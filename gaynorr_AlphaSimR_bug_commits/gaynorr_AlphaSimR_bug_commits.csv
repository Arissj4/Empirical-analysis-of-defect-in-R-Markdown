repo_owner,repo_name,commit_hash,author_name,author_email,author_date,committer_name,committer_email,committer_date,message,filenames,touches_rmd,touches_r,touches_r_or_rmd,is_merge,added,deleted,changed,diff
gaynorr,AlphaSimR,2f9204ac0232af9a9e5fccf575f7038e777fe65d,Gregor Gorjanc,gregor.gorjanc@gmail.com,2024-10-16T17:17:20Z,Gregor Gorjanc,gregor.gorjanc@gmail.com,2024-10-16T17:29:04Z,Fixing #205 (matrices in misc and mergePops),DESCRIPTION;NEWS.md;R/Class-Pop.R;R/mergePops.R;man/Pop-class.Rd;man/mapLoci.Rd;tests/testthat/test-misc.R,False,True,True,False,66,32,98,"---FILE: DESCRIPTION---
@@ -1,7 +1,7 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 1.6.0.9990
+Version: 1.6.1
 Date: 2024-08-22
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),

---FILE: NEWS.md---
@@ -1,3 +1,7 @@
+# AlphaSimR 1.6.1
+
+*fixed bug in `mergePops` and `[` (subset) methods - they were failing for populations that had a misc slot with a matrix - we now check if a misc slot element is a matrix and rbind them for `mergePops` and subset rows for `[` (assuming the first dimension represents individuals)
+
 # AlphaSimR 1.6.0
 
 *exported `meanEBV` and added `varEBV` to complement `meanP`/`varP` and `meanG`/`varG`

---FILE: R/Class-Pop.R---
@@ -377,7 +377,8 @@ isNamedMapPop = function(x) {
 #' Used by genomic selection models but otherwise ignored.
 #' @slot misc a list whose elements correspond to additional miscellaneous
 #' nodes with the items for individuals in the population (see example in
-#' \code{\link{newPop}}).
+#' \code{\link{newPop}}) - we support vectors and matrices or objects that
+#' have a generic length and subset method.
 #' This list is normally empty and exists solely as an
 #' open slot available for uses to store extra information about
 #' individuals.
@@ -462,8 +463,16 @@ setValidity(""Pop"",function(object){
   if(object@nInd!=length(object@fixEff)){
     errors = c(errors,""nInd!=length(fixEff)"")
   }
-  if(any(object@nInd!=sapply(object@misc, length))){
-    errors = c(errors,""any(nInd!=sapply(misc, length))"")
+  length2 = function(x){
+    if(is.matrix(x)){
+      ret = dim(x)[1]
+    }else{
+      ret = length(x)
+    }
+    return(ret)
+  }
+  if(any(object@nInd!=sapply(object@misc, length2))){
+    errors = c(errors,""any(nInd!=sapply(misc, length(x) or dim(x)[1]))"")
   }
   if(length(errors)==0){
     return(TRUE)
@@ -489,12 +498,19 @@ setMethod(""["",
                 stop(""Trying to select invalid individuals"")
               }
             }
+            subset2 = function(z){
+              if(is.matrix(z)){
+                return(z[i,,drop=FALSE])
+              }else{
+                return(z[i])
+              }
+            }
             x@id = x@id[i]
             x@iid = x@iid[i]
             x@mother = x@mother[i]
             x@father = x@father[i]
             x@fixEff = x@fixEff[i]
-            x@misc = lapply(x@misc, FUN = function(z) z[i])
+            x@misc = lapply(x@misc, FUN = subset2)
             x@miscPop = list()
             x@gv = x@gv[i,,drop=FALSE]
             x@pheno = x@pheno[i,,drop=FALSE]
@@ -796,7 +812,7 @@ resetPop = function(pop,simParam=NULL){
   pop@gv = matrix(NA_real_,nrow=pop@nInd,
                   ncol=simParam$nTraits)
   pop@fixEff = rep(1L,pop@nInd)
-  
+
   # Calculate genetic values
   for(i in seq_len(simParam$nTraits)){
     tmp = getGv(simParam$traits[[i]],pop,simParam$nThreads)
@@ -805,7 +821,7 @@ resetPop = function(pop,simParam=NULL){
       pop@gxe[[i]] = tmp[[2]]
     }
   }
-  
+
   # Add back trait names
   colnames(pop@pheno) = colnames(pop@gv) = traitNames
 
@@ -875,12 +891,12 @@ newEmptyPop = function(ploidy=2L, simParam=NULL){
                     ncol = simParam$nTraits)
 
   traitNames = character(simParam$nTraits)
-  
+
   # Get trait names
   for(i in seq_len(simParam$nTraits)){
     traitNames[i] = simParam$traits[[i]]@name
   }
-  
+
   colnames(traitMat) = traitNames
 
   # Create empty geno list

---FILE: R/mergePops.R---
@@ -43,52 +43,52 @@ mergePops = function(popList){
     classes = classes[-remove]
   }
   stopifnot(all(classes==""Pop""))
-  
+
   #nChr
   nChr = do.call(""c"",lapply(popList,
                             function(x) x@nChr))
   stopifnot(all(nChr==nChr[1]))
   nChr = nChr[1]
-  
+
   #ploidy
   ploidy = do.call(""c"",lapply(popList,
                               function(x) x@ploidy))
   stopifnot(all(ploidy==ploidy[1]))
   ploidy = ploidy[1]
-  
+
   #nLoci
   nLoci = do.call(""c"",lapply(popList,
                              function(x){
                                all(x@nLoci==popList[[1]]@nLoci)
                              }))
   stopifnot(all(nLoci))
   nLoci = popList[[1]]@nLoci
-  
+
   #id
   id = do.call(""c"",
                lapply(popList,
                       function(x) x@id))
-  
+
   #iid
   iid = do.call(""c"",
                 lapply(popList,
                        function(x) x@iid))
-  
+
   #mother
   mother = do.call(""c"",
                    lapply(popList,
                           function(x) x@mother))
-  
+
   #father
   father= do.call(""c"",
                   lapply(popList,
                          function(x) x@father))
-  
+
   #fixEff
   fixEff= do.call(""c"",
                   lapply(popList,
                          function(x) x@fixEff))
-  
+
   #misc
   tmp = sapply(popList, function(x) length(x@misc))
   if(all(tmp == tmp[1]) & tmp[1]>0) {
@@ -106,7 +106,11 @@ mergePops = function(popList){
       misc = vector(""list"", length=length(tmp[[1]]))
       for(i in seq_len(length(tmp[[1]]))){
         miscTmp = lapply(popList, function(x) x@misc[[i]])
-        misc[[i]] = do.call(""c"", miscTmp)
+        if (is.matrix(miscTmp[[1]])) {
+          misc[[i]] = do.call(""rbind"", miscTmp)
+        } else {
+          misc[[i]] = do.call(""c"", miscTmp)
+        }
       }
       names(misc) = tmp[[1]]
     }else{
@@ -115,30 +119,30 @@ mergePops = function(popList){
   } else {
     misc = list()
   }
-  
+
   #sex
   sex = do.call(""c"",
                    lapply(popList,
                           function(x) x@sex))
-  
+
   #nTraits
   nTraits = do.call(""c"",lapply(popList,
                                function(x) x@nTraits))
   stopifnot(all(nTraits==nTraits[1]))
   nTraits = nTraits[1]
-  
+
   #nInd
   nInd = do.call(""c"",lapply(popList,
                             function(x) x@nInd))
-  
+
   #gv
   gv = do.call(""rbind"",lapply(popList,
                               function(x) x@gv))
-  
+
   #pheno
   pheno = do.call(""rbind"",lapply(popList,
                                  function(x) x@pheno))
-  
+
   #ebv
   ebv = do.call(""c"",lapply(popList,
                            function(x) ncol(x@ebv)))
@@ -148,7 +152,7 @@ mergePops = function(popList){
   }else{
     ebv = matrix(NA_real_,nrow=sum(nInd),ncol=0)
   }
-  
+
   #gxe
   if(nTraits>=1){
     gxe = vector(""list"",length=nTraits)
@@ -162,12 +166,12 @@ mergePops = function(popList){
   }else{
     gxe = list()
   }
-  
+
   #geno
   nBin = as.integer(nLoci%/%8L + (nLoci%%8L > 0L))
   geno = mergeMultGeno(popList,nInd=nInd,nBin=nBin,ploidy=ploidy)
   dim(geno) = NULL # Account for matrix bug in RcppArmadillo
-  
+
   #wrap it all up into a Pop
   nInd = sum(nInd)
   return(new(""Pop"",

---FILE: man/Pop-class.Rd---
@@ -73,7 +73,8 @@ Used by genomic selection models but otherwise ignored.}
 
 \item{\code{misc}}{a list whose elements correspond to additional miscellaneous
 nodes with the items for individuals in the population (see example in
-\code{\link{newPop}}).
+\code{\link{newPop}}) - we support vectors and matrices or objects that
+have a generic length and subset method.
 This list is normally empty and exists solely as an
 open slot available for uses to store extra information about
 individuals.}

---FILE: man/mapLoci.Rd---
@@ -2,7 +2,7 @@
 % Please edit documentation in R/pullGeno.R
 \name{mapLoci}
 \alias{mapLoci}
-\title{Find positions of loci by marker name}
+\title{Finds positions of loci by marker name}
 \usage{
 mapLoci(markers, genMap)
 }
@@ -17,7 +17,8 @@ A list containing lociPerChr and lociLoc
 that can be
 }
 \description{
-Retrieves the genetic map for a 
-given SNP chip.
+Used to generate lociPerChr and lociLoc 
+objects for a set of markers. These objects can be passed 
+other functions for pulling genotypes or haplotypes.
 }
 \keyword{internal}

---FILE: tests/testthat/test-misc.R---
@@ -16,35 +16,43 @@ test_that(""misc_and_miscPop"",{
 
   pop = popOrig
   pop@misc$vec = rnorm(n=2)
+  pop@misc$mat = matrix(1:4, nrow=2)
   pop@misc$mtP = popOrig # hmm, should this actually be multiple pop objects or one with multiple individuals?
   pop@misc$mtLP = list(popOrig, popOrig)
   pop@misc$mtMP = multiPop
+  # setting these miscPop elements just as an example - we are not testing them below,
+  # because they get dropped in most/all operations on a pop
   pop@miscPop$vec = sum(pop@misc$vec)
   pop@miscPop$af = colMeans(pullSegSiteGeno(pop, simParam=SP))
+  pop@miscPop$mat = matrix(1:4, nrow=2)
 
   popSub = pop[1]
   expect_equal(popSub@misc$vec, pop@misc$vec[1])
+  expect_equal(popSub@misc$mat, pop@misc$mat[1, , drop=FALSE])
   expect_equal(popSub@misc$mtP, pop@misc$mtP[1])
   expect_equal(popSub@misc$mtLP, pop@misc$mtLP[1])
   expect_equal(popSub@misc$mtMP, pop@misc$mtMP[1])
   expect_equal(popSub@miscPop, list())
 
   popSub = pop[0]
   expect_equal(popSub@misc$vec, numeric(0))
+  expect_equal(popSub@misc$mat, pop@misc$mat[0, , drop=FALSE])
   expect_equal(popSub@misc$mtP, newEmptyPop(simParam=SP))
   expect_equal(popSub@misc$mtLP, list())
   expect_equal(popSub@misc$mtMP, new(""MultiPop"", pops=list()))
   expect_equal(popSub@miscPop, list())
 
   popC = c(pop, pop)
   expect_equal(popC@misc$vec, c(pop@misc$vec, pop@misc$vec))
+  expect_equal(popC@misc$mat, rbind(pop@misc$mat, pop@misc$mat))
   expect_equal(popC@misc$mtP, c(pop@misc$mtP, pop@misc$mtP))
   expect_equal(popC@misc$mtLP, c(pop@misc$mtLP, pop@misc$mtLP))
   expect_equal(popC@misc$mtMP, c(pop@misc$mtMP, pop@misc$mtMP))
   expect_equal(popC@miscPop, list())
 
   popC = c(pop, pop[1])
   expect_equal(popC@misc$vec, c(pop@misc$vec, pop@misc$vec[1]))
+  expect_equal(popC@misc$mat, rbind(pop@misc$mat, pop@misc$mat[1, ]))
   expect_equal(popC@misc$mtP, c(pop@misc$mtP, pop@misc$mtP[1]))
   expect_equal(popC@misc$mtLP, c(pop@misc$mtLP, pop@misc$mtLP[1]))
   expect_equal(popC@misc$mtMP, c(pop@misc$mtMP, pop@misc$mtMP[1]))"
gaynorr,AlphaSimR,c072aed0ed08010aae1c2ba7e9576396e25dcffb,Chris Gaynor,gaynor.robert@hotmail.com,2024-04-20T20:23:20Z,Chris Gaynor,gaynor.robert@hotmail.com,2024-04-20T20:23:20Z,fix to `mergePops` handling of misc slot,R/mergePops.R,False,True,True,False,37,8,45,"---FILE: R/mergePops.R---
@@ -43,76 +43,102 @@ mergePops = function(popList){
     classes = classes[-remove]
   }
   stopifnot(all(classes==""Pop""))
+  
   #nChr
   nChr = do.call(""c"",lapply(popList,
                             function(x) x@nChr))
   stopifnot(all(nChr==nChr[1]))
   nChr = nChr[1]
+  
   #ploidy
   ploidy = do.call(""c"",lapply(popList,
                               function(x) x@ploidy))
   stopifnot(all(ploidy==ploidy[1]))
   ploidy = ploidy[1]
+  
   #nLoci
   nLoci = do.call(""c"",lapply(popList,
                              function(x){
                                all(x@nLoci==popList[[1]]@nLoci)
                              }))
   stopifnot(all(nLoci))
   nLoci = popList[[1]]@nLoci
+  
   #id
   id = do.call(""c"",
                lapply(popList,
                       function(x) x@id))
+  
   #iid
   iid = do.call(""c"",
                 lapply(popList,
                        function(x) x@iid))
+  
   #mother
   mother = do.call(""c"",
                    lapply(popList,
                           function(x) x@mother))
+  
   #father
   father= do.call(""c"",
                   lapply(popList,
                          function(x) x@father))
+  
   #fixEff
   fixEff= do.call(""c"",
                   lapply(popList,
                          function(x) x@fixEff))
+  
   #misc
   tmp = sapply(popList, function(x) length(x@misc))
-  if(any(tmp > 0)) {
-    if(!any(tmp == tmp[1])){
-      stop(""misc list must have the same number of nodes in all populations"")
+  if(all(tmp == tmp[1]) & tmp[1]>0) {
+    tmp = lapply(popList, function(x) names(x@misc))
+    allMatch = TRUE
+    if(length(tmp)>1){
+      for(i in 2:length(tmp)){
+        if(!all(tmp[[1]]==tmp[[i]])){
+          allMatch = FALSE
+          break
+        }
+      }
     }
-    tmp = sapply(popList, function(x) names(x@misc))
-    if(!any(apply(tmp, MARGIN = 1, function(x) all(x == x[1])))){
-      stop(""misc list must have the same nodes in the same order for all populations"")
+    if(allMatch){
+      misc = vector(""list"", length=length(tmp[[1]]))
+      for(i in 1:length(tmp[[1]])){
+        miscTmp = lapply(popList, function(x) x@misc[[i]])
+        misc[[i]] = do.call(""c"", miscTmp)
+      }
+      names(misc) = tmp[[1]]
+    }else{
+      misc = list()
     }
-    misc = .mapply(""c"", lapply(popList, function(x) x@misc), MoreArgs = NULL)
-    names(misc) = names(popList[[1]]@misc)
   } else {
     misc = list()
   }
+  
   #sex
   sex = do.call(""c"",
                    lapply(popList,
                           function(x) x@sex))
+  
   #nTraits
   nTraits = do.call(""c"",lapply(popList,
                                function(x) x@nTraits))
   stopifnot(all(nTraits==nTraits[1]))
   nTraits = nTraits[1]
+  
   #nInd
   nInd = do.call(""c"",lapply(popList,
                             function(x) x@nInd))
+  
   #gv
   gv = do.call(""rbind"",lapply(popList,
                               function(x) x@gv))
+  
   #pheno
   pheno = do.call(""rbind"",lapply(popList,
                                  function(x) x@pheno))
+  
   #ebv
   ebv = do.call(""c"",lapply(popList,
                            function(x) ncol(x@ebv)))
@@ -122,6 +148,7 @@ mergePops = function(popList){
   }else{
     ebv = matrix(NA_real_,nrow=sum(nInd),ncol=0)
   }
+  
   #gxe
   if(nTraits>=1){
     gxe = vector(""list"",length=nTraits)
@@ -135,10 +162,12 @@ mergePops = function(popList){
   }else{
     gxe = list()
   }
+  
   #geno
   nBin = as.integer(nLoci%/%8L + (nLoci%%8L > 0L))
   geno = mergeMultGeno(popList,nInd=nInd,nBin=nBin,ploidy=ploidy)
   dim(geno) = NULL # Account for matrix bug in RcppArmadillo
+  
   #wrap it all up into a Pop
   nInd = sum(nInd)
   return(new(""Pop"","
gaynorr,AlphaSimR,c6e2f2daa9ec08316be87ecbdaf7226cc678ad90,Chris Gaynor,gaynor.robert@hotmail.com,2024-04-19T21:13:14Z,Chris Gaynor,gaynor.robert@hotmail.com,2024-04-19T21:13:14Z,fix for #188,DESCRIPTION;R/Class-SimParam.R,False,True,True,False,4,6,10,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
 Version: 1.5.3.9990
-Date: 2024-04-05
+Date: 2024-04-19
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: R/Class-SimParam.R---
@@ -1597,12 +1597,10 @@ SimParam = R6Class(
       private$.varA[traitPos] = popVar(tmp$bv)[1]
       private$.varG[traitPos] = popVar(tmp$gv)[1]
       if(is.matrix(private$.varE)){
-        private$.varE[traitPos,] = 0
-        private$.varE[,traitPos] = 0
-        private$.varE[traitPos,traitPos] = varE
-      }else{
-        private$.varE[traitPos] = varE
+        warning(""Error correlations have been removed, use setVarE to reinstate"")
+        private$.varE = diag(private$.varE)
       }
+      private$.varE[traitPos] = varE
       invisible(self)
     },
 "
gaynorr,AlphaSimR,304f912dd5ce74498901221c5d34dbe7f6cc9b70,Chris Gaynor,gaynor.robert@hotmail.com,2024-04-05T16:06:30Z,Chris Gaynor,gaynor.robert@hotmail.com,2024-04-05T16:06:30Z,fixed to findQuadrivalentCO to properly account for position of centromere,DESCRIPTION;src/meiosis.cpp,False,False,False,False,88,44,132,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
 Version: 1.5.3.9990
-Date: 2024-03-14
+Date: 2024-04-05
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: src/meiosis.cpp---
@@ -127,6 +127,7 @@ arma::vec sampleChiasmata(double start, double end, double v,
     return sort(join_cols(type1, type2));
   }
 }
+
 // Samples the locations for chiasmata via a gamma process for a quadrivalent
 // CO interference is assumed to occur between all arms
 // The first arm is sampled at random
@@ -381,25 +382,35 @@ arma::field<arma::Mat<int> > findQuadrivalentCO(const arma::vec& genMap,
   // Sample the exchange point
   arma::vec u(1, arma::fill::randu);
   double exchange = u(0)*genLen;
+  
+  // Sample start point for gamma model
   u.randu();
   double start = u(0)-10;
   
-  // Determine crossover postions
+  // Determine crossover positions
+  // Returns field with crossover positions in each arm of the quadrivalent
   arma::field<arma::vec> posCO = sampleQuadChiasmata(start, exchange, genLen, v, p);
   
-  // Set chromatid configuration for chiasmata
-  arma::field<arma::umat> chromatidPairs(4);
+  // Set chromatid configuration for each chiasmata
+  arma::field<arma::umat> chromatidPairs(4); // matches posCO
   for(arma::uword i=0; i<4; ++i){
+    // Create table for chromatid pairs on an arm
     chromatidPairs(i).set_size(posCO(i).n_elem,2);
+    
+    // Assign pairs if there are chiasmata
     if(chromatidPairs(i).n_rows>0){
+      // Initializing with ""0"" chromatid
       chromatidPairs(i).zeros();
+      
+      // Randomly switch to ""1"" chromatid
       for(arma::uword j=0; j<chromatidPairs(i).n_elem; ++j){
         u.randu();
         if(u(0)>0.5){
           chromatidPairs(i).at(j) = 1;
         }
       }
     }
+    
   }
   
   // Allocate output with a naive maximum number of COs
@@ -412,49 +423,62 @@ arma::field<arma::Mat<int> > findQuadrivalentCO(const arma::vec& genMap,
   output(1).set_size(maxCO+1,2);
   
   // Select centromeres (which chromosome and chromatid)
+  // Always taking chromosome 1 (1-4) and chromatid 1 (0-1) 
   arma::uvec chromosome(2, arma::fill::ones);
   arma::uvec chromatid(2, arma::fill::ones);
-  chromosome(1) = sampleInt(1,3)(0) + 2;
-  chromatid(1) = sampleInt(1,2)(0);
+  chromosome(1) = sampleInt(1,3)(0) + 2; // 2-4
+  chromatid(1) = sampleInt(1,2)(0); // 0-1
   
-  // Loop through each of the selected centromeres
+  // Find starting chromosomes and chromatids by working backwards
+  // from selected centromeres to start of chromosome (head)
   arma::uword currentChromosome, currentChromatid;
   for(arma::uword i=0; i<2; ++i){
     // Identify starting chromosome and chromatid
     currentChromosome = chromosome(i);
     currentChromatid = chromatid(i);
-    if(exchange<centromere){ // Centromere is in the head
+    
+    if(exchange>centromere){ // Centromere is in the head 
+      
       if(currentChromosome<3){ // currentChromosome is 1 or 2
-        // Account for all crossovers prior to the centromere
+        
+        // Loop through all chiasmata on arm 0
         for(arma::uword j=posCO(0).n_elem; j>0; --j){
+          
+          // Check if chiasmata is before centromere, ignore if not
           if(posCO(0)(j-1)<centromere){
+            
             switch(currentChromosome){
-            case 1:
+            case 1: // Check if there's a switch between chr 1 and 2
               if(chromatidPairs(0)(j-1,0) == currentChromatid){
                 currentChromosome = 2;
                 currentChromatid = chromatidPairs(0)(j-1,1);
               }
               break;
-            case 2:
+            case 2: // Check if there is a switch between chr 2 and 1
               if(chromatidPairs(0)(j-1,1) == currentChromatid){
                 currentChromosome = 1;
                 currentChromatid = chromatidPairs(0)(j-1,0);
               }
             }
           }
         }
+        
       }else{ // currentChromosome is 3 or 4
-        // Account for all crossovers prior to the centromere
+        
+        // Loop through all chiasmata on arm 2
         for(arma::uword j=posCO(2).n_elem; j>0; --j){
+          
+          // Check if chiasmata is before centromere, ignore if not
           if(posCO(2)(j-1)<centromere){
+            
             switch(currentChromosome){
-            case 3:
+            case 3: // Check if there's a switch between chr 3 and 4
               if(chromatidPairs(2)(j-1,0) == currentChromatid){
                 currentChromosome = 4;
                 currentChromatid = chromatidPairs(2)(j-1,1);
               }
               break;
-            case 4:
+            case 4: // Check if there's a switch between chr 4 and 3
               if(chromatidPairs(2)(j-1,1) == currentChromatid){
                 currentChromosome = 3;
                 currentChromatid = chromatidPairs(2)(j-1,0);
@@ -463,55 +487,62 @@ arma::field<arma::Mat<int> > findQuadrivalentCO(const arma::vec& genMap,
           }
         }
       }
+      
     }else{ // Centromere is in the tail
-      if((currentChromosome==1) | (currentChromosome==4)){ 
-        // Find chromosome and chromatid before transition
+      
+      if((currentChromosome==1) | (currentChromosome==4)){ // Working on arm 3
+        
+        // Find chromosome and chromatid before transition by looping 
+        // through chiasmata on arm 3
         for(arma::uword j=posCO(3).n_elem; j>0; --j){
+          
+          // Check if chiasmata is before centromere, ignore if not
           if(posCO(3)(j-1)<centromere){
             switch(currentChromosome){
-            case 1:
+            case 1: // Check if there's a switch between chr 1 and 4
               if(chromatidPairs(3)(j-1,0) == currentChromatid){
                 currentChromosome = 4;
                 currentChromatid = chromatidPairs(3)(j-1,1);
               }
               break;
-            case 4:
+            case 4: // Check if there's a switch between chr 4 and 1
               if(chromatidPairs(3)(j-1,1) == currentChromatid){
                 currentChromosome = 1;
                 currentChromatid = chromatidPairs(3)(j-1,0);
               }
             }
           }
         }
-        // Find starting chromosome and chromatid
+        
+        // Find starting chromosome and chromatid by working back through head
         switch(currentChromosome){
-        case 1:
+        case 1: // Work through arm 0
           for(arma::uword j=posCO(0).n_elem; j>0; --j){
             switch(currentChromosome){
-            case 1:
+            case 1: // Check if there's a switch between chr 1 and 2
               if(chromatidPairs(0)(j-1,0) == currentChromatid){
                 currentChromosome = 2;
                 currentChromatid = chromatidPairs(0)(j-1,1);
               }
               break;
-            case 2:
+            case 2: // Check if there's a switch between chr 2 and 1
               if(chromatidPairs(0)(j-1,1) == currentChromatid){
                 currentChromosome = 1;
                 currentChromatid = chromatidPairs(0)(j-1,0);
               }
             }
           }
           break;
-        case 4:
+        case 4: // Work through arm 2
           for(arma::uword j=posCO(2).n_elem; j>0; --j){
             switch(currentChromosome){
-            case 3:
+            case 3: // Check if there's a switch between chr 3 and 4
               if(chromatidPairs(2)(j-1,0) == currentChromatid){
                 currentChromosome = 4;
                 currentChromatid = chromatidPairs(2)(j-1,1);
               }
               break;
-            case 4:
+            case 4: // Check if there's a switch between chr 4 and 3
               if(chromatidPairs(2)(j-1,1) == currentChromatid){
                 currentChromosome = 3;
                 currentChromatid = chromatidPairs(2)(j-1,0);
@@ -520,54 +551,59 @@ arma::field<arma::Mat<int> > findQuadrivalentCO(const arma::vec& genMap,
           }
         }
         
-      }else{ // currentChromosome is 2 or 3
-        // Find chromosome and chromatid before transition
+      }else{ // Working on arm 1
+        
+        // Find chromosome and chromatid before transition by looping 
+        // through chiasmata on arm 1
         for(arma::uword j=posCO(1).n_elem; j>0; --j){
+          
+          // Check if chiasmata is before centromere, ignore if not
           if(posCO(1)(j-1)<centromere){
             switch(currentChromosome){
-            case 2:
+            case 2: // Check if there's a switch between chr 2 and 3
               if(chromatidPairs(1)(j-1,0) == currentChromatid){
                 currentChromosome = 3;
                 currentChromatid = chromatidPairs(1)(j-1,1);
               }
               break;
-            case 3:
+            case 3: // Check if there's a switch between chr 3 and 2
               if(chromatidPairs(1)(j-1,1) == currentChromatid){
                 currentChromosome = 2;
                 currentChromatid = chromatidPairs(1)(j-1,0);
               }
             }
           }
         }
-        // Find starting chromosome and chromatid
+        
+        // Find starting chromosome and chromatid by working back through head
         switch(currentChromosome){
-        case 2:
+        case 2: // Work through arm 0
           for(arma::uword j=posCO(0).n_elem; j>0; --j){
             switch(currentChromosome){
-            case 1:
+            case 1: // Check if there's a switch between chr 1 and 2
               if(chromatidPairs(0)(j-1,0) == currentChromatid){
                 currentChromosome = 2;
                 currentChromatid = chromatidPairs(0)(j-1,1);
               }
               break;
-            case 2:
+            case 2: // Check if there's a switch between chr 2 and 1
               if(chromatidPairs(0)(j-1,1) == currentChromatid){
                 currentChromosome = 1;
                 currentChromatid = chromatidPairs(0)(j-1,0);
               }
             }
           }
           break;
-        case 3:
+        case 3: // Work through arm 2
           for(arma::uword j=posCO(2).n_elem; j>0; --j){
             switch(currentChromosome){
-            case 3:
+            case 3: // Check if there's a switch between chr 3 and 4
               if(chromatidPairs(2)(j-1,0) == currentChromatid){
                 currentChromosome = 4;
                 currentChromatid = chromatidPairs(2)(j-1,1);
               }
               break;
-            case 4:
+            case 4: // Check if there's a switch between chr 4 and 3
               if(chromatidPairs(2)(j-1,1) == currentChromatid){
                 currentChromosome = 3;
                 currentChromatid = chromatidPairs(2)(j-1,0);
@@ -578,15 +614,19 @@ arma::field<arma::Mat<int> > findQuadrivalentCO(const arma::vec& genMap,
       }
     }
     
-    // Fill in crossover map
+    // Fill in crossover map by working from head to tail
     arma::uword startPos=0, endPos, nCO=0;
     output(i)(0,0) = currentChromosome;
     output(i)(0,1) = 1;
-    if(currentChromosome<3){
+    
+    if(currentChromosome<3){ // Start in arm 0
+      
       // Fill crossovers in the head
       for(arma::uword j=0; j<posCO(0).n_elem; ++j){
+        
+        // Check if chiasmata involves current chromatid
         switch(currentChromosome){
-        case 1:
+        case 1: 
           if(chromatidPairs(0)(j,0) == currentChromatid){
             currentChromosome = 2;
             currentChromatid = chromatidPairs(0)(j,1);
@@ -609,8 +649,9 @@ arma::field<arma::Mat<int> > findQuadrivalentCO(const arma::vec& genMap,
           }
         }
       }
+      
       // Fill crossovers in the tail
-      if(currentChromosome==1){
+      if(currentChromosome==1){ // Move to arm 3
         for(arma::uword j=0; j<posCO(3).n_elem; ++j){
           switch(currentChromosome){
           case 1:
@@ -636,7 +677,7 @@ arma::field<arma::Mat<int> > findQuadrivalentCO(const arma::vec& genMap,
             }
           }
         }
-      }else{ // currentChromosome = 2
+      }else{ // currentChromosome = 2, move to arm 1
         for(arma::uword j=0; j<posCO(1).n_elem; ++j){
           switch(currentChromosome){
           case 2:
@@ -663,7 +704,8 @@ arma::field<arma::Mat<int> > findQuadrivalentCO(const arma::vec& genMap,
           }
         }
       }
-    }else{
+    }else{ // currentChromosome>2, start in arm 2
+      
       // Fill crossovers in the head
       for(arma::uword j=0; j<posCO(2).n_elem; ++j){
         switch(currentChromosome){
@@ -690,8 +732,9 @@ arma::field<arma::Mat<int> > findQuadrivalentCO(const arma::vec& genMap,
           }
         }
       }
+      
       // Fill crossovers in the tail
-      if(currentChromosome==4){
+      if(currentChromosome==4){ // Move to arm 3
         for(arma::uword j=0; j<posCO(3).n_elem; ++j){
           switch(currentChromosome){
           case 1:
@@ -717,7 +760,7 @@ arma::field<arma::Mat<int> > findQuadrivalentCO(const arma::vec& genMap,
             }
           }
         }
-      }else{ // currentChromosome = 3
+      }else{ // currentChromosome = 3, move to arm 1
         for(arma::uword j=0; j<posCO(1).n_elem; ++j){
           switch(currentChromosome){
           case 2:
@@ -748,6 +791,7 @@ arma::field<arma::Mat<int> > findQuadrivalentCO(const arma::vec& genMap,
     output(i) = output(i).rows(arma::span(0,nCO));
     output(i) = removeDoubleCO(output(i));
   }
+  
   return output;
 }
 "
gaynorr,AlphaSimR,b62e5745e739a5acbd442be745b11388bd375a77,Chris Gaynor,gaynor.robert@hotmail.com,2024-01-24T21:57:07Z,Chris Gaynor,gaynor.robert@hotmail.com,2024-01-24T21:57:07Z,fix for #175,R/importData.R,False,True,True,False,1,1,2,"---FILE: R/importData.R---
@@ -276,7 +276,7 @@ importHaplo = function(haplo, genMap, ploidy=2L, ped=NULL){
       genMap[[i]] = genMap[[i]] - genMap[[i]]-genMap[[i]][1]
       take = na.omit(take)
     }
-    haplotypes[[i]] = haplo[,take]
+    haplotypes[[i]] = haplo[,take,drop=FALSE]
   }
   
   founderPop = newMapPop(genMap=genMap,"
gaynorr,AlphaSimR,e7b4eea80ca373eddbd32127ea092f48f667840a,Chris Gaynor,gaynor.robert@hotmail.com,2023-11-30T23:18:28Z,Chris Gaynor,gaynor.robert@hotmail.com,2023-11-30T23:18:28Z,fixed bug in `SimParam$restrSegSites` with excluding sites at end of chromosome,DESCRIPTION;NEWS.md;R/Class-SimParam.R,False,True,True,False,7,3,10,"---FILE: DESCRIPTION---
@@ -1,8 +1,8 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 1.5.2
-Date: 2023-10-31
+Version: 1.5.3
+Date: 2023-11-30
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: NEWS.md---
@@ -1,3 +1,7 @@
+# AlphaSimR 1.5.3
+
+*fixed bug in `SimParam$restrSegSites` with excluding sites at end of chromosome
+
 # AlphaSimR 1.5.2
 
 *fix SimParam examples for CRAN

---FILE: R/Class-SimParam.R---
@@ -2235,7 +2235,7 @@ SimParam = R6Class(
       cumSumSegSite = cumsum(private$.segSites)
       for(i in take){
         # Identify chromosome
-        chr = findInterval(i, cumSumSegSite) + 1L
+        chr = findInterval(i, cumSumSegSite, left.open = TRUE) + 1L
         
         # Identify position
         if(chr>1L){"
gaynorr,AlphaSimR,3ada1fbfbf724e918c1b3001928733a97ad7347f,Chris Gaynor,gaynor.robert@hotmail.com,2023-10-31T23:38:36Z,Chris Gaynor,gaynor.robert@hotmail.com,2023-10-31T23:38:36Z,second round of example fixes for SimParam,DESCRIPTION;NEWS.md;R/Class-SimParam.R;man/SimParam.Rd;vignettes/intro.R,False,True,True,False,34,1,35,"---FILE: DESCRIPTION---
@@ -1,7 +1,7 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 1.5.1
+Version: 1.5.2
 Date: 2023-10-31
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),

---FILE: NEWS.md---
@@ -1,3 +1,7 @@
+# AlphaSimR 1.5.2
+
+*fix SimParam examples for CRAN
+
 # AlphaSimR 1.5.1
 
 *deleted bad example code for `setMisc`

---FILE: R/Class-SimParam.R---
@@ -110,6 +110,7 @@ SimParam = R6Class(
     #'
     #' #Set simulation parameters
     #' SP = SimParam$new(founderPop)
+    #' \dontshow{SP$nThreads = 1L}
     #' SP$setTrackPed(TRUE)
     setTrackPed = function(isTrackPed, force=FALSE){
       stopifnot(is.logical(isTrackPed))
@@ -140,6 +141,7 @@ SimParam = R6Class(
     #'
     #' #Set simulation parameters
     #' SP = SimParam$new(founderPop)
+    #' \dontshow{SP$nThreads = 1L}
     #' SP$setTrackRec(TRUE)
     setTrackRec = function(isTrackRec, force=FALSE){
       stopifnot(is.logical(isTrackRec))
@@ -167,6 +169,7 @@ SimParam = R6Class(
     #'
     #' #Set simulation parameters
     #' SP = SimParam$new(founderPop)
+    #' \dontshow{SP$nThreads = 1L}
     #'
     #' #Create population
     #' pop = newPop(founderPop, simParam=SP)
@@ -206,6 +209,7 @@ SimParam = R6Class(
     #'
     #' #Set simulation parameters
     #' SP = SimParam$new(founderPop)
+    #' \dontshow{SP$nThreads = 1L}
     #' SP$restrSegSites(minQtlPerChr=5, minSnpPerChr=5)
     restrSegSites = function(minQtlPerChr=NULL, minSnpPerChr=NULL, excludeQtl=NULL,
                              excludeSnp=NULL, overlap=FALSE, minSnpFreq=NULL){
@@ -299,6 +303,7 @@ SimParam = R6Class(
     #'
     #' #Set simulation parameters
     #' SP = SimParam$new(founderPop)
+    #' \dontshow{SP$nThreads = 1L}
     #' SP$setSexes(""yes_sys"")
     setSexes = function(sexes, force=FALSE){
       if(!force){
@@ -346,6 +351,7 @@ SimParam = R6Class(
     #'
     #' #Set simulation parameters
     #' SP = SimParam$new(founderPop)
+    #' \dontshow{SP$nThreads = 1L}
     #' SP$addSnpChip(10)
     addSnpChip = function(nSnpPerChr, minSnpFreq=NULL, refPop=NULL, name=NULL){
       if(length(nSnpPerChr)==1){
@@ -1299,6 +1305,7 @@ SimParam = R6Class(
     #'
     #' #Set simulation parameters
     #' SP = SimParam$new(founderPop)
+    #' \dontshow{SP$nThreads = 1L}
     #' SP$addTraitADEG(10, meanDD=0.5, varGxE=2)
     addTraitADEG = function(nQtlPerChr,mean=0,var=1,varEnv=0,
                             varGxE=1e-6,meanDD=0,varDD=0,relAA=0,corA=NULL,
@@ -1857,6 +1864,7 @@ SimParam = R6Class(
     #'
     #' #Set simulation parameters
     #' SP = SimParam$new(founderPop)
+    #' \dontshow{SP$nThreads = 1L}
     #' SP$setRecombRatio(2) #Twice as much recombination in females
     setRecombRatio = function(femaleRatio){
       stopifnot(femaleRatio>0)

---FILE: man/SimParam.Rd---
@@ -35,6 +35,7 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)
+\dontshow{SP$nThreads = 1L}
 SP$setTrackPed(TRUE)
 
 ## ------------------------------------------------
@@ -46,6 +47,7 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)
+\dontshow{SP$nThreads = 1L}
 SP$setTrackRec(TRUE)
 
 ## ------------------------------------------------
@@ -57,6 +59,7 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)
+\dontshow{SP$nThreads = 1L}
 
 #Create population
 pop = newPop(founderPop, simParam=SP)
@@ -76,6 +79,7 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)
+\dontshow{SP$nThreads = 1L}
 SP$restrSegSites(minQtlPerChr=5, minSnpPerChr=5)
 
 ## ------------------------------------------------
@@ -87,6 +91,7 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)
+\dontshow{SP$nThreads = 1L}
 SP$setSexes(""yes_sys"")
 
 ## ------------------------------------------------
@@ -98,6 +103,7 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)
+\dontshow{SP$nThreads = 1L}
 SP$addSnpChip(10)
 
 ## ------------------------------------------------
@@ -216,6 +222,7 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)
+\dontshow{SP$nThreads = 1L}
 SP$addTraitADEG(10, meanDD=0.5, varGxE=2)
 
 ## ------------------------------------------------
@@ -277,6 +284,7 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)
+\dontshow{SP$nThreads = 1L}
 SP$setRecombRatio(2) #Twice as much recombination in females
 }
 \section{Public fields}{
@@ -479,6 +487,7 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)
+\dontshow{SP$nThreads = 1L}
 SP$setTrackPed(TRUE)
 }
 \if{html}{\out{</div>}}
@@ -517,6 +526,7 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)
+\dontshow{SP$nThreads = 1L}
 SP$setTrackRec(TRUE)
 }
 \if{html}{\out{</div>}}
@@ -551,6 +561,7 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)
+\dontshow{SP$nThreads = 1L}
 
 #Create population
 pop = newPop(founderPop, simParam=SP)
@@ -612,6 +623,7 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)
+\dontshow{SP$nThreads = 1L}
 SP$restrSegSites(minQtlPerChr=5, minSnpPerChr=5)
 }
 \if{html}{\out{</div>}}
@@ -653,6 +665,7 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)
+\dontshow{SP$nThreads = 1L}
 SP$setSexes(""yes_sys"")
 }
 \if{html}{\out{</div>}}
@@ -710,6 +723,7 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)
+\dontshow{SP$nThreads = 1L}
 SP$addSnpChip(10)
 }
 \if{html}{\out{</div>}}
@@ -1464,6 +1478,7 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)
+\dontshow{SP$nThreads = 1L}
 SP$addTraitADEG(10, meanDD=0.5, varGxE=2)
 }
 \if{html}{\out{</div>}}
@@ -1748,6 +1763,7 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)
+\dontshow{SP$nThreads = 1L}
 SP$setRecombRatio(2) #Twice as much recombination in females
 }
 \if{html}{\out{</div>}}

---FILE: vignettes/intro.R---
@@ -34,6 +34,11 @@ founderPop = quickHaplo(nInd=1000, nChr=10, segSites=1000)
 
 # Setting Simulation Parameters
 SP = SimParam$new(founderPop)
+
+## ----include=FALSE------------------------------------------------------------
+SP$nThreads = 1L
+
+## -----------------------------------------------------------------------------
 SP$addTraitA(nQtlPerChr=1000)
 SP$setSexes(""yes_sys"")
 "
gaynorr,AlphaSimR,28bc0655a7490d1b08ee8e9abc163c0ae5423ebf,Chris Gaynor,gaynor.robert@hotmail.com,2023-10-30T19:08:15Z,Chris Gaynor,gaynor.robert@hotmail.com,2023-10-30T19:08:15Z,fixed CRAN notes,DESCRIPTION;R/misc.R,False,True,True,False,6,7,13,"---FILE: DESCRIPTION---
@@ -1,7 +1,7 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 1.5.0
+Version: 1.5.1
 Date: 2023-10-30
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
@@ -32,8 +32,7 @@ Description: The successor to the 'AlphaSim' software for breeding program
   demographic history [Chen et al. (2009) <doi:10.1101/gr.083634.108>].
 License: MIT + file LICENSE
 URL: https://github.com/gaynorr/AlphaSimR,
-    https://gaynorr.github.io/AlphaSimR/,
-    https://www.edx.org/course/breeding-programme-modelling-with-alphasimr?utm_source=breeding_alphasimr&utm_medium=partner-marketing&utm_campaign=edinburghx
+    https://gaynorr.github.io/AlphaSimR/
 Encoding: UTF-8
 Depends: R (>= 4.0.0), methods, R6
 Imports: Rcpp (>= 0.12.7), Rdpack

---FILE: R/misc.R---
@@ -75,19 +75,19 @@ isMale <- function(x) {
 #' 
 #' n <- nInd(basePop)
 #' location <- vector(mode = ""list"", length = n)
-#' for (ind in seq_len(n)) {
+#' for (ind in seq_len(n)) 
 #'   location[[ind]] <- runif(n = 2, min = 0, max = 100)
-#' }
+#' 
 #' location
 #' basePop <- setMisc(basePop, node = ""location"", value = location)
 #' basePop@misc
 #' getMisc(x = basePop, node = ""location"")
 #' 
 #' n <- nInd(basePop)
 #' location <- vector(mode = ""list"", length = n)
-#' for (ind in c(1, 3)) {
+#' for (ind in c(1, 3)) 
 #'   location[[ind]] <- runif(n = 2, min = 0, max = 100)
-#' }
+#' 
 #' location
 #' basePop <- setMisc(basePop, node = ""location"", value = location)
 #' basePop@misc"
gaynorr,AlphaSimR,cb1d099c4fe2d9db10bd9b4bb5c1da090738b4ae,Chris Gaynor,gaynor.robert@hotmail.com,2023-10-30T13:44:41Z,Chris Gaynor,gaynor.robert@hotmail.com,2023-10-30T13:44:41Z,"-fixed bug in `writeRecords` #154

-added `altAddTraitAD` #140

-add miscPop slot to pop #120

-expanded functionality of candidates in selection #138",DESCRIPTION;NEWS.md;R/Class-Pop.R;R/Class-SimParam.R;R/RcppExports.R;R/mergePops.R;R/selection.R;man/Pop-class.Rd;man/SimParam.Rd;src/RcppExports.cpp;src/altAddTraitAD.cpp,False,True,True,False,654,23,677,"---FILE: DESCRIPTION---
@@ -1,8 +1,8 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 1.4.2.9990
-Date: 2023-6-29
+Version: 1.5.0
+Date: 2023-10-30
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: NEWS.md---
@@ -4,6 +4,12 @@
 
 *fixed bug in `writePlink` to correctly export map positions in cM
 
+*fixed bug in `writeRecords` due to removed reps slot in pops
+
+*added `altAddTraitAD` for specifying traits with dominance effects using dominance variance and inbreeding depression
+
+*add miscPop slot to class `Pop`
+
 # AlphaSimR 1.4.2
 
 *updated MaCS citation to https site
@@ -34,8 +40,6 @@
 
 # AlphaSimR 1.3.2
 
-*changed name of `MegaPop` to `MultiPop`
-
 *fixed column name bug with multiple traits in `setEBV`
 
 *fixed CTD caused by `runMacs` when too many segSites are requested

---FILE: R/Class-Pop.R---
@@ -379,6 +379,8 @@ isNamedMapPop = function(x) {
 #' population. This list is normally empty and exists solely as an
 #' open slot available for uses to store extra information about
 #' individuals.
+#' @slot miscPop a list of any length containing optional meta data for the 
+#' populations. This list is empty unless information is supplied by the user.
 #'
 #' @export
 setClass(""Pop"",
@@ -393,7 +395,8 @@ setClass(""Pop"",
                  ebv=""matrix"",
                  gxe=""list"",
                  fixEff=""integer"",
-                 misc=""list""),
+                 misc=""list"",
+                 miscPop=""list""),
          contains=""RawPop"")
 
 setValidity(""Pop"",function(object){
@@ -500,6 +503,7 @@ setMethod(""["",
             for(chr in 1:x@nChr){
               x@geno[[chr]] = x@geno[[chr]][,,i,drop=FALSE]
             }
+            x@miscPop = list()
             return(x)
           }
 )
@@ -692,7 +696,8 @@ newPop = function(rawPop,simParam=NULL,...){
                ebv=matrix(NA_real_,
                           nrow=rawPop@nInd,
                           ncol=0),
-               misc=vector(""list"",rawPop@nInd))
+               misc=vector(""list"",rawPop@nInd),
+               miscPop=list())
   if(simParam$nTraits>=1){
     output = setPheno(output, varE=NULL, reps=1,
                       fixEff=1L, p=NULL, onlyPheno=FALSE,
@@ -879,7 +884,8 @@ newEmptyPop = function(ploidy=2L, simParam=NULL){
                ebv = matrix(NA_real_,
                             nrow=0L,
                             ncol=0L),
-               misc = list())
+               misc = list(),
+               miscPop = list())
   return(output)
 }
 

---FILE: R/Class-SimParam.R---
@@ -609,6 +609,124 @@ SimParam = R6Class(
       }
       invisible(self)
     },
+    
+    #' @description 
+    #' An alternative method for adding a trait with additive  and dominance effects 
+    #' to an AlphaSimR simulation. The function attempts to create a trait matching 
+    #' user defined values for number of QTL, inbreeding depression, additive genetic 
+    #' variance and dominance genetic variance.
+    #' 
+    #' @param nQtlPerChr number of QTLs per chromosome. 
+    #' Can be a single value or nChr values.
+    #' @param mean desired mean of the trait
+    #' @param varA desired additive variance
+    #' @param varD desired dominance variance
+    #' @param inbrDepr desired inbreeding depression, see details
+    #' @param limMeanDD limits for meanDD, see details
+    #' @param limVarDD limits for varDD, see details
+    #' @param silent should summary details be printed to the console
+    #' @param force should the check for a running simulation be
+    #' ignored. Only set to TRUE if you know what you are doing.
+    #' @param name optional name for trait
+    #' 
+    #' @details 
+    #' This function will always add a trait to 'SimParam', unless an error occurs 
+    #' with picking QTLs. The resulting trait will always have the desired mean and 
+    #' additive genetic variance. However, it may not have the desired values for 
+    #' inbreeding depression and dominance variance. Thus, it is strongly recommended 
+    #' to check the output printed to the console to determine how close the trait's 
+    #' parameters came to these desired values.
+    #' 
+    #' The mean and additive genetic variance will always be achieved exactly. The 
+    #' function attempts to achieve the desired dominance variance and inbreeding 
+    #' depression while staying within the user supplied constraints for the 
+    #' acceptable range of dominance degree mean and variance. If the desired values
+    #' are not being achieved, the acceptable range need to be increased and/or the 
+    #' number of QTL may need to be increased. There are not limits to setting the 
+    #' range for dominance degree mean and variance, but care should be taken to 
+    #' with regards to the biological feasibility of the limits that are supplied. 
+    #' The default limits were somewhat arbitrarily set, so I make not claim to 
+    #' how reasonable these limits are for routine use.
+    #' 
+    #' Inbreeding depression in this function is defined as the difference in mean 
+    #' genetic value between a population with the same allele frequency as the 
+    #' reference population (population used to initialize SimParam) in 
+    #' Hardy-Weinberg equilibrium compared to a population with the same allele 
+    #' frequency that is fully inbred. This is equivalent to the amount the mean of 
+    #' a population increases when going from an inbreeding coefficient of 1 (fully 
+    #' inbred) to a population with an inbreeding coefficient of 0 (Hardy-Weinberg 
+    #' equilibrium). Note that the sign of the value should (usually) be positive. 
+    #' This corresponds to a detrimental effect of inbreeding when higher values of 
+    #' the trait are considered biologically beneficial.
+    #' 
+    #' Summary information on this trait is printed to the console when silent=FALSE. 
+    #' The summary information reports the inbreeding depression and dominance 
+    #' variance for the population as well as the dominance degree mean and variance 
+    #' applied to the trait.
+    #' 
+    #' @examples
+    #' #Create founder haplotypes
+    #' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+    #'
+    #' #Set simulation parameters
+    #' SP = SimParam$new(founderPop)
+    #' SP$altAddTraitAD(nQtlPerChr=10, mean=0, varA=1, varD=0.05, inbrDepr=0.2)
+    altAddTraitAD = function(nQtlPerChr,mean=0,varA=1,varD=0,inbrDepr=0, 
+                             limMeanDD=c(0,1.5),limVarDD=c(0,0.5),
+                             silent=FALSE,force=FALSE,name=NULL){
+      if(!force){
+        private$.isRunning()
+      }
+      if(length(nQtlPerChr)==1){
+        nQtlPerChr = rep(nQtlPerChr,self$nChr)
+      }
+      if(is.null(name)){
+        name = paste0(""Trait"",self$nTraits+1)
+      }
+      
+      # Pick QTL
+      qtlLoci = private$.pickLoci(nQtlPerChr)
+      
+      # Create list of arguments for optimization
+      argsList = argAltAD(LociMap = qtlLoci,
+                          Pop = self$founderPop,
+                          mean = mean,
+                          varA = varA,
+                          varD = varD,
+                          inbrDepr = inbrDepr,
+                          nThreads = self$nThreads)
+      
+      # Run optim to optimize meanDD and varDD
+      optOut = optim(par = c(mean(limMeanDD), mean(sqrt(limVarDD))),
+                     fn = objAltAD, 
+                     gr = NULL,
+                     method = ""L-BFGS-B"",
+                     lower = c(limMeanDD[1], sqrt(limVarDD[1])),
+                     upper = c(limMeanDD[2], sqrt(limVarDD[2])),
+                     args = argsList)
+      
+      # Finalize creation of trait
+      output = finAltAD(input = optOut$par, args = argsList)
+      trait = new(""TraitAD"",
+                  qtlLoci,
+                  addEff=c(output$a),
+                  domEff=c(output$d),
+                  intercept=c(output$intercept),
+                  name=name)
+      private$.addTrait(trait,varA,output$varG)
+      
+      # Report trait details
+      if(!silent){
+        cat(""A new trait called"", name, ""was added. \n"")
+        cat(""   varD ="", output$varD, ""\n"")
+        cat(""   inbrDepr ="", output$inbrDepr, ""\n"")
+        cat(""   meanDD ="", output$meanDD, ""\n"")
+        cat(""   varDD ="", output$varDD, ""\n"")
+      }
+      
+      invisible(self)
+    },
+    
 
     #' @description
     #' Randomly assigns eligible QTLs for one or more additive GxE traits.

---FILE: R/RcppExports.R---
@@ -212,6 +212,18 @@ writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missi
     invisible(.Call(`_AlphaSimR_writeASHaplotypes`, g, locations, allLocations, snpchips, names, missing, fname))
 }
 
+argAltAD <- function(LociMap, Pop, mean, varA, varD, inbrDepr, nThreads) {
+    .Call(`_AlphaSimR_argAltAD`, LociMap, Pop, mean, varA, varD, inbrDepr, nThreads)
+}
+
+objAltAD <- function(input, args) {
+    .Call(`_AlphaSimR_objAltAD`, input, args)
+}
+
+finAltAD <- function(input, args) {
+    .Call(`_AlphaSimR_finAltAD`, input, args)
+}
+
 calcGenParam <- function(trait, pop, nThreads) {
     .Call(`_AlphaSimR_calcGenParam`, trait, pop, nThreads)
 }

---FILE: R/mergePops.R---
@@ -144,5 +144,6 @@ mergePops = function(popList){
              gxe=gxe,
              pheno=pheno,
              ebv=ebv,
-             misc=misc))
+             misc=misc,
+             miscPop=list()))
 }

---FILE: R/selection.R---
@@ -56,6 +56,27 @@ getResponse = function(pop,trait,use,simParam=NULL,...){
   return(response)
 }
 
+# Converts candidates to a vector of positive numbers
+# for the individuals that are candidates. This function
+# handle indexing by id and negative value indexing
+getCandidates = function(pop, candidates){
+  if(is.character(candidates)){
+    candidates = match(candidates, pop@id)
+    if(any(is.na(candidates))){
+      stop(""Trying to select invalid individuals"")
+    }
+    if(any(is.null(candidates))){
+      stop(""Not valid ids"")
+    }
+  }else{
+    if(any(abs(candidates)>pop@nInd)){
+      stop(""Trying to select invalid individuals"")
+    }
+    candidates = (1:pop@nInd)[candidates]
+  }
+  return(candidates)
+}
+
 # Returns a vector of individuals in a population with the required sex
 checkSexes = function(pop,sex,simParam,...){
   sex = toupper(sex)
@@ -167,6 +188,7 @@ selectInd = function(pop,nInd,trait=1,use=""pheno"",sex=""B"",
   }
   eligible = checkSexes(pop=pop,sex=sex,simParam=simParam,...)
   if(!is.null(candidates)){
+    candidates = getCandidates(pop=pop,candidates=candidates)
     eligible = eligible[eligible%in%candidates]
   }
   if(length(eligible)<nInd){
@@ -257,6 +279,7 @@ selectFam = function(pop,nFam,trait=1,use=""pheno"",sex=""B"",
   }
   eligible = checkSexes(pop=pop,sex=sex,simParam=simParam,...)
   if(!is.null(candidates)){
+    candidates = getCandidates(pop=pop,candidates=candidates)
     eligible = eligible[eligible%in%candidates]
   }
   allFam = getFam(pop=pop,famType=famType)
@@ -357,6 +380,7 @@ selectWithinFam = function(pop,nInd,trait=1,use=""pheno"",sex=""B"",
   }
   eligible = checkSexes(pop=pop,sex=sex,simParam=simParam,...)
   if(!is.null(candidates)){
+    candidates = getCandidates(pop=pop,candidates=candidates)
     eligible = eligible[eligible%in%candidates]
   }
   families = getFam(pop=pop,famType=famType)

---FILE: man/Pop-class.Rd---
@@ -70,5 +70,8 @@ Used by genomic selection models but otherwise ignored.}
 population. This list is normally empty and exists solely as an
 open slot available for uses to store extra information about
 individuals.}
+
+\item{\code{miscPop}}{a list of any length containing optional meta data for the 
+populations. This list is empty unless information is supplied by the user.}
 }}
 

---FILE: man/SimParam.Rd---
@@ -133,6 +133,17 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 SP = SimParam$new(founderPop)
 SP$addTraitAD(10, meanDD=0.5)
 
+## ------------------------------------------------
+## Method `SimParam$altAddTraitAD`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$altAddTraitAD(nQtlPerChr=10, mean=0, varA=1, varD=0.05, inbrDepr=0.2)
+
 ## ------------------------------------------------
 ## Method `SimParam$addTraitAG`
 ## ------------------------------------------------
@@ -361,6 +372,7 @@ genetic map}
 \item \href{#method-SimParam-addStructuredSnpChip}{\code{SimParam$addStructuredSnpChip()}}
 \item \href{#method-SimParam-addTraitA}{\code{SimParam$addTraitA()}}
 \item \href{#method-SimParam-addTraitAD}{\code{SimParam$addTraitAD()}}
+\item \href{#method-SimParam-altAddTraitAD}{\code{SimParam$altAddTraitAD()}}
 \item \href{#method-SimParam-addTraitAG}{\code{SimParam$addTraitAG()}}
 \item \href{#method-SimParam-addTraitADG}{\code{SimParam$addTraitADG()}}
 \item \href{#method-SimParam-addTraitAE}{\code{SimParam$addTraitAE()}}
@@ -756,7 +768,7 @@ ignored. Only set to TRUE if you know what you are doing.}
 \if{latex}{\out{\hypertarget{method-SimParam-addTraitA}{}}}
 \subsection{Method \code{addTraitA()}}{
 Randomly assigns eligible QTLs for one or more additive traits.
-If simulating more than one trait, all traits will be pleiotrophic
+If simulating more than one trait, all traits will be pleiotropic
 with correlated additive effects.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addTraitA(
@@ -784,7 +796,9 @@ with correlated additive effects.
 
 \item{\code{gamma}}{should a gamma distribution be used instead of normal}
 
-\item{\code{shape}}{the shape parameter for the gamma distribution}
+\item{\code{shape}}{the shape parameter for the gamma distribution
+(the rate/scale parameter of the gamma distribution is accounted
+for via the desired level of genetic variance, the var argument)}
 
 \item{\code{force}}{should the check for a running simulation be
 ignored. Only set to TRUE if you know what you are doing.}
@@ -812,7 +826,7 @@ SP$addTraitA(10)
 \if{latex}{\out{\hypertarget{method-SimParam-addTraitAD}{}}}
 \subsection{Method \code{addTraitAD()}}{
 Randomly assigns eligible QTLs for one or more traits with dominance.
-If simulating more than one trait, all traits will be pleiotrophic
+If simulating more than one trait, all traits will be pleiotropic
 with correlated effects.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addTraitAD(
@@ -853,7 +867,9 @@ FALSE, tuning is performed according to total genetic variance.}
 
 \item{\code{gamma}}{should a gamma distribution be used instead of normal}
 
-\item{\code{shape}}{the shape parameter for the gamma distribution}
+\item{\code{shape}}{the shape parameter for the gamma distribution
+(the rate/scale parameter of the gamma distribution is accounted
+for via the desired level of genetic variance, the var argument)}
 
 \item{\code{force}}{should the check for a running simulation be
 ignored. Only set to TRUE if you know what you are doing.}
@@ -875,13 +891,113 @@ SP$addTraitAD(10, meanDD=0.5)
 
 }
 
+}
+\if{html}{\out{<hr>}}
+\if{html}{\out{<a id=""method-SimParam-altAddTraitAD""></a>}}
+\if{latex}{\out{\hypertarget{method-SimParam-altAddTraitAD}{}}}
+\subsection{Method \code{altAddTraitAD()}}{
+An alternative method for adding a trait with additive  and dominance effects 
+to an AlphaSimR simulation. The function attempts to create a trait matching 
+user defined values for number of QTL, inbreeding depression, additive genetic 
+variance and dominance genetic variance.
+\subsection{Usage}{
+\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$altAddTraitAD(
+  nQtlPerChr,
+  mean = 0,
+  varA = 1,
+  varD = 0,
+  inbrDepr = 0,
+  limMeanDD = c(0, 1.5),
+  limVarDD = c(0, 0.5),
+  silent = FALSE,
+  force = FALSE,
+  name = NULL
+)}\if{html}{\out{</div>}}
+}
+
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{nQtlPerChr}}{number of QTLs per chromosome. 
+Can be a single value or nChr values.}
+
+\item{\code{mean}}{desired mean of the trait}
+
+\item{\code{varA}}{desired additive variance}
+
+\item{\code{varD}}{desired dominance variance}
+
+\item{\code{inbrDepr}}{desired inbreeding depression, see details}
+
+\item{\code{limMeanDD}}{limits for meanDD, see details}
+
+\item{\code{limVarDD}}{limits for varDD, see details}
+
+\item{\code{silent}}{should summary details be printed to the console}
+
+\item{\code{force}}{should the check for a running simulation be
+ignored. Only set to TRUE if you know what you are doing.}
+
+\item{\code{name}}{optional name for trait}
+}
+\if{html}{\out{</div>}}
+}
+\subsection{Details}{
+This function will always add a trait to 'SimParam', unless an error occurs 
+with picking QTLs. The resulting trait will always have the desired mean and 
+additive genetic variance. However, it may not have the desired values for 
+inbreeding depression and dominance variance. Thus, it is strongly recommended 
+to check the output printed to the console to determine how close the trait's 
+parameters came to these desired values.
+
+The mean and additive genetic variance will always be achieved exactly. The 
+function attempts to achieve the desired dominance variance and inbreeding 
+depression while staying within the user supplied constraints for the 
+acceptable range of dominance degree mean and variance. If the desired values
+are not being achieved, the acceptable range need to be increased and/or the 
+number of QTL may need to be increased. There are not limits to setting the 
+range for dominance degree mean and variance, but care should be taken to 
+with regards to the biological feasibility of the limits that are supplied. 
+The default limits were somewhat arbitrarily set, so I make not claim to 
+how reasonable these limits are for routine use.
+
+Inbreeding depression in this function is defined as the difference in mean 
+genetic value between a population with the same allele frequency as the 
+reference population (population used to initialize SimParam) in 
+Hardy-Weinberg equilibrium compared to a population with the same allele 
+frequency that is fully inbred. This is equivalent to the amount the mean of 
+a population increases when going from an inbreeding coefficient of 1 (fully 
+inbred) to a population with an inbreeding coefficient of 0 (Hardy-Weinberg 
+equilibrium). Note that the sign of the value should (usually) be positive. 
+This corresponds to a detrimental effect of inbreeding when higher values of 
+the trait are considered biologically beneficial.
+
+Summary information on this trait is printed to the console when silent=FALSE. 
+The summary information reports the inbreeding depression and dominance 
+variance for the population as well as the dominance degree mean and variance 
+applied to the trait.
+}
+
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$altAddTraitAD(nQtlPerChr=10, mean=0, varA=1, varD=0.05, inbrDepr=0.2)
+}
+\if{html}{\out{</div>}}
+
+}
+
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-SimParam-addTraitAG""></a>}}
 \if{latex}{\out{\hypertarget{method-SimParam-addTraitAG}{}}}
 \subsection{Method \code{addTraitAG()}}{
-Randomly assigns eligible QTLs for one ore more additive GxE traits.
-If simulating more than one trait, all traits will be pleiotrophic
+Randomly assigns eligible QTLs for one or more additive GxE traits.
+If simulating more than one trait, all traits will be pleiotropic
 with correlated effects.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addTraitAG(
@@ -918,7 +1034,9 @@ with correlated effects.
 
 \item{\code{gamma}}{should a gamma distribution be used instead of normal}
 
-\item{\code{shape}}{the shape parameter for the gamma distribution}
+\item{\code{shape}}{the shape parameter for the gamma distribution
+(the rate/scale parameter of the gamma distribution is accounted
+for via the desired level of genetic variance, the var argument)}
 
 \item{\code{force}}{should the check for a running simulation be
 ignored. Only set to TRUE if you know what you are doing.}
@@ -994,7 +1112,9 @@ value or nChr values.}
 
 \item{\code{gamma}}{should a gamma distribution be used instead of normal}
 
-\item{\code{shape}}{the shape parameter for the gamma distribution}
+\item{\code{shape}}{the shape parameter for the gamma distribution
+(the rate/scale parameter of the gamma distribution is accounted
+for via the desired level of genetic variance, the var argument)}
 
 \item{\code{force}}{should the check for a running simulation be
 ignored. Only set to TRUE if you know what you are doing.}
@@ -1022,7 +1142,7 @@ SP$addTraitADG(10, meanDD=0.5, varGxE=2)
 \if{latex}{\out{\hypertarget{method-SimParam-addTraitAE}{}}}
 \subsection{Method \code{addTraitAE()}}{
 Randomly assigns eligible QTLs for one or more additive and epistasis
-traits. If simulating more than one trait, all traits will be pleiotrophic
+traits. If simulating more than one trait, all traits will be pleiotropic
 with correlated additive effects.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addTraitAE(
@@ -1061,7 +1181,9 @@ FALSE, tuning is performed according to total genetic variance.}
 
 \item{\code{gamma}}{should a gamma distribution be used instead of normal}
 
-\item{\code{shape}}{the shape parameter for the gamma distribution}
+\item{\code{shape}}{the shape parameter for the gamma distribution
+(the rate/scale parameter of the gamma distribution is accounted
+for via the desired level of genetic variance, the var argument)}
 
 \item{\code{force}}{should the check for a running simulation be
 ignored. Only set to TRUE if you know what you are doing.}
@@ -1085,7 +1207,7 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 \if{latex}{\out{\hypertarget{method-SimParam-addTraitADE}{}}}
 \subsection{Method \code{addTraitADE()}}{
 Randomly assigns eligible QTLs for one or more traits with dominance and
-epistasis. If simulating more than one trait, all traits will be pleiotrophic
+epistasis. If simulating more than one trait, all traits will be pleiotropic
 with correlated effects.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addTraitADE(
@@ -1133,7 +1255,9 @@ FALSE, tuning is performed according to total genetic variance.}
 
 \item{\code{gamma}}{should a gamma distribution be used instead of normal}
 
-\item{\code{shape}}{the shape parameter for the gamma distribution}
+\item{\code{shape}}{the shape parameter for the gamma distribution
+(the rate/scale parameter of the gamma distribution is accounted
+for via the desired level of genetic variance, the var argument)}
 
 \item{\code{force}}{should the check for a running simulation be
 ignored. Only set to TRUE if you know what you are doing.}
@@ -1161,7 +1285,7 @@ SP$addTraitADE(10)
 \if{latex}{\out{\hypertarget{method-SimParam-addTraitAEG}{}}}
 \subsection{Method \code{addTraitAEG()}}{
 Randomly assigns eligible QTLs for one or more additive and epistasis
-GxE traits. If simulating more than one trait, all traits will be pleiotrophic
+GxE traits. If simulating more than one trait, all traits will be pleiotropic
 with correlated effects.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addTraitAEG(
@@ -1209,7 +1333,9 @@ FALSE, tuning is performed according to total genetic variance.}
 
 \item{\code{gamma}}{should a gamma distribution be used instead of normal}
 
-\item{\code{shape}}{the shape parameter for the gamma distribution}
+\item{\code{shape}}{the shape parameter for the gamma distribution
+(the rate/scale parameter of the gamma distribution is accounted
+for via the desired level of genetic variance, the var argument)}
 
 \item{\code{force}}{should the check for a running simulation be
 ignored. Only set to TRUE if you know what you are doing.}
@@ -1293,7 +1419,9 @@ to additive variance in a diploid organism with allele frequency 0.5}
 
 \item{\code{gamma}}{should a gamma distribution be used instead of normal}
 
-\item{\code{shape}}{the shape parameter for the gamma distribution}
+\item{\code{shape}}{the shape parameter for the gamma distribution
+(the rate/scale parameter of the gamma distribution is accounted
+for via the desired level of genetic variance, the var argument)}
 
 \item{\code{force}}{should the check for a running simulation be
 ignored. Only set to TRUE if you know what you are doing.}

---FILE: src/RcppExports.cpp---
@@ -381,6 +381,47 @@ BEGIN_RCPP
     return R_NilValue;
 END_RCPP
 }
+// argAltAD
+Rcpp::List argAltAD(Rcpp::S4 LociMap, Rcpp::S4 Pop, double mean, double varA, double varD, double inbrDepr, int nThreads);
+RcppExport SEXP _AlphaSimR_argAltAD(SEXP LociMapSEXP, SEXP PopSEXP, SEXP meanSEXP, SEXP varASEXP, SEXP varDSEXP, SEXP inbrDeprSEXP, SEXP nThreadsSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< Rcpp::S4 >::type LociMap(LociMapSEXP);
+    Rcpp::traits::input_parameter< Rcpp::S4 >::type Pop(PopSEXP);
+    Rcpp::traits::input_parameter< double >::type mean(meanSEXP);
+    Rcpp::traits::input_parameter< double >::type varA(varASEXP);
+    Rcpp::traits::input_parameter< double >::type varD(varDSEXP);
+    Rcpp::traits::input_parameter< double >::type inbrDepr(inbrDeprSEXP);
+    Rcpp::traits::input_parameter< int >::type nThreads(nThreadsSEXP);
+    rcpp_result_gen = Rcpp::wrap(argAltAD(LociMap, Pop, mean, varA, varD, inbrDepr, nThreads));
+    return rcpp_result_gen;
+END_RCPP
+}
+// objAltAD
+double objAltAD(arma::vec input, const Rcpp::List& args);
+RcppExport SEXP _AlphaSimR_objAltAD(SEXP inputSEXP, SEXP argsSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::vec >::type input(inputSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::List& >::type args(argsSEXP);
+    rcpp_result_gen = Rcpp::wrap(objAltAD(input, args));
+    return rcpp_result_gen;
+END_RCPP
+}
+// finAltAD
+Rcpp::List finAltAD(arma::vec input, const Rcpp::List& args);
+RcppExport SEXP _AlphaSimR_finAltAD(SEXP inputSEXP, SEXP argsSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::vec >::type input(inputSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::List& >::type args(argsSEXP);
+    rcpp_result_gen = Rcpp::wrap(finAltAD(input, args));
+    return rcpp_result_gen;
+END_RCPP
+}
 // calcGenParam
 Rcpp::List calcGenParam(const Rcpp::S4& trait, const Rcpp::S4& pop, int nThreads);
 RcppExport SEXP _AlphaSimR_calcGenParam(SEXP traitSEXP, SEXP popSEXP, SEXP nThreadsSEXP) {
@@ -826,6 +867,9 @@ static const R_CallMethodDef CallEntries[] = {
     {""_AlphaSimR_solveMKM"", (DL_FUNC) &_AlphaSimR_solveMKM, 6},
     {""_AlphaSimR_writeASGenotypes"", (DL_FUNC) &_AlphaSimR_writeASGenotypes, 7},
     {""_AlphaSimR_writeASHaplotypes"", (DL_FUNC) &_AlphaSimR_writeASHaplotypes, 7},
+    {""_AlphaSimR_argAltAD"", (DL_FUNC) &_AlphaSimR_argAltAD, 7},
+    {""_AlphaSimR_objAltAD"", (DL_FUNC) &_AlphaSimR_objAltAD, 2},
+    {""_AlphaSimR_finAltAD"", (DL_FUNC) &_AlphaSimR_finAltAD, 2},
     {""_AlphaSimR_calcGenParam"", (DL_FUNC) &_AlphaSimR_calcGenParam, 3},
     {""_AlphaSimR_getGeno"", (DL_FUNC) &_AlphaSimR_getGeno, 4},
     {""_AlphaSimR_getMaternalGeno"", (DL_FUNC) &_AlphaSimR_getMaternalGeno, 4},

---FILE: src/altAddTraitAD.cpp---
@@ -0,0 +1,291 @@
+#include ""alphasimr.h""
+
+// Sets up the list of arguments needed for optimization
+// [[Rcpp::export]]
+Rcpp::List argAltAD(Rcpp::S4 LociMap,
+                    Rcpp::S4 Pop,
+                    double mean,
+                    double varA,
+                    double varD,
+                    double inbrDepr,
+                    int nThreads){
+  
+  // Create ploidy specific genotype dosage variables
+  arma::uword ploidy = Pop.slot(""ploidy"");
+  double dP = double(ploidy);
+  arma::uword nInd = Pop.slot(""nInd"");
+  arma::vec x(ploidy+1);
+  for(arma::uword i=0; i<x.n_elem; ++i)
+    x(i) = double(i);
+  arma::vec xa = (x-dP/2.0)*(2.0/dP);
+  arma::vec xd = x%(dP-x)*(2.0/dP)*(2.0/dP);
+  
+  // Extract loci information and genotypes
+  const arma::Col<int>& lociPerChr = LociMap.slot(""lociPerChr"");
+  arma::uword nLoci = accu(lociPerChr);
+  arma::uvec lociLoc = LociMap.slot(""lociLoc"");
+  arma::Mat<unsigned char> genoMat = getGeno(
+    Rcpp::as<arma::field<arma::Cube<unsigned char> > >(Pop.slot(""geno"")), 
+    lociPerChr, 
+    lociLoc, 
+    nThreads
+  );
+  
+  // Calculate genotype frequencies
+  arma::mat genoFreq(ploidy+1, nLoci, arma::fill::zeros);
+  arma::vec genoMu(nLoci), hetHWE(nLoci);
+#ifdef _OPENMP
+#pragma omp parallel for schedule(static) num_threads(nThreads)
+#endif
+  for(arma::uword i=0; i<nLoci; ++i){
+    // Count genotypes
+    for(arma::uword j=0; j<nInd; ++j){
+      ++genoFreq(genoMat(j,i), i);
+    }
+    
+    // Convert to frequency
+    genoFreq.col(i) = genoFreq.col(i)/double(nInd);
+    
+    // Calculate genotype mean
+    genoMu(i) = accu(genoFreq.col(i)%x);
+    
+    // Calculate inbreeding depression value
+    double p = genoMu(i)/dP;
+    double q = 1-p;
+    // Expected heterozygosity at HWE
+    // Not looping over first and last genotypes, because xd will be 0
+    for(arma::uword k=1; k<(ploidy); ++k){
+      double dK = double(k);
+      hetHWE(i) += xd(k)*choose(dP,dK)*std::pow(p,dK)*std::pow(q,dP-dK);
+    }
+  }
+  
+  // Sample random deviates
+  arma::vec a(nLoci, arma::fill::randn);
+  arma::vec domDegDev(nLoci, arma::fill::randn);
+  
+  return Rcpp::List::create(Rcpp::Named(""x"")=x,
+                            Rcpp::Named(""xa"")=xa,
+                            Rcpp::Named(""xd"")=xd,
+                            Rcpp::Named(""genoMat"")=genoMat,
+                            Rcpp::Named(""genoFreq"")=genoFreq,
+                            Rcpp::Named(""genoMu"")=genoMu,
+                            Rcpp::Named(""hetHWE"")=hetHWE,
+                            Rcpp::Named(""a"")=a,
+                            Rcpp::Named(""domDegDev"")=domDegDev,
+                            Rcpp::Named(""mean"")=mean,
+                            Rcpp::Named(""varA"")=varA,
+                            Rcpp::Named(""varD"")=varD,
+                            Rcpp::Named(""inbrDepr"")=inbrDepr,
+                            Rcpp::Named(""nThreads"")=nThreads);
+}
+
+// The objective function for optimization
+// [[Rcpp::export]]
+double objAltAD(arma::vec input, const Rcpp::List& args){
+  // Assign new values of meanDD and stdDevDD
+  double meanDD = input(0);
+  double stdDevDD = input(1);
+  
+  // Access variables from args
+  const arma::Mat<unsigned char>& genoMat = args[""genoMat""];
+  arma::uword nInd = genoMat.n_rows;
+  arma::uword nLoci = genoMat.n_cols;
+  const arma::mat& genoFreq = args[""genoFreq""];
+  const arma::vec& a = args[""a""];
+  const arma::vec& domDegDev = args[""domDegDev""];
+  const arma::vec& x = args[""x""];
+  const arma::vec& xa = args[""xa""];
+  const arma::vec& xd = args[""xd""];
+  const arma::vec& genoMu = args[""genoMu""];
+  const arma::vec& hetHWE = args[""hetHWE""];
+  double varA = args[""varA""];
+  double varD = args[""varD""];
+  double inbrDepr = args[""inbrDepr""];
+  int nThreads = args[""nThreads""];
+  
+  // Calculate d
+  arma::vec d = abs(a)%(domDegDev*stdDevDD + meanDD);
+  
+  // Allocate matrices for breeding values, dominance deviations, and means
+  // Number of threads used for efficient parallel computing
+  arma::mat bvMat(nInd, nThreads, arma::fill::zeros); // Breeding values
+  arma::mat ddMat(nInd, nThreads, arma::fill::zeros); // Dominance deviations
+  
+  // Calculate breeding values and dominance deviations
+  // Involves regressions for each locus
+#ifdef _OPENMP
+#pragma omp parallel for schedule(static) num_threads(nThreads)
+#endif
+  for(arma::uword i=0; i<nLoci; ++i){
+    
+    // Assign thread ID
+    arma::uword tid; 
+#ifdef _OPENMP
+    tid = omp_get_thread_num();
+#else
+    tid = 0;
+#endif
+    
+    // Decompose genetic values into breeding values and dominance deviations
+    arma::vec gv = xa*a(i) + xd*d(i);
+    double gvMu = accu(genoFreq.col(i)%gv); // Mean genetic value
+    gv = gv - gvMu; // Centering genetic values
+    arma::vec xc = x-genoMu(i); // Centered genotype dosage
+    
+    // Calculate average effect of an allele substitution (regression coefficient)
+    double alpha = accu(genoFreq.col(i)%gv%xc)/
+      accu(genoFreq.col(i)%xc%xc);
+    
+    // Calculate breeding values using alpha and dominance deviations using 
+    // lack-of-fit
+    arma::vec bv = xc*alpha;
+    arma::vec dd = gv - bv;
+    
+    // Fill matrices for breeding values and dominance deviations
+    // Accounts for the LD component of the variances
+    for(arma::uword j=0; j<nInd; ++j){
+      bvMat(j,tid) += bv(genoMat(j,i));
+      ddMat(j,tid) += dd(genoMat(j,i));
+    }
+  }
+  
+  // Calculate additive and dominance genetic variances for population
+  double obsVarA = accu(sum(bvMat,1)%sum(bvMat,1)) / nInd;
+  double obsVarD = accu(sum(ddMat,1)%sum(ddMat,1)) / nInd;
+  
+  // Scale effects to hit target additive variance
+  double scale = sqrt(varA) / sqrt(obsVarA);
+  d *= scale;
+  obsVarD *= scale*scale;
+  
+  // Calculate inbreeding depression and intercept for target mean
+  double obsInbrDepr = accu(hetHWE%d);
+  
+  // Return distance between target and observed 
+  // inbreeding depression and dominance variance (as standard deviation)
+  return sqrt(std::pow(obsInbrDepr-inbrDepr, 2) +
+              std::pow(sqrt(obsVarD)-sqrt(varD), 2));
+}
+
+// Calculates the a and d effects and the intercept
+// [[Rcpp::export]]
+Rcpp::List finAltAD(arma::vec input, const Rcpp::List& args){
+  // Assign new values of meanDD and stdDevDD
+  double meanDD = input(0);
+  double stdDevDD = input(1);
+  
+  // Access variables from args
+  const arma::Mat<unsigned char>& genoMat = args[""genoMat""];
+  arma::uword nInd = genoMat.n_rows;
+  arma::uword nLoci = genoMat.n_cols;
+  const arma::mat& genoFreq = args[""genoFreq""];
+  arma::vec a = args[""a""];
+  const arma::vec& domDegDev = args[""domDegDev""];
+  const arma::vec& x = args[""x""];
+  const arma::vec& xa = args[""xa""];
+  const arma::vec& xd = args[""xd""];
+  const arma::vec& genoMu = args[""genoMu""];
+  const arma::vec& hetHWE = args[""hetHWE""];
+  double varA = args[""varA""];
+  double mean = args[""mean""];
+  int nThreads = args[""nThreads""];
+  
+  // Calculate d
+  arma::vec d = abs(a)%(domDegDev*stdDevDD + meanDD);
+  
+  // Allocate matrices for breeding values, dominance deviations, and means
+  // Number of threads used for efficient parallel computing
+  arma::mat bvMat(nInd, nThreads, arma::fill::zeros); // Breeding values
+  arma::mat ddMat(nInd, nThreads, arma::fill::zeros); // Dominance deviations
+  
+  // Calculate breeding values and dominance deviations
+  // Involves regressions for each locus
+#ifdef _OPENMP
+#pragma omp parallel for schedule(static) num_threads(nThreads)
+#endif
+  for(arma::uword i=0; i<nLoci; ++i){
+    
+    // Assign thread ID
+    arma::uword tid; 
+#ifdef _OPENMP
+    tid = omp_get_thread_num();
+#else
+    tid = 0;
+#endif
+    
+    // Decompose genetic values into breeding values and dominance deviations
+    arma::vec gv = xa*a(i) + xd*d(i);
+    double gvMu = accu(genoFreq.col(i)%gv); // Mean genetic value
+    gv = gv - gvMu; // Centering genetic values
+    arma::vec xc = x-genoMu(i); // Centered genotype dosage
+    
+    // Calculate average effect of an allele substitution (regression coefficient)
+    double alpha = accu(genoFreq.col(i)%gv%xc)/
+      accu(genoFreq.col(i)%xc%xc);
+    
+    // Calculate breeding values using alpha and dominance deviations using 
+    // lack-of-fit
+    arma::vec bv = xc*alpha;
+    arma::vec dd = gv - bv;
+    
+    // Fill matrices for breeding values and dominance deviations
+    // Accounts for the LD component of the variances
+    for(arma::uword j=0; j<nInd; ++j){
+      bvMat(j,tid) += bv(genoMat(j,i));
+      ddMat(j,tid) += dd(genoMat(j,i));
+    }
+  }
+  
+  // Calculate additive and dominance genetic variances for population
+  double obsVarA = accu(sum(bvMat,1)%sum(bvMat,1)) / nInd;
+  double obsVarD = accu(sum(ddMat,1)%sum(ddMat,1)) / nInd;
+  
+  // Scale effects to hit target additive variance
+  double scale = sqrt(varA) / sqrt(obsVarA);
+  a *= scale;
+  d *= scale;
+  obsVarD *= scale*scale;
+  
+  // Calculate inbreeding depression and intercept for target mean
+  double obsInbrDepr = accu(hetHWE%d);
+  
+  // Calculate GV
+  arma::mat gvMat(nInd, nThreads, arma::fill::zeros); // Genetic values
+  
+#ifdef _OPENMP
+#pragma omp parallel for schedule(static) num_threads(nThreads)
+#endif
+  for(arma::uword i=0; i<nLoci; ++i){
+    
+    // Assign thread ID
+    arma::uword tid; 
+#ifdef _OPENMP
+    tid = omp_get_thread_num();
+#else
+    tid = 0;
+#endif
+    
+    // Decompose genetic values into breeding values and dominance deviations
+    arma::vec gv = xa*a(i) + xd*d(i);
+    
+    // Fill matrices for breeding values and dominance deviations
+    // Accounts for the LD component of the variances
+    for(arma::uword j=0; j<nInd; ++j){
+      gvMat(j,tid) += gv(genoMat(j,i));
+    }
+  }
+  
+  gvMat = sum(gvMat,1);
+  
+  double intercept = mean - accu(gvMat) / nInd;
+  
+  return Rcpp::List::create(Rcpp::Named(""a"")=a,
+                            Rcpp::Named(""d"")=d,
+                            Rcpp::Named(""intercept"")=intercept,
+                            Rcpp::Named(""meanDD"")=meanDD,
+                            Rcpp::Named(""varDD"")=stdDevDD*stdDevDD,
+                            Rcpp::Named(""inbrDepr"")=obsInbrDepr,
+                            Rcpp::Named(""varD"")=obsVarD,
+                            Rcpp::Named(""varG"")=accu(arma::cov(gvMat,1)));
+}"
gaynorr,AlphaSimR,cb6e1c1c893c59c080ce65691e5a7e25ef88a655,Chris Gaynor,gaynor.robert@hotmail.com,2023-07-12T12:08:04Z,Chris Gaynor,gaynor.robert@hotmail.com,2023-07-12T12:08:04Z,Resolving Namespace error,DESCRIPTION;NAMESPACE;NEWS.md;man/MegaPop-class.Rd;man/MultiPop-class.Rd;man/aa.Rd;man/calcGCA.Rd;man/genParam.Rd;man/genicVarAA.Rd;man/hybridCross.Rd;man/makeCross.Rd;man/makeCross2.Rd;man/makeDH.Rd;man/mergePops.Rd;man/newEmptyPop.Rd;man/newMultiPop.Rd;man/pedigreeCross.Rd;man/randCross.Rd;man/randCross2.Rd;man/selectCross.Rd;man/selectFam.Rd;man/selectInd.Rd;man/selectOP.Rd;man/selectWithinFam.Rd;man/self.Rd;man/setPheno.Rd;man/setPhenoGCA.Rd;man/setPhenoProgTest.Rd;man/varAA.Rd,False,False,False,False,241,239,480,"---FILE: DESCRIPTION---
@@ -35,7 +35,7 @@ Depends: R (>= 4.0.0), methods, R6
 Imports: Rcpp (>= 0.12.7), Rdpack
 RdMacros: Rdpack
 LinkingTo: Rcpp, RcppArmadillo (>= 0.7.500.0.0), BH
-RoxygenNote: 7.2.1
+RoxygenNote: 7.2.3
 Suggests: knitr, rmarkdown, testthat
 VignetteBuilder: knitr
 NeedsCompilation: true

---FILE: NAMESPACE---
@@ -42,7 +42,7 @@ export(isFemale)
 export(isHybridPop)
 export(isMale)
 export(isMapPop)
-export(isMegaPop)
+export(isMultiPop)
 export(isNamedMapPop)
 export(isPop)
 export(isRawPop)
@@ -57,7 +57,7 @@ export(mutate)
 export(nInd)
 export(newEmptyPop)
 export(newMapPop)
-export(newMegaPop)
+export(newMultiPop)
 export(newPop)
 export(pedigreeCross)
 export(pheno)
@@ -115,7 +115,7 @@ export(writeRecords)
 exportClasses(HybridPop)
 exportClasses(LociMap)
 exportClasses(MapPop)
-exportClasses(MegaPop)
+exportClasses(MultiPop)
 exportClasses(NamedMapPop)
 exportClasses(Pop)
 exportClasses(RRsol)

---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # AlphaSimR 1.3.1.9990
 
+*changed name of `MegaPop` to `MultiPop`
+
 *fixed column name bug with multiple traits in `setEBV`
 
 # AlphaSimR 1.3.1

---FILE: man/MegaPop-class.Rd---
@@ -1,51 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-Pop.R
-\docType{class}
-\name{MegaPop-class}
-\alias{MegaPop-class}
-\alias{[,MegaPop-method}
-\alias{[[,MegaPop-method}
-\alias{c,MegaPop-method}
-\alias{isMegaPop}
-\title{Mega-Population}
-\usage{
-\S4method{[}{MegaPop}(x, i)
-
-\S4method{[[}{MegaPop}(x, i)
-
-\S4method{c}{MegaPop}(x, ...)
-
-isMegaPop(x)
-}
-\arguments{
-\item{x}{a 'MegaPop' object}
-
-\item{i}{index of populations or mega-populations}
-
-\item{...}{additional 'MegaPop' or 'Pop' objects}
-}
-\description{
-The mega-population represents a population of populations.
-It is designed to behave like a list of populations.
-}
-\section{Methods (by generic)}{
-\itemize{
-\item \code{[}: Extract MegaPop by index
-
-\item \code{[[}: Extract Pop by index
-
-\item \code{c(MegaPop)}: Combine multiple MegaPops
-
-}}
-\section{Functions}{
-\itemize{
-\item \code{isMegaPop()}: Test if object is of a MegaPop class
-
-}}
-\section{Slots}{
-
-\describe{
-\item{\code{pops}}{list of \code{\link{Pop-class}} and/or
-\code{MegaPop-class}}
-}}
-

---FILE: man/MultiPop-class.Rd---
@@ -0,0 +1,51 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/Class-Pop.R
+\docType{class}
+\name{MultiPop-class}
+\alias{MultiPop-class}
+\alias{[,MultiPop-method}
+\alias{[[,MultiPop-method}
+\alias{c,MultiPop-method}
+\alias{isMultiPop}
+\title{Multi-Population}
+\usage{
+\S4method{[}{MultiPop}(x, i)
+
+\S4method{[[}{MultiPop}(x, i)
+
+\S4method{c}{MultiPop}(x, ...)
+
+isMultiPop(x)
+}
+\arguments{
+\item{x}{a 'MultiPop' object}
+
+\item{i}{index of populations or mega-populations}
+
+\item{...}{additional 'MultiPop' or 'Pop' objects}
+}
+\description{
+The mega-population represents a population of populations.
+It is designed to behave like a list of populations.
+}
+\section{Methods (by generic)}{
+\itemize{
+\item \code{[}: Extract MultiPop by index
+
+\item \code{[[}: Extract Pop by index
+
+\item \code{c(MultiPop)}: Combine multiple MultiPops
+
+}}
+\section{Functions}{
+\itemize{
+\item \code{isMultiPop()}: Test if object is of a MultiPop class
+
+}}
+\section{Slots}{
+
+\describe{
+\item{\code{pops}}{list of \code{\link{Pop-class}} and/or
+\code{MultiPop-class}}
+}}
+

---FILE: man/aa.Rd---
@@ -12,7 +12,7 @@ aa(pop, simParam = NULL)
 \item{simParam}{an object of \code{\link{SimParam}}}
 }
 \description{
-Returns additive-by-additive epistatic 
+Returns additive-by-additive epistatic
 deviations for all traits
 }
 \examples{

---FILE: man/calcGCA.Rd---
@@ -7,15 +7,15 @@
 calcGCA(pop, use = ""pheno"")
 }
 \arguments{
-\item{pop}{an object of \code{\link{Pop-class}} or 
+\item{pop}{an object of \code{\link{Pop-class}} or
 \code{\link{HybridPop-class}}}
 
 \item{use}{tabulate either genetic values ""gv"", estimated
 breeding values ""ebv"", or phenotypes ""pheno""}
 }
 \description{
-Calculate general combining ability of test crosses. Intended for 
-output from hybridCross using the ""testcross"" option, but will work 
+Calculate general combining ability of test crosses. Intended for
+output from hybridCross using the ""testcross"" option, but will work
 for any population.
 }
 \examples{

---FILE: man/genParam.Rd---
@@ -45,7 +45,7 @@ genParam(pop, simParam = NULL)
 }
 }
 \description{
-Calculates genetic and genic additive and dominance variances 
+Calculates genetic and genic additive and dominance variances
 for an object of \code{\link{Pop-class}}
 }
 \examples{

---FILE: man/genicVarAA.Rd---
@@ -12,7 +12,7 @@ genicVarAA(pop, simParam = NULL)
 \item{simParam}{an object of \code{\link{SimParam}}}
 }
 \description{
-Returns additive-by-additive epistatic 
+Returns additive-by-additive epistatic
 genic variance for all traits
 }
 \examples{

---FILE: man/hybridCross.Rd---
@@ -17,21 +17,21 @@ hybridCross(
 
 \item{males}{male population, an object of \code{\link{Pop-class}}}
 
-\item{crossPlan}{either ""testcross"" for all possible combinantions 
+\item{crossPlan}{either ""testcross"" for all possible combinantions
 or a matrix with two columns for designed crosses}
 
-\item{returnHybridPop}{should results be returned as 
-\code{\link{HybridPop-class}}. If false returns results as 
+\item{returnHybridPop}{should results be returned as
+\code{\link{HybridPop-class}}. If false returns results as
 \code{\link{Pop-class}}. Population must be fully inbred if TRUE.}
 
 \item{simParam}{an object of \code{\link{SimParam}}}
 }
 \description{
-A convience function for hybrid plant breeding simulations. Allows for 
-easy specification of a test cross scheme and/or creation of an object 
-of \code{\link{HybridPop-class}}. Note that the \code{\link{HybridPop-class}} 
-should only be used if the parents were created using the \code{\link{makeDH}} 
-function or \code{\link{newPop}} using inbred founders. The id for 
+A convience function for hybrid plant breeding simulations. Allows for
+easy specification of a test cross scheme and/or creation of an object
+of \code{\link{HybridPop-class}}. Note that the \code{\link{HybridPop-class}}
+should only be used if the parents were created using the \code{\link{makeDH}}
+function or \code{\link{newPop}} using inbred founders. The id for
 new individuals is [mother_id]_[father_id]
 }
 \examples{

---FILE: man/makeCross.Rd---
@@ -9,8 +9,8 @@ makeCross(pop, crossPlan, nProgeny = 1, simParam = NULL)
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}}}
 
-\item{crossPlan}{a matrix with two column representing 
-female and male parents. Either integers for the position in 
+\item{crossPlan}{a matrix with two column representing
+female and male parents. Either integers for the position in
 population or character strings for the IDs.}
 
 \item{nProgeny}{number of progeny per cross}
@@ -21,7 +21,7 @@ population or character strings for the IDs.}
 Returns an object of \code{\link{Pop-class}}
 }
 \description{
-Makes crosses within a population using a user supplied 
+Makes crosses within a population using a user supplied
 crossing plan.
 }
 \examples{

---FILE: man/makeCross2.Rd---
@@ -11,8 +11,8 @@ makeCross2(females, males, crossPlan, nProgeny = 1, simParam = NULL)
 
 \item{males}{an object of \code{\link{Pop-class}} for male parents.}
 
-\item{crossPlan}{a matrix with two column representing 
-female and male parents. Either integers for the position in 
+\item{crossPlan}{a matrix with two column representing
+female and male parents. Either integers for the position in
 population or character strings for the IDs.}
 
 \item{nProgeny}{number of progeny per cross}
@@ -23,7 +23,7 @@ population or character strings for the IDs.}
 Returns an object of \code{\link{Pop-class}}
 }
 \description{
-Makes crosses between two populations using a user supplied 
+Makes crosses between two populations using a user supplied
 crossing plan.
 }
 \examples{

---FILE: man/makeDH.Rd---
@@ -13,7 +13,7 @@ makeDH(pop, nDH = 1, useFemale = TRUE, keepParents = TRUE, simParam = NULL)
 
 \item{useFemale}{should female recombination rates be used.}
 
-\item{keepParents}{should previous parents be used for mother and 
+\item{keepParents}{should previous parents be used for mother and
 father.}
 
 \item{simParam}{an object of 'SimParam' class}
@@ -22,8 +22,8 @@ father.}
 Returns an object of \code{\link{Pop-class}}
 }
 \description{
-Creates DH lines from each individual in a population. 
-Only works with diploid individuals. For polyploids, use 
+Creates DH lines from each individual in a population.
+Only works with diploid individuals. For polyploids, use
 \code{\link{reduceGenome}} and \code{\link{doubleGenome}}.
 }
 \examples{

---FILE: man/mergePops.Rd---
@@ -7,8 +7,8 @@
 mergePops(popList)
 }
 \arguments{
-\item{popList}{a list containing \code{\link{Pop-class}} elements 
-or a \code{\link{MegaPop-class}}}
+\item{popList}{a list containing \code{\link{Pop-class}} elements
+or a \code{\link{MultiPop-class}}}
 }
 \value{
 Returns a \code{\link{Pop-class}}

---FILE: man/newEmptyPop.Rd---
@@ -16,7 +16,7 @@ Returns an object of \code{\link{Pop-class}} with
 zero individuals
 }
 \description{
-Creates an empty \code{\link{Pop-class}} object with user 
+Creates an empty \code{\link{Pop-class}} object with user
 defined ploidy and other parameters taken from simParam.
 }
 \examples{

---FILE: man/newMultiPop.Rd---
@@ -1,21 +1,21 @@
 % Generated by roxygen2: do not edit by hand
 % Please edit documentation in R/Class-Pop.R
-\name{newMegaPop}
-\alias{newMegaPop}
-\title{Create new Mega Population}
+\name{newMultiPop}
+\alias{newMultiPop}
+\title{Create new Multi Population}
 \usage{
-newMegaPop(...)
+newMultiPop(...)
 }
 \arguments{
 \item{...}{one or more \code{\link{Pop-class}} and/or
-\code{\link{MegaPop-class}} objects.}
+\code{\link{MultiPop-class}} objects.}
 }
 \value{
-Returns an object of \code{\link{MegaPop-class}}
+Returns an object of \code{\link{MultiPop-class}}
 }
 \description{
-Creates a new \code{\link{MegaPop-class}} from one or more
-\code{\link{Pop-class}} and/or \code{\link{MegaPop-class}}
+Creates a new \code{\link{MultiPop-class}} from one or more
+\code{\link{Pop-class}} and/or \code{\link{MultiPop-class}}
 objects.
 }
 \examples{
@@ -28,7 +28,7 @@ SP$addTraitA(10)
 
 #Create population
 pop = newPop(founderPop, simParam=SP)
-megaPop = newMegaPop(pop=pop)
-isMegaPop(megaPop)
+megaPop = newMultiPop(pop=pop)
+isMultiPop(megaPop)
 
 }

---FILE: man/pedigreeCross.Rd---
@@ -20,43 +20,43 @@ pedigreeCross(
 \arguments{
 \item{founderPop}{a \code{\link{Pop-class}}}
 
-\item{id}{a vector of unique identifiers for individuals 
-in the pedigree. The values of these IDs are seperate from   
+\item{id}{a vector of unique identifiers for individuals
+in the pedigree. The values of these IDs are seperate from
 the IDs in the founderPop if matchID=FALSE.}
 
-\item{mother}{a vector of identifiers for the mothers 
-of individuals in the pedigree. Must match one of the 
+\item{mother}{a vector of identifiers for the mothers
+of individuals in the pedigree. Must match one of the
 elements in the id vector or they will be treated as unknown.}
 
-\item{father}{a vector of identifiers for the fathers 
-of individuals in the pedigree. Must match one of the 
+\item{father}{a vector of identifiers for the fathers
+of individuals in the pedigree. Must match one of the
 elements in the id vector or they will be treated as unknown.}
 
-\item{matchID}{indicates if the IDs in founderPop should be 
+\item{matchID}{indicates if the IDs in founderPop should be
 matched to the id argument. See details.}
 
-\item{maxCycle}{the maximum number of loops to make over the pedigree 
+\item{maxCycle}{the maximum number of loops to make over the pedigree
 to sort it.}
 
-\item{DH}{an optional vector indicating if an individual 
+\item{DH}{an optional vector indicating if an individual
 should be made a doubled haploid.}
 
-\item{nSelf}{an optional vector indicating how many generations an 
+\item{nSelf}{an optional vector indicating how many generations an
 individual should be selfed.}
 
-\item{useFemale}{If creating DH lines, should female recombination 
+\item{useFemale}{If creating DH lines, should female recombination
 rates be used. This parameter has no effect if, recombRatio=1.}
 
 \item{simParam}{an object of 'SimParam' class}
 }
 \description{
-Creates a \code{\link{Pop-class}} from a generic 
+Creates a \code{\link{Pop-class}} from a generic
 pedigree and a set of founder individuals.
 
-The way in which the user supplied pedigree is used depends on 
-the value of matchID. If matchID is TRUE, the IDs in the user 
-supplied pedigree are matched against founderNames. If matchID 
-is FALSE, founder individuals in the user supplied pedigree are 
+The way in which the user supplied pedigree is used depends on
+the value of matchID. If matchID is TRUE, the IDs in the user
+supplied pedigree are matched against founderNames. If matchID
+is FALSE, founder individuals in the user supplied pedigree are
 randomly sampled from founderPop.
 }
 \examples{

---FILE: man/randCross.Rd---
@@ -21,7 +21,7 @@ randCross(
 
 \item{nProgeny}{number of progeny per cross}
 
-\item{balance}{if using sexes, this option will balance the number 
+\item{balance}{if using sexes, this option will balance the number
 of progeny per parent}
 
 \item{parents}{an optional vector of indices for allowable parents}
@@ -34,7 +34,7 @@ of progeny per parent}
 Returns an object of \code{\link{Pop-class}}
 }
 \description{
-A wrapper for \code{\link{makeCross}} that randomly 
+A wrapper for \code{\link{makeCross}} that randomly
 selects parental combinations for all possible combinantions.
 }
 \examples{

---FILE: man/randCross2.Rd---
@@ -25,13 +25,13 @@ randCross2(
 
 \item{nProgeny}{number of progeny per cross}
 
-\item{balance}{this option will balance the number 
+\item{balance}{this option will balance the number
 of progeny per parent}
 
-\item{femaleParents}{an optional vector of indices for allowable 
+\item{femaleParents}{an optional vector of indices for allowable
 female parents}
 
-\item{maleParents}{an optional vector of indices for allowable 
+\item{maleParents}{an optional vector of indices for allowable
 male parents}
 
 \item{ignoreSexes}{should sex be ignored}
@@ -42,8 +42,8 @@ male parents}
 Returns an object of \code{\link{Pop-class}}
 }
 \description{
-A wrapper for \code{\link{makeCross2}} that randomly 
-selects parental combinations for all possible combinantions between 
+A wrapper for \code{\link{makeCross2}} that randomly
+selects parental combinations for all possible combinantions between
 two populations.
 }
 \examples{

---FILE: man/selectCross.Rd---
@@ -22,51 +22,51 @@ selectCross(
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}}}
 
-\item{nInd}{the number of individuals to select. These individuals 
-are selected without regards to sex and it supercedes values 
-for nFemale and nMale. Thus if the simulation uses sexes, it is 
-likely better to leave this value as NULL and use nFemale and nMale 
+\item{nInd}{the number of individuals to select. These individuals
+are selected without regards to sex and it supercedes values
+for nFemale and nMale. Thus if the simulation uses sexes, it is
+likely better to leave this value as NULL and use nFemale and nMale
 instead.}
 
-\item{nFemale}{the number of females to select. This value is ignored 
+\item{nFemale}{the number of females to select. This value is ignored
 if nInd is set.}
 
-\item{nMale}{the number of males to select. This value is ignored 
+\item{nMale}{the number of males to select. This value is ignored
 if nInd is set.}
 
 \item{nCrosses}{total number of crosses to make}
 
 \item{nProgeny}{number of progeny per cross}
 
-\item{trait}{the trait for selection. Either a number indicating 
+\item{trait}{the trait for selection. Either a number indicating
 a single trait or a function returning a vector of length nInd.}
 
 \item{use}{select on genetic values ""gv"", estimated
-breeding values ""ebv"", breeding values ""bv"", phenotypes ""pheno"", 
+breeding values ""ebv"", breeding values ""bv"", phenotypes ""pheno"",
 or randomly ""rand""}
 
-\item{selectTop}{selects highest values if true. 
+\item{selectTop}{selects highest values if true.
 Selects lowest values if false.}
 
 \item{simParam}{an object of \code{\link{SimParam}}}
 
-\item{...}{additional arguments if using a function for 
+\item{...}{additional arguments if using a function for
 trait}
 
-\item{balance}{if using sexes, this option will balance the number 
-of progeny per parent. This argument occurs after ..., so the argument 
+\item{balance}{if using sexes, this option will balance the number
+of progeny per parent. This argument occurs after ..., so the argument
 name must be matched exactly.}
 }
 \value{
 Returns an object of \code{\link{Pop-class}}
 }
 \description{
-This is a wrapper that combines the functionalities of 
-\code{\link{randCross}} and \code{\link{selectInd}}. The 
-purpose of this wrapper is to combine both selection and 
-crossing in one function call that minimized the amount 
-of intermediate populations created. This reduces RAM usage 
-and simplifies code writing. Note that this wrapper does not 
+This is a wrapper that combines the functionalities of
+\code{\link{randCross}} and \code{\link{selectInd}}. The
+purpose of this wrapper is to combine both selection and
+crossing in one function call that minimized the amount
+of intermediate populations created. This reduces RAM usage
+and simplifies code writing. Note that this wrapper does not
 provide the full functionality of either function.
 }
 \examples{

---FILE: man/selectFam.Rd---
@@ -19,46 +19,46 @@ selectFam(
 )
 }
 \arguments{
-\item{pop}{and object of \code{\link{Pop-class}}, 
-\code{\link{HybridPop-class}} or \code{\link{MegaPop-class}}}
+\item{pop}{and object of \code{\link{Pop-class}},
+\code{\link{HybridPop-class}} or \code{\link{MultiPop-class}}}
 
 \item{nFam}{the number of families to select}
 
-\item{trait}{the trait for selection. Either a number indicating 
+\item{trait}{the trait for selection. Either a number indicating
 a single trait or a function returning a vector of length nInd.}
 
 \item{use}{select on genetic values ""gv"", estimated
-breeding values ""ebv"", breeding values ""bv"", phenotypes ""pheno"", 
+breeding values ""ebv"", breeding values ""bv"", phenotypes ""pheno"",
 or randomly ""rand""}
 
-\item{sex}{which sex to select. Use ""B"" for both, ""F"" for 
-females and ""M"" for males. If the simulation is not using sexes, 
+\item{sex}{which sex to select. Use ""B"" for both, ""F"" for
+females and ""M"" for males. If the simulation is not using sexes,
 the argument is ignored.}
 
-\item{famType}{which type of family to select. Use ""B"" for 
-full-sib families, ""F"" for half-sib families on female side and ""M"" 
+\item{famType}{which type of family to select. Use ""B"" for
+full-sib families, ""F"" for half-sib families on female side and ""M""
 for half-sib families on the male side.}
 
-\item{selectTop}{selects highest values if true. 
+\item{selectTop}{selects highest values if true.
 Selects lowest values if false.}
 
-\item{returnPop}{should results be returned as a 
-\code{\link{Pop-class}}. If FALSE, only the index of selected 
+\item{returnPop}{should results be returned as a
+\code{\link{Pop-class}}. If FALSE, only the index of selected
 individuals is returned.}
 
 \item{candidates}{an optional vector of eligible selection candidates.}
 
 \item{simParam}{an object of \code{\link{SimParam}}}
 
-\item{...}{additional arguments if using a function for 
+\item{...}{additional arguments if using a function for
 trait}
 }
 \value{
-Returns an object of \code{\link{Pop-class}}, 
-\code{\link{HybridPop-class}} or \code{\link{MegaPop-class}}
+Returns an object of \code{\link{Pop-class}},
+\code{\link{HybridPop-class}} or \code{\link{MultiPop-class}}
 }
 \description{
-Selects a subset of full-sib families from a 
+Selects a subset of full-sib families from a
 population.
 }
 \examples{

---FILE: man/selectInd.Rd---
@@ -18,42 +18,42 @@ selectInd(
 )
 }
 \arguments{
-\item{pop}{and object of \code{\link{Pop-class}}, 
-\code{\link{HybridPop-class}} or \code{\link{MegaPop-class}}}
+\item{pop}{and object of \code{\link{Pop-class}},
+\code{\link{HybridPop-class}} or \code{\link{MultiPop-class}}}
 
 \item{nInd}{the number of individuals to select}
 
-\item{trait}{the trait for selection. Either a number indicating 
+\item{trait}{the trait for selection. Either a number indicating
 a single trait or a function returning a vector of length nInd.}
 
 \item{use}{select on genetic values ""gv"", estimated
-breeding values ""ebv"", breeding values ""bv"", phenotypes ""pheno"", 
+breeding values ""ebv"", breeding values ""bv"", phenotypes ""pheno"",
 or randomly ""rand""}
 
-\item{sex}{which sex to select. Use ""B"" for both, ""F"" for 
-females and ""M"" for males. If the simulation is not using sexes, 
+\item{sex}{which sex to select. Use ""B"" for both, ""F"" for
+females and ""M"" for males. If the simulation is not using sexes,
 the argument is ignored.}
 
-\item{selectTop}{selects highest values if true. 
+\item{selectTop}{selects highest values if true.
 Selects lowest values if false.}
 
-\item{returnPop}{should results be returned as a 
-\code{\link{Pop-class}}. If FALSE, only the index of selected 
+\item{returnPop}{should results be returned as a
+\code{\link{Pop-class}}. If FALSE, only the index of selected
 individuals is returned.}
 
 \item{candidates}{an optional vector of eligible selection candidates.}
 
 \item{simParam}{an object of \code{\link{SimParam}}}
 
-\item{...}{additional arguments if using a function for 
+\item{...}{additional arguments if using a function for
 trait}
 }
 \value{
-Returns an object of \code{\link{Pop-class}}, 
-\code{\link{HybridPop-class}} or \code{\link{MegaPop-class}}
+Returns an object of \code{\link{Pop-class}},
+\code{\link{HybridPop-class}} or \code{\link{MultiPop-class}}
 }
 \description{
-Selects a subset of nInd individuals from a 
+Selects a subset of nInd individuals from a
 population.
 }
 \examples{

---FILE: man/selectOP.Rd---
@@ -19,43 +19,43 @@ selectOP(
 )
 }
 \arguments{
-\item{pop}{and object of \code{\link{Pop-class}} 
-or \code{\link{MegaPop-class}}}
+\item{pop}{and object of \code{\link{Pop-class}}
+or \code{\link{MultiPop-class}}}
 
 \item{nInd}{the number of plants to select}
 
 \item{nSeeds}{number of seeds per plant}
 
-\item{probSelf}{percentage of seeds expected from selfing. 
+\item{probSelf}{percentage of seeds expected from selfing.
 Value ranges from 0 to 1.}
 
 \item{pollenControl}{are plants selected before pollination}
 
-\item{trait}{the trait for selection. Either a number indicating 
+\item{trait}{the trait for selection. Either a number indicating
 a single trait or a function returning a vector of length nInd.}
 
 \item{use}{select on genetic values ""gv"", estimated
-breeding values ""ebv"", breeding values ""bv"", phenotypes ""pheno"", 
+breeding values ""ebv"", breeding values ""bv"", phenotypes ""pheno"",
 or randomly ""rand""}
 
-\item{selectTop}{selects highest values if true. 
+\item{selectTop}{selects highest values if true.
 Selects lowest values if false.}
 
 \item{candidates}{an optional vector of eligible selection candidates.}
 
 \item{simParam}{an object of \code{\link{SimParam}}}
 
-\item{...}{additional arguments if using a function for 
+\item{...}{additional arguments if using a function for
 trait}
 }
 \value{
-Returns an object of \code{\link{Pop-class}} 
-or \code{\link{MegaPop-class}}
+Returns an object of \code{\link{Pop-class}}
+or \code{\link{MultiPop-class}}
 }
 \description{
-This function models selection in an open pollinating 
-plant population. It allows for varying the percentage of 
-selfing. The function also provides an option for modeling 
+This function models selection in an open pollinating
+plant population. It allows for varying the percentage of
+selfing. The function also provides an option for modeling
 selection as occuring before or after pollination.
 }
 \examples{

---FILE: man/selectWithinFam.Rd---
@@ -19,47 +19,47 @@ selectWithinFam(
 )
 }
 \arguments{
-\item{pop}{and object of \code{\link{Pop-class}}, 
-\code{\link{HybridPop-class}} or \code{\link{MegaPop-class}}}
+\item{pop}{and object of \code{\link{Pop-class}},
+\code{\link{HybridPop-class}} or \code{\link{MultiPop-class}}}
 
 \item{nInd}{the number of individuals to select within a family}
 
-\item{trait}{the trait for selection. Either a number indicating 
+\item{trait}{the trait for selection. Either a number indicating
 a single trait or a function returning a vector of length nInd.}
 
 \item{use}{select on genetic values ""gv"", estimated
-breeding values ""ebv"", breeding values ""bv"", phenotypes ""pheno"", 
+breeding values ""ebv"", breeding values ""bv"", phenotypes ""pheno"",
 or randomly ""rand""}
 
-\item{sex}{which sex to select. Use ""B"" for both, ""F"" for 
-females and ""M"" for males. If the simulation is not using sexes, 
+\item{sex}{which sex to select. Use ""B"" for both, ""F"" for
+females and ""M"" for males. If the simulation is not using sexes,
 the argument is ignored.}
 
-\item{famType}{which type of family to select. Use ""B"" for 
-full-sib families, ""F"" for half-sib families on female side and ""M"" 
+\item{famType}{which type of family to select. Use ""B"" for
+full-sib families, ""F"" for half-sib families on female side and ""M""
 for half-sib families on the male side.}
 
-\item{selectTop}{selects highest values if true. 
+\item{selectTop}{selects highest values if true.
 Selects lowest values if false.}
 
-\item{returnPop}{should results be returned as a 
-\code{\link{Pop-class}}. If FALSE, only the index of selected 
+\item{returnPop}{should results be returned as a
+\code{\link{Pop-class}}. If FALSE, only the index of selected
 individuals is returned.}
 
 \item{candidates}{an optional vector of eligible selection candidates.}
 
 \item{simParam}{an object of \code{\link{SimParam}}}
 
-\item{...}{additional arguments if using a function for 
+\item{...}{additional arguments if using a function for
 trait}
 }
 \value{
-Returns an object of \code{\link{Pop-class}}, 
-\code{\link{HybridPop-class}} or \code{\link{MegaPop-class}}
+Returns an object of \code{\link{Pop-class}},
+\code{\link{HybridPop-class}} or \code{\link{MultiPop-class}}
 }
 \description{
-Selects a subset of nInd individuals from each  
-full-sib family within a population. Will return all individuals 
+Selects a subset of nInd individuals from each
+full-sib family within a population. Will return all individuals
 from a full-sib family if it has less than or equal to nInd individuals.
 }
 \examples{

---FILE: man/self.Rd---
@@ -13,7 +13,7 @@ self(pop, nProgeny = 1, parents = NULL, keepParents = TRUE, simParam = NULL)
 
 \item{parents}{an optional vector of indices for allowable parents}
 
-\item{keepParents}{should previous parents be used for mother and 
+\item{keepParents}{should previous parents be used for mother and
 father.}
 
 \item{simParam}{an object of \code{\link{SimParam}}}
@@ -22,7 +22,7 @@ father.}
 Returns an object of \code{\link{Pop-class}}
 }
 \description{
-Creates selfed progeny from each individual in a 
+Creates selfed progeny from each individual in a
 population. Only works when sexes is ""no"".
 }
 \examples{

---FILE: man/setPheno.Rd---
@@ -19,7 +19,7 @@ setPheno(
 )
 }
 \arguments{
-\item{pop}{an object of \code{\link{Pop-class}} or 
+\item{pop}{an object of \code{\link{Pop-class}} or
 \code{\link{HybridPop-class}}}
 
 \item{h2}{a vector of desired narrow-sense heritabilities for
@@ -30,15 +30,15 @@ each trait. See details.}
 
 \item{varE}{error (co)variances for traits. See details.}
 
-\item{corE}{an optional matrix for correlations between errors. 
+\item{corE}{an optional matrix for correlations between errors.
 See details.}
 
 \item{reps}{number of replications for phenotype. See details.}
 
-\item{fixEff}{fixed effect to assign to the population. Used 
+\item{fixEff}{fixed effect to assign to the population. Used
 by genomic selection models only.}
 
-\item{p}{the p-value for the environmental covariate 
+\item{p}{the p-value for the environmental covariate
 used by GxE traits. If NULL, a value is
 sampled at random.}
 
@@ -50,47 +50,47 @@ all traits will be set.}
 \item{simParam}{an object of \code{\link{SimParam}}}
 }
 \value{
-Returns an object of \code{\link{Pop-class}} or 
-\code{\link{HybridPop-class}} if onlyPheno=FALSE, if 
+Returns an object of \code{\link{Pop-class}} or
+\code{\link{HybridPop-class}} if onlyPheno=FALSE, if
 onlyPheno=TRUE a matrix is returned
 }
 \description{
-Sets phenotypes for all traits by adding random error 
+Sets phenotypes for all traits by adding random error
 from a multivariate normal distribution.
 }
 \details{
-There are three arguments for setting the error variance of a 
-phenotype: h2, H2, and varE. The user should only use one of these 
-arguments. If the user supplies values for more than one, only one 
+There are three arguments for setting the error variance of a
+phenotype: h2, H2, and varE. The user should only use one of these
+arguments. If the user supplies values for more than one, only one
 will be used according to order in which they are listed above.
 
-The h2 argument allows the user to specify the error variance 
+The h2 argument allows the user to specify the error variance
 according to narrow-sense heritability. This calculation uses the
-additive genetic variance and total genetic variance in the founder 
-population. Thus, the heritability relates to the founder population 
+additive genetic variance and total genetic variance in the founder
+population. Thus, the heritability relates to the founder population
 and not the current population.
 
-The H2 argument allows the user to specify the error variance 
+The H2 argument allows the user to specify the error variance
 according to broad-sense heritability. This calculation uses the
-total genetic variance in the founder population. Thus, the heritability 
+total genetic variance in the founder population. Thus, the heritability
 relates to the founder population and not the current population.
 
 The varE argument allows the user to specify the error variance
-directly. The user may supply a vector describing the error variance 
-for each trait or supply a matrix that specify the covariance of 
+directly. The user may supply a vector describing the error variance
+for each trait or supply a matrix that specify the covariance of
 the errors.
 
-The corE argument allows the user to specify correlations for the 
-error covariance matrix. These correlations are be supplied in addition 
-to the h2, H2, or varE arguments. These correlations will be used to 
-construct a covariance matrix from a vector of variances. If the user 
-supplied a covariance matrix to varE, these correlations will supercede 
+The corE argument allows the user to specify correlations for the
+error covariance matrix. These correlations are be supplied in addition
+to the h2, H2, or varE arguments. These correlations will be used to
+construct a covariance matrix from a vector of variances. If the user
+supplied a covariance matrix to varE, these correlations will supercede
 values provided in that matrix.
 
-The reps parameter is for convenient representation of replicated data. 
-It is intended to represent replicated yield trials in plant 
-breeding programs. In this case, varE is set to the plot error and 
-reps is set to the number of plots per entry. The resulting phenotype 
+The reps parameter is for convenient representation of replicated data.
+It is intended to represent replicated yield trials in plant
+breeding programs. In this case, varE is set to the plot error and
+reps is set to the number of plots per entry. The resulting phenotype
 represents the entry-means.
 }
 \examples{

---FILE: man/setPhenoGCA.Rd---
@@ -33,36 +33,36 @@ each trait. See details in \code{\link{setPheno}}.}
 \item{H2}{a vector of desired broad-sense heritabilities for
 each trait. See details in \code{\link{setPheno}}.}
 
-\item{varE}{error (co)variances for traits. 
+\item{varE}{error (co)variances for traits.
 See details in \code{\link{setPheno}}.}
 
-\item{corE}{an optional matrix for correlations between errors. 
+\item{corE}{an optional matrix for correlations between errors.
 See details in \code{\link{setPheno}}.}
 
-\item{reps}{number of replications for phenotype. 
+\item{reps}{number of replications for phenotype.
 See details in \code{\link{setPheno}}.}
 
-\item{fixEff}{fixed effect to assign to the population. Used 
+\item{fixEff}{fixed effect to assign to the population. Used
 by genomic selection models only.}
 
-\item{p}{the p-value for the environmental covariate 
+\item{p}{the p-value for the environmental covariate
 used by GxE traits. If NULL, a value is
 sampled at random.}
 
-\item{inbred}{are both pop and testers fully inbred. They are only 
-fully inbred if created by \code{\link{newPop}} using inbred founders 
+\item{inbred}{are both pop and testers fully inbred. They are only
+fully inbred if created by \code{\link{newPop}} using inbred founders
 or by the \code{\link{makeDH}} function}
 
 \item{onlyPheno}{should only the phenotype be returned, see return}
 
 \item{simParam}{an object of \code{\link{SimParam}}}
 }
 \value{
-Returns an object of \code{\link{Pop-class}} or 
+Returns an object of \code{\link{Pop-class}} or
 a matrix if onlyPheno=TRUE
 }
 \description{
-Calculates general combining ability from a set of testers and 
+Calculates general combining ability from a set of testers and
 returns these values as phenotypes for a population.
 }
 \examples{

---FILE: man/setPhenoProgTest.Rd---
@@ -25,7 +25,7 @@ setPhenoProgTest(
 
 \item{testPop}{an object of \code{\link{Pop-class}}}
 
-\item{nMatePerInd}{number of times an individual in 'pop' is mated to an 
+\item{nMatePerInd}{number of times an individual in 'pop' is mated to an
 individual in testPop}
 
 \item{use}{true genetic value (\code{gv}) or phenotypes (\code{pheno}, default)}
@@ -36,19 +36,19 @@ each trait. See details in \code{\link{setPheno}}.}
 \item{H2}{a vector of desired broad-sense heritabilities for
 each trait. See details in \code{\link{setPheno}}.}
 
-\item{varE}{error (co)variances for traits. 
+\item{varE}{error (co)variances for traits.
 See details in \code{\link{setPheno}}.}
 
-\item{corE}{an optional matrix for correlations between errors. 
+\item{corE}{an optional matrix for correlations between errors.
 See details in \code{\link{setPheno}}.}
 
-\item{reps}{number of replications for phenotype. 
+\item{reps}{number of replications for phenotype.
 See details in \code{\link{setPheno}}.}
 
-\item{fixEff}{fixed effect to assign to the population. Used 
+\item{fixEff}{fixed effect to assign to the population. Used
 by genomic selection models only.}
 
-\item{p}{the p-value for the environmental covariate 
+\item{p}{the p-value for the environmental covariate
 used by GxE traits. If NULL, a value is
 sampled at random.}
 
@@ -57,20 +57,20 @@ sampled at random.}
 \item{simParam}{an object of \code{\link{SimParam}}}
 }
 \value{
-Returns an object of \code{\link{Pop-class}} or 
+Returns an object of \code{\link{Pop-class}} or
 a matrix if onlyPheno=TRUE
 }
 \description{
-Models a progeny test of individuals in 'pop'. Returns 'pop' with a phenotype 
+Models a progeny test of individuals in 'pop'. Returns 'pop' with a phenotype
 representing the average performance of their progeny. The phenotype is generated
-by mating individuals in 'pop' to randomly chosen individuals in testPop a 
+by mating individuals in 'pop' to randomly chosen individuals in testPop a
 number of times equal to 'nMatePerInd'.
 }
 \details{
-The reps parameter is for convenient representation of replicated data. 
-It was intended for representation of replicated yield trials in plant 
-breeding programs. In this case, varE is set to the plot error and 
-reps is set to the number plots per entry. The resulting phenotype 
+The reps parameter is for convenient representation of replicated data.
+It was intended for representation of replicated yield trials in plant
+breeding programs. In this case, varE is set to the plot error and
+reps is set to the number plots per entry. The resulting phenotype
 would reflect the mean of all replications.
 }
 \examples{

---FILE: man/varAA.Rd---
@@ -12,7 +12,7 @@ varAA(pop, simParam = NULL)
 \item{simParam}{an object of \code{\link{SimParam}}}
 }
 \description{
-Returns additive-by-additive epistatic 
+Returns additive-by-additive epistatic
 variance for all traits
 }
 \examples{"
gaynorr,AlphaSimR,c62d3bed9756e2017e8f8f7f9874bd330769365c,Chris Gaynor,gaynor.robert@hotmail.com,2023-06-29T22:17:06Z,Chris Gaynor,gaynor.robert@hotmail.com,2023-06-29T22:20:33Z,fixed ped as vector bug in `importInbredGeno` and `importHaplo` #141,DESCRIPTION;R/importData.R,False,True,True,False,4,4,8,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
 Version: 1.4.2.9990
-Date: 2023-3-27
+Date: 2023-6-29
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 
@@ -12,7 +12,7 @@ Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   person(""Daniel"", ""Money"", role = ""ctb"", 
   comment = c(ORCID = ""0000-0001-5151-3648"")),
   person(""David"", ""Wilson"", role = ""ctb""),
-  person(""Thiago"",""Oliveira"", role = ""ctb"",
+  person(""Thiago"", ""Oliveira"", role = ""ctb"",
   comment = c(ORCID = ""0000-0002-4555-2584"")),
   person(""Audrey"", ""Martin"", role = ""ctb"",
   comment = c(ORCID = ""0000-0003-2235-0098"")))

---FILE: R/importData.R---
@@ -106,7 +106,7 @@ importInbredGeno = function(geno, genMap, ped=NULL){
   # Extract pedigree, if supplied
   if(!is.null(ped)){
     if(is.vector(ped)){
-      id = as.character(ped[,1])
+      id = as.character(ped)
       stopifnot(length(id)==nrow(geno),
                 !any(duplicated(id)))
       mother = father = rep(""0"", length(id))
@@ -238,7 +238,7 @@ importHaplo = function(haplo, genMap, ploidy=2L, ped=NULL){
   # Extract pedigree, if supplied
   if(!is.null(ped)){
     if(is.vector(ped)){
-      id = as.character(ped[,1])
+      id = as.character(ped)
       stopifnot(length(id)==(nrow(haplo)/ploidy),
                 !any(duplicated(id)))
       mother = father = rep(""0"", length(id))"
gaynorr,AlphaSimR,b2a78426e3d2683b03fa91b8010ed28a313e8b48,Chris Gaynor,gaynor.robert@hotmail.com,2023-06-29T22:17:06Z,Chris Gaynor,gaynor.robert@hotmail.com,2023-06-29T22:17:06Z,fixed ped as vector bug in `importInbredGeno` and `importHaplo`,DESCRIPTION;R/importData.R,False,True,True,False,4,4,8,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
 Version: 1.4.2.9990
-Date: 2023-3-27
+Date: 2023-6-29
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 
@@ -12,7 +12,7 @@ Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   person(""Daniel"", ""Money"", role = ""ctb"", 
   comment = c(ORCID = ""0000-0001-5151-3648"")),
   person(""David"", ""Wilson"", role = ""ctb""),
-  person(""Thiago"",""Oliveira"", role = ""ctb"",
+  person(""Thiago"", ""Oliveira"", role = ""ctb"",
   comment = c(ORCID = ""0000-0002-4555-2584"")),
   person(""Audrey"", ""Martin"", role = ""ctb"",
   comment = c(ORCID = ""0000-0003-2235-0098"")))

---FILE: R/importData.R---
@@ -106,7 +106,7 @@ importInbredGeno = function(geno, genMap, ped=NULL){
   # Extract pedigree, if supplied
   if(!is.null(ped)){
     if(is.vector(ped)){
-      id = as.character(ped[,1])
+      id = as.character(ped)
       stopifnot(length(id)==nrow(geno),
                 !any(duplicated(id)))
       mother = father = rep(""0"", length(id))
@@ -238,7 +238,7 @@ importHaplo = function(haplo, genMap, ploidy=2L, ped=NULL){
   # Extract pedigree, if supplied
   if(!is.null(ped)){
     if(is.vector(ped)){
-      id = as.character(ped[,1])
+      id = as.character(ped)
       stopifnot(length(id)==(nrow(haplo)/ploidy),
                 !any(duplicated(id)))
       mother = father = rep(""0"", length(id))"
gaynorr,AlphaSimR,9b4e7fbe9b78c360b350f40e49f72ca18f9079d9,Chris Gaynor,gaynor.robert@hotmail.com,2023-03-29T15:44:04Z,Chris Gaynor,gaynor.robert@hotmail.com,2023-03-29T15:44:04Z,fixed `writePlink` bug,DESCRIPTION;NEWS.md;R/writePlink.R,False,True,True,False,6,2,8,"---FILE: DESCRIPTION---
@@ -1,7 +1,7 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 1.4.3
+Version: 1.4.3.9990
 Date: 2023-3-27
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),

---FILE: NEWS.md---
@@ -1,3 +1,7 @@
+# AlphaSimR 1.4.3.9990
+
+* fixed bug in `writePlink` to correctly export map positions in cM
+
 # AlphaSimR 1.4.3
 
 * another citation fix

---FILE: R/writePlink.R---
@@ -126,7 +126,7 @@ writePlink = function(pop, baseName, traits=1, use=""pheno"",
   ## Make .map file
   map = rbind(map$chr, # Chromosome
               map$id, # Variant id
-              as.character(map$pos*10), # Genetic map position (cM)
+              as.character(map$pos*100), # Genetic map position (cM)
               as.character(map$site) # Physical map position
               )
   "
gaynorr,AlphaSimR,b931a32cf2077687de2a3ba28810bf0821526fd5,Chris Gaynor,gaynor.robert@hotmail.com,2023-03-27T15:17:36Z,Chris Gaynor,gaynor.robert@hotmail.com,2023-03-27T15:17:36Z,"Revert ""another citation fix""

This reverts commit 8acf7532c46dfbc2bfe67ec4e8d0eff5d11c3820.",DESCRIPTION;NEWS.md;inst/REFERENCES.bib;vignettes/AlphaSimR.bib,False,False,False,False,6,10,16,"---FILE: DESCRIPTION---
@@ -1,7 +1,7 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 1.4.3
+Version: 1.4.2
 Date: 2023-3-27
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),

---FILE: NEWS.md---
@@ -1,7 +1,3 @@
-# AlphaSimR 1.4.3
-
-* another citation fix
-
 # AlphaSimR 1.4.2
 
 * updated MaCS citation to https site

---FILE: inst/REFERENCES.bib---
@@ -45,7 +45,7 @@ @article{FinlayWilkinson
 		title = {The analysis of adaptation in a plant-breeding programme},
 	volume = {14},
 	issn = {1444-9838},
-	url = {https://www.publish.csiro.au/cp/AR9630742},
+	url = {http://www.publish.csiro.au/cp/AR9630742},
 	doi = {10.1071/ar9630742},
 	language = {en},
 	number = {6},
@@ -60,7 +60,7 @@ @article{gaynor_2017
 	title = {A Two-Part Strategy for Using Genomic Selection to Develop Inbred Lines},
 	volume = {57},
 	issn = {0011-183X},
-	url = {https://doi.org/10.2135/cropsci2016.09.0742},
+	url = {https://acsess.onlinelibrary.wiley.com/doi/full/10.2135/cropsci2016.09.0742},
 	doi = {10.2135/cropsci2016.09.0742},
 	language = {en},
 	number = {5},
@@ -75,7 +75,7 @@ @article{Falconer_85
 	title = {A note on {Fisher}'s average effect and average excess},
 	volume = {46},
 	issn = {1469-5073, 0016-6723},
-	url = {https://doi.org/10.1017/S0016672300022825},
+	url = {https://www.cambridge.org/core/journals/genetics-research/article/note-on-fishers-average-effect-and-average-excess/26DFA92B3BA3EA92CD76847BFA21C5C8},
 	doi = {10.1017/S0016672300022825},
 	language = {en},
 	number = {3},

---FILE: vignettes/AlphaSimR.bib---
@@ -60,7 +60,7 @@ @article{gaynor_2017
 	title = {A Two-Part Strategy for Using Genomic Selection to Develop Inbred Lines},
 	volume = {57},
 	issn = {0011-183X},
-	url = {https://doi.org/10.2135/cropsci2016.09.0742},
+	url = {https://acsess.onlinelibrary.wiley.com/doi/full/10.2135/cropsci2016.09.0742},
 	doi = {10.2135/cropsci2016.09.0742},
 	language = {en},
 	number = {5},
@@ -75,7 +75,7 @@ @article{Falconer_85
 	title = {A note on {Fisher}'s average effect and average excess},
 	volume = {46},
 	issn = {1469-5073, 0016-6723},
-	url = {https://doi.org/10.1017/S0016672300022825},
+	url = {https://www.cambridge.org/core/journals/genetics-research/article/note-on-fishers-average-effect-and-average-excess/26DFA92B3BA3EA92CD76847BFA21C5C8},
 	doi = {10.1017/S0016672300022825},
 	language = {en},
 	number = {3},"
gaynorr,AlphaSimR,8acf7532c46dfbc2bfe67ec4e8d0eff5d11c3820,Chris Gaynor,gaynor.robert@hotmail.com,2023-03-27T14:39:50Z,Chris Gaynor,gaynor.robert@hotmail.com,2023-03-27T14:39:50Z,another citation fix,DESCRIPTION;NEWS.md;inst/REFERENCES.bib;vignettes/AlphaSimR.bib,False,False,False,False,10,6,16,"---FILE: DESCRIPTION---
@@ -1,7 +1,7 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 1.4.2
+Version: 1.4.3
 Date: 2023-3-27
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),

---FILE: NEWS.md---
@@ -1,3 +1,7 @@
+# AlphaSimR 1.4.3
+
+* another citation fix
+
 # AlphaSimR 1.4.2
 
 * updated MaCS citation to https site

---FILE: inst/REFERENCES.bib---
@@ -45,7 +45,7 @@ @article{FinlayWilkinson
 		title = {The analysis of adaptation in a plant-breeding programme},
 	volume = {14},
 	issn = {1444-9838},
-	url = {http://www.publish.csiro.au/cp/AR9630742},
+	url = {https://www.publish.csiro.au/cp/AR9630742},
 	doi = {10.1071/ar9630742},
 	language = {en},
 	number = {6},
@@ -60,7 +60,7 @@ @article{gaynor_2017
 	title = {A Two-Part Strategy for Using Genomic Selection to Develop Inbred Lines},
 	volume = {57},
 	issn = {0011-183X},
-	url = {https://acsess.onlinelibrary.wiley.com/doi/full/10.2135/cropsci2016.09.0742},
+	url = {https://doi.org/10.2135/cropsci2016.09.0742},
 	doi = {10.2135/cropsci2016.09.0742},
 	language = {en},
 	number = {5},
@@ -75,7 +75,7 @@ @article{Falconer_85
 	title = {A note on {Fisher}'s average effect and average excess},
 	volume = {46},
 	issn = {1469-5073, 0016-6723},
-	url = {https://www.cambridge.org/core/journals/genetics-research/article/note-on-fishers-average-effect-and-average-excess/26DFA92B3BA3EA92CD76847BFA21C5C8},
+	url = {https://doi.org/10.1017/S0016672300022825},
 	doi = {10.1017/S0016672300022825},
 	language = {en},
 	number = {3},

---FILE: vignettes/AlphaSimR.bib---
@@ -60,7 +60,7 @@ @article{gaynor_2017
 	title = {A Two-Part Strategy for Using Genomic Selection to Develop Inbred Lines},
 	volume = {57},
 	issn = {0011-183X},
-	url = {https://acsess.onlinelibrary.wiley.com/doi/full/10.2135/cropsci2016.09.0742},
+	url = {https://doi.org/10.2135/cropsci2016.09.0742},
 	doi = {10.2135/cropsci2016.09.0742},
 	language = {en},
 	number = {5},
@@ -75,7 +75,7 @@ @article{Falconer_85
 	title = {A note on {Fisher}'s average effect and average excess},
 	volume = {46},
 	issn = {1469-5073, 0016-6723},
-	url = {https://www.cambridge.org/core/journals/genetics-research/article/note-on-fishers-average-effect-and-average-excess/26DFA92B3BA3EA92CD76847BFA21C5C8},
+	url = {https://doi.org/10.1017/S0016672300022825},
 	doi = {10.1017/S0016672300022825},
 	language = {en},
 	number = {3},"
gaynorr,AlphaSimR,cc9b011215a76183c1d37a9ef727c0e4654fa0cb,Chris Gaynor,gaynor.robert@hotmail.com,2023-03-24T17:05:45Z,Chris Gaynor,gaynor.robert@hotmail.com,2023-03-24T17:05:45Z,Fix for IBD bug,DESCRIPTION;NEWS.md;R/Class-SimParam.R;R/RcppExports.R;man/SimParam.Rd;src/RcppExports.cpp;src/ibd.cpp;src/meiosis.cpp;vignettes/intro.R,False,True,True,False,426,149,575,"---FILE: DESCRIPTION---
@@ -1,8 +1,8 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 1.3.4.9990
-Date: 2022-12-13
+Version: 1.4.0
+Date: 2023-3-24
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: NEWS.md---
@@ -1,3 +1,11 @@
+# AlphaSimR 1.4.0
+
+*fixed a bug in IBD tracking
+
+*add `setFounderHap` to SimParam for applying custom haplotypes to founders
+
+*added `addSnpChipByName` to SimParam for defining SNP chips by marker names
+
 # AlphaSimR 1.3.4
 
 *changed C++ using `sprintf` to use `snprintf`

---FILE: R/Class-SimParam.R---
@@ -315,6 +315,18 @@ SimParam = R6Class(
       }
       invisible(self)
     },
+    
+    #' @description 
+    #' Allows for the manual setting of founder haplotypes. This functionality 
+    #' is not fully documented, because it is still experimental.
+    #' 
+    #' @param hapMap a list of founder haplotypes
+    setFounderHap = function(hapMap){
+      private$.hap = hapMap
+      private$.hasHap = rep(TRUE, length(hapMap))
+      private$.isFounder = rep(FALSE, length(hapMap))
+      invisible(self)
+    },
 
     #' @description
     #' Randomly assigns eligible SNPs to a SNP chip
@@ -347,6 +359,64 @@ SimParam = R6Class(
       self$snpChips[[self$nSnpChips + 1L]] = snpChip
       invisible(self)
     },
+    
+    #' @description
+    #' Assigns SNPs to a SNP chip by supplying marker names. This function does 
+    #' check against excluded SNPs and will not add the SNPs to the list of 
+    #' excluded QTL for the purpose of avoiding overlap between SNPs and QTL. 
+    #' Excluding these SNPs from being used as QTL can be accomplished using 
+    #' the excludeQtl argument in SimParam's restrSegSites function.
+    #'
+    #' @param markers a vector of names for the markers
+    #' @param name optional name for chip
+    #'
+    #' @examples
+    #' #Create founder haplotypes
+    #' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+    #'
+    #' #Set simulation parameters
+    #' SP = SimParam$new(founderPop)
+    #' SP$addSnpChipByName(c(""1_1"",""1_3""))
+    addSnpChipByName = function(markers, name=NULL){
+      genMap = private$.femaleMap
+      
+      # Check that the markers are present on the map
+      genMapMarkerNames = unlist(lapply(genMap, names))
+      stopifnot(all(markers%in%genMapMarkerNames))
+      
+      # Create lociPerChr and lociLoc
+      lociPerChr = integer(length(genMap))
+      lociLoc = vector(""list"", length(genMap))
+      
+      # Loop through chromosomes
+      for(i in 1:length(genMap)){
+        
+        # Initialize lociLoc
+        lociLoc[[i]] = integer()
+        
+        # Find matches if they exist
+        take = match(names(genMap[[i]]), markers)
+        lociPerChr[i] = length(na.omit(take))
+        if(lociPerChr[i]>0L){
+          lociLoc[[i]] = which(!is.na(take))
+        }
+      }
+      lociLoc = unlist(lociLoc)
+      
+      snpChip = new(""LociMap"",
+                    nLoci=sum(lociPerChr),
+                    lociPerChr=lociPerChr,
+                    lociLoc=lociLoc)
+      
+      if(is.null(name)){
+        snpChip@name = paste0(""Chip"",self$nSnpChips + 1L)
+      }else{
+        snpChip@name = name
+      }
+      
+      self$snpChips[[self$nSnpChips + 1L]] = snpChip
+      invisible(self)
+    },
 
     #' @description
     #' Randomly selects the number of snps in structure and then

---FILE: R/RcppExports.R---
@@ -264,14 +264,14 @@ getHybridGv <- function(trait, females, femaleParents, males, maleParents, nThre
     .Call(`_AlphaSimR_getHybridGv`, trait, females, femaleParents, males, maleParents, nThreads)
 }
 
-getFounderIbd <- function(founder, nChr) {
-    .Call(`_AlphaSimR_getFounderIbd`, founder, nChr)
-}
-
 getNonFounderIbd <- function(recHist, mother, father) {
     .Call(`_AlphaSimR_getNonFounderIbd`, recHist, mother, father)
 }
 
+getFounderIbd <- function(founder, nChr) {
+    .Call(`_AlphaSimR_getFounderIbd`, founder, nChr)
+}
+
 createIbdMat <- function(ibd, chr, nLoci, ploidy, nThreads) {
     .Call(`_AlphaSimR_createIbdMat`, ibd, chr, nLoci, ploidy, nThreads)
 }

---FILE: man/SimParam.Rd---
@@ -100,6 +100,17 @@ founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 SP = SimParam$new(founderPop)
 SP$addSnpChip(10)
 
+## ------------------------------------------------
+## Method `SimParam$addSnpChipByName`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addSnpChipByName(c(""1_1"",""1_3""))
+
 ## ------------------------------------------------
 ## Method `SimParam$addTraitA`
 ## ------------------------------------------------
@@ -344,7 +355,9 @@ genetic map}
 \item \href{#method-SimParam-resetPed}{\code{SimParam$resetPed()}}
 \item \href{#method-SimParam-restrSegSites}{\code{SimParam$restrSegSites()}}
 \item \href{#method-SimParam-setSexes}{\code{SimParam$setSexes()}}
+\item \href{#method-SimParam-setFounderHap}{\code{SimParam$setFounderHap()}}
 \item \href{#method-SimParam-addSnpChip}{\code{SimParam$addSnpChip()}}
+\item \href{#method-SimParam-addSnpChipByName}{\code{SimParam$addSnpChipByName()}}
 \item \href{#method-SimParam-addStructuredSnpChip}{\code{SimParam$addStructuredSnpChip()}}
 \item \href{#method-SimParam-addTraitA}{\code{SimParam$addTraitA()}}
 \item \href{#method-SimParam-addTraitAD}{\code{SimParam$addTraitAD()}}
@@ -619,6 +632,24 @@ SP$setSexes(""yes_sys"")
 
 }
 
+}
+\if{html}{\out{<hr>}}
+\if{html}{\out{<a id=""method-SimParam-setFounderHap""></a>}}
+\if{latex}{\out{\hypertarget{method-SimParam-setFounderHap}{}}}
+\subsection{Method \code{setFounderHap()}}{
+Allows for the manual setting of founder haplotypes. This functionality 
+is not fully documented, because it is still experimental.
+\subsection{Usage}{
+\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$setFounderHap(hapMap)}\if{html}{\out{</div>}}
+}
+
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{hapMap}}{a list of founder haplotypes}
+}
+\if{html}{\out{</div>}}
+}
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-SimParam-addSnpChip""></a>}}
@@ -658,6 +689,42 @@ SP$addSnpChip(10)
 
 }
 
+}
+\if{html}{\out{<hr>}}
+\if{html}{\out{<a id=""method-SimParam-addSnpChipByName""></a>}}
+\if{latex}{\out{\hypertarget{method-SimParam-addSnpChipByName}{}}}
+\subsection{Method \code{addSnpChipByName()}}{
+Assigns SNPs to a SNP chip by supplying marker names. This function does 
+check against excluded SNPs and will not add the SNPs to the list of 
+excluded QTL for the purpose of avoiding overlap between SNPs and QTL. 
+Excluding these SNPs from being used as QTL can be accomplished using 
+the excludeQtl argument in SimParam's restrSegSites function.
+\subsection{Usage}{
+\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addSnpChipByName(markers, name = NULL)}\if{html}{\out{</div>}}
+}
+
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{markers}}{a vector of names for the markers}
+
+\item{\code{name}}{optional name for chip}
+}
+\if{html}{\out{</div>}}
+}
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addSnpChipByName(c(""1_1"",""1_3""))
+}
+\if{html}{\out{</div>}}
+
+}
+
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-SimParam-addStructuredSnpChip""></a>}}

---FILE: src/RcppExports.cpp---
@@ -563,18 +563,6 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// getFounderIbd
-arma::field<    arma::field<      arma::field<        arma::Mat<int> > > > getFounderIbd(const arma::field<arma::ivec>& founder, arma::uword nChr);
-RcppExport SEXP _AlphaSimR_getFounderIbd(SEXP founderSEXP, SEXP nChrSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::field<arma::ivec>& >::type founder(founderSEXP);
-    Rcpp::traits::input_parameter< arma::uword >::type nChr(nChrSEXP);
-    rcpp_result_gen = Rcpp::wrap(getFounderIbd(founder, nChr));
-    return rcpp_result_gen;
-END_RCPP
-}
 // getNonFounderIbd
 arma::field<    arma::field<      arma::Mat<int> > > getNonFounderIbd(const arma::field<arma::field<arma::Mat<int> > >& recHist, const arma::field<arma::field<arma::Mat<int> > >& mother, const arma::field<arma::field<arma::Mat<int> > >& father);
 RcppExport SEXP _AlphaSimR_getNonFounderIbd(SEXP recHistSEXP, SEXP motherSEXP, SEXP fatherSEXP) {
@@ -588,6 +576,18 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// getFounderIbd
+arma::field<    arma::field<      arma::field<        arma::Mat<int> > > > getFounderIbd(const arma::field<arma::ivec>& founder, arma::uword nChr);
+RcppExport SEXP _AlphaSimR_getFounderIbd(SEXP founderSEXP, SEXP nChrSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::field<arma::ivec>& >::type founder(founderSEXP);
+    Rcpp::traits::input_parameter< arma::uword >::type nChr(nChrSEXP);
+    rcpp_result_gen = Rcpp::wrap(getFounderIbd(founder, nChr));
+    return rcpp_result_gen;
+END_RCPP
+}
 // createIbdMat
 arma::Mat<int> createIbdMat(arma::field<arma::field<arma::field<arma::Mat<int> > > >& ibd, arma::uvec chr, arma::uvec nLoci, arma::uword ploidy, arma::uword nThreads);
 RcppExport SEXP _AlphaSimR_createIbdMat(SEXP ibdSEXP, SEXP chrSEXP, SEXP nLociSEXP, SEXP ploidySEXP, SEXP nThreadsSEXP) {
@@ -839,8 +839,8 @@ static const R_CallMethodDef CallEntries[] = {
     {""_AlphaSimR_calcChrFreq"", (DL_FUNC) &_AlphaSimR_calcChrFreq, 1},
     {""_AlphaSimR_getGv"", (DL_FUNC) &_AlphaSimR_getGv, 3},
     {""_AlphaSimR_getHybridGv"", (DL_FUNC) &_AlphaSimR_getHybridGv, 6},
-    {""_AlphaSimR_getFounderIbd"", (DL_FUNC) &_AlphaSimR_getFounderIbd, 2},
     {""_AlphaSimR_getNonFounderIbd"", (DL_FUNC) &_AlphaSimR_getNonFounderIbd, 3},
+    {""_AlphaSimR_getFounderIbd"", (DL_FUNC) &_AlphaSimR_getFounderIbd, 2},
     {""_AlphaSimR_createIbdMat"", (DL_FUNC) &_AlphaSimR_createIbdMat, 5},
     {""_AlphaSimR_cross"", (DL_FUNC) &_AlphaSimR_cross, 15},
     {""_AlphaSimR_createDH2"", (DL_FUNC) &_AlphaSimR_createDH2, 7},

---FILE: src/ibd.cpp---
@@ -1,36 +1,160 @@
 #include ""alphasimr.h""
 
-// Converts founder IBD into hap format for SimParam
-// [[Rcpp::export]]
-arma::field< //individual
-  arma::field< //chromosome
-    arma::field< //ploidy
-      arma::Mat<int> > > > getFounderIbd(const arma::field<arma::ivec>& founder, 
-                                         arma::uword nChr){
-        
-        // Generate object for output
-        arma::field< //individual
-          arma::field< //chromosome
-            arma::field< //ploidy
-              arma::Mat<int> > > > output;
-        output.set_size(founder.n_elem);
-        
-        // Allocate output object
-        for(arma::uword i=0; i<founder.n_elem; ++i){
-          output(i).set_size(nChr);
-          for(arma::uword j=0; j<nChr; ++j){
-            output(i)(j).set_size(founder(i).n_elem);
-          }
-          for(arma::uword k=0; k<founder(i).n_elem; ++k){
-            arma::Mat<int> tmp(1,2,arma::fill::ones);
-            tmp(0,0) = founder(i)(k);
-            for(arma::uword j=0; j<nChr; ++j){
-              output(i)(j)(k) = tmp;
-            }
+// Searches for an interval in x containing value
+// Result reported as left most element of the interval
+// Returns last element if value is greater than values of x
+// Set left to the smallest value of the interval to search
+int intervalSearchInt(const arma::Col<int>& x, int value){
+  int left = 0;
+  
+  // Check if crossover is before beginning
+  if(x[left]>value){
+    return -1;
+  }
+  int end = x.n_elem-1;
+  
+  // Check if crossover is at or past end
+  if(x[end]<=value){
+    return end;
+  }
+  
+  // Perform search
+  int right = end;
+  while((right-left)>1){ // Interval can be decreased
+    int middle = (left + right) / 2;
+    if (x[middle] == value){
+      left = middle;
+      
+      // Check if at the end of the vector
+      if(left<end){
+        // Check for identical values to the right
+        while(x[left+1]==value){
+          left += 1;
+          if(left==end){
+            break;
           }
         }
-        return output;
       }
+      break;
+    } else if (x[middle]>value){
+      right = middle;
+    }else{
+      left = middle;
+    }
+  }
+  return left;
+}
+
+// Creates the first section of the IBD matrix
+arma::Mat<int> firstSection(const arma::Mat<int>& parIbd,
+                            int recEnd){
+  // Determine last site before new recombination starts
+  // Assumes recEnd >= 2 and row 1 of parIbd is always 1
+  int matEnd = intervalSearchInt(parIbd.col(1), recEnd-1);
+  
+  // Return rows for the IBD section
+  return parIbd.rows(arma::span(0, matEnd));
+}
+
+// Appends to the IBD matrix
+arma::Mat<int> middleSection(const arma::Mat<int>& ibd, 
+                             const arma::Mat<int>& parIbd,
+                             int recStart, 
+                             int recEnd){
+  // Determine row at or just before recombination
+  int matStart = intervalSearchInt(parIbd.col(1), recStart);
+  
+  // Determine last site before new recombination starts
+  // May equal matStart
+  int matEnd = intervalSearchInt(parIbd.col(1), recEnd-1);
+  
+  // Check if previous IBD section matches section after recombination
+  if(parIbd(matStart,0) == ibd(ibd.n_rows-1,0)){
+    // Increment matStart by 1 to move to next IBD section in parIbd
+    // May move past the number of rows in parIbd, handled in next step
+    ++matStart;
+    
+    // Determine if new information is needed from parIbd
+    if(matStart>matEnd){
+      // No information needed from parIbd
+      return ibd;
+    }else{
+      // Append relevant rows from parIbd to ibd
+      return join_cols(ibd, 
+                       parIbd.rows(arma::span(matStart, matEnd)));
+    }
+  }
+  
+  // Determine if recombination matches start of IBD section (probably rare)
+  // Cases where this happens without an IBD change are handled in previous block
+  if(parIbd(matStart,1) == recStart){
+    // Relevant rows of parIbd can be appended to ibd directly
+    return join_cols(ibd, 
+                     parIbd.rows(arma::span(matStart, matEnd)));
+  }
+  
+  // Recombination occurred within an IBD block, creating a new segment
+  // A new row needs to be added to account for this recombination
+  arma::Mat<int> hapStart = { {parIbd(matStart, 0) , recStart} };
+  
+  // Increment matStart, because first IBD block is now accounted for with hapStart
+  ++matStart;
+  
+  // Determine if additional information is needed from parIbd
+  if(matStart>matEnd){
+    // No additional information needed from parIbd
+    return join_cols(ibd, hapStart);
+  }else{
+    // Appending additional rows from parIbd to ibd
+    return join_cols(join_cols(ibd, hapStart), 
+                     parIbd.rows(arma::span(matStart, matEnd)));
+  }
+}
+
+// Appends to the IBD matrix
+arma::Mat<int> lastSection(const arma::Mat<int>& ibd, 
+                           const arma::Mat<int>& parIbd,
+                           int recStart){
+  int matStart = intervalSearchInt(parIbd.col(1), recStart);
+  
+  // Check if previous IBD section matches section after recombination
+  if(parIbd(matStart,0) == ibd(ibd.n_rows-1,0)){
+    ++matStart;
+    
+    // Check if additional information from parIbd is needed
+    if(matStart == int(parIbd.n_rows)){
+      // No new information needed
+      return ibd;
+    }else{
+      return join_cols(ibd, 
+                       parIbd.rows(arma::span(matStart, parIbd.n_rows-1)));
+    }
+  }
+  
+  // Check if recombination occurs at new IBD section
+  if(parIbd(matStart,1) == recStart){
+    // Relevant rows of parIbd can be appended to ibd directly
+    return join_cols(ibd, 
+                     parIbd.rows(arma::span(matStart, parIbd.n_rows-1)));
+  }
+  
+  // Recombination occurred within an IBD block, creating a new segment
+  // A new row needs to be added to account for this recombination
+  arma::Mat<int> hapStart = { {parIbd(matStart, 0) , recStart} };
+  
+  // Increment matStart, because first IBD block is now accounted for with hapStart
+  ++matStart;
+  
+  // Determine if additional information is needed from parIbd
+  if(matStart == int(parIbd.n_rows)){
+    // No additional information needed from parIbd
+    return join_cols(ibd, hapStart);
+  }else{
+    // Appending additional rows from parIbd to ibd
+    return join_cols(join_cols(ibd, hapStart), 
+                     parIbd.rows(arma::span(matStart, parIbd.n_rows-1)));
+  }
+}
 
 // Calculates IBD for individual using recombination data and parental IBD
 // [[Rcpp::export]]
@@ -63,152 +187,110 @@ arma::field< //chromosome
         Rcpp::stop(""Unexpected parental ploidy levels"");
       }
       
-      
       for(arma::uword i=0; i<nChr; ++i){
+        
+        // Set chromosome to ploidy level
         output(i).set_size(ploidy);
         for(arma::uword j=0; j<ploidy; ++j){
+          
+          
           arma::uword nCO = recHist(i)(j).n_rows - 1;
           if(j<motherPloidy/2){
             // Pull from mother
             if(nCO==0){
               // Direct copy of chromosome IBD
               output(i)(j) = mother(i)(recHist(i)(j)(0,0)-1);
             }else{
-              arma::Mat<int> X;
               // Transfer first section
-              X = mother(i)(recHist(i)(j)(0,0)-1);
-              X = X.rows(find(X.col(1)<recHist(i)(j)(1,1)));
+              arma::Mat<int> X = firstSection(mother(i)(recHist(i)(j)(0,0)-1), 
+                                              recHist(i)(j)(1,1));
               
               // Transfer middle section(s)?
               if(nCO>1){
                 for(arma::uword k=1; k<nCO; ++k){
-                  arma::Mat<int> Y = mother(i)(recHist(i)(j)(k,0)-1);
-                  // Trim end
-                  Y = Y.rows(find(Y.col(1)<recHist(i)(j)(k+1,1)));
-                  
-                  // Trim front
-                  arma::uword l;
-                  arma::uword m = Y.n_rows-1;
-                  for(l=0; l<Y.n_rows; l++){
-                    if(Y(l,1)>recHist(i)(j)(nCO,1)){
-                      m = l-1;
-                      break;
-                    }
-                  }
-                  Y = Y.rows(m,Y.n_rows-1);
-                  
-                  // Check for haplotype match
-                  if(Y(0,0)==X(X.n_rows-1,0)){
-                    // Drop first row
-                    Y.shed_row(0);
-                  }else{
-                    // Change first site to crossover location
-                    Y(0,1) = recHist(i)(j)(k,1);
-                  }
-                  
-                  X = join_cols(X, Y);
+                  X = middleSection(X, 
+                                    mother(i)(recHist(i)(j)(k,0)-1), 
+                                    recHist(i)(j)(k,1), 
+                                    recHist(i)(j)(k+1,1));
                 }
               }
               
               // Transfer last section
-              arma::Mat<int> Y = mother(i)(recHist(i)(j)(nCO,0)-1);
-              
-              // Trim front
-              arma::uword l;
-              arma::uword m = Y.n_rows-1;
-              for(l=0; l<Y.n_rows; l++){
-                if(Y(l,1)>recHist(i)(j)(nCO,1)){
-                  m = l-1;
-                  break;
-                }
-              }
-              Y = Y.rows(m,Y.n_rows-1);
-              
-              // Check for haplotype match
-              if(Y(0,0)==X(X.n_rows-1,0)){
-                // Drop first row
-                Y.shed_row(0);
-              }else{
-                // Change first site to crossover location
-                Y(0,1) = recHist(i)(j)(nCO,1);
-              }
+              X = lastSection(X,
+                              mother(i)(recHist(i)(j)(nCO,0)-1),
+                              recHist(i)(j)(nCO,1));
               
-              output(i)(j) = join_cols(X, Y);
+              output(i)(j) = X;
             }
           }else{
             // Pull from father
             if(nCO==0){
               // Direct copy of chromosome IBD
               output(i)(j) = father(i)(recHist(i)(j)(0,0)-1 );
             }else{
-              arma::Mat<int> X;
               // Transfer first section
-              X = father(i)(recHist(i)(j)(0,0)-1);
-              X = X.rows(find(X.col(1)<recHist(i)(j)(1,1)));
+              arma::Mat<int> X = firstSection(father(i)(recHist(i)(j)(0,0)-1), 
+                                              recHist(i)(j)(1,1));
+              
               
               // Transfer middle section(s)?
               if(nCO>1){
                 for(arma::uword k=1; k<nCO; ++k){
-                  arma::Mat<int> Y = father(i)(recHist(i)(j)(k,0)-1);
-                  // Trim end
-                  Y = Y.rows(find(Y.col(1)<recHist(i)(j)(k+1,1)));
-                  
-                  // Trim front
-                  arma::uword l;
-                  arma::uword m = Y.n_rows-1;
-                  for(l=0; l<Y.n_rows; l++){
-                    if(Y(l,1)>recHist(i)(j)(nCO,1)){
-                      m = l-1;
-                      break;
-                    }
-                  }
-                  Y = Y.rows(m,Y.n_rows-1);
-                  
-                  // Check for haplotype match
-                  if(Y(0,0)==X(X.n_rows-1,0)){
-                    // Drop first row
-                    Y.shed_row(0);
-                  }else{
-                    // Change first site to crossover location
-                    Y(0,1) = recHist(i)(j)(k,1);
-                  }
-                  
-                  X = join_cols(X, Y);
+                  X = middleSection(X, 
+                                    father(i)(recHist(i)(j)(k,0)-1), 
+                                    recHist(i)(j)(k,1), 
+                                    recHist(i)(j)(k+1,1));
                 }
               }
               
               // Transfer last section
-              arma::Mat<int> Y = father(i)(recHist(i)(j)(nCO,0)-1);
-              
-              // Trim front
-              arma::uword l;
-              arma::uword m = Y.n_rows-1;
-              for(l=0; l<Y.n_rows; l++){
-                if(Y(l,1)>recHist(i)(j)(nCO,1)){
-                  m = l-1;
-                  break;
-                }
-              }
-              Y = Y.rows(m,Y.n_rows-1);
-              
-              // Check for haplotype match
-              if(Y(0,0)==X(X.n_rows-1,0)){
-                // Drop first row
-                Y.shed_row(0);
-              }else{
-                // Change first site to crossover location
-                Y(0,1) = recHist(i)(j)(nCO,1);
-              }
+              X = lastSection(X,
+                              father(i)(recHist(i)(j)(nCO,0)-1),
+                              recHist(i)(j)(nCO,1));
               
-              output(i)(j) = join_cols(X, Y);
+              output(i)(j) = X;
             }
           }
         }
       }
       
       return output;
+      
     }
 
+// Converts founder IBD into hap format for SimParam
+// [[Rcpp::export]]
+arma::field< //individual
+  arma::field< //chromosome
+    arma::field< //ploidy
+      arma::Mat<int> > > > getFounderIbd(const arma::field<arma::ivec>& founder, 
+                                         arma::uword nChr){
+        
+        // Generate object for output
+        arma::field< //individual
+          arma::field< //chromosome
+            arma::field< //ploidy
+              arma::Mat<int> > > > output;
+        output.set_size(founder.n_elem);
+        
+        // Allocate output object
+        for(arma::uword i=0; i<founder.n_elem; ++i){
+          output(i).set_size(nChr);
+          for(arma::uword j=0; j<nChr; ++j){
+            output(i)(j).set_size(founder(i).n_elem);
+          }
+          for(arma::uword k=0; k<founder(i).n_elem; ++k){
+            arma::Mat<int> tmp(1,2,arma::fill::ones);
+            tmp(0,0) = founder(i)(k);
+            for(arma::uword j=0; j<nChr; ++j){
+              output(i)(j)(k) = tmp;
+            }
+          }
+        }
+        return output;
+      }
+
+
 // Calculates IBD for individual using recombination data and parental IBD
 // [[Rcpp::export]]
 arma::Mat<int> createIbdMat(arma::field<arma::field<arma::field<arma::Mat<int> > > >& ibd,

---FILE: src/meiosis.cpp---
@@ -244,7 +244,7 @@ arma::field<arma::vec> sampleQuadChiasmata(double start, double exchange, double
 
 // Searches for an interval in x containing value
 // Result reported as left most element of the interval
-// Returns -1 if value is smaller than the values of x
+// Returns an error if value is smaller than the values of x
 // Returns last element if value is greater than values of x
 // Set left to the smallest value of the interval to search
 arma::uword intervalSearch(const arma::vec& x, double& value, arma::uword left=0){

---FILE: vignettes/intro.R---
@@ -0,0 +1,50 @@
+## ----eval=FALSE---------------------------------------------------------------
+#  founderPop = quickHaplo(nInd=1000, nChr=10, segSites=1000)
+
+## ----eval=FALSE---------------------------------------------------------------
+#  SP = SimParam$new(founderPop)
+
+## ----eval=FALSE---------------------------------------------------------------
+#  SP$addTraitA(nQtlPerChr=1000)
+
+## ----eval=FALSE---------------------------------------------------------------
+#  SP$setSexes(""yes_sys"")
+
+## ----eval=FALSE---------------------------------------------------------------
+#  pop = newPop(founderPop)
+
+## ----eval=FALSE---------------------------------------------------------------
+#  genMean = meanG(pop)
+
+## ----eval=FALSE---------------------------------------------------------------
+#  for(generation in 1:20){
+#    pop = selectCross(pop=pop, nFemale=500, nMale=25, use=""gv"", nCrosses=1000)
+#    genMean = c(genMean, meanG(pop))
+#  }
+
+## ----eval=FALSE---------------------------------------------------------------
+#  plot(0:20, genMean, xlab=""Generation"", ylab=""Mean Genetic Value"", type=""l"")
+
+## ----message=FALSE, warning=FALSE---------------------------------------------
+library(AlphaSimR)
+
+## -----------------------------------------------------------------------------
+# Creating Founder Haplotypes
+founderPop = quickHaplo(nInd=1000, nChr=10, segSites=1000)
+
+# Setting Simulation Parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(nQtlPerChr=1000)
+SP$setSexes(""yes_sys"")
+
+# Modeling the Breeding Program
+pop = newPop(founderPop)
+genMean = meanG(pop)
+for(generation in 1:20){
+  pop = selectCross(pop=pop, nFemale=500, nMale=25, use=""gv"", nCrosses=1000)
+  genMean = c(genMean, meanG(pop))
+}
+
+# Examining the Results
+plot(0:20, genMean, xlab=""Generation"", ylab=""Mean Genetic Value"", type=""l"")
+"
gaynorr,AlphaSimR,2215f29d6df172868ad9f2a7fd69bf51f40f3a92,AudreyAAMartin,122282773+AudreyAAMartin@users.noreply.github.com,2023-02-09T21:02:40Z,GitHub,noreply@github.com,2023-02-09T21:02:40Z,Fix to issue 110 (sortPed),R/crossing.R,False,True,True,False,4,4,8,"---FILE: R/crossing.R---
@@ -663,24 +663,24 @@ sortPed = function(id, mother, father, maxCycle=100){
     for(i in which(unsorted)){
       if(is.na(output$mother[i])&is.na(output$father[i])){
         # Is a founder
-        output$gen[i] = gen
+        output$gen[i] = 1
         unsorted[i] = FALSE
       }else if(is.na(output$mother[i])){
         # Mother is a founder
         if(!unsorted[output$father[i]]){
-          output$gen[i] = gen
+          output$gen[i] = output$gen[output$father[i]] + 1
           unsorted[i] = FALSE
         }
       }else if(is.na(output$father[i])){
         # Father is a founder
         if(!unsorted[output$mother[i]]){
-          output$gen[i] = gen
+          output$gen[i] = output$gen[output$mother[i]] + 1
           unsorted[i] = FALSE
         }
       }else{
         # Both parents are in the pedigree
         if(!unsorted[output$mother[i]] & !unsorted[output$father[i]]){
-          output$gen[i] = gen
+          output$gen[i] = pmax(output$gen[output$mother[i]], output$gen[output$father[i]]) + 1
           unsorted[i] = FALSE
         }
       }"
gaynorr,AlphaSimR,e4e994d0438f42570e9b7342d614769c96dc5aa3,Chris Gaynor,gaynor.robert@hotmail.com,2022-12-05T14:04:57Z,Chris Gaynor,gaynor.robert@hotmail.com,2022-12-05T14:04:57Z,"Updating Roxygen version, need to address sprintf issues",DESCRIPTION,False,False,False,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,7 +1,7 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 1.3.3
+Version: 1.3.3.9990
 Date: 2022-12-3
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
@@ -35,7 +35,7 @@ Depends: R (>= 4.0.0), methods, R6
 Imports: Rcpp (>= 0.12.7), Rdpack
 RdMacros: Rdpack
 LinkingTo: Rcpp, RcppArmadillo (>= 0.7.500.0.0), BH
-RoxygenNote: 7.2.1
+RoxygenNote: 7.2.2
 Suggests: knitr, rmarkdown, testthat
 VignetteBuilder: knitr
 NeedsCompilation: true"
gaynorr,AlphaSimR,37b1361359250adb6661f8dcefc9d11f331ec029,Gregor Gorjanc,gregor.gorjanc@gmail.com,2022-12-03T13:48:00Z,Gregor Gorjanc,gregor.gorjanc@gmail.com,2022-12-03T13:48:00Z,Bugfix for covE #101,R/phenotypes.R,False,True,True,False,5,1,6,"---FILE: R/phenotypes.R---
@@ -209,7 +209,11 @@ setPheno = function(pop, h2=NULL, H2=NULL, varE=NULL, corE=NULL,
       stopifnot(length(varE)==nTraits)
     }
   }else{
-    varE = simParam$varE[traits]
+    if(is.matrix(simParam$varE)){
+      varE = simParam$varE[traits, traits]
+    }else{
+      varE = simParam$varE[traits]
+    }
   }
   
   # Set error correlations"
gaynorr,AlphaSimR,b1f841d330bc483e6f7e003b28828dfa6018bae8,Chris Gaynor,gaynor.robert@hotmail.com,2022-11-16T08:20:55Z,Chris Gaynor,gaynor.robert@hotmail.com,2022-11-16T08:20:55Z,bug fixes,NEWS.md;R/importData.R;src/calcGenParam.cpp,False,True,True,False,23,12,35,"---FILE: NEWS.md---
@@ -1,5 +1,9 @@
 # AlphaSimR 1.3.2.9990
 
+*fixed bug in calculation of genic variance
+
+*fixed `importHaplo` not passing ploidy to `newMapPop`
+
 # AlphaSimR 1.3.2
 
 *fixed column name bug with multiple traits in `setEBV`

---FILE: R/importData.R---
@@ -252,7 +252,8 @@ importHaplo = function(haplo, genMap, ploidy=2L, ped=NULL){
   }
   
   founderPop = newMapPop(genMap=genMap,
-                         haplotypes=haplotypes)
+                         haplotypes=haplotypes,
+                         ploidy=ploidy)
   
   if(!is.null(ped)){
     founderPop = new(""NamedMapPop"",

---FILE: src/calcGenParam.cpp---
@@ -338,6 +338,7 @@ Rcpp::List calcGenParam(const Rcpp::S4& trait,
     arma::vec bvE(ploidy+1), ddE(ploidy+1); //Expected for random mating
     double gvMu, gvEMu, genoMu, p, q, dK, alpha, alphaE;
     
+    // Compute genotype frequencies
     for(arma::uword j=0; j<nInd; ++j){
       freq(genoMat(j,i)) += 1;
     }
@@ -346,33 +347,38 @@ Rcpp::List calcGenParam(const Rcpp::S4& trait,
     p = genoMu/dP;
     q = 1-p;
     
-    // Set effects, means and expected frequencies
+    // Expected genotype frequencies
+    freqE.zeros();
+    for(arma::uword k=0; k<(ploidy+1); ++k){
+      dK = double(k);
+      freqE(k) = choose(dP,dK)*std::pow(p,dK)*std::pow(q,dP-dK);
+    }
+    
+    // Set genetic values
     aEff = xa*a(i);
     if(hasD){
       dEff = xd*d(i);
       gv = aEff+dEff;
     }else{
       gv = aEff;
     }
+    
+    // Mean genetic values
     gvMu = accu(freq%gv);
+    gvEMu =  accu(freqE%gv);
     mu(tid) += gvMu;
-    freqE.zeros();
-    for(arma::uword k=0; k<(ploidy+1); ++k){
-      dK = double(k);
-      freqE(k) = choose(dP,dK)*std::pow(p,dK)*std::pow(q,dP-dK);
-    }
+    eMu(tid) += gvEMu;
+    
+    // Average effect
     alpha = accu(freq%(gv-gvMu)%(x-genoMu))/
       accu(freq%(x-genoMu)%(x-genoMu));
-    alphaE = accu(freqE%(gv-gvMu)%(x-genoMu))/
+    alphaE = accu(freqE%(gv-gvEMu)%(x-genoMu))/
       accu(freqE%(x-genoMu)%(x-genoMu)); 
     
-    //Check for divide by zero
+    // Check for divide by zero
     if(!std::isfinite(alpha)) alpha=0;
     if(!std::isfinite(alphaE)) alphaE=0;
     
-    gvEMu =  accu(freqE%gv);
-    eMu(tid) += gvEMu;
-    
     // Set additive genic variances
     bv = (x-genoMu)*alpha; //Breeding values
     bvE = (x-genoMu)*alphaE; //Random mating breeding value"
gaynorr,AlphaSimR,ecfbc879ac7a6b7310be43f7602c009adca57f3d,Chris Gaynor,gaynor.robert@hotmail.com,2022-11-02T13:52:45Z,Chris Gaynor,gaynor.robert@hotmail.com,2022-11-02T13:52:45Z,"version 1.3.2, bugfix patch",DESCRIPTION;NEWS.md;R/Class-Pop.R;R/misc.R;R/pullGeno.R,False,True,True,False,27,7,34,"---FILE: DESCRIPTION---
@@ -1,8 +1,8 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 1.3.1.9990
-Date: 2022-9-27
+Version: 1.3.2
+Date: 2022-11-2
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: NEWS.md---
@@ -1,8 +1,15 @@
-# AlphaSimR 1.3.1.9990
+# AlphaSimR 1.3.2
 
 *fixed column name bug with multiple traits in `setEBV`
+
 *fixed CTD caused by `runMacs` when too many segSites are requested
 
+*fixed missing names in GV when using `resetPop`
+
+*fixed bug in `importTrait`
+
+*`popVar` now deals with matrices having 1 row
+
 # AlphaSimR 1.3.1
 
 *updated link to Gaynor, 2017

---FILE: R/Class-Pop.R---
@@ -746,6 +746,11 @@ resetPop = function(pop,simParam=NULL){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
   pop@nTraits = simParam$nTraits
+  
+  # Extract names to add back at the end
+  traitNames = colnames(pop@gv)
+  
+  # Create empty slots for traits
   pop@pheno = matrix(NA_real_,
                      nrow=pop@nInd,
                      ncol=simParam$nTraits)
@@ -756,6 +761,8 @@ resetPop = function(pop,simParam=NULL){
   pop@gv = matrix(NA_real_,nrow=pop@nInd,
                   ncol=simParam$nTraits)
   pop@fixEff = rep(1L,pop@nInd)
+  
+  # Calculate genetic values
   if(simParam$nTraits>=1){
     for(i in 1:simParam$nTraits){
       tmp = getGv(simParam$traits[[i]],pop,simParam$nThreads)
@@ -765,6 +772,10 @@ resetPop = function(pop,simParam=NULL){
       }
     }
   }
+  
+  # Add back trait names
+  colnames(pop@pheno) = colnames(pop@gv) = traitNames
+  
   return(pop)
 }
 

---FILE: R/misc.R---
@@ -1,3 +1,9 @@
+# Converts a matrix to integer type
+# Intended for genotype matrices of raw type
+convToImat = function(X){
+  return(matrix(as.integer(X), nrow=nrow(X) ,ncol=ncol(X)))
+}
+
 #' @rdname isFemale
 #' @title Test if individuals of a population are female or male
 #'

---FILE: R/pullGeno.R---
@@ -1,7 +1,3 @@
-convToImat = function(X){
-  return(matrix(as.integer(X), nrow=nrow(X) ,ncol=ncol(X)))
-}
-
 selectLoci = function(chr, inLociPerChr, inLociLoc){
   if(is.null(chr)){
     return(list(lociPerChr=inLociPerChr,"
gaynorr,AlphaSimR,d46f67fc950468143965a648b679f08ce0b9d29b,Chris Gaynor,gaynor.robert@hotmail.com,2022-10-19T14:02:43Z,Chris Gaynor,gaynor.robert@hotmail.com,2022-10-19T14:02:43Z,Fixed CTD in runMacs,NEWS.md;src/simulator.cpp,False,False,False,False,2,4,6,"---FILE: NEWS.md---
@@ -1,6 +1,7 @@
 # AlphaSimR 1.3.1.9990
 
 *fixed column name bug with multiple traits in `setEBV`
+*fixed CTD caused by `runMacs` when too many segSites are requested
 
 # AlphaSimR 1.3.1
 

---FILE: src/simulator.cpp---
@@ -699,7 +699,7 @@ Rcpp::List MaCS(Rcpp::String args, arma::uvec maxSites, bool inbred,
   //Check input
   string t = args;
   if (t == """") {
-    Rcpp::stop(""error"");
+    Rcpp::stop(""error passing argument string"");
   }
   
   // Output objects
@@ -715,9 +715,6 @@ Rcpp::List MaCS(Rcpp::String args, arma::uvec maxSites, bool inbred,
     // Run MaCS and check for valid output
     vector<AlphaSimRReturn> macsOutput;
     macsOutput = runFromAlphaSimR(args+seed(chr));
-    if(macsOutput.empty()){
-      Rcpp::stop(""Macs has failed to run."");
-    }
     
     arma::uword nSites, nBins, nHap, nInd;
     nSites = macsOutput.size();"
gaynorr,AlphaSimR,59bcd4544bca34befed655da956861eaabb4b804,Chris Gaynor,gaynor.robert@hotmail.com,2022-10-19T14:01:33Z,Chris Gaynor,gaynor.robert@hotmail.com,2022-10-19T14:01:33Z,Fixed bad check in importTrait,.gitignore;R/Class-SimParam.R,False,True,True,False,2,1,3,"---FILE: .gitignore---
@@ -22,3 +22,4 @@ vignettes/*.pdf
 Notes.txt
 .Rproj.user/
 docs
+.DS_Store

---FILE: R/Class-SimParam.R---
@@ -1247,7 +1247,7 @@ SimParam = R6Class(
         useDom = TRUE
         domEff = as.matrix(domEff)
         stopifnot(nrow(addEff)==nrow(domEff),
-                  ncol(addEff)==nrow(domEff))
+                  ncol(addEff)==ncol(domEff))
       }
 
       # Prepare the intercept"
gaynorr,AlphaSimR,934e36fea54c653ab17fdd9b9283aae39d55adc6,Chris Gaynor,gaynor.robert@hotmail.com,2022-09-28T12:08:19Z,Chris Gaynor,gaynor.robert@hotmail.com,2022-09-28T12:08:19Z,fixed bug in runMacs,R/founderPop.R;src/simulator.cpp,False,True,True,False,13,1,14,"---FILE: R/founderPop.R---
@@ -218,22 +218,34 @@ runMacs = function(nInd,nChr=1, segSites=NULL, inbred=FALSE, species=""GENERIC"",
     }
     command = paste0(popSize,"" "",speciesParams,splitI,"" "",speciesHist,splitJ,"" -s "")
   }
+  
   if(!is.null(manualGenLen)){
     genLen = manualGenLen
   }
+  
   if(length(genLen)==1){
     genLen = rep(genLen, nChr)
   }
+  
+  # Run MaCS
   macsOut = MaCS(command, segSites, inbred, ploidy, 
                  nThreads, seed)
   dim(macsOut$geno) = NULL # Account for matrix bug in RcppArmadillo
+  
+  # Check if desired number of loci were obtained
   nLoci = sapply(macsOut$genMap,length)
+  isLimited = segSites>0
+  if(any(nLoci[isLimited] != segSites[isLimited])){
+    stop(""MaCS did not return enough segSites, use segSites=NULL to return all sites generated by MaCS"")
+  }
+  
   genMap = vector(""list"",nChr)
   for(i in 1:nChr){
     genMap[[i]] = genLen[i]*c(macsOut$genMap[[i]]-macsOut$genMap[[i]][1])
     names(genMap[[i]]) = paste(i,1:length(genMap[[i]]),sep=""_"")
   }
   names(genMap) = as.character(1:nChr)
+  
   output = new(""MapPop"",
                nInd=nInd,
                nChr=nChr,

---FILE: src/simulator.cpp---
@@ -730,7 +730,7 @@ Rcpp::List MaCS(Rcpp::String args, arma::uvec maxSites, bool inbred,
     arma::uvec selSites;
     if(maxSites(chr)>0){
       if(nSites<maxSites(chr)){
-        Rcpp::stop(""Not enough segregating sites generated"");
+        maxSites(chr) = nSites;
       }
       selSites = sampleInt(maxSites(chr),nSites);
       nSites = maxSites(chr);"
gaynorr,AlphaSimR,8f0110a0c02c82283c0e1022321cb94d2375566b,Chris Gaynor,gaynor.robert@hotmail.com,2022-09-09T22:42:16Z,Chris Gaynor,gaynor.robert@hotmail.com,2022-09-09T22:42:16Z,Fixed setEBV bug,DESCRIPTION;NEWS.md;R/GS.R,False,True,True,False,9,6,15,"---FILE: DESCRIPTION---
@@ -1,8 +1,8 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 1.3.1
-Date: 2022-8-25
+Version: 1.3.1.9990
+Date: 2022-9-9
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: NEWS.md---
@@ -1,3 +1,7 @@
+# AlphaSimR 1.3.1.9990
+
+*fixed column name bug with multiple traits in `setEBV`
+
 # AlphaSimR 1.3.1
 
 *updated link to Gaynor, 2017
@@ -49,10 +53,6 @@
 *added `pullMarkerGeno` and `pullMarkerHaplo` to make it easier to extract genotypes and haplotypes of specific loci without defining a trait or SNP chip
 
 *`reduceGenome`, `mergeGenome` and `doubleGenome` should really now work with pedigree and recombination tracking
-    
-## Known issues
-
-*`pedigreeCross` fails without an appropriate warning for some incomplete pedigrees
 
 # AlphaSimR 1.1.2
 

---FILE: R/GS.R---
@@ -1266,6 +1266,9 @@ setEBV = function(pop, solution, value=""gv"", targetPop=NULL,
                nrow=pop@nInd,
                ncol=nTraits)
   
+  # Placeholder names
+  colnames(ebv) = as.character(1:nTraits)
+  
   value = tolower(value)
   
   if(value==""gv""){"
gaynorr,AlphaSimR,18c7574ef7c69953d3c054e8046be8e175d9c13c,Chris Gaynor,gaynor.robert@hotmail.com,2022-08-25T11:58:04Z,Chris Gaynor,gaynor.robert@hotmail.com,2022-08-25T11:58:04Z,"fixed link to Gaynor, 2017",DESCRIPTION;NEWS.md;inst/REFERENCES.bib;vignettes/AlphaSimR.bib,False,False,False,False,8,4,12,"---FILE: DESCRIPTION---
@@ -1,8 +1,8 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 1.3.0
-Date: 2022-8-24
+Version: 1.3.1
+Date: 2022-8-25
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: NEWS.md---
@@ -1,3 +1,7 @@
+# AlphaSimR 1.3.1
+
+*updated link to Gaynor, 2017
+
 # AlphaSimR 1.3.0
 
 *added ability to exclude loci by name in `SimParam$restrSegSites`

---FILE: inst/REFERENCES.bib---
@@ -60,7 +60,7 @@ @article{gaynor_2017
 	title = {A Two-Part Strategy for Using Genomic Selection to Develop Inbred Lines},
 	volume = {57},
 	issn = {0011-183X},
-	url = {https://dl.sciencesocieties.org/publications/cs/abstracts/57/5/2372},
+	url = {https://acsess.onlinelibrary.wiley.com/doi/full/10.2135/cropsci2016.09.0742},
 	doi = {10.2135/cropsci2016.09.0742},
 	language = {en},
 	number = {5},

---FILE: vignettes/AlphaSimR.bib---
@@ -60,7 +60,7 @@ @article{gaynor_2017
 	title = {A Two-Part Strategy for Using Genomic Selection to Develop Inbred Lines},
 	volume = {57},
 	issn = {0011-183X},
-	url = {https://dl.sciencesocieties.org/publications/cs/abstracts/57/5/2372},
+	url = {https://acsess.onlinelibrary.wiley.com/doi/full/10.2135/cropsci2016.09.0742},
 	doi = {10.2135/cropsci2016.09.0742},
 	language = {en},
 	number = {5},"
gaynorr,AlphaSimR,4b66d8086bbe2216dc5c98f046a17a0666651c5b,Chris Gaynor,gaynor.robert@hotmail.com,2022-08-24T17:56:30Z,GitHub,noreply@github.com,2022-08-24T17:56:30Z,Update issue templates,.github/ISSUE_TEMPLATE/bug_report.md,False,False,False,False,2,20,22,"---FILE: .github/ISSUE_TEMPLATE/bug_report.md---
@@ -10,29 +10,11 @@ assignees: ''
 **Describe the bug**
 A clear and concise description of what the bug is.
 
-**To Reproduce**
-Steps to reproduce the behavior:
-1. Go to '...'
-2. Click on '....'
-3. Scroll down to '....'
-4. See error
+**Steps To Reproduce**
+A short script reproducing the bug.
 
 **Expected behavior**
 A clear and concise description of what you expected to happen.
 
-**Screenshots**
-If applicable, add screenshots to help explain your problem.
-
-**Desktop (please complete the following information):**
- - OS: [e.g. iOS]
- - Browser [e.g. chrome, safari]
- - Version [e.g. 22]
-
-**Smartphone (please complete the following information):**
- - Device: [e.g. iPhone6]
- - OS: [e.g. iOS8.1]
- - Browser [e.g. stock browser, safari]
- - Version [e.g. 22]
-
 **Additional context**
 Add any other context about the problem here."
gaynorr,AlphaSimR,16f2caf20ea7b710205ced676ef10a8bc16f5923,Chris Gaynor,gaynor.robert@hotmail.com,2022-08-23T21:46:10Z,Chris Gaynor,gaynor.robert@hotmail.com,2022-08-23T21:46:10Z,fixed bug in restrSegSites,R/Class-SimParam.R;R/pullGeno.R;src/datastructures.cpp,False,True,True,False,8,17,25,"---FILE: R/Class-SimParam.R---
@@ -59,8 +59,8 @@ SimParam = R6Class(
       self$p = 0 # Single pathway gamma model
       self$quadProb = 0 # No quadrivalent pairing
       self$snpChips = list()
-      self$invalidQtl = vector(""list"", founderPop@nChr) # All eligible
-      self$invalidSnp = vector(""list"", founderPop@nChr) # All eligible
+      self$invalidQtl = rep(list(integer()), founderPop@nChr) # All eligible
+      self$invalidSnp = rep(list(integer()), founderPop@nChr) # All eligible
       self$founderPop = founderPop
       self$finalizePop = function(pop, ...){return(pop)}
       self$allowEmptyPop = FALSE # Empty populations trigger an error
@@ -1942,11 +1942,7 @@ SimParam = R6Class(
       # Identify potential sites
       pot = vector('list', self$nChr)
       for(i in 1:self$nChr){
-        if(is.null(restr[[i]])){
-          pot[[i]] = 1:private$.segSites[i]
-        }else{
-          pot[[i]] = setdiff(1:private$.segSites[i], restr[[i]])
-        }
+        pot[[i]] = setdiff(1:private$.segSites[i], restr[[i]])
       }
 
       # Filter for minimum frequency
@@ -1999,15 +1995,15 @@ SimParam = R6Class(
     # a helper for restrSegSites
     .findNamedLoci = function(lociNames){
       # Loci names
-      id = unlist(lapply(private$.femaleMap, names))
+      id = unlist(unname(lapply(private$.femaleMap, names)))
       take = match(lociNames, id)
       if(any(is.na(take))){
         stop(""One or more loci are not on the genetic map. Beware of case sensitivity."")
       }
       
       # Find positions using an interval search strategy on the cumulative sum
       take = unique(take)
-      posList = vector(""list"", self$nChr)
+      posList = rep(list(integer()), self$nChr)
       cumSumSegSite = cumsum(private$.segSites)
       for(i in take){
         # Identify chromosome

---FILE: R/pullGeno.R---
@@ -133,17 +133,17 @@ getGenMap = function(object=NULL, sex=""A""){
   }
   
   # Loci names
-  id = unlist(lapply(genMap, names))
+  id = unlist(unname(lapply(genMap, names)))
   
   # Chromosome names
   nLoci = sapply(genMap, length)
   chr = rep(names(genMap), nLoci)
   
   # Map positions
-  pos = do.call(""c"", genMap)
+  pos = unname(do.call(""c"", genMap))
   
   # Output data.frame
-  return(data.frame(id, chr, pos))
+  return(data.frame(id=id, chr=chr, pos=pos))
 }
 
 #' @title Get SNP genetic map

---FILE: src/datastructures.cpp---
@@ -591,9 +591,7 @@ void GraphBuilder::printHaplotypes(){
 void GraphBuilder::printDataStructures(){
   Rcpp::Rcerr<<endl<<""*** Begin printing structures ***""<<endl;
   
-  double trueLen = 0.0;
   Rcpp::Rcerr<<""Full ARG (list of edges)\n"";
-  trueLen = 0.0;
   for (EdgePtrList::iterator it=pEdgeListInARG->begin();it!=pEdgeListInARG->end();it++){
     EdgePtr curEdge = *it;
     Rcpp::Rcerr<<""low:ht:""<<curEdge->getBottomNodeRef()->getHeight()<<
@@ -604,12 +602,10 @@ void GraphBuilder::printDataStructures(){
               "",pop:""<<curEdge->getTopNodeRef()->getPopulation()<<
                 "",del:""<<curEdge->bDeleted<<
                   "";hist:""<<curEdge->iGraphIteration<<endl;
-    trueLen+=curEdge->getLength();
   }
   
   
   Rcpp::Rcerr<<""Last tree (list of edges)\n"";
-  trueLen = 0.0;
   EdgePtrVector::iterator it=pEdgeVectorInTree->begin();
   unsigned int count=0;
   while(count<iTotalTreeEdges){
@@ -621,7 +617,6 @@ void GraphBuilder::printDataStructures(){
           "";high_ht:""<<curEdge->getTopNodeRef()->getHeight()<<
             "",type:""<<curEdge->getTopNodeRef()->getTypeStr()<<
               "",pop:""<<curEdge->getTopNodeRef()->getPopulation()<<endl;
-    trueLen+=curEdge->getLength();
     ++count;
     ++it;
   }"
gaynorr,AlphaSimR,871c8034d757d86731f67d4f6d62b0e50fb3a9d9,Chris Gaynor,gaynor.robert@hotmail.com,2022-07-28T21:39:23Z,GitHub,noreply@github.com,2022-07-28T21:39:23Z,Update issue templates,.github/ISSUE_TEMPLATE/bug_report.md;.github/ISSUE_TEMPLATE/feature_request.md,False,False,False,False,58,0,58,"---FILE: .github/ISSUE_TEMPLATE/bug_report.md---
@@ -0,0 +1,38 @@
+---
+name: Bug report
+about: Create a report to help us improve
+title: ''
+labels: ''
+assignees: ''
+
+---
+
+**Describe the bug**
+A clear and concise description of what the bug is.
+
+**To Reproduce**
+Steps to reproduce the behavior:
+1. Go to '...'
+2. Click on '....'
+3. Scroll down to '....'
+4. See error
+
+**Expected behavior**
+A clear and concise description of what you expected to happen.
+
+**Screenshots**
+If applicable, add screenshots to help explain your problem.
+
+**Desktop (please complete the following information):**
+ - OS: [e.g. iOS]
+ - Browser [e.g. chrome, safari]
+ - Version [e.g. 22]
+
+**Smartphone (please complete the following information):**
+ - Device: [e.g. iPhone6]
+ - OS: [e.g. iOS8.1]
+ - Browser [e.g. stock browser, safari]
+ - Version [e.g. 22]
+
+**Additional context**
+Add any other context about the problem here.

---FILE: .github/ISSUE_TEMPLATE/feature_request.md---
@@ -0,0 +1,20 @@
+---
+name: Feature request
+about: Suggest an idea for this project
+title: ''
+labels: ''
+assignees: ''
+
+---
+
+**Is your feature request related to a problem? Please describe.**
+A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]
+
+**Describe the solution you'd like**
+A clear and concise description of what you want to happen.
+
+**Describe alternatives you've considered**
+A clear and concise description of any alternative solutions or features you've considered.
+
+**Additional context**
+Add any other context or screenshots about the feature request here."
gaynorr,AlphaSimR,be94187a96dd3e8b78618446763aafb513918155,Chris Gaynor,gaynor.robert@hotmail.com,2022-06-22T15:15:57Z,Chris Gaynor,gaynor.robert@hotmail.com,2022-06-22T15:15:57Z,fixing importData bugs,DESCRIPTION;NEWS;R/Class-SimParam.R;tests/testthat/test-importData.R,False,True,True,False,59,6,65,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
 Version: 1.2.0.9990
-Date: 2022-6-15
+Date: 2022-6-22
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: NEWS---
@@ -1,3 +1,8 @@
+Changes in version 1.2.1
+    
+  Bug fixes
+    -fixed bugs relating to importData functions
+
 Changes in version 1.2.0
     
   New features

---FILE: R/Class-SimParam.R---
@@ -51,7 +51,7 @@ SimParam = R6Class(
     #' #Set simulation parameters
     #' SP = SimParam$new(founderPop)
     initialize = function(founderPop){
-      stopifnot(class(founderPop)==""MapPop"")
+      stopifnot(is(founderPop, ""MapPop""))
       
       # Public items
       self$nThreads = getNumThreads()
@@ -1212,16 +1212,17 @@ SimParam = R6Class(
       if(!is.null(varE)){
         varE = as.numeric(varE)
         stopifnot(length(varE)==nTraits)
+      }else{
+        varE = rep(NA_real_, nTraits)
       }
       
       # Prepare trait names
-      if(is.null(names)){
+      if(is.null(name)){
         name = paste0(""Trait"",1:nTraits+self$nTraits)
       }else{
-        stopifnot(length(names)==nTraits)
+        stopifnot(length(name)==nTraits)
       }
       
-      
       # Extract genetic map and check if marker names are on the map
       genMapMarkerNames = unlist(lapply(private$.femaleMap, names))
       stopifnot(all(markerNames%in%genMapMarkerNames))
@@ -1242,7 +1243,7 @@ SimParam = R6Class(
         lociLoc[[i]] = integer()
         
         # Find matches if they exist
-        take = match(names(genMap[[i]]), markerNames)
+        take = match(names(private$.femaleMap[[i]]), markerNames)
         lociPerChr[i] = length(na.omit(take))
         
         if(lociPerChr[i]>0L){

---FILE: tests/testthat/test-importData.R---
@@ -0,0 +1,47 @@
+context(""importData"")
+
+test_that(""importTrait"",{
+  # Create haplotype data
+  haplo = rbind(c(1,1,0,1,0),
+                c(1,1,0,1,0),
+                c(0,1,1,0,0),
+                c(0,1,1,0,0))
+  colnames(haplo) = letters[1:5]
+  
+  # Create genetic map
+  genMap = data.frame(markerName=letters[1:5],
+                      chromosome=c(1,1,1,2,2),
+                      position=c(0,0.5,1,0.15,0.4))
+  
+  # Create pedigree
+  ped = data.frame(id=c(""a"",""b""),
+                   mother=c(0,0),
+                   father=c(0,0))
+  
+  # Generate an external trait
+  myTrait = data.frame(marker = c(""a"",""c"",""d""),
+                       a = c(1,-1,1))
+  
+  founderPop = importHaplo(haplo = haplo, 
+                           genMap = genMap,
+                           ploidy = 2L,
+                           ped = ped)
+  
+  SP = SimParam$new(founderPop=founderPop)
+  
+  # Import trait
+  SP$importTrait(markerNames = myTrait$marker,
+                 addEff = myTrait$a,
+                 name = ""myTrait"")
+  
+  expect_equal(SP$traits[[1]]@addEff, myTrait$a, tolerance=1e-6)
+  
+  expect_equal(SP$traits[[1]]@intercept, 0, tolerance=1e-6)
+  
+  pop = newPop(founderPop,simParam=SP)
+  
+  expect_equal(unname(pop@gv[1,1]), 3, tolerance=1e-6)
+  
+  expect_equal(unname(pop@gv[2,1]), -3, tolerance=1e-6)
+})
+"
gaynorr,AlphaSimR,acb18a443852506b5e5c36dca058692dbfbb3c48,Chris Gaynor,gaynor.robert@hotmail.com,2022-05-30T10:00:52Z,Chris Gaynor,gaynor.robert@hotmail.com,2022-05-30T10:00:52Z,"fixed another bug in pedigreeCross, unfixed bug with parents as founders",R/crossing.R,False,True,True,False,2,2,4,"---FILE: R/crossing.R---
@@ -866,8 +866,8 @@ pedigreeCross = function(founderPop, id, mother, father, matchID=FALSE,
       # Self?
       if(nSelf[i]>0){
         for(j in 1:nSelf[i]){
-          output[i] = self(output[[i]],
-                           simParam=simParam)
+          output[[i]] = self(output[[i]],
+                             simParam=simParam)
         }
       }
       "
gaynorr,AlphaSimR,2619df4f482dc7cf690d6126760e4ff6e2afb09e,Chris Gaynor,gaynor.robert@hotmail.com,2022-05-30T09:39:08Z,Chris Gaynor,gaynor.robert@hotmail.com,2022-05-30T09:39:08Z,fixed bug in pedigreeCross,R/crossing.R,False,True,True,False,0,1,1,"---FILE: R/crossing.R---
@@ -867,7 +867,6 @@ pedigreeCross = function(founderPop, id, mother, father, matchID=FALSE,
       if(nSelf[i]>0){
         for(j in 1:nSelf[i]){
           output[i] = self(output[[i]],
-                           useFemale=useFemale,
                            simParam=simParam)
         }
       }"
gaynorr,AlphaSimR,f37f69eec1027446cc386ed7cc6b6024148dc739,Chris Gaynor,gaynor.robert@hotmail.com,2022-03-25T22:22:45Z,Chris Gaynor,gaynor.robert@hotmail.com,2022-03-25T22:22:45Z,Hiding most is* functions due documentation errors,NAMESPACE;R/Class-HybridPop.R;R/Class-LociMap.R;R/Class-Pop.R;R/Class-RRsol.R;R/Class-SimParam.R;man/isPop.Rd;man/setMisc.Rd;src/getGeno.cpp;src/meiosis.cpp,False,True,True,False,35,90,125,"---FILE: NAMESPACE---
@@ -34,7 +34,6 @@ export(gv)
 export(hybridCross)
 export(isFemale)
 export(isMale)
-export(isPop)
 export(makeCross)
 export(makeCross2)
 export(makeDH)

---FILE: R/Class-HybridPop.R---
@@ -121,8 +121,7 @@ setMethod(""c"",
           }
 )
 
-#' @describeIn HybridPop Test if object is of a HybridPop class
-#' @export
+# Test if object is of a HybridPop class
 isHybridPop = function(x) {
   ret = is(x, class2 = ""HybridPop"")
   return(ret)

---FILE: R/Class-LociMap.R---
@@ -31,8 +31,7 @@ setValidity(""LociMap"",function(object){
   }
 })
 
-#' @describeIn LociMap Test if object is of a LociMap class
-#' @export
+# Test if object is of a LociMap class
 isLociMap = function(x) {
   ret = is(x, class2 = ""LociMap"")
   return(ret)
@@ -65,8 +64,7 @@ setValidity(""TraitA"",function(object){
   }
 })
 
-#' @describeIn TraitA Test if object is of a TraitA class
-#' @export
+# Test if object is of a TraitA class
 isTraitA = function(x) {
   ret = is(x, class2 = ""TraitA"")
   return(ret)
@@ -98,8 +96,7 @@ setValidity(""TraitA2"",function(object){
   }
 })
 
-#' @describeIn TraitA2 Test if object is of a TraitA2 class
-#' @export
+# Test if object is of a TraitA2 class
 isTraitA2 = function(x) {
   ret = is(x, class2 = ""TraitA2"")
   return(ret)
@@ -133,8 +130,7 @@ setValidity(""TraitAE"",function(object){
   }
 })
 
-#' @describeIn TraitAE Test if object is of a TraitAE class
-#' @export
+# Test if object is of a TraitAE class
 isTraitAE = function(x) {
   ret = is(x, class2 = ""TraitAE"")
   return(ret)
@@ -165,8 +161,7 @@ setValidity(""TraitAD"",function(object){
   }
 })
 
-#' @describeIn TraitAD Test if object is of a TraitAD class
-#' @export
+# Test if object is of a TraitAD class
 isTraitAD = function(x) {
   ret = is(x, class2 = ""TraitAD"")
   return(ret)
@@ -197,8 +192,7 @@ setValidity(""TraitA2D"",function(object){
   }
 })
 
-#' @describeIn TraitA2D Test if object is of a TraitA2D class
-#' @export
+# Test if object is of a TraitA2D class
 isTraitA2D = function(x) {
   ret = is(x, class2 = ""TraitA2D"")
   return(ret)
@@ -232,8 +226,7 @@ setValidity(""TraitADE"",function(object){
   }
 })
 
-#' @describeIn TraitADE Test if object is of a TraitADE class
-#' @export
+# Test if object is of a TraitADE class
 isTraitADE = function(x) {
   ret = is(x, class2 = ""TraitADE"")
   return(ret)
@@ -268,8 +261,7 @@ setValidity(""TraitAG"",function(object){
   }
 })
 
-#' @describeIn TraitAG Test if object is of a TraitAG class
-#' @export
+# Test if object is of a TraitAG class
 isTraitAG = function(x) {
   ret = is(x, class2 = ""TraitAG"")
   return(ret)
@@ -304,8 +296,7 @@ setValidity(""TraitAEG"",function(object){
   }
 })
 
-#' @describeIn TraitAEG Test if object is of a TraitAEG class
-#' @export
+# Test if object is of a TraitAEG class
 isTraitAEG = function(x) {
   ret = is(x, class2 = ""TraitAEG"")
   return(ret)
@@ -340,8 +331,7 @@ setValidity(""TraitADG"",function(object){
   }
 })
 
-#' @describeIn TraitADG Test if object is of a TraitADG class
-#' @export
+# Test if object is of a TraitADG class
 isTraitADG = function(x) {
   ret = is(x, class2 = ""TraitADG"")
   return(ret)
@@ -376,8 +366,7 @@ setValidity(""TraitADEG"",function(object){
   }
 })
 
-#' @describeIn TraitADEG Test if object is of a TraitADEG class
-#' @export
+# Test if object is of a TraitADEG class
 isTraitADEG = function(x) {
   ret = is(x, class2 = ""TraitADEG"")
   return(ret)

---FILE: R/Class-Pop.R---
@@ -111,8 +111,7 @@ setMethod(""show"",
           }
 )
 
-#' @describeIn RawPop Test if object is of RawPop class
-#' @export
+# Test if object is of RawPop class
 isRawPop = function(x) {
   ret = is(x, class2 = ""RawPop"")
   return(ret)
@@ -198,8 +197,7 @@ setMethod(""c"",
           }
 )
 
-#' @describeIn MapPop Test if object is of a MapPop class
-#' @export
+# Test if object is of a MapPop class
 isMapPop = function(x) {
   ret = is(x, class2 = ""MapPop"")
   return(ret)
@@ -339,8 +337,7 @@ cChr = function(...){
   return(x)
 }
 
-#' @describeIn NamedMapPop Test if object is a NamedMapPop class
-#' @export
+# Test if object is a NamedMapPop class
 isNamedMapPop = function(x) {
   ret = is(x, class2 = ""NamedMapPop"")
   return(ret)
@@ -564,7 +561,6 @@ setMethod(""show"",
 #' 
 #' #Create population
 #' pop = newPop(founderPop, simParam=SP)
-#' isPop(pop)
 #' 
 #' @export
 newPop = function(rawPop,id=NULL,mother=NULL,father=NULL,simParam=NULL,...){
@@ -748,8 +744,7 @@ resetPop = function(pop,simParam=NULL){
 }
 
 
-#' @describeIn Pop Test if object is of a Pop class
-#' @export
+# Test if object is of a Pop class
 isPop = function(x) {
   ret = is(x, class2 = ""Pop"")
   return(ret)
@@ -852,7 +847,6 @@ setMethod(""c"",
 #' #Create population
 #' pop = newPop(founderPop, simParam=SP)
 #' megaPop = newMegaPop(pop=pop)
-#' isMegaPop(megaPop)
 #' 
 #' @export
 newMegaPop = function(...){
@@ -863,8 +857,7 @@ newMegaPop = function(...){
   return(output)
 }
 
-#' @describeIn MegaPop Test if object is of a MegaPop class
-#' @export
+# Test if object is of a MegaPop class
 isMegaPop = function(x) {
   ret = is(x, class2 = ""MegaPop"")
   return(ret)

---FILE: R/Class-RRsol.R---
@@ -20,8 +20,7 @@ setClass(""RRsol"",
                  Vu=""matrix"",
                  Ve=""matrix""))
 
-#' @describeIn RRsol Test if object is of a RRsol class
-#' @export
+# Test if object is of a RRsol class
 isRRsol = function(x) {
   ret = is(x, class2 = ""RRsol"")
   return(ret)

---FILE: R/Class-SimParam.R---
@@ -1986,8 +1986,7 @@ sampEpiEff = function(qtlLoci,nTraits,corr,gamma,shape,relVar){
   return(epiEff)
 }
 
-#' @describeIn SimParam Test if object is of a SimParam class
-#' @export
+# Test if object is of a SimParam class
 isSimParam = function(x) {
   ret = is(x, class2 = ""SimParam"")
   return(ret)

---FILE: man/isPop.Rd---
@@ -1,28 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-Pop.R
-\name{isPop}
-\alias{isPop}
-\title{Test if object is of a Population class}
-\usage{
-isPop(x)
-}
-\arguments{
-\item{x}{\code{\link{Pop-class}}}
-}
-\description{
-Utilify function to test if object is of a Population class
-}
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$addTraitA(10)
-
-#Create population
-pop = newPop(founderPop, simParam=SP)
-isPop(pop)
-isPop(SP)
-
-}

---FILE: man/setMisc.Rd---
@@ -17,16 +17,6 @@ it is repeated using \code{rep} (see examples)}
 }
 \value{
 \code{\link{Pop-class}} with \code{x@misc[[*]][[node]]} set
-}
-\description{
-Set miscelaneous information in a population
-}
-\details{
-A \code{NULL} in \code{value} is ignored
-}
-\examples{
-founderGenomes <- quickHaplo(nInd = 3, nChr = 1, segSites = 100)
-SP <- SimParam$new(founderGenomes)
 basePop <- newPop(founderGenomes)
 
 basePop <- setMisc(basePop, node = ""info"", value = 1)
@@ -58,5 +48,10 @@ basePop@misc
 getMisc(x = basePop, node = ""location"")
 
 getMisc(x = basePop)
-
+}
+\description{
+Set miscelaneous information in a population
+}
+\details{
+A \code{NULL} in \code{value} is ignored
 }

---FILE: src/getGeno.cpp---
@@ -16,7 +16,7 @@ arma::Mat<unsigned char> getGeno(const arma::field<arma::Cube<unsigned char> >&
   arma::uword nInd = geno(0).n_slices;
   arma::uword nChr = geno.n_elem;
   arma::uword ploidy = geno(0).n_cols;
-  if(nInd<nThreads){
+  if(nInd < static_cast<arma::uword>(nThreads) ){
     nThreads = nInd;
   }
   arma::Mat<unsigned char> output(nInd,arma::sum(lociPerChr),arma::fill::zeros);
@@ -63,7 +63,7 @@ arma::Mat<unsigned char> getMaternalGeno(const arma::field<arma::Cube<unsigned c
   arma::uword nInd = geno(0).n_slices;
   arma::uword nChr = geno.n_elem;
   arma::uword ploidy = geno(0).n_cols;
-  if(nInd<nThreads){
+  if(nInd < static_cast<arma::uword>(nThreads) ){
     nThreads = nInd;
   }
   arma::Mat<unsigned char> output(nInd,arma::sum(lociPerChr),arma::fill::zeros);
@@ -110,7 +110,7 @@ arma::Mat<unsigned char> getPaternalGeno(const arma::field<arma::Cube<unsigned c
   arma::uword nInd = geno(0).n_slices;
   arma::uword nChr = geno.n_elem;
   arma::uword ploidy = geno(0).n_cols;
-  if(nInd<nThreads){
+  if(nInd < static_cast<arma::uword>(nThreads) ){
     nThreads = nInd;
   }
   arma::Mat<unsigned char> output(nInd,arma::sum(lociPerChr),arma::fill::zeros);
@@ -158,7 +158,7 @@ arma::Mat<unsigned char> getHaplo(const arma::field<arma::Cube<unsigned char> >&
   arma::uword nInd = geno(0).n_slices;
   arma::uword nChr = geno.n_elem;
   arma::uword ploidy = geno(0).n_cols;
-  if(nInd<nThreads){
+  if(nInd < static_cast<arma::uword>(nThreads) ){
     nThreads = nInd;
   }
   arma::Mat<unsigned char> output(nInd*ploidy,arma::sum(lociPerChr));
@@ -207,7 +207,7 @@ arma::Mat<unsigned char> getOneHaplo(const arma::field<arma::Cube<unsigned char>
   
   arma::uword nInd = geno(0).n_slices;
   arma::uword nChr = geno.n_elem;
-  if(nInd<nThreads){
+  if(nInd < static_cast<arma::uword>(nThreads) ){
     nThreads = nInd;
   }
   arma::Mat<unsigned char> output(nInd,arma::sum(lociPerChr));

---FILE: src/meiosis.cpp---
@@ -784,13 +784,13 @@ void transferGeno(const arma::Col<unsigned char>& inChr,
     }
   }
   // Transfer full bytes
-  if(stopByte > startByte){
+  if(stopByte >  startByte){
     outChr(arma::span(startByte,stopByte-1)) = 
       inChr(arma::span(startByte,stopByte-1));
     startByte = stopByte;
   }
   // Transfer partial stop
-  if(inChr.n_elem == startByte){
+  if(inChr.n_elem == static_cast<arma::uword>(startByte) ){
     // End has been reached
     return;
   }else{
@@ -1033,7 +1033,7 @@ Rcpp::List cross(
   if(trackRec){
     hist.setSize(nInd,nChr,ploidy);
   }
-  if(nChr<nThreads){
+  if(nChr < static_cast<arma::uword>(nThreads) ){
     nThreads = nChr;
   }
   //Loop through chromosomes
@@ -1255,7 +1255,7 @@ Rcpp::List createDH2(
   if(trackRec){
     hist.setSize(nInd*nDH,nChr,2);
   }
-  if(nChr<nThreads){
+  if(nChr < static_cast<arma::uword>(nThreads) ){
     nThreads = nChr;
   }
 #ifdef _OPENMP
@@ -1312,7 +1312,7 @@ Rcpp::List createReducedGenome(
   if(trackRec){
     hist.setSize(nInd*nProgeny,nChr,ploidy/2);
   }
-  if(nChr<nThreads){
+  if(nChr < static_cast<arma::uword>(nThreads) ){
     nThreads = nChr;
   }
 #ifdef _OPENMP"
gaynorr,AlphaSimR,571e191b7e787aa7f7cbf94ed67797c9810238bc,Chris Gaynor,gaynor.robert@hotmail.com,2022-03-24T19:00:14Z,Chris Gaynor,gaynor.robert@hotmail.com,2022-03-24T19:00:14Z,spelling corrections,src/meiosis.cpp,False,False,False,False,3,3,6,"---FILE: src/meiosis.cpp---
@@ -13,7 +13,7 @@ class RecHist{
                arma::uword nChr, 
                arma::uword ploidy);
   
-  // Append new recombinations to history
+  // Append new recombination history
   void addHist(arma::Mat<int>& input, 
                arma::uword nInd, 
                arma::uword chrGroup,
@@ -38,7 +38,7 @@ void RecHist::setSize(arma::uword nInd,
   }
 }
 
-// Append new recombinations to history
+// Append new recombination history
 void RecHist::addHist(arma::Mat<int>& input, 
              arma::uword nInd, 
              arma::uword chrGroup,
@@ -1002,7 +1002,7 @@ void quadrivalent(const arma::Col<unsigned char>& chr1,
 // motherPloidy: ploidy level of mother 
 // fatherPloidy: ploidy level of father
 // v: interference parameter for gamma model
-// p: proportion of non-interferring crossovers
+// p: proportion of non-interfering crossovers
 // quadProb: probability of quadrivalent formation
 // nThreads: number of threads for parallel computing
 // [[Rcpp::export]]"
gaynorr,AlphaSimR,06f90e9936fea5b9e02e6a5cad4023ae171427e8,Chris Gaynor,gaynor.robert@hotmail.com,2021-12-14T13:02:56Z,Chris Gaynor,gaynor.robert@hotmail.com,2021-12-14T13:02:56Z,-fixed an error with assigning 1 QTL and/or SNP,NEWS;R/Class-SimParam.R,False,True,True,False,6,1,7,"---FILE: NEWS---
@@ -6,6 +6,7 @@ Changes in version 1.0.4.9990
     
   Bug fixes
     -fixed error in pullIbdHaplo when chr isn't NULL
+    -fixed an error with assigning 1 QTL and/or SNP
 
 Changes in version 1.0.4
 

---FILE: R/Class-SimParam.R---
@@ -1685,7 +1685,11 @@ SimParam = R6Class(
         if(nSitesPerChr[x]==0){
           return(NULL)
         }else{
-          tmp = sort(sample(pot[[x]],nSitesPerChr[x]))
+          if(length(pot[[x]])==1){
+            tmp = pot[[x]]
+          }else{
+            tmp = sort(sample(pot[[x]],nSitesPerChr[x]))
+          }
           # Add site restrictions
           if(private$.restrSites){
             if(QTL){"
gaynorr,AlphaSimR,fcf1abeaa7cd63da26a75c8ca71bb9b977c89432,Gregor Gorjanc,gregor.gorjanc@gmail.com,2021-12-06T21:32:54Z,Gregor Gorjanc,gregor.gorjanc@gmail.com,2021-12-06T21:32:54Z,"Fixing #17 by setting covariances to zero for nInd=1

We need this when we look at breeding value of a honeybee queen.

It seems that when we have nInd=1, then `arma::cov(X,1)` is casting the 1x2 matrix `cbind(bv, dd)` into a vector and calculating 1x1 variance of `c(bv, dd)`, which causes this code `popVar(cbind(bv[,i],dd[,i]))[1,2]` to break (since there is no 2x2 matrix).",R/popSummary.R,False,True,True,False,10,3,13,"---FILE: R/popSummary.R---
@@ -161,6 +161,7 @@ genParam = function(pop,simParam=NULL){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
   stopifnot(class(pop)==""Pop"")
+  nInd=nInd(pop)
   gv=NULL
   bv=NULL
   dd=NULL
@@ -215,9 +216,15 @@ genParam = function(pop,simParam=NULL){
       aa = cbind(aa,rep(0,pop@nInd))
       gv_aa = cbind(gv_aa,rep(0,pop@nInd))
     }
-    covAD_L = c(covAD_L,popVar(cbind(bv[,i],dd[,i]))[1,2])
-    covAAA_L = c(covAAA_L,popVar(cbind(bv[,i],aa[,i]))[1,2])
-    covDAA_L = c(covDAA_L,popVar(cbind(dd[,i],aa[,i]))[1,2])
+    if(nInd==1){
+      covAD_L = c(covAD_L,0)
+      covAAA_L = c(covAAA_L,0)
+      covDAA_L = c(covDAA_L,0)
+    } else {
+      covAD_L = c(covAD_L,popVar(cbind(bv[,i],dd[,i]))[1,2])
+      covAAA_L = c(covAAA_L,popVar(cbind(bv[,i],aa[,i]))[1,2])
+      covDAA_L = c(covDAA_L,popVar(cbind(dd[,i],aa[,i]))[1,2])
+    }
   }
   varA = popVar(bv)
   varD = popVar(dd)"
gaynorr,AlphaSimR,f5d12ee20216c06061ad256764fa608e32eb9f20,Chris Gaynor,gaynor.robert@hotmail.com,2021-10-20T21:58:32Z,Chris Gaynor,gaynor.robert@hotmail.com,2021-10-20T21:58:32Z,Fixing pullIbdHaplo,DESCRIPTION;NEWS;R/pullGeno.R;src/ibd.cpp,False,True,True,False,33,9,42,"---FILE: DESCRIPTION---
@@ -1,8 +1,8 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 1.0.4
-Date: 2021-09-08
+Version: 1.0.4.9990
+Date: 2021-10-20
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: NEWS---
@@ -1,3 +1,11 @@
+Changes in version 1.0.4.9990
+  
+  New features
+    -added snpChip argument to pullIbdHaplo for backwards compatibility
+    
+  Bug fixes
+    -fixed error in pullIbdHaplo when chr isn't NULL
+
 Changes in version 1.0.4
 
   Bug fixes

---FILE: R/pullGeno.R---
@@ -565,7 +565,9 @@ pullSegSiteHaplo = function(pop, haplo=""all"",
 #'
 #' @param pop an object of \code{\link{Pop-class}}
 #' @param chr a vector of chromosomes to retrieve. If NULL,
-#' all chromosome are retrieved.
+#' all chromosomes are retrieved.
+#' @param snpChip an integer indicating which SNP array loci 
+#' are to be retrieved. If NULL, all sites are retrieved.
 #' @param simParam an object of \code{\link{SimParam}}
 #'
 #' @return Returns a matrix of SNP haplotypes.
@@ -585,7 +587,7 @@ pullSegSiteHaplo = function(pop, haplo=""all"",
 #' pullIbdHaplo(pop, simParam=SP)
 #' 
 #' @export
-pullIbdHaplo = function(pop, chr=NULL, simParam=NULL){
+pullIbdHaplo = function(pop, chr=NULL, snpChip=NULL, simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
@@ -614,5 +616,19 @@ pullIbdHaplo = function(pop, chr=NULL, simParam=NULL){
   
   colnames(output) = unlist(lapply(simParam$genMap[chr], names))
   
+  if(!is.null(snpChip)){
+    nLoci = founderPop@nLoci[chr]
+    tmp = getSnpMap(snpChip=snpChip,simParam=simParam)
+    tmp = tmp[tmp$chr%in%chr,]
+    if(length(chr)>1){
+      for(i in 2:length(chr)){
+        j = chr[i]
+        tmp[tmp$chr==j,""site""] =
+          tmp[tmp$chr==j,""site""] + sum(nLoci[1:(i-1)])
+      }
+    }
+    output = output[,tmp$site,drop=FALSE]
+  }
+  
   return(output)
 }

---FILE: src/ibd.cpp---
@@ -212,18 +212,18 @@ arma::Mat<int> createIbdMat(arma::field<arma::field<arma::field<arma::Mat<int> >
     for(arma::uword j=0; j<ploidy; ++j){
       arma::uword stop,start=0;
       for(arma::uword k=0; k<nChr; ++k){
-        arma::uword nSeg = ibd(i)(k)(j).n_rows;
+        arma::uword nSeg = ibd(i)(chr(k))(j).n_rows;
         if(nSeg>1){
           // First segments
           for(arma::uword l=0; l<(nSeg-1); ++l){
-            stop = start + ibd(i)(k)(j)(l+1,1) - ibd(i)(k)(j)(l,1) - 1;
-            output.col(i*ploidy+j).rows(start,stop).fill(ibd(i)(k)(j)(l,0));
+            stop = start + ibd(i)(chr(k))(j)(l+1,1) - ibd(i)(chr(k))(j)(l,1) - 1;
+            output.col(i*ploidy+j).rows(start,stop).fill(ibd(i)(chr(k))(j)(l,0));
             start = stop + 1;
           }
         }
         // Last segment
-        stop = start + nLoci(chr(k)) - ibd(i)(k)(j)(nSeg-1,1);
-        output.col(i*ploidy+j).rows(start,stop).fill(ibd(i)(k)(j)(nSeg-1,0));
+        stop = start + nLoci(chr(k)) - ibd(i)(chr(k))(j)(nSeg-1,1);
+        output.col(i*ploidy+j).rows(start,stop).fill(ibd(i)(chr(k))(j)(nSeg-1,0));
         start = stop+1;
       }
     }"
gaynorr,AlphaSimR,389305056c046d229b9050f612c2b479ec0dc541,Chris Gaynor,gaynor.robert@hotmail.com,2021-09-08T14:56:07Z,Chris Gaynor,gaynor.robert@hotmail.com,2021-09-08T14:56:07Z,Fixed errors in implementation of Gamma Sprinkling model,DESCRIPTION;NEWS;src/RcppExports.cpp;src/meiosis.cpp,False,False,False,False,31,7,38,"---FILE: DESCRIPTION---
@@ -1,8 +1,8 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 1.0.3
-Date: 2021-07-29
+Version: 1.0.4
+Date: 2021-09-08
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: NEWS---
@@ -1,3 +1,8 @@
+Changes in version 1.0.4
+
+  Bug fixes
+    -fixed errors in implementation of Gamma Sprinkling model
+
 Changes in version 1.0.3
 
   Bug fixes

---FILE: src/RcppExports.cpp---
@@ -6,6 +6,11 @@
 
 using namespace Rcpp;
 
+#ifdef RCPP_USE_GLOBAL_ROSTREAM
+Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
+Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
+#endif
+
 // callFastRRBLUP
 Rcpp::List callFastRRBLUP(arma::vec y, arma::field<arma::Cube<unsigned char> >& geno, arma::Col<int>& lociPerChr, arma::uvec lociLoc, double Vu, double Ve, arma::uword maxIter, int nThreads);
 RcppExport SEXP _AlphaSimR_callFastRRBLUP(SEXP ySEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP VuSEXP, SEXP VeSEXP, SEXP maxIterSEXP, SEXP nThreadsSEXP) {

---FILE: src/meiosis.cpp---
@@ -61,7 +61,14 @@ arma::Mat<int> RecHist::getHist(arma::uword ind,
 // n, the number of gamma deviates sampled at a time (affects performance, not results)
 arma::vec sampleChiasmata(double start, double end, double v, 
                           double p, arma::uword n=40){
-  if((1-p)>1e-6){ // Gamma model
+  if((1-p)<1e-6){
+    // All chiasmata from type 2 pathway
+    // Changing v and p to model type 2 with gamma model
+    p = 0;
+    v = 1;
+  }
+  
+  if(p<1e-6){ // Gamma model
     // Sample deviates from a gamma distribution
     arma::vec output = arma::randg<arma::vec>(n, arma::distr_param(v,1.0/(2.0*v)));
     
@@ -101,14 +108,14 @@ arma::vec sampleChiasmata(double start, double end, double v,
     type1 = type1(find(type1<end));
     
     // Sample type 2 deviates from a gamma distribution
-    arma::vec type2 = arma::randg<arma::vec>(n, arma::distr_param(1.0,1.0/(2.0*v*p)));
+    arma::vec type2 = arma::randg<arma::vec>(n, arma::distr_param(1.0,1.0/(2.0*p)));
     
     // Find locations on genetic map
     type2 = cumsum(type2);
     
     // Add additional values if max position less than end
     while(type2(type2.n_elem-1)<end){
-      arma::vec tmp = arma::randg<arma::vec>(n, arma::distr_param(1.0,1.0/(2.0*v*p)));
+      arma::vec tmp = arma::randg<arma::vec>(n, arma::distr_param(1.0,1.0/(2.0*p)));
       tmp = cumsum(tmp) + type2(type2.n_elem-1);
       type2 = join_cols(type2, tmp);
     }
@@ -140,6 +147,13 @@ arma::field<arma::vec> sampleQuadChiasmata(double start, double exchange, double
   arm = shuffle(arm);
   double nearest, terminator, prob;
   
+  if((1-p)<1e-6){
+    // All chiasmata from type 2 pathway
+    // Changing v and p to model type 2 with type 1 pathway
+    p = 0;
+    v = 1;
+  }
+  
   // First arm
   output(arm(0)) = arma::randg<arma::vec>(n1, arma::distr_param(v,1.0/(2.0*v*(1-p))));
   output(arm(0)) = cumsum(output(arm(0))) + start;
@@ -199,14 +213,14 @@ arma::field<arma::vec> sampleQuadChiasmata(double start, double exchange, double
       }
       
       // Sample type 2 deviates from a gamma distribution
-      arma::vec type2 = arma::randg<arma::vec>(n2, arma::distr_param(1.0,1.0/(2.0*v*p)));
+      arma::vec type2 = arma::randg<arma::vec>(n2, arma::distr_param(1.0,1.0/(2.0*p)));
       
       // Find locations on genetic map
       type2 = cumsum(type2);
       
       // Add additional values if max position less than terminator
       while(type2(type2.n_elem-1)<terminator){
-        arma::vec tmp = arma::randg<arma::vec>(n2, arma::distr_param(1.0,1.0/(2.0*v*p)));
+        arma::vec tmp = arma::randg<arma::vec>(n2, arma::distr_param(1.0,1.0/(2.0*p)));
         tmp = cumsum(tmp) + type2(type2.n_elem-1);
         type2 = join_cols(type2, tmp);
       }"
gaynorr,AlphaSimR,a8472ce69b700b96758edab8c819bcde084f30c9,Chris Gaynor,gaynor.robert@hotmail.com,2021-07-29T21:44:01Z,Chris Gaynor,gaynor.robert@hotmail.com,2021-07-29T21:44:01Z,fixed formatting error in genetic maps created by runMacs that broke genotype extraction functions,DESCRIPTION;NEWS;R/founderPop.R,False,True,True,False,8,3,11,"---FILE: DESCRIPTION---
@@ -1,8 +1,8 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 1.0.2
-Date: 2021-07-28
+Version: 1.0.3
+Date: 2021-07-29
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: NEWS---
@@ -1,3 +1,8 @@
+Changes in version 1.0.3
+
+  Bug fixes
+    -fixed formatting error in genetic maps created by runMacs that broke genotype extraction functions
+
 Changes in version 1.0.2
 
   New features

---FILE: R/founderPop.R---
@@ -207,7 +207,7 @@ runMacs = function(nInd,nChr=1, segSites=NULL, inbred=FALSE, species=""GENERIC"",
   nLoci = sapply(macsOut$genMap,length)
   genMap = vector(""list"",nChr)
   for(i in 1:nChr){
-    genMap[[i]] = genLen[i]*(macsOut$genMap[[i]]-macsOut$genMap[[i]][1])
+    genMap[[i]] = genLen[i]*c(macsOut$genMap[[i]]-macsOut$genMap[[i]][1])
     names(genMap[[i]]) = paste(i,1:length(genMap[[i]]),sep=""_"")
   }
   names(genMap) = as.character(1:nChr)"
gaynorr,AlphaSimR,22a3f8fca8508641a46bcd7436b70df703b06be7,Chris Gaynor,gaynor.robert@hotmail.com,2021-05-18T16:33:08Z,Chris Gaynor,gaynor.robert@hotmail.com,2021-05-18T16:33:08Z,fixed typo,inst/CITATION,False,False,False,False,1,1,2,"---FILE: inst/CITATION---
@@ -4,7 +4,7 @@ Gaynor, R. Chris, Gregor Gorjanc, and John M. Hickey. 2021. AlphaSimR: an R pack
 
 citEntry(
   entry    = ""Article"",
-  title    = ""AlphaSimR: an R package for breeding program simulation"",
+  title    = ""AlphaSimR: an R package for breeding program simulations"",
   author   = ""R Chris Gaynor, Gregor Gorjanc, John M Hickey"",
   journal  = ""G3 Gene|Genomes|Genetics"",
   year     = ""2021"","
gaynorr,AlphaSimR,7e038643e82e69dd816382d80d6e81bc2e9c3cfc,Chris Gaynor,gaynor.robert@hotmail.com,2021-04-12T23:16:31Z,Chris Gaynor,gaynor.robert@hotmail.com,2021-04-12T23:16:31Z,"fixed ibd c++ code
need to rewrite pullIbdHaplo",src/ibd.cpp,False,False,False,False,12,10,22,"---FILE: src/ibd.cpp---
@@ -70,16 +70,17 @@ arma::field< //chromosome
                   
                   // Trim front
                   arma::uword l;
+                  arma::uword m = Y.n_rows-1;
                   for(l=0; l<Y.n_rows; l++){
-                    if(Y(l,1)>recHist(i)(j)(k+1,1)){
-                      --l;
+                    if(Y(l,1)>recHist(i)(j)(nCO,1)){
+                      m = l-1;
                       break;
                     }
                   }
-                  Y = Y.rows(l,Y.n_rows-1);
+                  Y = Y.rows(m,Y.n_rows-1);
                   
                   // Check for haplotype match
-                  if(Y(0,1)==X(X.n_rows-1,1)){
+                  if(Y(0,0)==X(X.n_rows-1,0)){
                     // Drop first row
                     Y.shed_row(0);
                   }else{
@@ -106,7 +107,7 @@ arma::field< //chromosome
               Y = Y.rows(m,Y.n_rows-1);
               
               // Check for haplotype match
-              if(Y(0,1)==X(X.n_rows-1,1)){
+              if(Y(0,0)==X(X.n_rows-1,0)){
                 // Drop first row
                 Y.shed_row(0);
               }else{
@@ -136,16 +137,17 @@ arma::field< //chromosome
                   
                   // Trim front
                   arma::uword l;
+                  arma::uword m = Y.n_rows-1;
                   for(l=0; l<Y.n_rows; l++){
-                    if(Y(l,1)>recHist(i)(j)(k+1,1)){
-                      --l;
+                    if(Y(l,1)>recHist(i)(j)(nCO,1)){
+                      m = l-1;
                       break;
                     }
                   }
-                  Y = Y.rows(l,Y.n_rows-1);
+                  Y = Y.rows(m,Y.n_rows-1);
                   
                   // Check for haplotype match
-                  if(Y(0,1)==X(X.n_rows-1,1)){
+                  if(Y(0,0)==X(X.n_rows-1,0)){
                     // Drop first row
                     Y.shed_row(0);
                   }else{
@@ -172,7 +174,7 @@ arma::field< //chromosome
               Y = Y.rows(m,Y.n_rows-1);
               
               // Check for haplotype match
-              if(Y(0,1)==X(X.n_rows-1,1)){
+              if(Y(0,0)==X(X.n_rows-1,0)){
                 // Drop first row
                 Y.shed_row(0);
               }else{"
gaynorr,AlphaSimR,9857e5c0405a6a6d7bc3a245ffc72e847d289a34,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2020-06-15T09:03:35Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2020-06-15T09:03:35Z,"-fixed bug in writeRecords
-cleaned up code in MaCS",DESCRIPTION;R/hybrids.R;R/writeRecords.R;man/setPhenoGCA.Rd;src/algorithm.cpp;src/datastructures.cpp;src/simulator.cpp;src/simulator.h,False,True,True,False,23,735,758,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
 Version: 0.12.2
-Date: 2020-05-19
+Date: 2020-06-15
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""aut"", 

---FILE: R/hybrids.R---
@@ -233,6 +233,8 @@ calcGCA = function(pop,use=""pheno""){
 #' @param fixEff fixed effect to assign to the population. Used 
 #' by genomic selection models only.
 #' @param p the p-value for the environmental covariate 
+#' used by GxE traits. If NULL, a value is
+#' sampled at random.
 #' @param inbred are both pop and testers fully inbred. They are only 
 #' fully inbred if created by \code{\link{newPop}} using inbred founders 
 #' or by the \code{\link{makeDH}} function
@@ -265,7 +267,7 @@ calcGCA = function(pop,use=""pheno""){
 #' 
 #' @export
 setPhenoGCA = function(pop,testers,use=""pheno"",varE=NULL,reps=1,
-                       fixEff=1L,p=0.5,inbred=FALSE,
+                       fixEff=1L,p=NULL,inbred=FALSE,
                        onlyPheno=FALSE,simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)

---FILE: R/writeRecords.R---
@@ -81,26 +81,26 @@ writeRecords = function(pop,dir,snpChip=1,useQtl=FALSE,
     if(useQtl){
       writeGeno(pop@geno,simParam$traits[[snpChip]]@lociPerChr,
                 simParam$traits[[snpChip]]@lociLoc,
-                file.path(dir,""genotype.txt""))
+                file.path(dir,""genotype.txt""),simParam$nThreads)
       if(includeHaplo){
         writeOneHaplo(pop@geno,simParam$traits[[snpChip]]@lociPerChr,
                       simParam$traits[[snpChip]]@lociLoc,1L,
-                      file.path(dir,""haplotype1.txt""))
+                      file.path(dir,""haplotype1.txt""),simParam$nThreads)
         writeOneHaplo(pop@geno,simParam$traits[[snpChip]]@lociPerChr,
                       simParam$traits[[snpChip]]@lociLoc,2L,
-                      file.path(dir,""haplotype2.txt""))
+                      file.path(dir,""haplotype2.txt""),simParam$nThreads)
       }
     }else{
       writeGeno(pop@geno,simParam$snpChips[[snpChip]]@lociPerChr,
                 simParam$snpChips[[snpChip]]@lociLoc,
-                file.path(dir,""genotype.txt""))
+                file.path(dir,""genotype.txt""),simParam$nThreads)
       if(includeHaplo){
         writeOneHaplo(pop@geno,simParam$snpChips[[snpChip]]@lociPerChr,
                       simParam$snpChips[[snpChip]]@lociLoc,1L,
-                      file.path(dir,""haplotype1.txt""))
+                      file.path(dir,""haplotype1.txt""),simParam$nThreads)
         writeOneHaplo(pop@geno,simParam$snpChips[[snpChip]]@lociPerChr,
                       simParam$snpChips[[snpChip]]@lociLoc,2L,
-                      file.path(dir,""haplotype2.txt""))
+                      file.path(dir,""haplotype2.txt""),simParam$nThreads)
       }
     }
   }

---FILE: man/setPhenoGCA.Rd---
@@ -11,7 +11,7 @@ setPhenoGCA(
   varE = NULL,
   reps = 1,
   fixEff = 1L,
-  p = 0.5,
+  p = NULL,
   inbred = FALSE,
   onlyPheno = FALSE,
   simParam = NULL
@@ -33,7 +33,9 @@ dimensions nTraits for correlated errors.}
 \item{fixEff}{fixed effect to assign to the population. Used 
 by genomic selection models only.}
 
-\item{p}{the p-value for the environmental covariate}
+\item{p}{the p-value for the environmental covariate 
+used by GxE traits. If NULL, a value is
+sampled at random.}
 
 \item{inbred}{are both pop and testers fully inbred. They are only 
 fully inbred if created by \code{\link{newPop}} using inbred founders 

---FILE: src/algorithm.cpp---
@@ -34,14 +34,7 @@ EdgePtr GraphBuilder::getRandomEdgeOnTree(double & dSplitPoint,
         found = true;
       }else{
         dRunningLength+=curEdge->getLength();
-        //if (pConfig->bDebug){
-        //Rcpp::Rcerr<<""getRandomEdge: running length: ""<<dRunningLength<<"", random spot ""<<dRandomSpot<<""\n""; 
-        //}
       }
-    }else{
-      //if (pConfig->bDebug){
-      //Rcpp::Rcerr<<""getRandomEdge: Sorry edge was deleted\n""; 
-      //}
     }
     ++counter;
     ++it;
@@ -61,12 +54,8 @@ EdgePtr GraphBuilder::getRandomEdgeToCoalesce(EdgePtr & coalescingEdge,
   
   EdgeIndexQueue & pVectorIndicesToRecycle = this->pVectorIndicesToRecycle->at(iPopulation);
   unsigned int edgeVectorSize = pEdgeVector.size();
-  if (pConfig->bDebug){
-    Rcpp::Rcerr<<""getRandomEdgeToCoalesce: selecting population ""<<iPopulation<<"" with avail edges: ""<< edgeVectorSize<<""\n"";
-  }
   bool found = false;
   int iUnifPick =-1;
-  int out_of_range = 0,already_deleted=0;
   while(!found){
     // guessing by randomly selecting elements from the vector of graph
     // edges appears to work pretty well here
@@ -81,28 +70,14 @@ EdgePtr GraphBuilder::getRandomEdgeToCoalesce(EdgePtr & coalescingEdge,
         pVectorIndicesToRecycle.push(iUnifPick);
         edge->bInQueue = true;
       }
-      if (pConfig->bDebug){
-        //Rcpp::Rcerr<<""getRandomEdgeToCoalesce: edge already deleted \n"";
-        ++already_deleted;
-      }
       // if the proposed coalescing time is within the endpoints of this
       // randomly picked edge, select this edge
     }else if (edge->getBottomNodeRef()->getHeight()<dHeight
                 && edge->getTopNodeRef()->getHeight()>dHeight) {
       found = true;
-    }else{
-      if (pConfig->bDebug){
-        //Rcpp::Rcerr<<""getRandomEdgeToCoalesce: Edge out of range\n"";
-        ++out_of_range;
-      }
     }
   }
   EdgePtr & edge = pEdgeVector[iUnifPick];
-  if (pConfig->bDebug){
-    Rcpp::Rcerr<<""Stats: out of range edges: ""<<out_of_range<<"" and already deleted: ""<<already_deleted<<endl;
-    Rcpp::Rcerr<<""Edge to coalesce: ""<<edge->getBottomNodeRef()->getHeight()<<"" to ""<<
-      edge->getTopNodeRef()->getHeight()<<endl;
-  }
   
   return edge;
 }
@@ -245,14 +220,6 @@ void GraphBuilder::pruneEdgesAbove(EdgePtr & selectedEdge){
     }
     
   }else{
-#ifdef DIAG
-    if (topNodeType!=Node::MIGRATION
-          && topNodeType!=Node::QUERY){
-      Rcpp::Rcerr<<""At edge with ""<<selectedEdge->getBottomNodeRef()->getHeight()<<
-        "" and ""<<selectedEdge->getTopNodeRef()->getHeight()<<endl;
-      throw ""Prune up did not find a migration node"";
-    }
-#endif
     EdgePtr topEdge = topNode->getTopEdgeByIndex(0);
     pruneEdgesAbove(topEdge);
   }
@@ -269,12 +236,6 @@ void GraphBuilder::invokeRecombination(GeneConversionPtr & geneConversionPtr){
   // save old edge if gene conversion
   if (this->bBeginGeneConversion) geneConversionPtr->xOverNode = xOverNode;
   
-  if(pConfig->bDebug){
-    Rcpp::Rcerr<<""Adding xover point at ""<<dSplitPoint<<
-      "" for edge ""<<selectedXoverEdge->getBottomNodeRef()->getHeight()<<
-        "" to ""<<selectedXoverEdge->getTopNodeRef()->getHeight()<<
-          "" of population ""<<selectedXoverEdge->getBottomNodeRef()->getPopulation()<<endl;
-  }
   EventPtr pXoverEventWrapper = EventPtr(new XoverEvent
                                            (Event::XOVER,dSplitPoint,xOverNode->getPopulation()));
   // insert the xover node at the selected edge
@@ -298,18 +259,11 @@ void GraphBuilder::invokeRecombination(GeneConversionPtr & geneConversionPtr){
   // now initialize the parameters that will be sent to the event traversal routine
   EventPtr newCoalEvent;
   // Traverse the events to find the proper coalescent waiting time.
-  if (pConfig->bDebug){
-    Rcpp::Rcerr<<""Calling traverse events\n"";
-  }
   traverseEvents(true,xOverNode,newCoalEvent);
-  if (pConfig->bDebug){
-    Rcpp::Rcerr<<""Traverse events completed successfully\n"";
-  }
   dSplitPoint = newCoalEvent->getTime();
   bool bNewOrigin = false;
   EdgePtr selectedCoalEdge;
   if (dSplitPoint<this->grandMRCA->getHeight()){
-    if(pConfig->bDebug) Rcpp::Rcerr<<""Coalescing at height ""<<dSplitPoint<<endl;
     try{
       selectedCoalEdge = getRandomEdgeToCoalesce(
         coalescingEdge,dSplitPoint);
@@ -330,13 +284,6 @@ void GraphBuilder::invokeRecombination(GeneConversionPtr & geneConversionPtr){
   if (bNewOrigin){
     coalNode = NodePtr(new Node(Node::COAL,
                                 grandMRCA->getPopulation(),dSplitPoint));
-    if(pConfig->bDebug) Rcpp::Rcerr<<""Creating new grand ancestor at ""<<
-      coalNode->getHeight()<<endl;
-#ifdef DIAG
-    if (grandMRCA->getPopulation()!=coalNode->getPopulation()){
-      throw ""Old grandMRCA and new grandMRCA don't match in pop\n"";
-    }
-#endif
     EdgePtr shortEdge = EdgePtr(new Edge(coalNode,grandMRCA));
     shortEdge->iGraphIteration=iGraphIteration;
     addEdge(shortEdge);
@@ -387,14 +334,6 @@ void GraphBuilder::markCurrentTree(){
     bFirstSample = false;
     ++iIterations;
   }
-#ifdef DIAG
-  if (localMRCA->getBottomEdgeByIndex(0)->iGraphIteration!=
-      localMRCA->getBottomEdgeByIndex(1)->iGraphIteration){
-    printDataStructures();
-    Rcpp::Rcerr<<""Proposed grandMRCA at :""<<localMRCA->getHeight()<<endl;
-    throw ""Proposed grandMRCA's edges' histories don't match"";
-  }
-#endif
 }
 
 
@@ -418,15 +357,6 @@ void GraphBuilder::traverseEvents(bool bBuildFromEventList,
   //dMigrationMatrix.clear();
   dMigrationMatrix = pConfig->dMigrationMatrix;
   //}
-  if (pConfig->bDebug){
-    //Rcpp::Rcerr<<""Migration Matrix from copy\n"";
-    //for (int j=0;j<iTotalPops;++j){
-    //  for (int k=0;k<iTotalPops;++k){
-    //    Rcpp::Rcerr<<"" ""<<dMigrationMatrix[j][j];
-    //  }
-    //  Rcpp::Rcerr<<endl;
-    // }
-  }
   // set up pile of coalesced nodes for building the prior tree
   NodePtrSet * pCoalescedNodes = NULL;
   if (!bBuildFromEventList){
@@ -447,9 +377,6 @@ void GraphBuilder::traverseEvents(bool bBuildFromEventList,
   }
   
   // remove any leading events that are marked for deletion.
-  if (pConfig->bDebug){
-    Rcpp::Rcerr<<""Removing leading events marked for deletion\n"";
-  }
   EventPtrList::iterator currentEventIt = pEventList->begin();
   EventPtrList::iterator lastEventIt = pEventList->end();
   EventPtr pNextNewEvent;
@@ -468,9 +395,6 @@ void GraphBuilder::traverseEvents(bool bBuildFromEventList,
   short int iCoalescingPop = -1;
   unsigned long int iCoalRate = 0;
   double dTime = 0.0,dMigration = 0.0,dLastTime = 0.0,dWaitTime=0.;
-  if (pConfig->bDebug){
-    Rcpp::Rcerr<<""Beginning events traversal\n"";
-  }
   while (!bDoneBuild){
     int iEventType = -1;
     if (currentEventIt!=lastEventIt){
@@ -568,10 +492,6 @@ void GraphBuilder::traverseEvents(bool bBuildFromEventList,
           bIsEvent = true;
         }
       }else{
-#ifdef DIAG
-        if (dMigration<0.0)
-          throw ""Negative migration. Program exiting"";
-#endif
         if(iTotalPops>1 && !bUserEventAvailable){
           int iPops = 0;
           for(int j=0; j<iTotalPops; ++j) {
@@ -590,7 +510,6 @@ void GraphBuilder::traverseEvents(bool bBuildFromEventList,
     ){
       dTime = pNextNewEvent->getTime();
       short int eventType =  pNextNewEvent->getType();
-      //if (pConfig->bDebug) Rcpp::Rcerr<<""At time ""<<dTime<<"" event type is  ""<<eventType<<endl;
       if (eventType==Event::PAST_COAL){
         CoalEvent * pExistingCoalEvent =
           static_cast<CoalEvent *>(pNextNewEvent.get());
@@ -620,7 +539,6 @@ void GraphBuilder::traverseEvents(bool bBuildFromEventList,
           for (int j=0;j<iTotalPops;++j){
             dMigrationMatrix[j].push_back(pConfig->dGlobalMigration);
           }
-          if (pConfig->bDebug) Rcpp::Rcerr<<""dMigrationMatrix has dim ""<<dMigrationMatrix.size()<<endl;
         }
         
         
@@ -652,9 +570,6 @@ void GraphBuilder::traverseEvents(bool bBuildFromEventList,
         short int  iSourcePop = migRateEvent->getSourcePop();
         short int iDestPop = migRateEvent->getDestPop();
         double dMigRate = migRateEvent->getRate();
-        if (pConfig->bDebug){
-          Rcpp::Rcerr<<""Mig matrix has dim ""<<dMigrationMatrix.size()<<"" and source,Dest is ""<<iSourcePop<<"",""<<iDestPop<<endl;
-        }
         dMigrationMatrix[iSourcePop][iSourcePop]+=
           dMigRate-dMigrationMatrix[iSourcePop][iDestPop];
         dMigrationMatrix[iSourcePop][iDestPop] = dMigRate;
@@ -692,9 +607,6 @@ void GraphBuilder::traverseEvents(bool bBuildFromEventList,
         <PopJoinEvent *>(pNextNewEvent.get());
         short int iSourcePop = joinEvent->getSourcePop();
         short int iDestPop = joinEvent->getDestPop();
-        if (pConfig->bDebug){
-          Rcpp::Rcerr<<""POPJOIN event encountered at time ""<<dTime<<"" from ""<< iSourcePop<<"" to ""<<iDestPop <<""\n"";
-        }
         if (iSourcePop>=iTotalPops){
           Rcpp::Rcerr <<""Source pop and total pops are ""<<iSourcePop<<"",""<<iTotalPops<<"" in POP JOIN event at history ""<<iGraphIteration<<"". It is recommended that you increase the migration rates and/or number of sampled chromosomes.\n"";
           
@@ -716,9 +628,6 @@ void GraphBuilder::traverseEvents(bool bBuildFromEventList,
           dMigrationMatrix.push_back(newRow);
           for (int j=0;j<iTotalPops;++j)
             dMigrationMatrix[j].push_back(0.0);
-          if (pConfig->bDebug){
-            Rcpp::Rcerr<<""In pop join, dMigrationMatrix dim is ""<<dMigrationMatrix.size()<<endl;
-          }
         }
         
         if (!bBuildFromEventList){
@@ -796,20 +705,12 @@ void GraphBuilder::traverseEvents(bool bBuildFromEventList,
             }
           }
         }
-        if (pConfig->bDebug){
-          Rcpp::Rcerr<<""POPJOIN event completed\n"";
-        }
         // 2013-06-23 GKC end codefix to revise migration matrix
       }else if (eventType==Event::POPSPLIT){
         PopSizeChangeEvent *splitEvent = static_cast
         <PopSizeChangeEvent *>(pNextNewEvent.get());
         short int iSourcePop = splitEvent->getPopulationIndex();
         short int iDestPop = iTotalPops;
-        if (pConfig->bDebug){
-          Rcpp::Rcerr<<""POPSPLIT event encountered at time ""<<dTime<<
-            "" from ""<<iSourcePop<<"" to ""<<iDestPop<<""\n"";
-          //    if (iGraphIteration==887) throw ""test exit"";
-        }
         double dProportion = splitEvent->getPopChangeParam();
         // GKC: 2015-07-05 Add epsilon to migration node
         // to make sure POPSPLIT happens first
@@ -827,8 +728,6 @@ void GraphBuilder::traverseEvents(bool bBuildFromEventList,
         for (int j=0;j<iTotalPops;++j){
           dMigrationMatrix[j].push_back(pConfig->dGlobalMigration);
         }
-        if(pConfig->bDebug) Rcpp::Rcerr<<""POPSPLIT migration matrix expanded ""
-                                <<""to ""<<dMigrationMatrix.size()<<"" rows.\n"";
         // end expand migration matrix
         if (!bBuildFromEventList){
           NodePtrList nodesToMigrate;
@@ -850,10 +749,6 @@ void GraphBuilder::traverseEvents(bool bBuildFromEventList,
             NodePtr parentNode =
               NodePtr(new Node(Node::MIGRATION,
                                iDestPop,dMigrationTime));
-            if(pConfig->bDebug) Rcpp::Rcerr<<
-              ""POPSPLIT in build tree, migration node at time ""
-              <<dMigrationTime<<
-              endl;
             EdgePtr newEdge =
               EdgePtr(new Edge(parentNode,childNode));
             this->addEdge(newEdge);
@@ -873,14 +768,9 @@ void GraphBuilder::traverseEvents(bool bBuildFromEventList,
           //GKC 2015-07-05 make sure the migration event happens
           // after the pop split
           if(nodesToMigrate.size()>0) --currentEventIt;
-          if (pConfig->bDebug) {
-            Rcpp::Rcerr<<""In pop split mig dim is size ""<<dMigrationMatrix.size()<<endl;
-          }
+
         }else{
           iDestPop=iTotalPops-1;
-          if (pConfig->bDebug){
-            Rcpp::Rcerr<<""In POPSPLIT: destpop,sourcepop,size: ""<<iDestPop<<"",""<<iSourcePop<<"",""<<pPopList.size()<<endl;
-          }
           double random = pRandNumGenerator->unifRV();
           bool internal_edge_condition =
             iRequestedPop==iSourcePop &&
@@ -968,20 +858,16 @@ void GraphBuilder::traverseEvents(bool bBuildFromEventList,
         throw ""Event is not implemented yet!"";
       }
       ++currentEventIt;
-      //if (pConfig->bDebug) Rcpp::Rcerr<<""looking for events to mark for deletion\n"";
       bool found = false;
       while(!found && currentEventIt!=lastEventIt){
         if (*currentEventIt==NULL) Rcpp::Rcerr<<""null\n"";
         if ((*currentEventIt)->bMarkedForDelete) {
-          if(pConfig->bDebug)Rcpp::Rcerr<<""Deleting event at ""<<(*currentEventIt)->getTime()<<endl;
           currentEventIt=pEventList->erase(currentEventIt);
         }
         else found = true;
       }
-      //if (pConfig->bDebug) Rcpp::Rcerr<<""user event processing complete\n"";
     }else{
       dTime += dWaitTime;
-      //if(pConfig->bDebug) Rcpp::Rcerr<<""Handling migration or coalescence at time ""<<dTime<<endl;
       if(iEventType==Event::NEW_MIGRATION){
         double dRandMigr =  dMigration*pRandNumGenerator->unifRV();
         vector<int> migrantPops;
@@ -1002,9 +888,6 @@ void GraphBuilder::traverseEvents(bool bBuildFromEventList,
         int migrant=-1,i=0;
         double dSum=0.;
         while (dRandMigr>=dSum && i<iTotalChrom){
-          if (pConfig->bDebug){
-            //Rcpp::Rcerr<<""In existing mig node, dMigrationMatrix size ""<<dMigrationMatrix.size()<<"" and migrantPops[i]: ""<<migrantPops[i]<<endl;
-          }
           dSum += dMigrationMatrix[migrantPops[i]][migrantPops[i]];
           migrant = i ;
           ++i;
@@ -1047,9 +930,6 @@ void GraphBuilder::traverseEvents(bool bBuildFromEventList,
             dMigrationMatrix[source_pop][source_pop];
           dSum = 0.0;
           i = 0;
-          if (pConfig->bDebug){
-            Rcpp::Rcerr<<""2 In existing mig node, dMigrationMatrix size ""<<dMigrationMatrix.size()<<"" and sourcepop, itotalpops: ""<<source_pop<<"",""<<iTotalPops<<endl;
-          }
           
           while (dRandMigr>=dSum && i<iTotalPops){
             if( i != source_pop){
@@ -1152,10 +1032,7 @@ void GraphBuilder::traverseEvents(bool bBuildFromEventList,
           pEventList->insert(currentEventIt,newCoalEvent);
           bDoneBuild = true;
         }
-      }else{
-        if (pConfig->bDebug) Rcpp::Rcerr<< ""No random event could be assigned."";
       }
-      
     }
     dLastTime = dTime;
   }
@@ -1235,29 +1112,15 @@ void GraphBuilder::addMutations(double startPos,double endPos){
       mutateBelowEdge(selectedEdge);
       NodePtrVector::iterator it;
       
-      
-#ifdef DIAG
-      Rcpp::Rcout<<MUTATIONSITE<<FIELD_DELIMITER<<pMutationPtrVector->size()<<
-        FIELD_DELIMITER<< setw(15) << setprecision(9)<<startPos<<
-          FIELD_DELIMITER<< setw(15) << setprecision(9)<<dMutationTime<<
-            FIELD_DELIMITER;
-#endif
-      
       unique_ptr<AlphaSimRReturn> temp(new AlphaSimRReturn());
       temp->length = startPos;
       unsigned int iSampleSize = pConfig->iSampleSize;
       for (unsigned int iSampleIndex=0;iSampleIndex<iSampleSize;++iSampleIndex){
         SampleNode * sample = static_cast<SampleNode*>(pSampleNodeArray[iSampleIndex].get());
         sites[iSampleIndex]=sample->bAffected;
-#ifdef DIAG
-        Rcpp::Rcout<<sample->bAffected;
-#endif
         temp->haplotypes.push_back(sample->bAffected);
         sample->bAffected=false;
       }
-#ifdef DIAG
-      Rcpp::Rcout<<endl;
-#endif
       mutations.push_back(*temp);
       double dFreq=0.;
       if (pConfig->bSNPAscertainment){
@@ -1327,22 +1190,9 @@ bool GraphBuilder::checkPendingGeneConversions(double & curPos){
         EdgePtr edge1 = gc->xOverNode->getTopEdgeByIndex(1);
         if (gc->xOverNode->bDeleted ||
             edge1->iGraphIteration!=iGraphIteration){
-          if (pConfig->bDebug){
-            Rcpp::Rcerr<<""Deleting gene conversion because:""<<endl;
-            if (gc->xOverNode->bDeleted)
-              Rcpp::Rcerr<<""xover node was deleted\n"";
-            else if (edge1->iGraphIteration!=iGraphIteration)
-              Rcpp::Rcerr<<""new edge ""<<edge1->getBottomNodeRef()->getHeight()<<"" to ""<<
-                edge1->getTopNodeRef()->getHeight()<<"" was not ancestral\n"";
-          }
           delete(*it);
           pGeneConversionPtrSet->erase(it++);
         }else{
-          if (pConfig->bDebug){
-            Rcpp::Rcerr<<""Closing a gene conversion: ""<<
-              ""Backtracking position from ""<<curPos<<"" to ""<<
-                gc->dEndPos<<endl;
-          }
           curPos = gc->dEndPos;
           this->gcOldEdge = edge0;
           this->gcNewEdge = edge1;
@@ -1361,9 +1211,6 @@ bool GraphBuilder::checkPendingGeneConversions(double & curPos){
 void GraphBuilder::build(){
   double curPos = 0.0,lastPos = 0.0,dMaxPos = 1.0;
   unsigned int iLastCumulativePos = 0;
-#ifdef DIAG
-  Rcpp::Rcerr<<""Debugging: ""<<pConfig->bDebug<<endl;
-#endif
   
   HotSpotBinPtrList::iterator hotSpotIt;
   if (pConfig->bVariableRecomb){
@@ -1395,8 +1242,6 @@ void GraphBuilder::build(){
           lastRE=GCSTART;
           double dTractLen = (1.+log(pRandNumGenerator->unifRV())/
                               dLogTractRatio)/pConfig->dSeqLength;
-          if (pConfig->bDebug) Rcpp::Rcerr<<""Proposing tract length: ""
-                                   <<dTractLen<<endl;
           newGC = GeneConversionPtr(new GeneConversion(
             curPos+dTractLen));
           pGeneConversionPtrSet->insert(newGC);
@@ -1424,25 +1269,13 @@ void GraphBuilder::build(){
       }else{
         ++iHistoryMax;
       }
-#ifdef DIAG
-      Rcpp::Rcerr<<""iHistoryMax: ""<<iHistoryMax<<endl;
-#endif
       if (iHistoryMax>=0){
         pruneARG(iHistoryMax);
       }
     }
     
     initializeCurrentTree();
-#ifdef DIAG
-    Rcpp::Rcerr<<""Tree:""<<iGraphIteration<<
-      "",pos:""<<curPos<<
-        "",len:""<<dLastTreeLength<<
-          "",TMRCA:""<<localMRCA->getHeight()<<
-            "",ARG:""<<
-              "",len:""<<dArgLength<<
-                "",TMRCA:""<<grandMRCA->getHeight()<<
-                  endl;
-#endif
+
     if (pConfig->bVariableRecomb){
       bool bBinCrossed;
       do{
@@ -1459,10 +1292,7 @@ void GraphBuilder::build(){
       // Schiffels following two lines fixes
       uint iSegLength = curPos*pConfig->dSeqLength-iLastCumulativePos;
       iLastCumulativePos += iSegLength;
-#ifdef DIAG
-      Rcpp::Rcout<<NEWICKTREE<<""\t[""<<iSegLength<<""]""<<
-        getNewickTree(localMRCA->getHeight(),localMRCA)<<"";""<<endl;
-#endif
+
     }
     // check if there was an existing gene conversion event that needs
     // to be closed. backtrack if necessary.
@@ -1473,13 +1303,7 @@ void GraphBuilder::build(){
     lastPos = curPos;
     ++iGraphIteration;
   }while(curPos<dMaxPos);
-#ifdef DIAG
-  Rcpp::Rcerr<<""Completed the chromosome at position ""<<curPos<<endl;
-  //if (pMutationPtrVector->size()>0){
-  //        Rcpp::Rcout<<HAPLOEND<<endl;
-  //}
-  Rcpp::Rcerr<<""gcstarts:""<<gcstarts<<"" gcends:""<<gcends<<"" xovers:""<<xovers<<endl;
-#endif
+
 }
 
 vector<AlphaSimRReturn> GraphBuilder::getMutations() {

---FILE: src/datastructures.cpp---
@@ -35,9 +35,6 @@ GeneConversion::GeneConversion(double dEndPos):
 }
 
 GeneConversion::~GeneConversion(){
-#ifdef DIAG
-  //    cout<<""Gene conversion destructor\n"";
-#endif
 }
 
 HotSpotBin::HotSpotBin(double dStart,
@@ -56,9 +53,6 @@ AlleleFreqBin::AlleleFreqBin(double dStart,
 }
 
 AlleleFreqBin::~AlleleFreqBin(){
-#ifdef DIAG
-  //    cout<<""AlleleFreqBin destructor\n"";
-#endif
 }
 
 
@@ -72,9 +66,6 @@ Population::Population(){
 
 void Population::setLastTime(double time){
   this->dLastTime = time;
-#ifdef DIAG
-  if (time<0) throw ""setLastTime, negative time"";
-#endif
 }
 
 double Population::getLastTime(){
@@ -83,9 +74,6 @@ double Population::getLastTime(){
 
 void Population::setGrowthAlpha(double alpha){
   this->dGrowthAlpha = alpha;
-#ifdef DIAG
-  if (this->dGrowthAlpha<0) throw ""setGrowthAlpha, negative alpha"";
-#endif
 }
 
 double Population::getGrowthAlpha(){
@@ -94,34 +82,14 @@ double Population::getGrowthAlpha(){
 
 void Population::setChrSampled(int iChrSampled){
   this->iChrSampled = iChrSampled;
-#ifdef DIAG
-  if (this->iChrSampled<0) throw ""setChrSampled, negative chrs"";
-#endif
 }
 
 void Population::setPopSize(double dPopSize){
   this->dPopSize = dPopSize;
-#ifdef DIAG
-  if (this->dPopSize<0) throw ""setPopSize, negative pop"";
-#endif
 }
 
 Edge::Edge(NodePtr & topNode,NodePtr & bottomNode):
   PtrRefCountable(){
-#ifdef DIAG
-  
-  if (topNode->getHeight()<bottomNode->getHeight()){
-    Rcpp::Rcerr<<""Error in creating edge.  Top node must be higher or equal\n"";
-    throw ""Error in creating edge"";
-  }
-  if (topNode->getType()==Node::MIGRATION &&
-      bottomNode->getPopulation()==topNode->getPopulation()){
-    Rcpp::Rcerr<<""Error in creating edge.  Top node must be different from ""<<
-      ""migration node's population\n"";
-    throw ""Error in creating edge"";
-  }
-  Rcpp::Rcerr<<""edge of constructed.\n"";
-#endif
   this->dLength = topNode->getHeight() - bottomNode->getHeight();
   this->topNode = topNode;
   this->getBottomNodeRef() = bottomNode;
@@ -132,17 +100,9 @@ Edge::Edge(NodePtr & topNode,NodePtr & bottomNode):
 }
 
 Edge::~Edge(){
-#ifdef DIAG
-  //    Rcpp::Rcerr<<""edge of length: ""<<dLength<<"" destructed.\n"";
-#endif
-  
 }
 
 void Edge::setBottomNode(NodePtr & bottomNode){
-#ifdef DIAG
-  if (topNode->getHeight()<bottomNode->getHeight())
-    throw ""Error in modifying edge.  Top node must be higher or equal"";
-#endif
   this->dLength = topNode->getHeight() - bottomNode->getHeight();
   this->bottomNode = bottomNode;
 }
@@ -178,27 +138,6 @@ void Node::addNewEdge(EdgeLocation iLocation,
     break;
     break;
   }
-#ifdef DIAG
-  switch(iType){
-  case Node::COAL:
-    if (bottomEdgeSize>2||
-        topEdgeSize>1)
-      throw ""Coal node has too many edges\n"";
-    break;
-  case Node::XOVER:
-    if (topEdgeSize>2||
-        bottomEdgeSize>1)
-      throw ""Xover node has too many edges\n"";
-    break;
-  case Node::MIGRATION:
-    if (bottomEdgeSize>1||
-        topEdgeSize>1)
-      throw ""Migration node has too many edges\n"";
-    break;
-  default:
-    break;
-  }
-#endif
 }
 
 void Node::replaceOldWithNewEdge(EdgeLocation iLocation,
@@ -215,9 +154,6 @@ void Node::replaceOldWithNewEdge(EdgeLocation iLocation,
         ++i;
       }
     }
-#ifdef DIAG
-    if (!found) throw ""Can't find top edge in replace edge"";
-#endif
   }else if (iLocation==Node::BOTTOM_EDGE){
     while(!found && i<this->bottomEdgeSize){
       WeakEdgePtr & bottomEdge = i?bottomEdge2:bottomEdge1;
@@ -242,15 +178,9 @@ Node::Node(NodeType iType,short int iPopulation,double dHeight):
   this->topEdgeSize=0;
   this->bottomEdgeSize=0;
   this->bDeleted = false;
-#ifdef DIAG
-  Rcpp::Rcerr<<""Graph node at ""<<dHeight<<"" constructed.""<<endl;
-#endif
 }
 
 Node::~Node(){
-#ifdef DIAG
-  //    Rcpp::Rcerr<<""Graph node at ""<<dHeight<<"" destructed.""<<endl;
-#endif
 }
 
 SampleNode::SampleNode(short int iPopulation,int iId):
@@ -261,17 +191,10 @@ SampleNode::SampleNode(short int iPopulation,int iId):
 
 
 Event::~Event(){
-#ifdef DIAG
-  //    Rcpp::Rcerr<<""At time ""<<this->dTime<<"" Graph event destructor\n"";
-#endif
 }
 
 Event::Event(EventType iType,double dTime):
   PtrRefCountable(){
-#ifdef DIAG
-  if (dTime<0) throw ""Error in creating event. Time must be positive"";
-  Rcpp::Rcerr<<""At time ""<<this->dTime<<"" Graph event constructor\n"";
-#endif
   this->iType = iType;
   this->dTime = dTime;
   this->bMarkedForDelete = false;
@@ -374,9 +297,6 @@ short int PopJoinEvent::getDestPop(){
 }
 
 GraphBuilder::~GraphBuilder(){
-#ifdef DIAG
-  Rcpp::Rcerr<<""Graphbuilder destructor\n"";
-#endif
   this->pConfig = NULL;
   this->pRandNumGenerator = NULL;
   
@@ -418,9 +338,6 @@ GraphBuilder::GraphBuilder(Configuration *pConfig,RandNumGenerator * pRG){
   this->pTreeEdgesToCoalesceArray = new EdgePtr[pConfig->iSampleSize];
   for (int i=0;i<pConfig->iTotalPops;++i){
     this->pEdgeVectorByPop->push_back(EdgePtrVector());
-#ifdef DIAG
-    Rcpp::Rcerr<<""DEBUG: Size at ""<<i<<"" is ""<<this->pEdgeVectorByPop->at(i).size()<<endl;
-#endif
     this->pVectorIndicesToRecycle->push_back(EdgeIndexQueue());
   }
   this->pSampleNodeArray = new NodePtr[pConfig->iSampleSize];
@@ -489,15 +406,6 @@ void GraphBuilder::insertNodeInRunningEdge(NodePtr & newNode,EdgePtr & tempEdge)
   
   NodePtr & bottomNode = tempEdge->getBottomNodeRef();
   NodePtr & topNode = tempEdge->getTopNodeRef();
-#ifdef DIAG
-  if (newNode->getHeight()<=bottomNode->getHeight() ||
-      newNode->getHeight() >= topNode->getHeight()){
-    Rcpp::Rcerr<<""Edge has heights ""<<bottomNode->getHeight()<<
-      "" and ""<<topNode->getHeight()<<endl;
-    Rcpp::Rcerr<<""New node has height ""<<newNode->getHeight()<<endl;
-    throw ""Node to insert does not fit within coal edge "";
-  }
-#endif
   
   EdgePtr tempEdgeCopy = tempEdge;
   
@@ -517,10 +425,6 @@ void GraphBuilder::insertNodeInRunningEdge(NodePtr & newNode,EdgePtr & tempEdge)
 
 
 void GraphBuilder::mergeEdges(EdgePtr & topEdge,EdgePtr & bottomEdge){
-#ifdef DIAG
-  if (topEdge->getBottomNodeRef()->getHeight()!=bottomEdge->getTopNodeRef()->getHeight())
-    throw ""The top edge and bottom edge are mismatched for the join"";
-#endif
   // mark expired node as deleted
   bottomEdge->getTopNodeRef()->bDeleted = true;
   NodePtr & bottomNode = bottomEdge->getBottomNodeRef();
@@ -533,16 +437,6 @@ void GraphBuilder::insertNodeInEdge(NodePtr & newNode,
                                     EdgePtr & selectedEdge){
   
   NodePtr bottomNodeCopy = selectedEdge->getBottomNodeRef();
-#ifdef DIAG
-  NodePtr & topNode = selectedEdge->getTopNodeRef();
-  if (newNode->getHeight()<bottomNodeCopy->getHeight() ||
-      newNode->getHeight() > topNode->getHeight()){
-    Rcpp::Rcerr<<""Edge has heights ""<<bottomNodeCopy->getHeight()<<
-      "" and ""<<topNode->getHeight()<<endl;
-    Rcpp::Rcerr<<""New node has height ""<<newNode->getHeight()<<endl;
-    throw ""Node to insert does not fit within edge"";
-  }
-#endif
   int iGraphIteration = selectedEdge->iGraphIteration;
   selectedEdge->setBottomNode(newNode);
   newNode->addNewEdge(Node::TOP_EDGE,selectedEdge);
@@ -559,33 +453,18 @@ void GraphBuilder::insertNodeInEdge(NodePtr & newNode,
 void GraphBuilder::deleteEdge(EdgePtr & edge){
   if (!edge->bDeleted){
     edge->bDeleted = true;
-    if (pConfig->bDebug){
-      Rcpp::Rcerr<<""Deleting edge with hts ""<<edge->getBottomNodeRef()->getHeight()<<"" and ""<<
-        edge->getTopNodeRef()->getHeight()<<endl;
-    }
   }
 }
 
 // Insert into EdgeVector, pop refers to bottom node
 void GraphBuilder::addEdge(EdgePtr & edge){
   unsigned int iPopulation = edge->getBottomNodeRef()->getPopulation();
-  //if(pConfig->bDebug) Rcpp::Rcerr<<""DEBUG addEdge: iPopulation: ""<<iPopulation<<"" and pEdgeVectorByPop size ""<<pEdgeVectorByPop->size()<<endl;
   this->pEdgeListInARG->push_back(edge);
   while (iPopulation>=pEdgeVectorByPop->size()){
     this->pEdgeVectorByPop->push_back(EdgePtrVector());
     this->pVectorIndicesToRecycle->push_back(EdgeIndexQueue());
-    if(pConfig->bDebug)Rcpp::Rcerr<<""DEBUG! addEdge: Adding pop ""<<iPopulation<<"" has edge vector size: ""<<pEdgeVectorByPop->size()<<endl;
-    //        if(pConfig->bDebug)Rcpp::Rcerr<<""DEBUG! addEdge: Just added. Pop ""<<iPopulation<<"" has edge vector size: ""<<pEdgeVectorByPop->at(iPopulation).size()<<endl;
-    //Rcpp::Rcerr<<""Attempting to add edge of population ""<<iPopulation<<"" when the number of available population edge pools is only ""<<pEdgeVectorByPop->size()<<"". It is recommended that you increase the migration rates and/or number of sampled chromosomes.""<<endl;
-    //for(uint i=0;i<pEdgeVectorByPop->size();++i){
-    //Rcpp::Rcerr<<""Pop ""<<i<<"" has edge vector size: ""<<pEdgeVectorByPop->at(i).size()<<endl;
-    //}
-    // throw ""Data structure integrity error."";
-    //}
-    //}
   }
   if (iPopulation>=pEdgeVectorByPop->size()){
-    if(pConfig->bDebug) Rcpp::Rcerr<<""DEBUG! addEdge: Still not added! iPopulation: ""<<iPopulation<<"" and pEdgeVectorByPop size ""<<pEdgeVectorByPop->size()<<endl;
     throw ""Something wrong with while loop"";
   }
   
@@ -596,7 +475,6 @@ void GraphBuilder::addEdge(EdgePtr & edge){
     at(iPopulation);
   if (pVectorIndicesToRecycle.empty()){
     pEdgeVector.push_back(edge);
-    //if(pConfig->bDebug) Rcpp::Rcerr<<""DEBUG: pEdgeVector for pop ""<<iPopulation<<"" is now size: ""<<pEdgeVector.size()<<endl;
   }else{
     int iIndex = pVectorIndicesToRecycle.front();
     pVectorIndicesToRecycle.pop();
@@ -649,107 +527,9 @@ void GraphBuilder::initializeCurrentTree(){
   }
 }
 
-
-//vector<AlphaSimRReturn> GraphBuilder::getHaplotypes(){
-//    unsigned int iTotalSites = pMutationPtrVector->size();
-//
-//    unique_ptr<vector<AlphaSimRReturn> > lines(new vector<AlphaSimRReturn>());
-//
-//
-//    unique_ptr<vector<int>> haplotypes(new vector<int>());
-//
-//    AlphaSimRReturn tmp;
-//
-//    bool bZeroCellCount=false;
-//    if (iTotalSites){
-//        int iReducedSites=iTotalSites;
-//        if (pConfig->bSNPAscertainment){
-//            // first see if any expected count exceed actual counts
-//            bool bSufficientObs=false;
-//            do{
-//                bSufficientObs=true;
-//                auto it=pConfig->pAlleleFreqBinPtrSet->begin();
-//                while(bSufficientObs && !bZeroCellCount && it!=pConfig->pAlleleFreqBinPtrSet->end()){
-//                    AlleleFreqBinPtr bin = *it;
-//                    auto iExpectedCount = static_cast<int>(bin->dFreq * iReducedSites);
-//                    if (!iExpectedCount && bin->dFreq>0.){
-//                        bZeroCellCount = true;
-//                    }
-//                    else if (bin->iObservedCounts<iExpectedCount){
-//                        bSufficientObs = false;
-//                        --iReducedSites;
-//                    }else{
-//                        ++it;
-//                    }
-//                }
-//            }while(!bSufficientObs && !bZeroCellCount);
-//            if (bZeroCellCount){
-//                iReducedSites = 0;
-//            }else{
-//                int tally=0;
-//                for (auto it=pConfig->pAlleleFreqBinPtrSet->begin();
-//                     it!=pConfig->pAlleleFreqBinPtrSet->end();++it){
-//                    AlleleFreqBinPtr bin = *it;
-//                    double dStart = bin->dStart;
-//                    double dEnd = bin->dEnd;
-//                    auto iExpectedCount = static_cast<int>(bin->dFreq * iReducedSites);
-//
-//                    tally+=iExpectedCount;
-//
-//                    while(iExpectedCount>0){
-//                        int iRandIndex = static_cast<int>(pRandNumGenerator->unifRV()*iTotalSites);
-//                        MutationPtr mutation = pMutationPtrVector->at(iRandIndex);
-//                        if (!mutation->bPrintOutput && mutation->dFreq>=dStart && mutation->dFreq<=dEnd){
-//                            mutation->bPrintOutput = true;
-//                            --iExpectedCount;
-//                        }
-//                    }
-//                }
-//                iReducedSites = tally;
-//            }
-//        }
-//
-//
-//        if (iReducedSites){
-//            MutationPtrVector::iterator it;
-//            // copy to a temporary vector if ascertained
-//            cout<<TOTALSAMPLES<<FIELD_DELIMITER<<pConfig->iSampleSize<<endl;
-//            cout<<TOTALSITES<<FIELD_DELIMITER<<iReducedSites<<endl;
-//            cout<<SNPBEGIN<<endl;
-//            if (pConfig->bSNPAscertainment && !bZeroCellCount){
-//                int origIndex=0;
-//                bool indexPrinted=false;
-//                for (it = pMutationPtrVector->begin();
-//                     it!=pMutationPtrVector->end();++it){
-//                    MutationPtr mutation = *it;
-//                    if (mutation->bPrintOutput){
-//                        if (indexPrinted) cout<<FIELD_DELIMITER;
-//                        haplotypes->push_back(origIndex);
-//                        indexPrinted=true;
-//                    }
-//                    ++origIndex;
-//                }
-//            }else{
-//                for(int i=0;i<iReducedSites;++i){
-//                    tmp.haplotypes.emplace_back(i);
-//                }
-//            }
-//
-//
-//
-//
-//            lines->emplace_back(tmp);
-//            cout<<endl<<SNPEND<<endl;
-//        }
-//    }
-//    return *haplotypes;
-//}
-
-
 void GraphBuilder::printHaplotypes(){
   unsigned int iTotalSites = pMutationPtrVector->size();
   bool bZeroCellCount=false;
-  if (pConfig->bDebug) Rcpp::Rcerr<<""Total sites: ""<<iTotalSites<<endl;
   if (iTotalSites){
     int iReducedSites=iTotalSites;
     if (pConfig->bSNPAscertainment){
@@ -763,10 +543,6 @@ void GraphBuilder::printHaplotypes(){
           int iExpectedCount = static_cast<int>(bin->dFreq * iReducedSites);
           if (!iExpectedCount && bin->dFreq>0.){
             bZeroCellCount = true;
-            if (pConfig->bDebug){
-              Rcpp::Rcerr<<""Setting zero cell count true because expecting a proportion of ""<<
-                bin->dFreq<<"" but found ""<<iExpectedCount<<endl;
-            }
           }
           else if (bin->iObservedCounts<iExpectedCount){
             bSufficientObs = false;
@@ -791,16 +567,6 @@ void GraphBuilder::printHaplotypes(){
           int iExpectedCount = static_cast<int>(bin->dFreq * iReducedSites);
           
           tally+=iExpectedCount;
-          if (pConfig->bDebug) {
-            Rcpp::Rcerr<<""Looking for SNPs in range ""<<dStart<<"" to ""<<dEnd<<endl;
-            Rcpp::Rcerr<<""iObserved count: ""<<bin->iObservedCounts<<endl;
-            Rcpp::Rcerr<<""Expecting ""<<iExpectedCount<<"" SNPS.""<<endl;
-          }
-#ifdef DIAG
-          if (bin->iObservedCounts<iExpectedCount){
-            throw ""Too many expected counts"";
-          }
-#endif
           while(iExpectedCount>0){
             int iRandIndex = static_cast<int>(pRandNumGenerator->unifRV()*iTotalSites);
             MutationPtr mutation = pMutationPtrVector->at(iRandIndex);
@@ -817,34 +583,6 @@ void GraphBuilder::printHaplotypes(){
     if (iReducedSites){
       MutationPtrVector::iterator it;
       // copy to a temporary vector if ascertained
-#ifdef DIAG
-      cout<<TOTALSAMPLES<<FIELD_DELIMITER<<pConfig->iSampleSize<<endl;
-      cout<<TOTALSITES<<FIELD_DELIMITER<<iReducedSites<<endl;
-      cout<<SNPBEGIN<<endl;
-      
-      if (pConfig->bSNPAscertainment && !bZeroCellCount){
-        int origIndex=0;
-        bool indexPrinted=false;
-        for (it = pMutationPtrVector->begin();
-             it!=pMutationPtrVector->end();++it){
-          MutationPtr mutation = *it;
-#ifdef DIAG
-          if (mutation->bPrintOutput){
-            if (indexPrinted) cout<<FIELD_DELIMITER;
-            cout<<origIndex;
-            indexPrinted=true;
-          }
-#endif
-          ++origIndex;
-        }
-      }else{
-        for(int i=0;i<iReducedSites;++i){
-          if (i) cout<<FIELD_DELIMITER;
-          cout<<i;
-        }
-      }
-      cout<<endl<<SNPEND<<endl;
-#endif
     }
   }
 }
@@ -865,14 +603,12 @@ void GraphBuilder::printDataStructures(){
             "",type:""<<curEdge->getTopNodeRef()->getTypeStr()<<
               "",pop:""<<curEdge->getTopNodeRef()->getPopulation()<<
                 "",del:""<<curEdge->bDeleted<<
-                  //        "",length:""<<curEdge->getLength()<<
                   "";hist:""<<curEdge->iGraphIteration<<endl;
     trueLen+=curEdge->getLength();
   }
   
   
   Rcpp::Rcerr<<""Last tree (list of edges)\n"";
-  //    it;
   trueLen = 0.0;
   EdgePtrVector::iterator it=pEdgeVectorInTree->begin();
   unsigned int count=0;
@@ -885,9 +621,6 @@ void GraphBuilder::printDataStructures(){
           "";high_ht:""<<curEdge->getTopNodeRef()->getHeight()<<
             "",type:""<<curEdge->getTopNodeRef()->getTypeStr()<<
               "",pop:""<<curEdge->getTopNodeRef()->getPopulation()<<endl;
-    //        "",intree:""<<curEdge->bInCurrentTree<<endl;
-    //        "",length:""<<curEdge->getLength()<<
-    //        "";hist:""<<curEdge->iGraphIteration<<endl;
     trueLen+=curEdge->getLength();
     ++count;
     ++it;

---FILE: src/simulator.cpp---
@@ -26,70 +26,10 @@ RandNumGenerator::RandNumGenerator(unsigned long iRandomSeed){
 }
 
 RandNumGenerator::~RandNumGenerator(){
-#ifdef DIAG
-  Rcpp::Rcerr<<""Rand generator destructor\n"";
-#endif
   delete unif;
 }
 
-void Simulator::printUsage() {
-  Rcpp::Rcout<<""Usage: <samplesize> <region in base pairs> [options]""<<endl;
-  Rcpp::Rcout<<""Options: ""<<endl;
-  Rcpp::Rcout<<""-s <random seed>""<<endl;
-  Rcpp::Rcout<<""-d enable debugging messages""<<endl;
-  Rcpp::Rcout<<""-i <iterations>""<<endl;
-  Rcpp::Rcout<<""-h <history> number of previous base pairs to retain""<<endl;
-  Rcpp::Rcout<<""-t <mu> (mutation rate per site per 4N generations)""<<endl;
-  Rcpp::Rcout<<""-F <inputfilename> [0|1] (Tab delimited frequency distribution ""<<
-    ""file where first column indicate range of SNP allele frequencies ""<<
-      ""from previous row to current row and last column is desired bin ""<<
-        ""frequency. Second parameter is 1 if SNPs with derived allele freq > ""<<
-          ""1.0 should have alleles flipped, 0 otherwise.)""<<endl;
-  Rcpp::Rcout<<""-r <r> (recombination rate per site per 4N generations)""<<endl;
-  Rcpp::Rcout<<""-c <f> <lambda> (f = ratio of gene conversion rate to crossover ""<<
-    ""rate. tracklen lambda is mean length of tract in base pairs.)""<<endl;
-  Rcpp::Rcout<<""-R <inputfilename> (Tab delimited file where first ""<<
-    ""two columns indicate range of base pair positions scaled to the ""<<
-      ""unit interval and last column is ratio with respect to base line ""<<
-        ""recombination rate.)""<<endl;
-  Rcpp::Rcout<<""-T (Print each local tree in Newick format to standard out)""<<endl;
-  Rcpp::Rcout<<""-G <alpha> (Assign growth rate alpha across populations ""<<
-    ""where alpha=-log(Np/Nr)""<<endl;
-  Rcpp::Rcout<<""-I <n> <n1> <n2> .. <mig_rate> (Assign all elements of the ""<<
-    ""migration matrix for n populations.  Values in matrix set to ""<<
-      ""mig_rate/(n-1).)""<<endl;
-  Rcpp::Rcout<<""-m <i> <j> <m>  (Assign i,j-th element of migration matrix ""<<
-    ""to m.)""<<
-      endl;
-  Rcpp::Rcout<<""-ma <m_11>..<m_12>..<m_nn> (Assign values to all ""<<
-    ""elements of migration matrix for n populations.)""<<endl;
-  Rcpp::Rcout<<""-n <i> <size>   (Pop i has size set to size*N_0 ""<<endl;
-  Rcpp::Rcout<<""-g <i> <alpha>  (If used must appear after -M option.)""<<endl;
-  Rcpp::Rcout<<""The following options modify parameters at time t.""<<endl;
-  Rcpp::Rcout<<""-eG <t> <alpha>  (Assign growth rate for all pops at time""<<
-    "" t.""<<endl;
-  Rcpp::Rcout<<""-eg <t> <i> <alpha>  (Assign growth rate alpha of pop ""<<
-    ""i at time t.)""<<endl;
-  Rcpp::Rcout<<""-eM <t> <m> (Assign migrate rate m for all elements ""<<
-    ""of migration matrix at time t.)""<<endl;
-  Rcpp::Rcout<<""-em <t> <i> <j> <m_ij> (Assign migration rate for i,j-th ""<<
-    ""element of migration matrix at time t.)""
-    <<""at time t )""<<endl;
-    Rcpp::Rcout<<""-ema <t> <n> <m_11>..<m_12>..<m_nn> (Assign migration rates ""
-    "" within the migration matrix for n populations at time t.)""<<endl;
-    Rcpp::Rcout<<""-eN <t> <size> (New pop sizes at time t for all pops ""<<
-      ""where new sizes = size*N_0)""<<endl;
-    Rcpp::Rcout<<""-en <t> <i> <size_i> (New pop size of pop i will be set ""<<
-      ""to (size_i*N_0) at time t.""<<endl;
-    Rcpp::Rcout<<""-es <t> <i> <p> (Split two populations.  At time t, ""<<
-      ""a proportion p of chromosomes from pop i will migrate to a ""<<
-        ""population i+1.""<<endl;
-    Rcpp::Rcout<<""-ej <t> <i> <j> (Join two populations.  At time t ""<<
-      ""all chromosomes migrate from pop i to pop j.""<<endl;
-}
-
 Configuration::Configuration(){
-  bDebug = false;
   bVariableRecomb = false;
   bSNPAscertainment = false;
   bFlipAlleles = false;
@@ -109,11 +49,8 @@ Configuration::Configuration(){
 }
 
 Configuration::~Configuration(){
-#ifdef DIAG
-  Rcpp::Rcerr<<""Configuration destructor\n"";
-#endif
   if (pEventList) {
-  delete pEventList;
+    delete pEventList;
   }
   if (bSNPAscertainment){
     AlleleFreqBinPtrSet::iterator it;
@@ -143,8 +80,8 @@ void Simulator::readInputParameters(CommandArguments arguments){
   unsigned int iTotalArgs = arguments.size();
   
   pConfig=new Configuration();
-
-
+  
+  
   dDefaultPopSize = 1.0;
   dDefaultGrowthAlpha =0.0;
   
@@ -160,14 +97,7 @@ void Simulator::readInputParameters(CommandArguments arguments){
       newRow.push_back(dDefaultMigrationRate);
     pConfig->dMigrationMatrix.push_back(newRow);
   }
-
-  if (iTotalArgs == 0) {
-    Rcpp::stop(""You must enter a value for the sample size and seq length."");
-  } 
   
-  if( arguments[0].size()!=2 ){
-    Rcpp::stop(""You must enter a value for the sample size and seq length."");
-  }
   iSampleSize = atoi(arguments[0][0].data());
   Population newPop;
   newPop.setChrSampled(iSampleSize);
@@ -176,29 +106,12 @@ void Simulator::readInputParameters(CommandArguments arguments){
   
   pConfig->pPopList.push_back(newPop);
   pConfig->iSampleSize = iSampleSize;
-#ifdef DIAG
-  Rcpp::Rcerr<<""INPUT: Sample size is now ""<<pConfig->iSampleSize<<endl;
-#endif
-  if( iSampleSize<= 0) {
-    printUsage();
-    Rcpp::stop(""First argument error. Sample size needs to be greater than 0.\n"");
-    
-
-  }
   
   pConfig->dSeqLength = atof(arguments[0][1].data());
-#ifdef DIAG
-  Rcpp::Rcerr<<""INPUT: Seq length is now ""<<pConfig->dSeqLength<<endl;
-#endif
+  
   set<float> eventTimes;
   for (unsigned int iCurrentArg = 1;iCurrentArg<iTotalArgs;++iCurrentArg){
     try{
-      if(arguments[iCurrentArg][0][0] != '-' ) {
-        Rcpp::Rcerr<<""At argument ""<<iCurrentArg<<
-          "", argument needs to be prefixed with a -""<<endl;
-        Rcpp::Rcerr<<""You entered ""<<arguments[iCurrentArg][0][0]<<endl;
-        printUsage();
-      }
       double dTime;
       char chType;
       EventPtr wrapper;
@@ -217,9 +130,6 @@ void Simulator::readInputParameters(CommandArguments arguments){
         // example:
         // (2:1.766,(4:0.505,(3:0.222,(1:0.163,5:0.163):0.059):0.283):1.261);
         break;
-      case 'd' :
-        pConfig->bDebug = true;
-        break;
       case 'h' :
         if (arguments[iCurrentArg].size()!=2) {
           Rcpp::Rcerr<<""For flag ""<<arguments[iCurrentArg][0][1]<<
@@ -228,9 +138,6 @@ void Simulator::readInputParameters(CommandArguments arguments){
           return;
         }
         pConfig->dBasesToTrack = atof(arguments[iCurrentArg][1].data());
-#ifdef DIAG
-        Rcpp::Rcerr<<""INPUT: Base pairs to track is ""<<pConfig->dBasesToTrack<<endl;
-#endif
         break;
       case 's' :
         if (arguments[iCurrentArg].size()<2) {
@@ -239,9 +146,6 @@ void Simulator::readInputParameters(CommandArguments arguments){
           Rcpp::stop(""Argument error"");
         }
         pConfig->iRandomSeed = atoi(arguments[iCurrentArg][1].data());
-#ifdef DIAG
-        Rcpp::Rcerr<<""INPUT: Random seed used is ""<<pConfig->iRandomSeed<<endl;
-#endif
         break;
       case 't' :  // set mutation parameter
         if (arguments[iCurrentArg].size()!=2) {
@@ -250,9 +154,6 @@ void Simulator::readInputParameters(CommandArguments arguments){
           Rcpp::stop(""Argument error"");
         }
         pConfig->dTheta = pConfig->dSeqLength * atof(arguments[iCurrentArg][1].data());
-#ifdef DIAG
-        Rcpp::Rcerr<<""INPUT: Scaled mutation rate is now ""<<pConfig->dTheta<<endl;
-#endif
         break;
       case 'F':
         if (arguments[iCurrentArg].size()!=3){
@@ -279,17 +180,11 @@ void Simulator::readInputParameters(CommandArguments arguments){
             cumFreq+=freq;
             if (end>maxFreq) end = maxFreq;
             if (start>=end) throw ""The freq range entered is incorrect."";
-            if (pConfig->bDebug){
-              Rcpp::Rcerr<<""Frequency bin from ""<<start<<"" to ""<<end<<"" with freq ""<<freq<<endl;
-            }
             AlleleFreqBinPtr bin = AlleleFreqBinPtr(new AlleleFreqBin(start,end,freq));
             pConfig->pAlleleFreqBinPtrSet->insert(bin);
             lastStart = end;
             ++total;
           }
-#ifdef DIAG
-          Rcpp::Rcerr<<""INPUT: Accepted ""<<total<<"" freqency bins""<<endl;
-#endif
           inFile.close();
           pConfig->bSNPAscertainment = true;
           if (cumFreq>1.0) throw ""The total frequency entered exceeds one"";
@@ -298,9 +193,6 @@ void Simulator::readInputParameters(CommandArguments arguments){
             }else{
               AlleleFreqBinPtr bin = AlleleFreqBinPtr(new AlleleFreqBin(lastStart,maxFreq,1-cumFreq));
               pConfig->pAlleleFreqBinPtrSet->insert(bin);
-              if (pConfig->bDebug){
-                Rcpp::Rcerr<<""Added frequency bin from ""<<lastStart<<"" to ""<<maxFreq<<"" with freq ""<<1-cumFreq<<endl;
-              }
             }
           }
         }
@@ -312,9 +204,6 @@ void Simulator::readInputParameters(CommandArguments arguments){
           Rcpp::stop(""Argument error"");
         }
         pConfig->dRecombRateRAcrossSites = pConfig->dSeqLength * atof(arguments[iCurrentArg][1].data());
-#ifdef DIAG
-        Rcpp::Rcerr<<""INPUT: Scaled recombination rate is now ""<<pConfig->dRecombRateRAcrossSites<<endl;
-#endif
         break;
       case 'c' :
         if (arguments[iCurrentArg].size()!=3) {
@@ -328,10 +217,6 @@ void Simulator::readInputParameters(CommandArguments arguments){
           Rcpp::Rcerr<<""The gene conversion parameters must be positive\n"";
           Rcpp::stop(""Argument error"");
         }
-#ifdef DIAG
-        Rcpp::Rcerr<<""INPUT: Gene conversion ratio is now ""<<pConfig->dGeneConvRatio<<endl;
-        Rcpp::Rcerr<<""INPUT: Gene conversion tract length is now ""<<pConfig->iGeneConvTract<<endl;
-#endif
         break;
       case 'R':
         if (arguments[iCurrentArg].size()!=2){
@@ -350,16 +235,10 @@ void Simulator::readInputParameters(CommandArguments arguments){
             istringstream inStr(line);
             double start,end,ratio;
             inStr>>start>>end>>ratio;
-            if (pConfig->bDebug){
-              Rcpp::Rcerr<<""Hot spot from ""<<start<<"" to ""<<end<<"" with rate ""<<ratio<<endl;
-            }
             HotSpotBinPtr bin(new HotSpotBin(start,end,ratio));
             pConfig->pHotSpotBinPtrList->push_back(bin);
             ++total;
           }
-#ifdef DIAG
-          Rcpp::Rcerr<<""INPUT: Accepted ""<<total<<"" hotspots""<<endl;
-#endif
           inFile.close();
           pConfig->bVariableRecomb = true;
         }
@@ -371,9 +250,6 @@ void Simulator::readInputParameters(CommandArguments arguments){
           Rcpp::stop(""Argument error"");
         }
         pConfig->iIterations = atoi(arguments[iCurrentArg][1].data());
-#ifdef DIAG
-        Rcpp::Rcerr<<""INPUT: Iterations is now ""<<pConfig->iIterations<<endl;
-#endif
         break;
       case 'I' :
         if (arguments[iCurrentArg].size()<2) {
@@ -404,9 +280,6 @@ void Simulator::readInputParameters(CommandArguments arguments){
           }else{
             pConfig->dGlobalMigration = dDefaultMigrationRate;
           }
-#ifdef DIAG
-          Rcpp::Rcerr<<""INPUT: Global migration rate to ""<<pConfig->dGlobalMigration<<endl;
-#endif
         }else{
           Rcpp::Rcerr<<""For flag ""<<arguments[iCurrentArg][0][1]<<
             "", the number of island sample sizes entered does not match the first parameter\n"";
@@ -417,9 +290,6 @@ void Simulator::readInputParameters(CommandArguments arguments){
         }
         
         // Allocate migration rate matrix
-        if (pConfig->bDebug){
-          Rcpp::Rcerr<<""Constructing migration matrix of dimension ""<<pConfig->iTotalPops<<endl;
-        }
         pConfig->dMigrationMatrix.clear();
         for (int i=0;i<pConfig->iTotalPops;++i){
           vector<double> newRow;
@@ -475,10 +345,6 @@ void Simulator::readInputParameters(CommandArguments arguments){
         break;
       case 'n' :
         //                    // specify population size for each population
-        if( pConfig->iTotalPops < 2 ) {
-          Rcpp::Rcerr<<""You must use -I option first (i.e. specify more than one population).""<<endl;
-          printUsage();
-        }
         if (arguments[iCurrentArg].size()!=3){
           Rcpp::Rcerr<<""For flag ""<<arguments[iCurrentArg][0]<<
             "", you need to specify the pop ID and the population size.\n"";
@@ -491,17 +357,10 @@ void Simulator::readInputParameters(CommandArguments arguments){
             Rcpp::stop(""Argument error"");
           }
           pConfig->pPopList[popId].setPopSize(popSize) ;
-#ifdef DIAG
-          Rcpp::Rcerr<<""INPUT: Pop ""<<arguments[iCurrentArg][1]<<"" has size: ""<<popSize<<endl;
-#endif
         }
         break;
       case 'g' :
         //                    // specify growth rates
-        if( pConfig->iTotalPops < 2 ) {
-          Rcpp::Rcerr<<""You must use -I option first (i.e. specify more than one population).""<<endl;
-          printUsage();
-        }
         if (arguments[iCurrentArg].size()!=3){
           Rcpp::Rcerr<<""For flag ""<<arguments[iCurrentArg][0]<<
             "", you need to specify the pop ID and the population growth rate.\n"";
@@ -514,9 +373,6 @@ void Simulator::readInputParameters(CommandArguments arguments){
             Rcpp::stop(""Argument error"");
           }
           pConfig->pPopList[popId].setGrowthAlpha(dDefaultGrowthAlpha);
-#ifdef DIAG
-          Rcpp::Rcerr<<""INPUT: Pop ""<<arguments[iCurrentArg][1].data()<<"" has growth rate: ""<<dDefaultGrowthAlpha<<endl;
-#endif
         }
         break;
       case 'G' :
@@ -532,10 +388,6 @@ void Simulator::readInputParameters(CommandArguments arguments){
           //                    Rcpp::Rcerr<<""INPUT: Growth rate for all pop ""<<dDefaultGrowthAlpha<<endl;
           for(int i=0; i<pConfig->iTotalPops; ++i){
             pConfig->pPopList[i].setGrowthAlpha(dDefaultGrowthAlpha);
-#ifdef DIAG
-            Rcpp::Rcerr<<""INPUT: Growth rate for pop ""<<i<<"" is ""<<
-              pConfig->pPopList[i].getGrowthAlpha()<<endl;
-#endif
           }
         }
         break;
@@ -550,9 +402,6 @@ void Simulator::readInputParameters(CommandArguments arguments){
           Rcpp::stop(""Argument error"");
         }
         dTime = atof(arguments[iCurrentArg][1].data());
-#ifdef DIAG
-        Rcpp::Rcerr<<""INPUT: At time ""<<dTime<<"": "";
-#endif
         if (eventTimes.find(dTime)==eventTimes.end()){
           eventTimes.insert(dTime);
         }else{
@@ -645,11 +494,6 @@ void Simulator::readInputParameters(CommandArguments arguments){
             //iType = Event::POPSPLIT;
             iPop1 = atoi( arguments[iCurrentArg][2].data() )-1;
             dProportion = atof( arguments[iCurrentArg][3].data() );
-            if (iPop1<0||iPop1>=pConfig->iTotalPops||dProportion<0||
-                dProportion>=1){
-              Rcpp::Rcerr<<""Bad values in parameters for pop IDs and/or proportion in pop split\n"";
-              printUsage();
-            }
             wrapper = EventPtr(new PopSizeChangeEvent(
               Event::POPSPLIT,dTime,iPop1,dProportion));
             //Rcpp::Rcerr<<""Population ""<<arguments[iCurrentArg][2]<<
@@ -666,10 +510,6 @@ void Simulator::readInputParameters(CommandArguments arguments){
             //iType = Event::POPJOIN;
             iPop1 = atoi( arguments[iCurrentArg][2].data() ) -1;
             iPop2 = atoi( arguments[iCurrentArg][3].data() ) -1;
-            if (iPop1<0||iPop2<0){
-              Rcpp::Rcerr<<""Bad values in parameters for pop IDs pop join\n"";
-              printUsage();
-            }
             if (iPop1>=pConfig->iTotalPops||
                 iPop2>=pConfig->iTotalPops){
               Rcpp::Rcerr<<""WARNING: The pop IDs used in pop join is greater than the number specified in -I.  You must have a split event before this join event.\n"";
@@ -751,11 +591,9 @@ void Simulator::readInputParameters(CommandArguments arguments){
         break;
       default:
         Rcpp::Rcerr<<""Invalid option, you entered ""<<arguments[iCurrentArg][0][1]<<endl;
-      printUsage();
       }
     }catch(const out_of_range & e){
       Rcpp::Rcerr<<""There were too many arguments.\n"";
-      printUsage();
     }
   }
   
@@ -769,7 +607,6 @@ void Simulator::readInputParameters(CommandArguments arguments){
     //    <<pConfig->dBasesToTrack<<endl;
   }
   
-  
   pEventList->sort(byEventTime());
   pConfig->pEventList = pEventList;
 }
@@ -779,12 +616,8 @@ vector<AlphaSimRReturn> Simulator::beginSimulationMemory() {
   
   vector<AlphaSimRReturn> toRet;
   
-  
   try {
     RandNumGenerator *rg = new RandNumGenerator(pConfig->iRandomSeed);
-#ifdef DIAG
-    Rcpp::Rcout << SEED << ""\t"" << pConfig->iRandomSeed << endl;
-#endif
     for (unsigned int i = 0; i < pConfig->iIterations; ++i) {
       GraphBuilder graphBuilder = GraphBuilder(pConfig, rg);
       graphBuilder.build();
@@ -803,13 +636,7 @@ vector<AlphaSimRReturn> Simulator::beginSimulationMemory() {
 void Simulator::beginSimulation() {
   try {
     RandNumGenerator *rg = new RandNumGenerator(pConfig->iRandomSeed);
-#ifdef DIAG
-    Rcpp::Rcout << SEED << ""\t"" << pConfig->iRandomSeed << endl;
-#endif
     for (unsigned int i = 0; i < pConfig->iIterations; ++i) {
-      if (pConfig->bDebug) {
-        Rcpp::Rcerr << ""Iteration: "" << i << endl;
-      }
       GraphBuilder graphBuilder = GraphBuilder(pConfig, rg);
       graphBuilder.build();
       graphBuilder.printHaplotypes();
@@ -821,75 +648,11 @@ void Simulator::beginSimulation() {
   }
 }
 
-
-
-
-void Simulator::runFromAlphaSimRParams(int sampleSize, float sequenceLength, double mutation, double recombination,
-                                       vector<tuple<float, float> > *popSizeList,
-                                       vector<float> *migrationRate,
-                                       vector<int> lineage) {
-  
-  // double defaultMigrationRate;
-  
-  pConfig = new Configuration();
-  pConfig->iTotalPops = 1;
-    
-  double dDefaultMigrationRate = 0.0;
-  //double dDefaultPopSize = 1.0;
-  
-  for (unsigned int i = 0; i < pConfig->iTotalPops; ++i) {
-    vector<double> newRow;
-    for (unsigned int j = 0; j < pConfig->iTotalPops; ++j)
-      newRow.push_back(dDefaultMigrationRate);
-    pConfig->dMigrationMatrix.push_back(newRow);
-  }
-  
-  pConfig->dSeqLength = sequenceLength;
-  
-  pConfig->dTheta = pConfig->dSeqLength * mutation;
-  pConfig->dRecombRateRAcrossSites = pConfig->dSeqLength * recombination;
-  
-  for (tuple<float, float> pop : *popSizeList) {
-    EventPtr wrapper;
-    wrapper = EventPtr(new GenericEvent(
-      Event::GLOBAL_POPSIZE, get<0>(pop), get<1>(pop)));
-  }
-  
-  
-  int lineageSize = static_cast<int>(lineage.size());
-  
-  if (lineageSize > 0) {
-    if (lineageSize != 3) {
-      Rcpp::Rcerr << ""ERROR, lineage not given enough arguements"";
-    }
-    // merge populations
-    int iPop1 = lineage[1] - 1;
-    int iPop2 = lineage[2] - 1;
-    if (iPop1 < 0 || iPop2 < 0) {
-      Rcpp::Rcerr << ""Bad values in parameters for pop IDs pop join\n"";
-    }
-    if (iPop1 >= pConfig->iTotalPops ||
-        iPop2 >= pConfig->iTotalPops) {
-      Rcpp::Rcerr
-      << ""WARNING: The pop IDs used in pop join is greater than the number specified in -I.  You must have a split event before this join event.\n"";
-    }
-    EventPtr wrapper = EventPtr(new PopJoinEvent(
-      Event::POPJOIN, lineage[0], static_cast<short>(iPop1), static_cast<short>(iPop2)));
-    
-  }
-  beginSimulation();
-  
-  
-}
-
 Simulator::Simulator() {
 }
 
 
 Simulator::~Simulator() {
-#ifdef DIAG
-  Rcpp::Rcerr << ""Simulator destructor:"" << endl;
-#endif
   delete pConfig;
 }
 

---FILE: src/simulator.h---
@@ -10,7 +10,6 @@
 #include <boost/random/mersenne_twister.hpp>
 #include <boost/random/uniform_01.hpp>
 #include ""constants.h""
-//#define DIAG
 
 using namespace std;
 
@@ -453,24 +452,13 @@ class AlleleFreqBin{
   
 };
 
-//typedef boost::shared_ptr<AlleleFreqBin> AlleleFreqBinPtr;
-
-
-
 class AlphaSimRReturn {
 public:
-  
   AlphaSimRReturn();
-  
-  
-  
   vector<bool > haplotypes;
   double length;
 };
 
-
-
-
 class Mutation{
 public:
   Mutation(double dLocation,double dFreq);
@@ -480,11 +468,6 @@ class Mutation{
   bool bPrintOutput;
 };
 
-//typedef boost::shared_ptr<Mutation> MutationPtr;
-
-
-
-
 // Configuration container populated by parameter reading procedure
 // can be used by any simulator implementation
 class Configuration
@@ -495,7 +478,7 @@ class Configuration
   unsigned int iSampleSize,iIterations,iGeneConvTract;
   unsigned short int iTotalPops;
   long iRandomSeed;
-  bool bDebug,bSNPAscertainment,bFlipAlleles;
+  bool bSNPAscertainment,bFlipAlleles;
   //    bool bHighMutationRate;
   bool bVariableRecomb,bNewickFormat;
   bool bMigrationChangeEventDefined;
@@ -746,16 +729,9 @@ class Simulator
   // from the command line
   // We can always do more error checking here!
   void readInputParameters(CommandArguments args);
-  // Prints the command line parameter usage as described
-  // in the MS manual
-  void printUsage();
   // Calls any coalescent simulator (e.g. fastcoal, MS). In this
   // case, constructs a new graphbuilder and calls the build() function
   void beginSimulation();
-  void runFromAlphaSimRParams(int sampleSize, float sequenceLength, double mutation, double recombination, vector<tuple<float, float> > *popSizeList,
-                              vector<float> *migrationRate = new vector<float>(),
-                              vector<int> lineage = vector<int>());
-  
   vector<AlphaSimRReturn> beginSimulationMemory();
   Simulator();
   ~Simulator(); //destructor
@@ -812,9 +788,6 @@ inline int Population::getChrSampled(){
 inline void Population::changeChrSampled(int change){
   //setChrSampled(this->iChrSampled + change);
   this->iChrSampled+=change;
-#ifdef DIAG
-  if (this->iChrSampled<0) throw ""setChrSampled, negative chrs"";
-#endif
 }
 
 inline double Population::getPopSize(){
@@ -861,20 +834,12 @@ inline short unsigned int Node::getBottomEdgeSize(){
 
 // a vector of the edge(s) above the node
 inline EdgePtr Node::getTopEdgeByIndex(short unsigned int index){
-#ifdef DIAG
-  if (index>=this->topEdgeSize)
-    throw ""Index for top edge out of range"";
-#endif
   return index != 0u ?topEdge2.lock():topEdge1.lock();
   //        return index?topEdge2:topEdge1;
   //    return edge;
 }
 
 inline EdgePtr Node::getBottomEdgeByIndex(short unsigned int index){
-#ifdef DIAG
-  if (index>=this->bottomEdgeSize)
-    throw ""Index for bottom edge out of range"";
-#endif
   return index?bottomEdge2.lock():bottomEdge1.lock();
   //        return index?bottomEdge2:bottomEdge1;
   //    return edge;
@@ -924,6 +889,5 @@ inline double RandNumGenerator::unifRV() {
 }
 
 inline double GraphBuilder::getRate(){
-  //return dArgLength*dScaledRecombRate;
   return dLastTreeLength*dScaledRecombRate;
 }"
gaynorr,AlphaSimR,93d691e8fdf5ffdb46cc8a6d2c77b7fb1a47b57d,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2020-03-30T08:38:34Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2020-03-30T08:38:34Z,-fix bug in selection of segSites,DESCRIPTION;NEWS;R/Class-SimParam.R,False,True,True,False,11,8,19,"---FILE: DESCRIPTION---
@@ -1,8 +1,8 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 0.12.0
-Date: 2020-01-20
+Version: 0.12.1
+Date: 2020-03-30
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: NEWS---
@@ -1,3 +1,8 @@
+Changes in version 0.12.1
+
+  Bug fixes
+    -fix bug in selection of segSites
+
 Changes in version 0.12.0
   
   New features

---FILE: R/Class-SimParam.R---
@@ -1561,12 +1561,10 @@ SimParam = R6Class(
           tmp = sort(sample(pot[[x]],nSitesPerChr[x]))
           # Add site restrictions
           if(private$.restrSites){
-            for(chr in 1:self$nChr){
-              if(QTL){
-                self$invalidSnp[[chr]] = sort(union(tmp, self$invalidSnp[[x]]))
-              }else{
-                self$invalidQtl[[chr]] = sort(union(tmp, self$invalidQtl[[x]]))
-              }
+            if(QTL){
+              self$invalidSnp[[x]] = sort(union(tmp, self$invalidSnp[[x]]))
+            }else{
+              self$invalidQtl[[x]] = sort(union(tmp, self$invalidQtl[[x]]))
             }
           }
           return(tmp)"
gaynorr,AlphaSimR,2d3722ba04011c7f5f44bb4e6e985d23ad4b2a6b,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2020-03-11T16:45:19Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2020-03-11T16:45:19Z,"-changed output of genParam to match Bulmer, 1976
-nProgeny added to makeCross and makeCross2
-all SimParam documentation is now in ?SimParam
-non-overlapping QTL and SNP is now the default
-new interface for restrSegSites in SimParam
-fixed major bug in newMapPop",NAMESPACE;NEWS;R/Class-SimParam.R;R/GS.R;R/crossing.R;R/founderPop.R;R/polyploids.R;R/popSummary.R;R/pullGeno.R;man/RRBLUP.Rd;man/RRBLUP2.Rd;man/RRBLUP_D.Rd;man/RRBLUP_D2.Rd;man/RRBLUP_GCA.Rd;man/RRBLUP_GCA2.Rd;man/RRBLUP_SCA.Rd;man/RRBLUP_SCA2.Rd;man/SimParam.Rd;man/SimParam_addSnpChip.Rd;man/SimParam_addStructuredSnpChips.Rd;man/SimParam_addTraitA.Rd;man/SimParam_addTraitAD.Rd;man/SimParam_addTraitADE.Rd;man/SimParam_addTraitADEG.Rd;man/SimParam_addTraitADG.Rd;man/SimParam_addTraitAE.Rd;man/SimParam_addTraitAEG.Rd;man/SimParam_addTraitAG.Rd;man/SimParam_manAddSnpChip.Rd;man/SimParam_manAddTrait.Rd;man/SimParam_new.Rd;man/SimParam_removeFounderPop.Rd;man/SimParam_removeSnpChip.Rd;man/SimParam_removeTrait.Rd;man/SimParam_rescaleTraits.Rd;man/SimParam_resetPed.Rd;man/SimParam_restrSegSites.Rd;man/SimParam_setCorE.Rd;man/SimParam_setGender.Rd;man/SimParam_setMeiosis.Rd;man/SimParam_setTrackPed.Rd;man/SimParam_setTrackRec.Rd;man/SimParam_setVarE.Rd;man/SimParam_switchFemaleMap.Rd;man/SimParam_switchFounderPop.Rd;man/SimParam_switchGenMap.Rd;man/SimParam_switchMaleMap.Rd;man/SimParam_switchSnpChip.Rd;man/SimParam_switchTrait.Rd;man/fastRRBLUP.Rd;man/h2.Rd;man/makeCross.Rd;man/makeCross2.Rd;man/mergeGenome.Rd;man/pullIbdHaplo.Rd;man/pullQtlGeno.Rd;man/pullQtlHaplo.Rd;man/pullSegSiteGeno.Rd;man/pullSegSiteHaplo.Rd;man/pullSnpGeno.Rd;man/pullSnpHaplo.Rd;man/reduceGenome.Rd;man/setEBV.Rd;src/getGeno.cpp;src/getGv.cpp;src/meiosis.cpp;src/packHaplo.cpp;tests/testthat/test-addTrait.R;vignettes/traits.Rmd,True,True,True,False,3139,3659,6798,"---FILE: NAMESPACE---
@@ -1,6 +1,5 @@
 # Generated by roxygen2: do not edit by hand
 
-export(H2)
 export(RRBLUP)
 export(RRBLUP2)
 export(RRBLUPMemUse)
@@ -29,13 +28,13 @@ export(genicVarG)
 export(getQtlMap)
 export(getSnpMap)
 export(gv)
-export(h2)
 export(hybridCross)
 export(makeCross)
 export(makeCross2)
 export(makeDH)
 export(meanG)
 export(meanP)
+export(mergeGenome)
 export(mergePops)
 export(mutate)
 export(nInd)

---FILE: NEWS---
@@ -1,11 +1,15 @@
 Changes in version 0.12.0
   
   New features
-    -changed output of genParam function
-    -added h2 and H2 functions
+    -changed output of genParam to match Bulmer, 1976
+    -nProgeny added to makeCross and makeCross2
+    -all SimParam documentation is now in ?SimParam
+    -non-overlapping QTL and SNP is now the default
+    -new interface for restrSegSites in SimParam
   
   Bug fixes
     -fixed subset by id for populations
+    -fixed major bug in newMapPop
 
 Changes in version 0.11.1
   

---FILE: R/GS.R---
@@ -29,7 +29,7 @@
 #' 
 #' @examples 
 #' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)
 #' 
 #' #Set simulation parameters
 #' SP = SimParam$new(founderPop)
@@ -142,7 +142,7 @@ fastRRBLUP = function(pop, traits=1, use=""pheno"", snpChip=1,
 #'
 #' @examples 
 #' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)
 #' 
 #' #Set simulation parameters
 #' SP = SimParam$new(founderPop)
@@ -278,7 +278,7 @@ RRBLUP = function(pop, traits=1, use=""pheno"", snpChip=1,
 #' 
 #' @examples 
 #' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)
 #' 
 #' #Set simulation parameters
 #' SP = SimParam$new(founderPop)
@@ -391,7 +391,7 @@ RRBLUP2 = function(pop, traits=1, use=""pheno"", snpChip=1,
 #'
 #' @examples 
 #' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)
 #' 
 #' #Set simulation parameters
 #' SP = SimParam$new(founderPop)
@@ -494,7 +494,7 @@ RRBLUP_D = function(pop, traits=1, use=""pheno"", snpChip=1,
 #'
 #' @examples 
 #' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)
 #' 
 #' #Set simulation parameters
 #' SP = SimParam$new(founderPop)
@@ -619,7 +619,7 @@ RRBLUP_D2 = function(pop, traits=1, use=""pheno"", snpChip=1,
 #'
 #' @examples 
 #' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)
 #' 
 #' #Set simulation parameters
 #' SP = SimParam$new(founderPop)
@@ -727,7 +727,7 @@ RRBLUP_GCA = function(pop, traits=1, use=""pheno"", snpChip=1,
 #'
 #' @examples 
 #' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)
 #' 
 #' #Set simulation parameters
 #' SP = SimParam$new(founderPop)
@@ -858,7 +858,7 @@ RRBLUP_GCA2 = function(pop, traits=1, use=""pheno"", snpChip=1,
 #'
 #' @examples 
 #' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+#' founderPop = quickHaplo(nInd=2, nChr=1, segSites=20)
 #' 
 #' #Set simulation parameters
 #' SP = SimParam$new(founderPop)
@@ -969,7 +969,7 @@ RRBLUP_SCA = function(pop, traits=1, use=""pheno"", snpChip=1,
 #'
 #' @examples 
 #' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)
 #' 
 #' #Set simulation parameters
 #' SP = SimParam$new(founderPop)
@@ -1112,7 +1112,7 @@ RRBLUP_SCA2 = function(pop, traits=1, use=""pheno"", snpChip=1,
 #'
 #' @examples 
 #' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)
 #' 
 #' #Set simulation parameters
 #' SP = SimParam$new(founderPop)

---FILE: R/crossing.R---
@@ -8,6 +8,7 @@
 #' @param crossPlan a matrix with two column representing 
 #' female and male parents. Either integers for the position in 
 #' population or character strings for the IDs.
+#' @param nProgeny number of progeny per cross
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
 #' @return Returns an object of \code{\link{Pop-class}}
@@ -27,7 +28,8 @@
 #' pop2 = makeCross(pop, crossPlan, simParam=SP)
 #'
 #' @export
-makeCross = function(pop,crossPlan,simParam=NULL){
+makeCross = function(pop,crossPlan,nProgeny=1,
+                     simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
@@ -45,6 +47,10 @@ makeCross = function(pop,crossPlan,simParam=NULL){
      (min(crossPlan)<1L)){
     stop(""Invalid crossPlan"")
   }
+  if(nProgeny>1){
+    crossPlan = cbind(rep(crossPlan[,1],each=nProgeny),
+                      rep(crossPlan[,2],each=nProgeny))
+  }
   tmp = cross(pop@geno,
               crossPlan[,1],
               pop@geno,
@@ -156,11 +162,7 @@ randCross = function(pop,nCrosses,nProgeny=1,
       crossPlan[,2] = male[crossPlan[,2]]
     }
   }
-  if(nProgeny>1){
-    crossPlan = cbind(rep(crossPlan[,1],each=nProgeny),
-                      rep(crossPlan[,2],each=nProgeny))
-  }
-  return(makeCross(pop=pop,crossPlan=crossPlan,simParam=simParam))
+  return(makeCross(pop=pop,crossPlan=crossPlan,nProgeny=nProgeny,simParam=simParam))
 }
 
 #' @title Select and randomly cross
@@ -260,6 +262,7 @@ selectCross = function(pop,nInd=NULL,nFemale=NULL,nMale=NULL,nCrosses,
 #' @param crossPlan a matrix with two column representing 
 #' female and male parents. Either integers for the position in 
 #' population or character strings for the IDs.
+#' @param nProgeny number of progeny per cross
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
 #' @return Returns an object of \code{\link{Pop-class}}
@@ -279,7 +282,7 @@ selectCross = function(pop,nInd=NULL,nFemale=NULL,nMale=NULL,nCrosses,
 #' pop2 = makeCross2(pop, pop, crossPlan, simParam=SP)
 #' 
 #' @export
-makeCross2 = function(females,males,crossPlan,simParam=NULL){
+makeCross2 = function(females,males,crossPlan,nProgeny=1,simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
@@ -299,6 +302,10 @@ makeCross2 = function(females,males,crossPlan,simParam=NULL){
      (min(crossPlan)<1L)){
     stop(""Invalid crossPlan"")
   }
+  if(nProgeny>1){
+    crossPlan = cbind(rep(crossPlan[,1],each=nProgeny),
+                      rep(crossPlan[,2],each=nProgeny))
+  }
   tmp=cross(females@geno,
             crossPlan[,1],
             males@geno,
@@ -418,12 +425,9 @@ randCross2 = function(females,males,nCrosses,nProgeny=1,
     crossPlan[,1] = female[crossPlan[,1]]
     crossPlan[,2] = male[crossPlan[,2]]
   }
-  if(nProgeny>1){
-    crossPlan = cbind(rep(crossPlan[,1],each=nProgeny),
-                      rep(crossPlan[,2],each=nProgeny))
-  }
   return(makeCross2(females=females,males=males,
-                    crossPlan=crossPlan,simParam=simParam))
+                    crossPlan=crossPlan,nProgeny=nProgeny,
+                    simParam=simParam))
 }
 
 #' @title Self individuals

---FILE: R/founderPop.R---
@@ -61,7 +61,7 @@ newMapPop = function(genMap,haplotypes,inbred=FALSE,
   nCol = unlist(nCol)
   segSites = lapply(genMap,length)
   segSites = unlist(segSites)
-  if(!all.equal(nCol,segSites)){
+  if(!all(nCol == segSites)){
     stop(""Number of segregating sites in haplotypes and genMap don't match"")
   }
   output = vector(""list"",length(genMap))

---FILE: R/polyploids.R---
@@ -4,14 +4,15 @@
 #' was created to model the creation of diploid potatoes from 
 #' tetraploid potatoes. It can be used on any population with an 
 #' even ploidy level. The newly created individuals will have half 
-#' the ploidy level of the originals and they will first undergo
-#' a single round of meiosis.
+#' the ploidy level of the originals. The reduction can occur with 
+#' or without genetic recombination.
 #' 
 #' @param pop an object of 'Pop' superclass
 #' @param nProgeny total number of progeny per individual
 #' @param useFemale should female recombination rates be used. 
 #' @param keepParents should previous parents be used for mother and 
 #' father. 
+#' @param simRecomb should genetic recombination be modeled.
 #' @param simParam an object of 'SimParam' class
 #' 
 #' @return Returns an object of \code{\link{Pop-class}}
@@ -31,32 +32,35 @@
 #' 
 #' @export
 reduceGenome = function(pop,nProgeny=1,useFemale=TRUE,keepParents=TRUE,
-                        simParam=NULL){
+                        simRecomb=TRUE,simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
   if(pop@ploidy%%2L){
     stop(""You cannot reduce aneuploids"")
   }
-  if(useFemale){
-    tmp = createReducedGenome(pop@geno, nProgeny,
-                              simParam$femaleMap,
-                              simParam$v,
-                              simParam$isTrackRec,
-                              pop@ploidy,
-                              simParam$femaleCentromere,
-                              simParam$quadProb,
-                              simParam$nThreads)
+  if(simRecomb){
+    if(useFemale){
+      map = simParam$femaleMap
+    }else{
+      map = simParam$maleMap
+    }
   }else{
-    tmp = createReducedGenome(pop@geno, nProgeny,
-                              simParam$maleMap,
-                              simParam$v,
-                              simParam$isTrackRec,
-                              pop@ploidy,
-                              simParam$maleCentromere,
-                              simParam$quadProb,
-                              simParam$nThreads)
+    # Create dummy map with zero genetic distance
+    map = vector(""list"",pop@nChr)
+    for(i in 1:pop@nChr){
+      map[[i]] = rep(0,pop@nLoci[i])
+    }
+    map = as.matrix(map)
   }
+  tmp = createReducedGenome(pop@geno, nProgeny,
+                            map,
+                            simParam$v,
+                            simParam$isTrackRec,
+                            pop@ploidy,
+                            simParam$femaleCentromere,
+                            simParam$quadProb,
+                            simParam$nThreads)
   rPop = new(""RawPop"",
              nInd=as.integer(pop@nInd*nProgeny),
              nChr=pop@nChr,
@@ -173,37 +177,105 @@ doubleGenome = function(pop, keepParents=TRUE,
                 simParam=simParam))
 }
 
-#' #' @title Combine genomes of individuals
-#' #' 
-#' #' @description
-#' #' This function is designed to model the pairing of gametes. The male 
-#' #' and female individuals are treated as gametes, so the newly created
-#' #'
-#' #' @param females an object of \code{\link{Pop-class}} for female parents.
-#' #' @param males an object of \code{\link{Pop-class}} for male parents.
-#' #' @param crossPlan a matrix with two column representing 
-#' #' female and male parents. Either integers for the position in 
-#' #' population or character strings for the IDs.
-#' #' @param simParam an object of \code{\link{SimParam}}
-#' #' 
-#' #' @return Returns an object of \code{\link{Pop-class}}
-#' #'
-#' #' @examples 
-#' #' #Create founder haplotypes
-#' #' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-#' #' 
-#' #' #Set simulation parameters
-#' #' SP = SimParam$new(founderPop)
-#' #' 
-#' #' #Create population
-#' #' pop = newPop(founderPop, simParam=SP)
-#' #' 
-#' #' #Cross individual 1 with individual 10
-#' #' crossPlan = matrix(c(1,10), nrow=1, ncol=2)
-#' #' pop2 = makeCross2(pop, pop, crossPlan, simParam=SP)
-#' #' 
-#' #' @export
-#' mergeGenome = function(females,males,crossPlan,simParam=NULL){
-#'   
-#' }
+#' @title Combine genomes of individuals
+#'
+#' @description
+#' This function is designed to model the pairing of gametes. The male
+#' and female individuals are treated as gametes, so the ploidy of newly 
+#' created individuals will be the sum of it parents.
+#'
+#' @param females an object of \code{\link{Pop-class}} for female parents.
+#' @param males an object of \code{\link{Pop-class}} for male parents.
+#' @param crossPlan a matrix with two column representing
+#' female and male parents. Either integers for the position in
+#' population or character strings for the IDs.
+#' @param simParam an object of \code{\link{SimParam}}
+#'
+#' @return Returns an object of \code{\link{Pop-class}}
+#'
+#' @examples
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#'
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#'
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#'
+#' #Cross individual 1 with individual 10
+#' crossPlan = matrix(c(1,10), nrow=1, ncol=2)
+#' pop2 = mergeGenome(pop, pop, crossPlan, simParam=SP)
+#'
+#' @export
+mergeGenome = function(females,males,crossPlan,simParam=NULL){
+  if(is.null(simParam)){
+    simParam = get(""SP"",envir=.GlobalEnv)
+  }
+  if(is.character(crossPlan)){ #Match by ID
+    crossPlan = cbind(match(crossPlan[,1],females@id),
+                      match(crossPlan[,2],males@id))
+    if(any(is.na(crossPlan))){
+      stop(""Failed to match supplied IDs"")
+    }
+  }
+  if((max(crossPlan[,1])>nInd(females)) | 
+     (max(crossPlan[,2])>nInd(males)) |
+     (min(crossPlan)<1L)){
+    stop(""Invalid crossPlan"")
+  }
+  mother = as.integer(females@id[crossPlan[,1]])
+  father = as.integer(males@id[crossPlan[,2]])
+  # Merge genotype data
+  geno = vector(""list"", females@nChr)
+  for(i in 1:females@nChr){
+    geno[[i]] = array(as.raw(0), 
+                      dim = c(dim(females@geno[[i]])[1],
+                              females@ploidy+males@ploidy,
+                              nrow(crossPlan)))
+    for(j in 1:nrow(crossPlan)){
+      # Add female gamete
+      geno[[i]][,1:females@ploidy,j] = 
+        females@geno[[i]][,,crossPlan[j,1]]
+      # Add male gamete
+      geno[[i]][,(females@ploidy+1):(females@ploidy+males@ploidy),j] = 
+        males@geno[[i]][,,crossPlan[j,2]]
+    }
+  }
+  rPop = new(""RawPop"",
+             nInd=as.integer(nrow(crossPlan)),
+             nChr=females@nChr,
+             ploidy=females@ploidy+males@ploidy,
+             nLoci=females@nLoci,
+             geno=as.matrix(geno))
+  
+  if(simParam$isTrackRec){
+    # Duplicate recombination histories
+    oldHist = simParam$recHist
+    newHist = vector(""list"", females@ploidy+males@ploidy)
+    newHist = rep(list(newHist), females@nChr)
+    newHist = rep(list(newHist), nrow(crossPlan))
+    for(i in 1:nrow(crossPlan)){
+      for(j in 1:females@nChr){
+        k = 0
+        for(l in 1:females@ploidy){
+          k = k+1
+          newHist[[i]][[j]][[k]] = 
+            oldHist[[mother[i]]][[j]][[l]]
+        }
+        for(l in 1:males@ploidy){
+          k = k+1
+          newHist[[i]][[j]][[k]] = 
+            oldHist[[father[i]]][[j]][[l]]
+        }
+      }
+    }
+    simParam$addToRec(newHist)
+  }
+  return(newPop(rawPop=rPop,
+                mother=mother,
+                father=father,
+                isDH=FALSE,
+                simParam=simParam))
+}
 

---FILE: R/popSummary.R---
@@ -193,6 +193,7 @@ genParam = function(pop,simParam=NULL){
       dd = cbind(dd,tmp$dd)
       gv_d = cbind(gv_d,tmp$gv_d)
     }else{
+      genicVarD = c(genicVarD,0)
       covD_HW = c(covD_HW,0)
       dd = cbind(dd,rep(0,pop@nInd))
       gv_d = cbind(gv_d,rep(0,pop@nInd))
@@ -599,53 +600,3 @@ ebv = function(pop){
 nInd = function(pop){
   pop@nInd
 }
-
-#' @title Narrow-sense heritability
-#' 
-#' @description Returns narrow-sense heritability for all traits
-#' 
-#' @param pop an object of \code{\link{Pop-class}}
-#' @param simParam an object of \code{\link{SimParam}}
-#' 
-#' @examples 
-#' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-#' 
-#' #Set simulation parameters
-#' SP = SimParam$new(founderPop)
-#' SP$addTraitAD(10, meanDD=0.5)
-#' SP$setVarE(h2=0.5)
-#' 
-#' #Create population
-#' pop = newPop(founderPop, simParam=SP)
-#' h2(pop, simParam=SP)
-#' 
-#' @export
-h2 = function(pop, simParam=NULL){
-  diag(varA(pop))/diag(varP(pop))
-}
-
-#' @title Broad-sense heritability
-#' 
-#' @description Returns broad-sense heritability for all traits
-#' 
-#' @param pop an object of \code{\link{Pop-class}}
-#' @param simParam an object of \code{\link{SimParam}}
-#' 
-#' @examples 
-#' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-#' 
-#' #Set simulation parameters
-#' SP = SimParam$new(founderPop)
-#' SP$addTraitAD(10, meanDD=0.5)
-#' SP$setVarE(h2=0.5)
-#' 
-#' #Create population
-#' pop = newPop(founderPop, simParam=SP)
-#' H2(pop)
-#' 
-#' @export
-H2 = function(pop){
-  diag(varG(pop))/diag(varP(pop))
-}

---FILE: R/pullGeno.R---
@@ -183,7 +183,7 @@ getQtlMap = function(trait=1, gender=""A"", simParam=NULL){
 #' 
 #' @examples 
 #' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)
 #' 
 #' #Set simulation parameters
 #' SP = SimParam$new(founderPop)
@@ -282,7 +282,7 @@ pullSnpGeno = function(pop, snpChip=1, chr=NULL, simParam=NULL){
 #' 
 #' @examples 
 #' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)
 #' 
 #' #Set simulation parameters
 #' SP = SimParam$new(founderPop)
@@ -327,7 +327,7 @@ pullQtlGeno = function(pop, trait=1, chr=NULL, simParam=NULL){
 #' 
 #' @examples 
 #' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)
 #' 
 #' #Set simulation parameters
 #' SP = SimParam$new(founderPop)
@@ -382,7 +382,7 @@ pullSegSiteGeno = function(pop, chr=NULL, simParam=NULL){
 #' 
 #' @examples 
 #' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)
 #' 
 #' #Set simulation parameters
 #' SP = SimParam$new(founderPop)
@@ -530,7 +530,7 @@ pullSnpHaplo = function(pop, snpChip=1, haplo=""all"",
 #' 
 #' @examples 
 #' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)
 #' 
 #' #Set simulation parameters
 #' SP = SimParam$new(founderPop)
@@ -595,7 +595,7 @@ pullQtlHaplo = function(pop, trait=1, haplo=""all"",
 #' 
 #' @examples 
 #' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)
 #' 
 #' #Set simulation parameters
 #' SP = SimParam$new(founderPop)
@@ -673,10 +673,11 @@ pullSegSiteHaplo = function(pop, haplo=""all"",
 #' are retrieved. If NULL, all sites are retrieved.
 #' @param pedigree a matrix with ancestral pedigree to set a base
 #' population. It should be of the same form as \code{simParam$pedigree} 
-#' (see \code{\link{SimParam_setTrackPed}}), i.e., two columns (mother
-#' and father) and the same number of rows as \code{simParam$pedigree}.
-#' Base population can be set by setting parents as 0. If NULL, pedigree
-#' from \code{\link{SimParam}} is taken.
+#' (see \code{setTrackPed} in \code{\link{SimParam}}), i.e., two columns 
+#' (mother and father) and the same number of rows as 
+#' \code{simParam$pedigree}.Base population can be set by setting 
+#' parents as 0. If NULL, pedigree from \code{\link{SimParam}} is taken.
+#' 
 #' @param simParam an object of \code{\link{SimParam}}
 #'
 #' @return Returns a matrix of haplotypes with Identity By Descent
@@ -685,7 +686,7 @@ pullSegSiteHaplo = function(pop, haplo=""all"",
 #' 
 #' @examples 
 #' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)
 #' 
 #' #Set simulation parameters
 #' SP = SimParam$new(founderPop)

---FILE: man/RRBLUP.Rd---
@@ -48,7 +48,7 @@ Fits an RR-BLUP model for genomic predictions.
 }
 \examples{
 #Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)

---FILE: man/RRBLUP2.Rd---
@@ -94,7 +94,7 @@ of this approach.
 }
 \examples{
 #Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)

---FILE: man/RRBLUP_D.Rd---
@@ -49,7 +49,7 @@ dominance effects.
 }
 \examples{
 #Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)

---FILE: man/RRBLUP_D2.Rd---
@@ -71,7 +71,7 @@ is only faster in certain situations. Most users should use
 }
 \examples{
 #Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)

---FILE: man/RRBLUP_GCA.Rd---
@@ -50,7 +50,7 @@ single cross hybrids.
 }
 \examples{
 #Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)

---FILE: man/RRBLUP_GCA2.Rd---
@@ -70,7 +70,7 @@ is only faster in certain situations. Most users should use
 }
 \examples{
 #Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)

---FILE: man/RRBLUP_SCA.Rd---
@@ -49,7 +49,7 @@ Note that we have not seen any consistent benefit of this model over
 }
 \examples{
 #Create founder haplotypes
-founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+founderPop = quickHaplo(nInd=2, nChr=1, segSites=20)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)

---FILE: man/RRBLUP_SCA2.Rd---
@@ -74,7 +74,7 @@ RRBLUP_SCA2 is only faster in certain situations. Most users should use
 }
 \examples{
 #Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)

---FILE: man/SimParam.Rd---
@@ -7,19 +7,270 @@
 Container for global simulation parameters. Saving this object 
 as SP will allow it to be accessed by function defaults.
 }
+\note{
+By default the founder population is the population used to 
+initalize the SimParam object. This population can be changed by 
+replacing the population in the founderPop slot. You must run 
+\code{\link{resetPop}} on any existing populations to obtain the 
+new trait values.
+}
+\examples{
+
+## ------------------------------------------------
+## Method `SimParam$new`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+
+## ------------------------------------------------
+## Method `SimParam$setTrackPed`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$setTrackPed(TRUE)
+
+## ------------------------------------------------
+## Method `SimParam$setTrackRec`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$setTrackRec(TRUE)
+
+## ------------------------------------------------
+## Method `SimParam$resetPed`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+pop@id # 1:10
+
+#Create another population after reseting pedigree
+SP$resetPed()
+pop2 = newPop(founderPop, simParam=SP)
+pop2@id # 1:10
+
+## ------------------------------------------------
+## Method `SimParam$restrSegSites`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$restrSegSites(minQtlPerChr=5, minSnpPerChr=5)
+
+## ------------------------------------------------
+## Method `SimParam$setGender`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$setGender(""yes_sys"")
+
+## ------------------------------------------------
+## Method `SimParam$addSnpChip`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addSnpChip(10)
+
+## ------------------------------------------------
+## Method `SimParam$addTraitA`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+
+## ------------------------------------------------
+## Method `SimParam$addTraitAD`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAD(10, meanDD=0.5)
+
+## ------------------------------------------------
+## Method `SimParam$addTraitAG`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAG(10, varGxE=2)
+
+## ------------------------------------------------
+## Method `SimParam$addTraitADG`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitADG(10, meanDD=0.5, varGxE=2)
+
+## ------------------------------------------------
+## Method `SimParam$addTraitAE`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+## ------------------------------------------------
+## Method `SimParam$addTraitADE`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitADE(10)
+
+## ------------------------------------------------
+## Method `SimParam$addTraitAEG`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAEG(10, varGxE=2)
+
+## ------------------------------------------------
+## Method `SimParam$addTraitADEG`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitADEG(10, meanDD=0.5, varGxE=2)
+
+## ------------------------------------------------
+## Method `SimParam$setVarE`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$setVarE(h2=0.5)
+
+## ------------------------------------------------
+## Method `SimParam$setCorE`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10, mean=c(0,0), var=c(1,1), corA=diag(2))
+SP$setVarE(varE=c(1,1))
+E = 0.5*diag(2)+0.5 #Positively correlated error
+SP$setCorE(E)
+
+## ------------------------------------------------
+## Method `SimParam$rescaleTraits`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+meanG(pop)
+
+#Change mean to 1
+SP$rescaleTraits(mean=1)
+#Run resetPop for change to take effect
+pop = resetPop(pop, simParam=SP) 
+meanG(pop)
+
+## ------------------------------------------------
+## Method `SimParam$setRecombRatio`
+## ------------------------------------------------
+
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$setRecombRatio(2) #Twice as much recombination in females
+}
 \section{Public fields}{
 \if{html}{\out{<div class=""r6-fields"">}}
 \describe{
-\item{\code{recombRatio}}{ratio of genetic recombination in 
-females relative to male}
-
 \item{\code{nThreads}}{number of threads used on platforms with OpenMP support}
+
+\item{\code{snpChips}}{list of SNP chips}
+
+\item{\code{invalidQtl}}{list of segregating sites that aren't valid QTL}
+
+\item{\code{invalidSnp}}{list of segregating sites that aren't valid SNP}
+
+\item{\code{founderPop}}{founder population used for variance scaling}
+
+\item{\code{v}}{the crossover interference parameter for a gamma model of 
+recombination. A value of 1 indicates no crossover interference 
+(e.g. Haldane mapping function). A value of 2.6 approximates the 
+degree of crossover interference implied by the Kosambi mapping 
+function. (default is 1)}
+
+\item{\code{quadProb}}{the probability of quadrivalent pairing in an 
+autopolyploid. (default is 0)}
 }
 \if{html}{\out{</div>}}
 }
 \section{Active bindings}{
 \if{html}{\out{<div class=""r6-active-bindings"">}}
 \describe{
+\item{\code{traits}}{list of traits}
+
 \item{\code{nChr}}{number of chromosomes}
 
 \item{\code{nTraits}}{number of traits}
@@ -30,6 +281,9 @@ females relative to male}
 
 \item{\code{gender}}{is gender used for mating}
 
+\item{\code{sepMap}}{are there seperate genetic maps for 
+males and females}
+
 \item{\code{genMap}}{""matrix"" of chromosome genetic maps}
 
 \item{\code{femaleMap}}{""matrix"" of chromosome genetic maps for 
@@ -38,26 +292,14 @@ females}
 \item{\code{maleMap}}{""matrix"" of chromosome genetic maps for 
 males}
 
-\item{\code{sepMap}}{are there seperate genetic maps for 
-males and females}
+\item{\code{centromere}}{position of centromeres genetic map}
 
-\item{\code{femaleCentromere}}{position of centromere on female 
+\item{\code{femaleCentromere}}{position of centromeres on female 
 genetic map}
 
-\item{\code{maleCentromere}}{position of centromere on male 
+\item{\code{maleCentromere}}{position of centromeres on male 
 genetic map}
 
-\item{\code{recombRatio}}{ratio of genetic recombination in 
-females relative to male}
-
-\item{\code{traits}}{list of trait}
-
-\item{\code{snpChips}}{list of SNP chips}
-
-\item{\code{potQtl}}{list of potential QTL segregating sites}
-
-\item{\code{potSnp}}{list of potential SNP segregating sites}
-
 \item{\code{lastId}}{last ID number assigned}
 
 \item{\code{isTrackPed}}{is pedigree being tracked}
@@ -74,12 +316,6 @@ females relative to male}
 
 \item{\code{varE}}{default error variance}
 
-\item{\code{founderPop}}{the founder population used for scaling traits}
-
-\item{\code{v}}{the interference parameter for a gamma model of recombination}
-
-\item{\code{quadProb}}{the probability of quadrivalent formation}
-
 \item{\code{version}}{the version of AlphaSimR used to generate this object}
 }
 \if{html}{\out{</div>}}
@@ -88,20 +324,13 @@ females relative to male}
 \subsection{Public methods}{
 \itemize{
 \item \href{#method-new}{\code{SimParam$new()}}
-\item \href{#method-updateLastId}{\code{SimParam$updateLastId()}}
 \item \href{#method-setTrackPed}{\code{SimParam$setTrackPed()}}
 \item \href{#method-setTrackRec}{\code{SimParam$setTrackRec()}}
 \item \href{#method-resetPed}{\code{SimParam$resetPed()}}
 \item \href{#method-restrSegSites}{\code{SimParam$restrSegSites()}}
 \item \href{#method-setGender}{\code{SimParam$setGender()}}
-\item \href{#method-setMeiosis}{\code{SimParam$setMeiosis()}}
-\item \href{#method-setVarE}{\code{SimParam$setVarE()}}
-\item \href{#method-setCorE}{\code{SimParam$setCorE()}}
 \item \href{#method-addSnpChip}{\code{SimParam$addSnpChip()}}
 \item \href{#method-addStructuredSnpChip}{\code{SimParam$addStructuredSnpChip()}}
-\item \href{#method-removeSnpChip}{\code{SimParam$removeSnpChip()}}
-\item \href{#method-switchSnpChip}{\code{SimParam$switchSnpChip()}}
-\item \href{#method-manAddSnpChip}{\code{SimParam$manAddSnpChip()}}
 \item \href{#method-addTraitA}{\code{SimParam$addTraitA()}}
 \item \href{#method-addTraitAD}{\code{SimParam$addTraitAD()}}
 \item \href{#method-addTraitAG}{\code{SimParam$addTraitAG()}}
@@ -110,149 +339,324 @@ females relative to male}
 \item \href{#method-addTraitADE}{\code{SimParam$addTraitADE()}}
 \item \href{#method-addTraitAEG}{\code{SimParam$addTraitAEG()}}
 \item \href{#method-addTraitADEG}{\code{SimParam$addTraitADEG()}}
-\item \href{#method-removeTrait}{\code{SimParam$removeTrait()}}
-\item \href{#method-switchTrait}{\code{SimParam$switchTrait()}}
 \item \href{#method-manAddTrait}{\code{SimParam$manAddTrait()}}
+\item \href{#method-switchTrait}{\code{SimParam$switchTrait()}}
+\item \href{#method-removeTrait}{\code{SimParam$removeTrait()}}
+\item \href{#method-setVarE}{\code{SimParam$setVarE()}}
+\item \href{#method-setCorE}{\code{SimParam$setCorE()}}
 \item \href{#method-rescaleTraits}{\code{SimParam$rescaleTraits()}}
-\item \href{#method-switchFounderPop}{\code{SimParam$switchFounderPop()}}
-\item \href{#method-removeFounderPop}{\code{SimParam$removeFounderPop()}}
-\item \href{#method-addToPed}{\code{SimParam$addToPed()}}
-\item \href{#method-addToRec}{\code{SimParam$addToRec()}}
+\item \href{#method-setRecombRatio}{\code{SimParam$setRecombRatio()}}
 \item \href{#method-switchGenMap}{\code{SimParam$switchGenMap()}}
 \item \href{#method-switchFemaleMap}{\code{SimParam$switchFemaleMap()}}
 \item \href{#method-switchMaleMap}{\code{SimParam$switchMaleMap()}}
+\item \href{#method-addToRec}{\code{SimParam$addToRec()}}
+\item \href{#method-updateLastId}{\code{SimParam$updateLastId()}}
+\item \href{#method-addToPed}{\code{SimParam$addToPed()}}
 \item \href{#method-clone}{\code{SimParam$clone()}}
 }
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-new""></a>}}
 \subsection{Method \code{new()}}{
+Starts the process of building a new simulation 
+by creating a new SimParam object and assigning a founder 
+population to the class. It is recommended that you save the 
+object with the name ""SP"", because subsequent functions will 
+check your global enviroment for an object of this name if 
+their simParam arguments are NULL. This allows you to call 
+these functions without explicitly supplying a simParam 
+argument with every call.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$new(founderPop)}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{founderPop}}{an object of \code{\link{MapPop-class}}}
 }
-\if{html}{\out{<hr>}}
-\if{html}{\out{<a id=""method-updateLastId""></a>}}
-\subsection{Method \code{updateLastId()}}{
-\subsection{Usage}{
-\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$updateLastId(lastId)}\if{html}{\out{</div>}}
+\if{html}{\out{</div>}}
+}
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+}
+\if{html}{\out{</div>}}
+
 }
 
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-setTrackPed""></a>}}
 \subsection{Method \code{setTrackPed()}}{
+Sets pedigree tracking for the simulation. 
+By default pedigree tracking is turned off. When turned on, 
+the pedigree of all individuals created will be tracked, 
+except those created by \code{\link{hybridCross}}. Turning 
+off pedigree tracking will turn off recombination tracking 
+if it is turned on.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$setTrackPed(isTrackPed, force = FALSE)}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{isTrackPed}}{should pedigree tracking be on.}
+
+\item{\code{force}}{should the check for a running simulation be 
+ignored. Only set to TRUE if you know what you are doing.}
+}
+\if{html}{\out{</div>}}
+}
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$setTrackPed(TRUE)
+}
+\if{html}{\out{</div>}}
+
+}
+
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-setTrackRec""></a>}}
 \subsection{Method \code{setTrackRec()}}{
+Sets recombination tracking for the simulation.
+By default recombination tracking is turned off. When turned
+on recombination tracking will also turn on pedigree tracking.
+Recombination tracking keeps records of all individuals created,
+except those created by \code{\link{hybridCross}}, because their
+pedigree is not tracked.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$setTrackRec(isTrackRec, force = FALSE)}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{isTrackRec}}{should recombination tracking be on.}
+
+\item{\code{force}}{should the check for a running simulation be
+ignored. Only set to TRUE if you know what you are doing.}
+}
+\if{html}{\out{</div>}}
+}
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$setTrackRec(TRUE)
+}
+\if{html}{\out{</div>}}
+
+}
+
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-resetPed""></a>}}
 \subsection{Method \code{resetPed()}}{
+Resets the internal lastId, the pedigree 
+and recombination tracking (if in use) to the 
+supplied lastId. Be careful using this function because 
+it may introduce a bug if you use individuals from
+the deleted portion of the pedigree.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$resetPed(lastId = 0L)}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{lastId}}{last ID to include in pedigree}
+}
+\if{html}{\out{</div>}}
+}
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+pop@id # 1:10
+
+#Create another population after reseting pedigree
+SP$resetPed()
+pop2 = newPop(founderPop, simParam=SP)
+pop2@id # 1:10
+}
+\if{html}{\out{</div>}}
+
+}
+
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-restrSegSites""></a>}}
 \subsection{Method \code{restrSegSites()}}{
+Sets restrictions on which segregating sites 
+can serve as SNP and/or QTL.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$restrSegSites(
-  maxQtl = 0,
-  maxSnp = 0,
+  minQtlPerChr = NULL,
+  minSnpPerChr = NULL,
   overlap = FALSE,
-  minSnpFreq = NULL,
-  force = FALSE
+  minSnpFreq = NULL
 )}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{minQtlPerChr}}{the minimum number of segSites for QTLs. 
+Can be a single value or a vector values for each 
+chromosome.}
+
+\item{\code{minSnpPerChr}}{the minimum number of segSites for SNPs. 
+Can be a single value or a vector values for each 
+chromosome.}
+
+\item{\code{overlap}}{should SNP and QTL sites be allowed to overlap.}
+
+\item{\code{minSnpFreq}}{minimum allowable frequency for SNP loci. 
+No minimum SNP frequency is used if value is NULL.}
+}
+\if{html}{\out{</div>}}
+}
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$restrSegSites(minQtlPerChr=5, minSnpPerChr=5)
+}
+\if{html}{\out{</div>}}
+
+}
+
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-setGender""></a>}}
 \subsection{Method \code{setGender()}}{
+Changes how gender is used in the simulation. 
+The default gender of a simulation is ""no"". To add gender 
+to the simulation, run this function with ""yes_sys"" or 
+""yes_rand"". The value ""yes_sys"" will systematically assign 
+gender to newly created individuals as first male, then female. 
+Thus, odd numbers of individuals will have one more male than 
+female. The value ""yes_rand"" will randomly assign gender to 
+individuals.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$setGender(gender, force = FALSE)}\if{html}{\out{</div>}}
 }
 
-}
-\if{html}{\out{<hr>}}
-\if{html}{\out{<a id=""method-setMeiosis""></a>}}
-\subsection{Method \code{setMeiosis()}}{
-\subsection{Usage}{
-\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$setMeiosis(v = NULL, ratio = NULL, quadProb = NULL, force = FALSE)}\if{html}{\out{</div>}}
-}
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{gender}}{acceptable value are ""no"", ""yes_sys"", or 
+""yes_rand""}
 
+\item{\code{force}}{should the check for a running simulation be 
+ignored. Only set to TRUE if you know what you are doing.}
 }
-\if{html}{\out{<hr>}}
-\if{html}{\out{<a id=""method-setVarE""></a>}}
-\subsection{Method \code{setVarE()}}{
-\subsection{Usage}{
-\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$setVarE(h2 = NULL, H2 = NULL, varE = NULL)}\if{html}{\out{</div>}}
+\if{html}{\out{</div>}}
 }
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$setGender(""yes_sys"")
 }
-\if{html}{\out{<hr>}}
-\if{html}{\out{<a id=""method-setCorE""></a>}}
-\subsection{Method \code{setCorE()}}{
-\subsection{Usage}{
-\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$setCorE(corE)}\if{html}{\out{</div>}}
+\if{html}{\out{</div>}}
+
 }
 
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-addSnpChip""></a>}}
 \subsection{Method \code{addSnpChip()}}{
+Randomly assigns eligble SNPs to a SNP chip
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addSnpChip(nSnpPerChr, minSnpFreq = NULL, refPop = NULL)}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{nSnpPerChr}}{number of SNPs per chromosome. 
+Can be a single value or nChr values.}
+
+\item{\code{minSnpFreq}}{minimum allowable frequency for SNP loci.
+If NULL, no minimum frequency is used.}
+
+\item{\code{refPop}}{reference population for calculating SNP 
+frequency. If NULL, the founder population is used.}
 }
-\if{html}{\out{<hr>}}
-\if{html}{\out{<a id=""method-addStructuredSnpChip""></a>}}
-\subsection{Method \code{addStructuredSnpChip()}}{
-\subsection{Usage}{
-\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addStructuredSnpChip(nSnpPerChr, structure, force = FALSE)}\if{html}{\out{</div>}}
+\if{html}{\out{</div>}}
 }
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addSnpChip(10)
 }
-\if{html}{\out{<hr>}}
-\if{html}{\out{<a id=""method-removeSnpChip""></a>}}
-\subsection{Method \code{removeSnpChip()}}{
-\subsection{Usage}{
-\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$removeSnpChip(chips, force = FALSE)}\if{html}{\out{</div>}}
+\if{html}{\out{</div>}}
+
 }
 
 }
 \if{html}{\out{<hr>}}
-\if{html}{\out{<a id=""method-switchSnpChip""></a>}}
-\subsection{Method \code{switchSnpChip()}}{
+\if{html}{\out{<a id=""method-addStructuredSnpChip""></a>}}
+\subsection{Method \code{addStructuredSnpChip()}}{
+Randomly selects the number of snps in structure and then
+assigns them to chips based on structure
 \subsection{Usage}{
-\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$switchSnpChip(lociMap, chip, force = FALSE)}\if{html}{\out{</div>}}
+\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addStructuredSnpChip(nSnpPerChr, structure, force = FALSE)}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{nSnpPerChr}}{number of SNPs per chromosome. 
+Can be a single value or nChr values.}
+
+\item{\code{structure}}{a matrix.  Rows are snp chips, columns are chips.
+If value is true then that snp is on that chip.}
+
+\item{\code{force}}{should the check for a running simulation be 
+ignored. Only set to TRUE if you know what you are doing.}
 }
-\if{html}{\out{<hr>}}
-\if{html}{\out{<a id=""method-manAddSnpChip""></a>}}
-\subsection{Method \code{manAddSnpChip()}}{
-\subsection{Usage}{
-\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$manAddSnpChip(lociMap, force = FALSE)}\if{html}{\out{</div>}}
+\if{html}{\out{</div>}}
 }
-
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-addTraitA""></a>}}
 \subsection{Method \code{addTraitA()}}{
+Randomly assigns eligble QTLs for one or more additive traits. 
+If simulating more than one trait, all traits will be pleiotrophic 
+with correlated additive effects.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addTraitA(
   nQtlPerChr,
@@ -265,10 +669,46 @@ females relative to male}
 )}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{nQtlPerChr}}{number of QTLs per chromosome. Can be a single value or nChr values.}
+
+\item{\code{mean}}{a vector of desired mean genetic values for one or more traits}
+
+\item{\code{var}}{a vector of desired genetic variances for one or more traits}
+
+\item{\code{corA}}{a matrix of correlations between additive effects}
+
+\item{\code{gamma}}{should a gamma distribution be used instead of normal}
+
+\item{\code{shape}}{the shape parameter for the gamma distribution}
+
+\item{\code{force}}{should the check for a running simulation be 
+ignored. Only set to TRUE if you know what you are doing.}
+}
+\if{html}{\out{</div>}}
+}
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+}
+\if{html}{\out{</div>}}
+
+}
+
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-addTraitAD""></a>}}
 \subsection{Method \code{addTraitAD()}}{
+Randomly assigns eligble QTLs for one or more traits with dominance. 
+If simulating more than one trait, all traits will be pleiotrophic 
+with correlated effects.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addTraitAD(
   nQtlPerChr,
@@ -285,10 +725,55 @@ females relative to male}
 )}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{nQtlPerChr}}{number of QTLs per chromosome. Can be a single value or nChr values.}
+
+\item{\code{mean}}{a vector of desired mean genetic values for one or more traits}
+
+\item{\code{var}}{a vector of desired genetic variances for one or more traits}
+
+\item{\code{meanDD}}{mean dominance degree}
+
+\item{\code{varDD}}{variance of dominance degree}
+
+\item{\code{corA}}{a matrix of correlations between additive effects}
+
+\item{\code{corDD}}{a matrix of correlations between dominance degrees}
+
+\item{\code{useVarA}}{tune according to additive genetic variance if true. If 
+FALSE, tuning is performed according to total genetic variance.}
+
+\item{\code{gamma}}{should a gamma distribution be used instead of normal}
+
+\item{\code{shape}}{the shape parameter for the gamma distribution}
+
+\item{\code{force}}{should the check for a running simulation be 
+ignored. Only set to TRUE if you know what you are doing.}
+}
+\if{html}{\out{</div>}}
+}
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAD(10, meanDD=0.5)
+}
+\if{html}{\out{</div>}}
+
+}
+
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-addTraitAG""></a>}}
 \subsection{Method \code{addTraitAG()}}{
+Randomly assigns eligble QTLs for one ore more additive GxE traits. 
+If simulating more than one trait, all traits will be pleiotrophic 
+with correlated effects.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addTraitAG(
   nQtlPerChr,
@@ -304,10 +789,50 @@ females relative to male}
 )}\if{html}{\out{</div>}}
 }
 
-}
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{nQtlPerChr}}{number of QTLs per chromosome. Can be a single value or nChr values.}
+
+\item{\code{mean}}{a vector of desired mean genetic values for one or more traits}
+
+\item{\code{var}}{a vector of desired genetic variances for one or more traits}
+
+\item{\code{varGxE}}{a vector of total genotype-by-environment variances for the traits}
+
+\item{\code{varEnv}}{a vector of environmental variances for one or more traits}
+
+\item{\code{corA}}{a matrix of correlations between additive effects}
+
+\item{\code{corGxE}}{a matrix of correlations between GxE effects}
+
+\item{\code{gamma}}{should a gamma distribution be used instead of normal}
+
+\item{\code{shape}}{the shape parameter for the gamma distribution}
+
+\item{\code{force}}{should the check for a running simulation be 
+ignored. Only set to TRUE if you know what you are doing.}
+}
+\if{html}{\out{</div>}}
+}
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAG(10, varGxE=2)
+}
+\if{html}{\out{</div>}}
+
+}
+
+}
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-addTraitADG""></a>}}
 \subsection{Method \code{addTraitADG()}}{
+Randomly assigns eligble QTLs for a trait with dominance and GxE.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addTraitADG(
   nQtlPerChr,
@@ -327,10 +852,61 @@ females relative to male}
 )}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{nQtlPerChr}}{number of QTLs per chromosome. Can be a single 
+value or nChr values.}
+
+\item{\code{mean}}{a vector of desired mean genetic values for one or more traits}
+
+\item{\code{var}}{a vector of desired genetic variances for one or more traits}
+
+\item{\code{varEnv}}{a vector of environmental variances for one or more traits}
+
+\item{\code{varGxE}}{a vector of total genotype-by-environment variances for the traits}
+
+\item{\code{meanDD}}{mean dominance degree}
+
+\item{\code{varDD}}{variance of dominance degree}
+
+\item{\code{corA}}{a matrix of correlations between additive effects}
+
+\item{\code{corDD}}{a matrix of correlations between dominance degrees}
+
+\item{\code{corGxE}}{a matrix of correlations between GxE effects}
+
+\item{\code{useVarA}}{tune according to additive genetic variance if true}
+
+\item{\code{gamma}}{should a gamma distribution be used instead of normal}
+
+\item{\code{shape}}{the shape parameter for the gamma distribution}
+
+\item{\code{force}}{should the check for a running simulation be 
+ignored. Only set to TRUE if you know what you are doing.}
+}
+\if{html}{\out{</div>}}
+}
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitADG(10, meanDD=0.5, varGxE=2)
+}
+\if{html}{\out{</div>}}
+
+}
+
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-addTraitAE""></a>}}
 \subsection{Method \code{addTraitAE()}}{
+Randomly assigns eligble QTLs for one or more additive and epistasis 
+traits. If simulating more than one trait, all traits will be pleiotrophic 
+with correlated additive effects.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addTraitAE(
   nQtlPerChr,
@@ -346,10 +922,50 @@ females relative to male}
 )}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{nQtlPerChr}}{number of QTLs per chromosome. Can be a single value or nChr values.}
+
+\item{\code{mean}}{a vector of desired mean genetic values for one or more traits}
+
+\item{\code{var}}{a vector of desired genetic variances for one or more traits}
+
+\item{\code{relAA}}{the relative value of additive-by-additive variance compared 
+to additive variance in a diploid organism with allele frequency 0.5}
+
+\item{\code{corA}}{a matrix of correlations between additive effects}
+
+\item{\code{corAA}}{a matrix of correlations between additive-by-additive effects}
+
+\item{\code{useVarA}}{tune according to additive genetic variance if true. If 
+FALSE, tuning is performed according to total genetic variance.}
+
+\item{\code{gamma}}{should a gamma distribution be used instead of normal}
+
+\item{\code{shape}}{the shape parameter for the gamma distribution}
+
+\item{\code{force}}{should the check for a running simulation be 
+ignored. Only set to TRUE if you know what you are doing.}
+}
+\if{html}{\out{</div>}}
+}
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+}
+\if{html}{\out{</div>}}
+
+}
+
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-addTraitADE""></a>}}
 \subsection{Method \code{addTraitADE()}}{
+Randomly assigns eligble QTLs for one or more traits with dominance and 
+epistasis. If simulating more than one trait, all traits will be pleiotrophic 
+with correlated effects.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addTraitADE(
   nQtlPerChr,
@@ -368,10 +984,60 @@ females relative to male}
 )}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{nQtlPerChr}}{number of QTLs per chromosome. Can be a single value or nChr values.}
+
+\item{\code{mean}}{a vector of desired mean genetic values for one or more traits}
+
+\item{\code{var}}{a vector of desired genetic variances for one or more traits}
+
+\item{\code{meanDD}}{mean dominance degree}
+
+\item{\code{varDD}}{variance of dominance degree}
+
+\item{\code{relAA}}{the relative value of additive-by-additive variance compared 
+to additive variance in a diploid organism with allele frequency 0.5}
+
+\item{\code{corA}}{a matrix of correlations between additive effects}
+
+\item{\code{corDD}}{a matrix of correlations between dominance degrees}
+
+\item{\code{corAA}}{a matrix of correlations between additive-by-additive effects}
+
+\item{\code{useVarA}}{tune according to additive genetic variance if true. If 
+FALSE, tuning is performed according to total genetic variance.}
+
+\item{\code{gamma}}{should a gamma distribution be used instead of normal}
+
+\item{\code{shape}}{the shape parameter for the gamma distribution}
+
+\item{\code{force}}{should the check for a running simulation be 
+ignored. Only set to TRUE if you know what you are doing.}
+}
+\if{html}{\out{</div>}}
+}
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitADE(10)
+}
+\if{html}{\out{</div>}}
+
+}
+
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-addTraitAEG""></a>}}
 \subsection{Method \code{addTraitAEG()}}{
+Randomly assigns eligble QTLs for one or more additive and epistasis 
+GxE traits. If simulating more than one trait, all traits will be pleiotrophic 
+with correlated effects.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addTraitAEG(
   nQtlPerChr,
@@ -390,10 +1056,59 @@ females relative to male}
 )}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{nQtlPerChr}}{number of QTLs per chromosome. Can be a single value or nChr values.}
+
+\item{\code{mean}}{a vector of desired mean genetic values for one or more traits}
+
+\item{\code{var}}{a vector of desired genetic variances for one or more traits}
+
+\item{\code{relAA}}{the relative value of additive-by-additive variance compared 
+to additive variance in a diploid organism with allele frequency 0.5}
+
+\item{\code{varGxE}}{a vector of total genotype-by-environment variances for the traits}
+
+\item{\code{varEnv}}{a vector of environmental variances for one or more traits}
+
+\item{\code{corA}}{a matrix of correlations between additive effects}
+
+\item{\code{corAA}}{a matrix of correlations between additive-by-additive effects}
+
+\item{\code{corGxE}}{a matrix of correlations between GxE effects}
+
+\item{\code{useVarA}}{tune according to additive genetic variance if true. If 
+FALSE, tuning is performed according to total genetic variance.}
+
+\item{\code{gamma}}{should a gamma distribution be used instead of normal}
+
+\item{\code{shape}}{the shape parameter for the gamma distribution}
+
+\item{\code{force}}{should the check for a running simulation be 
+ignored. Only set to TRUE if you know what you are doing.}
+}
+\if{html}{\out{</div>}}
+}
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAEG(10, varGxE=2)
+}
+\if{html}{\out{</div>}}
+
+}
+
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-addTraitADEG""></a>}}
 \subsection{Method \code{addTraitADEG()}}{
+Randomly assigns eligble QTLs for a trait with dominance, 
+epistasis and GxE.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addTraitADEG(
   nQtlPerChr,
@@ -415,26 +1130,64 @@ females relative to male}
 )}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{nQtlPerChr}}{number of QTLs per chromosome. Can be a single 
+value or nChr values.}
+
+\item{\code{mean}}{a vector of desired mean genetic values for one or more traits}
+
+\item{\code{var}}{a vector of desired genetic variances for one or more traits}
+
+\item{\code{varEnv}}{a vector of environmental variances for one or more traits}
+
+\item{\code{varGxE}}{a vector of total genotype-by-environment variances for the traits}
+
+\item{\code{meanDD}}{mean dominance degree}
+
+\item{\code{varDD}}{variance of dominance degree}
+
+\item{\code{relAA}}{the relative value of additive-by-additive variance compared 
+to additive variance in a diploid organism with allele frequency 0.5}
+
+\item{\code{corA}}{a matrix of correlations between additive effects}
+
+\item{\code{corDD}}{a matrix of correlations between dominance degrees}
+
+\item{\code{corAA}}{a matrix of correlations between additive-by-additive effects}
+
+\item{\code{corGxE}}{a matrix of correlations between GxE effects}
+
+\item{\code{useVarA}}{tune according to additive genetic variance if true}
+
+\item{\code{gamma}}{should a gamma distribution be used instead of normal}
+
+\item{\code{shape}}{the shape parameter for the gamma distribution}
+
+\item{\code{force}}{should the check for a running simulation be 
+ignored. Only set to TRUE if you know what you are doing.}
 }
-\if{html}{\out{<hr>}}
-\if{html}{\out{<a id=""method-removeTrait""></a>}}
-\subsection{Method \code{removeTrait()}}{
-\subsection{Usage}{
-\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$removeTrait(traits, force = FALSE)}\if{html}{\out{</div>}}
+\if{html}{\out{</div>}}
 }
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
 
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitADEG(10, meanDD=0.5, varGxE=2)
 }
-\if{html}{\out{<hr>}}
-\if{html}{\out{<a id=""method-switchTrait""></a>}}
-\subsection{Method \code{switchTrait()}}{
-\subsection{Usage}{
-\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$switchTrait(lociMap, trait, varA = NULL, varG = NULL, force = FALSE)}\if{html}{\out{</div>}}
+\if{html}{\out{</div>}}
+
 }
 
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-manAddTrait""></a>}}
 \subsection{Method \code{manAddTrait()}}{
+Manually add a new trait to the simulation.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$manAddTrait(
   lociMap,
@@ -445,10 +1198,152 @@ females relative to male}
 )}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{lociMap}}{a new object descended from 
+\code{\link{LociMap-class}}}
+
+\item{\code{varA}}{the value for varA in the base population, optional}
+
+\item{\code{varG}}{the value for varG in the base population, optional}
+
+\item{\code{varE}}{default error variance for phenotype, optional}
+
+\item{\code{force}}{should the check for a running simulation be 
+ignored. Only set to TRUE if you know what you are doing}
+}
+\if{html}{\out{</div>}}
+}
+}
+\if{html}{\out{<hr>}}
+\if{html}{\out{<a id=""method-switchTrait""></a>}}
+\subsection{Method \code{switchTrait()}}{
+Switch a trait in the simulation.
+\subsection{Usage}{
+\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$switchTrait(
+  traitPos,
+  lociMap,
+  varA = NA_real_,
+  varG = NA_real_,
+  varE = NA_real_,
+  force = FALSE
+)}\if{html}{\out{</div>}}
+}
+
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{traitPos}}{an integer indicate which trait to switch}
+
+\item{\code{lociMap}}{a new object descended from 
+\code{\link{LociMap-class}}}
+
+\item{\code{varA}}{the value for varA in the base population, optional}
+
+\item{\code{varG}}{the value for varG in the base population, optional}
+
+\item{\code{varE}}{default error variance for phenotype, optional}
+
+\item{\code{force}}{should the check for a running simulation be 
+ignored. Only set to TRUE if you know what you are doing}
+}
+\if{html}{\out{</div>}}
+}
+}
+\if{html}{\out{<hr>}}
+\if{html}{\out{<a id=""method-removeTrait""></a>}}
+\subsection{Method \code{removeTrait()}}{
+Remove a trait from the simulation
+\subsection{Usage}{
+\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$removeTrait(traits, force = FALSE)}\if{html}{\out{</div>}}
+}
+
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{traits}}{an integer vector indicating which traits to remove}
+
+\item{\code{force}}{should the check for a running simulation be 
+ignored. Only set to TRUE if you know what you are doing}
+}
+\if{html}{\out{</div>}}
+}
+}
+\if{html}{\out{<hr>}}
+\if{html}{\out{<a id=""method-setVarE""></a>}}
+\subsection{Method \code{setVarE()}}{
+Defines a default value for error 
+variances in the simulation.
+\subsection{Usage}{
+\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$setVarE(h2 = NULL, H2 = NULL, varE = NULL)}\if{html}{\out{</div>}}
+}
+
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{h2}}{a vector of desired narrow-sense heritabilities}
+
+\item{\code{H2}}{a vector of desired broad-sense heritabilities}
+
+\item{\code{varE}}{a vector of error variances}
+}
+\if{html}{\out{</div>}}
+}
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$setVarE(h2=0.5)
+}
+\if{html}{\out{</div>}}
+
+}
+
+}
+\if{html}{\out{<hr>}}
+\if{html}{\out{<a id=""method-setCorE""></a>}}
+\subsection{Method \code{setCorE()}}{
+Defines a correlation structure for default 
+error variances. You must call \code{setVarE} first to define 
+the default error variances.
+\subsection{Usage}{
+\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$setCorE(corE)}\if{html}{\out{</div>}}
+}
+
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{corE}}{a correlation matrix for the error variances}
+}
+\if{html}{\out{</div>}}
+}
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10, mean=c(0,0), var=c(1,1), corA=diag(2))
+SP$setVarE(varE=c(1,1))
+E = 0.5*diag(2)+0.5 #Positively correlated error
+SP$setCorE(E)
+}
+\if{html}{\out{</div>}}
+
+}
+
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-rescaleTraits""></a>}}
 \subsection{Method \code{rescaleTraits()}}{
+Linearly scales all traits to achieve desired 
+values of means and variances in the founder population.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$rescaleTraits(
   mean = 0,
@@ -459,62 +1354,197 @@ females relative to male}
 )}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{mean}}{a vector of new trait means}
+
+\item{\code{var}}{a vector of new trait variances}
+
+\item{\code{varEnv}}{a vector of new environmental variances}
+
+\item{\code{varGxE}}{a vector of new GxE variances}
+
+\item{\code{useVarA}}{tune according to additive genetic variance if true}
 }
-\if{html}{\out{<hr>}}
-\if{html}{\out{<a id=""method-switchFounderPop""></a>}}
-\subsection{Method \code{switchFounderPop()}}{
-\subsection{Usage}{
-\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$switchFounderPop(founderPop)}\if{html}{\out{</div>}}
+\if{html}{\out{</div>}}
 }
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
 
+#Create population
+pop = newPop(founderPop, simParam=SP)
+meanG(pop)
+
+#Change mean to 1
+SP$rescaleTraits(mean=1)
+#Run resetPop for change to take effect
+pop = resetPop(pop, simParam=SP) 
+meanG(pop)
 }
-\if{html}{\out{<hr>}}
-\if{html}{\out{<a id=""method-removeFounderPop""></a>}}
-\subsection{Method \code{removeFounderPop()}}{
-\subsection{Usage}{
-\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$removeFounderPop()}\if{html}{\out{</div>}}
+\if{html}{\out{</div>}}
+
 }
 
 }
 \if{html}{\out{<hr>}}
-\if{html}{\out{<a id=""method-addToPed""></a>}}
-\subsection{Method \code{addToPed()}}{
+\if{html}{\out{<a id=""method-setRecombRatio""></a>}}
+\subsection{Method \code{setRecombRatio()}}{
+Set the relative recombination rates between males 
+and females. This allows for gender specific recombination rates, 
+under the assumption of equivalent recombination landscapes.
 \subsection{Usage}{
-\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addToPed(lastId, mother, father, isDH)}\if{html}{\out{</div>}}
+\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$setRecombRatio(femaleRatio)}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{femaleRatio}}{relative ratio of recombination in females compared to 
+males. A value of 2 indicate twice as much recombination in females. The 
+value must be greater than 0. (default is 1)}
 }
-\if{html}{\out{<hr>}}
-\if{html}{\out{<a id=""method-addToRec""></a>}}
-\subsection{Method \code{addToRec()}}{
-\subsection{Usage}{
-\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addToRec(hist)}\if{html}{\out{</div>}}
+\if{html}{\out{</div>}}
+}
+\subsection{Examples}{
+\if{html}{\out{<div class=""r example copy"">}}
+\preformatted{#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$setRecombRatio(2) #Twice as much recombination in females
+}
+\if{html}{\out{</div>}}
+
 }
 
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-switchGenMap""></a>}}
 \subsection{Method \code{switchGenMap()}}{
+Replaces existing genetic map.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$switchGenMap(genMap, centromere = NULL)}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{genMap}}{a list of length nChr containing 
+numeric vectors for the position of each segregating 
+site on a chromosome.}
+
+\item{\code{centromere}}{a numeric vector of centromere 
+positions. If NULL, the centromere are assumed to 
+be metacentric.}
+}
+\if{html}{\out{</div>}}
+}
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-switchFemaleMap""></a>}}
 \subsection{Method \code{switchFemaleMap()}}{
+Replaces existing female genetic map.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$switchFemaleMap(genMap, centromere = NULL)}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{genMap}}{a list of length nChr containing 
+numeric vectors for the position of each segregating 
+site on a chromosome.}
+
+\item{\code{centromere}}{a numeric vector of centromere 
+positions. If NULL, the centromere are assumed to 
+be metacentric.}
+}
+\if{html}{\out{</div>}}
+}
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-switchMaleMap""></a>}}
 \subsection{Method \code{switchMaleMap()}}{
+Replaces existing male genetic map.
 \subsection{Usage}{
 \if{html}{\out{<div class=""r"">}}\preformatted{SimParam$switchMaleMap(genMap, centromere = NULL)}\if{html}{\out{</div>}}
 }
 
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{genMap}}{a list of length nChr containing 
+numeric vectors for the position of each segregating 
+site on a chromosome.}
+
+\item{\code{centromere}}{a numeric vector of centromere 
+positions. If NULL, the centromere are assumed to 
+be metacentric.}
+}
+\if{html}{\out{</div>}}
+}
+}
+\if{html}{\out{<hr>}}
+\if{html}{\out{<a id=""method-addToRec""></a>}}
+\subsection{Method \code{addToRec()}}{
+For internal use only.
+\subsection{Usage}{
+\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addToRec(hist)}\if{html}{\out{</div>}}
+}
+
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{hist}}{new recombination history}
+}
+\if{html}{\out{</div>}}
+}
+}
+\if{html}{\out{<hr>}}
+\if{html}{\out{<a id=""method-updateLastId""></a>}}
+\subsection{Method \code{updateLastId()}}{
+For internal use only.
+\subsection{Usage}{
+\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$updateLastId(lastId)}\if{html}{\out{</div>}}
+}
+
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{lastId}}{last ID assigned}
+}
+\if{html}{\out{</div>}}
+}
+}
+\if{html}{\out{<hr>}}
+\if{html}{\out{<a id=""method-addToPed""></a>}}
+\subsection{Method \code{addToPed()}}{
+For internal use only.
+\subsection{Usage}{
+\if{html}{\out{<div class=""r"">}}\preformatted{SimParam$addToPed(lastId, mother, father, isDH)}\if{html}{\out{</div>}}
+}
+
+\subsection{Arguments}{
+\if{html}{\out{<div class=""arguments"">}}
+\describe{
+\item{\code{lastId}}{ID of last individual}
+
+\item{\code{mother}}{vector of mother IDs}
+
+\item{\code{father}}{vector of father IDs}
+
+\item{\code{isDH}}{vector of DH indicators}
+}
+\if{html}{\out{</div>}}
+}
 }
 \if{html}{\out{<hr>}}
 \if{html}{\out{<a id=""method-clone""></a>}}

---FILE: man/SimParam_addSnpChip.Rd---
@@ -1,31 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_addSnpChip}
-\alias{SimParam_addSnpChip}
-\title{Add SNP chip}
-\arguments{
-\item{nSnpPerChr}{number of SNPs per chromosome. 
-Can be a single value or nChr values.}
-
-\item{minSnpFreq}{minimum allowable frequency for SNP loci.
-If NULL, no minimum frequency is used.}
-
-\item{refPop}{reference population for calculating SNP 
-frequency. If NULL, the founder population is used.}
-}
-\description{
-Randomly assigns eligble SNPs to a SNP chip
-}
-\section{Usage}{
- SP$addSnpChip(nSnpPerChr, minSnpFreq = NULL, refPop = NULL)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$addSnpChip(10)
-
-}

---FILE: man/SimParam_addStructuredSnpChips.Rd---
@@ -1,23 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_addStructuredSnpChips}
-\alias{SimParam_addStructuredSnpChips}
-\title{Add Structured SNP chips}
-\arguments{
-\item{nSnpPerChr}{number of SNPs per chromosome. 
-Can be a single value or nChr values.}
-
-\item{structure}{a matrix.  Rows are snp chips, columns are chips.
-If value is true then that snp is on that chip.}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Randomly selects the number of snps in structure and then
-assigns them to chips based on structure
-}
-\section{Usage}{
- SP$addStructuredSnpChip(nSnpPerChr, structure, force = FALSE)
-}
-

---FILE: man/SimParam_addTraitA.Rd---
@@ -1,40 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_addTraitA}
-\alias{SimParam_addTraitA}
-\title{Add additive traits}
-\arguments{
-\item{nQtlPerChr}{number of QTLs per chromosome. Can be a single value or nChr values.}
-
-\item{mean}{a vector of desired mean genetic values for one or more traits}
-
-\item{var}{a vector of desired genetic variances for one or more traits}
-
-\item{corA}{a matrix of correlations between additive effects}
-
-\item{gamma}{should a gamma distribution be used instead of normal}
-
-\item{shape}{the shape parameter for the gamma distribution}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Randomly assigns eligble QTLs for one or more additive traits. 
-If simulating more than one trait, all traits will be pleiotrophic 
-with correlated additive effects.
-}
-\section{Usage}{
- SP$addTraitA(nQtlPerChr, mean = 0, var = 1, corA = NULL, 
-gamma = FALSE, shape = 1, force = FALSE)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$addTraitA(10)
-
-}

---FILE: man/SimParam_addTraitAD.Rd---
@@ -1,50 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_addTraitAD}
-\alias{SimParam_addTraitAD}
-\title{Add additive and dominance traits}
-\arguments{
-\item{nQtlPerChr}{number of QTLs per chromosome. Can be a single value or nChr values.}
-
-\item{mean}{a vector of desired mean genetic values for one or more traits}
-
-\item{var}{a vector of desired genetic variances for one or more traits}
-
-\item{meanDD}{mean dominance degree}
-
-\item{varDD}{variance of dominance degree}
-
-\item{corA}{a matrix of correlations between additive effects}
-
-\item{corDD}{a matrix of correlations between dominance degrees}
-
-\item{useVarA}{tune according to additive genetic variance if true. If 
-FALSE, tuning is performed according to total genetic variance.}
-
-\item{gamma}{should a gamma distribution be used instead of normal}
-
-\item{shape}{the shape parameter for the gamma distribution}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Randomly assigns eligble QTLs for one or more traits with dominance. 
-If simulating more than one trait, all traits will be pleiotrophic 
-with correlated effects.
-}
-\section{Usage}{
- SP$addTraitAD(nQtlPerChr, mean = 0, var = 1, meanDD = 0, 
-varDD = 0, corA = NULL, corDD = NULL, useVarA = TRUE, gamma = FALSE, 
-shape = 1, force = FALSE)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$addTraitAD(10, meanDD=0.5)
-
-}

---FILE: man/SimParam_addTraitADE.Rd---
@@ -1,55 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_addTraitADE}
-\alias{SimParam_addTraitADE}
-\title{Add additive, dominance and epistasis traits}
-\arguments{
-\item{nQtlPerChr}{number of QTLs per chromosome. Can be a single value or nChr values.}
-
-\item{mean}{a vector of desired mean genetic values for one or more traits}
-
-\item{var}{a vector of desired genetic variances for one or more traits}
-
-\item{meanDD}{mean dominance degree}
-
-\item{varDD}{variance of dominance degree}
-
-\item{relAA}{the relative value of additive-by-additive variance compared 
-to additive variance in a diploid organism with allele frequency 0.5}
-
-\item{corA}{a matrix of correlations between additive effects}
-
-\item{corDD}{a matrix of correlations between dominance degrees}
-
-\item{corAA}{a matrix of correlations between additive-by-additive effects}
-
-\item{useVarA}{tune according to additive genetic variance if true. If 
-FALSE, tuning is performed according to total genetic variance.}
-
-\item{gamma}{should a gamma distribution be used instead of normal}
-
-\item{shape}{the shape parameter for the gamma distribution}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Randomly assigns eligble QTLs for one or more traits with dominance and 
-epistasis. If simulating more than one trait, all traits will be pleiotrophic 
-with correlated effects.
-}
-\section{Usage}{
- SP$addTraitADE(nQtlPerChr, mean = 0, var = 1, meanDD = 0, 
-varDD = 0, relAA = 0, corA = NULL, corDD = NULL, corAA = NULL, useVarA = TRUE, 
-gamma = FALSE, shape = 1, force = FALSE)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$addTraitADE(10)
-
-}

---FILE: man/SimParam_addTraitADEG.Rd---
@@ -1,61 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_addTraitADEG}
-\alias{SimParam_addTraitADEG}
-\title{Add an additive, dominance, and epistasis GxE trait}
-\arguments{
-\item{nQtlPerChr}{number of QTLs per chromosome. Can be a single 
-value or nChr values.}
-
-\item{mean}{a vector of desired mean genetic values for one or more traits}
-
-\item{var}{a vector of desired genetic variances for one or more traits}
-
-\item{varGxE}{a vector of total genotype-by-environment variances for the traits}
-
-\item{varEnv}{a vector of environmental variances for one or more traits}
-
-\item{meanDD}{mean dominance degree}
-
-\item{varDD}{variance of dominance degree}
-
-\item{relAA}{the relative value of additive-by-additive variance compared 
-to additive variance in a diploid organism with allele frequency 0.5}
-
-\item{corA}{a matrix of correlations between additive effects}
-
-\item{corDD}{a matrix of correlations between dominance degrees}
-
-\item{corAA}{a matrix of correlations between additive-by-additive effects}
-
-\item{corGxE}{a matrix of correlations between GxE effects}
-
-\item{useVarA}{tune according to additive genetic variance if true}
-
-\item{gamma}{should a gamma distribution be used instead of normal}
-
-\item{shape}{the shape parameter for the gamma distribution}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Randomly assigns eligble QTLs for a trait with dominance, 
-epistasis and GxE.
-}
-\section{Usage}{
- SP$addTraitADEG(nQtlPerChr, mean = 0, var = 1, varGxE = 1e-6, 
-varEnv = 0, meanDD = 0, varDD = 0, relAA = 0, corA = NULL, corDD = NULL, 
-corAA = NULL, corGxE = NULL, useVarA = TRUE, gamma = FALSE, shape = 1, 
-force = FALSE)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$addTraitADEG(10, meanDD=0.5, varGxE=2)
-
-}

---FILE: man/SimParam_addTraitADG.Rd---
@@ -1,54 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_addTraitADG}
-\alias{SimParam_addTraitADG}
-\title{Add an additive and dominance GxE trait}
-\arguments{
-\item{nQtlPerChr}{number of QTLs per chromosome. Can be a single 
-value or nChr values.}
-
-\item{mean}{a vector of desired mean genetic values for one or more traits}
-
-\item{var}{a vector of desired genetic variances for one or more traits}
-
-\item{varGxE}{a vector of total genotype-by-environment variances for the traits}
-
-\item{varEnv}{a vector of environmental variances for one or more traits}
-
-\item{meanDD}{mean dominance degree}
-
-\item{varDD}{variance of dominance degree}
-
-\item{corA}{a matrix of correlations between additive effects}
-
-\item{corDD}{a matrix of correlations between dominance degrees}
-
-\item{corGxE}{a matrix of correlations between GxE effects}
-
-\item{useVarA}{tune according to additive genetic variance if true}
-
-\item{gamma}{should a gamma distribution be used instead of normal}
-
-\item{shape}{the shape parameter for the gamma distribution}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Randomly assigns eligble QTLs for a trait with dominance and GxE.
-}
-\section{Usage}{
- SP$addTraitADG(nQtlPerChr, mean = 0, var = 1, varGxE = 1e-6, 
-varEnv = 0, meanDD = 0, varDD = 0, corA = NULL, corDD = NULL, 
-corGxE = NULL, useVarA = TRUE, gamma = FALSE, shape = 1, force = FALSE)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$addTraitADG(10, meanDD=0.5, varGxE=2)
-
-}

---FILE: man/SimParam_addTraitAE.Rd---
@@ -1,48 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_addTraitAE}
-\alias{SimParam_addTraitAE}
-\title{Add additive and epistasis traits}
-\arguments{
-\item{nQtlPerChr}{number of QTLs per chromosome. Can be a single value or nChr values.}
-
-\item{mean}{a vector of desired mean genetic values for one or more traits}
-
-\item{var}{a vector of desired genetic variances for one or more traits}
-
-\item{relAA}{the relative value of additive-by-additive variance compared 
-to additive variance in a diploid organism with allele frequency 0.5}
-
-\item{corA}{a matrix of correlations between additive effects}
-
-\item{corAA}{a matrix of correlations between additive-by-additive effects}
-
-\item{useVarA}{tune according to additive genetic variance if true. If 
-FALSE, tuning is performed according to total genetic variance.}
-
-\item{gamma}{should a gamma distribution be used instead of normal}
-
-\item{shape}{the shape parameter for the gamma distribution}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Randomly assigns eligble QTLs for one or more additive and epistasis 
-traits. If simulating more than one trait, all traits will be pleiotrophic 
-with correlated additive effects.
-}
-\section{Usage}{
- SP$addTraitAA(nQtlPerChr, mean = 0, var = 1, relAA = 0, corA = NULL, 
-corAA = NULL, gamma = FALSE, shape = 1, force = FALSE)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$addTraitAE(10)
-
-}

---FILE: man/SimParam_addTraitAEG.Rd---
@@ -1,55 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_addTraitAEG}
-\alias{SimParam_addTraitAEG}
-\title{Add additive and epistasis GxE traits}
-\arguments{
-\item{nQtlPerChr}{number of QTLs per chromosome. Can be a single value or nChr values.}
-
-\item{mean}{a vector of desired mean genetic values for one or more traits}
-
-\item{var}{a vector of desired genetic variances for one or more traits}
-
-\item{relAA}{the relative value of additive-by-additive variance compared 
-to additive variance in a diploid organism with allele frequency 0.5}
-
-\item{varGxE}{a vector of total genotype-by-environment variances for the traits}
-
-\item{varEnv}{a vector of environmental variances for one or more traits}
-
-\item{corA}{a matrix of correlations between additive effects}
-
-\item{corAA}{a matrix of correlations between additive-by-additive effects}
-
-\item{corGxE}{a matrix of correlations between GxE effects}
-
-\item{useVarA}{tune according to additive genetic variance if true. If 
-FALSE, tuning is performed according to total genetic variance.}
-
-\item{gamma}{should a gamma distribution be used instead of normal}
-
-\item{shape}{the shape parameter for the gamma distribution}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Randomly assigns eligble QTLs for one or more additive and epistasis 
-GxE traits. If simulating more than one trait, all traits will be pleiotrophic 
-with correlated effects.
-}
-\section{Usage}{
- SP$addTraitAG(nQtlPerChr, mean = 0, var = 1, relAA = 0, varGxE = 1e-6, 
-varEnv = 0, corA = NULL, corAA = NULL, corGxE = NULL, useVarA = TRUE, gamma = FALSE, 
-shape = 1)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$addTraitAEG(10, varGxE=2)
-
-}

---FILE: man/SimParam_addTraitAG.Rd---
@@ -1,46 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_addTraitAG}
-\alias{SimParam_addTraitAG}
-\title{Add additive GxE traits}
-\arguments{
-\item{nQtlPerChr}{number of QTLs per chromosome. Can be a single value or nChr values.}
-
-\item{mean}{a vector of desired mean genetic values for one or more traits}
-
-\item{var}{a vector of desired genetic variances for one or more traits}
-
-\item{varGxE}{a vector of total genotype-by-environment variances for the traits}
-
-\item{varEnv}{a vector of environmental variances for one or more traits}
-
-\item{corA}{a matrix of correlations between additive effects}
-
-\item{corGxE}{a matrix of correlations between GxE effects}
-
-\item{gamma}{should a gamma distribution be used instead of normal}
-
-\item{shape}{the shape parameter for the gamma distribution}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Randomly assigns eligble QTLs for one ore more additive GxE traits. 
-If simulating more than one trait, all traits will be pleiotrophic 
-with correlated effects.
-}
-\section{Usage}{
- SP$addTraitAG(nQtlPerChr, mean = 0, var = 1, varGxE = 1e-6, 
-varEnv = 0, corA = NULL, corGxE = NULL, gamma = FALSE, shape = 1)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$addTraitAG(10, varGxE=2)
-
-}

---FILE: man/SimParam_manAddSnpChip.Rd---
@@ -1,18 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_manAddSnpChip}
-\alias{SimParam_manAddSnpChip}
-\title{Manually add SNP chip}
-\arguments{
-\item{lociMap}{a new \code{\link{LociMap-class}}}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Adds a new \code{\link{LociMap-class}} for a SNP chip.
-}
-\section{Usage}{
- SP$manAddSnpChips(lociMap, force = FALSE)
-}
-

---FILE: man/SimParam_manAddTrait.Rd---
@@ -1,26 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_manAddTrait}
-\alias{SimParam_manAddTrait}
-\title{Manually add trait}
-\arguments{
-\item{lociMap}{a new object descended from 
-\code{\link{LociMap-class}}}
-
-\item{varA}{the value for varA in the base population, optional}
-
-\item{varG}{the value for varG in the base population, optional}
-
-\item{varE}{default error variance for phenotype, optional}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing}
-}
-\description{
-Add a new trait to the simulation.
-}
-\section{Usage}{
- SP$manAddTrait(lociMap, varA = NA_real_, varG = NA_real_, 
-varE = NA_real_, force = FALSE)
-}
-

---FILE: man/SimParam_new.Rd---
@@ -1,30 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_new}
-\alias{SimParam_new}
-\title{Create new simulation}
-\arguments{
-\item{founderPop}{an object of \code{\link{MapPop-class}}}
-}
-\description{
-Starts the process of building a new simulation 
-by creating a new SimParam object and assigning a founder 
-population to the class. It is recommended that you save the 
-object with the name ""SP"", because subsequent functions will 
-check your global enviroment for an object of this name if 
-their simParam arguments are NULL. This allows you to call 
-these functions without explicitly supplying a simParam 
-argument with every call.
-}
-\section{Usage}{
- SimParam$new(founderPop)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-
-}

---FILE: man/SimParam_removeFounderPop.Rd---
@@ -1,14 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_removeFounderPop}
-\alias{SimParam_removeFounderPop}
-\title{Remove founder population}
-\description{
-Removes the founder population from the founderPop 
-field. This can be ran after all traits have been 
-added to reduce the size of the SimParam object.
-}
-\section{Usage}{
- SP$removeFounderPop()
-}
-

---FILE: man/SimParam_removeSnpChip.Rd---
@@ -1,30 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_removeSnpChip}
-\alias{SimParam_removeSnpChip}
-\title{Remove SNP chip}
-\arguments{
-\item{chips}{a vector of SNP chips to remove}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Removes designated SNP chip(s).
-}
-\section{Usage}{
- SP$removeSnpChip(chips, force = FALSE)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$addSnpChip(10)
-SP$nSnpChips
-SP$removeSnpChip(1)
-SP$nSnpChips
-
-}

---FILE: man/SimParam_removeTrait.Rd---
@@ -1,31 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_removeTrait}
-\alias{SimParam_removeTrait}
-\title{Remove trait}
-\arguments{
-\item{traits}{a vector of traits to remove}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Removes designated trait(s).
-}
-\section{Usage}{
- SP$removeTrait(traits, force = FALSE)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$addTraitA(10)
-SP$nTraits
-SP$removeTrait(1)
-SP$nTraits
-
-
-}

---FILE: man/SimParam_rescaleTraits.Rd---
@@ -1,51 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_rescaleTraits}
-\alias{SimParam_rescaleTraits}
-\title{Rescale traits}
-\arguments{
-\item{mean}{a vector of new trait means}
-
-\item{var}{a vector of new trait variances}
-
-\item{varEnv}{a vector of new environmental variances}
-
-\item{varGxE}{a vector of new GxE variances}
-
-\item{useVarA}{tune according to additive genetic variance if true}
-}
-\description{
-Linearly scales all traits to achieve desired 
-values of means and variances in the founder population.
-}
-\note{
-By default the founder population is the population used to 
-initalize the SimParam object. This population can be changed using 
-the switchFounderPop function in the SimParam object 
-(see \code{\link{SimParam_switchFounderPop}}). You must run 
-\code{\link{resetPop}} on existing populations to obtain the new trait values.
-}
-\section{Usage}{
- SP$rescaleTraits(mean = 0, var = 1, relAA = 1e-6,
-varEnv = 0, varGxE = 1e-6, useVarA = TRUE)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$addTraitA(10)
-
-#Create population
-pop = newPop(founderPop, simParam=SP)
-meanG(pop)
-
-#Change mean to 1
-SP$rescaleTraits(mean=1)
-#Run resetPop for change to take effect
-pop = resetPop(pop, simParam=SP) 
-meanG(pop)
-
-}

---FILE: man/SimParam_resetPed.Rd---
@@ -1,36 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_resetPed}
-\alias{SimParam_resetPed}
-\title{Reset pedigree}
-\arguments{
-\item{lastId}{last ID to include in pedigree}
-}
-\description{
-Resets the internal lastId, the pedigree 
-and recombination tracking, if it is being used, to the 
-supplied lastId. Be careful using this function because 
-it may introduce bug if you supsequently use individuals 
-that come from a portion the pedigree that is being reset.
-}
-\section{Usage}{
- SP$resetPed(lastId = 0L)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-
-#Create population
-pop = newPop(founderPop, simParam=SP)
-pop@id # 1:10
-
-#Create another population after reseting pedigree
-SP$resetPed()
-pop2 = newPop(founderPop, simParam=SP)
-pop2@id # 1:10
-
-}

---FILE: man/SimParam_restrSegSites.Rd---
@@ -1,40 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_restrSegSites}
-\alias{SimParam_restrSegSites}
-\title{Restrict segregating sites}
-\arguments{
-\item{maxQtl}{the maximum number of segSites for QTLs. 
-Can be a single value or a vector values for each 
-chromosome.}
-
-\item{maxSnp}{the maximum number of segSites for SNPs. 
-Can be a single value or a vector values for each 
-chromosome.}
-
-\item{overlap}{should SNP and QTL sites be allowed to overlap.}
-
-\item{minSnpFreq}{minimum allowable frequency for SNP loci. 
-No minimum SNP frequency is used if value is NULL.}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Sets restrictions on which segregating sites 
-can serve as SNP and/or QTL.
-}
-\section{Usage}{
- SP$restrSegSites(maxQtl = 0, maxSnp = 0, 
-snpQtlOverlap = FALSE, minSnpFreq = NULL, force = FALSE)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$restrSegSites(maxQtl=5, maxSnp=5)
-
-}

---FILE: man/SimParam_setCorE.Rd---
@@ -1,29 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_setCorE}
-\alias{SimParam_setCorE}
-\title{Set correlated error variance}
-\arguments{
-\item{corE}{a correlation matrix for the error variances}
-}
-\description{
-Defines a correlation structure for default 
-error variances. You must call \code{\link{SimParam_setVarE}} 
-first to define the default error variances.
-}
-\section{Usage}{
- SP$setCorE(corE)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$addTraitA(10, mean=c(0,0), var=c(1,1), corA=diag(2))
-SP$setVarE(varE=c(1,1))
-E = 0.5*diag(2)+0.5 #Positively correlated error
-SP$setCorE(E)
-
-}

---FILE: man/SimParam_setGender.Rd---
@@ -1,35 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_setGender}
-\alias{SimParam_setGender}
-\title{Set gender in simulation}
-\arguments{
-\item{gender}{acceptable value are ""no"", ""yes_sys"", or 
-""yes_rand""}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Changes how gender is used in the simulation. 
-The default gender of a simulation is ""no"". To add gender 
-to the simulation, run this function with ""yes_sys"" or 
-""yes_rand"". The value ""yes_sys"" will systematically assign 
-gender to newly created individuals as first male, then female. 
-Thus, odd numbers of individuals will have one more male than 
-female. The value ""yes_rand"" will randomly assign gender to 
-individuals.
-}
-\section{Usage}{
- SP$setGender(gender, force = FALSE)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$setGender(""yes_sys"")
-
-}

---FILE: man/SimParam_setMeiosis.Rd---
@@ -1,45 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_setMeiosis}
-\alias{SimParam_setMeiosis}
-\title{Set meiosis parameters}
-\arguments{
-\item{v}{the crossover interference parameter for a gamma model of 
-recombination. A value of 1 indicates no crossover interference 
-(e.g. Haldane mapping function). A value of 2.65 approximates the 
-degree of crossover interference implied by the Kosambi mapping 
-function. (default is 1)}
-
-\item{ratio}{relative ratio of recombination in females compared to 
-males. A value of 2 indicate twice as much recombination in females 
-and a value of 1/2 would indicate half as much recombinations. The 
-value must be greater than 0. (default is 1)}
-
-\item{quadProb}{the probability of quadrivalent pairing in an 
-autopolyploid. A value of 2/3 equals the probability expected under 
-random pairing of telomeres in a tetraploid. (default is 0)}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Changes parameters defining the amount of crossover 
-interference, the gender specific recombination ratio, or the 
-probability of quadrivalent pairing in autopolyploids. Parameters 
-are only changed if specified by the user. The default values for the 
-parameters are indicated in descriptions below.
-}
-\section{Usage}{
- SP$setMeiosis(v = NULL, ratio = NULL, quadProb = NULL, 
-force = FALSE)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$setMeiosis(ratio=2) #Twice as much recombination in females
-
-}

---FILE: man/SimParam_setTrackPed.Rd---
@@ -1,32 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_setTrackPed}
-\alias{SimParam_setTrackPed}
-\title{Set pedigree tracking}
-\arguments{
-\item{isTrackPed}{should pedigree tracking be on.}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Sets pedigree tracking for the simulation. 
-By default pedigree tracking is turned off. When turned on, 
-the pedigree of all individuals created will be tracked, 
-except those created by \code{\link{hybridCross}}. Turning 
-off pedigree tracking will turn off recombination tracking 
-if it is turned on.
-}
-\section{Usage}{
- SP$setTrackPed(isTrackPed, force = FALSE)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$setTrackPed(TRUE)
-
-}

---FILE: man/SimParam_setTrackRec.Rd---
@@ -1,32 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_setTrackRec}
-\alias{SimParam_setTrackRec}
-\title{Set recombination tracking}
-\arguments{
-\item{isTrackRec}{should recombination tracking be on.}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Sets recombination tracking for the simulation. 
-By default recombination tracking is turned off. When turned 
-on recombination tracking will also turn on pedigree tracking. 
-Recombination tracking keeps records of all individuals created, 
-except those created by \code{\link{hybridCross}}, because their 
-pedigree is not tracked.
-}
-\section{Usage}{
- SimParam$setTrackRec(isTrackRec, force = FALSE)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$setTrackRec(TRUE)
-
-}

---FILE: man/SimParam_setVarE.Rd---
@@ -1,30 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_setVarE}
-\alias{SimParam_setVarE}
-\title{Set simulation error variance}
-\arguments{
-\item{h2}{a vector of desired narrow-sense heritabilities}
-
-\item{H2}{a vector of desired broad-sense heritabilities}
-
-\item{varE}{a vector of error variances}
-}
-\description{
-Defines a default value for error 
-variances in the simulation.
-}
-\section{Usage}{
- SP$setVarE(h2 = NULL, H2 = NULL, varE = NULL)
-}
-
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$addTraitA(10)
-SP$setVarE(h2=0.5)
-
-}

---FILE: man/SimParam_switchFemaleMap.Rd---
@@ -1,21 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_switchFemaleMap}
-\alias{SimParam_switchFemaleMap}
-\title{Switch female genetic map}
-\arguments{
-\item{genMap}{a list of length nChr containing 
-numeric vectors for the position of each segregating 
-site on a chromosome.}
-
-\item{centromere}{a numeric vector of centromere 
-positions. If NULL, the centromere are assumed to 
-be metacentric.}
-}
-\description{
-Replaces existing female genetic map.
-}
-\section{Usage}{
- SP$switchFemaleMap(genMap)
-}
-

---FILE: man/SimParam_switchFounderPop.Rd---
@@ -1,18 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_switchFounderPop}
-\alias{SimParam_switchFounderPop}
-\title{Switch founder population}
-\description{
-Switches the founder population in the founderPop 
-field. This may be desirable if traits are to be 
-tuned to a population derived from the original 
-founderPop. Note that no checking is performed to verify 
-that the genetic map and/or number of segregating sites 
-hasn't changed. The new founderPop can be 
-\code{\link{MapPop-class}} or \code{\link{RawPop-class}}
-}
-\section{Usage}{
- SP$switchFounderPop(founderPop)
-}
-

---FILE: man/SimParam_switchGenMap.Rd---
@@ -1,21 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_switchGenMap}
-\alias{SimParam_switchGenMap}
-\title{Switch genetic map}
-\arguments{
-\item{genMap}{a list of length nChr containing 
-numeric vectors for the position of each segregating 
-site on a chromosome.}
-
-\item{centromere}{a numeric vector of centromere 
-positions. If NULL, the centromere are assumed to 
-be metacentric.}
-}
-\description{
-Replaces existing genetic map.
-}
-\section{Usage}{
- SP$switchGenMap(genMap)
-}
-

---FILE: man/SimParam_switchMaleMap.Rd---
@@ -1,21 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_switchMaleMap}
-\alias{SimParam_switchMaleMap}
-\title{Switch male genetic map}
-\arguments{
-\item{genMap}{a list of length nChr containing 
-numeric vectors for the position of each segregating 
-site on a chromosome.}
-
-\item{centromere}{a numeric vector of centromere 
-positions. If NULL, the centromere are assumed to 
-be metacentric.}
-}
-\description{
-Replaces existing male genetic map.
-}
-\section{Usage}{
- SP$switchMaleMap(genMap)
-}
-

---FILE: man/SimParam_switchSnpChip.Rd---
@@ -1,20 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_switchSnpChip}
-\alias{SimParam_switchSnpChip}
-\title{Switch SNP chip}
-\arguments{
-\item{lociMap}{a new \code{\link{LociMap-class}}}
-
-\item{chip}{an integer indicating which chip to replace}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Replaces the \code{\link{LociMap-class}} for a SNP chip.
-}
-\section{Usage}{
- SP$switchSnpChips(lociMap, chip, force = FALSE)
-}
-

---FILE: man/SimParam_switchTrait.Rd---
@@ -1,28 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_switchTrait}
-\alias{SimParam_switchTrait}
-\title{Switch trait}
-\arguments{
-\item{lociMap}{a new object descended from 
-\code{\link{LociMap-class}}}
-
-\item{trait}{an integer indicating which trait to replace}
-
-\item{varA}{a new value for varA in the base population. 
-If NULL, the existing value is retained.}
-
-\item{varG}{a new value for varG in the base population. 
-If NULL, the existing value is retained.}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Replaces an existing trait.
-}
-\section{Usage}{
- SP$switchTrait(lociMap, trait, varA = NULL, varG = NULL, 
-force = FALSE)
-}
-

---FILE: man/fastRRBLUP.Rd---
@@ -56,7 +56,7 @@ than the intercept) or account for unequal replication.
 }
 \examples{
 #Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)

---FILE: man/h2.Rd---
@@ -1,30 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/popSummary.R
-\name{H2}
-\alias{H2}
-\title{Broad-sense heritability}
-\usage{
-H2(pop)
-}
-\arguments{
-\item{pop}{an object of \code{\link{Pop-class}}}
-
-\item{simParam}{an object of \code{\link{SimParam}}}
-}
-\description{
-Returns broad-sense heritability for all traits
-}
-\examples{
-#Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
-
-#Set simulation parameters
-SP = SimParam$new(founderPop)
-SP$addTraitAD(10, meanDD=0.5)
-SP$setVarE(h2=0.5)
-
-#Create population
-pop = newPop(founderPop, simParam=SP)
-H2(pop)
-
-}

---FILE: man/makeCross.Rd---
@@ -4,7 +4,7 @@
 \alias{makeCross}
 \title{Make designed crosses}
 \usage{
-makeCross(pop, crossPlan, simParam = NULL)
+makeCross(pop, crossPlan, nProgeny = 1, simParam = NULL)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}}}
@@ -13,6 +13,8 @@ makeCross(pop, crossPlan, simParam = NULL)
 female and male parents. Either integers for the position in 
 population or character strings for the IDs.}
 
+\item{nProgeny}{number of progeny per cross}
+
 \item{simParam}{an object of \code{\link{SimParam}}}
 }
 \value{

---FILE: man/makeCross2.Rd---
@@ -4,7 +4,7 @@
 \alias{makeCross2}
 \title{Make designed crosses}
 \usage{
-makeCross2(females, males, crossPlan, simParam = NULL)
+makeCross2(females, males, crossPlan, nProgeny = 1, simParam = NULL)
 }
 \arguments{
 \item{females}{an object of \code{\link{Pop-class}} for female parents.}
@@ -15,6 +15,8 @@ makeCross2(females, males, crossPlan, simParam = NULL)
 female and male parents. Either integers for the position in 
 population or character strings for the IDs.}
 
+\item{nProgeny}{number of progeny per cross}
+
 \item{simParam}{an object of \code{\link{SimParam}}}
 }
 \value{

---FILE: man/mergeGenome.Rd---
@@ -0,0 +1,42 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/polyploids.R
+\name{mergeGenome}
+\alias{mergeGenome}
+\title{Combine genomes of individuals}
+\usage{
+mergeGenome(females, males, crossPlan, simParam = NULL)
+}
+\arguments{
+\item{females}{an object of \code{\link{Pop-class}} for female parents.}
+
+\item{males}{an object of \code{\link{Pop-class}} for male parents.}
+
+\item{crossPlan}{a matrix with two column representing
+female and male parents. Either integers for the position in
+population or character strings for the IDs.}
+
+\item{simParam}{an object of \code{\link{SimParam}}}
+}
+\value{
+Returns an object of \code{\link{Pop-class}}
+}
+\description{
+This function is designed to model the pairing of gametes. The male
+and female individuals are treated as gametes, so the ploidy of newly 
+created individuals will be the sum of it parents.
+}
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Cross individual 1 with individual 10
+crossPlan = matrix(c(1,10), nrow=1, ncol=2)
+pop2 = mergeGenome(pop, pop, crossPlan, simParam=SP)
+
+}

---FILE: man/pullIbdHaplo.Rd---
@@ -27,10 +27,10 @@ are retrieved. If NULL, all sites are retrieved.}
 
 \item{pedigree}{a matrix with ancestral pedigree to set a base
 population. It should be of the same form as \code{simParam$pedigree} 
-(see \code{\link{SimParam_setTrackPed}}), i.e., two columns (mother
-and father) and the same number of rows as \code{simParam$pedigree}.
-Base population can be set by setting parents as 0. If NULL, pedigree
-from \code{\link{SimParam}} is taken.}
+(see \code{setTrackPed} in \code{\link{SimParam}}), i.e., two columns 
+(mother and father) and the same number of rows as 
+\code{simParam$pedigree}.Base population can be set by setting 
+parents as 0. If NULL, pedigree from \code{\link{SimParam}} is taken.}
 
 \item{simParam}{an object of \code{\link{SimParam}}}
 }
@@ -44,7 +44,7 @@ Retrieves Identity By Descent (IBD) haplotype data
 }
 \examples{
 #Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)

---FILE: man/pullQtlGeno.Rd---
@@ -80,7 +80,7 @@ pullMultipleSnpGeno = function(pop, chips,
 }
 \examples{
 #Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)

---FILE: man/pullQtlHaplo.Rd---
@@ -113,7 +113,7 @@ pullMultipleSnpHaplo = function(pop, chips, haplo=""all"",
 }
 \examples{
 #Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)

---FILE: man/pullSegSiteGeno.Rd---
@@ -23,7 +23,7 @@ Retrieves genotype data for all segregating sites
 }
 \examples{
 #Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)

---FILE: man/pullSegSiteHaplo.Rd---
@@ -27,7 +27,7 @@ Retrieves haplotype data for all segregating sites
 }
 \examples{
 #Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)

---FILE: man/pullSnpGeno.Rd---
@@ -25,7 +25,7 @@ Retrieves SNP genotype data
 }
 \examples{
 #Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)

---FILE: man/pullSnpHaplo.Rd---
@@ -29,7 +29,7 @@ Retrieves SNP haplotype data
 }
 \examples{
 #Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=15)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)

---FILE: man/reduceGenome.Rd---
@@ -9,6 +9,7 @@ reduceGenome(
   nProgeny = 1,
   useFemale = TRUE,
   keepParents = TRUE,
+  simRecomb = TRUE,
   simParam = NULL
 )
 }
@@ -22,6 +23,8 @@ reduceGenome(
 \item{keepParents}{should previous parents be used for mother and 
 father.}
 
+\item{simRecomb}{should genetic recombination be modeled.}
+
 \item{simParam}{an object of 'SimParam' class}
 }
 \value{
@@ -32,8 +35,8 @@ Creates new individuals from gametes. This function
 was created to model the creation of diploid potatoes from 
 tetraploid potatoes. It can be used on any population with an 
 even ploidy level. The newly created individuals will have half 
-the ploidy level of the originals and they will first undergo
-a single round of meiosis.
+the ploidy level of the originals. The reduction can occur with 
+or without genetic recombination.
 }
 \examples{
 #Create founder haplotypes

---FILE: man/setEBV.Rd---
@@ -45,7 +45,7 @@ estimated general combining values.
 }
 \examples{
 #Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=20)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)

---FILE: src/getGeno.cpp---
@@ -5,7 +5,7 @@
  * Genotype data is stored in a field of cubes.
  * The field has length equal to nChr
  * Each cube has dimensions nLoci/8 by ploidy by nInd
- * Output return with dimensions nInd by nLoci
+ * Output returned with dimensions nInd by nLoci
  */
 // [[Rcpp::export]]
 arma::Mat<unsigned char> getGeno(const arma::field<arma::Cube<unsigned char> >& geno, 

---FILE: src/getGv.cpp---
@@ -1,7 +1,7 @@
 // [[Rcpp::depends(RcppArmadillo)]]
 #include ""alphasimr.h""
 
-// Calculates genetic values for genomic predictions use parental origin
+// Calculates genetic values for genomic predictions using parental origin
 arma::field<arma::vec> getGvA2(const Rcpp::S4& trait, 
                                const Rcpp::S4& pop, 
                                int nThreads){

---FILE: src/meiosis.cpp---
@@ -1,24 +1,32 @@
 // [[Rcpp::depends(RcppArmadillo)]]
 #include ""alphasimr.h""
 
+// Class for storing recombination history
 class RecHist{
 public:
   arma::field< //individual
     arma::field< //chromosome
       arma::field< //ploidy
         arma::Mat<int> > > > hist; //(chr, site)
+  
+  // Allocates space for history
   void setSize(arma::uword nInd, 
                arma::uword nChr, 
                arma::uword ploidy);
+  
+  // Append new recombinations to history
   void addHist(arma::Mat<int>& input, 
                arma::uword nInd, 
                arma::uword chrGroup,
                arma::uword chrInd);
+  
+  // Access history
   arma::Mat<int> getHist(arma::uword ind, 
                          arma::uword chr,
                          arma::uword par);
 };
 
+// Allocates space for history
 void RecHist::setSize(arma::uword nInd, 
                       arma::uword nChr, 
                       arma::uword ploidy=2){
@@ -31,13 +39,15 @@ void RecHist::setSize(arma::uword nInd,
   }
 }
 
+// Append new recombinations to history
 void RecHist::addHist(arma::Mat<int>& input, 
              arma::uword nInd, 
              arma::uword chrGroup,
              arma::uword chrInd){
   hist(nInd)(chrGroup)(chrInd) = input;
 }
 
+// Access history
 arma::Mat<int> RecHist::getHist(arma::uword ind, 
                                 arma::uword chr,
                                 arma::uword par){
@@ -53,16 +63,20 @@ arma::vec sampleChiasmata(double start, double end, double v,
                           arma::uword n=40){
   // Sample deviates from a gamma distribution
   arma::vec output = arma::randg<arma::vec>(n, arma::distr_param(v,0.5/v));
+  
   // Find locations on genetic map
   output = cumsum(output)+start;
+  
   // Add additional values if max position less than end
   while(output(output.n_elem-1)<end){
     arma::vec tmp = arma::randg<arma::vec>(n, arma::distr_param(v,0.5/v));
     tmp = cumsum(tmp) + output(output.n_elem-1);
     output = join_cols(output, tmp);
   }
+  
   // Remove values less than 0
   output = output(find(output>0));
+  
   // Return values less than the end
   return output(find(output<end));
 }
@@ -150,16 +164,19 @@ arma::uword intervalSearch(const arma::vec& x, double& value, arma::uword left=0
     Rcpp::stop(""intervalSearch searching in impossible interval"");
   }
   arma::uword end = x.n_elem-1;
+  
   // Check if crossover is at or past end
   if(x[end]<=value){
     return end;
   }
+  
   // Perform search
   arma::uword right = end;
   while((right-left)>1){ // Interval can be decreased
     arma::uword middle = (left + right) / 2;
     if (x[middle] == value){
       left = middle;
+      
       // Check if at the end of the vector
       if(left<end){
         // Check for identical values to the right
@@ -188,15 +205,18 @@ arma::Mat<int> removeDoubleCO(const arma::Mat<int>& X){
   if(X.n_rows<3){
     return X;
   }
+  
   // Initially assume all rows are useful
   arma::Col<int> take(X.n_rows,arma::fill::ones);
+  
   // Remove unobserved crossovers (site doesn't change)
   // Works backwards, because the last crossover is observed
   for(arma::uword i=(X.n_rows-2); i>0; --i){
     if(X(i,1) == X(i+1,1)){
       take(i) = 0;
     }
   }
+  
   // Remove redundant records (chromosome doesn't change)
   int lastChr = X(0,0);
   for(arma::uword i=1; i<X.n_rows; ++i){
@@ -707,6 +727,7 @@ void bivalent(const arma::Col<unsigned char>& chr1,
     output = chr1;
   }else{
     int nBins = chr1.n_elem;
+    
     // Fill-in based on recombination history
     for(arma::uword i=0; i<(hist.n_rows-1); ++i){
       switch(hist(i,0)){
@@ -719,6 +740,7 @@ void bivalent(const arma::Col<unsigned char>& chr1,
                      hist(i,1), hist(i+1,1));
       }
     }
+    
     // Fill-in last sites
     switch(hist(hist.n_rows-1,0)){
     case 1:
@@ -790,6 +812,7 @@ void quadrivalent(const arma::Col<unsigned char>& chr1,
                      hist1(i,1), hist1(i+1,1));
       }
     }
+    
     // Fill-in last sites
     switch(hist1(hist1.n_rows-1,0)){
     case 1:
@@ -850,6 +873,7 @@ void quadrivalent(const arma::Col<unsigned char>& chr1,
                      hist2(i,1), hist2(i+1,1));
       }
     }
+    
     // Fill-in last sites
     switch(hist2(hist2.n_rows-1,0)){
     case 1:
@@ -932,10 +956,12 @@ Rcpp::List cross(
     arma::uword nBins = motherGeno(chr).n_rows;
     arma::Cube<unsigned char> tmpGeno(nBins,ploidy,nInd);
     arma::Col<unsigned char> gamete1(nBins), gamete2(nBins);
+    
     //Loop through individuals
     for(arma::uword ind=0; ind<nInd; ++ind){
       progenyChr=0;
       xm = shuffle(xm);
+      
       //Female gamete
       for(arma::uword x=0; x<motherPloidy; x+=4){
         if((motherPloidy-x)>2){
@@ -956,6 +982,7 @@ Rcpp::List cross(
               hist.addHist(hist1,ind,chr,progenyChr);
             }
             ++progenyChr;
+            
             //Bivalent 2
             bivalent(motherGeno(chr).slice(mother(ind)).col(xm(x+2)),
                      motherGeno(chr).slice(mother(ind)).col(xm(x+3)),
@@ -1038,6 +1065,7 @@ Rcpp::List cross(
               hist.addHist(hist1,ind,chr,progenyChr);
             }
             ++progenyChr;
+            
             //Bivalent 2
             bivalent(fatherGeno(chr).slice(father(ind)).col(xf(x+2)),
                      fatherGeno(chr).slice(father(ind)).col(xf(x+3)),
@@ -1210,6 +1238,7 @@ Rcpp::List createReducedGenome(
               hist.addHist(hist1,ind,chr,progenyChr);
             }
             ++progenyChr;
+            
             //Bivalent 2
             bivalent(geno(chr).slice(par).col(x(y+2)),
                      geno(chr).slice(par).col(x(y+3)),

---FILE: src/packHaplo.cpp---
@@ -26,6 +26,7 @@ arma::Cube<unsigned char> packHaplo(arma::Mat<unsigned char>& haplo,
     if(inbred){
       for(chr=0; chr<ploidy; ++chr){
         locus = 0;
+        
         // Fill in bins known to be complete
         if(nBins > 1){
           for(arma::uword j=0; j<(nBins-1); ++j){
@@ -37,6 +38,7 @@ arma::Cube<unsigned char> packHaplo(arma::Mat<unsigned char>& haplo,
               toByte(workBits);
           }
         }
+        
         // Fill in potentially incomplete bins
         for(arma::uword k=0; k<8; ++k){
           if(locus<nLoci){
@@ -51,6 +53,7 @@ arma::Cube<unsigned char> packHaplo(arma::Mat<unsigned char>& haplo,
       }
     }else{
       locus = 0;
+      
       // Fill in bins known to be complete
       if(nBins > 1){
         for(arma::uword j=0; j<(nBins-1); ++j){
@@ -62,6 +65,7 @@ arma::Cube<unsigned char> packHaplo(arma::Mat<unsigned char>& haplo,
             toByte(workBits);
         }
       }
+      
       // Fill in potentially incomplete bins
       for(arma::uword k=0; k<8; ++k){
         if(locus<nLoci){

---FILE: tests/testthat/test-addTrait.R---
@@ -19,9 +19,9 @@ test_that(""addTraitA"",{
   expect_equal(c(ans$varA),1,tolerance=1e-6)
   expect_equal(c(ans$varD),0,tolerance=1e-6)
   expect_equal(c(ans$varG),1,tolerance=1e-6)
-  expect_equal(ans$genicVarA,1,tolerance=1e-6)
+  expect_equal(ans$genicVarA,0.5,tolerance=1e-6)
   expect_equal(ans$genicVarD,0,tolerance=1e-6)
-  expect_equal(ans$genicVarG,1,tolerance=1e-6)
+  expect_equal(ans$genicVarG,0.5,tolerance=1e-6)
 })
 
 test_that(""addTraitAD"",{
@@ -37,9 +37,9 @@ test_that(""addTraitAD"",{
   expect_equal(c(ans$varA),1,tolerance=1e-6)
   expect_equal(c(ans$varD),0,tolerance=1e-6)
   expect_equal(c(ans$varG),1,tolerance=1e-6)
-  expect_equal(ans$genicVarA,1,tolerance=1e-6)
-  expect_equal(ans$genicVarD,0,tolerance=1e-6)
-  expect_equal(ans$genicVarG,1,tolerance=1e-6)
+  expect_equal(ans$genicVarA,0.5,tolerance=1e-6)
+  expect_equal(ans$genicVarD,0.25,tolerance=1e-6)
+  expect_equal(ans$genicVarG,0.75,tolerance=1e-6)
 })
 
 test_that(""addTraitAG"",{

---FILE: vignettes/traits.Rmd---
@@ -11,7 +11,7 @@ vignette: >
   %\VignetteEncoding{UTF-8}
 ---
 
-This vignette describes AlphaSimR's biological model for traits. The biological model deals with converting an individual's genotype into a genetic value, which can then be used to create phenotype. AlphaSimR's biological model is primarily based on classic models used in quantitative genetics. This means that users that have completed an introductory course in quantitative genetics should already be familiar with most aspects of AlphaSimR's model. This vignette will assume the reader is such a person and will thus focus on aspects of AlphaSimR's model that might not be obvious or don't coincide with one of the classic models. This vignette will proceed by first describing a novel classification system used in AlphaSimR to name different types of traits. The vignette will then present the full biological model and continue with a detailed description for each of components in this model.
+This vignette describes AlphaSimR's biological model for traits. The biological model converts an individual's genotype into a genetic value which is then used to create a phenotype. AlphaSimR's biological model is primarily based on classic models used in quantitative genetics. This means users that have completed an introductory course in quantitative genetics probably already familiar with most aspects of AlphaSimR's biological model. This vignette will assume the reader is such a person and will thus focus on aspects of AlphaSimR's biological model that may not be obvious or don't match classic models. This vignette will proceed by first describing a novel classification system used in AlphaSimR to name different types of traits. The vignette will then present the full biological model and continue with a detailed description for each of components in this model.
 
 Traits in AlphaSimR are classified according to the biological effects they model using the **ADEG** framework. Under this framework, each trait is assigned a name consisting of one or more letters. The letters come from the name **ADEG**, whose letters correspond to biological effects. The biological effects are: **A**dditive, **D**ominance, **E**pistatic and **G**enotype-by-environment. For example, a trait with only additive effects is called an **A** trait and a trait with both additive and dominance effects is called an **AD** trait. The following traits are modeled in AlphaSimR: **A**, **AD**, **AE**, **AG**, **ADE**, **ADG**, **AEG**, and **ADEG**.
 "
gaynorr,AlphaSimR,f1e3cf8d1145499dd3d2112e5b7af1de747d3bcf,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2020-01-20T16:58:52Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2020-01-20T16:58:52Z,-fixed subset by id for populations,DESCRIPTION;NEWS;R/Class-Pop.R,False,True,True,False,14,3,17,"---FILE: DESCRIPTION---
@@ -1,8 +1,8 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 0.11.1
-Date: 2020-01-13
+Version: 0.11.2
+Date: 2020-01-20
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: NEWS---
@@ -1,3 +1,8 @@
+Changes in version 0.11.1
+    
+  Bug fixes
+    -fixed subset by id for populations
+
 Changes in version 0.11.1
   
   New features

---FILE: R/Class-Pop.R---
@@ -341,7 +341,13 @@ setMethod(""["",
           signature(x = ""Pop""),
           function(x, i){
             if(is.character(i)){
-              i = x@id%in%i
+              i = match(i, x@id)
+              if(any(is.na(i))){
+                stop(""Trying to select invalid individuals"")
+              }
+              if(any(is.null(i))){
+                stop(""Not valid ids"")
+              }
             }else{
               if(any(abs(i)>x@nInd)){
                 stop(""Trying to select invalid individuals"")"
gaynorr,AlphaSimR,a51167f60b923da86d8c8142b7611e15c0d1e46e,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-11-25T09:45:48Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-11-25T09:45:48Z,"-fixed broken SimParam_addStructuredSnpChip
-removed broken pullMultipleSnpGeno and pullMultipleSnpHaplo
-switched to a circular design for the balance option in randCross and randCross2
-added reduceGenome and doubleGenome for changing plody levels",DESCRIPTION;NAMESPACE;NEWS;R/Class-Pop.R;R/Class-SimParam.R;R/RcppExports.R;R/crossing.R;R/polyploids.R;R/pullGeno.R;man/doubleGenome.Rd;man/makeDH.Rd;man/pullMultipleSnpGeno.Rd;man/pullMultipleSnpHaplo.Rd;man/pullQtlGeno.Rd;man/pullQtlHaplo.Rd;man/reduceGenome.Rd;src/RcppExports.cpp;src/init.c;src/meiosis.cpp,False,True,True,False,770,258,1028,"---FILE: DESCRIPTION---
@@ -1,8 +1,8 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 0.11.0
-Date: 2019-10-11
+Version: 0.11.1
+Date: 2019-11-25
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: NAMESPACE---
@@ -14,6 +14,7 @@ export(aa)
 export(bv)
 export(calcGCA)
 export(dd)
+export(doubleGenome)
 export(ebv)
 export(editGenome)
 export(editGenomeTopQtl)
@@ -41,8 +42,6 @@ export(pedigreeCross)
 export(pheno)
 export(popVar)
 export(pullIbdHaplo)
-export(pullMultipleSnpGeno)
-export(pullMultipleSnpHaplo)
 export(pullQtlGeno)
 export(pullQtlHaplo)
 export(pullSegSiteGeno)
@@ -52,6 +51,7 @@ export(pullSnpHaplo)
 export(quickHaplo)
 export(randCross)
 export(randCross2)
+export(reduceGenome)
 export(resetPop)
 export(runMacs)
 export(runMacs2)

---FILE: NEWS---
@@ -1,3 +1,13 @@
+Changes in version 0.11.1
+  
+  New features
+    -switched to a circular design for the balance option in randCross and randCross2
+    -added reduceGenome and doubleGenome for changing plody levels
+    
+  Bug fixes
+    -fixed broken SimParam_addStructuredSnpChip
+    -removed broken pullMultipleSnpGeno and pullMultipleSnpHaplo
+
 Changes in version 0.11.0
   
   New features

---FILE: R/Class-Pop.R---
@@ -161,7 +161,6 @@ setMethod(""["",
             }
             x@nInd = dim(x@geno[[1]])[3]
             class(x) = ""MapPop""
-            validObject(x)
             return(x)
           }
 )

---FILE: R/Class-SimParam.R---
@@ -924,7 +924,7 @@ SimParam$set(
       nSnpPerChr = rep(nSnpPerChr,private$.nChr)
     }
     stopifnot(length(nSnpPerChr)==private$.nChr)
-    stopifnot(sapply(simParam$potSnp,length)>=nSnpPerChr)
+    stopifnot(sapply(private$.potSnp,length)>=nSnpPerChr)
     stopifnot(dim(structure)[2]==sum(nSnpPerChr))
     lociLoc = lapply(1:private$.nChr,function(x){
       sort(sample(private$.potSnp[[x]],nSnpPerChr[x]))

---FILE: R/RcppExports.R---
@@ -109,6 +109,10 @@ createDH2 <- function(geno, nDH, genMap, v, trackRec, nThreads) {
     .Call(`_AlphaSimR_createDH2`, geno, nDH, genMap, v, trackRec, nThreads)
 }
 
+createReducedGenome <- function(geno, nProgeny, genMap, v, trackRec, ploidy, centromere, quadProb, nThreads) {
+    .Call(`_AlphaSimR_createReducedGenome`, geno, nProgeny, genMap, v, trackRec, ploidy, centromere, quadProb, nThreads)
+}
+
 getIbdRecHist <- function(recHist, pedigree, nLociPerChr) {
     .Call(`_AlphaSimR_getIbdRecHist`, recHist, pedigree, nLociPerChr)
 }

---FILE: R/crossing.R---
@@ -32,7 +32,7 @@ makeCross = function(pop,crossPlan,simParam=NULL){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
   if(pop@ploidy%%2L != 0L){
-    stop(""You can not cross aneuploids"")
+    stop(""You cannot cross aneuploids"")
   }
   if(is.character(crossPlan)){ #Match by ID
     crossPlan = cbind(match(crossPlan[,1],pop@id),
@@ -127,23 +127,30 @@ randCross = function(pop,nCrosses,nProgeny=1,
     crossPlan[,2] = parents[crossPlan[,2]]
   }else{
     female = which(pop@gender==""F"" & (1:pop@nInd)%in%parents)
-    if(length(female)==0){
+    nFemale = length(female)
+    if(nFemale==0){
       stop(""population doesn't contain any females"")
     }
     male = which(pop@gender==""M"" & (1:pop@nInd)%in%parents)
-    if(length(male)==0){
+    nMale = length(male)
+    if(nMale==0){
       stop(""population doesn't contain any males"")
     }
     if(balance){
-      female = female[sample.int(length(female),length(female))]
-      female = rep(female,length.out=nCrosses)
-      male = male[sample.int(length(male),length(male))]
-      male = rep(male,length.out=nCrosses)
-      male = male[sample.int(nCrosses,nCrosses)]
+      female = female[sample.int(nFemale, nFemale)]
+      female = rep(female, length.out=nCrosses)
+      tmp = male[sample.int(nMale, nMale)]
+      n = nCrosses%/%nMale + 1
+      male = NULL
+      for(i in 1:n){
+        take = nMale - (i:(nMale+i-1))%%nMale
+        male = c(male, tmp[take])
+      }
+      male = male[1:nCrosses]
       crossPlan = cbind(female,male)
     }else{
-      crossPlan = sampAllComb(length(female),
-                              length(male),
+      crossPlan = sampAllComb(nFemale,
+                              nMale,
                               nCrosses)
       crossPlan[,1] = female[crossPlan[,1]]
       crossPlan[,2] = male[crossPlan[,2]]
@@ -390,16 +397,23 @@ randCross2 = function(females,males,nCrosses,nProgeny=1,
       stop(""population doesn't contain any males"")
     }
   }
+  nMale = length(male)
+  nFemale = length(female)
   if(balance){
-    female = female[sample.int(length(female),length(female))]
-    female = rep(female,length.out=nCrosses)
-    male = male[sample.int(length(male),length(male))]
-    male = rep(male,length.out=nCrosses)
-    male = male[sample.int(nCrosses,nCrosses)]
+    female = female[sample.int(nFemale, nFemale)]
+    female = rep(female, length.out=nCrosses)
+    tmp = male[sample.int(nMale, nMale)]
+    n = nCrosses%/%nMale + 1
+    male = NULL
+    for(i in 1:n){
+      take = nMale - (i:(nMale+i-1))%%nMale
+      male = c(male, tmp[take])
+    }
+    male = male[1:nCrosses]
     crossPlan = cbind(female,male)
   }else{
-    crossPlan = sampAllComb(length(female),
-                            length(male),
+    crossPlan = sampAllComb(nFemale,
+                            nMale,
                             nCrosses)
     crossPlan[,1] = female[crossPlan[,1]]
     crossPlan[,2] = male[crossPlan[,2]]
@@ -497,12 +511,12 @@ self = function(pop,nProgeny=1,parents=NULL,keepParents=TRUE,
 #' @title Generates DH lines
 #' 
 #' @description Creates DH lines from each individual in a population. 
-#' Only works when gender is ""no"".
+#' Only works with diploid individuals. For polyploids, use 
+#' \code{\link{reduceGenome}} and \code{\link{doubleGenome}}.
 #' 
 #' @param pop an object of 'Pop' superclass
 #' @param nDH total number of DH lines per individual
 #' @param useFemale should female recombination rates be used. 
-#' This parameter has no effect if, recombRatio=1.
 #' @param keepParents should previous parents be used for mother and 
 #' father. 
 #' @param simParam an object of 'SimParam' class

---FILE: R/polyploids.R---
@@ -0,0 +1,175 @@
+#' @title Create individuals with reduced ploidy
+#' 
+#' @description Creates new individuals from gametes. This function 
+#' was created to model the creation of diploid potatoes from 
+#' tetraploid potatoes. It can be used on any population with an 
+#' even ploidy level. The newly created individuals will have half 
+#' the ploidy level of the originals and they will first undergo
+#' a single round of meiosis.
+#' 
+#' @param pop an object of 'Pop' superclass
+#' @param nProgeny total number of progeny per individual
+#' @param useFemale should female recombination rates be used. 
+#' @param keepParents should previous parents be used for mother and 
+#' father. 
+#' @param simParam an object of 'SimParam' class
+#' 
+#' @return Returns an object of \code{\link{Pop-class}}
+#' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Create individuals with reduced ploidy
+#' pop2 = reduceGenome(pop, simParam=SP)
+#' 
+#' @export
+reduceGenome = function(pop,nProgeny=1,useFemale=TRUE,keepParents=TRUE,
+                        simParam=NULL){
+  if(is.null(simParam)){
+    simParam = get(""SP"",envir=.GlobalEnv)
+  }
+  if(pop@ploidy%%2L){
+    stop(""You cannot reduce aneuploids"")
+  }
+  if(useFemale){
+    tmp = createReducedGenome(pop@geno, nProgeny,
+                              simParam$femaleMap,
+                              simParam$v,
+                              simParam$isTrackRec,
+                              pop@ploidy,
+                              simParam$femaleCentromere,
+                              simParam$quadProb,
+                              simParam$nThreads)
+  }else{
+    tmp = createReducedGenome(pop@geno, nProgeny,
+                              simParam$maleMap,
+                              simParam$v,
+                              simParam$isTrackRec,
+                              pop@ploidy,
+                              simParam$maleCentromere,
+                              simParam$quadProb,
+                              simParam$nThreads)
+  }
+  rPop = new(""RawPop"",
+             nInd=as.integer(pop@nInd*nProgeny),
+             nChr=pop@nChr,
+             ploidy=as.integer(pop@ploidy/2),
+             nLoci=pop@nLoci,
+             geno=tmp$geno)
+  if(simParam$isTrackRec){
+    simParam$addToRec(tmp$recHist)
+  }
+  if(keepParents){
+    return(newPop(rawPop=rPop,
+                  mother=rep(pop@id,each=nProgeny),
+                  father=rep(pop@id,each=nProgeny),
+                  origM=rep(pop@mother,each=nProgeny),
+                  origF=rep(pop@father,each=nProgeny),
+                  isDH=FALSE,
+                  simParam=simParam))
+  }else{
+    return(newPop(rawPop=rPop,
+                  mother=rep(pop@id,each=nProgeny),
+                  father=rep(pop@id,each=nProgeny),
+                  isDH=FALSE,
+                  simParam=simParam))
+  }
+}
+
+#' @title Double the ploidy of individuals
+#' 
+#' @description Creates new individuals with twice the ploidy. 
+#' This function was created to model the formation of tetraploid 
+#' potatoes from diploid potatoes. This function will work on any 
+#' population.
+#' 
+#' @param pop an object of 'Pop' superclass
+#' @param keepParents should previous parents be used for mother and 
+#' father. 
+#' @param simParam an object of 'SimParam' class
+#' 
+#' @return Returns an object of \code{\link{Pop-class}}
+#' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Create individuals with doubled ploidy
+#' pop2 = doubleGenome(pop, simParam=SP)
+#' 
+#' @export
+doubleGenome = function(pop, keepParents=TRUE,
+                        simParam=NULL){
+  if(is.null(simParam)){
+    simParam = get(""SP"",envir=.GlobalEnv)
+  }
+  geno = pop@geno
+  for(i in 1:pop@nChr){
+    geno[[i]] = geno[[i]][,rep(1:pop@ploidy,each=2),]
+  }
+  rPop = new(""RawPop"",
+             nInd=as.integer(pop@nInd),
+             nChr=pop@nChr,
+             ploidy=2L*pop@ploidy,
+             nLoci=pop@nLoci,
+             geno=geno)
+  if(keepParents){
+    origM=pop@mother
+    origF=pop@father
+  }else{
+    origM=pop@id
+    origF=pop@id
+  }
+  if(simParam$isTrackPed){
+    # Extract actual parents
+    ped = simParam$ped
+    id = as.numeric(pop@id)
+    mother = ped[id,1]
+    father = ped[id,2]
+  }else{
+    # Provide arbitrary parents (not actually used)
+    mother = origM
+    father = origF
+  }
+  if(simParam$isTrackRec){
+    # Duplicate recombination histories
+    oldHist = simParam$recHist
+    newHist = vector(""list"", 2*pop@ploidy)
+    newHist = rep(list(newHist), pop@nChr)
+    newHist = rep(list(newHist), pop@nInd)
+    for(i in 1:pop@nInd){
+      for(j in 1:pop@nChr){
+        k = 0
+        for(l in 1:pop@ploidy){
+          for(m in 1:2){
+            k = k+1
+            newHist[[i]][[j]][[k]] = 
+              oldHist[[as.numeric(id[i])]][[j]][[l]]
+          }
+        }
+      }
+    }
+    simParam$addToRec(newHist)
+  }
+  return(newPop(rawPop=rPop,
+                mother=mother,
+                father=father,
+                origM=origM,
+                origF=origF,
+                isDH=TRUE,
+                simParam=simParam))
+}
+

---FILE: R/pullGeno.R---
@@ -213,60 +213,59 @@ pullSnpGeno = function(pop, snpChip=1, chr=NULL, simParam=NULL){
   return(output)
 }
 
-#' @title Pull SNP genotype for multiple snp chips
-#'
-#' @description Retrieves SNP genotype data for multiple snp chips
-#'
-#' @param pop an object of \code{\link{Pop-class}}
-#' @param chips a vector. For each animal indicates what snp
-#' chip to use
-#' @param missing What value to use for missing
-#' @param simParam an object of \code{\link{SimParam}}
-#' 
-#' @return Returns a matrix of SNP genotypes.
-#' 
-#' @export
-pullMultipleSnpGeno = function(pop, chips,
-                               missing=9, simParam=NULL) {
-  if(is.null(simParam)){
-    simParam = get(""SP"",envir=.GlobalEnv)
-  }
-  stopifnot(length(chips) == pop@nInd)
-  # I feel like the next line shouldn't be needed but I don't know
-  # enough R! (dmoney)
-  missing = as.integer(missing)
-  allSnps = numeric(0)
-  uniqueChips = unique(chips)
-  for (c in uniqueChips){
-    allSnps = sort(union(allSnps,simParam$snpChips[[c]]@lociLoc))
-  }
-
-  output = matrix(pop@nInd,length(allSnps),data=missing)
-  if(class(pop)==""Pop""){
-    rownames(output) = pop@id
-  }else{
-    rownames(output) = as.character(1:pop@nInd)
-  }
-
-  for (snpChip in uniqueChips){
-    mask = allSnps %in% simParam$snpChips[[snpChip]]@lociLoc
-    one = getGeno(pop@geno,
-                  simParam$snpChips[[snpChip]]@lociPerChr,
-                  simParam$snpChips[[snpChip]]@lociLoc,
-                  simParam$nThreads)
-    one = convToImat(one)
-    for (i in 1:pop@nInd){
-      if (chips[i] == snpChip) {
-        output[i,mask] = one[i,]
-        output[i,mask] = one[i,]
-      }
-    }
-  }
-
-  colnames(output) = paste(""SNP"",1:ncol(output),sep=""_"")
-
-  return(output)
-}
+#' #' @title Pull SNP genotype for multiple snp chips
+#' #'
+#' #' @description Retrieves SNP genotype data for multiple snp chips
+#' #'
+#' #' @param pop an object of \code{\link{Pop-class}}
+#' #' @param chips a vector. For each animal indicates what snp
+#' #' chip to use
+#' #' @param missing What value to use for missing
+#' #' @param simParam an object of \code{\link{SimParam}}
+#' #' 
+#' #' @return Returns a matrix of SNP genotypes.
+#' #' 
+#' #' @export
+#' pullMultipleSnpGeno = function(pop, chips,
+#'                                missing=9, simParam=NULL) {
+#'   if(is.null(simParam)){
+#'     simParam = get(""SP"",envir=.GlobalEnv)
+#'   }
+#'   # I feel like the next line shouldn't be needed but I don't know
+#'   # enough R! (dmoney)
+#'   missing = as.integer(missing)
+#'   allSnps = numeric(0)
+#'   uniqueChips = unique(chips)
+#'   for (c in uniqueChips){
+#'     allSnps = sort(union(allSnps,simParam$snpChips[[c]]@lociLoc))
+#'   }
+#' 
+#'   output = matrix(pop@nInd,length(allSnps),data=missing)
+#'   if(class(pop)==""Pop""){
+#'     rownames(output) = pop@id
+#'   }else{
+#'     rownames(output) = as.character(1:pop@nInd)
+#'   }
+#' 
+#'   for (snpChip in uniqueChips){
+#'     mask = allSnps %in% simParam$snpChips[[snpChip]]@lociLoc
+#'     one = getGeno(pop@geno,
+#'                   simParam$snpChips[[snpChip]]@lociPerChr,
+#'                   simParam$snpChips[[snpChip]]@lociLoc,
+#'                   simParam$nThreads)
+#'     one = convToImat(one)
+#'     for (i in 1:pop@nInd){
+#'       if (chips[i] == snpChip) {
+#'         output[i,mask] = one[i,]
+#'         output[i,mask] = one[i,]
+#'       }
+#'     }
+#'   }
+#' 
+#'   colnames(output) = paste(""SNP"",1:ncol(output),sep=""_"")
+#' 
+#'   return(output)
+#' }
 
 #' @title Pull QTL genotype
 #'
@@ -430,89 +429,88 @@ pullSnpHaplo = function(pop, snpChip=1, haplo=""all"",
   return(output)
 }
 
-#' @title Pull SNP haplotypes for multiple chips
-#'
-#' @description Retrieves SNP haplotype data for multiple snp
-#'
-#' @param pop an object of \code{\link{Pop-class}}
-#' @param chips a vector. For each animal indicates what snp
-#' chip to use
-#' @param haplo either ""all"" for all haplotypes or an integer
-#' for a single set of haplotypes. Use a value of 1 for female
-#' haplotyes and a value of 2 for male haplotypes.
-#' @param missing What value to use for missing
-#' @param simParam an object of \code{\link{SimParam}}
-#'
-#' @return Returns a matrix of SNP haplotypes.
-#' 
-#' @export
-pullMultipleSnpHaplo = function(pop, chips, haplo=""all"",
-                                missing=9, simParam=NULL){
-  if(is.null(simParam)){
-    simParam = get(""SP"",envir=.GlobalEnv)
-  }
-  stopifnot(length(chips) == pop@nInd)
-  # I feel like the next line shouldn't be needed but I don't know
-  # enough R! (dmoney)
-  missing = as.integer(missing)
-  allSnps = numeric(0)
-  uniqueChips = unique(chips)
-  for (c in uniqueChips){
-    allSnps = sort(union(allSnps,simParam$snpChips[[c]]@lociLoc))
-  }
-
-  if (haplo == ""all"") {
-    output = matrix(pop@nInd*2,length(allSnps),data=missing)
-    if(class(pop)==""Pop""){
-      rownames(output) = paste(rep(pop@id,each=pop@ploidy),
-                               rep(1:pop@ploidy,pop@nInd),sep=""_"")
-    }else{
-      rownames(output) = paste(rep(1:pop@nInd,each=pop@ploidy),
-                               rep(1:pop@ploidy,pop@nInd),sep=""_"")
-    }
-  }else{
-    output = matrix(pop@nInd,length(allSnps),data=missing)
-    if(class(pop)==""Pop""){
-      rownames(output) = paste(pop@id,rep(haplo,pop@nInd),sep=""_"")
-    }else{
-      rownames(output) = paste(1:pop@nInd,rep(haplo,pop@nInd),sep=""_"")
-    }
-  }
-  for (snpChip in uniqueChips){
-    mask = allSnps %in% simParam$snpChips[[snpChip]]@lociLoc
-    if (haplo == ""all"") {
-      one = getHaplo(pop@geno,
-                     simParam$snpChips[[snpChip]]@lociPerChr,
-                     simParam$snpChips[[snpChip]]@lociLoc,
-                     simParam$nThreads)
-      one = convToImat(one)
-      for (i in 1:pop@nInd){
-        if (chips[i] == snpChip) {
-          output[i*2-1,mask] = one[i*2-1,]
-          output[i*2,mask] = one[i*2,]
-        }
-      }
-    }
-    else {
-      one = getOneHaplo(pop@geno,
-                        simParam$snpChips[[snpChip]]@lociPerChr,
-                        simParam$snpChips[[snpChip]]@lociLoc,
-                        as.integer(haplo),
-                        simParam$nThreads)
-      one = convToImat(one)
-      for (i in 1:pop@nInd){
-        if (chips[i] == snpChip) {
-          output[i,mask] = one[i,]
-          output[i,mask] = one[i,]
-        }
-      }
-    }
-  }
-
-  colnames(output) = paste(""SNP"",1:ncol(output),sep=""_"")
-
-  return(output)
-}
+#' #' @title Pull SNP haplotypes for multiple chips
+#' #'
+#' #' @description Retrieves SNP haplotype data for multiple snp
+#' #'
+#' #' @param pop an object of \code{\link{Pop-class}}
+#' #' @param chips a vector. For each animal indicates what snp
+#' #' chip to use
+#' #' @param haplo either ""all"" for all haplotypes or an integer
+#' #' for a single set of haplotypes. Use a value of 1 for female
+#' #' haplotyes and a value of 2 for male haplotypes.
+#' #' @param missing What value to use for missing
+#' #' @param simParam an object of \code{\link{SimParam}}
+#' #'
+#' #' @return Returns a matrix of SNP haplotypes.
+#' #' 
+#' #' @export
+#' pullMultipleSnpHaplo = function(pop, chips, haplo=""all"",
+#'                                 missing=9, simParam=NULL){
+#'   if(is.null(simParam)){
+#'     simParam = get(""SP"",envir=.GlobalEnv)
+#'   }
+#'   # I feel like the next line shouldn't be needed but I don't know
+#'   # enough R! (dmoney)
+#'   missing = as.integer(missing)
+#'   allSnps = numeric(0)
+#'   uniqueChips = unique(chips)
+#'   for (c in uniqueChips){
+#'     allSnps = sort(union(allSnps,simParam$snpChips[[c]]@lociLoc))
+#'   }
+#' 
+#'   if (haplo == ""all"") {
+#'     output = matrix(pop@nInd*2,length(allSnps),data=missing)
+#'     if(class(pop)==""Pop""){
+#'       rownames(output) = paste(rep(pop@id,each=pop@ploidy),
+#'                                rep(1:pop@ploidy,pop@nInd),sep=""_"")
+#'     }else{
+#'       rownames(output) = paste(rep(1:pop@nInd,each=pop@ploidy),
+#'                                rep(1:pop@ploidy,pop@nInd),sep=""_"")
+#'     }
+#'   }else{
+#'     output = matrix(pop@nInd,length(allSnps),data=missing)
+#'     if(class(pop)==""Pop""){
+#'       rownames(output) = paste(pop@id,rep(haplo,pop@nInd),sep=""_"")
+#'     }else{
+#'       rownames(output) = paste(1:pop@nInd,rep(haplo,pop@nInd),sep=""_"")
+#'     }
+#'   }
+#'   for (snpChip in uniqueChips){
+#'     mask = allSnps %in% simParam$snpChips[[snpChip]]@lociLoc
+#'     if (haplo == ""all"") {
+#'       one = getHaplo(pop@geno,
+#'                      simParam$snpChips[[snpChip]]@lociPerChr,
+#'                      simParam$snpChips[[snpChip]]@lociLoc,
+#'                      simParam$nThreads)
+#'       one = convToImat(one)
+#'       for (i in 1:pop@nInd){
+#'         if (chips[i] == snpChip) {
+#'           output[i*2-1,mask] = one[i*2-1,]
+#'           output[i*2,mask] = one[i*2,]
+#'         }
+#'       }
+#'     }
+#'     else {
+#'       one = getOneHaplo(pop@geno,
+#'                         simParam$snpChips[[snpChip]]@lociPerChr,
+#'                         simParam$snpChips[[snpChip]]@lociLoc,
+#'                         as.integer(haplo),
+#'                         simParam$nThreads)
+#'       one = convToImat(one)
+#'       for (i in 1:pop@nInd){
+#'         if (chips[i] == snpChip) {
+#'           output[i,mask] = one[i,]
+#'           output[i,mask] = one[i,]
+#'         }
+#'       }
+#'     }
+#'   }
+#' 
+#'   colnames(output) = paste(""SNP"",1:ncol(output),sep=""_"")
+#' 
+#'   return(output)
+#' }
 
 #' @title Pull QTL haplotypes
 #'

---FILE: man/doubleGenome.Rd---
@@ -0,0 +1,39 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/polyploids.R
+\name{doubleGenome}
+\alias{doubleGenome}
+\title{Double the ploidy of individuals}
+\usage{
+doubleGenome(pop, keepParents = TRUE, simParam = NULL)
+}
+\arguments{
+\item{pop}{an object of 'Pop' superclass}
+
+\item{keepParents}{should previous parents be used for mother and 
+father.}
+
+\item{simParam}{an object of 'SimParam' class}
+}
+\value{
+Returns an object of \code{\link{Pop-class}}
+}
+\description{
+Creates new individuals with twice the ploidy. 
+This function was created to model the formation of tetraploid 
+potatoes from diploid potatoes. This function will work on any 
+population.
+}
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Create individuals with doubled ploidy
+pop2 = doubleGenome(pop, simParam=SP)
+
+}

---FILE: man/makeDH.Rd---
@@ -12,8 +12,7 @@ makeDH(pop, nDH = 1, useFemale = TRUE, keepParents = TRUE,
 
 \item{nDH}{total number of DH lines per individual}
 
-\item{useFemale}{should female recombination rates be used. 
-This parameter has no effect if, recombRatio=1.}
+\item{useFemale}{should female recombination rates be used.}
 
 \item{keepParents}{should previous parents be used for mother and 
 father.}
@@ -25,7 +24,8 @@ Returns an object of \code{\link{Pop-class}}
 }
 \description{
 Creates DH lines from each individual in a population. 
-Only works when gender is ""no"".
+Only works with diploid individuals. For polyploids, use 
+\code{\link{reduceGenome}} and \code{\link{doubleGenome}}.
 }
 \examples{
 #Create founder haplotypes

---FILE: man/pullMultipleSnpGeno.Rd---
@@ -1,24 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/pullGeno.R
-\name{pullMultipleSnpGeno}
-\alias{pullMultipleSnpGeno}
-\title{Pull SNP genotype for multiple snp chips}
-\usage{
-pullMultipleSnpGeno(pop, chips, missing = 9, simParam = NULL)
-}
-\arguments{
-\item{pop}{an object of \code{\link{Pop-class}}}
-
-\item{chips}{a vector. For each animal indicates what snp
-chip to use}
-
-\item{missing}{What value to use for missing}
-
-\item{simParam}{an object of \code{\link{SimParam}}}
-}
-\value{
-Returns a matrix of SNP genotypes.
-}
-\description{
-Retrieves SNP genotype data for multiple snp chips
-}

---FILE: man/pullMultipleSnpHaplo.Rd---
@@ -1,29 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/pullGeno.R
-\name{pullMultipleSnpHaplo}
-\alias{pullMultipleSnpHaplo}
-\title{Pull SNP haplotypes for multiple chips}
-\usage{
-pullMultipleSnpHaplo(pop, chips, haplo = ""all"", missing = 9,
-  simParam = NULL)
-}
-\arguments{
-\item{pop}{an object of \code{\link{Pop-class}}}
-
-\item{chips}{a vector. For each animal indicates what snp
-chip to use}
-
-\item{haplo}{either ""all"" for all haplotypes or an integer
-for a single set of haplotypes. Use a value of 1 for female
-haplotyes and a value of 2 for male haplotypes.}
-
-\item{missing}{What value to use for missing}
-
-\item{simParam}{an object of \code{\link{SimParam}}}
-}
-\value{
-Returns a matrix of SNP haplotypes.
-}
-\description{
-Retrieves SNP haplotype data for multiple snp
-}

---FILE: man/pullQtlGeno.Rd---
@@ -23,6 +23,61 @@ Returns a matrix of QTL genotypes.
 \description{
 Retrieves QTL genotype data
 }
+\details{
+#' @title Pull SNP genotype for multiple snp chips
+#'
+#' @description Retrieves SNP genotype data for multiple snp chips
+#'
+#' @param pop an object of \code{\link{Pop-class}}
+#' @param chips a vector. For each animal indicates what snp
+#' chip to use
+#' @param missing What value to use for missing
+#' @param simParam an object of \code{\link{SimParam}}
+#' 
+#' @return Returns a matrix of SNP genotypes.
+#' 
+#' @export
+pullMultipleSnpGeno = function(pop, chips,
+                               missing=9, simParam=NULL) {
+  if(is.null(simParam)){
+    simParam = get(""SP"",envir=.GlobalEnv)
+  }
+  # I feel like the next line shouldn't be needed but I don't know
+  # enough R! (dmoney)
+  missing = as.integer(missing)
+  allSnps = numeric(0)
+  uniqueChips = unique(chips)
+  for (c in uniqueChips){
+    allSnps = sort(union(allSnps,simParam$snpChips[[c]]@lociLoc))
+  }
+
+output = matrix(pop@nInd,length(allSnps),data=missing)
+  if(class(pop)==""Pop""){
+    rownames(output) = pop@id
+  }else{
+    rownames(output) = as.character(1:pop@nInd)
+  }
+
+for (snpChip in uniqueChips){
+    mask = allSnps %in% simParam$snpChips[[snpChip]]@lociLoc
+    one = getGeno(pop@geno,
+                  simParam$snpChips[[snpChip]]@lociPerChr,
+                  simParam$snpChips[[snpChip]]@lociLoc,
+                  simParam$nThreads)
+    one = convToImat(one)
+    for (i in 1:pop@nInd){
+      if (chips[i] == snpChip) {
+        output[i,mask] = one[i,]
+        output[i,mask] = one[i,]
+      }
+    }
+  }
+
+colnames(output) = paste(""SNP"",1:ncol(output),sep=""_"")
+
+return(output)
+}
+}
 \examples{
 #Create founder haplotypes
 founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

---FILE: man/pullQtlHaplo.Rd---
@@ -28,6 +28,90 @@ Returns a matrix of QTL haplotypes.
 \description{
 Retrieves QTL haplotype data
 }
+\details{
+#' @title Pull SNP haplotypes for multiple chips
+#'
+#' @description Retrieves SNP haplotype data for multiple snp
+#'
+#' @param pop an object of \code{\link{Pop-class}}
+#' @param chips a vector. For each animal indicates what snp
+#' chip to use
+#' @param haplo either ""all"" for all haplotypes or an integer
+#' for a single set of haplotypes. Use a value of 1 for female
+#' haplotyes and a value of 2 for male haplotypes.
+#' @param missing What value to use for missing
+#' @param simParam an object of \code{\link{SimParam}}
+#'
+#' @return Returns a matrix of SNP haplotypes.
+#' 
+#' @export
+pullMultipleSnpHaplo = function(pop, chips, haplo=""all"",
+                                missing=9, simParam=NULL){
+  if(is.null(simParam)){
+    simParam = get(""SP"",envir=.GlobalEnv)
+  }
+  # I feel like the next line shouldn't be needed but I don't know
+  # enough R! (dmoney)
+  missing = as.integer(missing)
+  allSnps = numeric(0)
+  uniqueChips = unique(chips)
+  for (c in uniqueChips){
+    allSnps = sort(union(allSnps,simParam$snpChips[[c]]@lociLoc))
+  }
+
+if (haplo == ""all"") {
+    output = matrix(pop@nInd*2,length(allSnps),data=missing)
+    if(class(pop)==""Pop""){
+      rownames(output) = paste(rep(pop@id,each=pop@ploidy),
+                               rep(1:pop@ploidy,pop@nInd),sep=""_"")
+    }else{
+      rownames(output) = paste(rep(1:pop@nInd,each=pop@ploidy),
+                               rep(1:pop@ploidy,pop@nInd),sep=""_"")
+    }
+  }else{
+    output = matrix(pop@nInd,length(allSnps),data=missing)
+    if(class(pop)==""Pop""){
+      rownames(output) = paste(pop@id,rep(haplo,pop@nInd),sep=""_"")
+    }else{
+      rownames(output) = paste(1:pop@nInd,rep(haplo,pop@nInd),sep=""_"")
+    }
+  }
+  for (snpChip in uniqueChips){
+    mask = allSnps %in% simParam$snpChips[[snpChip]]@lociLoc
+    if (haplo == ""all"") {
+      one = getHaplo(pop@geno,
+                     simParam$snpChips[[snpChip]]@lociPerChr,
+                     simParam$snpChips[[snpChip]]@lociLoc,
+                     simParam$nThreads)
+      one = convToImat(one)
+      for (i in 1:pop@nInd){
+        if (chips[i] == snpChip) {
+          output[i*2-1,mask] = one[i*2-1,]
+          output[i*2,mask] = one[i*2,]
+        }
+      }
+    }
+    else {
+      one = getOneHaplo(pop@geno,
+                        simParam$snpChips[[snpChip]]@lociPerChr,
+                        simParam$snpChips[[snpChip]]@lociLoc,
+                        as.integer(haplo),
+                        simParam$nThreads)
+      one = convToImat(one)
+      for (i in 1:pop@nInd){
+        if (chips[i] == snpChip) {
+          output[i,mask] = one[i,]
+          output[i,mask] = one[i,]
+        }
+      }
+    }
+  }
+
+colnames(output) = paste(""SNP"",1:ncol(output),sep=""_"")
+
+return(output)
+}
+}
 \examples{
 #Create founder haplotypes
 founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)

---FILE: man/reduceGenome.Rd---
@@ -0,0 +1,46 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/polyploids.R
+\name{reduceGenome}
+\alias{reduceGenome}
+\title{Create individuals with reduced ploidy}
+\usage{
+reduceGenome(pop, nProgeny = 1, useFemale = TRUE, keepParents = TRUE,
+  simParam = NULL)
+}
+\arguments{
+\item{pop}{an object of 'Pop' superclass}
+
+\item{nProgeny}{total number of progeny per individual}
+
+\item{useFemale}{should female recombination rates be used.}
+
+\item{keepParents}{should previous parents be used for mother and 
+father.}
+
+\item{simParam}{an object of 'SimParam' class}
+}
+\value{
+Returns an object of \code{\link{Pop-class}}
+}
+\description{
+Creates new individuals from gametes. This function 
+was created to model the creation of diploid potatoes from 
+tetraploid potatoes. It can be used on any population with an 
+even ploidy level. The newly created individuals will have half 
+the ploidy level of the originals and they will first undergo
+a single round of meiosis.
+}
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Create individuals with reduced ploidy
+pop2 = reduceGenome(pop, simParam=SP)
+
+}

---FILE: src/RcppExports.cpp---
@@ -466,6 +466,25 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// createReducedGenome
+Rcpp::List createReducedGenome(const arma::field<arma::Cube<unsigned char> >& geno, arma::uword nProgeny, const arma::field<arma::vec>& genMap, double v, bool trackRec, arma::uword ploidy, arma::vec& centromere, double quadProb, int nThreads);
+RcppExport SEXP _AlphaSimR_createReducedGenome(SEXP genoSEXP, SEXP nProgenySEXP, SEXP genMapSEXP, SEXP vSEXP, SEXP trackRecSEXP, SEXP ploidySEXP, SEXP centromereSEXP, SEXP quadProbSEXP, SEXP nThreadsSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::uword >::type nProgeny(nProgenySEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::vec>& >::type genMap(genMapSEXP);
+    Rcpp::traits::input_parameter< double >::type v(vSEXP);
+    Rcpp::traits::input_parameter< bool >::type trackRec(trackRecSEXP);
+    Rcpp::traits::input_parameter< arma::uword >::type ploidy(ploidySEXP);
+    Rcpp::traits::input_parameter< arma::vec& >::type centromere(centromereSEXP);
+    Rcpp::traits::input_parameter< double >::type quadProb(quadProbSEXP);
+    Rcpp::traits::input_parameter< int >::type nThreads(nThreadsSEXP);
+    rcpp_result_gen = Rcpp::wrap(createReducedGenome(geno, nProgeny, genMap, v, trackRec, ploidy, centromere, quadProb, nThreads));
+    return rcpp_result_gen;
+END_RCPP
+}
 // getIbdRecHist
 Rcpp::List getIbdRecHist(const Rcpp::List& recHist, const Rcpp::IntegerMatrix& pedigree, const Rcpp::IntegerVector& nLociPerChr);
 RcppExport SEXP _AlphaSimR_getIbdRecHist(SEXP recHistSEXP, SEXP pedigreeSEXP, SEXP nLociPerChrSEXP) {

---FILE: src/init.c---
@@ -23,6 +23,7 @@ extern SEXP _AlphaSimR_callRRBLUP_SCA(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP,
 extern SEXP _AlphaSimR_callRRBLUP_SCA2(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_callRRBLUP2(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_createDH2(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
+extern SEXP _AlphaSimR_createReducedGenome(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_cross(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_getGeno(SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_getGv(SEXP, SEXP, SEXP);
@@ -50,46 +51,47 @@ extern SEXP _AlphaSimR_writeOneHaplo(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_writePlinkPed(SEXP, SEXP, SEXP, SEXP, SEXP);
 
 static const R_CallMethodDef CallEntries[] = {
-    {""_AlphaSimR_calcChrFreq"",       (DL_FUNC) &_AlphaSimR_calcChrFreq,        1},
-    {""_AlphaSimR_calcCoef"",          (DL_FUNC) &_AlphaSimR_calcCoef,           2},
-    {""_AlphaSimR_calcGenoFreq"",      (DL_FUNC) &_AlphaSimR_calcGenoFreq,       4},
-    {""_AlphaSimR_calcGenParam"",      (DL_FUNC) &_AlphaSimR_calcGenParam,       3},
-    {""_AlphaSimR_callFastRRBLUP"",    (DL_FUNC) &_AlphaSimR_callFastRRBLUP,     8},
-    {""_AlphaSimR_callRRBLUP"",        (DL_FUNC) &_AlphaSimR_callRRBLUP,         8},
-    {""_AlphaSimR_callRRBLUP_D"",      (DL_FUNC) &_AlphaSimR_callRRBLUP_D,       9},
-    {""_AlphaSimR_callRRBLUP_D2"",     (DL_FUNC) &_AlphaSimR_callRRBLUP_D2,     14},
-    {""_AlphaSimR_callRRBLUP_GCA"",    (DL_FUNC) &_AlphaSimR_callRRBLUP_GCA,     9},
-    {""_AlphaSimR_callRRBLUP_GCA2"",   (DL_FUNC) &_AlphaSimR_callRRBLUP_GCA2,   14},
-    {""_AlphaSimR_callRRBLUP_MV"",     (DL_FUNC) &_AlphaSimR_callRRBLUP_MV,      9},
-    {""_AlphaSimR_callRRBLUP_SCA"",    (DL_FUNC) &_AlphaSimR_callRRBLUP_SCA,     9},
-    {""_AlphaSimR_callRRBLUP_SCA2"",   (DL_FUNC) &_AlphaSimR_callRRBLUP_SCA2,   15},
-    {""_AlphaSimR_callRRBLUP2"",       (DL_FUNC) &_AlphaSimR_callRRBLUP2,       13},
-    {""_AlphaSimR_createDH2"",         (DL_FUNC) &_AlphaSimR_createDH2,          6},
-    {""_AlphaSimR_cross"",             (DL_FUNC) &_AlphaSimR_cross,             14},
-    {""_AlphaSimR_getGeno"",           (DL_FUNC) &_AlphaSimR_getGeno,            4},
-    {""_AlphaSimR_getGv"",             (DL_FUNC) &_AlphaSimR_getGv,              3},
-    {""_AlphaSimR_getHaplo"",          (DL_FUNC) &_AlphaSimR_getHaplo,           4},
-    {""_AlphaSimR_getHybridGv"",       (DL_FUNC) &_AlphaSimR_getHybridGv,        6},
-    {""_AlphaSimR_getIbdHaplo"",       (DL_FUNC) &_AlphaSimR_getIbdHaplo,        3},
-    {""_AlphaSimR_getIbdRecHist"",     (DL_FUNC) &_AlphaSimR_getIbdRecHist,      3},
-    {""_AlphaSimR_getMaternalGeno"",   (DL_FUNC) &_AlphaSimR_getMaternalGeno,    4},
-    {""_AlphaSimR_getNumThreads"",     (DL_FUNC) &_AlphaSimR_getNumThreads,      0},
-    {""_AlphaSimR_getOneHaplo"",       (DL_FUNC) &_AlphaSimR_getOneHaplo,        5},
-    {""_AlphaSimR_getPaternalGeno"",   (DL_FUNC) &_AlphaSimR_getPaternalGeno,    4},
-    {""_AlphaSimR_MaCS"",              (DL_FUNC) &_AlphaSimR_MaCS,               6},
-    {""_AlphaSimR_mergeGeno"",         (DL_FUNC) &_AlphaSimR_mergeGeno,          2},
-    {""_AlphaSimR_mergeMultGeno"",     (DL_FUNC) &_AlphaSimR_mergeMultGeno,      4},
-    {""_AlphaSimR_mergeMultIntMat"",   (DL_FUNC) &_AlphaSimR_mergeMultIntMat,    3},
-    {""_AlphaSimR_packHaplo"",         (DL_FUNC) &_AlphaSimR_packHaplo,          3},
-    {""_AlphaSimR_popVar"",            (DL_FUNC) &_AlphaSimR_popVar,             1},
-    {""_AlphaSimR_sampAllComb"",       (DL_FUNC) &_AlphaSimR_sampAllComb,        3},
-    {""_AlphaSimR_sampHalfDialComb"",  (DL_FUNC) &_AlphaSimR_sampHalfDialComb,   2},
-    {""_AlphaSimR_sampleInt"",         (DL_FUNC) &_AlphaSimR_sampleInt,          2},
-    {""_AlphaSimR_writeASGenotypes"",  (DL_FUNC) &_AlphaSimR_writeASGenotypes,   7},
-    {""_AlphaSimR_writeASHaplotypes"", (DL_FUNC) &_AlphaSimR_writeASHaplotypes,  7},
-    {""_AlphaSimR_writeGeno"",         (DL_FUNC) &_AlphaSimR_writeGeno,          5},
-    {""_AlphaSimR_writeOneHaplo"",     (DL_FUNC) &_AlphaSimR_writeOneHaplo,      6},
-    {""_AlphaSimR_writePlinkPed"",     (DL_FUNC) &_AlphaSimR_writePlinkPed,      5},
+    {""_AlphaSimR_calcChrFreq"",         (DL_FUNC) &_AlphaSimR_calcChrFreq,          1},
+    {""_AlphaSimR_calcCoef"",            (DL_FUNC) &_AlphaSimR_calcCoef,             2},
+    {""_AlphaSimR_calcGenoFreq"",        (DL_FUNC) &_AlphaSimR_calcGenoFreq,         4},
+    {""_AlphaSimR_calcGenParam"",        (DL_FUNC) &_AlphaSimR_calcGenParam,         3},
+    {""_AlphaSimR_callFastRRBLUP"",      (DL_FUNC) &_AlphaSimR_callFastRRBLUP,       8},
+    {""_AlphaSimR_callRRBLUP"",          (DL_FUNC) &_AlphaSimR_callRRBLUP,           8},
+    {""_AlphaSimR_callRRBLUP_D"",        (DL_FUNC) &_AlphaSimR_callRRBLUP_D,         9},
+    {""_AlphaSimR_callRRBLUP_D2"",       (DL_FUNC) &_AlphaSimR_callRRBLUP_D2,       14},
+    {""_AlphaSimR_callRRBLUP_GCA"",      (DL_FUNC) &_AlphaSimR_callRRBLUP_GCA,       9},
+    {""_AlphaSimR_callRRBLUP_GCA2"",     (DL_FUNC) &_AlphaSimR_callRRBLUP_GCA2,     14},
+    {""_AlphaSimR_callRRBLUP_MV"",       (DL_FUNC) &_AlphaSimR_callRRBLUP_MV,        9},
+    {""_AlphaSimR_callRRBLUP_SCA"",      (DL_FUNC) &_AlphaSimR_callRRBLUP_SCA,       9},
+    {""_AlphaSimR_callRRBLUP_SCA2"",     (DL_FUNC) &_AlphaSimR_callRRBLUP_SCA2,     15},
+    {""_AlphaSimR_callRRBLUP2"",         (DL_FUNC) &_AlphaSimR_callRRBLUP2,         13},
+    {""_AlphaSimR_createDH2"",           (DL_FUNC) &_AlphaSimR_createDH2,            6},
+    {""_AlphaSimR_createReducedGenome"", (DL_FUNC) &_AlphaSimR_createReducedGenome,  9},
+    {""_AlphaSimR_cross"",               (DL_FUNC) &_AlphaSimR_cross,               14},
+    {""_AlphaSimR_getGeno"",             (DL_FUNC) &_AlphaSimR_getGeno,              4},
+    {""_AlphaSimR_getGv"",               (DL_FUNC) &_AlphaSimR_getGv,                3},
+    {""_AlphaSimR_getHaplo"",            (DL_FUNC) &_AlphaSimR_getHaplo,             4},
+    {""_AlphaSimR_getHybridGv"",         (DL_FUNC) &_AlphaSimR_getHybridGv,          6},
+    {""_AlphaSimR_getIbdHaplo"",         (DL_FUNC) &_AlphaSimR_getIbdHaplo,          3},
+    {""_AlphaSimR_getIbdRecHist"",       (DL_FUNC) &_AlphaSimR_getIbdRecHist,        3},
+    {""_AlphaSimR_getMaternalGeno"",     (DL_FUNC) &_AlphaSimR_getMaternalGeno,      4},
+    {""_AlphaSimR_getNumThreads"",       (DL_FUNC) &_AlphaSimR_getNumThreads,        0},
+    {""_AlphaSimR_getOneHaplo"",         (DL_FUNC) &_AlphaSimR_getOneHaplo,          5},
+    {""_AlphaSimR_getPaternalGeno"",     (DL_FUNC) &_AlphaSimR_getPaternalGeno,      4},
+    {""_AlphaSimR_MaCS"",                (DL_FUNC) &_AlphaSimR_MaCS,                 6},
+    {""_AlphaSimR_mergeGeno"",           (DL_FUNC) &_AlphaSimR_mergeGeno,            2},
+    {""_AlphaSimR_mergeMultGeno"",       (DL_FUNC) &_AlphaSimR_mergeMultGeno,        4},
+    {""_AlphaSimR_mergeMultIntMat"",     (DL_FUNC) &_AlphaSimR_mergeMultIntMat,      3},
+    {""_AlphaSimR_packHaplo"",           (DL_FUNC) &_AlphaSimR_packHaplo,            3},
+    {""_AlphaSimR_popVar"",              (DL_FUNC) &_AlphaSimR_popVar,               1},
+    {""_AlphaSimR_sampAllComb"",         (DL_FUNC) &_AlphaSimR_sampAllComb,          3},
+    {""_AlphaSimR_sampHalfDialComb"",    (DL_FUNC) &_AlphaSimR_sampHalfDialComb,     2},
+    {""_AlphaSimR_sampleInt"",           (DL_FUNC) &_AlphaSimR_sampleInt,            2},
+    {""_AlphaSimR_writeASGenotypes"",    (DL_FUNC) &_AlphaSimR_writeASGenotypes,     7},
+    {""_AlphaSimR_writeASHaplotypes"",   (DL_FUNC) &_AlphaSimR_writeASHaplotypes,    7},
+    {""_AlphaSimR_writeGeno"",           (DL_FUNC) &_AlphaSimR_writeGeno,            5},
+    {""_AlphaSimR_writeOneHaplo"",       (DL_FUNC) &_AlphaSimR_writeOneHaplo,        6},
+    {""_AlphaSimR_writePlinkPed"",       (DL_FUNC) &_AlphaSimR_writePlinkPed,        5},
     {NULL, NULL, 0}
 };
 

---FILE: src/meiosis.cpp---
@@ -1160,6 +1160,126 @@ Rcpp::List createDH2(
   return Rcpp::List::create(Rcpp::Named(""geno"")=output);
 }
 
+// Samples gametes from individuals
+// [[Rcpp::export]]
+Rcpp::List createReducedGenome(
+    const arma::field<arma::Cube<unsigned char> >& geno, 
+    arma::uword nProgeny, const arma::field<arma::vec>& genMap, 
+    double v, bool trackRec, arma::uword ploidy,  
+    arma::vec& centromere, double quadProb, int nThreads){
+  arma::uword nChr = geno.n_elem;
+  arma::uword nInd = geno(0).n_slices;
+  //Output data
+  arma::field<arma::Cube<unsigned char> > output(nChr);
+  RecHist hist;
+  if(trackRec){
+    hist.setSize(nInd*nProgeny,nChr,ploidy/2);
+  }
+#ifdef _OPENMP
+#pragma omp parallel for schedule(static) num_threads(nThreads)
+#endif
+  for(arma::uword chr=0; chr<nChr; ++chr){ //Chromosome loop
+    arma::vec u(1);
+    arma::Mat<int> hist1, hist2;
+    arma::uword nBins = geno(chr).n_rows;
+    arma::Cube<unsigned char> tmpGeno(nBins,ploidy/2,nInd*nProgeny);
+    arma::Col<unsigned char> gamete1(nBins), gamete2(nBins);
+    arma::uvec x(ploidy);
+    for(arma::uword i=0; i<ploidy; ++i) 
+      x(i) = i;
+    for(arma::uword ind=0; ind<(nInd*nProgeny); ++ind){ //Individual loop
+      x = shuffle(x);
+      arma::uword progenyChr=0;
+      arma::uword par = ind/nProgeny;
+      for(arma::uword y=0; y<ploidy; y+=4){
+        if((ploidy-y)>2){
+          u.randu();
+          if(u(0)>quadProb){
+            //Bivalent 1
+            bivalent(geno(chr).slice(par).col(x(y)),
+                     geno(chr).slice(par).col(x(y+1)),
+                     genMap(chr),
+                     v,
+                     gamete1,
+                     hist1);
+            tmpGeno.slice(ind).col(progenyChr) = gamete1;
+            if(trackRec){
+              hist1.col(0) *= 100; //To avoid conflicts
+              hist1.col(0).replace(100,int(x(y))+1);
+              hist1.col(0).replace(200,int(x(y+1))+1);
+              hist.addHist(hist1,ind,chr,progenyChr);
+            }
+            ++progenyChr;
+            //Bivalent 2
+            bivalent(geno(chr).slice(par).col(x(y+2)),
+                     geno(chr).slice(par).col(x(y+3)),
+                     genMap(chr),
+                     v,
+                     gamete1,
+                     hist1);
+            tmpGeno.slice(ind).col(progenyChr) = gamete1;
+            if(trackRec){
+              hist1.col(0) *= 100; //To avoid conflicts
+              hist1.col(0).replace(100,int(x(y+2))+1);
+              hist1.col(0).replace(200,int(x(y+3))+1);
+              hist.addHist(hist1,ind,chr,progenyChr);
+            }
+            ++progenyChr;
+          }else{
+            //Quadrivalent
+            quadrivalent(geno(chr).slice(par).col(x(y)),
+                         geno(chr).slice(par).col(x(y+1)),
+                         geno(chr).slice(par).col(x(y+2)),
+                         geno(chr).slice(par).col(x(y+3)),
+                         genMap(chr),
+                         centromere(chr),
+                         v,
+                         gamete1,
+                         gamete2,
+                         hist1,
+                         hist2);
+            tmpGeno.slice(ind).col(progenyChr) = gamete1;
+            tmpGeno.slice(ind).col(progenyChr+1) = gamete2;
+            if(trackRec){
+              hist1.col(0) *= 100; //To avoid conflicts
+              hist1.col(0).replace(100,int(x(y))+1);
+              hist1.col(0).replace(200,int(x(y+1))+1);
+              hist.addHist(hist1,ind,chr,progenyChr);
+              hist2.col(0) *= 100; //To avoid conflicts
+              hist2.col(0).replace(100,int(x(y+2))+1);
+              hist2.col(0).replace(200,int(x(y+3))+1);
+              hist.addHist(hist2,ind,chr,progenyChr+1);
+            }
+            progenyChr += 2;
+          }
+        }else{
+          //Bivalent
+          bivalent(geno(chr).slice(par).col(x(y)),
+                   geno(chr).slice(par).col(x(y+1)),
+                   genMap(chr),
+                   v,
+                   gamete1,
+                   hist1);
+          tmpGeno.slice(ind).col(progenyChr) = gamete1;
+          if(trackRec){
+            hist1.col(0) *= 100; //To avoid conflicts
+            hist1.col(0).replace(100,int(x(y))+1);
+            hist1.col(0).replace(200,int(x(y+1))+1);
+            hist.addHist(hist1,ind,chr,progenyChr);
+          }
+          ++progenyChr;
+        }
+      } // End ploidy loop
+    } // End individual loop
+    output(chr) = tmpGeno;
+  } //End chromosome loop
+  if(trackRec){
+    return Rcpp::List::create(Rcpp::Named(""geno"")=output,
+                              Rcpp::Named(""recHist"")=hist.hist);
+  }
+  return Rcpp::List::create(Rcpp::Named(""geno"")=output);
+}
+
 // Converts    recHist (recombinations between generations) to
 //          ibdRecHist (recombinations since the base generation/population)
 // [[Rcpp::export]]"
gaynorr,AlphaSimR,6b8f3cfd391f16e285c4c9892c2d18c8ba50393f,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-09-23T13:32:38Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-09-23T13:32:38Z,"-fixed quadProb default
-swithced CO to 9-10 Morgan burn-in
-no more double sampling from gamma",R/Class-SimParam.R;R/misc.R;src/meiosis.cpp,False,True,True,False,80,60,140,"---FILE: R/Class-SimParam.R---
@@ -352,7 +352,7 @@ SimParam$set(
     private$.varE = numeric()
     private$.founderPop = founderPop
     private$.v = 1
-    private$.quadProb = 2/3
+    private$.quadProb = 0
     self$nThreads = getNumThreads()
     private$.version = packageDescription(""AlphaSimR"")$Version 
     invisible(self)

---FILE: R/misc.R---
@@ -146,19 +146,12 @@ editGenome = function(pop,ind,chr,segSites,allele,
       }
     }
   }
-  pop@gxe = vector(""list"",simParam$nTraits)
-  pop@gv = matrix(NA_real_,nrow=pop@nInd,
-                  ncol=simParam$nTraits)
-  if(simParam$nTraits>=1){
-    for(i in 1:simParam$nTraits){
-      tmp = getGv(simParam$traits[[i]],pop,simParam$nThreads)
-      pop@gv[,i] = tmp[[1]]
-      if(length(tmp)>1){
-        pop@gxe[[i]] = tmp[[2]]
-      }
-    }
-  }
-  validObject(pop)
+  # Reset population
+  PHENO = pop@pheno
+  EBV = pop@ebv
+  pop = resetPop(pop=pop, simParam=simParam)
+  pop@pheno = PHENO
+  pop@ebv = EBV
   return(pop)
 }
 
@@ -324,9 +317,9 @@ usefulness = function(pop,trait=1,use=""gv"",p=0.1,
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
-  response = getResponse(pop=pop,trait=trait,use=use,
-                         simParam=simParam,...)
-  response = sort(response,decreasing=selectTop)
+  response = getResponse(pop=pop, trait=trait, use=use,
+                         simParam=simParam, ...)
+  response = sort(response, decreasing=selectTop)
   response = response[1:ceiling(p*length(response))]
   return(mean(response))
 }
@@ -443,9 +436,7 @@ rotMat = function(X){
 #' 
 #' @export
 mutate = function(pop, mutRate=2.5e-8, returnPos=FALSE, simParam=NULL){
-  # This implementation is a place holder for future development
-  # The next implementation should be written in C++ for speed
-  
+
   # Mutation history variable
   IND=NULL; CHR=NULL; HAP=NULL; SITE=NULL
   

---FILE: src/meiosis.cpp---
@@ -50,7 +50,7 @@ arma::Mat<int> RecHist::getHist(arma::uword ind,
 // v, the interference parameter
 // n, the number of gamma deviates sampled at a time (affects performance, not results)
 arma::vec sampleChiasmata(double start, double end, double v, 
-                          arma::uword n=15){
+                          arma::uword n=40){
   // Sample deviates from a gamma distribution
   arma::vec output = arma::randg<arma::vec>(n, arma::distr_param(v,0.5/v));
   // Find locations on genetic map
@@ -67,6 +67,69 @@ arma::vec sampleChiasmata(double start, double end, double v,
   return output(find(output<end));
 }
 
+arma::field<arma::vec> sampleQuadChiasmata(double start, double exchange, double end, 
+                                           double v, arma::uword n1=40, arma::uword n2=8){
+  arma::field<arma::vec> output(4);
+  arma::vec u(1, arma::fill::randu);
+  
+  // Randomly set order of chromosome arms
+  arma::uvec arm = {0, 1, 2, 3};
+  arm = shuffle(arm);
+  double nearest, terminator, p;
+  
+  // First arm
+  output(arm(0)) = arma::randg<arma::vec>(n1, arma::distr_param(v,0.5/v));
+  output(arm(0)) = cumsum(output(arm(0))) + start;
+  if(arm(0)%2){ // Tail
+    terminator = end - exchange;
+  }else{ // Head
+    terminator = exchange;
+  }
+  while( output(arm(0))(output(arm(0)).n_elem-1) < terminator ){
+    arma::vec tmp = arma::randg<arma::vec>(n2, arma::distr_param(v,0.5/v));
+    tmp = cumsum(tmp) + output(arm(0))(output(arm(0)).n_elem-1);
+    output(arm(0)) = join_cols(output(arm(0)), tmp);
+  }
+  output(arm(0)) = output(arm(0))(find(output(arm(0))<terminator));
+  nearest = terminator - output(arm(0))(output(arm(0)).n_elem-1);
+  output(arm(0)) = output(arm(0))(find(output(arm(0))>0));
+  if(arm(0)%2){ // Tail
+    output(arm(0)) = sort(end-output(arm(0)));
+  }
+  
+  // All other arms
+  for(arma::uword i=1; i<4; ++i){
+    output(arm(i)).set_size(1+n2);
+    p = R::pgamma(nearest, v, 0.5/v, 1, 0);
+    u.randu();
+    u(0) = u(0)*(1-p)+p;
+    output(arm(i))(0) = R::qgamma(u(0), v, 0.5/v, 1, 0) - nearest;
+    if(output(arm(i))(0) < nearest){
+      nearest = output(arm(i))(0);
+    }
+    output(arm(i))(arma::span(1,n2)) = arma::randg<arma::vec>(n2, arma::distr_param(v,0.5/v));
+    output(arm(i)) = cumsum(output(arm(i)));
+    if(arm(i)%2){ // Tail
+      terminator = end - exchange;
+    }else{ // Head
+      terminator = exchange;
+    }
+    while( output(arm(i))(output(arm(i)).n_elem-1) < terminator ){
+      arma::vec tmp = arma::randg<arma::vec>(n2, arma::distr_param(v,0.5/v));
+      tmp = cumsum(tmp) + output(arm(i))(output(arm(i)).n_elem-1);
+      output(arm(i)) = join_cols(output(arm(i)), tmp);
+    }
+    output(arm(i)) = output(arm(i))(find(output(arm(i))<terminator));
+    if(arm(i)%2){ // Tail
+      output(arm(i)) += exchange;
+    }else{ // Head
+      output(arm(i)) = sort(exchange-output(arm(i)));
+    }
+  }
+  return output;
+}
+
+
 // Searches for an interval in x containing value
 // Result reported as left most element of the interval
 // Returns -1 if value is smaller than the values of x
@@ -144,9 +207,9 @@ arma::Mat<int> findBivalentCO(const arma::vec& genMap, double v){
   arma::uword startPos=0, endPos, readChr=0, nCO;
   double genLen = genMap(genMap.n_elem-1);
   
-  // Choose a starting location 2-3 Morgans away
+  // Choose a starting location 9-10 Morgans away
   arma::vec u(1, arma::fill::randu);
-  double start = u(0)-3;
+  double start = u(0)-10;
   
   // Find crossover positions
   arma::vec posCO = sampleChiasmata(start, genLen, v);
@@ -199,43 +262,11 @@ arma::field<arma::Mat<int> > findQuadrivalentCO(const arma::vec& genMap,
   // Sample the exchange point
   arma::vec u(1, arma::fill::randu);
   double exchange = u(0)*genLen;
-  
-  // Determine crossover postions
-  arma::field<arma::vec> posCO(4); // Each element is one arm
-  
-  // Arm 0 (1 and 2 heads)
-  u.randu();
-  double start = u(0)-3;
-  posCO(0) = sampleChiasmata(start, exchange, v);
-  
-  // Arm 2 (3 and 4 heads)
-  u.randu();
-  start = u(0)-3;
-  posCO(2) = sampleChiasmata(start, exchange, v);
-  
-  // Find CO nearest to exchange point
   u.randu();
-  start = u(0)-3;
-  if(posCO(0).n_elem>0){
-    start = std::max(start, 
-                     posCO(0)(posCO(0).n_elem-1)-exchange);
-  }
-  if(posCO(2).n_elem>0){
-    start = std::max(start, 
-                     posCO(2)(posCO(2).n_elem-1)-exchange);
-  }
+  double start = u(0)-10;
   
-  // Arm 1
-  posCO(1) = sampleChiasmata(start, genLen-exchange, v);
-  if(posCO(1).n_elem>0){
-    posCO(1) += exchange;
-  }
-  
-  // Arm 3
-  posCO(3) = sampleChiasmata(start, genLen-exchange, v);
-  if(posCO(3).n_elem>0){
-    posCO(3) += exchange;
-  }
+  // Determine crossover postions
+  arma::field<arma::vec> posCO = sampleQuadChiasmata(start, exchange, genLen, v);
   
   // Set chromatid configuration for chiasmata
   arma::field<arma::umat> chromatidPairs(4);
@@ -260,8 +291,6 @@ arma::field<arma::Mat<int> > findQuadrivalentCO(const arma::vec& genMap,
   maxCO *= 2;
   output(0).set_size(maxCO+1,2);
   output(1).set_size(maxCO+1,2);
-  output(0).zeros(); // For testing only
-  output(1).zeros(); // For testing only
   
   // Select centromeres (which chromosome and chromatid)
   arma::uvec chromosome(2, arma::fill::ones);"
gaynorr,AlphaSimR,82df2508ee2b103a62079090fc25c83efa38bece,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-09-06T09:06:18Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-09-06T09:06:18Z,-correcting error in gamma distribution,drafts/recombination.Rmd;src/meiosis.cpp,True,False,True,False,4,4,8,"---FILE: drafts/recombination.Rmd---
@@ -1,11 +1,11 @@
 ---
-title: ""Meiosis in AlphaSimR""
+title: ""Genetic Recombination in AlphaSimR""
 author: ""Chris Gaynor""
 date: ""`r Sys.Date()`""
 output: rmarkdown::html_vignette
 bibliography: AlphaSimR.bib
 vignette: >
-  %\VignetteIndexEntry{Meiosis}
+  %\VignetteIndexEntry{Recombination}
   %\VignetteEngine{knitr::rmarkdown}
   %\VignetteEncoding{UTF-8}
 ---

---FILE: src/meiosis.cpp---
@@ -52,12 +52,12 @@ arma::Mat<int> RecHist::getHist(arma::uword ind,
 arma::vec sampleChiasmata(double start, double end, double v, 
                           arma::uword n=15){
   // Sample deviates from a gamma distribution
-  arma::vec output = arma::randg<arma::vec>(n, arma::distr_param(v/2,1/v));
+  arma::vec output = arma::randg<arma::vec>(n, arma::distr_param(v,0.5/v));
   // Find locations on genetic map
   output = cumsum(output)+start;
   // Add additional values if max position less than end
   while(output(output.n_elem-1)<end){
-    arma::vec tmp = arma::randg<arma::vec>(n, arma::distr_param(v/2,1/v));
+    arma::vec tmp = arma::randg<arma::vec>(n, arma::distr_param(v,0.5/v));
     tmp = cumsum(tmp) + output(output.n_elem-1);
     output = join_cols(output, tmp);
   }"
gaynorr,AlphaSimR,03401f1be616e8eb90bd2383aa4d50efedb66156,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-08-22T15:54:46Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-08-22T15:54:46Z,-fixed an error with pullSegSiteGeno and pullSegSiteHaplo with variable number of sites per chromosome,DESCRIPTION;NEWS;R/crossing.R;R/pullGeno.R;man/pedigreeCross.Rd,False,True,True,False,46,40,86,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
 Version: 0.11.0
-Date: 2019-6-24
+Date: 2019-8-22
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: NEWS---
@@ -17,6 +17,7 @@ Changes in version 0.11.0
     -fixed a bug returning the first individual when selecting 0
     -fixed error in recombination track when using makeDH
     -fixed error causing epistatic effects to mask GxE effects
+    -fixed an error with pullSegSiteGeno and pullSegSiteHaplo with variable number of sites per chromosome
 
 Changes in version 0.10.0
   

---FILE: R/crossing.R---
@@ -588,6 +588,8 @@ makeDH = function(pop,nDH=1,useFemale=TRUE,keepParents=TRUE,
 #' elements in the id vector or they will be treated as unknown.
 #' @param matchID indicates if the IDs in founderPop should be 
 #' matched to the id argument. See details.
+#' @param founderNames names for individuals in the founder population. 
+#' Must be provided when matchID=TRUE.
 #' @param maxCycle the maximum number of loops to make over the pedigree 
 #' to sort it.
 #' @param DH an optional vector indicating if an individual 
@@ -599,10 +601,9 @@ makeDH = function(pop,nDH=1,useFemale=TRUE,keepParents=TRUE,
 #' @description 
 #' The way in which the user supplied pedigree is used depends on 
 #' the value of matchID. If matchID is TRUE, the IDs in the user 
-#' supplied pedigree are matched to the IDs in founderPop. If matchID 
-#' is FALSE, the IDs in the founderPop are not used. Instead, 
-#' founder individuals in the user supplied pedigree are randomly 
-#' sampled from founderPop.
+#' supplied pedigree are matched against founderNames. If matchID 
+#' is FALSE, founder individuals in the user supplied pedigree are 
+#' randomly sampled from founderPop.
 #' 
 #' @examples 
 #' #Create founder haplotypes
@@ -620,18 +621,11 @@ makeDH = function(pop,nDH=1,useFemale=TRUE,keepParents=TRUE,
 #' father = c(0,0,2,3:9)
 #' pop2 = pedigreeCross(pop, id, mother, father, simParam=SP)
 #' 
-#' ### OPTIONAL additional step
-#' # Replace id, mother, and father for pop2 with those found
-#' # in the user supplied pedigree. Be aware that these values 
-#' # won't match AlphaSimR's internal pedigree, so be sure you 
-#' # know what you are doing.
-#' pop2@id = as.character(id)
-#' pop2@mother = as.character(mother)
-#' pop2@father = as.character(father)
 #' 
 #' @export
 pedigreeCross = function(founderPop, id, mother, father, matchID=FALSE, 
-                         maxCycle=100, DH=NULL, useFemale=TRUE, simParam=NULL){
+                         founderNames=NULL, maxCycle=100, DH=NULL, useFemale=TRUE, 
+                         simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
@@ -642,6 +636,10 @@ pedigreeCross = function(founderPop, id, mother, father, matchID=FALSE,
   id = as.character(id)
   mother = as.character(mother)
   father = as.character(father)
+  if(matchID){
+    founderNames = as.character(founderNames)
+    stopifnot(length(founderNames)==nInd(founderPop))
+  }
   if(is.null(DH)){
     DH = logical(length(id))
   }else{
@@ -716,7 +714,7 @@ pedigreeCross = function(founderPop, id, mother, father, matchID=FALSE,
             founderIndicator = founderIndicator+1L
           }else{
             #Match founder
-            founderIndicator = match(id[i],founderPop@id)
+            founderIndicator = match(id[i],founderNames)
             if(is.na(founderIndicator)){
               stop(paste(id[i],""is missing in founderPop""))
             }
@@ -729,7 +727,7 @@ pedigreeCross = function(founderPop, id, mother, father, matchID=FALSE,
             founderIndicator = founderIndicator+1L
           }else{
             #Match founder
-            founderIndicator = match(mother[i],founderPop@id)
+            founderIndicator = match(mother[i],founderNames)
             if(is.na(founderIndicator)){
               stop(paste(id[i],""is missing in founderPop""))
             }
@@ -738,14 +736,20 @@ pedigreeCross = function(founderPop, id, mother, father, matchID=FALSE,
                                    output[[matchFather[i]]],
                                    crossPlan=crossPlan,
                                    simParam=simParam)
+          #Make the individual a DH?
+          if(DH[i]){
+            output[[i]] = makeDH(output[[i]],
+                                 useFemale=useFemale,
+                                 simParam=simParam)
+          }
         }else if(is.na(matchFather[i])){
           #Father is a founder
           if(!matchID){
             #Select the next founder
             founderIndicator = founderIndicator+1L
           }else{
             #Match founder
-            founderIndicator = match(father[i],founderPop@id)
+            founderIndicator = match(father[i],founderNames)
             if(is.na(founderIndicator)){
               stop(paste(id[i],""is missing in founderPop""))
             }
@@ -754,18 +758,24 @@ pedigreeCross = function(founderPop, id, mother, father, matchID=FALSE,
                                    founderPop[selFounder[founderIndicator]],
                                    crossPlan=crossPlan,
                                    simParam=simParam)
+          #Make the individual a DH?
+          if(DH[i]){
+            output[[i]] = makeDH(output[[i]],
+                                 useFemale=useFemale,
+                                 simParam=simParam)
+          }
         }else{
           #Both parents are in the pedigree
           output[[i]] = makeCross2(output[[matchMother[i]]],
                                    output[[matchFather[i]]],
                                    crossPlan=crossPlan,
                                    simParam=simParam)
-        }
-        #Make the individual a DH?
-        if(DH[i]){
-          output[[i]] = makeDH(output[[i]],
-                               useFemale=useFemale,
-                               simParam=simParam)
+          #Make the individual a DH?
+          if(DH[i]){
+            output[[i]] = makeDH(output[[i]],
+                                 useFemale=useFemale,
+                                 simParam=simParam)
+          }
         }
       }
     }

---FILE: R/pullGeno.R---
@@ -342,14 +342,14 @@ pullQtlGeno = function(pop, trait=1, chr=NULL, simParam=NULL){
 #' @export
 pullSegSiteGeno = function(pop, chr=NULL, simParam=NULL){
   if(class(pop)==""MapPop""){
-    allLoci = unlist(sapply(pop@nLoci, function(x) 1:x))
+    allLoci = unlist(c(sapply(pop@nLoci, function(x) 1:x)))
     lociTot = pop@nLoci
     nThreads = getNumThreads()
   }else{
     if(is.null(simParam)){
       simParam = get(""SP"",envir=.GlobalEnv)
     }
-    allLoci = c(sapply(simParam$segSites, function(x) 1:x))
+    allLoci = unlist(c(sapply(simParam$segSites, function(x) 1:x)))
     lociTot = simParam$segSites
     nThreads = simParam$nThreads
   }
@@ -612,14 +612,14 @@ pullQtlHaplo = function(pop, trait=1, haplo=""all"",
 pullSegSiteHaplo = function(pop, haplo=""all"",
                             chr=NULL, simParam=NULL){
   if(class(pop)==""MapPop""){
-    allLoci = unlist(sapply(pop@nLoci, function(x) 1:x))
+    allLoci = unlist(c(sapply(pop@nLoci, function(x) 1:x)))
     lociTot = pop@nLoci
     nThreads = getNumThreads()
   }else{
     if(is.null(simParam)){
       simParam = get(""SP"",envir=.GlobalEnv)
     }
-    allLoci = c(sapply(simParam$segSites, function(x) 1:x))
+    allLoci = unlist(c(sapply(simParam$segSites, function(x) 1:x)))
     lociTot = simParam$segSites
     nThreads = simParam$nThreads
   }

---FILE: man/pedigreeCross.Rd---
@@ -5,7 +5,8 @@
 \title{Pedigree cross}
 \usage{
 pedigreeCross(founderPop, id, mother, father, matchID = FALSE,
-  maxCycle = 100, DH = NULL, useFemale = TRUE, simParam = NULL)
+  founderNames = NULL, maxCycle = 100, DH = NULL, useFemale = TRUE,
+  simParam = NULL)
 }
 \arguments{
 \item{founderPop}{a \code{\link{Pop-class}}}
@@ -25,6 +26,9 @@ elements in the id vector or they will be treated as unknown.}
 \item{matchID}{indicates if the IDs in founderPop should be 
 matched to the id argument. See details.}
 
+\item{founderNames}{names for individuals in the founder population. 
+Must be provided when matchID=TRUE.}
+
 \item{maxCycle}{the maximum number of loops to make over the pedigree 
 to sort it.}
 
@@ -42,10 +46,9 @@ pedigree and a set of founder individuals.
 
 The way in which the user supplied pedigree is used depends on 
 the value of matchID. If matchID is TRUE, the IDs in the user 
-supplied pedigree are matched to the IDs in founderPop. If matchID 
-is FALSE, the IDs in the founderPop are not used. Instead, 
-founder individuals in the user supplied pedigree are randomly 
-sampled from founderPop.
+supplied pedigree are matched against founderNames. If matchID 
+is FALSE, founder individuals in the user supplied pedigree are 
+randomly sampled from founderPop.
 }
 \examples{
 #Create founder haplotypes
@@ -63,13 +66,5 @@ mother = c(0,0,1,3:9)
 father = c(0,0,2,3:9)
 pop2 = pedigreeCross(pop, id, mother, father, simParam=SP)
 
-### OPTIONAL additional step
-# Replace id, mother, and father for pop2 with those found
-# in the user supplied pedigree. Be aware that these values 
-# won't match AlphaSimR's internal pedigree, so be sure you 
-# know what you are doing.
-pop2@id = as.character(id)
-pop2@mother = as.character(mother)
-pop2@father = as.character(father)
 
 }"
gaynorr,AlphaSimR,f9c1d258be8d1b7de7884cd04864d36d879ed370,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-08-19T13:47:22Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-08-19T13:47:22Z,-fixed error causing epistatic effects to mask GxE effects,.Rbuildignore;NAMESPACE;NEWS;R/AlphaSimR.R;R/crossing.R;R/phenotypes.R;drafts/AlphaSimR.bib;drafts/gs.Rmd;drafts/meiosis.Rmd;man/pedigreeCross.Rd,True,True,True,False,172,8,180,"---FILE: .Rbuildignore---
@@ -3,3 +3,4 @@
 Notes.txt
 ^doc$
 ^Meta$
+^drafts$

---FILE: NAMESPACE---
@@ -95,8 +95,10 @@ exportClasses(TraitAG)
 import(Rcpp)
 importFrom(R6,R6Class)
 importFrom(methods,.hasSlot)
+importFrom(methods,classLabel)
 importFrom(methods,is)
 importFrom(methods,new)
+importFrom(methods,show)
 importFrom(methods,validObject)
 importFrom(stats,aggregate)
 importFrom(stats,coef)

---FILE: NEWS---
@@ -15,6 +15,8 @@ Changes in version 0.11.0
     
   Bug fixes
     -fixed a bug returning the first individual when selecting 0
+    -fixed error in recombination track when using makeDH
+    -fixed error causing epistatic effects to mask GxE effects
 
 Changes in version 0.10.0
   

---FILE: R/AlphaSimR.R---
@@ -1,6 +1,7 @@
 #' @useDynLib AlphaSimR, .registration = TRUE
 #' @import Rcpp
-#' @importFrom methods new validObject is .hasSlot
+#' @importFrom methods new validObject is .hasSlot 
+#' @importFrom methods show classLabel
 #' @importFrom stats aggregate rnorm qnorm var
 #' @importFrom stats coef dnorm lm pnorm qgamma
 #' @importFrom stats model.matrix rbinom

---FILE: R/crossing.R---
@@ -630,9 +630,8 @@ makeDH = function(pop,nDH=1,useFemale=TRUE,keepParents=TRUE,
 #' pop2@father = as.character(father)
 #' 
 #' @export
-pedigreeCross = function(founderPop, id, mother, father, matchID=FALSE,
-                         internalPed=TRUE, maxCycle=100, 
-                         DH=NULL, useFemale=TRUE, simParam=NULL){
+pedigreeCross = function(founderPop, id, mother, father, matchID=FALSE, 
+                         maxCycle=100, DH=NULL, useFemale=TRUE, simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }

---FILE: R/phenotypes.R---
@@ -37,8 +37,7 @@ calcPheno = function(pop,varE,reps,p,simParam){
     varE = simParam$varE
   }
   for(i in 1:simParam$nTraits){
-    traitClass = class(simParam$traits[[i]])
-    if(traitClass==""TraitAG"" | traitClass==""TraitADG""){
+    if(.hasSlot(simParam$traits[[i]], ""envVar"")){
       stdDev = sqrt(simParam$traits[[i]]@envVar)
       gv[,i] = gv[,i]+pop@gxe[[i]]*qnorm(p[i],sd=stdDev)
     }

---FILE: drafts/AlphaSimR.bib---
@@ -0,0 +1,144 @@
+### For Introduction
+
+@article{MaCS,
+   author = {Gary K. Chen and Paul Marjoram and Jeffery D. Wall},
+   title = {Fast and Flexible Simulation of DNA Sequence Data},
+   journal = {Genome Research},
+   volume = {19},
+   pages = {136-142},
+   year = {2009},
+   URL ={http://genome.cshlp.org/content/19/1/136}
+}
+
+@article{AlphaSim,
+   author = {Anne-Michelle Faux and Gregor Gorjanc and R. Chris Gaynor and Mara Battagin and Stefan M. Edwards and David L. Wilson and Sarah J. Hearne and Serap Gonen and John M. Hickey},
+   title = {AlphaSim: Software for Breeding Program Simulation},
+   journal = {The Plant Genome},
+   volume = {9},
+   number = {3},
+   year = {2016},
+   URL ={https://doi.org/10.3835/plantgenome2016.02.0013}
+}
+
+### For theory
+
+@book{Gallais,
+    title = {Quantitative Genetics and Breeding Methods in Autopolyploid Plants},
+    author = {A. Gallais},
+    year = {2003},
+    publisher = {INRA},
+    address = {Paris},
+    ISBN = {2-7380-1093-8}
+}
+
+@book{FalconerMackay,
+    title = {Introduction to Quantitative Genetics},
+    author = {D. S. Falconer and Trudy F. C. Mackay},
+    edition = {4},
+    year = {1996},
+    publisher = {Longman},
+    address = {Harlow},
+    ISBN = {978-0-582-24302-6}
+}
+
+@article{FinlayWilkinson,
+		title = {The analysis of adaptation in a plant-breeding programme},
+	volume = {14},
+	issn = {1444-9838},
+	url = {http://www.publish.csiro.au/cp/AR9630742},
+	doi = {10.1071/ar9630742},
+	language = {en},
+	number = {6},
+	urldate = {2017-12-13},
+	journal = {Australian Journal of Agricultural Research},
+	author = {Finlay, K. W. and Wilkinson, G. N.},
+	year = {1963},
+	pages = {742--754}
+}
+
+@article{gaynor_2017,
+	title = {A Two-Part Strategy for Using Genomic Selection to Develop Inbred Lines},
+	volume = {57},
+	issn = {0011-183X},
+	url = {https://dl.sciencesocieties.org/publications/cs/abstracts/57/5/2372},
+	doi = {10.2135/cropsci2016.09.0742},
+	language = {en},
+	number = {5},
+	urldate = {2017-10-20},
+	journal = {Crop Science},
+	author = {Gaynor, R. Chris and Gorjanc, Gregor and Bentley, Alison R. and Ober, Eric S. and Howell, Phil and Jackson, Robert and Mackay, Ian J. and Hickey, John M.},
+	year = {2017},
+	pages = {2372--2386},
+}
+
+@article{Falconer_85,
+	title = {A note on {Fisher}'s average effect and average excess},
+	volume = {46},
+	issn = {1469-5073, 0016-6723},
+	url = {https://www.cambridge.org/core/journals/genetics-research/article/note-on-fishers-average-effect-and-average-excess/26DFA92B3BA3EA92CD76847BFA21C5C8},
+	doi = {10.1017/S0016672300022825},
+	language = {en},
+	number = {3},
+	urldate = {2019-01-03},
+	journal = {Genetics Research},
+	author = {Falconer, D. S.},
+	month = dec,
+	year = {1985},
+	pages = {337--347}
+}
+
+@article{Massman13,
+   author = {Jon M. Massman and Andres Gordillo and Robenzon E. Lorenzana and Rex Bernardo},
+   title = {Genomewide Predictions from Maize Single-Cross Data},
+   journal = {Theoretical and Applied Genetics},
+   volume = {126},
+   number = {1},
+   pages = {12-22},
+   year = {2013},
+   URL ={https://doi.org/10.1007/s00122-012-1955-y}
+}
+
+@manual{EMMREML,
+    title = {EMMREML: Fitting Mixed Models with Known Covariance Structures},
+    author = {Deniz Akdemir and Okeke Uche Godfrey},
+    year = {2015},
+    note = {R package version 3.1},
+    url = {https://CRAN.R-project.org/package=EMMREML},
+}
+
+@article{sommer,
+    title = {Genome assisted prediction of quantitative traits using the R package sommer},
+    author = {Giovanny Covarrubias-Pazaran},
+    journal = {PLoS ONE},
+    year = {2016},
+    volume = {11},
+    pages = {1-15},
+    url = {https://doi.org/10.1371/journal.pone.0156744}
+}
+
+@article{xiang_2016,
+	title = {Genomic evaluation by including dominance effects and inbreeding depression for purebred and crossbred performance with an application in pigs},
+	volume = {48},
+	issn = {1297-9686},
+	url = {https://doi.org/10.1186/s12711-016-0271-4},
+	doi = {10.1186/s12711-016-0271-4},
+	number = {1},
+	urldate = {2019-04-23},
+	journal = {Genetics Selection Evolution},
+	author = {Xiang, Tao and Christensen, Ole Fredslund and Vitezica, Zulma Gladis and Legarra, Andres},
+	month = nov,
+	year = {2016},
+	pages = {92}
+}
+
+@article{fisher_1919, 
+  title={XV.The Correlation between Relatives on the Supposition of Mendelian Inheritance.}, 
+  volume={52}, 
+  DOI={10.1017/S0080456800012163}, 
+  number={2}, 
+  journal={Transactions of the Royal Society of Edinburgh}, 
+  publisher={Royal Society of Edinburgh Scotland Foundation}, 
+  author={Fisher, R. A.}, 
+  year={1919}, 
+  pages={399433}
+}

---FILE: drafts/gs.Rmd---
@@ -0,0 +1,17 @@
+---
+title: ""Genomic Selection Models""
+author: ""Chris Gaynor""
+date: ""`r Sys.Date()`""
+output: rmarkdown::pdf_document
+tables: true
+bibliography: AlphaSimR.bib
+vignette: >
+  %\VignetteIndexEntry{GS}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+
+
+
+# References
+

---FILE: man/pedigreeCross.Rd---
@@ -5,8 +5,7 @@
 \title{Pedigree cross}
 \usage{
 pedigreeCross(founderPop, id, mother, father, matchID = FALSE,
-  internalPed = TRUE, maxCycle = 100, DH = NULL, useFemale = TRUE,
-  simParam = NULL)
+  maxCycle = 100, DH = NULL, useFemale = TRUE, simParam = NULL)
 }
 \arguments{
 \item{founderPop}{a \code{\link{Pop-class}}}"
gaynorr,AlphaSimR,536461c20780d6dfd58407bf952446349f57bc2b,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-05-23T12:52:42Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-05-23T12:52:42Z,-fixed bug in pullSegSiteGeno and pullSegSiteHaplo,R/pullGeno.R,False,True,True,False,2,2,4,"---FILE: R/pullGeno.R---
@@ -342,7 +342,7 @@ pullQtlGeno = function(pop, trait=1, chr=NULL, simParam=NULL){
 #' @export
 pullSegSiteGeno = function(pop, chr=NULL, simParam=NULL){
   if(class(pop)==""MapPop""){
-    allLoci = c(sapply(pop@nLoci, function(x) 1:x))
+    allLoci = unlist(sapply(pop@nLoci, function(x) 1:x))
     lociTot = pop@nLoci
     nThreads = getNumThreads()
   }else{
@@ -612,7 +612,7 @@ pullQtlHaplo = function(pop, trait=1, haplo=""all"",
 pullSegSiteHaplo = function(pop, haplo=""all"",
                             chr=NULL, simParam=NULL){
   if(class(pop)==""MapPop""){
-    allLoci = c(sapply(pop@nLoci, function(x) 1:x))
+    allLoci = unlist(sapply(pop@nLoci, function(x) 1:x))
     lociTot = pop@nLoci
     nThreads = getNumThreads()
   }else{"
gaynorr,AlphaSimR,4777c44d655b2fa90273e5652dda11b1c36eeb60,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-04-10T08:07:23Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-04-10T08:07:23Z,"-added keepParents option to makeDH and self
-fixed bug returning top individual when selecting 0",DESCRIPTION;NEWS;R/Class-SimParam.R;R/crossing.R;R/founderPop.R;R/selection.R;inst/doc/intro.Rmd;inst/doc/intro.html;man/SimParam_addTraitADE.Rd;man/SimParam_addTraitADEG.Rd;man/SimParam_addTraitAE.Rd;man/SimParam_addTraitAEG.Rd;man/makeDH.Rd;man/self.Rd;src/misc.cpp;vignettes/AlphaSimR.bib;vignettes/intro.Rmd;vignettes/theory.Rmd,True,True,True,False,367,117,484,"---FILE: DESCRIPTION---
@@ -1,8 +1,8 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 0.10.0
-Date: 2019-3-15
+Version: 0.10.1
+Date: 2019-4-10
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: NEWS---
@@ -1,3 +1,11 @@
+Changes in version 0.10.1
+  
+  New features
+    -added keepParents option to makeDH and self
+    
+  Bug fixes
+    -fixed bug returning top individual when selecting 0
+
 Changes in version 0.10.0
   
   New features

---FILE: R/Class-SimParam.R---
@@ -1465,8 +1465,8 @@ SimParam$set(
 #' @param nQtlPerChr number of QTLs per chromosome. Can be a single value or nChr values.
 #' @param mean a vector of desired mean genetic values for one or more traits
 #' @param var a vector of desired genetic variances for one or more traits
-#' @param relAA the relative variance of additive-by-additive effects compared 
-#' to the additive effects
+#' @param relAA the relative value of additive-by-additive variance compared 
+#' to additive variance in a diploid organism with allele frequency 0.5
 #' @param corA a matrix of correlations between additive effects
 #' @param corAA a matrix of correlations between additive-by-additive effects
 #' @param useVarA tune according to additive genetic variance if true. If 
@@ -1560,8 +1560,8 @@ SimParam$set(
 #' @param var a vector of desired genetic variances for one or more traits
 #' @param meanDD mean dominance degree
 #' @param varDD variance of dominance degree
-#' @param relAA the relative variance of additive-by-additive effects compared 
-#' to the additive effects
+#' @param relAA the relative value of additive-by-additive variance compared 
+#' to additive variance in a diploid organism with allele frequency 0.5
 #' @param corA a matrix of correlations between additive effects
 #' @param corDD a matrix of correlations between dominance degrees
 #' @param corAA a matrix of correlations between additive-by-additive effects
@@ -1664,8 +1664,8 @@ SimParam$set(
 #' @param nQtlPerChr number of QTLs per chromosome. Can be a single value or nChr values.
 #' @param mean a vector of desired mean genetic values for one or more traits
 #' @param var a vector of desired genetic variances for one or more traits
-#' @param relAA the relative variance of additive-by-additive effects compared 
-#' to the additive effects
+#' @param relAA the relative value of additive-by-additive variance compared 
+#' to additive variance in a diploid organism with allele frequency 0.5
 #' @param varGxE a vector of total genotype-by-environment variances for the traits
 #' @param varEnv a vector of environmental variances for one or more traits
 #' @param corA a matrix of correlations between additive effects
@@ -1799,8 +1799,8 @@ SimParam$set(
 #' @param varEnv a vector of environmental variances for one or more traits
 #' @param meanDD mean dominance degree
 #' @param varDD variance of dominance degree
-#' @param relAA the relative variance of additive-by-additive effects compared 
-#' to the additive effects
+#' @param relAA the relative value of additive-by-additive variance compared 
+#' to additive variance in a diploid organism with allele frequency 0.5
 #' @param corA a matrix of correlations between additive effects
 #' @param corDD a matrix of correlations between dominance degrees
 #' @param corAA a matrix of correlations between additive-by-additive effects

---FILE: R/crossing.R---
@@ -419,6 +419,8 @@ randCross2 = function(females,males,nCrosses,nProgeny=1,
 #' @param pop an object of \code{\link{Pop-class}}
 #' @param nProgeny total number of selfed progeny per individual
 #' @param parents an optional vector of indices for allowable parents
+#' @param keepParents should previous parents be used for mother and 
+#' father. 
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
 #' @return Returns an object of \code{\link{Pop-class}}
@@ -437,7 +439,8 @@ randCross2 = function(females,males,nCrosses,nProgeny=1,
 #' pop2 = self(pop, simParam=SP)
 #' 
 #' @export
-self = function(pop,nProgeny=1,parents=NULL,simParam=NULL){
+self = function(pop,nProgeny=1,parents=NULL,keepParents=TRUE,
+                simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
@@ -473,12 +476,19 @@ self = function(pop,nProgeny=1,parents=NULL,simParam=NULL){
   if(simParam$isTrackRec){
     simParam$addToRec(tmp$recHist)
   }
-  return(newPop(rawPop=rPop,
-                mother=rep(pop@id,each=nProgeny),
-                father=rep(pop@id,each=nProgeny),
-                origM=rep(pop@mother,each=nProgeny),
-                origF=rep(pop@father,each=nProgeny),
-                simParam=simParam))
+  if(keepParents){
+    return(newPop(rawPop=rPop,
+                  mother=rep(pop@id,each=nProgeny),
+                  father=rep(pop@id,each=nProgeny),
+                  origM=rep(pop@mother,each=nProgeny),
+                  origF=rep(pop@father,each=nProgeny),
+                  simParam=simParam))
+  }else{
+    return(newPop(rawPop=rPop,
+                  mother=rep(pop@id,each=nProgeny),
+                  father=rep(pop@id,each=nProgeny),
+                  simParam=simParam))
+  }
 }
 
 #' @title Generates DH lines
@@ -490,6 +500,8 @@ self = function(pop,nProgeny=1,parents=NULL,simParam=NULL){
 #' @param nDH total number of DH lines per individual
 #' @param useFemale should female recombination rates be used. 
 #' This parameter has no effect if, recombRatio=1.
+#' @param keepParents should previous parents be used for mother and 
+#' father. 
 #' @param simParam an object of 'SimParam' class
 #' 
 #' @return Returns an object of \code{\link{Pop-class}}
@@ -508,7 +520,8 @@ self = function(pop,nProgeny=1,parents=NULL,simParam=NULL){
 #' pop2 = makeDH(pop, simParam=SP)
 #' 
 #' @export
-makeDH = function(pop,nDH=1,useFemale=TRUE,simParam=NULL){
+makeDH = function(pop,nDH=1,useFemale=TRUE,keepParents=TRUE,
+                  simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
@@ -535,13 +548,21 @@ makeDH = function(pop,nDH=1,useFemale=TRUE,simParam=NULL){
   if(simParam$isTrackRec){
     simParam$addToRec(tmp$recHist)
   }
-  return(newPop(rawPop=rPop,
-                mother=rep(pop@id,each=nDH),
-                father=rep(pop@id,each=nDH),
-                origM=rep(pop@mother,each=nDH),
-                origF=rep(pop@father,each=nDH),
-                isDH=TRUE,
-                simParam=simParam))
+  if(keepParents){
+    return(newPop(rawPop=rPop,
+                  mother=rep(pop@id,each=nDH),
+                  father=rep(pop@id,each=nDH),
+                  origM=rep(pop@mother,each=nDH),
+                  origF=rep(pop@father,each=nDH),
+                  isDH=TRUE,
+                  simParam=simParam))
+  }else{
+    return(newPop(rawPop=rPop,
+                  mother=rep(pop@id,each=nDH),
+                  father=rep(pop@id,each=nDH),
+                  isDH=TRUE,
+                  simParam=simParam))
+  }
 }
 
 #' @title Pedigree cross

---FILE: R/founderPop.R---
@@ -364,19 +364,35 @@ sampleHaplo = function(mapPop,nInd,inbred=FALSE,ploidy=NULL,replace=TRUE){
 #' @export
 quickHaplo = function(nInd,nChr,segSites,genLen=1,ploidy=2L,inbred=FALSE){
   ploidy = as.integer(ploidy)
-  if(inbred){
-    nHap = nInd
-  }else{
-    nHap = ploidy*nInd
-  }
+  nInd = as.integer(nInd)
+  nChr = as.integer(nChr)
+  segSites = as.integer(segSites)
   if(length(segSites)==1) segSites = rep(segSites,nChr)
   if(length(genLen)==1) genLen = rep(genLen,nChr)
+  centromere = genLen/2
+  
   genMap = vector(""list"",nChr)
-  haplotypes = vector(""list"",nChr)
+  geno = vector(""list"",nChr)
   for(i in 1:nChr){
     genMap[[i]] = seq(0,genLen[i],length.out=segSites[i])
-    haplotypes[[i]] = matrix(sample(0:1,nHap*segSites[i],replace=TRUE),
-                             nrow=nHap, ncol=segSites[i])
+    geno[[i]] = array(sample(as.raw(0:1),
+                             nInd*ploidy*segSites[i],
+                             replace=TRUE),
+                      dim = c(segSites[i],ploidy,nInd))
+    if(inbred){
+      if(ploidy>1){
+        for(j in 2:ploidy){
+          geno[[i]][,j,] = geno[[i]][,1,]
+        }
+      }
+    }
   }
-  return(newMapPop(genMap,haplotypes,inbred,ploidy))
+  return(new(""MapPop"",
+             nInd=nInd,
+             nChr=nChr,
+             ploidy=ploidy,
+             nLoci=segSites,
+             geno=as.matrix(geno),
+             genMap=as.matrix(genMap),
+             centromere=centromere))
 }
\ No newline at end of file

---FILE: R/selection.R---
@@ -143,9 +143,9 @@ selectInd = function(pop,nInd,trait=1,use=""pheno"",gender=""B"",
   take = order(response,decreasing=selectTop)
   take = take[take%in%eligible]
   if(returnPop){
-    return(pop[take[1:nInd]])
+    return(pop[take[0:nInd]])
   }else{
-    return(take[1:nInd])
+    return(take[0:nInd])
   }
 }
 
@@ -226,7 +226,7 @@ selectFam = function(pop,nFam,trait=1,use=""pheno"",gender=""B"",
   famMeans = aggregate(response,list(families=availFam),mean)
   response = famMeans$x
   #Select families
-  bestFam = order(response,decreasing=selectTop)[1:nFam]
+  bestFam = order(response,decreasing=selectTop)[0:nFam]
   bestFam = famMeans$families[bestFam]
   take = which(allFam%in%bestFam)
   take = take[take%in%eligible]
@@ -315,7 +315,7 @@ selectWithinFam = function(pop,nInd,trait=1,use=""pheno"",gender=""B"",
       warn <<- TRUE
       return(index)
     }else{
-      return(index[1:nInd])
+      return(index[0:nInd])
     }
   }
   take = unlist(sapply(unique(families),selInFam))

---FILE: inst/doc/intro.Rmd---
@@ -1,8 +1,9 @@
 ---
 title: ""Introduction to AlphaSimR""
-date: ""`r Sys.Date()`""
+author: ""Chris Gaynor""
+date: ""March 27, 2019""
 output: rmarkdown::html_vignette
-bibliography: bibliography.bib
+bibliography: AlphaSimR.bib
 vignette: >
   %\VignetteIndexEntry{Introduction}
   %\VignetteEngine{knitr::rmarkdown}

---FILE: inst/doc/intro.html---
@@ -10,8 +10,9 @@
 
 <meta name=""viewport"" content=""width=device-width, initial-scale=1"">
 
+<meta name=""author"" content=""Chris Gaynor"" />
 
-<meta name=""date"" content=""2019-03-15"" />
+<meta name=""date"" content=""2019-03-27"" />
 
 <title>Introduction to AlphaSimR</title>
 
@@ -266,7 +267,8 @@
 
 
 <h1 class=""title toc-ignore"">Introduction to AlphaSimR</h1>
-<h4 class=""date""><em>2019-03-15</em></h4>
+<h4 class=""author""><em>Chris Gaynor</em></h4>
+<h4 class=""date""><em>March 27, 2019</em></h4>
 
 
 
@@ -344,7 +346,7 @@ <h2>Full Code</h2>
 <div class=""sourceLine"" id=""cb11-16"" data-line-number=""16""></div>
 <div class=""sourceLine"" id=""cb11-17"" data-line-number=""17""><span class=""co""># Examining the Results</span></div>
 <div class=""sourceLine"" id=""cb11-18"" data-line-number=""18""><span class=""kw"">plot</span>(<span class=""dv"">0</span><span class=""op"">:</span><span class=""dv"">20</span>, genMean, <span class=""dt"">xlab=</span><span class=""st"">&quot;Generation&quot;</span>, <span class=""dt"">ylab=</span><span class=""st"">&quot;Mean Genetic Value&quot;</span>, <span class=""dt"">type=</span><span class=""st"">&quot;l&quot;</span>)</div></code></pre>
-<p><img src=""data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAYAAAAUg66AAAAEDWlDQ1BJQ0MgUHJvZmlsZQAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VVBg/m8AAC9+SURBVHgB7Z0J/E3VFseXQiKSRkPyZChKzyxpIBRPqJQGYwPFU9KEFD0ilWgyNVC90mRIKClJxqekMg8pvUqaJFFPdd7+rffOde/9n3vP+fvfe8659/7W5/Pnnmnvfb7n3HX3XnvttQpZRoRCAiRAAgEQOCiAOlklCZAACSgBKiC+CCRAAoERoAIKDD0rJgESoALiO0ACJBAYASqgwNCzYhIgASogvgMkQAKBEaACCgw9KyYBEqAC4jtAAiQQGAEqoMDQs2ISIAEqIL4DJEACgRGgAgoMPSsmARKgAuI7QAIkEBgBKqDA0LNiEiABKiC+AyRAAoERoAIKDD0rJgESoALiO0ACJBAYASqgwNCzYhIgASogvgMkQAKBEaACCgw9KyYBEqAC4jtAAiQQGAEqoMDQs2ISIAEqIL4DJEACgRGgAgoMPSsmARKgAuI7QAIkEBgBKqDA0LNiEiABKiC+AyRAAoERoAIKDD0rJgESoALiO0ACJBAYASqgwNCzYhIgASogvgMkQAKBEaACCgw9KyYBEqAC4jtAAiQQGAEqoMDQs2ISIAEqIL4DJEACgRGgAgoMPSsmARKgAuI7QAIkEBgBKqDA0LNiEiABKiC+AyRAAoERoAIKDD0rJgESoALiO0ACJBAYASqgwNCzYhIgASogvgMkQAKBEaACCgw9KyYBEqAC4jtAAiQQGAEqoMDQs2ISIAEqIL4DJEACgRGgAgoMPSsmARKgAuI7QAIkEBgBKqDA0LNiEiABKiC+AyRAAoERoAIKDD0rJgESoALiO0ACJBAYASqgwNCzYhIgASogvgMkQAKBEaACCgw9KyYBEqAC4jtAAiQQGAEqoMDQs2ISIAEqIL4DJEACgRGgAgoMPSsmARKgAuI7QAIkEBgBKqDA0LNiEiCBfCmgX375RT7++GPZvXu3/Pbbb6RHAiRAAgUi4EkB/fvf/5YOHTrIYYcdJqeddpqsXbtWbr/9drnllltkz549BWoALyYBEshdAq4K6D//+Y+0bdtWNm7cKKNHj5bixYsrrTPPPFOeeOIJ6du3b+7S452TAAkUiEBht6vfeust+fLLL1UBHX744TJ48GC95OKLL5ZSpUpJ165dxbIsKVSokFtRPE4CJEACMQRce0CbNm2SmjVrCpRPvNSvX1++/vpr+eyzz+IPcZsESIAEXAm4KqC//OUvsnjxYvn222/zFPbCCy9I4cKFpXz58nmOcQcJkAAJuBFwHYI1a9ZMKlSoIK1bt5Z+/frJn3/+KegVvfbaazJ+/Hi54oorpGjRom718DgJkAAJ5CFQyNhvrDx743Zg6r1bt27y4Ycfxhxp3769TJo0SUqXLh2znxskQAIk4IWAJwWEgtDz+eCDD7T3gx4P7EInn3yylzp4DgmQAAk4EvCsgByv5k4SIAESKAABVxvQsmXLpH///kmrWLBgQdLjPEgCJEACTgRcFdAhhxwiZcuWjbl2165dsn79eoGHNB0RY9BwgwRIIB8EDngIBtt1nz595Pvvv5cpU6bko0qeSgIkQAL/I3DACgiXwwGxSpUqsnPnTl0nFiRUrElbt26demdXrlxZDj744CCbw7pJgAQ8EHB1RExWxjfffCN//PGH/PTTT8lOS+mxUaNGyZ133hlT5ogRI6RMmTJSr149qVatmlSvXl3efPPNmHO4QQIkED4CrjYg9HJmzpwZ03IonR9++EEef/xxOemkk3z1hIZPUrRXNvyQBg4cKOeee646RcI+hSEhfJSWLFkif/3rX2Pazg0SIIHwEHAdgs2ZM0cuvPDCPC0uUaKEfrkfeughOfXUU/McT9cOLH6FAkK7II0bN9bFsEuXLo2psk6dOlKrVi2ZPHlyzP5UbTz88MMybtw4xzVyqaqD5ZBAQQgUK1ZMVyyULFmyIMWk9VrXHhCWYIQ5+BjsT717984D6dprr5WJEyfm2Z+qHc8++6yMGTOGCihVQFlOygk0bdpUPv30U43hlfLCU1SgqwJKUT0pLWbv3r2yb98+KVKkiLRr107DhcRXAK/to446Kn53yraxCBfhSBo1apSyMlkQCaSSAOyhYRdHBYQ1X++9957ntt9www2ezy3oiYg7BMdHdCsxxMI6NNh6LrnkEqldu7b6Jt1zzz2CHsqjjz5a0Op4PQmQQBoJOCogfMHdvJ+j2+SnAsKwCs6Pq1at0sWx+B+9kS1btqgCmj17tq7Sx7Ds6quvjm6m589Y9+YmHtbwuhXB4yRQYAIIlYPZ6IsuuqjAZQVSAFbDZ4OYIZnehoneaH3xxRcHfEtmVs066KCDXP/Mw7IGDBhwwPXwQhIoCIFPPvnEatOmjVWxYkXLrEpwLMqMECzzA+14LCw7C+QHBI35448/BqI44ytFLwhSrlw5jV8Uf9zrNsKOwM3A7Q8B+hGsjUICfhL4/PPPpUuXLup20rx5c41OAb+3TBXHIVj8zSAu9GOPPSbfffedfjFxHF9QeB8jWH2YZ8ni74XbJJCJBOB6MmzYMLVtwuSxefNmtYNm4r1Et9m1B2SGM5oVA4ZezDrBEfC4447T5RerV68WeCFTSIAE0kMAP/JDhgxRh1/UsGHDBt0Os29Pfki49oAWLVqkwchg5EWv5+ijj5ZnnnlG4Ih4/fXXq59Bfios6LlYboG8ZF4Ehrl//vOfXk7lOSQQKgLGRqPvrrEzCsIiw62kUqVKoWpjKhrjqoCQ9aJhw4aRxaYIzbF8+XIdgyJFD6AgXxh6R34I6kJKIOQrGzRokBiDccJqM8EPImHjeSBnCWC0ceONN+q7/corr2S1r5mrAoKhdevWrZGXAWu/MPWHtVdHHHGE7kdcIL8MskiIiF4Z1nihR4bsrBQSyAYC27Ztk1tvvVX92kaOHKlrG7PhvpLdQ+Luw/+vOv3009Xeg9khzHhhG0Mw2ILuu+8+HZL53TVEz2bo0KFqlEM8IgoJZDIB2HnuuOMO/VE95ZRTdGIH2WZyQVwVEAzOTz75pLzxxhuyfft2tfvAUQ854u+++27p2bNnIFlR4YyIVfroBVFIIBMJYPYYi5qrVq2qHvyY1EGomUMPPTQTb+eA2uw4BFuxYoVCgDaGYJkD1lwhyBf+Vq5cKfPmzZO6desKgn8FIWgHFttRSCDTCOBHc7KJ0oAfcJgSXn/9dV1WlGn3kYr2OvaAFi5cqCE2sNASvZ/du3dr8kE7yiDWX0EpBaV8UnHjLIME/CaAmS1kE4Yd9fnnn5eXX35Ze/FY05ir4qiAevXqJc8995yGmujRo4cGpUd4C8x+UUiABPJPAJmEYbZACJcJEybI22+/rbPL+S8pu65wVEAYg8IINnfuXIFlHgYyzDyhRwRtjXErIiJSSIAEkhPAlHqTJk30O4QoDUhzBb8eyv8IOCqgaDjly5fXlfEI+I4eEKbB4ZmJNVdQUvPnz48+nZ9JgAQMAXgsI5LoZZddphM3H330kVxwwQVkE0fAVQFFn9+gQQNdE4bZsJdeeklgtYc/EIUESOB/BPDduO6667TXc8YZZ+hi0SuvvDKQmeJMeCaOs2DJGo4ZMCxvgIcmvKQR/J1CArlOABM1DzzwgDzyyCNy1VVXqS+P7aib62yS3b8nBQRPaFjtoXiQERXL/5GUEGEBjj322GTl8xgJZDUBzGxhphjLkmDbQTRRE6Mnq+85lTeXUAHBwxjThFA6MKQVL15cp96RigdGNQoJ5DqBf/3rX4IZY6QvR5YWzHJR8kfAUQFhCr579+4a+B12H0wbwpiWLSEA8oeIZ5NALIEdO3boxAxWB2A5UqdOnWJP4JZnAo5GaKw0R0xlE/ZRZ77gA0Tl45kpT8xSAvBghgtKzZo15cgjj9SZLiqfgj1sxx4Qej8UEiCB/QTeffdd/VFGOBpkjIE3M6XgBBwVUMGLZQkkkB0EkHGiX79+agcdNWpU5mafCOnjcByChbStbBYJ+EYAER/Gjh2rwy3MasERN2NT3/hGLf8VsQeUf2a8IssJvP/+++pMiJlfDLdOPvnkLL/j4G6PPaDg2LPmkBH46aef1M5j8m0JMk8gKgSVT3ofkicFBGcrOCIi0b0t8H+AUyKFBLKBAN5vONhi6IX3Gk62lPQT8KSAzjvvPOlmQrJinQsECgmL6xCwDOEFghS0BTmTuDo/yKeQuXWbTLryt7/9TZdRIGTGuHHjBPGuKP4QcFVAmzZtEkxBYuFp48aNtVWFChXSwPQPPvighhmA35Cfgpfm9ttv14wcRYsWlWOOOUb9Mg4//HD1Rr355ps1iJqfbWJdmUcASygQkRBhZmD3qV+/fubdRIa32NUIjcBJyMXllOIGTlhIH4KYQVWqVPEFBVLTYikIlKAdlbFMmTK6jV4Q1q1hoezUqVM16NOJJ57oS7tYSeYQwPt6zTXXaK/5nXfe0Z585rQ+u1rqqoDgcIU1L8iQevzxx8fc/axZszRGNGIG+SX333+/9nyQLhprcJxk+PDh0qpVK83egbi7FBIAAQzXJ06cqL12pHNCChw7zDAJBUPAdQiG7ikyY3Tu3FmDjyEHGPJST5kyRRMDohfiZxT/VatWqYEwkfIBRiRJhM0Ka3UoJAACn332mcaueuqppzS6Z//+/al8QvBquCqgYsWKqRcohjcIPoZeENKIIBoiMqbCWctPgR0KiRHdBJEa/eyZubWHx4MjgAgOsO/A2Lx06VIuowjuUeSp2XUIhiugdJCIEL0f9EDQbcXQzK9sqNGthuKDEoKLPCLNwcaDhYFI0QwliV86rOZHeAQM0yi5SwDvCIKDIXAefrSc7Ji5Syccd+6ogGDzQQ8Cq+B37typcYHim4tpeFvQnfVLMGsBZYiEiF27dlW/jfi6mzdvLm+++aacffbZ8Ye4nSMEpk2bprGY8Z7cddddUriw46ueIzTCe5uOTwUKCLmpEVQbPQp8TiZ+KiC0AzNumJ3D9D9mNNDGffv2aaD8ChUqaI8oWXuTHcOL6+V+fvnlFzXMJyuLx/wnsGvXLo3WiSB6yJwLMwElvAQcFdDf//53wR8E3qHICR9GgQ8QlFEqXQBatGjhKUslot/BOE8JD4EFCxboBAWWUqCHjrVclHATcFRA0U3eu3evDsMQByVecAy9pWwa6iDwmpfga7A5YbaNEjwBrOGCu8WLL74omOWC5z4lMwi4zoLBFpQonxG8R8855xwug8iMZ511rYRfz6RJk7SXjqwUiOBJ5ZNZj9mxB/Trr79qVxYPFeus4PfTunXrmDvDw8eivVKlSomf6Ufglb127dqYtiTaQPwWBNWnZB+BFStW6Mp1zMhixrNOnTrZd5M5cEeOCgi+P+eff74a8TB7gGUPsLdEC/ZhSQRmovDZLxk9erRcfPHFaoAeNGiQTr8nqpvTronIZO5+/CAOGDBAZs+erZMjcJD18/3LXHLhbLmjAkJT4T+BP9h40ItAMO4wCFJDI089puMRJBwu9ZTsJ4BnjZXqSAuOH72NGzd6stVlP5nMvsOECsi+LaTlwR8EU89btmyRypUrqwE22XII+/p0/I+ezdChQ/VlxKJCOCJSspcAnAiR7hgTIfjxYUD47HnWrgoItwoP6L59++oKc2wvX75cA5RhePaPf/wjkOlOtAfjfvwyUrKTwHfffSe33XabOpVi6I11h5TsIuA6CwZnv7Zt22qXFy+B7VuBodATTzyhiikIJDA+Nm3aVGMBBVE/60wfAUQlRDJMhEPFBAcmO6h80sc7yJJde0BYT4UAYBhzI+AXcmBDYAjGDBjG45gRoyEwyMeYPXV/8MEHuoQCkx6M1ZM9zzXRnbj2gBAREZkgoXziBSuMsdAPSyEoJFAQAnAmhPc9VqwjKy9sPQj5S8luAq4KCCveYQTE9Ge8vPDCC7rIj2Ev4slwOz8EXn31Vf2RwzUYbqFXTckNAq5DsGbNmgkWeMIRERkiMT5HrwgBvMePH69xgeJ9hHIDHe+yoAQQLqNPnz4a4gUB7mBXpOQWAdce0GGHHSbTp0/X2SbE4oF3NGJBDxs2TB0RH3roodwixrtNCYHJkyfLqaeeqguJsYSCyiclWDOuENceEO6oVq1amjUABkL0ftDjgV2ISdsy7nkH3mDYCxFnCsHj5s2bp1lMAm8UGxAYAU8KCK3D6m8YnZm6JLBnldEVY+j+yCOPqN8Y4i1hOM+A8Bn9SFPSeE8KCMGdkIAQDolOOcCwKp5CAokIwLDczSQJgA8ZlvYwVVIiUrm331UBIR0PFqZiGv70009X35/cw8Q7PhAC8FJHGqUHHnhAbYZYTkEhgWgCrgoIoU8x/EIcZj/DbkQ3kp8zjwAMy+j1YJ3eypUrpWLFipl3E2xx2gm4zoLByxnT8FQ+aX8WWVEBYnMjOiHcN+BQiOQAVD5Z8WjTchOuCgjrrT799FNZs2ZNWhrAQrOHAGZJ69atqzOmiMmMcC4UEkhGwHUIhuBk8P9B3OeOHTtqbyh+9gIrlim5SwAzXCNGjNCYUQ8++KDma8tdGrzz/BBwVUD4JXv55Ze1zEThTamA8oM8u85FWiT8QME3DHbCY489NrtukHeTVgKuQzAE+cZCQfx99dVX8t577+nq+B07dkT2p7WFLDy0BLAWEEOu9u3ba542Kp/QPqrQNsy1B4SWhzEgWWiJ5kDDfv75Z+nVq5f69MDIXLt27Ry4a95iOgi49oDCGpAsHTBYpjuBpUuX6hourBFctWoVlY87Mp6RhIBrD4gByZLQy6FDv//+uwwfPlwee+wxjYSZKFdcDiHhraaAgKsC8hqQDHGDKNlJAE6FXbp0kXLlymnKY6akzs7nHMRduQ7BGJAsiMcSjjqxlAK9HjgV3nDDDZqLi8onHM8mW1rh2gNiQLJsedT5u49169ZpZMLSpUvLhx9+qP5f+SuBZ5OAOwHXHlCmBCTbs2eP2PGKmKrH/cEnOgNOhVg8igBhV199tS6lwFIcCgmkg4BrDwiVhikg2ahRo2Tnzp2amNAGAi9crD/67bffdBfCPYwdO1Zatmxpn8L/PRDYvHmz9nrgVAhlfsIJJ3i4iqeQwIET8KSAUHxYApLB2zY6QP6kSZNk4MCBcu6556pH7q5duwTxheEchzhGSOFMcScAL3cECbvzzjs1OwXTLLkz4xkFJ+CqgBA43PZwRRxfhNK0BdERg47l+/jjj0ujRo0E7gK22FlTEUQNbc6PoBwvca737t0r27dvz0/RoTwX6baxah3ZbpGHC6F2KSTgF4GECgjez3gx3333XUGKXKRhHjlypKZNsRuHGREkLCxZsqS9y/f/MRxDO+MFcYcnTpwYv9t1G3nHe/bs6XoeFBUSM2ayYJ0fMo7iRwRDLjvrbSbfE9ueWQQcFRAMkVhgiDAcWN0c3R0fMGCADBo0SBAp8bTTTpN77rlH7r33Xl/vGr0PxJ0pUqSItGvXTtemxTcAX6ijjjoqfrfrNgyuXoyuUMiZ/IWFQ+GQIUM0TvNll13myoUnkEA6CDgqoDlz5qj9BDaUBg0aROqFIrK/eNWrV9dZEqyU91MBoQ0LFizQXheM45gmRjvxS441Sei5QSk+++yz8uijj0bazg//I4BFxYhUiB+QZcuWMT4zX4xACThOw2ONT40aNWKUj1Mr0XXfunWrYHGiX4JhFfxSkBQRMaox8wWluGXLFm3C7Nmz9RiGYJhGpuwnsHDhQjXKw7kUSpvB4fez4adgCDj2gL788ktxWlqBLnvlypUjLT3++OMFIVthI/LLDoQpYsxs4Q+/5LZgrRIEa5SQX9zLMMq+Ntv/xw8EYjYhmy2M9q1atcr2W+b9ZQgBxx5QnTp11Lgcfw+XXnqp1KtXL7IbdhbMkDkpq8hJPn1ALwiC9UpUPvuhv/7669qbhXMmwupS+exnw0/BE3BUQE2aNFEFhKFYIoGh+tVXX5Uzzjgj0SncHyABuEt07txZZwifeeYZnRFEaiUKCYSJgKMCwlQ0ekGYCduwYUOe9kL5YPiDKfru3bvnOc4dwRLAxABseEcffbSsXr1akFiAQgJhJOBoA8JME/KBtW3bVqfaGzdurDNMdo4nZLdEeFZ4z7Zp0yaM95WTbYLTKJL/4UcDvdOGDRvmJAfedOYQcOwBoflwsnvjjTcEfj9QSJh9uuOOOzTlCoZoMGjSfyQ8D3rmzJn6YwHfLAydqXzC82zYksQEHHtA9ulIyTN48GDdhBETdgV06ynhIYClFDfddJMuRZk+fbq6JoSndWwJCSQnkLAHFH8ZcoFR+cRTCXYbQ2G4I8AFAYt04RdFIYFMIpC0B5RJN5JLbUVvFN7eWE4xbtw4ueiii3Lp9nmvWUSACijDHiY8vjt16qQ2Oth6ypYtm2F3wOaSwH4Cnodg+y/hp6AIIM4RhlmXX365ThBQ+QT1JFhvqgiwB5Qqkmks59dffxXEOIJrBBbiwseHQgLZQMCTAsLCRQT3wkpzJCqMl/fffz9+F7dTRABhUjt06CBwDsUiXMToppBAthBwVUAI23D++ecL3PjR/c/0IFyZ9ODg0YwUyEOHDlUHw0xqO9tKAl4IuCogdPsRDxrTvEcccYSXMnlOAQkgxMjNN98sWEjK3OsFhMnLQ03AVQEh3AZWl1P5+PMcEV8JwdUqVaqkQy72OP3hzlqCIeA6C4aFjAjNilAOlPQSwHIKDHO7du0qr7zyCoe76cXN0kNAwLUHhOUYWBV/9tlnS8eOHbU3BK/oaEGwK8qBE4BjIdLhPPfcczJr1qyYmEsHXiqvJIHwE3BVQMicAGMoBKvfnYQKyImKt33IcQa/Hiz4PdBA+t5q4lkkED4CrkOw8847TxDIPNlf+G4rM1qEoPCIu4S8ZnPnzj2gLB6ZcadsJQk4E3BVQM6X7d/7448/7t/gJ88EkLED8ZYQXH/YsGE60+j5Yp5IAllCwHUIhvtEEj4sfETwedgrIPh/z549GrrVzsmuB/hPUgIIEI+gYWvXrtVspGGIp520wTxIAmkk4NoDgiMifqnhDY1EgPAHQkZUZCRFuM8RI0aksXnZVTTsPUhldMghh8jSpUtDEcw/uwjzbjKNgGsPaNGiRYIY0FiFjV4PYgIhyHmJEiXk+uuv1yn6TLvpINqLVEdwaUAMbUSZpJAACYi49oC+/vprDe+JNUhYjoEV2MuXL9dZG0RLRJ4ppEmmJCYAPypkD8HQi8onMSceyT0CrgoINgp459qCRZGLFy/WTds7GotUKc4E1q9fL2eddZYMHDhQ+vXr53wS95JAjhJwVUDwzIW9B2l4MOOFbQzBYAu67777dEiGZQNBCZaKwLaCeNVhEwQMgwPnyJEjpUePHmFrHttDAoETcFVAMDg/+eSTGgBr+/btaveBTQjZF+6++27p2bOnDsf8vBPYU26//XZdL4VUzcccc4wgZRCGiGgXFnLu3r3bzyblqQtG5hYtWsiECRPkyiuvzHOcO0iABERcjdCAhMWR7dq1EyzBwN/KlStl3rx5Urdu3Zhc8X4A/fzzzwVpgeA5jHYhV32ZMmV0G70gDBexjmrq1KkawOvEE0/0o1kxdcyfP1+Qxvr555+Xli1bxhzjBgmQwH4CnhQQTkdPAylgMBuGLz2m5jGd7Lfcf//92vOBb1Ki+ocPH6450DFURC8tP4Lgai+++KLrJfB9+v777/OchyEhlM+MGTNUUeY5gTtIgAQiBFyHYDgTRmZE5cNMGIY4cKLDEOiWW25RZ8RIaT58gF2lS5cuCZUPmgB/JdiskFgxv4LFt8cee6zrH8JkOMVkhqsCllWgl0YhARJITsC1B4QQrOjtIPfU6NGjNTsqioRD3dVXXy27du3SrKnJq0ndUaSJxizctddem7RQDIPKly+f9Byng6eccorgz00wxKtWrVqe0woXLqxD0zwHuIMESCAPAVcFhKEOjL4bN25UI6+dKfXiiy/WeDWIXYNhB2wyfghCg0AJIQ86jLuw8cAAjaiNsAF99tlnGtZizpw5uoTEjzaxDhIggQMj4KqANm3aJDVr1lTlE19F/fr1BY6K+NL7taYJmUDhAoDZNyg/zMjFS/PmzTWUKabA0yWwAb3zzjsaQiO6DixZgVuA7SMVfSzoz4hogB5tGDPcwr6I9pUrVy5oTHnqx7PesWOHHH/88XmOBb0DQ36YSDp37pynKWF0TYlvpKsCgmLBkAdfqvgX94UXXhAMOQ5kqBPfkPxsV6lSRWe48GXatm2bKkB4Y+PlRfhY9IjSLWPHjpXJkyfr/UfXhXTJcAGIZxV9TlCf8UIixU8Yv+RYpIv2QQmFTcAMX/KgXTucuEABYXSCzkC83HjjjZ7MCfHX+bpthk9JxbwYlpn1surVq2eZaWXLGKItE5jMGjRokHXUUUdZxiCc9PpcO2g8ni2TNjmUt22UpmXW74Wyba+99prVpk2bULbNpEOyTM87lG0zESos84MbyrZ5aZRrDwgzX9OnT9dZJdhfIEgNDGnfvr089NBD+pn/kAAJkEB+CbgqIBRYq1YtgX8MQobCJgSfINiFTj755PzWx/NJgARIIELAUQFhPO4U6dD2j7Gvhv0FUrFiRXsX/ycBEiABzwQcFdDEiRPVydBrKWas5/VUnkcCJEACEQKOCgg+NRAs7rzwwgvl3HPPVe/iyFX8QAIkQAIpIOCogDB9h2wNmGbHws7Zs2frwk+kj0FgLb+cDlNwfyyCBEggxAQc14KhBwQnvnHjxqmjIRZ1wlHMTJPKCSecILfeequuiA/xfbFpJEACGUDAUQFFtxuOhueff7463WH5w8MPPywIVI8of9WrV5chQ4ZEn87PJEACJOCZQCE4C3k++/8nYunFs88+K/fee6+uhj+AIvJbZcacDyWNISqCpIVN4Gm8d+9e3z3XvXDAzCvCm1QKMLpmonbCExo/ulWrVk10SmD74Qm9YcMGqVGjRmBtKEjFnhUQlA5SNONvxYoVui4GcW+QL97JDbwgjeK1JEACuUEgqQJC9EEonJdeekmVDuLfIAohlA5iQ9MYnRsvCe+SBNJFwFEBvfvuu3LbbbcJFlZiKIHQG1A6iAFkT9Gnq0EslwRIIHcIOCqgUaNGqSMiAtLD2AxDdDJ57rnnkh3mMRIgARJwJOCoWRBKAnF3IFjqTyEBEiCBdBBw7AGloyKWSQIkQALxBFz9gOIv4DYJkAAJpIoAFVCqSLIcEiCBfBOgAso3Ml5AAiSQKgJUQKkiyXJIgATyTYAKKN/IeAEJkECqCFABpYrk/8vhujjvQLEuLZkEyRIZV7DOKmzilIYqvo1Bcotvi9s2FZAbIY/HTeYETZSIfGAmi4gMHTrU45XpPw1ZZE866aQ8fwixEpQ89dRTYrKqOFb/9NNPyznnnCPFixeXBg0ayIIFCxzPS9fOrVu3auqi+NTeSMuDOOjxLN2y9KainVOmTNEUO4cccoiUKVNGVyYgVVC0hPkdjG5n9GdHR8ToE/jZncCePXukQ4cO0rBhQ01W+NFHH0nv3r112codd9zhXkCaz8AXCaul0b5oKVKkSPSmb59nzJghJj2QHHzwwXnqXLhwofTo0UPgjT9mzBiZMGGCtGrVSpYvX67JEfJckOIdUD5IRY6V+fGyevVqWb9+vfTt21dKliwZOYw8demUWbNmCTLSIBHnY489ps7BiETRunVrTRaBJBFhfwcT8jHdNUoBCZh01VapUqUsM6SIlHT33Xdr3jQTyiGyL4gP5ouEcCuWiWoZRPUxdZqkg5ZJp63tqVatmnXooYfGHMeG6WHoOdEHTjnlFOuqq66K3pWWz8ibVqJECcvEudI2mi9+TD1GGWpePDM0i9mf7g0Tj8syYUosM/yKVGWilWobzbpN3RfmdzDSaIcPHIIlVM3eD8ydO1d/pYsVKxa5qF27dmKSxmkUgcjOAD588sknWmvt2rX1fy82hHQ1E2mdFi1aJOgBXXfddXmiKWBIsW7dOo1DHt0GsJwzZ070rrR8NgklpU+fPgnrQs8WS5SwINtPjhjioScYHX3CToVuZ5IN8zuY7GFRASWj4/HY5s2b8wT5stNVb9++3WMp6TkNXxrzq67hdTFUKF26tCCOE1Jt+y2IM461hVAoToKccxCbnX0OttHedH/pYUMZMWKE5r2z647+/+OPP9ZhY7du3ZQjcsWPHDky7e266KKLpGXLltFNESwAxyJxk7FY94f5HYxpeNwGFVAckAPZ3LVrV5589PiiQxAhMUjBlwbG5i1btogZFgpeZpMGWVq0aOH7LA+yrMBekUgQFRFiUg3HnALDPmaknOwyMScWcAOLsJMJWCJBJ3ofsE8hPnr//v1l2LBhyS5L+bHFixdrj6hfv36CGF2QML+DyQDQCJ2MjsdjMOZGd49xmb29b98+j6Wk5zT8WkPZIJ4TxNhgdGYJRvKpU6dqbyg9Nee/VDvsi80uvgRMjQclv//+u/YiEZbVjgBq7FLStGlT7TUhUYOxaaW9ecuWLZMLLrhAGjVqpD8odoVhfgftNjr9zx6QE5V87kPcpPhMsjt37tRSomdL8llsSk5v0qRJRPnYBSLAHOwYq1atsneF4n/719xmZzfKZmsM/fYu3/+HcsRMlK187AYgQihiRiMuc7pl/vz50rx5c7VDYWYs2uYY5ncwGRcqoGR0PB7Dw4+39Xz99dd69YknnuixlPSctnLlSoF9IFrwawkFlGw4FH2+X5/BEWKzs+sFW/gMBanMMTxcsmSJDnXsduF/Wwmk26XhnXfe0bRYUEAwyB922GHRzZAwv4MxDY3boAKKA3Igm3gp4GsT7TmLZI74xa5bt+6BFJmyazp16qQhdaMLnDlzpmBIEXTbotuEz+gB1axZUxNhRh/Dr32zZs2id/n+edu2bZqUE2mpogXDWNi20ukLtGbNGlU+7du312GzrfSi2xHmdzC6nXk+O0zNc1c+CXz11VeW+QW0jF3FMqlvLOO5axlvVcsYKvNZUupPNw596i8CP5EdO3ZYxohqGTuGZZRPjF9J6mtOXuKDDz5oGU/nPCeZZJiW+YJZJiOvBb+h4cOH67Yxouc5N107TAoeRz8gk4jBMjHSrWnTplnG6GtNmjRJn7uZOUtXU7Rco1zUZ8ooP2vixIkxf8YxUs8J8zuYDI4kO8hj3gnAac0ME/TFhfIx3ryW6WV4LyBNZ8J5zczUWGa4pW0ztgzLGDFVUaapSk/FJlJAYGZmd/SLbX4t1THRLM3wVGaqTkqkgEwvyDIGfeWItpkhoWU8klNVrWM5UCyoK9HfE088EbkurO9gpIEOHxiS1TzZVInhK0hlVKFCBddA/qmq02s5mEFCbje0DWuswi4w7Joem1SsWDF0TYWRHE6mWPMXtiwxYX4HnR4kFZATFe4jARLwhQCN0L5gZiUkQAJOBKiAnKhwHwmQgC8EqIB8wcxKSIAEnAhQATlR4T4SIAFfCFAB+YKZlZAACTgRoAJyosJ9JEACvhCgAvIFMyshARJwIkAF5ESF+0iABHwhQAXkC2ZWQgIk4ESACsiJCveRAAn4QoAKyBfMrIQESMCJABWQExXuIwES8IUAFZAvmFkJCZCAEwEqICcq3EcCJOALASogXzCzEhIgAScCVEBOVLiPBEjAFwJUQL5gZiUkQAJOBKiAnKhwHwmQgC8EqIB8wcxKSIAEnAhQATlR4T4SIAFfCFAB+YKZlZAACTgRoAJyosJ9JEACvhCgAvIFMyshARJwIkAF5ESF+0iABHwhQAXkC+ZwV4Isn99//324G8nWZSUBKqCsfKzuN7V27Vrp1q2bVKtWTY4++mgxee2lbNmycuuttwrSOGeaLF++XBYtWhRpdo8ePaRu3bqRbX4IJwEqoHA+l7S2CjniW7RoIe+//77ceeedsmrVKlm2bJn06dNHHn30UWnevHla60914b///rucfvrpsnnz5kjR2G7Tpk1kmx/CSaBwOJvFVqWLwM8//ywtW7aUypUry7x586RYsWKRqho2bCi1atWSCy64QN56662MUUSWZQn+oqV79+7Rm/wcUgLsAYX0waSrWRimbNq0SR544IEY5WPXh17D4MGDdUhm78P/Tz75pNSuXVtKliwpDRo0kJkzZ0YOL126VPeh3PPOO09Kly4tp512mkybNi1yDj7s3r1bevXqJZUqVdLy27dvL59//nnkHLStcePG8uabb0qFChXk7LPPlh9++EF+++03GTBggCrHEiVK6LDxxhtvlD179uhfo0aNtIwhQ4ZIly5d9PM999wjnTp1ipT9zTff6JCzfPnyOuRs166dbNmyJXLc6z1ELuCH1BAwvxyUHCJgvqRW0aJFLWPn8XzX9913n1W4cGHriiuusGbMmGHddNNNVqFChaxXXnlFy3jjjTd02/SqLGNXsp566inLKAXdZ77kes6ff/5pGcVlHXPMMdZdd91lGeVknXXWWZaxP1nGAK7nzJo1yzr44IOtE044wbr88ssto6B0/6WXXqrnoR1Tp061rr32WnR3tJx9+/ZZkyZN0m3snz17tl6Dz3Xq1NHPuNeaNWtaRvFZkydPtl566SWrfv361uGHH259+eWXeo6Xe9AT+U9KCaDrSskhAq1bt7bMMCvmjo0Nxfr444/176OPPrLwZ3ozes6PP/5olSpVyjJDmphrOnbsaFWpUkX34csLhQAFYcsXX3yh+yZMmKC7pkyZottz5syxT7FMD8YyPRrL9G50HxQQyjG9l8g5v/zyi2V6Xtb48eMj+/AB+4ytSvdBweA6KCJbohXQww8/rIpt48aN9mFVelB2xlit+7zcQ+RifkgZAdqAzJubS2J6LjoUir7nn376SYc30fswrMGwBAbqXbt26ZBqyZIlkVOqVq0qL774onz77beRfeecc07kM4ZQsC/hWsh7770npsehQ7jocjBUi97GuRh62VK8eHFZuXKlbsLYDEMz2oSZOgzBvMiKFSvE9HgEbbalTJkyOmyMrzvZPdjX8v/UEaACSh3LjCgJhmbTCxEoHSgEiOnhyPz58yPtHzhwYOSzbaPp27dvZF/0B8yo2YKp/GgxQz0xQy/dhfNQ55lnnhl9in6GTShaoLyiZfHixYI2YabODLlUWcKehHZ7ka1btwpsP/ECRWd6aDG7k91DzIncSAkBGqFTgjFzCoECMv1nWbhwYaTRxr4jTZs2jfwdeeSRkWPoKUDw5Ycyif9Dz8IW9K4SCco0th35448/8pTx6aefxlxmhkaRbWOjkVatWslBBx0kL7/8sjpMogd06qmnRs5x+wA/Jxiz4wUzgmYYGbM72T3EnMiNlBCgAkoJxswppEmTJjqcwjT1mjVr8jQcX1Rjv4nsN8ZbwZcSwy38b/8Zm4xccskl8uuvv0bOTfYB5aA3BYdBuwwoQmPY1hm5RNdi6AZFMXbsWGnbtq0cccQRgqHYJ598osoM10E5QaDcnAR1w+fJ2LMih6FI33777TxDz8gJ/OALASogXzCHpxLYVObOnSvo2TRr1kwwnT19+nSdMu/fv79Ur15d1q9fLx06dNBGw1/IGJzFzGyposB0tpkJk1tuuUVq1KjhOJXvdLc9e/YU9IJ69+6tU/hfffWVoD70apI5Pp5xxhmCHtHTTz8txiAtGMp17dpVlRm2ITgOexOm76Hg4gUOlpDOnTvrdbBb3XDDDbJt2za55ppr4k/ntp8EUmbOZkEZRcD0RiyjFCyjRHS63LxzllEQ1oUXXmht2LAh5l6M7Uan1zEVj/PMkg2dCscsFsSeQTK2Ft22/8Hs2ciRI+1N68MPP9TZK5RhekE6TR49u2XPgmEGLVqGDh1qGRuOugLAhcAoFGvMmDHqTmB6bHoqXAPQPkzrQ6JnwbBtDOp6r3bdmJZHu23xeg/2+fw/NQQKoRjzUCg5TADDLswoxRt/45Fg5gk2mUrGaIxh1IHKzp07deh23HHHeS4Cryl6P2hjkSJFHK/bu3ev2pfgrJhIsPAWZcEuRAmeABVQ8M+ALSCBnCVAG1DOPnreOAkET4AKKPhnwBaQQM4SoALK2UfPGyeB4AlQAQX/DNgCEshZAlRAOfvoeeMkEDwBKqDgnwFbQAI5S4AKKGcfPW+cBIInQAUU/DNgC0ggZwlQAeXso+eNk0DwBKiAgn8GbAEJ5CwBKqCcffS8cRIIngAVUPDPgC0ggZwlQAWUs4+eN04CwROgAgr+GbAFJJCzBKiAcvbR88ZJIHgCVEDBPwO2gARylgAVUM4+et44CQRPgAoo+GfAFpBAzhKgAsrZR88bJ4HgCVABBf8M2AISyFkCVEA5++h54yQQPAEqoOCfAVtAAjlL4L8EJtQpsPmzZwAAAABJRU5ErkJggg=="" /><!-- --></p>
+<p><img src=""data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAYAAAAUg66AAAAEDWlDQ1BJQ0MgUHJvZmlsZQAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VVBg/m8AAC+gSURBVHgB7Z0J3FXT+sefSFGiMleqS0qDsasRjVJdFFK4hgxlKAqV5CKiwZihMkThmiJNSoWQopQQ0ShyEyoSiVvs//o997+PM+z37HPe95y99jnn93w+b509rbX2d+/znLWe9aznKeUYEQoJkAAJWCCwi4U6WSUJkAAJKAEqIL4IJEAC1ghQAVlDz4pJgASogPgOkAAJWCNABWQNPSsmARKgAuI7QAIkYI0AFZA19KyYBEiACojvAAmQgDUCVEDW0LNiEiABKiC+AyRAAtYIUAFZQ8+KSYAEqID4DpAACVgjQAVkDT0rJgESoALiO0ACJGCNABWQNfSsmARIgAqI7wAJkIA1AlRA1tCzYhIgASogvgMkQALWCFABWUPPikmABKiA+A6QAAlYI0AFZA09KyYBEqAC4jtAAiRgjQAVkDX0rJgESIAKiO8ACZCANQJUQNbQs2ISIAEqIL4DJEAC1ghQAVlDz4pJgASogPgOkAAJWCNABWQNPSsmARKgAuI7QAIkYI0AFZA19KyYBEiACojvAAmQgDUCVEDW0LNiEiABKiC+AyRAAtYIUAFZQ8+KSYAEqID4DpAACVgjQAVkDT0rJgESoALiO0ACJGCNABWQNfSsmARIgAqI7wAJkIA1AlRA1tCzYhIgASogvgMkQALWCFABWUPPikmABKiA+A6QAAlYI0AFZA09KyYBEqAC4jtAAiRgjQAVkDX0rJgESIAKiO8ACZCANQJUQNbQs2ISIAEqIL4DJEAC1ghQAVlDz4pJgASogPgOkAAJWCNABWQNPSsmARKgAuI7QAIkYI0AFZA19KyYBEiACojvAAmQgDUCVEDW0LNiEiABKiC+AyRAAtYIUAFZQ8+KSYAEqID4DpAACVgjQAVkDT0rJgESSEsBbdu2TZYuXSq//PKL/P7776RHAiRAAiUikJIC+s9//iNdunSRPffcU4466ij57LPP5Prrr5d+/frJr7/+WqIG8GISIIHCJeCrgP773//KaaedJitXrpT77rtPypUrp7ROOOEEGTt2rPTt27dw6fHOSYAESkSgtN/Vr7/+uqxfv14V0N577y233HKLXnLmmWfKXnvtJRdeeKE4jiOlSpXyK4rHSYAESCCGgG8PaNWqVVK/fn2B8omX4447TjZs2CBffvll/CFukwAJkIAvAV8F9Le//U3mz58vGzduTCjs+eefl9KlS0vVqlUTjnEHCZAACfgR8B2CtW7dWqpVqyYdO3aUa6+9Vv78809Br2jatGny8MMPy7nnnitlypTxq4fHSYAESCCBQCljv3ES9sbtwNR79+7d5cMPP4w50rlzZxk3bpxUrFgxZj83SIAESCAVAikpIBSEns8HH3ygvR/0eGAXqlu3bip18BwSIAES8CSQsgLyvJo7SYAESKAEBHxtQAsWLJCBAwcmreKtt95KepwHSYAESMCLgK8CKlu2rBx00EEx127dulWWL18u8JCmI2IMGm6QAAmkQaDYQzDYrq+66irZvHmzPPfcc2lUyVNJgARI4H8Eiq2AcDkcEGvVqiVbtmzRdWKESgIkQALpEPB1RExW2HfffSd//PGH/PTTT8lO4zESIAES8CTg2wNCL2fq1KkxF0Pp/PDDD/LYY49JpUqV5PPPP485zg0SIAESSIWArxEaoTf69++fUFb58uXl6KOPlvvvvz/hWCHseOCBB2TMmDGea+QK4f55j+EnsPvuu+uKhQoVKoS2sb49oNC23HLDsBD39ttvpwKy/BxYfdEEWrVqJXCjQQyvsIpvDyisDbfdLizCRTiSJk2a2G4K6ycBTwK1a9f23B+mnZ4KCGu+3nnnnZTbefXVV6d8Lk8kARIgAZeApwKCZ7Of97NbAP6nAoqmwc8kEByBd999V7799ls544wzgqs0gzV5TsNfc801GnQegedT+ctge4pdFGJTu4tlMUtHIYF8JrBs2TINlXz22WfrwvBcvVdPBZTOzfz444/pnF7ic++55x656aabYsoZNmyYVK5cWf7+978Lxr116tSR2bNnx5zDDRLIBwLr1q3T0DgwMCNW1+rVq/V9z9V78xyCxd8M4kKPGjVKNm3apI6HOI5eBnodCFYfZIoexCaKjs6IeESDBg2SNm3aaHA0rFPD0hDEKkL3FK4CFBLIdQJY8nTHHXfI+PHjpXfv3rJmzRoJ8/R6qrx9e0Bff/21dvXwZd5tt900L9iBBx6oyy8+/fRTQe/DpsAZEjNRUJIXX3yxLo5duHChHH744TJy5EibTWPdJFBiAsjBN3ToUO3ZI0MNFoHfdttteaF8AMe3BzRv3jwNRgaNi17PfvvtJ0899ZTAEfGKK66QL774osSQS1IA1qH16tUroYgePXrIo48+mrCfO0ggFwhs375dRx133nmntGvXThYtWiSHHHJILjQ9rTb69oCQ9aJx48a62BSZMRCaAz0MpOFBih70QHbs2JFWpSU9GQ/HrbNTp06aNii+TBik99133/jd3CaBUBOAOQNe9kgGge/Z22+/Lf/+97/zUvngQfgqIIBYu3Zt5KFhaIMsGRCsA4MgLlBQAsUHNwGMfxs1aqQzX3hgbrxqtAU9s6efflq6du0aVLNYDwmUiAB+UB955BGNLvHGG2/oJMqLL76Y92GPfRVQ06ZN1d6DoPSY8cI2hmAwBqN7iCFZzZo1SwQ/nYsxrIKyQUYOtAW/GPBKxhARMn36dD2GIdgll1ySTtE8lwQCJ4BY608++aTaeCZNmiQvv/yyTJkyRY488sjA22KjwpTWgkETI/jYm2++qdPd+OKjV7TLLrvI4MGDE6bFbdzIzp07VRF98803arNCKqHiyKuvvirDhw/3vfS9997TtWADBgzwPZcnkIAXgTlz5miqK5g2YGhu3ry512nF3oc1YOgs5NxaMBi89thjD2nQoIHe/FlnnSWwtey66676t2TJEnnttdekYcOGoRmbohcEqVKliv5f3H+OPfZYGTJkiO/l7du3F6w2ppBAugTcCBOY0brrrrty1os53fv2Ot9zFmzu3LnSr18/NT5jKNOtW7eYiIfIAwallI9ywAEHCP78BMoYSppCAqkSQAC/m2++WTDUuvHGG2Xy5Mnq2pLq9fl4nqcN6Morr5RnnnlGQ0307NlTZ76giGCVp5AACaRHALO26FXXq1dPIyjAebdPnz4Fr3xA0VMB4ZcdKZdnzZolcP2GtoY/EBz+YBzDrBMiItoQLLcoV65cSn/nnXeejSayThJQAvCbGzt2rBx22GGCYRdcQzDkYibhv14QzyHYX4dFqlatqivjsTr+/fffV4s9DM8wvmIF7qWXXqprUqKvyebn++67T84880yBV+i//vUvNYQXVV8uxEMpqu3cn9sEMJOF7wxWDSCkMWyLFA8CyA2frpipb8cAdo444gjklU/38hKfv2LFCsf00hwzW1XisopbwJ577ukYl4DiXs7r8pSA8ZFzmjVrpt+NGTNmWL1LM1pxPvroI6tt8KvccwjmoaciuzADBs2OBXEIRo9Fn0ELejYYUyMkKhbpUUjANgHMaOG7gPAYl112mZgvvnTo0MF2s0Jff0oKCD4/WIlbt25dnXo3ml39guB1DIu+DUFGVnRtGfvHBn3W6RKALRSTNi1atJATTjhBVq1aJRdccEFS04B7Lf9PshgVPQs4IGIdClbCw/CLqXes/Tr++OOts8M0OGKiUEjABgH88GHpBOyh6PVgZgsOhZT0CHgaoTEFf9FFF+mCT6y3AmhAzof4I+nh4dkkkEgAC0SxMgCLneHN7DrsJp7JPX4EPBUQZpgQ4gJrqQjXDyGPFwoBxMaCgy784RCZE7OxlJIR8FRA6P1QSIAE/kfgt99+k7vvvlvgAoIEDIhKSC/4zLwdngooM0WzFBLIfQITJkzQXo+ZWtcoDNWrV8/9mwrRHVABhehhsCnhIQB3E/R2tm3bpsuSMMNFyTyBlKbhM18tSySBcBJAji3EFu/YsaNOxGD5BJVP9p4VFVD22LLkHCIAOw8SLNSvX1+D7MGfB5MwiHlFyR6BlOgad2p59tlnYwLQw/kK3p8UEsh1Agi0h5XqiIOFvxEjRtDlJKCHmpICOvnkk6W7CcmK7ikECunjjz/WKXqmvgnoSbGajBNAXjv488BzGQ62CIeaj5knMg4ugwX6KiB0ReF4hRxgmAmAIDA8AtPfe++9GqoDfkMUEsglAggvYxZTCxJZfvLJJ5rYMpfany9t9VVAiNDvpjyOv2nE28GvCGIGUUggFwjA1nPddddpxhT03hEQnvF57D05XwWENDyIAwQv0Hh55ZVXNEY0YgZRSCDsBODBjADtSFyAHv2pp54a9ibnfft8/YAQBRFBlc4//3yNZ4tQGPgVgbEOAcGwQJVeoXn/nuT0DeJ9RegWRCccNWoUl1CE6Gn6KiBkfsBq+H/84x8J4+QuXbrI6NGjQ3Q7bAoJxBLAYlHENUcGF9h6kMeOEh4CvgoITT344IM1ESHi/yDQEkJhYGiGrKm2BTNymzZt0jZVrlzZdnNYf0gIIJwMbD2YYh8zZow6FoakaWxGFAFPBQSbD345kAljy5YtGhco6hr9iGl4VxAhMUhZv369BsZ/4YUXNC88khJC9tprL83S2rZtW7n11ltjUgkF2T7WZZcA0nJj1fo///lPDQZfvnx5uw1i7UUSKFIBwRnr9NNPly+//FIds4oswRwIUgF99dVXGhANrgCwP8FvAz0fbCM6HaI3vvTSSzJx4kTBDN6hhx6arOk8lkcEvvjiCw2Hit4PMtwyEHwOPFy/oNFhO27iFDkmIqNjDItFNs34JTlt2rRxTBK4Is8p6QEGpS8pwcxdv2PHDk1QYH6IHBM2wzE94swVnsMl5UVQeiRV27Bhg6cqxTE4KQYpsEHBc7Vs2bJFVrvbbrup5/bMmTOLPIcH8oMAVq3DTw3vIT7D7gMbJSU3CPj6AcEWVJS/xOLFi6Vly5aBJimENza8sP0E7aZ/kh+l3D2OH7/+/ftL+/bt1d6DRAk1atTI3Rsq0JZ72oDgN4Fexi+//CIbN26U1atXJ8wimJ6pLkaF4bdSpUqB4UPGVigh5NmGkRE2nn322UdXLcMGBJsVYlrjhXz99dcDaxcrCo4AflyQELNp06ZqZEZsZkpuEvBUQPD9wS8L0t6ULl1aDbxlypSJuUMYfZEd48ILL9TjMQezuHH00UerSwByL6HuP//8M6E2zILNnj1bU6UkHPTZAUPmggULfM4SDdgPBU0JjgBmZK+99lr9YUGiBObdCo59tmryVECoDEGZ8IcpeaTmQT74sEitWrV0hguLYLEODb0eY4iUKlWqSLVq1bRHVNy2wtdp+vTpvpcjLQvWwVGCIYBZTUQoRCB45Fk3kwDBVMxaskqgSAXk1oq0PPiDIDzlmjVrdOobht5khmD3+mz+j14ZlBH+MiUnnnii4M9P0Dvcf//9/U7j8RISwJQ6MrR8+OGHGi6jcePGJSyRl4eJgK8RGo1FrwDLLvCrg8V8+AW6/vrr1fjHXkCYHmd+tQVZdxGhEL1aOL5S+eTX88Xd+PaAMMw57bTTBN7GSEty4403KgXEyUXISsRTefTRR/OPDO/IGgFMJvTu3VswywolBGMzJT8J+PaAMJOEpQ/vvPOOIB87jNIQjMWRuhkhOTAjFpTA5wNpolP5Q7wiSm4RmDJlioZHRQQG9HqofHLr+aXbWt8eECIiohvslff6uOOOUydFGIGDWpiKXhiUH3pmCAeSLGg4QodQcoPAjz/+KH369NHICwiN6kbfzI3Ws5XFJeCrgKBY4PgHf6D4UAbPP/+89oiCdPjD0A/hNDEdj5koLDqk5DYBrNuCX0+3bt00ZAbjS+X280yn9b4KqHXr1moERJ4k+GDA7wa9omnTpsnDDz8scAyM9xFKpwHFORc9myFDhsjgwYP1xYUjIiX3CPz88886rMeiYWRdadGiRe7dBFtcIgK+NiDMfMEQiN4GlA2c72BbQYQ5OCLef//9JWpAcS+GPQpT4WgXJfcIwJu5QYMGAncOhEel8sm9Z5iJFvv2gFCJWVWrMxLIEoneD3o8sAvVrVs3E20oVhlYcNiqVatiXcuL7BGA28aAAQNk8uTJ8vjjjwtSPlEKl0BKCgh4YOyF0Rl/FBIoDgGE9kVscfScly1b5jmxUZxyeU3uEkhJAeHFQQoTOCRi9ile4K9BIYGiCGCZjInNpClwYDeEXxmFBEDAVwEhHQ8WpmIaHj4ZWP1OIYFUCcBrHlELqlevrrYexu1OlVxhnOergDBDgeHX0qVLAw27URj48/cu4Zz64IMP6mzlsGHDdLYyf++Wd1ZcAr4KCC8S1uIEGfOnuDfD68JBAIn/unfvLphmR2gTxuUOx3MJYyt8p+Ex04QYOTAaUkjAjwASAsBJ1HUYpfLxI1bYx317QAhOBv8f+GnAUxW9ofiYu5hWpRQ2gZ9++imylALRKLFmj0ICfgR8FRAWBGLRKQSBybyECsiLSuHse+uttzQ6JWKHI2kAFgpTSCAVAr4KCI5i+HWDhC0gWSo3yHOyR+D333+XQYMGCdYEPvHEE3QqzB7qvC3Z1waEO2dAsrx9/sW+MfR0kPgPbhrIuU6P5mKjLOgLfRWQG5Bs5cqVGpDM7V7DyDh27FhdTFjQBAvs5rEYefjw4XLSSSdp72fChAmambbAMPB2M0TAdwjmBiSDAoIz4i233KJVIyYPnBKRmQJT9ciSQclvAlgHiOl1xAJHjGZMSFBIoCQEfHtAqQYkK0kjeG34CeCHCGu4zjrrLM1IQuUT/meWCy307QGFLSBZLkDNtzaOHj1abr31Vg2/y8XI+fZ07d6PrwIKY0Ayu8gKp3bEWkLcJSzHgUdzUGF3C4cw79RXAbkByTD2h0MixA323rlzZ2sByfjosksArhddu3ZV2x6UDxchZ5d3oZbuq4AAJowByQr1gQVx31h6gxC87dq105nPeM/3INrAOgqDQEoKCCgYkKwwXgikX0ISyttuu00uu+yywrhp3qU1Ar4K6LvvvpMDDjhAGzh+/HhB0jhXYJCEP1AYBKE+P//8cx0qHHLIIQnr1cLQxrC3Ac+3f//+6tncpk2bsDeX7csHAsaHx1OMh6tjItc5xvfHMRHt9JzDDz8cGQgjfyZ5nGMyo3pen62dd999t2PygcUUP3ToUMf4pkTaZVZgO7NmzYo5J9MbxjbmmIywmS7WSnl4vldffbWD57tixQorbWClmSdgTCeO8VjPfMEZLNHTDwjerjA4Iwj9vffeG+NkeMMNN+iasOXLlwuSyd1xxx2B6mEERkO7XBk3bpx65MJHBUHOkbgQaXpgIMdyAUpyAps3b9ZlFPD3WrhwoTCZY3JePJpZAp4KCOEUEAcaGSovvvjiyHAG3s5IzYzlGHXq1NHc8O5K+cw2K/XSHnvsMWnSpInAUQ5txbQxvkjm11zjWKde0v/OxIp/zPj4/SE90dq1a9MtPlTnYw2Xm2gAKbY50xWqx1MQjfG0AaHnUK9ePWnUqFFSCLD/jBkzRiPfVahQIem52Tq4ZcsW6dWrV0LxPXr0EDNEStjvt+Pss8+WTp06+Z0mBx10kNSoUcP3vLCegB8XGJkRNhX3TCEBGwQ8FdD69es9nc6QiRQGXlcOPvhgXQe2adMmCVIBbd++XZBpAUntoCzQ3njBMG3fffeN3+27jR5eKveC3mCyvPS+FVk8Aev5YHCePXu2HHPMMRZbwqoLnYCnAkKYBQSZihc4pkULvuSYIQvSQxZffLQNSgL+SRUrVtThItYo4cuE0CGwSz399NPy0EMPRTe34D9j2IglFXAsXLRokey///4Fz4QA7BLwtAHBoIvV78mMuDBUT5kyRZo3bx7oHWBYhZXYyC+FNEEIioVey5o1a7Qd06dP12MYgl1yySWBti3Mlc2fP18VNgLFIy0ylU+Yn1YBtc1rRs0oF8fE9HVM6mXHzHYlnGLWCDkmw6VjPGSdadOmJRy3scN1FTDDMQcuBNmWXJmGNwrauf766x3TU3WmTp2abSwsP0QEcmEa3nMIhmEOFiAig+VRRx0lzZo10+ENpreXLFki77//viD1CmaMTjnllFCoa/SCIFWqVAlFe8LQCMxyISkgMlN8+umnxbKJheE+2Ib8JeCpgHC7mJKdOXOmjBgxQubOnaszSrAhYOYHQzTk+O7QoUP+ksnhO8Pw2Dhsyp133in33HOPBo3L4dth0/OYQJEKCPeMlDxuBESEZsAyjP322y+PceT+rX355ZcarQA9QvRWkRKZQgJhJeBphPZqLFZEU/l4kQnPPjhlwrEQ4XLffPNNKp/wPBq2pAgCSXtARVzD3SEjsGHDBp3xw8LhefPmqZd6yJrI5pCAJ4GUe0CeV3OndQIvvPCCThTAax1LULBEhkICuUKAPaBceVJx7YQ97sorrxRkrn311VelYcOGcWdwkwTCT4A9oPA/o4QWYnbyiCOOUJcDOGVS+SQg4o4cIZBSDwgr40eOHKnLHJCoMF4WL14cv4vbWSAAN4h+/fppj+fZZ5+VFi1aZKEWFkkCwRHwVUBIvdu+fXtNSoilDwzZENzDia4JvlhIAomMpHAqTGXBbPT1/EwCYSTgq4DgEY1V3wgEVqlSpTDeQ1636bfffhMEgYOxGamwESyeQgL5QsDXBmSWtmgKXiqf4B85VqxjKQym15ctW0blE/wjYI1ZJuCrgFq1aiVI04IvACUYAoh1ZOJe6zo7hBaBvYc/AMGwZy3BEvAdgmE5BuJDw+DZrVs37Q3F54kaMGBAsK3O49qwgBSJH2vWrKnDXjcjSR7fMm+tgAn4KiD4mbhxn7H63UuogLyopLcPQ13MNA4fPlwXkcLgTCGBfCfgq4BOPvlkQZpeSvYIwMYDhQPOcGlAqFsKCRQCAV8bkB8EpOahFJ8AvJiPPvpoTQCAdVxUPsVnyStzj4BvDwi3hJQ3o0aNEgSfR1gOCP5HNlKEbkVYVEp6BMDMRCrU1EcTJkwITYbZ9O6CZ5NAyQj49oDgiIjIiPCGRhYK+AOZjKiCdDhwiBs2bFjJWlCAVyOFNMJmIJsHeIYlvXUBPgresmUCvj0gDAsQYQ9B39HrQUygp556SsqXLy9XXHGFTtFbvoecqh5B9eFYeNddd2kixZxqPBtLAhkm4KuAEGumcePGYoKwa9VIyIewD23atNFoiZguRjpk9I4oRRPYtm2b9OzZUz777DNNi3PYYYcVfTKPkECBEPAdgiHnV3QKYqQ8RooXiOsch1xclKIJYMhlsozIHnvsocqbyqdoVjxSWAR8FRAWoMLe0717d8GMF7YxBIPtAkHPMSRDL8iWwH9m48aNGq/aVhuS1fvMM8+ojWfgwIG6lqtMmTLJTucxEigoAr4KCAbnxx9/XDNkfPvtt2r3gU0Ia5SQZRP5xZHGJ0iB8RYzSFB8+EIjyR5SBu29997aruuuu04QusKmYJbr8ssvV0bI5ErHQptPg3WHlYCvDQgNR9pj5GDHEgz8IdvCa6+9poGwonPFB3GTX331laYFgtJDu1B/5cqVVQkiSiCGiy+99JJMnDhRc5shJ1bQgjYgMDyGWmDl2s+CbgfrI4GwE0hJAeEm0NOAIRWzYfjSY2q+bNmygd8fZo/Q84FvUlH1Dx06VHOWYaiIXlo6Ak9khL7wE/RwNm/enHAahoSIz4x0Rr179044zh0kQAJ/EUhJAcHI3LdvX+1V4FLMgmGFNnJP3XbbbVKuXLm/SszyJ+Srx3CmKOWD6jEjB5vVgw8+mLYCwuLbVBaAIjAbZgTjBa4KM2bMUD+f+GPcJgESiCXgq4AQghW9nZ07d+p0+4033qglwHnukksuka1bt2rW1Nhis7eFNNGYhevRo0fSSubMmSNVq1ZNeo7XwQYNGgj+/ARDvNq1ayecBqUMJ0MKCZCAPwFfBYShDoy+WHIBI6+bKRU2DvQC0BvBsCMoQzRCg0AJYQGnm/ccBmhEbYQNCJlBMfOEXgjaTiEBEggvAV8FtGrVKqlfv74qn/jbwC89HBXxpYe/UBCChZtwAcDsG5QfZuTipW3btjJ79uysBm2HDQjZRz/44IOY6rFkBW4Bro9UzEHLG1htjx5tGDPcwr6I9lWpUsUypcTq8ay///77UC4UxpAfJpLzzz8/oeH4QQ67+CogKBYMefClin9xn3/+ebUDFWeoUxIwtWrV0hkufJnWrVunChBRBPHyVqtWTafkS1J+KteOHj1axo8fr/cfff7777+vLgDxrKLPsfUZLyRiTIfxS/7zzz9rDzaMoV/ADF9y264dXu8NFBBGJ17D/j59+qRkTvAqN7B9ZviUVMyL4ZhZL8d48jrG8OyYKWXHBCZzTMhQZ99993UuuOCCpNcX2sFBgwY5JoxqKG/bKE3HrN8LZdumTZvmnHLKKaFsm8m95piedyjbZiJUOMYEEcq2pdIo3x4QfFgmTZqks0qwv0AQMhTSuXNnuf/++/Uz/yEBEiCBdAn4KiAUeOSRR2qkPtg7YBOCTxDsQnXr1k23Pp5PAiRAAhECngoI43GvSIfwj4n2kYH9BVK9evVIgfxAAiRAAqkS8FRAiFmDFMCpihnrpXoqzyMBEiCBCAFPBQSfGgj8fk4//XSN/cN4PxFm/EACJJAhAp4KCNN3xx57rGCaHQs7p0+frgs/zznnHGnevHlgTocZukcWQwIkEFICnuE40ANCIsIxY8aooyEWdcJRzEyTSo0aNaR///66yjuk98RmkQAJ5AgBTwUU3XasbWrfvr063WH5wwMPPCAIVH/iiSdKnTp1ZPDgwdGn8zMJkAAJpEygFJyFUj77/0/E0ounn35as3giNU8xiki3ypw5H0oa6+IQJC1sAk/o7du3F2uRbrbvBTOvCG+CUCthE3hC40c3jKF04Qm9YsUKqVevXtiwpdSelBUQlA5SNONv0aJFui6ma9eumi/eyw08pdp5EgmQQEETSKqAEH0QCgeJ86B0EP8GUQi7deumsaGDWgFf0E+IN08CeUzAUwG9/fbbMmDAAMHCSgwlEHoDSgcxgNwp+jxmwlsjARIIiICnArrnnnvUEREB6WFshiE6mSD+DoUESIAE0iXgqVkQSgJxdyBY6k8hARIggWwQ8OwBZaMilkkCJEAC8QR8/YDiL+A2CZAACWSKABVQpkiyHBIggbQJUAGljYwXkAAJZIoAFVCmSLIcEiCBtAlQAaWNjBeQAAlkigAVUKZI/n85XBeXOlCsS0smNlki4wrWWYVNvNJQxbfRJrf4tvhtUwH5EUrxuMmcoIkSkQ/MZBGRIUOGpHhl9k9DFtnDDz884Q8hVmzJE088ISarimf1Tz75pLRs2VJTfjdq1Ejeeustz/OytXPt2rWaumjmzJkxVSAtD+Kgx7P0y9IbU0gxN5577jlNsYOU5JUrV9aVCUgVFC1hfgej2xn92dMRMfoEfvYngIgAXbp0kcaNG2uywo8//lh69eqly1bcVNb+pWTvDHyRsFoa7YsWW1EuJ0+eLCY9kOy6667RzdHPc+fOlZ49ewq88UeOHCmPPPKIdOjQQRYuXKjJERIuyPAOKB+kIsfK/Hj59NNPZfny5dK3b1+pUKFC5DDy1GVTXnnlFUFGGiTiHDVqlDoHDx8+XDp27KjJIpAkIuzvYJF8THeNUkICJl21Y9JUO2ZIESnp1ltv1bxpJpRDZJ+ND+aLhHArjolqaaP6mDpN0kHHpNPW9tSuXdvZY489Yo5jw/Qw9JzoAw0aNHAuvvji6F1Z+Yy8aeXLl3dMnCtto/nix9RjlKHmxTNDs5j92d4w8bgcE6bEMcOvSFUmWqm20azb1H1hfgcjjfb4wCFYkao59QOzZs3SX+ndd989clGnTp3EJI3TKAKRnRY+fPLJJ1rrMccco/+nYkPIVjOR1mnevHmCHtDll1+eENoXQ4rPP/9c45BHtwEsZ8yYEb0rK59NQkm56qqriqwLPVssUcKC7CA5YoiHnmB09Ak3FbqbSTbM72Cyh0UFlIxOisdWr16dEOTLTVf97bffplhKdk7Dl8b8qmt4XQwVKlasKIjjhFTbQQvijGNtIRSKlyDnHMRl556DbbQ321962FCGDRumee/cuqP/X7p0qQ4bu3fvrhwPPvhgGTFiRNbbdcYZZ0i7du2imyJYAI5F4iZjse4P8zsY0/C4DSqgOCDF2dy6dWtCPnp80SGIkGhT8KWBsXnNmjVihoWCl9mkQZaTTjop8FkeZFmBvaIoQVREiEk1HHMKDPuYkfKyy8ScWMINLMJOJmC5ePFiQe8D9inERx84cKDcfvvtyS7L+LH58+drj+jaa6/VGF2oIMzvYDIANEIno5PiMRhzo7vHuMzd3rFjR4qlZOc0/FpD2SCeE8TYYAQzSzCST5w4UXtD2ak5/VLdsC8uu/gSMDVuS3bu3Km9SIRldSOAGruUtGrVSntNSNRgbFpZb96CBQvk1FNPlSZNmugPilthmN9Bt41e/7MH5EUlzX2ImxSfSXbLli1aSvRsSZrFZuT0448/PqJ83AIRYA52jI8++sjdFYr/EXET4rJzG+WyNYZ+d1fg/0M5YibKVT5uAxAhFDGjEZc52zJnzhxp27at2qEwMxZtcwzzO5iMCxVQMjopHsPDj7f1bNiwQa8+9NBDUywlO6ctWbJEYB+IFvxaQgElGw5Fnx/UZ3CEuOzcesEWPkM2lTmGh++++64Oddx24X9XCWTbpeHNN9/UtFhQQDDI77nnntHNkDC/gzENjdugAooDUpxNvBTwtYn2nEUyR/xiN2zYsDhFZuya8847T0PqRhc4depUwZDCdtui24TP6AHVr19fE2FGH8OvfevWraN3Bf553bp1mpQTaamiBcNY2Lay6Qu0bNkyVT6dO3fWYbOr9KLbEeZ3MLqdCZ89pua5K00C33zzjWN+AR1jV3FM6hvHeO46xlvVMYbKNEvK/OnGoU/9ReAn8v333zvGiOoYO4ZjlE+MX0nma05e4r333uuUK1cu4SSTDNMxXzDHZOR14Dc0dOhQ3TZG9IRzs7XDpODx9ANq2rSpY2KkOy+//LJjjL7OuHHj9LmbmbNsNUXLNcpFfaaM8nMeffTRmD/jGKnnhPkdTAYHOb0oGSAApzUzTNAXF8rHePM6ppeRgZJLVgSc18xMjWOGW9o2Y8twjBFTFWXJSi7Z1UUpIDAzszv6xTa/luqYaJZmlKyyNK8uSgGZXpBjDPrKEW0zQ0LHeCSnWXp6p0OxoK6i/saOHRspMKzvYKSBHh8YktU82UyJ4StIZVStWjXfQP6ZqjPVcjCDhNxuaJvpeaR6mbXzYNg1PTapXr26tTYUVTGM5HAyxZq/sGWJCfM76MWTCsiLCveRAAkEQoBG6EAwsxISIAEvAlRAXlS4jwRIIBACVECBYGYlJEACXgSogLyocB8JkEAgBKiAAsHMSkiABLwIUAF5UeE+EiCBQAhQAQWCmZWQAAl4EaAC8qLCfSRAAoEQoAIKBDMrIQES8CJABeRFhftIgAQCIUAFFAhmVkICJOBFgArIiwr3kQAJBEKACigQzKyEBEjAiwAVkBcV7iMBEgiEABVQIJhZCQmQgBcBKiAvKtxHAiQQCAEqoEAwsxISIAEvAlRAXlS4jwRIIBACVECBYGYlJEACXgSogLyocB8JkEAgBKiAAsHMSkiABLwIUAF5UeE+EiCBQAhQAQWCmZWQAAl4EaAC8qLCfSRAAoEQoAIKBHO4K0GWz82bN4e7kWxdXhKgAsrLx+p/U5999pl0795dateuLfvtt5+YvPZy0EEHSf/+/QVpnHNNFi5cKPPmzYs0u2fPntKwYcPINj+EkwAVUDifS1ZbhRzxJ510kixevFhuuukm+eijj2TBggVy1VVXyUMPPSRt27bNav2ZLnznzp3StGlTWb16daRobJ9yyimRbX4IJ4HS4WwWW5UtAj///LO0a9dODjnkEHnttddk9913j1TVuHFjOfLII+XUU0+V119/PWcUkeM4gr9oueiii6I3+TmkBNgDCumDyVazMExZtWqV3H333THKx60PvYZbbrlFh2TuPvz/+OOPyzHHHCMVKlSQRo0aydSpUyOH33vvPd2Hck8++WSpWLGiHHXUUfLyyy9HzsGHX375Ra688kqpWbOmlt+5c2f56quvIuegbc2aNZPZs2dLtWrVpEWLFvLDDz/I77//LjfccIMqx/Lly+uwsU+fPvLrr7/qX5MmTbSMwYMHywUXXKCf77jjDjnvvPMiZX/33Xc65KxataoOOTt16iRr1qyJHE/1HiIX8ENmCJhfDkoBETBfUqdMmTKOsfOkfNd33nmnU7p0aefcc891Jk+e7FxzzTVOqVKlnJdeeknLmDlzpm6bXpVj7ErOE0884RiloPvMl1zP+fPPPx2juJz999/fufnmmx2jnJwTTzzRMfYnxxjA9ZxXXnnF2XXXXZ0aNWo455xzjmMUlO7v2rWrnod2TJw40enRowe6O1rOjh07nHHjxuk29k+fPl2vwedjjz1WP+Ne69ev7xjF54wfP96ZMGGCc9xxxzl77723s379ej0nlXvQE/lPRgmg60opIAIdO3Z0zDAr5o6NDcVZunSp/n388ccO/kxvRs/58ccfnb322ssxQ5qYa7p16+bUqlVL9+HLC4UABeHK119/rfseeeQR3fXcc8/p9owZM9xTHNODcUyPxjG9G90HBYRyTO8lcs62bdsc0/NyHn744cg+fMA+Y6vSfVAwuA6KyJVoBfTAAw+oYlu5cqV7WJUelJ0xVuu+VO4hcjE/ZIwAbUDmzS0kMT0XHQpF3/NPP/2kw5vofRjWYFgCA/XWrVt1SPXuu+9GTjnssMPkhRdekI0bN0b2tWzZMvIZQyjYl3At5J133hHT49AhXHQ5GKpFb+NcDL1cKVeunCxZskQ3YWyGoRltwkwdhmCpyKJFi8T0eARtdqVy5co6bIyvO9k9uNfy/8wRoALKHMucKAmGZtMLESgdKASI6eHInDlzIu0fNGhQ5LNro+nbt29kX/QHzKi5gqn8aDFDPTFDL92F81DnCSecEH2KfoZNKFqgvKJl/vz5gjZhps4MuVRZwp6Edqcia9euFdh+4gWKzvTQYnYnu4eYE7mREQI0QmcEY+4UAgVk+s8yd+7cSKONfUdatWoV+dtnn30ix9BTgODLD2US/4eehSvoXRUlKNPYduSPP/5IKOOLL76IucwMjSLbxkYjHTp0kF122UVefPFFdZhED+iII46InOP3AX5OMGbHC2YEzTAyZneye4g5kRsZIUAFlBGMuVPI8ccfr8MpTFMvW7YsoeH4ohr7TWS/Md4KvpQYbuF/98/YZOSss86S3377LXJusg8oB70pOAy6ZUARGsO2zsgVdS2GblAUo0ePltNOO00qVaokGIp98sknqsxwHZQTBMrNS1A3fJ6MPStyGIr0jTfeSBh6Rk7gh0AIUAEFgjk8lcCmMmvWLEHPpnXr1oLp7EmTJumU+cCBA6VOnTqyfPly6dKlizYa/kLG4CxmZksVBaazzUyY9OvXT+rVq+c5le91t5dddpmgF9SrVy+dwv/mm28E9aFXk8zxsXnz5oIe0ZNPPinGIC0Yyl144YWqzLANwXHYmzB9DwUXL3CwhJx//vl6HexWV199taxbt04uvfTS+NO5HSSBjJmzWVBOETC9EccoBccoEZ0uN++cYxSEc/rppzsrVqyIuRdju9HpdUzF4zyzZEOnwjGLBXFnkIytRbfdfzB7NmLECHfT+fDDD3X2CmWYXpBOk0fPbrmzYJhBi5YhQ4Y4xoajrgBwITAKxRk5cqS6E5gem54K1wC0D9P6kOhZMGwbg7req1s3puXRbldSvQf3fP6fGQKlUIx5KJQCJoBhF2aU4o2/8Ugw8wSbTE1jNMYwqriyZcsWHbodeOCBKReB1xS9H7Rxt91287xu+/btal+Cs2JRgoW3KAt2IYp9AlRA9p8BW0ACBUuANqCCffS8cRKwT4AKyP4zYAtIoGAJUAEV7KPnjZOAfQJUQPafAVtAAgVLgAqoYB89b5wE7BOgArL/DNgCEihYAlRABfvoeeMkYJ8AFZD9Z8AWkEDBEqACKthHzxsnAfsEqIDsPwO2gAQKlgAVUME+et44CdgnQAVk/xmwBSRQsASogAr20fPGScA+ASog+8+ALSCBgiVABVSwj543TgL2CVAB2X8GbAEJFCwBKqCCffS8cRKwT4AKyP4zYAtIoGAJUAEV7KPnjZOAfQJUQPafAVtAAgVLgAqoYB89b5wE7BOgArL/DNgCEihYAv8H46SM/qoSD7cAAAAASUVORK5CYII="" /><!-- --></p>
 </div>
 <div id=""references"" class=""section level1 unnumbered"">
 <h1>References</h1>

---FILE: man/SimParam_addTraitADE.Rd---
@@ -14,8 +14,8 @@
 
 \item{varDD}{variance of dominance degree}
 
-\item{relAA}{the relative variance of additive-by-additive effects compared 
-to the additive effects}
+\item{relAA}{the relative value of additive-by-additive variance compared 
+to additive variance in a diploid organism with allele frequency 0.5}
 
 \item{corA}{a matrix of correlations between additive effects}
 

---FILE: man/SimParam_addTraitADEG.Rd---
@@ -19,8 +19,8 @@ value or nChr values.}
 
 \item{varDD}{variance of dominance degree}
 
-\item{relAA}{the relative variance of additive-by-additive effects compared 
-to the additive effects}
+\item{relAA}{the relative value of additive-by-additive variance compared 
+to additive variance in a diploid organism with allele frequency 0.5}
 
 \item{corA}{a matrix of correlations between additive effects}
 

---FILE: man/SimParam_addTraitAE.Rd---
@@ -10,8 +10,8 @@
 
 \item{var}{a vector of desired genetic variances for one or more traits}
 
-\item{relAA}{the relative variance of additive-by-additive effects compared 
-to the additive effects}
+\item{relAA}{the relative value of additive-by-additive variance compared 
+to additive variance in a diploid organism with allele frequency 0.5}
 
 \item{corA}{a matrix of correlations between additive effects}
 

---FILE: man/SimParam_addTraitAEG.Rd---
@@ -10,8 +10,8 @@
 
 \item{var}{a vector of desired genetic variances for one or more traits}
 
-\item{relAA}{the relative variance of additive-by-additive effects compared 
-to the additive effects}
+\item{relAA}{the relative value of additive-by-additive variance compared 
+to additive variance in a diploid organism with allele frequency 0.5}
 
 \item{varGxE}{a vector of total genotype-by-environment variances for the traits}
 

---FILE: man/makeDH.Rd---
@@ -4,7 +4,8 @@
 \alias{makeDH}
 \title{Generates DH lines}
 \usage{
-makeDH(pop, nDH = 1, useFemale = TRUE, simParam = NULL)
+makeDH(pop, nDH = 1, useFemale = TRUE, keepParents = TRUE,
+  simParam = NULL)
 }
 \arguments{
 \item{pop}{an object of 'Pop' superclass}
@@ -14,6 +15,9 @@ makeDH(pop, nDH = 1, useFemale = TRUE, simParam = NULL)
 \item{useFemale}{should female recombination rates be used. 
 This parameter has no effect if, recombRatio=1.}
 
+\item{keepParents}{should previous parents be used for mother and 
+father.}
+
 \item{simParam}{an object of 'SimParam' class}
 }
 \value{

---FILE: man/self.Rd---
@@ -4,7 +4,8 @@
 \alias{self}
 \title{Self individuals}
 \usage{
-self(pop, nProgeny = 1, parents = NULL, simParam = NULL)
+self(pop, nProgeny = 1, parents = NULL, keepParents = TRUE,
+  simParam = NULL)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}}}
@@ -13,6 +14,9 @@ self(pop, nProgeny = 1, parents = NULL, simParam = NULL)
 
 \item{parents}{an optional vector of indices for allowable parents}
 
+\item{keepParents}{should previous parents be used for mother and 
+father.}
+
 \item{simParam}{an object of \code{\link{SimParam}}}
 }
 \value{

---FILE: src/misc.cpp---
@@ -132,26 +132,46 @@ arma::uword mapCol(arma::uword k, arma::uword n){
 // n number of integers to return
 // N number of integers to sample from
 // Returns an integer vector of length n with values ranging from 0 to N-1
-// From: https://stackoverflow.com/questions/311703/algorithm-for-sampling-without-replacement
-// Reportedly from: Algorithm 3.4.2S of Knuth's book Seminumeric Algorithms
+// Uses Jeffrey Scott Vitter's method A for big numbers
+// Uses Rcpp::sample for small numbers
 arma::uvec sampleInt(arma::uword n, arma::uword N){
-  arma::uword t = 0;
-  arma::uword m = 0;
+  arma::uvec output(n);
+  if(n==0){
+    return output;
+  }
+  // Use Rcpp::sample if N is a viable signed integer
+  if(N <= 2147483647){
+    output = Rcpp::as<arma::uvec>(Rcpp::sample(int(N),int(n)));
+    output = sort(output);
+    return output-1; //R to C++
+  }
+  
+  // Use method A
+  double top = double(N-n);
   arma::vec u(1);
-  arma::uvec samples(n);
-  while(m<n){
+  arma::uword S;
+  double q;
+  
+  while(n >= 2){
     u.randu();
-    if(double(N-t)*u(0) >= double(n-m)){
-      ++t;
-    }else{
-      samples(m) = t;
-      ++t;
-      ++m;
+    S = 0;
+    q = top/double(N);
+    while(q > u(0)){
+      ++S;
+      --top;
+      --N;
+      q = (q*top)/double(N);
     }
+    output(n-1) = S+1;
+    --N;
+    --n;
   }
-  return samples;
+  u.randu();
+  output(0) = floor(u(0)*N);
+  return cumsum(output);
 }
 
+
 // Samples random pairs without replacement from all possible combinations
 // nLevel1 = number of levels for the first column
 // nLevel2 = number of levels for the second column

---FILE: vignettes/AlphaSimR.bib---
@@ -1,3 +1,5 @@
+### For Introduction
+
 @article{MaCS,
    author = {Gary K. Chen and Paul Marjoram and Jeffery D. Wall},
    title = {Fast and Flexible Simulation of DNA Sequence Data},
@@ -8,17 +10,70 @@ @article{MaCS
    URL ={http://genome.cshlp.org/content/19/1/136}
 }
 
-@article{Troyer09,
-   author = {A. Forrest Troyer and Eric J. Wellin},
-   title = {Heterosis Decreasing in Hybrids: Yield Test Inbreds},
-   journal = {Crop Science},
-   volume = {49},
-   number = {6},
-   pages = {1969-1976},
-   year = {2009},
-   URL ={https://doi.org/10.2135/cropsci2009.04.0170}
+@article{AlphaSim,
+   author = {Anne-Michelle Faux and Gregor Gorjanc and R. Chris Gaynor and Mara Battagin and Stefan M. Edwards and David L. Wilson and Sarah J. Hearne and Serap Gonen and John M. Hickey},
+   title = {AlphaSim: Software for Breeding Program Simulation},
+   journal = {The Plant Genome},
+   volume = {9},
+   number = {3},
+   year = {2016},
+   URL ={https://doi.org/10.3835/plantgenome2016.02.0013}
 }
 
+### For quantitative genetics
+
+@book{Gallais,
+    title = {Quantitative Genetics and Breeding Methods in Autopolyploid Plants},
+    author = {A. Gallais},
+    year = {2003},
+    publisher = {INRA},
+    address = {Paris},
+    ISBN = {2-7380-1093-8}
+}
+
+@book{Falconer,
+    title = {Introduction to Quantitative Genetics},
+    author = {D. S. Falconer and Trudy F. C. Mackay},
+    edition = {4},
+    year = {1996},
+    publisher = {Longman},
+    address = {Harlow},
+    ISBN = {978-0-582-24302-6}
+}
+
+@article{FinlayWilkinson,
+		title = {The analysis of adaptation in a plant-breeding programme},
+	volume = {14},
+	issn = {1444-9838},
+	url = {http://www.publish.csiro.au/cp/AR9630742},
+	doi = {10.1071/ar9630742},
+	language = {en},
+	number = {6},
+	urldate = {2017-12-13},
+	journal = {Australian Journal of Agricultural Research},
+	author = {Finlay, K. W. and Wilkinson, G. N.},
+	year = {1963},
+	pages = {742--754}
+}
+
+@article{Falconer_85,
+	title = {A note on {Fisher}'s average effect and average excess},
+	volume = {46},
+	issn = {1469-5073, 0016-6723},
+	url = {https://www.cambridge.org/core/journals/genetics-research/article/note-on-fishers-average-effect-and-average-excess/26DFA92B3BA3EA92CD76847BFA21C5C8},
+	doi = {10.1017/S0016672300022825},
+	language = {en},
+	number = {3},
+	urldate = {2019-01-03},
+	journal = {Genetics Research},
+	author = {Falconer, D. S.},
+	month = dec,
+	year = {1985},
+	pages = {337--347}
+}
+
+### For GS
+
 @article{Massman13,
    author = {Jon M. Massman and Andres Gordillo and Robenzon E. Lorenzana and Rex Bernardo},
    title = {Genomewide Predictions from Maize Single-Cross Data},
@@ -30,37 +85,6 @@ @article{Massman13
    URL ={https://doi.org/10.1007/s00122-012-1955-y}
 }
 
-@article{Jenko15,
-   author = {Janez Jenko and Gregor Gorjanc and Matthew A. Cleveland and Rajeev K. Varshney and C. Bruce A. Whitelaw and John A. Woolliams and John M. Hickey},
-   title = {Potential of Promotion of Alleles by Genome Editing to Improve Quantitative Traits in Livestock Breeding Programs},
-   journal = {Genetics Selection Evolution},
-   volume = {47},
-   number = {55},
-   year = {2015},
-   URL ={https://doi.org/10.1186/s12711-015-0135-3}
-}
-
-@article{AlphaSim,
-   author = {Anne-Michelle Faux and Gregor Gorjanc and R. Chris Gaynor and Mara Battagin and Stefan M. Edwards and David L. Wilson and Sarah J. Hearne and Serap Gonen and John M. Hickey},
-   title = {AlphaSim: Software for Breeding Program Simulation},
-   journal = {The Plant Genome},
-   volume = {9},
-   number = {3},
-   year = {2016},
-   URL ={https://doi.org/10.3835/plantgenome2016.02.0013}
-}
-
-@article{Gaynor17,
-   author = {R. Chris Gaynor and Gregor Gorjanc and Alison R. Bentley and Eric S. Ober and Phil Howell and Robert Jackson and Ian J. Mackay and John M. Hickey},
-   title = {A Two-Part Strategy for Using Genomic Selection to Develop Inbred Lines},
-   journal = {Crop Science},
-   volume = {57},
-   number = {5},
-   pages = {2372-2386},
-   year = {2017},
-   URL ={https://doi.org/10.2135/cropsci2016.09.0742}
-}
-
 @manual{EMMREML,
     title = {EMMREML: Fitting Mixed Models with Known Covariance Structures},
     author = {Deniz Akdemir and Okeke Uche Godfrey},
@@ -78,12 +102,3 @@ @article{sommer
     pages = {1-15},
     url = {https://doi.org/10.1371/journal.pone.0156744}
 }
-
-@book{BernardoBook,
-    title = {Essentials of Plant Breeding},
-    author = {Rex Bernardo},
-    year = {2014},
-    publisher = {Stemma Press},
-    address = {Woodsbury, MN},
-    ISBN = {978-0-9720724-2-7}
-}
\ No newline at end of file

---FILE: vignettes/intro.Rmd---
@@ -1,8 +1,9 @@
 ---
 title: ""Introduction to AlphaSimR""
-date: ""`r Sys.Date()`""
+author: ""Chris Gaynor""
+date: ""March 27, 2019""
 output: rmarkdown::html_vignette
-bibliography: bibliography.bib
+bibliography: AlphaSimR.bib
 vignette: >
   %\VignetteIndexEntry{Introduction}
   %\VignetteEngine{knitr::rmarkdown}

---FILE: vignettes/theory.Rmd---
@@ -0,0 +1,158 @@
+---
+title: ""Theory in AlphaSimR""
+author: ""Chris Gaynor""
+date: ""April 9, 2019""
+output: 
+  rmarkdown::pdf_document:
+    toc: true
+    toc_depth: 2
+    number_sections: true
+tables: true
+bibliography: AlphaSimR.bib
+vignette: >
+  %\VignetteIndexEntry{Theory}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+
+\pagebreak
+
+# Introduction
+
+This document explains the theoretical basis for several models implemented within AlphaSimR. The article consists of the following four sections: biological trait model, statistical trait model, meiosis model, and genomic selection models. The biological trait model section is concerned with how an individual's genotype becomes a genetic value, which ultimately becomes a phenotype. The statistical trait model section covers the partitioning of a population's total genetic variance into variance components. The meiosis model section deals with genetic recombination. And the final section provides a brief overview of the genomic selection models available in AlphaSimR.
+
+\pagebreak
+
+# Biological Trait Model
+
+The biological trait model is the model used to convert an individual's genotype to a genetic value. The genetic value then becomes a phenotype by adding some amount of random error. 
+
+There are some notable differences between how AlphaSimR models traits compared t 
+
+Traits in AlphaSimR are classified by the biolgical effects they model using the **ADEG** framework. Under this framework, each trait is assigned a name consisting of one or more letters. The letters come from the name **ADEG**, which correspond to the biological effects. The biological effects are: **A**dditive, **D**ominance, **E**pistatic and **G**enotype-by-environment. For example, a trait with only additive effects is called an **A** trait and a trait with both additive and dominance effects is called an **AD** trait. The following traits are modeled in AlphaSimR: **A**, **AD**, **AE**, **AG**, **ADE**, **ADG**, **AEG**, and **ADEG**.
+
+The most complex trait in AlphaSimR is an **ADEG** trait, because it includes all possible biological effects. The equation below represents how genetic values are calculated for this trait:
+
+\begin{equation}
+GV(x, w) = 
+\mu + 
+A(x) +
+D(x) +
+E(x) +
+G(x, w)
+\end{equation}
+
+where $GV$ represents an individuals genetic value, $x$ represents a vector of QTL genotype dosages and $w$ represents an environmental covariate. The right-hand side of the equation consists of a constant value ($\mu$) and four functions, each corresponding to one of the biological effects. Those equations simply lack the respective functions for the missing biological effects. Each of the biological effects functions are shown in separate subsections below with an explanation of the effects they model.
+
+## Dosage Scaling
+
+Before discussing the functions for biological effects in equation (1), it is worthwhile to expand on the concept of genotype dosage. First, consider that AlphaSimR models all loci as biallelic with alleles 0 and 1. The raw genotype dosage in AlphaSimR is simply defined as the number of copies of the 1 allele at a locus. This is notable, because the range for raw genotype dosage depends on the ploidy level of an organism. For example, the range for a diploid is 0 to 2, but the range for an autotetraploid is 0 to 4. 
+
+AlphaSimR uses scaled genotype dosages in its biological model to account for simulations with different levels of ploidy. The primary reason for using scaled dosages is to unify user inputs and make direct comparisons between simulations with different ploidy level easier. The effect of using scaled dosages is to hypothesize that an individual's genetic value depends on the relative ratio of alleles and is independent of the ploidy level. There is some evidence supporting this hypothesis in species where it can be tested, but only for some traits as there are traits that clearly violate the hypothesis [@Gallais]. This means that users should use care when drawing conclusions from simulations based on this hypothesis.
+
+There are two types of scaled genotype dosages in AlphaSimR: additive and dominance. The scaled additive genotype dosage ($x_A$) is shown in equation (2). This equation linearly scales relative dosage to set the values for opposing homozygotes to -1 and 1. 
+
+\begin{equation}
+x_A = \big( x - \tfrac{ploidy}{2} \big) \big( \tfrac{2}{ploidy} \big)
+\end{equation}
+
+The scaled dominance genotype dosage ($x_D$) is shown in equation (3). This equation uses non-linear scaling to fit the value for both opposing homozygotes to 0 and middlemost heterozygote to 1. The middlemost heterozygote is the genotype with an equal ratio of ""0"" and ""1"" alleles. For a diploid organism, the scaled dominance genotype dosage is the same as the classic parameterization for dominance. For an autopolyploid organism, the scaled dominance genotype dosage is consistent with digenic dominance (discussed later).
+
+\begin{equation}
+x_D = x \big( ploidy - x \big) \big( \tfrac{2}{ploidy} \big)^2
+\end{equation}
+
+Table 1 provides an example of the raw and scaled genotype dosages for both a diploid and an autotetraploid organism. The diploid and tetraploid columns represent the range of raw genotype dosages for those organisms. The additive and dominance columns represent the scaled genotype dosages. The table shows how the 0, 1 and 2 genotypes of a diploid are respectively scaled to be equivalent to the 0, 2 and 4 genotypes of an autotetraploid.
+
+\begin{table}[h]
+\centering
+\caption{Raw and scaled genotype dosages.}
+\begin{tabular}{@{}rrrr@{}}
+\toprule
+Diploid & Tetraploid & Additive & Dominance \\ \midrule
+0 & 0 & $-1$ & $0$ \\
+ & 1 & $-1/2$ & $3/4$ \\
+1 & 2 & $0$ & $1$ \\
+ & 3 & $1/2$ & $3/4$ \\
+2 & 4 & $1$ & $0$ \\ \bottomrule
+\end{tabular}
+\end{table}
+
+## Additive Effects
+
+All traits in AlphaSimR include additive effects. 
+
+\begin{equation}
+A(x) = \sum a x_A
+\end{equation}
+
+## Dominance Effects
+
+\begin{equation}
+D(x) = \sum d x_D
+\end{equation}
+
+## Epistatic Effects
+
+\begin{equation}
+E(x) = \sum e x_{A_1} x_{A_2}
+\end{equation}
+
+## Genotype-by-Environment Effects
+
+\begin{equation}
+G(x, w) = w \big(\mu_G + \sum g x_A \big)
+\end{equation}
+
+\pagebreak
+ 
+# Statistical Trait Model
+
+\begin{equation}
+V_G = 
+V_A + 
+V_D + 
+V_I
+\end{equation}
+
+\begin{equation}
+GV = \overline{GV} + BV + DD + AA
+\end{equation}
+
+\begin{equation}
+\sum BV = \sum DD = \sum AA = 0
+\end{equation}
+
+## Variance Component Decomposition
+
+## Breeding Values
+
+## Dominance Deviations
+
+## Epistatic Deviations
+
+## Genetic vs Genic Variance
+
+\pagebreak
+
+# Meiosis Model
+
+## Bivalent Pairing
+
+## Quadrivalent Pairing
+
+\pagebreak
+
+# Genomic Selection Models
+
+## RR-BLUP Model
+
+## Dominance Model 
+
+## GCA Model
+
+## SCA Model
+
+\pagebreak
+
+# References"
gaynorr,AlphaSimR,765ded868a8c29d1b9d3e6be49f6cea62bb497dc,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-02-19T15:01:28Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-02-19T15:01:28Z,"-fixed broken writePlink
-fixed broken pullIbdHaplo
-removed trackHaploPop (superceded by pullIbdHaplo)",DESCRIPTION;NAMESPACE;NEWS;R/crossing.R;R/founderPop.R;R/hybrids.R;R/misc.R;R/pullGeno.R;man/hybridCross.Rd;man/pullIbdHaplo.Rd;man/trackHaploPop.Rd;tests/testthat/test-crossing.R;tests/testthat/test-editGenome.R;tests/testthat/test-hybrids.R,False,True,True,False,58,113,171,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
 Version: 0.9.1
-Date: 2019-2-7
+Date: 2019-2-19
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: NAMESPACE---
@@ -61,7 +61,6 @@ export(setEBV)
 export(setPheno)
 export(setPhenoGCA)
 export(smithHazel)
-export(trackHaploPop)
 export(usefulness)
 export(varA)
 export(varD)

---FILE: NEWS---
@@ -4,9 +4,12 @@ Changes in version 0.9.1
     -Max number of threads automatically detected
     -added RRBLUP_D2
     -added version tracking to SimParam
+    -removed trackHaploPop (superceded by pullIbdHaplo)
   
   Bug fixes
     -fixed faulting double crossover logic
+    -fixed broken writePlink
+    -fixed broken pullIbdHaplo
 
 Changes in version 0.9.0
 

---FILE: R/crossing.R---
@@ -41,6 +41,10 @@ makeCross = function(pop,crossPlan,simParam=NULL){
       stop(""Failed to match supplied IDs"")
     }
   }
+  if((max(crossPlan)>nInd(pop)) |
+     (min(crossPlan)<1L)){
+    stop(""Invalid crossPlan"")
+  }
   tmp = cross(pop@geno,
               crossPlan[,1],
               pop@geno,
@@ -282,6 +286,11 @@ makeCross2 = function(females,males,crossPlan,simParam=NULL){
       stop(""Failed to match supplied IDs"")
     }
   }
+  if((max(crossPlan[,1])>nInd(females)) | 
+     (max(crossPlan[,2])>nInd(males)) |
+     (min(crossPlan)<1L)){
+    stop(""Invalid crossPlan"")
+  }
   tmp=cross(females@geno,
             crossPlan[,1],
             males@geno,

---FILE: R/founderPop.R---
@@ -81,68 +81,6 @@ newMapPop = function(genMap,haplotypes,inbred=FALSE,
   return(output)
 }
 
-#' @title Haplotype tracking population
-#' 
-#' @description
-#' Creates a population contain haplotypes numbered for 
-#' identity be descent tracking.
-#'
-#' @param genMap a list of genetic maps
-#' @param nInd number of individuals
-#' @param inbred should individuals be fully inbred
-#' @param ploidy ploidy level of organism
-#' 
-#' @details
-#' Each item of genMap must be a vector of ordered genetic lengths in 
-#' Morgans. The first value must be zero. The length of the vector 
-#' determines the number of segregating sites on the chromosome.
-#' 
-#' If inbred=FALSE, the value of nInd must be less than or equal to 
-#' 128. Otherwise, it must be less than or equal to 256.
-#' 
-#' @examples
-#' # Create genetic map for a single chromosome with 1 Morgan
-#' # Chromosome contains 11 equally spaced segregating sites
-#' genMap = list(seq(0,1,length.out=11))
-#' founderPop = trackHaploPop(genMap=genMap,nInd=10)
-#' 
-#' @export
-trackHaploPop = function(genMap,nInd,inbred=FALSE,
-                         ploidy=2L){
-  stopifnot(is.list(genMap))
-  ploidy = as.integer(ploidy)
-  if(inbred){
-    stopifnot(nInd<=256)
-  }else{
-    stopifnot(nInd<=(256/ploidy))
-  }
-  nInd = as.integer(nInd)
-  nChr = length(genMap)
-  nLoci = unlist(lapply(genMap,length))
-  geno = vector(""list"",nChr)
-  for(i in 1:nChr){
-    tmpGeno = array(raw(),dim=c(nLoci[i],ploidy,nInd))
-    tmp=-1
-    for(j in 1:nInd){
-      if(inbred){
-        tmp=tmp+1
-        tmpGeno[,1:2,j] = as.raw(tmp)
-      }else{
-        for(k in 1:ploidy){
-          tmp=tmp+1
-          tmpGeno[,k,j] = as.raw(tmp)
-        } 
-      }
-    }
-    geno[[i]] = tmpGeno
-  }
-  output = new(""MapPop"",nInd=nInd,nChr=nChr,ploidy=ploidy,
-               nLoci=nLoci,geno=as.matrix(geno),
-               genMap=as.matrix(genMap),
-               centromere=sapply(genMap,max)/2)
-  return(output)
-}
-
 #' @title Create founder haplotypes using MaCS
 #'
 #' @description Uses the MaCS software to produce founder haplotypes.

---FILE: R/hybrids.R---
@@ -19,7 +19,7 @@
 #' 
 #' @examples 
 #' #Create founder haplotypes
-#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10, inbred=TRUE)
+#' founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
 #' 
 #' #Set simulation parameters
 #' SP = SimParam$new(founderPop)

---FILE: R/misc.R---
@@ -339,7 +339,7 @@ writePlink = function(pop, baseName, trait = 1L, snpChip = 1L, simParam = NULL,
   if (is.null(simParam)) {
     simParam = get(x = ""SP"", envir = .GlobalEnv)
   }
-  if (simParam$ploidy != 2L) {
+  if (pop@ploidy != 2L) {
     stop(""writePlink() works only with diploids!"")
   }  
   

---FILE: R/pullGeno.R---
@@ -533,6 +533,20 @@ pullSegSiteHaplo = function(pop, haplo=""all"",
 #' (IBD) coding of locus alleles. The matrix colnames reflect whether
 #' all segregagting loci (sites) are retreived or only SNP array loci.
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$addSnpChip(5)
+#' SP$setTrackRec(TRUE)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' pullIbdHaplo(pop, simParam=SP)
+#' 
 #' @export
 pullIbdHaplo = function(pop = NULL, chr = NULL, snpChip = NULL, pedigree = NULL, simParam = NULL) {
   
@@ -541,7 +555,7 @@ pullIbdHaplo = function(pop = NULL, chr = NULL, snpChip = NULL, pedigree = NULL,
   if (is.null(simParam)) {
     simParam = get(x = ""SP"", envir = .GlobalEnv)
   }
-  if (simParam$ploidy != 2L) {
+  if (pop@ploidy != 2L) {
     stop(""pullIbdHaplo() works (currently) only with diploids!"")
   }
   if (!simParam$isTrackRec) {
@@ -585,8 +599,8 @@ pullIbdHaplo = function(pop = NULL, chr = NULL, snpChip = NULL, pedigree = NULL,
   output = getIbdHaplo(ibdRecHist  = ibdRecHist,
                        individuals = individuals,
                        nLociPerChr = lociPerChr)
-  rownames(output) = paste(rep(x = individuals,        each  = simParam$ploidy),
-                           rep(x = 1L:simParam$ploidy, times = nInd), sep = ""_"")
+  rownames(output) = paste(rep(x = individuals,        each  = pop@ploidy),
+                           rep(x = 1L:pop@ploidy, times = nInd), sep = ""_"")
   
   # ---- Subset loci -----
   

---FILE: man/hybridCross.Rd---
@@ -31,7 +31,7 @@ new individuals is [mother_id]_[father_id]
 }
 \examples{
 #Create founder haplotypes
-founderPop = quickHaplo(nInd=10, nChr=1, segSites=10, inbred=TRUE)
+founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
 
 #Set simulation parameters
 SP = SimParam$new(founderPop)

---FILE: man/pullIbdHaplo.Rd---
@@ -37,3 +37,18 @@ all segregagting loci (sites) are retreived or only SNP array loci.
 \description{
 Retrieves Identity By Descent (IBD) haplotype data
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$addSnpChip(5)
+SP$setTrackRec(TRUE)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+pullIbdHaplo(pop, simParam=SP)
+
+}

---FILE: man/trackHaploPop.Rd---
@@ -1,36 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/founderPop.R
-\name{trackHaploPop}
-\alias{trackHaploPop}
-\title{Haplotype tracking population}
-\usage{
-trackHaploPop(genMap, nInd, inbred = FALSE, ploidy = 2L)
-}
-\arguments{
-\item{genMap}{a list of genetic maps}
-
-\item{nInd}{number of individuals}
-
-\item{inbred}{should individuals be fully inbred}
-
-\item{ploidy}{ploidy level of organism}
-}
-\description{
-Creates a population contain haplotypes numbered for 
-identity be descent tracking.
-}
-\details{
-Each item of genMap must be a vector of ordered genetic lengths in 
-Morgans. The first value must be zero. The length of the vector 
-determines the number of segregating sites on the chromosome.
-
-If inbred=FALSE, the value of nInd must be less than or equal to 
-128. Otherwise, it must be less than or equal to 256.
-}
-\examples{
-# Create genetic map for a single chromosome with 1 Morgan
-# Chromosome contains 11 equally spaced segregating sites
-genMap = list(seq(0,1,length.out=11))
-founderPop = trackHaploPop(genMap=genMap,nInd=10)
-
-}

---FILE: tests/testthat/test-crossing.R---
@@ -1,6 +1,8 @@
 context(""crossing"")
 
-founderPop = trackHaploPop(genMap=list(c(0)),nInd=2,inbred=TRUE)
+founderPop = newMapPop(list(c(0)),
+                       list(matrix(c(1,1,0,0),
+                                   nrow=4,ncol=1)))
 
 test_that(""makeCross"",{
   SP = SimParam$new(founderPop=founderPop)

---FILE: tests/testthat/test-editGenome.R---
@@ -1,8 +1,9 @@
 context(""editGenome"")
 
 test_that(""editGenome"",{
-  genMap = list(c(0))
-  founderPop = trackHaploPop(genMap=genMap,nInd=2,inbred=TRUE)
+  founderPop = newMapPop(list(c(0)),
+                         list(matrix(c(0,0,1,1),
+                                     nrow=4,ncol=1)))
   SP = SimParam$new(founderPop=founderPop)
   SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
   pop = newPop(founderPop,simParam=SP)

---FILE: tests/testthat/test-hybrids.R---
@@ -1,8 +1,10 @@
 context(""hybrids"")
 
+founderPop = newMapPop(list(c(0)),
+                       list(matrix(c(1,1,0,0),
+                                   nrow=4,ncol=1)))
+
 test_that(""hybridCross"",{
-  genMap = list(c(0))
-  founderPop = trackHaploPop(genMap=genMap,nInd=2,inbred=TRUE)
   SP = SimParam$new(founderPop=founderPop)
   SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
   pop = newPop(founderPop,simParam=SP)
@@ -27,8 +29,6 @@ test_that(""hybridCross"",{
 })
 
 test_that(""calcGCA"",{
-  genMap = list(c(0))
-  founderPop = trackHaploPop(genMap=genMap,nInd=2,inbred=TRUE)
   SP = SimParam$new(founderPop=founderPop)
   SP$addTraitA(nQtlPerChr=1,mean=c(0,0),var=c(1,1))
   SP$setVarE(varE=c(1,1))"
gaynorr,AlphaSimR,19ead3a6d1409e22ac67c9d22cdf20030e45b9e1,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-02-14T09:23:21Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-02-14T09:23:21Z,-fixed faulting double crossover logic,DESCRIPTION;NEWS;src/meiosis.cpp;tests/testthat/test-crossing.R,False,True,True,False,34,17,51,"---FILE: DESCRIPTION---
@@ -1,7 +1,7 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 0.9.0
+Version: 0.9.1
 Date: 2019-2-7
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),

---FILE: NEWS---
@@ -1,3 +1,8 @@
+Changes in version 0.9.1
+  
+  Bug fixes
+    -fixed faulting double crossover logic
+
 Changes in version 0.9.0
 
   New features

---FILE: src/meiosis.cpp---
@@ -85,19 +85,32 @@ arma::uword intervalSearch(const arma::vec& x, double& value, arma::uword left=0
   return left;
 }
 
-// Removes hidden double crossover from recombination map
+// Removes hidden crossovers from recombination map
+// Assumes first row is always site 1 and no other row
+// will have a value of 1. This logic is based on 
+// the implementation of intervalSearch.
 arma::Mat<int> removeDoubleCO(const arma::Mat<int>& X){
-  arma::Col<int> take(X.n_rows,arma::fill::zeros);
-  ++take(0);
-  int lastChr, lastSite;
-  lastChr = X(0,0);
-  lastSite = X(0,1);
+  if(X.n_rows<3){
+    return X;
+  }
+  // Initially assume all rows are useful
+  arma::Col<int> take(X.n_rows,arma::fill::ones);
+  // Remove unobserved crossovers (site doesn't change)
+  // Works backwards, because the last crossover is observed
+  for(arma::uword i=(X.n_rows-2); i>0; --i){
+    if(X(i,1) == X(i+1,1)){
+      take(i) = 0;
+    }
+  }
+  // Remove redundant records (chromosome doesn't change)
+  int lastChr = X(0,0);
   for(arma::uword i=1; i<X.n_rows; ++i){
-    if((X(i,0)!=lastChr) & 
-       (X(i,1)!=lastSite)){
-      ++take(i);
-      lastChr = X(i,0);
-      lastSite = X(i,1);
+    if(take(i) == 1){
+      if(X(i,0) == lastChr){
+        take(i) = 0;
+      }else{
+        lastChr = X(i,0);
+      }
     }
   }
   return X.rows(find(take>0));
@@ -175,8 +188,8 @@ arma::Mat<int>  findQuadrivalentCO(arma::uword chr, //1-4
       }
     }
     nCO_1 = relPosCO(0) + relPosCO(1);
-    switch(chr){
-    case 1:
+    switch(chr){ // Identity of selected centromere
+    case 1: 
       if(relPosCO(0)%2 == 0){
         pairChr1(0) = 1;
         pairChr1(1) = 2;
@@ -251,7 +264,7 @@ arma::Mat<int>  findQuadrivalentCO(arma::uword chr, //1-4
       }
     }
     nCO_1 = relPosCO(0);
-    switch(chr){
+    switch(chr){ // Identity of selected centromere
     case 1:
       if(relPosCO(1)%2 == 0){
         pairChr2(0) = 1;

---FILE: tests/testthat/test-crossing.R---
@@ -1,7 +1,6 @@
 context(""crossing"")
 
-genMap = list(c(0))
-founderPop = trackHaploPop(genMap=genMap,nInd=2,inbred=TRUE)
+founderPop = trackHaploPop(genMap=list(c(0)),nInd=2,inbred=TRUE)
 
 test_that(""makeCross"",{
   SP = SimParam$new(founderPop=founderPop)"
gaynorr,AlphaSimR,e6b6c00e6dfb32b05879432a94f2de9a77050dcd,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-01-28T09:33:58Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2019-01-28T09:33:58Z,bug fixes,DESCRIPTION;R/Class-SimParam.R;R/RcppExports.R;R/crossing.R;R/founderPop.R;R/hybrids.R;man/SimParam.Rd;man/SimParam_switchFemaleMap.Rd;man/SimParam_switchGenMap.Rd;man/SimParam_switchMaleMap.Rd;man/hybridCross.Rd;man/sampleHaplo.Rd;man/setPhenoGCA.Rd;src/GEBV.cpp;src/RcppExports.cpp;src/alphasimr.h;src/getGv.cpp;src/getGv.h;src/getHybridGv.cpp;src/init.c;src/meiosis.cpp;src/misc.cpp;src/misc.h;src/tuneTraits.cpp,False,True,True,False,277,202,479,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
 Version: 0.9.0
-Date: 2019-1-25
+Date: 2019-1-28
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: R/Class-SimParam.R---
@@ -17,6 +17,10 @@
 #' males
 #' @field sepMap are there seperate genetic maps for 
 #' males and females
+#' @field femaleCentromere position of centromere on female 
+#' genetic map
+#' @field maleCentromere position of centromere on male 
+#' genetic map
 #' @field recombRatio ratio of genetic recombination in 
 #' females relative to male
 #' @field traits list of trait
@@ -49,6 +53,8 @@ SimParam = R6Class(
     .femaleMap=""matrix"",
     .maleMap=""matrix"",
     .sepMap=""logical"",
+    .femaleCentromere=""numeric"",
+    .maleCentromere=""numeric"",
     .recombRatio=""numeric"",
     .traits=""list"",
     .snpChips=""list"",
@@ -141,6 +147,35 @@ SimParam = R6Class(
         stop(""`$maleMap` is read only"",call.=FALSE)
       }
     },
+    centromere=function(value){
+      if(missing(value)){
+        if(private$.sepMap){
+          (private$.femaleCentromere+private$.maleCentromere)/2
+        }else{
+          private$.femaleCentromere
+        }
+      }else{
+        stop(""`$centromere` is read only"",call.=FALSE)
+      }
+    },
+    femaleCentromere=function(value){
+      if(missing(value)){
+        private$.femaleCentromere
+      }else{
+        stop(""`$femaleCentromere` is read only"",call.=FALSE)
+      }
+    },
+    maleCentromere=function(value){
+      if(missing(value)){
+        if(private$.sepMap){
+          private$.maleCentromere
+        }else{
+          private$.femaleCentromere
+        }
+      }else{
+        stop(""`$maleCentromere` is read only"",call.=FALSE)
+      }
+    },
     traits=function(value){
       if(missing(value)){
         private$.traits
@@ -274,6 +309,8 @@ SimParam$set(
     private$.femaleMap = founderPop@genMap
     private$.maleMap = NULL
     private$.sepMap = FALSE
+    private$.femaleCentromere = founderPop@centromere
+    private$.maleCentromere = NULL
     private$.traits = list()
     private$.snpChips = list()
     private$.potQtl = lapply(
@@ -652,12 +689,14 @@ SimParam$set(
                feSc*x
              })
     )
+    private$.femaleCentromere = feSc*private$.femaleCentromere
     private$.maleMap = as.matrix(
       lapply(genMap,
              function(x){
                maSc*x
              })
     )
+    private$.maleCentromere = maSc*private$.maleCentromere
     invisible(self)
   }
 )
@@ -1668,20 +1707,29 @@ SimParam$set(
 #' @param genMap a list of length nChr containing 
 #' numeric vectors for the position of each segregating 
 #' site on a chromosome.
+#' @param centromere a numeric vector of centromere 
+#' positions. If NULL, the centromere are assumed to 
+#' be metacentric.
 #' 
 #' @name SimParam_switchGenMap
 NULL
 # switchGenMap ----
 SimParam$set(
   ""public"",
   ""switchGenMap"",
-  function(genMap){
-    stopifnot(length(genMap)==private$.nChr)
+  function(genMap, centromere=NULL){
+    if(is.null(centromere)){
+      centromere=sapply(genMap,max)/2
+    }
+    stopifnot(length(genMap)==private$.nChr,
+              centromere<=sapply(genMap,max))
     tmp = do.call(""c"",lapply(genMap,length))
     stopifnot(all(tmp==private$.segSites))
     private$.sepMap = FALSE
     private$.femaleMap = genMap
     private$.maleMap = NULL
+    private$.femaleCentromere = centromere
+    private$.maleCentromere = NULL
     invisible(self)
   }
 )
@@ -1696,23 +1744,33 @@ SimParam$set(
 #' @param genMap a list of length nChr containing 
 #' numeric vectors for the position of each segregating 
 #' site on a chromosome.
+#' @param centromere a numeric vector of centromere 
+#' positions. If NULL, the centromere are assumed to 
+#' be metacentric.
 #' 
 #' @name SimParam_switchFemaleMap
 NULL
 # switchFemaleMap ----
 SimParam$set(
   ""public"",
   ""switchFemaleMap"",
-  function(genMap){
-    stopifnot(length(genMap)==private$.nChr)
+  function(genMap, centromere=NULL){
+    if(is.null(centromere)){
+      centromere=sapply(genMap,max)/2
+    }
+    stopifnot(length(genMap)==private$.nChr,
+              centromere<=sapply(genMap,max))
     tmp = do.call(""c"",lapply(genMap,length))
     stopifnot(all(tmp==private$.segSites))
     if(private$.sepMap){
       private$.femaleMap = genMap
+      private$.femaleCentromere = centromere
     }else{
       private$.sepMap = TRUE
       private$.maleMap = private$.femaleMap
       private$.femaleMap = genMap
+      private$.maleCentromere = private$.femaleCentromere
+      private$.femaleCentromere = centromere
     }
     invisible(self)
   }
@@ -1728,19 +1786,27 @@ SimParam$set(
 #' @param genMap a list of length nChr containing 
 #' numeric vectors for the position of each segregating 
 #' site on a chromosome.
+#' @param centromere a numeric vector of centromere 
+#' positions. If NULL, the centromere are assumed to 
+#' be metacentric.
 #' 
 #' @name SimParam_switchMaleMap
 NULL
 # switchMaleMap ----
 SimParam$set(
   ""public"",
   ""switchMaleMap"",
-  function(genMap){
-    stopifnot(length(genMap)==private$.nChr)
+  function(genMap, centromere=NULL){
+    if(is.null(centromere)){
+      centromere=sapply(genMap,max)/2
+    }
+    stopifnot(length(genMap)==private$.nChr,
+              centromere<=sapply(genMap,max))
     tmp = do.call(""c"",lapply(genMap,length))
     stopifnot(all(tmp==private$.segSites))
     private$.sepMap = TRUE
     private$.maleMap = genMap
+    private$.maleCentromere = centromere
     invisible(self)
   }
 )

---FILE: R/RcppExports.R---
@@ -97,12 +97,12 @@ calcGenParam <- function(trait, pop, nThreads) {
     .Call(`_AlphaSimR_calcGenParam`, trait, pop, nThreads)
 }
 
-getHybridGv <- function(trait, motherGeno, mother, fatherGeno, father, nThreads) {
-    .Call(`_AlphaSimR_getHybridGv`, trait, motherGeno, mother, fatherGeno, father, nThreads)
+getHybridGv <- function(trait, females, femaleParents, males, maleParents, nThreads) {
+    .Call(`_AlphaSimR_getHybridGv`, trait, females, femaleParents, males, maleParents, nThreads)
 }
 
-cross <- function(motherGeno, mother, fatherGeno, father, femaleMap, maleMap, trackRec, motherPloidy, fatherPloidy, quadProb, nThreads) {
-    .Call(`_AlphaSimR_cross`, motherGeno, mother, fatherGeno, father, femaleMap, maleMap, trackRec, motherPloidy, fatherPloidy, quadProb, nThreads)
+cross <- function(motherGeno, mother, fatherGeno, father, femaleMap, maleMap, trackRec, motherPloidy, fatherPloidy, motherCentromere, fatherCentromere, quadProb, nThreads) {
+    .Call(`_AlphaSimR_cross`, motherGeno, mother, fatherGeno, father, femaleMap, maleMap, trackRec, motherPloidy, fatherPloidy, motherCentromere, fatherCentromere, quadProb, nThreads)
 }
 
 createDH2 <- function(geno, nDH, genMap, trackRec, nThreads) {

---FILE: R/crossing.R---
@@ -50,6 +50,8 @@ makeCross = function(pop,crossPlan,simParam=NULL){
               simParam$isTrackRec,
               pop@ploidy,
               pop@ploidy,
+              simParam$femaleCentromere,
+              simParam$maleCentromere,
               simParam$quadProb,
               simParam$nThreads)
   rPop = new(""RawPop"",
@@ -289,12 +291,14 @@ makeCross2 = function(females,males,crossPlan,simParam=NULL){
             simParam$isTrackRec,
             females@ploidy,
             males@ploidy,
+            simParam$femaleCentromere,
+            simParam$maleCentromere,
             simParam$quadProb,
             simParam$nThreads)
   rPop = new(""RawPop"",
              nInd=nrow(crossPlan),
              nChr=females@nChr,
-             ploidy=females@ploidy,
+             ploidy=as.integer((females@ploidy+males@ploidy)/2),
              nLoci=females@nLoci,
              geno=tmp$geno)
   if(simParam$isTrackRec){
@@ -447,6 +451,8 @@ self = function(pop,nProgeny=1,parents=NULL,simParam=NULL){
               simParam$isTrackRec,
               pop@ploidy,
               pop@ploidy,
+              simParam$femaleCentromere,
+              simParam$maleCentromere,
               simParam$quadProb,
               simParam$nThreads)
   rPop = new(""RawPop"",

---FILE: R/founderPop.R---
@@ -339,6 +339,8 @@ runMacs2 = function(nInd,nChr=1,segSites=NULL,Ne=100,
 #' sample haplotypes
 #' @param nInd the number of individuals to create
 #' @param inbred should new individuals be fully inbred
+#' @param ploidy new ploidy level for organism. If NULL, 
+#' the ploidy level of the mapPop is used.
 #' @param replace should haplotypes be sampled with replacement
 #' 
 #' @return an object of \code{\link{MapPop-class}}
@@ -351,34 +353,36 @@ runMacs2 = function(nInd,nChr=1,segSites=NULL,Ne=100,
 #' founderPop = sampleHaplo(nInd=20,mapPop=founderPop)
 #' 
 #' @export
-sampleHaplo = function(mapPop,nInd,inbred=FALSE,replace=TRUE){
+sampleHaplo = function(mapPop,nInd,inbred=FALSE,ploidy=NULL,replace=TRUE){
+  if(is.null(ploidy)) ploidy = mapPop@ploidy
   nHaplo = mapPop@nInd*mapPop@ploidy
   if(inbred){
     nSamp = nInd
   }else{
-    nSamp = nInd*mapPop@ploidy
+    nSamp = nInd*ploidy
   }
+  if(!replace) stopifnot(nHaplo>=nSamp)
   output = vector(""list"",mapPop@nChr)
   for(chr in 1:mapPop@nChr){
     haplo = sample.int(nHaplo,nSamp,replace=replace)
     geno = array(data=as.raw(0),
                  dim=c(mapPop@nLoci[chr],
-                       mapPop@ploidy,nInd))
+                       ploidy,nInd))
     outHap = 1L 
     outInd = 1L
     for(i in 1:length(haplo)){
       inHap = (haplo[i]-1L)%%mapPop@ploidy + 1L
       inInd = (haplo[i]-1L)%/%mapPop@ploidy + 1L
       if(inbred){
-        for(outHap in 1:mapPop@ploidy){
+        for(outHap in 1:ploidy){
           geno[,outHap,outInd] = 
             mapPop@geno[[chr]][,inHap,inInd]
         }
         outInd = outInd+1L
       }else{
         geno[,outHap,outInd] = 
           mapPop@geno[[chr]][,inHap,inInd]
-        outHap = outHap%%mapPop@ploidy+1L
+        outHap = outHap%%ploidy+1L
         if(outHap==1L){
           outInd = outInd+1L
         }
@@ -387,7 +391,7 @@ sampleHaplo = function(mapPop,nInd,inbred=FALSE,replace=TRUE){
     output[[chr]] = new(""MapPop"",
                         nInd=as.integer(nInd),
                         nChr=1L,
-                        ploidy=mapPop@ploidy,
+                        ploidy=as.integer(ploidy),
                         nLoci=mapPop@nLoci[chr],
                         geno=as.matrix(list(geno)),
                         genMap=as.matrix(mapPop@genMap[chr]),

---FILE: R/hybrids.R---
@@ -1,33 +1,3 @@
-#A wrapper for calling getHybridGv
-#This function uses chunking to reduce RAM usage
-getHybridGvByChunk = function(trait,females,femaleParents,
-                              males,maleParents,chunkSize, 
-                              nThreads){
-  nOut = length(femaleParents)
-  if(nOut<=chunkSize){
-    output = getHybridGv(trait,females,femaleParents,males,maleParents,
-                         nThreads)
-  }else{
-    Chunks = split(1:nOut,ceiling(seq_along(1:nOut)/chunkSize))
-    output = list()
-    output[[1]] = matrix(NA_real_,nrow=nOut,ncol=1)
-    for(chunk in Chunks){
-      tmp = getHybridGv(trait,females,femaleParents[chunk],
-                        males,maleParents[chunk],nThreads)
-      output[[1]][chunk,] = tmp[[1]]
-      if(length(tmp)==2){
-        if(length(output)==2){
-          output[[2]] = c(output[[2]],tmp[[2]])
-        }else{
-          output[[2]] = tmp[[2]]
-        }
-      }
-    }
-  }
-  return(output)
-}
-
-
 #' @title Hybrid crossing
 #' 
 #' @description 
@@ -45,10 +15,6 @@ getHybridGvByChunk = function(trait,females,femaleParents,
 #' @param returnHybridPop should results be returned as 
 #' \code{\link{HybridPop-class}}. If false returns results as 
 #' \code{\link{Pop-class}}. Population must be fully inbred if TRUE.
-#' @param chunkSize when using returnHybridPop=TRUE, this 
-#' parameter determines the maximum number of hybrids created 
-#' at one time. Smaller values reduce RAM usage, but may take 
-#' more time.
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
 #' @examples 
@@ -65,14 +31,16 @@ getHybridGvByChunk = function(trait,females,femaleParents,
 #' pop2 = hybridCross(pop, pop, simParam=SP)
 #' 
 #' @export
-hybridCross = function(females,males,crossPlan=""testcross"",
-                       returnHybridPop=FALSE,chunkSize=10000,
+hybridCross = function(females, males,
+                       crossPlan=""testcross"",
+                       returnHybridPop=FALSE,
                        simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
-  if(females@ploidy!=2 | males@ploidy!=2){
-    stop(""Only works with diploids"")
+  if((females@ploidy%%2L != 0L) | 
+     (males@ploidy%%2L != 0L)){
+    stop(""You can not cross aneuploids"")
   }
   #crossPlan for test cross
   if(length(crossPlan)==1){
@@ -87,25 +55,30 @@ hybridCross = function(females,males,crossPlan=""testcross"",
   #Set id
   femaleParents = females@id[crossPlan[,1]]
   maleParents = males@id[crossPlan[,2]]
-  id = paste(femaleParents,maleParents,sep=""_"")
+  id = paste(femaleParents, maleParents, sep=""_"")
   
   #Return Pop-class
   if(!returnHybridPop){
-    return(makeCross2(females=females,males=males,
+    return(makeCross2(females=females,
+                      males=males,
                       crossPlan=crossPlan,
                       simParam=simParam))
   }
   
   #Return HybridPop-class
-  gv = matrix(NA_real_,nrow=length(id),
-                      ncol=simParam$nTraits)
+  gv = matrix(NA_real_,
+              nrow=length(id),
+              ncol=simParam$nTraits)
   gxe = vector(""list"",simParam$nTraits)
   i = 0L
   for(trait in simParam$traits){
     i = i+1L
-    tmp = getHybridGvByChunk(trait=trait,females=females,femaleParents=crossPlan[,1],
-                             males=males,maleParents=crossPlan[,2],chunkSize=chunkSize,
-                             nThreads=simParam$nThreads)
+    tmp = getHybridGv(trait=trait,
+                      females=females,
+                      femaleParents=crossPlan[,1],
+                      males=males,
+                      maleParents=crossPlan[,2],
+                      nThreads=simParam$nThreads)
     gv[,i] = tmp[[1]]
     if(length(tmp)==2){
       gxe[[i]] = tmp[[2]]
@@ -260,10 +233,6 @@ calcGCA = function(pop,use=""pheno""){
 #' @param inbred are both pop and testers fully inbred. They are only 
 #' fully inbred if created by \code{\link{newPop}} using inbred founders 
 #' or by the \code{\link{makeDH}} function
-#' @param chunkSize when using inbred=TRUE, this 
-#' parameter determines the maximum number of hybrids created 
-#' at one time. Smaller values reduce RAM usage, but may take 
-#' more time.
 #' @param onlyPheno should only the phenotype be returned, see return
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
@@ -293,7 +262,7 @@ calcGCA = function(pop,use=""pheno""){
 #' 
 #' @export
 setPhenoGCA = function(pop,testers,use=""pheno"",varE=NULL,reps=1,
-                       fixEff=1L,p=0.5,inbred=FALSE,chunkSize=10000,
+                       fixEff=1L,p=0.5,inbred=FALSE,
                        onlyPheno=FALSE,simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
@@ -305,7 +274,7 @@ setPhenoGCA = function(pop,testers,use=""pheno"",varE=NULL,reps=1,
   use = tolower(use)
   #Make hybrids
   tmp = hybridCross(females=pop,males=testers,crossPlan=""testcross"",
-                    returnHybridPop=inbred,chunkSize=chunkSize,simParam=simParam)
+                    returnHybridPop=inbred,simParam=simParam)
   #Get response
   if(use==""pheno""){
     y = setPheno(tmp,varE=varE,p=p,reps=reps,

---FILE: man/SimParam.Rd---
@@ -36,6 +36,12 @@ males}
 \item{\code{sepMap}}{are there seperate genetic maps for 
 males and females}
 
+\item{\code{femaleCentromere}}{position of centromere on female 
+genetic map}
+
+\item{\code{maleCentromere}}{position of centromere on male 
+genetic map}
+
 \item{\code{recombRatio}}{ratio of genetic recombination in 
 females relative to male}
 

---FILE: man/SimParam_switchFemaleMap.Rd---
@@ -7,6 +7,10 @@
 \item{genMap}{a list of length nChr containing 
 numeric vectors for the position of each segregating 
 site on a chromosome.}
+
+\item{centromere}{a numeric vector of centromere 
+positions. If NULL, the centromere are assumed to 
+be metacentric.}
 }
 \description{
 Replaces existing female genetic map.

---FILE: man/SimParam_switchGenMap.Rd---
@@ -7,6 +7,10 @@
 \item{genMap}{a list of length nChr containing 
 numeric vectors for the position of each segregating 
 site on a chromosome.}
+
+\item{centromere}{a numeric vector of centromere 
+positions. If NULL, the centromere are assumed to 
+be metacentric.}
 }
 \description{
 Replaces existing genetic map.

---FILE: man/SimParam_switchMaleMap.Rd---
@@ -7,6 +7,10 @@
 \item{genMap}{a list of length nChr containing 
 numeric vectors for the position of each segregating 
 site on a chromosome.}
+
+\item{centromere}{a numeric vector of centromere 
+positions. If NULL, the centromere are assumed to 
+be metacentric.}
 }
 \description{
 Replaces existing male genetic map.

---FILE: man/hybridCross.Rd---
@@ -5,7 +5,7 @@
 \title{Hybrid crossing}
 \usage{
 hybridCross(females, males, crossPlan = ""testcross"",
-  returnHybridPop = FALSE, chunkSize = 10000, simParam = NULL)
+  returnHybridPop = FALSE, simParam = NULL)
 }
 \arguments{
 \item{females}{female population, an object of \code{\link{Pop-class}}}
@@ -19,11 +19,6 @@ or a matrix with two columns for designed crosses}
 \code{\link{HybridPop-class}}. If false returns results as 
 \code{\link{Pop-class}}. Population must be fully inbred if TRUE.}
 
-\item{chunkSize}{when using returnHybridPop=TRUE, this 
-parameter determines the maximum number of hybrids created 
-at one time. Smaller values reduce RAM usage, but may take 
-more time.}
-
 \item{simParam}{an object of \code{\link{SimParam}}}
 }
 \description{

---FILE: man/sampleHaplo.Rd---
@@ -4,7 +4,8 @@
 \alias{sampleHaplo}
 \title{Sample haplotypes from a MapPop}
 \usage{
-sampleHaplo(mapPop, nInd, inbred = FALSE, replace = TRUE)
+sampleHaplo(mapPop, nInd, inbred = FALSE, ploidy = NULL,
+  replace = TRUE)
 }
 \arguments{
 \item{mapPop}{the \code{\link{MapPop-class}} used to 
@@ -14,6 +15,9 @@ sample haplotypes}
 
 \item{inbred}{should new individuals be fully inbred}
 
+\item{ploidy}{new ploidy level for organism. If NULL, 
+the ploidy level of the mapPop is used.}
+
 \item{replace}{should haplotypes be sampled with replacement}
 }
 \value{

---FILE: man/setPhenoGCA.Rd---
@@ -5,8 +5,8 @@
 \title{Set GCA as phenotype}
 \usage{
 setPhenoGCA(pop, testers, use = ""pheno"", varE = NULL, reps = 1,
-  fixEff = 1L, p = 0.5, inbred = FALSE, chunkSize = 10000,
-  onlyPheno = FALSE, simParam = NULL)
+  fixEff = 1L, p = 0.5, inbred = FALSE, onlyPheno = FALSE,
+  simParam = NULL)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}}}
@@ -30,11 +30,6 @@ by genomic selection models only.}
 fully inbred if created by \code{\link{newPop}} using inbred founders 
 or by the \code{\link{makeDH}} function}
 
-\item{chunkSize}{when using inbred=TRUE, this 
-parameter determines the maximum number of hybrids created 
-at one time. Smaller values reduce RAM usage, but may take 
-more time.}
-
 \item{onlyPheno}{should only the phenotype be returned, see return}
 
 \item{simParam}{an object of \code{\link{SimParam}}}

---FILE: src/GEBV.cpp---
@@ -1,7 +1,6 @@
 // [[Rcpp::depends(RcppArmadillo)]]
 #include ""alphasimr.h""
 
-
 // Retrieves GEBVs for RRsol
 // [[Rcpp::export]]
 arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop, 

---FILE: src/RcppExports.cpp---
@@ -365,24 +365,24 @@ BEGIN_RCPP
 END_RCPP
 }
 // getHybridGv
-arma::field<arma::vec> getHybridGv(const Rcpp::S4& trait, const Rcpp::S4& motherGeno, arma::uvec& mother, const Rcpp::S4& fatherGeno, arma::uvec& father, int nThreads);
-RcppExport SEXP _AlphaSimR_getHybridGv(SEXP traitSEXP, SEXP motherGenoSEXP, SEXP motherSEXP, SEXP fatherGenoSEXP, SEXP fatherSEXP, SEXP nThreadsSEXP) {
+arma::field<arma::vec> getHybridGv(const Rcpp::S4& trait, const Rcpp::S4& females, arma::uvec femaleParents, const Rcpp::S4& males, arma::uvec maleParents, int nThreads);
+RcppExport SEXP _AlphaSimR_getHybridGv(SEXP traitSEXP, SEXP femalesSEXP, SEXP femaleParentsSEXP, SEXP malesSEXP, SEXP maleParentsSEXP, SEXP nThreadsSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
     Rcpp::traits::input_parameter< const Rcpp::S4& >::type trait(traitSEXP);
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type motherGeno(motherGenoSEXP);
-    Rcpp::traits::input_parameter< arma::uvec& >::type mother(motherSEXP);
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type fatherGeno(fatherGenoSEXP);
-    Rcpp::traits::input_parameter< arma::uvec& >::type father(fatherSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type females(femalesSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type femaleParents(femaleParentsSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type males(malesSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type maleParents(maleParentsSEXP);
     Rcpp::traits::input_parameter< int >::type nThreads(nThreadsSEXP);
-    rcpp_result_gen = Rcpp::wrap(getHybridGv(trait, motherGeno, mother, fatherGeno, father, nThreads));
+    rcpp_result_gen = Rcpp::wrap(getHybridGv(trait, females, femaleParents, males, maleParents, nThreads));
     return rcpp_result_gen;
 END_RCPP
 }
 // cross
-Rcpp::List cross(const arma::field<arma::Cube<unsigned char> >& motherGeno, arma::uvec mother, const arma::field<arma::Cube<unsigned char> >& fatherGeno, arma::uvec father, const arma::field<arma::vec>& femaleMap, const arma::field<arma::vec>& maleMap, bool trackRec, arma::uword motherPloidy, arma::uword fatherPloidy, double quadProb, int nThreads);
-RcppExport SEXP _AlphaSimR_cross(SEXP motherGenoSEXP, SEXP motherSEXP, SEXP fatherGenoSEXP, SEXP fatherSEXP, SEXP femaleMapSEXP, SEXP maleMapSEXP, SEXP trackRecSEXP, SEXP motherPloidySEXP, SEXP fatherPloidySEXP, SEXP quadProbSEXP, SEXP nThreadsSEXP) {
+Rcpp::List cross(const arma::field<arma::Cube<unsigned char> >& motherGeno, arma::uvec mother, const arma::field<arma::Cube<unsigned char> >& fatherGeno, arma::uvec father, const arma::field<arma::vec>& femaleMap, const arma::field<arma::vec>& maleMap, bool trackRec, arma::uword motherPloidy, arma::uword fatherPloidy, const arma::vec& motherCentromere, const arma::vec& fatherCentromere, double quadProb, int nThreads);
+RcppExport SEXP _AlphaSimR_cross(SEXP motherGenoSEXP, SEXP motherSEXP, SEXP fatherGenoSEXP, SEXP fatherSEXP, SEXP femaleMapSEXP, SEXP maleMapSEXP, SEXP trackRecSEXP, SEXP motherPloidySEXP, SEXP fatherPloidySEXP, SEXP motherCentromereSEXP, SEXP fatherCentromereSEXP, SEXP quadProbSEXP, SEXP nThreadsSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
@@ -395,9 +395,11 @@ BEGIN_RCPP
     Rcpp::traits::input_parameter< bool >::type trackRec(trackRecSEXP);
     Rcpp::traits::input_parameter< arma::uword >::type motherPloidy(motherPloidySEXP);
     Rcpp::traits::input_parameter< arma::uword >::type fatherPloidy(fatherPloidySEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type motherCentromere(motherCentromereSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type fatherCentromere(fatherCentromereSEXP);
     Rcpp::traits::input_parameter< double >::type quadProb(quadProbSEXP);
     Rcpp::traits::input_parameter< int >::type nThreads(nThreadsSEXP);
-    rcpp_result_gen = Rcpp::wrap(cross(motherGeno, mother, fatherGeno, father, femaleMap, maleMap, trackRec, motherPloidy, fatherPloidy, quadProb, nThreads));
+    rcpp_result_gen = Rcpp::wrap(cross(motherGeno, mother, fatherGeno, father, femaleMap, maleMap, trackRec, motherPloidy, fatherPloidy, motherCentromere, fatherCentromere, quadProb, nThreads));
     return rcpp_result_gen;
 END_RCPP
 }

---FILE: src/alphasimr.h---
@@ -3,7 +3,6 @@
 
 #include <RcppArmadillo.h>
 #include ""getGeno.h""
-#include ""getGv.h""
 #include ""optimize.h""
 #include ""misc.h""
 #ifdef _OPENMP

---FILE: src/getGv.cpp---
@@ -1,40 +1,6 @@
 // [[Rcpp::depends(RcppArmadillo)]]
 #include ""alphasimr.h""
 
-// Calculates genetic values for a trait with only additive effects
-arma::vec calcGvA(const arma::Mat<unsigned char>& geno,
-                  const arma::vec& a, double intercept, 
-                  int nThreads){
-  arma::vec output(geno.n_cols);
-  output.fill(intercept);
-#ifdef _OPENMP
-#pragma omp parallel for schedule(static) num_threads(nThreads)
-#endif
-  for(arma::uword i=0; i<geno.n_cols; ++i){
-    for(arma::uword j=0; j<geno.n_rows; ++j){
-      output(i) += geno(j,i)*a(j);
-    }
-  }
-  return output;
-}
-
-// Calculates genetic values for a trait with additive and dominance effects
-arma::vec calcGvAD(const arma::Mat<unsigned char>& geno,
-                   const arma::vec& a, const arma::vec& d,
-                   double intercept, int nThreads){
-  arma::vec output(geno.n_cols);
-  output.fill(intercept);
-#ifdef _OPENMP
-#pragma omp parallel for schedule(static) num_threads(nThreads)
-#endif
-  for(arma::uword i=0; i<geno.n_cols; ++i){
-    for(arma::uword j=0; j<geno.n_rows; ++j){
-      output(i) += geno(j,i)*a(j)+(1-abs(int(geno(j,i))-1))*d(j);
-    }
-  }
-  return output;
-}
-
 // Calculates genetic values for a trait
 // Returns output in a list with length 1 or 2
 //   The first item contains genetic values
@@ -119,15 +85,10 @@ arma::field<arma::vec> getGv(const Rcpp::S4& trait,
   return output;
 }
 
-double choose(double n, double k){ // n choose k
-  if(k==0) return 1;
-  return (n*choose(n-1,k-1))/k;
-}
-
-// A calculates breeding values and dominance deviations and genic
+// Calculates breeding values, dominance deviations and genic
 // variances. Additive and dominance genetic variances are calculated
-// from breeding values and dominance deviations. Formulat accounts 
-// for inbreeding in the population. Only works for ploidy=2.
+// from breeding values and dominance deviations. Formula accounts 
+// for inbreeding in the population.
 // [[Rcpp::export]]
 Rcpp::List calcGenParam(const Rcpp::S4& trait, const Rcpp::S4& pop,
                         int nThreads){
@@ -210,10 +171,13 @@ Rcpp::List calcGenParam(const Rcpp::S4& trait, const Rcpp::S4& pop,
         }
         alpha = accu(freq%(gv-gvMu)%(x-genoMu))/
           accu(freq%(x-genoMu)%(x-genoMu));
-        if(isinf(alpha)) alpha=0; //Check for divide by zero
         alphaE = accu(freqE%(gv-gvMu)%(x-genoMu))/
-          accu(freqE%(x-genoMu)%(x-genoMu)); //Check for divide by zero
-        if(isinf(alphaE)) alphaE=0;
+          accu(freqE%(x-genoMu)%(x-genoMu)); 
+        
+        //Check for divide by zero
+        if(isinf(alpha) | isnan(alpha)) alpha=0;
+        if(isinf(alphaE) | isnan(alphaE)) alphaE=0;
+        
         gvEMu =  accu(freqE%gv);
         eMu(i) += gvEMu;
         bv = (x-genoMu)*alpha; //Breeding values

---FILE: src/getGv.h---
@@ -1,12 +0,0 @@
-#ifndef GETGV_H
-#define GETGV_H
-
-arma::vec calcGvA(const arma::Mat<unsigned char>& geno,
-                  const arma::vec& a, double intercept,
-                  int nThreads);
-
-arma::vec calcGvAD(const arma::Mat<unsigned char>& geno,
-                   const arma::vec& a, const arma::vec& d,
-                   double intercept, int nThreads);
-
-#endif
\ No newline at end of file

---FILE: src/getHybridGv.cpp---
@@ -1,51 +1,98 @@
 // [[Rcpp::depends(RcppArmadillo)]]
 #include ""alphasimr.h""
 
-// Retrieves hybrid geno under the assumption lines are completely inbred
-arma::Mat<unsigned char> getHybridGeno(const Rcpp::S4& trait, 
-                                       const Rcpp::S4& motherGeno, arma::uvec mother,
-                                       const Rcpp::S4& fatherGeno, arma::uvec father){
-  // R to C++
-  mother = mother-1;
-  father = father-1;
-  arma::Mat<unsigned char> geno;
-  geno = (getGenoT(motherGeno.slot(""geno""), 
-                   trait.slot(""lociPerChr""),
-                   trait.slot(""lociLoc""))).cols(mother);
-  geno += (getGenoT(fatherGeno.slot(""geno""), 
-                    trait.slot(""lociPerChr""),
-                    trait.slot(""lociLoc""))).cols(father);
-  geno = geno/2;
-  return geno;
-}
-
+// Calculates genetic values for a trait
+// Returns output in a list with length 1 or 2
+//   The first item contains genetic values
+//   The second item contains GxE effects (optional)
 // [[Rcpp::export]]
 arma::field<arma::vec> getHybridGv(const Rcpp::S4& trait, 
-                                   const Rcpp::S4& motherGeno, arma::uvec& mother,
-                                   const Rcpp::S4& fatherGeno, arma::uvec& father, 
+                                   const Rcpp::S4& females,
+                                   arma::uvec femaleParents,
+                                   const Rcpp::S4& males,
+                                   arma::uvec maleParents,
                                    int nThreads){
+  femaleParents -= 1; // R to C++
+  maleParents -= 1; // R to C++
   arma::field<arma::vec> output;
   bool hasD = trait.hasSlot(""domEff"");
   bool hasGxe = trait.hasSlot(""gxeEff"");
+  arma::uword nChr = females.slot(""nChr"");
+  arma::uword nInd = femaleParents.n_elem;
+  arma::uword ploidyF = females.slot(""ploidy"");
+  arma::uword ploidyM = males.slot(""ploidy"");
+  arma::uword ploidy = ploidyF+ploidyM;
+  double dP = double(ploidy);
+  const arma::field<arma::Cube<unsigned char> >& genoF = females.slot(""geno"");
+  const arma::field<arma::Cube<unsigned char> >& genoM = males.slot(""geno"");
+  const arma::ivec& lociPerChr = trait.slot(""lociPerChr"");
+  arma::uvec lociLoc = trait.slot(""lociLoc"");
+  arma::vec a,d,g;
+  a = Rcpp::as<arma::vec>(trait.slot(""addEff""));
+  if(hasD){
+    d = Rcpp::as<arma::vec>(trait.slot(""domEff""));
+  }
+  arma::mat gv(nInd,nChr),gxe;
+  gv.fill(double(trait.slot(""intercept""))/double(nChr));
   if(hasGxe){
+    g = Rcpp::as<arma::vec>(trait.slot(""gxeEff""));
     output.set_size(2);
+    output(0).set_size(nInd);
+    output(1).set_size(nInd);
+    gxe.set_size(nInd,nChr);
+    gxe.fill(double(trait.slot(""gxeInt""))/double(nChr));
   }else{
     output.set_size(1);
+    output(0).set_size(nInd);
   }
-  arma::Mat<unsigned char> geno;
-  geno = getHybridGeno(trait,motherGeno,mother,fatherGeno,father);
-  arma::vec a = trait.slot(""addEff"");
-  double intercept = trait.slot(""intercept"");
-  if(hasD){
-    arma::vec d = trait.slot(""domEff"");
-    output(0) = calcGvAD(geno, a, d, intercept, nThreads);
-  }else{
-    output(0) = calcGvA(geno, a, intercept, nThreads);
+  arma::vec x(ploidy+1); // Genotype dossage
+  for(arma::uword i=0; i<x.n_elem; ++i)
+    x(i) = double(i);
+  arma::vec xa = (x-dP/2.0)*(2.0/dP);
+  arma::vec xd = x%(dP-x)*(2.0/dP)*(2.0/dP);
+  
+#ifdef _OPENMP
+#pragma omp parallel for schedule(static) num_threads(nThreads)
+#endif
+  for(arma::uword i=0; i<nChr; ++i){
+    if(lociPerChr(i)>0){ //Check for QTL
+      arma::uword loc1=0,loc2;
+      loc2 = arma::sum(lociPerChr(arma::span(0,i)))-1;
+      if(i==0){
+        loc1 = 0;
+      }else{
+        loc1 = arma::sum(lociPerChr(arma::span(0,i-1)));
+      }
+      arma::uvec chrLociLoc = lociLoc(arma::span(loc1,loc2))-1;
+      arma::Mat<unsigned char> tmpGenoF, tmpGenoM;
+      tmpGenoF = arma::sum(genoF(i),1);
+      tmpGenoF = tmpGenoF.rows(chrLociLoc).t();
+      tmpGenoM = arma::sum(genoM(i),1);
+      tmpGenoM = tmpGenoM.rows(chrLociLoc).t();
+      arma::vec eff(ploidy+1),gEff(ploidy+1);
+      for(arma::uword j=loc1; j<(loc2+1); ++j){
+        // Calculate genetic values
+        eff = xa*a(j);
+        if(hasD){
+          eff += xd*d(j);
+        }
+        if(hasGxe){
+          gEff = xa*g(j);
+        }
+        for(arma::uword k=0; k<nInd; ++k){
+          gv(k,i) += eff((tmpGenoF(femaleParents(k),j-loc1)+
+            tmpGenoM(maleParents(k),j-loc1))/2);
+          if(hasGxe){
+            gxe(k,i) += gEff((tmpGenoF(femaleParents(k),j-loc1)+
+              tmpGenoM(maleParents(k),j-loc1))/2);
+          }
+        }
+      }
+    }
   }
+  output(0) = sum(gv,1);
   if(hasGxe){
-    arma::vec g = trait.slot(""gxeEff"");
-    double gxeInt = trait.slot(""gxeInt"");
-    output(1) = calcGvA(geno, g, gxeInt, nThreads);
+    output(1) = sum(gxe,1);
   }
   return output;
-}
+}
\ No newline at end of file

---FILE: src/init.c---
@@ -20,7 +20,7 @@ extern SEXP _AlphaSimR_callRRBLUP_SCA(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_callRRBLUP2(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_convToImat(SEXP);
 extern SEXP _AlphaSimR_createDH2(SEXP, SEXP, SEXP, SEXP, SEXP);
-extern SEXP _AlphaSimR_cross(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
+extern SEXP _AlphaSimR_cross(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_gebvGCA(SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_gebvRR(SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_gegvGCA(SEXP, SEXP, SEXP);
@@ -64,7 +64,7 @@ static const R_CallMethodDef CallEntries[] = {
     {""_AlphaSimR_callRRBLUP2"",       (DL_FUNC) &_AlphaSimR_callRRBLUP2,       11},
     {""_AlphaSimR_convToImat"",        (DL_FUNC) &_AlphaSimR_convToImat,         1},
     {""_AlphaSimR_createDH2"",         (DL_FUNC) &_AlphaSimR_createDH2,          5},
-    {""_AlphaSimR_cross"",             (DL_FUNC) &_AlphaSimR_cross,             11},
+    {""_AlphaSimR_cross"",             (DL_FUNC) &_AlphaSimR_cross,             13},
     {""_AlphaSimR_gebvGCA"",           (DL_FUNC) &_AlphaSimR_gebvGCA,            4},
     {""_AlphaSimR_gebvRR"",            (DL_FUNC) &_AlphaSimR_gebvRR,             3},
     {""_AlphaSimR_gegvGCA"",           (DL_FUNC) &_AlphaSimR_gegvGCA,            3},

---FILE: src/meiosis.cpp---
@@ -195,6 +195,8 @@ Rcpp::List cross(
     bool trackRec,
     arma::uword motherPloidy,
     arma::uword fatherPloidy,
+    const arma::vec& motherCentromere,
+    const arma::vec& fatherCentromere,
     double quadProb,
     int nThreads){
   mother -= 1; // R to C++
@@ -216,14 +218,18 @@ Rcpp::List cross(
     arma::vec u(1);
     arma::Mat<int> histMat;
     arma::uvec xm(motherPloidy); // Indicator for mother chromosomes
+    for(arma::uword i=0; i<motherPloidy; ++i)
+      xm(i) = i;
     arma::uvec xf(fatherPloidy); // Indicator for father chromosomes
+    for(arma::uword i=0; i<fatherPloidy; ++i)
+      xf(i) = i;
     arma::uword progenyChr;
     arma::uword segSites = motherGeno(chr).n_rows;
     arma::Cube<unsigned char> tmpGeno(segSites,ploidy,nInd);
     //Loop through individuals
     for(arma::uword ind=0; ind<nInd; ++ind){
       progenyChr=0;
-      xm = sampleInt(motherPloidy,motherPloidy);
+      xm = shuffle(xm);
       //Female gamete
       for(arma::uword x=0; x<motherPloidy; x+=4){
         if((motherPloidy-x)>2){
@@ -235,8 +241,9 @@ Rcpp::List cross(
                        motherGeno(chr).slice(mother(ind)).col(xm(x+1)),
                        femaleMap(chr),histMat,trackRec);
             if(trackRec){
-              histMat.col(0).replace(1,int(xm(x))+1);
-              histMat.col(0).replace(2,int(xm(x+1))+1);
+              histMat.col(0) *= 100; //To avoid conflicts
+              histMat.col(0).replace(100,int(xm(x))+1);
+              histMat.col(0).replace(200,int(xm(x+1))+1);
               hist.addHist(histMat,ind,chr,progenyChr);
             }
             ++progenyChr;
@@ -246,8 +253,9 @@ Rcpp::List cross(
                      motherGeno(chr).slice(mother(ind)).col(xm(x+3)),
                      femaleMap(chr),histMat,trackRec);
             if(trackRec){
-              histMat.col(0).replace(1,int(xm(x+2))+1);
-              histMat.col(0).replace(2,int(xm(x+3))+1);
+              histMat.col(0) *= 100; //To avoid conflicts
+              histMat.col(0).replace(100,int(xm(x+2))+1);
+              histMat.col(0).replace(200,int(xm(x+3))+1);
               hist.addHist(histMat,ind,chr,progenyChr);
             }
             ++progenyChr;
@@ -261,16 +269,17 @@ Rcpp::List cross(
                      motherGeno(chr).slice(mother(ind)).col(xm(x+1)),
                      femaleMap(chr),histMat,trackRec);
           if(trackRec){
-            histMat.col(0).replace(1,int(xm(x))+1);
-            histMat.col(0).replace(2,int(xm(x+1))+1);
+            histMat.col(0) *= 100; //To avoid conflicts
+            histMat.col(0).replace(100,int(xm(x))+1);
+            histMat.col(0).replace(200,int(xm(x+1))+1);
             hist.addHist(histMat,ind,chr,progenyChr);
           }
           ++progenyChr;
         }
       }
       
       //Male gamete
-      xf = sampleInt(fatherPloidy,fatherPloidy);
+      xf = shuffle(xf);
       for(arma::uword x=0; x<fatherPloidy; x+=4){
         if((fatherPloidy-x)>2){
           u.randu();
@@ -281,8 +290,9 @@ Rcpp::List cross(
                        fatherGeno(chr).slice(father(ind)).col(xf(x+1)),
                        maleMap(chr),histMat,trackRec);
             if(trackRec){
-              histMat.col(0).replace(1,int(xf(x))+1);
-              histMat.col(0).replace(2,int(xf(x+1))+1);
+              histMat.col(0) *= 100; //To avoid conflicts
+              histMat.col(0).replace(100,int(xf(x))+1);
+              histMat.col(0).replace(200,int(xf(x+1))+1);
               hist.addHist(histMat,ind,chr,progenyChr);
             }
             ++progenyChr;
@@ -292,8 +302,9 @@ Rcpp::List cross(
                      fatherGeno(chr).slice(father(ind)).col(xf(x+3)),
                      maleMap(chr),histMat,trackRec);
             if(trackRec){
-              histMat.col(0).replace(1,int(xf(x+2))+1);
-              histMat.col(0).replace(2,int(xf(x+3))+1);
+              histMat.col(0) *= 100; //To avoid conflicts
+              histMat.col(0).replace(100,int(xf(x+2))+1);
+              histMat.col(0).replace(200,int(xf(x+3))+1);
               hist.addHist(histMat,ind,chr,progenyChr);
             }
             ++progenyChr;
@@ -307,8 +318,9 @@ Rcpp::List cross(
                      fatherGeno(chr).slice(father(ind)).col(xf(x+1)),
                      maleMap(chr),histMat,trackRec);
           if(trackRec){
-            histMat.col(0).replace(1,int(xf(x))+1);
-            histMat.col(0).replace(2,int(xf(x+1))+1);
+            histMat.col(0) *= 100; //To avoid conflicts
+            histMat.col(0).replace(100,int(xf(x))+1);
+            histMat.col(0).replace(200,int(xf(x+1))+1);
             hist.addHist(histMat,ind,chr,progenyChr);
           }
           ++progenyChr;

---FILE: src/misc.cpp---
@@ -245,4 +245,10 @@ arma::uword samplePoisson(double lambda){
     p *= u(0);
   }while(p>L);
   return k-1;
+}
+
+// n choose k recursive formula
+double choose(double n, double k){ 
+  if(k==0) return 1;
+  return (n*choose(n-1,k-1))/k;
 }
\ No newline at end of file

---FILE: src/misc.h---
@@ -3,5 +3,6 @@
 
 arma::uvec sampleInt(arma::uword n, arma::uword N);
 arma::uword samplePoisson(double lambda);
+double choose(double n, double k);
 
 #endif

---FILE: src/tuneTraits.cpp---
@@ -71,7 +71,7 @@ Rcpp::List tuneTraitAD(arma::Mat<unsigned char>& geno,
   }
 
   // Account for divide by zero
-  alpha.replace(arma::datum::inf,0.0);
+  alpha.elem(find_nonfinite(alpha)).zeros();
   
 #ifdef _OPENMP
 #pragma omp parallel for schedule(static) num_threads(nThreads)"
gaynorr,AlphaSimR,8a4f05a18d1d0d9936a10e253d198721dcc1743b,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-10-29T10:11:51Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-10-29T10:11:51Z,-fixed recombination tracking bug in createDH2s,DESCRIPTION;NEWS;src/meiosis.cpp,False,False,False,False,8,3,11,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
 Version: 0.8.3
-Date: 2018-10-22
+Date: 2018-10-29
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: NEWS---
@@ -1,3 +1,8 @@
+Changes in version 0.8.3
+
+  Bug fixes
+    -fixed recombination tracking bug in createDH2s
+
 Changes in version 0.8.2
 
   Bug fixes

---FILE: src/meiosis.cpp---
@@ -245,7 +245,7 @@ Rcpp::List createDH2(
   arma::field<arma::Cube<unsigned char> > output(nChr);
   RecHist hist;
   if(trackRec){
-    hist.setSize(nInd,nChr,2);
+    hist.setSize(nInd*nDH,nChr,2);
   }
 #ifdef _OPENMP
 #pragma omp parallel for schedule(static) num_threads(nThreads)
@@ -263,7 +263,7 @@ Rcpp::List createDH2(
         for(arma::uword j=0; j<2; ++j){ //ploidy loop
           tmp.slice(i+ind*nDH).col(j) = gamete;
           if(trackRec){
-            hist.addHist(histMat,ind,chr,j);
+            hist.addHist(histMat,i+ind*nDH,chr,j);
           }
         } //End ploidy loop
       } //End nDH loop"
gaynorr,AlphaSimR,e90da8ae5826c348f252db5bed97437d4f646e9b,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-10-15T08:30:24Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-10-15T08:30:24Z,fix to ambiguous overloading of std::sqrt causing compilation error on Solaris,DESCRIPTION;NEWS;R/Class-SimParam.R;R/misc.R;R/phenotypes.R;README.md;src/optimize.cpp,False,True,True,False,24,19,43,"---FILE: DESCRIPTION---
@@ -1,8 +1,8 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 0.8.1
-Date: 2018-10-01
+Version: 0.8.2
+Date: 2018-10-15
 Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
   role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
   person(""Gregor"", ""Gorjanc"", role = ""ctb"", 

---FILE: NEWS---
@@ -1,3 +1,8 @@
+Changes in version 0.8.2
+
+  Bug fixes
+    -fixed ambiguous overloading in optimize.cpp
+
 Changes in version 0.8.1
 
   Bug fixes

---FILE: R/Class-SimParam.R---
@@ -997,7 +997,7 @@ SimParam$set(
 
 sampAddEff = function(qtlLoci,nTraits,corr,gamma,shape){
   addEff = matrix(rnorm(qtlLoci@nLoci*nTraits),
-                  ncol=nTraits)%*%chol(corr)
+                  ncol=nTraits)%*%rotMat(corr)
   if(any(gamma)){
     for(i in which(gamma)){
       x = (pnorm(addEff[,i])-0.5)*2
@@ -1010,7 +1010,7 @@ sampAddEff = function(qtlLoci,nTraits,corr,gamma,shape){
 sampDomEff = function(qtlLoci,nTraits,addEff,corDD,
                       meanDD,varDD){
   domEff = matrix(rnorm(qtlLoci@nLoci*nTraits),
-                  ncol=nTraits)%*%chol(corDD)
+                  ncol=nTraits)%*%rotMat(corDD)
   domEff = sweep(domEff,2,sqrt(varDD),""*"")
   domEff = sweep(domEff,2,meanDD,""+"")
   domEff = abs(addEff)*domEff

---FILE: R/misc.R---
@@ -387,3 +387,11 @@ writePlink = function(pop, baseName, trait = 1L, snpChip = 1L, simParam = NULL,
                 lociLoc    = tmp$lociLoc,
                 file       = paste0(baseName, "".ped""))
 }
+
+#Create rotation matrix for sampling random deviates
+#Uses SVD method for stability
+rotMat = function(X){
+  ans = svd(X)
+  u = t(ans$u)*sqrt(pmax(ans$d,0))
+  return(t(ans$v%*%u))
+}
\ No newline at end of file

---FILE: R/phenotypes.R---
@@ -5,16 +5,8 @@ addError = function(gv,varE,reps=1){
   if(is.matrix(varE)){
     stopifnot(isSymmetric(varE),
               ncol(varE)==nTraits)
-    if(any(diag(varE)==0)){
-      zeros = which(diag(varE)==0)
-      diag(varE)[zeros] = 1
-      error = matrix(rnorm(nInd*nTraits),
-                     ncol=nTraits)%*%chol(varE)
-      error[,zeros] = 0
-    }else{
-      error = matrix(rnorm(nInd*nTraits),
-                     ncol=nTraits)%*%chol(varE)
-    }
+    error = matrix(rnorm(nInd*nTraits),
+                   ncol=nTraits)%*%rotMat(varE)
   }else{
     stopifnot(length(varE)==nTraits)
     error = lapply(varE,function(x){

---FILE: README.md---
@@ -1,9 +1,9 @@
 # README #
 
-This package is currently under development and will soon be released on CRAN.
+This package is currently under development. A manuscript detailing its use and the theory behind its operation is in preparation. 
 
-You can install this package in R by using the 'devtools' library and the following command:
+'AlphaSimR' is available on both CRAN and Bitbucket. The most recent version will be on Bitbucket and it can be downloaded and installed using the 'devtools' library and the following command:
 devtools::install_bitbucket(""hickeyjohnteam/AlphaSimR"")
 
-The 'R6', 'Rcpp', 'RcppArmadillo', and 'BH' libraries are required to install this package.
+Installing from Bitbucket requires the following libraries: 'R6', 'Rcpp', 'RcppArmadillo', and 'BH'.
 

---FILE: src/optimize.cpp---
@@ -19,11 +19,11 @@ List optimize(List (*objective)(double, List), List args, double l,
               double u, int maxIter=1000, bool maximize=false, 
               bool evalU=false, bool evalL=false, double eps=1.0e-9){
   double MACHEPS_SQRT = sqrt(2.2204460492503131e-016);
-  double c = (3-sqrt(5))/2;
+  double c = (3.0-std::sqrt(double(5.0)))/2.0;
   double x = l+c*(u-l);
   double v = x;
   double w = x;
-  double e = 0;
+  double e = 0.0;
   double lInt = l;
   double uInt = u;
   List fOut = objective(x, args);"
gaynorr,AlphaSimR,8acf00fbc8d6288c81b5076c7228c583fd5407ad,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-10-01T15:07:04Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-10-01T15:07:04Z,"Resubmitting to CRAN
Added references to the description
Added lots more examples
Squashed a few bugs",DESCRIPTION;NAMESPACE;NEWS;R/Class-Pop.R;R/Class-SimParam.R;R/GS.R;R/RcppExports.R;R/crossing.R;R/founderPop.R;R/hybrids.R;R/mergePops.R;R/misc.R;R/phenotypes.R;R/popSummary.R;R/pullGeno.R;R/selection.R;man/RRBLUP.Rd;man/RRBLUP2.Rd;man/RRBLUPMemUse.Rd;man/RRBLUP_D.Rd;man/RRBLUP_GCA.Rd;man/RRBLUP_SCA.Rd;man/SimParam_addSnpChip.Rd;man/SimParam_addTraitA.Rd;man/SimParam_addTraitAD.Rd;man/SimParam_addTraitADG.Rd;man/SimParam_addTraitAG.Rd;man/SimParam_new.Rd;man/SimParam_removeSnpChip.Rd;man/SimParam_removeTrait.Rd;man/SimParam_rescaleTraits.Rd;man/SimParam_resetPed.Rd;man/SimParam_restrQtlSites.Rd;man/SimParam_restrSegSites.Rd;man/SimParam_restrSnpSites.Rd;man/SimParam_setCorE.Rd;man/SimParam_setGender.Rd;man/SimParam_setRecRatio.Rd;man/SimParam_setTrackPed.Rd;man/SimParam_setTrackRec.Rd;man/SimParam_setVarE.Rd;man/bv.Rd;man/calcGCA.Rd;man/dd.Rd;man/ebv.Rd;man/editGenome.Rd;man/editGenomeTopQtl.Rd;man/genParam.Rd;man/genicVarA.Rd;man/genicVarD.Rd;man/genicVarG.Rd;man/gv.Rd;man/hybridCross.Rd;man/makeCross.Rd;man/makeCross2.Rd;man/makeDH.Rd;man/meanG.Rd;man/meanP.Rd;man/mergePops.Rd;man/nInd.Rd;man/newPop.Rd;man/pedigreeCross.Rd;man/pheno.Rd;man/pullQtlGeno.Rd;man/pullQtlHaplo.Rd;man/pullSegSiteGeno.Rd;man/pullSegSiteHaplo.Rd;man/pullSnpGeno.Rd;man/pullSnpHaplo.Rd;man/quickHaplo.Rd;man/randCross.Rd;man/randCross2.Rd;man/resetPop.Rd;man/selIndex.Rd;man/selInt.Rd;man/selectCross.Rd;man/selectFam.Rd;man/selectInd.Rd;man/selectOP.Rd;man/selectWithinFam.Rd;man/self.Rd;man/setEBV.Rd;man/setPheno.Rd;man/setPhenoGCA.Rd;man/smithHazel.Rd;man/usefulness.Rd;man/varA.Rd;man/varD.Rd;man/varG.Rd;man/varP.Rd;src/RcppExports.cpp,False,True,True,False,2230,290,2520,"---FILE: DESCRIPTION---
@@ -2,11 +2,31 @@ Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
 Version: 0.8.1
-Date: 2018-9-25
-Authors@R: c(person(""Chris"",""Gaynor"",email=""gaynor.robert@hotmail.com"",role=c(""aut"",""cre""),comment = c(ORCID = ""0000-0003-0558-6656"")),person(""Gregor"",""Gorjanc"",role=""aut""),person(""David"",""Wilson"",role=""ctb""),person(""Daniel"",""Money"",role=""ctb""),person(""John"",""Hickey"",role=""ctb""))
-Description: Performs stochastic simulations of plant and animal breeding programs. The stochastic simulations model each individual in a breeding program down to the sequence level. The package contains a wide range of functions for modeling many common tasks performing in breeding programs, such as selection and crossing. 
+Date: 2018-10-01
+Authors@R: c(person(""Chris"", ""Gaynor"", email = ""gaynor.robert@hotmail.com"",
+  role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0003-0558-6656"")),
+  person(""Gregor"", ""Gorjanc"", role = ""ctb"", 
+  comment = c(ORCID = ""0000-0001-8008-2787"")),
+  person(""David"", ""Wilson"", role = ""ctb""),
+  person(""Daniel"", ""Money"", role = ""ctb""),
+  person(""John"", ""Hickey"", role = ""ctb"", 
+  comment = c(ORCID = ""0000-0001-5675-3974"")))
+Description: This package is the successor to the AlphaSim software for breeding 
+  program simulation (Faux et al., 2016, <doi:10.3835/plantgenome2016.02.0013>). 
+  It uses stochastic simulation to model every individual in a breeding program 
+  down to their sequence level. Contained within the package is a wide range of 
+  functions for modeling common tasks in a breeding program, such as selection 
+  and crossing. These functions are used to construction simulations of highly 
+  complex plant and animal breeding programs via scripting in the R software 
+  environment. Such simulations can be used to evaluate overall breeding program 
+  performance and conduct research into areas such as implementation of genomic 
+  selection in a breeding program. Included in the package is the Markovian 
+  Coalescent Simulator (MaCS) for fast simulation of biallelic sequences 
+  according to a population demographic history 
+  (Chen et al., 2009, <doi:10.1101/gr.083634.108>).
 License: MIT + file LICENSE
-URL: https://bitbucket.org/hickeyjohnteam/alphasimr
+URL: https://alphagenes.roslin.ed.ac.uk/wp/software/alphasimr/, 
+  https://bitbucket.org/hickeyjohnteam/alphasimr
 Encoding: UTF-8
 LazyData: true
 Depends: R (>= 3.3.0), methods, R6

---FILE: NAMESPACE---
@@ -40,6 +40,7 @@ export(pullSegSiteGeno)
 export(pullSegSiteHaplo)
 export(pullSnpGeno)
 export(pullSnpHaplo)
+export(quickHaplo)
 export(randCross)
 export(randCross2)
 export(resetPop)

---FILE: NEWS---
@@ -1,7 +1,13 @@
 Changes in version 0.8.1
 
   Bug fixes
-    -setPheno now passes the number of reps to populations
+    -setPheno (not setPhenoGCA) passes the number of reps to populations
+    -fixed bug in editGenomeTopQtl
+    -fixed bug in RRBLUP_D
+    -fixed bug in resetPop
+    -fixed bug in SimParam_rescaleTraits
+    -removed unimplemented SimParam_restrSnpSites and SimParam_restrQtlSites
+    -add error message for no traits in calcGCA
 
 Changes in version 0.8.0
 

---FILE: R/Class-Pop.R---
@@ -343,6 +343,17 @@ setMethod(""c"",
 #'
 #' @return Returns an object of \code{\link{Pop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
 #' @export
 newPop = function(rawPop,mother=NULL,father=NULL,origM=NULL,
                   origF=NULL,isDH=FALSE,simParam=NULL){
@@ -430,6 +441,21 @@ newPop = function(rawPop,mother=NULL,father=NULL,origM=NULL,
 #'
 #' @return an object of \code{\link{Pop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Rescale to set mean to 1
+#' SP$rescaleTraits(pop,mean=1)
+#' pop = resetPop(pop, simParam=SP)
+#' 
 #' @export
 resetPop = function(pop,simParam=NULL){
   if(is.null(simParam)){
@@ -449,7 +475,7 @@ resetPop = function(pop,simParam=NULL){
   pop@reps = rep(1,pop@nInd) 
   if(simParam$nTraits>=1){
     for(i in 1:simParam$nTraits){
-      tmp = getGv(simParam$traits[[i]],pop)
+      tmp = getGv(simParam$traits[[i]],pop,simParam$nThreads)
       pop@gv[,i] = tmp[[1]]
       if(length(tmp)>1){
         pop@gxe[[i]] = tmp[[2]]

---FILE: R/Class-SimParam.R---
@@ -259,6 +259,13 @@ SimParam = R6Class(
 #' 
 #' @param founderPop an object of \code{\link{MapPop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' 
 #' @name SimParam_new
 NULL
 # new ----
@@ -353,6 +360,14 @@ SimParam$set(
 #' @param force should the check for a running simulation be 
 #' ignored. Only set to TRUE if you know what you are doing.
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$setTrackPed(TRUE)
+#' 
 #' @name SimParam_setTrackPed
 NULL
 # setTrackPed ----
@@ -387,6 +402,14 @@ SimParam$set(
 #' @param force should the check for a running simulation be 
 #' ignored. Only set to TRUE if you know what you are doing.
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$setTrackRec(TRUE)
+#' 
 #' @name SimParam_setTrackRec
 NULL
 # setTrackRec ----
@@ -418,6 +441,22 @@ SimParam$set(
 #' 
 #' @section Usage: SP$resetPed(lastId = 0L)
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' pop@id # 1:10
+#' 
+#' #Create another population after reseting pedigree
+#' SP$resetPed()
+#' pop2 = newPop(founderPop, simParam=SP)
+#' pop2@id # 1:10
+#' 
 #' @name SimParam_resetPed
 NULL
 # resetPed ----
@@ -454,6 +493,14 @@ SimParam$set(
 #' @param force should the check for a running simulation be 
 #' ignored. Only set to TRUE if you know what you are doing.
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$restrSegSites(maxQtl=5, maxSnp=5)
+#' 
 #' @name SimParam_restrSegSites
 NULL
 # restrSegSites ----
@@ -518,66 +565,6 @@ SimParam$set(
   }
 )
 
-#' @title Restrict SNP sites
-#'
-#' @description Sets restrictions on which segregating sites 
-#' can serve as SNPs.
-#' 
-#' @section Usage: SP$restrSnpSites(chr=NULL, site=NULL, force = FALSE)
-#' 
-#' @param chr a vector of chromosome postions for eligible 
-#' SNPs
-#' @param site a vector of eligible segregating sites within 
-#' chromosomes
-#' @param force should the check for a running simulation be 
-#' ignored. Only set to TRUE if you know what you are doing.
-#' 
-#' @name SimParam_restrSnpSites
-NULL
-# restrSnpSites ----
-SimParam$set(
-  ""public"",
-  ""restrSnpSites"",
-  function(chr=NULL, site=NULL, force=FALSE){
-    if(!force){
-      private$.isRunning()
-    }
-    #DO SOMETHING
-    private$.potSnp
-    invisible(self)
-  }
-)
-
-#' @title Restrict QTL sites
-#'
-#' @description Sets restrictions on which segregating sites 
-#' can serve as QTL.
-#' 
-#' @section Usage: SP$restrQtlSites(chr = NULL, site = NULL, force = FALSE)
-#' 
-#' @param chr a vector of chromosome postions for eligible 
-#' QTL
-#' @param site a vector of eligible segregating sites within 
-#' chromosomes
-#' @param force should the check for a running simulation be 
-#' ignored. Only set to TRUE if you know what you are doing.
-#' 
-#' @name SimParam_restrQtlSites
-NULL
-# restrQtlSites ----
-SimParam$set(
-  ""public"",
-  ""restrQtlSites"",
-  function(chr=NULL, site=NULL, force=FALSE){
-    if(!force){
-      private$.isRunning()
-    }
-    #DO SOMETHING
-    private$.potQtl
-    invisible(self)
-  }
-)
-
 #' @title Set gender in simulation
 #'
 #' @description Changes how gender is used in the simulation. 
@@ -596,6 +583,14 @@ SimParam$set(
 #' @param force should the check for a running simulation be 
 #' ignored. Only set to TRUE if you know what you are doing.
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$setGender(""yes_sys"")
+#' 
 #' @name SimParam_setGender
 NULL
 # setGender ----
@@ -636,6 +631,14 @@ SimParam$set(
 #' @param force should the check for a running simulation be 
 #' ignored. Only set to TRUE if you know what you are doing.
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$setRecRatio(2) #Twice as much recombination in females
+#' 
 #' @name SimParam_setRecRatio
 NULL
 # setRecRatio ----
@@ -678,6 +681,15 @@ SimParam$set(
 #' @param H2 a vector of desired broad-sense heritabilities
 #' @param varE a vector of error variances
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$setVarE(h2=0.5)
+#' 
 #' @name SimParam_setVarE
 NULL
 # setVarE ----
@@ -726,6 +738,17 @@ SimParam$set(
 #' 
 #' @param corE a correlation matrix for the error variances
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10, mean=c(0,0), var=c(1,1), corA=diag(2))
+#' SP$setVarE(varE=c(1,1))
+#' E = 0.5*diag(2)+0.5 #Positively correlated error
+#' SP$setCorE(E)
+#' 
 #' @name SimParam_setCorE
 NULL
 # setCorE ----
@@ -758,6 +781,14 @@ SimParam$set(
 #' @param force should the check for a running simulation be 
 #' ignored. Only set to TRUE if you know what you are doing.
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addSnpChip(10)
+#' 
 #' @name SimParam_addSnpChip
 NULL
 # addSnpChip ----
@@ -854,6 +885,17 @@ SimParam$set(
 #' @param force should the check for a running simulation be 
 #' ignored. Only set to TRUE if you know what you are doing.
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addSnpChip(10)
+#' SP$nSnpChips
+#' SP$removeSnpChip(1)
+#' SP$nSnpChips
+#' 
 #' @name SimParam_removeSnpChip
 NULL
 # removeSnpChip ----
@@ -994,6 +1036,14 @@ sampDomEff = function(qtlLoci,nTraits,addEff,corDD,
 #' @param force should the check for a running simulation be 
 #' ignored. Only set to TRUE if you know what you are doing.
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' 
 #' @name SimParam_addTraitA
 NULL
 # addTraitA ----
@@ -1055,6 +1105,14 @@ SimParam$set(
 #' @param force should the check for a running simulation be 
 #' ignored. Only set to TRUE if you know what you are doing.
 #'  
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitAD(10, meanDD=0.5)
+#' 
 #' @name SimParam_addTraitAD
 NULL
 # addTraitAD ----
@@ -1120,6 +1178,14 @@ SimParam$set(
 #' @param gamma should a gamma distribution be used instead of normal
 #' @param shape the shape parameter for the gamma distribution
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitAG(10, varGxE=2)
+#' 
 #' @name SimParam_addTraitAG
 NULL
 # addTraitAG ----
@@ -1207,6 +1273,14 @@ SimParam$set(
 #' @param force should the check for a running simulation be 
 #' ignored. Only set to TRUE if you know what you are doing.
 #'  
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitADG(10, meanDD=0.5, varGxE=2)
+#' 
 #' @name SimParam_addTraitADG
 NULL
 # addTraitADG ----
@@ -1291,6 +1365,18 @@ SimParam$set(
 #' @param force should the check for a running simulation be 
 #' ignored. Only set to TRUE if you know what you are doing.
 #'  
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$nTraits
+#' SP$removeTrait(1)
+#' SP$nTraits
+#' 
+#' 
 #' @name SimParam_removeTrait
 NULL
 # removeTrait ----
@@ -1412,6 +1498,24 @@ SimParam$set(
 #' You must run \code{\link{resetPop}} on existing 
 #' populations to obtain the new trait values.
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' meanG(pop)
+#' 
+#' #Change mean to 1
+#' SP$rescaleTraits(pop, mean=1)
+#' #Run resetPop for chage to take effect
+#' pop = resetPop(pop, simParam=SP) 
+#' meanG(pop)
+#' 
 #' @name SimParam_rescaleTraits
 NULL
 # rescaleTraits ----
@@ -1439,22 +1543,24 @@ SimParam$set(
                       trait@lociPerChr,
                       trait@lociLoc)
       if(class(trait)%in%c(""TraitAD"",""TraitADG"")){
-        tmp = tuneTraitAD(geno,trait@addEff,trait@domEff,var[i],useVarA)
+        tmp = tuneTraitAD(geno,trait@addEff,trait@domEff,var[i],
+                          useVarA,self$nThreads)
         trait@domEff = trait@domEff*tmp$scale
       }else{
-        tmp = tuneTraitA(geno,trait@addEff,var[i])
+        tmp = tuneTraitA(geno,trait@addEff,var[i],self$nThreads)
       }
       trait@addEff = trait@addEff*tmp$scale
       trait@intercept = mean[i]-tmp$intercept
       if(class(trait)%in%c(""TraitAG"",""TraitADG"")){
         if(varEnv[i]==0){
-          tmpG = tuneTraitA(geno,trait@gxeEff,varGxE[i])
+          tmpG = tuneTraitA(geno,trait@gxeEff,varGxE[i],
+                            self$nThreads)
           trait@gxeEff = trait@gxeEff*tmpG$scale
           trait@gxeInt = 0-tmpG$intercept
           trait@envVar = 1
         }else{
-          tmpG = tuneTraitA(geno,trait@gxeEff,
-                            varGxE[i]/varEnv[i])
+          tmpG = tuneTraitA(geno,trait@gxeEff,varGxE[i]/varEnv[i],
+                            self$nThreads)
           trait@gxeEff = trait@gxeEff*tmpG$scale
           trait@gxeInt = 1-tmpG$intercept
           trait@envVar = varEnv[i]

---FILE: R/GS.R---
@@ -19,6 +19,26 @@
 #' @param ... additional arguments if using a function for 
 #' traits
 #'
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$setVarE(h2=0.5)
+#' SP$addSnpChip(10)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Run GS model and set EBV
+#' ans = RRBLUP(pop, simParam=SP)
+#' pop = setEBV(pop, ans, simParam=SP)
+#' 
+#' #Evaluate accuracy
+#' cor(gv(pop), ebv(pop))
+#' 
 #' @export
 RRBLUP = function(pop, traits=1, use=""pheno"", snpChip=1, 
                   useQtl=FALSE, maxIter=1000L, simParam=NULL, ...){
@@ -123,6 +143,26 @@ RRBLUP = function(pop, traits=1, use=""pheno"", snpChip=1,
 #' future runs with the RRBLUP2 functions. Again, we can make no claim to the general robustness 
 #' of this approach.
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$setVarE(h2=0.5)
+#' SP$addSnpChip(10)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Run GS model and set EBV
+#' ans = RRBLUP2(pop, simParam=SP)
+#' pop = setEBV(pop, ans, simParam=SP)
+#' 
+#' #Evaluate accuracy
+#' cor(gv(pop), ebv(pop))
+#' 
 #' @export
 RRBLUP2 = function(pop, traits=1, use=""pheno"", snpChip=1, 
                    useQtl=FALSE, maxIter=10, Vu=NULL, Ve=NULL, 
@@ -209,6 +249,26 @@ RRBLUP2 = function(pop, traits=1, use=""pheno"", snpChip=1,
 #' @param ... additional arguments if using a function for 
 #' traits
 #'
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitAD(10, meanDD=0.5)
+#' SP$setVarE(h2=0.5)
+#' SP$addSnpChip(10)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Run GS model and set EBV
+#' ans = RRBLUP_D(pop, simParam=SP)
+#' pop = setEBV(pop, ans, simParam=SP)
+#' 
+#' #Evaluate accuracy
+#' cor(gv(pop), ebv(pop))
+#' 
 #' @export
 RRBLUP_D = function(pop, traits=1, use=""pheno"", snpChip=1, 
                     useQtl=FALSE, maxIter=40L, simParam=NULL, 
@@ -232,9 +292,9 @@ RRBLUP_D = function(pop, traits=1, use=""pheno"", snpChip=1,
   stopifnot(ncol(y)==1)
   ans = callRRBLUP_D(y,fixEff,pop@reps,pop@geno,lociPerChr,
                      lociLoc,maxIter)
-  p = t(ans$p)
+  p = c(ans$p)
   q = 1-p
-  fixCoef = ans$F
+  fixCoef = c(ans$F)
   fixed = ((p<0.000000001) | (p>0.999999999)) #Fixed markers
   nMarker = nLoci-sum(fixed) #Number of segregating markers
   ans = ans$ans
@@ -285,6 +345,26 @@ RRBLUP_D = function(pop, traits=1, use=""pheno"", snpChip=1,
 #' @param ... additional arguments if using a function for 
 #' traits
 #'
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$setVarE(h2=0.5)
+#' SP$addSnpChip(10)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Run GS model and set EBV
+#' ans = RRBLUP_GCA(pop, simParam=SP)
+#' pop = setEBV(pop, ans, simParam=SP)
+#' 
+#' #Evaluate accuracy
+#' cor(gv(pop), ebv(pop))
+#' 
 #' @export
 RRBLUP_GCA = function(pop, traits=1, use=""pheno"", snpChip=1, 
                       useQtl=FALSE, maxIter=40L, simParam=NULL, 
@@ -344,6 +424,26 @@ RRBLUP_GCA = function(pop, traits=1, use=""pheno"", snpChip=1,
 #' @param ... additional arguments if using a function for 
 #' traits
 #'
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$setVarE(h2=0.5)
+#' SP$addSnpChip(10)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Run GS model and set EBV
+#' ans = RRBLUP_SCA(pop, simParam=SP)
+#' pop = setEBV(pop, ans, simParam=SP)
+#' 
+#' #Evaluate accuracy
+#' cor(gv(pop), ebv(pop))
+#' 
 #' @export
 RRBLUP_SCA = function(pop, traits=1, use=""pheno"", snpChip=1, 
                       useQtl=FALSE, maxIter=40L, simParam=NULL, ...){
@@ -405,6 +505,26 @@ RRBLUP_SCA = function(pop, traits=1, use=""pheno"", snpChip=1,
 #'
 #' @return Returns an object of \code{\link{Pop-class}}
 #'
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$setVarE(h2=0.5)
+#' SP$addSnpChip(10)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Run GS model and set EBV
+#' ans = RRBLUP(pop, simParam=SP)
+#' pop = setEBV(pop, ans, simParam=SP)
+#' 
+#' #Evaluate accuracy
+#' cor(gv(pop), ebv(pop))
+#' 
 #' @export
 setEBV = function(pop, solution, gender=NULL, useGV=FALSE, 
                   append=FALSE, simParam=NULL){
@@ -456,6 +576,9 @@ setEBV = function(pop, solution, gender=NULL, useGV=FALSE,
 #'
 #' @return Returns an estimate for the required gigabytes of RAM
 #'
+#' @examples 
+#' RRBLUPMemUse(nInd=1000, nMarker=5000)
+#' 
 #' @export
 RRBLUPMemUse = function(nInd,nMarker,model=""REG""){
   y = nInd

---FILE: R/RcppExports.R---
@@ -1,6 +1,14 @@
 # Generated by using Rcpp::compileAttributes() -> do not edit by hand
 # Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393
 
+writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call(`_AlphaSimR_writeASGenotypes`, g, locations, allLocations, snpchips, names, missing, fname))
+}
+
+writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call(`_AlphaSimR_writeASHaplotypes`, g, locations, allLocations, snpchips, names, missing, fname))
+}
+
 gebvRR <- function(RRsol, pop, nThreads) {
     .Call(`_AlphaSimR_gebvRR`, RRsol, pop, nThreads)
 }
@@ -21,38 +29,6 @@ gegvSCA <- function(sol, pop, nThreads) {
     .Call(`_AlphaSimR_gegvSCA`, sol, pop, nThreads)
 }
 
-callRRBLUP <- function(y, x, reps, geno, lociPerChr, lociLoc) {
-    .Call(`_AlphaSimR_callRRBLUP`, y, x, reps, geno, lociPerChr, lociLoc)
-}
-
-callRRBLUP2 <- function(y, x, reps, geno, lociPerChr, lociLoc, Vu, Ve, tol, maxIter, useEM) {
-    .Call(`_AlphaSimR_callRRBLUP2`, y, x, reps, geno, lociPerChr, lociLoc, Vu, Ve, tol, maxIter, useEM)
-}
-
-callRRBLUP_D <- function(y, x, reps, geno, lociPerChr, lociLoc, maxIter) {
-    .Call(`_AlphaSimR_callRRBLUP_D`, y, x, reps, geno, lociPerChr, lociLoc, maxIter)
-}
-
-callRRBLUP_MV <- function(Y, x, reps, geno, lociPerChr, lociLoc, maxIter) {
-    .Call(`_AlphaSimR_callRRBLUP_MV`, Y, x, reps, geno, lociPerChr, lociLoc, maxIter)
-}
-
-callRRBLUP_GCA <- function(y, x, reps, geno, lociPerChr, lociLoc, maxIter) {
-    .Call(`_AlphaSimR_callRRBLUP_GCA`, y, x, reps, geno, lociPerChr, lociLoc, maxIter)
-}
-
-callRRBLUP_SCA <- function(y, x, reps, geno, lociPerChr, lociLoc, maxIter) {
-    .Call(`_AlphaSimR_callRRBLUP_SCA`, y, x, reps, geno, lociPerChr, lociLoc, maxIter)
-}
-
-writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call(`_AlphaSimR_writeASGenotypes`, g, locations, allLocations, snpchips, names, missing, fname))
-}
-
-writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call(`_AlphaSimR_writeASHaplotypes`, g, locations, allLocations, snpchips, names, missing, fname))
-}
-
 getGeno <- function(geno, lociPerChr, lociLoc) {
     .Call(`_AlphaSimR_getGeno`, geno, lociPerChr, lociLoc)
 }
@@ -158,6 +134,30 @@ calcCoef <- function(X, Y) {
     .Call(`_AlphaSimR_calcCoef`, X, Y)
 }
 
+callRRBLUP <- function(y, x, reps, geno, lociPerChr, lociLoc) {
+    .Call(`_AlphaSimR_callRRBLUP`, y, x, reps, geno, lociPerChr, lociLoc)
+}
+
+callRRBLUP2 <- function(y, x, reps, geno, lociPerChr, lociLoc, Vu, Ve, tol, maxIter, useEM) {
+    .Call(`_AlphaSimR_callRRBLUP2`, y, x, reps, geno, lociPerChr, lociLoc, Vu, Ve, tol, maxIter, useEM)
+}
+
+callRRBLUP_D <- function(y, x, reps, geno, lociPerChr, lociLoc, maxIter) {
+    .Call(`_AlphaSimR_callRRBLUP_D`, y, x, reps, geno, lociPerChr, lociLoc, maxIter)
+}
+
+callRRBLUP_MV <- function(Y, x, reps, geno, lociPerChr, lociLoc, maxIter) {
+    .Call(`_AlphaSimR_callRRBLUP_MV`, Y, x, reps, geno, lociPerChr, lociLoc, maxIter)
+}
+
+callRRBLUP_GCA <- function(y, x, reps, geno, lociPerChr, lociLoc, maxIter) {
+    .Call(`_AlphaSimR_callRRBLUP_GCA`, y, x, reps, geno, lociPerChr, lociLoc, maxIter)
+}
+
+callRRBLUP_SCA <- function(y, x, reps, geno, lociPerChr, lociLoc, maxIter) {
+    .Call(`_AlphaSimR_callRRBLUP_SCA`, y, x, reps, geno, lociPerChr, lociLoc, maxIter)
+}
+
 packHaplo <- function(haplo, ploidy, inbred) {
     .Call(`_AlphaSimR_packHaplo`, haplo, ploidy, inbred)
 }

---FILE: R/crossing.R---
@@ -11,6 +11,20 @@
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
 #' @return Returns an object of \code{\link{Pop-class}}
+#' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Cross individual 1 with individual 10
+#' crossPlan = matrix(c(1,10), nrow=1, ncol=2)
+#' pop2 = makeCross(pop, crossPlan, simParam=SP)
 #'
 #' @export
 makeCross = function(pop,crossPlan,simParam=NULL){
@@ -65,6 +79,19 @@ makeCross = function(pop,crossPlan,simParam=NULL){
 #' 
 #' @return Returns an object of \code{\link{Pop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Make 10 crosses
+#' pop2 = randCross(pop, 10, simParam=SP)
+#' 
 #' @export
 randCross = function(pop,nCrosses,nProgeny=1,
                      balance=TRUE,parents=NULL,
@@ -156,6 +183,21 @@ randCross = function(pop,nCrosses,nProgeny=1,
 #' 
 #' @return Returns an object of \code{\link{Pop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Select 4 individuals and make 8 crosses
+#' pop2 = selectCross(pop, nInd=4, nCrosses=8, simParam=SP)
+#' 
 #' @export
 selectCross = function(pop,nInd=NULL,nFemale=NULL,nMale=NULL,nCrosses,
                        nProgeny=1,trait=1,use=""pheno"",selectTop=TRUE,
@@ -203,6 +245,20 @@ selectCross = function(pop,nInd=NULL,nFemale=NULL,nMale=NULL,nCrosses,
 #' 
 #' @return Returns an object of \code{\link{Pop-class}}
 #'
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Cross individual 1 with individual 10
+#' crossPlan = matrix(c(1,10), nrow=1, ncol=2)
+#' pop2 = makeCross2(pop, pop, crossPlan, simParam=SP)
+#' 
 #' @export
 makeCross2 = function(females,males,crossPlan,simParam=NULL){
   if(is.null(simParam)){
@@ -261,6 +317,19 @@ makeCross2 = function(females,males,crossPlan,simParam=NULL){
 #' 
 #' @return Returns an object of \code{\link{Pop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Make 10 crosses
+#' pop2 = randCross2(pop, pop, 10, simParam=SP)
+#' 
 #' @export
 randCross2 = function(females,males,nCrosses,nProgeny=1,
                       balance=TRUE,femaleParents=NULL,
@@ -333,6 +402,19 @@ randCross2 = function(females,males,nCrosses,nProgeny=1,
 #' 
 #' @return Returns an object of \code{\link{Pop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Self pollinate each individual
+#' pop2 = self(pop, simParam=SP)
+#' 
 #' @export
 self = function(pop,nProgeny=1,parents=NULL,simParam=NULL){
   if(is.null(simParam)){
@@ -384,6 +466,19 @@ self = function(pop,nProgeny=1,parents=NULL,simParam=NULL){
 #' 
 #' @return Returns an object of \code{\link{Pop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Create 1 DH for each individual
+#' pop2 = makeDH(pop, simParam=SP)
+#' 
 #' @export
 makeDH = function(pop,nDH=1,useFemale=TRUE,simParam=NULL){
   if(is.null(simParam)){
@@ -446,6 +541,22 @@ makeDH = function(pop,nDH=1,useFemale=TRUE,simParam=NULL){
 #' @param simParam an object of 'SimParam' class
 #' 
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Pedigree for a biparental cross with 7 generations of selfing
+#' id = 1:10
+#' mother = c(0,0,1,3:9)
+#' father = c(0,0,2,3:9)
+#' pop2 = pedigreeCross(pop, id, mother, father, simParam=SP)
+#' 
 #' @export
 pedigreeCross = function(founderPop,id,mother,father, 
                          maxCycle=100,DH=NULL,useFemale=TRUE,

---FILE: R/founderPop.R---
@@ -388,3 +388,41 @@ sampleHaplo = function(mapPop,nInd,inbred=FALSE,replace=TRUE){
   output = do.call(""c"",output)
   return(output)
 }
+
+#' @title Quick founder haplotype simulation
+#'
+#' @description Rapidly simulates founder haplotypes by randomly 
+#' sampling 0s and 1s. This is equivalent to having all loci with 
+#' allele frequency 0.5 and being in linkage equilibrium.
+#' 
+#' @param nInd number of individuals to simulate
+#' @param nChr number of chromosomes to simulate
+#' @param segSites number of segregating sites per chromosome
+#' @param genLen genetic length of chromosomes
+#' @param inbred should founder individuals be inbred
+#'
+#' @return an object of \code{\link{MapPop-class}}
+#' 
+#' @examples 
+#' # Creates a populations of 10 outbred individuals
+#' # Their genome consists of 1 chromosome and 100 segregating sites
+#' founderPop = quickHaplo(nInd=10,nChr=1,segSites=100)
+#' 
+#' @export
+quickHaplo = function(nInd,nChr,segSites,genLen=1,inbred=FALSE){
+  if(inbred){
+    nHap = nInd
+  }else{
+    nHap = 2*nInd
+  }
+  if(length(segSites)==1) segSites = rep(segSites,nChr)
+  if(length(genLen)==1) genLen = rep(genLen,nChr)
+  genMap = vector(""list"",nChr)
+  haplotypes = vector(""list"",nChr)
+  for(i in 1:nChr){
+    genMap[[i]] = seq(0,genLen[i],length.out=segSites[i])
+    haplotypes[[i]] = matrix(sample(0:1,nHap*segSites[i],replace=TRUE),
+                             nrow=nHap, ncol=segSites[i])
+  }
+  return(newMapPop(genMap,haplotypes,inbred))
+}
\ No newline at end of file

---FILE: R/hybrids.R---
@@ -51,6 +51,19 @@ getHybridGvByChunk = function(trait,females,femaleParents,
 #' more time.
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10, inbred=TRUE)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Make crosses for full diallele
+#' pop2 = hybridCross(pop, pop, simParam=SP)
+#' 
 #' @export
 hybridCross = function(females,males,crossPlan=""testcross"",
                        returnHybridPop=FALSE,chunkSize=10000,
@@ -126,6 +139,21 @@ hybridCross = function(females,males,crossPlan=""testcross"",
 #' \code{\link{HybridPop-class}}
 #' @param use true genetic value ""gv"" or phenotypes ""pheno"" (default)
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10, inbred=TRUE)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Make crosses for full diallele
+#' pop2 = hybridCross(pop, pop, simParam=SP)
+#' GCA = calcGCA(pop2, use=""gv"")
+#' 
 #' @export
 calcGCA = function(pop,use=""pheno""){
   if(use==""pheno""){
@@ -135,6 +163,9 @@ calcGCA = function(pop,use=""pheno""){
   }else{
     stop(paste0(""use="",use,"" is not a valid option""))
   }
+  if(ncol(y)==0){
+    stop(paste(""No values for"",use))
+  }
   female = factor(pop@mother,
                   levels=unique(pop@mother))
   male = factor(pop@father,
@@ -246,6 +277,20 @@ calcGCA = function(pop,use=""pheno""){
 #' @return Returns an object of \code{\link{Pop-class}} or 
 #' a matrix if onlyPheno=TRUE
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10, inbred=TRUE)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Set phenotype to average per
+#' pop2 = setPhenoGCA(pop, pop, use=""gv"", inbred=TRUE, simParam=SP)
+#' 
 #' @export
 setPhenoGCA = function(pop,testers,use=""pheno"",varE=NULL,reps=1,
                        fixEff=1L,p=0.5,inbred=FALSE,chunkSize=10000,
@@ -270,7 +315,9 @@ setPhenoGCA = function(pop,testers,use=""pheno"",varE=NULL,reps=1,
   }else{
     stop(paste0(""use="",use,"" is not a valid option""))
   }
-  #
+  if(ncol(y)==0){
+    stop(paste(""No values for"",use))
+  }
   female = factor(tmp@mother,levels=unique(tmp@mother))
   if(nlevels(female)==1){
     GCAf = matrix(colMeans(y),nrow=1)

---FILE: R/mergePops.R---
@@ -7,6 +7,18 @@
 #' 
 #' @return Returns a \code{\link{Pop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' 
+#' #Create a list of populations and merge list
+#' pop = newPop(founderPop, simParam=SP)
+#' popList = list(pop, pop)
+#' pop2 = mergePops(popList)
+#' 
 #' @export
 mergePops = function(popList){
   classes = do.call(""c"",lapply(popList,

---FILE: R/misc.R---
@@ -5,6 +5,9 @@
 #' 
 #' @param p the proportion of individuals selected
 #' 
+#' @examples 
+#' selInt(0.1)
+#' 
 #' @export
 selInt = function(p){
   return(dnorm(qnorm(1-p))/p)
@@ -22,6 +25,13 @@ selInt = function(p){
 #' 
 #' @return a vector of weight for calculating index values
 #' 
+#' @examples
+#' G = 1.5*diag(2)-0.5
+#' E = diag(2)
+#' P = G+E
+#' wt = c(1,1)
+#' smithHazel(wt, G, P)
+#' 
 #' @export
 smithHazel = function(econWt,varG,varP){
   return(solve(varP)%*%varG%*%econWt)
@@ -39,6 +49,29 @@ smithHazel = function(econWt,varG,varP){
 #' @param b a vector of weights
 #' @param scale should Y be scaled and centered
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' #Model two genetically correlated traits
+#' G = 1.5*diag(2)-0.5 #Genetic correlation matrix
+#' SP$addTraitA(10, mean=c(0,0), var=c(1,1), corA=G)
+#' SP$setVarE(h2=c(0.5,0.5))
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Calculate Smith-Hazel weights
+#' econWt = c(1, 1)
+#' b = smithHazel(econWt, varG(pop), varP(pop))
+#' 
+#' #Selection 2 best individuals using Smith-Hazel index
+#' #selIndex is used as a trait
+#' pop2 = selectInd(pop, nInd=2, trait=selIndex, 
+#'                  simParam=SP, b=b)
+#' 
 #' @export
 selIndex = function(Y,b,scale=FALSE){
   if(scale){
@@ -65,6 +98,22 @@ selIndex = function(Y,b,scale=FALSE){
 #' 
 #' @return Returns an object of \code{\link{Pop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Change individual 1 to homozygous for the 1 allele 
+#' #at locus 1, chromosome 1
+#' pop2 = editGenome(pop, ind=1, chr=1, segSites=1, 
+#'                   allele=1, simParam=SP)
+#' 
 #' @export
 editGenome = function(pop,ind,chr,segSites,allele,
                       simParam=NULL){
@@ -117,6 +166,20 @@ editGenome = function(pop,ind,chr,segSites,allele,
 #' 
 #' @return Returns an object of \code{\link{Pop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Change up to 10 loci for individual 1 
+#' pop2 = editGenomeTopQtl(pop, ind=1, nQtl=10, simParam=SP)
+#'                   
 #' @export
 editGenomeTopQtl = function(pop, ind, nQtl, trait = 1, increase = TRUE, simParam = NULL) {
   if (is.null(simParam)) {
@@ -143,14 +206,22 @@ editGenomeTopQtl = function(pop, ind, nQtl, trait = 1, increase = TRUE, simParam
     QtlGeno = pullQtlGeno(pop=pop[ind],trait=trait,simParam=simParam)
     
     QtlEff = simParam$traits[[trait]]@addEff
-    ret = vector(mode = ""list"", length = 2)
+    ret = vector(mode = ""list"", length = 4)
     ret[[1]] = ret[[2]] = ret[[3]] = ret[[4]] = rep(NA, times = nQtl)
     QtlEffRank = order(abs(QtlEff), decreasing = TRUE)
     nQtlInd = 0
     Qtl = 0
     
     while (nQtlInd < nQtl) {
       Qtl = Qtl + 1
+      if(Qtl>ncol(QtlGeno)){
+        ret[[1]] = ret[[1]][1:nQtlInd]
+        ret[[2]] = ret[[2]][1:nQtlInd]
+        ret[[3]] = ret[[3]][1:nQtlInd]
+        ret[[4]] = ret[[4]][1:nQtlInd]
+        nQtl = nQtlInd
+        break()
+      }
       QtlGenoLoc = QtlGeno[QtlEffRank[Qtl]]
       if (QtlEff[QtlEffRank[Qtl]] > 0) {
         if (QtlGenoLoc < 2) {
@@ -219,6 +290,23 @@ editGenomeTopQtl = function(pop, ind, nQtl, trait = 1, increase = TRUE, simParam
 #' 
 #' @return Returns a numeric value
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Determine usefulness of population 
+#' usefulness(pop, simParam=SP)
+#' 
+#' #Should be equivalent to GV of best individual
+#' max(gv(pop))
+#' 
 #' @export
 usefulness = function(pop,trait=1,use=""gv"",p=0.1,
                       selectTop=TRUE,simParam=NULL,...){

---FILE: R/phenotypes.R---
@@ -86,6 +86,20 @@ calcPheno = function(pop,varE,reps,p,simParam){
 #' \code{\link{HybridPop-class}} if onlyPheno=FALSE, if 
 #' onlyPheno=TRUE a matrix is returned
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Add phenotype with error variance of 1
+#' pop = setPheno(pop, varE=1)
+#' 
 #' @export
 setPheno = function(pop,varE=NULL,reps=1,fixEff=1L,p=0.5,
                     onlyPheno=FALSE,simParam=NULL){

---FILE: R/popSummary.R---
@@ -4,6 +4,19 @@
 #' 
 #' @param pop an object of \code{\link{Pop-class}} or \code{\link{HybridPop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' meanG(pop)
+#' 
 #' @export
 meanG = function(pop){
   colMeans(pop@gv)
@@ -15,6 +28,19 @@ meanG = function(pop){
 #' 
 #' @param pop an object of \code{\link{Pop-class}} or \code{\link{HybridPop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' meanP(pop)
+#' 
 #' @export
 meanP = function(pop){
   colMeans(pop@pheno)
@@ -26,6 +52,19 @@ meanP = function(pop){
 #' 
 #' @param pop an object of \code{\link{Pop-class}} or \code{\link{HybridPop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' varG(pop)
+#' 
 #' @export
 varG = function(pop){
   popVar(pop@gv)
@@ -37,6 +76,19 @@ varG = function(pop){
 #' 
 #' @param pop an object of \code{\link{Pop-class}} or \code{\link{HybridPop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' varP(pop)
+#' 
 #' @export
 varP = function(pop){
   popVar(pop@pheno)
@@ -69,6 +121,19 @@ varP = function(pop){
 #' \item{gv_d}{a matrix of dominance genetic values with dimensions nInd by nTraits}
 #' }
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitAD(10, meanDD=0.5)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' ans = genParam(pop, simParam=SP)
+#' 
 #' @export
 genParam = function(pop,simParam=NULL){
   if(is.null(simParam)){
@@ -124,6 +189,19 @@ genParam = function(pop,simParam=NULL){
 #' @param pop an object of \code{\link{Pop-class}}
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitAD(10, meanDD=0.5)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' varA(pop, simParam=SP)
+#' 
 #' @export
 varA = function(pop,simParam=NULL){
   genParam(pop,simParam=simParam)$varA
@@ -136,6 +214,19 @@ varA = function(pop,simParam=NULL){
 #' @param pop an object of \code{\link{Pop-class}}
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitAD(10, meanDD=0.5)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' varD(pop, simParam=SP)
+#' 
 #' @export
 varD = function(pop,simParam=NULL){
   genParam(pop,simParam=simParam)$varD
@@ -148,6 +239,19 @@ varD = function(pop,simParam=NULL){
 #' @param pop an object of \code{\link{Pop-class}}
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitAD(10, meanDD=0.5)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' bv(pop, simParam=SP)
+#' 
 #' @export
 bv = function(pop,simParam=NULL){
   genParam(pop,simParam=simParam)$bv
@@ -160,6 +264,19 @@ bv = function(pop,simParam=NULL){
 #' @param pop an object of \code{\link{Pop-class}}
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitAD(10, meanDD=0.5)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' dd(pop, simParam=SP)
+#' 
 #' @export
 dd = function(pop,simParam=NULL){
   genParam(pop,simParam=simParam)$dd
@@ -172,6 +289,19 @@ dd = function(pop,simParam=NULL){
 #' @param pop an object of \code{\link{Pop-class}}
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitAD(10, meanDD=0.5)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' genicVarA(pop, simParam=SP)
+#' 
 #' @export
 genicVarA = function(pop,simParam=NULL){
   genParam(pop,simParam=simParam)$genicVarA
@@ -184,6 +314,19 @@ genicVarA = function(pop,simParam=NULL){
 #' @param pop an object of \code{\link{Pop-class}}
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitAD(10, meanDD=0.5)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' genicVarD(pop, simParam=SP)
+#' 
 #' @export
 genicVarD = function(pop,simParam=NULL){
   genParam(pop,simParam=simParam)$genicVarD
@@ -196,6 +339,19 @@ genicVarD = function(pop,simParam=NULL){
 #' @param pop an object of \code{\link{Pop-class}}
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitAD(10, meanDD=0.5)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' genicVarG(pop, simParam=SP)
+#'
 #' @export
 genicVarG = function(pop,simParam=NULL){
   genParam(pop,simParam=simParam)$genicVarG
@@ -207,6 +363,19 @@ genicVarG = function(pop,simParam=NULL){
 #' 
 #' @param pop a \code{\link{Pop-class}} or similar object
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitAD(10, meanDD=0.5)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' gv(pop)
+#' 
 #' @export
 gv = function(pop){
   pop@gv
@@ -218,6 +387,19 @@ gv = function(pop){
 #' 
 #' @param pop a \code{\link{Pop-class}} or similar object
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitAD(10, meanDD=0.5)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' pheno(pop)
+#' 
 #' @export
 pheno = function(pop){
   pop@pheno
@@ -229,6 +411,20 @@ pheno = function(pop){
 #' 
 #' @param pop a \code{\link{Pop-class}} or similar object
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitAD(10, meanDD=0.5)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' pop@ebv = matrix(rnorm(pop@nInd), nrow=pop@nInd, ncol=1)
+#' ebv(pop)
+#' 
 #' @export
 ebv = function(pop){
   pop@ebv
@@ -240,6 +436,19 @@ ebv = function(pop){
 #' 
 #' @param pop a \code{\link{Pop-class}} or similar object
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitAD(10, meanDD=0.5)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' nInd(pop)
+#' 
 #' @export
 nInd = function(pop){
   pop@nInd

---FILE: R/pullGeno.R---
@@ -37,6 +37,20 @@ selectLoci = function(chr,inLociPerChr,inLociLoc){
 #' @param simParam an object of \code{\link{SimParam}}
 #'
 #' @return Returns a matrix of SNP genotypes.
+#' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$addSnpChip(5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' pullSnpGeno(pop, simParam=SP)
+#' 
 #' @export
 pullSnpGeno = function(pop, snpChip=1, chr=NULL, simParam=NULL){
   if(is.null(simParam)){
@@ -65,7 +79,9 @@ pullSnpGeno = function(pop, snpChip=1, chr=NULL, simParam=NULL){
 #' chip to use
 #' @param missing What value to use for missing
 #' @param simParam an object of \code{\link{SimParam}}
+#' 
 #' @return Returns a matrix of SNP genotypes.
+#' 
 #' @export
 pullMultipleSnpGeno = function(pop, chips,
                                missing=9, simParam=NULL) {
@@ -120,6 +136,20 @@ pullMultipleSnpGeno = function(pop, chips,
 #' @param simParam an object of \code{\link{SimParam}}
 #'
 #' @return Returns a matrix of QTL genotypes.
+#' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$addSnpChip(5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' pullQtlGeno(pop, simParam=SP)
+#' 
 #' @export
 pullQtlGeno = function(pop, trait=1, chr=NULL, simParam=NULL){
   if(is.null(simParam)){
@@ -151,6 +181,20 @@ pullQtlGeno = function(pop, trait=1, chr=NULL, simParam=NULL){
 #' @param simParam an object of \code{\link{SimParam}}
 #'
 #' @return Returns a matrix of genotypes
+#' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$addSnpChip(5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' pullSegSiteGeno(pop, simParam=SP)
+#' 
 #' @export
 pullSegSiteGeno = function(pop, chr=NULL, simParam=NULL){
   if(class(pop)==""MapPop""){
@@ -190,6 +234,20 @@ pullSegSiteGeno = function(pop, chr=NULL, simParam=NULL){
 #' @param simParam an object of \code{\link{SimParam}}
 #'
 #' @return Returns a matrix of SNP haplotypes.
+#' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$addSnpChip(5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' pullSnpHaplo(pop, simParam=SP)
+#' 
 #' @export
 pullSnpHaplo = function(pop, snpChip=1, haplo=""all"",
                         chr=NULL, simParam=NULL){
@@ -240,6 +298,7 @@ pullSnpHaplo = function(pop, snpChip=1, haplo=""all"",
 #' @param simParam an object of \code{\link{SimParam}}
 #'
 #' @return Returns a matrix of SNP haplotypes.
+#' 
 #' @export
 pullMultipleSnpHaplo = function(pop, chips, haplo=""all"",
                                 missing=9, simParam=NULL){
@@ -322,6 +381,20 @@ pullMultipleSnpHaplo = function(pop, chips, haplo=""all"",
 #' @param simParam an object of \code{\link{SimParam}}
 #'
 #' @return Returns a matrix of QTL haplotypes.
+#' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$addSnpChip(5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' pullQtlHaplo(pop, simParam=SP)
+#' 
 #' @export
 pullQtlHaplo = function(pop, trait=1, haplo=""all"",
                         chr=NULL, simParam=NULL){
@@ -373,6 +446,20 @@ pullQtlHaplo = function(pop, trait=1, haplo=""all"",
 #' @param simParam an object of \code{\link{SimParam}}
 #'
 #' @return Returns a matrix of haplotypes
+#' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$addSnpChip(5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' pullSegSiteHaplo(pop, simParam=SP)
+#' 
 #' @export
 pullSegSiteHaplo = function(pop, haplo=""all"",
                             chr=NULL, simParam=NULL){
@@ -445,6 +532,7 @@ pullSegSiteHaplo = function(pop, haplo=""all"",
 #' @return Returns a matrix of haplotypes with Identity By Descent
 #' (IBD) coding of locus alleles. The matrix colnames reflect whether
 #' all segregagting loci (sites) are retreived or only SNP array loci.
+#' 
 #' @export
 pullIbdHaplo = function(pop = NULL, chr = NULL, snpChip = NULL, pedigree = NULL, simParam = NULL) {
   

---FILE: R/selection.R---
@@ -105,6 +105,21 @@ getFam = function(pop,famType){
 #' @return Returns an object of \code{\link{Pop-class}} or 
 #' \code{\link{HybridPop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Select best 5
+#' pop2 = selectInd(pop, 5, simParam=SP)
+#' 
 #' @export
 selectInd = function(pop,nInd,trait=1,use=""pheno"",gender=""B"",
                      selectTop=TRUE,returnPop=TRUE,
@@ -161,6 +176,24 @@ selectInd = function(pop,nInd,trait=1,use=""pheno"",gender=""B"",
 #' @return Returns an object of \code{\link{Pop-class}} or 
 #' \code{\link{HybridPop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Create 3 biparental families with 10 progeny
+#' pop2 = randCross(pop, nCrosses=3, nProgeny=10, simParam=SP)
+#' 
+#' #Select best 2 families
+#' pop3 = selectFam(pop2, 2, simParam=SP)
+#' 
 #' @export
 selectFam = function(pop,nFam,trait=1,use=""pheno"",gender=""B"",
                      famType=""B"",selectTop=TRUE,returnPop=TRUE,
@@ -228,6 +261,24 @@ selectFam = function(pop,nFam,trait=1,use=""pheno"",gender=""B"",
 #' @return Returns an object of \code{\link{Pop-class}} or 
 #' \code{\link{HybridPop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Create 3 biparental families with 10 progeny
+#' pop2 = randCross(pop, nCrosses=3, nProgeny=10, simParam=SP)
+#' 
+#' #Select best individual per family
+#' pop3 = selectWithinFam(pop2, 1, simParam=SP)
+#' 
 #' @export
 selectWithinFam = function(pop,nInd,trait=1,use=""pheno"",gender=""B"",
                            famType=""B"",selectTop=TRUE,returnPop=TRUE,
@@ -293,6 +344,22 @@ selectWithinFam = function(pop,nInd,trait=1,use=""pheno"",gender=""B"",
 #' 
 #' @return Returns an object of \code{\link{Pop-class}}
 #' 
+#' @examples 
+#' #Create founder haplotypes
+#' founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+#' 
+#' #Set simulation parameters
+#' SP = SimParam$new(founderPop)
+#' SP$addTraitA(10)
+#' SP$setVarE(h2=0.5)
+#' 
+#' #Create population
+#' pop = newPop(founderPop, simParam=SP)
+#' 
+#' #Create new population by selecting the best 3 plant
+#' #Assuming 50% selfing in plants and 10 seeds per plant
+#' pop2 = selectOP(pop, nInd=3, nSeeds=10, probSelf=0.5, simParam=SP)
+#' 
 #' @export
 selectOP = function(pop,nInd,nSeeds,probSelf=0,
                     pollenControl=FALSE,trait=1,

---FILE: man/RRBLUP.Rd---
@@ -34,3 +34,24 @@ traits}
 \description{
 Fits an RR-BLUP model for genomic predictions.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$setVarE(h2=0.5)
+SP$addSnpChip(10)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Run GS model and set EBV
+ans = RRBLUP(pop, simParam=SP)
+pop = setEBV(pop, ans, simParam=SP)
+
+#Evaluate accuracy
+cor(gv(pop), ebv(pop))
+
+}

---FILE: man/RRBLUP2.Rd---
@@ -77,3 +77,24 @@ time the model is trained, and then use the variance components from this output
 future runs with the RRBLUP2 functions. Again, we can make no claim to the general robustness 
 of this approach.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$setVarE(h2=0.5)
+SP$addSnpChip(10)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Run GS model and set EBV
+ans = RRBLUP2(pop, simParam=SP)
+pop = setEBV(pop, ans, simParam=SP)
+
+#Evaluate accuracy
+cor(gv(pop), ebv(pop))
+
+}

---FILE: man/RRBLUPMemUse.Rd---
@@ -22,3 +22,7 @@ Estimates the amount of RAM needed to run the \code{\link{RRBLUP}}
 and its related functions for a given training population size. 
 Note that this functions may underestimate total usage.
 }
+\examples{
+RRBLUPMemUse(nInd=1000, nMarker=5000)
+
+}

---FILE: man/RRBLUP_D.Rd---
@@ -35,3 +35,24 @@ traits}
 Fits an RR-BLUP model for genomic predictions that includes 
 dominance effects.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAD(10, meanDD=0.5)
+SP$setVarE(h2=0.5)
+SP$addSnpChip(10)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Run GS model and set EBV
+ans = RRBLUP_D(pop, simParam=SP)
+pop = setEBV(pop, ans, simParam=SP)
+
+#Evaluate accuracy
+cor(gv(pop), ebv(pop))
+
+}

---FILE: man/RRBLUP_GCA.Rd---
@@ -36,3 +36,24 @@ females and males. Useful for predicting GCA of parents
 in single cross hybrids. Can also predict performance of specific 
 single cross hybrids.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$setVarE(h2=0.5)
+SP$addSnpChip(10)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Run GS model and set EBV
+ans = RRBLUP_GCA(pop, simParam=SP)
+pop = setEBV(pop, ans, simParam=SP)
+
+#Evaluate accuracy
+cor(gv(pop), ebv(pop))
+
+}

---FILE: man/RRBLUP_SCA.Rd---
@@ -35,3 +35,24 @@ An extention of \code{\link{RRBLUP_GCA}} that adds dominance effects.
 Note that we have not seen any consistent benefit of this model over 
 \code{\link{RRBLUP_GCA}}.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$setVarE(h2=0.5)
+SP$addSnpChip(10)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Run GS model and set EBV
+ans = RRBLUP_SCA(pop, simParam=SP)
+pop = setEBV(pop, ans, simParam=SP)
+
+#Evaluate accuracy
+cor(gv(pop), ebv(pop))
+
+}

---FILE: man/SimParam_addSnpChip.Rd---
@@ -17,3 +17,12 @@ Randomly assigns eligble SNPs to a SNP chip
  SP$addSnpChip(nSnpPerChr, force = FALSE)
 }
 
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addSnpChip(10)
+
+}

---FILE: man/SimParam_addTraitA.Rd---
@@ -29,3 +29,12 @@ with correlated additive effects.
 gamma = FALSE, shape = 1, force = FALSE)
 }
 
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+
+}

---FILE: man/SimParam_addTraitAD.Rd---
@@ -39,3 +39,12 @@ varDD = 0, corA = NULL, corDD = NULL, useVarA = TRUE, gamma = FALSE,
 shape = 1, force = FALSE)
 }
 
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAD(10, meanDD=0.5)
+
+}

---FILE: man/SimParam_addTraitADG.Rd---
@@ -43,3 +43,12 @@ varEnv = 0, meanDD = 0, varDD = 0, corA = NULL, corDD = NULL,
 corGxE = NULL, useVarA = TRUE, gamma = FALSE, shape = 1, force = FALSE)
 }
 
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitADG(10, meanDD=0.5, varGxE=2)
+
+}

---FILE: man/SimParam_addTraitAG.Rd---
@@ -32,3 +32,12 @@ with correlated effects.
 varEnv = 0, corA = NULL, corGxE = NULL, gamma = FALSE, shape = 1)
 }
 
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAG(10, varGxE=2)
+
+}

---FILE: man/SimParam_new.Rd---
@@ -20,3 +20,11 @@ argument with every call.
  SimParam$new(founderPop)
 }
 
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+
+}

---FILE: man/SimParam_removeSnpChip.Rd---
@@ -16,3 +16,15 @@ Removes designated SNP chip(s).
  SP$removeSnpChip(chips, force = FALSE)
 }
 
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addSnpChip(10)
+SP$nSnpChips
+SP$removeSnpChip(1)
+SP$nSnpChips
+
+}

---FILE: man/SimParam_removeTrait.Rd---
@@ -16,3 +16,16 @@ Removes designated trait(s).
  SP$removeTrait(traits, force = FALSE)
 }
 
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$nTraits
+SP$removeTrait(1)
+SP$nTraits
+
+
+}

---FILE: man/SimParam_rescaleTraits.Rd---
@@ -29,3 +29,22 @@ populations to obtain the new trait values.
 varGxE = 1e-6, useVarA = TRUE)
 }
 
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+meanG(pop)
+
+#Change mean to 1
+SP$rescaleTraits(pop, mean=1)
+#Run resetPop for chage to take effect
+pop = resetPop(pop, simParam=SP) 
+meanG(pop)
+
+}

---FILE: man/SimParam_resetPed.Rd---
@@ -17,3 +17,20 @@ that come from a portion the pedigree that is being reset.
  SP$resetPed(lastId = 0L)
 }
 
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+pop@id # 1:10
+
+#Create another population after reseting pedigree
+SP$resetPed()
+pop2 = newPop(founderPop, simParam=SP)
+pop2@id # 1:10
+
+}

---FILE: man/SimParam_restrQtlSites.Rd---
@@ -1,23 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_restrQtlSites}
-\alias{SimParam_restrQtlSites}
-\title{Restrict QTL sites}
-\arguments{
-\item{chr}{a vector of chromosome postions for eligible 
-QTL}
-
-\item{site}{a vector of eligible segregating sites within 
-chromosomes}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Sets restrictions on which segregating sites 
-can serve as QTL.
-}
-\section{Usage}{
- SP$restrQtlSites(chr = NULL, site = NULL, force = FALSE)
-}
-

---FILE: man/SimParam_restrSegSites.Rd---
@@ -29,3 +29,12 @@ can serve as SNP and/or QTL.
 snpQtlOverlap = FALSE, minSnpFreq = NULL, force = FALSE)
 }
 
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$restrSegSites(maxQtl=5, maxSnp=5)
+
+}

---FILE: man/SimParam_restrSnpSites.Rd---
@@ -1,23 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/Class-SimParam.R
-\name{SimParam_restrSnpSites}
-\alias{SimParam_restrSnpSites}
-\title{Restrict SNP sites}
-\arguments{
-\item{chr}{a vector of chromosome postions for eligible 
-SNPs}
-
-\item{site}{a vector of eligible segregating sites within 
-chromosomes}
-
-\item{force}{should the check for a running simulation be 
-ignored. Only set to TRUE if you know what you are doing.}
-}
-\description{
-Sets restrictions on which segregating sites 
-can serve as SNPs.
-}
-\section{Usage}{
- SP$restrSnpSites(chr=NULL, site=NULL, force = FALSE)
-}
-

---FILE: man/SimParam_setCorE.Rd---
@@ -15,3 +15,15 @@ first to define the default error variances.
  SP$setCorE(corE)
 }
 
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10, mean=c(0,0), var=c(1,1), corA=diag(2))
+SP$setVarE(varE=c(1,1))
+E = 0.5*diag(2)+0.5 #Positively correlated error
+SP$setCorE(E)
+
+}

---FILE: man/SimParam_setGender.Rd---
@@ -24,3 +24,12 @@ individuals.
  SP$setGender(gender, force = FALSE)
 }
 
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$setGender(""yes_sys"")
+
+}

---FILE: man/SimParam_setRecRatio.Rd---
@@ -22,3 +22,12 @@ females.
  SP$setRecRatio(ratio, force = FALSE)
 }
 
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$setRecRatio(2) #Twice as much recombination in females
+
+}

---FILE: man/SimParam_setTrackPed.Rd---
@@ -21,3 +21,12 @@ if it is turned on.
  SP$setTrackPed(isTrackPed, force = FALSE)
 }
 
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$setTrackPed(TRUE)
+
+}

---FILE: man/SimParam_setTrackRec.Rd---
@@ -21,3 +21,12 @@ pedigree is not tracked.
  SimParam$setTrackRec(isTrackRec, force = FALSE)
 }
 
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$setTrackRec(TRUE)
+
+}

---FILE: man/SimParam_setVarE.Rd---
@@ -18,3 +18,13 @@ variances in the simulation.
  SP$setVarE(h2 = NULL, H2 = NULL, varE = NULL)
 }
 
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$setVarE(h2=0.5)
+
+}

---FILE: man/bv.Rd---
@@ -14,3 +14,17 @@ bv(pop, simParam = NULL)
 \description{
 Returns breeding values for all traits
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAD(10, meanDD=0.5)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+bv(pop, simParam=SP)
+
+}

---FILE: man/calcGCA.Rd---
@@ -17,3 +17,19 @@ Calculate general combining ability of test crosses. Intended for
 output from hybridCross using the ""testcross"" option, but will work 
 for any population.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10, inbred=TRUE)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Make crosses for full diallele
+pop2 = hybridCross(pop, pop, simParam=SP)
+GCA = calcGCA(pop2, use=""gv"")
+
+}

---FILE: man/dd.Rd---
@@ -14,3 +14,17 @@ dd(pop, simParam = NULL)
 \description{
 Returns dominance deviations for all traits
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAD(10, meanDD=0.5)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+dd(pop, simParam=SP)
+
+}

---FILE: man/ebv.Rd---
@@ -12,3 +12,18 @@ ebv(pop)
 \description{
 A wrapper for accessing the ebv slot
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAD(10, meanDD=0.5)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+pop@ebv = matrix(rnorm(pop@nInd), nrow=pop@nInd, ncol=1)
+ebv(pop)
+
+}

---FILE: man/editGenome.Rd---
@@ -29,3 +29,20 @@ Edits selected loci of selected individuals to a homozygous
 state for either the 1 or 0 allele. The gv slot is recalculated to 
 reflect the any changes due to editing, but other slots remain the same.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Change individual 1 to homozygous for the 1 allele 
+#at locus 1, chromosome 1
+pop2 = editGenome(pop, ind=1, chr=1, segSites=1, 
+                  allele=1, simParam=SP)
+
+}

---FILE: man/editGenomeTopQtl.Rd---
@@ -28,3 +28,18 @@ Edits the top QTL (with the largest additive effect) to a homozygous
 state for the allele increasing. Only nonfixed QTL are edited The gv slot is
 recalculated to reflect the any changes due to editing, but other slots remain the same.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Change up to 10 loci for individual 1 
+pop2 = editGenomeTopQtl(pop, ind=1, nQtl=10, simParam=SP)
+                  
+}

---FILE: man/genParam.Rd---
@@ -33,3 +33,17 @@ genParam(pop, simParam = NULL)
 Calculates genetic and genic additive and dominance variances 
 for an object of \code{\link{Pop-class}}
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAD(10, meanDD=0.5)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+ans = genParam(pop, simParam=SP)
+
+}

---FILE: man/genicVarA.Rd---
@@ -14,3 +14,17 @@ genicVarA(pop, simParam = NULL)
 \description{
 Returns additive genic variance for all traits
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAD(10, meanDD=0.5)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+genicVarA(pop, simParam=SP)
+
+}

---FILE: man/genicVarD.Rd---
@@ -14,3 +14,17 @@ genicVarD(pop, simParam = NULL)
 \description{
 Returns dominance genic variance for all traits
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAD(10, meanDD=0.5)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+genicVarD(pop, simParam=SP)
+
+}

---FILE: man/genicVarG.Rd---
@@ -14,3 +14,17 @@ genicVarG(pop, simParam = NULL)
 \description{
 Returns total genic variance for all traits
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAD(10, meanDD=0.5)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+genicVarG(pop, simParam=SP)
+
+}

---FILE: man/gv.Rd---
@@ -12,3 +12,17 @@ gv(pop)
 \description{
 A wrapper for accessing the gv slot
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAD(10, meanDD=0.5)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+gv(pop)
+
+}

---FILE: man/hybridCross.Rd---
@@ -34,3 +34,17 @@ should only be used if the parents were created using the \code{\link{makeDH}}
 function or \code{\link{newPop}} using inbred founders. The id for 
 new individuals is [mother_id]_[father_id]
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10, inbred=TRUE)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Make crosses for full diallele
+pop2 = hybridCross(pop, pop, simParam=SP)
+
+}

---FILE: man/makeCross.Rd---
@@ -22,3 +22,18 @@ Returns an object of \code{\link{Pop-class}}
 Makes crosses within a population using a user supplied 
 crossing plan.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Cross individual 1 with individual 10
+crossPlan = matrix(c(1,10), nrow=1, ncol=2)
+pop2 = makeCross(pop, crossPlan, simParam=SP)
+
+}

---FILE: man/makeCross2.Rd---
@@ -24,3 +24,18 @@ Returns an object of \code{\link{Pop-class}}
 Makes crosses between two populations using a user supplied 
 crossing plan.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Cross individual 1 with individual 10
+crossPlan = matrix(c(1,10), nrow=1, ncol=2)
+pop2 = makeCross2(pop, pop, crossPlan, simParam=SP)
+
+}

---FILE: man/makeDH.Rd---
@@ -23,3 +23,17 @@ Returns an object of \code{\link{Pop-class}}
 Creates DH lines from each individual in a population. 
 Only works when gender is ""no"".
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Create 1 DH for each individual
+pop2 = makeDH(pop, simParam=SP)
+
+}

---FILE: man/meanG.Rd---
@@ -12,3 +12,17 @@ meanG(pop)
 \description{
 Returns the mean genetic values for all traits
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+meanG(pop)
+
+}

---FILE: man/meanP.Rd---
@@ -12,3 +12,17 @@ meanP(pop)
 \description{
 Returns the mean phenotypic values for all traits
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+meanP(pop)
+
+}

---FILE: man/mergePops.Rd---
@@ -16,3 +16,16 @@ Returns a \code{\link{Pop-class}}
 Rapidly merges a list of populations into a
 single population
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+
+#Create a list of populations and merge list
+pop = newPop(founderPop, simParam=SP)
+popList = list(pop, pop)
+pop2 = mergePops(popList)
+
+}

---FILE: man/nInd.Rd---
@@ -12,3 +12,17 @@ nInd(pop)
 \description{
 A wrapper for accessing the nInd slot
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAD(10, meanDD=0.5)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+nInd(pop)
+
+}

---FILE: man/newPop.Rd---
@@ -35,3 +35,15 @@ Creates a new \code{\link{Pop-class}} from an object of
 The function is intended for creating initial populations from 
 'FOUNDERPOP' created by \code{\link{runMacs}}.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+}

---FILE: man/pedigreeCross.Rd---
@@ -37,3 +37,20 @@ rates be used. This parameter has no effect if, recombRatio=1.}
 Creates a \code{\link{Pop-class}} from a generic 
 pedigree and a set of founder individuals.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Pedigree for a biparental cross with 7 generations of selfing
+id = 1:10
+mother = c(0,0,1,3:9)
+father = c(0,0,2,3:9)
+pop2 = pedigreeCross(pop, id, mother, father, simParam=SP)
+
+}

---FILE: man/pheno.Rd---
@@ -12,3 +12,17 @@ pheno(pop)
 \description{
 A wrapper for accessing the pheno slot
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAD(10, meanDD=0.5)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+pheno(pop)
+
+}

---FILE: man/pullQtlGeno.Rd---
@@ -23,3 +23,17 @@ Returns a matrix of QTL genotypes.
 \description{
 Retrieves QTL genotype data
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$addSnpChip(5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+pullQtlGeno(pop, simParam=SP)
+
+}

---FILE: man/pullQtlHaplo.Rd---
@@ -28,3 +28,17 @@ Returns a matrix of QTL haplotypes.
 \description{
 Retrieves QTL haplotype data
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$addSnpChip(5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+pullQtlHaplo(pop, simParam=SP)
+
+}

---FILE: man/pullSegSiteGeno.Rd---
@@ -21,3 +21,17 @@ Returns a matrix of genotypes
 \description{
 Retrieves genotype data for all segregating sites
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$addSnpChip(5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+pullSegSiteGeno(pop, simParam=SP)
+
+}

---FILE: man/pullSegSiteHaplo.Rd---
@@ -25,3 +25,17 @@ Returns a matrix of haplotypes
 \description{
 Retrieves haplotype data for all segregating sites
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$addSnpChip(5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+pullSegSiteHaplo(pop, simParam=SP)
+
+}

---FILE: man/pullSnpGeno.Rd---
@@ -23,3 +23,17 @@ Returns a matrix of SNP genotypes.
 \description{
 Retrieves SNP genotype data
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$addSnpChip(5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+pullSnpGeno(pop, simParam=SP)
+
+}

---FILE: man/pullSnpHaplo.Rd---
@@ -28,3 +28,17 @@ Returns a matrix of SNP haplotypes.
 \description{
 Retrieves SNP haplotype data
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$addSnpChip(5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+pullSnpHaplo(pop, simParam=SP)
+
+}

---FILE: man/quickHaplo.Rd---
@@ -0,0 +1,33 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/founderPop.R
+\name{quickHaplo}
+\alias{quickHaplo}
+\title{Quick founder haplotype simulation}
+\usage{
+quickHaplo(nInd, nChr, segSites, genLen = 1, inbred = FALSE)
+}
+\arguments{
+\item{nInd}{number of individuals to simulate}
+
+\item{nChr}{number of chromosomes to simulate}
+
+\item{segSites}{number of segregating sites per chromosome}
+
+\item{genLen}{genetic length of chromosomes}
+
+\item{inbred}{should founder individuals be inbred}
+}
+\value{
+an object of \code{\link{MapPop-class}}
+}
+\description{
+Rapidly simulates founder haplotypes by randomly 
+sampling 0s and 1s. This is equivalent to having all loci with 
+allele frequency 0.5 and being in linkage equilibrium.
+}
+\examples{
+# Creates a populations of 10 outbred individuals
+# Their genome consists of 1 chromosome and 100 segregating sites
+founderPop = quickHaplo(nInd=10,nChr=1,segSites=100)
+
+}

---FILE: man/randCross.Rd---
@@ -30,3 +30,17 @@ Returns an object of \code{\link{Pop-class}}
 A wrapper for \code{\link{makeCross}} that randomly 
 selects parental combinations for all possible combinantions.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Make 10 crosses
+pop2 = randCross(pop, 10, simParam=SP)
+
+}

---FILE: man/randCross2.Rd---
@@ -38,3 +38,17 @@ A wrapper for \code{\link{makeCross2}} that randomly
 selects parental combinations for all possible combinantions between 
 two populations.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Make 10 crosses
+pop2 = randCross2(pop, pop, 10, simParam=SP)
+
+}

---FILE: man/resetPop.Rd---
@@ -18,3 +18,19 @@ an object of \code{\link{Pop-class}}
 Recalculates a population's genetic values and 
 resets phenotypes and EBVs.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Rescale to set mean to 1
+SP$rescaleTraits(pop,mean=1)
+pop = resetPop(pop, simParam=SP)
+
+}

---FILE: man/selIndex.Rd---
@@ -19,3 +19,27 @@ weights. This function is intended to be used in combination with
 selection functions working on populations such as 
 \code{\link{selectInd}}.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+#Model two genetically correlated traits
+G = 1.5*diag(2)-0.5 #Genetic correlation matrix
+SP$addTraitA(10, mean=c(0,0), var=c(1,1), corA=G)
+SP$setVarE(h2=c(0.5,0.5))
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Calculate Smith-Hazel weights
+econWt = c(1, 1)
+b = smithHazel(econWt, varG(pop), varP(pop))
+
+#Selection 2 best individuals using Smith-Hazel index
+#selIndex is used as a trait
+pop2 = selectInd(pop, nInd=2, trait=selIndex, 
+                 simParam=SP, b=b)
+
+}

---FILE: man/selInt.Rd---
@@ -12,3 +12,7 @@ selInt(p)
 \description{
 Calculates the standardized selection intensity
 }
+\examples{
+selInt(0.1)
+
+}

---FILE: man/selectCross.Rd---
@@ -58,3 +58,19 @@ of intermediate populations created. This reduces RAM usage
 and simplifies code writing. Note that this wrapper does not 
 provide the full functionality of either function.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Select 4 individuals and make 8 crosses
+pop2 = selectCross(pop, nInd=4, nCrosses=8, simParam=SP)
+
+}

---FILE: man/selectFam.Rd---
@@ -49,3 +49,22 @@ Returns an object of \code{\link{Pop-class}} or
 Selects a subset of full-sib families from a 
 population.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Create 3 biparental families with 10 progeny
+pop2 = randCross(pop, nCrosses=3, nProgeny=10, simParam=SP)
+
+#Select best 2 families
+pop3 = selectFam(pop2, 2, simParam=SP)
+
+}

---FILE: man/selectInd.Rd---
@@ -44,3 +44,19 @@ Returns an object of \code{\link{Pop-class}} or
 Selects a subset of nInd individuals from a 
 population.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Select best 5
+pop2 = selectInd(pop, 5, simParam=SP)
+
+}

---FILE: man/selectOP.Rd---
@@ -43,3 +43,20 @@ plant population. It allows for varying the percentage of
 selfing. The function also provides an option for modeling 
 selection as occuring before or after pollination.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Create new population by selecting the best 3 plant
+#Assuming 50\% selfing in plants and 10 seeds per plant
+pop2 = selectOP(pop, nInd=3, nSeeds=10, probSelf=0.5, simParam=SP)
+
+}

---FILE: man/selectWithinFam.Rd---
@@ -50,3 +50,22 @@ Selects a subset of nInd individuals from each
 full-sib family within a population. Will return all individuals 
 from a full-sib family if it has less than or equal to nInd individuals.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Create 3 biparental families with 10 progeny
+pop2 = randCross(pop, nCrosses=3, nProgeny=10, simParam=SP)
+
+#Select best individual per family
+pop3 = selectWithinFam(pop2, 1, simParam=SP)
+
+}

---FILE: man/self.Rd---
@@ -22,3 +22,17 @@ Returns an object of \code{\link{Pop-class}}
 Creates selfed progeny from each individual in a 
 population. Only works when gender is ""no"".
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Self pollinate each individual
+pop2 = self(pop, simParam=SP)
+
+}

---FILE: man/setEBV.Rd---
@@ -35,3 +35,24 @@ Sets a population's EBV with genomic estimated
 values from \code{\link{RRBLUP}}, \code{\link{RRBLUP_GCA}},
 or \code{\link{RRBLUP_SCA}}.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$setVarE(h2=0.5)
+SP$addSnpChip(10)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Run GS model and set EBV
+ans = RRBLUP(pop, simParam=SP)
+pop = setEBV(pop, ans, simParam=SP)
+
+#Evaluate accuracy
+cor(gv(pop), ebv(pop))
+
+}

---FILE: man/setPheno.Rd---
@@ -43,3 +43,18 @@ breeding programs. In this case, varE is set to the plot error and
 reps is set to the number of plots per entry. The resulting phenotype 
 represents entry means.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Add phenotype with error variance of 1
+pop = setPheno(pop, varE=1)
+
+}

---FILE: man/setPhenoGCA.Rd---
@@ -54,3 +54,18 @@ breeding programs. In this case, varE is set to the plot error and
 reps is set to the number plots per entry. The resulting phenotype 
 would reflect the mean of all replications.
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10, inbred=TRUE)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Set phenotype to average per
+pop2 = setPhenoGCA(pop, pop, use=""gv"", inbred=TRUE, simParam=SP)
+
+}

---FILE: man/smithHazel.Rd---
@@ -20,3 +20,11 @@ a vector of weight for calculating index values
 Calculates weights for Smith-Hazel index given economice weights 
 and phenotypic and genotypic variance-covariance matrices.
 }
+\examples{
+G = 1.5*diag(2)-0.5
+E = diag(2)
+P = G+E
+wt = c(1,1)
+smithHazel(wt, G, P)
+
+}

---FILE: man/usefulness.Rd---
@@ -34,3 +34,21 @@ Returns a numeric value
 \description{
 Calculates the usefulness criterion
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=2, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+
+#Determine usefulness of population 
+usefulness(pop, simParam=SP)
+
+#Should be equivalent to GV of best individual
+max(gv(pop))
+
+}

---FILE: man/varA.Rd---
@@ -14,3 +14,17 @@ varA(pop, simParam = NULL)
 \description{
 Returns additive variance for all traits
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAD(10, meanDD=0.5)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+varA(pop, simParam=SP)
+
+}

---FILE: man/varD.Rd---
@@ -14,3 +14,17 @@ varD(pop, simParam = NULL)
 \description{
 Returns dominance variance for all traits
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitAD(10, meanDD=0.5)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+varD(pop, simParam=SP)
+
+}

---FILE: man/varG.Rd---
@@ -12,3 +12,17 @@ varG(pop)
 \description{
 Returns total genetic variance for all traits
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+varG(pop)
+
+}

---FILE: man/varP.Rd---
@@ -12,3 +12,17 @@ varP(pop)
 \description{
 Returns phenotypic variance for all traits
 }
+\examples{
+#Create founder haplotypes
+founderPop = quickHaplo(nInd=10, nChr=1, segSites=10)
+
+#Set simulation parameters
+SP = SimParam$new(founderPop)
+SP$addTraitA(10)
+SP$setVarE(h2=0.5)
+
+#Create population
+pop = newPop(founderPop, simParam=SP)
+varP(pop)
+
+}

---FILE: src/RcppExports.cpp---
@@ -6,6 +6,38 @@
 
 using namespace Rcpp;
 
+// writeASGenotypes
+void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP _AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
+END_RCPP
+}
+// writeASHaplotypes
+void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP _AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
+END_RCPP
+}
 // gebvRR
 arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop, int nThreads);
 RcppExport SEXP _AlphaSimR_gebvRR(SEXP RRsolSEXP, SEXP popSEXP, SEXP nThreadsSEXP) {
@@ -72,143 +104,6 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// callRRBLUP
-Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc);
-RcppExport SEXP _AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, geno, lociPerChr, lociLoc));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP2
-Rcpp::List callRRBLUP2(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, double Vu, double Ve, double tol, int maxIter, bool useEM);
-RcppExport SEXP _AlphaSimR_callRRBLUP2(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP VuSEXP, SEXP VeSEXP, SEXP tolSEXP, SEXP maxIterSEXP, SEXP useEMSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    Rcpp::traits::input_parameter< double >::type Vu(VuSEXP);
-    Rcpp::traits::input_parameter< double >::type Ve(VeSEXP);
-    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    Rcpp::traits::input_parameter< bool >::type useEM(useEMSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP2(y, x, reps, geno, lociPerChr, lociLoc, Vu, Ve, tol, maxIter, useEM));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_D
-Rcpp::List callRRBLUP_D(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter);
-RcppExport SEXP _AlphaSimR_callRRBLUP_D(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_D(y, x, reps, geno, lociPerChr, lociLoc, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_MV
-Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter);
-RcppExport SEXP _AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, geno, lociPerChr, lociLoc, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_GCA
-Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter);
-RcppExport SEXP _AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, geno, lociPerChr, lociLoc, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_SCA
-Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter);
-RcppExport SEXP _AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, geno, lociPerChr, lociLoc, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// writeASGenotypes
-void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP _AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
-END_RCPP
-}
-// writeASHaplotypes
-void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP _AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
-END_RCPP
-}
 // getGeno
 arma::Mat<unsigned char> getGeno(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
 RcppExport SEXP _AlphaSimR_getGeno(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
@@ -513,6 +408,111 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// callRRBLUP
+Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc);
+RcppExport SEXP _AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, geno, lociPerChr, lociLoc));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP2
+Rcpp::List callRRBLUP2(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, double Vu, double Ve, double tol, int maxIter, bool useEM);
+RcppExport SEXP _AlphaSimR_callRRBLUP2(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP VuSEXP, SEXP VeSEXP, SEXP tolSEXP, SEXP maxIterSEXP, SEXP useEMSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    Rcpp::traits::input_parameter< double >::type Vu(VuSEXP);
+    Rcpp::traits::input_parameter< double >::type Ve(VeSEXP);
+    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    Rcpp::traits::input_parameter< bool >::type useEM(useEMSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP2(y, x, reps, geno, lociPerChr, lociLoc, Vu, Ve, tol, maxIter, useEM));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_D
+Rcpp::List callRRBLUP_D(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter);
+RcppExport SEXP _AlphaSimR_callRRBLUP_D(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_D(y, x, reps, geno, lociPerChr, lociLoc, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_MV
+Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter);
+RcppExport SEXP _AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, geno, lociPerChr, lociLoc, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_GCA
+Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter);
+RcppExport SEXP _AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, geno, lociPerChr, lociLoc, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_SCA
+Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter);
+RcppExport SEXP _AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, geno, lociPerChr, lociLoc, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
 // packHaplo
 arma::Cube<unsigned char> packHaplo(arma::Mat<unsigned char>& haplo, arma::uword ploidy, bool inbred);
 RcppExport SEXP _AlphaSimR_packHaplo(SEXP haploSEXP, SEXP ploidySEXP, SEXP inbredSEXP) {"
gaynorr,AlphaSimR,7470a4f09f4892521d95e30e6fccf4113d70b419,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-09-13T10:37:57Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-09-13T10:37:57Z,"-fixes for male selection in selectOP
-fix for resetPop to match new trait scaling",NEWS;R/Class-SimParam.R;R/RcppExports.R;R/selection.R;man/SimParam_removeFounderPop.Rd;man/SimParam_rescaleTraits.Rd;man/SimParam_switchFounderPop.Rd;src/RcppExports.cpp;tests/testthat/test-crossing.R,False,True,True,False,239,212,451,"---FILE: NEWS---
@@ -8,6 +8,9 @@ Changes in version 0.7.2
     -added OpenMP support
     -parallelized cross2
     -parallelized runMacs
+    
+  Bug fixes
+    -fixes for male selection in selectOP
 
 Changes in version 0.7.1
   

---FILE: R/Class-SimParam.R---
@@ -1390,7 +1390,7 @@ SimParam$set(
 #' Linearly scales all traits to achieve desired 
 #' values of means and variances.
 #' 
-#' @section Usage: SP$rescaleTraits(pop, mean = 0, var = 1, varEnv = 1e-6, 
+#' @section Usage: SP$rescaleTraits(pop, mean = 0, var = 1, varEnv = 0, 
 #' varGxE = 1e-6, useVarA = TRUE)
 #' 
 #' @param pop an object of \code{\link{Pop-class}}
@@ -1410,7 +1410,7 @@ NULL
 SimParam$set(
   ""public"",
   ""rescaleTraits"",
-  function(pop,mean=0,var=1,varEnv=1e-6,
+  function(pop,mean=0,var=1,varEnv=0,
            varGxE=1e-6,useVarA=TRUE){
     isGxe = sapply(private$.traits,function(x){
       class(x)%in%c(""TraitAG"",""TraitADG"")
@@ -1432,18 +1432,25 @@ SimParam$set(
                      trait@lociLoc)
       if(class(trait)%in%c(""TraitAD"",""TraitADG"")){
         tmp = tuneTraitAD(geno,trait@addEff,trait@domEff,var[i],useVarA)
-        trait@domEff = trait@domEff*tmp$parameter
+        trait@domEff = trait@domEff*tmp$scale
       }else{
         tmp = tuneTraitA(geno,trait@addEff,var[i])
       }
-      trait@addEff = trait@addEff*tmp$parameter
-      trait@intercept = mean[i]-tmp$output$intercept
+      trait@addEff = trait@addEff*tmp$scale
+      trait@intercept = mean[i]-tmp$intercept
       if(class(trait)%in%c(""TraitAG"",""TraitADG"")){
-        targetVar = varGxE[i]/varEnv[i]
-        tmp = tuneTraitA(geno,trait@gxeEff,targetVar)
-        trait@gxeEff = trait@gxeEff*tmp$parameter
-        trait@gxeInt = 1-tmp$output$intercept
-        trait@envVar = varEnv[i]
+        if(varEnv[i]==0){
+          tmpG = tuneTraitA(geno,trait@gxeEff,varGxE[i])
+          trait@gxeEff = trait@gxeEff*tmpG$scale
+          trait@gxeInt = 0-tmpG$intercept
+          trait@envVar = 1
+        }else{
+          tmpG = tuneTraitA(geno,trait@gxeEff,
+                            varGxE[i]/varEnv[i])
+          trait@gxeEff = trait@gxeEff*tmpG$scale
+          trait@gxeInt = 1-tmpG$intercept
+          trait@envVar = varEnv[i]
+        }
       }
       private$.traits[[i]] = trait
     }
@@ -1464,7 +1471,7 @@ SimParam$set(
 #' 
 #' @section Usage: SP$switchFounderPop(founderPop)
 #' 
-#' @name SimParam_removeFounderPop
+#' @name SimParam_switchFounderPop
 NULL
 # switchFounderPop ----
 SimParam$set(

---FILE: R/RcppExports.R---
@@ -1,14 +1,6 @@
 # Generated by using Rcpp::compileAttributes() -> do not edit by hand
 # Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393
 
-writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call(`_AlphaSimR_writeASGenotypes`, g, locations, allLocations, snpchips, names, missing, fname))
-}
-
-writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call(`_AlphaSimR_writeASHaplotypes`, g, locations, allLocations, snpchips, names, missing, fname))
-}
-
 gebvRR <- function(RRsol, pop) {
     .Call(`_AlphaSimR_gebvRR`, RRsol, pop)
 }
@@ -29,6 +21,38 @@ gegvSCA <- function(sol, pop) {
     .Call(`_AlphaSimR_gegvSCA`, sol, pop)
 }
 
+callRRBLUP <- function(y, x, reps, geno, lociPerChr, lociLoc) {
+    .Call(`_AlphaSimR_callRRBLUP`, y, x, reps, geno, lociPerChr, lociLoc)
+}
+
+callRRBLUP2 <- function(y, x, reps, geno, lociPerChr, lociLoc, Vu, Ve, tol, maxIter, useEM) {
+    .Call(`_AlphaSimR_callRRBLUP2`, y, x, reps, geno, lociPerChr, lociLoc, Vu, Ve, tol, maxIter, useEM)
+}
+
+callRRBLUP_D <- function(y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov) {
+    .Call(`_AlphaSimR_callRRBLUP_D`, y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov)
+}
+
+callRRBLUP_MV <- function(Y, x, reps, geno, lociPerChr, lociLoc, maxIter) {
+    .Call(`_AlphaSimR_callRRBLUP_MV`, Y, x, reps, geno, lociPerChr, lociLoc, maxIter)
+}
+
+callRRBLUP_GCA <- function(y, x, reps, geno, lociPerChr, lociLoc, maxIter) {
+    .Call(`_AlphaSimR_callRRBLUP_GCA`, y, x, reps, geno, lociPerChr, lociLoc, maxIter)
+}
+
+callRRBLUP_SCA <- function(y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov) {
+    .Call(`_AlphaSimR_callRRBLUP_SCA`, y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov)
+}
+
+writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call(`_AlphaSimR_writeASGenotypes`, g, locations, allLocations, snpchips, names, missing, fname))
+}
+
+writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call(`_AlphaSimR_writeASHaplotypes`, g, locations, allLocations, snpchips, names, missing, fname))
+}
+
 getGeno <- function(geno, lociPerChr, lociLoc) {
     .Call(`_AlphaSimR_getGeno`, geno, lociPerChr, lociLoc)
 }
@@ -126,30 +150,6 @@ calcCoef <- function(X, Y) {
     .Call(`_AlphaSimR_calcCoef`, X, Y)
 }
 
-callRRBLUP <- function(y, x, reps, geno, lociPerChr, lociLoc) {
-    .Call(`_AlphaSimR_callRRBLUP`, y, x, reps, geno, lociPerChr, lociLoc)
-}
-
-callRRBLUP2 <- function(y, x, reps, geno, lociPerChr, lociLoc, Vu, Ve, tol, maxIter, useEM) {
-    .Call(`_AlphaSimR_callRRBLUP2`, y, x, reps, geno, lociPerChr, lociLoc, Vu, Ve, tol, maxIter, useEM)
-}
-
-callRRBLUP_D <- function(y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov) {
-    .Call(`_AlphaSimR_callRRBLUP_D`, y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov)
-}
-
-callRRBLUP_MV <- function(Y, x, reps, geno, lociPerChr, lociLoc, maxIter) {
-    .Call(`_AlphaSimR_callRRBLUP_MV`, Y, x, reps, geno, lociPerChr, lociLoc, maxIter)
-}
-
-callRRBLUP_GCA <- function(y, x, reps, geno, lociPerChr, lociLoc, maxIter) {
-    .Call(`_AlphaSimR_callRRBLUP_GCA`, y, x, reps, geno, lociPerChr, lociLoc, maxIter)
-}
-
-callRRBLUP_SCA <- function(y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov) {
-    .Call(`_AlphaSimR_callRRBLUP_SCA`, y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov)
-}
-
 packHaplo <- function(haplo, ploidy, inbred) {
     .Call(`_AlphaSimR_packHaplo`, haplo, ploidy, inbred)
 }

---FILE: R/selection.R---
@@ -308,12 +308,20 @@ selectOP = function(pop,nInd,nSeeds,probSelf=0,
   if(pollenControl){
     male = female
   }else{
-    male = 1:nInd
+    male = 1:pop@nInd
   }
   crossPlan = lapply(1:nInd,function(x){
-    cbind(rep(female[x],nSeeds),
-          c(rep(female[x],nSelf[x]),
-            sample(male[!male==female[x]],nSeeds-nSelf[x],replace=TRUE)))
+    male = male[!male==female[x]]
+    if(length(male)==1){
+      #Account for ""convenience"" feature of sample when length = 1
+      cbind(rep(female[x],nSeeds),
+            c(rep(female[x],nSelf[x]),
+              rep(male,nSeeds-nSelf[x])))
+    }else{
+      cbind(rep(female[x],nSeeds),
+            c(rep(female[x],nSelf[x]),
+              sample(male,nSeeds-nSelf[x],replace=TRUE)))
+    }
   })
   crossPlan = mergeMultIntMat(crossPlan,rep(nSeeds,nInd),2L)
   return(makeCross(pop=pop,crossPlan=crossPlan,simParam=simParam))

---FILE: man/SimParam_removeFounderPop.Rd---
@@ -2,23 +2,13 @@
 % Please edit documentation in R/Class-SimParam.R
 \name{SimParam_removeFounderPop}
 \alias{SimParam_removeFounderPop}
-\title{Switch founder population}
+\title{Remove founder population}
 \description{
-Switches the founder population in the founderPop 
-field. This may be desirable if traits are to be 
-tuned to a population derived from the original 
-founderPop. Note that no checking is performed to verify 
-that the genetic map and/or number of segregating sites 
-hasn't changed. The new founderPop can be 
-\code{\link{MapPop-class}} or \code{\link{RawPop-class}}
-
 Removes the founder population from the founderPop 
 field. This can be ran after all traits have been 
 added to reduce the size of the SimParam object.
 }
 \section{Usage}{
- SP$switchFounderPop(founderPop)
-
  SP$removeFounderPop()
 }
 

---FILE: man/SimParam_rescaleTraits.Rd---
@@ -25,7 +25,7 @@ You must run \code{\link{resetPop}} on existing
 populations to obtain the new trait values.
 }
 \section{Usage}{
- SP$rescaleTraits(pop, mean = 0, var = 1, varEnv = 1e-6, 
+ SP$rescaleTraits(pop, mean = 0, var = 1, varEnv = 0, 
 varGxE = 1e-6, useVarA = TRUE)
 }
 

---FILE: man/SimParam_switchFounderPop.Rd---
@@ -0,0 +1,18 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/Class-SimParam.R
+\name{SimParam_switchFounderPop}
+\alias{SimParam_switchFounderPop}
+\title{Switch founder population}
+\description{
+Switches the founder population in the founderPop 
+field. This may be desirable if traits are to be 
+tuned to a population derived from the original 
+founderPop. Note that no checking is performed to verify 
+that the genetic map and/or number of segregating sites 
+hasn't changed. The new founderPop can be 
+\code{\link{MapPop-class}} or \code{\link{RawPop-class}}
+}
+\section{Usage}{
+ SP$switchFounderPop(founderPop)
+}
+

---FILE: src/RcppExports.cpp---
@@ -6,38 +6,6 @@
 
 using namespace Rcpp;
 
-// writeASGenotypes
-void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP _AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
-END_RCPP
-}
-// writeASHaplotypes
-void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP _AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
-END_RCPP
-}
 // gebvRR
 arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
 RcppExport SEXP _AlphaSimR_gebvRR(SEXP RRsolSEXP, SEXP popSEXP) {
@@ -99,6 +67,145 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// callRRBLUP
+Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc);
+RcppExport SEXP _AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, geno, lociPerChr, lociLoc));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP2
+Rcpp::List callRRBLUP2(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, double Vu, double Ve, double tol, int maxIter, bool useEM);
+RcppExport SEXP _AlphaSimR_callRRBLUP2(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP VuSEXP, SEXP VeSEXP, SEXP tolSEXP, SEXP maxIterSEXP, SEXP useEMSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    Rcpp::traits::input_parameter< double >::type Vu(VuSEXP);
+    Rcpp::traits::input_parameter< double >::type Ve(VeSEXP);
+    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    Rcpp::traits::input_parameter< bool >::type useEM(useEMSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP2(y, x, reps, geno, lociPerChr, lociLoc, Vu, Ve, tol, maxIter, useEM));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_D
+Rcpp::List callRRBLUP_D(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter, bool useHetCov);
+RcppExport SEXP _AlphaSimR_callRRBLUP_D(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP, SEXP useHetCovSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    Rcpp::traits::input_parameter< bool >::type useHetCov(useHetCovSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_D(y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_MV
+Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter);
+RcppExport SEXP _AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, geno, lociPerChr, lociLoc, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_GCA
+Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter);
+RcppExport SEXP _AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, geno, lociPerChr, lociLoc, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_SCA
+Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter, bool useHetCov);
+RcppExport SEXP _AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP, SEXP useHetCovSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    Rcpp::traits::input_parameter< bool >::type useHetCov(useHetCovSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov));
+    return rcpp_result_gen;
+END_RCPP
+}
+// writeASGenotypes
+void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP _AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
+END_RCPP
+}
+// writeASHaplotypes
+void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP _AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
+END_RCPP
+}
 // getGeno
 arma::Mat<unsigned char> getGeno(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
 RcppExport SEXP _AlphaSimR_getGeno(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
@@ -372,113 +479,6 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// callRRBLUP
-Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc);
-RcppExport SEXP _AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, geno, lociPerChr, lociLoc));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP2
-Rcpp::List callRRBLUP2(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, double Vu, double Ve, double tol, int maxIter, bool useEM);
-RcppExport SEXP _AlphaSimR_callRRBLUP2(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP VuSEXP, SEXP VeSEXP, SEXP tolSEXP, SEXP maxIterSEXP, SEXP useEMSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    Rcpp::traits::input_parameter< double >::type Vu(VuSEXP);
-    Rcpp::traits::input_parameter< double >::type Ve(VeSEXP);
-    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    Rcpp::traits::input_parameter< bool >::type useEM(useEMSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP2(y, x, reps, geno, lociPerChr, lociLoc, Vu, Ve, tol, maxIter, useEM));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_D
-Rcpp::List callRRBLUP_D(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter, bool useHetCov);
-RcppExport SEXP _AlphaSimR_callRRBLUP_D(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP, SEXP useHetCovSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    Rcpp::traits::input_parameter< bool >::type useHetCov(useHetCovSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_D(y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_MV
-Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter);
-RcppExport SEXP _AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, geno, lociPerChr, lociLoc, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_GCA
-Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter);
-RcppExport SEXP _AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, geno, lociPerChr, lociLoc, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_SCA
-Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter, bool useHetCov);
-RcppExport SEXP _AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP, SEXP useHetCovSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    Rcpp::traits::input_parameter< bool >::type useHetCov(useHetCovSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov));
-    return rcpp_result_gen;
-END_RCPP
-}
 // packHaplo
 arma::Cube<unsigned char> packHaplo(arma::Mat<unsigned char>& haplo, arma::uword ploidy, bool inbred);
 RcppExport SEXP _AlphaSimR_packHaplo(SEXP haploSEXP, SEXP ploidySEXP, SEXP inbredSEXP) {

---FILE: tests/testthat/test-crossing.R---
@@ -1,8 +1,9 @@
 context(""crossing"")
 
+genMap = list(c(0))
+founderPop = trackHaploPop(genMap=genMap,nInd=2,inbred=TRUE)
+
 test_that(""makeCross"",{
-  genMap = list(c(0))
-  founderPop = trackHaploPop(genMap=genMap,nInd=2,inbred=TRUE)
   SP = SimParam$new(founderPop=founderPop)
   SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
   SP$setTrackPed(TRUE)
@@ -24,8 +25,6 @@ test_that(""makeCross"",{
 })
 
 test_that(""makeCross2"",{
-  genMap = list(c(0))
-  founderPop = trackHaploPop(genMap=genMap,nInd=2,inbred=TRUE)
   SP = SimParam$new(founderPop=founderPop)
   SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
   SP$setTrackPed(TRUE)
@@ -47,8 +46,6 @@ test_that(""makeCross2"",{
 })
 
 test_that(""randCross"",{
-  genMap = list(c(0))
-  founderPop = trackHaploPop(genMap=genMap,nInd=2,inbred=TRUE)
   SP = SimParam$new(founderPop=founderPop)
   SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
   SP$setTrackPed(TRUE)
@@ -63,8 +60,6 @@ test_that(""randCross"",{
 })
 
 test_that(""randCross2"",{
-  genMap = list(c(0))
-  founderPop = trackHaploPop(genMap=genMap,nInd=2,inbred=TRUE)
   SP = SimParam$new(founderPop=founderPop)
   SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
   SP$setTrackPed(TRUE)
@@ -79,8 +74,6 @@ test_that(""randCross2"",{
 })
 
 test_that(""self"",{
-  genMap = list(c(0))
-  founderPop = trackHaploPop(genMap=genMap,nInd=2,inbred=TRUE)
   SP = SimParam$new(founderPop=founderPop)
   SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
   SP$setTrackPed(TRUE)
@@ -95,8 +88,6 @@ test_that(""self"",{
 })
 
 test_that(""makeDH"",{
-  genMap = list(c(0))
-  founderPop = trackHaploPop(genMap=genMap,nInd=2,inbred=TRUE)
   SP = SimParam$new(founderPop=founderPop)
   SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
   SP$setTrackPed(TRUE)
@@ -111,8 +102,6 @@ test_that(""makeDH"",{
 })
 
 test_that(""selectCross"",{
-  genMap = list(c(0))
-  founderPop = trackHaploPop(genMap=genMap,nInd=2,inbred=TRUE)
   SP = SimParam$new(founderPop=founderPop)
   SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
   SP$setTrackPed(TRUE)
@@ -124,3 +113,15 @@ test_that(""selectCross"",{
   expect_equal(SP$pedigree[-(1:2),1L],c(2L,2L))
   expect_equal(SP$pedigree[-(1:2),2L],c(1L,1L))
 })
+
+test_that(""selectOP"",{
+  SP = SimParam$new(founderPop=founderPop)
+  SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
+  SP$setTrackPed(TRUE)
+  pop = newPop(founderPop,simParam=SP)
+  pop1 = selectOP(pop=pop,nInd=1,nSeeds=2,use=""gv"",simParam=SP)
+  expect_equal(SP$lastId,4L)
+  expect_equal(meanG(pop1),0,tolerance=1e-6)
+  tmp = abs(SP$pedigree[-(1:2),1L]-SP$pedigree[-(1:2),2L])
+  expect_equal(tmp,c(1L,1L))
+})"
gaynorr,AlphaSimR,a59d058fe5d7fd0fb74aadc9b6c66f6bc065b158,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-08-27T08:02:23Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-08-27T08:02:23Z,"-fixed bug in setVarE when using H2 and multiple traits
-update documentation
-removed unnecessary rawPop option for crossing",DESCRIPTION;NEWS;R/Class-SimParam.R;R/RcppExports.R;R/crossing.R;R/founderPop.R;R/selection.R;man/RRBLUP2.Rd;man/RRBLUP_D.Rd;man/RRBLUP_GCA.Rd;man/RRBLUP_SCA.Rd;man/SimParam_removeFounderPop.Rd;man/SimParam_restrSegSites.Rd;man/makeCross.Rd;man/makeCross2.Rd;man/makeDH.Rd;man/newPop.Rd;man/pedigreeCross.Rd;man/pullQtlHaplo.Rd;man/randCross.Rd;man/randCross2.Rd;man/runMacs.Rd;man/runMacs2.Rd;man/sampleHaplo.Rd;man/selectFam.Rd;man/selectWithinFam.Rd;man/self.Rd;man/setPhenoGCA.Rd;man/trackHaploPop.Rd;man/writeRecords.Rd;src/MME.cpp;src/RcppExports.cpp;src/misc.cpp;src/misc.h,False,True,True,False,275,315,590,"---FILE: DESCRIPTION---
@@ -12,7 +12,7 @@ LazyData: true
 Depends: R (>= 3.3.0), methods, R6
 Imports: Rcpp (>= 0.12.7), RcppArmadillo (>= 0.7.500.0.0)
 LinkingTo: Rcpp, RcppArmadillo, BH
-RoxygenNote: 6.0.1
+RoxygenNote: 6.1.0
 Suggests: knitr, rmarkdown, testthat
 VignetteBuilder: knitr
 NeedsCompilation: true

---FILE: NEWS---
@@ -14,6 +14,7 @@ Changes in version 0.7.0
     -fixed slow calcGCA
     -fixed error in addTraitAG preventing multiple traits
     -fixed bug with mergePops when merging ebv
+    -fixed bug in setVarE when using H2 and multiple traits
 
 Changes in version 0.6.1
 

---FILE: R/Class-SimParam.R---
@@ -445,8 +445,7 @@ SimParam$set(
 #' @param maxSnp the maximum number of segSites for SNPs. 
 #' Can be a single value or a vector values for each 
 #' chromosome.
-#' @param snpQtlOverlap should SNP and QTL loci be allowed 
-#' to overlap.
+#' @param overlap should SNP and QTL sites be allowed to overlap.
 #' @param minSnpFreq minimum allowable frequency for SNP loci. 
 #' No minimum SNP frequency is used if value is NULL.
 #' @param force should the check for a running simulation be 
@@ -458,7 +457,7 @@ NULL
 SimParam$set(
   ""public"",
   ""restrSegSites"",
-  function(maxQtl=0,maxSnp=0,snpQtlOverlap=FALSE,
+  function(maxQtl=0,maxSnp=0,overlap=FALSE,
            minSnpFreq=NULL, force=FALSE){
     if(!force){
       private$.isRunning()
@@ -474,7 +473,7 @@ SimParam$set(
     potSnp = list()
     potQtl = list()
     for(chr in 1:private$.nChr){
-      if(snpQtlOverlap){
+      if(overlap){
         stopifnot(private$.segSites[chr]>=maxSnp[chr],
                   private$.segSites[chr]>=maxQtl[chr])
         if(is.null(minSnpFreq)){
@@ -699,7 +698,7 @@ SimParam$set(
     }else if(!is.null(H2)){
       stopifnot(length(H2)==private$.nTraits)
       varE = numeric(private$.nTraits)
-      for(i in 1:length(h2)){
+      for(i in 1:length(H2)){
         tmp = private$.varG[i]/H2[i]-private$.varG[i]
         varE[i] = tmp
       }

---FILE: R/RcppExports.R---
@@ -1,14 +1,6 @@
 # Generated by using Rcpp::compileAttributes() -> do not edit by hand
 # Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393
 
-writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call(`_AlphaSimR_writeASGenotypes`, g, locations, allLocations, snpchips, names, missing, fname))
-}
-
-writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call(`_AlphaSimR_writeASHaplotypes`, g, locations, allLocations, snpchips, names, missing, fname))
-}
-
 gebvRR <- function(RRsol, pop) {
     .Call(`_AlphaSimR_gebvRR`, RRsol, pop)
 }
@@ -29,6 +21,38 @@ gegvSCA <- function(sol, pop) {
     .Call(`_AlphaSimR_gegvSCA`, sol, pop)
 }
 
+callRRBLUP <- function(y, x, reps, geno, lociPerChr, lociLoc) {
+    .Call(`_AlphaSimR_callRRBLUP`, y, x, reps, geno, lociPerChr, lociLoc)
+}
+
+callRRBLUP2 <- function(y, x, reps, geno, lociPerChr, lociLoc, Vu, Ve, tol, maxIter, useEM) {
+    .Call(`_AlphaSimR_callRRBLUP2`, y, x, reps, geno, lociPerChr, lociLoc, Vu, Ve, tol, maxIter, useEM)
+}
+
+callRRBLUP_D <- function(y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov) {
+    .Call(`_AlphaSimR_callRRBLUP_D`, y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov)
+}
+
+callRRBLUP_MV <- function(Y, x, reps, geno, lociPerChr, lociLoc, maxIter) {
+    .Call(`_AlphaSimR_callRRBLUP_MV`, Y, x, reps, geno, lociPerChr, lociLoc, maxIter)
+}
+
+callRRBLUP_GCA <- function(y, x, reps, geno, lociPerChr, lociLoc, maxIter) {
+    .Call(`_AlphaSimR_callRRBLUP_GCA`, y, x, reps, geno, lociPerChr, lociLoc, maxIter)
+}
+
+callRRBLUP_SCA <- function(y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov) {
+    .Call(`_AlphaSimR_callRRBLUP_SCA`, y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov)
+}
+
+writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call(`_AlphaSimR_writeASGenotypes`, g, locations, allLocations, snpchips, names, missing, fname))
+}
+
+writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call(`_AlphaSimR_writeASHaplotypes`, g, locations, allLocations, snpchips, names, missing, fname))
+}
+
 getGeno <- function(geno, lociPerChr, lociLoc) {
     .Call(`_AlphaSimR_getGeno`, geno, lociPerChr, lociLoc)
 }
@@ -122,30 +146,6 @@ calcCoef <- function(X, Y) {
     .Call(`_AlphaSimR_calcCoef`, X, Y)
 }
 
-callRRBLUP <- function(y, x, reps, geno, lociPerChr, lociLoc) {
-    .Call(`_AlphaSimR_callRRBLUP`, y, x, reps, geno, lociPerChr, lociLoc)
-}
-
-callRRBLUP2 <- function(y, x, reps, geno, lociPerChr, lociLoc, Vu, Ve, tol, maxIter, useEM) {
-    .Call(`_AlphaSimR_callRRBLUP2`, y, x, reps, geno, lociPerChr, lociLoc, Vu, Ve, tol, maxIter, useEM)
-}
-
-callRRBLUP_D <- function(y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov) {
-    .Call(`_AlphaSimR_callRRBLUP_D`, y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov)
-}
-
-callRRBLUP_MV <- function(Y, x, reps, geno, lociPerChr, lociLoc, maxIter) {
-    .Call(`_AlphaSimR_callRRBLUP_MV`, Y, x, reps, geno, lociPerChr, lociLoc, maxIter)
-}
-
-callRRBLUP_GCA <- function(y, x, reps, geno, lociPerChr, lociLoc, maxIter) {
-    .Call(`_AlphaSimR_callRRBLUP_GCA`, y, x, reps, geno, lociPerChr, lociLoc, maxIter)
-}
-
-callRRBLUP_SCA <- function(y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov) {
-    .Call(`_AlphaSimR_callRRBLUP_SCA`, y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov)
-}
-
 packHaplo <- function(haplo, ploidy, inbred) {
     .Call(`_AlphaSimR_packHaplo`, haplo, ploidy, inbred)
 }

---FILE: R/crossing.R---
@@ -8,15 +8,12 @@
 #' @param crossPlan a matrix with two column representing 
 #' female and male parents. Either integers for the position in 
 #' population or character strings for the IDs.
-#' @param rawPop should a \code{\link{RawPop-class}} be returned
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
-#' @return Returns an object of \code{\link{Pop-class}} or 
-#' \code{\link{RawPop-class}}
+#' @return Returns an object of \code{\link{Pop-class}}
 #'
 #' @export
-makeCross = function(pop,crossPlan,rawPop=FALSE,
-                     simParam=NULL){
+makeCross = function(pop,crossPlan,simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
@@ -41,7 +38,6 @@ makeCross = function(pop,crossPlan,rawPop=FALSE,
              ploidy=pop@ploidy,
              nLoci=pop@nLoci,
              geno=tmp$geno)
-  if(rawPop) return(rPop)
   if(simParam$isTrackRec){
     simParam$addToRec(tmp$recHist)
   }
@@ -63,17 +59,15 @@ makeCross = function(pop,crossPlan,rawPop=FALSE,
 #' @param balance if using gender, this option will balance the number 
 #' of progeny per parent
 #' @param parents an optional vector of indices for allowable parents
-#' @param rawPop should a \code{\link{RawPop-class}} be returned
 #' @param ignoreGender should gender be ignored
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
-#' @return Returns an object of \code{\link{Pop-class}} or 
-#' \code{\link{RawPop-class}}
+#' @return Returns an object of \code{\link{Pop-class}}
 #' 
 #' @export
 randCross = function(pop,nCrosses,nProgeny=1,
                      balance=TRUE,parents=NULL,
-                     rawPop=FALSE,ignoreGender=FALSE,
+                     ignoreGender=FALSE,
                      simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
@@ -116,8 +110,7 @@ randCross = function(pop,nCrosses,nProgeny=1,
     crossPlan = cbind(rep(crossPlan[,1],each=nProgeny),
                       rep(crossPlan[,2],each=nProgeny))
   }
-  return(makeCross(pop=pop,crossPlan=crossPlan,
-                   rawPop=rawPop,simParam=simParam))
+  return(makeCross(pop=pop,crossPlan=crossPlan,simParam=simParam))
 }
 
 #' @title Select and randomly cross
@@ -188,8 +181,7 @@ selectCross = function(pop,nInd=NULL,nFemale=NULL,nMale=NULL,nCrosses,
   
   return(randCross(pop=pop,nCrosses=nCrosses,nProgeny=nProgeny,
                    balance=balance,parents=parents,
-                   rawPop=FALSE,ignoreGender=FALSE,
-                   simParam=simParam))
+                   ignoreGender=FALSE,simParam=simParam))
 }
 
 #' @title Make designed crosses
@@ -203,15 +195,12 @@ selectCross = function(pop,nInd=NULL,nFemale=NULL,nMale=NULL,nCrosses,
 #' @param crossPlan a matrix with two column representing 
 #' female and male parents. Either integers for the position in 
 #' population or character strings for the IDs.
-#' @param rawPop should a \code{\link{RawPop-class}} be returned
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
-#' @return Returns an object of \code{\link{Pop-class}} or 
-#' \code{\link{RawPop-class}}
+#' @return Returns an object of \code{\link{Pop-class}}
 #'
 #' @export
-makeCross2 = function(females,males,crossPlan,
-                      rawPop=FALSE,simParam=NULL){
+makeCross2 = function(females,males,crossPlan,simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
@@ -236,7 +225,6 @@ makeCross2 = function(females,males,crossPlan,
              ploidy=females@ploidy,
              nLoci=females@nLoci,
              geno=tmp$geno)
-  if(rawPop) return(rPop)
   if(simParam$isTrackRec){
     simParam$addToRec(tmp$recHist)
   }
@@ -263,18 +251,16 @@ makeCross2 = function(females,males,crossPlan,
 #' female parents
 #' @param maleParents an optional vector of indices for allowable 
 #' male parents
-#' @param rawPop should a \code{\link{RawPop-class}} be returned
 #' @param ignoreGender should gender be ignored
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
-#' @return Returns an object of \code{\link{Pop-class}} or 
-#' \code{\link{RawPop-class}}
+#' @return Returns an object of \code{\link{Pop-class}}
 #' 
 #' @export
 randCross2 = function(females,males,nCrosses,nProgeny=1,
                       balance=TRUE,femaleParents=NULL,
-                      maleParents=NULL,rawPop=FALSE,
-                      ignoreGender=FALSE,simParam=NULL){
+                      maleParents=NULL,ignoreGender=FALSE,
+                      simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
@@ -326,8 +312,7 @@ randCross2 = function(females,males,nCrosses,nProgeny=1,
                       rep(crossPlan[,2],each=nProgeny))
   }
   return(makeCross2(females=females,males=males,
-                    crossPlan=crossPlan,
-                    rawPop=rawPop,simParam=simParam))
+                    crossPlan=crossPlan,simParam=simParam))
 }
 
 #' @title Self individuals
@@ -339,15 +324,12 @@ randCross2 = function(females,males,nCrosses,nProgeny=1,
 #' @param pop an object of \code{\link{Pop-class}}
 #' @param nProgeny total number of selfed progeny per individual
 #' @param parents an optional vector of indices for allowable parents
-#' @param rawPop should a \code{\link{RawPop-class}} be returned
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
-#' @return Returns an object of \code{\link{Pop-class}} or 
-#' \code{\link{RawPop-class}}
+#' @return Returns an object of \code{\link{Pop-class}}
 #' 
 #' @export
-self = function(pop,nProgeny=1,parents=NULL,
-                rawPop=FALSE,simParam=NULL){
+self = function(pop,nProgeny=1,parents=NULL,simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
@@ -372,7 +354,6 @@ self = function(pop,nProgeny=1,parents=NULL,
              ploidy=pop@ploidy,
              nLoci=pop@nLoci,
              geno=tmp$geno)
-  if(rawPop) return(rPop)
   if(simParam$isTrackRec){
     simParam$addToRec(tmp$recHist)
   }
@@ -393,15 +374,12 @@ self = function(pop,nProgeny=1,parents=NULL,
 #' @param nDH total number of DH lines per individual
 #' @param useFemale should female recombination rates be used. 
 #' This parameter has no effect if, recombRatio=1.
-#' @param rawPop should a \code{\link{RawPop-class}} be returned
 #' @param simParam an object of 'SimParam' class
 #' 
-#' @return Returns an object of \code{\link{Pop-class}} or 
-#' \code{\link{RawPop-class}}
+#' @return Returns an object of \code{\link{Pop-class}}
 #' 
 #' @export
-makeDH = function(pop,nDH=1,useFemale=TRUE,
-                  rawPop=FALSE,simParam=NULL){
+makeDH = function(pop,nDH=1,useFemale=TRUE,simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
@@ -423,7 +401,6 @@ makeDH = function(pop,nDH=1,useFemale=TRUE,
              ploidy=pop@ploidy,
              nLoci=pop@nLoci,
              geno=tmp$geno)
-  if(rawPop) return(rPop)
   if(simParam$isTrackRec){
     simParam$addToRec(tmp$recHist)
   }

---FILE: R/founderPop.R---
@@ -83,7 +83,8 @@ newMapPop = function(genMap,haplotypes,inbred=FALSE){
 #' @title Haplotype tracking population
 #' 
 #' @description
-#' Creates a population for tracking haplotypes.
+#' Creates a population contain haplotypes numbered for 
+#' identity be descent tracking.
 #'
 #' @param genMap a list of genetic maps
 #' @param nInd number of individuals
@@ -138,9 +139,9 @@ trackHaploPop = function(genMap,nInd,inbred=FALSE){
   return(output)
 }
 
-#' @title Create founder genotypes using MaCS
+#' @title Create founder haplotypes using MaCS
 #'
-#' @description Uses an external programs MaCS and AlphaFormatter to produce initial founder genotypes.
+#' @description Uses the MaCS software to produce founder haplotypes.
 #' 
 #' @param nInd number of individuals to simulate
 #' @param nChr number of chromosomes to simulate
@@ -189,27 +190,27 @@ runMacs = function(nInd,nChr=1,segSites=NULL,inbred=FALSE,species=""GENERIC"",
     if(species==""GENERIC""){ #GENERIC----
       genLen = 1.0
       Ne = 100
-      speciesParams = ""100000000 -t 0.10E-04 -r 0.40E-05""
-      speciesHist = ""-eN 0.25 5.0 -eN 1.25 12.5 -eN 2.50 15.0 -eN 12.50 35.0 -eN 25.00 60.0 -eN 250.00 120.0 -eN 2500.00 1000.0""
+      speciesParams = ""1E8 -t 1E-5 -r 4E-6""
+      speciesHist = ""-eN 0.25 5.0 -eN 2.50 15.0 -eN 25.00 60.0 -eN 250.00 120.0 -eN 2500.00 1000.0""
     }else if(species==""CATTLE""){ #CATTLE----
       genLen = 1.0
       Ne = 90
-      speciesParams = ""100000000 -t 9e-6 -r 3.6e-06""
+      speciesParams = ""1E8 -t 9E-6 -r 3.6E-6""
       speciesHist = ""-eN 0.011 1.33 -eN 0.019 2.78 -eN 0.036 3.89 -eN 0.053 11.11 -eN 0.069 16.67 -eN 0.431 22.22 -eN 1.264 27.78 -eN 1.819 38.89 -eN 4.875 77.78 -eN 6.542 111.11 -eN 9.319 188.89 -eN 92.097 688.89 -eN 2592.097 688.89""
     }else if(species==""WHEAT""){ #WHEAT----
       genLen = 1.43
       Ne = 50
-      speciesParams = ""800000000 -t 0.40E-06 -r 0.36E-06""
+      speciesParams = ""8E8 -t 4E-7 -r 3.6E-7""
       speciesHist = ""-eN 0.03 1 -eN 0.05 2 -eN 0.10 4 -eN 0.15 6 -eN 0.20 8 -eN 0.25 10 -eN 0.30 12 -eN 0.35 14 -eN 0.40 16 -eN 0.45 18 -eN 0.50 20 -eN 1.00 40 -eN 2.00 60 -eN 3.00 80 -eN 4.00 100 -eN 5.00 120 -eN 10.00 140 -eN 20.00 160 -eN 30.00 180 -eN 40.00 200 -eN 50.00 240 -eN 100.00 320 -eN 200.00 400 -eN 300.00 480 -eN 400.00 560 -eN 500.00 640""
     }else if(species==""MAIZE""){ #MAIZE----
       genLen = 2.0
       Ne = 100
-      speciesParams = ""200000000 -t 0.50E-05 -r 0.40E-05""
+      speciesParams = ""2E8 -t 5E-6 -r 4E-6""
       speciesHist = ""-eN 0.03 1 -eN 0.05 2 -eN 0.10 4 -eN 0.15 6 -eN 0.20 8 -eN 0.25 10 -eN 0.30 12 -eN 0.35 14 -eN 0.40 16 -eN 0.45 18 -eN 0.50 20 -eN 2.00 40 -eN 3.00 60 -eN 4.00 80 -eN 5.00 100"" 
     }else if(species==""EUROPEAN""){ #EUROPEAN----
       genLen = 1.3
       Ne = 512000
-      speciesParams = ""1.3e8 -t 0.0483328 -r 0.02054849""
+      speciesParams = ""1.3E8 -t 0.0483328 -r 0.02054849""
       speciesHist = ""-G 1.0195 -eG 0.0001000977 1.0031 -eN 0.0004492188 0.002015625 -eN 0.000449707 0.003634766""
     }else{
       stop(paste(""No rules for species"",species))
@@ -293,8 +294,8 @@ runMacs = function(nInd,nChr=1,segSites=NULL,inbred=FALSE,species=""GENERIC"",
 #' @export
 runMacs2 = function(nInd,nChr=1,segSites=NULL,Ne=100,
                     bp=1e8,genLen=1,mutRate=2.5e-8,
-                    histNe=c(500,1250,1500,3500,6000,12000,100000),
-                    histGen=c(100,500,1000,5000,10000,100000,1000000),
+                    histNe=c(500,1500,6000,12000,100000),
+                    histGen=c(100,1000,10000,100000,1000000),
                     inbred=FALSE,split=NULL,returnCommand=FALSE,
                     suppressMessages=FALSE){
   stopifnot(length(histNe)==length(histGen))
@@ -333,9 +334,9 @@ runMacs2 = function(nInd,nChr=1,segSites=NULL,Ne=100,
 #' Creates a new \code{\link{MapPop-class}} from an existing 
 #' \code{\link{MapPop-class}} by randomly sampling haplotypes.
 #' 
-#' @param nInd the number of individuals to create
 #' @param mapPop the \code{\link{MapPop-class}} used to 
 #' sample haplotypes
+#' @param nInd the number of individuals to create
 #' @param inbred should new individuals be fully inbred
 #' @param replace should haplotypes be sampled with replacement
 #' 
@@ -349,7 +350,7 @@ runMacs2 = function(nInd,nChr=1,segSites=NULL,Ne=100,
 #' founderPop = sampleHaplo(nInd=20,mapPop=founderPop)
 #' 
 #' @export
-sampleHaplo = function(nInd,mapPop,inbred=FALSE,replace=TRUE){
+sampleHaplo = function(mapPop,nInd,inbred=FALSE,replace=TRUE){
   nHaplo = mapPop@nInd*mapPop@ploidy
   if(inbred){
     nSamp = nInd

---FILE: R/selection.R---
@@ -316,6 +316,5 @@ selectOP = function(pop,nInd,nSeeds,probSelf=0,
             sample(male[!male==female[x]],nSeeds-nSelf[x],replace=TRUE)))
   })
   crossPlan = mergeMultIntMat(crossPlan,rep(nSeeds,nInd),2L)
-  return(makeCross(pop=pop,crossPlan=crossPlan,
-                   rawPop=FALSE,simParam=simParam))
+  return(makeCross(pop=pop,crossPlan=crossPlan,simParam=simParam))
 }

---FILE: man/RRBLUP2.Rd---
@@ -4,9 +4,9 @@
 \alias{RRBLUP2}
 \title{RR-BLUP Model 2}
 \usage{
-RRBLUP2(pop, traits = 1, use = ""pheno"", snpChip = 1, useQtl = FALSE,
-  maxIter = 10, Vu = NULL, Ve = NULL, useEM = TRUE, tol = 1e-06,
-  simParam = NULL, ...)
+RRBLUP2(pop, traits = 1, use = ""pheno"", snpChip = 1,
+  useQtl = FALSE, maxIter = 10, Vu = NULL, Ve = NULL,
+  useEM = TRUE, tol = 1e-06, simParam = NULL, ...)
 }
 \arguments{
 \item{pop}{a \code{\link{Pop-class}} to serve as the training population}

---FILE: man/RRBLUP_D.Rd---
@@ -4,8 +4,9 @@
 \alias{RRBLUP_D}
 \title{RR-BLUP Model with Dominance}
 \usage{
-RRBLUP_D(pop, traits = 1, use = ""pheno"", snpChip = 1, useQtl = FALSE,
-  useHetCov = TRUE, maxIter = 40L, simParam = NULL, ...)
+RRBLUP_D(pop, traits = 1, use = ""pheno"", snpChip = 1,
+  useQtl = FALSE, useHetCov = TRUE, maxIter = 40L, simParam = NULL,
+  ...)
 }
 \arguments{
 \item{pop}{a \code{\link{Pop-class}} to serve as the training population}

---FILE: man/RRBLUP_GCA.Rd---
@@ -4,8 +4,8 @@
 \alias{RRBLUP_GCA}
 \title{RR-BLUP GCA Model}
 \usage{
-RRBLUP_GCA(pop, traits = 1, use = ""pheno"", snpChip = 1, useQtl = FALSE,
-  maxIter = 40L, simParam = NULL, ...)
+RRBLUP_GCA(pop, traits = 1, use = ""pheno"", snpChip = 1,
+  useQtl = FALSE, maxIter = 40L, simParam = NULL, ...)
 }
 \arguments{
 \item{pop}{a \code{\link{Pop-class}} to serve as the training population}

---FILE: man/RRBLUP_SCA.Rd---
@@ -4,9 +4,9 @@
 \alias{RRBLUP_SCA}
 \title{RR-BLUP SCA Model}
 \usage{
-RRBLUP_SCA(pop, traits = 1, use = ""pheno"", snpChip = 1, useQtl = FALSE,
-  maxIter = 40L, useHetCov = FALSE, onFailGCA = TRUE, simParam = NULL,
-  ...)
+RRBLUP_SCA(pop, traits = 1, use = ""pheno"", snpChip = 1,
+  useQtl = FALSE, maxIter = 40L, useHetCov = FALSE,
+  onFailGCA = TRUE, simParam = NULL, ...)
 }
 \arguments{
 \item{pop}{a \code{\link{Pop-class}} to serve as the training population}

---FILE: man/SimParam_removeFounderPop.Rd---
@@ -2,7 +2,6 @@
 % Please edit documentation in R/Class-SimParam.R
 \name{SimParam_removeFounderPop}
 \alias{SimParam_removeFounderPop}
-\alias{SimParam_removeFounderPop}
 \title{Switch founder population}
 \description{
 Switches the founder population in the founderPop 

---FILE: man/SimParam_restrSegSites.Rd---
@@ -12,8 +12,7 @@ chromosome.}
 Can be a single value or a vector values for each 
 chromosome.}
 
-\item{snpQtlOverlap}{should SNP and QTL loci be allowed 
-to overlap.}
+\item{overlap}{should SNP and QTL sites be allowed to overlap.}
 
 \item{minSnpFreq}{minimum allowable frequency for SNP loci. 
 No minimum SNP frequency is used if value is NULL.}

---FILE: man/makeCross.Rd---
@@ -4,7 +4,7 @@
 \alias{makeCross}
 \title{Make designed crosses}
 \usage{
-makeCross(pop, crossPlan, rawPop = FALSE, simParam = NULL)
+makeCross(pop, crossPlan, simParam = NULL)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}}}
@@ -13,13 +13,10 @@ makeCross(pop, crossPlan, rawPop = FALSE, simParam = NULL)
 female and male parents. Either integers for the position in 
 population or character strings for the IDs.}
 
-\item{rawPop}{should a \code{\link{RawPop-class}} be returned}
-
 \item{simParam}{an object of \code{\link{SimParam}}}
 }
 \value{
-Returns an object of \code{\link{Pop-class}} or 
-\code{\link{RawPop-class}}
+Returns an object of \code{\link{Pop-class}}
 }
 \description{
 Makes crosses within a population using a user supplied 

---FILE: man/makeCross2.Rd---
@@ -4,7 +4,7 @@
 \alias{makeCross2}
 \title{Make designed crosses}
 \usage{
-makeCross2(females, males, crossPlan, rawPop = FALSE, simParam = NULL)
+makeCross2(females, males, crossPlan, simParam = NULL)
 }
 \arguments{
 \item{females}{an object of \code{\link{Pop-class}} for female parents.}
@@ -15,13 +15,10 @@ makeCross2(females, males, crossPlan, rawPop = FALSE, simParam = NULL)
 female and male parents. Either integers for the position in 
 population or character strings for the IDs.}
 
-\item{rawPop}{should a \code{\link{RawPop-class}} be returned}
-
 \item{simParam}{an object of \code{\link{SimParam}}}
 }
 \value{
-Returns an object of \code{\link{Pop-class}} or 
-\code{\link{RawPop-class}}
+Returns an object of \code{\link{Pop-class}}
 }
 \description{
 Makes crosses between two populations using a user supplied 

---FILE: man/makeDH.Rd---
@@ -4,7 +4,7 @@
 \alias{makeDH}
 \title{Generates DH lines}
 \usage{
-makeDH(pop, nDH = 1, useFemale = TRUE, rawPop = FALSE, simParam = NULL)
+makeDH(pop, nDH = 1, useFemale = TRUE, simParam = NULL)
 }
 \arguments{
 \item{pop}{an object of 'Pop' superclass}
@@ -14,13 +14,10 @@ makeDH(pop, nDH = 1, useFemale = TRUE, rawPop = FALSE, simParam = NULL)
 \item{useFemale}{should female recombination rates be used. 
 This parameter has no effect if, recombRatio=1.}
 
-\item{rawPop}{should a \code{\link{RawPop-class}} be returned}
-
 \item{simParam}{an object of 'SimParam' class}
 }
 \value{
-Returns an object of \code{\link{Pop-class}} or 
-\code{\link{RawPop-class}}
+Returns an object of \code{\link{Pop-class}}
 }
 \description{
 Creates DH lines from each individual in a population. 

---FILE: man/newPop.Rd---
@@ -4,8 +4,8 @@
 \alias{newPop}
 \title{Create new Population}
 \usage{
-newPop(rawPop, mother = NULL, father = NULL, origM = NULL, origF = NULL,
-  isDH = FALSE, simParam = NULL)
+newPop(rawPop, mother = NULL, father = NULL, origM = NULL,
+  origF = NULL, isDH = FALSE, simParam = NULL)
 }
 \arguments{
 \item{rawPop}{an object of \code{\link{MapPop-class}} or 

---FILE: man/pedigreeCross.Rd---
@@ -4,8 +4,8 @@
 \alias{pedigreeCross}
 \title{Pedigree cross}
 \usage{
-pedigreeCross(founderPop, id, mother, father, maxCycle = 100, DH = NULL,
-  useFemale = TRUE, simParam = NULL)
+pedigreeCross(founderPop, id, mother, father, maxCycle = 100,
+  DH = NULL, useFemale = TRUE, simParam = NULL)
 }
 \arguments{
 \item{founderPop}{a \code{\link{Pop-class}}}

---FILE: man/pullQtlHaplo.Rd---
@@ -4,7 +4,8 @@
 \alias{pullQtlHaplo}
 \title{Pull QTL haplotypes}
 \usage{
-pullQtlHaplo(pop, trait = 1, haplo = ""all"", chr = NULL, simParam = NULL)
+pullQtlHaplo(pop, trait = 1, haplo = ""all"", chr = NULL,
+  simParam = NULL)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}}}

---FILE: man/randCross.Rd---
@@ -4,8 +4,8 @@
 \alias{randCross}
 \title{Make random crosses}
 \usage{
-randCross(pop, nCrosses, nProgeny = 1, balance = TRUE, parents = NULL,
-  rawPop = FALSE, ignoreGender = FALSE, simParam = NULL)
+randCross(pop, nCrosses, nProgeny = 1, balance = TRUE,
+  parents = NULL, ignoreGender = FALSE, simParam = NULL)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}}}
@@ -19,15 +19,12 @@ of progeny per parent}
 
 \item{parents}{an optional vector of indices for allowable parents}
 
-\item{rawPop}{should a \code{\link{RawPop-class}} be returned}
-
 \item{ignoreGender}{should gender be ignored}
 
 \item{simParam}{an object of \code{\link{SimParam}}}
 }
 \value{
-Returns an object of \code{\link{Pop-class}} or 
-\code{\link{RawPop-class}}
+Returns an object of \code{\link{Pop-class}}
 }
 \description{
 A wrapper for \code{\link{makeCross}} that randomly 

---FILE: man/randCross2.Rd---
@@ -5,8 +5,8 @@
 \title{Make random crosses}
 \usage{
 randCross2(females, males, nCrosses, nProgeny = 1, balance = TRUE,
-  femaleParents = NULL, maleParents = NULL, rawPop = FALSE,
-  ignoreGender = FALSE, simParam = NULL)
+  femaleParents = NULL, maleParents = NULL, ignoreGender = FALSE,
+  simParam = NULL)
 }
 \arguments{
 \item{females}{an object of \code{\link{Pop-class}} for female parents.}
@@ -26,15 +26,12 @@ female parents}
 \item{maleParents}{an optional vector of indices for allowable 
 male parents}
 
-\item{rawPop}{should a \code{\link{RawPop-class}} be returned}
-
 \item{ignoreGender}{should gender be ignored}
 
 \item{simParam}{an object of \code{\link{SimParam}}}
 }
 \value{
-Returns an object of \code{\link{Pop-class}} or 
-\code{\link{RawPop-class}}
+Returns an object of \code{\link{Pop-class}}
 }
 \description{
 A wrapper for \code{\link{makeCross2}} that randomly 

---FILE: man/runMacs.Rd---
@@ -2,7 +2,7 @@
 % Please edit documentation in R/founderPop.R
 \name{runMacs}
 \alias{runMacs}
-\title{Create founder genotypes using MaCS}
+\title{Create founder haplotypes using MaCS}
 \usage{
 runMacs(nInd, nChr = 1, segSites = NULL, inbred = FALSE,
   species = ""GENERIC"", split = NULL, manualCommand = NULL,
@@ -36,7 +36,7 @@ For advanced users only.}
 an object of \code{\link{MapPop-class}}
 }
 \description{
-Uses an external programs MaCS and AlphaFormatter to produce initial founder genotypes.
+Uses the MaCS software to produce founder haplotypes.
 }
 \details{
 The current species histories are included: GENERIC, CATTLE, WHEAT, MAIZE,  

---FILE: man/runMacs2.Rd---
@@ -5,10 +5,9 @@
 \title{Alternative wrapper for MaCS}
 \usage{
 runMacs2(nInd, nChr = 1, segSites = NULL, Ne = 100, bp = 1e+08,
-  genLen = 1, mutRate = 2.5e-08, histNe = c(500, 1250, 1500, 3500, 6000,
-  12000, 1e+05), histGen = c(100, 500, 1000, 5000, 10000, 1e+05, 1e+06),
-  inbred = FALSE, split = NULL, returnCommand = FALSE,
-  suppressMessages = FALSE)
+  genLen = 1, mutRate = 2.5e-08, histNe = c(500, 1500, 6000, 12000,
+  1e+05), histGen = c(100, 1000, 10000, 1e+05, 1e+06), inbred = FALSE,
+  split = NULL, returnCommand = FALSE, suppressMessages = FALSE)
 }
 \arguments{
 \item{nInd}{number of individuals to simulate}

---FILE: man/sampleHaplo.Rd---
@@ -4,14 +4,14 @@
 \alias{sampleHaplo}
 \title{Sample haplotypes from a MapPop}
 \usage{
-sampleHaplo(nInd, mapPop, inbred = FALSE, replace = TRUE)
+sampleHaplo(mapPop, nInd, inbred = FALSE, replace = TRUE)
 }
 \arguments{
-\item{nInd}{the number of individuals to create}
-
 \item{mapPop}{the \code{\link{MapPop-class}} used to 
 sample haplotypes}
 
+\item{nInd}{the number of individuals to create}
+
 \item{inbred}{should new individuals be fully inbred}
 
 \item{replace}{should haplotypes be sampled with replacement}

---FILE: man/selectFam.Rd---
@@ -5,8 +5,8 @@
 \title{Select families}
 \usage{
 selectFam(pop, nFam, trait = 1, use = ""pheno"", gender = ""B"",
-  famType = ""B"", selectTop = TRUE, returnPop = TRUE, simParam = NULL,
-  ...)
+  famType = ""B"", selectTop = TRUE, returnPop = TRUE,
+  simParam = NULL, ...)
 }
 \arguments{
 \item{pop}{and object of \code{\link{Pop-class}} or 

---FILE: man/selectWithinFam.Rd---
@@ -5,8 +5,8 @@
 \title{Select individuals within families}
 \usage{
 selectWithinFam(pop, nInd, trait = 1, use = ""pheno"", gender = ""B"",
-  famType = ""B"", selectTop = TRUE, returnPop = TRUE, simParam = NULL,
-  ...)
+  famType = ""B"", selectTop = TRUE, returnPop = TRUE,
+  simParam = NULL, ...)
 }
 \arguments{
 \item{pop}{and object of \code{\link{Pop-class}} or 

---FILE: man/self.Rd---
@@ -4,7 +4,7 @@
 \alias{self}
 \title{Self individuals}
 \usage{
-self(pop, nProgeny = 1, parents = NULL, rawPop = FALSE, simParam = NULL)
+self(pop, nProgeny = 1, parents = NULL, simParam = NULL)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}}}
@@ -13,13 +13,10 @@ self(pop, nProgeny = 1, parents = NULL, rawPop = FALSE, simParam = NULL)
 
 \item{parents}{an optional vector of indices for allowable parents}
 
-\item{rawPop}{should a \code{\link{RawPop-class}} be returned}
-
 \item{simParam}{an object of \code{\link{SimParam}}}
 }
 \value{
-Returns an object of \code{\link{Pop-class}} or 
-\code{\link{RawPop-class}}
+Returns an object of \code{\link{Pop-class}}
 }
 \description{
 Creates selfed progeny from each individual in a 

---FILE: man/setPhenoGCA.Rd---
@@ -4,8 +4,9 @@
 \alias{setPhenoGCA}
 \title{Set GCA as phenotype}
 \usage{
-setPhenoGCA(pop, testers, use = ""pheno"", varE = NULL, reps = 1, p = 0.5,
-  inbred = FALSE, chunkSize = 10000, onlyPheno = FALSE, simParam = NULL)
+setPhenoGCA(pop, testers, use = ""pheno"", varE = NULL, reps = 1,
+  p = 0.5, inbred = FALSE, chunkSize = 10000, onlyPheno = FALSE,
+  simParam = NULL)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}}}

---FILE: man/trackHaploPop.Rd---
@@ -14,7 +14,8 @@ trackHaploPop(genMap, nInd, inbred = FALSE)
 \item{inbred}{should individuals be fully inbred}
 }
 \description{
-Creates a population for tracking haplotypes.
+Creates a population contain haplotypes numbered for 
+identity be descent tracking.
 }
 \details{
 Each item of genMap must be a vector of ordered genetic lengths in 

---FILE: man/writeRecords.Rd---
@@ -4,8 +4,8 @@
 \alias{writeRecords}
 \title{Write data records}
 \usage{
-writeRecords(pop, dir, snpChip = 1, useQtl = FALSE, includeHaplo = FALSE,
-  append = TRUE, simParam = NULL)
+writeRecords(pop, dir, snpChip = 1, useQtl = FALSE,
+  includeHaplo = FALSE, append = TRUE, simParam = NULL)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}}}

---FILE: src/MME.cpp---
@@ -12,9 +12,9 @@ extern ""C"" void dsyevr_(char* JOBZ, char* RANGE, char* UPLO, long long int* N, d
                        long long int* LIWORK, long long int* INFO);
 
 // Replacement for Armadillo's eig_sym
-// Fixes an error with decompisition of large matrices on Eddie
+// Fixes an error with decompisition of large matrices
 // If calcVec = false, eigvec is not used
-// It would be better to template this function
+// It would be better to template this function in the future
 int eigen2(arma::vec& eigval, arma::mat& eigvec, arma::mat X,
            bool calcVec = true){
   char JOBZ;

---FILE: src/RcppExports.cpp---
@@ -6,38 +6,6 @@
 
 using namespace Rcpp;
 
-// writeASGenotypes
-void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP _AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
-END_RCPP
-}
-// writeASHaplotypes
-void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP _AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
-END_RCPP
-}
 // gebvRR
 arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
 RcppExport SEXP _AlphaSimR_gebvRR(SEXP RRsolSEXP, SEXP popSEXP) {
@@ -99,6 +67,145 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// callRRBLUP
+Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc);
+RcppExport SEXP _AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, geno, lociPerChr, lociLoc));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP2
+Rcpp::List callRRBLUP2(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, double Vu, double Ve, double tol, int maxIter, bool useEM);
+RcppExport SEXP _AlphaSimR_callRRBLUP2(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP VuSEXP, SEXP VeSEXP, SEXP tolSEXP, SEXP maxIterSEXP, SEXP useEMSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    Rcpp::traits::input_parameter< double >::type Vu(VuSEXP);
+    Rcpp::traits::input_parameter< double >::type Ve(VeSEXP);
+    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    Rcpp::traits::input_parameter< bool >::type useEM(useEMSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP2(y, x, reps, geno, lociPerChr, lociLoc, Vu, Ve, tol, maxIter, useEM));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_D
+Rcpp::List callRRBLUP_D(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter, bool useHetCov);
+RcppExport SEXP _AlphaSimR_callRRBLUP_D(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP, SEXP useHetCovSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    Rcpp::traits::input_parameter< bool >::type useHetCov(useHetCovSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_D(y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_MV
+Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter);
+RcppExport SEXP _AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, geno, lociPerChr, lociLoc, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_GCA
+Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter);
+RcppExport SEXP _AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, geno, lociPerChr, lociLoc, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_SCA
+Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter, bool useHetCov);
+RcppExport SEXP _AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP, SEXP useHetCovSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    Rcpp::traits::input_parameter< bool >::type useHetCov(useHetCovSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov));
+    return rcpp_result_gen;
+END_RCPP
+}
+// writeASGenotypes
+void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP _AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
+END_RCPP
+}
+// writeASHaplotypes
+void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP _AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
+END_RCPP
+}
 // getGeno
 arma::Mat<unsigned char> getGeno(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
 RcppExport SEXP _AlphaSimR_getGeno(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
@@ -320,7 +427,7 @@ BEGIN_RCPP
 END_RCPP
 }
 // sampAllComb
-arma::Mat<arma::uword> sampAllComb(arma::uword nLevel1, arma::uword nLevel2, arma::uword n);
+arma::umat sampAllComb(arma::uword nLevel1, arma::uword nLevel2, arma::uword n);
 RcppExport SEXP _AlphaSimR_sampAllComb(SEXP nLevel1SEXP, SEXP nLevel2SEXP, SEXP nSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
@@ -333,7 +440,7 @@ BEGIN_RCPP
 END_RCPP
 }
 // sampHalfDialComb
-arma::Mat<arma::uword> sampHalfDialComb(arma::uword nLevel, arma::uword n);
+arma::umat sampHalfDialComb(arma::uword nLevel, arma::uword n);
 RcppExport SEXP _AlphaSimR_sampHalfDialComb(SEXP nLevelSEXP, SEXP nSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
@@ -356,113 +463,6 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// callRRBLUP
-Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc);
-RcppExport SEXP _AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, geno, lociPerChr, lociLoc));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP2
-Rcpp::List callRRBLUP2(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, double Vu, double Ve, double tol, int maxIter, bool useEM);
-RcppExport SEXP _AlphaSimR_callRRBLUP2(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP VuSEXP, SEXP VeSEXP, SEXP tolSEXP, SEXP maxIterSEXP, SEXP useEMSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    Rcpp::traits::input_parameter< double >::type Vu(VuSEXP);
-    Rcpp::traits::input_parameter< double >::type Ve(VeSEXP);
-    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    Rcpp::traits::input_parameter< bool >::type useEM(useEMSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP2(y, x, reps, geno, lociPerChr, lociLoc, Vu, Ve, tol, maxIter, useEM));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_D
-Rcpp::List callRRBLUP_D(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter, bool useHetCov);
-RcppExport SEXP _AlphaSimR_callRRBLUP_D(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP, SEXP useHetCovSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    Rcpp::traits::input_parameter< bool >::type useHetCov(useHetCovSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_D(y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_MV
-Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter);
-RcppExport SEXP _AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, geno, lociPerChr, lociLoc, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_GCA
-Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter);
-RcppExport SEXP _AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, geno, lociPerChr, lociLoc, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_SCA
-Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, arma::field<arma::Cube<unsigned char> >& geno, arma::ivec& lociPerChr, arma::uvec lociLoc, int maxIter, bool useHetCov);
-RcppExport SEXP _AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP maxIterSEXP, SEXP useHetCovSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    Rcpp::traits::input_parameter< bool >::type useHetCov(useHetCovSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, geno, lociPerChr, lociLoc, maxIter, useHetCov));
-    return rcpp_result_gen;
-END_RCPP
-}
 // packHaplo
 arma::Cube<unsigned char> packHaplo(arma::Mat<unsigned char>& haplo, arma::uword ploidy, bool inbred);
 RcppExport SEXP _AlphaSimR_packHaplo(SEXP haploSEXP, SEXP ploidySEXP, SEXP inbredSEXP) {

---FILE: src/misc.cpp---
@@ -134,11 +134,11 @@ arma::uword mapCol(arma::uword k, arma::uword n){
 // Returns an integer vector of length n with values ranging from 0 to N-1
 // From: https://stackoverflow.com/questions/311703/algorithm-for-sampling-without-replacement
 // Reportedly from: Algorithm 3.4.2S of Knuth's book Seminumeric Algorithms
-arma::Col<arma::uword> sampleInt(arma::uword n, arma::uword N){
+arma::uvec sampleInt(arma::uword n, arma::uword N){
   arma::uword t = 0;
   arma::uword m = 0;
   arma::vec u(1);
-  arma::Col<arma::uword> samples(n);
+  arma::uvec samples(n);
   while(m<n){
     u.randu();
     if(double(N-t)*u(0) >= double(n-m)){
@@ -162,23 +162,23 @@ arma::Col<arma::uword> sampleInt(arma::uword n, arma::uword N){
 // Values in column 1 range from 1 to nLevel1
 // Values in column 2 range from 1 to nLevel2
 // [[Rcpp::export]]
-arma::Mat<arma::uword> sampAllComb(arma::uword nLevel1, arma::uword nLevel2, 
-                                   arma::uword n){
+arma::umat sampAllComb(arma::uword nLevel1, arma::uword nLevel2, 
+                       arma::uword n){
   arma::uword N = nLevel1*nLevel2;
   arma::uword fullComb = 0;
   while(n>N){
     n -= N;
     ++fullComb;
   }
-  arma::Col<arma::uword> samples = sampleInt(n,N);
+  arma::uvec samples = sampleInt(n,N);
   // Calculate selected combinations
-  arma::Mat<arma::uword> output(n,2);
+  arma::umat output(n,2);
   for(arma::uword  i=0; i<n; ++i){
     output(i,0) = samples(i)/nLevel2;
     output(i,1) = samples(i)%nLevel2;
   }
   if(fullComb>0){
-    arma::Mat<arma::uword> tmp(N*fullComb,2);
+    arma::umat tmp(N*fullComb,2);
     arma::uword i;
     for(arma::uword j=0; j<(N*fullComb); ++j){
       i = j%N;
@@ -200,22 +200,22 @@ arma::Mat<arma::uword> sampAllComb(arma::uword nLevel1, arma::uword nLevel2,
 // Returns an integer matrix with the sampled levels for each combination
 // Returned values range from 1 to nLevel
 // [[Rcpp::export]]
-arma::Mat<arma::uword> sampHalfDialComb(arma::uword nLevel, arma::uword n){
+arma::umat sampHalfDialComb(arma::uword nLevel, arma::uword n){
   arma::uword N = nLevel*(nLevel-1)/2;
   arma::uword fullComb = 0;
   while(n>N){
     n -= N;
     ++fullComb;
   }
-  arma::Col<arma::uword> samples = sampleInt(n,N);
+  arma::uvec samples = sampleInt(n,N);
   // Calculate selected combinations
-  arma::Mat<arma::uword> output(n,2);
+  arma::umat output(n,2);
   for(arma::uword i=0; i<n; ++i){
     output(i,0) = mapRow(samples(i),nLevel);
     output(i,1) = mapCol(samples(i),nLevel);
   }
   if(fullComb>0){
-    arma::Mat<arma::uword> tmp(N*fullComb,2);
+    arma::umat tmp(N*fullComb,2);
     arma::uword i;
     for(arma::uword j=0; j<(N*fullComb); ++j){
       i = j%N;

---FILE: src/misc.h---
@@ -1,7 +1,7 @@
 #ifndef MISC_H
 #define MISC_H
 
-arma::Col<arma::uword> sampleInt(arma::uword n, arma::uword N);
+arma::uvec sampleInt(arma::uword n, arma::uword N);
 int samplePoisson(double lambda);
 
 #endif"
gaynorr,AlphaSimR,ae15c1bd050bed5d299a9fc358f2479c7f96008b,gregor_gorjanc,gregor.gorjanc@gmail.com,2018-08-21T00:06:31Z,gregor_gorjanc,gregor.gorjanc@gmail.com,2018-08-21T00:06:31Z,getIbdRecHist bugfix and somewhat simpler code,src/meiosis.cpp;tests/testthat/test-ibdRecHaplo.R,False,True,True,False,722,519,1241,"---FILE: src/meiosis.cpp---
@@ -319,134 +319,90 @@ Rcpp::List getIbdRecHist(const Rcpp::List          & recHist,
               ibdRecHist.addHist(recHistIndChrPar, ind, chr, par);
               // std::cout << recHistIndChrPar << ""\n"";
             } else {                      // Parent is not a founder and has    recHist info --> parse and combine parent and individual recombinations
-              Rcpp::List recHistParChr = recHistPar(chr);
-              arma::Mat<int> recHistParChrPar1 = recHistParChr(0);
-              arma::Mat<int> recHistParChrPar2 = recHistParChr(1);
-              arma::field<arma::Mat<int> > recHistParChrPar(2);
-              recHistParChrPar(0) = recHistParChrPar1;
-              recHistParChrPar(1) = recHistParChrPar2;
-              arma::uvec nRecSegParChrPar(2);
-              nRecSegParChrPar(0) = recHistParChrPar(0).n_rows;
-              nRecSegParChrPar(1) = recHistParChrPar(1).n_rows;
-              arma::uvec recSegPar(2);
-              int nIbdSegInd;
+              // Parent's all ancestral recombinations
+              arma::Mat<int> ibdRecHistParChrPar1 = ibdRecHist.getHist(pId, chr, 0);
+              arma::Mat<int> ibdRecHistParChrPar2 = ibdRecHist.getHist(pId, chr, 1);
+              arma::field<arma::Mat<int> > ibdRecHistParChrPar(2);
+              ibdRecHistParChrPar(0) = ibdRecHistParChrPar1;
+              ibdRecHistParChrPar(1) = ibdRecHistParChrPar2;
+              arma::uvec nIbdRecSegParChrPar(2);
+              nIbdRecSegParChrPar(0) = ibdRecHistParChrPar(0).n_rows;
+              nIbdRecSegParChrPar(1) = ibdRecHistParChrPar(1).n_rows;
+              // std::cout << ""ibdRecHistParChrPar1: "" << ibdRecHistParChrPar1 << ""\n"";
+              // std::cout << ""ibdRecHistParChrPar2: "" << ibdRecHistParChrPar2 << ""\n"";
               
-              // First parse to figure how many IBD segments are there
-              recSegPar(0) = 0;
-              recSegPar(1) = 0;
-              nIbdSegInd = 0;
-              for (int recSegInd = 0; recSegInd < nRecSegInd; ++recSegInd) {
-                int source = recHistIndChrPar(recSegInd, 0) - 1;
-                int startInd = recHistIndChrPar(recSegInd, 1);
-                int stopInd;
-                if (recSegInd == (nRecSegInd - 1)) {
-                  stopInd = nLociPerChr(chr);
+              // Find and advance the ancestral recombinations in line with the recent (parent-progeny) recombinations
+              arma::uvec ibdRecSegPar(2);
+              int nIbdSegInd;
+              arma::Mat<int> ibdRecHistIndChrPar;
+              for (int run = 0; run < 2; ++run) {
+                if (run == 0) {
+                  // std::cout << ""Count the segments\n"";
                 } else {
-                  stopInd = recHistIndChrPar(recSegInd + 1, 1) - 1;
+                  // std::cout << ""Store the segments\n"";
+                  ibdRecHistIndChrPar.set_size(nIbdSegInd, 2);
                 }
-                // std::cout << ""\n""
-                //           << ""SegInd ""     << recSegInd + 1
-                //           << "" startInd: "" << startInd
-                //           << "" stopInd: ""  << stopInd
-                //           << "" source: ""   << source + 1 << ""\n"";
-                bool loop = true;
-                while (loop & (recSegPar(source) < nRecSegParChrPar(source))) {
-                  int sourcePar = ibdRecHist.getHist(pId, chr, source)(recSegPar(source), 0);
-                  int startPar = recHistParChrPar(source)(recSegPar(source), 1);
-                  int stopPar;
-                  if (recSegPar(source) == (nRecSegParChrPar(source) - 1)) {
-                    stopPar = nLociPerChr(chr);
+                ibdRecSegPar(0) = 0;
+                ibdRecSegPar(1) = 0;
+                nIbdSegInd = 0;
+                for (int recSegInd = 0; recSegInd < nRecSegInd; ++recSegInd) {
+                  int source = recHistIndChrPar(recSegInd, 0) - 1;
+                  int startInd = recHistIndChrPar(recSegInd, 1);
+                  int stopInd;
+                  if (recSegInd == (nRecSegInd - 1)) {
+                    stopInd = nLociPerChr(chr);
                   } else {
-                    stopPar = recHistParChrPar(source)(recSegPar(source) + 1, 1) - 1;
+                    stopInd = recHistIndChrPar(recSegInd + 1, 1) - 1;
                   }
-                  // std::cout << "" recSegPar: ""  << recSegPar(source) + 1
-                  //           << "" startPar: ""   << startPar
-                  //           << "" stopPar: ""    << stopPar
-                  //           << "" sourcePar: ""  << sourcePar;
-                  if (startInd <= stopPar) {
-                    if (stopInd >= startPar) {
-                      int startIbd = std::max(startInd, startPar);
-                      nIbdSegInd += 1;
-                      // std::cout << ""  --> nIbdSegInd: ""  << nIbdSegInd
-                      //           << "" sourcePar: ""        << sourcePar
-                      //           << "" start: ""            << startIbd;
-                      if (stopInd <= stopPar) {
-                        loop = false;
-                      }
-                      if ((stopInd >= stopPar) & (stopPar < nLociPerChr(chr))) {
-                        recSegPar(source) += 1;
-                      }
+                  // std::cout << ""\n""
+                  //           << ""SegInd ""     << recSegInd + 1
+                  //           << "" startInd: "" << startInd
+                  //           << "" stopInd: ""  << stopInd
+                  //           << "" source: ""   << source + 1 << ""\n"";
+                  bool loop = true;
+                  while (loop & (ibdRecSegPar(source) < nIbdRecSegParChrPar(source))) {
+                    int sourcePar = ibdRecHistParChrPar(source)(ibdRecSegPar(source), 0);
+                    int startPar  = ibdRecHistParChrPar(source)(ibdRecSegPar(source), 1);
+                    int stopPar;
+                    if (ibdRecSegPar(source) == (nIbdRecSegParChrPar(source) - 1)) {
+                      stopPar = nLociPerChr(chr);
                     } else {
-                      loop = false;
+                      stopPar = ibdRecHistParChrPar(source)(ibdRecSegPar(source) + 1, 1) - 1;
                     }
-                  } else {
-                    recSegPar(source) += 1;
-                  }
-                  // std::cout << ""\n"";
-                }
-              }
-              // std::cout << ""nIbdSegInd: "" << nIbdSegInd << ""\n\n"";
-              
-              // Now store the IBD segments - 99% code the same as above
-              arma::Mat<int> ibdHistIndChrPar;
-              ibdHistIndChrPar.set_size(nIbdSegInd, 2);
-              recSegPar(0) = 0;
-              recSegPar(1) = 0;
-              nIbdSegInd = 0;
-              for (int recSegInd = 0; recSegInd < nRecSegInd; ++recSegInd) {
-                int source = recHistIndChrPar(recSegInd, 0) - 1;
-                int startInd = recHistIndChrPar(recSegInd, 1);
-                int stopInd;
-                if (recSegInd == (nRecSegInd - 1)) {
-                  stopInd = nLociPerChr(chr);
-                } else {
-                  stopInd = recHistIndChrPar(recSegInd + 1, 1) - 1;
-                }
-                // std::cout << ""\n""
-                //           << ""SegInd ""     << recSegInd + 1
-                //           << "" startInd: "" << startInd
-                //           << "" stopInd: ""  << stopInd
-                //           << "" source: ""   << source + 1 << ""\n"";
-                bool loop = true;
-                while (loop & (recSegPar(source) < nRecSegParChrPar(source))) {
-                  int sourcePar = ibdRecHist.getHist(pId, chr, source)(recSegPar(source), 0);
-                  int startPar = recHistParChrPar(source)(recSegPar(source), 1);
-                  int stopPar;
-                  if (recSegPar(source) == (nRecSegParChrPar(source) - 1)) {
-                    stopPar = nLociPerChr(chr);
-                  } else {
-                    stopPar = recHistParChrPar(source)(recSegPar(source) + 1, 1) - 1;
-                  }
-                  // std::cout << "" recSegPar: ""  << recSegPar(source) + 1
-                  //           << "" startPar: ""   << startPar
-                  //           << "" stopPar: ""    << stopPar
-                  //           << "" sourcePar: ""  << sourcePar;
-                  if (startInd <= stopPar) {
-                    if (stopInd >= startPar) {
-                      int startIbd = std::max(startInd, startPar);
-                      ibdHistIndChrPar(nIbdSegInd, 0) = sourcePar; // added in comparison to the above code
-                      ibdHistIndChrPar(nIbdSegInd, 1) = startIbd;  // added in comparison to the above code
-                      nIbdSegInd += 1;
-                      // std::cout << ""  --> nIbdSegInd: ""  << nIbdSegInd
-                      //           << "" sourcePar: ""        << sourcePar
-                      //           << "" start: ""            << startIbd;
-                      if (stopInd <= stopPar) {
+                    // std::cout << "" ibdRecSegPar: ""  << ibdRecSegPar(source) + 1
+                    //           << "" startPar: ""      << startPar
+                    //           << "" stopPar: ""       << stopPar
+                    //           << "" sourcePar: ""     << sourcePar;
+                    if (startInd <= stopPar) {
+                      if (stopInd >= startPar) {
+                        int startIbd = std::max(startInd, startPar);
+                        if (run == 1) {
+                          ibdRecHistIndChrPar(nIbdSegInd, 0) = sourcePar;
+                          ibdRecHistIndChrPar(nIbdSegInd, 1) = startIbd;
+                        }
+                        nIbdSegInd += 1;
+                        // std::cout << ""  --> nIbdSegInd: ""  << nIbdSegInd
+                        //           << "" sourcePar: ""        << sourcePar
+                        //           << "" start: ""            << startIbd;
+                        if (stopInd <= stopPar) {
+                          loop = false;
+                        }
+                        if ((stopInd >= stopPar) & (stopPar < nLociPerChr(chr))) {
+                          ibdRecSegPar(source) += 1;
+                        }
+                      } else {
                         loop = false;
                       }
-                      if ((stopInd >= stopPar) & (stopPar < nLociPerChr(chr))) {
-                        recSegPar(source) += 1;
-                      }
                     } else {
-                      loop = false;
+                      ibdRecSegPar(source) += 1;
                     }
-                  } else {
-                    recSegPar(source) += 1;
+                    // std::cout << ""\n"";
                   }
-                  // std::cout << ""\n"";
                 }
+                // std::cout << ""nIbdSegInd: "" << nIbdSegInd << ""\n\n"";
               }
-              // std::cout << ibdHistIndChrPar << ""\n"";
-              ibdRecHist.addHist(ibdHistIndChrPar, ind, chr, par);
+              // std::cout << ibdRecHistIndChrPar << ""\n"";
+              ibdRecHist.addHist(ibdRecHistIndChrPar, ind, chr, par);
             }
           }
         }

---FILE: tests/testthat/test-ibdRecHaplo.R---
@@ -3,257 +3,427 @@ context(""ibdRecHaplo"")
 # ---- Data ----
 
 # A simple pedigree
-pedigree = matrix(data = 0L, nrow = 7, ncol = 2)
-pedigree[5, 1:2] = c(1L, 2L)
-pedigree[6, 1:2] = c(3L, 4L)
-pedigree[7, 1:2] = c(5L, 6L)
+pedigree = matrix(data = 0L, nrow = 10, ncol = 2)
+pedigree[ 5, 1:2] = c(1L, 2L)
+pedigree[ 6, 1:2] = c(3L, 4L)
+pedigree[ 7, 1:2] = c(5L, 6L)
+pedigree[ 8, 1:2] = c(5L, 7L)
+pedigree[ 9, 1:2] = c(8L, 8L)
+pedigree[10, 1:2] = c(8L, 9L)
 
 nLociPerChr = c(300, 300)
 
 # Recombinations (as they are stored in simParam$recHist)
-recHist = vector(mode = ""list"", length = ""7"")
+recHist = vector(mode = ""list"", length = ""10"")
 # 2 chromosomes
-recHist[[5]] = recHist[[6]] = recHist[[7]] = vector(mode = ""list"", length = ""2"")
+recHist[[5]] = recHist[[6]] = recHist[[7]] = recHist[[8]] =
+  recHist[[9]] = recHist[[9]] = vector(mode = ""list"", length = ""2"")
 # 2 gametes of a chromosome
 recHist[[5]][[1]] = recHist[[5]][[2]] = 
   recHist[[6]][[1]] = recHist[[6]][[2]] =
-  recHist[[7]][[1]] = recHist[[7]][[2]] = vector(mode = ""list"", length = ""2"")
-# ind 5
-recHist[[5]][[1]][[1]] = matrix(data = 0L, nrow = 5, ncol = 2)
-recHist[[5]][[1]][[1]][1, 1:2] = c(1L, 1L)
-recHist[[5]][[1]][[1]][2, 1:2] = c(2L, 10L)
-recHist[[5]][[1]][[1]][3, 1:2] = c(1L, 50L)
-recHist[[5]][[1]][[1]][4, 1:2] = c(2L, 100L)
-recHist[[5]][[1]][[1]][5, 1:2] = c(1L, 150L)
-recHist[[5]][[1]][[2]] = matrix(data = 0L, nrow = 5, ncol = 2)
-recHist[[5]][[1]][[2]][1, 1:2] = c(2L, 1L)
-recHist[[5]][[1]][[2]][2, 1:2] = c(1L, 5L)
-recHist[[5]][[1]][[2]][3, 1:2] = c(2L, 10L)
-recHist[[5]][[1]][[2]][4, 1:2] = c(1L, 15L)
-recHist[[5]][[1]][[2]][5, 1:2] = c(2L, 20L)
-recHist[[5]][[2]][[1]] = matrix(data = 0L, nrow = 10, ncol = 2)
-recHist[[5]][[2]][[1]][ 1, 1:2] = c(1L, 1L)
-recHist[[5]][[2]][[1]][ 2, 1:2] = c(2L, 2L)
-recHist[[5]][[2]][[1]][ 3, 1:2] = c(1L, 3L)
-recHist[[5]][[2]][[1]][ 4, 1:2] = c(2L, 4L)
-recHist[[5]][[2]][[1]][ 5, 1:2] = c(1L, 5L)
-recHist[[5]][[2]][[1]][ 6, 1:2] = c(2L, 6L)
-recHist[[5]][[2]][[1]][ 7, 1:2] = c(1L, 7L)
-recHist[[5]][[2]][[1]][ 8, 1:2] = c(2L, 8L)
-recHist[[5]][[2]][[1]][ 9, 1:2] = c(1L, 9L)
-recHist[[5]][[2]][[1]][10, 1:2] = c(2L, 10L)
-recHist[[5]][[2]][[2]] = matrix(data = 0L, nrow = 10, ncol = 2)
-recHist[[5]][[2]][[2]][ 1, 1:2] = c(2L, 1L)
-recHist[[5]][[2]][[2]][ 2, 1:2] = c(1L, 3L)
-recHist[[5]][[2]][[2]][ 3, 1:2] = c(2L, 5L)
-recHist[[5]][[2]][[2]][ 4, 1:2] = c(1L, 7L)
-recHist[[5]][[2]][[2]][ 5, 1:2] = c(2L, 9L)
-recHist[[5]][[2]][[2]][ 6, 1:2] = c(1L, 11L)
-recHist[[5]][[2]][[2]][ 7, 1:2] = c(2L, 13L)
-recHist[[5]][[2]][[2]][ 8, 1:2] = c(1L, 15L)
-recHist[[5]][[2]][[2]][ 9, 1:2] = c(2L, 17L)
-recHist[[5]][[2]][[2]][10, 1:2] = c(1L, 19L)
-# ind 6
-recHist[[6]][[1]][[1]] = matrix(data = 0L, nrow = 4, ncol = 2)
-recHist[[6]][[1]][[1]][1, 1:2] = c(2L, 1L)
-recHist[[6]][[1]][[1]][2, 1:2] = c(1L, 150L)
-recHist[[6]][[1]][[1]][3, 1:2] = c(2L, 200L)
-recHist[[6]][[1]][[1]][4, 1:2] = c(1L, 250L)
-recHist[[6]][[1]][[2]] = matrix(data = 0L, nrow = 5, ncol = 2)
-recHist[[6]][[1]][[2]][1, 1:2] = c(2L, 1L)
-recHist[[6]][[1]][[2]][2, 1:2] = c(1L, 9L)
-recHist[[6]][[1]][[2]][3, 1:2] = c(2L, 11L)
-recHist[[6]][[1]][[2]][4, 1:2] = c(1L, 50L)
-recHist[[6]][[1]][[2]][5, 1:2] = c(2L, 100L)
-recHist[[6]][[2]][[1]] = matrix(data = 0L, nrow = 11, ncol = 2)
-recHist[[6]][[2]][[1]][ 1, 1:2] = c(1L, 1L)
-recHist[[6]][[2]][[1]][ 2, 1:2] = c(2L, 10L)
-recHist[[6]][[2]][[1]][ 3, 1:2] = c(1L, 20L)
-recHist[[6]][[2]][[1]][ 4, 1:2] = c(2L, 30L)
-recHist[[6]][[2]][[1]][ 5, 1:2] = c(1L, 40L)
-recHist[[6]][[2]][[1]][ 6, 1:2] = c(2L, 50L)
-recHist[[6]][[2]][[1]][ 7, 1:2] = c(1L, 60L)
-recHist[[6]][[2]][[1]][ 8, 1:2] = c(2L, 70L)
-recHist[[6]][[2]][[1]][ 9, 1:2] = c(1L, 80L)
-recHist[[6]][[2]][[1]][10, 1:2] = c(2L, 90L)
-recHist[[6]][[2]][[1]][11, 1:2] = c(1L, 100L)
-recHist[[6]][[2]][[2]] = matrix(data = 0L, nrow = 6, ncol = 2)
-recHist[[6]][[2]][[2]][1, 1:2] = c(2L, 1L)
-recHist[[6]][[2]][[2]][2, 1:2] = c(1L, 50L)
-recHist[[6]][[2]][[2]][3, 1:2] = c(2L, 100L)
-recHist[[6]][[2]][[2]][4, 1:2] = c(1L, 150L)
-recHist[[6]][[2]][[2]][5, 1:2] = c(2L, 200L)
-recHist[[6]][[2]][[2]][6, 1:2] = c(1L, 250L)
-# ind 7
-recHist[[7]][[1]][[1]] = matrix(data = 0L, nrow = 6, ncol = 2)
-recHist[[7]][[1]][[1]][1, 1:2] = c(2L, 1L)
-recHist[[7]][[1]][[1]][2, 1:2] = c(1L, 6L)
-recHist[[7]][[1]][[1]][3, 1:2] = c(2L, 10L)
-recHist[[7]][[1]][[1]][4, 1:2] = c(1L, 45L)
-recHist[[7]][[1]][[1]][5, 1:2] = c(2L, 110L)
-recHist[[7]][[1]][[1]][6, 1:2] = c(1L, 140L)
-recHist[[7]][[1]][[2]] = matrix(data = 0L, nrow = 1, ncol = 2)
-recHist[[7]][[1]][[2]][1, 1:2] = c(2L, 1L)
-recHist[[7]][[2]][[1]] = matrix(data = 0L, nrow = 6, ncol = 2)
-recHist[[7]][[2]][[1]][1, 1:2] = c(2L, 1L)
-recHist[[7]][[2]][[1]][2, 1:2] = c(1L, 6L)
-recHist[[7]][[2]][[1]][3, 1:2] = c(2L, 10L)
-recHist[[7]][[2]][[1]][4, 1:2] = c(1L, 45L)
-recHist[[7]][[2]][[1]][5, 1:2] = c(2L, 110L)
-recHist[[7]][[2]][[1]][6, 1:2] = c(1L, 140L)
-recHist[[7]][[2]][[2]] = matrix(data = 0L, nrow = 7, ncol = 2)
-recHist[[7]][[2]][[2]][1, 1:2] = c(1L, 1L)
-recHist[[7]][[2]][[2]][2, 1:2] = c(2L, 50L)
-recHist[[7]][[2]][[2]][3, 1:2] = c(1L, 75L)
-recHist[[7]][[2]][[2]][4, 1:2] = c(2L, 99L)
-recHist[[7]][[2]][[2]][5, 1:2] = c(1L, 101L)
-recHist[[7]][[2]][[2]][6, 1:2] = c(2L, 149L)
-recHist[[7]][[2]][[2]][7, 1:2] = c(1L, 151L)
+  recHist[[7]][[1]] = recHist[[7]][[2]] = 
+  recHist[[8]][[1]] = recHist[[8]][[2]] = 
+  recHist[[9]][[1]] = recHist[[9]][[2]] = 
+  recHist[[10]][[1]] = recHist[[10]][[2]] = vector(mode = ""list"", length = ""2"")
+
+ind = 5
+chr = 1; par = 1
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 5, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(1L, 1L)
+recHist[[ind]][[chr]][[par]][2, 1:2] = c(2L, 10L)
+recHist[[ind]][[chr]][[par]][3, 1:2] = c(1L, 50L)
+recHist[[ind]][[chr]][[par]][4, 1:2] = c(2L, 100L)
+recHist[[ind]][[chr]][[par]][5, 1:2] = c(1L, 150L)
+chr = 1; par = 2
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 5, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(2L, 1L)
+recHist[[ind]][[chr]][[par]][2, 1:2] = c(1L, 5L)
+recHist[[ind]][[chr]][[par]][3, 1:2] = c(2L, 10L)
+recHist[[ind]][[chr]][[par]][4, 1:2] = c(1L, 15L)
+recHist[[ind]][[chr]][[par]][5, 1:2] = c(2L, 20L)
+chr = 2; par = 1
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 10, ncol = 2)
+recHist[[ind]][[chr]][[par]][ 1, 1:2] = c(1L, 1L)
+recHist[[ind]][[chr]][[par]][ 2, 1:2] = c(2L, 2L)
+recHist[[ind]][[chr]][[par]][ 3, 1:2] = c(1L, 3L)
+recHist[[ind]][[chr]][[par]][ 4, 1:2] = c(2L, 4L)
+recHist[[ind]][[chr]][[par]][ 5, 1:2] = c(1L, 5L)
+recHist[[ind]][[chr]][[par]][ 6, 1:2] = c(2L, 6L)
+recHist[[ind]][[chr]][[par]][ 7, 1:2] = c(1L, 7L)
+recHist[[ind]][[chr]][[par]][ 8, 1:2] = c(2L, 8L)
+recHist[[ind]][[chr]][[par]][ 9, 1:2] = c(1L, 9L)
+recHist[[ind]][[chr]][[par]][10, 1:2] = c(2L, 10L)
+chr = 2; par = 2
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 10, ncol = 2)
+recHist[[ind]][[chr]][[par]][ 1, 1:2] = c(2L, 1L)
+recHist[[ind]][[chr]][[par]][ 2, 1:2] = c(1L, 3L)
+recHist[[ind]][[chr]][[par]][ 3, 1:2] = c(2L, 5L)
+recHist[[ind]][[chr]][[par]][ 4, 1:2] = c(1L, 7L)
+recHist[[ind]][[chr]][[par]][ 5, 1:2] = c(2L, 9L)
+recHist[[ind]][[chr]][[par]][ 6, 1:2] = c(1L, 11L)
+recHist[[ind]][[chr]][[par]][ 7, 1:2] = c(2L, 13L)
+recHist[[ind]][[chr]][[par]][ 8, 1:2] = c(1L, 15L)
+recHist[[ind]][[chr]][[par]][ 9, 1:2] = c(2L, 17L)
+recHist[[ind]][[chr]][[par]][10, 1:2] = c(1L, 19L)
+
+ind = 6
+chr = 1; par = 1
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 4, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(2L, 1L)
+recHist[[ind]][[chr]][[par]][2, 1:2] = c(1L, 150L)
+recHist[[ind]][[chr]][[par]][3, 1:2] = c(2L, 200L)
+recHist[[ind]][[chr]][[par]][4, 1:2] = c(1L, 250L)
+chr = 1; par = 2
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 5, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(2L, 1L)
+recHist[[ind]][[chr]][[par]][2, 1:2] = c(1L, 9L)
+recHist[[ind]][[chr]][[par]][3, 1:2] = c(2L, 11L)
+recHist[[ind]][[chr]][[par]][4, 1:2] = c(1L, 50L)
+recHist[[ind]][[chr]][[par]][5, 1:2] = c(2L, 100L)
+chr = 2; par = 1
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 11, ncol = 2)
+recHist[[ind]][[chr]][[par]][ 1, 1:2] = c(1L, 1L)
+recHist[[ind]][[chr]][[par]][ 2, 1:2] = c(2L, 10L)
+recHist[[ind]][[chr]][[par]][ 3, 1:2] = c(1L, 20L)
+recHist[[ind]][[chr]][[par]][ 4, 1:2] = c(2L, 30L)
+recHist[[ind]][[chr]][[par]][ 5, 1:2] = c(1L, 40L)
+recHist[[ind]][[chr]][[par]][ 6, 1:2] = c(2L, 50L)
+recHist[[ind]][[chr]][[par]][ 7, 1:2] = c(1L, 60L)
+recHist[[ind]][[chr]][[par]][ 8, 1:2] = c(2L, 70L)
+recHist[[ind]][[chr]][[par]][ 9, 1:2] = c(1L, 80L)
+recHist[[ind]][[chr]][[par]][10, 1:2] = c(2L, 90L)
+recHist[[ind]][[chr]][[par]][11, 1:2] = c(1L, 100L)
+chr = 2; par = 2
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 6, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(2L, 1L)
+recHist[[ind]][[chr]][[par]][2, 1:2] = c(1L, 50L)
+recHist[[ind]][[chr]][[par]][3, 1:2] = c(2L, 100L)
+recHist[[ind]][[chr]][[par]][4, 1:2] = c(1L, 150L)
+recHist[[ind]][[chr]][[par]][5, 1:2] = c(2L, 200L)
+recHist[[ind]][[chr]][[par]][6, 1:2] = c(1L, 250L)
+
+ind = 7
+chr = 1; par = 1
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 6, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(2L, 1L)
+recHist[[ind]][[chr]][[par]][2, 1:2] = c(1L, 6L)
+recHist[[ind]][[chr]][[par]][3, 1:2] = c(2L, 10L)
+recHist[[ind]][[chr]][[par]][4, 1:2] = c(1L, 45L)
+recHist[[ind]][[chr]][[par]][5, 1:2] = c(2L, 110L)
+recHist[[ind]][[chr]][[par]][6, 1:2] = c(1L, 140L)
+chr = 1; par = 2
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 1, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(2L, 1L)
+chr = 2; par = 1
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 6, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(2L, 1L)
+recHist[[ind]][[chr]][[par]][2, 1:2] = c(1L, 6L)
+recHist[[ind]][[chr]][[par]][3, 1:2] = c(2L, 10L)
+recHist[[ind]][[chr]][[par]][4, 1:2] = c(1L, 45L)
+recHist[[ind]][[chr]][[par]][5, 1:2] = c(2L, 110L)
+recHist[[ind]][[chr]][[par]][6, 1:2] = c(1L, 140L)
+chr = 2; par = 2
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 7, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(1L, 1L)
+recHist[[ind]][[chr]][[par]][2, 1:2] = c(2L, 50L)
+recHist[[ind]][[chr]][[par]][3, 1:2] = c(1L, 75L)
+recHist[[ind]][[chr]][[par]][4, 1:2] = c(2L, 99L)
+recHist[[ind]][[chr]][[par]][5, 1:2] = c(1L, 101L)
+recHist[[ind]][[chr]][[par]][6, 1:2] = c(2L, 149L)
+recHist[[ind]][[chr]][[par]][7, 1:2] = c(1L, 151L)
+
+ind = 8
+chr = 1; par = 1
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 1, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(2L, 1L)
+chr = 1; par = 2
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 1, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(2L, 1L)
+chr = 2; par = 1
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 1, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(2L, 1L)
+chr = 2; par = 2
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 1, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(2L, 1L)
+
+ind = 9
+chr = 1; par = 1
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 1, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(1L, 1L)
+chr = 1; par = 2
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 1, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(2L, 1L)
+chr = 2; par = 1
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 1, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(1L, 1L)
+chr = 2; par = 2
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 1, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(2L, 1L)
+
+ind = 10
+chr = 1; par = 1
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 2, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(1L, 1L)
+recHist[[ind]][[chr]][[par]][2, 1:2] = c(2L, 50L)
+chr = 1; par = 2
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 2, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(2L, 1L)
+recHist[[ind]][[chr]][[par]][2, 1:2] = c(1L, 100L)
+chr = 2; par = 1
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 2, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(1L, 1L)
+recHist[[ind]][[chr]][[par]][2, 1:2] = c(2L, 50L)
+chr = 2; par = 2
+recHist[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 2, ncol = 2)
+recHist[[ind]][[chr]][[par]][1, 1:2] = c(2L, 1L)
+recHist[[ind]][[chr]][[par]][2, 1:2] = c(1L, 100L)
 
 # ---- getIbdRecHist ----
 
 test_that(""getIbdRecHist converts recHist & pedigree to ibdRecHist correctly"", {
   # IBD recombinations (since the base generation)
   expect = recHist
-  # ind 1
-  expect[[1]][[1]][[1]] = matrix(data = c(1L, 1L), nrow = 1, ncol = 2)
-  expect[[1]][[1]][[2]] = matrix(data = c(2L, 1L), nrow = 1, ncol = 2)
-  expect[[1]][[2]] = expect[[1]][[1]]
-  # ind 2
-  expect[[2]][[1]][[1]] = matrix(data = c(3L, 1L), nrow = 1, ncol = 2)
-  expect[[2]][[1]][[2]] = matrix(data = c(4L, 1L), nrow = 1, ncol = 2)
-  expect[[2]][[2]] = expect[[2]][[1]]
-  # ind 3
-  expect[[3]][[1]][[1]] = matrix(data = c(5L, 1L), nrow = 1, ncol = 2)
-  expect[[3]][[1]][[2]] = matrix(data = c(6L, 1L), nrow = 1, ncol = 2)
-  expect[[3]][[2]] = expect[[3]][[1]]
-  # ind 4
-  expect[[4]][[1]][[1]] = matrix(data = c(7L, 1L), nrow = 1, ncol = 2)
-  expect[[4]][[1]][[2]] = matrix(data = c(8L, 1L), nrow = 1, ncol = 2)
-  expect[[4]][[2]] = expect[[4]][[1]]
-  # ind 5
-  expect[[5]][[1]][[1]] = matrix(data = 0L, nrow = 5, ncol = 2)
-  expect[[5]][[1]][[1]][1, 1:2] = c(1L, 1L)
-  expect[[5]][[1]][[1]][2, 1:2] = c(2L, 10L)
-  expect[[5]][[1]][[1]][3, 1:2] = c(1L, 50L)
-  expect[[5]][[1]][[1]][4, 1:2] = c(2L, 100L)
-  expect[[5]][[1]][[1]][5, 1:2] = c(1L, 150L)
-  expect[[5]][[1]][[2]] = matrix(data = 0L, nrow = 5, ncol = 2)
-  expect[[5]][[1]][[2]][1, 1:2] = c(4L, 1L)
-  expect[[5]][[1]][[2]][2, 1:2] = c(3L, 5L)
-  expect[[5]][[1]][[2]][3, 1:2] = c(4L, 10L)
-  expect[[5]][[1]][[2]][4, 1:2] = c(3L, 15L)
-  expect[[5]][[1]][[2]][5, 1:2] = c(4L, 20L)
-  expect[[5]][[2]][[1]] = matrix(data = 0L, nrow = 10, ncol = 2)
-  expect[[5]][[2]][[1]][ 1, 1:2] = c(1L, 1L)
-  expect[[5]][[2]][[1]][ 2, 1:2] = c(2L, 2L)
-  expect[[5]][[2]][[1]][ 3, 1:2] = c(1L, 3L)
-  expect[[5]][[2]][[1]][ 4, 1:2] = c(2L, 4L)
-  expect[[5]][[2]][[1]][ 5, 1:2] = c(1L, 5L)
-  expect[[5]][[2]][[1]][ 6, 1:2] = c(2L, 6L)
-  expect[[5]][[2]][[1]][ 7, 1:2] = c(1L, 7L)
-  expect[[5]][[2]][[1]][ 8, 1:2] = c(2L, 8L)
-  expect[[5]][[2]][[1]][ 9, 1:2] = c(1L, 9L)
-  expect[[5]][[2]][[1]][10, 1:2] = c(2L, 10L)
-  expect[[5]][[2]][[2]] = matrix(data = 0L, nrow = 10, ncol = 2)
-  expect[[5]][[2]][[2]][ 1, 1:2] = c(4L, 1L)
-  expect[[5]][[2]][[2]][ 2, 1:2] = c(3L, 3L)
-  expect[[5]][[2]][[2]][ 3, 1:2] = c(4L, 5L)
-  expect[[5]][[2]][[2]][ 4, 1:2] = c(3L, 7L)
-  expect[[5]][[2]][[2]][ 5, 1:2] = c(4L, 9L)
-  expect[[5]][[2]][[2]][ 6, 1:2] = c(3L, 11L)
-  expect[[5]][[2]][[2]][ 7, 1:2] = c(4L, 13L)
-  expect[[5]][[2]][[2]][ 8, 1:2] = c(3L, 15L)
-  expect[[5]][[2]][[2]][ 9, 1:2] = c(4L, 17L)
-  expect[[5]][[2]][[2]][10, 1:2] = c(3L, 19L)
-  # ind 6
-  expect[[6]][[1]][[1]] = matrix(data = 0L, nrow = 4, ncol = 2)
-  expect[[6]][[1]][[1]][1, 1:2] = c(6L, 1L)
-  expect[[6]][[1]][[1]][2, 1:2] = c(5L, 150L)
-  expect[[6]][[1]][[1]][3, 1:2] = c(6L, 200L)
-  expect[[6]][[1]][[1]][4, 1:2] = c(5L, 250L)
-  expect[[6]][[1]][[2]] = matrix(data = 0L, nrow = 5, ncol = 2)
-  expect[[6]][[1]][[2]][1, 1:2] = c(8L, 1L)
-  expect[[6]][[1]][[2]][2, 1:2] = c(7L, 9L)
-  expect[[6]][[1]][[2]][3, 1:2] = c(8L, 11L)
-  expect[[6]][[1]][[2]][4, 1:2] = c(7L, 50L)
-  expect[[6]][[1]][[2]][5, 1:2] = c(8L, 100L)
-  expect[[6]][[2]][[1]] = matrix(data = 0L, nrow = 11, ncol = 2)
-  expect[[6]][[2]][[1]][ 1, 1:2] = c(5L, 1L)
-  expect[[6]][[2]][[1]][ 2, 1:2] = c(6L, 10L)
-  expect[[6]][[2]][[1]][ 3, 1:2] = c(5L, 20L)
-  expect[[6]][[2]][[1]][ 4, 1:2] = c(6L, 30L)
-  expect[[6]][[2]][[1]][ 5, 1:2] = c(5L, 40L)
-  expect[[6]][[2]][[1]][ 6, 1:2] = c(6L, 50L)
-  expect[[6]][[2]][[1]][ 7, 1:2] = c(5L, 60L)
-  expect[[6]][[2]][[1]][ 8, 1:2] = c(6L, 70L)
-  expect[[6]][[2]][[1]][ 9, 1:2] = c(5L, 80L)
-  expect[[6]][[2]][[1]][10, 1:2] = c(6L, 90L)
-  expect[[6]][[2]][[1]][11, 1:2] = c(5L, 100L)
-  expect[[6]][[2]][[2]] = matrix(data = 0L, nrow = 6, ncol = 2)
-  expect[[6]][[2]][[2]][1, 1:2] = c(8L, 1L)
-  expect[[6]][[2]][[2]][2, 1:2] = c(7L, 50L)
-  expect[[6]][[2]][[2]][3, 1:2] = c(8L, 100L)
-  expect[[6]][[2]][[2]][4, 1:2] = c(7L, 150L)
-  expect[[6]][[2]][[2]][5, 1:2] = c(8L, 200L)
-  expect[[6]][[2]][[2]][6, 1:2] = c(7L, 250L)
-  # ind 7
-  expect[[7]][[1]][[1]] = matrix(data = 0L, nrow = 12, ncol = 2)
-  expect[[7]][[1]][[1]][ 1, 1:2] = c(4L, 1L)
-  expect[[7]][[1]][[1]][ 2, 1:2] = c(3L, 5L)
-  expect[[7]][[1]][[1]][ 3, 1:2] = c(1L, 6L)
-  expect[[7]][[1]][[1]][ 4, 1:2] = c(4L, 10L)
-  expect[[7]][[1]][[1]][ 5, 1:2] = c(3L, 15L)
-  expect[[7]][[1]][[1]][ 6, 1:2] = c(4L, 20L)
-  expect[[7]][[1]][[1]][ 7, 1:2] = c(2L, 45L)
-  expect[[7]][[1]][[1]][ 8, 1:2] = c(1L, 50L)
-  expect[[7]][[1]][[1]][ 9, 1:2] = c(2L, 100L)
-  expect[[7]][[1]][[1]][10, 1:2] = c(4L, 110L)
-  expect[[7]][[1]][[1]][11, 1:2] = c(2L, 140L)
-  expect[[7]][[1]][[1]][12, 1:2] = c(1L, 150L)
-  expect[[7]][[1]][[2]] = matrix(data = 0L, nrow = 5, ncol = 2)
-  expect[[7]][[1]][[2]][1, 1:2] = c(8L, 1L)
-  expect[[7]][[1]][[2]][2, 1:2] = c(7L, 9L)
-  expect[[7]][[1]][[2]][3, 1:2] = c(8L, 11L)
-  expect[[7]][[1]][[2]][4, 1:2] = c(7L, 50L)
-  expect[[7]][[1]][[2]][5, 1:2] = c(8L, 100L)
-  expect[[7]][[2]][[1]] = matrix(data = 0L, nrow = 16, ncol = 2)
-  expect[[7]][[2]][[1]][ 1, 1:2] = c(4L, 1L)
-  expect[[7]][[2]][[1]][ 2, 1:2] = c(3L, 3L)
-  expect[[7]][[2]][[1]][ 3, 1:2] = c(4L, 5L)
-  expect[[7]][[2]][[1]][ 4, 1:2] = c(2L, 6L)
-  expect[[7]][[2]][[1]][ 5, 1:2] = c(1L, 7L)
-  expect[[7]][[2]][[1]][ 6, 1:2] = c(2L, 8L)
-  expect[[7]][[2]][[1]][ 7, 1:2] = c(1L, 9L)
-  expect[[7]][[2]][[1]][ 8, 1:2] = c(4L, 10L)
-  expect[[7]][[2]][[1]][ 9, 1:2] = c(3L, 11L)
-  expect[[7]][[2]][[1]][10, 1:2] = c(4L, 13L)
-  expect[[7]][[2]][[1]][11, 1:2] = c(3L, 15L)
-  expect[[7]][[2]][[1]][12, 1:2] = c(4L, 17L)  
-  expect[[7]][[2]][[1]][13, 1:2] = c(3L, 19L)  
-  expect[[7]][[2]][[1]][14, 1:2] = c(2L, 45L)  
-  expect[[7]][[2]][[1]][15, 1:2] = c(3L, 110L)  
-  expect[[7]][[2]][[1]][16, 1:2] = c(2L, 140L)  
-  expect[[7]][[2]][[2]] = matrix(data = 0L, nrow = 15, ncol = 2)
-  expect[[7]][[2]][[2]][ 1, 1:2] = c(5L, 1L)
-  expect[[7]][[2]][[2]][ 2, 1:2] = c(6L, 10L)
-  expect[[7]][[2]][[2]][ 3, 1:2] = c(5L, 20L)
-  expect[[7]][[2]][[2]][ 4, 1:2] = c(6L, 30L)
-  expect[[7]][[2]][[2]][ 5, 1:2] = c(5L, 40L)
-  expect[[7]][[2]][[2]][ 6, 1:2] = c(7L, 50L)
-  expect[[7]][[2]][[2]][ 7, 1:2] = c(6L, 75L)
-  expect[[7]][[2]][[2]][ 8, 1:2] = c(5L, 80L)
-  expect[[7]][[2]][[2]][ 9, 1:2] = c(6L, 90L)
-  expect[[7]][[2]][[2]][10, 1:2] = c(7L, 99L)
-  expect[[7]][[2]][[2]][11, 1:2] = c(8L, 100L)
-  expect[[7]][[2]][[2]][12, 1:2] = c(5L, 101L)  
-  expect[[7]][[2]][[2]][13, 1:2] = c(8L, 149L)  
-  expect[[7]][[2]][[2]][14, 1:2] = c(7L, 150L)  
-  expect[[7]][[2]][[2]][15, 1:2] = c(5L, 151L)  
+  
+  ind = 1
+  chr = 1; par = 1
+  expect[[ind]][[chr]][[par]] = matrix(data = c(1L, 1L), nrow = 1, ncol = 2)
+  chr = 1; par = 2
+  expect[[ind]][[chr]][[par]] = matrix(data = c(2L, 1L), nrow = 1, ncol = 2)
+  expect[[ind]][[2]] = expect[[ind]][[1]]
+  
+  ind = 2
+  chr = 1; par = 1
+  expect[[ind]][[chr]][[par]] = matrix(data = c(3L, 1L), nrow = 1, ncol = 2)
+  chr = 1; par = 2
+  expect[[ind]][[chr]][[par]] = matrix(data = c(4L, 1L), nrow = 1, ncol = 2)
+  expect[[ind]][[2]] = expect[[ind]][[1]]
+  
+  ind = 3
+  chr = 1; par = 1
+  expect[[ind]][[chr]][[par]] = matrix(data = c(5L, 1L), nrow = 1, ncol = 2)
+  chr = 1; par = 2
+  expect[[ind]][[chr]][[par]] = matrix(data = c(6L, 1L), nrow = 1, ncol = 2)
+  expect[[ind]][[2]] = expect[[ind]][[1]]
+  
+  ind = 4
+  chr = 1; par = 1
+  expect[[ind]][[chr]][[par]] = matrix(data = c(7L, 1L), nrow = 1, ncol = 2)
+  chr = 1; par = 2
+  expect[[ind]][[chr]][[par]] = matrix(data = c(8L, 1L), nrow = 1, ncol = 2)
+  expect[[ind]][[2]] = expect[[ind]][[1]]
+  
+  ind = 5
+  chr = 1; par = 1
+  expect[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 5, ncol = 2)
+  expect[[ind]][[chr]][[par]][1, 1:2] = c(1L, 1L)
+  expect[[ind]][[chr]][[par]][2, 1:2] = c(2L, 10L)
+  expect[[ind]][[chr]][[par]][3, 1:2] = c(1L, 50L)
+  expect[[ind]][[chr]][[par]][4, 1:2] = c(2L, 100L)
+  expect[[ind]][[chr]][[par]][5, 1:2] = c(1L, 150L)
+  chr = 1; par = 2
+  expect[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 5, ncol = 2)
+  expect[[ind]][[chr]][[par]][1, 1:2] = c(4L, 1L)
+  expect[[ind]][[chr]][[par]][2, 1:2] = c(3L, 5L)
+  expect[[ind]][[chr]][[par]][3, 1:2] = c(4L, 10L)
+  expect[[ind]][[chr]][[par]][4, 1:2] = c(3L, 15L)
+  expect[[ind]][[chr]][[par]][5, 1:2] = c(4L, 20L)
+  chr = 2; par = 1
+  expect[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 10, ncol = 2)
+  expect[[ind]][[chr]][[par]][ 1, 1:2] = c(1L, 1L)
+  expect[[ind]][[chr]][[par]][ 2, 1:2] = c(2L, 2L)
+  expect[[ind]][[chr]][[par]][ 3, 1:2] = c(1L, 3L)
+  expect[[ind]][[chr]][[par]][ 4, 1:2] = c(2L, 4L)
+  expect[[ind]][[chr]][[par]][ 5, 1:2] = c(1L, 5L)
+  expect[[ind]][[chr]][[par]][ 6, 1:2] = c(2L, 6L)
+  expect[[ind]][[chr]][[par]][ 7, 1:2] = c(1L, 7L)
+  expect[[ind]][[chr]][[par]][ 8, 1:2] = c(2L, 8L)
+  expect[[ind]][[chr]][[par]][ 9, 1:2] = c(1L, 9L)
+  expect[[ind]][[chr]][[par]][10, 1:2] = c(2L, 10L)
+  chr = 2; par = 2
+  expect[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 10, ncol = 2)
+  expect[[ind]][[chr]][[par]][ 1, 1:2] = c(4L, 1L)
+  expect[[ind]][[chr]][[par]][ 2, 1:2] = c(3L, 3L)
+  expect[[ind]][[chr]][[par]][ 3, 1:2] = c(4L, 5L)
+  expect[[ind]][[chr]][[par]][ 4, 1:2] = c(3L, 7L)
+  expect[[ind]][[chr]][[par]][ 5, 1:2] = c(4L, 9L)
+  expect[[ind]][[chr]][[par]][ 6, 1:2] = c(3L, 11L)
+  expect[[ind]][[chr]][[par]][ 7, 1:2] = c(4L, 13L)
+  expect[[ind]][[chr]][[par]][ 8, 1:2] = c(3L, 15L)
+  expect[[ind]][[chr]][[par]][ 9, 1:2] = c(4L, 17L)
+  expect[[ind]][[chr]][[par]][10, 1:2] = c(3L, 19L)
+  
+  ind = 6
+  chr = 1; par = 1
+  expect[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 4, ncol = 2)
+  expect[[ind]][[chr]][[par]][1, 1:2] = c(6L, 1L)
+  expect[[ind]][[chr]][[par]][2, 1:2] = c(5L, 150L)
+  expect[[ind]][[chr]][[par]][3, 1:2] = c(6L, 200L)
+  expect[[ind]][[chr]][[par]][4, 1:2] = c(5L, 250L)
+  chr = 1; par = 2
+  expect[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 5, ncol = 2)
+  expect[[ind]][[chr]][[par]][1, 1:2] = c(8L, 1L)
+  expect[[ind]][[chr]][[par]][2, 1:2] = c(7L, 9L)
+  expect[[ind]][[chr]][[par]][3, 1:2] = c(8L, 11L)
+  expect[[ind]][[chr]][[par]][4, 1:2] = c(7L, 50L)
+  expect[[ind]][[chr]][[par]][5, 1:2] = c(8L, 100L)
+  chr = 2; par = 1
+  expect[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 11, ncol = 2)
+  expect[[ind]][[chr]][[par]][ 1, 1:2] = c(5L, 1L)
+  expect[[ind]][[chr]][[par]][ 2, 1:2] = c(6L, 10L)
+  expect[[ind]][[chr]][[par]][ 3, 1:2] = c(5L, 20L)
+  expect[[ind]][[chr]][[par]][ 4, 1:2] = c(6L, 30L)
+  expect[[ind]][[chr]][[par]][ 5, 1:2] = c(5L, 40L)
+  expect[[ind]][[chr]][[par]][ 6, 1:2] = c(6L, 50L)
+  expect[[ind]][[chr]][[par]][ 7, 1:2] = c(5L, 60L)
+  expect[[ind]][[chr]][[par]][ 8, 1:2] = c(6L, 70L)
+  expect[[ind]][[chr]][[par]][ 9, 1:2] = c(5L, 80L)
+  expect[[ind]][[chr]][[par]][10, 1:2] = c(6L, 90L)
+  expect[[ind]][[chr]][[par]][11, 1:2] = c(5L, 100L)
+  chr = 2; par = 2
+  expect[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 6, ncol = 2)
+  expect[[ind]][[chr]][[par]][1, 1:2] = c(8L, 1L)
+  expect[[ind]][[chr]][[par]][2, 1:2] = c(7L, 50L)
+  expect[[ind]][[chr]][[par]][3, 1:2] = c(8L, 100L)
+  expect[[ind]][[chr]][[par]][4, 1:2] = c(7L, 150L)
+  expect[[ind]][[chr]][[par]][5, 1:2] = c(8L, 200L)
+  expect[[ind]][[chr]][[par]][6, 1:2] = c(7L, 250L)
+  
+  ind = 7
+  chr = 1; par = 1
+  expect[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 12, ncol = 2)
+  expect[[ind]][[chr]][[par]][ 1, 1:2] = c(4L, 1L)
+  expect[[ind]][[chr]][[par]][ 2, 1:2] = c(3L, 5L)
+  expect[[ind]][[chr]][[par]][ 3, 1:2] = c(1L, 6L)
+  expect[[ind]][[chr]][[par]][ 4, 1:2] = c(4L, 10L)
+  expect[[ind]][[chr]][[par]][ 5, 1:2] = c(3L, 15L)
+  expect[[ind]][[chr]][[par]][ 6, 1:2] = c(4L, 20L)
+  expect[[ind]][[chr]][[par]][ 7, 1:2] = c(2L, 45L)
+  expect[[ind]][[chr]][[par]][ 8, 1:2] = c(1L, 50L)
+  expect[[ind]][[chr]][[par]][ 9, 1:2] = c(2L, 100L)
+  expect[[ind]][[chr]][[par]][10, 1:2] = c(4L, 110L)
+  expect[[ind]][[chr]][[par]][11, 1:2] = c(2L, 140L)
+  expect[[ind]][[chr]][[par]][12, 1:2] = c(1L, 150L)
+  chr = 1; par = 2
+  expect[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 5, ncol = 2)
+  expect[[ind]][[chr]][[par]][1, 1:2] = c(8L, 1L)
+  expect[[ind]][[chr]][[par]][2, 1:2] = c(7L, 9L)
+  expect[[ind]][[chr]][[par]][3, 1:2] = c(8L, 11L)
+  expect[[ind]][[chr]][[par]][4, 1:2] = c(7L, 50L)
+  expect[[ind]][[chr]][[par]][5, 1:2] = c(8L, 100L)
+  chr = 2; par = 1
+  expect[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 16, ncol = 2)
+  expect[[ind]][[chr]][[par]][ 1, 1:2] = c(4L, 1L)
+  expect[[ind]][[chr]][[par]][ 2, 1:2] = c(3L, 3L)
+  expect[[ind]][[chr]][[par]][ 3, 1:2] = c(4L, 5L)
+  expect[[ind]][[chr]][[par]][ 4, 1:2] = c(2L, 6L)
+  expect[[ind]][[chr]][[par]][ 5, 1:2] = c(1L, 7L)
+  expect[[ind]][[chr]][[par]][ 6, 1:2] = c(2L, 8L)
+  expect[[ind]][[chr]][[par]][ 7, 1:2] = c(1L, 9L)
+  expect[[ind]][[chr]][[par]][ 8, 1:2] = c(4L, 10L)
+  expect[[ind]][[chr]][[par]][ 9, 1:2] = c(3L, 11L)
+  expect[[ind]][[chr]][[par]][10, 1:2] = c(4L, 13L)
+  expect[[ind]][[chr]][[par]][11, 1:2] = c(3L, 15L)
+  expect[[ind]][[chr]][[par]][12, 1:2] = c(4L, 17L)  
+  expect[[ind]][[chr]][[par]][13, 1:2] = c(3L, 19L)  
+  expect[[ind]][[chr]][[par]][14, 1:2] = c(2L, 45L)  
+  expect[[ind]][[chr]][[par]][15, 1:2] = c(3L, 110L)  
+  expect[[ind]][[chr]][[par]][16, 1:2] = c(2L, 140L)  
+  chr = 2; par = 2
+  expect[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 15, ncol = 2)
+  expect[[ind]][[chr]][[par]][ 1, 1:2] = c(5L, 1L)
+  expect[[ind]][[chr]][[par]][ 2, 1:2] = c(6L, 10L)
+  expect[[ind]][[chr]][[par]][ 3, 1:2] = c(5L, 20L)
+  expect[[ind]][[chr]][[par]][ 4, 1:2] = c(6L, 30L)
+  expect[[ind]][[chr]][[par]][ 5, 1:2] = c(5L, 40L)
+  expect[[ind]][[chr]][[par]][ 6, 1:2] = c(7L, 50L)
+  expect[[ind]][[chr]][[par]][ 7, 1:2] = c(6L, 75L)
+  expect[[ind]][[chr]][[par]][ 8, 1:2] = c(5L, 80L)
+  expect[[ind]][[chr]][[par]][ 9, 1:2] = c(6L, 90L)
+  expect[[ind]][[chr]][[par]][10, 1:2] = c(7L, 99L)
+  expect[[ind]][[chr]][[par]][11, 1:2] = c(8L, 100L)
+  expect[[ind]][[chr]][[par]][12, 1:2] = c(5L, 101L)  
+  expect[[ind]][[chr]][[par]][13, 1:2] = c(8L, 149L)  
+  expect[[ind]][[chr]][[par]][14, 1:2] = c(7L, 150L)  
+  expect[[ind]][[chr]][[par]][15, 1:2] = c(5L, 151L)
+  
+  ind = 8
+  chr = 1; par = 1
+  expect[[ind]][[chr]][[par]] = expect[[5]][[chr]][[2]]
+  chr = 1; par = 2
+  expect[[ind]][[chr]][[par]] = expect[[7]][[chr]][[2]]
+  chr = 2; par = 1
+  expect[[ind]][[chr]][[par]] = expect[[5]][[chr]][[2]]
+  chr = 2; par = 2
+  expect[[ind]][[chr]][[par]] = expect[[7]][[chr]][[2]]
+  
+  ind = 9
+  chr = 1; par = 1
+  expect[[ind]][[chr]][[par]] = expect[[8]][[chr]][[1]]
+  chr = 1; par = 2
+  expect[[ind]][[chr]][[par]] = expect[[8]][[chr]][[2]]
+  chr = 2; par = 1
+  expect[[ind]][[chr]][[par]] = expect[[8]][[chr]][[1]]
+  chr = 2; par = 2
+  expect[[ind]][[chr]][[par]] = expect[[8]][[chr]][[2]]
+  
+  ind = 10
+  chr = 1; par = 1
+  expect[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 7, ncol = 2)
+  expect[[ind]][[chr]][[par]][ 1, 1:2] = c(4L, 1L)
+  expect[[ind]][[chr]][[par]][ 2, 1:2] = c(3L, 5L)
+  expect[[ind]][[chr]][[par]][ 3, 1:2] = c(4L, 10L)
+  expect[[ind]][[chr]][[par]][ 4, 1:2] = c(3L, 15L)
+  expect[[ind]][[chr]][[par]][ 5, 1:2] = c(4L, 20L)
+  expect[[ind]][[chr]][[par]][ 6, 1:2] = c(7L, 50L)
+  expect[[ind]][[chr]][[par]][ 7, 1:2] = c(8L, 100L)
+  chr = 1; par = 2
+  expect[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 5, ncol = 2)
+  expect[[ind]][[chr]][[par]][1, 1:2] = c(8L, 1L)
+  expect[[ind]][[chr]][[par]][2, 1:2] = c(7L, 9L)
+  expect[[ind]][[chr]][[par]][3, 1:2] = c(8L, 11L)
+  expect[[ind]][[chr]][[par]][4, 1:2] = c(7L, 50L)
+  expect[[ind]][[chr]][[par]][5, 1:2] = c(4L, 100L)
+  chr = 2; par = 1
+  expect[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 20, ncol = 2)
+  expect[[ind]][[chr]][[par]][ 1, 1:2] = c(4L, 1L)
+  expect[[ind]][[chr]][[par]][ 2, 1:2] = c(3L, 3L)
+  expect[[ind]][[chr]][[par]][ 3, 1:2] = c(4L, 5L)
+  expect[[ind]][[chr]][[par]][ 4, 1:2] = c(3L, 7L)
+  expect[[ind]][[chr]][[par]][ 5, 1:2] = c(4L, 9L)
+  expect[[ind]][[chr]][[par]][ 6, 1:2] = c(3L, 11L)
+  expect[[ind]][[chr]][[par]][ 7, 1:2] = c(4L, 13L)
+  expect[[ind]][[chr]][[par]][ 8, 1:2] = c(3L, 15L)
+  expect[[ind]][[chr]][[par]][ 9, 1:2] = c(4L, 17L)
+  expect[[ind]][[chr]][[par]][10, 1:2] = c(3L, 19L)
+  expect[[ind]][[chr]][[par]][11, 1:2] = c(7L, 50L)
+  expect[[ind]][[chr]][[par]][12, 1:2] = c(6L, 75L)  
+  expect[[ind]][[chr]][[par]][13, 1:2] = c(5L, 80L)  
+  expect[[ind]][[chr]][[par]][14, 1:2] = c(6L, 90L)  
+  expect[[ind]][[chr]][[par]][15, 1:2] = c(7L, 99L)  
+  expect[[ind]][[chr]][[par]][16, 1:2] = c(8L, 100L)  
+  expect[[ind]][[chr]][[par]][17, 1:2] = c(5L, 101L)  
+  expect[[ind]][[chr]][[par]][18, 1:2] = c(8L, 149L)  
+  expect[[ind]][[chr]][[par]][19, 1:2] = c(7L, 150L)  
+  expect[[ind]][[chr]][[par]][20, 1:2] = c(5L, 151L)  
+  chr = 2; par = 2
+  expect[[ind]][[chr]][[par]] = matrix(data = 0L, nrow = 11, ncol = 2)
+  expect[[ind]][[chr]][[par]][ 1, 1:2] = c(5L, 1L)
+  expect[[ind]][[chr]][[par]][ 2, 1:2] = c(6L, 10L)
+  expect[[ind]][[chr]][[par]][ 3, 1:2] = c(5L, 20L)
+  expect[[ind]][[chr]][[par]][ 4, 1:2] = c(6L, 30L)
+  expect[[ind]][[chr]][[par]][ 5, 1:2] = c(5L, 40L)
+  expect[[ind]][[chr]][[par]][ 6, 1:2] = c(7L, 50L)
+  expect[[ind]][[chr]][[par]][ 7, 1:2] = c(6L, 75L)
+  expect[[ind]][[chr]][[par]][ 8, 1:2] = c(5L, 80L)
+  expect[[ind]][[chr]][[par]][ 9, 1:2] = c(6L, 90L)
+  expect[[ind]][[chr]][[par]][10, 1:2] = c(7L, 99L)
+  expect[[ind]][[chr]][[par]][11, 1:2] = c(3L, 100L)
+  
   result = AlphaSimR:::getIbdRecHist(recHist     = recHist,
                                      pedigree    = pedigree,
                                      nLociPerChr = nLociPerChr)$ibdRecHist
-  for (ind in 1:7) {
+  
+  for (ind in 1:10) {
     for (chr in 1:2) {
       for (par in 1:2) {
         expect_identical(object = result[[ind]][[chr]][[par]],
@@ -273,215 +443,292 @@ test_that(""pullIbdHaplo2 gets correct IBD haplotypes"", {
   output = AlphaSimR:::getIbdHaplo(ibdRecHist  = ibdRecHist,
                                    individuals = 1L:nrow(pedigree),
                                    nLociPerChr = nLociPerChr)
-  expect = matrix(data = 0L, nrow = 14, ncol = 600)
+  
+  expect = matrix(data = 0L, nrow = 18, ncol = 600)
+  
   # ind 1
-  expect[1, ] = 1L
-  expect_identical(object = output[1, ],
-                   expected = expect[1, ],
+  gam = 1
+  expect[gam, ] = 1L
+  expect_identical(object = output[gam, ],
+                   expected = expect[gam, ],
                    info = paste0(""ind 1, chr 1 & 2, gamete 1""))
-  expect[2, ] = 2L
-  expect_identical(object = output[2, ],
-                   expected = expect[2, ],
+  gam = 2
+  expect[gam, ] = 2L
+  expect_identical(object = output[gam, ],
+                   expected = expect[gam, ],
                    info = paste0(""ind 1, chr 1 & 2, gamete 2""))
+  
   # ind 2
-  expect[3, ] = 3L
-  expect_identical(object = output[3, ],
-                   expected = expect[3, ],
+  gam = 3
+  expect[gam, ] = 3L
+  expect_identical(object = output[gam, ],
+                   expected = expect[gam, ],
                    info = paste0(""ind 2, chr 1 & 2, gamete 1""))
-  expect[4, ] = 4L
-  expect_identical(object = output[4, ],
-                   expected = expect[4, ],
+  gam = 4
+  expect[gam, ] = 4L
+  expect_identical(object = output[gam, ],
+                   expected = expect[gam, ],
                    info = paste0(""ind 2, chr 1 & 2, gamete 2""))
+  
   # ind 3
-  expect[5, ] = 5L
-  expect_identical(object = output[5, ],
-                   expected = expect[5, ],
+  gam = 5
+  expect[gam, ] = 5L
+  expect_identical(object = output[gam, ],
+                   expected = expect[gam, ],
                    info = paste0(""ind 3, chr 1 & 2, gamete 1""))
-  expect[6, ] = 6L
-  expect_identical(object = output[6, ],
-                   expected = expect[6, ],
+  gam = 6
+  expect[gam, ] = 6L
+  expect_identical(object = output[gam, ],
+                   expected = expect[gam, ],
                    info = paste0(""ind 3, chr 1 & 2, gamete 2""))
+  
   # ind 4
-  expect[7, ] = 7L
-  expect_identical(object = output[7, ],
-                   expected = expect[7, ],
+  gam = 7
+  expect[gam, ] = 7L
+  expect_identical(object = output[gam, ],
+                   expected = expect[gam, ],
                    info = paste0(""ind 4, chr 1 & 2, gamete 1""))
-  expect[8, ] = 8L
-  expect_identical(object = output[8, ],
-                   expected = expect[8, ],
+  gam = 8
+  expect[gam, ] = 8L
+  expect_identical(object = output[gam, ],
+                   expected = expect[gam, ],
                    info = paste0(""ind 4, chr 1 & 2, gamete 2""))
-  # ind 5 - chr 1, paternal
-  expect[9,   1:009] = 1L
-  expect[9,  10:049] = 2L
-  expect[9,  50:099] = 1L
-  expect[9, 100:149] = 2L
-  expect[9, 150:300] = 1L
-  expect_identical(object = output[9, 1:300],
-                   expected = expect[9, 1:300],
-                   info = paste0(""ind 5, chr 1, gamete 1""))
+  
   # ind 5 - chr 1, maternal
-  expect[10,  1:004] = 4L
-  expect[10,  5:009] = 3L
-  expect[10, 10:014] = 4L
-  expect[10, 15:019] = 3L
-  expect[10, 20:300] = 4L
-  expect_identical(object = output[10, 1:300],
-                   expected = expect[10, 1:300],
+  gam = 9
+  expect[gam,   1:009] = 1L
+  expect[gam,  10:049] = 2L
+  expect[gam,  50:099] = 1L
+  expect[gam, 100:149] = 2L
+  expect[gam, 150:300] = 1L
+  expect_identical(object = output[gam, 1:300],
+                   expected = expect[gam, 1:300],
+                   info = paste0(""ind 5, chr 1, gamete 1""))
+  # ind 5 - chr 1, paternal
+  gam = 10
+  expect[gam,  1:004] = 4L
+  expect[gam,  5:009] = 3L
+  expect[gam, 10:014] = 4L
+  expect[gam, 15:019] = 3L
+  expect[gam, 20:300] = 4L
+  expect_identical(object = output[gam, 1:300],
+                   expected = expect[gam, 1:300],
                    info = paste0(""ind 5, chr 1, gamete 2""))
-  # ind 5 - chr 2, paternal
-  expect[9, 300 + 001:001] = 1L
-  expect[9, 300 + 002:002] = 2L
-  expect[9, 300 + 003:003] = 1L
-  expect[9, 300 + 004:004] = 2L
-  expect[9, 300 + 005:005] = 1L
-  expect[9, 300 + 006:006] = 2L
-  expect[9, 300 + 007:007] = 1L
-  expect[9, 300 + 008:008] = 2L
-  expect[9, 300 + 009:009] = 1L
-  expect[9, 300 + 010:300] = 2L
-  expect_identical(object = output[9, 301:600],
-                   expected = expect[9, 301:600],
-                   info = paste0(""ind 5, chr 2, gamete 1""))
   # ind 5 - chr 2, maternal
-  expect[10, 300 + 001:002] = 4L
-  expect[10, 300 + 003:004] = 3L
-  expect[10, 300 + 005:006] = 4L
-  expect[10, 300 + 007:008] = 3L
-  expect[10, 300 + 009:010] = 4L
-  expect[10, 300 + 011:012] = 3L
-  expect[10, 300 + 013:014] = 4L
-  expect[10, 300 + 015:016] = 3L
-  expect[10, 300 + 017:018] = 4L
-  expect[10, 300 + 019:300] = 3L
-  expect_identical(object = output[10, 301:600],
-                   expected = expect[10, 301:600],
+  gam = 9
+  expect[gam, 300 + 001:001] = 1L
+  expect[gam, 300 + 002:002] = 2L
+  expect[gam, 300 + 003:003] = 1L
+  expect[gam, 300 + 004:004] = 2L
+  expect[gam, 300 + 005:005] = 1L
+  expect[gam, 300 + 006:006] = 2L
+  expect[gam, 300 + 007:007] = 1L
+  expect[gam, 300 + 008:008] = 2L
+  expect[gam, 300 + 009:009] = 1L
+  expect[gam, 300 + 010:300] = 2L
+  expect_identical(object = output[gam, 301:600],
+                   expected = expect[gam, 301:600],
+                   info = paste0(""ind 5, chr 2, gamete 1""))
+  # ind 5 - chr 2, paternal
+  gam = 10
+  expect[gam, 300 + 001:002] = 4L
+  expect[gam, 300 + 003:004] = 3L
+  expect[gam, 300 + 005:006] = 4L
+  expect[gam, 300 + 007:008] = 3L
+  expect[gam, 300 + 009:010] = 4L
+  expect[gam, 300 + 011:012] = 3L
+  expect[gam, 300 + 013:014] = 4L
+  expect[gam, 300 + 015:016] = 3L
+  expect[gam, 300 + 017:018] = 4L
+  expect[gam, 300 + 019:300] = 3L
+  expect_identical(object = output[gam, 301:600],
+                   expected = expect[gam, 301:600],
                    info = paste0(""ind 5, chr 2, gamete 2""))
-  # ind 6 - chr 1, paternal
-  expect[11,   1:149] = 6L
-  expect[11, 150:199] = 5L
-  expect[11, 200:249] = 6L
-  expect[11, 250:300] = 5L
-  expect_identical(object = output[11, 1:300],
-                   expected = expect[11, 1:300],
-                   info = paste0(""ind 6, chr 1, gamete 1""))
+  
   # ind 6 - chr 1, maternal
-  expect[12,   1:008] = 8L
-  expect[12,   9:010] = 7L
-  expect[12,  11:049] = 8L
-  expect[12,  50:099] = 7L
-  expect[12, 100:300] = 8L
-  expect_identical(object = output[12, 1:300],
-                   expected = expect[12, 1:300],
+  gam = 11
+  expect[gam,   1:149] = 6L
+  expect[gam, 150:199] = 5L
+  expect[gam, 200:249] = 6L
+  expect[gam, 250:300] = 5L
+  expect_identical(object = output[gam, 1:300],
+                   expected = expect[gam, 1:300],
+                   info = paste0(""ind 6, chr 1, gamete 1""))
+  # ind 6 - chr 1, paternal
+  gam = 12
+  expect[gam,   1:008] = 8L
+  expect[gam,   9:010] = 7L
+  expect[gam,  11:049] = 8L
+  expect[gam,  50:099] = 7L
+  expect[gam, 100:300] = 8L
+  expect_identical(object = output[gam, 1:300],
+                   expected = expect[gam, 1:300],
                    info = paste0(""ind 6, chr 1, gamete 2""))
-  # ind 6 - chr 2, paternal
-  expect[11, 300 + 001:009] = 5L
-  expect[11, 300 + 010:019] = 6L
-  expect[11, 300 + 020:029] = 5L
-  expect[11, 300 + 030:039] = 6L
-  expect[11, 300 + 040:049] = 5L
-  expect[11, 300 + 050:059] = 6L
-  expect[11, 300 + 060:069] = 5L
-  expect[11, 300 + 070:079] = 6L
-  expect[11, 300 + 080:089] = 5L
-  expect[11, 300 + 090:099] = 6L
-  expect[11, 300 + 100:300] = 5L
-  expect_identical(object = output[11, 301:600],
-                   expected = expect[11, 301:600],
-                   info = paste0(""ind 6, chr 2, gamete 1""))
   # ind 6 - chr 2, maternal
-  expect[12, 300 + 001:049] = 8L
-  expect[12, 300 + 050:099] = 7L
-  expect[12, 300 + 100:149] = 8L
-  expect[12, 300 + 150:199] = 7L
-  expect[12, 300 + 200:249] = 8L
-  expect[12, 300 + 250:300] = 7L
-  expect_identical(object = output[12, 301:600],
-                   expected = expect[12, 301:600],
+  gam = 11
+  expect[gam, 300 + 001:009] = 5L
+  expect[gam, 300 + 010:019] = 6L
+  expect[gam, 300 + 020:029] = 5L
+  expect[gam, 300 + 030:039] = 6L
+  expect[gam, 300 + 040:049] = 5L
+  expect[gam, 300 + 050:059] = 6L
+  expect[gam, 300 + 060:069] = 5L
+  expect[gam, 300 + 070:079] = 6L
+  expect[gam, 300 + 080:089] = 5L
+  expect[gam, 300 + 090:099] = 6L
+  expect[gam, 300 + 100:300] = 5L
+  expect_identical(object = output[gam, 301:600],
+                   expected = expect[gam, 301:600],
+                   info = paste0(""ind 6, chr 2, gamete 1""))
+  # ind 6 - chr 2, paternal
+  gam = 12
+  expect[gam, 300 + 001:049] = 8L
+  expect[gam, 300 + 050:099] = 7L
+  expect[gam, 300 + 100:149] = 8L
+  expect[gam, 300 + 150:199] = 7L
+  expect[gam, 300 + 200:249] = 8L
+  expect[gam, 300 + 250:300] = 7L
+  expect_identical(object = output[gam, 301:600],
+                   expected = expect[gam, 301:600],
                    info = paste0(""ind 6, chr 2, gamete 2""))
-  # ind 7 - chr 1, paternal
-  expect[13,   1:004] = 4L
-  expect[13,   5:005] = 3L
-  expect[13,   6:009] = 1L
-  expect[13,  10:014] = 4L
-  expect[13,  15:019] = 3L
-  expect[13,  20:044] = 4L
-  expect[13,  45:049] = 2L
-  expect[13,  50:099] = 1L
-  expect[13, 100:109] = 2L
-  expect[13, 110:139] = 4L
-  expect[13, 140:149] = 2L
-  expect[13, 150:300] = 1L
-  expect_identical(object = output[13, 1:300],
-                   expected = expect[13, 1:300],
-                   info = paste0(""ind 7, chr 1, gamete 1""))
+  
   # ind 7 - chr 1, maternal
-  expect[14,   1:008] = 8L
-  expect[14,   9:010] = 7L
-  expect[14,  11:049] = 8L
-  expect[14,  50:099] = 7L
-  expect[14, 100:300] = 8L
-  expect_identical(object = output[14, 1:300],
-                   expected = expect[14, 1:300],
+  gam = 13
+  expect[gam,   1:004] = 4L
+  expect[gam,   5:005] = 3L
+  expect[gam,   6:009] = 1L
+  expect[gam,  10:014] = 4L
+  expect[gam,  15:019] = 3L
+  expect[gam,  20:044] = 4L
+  expect[gam,  45:049] = 2L
+  expect[gam,  50:099] = 1L
+  expect[gam, 100:109] = 2L
+  expect[gam, 110:139] = 4L
+  expect[gam, 140:149] = 2L
+  expect[gam, 150:300] = 1L
+  expect_identical(object = output[gam, 1:300],
+                   expected = expect[gam, 1:300],
+                   info = paste0(""ind 7, chr 1, gamete 1""))
+  # ind 7 - chr 1, paternal
+  gam = 14
+  expect[gam,   1:008] = 8L
+  expect[gam,   9:010] = 7L
+  expect[gam,  11:049] = 8L
+  expect[gam,  50:099] = 7L
+  expect[gam, 100:300] = 8L
+  expect_identical(object = output[gam, 1:300],
+                   expected = expect[gam, 1:300],
                    info = paste0(""ind 7, chr 1, gamete 2""))
-  # ind 7 - chr 2, paternal
-  expect[13, 300 + 001:002] = 4L
-  expect[13, 300 + 003:004] = 3L
-  expect[13, 300 + 005:005] = 4L
-  expect[13, 300 + 006:006] = 2L
-  expect[13, 300 + 007:007] = 1L
-  expect[13, 300 + 008:008] = 2L
-  expect[13, 300 + 009:009] = 1L
-  expect[13, 300 + 010:010] = 4L
-  expect[13, 300 + 011:012] = 3L
-  expect[13, 300 + 013:014] = 4L
-  expect[13, 300 + 015:016] = 3L
-  expect[13, 300 + 017:018] = 4L
-  expect[13, 300 + 019:044] = 3L
-  expect[13, 300 + 045:109] = 2L
-  expect[13, 300 + 110:139] = 3L
-  expect[13, 300 + 140:300] = 2L
-  expect_identical(object = output[13, 301:600],
-                   expected = expect[13, 301:600],
-                   info = paste0(""ind 7, chr 2, gamete 1""))
   # ind 7 - chr 2, maternal
-  expect[14, 300 + 001:009] = 5L
-  expect[14, 300 + 010:019] = 6L
-  expect[14, 300 + 020:029] = 5L
-  expect[14, 300 + 030:039] = 6L
-  expect[14, 300 + 040:049] = 5L
-  expect[14, 300 + 050:074] = 7L
-  expect[14, 300 + 075:079] = 6L
-  expect[14, 300 + 080:089] = 5L
-  expect[14, 300 + 090:098] = 6L
-  expect[14, 300 + 099:099] = 7L
-  expect[14, 300 + 100:100] = 8L
-  expect[14, 300 + 101:148] = 5L
-  expect[14, 300 + 149:149] = 8L
-  expect[14, 300 + 150:150] = 7L
-  expect[14, 300 + 151:300] = 5L
-  expect_identical(object = output[14, 301:600],
-                   expected = expect[14, 301:600],
+  gam = 13
+  expect[gam, 300 + 001:002] = 4L
+  expect[gam, 300 + 003:004] = 3L
+  expect[gam, 300 + 005:005] = 4L
+  expect[gam, 300 + 006:006] = 2L
+  expect[gam, 300 + 007:007] = 1L
+  expect[gam, 300 + 008:008] = 2L
+  expect[gam, 300 + 009:009] = 1L
+  expect[gam, 300 + 010:010] = 4L
+  expect[gam, 300 + 011:012] = 3L
+  expect[gam, 300 + 013:014] = 4L
+  expect[gam, 300 + 015:016] = 3L
+  expect[gam, 300 + 017:018] = 4L
+  expect[gam, 300 + 019:044] = 3L
+  expect[gam, 300 + 045:109] = 2L
+  expect[gam, 300 + 110:139] = 3L
+  expect[gam, 300 + 140:300] = 2L
+  expect_identical(object = output[gam, 301:600],
+                   expected = expect[gam, 301:600],
+                   info = paste0(""ind 7, chr 2, gamete 1""))
+  # ind 7 - chr 2, paternal
+  gam = 14
+  expect[gam, 300 + 001:009] = 5L
+  expect[gam, 300 + 010:019] = 6L
+  expect[gam, 300 + 020:029] = 5L
+  expect[gam, 300 + 030:039] = 6L
+  expect[gam, 300 + 040:049] = 5L
+  expect[gam, 300 + 050:074] = 7L
+  expect[gam, 300 + 075:079] = 6L
+  expect[gam, 300 + 080:089] = 5L
+  expect[gam, 300 + 090:098] = 6L
+  expect[gam, 300 + 099:099] = 7L
+  expect[gam, 300 + 100:100] = 8L
+  expect[gam, 300 + 101:148] = 5L
+  expect[gam, 300 + 149:149] = 8L
+  expect[gam, 300 + 150:150] = 7L
+  expect[gam, 300 + 151:300] = 5L
+  expect_identical(object = output[gam, 301:600],
+                   expected = expect[gam, 301:600],
                    info = paste0(""ind 7, chr 2, gamete 2""))
   
+  # ind 8 - chr 1, maternal
+  gam = 15
+  expect[gam, 1:300] = expect[10, 1:300]
+  expect_identical(object = output[gam, 1:300],
+                   expected = expect[gam, 1:300],
+                   info = paste0(""ind 8, chr 1, gamete 1""))
+  # ind 8 - chr 1, paternal
+  gam = 16
+  expect[gam, 1:300] = expect[14, 1:300]
+  expect_identical(object = output[gam, 1:300],
+                   expected = expect[gam, 1:300],
+                   info = paste0(""ind 8, chr 1, gamete 2""))
+  # ind 8 - chr 2, maternal
+  gam = 15
+  expect[gam, 300 + 1:300] = expect[10, 300 + 1:300]
+  expect_identical(object = output[gam, 300 + 1:300],
+                   expected = expect[gam, 300 + 1:300],
+                   info = paste0(""ind 8, chr 2, gamete 1""))
+  # ind 8 - chr 2, paternal
+  gam = 16
+  expect[gam, 300 + 1:300] = expect[14, 300 + 1:300]
+  expect_identical(object = output[gam, 300 + 1:300],
+                   expected = expect[gam, 300 + 1:300],
+                   info = paste0(""ind 8, chr 2, gamete 2""))
+  
+  # ind 9 - chr 1, maternal
+  gam = 17
+  expect[gam, 1:300] = expect[15, 1:300]
+  expect_identical(object = output[gam, 1:300],
+                   expected = expect[gam, 1:300],
+                   info = paste0(""ind 9, chr 1, gamete 1""))
+  # ind 9 - chr 1, paternal
+  gam = 18
+  expect[gam, 1:300] = expect[16, 1:300]
+  expect_identical(object = output[gam, 1:300],
+                   expected = expect[gam, 1:300],
+                   info = paste0(""ind 9, chr 1, gamete 2""))
+  # ind 8 - chr 2, maternal
+  gam = 17
+  expect[gam, 300 + 1:300] = expect[15, 300 + 1:300]
+  expect_identical(object = output[gam, 300 + 1:300],
+                   expected = expect[gam, 300 + 1:300],
+                   info = paste0(""ind 9, chr 2, gamete 1""))
+  # ind 8 - chr 2, paternal
+  gam = 18
+  expect[gam, 300 + 1:300] = expect[16, 300 + 1:300]
+  expect_identical(object = output[gam, 300 + 1:300],
+                   expected = expect[gam, 300 + 1:300],
+                   info = paste0(""ind 9, chr 2, gamete 2""))
+  
   # Test subsetting
   output = AlphaSimR:::getIbdHaplo(ibdRecHist  = ibdRecHist,
                                    individuals = 7L,
                                    nLociPerChr = nLociPerChr)
-  # ind 7 - chr 1, paternal
+  # ind 7 - chr 1, maternal
   expect_identical(object = output[1, 1:300],
                    expected = expect[13, 1:300],
                    info = paste0(""ind 7, chr 1, gamete 1, from subsetted call""))
-  # ind 7 - chr 1, maternal
+  # ind 7 - chr 1, paternal
   expect_identical(object = output[2, 1:300],
                    expected = expect[14, 1:300],
                    info = paste0(""ind 7, chr 1, gamete 2, from subsetted call""))
-  # ind 7 - chr 2, paternal
-
+  # ind 7 - chr 2, maternal
   expect_identical(object = output[1, 301:600],
                    expected = expect[13, 301:600],
                    info = paste0(""ind 7, chr 2, gamete 1, from subsetted call""))
-  # ind 7 - chr 2, maternal
+  # ind 7 - chr 2, paternal
   expect_identical(object = output[2, 301:600],
                    expected = expect[14, 301:600],
                    info = paste0(""ind 7, chr 2, gamete 2, from subsetted call""))
-})
\ No newline at end of file
+})"
gaynorr,AlphaSimR,4c05e298161969624472f344ac8cb2d84510478a,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-07-26T15:40:20Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-07-26T15:40:20Z,-fixed bug with mergePops when merging ebv,NEWS;R/mergePops.R,False,True,True,False,3,2,5,"---FILE: NEWS---
@@ -13,6 +13,7 @@ Changes in version 0.7.0
     -fixed population subsetting checks to prevent invalid selections
     -fixed slow calcGCA
     -fixed error in addTraitAG preventing multiple traits
+    -fixed bug with mergePops when merging ebv
 
 Changes in version 0.6.1
 

---FILE: R/mergePops.R---
@@ -72,9 +72,9 @@ mergePops = function(popList){
                            function(x) ncol(x@ebv)))
   if(all(ebv==ebv[1])){
     ebv = do.call(""rbind"",lapply(popList,
-                                 function(x) x@pheno))
+                                 function(x) x@ebv))
   }else{
-    ebv = matrix(NA_real_,nrow=nInd,ncol=0)
+    ebv = matrix(NA_real_,nrow=sum(nInd),ncol=0)
   }
   #gxe
   if(nTraits>=1){"
gaynorr,AlphaSimR,7b1682ac626657444eb1ffe0614746a5fa50edb7,gregor_gorjanc,gregor.gorjanc@gmail.com,2018-07-25T15:43:44Z,gregor_gorjanc,gregor.gorjanc@gmail.com,2018-07-25T15:43:44Z,Bugfix: replacing unlist(sapply()) with c(sapply()) to get a vector,R/pullGeno.R,False,True,True,False,46,50,96,"---FILE: R/pullGeno.R---
@@ -9,7 +9,7 @@ selectLoci = function(chr,inLociPerChr,inLociLoc){
   outLociPerChr = numeric(nChr)
   outLociPerChr[chr] = inLociPerChr[chr]
   outLociLoc = numeric(sum(outLociPerChr))
-  inStart = outStart = inEnd = outEnd = 0L 
+  inStart = outStart = inEnd = outEnd = 0L
   for(i in 1:nChr){
     inStart = inStart + 1L
     inEnd = inEnd + inLociPerChr[i]
@@ -26,13 +26,13 @@ selectLoci = function(chr,inLociPerChr,inLociLoc){
 }
 
 #' @title Pull SNP genotype
-#' 
+#'
 #' @description Retrieves SNP genotype data
 #'
 #' @param pop an object of \code{\link{Pop-class}}
-#' @param snpChip an integer. Indicates which SNP 
+#' @param snpChip an integer. Indicates which SNP
 #' chip's genotypes to retrieve.
-#' @param chr a vector of chromosomes to retrieve. If NULL, 
+#' @param chr a vector of chromosomes to retrieve. If NULL,
 #' all chromosome are retrieved.
 #' @param simParam an object of \code{\link{SimParam}}
 #'
@@ -57,7 +57,7 @@ pullSnpGeno = function(pop, snpChip=1, chr=NULL, simParam=NULL){
 }
 
 #' @title Pull SNP genotype for multiple snp chips
-#' 
+#'
 #' @description Retrieves SNP genotype data for multiple snp chips
 #'
 #' @param pop an object of \code{\link{Pop-class}}
@@ -81,14 +81,14 @@ pullMultipleSnpGeno = function(pop, chips,
   for (c in uniqueChips){
     allSnps = sort(union(allSnps,simParam$snpChips[[c]]@lociLoc))
   }
-  
+
   output = matrix(pop@nInd,length(allSnps),data=missing)
   if(class(pop)==""Pop""){
     rownames(output) = pop@id
   }else{
     rownames(output) = as.character(1:pop@nInd)
   }
-  
+
   for (snpChip in uniqueChips){
     mask = allSnps %in% simParam$snpChips[[snpChip]]@lociLoc
     one = getGeno(pop@geno,
@@ -100,22 +100,22 @@ pullMultipleSnpGeno = function(pop, chips,
         output[i,mask] = one[i,]
         output[i,mask] = one[i,]
       }
-    }      
+    }
   }
-  
+
   colnames(output) = paste(""SNP"",1:ncol(output),sep=""_"")
-  
+
   return(output)
 }
 
 #' @title Pull QTL genotype
-#' 
+#'
 #' @description Retrieves QTL genotype data
 #'
 #' @param pop an object of \code{\link{Pop-class}}
 #' @param trait an integer. Indicates which trait's
 #' QTL genotypes to retrieve.
-#' @param chr a vector of chromosomes to retrieve. If NULL, 
+#' @param chr a vector of chromosomes to retrieve. If NULL,
 #' all chromosome are retrieved.
 #' @param simParam an object of \code{\link{SimParam}}
 #'
@@ -140,29 +140,27 @@ pullQtlGeno = function(pop, trait=1, chr=NULL, simParam=NULL){
 }
 
 #' @title Pull seg site genotypes
-#' 
-#' @description 
+#'
+#' @description
 #' Retrieves genotype data for all segregating sites
 #'
-#' @param pop an object of \code{\link{Pop-class}} or 
+#' @param pop an object of \code{\link{Pop-class}} or
 #' \code{\link{RawPop-class}}
-#' @param chr a vector of chromosomes to retrieve. If NULL, 
+#' @param chr a vector of chromosomes to retrieve. If NULL,
 #' all chromosome are retrieved.
 #' @param simParam an object of \code{\link{SimParam}}
 #'
 #' @return Returns a matrix of genotypes
 #' @export
 pullSegSiteGeno = function(pop, chr=NULL, simParam=NULL){
   if(class(pop)==""MapPop""){
-    allLoci = unlist(sapply(pop@nLoci,
-                            function(x) 1:x))
+    allLoci = c(sapply(pop@nLoci, function(x) 1:x))
     lociTot = pop@nLoci
   }else{
     if(is.null(simParam)){
       simParam = get(""SP"",envir=.GlobalEnv)
     }
-    allLoci = unlist(sapply(simParam$segSites,
-                            function(x) 1:x))
+    allLoci = c(sapply(simParam$segSites, function(x) 1:x))
     lociTot = simParam$segSites
   }
   tmp = selectLoci(chr,lociTot,allLoci)
@@ -178,22 +176,22 @@ pullSegSiteGeno = function(pop, chr=NULL, simParam=NULL){
 }
 
 #' @title Pull SNP haplotypes
-#' 
+#'
 #' @description Retrieves SNP haplotype data
 #'
 #' @param pop an object of \code{\link{Pop-class}}
-#' @param snpChip an integer. Indicates which SNP 
+#' @param snpChip an integer. Indicates which SNP
 #' chip's haplotypes to retrieve.
-#' @param haplo either ""all"" for all haplotypes or an integer 
-#' for a single set of haplotypes. Use a value of 1 for female 
+#' @param haplo either ""all"" for all haplotypes or an integer
+#' for a single set of haplotypes. Use a value of 1 for female
 #' haplotyes and a value of 2 for male haplotypes.
-#' @param chr a vector of chromosomes to retrieve. If NULL, 
+#' @param chr a vector of chromosomes to retrieve. If NULL,
 #' all chromosome are retrieved.
 #' @param simParam an object of \code{\link{SimParam}}
 #'
 #' @return Returns a matrix of SNP haplotypes.
 #' @export
-pullSnpHaplo = function(pop, snpChip=1, haplo=""all"", 
+pullSnpHaplo = function(pop, snpChip=1, haplo=""all"",
                         chr=NULL, simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
@@ -229,21 +227,21 @@ pullSnpHaplo = function(pop, snpChip=1, haplo=""all"",
 }
 
 #' @title Pull SNP haplotypes for multiple chips
-#' 
+#'
 #' @description Retrieves SNP haplotype data for multiple snp
 #'
 #' @param pop an object of \code{\link{Pop-class}}
 #' @param chips a vector. For each animal indicates what snp
 #' chip to use
-#' @param haplo either ""all"" for all haplotypes or an integer 
-#' for a single set of haplotypes. Use a value of 1 for female 
+#' @param haplo either ""all"" for all haplotypes or an integer
+#' for a single set of haplotypes. Use a value of 1 for female
 #' haplotyes and a value of 2 for male haplotypes.
 #' @param missing What value to use for missing
 #' @param simParam an object of \code{\link{SimParam}}
 #'
 #' @return Returns a matrix of SNP haplotypes.
 #' @export
-pullMultipleSnpHaplo = function(pop, chips, haplo=""all"", 
+pullMultipleSnpHaplo = function(pop, chips, haplo=""all"",
                                 missing=9, simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
@@ -257,7 +255,7 @@ pullMultipleSnpHaplo = function(pop, chips, haplo=""all"",
   for (c in uniqueChips){
     allSnps = sort(union(allSnps,simParam$snpChips[[c]]@lociLoc))
   }
-  
+
   if (haplo == ""all"") {
     output = matrix(pop@nInd*2,length(allSnps),data=missing)
     if(class(pop)==""Pop""){
@@ -300,32 +298,32 @@ pullMultipleSnpHaplo = function(pop, chips, haplo=""all"",
           output[i,mask] = one[i,]
           output[i,mask] = one[i,]
         }
-      }      
+      }
     }
   }
-  
+
   colnames(output) = paste(""SNP"",1:ncol(output),sep=""_"")
-  
+
   return(output)
 }
 
 #' @title Pull QTL haplotypes
-#' 
+#'
 #' @description Retrieves QTL haplotype data
 #'
 #' @param pop an object of \code{\link{Pop-class}}
 #' @param trait an integer. Indicates which trait's
 #' QTL haplotypes to retrieve.
-#' @param haplo either ""all"" for all haplotypes or an integer 
-#' for a single set of haplotypes. Use a value of 1 for female 
+#' @param haplo either ""all"" for all haplotypes or an integer
+#' for a single set of haplotypes. Use a value of 1 for female
 #' haplotyes and a value of 2 for male haplotypes.
-#' @param chr a vector of chromosomes to retrieve. If NULL, 
+#' @param chr a vector of chromosomes to retrieve. If NULL,
 #' all chromosome are retrieved.
 #' @param simParam an object of \code{\link{SimParam}}
 #'
 #' @return Returns a matrix of QTL haplotypes.
 #' @export
-pullQtlHaplo = function(pop, trait=1, haplo=""all"", 
+pullQtlHaplo = function(pop, trait=1, haplo=""all"",
                         chr=NULL, simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
@@ -361,33 +359,31 @@ pullQtlHaplo = function(pop, trait=1, haplo=""all"",
 }
 
 #' @title Pull seg site haplotypes
-#' 
-#' @description 
+#'
+#' @description
 #' Retrieves haplotype data for all segregating sites
 #'
-#' @param pop an object of \code{\link{Pop-class}} or 
+#' @param pop an object of \code{\link{Pop-class}} or
 #' \code{\link{RawPop-class}}
-#' @param haplo either ""all"" for all haplotypes or an integer 
-#' for a single set of haplotypes. Use a value of 1 for female 
+#' @param haplo either ""all"" for all haplotypes or an integer
+#' for a single set of haplotypes. Use a value of 1 for female
 #' haplotyes and a value of 2 for male haplotypes.
-#' @param chr a vector of chromosomes to retrieve. If NULL, 
+#' @param chr a vector of chromosomes to retrieve. If NULL,
 #' all chromosome are retrieved.
 #' @param simParam an object of \code{\link{SimParam}}
 #'
 #' @return Returns a matrix of haplotypes
 #' @export
-pullSegSiteHaplo = function(pop, haplo=""all"", 
+pullSegSiteHaplo = function(pop, haplo=""all"",
                             chr=NULL, simParam=NULL){
   if(class(pop)==""MapPop""){
-    allLoci = unlist(sapply(pop@nLoci,
-                            function(x) 1:x))
+    allLoci = c(sapply(pop@nLoci, function(x) 1:x))
     lociTot = pop@nLoci
   }else{
     if(is.null(simParam)){
       simParam = get(""SP"",envir=.GlobalEnv)
     }
-    allLoci = unlist(sapply(simParam$segSites,
-                            function(x) 1:x))
+    allLoci = c(sapply(simParam$segSites, function(x) 1:x))
     lociTot = simParam$segSites
   }
   if(!is.null(chr)){"
gaynorr,AlphaSimR,dd198fb8947846653ca0a44616e91dd700d06bef,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-07-23T12:45:34Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-07-23T12:45:34Z,-fixed error in addTraitAG preventing multiple traits,NEWS;R/Class-SimParam.R;R/RcppExports.R;R/founderPop.R;man/runMacs.Rd;man/runMacs2.Rd;src/RcppExports.cpp,False,True,True,False,258,216,474,"---FILE: NEWS---
@@ -11,6 +11,7 @@ Changes in version 0.7.0
   Bug fixes
     -fixed population subsetting checks to prevent invalid selections
     -fixed slow calcGCA
+    -fixed error in addTraitAG preventing multiple traits
 
 Changes in version 0.6.1
 

---FILE: R/Class-SimParam.R---
@@ -1135,10 +1135,10 @@ SimParam$set(
     stopifnot(length(mean)==length(var),
               isSymmetric(corA),
               isSymmetric(corGxE),
-              length(meanG)==nrow(corA),
-              length(meanG)==nrow(corGxE),
-              length(meanG)==length(varGxE),
-              length(meanG)==length(varEnv))
+              length(mean)==nrow(corA),
+              length(mean)==nrow(corGxE),
+              length(mean)==length(varGxE),
+              length(mean)==length(varEnv))
     qtlLoci = private$.pickQtlLoci(nQtlPerChr)
     addEff = sampAddEff(qtlLoci=qtlLoci,nTraits=nTraits,
                         corr=corA,gamma=gamma,shape=shape)

---FILE: R/RcppExports.R---
@@ -1,6 +1,14 @@
 # Generated by using Rcpp::compileAttributes() -> do not edit by hand
 # Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393
 
+writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call(`_AlphaSimR_writeASGenotypes`, g, locations, allLocations, snpchips, names, missing, fname))
+}
+
+writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call(`_AlphaSimR_writeASHaplotypes`, g, locations, allLocations, snpchips, names, missing, fname))
+}
+
 gebvRR <- function(RRsol, pop) {
     .Call(`_AlphaSimR_gebvRR`, RRsol, pop)
 }
@@ -21,38 +29,6 @@ gegvSCA <- function(sol, pop) {
     .Call(`_AlphaSimR_gegvSCA`, sol, pop)
 }
 
-callRRBLUP <- function(y, x, reps, genoTrain, nMarker, skip) {
-    .Call(`_AlphaSimR_callRRBLUP`, y, x, reps, genoTrain, nMarker, skip)
-}
-
-callRRBLUP2 <- function(y, x, reps, genoTrain, nMarker, skip, Vu, Ve, tol, maxIter, useEM) {
-    .Call(`_AlphaSimR_callRRBLUP2`, y, x, reps, genoTrain, nMarker, skip, Vu, Ve, tol, maxIter, useEM)
-}
-
-callRRBLUP_D <- function(y, x, reps, genoTrain, nMarker, skip, maxIter, useHetCov) {
-    .Call(`_AlphaSimR_callRRBLUP_D`, y, x, reps, genoTrain, nMarker, skip, maxIter, useHetCov)
-}
-
-callRRBLUP_MV <- function(Y, x, reps, genoTrain, nMarker, skip, maxIter) {
-    .Call(`_AlphaSimR_callRRBLUP_MV`, Y, x, reps, genoTrain, nMarker, skip, maxIter)
-}
-
-callRRBLUP_GCA <- function(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter) {
-    .Call(`_AlphaSimR_callRRBLUP_GCA`, y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter)
-}
-
-callRRBLUP_SCA <- function(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter, useHetCov) {
-    .Call(`_AlphaSimR_callRRBLUP_SCA`, y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter, useHetCov)
-}
-
-writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call(`_AlphaSimR_writeASGenotypes`, g, locations, allLocations, snpchips, names, missing, fname))
-}
-
-writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call(`_AlphaSimR_writeASHaplotypes`, g, locations, allLocations, snpchips, names, missing, fname))
-}
-
 getGeno <- function(geno, lociPerChr, lociLoc) {
     .Call(`_AlphaSimR_getGeno`, geno, lociPerChr, lociLoc)
 }
@@ -146,6 +122,30 @@ calcCoef <- function(X, Y) {
     .Call(`_AlphaSimR_calcCoef`, X, Y)
 }
 
+callRRBLUP <- function(y, x, reps, genoTrain, nMarker, skip) {
+    .Call(`_AlphaSimR_callRRBLUP`, y, x, reps, genoTrain, nMarker, skip)
+}
+
+callRRBLUP2 <- function(y, x, reps, genoTrain, nMarker, skip, Vu, Ve, tol, maxIter, useEM) {
+    .Call(`_AlphaSimR_callRRBLUP2`, y, x, reps, genoTrain, nMarker, skip, Vu, Ve, tol, maxIter, useEM)
+}
+
+callRRBLUP_D <- function(y, x, reps, genoTrain, nMarker, skip, maxIter, useHetCov) {
+    .Call(`_AlphaSimR_callRRBLUP_D`, y, x, reps, genoTrain, nMarker, skip, maxIter, useHetCov)
+}
+
+callRRBLUP_MV <- function(Y, x, reps, genoTrain, nMarker, skip, maxIter) {
+    .Call(`_AlphaSimR_callRRBLUP_MV`, Y, x, reps, genoTrain, nMarker, skip, maxIter)
+}
+
+callRRBLUP_GCA <- function(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter) {
+    .Call(`_AlphaSimR_callRRBLUP_GCA`, y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter)
+}
+
+callRRBLUP_SCA <- function(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter, useHetCov) {
+    .Call(`_AlphaSimR_callRRBLUP_SCA`, y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter, useHetCov)
+}
+
 packHaplo <- function(haplo, ploidy, inbred) {
     .Call(`_AlphaSimR_packHaplo`, haplo, ploidy, inbred)
 }

---FILE: R/founderPop.R---
@@ -150,7 +150,10 @@ trackHaploPop = function(genMap,nInd,inbred=FALSE){
 #' @param species species history to simulate. See details.
 #' @param split an optional historic population split in terms of generations ago.
 #' @param manualCommand user provided MaCS options. For advanced users only.
-#' @param manualGenLen user provided genLen option for use with manual command. 
+#' @param manualGenLen user provided genetic length. This must be supplied if using 
+#' manualCommand. If not using manualCommand, this value will replace the predefined 
+#' genetic length for the species. However, this the genetic length is only used by 
+#' AlphaSimR and is not passed to MaCS, so MaCS still uses the predefined genetic length. 
 #' For advanced users only.
 #' @param suppressMessages should messages on status be suppressed
 #' 
@@ -167,36 +170,23 @@ trackHaploPop = function(genMap,nInd,inbred=FALSE){
 #' 
 #' @export
 runMacs = function(nInd,nChr=1,segSites=NULL,inbred=FALSE,species=""GENERIC"",
-                   split=NULL,manualCommand=NULL,manualGenLen=NULL,suppressMessages=FALSE){
+                   split=NULL,manualCommand=NULL,manualGenLen=NULL,
+                   suppressMessages=FALSE){
   nInd = as.integer(nInd)
   ploidy = 2L #The only ploidy level currently supported
   if(is.null(segSites)){
     segSites = rep(0,nChr)
   }else if(length(segSites)==1){
     segSites = rep(segSites,nChr)
   }
-  if(inbred){
-    popSize = nInd
-  }else{
-    popSize = ploidy*nInd
-  }
+  popSize = ifelse(inbred,nInd,ploidy*nInd)
   if(!is.null(manualCommand)){
     if(is.null(manualGenLen)) stop(""You must define manualGenLen"")
     command = paste(popSize,manualCommand,""-s"",sample.int(1e8,1))
     genLen = manualGenLen
   }else{
     species = toupper(species)
-    if(species==""WHEAT""){ #WHEAT----
-      genLen = 1.43
-      Ne = 50
-      speciesParams = ""800000000 -t 0.40E-06 -r 0.36E-06""
-      speciesHist = ""-eN 0.03 1 -eN 0.05 2 -eN 0.10 4 -eN 0.15 6 -eN 0.20 8 -eN 0.25 10 -eN 0.30 12 -eN 0.35 14 -eN 0.40 16 -eN 0.45 18 -eN 0.50 20 -eN 1.00 40 -eN 2.00 60 -eN 3.00 80 -eN 4.00 100 -eN 5.00 120 -eN 10.00 140 -eN 20.00 160 -eN 30.00 180 -eN 40.00 200 -eN 50.00 240 -eN 100.00 320 -eN 200.00 400 -eN 300.00 480 -eN 400.00 560 -eN 500.00 640""
-    }else if(species==""MAIZE""){ #MAIZE----
-      genLen = 2.0
-      Ne = 100
-      speciesParams = ""200000000 -t 0.50E-05 -r 0.40E-05""
-      speciesHist = ""-eN 0.03 1 -eN 0.05 2 -eN 0.10 4 -eN 0.15 6 -eN 0.20 8 -eN 0.25 10 -eN 0.30 12 -eN 0.35 14 -eN 0.40 16 -eN 0.45 18 -eN 0.50 20 -eN 2.00 40 -eN 3.00 60 -eN 4.00 80 -eN 5.00 100""
-    }else if(species==""GENERIC""){ #GENERIC----
+    if(species==""GENERIC""){ #GENERIC----
       genLen = 1.0
       Ne = 100
       speciesParams = ""100000000 -t 0.10E-04 -r 0.40E-05""
@@ -206,6 +196,16 @@ runMacs = function(nInd,nChr=1,segSites=NULL,inbred=FALSE,species=""GENERIC"",
       Ne = 90
       speciesParams = ""100000000 -t 9e-6 -r 3.6e-06""
       speciesHist = ""-eN 0.011 1.33 -eN 0.019 2.78 -eN 0.036 3.89 -eN 0.053 11.11 -eN 0.069 16.67 -eN 0.431 22.22 -eN 1.264 27.78 -eN 1.819 38.89 -eN 4.875 77.78 -eN 6.542 111.11 -eN 9.319 188.89 -eN 92.097 688.89 -eN 2592.097 688.89""
+    }else if(species==""WHEAT""){ #WHEAT----
+      genLen = 1.43
+      Ne = 50
+      speciesParams = ""800000000 -t 0.40E-06 -r 0.36E-06""
+      speciesHist = ""-eN 0.03 1 -eN 0.05 2 -eN 0.10 4 -eN 0.15 6 -eN 0.20 8 -eN 0.25 10 -eN 0.30 12 -eN 0.35 14 -eN 0.40 16 -eN 0.45 18 -eN 0.50 20 -eN 1.00 40 -eN 2.00 60 -eN 3.00 80 -eN 4.00 100 -eN 5.00 120 -eN 10.00 140 -eN 20.00 160 -eN 30.00 180 -eN 40.00 200 -eN 50.00 240 -eN 100.00 320 -eN 200.00 400 -eN 300.00 480 -eN 400.00 560 -eN 500.00 640""
+    }else if(species==""MAIZE""){ #MAIZE----
+      genLen = 2.0
+      Ne = 100
+      speciesParams = ""200000000 -t 0.50E-05 -r 0.40E-05""
+      speciesHist = ""-eN 0.03 1 -eN 0.05 2 -eN 0.10 4 -eN 0.15 6 -eN 0.20 8 -eN 0.25 10 -eN 0.30 12 -eN 0.35 14 -eN 0.40 16 -eN 0.45 18 -eN 0.50 20 -eN 2.00 40 -eN 3.00 60 -eN 4.00 80 -eN 5.00 100"" 
     }else if(species==""EUROPEAN""){ #EUROPEAN----
       genLen = 1.3
       Ne = 512000
@@ -224,6 +224,9 @@ runMacs = function(nInd,nChr=1,segSites=NULL,inbred=FALSE,species=""GENERIC"",
     }
     command = paste0(popSize,"" "",speciesParams,splitI,"" "",speciesHist,splitJ,"" -s "",sample.int(1e8,1))
   }
+  if(!is.null(manualGenLen)){
+    genLen = manualGenLen
+  }
   output = vector(""list"",nChr)
   for(chr in 1:nChr){
     if(!suppressMessages){
@@ -252,10 +255,12 @@ runMacs = function(nInd,nChr=1,segSites=NULL,inbred=FALSE,species=""GENERIC"",
 #' @title Alternative wrapper for MaCS
 #'
 #' @description 
-#' A wrapper function for \code{\link{runMacs}}. This wrapper 
-#' is an alternative to directly using manualCommand in 
-#' \code{\link{runMacs}}. It automatically creates an appropriate 
-#' manualCommand based on user supplied variables.
+#' A wrapper function for \code{\link{runMacs}}. This wrapper is designed 
+#' to be easier to use than supply custom comands to manualCommand in 
+#' \code{\link{runMacs}}. It effectively automates the creation of an 
+#' appropriate manualCommand using user supplied variables, but only deals  
+#' with a subset of the possibilities. The defaults were chosen to match 
+#' species=""GENERIC"" in \code{\link{runMacs}}.
 #' 
 #' @param nInd number of individuals to simulate
 #' @param nChr number of chromosomes to simulate
@@ -269,32 +274,53 @@ runMacs = function(nInd,nChr=1,segSites=NULL,inbred=FALSE,species=""GENERIC"",
 #' @param histGen number of generations ago for effective 
 #' population sizes given in histNe
 #' @param inbred should founder individuals be inbred
+#' @param split an optional historic population split in terms of generations ago
+#' @param returnCommand should the command passed to manualCommand in 
+#' \code{\link{runMacs}} be returned. If TRUE, MaCS will not be called and 
+#' the command is returned instead.
 #' @param suppressMessages should messages on status be suppressed
 #'
-#' @return an object of \code{\link{MapPop-class}}
+#' @return an object of \code{\link{MapPop-class}} or if 
+#' returnCommand is true a string giving the MaCS command passed 
+#' the manualCommand argument of \code{\link{runMacs}}.
 #' 
 #' @examples 
 #' # Creates a populations of 10 outbred individuals
 #' # Their genome consists of 1 chromosome and 100 segregating sites
-#' # The command is equivalent to using species=""TEST"" in runMacs
+#' # The command is equivalent to using species=""GENERIC"" in runMacs
 #' founderPop = runMacs2(nInd=10,nChr=1,segSites=100)
 #' 
 #' @export
-runMacs2 = function(nInd,nChr,segSites,Ne=100,
+runMacs2 = function(nInd,nChr=1,segSites=NULL,Ne=100,
                     bp=1e8,genLen=1,mutRate=2.5e-8,
-                    histNe=NULL,histGen=NULL,
-                    inbred=FALSE,suppressMessages=FALSE){
+                    histNe=c(500,1250,1500,3500,6000,12000,100000),
+                    histGen=c(100,500,1000,5000,10000,100000,1000000),
+                    inbred=FALSE,split=NULL,returnCommand=FALSE,
+                    suppressMessages=FALSE){
   stopifnot(length(histNe)==length(histGen))
-  command = paste(bp,""-t"",4*Ne*mutRate,
-                  ""-r"",4*Ne*genLen/bp)
+  speciesParams = paste(bp,""-t"",4*Ne*mutRate,
+                        ""-r"",4*Ne*genLen/bp)
+  speciesHist = """"
   if(length(histNe)>0){
     histNe = histNe/Ne
     histGen = histGen/(4*Ne)
     for(i in 1:length(histNe)){
-      command = paste(command,""-eN"",
+      speciesHist = paste(speciesHist,""-eN"",
                       histGen[i],histNe[i])
     }
   }
+  if(is.null(split)){
+    command = paste(speciesParams,speciesHist)
+  }else{
+    popSize = ifelse(inbred,nInd,2*nInd)
+    command = paste(speciesParams,
+                    paste(""-I 2"",popSize%/%2,popSize%/%2),
+                    speciesHist,
+                    paste(""-ej"",split/(4*Ne)+0.000001,""2 1""))
+  }
+  if(returnCommand){
+    return(command)
+  }
   return(runMacs(nInd=nInd,nChr=nChr,segSites=segSites,
                  inbred=inbred,species=""TEST"",split=NULL,
                  manualCommand=command,manualGenLen=genLen,

---FILE: man/runMacs.Rd---
@@ -24,7 +24,10 @@ value of NULL results in all sites being retained.}
 
 \item{manualCommand}{user provided MaCS options. For advanced users only.}
 
-\item{manualGenLen}{user provided genLen option for use with manual command. 
+\item{manualGenLen}{user provided genetic length. This must be supplied if using 
+manualCommand. If not using manualCommand, this value will replace the predefined 
+genetic length for the species. However, this the genetic length is only used by 
+AlphaSimR and is not passed to MaCS, so MaCS still uses the predefined genetic length. 
 For advanced users only.}
 
 \item{suppressMessages}{should messages on status be suppressed}

---FILE: man/runMacs2.Rd---
@@ -4,8 +4,10 @@
 \alias{runMacs2}
 \title{Alternative wrapper for MaCS}
 \usage{
-runMacs2(nInd, nChr, segSites, Ne = 100, bp = 1e+08, genLen = 1,
-  mutRate = 2.5e-08, histNe = NULL, histGen = NULL, inbred = FALSE,
+runMacs2(nInd, nChr = 1, segSites = NULL, Ne = 100, bp = 1e+08,
+  genLen = 1, mutRate = 2.5e-08, histNe = c(500, 1250, 1500, 3500, 6000,
+  12000, 1e+05), histGen = c(100, 500, 1000, 5000, 10000, 1e+05, 1e+06),
+  inbred = FALSE, split = NULL, returnCommand = FALSE,
   suppressMessages = FALSE)
 }
 \arguments{
@@ -31,21 +33,31 @@ population sizes given in histNe}
 
 \item{inbred}{should founder individuals be inbred}
 
+\item{split}{an optional historic population split in terms of generations ago}
+
+\item{returnCommand}{should the command passed to manualCommand in 
+\code{\link{runMacs}} be returned. If TRUE, MaCS will not be called and 
+the command is returned instead.}
+
 \item{suppressMessages}{should messages on status be suppressed}
 }
 \value{
-an object of \code{\link{MapPop-class}}
+an object of \code{\link{MapPop-class}} or if 
+returnCommand is true a string giving the MaCS command passed 
+the manualCommand argument of \code{\link{runMacs}}.
 }
 \description{
-A wrapper function for \code{\link{runMacs}}. This wrapper 
-is an alternative to directly using manualCommand in 
-\code{\link{runMacs}}. It automatically creates an appropriate 
-manualCommand based on user supplied variables.
+A wrapper function for \code{\link{runMacs}}. This wrapper is designed 
+to be easier to use than supply custom comands to manualCommand in 
+\code{\link{runMacs}}. It effectively automates the creation of an 
+appropriate manualCommand using user supplied variables, but only deals  
+with a subset of the possibilities. The defaults were chosen to match 
+species=""GENERIC"" in \code{\link{runMacs}}.
 }
 \examples{
 # Creates a populations of 10 outbred individuals
 # Their genome consists of 1 chromosome and 100 segregating sites
-# The command is equivalent to using species=""TEST"" in runMacs
+# The command is equivalent to using species=""GENERIC"" in runMacs
 founderPop = runMacs2(nInd=10,nChr=1,segSites=100)
 
 }

---FILE: src/RcppExports.cpp---
@@ -6,6 +6,38 @@
 
 using namespace Rcpp;
 
+// writeASGenotypes
+void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP _AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
+END_RCPP
+}
+// writeASHaplotypes
+void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP _AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
+END_RCPP
+}
 // gebvRR
 arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
 RcppExport SEXP _AlphaSimR_gebvRR(SEXP RRsolSEXP, SEXP popSEXP) {
@@ -67,147 +99,6 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// callRRBLUP
-Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip);
-RcppExport SEXP _AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker, skip));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP2
-Rcpp::List callRRBLUP2(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip, double Vu, double Ve, double tol, int maxIter, bool useEM);
-RcppExport SEXP _AlphaSimR_callRRBLUP2(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP VuSEXP, SEXP VeSEXP, SEXP tolSEXP, SEXP maxIterSEXP, SEXP useEMSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< double >::type Vu(VuSEXP);
-    Rcpp::traits::input_parameter< double >::type Ve(VeSEXP);
-    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    Rcpp::traits::input_parameter< bool >::type useEM(useEMSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP2(y, x, reps, genoTrain, nMarker, skip, Vu, Ve, tol, maxIter, useEM));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_D
-Rcpp::List callRRBLUP_D(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip, int maxIter, bool useHetCov);
-RcppExport SEXP _AlphaSimR_callRRBLUP_D(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP, SEXP useHetCovSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    Rcpp::traits::input_parameter< bool >::type useHetCov(useHetCovSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_D(y, x, reps, genoTrain, nMarker, skip, maxIter, useHetCov));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_MV
-Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip, int maxIter);
-RcppExport SEXP _AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker, skip, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_GCA
-Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker, int skip, int maxIter);
-RcppExport SEXP _AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_SCA
-Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker, int skip, int maxIter, bool useHetCov);
-RcppExport SEXP _AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP, SEXP useHetCovSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    Rcpp::traits::input_parameter< bool >::type useHetCov(useHetCovSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter, useHetCov));
-    return rcpp_result_gen;
-END_RCPP
-}
-// writeASGenotypes
-void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP _AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
-END_RCPP
-}
-// writeASHaplotypes
-void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP _AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
-END_RCPP
-}
 // getGeno
 arma::Mat<unsigned char> getGeno(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
 RcppExport SEXP _AlphaSimR_getGeno(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
@@ -465,6 +356,115 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// callRRBLUP
+Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip);
+RcppExport SEXP _AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker, skip));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP2
+Rcpp::List callRRBLUP2(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip, double Vu, double Ve, double tol, int maxIter, bool useEM);
+RcppExport SEXP _AlphaSimR_callRRBLUP2(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP VuSEXP, SEXP VeSEXP, SEXP tolSEXP, SEXP maxIterSEXP, SEXP useEMSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    Rcpp::traits::input_parameter< double >::type Vu(VuSEXP);
+    Rcpp::traits::input_parameter< double >::type Ve(VeSEXP);
+    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    Rcpp::traits::input_parameter< bool >::type useEM(useEMSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP2(y, x, reps, genoTrain, nMarker, skip, Vu, Ve, tol, maxIter, useEM));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_D
+Rcpp::List callRRBLUP_D(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip, int maxIter, bool useHetCov);
+RcppExport SEXP _AlphaSimR_callRRBLUP_D(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP, SEXP useHetCovSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    Rcpp::traits::input_parameter< bool >::type useHetCov(useHetCovSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_D(y, x, reps, genoTrain, nMarker, skip, maxIter, useHetCov));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_MV
+Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip, int maxIter);
+RcppExport SEXP _AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker, skip, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_GCA
+Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker, int skip, int maxIter);
+RcppExport SEXP _AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_SCA
+Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker, int skip, int maxIter, bool useHetCov);
+RcppExport SEXP _AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP, SEXP useHetCovSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    Rcpp::traits::input_parameter< bool >::type useHetCov(useHetCovSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter, useHetCov));
+    return rcpp_result_gen;
+END_RCPP
+}
 // packHaplo
 arma::Cube<unsigned char> packHaplo(arma::Mat<unsigned char>& haplo, arma::uword ploidy, bool inbred);
 RcppExport SEXP _AlphaSimR_packHaplo(SEXP haploSEXP, SEXP ploidySEXP, SEXP inbredSEXP) {"
gaynorr,AlphaSimR,60d9364135f8b7b0414201815e54222f4901dfa3,gregor_gorjanc,gregor.gorjanc@gmail.com,2018-07-23T09:59:40Z,gregor_gorjanc,gregor.gorjanc@gmail.com,2018-07-23T09:59:40Z,Bugfix,R/pullGeno.R,False,True,True,False,1,1,2,"---FILE: R/pullGeno.R---
@@ -563,7 +563,7 @@ pullIbdHaplo = function(pop = NULL, chr = NULL, snpChip = NULL, pedigree = NULL,
                            rep(x = 1L:simParam$ploidy, times = nInd), sep = ""_"")
   if (!is.null(pop)) {
     Sel = paste(rep(x = pop@id,             each  = simParam$ploidy),
-                rep(x = 1L:simParam$ploidy, times = simParam$nInd), sep = ""_"")
+                rep(x = 1L:simParam$ploidy, times = pop@nInd), sep = ""_"")
     output = output[Sel, ]
   }
   return(output)"
gaynorr,AlphaSimR,2483a965ba0edbd2bbdad5067e7838c8cd7a0bb8,gregor_gorjanc,gregor.gorjanc@gmail.com,2018-07-20T18:29:48Z,gregor_gorjanc,gregor.gorjanc@gmail.com,2018-07-20T18:33:51Z,Bugfix,R/pullGeno.R,False,True,True,False,1,1,2,"---FILE: R/pullGeno.R---
@@ -453,7 +453,7 @@ pullIbdHaplo = function(pop = NULL, chr = NULL, snpChip = NULL, pedigree = NULL,
   if (is.null(simParam)) {
     simParam = get(x = ""SP"", envir = .GlobalEnv)
   }
-  if (simParam@ploidy != 2L) {
+  if (simParam$ploidy != 2L) {
     stop(""pullIbdHaplo() works (currently) only with diploids!"")
   }
   if (!simParam$isTrackRec) {"
gaynorr,AlphaSimR,adc6ed8aa23dbc72e2dc01fba5891602635fda86,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-06-12T14:38:31Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-06-12T14:38:31Z,-fixed bug in setPhenoGCA,R/hybrids.R,False,True,True,False,1,1,2,"---FILE: R/hybrids.R---
@@ -266,7 +266,7 @@ setPhenoGCA = function(pop,testers,use=""pheno"",varE=NULL,reps=1,
     stop(paste0(""use="",use,"" is not a valid option""))
   }
   #
-  female = factor(pop@id,levels=unique(pop@id))
+  female = factor(tmp@mother,levels=unique(tmp@mother))
   if(nlevels(female)==1){
     GCAf = matrix(colMeans(y),nrow=1)
   }else{"
gaynorr,AlphaSimR,554e8bc56825882e9308234c7b2d36f6437d5963,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-06-08T12:32:51Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-06-08T12:32:51Z,-fixed population subsetting checks to prevent invalid selections,NEWS;R/Class-Pop.R;R/selection.R,False,True,True,False,12,2,14,"---FILE: NEWS---
@@ -8,7 +8,7 @@ Changes in version 0.7.0
     -improved speed by replacing Rcpp random number generators
     
   Bug fixes
-    -
+    -fixed population subsetting checks to prevent invalid selections
 
 Changes in version 0.6.1
 

---FILE: R/Class-Pop.R---
@@ -64,6 +64,9 @@ setValidity(""RawPop"",function(object){
 setMethod(""["",
           signature(x = ""RawPop""),
           function(x, i){
+            if(any(abs(i)>x@nInd)){
+              stop(""Trying to select invalid individuals"")
+            }
             for(chr in 1:x@nChr){
               x@geno[[chr]] = x@geno[[chr]][,,i,drop=FALSE]
             }
@@ -134,6 +137,9 @@ setValidity(""MapPop"",function(object){
 setMethod(""["",
           signature(x = ""MapPop""),
           function(x, i){
+            if(any(abs(i)>x@nInd)){
+              stop(""Trying to select invalid individuals"")
+            }
             for(chr in 1:x@nChr){
               x@geno[[chr]] = x@geno[[chr]][,,i,drop=FALSE]
             }
@@ -263,6 +269,10 @@ setMethod(""["",
           function(x, i){
             if(is.character(i)){
               i = x@id%in%i
+            }else{
+              if(any(abs(i)>x@nInd)){
+                stop(""Trying to select invalid individuals"")
+              }
             }
             x@id = x@id[i]
             x@mother = x@mother[i]

---FILE: R/selection.R---
@@ -114,7 +114,7 @@ selectInd = function(pop,nInd,trait=1,use=""pheno"",gender=""B"",
     simParam = get(""SP"",envir=.GlobalEnv)
   }
   eligible = checkGender(pop=pop,gender=gender,simParam=simParam)
-  if(sum(eligible)<nInd){
+  if(length(eligible)<nInd){
     stop(""Not enough suitable candidates, check request value and gender"")
   }
   response = getResponse(pop=pop,trait=trait,use=use,"
gaynorr,AlphaSimR,59ed7e20a0580bbb7a74d482c3f842b5f693992e,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-05-07T10:58:15Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-05-07T10:58:15Z,"-Fixed bug in setPhenoGCA
-Fixed bug in selectFam
-Added half-sib families to selectFam and selectWithinFam",DESCRIPTION;R/hybrids.R;R/selection.R;man/selectFam.Rd;man/selectWithinFam.Rd,False,True,True,False,39,14,53,"---FILE: DESCRIPTION---
@@ -1,7 +1,7 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 0.6.0
+Version: 0.6.1
 Date: 2018-3-9
 Authors@R: c(person(""Chris"",""Gaynor"",email=""gaynor.robert@hotmail.com"",role=""cre""),person(""Gregor"",""Gorjanc"",role=""ctb""),person(""David"",""Wilson"",role=""ctb""),person(""Daniel"",""Money"",role=""ctb""),person(""John"",""Hickey"",role=""ctb""))
 Description: This package contains classes and functions for simulating plant and animal breeding programs.

---FILE: R/hybrids.R---
@@ -220,11 +220,6 @@ setPhenoGCA = function(pop,testers,use=""pheno"",varE=NULL,reps=1,
   }
   stopifnot(class(pop)==""Pop"",class(testers)==""Pop"")
   use = tolower(use)
-  if(use == ""pheno""){
-    if(is.null(varE)){
-      stop(""varE must be specified if use=\""pheno\"""")
-    }
-  }
   tmp = hybridCross(females=pop,males=testers,crossPlan=""testcross"",
                     returnHybridPop=inbred,chunkSize=chunkSize,simParam=simParam)
   if(use==""pheno""){

---FILE: R/selection.R---
@@ -64,6 +64,20 @@ checkGender = function(pop,gender,simParam){
   }
 }
 
+# Returns a vector of families
+getFam = function(pop,famType){
+  famType = toupper(famType)
+  if(famType==""B""){
+    return(paste(pop@mother,pop@father,sep=""_""))
+  }else if(famType==""F""){
+    return(pop@mother)
+  }else if(famType==""M""){
+    return(pop@father)
+  }else{
+    stop(paste0(""famType="",famType,"" is not a valid option""))
+  }
+}
+
 #' @title Select individuals
 #' 
 #' @description Selects a subset of nInd individuals from a 
@@ -130,6 +144,9 @@ selectInd = function(pop,nInd,trait=1,use=""pheno"",gender=""B"",
 #' @param gender which gender to select. Use ""B"" for both, ""F"" for 
 #' females and ""M"" for males. If the simulation is not using gender, 
 #' the argument is ignored.
+#' @param famType which type of family to select. Use ""B"" for 
+#' full-sib families, ""F"" for half-sib families on female side and ""M"" 
+#' for half-sib families on the male side.
 #' @param selectTop selects highest values if true. 
 #' Selects lowest values if false.
 #' @param returnPop should results be returned as a 
@@ -144,20 +161,20 @@ selectInd = function(pop,nInd,trait=1,use=""pheno"",gender=""B"",
 #' 
 #' @export
 selectFam = function(pop,nFam,trait=1,use=""pheno"",gender=""B"",
-                     selectTop=TRUE,returnPop=TRUE,
+                     famType=""B"",selectTop=TRUE,returnPop=TRUE,
                      simParam=NULL,...){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
   eligible = checkGender(pop=pop,gender=gender,simParam=simParam)
-  allFam = paste(pop@mother,pop@father,sep=""_"")
-  availFam = paste(pop@mother[eligible],pop@father[eligible],sep=""_"")
+  allFam = getFam(pop=pop,famType=famType)
+  availFam = allFam[eligible]
   if(nFam>length(unique(availFam))){
     stop(paste(nFam,""families requested but only"",length(unique(availFam)),
                ""families are available""))
   }
   response = getResponse(pop=pop,trait=trait,use=use,
-                         simParam=simParam,...)[eligible,,drop=FALSE]
+                         simParam=simParam,...)[eligible]
   #Calculate family means
   famMeans = aggregate(response,list(families=availFam),mean)
   response = famMeans$x
@@ -190,6 +207,9 @@ selectFam = function(pop,nFam,trait=1,use=""pheno"",gender=""B"",
 #' @param gender which gender to select. Use ""B"" for both, ""F"" for 
 #' females and ""M"" for males. If the simulation is not using gender, 
 #' the argument is ignored.
+#' @param famType which type of family to select. Use ""B"" for 
+#' full-sib families, ""F"" for half-sib families on female side and ""M"" 
+#' for half-sib families on the male side.
 #' @param selectTop selects highest values if true. 
 #' Selects lowest values if false.
 #' @param returnPop should results be returned as a 
@@ -204,13 +224,13 @@ selectFam = function(pop,nFam,trait=1,use=""pheno"",gender=""B"",
 #' 
 #' @export
 selectWithinFam = function(pop,nInd,trait=1,use=""pheno"",gender=""B"",
-                           selectTop=TRUE,returnPop=TRUE,
+                           famType=""B"",selectTop=TRUE,returnPop=TRUE,
                            simParam=NULL,...){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
   eligible = checkGender(pop=pop,gender=gender,simParam=simParam)
-  families = paste(pop@mother,pop@father,sep=""_"")
+  families = getFam(pop=pop,famType=famType)
   response = getResponse(pop=pop,trait=trait,use=use,
                          simParam=simParam,...)
   selInFam = function(selFam){

---FILE: man/selectFam.Rd---
@@ -5,7 +5,8 @@
 \title{Select families}
 \usage{
 selectFam(pop, nFam, trait = 1, use = ""pheno"", gender = ""B"",
-  selectTop = TRUE, returnPop = TRUE, simParam = NULL, ...)
+  famType = ""B"", selectTop = TRUE, returnPop = TRUE, simParam = NULL,
+  ...)
 }
 \arguments{
 \item{pop}{and object of \code{\link{Pop-class}} or 
@@ -24,6 +25,10 @@ or randomly ""rand""}
 females and ""M"" for males. If the simulation is not using gender, 
 the argument is ignored.}
 
+\item{famType}{which type of family to select. Use ""B"" for 
+full-sib families, ""F"" for half-sib families on female side and ""M"" 
+for half-sib families on the male side.}
+
 \item{selectTop}{selects highest values if true. 
 Selects lowest values if false.}
 

---FILE: man/selectWithinFam.Rd---
@@ -5,7 +5,8 @@
 \title{Select individuals within families}
 \usage{
 selectWithinFam(pop, nInd, trait = 1, use = ""pheno"", gender = ""B"",
-  selectTop = TRUE, returnPop = TRUE, simParam = NULL, ...)
+  famType = ""B"", selectTop = TRUE, returnPop = TRUE, simParam = NULL,
+  ...)
 }
 \arguments{
 \item{pop}{and object of \code{\link{Pop-class}} or 
@@ -24,6 +25,10 @@ or randomly ""rand""}
 females and ""M"" for males. If the simulation is not using gender, 
 the argument is ignored.}
 
+\item{famType}{which type of family to select. Use ""B"" for 
+full-sib families, ""F"" for half-sib families on female side and ""M"" 
+for half-sib families on the male side.}
+
 \item{selectTop}{selects highest values if true. 
 Selects lowest values if false.}
 "
gaynorr,AlphaSimR,4c6b03040f39dfd647081b9dcb5aaedfca6013e6,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-04-12T13:56:40Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-04-12T13:56:40Z,"-Added NEWS file
-Added selectOP to model selection in open pollinating plants
-Added runMacs2 as a wrapper for runMacs
-Fixed error when using H2 in SimParam_setVarE",NAMESPACE;NEWS;R/Class-SimParam.R;R/RcppExports.R;R/crossing.R;R/founderPop.R;R/hybrids.R;R/selection.R;man/RRBLUP_GCA.Rd;man/RRBLUP_SCA.Rd;man/runMacs2.Rd;man/selectCross.Rd;man/selectOP.Rd;src/RcppExports.cpp;src/init.c;src/misc.cpp;vignettes/GS.Rmd;vignettes/SI.Rmd;vignettes/crossing.Rmd;vignettes/hybrids.Rmd;vignettes/intro.Rmd;vignettes/maize.Rmd;vignettes/quickref.Rmd;vignettes/traits.Rmd;vignettes/wheat.Rmd,True,True,True,False,527,172,699,"---FILE: NAMESPACE---
@@ -44,12 +44,14 @@ export(randCross)
 export(randCross2)
 export(resetPop)
 export(runMacs)
+export(runMacs2)
 export(sampleHaplo)
 export(selIndex)
 export(selInt)
 export(selectCross)
 export(selectFam)
 export(selectInd)
+export(selectOP)
 export(selectWithinFam)
 export(self)
 export(setEBV)

---FILE: NEWS---
@@ -0,0 +1,10 @@
+Changes in version 0.6.0
+
+  New features
+    -Added NEWS file
+    -Added selectOP to model selection in open pollinating plants
+    -Added runMacs2 as a wrapper for runMacs
+    
+  Bug fixes
+    -Fixed error when using H2 in SimParam_setVarE
+    
\ No newline at end of file

---FILE: R/Class-SimParam.R---
@@ -587,7 +587,7 @@ SimParam$set(
       stopifnot(length(H2)==private$.nTraits)
       varE = numeric(private$.nTraits)
       for(i in 1:length(h2)){
-        tmp = private$.varG[i]/h2[i]-private$.varG[i]
+        tmp = private$.varG[i]/H2[i]-private$.varG[i]
         varE[i] = tmp
       }
       private$.varE = varE

---FILE: R/RcppExports.R---
@@ -1,14 +1,6 @@
 # Generated by using Rcpp::compileAttributes() -> do not edit by hand
 # Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393
 
-writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call(`_AlphaSimR_writeASGenotypes`, g, locations, allLocations, snpchips, names, missing, fname))
-}
-
-writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call(`_AlphaSimR_writeASHaplotypes`, g, locations, allLocations, snpchips, names, missing, fname))
-}
-
 gebvRR <- function(RRsol, pop) {
     .Call(`_AlphaSimR_gebvRR`, RRsol, pop)
 }
@@ -29,6 +21,34 @@ gegvSCA <- function(sol, pop) {
     .Call(`_AlphaSimR_gegvSCA`, sol, pop)
 }
 
+callRRBLUP <- function(y, x, reps, genoTrain, nMarker, skip) {
+    .Call(`_AlphaSimR_callRRBLUP`, y, x, reps, genoTrain, nMarker, skip)
+}
+
+callRRBLUP_D <- function(y, x, reps, genoTrain, nMarker, skip, maxIter, useHetCov) {
+    .Call(`_AlphaSimR_callRRBLUP_D`, y, x, reps, genoTrain, nMarker, skip, maxIter, useHetCov)
+}
+
+callRRBLUP_MV <- function(Y, x, reps, genoTrain, nMarker, skip, maxIter) {
+    .Call(`_AlphaSimR_callRRBLUP_MV`, Y, x, reps, genoTrain, nMarker, skip, maxIter)
+}
+
+callRRBLUP_GCA <- function(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter) {
+    .Call(`_AlphaSimR_callRRBLUP_GCA`, y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter)
+}
+
+callRRBLUP_SCA <- function(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter, useHetCov) {
+    .Call(`_AlphaSimR_callRRBLUP_SCA`, y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter, useHetCov)
+}
+
+writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call(`_AlphaSimR_writeASGenotypes`, g, locations, allLocations, snpchips, names, missing, fname))
+}
+
+writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call(`_AlphaSimR_writeASHaplotypes`, g, locations, allLocations, snpchips, names, missing, fname))
+}
+
 getGeno <- function(geno, lociPerChr, lociLoc) {
     .Call(`_AlphaSimR_getGeno`, geno, lociPerChr, lociLoc)
 }
@@ -98,6 +118,10 @@ mergeMultGeno <- function(popList, nInd, nLoci, ploidy) {
     .Call(`_AlphaSimR_mergeMultGeno`, popList, nInd, nLoci, ploidy)
 }
 
+mergeMultIntMat <- function(X, nRow, nCol) {
+    .Call(`_AlphaSimR_mergeMultIntMat`, X, nRow, nCol)
+}
+
 calcChrFreq <- function(geno) {
     .Call(`_AlphaSimR_calcChrFreq`, geno)
 }
@@ -118,26 +142,6 @@ calcCoef <- function(X, Y) {
     .Call(`_AlphaSimR_calcCoef`, X, Y)
 }
 
-callRRBLUP <- function(y, x, reps, genoTrain, nMarker, skip) {
-    .Call(`_AlphaSimR_callRRBLUP`, y, x, reps, genoTrain, nMarker, skip)
-}
-
-callRRBLUP_D <- function(y, x, reps, genoTrain, nMarker, skip, maxIter, useHetCov) {
-    .Call(`_AlphaSimR_callRRBLUP_D`, y, x, reps, genoTrain, nMarker, skip, maxIter, useHetCov)
-}
-
-callRRBLUP_MV <- function(Y, x, reps, genoTrain, nMarker, skip, maxIter) {
-    .Call(`_AlphaSimR_callRRBLUP_MV`, Y, x, reps, genoTrain, nMarker, skip, maxIter)
-}
-
-callRRBLUP_GCA <- function(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter) {
-    .Call(`_AlphaSimR_callRRBLUP_GCA`, y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter)
-}
-
-callRRBLUP_SCA <- function(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter, useHetCov) {
-    .Call(`_AlphaSimR_callRRBLUP_SCA`, y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter, useHetCov)
-}
-
 packHaplo <- function(haplo, ploidy, inbred) {
     .Call(`_AlphaSimR_packHaplo`, haplo, ploidy, inbred)
 }

---FILE: R/crossing.R---
@@ -141,15 +141,15 @@ randCross = function(pop,nCrosses,nProgeny=1,
 #' if nInd is set.
 #' @param nMale the number of males to select. This value is ignored 
 #' if nInd is set.
+#' @param nCrosses total number of crosses to make
+#' @param nProgeny number of progeny per cross
 #' @param trait the trait for selection. Either a number indicating 
 #' a single trait or a function returning a vector of length nInd.
 #' @param use select on genetic values ""gv"", estimated
 #' breeding values ""ebv"", breeding values ""bv"", phenotypes ""pheno"", 
 #' or randomly ""rand""
 #' @param selectTop selects highest values if true. 
 #' Selects lowest values if false.
-#' @param nCrosses total number of crosses to make
-#' @param nProgeny number of progeny per cross
 #' @param simParam an object of \code{\link{SimParam}}
 #' @param ... additional arguments if using a function for 
 #' trait
@@ -160,8 +160,8 @@ randCross = function(pop,nCrosses,nProgeny=1,
 #' @return Returns an object of \code{\link{Pop-class}}
 #' 
 #' @export
-selectCross = function(pop,nInd=NULL,nFemale=NULL,nMale=NULL,trait=1,
-                       selectTop=TRUE,use=""pheno"",nCrosses,nProgeny=1,
+selectCross = function(pop,nInd=NULL,nFemale=NULL,nMale=NULL,nCrosses,
+                       nProgeny=1,trait=1,use=""pheno"",selectTop=TRUE,
                        simParam=NULL,...,balance=TRUE){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)

---FILE: R/founderPop.R---
@@ -176,7 +176,7 @@ runMacs = function(nInd,nChr,segSites,inbred=FALSE,species=""TEST"",
   }
   if(!is.null(manualCommand)){
     if(is.null(manualGenLen)) stop(""You must define manualGenLen"")
-    command = paste0(popSize,"" "",manualCommand,"" -s "",sample.int(1e8,1))
+    command = paste(popSize,manualCommand,""-s"",sample.int(1e8,1))
     genLen = manualGenLen
   }else{
     species = toupper(species)
@@ -254,6 +254,56 @@ runMacs = function(nInd,nChr,segSites,inbred=FALSE,species=""TEST"",
   return(output)
 }
 
+#' @title Alternative wrapper for MaCS
+#'
+#' @description 
+#' A wrapper function for \code{\link{runMacs}}. This wrapper 
+#' is an alternative to directly using manualCommand in 
+#' \code{\link{runMacs}}. It automatically creates an appropriate 
+#' manualCommand based on user supplied variables.
+#' 
+#' @param nInd number of individuals to simulate
+#' @param nChr number of chromosomes to simulate
+#' @param segSites number of segregating sites to keep per chromosome
+#' @param Ne effective population size
+#' @param bp base pair length of chromosome
+#' @param genLen genetic length of chromosome in Morgans
+#' @param mutRate per base pair mutation rate
+#' @param histNe effective population size in previous 
+#' generations
+#' @param histGen number of generations ago for effective 
+#' population sizes given in histNe
+#' @param inbred should founder individuals be inbred
+#'
+#' @return an object of \code{\link{MapPop-class}}
+#' 
+#' @examples 
+#' # Creates a populations of 10 outbred individuals
+#' # Their genome consists of 1 chromosome and 100 segregating sites
+#' # The command is equivalent to using species=""TEST"" in runMacs
+#' founderPop = runMacs2(nInd=10,nChr=1,segSites=100)
+#' 
+#' @export
+runMacs2 = function(nInd,nChr,segSites,Ne=100,
+                    bp=1e8,genLen=1,mutRate=2.5e-8,
+                    histNe=NULL,histGen=NULL,
+                    inbred=FALSE){
+  stopifnot(length(histNe)==length(histGen))
+  command = paste(bp,""-t"",4*Ne*mutRate,
+                  ""-r"",4*Ne*genLen/bp)
+  if(length(histNe)>0){
+    histNe = histNe/Ne
+    histGen = histGen/(4*Ne)
+    for(i in 1:length(histNe)){
+      command = paste(command,""-eN"",
+                      histGen[i],histNe[i])
+    }
+  }
+  return(runMacs(nInd=nInd,nChr=nChr,segSites=segSites,
+                 inbred=inbred,species=""TEST"",split=NULL,
+                 manualCommand=command,manualGenLen=genLen))
+}
+
 #' @title Sample haplotypes from a MapPop
 #'
 #' @description 

---FILE: R/hybrids.R---
@@ -60,10 +60,15 @@ hybridCross = function(females,males,crossPlan=""testcross"",
     stop(""Only works with diploids"")
   }
   #crossPlan for test cross
-  if(crossPlan==""testcross""){
-    crossPlan = cbind(rep(1:females@nInd,each=males@nInd),
-                      rep(1:males@nInd,females@nInd))
+  if(length(crossPlan)==1){
+    if(crossPlan==""testcross""){
+      crossPlan = cbind(rep(1:females@nInd,each=males@nInd),
+                        rep(1:males@nInd,females@nInd))
+    }else{
+      stop(paste0(""crossPlan="",crossPlan,"" is not a valid option""))
+    }
   }
+  
   #Set id
   femaleParents = females@id[crossPlan[,1]]
   maleParents = males@id[crossPlan[,2]]

---FILE: R/selection.R---
@@ -231,3 +231,60 @@ selectWithinFam = function(pop,nInd,trait=1,use=""pheno"",gender=""B"",
     return(take)
   }
 }
+
+#' @title Select open pollinating plants
+#' 
+#' @description 
+#' This function models selection in an open pollinating 
+#' plant population. It allows for varying the percentage of 
+#' selfing. The function also provides an option for modeling 
+#' selection as occuring before or after pollination.
+#' 
+#' @param pop an object of \code{\link{Pop-class}}
+#' @param nInd the number of plants to select
+#' @param nSeeds number of seeds per plant
+#' @param probSelf percentage of seeds expected from selfing. 
+#' Value ranges from 0 to 1.
+#' @param pollenControl are plants selected before pollination
+#' @param trait the trait for selection. Either a number indicating 
+#' a single trait or a function returning a vector of length nInd.
+#' @param use select on genetic values ""gv"", estimated
+#' breeding values ""ebv"", breeding values ""bv"", phenotypes ""pheno"", 
+#' or randomly ""rand""
+#' @param selectTop selects highest values if true. 
+#' Selects lowest values if false.
+#' @param simParam an object of \code{\link{SimParam}}
+#' @param ... additional arguments if using a function for 
+#' trait
+#' @param balance if using gender, this option will balance the number 
+#' of progeny per parent. This argument occurs after ..., so the argument 
+#' name must be matched exactly.
+#' 
+#' @return Returns an object of \code{\link{Pop-class}}
+#' 
+#' @export
+selectOP = function(pop,nInd,nSeeds,probSelf=0,
+                    pollenControl=FALSE,trait=1,
+                    use=""pheno"",selectTop=TRUE,
+                    simParam=NULL,...){
+  if(is.null(simParam)){
+    simParam = get(""SP"",envir=.GlobalEnv)
+  }
+  female = selectInd(pop=pop,nInd=nInd,trait=trait,
+                     use=use,gender=""B"",selectTop=selectTop,
+                     returnPop=FALSE,simParam=simParam,...)
+  nSelf = rbinom(n=nInd,prob=probSelf,size=nSeeds)
+  if(pollenControl){
+    male = female
+  }else{
+    male = 1:nInd
+  }
+  crossPlan = lapply(1:nInd,function(x){
+    cbind(rep(female[x],nSeeds),
+          c(rep(female[x],nSelf[x]),
+            sample(male[!male==female[x]],nSeeds-nSelf[x],replace=TRUE)))
+  })
+  crossPlan = mergeMultIntMat(crossPlan,rep(nSeeds,nInd),2L)
+  return(makeCross(pop=pop,crossPlan=crossPlan,
+                   rawPop=FALSE,simParam=simParam))
+}

---FILE: man/RRBLUP_GCA.Rd---
@@ -24,6 +24,7 @@ or phenotypes (\code{pheno}, default)}
 }
 \description{
 Fits an RR-BLUP model that estimates seperate marker effects for
-the female and male gametes. Used for predicting GCA of parents
-in single cross hybrids.
+females and males. Useful for predicting GCA of parents
+in single cross hybrids. Can also predict performance of specific 
+single cross hybrids.
 }

---FILE: man/RRBLUP_SCA.Rd---
@@ -29,7 +29,7 @@ RRBLUP_SCA gives a variance component of zero}
 \item{simParam}{an object of \code{\link{SimParam}}}
 }
 \description{
-Fits an RR-BLUP model that models seperate effects for both female
-and male gametes and dominance effects. Used for predicting single
-cross hybrid performance.
+An extention of \code{\link{RRBLUP_GCA}} that adds dominance effects. 
+Note that we have not seen any consistent benefit of this model over 
+\code{\link{RRBLUP_GCA}}.
 }

---FILE: man/runMacs2.Rd---
@@ -0,0 +1,48 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/founderPop.R
+\name{runMacs2}
+\alias{runMacs2}
+\title{Alternative wrapper for MaCS}
+\usage{
+runMacs2(nInd, nChr, segSites, Ne = 100, bp = 1e+08, genLen = 1,
+  mutRate = 2.5e-08, histNe = NULL, histGen = NULL, inbred = FALSE)
+}
+\arguments{
+\item{nInd}{number of individuals to simulate}
+
+\item{nChr}{number of chromosomes to simulate}
+
+\item{segSites}{number of segregating sites to keep per chromosome}
+
+\item{Ne}{effective population size}
+
+\item{bp}{base pair length of chromosome}
+
+\item{genLen}{genetic length of chromosome in Morgans}
+
+\item{mutRate}{per base pair mutation rate}
+
+\item{histNe}{effective population size in previous 
+generations}
+
+\item{histGen}{number of generations ago for effective 
+population sizes given in histNe}
+
+\item{inbred}{should founder individuals be inbred}
+}
+\value{
+an object of \code{\link{MapPop-class}}
+}
+\description{
+A wrapper function for \code{\link{runMacs}}. This wrapper 
+is an alternative to directly using manualCommand in 
+\code{\link{runMacs}}. It automatically creates an appropriate 
+manualCommand based on user supplied variables.
+}
+\examples{
+# Creates a populations of 10 outbred individuals
+# Their genome consists of 1 chromosome and 100 segregating sites
+# The command is equivalent to using species=""TEST"" in runMacs
+founderPop = runMacs2(nInd=10,nChr=1,segSites=100)
+
+}

---FILE: man/selectCross.Rd---
@@ -4,8 +4,8 @@
 \alias{selectCross}
 \title{Select and randomly cross}
 \usage{
-selectCross(pop, nInd = NULL, nFemale = NULL, nMale = NULL, trait = 1,
-  selectTop = TRUE, use = ""pheno"", nCrosses, nProgeny = 1,
+selectCross(pop, nInd = NULL, nFemale = NULL, nMale = NULL, nCrosses,
+  nProgeny = 1, trait = 1, use = ""pheno"", selectTop = TRUE,
   simParam = NULL, ..., balance = TRUE)
 }
 \arguments{
@@ -23,19 +23,19 @@ if nInd is set.}
 \item{nMale}{the number of males to select. This value is ignored 
 if nInd is set.}
 
+\item{nCrosses}{total number of crosses to make}
+
+\item{nProgeny}{number of progeny per cross}
+
 \item{trait}{the trait for selection. Either a number indicating 
 a single trait or a function returning a vector of length nInd.}
 
-\item{selectTop}{selects highest values if true. 
-Selects lowest values if false.}
-
 \item{use}{select on genetic values ""gv"", estimated
 breeding values ""ebv"", breeding values ""bv"", phenotypes ""pheno"", 
 or randomly ""rand""}
 
-\item{nCrosses}{total number of crosses to make}
-
-\item{nProgeny}{number of progeny per cross}
+\item{selectTop}{selects highest values if true. 
+Selects lowest values if false.}
 
 \item{simParam}{an object of \code{\link{SimParam}}}
 

---FILE: man/selectOP.Rd---
@@ -0,0 +1,49 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/selection.R
+\name{selectOP}
+\alias{selectOP}
+\title{Select open pollinating plants}
+\usage{
+selectOP(pop, nInd, nSeeds, probSelf = 0, pollenControl = FALSE,
+  trait = 1, use = ""pheno"", selectTop = TRUE, simParam = NULL, ...)
+}
+\arguments{
+\item{pop}{an object of \code{\link{Pop-class}}}
+
+\item{nInd}{the number of plants to select}
+
+\item{nSeeds}{number of seeds per plant}
+
+\item{probSelf}{percentage of seeds expected from selfing. 
+Value ranges from 0 to 1.}
+
+\item{pollenControl}{are plants selected before pollination}
+
+\item{trait}{the trait for selection. Either a number indicating 
+a single trait or a function returning a vector of length nInd.}
+
+\item{use}{select on genetic values ""gv"", estimated
+breeding values ""ebv"", breeding values ""bv"", phenotypes ""pheno"", 
+or randomly ""rand""}
+
+\item{selectTop}{selects highest values if true. 
+Selects lowest values if false.}
+
+\item{simParam}{an object of \code{\link{SimParam}}}
+
+\item{...}{additional arguments if using a function for 
+trait}
+
+\item{balance}{if using gender, this option will balance the number 
+of progeny per parent. This argument occurs after ..., so the argument 
+name must be matched exactly.}
+}
+\value{
+Returns an object of \code{\link{Pop-class}}
+}
+\description{
+This function models selection in an open pollinating 
+plant population. It allows for varying the percentage of 
+selfing. The function also provides an option for modeling 
+selection as occuring before or after pollination.
+}

---FILE: src/RcppExports.cpp---
@@ -6,38 +6,6 @@
 
 using namespace Rcpp;
 
-// writeASGenotypes
-void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP _AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
-END_RCPP
-}
-// writeASHaplotypes
-void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP _AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
-END_RCPP
-}
 // gebvRR
 arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
 RcppExport SEXP _AlphaSimR_gebvRR(SEXP RRsolSEXP, SEXP popSEXP) {
@@ -99,6 +67,126 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// callRRBLUP
+Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip);
+RcppExport SEXP _AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker, skip));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_D
+Rcpp::List callRRBLUP_D(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip, int maxIter, bool useHetCov);
+RcppExport SEXP _AlphaSimR_callRRBLUP_D(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP, SEXP useHetCovSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    Rcpp::traits::input_parameter< bool >::type useHetCov(useHetCovSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_D(y, x, reps, genoTrain, nMarker, skip, maxIter, useHetCov));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_MV
+Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip, int maxIter);
+RcppExport SEXP _AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker, skip, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_GCA
+Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker, int skip, int maxIter);
+RcppExport SEXP _AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_SCA
+Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker, int skip, int maxIter, bool useHetCov);
+RcppExport SEXP _AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP, SEXP useHetCovSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    Rcpp::traits::input_parameter< bool >::type useHetCov(useHetCovSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter, useHetCov));
+    return rcpp_result_gen;
+END_RCPP
+}
+// writeASGenotypes
+void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP _AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
+END_RCPP
+}
+// writeASHaplotypes
+void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP _AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
+END_RCPP
+}
 // getGeno
 arma::Mat<unsigned char> getGeno(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
 RcppExport SEXP _AlphaSimR_getGeno(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
@@ -286,6 +374,19 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// mergeMultIntMat
+arma::Mat<int> mergeMultIntMat(const arma::field<arma::Mat<int> >& X, arma::uvec nRow, arma::uword nCol);
+RcppExport SEXP _AlphaSimR_mergeMultIntMat(SEXP XSEXP, SEXP nRowSEXP, SEXP nColSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::field<arma::Mat<int> >& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type nRow(nRowSEXP);
+    Rcpp::traits::input_parameter< arma::uword >::type nCol(nColSEXP);
+    rcpp_result_gen = Rcpp::wrap(mergeMultIntMat(X, nRow, nCol));
+    return rcpp_result_gen;
+END_RCPP
+}
 // calcChrFreq
 arma::vec calcChrFreq(const arma::Cube<unsigned char>& geno);
 RcppExport SEXP _AlphaSimR_calcChrFreq(SEXP genoSEXP) {
@@ -345,94 +446,6 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// callRRBLUP
-Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip);
-RcppExport SEXP _AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker, skip));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_D
-Rcpp::List callRRBLUP_D(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip, int maxIter, bool useHetCov);
-RcppExport SEXP _AlphaSimR_callRRBLUP_D(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP, SEXP useHetCovSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    Rcpp::traits::input_parameter< bool >::type useHetCov(useHetCovSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_D(y, x, reps, genoTrain, nMarker, skip, maxIter, useHetCov));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_MV
-Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip, int maxIter);
-RcppExport SEXP _AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker, skip, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_GCA
-Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker, int skip, int maxIter);
-RcppExport SEXP _AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_SCA
-Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker, int skip, int maxIter, bool useHetCov);
-RcppExport SEXP _AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP, SEXP useHetCovSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    Rcpp::traits::input_parameter< bool >::type useHetCov(useHetCovSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter, useHetCov));
-    return rcpp_result_gen;
-END_RCPP
-}
 // packHaplo
 arma::Cube<unsigned char> packHaplo(arma::Mat<unsigned char>& haplo, arma::uword ploidy, bool inbred);
 RcppExport SEXP _AlphaSimR_packHaplo(SEXP haploSEXP, SEXP ploidySEXP, SEXP inbredSEXP) {

---FILE: src/init.c---
@@ -33,6 +33,7 @@ extern SEXP _AlphaSimR_getOneHaplo(SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_MaCS(SEXP, SEXP);
 extern SEXP _AlphaSimR_mergeGeno(SEXP, SEXP);
 extern SEXP _AlphaSimR_mergeMultGeno(SEXP, SEXP, SEXP, SEXP);
+extern SEXP _AlphaSimR_mergeMultIntMat(SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_packHaplo(SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_popVar(SEXP);
 extern SEXP _AlphaSimR_sampAllComb(SEXP, SEXP, SEXP);
@@ -70,6 +71,7 @@ static const R_CallMethodDef CallEntries[] = {
     {""_AlphaSimR_MaCS"",              (DL_FUNC) &_AlphaSimR_MaCS,              2},
     {""_AlphaSimR_mergeGeno"",         (DL_FUNC) &_AlphaSimR_mergeGeno,         2},
     {""_AlphaSimR_mergeMultGeno"",     (DL_FUNC) &_AlphaSimR_mergeMultGeno,     4},
+    {""_AlphaSimR_mergeMultIntMat"",   (DL_FUNC) &_AlphaSimR_mergeMultIntMat,   3},
     {""_AlphaSimR_packHaplo"",         (DL_FUNC) &_AlphaSimR_packHaplo,         3},
     {""_AlphaSimR_popVar"",            (DL_FUNC) &_AlphaSimR_popVar,            1},
     {""_AlphaSimR_sampAllComb"",       (DL_FUNC) &_AlphaSimR_sampAllComb,       3},

---FILE: src/misc.cpp---
@@ -64,6 +64,24 @@ arma::field<arma::Cube<unsigned char> > mergeMultGeno(Rcpp::List& popList,
   return output;
 }
 
+// Merges a list of integer matrices
+// [[Rcpp::export]]
+arma::Mat<int> mergeMultIntMat(const arma::field<arma::Mat<int> >& X,
+                               arma::uvec nRow,
+                               arma::uword nCol){
+  arma::Mat<int> output(sum(nRow),nCol);
+  arma::uword start=0, end=0;
+  for(arma::uword i=0; i<nRow.n_elem; i++){
+    if(nRow(i)>0){
+      end += nRow(i)-1;
+    }
+    output.rows(start,end) = X(i);
+    start += nRow(i);
+    end = start;
+  }
+  return output;
+}
+
 // Calculates allele frequency on a single chromsome
 // Requires bi-allelic markers, but works for any ploidy
 // [[Rcpp::export]]

---FILE: vignettes/GS.Rmd---
@@ -0,0 +1,12 @@
+---
+title: ""Genomic Selection in AlphaSimR""
+author: ""Chris Gaynor""
+date: ""`r Sys.Date()`""
+output: pdf_document
+bibliography: bibliography.bib
+vignette: >
+  %\VignetteIndexEntry{GS}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+

---FILE: vignettes/SI.Rmd---
@@ -0,0 +1,12 @@
+---
+title: ""Selection Indices in AlphaSimR""
+author: ""Chris Gaynor""
+date: ""`r Sys.Date()`""
+output: pdf_document
+bibliography: bibliography.bib
+vignette: >
+  %\VignetteIndexEntry{Selection Index}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+

---FILE: vignettes/crossing.Rmd---
@@ -0,0 +1,12 @@
+---
+title: ""Guide to Crossing/Mating""
+author: ""Chris Gaynor""
+date: ""`r Sys.Date()`""
+output: pdf_document
+bibliography: bibliography.bib
+vignette: >
+  %\VignetteIndexEntry{Crossing}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+

---FILE: vignettes/hybrids.Rmd---
@@ -0,0 +1,12 @@
+---
+title: ""Simulating Hybrid Breeding Programs""
+author: ""Chris Gaynor""
+date: ""`r Sys.Date()`""
+output: pdf_document
+bibliography: bibliography.bib
+vignette: >
+  %\VignetteIndexEntry{Hybrids}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+

---FILE: vignettes/intro.Rmd---
@@ -50,7 +50,7 @@ There are many additional functions that you may wish to use to modify `SP`. The
 
   Once you have finished modifying `SP`, you are ready to start the process of simulating your breeding. You should not modify `SP` once you start this process, because doing so can result in undesired side effects. In fact, you will be prevented from using most functions for modifying `SP` at this point and they will return the following error, ""lastId doesn't equal 0, you must run resetPed to proceed"". There are some exceptions to this rule, but because they rarely occur I will not discuss them here.
 
-# Simulate the Breeding Program
+# Model the Breeding Program
 
 There is no single way to simulate breeding programs in AlphaSimR. This means you can come up with multiple ways to simulate the same breeding program. This is not to say that all ways are equally good. Some ways are clearly better than others with respect to computational performance. The point is that you need not write your simulation in only one way. This is an intentional element of AlphaSimR's design, because it gives you the freedom structure your simulations in a way that works best for you and the breeding program you are trying to simulate. This is what makes AlphaSimR so powerful for modeling complicated breeding programs. For this reason, I will not present a single way of performing breeding program simulation but present instead some of the functions you can use in your simulations. But before I do this, you need to know about the `Pop-class`.
 
@@ -117,7 +117,7 @@ SP$addTraitA(nQtlPerChr=1000, mean=0, var=1)
 # Gender is assigned systematically as male, female, male, ...
 SP$setGender(""yes_sys"")
 
-### Simulate the Breeding Program
+### Model the Breeding Program
 
 # Creating the initial population
 pop = newPop(founderPop)

---FILE: vignettes/maize.Rmd---
@@ -0,0 +1,12 @@
+---
+title: ""Maize Breeding Program Example""
+author: ""Chris Gaynor""
+date: ""`r Sys.Date()`""
+output: pdf_document
+bibliography: bibliography.bib
+vignette: >
+  %\VignetteIndexEntry{Maize Breeding Program}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+

---FILE: vignettes/quickref.Rmd---
@@ -0,0 +1,12 @@
+---
+title: ""AlphaSimR Quick Reference Guide""
+author: ""Chris Gaynor""
+date: ""`r Sys.Date()`""
+output: pdf_document
+bibliography: bibliography.bib
+vignette: >
+  %\VignetteIndexEntry{Quick Reference Guide}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+

---FILE: vignettes/traits.Rmd---
@@ -0,0 +1,12 @@
+---
+title: ""Traits in AlphaSimR""
+author: ""Chris Gaynor""
+date: ""`r Sys.Date()`""
+output: pdf_document
+bibliography: bibliography.bib
+vignette: >
+  %\VignetteIndexEntry{Traits}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+

---FILE: vignettes/wheat.Rmd---
@@ -0,0 +1,12 @@
+---
+title: ""Wheat Breeding Program Example""
+author: ""Chris Gaynor""
+date: ""`r Sys.Date()`""
+output: pdf_document
+bibliography: bibliography.bib
+vignette: >
+  %\VignetteIndexEntry{Wheat Breeding Program}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+"
gaynorr,AlphaSimR,f415fa4fb1bdc3d99b99fedf73b4cd285374d242,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-03-09T13:17:01Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-03-09T13:17:01Z,Fixed selection index in crossSelect,DESCRIPTION;R/crossing.R;man/selectCross.Rd,False,True,True,False,11,9,20,"---FILE: DESCRIPTION---
@@ -1,8 +1,8 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 0.5.0
-Date: 2017-12-21
+Version: 0.5.1
+Date: 2018-3-9
 Authors@R: c(person(""Chris"",""Gaynor"",email=""gaynor.robert@hotmail.com"",role=""cre""),person(""Gregor"",""Gorjanc"",role=""ctb""),person(""David"",""Wilson"",role=""ctb""),person(""Daniel"",""Money"",role=""ctb""),person(""John"",""Hickey"",role=""ctb""))
 Description: This package contains classes and functions for simulating plant and animal breeding programs.
 License: MIT + file LICENSE

---FILE: R/crossing.R---
@@ -150,18 +150,19 @@ randCross = function(pop,nCrosses,nProgeny=1,
 #' Selects lowest values if false.
 #' @param nCrosses total number of crosses to make
 #' @param nProgeny number of progeny per cross
-#' @param balance if using gender, this option will balance the number 
-#' of progeny per parent
 #' @param simParam an object of \code{\link{SimParam}}
 #' @param ... additional arguments if using a function for 
 #' trait
+#' @param balance if using gender, this option will balance the number 
+#' of progeny per parent. This argument occurs after ..., so the argument 
+#' name must be matched exactly.
 #' 
 #' @return Returns an object of \code{\link{Pop-class}}
 #' 
 #' @export
 selectCross = function(pop,nInd=NULL,nFemale=NULL,nMale=NULL,trait=1,
                        selectTop=TRUE,use=""pheno"",nCrosses,nProgeny=1,
-                       balance=TRUE,simParam=NULL,...){
+                       simParam=NULL,...,balance=TRUE){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }

---FILE: man/selectCross.Rd---
@@ -6,7 +6,7 @@
 \usage{
 selectCross(pop, nInd = NULL, nFemale = NULL, nMale = NULL, trait = 1,
   selectTop = TRUE, use = ""pheno"", nCrosses, nProgeny = 1,
-  balance = TRUE, simParam = NULL, ...)
+  simParam = NULL, ..., balance = TRUE)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}}}
@@ -37,13 +37,14 @@ or randomly ""rand""}
 
 \item{nProgeny}{number of progeny per cross}
 
-\item{balance}{if using gender, this option will balance the number 
-of progeny per parent}
-
 \item{simParam}{an object of \code{\link{SimParam}}}
 
 \item{...}{additional arguments if using a function for 
 trait}
+
+\item{balance}{if using gender, this option will balance the number 
+of progeny per parent. This argument occurs after ..., so the argument 
+name must be matched exactly.}
 }
 \value{
 Returns an object of \code{\link{Pop-class}}"
gaynorr,AlphaSimR,bebd38bcf5dff4fef62efa68f218d14d29cf2011,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-02-01T22:16:57Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-02-01T22:16:57Z,Fixed bug in mergePops with GxE traits,R/mergePops.R,False,True,True,False,12,2,14,"---FILE: R/mergePops.R---
@@ -69,8 +69,18 @@ mergePops = function(popList){
     ebv = matrix(NA_real_,nrow=nInd,ncol=0)
   }
   #gxe
-  gxe = do.call(""c"",lapply(popList,
-                           function(x) x@gxe))
+  if(nTraits>=1){
+    gxe = vector(""list"",length=nTraits)
+    for(trait in 1:nTraits){
+      if(!is.null(popList[[1]]@gxe[[trait]])){
+        tmp = lapply(popList,function(x) x@gxe[[trait]])
+        tmp = do.call(""c"",tmp)
+        gxe[[trait]] = tmp
+      }
+    }
+  }else{
+    gxe = list()
+  }
   #geno
   geno = AlphaSimR:::mergeMultGeno(popList,nInd=nInd,nLoci=nLoci,ploidy=ploidy)
   nInd = sum(nInd)"
gaynorr,AlphaSimR,8be4a3c70b9c7e7b863b6438a430bc53fca85dec,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-01-05T15:05:28Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2018-01-05T15:05:28Z,"-Multiple bug fixes
-New unit tests
-Changes to setEBV for RRBLUP_D
--useD is now useGV
--EBV considers allele frequency",NAMESPACE;R/Class-SimParam.R;R/GS.R;R/RcppExports.R;R/crossing.R;R/founderPop.R;R/hybrids.R;R/phenotypes.R;R/pullGeno.R;R/quickPop.R;R/runMacs.R;inst/doc/Introduction.pdf;inst/doc/introduction.R;inst/doc/introduction.Rmd;man/MaCS.Rd;man/SimParam.Rd;man/SimParam_addSnpChip.Rd;man/SimParam_addStructuredSnpChips.Rd;man/SimParam_addTraitA.Rd;man/SimParam_addTraitAD.Rd;man/SimParam_addTraitADG.Rd;man/SimParam_addTraitAG.Rd;man/SimParam_new.Rd;man/SimParam_removeFounderPop.Rd;man/SimParam_removeSnpChip.Rd;man/SimParam_removeTrait.Rd;man/SimParam_rescaleTraits.Rd;man/SimParam_resetPed.Rd;man/SimParam_restrSegSites.Rd;man/SimParam_setCorrVarE.Rd;man/SimParam_setGender.Rd;man/SimParam_setRecombRatio.Rd;man/SimParam_setTrackPed.Rd;man/SimParam_setTrackRec.Rd;man/SimParam_setVarE.Rd;man/SimParam_switchSnpChip.Rd;man/SimParam_switchTrait.Rd;man/calcPheno.Rd;man/newMapPop.Rd;man/pullSegSiteHaplo.Rd;man/quickPop.Rd;man/runMacs.Rd;man/sampleHaplo.Rd;man/setEBV.Rd;man/setPheno.Rd;man/setPhenoGCA.Rd;man/solveAniModel.Rd;man/trackHaploPop.Rd;src/GEBV.cpp;src/MME.cpp;src/RcppExports.cpp;src/init.c;src/misc.cpp;src/simulator.cpp;tests/testthat/test-addTrait.R;tests/testthat/test-crossing.R;tests/testthat/test-editGenome.R;tests/testthat/test-statistics.R;vignettes/Introduction.Rmd,True,True,True,False,1055,586,1641,"---FILE: NAMESPACE---
@@ -1,6 +1,5 @@
 # Generated by roxygen2: do not edit by hand
 
-export(MaCS)
 export(RRBLUP)
 export(RRBLUPMemUse)
 export(RRBLUP_D)
@@ -29,6 +28,7 @@ export(makeCross2)
 export(makeDH)
 export(meanG)
 export(meanP)
+export(newMapPop)
 export(newPop)
 export(popVar)
 export(pullMultipleSnpGeno)
@@ -38,12 +38,12 @@ export(pullQtlHaplo)
 export(pullSegSiteHaplo)
 export(pullSnpGeno)
 export(pullSnpHaplo)
-export(quickPop)
 export(randCross)
 export(randCross2)
 export(readMat)
 export(resetPop)
 export(runMacs)
+export(sampleHaplo)
 export(selIndex)
 export(selInt)
 export(selectCross)
@@ -55,6 +55,7 @@ export(setEBV)
 export(setPheno)
 export(setPhenoGCA)
 export(smithHazel)
+export(solveAniModel)
 export(solveMKM)
 export(solveMVM)
 export(solveRRBLUP)

---FILE: R/Class-SimParam.R---
@@ -5,8 +5,6 @@
 #' Container for global simulation parameters. Saving this object 
 #' as SIMPARAM will allow it to be accessed by function defaults.
 #' 
-#' @docType class
-#' 
 #' @field ploidy ploidy level of species
 #' @field nChr number of chromosomes
 #' @field nTraits number of traits
@@ -60,7 +58,7 @@ SimParam = R6Class(
   active = list(
     ploidy=function(value){
       if(missing(value)){
-        private$ploidy
+        private$.ploidy
       }else{
         stop(""`$ploidy` is read only"",call.=FALSE)
       }
@@ -220,6 +218,8 @@ SimParam = R6Class(
 #' these functions without explicitly supplying a simParam 
 #' argument with every call.
 #' 
+#' @section Usage: SimParam$new(founderPop)
+#' 
 #' @param founderPop an object of \code{\link{MapPop-class}}
 #' 
 #' @name SimParam_new
@@ -306,6 +306,8 @@ SimParam$set(
 #' off pedigree tracking will turn off recombination tracking 
 #' if it is turned on.
 #' 
+#' @section Usage: SP$setTrackPed(isTrackPed)
+#' 
 #' @param isTrackPed should pedigree tracking be on.
 #' 
 #' @name SimParam_setTrackPed
@@ -334,6 +336,8 @@ SimParam$set(
 #' except those created by \code{\link{hybridCross}}, because their 
 #' pedigree is not tracked.
 #' 
+#' @section Usage: SimParam$setTrackRec(isTrackRec)
+#' 
 #' @param isTrackRec should recombination tracking be on.
 #' 
 #' @name SimParam_setTrackRec
@@ -361,6 +365,8 @@ SimParam$set(
 #' function, because they are tied to the older pedigree that is 
 #' being deleted.
 #' 
+#' @section Usage: SP$resetPed()
+#' 
 #' @name SimParam_resetPed
 NULL
 # resetPed ----
@@ -379,6 +385,9 @@ SimParam$set(
 #' @description Sets restrictions on which segregating sites 
 #' can serve and SNP and/or QTL loci.
 #' 
+#' @section Usage: SP$restrSegSites(maxQtl = 0, maxSnp = 0, 
+#' snpQtlOverlap = FALSE, minSnpFreq = NULL)
+#' 
 #' @param maxQtl the maximum number of segSites for QTLs. 
 #' Can be a single value or a vector values for each 
 #' chromosome.
@@ -463,6 +472,8 @@ SimParam$set(
 #' female. The value ""yes_rand"" will randomly assign gender to 
 #' individuals.
 #' 
+#' @section Usage: SP$setGender(gender)
+#' 
 #' @param gender acceptable value are ""no"", ""yes_sys"", or 
 #' ""yes_rand""
 #' 
@@ -498,6 +509,8 @@ SimParam$set(
 #' and a value of 0.5 specifies half as much recombination in 
 #' females.
 #' 
+#' @section Usage: SP$setRecombRatio(ratio)
+#' 
 #' @param ratio any value greater than 0
 #' 
 #' @name SimParam_setRecombRatio
@@ -519,6 +532,8 @@ SimParam$set(
 #' @description Defines a default value for error 
 #' variances in the simulation.
 #' 
+#' @section Usage: SP$setVarE(h2 = NULL, H2 = NULL, varE = NULL)
+#' 
 #' @param h2 a vector of desired narrow-sense heritabilities
 #' @param H2 a vector of desired broad-sense heritabilities
 #' @param varE a vector of error variances
@@ -567,6 +582,8 @@ SimParam$set(
 #' error variances. You must call \code{\link{SimParam_setVarE}} 
 #' first to define the default error variances.
 #' 
+#' @section Usage: SP$setCorrVarE(corr)
+#' 
 #' @param corr a correlation matrix for the error variances
 #' 
 #' @name SimParam_setCorrVarE
@@ -593,6 +610,8 @@ SimParam$set(
 #' @description 
 #' Randomly assigns eligble SNPs to a SNP chip
 #' 
+#' @section Usage: SP$addSnpChip(nSnpPerChr)
+#' 
 #' @param nSnpPerChr number of SNPs per chromosome. 
 #' Can be a single value or nChr values.
 #' 
@@ -629,6 +648,8 @@ SimParam$set(
 #' Randomly selects the number of snps in structure and then
 #' assigns them to chips based on structure
 #' 
+#' @section Usage: SP$addStructuredSnpChip(nSnpPerChr, structure)
+#' 
 #' @param nSnpPerChr number of SNPs per chromosome. 
 #' Can be a single value or nChr values.
 #' @param structure a matrix.  Rows are snp chips, columns are chips.
@@ -678,6 +699,8 @@ SimParam$set(
 #' @description 
 #' Removes designated SNP chip(s).
 #' 
+#' @section Usage: SP$removeSnpChip(chips)
+#' 
 #' @param chips a vector of SNP chips to remove
 #' 
 #' @name SimParam_removeSnpChip
@@ -701,6 +724,8 @@ SimParam$set(
 #' @description 
 #' Replaces the \code{\link{LociMap-class}} for a SNP chip.
 #' 
+#' @section Usage: SP$switchSnpChips(lociMap, chip)
+#' 
 #' @param lociMap a new \code{\link{LociMap-class}}
 #' @param chip an integer indicating which chip to replace
 #' 
@@ -778,6 +803,9 @@ sampDomEff = function(qtlLoci,nTraits,addEff,corDD,
 #' If simulating more than one trait, all traits will be pleiotrophic 
 #' with correlated additive effects.
 #' 
+#' @section Usage: SP$addTraitA(nQtlPerChr, mean = 0, var = 1, corr = NULL, 
+#' gamma = FALSE, shape = 1)
+#' 
 #' @param nQtlPerChr number of QTLs per chromosome. Can be a single value or nChr values.
 #' @param mean a vector of desired mean genetic values for one or more traits
 #' @param var a vector of desired genetic variances for one or more traits
@@ -829,6 +857,10 @@ SimParam$set(
 #' If simulating more than one trait, all traits will be pleiotrophic 
 #' with correlated additive effects.
 #' 
+#' @section Usage: SP$addTraitAD(nQtlPerChr, mean = 0, var = 1, meanDD = 0, 
+#' varDD = 0, corA = NULL, corDD = NULL, useVarA = TRUE, gamma = FALSE, 
+#' shape = 1)
+#' 
 #' @param nQtlPerChr number of QTLs per chromosome. Can be a single value or nChr values.
 #' @param mean a vector of desired mean genetic values for one or more traits
 #' @param var a vector of desired genetic variances for one or more traits
@@ -892,6 +924,9 @@ SimParam$set(
 #' If simulating more than one trait, all traits will be pleiotrophic 
 #' with correlated effects.
 #' 
+#' @section Usage: SP$addTraitAG(nQtlPerChr, mean = 0, var = 1, varEnv = 1e-6, 
+#' varGxE = 1e-6, corA = NULL, corGxE = NULL, gamma = FALSE, shape = 1)
+#' 
 #' @param nQtlPerChr number of QTLs per chromosome. Can be a single value or nChr values.
 #' @param mean a vector of desired mean genetic values for one or more traits
 #' @param var a vector of desired genetic variances for one or more traits
@@ -959,6 +994,10 @@ SimParam$set(
 #' @description 
 #' Randomly assigns eligble QTLs for a trait with dominance and GxE. 
 #' 
+#' @section Usage: SP$addTraitAG(nQtlPerChr, mean = 0, var = 1, varEnv = 1e-6, 
+#' varGxE = 1e-6, meanDD = 0, varDD = 0, corA = NULL, corDD = NULL, 
+#' corGxE = NULL, useVarA = TRUE, gamma = FALSE, shape = 1)
+#' 
 #' @param nQtlPerChr number of QTLs per chromosome. Can be a single 
 #' value or nChr values.
 #' @param mean a vector of desired mean genetic values for one or more traits
@@ -1040,6 +1079,8 @@ SimParam$set(
 #' @description 
 #' Removes designated trait(s).
 #' 
+#' @section Usage: SP$removeTrait(traits)
+#' 
 #' @param traits a vector of traits to remove
 #' 
 #' @name SimParam_removeTrait
@@ -1073,6 +1114,8 @@ SimParam$set(
 #' @description 
 #' Replaces an existing trait.
 #' 
+#' @section Usage: SP$switchTrait(lociMap, trait, varA = NULL, varG = NULL)
+#' 
 #' @param lociMap a new object descended from 
 #' \code{\link{LociMap-class}}
 #' @param trait an integer indicating which trait to replace
@@ -1107,9 +1150,12 @@ SimParam$set(
 #' Linearly scales all traits to achieve desired 
 #' values of means and variances.
 #' 
+#' @section Usage: SP$rescaleTraits(pop, mean = 0, var = 1, varEnv = 1e-6, 
+#' varGxE = 1e-6, useVarA = TRUE)
+#' 
 #' @param pop an object of \code{\link{Pop-class}}
-#' @param meanG a vector of new trait means
-#' @param varG a vector of new trait variances
+#' @param mean a vector of new trait means
+#' @param var a vector of new trait variances
 #' @param varEnv a vector of new environmental variances
 #' @param varGxE a vector of new GxE variances
 #' @param useVarA tune according to additive genetic variance if true
@@ -1124,19 +1170,19 @@ NULL
 SimParam$set(
   ""public"",
   ""rescaleTraits"",
-  function(pop,meanG=0,varG=1,varEnv=1e-6,
+  function(pop,mean=0,var=1,varEnv=1e-6,
            varGxE=1e-6,useVarA=TRUE){
     isGxe = sapply(private$.traits,function(x){
       class(x)%in%c(""TraitAG"",""TraitADG"")
     })
     if(any(isGxe)){
-      stopifnot(length(meanG)==private$.nTraits,
-                length(varG)==private$.nTraits,
+      stopifnot(length(mean)==private$.nTraits,
+                length(var)==private$.nTraits,
                 length(varEnv)==private$.nTraits,
                 length(varGxE)==private$.nTraits)
     }else{
-      stopifnot(length(meanG)==private$.nTraits,
-                length(varG)==private$.nTraits)
+      stopifnot(length(mean)==private$.nTraits,
+                length(var)==private$.nTraits)
     }
     
     for(i in 1:private$.nTraits){
@@ -1145,13 +1191,13 @@ SimParam$set(
                      trait@lociPerChr,
                      trait@lociLoc)
       if(class(trait)%in%c(""TraitAD"",""TraitADG"")){
-        tmp = tuneTraitAD(geno,trait@addEff,trait@domEff,varG[i],useVarA)
+        tmp = tuneTraitAD(geno,trait@addEff,trait@domEff,var[i],useVarA)
         trait@domEff = trait@domEff*tmp$parameter
       }else{
-        tmp = tuneTraitA(geno,trait@addEff,varG[i])
+        tmp = tuneTraitA(geno,trait@addEff,var[i])
       }
       trait@addEff = trait@addEff*tmp$parameter
-      trait@intercept = meanG[i]-tmp$output$intercept
+      trait@intercept = mean[i]-tmp$output$intercept
       if(class(trait)%in%c(""TraitAG"",""TraitADG"")){
         targetVar = varGxE[i]/varEnv[i]
         tmp = tuneTraitA(geno,trait@gxeEff,targetVar)
@@ -1165,13 +1211,40 @@ SimParam$set(
   }
 )
 
+#' @title Switch founder population
+#' 
+#' @description
+#' Switches the founder population in the founderPop 
+#' field. This may be desirable if traits are to be 
+#' tuned to a population derived from the original 
+#' founderPop. Note that no checking is performed to verify 
+#' that the genetic map and/or number of segregating sites 
+#' hasn't changed. The new founderPop can be 
+#' \code{\link{MapPop-class}} or \code{\link{RawPop-class}}
+#' 
+#' @section Usage: SP$switchFounderPop(founderPop)
+#' 
+#' @name SimParam_removeFounderPop
+NULL
+# switchFounderPop ----
+SimParam$set(
+  ""public"",
+  ""switchFounderPop"",
+  function(founderPop){
+    private$.founderPop = founderPop
+    invisible(self)
+  }
+)
+
 #' @title Remove founder population
 #' 
 #' @description
 #' Removes the founder population from the founderPop 
 #' field. This can be ran after all traits have been 
 #' added to reduce the size of the SimParam object.
 #' 
+#' @section Usage: SP$removeFounderPop()
+#' 
 #' @name SimParam_removeFounderPop
 NULL
 # removeFounderPop ----

---FILE: R/GS.R---
@@ -438,23 +438,24 @@ RRBLUP_SCA = function(dir, traits=1, use=""pheno"",
 #' solution is \code{\link{GCAsol-class}} or 
 #' \code{\link{SCAsol-class}} the EBV is the GCA if used in 
 #' the corresponding pool
-#' @param useD if model is \code{\link{RRDsol-class}}, should 
-#' dominance be included in the EBV. If yes, the ""EBV"" is an 
-#' estimate of genetic value and not an estimate of breeding value.
+#' @param useGV if model is \code{\link{RRDsol-class}}, 
+#' setting this parameter to TRUE will give use estimated 
+#' genetic values. Otherwise, you get estimated breeding 
+#' values that depend on the population's allele frequency.
 #' @param append should EBVs be appended to existing EBVs
 #'
 #' @return Returns an object of \code{\link{Pop-class}}
 #'
 #' @export
-setEBV = function(pop, solution, gender=NULL, useD=FALSE, 
+setEBV = function(pop, solution, gender=NULL, useGV=FALSE, 
                   append=FALSE){
   if(class(solution)==""RRsol""){
     ebv = gebvRR(solution, pop)
   }else if(class(solution)==""RRDsol""){
-    if(useD){
-      ebv = gebvRRD(solution, pop)
+    if(useGV){
+      ebv = gegvRRD(solution, pop)
     }else{
-      ebv = gebvRR(solution, pop)
+      ebv = gebvRRD(solution, pop)
     }
   }else if(class(solution)==""GCAsol""){
     if(is.null(gender)){

---FILE: R/RcppExports.R---
@@ -13,6 +13,10 @@ gebvRR <- function(RRsol, pop) {
     .Call(`_AlphaSimR_gebvRR`, RRsol, pop)
 }
 
+gegvRRD <- function(RRsol, pop) {
+    .Call(`_AlphaSimR_gegvRRD`, RRsol, pop)
+}
+
 gebvRRD <- function(RRsol, pop) {
     .Call(`_AlphaSimR_gebvRRD`, RRsol, pop)
 }
@@ -106,14 +110,6 @@ sampHalfDialComb <- function(nLevel, n) {
     .Call(`_AlphaSimR_sampHalfDialComb`, nLevel, n)
 }
 
-zero <- function() {
-    .Call(`_AlphaSimR_zero`)
-}
-
-changeId <- function(newId, oldId) {
-    invisible(.Call(`_AlphaSimR_changeId`, newId, oldId))
-}
-
 calcCoef <- function(X, Y) {
     .Call(`_AlphaSimR_calcCoef`, X, Y)
 }
@@ -154,6 +150,21 @@ solveUVM <- function(y, X, Z, K) {
     .Call(`_AlphaSimR_solveUVM`, y, X, Z, K)
 }
 
+#' @title Solve animal model
+#'
+#' @description
+#' Solves a univariate mixed model of form \eqn{y=X\beta+u+e}
+#'
+#' @param y a matrix with n rows and 1 column
+#' @param X a matrix with n rows and x columns
+#' @param K the numeric relationship matrix 
+#' with n rows and n columns
+#'
+#' @export
+solveAniModel <- function(y, X, K) {
+    .Call(`_AlphaSimR_solveAniModel`, y, X, K)
+}
+
 #' @title Solve RR-BLUP
 #'
 #' @description
@@ -352,23 +363,6 @@ packHaplo <- function(haplo, ploidy, inbred) {
     .Call(`_AlphaSimR_packHaplo`, haplo, ploidy, inbred)
 }
 
-#' @title Markovian Coalescent Simulator
-#' 
-#' @description
-#' Runs a built-in version of the Markovian Coalescent Simulator. 
-#' 
-#' @param args command line arguments passed to MaCS.
-#' @param maxSites maximum number of segregating sites to 
-#' return. If value is 0, all segregating sites are returned. 
-#' Otherwise, segregating sites are randomly sampled.
-#' 
-#' @references
-#' \cite{Chen, G.K., P. Marjoram, and J.D. Wall. 2009. Fast and flexible simulation of DNA sequence data. Genome Res. 19(1): 136142.}
-#' 
-#' @return A list containing a matrix of haplotypes and a 
-#' vector of genetic distances.
-#'
-#' @export
 MaCS <- function(args, maxSites = 0L) {
     .Call(`_AlphaSimR_MaCS`, args, maxSites)
 }

---FILE: R/crossing.R---
@@ -24,8 +24,8 @@ makeCross = function(pop,crossPlan,rawPop=FALSE,
     stop(""Only works with diploids"")
   }
   if(is.character(crossPlan)){ #Match by ID
-    crossPlan = cbind(match(crossPlan[,1],pop$id),
-                      match(crossPlan[,2],pop$id))
+    crossPlan = cbind(match(crossPlan[,1],pop@id),
+                      match(crossPlan[,2],pop@id))
     if(any(is.na(crossPlan))){
       stop(""Failed to match supplied IDs"")
     }
@@ -218,8 +218,8 @@ makeCross2 = function(females,males,crossPlan,
     stop(""Only works with diploids"")
   }
   if(is.character(crossPlan)){ #Match by ID
-    crossPlan = cbind(match(crossPlan[,1],females$id),
-                      match(crossPlan[,2],males$id))
+    crossPlan = cbind(match(crossPlan[,1],females@id),
+                      match(crossPlan[,2],males@id))
     if(any(is.na(crossPlan))){
       stop(""Failed to match supplied IDs"")
     }

---FILE: R/founderPop.R---
@@ -0,0 +1,322 @@
+#' @title New MapPop
+#'
+#' @description 
+#' Creates a new \code{\link{MapPop-class}} from user supplied 
+#' genetic maps and haplotypes.
+#' 
+#' @param genMaps a list of genetic maps
+#' @param haplotypes a list of matrices or data.frames that 
+#' can be coerced to matrices. See details.
+#' @param inbred are individuals fully inbred
+#' 
+#' @details
+#' Each item of genMaps must be a vector of ordered genetic lengths in 
+#' Morgans. The first value must be zero. The length of the vector 
+#' determines the number of segregating sites on the chromosome.
+#' 
+#' Each item of haplotypes must be coercible to a matrix. The columns 
+#' of this matrix correspond to segregating sites and their number must 
+#' match
+#' 
+#' @return an object of \code{\link{MapPop-class}}
+#' 
+#' @examples 
+#' # Create genetic map for two chromosomes, each 1 Morgan long
+#' # Each chromosome contains 11 equally spaced segregating sites
+#' genMaps = list(seq(0,1,length.out=11),
+#'                seq(0,1,length.out=11))
+#'                
+#' # Create haplotypes for 10 outbred individuals
+#' chr1 = sample(x=0:1,size=20*11,replace=TRUE)
+#' chr1 = matrix(chr1,nrow=20,ncol=11)
+#' chr2 = sample(x=0:1,size=20*11,replace=TRUE)
+#' chr2 = matrix(chr2,nrow=20,ncol=11)
+#' haplotypes = list(chr1,chr2)
+#' 
+#' founderPop = newMapPop(genMaps=genMaps,haplotypes=haplotypes)
+#' 
+#' @export
+newMapPop = function(genMaps,haplotypes,inbred=FALSE){
+  stopifnot(length(genMaps)==length(haplotypes))
+  ploidy = 2 #The only ploidy level currently supported
+  nRow = lapply(haplotypes,nrow)
+  nRow = unlist(nRow)
+  if(length(nRow)>1L){
+    if(any(nRow[1]!=nRow)){
+      stop(""Number of rows must be equal in haplotypes"")
+    }
+    nRow = nRow[1]
+  }
+  if(inbred){
+    nInd = nRow
+  }else{
+    if(ploidy==2L){
+      if(nRow%%2 == 1L){
+        stop(""Number of haplotypes must be divisible by 2"")
+      }
+      nInd = nRow/2
+    }
+  }
+  nCol = lapply(haplotypes,ncol)
+  nCol = unlist(nCol)
+  segSites = lapply(genMaps,length)
+  segSites = unlist(segSites)
+  if(!all.equal(nCol,segSites)){
+    stop(""Number of segregating sites in haplotypes and genMaps don't match"")
+  }
+  output = vector(""list"",length(genMaps))
+  for(chr in 1:length(genMaps)){
+    geno = packHaplo(as.matrix(haplotypes[[chr]]),
+                     ploidy=ploidy,inbred=inbred)
+    output[[chr]] = new(""MapPop"",
+                        nInd=as.integer(nInd),
+                        nChr=1L,
+                        ploidy=as.integer(ploidy),
+                        nLoci=as.integer(segSites[chr]),
+                        geno=as.matrix(list(geno)),
+                        genMaps=as.matrix(genMaps[chr]))
+  }
+  output = do.call(""c"",output)
+  return(output)
+}
+
+#' @title Haplotype tracking population
+#' 
+#' @description
+#' Creates a population for tracking haplotypes.
+#'
+#' @param genMaps a list of genetic maps
+#' @param nInd number of individuals
+#' @param inbred should individuals be fully inbred
+#' 
+#' @details
+#' Each item of genMaps must be a vector of ordered genetic lengths in 
+#' Morgans. The first value must be zero. The length of the vector 
+#' determines the number of segregating sites on the chromosome.
+#' 
+#' If inbred=FALSE, the value of nInd must be less than or equal to 
+#' 128. Otherwise, it must be less than or equal to 256.
+#' 
+#' @examples
+#' # Create genetic map for a single chromosome with 1 Morgan
+#' # Chromosome contains 11 equally spaced segregating sites
+#' genMaps = list(seq(0,1,length.out=11))
+#' founderPop = trackHaploPop(genMaps=genMaps,nInd=10)
+#' 
+#' @export
+trackHaploPop = function(genMaps,nInd,inbred=FALSE){
+  stopifnot(is.list(genMaps))
+  if(inbred){
+    stopifnot(nInd<=128)
+  }else{
+    stopifnot(nInd<=256)
+  }
+  nInd = as.integer(nInd)
+  nChr = length(genMaps)
+  nLoci = unlist(lapply(genMaps,length))
+  geno = vector(""list"",nChr)
+  for(i in 1:nChr){
+    tmpGeno = as.raw(0:(2*nInd-1))
+    tmpGeno = array(raw(),dim=c(nLoci[i],2L,nInd))
+    tmp=-1
+    for(j in 1:nInd){
+      if(inbred){
+        tmp=tmp+1
+        tmpGeno[,1:2,j] = as.raw(tmp)
+      }else{
+        for(k in 1:2){
+          tmp=tmp+1
+          tmpGeno[,k,j] = as.raw(tmp)
+        } 
+      }
+    }
+    geno[[i]] = tmpGeno
+  }
+  output = new(""MapPop"",nInd=nInd,nChr=nChr,ploidy=2L,
+               nLoci=nLoci,geno=as.matrix(geno),
+               genMaps=as.matrix(genMaps))
+  return(output)
+}
+
+#' @title Create founder genotypes using MaCS
+#'
+#' @description Uses an external programs MaCS and AlphaFormatter to produce initial founder genotypes.
+#' 
+#' @param nInd number of individuals to simulate
+#' @param nChr number of chromosomes to simulate
+#' @param segSites number of segregating sites to keep per chromosome
+#' @param inbred should founder individuals be inbred
+#' @param species species history to simulate. See details.
+#' @param split an optional historic population split in terms of generations ago.
+#' @param manualCommand user provided MaCS options. For advanced users only.
+#' @param manualGenLen user provided genLen option for use with manual command.  For advanced users only.
+#' 
+#' @details
+#' The current species histories are included: WHEAT, MAIZE, MAIZELANDRACE, CATTLE, 
+#' PIG, CHICKEN, RABBIT and TEST. TEST uses MaCS's default history.
+#'
+#' @return an object of \code{\link{MapPop-class}}
+#' 
+#' @examples 
+#' # Creates a populations of 10 outbred individuals
+#' # Their genome consists of 1 chromosome and 100 segregating sites
+#' founderPop = runMacs(nInd=10,nChr=1,segSites=100)
+#' 
+#' @export
+runMacs = function(nInd,nChr,segSites,inbred=FALSE,species=""TEST"",
+                   split=NULL,manualCommand=NULL,manualGenLen=NULL){
+  ploidy = 2 #The only ploidy level currently supported
+  if(length(segSites)==1){
+    segSites = rep(segSites,nChr)
+  }
+  if(inbred){
+    popSize = nInd
+  }else{
+    popSize = ploidy*nInd
+  }
+  if(!is.null(manualCommand)){
+    if(is.null(manualGenLen)) stop(""You must define manualGenLen"")
+    command = paste0(popSize,"" "",manualCommand,"" -s "",sample.int(1e8,1))
+    genLen = manualGenLen
+  }else{
+    species = toupper(species)
+    if(species==""WHEAT""){ #WHEAT----
+      genLen = 1.43
+      Ne = 50
+      speciesParams = ""800000000 -t 0.40E-06 -r 0.36E-06""
+      speciesHist = ""-eN 0.03 1 -eN 0.05 2 -eN 0.10 4 -eN 0.15 6 -eN 0.20 8 -eN 0.25 10 -eN 0.30 12 -eN 0.35 14 -eN 0.40 16 -eN 0.45 18 -eN 0.50 20 -eN 1.00 40 -eN 2.00 60 -eN 3.00 80 -eN 4.00 100 -eN 5.00 120 -eN 10.00 140 -eN 20.00 160 -eN 30.00 180 -eN 40.00 200 -eN 50.00 240 -eN 100.00 320 -eN 200.00 400 -eN 300.00 480 -eN 400.00 560 -eN 500.00 640""
+    }else if(species==""MAIZE""){ #MAIZE----
+      genLen = 2.0
+      Ne = 100
+      speciesParams = ""200000000 -t 0.50E-05 -r 0.40E-05""
+      speciesHist = ""-eN 0.03 1 -eN 0.05 2 -eN 0.10 4 -eN 0.15 6 -eN 0.20 8 -eN 0.25 10 -eN 0.30 12 -eN 0.35 14 -eN 0.40 16 -eN 0.45 18 -eN 0.50 20 -eN 2.00 40 -eN 3.00 60 -eN 4.00 80 -eN 5.00 100""
+    }else if(species==""MAIZELANDRACE""){ #MAIZELANDRACE----
+      genLen = 2.0
+      Ne = 100
+      speciesParams = ""200000000 -t 0.50E-05 -r 0.40E-05""
+      speciesHist = ""-eN 0.03 1 -eN 0.05 2 -eN 0.10 4 -eN 0.15 6 -eN 0.20 8 -eN 0.25 10 -eN 0.30 12 -eN 0.35 14 -eN 0.40 16 -eN 0.45 18 -eN 0.50 20 -eN 2.00 40 -eN 3.00 60 -eN 4.00 80 -eN 5.00 100 -eN 6.00 120 -eN 7.00 140 -eN 8.00 160 -eN 9.00 180 -eN 10.00 200 -eN 12.50 400 -eN 15.00 600 -eN 17.50 800 -eN 20.00 1000 -eN 22.50 1200 -eN 25.00 1400 -eN 27.50 1600 -eN 30.00 2000""
+    }else if(species==""CATTLE""){ #CATTLE----
+      genLen = 1.0
+      Ne = 100
+      speciesParams = ""100000000 -t 0.10E-04 -r 0.40E-05""
+      speciesHist = ""-eN 0.06 2.0 -eN 0.13 3.0 -eN 0.25 5.0 -eN 0.50 7.0 -eN 0.75 9.0 -eN 1.00 11.0 -eN 1.25 12.5 -eN 1.50 13.0 -eN 1.75 13.5 -eN 2.00 14.0 -eN 2.25 14.5 -eN 2.50 15.0 -eN 5.00 20.0 -eN 7.50 25.0 -eN 10.00 30.0 -eN 12.50 35.0 -eN 15.00 40.0 -eN 17.50 45.0 -eN 20.00 50.0 -eN 22.50 55.0 -eN 25.00 60.0 -eN 50.00 70.0 -eN 100.00 80.0 -eN 150.00 90.0 -eN 200.00 100.0 -eN 250.00 120.0 -eN 500.00 200.0 -eN 1000.00 400.0 -eN 1500.00 600.0 -eN 2000.00 800.0 -eN 2500.00 1000.0""
+    }else if(species==""PIG""){ #PIG----
+      genLen = 1.71
+      Ne = 100
+      speciesParams = ""675000000 -t 0.95E-06 -r 0.10E-05""
+      speciesHist = ""-eN 25.00 100.0 -eN 50.00 200.0 -eN 75.00 300.0 -eN 100.00 400.0 -eN 125.00 500.0 -eN 150.00 600.0 -eN 175.00 700.0 -eN 200.00 800.0 -eN 225.00 900.0 -eN 250.00 1000.0 -eN 275.00 2000.0 -eN 300.00 3000.0 -eN 325.00 4000.0 -eN 350.00 5000.0 -eN 375.00 6000.0 -eN 400.00 7000.0 -eN 425.00 8000.0 -eN 450.00 9000.0 -eN 475.00 10000.0""
+    }else if(species==""CHICKEN""){ #CHICKEN----
+      genLen = 0.84
+      Ne = 70
+      speciesParams = ""300000000 -t 0.23E-05 -r 0.78E-06""
+      speciesHist = ""-eN 0.18 0.71 -eN 0.36 1.43 -eN 0.54 2.14 -eN 0.71 2.86 -eN 0.89 3.57 -eN 1.07 4.29 -eN 1.25 5.00 -eN 1.43 5.71""
+    }else if(species==""RABBIT""){ #RABBIT----
+      genLen = 1.36
+      Ne = 100
+      speciesParams = ""159000000 -t 0.44E-05 -r 0.34E-05""
+      speciesHist = ""-eN 0.05 1.25 -eN 0.08 1.50 -eN 0.10 1.75 -eN 0.13 2.00 -eN 0.15 2.25 -eN 0.18 2.50 -eN 0.20 2.75 -eN 0.23 3.00 -eN 0.25 3.25 -eN 0.50 4.00 -eN 1.00 5.00 -eN 1.50 6.00 -eN 2.00 7.00 -eN 2.50 8.00 -eN 3.00 90.00 -eN 3.50 10.00 -eN 4.00 11.00 -eN 4.50 12.00 -eN 5.00 1000.00""
+    }else if(species==""TEST""){ #TEST----
+      genLen = 1.0
+      Ne = 100
+      speciesParams = ""100000000 -t 0.10E-04 -r 0.40E-05""
+      speciesHist = """"
+    }else{
+      stop(paste(""No rules for species"",species))
+    }
+    if(is.null(split)){
+      splitI = """"
+      splitJ = """"
+    }else{
+      stopifnot(popSize%%2==0)
+      splitI = paste("" -I 2"",popSize%/%2,popSize%/%2)
+      splitJ = paste("" -ej"",split/(4*Ne)+0.000001,""2 1"")
+    }
+    command = paste0(popSize,"" "",speciesParams,splitI,"" "",speciesHist,splitJ,"" -s "",sample.int(1e8,1))
+  }
+  output = vector(""list"",nChr)
+  for(chr in 1:nChr){
+    cat(""Making chomosome"",chr,""of"",nChr,""\n"")
+    macsOut = MaCS(command,segSites[chr])
+    genMap = c(macsOut$genMap)
+    genMap = genLen*(genMap-min(genMap))
+    geno = packHaplo(macsOut$haplo,ploidy=ploidy,
+                     inbred=inbred)
+    output[[chr]] = new(""MapPop"",
+                        nInd=as.integer(nInd),
+                        nChr=1L,
+                        ploidy=as.integer(ploidy),
+                        nLoci=as.integer(segSites[chr]),
+                        geno=as.matrix(list(geno)),
+                        genMaps=as.matrix(list(genMap)))
+  }
+  output = do.call(""c"",output)
+  cat(""Done\n"")
+  return(output)
+}
+
+#' @title Sample haplotypes from a MapPop
+#'
+#' @description 
+#' Creates a new \code{\link{MapPop-class}} from an existing 
+#' \code{\link{MapPop-class}} by randomly sampling haplotypes.
+#' 
+#' @param nInd the number of individuals to create
+#' @param mapPop the \code{\link{MapPop-class}} used to 
+#' sample haplotypes
+#' @param inbred should new individuals be fully inbred
+#' @param replace should haplotypes be sampled with replacement
+#' 
+#' @return an object of \code{\link{MapPop-class}}
+#' 
+#' @examples 
+#' # Create genetic map for a single chromosome with 1 Morgan
+#' # Chromosome contains 11 equally spaced segregating sites
+#' genMaps = list(seq(0,1,length.out=11))
+#' founderPop = trackHaploPop(genMaps=genMaps,nInd=2,inbred=TRUE)
+#' founderPop = sampleHaplo(nInd=20,mapPop=founderPop)
+#' 
+#' @export
+sampleHaplo = function(nInd,mapPop,inbred=FALSE,replace=TRUE){
+  nHaplo = mapPop@nInd*mapPop@ploidy
+  if(inbred){
+    nSamp = nInd
+  }else{
+    nSamp = nInd*mapPop@ploidy
+  }
+  output = vector(""list"",mapPop@nChr)
+  for(chr in 1:mapPop@nChr){
+    haplo = sample.int(nHaplo,nSamp,replace=replace)
+    geno = array(data=as.raw(0),
+                 dim=c(mapPop@nLoci[chr],
+                       mapPop@ploidy,nInd))
+    outHap = 1L 
+    outInd = 1L
+    for(i in 1:length(haplo)){
+      inHap = (haplo[i]-1L)%%mapPop@ploidy + 1L
+      inInd = (haplo[i]-1L)%/%mapPop@ploidy + 1L
+      if(inbred){
+        for(outHap in 1:mapPop@ploidy){
+          geno[,outHap,outInd] = 
+            mapPop@geno[[chr]][,inHap,inInd]
+        }
+        outInd = outInd+1L
+      }else{
+        geno[,outHap,outInd] = 
+          mapPop@geno[[chr]][,inHap,inInd]
+        outHap = outHap%%mapPop@ploidy+1L
+        if(outHap==1L){
+          outInd = outInd+1L
+        }
+      }
+    }
+    output[[chr]] = new(""MapPop"",
+                        nInd=as.integer(nInd),
+                        nChr=1L,
+                        ploidy=mapPop@ploidy,
+                        nLoci=mapPop@nLoci[chr],
+                        geno=as.matrix(list(geno)),
+                        genMaps=as.matrix(mapPop@genMaps[chr]))
+  }
+  output = do.call(""c"",output)
+  return(output)
+}

---FILE: R/hybrids.R---
@@ -182,7 +182,7 @@ calcGCA = function(pop,use=""pheno""){
 #' of length nTraits for independent error or a square matrix of 
 #' dimensions nTraits for correlated errors.
 #' @param reps number of replications for phenotype. See details.
-#' @param w the environmental covariate used by GxE traits.
+#' @param p the p-value for the environmental covariate 
 #' @param inbred are both pop and testers fully inbred. They are only 
 #' fully inbred if created by \code{\link{newPop}} using inbred founders 
 #' or by the \code{\link{makeDH}} function
@@ -205,7 +205,7 @@ calcGCA = function(pop,use=""pheno""){
 #' 
 #' @export
 setPhenoGCA = function(pop,testers,use=""pheno"",varE=NULL,reps=1,
-                       w=0.5,inbred=FALSE,chunkSize=10000,
+                       p=0.5,inbred=FALSE,chunkSize=10000,
                        onlyPheno=FALSE,simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
@@ -220,7 +220,7 @@ setPhenoGCA = function(pop,testers,use=""pheno"",varE=NULL,reps=1,
   tmp = hybridCross(females=pop,males=testers,crossPlan=""testcross"",
                     returnHybridPop=inbred,chunkSize=chunkSize,simParam=simParam)
   if(use==""pheno""){
-    tmp = setPheno(tmp,varE=varE,w=w,reps=reps,simParam=simParam)
+    tmp = setPheno(tmp,varE=varE,p=p,reps=reps,simParam=simParam)
   }
   tmp = calcGCA(pop=tmp,use=use)
   if(onlyPheno){

---FILE: R/phenotypes.R---
@@ -43,7 +43,8 @@ addError = function(gv,varE,reps=1){
 #' nTraits for independent error or a square matrix of dimensions 
 #' nTraits for correlated errors. If NULL, value in simParam is used.
 #' @param reps number of replications for phenotype. See details.
-#' @param w the environmental covariate used by GxE traits.
+#' @param p the p-value for the environmental covariate 
+#' used by GxE traits.
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
 #' @details
@@ -56,16 +57,16 @@ addError = function(gv,varE,reps=1){
 #' @return Returns a matrix of nInd by nTrait phenotypes
 #' 
 #' @export
-calcPheno = function(pop,varE=NULL,reps=1,w=0.5,
+calcPheno = function(pop,varE=NULL,reps=1,p=0.5,
                      simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
   validObject(pop)
-  if(length(w)==1){
-    w = rep(w,simParam$nTraits)
+  if(length(p)==1){
+    p = rep(p,simParam$nTraits)
   }
-  stopifnot(length(w)==simParam$nTraits)
+  stopifnot(length(p)==simParam$nTraits)
   gv = pop@gv
   if(is.null(varE)){
     varE = simParam$varE
@@ -74,7 +75,7 @@ calcPheno = function(pop,varE=NULL,reps=1,w=0.5,
     traitClass = class(simParam$traits[[i]])
     if(traitClass==""TraitAG"" | traitClass==""TraitADG""){
       stdDev = sqrt(simParam$traits[[i]]@envVar)
-      gv[,i] = gv[,i]+pop@gxe[[i]]*qnorm(w[i],sd=stdDev)
+      gv[,i] = gv[,i]+pop@gxe[[i]]*qnorm(p[i],sd=stdDev)
     }
   }
   pheno = addError(gv=gv,varE=varE,reps=reps)
@@ -93,7 +94,8 @@ calcPheno = function(pop,varE=NULL,reps=1,w=0.5,
 #' nTraits for independent error or a square matrix of dimensions 
 #' nTraits for correlated errors. If NULL, value in simParam is used.
 #' @param reps number of replications for phenotype. See details.
-#' @param w the environmental covariate used by GxE traits.
+#' @param p the p-value for the environmental covariate 
+#' used by GxE traits.
 #' @param simParam an object of \code{\link{SimParam}}
 #' 
 #' @details
@@ -107,11 +109,11 @@ calcPheno = function(pop,varE=NULL,reps=1,w=0.5,
 #' \code{\link{HybridPop-class}}
 #' 
 #' @export
-setPheno = function(pop,varE=NULL,reps=1,w=0.5,simParam=NULL){
+setPheno = function(pop,varE=NULL,reps=1,p=0.5,simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }
-  pop@pheno = calcPheno(pop=pop,varE=varE,reps=reps,w=w,
+  pop@pheno = calcPheno(pop=pop,varE=varE,reps=reps,p=p,
                         simParam=simParam)
   validObject(pop)
   return(pop)

---FILE: R/pullGeno.R---
@@ -252,7 +252,8 @@ pullQtlHaplo = function(pop, trait=1, haplo=""all"",
 #' @description 
 #' Retrieves haplotype data for all segregating sites
 #'
-#' @param pop an object of \code{\link{Pop-class}}
+#' @param pop an object of \code{\link{Pop-class}} or 
+#' \code{\link{RawPop-class}}
 #' @param haplo either ""all"" for all haplotypes or an integer 
 #' for a single set of haplotypes. Use a value of 1 for female 
 #' haplotyes and a value of 2 for male haplotypes.
@@ -272,17 +273,25 @@ pullSegSiteHaplo = function(pop, haplo=""all"",
                       simParam$segSites,
                       allLoci)
     output = convToImat(output)
-    rownames(output) = paste(rep(pop@id,each=pop@ploidy),
-                             rep(1:pop@ploidy,pop@nInd),sep=""_"")
+    if(class(pop)==""Pop""){
+      rownames(output) = paste(rep(pop@id,each=pop@ploidy),
+                               rep(1:pop@ploidy,pop@nInd),sep=""_"")
+    }else{
+      rownames(output) = paste(rep(1:pop@nInd,each=pop@ploidy),
+                               rep(1:pop@ploidy,pop@nInd),sep=""_"")
+    }
   }else{
     stopifnot(haplo%in%c(1,2))
     output = getOneHaplo(pop@geno,
                          simParam$segSites,
                          allLoci,
                          as.integer(haplo))
     output = convToImat(output)
-    rownames(output) = paste(pop@id,rep(haplo,pop@nInd),sep=""_"")
-    
+    if(class(pop)==""Pop""){
+      rownames(output) = paste(pop@id,rep(haplo,pop@nInd),sep=""_"")
+    }else{
+      rownames(output) = paste(1:pop@nInd,rep(haplo,pop@nInd),sep=""_"")
+    }
   }
   colnames(output) = paste(""SITE"",1:ncol(output),sep=""_"")
   return(output)

---FILE: R/quickPop.R---
@@ -1,89 +0,0 @@
-#' @title Quick founder genotypes
-#'
-#' @description 
-#' Creates founder genotypes with evely spaced segregating 
-#' sites and allele frequencies of 0.5.
-#' 
-#' @param nInd number of individuals
-#' @param nChr number of chromosomes
-#' @param segSites number of segregating sites per chromosome
-#' @param genLen genetic length of chromosomes in Morgans
-#' @param inbred should founder individuals be inbred
-#' 
-#' @return an object of \code{\link{MapPop-class}}
-#' 
-#' @export
-quickPop = function(nInd,nChr,segSites,genLen=1,inbred=TRUE){
-  geno = vector(""list"",nChr)
-  genMaps = vector(""list"",nChr)
-  for(i in 1:nChr){
-    genMaps[[i]] = seq(0,genLen,length.out=segSites)
-    geno[[i]] = array(sample(as.raw(c(0,1)),nInd*segSites*2,
-                                    replace=TRUE),
-                      dim=c(segSites,2,nInd))
-    if(inbred){
-      geno[[i]][,2,] = geno[[i]][,1,]
-    }
-  }
-  output = new(""MapPop"",nInd=as.integer(nInd),nChr=as.integer(nChr),
-               ploidy=2L,nLoci=as.integer(rep(segSites,nChr)),
-               geno=as.matrix(geno),genMaps=as.matrix(genMaps))
-  return(output)
-}
-
-#' @title Haplotype tracking population
-#' 
-#' @description
-#' Creates a population for tracking haplotypes.
-#'
-#' @param genMaps a list of genetic maps
-#' @param nInd number of individuals
-#' @param inbred should individuals be fully inbred
-#' 
-#' @details
-#' The number of chromosomes is determined by the length of genMaps. 
-#' Each item of genMaps must be a vector of ordered numeric values and 
-#' the first value must be zero. The length of the vector determines the 
-#' number of segregating sites on the chromosome.
-#' 
-#' If inbred=FALSE, the value of nInd must be less than or equal to 
-#' 128. Otherwise, it must be less than or equal to 256.
-#' 
-#' @examples
-#' genMaps = list(seq(0,1,length.out=11))
-#' FOUNDERPOP = trackHaploPop(genMaps=genMaps,nInd=10)
-#' 
-#' @export
-trackHaploPop = function(genMaps,nInd,inbred=FALSE){
-  stopifnot(is.list(genMaps))
-  if(inbred){
-    stopifnot(nInd<=128)
-  }else{
-    stopifnot(nInd<=256)
-  }
-  nInd = as.integer(nInd)
-  nChr = length(genMaps)
-  nLoci = unlist(lapply(genMaps,length))
-  geno = vector(""list"",nChr)
-  for(i in 1:nChr){
-    tmpGeno = as.raw(0:(2*nInd-1))
-    tmpGeno = array(raw(),dim=c(nLoci[i],2L,nInd))
-    tmp=-1
-    for(j in 1:nInd){
-      if(inbred){
-        tmp=tmp+1
-        tmpGeno[,1:2,j] = as.raw(tmp)
-      }else{
-        for(k in 1:2){
-          tmp=tmp+1
-          tmpGeno[,k,j] = as.raw(tmp)
-        } 
-      }
-    }
-    geno[[i]] = tmpGeno
-  }
-  output = new(""MapPop"",nInd=nInd,nChr=nChr,ploidy=2L,
-               nLoci=nLoci,geno=as.matrix(geno),
-               genMaps=as.matrix(genMaps))
-  return(output)
-}

---FILE: R/runMacs.R---
@@ -1,112 +0,0 @@
-# A stop-gap solution until MaCS is integrated
-
-#' @title Create founder genotypes using MaCS
-#'
-#' @description Uses an external programs MaCS and AlphaFormatter to produce initial founder genotypes.
-#' 
-#' @param nInd number of individuals to simulate
-#' @param nChr number of chromosomes to simulate
-#' @param segSites number of segregating sites to keep per chromosome
-#' @param inbred should founder individuals be inbred
-#' @param species species history to simulate. See details.
-#' @param split an optional historic population split in terms of generations ago.
-#' @param manualCommand user provided MaCS options. For advanced users only.
-#' @param manualGenLen user provided genLen option for use with manual command.  For advanced users only.
-#' 
-#' @details
-#' The current species histories are included: WHEAT, MAIZE, MAIZELANDRACE, CATTLE, 
-#' PIG, CHICKEN, RABBIT and TEST. TEST uses MaCS's default history.
-#'
-#' @return an object of \code{\link{MapPop-class}}
-#' 
-#' @export
-runMacs = function(nInd,nChr,segSites,inbred=FALSE,species=""TEST"",
-                   split=NULL,manualCommand=NULL,manualGenLen=NULL){
-  ploidy = 2 #The only ploidy level currently supported
-  if(length(segSites)==1){
-    segSites = rep(segSites,nChr)
-  }
-  if(inbred){
-    popSize = nInd
-  }else{
-    popSize = ploidy*nInd
-  }
-  if(!is.null(manualCommand)){
-    if(is.null(manualGenLen)) stop(""You must define manualGenLen"")
-    command = paste0(popSize,"" "",manualCommand,"" -s "",sample.int(1e8,1))
-    genLen = manualGenLen
-  }else{
-    species = toupper(species)
-    if(species==""WHEAT""){ #WHEAT----
-      genLen = 1.43
-      Ne = 50
-      speciesParams = ""800000000 -t 0.40E-06 -r 0.36E-06""
-      speciesHist = ""-eN 0.03 1 -eN 0.05 2 -eN 0.10 4 -eN 0.15 6 -eN 0.20 8 -eN 0.25 10 -eN 0.30 12 -eN 0.35 14 -eN 0.40 16 -eN 0.45 18 -eN 0.50 20 -eN 1.00 40 -eN 2.00 60 -eN 3.00 80 -eN 4.00 100 -eN 5.00 120 -eN 10.00 140 -eN 20.00 160 -eN 30.00 180 -eN 40.00 200 -eN 50.00 240 -eN 100.00 320 -eN 200.00 400 -eN 300.00 480 -eN 400.00 560 -eN 500.00 640""
-    }else if(species==""MAIZE""){ #MAIZE----
-      genLen = 2.0
-      Ne = 100
-      speciesParams = ""200000000 -t 0.50E-05 -r 0.40E-05""
-      speciesHist = ""-eN 0.03 1 -eN 0.05 2 -eN 0.10 4 -eN 0.15 6 -eN 0.20 8 -eN 0.25 10 -eN 0.30 12 -eN 0.35 14 -eN 0.40 16 -eN 0.45 18 -eN 0.50 20 -eN 2.00 40 -eN 3.00 60 -eN 4.00 80 -eN 5.00 100""
-    }else if(species==""MAIZELANDRACE""){ #MAIZELANDRACE----
-      genLen = 2.0
-      Ne = 100
-      speciesParams = ""200000000 -t 0.50E-05 -r 0.40E-05""
-      speciesHist = ""-eN 0.03 1 -eN 0.05 2 -eN 0.10 4 -eN 0.15 6 -eN 0.20 8 -eN 0.25 10 -eN 0.30 12 -eN 0.35 14 -eN 0.40 16 -eN 0.45 18 -eN 0.50 20 -eN 2.00 40 -eN 3.00 60 -eN 4.00 80 -eN 5.00 100 -eN 6.00 120 -eN 7.00 140 -eN 8.00 160 -eN 9.00 180 -eN 10.00 200 -eN 12.50 400 -eN 15.00 600 -eN 17.50 800 -eN 20.00 1000 -eN 22.50 1200 -eN 25.00 1400 -eN 27.50 1600 -eN 30.00 2000""
-    }else if(species==""CATTLE""){ #CATTLE----
-      genLen = 1.0
-      Ne = 100
-      speciesParams = ""100000000 -t 0.10E-04 -r 0.40E-05""
-      speciesHist = ""-eN 0.06 2.0 -eN 0.13 3.0 -eN 0.25 5.0 -eN 0.50 7.0 -eN 0.75 9.0 -eN 1.00 11.0 -eN 1.25 12.5 -eN 1.50 13.0 -eN 1.75 13.5 -eN 2.00 14.0 -eN 2.25 14.5 -eN 2.50 15.0 -eN 5.00 20.0 -eN 7.50 25.0 -eN 10.00 30.0 -eN 12.50 35.0 -eN 15.00 40.0 -eN 17.50 45.0 -eN 20.00 50.0 -eN 22.50 55.0 -eN 25.00 60.0 -eN 50.00 70.0 -eN 100.00 80.0 -eN 150.00 90.0 -eN 200.00 100.0 -eN 250.00 120.0 -eN 500.00 200.0 -eN 1000.00 400.0 -eN 1500.00 600.0 -eN 2000.00 800.0 -eN 2500.00 1000.0""
-    }else if(species==""PIG""){ #PIG----
-      genLen = 1.71
-      Ne = 100
-      speciesParams = ""675000000 -t 0.95E-06 -r 0.10E-05""
-      speciesHist = ""-eN 25.00 100.0 -eN 50.00 200.0 -eN 75.00 300.0 -eN 100.00 400.0 -eN 125.00 500.0 -eN 150.00 600.0 -eN 175.00 700.0 -eN 200.00 800.0 -eN 225.00 900.0 -eN 250.00 1000.0 -eN 275.00 2000.0 -eN 300.00 3000.0 -eN 325.00 4000.0 -eN 350.00 5000.0 -eN 375.00 6000.0 -eN 400.00 7000.0 -eN 425.00 8000.0 -eN 450.00 9000.0 -eN 475.00 10000.0""
-    }else if(species==""CHICKEN""){ #CHICKEN----
-      genLen = 0.84
-      Ne = 70
-      speciesParams = ""300000000 -t 0.23E-05 -r 0.78E-06""
-      speciesHist = ""-eN 0.18 0.71 -eN 0.36 1.43 -eN 0.54 2.14 -eN 0.71 2.86 -eN 0.89 3.57 -eN 1.07 4.29 -eN 1.25 5.00 -eN 1.43 5.71""
-    }else if(species==""RABBIT""){ #RABBIT----
-      genLen = 1.36
-      Ne = 100
-      speciesParams = ""159000000 -t 0.44E-05 -r 0.34E-05""
-      speciesHist = ""-eN 0.05 1.25 -eN 0.08 1.50 -eN 0.10 1.75 -eN 0.13 2.00 -eN 0.15 2.25 -eN 0.18 2.50 -eN 0.20 2.75 -eN 0.23 3.00 -eN 0.25 3.25 -eN 0.50 4.00 -eN 1.00 5.00 -eN 1.50 6.00 -eN 2.00 7.00 -eN 2.50 8.00 -eN 3.00 90.00 -eN 3.50 10.00 -eN 4.00 11.00 -eN 4.50 12.00 -eN 5.00 1000.00""
-    }else if(species==""TEST""){ #TEST----
-      genLen = 1.0
-      Ne = 100
-      speciesParams = ""100000000 -t 0.10E-04 -r 0.40E-05""
-      speciesHist = """"
-    }else{
-      stop(paste(""No rules for species"",species))
-    }
-    if(is.null(split)){
-      splitI = """"
-      splitJ = """"
-    }else{
-      stopifnot(popSize%%2==0)
-      splitI = paste("" -I 2"",popSize%/%2,popSize%/%2)
-      splitJ = paste("" -ej"",split/(4*Ne)+0.000001,""2 1"")
-    }
-    command = paste0(popSize,"" "",speciesParams,splitI,"" "",speciesHist,splitJ,"" -s "",sample.int(1e8,1))
-  }
-  output = vector(""list"",nChr)
-  for(chr in 1:nChr){
-    cat(""Making chomosome"",chr,""of"",nChr,""\n"")
-    macsOut = MaCS(command,segSites[chr])
-    genMap = c(macsOut$genMap)
-    genMap = genLen*(genMap-min(genMap))
-    geno = packHaplo(macsOut$haplo,ploidy=ploidy,
-                     inbred=inbred)
-    output[[chr]] = new(""MapPop"",
-                        nInd=as.integer(nInd),
-                        nChr=1L,
-                        ploidy=as.integer(ploidy),
-                        nLoci=as.integer(segSites[chr]),
-                        geno=as.matrix(list(geno)),
-                        genMaps=as.matrix(list(genMap)))
-  }
-  output = do.call(""c"",output)
-  cat(""Done\n"")
-  return(output)
-}

---FILE: inst/doc/introduction.R---
@@ -1 +0,0 @@
-

---FILE: inst/doc/introduction.Rmd---
@@ -1,69 +0,0 @@
----
-title: ""Introduction to AlphaSimR""
-author: ""Chris Gaynor""
-date: ""`r Sys.Date()`""
-output: pdf_document
-bibliography: bibliography.bib
-vignette: >
-  %\VignetteIndexEntry{Introduction}
-  %\VignetteEngine{knitr::rmarkdown}
-  %\VignetteEncoding{UTF-8}
----
-
-
-The AlphaSimR package provides a framework for simulating plant and animal breeding programs in R. It is based on the AlphaSim program [@AlphaSim]. This document will introduce the basic steps for running a simulation in AlphaSimR.
-
-The basic steps of an AlphaSimR simulation are:
-
-1. Create founder haplotypes using `runMacs`
-
-2. Set simulation parameters using `createSimulation`
-
-3. Add traits using `addTraitA` or any other addTrait function
-
-4. Add SNP chips using `addSnpChip` (optional)
-
-5. Create one or more initial populations using `newPop`
-
-6. Perform a mix of crossing and selection to simulate a breeding program
-
-# Creating Founder Haplotypes
-
-The first step in an AlphaSimR simulation is to create a set of founder haplotypes. To do this, run the function `runMacs`. The `runMacs` function uses a built in version of the MaCS program [@MaCS]. The `runMacs` function allows for simulation of haplotypes using several predefined species histories or can be used to create a custom population using MaCS command line arguments. 
-
-# Setting Simulation Parameters
-
-Parameters for a simulation are stored in an object of `SimParam-class`. The function `createSimulation` creates this object. The `SimParam-class` is a container for global parameters that will be used by many functions in AlphaSimR. To avoid specifying a `SimParam-class` in all functions that use one, it is recommended that you give your `SimParam-class` the name `SIMPARAM`. All functions that take a `SimParam-class` as an arguement will search your global environment for an object called `SIMPARAM` if the argument is `NULL`.
-
-# Adding Traits
-
-Traits are added to the simulation using one of the fullowing functions: `addTraitA`, `addTraitAD`, `addTraitAG`, or `addTraitADG`. These functions can be called multiple times to run simulations with multiple traits. These functions can also be used to simulate correlated pleiotropic traits. Simulations without any traits are possible as long as you don't use a selection function.
-
-# Adding SNP Chips
-
-SNP chips are added to the simulation using the `addSnpChip` or `addStructuredSnpChips` functions. As with traits, these functions can be called multiple times to assign multiple SNP chips. SNP chips are not necessary for a simulation, so this step can be skipped.
-
-# Creating a Population
-
-The main objects in an AlphaSimR simulation are `Pop-class` objects. These objects represent a population that contains one or more individuals. Many AlphaSimR functions use a `Pop-class` object as an argument and return a `Pop-class` object as a result.
-
-To create your first `Pop-class` object use the function `newPop`. This function should only be called after you have finished all of the above steps.
-
-# Working with Populations
-
-Listed below are some functions for carrying out operations on populations.
-
-* Viewing genotypes: `pullSnpGeno`, `pullSnpHaplo`, `pullQtlGeno`, `pullQtlHaplo`, `pullSegSitHaplo`
-
-* Viewing summary data: `meanG`, `meanP`, `varG`, `varP`, `varAD`
-
-* Setting phenotypes: `setPheno`, `calcPheno`, `setPhenoGCA`
-
-* Making selections: `selectInd`, `selectFam`, `selectWithinFam`, `selectMale`, `selectFemale`
-
-* Crossing: `makeCross`, `randCross`, `makeCross2`, `randCross2`,
-`self`, `makeDH`
-
-* Genomic selection: `writeRecords`, `setEBV`
-
-# References
\ No newline at end of file

---FILE: man/MaCS.Rd---
@@ -1,25 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/RcppExports.R
-\name{MaCS}
-\alias{MaCS}
-\title{Markovian Coalescent Simulator}
-\usage{
-MaCS(args, maxSites = 0L)
-}
-\arguments{
-\item{args}{command line arguments passed to MaCS.}
-
-\item{maxSites}{maximum number of segregating sites to 
-return. If value is 0, all segregating sites are returned. 
-Otherwise, segregating sites are randomly sampled.}
-}
-\value{
-A list containing a matrix of haplotypes and a 
-vector of genetic distances.
-}
-\description{
-Runs a built-in version of the Markovian Coalescent Simulator.
-}
-\references{
-\cite{Chen, G.K., P. Marjoram, and J.D. Wall. 2009. Fast and flexible simulation of DNA sequence data. Genome Res. 19(1): 136142.}
-}

---FILE: man/SimParam.Rd---
@@ -1,6 +1,6 @@
 % Generated by roxygen2: do not edit by hand
 % Please edit documentation in R/Class-SimParam.R
-\docType{class}
+\docType{data}
 \name{SimParam}
 \alias{SimParam}
 \title{Simulation parameters}

---FILE: man/SimParam_addSnpChip.Rd---
@@ -10,3 +10,7 @@ Can be a single value or nChr values.}
 \description{
 Randomly assigns eligble SNPs to a SNP chip
 }
+\section{Usage}{
+ SP$addSnpChip(nSnpPerChr)
+}
+

---FILE: man/SimParam_addStructuredSnpChips.Rd---
@@ -14,3 +14,7 @@ If value is true then that snp is on that chip.}
 Randomly selects the number of snps in structure and then
 assigns them to chips based on structure
 }
+\section{Usage}{
+ SP$addStructuredSnpChip(nSnpPerChr, structure)
+}
+

---FILE: man/SimParam_addTraitA.Rd---
@@ -22,3 +22,8 @@ Randomly assigns eligble QTLs for one ore more additive traits.
 If simulating more than one trait, all traits will be pleiotrophic 
 with correlated additive effects.
 }
+\section{Usage}{
+ SP$addTraitA(nQtlPerChr, mean = 0, var = 1, corr = NULL, 
+gamma = FALSE, shape = 1)
+}
+

---FILE: man/SimParam_addTraitAD.Rd---
@@ -31,3 +31,9 @@ Randomly assigns eligble QTLs for one or more traits with dominance.
 If simulating more than one trait, all traits will be pleiotrophic 
 with correlated additive effects.
 }
+\section{Usage}{
+ SP$addTraitAD(nQtlPerChr, mean = 0, var = 1, meanDD = 0, 
+varDD = 0, corA = NULL, corDD = NULL, useVarA = TRUE, gamma = FALSE, 
+shape = 1)
+}
+

---FILE: man/SimParam_addTraitADG.Rd---
@@ -35,3 +35,9 @@ Note that shape=1 is equivalent to an exponential distribution.}
 \description{
 Randomly assigns eligble QTLs for a trait with dominance and GxE.
 }
+\section{Usage}{
+ SP$addTraitAG(nQtlPerChr, mean = 0, var = 1, varEnv = 1e-6, 
+varGxE = 1e-6, meanDD = 0, varDD = 0, corA = NULL, corDD = NULL, 
+corGxE = NULL, useVarA = TRUE, gamma = FALSE, shape = 1)
+}
+

---FILE: man/SimParam_addTraitAG.Rd---
@@ -28,3 +28,8 @@ Randomly assigns eligble QTLs for one ore more additive GxE traits.
 If simulating more than one trait, all traits will be pleiotrophic 
 with correlated effects.
 }
+\section{Usage}{
+ SP$addTraitAG(nQtlPerChr, mean = 0, var = 1, varEnv = 1e-6, 
+varGxE = 1e-6, corA = NULL, corGxE = NULL, gamma = FALSE, shape = 1)
+}
+

---FILE: man/SimParam_new.Rd---
@@ -16,3 +16,7 @@ their simParam arguments are NULL. This allows you to call
 these functions without explicitly supplying a simParam 
 argument with every call.
 }
+\section{Usage}{
+ SimParam$new(founderPop)
+}
+

---FILE: man/SimParam_removeFounderPop.Rd---
@@ -2,9 +2,24 @@
 % Please edit documentation in R/Class-SimParam.R
 \name{SimParam_removeFounderPop}
 \alias{SimParam_removeFounderPop}
-\title{Remove founder population}
+\alias{SimParam_removeFounderPop}
+\title{Switch founder population}
 \description{
+Switches the founder population in the founderPop 
+field. This may be desirable if traits are to be 
+tuned to a population derived from the original 
+founderPop. Note that no checking is performed to verify 
+that the genetic map and/or number of segregating sites 
+hasn't changed. The new founderPop can be 
+\code{\link{MapPop-class}} or \code{\link{RawPop-class}}
+
 Removes the founder population from the founderPop 
 field. This can be ran after all traits have been 
 added to reduce the size of the SimParam object.
 }
+\section{Usage}{
+ SP$switchFounderPop(founderPop)
+
+ SP$removeFounderPop()
+}
+

---FILE: man/SimParam_removeSnpChip.Rd---
@@ -9,3 +9,7 @@
 \description{
 Removes designated SNP chip(s).
 }
+\section{Usage}{
+ SP$removeSnpChip(chips)
+}
+

---FILE: man/SimParam_removeTrait.Rd---
@@ -9,3 +9,7 @@
 \description{
 Removes designated trait(s).
 }
+\section{Usage}{
+ SP$removeTrait(traits)
+}
+

---FILE: man/SimParam_rescaleTraits.Rd---
@@ -6,9 +6,9 @@
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}}}
 
-\item{meanG}{a vector of new trait means}
+\item{mean}{a vector of new trait means}
 
-\item{varG}{a vector of new trait variances}
+\item{var}{a vector of new trait variances}
 
 \item{varEnv}{a vector of new environmental variances}
 
@@ -24,3 +24,8 @@ values of means and variances.
 You must run \code{\link{resetPop}} on existing 
 populations to obtain the new trait values.
 }
+\section{Usage}{
+ SP$rescaleTraits(pop, mean = 0, var = 1, varEnv = 1e-6, 
+varGxE = 1e-6, useVarA = TRUE)
+}
+

---FILE: man/SimParam_resetPed.Rd---
@@ -10,3 +10,7 @@ using \code{\link{Pop-class}} objects created before running this
 function, because they are tied to the older pedigree that is 
 being deleted.
 }
+\section{Usage}{
+ SP$resetPed()
+}
+

---FILE: man/SimParam_restrSegSites.Rd---
@@ -22,3 +22,8 @@ No minimum SNP frequency is used if value is NULL.}
 Sets restrictions on which segregating sites 
 can serve and SNP and/or QTL loci.
 }
+\section{Usage}{
+ SP$restrSegSites(maxQtl = 0, maxSnp = 0, 
+snpQtlOverlap = FALSE, minSnpFreq = NULL)
+}
+

---FILE: man/SimParam_setCorrVarE.Rd---
@@ -11,3 +11,7 @@ Defines a correlation structure for default
 error variances. You must call \code{\link{SimParam_setVarE}} 
 first to define the default error variances.
 }
+\section{Usage}{
+ SP$setCorrVarE(corr)
+}
+

---FILE: man/SimParam_setGender.Rd---
@@ -17,3 +17,7 @@ Thus, odd numbers of individuals will have one more male than
 female. The value ""yes_rand"" will randomly assign gender to 
 individuals.
 }
+\section{Usage}{
+ SP$setGender(gender)
+}
+

---FILE: man/SimParam_setRecombRatio.Rd---
@@ -15,3 +15,7 @@ A value of 2 specifies twice as much recombination in females
 and a value of 0.5 specifies half as much recombination in 
 females.
 }
+\section{Usage}{
+ SP$setRecombRatio(ratio)
+}
+

---FILE: man/SimParam_setTrackPed.Rd---
@@ -14,3 +14,7 @@ except those created by \code{\link{hybridCross}}. Turning
 off pedigree tracking will turn off recombination tracking 
 if it is turned on.
 }
+\section{Usage}{
+ SP$setTrackPed(isTrackPed)
+}
+

---FILE: man/SimParam_setTrackRec.Rd---
@@ -14,3 +14,7 @@ Recombination tracking keeps records of all individuals created,
 except those created by \code{\link{hybridCross}}, because their 
 pedigree is not tracked.
 }
+\section{Usage}{
+ SimParam$setTrackRec(isTrackRec)
+}
+

---FILE: man/SimParam_setVarE.Rd---
@@ -14,3 +14,7 @@
 Defines a default value for error 
 variances in the simulation.
 }
+\section{Usage}{
+ SP$setVarE(h2 = NULL, H2 = NULL, varE = NULL)
+}
+

---FILE: man/SimParam_switchSnpChip.Rd---
@@ -11,3 +11,7 @@
 \description{
 Replaces the \code{\link{LociMap-class}} for a SNP chip.
 }
+\section{Usage}{
+ SP$switchSnpChips(lociMap, chip)
+}
+

---FILE: man/SimParam_switchTrait.Rd---
@@ -18,3 +18,7 @@ If NULL, the existing value is retained.}
 \description{
 Replaces an existing trait.
 }
+\section{Usage}{
+ SP$switchTrait(lociMap, trait, varA = NULL, varG = NULL)
+}
+

---FILE: man/calcPheno.Rd---
@@ -4,7 +4,7 @@
 \alias{calcPheno}
 \title{Calculate phenotypes}
 \usage{
-calcPheno(pop, varE = NULL, reps = 1, w = 0.5, simParam = NULL)
+calcPheno(pop, varE = NULL, reps = 1, p = 0.5, simParam = NULL)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}} or 
@@ -16,7 +16,8 @@ nTraits for correlated errors. If NULL, value in simParam is used.}
 
 \item{reps}{number of replications for phenotype. See details.}
 
-\item{w}{the environmental covariate used by GxE traits.}
+\item{p}{the p-value for the environmental covariate 
+used by GxE traits.}
 
 \item{simParam}{an object of \code{\link{SimParam}}}
 }

---FILE: man/newMapPop.Rd---
@@ -0,0 +1,48 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/founderPop.R
+\name{newMapPop}
+\alias{newMapPop}
+\title{New MapPop}
+\usage{
+newMapPop(genMaps, haplotypes, inbred = FALSE)
+}
+\arguments{
+\item{genMaps}{a list of genetic maps}
+
+\item{haplotypes}{a list of matrices or data.frames that 
+can be coerced to matrices. See details.}
+
+\item{inbred}{are individuals fully inbred}
+}
+\value{
+an object of \code{\link{MapPop-class}}
+}
+\description{
+Creates a new \code{\link{MapPop-class}} from user supplied 
+genetic maps and haplotypes.
+}
+\details{
+Each item of genMaps must be a vector of ordered genetic lengths in 
+Morgans. The first value must be zero. The length of the vector 
+determines the number of segregating sites on the chromosome.
+
+Each item of haplotypes must be coercible to a matrix. The columns 
+of this matrix correspond to segregating sites and their number must 
+match
+}
+\examples{
+# Create genetic map for two chromosomes, each 1 Morgan long
+# Each chromosome contains 11 equally spaced segregating sites
+genMaps = list(seq(0,1,length.out=11),
+               seq(0,1,length.out=11))
+               
+# Create haplotypes for 10 outbred individuals
+chr1 = sample(x=0:1,size=20*11,replace=TRUE)
+chr1 = matrix(chr1,nrow=20,ncol=11)
+chr2 = sample(x=0:1,size=20*11,replace=TRUE)
+chr2 = matrix(chr2,nrow=20,ncol=11)
+haplotypes = list(chr1,chr2)
+
+founderPop = newMapPop(genMaps=genMaps,haplotypes=haplotypes)
+
+}

---FILE: man/pullSegSiteHaplo.Rd---
@@ -7,7 +7,8 @@
 pullSegSiteHaplo(pop, haplo = ""all"", simParam = NULL)
 }
 \arguments{
-\item{pop}{an object of \code{\link{Pop-class}}}
+\item{pop}{an object of \code{\link{Pop-class}} or 
+\code{\link{RawPop-class}}}
 
 \item{haplo}{either ""all"" for all haplotypes or an integer 
 for a single set of haplotypes. Use a value of 1 for female 

---FILE: man/quickPop.Rd---
@@ -1,26 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/quickPop.R
-\name{quickPop}
-\alias{quickPop}
-\title{Quick founder genotypes}
-\usage{
-quickPop(nInd, nChr, segSites, genLen = 1, inbred = TRUE)
-}
-\arguments{
-\item{nInd}{number of individuals}
-
-\item{nChr}{number of chromosomes}
-
-\item{segSites}{number of segregating sites per chromosome}
-
-\item{genLen}{genetic length of chromosomes in Morgans}
-
-\item{inbred}{should founder individuals be inbred}
-}
-\value{
-an object of \code{\link{MapPop-class}}
-}
-\description{
-Creates founder genotypes with evely spaced segregating 
-sites and allele frequencies of 0.5.
-}

---FILE: man/runMacs.Rd---
@@ -1,5 +1,5 @@
 % Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/runMacs.R
+% Please edit documentation in R/founderPop.R
 \name{runMacs}
 \alias{runMacs}
 \title{Create founder genotypes using MaCS}
@@ -34,3 +34,9 @@ Uses an external programs MaCS and AlphaFormatter to produce initial founder gen
 The current species histories are included: WHEAT, MAIZE, MAIZELANDRACE, CATTLE, 
 PIG, CHICKEN, RABBIT and TEST. TEST uses MaCS's default history.
 }
+\examples{
+# Creates a populations of 10 outbred individuals
+# Their genome consists of 1 chromosome and 100 segregating sites
+founderPop = runMacs(nInd=10,nChr=1,segSites=100)
+
+}

---FILE: man/sampleHaplo.Rd---
@@ -0,0 +1,33 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/founderPop.R
+\name{sampleHaplo}
+\alias{sampleHaplo}
+\title{Sample haplotypes from a MapPop}
+\usage{
+sampleHaplo(nInd, mapPop, inbred = FALSE, replace = TRUE)
+}
+\arguments{
+\item{nInd}{the number of individuals to create}
+
+\item{mapPop}{the \code{\link{MapPop-class}} used to 
+sample haplotypes}
+
+\item{inbred}{should new individuals be fully inbred}
+
+\item{replace}{should haplotypes be sampled with replacement}
+}
+\value{
+an object of \code{\link{MapPop-class}}
+}
+\description{
+Creates a new \code{\link{MapPop-class}} from an existing 
+\code{\link{MapPop-class}} by randomly sampling haplotypes.
+}
+\examples{
+# Create genetic map for a single chromosome with 1 Morgan
+# Chromosome contains 11 equally spaced segregating sites
+genMaps = list(seq(0,1,length.out=11))
+founderPop = trackHaploPop(genMaps=genMaps,nInd=2,inbred=TRUE)
+founderPop = sampleHaplo(nInd=20,mapPop=founderPop)
+
+}

---FILE: man/setEBV.Rd---
@@ -4,7 +4,7 @@
 \alias{setEBV}
 \title{Set EBV}
 \usage{
-setEBV(pop, solution, gender = NULL, useD = FALSE, append = FALSE)
+setEBV(pop, solution, gender = NULL, useGV = FALSE, append = FALSE)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}}}
@@ -17,9 +17,10 @@ solution is \code{\link{GCAsol-class}} or
 \code{\link{SCAsol-class}} the EBV is the GCA if used in 
 the corresponding pool}
 
-\item{useD}{if model is \code{\link{RRDsol-class}}, should 
-dominance be included in the EBV. If yes, the ""EBV"" is an 
-estimate of genetic value and not an estimate of breeding value.}
+\item{useGV}{if model is \code{\link{RRDsol-class}}, 
+setting this parameter to TRUE will give use estimated 
+genetic values. Otherwise, you get estimated breeding 
+values that depend on the population's allele frequency.}
 
 \item{append}{should EBVs be appended to existing EBVs}
 }

---FILE: man/setPheno.Rd---
@@ -4,7 +4,7 @@
 \alias{setPheno}
 \title{Set phenotypes}
 \usage{
-setPheno(pop, varE = NULL, reps = 1, w = 0.5, simParam = NULL)
+setPheno(pop, varE = NULL, reps = 1, p = 0.5, simParam = NULL)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}} or 
@@ -16,7 +16,8 @@ nTraits for correlated errors. If NULL, value in simParam is used.}
 
 \item{reps}{number of replications for phenotype. See details.}
 
-\item{w}{the environmental covariate used by GxE traits.}
+\item{p}{the p-value for the environmental covariate 
+used by GxE traits.}
 
 \item{simParam}{an object of \code{\link{SimParam}}}
 }

---FILE: man/setPhenoGCA.Rd---
@@ -4,7 +4,7 @@
 \alias{setPhenoGCA}
 \title{Set GCA as phenotype}
 \usage{
-setPhenoGCA(pop, testers, use = ""pheno"", varE = NULL, reps = 1, w = 0.5,
+setPhenoGCA(pop, testers, use = ""pheno"", varE = NULL, reps = 1, p = 0.5,
   inbred = FALSE, chunkSize = 10000, onlyPheno = FALSE, simParam = NULL)
 }
 \arguments{
@@ -20,7 +20,7 @@ dimensions nTraits for correlated errors.}
 
 \item{reps}{number of replications for phenotype. See details.}
 
-\item{w}{the environmental covariate used by GxE traits.}
+\item{p}{the p-value for the environmental covariate}
 
 \item{inbred}{are both pop and testers fully inbred. They are only 
 fully inbred if created by \code{\link{newPop}} using inbred founders 

---FILE: man/solveAniModel.Rd---
@@ -0,0 +1,19 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/RcppExports.R
+\name{solveAniModel}
+\alias{solveAniModel}
+\title{Solve animal model}
+\usage{
+solveAniModel(y, X, K)
+}
+\arguments{
+\item{y}{a matrix with n rows and 1 column}
+
+\item{X}{a matrix with n rows and x columns}
+
+\item{K}{the numeric relationship matrix 
+with n rows and n columns}
+}
+\description{
+Solves a univariate mixed model of form \eqn{y=X\beta+u+e}
+}

---FILE: man/trackHaploPop.Rd---
@@ -1,5 +1,5 @@
 % Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/quickPop.R
+% Please edit documentation in R/founderPop.R
 \name{trackHaploPop}
 \alias{trackHaploPop}
 \title{Haplotype tracking population}
@@ -17,16 +17,17 @@ trackHaploPop(genMaps, nInd, inbred = FALSE)
 Creates a population for tracking haplotypes.
 }
 \details{
-The number of chromosomes is determined by the length of genMaps. 
-Each item of genMaps must be a vector of ordered numeric values and 
-the first value must be zero. The length of the vector determines the 
-number of segregating sites on the chromosome.
+Each item of genMaps must be a vector of ordered genetic lengths in 
+Morgans. The first value must be zero. The length of the vector 
+determines the number of segregating sites on the chromosome.
 
 If inbred=FALSE, the value of nInd must be less than or equal to 
 128. Otherwise, it must be less than or equal to 256.
 }
 \examples{
+# Create genetic map for a single chromosome with 1 Morgan
+# Chromosome contains 11 equally spaced segregating sites
 genMaps = list(seq(0,1,length.out=11))
-FOUNDERPOP = trackHaploPop(genMaps=genMaps,nInd=10)
+founderPop = trackHaploPop(genMaps=genMaps,nInd=10)
 
 }

---FILE: src/GEBV.cpp---
@@ -14,6 +14,19 @@ arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop){
   return output;
 }
 
+// Retrieves GEGVs for RRDsol
+// [[Rcpp::export]]
+arma::mat gegvRRD(const Rcpp::S4& RRsol, const Rcpp::S4& pop){
+  arma::mat a = RRsol.slot(""markerEff"");
+  arma::mat d = RRsol.slot(""domEff"");
+  arma::Mat<unsigned char> geno;
+  geno = getGeno(pop.slot(""geno""), 
+                 RRsol.slot(""lociPerChr""),
+                 RRsol.slot(""lociLoc""));
+  arma::mat output = geno*a+getDomGeno(geno)*d;
+  return output;
+}
+
 // Retrieves GEBVs for RRDsol
 // [[Rcpp::export]]
 arma::mat gebvRRD(const Rcpp::S4& RRsol, const Rcpp::S4& pop){
@@ -23,7 +36,8 @@ arma::mat gebvRRD(const Rcpp::S4& RRsol, const Rcpp::S4& pop){
   geno = getGeno(pop.slot(""geno""), 
                  RRsol.slot(""lociPerChr""),
                  RRsol.slot(""lociLoc""));
-  arma::mat output = geno*a+getDomGeno(geno)*d;
+  arma::mat p = arma::mean(arma::conv_to<arma::mat>::from(geno),0)/2;
+  arma::mat output = geno*(a+d%(1-2*p.t()));
   return output;
 }
 

---FILE: src/MME.cpp---
@@ -176,7 +176,6 @@ Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X,
   int q = X.n_cols;
   double df = double(n)-double(q);
   double offset = log(double(n));
-  bool invPass;
 
   // Construct system of equations for eigendecomposition
   arma::mat S = arma::eye(n,n) - X*inv_sympd(X.t()*X)*X.t();
@@ -203,11 +202,7 @@ Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X,
                                  Rcpp::Named(""lambda"")=eigval),
                                  1.0e-10, 1.0e10);
   double delta = optRes[""parameter""];
-  arma::mat Hinv;
-  invPass = inv_sympd(Hinv,ZKZ+delta*arma::eye(n,n));
-  if(!invPass){
-    Hinv = pinv(ZKZ+delta*arma::eye(n,n));
-  }
+  arma::mat Hinv = inv_sympd(ZKZ+delta*arma::eye(n,n));
   arma::mat XHinv = X.t()*Hinv;
   arma::mat beta = solve(XHinv*X,XHinv*y);
   arma::mat u = ZK.t()*(Hinv*(y-X*beta));
@@ -221,6 +216,63 @@ Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X,
                             Rcpp::Named(""LL"")=ll);
 }
 
+//' @title Solve animal model
+//'
+//' @description
+//' Solves a univariate mixed model of form \eqn{y=X\beta+u+e}
+//'
+//' @param y a matrix with n rows and 1 column
+//' @param X a matrix with n rows and x columns
+//' @param K the numeric relationship matrix 
+//' with n rows and n columns
+//'
+//' @export
+// [[Rcpp::export]]
+Rcpp::List solveAniModel(const arma::mat& y,
+                         const arma::mat& X,
+                         const arma::mat& K){
+  int n = y.n_rows;
+  int q = X.n_cols;
+  double df = double(n)-double(q);
+  double offset = log(double(n));
+  
+  // Construct system of equations for eigendecomposition
+  arma::mat S = arma::eye(n,n) - X*inv_sympd(X.t()*X)*X.t();
+  S = S*(K+offset*arma::eye(n,n))*S;
+  
+  // Compute eigendecomposition
+  arma::vec eigval(n);
+  arma::mat eigvec(n,n);
+  eigen2(eigval, eigvec, S);
+  
+  // Drop eigenvalues
+  eigval = eigval(arma::span(q,eigvec.n_cols-1)) - offset;
+  eigvec = eigvec(arma::span(0,eigvec.n_rows-1),
+                  arma::span(q,eigvec.n_cols-1));
+  
+  // Estimate variances and solve equations
+  arma::vec eta = eigvec.t()*y;
+  Rcpp::List optRes = optimize(*objREML,
+                               Rcpp::List::create(
+                                 Rcpp::Named(""df"")=df,
+                                 Rcpp::Named(""eta"")=eta,
+                                 Rcpp::Named(""lambda"")=eigval),
+                                 1.0e-10, 1.0e10);
+  double delta = optRes[""parameter""];
+  arma::mat Hinv = inv_sympd(K+delta*arma::eye(n,n));
+  arma::mat XHinv = X.t()*Hinv;
+  arma::mat beta = solve(XHinv*X,XHinv*y);
+  arma::mat u = K.t()*(Hinv*(y-X*beta));
+  double Vu = sum(eta%eta/(eigval+delta))/df;
+  double Ve = delta*Vu;
+  double ll = -0.5*(double(optRes[""objective""])+df+df*log(2*PI/df));
+  return Rcpp::List::create(Rcpp::Named(""Vu"")=Vu,
+                            Rcpp::Named(""Ve"")=Ve,
+                            Rcpp::Named(""beta"")=beta,
+                            Rcpp::Named(""u"")=u,
+                            Rcpp::Named(""LL"")=ll);
+}
+
 //' @title Solve RR-BLUP
 //'
 //' @description
@@ -238,7 +290,6 @@ Rcpp::List solveRRBLUP(const arma::mat& y, const arma::mat& X,
   int q = X.n_cols;
   double df = double(n)-double(q);
   double offset = log(double(n));
-  bool invPass;
 
   // Construct system of equations for eigendecomposition
   arma::mat S = arma::eye(n,n) - X*inv_sympd(X.t()*X)*X.t();
@@ -263,11 +314,7 @@ Rcpp::List solveRRBLUP(const arma::mat& y, const arma::mat& X,
                                  Rcpp::Named(""lambda"")=eigval),
                                  1.0e-10, 1.0e10);
   double delta = optRes[""parameter""];
-  arma::mat Hinv;
-  invPass = inv_sympd(Hinv,M*M.t()+delta*arma::eye(n,n));
-  if(!invPass){
-    Hinv = pinv(M*M.t()+delta*arma::eye(n,n));
-  }
+  arma::mat Hinv = inv_sympd(M*M.t()+delta*arma::eye(n,n));
   arma::mat XHinv = X.t()*Hinv;
   arma::mat beta = solve(XHinv*X,XHinv*y);
   arma::mat u = M.t()*(Hinv*(y-X*beta));
@@ -319,7 +366,6 @@ Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X,
   double denom;
   double numer;
   bool converging=true;
-  bool invPass;
   int iter=0;
   while(converging){
     ++iter;
@@ -350,13 +396,9 @@ Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X,
       break;
     }
   }
-  arma::mat HI;
-  invPass = inv_sympd(HI,kron(ZKZ, Vu)+kron(arma::eye(n,n), Ve)+
+  arma::mat HI = inv_sympd(kron(ZKZ, Vu)+
+    kron(arma::eye(n,n), Ve)+
     tol*arma::eye(n*m,n*m));
-  if(!invPass){
-    HI = pinv(kron(ZKZ, Vu)+kron(arma::eye(n,n), Ve)+
-      tol*arma::eye(n*m,n*m));
-  }
   arma::mat E = Y.t() - B*X.t();
   arma::mat U = kron(K, Vu)*kron(Z.t(),
                      arma::eye(m,m))*(HI*vectorise(E)); //BLUPs
@@ -411,7 +453,6 @@ Rcpp::List solveRRBLUPMV(const arma::mat& Y, const arma::mat& X,
   double denom;
   double numer;
   bool converging=true;
-  bool invPass;
   int iter=0;
   while(converging){
     ++iter;
@@ -442,13 +483,9 @@ Rcpp::List solveRRBLUPMV(const arma::mat& Y, const arma::mat& X,
       break;
     }
   }
-  arma::mat HI;
-  invPass = inv_sympd(HI,kron(M*M.t(), Vu)+kron(arma::eye(n,n), Ve)+
+  arma::mat HI = inv_sympd(kron(M*M.t(), Vu)+
+    kron(arma::eye(n,n), Ve)+
     tol*arma::eye(n*m,n*m));
-  if(!invPass){
-    HI = pinv(kron(M*M.t(), Vu)+kron(arma::eye(n,n), Ve)+
-      tol*arma::eye(n*m,n*m));
-  }
   arma::mat E = Y.t() - B*X.t();
   arma::mat U = kron(arma::eye(M.n_cols,M.n_cols), Vu)*kron(M.t(),
                      arma::eye(m,m))*(HI*vectorise(E)); //BLUPs
@@ -940,63 +977,12 @@ arma::mat gaussKernel(arma::mat& D, double theta){
   return exp(-1.0*square(D/theta));
 }
 
-// Efficiently solves an animal model with records on all individuals
-Rcpp::List animalModel(const arma::mat& y,
-                       const arma::mat& X,
-                       const arma::mat& K){
-  int n = y.n_rows;
-  int q = X.n_cols;
-  double df = double(n)-double(q);
-  double offset = log(double(n));
-  bool invPass;
-
-  // Construct system of equations for eigendecomposition
-  arma::mat S = arma::eye(n,n) - X*inv_sympd(X.t()*X)*X.t();
-  S = S*(K+offset*arma::eye(n,n))*S;
-
-  // Compute eigendecomposition
-  arma::vec eigval(n);
-  arma::mat eigvec(n,n);
-  eigen2(eigval, eigvec, S);
-
-  // Drop eigenvalues
-  eigval = eigval(arma::span(q,eigvec.n_cols-1)) - offset;
-  eigvec = eigvec(arma::span(0,eigvec.n_rows-1),
-                  arma::span(q,eigvec.n_cols-1));
-
-  // Estimate variances and solve equations
-  arma::vec eta = eigvec.t()*y;
-  Rcpp::List optRes = optimize(*objREML,
-                               Rcpp::List::create(
-                                 Rcpp::Named(""df"")=df,
-                                 Rcpp::Named(""eta"")=eta,
-                                 Rcpp::Named(""lambda"")=eigval),
-                                 1.0e-10, 1.0e10);
-  double delta = optRes[""parameter""];
-  arma::mat Hinv;
-  invPass = inv_sympd(Hinv,K+delta*arma::eye(n,n));
-  if(!invPass){
-    Hinv = pinv(K+delta*arma::eye(n,n));
-  }
-  arma::mat XHinv = X.t()*Hinv;
-  arma::mat beta = solve(XHinv*X,XHinv*y);
-  arma::mat u = K.t()*(Hinv*(y-X*beta));
-  double Vu = sum(eta%eta/(eigval+delta))/df;
-  double Ve = delta*Vu;
-  double ll = -0.5*(double(optRes[""objective""])+df+df*log(2*PI/df));
-  return Rcpp::List::create(Rcpp::Named(""Vu"")=Vu,
-                            Rcpp::Named(""Ve"")=Ve,
-                            Rcpp::Named(""beta"")=beta,
-                            Rcpp::Named(""u"")=u,
-                            Rcpp::Named(""LL"")=ll);
-}
-
 // Objective function for Gaussian kernel method
 Rcpp::List objRKHS(double theta, Rcpp::List args){
   Rcpp::List output;
   arma::mat D = args[""D""];
-  output = animalModel(args[""y""],args[""X""],
-                       gaussKernel(D,theta));
+  output = solveAniModel(args[""y""],args[""X""],
+                         gaussKernel(D,theta));
   return Rcpp::List::create(Rcpp::Named(""objective"")=output[""LL""],
                             Rcpp::Named(""output"")=output);
 }

---FILE: src/RcppExports.cpp---
@@ -50,6 +50,18 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// gegvRRD
+arma::mat gegvRRD(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
+RcppExport SEXP _AlphaSimR_gegvRRD(SEXP RRsolSEXP, SEXP popSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type RRsol(RRsolSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
+    rcpp_result_gen = Rcpp::wrap(gegvRRD(RRsol, pop));
+    return rcpp_result_gen;
+END_RCPP
+}
 // gebvRRD
 arma::mat gebvRRD(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
 RcppExport SEXP _AlphaSimR_gebvRRD(SEXP RRsolSEXP, SEXP popSEXP) {
@@ -309,27 +321,6 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// zero
-int zero();
-RcppExport SEXP _AlphaSimR_zero() {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    rcpp_result_gen = Rcpp::wrap(zero());
-    return rcpp_result_gen;
-END_RCPP
-}
-// changeId
-void changeId(Rcpp::IntegerVector newId, Rcpp::IntegerVector& oldId);
-RcppExport SEXP _AlphaSimR_changeId(SEXP newIdSEXP, SEXP oldIdSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< Rcpp::IntegerVector >::type newId(newIdSEXP);
-    Rcpp::traits::input_parameter< Rcpp::IntegerVector& >::type oldId(oldIdSEXP);
-    changeId(newId, oldId);
-    return R_NilValue;
-END_RCPP
-}
 // calcCoef
 arma::mat calcCoef(arma::mat& X, arma::mat& Y);
 RcppExport SEXP _AlphaSimR_calcCoef(SEXP XSEXP, SEXP YSEXP) {
@@ -372,6 +363,19 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// solveAniModel
+Rcpp::List solveAniModel(const arma::mat& y, const arma::mat& X, const arma::mat& K);
+RcppExport SEXP _AlphaSimR_solveAniModel(SEXP ySEXP, SEXP XSEXP, SEXP KSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveAniModel(y, X, K));
+    return rcpp_result_gen;
+END_RCPP
+}
 // solveRRBLUP
 Rcpp::List solveRRBLUP(const arma::mat& y, const arma::mat& X, const arma::mat& M);
 RcppExport SEXP _AlphaSimR_solveRRBLUP(SEXP ySEXP, SEXP XSEXP, SEXP MSEXP) {

---FILE: src/init.c---
@@ -19,7 +19,6 @@ extern SEXP _AlphaSimR_callRRBLUP_D(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_callRRBLUP_GCA(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_callRRBLUP_MV(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_callRRBLUP_SCA(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
-extern SEXP _AlphaSimR_changeId(SEXP, SEXP);
 extern SEXP _AlphaSimR_convToImat(SEXP);
 extern SEXP _AlphaSimR_createDH2(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_cross2(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
@@ -30,6 +29,7 @@ extern SEXP _AlphaSimR_gebvGCA(SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_gebvRR(SEXP, SEXP);
 extern SEXP _AlphaSimR_gebvRRD(SEXP, SEXP);
 extern SEXP _AlphaSimR_gebvSCA(SEXP, SEXP, SEXP);
+extern SEXP _AlphaSimR_gegvRRD(SEXP, SEXP);
 extern SEXP _AlphaSimR_getDomGeno(SEXP);
 extern SEXP _AlphaSimR_getGeno(SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_getGv(SEXP, SEXP);
@@ -43,6 +43,7 @@ extern SEXP _AlphaSimR_popVar(SEXP);
 extern SEXP _AlphaSimR_readMat(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_sampAllComb(SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_sampHalfDialComb(SEXP, SEXP);
+extern SEXP _AlphaSimR_solveAniModel(SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_solveMKM(SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_solveMVM(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_solveRRBLUP(SEXP, SEXP, SEXP);
@@ -55,7 +56,6 @@ extern SEXP _AlphaSimR_writeASGenotypes(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP
 extern SEXP _AlphaSimR_writeASHaplotypes(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_writeGeno(SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_writeOneHaplo(SEXP, SEXP, SEXP, SEXP, SEXP);
-extern SEXP _AlphaSimR_zero();
 
 static const R_CallMethodDef CallEntries[] = {
     {""_AlphaSimR_calcChrFreq"",       (DL_FUNC) &_AlphaSimR_calcChrFreq,       1},
@@ -69,7 +69,6 @@ static const R_CallMethodDef CallEntries[] = {
     {""_AlphaSimR_callRRBLUP_GCA"",    (DL_FUNC) &_AlphaSimR_callRRBLUP_GCA,    8},
     {""_AlphaSimR_callRRBLUP_MV"",     (DL_FUNC) &_AlphaSimR_callRRBLUP_MV,     7},
     {""_AlphaSimR_callRRBLUP_SCA"",    (DL_FUNC) &_AlphaSimR_callRRBLUP_SCA,    8},
-    {""_AlphaSimR_changeId"",          (DL_FUNC) &_AlphaSimR_changeId,          2},
     {""_AlphaSimR_convToImat"",        (DL_FUNC) &_AlphaSimR_convToImat,        1},
     {""_AlphaSimR_createDH2"",         (DL_FUNC) &_AlphaSimR_createDH2,         6},
     {""_AlphaSimR_cross2"",            (DL_FUNC) &_AlphaSimR_cross2,            7},
@@ -80,6 +79,7 @@ static const R_CallMethodDef CallEntries[] = {
     {""_AlphaSimR_gebvRR"",            (DL_FUNC) &_AlphaSimR_gebvRR,            2},
     {""_AlphaSimR_gebvRRD"",           (DL_FUNC) &_AlphaSimR_gebvRRD,           2},
     {""_AlphaSimR_gebvSCA"",           (DL_FUNC) &_AlphaSimR_gebvSCA,           3},
+    {""_AlphaSimR_gegvRRD"",           (DL_FUNC) &_AlphaSimR_gegvRRD,           2},
     {""_AlphaSimR_getDomGeno"",        (DL_FUNC) &_AlphaSimR_getDomGeno,        1},
     {""_AlphaSimR_getGeno"",           (DL_FUNC) &_AlphaSimR_getGeno,           3},
     {""_AlphaSimR_getGv"",             (DL_FUNC) &_AlphaSimR_getGv,             2},
@@ -93,6 +93,7 @@ static const R_CallMethodDef CallEntries[] = {
     {""_AlphaSimR_readMat"",           (DL_FUNC) &_AlphaSimR_readMat,           6},
     {""_AlphaSimR_sampAllComb"",       (DL_FUNC) &_AlphaSimR_sampAllComb,       3},
     {""_AlphaSimR_sampHalfDialComb"",  (DL_FUNC) &_AlphaSimR_sampHalfDialComb,  2},
+    {""_AlphaSimR_solveAniModel"",     (DL_FUNC) &_AlphaSimR_solveAniModel,     3},
     {""_AlphaSimR_solveMKM"",          (DL_FUNC) &_AlphaSimR_solveMKM,          5},
     {""_AlphaSimR_solveMVM"",          (DL_FUNC) &_AlphaSimR_solveMVM,          6},
     {""_AlphaSimR_solveRRBLUP"",       (DL_FUNC) &_AlphaSimR_solveRRBLUP,       3},
@@ -105,7 +106,6 @@ static const R_CallMethodDef CallEntries[] = {
     {""_AlphaSimR_writeASHaplotypes"", (DL_FUNC) &_AlphaSimR_writeASHaplotypes, 7},
     {""_AlphaSimR_writeGeno"",         (DL_FUNC) &_AlphaSimR_writeGeno,         4},
     {""_AlphaSimR_writeOneHaplo"",     (DL_FUNC) &_AlphaSimR_writeOneHaplo,     5},
-    {""_AlphaSimR_zero"",              (DL_FUNC) &_AlphaSimR_zero,              0},
     {NULL, NULL, 0}
 };
 

---FILE: src/misc.cpp---
@@ -181,20 +181,6 @@ arma::Mat<arma::uword> sampHalfDialComb(arma::uword nLevel, arma::uword n){
   return output;
 }
 
-// Create a value of zero for initial ID
-// Needed to prevent side effects of modify in place
-// [[Rcpp::export]]
-int zero(){
-  return 0;
-}
-
-// Modifies the ID value in place
-// [[Rcpp::export]]
-void changeId(Rcpp::IntegerVector newId,
-              Rcpp::IntegerVector& oldId){
-  oldId[0] = newId[0];
-}
-
 // [[Rcpp::export]]
 arma::mat calcCoef(arma::mat& X, arma::mat& Y){
   return arma::solve(X,Y);

---FILE: src/simulator.cpp---
@@ -898,11 +898,9 @@ vector<AlphaSimRReturn> runFromAlphaSimR(string in) {
   vector<std::string> words;
   Simulator simulator;
   
-  
   if (in == """"){
     Rcpp::stop(""Not enough args for macs call"");
   }
-  
   if (in.empty()) {
     Rcpp::stop(""Not enough args for macs call"");
   }
@@ -922,40 +920,20 @@ vector<AlphaSimRReturn> runFromAlphaSimR(string in) {
       subOption.clear();
     }
   }
-  
   if (arguments.size() == 0) {
     Rcpp::stop(""Not enough args for macs call"");
   }
   
-  
   simulator.readInputParameters(arguments);
   vector<AlphaSimRReturn> test = simulator.beginSimulationMemory();
   return test;
 }
 
-//' @title Markovian Coalescent Simulator
-//' 
-//' @description
-//' Runs a built-in version of the Markovian Coalescent Simulator. 
-//' 
-//' @param args command line arguments passed to MaCS.
-//' @param maxSites maximum number of segregating sites to 
-//' return. If value is 0, all segregating sites are returned. 
-//' Otherwise, segregating sites are randomly sampled.
-//' 
-//' @references
-//' \cite{Chen, G.K., P. Marjoram, and J.D. Wall. 2009. Fast and flexible simulation of DNA sequence data. Genome Res. 19(1): 136142.}
-//' 
-//' @return A list containing a matrix of haplotypes and a 
-//' vector of genetic distances.
-//'
-//' @export
 // [[Rcpp::export]]
 Rcpp::List MaCS(Rcpp::String args, arma::uword maxSites=0){
   
   // Run MaCS
   vector<AlphaSimRReturn> macsOutput;
-  
   string t = args;
   if (t == """") {
     Rcpp::stop(""error"");

---FILE: tests/testthat/test-addTrait.R---
@@ -1,4 +1,4 @@
-context(""SimParam"")
+context(""addTrait"")
 
 test_that(""addTraitA"",{
   genMap = list(c(0))
@@ -8,9 +8,8 @@ test_that(""addTraitA"",{
   pop = newPop(founderPop,simParam=SP)
   expect_equal(abs(SP$traits[[1]]@addEff),1,tolerance=1e-6)
   expect_equal(abs(SP$traits[[1]]@intercept),1,tolerance=1e-6)
-  expect_equal(SP$traits[[1]]@nLoci,1,tolerance=1e-6)
-  expect_equal(SP$traits[[1]]@lociPerChr,1,tolerance=1e-6)
-  expect_equal(SP$traits[[1]]@lociLoc,1,tolerance=1e-6)
+  expect_equal(SP$varA,1,tolerance=1e-6)
+  expect_equal(SP$varG,1,tolerance=1e-6)
   expect_equal(c(varA(pop,simParam=SP)),1,tolerance=1e-6)
   expect_equal(c(varD(pop,simParam=SP)),0,tolerance=1e-6)
   expect_equal(c(varG(pop)),1,tolerance=1e-6)
@@ -28,9 +27,8 @@ test_that(""addTraitAD"",{
   expect_equal(abs(SP$traits[[1]]@addEff),1,tolerance=1e-6)
   expect_equal(SP$traits[[1]]@domEff,1,tolerance=1e-6)
   expect_equal(abs(SP$traits[[1]]@intercept),1,tolerance=1e-6)
-  expect_equal(SP$traits[[1]]@nLoci,1,tolerance=1e-6)
-  expect_equal(SP$traits[[1]]@lociPerChr,1,tolerance=1e-6)
-  expect_equal(SP$traits[[1]]@lociLoc,1,tolerance=1e-6)
+  expect_equal(SP$varA,1,tolerance=1e-6)
+  expect_equal(SP$varG,1,tolerance=1e-6)
   expect_equal(c(varA(pop,simParam=SP)),1,tolerance=1e-6)
   expect_equal(c(varD(pop,simParam=SP)),0,tolerance=1e-6)
   expect_equal(c(varG(pop)),1,tolerance=1e-6)
@@ -50,9 +48,8 @@ test_that(""addTraitAG"",{
   expect_equal(SP$traits[[1]]@envVar,1,tolerance=1e-6)
   expect_equal(abs(SP$traits[[1]]@gxeInt-1),1,tolerance=1e-6)
   expect_equal(abs(SP$traits[[1]]@intercept),1,tolerance=1e-6)
-  expect_equal(SP$traits[[1]]@nLoci,1,tolerance=1e-6)
-  expect_equal(SP$traits[[1]]@lociPerChr,1,tolerance=1e-6)
-  expect_equal(SP$traits[[1]]@lociLoc,1,tolerance=1e-6)
+  expect_equal(SP$varA,1,tolerance=1e-6)
+  expect_equal(SP$varG,1,tolerance=1e-6)
   expect_equal(c(varA(pop,simParam=SP)),1,tolerance=1e-6)
   expect_equal(c(varD(pop,simParam=SP)),0,tolerance=1e-6)
   expect_equal(c(varG(pop)),1,tolerance=1e-6)
@@ -73,9 +70,8 @@ test_that(""addTraitADG"",{
   expect_equal(SP$traits[[1]]@envVar,1,tolerance=1e-6)
   expect_equal(abs(SP$traits[[1]]@gxeInt-1),1,tolerance=1e-6)
   expect_equal(abs(SP$traits[[1]]@intercept),1,tolerance=1e-6)
-  expect_equal(SP$traits[[1]]@nLoci,1,tolerance=1e-6)
-  expect_equal(SP$traits[[1]]@lociPerChr,1,tolerance=1e-6)
-  expect_equal(SP$traits[[1]]@lociLoc,1,tolerance=1e-6)
+  expect_equal(SP$varA,1,tolerance=1e-6)
+  expect_equal(SP$varG,1,tolerance=1e-6)
   expect_equal(c(varA(pop,simParam=SP)),1,tolerance=1e-6)
   expect_equal(c(varD(pop,simParam=SP)),0,tolerance=1e-6)
   expect_equal(c(varG(pop)),1,tolerance=1e-6)

---FILE: tests/testthat/test-crossing.R---
@@ -0,0 +1,138 @@
+context(""crossing"")
+
+test_that(""makeCross"",{
+  genMap = list(c(0))
+  founderPop = trackHaploPop(genMaps=genMap,nInd=2,inbred=TRUE)
+  SP = SimParam$new(founderPop=founderPop)
+  SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
+  SP$setTrackPed(TRUE)
+  pop = newPop(founderPop,simParam=SP)
+  crossPlan = cbind(rep(1,10),rep(2,10))
+  #Match by number
+  pop0 = makeCross(pop=pop,crossPlan=crossPlan,rawPop=TRUE,simParam=SP)
+  expect_equal(SP$lastId,2L)
+  pop1 = makeCross(pop=pop,crossPlan=crossPlan,simParam=SP)
+  expect_equal(SP$lastId,12L)
+  expect_equal(meanG(pop1),0,tolerance=1e-6)
+  expect_equal(SP$pedigree[-(1:2),1L],rep(1L,10L))
+  expect_equal(SP$pedigree[-(1:2),2L],rep(2L,10L))
+  #Match by id
+  crossPlan = matrix(as.character(crossPlan),ncol=2)
+  pop2 = makeCross(pop=pop,crossPlan=crossPlan,simParam=SP)
+  expect_equal(SP$lastId,22L)
+  expect_equal(meanG(pop2),0,tolerance=1e-6)
+  expect_equal(SP$pedigree[-(1:2),1L],rep(1L,20L))
+  expect_equal(SP$pedigree[-(1:2),2L],rep(2L,20L))
+})
+
+test_that(""makeCross2"",{
+  genMap = list(c(0))
+  founderPop = trackHaploPop(genMaps=genMap,nInd=2,inbred=TRUE)
+  SP = SimParam$new(founderPop=founderPop)
+  SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
+  SP$setTrackPed(TRUE)
+  pop = newPop(founderPop,simParam=SP)
+  crossPlan = cbind(rep(1,10),rep(2,10))
+  #Match by number
+  pop0 = makeCross2(females=pop,males=pop,crossPlan=crossPlan,rawPop=TRUE,simParam=SP)
+  expect_equal(SP$lastId,2L)
+  pop1 = makeCross2(females=pop,males=pop,crossPlan=crossPlan,simParam=SP)
+  expect_equal(SP$lastId,12L)
+  expect_equal(meanG(pop1),0,tolerance=1e-6)
+  expect_equal(SP$pedigree[-(1:2),1L],rep(1L,10L))
+  expect_equal(SP$pedigree[-(1:2),2L],rep(2L,10L))
+  #Match by id
+  crossPlan = matrix(as.character(crossPlan),ncol=2)
+  pop2 = makeCross2(females=pop,males=pop,crossPlan=crossPlan,simParam=SP)
+  expect_equal(SP$lastId,22L)
+  expect_equal(meanG(pop2),0,tolerance=1e-6)
+  expect_equal(SP$pedigree[-(1:2),1L],rep(1L,20L))
+  expect_equal(SP$pedigree[-(1:2),2L],rep(2L,20L))
+})
+
+test_that(""randCross"",{
+  genMap = list(c(0))
+  founderPop = trackHaploPop(genMaps=genMap,nInd=2,inbred=TRUE)
+  SP = SimParam$new(founderPop=founderPop)
+  SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
+  SP$setTrackPed(TRUE)
+  SP$setGender(""yes_sys"")
+  pop = newPop(founderPop,simParam=SP)
+  crossPlan = cbind(rep(1,10),rep(2,10))
+  pop0 = randCross(pop=pop,nCrosses=1,nProgeny=10,rawPop=TRUE,simParam=SP)
+  expect_equal(SP$lastId,2L)
+  pop1 = randCross(pop=pop,nCrosses=1,nProgeny=10,simParam=SP)
+  expect_equal(SP$lastId,12L)
+  expect_equal(meanG(pop1),0,tolerance=1e-6)
+  expect_equal(SP$pedigree[-(1:2),1L],rep(2L,10L))
+  expect_equal(SP$pedigree[-(1:2),2L],rep(1L,10L))
+})
+
+test_that(""randCross2"",{
+  genMap = list(c(0))
+  founderPop = trackHaploPop(genMaps=genMap,nInd=2,inbred=TRUE)
+  SP = SimParam$new(founderPop=founderPop)
+  SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
+  SP$setTrackPed(TRUE)
+  SP$setGender(""yes_sys"")
+  pop = newPop(founderPop,simParam=SP)
+  crossPlan = cbind(rep(1,10),rep(2,10))
+  pop0 = randCross2(females=pop,males=pop,nCrosses=1,nProgeny=10,rawPop=TRUE,simParam=SP)
+  expect_equal(SP$lastId,2L)
+  pop1 = randCross2(females=pop,males=pop,nCrosses=1,nProgeny=10,simParam=SP)
+  expect_equal(SP$lastId,12L)
+  expect_equal(meanG(pop1),0,tolerance=1e-6)
+  expect_equal(SP$pedigree[-(1:2),1L],rep(2L,10L))
+  expect_equal(SP$pedigree[-(1:2),2L],rep(1L,10L))
+})
+
+test_that(""self"",{
+  genMap = list(c(0))
+  founderPop = trackHaploPop(genMaps=genMap,nInd=2,inbred=TRUE)
+  SP = SimParam$new(founderPop=founderPop)
+  SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
+  SP$setTrackPed(TRUE)
+  pop = newPop(founderPop,simParam=SP)
+  crossPlan = cbind(rep(1,10),rep(2,10))
+  pop0 = self(pop=pop,nProgeny=1,rawPop=TRUE,simParam=SP)
+  expect_equal(SP$lastId,2L)
+  pop1 = self(pop=pop,nProgeny=1,simParam=SP)
+  expect_equal(SP$lastId,4L)
+  expect_equal(meanG(pop1),0,tolerance=1e-6)
+  expect_equal(SP$pedigree[-(1:2),1L],c(1L,2L))
+  expect_equal(SP$pedigree[-(1:2),2L],c(1L,2L))
+  expect_equal(SP$pedigree[-(1:2),3L],c(0L,0L))
+})
+
+test_that(""makeDH"",{
+  genMap = list(c(0))
+  founderPop = trackHaploPop(genMaps=genMap,nInd=2,inbred=TRUE)
+  SP = SimParam$new(founderPop=founderPop)
+  SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
+  SP$setTrackPed(TRUE)
+  pop = newPop(founderPop,simParam=SP)
+  crossPlan = cbind(rep(1,10),rep(2,10))
+  pop0 = makeDH(pop=pop,nDH=1,rawPop=TRUE,simParam=SP)
+  expect_equal(SP$lastId,2L)
+  pop1 = makeDH(pop=pop,nDH=1,simParam=SP)
+  expect_equal(SP$lastId,4L)
+  expect_equal(meanG(pop1),0,tolerance=1e-6)
+  expect_equal(SP$pedigree[-(1:2),1L],c(1L,2L))
+  expect_equal(SP$pedigree[-(1:2),2L],c(1L,2L))
+  expect_equal(SP$pedigree[-(1:2),3L],c(1L,1L))
+})
+
+test_that(""selectCross"",{
+  genMap = list(c(0))
+  founderPop = trackHaploPop(genMaps=genMap,nInd=2,inbred=TRUE)
+  SP = SimParam$new(founderPop=founderPop)
+  SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
+  SP$setTrackPed(TRUE)
+  SP$setGender(""yes_sys"")
+  pop = newPop(founderPop,simParam=SP)
+  pop1 = selectCross(pop=pop,nFemale=1,nMale=1,use=""rand"",nCrosses=2,simParam=SP)
+  expect_equal(SP$lastId,4L)
+  expect_equal(meanG(pop1),0,tolerance=1e-6)
+  expect_equal(SP$pedigree[-(1:2),1L],c(2L,2L))
+  expect_equal(SP$pedigree[-(1:2),2L],c(1L,1L))
+})
\ No newline at end of file

---FILE: tests/testthat/test-editGenome.R---
@@ -0,0 +1,14 @@
+context(""editGenome"")
+
+test_that(""editGenome"",{
+  genMap = list(c(0))
+  founderPop = trackHaploPop(genMaps=genMap,nInd=2,inbred=TRUE)
+  SP = SimParam$new(founderPop=founderPop)
+  SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
+  pop = newPop(founderPop,simParam=SP)
+  pop = editGenome(pop=pop,ind=1,chr=1,segSites=1,allele=1,
+                   simParam=SP)
+  expect_equal(c(varG(pop)),0,tolerance=1e-6)
+  pop = randCross(pop=pop,nCrosses=10,simParam=SP)
+  expect_equal(c(varG(pop)),0,tolerance=1e-6)
+})
\ No newline at end of file

---FILE: tests/testthat/test-statistics.R---
@@ -0,0 +1,68 @@
+# These tests will fail with a small probability and/or 
+# they are slower tests, so they are skipped on CRAN.
+# If any of these test fail, rerun the tests multiple times.
+# Frequent failures indicate a problem.
+context(""statistics"")
+
+test_that(""addError"",{
+  skip_on_cran()
+  gv = matrix(0,nrow=10000,ncol=2)
+  varE = c(1,1)
+  pheno = AlphaSimR:::addError(gv=gv,varE=varE,reps=1)
+  expect_equal(var(pheno),diag(varE),tol=0.1)
+  varE = diag(2)
+  pheno = AlphaSimR:::addError(gv=gv,varE=varE,reps=1)
+  expect_equal(var(pheno),varE,tol=0.1)
+  pheno = AlphaSimR:::addError(gv=gv,varE=varE,reps=4)
+  expect_equal(var(pheno),varE/4,tol=0.1)
+  varE = 0.5*diag(2)+0.5
+  pheno = AlphaSimR:::addError(gv=gv,varE=varE,reps=1)
+  expect_equal(var(pheno),varE,tol=0.1)
+  pheno = AlphaSimR:::addError(gv=gv,varE=varE,reps=4)
+  expect_equal(var(pheno),varE/4,tol=0.1)
+  varE = 1.5*diag(2)-0.5
+  pheno = AlphaSimR:::addError(gv=gv,varE=varE,reps=1)
+  expect_equal(var(pheno),varE,tol=0.1)
+  pheno = AlphaSimR:::addError(gv=gv,varE=varE,reps=4)
+  expect_equal(var(pheno),varE/4,tol=0.1)
+  varE = matrix(c(1,0.5,-0.5,1),ncol=2)
+  expect_error(AlphaSimR:::addError(gv=gv,varE=varE,reps=1))
+})
+
+# test_that(""Univariate GS"",{
+#   # All mixed model solvers should give nearly the 
+#   # same prediction
+#   skip_on_cran()
+#   founderPop = runMacs(nInd=10,nChr=10,segSites=100)
+#   SP = SimParam$new(founderPop)
+#   SP$addTraitA(100,0,1)
+#   SP$setVarE(varE=10)
+#   pop = newPop(founderPop,simParam=SP)
+#   pop = randCross(pop,1000,simParam=SP)
+#   y = pop@pheno
+#   X = matrix(1,nrow=pop@nInd)
+#   Z = diag(pop@nInd)
+#   M = pullQtlGeno(pop,simParam=SP)
+#   G = calcG(M)
+#   M = scale(M,scale=FALSE)
+#   # GBLUP models
+#   ansAni = solveAniModel(y,X,G)
+#   ansAni = c(ansAni$u)
+#   ansAniUVM = solveUVM(y,X,Z,G)
+#   ansAniUVM = c(ansAniUVM$u)
+#   ansAniMVM = solveMVM(y,X,Z,G)
+#   ansAniMVM = c(ansAniMVM$u)
+#   
+#   
+#   ansAniMKM = solveMKM(y,X,list(Z),list(G))
+#   ansAniMKM = c(ansAniMKM$u[[1]])
+#   
+#   # RR-BLUP models
+#   ansRR = solveRRBLUP(y,X,M)
+#   
+#   ansRRUVM = solveUVM(y,X,Z,G)
+#   ansRRMKM = solveMKM(y,X,list(Z),list(G))
+#   
+#   expect_equal(ansUVM$u,ansAni$u,tol=1e-4)
+#   expect_equal(c(ansUVM$u),c(u),tol=1e-4)
+# })

---FILE: vignettes/Introduction.Rmd---
@@ -10,46 +10,37 @@ vignette: >
   %\VignetteEncoding{UTF-8}
 ---
 
-
-The AlphaSimR package provides a framework for simulating plant and animal breeding programs in R. It is based on the AlphaSim program [@AlphaSim]. This document will introduce the basic steps for running a simulation in AlphaSimR.
+This vignette provides a brief introduction to the AlphaSimR package. The AlphaSimR package was designed to provide all the tools necessary for simulating complex plant and animal breeding programs in R. It is also the successor to the AlphaSim program [@AlphaSim]. 
 
 The basic steps of an AlphaSimR simulation are:
 
-1. Create founder haplotypes using `runMacs`
-
-2. Set simulation parameters using `createSimulation`
-
-3. Add traits using `addTraitA` or any other addTrait function
+1. Create Founder Haplotypes
 
-4. Add SNP chips using `addSnpChip` (optional)
+2. Set Simulation Parameters
 
-5. Create one or more initial populations using `newPop`
+3. Create an Initial Population(s)
 
-6. Perform a mix of crossing and selection to simulate a breeding program
+4. Simulate a Breeding Program
 
-# Creating Founder Haplotypes
+# Create Founder Haplotypes
 
 The first step in an AlphaSimR simulation is to create a set of founder haplotypes. To do this, run the function `runMacs`. The `runMacs` function uses a built in version of the MaCS program [@MaCS]. The `runMacs` function allows for simulation of haplotypes using several predefined species histories or can be used to create a custom population using MaCS command line arguments. 
 
-# Setting Simulation Parameters
-
-Parameters for a simulation are stored in an object of `SimParam-class`. The function `createSimulation` creates this object. The `SimParam-class` is a container for global parameters that will be used by many functions in AlphaSimR. To avoid specifying a `SimParam-class` in all functions that use one, it is recommended that you give your `SimParam-class` the name `SIMPARAM`. All functions that take a `SimParam-class` as an arguement will search your global environment for an object called `SIMPARAM` if the argument is `NULL`.
-
-# Adding Traits
+# Set Simulation Parameters
 
-Traits are added to the simulation using one of the fullowing functions: `addTraitA`, `addTraitAD`, `addTraitAG`, or `addTraitADG`. These functions can be called multiple times to run simulations with multiple traits. These functions can also be used to simulate correlated pleiotropic traits. Simulations without any traits are possible as long as you don't use a selection function.
+Parameters for a simulation are stored in an object of `SimParam-class`. The function `createSimulation` creates this object. The `SimParam-class` is a container for global parameters that will be used by many functions in AlphaSimR. To avoid specifying a `SimParam-class` in all functions that use one, it is recommended that you give your `SimParam-class` the name `SIMPARAM`. All functions that take a `SimParam-class` as an argument will search your global environment for an object called `SIMPARAM` if the argument is `NULL`.
 
-# Adding SNP Chips
+Traits are added to the simulation using one of the following functions: `addTraitA`, `addTraitAD`, `addTraitAG`, or `addTraitADG`. These functions can be called multiple times to run simulations with multiple traits. These functions can also be used to simulate correlated pleiotropic traits. Simulations without any traits are possible as long as you don't use a selection function.
 
 SNP chips are added to the simulation using the `addSnpChip` or `addStructuredSnpChips` functions. As with traits, these functions can be called multiple times to assign multiple SNP chips. SNP chips are not necessary for a simulation, so this step can be skipped.
 
-# Creating a Population
+# Create an Initial Population(s)
 
 The main objects in an AlphaSimR simulation are `Pop-class` objects. These objects represent a population that contains one or more individuals. Many AlphaSimR functions use a `Pop-class` object as an argument and return a `Pop-class` object as a result.
 
 To create your first `Pop-class` object use the function `newPop`. This function should only be called after you have finished all of the above steps.
 
-# Working with Populations
+# Simulate a Breeding Program
 
 Listed below are some functions for carrying out operations on populations.
 "
gaynorr,AlphaSimR,25c3295f6e7d2cfe39b740fb2c352faf65d1352b,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-12-22T17:17:45Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-12-22T17:17:45Z,"bug fixes
unit tests for addTrait functions",DESCRIPTION;R/Class-Pop.R;R/Class-SimParam.R;R/phenotypes.R;man/calcPheno.Rd;man/setPheno.Rd;tests/testthat/test-RecombTracking.R;tests/testthat/test-SimParm.R,False,True,True,False,112,22,134,"---FILE: DESCRIPTION---
@@ -15,3 +15,4 @@ LinkingTo: Rcpp, RcppArmadillo, BH
 RoxygenNote: 6.0.1
 Suggests: knitr, rmarkdown, testthat
 VignetteBuilder: knitr
+NeedsCompilation: true

---FILE: R/Class-Pop.R---
@@ -388,6 +388,11 @@ newPop = function(rawPop,mother=NULL,father=NULL,origM=NULL,
       }
     }
   }
+  if(simParam$nTraits>0){
+    pheno = addError(gv,simParam$varE)
+  }else{
+    pheno = gv
+  }
   if(is.null(origM)) origM = mother
   if(is.null(origF)) origF = father
   output = new(""Pop"",
@@ -403,7 +408,7 @@ newPop = function(rawPop,mother=NULL,father=NULL,origM=NULL,
                nTraits=simParam$nTraits,
                gv=gv,
                gxe=gxe,
-               pheno=addError(gv,simParam$varE),
+               pheno=pheno,
                ebv=matrix(NA_real_,
                           nrow=rawPop@nInd,
                           ncol=0))

---FILE: R/Class-SimParam.R---
@@ -411,22 +411,22 @@ SimParam$set(
     potQtl = list()
     for(chr in 1:private$.nChr){
       if(snpQtlOverlap){
-        stopifnot(private$.nLoci[chr]>=maxSnp[chr],
-                  private$.nLoci[chr]>=maxQtl[chr])
+        stopifnot(private$.segSites[chr]>=maxSnp[chr],
+                  private$.segSites[chr]>=maxQtl[chr])
         if(is.null(minSnpFreq)){
-          potSnp[[chr]] = sort(sample.int(private$.nLoci[chr],
+          potSnp[[chr]] = sort(sample.int(private$.segSites[chr],
                                           maxSnp[chr]))
         }else{
           q = calcChrFreq(private$.founderPop@geno[[chr]])
           q = 0.5-abs(q-0.5) #Convert to minor allele frequency
           potSnp[[chr]] = sort(sample(which(q>=minSnpFreq),maxSnp[chr]))
         }
-        potQtl[[chr]] = sort(sample.int(private$.nLoci[chr],
+        potQtl[[chr]] = sort(sample.int(private$.segSites[chr],
                                         maxQtl[chr]))
       }else{
-        stopifnot(private$.nLoci[chr]>=sum(maxSnp[chr],maxQtl[chr]))
+        stopifnot(private$.segSites[chr]>=sum(maxSnp[chr],maxQtl[chr]))
         if(is.null(minSnpFreq)){
-          tmp = sample.int(private$.nLoci[chr],sum(maxSnp[chr],maxQtl[chr]))
+          tmp = sample.int(private$.segSites[chr],sum(maxSnp[chr],maxQtl[chr]))
           if(maxSnp[chr]>0){
             potSnp[[chr]] = sort(tmp[1:maxSnp[chr]])
           }else{
@@ -441,7 +441,7 @@ SimParam$set(
           q = calcChrFreq(private$.founderPop@geno[[chr]])
           q = 0.5-abs(q-0.5)
           potSnp[[chr]] = sort(sample(which(q>=minSnpFreq),maxSnp[chr]))
-          potQtl[[chr]] = sort(sample(which(!((1:private$.nLoci[chr])%in%potSnp[[chr]])),
+          potQtl[[chr]] = sort(sample(which(!((1:private$.segSites[chr])%in%potSnp[[chr]])),
                                       maxQtl[chr]))
         }
       }
@@ -856,9 +856,10 @@ SimParam$set(
     if(length(gamma)==1) gamma = rep(gamma,nTraits)
     if(length(shape)==1) shape = rep(shape,nTraits)
     if(is.null(corA)) corA=diag(nTraits)
-    if(is.null(corD)) corDD=diag(nTraits)
+    if(is.null(corDD)) corDD=diag(nTraits)
     stopifnot(length(mean)==length(var),
               isSymmetric(corA),
+              isSymmetric(corDD),
               length(mean)==nrow(corA))
     qtlLoci = private$.pickQtlLoci(nQtlPerChr)
     addEff = sampAddEff(qtlLoci=qtlLoci,nTraits=nTraits,

---FILE: R/phenotypes.R---
@@ -41,7 +41,7 @@ addError = function(gv,varE,reps=1){
 #' \code{\link{HybridPop-class}}
 #' @param varE error variances for phenotype. A vector of length 
 #' nTraits for independent error or a square matrix of dimensions 
-#' nTraits for correlated errors.
+#' nTraits for correlated errors. If NULL, value in simParam is used.
 #' @param reps number of replications for phenotype. See details.
 #' @param w the environmental covariate used by GxE traits.
 #' @param simParam an object of \code{\link{SimParam}}
@@ -56,7 +56,7 @@ addError = function(gv,varE,reps=1){
 #' @return Returns a matrix of nInd by nTrait phenotypes
 #' 
 #' @export
-calcPheno = function(pop,varE,reps=1,w=0.5,
+calcPheno = function(pop,varE=NULL,reps=1,w=0.5,
                      simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
@@ -67,6 +67,9 @@ calcPheno = function(pop,varE,reps=1,w=0.5,
   }
   stopifnot(length(w)==simParam$nTraits)
   gv = pop@gv
+  if(is.null(varE)){
+    varE = simParam$varE
+  }
   for(i in 1:simParam$nTraits){
     traitClass = class(simParam$traits[[i]])
     if(traitClass==""TraitAG"" | traitClass==""TraitADG""){
@@ -88,7 +91,7 @@ calcPheno = function(pop,varE,reps=1,w=0.5,
 #' \code{\link{HybridPop-class}}
 #' @param varE error variances for phenotype. A vector of length 
 #' nTraits for independent error or a square matrix of dimensions 
-#' nTraits for correlated errors.
+#' nTraits for correlated errors. If NULL, value in simParam is used.
 #' @param reps number of replications for phenotype. See details.
 #' @param w the environmental covariate used by GxE traits.
 #' @param simParam an object of \code{\link{SimParam}}
@@ -104,7 +107,7 @@ calcPheno = function(pop,varE,reps=1,w=0.5,
 #' \code{\link{HybridPop-class}}
 #' 
 #' @export
-setPheno = function(pop,varE,reps=1,w=0.5,simParam=NULL){
+setPheno = function(pop,varE=NULL,reps=1,w=0.5,simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SP"",envir=.GlobalEnv)
   }

---FILE: man/calcPheno.Rd---
@@ -4,15 +4,15 @@
 \alias{calcPheno}
 \title{Calculate phenotypes}
 \usage{
-calcPheno(pop, varE, reps = 1, w = 0.5, simParam = NULL)
+calcPheno(pop, varE = NULL, reps = 1, w = 0.5, simParam = NULL)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}} or 
 \code{\link{HybridPop-class}}}
 
 \item{varE}{error variances for phenotype. A vector of length 
 nTraits for independent error or a square matrix of dimensions 
-nTraits for correlated errors.}
+nTraits for correlated errors. If NULL, value in simParam is used.}
 
 \item{reps}{number of replications for phenotype. See details.}
 

---FILE: man/setPheno.Rd---
@@ -4,15 +4,15 @@
 \alias{setPheno}
 \title{Set phenotypes}
 \usage{
-setPheno(pop, varE, reps = 1, w = 0.5, simParam = NULL)
+setPheno(pop, varE = NULL, reps = 1, w = 0.5, simParam = NULL)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}} or 
 \code{\link{HybridPop-class}}}
 
 \item{varE}{error variances for phenotype. A vector of length 
 nTraits for independent error or a square matrix of dimensions 
-nTraits for correlated errors.}
+nTraits for correlated errors. If NULL, value in simParam is used.}
 
 \item{reps}{number of replications for phenotype. See details.}
 

---FILE: tests/testthat/test-RecombTracking.R---
@@ -1,5 +0,0 @@
-context(""Rec. Track"")
-
-test_that(""number of recombination should match"",{
-  
-})
\ No newline at end of file

---FILE: tests/testthat/test-SimParm.R---
@@ -0,0 +1,85 @@
+context(""SimParam"")
+
+test_that(""addTraitA"",{
+  genMap = list(c(0))
+  founderPop = trackHaploPop(genMaps=genMap,nInd=2,inbred=TRUE)
+  SP = SimParam$new(founderPop=founderPop)
+  SP$addTraitA(nQtlPerChr=1,mean=0,var=1)
+  pop = newPop(founderPop,simParam=SP)
+  expect_equal(abs(SP$traits[[1]]@addEff),1,tolerance=1e-6)
+  expect_equal(abs(SP$traits[[1]]@intercept),1,tolerance=1e-6)
+  expect_equal(SP$traits[[1]]@nLoci,1,tolerance=1e-6)
+  expect_equal(SP$traits[[1]]@lociPerChr,1,tolerance=1e-6)
+  expect_equal(SP$traits[[1]]@lociLoc,1,tolerance=1e-6)
+  expect_equal(c(varA(pop,simParam=SP)),1,tolerance=1e-6)
+  expect_equal(c(varD(pop,simParam=SP)),0,tolerance=1e-6)
+  expect_equal(c(varG(pop)),1,tolerance=1e-6)
+  expect_equal(genicVarA(pop,simParam=SP),0.5,tolerance=1e-6)
+  expect_equal(genicVarD(pop,simParam=SP),0,tolerance=1e-6)
+  expect_equal(genicVarG(pop,simParam=SP),0.5,tolerance=1e-6)
+})
+
+test_that(""addTraitAD"",{
+  genMap = list(c(0))
+  founderPop = trackHaploPop(genMaps=genMap,nInd=2,inbred=TRUE)
+  SP = SimParam$new(founderPop=founderPop)
+  SP$addTraitAD(nQtlPerChr=1,mean=0,var=1,meanDD=1)
+  pop = newPop(founderPop,simParam=SP)
+  expect_equal(abs(SP$traits[[1]]@addEff),1,tolerance=1e-6)
+  expect_equal(SP$traits[[1]]@domEff,1,tolerance=1e-6)
+  expect_equal(abs(SP$traits[[1]]@intercept),1,tolerance=1e-6)
+  expect_equal(SP$traits[[1]]@nLoci,1,tolerance=1e-6)
+  expect_equal(SP$traits[[1]]@lociPerChr,1,tolerance=1e-6)
+  expect_equal(SP$traits[[1]]@lociLoc,1,tolerance=1e-6)
+  expect_equal(c(varA(pop,simParam=SP)),1,tolerance=1e-6)
+  expect_equal(c(varD(pop,simParam=SP)),0,tolerance=1e-6)
+  expect_equal(c(varG(pop)),1,tolerance=1e-6)
+  expect_equal(genicVarA(pop,simParam=SP),0.5,tolerance=1e-6)
+  expect_equal(genicVarD(pop,simParam=SP),0.25,tolerance=1e-6)
+  expect_equal(genicVarG(pop,simParam=SP),0.75,tolerance=1e-6)
+})
+
+test_that(""addTraitAG"",{
+  genMap = list(c(0))
+  founderPop = trackHaploPop(genMaps=genMap,nInd=2,inbred=TRUE)
+  SP = SimParam$new(founderPop=founderPop)
+  SP$addTraitAG(nQtlPerChr=1,mean=0,var=1,varEnv=1,varGxE=1)
+  pop = newPop(founderPop,simParam=SP)
+  expect_equal(abs(SP$traits[[1]]@addEff),1,tolerance=1e-6)
+  expect_equal(abs(SP$traits[[1]]@gxeEff),1,tolerance=1e-6)
+  expect_equal(SP$traits[[1]]@envVar,1,tolerance=1e-6)
+  expect_equal(abs(SP$traits[[1]]@gxeInt-1),1,tolerance=1e-6)
+  expect_equal(abs(SP$traits[[1]]@intercept),1,tolerance=1e-6)
+  expect_equal(SP$traits[[1]]@nLoci,1,tolerance=1e-6)
+  expect_equal(SP$traits[[1]]@lociPerChr,1,tolerance=1e-6)
+  expect_equal(SP$traits[[1]]@lociLoc,1,tolerance=1e-6)
+  expect_equal(c(varA(pop,simParam=SP)),1,tolerance=1e-6)
+  expect_equal(c(varD(pop,simParam=SP)),0,tolerance=1e-6)
+  expect_equal(c(varG(pop)),1,tolerance=1e-6)
+  expect_equal(genicVarA(pop,simParam=SP),0.5,tolerance=1e-6)
+  expect_equal(genicVarD(pop,simParam=SP),0,tolerance=1e-6)
+  expect_equal(genicVarG(pop,simParam=SP),0.5,tolerance=1e-6)
+})
+
+test_that(""addTraitADG"",{
+  genMap = list(c(0))
+  founderPop = trackHaploPop(genMaps=genMap,nInd=2,inbred=TRUE)
+  SP = SimParam$new(founderPop=founderPop)
+  SP$addTraitADG(nQtlPerChr=1,mean=0,var=1,meanDD=1,varEnv=1,varGxE=1)
+  pop = newPop(founderPop,simParam=SP)
+  expect_equal(abs(SP$traits[[1]]@addEff),1,tolerance=1e-6)
+  expect_equal(SP$traits[[1]]@domEff,1,tolerance=1e-6)
+  expect_equal(abs(SP$traits[[1]]@gxeEff),1,tolerance=1e-6)
+  expect_equal(SP$traits[[1]]@envVar,1,tolerance=1e-6)
+  expect_equal(abs(SP$traits[[1]]@gxeInt-1),1,tolerance=1e-6)
+  expect_equal(abs(SP$traits[[1]]@intercept),1,tolerance=1e-6)
+  expect_equal(SP$traits[[1]]@nLoci,1,tolerance=1e-6)
+  expect_equal(SP$traits[[1]]@lociPerChr,1,tolerance=1e-6)
+  expect_equal(SP$traits[[1]]@lociLoc,1,tolerance=1e-6)
+  expect_equal(c(varA(pop,simParam=SP)),1,tolerance=1e-6)
+  expect_equal(c(varD(pop,simParam=SP)),0,tolerance=1e-6)
+  expect_equal(c(varG(pop)),1,tolerance=1e-6)
+  expect_equal(genicVarA(pop,simParam=SP),0.5,tolerance=1e-6)
+  expect_equal(genicVarD(pop,simParam=SP),0.25,tolerance=1e-6)
+  expect_equal(genicVarG(pop,simParam=SP),0.75,tolerance=1e-6)
+})
\ No newline at end of file"
gaynorr,AlphaSimR,8b29d1eb097413feb8d470fb9d0f4ab1ee365131,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-12-15T11:22:21Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-12-15T11:22:21Z,Fixed bug in gender specific recombination calculation.,R/RcppExports.R;R/crossing.R;inst/doc/BasicAnimal.Rmd;inst/doc/BasicAnimal.pdf;inst/doc/GenomicSelection.R;inst/doc/GenomicSelection.Rmd;inst/doc/GenomicSelection.pdf;inst/doc/Introduction.pdf;inst/doc/Maize.R;inst/doc/Maize.Rmd;inst/doc/Maize.pdf;inst/doc/Wheat.R;inst/doc/Wheat.Rmd;inst/doc/Wheat.pdf;inst/doc/basicAnimal.R;src/RcppExports.cpp;src/init.c;src/meiosis.cpp;vignettes/BasicAnimal.Rmd;vignettes/GenomicSelection.Rmd;vignettes/Maize.Rmd;vignettes/Wheat.Rmd,True,True,True,False,25,283,308,"---FILE: R/RcppExports.R---
@@ -69,8 +69,8 @@ createDH2 <- function(geno, nDH, genMaps, recombRatio, useFemale) {
     .Call(`_AlphaSimR_createDH2`, geno, nDH, genMaps, recombRatio, useFemale)
 }
 
-crossPedigree <- function(founders, mother, father, genMaps) {
-    .Call(`_AlphaSimR_crossPedigree`, founders, mother, father, genMaps)
+crossPedigree <- function(founders, mother, father, genMaps, recombRatio) {
+    .Call(`_AlphaSimR_crossPedigree`, founders, mother, father, genMaps, recombRatio)
 }
 
 #' @title Population variance

---FILE: R/crossing.R---
@@ -371,7 +371,8 @@ pedigreeCross = function(pedigree,founders,id=NULL,
                geno=crossPedigree(founders@geno,
                                   sortedped@mother,
                                   sortedped@father,
-                                  simParam@genMaps))
+                                  simParam@genMaps,
+                                  simParam@recombRatio))
   return(newPop(rawPop=rawPop,id=id,
                 mother=as.character(sortedped@mother),
                 father=as.character(sortedped@father),

---FILE: inst/doc/BasicAnimal.Rmd---
@@ -1,46 +0,0 @@
----
-title: ""Basic Animal Simulation""
-author: ""Chris Gaynor""
-date: ""`r Sys.Date()`""
-output: pdf_document
-bibliography: bibliography.bib
-vignette: >
-  %\VignetteIndexEntry{Basic Animal}
-  %\VignetteEngine{knitr::rmarkdown}
-  %\VignetteEncoding{UTF-8}
----
-
-This document provides
-
-[-@Jenko15]
-
-```r
-# Basic animal breeding simulation
-# Based on ""historical breeding"" portion of Jenko et al., 2015
-# https://gsejournal.biomedcentral.com/articles/10.1186/s12711-015-0135-3
-library(AlphaSimR)
-# Generate initial haplotypes
-FOUNDERPOP = runMacs(nInd=1000,nChr=10,segSites=1000,
-                     inbred=FALSE,species=""TEST"") #Using TEST instead of CATTLE for speed
-
-# Set simulation parameters
-SIMPARAM = createSimulation(FOUNDERPOP,maxQtl=1000,maxSnp=0,gender=""yes_sys"")
-# Add a trait with additive effects
-SIMPARAM = addTraitA(FOUNDERPOP,nQtlPerChr=1000,meanG=0,varG=1)
-
-calves = newPop(FOUNDERPOP)
-popMean = meanG(calves)
-popVar = varG(calves)
-for(i in 1:20){
-  bulls = selectMale(calves,25,use=""gv"")
-  cows = selectFemale(calves,500,use=""gv"")
-  calves = randCross2(cows,bulls,nCrosses=1000)
-  popMean = c(popMean,meanG(calves))
-  popVar = c(popVar,varG(bulls))
-}
-plot(0:20,popMean,type=""l"",xlab=""Generation"",ylab=""GV"",main=""Genetic Gain"")
-plot(0:20,popVar,type=""l"",xlab=""Generation"",ylab=""GV"",main=""Genetic Variance"")
-```
-
-# References
-

---FILE: inst/doc/GenomicSelection.R---
@@ -1 +0,0 @@
-

---FILE: inst/doc/GenomicSelection.Rmd---
@@ -1,42 +0,0 @@
----
-title: ""Genomic Selection""
-author: ""Chris Gaynor""
-date: ""`r Sys.Date()`""
-output: pdf_document
-bibliography: bibliography.bib
-vignette: >
-  %\VignetteIndexEntry{Genomic Selection}
-  %\VignetteEngine{knitr::rmarkdown}
-  %\VignetteEncoding{UTF-8}
----
-
-[@Massman13]
-[@sommer]
-[@EMMREML]
-
-```r
-library(AlphaSimR)
-FOUNDERPOP = runMacs(nInd=100,nChr=10,segSites=1200,
-                     inbred=FALSE,species=""TEST"")
-SIMPARAM = createSimulation(FOUNDERPOP,maxQtl=200,maxSnp=1000,gender=""yes_sys"")
-SIMPARAM = addTraitA(FOUNDERPOP,nQtlPerChr=100,meanG=0,varG=1)
-SIMPARAM = addSnpChip(1000)
-pop = newPop(FOUNDERPOP)
-unlink(""GS"",recursive=TRUE)
-dir.create(""GS"")
-writeRecords(pop,""GS"",1)
-for(gen in 1:9){
-  pop = randCross(pop,100)
-  writeRecords(pop,""GS"",1)
-}
-#Predict
-pop = randCross(pop,100)
-gsModel = RRBLUP(""GS"",1,use=""GV"")
-pop = setEBV(pop,gsModel)
-cor(pop@gv[,1],pop@ebv[,1])
-#Select on EBV
-best = selectInd(pop,10,use=""ebv"")
-meanG(best)-meanG(pop)
-```
-
-# References
\ No newline at end of file

---FILE: inst/doc/Maize.R---
@@ -1 +0,0 @@
-

---FILE: inst/doc/Maize.Rmd---
@@ -1,22 +0,0 @@
----
-title: ""Maize Breeding Simulation""
-author: ""Chris Gaynor""
-date: ""`r Sys.Date()`""
-output: pdf_document
-bibliography: bibliography.bib
-vignette: >
-  %\VignetteIndexEntry{Maize}
-  %\VignetteEngine{knitr::rmarkdown}
-  %\VignetteEncoding{UTF-8}
----
-
-This document provides
-
-[@Troyer09]
-[@BernardoBook]
-
-```r
-
-```
-
-# References

---FILE: inst/doc/Wheat.R---
@@ -1 +0,0 @@
-

---FILE: inst/doc/Wheat.Rmd---
@@ -1,21 +0,0 @@
----
-title: ""Wheat Breeding Simulation""
-author: ""Chris Gaynor""
-date: ""`r Sys.Date()`""
-output: pdf_document
-bibliography: bibliography.bib
-vignette: >
-  %\VignetteIndexEntry{Wheat}
-  %\VignetteEngine{knitr::rmarkdown}
-  %\VignetteEncoding{UTF-8}
----
-
-This document provides
-
-[-@Gaynor17]
-
-```r
-
-```
-
-# References

---FILE: inst/doc/basicAnimal.R---
@@ -1 +0,0 @@
-

---FILE: src/RcppExports.cpp---
@@ -238,16 +238,17 @@ BEGIN_RCPP
 END_RCPP
 }
 // crossPedigree
-arma::field<arma::Cube<unsigned char> > crossPedigree(const arma::field<arma::Cube<unsigned char> >& founders, arma::uvec mother, arma::uvec father, const arma::field<arma::vec>& genMaps);
-RcppExport SEXP _AlphaSimR_crossPedigree(SEXP foundersSEXP, SEXP motherSEXP, SEXP fatherSEXP, SEXP genMapsSEXP) {
+arma::field<arma::Cube<unsigned char> > crossPedigree(const arma::field<arma::Cube<unsigned char> >& founders, arma::uvec mother, arma::uvec father, const arma::field<arma::vec>& genMaps, double recombRatio);
+RcppExport SEXP _AlphaSimR_crossPedigree(SEXP foundersSEXP, SEXP motherSEXP, SEXP fatherSEXP, SEXP genMapsSEXP, SEXP recombRatioSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
     Rcpp::traits::input_parameter< const arma::field<arma::Cube<unsigned char> >& >::type founders(foundersSEXP);
     Rcpp::traits::input_parameter< arma::uvec >::type mother(motherSEXP);
     Rcpp::traits::input_parameter< arma::uvec >::type father(fatherSEXP);
     Rcpp::traits::input_parameter< const arma::field<arma::vec>& >::type genMaps(genMapsSEXP);
-    rcpp_result_gen = Rcpp::wrap(crossPedigree(founders, mother, father, genMaps));
+    Rcpp::traits::input_parameter< double >::type recombRatio(recombRatioSEXP);
+    rcpp_result_gen = Rcpp::wrap(crossPedigree(founders, mother, father, genMaps, recombRatio));
     return rcpp_result_gen;
 END_RCPP
 }

---FILE: src/init.c---
@@ -22,7 +22,7 @@ extern SEXP _AlphaSimR_changeId(SEXP, SEXP);
 extern SEXP _AlphaSimR_convToImat(SEXP);
 extern SEXP _AlphaSimR_createDH2(SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_cross2(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
-extern SEXP _AlphaSimR_crossPedigree(SEXP, SEXP, SEXP, SEXP);
+extern SEXP _AlphaSimR_crossPedigree(SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_fastDist(SEXP);
 extern SEXP _AlphaSimR_fastPairDist(SEXP, SEXP);
 extern SEXP _AlphaSimR_gaussKernel(SEXP, SEXP);
@@ -72,7 +72,7 @@ static const R_CallMethodDef CallEntries[] = {
     {""_AlphaSimR_convToImat"",        (DL_FUNC) &_AlphaSimR_convToImat,        1},
     {""_AlphaSimR_createDH2"",         (DL_FUNC) &_AlphaSimR_createDH2,         5},
     {""_AlphaSimR_cross2"",            (DL_FUNC) &_AlphaSimR_cross2,            6},
-    {""_AlphaSimR_crossPedigree"",     (DL_FUNC) &_AlphaSimR_crossPedigree,     4},
+    {""_AlphaSimR_crossPedigree"",     (DL_FUNC) &_AlphaSimR_crossPedigree,     5},
     {""_AlphaSimR_fastDist"",          (DL_FUNC) &_AlphaSimR_fastDist,          1},
     {""_AlphaSimR_fastPairDist"",      (DL_FUNC) &_AlphaSimR_fastPairDist,      2},
     {""_AlphaSimR_gaussKernel"",       (DL_FUNC) &_AlphaSimR_gaussKernel,       2},

---FILE: src/meiosis.cpp---
@@ -122,10 +122,12 @@ arma::field<arma::Cube<unsigned char> > cross2(
   int nInd = mother.n_elem;
   //Output data
   arma::field<arma::Cube<unsigned char> > geno(nChr);
+  double femaleRecRate = 2/(1/recombRatio+1);
+  double maleRecRate = 2/(recombRatio+1);
   //Loop through chromosomes
   for(arma::uword chr=0; chr<nChr; ++chr){
-    arma::vec maleMap = 2*(recombRatio+1)*genMaps(chr);
-    arma::vec femaleMap = 2*recombRatio*(recombRatio+1)*genMaps(chr);
+    arma::vec maleMap = maleRecRate*genMaps(chr);
+    arma::vec femaleMap = femaleRecRate*genMaps(chr);
     int segSites = motherGeno(chr).n_rows;
     arma::Cube<unsigned char> tmpGeno(segSites,2,nInd);
     //Loop through individuals
@@ -156,7 +158,7 @@ arma::field<arma::Cube<unsigned char> > createDH2(
   int nInd = geno(0).n_slices;
   double ratio;
   if(useFemale){
-    ratio = 2*recombRatio/(recombRatio+1);
+    ratio = 2/(1/recombRatio+1);
   }else{
     ratio = 2/(recombRatio+1);
   }
@@ -193,11 +195,14 @@ arma::field<arma::Cube<unsigned char> > crossPedigree(
     const arma::field<arma::Cube<unsigned char> >& founders, 
     arma::uvec mother,
     arma::uvec father,
-    const arma::field<arma::vec>& genMaps){
+    const arma::field<arma::vec>& genMaps,
+    double recombRatio){
   mother -= 1; // R to C++
   father -= 1; // R to C++
   int nChr = founders.n_elem;
   int nInd = mother.n_elem;
+  double femaleRecRate = 2/(1/recombRatio+1);
+  double maleRecRate = 2/(recombRatio+1);
   
   typedef std::minstd_rand G;
   G g;
@@ -210,37 +215,38 @@ arma::field<arma::Cube<unsigned char> > crossPedigree(
   for(arma::uword chr=0; chr<nChr; ++chr){
     int segSites = founders(chr).n_rows;
     arma::Cube<unsigned char> tmpGeno(segSites,2,nInd);
-    
+    arma::vec maleMap = maleRecRate*genMaps(chr);
+    arma::vec femaleMap = femaleRecRate*genMaps(chr);
     //Loop through individuals
     for(arma::uword ind=0; ind<nInd; ++ind){
       if (mother(ind) == -1){
         //Female gamete
         tmpGeno.slice(ind).col(0) = 
           bivalent(founders(chr).slice(d(g)).col(0),
                    founders(chr).slice(d(g)).col(1),
-                   genMaps(chr));
+                   femaleMap);
       }
       else {
         //Female gamete
         tmpGeno.slice(ind).col(0) = 
           bivalent(tmpGeno.slice(mother(ind)).col(0),
                    tmpGeno.slice(mother(ind)).col(1),
-                   genMaps(chr));           
+                   femaleMap);           
       }
       if (father(ind) == -1) {
         //Male gamete
         tmpGeno.slice(ind).col(1) = 
           bivalent(founders(chr).slice(d(g)).col(0),
                    founders(chr).slice(d(g)).col(1),
-                   genMaps(chr));
+                   maleMap);
       }
       else
       {
         //Male gamete
         tmpGeno.slice(ind).col(1) = 
           bivalent(tmpGeno.slice(father(ind)).col(0),
                    tmpGeno.slice(father(ind)).col(1),
-                   genMaps(chr));
+                   maleMap);
       }
     } //End individual loop
     geno(chr) = tmpGeno;

---FILE: vignettes/BasicAnimal.Rmd---
@@ -1,46 +0,0 @@
----
-title: ""Basic Animal Simulation""
-author: ""Chris Gaynor""
-date: ""`r Sys.Date()`""
-output: pdf_document
-bibliography: bibliography.bib
-vignette: >
-  %\VignetteIndexEntry{Basic Animal}
-  %\VignetteEngine{knitr::rmarkdown}
-  %\VignetteEncoding{UTF-8}
----
-
-This document provides
-
-[-@Jenko15]
-
-```r
-# Basic animal breeding simulation
-# Based on ""historical breeding"" portion of Jenko et al., 2015
-# https://gsejournal.biomedcentral.com/articles/10.1186/s12711-015-0135-3
-library(AlphaSimR)
-# Generate initial haplotypes
-FOUNDERPOP = runMacs(nInd=1000,nChr=10,segSites=1000,
-                     inbred=FALSE,species=""TEST"") #Using TEST instead of CATTLE for speed
-
-# Set simulation parameters
-SIMPARAM = createSimulation(FOUNDERPOP,maxQtl=1000,maxSnp=0,gender=""yes_sys"")
-# Add a trait with additive effects
-SIMPARAM = addTraitA(FOUNDERPOP,nQtlPerChr=1000,meanG=0,varG=1)
-
-calves = newPop(FOUNDERPOP)
-popMean = meanG(calves)
-popVar = varG(calves)
-for(i in 1:20){
-  bulls = selectMale(calves,25,use=""gv"")
-  cows = selectFemale(calves,500,use=""gv"")
-  calves = randCross2(cows,bulls,nCrosses=1000)
-  popMean = c(popMean,meanG(calves))
-  popVar = c(popVar,varG(bulls))
-}
-plot(0:20,popMean,type=""l"",xlab=""Generation"",ylab=""GV"",main=""Genetic Gain"")
-plot(0:20,popVar,type=""l"",xlab=""Generation"",ylab=""GV"",main=""Genetic Variance"")
-```
-
-# References
-

---FILE: vignettes/GenomicSelection.Rmd---
@@ -1,42 +0,0 @@
----
-title: ""Genomic Selection""
-author: ""Chris Gaynor""
-date: ""`r Sys.Date()`""
-output: pdf_document
-bibliography: bibliography.bib
-vignette: >
-  %\VignetteIndexEntry{Genomic Selection}
-  %\VignetteEngine{knitr::rmarkdown}
-  %\VignetteEncoding{UTF-8}
----
-
-[@Massman13]
-[@sommer]
-[@EMMREML]
-
-```r
-library(AlphaSimR)
-FOUNDERPOP = runMacs(nInd=100,nChr=10,segSites=1200,
-                     inbred=FALSE,species=""TEST"")
-SIMPARAM = createSimulation(FOUNDERPOP,maxQtl=200,maxSnp=1000,gender=""yes_sys"")
-SIMPARAM = addTraitA(FOUNDERPOP,nQtlPerChr=100,meanG=0,varG=1)
-SIMPARAM = addSnpChip(1000)
-pop = newPop(FOUNDERPOP)
-unlink(""GS"",recursive=TRUE)
-dir.create(""GS"")
-writeRecords(pop,""GS"",1)
-for(gen in 1:9){
-  pop = randCross(pop,100)
-  writeRecords(pop,""GS"",1)
-}
-#Predict
-pop = randCross(pop,100)
-gsModel = RRBLUP(""GS"",1,use=""GV"")
-pop = setEBV(pop,gsModel)
-cor(pop@gv[,1],pop@ebv[,1])
-#Select on EBV
-best = selectInd(pop,10,use=""ebv"")
-meanG(best)-meanG(pop)
-```
-
-# References
\ No newline at end of file

---FILE: vignettes/Maize.Rmd---
@@ -1,22 +0,0 @@
----
-title: ""Maize Breeding Simulation""
-author: ""Chris Gaynor""
-date: ""`r Sys.Date()`""
-output: pdf_document
-bibliography: bibliography.bib
-vignette: >
-  %\VignetteIndexEntry{Maize}
-  %\VignetteEngine{knitr::rmarkdown}
-  %\VignetteEncoding{UTF-8}
----
-
-This document provides
-
-[@Troyer09]
-[@BernardoBook]
-
-```r
-
-```
-
-# References

---FILE: vignettes/Wheat.Rmd---
@@ -1,21 +0,0 @@
----
-title: ""Wheat Breeding Simulation""
-author: ""Chris Gaynor""
-date: ""`r Sys.Date()`""
-output: pdf_document
-bibliography: bibliography.bib
-vignette: >
-  %\VignetteIndexEntry{Wheat}
-  %\VignetteEngine{knitr::rmarkdown}
-  %\VignetteEncoding{UTF-8}
----
-
-This document provides
-
-[-@Gaynor17]
-
-```r
-
-```
-
-# References"
gaynorr,AlphaSimR,45afa0d0fd213c4bad084782cc1d1ea43fe20f2b,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-11-27T12:24:43Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-11-27T12:24:43Z,Patch for multivariate GS,DESCRIPTION;R/AlphaSimR.R;R/AlphaSuite.R;R/Class-HybridPop.R;R/Class-LociMap.R;R/Class-Pedigree.R;R/Class-Pop.R;R/GS.R;R/RcppExports.R;R/createSimulation.R;R/hybrids.R;R/misc.R;R/pedigree.R;R/popSummary.R;R/quickPop.R;R/selection.R;inst/doc/BasicAnimal.Rmd;inst/doc/BasicAnimal.html;inst/doc/BasicAnimal.pdf;inst/doc/GenomicSelection.Rmd;inst/doc/GenomicSelection.html;inst/doc/GenomicSelection.pdf;inst/doc/Introduction.pdf;inst/doc/Maize.R;inst/doc/Maize.Rmd;inst/doc/Maize.pdf;inst/doc/Wheat.R;inst/doc/Wheat.Rmd;inst/doc/Wheat.pdf;inst/doc/introduction.Rmd;inst/doc/introduction.html;src/RcppExports.cpp;vignettes/BasicAnimal.Rmd;vignettes/GenomicSelection.Rmd;vignettes/Maize.Rmd;vignettes/Wheat.Rmd;vignettes/bibliography.bib;vignettes/introduction.Rmd,True,True,True,False,654,1358,2012,"---FILE: DESCRIPTION---
@@ -2,8 +2,7 @@ Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
 Version: 0.4.0
-Author: Chris Gaynor, David Wilson, Daniel Money, Gregor Gorjanc
-Maintainer: Chris Gaynor <gaynor.robert@hotmail.com>
+Authors@R: c(person(""Chris"",""Gaynor"",email=""gaynor.robert@hotmail.com"",role=""cre""),person(""David"",""Wilson"",role=""ctb""),person(""Daniel"",""Money"",role=""ctb""),person(""Gregor"",""Gorjanc"",role=""ctb""))
 Description: This package contains classes and functions for simulating plant and animal breeding programs.
 License: MIT + file LICENSE
 Encoding: UTF-8

---FILE: R/AlphaSimR.R---
@@ -13,4 +13,3 @@
 #' @docType package
 #' @name AlphaSimR
 NULL
-

---FILE: R/AlphaSuite.R---
@@ -23,11 +23,10 @@ writeAlphaGenotypes = function(pop,file,chr=1,chips=rep(0,pop@nInd),
     }
   }
   else {
-    for (c in uniqueChips){
-      allSnps = sort(union(allSnps,simParam@snpChips[[c]]@lociLoc))
+    for (i in uniqueChips){
+      allSnps = sort(union(allSnps,simParam@snpChips[[i]]@lociLoc))
     }
   }
-  
   positions = list()
   for (i in 1:simParam@nSnpChips) {
     start = 1
@@ -65,8 +64,8 @@ writeAlphaHaplotypes = function(pop,file,chr=1,chips=rep(0,pop@nInd),simParam) {
     }
   }
   else {
-    for (c in uniqueChips){
-      allSnps = sort(union(allSnps,simParam@snpChips[[c]]@lociLoc))
+    for (i in uniqueChips){
+      allSnps = sort(union(allSnps,simParam@snpChips[[i]]@lociLoc))
     }
   }
 
@@ -84,4 +83,4 @@ writeAlphaHaplotypes = function(pop,file,chr=1,chips=rep(0,pop@nInd),simParam) {
   }
 
   writeASHaplotypes(pop@geno[[chr]],positions,allSnps,chips,sprintf(""%s"",pop@id),'9',normalizePath(file, mustWork=FALSE))
-}
\ No newline at end of file
+}

---FILE: R/Class-HybridPop.R---
@@ -122,4 +122,3 @@ setMethod(""c"",
             return(x)
           }
 )
-

---FILE: R/Class-LociMap.R---
@@ -158,8 +158,8 @@ setValidity(""TraitADG"",function(object){
 setClass(""RRsol"",
          slots=c(markerEff=""matrix"",
                  fixEff=""matrix"",
-                 Vu=""numeric"",
-                 Ve=""numeric"",
+                 Vu=""matrix"",
+                 Ve=""matrix"",
                  LL=""numeric"",
                  iter=""numeric""),
          contains=""LociMap"")
@@ -182,6 +182,8 @@ setValidity(""RRsol"",function(object){
   }
 })
 
+
+
 #RRDsol----
 #' @title RR-BLUP Solution with Dominance
 #' 

---FILE: R/Class-Pedigree.R---
@@ -1,4 +1,3 @@
-
 # Pedigree ------------------------------------------------------------------
 
 #' @title Pedigree
@@ -90,4 +89,4 @@ sortPed = function(x, maxGen=100){
     }
   }
   return(new(""Pedigree"",nInd=pedsize,ids=ids,mother=mother,father=father))
-}
\ No newline at end of file
+}

---FILE: R/Class-Pop.R---
@@ -1,4 +1,3 @@
-
 # RawPop ------------------------------------------------------------------
 
 #' @title Raw Population

---FILE: R/GS.R---
@@ -185,8 +185,8 @@ RRBLUP = function(dir, traits=1, use=""pheno"",
                lociLoc=markers@lociLoc,
                markerEff=markerEff,
                fixEff=ans$beta,
-               Vu=ans$Vu,
-               Ve=ans$Ve,
+               Vu=as.matrix(ans$Vu),
+               Ve=as.matrix(ans$Ve),
                LL=ans$LL,
                iter=iter)
   return(output)

---FILE: R/RcppExports.R---
@@ -1,6 +1,14 @@
 # Generated by using Rcpp::compileAttributes() -> do not edit by hand
 # Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393
 
+writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call(`_AlphaSimR_writeASGenotypes`, g, locations, allLocations, snpchips, names, missing, fname))
+}
+
+writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call(`_AlphaSimR_writeASHaplotypes`, g, locations, allLocations, snpchips, names, missing, fname))
+}
+
 gebvRR <- function(RRsol, pop) {
     .Call(`_AlphaSimR_gebvRR`, RRsol, pop)
 }
@@ -17,6 +25,99 @@ gebvSCA <- function(sol, pop, isSCAsol = TRUE) {
     .Call(`_AlphaSimR_gebvSCA`, sol, pop, isSCAsol)
 }
 
+getGeno <- function(geno, lociPerChr, lociLoc) {
+    .Call(`_AlphaSimR_getGeno`, geno, lociPerChr, lociLoc)
+}
+
+getDomGeno <- function(geno) {
+    .Call(`_AlphaSimR_getDomGeno`, geno)
+}
+
+getHaplo <- function(geno, lociPerChr, lociLoc) {
+    .Call(`_AlphaSimR_getHaplo`, geno, lociPerChr, lociLoc)
+}
+
+getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
+    .Call(`_AlphaSimR_getOneHaplo`, geno, lociPerChr, lociLoc, haplo)
+}
+
+writeGeno <- function(geno, lociPerChr, lociLoc, filePath) {
+    invisible(.Call(`_AlphaSimR_writeGeno`, geno, lociPerChr, lociLoc, filePath))
+}
+
+writeOneHaplo <- function(geno, lociPerChr, lociLoc, haplo, filePath) {
+    invisible(.Call(`_AlphaSimR_writeOneHaplo`, geno, lociPerChr, lociLoc, haplo, filePath))
+}
+
+getGv <- function(trait, pop) {
+    .Call(`_AlphaSimR_getGv`, trait, pop)
+}
+
+calcGenParam <- function(trait, pop) {
+    .Call(`_AlphaSimR_calcGenParam`, trait, pop)
+}
+
+getHybridGv <- function(trait, motherGeno, mother, fatherGeno, father) {
+    .Call(`_AlphaSimR_getHybridGv`, trait, motherGeno, mother, fatherGeno, father)
+}
+
+cross2 <- function(motherGeno, mother, fatherGeno, father, genMaps, recombRatio) {
+    .Call(`_AlphaSimR_cross2`, motherGeno, mother, fatherGeno, father, genMaps, recombRatio)
+}
+
+createDH2 <- function(geno, nDH, genMaps, recombRatio, useFemale) {
+    .Call(`_AlphaSimR_createDH2`, geno, nDH, genMaps, recombRatio, useFemale)
+}
+
+crossPedigree <- function(founders, mother, father, genMaps) {
+    .Call(`_AlphaSimR_crossPedigree`, founders, mother, father, genMaps)
+}
+
+#' @title Population variance
+#' 
+#' @description
+#' Calculates the population variance matrix as 
+#' opposed to the sample variance matrix calculated 
+#' by \code{\link{var}}. i.e. divides by n instead 
+#' of n-1
+#' 
+#' @param X an n by m matrix
+#' 
+#' @return an m by m variance-covariance matrix
+#' 
+#' @export
+popVar <- function(X) {
+    .Call(`_AlphaSimR_popVar`, X)
+}
+
+mergeGeno <- function(x, y) {
+    .Call(`_AlphaSimR_mergeGeno`, x, y)
+}
+
+calcChrFreq <- function(geno) {
+    .Call(`_AlphaSimR_calcChrFreq`, geno)
+}
+
+convToImat <- function(X) {
+    .Call(`_AlphaSimR_convToImat`, X)
+}
+
+sampAllComb <- function(nLevel1, nLevel2, n) {
+    .Call(`_AlphaSimR_sampAllComb`, nLevel1, nLevel2, n)
+}
+
+sampHalfDialComb <- function(nLevel, n) {
+    .Call(`_AlphaSimR_sampHalfDialComb`, nLevel, n)
+}
+
+zero <- function() {
+    .Call(`_AlphaSimR_zero`)
+}
+
+changeId <- function(newId, oldId) {
+    invisible(.Call(`_AlphaSimR_changeId`, newId, oldId))
+}
+
 #' @title Read Matrix
 #'
 #' @description
@@ -247,107 +348,6 @@ gaussKernel <- function(D, theta) {
     .Call(`_AlphaSimR_gaussKernel`, D, theta)
 }
 
-writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call(`_AlphaSimR_writeASGenotypes`, g, locations, allLocations, snpchips, names, missing, fname))
-}
-
-writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call(`_AlphaSimR_writeASHaplotypes`, g, locations, allLocations, snpchips, names, missing, fname))
-}
-
-getGeno <- function(geno, lociPerChr, lociLoc) {
-    .Call(`_AlphaSimR_getGeno`, geno, lociPerChr, lociLoc)
-}
-
-getDomGeno <- function(geno) {
-    .Call(`_AlphaSimR_getDomGeno`, geno)
-}
-
-getHaplo <- function(geno, lociPerChr, lociLoc) {
-    .Call(`_AlphaSimR_getHaplo`, geno, lociPerChr, lociLoc)
-}
-
-getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
-    .Call(`_AlphaSimR_getOneHaplo`, geno, lociPerChr, lociLoc, haplo)
-}
-
-writeGeno <- function(geno, lociPerChr, lociLoc, filePath) {
-    invisible(.Call(`_AlphaSimR_writeGeno`, geno, lociPerChr, lociLoc, filePath))
-}
-
-writeOneHaplo <- function(geno, lociPerChr, lociLoc, haplo, filePath) {
-    invisible(.Call(`_AlphaSimR_writeOneHaplo`, geno, lociPerChr, lociLoc, haplo, filePath))
-}
-
-getGv <- function(trait, pop) {
-    .Call(`_AlphaSimR_getGv`, trait, pop)
-}
-
-calcGenParam <- function(trait, pop) {
-    .Call(`_AlphaSimR_calcGenParam`, trait, pop)
-}
-
-getHybridGv <- function(trait, motherGeno, mother, fatherGeno, father) {
-    .Call(`_AlphaSimR_getHybridGv`, trait, motherGeno, mother, fatherGeno, father)
-}
-
-cross2 <- function(motherGeno, mother, fatherGeno, father, genMaps, recombRatio) {
-    .Call(`_AlphaSimR_cross2`, motherGeno, mother, fatherGeno, father, genMaps, recombRatio)
-}
-
-createDH2 <- function(geno, nDH, genMaps, recombRatio, useFemale) {
-    .Call(`_AlphaSimR_createDH2`, geno, nDH, genMaps, recombRatio, useFemale)
-}
-
-crossPedigree <- function(founders, mother, father, genMaps) {
-    .Call(`_AlphaSimR_crossPedigree`, founders, mother, father, genMaps)
-}
-
-#' @title Population variance
-#' 
-#' @description
-#' Calculates the population variance matrix as 
-#' opposed to the sample variance matrix calculated 
-#' by \code{\link{var}}. i.e. divides by n instead 
-#' of n-1
-#' 
-#' @param X an n by m matrix
-#' 
-#' @return an m by m variance-covariance matrix
-#' 
-#' @export
-popVar <- function(X) {
-    .Call(`_AlphaSimR_popVar`, X)
-}
-
-mergeGeno <- function(x, y) {
-    .Call(`_AlphaSimR_mergeGeno`, x, y)
-}
-
-calcChrFreq <- function(geno) {
-    .Call(`_AlphaSimR_calcChrFreq`, geno)
-}
-
-convToImat <- function(X) {
-    .Call(`_AlphaSimR_convToImat`, X)
-}
-
-sampAllComb <- function(nLevel1, nLevel2, n) {
-    .Call(`_AlphaSimR_sampAllComb`, nLevel1, nLevel2, n)
-}
-
-sampHalfDialComb <- function(nLevel, n) {
-    .Call(`_AlphaSimR_sampHalfDialComb`, nLevel, n)
-}
-
-zero <- function() {
-    .Call(`_AlphaSimR_zero`)
-}
-
-changeId <- function(newId, oldId) {
-    invisible(.Call(`_AlphaSimR_changeId`, newId, oldId))
-}
-
 packHaplo <- function(haplo, ploidy, inbred) {
     .Call(`_AlphaSimR_packHaplo`, haplo, ploidy, inbred)
 }

---FILE: R/createSimulation.R---
@@ -650,5 +650,3 @@ newPop = function(rawPop, id=NULL, mother=NULL,
   }
   return(output)
 }
-
-

---FILE: R/hybrids.R---
@@ -228,4 +228,3 @@ setPhenoGCA = function(pop,testers,use=""pheno"",varE=NULL,reps=1,
   pop@pheno = as.matrix(tmp$females[,-1])
   return(pop)
 }
-

---FILE: R/misc.R---
@@ -178,4 +178,4 @@ usefulness = function(pop,trait=1,use=""gv"",p=0.1,
   response = sort(response,decreasing=selectTop)
   response = response[1:ceiling(p*length(response))]
   return(mean(response))
-}
\ No newline at end of file
+}

---FILE: R/pedigree.R---
@@ -16,4 +16,4 @@ loadPedigreeFromFile = function(pedname) {
                  mother=match(fped[,2],fped[,1],nomatch=0L),
                  father=match(fped[,3],fped[,1],nomatch=0L))
   return(pedigree)
-}
\ No newline at end of file
+}

---FILE: R/popSummary.R---
@@ -100,4 +100,3 @@ varAD = function(pop,retGenParam=FALSE,simParam=NULL){
   }
   return(output)
 }
-

---FILE: R/quickPop.R---
@@ -89,4 +89,4 @@ trackHaploPop = function(genMaps,nInd,inbred=FALSE){
                nLoci=nLoci,geno=as.matrix(geno),
                genMaps=as.matrix(genMaps))
   return(output)
-}
\ No newline at end of file
+}

---FILE: R/selection.R---
@@ -311,4 +311,3 @@ selectWithinFam = function(pop,nInd,trait=1,use=""pheno"",
     return(take)
   }
 }
-

---FILE: inst/doc/BasicAnimal.Rmd---
@@ -2,13 +2,18 @@
 title: ""Basic Animal Simulation""
 author: ""Chris Gaynor""
 date: ""`r Sys.Date()`""
-output: rmarkdown::html_vignette
+output: pdf_document
+bibliography: bibliography.bib
 vignette: >
   %\VignetteIndexEntry{Basic Animal}
   %\VignetteEngine{knitr::rmarkdown}
   %\VignetteEncoding{UTF-8}
 ---
 
+This document provides
+
+[-@Jenko15]
+
 ```r
 # Basic animal breeding simulation
 # Based on ""historical breeding"" portion of Jenko et al., 2015
@@ -37,3 +42,5 @@ plot(0:20,popMean,type=""l"",xlab=""Generation"",ylab=""GV"",main=""Genetic Gain"")
 plot(0:20,popVar,type=""l"",xlab=""Generation"",ylab=""GV"",main=""Genetic Variance"")
 ```
 
+# References
+

---FILE: inst/doc/BasicAnimal.html---
@@ -1,314 +0,0 @@
-<!DOCTYPE html>
-
-<html xmlns=""http://www.w3.org/1999/xhtml"">
-
-<head>
-
-<meta charset=""utf-8"" />
-<meta http-equiv=""Content-Type"" content=""text/html; charset=utf-8"" />
-<meta name=""generator"" content=""pandoc"" />
-
-<meta name=""viewport"" content=""width=device-width, initial-scale=1"">
-
-<meta name=""author"" content=""Chris Gaynor"" />
-
-<meta name=""date"" content=""2017-11-22"" />
-
-<title>Basic Animal Simulation</title>
-
-
-
-<style type=""text/css"">code{white-space: pre;}</style>
-<style type=""text/css"">
-div.sourceLine, a.sourceLine { display: inline-block; min-height: 1.25em; }
-a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
-.sourceCode { overflow: visible; }
-code.sourceCode { white-space: pre; }
-@media print {
-code.sourceCode { white-space: pre-wrap; }
-div.sourceLine, a.sourceLine { text-indent: -1em; padding-left: 1em; }
-}
-pre.numberSource div.sourceLine, .numberSource a.sourceLine
-  { position: relative; }
-pre.numberSource div.sourceLine::before, .numberSource a.sourceLine::before
-  { content: attr(data-line-number);
-    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
-    border: none; pointer-events: all;
-    -webkit-touch-callout: none; -webkit-user-select: none;
-    -khtml-user-select: none; -moz-user-select: none;
-    -ms-user-select: none; user-select: none;
-    padding: 0 4px; width: 4em; }
-pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; color: #aaaaaa;  padding-left: 4px; }
-@media screen {
-a.sourceLine::before { text-decoration: underline; color: initial; }
-}
-code span.kw { color: #007020; font-weight: bold; } /* Keyword */
-code span.dt { color: #902000; } /* DataType */
-code span.dv { color: #40a070; } /* DecVal */
-code span.bn { color: #40a070; } /* BaseN */
-code span.fl { color: #40a070; } /* Float */
-code span.ch { color: #4070a0; } /* Char */
-code span.st { color: #4070a0; } /* String */
-code span.co { color: #60a0b0; font-style: italic; } /* Comment */
-code span.ot { color: #007020; } /* Other */
-code span.al { color: #ff0000; font-weight: bold; } /* Alert */
-code span.fu { color: #06287e; } /* Function */
-code span.er { color: #ff0000; font-weight: bold; } /* Error */
-code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
-code span.cn { color: #880000; } /* Constant */
-code span.sc { color: #4070a0; } /* SpecialChar */
-code span.vs { color: #4070a0; } /* VerbatimString */
-code span.ss { color: #bb6688; } /* SpecialString */
-code span.im { } /* Import */
-code span.va { color: #19177c; } /* Variable */
-code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
-code span.op { color: #666666; } /* Operator */
-code span.bu { } /* BuiltIn */
-code span.ex { } /* Extension */
-code span.pp { color: #bc7a00; } /* Preprocessor */
-code span.at { color: #7d9029; } /* Attribute */
-code span.do { color: #ba2121; font-style: italic; } /* Documentation */
-code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
-code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
-code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
-</style>
-
-
-
-<style type=""text/css"">body {
-background-color: #fff;
-margin: 1em auto;
-max-width: 700px;
-overflow: visible;
-padding-left: 2em;
-padding-right: 2em;
-font-family: ""Open Sans"", ""Helvetica Neue"", Helvetica, Arial, sans-serif;
-font-size: 14px;
-line-height: 1.35;
-}
-#header {
-text-align: center;
-}
-#TOC {
-clear: both;
-margin: 0 0 10px 10px;
-padding: 4px;
-width: 400px;
-border: 1px solid #CCCCCC;
-border-radius: 5px;
-background-color: #f6f6f6;
-font-size: 13px;
-line-height: 1.3;
-}
-#TOC .toctitle {
-font-weight: bold;
-font-size: 15px;
-margin-left: 5px;
-}
-#TOC ul {
-padding-left: 40px;
-margin-left: -1.5em;
-margin-top: 5px;
-margin-bottom: 5px;
-}
-#TOC ul ul {
-margin-left: -2em;
-}
-#TOC li {
-line-height: 16px;
-}
-table {
-margin: 1em auto;
-border-width: 1px;
-border-color: #DDDDDD;
-border-style: outset;
-border-collapse: collapse;
-}
-table th {
-border-width: 2px;
-padding: 5px;
-border-style: inset;
-}
-table td {
-border-width: 1px;
-border-style: inset;
-line-height: 18px;
-padding: 5px 5px;
-}
-table, table th, table td {
-border-left-style: none;
-border-right-style: none;
-}
-table thead, table tr.even {
-background-color: #f7f7f7;
-}
-p {
-margin: 0.5em 0;
-}
-blockquote {
-background-color: #f6f6f6;
-padding: 0.25em 0.75em;
-}
-hr {
-border-style: solid;
-border: none;
-border-top: 1px solid #777;
-margin: 28px 0;
-}
-dl {
-margin-left: 0;
-}
-dl dd {
-margin-bottom: 13px;
-margin-left: 13px;
-}
-dl dt {
-font-weight: bold;
-}
-ul {
-margin-top: 0;
-}
-ul li {
-list-style: circle outside;
-}
-ul ul {
-margin-bottom: 0;
-}
-pre, code {
-background-color: #f7f7f7;
-border-radius: 3px;
-color: #333;
-white-space: pre-wrap; 
-}
-pre {
-border-radius: 3px;
-margin: 5px 0px 10px 0px;
-padding: 10px;
-}
-pre:not([class]) {
-background-color: #f7f7f7;
-}
-code {
-font-family: Consolas, Monaco, 'Courier New', monospace;
-font-size: 85%;
-}
-p > code, li > code {
-padding: 2px 0px;
-}
-div.figure {
-text-align: center;
-}
-img {
-background-color: #FFFFFF;
-padding: 2px;
-border: 1px solid #DDDDDD;
-border-radius: 3px;
-border: 1px solid #CCCCCC;
-margin: 0 5px;
-}
-h1 {
-margin-top: 0;
-font-size: 35px;
-line-height: 40px;
-}
-h2 {
-border-bottom: 4px solid #f7f7f7;
-padding-top: 10px;
-padding-bottom: 2px;
-font-size: 145%;
-}
-h3 {
-border-bottom: 2px solid #f7f7f7;
-padding-top: 10px;
-font-size: 120%;
-}
-h4 {
-border-bottom: 1px solid #f7f7f7;
-margin-left: 8px;
-font-size: 105%;
-}
-h5, h6 {
-border-bottom: 1px solid #ccc;
-font-size: 105%;
-}
-a {
-color: #0033dd;
-text-decoration: none;
-}
-a:hover {
-color: #6666ff; }
-a:visited {
-color: #800080; }
-a:visited:hover {
-color: #BB00BB; }
-a[href^=""http:""] {
-text-decoration: underline; }
-a[href^=""https:""] {
-text-decoration: underline; }
-
-code > span.kw { color: #555; font-weight: bold; } 
-code > span.dt { color: #902000; } 
-code > span.dv { color: #40a070; } 
-code > span.bn { color: #d14; } 
-code > span.fl { color: #d14; } 
-code > span.ch { color: #d14; } 
-code > span.st { color: #d14; } 
-code > span.co { color: #888888; font-style: italic; } 
-code > span.ot { color: #007020; } 
-code > span.al { color: #ff0000; font-weight: bold; } 
-code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
-</style>
-
-</head>
-
-<body>
-
-
-
-
-<h1 class=""title toc-ignore"">Basic Animal Simulation</h1>
-<h4 class=""author""><em>Chris Gaynor</em></h4>
-<h4 class=""date""><em>2017-11-22</em></h4>
-
-
-
-<pre class=""sourceCode r"" id=""cb1""><code class=""sourceCode r""><div class=""sourceLine"" id=""cb1-1"" data-line-number=""1""><span class=""co""># Basic animal breeding simulation</span></div>
-<div class=""sourceLine"" id=""cb1-2"" data-line-number=""2""><span class=""co""># Based on &quot;historical breeding&quot; portion of Jenko et al., 2015</span></div>
-<div class=""sourceLine"" id=""cb1-3"" data-line-number=""3""><span class=""co""># https://gsejournal.biomedcentral.com/articles/10.1186/s12711-015-0135-3</span></div>
-<div class=""sourceLine"" id=""cb1-4"" data-line-number=""4""><span class=""kw"">library</span>(AlphaSimR)</div>
-<div class=""sourceLine"" id=""cb1-5"" data-line-number=""5""><span class=""co""># Generate initial haplotypes</span></div>
-<div class=""sourceLine"" id=""cb1-6"" data-line-number=""6"">FOUNDERPOP =<span class=""st""> </span><span class=""kw"">runMacs</span>(<span class=""dt"">nInd=</span><span class=""dv"">1000</span>,<span class=""dt"">nChr=</span><span class=""dv"">10</span>,<span class=""dt"">segSites=</span><span class=""dv"">1000</span>,</div>
-<div class=""sourceLine"" id=""cb1-7"" data-line-number=""7"">                     <span class=""dt"">inbred=</span><span class=""ot"">FALSE</span>,<span class=""dt"">species=</span><span class=""st"">&quot;TEST&quot;</span>) <span class=""co"">#Using </span><span class=""al"">TEST</span><span class=""co""> instead of CATTLE for speed</span></div>
-<div class=""sourceLine"" id=""cb1-8"" data-line-number=""8""></div>
-<div class=""sourceLine"" id=""cb1-9"" data-line-number=""9""><span class=""co""># Set simulation parameters</span></div>
-<div class=""sourceLine"" id=""cb1-10"" data-line-number=""10"">SIMPARAM =<span class=""st""> </span><span class=""kw"">createSimulation</span>(FOUNDERPOP,<span class=""dt"">maxQtl=</span><span class=""dv"">1000</span>,<span class=""dt"">maxSnp=</span><span class=""dv"">0</span>,<span class=""dt"">gender=</span><span class=""st"">&quot;yes_sys&quot;</span>)</div>
-<div class=""sourceLine"" id=""cb1-11"" data-line-number=""11""><span class=""co""># Add a trait with additive effects</span></div>
-<div class=""sourceLine"" id=""cb1-12"" data-line-number=""12"">SIMPARAM =<span class=""st""> </span><span class=""kw"">addTraitA</span>(FOUNDERPOP,<span class=""dt"">nQtlPerChr=</span><span class=""dv"">1000</span>,<span class=""dt"">meanG=</span><span class=""dv"">0</span>,<span class=""dt"">varG=</span><span class=""dv"">1</span>)</div>
-<div class=""sourceLine"" id=""cb1-13"" data-line-number=""13""></div>
-<div class=""sourceLine"" id=""cb1-14"" data-line-number=""14"">calves =<span class=""st""> </span><span class=""kw"">newPop</span>(FOUNDERPOP)</div>
-<div class=""sourceLine"" id=""cb1-15"" data-line-number=""15"">popMean =<span class=""st""> </span><span class=""kw"">meanG</span>(calves)</div>
-<div class=""sourceLine"" id=""cb1-16"" data-line-number=""16"">popVar =<span class=""st""> </span><span class=""kw"">varG</span>(calves)</div>
-<div class=""sourceLine"" id=""cb1-17"" data-line-number=""17""><span class=""cf"">for</span>(i <span class=""cf"">in</span> <span class=""dv"">1</span><span class=""op"">:</span><span class=""dv"">20</span>){</div>
-<div class=""sourceLine"" id=""cb1-18"" data-line-number=""18"">  bulls =<span class=""st""> </span><span class=""kw"">selectMale</span>(calves,<span class=""dv"">25</span>,<span class=""dt"">use=</span><span class=""st"">&quot;gv&quot;</span>)</div>
-<div class=""sourceLine"" id=""cb1-19"" data-line-number=""19"">  cows =<span class=""st""> </span><span class=""kw"">selectFemale</span>(calves,<span class=""dv"">500</span>,<span class=""dt"">use=</span><span class=""st"">&quot;gv&quot;</span>)</div>
-<div class=""sourceLine"" id=""cb1-20"" data-line-number=""20"">  calves =<span class=""st""> </span><span class=""kw"">randCross2</span>(cows,bulls,<span class=""dt"">nCrosses=</span><span class=""dv"">1000</span>)</div>
-<div class=""sourceLine"" id=""cb1-21"" data-line-number=""21"">  popMean =<span class=""st""> </span><span class=""kw"">c</span>(popMean,<span class=""kw"">meanG</span>(calves))</div>
-<div class=""sourceLine"" id=""cb1-22"" data-line-number=""22"">  popVar =<span class=""st""> </span><span class=""kw"">c</span>(popVar,<span class=""kw"">varG</span>(bulls))</div>
-<div class=""sourceLine"" id=""cb1-23"" data-line-number=""23"">}</div>
-<div class=""sourceLine"" id=""cb1-24"" data-line-number=""24""><span class=""kw"">plot</span>(<span class=""dv"">0</span><span class=""op"">:</span><span class=""dv"">20</span>,popMean,<span class=""dt"">type=</span><span class=""st"">&quot;l&quot;</span>,<span class=""dt"">xlab=</span><span class=""st"">&quot;Generation&quot;</span>,<span class=""dt"">ylab=</span><span class=""st"">&quot;GV&quot;</span>,<span class=""dt"">main=</span><span class=""st"">&quot;Genetic Gain&quot;</span>)</div>
-<div class=""sourceLine"" id=""cb1-25"" data-line-number=""25""><span class=""kw"">plot</span>(<span class=""dv"">0</span><span class=""op"">:</span><span class=""dv"">20</span>,popVar,<span class=""dt"">type=</span><span class=""st"">&quot;l&quot;</span>,<span class=""dt"">xlab=</span><span class=""st"">&quot;Generation&quot;</span>,<span class=""dt"">ylab=</span><span class=""st"">&quot;GV&quot;</span>,<span class=""dt"">main=</span><span class=""st"">&quot;Genetic Variance&quot;</span>)</div></code></pre>
-
-
-
-<!-- dynamically load mathjax for compatibility with self-contained -->
-<script>
-  (function () {
-    var script = document.createElement(""script"");
-    script.type = ""text/javascript"";
-    script.src  = ""https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"";
-    document.getElementsByTagName(""head"")[0].appendChild(script);
-  })();
-</script>
-
-</body>
-</html>

---FILE: inst/doc/GenomicSelection.Rmd---
@@ -2,22 +2,25 @@
 title: ""Genomic Selection""
 author: ""Chris Gaynor""
 date: ""`r Sys.Date()`""
-output: rmarkdown::html_vignette
+output: pdf_document
+bibliography: bibliography.bib
 vignette: >
   %\VignetteIndexEntry{Genomic Selection}
   %\VignetteEngine{knitr::rmarkdown}
   %\VignetteEncoding{UTF-8}
 ---
 
+[@Massman13]
+[@sommer]
+[@EMMREML]
+
 ```r
 library(AlphaSimR)
 FOUNDERPOP = runMacs(nInd=100,nChr=10,segSites=1200,
                      inbred=FALSE,species=""TEST"")
-rm(macsPath)
 SIMPARAM = createSimulation(FOUNDERPOP,maxQtl=200,maxSnp=1000,gender=""yes_sys"")
 SIMPARAM = addTraitA(FOUNDERPOP,nQtlPerChr=100,meanG=0,varG=1)
 SIMPARAM = addSnpChip(1000)
-
 pop = newPop(FOUNDERPOP)
 unlink(""GS"",recursive=TRUE)
 dir.create(""GS"")
@@ -32,5 +35,8 @@ gsModel = RRBLUP(""GS"",1,use=""GV"")
 pop = setEBV(pop,gsModel)
 cor(pop@gv[,1],pop@ebv[,1])
 #Select on EBV
-bestInd = selectInd(pop,10,use=""ebv"")
-```
\ No newline at end of file
+best = selectInd(pop,10,use=""ebv"")
+meanG(best)-meanG(pop)
+```
+
+# References
\ No newline at end of file

---FILE: inst/doc/GenomicSelection.html---
@@ -1,312 +0,0 @@
-<!DOCTYPE html>
-
-<html xmlns=""http://www.w3.org/1999/xhtml"">
-
-<head>
-
-<meta charset=""utf-8"" />
-<meta http-equiv=""Content-Type"" content=""text/html; charset=utf-8"" />
-<meta name=""generator"" content=""pandoc"" />
-
-<meta name=""viewport"" content=""width=device-width, initial-scale=1"">
-
-<meta name=""author"" content=""Chris Gaynor"" />
-
-<meta name=""date"" content=""2017-11-22"" />
-
-<title>Genomic Selection</title>
-
-
-
-<style type=""text/css"">code{white-space: pre;}</style>
-<style type=""text/css"">
-div.sourceLine, a.sourceLine { display: inline-block; min-height: 1.25em; }
-a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
-.sourceCode { overflow: visible; }
-code.sourceCode { white-space: pre; }
-@media print {
-code.sourceCode { white-space: pre-wrap; }
-div.sourceLine, a.sourceLine { text-indent: -1em; padding-left: 1em; }
-}
-pre.numberSource div.sourceLine, .numberSource a.sourceLine
-  { position: relative; }
-pre.numberSource div.sourceLine::before, .numberSource a.sourceLine::before
-  { content: attr(data-line-number);
-    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
-    border: none; pointer-events: all;
-    -webkit-touch-callout: none; -webkit-user-select: none;
-    -khtml-user-select: none; -moz-user-select: none;
-    -ms-user-select: none; user-select: none;
-    padding: 0 4px; width: 4em; }
-pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; color: #aaaaaa;  padding-left: 4px; }
-@media screen {
-a.sourceLine::before { text-decoration: underline; color: initial; }
-}
-code span.kw { color: #007020; font-weight: bold; } /* Keyword */
-code span.dt { color: #902000; } /* DataType */
-code span.dv { color: #40a070; } /* DecVal */
-code span.bn { color: #40a070; } /* BaseN */
-code span.fl { color: #40a070; } /* Float */
-code span.ch { color: #4070a0; } /* Char */
-code span.st { color: #4070a0; } /* String */
-code span.co { color: #60a0b0; font-style: italic; } /* Comment */
-code span.ot { color: #007020; } /* Other */
-code span.al { color: #ff0000; font-weight: bold; } /* Alert */
-code span.fu { color: #06287e; } /* Function */
-code span.er { color: #ff0000; font-weight: bold; } /* Error */
-code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
-code span.cn { color: #880000; } /* Constant */
-code span.sc { color: #4070a0; } /* SpecialChar */
-code span.vs { color: #4070a0; } /* VerbatimString */
-code span.ss { color: #bb6688; } /* SpecialString */
-code span.im { } /* Import */
-code span.va { color: #19177c; } /* Variable */
-code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
-code span.op { color: #666666; } /* Operator */
-code span.bu { } /* BuiltIn */
-code span.ex { } /* Extension */
-code span.pp { color: #bc7a00; } /* Preprocessor */
-code span.at { color: #7d9029; } /* Attribute */
-code span.do { color: #ba2121; font-style: italic; } /* Documentation */
-code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
-code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
-code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
-</style>
-
-
-
-<style type=""text/css"">body {
-background-color: #fff;
-margin: 1em auto;
-max-width: 700px;
-overflow: visible;
-padding-left: 2em;
-padding-right: 2em;
-font-family: ""Open Sans"", ""Helvetica Neue"", Helvetica, Arial, sans-serif;
-font-size: 14px;
-line-height: 1.35;
-}
-#header {
-text-align: center;
-}
-#TOC {
-clear: both;
-margin: 0 0 10px 10px;
-padding: 4px;
-width: 400px;
-border: 1px solid #CCCCCC;
-border-radius: 5px;
-background-color: #f6f6f6;
-font-size: 13px;
-line-height: 1.3;
-}
-#TOC .toctitle {
-font-weight: bold;
-font-size: 15px;
-margin-left: 5px;
-}
-#TOC ul {
-padding-left: 40px;
-margin-left: -1.5em;
-margin-top: 5px;
-margin-bottom: 5px;
-}
-#TOC ul ul {
-margin-left: -2em;
-}
-#TOC li {
-line-height: 16px;
-}
-table {
-margin: 1em auto;
-border-width: 1px;
-border-color: #DDDDDD;
-border-style: outset;
-border-collapse: collapse;
-}
-table th {
-border-width: 2px;
-padding: 5px;
-border-style: inset;
-}
-table td {
-border-width: 1px;
-border-style: inset;
-line-height: 18px;
-padding: 5px 5px;
-}
-table, table th, table td {
-border-left-style: none;
-border-right-style: none;
-}
-table thead, table tr.even {
-background-color: #f7f7f7;
-}
-p {
-margin: 0.5em 0;
-}
-blockquote {
-background-color: #f6f6f6;
-padding: 0.25em 0.75em;
-}
-hr {
-border-style: solid;
-border: none;
-border-top: 1px solid #777;
-margin: 28px 0;
-}
-dl {
-margin-left: 0;
-}
-dl dd {
-margin-bottom: 13px;
-margin-left: 13px;
-}
-dl dt {
-font-weight: bold;
-}
-ul {
-margin-top: 0;
-}
-ul li {
-list-style: circle outside;
-}
-ul ul {
-margin-bottom: 0;
-}
-pre, code {
-background-color: #f7f7f7;
-border-radius: 3px;
-color: #333;
-white-space: pre-wrap; 
-}
-pre {
-border-radius: 3px;
-margin: 5px 0px 10px 0px;
-padding: 10px;
-}
-pre:not([class]) {
-background-color: #f7f7f7;
-}
-code {
-font-family: Consolas, Monaco, 'Courier New', monospace;
-font-size: 85%;
-}
-p > code, li > code {
-padding: 2px 0px;
-}
-div.figure {
-text-align: center;
-}
-img {
-background-color: #FFFFFF;
-padding: 2px;
-border: 1px solid #DDDDDD;
-border-radius: 3px;
-border: 1px solid #CCCCCC;
-margin: 0 5px;
-}
-h1 {
-margin-top: 0;
-font-size: 35px;
-line-height: 40px;
-}
-h2 {
-border-bottom: 4px solid #f7f7f7;
-padding-top: 10px;
-padding-bottom: 2px;
-font-size: 145%;
-}
-h3 {
-border-bottom: 2px solid #f7f7f7;
-padding-top: 10px;
-font-size: 120%;
-}
-h4 {
-border-bottom: 1px solid #f7f7f7;
-margin-left: 8px;
-font-size: 105%;
-}
-h5, h6 {
-border-bottom: 1px solid #ccc;
-font-size: 105%;
-}
-a {
-color: #0033dd;
-text-decoration: none;
-}
-a:hover {
-color: #6666ff; }
-a:visited {
-color: #800080; }
-a:visited:hover {
-color: #BB00BB; }
-a[href^=""http:""] {
-text-decoration: underline; }
-a[href^=""https:""] {
-text-decoration: underline; }
-
-code > span.kw { color: #555; font-weight: bold; } 
-code > span.dt { color: #902000; } 
-code > span.dv { color: #40a070; } 
-code > span.bn { color: #d14; } 
-code > span.fl { color: #d14; } 
-code > span.ch { color: #d14; } 
-code > span.st { color: #d14; } 
-code > span.co { color: #888888; font-style: italic; } 
-code > span.ot { color: #007020; } 
-code > span.al { color: #ff0000; font-weight: bold; } 
-code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
-</style>
-
-</head>
-
-<body>
-
-
-
-
-<h1 class=""title toc-ignore"">Genomic Selection</h1>
-<h4 class=""author""><em>Chris Gaynor</em></h4>
-<h4 class=""date""><em>2017-11-22</em></h4>
-
-
-
-<pre class=""sourceCode r"" id=""cb1""><code class=""sourceCode r""><div class=""sourceLine"" id=""cb1-1"" data-line-number=""1""><span class=""kw"">library</span>(AlphaSimR)</div>
-<div class=""sourceLine"" id=""cb1-2"" data-line-number=""2"">FOUNDERPOP =<span class=""st""> </span><span class=""kw"">runMacs</span>(<span class=""dt"">nInd=</span><span class=""dv"">100</span>,<span class=""dt"">nChr=</span><span class=""dv"">10</span>,<span class=""dt"">segSites=</span><span class=""dv"">1200</span>,</div>
-<div class=""sourceLine"" id=""cb1-3"" data-line-number=""3"">                     <span class=""dt"">inbred=</span><span class=""ot"">FALSE</span>,<span class=""dt"">species=</span><span class=""st"">&quot;TEST&quot;</span>)</div>
-<div class=""sourceLine"" id=""cb1-4"" data-line-number=""4""><span class=""kw"">rm</span>(macsPath)</div>
-<div class=""sourceLine"" id=""cb1-5"" data-line-number=""5"">SIMPARAM =<span class=""st""> </span><span class=""kw"">createSimulation</span>(FOUNDERPOP,<span class=""dt"">maxQtl=</span><span class=""dv"">200</span>,<span class=""dt"">maxSnp=</span><span class=""dv"">1000</span>,<span class=""dt"">gender=</span><span class=""st"">&quot;yes_sys&quot;</span>)</div>
-<div class=""sourceLine"" id=""cb1-6"" data-line-number=""6"">SIMPARAM =<span class=""st""> </span><span class=""kw"">addTraitA</span>(FOUNDERPOP,<span class=""dt"">nQtlPerChr=</span><span class=""dv"">100</span>,<span class=""dt"">meanG=</span><span class=""dv"">0</span>,<span class=""dt"">varG=</span><span class=""dv"">1</span>)</div>
-<div class=""sourceLine"" id=""cb1-7"" data-line-number=""7"">SIMPARAM =<span class=""st""> </span><span class=""kw"">addSnpChip</span>(<span class=""dv"">1000</span>)</div>
-<div class=""sourceLine"" id=""cb1-8"" data-line-number=""8""></div>
-<div class=""sourceLine"" id=""cb1-9"" data-line-number=""9"">pop =<span class=""st""> </span><span class=""kw"">newPop</span>(FOUNDERPOP)</div>
-<div class=""sourceLine"" id=""cb1-10"" data-line-number=""10""><span class=""kw"">unlink</span>(<span class=""st"">&quot;GS&quot;</span>,<span class=""dt"">recursive=</span><span class=""ot"">TRUE</span>)</div>
-<div class=""sourceLine"" id=""cb1-11"" data-line-number=""11""><span class=""kw"">dir.create</span>(<span class=""st"">&quot;GS&quot;</span>)</div>
-<div class=""sourceLine"" id=""cb1-12"" data-line-number=""12""><span class=""kw"">writeRecords</span>(pop,<span class=""st"">&quot;GS&quot;</span>,<span class=""dv"">1</span>)</div>
-<div class=""sourceLine"" id=""cb1-13"" data-line-number=""13""><span class=""cf"">for</span>(gen <span class=""cf"">in</span> <span class=""dv"">1</span><span class=""op"">:</span><span class=""dv"">9</span>){</div>
-<div class=""sourceLine"" id=""cb1-14"" data-line-number=""14"">  pop =<span class=""st""> </span><span class=""kw"">randCross</span>(pop,<span class=""dv"">100</span>)</div>
-<div class=""sourceLine"" id=""cb1-15"" data-line-number=""15"">  <span class=""kw"">writeRecords</span>(pop,<span class=""st"">&quot;GS&quot;</span>,<span class=""dv"">1</span>)</div>
-<div class=""sourceLine"" id=""cb1-16"" data-line-number=""16"">}</div>
-<div class=""sourceLine"" id=""cb1-17"" data-line-number=""17""><span class=""co"">#Predict</span></div>
-<div class=""sourceLine"" id=""cb1-18"" data-line-number=""18"">pop =<span class=""st""> </span><span class=""kw"">randCross</span>(pop,<span class=""dv"">100</span>)</div>
-<div class=""sourceLine"" id=""cb1-19"" data-line-number=""19"">gsModel =<span class=""st""> </span><span class=""kw"">RRBLUP</span>(<span class=""st"">&quot;GS&quot;</span>,<span class=""dv"">1</span>,<span class=""dt"">use=</span><span class=""st"">&quot;GV&quot;</span>)</div>
-<div class=""sourceLine"" id=""cb1-20"" data-line-number=""20"">pop =<span class=""st""> </span><span class=""kw"">setEBV</span>(pop,gsModel)</div>
-<div class=""sourceLine"" id=""cb1-21"" data-line-number=""21""><span class=""kw"">cor</span>(pop<span class=""op"">@</span>gv[,<span class=""dv"">1</span>],pop<span class=""op"">@</span>ebv[,<span class=""dv"">1</span>])</div>
-<div class=""sourceLine"" id=""cb1-22"" data-line-number=""22""><span class=""co"">#Select on EBV</span></div>
-<div class=""sourceLine"" id=""cb1-23"" data-line-number=""23"">bestInd =<span class=""st""> </span><span class=""kw"">selectInd</span>(pop,<span class=""dv"">10</span>,<span class=""dt"">use=</span><span class=""st"">&quot;ebv&quot;</span>)</div></code></pre>
-
-
-
-<!-- dynamically load mathjax for compatibility with self-contained -->
-<script>
-  (function () {
-    var script = document.createElement(""script"");
-    script.type = ""text/javascript"";
-    script.src  = ""https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"";
-    document.getElementsByTagName(""head"")[0].appendChild(script);
-  })();
-</script>
-
-</body>
-</html>

---FILE: inst/doc/Maize.R---
@@ -0,0 +1 @@
+

---FILE: inst/doc/Maize.Rmd---
@@ -0,0 +1,22 @@
+---
+title: ""Maize Breeding Simulation""
+author: ""Chris Gaynor""
+date: ""`r Sys.Date()`""
+output: pdf_document
+bibliography: bibliography.bib
+vignette: >
+  %\VignetteIndexEntry{Maize}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+
+This document provides
+
+[@Troyer09]
+[@BernardoBook]
+
+```r
+
+```
+
+# References

---FILE: inst/doc/Wheat.R---
@@ -0,0 +1 @@
+

---FILE: inst/doc/Wheat.Rmd---
@@ -0,0 +1,21 @@
+---
+title: ""Wheat Breeding Simulation""
+author: ""Chris Gaynor""
+date: ""`r Sys.Date()`""
+output: pdf_document
+bibliography: bibliography.bib
+vignette: >
+  %\VignetteIndexEntry{Wheat}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+
+This document provides
+
+[-@Gaynor17]
+
+```r
+
+```
+
+# References

---FILE: inst/doc/introduction.Rmd---
@@ -2,15 +2,16 @@
 title: ""Introduction to AlphaSimR""
 author: ""Chris Gaynor""
 date: ""`r Sys.Date()`""
-output: rmarkdown::html_vignette
+output: pdf_document
+bibliography: bibliography.bib
 vignette: >
   %\VignetteIndexEntry{Introduction}
   %\VignetteEngine{knitr::rmarkdown}
   %\VignetteEncoding{UTF-8}
 ---
 
 
-The AlphaSimR package provides a framework for simulating plant and animal breeding programs in R. It is based on the [AlphaSim](https://dl.sciencesocieties.org/publications/tpg/abstracts/9/3/plantgenome2016.02.0013) program. This document will introduce the basic steps for running a simulation in AlphaSimR.
+The AlphaSimR package provides a framework for simulating plant and animal breeding programs in R. It is based on the AlphaSim program [@AlphaSim]. This document will introduce the basic steps for running a simulation in AlphaSimR.
 
 The basic steps of an AlphaSimR simulation are:
 
@@ -20,37 +21,37 @@ The basic steps of an AlphaSimR simulation are:
 
 3. Add traits using `addTraitA` or any other addTrait function
 
-4. Optionally, add SNP chips using `addSnpChip`
+4. Add SNP chips using `addSnpChip` (optional)
 
 5. Create one or more initial populations using `newPop`
 
 6. Perform a mix of crossing and selection to simulate a breeding program
 
-### Creating founder haplotypes
+# Creating Founder Haplotypes
 
-The first step to a simulation in AlphaSimR is to create a set of founder haplotypes. This is done using the `runMacs` function which uses a built in version of the [MaCS](https://github.com/gchen98/macs) program. The `runMacs` function allows for simulation of haplotypes using several predefined species histories or can be used to run a custom population using MaCS command line arguements. 
+The first step in an AlphaSimR simulation is to create a set of founder haplotypes. To do this, run the function `runMacs`. The `runMacs` function uses a built in version of the MaCS program [@MaCS]. The `runMacs` function allows for simulation of haplotypes using several predefined species histories or can be used to create a custom population using MaCS command line arguments. 
 
-### Setting simulation parameters
+# Setting Simulation Parameters
 
-Parameters for a simulation are stored in an object of `SimParam-class`. This object is created by calling the function `createSimulation`. The `SimParam-class` is a container for global parameters that will be used by many functions in AlphaSimR. To avoid specifying a `SimParam-class` in all functions that use one, it is recommended that you give your `SimParam-class` the name `SIMPARAM`. All functions that take a `SimParam-class` as an arguement will search your global environment for an object called `SIMPARAM` if the argument is `NULL`.
+Parameters for a simulation are stored in an object of `SimParam-class`. The function `createSimulation` creates this object. The `SimParam-class` is a container for global parameters that will be used by many functions in AlphaSimR. To avoid specifying a `SimParam-class` in all functions that use one, it is recommended that you give your `SimParam-class` the name `SIMPARAM`. All functions that take a `SimParam-class` as an arguement will search your global environment for an object called `SIMPARAM` if the argument is `NULL`.
 
-### Adding traits
+# Adding Traits
 
-Traits are added to the simulation using one of the fullowing functions: `addTraitA`, `addTraitAD`, `addTraitAG`, or `addTraitADG`. These functions can be called multiple times to run simulations with multiple traits. These functions can also be used to simulate correlated pleiotropic traits. Simulation without any traits are possible as long as you don't use a selection function.
+Traits are added to the simulation using one of the fullowing functions: `addTraitA`, `addTraitAD`, `addTraitAG`, or `addTraitADG`. These functions can be called multiple times to run simulations with multiple traits. These functions can also be used to simulate correlated pleiotropic traits. Simulations without any traits are possible as long as you don't use a selection function.
 
-### Adding SNP chips
+# Adding SNP Chips
 
 SNP chips are added to the simulation using the `addSnpChip` or `addStructuredSnpChips` functions. As with traits, these functions can be called multiple times to assign multiple SNP chips. SNP chips are not necessary for a simulation, so this step can be skipped.
 
-### Creating a population
+# Creating a Population
 
-The main objects in an AlphaSimR simulation are `Pop-class` objects. These objects represent a population which contains one or more individuals. Many AlphaSimR functions use a `Pop-class` object as an argument and return a `Pop-class` object as a result.
+The main objects in an AlphaSimR simulation are `Pop-class` objects. These objects represent a population that contains one or more individuals. Many AlphaSimR functions use a `Pop-class` object as an argument and return a `Pop-class` object as a result.
 
 To create your first `Pop-class` object use the function `newPop`. This function should only be called after you have finished all of the above steps.
 
-### Working with populations
+# Working with Populations
 
-Below are some functions for operations carried out on populations.
+Listed below are some functions for carrying out operations on populations.
 
 * Viewing genotypes: `pullSnpGeno`, `pullSnpHaplo`, `pullQtlGeno`, `pullQtlHaplo`, `pullSegSitHaplo`
 
@@ -64,3 +65,5 @@ Below are some functions for operations carried out on populations.
 `self`, `makeDH`
 
 * Genomic selection: `writeRecords`, `setEBV`
+
+# References
\ No newline at end of file

---FILE: inst/doc/introduction.html---
@@ -1,278 +0,0 @@
-<!DOCTYPE html>
-
-<html xmlns=""http://www.w3.org/1999/xhtml"">
-
-<head>
-
-<meta charset=""utf-8"" />
-<meta http-equiv=""Content-Type"" content=""text/html; charset=utf-8"" />
-<meta name=""generator"" content=""pandoc"" />
-
-<meta name=""viewport"" content=""width=device-width, initial-scale=1"">
-
-<meta name=""author"" content=""Chris Gaynor"" />
-
-<meta name=""date"" content=""2017-11-22"" />
-
-<title>Introduction to AlphaSimR</title>
-
-
-
-
-
-
-<style type=""text/css"">body {
-background-color: #fff;
-margin: 1em auto;
-max-width: 700px;
-overflow: visible;
-padding-left: 2em;
-padding-right: 2em;
-font-family: ""Open Sans"", ""Helvetica Neue"", Helvetica, Arial, sans-serif;
-font-size: 14px;
-line-height: 1.35;
-}
-#header {
-text-align: center;
-}
-#TOC {
-clear: both;
-margin: 0 0 10px 10px;
-padding: 4px;
-width: 400px;
-border: 1px solid #CCCCCC;
-border-radius: 5px;
-background-color: #f6f6f6;
-font-size: 13px;
-line-height: 1.3;
-}
-#TOC .toctitle {
-font-weight: bold;
-font-size: 15px;
-margin-left: 5px;
-}
-#TOC ul {
-padding-left: 40px;
-margin-left: -1.5em;
-margin-top: 5px;
-margin-bottom: 5px;
-}
-#TOC ul ul {
-margin-left: -2em;
-}
-#TOC li {
-line-height: 16px;
-}
-table {
-margin: 1em auto;
-border-width: 1px;
-border-color: #DDDDDD;
-border-style: outset;
-border-collapse: collapse;
-}
-table th {
-border-width: 2px;
-padding: 5px;
-border-style: inset;
-}
-table td {
-border-width: 1px;
-border-style: inset;
-line-height: 18px;
-padding: 5px 5px;
-}
-table, table th, table td {
-border-left-style: none;
-border-right-style: none;
-}
-table thead, table tr.even {
-background-color: #f7f7f7;
-}
-p {
-margin: 0.5em 0;
-}
-blockquote {
-background-color: #f6f6f6;
-padding: 0.25em 0.75em;
-}
-hr {
-border-style: solid;
-border: none;
-border-top: 1px solid #777;
-margin: 28px 0;
-}
-dl {
-margin-left: 0;
-}
-dl dd {
-margin-bottom: 13px;
-margin-left: 13px;
-}
-dl dt {
-font-weight: bold;
-}
-ul {
-margin-top: 0;
-}
-ul li {
-list-style: circle outside;
-}
-ul ul {
-margin-bottom: 0;
-}
-pre, code {
-background-color: #f7f7f7;
-border-radius: 3px;
-color: #333;
-white-space: pre-wrap; 
-}
-pre {
-border-radius: 3px;
-margin: 5px 0px 10px 0px;
-padding: 10px;
-}
-pre:not([class]) {
-background-color: #f7f7f7;
-}
-code {
-font-family: Consolas, Monaco, 'Courier New', monospace;
-font-size: 85%;
-}
-p > code, li > code {
-padding: 2px 0px;
-}
-div.figure {
-text-align: center;
-}
-img {
-background-color: #FFFFFF;
-padding: 2px;
-border: 1px solid #DDDDDD;
-border-radius: 3px;
-border: 1px solid #CCCCCC;
-margin: 0 5px;
-}
-h1 {
-margin-top: 0;
-font-size: 35px;
-line-height: 40px;
-}
-h2 {
-border-bottom: 4px solid #f7f7f7;
-padding-top: 10px;
-padding-bottom: 2px;
-font-size: 145%;
-}
-h3 {
-border-bottom: 2px solid #f7f7f7;
-padding-top: 10px;
-font-size: 120%;
-}
-h4 {
-border-bottom: 1px solid #f7f7f7;
-margin-left: 8px;
-font-size: 105%;
-}
-h5, h6 {
-border-bottom: 1px solid #ccc;
-font-size: 105%;
-}
-a {
-color: #0033dd;
-text-decoration: none;
-}
-a:hover {
-color: #6666ff; }
-a:visited {
-color: #800080; }
-a:visited:hover {
-color: #BB00BB; }
-a[href^=""http:""] {
-text-decoration: underline; }
-a[href^=""https:""] {
-text-decoration: underline; }
-
-code > span.kw { color: #555; font-weight: bold; } 
-code > span.dt { color: #902000; } 
-code > span.dv { color: #40a070; } 
-code > span.bn { color: #d14; } 
-code > span.fl { color: #d14; } 
-code > span.ch { color: #d14; } 
-code > span.st { color: #d14; } 
-code > span.co { color: #888888; font-style: italic; } 
-code > span.ot { color: #007020; } 
-code > span.al { color: #ff0000; font-weight: bold; } 
-code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
-</style>
-
-</head>
-
-<body>
-
-
-
-
-<h1 class=""title toc-ignore"">Introduction to AlphaSimR</h1>
-<h4 class=""author""><em>Chris Gaynor</em></h4>
-<h4 class=""date""><em>2017-11-22</em></h4>
-
-
-
-<p>The AlphaSimR package provides a framework for simulating plant and animal breeding programs in R. It is based on the <a href=""https://dl.sciencesocieties.org/publications/tpg/abstracts/9/3/plantgenome2016.02.0013"">AlphaSim</a> program. This document will introduce the basic steps for running a simulation in AlphaSimR.</p>
-<p>The basic steps of an AlphaSimR simulation are:</p>
-<ol type=""1"">
-<li><p>Create founder haplotypes using <code>runMacs</code></p></li>
-<li><p>Set simulation parameters using <code>createSimulation</code></p></li>
-<li><p>Add traits using <code>addTraitA</code> or any other addTrait function</p></li>
-<li><p>Optionally, add SNP chips using <code>addSnpChip</code></p></li>
-<li><p>Create one or more initial populations using <code>newPop</code></p></li>
-<li><p>Perform a mix of crossing and selection to simulate a breeding program</p></li>
-</ol>
-<section id=""creating-founder-haplotypes"" class=""level3"">
-<h3>Creating founder haplotypes</h3>
-<p>The first step to a simulation in AlphaSimR is to create a set of founder haplotypes. This is done using the <code>runMacs</code> function which uses a built in version of the <a href=""https://github.com/gchen98/macs"">MaCS</a> program. The <code>runMacs</code> function allows for simulation of haplotypes using several predefined species histories or can be used to run a custom population using MaCS command line arguements.</p>
-</section>
-<section id=""setting-simulation-parameters"" class=""level3"">
-<h3>Setting simulation parameters</h3>
-<p>Parameters for a simulation are stored in an object of <code>SimParam-class</code>. This object is created by calling the function <code>createSimulation</code>. The <code>SimParam-class</code> is a container for global parameters that will be used by many functions in AlphaSimR. To avoid specifying a <code>SimParam-class</code> in all functions that use one, it is recommended that you give your <code>SimParam-class</code> the name <code>SIMPARAM</code>. All functions that take a <code>SimParam-class</code> as an arguement will search your global environment for an object called <code>SIMPARAM</code> if the argument is <code>NULL</code>.</p>
-</section>
-<section id=""adding-traits"" class=""level3"">
-<h3>Adding traits</h3>
-<p>Traits are added to the simulation using one of the fullowing functions: <code>addTraitA</code>, <code>addTraitAD</code>, <code>addTraitAG</code>, or <code>addTraitADG</code>. These functions can be called multiple times to run simulations with multiple traits. These functions can also be used to simulate correlated pleiotropic traits. Simulation without any traits are possible as long as you dont use a selection function.</p>
-</section>
-<section id=""adding-snp-chips"" class=""level3"">
-<h3>Adding SNP chips</h3>
-<p>SNP chips are added to the simulation using the <code>addSnpChip</code> or <code>addStructuredSnpChips</code> functions. As with traits, these functions can be called multiple times to assign multiple SNP chips. SNP chips are not necessary for a simulation, so this step can be skipped.</p>
-</section>
-<section id=""creating-a-population"" class=""level3"">
-<h3>Creating a population</h3>
-<p>The main objects in an AlphaSimR simulation are <code>Pop-class</code> objects. These objects represent a population which contains one or more individuals. Many AlphaSimR functions use a <code>Pop-class</code> object as an argument and return a <code>Pop-class</code> object as a result.</p>
-<p>To create your first <code>Pop-class</code> object use the function <code>newPop</code>. This function should only be called after you have finished all of the above steps.</p>
-</section>
-<section id=""working-with-populations"" class=""level3"">
-<h3>Working with populations</h3>
-<p>Below are some functions for operations carried out on populations.</p>
-<ul>
-<li><p>Viewing genotypes: <code>pullSnpGeno</code>, <code>pullSnpHaplo</code>, <code>pullQtlGeno</code>, <code>pullQtlHaplo</code>, <code>pullSegSitHaplo</code></p></li>
-<li><p>Viewing summary data: <code>meanG</code>, <code>meanP</code>, <code>varG</code>, <code>varP</code>, <code>varAD</code></p></li>
-<li><p>Setting phenotypes: <code>setPheno</code>, <code>calcPheno</code>, <code>setPhenoGCA</code></p></li>
-<li><p>Making selections: <code>selectInd</code>, <code>selectFam</code>, <code>selectWithinFam</code>, <code>selectMale</code>, <code>selectFemale</code></p></li>
-<li><p>Crossing: <code>makeCross</code>, <code>randCross</code>, <code>makeCross2</code>, <code>randCross2</code>, <code>self</code>, <code>makeDH</code></p></li>
-<li><p>Genomic selection: <code>writeRecords</code>, <code>setEBV</code></p></li>
-</ul>
-</section>
-
-
-
-<!-- dynamically load mathjax for compatibility with self-contained -->
-<script>
-  (function () {
-    var script = document.createElement(""script"");
-    script.type = ""text/javascript"";
-    script.src  = ""https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"";
-    document.getElementsByTagName(""head"")[0].appendChild(script);
-  })();
-</script>
-
-</body>
-</html>

---FILE: src/RcppExports.cpp---
@@ -6,6 +6,38 @@
 
 using namespace Rcpp;
 
+// writeASGenotypes
+void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP _AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
+END_RCPP
+}
+// writeASHaplotypes
+void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP _AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
+END_RCPP
+}
 // gebvRR
 arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
 RcppExport SEXP _AlphaSimR_gebvRR(SEXP RRsolSEXP, SEXP popSEXP) {
@@ -57,294 +89,6 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// readMat
-arma::mat readMat(std::string fileName, int rows, int cols, char sep, int skipRows, int skipCols);
-RcppExport SEXP _AlphaSimR_readMat(SEXP fileNameSEXP, SEXP rowsSEXP, SEXP colsSEXP, SEXP sepSEXP, SEXP skipRowsSEXP, SEXP skipColsSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< std::string >::type fileName(fileNameSEXP);
-    Rcpp::traits::input_parameter< int >::type rows(rowsSEXP);
-    Rcpp::traits::input_parameter< int >::type cols(colsSEXP);
-    Rcpp::traits::input_parameter< char >::type sep(sepSEXP);
-    Rcpp::traits::input_parameter< int >::type skipRows(skipRowsSEXP);
-    Rcpp::traits::input_parameter< int >::type skipCols(skipColsSEXP);
-    rcpp_result_gen = Rcpp::wrap(readMat(fileName, rows, cols, sep, skipRows, skipCols));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveUVM
-Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
-RcppExport SEXP _AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveRRBLUP
-Rcpp::List solveRRBLUP(const arma::mat& y, const arma::mat& X, const arma::mat& M);
-RcppExport SEXP _AlphaSimR_solveRRBLUP(SEXP ySEXP, SEXP XSEXP, SEXP MSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type M(MSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveRRBLUP(y, X, M));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMVM
-Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol, int maxIter);
-RcppExport SEXP _AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveRRBLUPMV
-Rcpp::List solveRRBLUPMV(const arma::mat& Y, const arma::mat& X, const arma::mat& M, double tol, int maxIter);
-RcppExport SEXP _AlphaSimR_solveRRBLUPMV(SEXP YSEXP, SEXP XSEXP, SEXP MSEXP, SEXP tolSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type M(MSEXP);
-    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveRRBLUPMV(Y, X, M, tol, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMKM
-Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist, int maxIter);
-RcppExport SEXP _AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveRRBLUPMK
-Rcpp::List solveRRBLUPMK(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Mlist, int maxIter);
-RcppExport SEXP _AlphaSimR_solveRRBLUPMK(SEXP ySEXP, SEXP XSEXP, SEXP MlistSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Mlist(MlistSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveRRBLUPMK(y, X, Mlist, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP
-Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip);
-RcppExport SEXP _AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker, skip));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_D
-Rcpp::List callRRBLUP_D(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip);
-RcppExport SEXP _AlphaSimR_callRRBLUP_D(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_D(y, x, reps, genoTrain, nMarker, skip));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_MV
-Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip, int maxIter);
-RcppExport SEXP _AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker, skip, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_GCA
-Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker, int skip, int maxIter);
-RcppExport SEXP _AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_SCA
-Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker, int skip, int maxIter);
-RcppExport SEXP _AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcG
-arma::mat calcG(arma::mat X);
-RcppExport SEXP _AlphaSimR_calcG(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcG(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcD
-arma::mat calcD(arma::mat X);
-RcppExport SEXP _AlphaSimR_calcD(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcD(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcGIbs
-arma::mat calcGIbs(arma::mat X);
-RcppExport SEXP _AlphaSimR_calcGIbs(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcGIbs(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// fastDist
-arma::mat fastDist(const arma::mat& X);
-RcppExport SEXP _AlphaSimR_fastDist(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(fastDist(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// fastPairDist
-arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y);
-RcppExport SEXP _AlphaSimR_fastPairDist(SEXP XSEXP, SEXP YSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    rcpp_result_gen = Rcpp::wrap(fastPairDist(X, Y));
-    return rcpp_result_gen;
-END_RCPP
-}
-// gaussKernel
-arma::mat gaussKernel(arma::mat& D, double theta);
-RcppExport SEXP _AlphaSimR_gaussKernel(SEXP DSEXP, SEXP thetaSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type D(DSEXP);
-    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
-    rcpp_result_gen = Rcpp::wrap(gaussKernel(D, theta));
-    return rcpp_result_gen;
-END_RCPP
-}
-// writeASGenotypes
-void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP _AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
-END_RCPP
-}
-// writeASHaplotypes
-void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP _AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
-END_RCPP
-}
 // getGeno
 arma::Mat<unsigned char> getGeno(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
 RcppExport SEXP _AlphaSimR_getGeno(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
@@ -598,6 +342,262 @@ BEGIN_RCPP
     return R_NilValue;
 END_RCPP
 }
+// readMat
+arma::mat readMat(std::string fileName, int rows, int cols, char sep, int skipRows, int skipCols);
+RcppExport SEXP _AlphaSimR_readMat(SEXP fileNameSEXP, SEXP rowsSEXP, SEXP colsSEXP, SEXP sepSEXP, SEXP skipRowsSEXP, SEXP skipColsSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< std::string >::type fileName(fileNameSEXP);
+    Rcpp::traits::input_parameter< int >::type rows(rowsSEXP);
+    Rcpp::traits::input_parameter< int >::type cols(colsSEXP);
+    Rcpp::traits::input_parameter< char >::type sep(sepSEXP);
+    Rcpp::traits::input_parameter< int >::type skipRows(skipRowsSEXP);
+    Rcpp::traits::input_parameter< int >::type skipCols(skipColsSEXP);
+    rcpp_result_gen = Rcpp::wrap(readMat(fileName, rows, cols, sep, skipRows, skipCols));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveUVM
+Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
+RcppExport SEXP _AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveRRBLUP
+Rcpp::List solveRRBLUP(const arma::mat& y, const arma::mat& X, const arma::mat& M);
+RcppExport SEXP _AlphaSimR_solveRRBLUP(SEXP ySEXP, SEXP XSEXP, SEXP MSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type M(MSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveRRBLUP(y, X, M));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMVM
+Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol, int maxIter);
+RcppExport SEXP _AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveRRBLUPMV
+Rcpp::List solveRRBLUPMV(const arma::mat& Y, const arma::mat& X, const arma::mat& M, double tol, int maxIter);
+RcppExport SEXP _AlphaSimR_solveRRBLUPMV(SEXP YSEXP, SEXP XSEXP, SEXP MSEXP, SEXP tolSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type M(MSEXP);
+    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveRRBLUPMV(Y, X, M, tol, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMKM
+Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist, int maxIter);
+RcppExport SEXP _AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveRRBLUPMK
+Rcpp::List solveRRBLUPMK(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Mlist, int maxIter);
+RcppExport SEXP _AlphaSimR_solveRRBLUPMK(SEXP ySEXP, SEXP XSEXP, SEXP MlistSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Mlist(MlistSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveRRBLUPMK(y, X, Mlist, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP
+Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip);
+RcppExport SEXP _AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker, skip));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_D
+Rcpp::List callRRBLUP_D(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip);
+RcppExport SEXP _AlphaSimR_callRRBLUP_D(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_D(y, x, reps, genoTrain, nMarker, skip));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_MV
+Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip, int maxIter);
+RcppExport SEXP _AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker, skip, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_GCA
+Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker, int skip, int maxIter);
+RcppExport SEXP _AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_SCA
+Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker, int skip, int maxIter);
+RcppExport SEXP _AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcG
+arma::mat calcG(arma::mat X);
+RcppExport SEXP _AlphaSimR_calcG(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcG(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcD
+arma::mat calcD(arma::mat X);
+RcppExport SEXP _AlphaSimR_calcD(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcD(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcGIbs
+arma::mat calcGIbs(arma::mat X);
+RcppExport SEXP _AlphaSimR_calcGIbs(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcGIbs(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// fastDist
+arma::mat fastDist(const arma::mat& X);
+RcppExport SEXP _AlphaSimR_fastDist(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(fastDist(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// fastPairDist
+arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y);
+RcppExport SEXP _AlphaSimR_fastPairDist(SEXP XSEXP, SEXP YSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    rcpp_result_gen = Rcpp::wrap(fastPairDist(X, Y));
+    return rcpp_result_gen;
+END_RCPP
+}
+// gaussKernel
+arma::mat gaussKernel(arma::mat& D, double theta);
+RcppExport SEXP _AlphaSimR_gaussKernel(SEXP DSEXP, SEXP thetaSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type D(DSEXP);
+    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
+    rcpp_result_gen = Rcpp::wrap(gaussKernel(D, theta));
+    return rcpp_result_gen;
+END_RCPP
+}
 // packHaplo
 arma::Cube<unsigned char> packHaplo(arma::Mat<unsigned char>& haplo, arma::uword ploidy, bool inbred);
 RcppExport SEXP _AlphaSimR_packHaplo(SEXP haploSEXP, SEXP ploidySEXP, SEXP inbredSEXP) {

---FILE: vignettes/BasicAnimal.Rmd---
@@ -2,13 +2,18 @@
 title: ""Basic Animal Simulation""
 author: ""Chris Gaynor""
 date: ""`r Sys.Date()`""
-output: rmarkdown::html_vignette
+output: pdf_document
+bibliography: bibliography.bib
 vignette: >
   %\VignetteIndexEntry{Basic Animal}
   %\VignetteEngine{knitr::rmarkdown}
   %\VignetteEncoding{UTF-8}
 ---
 
+This document provides
+
+[-@Jenko15]
+
 ```r
 # Basic animal breeding simulation
 # Based on ""historical breeding"" portion of Jenko et al., 2015
@@ -37,3 +42,5 @@ plot(0:20,popMean,type=""l"",xlab=""Generation"",ylab=""GV"",main=""Genetic Gain"")
 plot(0:20,popVar,type=""l"",xlab=""Generation"",ylab=""GV"",main=""Genetic Variance"")
 ```
 
+# References
+

---FILE: vignettes/GenomicSelection.Rmd---
@@ -2,22 +2,25 @@
 title: ""Genomic Selection""
 author: ""Chris Gaynor""
 date: ""`r Sys.Date()`""
-output: rmarkdown::html_vignette
+output: pdf_document
+bibliography: bibliography.bib
 vignette: >
   %\VignetteIndexEntry{Genomic Selection}
   %\VignetteEngine{knitr::rmarkdown}
   %\VignetteEncoding{UTF-8}
 ---
 
+[@Massman13]
+[@sommer]
+[@EMMREML]
+
 ```r
 library(AlphaSimR)
 FOUNDERPOP = runMacs(nInd=100,nChr=10,segSites=1200,
                      inbred=FALSE,species=""TEST"")
-rm(macsPath)
 SIMPARAM = createSimulation(FOUNDERPOP,maxQtl=200,maxSnp=1000,gender=""yes_sys"")
 SIMPARAM = addTraitA(FOUNDERPOP,nQtlPerChr=100,meanG=0,varG=1)
 SIMPARAM = addSnpChip(1000)
-
 pop = newPop(FOUNDERPOP)
 unlink(""GS"",recursive=TRUE)
 dir.create(""GS"")
@@ -32,5 +35,8 @@ gsModel = RRBLUP(""GS"",1,use=""GV"")
 pop = setEBV(pop,gsModel)
 cor(pop@gv[,1],pop@ebv[,1])
 #Select on EBV
-bestInd = selectInd(pop,10,use=""ebv"")
-```
\ No newline at end of file
+best = selectInd(pop,10,use=""ebv"")
+meanG(best)-meanG(pop)
+```
+
+# References
\ No newline at end of file

---FILE: vignettes/Maize.Rmd---
@@ -0,0 +1,22 @@
+---
+title: ""Maize Breeding Simulation""
+author: ""Chris Gaynor""
+date: ""`r Sys.Date()`""
+output: pdf_document
+bibliography: bibliography.bib
+vignette: >
+  %\VignetteIndexEntry{Maize}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+
+This document provides
+
+[@Troyer09]
+[@BernardoBook]
+
+```r
+
+```
+
+# References

---FILE: vignettes/Wheat.Rmd---
@@ -0,0 +1,21 @@
+---
+title: ""Wheat Breeding Simulation""
+author: ""Chris Gaynor""
+date: ""`r Sys.Date()`""
+output: pdf_document
+bibliography: bibliography.bib
+vignette: >
+  %\VignetteIndexEntry{Wheat}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+
+This document provides
+
+[-@Gaynor17]
+
+```r
+
+```
+
+# References

---FILE: vignettes/bibliography.bib---
@@ -0,0 +1,89 @@
+@article{MaCS,
+   author = {Gary K. Chen and Paul Marjoram and Jeffery D. Wall},
+   title = {Fast and Flexible Simulation of DNA Sequence Data},
+   journal = {Genome Research},
+   volume = {19},
+   pages = {136-142},
+   year = {2009},
+   URL ={http://genome.cshlp.org/content/19/1/136}
+}
+
+@article{Troyer09,
+   author = {A. Forrest Troyer and Eric J. Wellin},
+   title = {Heterosis Decreasing in Hybrids: Yield Test Inbreds},
+   journal = {Crop Science},
+   volume = {49},
+   number = {6},
+   pages = {1969-1976},
+   year = {2009},
+   URL ={https://doi.org/10.2135/cropsci2009.04.0170}
+}
+
+@article{Massman13,
+   author = {Jon M. Massman and Andres Gordillo and Robenzon E. Lorenzana and Rex Bernardo},
+   title = {Genomewide Predictions from Maize Single-Cross Data},
+   journal = {Theoretical and Applied Genetics},
+   volume = {126},
+   number = {1},
+   pages = {12-22},
+   year = {2013},
+   URL ={https://doi.org/10.1007/s00122-012-1955-y}
+}
+
+@article{Jenko15,
+   author = {Janez Jenko and Gregor Gorjanc and Matthew A. Cleveland and Rajeev K. Varshney and C. Bruce A. Whitelaw and John A. Woolliams and John M. Hickey},
+   title = {Potential of Promotion of Alleles by Genome Editing to Improve Quantitative Traits in Livestock Breeding Programs},
+   journal = {Genetics Selection Evolution},
+   volume = {47},
+   number = {55},
+   year = {2015},
+   URL ={https://doi.org/10.1186/s12711-015-0135-3}
+}
+
+@article{AlphaSim,
+   author = {Anne-Michelle Faux and Gregor Gorjanc and R. Chris Gaynor and Mara Battagin and Stefan M. Edwards and David L. Wilson and Sarah J. Hearne and Serap Gonen and John M. Hickey},
+   title = {AlphaSim: Software for Breeding Program Simulation},
+   journal = {The Plant Genome},
+   volume = {9},
+   number = {3},
+   year = {2016},
+   URL ={https://doi.org/10.3835/plantgenome2016.02.0013}
+}
+
+@article{Gaynor17,
+   author = {R. Chris Gaynor and Gregor Gorjanc and Alison R. Bentley and Eric S. Ober and Phil Howell and Robert Jackson and Ian J. Mackay and John M. Hickey},
+   title = {A Two-Part Strategy for Using Genomic Selection to Develop Inbred Lines},
+   journal = {Crop Science},
+   volume = {57},
+   number = {5},
+   pages = {2372-2386},
+   year = {2017},
+   URL ={https://doi.org/10.2135/cropsci2016.09.0742}
+}
+
+@manual{EMMREML,
+    title = {EMMREML: Fitting Mixed Models with Known Covariance Structures},
+    author = {Deniz Akdemir and Okeke Uche Godfrey},
+    year = {2015},
+    note = {R package version 3.1},
+    url = {https://CRAN.R-project.org/package=EMMREML},
+}
+
+@article{sommer,
+    title = {Genome assisted prediction of quantitative traits using the R package sommer},
+    author = {Giovanny Covarrubias-Pazaran},
+    journal = {PLoS ONE},
+    year = {2016},
+    volume = {11},
+    pages = {1-15},
+    url = {https://doi.org/10.1371/journal.pone.0156744}
+}
+
+@book{BernardoBook,
+    title = {Essentials of Plant Breeding},
+    author = {Rex Bernardo},
+    year = {2014},
+    publisher = {Stemma Press},
+    address = {Woodsbury, MN},
+    ISBN = {978-0-9720724-2-7}
+}
\ No newline at end of file

---FILE: vignettes/introduction.Rmd---
@@ -2,15 +2,16 @@
 title: ""Introduction to AlphaSimR""
 author: ""Chris Gaynor""
 date: ""`r Sys.Date()`""
-output: rmarkdown::html_vignette
+output: pdf_document
+bibliography: bibliography.bib
 vignette: >
   %\VignetteIndexEntry{Introduction}
   %\VignetteEngine{knitr::rmarkdown}
   %\VignetteEncoding{UTF-8}
 ---
 
 
-The AlphaSimR package provides a framework for simulating plant and animal breeding programs in R. It is based on the [AlphaSim](https://dl.sciencesocieties.org/publications/tpg/abstracts/9/3/plantgenome2016.02.0013) program. This document will introduce the basic steps for running a simulation in AlphaSimR.
+The AlphaSimR package provides a framework for simulating plant and animal breeding programs in R. It is based on the AlphaSim program [@AlphaSim]. This document will introduce the basic steps for running a simulation in AlphaSimR.
 
 The basic steps of an AlphaSimR simulation are:
 
@@ -20,37 +21,37 @@ The basic steps of an AlphaSimR simulation are:
 
 3. Add traits using `addTraitA` or any other addTrait function
 
-4. Optionally, add SNP chips using `addSnpChip`
+4. Add SNP chips using `addSnpChip` (optional)
 
 5. Create one or more initial populations using `newPop`
 
 6. Perform a mix of crossing and selection to simulate a breeding program
 
-### Creating founder haplotypes
+# Creating Founder Haplotypes
 
-The first step to a simulation in AlphaSimR is to create a set of founder haplotypes. This is done using the `runMacs` function which uses a built in version of the [MaCS](https://github.com/gchen98/macs) program. The `runMacs` function allows for simulation of haplotypes using several predefined species histories or can be used to run a custom population using MaCS command line arguements. 
+The first step in an AlphaSimR simulation is to create a set of founder haplotypes. To do this, run the function `runMacs`. The `runMacs` function uses a built in version of the MaCS program [@MaCS]. The `runMacs` function allows for simulation of haplotypes using several predefined species histories or can be used to create a custom population using MaCS command line arguments. 
 
-### Setting simulation parameters
+# Setting Simulation Parameters
 
-Parameters for a simulation are stored in an object of `SimParam-class`. This object is created by calling the function `createSimulation`. The `SimParam-class` is a container for global parameters that will be used by many functions in AlphaSimR. To avoid specifying a `SimParam-class` in all functions that use one, it is recommended that you give your `SimParam-class` the name `SIMPARAM`. All functions that take a `SimParam-class` as an arguement will search your global environment for an object called `SIMPARAM` if the argument is `NULL`.
+Parameters for a simulation are stored in an object of `SimParam-class`. The function `createSimulation` creates this object. The `SimParam-class` is a container for global parameters that will be used by many functions in AlphaSimR. To avoid specifying a `SimParam-class` in all functions that use one, it is recommended that you give your `SimParam-class` the name `SIMPARAM`. All functions that take a `SimParam-class` as an arguement will search your global environment for an object called `SIMPARAM` if the argument is `NULL`.
 
-### Adding traits
+# Adding Traits
 
-Traits are added to the simulation using one of the fullowing functions: `addTraitA`, `addTraitAD`, `addTraitAG`, or `addTraitADG`. These functions can be called multiple times to run simulations with multiple traits. These functions can also be used to simulate correlated pleiotropic traits. Simulation without any traits are possible as long as you don't use a selection function.
+Traits are added to the simulation using one of the fullowing functions: `addTraitA`, `addTraitAD`, `addTraitAG`, or `addTraitADG`. These functions can be called multiple times to run simulations with multiple traits. These functions can also be used to simulate correlated pleiotropic traits. Simulations without any traits are possible as long as you don't use a selection function.
 
-### Adding SNP chips
+# Adding SNP Chips
 
 SNP chips are added to the simulation using the `addSnpChip` or `addStructuredSnpChips` functions. As with traits, these functions can be called multiple times to assign multiple SNP chips. SNP chips are not necessary for a simulation, so this step can be skipped.
 
-### Creating a population
+# Creating a Population
 
-The main objects in an AlphaSimR simulation are `Pop-class` objects. These objects represent a population which contains one or more individuals. Many AlphaSimR functions use a `Pop-class` object as an argument and return a `Pop-class` object as a result.
+The main objects in an AlphaSimR simulation are `Pop-class` objects. These objects represent a population that contains one or more individuals. Many AlphaSimR functions use a `Pop-class` object as an argument and return a `Pop-class` object as a result.
 
 To create your first `Pop-class` object use the function `newPop`. This function should only be called after you have finished all of the above steps.
 
-### Working with populations
+# Working with Populations
 
-Below are some functions for operations carried out on populations.
+Listed below are some functions for carrying out operations on populations.
 
 * Viewing genotypes: `pullSnpGeno`, `pullSnpHaplo`, `pullQtlGeno`, `pullQtlHaplo`, `pullSegSitHaplo`
 
@@ -64,3 +65,5 @@ Below are some functions for operations carried out on populations.
 `self`, `makeDH`
 
 * Genomic selection: `writeRecords`, `setEBV`
+
+# References
\ No newline at end of file"
gaynorr,AlphaSimR,4be61702386f357806b402945b7eaa857d33d511,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-11-23T13:02:08Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-11-23T13:02:08Z,Fixed AlphaSim link,inst/doc/introduction.Rmd;inst/doc/introduction.html;src/init.c;vignettes/introduction.Rmd,True,False,True,False,62,56,118,"---FILE: inst/doc/introduction.Rmd---
@@ -10,7 +10,7 @@ vignette: >
 ---
 
 
-The AlphaSimR package provides a framework for simulating plant and animal breeding programs in R. It is based on the [AlphaSim](https://dl.sciencesocieties.org/publications/tpg/articles/0/0/plantgenome2016.02.0013) program. This document will introduce the basic steps for running a simulation in AlphaSimR.
+The AlphaSimR package provides a framework for simulating plant and animal breeding programs in R. It is based on the [AlphaSim](https://dl.sciencesocieties.org/publications/tpg/abstracts/9/3/plantgenome2016.02.0013) program. This document will introduce the basic steps for running a simulation in AlphaSimR.
 
 The basic steps of an AlphaSimR simulation are:
 

---FILE: inst/doc/introduction.html---
@@ -218,7 +218,7 @@ <h4 class=""date""><em>2017-11-22</em></h4>
 
 
 
-<p>The AlphaSimR package provides a framework for simulating plant and animal breeding programs in R. It is based on the <a href=""https://dl.sciencesocieties.org/publications/tpg/articles/0/0/plantgenome2016.02.0013"">AlphaSim</a> program. This document will introduce the basic steps for running a simulation in AlphaSimR.</p>
+<p>The AlphaSimR package provides a framework for simulating plant and animal breeding programs in R. It is based on the <a href=""https://dl.sciencesocieties.org/publications/tpg/abstracts/9/3/plantgenome2016.02.0013"">AlphaSim</a> program. This document will introduce the basic steps for running a simulation in AlphaSimR.</p>
 <p>The basic steps of an AlphaSimR simulation are:</p>
 <ol type=""1"">
 <li><p>Create founder haplotypes using <code>runMacs</code></p></li>

---FILE: src/init.c---
@@ -1,8 +1,13 @@
 #include <R.h>
 #include <Rinternals.h>
-#include <stdlib.h>
+#include <stdlib.h> // for NULL
 #include <R_ext/Rdynload.h>
 
+/* FIXME: 
+   Check these declarations against the C/Fortran source code.
+*/
+
+/* .Call calls */
 extern SEXP _AlphaSimR_calcChrFreq(SEXP);
 extern SEXP _AlphaSimR_calcD(SEXP);
 extern SEXP _AlphaSimR_calcG(SEXP);
@@ -53,58 +58,59 @@ extern SEXP _AlphaSimR_writeOneHaplo(SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP _AlphaSimR_zero();
 
 static const R_CallMethodDef CallEntries[] = {
-  {""AlphaSimR_calcChrFreq"",       (DL_FUNC) &_AlphaSimR_calcChrFreq,       1},
-  {""AlphaSimR_calcD"",             (DL_FUNC) &_AlphaSimR_calcD,             1},
-  {""AlphaSimR_calcG"",             (DL_FUNC) &_AlphaSimR_calcG,             1},
-  {""AlphaSimR_calcGenParam"",      (DL_FUNC) &_AlphaSimR_calcGenParam,      2},
-  {""AlphaSimR_calcGIbs"",          (DL_FUNC) &_AlphaSimR_calcGIbs,          1},
-  {""AlphaSimR_callRRBLUP"",        (DL_FUNC) &_AlphaSimR_callRRBLUP,        6},
-  {""AlphaSimR_callRRBLUP_D"",      (DL_FUNC) &_AlphaSimR_callRRBLUP_D,      6},
-  {""AlphaSimR_callRRBLUP_GCA"",    (DL_FUNC) &_AlphaSimR_callRRBLUP_GCA,    8},
-  {""AlphaSimR_callRRBLUP_MV"",     (DL_FUNC) &_AlphaSimR_callRRBLUP_MV,     7},
-  {""AlphaSimR_callRRBLUP_SCA"",    (DL_FUNC) &_AlphaSimR_callRRBLUP_SCA,    8},
-  {""AlphaSimR_changeId"",          (DL_FUNC) &_AlphaSimR_changeId,          2},
-  {""AlphaSimR_convToImat"",        (DL_FUNC) &_AlphaSimR_convToImat,        1},
-  {""AlphaSimR_createDH2"",         (DL_FUNC) &_AlphaSimR_createDH2,         5},
-  {""AlphaSimR_cross2"",            (DL_FUNC) &_AlphaSimR_cross2,            6},
-  {""AlphaSimR_crossPedigree"",     (DL_FUNC) &_AlphaSimR_crossPedigree,     4},
-  {""AlphaSimR_fastDist"",          (DL_FUNC) &_AlphaSimR_fastDist,          1},
-  {""AlphaSimR_fastPairDist"",      (DL_FUNC) &_AlphaSimR_fastPairDist,      2},
-  {""AlphaSimR_gaussKernel"",       (DL_FUNC) &_AlphaSimR_gaussKernel,       2},
-  {""AlphaSimR_gebvGCA"",           (DL_FUNC) &_AlphaSimR_gebvGCA,           4},
-  {""AlphaSimR_gebvRR"",            (DL_FUNC) &_AlphaSimR_gebvRR,            2},
-  {""AlphaSimR_gebvRRD"",           (DL_FUNC) &_AlphaSimR_gebvRRD,           2},
-  {""AlphaSimR_gebvSCA"",           (DL_FUNC) &_AlphaSimR_gebvSCA,           3},
-  {""AlphaSimR_getDomGeno"",        (DL_FUNC) &_AlphaSimR_getDomGeno,        1},
-  {""AlphaSimR_getGeno"",           (DL_FUNC) &_AlphaSimR_getGeno,           3},
-  {""AlphaSimR_getGv"",             (DL_FUNC) &_AlphaSimR_getGv,             2},
-  {""AlphaSimR_getHaplo"",          (DL_FUNC) &_AlphaSimR_getHaplo,          3},
-  {""AlphaSimR_getHybridGv"",       (DL_FUNC) &_AlphaSimR_getHybridGv,       5},
-  {""AlphaSimR_getOneHaplo"",       (DL_FUNC) &_AlphaSimR_getOneHaplo,       4},
-  {""AlphaSimR_MaCS"",              (DL_FUNC) &_AlphaSimR_MaCS,              2},
-  {""AlphaSimR_mergeGeno"",         (DL_FUNC) &_AlphaSimR_mergeGeno,         2},
-  {""AlphaSimR_packHaplo"",         (DL_FUNC) &_AlphaSimR_packHaplo,         3},
-  {""AlphaSimR_popVar"",            (DL_FUNC) &_AlphaSimR_popVar,            1},
-  {""AlphaSimR_readMat"",           (DL_FUNC) &_AlphaSimR_readMat,           6},
-  {""AlphaSimR_sampAllComb"",       (DL_FUNC) &_AlphaSimR_sampAllComb,       3},
-  {""AlphaSimR_sampHalfDialComb"",  (DL_FUNC) &_AlphaSimR_sampHalfDialComb,  2},
-  {""AlphaSimR_solveMKM"",          (DL_FUNC) &_AlphaSimR_solveMKM,          5},
-  {""AlphaSimR_solveMVM"",          (DL_FUNC) &_AlphaSimR_solveMVM,          6},
-  {""AlphaSimR_solveRRBLUP"",       (DL_FUNC) &_AlphaSimR_solveRRBLUP,       3},
-  {""AlphaSimR_solveRRBLUPMK"",     (DL_FUNC) &_AlphaSimR_solveRRBLUPMK,     4},
-  {""AlphaSimR_solveRRBLUPMV"",     (DL_FUNC) &_AlphaSimR_solveRRBLUPMV,     5},
-  {""AlphaSimR_solveUVM"",          (DL_FUNC) &_AlphaSimR_solveUVM,          4},
-  {""AlphaSimR_tuneTraitA"",        (DL_FUNC) &_AlphaSimR_tuneTraitA,        3},
-  {""AlphaSimR_tuneTraitAD"",       (DL_FUNC) &_AlphaSimR_tuneTraitAD,       5},
-  {""AlphaSimR_writeASGenotypes"",  (DL_FUNC) &_AlphaSimR_writeASGenotypes,  7},
-  {""AlphaSimR_writeASHaplotypes"", (DL_FUNC) &_AlphaSimR_writeASHaplotypes, 7},
-  {""AlphaSimR_writeGeno"",         (DL_FUNC) &_AlphaSimR_writeGeno,         4},
-  {""AlphaSimR_writeOneHaplo"",     (DL_FUNC) &_AlphaSimR_writeOneHaplo,     5},
-  {""AlphaSimR_zero"",              (DL_FUNC) &_AlphaSimR_zero,              0},
-  {NULL, NULL, 0}
+    {""_AlphaSimR_calcChrFreq"",       (DL_FUNC) &_AlphaSimR_calcChrFreq,       1},
+    {""_AlphaSimR_calcD"",             (DL_FUNC) &_AlphaSimR_calcD,             1},
+    {""_AlphaSimR_calcG"",             (DL_FUNC) &_AlphaSimR_calcG,             1},
+    {""_AlphaSimR_calcGenParam"",      (DL_FUNC) &_AlphaSimR_calcGenParam,      2},
+    {""_AlphaSimR_calcGIbs"",          (DL_FUNC) &_AlphaSimR_calcGIbs,          1},
+    {""_AlphaSimR_callRRBLUP"",        (DL_FUNC) &_AlphaSimR_callRRBLUP,        6},
+    {""_AlphaSimR_callRRBLUP_D"",      (DL_FUNC) &_AlphaSimR_callRRBLUP_D,      6},
+    {""_AlphaSimR_callRRBLUP_GCA"",    (DL_FUNC) &_AlphaSimR_callRRBLUP_GCA,    8},
+    {""_AlphaSimR_callRRBLUP_MV"",     (DL_FUNC) &_AlphaSimR_callRRBLUP_MV,     7},
+    {""_AlphaSimR_callRRBLUP_SCA"",    (DL_FUNC) &_AlphaSimR_callRRBLUP_SCA,    8},
+    {""_AlphaSimR_changeId"",          (DL_FUNC) &_AlphaSimR_changeId,          2},
+    {""_AlphaSimR_convToImat"",        (DL_FUNC) &_AlphaSimR_convToImat,        1},
+    {""_AlphaSimR_createDH2"",         (DL_FUNC) &_AlphaSimR_createDH2,         5},
+    {""_AlphaSimR_cross2"",            (DL_FUNC) &_AlphaSimR_cross2,            6},
+    {""_AlphaSimR_crossPedigree"",     (DL_FUNC) &_AlphaSimR_crossPedigree,     4},
+    {""_AlphaSimR_fastDist"",          (DL_FUNC) &_AlphaSimR_fastDist,          1},
+    {""_AlphaSimR_fastPairDist"",      (DL_FUNC) &_AlphaSimR_fastPairDist,      2},
+    {""_AlphaSimR_gaussKernel"",       (DL_FUNC) &_AlphaSimR_gaussKernel,       2},
+    {""_AlphaSimR_gebvGCA"",           (DL_FUNC) &_AlphaSimR_gebvGCA,           4},
+    {""_AlphaSimR_gebvRR"",            (DL_FUNC) &_AlphaSimR_gebvRR,            2},
+    {""_AlphaSimR_gebvRRD"",           (DL_FUNC) &_AlphaSimR_gebvRRD,           2},
+    {""_AlphaSimR_gebvSCA"",           (DL_FUNC) &_AlphaSimR_gebvSCA,           3},
+    {""_AlphaSimR_getDomGeno"",        (DL_FUNC) &_AlphaSimR_getDomGeno,        1},
+    {""_AlphaSimR_getGeno"",           (DL_FUNC) &_AlphaSimR_getGeno,           3},
+    {""_AlphaSimR_getGv"",             (DL_FUNC) &_AlphaSimR_getGv,             2},
+    {""_AlphaSimR_getHaplo"",          (DL_FUNC) &_AlphaSimR_getHaplo,          3},
+    {""_AlphaSimR_getHybridGv"",       (DL_FUNC) &_AlphaSimR_getHybridGv,       5},
+    {""_AlphaSimR_getOneHaplo"",       (DL_FUNC) &_AlphaSimR_getOneHaplo,       4},
+    {""_AlphaSimR_MaCS"",              (DL_FUNC) &_AlphaSimR_MaCS,              2},
+    {""_AlphaSimR_mergeGeno"",         (DL_FUNC) &_AlphaSimR_mergeGeno,         2},
+    {""_AlphaSimR_packHaplo"",         (DL_FUNC) &_AlphaSimR_packHaplo,         3},
+    {""_AlphaSimR_popVar"",            (DL_FUNC) &_AlphaSimR_popVar,            1},
+    {""_AlphaSimR_readMat"",           (DL_FUNC) &_AlphaSimR_readMat,           6},
+    {""_AlphaSimR_sampAllComb"",       (DL_FUNC) &_AlphaSimR_sampAllComb,       3},
+    {""_AlphaSimR_sampHalfDialComb"",  (DL_FUNC) &_AlphaSimR_sampHalfDialComb,  2},
+    {""_AlphaSimR_solveMKM"",          (DL_FUNC) &_AlphaSimR_solveMKM,          5},
+    {""_AlphaSimR_solveMVM"",          (DL_FUNC) &_AlphaSimR_solveMVM,          6},
+    {""_AlphaSimR_solveRRBLUP"",       (DL_FUNC) &_AlphaSimR_solveRRBLUP,       3},
+    {""_AlphaSimR_solveRRBLUPMK"",     (DL_FUNC) &_AlphaSimR_solveRRBLUPMK,     4},
+    {""_AlphaSimR_solveRRBLUPMV"",     (DL_FUNC) &_AlphaSimR_solveRRBLUPMV,     5},
+    {""_AlphaSimR_solveUVM"",          (DL_FUNC) &_AlphaSimR_solveUVM,          4},
+    {""_AlphaSimR_tuneTraitA"",        (DL_FUNC) &_AlphaSimR_tuneTraitA,        3},
+    {""_AlphaSimR_tuneTraitAD"",       (DL_FUNC) &_AlphaSimR_tuneTraitAD,       5},
+    {""_AlphaSimR_writeASGenotypes"",  (DL_FUNC) &_AlphaSimR_writeASGenotypes,  7},
+    {""_AlphaSimR_writeASHaplotypes"", (DL_FUNC) &_AlphaSimR_writeASHaplotypes, 7},
+    {""_AlphaSimR_writeGeno"",         (DL_FUNC) &_AlphaSimR_writeGeno,         4},
+    {""_AlphaSimR_writeOneHaplo"",     (DL_FUNC) &_AlphaSimR_writeOneHaplo,     5},
+    {""_AlphaSimR_zero"",              (DL_FUNC) &_AlphaSimR_zero,              0},
+    {NULL, NULL, 0}
 };
 
-void R_init_AlphaSimR(DllInfo *dll){
-  R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
-  R_useDynamicSymbols(dll, FALSE);
+void R_init_AlphaSimR(DllInfo *dll)
+{
+    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
+    R_useDynamicSymbols(dll, FALSE);
 }

---FILE: vignettes/introduction.Rmd---
@@ -10,7 +10,7 @@ vignette: >
 ---
 
 
-The AlphaSimR package provides a framework for simulating plant and animal breeding programs in R. It is based on the [AlphaSim](https://dl.sciencesocieties.org/publications/tpg/articles/0/0/plantgenome2016.02.0013) program. This document will introduce the basic steps for running a simulation in AlphaSimR.
+The AlphaSimR package provides a framework for simulating plant and animal breeding programs in R. It is based on the [AlphaSim](https://dl.sciencesocieties.org/publications/tpg/abstracts/9/3/plantgenome2016.02.0013) program. This document will introduce the basic steps for running a simulation in AlphaSimR.
 
 The basic steps of an AlphaSimR simulation are:
 "
gaynorr,AlphaSimR,4bb936bd2fa065b9b3fb9839dd1d202d4d8055e9,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-11-09T11:16:17Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-11-09T11:16:17Z,Fixed bugs in GS changes,R/Class-LociMap.R;R/GS.R;R/RcppExports.R;man/RRBLUP_GCA.Rd;man/RRBLUP_SCA.Rd;man/solveMKM.Rd;man/solveRRBLUPMK.Rd;src/MME.cpp;src/RcppExports.cpp,False,True,True,False,389,389,778,"---FILE: R/Class-LociMap.R---
@@ -161,7 +161,7 @@ setClass(""RRsol"",
                  Vu=""numeric"",
                  Ve=""numeric"",
                  LL=""numeric"",
-                 iter=""integer""),
+                 iter=""numeric""),
          contains=""LociMap"")
 
 setValidity(""RRsol"",function(object){
@@ -204,7 +204,7 @@ setClass(""GCAsol"",
                  Vu=""matrix"",
                  Ve=""matrix"",
                  LL=""numeric"",
-                 iter=""integer""),
+                 iter=""numeric""),
          contains=""LociMap"")
 
 setValidity(""GCAsol"",function(object){

---FILE: R/GS.R---
@@ -210,7 +210,7 @@ RRBLUP = function(dir, traits=1, use=""pheno"",
 #'
 #' @export
 RRBLUP_GCA = function(dir, traits=1, use=""pheno"",
-                      skip=0, maxIter=20, simParam=NULL){
+                      skip=0, maxIter=40, simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SIMPARAM"",envir=.GlobalEnv)
   }
@@ -286,7 +286,7 @@ RRBLUP_GCA = function(dir, traits=1, use=""pheno"",
 #'
 #' @export
 RRBLUP_SCA = function(dir, traits=1, use=""pheno"",
-                      skip=0, maxIter=20, onFailGCA=TRUE, 
+                      skip=0, maxIter=40, onFailGCA=TRUE, 
                       simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SIMPARAM"",envir=.GlobalEnv)

---FILE: R/RcppExports.R---
@@ -1,6 +1,14 @@
 # Generated by using Rcpp::compileAttributes() -> do not edit by hand
 # Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393
 
+writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call('AlphaSimR_writeASGenotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
+}
+
+writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call('AlphaSimR_writeASHaplotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
+}
+
 gebvRR <- function(RRsol, pop) {
     .Call('AlphaSimR_gebvRR', PACKAGE = 'AlphaSimR', RRsol, pop)
 }
@@ -13,6 +21,99 @@ gebvSCA <- function(sol, pop, isSCAsol = TRUE) {
     .Call('AlphaSimR_gebvSCA', PACKAGE = 'AlphaSimR', sol, pop, isSCAsol)
 }
 
+getGeno <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+getDomGeno <- function(geno) {
+    .Call('AlphaSimR_getDomGeno', PACKAGE = 'AlphaSimR', geno)
+}
+
+getHaplo <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
+    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
+}
+
+writeGeno <- function(geno, lociPerChr, lociLoc, filePath) {
+    invisible(.Call('AlphaSimR_writeGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, filePath))
+}
+
+writeOneHaplo <- function(geno, lociPerChr, lociLoc, haplo, filePath) {
+    invisible(.Call('AlphaSimR_writeOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo, filePath))
+}
+
+getGv <- function(trait, pop) {
+    .Call('AlphaSimR_getGv', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+calcGenParam <- function(trait, pop) {
+    .Call('AlphaSimR_calcGenParam', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+getHybridGv <- function(trait, motherGeno, mother, fatherGeno, father) {
+    .Call('AlphaSimR_getHybridGv', PACKAGE = 'AlphaSimR', trait, motherGeno, mother, fatherGeno, father)
+}
+
+cross2 <- function(motherGeno, mother, fatherGeno, father, genMaps, recombRatio) {
+    .Call('AlphaSimR_cross2', PACKAGE = 'AlphaSimR', motherGeno, mother, fatherGeno, father, genMaps, recombRatio)
+}
+
+createDH2 <- function(geno, nDH, genMaps, recombRatio, useFemale) {
+    .Call('AlphaSimR_createDH2', PACKAGE = 'AlphaSimR', geno, nDH, genMaps, recombRatio, useFemale)
+}
+
+crossPedigree <- function(founders, mother, father, genMaps) {
+    .Call('AlphaSimR_crossPedigree', PACKAGE = 'AlphaSimR', founders, mother, father, genMaps)
+}
+
+#' @title Population variance
+#' 
+#' @description
+#' Calculates the population variance matrix as 
+#' opposed to the sample variance matrix calculated 
+#' by \code{\link{var}}. i.e. divides by n instead 
+#' of n-1
+#' 
+#' @param X an n by m matrix
+#' 
+#' @return an m by m variance-covariance matrix
+#' 
+#' @export
+popVar <- function(X) {
+    .Call('AlphaSimR_popVar', PACKAGE = 'AlphaSimR', X)
+}
+
+mergeGeno <- function(x, y) {
+    .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
+}
+
+calcChrFreq <- function(geno) {
+    .Call('AlphaSimR_calcChrFreq', PACKAGE = 'AlphaSimR', geno)
+}
+
+convToImat <- function(X) {
+    .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
+}
+
+sampAllComb <- function(nLevel1, nLevel2, n) {
+    .Call('AlphaSimR_sampAllComb', PACKAGE = 'AlphaSimR', nLevel1, nLevel2, n)
+}
+
+sampHalfDialComb <- function(nLevel, n) {
+    .Call('AlphaSimR_sampHalfDialComb', PACKAGE = 'AlphaSimR', nLevel, n)
+}
+
+zero <- function() {
+    .Call('AlphaSimR_zero', PACKAGE = 'AlphaSimR')
+}
+
+changeId <- function(newId, oldId) {
+    invisible(.Call('AlphaSimR_changeId', PACKAGE = 'AlphaSimR', newId, oldId))
+}
+
 #' @title Read Matrix
 #'
 #' @description
@@ -108,7 +209,7 @@ solveRRBLUPMV <- function(Y, X, M, tol = 1e-6, maxIter = 1000L) {
 #' @param maxIter maximum number of iteration
 #'
 #' @export
-solveMKM <- function(y, X, Zlist, Klist, maxIter = 20L) {
+solveMKM <- function(y, X, Zlist, Klist, maxIter = 40L) {
     .Call('AlphaSimR_solveMKM', PACKAGE = 'AlphaSimR', y, X, Zlist, Klist, maxIter)
 }
 
@@ -123,7 +224,7 @@ solveMKM <- function(y, X, Zlist, Klist, maxIter = 20L) {
 #' @param maxIter maximum number of iteration
 #'
 #' @export
-solveRRBLUPMK <- function(y, X, Mlist, maxIter = 20L) {
+solveRRBLUPMK <- function(y, X, Mlist, maxIter = 40L) {
     .Call('AlphaSimR_solveRRBLUPMK', PACKAGE = 'AlphaSimR', y, X, Mlist, maxIter)
 }
 
@@ -222,107 +323,6 @@ gaussKernel <- function(D, theta) {
     .Call('AlphaSimR_gaussKernel', PACKAGE = 'AlphaSimR', D, theta)
 }
 
-writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call('AlphaSimR_writeASGenotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
-}
-
-writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call('AlphaSimR_writeASHaplotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
-}
-
-getGeno <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-getDomGeno <- function(geno) {
-    .Call('AlphaSimR_getDomGeno', PACKAGE = 'AlphaSimR', geno)
-}
-
-getHaplo <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
-    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
-}
-
-writeGeno <- function(geno, lociPerChr, lociLoc, filePath) {
-    invisible(.Call('AlphaSimR_writeGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, filePath))
-}
-
-writeOneHaplo <- function(geno, lociPerChr, lociLoc, haplo, filePath) {
-    invisible(.Call('AlphaSimR_writeOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo, filePath))
-}
-
-getGv <- function(trait, pop) {
-    .Call('AlphaSimR_getGv', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-calcGenParam <- function(trait, pop) {
-    .Call('AlphaSimR_calcGenParam', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-getHybridGv <- function(trait, motherGeno, mother, fatherGeno, father) {
-    .Call('AlphaSimR_getHybridGv', PACKAGE = 'AlphaSimR', trait, motherGeno, mother, fatherGeno, father)
-}
-
-cross2 <- function(motherGeno, mother, fatherGeno, father, genMaps, recombRatio) {
-    .Call('AlphaSimR_cross2', PACKAGE = 'AlphaSimR', motherGeno, mother, fatherGeno, father, genMaps, recombRatio)
-}
-
-createDH2 <- function(geno, nDH, genMaps, recombRatio, useFemale) {
-    .Call('AlphaSimR_createDH2', PACKAGE = 'AlphaSimR', geno, nDH, genMaps, recombRatio, useFemale)
-}
-
-crossPedigree <- function(founders, mother, father, genMaps) {
-    .Call('AlphaSimR_crossPedigree', PACKAGE = 'AlphaSimR', founders, mother, father, genMaps)
-}
-
-#' @title Population variance
-#' 
-#' @description
-#' Calculates the population variance matrix as 
-#' opposed to the sample variance matrix calculated 
-#' by \code{\link{var}}. i.e. divides by n instead 
-#' of n-1
-#' 
-#' @param X an n by m matrix
-#' 
-#' @return an m by m variance-covariance matrix
-#' 
-#' @export
-popVar <- function(X) {
-    .Call('AlphaSimR_popVar', PACKAGE = 'AlphaSimR', X)
-}
-
-mergeGeno <- function(x, y) {
-    .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
-}
-
-calcChrFreq <- function(geno) {
-    .Call('AlphaSimR_calcChrFreq', PACKAGE = 'AlphaSimR', geno)
-}
-
-convToImat <- function(X) {
-    .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
-}
-
-sampAllComb <- function(nLevel1, nLevel2, n) {
-    .Call('AlphaSimR_sampAllComb', PACKAGE = 'AlphaSimR', nLevel1, nLevel2, n)
-}
-
-sampHalfDialComb <- function(nLevel, n) {
-    .Call('AlphaSimR_sampHalfDialComb', PACKAGE = 'AlphaSimR', nLevel, n)
-}
-
-zero <- function() {
-    .Call('AlphaSimR_zero', PACKAGE = 'AlphaSimR')
-}
-
-changeId <- function(newId, oldId) {
-    invisible(.Call('AlphaSimR_changeId', PACKAGE = 'AlphaSimR', newId, oldId))
-}
-
 packHaplo <- function(haplo, ploidy, inbred) {
     .Call('AlphaSimR_packHaplo', PACKAGE = 'AlphaSimR', haplo, ploidy, inbred)
 }

---FILE: man/RRBLUP_GCA.Rd---
@@ -4,7 +4,7 @@
 \alias{RRBLUP_GCA}
 \title{RR-BLUP GCA Model}
 \usage{
-RRBLUP_GCA(dir, traits = 1, use = ""pheno"", skip = 0, maxIter = 20,
+RRBLUP_GCA(dir, traits = 1, use = ""pheno"", skip = 0, maxIter = 40,
   simParam = NULL)
 }
 \arguments{

---FILE: man/RRBLUP_SCA.Rd---
@@ -4,7 +4,7 @@
 \alias{RRBLUP_SCA}
 \title{RR-BLUP SCA Model}
 \usage{
-RRBLUP_SCA(dir, traits = 1, use = ""pheno"", skip = 0, maxIter = 20,
+RRBLUP_SCA(dir, traits = 1, use = ""pheno"", skip = 0, maxIter = 40,
   onFailGCA = TRUE, simParam = NULL)
 }
 \arguments{

---FILE: man/solveMKM.Rd---
@@ -4,7 +4,7 @@
 \alias{solveMKM}
 \title{Solve Multikernel Model}
 \usage{
-solveMKM(y, X, Zlist, Klist, maxIter = 20L)
+solveMKM(y, X, Zlist, Klist, maxIter = 40L)
 }
 \arguments{
 \item{y}{a matrix with n rows and 1 column}

---FILE: man/solveRRBLUPMK.Rd---
@@ -4,7 +4,7 @@
 \alias{solveRRBLUPMK}
 \title{Solve Multikernel RR-BLUP}
 \usage{
-solveRRBLUPMK(y, X, Mlist, maxIter = 20L)
+solveRRBLUPMK(y, X, Mlist, maxIter = 40L)
 }
 \arguments{
 \item{y}{a matrix with n rows and 1 column}

---FILE: src/MME.cpp---
@@ -484,7 +484,7 @@ Rcpp::List solveRRBLUPMV(const arma::mat& Y, const arma::mat& X,
 Rcpp::List solveMKM(arma::mat& y, arma::mat& X,
                      arma::field<arma::mat>& Zlist,
                      arma::field<arma::mat>& Klist,
-                     int maxIter=20){
+                     int maxIter=40){
   double tol = 1e-4;
   int k = Klist.n_elem;
   int n = y.n_rows;
@@ -608,7 +608,7 @@ Rcpp::List solveMKM(arma::mat& y, arma::mat& X,
 // [[Rcpp::export]]
 Rcpp::List solveRRBLUPMK(arma::mat& y, arma::mat& X,
                          arma::field<arma::mat>& Mlist,
-                         int maxIter=20){
+                         int maxIter=40){
   double tol = 1e-4;
   int k = Mlist.n_elem;
   int n = y.n_rows;

---FILE: src/RcppExports.cpp---
@@ -6,304 +6,75 @@
 
 using namespace Rcpp;
 
-// gebvRR
-arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
-RcppExport SEXP AlphaSimR_gebvRR(SEXP RRsolSEXP, SEXP popSEXP) {
+// writeASGenotypes
+void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
 BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type RRsol(RRsolSEXP);
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
-    rcpp_result_gen = Rcpp::wrap(gebvRR(RRsol, pop));
-    return rcpp_result_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
 END_RCPP
 }
-// gebvGCA
-arma::mat gebvGCA(const Rcpp::S4& sol, const Rcpp::S4& pop, bool female, bool isSCAsol);
-RcppExport SEXP AlphaSimR_gebvGCA(SEXP solSEXP, SEXP popSEXP, SEXP femaleSEXP, SEXP isSCAsolSEXP) {
+// writeASHaplotypes
+void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
 BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type sol(solSEXP);
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
-    Rcpp::traits::input_parameter< bool >::type female(femaleSEXP);
-    Rcpp::traits::input_parameter< bool >::type isSCAsol(isSCAsolSEXP);
-    rcpp_result_gen = Rcpp::wrap(gebvGCA(sol, pop, female, isSCAsol));
-    return rcpp_result_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
 END_RCPP
 }
-// gebvSCA
-arma::mat gebvSCA(const Rcpp::S4& sol, const Rcpp::S4& pop, bool isSCAsol);
-RcppExport SEXP AlphaSimR_gebvSCA(SEXP solSEXP, SEXP popSEXP, SEXP isSCAsolSEXP) {
+// gebvRR
+arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
+RcppExport SEXP AlphaSimR_gebvRR(SEXP RRsolSEXP, SEXP popSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type sol(solSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type RRsol(RRsolSEXP);
     Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
-    Rcpp::traits::input_parameter< bool >::type isSCAsol(isSCAsolSEXP);
-    rcpp_result_gen = Rcpp::wrap(gebvSCA(sol, pop, isSCAsol));
-    return rcpp_result_gen;
-END_RCPP
-}
-// readMat
-arma::mat readMat(std::string fileName, int rows, int cols, char sep, int skipRows, int skipCols);
-RcppExport SEXP AlphaSimR_readMat(SEXP fileNameSEXP, SEXP rowsSEXP, SEXP colsSEXP, SEXP sepSEXP, SEXP skipRowsSEXP, SEXP skipColsSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< std::string >::type fileName(fileNameSEXP);
-    Rcpp::traits::input_parameter< int >::type rows(rowsSEXP);
-    Rcpp::traits::input_parameter< int >::type cols(colsSEXP);
-    Rcpp::traits::input_parameter< char >::type sep(sepSEXP);
-    Rcpp::traits::input_parameter< int >::type skipRows(skipRowsSEXP);
-    Rcpp::traits::input_parameter< int >::type skipCols(skipColsSEXP);
-    rcpp_result_gen = Rcpp::wrap(readMat(fileName, rows, cols, sep, skipRows, skipCols));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveUVM
-Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
-RcppExport SEXP AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveRRBLUP
-Rcpp::List solveRRBLUP(const arma::mat& y, const arma::mat& X, const arma::mat& M);
-RcppExport SEXP AlphaSimR_solveRRBLUP(SEXP ySEXP, SEXP XSEXP, SEXP MSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type M(MSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveRRBLUP(y, X, M));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMVM
-Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol, int maxIter);
-RcppExport SEXP AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveRRBLUPMV
-Rcpp::List solveRRBLUPMV(const arma::mat& Y, const arma::mat& X, const arma::mat& M, double tol, int maxIter);
-RcppExport SEXP AlphaSimR_solveRRBLUPMV(SEXP YSEXP, SEXP XSEXP, SEXP MSEXP, SEXP tolSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type M(MSEXP);
-    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveRRBLUPMV(Y, X, M, tol, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMKM
-Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist, int maxIter);
-RcppExport SEXP AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveRRBLUPMK
-Rcpp::List solveRRBLUPMK(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Mlist, int maxIter);
-RcppExport SEXP AlphaSimR_solveRRBLUPMK(SEXP ySEXP, SEXP XSEXP, SEXP MlistSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Mlist(MlistSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveRRBLUPMK(y, X, Mlist, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP
-Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip);
-RcppExport SEXP AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker, skip));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_MV
-Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip, int maxIter);
-RcppExport SEXP AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker, skip, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_GCA
-Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker, int skip, int maxIter);
-RcppExport SEXP AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_SCA
-Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker, int skip, int maxIter);
-RcppExport SEXP AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcG
-arma::mat calcG(arma::mat X);
-RcppExport SEXP AlphaSimR_calcG(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcG(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcGIbs
-arma::mat calcGIbs(arma::mat X);
-RcppExport SEXP AlphaSimR_calcGIbs(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcGIbs(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// fastDist
-arma::mat fastDist(const arma::mat& X);
-RcppExport SEXP AlphaSimR_fastDist(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(fastDist(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// fastPairDist
-arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y);
-RcppExport SEXP AlphaSimR_fastPairDist(SEXP XSEXP, SEXP YSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    rcpp_result_gen = Rcpp::wrap(fastPairDist(X, Y));
+    rcpp_result_gen = Rcpp::wrap(gebvRR(RRsol, pop));
     return rcpp_result_gen;
 END_RCPP
 }
-// gaussKernel
-arma::mat gaussKernel(arma::mat& D, double theta);
-RcppExport SEXP AlphaSimR_gaussKernel(SEXP DSEXP, SEXP thetaSEXP) {
+// gebvGCA
+arma::mat gebvGCA(const Rcpp::S4& sol, const Rcpp::S4& pop, bool female, bool isSCAsol);
+RcppExport SEXP AlphaSimR_gebvGCA(SEXP solSEXP, SEXP popSEXP, SEXP femaleSEXP, SEXP isSCAsolSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type D(DSEXP);
-    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
-    rcpp_result_gen = Rcpp::wrap(gaussKernel(D, theta));
-    return rcpp_result_gen;
-END_RCPP
-}
-// writeASGenotypes
-void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type sol(solSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
+    Rcpp::traits::input_parameter< bool >::type female(femaleSEXP);
+    Rcpp::traits::input_parameter< bool >::type isSCAsol(isSCAsolSEXP);
+    rcpp_result_gen = Rcpp::wrap(gebvGCA(sol, pop, female, isSCAsol));
+    return rcpp_result_gen;
 END_RCPP
 }
-// writeASHaplotypes
-void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+// gebvSCA
+arma::mat gebvSCA(const Rcpp::S4& sol, const Rcpp::S4& pop, bool isSCAsol);
+RcppExport SEXP AlphaSimR_gebvSCA(SEXP solSEXP, SEXP popSEXP, SEXP isSCAsolSEXP) {
 BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type sol(solSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
+    Rcpp::traits::input_parameter< bool >::type isSCAsol(isSCAsolSEXP);
+    rcpp_result_gen = Rcpp::wrap(gebvSCA(sol, pop, isSCAsol));
+    return rcpp_result_gen;
 END_RCPP
 }
 // getGeno
@@ -559,6 +330,235 @@ BEGIN_RCPP
     return R_NilValue;
 END_RCPP
 }
+// readMat
+arma::mat readMat(std::string fileName, int rows, int cols, char sep, int skipRows, int skipCols);
+RcppExport SEXP AlphaSimR_readMat(SEXP fileNameSEXP, SEXP rowsSEXP, SEXP colsSEXP, SEXP sepSEXP, SEXP skipRowsSEXP, SEXP skipColsSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< std::string >::type fileName(fileNameSEXP);
+    Rcpp::traits::input_parameter< int >::type rows(rowsSEXP);
+    Rcpp::traits::input_parameter< int >::type cols(colsSEXP);
+    Rcpp::traits::input_parameter< char >::type sep(sepSEXP);
+    Rcpp::traits::input_parameter< int >::type skipRows(skipRowsSEXP);
+    Rcpp::traits::input_parameter< int >::type skipCols(skipColsSEXP);
+    rcpp_result_gen = Rcpp::wrap(readMat(fileName, rows, cols, sep, skipRows, skipCols));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveUVM
+Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
+RcppExport SEXP AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveRRBLUP
+Rcpp::List solveRRBLUP(const arma::mat& y, const arma::mat& X, const arma::mat& M);
+RcppExport SEXP AlphaSimR_solveRRBLUP(SEXP ySEXP, SEXP XSEXP, SEXP MSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type M(MSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveRRBLUP(y, X, M));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMVM
+Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol, int maxIter);
+RcppExport SEXP AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveRRBLUPMV
+Rcpp::List solveRRBLUPMV(const arma::mat& Y, const arma::mat& X, const arma::mat& M, double tol, int maxIter);
+RcppExport SEXP AlphaSimR_solveRRBLUPMV(SEXP YSEXP, SEXP XSEXP, SEXP MSEXP, SEXP tolSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type M(MSEXP);
+    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveRRBLUPMV(Y, X, M, tol, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMKM
+Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist, int maxIter);
+RcppExport SEXP AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveRRBLUPMK
+Rcpp::List solveRRBLUPMK(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Mlist, int maxIter);
+RcppExport SEXP AlphaSimR_solveRRBLUPMK(SEXP ySEXP, SEXP XSEXP, SEXP MlistSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Mlist(MlistSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveRRBLUPMK(y, X, Mlist, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP
+Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip);
+RcppExport SEXP AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker, skip));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_MV
+Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, int skip, int maxIter);
+RcppExport SEXP AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker, skip, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_GCA
+Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker, int skip, int maxIter);
+RcppExport SEXP AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_SCA
+Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker, int skip, int maxIter);
+RcppExport SEXP AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP, SEXP skipSEXP, SEXP maxIterSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
+    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcG
+arma::mat calcG(arma::mat X);
+RcppExport SEXP AlphaSimR_calcG(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcG(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcGIbs
+arma::mat calcGIbs(arma::mat X);
+RcppExport SEXP AlphaSimR_calcGIbs(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcGIbs(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// fastDist
+arma::mat fastDist(const arma::mat& X);
+RcppExport SEXP AlphaSimR_fastDist(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(fastDist(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// fastPairDist
+arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y);
+RcppExport SEXP AlphaSimR_fastPairDist(SEXP XSEXP, SEXP YSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    rcpp_result_gen = Rcpp::wrap(fastPairDist(X, Y));
+    return rcpp_result_gen;
+END_RCPP
+}
+// gaussKernel
+arma::mat gaussKernel(arma::mat& D, double theta);
+RcppExport SEXP AlphaSimR_gaussKernel(SEXP DSEXP, SEXP thetaSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type D(DSEXP);
+    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
+    rcpp_result_gen = Rcpp::wrap(gaussKernel(D, theta));
+    return rcpp_result_gen;
+END_RCPP
+}
 // packHaplo
 arma::Cube<unsigned char> packHaplo(arma::Mat<unsigned char>& haplo, arma::uword ploidy, bool inbred);
 RcppExport SEXP AlphaSimR_packHaplo(SEXP haploSEXP, SEXP ploidySEXP, SEXP inbredSEXP) {"
gaynorr,AlphaSimR,f815d725814c0af0da77b43bbb2a82391c4d2f19,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-11-08T15:05:23Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-11-08T15:05:23Z,Fixed bug with setEBV gender test,R/GS.R,False,True,True,False,4,2,6,"---FILE: R/GS.R---
@@ -362,12 +362,14 @@ setEBV = function(pop, solution, gender=NULL, append=FALSE){
     }
     
   }else if(class(solution)==""SCAsol""){
-    if(toupper(gender)==""FEMALE""){
+    if(is.null(gender)){
+      ebv = gebvSCA(solution, pop)
+    }else if(toupper(gender)==""FEMALE""){
       ebv = gebvGCA(solution, pop, TRUE, TRUE)
     }else if(toupper(gender)==""MALE""){
       ebv = gebvGCA(solution, pop, FALSE, TRUE)
     }else{
-      ebv = gebvSCA(solution, pop)
+      stop(paste0(""gender="",gender,"" is not a valid option""))
     }
   }else{
     stop(""No method for class(solution)="",class(solution))"
gaynorr,AlphaSimR,d46a708f7e6a1e563737e9b5afa46194a922217a,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-11-06T10:44:34Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-11-06T10:44:34Z,Fixed bug in eigen2,src/MME.cpp,False,False,False,False,2,2,4,"---FILE: src/MME.cpp---
@@ -42,9 +42,9 @@ int eigen2(arma::vec& eigval, arma::mat& eigvec, arma::mat X,
   double tmpWORK;
   long long int LWORK = -1; // To be calculated
   // IWORK length to be determined
-  long long int tmpIWORK;
+  long long int tmpIWORK = 0;
   long long int LIWORK = -1; // To be calculated
-  long long int INFO;
+  long long int INFO = 0;
   // Calculate LWORK and LIWORK
   dsyevr_(&JOBZ,&RANGE,&UPLO,&N,&*X.begin(),&LDA,&VL,&VU,&IL,&IU,&ABSTOL,&M,&*eigval.begin(),
           &*eigvec.begin(),&LDZ,&*ISUPPZ.begin(),&tmpWORK,&LWORK,&tmpIWORK,&LIWORK,&INFO);"
gaynorr,AlphaSimR,9be0d817ba9e00a492adec7b0ded64d999773ace,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-10-09T14:04:39Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-10-09T14:04:39Z,"Fixed rescaleTraits
Preallocated long long int in eigen2",DESCRIPTION;R/createSimulation.R;man/rescaleTraits.Rd;src/MME.cpp,False,True,True,False,11,9,20,"---FILE: DESCRIPTION---
@@ -1,7 +1,7 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 0.3.3
+Version: 0.3.4
 Author: Chris Gaynor, David Wilson, Daniel Money
 Maintainer: Chris Gaynor <gaynor.robert@hotmail.com>
 Description: This package contains classes and functions for simulating plant and animal breeding programs.

---FILE: R/createSimulation.R---
@@ -523,6 +523,7 @@ addTraitADG = function(founderPop,nQtlPerChr,meanG,varG,varEnv,varGE,
 #' @param varG a vector of new trait variances
 #' @param varEnv a vector of new environmental variances
 #' @param varGE a vector of new GxE variances
+#' @param useVarA tune according to additive genetic variance if true
 #' @param simParam an object of \code{\link{SimParam-class}}
 #'
 #' @note
@@ -533,7 +534,7 @@ addTraitADG = function(founderPop,nQtlPerChr,meanG,varG,varEnv,varGE,
 #' 
 #' @export
 rescaleTraits = function(pop,meanG,varG,varEnv=NULL,
-                         varGE=NULL,simParam=NULL){
+                         varGE=NULL,useVarA=FALSE,simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SIMPARAM"",envir=.GlobalEnv)
   }
@@ -556,7 +557,7 @@ rescaleTraits = function(pop,meanG,varG,varEnv=NULL,
                    trait@lociPerChr,
                    trait@lociLoc)
     if(class(trait)%in%c(""TraitAD"",""TraitADG"")){
-      tmp = tuneTraitAD(geno,trait@addEff,trait@domEff,varG[i])
+      tmp = tuneTraitAD(geno,trait@addEff,trait@domEff,varG[i],useVarA)
       trait@domEff = trait@domEff*tmp$parameter
     }else{
       tmp = tuneTraitA(geno,trait@addEff,varG[i])
@@ -599,7 +600,6 @@ newPop = function(rawPop, id=NULL, mother=NULL,
   if(is.null(simParam)){
     simParam = get(""SIMPARAM"",envir=.GlobalEnv)
   }
-  stopifnot(class(rawPop)==""RawPop"" | class(rawPop)==""MapPop"")
   if(is.null(id)){
     lastId = simParam@lastId
     id = (1:rawPop@nInd) + lastId

---FILE: man/rescaleTraits.Rd---
@@ -5,7 +5,7 @@
 \title{Rescale traits}
 \usage{
 rescaleTraits(pop, meanG, varG, varEnv = NULL, varGE = NULL,
-  simParam = NULL)
+  useVarA = FALSE, simParam = NULL)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}}}
@@ -18,6 +18,8 @@ rescaleTraits(pop, meanG, varG, varEnv = NULL, varGE = NULL,
 
 \item{varGE}{a vector of new GxE variances}
 
+\item{useVarA}{tune according to additive genetic variance if true}
+
 \item{simParam}{an object of \code{\link{SimParam-class}}}
 }
 \value{

---FILE: src/MME.cpp---
@@ -30,8 +30,8 @@ int eigen2(arma::vec& eigval, arma::mat& eigvec, arma::mat X,
   long long int LDA = N;
   double VL = 0.0;
   double VU = 0.0;
-  long long int IL;
-  long long int IU;
+  long long int IL = 0;
+  long long int IU = 0;
   double ABSTOL = 0.0;
   long long int M = N;
   // W=eigval
@@ -42,9 +42,9 @@ int eigen2(arma::vec& eigval, arma::mat& eigvec, arma::mat X,
   double tmpWORK;
   long long int LWORK = -1; // To be calculated
   // IWORK length to be determined
-  long long int tmpIWORK;
+  long long int tmpIWORK = 0;
   long long int LIWORK = -1; // To be calculated
-  long long int INFO;
+  long long int INFO = 0;
   // Calculate LWORK and LIWORK
   dsyevr_(&JOBZ,&RANGE,&UPLO,&N,&*X.begin(),&LDA,&VL,&VU,&IL,&IU,&ABSTOL,&M,&*eigval.begin(),
           &*eigvec.begin(),&LDZ,&*ISUPPZ.begin(),&tmpWORK,&LWORK,&tmpIWORK,&LIWORK,&INFO);"
gaynorr,AlphaSimR,5e0a1cc9d497af7666c95ba2ba6503b256712da9,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-09-13T10:48:16Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-09-13T10:48:16Z,Fixed bug depressing recombination rate,DESCRIPTION;src/MME.cpp;src/meiosis.cpp,False,False,False,False,86,3,89,"---FILE: DESCRIPTION---
@@ -1,7 +1,7 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 0.3.0
+Version: 0.3.1
 Author: Chris Gaynor, David Wilson, Daniel Money
 Maintainer: Chris Gaynor <gaynor.robert@hotmail.com>
 Description: This package contains classes and functions for simulating plant and animal breeding programs.

---FILE: src/MME.cpp---
@@ -856,3 +856,87 @@ arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y){
 arma::mat gaussKernel(arma::mat& D, double theta){
   return exp(-1.0*square(D/theta));
 }
+
+// Efficiently solves an animal model with records on all individuals
+Rcpp::List animalModel(const arma::mat& y, 
+                       const arma::mat& X, 
+                       const arma::mat& K){
+  int n = y.n_rows;
+  int q = X.n_cols;
+  double df = double(n)-double(q);
+  double offset = log(double(n));
+  bool invPass;
+  
+  // Construct system of equations for eigendecomposition
+  arma::mat S = arma::eye(n,n) - X*inv_sympd(X.t()*X)*X.t();
+  S = S*(K+offset*arma::eye(n,n))*S;
+  
+  // Compute eigendecomposition
+  arma::vec eigval(n);
+  arma::mat eigvec(n,n);
+  eigen2(eigval, eigvec, S);
+  
+  // Drop eigenvalues
+  eigval = eigval(arma::span(q,eigvec.n_cols-1)) - offset;
+  eigvec = eigvec(arma::span(0,eigvec.n_rows-1),
+                  arma::span(q,eigvec.n_cols-1));
+  
+  // Estimate variances and solve equations
+  arma::vec eta = eigvec.t()*y;
+  Rcpp::List optRes = optimize(*objREML,
+                               Rcpp::List::create(
+                                 Rcpp::Named(""df"")=df,
+                                 Rcpp::Named(""eta"")=eta,
+                                 Rcpp::Named(""lambda"")=eigval), 
+                                 1.0e-10, 1.0e10);
+  double delta = optRes[""parameter""];
+  arma::mat Hinv; 
+  invPass = inv_sympd(Hinv,K+delta*arma::eye(n,n));
+  if(!invPass){
+    Hinv = pinv(K+delta*arma::eye(n,n));
+  }
+  arma::mat XHinv = X.t()*Hinv;
+  arma::mat beta = solve(XHinv*X,XHinv*y);
+  arma::mat u = K.t()*(Hinv*(y-X*beta));
+  double Vu = sum(eta%eta/(eigval+delta))/df;
+  double Ve = delta*Vu;
+  double ll = -0.5*(double(optRes[""objective""])+df+df*log(2*PI/df));
+  return Rcpp::List::create(Rcpp::Named(""Vu"")=Vu,
+                            Rcpp::Named(""Ve"")=Ve,
+                            Rcpp::Named(""beta"")=beta,
+                            Rcpp::Named(""u"")=u,
+                            Rcpp::Named(""LL"")=ll);
+}
+
+// Objective function for Gaussian kernel method
+Rcpp::List objRKHS(double theta, Rcpp::List args){
+  Rcpp::List output;
+  arma::mat D = args[""D""];
+  output = animalModel(args[""y""],args[""X""],
+                       gaussKernel(D,theta));
+  return Rcpp::List::create(Rcpp::Named(""objective"")=output[""LL""],
+                            Rcpp::Named(""output"")=output);
+}
+// 
+// //' @title Solve RKHS
+// //'
+// //' @description
+// //' Solves a Reproducing Kernel Hilbert Space regression
+// //' using a Gaussian Kernel.
+// //'
+// //' @param y a matrix with n rows and 1 column
+// //' @param X a matrix with n rows and x columns
+// //' @param M a matrix with n rows and m columns
+// //'
+// //' @export
+// // [[Rcpp::export]]
+// Rcpp::List solveRKHS(const arma::mat& y, const arma::mat& X,
+//                      const arma::mat& M){
+// 
+// 
+//   return Rcpp::List::create(Rcpp::Named(""Vu"")=Vu,
+//                             Rcpp::Named(""Ve"")=Ve,
+//                             Rcpp::Named(""beta"")=beta,
+//                             Rcpp::Named(""u"")=u,
+//                             Rcpp::Named(""LL"")=ll);
+// }
\ No newline at end of file

---FILE: src/meiosis.cpp---
@@ -89,8 +89,7 @@ arma::Col<unsigned char> bivalent(const arma::Col<unsigned char>& chr1,
       }
       startPos = endPos;
       // Switch chromosome
-      ++readChr;
-      readChr = Rcpp::rbinom(1,1,0.5)(0);
+      readChr = ++readChr % 2;
     }
     // Fill in last segSites if needed
     if(endPos<(nSites-1)){"
gaynorr,AlphaSimR,7f3c243251488dfc70e8fa81ee2bddd10da8856d,David Wilson,david.wilson@roslin.ed.ac.uk,2017-08-24T14:35:35Z,David Wilson,david.wilson@roslin.ed.ac.uk,2017-08-24T14:35:35Z,fixed issue that was throwing assertion error on some compilers,src/Makevars;src/Makevars.win;src/simulator.cpp,False,False,False,False,4,7,11,"---FILE: src/Makevars---
@@ -1,3 +1,3 @@
-PKG_CXXFLAGS=-DARMA_64BIT_WORD
+PKG_CXXFLAGS=-DARMA_64BIT_WORD -DBOOST_DISABLE_ASSERTS
 CXX_STD = CXX11
 PKG_LIBS = $(LAPACK_LIBS) $(BLAS_LIBS) $(FLIBS)

---FILE: src/Makevars.win---
@@ -1,4 +1,4 @@
 
-PKG_CXXFLAGS=-DARMA_64BIT_WORD
+PKG_CXXFLAGS=-DARMA_64BIT_WORD -DBOOST_DISABLE_ASSERTS
 CXX_STD = CXX11
 PKG_LIBS = $(LAPACK_LIBS) $(BLAS_LIBS) $(FLIBS)

---FILE: src/simulator.cpp---
@@ -828,16 +828,13 @@ void Simulator::runFromAlphaSimRParams(int sampleSize, float sequenceLength, dou
                                        vector<float> *migrationRate,
                                        vector<int> lineage) {
   
-  double defaultMigrationRate;
+  // double defaultMigrationRate;
   
   pConfig = new Configuration();
   pConfig->iTotalPops = 1;
-  
-  EventPtrList *pEventList = new EventPtrList;
-  
+    
   double dDefaultMigrationRate = 0.0;
   double dDefaultPopSize = 1.0;
-  double dDefaultGrowthAlpha = 0.0;
   
   for (unsigned int i = 0; i < pConfig->iTotalPops; ++i) {
     vector<double> newRow;"
gaynorr,AlphaSimR,4f209f717569e42be5bc6843e69d1c8fc70b0a61,David Wilson,david.wilson@roslin.ed.ac.uk,2017-08-22T09:09:59Z,David Wilson,david.wilson@roslin.ed.ac.uk,2017-08-22T09:09:59Z,fixed deallocation error,src/simulator.cpp,False,False,False,False,18,7,25,"---FILE: src/simulator.cpp---
@@ -85,7 +85,6 @@ void Simulator::printUsage() {
         ""population i+1.""<<endl;
     Rcpp::Rcout<<""-ej <t> <i> <j> (Join two populations.  At time t ""<<
       ""all chromosomes migrate from pop i to pop j.""<<endl;
-    Rcpp::stop("""");
 }
 
 Configuration::Configuration(){
@@ -105,13 +104,16 @@ Configuration::Configuration(){
   iRandomSeed = time(NULL);
   iIterations = 1;
   pAlleleFreqBinPtrSet = NULL;
+  pEventList = NULL;
 }
 
 Configuration::~Configuration(){
 #ifdef DIAG
   Rcpp::Rcerr<<""Configuration destructor\n"";
 #endif
+  if (pEventList) {
   delete pEventList;
+  }
   if (bSNPAscertainment){
     AlleleFreqBinPtrSet::iterator it;
     for (it=pAlleleFreqBinPtrSet->begin();it!=pAlleleFreqBinPtrSet->end();++it){
@@ -124,7 +126,9 @@ Configuration::~Configuration(){
     for(it=pHotSpotBinPtrList->begin();it!=pHotSpotBinPtrList->end();++it){
       delete(*it);
     }
-    delete pHotSpotBinPtrList;
+    if (pHotSpotBinPtrList) {
+      delete pHotSpotBinPtrList;
+    }
   }
 }
 
@@ -137,13 +141,13 @@ void Simulator::readInputParameters(CommandArguments arguments){
   
   unsigned int iTotalArgs = arguments.size();
   
-  if (iTotalArgs == 0) {
-    Rcpp::stop(""You must enter a value for the sample size and seq length."");
-  } 
+  pConfig=new Configuration();
+
+
   dDefaultPopSize = 1.0;
   dDefaultGrowthAlpha =0.0;
   
-  pConfig=new Configuration();
+  
   pConfig->iTotalPops = 1;
   
   EventPtrList * pEventList = new EventPtrList;
@@ -155,6 +159,10 @@ void Simulator::readInputParameters(CommandArguments arguments){
       newRow.push_back(dDefaultMigrationRate);
     pConfig->dMigrationMatrix.push_back(newRow);
   }
+
+  if (iTotalArgs == 0) {
+    Rcpp::stop(""You must enter a value for the sample size and seq length."");
+  } 
   
   if( arguments[0].size()!=2 ){
     Rcpp::stop(""You must enter a value for the sample size and seq length."");
@@ -171,8 +179,10 @@ void Simulator::readInputParameters(CommandArguments arguments){
   Rcpp::Rcerr<<""INPUT: Sample size is now ""<<pConfig->iSampleSize<<endl;
 #endif
   if( iSampleSize<= 0) {
-    Rcpp::Rcerr<<""First argument error. Sample size needs to be greater than 0.\n"";
     printUsage();
+    Rcpp::stop(""First argument error. Sample size needs to be greater than 0.\n"");
+    
+
   }
   
   pConfig->dSeqLength = atof(arguments[0][1].data());
@@ -214,6 +224,7 @@ void Simulator::readInputParameters(CommandArguments arguments){
           Rcpp::Rcerr<<""For flag ""<<arguments[iCurrentArg][0][1]<<
             "", you must enter a single integer for retaining the number of previous trees\n"";
           Rcpp::stop(""Argument error"");
+          return;
         }
         pConfig->dBasesToTrack = atof(arguments[iCurrentArg][1].data());
 #ifdef DIAG"
gaynorr,AlphaSimR,453b6ea013315908c2aaa23d3c8abba0c1b9ea8a,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-08-21T14:56:51Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-08-21T14:56:51Z,"Can now tune traits by VarA.
Fixes for traits with gamma distributions.",R/Class-Pop.R;R/RcppExports.R;R/createSimulation.R;man/MapPop-class.Rd;man/addTraitA.Rd;man/addTraitAD.Rd;man/addTraitADG.Rd;man/addTraitAG.Rd;src/RcppExports.cpp;src/init.c;src/tuneTraits.cpp,False,True,True,False,387,340,727,"---FILE: R/Class-Pop.R---
@@ -131,15 +131,15 @@ setValidity(""MapPop"",function(object){
   }
 })
 
-#' @describeIn MapPop Extract \code{\link{RawPop-class}} by index
+#' @describeIn MapPop Extract MapPop by index
 setMethod(""["",
           signature(x = ""MapPop""),
           function(x, i){
             for(chr in 1:x@nChr){
               x@geno[[chr]] = x@geno[[chr]][,,i,drop=FALSE]
             }
             x@nInd = dim(x@geno[[1]])[3]
-            class(x) = ""RawPop""
+            class(x) = ""MapPop""
             validObject(x)
             return(x)
           }

---FILE: R/RcppExports.R---
@@ -1,14 +1,6 @@
 # Generated by using Rcpp::compileAttributes() -> do not edit by hand
 # Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393
 
-writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call('AlphaSimR_writeASGenotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
-}
-
-writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call('AlphaSimR_writeASHaplotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
-}
-
 gebvRR <- function(RRsol, pop) {
     .Call('AlphaSimR_gebvRR', PACKAGE = 'AlphaSimR', RRsol, pop)
 }
@@ -21,91 +13,6 @@ gebvSCA <- function(SCAsol, pop) {
     .Call('AlphaSimR_gebvSCA', PACKAGE = 'AlphaSimR', SCAsol, pop)
 }
 
-getGeno <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-getDomGeno <- function(geno) {
-    .Call('AlphaSimR_getDomGeno', PACKAGE = 'AlphaSimR', geno)
-}
-
-getHaplo <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
-    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
-}
-
-getGv <- function(trait, pop) {
-    .Call('AlphaSimR_getGv', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-calcGenParam <- function(trait, pop) {
-    .Call('AlphaSimR_calcGenParam', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-getHybridGv <- function(trait, motherGeno, mother, fatherGeno, father) {
-    .Call('AlphaSimR_getHybridGv', PACKAGE = 'AlphaSimR', trait, motherGeno, mother, fatherGeno, father)
-}
-
-cross2 <- function(motherGeno, mother, fatherGeno, father, genMaps, recombRatio) {
-    .Call('AlphaSimR_cross2', PACKAGE = 'AlphaSimR', motherGeno, mother, fatherGeno, father, genMaps, recombRatio)
-}
-
-createDH2 <- function(geno, nDH, genMaps, recombRatio, useFemale) {
-    .Call('AlphaSimR_createDH2', PACKAGE = 'AlphaSimR', geno, nDH, genMaps, recombRatio, useFemale)
-}
-
-crossPedigree <- function(founders, mother, father, genMaps) {
-    .Call('AlphaSimR_crossPedigree', PACKAGE = 'AlphaSimR', founders, mother, father, genMaps)
-}
-
-#' @title Population variance
-#' 
-#' @description
-#' Calculates the population variance matrix as 
-#' opposed to the sample variance matrix calculated 
-#' by \code{\link{var}}. i.e. divides by n instead 
-#' of n-1
-#' 
-#' @param X an n by m matrix
-#' 
-#' @return an m by m variance-covariance matrix
-#' 
-#' @export
-popVar <- function(X) {
-    .Call('AlphaSimR_popVar', PACKAGE = 'AlphaSimR', X)
-}
-
-mergeGeno <- function(x, y) {
-    .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
-}
-
-calcChrFreq <- function(geno) {
-    .Call('AlphaSimR_calcChrFreq', PACKAGE = 'AlphaSimR', geno)
-}
-
-convToImat <- function(X) {
-    .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
-}
-
-sampAllComb <- function(nLevel1, nLevel2, n) {
-    .Call('AlphaSimR_sampAllComb', PACKAGE = 'AlphaSimR', nLevel1, nLevel2, n)
-}
-
-sampHalfDialComb <- function(nLevel, n) {
-    .Call('AlphaSimR_sampHalfDialComb', PACKAGE = 'AlphaSimR', nLevel, n)
-}
-
-zero <- function() {
-    .Call('AlphaSimR_zero', PACKAGE = 'AlphaSimR')
-}
-
-changeId <- function(newId, oldId) {
-    invisible(.Call('AlphaSimR_changeId', PACKAGE = 'AlphaSimR', newId, oldId))
-}
-
 #' @title Read Matrix
 #' 
 #' @description
@@ -268,6 +175,99 @@ gaussKernel <- function(D, theta) {
     .Call('AlphaSimR_gaussKernel', PACKAGE = 'AlphaSimR', D, theta)
 }
 
+writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call('AlphaSimR_writeASGenotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
+}
+
+writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call('AlphaSimR_writeASHaplotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
+}
+
+getGeno <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+getDomGeno <- function(geno) {
+    .Call('AlphaSimR_getDomGeno', PACKAGE = 'AlphaSimR', geno)
+}
+
+getHaplo <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
+    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
+}
+
+getGv <- function(trait, pop) {
+    .Call('AlphaSimR_getGv', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+calcGenParam <- function(trait, pop) {
+    .Call('AlphaSimR_calcGenParam', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+getHybridGv <- function(trait, motherGeno, mother, fatherGeno, father) {
+    .Call('AlphaSimR_getHybridGv', PACKAGE = 'AlphaSimR', trait, motherGeno, mother, fatherGeno, father)
+}
+
+cross2 <- function(motherGeno, mother, fatherGeno, father, genMaps, recombRatio) {
+    .Call('AlphaSimR_cross2', PACKAGE = 'AlphaSimR', motherGeno, mother, fatherGeno, father, genMaps, recombRatio)
+}
+
+createDH2 <- function(geno, nDH, genMaps, recombRatio, useFemale) {
+    .Call('AlphaSimR_createDH2', PACKAGE = 'AlphaSimR', geno, nDH, genMaps, recombRatio, useFemale)
+}
+
+crossPedigree <- function(founders, mother, father, genMaps) {
+    .Call('AlphaSimR_crossPedigree', PACKAGE = 'AlphaSimR', founders, mother, father, genMaps)
+}
+
+#' @title Population variance
+#' 
+#' @description
+#' Calculates the population variance matrix as 
+#' opposed to the sample variance matrix calculated 
+#' by \code{\link{var}}. i.e. divides by n instead 
+#' of n-1
+#' 
+#' @param X an n by m matrix
+#' 
+#' @return an m by m variance-covariance matrix
+#' 
+#' @export
+popVar <- function(X) {
+    .Call('AlphaSimR_popVar', PACKAGE = 'AlphaSimR', X)
+}
+
+mergeGeno <- function(x, y) {
+    .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
+}
+
+calcChrFreq <- function(geno) {
+    .Call('AlphaSimR_calcChrFreq', PACKAGE = 'AlphaSimR', geno)
+}
+
+convToImat <- function(X) {
+    .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
+}
+
+sampAllComb <- function(nLevel1, nLevel2, n) {
+    .Call('AlphaSimR_sampAllComb', PACKAGE = 'AlphaSimR', nLevel1, nLevel2, n)
+}
+
+sampHalfDialComb <- function(nLevel, n) {
+    .Call('AlphaSimR_sampHalfDialComb', PACKAGE = 'AlphaSimR', nLevel, n)
+}
+
+zero <- function() {
+    .Call('AlphaSimR_zero', PACKAGE = 'AlphaSimR')
+}
+
+changeId <- function(newId, oldId) {
+    invisible(.Call('AlphaSimR_changeId', PACKAGE = 'AlphaSimR', newId, oldId))
+}
+
 packHaplo <- function(haplo, ploidy, inbred) {
     .Call('AlphaSimR_packHaplo', PACKAGE = 'AlphaSimR', haplo, ploidy, inbred)
 }
@@ -297,7 +297,7 @@ tuneTraitA <- function(geno, addEff, varG) {
     .Call('AlphaSimR_tuneTraitA', PACKAGE = 'AlphaSimR', geno, addEff, varG)
 }
 
-tuneTraitAD <- function(geno, addEff, domEff, varG) {
-    .Call('AlphaSimR_tuneTraitAD', PACKAGE = 'AlphaSimR', geno, addEff, domEff, varG)
+tuneTraitAD <- function(geno, addEff, domEff, varG, useVarA) {
+    .Call('AlphaSimR_tuneTraitAD', PACKAGE = 'AlphaSimR', geno, addEff, domEff, varG, useVarA)
 }
 

---FILE: R/createSimulation.R---
@@ -216,7 +216,8 @@ pickQtlLoci = function(nQtlPerChr, simParam=NULL){
 #' @param varG a vector of total genetic variances for one or more traits
 #' @param corr a matrix of correlations between traits
 #' @param gamma should a gamma distribution be used instead of normal
-#' @param shape value of the shape parameter if using a gamma distribution
+#' @param shape value of the shape parameter if using a gamma distribution. 
+#' Note that shape=1 is equivalent to an exponential distribution.
 #' @param simParam an object of \code{\link{SimParam-class}}
 #' 
 #' @return Returns an object of \code{\link{SimParam-class}}
@@ -239,8 +240,13 @@ addTraitA = function(founderPop,nQtlPerChr,meanG,varG,corr=NULL,
                   ncol=nTraits)%*%chol(corr)
   if(any(gamma)){
     for(i in which(gamma)){
-      addEff[,i] = qgamma(pnorm(addEff[,i]),
-                          shape=shape[i])
+      tmp = addEff[,i]>=0
+      addEff[tmp,i] = qgamma(
+        (pnorm(addEff[tmp,i])-0.5)*2,
+        shape=shape[i])
+      addEff[!tmp,i] = -qgamma(
+        (pnorm(abs(addEff[!tmp,i]))-0.5)*2,
+        shape=shape[i])
     }
   }
   geno = getGeno(founderPop@geno,
@@ -275,15 +281,17 @@ addTraitA = function(founderPop,nQtlPerChr,meanG,varG,corr=NULL,
 #' @param domDegree mean dominance degree
 #' @param domDegreeVar variance of dominance degree
 #' @param corr a matrix of correlations between traits
+#' @param useVarA tune according to additive genetic variance if true
 #' @param gamma should a gamma distribution be used instead of normal
-#' @param shape value of the shape parameter if using a gamma distribution
+#' @param shape value of the shape parameter if using a gamma distribution. 
+#' Note that shape=1 is equivalent to an exponential distribution.
 #' @param simParam an object of \code{\link{SimParam-class}}
 #' 
 #' @return Returns an object of \code{\link{SimParam-class}}
 #'  
 #' @export
 addTraitAD = function(founderPop,nQtlPerChr,meanG,varG,domDegree,
-                      domDegreeVar=0,corr=NULL,
+                      domDegreeVar=0,corr=NULL,useVarA=FALSE,
                       gamma=FALSE,shape=1,simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SIMPARAM"",envir=.GlobalEnv)
@@ -300,8 +308,13 @@ addTraitAD = function(founderPop,nQtlPerChr,meanG,varG,domDegree,
                   ncol=nTraits)%*%chol(corr)
   if(any(gamma)){
     for(i in which(gamma)){
-      addEff[,i] = qgamma(pnorm(addEff[,i]),
-                          shape=shape[i])
+      tmp = addEff[,i]>=0
+      addEff[tmp,i] = qgamma(
+        (pnorm(addEff[tmp,i])-0.5)*2,
+        shape=shape[i])
+      addEff[!tmp,i] = -qgamma(
+        (pnorm(abs(addEff[!tmp,i]))-0.5)*2,
+        shape=shape[i])
     }
   }
   domDegree = rnorm(qtlLoci@nLoci,domDegree,
@@ -311,7 +324,7 @@ addTraitAD = function(founderPop,nQtlPerChr,meanG,varG,domDegree,
                  qtlLoci@lociPerChr,
                  qtlLoci@lociLoc)
   for(i in 1:nTraits){
-    tmp = tuneTraitAD(geno,addEff[,i],domEff[,i],varG[i])
+    tmp = tuneTraitAD(geno,addEff[,i],domEff[,i],varG[i],useVarA)
     intercept = tmp$output$intercept
     addEff[,i] = addEff[,i]*tmp$parameter
     domEff[,i] = domEff[,i]*tmp$parameter
@@ -343,7 +356,8 @@ addTraitAD = function(founderPop,nQtlPerChr,meanG,varG,domDegree,
 #' @param corr a matrix of correlations between traits
 #' @param corrGxe a matrix of correlations between GxE effects
 #' @param gamma should a gamma distribution be used instead of normal
-#' @param shape value of the shape parameter if using a gamma distribution
+#' @param shape value of the shape parameter if using a gamma distribution. 
+#' Note that shape=1 is equivalent to an exponential distribution.
 #' @param simParam an object of \code{\link{SimParam-class}}
 #' 
 #' @return Returns an object of \code{\link{SimParam-class}}
@@ -372,8 +386,13 @@ addTraitAG = function(founderPop,nQtlPerChr,meanG,varG,varEnv,varGE,
                   ncol=nTraits)%*%chol(corr)
   if(any(gamma)){
     for(i in which(gamma)){
-      addEff[,i] = qgamma(pnorm(addEff[,i]),
-                          shape=shape[i])
+      tmp = addEff[,i]>=0
+      addEff[tmp,i] = qgamma(
+        (pnorm(addEff[tmp,i])-0.5)*2,
+        shape=shape[i])
+      addEff[!tmp,i] = -qgamma(
+        (pnorm(abs(addEff[!tmp,i]))-0.5)*2,
+        shape=shape[i])
     }
   }
   gxeEff = matrix(rnorm(qtlLoci@nLoci*nTraits),
@@ -419,16 +438,18 @@ addTraitAG = function(founderPop,nQtlPerChr,meanG,varG,varEnv,varGE,
 #' @param domDegreeVar variance of dominance degree
 #' @param corr a matrix of correlations between traits
 #' @param corrGxe a matrix of correlations between GxE effects
+#' @param useVarA tune according to additive genetic variance if true
 #' @param gamma should a gamma distribution be used instead of normal
-#' @param shape value of the shape parameter if using a gamma distribution
+#' @param shape value of the shape parameter if using a gamma distribution. 
+#' Note that shape=1 is equivalent to an exponential distribution.
 #' @param simParam an object of \code{\link{SimParam-class}}
 #' 
 #' @return Returns an object of \code{\link{SimParam-class}}
 #'  
 #' @export
 addTraitADG = function(founderPop,nQtlPerChr,meanG,varG,varEnv,varGE,
                        domDegree,domDegreeVar=0,corr=NULL,
-                       corrGxe=NULL,gamma=FALSE,shape=1,
+                       corrGxe=NULL,useVarA=FALSE,gamma=FALSE,shape=1,
                        simParam=NULL){
   if(is.null(simParam)){
     simParam = get(""SIMPARAM"",envir=.GlobalEnv)
@@ -450,8 +471,13 @@ addTraitADG = function(founderPop,nQtlPerChr,meanG,varG,varEnv,varGE,
                   ncol=nTraits)%*%chol(corr)
   if(any(gamma)){
     for(i in which(gamma)){
-      addEff[,i] = qgamma(pnorm(addEff[,i]),
-                          shape=shape[i])
+      tmp = addEff[,i]>=0
+      addEff[tmp,i] = qgamma(
+        (pnorm(addEff[tmp,i])-0.5)*2,
+        shape=shape[i])
+      addEff[!tmp,i] = -qgamma(
+        (pnorm(abs(addEff[!tmp,i]))-0.5)*2,
+        shape=shape[i])
     }
   }
   domDegree = rnorm(qtlLoci@nLoci,domDegree,
@@ -463,7 +489,7 @@ addTraitADG = function(founderPop,nQtlPerChr,meanG,varG,varEnv,varGE,
                  qtlLoci@lociPerChr,
                  qtlLoci@lociLoc)
   for(i in 1:nTraits){
-    tmp = tuneTraitAD(geno,addEff[,i],domEff[,i],varG[i])
+    tmp = tuneTraitAD(geno,addEff[,i],domEff[,i],varG[i],useVarA)
     intercept = tmp$output$intercept
     addEff[,i] = addEff[,i]*tmp$parameter
     domEff[,i] = domEff[,i]*tmp$parameter

---FILE: man/MapPop-class.Rd---
@@ -26,7 +26,7 @@ for creating initial populations and setting traits in the
 }
 \section{Methods (by generic)}{
 \itemize{
-\item \code{[}: Extract \code{\link{RawPop-class}} by index
+\item \code{[}: Extract MapPop by index
 
 \item \code{c}: Combine MapPop chromosomes
 }}

---FILE: man/addTraitA.Rd---
@@ -20,7 +20,8 @@ addTraitA(founderPop, nQtlPerChr, meanG, varG, corr = NULL, gamma = FALSE,
 
 \item{gamma}{should a gamma distribution be used instead of normal}
 
-\item{shape}{value of the shape parameter if using a gamma distribution}
+\item{shape}{value of the shape parameter if using a gamma distribution. 
+Note that shape=1 is equivalent to an exponential distribution.}
 
 \item{simParam}{an object of \code{\link{SimParam-class}}}
 }

---FILE: man/addTraitAD.Rd---
@@ -5,7 +5,8 @@
 \title{Add additive and dominance traits}
 \usage{
 addTraitAD(founderPop, nQtlPerChr, meanG, varG, domDegree, domDegreeVar = 0,
-  corr = NULL, gamma = FALSE, shape = 1, simParam = NULL)
+  corr = NULL, useVarA = FALSE, gamma = FALSE, shape = 1,
+  simParam = NULL)
 }
 \arguments{
 \item{founderPop}{an object of \code{\link{MapPop-class}}}
@@ -22,9 +23,12 @@ addTraitAD(founderPop, nQtlPerChr, meanG, varG, domDegree, domDegreeVar = 0,
 
 \item{corr}{a matrix of correlations between traits}
 
+\item{useVarA}{tune according to additive genetic variance if true}
+
 \item{gamma}{should a gamma distribution be used instead of normal}
 
-\item{shape}{value of the shape parameter if using a gamma distribution}
+\item{shape}{value of the shape parameter if using a gamma distribution. 
+Note that shape=1 is equivalent to an exponential distribution.}
 
 \item{simParam}{an object of \code{\link{SimParam-class}}}
 }

---FILE: man/addTraitADG.Rd---
@@ -5,8 +5,8 @@
 \title{Add an additive and dominance GxE trait}
 \usage{
 addTraitADG(founderPop, nQtlPerChr, meanG, varG, varEnv, varGE, domDegree,
-  domDegreeVar = 0, corr = NULL, corrGxe = NULL, gamma = FALSE,
-  shape = 1, simParam = NULL)
+  domDegreeVar = 0, corr = NULL, corrGxe = NULL, useVarA = FALSE,
+  gamma = FALSE, shape = 1, simParam = NULL)
 }
 \arguments{
 \item{founderPop}{an object of \code{\link{MapPop-class}}}
@@ -30,9 +30,12 @@ value or nChr values.}
 
 \item{corrGxe}{a matrix of correlations between GxE effects}
 
+\item{useVarA}{tune according to additive genetic variance if true}
+
 \item{gamma}{should a gamma distribution be used instead of normal}
 
-\item{shape}{value of the shape parameter if using a gamma distribution}
+\item{shape}{value of the shape parameter if using a gamma distribution. 
+Note that shape=1 is equivalent to an exponential distribution.}
 
 \item{simParam}{an object of \code{\link{SimParam-class}}}
 }

---FILE: man/addTraitAG.Rd---
@@ -26,7 +26,8 @@ addTraitAG(founderPop, nQtlPerChr, meanG, varG, varEnv, varGE, corr = NULL,
 
 \item{gamma}{should a gamma distribution be used instead of normal}
 
-\item{shape}{value of the shape parameter if using a gamma distribution}
+\item{shape}{value of the shape parameter if using a gamma distribution. 
+Note that shape=1 is equivalent to an exponential distribution.}
 
 \item{simParam}{an object of \code{\link{SimParam-class}}}
 }

---FILE: src/RcppExports.cpp---
@@ -6,38 +6,6 @@
 
 using namespace Rcpp;
 
-// writeASGenotypes
-void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
-END_RCPP
-}
-// writeASHaplotypes
-void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
-END_RCPP
-}
 // gebvRR
 arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
 RcppExport SEXP AlphaSimR_gebvRR(SEXP RRsolSEXP, SEXP popSEXP) {
@@ -75,6 +43,216 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// readMat
+arma::mat readMat(std::string fileName, int rows, int cols, char sep, int skipRows, int skipCols);
+RcppExport SEXP AlphaSimR_readMat(SEXP fileNameSEXP, SEXP rowsSEXP, SEXP colsSEXP, SEXP sepSEXP, SEXP skipRowsSEXP, SEXP skipColsSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< std::string >::type fileName(fileNameSEXP);
+    Rcpp::traits::input_parameter< int >::type rows(rowsSEXP);
+    Rcpp::traits::input_parameter< int >::type cols(colsSEXP);
+    Rcpp::traits::input_parameter< char >::type sep(sepSEXP);
+    Rcpp::traits::input_parameter< int >::type skipRows(skipRowsSEXP);
+    Rcpp::traits::input_parameter< int >::type skipCols(skipColsSEXP);
+    rcpp_result_gen = Rcpp::wrap(readMat(fileName, rows, cols, sep, skipRows, skipCols));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveUVM
+Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
+RcppExport SEXP AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMVM
+Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol);
+RcppExport SEXP AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMKM
+Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist);
+RcppExport SEXP AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP
+Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_MV
+Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_GCA
+Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_SCA
+Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcG
+arma::mat calcG(arma::mat X);
+RcppExport SEXP AlphaSimR_calcG(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcG(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcGIbs
+arma::mat calcGIbs(arma::mat X);
+RcppExport SEXP AlphaSimR_calcGIbs(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcGIbs(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// fastDist
+arma::mat fastDist(const arma::mat& X);
+RcppExport SEXP AlphaSimR_fastDist(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(fastDist(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// fastPairDist
+arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y);
+RcppExport SEXP AlphaSimR_fastPairDist(SEXP XSEXP, SEXP YSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    rcpp_result_gen = Rcpp::wrap(fastPairDist(X, Y));
+    return rcpp_result_gen;
+END_RCPP
+}
+// gaussKernel
+arma::mat gaussKernel(arma::mat& D, double theta);
+RcppExport SEXP AlphaSimR_gaussKernel(SEXP DSEXP, SEXP thetaSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type D(DSEXP);
+    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
+    rcpp_result_gen = Rcpp::wrap(gaussKernel(D, theta));
+    return rcpp_result_gen;
+END_RCPP
+}
+// writeASGenotypes
+void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
+END_RCPP
+}
+// writeASHaplotypes
+void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
+END_RCPP
+}
 // getGeno
 arma::Mat<unsigned char> getGeno(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
 RcppExport SEXP AlphaSimR_getGeno(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
@@ -301,184 +479,6 @@ BEGIN_RCPP
     return R_NilValue;
 END_RCPP
 }
-// readMat
-arma::mat readMat(std::string fileName, int rows, int cols, char sep, int skipRows, int skipCols);
-RcppExport SEXP AlphaSimR_readMat(SEXP fileNameSEXP, SEXP rowsSEXP, SEXP colsSEXP, SEXP sepSEXP, SEXP skipRowsSEXP, SEXP skipColsSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< std::string >::type fileName(fileNameSEXP);
-    Rcpp::traits::input_parameter< int >::type rows(rowsSEXP);
-    Rcpp::traits::input_parameter< int >::type cols(colsSEXP);
-    Rcpp::traits::input_parameter< char >::type sep(sepSEXP);
-    Rcpp::traits::input_parameter< int >::type skipRows(skipRowsSEXP);
-    Rcpp::traits::input_parameter< int >::type skipCols(skipColsSEXP);
-    rcpp_result_gen = Rcpp::wrap(readMat(fileName, rows, cols, sep, skipRows, skipCols));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveUVM
-Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
-RcppExport SEXP AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMVM
-Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol);
-RcppExport SEXP AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMKM
-Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist);
-RcppExport SEXP AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP
-Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_MV
-Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_GCA
-Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_SCA
-Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcG
-arma::mat calcG(arma::mat X);
-RcppExport SEXP AlphaSimR_calcG(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcG(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcGIbs
-arma::mat calcGIbs(arma::mat X);
-RcppExport SEXP AlphaSimR_calcGIbs(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcGIbs(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// fastDist
-arma::mat fastDist(const arma::mat& X);
-RcppExport SEXP AlphaSimR_fastDist(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(fastDist(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// fastPairDist
-arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y);
-RcppExport SEXP AlphaSimR_fastPairDist(SEXP XSEXP, SEXP YSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    rcpp_result_gen = Rcpp::wrap(fastPairDist(X, Y));
-    return rcpp_result_gen;
-END_RCPP
-}
-// gaussKernel
-arma::mat gaussKernel(arma::mat& D, double theta);
-RcppExport SEXP AlphaSimR_gaussKernel(SEXP DSEXP, SEXP thetaSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type D(DSEXP);
-    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
-    rcpp_result_gen = Rcpp::wrap(gaussKernel(D, theta));
-    return rcpp_result_gen;
-END_RCPP
-}
 // packHaplo
 arma::Cube<unsigned char> packHaplo(arma::Mat<unsigned char>& haplo, arma::uword ploidy, bool inbred);
 RcppExport SEXP AlphaSimR_packHaplo(SEXP haploSEXP, SEXP ploidySEXP, SEXP inbredSEXP) {
@@ -518,16 +518,17 @@ BEGIN_RCPP
 END_RCPP
 }
 // tuneTraitAD
-Rcpp::List tuneTraitAD(arma::Mat<unsigned char>& geno, arma::vec& addEff, arma::vec& domEff, double varG);
-RcppExport SEXP AlphaSimR_tuneTraitAD(SEXP genoSEXP, SEXP addEffSEXP, SEXP domEffSEXP, SEXP varGSEXP) {
+Rcpp::List tuneTraitAD(arma::Mat<unsigned char>& geno, arma::vec& addEff, arma::vec& domEff, double varG, bool useVarA);
+RcppExport SEXP AlphaSimR_tuneTraitAD(SEXP genoSEXP, SEXP addEffSEXP, SEXP domEffSEXP, SEXP varGSEXP, SEXP useVarASEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
     Rcpp::traits::input_parameter< arma::Mat<unsigned char>& >::type geno(genoSEXP);
     Rcpp::traits::input_parameter< arma::vec& >::type addEff(addEffSEXP);
     Rcpp::traits::input_parameter< arma::vec& >::type domEff(domEffSEXP);
     Rcpp::traits::input_parameter< double >::type varG(varGSEXP);
-    rcpp_result_gen = Rcpp::wrap(tuneTraitAD(geno, addEff, domEff, varG));
+    Rcpp::traits::input_parameter< bool >::type useVarA(useVarASEXP);
+    rcpp_result_gen = Rcpp::wrap(tuneTraitAD(geno, addEff, domEff, varG, useVarA));
     return rcpp_result_gen;
 END_RCPP
 }

---FILE: src/init.c---
@@ -44,7 +44,7 @@ extern SEXP AlphaSimR_solveMKM(SEXP, SEXP, SEXP, SEXP);
 extern SEXP AlphaSimR_solveMVM(SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP AlphaSimR_solveUVM(SEXP, SEXP, SEXP, SEXP);
 extern SEXP AlphaSimR_tuneTraitA(SEXP, SEXP, SEXP);
-extern SEXP AlphaSimR_tuneTraitAD(SEXP, SEXP, SEXP, SEXP);
+extern SEXP AlphaSimR_tuneTraitAD(SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP AlphaSimR_writeASGenotypes(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP AlphaSimR_writeASHaplotypes(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP AlphaSimR_zero();
@@ -86,7 +86,7 @@ static const R_CallMethodDef CallEntries[] = {
     {""AlphaSimR_solveMVM"",          (DL_FUNC) &AlphaSimR_solveMVM,          5},
     {""AlphaSimR_solveUVM"",          (DL_FUNC) &AlphaSimR_solveUVM,          4},
     {""AlphaSimR_tuneTraitA"",        (DL_FUNC) &AlphaSimR_tuneTraitA,        3},
-    {""AlphaSimR_tuneTraitAD"",       (DL_FUNC) &AlphaSimR_tuneTraitAD,       4},
+    {""AlphaSimR_tuneTraitAD"",       (DL_FUNC) &AlphaSimR_tuneTraitAD,       5},
     {""AlphaSimR_writeASGenotypes"",  (DL_FUNC) &AlphaSimR_writeASGenotypes,  7},
     {""AlphaSimR_writeASHaplotypes"", (DL_FUNC) &AlphaSimR_writeASHaplotypes, 7},
     {""AlphaSimR_zero"",              (DL_FUNC) &AlphaSimR_zero,              0},

---FILE: src/tuneTraits.cpp---
@@ -23,9 +23,18 @@ Rcpp::List traitADObj(double tuneValue, Rcpp::List args){
   arma::vec addEff = args[""addEff""];
   arma::vec domEff = args[""domEff""];
   double varG = args[""varG""];
+  bool useVarA = args[""useVarA""];
   arma::vec gv = geno*(addEff*tuneValue)+domGeno*(domEff*tuneValue);
   double intercept = arma::mean(gv);
-  double obsVar = arma::var(gv,1); //Population variance
+  double obsVar;
+  if(useVarA){
+    arma::vec p = (arma::mean(arma::conv_to<arma::mat>::from(geno),0)/2.0).t();
+    arma::vec alpha = (addEff*tuneValue)+(domEff*tuneValue)%(1-2*p);
+    arma::vec bv = geno*alpha;
+    obsVar = arma::var(bv,1);
+  }else{
+    obsVar = arma::var(gv,1); //Population variance
+  }
   Rcpp::List output;
   output = Rcpp::List::create(Rcpp::Named(""intercept"")=intercept);
   return Rcpp::List::create(Rcpp::Named(""objective"")=fabs(varG-obsVar),
@@ -45,18 +54,20 @@ Rcpp::List tuneTraitA(arma::Mat<unsigned char>& geno,
                                      1e3);
 }
 
-//Tunes TraitAD for desired varG, tuneTraitA used for inbreds
+//Tunes TraitAD for desired varG (or varA), tuneTraitA used for inbreds
 // [[Rcpp::export]]
 Rcpp::List tuneTraitAD(arma::Mat<unsigned char>& geno,
                       arma::vec& addEff,
                       arma::vec& domEff,
-                      double varG){
+                      double varG, 
+                      bool useVarA){
   return optimize(*traitADObj,
                   Rcpp::List::create(Rcpp::Named(""geno"")=geno,
                                      Rcpp::Named(""domGeno"")=getDomGeno(geno),
                                      Rcpp::Named(""addEff"")=addEff,
                                      Rcpp::Named(""domEff"")=domEff,
-                                     Rcpp::Named(""varG"")=varG),
+                                     Rcpp::Named(""varG"")=varG,
+                                     Rcpp::Named(""useVarA"")=useVarA),
                                      1e-10,
                                      1e3);
 }"
gaynorr,AlphaSimR,05a30db6bf1aab5a695ed32f639c5f797f6d610f,David Wilson,david.wilson@roslin.ed.ac.uk,2017-08-18T09:49:10Z,David Wilson,david.wilson@roslin.ed.ac.uk,2017-08-18T09:49:10Z,fixed string issue with cpp,R/RcppExports.R;src/RcppExports.cpp;src/simulator.cpp,False,True,True,False,332,304,636,"---FILE: R/RcppExports.R---
@@ -1,6 +1,14 @@
 # Generated by using Rcpp::compileAttributes() -> do not edit by hand
 # Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393
 
+writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call('AlphaSimR_writeASGenotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
+}
+
+writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call('AlphaSimR_writeASHaplotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
+}
+
 gebvRR <- function(RRsol, pop) {
     .Call('AlphaSimR_gebvRR', PACKAGE = 'AlphaSimR', RRsol, pop)
 }
@@ -13,6 +21,91 @@ gebvSCA <- function(SCAsol, pop) {
     .Call('AlphaSimR_gebvSCA', PACKAGE = 'AlphaSimR', SCAsol, pop)
 }
 
+getGeno <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+getDomGeno <- function(geno) {
+    .Call('AlphaSimR_getDomGeno', PACKAGE = 'AlphaSimR', geno)
+}
+
+getHaplo <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
+    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
+}
+
+getGv <- function(trait, pop) {
+    .Call('AlphaSimR_getGv', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+calcGenParam <- function(trait, pop) {
+    .Call('AlphaSimR_calcGenParam', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+getHybridGv <- function(trait, motherGeno, mother, fatherGeno, father) {
+    .Call('AlphaSimR_getHybridGv', PACKAGE = 'AlphaSimR', trait, motherGeno, mother, fatherGeno, father)
+}
+
+cross2 <- function(motherGeno, mother, fatherGeno, father, genMaps, recombRatio) {
+    .Call('AlphaSimR_cross2', PACKAGE = 'AlphaSimR', motherGeno, mother, fatherGeno, father, genMaps, recombRatio)
+}
+
+createDH2 <- function(geno, nDH, genMaps, recombRatio, useFemale) {
+    .Call('AlphaSimR_createDH2', PACKAGE = 'AlphaSimR', geno, nDH, genMaps, recombRatio, useFemale)
+}
+
+crossPedigree <- function(founders, mother, father, genMaps) {
+    .Call('AlphaSimR_crossPedigree', PACKAGE = 'AlphaSimR', founders, mother, father, genMaps)
+}
+
+#' @title Population variance
+#' 
+#' @description
+#' Calculates the population variance matrix as 
+#' opposed to the sample variance matrix calculated 
+#' by \code{\link{var}}. i.e. divides by n instead 
+#' of n-1
+#' 
+#' @param X an n by m matrix
+#' 
+#' @return an m by m variance-covariance matrix
+#' 
+#' @export
+popVar <- function(X) {
+    .Call('AlphaSimR_popVar', PACKAGE = 'AlphaSimR', X)
+}
+
+mergeGeno <- function(x, y) {
+    .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
+}
+
+calcChrFreq <- function(geno) {
+    .Call('AlphaSimR_calcChrFreq', PACKAGE = 'AlphaSimR', geno)
+}
+
+convToImat <- function(X) {
+    .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
+}
+
+sampAllComb <- function(nLevel1, nLevel2, n) {
+    .Call('AlphaSimR_sampAllComb', PACKAGE = 'AlphaSimR', nLevel1, nLevel2, n)
+}
+
+sampHalfDialComb <- function(nLevel, n) {
+    .Call('AlphaSimR_sampHalfDialComb', PACKAGE = 'AlphaSimR', nLevel, n)
+}
+
+zero <- function() {
+    .Call('AlphaSimR_zero', PACKAGE = 'AlphaSimR')
+}
+
+changeId <- function(newId, oldId) {
+    invisible(.Call('AlphaSimR_changeId', PACKAGE = 'AlphaSimR', newId, oldId))
+}
+
 #' @title Read Matrix
 #' 
 #' @description
@@ -175,99 +268,6 @@ gaussKernel <- function(D, theta) {
     .Call('AlphaSimR_gaussKernel', PACKAGE = 'AlphaSimR', D, theta)
 }
 
-writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call('AlphaSimR_writeASGenotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
-}
-
-writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call('AlphaSimR_writeASHaplotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
-}
-
-getGeno <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-getDomGeno <- function(geno) {
-    .Call('AlphaSimR_getDomGeno', PACKAGE = 'AlphaSimR', geno)
-}
-
-getHaplo <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
-    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
-}
-
-getGv <- function(trait, pop) {
-    .Call('AlphaSimR_getGv', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-calcGenParam <- function(trait, pop) {
-    .Call('AlphaSimR_calcGenParam', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-getHybridGv <- function(trait, motherGeno, mother, fatherGeno, father) {
-    .Call('AlphaSimR_getHybridGv', PACKAGE = 'AlphaSimR', trait, motherGeno, mother, fatherGeno, father)
-}
-
-cross2 <- function(motherGeno, mother, fatherGeno, father, genMaps, recombRatio) {
-    .Call('AlphaSimR_cross2', PACKAGE = 'AlphaSimR', motherGeno, mother, fatherGeno, father, genMaps, recombRatio)
-}
-
-createDH2 <- function(geno, nDH, genMaps, recombRatio, useFemale) {
-    .Call('AlphaSimR_createDH2', PACKAGE = 'AlphaSimR', geno, nDH, genMaps, recombRatio, useFemale)
-}
-
-crossPedigree <- function(founders, mother, father, genMaps) {
-    .Call('AlphaSimR_crossPedigree', PACKAGE = 'AlphaSimR', founders, mother, father, genMaps)
-}
-
-#' @title Population variance
-#' 
-#' @description
-#' Calculates the population variance matrix as 
-#' opposed to the sample variance matrix calculated 
-#' by \code{\link{var}}. i.e. divides by n instead 
-#' of n-1
-#' 
-#' @param X an n by m matrix
-#' 
-#' @return an m by m variance-covariance matrix
-#' 
-#' @export
-popVar <- function(X) {
-    .Call('AlphaSimR_popVar', PACKAGE = 'AlphaSimR', X)
-}
-
-mergeGeno <- function(x, y) {
-    .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
-}
-
-calcChrFreq <- function(geno) {
-    .Call('AlphaSimR_calcChrFreq', PACKAGE = 'AlphaSimR', geno)
-}
-
-convToImat <- function(X) {
-    .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
-}
-
-sampAllComb <- function(nLevel1, nLevel2, n) {
-    .Call('AlphaSimR_sampAllComb', PACKAGE = 'AlphaSimR', nLevel1, nLevel2, n)
-}
-
-sampHalfDialComb <- function(nLevel, n) {
-    .Call('AlphaSimR_sampHalfDialComb', PACKAGE = 'AlphaSimR', nLevel, n)
-}
-
-zero <- function() {
-    .Call('AlphaSimR_zero', PACKAGE = 'AlphaSimR')
-}
-
-changeId <- function(newId, oldId) {
-    invisible(.Call('AlphaSimR_changeId', PACKAGE = 'AlphaSimR', newId, oldId))
-}
-
 packHaplo <- function(haplo, ploidy, inbred) {
     .Call('AlphaSimR_packHaplo', PACKAGE = 'AlphaSimR', haplo, ploidy, inbred)
 }

---FILE: src/RcppExports.cpp---
@@ -6,6 +6,38 @@
 
 using namespace Rcpp;
 
+// writeASGenotypes
+void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
+END_RCPP
+}
+// writeASHaplotypes
+void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
+END_RCPP
+}
 // gebvRR
 arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
 RcppExport SEXP AlphaSimR_gebvRR(SEXP RRsolSEXP, SEXP popSEXP) {
@@ -43,216 +75,6 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// readMat
-arma::mat readMat(std::string fileName, int rows, int cols, char sep, int skipRows, int skipCols);
-RcppExport SEXP AlphaSimR_readMat(SEXP fileNameSEXP, SEXP rowsSEXP, SEXP colsSEXP, SEXP sepSEXP, SEXP skipRowsSEXP, SEXP skipColsSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< std::string >::type fileName(fileNameSEXP);
-    Rcpp::traits::input_parameter< int >::type rows(rowsSEXP);
-    Rcpp::traits::input_parameter< int >::type cols(colsSEXP);
-    Rcpp::traits::input_parameter< char >::type sep(sepSEXP);
-    Rcpp::traits::input_parameter< int >::type skipRows(skipRowsSEXP);
-    Rcpp::traits::input_parameter< int >::type skipCols(skipColsSEXP);
-    rcpp_result_gen = Rcpp::wrap(readMat(fileName, rows, cols, sep, skipRows, skipCols));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveUVM
-Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
-RcppExport SEXP AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMVM
-Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol);
-RcppExport SEXP AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMKM
-Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist);
-RcppExport SEXP AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP
-Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_MV
-Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_GCA
-Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_SCA
-Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcG
-arma::mat calcG(arma::mat X);
-RcppExport SEXP AlphaSimR_calcG(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcG(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcGIbs
-arma::mat calcGIbs(arma::mat X);
-RcppExport SEXP AlphaSimR_calcGIbs(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcGIbs(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// fastDist
-arma::mat fastDist(const arma::mat& X);
-RcppExport SEXP AlphaSimR_fastDist(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(fastDist(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// fastPairDist
-arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y);
-RcppExport SEXP AlphaSimR_fastPairDist(SEXP XSEXP, SEXP YSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    rcpp_result_gen = Rcpp::wrap(fastPairDist(X, Y));
-    return rcpp_result_gen;
-END_RCPP
-}
-// gaussKernel
-arma::mat gaussKernel(arma::mat& D, double theta);
-RcppExport SEXP AlphaSimR_gaussKernel(SEXP DSEXP, SEXP thetaSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type D(DSEXP);
-    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
-    rcpp_result_gen = Rcpp::wrap(gaussKernel(D, theta));
-    return rcpp_result_gen;
-END_RCPP
-}
-// writeASGenotypes
-void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
-END_RCPP
-}
-// writeASHaplotypes
-void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
-END_RCPP
-}
 // getGeno
 arma::Mat<unsigned char> getGeno(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
 RcppExport SEXP AlphaSimR_getGeno(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
@@ -479,6 +301,184 @@ BEGIN_RCPP
     return R_NilValue;
 END_RCPP
 }
+// readMat
+arma::mat readMat(std::string fileName, int rows, int cols, char sep, int skipRows, int skipCols);
+RcppExport SEXP AlphaSimR_readMat(SEXP fileNameSEXP, SEXP rowsSEXP, SEXP colsSEXP, SEXP sepSEXP, SEXP skipRowsSEXP, SEXP skipColsSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< std::string >::type fileName(fileNameSEXP);
+    Rcpp::traits::input_parameter< int >::type rows(rowsSEXP);
+    Rcpp::traits::input_parameter< int >::type cols(colsSEXP);
+    Rcpp::traits::input_parameter< char >::type sep(sepSEXP);
+    Rcpp::traits::input_parameter< int >::type skipRows(skipRowsSEXP);
+    Rcpp::traits::input_parameter< int >::type skipCols(skipColsSEXP);
+    rcpp_result_gen = Rcpp::wrap(readMat(fileName, rows, cols, sep, skipRows, skipCols));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveUVM
+Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
+RcppExport SEXP AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMVM
+Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol);
+RcppExport SEXP AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMKM
+Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist);
+RcppExport SEXP AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP
+Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_MV
+Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_GCA
+Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_SCA
+Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcG
+arma::mat calcG(arma::mat X);
+RcppExport SEXP AlphaSimR_calcG(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcG(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcGIbs
+arma::mat calcGIbs(arma::mat X);
+RcppExport SEXP AlphaSimR_calcGIbs(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcGIbs(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// fastDist
+arma::mat fastDist(const arma::mat& X);
+RcppExport SEXP AlphaSimR_fastDist(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(fastDist(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// fastPairDist
+arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y);
+RcppExport SEXP AlphaSimR_fastPairDist(SEXP XSEXP, SEXP YSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    rcpp_result_gen = Rcpp::wrap(fastPairDist(X, Y));
+    return rcpp_result_gen;
+END_RCPP
+}
+// gaussKernel
+arma::mat gaussKernel(arma::mat& D, double theta);
+RcppExport SEXP AlphaSimR_gaussKernel(SEXP DSEXP, SEXP thetaSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type D(DSEXP);
+    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
+    rcpp_result_gen = Rcpp::wrap(gaussKernel(D, theta));
+    return rcpp_result_gen;
+END_RCPP
+}
 // packHaplo
 arma::Cube<unsigned char> packHaplo(arma::Mat<unsigned char>& haplo, arma::uword ploidy, bool inbred);
 RcppExport SEXP AlphaSimR_packHaplo(SEXP haploSEXP, SEXP ploidySEXP, SEXP inbredSEXP) {

---FILE: src/simulator.cpp---
@@ -5,6 +5,10 @@
 #include <stdexcept>
 #include <tuple>
 #include <math.h>
+#include <algorithm> 
+#include <cctype>
+#include <locale>
+
 #include <boost/algorithm/string/split.hpp> // Include for boost::split
 #include <boost/algorithm/string/classification.hpp> // Include boost::for is_any_of
 #include ""simulator.h""
@@ -132,6 +136,10 @@ void Simulator::readInputParameters(CommandArguments arguments){
   bool bAcceptFullMigrMatrix;
   
   unsigned int iTotalArgs = arguments.size();
+  
+  if (iTotalArgs == 0) {
+    Rcpp::stop(""You must enter a value for the sample size and seq length."");
+  } 
   dDefaultPopSize = 1.0;
   dDefaultGrowthAlpha =0.0;
   
@@ -881,6 +889,15 @@ Simulator::~Simulator() {
 vector<AlphaSimRReturn> runFromAlphaSimR(string in) {
   vector<std::string> words;
   Simulator simulator;
+  
+  
+  if (in == """"){
+    Rcpp::stop(""Not enough args for macs call"");
+  }
+  
+  if (in.empty()) {
+    Rcpp::stop(""Not enough args for macs call"");
+  }
   boost::split(words, in, boost::is_any_of("", ""), boost::token_compress_on);
   CommandArguments arguments;
   vector<string> subOption;
@@ -898,6 +915,10 @@ vector<AlphaSimRReturn> runFromAlphaSimR(string in) {
     }
   }
   
+  if (arguments.size() == 0) {
+    Rcpp::stop(""Not enough args for macs call"");
+  }
+  
   
   simulator.readInputParameters(arguments);
   vector<AlphaSimRReturn> test = simulator.beginSimulationMemory();
@@ -926,8 +947,15 @@ Rcpp::List MaCS(Rcpp::String args, long long int maxSites=0){
   
   // Run MaCS
   vector<AlphaSimRReturn> macsOutput;
-  macsOutput = runFromAlphaSimR(args);
   
+  string t = args;
+  if (t == """") {
+    Rcpp::stop(""error"");
+  }
+  macsOutput = runFromAlphaSimR(args);
+  if(macsOutput.empty()){
+    Rcpp::stop(""Macs has failed to run."");
+  }
   // Check MaCS output
   long long int nSites, nHap;
   arma::Mat<unsigned char> haplo;"
gaynorr,AlphaSimR,102d8cba4e5946d3d1ecbcd2b6a9606d1374d52c,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-08-15T13:13:07Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-08-15T13:13:07Z,"Added C++ function to initialize lastID in SimParam
Fixes side effects of changeId due to R's copy-on-modify semantics",R/RcppExports.R;R/createSimulation.R;src/RcppExports.cpp;src/init.c;src/misc.cpp;src/simulator.cpp,False,True,True,False,46,23,69,"---FILE: R/RcppExports.R---
@@ -244,8 +244,8 @@ mergeGeno <- function(x, y) {
     .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
 }
 
-calcChrMinorFreq <- function(geno, ploidy) {
-    .Call('AlphaSimR_calcChrMinorFreq', PACKAGE = 'AlphaSimR', geno, ploidy)
+calcChrFreq <- function(geno) {
+    .Call('AlphaSimR_calcChrFreq', PACKAGE = 'AlphaSimR', geno)
 }
 
 convToImat <- function(X) {
@@ -260,6 +260,10 @@ sampHalfDialComb <- function(nLevel, n) {
     .Call('AlphaSimR_sampHalfDialComb', PACKAGE = 'AlphaSimR', nLevel, n)
 }
 
+zero <- function() {
+    .Call('AlphaSimR_zero', PACKAGE = 'AlphaSimR')
+}
+
 changeId <- function(newId, oldId) {
     invisible(.Call('AlphaSimR_changeId', PACKAGE = 'AlphaSimR', newId, oldId))
 }

---FILE: R/createSimulation.R---
@@ -53,8 +53,8 @@ createSimulation = function(founderPop,maxQtl=0,maxSnp=0,snpQtlOverlap=FALSE,
         potSnp[[chr]] = sort(sample.int(founderPop@nLoci[chr],
                                         maxSnp[chr]))
       }else{
-        q = calcChrMinorFreq(founderPop@geno[[chr]],
-                             founderPop@ploidy)
+        q = calcChrFreq(founderPop@geno[[chr]])
+        q = 0.5-abs(q-0.5) #Convert to minor allele frequency
         potSnp[[chr]] = sort(sample(which(q>=minSnpFreq),maxSnp[chr]))
       }
       potQtl[[chr]] = sort(sample.int(founderPop@nLoci[chr],
@@ -66,8 +66,8 @@ createSimulation = function(founderPop,maxQtl=0,maxSnp=0,snpQtlOverlap=FALSE,
         potSnp[[chr]] = sort(tmp[1:maxSnp[chr]])
         potQtl[[chr]] = sort(tmp[(maxSnp[chr]+1):length(tmp)])
       }else{
-        q = calcChrMinorFreq(founderPop@geno[[chr]],
-                             founderPop@ploidy)
+        q = calcChrFreq(founderPop@geno[[chr]])
+        q = 0.5-abs(q-0.5)
         potSnp[[chr]] = sort(sample(which(q>=minSnpFreq),maxSnp[chr]))
         potQtl[[chr]] = sort(sample(which(!((1:founderPop@nLoci[chr])%in%potSnp[[chr]])),
                                     maxQtl[chr]))
@@ -87,7 +87,7 @@ createSimulation = function(founderPop,maxQtl=0,maxSnp=0,snpQtlOverlap=FALSE,
                snpChips=list(),
                potQtl=potQtl,
                potSnp=potSnp,
-               lastId=0L)
+               lastId=zero())
   return(output)
 }
 

---FILE: src/RcppExports.cpp---
@@ -411,15 +411,14 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// calcChrMinorFreq
-arma::vec calcChrMinorFreq(const arma::Cube<unsigned char>& geno, int ploidy);
-RcppExport SEXP AlphaSimR_calcChrMinorFreq(SEXP genoSEXP, SEXP ploidySEXP) {
+// calcChrFreq
+arma::vec calcChrFreq(const arma::Cube<unsigned char>& geno);
+RcppExport SEXP AlphaSimR_calcChrFreq(SEXP genoSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
     Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< int >::type ploidy(ploidySEXP);
-    rcpp_result_gen = Rcpp::wrap(calcChrMinorFreq(geno, ploidy));
+    rcpp_result_gen = Rcpp::wrap(calcChrFreq(geno));
     return rcpp_result_gen;
 END_RCPP
 }
@@ -459,6 +458,16 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// zero
+int zero();
+RcppExport SEXP AlphaSimR_zero() {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    rcpp_result_gen = Rcpp::wrap(zero());
+    return rcpp_result_gen;
+END_RCPP
+}
 // changeId
 void changeId(Rcpp::IntegerVector newId, Rcpp::IntegerVector& oldId);
 RcppExport SEXP AlphaSimR_changeId(SEXP newIdSEXP, SEXP oldIdSEXP) {

---FILE: src/init.c---
@@ -8,7 +8,7 @@
 */
 
 /* .Call calls */
-extern SEXP AlphaSimR_calcChrMinorFreq(SEXP, SEXP);
+extern SEXP AlphaSimR_calcChrFreq(SEXP);
 extern SEXP AlphaSimR_calcG(SEXP);
 extern SEXP AlphaSimR_calcGenParam(SEXP, SEXP);
 extern SEXP AlphaSimR_calcGIbs(SEXP);
@@ -47,9 +47,10 @@ extern SEXP AlphaSimR_tuneTraitA(SEXP, SEXP, SEXP);
 extern SEXP AlphaSimR_tuneTraitAD(SEXP, SEXP, SEXP, SEXP);
 extern SEXP AlphaSimR_writeASGenotypes(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
 extern SEXP AlphaSimR_writeASHaplotypes(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
+extern SEXP AlphaSimR_zero();
 
 static const R_CallMethodDef CallEntries[] = {
-    {""AlphaSimR_calcChrMinorFreq"",  (DL_FUNC) &AlphaSimR_calcChrMinorFreq,  2},
+    {""AlphaSimR_calcChrFreq"",       (DL_FUNC) &AlphaSimR_calcChrFreq,       1},
     {""AlphaSimR_calcG"",             (DL_FUNC) &AlphaSimR_calcG,             1},
     {""AlphaSimR_calcGenParam"",      (DL_FUNC) &AlphaSimR_calcGenParam,      2},
     {""AlphaSimR_calcGIbs"",          (DL_FUNC) &AlphaSimR_calcGIbs,          1},
@@ -88,6 +89,7 @@ static const R_CallMethodDef CallEntries[] = {
     {""AlphaSimR_tuneTraitAD"",       (DL_FUNC) &AlphaSimR_tuneTraitAD,       4},
     {""AlphaSimR_writeASGenotypes"",  (DL_FUNC) &AlphaSimR_writeASGenotypes,  7},
     {""AlphaSimR_writeASHaplotypes"", (DL_FUNC) &AlphaSimR_writeASHaplotypes, 7},
+    {""AlphaSimR_zero"",              (DL_FUNC) &AlphaSimR_zero,              0},
     {NULL, NULL, 0}
 };
 

---FILE: src/misc.cpp---
@@ -34,15 +34,15 @@ arma::field<arma::Cube<unsigned char> > mergeGeno(
   return z;
 }
 
-// Calculates minor allele frequency on a single chromsome
+// Calculates allele frequency on a single chromsome
 // Requires bi-allelic markers, but works for any ploidy
 // [[Rcpp::export]]
-arma::vec calcChrMinorFreq(const arma::Cube<unsigned char>& geno,
-                           int ploidy){
+arma::vec calcChrFreq(const arma::Cube<unsigned char>& geno){
+  int ploidy = geno.n_cols;
   arma::Mat<unsigned char> tmp = arma::sum(geno,1);
   arma::vec output = arma::mean(arma::conv_to<arma::mat>::from(tmp),
                                 1)/ploidy;
-  return 0.5-arma::abs(output-0.5);
+  return output;
 }
 
 // [[Rcpp::export]]
@@ -181,6 +181,14 @@ arma::imat sampHalfDialComb(long long int nLevel, long long int n){
   return output;
 }
 
+// Create a value of zero for initial ID
+// Needed to prevent side effects of modify in place
+// [[Rcpp::export]]
+int zero(){
+  return 0;
+}
+
+// Modifies the ID value in place
 // [[Rcpp::export]]
 void changeId(Rcpp::IntegerVector newId,
               Rcpp::IntegerVector& oldId){

---FILE: src/simulator.cpp---
@@ -373,7 +373,7 @@ void Simulator::readInputParameters(CommandArguments arguments){
             const char * arg = arguments[iCurrentArg][2+i].data();
             newPop.setChrSampled(atoi(arg));
             iRunningSample+=newPop.getChrSampled();
-            Rcpp::Rcerr<<""INPUT: Setting chr sampled for pop ""<<(i+1)<<"" to ""<<newPop.getChrSampled()<<endl;
+            //Rcpp::Rcerr<<""INPUT: Setting chr sampled for pop ""<<(i+1)<<"" to ""<<newPop.getChrSampled()<<endl;
             newPop.setPopSize(dDefaultPopSize) ;
             newPop.setGrowthAlpha(dDefaultGrowthAlpha);
             newPop.setLastTime(0);
@@ -656,10 +656,10 @@ void Simulator::readInputParameters(CommandArguments arguments){
             }
             wrapper = EventPtr(new PopJoinEvent(
               Event::POPJOIN,dTime,iPop1,iPop2));
-            Rcpp::Rcerr<<""Population ""<<
-              arguments[iCurrentArg][2].data()<<
-                "" will merge with ""<<
-                  arguments[iCurrentArg][3].data()<<endl;
+            //Rcpp::Rcerr<<""Population ""<<
+            //  arguments[iCurrentArg][2].data()<<
+            //    "" will merge with ""<<
+            //      arguments[iCurrentArg][3].data()<<endl;
           }
           break;
         case 'm':"
gaynorr,AlphaSimR,a4b8ce7b2e06c9b9a3c3d69c140b5de1c310e6d8,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-08-10T13:04:26Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-08-10T13:04:26Z,Fixed bug in packHaplo,R/RcppExports.R;src/RcppExports.cpp;src/packHaplo.cpp,False,True,True,False,300,300,600,"---FILE: R/RcppExports.R---
@@ -1,14 +1,6 @@
 # Generated by using Rcpp::compileAttributes() -> do not edit by hand
 # Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393
 
-writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call('AlphaSimR_writeASGenotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
-}
-
-writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call('AlphaSimR_writeASHaplotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
-}
-
 gebvRR <- function(RRsol, pop) {
     .Call('AlphaSimR_gebvRR', PACKAGE = 'AlphaSimR', RRsol, pop)
 }
@@ -21,87 +13,6 @@ gebvSCA <- function(SCAsol, pop) {
     .Call('AlphaSimR_gebvSCA', PACKAGE = 'AlphaSimR', SCAsol, pop)
 }
 
-getGeno <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-getDomGeno <- function(geno) {
-    .Call('AlphaSimR_getDomGeno', PACKAGE = 'AlphaSimR', geno)
-}
-
-getHaplo <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
-    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
-}
-
-getGv <- function(trait, pop) {
-    .Call('AlphaSimR_getGv', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-calcGenParam <- function(trait, pop) {
-    .Call('AlphaSimR_calcGenParam', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-getHybridGv <- function(trait, motherGeno, mother, fatherGeno, father) {
-    .Call('AlphaSimR_getHybridGv', PACKAGE = 'AlphaSimR', trait, motherGeno, mother, fatherGeno, father)
-}
-
-cross2 <- function(motherGeno, mother, fatherGeno, father, genMaps, recombRatio) {
-    .Call('AlphaSimR_cross2', PACKAGE = 'AlphaSimR', motherGeno, mother, fatherGeno, father, genMaps, recombRatio)
-}
-
-createDH2 <- function(geno, nDH, genMaps, recombRatio, useFemale) {
-    .Call('AlphaSimR_createDH2', PACKAGE = 'AlphaSimR', geno, nDH, genMaps, recombRatio, useFemale)
-}
-
-crossPedigree <- function(founders, mother, father, genMaps) {
-    .Call('AlphaSimR_crossPedigree', PACKAGE = 'AlphaSimR', founders, mother, father, genMaps)
-}
-
-#' @title Population variance
-#' 
-#' @description
-#' Calculates the population variance matrix as 
-#' opposed to the sample variance matrix calculated 
-#' by \code{\link{var}}. i.e. divides by n instead 
-#' of n-1
-#' 
-#' @param X an n by m matrix
-#' 
-#' @return an m by m variance-covariance matrix
-#' 
-#' @export
-popVar <- function(X) {
-    .Call('AlphaSimR_popVar', PACKAGE = 'AlphaSimR', X)
-}
-
-mergeGeno <- function(x, y) {
-    .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
-}
-
-calcChrMinorFreq <- function(geno, ploidy) {
-    .Call('AlphaSimR_calcChrMinorFreq', PACKAGE = 'AlphaSimR', geno, ploidy)
-}
-
-convToImat <- function(X) {
-    .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
-}
-
-sampAllComb <- function(nLevel1, nLevel2, n) {
-    .Call('AlphaSimR_sampAllComb', PACKAGE = 'AlphaSimR', nLevel1, nLevel2, n)
-}
-
-sampHalfDialComb <- function(nLevel, n) {
-    .Call('AlphaSimR_sampHalfDialComb', PACKAGE = 'AlphaSimR', nLevel, n)
-}
-
-changeId <- function(newId, oldId) {
-    invisible(.Call('AlphaSimR_changeId', PACKAGE = 'AlphaSimR', newId, oldId))
-}
-
 #' @title Read Matrix
 #' 
 #' @description
@@ -264,6 +175,95 @@ gaussKernel <- function(D, theta) {
     .Call('AlphaSimR_gaussKernel', PACKAGE = 'AlphaSimR', D, theta)
 }
 
+writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call('AlphaSimR_writeASGenotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
+}
+
+writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call('AlphaSimR_writeASHaplotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
+}
+
+getGeno <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+getDomGeno <- function(geno) {
+    .Call('AlphaSimR_getDomGeno', PACKAGE = 'AlphaSimR', geno)
+}
+
+getHaplo <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
+    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
+}
+
+getGv <- function(trait, pop) {
+    .Call('AlphaSimR_getGv', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+calcGenParam <- function(trait, pop) {
+    .Call('AlphaSimR_calcGenParam', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+getHybridGv <- function(trait, motherGeno, mother, fatherGeno, father) {
+    .Call('AlphaSimR_getHybridGv', PACKAGE = 'AlphaSimR', trait, motherGeno, mother, fatherGeno, father)
+}
+
+cross2 <- function(motherGeno, mother, fatherGeno, father, genMaps, recombRatio) {
+    .Call('AlphaSimR_cross2', PACKAGE = 'AlphaSimR', motherGeno, mother, fatherGeno, father, genMaps, recombRatio)
+}
+
+createDH2 <- function(geno, nDH, genMaps, recombRatio, useFemale) {
+    .Call('AlphaSimR_createDH2', PACKAGE = 'AlphaSimR', geno, nDH, genMaps, recombRatio, useFemale)
+}
+
+crossPedigree <- function(founders, mother, father, genMaps) {
+    .Call('AlphaSimR_crossPedigree', PACKAGE = 'AlphaSimR', founders, mother, father, genMaps)
+}
+
+#' @title Population variance
+#' 
+#' @description
+#' Calculates the population variance matrix as 
+#' opposed to the sample variance matrix calculated 
+#' by \code{\link{var}}. i.e. divides by n instead 
+#' of n-1
+#' 
+#' @param X an n by m matrix
+#' 
+#' @return an m by m variance-covariance matrix
+#' 
+#' @export
+popVar <- function(X) {
+    .Call('AlphaSimR_popVar', PACKAGE = 'AlphaSimR', X)
+}
+
+mergeGeno <- function(x, y) {
+    .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
+}
+
+calcChrMinorFreq <- function(geno, ploidy) {
+    .Call('AlphaSimR_calcChrMinorFreq', PACKAGE = 'AlphaSimR', geno, ploidy)
+}
+
+convToImat <- function(X) {
+    .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
+}
+
+sampAllComb <- function(nLevel1, nLevel2, n) {
+    .Call('AlphaSimR_sampAllComb', PACKAGE = 'AlphaSimR', nLevel1, nLevel2, n)
+}
+
+sampHalfDialComb <- function(nLevel, n) {
+    .Call('AlphaSimR_sampHalfDialComb', PACKAGE = 'AlphaSimR', nLevel, n)
+}
+
+changeId <- function(newId, oldId) {
+    invisible(.Call('AlphaSimR_changeId', PACKAGE = 'AlphaSimR', newId, oldId))
+}
+
 packHaplo <- function(haplo, ploidy, inbred) {
     .Call('AlphaSimR_packHaplo', PACKAGE = 'AlphaSimR', haplo, ploidy, inbred)
 }

---FILE: src/RcppExports.cpp---
@@ -6,38 +6,6 @@
 
 using namespace Rcpp;
 
-// writeASGenotypes
-void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
-END_RCPP
-}
-// writeASHaplotypes
-void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
-RcppExport SEXP AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
-    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
-    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
-    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
-    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
-    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
-    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
-    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
-    return R_NilValue;
-END_RCPP
-}
 // gebvRR
 arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
 RcppExport SEXP AlphaSimR_gebvRR(SEXP RRsolSEXP, SEXP popSEXP) {
@@ -75,6 +43,216 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// readMat
+arma::mat readMat(std::string fileName, int rows, int cols, char sep, int skipRows, int skipCols);
+RcppExport SEXP AlphaSimR_readMat(SEXP fileNameSEXP, SEXP rowsSEXP, SEXP colsSEXP, SEXP sepSEXP, SEXP skipRowsSEXP, SEXP skipColsSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< std::string >::type fileName(fileNameSEXP);
+    Rcpp::traits::input_parameter< int >::type rows(rowsSEXP);
+    Rcpp::traits::input_parameter< int >::type cols(colsSEXP);
+    Rcpp::traits::input_parameter< char >::type sep(sepSEXP);
+    Rcpp::traits::input_parameter< int >::type skipRows(skipRowsSEXP);
+    Rcpp::traits::input_parameter< int >::type skipCols(skipColsSEXP);
+    rcpp_result_gen = Rcpp::wrap(readMat(fileName, rows, cols, sep, skipRows, skipCols));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveUVM
+Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
+RcppExport SEXP AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMVM
+Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol);
+RcppExport SEXP AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMKM
+Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist);
+RcppExport SEXP AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP
+Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_MV
+Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_GCA
+Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_SCA
+Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcG
+arma::mat calcG(arma::mat X);
+RcppExport SEXP AlphaSimR_calcG(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcG(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcGIbs
+arma::mat calcGIbs(arma::mat X);
+RcppExport SEXP AlphaSimR_calcGIbs(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcGIbs(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// fastDist
+arma::mat fastDist(const arma::mat& X);
+RcppExport SEXP AlphaSimR_fastDist(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(fastDist(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// fastPairDist
+arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y);
+RcppExport SEXP AlphaSimR_fastPairDist(SEXP XSEXP, SEXP YSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    rcpp_result_gen = Rcpp::wrap(fastPairDist(X, Y));
+    return rcpp_result_gen;
+END_RCPP
+}
+// gaussKernel
+arma::mat gaussKernel(arma::mat& D, double theta);
+RcppExport SEXP AlphaSimR_gaussKernel(SEXP DSEXP, SEXP thetaSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type D(DSEXP);
+    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
+    rcpp_result_gen = Rcpp::wrap(gaussKernel(D, theta));
+    return rcpp_result_gen;
+END_RCPP
+}
+// writeASGenotypes
+void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
+END_RCPP
+}
+// writeASHaplotypes
+void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
+END_RCPP
+}
 // getGeno
 arma::Mat<unsigned char> getGeno(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
 RcppExport SEXP AlphaSimR_getGeno(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
@@ -292,184 +470,6 @@ BEGIN_RCPP
     return R_NilValue;
 END_RCPP
 }
-// readMat
-arma::mat readMat(std::string fileName, int rows, int cols, char sep, int skipRows, int skipCols);
-RcppExport SEXP AlphaSimR_readMat(SEXP fileNameSEXP, SEXP rowsSEXP, SEXP colsSEXP, SEXP sepSEXP, SEXP skipRowsSEXP, SEXP skipColsSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< std::string >::type fileName(fileNameSEXP);
-    Rcpp::traits::input_parameter< int >::type rows(rowsSEXP);
-    Rcpp::traits::input_parameter< int >::type cols(colsSEXP);
-    Rcpp::traits::input_parameter< char >::type sep(sepSEXP);
-    Rcpp::traits::input_parameter< int >::type skipRows(skipRowsSEXP);
-    Rcpp::traits::input_parameter< int >::type skipCols(skipColsSEXP);
-    rcpp_result_gen = Rcpp::wrap(readMat(fileName, rows, cols, sep, skipRows, skipCols));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveUVM
-Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
-RcppExport SEXP AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMVM
-Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol);
-RcppExport SEXP AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMKM
-Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist);
-RcppExport SEXP AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP
-Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_MV
-Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_GCA
-Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_SCA
-Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcG
-arma::mat calcG(arma::mat X);
-RcppExport SEXP AlphaSimR_calcG(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcG(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcGIbs
-arma::mat calcGIbs(arma::mat X);
-RcppExport SEXP AlphaSimR_calcGIbs(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcGIbs(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// fastDist
-arma::mat fastDist(const arma::mat& X);
-RcppExport SEXP AlphaSimR_fastDist(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(fastDist(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// fastPairDist
-arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y);
-RcppExport SEXP AlphaSimR_fastPairDist(SEXP XSEXP, SEXP YSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    rcpp_result_gen = Rcpp::wrap(fastPairDist(X, Y));
-    return rcpp_result_gen;
-END_RCPP
-}
-// gaussKernel
-arma::mat gaussKernel(arma::mat& D, double theta);
-RcppExport SEXP AlphaSimR_gaussKernel(SEXP DSEXP, SEXP thetaSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type D(DSEXP);
-    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
-    rcpp_result_gen = Rcpp::wrap(gaussKernel(D, theta));
-    return rcpp_result_gen;
-END_RCPP
-}
 // packHaplo
 arma::Cube<unsigned char> packHaplo(arma::Mat<unsigned char>& haplo, arma::uword ploidy, bool inbred);
 RcppExport SEXP AlphaSimR_packHaplo(SEXP haploSEXP, SEXP ploidySEXP, SEXP inbredSEXP) {

---FILE: src/packHaplo.cpp---
@@ -11,7 +11,7 @@ arma::Cube<unsigned char> packHaplo(arma::Mat<unsigned char>& haplo,
     if(haplo.n_rows%ploidy != 0){
       Rcpp::stop(""Number of rows not a factor of ploidy"");
     }
-    nInd = haplo.n_cols/ploidy;
+    nInd = haplo.n_rows/ploidy;
   }
   arma::uword nLoci = haplo.n_cols;
   arma::Cube<unsigned char> output(nLoci,ploidy,nInd);"
gaynorr,AlphaSimR,6fffaf4b9576cf800fb14cab2f28be43b0ffe57c,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-08-07T10:16:34Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-08-07T10:16:34Z,Fixed bug in resetPop,R/Class-Pop.R;src/MME.cpp,False,True,True,False,4,4,8,"---FILE: R/Class-Pop.R---
@@ -354,7 +354,7 @@ resetPop = function(pop,simParam){
       tmp = getGv(simParam@traits[[i]],pop)
       pop@gv[,i] = tmp[[1]]
       if(length(tmp)>1){
-        pop@gxe[[i]] = tmp[2]
+        pop@gxe[[i]] = tmp[[2]]
       }
     }
   }

---FILE: src/MME.cpp---
@@ -407,7 +407,7 @@ Rcpp::List solveMKM(arma::mat& y, arma::mat& X,
   sigma.fill(var(y.col(0)));
   for(arma::uword cycle=0; cycle<maxcyc; ++cycle){
     W = V(0)*sigma(0);
-    for(int i=1; i<k; ++i){
+    for(arma::uword i=1; i<k; ++i){
       W += V(i)*sigma(i);
     }
     W = inv_sympd(W);
@@ -425,12 +425,12 @@ Rcpp::List solveMKM(arma::mat& y, arma::mat& X,
       llik0 = llik;
     deltaLlik = llik - llik0;
     llik0 = llik;
-    for(int i=0; i<k; ++i){
+    for(arma::uword i=0; i<k; ++i){
       T(i) = WQX*V(i);
     }
     for(arma::uword i=0; i<k; ++i){
       qvec(i) = as_scalar(y.t()*T(i)*WQX*y - sum(T(i).diag()));
-      for(int j=0; j<k; ++j){
+      for(arma::uword j=0; j<k; ++j){
         A(i,j) = accu(T(i)%T(j).t());
       }
     }"
gaynorr,AlphaSimR,7844a5488955bce314b90a924677c0d5d94e6249,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-07-17T12:38:16Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-07-17T12:38:16Z,Fixed bug in calcGCA,DESCRIPTION;R/RcppExports.R;R/hybrids.R;src/RcppExports.cpp,False,True,True,False,320,308,628,"---FILE: DESCRIPTION---
@@ -1,7 +1,7 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 0.2.3
+Version: 0.2.4
 Author: Chris Gaynor
 Maintainer: Chris Gaynor <gaynor.robert@hotmail.com>
 Description: This package contains classes and functions for simulating plant and animal breeding programs.

---FILE: R/RcppExports.R---
@@ -5,22 +5,6 @@ AlphaFormatter <- function() {
     .Call('AlphaSimR_AlphaFormatter', PACKAGE = 'AlphaSimR')
 }
 
-writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call('AlphaSimR_writeASGenotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
-}
-
-writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
-    invisible(.Call('AlphaSimR_writeASHaplotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
-}
-
-calcPopGC <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_calcPopGC', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-calcPopGIbsC <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_calcPopGIbsC', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
 gebvRR <- function(RRsol, pop) {
     .Call('AlphaSimR_gebvRR', PACKAGE = 'AlphaSimR', RRsol, pop)
 }
@@ -33,94 +17,6 @@ gebvSCA <- function(SCAsol, pop) {
     .Call('AlphaSimR_gebvSCA', PACKAGE = 'AlphaSimR', SCAsol, pop)
 }
 
-getGeno <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-getDomGeno <- function(geno) {
-    .Call('AlphaSimR_getDomGeno', PACKAGE = 'AlphaSimR', geno)
-}
-
-getHaplo <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
-    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
-}
-
-getGvA <- function(trait, pop) {
-    .Call('AlphaSimR_getGvA', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-getGvAG <- function(trait, pop, z) {
-    .Call('AlphaSimR_getGvAG', PACKAGE = 'AlphaSimR', trait, pop, z)
-}
-
-getGvAD <- function(trait, pop) {
-    .Call('AlphaSimR_getGvAD', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-getGvADG <- function(trait, pop, z) {
-    .Call('AlphaSimR_getGvADG', PACKAGE = 'AlphaSimR', trait, pop, z)
-}
-
-calcGenParam <- function(trait, pop) {
-    .Call('AlphaSimR_calcGenParam', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-getHybridGvA <- function(trait, fPop, fPar, mPop, mPar) {
-    .Call('AlphaSimR_getHybridGvA', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar)
-}
-
-getHybridGvAG <- function(trait, fPop, fPar, mPop, mPar, z) {
-    .Call('AlphaSimR_getHybridGvAG', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar, z)
-}
-
-getHybridGvAD <- function(trait, fPop, fPar, mPop, mPar) {
-    .Call('AlphaSimR_getHybridGvAD', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar)
-}
-
-getHybridGvADG <- function(trait, fPop, fPar, mPop, mPar, z) {
-    .Call('AlphaSimR_getHybridGvADG', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar, z)
-}
-
-cross2 <- function(fGeno, fPar, mGeno, mPar, genMaps) {
-    .Call('AlphaSimR_cross2', PACKAGE = 'AlphaSimR', fGeno, fPar, mGeno, mPar, genMaps)
-}
-
-createDH2 <- function(geno, nDH, genMaps) {
-    .Call('AlphaSimR_createDH2', PACKAGE = 'AlphaSimR', geno, nDH, genMaps)
-}
-
-crossPedigree <- function(founders, fPar, mPar, genMaps) {
-    .Call('AlphaSimR_crossPedigree', PACKAGE = 'AlphaSimR', founders, fPar, mPar, genMaps)
-}
-
-popVar <- function(X) {
-    .Call('AlphaSimR_popVar', PACKAGE = 'AlphaSimR', X)
-}
-
-mergeGeno <- function(x, y) {
-    .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
-}
-
-calcChrMinorFreq <- function(geno, ploidy) {
-    .Call('AlphaSimR_calcChrMinorFreq', PACKAGE = 'AlphaSimR', geno, ploidy)
-}
-
-convToImat <- function(X) {
-    .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
-}
-
-sampAllComb <- function(nLevel1, nLevel2, n) {
-    .Call('AlphaSimR_sampAllComb', PACKAGE = 'AlphaSimR', nLevel1, nLevel2, n)
-}
-
-sampHalfDialComb <- function(nLevel, n) {
-    .Call('AlphaSimR_sampHalfDialComb', PACKAGE = 'AlphaSimR', nLevel, n)
-}
-
 #' @title Solve Univariate Model
 #' 
 #' @description
@@ -262,6 +158,110 @@ gaussKernel <- function(D, theta) {
     .Call('AlphaSimR_gaussKernel', PACKAGE = 'AlphaSimR', D, theta)
 }
 
+writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call('AlphaSimR_writeASGenotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
+}
+
+writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call('AlphaSimR_writeASHaplotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
+}
+
+calcPopGC <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_calcPopGC', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+calcPopGIbsC <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_calcPopGIbsC', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+getGeno <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+getDomGeno <- function(geno) {
+    .Call('AlphaSimR_getDomGeno', PACKAGE = 'AlphaSimR', geno)
+}
+
+getHaplo <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
+    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
+}
+
+getGvA <- function(trait, pop) {
+    .Call('AlphaSimR_getGvA', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+getGvAG <- function(trait, pop, z) {
+    .Call('AlphaSimR_getGvAG', PACKAGE = 'AlphaSimR', trait, pop, z)
+}
+
+getGvAD <- function(trait, pop) {
+    .Call('AlphaSimR_getGvAD', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+getGvADG <- function(trait, pop, z) {
+    .Call('AlphaSimR_getGvADG', PACKAGE = 'AlphaSimR', trait, pop, z)
+}
+
+calcGenParam <- function(trait, pop) {
+    .Call('AlphaSimR_calcGenParam', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+getHybridGvA <- function(trait, fPop, fPar, mPop, mPar) {
+    .Call('AlphaSimR_getHybridGvA', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar)
+}
+
+getHybridGvAG <- function(trait, fPop, fPar, mPop, mPar, z) {
+    .Call('AlphaSimR_getHybridGvAG', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar, z)
+}
+
+getHybridGvAD <- function(trait, fPop, fPar, mPop, mPar) {
+    .Call('AlphaSimR_getHybridGvAD', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar)
+}
+
+getHybridGvADG <- function(trait, fPop, fPar, mPop, mPar, z) {
+    .Call('AlphaSimR_getHybridGvADG', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar, z)
+}
+
+cross2 <- function(fGeno, fPar, mGeno, mPar, genMaps) {
+    .Call('AlphaSimR_cross2', PACKAGE = 'AlphaSimR', fGeno, fPar, mGeno, mPar, genMaps)
+}
+
+createDH2 <- function(geno, nDH, genMaps) {
+    .Call('AlphaSimR_createDH2', PACKAGE = 'AlphaSimR', geno, nDH, genMaps)
+}
+
+crossPedigree <- function(founders, fPar, mPar, genMaps) {
+    .Call('AlphaSimR_crossPedigree', PACKAGE = 'AlphaSimR', founders, fPar, mPar, genMaps)
+}
+
+popVar <- function(X) {
+    .Call('AlphaSimR_popVar', PACKAGE = 'AlphaSimR', X)
+}
+
+mergeGeno <- function(x, y) {
+    .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
+}
+
+calcChrMinorFreq <- function(geno, ploidy) {
+    .Call('AlphaSimR_calcChrMinorFreq', PACKAGE = 'AlphaSimR', geno, ploidy)
+}
+
+convToImat <- function(X) {
+    .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
+}
+
+sampAllComb <- function(nLevel1, nLevel2, n) {
+    .Call('AlphaSimR_sampAllComb', PACKAGE = 'AlphaSimR', nLevel1, nLevel2, n)
+}
+
+sampHalfDialComb <- function(nLevel, n) {
+    .Call('AlphaSimR_sampHalfDialComb', PACKAGE = 'AlphaSimR', nLevel, n)
+}
+
 readAF <- function(nInd, segSites, ploidy, keep, inbred) {
     .Call('AlphaSimR_readAF', PACKAGE = 'AlphaSimR', nInd, segSites, ploidy, keep, inbred)
 }

---FILE: R/hybrids.R---
@@ -147,11 +147,23 @@ calcGCA = function(pop,use=""pheno""){
   colnames(females) = colnames(males) = colnames(y)
   for(i in 1:pop@nTraits){
     #Calculate female GCA
-    ans = lm(y[,i]~female+male-1,contrasts=list(male=""contr.sum""))
-    females[,i] = coef(ans)[1:length(unique(female))]
+    if(length(unique(male))==1){
+      females[,i] = y[,i]
+    }else if(length(unique(female))==1){
+      females[,i] = mean(y[,i])
+    }else{
+      ans = lm(y[,i]~female+male-1,contrasts=list(male=""contr.sum""))
+      females[,i] = coef(ans)[1:length(unique(female))]
+    }
     #Calculate male GCA
-    ans = lm(y[,i]~male+female-1,contrasts=list(female=""contr.sum""))
-    males[,i] = coef(ans)[1:length(unique(male))]
+    if(length(unique(female))==1){
+      males[,i] = y[,i]
+    }else if(length(unique(male))==1){
+      males[,i] = mean(y[,i])
+    }else{
+      ans = lm(y[,i]~male+female-1,contrasts=list(female=""contr.sum""))
+      males[,i] = coef(ans)[1:length(unique(male))]
+    }
   }
   #Create output
   output = list()

---FILE: src/RcppExports.cpp---
@@ -16,6 +16,205 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// gebvRR
+arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
+RcppExport SEXP AlphaSimR_gebvRR(SEXP RRsolSEXP, SEXP popSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type RRsol(RRsolSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
+    rcpp_result_gen = Rcpp::wrap(gebvRR(RRsol, pop));
+    return rcpp_result_gen;
+END_RCPP
+}
+// gebvGCA
+arma::mat gebvGCA(const Rcpp::S4& GCAsol, const Rcpp::S4& pop, bool female);
+RcppExport SEXP AlphaSimR_gebvGCA(SEXP GCAsolSEXP, SEXP popSEXP, SEXP femaleSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type GCAsol(GCAsolSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
+    Rcpp::traits::input_parameter< bool >::type female(femaleSEXP);
+    rcpp_result_gen = Rcpp::wrap(gebvGCA(GCAsol, pop, female));
+    return rcpp_result_gen;
+END_RCPP
+}
+// gebvSCA
+arma::mat gebvSCA(const Rcpp::S4& SCAsol, const Rcpp::S4& pop);
+RcppExport SEXP AlphaSimR_gebvSCA(SEXP SCAsolSEXP, SEXP popSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type SCAsol(SCAsolSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
+    rcpp_result_gen = Rcpp::wrap(gebvSCA(SCAsol, pop));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveUVM
+Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
+RcppExport SEXP AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMVM
+Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol);
+RcppExport SEXP AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMKM
+Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist);
+RcppExport SEXP AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP
+Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_MV
+Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_GCA
+Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_SCA
+Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcG
+arma::mat calcG(arma::mat X);
+RcppExport SEXP AlphaSimR_calcG(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcG(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcGIbs
+arma::mat calcGIbs(arma::mat X);
+RcppExport SEXP AlphaSimR_calcGIbs(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcGIbs(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// fastDist
+arma::mat fastDist(const arma::mat& X);
+RcppExport SEXP AlphaSimR_fastDist(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(fastDist(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// fastPairDist
+arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y);
+RcppExport SEXP AlphaSimR_fastPairDist(SEXP XSEXP, SEXP YSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    rcpp_result_gen = Rcpp::wrap(fastPairDist(X, Y));
+    return rcpp_result_gen;
+END_RCPP
+}
+// gaussKernel
+arma::mat gaussKernel(arma::mat& D, double theta);
+RcppExport SEXP AlphaSimR_gaussKernel(SEXP DSEXP, SEXP thetaSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type D(DSEXP);
+    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
+    rcpp_result_gen = Rcpp::wrap(gaussKernel(D, theta));
+    return rcpp_result_gen;
+END_RCPP
+}
 // writeASGenotypes
 void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
 RcppExport SEXP AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
@@ -74,43 +273,6 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// gebvRR
-arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
-RcppExport SEXP AlphaSimR_gebvRR(SEXP RRsolSEXP, SEXP popSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type RRsol(RRsolSEXP);
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
-    rcpp_result_gen = Rcpp::wrap(gebvRR(RRsol, pop));
-    return rcpp_result_gen;
-END_RCPP
-}
-// gebvGCA
-arma::mat gebvGCA(const Rcpp::S4& GCAsol, const Rcpp::S4& pop, bool female);
-RcppExport SEXP AlphaSimR_gebvGCA(SEXP GCAsolSEXP, SEXP popSEXP, SEXP femaleSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type GCAsol(GCAsolSEXP);
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
-    Rcpp::traits::input_parameter< bool >::type female(femaleSEXP);
-    rcpp_result_gen = Rcpp::wrap(gebvGCA(GCAsol, pop, female));
-    return rcpp_result_gen;
-END_RCPP
-}
-// gebvSCA
-arma::mat gebvSCA(const Rcpp::S4& SCAsol, const Rcpp::S4& pop);
-RcppExport SEXP AlphaSimR_gebvSCA(SEXP SCAsolSEXP, SEXP popSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type SCAsol(SCAsolSEXP);
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
-    rcpp_result_gen = Rcpp::wrap(gebvSCA(SCAsol, pop));
-    return rcpp_result_gen;
-END_RCPP
-}
 // getGeno
 arma::Mat<unsigned char> getGeno(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
 RcppExport SEXP AlphaSimR_getGeno(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
@@ -399,168 +561,6 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// solveUVM
-Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
-RcppExport SEXP AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMVM
-Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol);
-RcppExport SEXP AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMKM
-Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist);
-RcppExport SEXP AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP
-Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_MV
-Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_GCA
-Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_SCA
-Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcG
-arma::mat calcG(arma::mat X);
-RcppExport SEXP AlphaSimR_calcG(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcG(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcGIbs
-arma::mat calcGIbs(arma::mat X);
-RcppExport SEXP AlphaSimR_calcGIbs(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcGIbs(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// fastDist
-arma::mat fastDist(const arma::mat& X);
-RcppExport SEXP AlphaSimR_fastDist(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(fastDist(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// fastPairDist
-arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y);
-RcppExport SEXP AlphaSimR_fastPairDist(SEXP XSEXP, SEXP YSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    rcpp_result_gen = Rcpp::wrap(fastPairDist(X, Y));
-    return rcpp_result_gen;
-END_RCPP
-}
-// gaussKernel
-arma::mat gaussKernel(arma::mat& D, double theta);
-RcppExport SEXP AlphaSimR_gaussKernel(SEXP DSEXP, SEXP thetaSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type D(DSEXP);
-    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
-    rcpp_result_gen = Rcpp::wrap(gaussKernel(D, theta));
-    return rcpp_result_gen;
-END_RCPP
-}
 // readAF
 arma::Cube<unsigned char> readAF(int nInd, int segSites, int ploidy, arma::uvec keep, bool inbred);
 RcppExport SEXP AlphaSimR_readAF(SEXP nIndSEXP, SEXP segSitesSEXP, SEXP ploidySEXP, SEXP keepSEXP, SEXP inbredSEXP) {"
gaynorr,AlphaSimR,506cf92429f188bf2d0aa1dfe71651bfb5667189,MONEY Daniel,Daniel.Money@roslin.ed.ac.uk,2017-06-15T14:25:51Z,MONEY Daniel,Daniel.Money@roslin.ed.ac.uk,2017-06-15T14:25:51Z,Minor bug fix (no idea what was going on there but moving the formatting of names from R to C seems to have fixed it),R/AlphaSuite.R;src/alphaSuite.cpp,False,True,True,False,8,4,12,"---FILE: R/AlphaSuite.R---
@@ -26,7 +26,7 @@ writeAlphaGenotypes = function(pop,file,chr=1,chips=rep(0,pop@nInd),simParam=SIM
     positions[[i]] = params@snpChips[[i]]@lociLoc[start:end]
   }
 
-  writeASGenotypes(pop@geno[[chr]],positions,allSnps,chips,sprintf(""%s"",newpop@id),'9',normalizePath(file, mustWork=FALSE))
+  writeASGenotypes(pop@geno[[chr]],positions,allSnps,chips,newpop@id,'9',normalizePath(file, mustWork=FALSE))
 }
 
 #' @export

---FILE: src/alphaSuite.cpp---
@@ -14,7 +14,8 @@ void writeASGenotypes(const arma::Cube<unsigned char> & g,
   
   std::ofstream ASout;
   ASout.open(fname, std::ios::trunc);
-  
+
+  char name[20];
   for (int i = 0; i < snpchips.n_rows; i++){
     arma::Col<unsigned char> all0 = g.slice(i).col(0);
     arma::Col<unsigned char> all1 = g.slice(i).col(1);
@@ -32,7 +33,8 @@ void writeASGenotypes(const arma::Cube<unsigned char> & g,
     
     arma::Col<unsigned char> selectedg = selected0 + selected1;
     
-    ASout << names[i];
+    std::sprintf(name,""%20s"",names[i].c_str());
+    ASout << name;
     
     if (snpchips(i) == 0) {
       for (int k = 0; k < allLocations.n_rows; k++) {
@@ -71,11 +73,13 @@ void writeASHaplotypes(const arma::Cube<unsigned char> & g,
   std::ofstream ASout;
   ASout.open(fname, std::ios::trunc);
   
+  char name[20];
   for (int i = 0; i < snpchips.n_rows; i++){
     for (int j = 0; j < 2; j ++){
       arma::Col<unsigned char> all = g.slice(i).col(j);
 
-      ASout << names[i];
+      std::sprintf(name,""%20s"",names[i].c_str());
+      ASout << name;
 
       if (snpchips(i) == 0) {
         arma::Col<unsigned char> selected = all.elem(allLocations - 1);"
gaynorr,AlphaSimR,ed7ea2ae8522a006da7558fea3d5d6e1fdc140f5,MONEY Daniel,Daniel.Money@roslin.ed.ac.uk,2017-06-15T13:07:17Z,MONEY Daniel,Daniel.Money@roslin.ed.ac.uk,2017-06-15T13:07:17Z,"Rewrite write Alpha genotypes and haplotypes to use c - so much faster than R and can cope with very big matrices.  Still need to comment, put error checks in etc but it works.",R/AlphaSuite.R;R/RcppExports.R;R/pedigree.R;R/pullGeno.R;src/RcppExports.cpp;src/alphaSuite.cpp,False,True,True,False,540,293,833,"---FILE: R/AlphaSuite.R---
@@ -1,13 +1,61 @@
 #' @export
-writeAlphaGenotypes = function(pop,file,chips,simParam=SIMPARAM) {
-  genotypes = AlphaSimR::pullMultipleSnpGeno(pop,chips,simParam=simParam)
-  names = sprintf(""%20i"",1:pop@nInd)
-  write.table(genotypes,file=file,quote=FALSE,row.names=names,col.names=FALSE)
+writeAlphaGenotypes = function(pop,file,chr=1,chips=rep(0,pop@nInd),simParam=SIMPARAM) {
+  allSnps = numeric(0)
+  uniqueChips = unique(chips)
+  if (0 %in% uniqueChips){
+    for (c in 1:simParam@nSnpChips) {
+      allSnps = sort(union(allSnps,simParam@snpChips[[c]]@lociLoc))
+    }
+  }
+  else {
+    for (c in uniqueChips){
+      allSnps = sort(union(allSnps,simParam@snpChips[[c]]@lociLoc))
+    }
+  }
+  
+  positions = list()
+  for (i in 1:simParam@nSnpChips) {
+    start = 1
+    end = params@snpChips[[i]]@lociPerChr[1]
+    if (chr > 1) {
+      for (j in 2:chr) {
+        start = start + params@snpChips[[i]]@lociPerChr[j-1]
+        end = end + params@snpChips[[i]]@lociPerChr[j]
+      }
+    }
+    positions[[i]] = params@snpChips[[i]]@lociLoc[start:end]
+  }
+
+  writeASGenotypes(pop@geno[[chr]],positions,allSnps,chips,sprintf(""%s"",newpop@id),'9',normalizePath(file, mustWork=FALSE))
 }
 
 #' @export
-writeAlphaHaplotypes = function(pop,file,chips,simParam=SIMPARAM) {
-  haplotypes = AlphaSimR::pullMultipleSnpHaplo(pop,chips,simParam=simParam)
-  names = sprintf(""%20i"",rep(1:pop@nInd,each=2))
-  write.table(haplotypes,file=file,quote=FALSE,row.names=names,col.names=FALSE)
+writeAlphaHaplotypes = function(pop,file,chr=1,chips=rep(0,pop@nInd),simParam=SIMPARAM) {
+  allSnps = numeric(0)
+  uniqueChips = unique(chips)
+  if (0 %in% uniqueChips){
+    for (c in 1:simParam@nSnpChips) {
+      allSnps = sort(union(allSnps,simParam@snpChips[[c]]@lociLoc))
+    }
+  }
+  else {
+    for (c in uniqueChips){
+      allSnps = sort(union(allSnps,simParam@snpChips[[c]]@lociLoc))
+    }
+  }
+
+  positions = list()
+  for (i in 1:simParam@nSnpChips) {
+    start = 1
+    end = params@snpChips[[i]]@lociPerChr[1]
+    if (chr > 1) {
+      for (j in 2:chr) {
+        start = start + params@snpChips[[i]]@lociPerChr[j-1]
+        end = end + params@snpChips[[i]]@lociPerChr[j]
+      }
+    }
+    positions[[i]] = params@snpChips[[i]]@lociLoc[start:end]
+  }
+
+  writeASHaplotypes(pop@geno[[chr]],positions,allSnps,chips,sprintf(""%s"",newpop@id),'9',normalizePath(file, mustWork=FALSE))
 }
\ No newline at end of file

---FILE: R/RcppExports.R---
@@ -5,6 +5,22 @@ AlphaFormatter <- function() {
     .Call('AlphaSimR_AlphaFormatter', PACKAGE = 'AlphaSimR')
 }
 
+writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call('AlphaSimR_writeASGenotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
+}
+
+writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
+    invisible(.Call('AlphaSimR_writeASHaplotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
+}
+
+calcPopGC <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_calcPopGC', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+calcPopGIbsC <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_calcPopGIbsC', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
 gebvRR <- function(RRsol, pop) {
     .Call('AlphaSimR_gebvRR', PACKAGE = 'AlphaSimR', RRsol, pop)
 }
@@ -17,6 +33,94 @@ gebvSCA <- function(SCAsol, pop) {
     .Call('AlphaSimR_gebvSCA', PACKAGE = 'AlphaSimR', SCAsol, pop)
 }
 
+getGeno <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+getDomGeno <- function(geno) {
+    .Call('AlphaSimR_getDomGeno', PACKAGE = 'AlphaSimR', geno)
+}
+
+getHaplo <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
+    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
+}
+
+getGvA <- function(trait, pop) {
+    .Call('AlphaSimR_getGvA', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+getGvAG <- function(trait, pop, z) {
+    .Call('AlphaSimR_getGvAG', PACKAGE = 'AlphaSimR', trait, pop, z)
+}
+
+getGvAD <- function(trait, pop) {
+    .Call('AlphaSimR_getGvAD', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+getGvADG <- function(trait, pop, z) {
+    .Call('AlphaSimR_getGvADG', PACKAGE = 'AlphaSimR', trait, pop, z)
+}
+
+calcGenParam <- function(trait, pop) {
+    .Call('AlphaSimR_calcGenParam', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+getHybridGvA <- function(trait, fPop, fPar, mPop, mPar) {
+    .Call('AlphaSimR_getHybridGvA', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar)
+}
+
+getHybridGvAG <- function(trait, fPop, fPar, mPop, mPar, z) {
+    .Call('AlphaSimR_getHybridGvAG', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar, z)
+}
+
+getHybridGvAD <- function(trait, fPop, fPar, mPop, mPar) {
+    .Call('AlphaSimR_getHybridGvAD', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar)
+}
+
+getHybridGvADG <- function(trait, fPop, fPar, mPop, mPar, z) {
+    .Call('AlphaSimR_getHybridGvADG', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar, z)
+}
+
+cross2 <- function(fGeno, fPar, mGeno, mPar, genMaps) {
+    .Call('AlphaSimR_cross2', PACKAGE = 'AlphaSimR', fGeno, fPar, mGeno, mPar, genMaps)
+}
+
+createDH2 <- function(geno, nDH, genMaps) {
+    .Call('AlphaSimR_createDH2', PACKAGE = 'AlphaSimR', geno, nDH, genMaps)
+}
+
+crossPedigree <- function(founders, fPar, mPar, genMaps) {
+    .Call('AlphaSimR_crossPedigree', PACKAGE = 'AlphaSimR', founders, fPar, mPar, genMaps)
+}
+
+popVar <- function(X) {
+    .Call('AlphaSimR_popVar', PACKAGE = 'AlphaSimR', X)
+}
+
+mergeGeno <- function(x, y) {
+    .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
+}
+
+calcChrMinorFreq <- function(geno, ploidy) {
+    .Call('AlphaSimR_calcChrMinorFreq', PACKAGE = 'AlphaSimR', geno, ploidy)
+}
+
+convToImat <- function(X) {
+    .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
+}
+
+sampAllComb <- function(nLevel1, nLevel2, n) {
+    .Call('AlphaSimR_sampAllComb', PACKAGE = 'AlphaSimR', nLevel1, nLevel2, n)
+}
+
+sampHalfDialComb <- function(nLevel, n) {
+    .Call('AlphaSimR_sampHalfDialComb', PACKAGE = 'AlphaSimR', nLevel, n)
+}
+
 #' @title Solve Univariate Model
 #' 
 #' @description
@@ -158,102 +262,6 @@ gaussKernel <- function(D, theta) {
     .Call('AlphaSimR_gaussKernel', PACKAGE = 'AlphaSimR', D, theta)
 }
 
-calcPopGC <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_calcPopGC', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-calcPopGIbsC <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_calcPopGIbsC', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-getGeno <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-getDomGeno <- function(geno) {
-    .Call('AlphaSimR_getDomGeno', PACKAGE = 'AlphaSimR', geno)
-}
-
-getHaplo <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
-    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
-}
-
-getGvA <- function(trait, pop) {
-    .Call('AlphaSimR_getGvA', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-getGvAG <- function(trait, pop, z) {
-    .Call('AlphaSimR_getGvAG', PACKAGE = 'AlphaSimR', trait, pop, z)
-}
-
-getGvAD <- function(trait, pop) {
-    .Call('AlphaSimR_getGvAD', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-getGvADG <- function(trait, pop, z) {
-    .Call('AlphaSimR_getGvADG', PACKAGE = 'AlphaSimR', trait, pop, z)
-}
-
-calcGenParam <- function(trait, pop) {
-    .Call('AlphaSimR_calcGenParam', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-getHybridGvA <- function(trait, fPop, fPar, mPop, mPar) {
-    .Call('AlphaSimR_getHybridGvA', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar)
-}
-
-getHybridGvAG <- function(trait, fPop, fPar, mPop, mPar, z) {
-    .Call('AlphaSimR_getHybridGvAG', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar, z)
-}
-
-getHybridGvAD <- function(trait, fPop, fPar, mPop, mPar) {
-    .Call('AlphaSimR_getHybridGvAD', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar)
-}
-
-getHybridGvADG <- function(trait, fPop, fPar, mPop, mPar, z) {
-    .Call('AlphaSimR_getHybridGvADG', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar, z)
-}
-
-cross2 <- function(fGeno, fPar, mGeno, mPar, genMaps) {
-    .Call('AlphaSimR_cross2', PACKAGE = 'AlphaSimR', fGeno, fPar, mGeno, mPar, genMaps)
-}
-
-createDH2 <- function(geno, nDH, genMaps) {
-    .Call('AlphaSimR_createDH2', PACKAGE = 'AlphaSimR', geno, nDH, genMaps)
-}
-
-crossPedigree <- function(founders, fPar, mPar, genMaps) {
-    .Call('AlphaSimR_crossPedigree', PACKAGE = 'AlphaSimR', founders, fPar, mPar, genMaps)
-}
-
-popVar <- function(X) {
-    .Call('AlphaSimR_popVar', PACKAGE = 'AlphaSimR', X)
-}
-
-mergeGeno <- function(x, y) {
-    .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
-}
-
-calcChrMinorFreq <- function(geno, ploidy) {
-    .Call('AlphaSimR_calcChrMinorFreq', PACKAGE = 'AlphaSimR', geno, ploidy)
-}
-
-convToImat <- function(X) {
-    .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
-}
-
-sampAllComb <- function(nLevel1, nLevel2, n) {
-    .Call('AlphaSimR_sampAllComb', PACKAGE = 'AlphaSimR', nLevel1, nLevel2, n)
-}
-
-sampHalfDialComb <- function(nLevel, n) {
-    .Call('AlphaSimR_sampHalfDialComb', PACKAGE = 'AlphaSimR', nLevel, n)
-}
-
 readAF <- function(nInd, segSites, ploidy, keep, inbred) {
     .Call('AlphaSimR_readAF', PACKAGE = 'AlphaSimR', nInd, segSites, ploidy, keep, inbred)
 }

---FILE: R/pedigree.R---
@@ -15,7 +15,7 @@ loadPedigreeFromFile = function(pedname) {
   
   pedsize = nrow(fped)
   
-  ids = hashmap(keys=fped[,1], values = 1:pedsize)
+  ids = hashmap::hashmap(keys=fped[,1], values = 1:pedsize)
   ids$insert(""0"",0)
   
   numped = matrix(nrow=pedsize,ncol=2)

---FILE: R/pullGeno.R---
@@ -139,9 +139,9 @@ pullSnpHaplo = function(pop, snpChip=1, haplo=""all"",
 #' @export
 pullMultipleSnpHaplo = function(pop, chips, haplo=""all"", 
                                 missing = 9, simParam=SIMPARAM) {
+  stopifnot(length(chips) == pop@nInd)
   # I feel like the next line shouldn't be needed but I don't know
   # enough R! (dmoney)
-  stopifnot(length(chips) == pop@nInd)
   missing = as.integer(missing)
   allSnps = numeric(0)
   uniqueChips = unique(chips)

---FILE: src/RcppExports.cpp---
@@ -16,228 +16,98 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// gebvRR
-arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
-RcppExport SEXP AlphaSimR_gebvRR(SEXP RRsolSEXP, SEXP popSEXP) {
+// writeASGenotypes
+void writeASGenotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP AlphaSimR_writeASGenotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
 BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type RRsol(RRsolSEXP);
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
-    rcpp_result_gen = Rcpp::wrap(gebvRR(RRsol, pop));
-    return rcpp_result_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASGenotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
 END_RCPP
 }
-// gebvGCA
-arma::mat gebvGCA(const Rcpp::S4& GCAsol, const Rcpp::S4& pop, bool female);
-RcppExport SEXP AlphaSimR_gebvGCA(SEXP GCAsolSEXP, SEXP popSEXP, SEXP femaleSEXP) {
+// writeASHaplotypes
+void writeASHaplotypes(const arma::Cube<unsigned char>& g, const arma::field<arma::uvec>& locations, const arma::uvec& allLocations, const arma::vec& snpchips, const std::vector<std::string>& names, const char missing, const std::string fname);
+RcppExport SEXP AlphaSimR_writeASHaplotypes(SEXP gSEXP, SEXP locationsSEXP, SEXP allLocationsSEXP, SEXP snpchipsSEXP, SEXP namesSEXP, SEXP missingSEXP, SEXP fnameSEXP) {
 BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type GCAsol(GCAsolSEXP);
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
-    Rcpp::traits::input_parameter< bool >::type female(femaleSEXP);
-    rcpp_result_gen = Rcpp::wrap(gebvGCA(GCAsol, pop, female));
-    return rcpp_result_gen;
+    Rcpp::traits::input_parameter< const arma::Cube<unsigned char>& >::type g(gSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::uvec>& >::type locations(locationsSEXP);
+    Rcpp::traits::input_parameter< const arma::uvec& >::type allLocations(allLocationsSEXP);
+    Rcpp::traits::input_parameter< const arma::vec& >::type snpchips(snpchipsSEXP);
+    Rcpp::traits::input_parameter< const std::vector<std::string>& >::type names(namesSEXP);
+    Rcpp::traits::input_parameter< const char >::type missing(missingSEXP);
+    Rcpp::traits::input_parameter< const std::string >::type fname(fnameSEXP);
+    writeASHaplotypes(g, locations, allLocations, snpchips, names, missing, fname);
+    return R_NilValue;
 END_RCPP
 }
-// gebvSCA
-arma::mat gebvSCA(const Rcpp::S4& SCAsol, const Rcpp::S4& pop);
-RcppExport SEXP AlphaSimR_gebvSCA(SEXP SCAsolSEXP, SEXP popSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type SCAsol(SCAsolSEXP);
-    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
-    rcpp_result_gen = Rcpp::wrap(gebvSCA(SCAsol, pop));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveUVM
-Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
-RcppExport SEXP AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMVM
-Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol);
-RcppExport SEXP AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMKM
-Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist);
-RcppExport SEXP AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP
-Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_MV
-Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_GCA
-Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_SCA
-Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcG
-arma::mat calcG(arma::mat X);
-RcppExport SEXP AlphaSimR_calcG(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcG(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcGIbs
-arma::mat calcGIbs(arma::mat X);
-RcppExport SEXP AlphaSimR_calcGIbs(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcGIbs(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// fastDist
-arma::mat fastDist(const arma::mat& X);
-RcppExport SEXP AlphaSimR_fastDist(SEXP XSEXP) {
+// calcPopGC
+arma::fmat calcPopGC(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
+RcppExport SEXP AlphaSimR_calcPopGC(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(fastDist(X));
+    Rcpp::traits::input_parameter< const arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< const arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcPopGC(geno, lociPerChr, lociLoc));
     return rcpp_result_gen;
 END_RCPP
 }
-// fastPairDist
-arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y);
-RcppExport SEXP AlphaSimR_fastPairDist(SEXP XSEXP, SEXP YSEXP) {
+// calcPopGIbsC
+arma::fmat calcPopGIbsC(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
+RcppExport SEXP AlphaSimR_calcPopGIbsC(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    rcpp_result_gen = Rcpp::wrap(fastPairDist(X, Y));
+    Rcpp::traits::input_parameter< const arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< const arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcPopGIbsC(geno, lociPerChr, lociLoc));
     return rcpp_result_gen;
 END_RCPP
 }
-// gaussKernel
-arma::mat gaussKernel(arma::mat& D, double theta);
-RcppExport SEXP AlphaSimR_gaussKernel(SEXP DSEXP, SEXP thetaSEXP) {
+// gebvRR
+arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
+RcppExport SEXP AlphaSimR_gebvRR(SEXP RRsolSEXP, SEXP popSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type D(DSEXP);
-    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
-    rcpp_result_gen = Rcpp::wrap(gaussKernel(D, theta));
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type RRsol(RRsolSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
+    rcpp_result_gen = Rcpp::wrap(gebvRR(RRsol, pop));
     return rcpp_result_gen;
 END_RCPP
 }
-// calcPopGC
-arma::fmat calcPopGC(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
-RcppExport SEXP AlphaSimR_calcPopGC(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
+// gebvGCA
+arma::mat gebvGCA(const Rcpp::S4& GCAsol, const Rcpp::S4& pop, bool female);
+RcppExport SEXP AlphaSimR_gebvGCA(SEXP GCAsolSEXP, SEXP popSEXP, SEXP femaleSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< const arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcPopGC(geno, lociPerChr, lociLoc));
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type GCAsol(GCAsolSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
+    Rcpp::traits::input_parameter< bool >::type female(femaleSEXP);
+    rcpp_result_gen = Rcpp::wrap(gebvGCA(GCAsol, pop, female));
     return rcpp_result_gen;
 END_RCPP
 }
-// calcPopGIbsC
-arma::fmat calcPopGIbsC(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
-RcppExport SEXP AlphaSimR_calcPopGIbsC(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
+// gebvSCA
+arma::mat gebvSCA(const Rcpp::S4& SCAsol, const Rcpp::S4& pop);
+RcppExport SEXP AlphaSimR_gebvSCA(SEXP SCAsolSEXP, SEXP popSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< const arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcPopGIbsC(geno, lociPerChr, lociLoc));
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type SCAsol(SCAsolSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
+    rcpp_result_gen = Rcpp::wrap(gebvSCA(SCAsol, pop));
     return rcpp_result_gen;
 END_RCPP
 }
@@ -529,6 +399,168 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// solveUVM
+Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
+RcppExport SEXP AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMVM
+Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol);
+RcppExport SEXP AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMKM
+Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist);
+RcppExport SEXP AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP
+Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_MV
+Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_GCA
+Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_SCA
+Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcG
+arma::mat calcG(arma::mat X);
+RcppExport SEXP AlphaSimR_calcG(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcG(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcGIbs
+arma::mat calcGIbs(arma::mat X);
+RcppExport SEXP AlphaSimR_calcGIbs(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcGIbs(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// fastDist
+arma::mat fastDist(const arma::mat& X);
+RcppExport SEXP AlphaSimR_fastDist(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(fastDist(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// fastPairDist
+arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y);
+RcppExport SEXP AlphaSimR_fastPairDist(SEXP XSEXP, SEXP YSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    rcpp_result_gen = Rcpp::wrap(fastPairDist(X, Y));
+    return rcpp_result_gen;
+END_RCPP
+}
+// gaussKernel
+arma::mat gaussKernel(arma::mat& D, double theta);
+RcppExport SEXP AlphaSimR_gaussKernel(SEXP DSEXP, SEXP thetaSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type D(DSEXP);
+    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
+    rcpp_result_gen = Rcpp::wrap(gaussKernel(D, theta));
+    return rcpp_result_gen;
+END_RCPP
+}
 // readAF
 arma::Cube<unsigned char> readAF(int nInd, int segSites, int ploidy, arma::uvec keep, bool inbred);
 RcppExport SEXP AlphaSimR_readAF(SEXP nIndSEXP, SEXP segSitesSEXP, SEXP ploidySEXP, SEXP keepSEXP, SEXP inbredSEXP) {
@@ -571,3 +603,57 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+
+static const R_CallMethodDef CallEntries[] = {
+    {""AlphaSimR_AlphaFormatter"", (DL_FUNC) &AlphaSimR_AlphaFormatter, 0},
+    {""AlphaSimR_writeASGenotypes"", (DL_FUNC) &AlphaSimR_writeASGenotypes, 7},
+    {""AlphaSimR_writeASHaplotypes"", (DL_FUNC) &AlphaSimR_writeASHaplotypes, 7},
+    {""AlphaSimR_calcPopGC"", (DL_FUNC) &AlphaSimR_calcPopGC, 3},
+    {""AlphaSimR_calcPopGIbsC"", (DL_FUNC) &AlphaSimR_calcPopGIbsC, 3},
+    {""AlphaSimR_gebvRR"", (DL_FUNC) &AlphaSimR_gebvRR, 2},
+    {""AlphaSimR_gebvGCA"", (DL_FUNC) &AlphaSimR_gebvGCA, 3},
+    {""AlphaSimR_gebvSCA"", (DL_FUNC) &AlphaSimR_gebvSCA, 2},
+    {""AlphaSimR_getGeno"", (DL_FUNC) &AlphaSimR_getGeno, 3},
+    {""AlphaSimR_getDomGeno"", (DL_FUNC) &AlphaSimR_getDomGeno, 1},
+    {""AlphaSimR_getHaplo"", (DL_FUNC) &AlphaSimR_getHaplo, 3},
+    {""AlphaSimR_getOneHaplo"", (DL_FUNC) &AlphaSimR_getOneHaplo, 4},
+    {""AlphaSimR_getGvA"", (DL_FUNC) &AlphaSimR_getGvA, 2},
+    {""AlphaSimR_getGvAG"", (DL_FUNC) &AlphaSimR_getGvAG, 3},
+    {""AlphaSimR_getGvAD"", (DL_FUNC) &AlphaSimR_getGvAD, 2},
+    {""AlphaSimR_getGvADG"", (DL_FUNC) &AlphaSimR_getGvADG, 3},
+    {""AlphaSimR_calcGenParam"", (DL_FUNC) &AlphaSimR_calcGenParam, 2},
+    {""AlphaSimR_getHybridGvA"", (DL_FUNC) &AlphaSimR_getHybridGvA, 5},
+    {""AlphaSimR_getHybridGvAG"", (DL_FUNC) &AlphaSimR_getHybridGvAG, 6},
+    {""AlphaSimR_getHybridGvAD"", (DL_FUNC) &AlphaSimR_getHybridGvAD, 5},
+    {""AlphaSimR_getHybridGvADG"", (DL_FUNC) &AlphaSimR_getHybridGvADG, 6},
+    {""AlphaSimR_cross2"", (DL_FUNC) &AlphaSimR_cross2, 5},
+    {""AlphaSimR_createDH2"", (DL_FUNC) &AlphaSimR_createDH2, 3},
+    {""AlphaSimR_crossPedigree"", (DL_FUNC) &AlphaSimR_crossPedigree, 4},
+    {""AlphaSimR_popVar"", (DL_FUNC) &AlphaSimR_popVar, 1},
+    {""AlphaSimR_mergeGeno"", (DL_FUNC) &AlphaSimR_mergeGeno, 2},
+    {""AlphaSimR_calcChrMinorFreq"", (DL_FUNC) &AlphaSimR_calcChrMinorFreq, 2},
+    {""AlphaSimR_convToImat"", (DL_FUNC) &AlphaSimR_convToImat, 1},
+    {""AlphaSimR_sampAllComb"", (DL_FUNC) &AlphaSimR_sampAllComb, 3},
+    {""AlphaSimR_sampHalfDialComb"", (DL_FUNC) &AlphaSimR_sampHalfDialComb, 2},
+    {""AlphaSimR_solveUVM"", (DL_FUNC) &AlphaSimR_solveUVM, 4},
+    {""AlphaSimR_solveMVM"", (DL_FUNC) &AlphaSimR_solveMVM, 5},
+    {""AlphaSimR_solveMKM"", (DL_FUNC) &AlphaSimR_solveMKM, 4},
+    {""AlphaSimR_callRRBLUP"", (DL_FUNC) &AlphaSimR_callRRBLUP, 5},
+    {""AlphaSimR_callRRBLUP_MV"", (DL_FUNC) &AlphaSimR_callRRBLUP_MV, 5},
+    {""AlphaSimR_callRRBLUP_GCA"", (DL_FUNC) &AlphaSimR_callRRBLUP_GCA, 6},
+    {""AlphaSimR_callRRBLUP_SCA"", (DL_FUNC) &AlphaSimR_callRRBLUP_SCA, 6},
+    {""AlphaSimR_calcG"", (DL_FUNC) &AlphaSimR_calcG, 1},
+    {""AlphaSimR_calcGIbs"", (DL_FUNC) &AlphaSimR_calcGIbs, 1},
+    {""AlphaSimR_fastDist"", (DL_FUNC) &AlphaSimR_fastDist, 1},
+    {""AlphaSimR_fastPairDist"", (DL_FUNC) &AlphaSimR_fastPairDist, 2},
+    {""AlphaSimR_gaussKernel"", (DL_FUNC) &AlphaSimR_gaussKernel, 2},
+    {""AlphaSimR_readAF"", (DL_FUNC) &AlphaSimR_readAF, 5},
+    {""AlphaSimR_tuneTraitA"", (DL_FUNC) &AlphaSimR_tuneTraitA, 3},
+    {""AlphaSimR_tuneTraitAD"", (DL_FUNC) &AlphaSimR_tuneTraitAD, 4},
+    {NULL, NULL, 0}
+};
+
+RcppExport void R_init_AlphaSimR(DllInfo *dll) {
+    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
+    R_useDynamicSymbols(dll, FALSE);
+}

---FILE: src/alphaSuite.cpp---
@@ -0,0 +1,105 @@
+// [[Rcpp::depends(RcppArmadillo)]]
+#include ""alphasimr.h""
+#include <iostream>
+#include <fstream>
+
+// [[Rcpp::export]]
+void writeASGenotypes(const arma::Cube<unsigned char> & g,
+                      const arma::field<arma::uvec> &locations,
+                      const arma::uvec &allLocations,
+                      const arma::vec & snpchips, 
+                      const std::vector<std::string> & names, 
+                      const char missing,
+                      const std::string fname){
+  
+  std::ofstream ASout;
+  ASout.open(fname, std::ios::trunc);
+  
+  for (int i = 0; i < snpchips.n_rows; i++){
+    arma::Col<unsigned char> all0 = g.slice(i).col(0);
+    arma::Col<unsigned char> all1 = g.slice(i).col(1);
+    arma::Col<unsigned char> selected0;
+    arma::Col<unsigned char> selected1;
+    
+    if (snpchips(i) == 0) {
+      selected0 = all0.elem(allLocations - 1);
+      selected1 = all1.elem(allLocations - 1);      
+    }
+    else{
+      selected0 = all0.elem(locations(snpchips(i) - 1) - 1);
+      selected1 = all1.elem(locations(snpchips(i) - 1) - 1);
+    }
+    
+    arma::Col<unsigned char> selectedg = selected0 + selected1;
+    
+    ASout << names[i];
+    
+    if (snpchips(i) == 0) {
+      for (int k = 0; k < allLocations.n_rows; k++) {
+        ASout << "" "" << char(selectedg(k) + 48);
+      }      
+    }
+    else
+    {
+      int cur = 0;
+      for (int k = 0; k < allLocations.n_rows; k++) {
+        if ( (cur < locations(snpchips(i) - 1).n_rows) && ((allLocations(k) - 1) == (locations(snpchips(i) - 1)(cur) - 1)) ){
+          ASout << "" "" << char(selectedg(cur) + 48);
+          cur ++;
+        }
+        else {
+          ASout << "" "" << missing;
+        }
+      }
+    }
+    
+    ASout << ""\n"";
+  }
+  
+  ASout.close();
+}
+
+// [[Rcpp::export]]
+void writeASHaplotypes(const arma::Cube<unsigned char> & g,
+                      const arma::field<arma::uvec> &locations,
+                      const arma::uvec &allLocations,
+                      const arma::vec & snpchips, 
+                      const std::vector<std::string> & names,
+                      const char missing,
+                      const std::string fname){
+  
+  std::ofstream ASout;
+  ASout.open(fname, std::ios::trunc);
+  
+  for (int i = 0; i < snpchips.n_rows; i++){
+    for (int j = 0; j < 2; j ++){
+      arma::Col<unsigned char> all = g.slice(i).col(j);
+
+      ASout << names[i];
+
+      if (snpchips(i) == 0) {
+        arma::Col<unsigned char> selected = all.elem(allLocations - 1);
+        for (int k = 0; k < allLocations.n_rows; k++) {
+          ASout << "" "" << char(selected(k) + 48);
+        }      
+      }
+      else {
+        int cur = 0;
+        for (int k = 0; k < allLocations.n_rows; k++) {
+          arma::Col<unsigned char> selected = all.elem(locations(snpchips(i) - 1) - 1);
+          if ( (cur < locations(snpchips(i) - 1).n_rows) && ((allLocations(k) - 1) == (locations(snpchips(i) - 1)(cur) - 1)) ){
+            ASout << "" "" << char(selected(cur) + 48);
+            cur ++;
+          }
+          else {
+            ASout << "" "" << missing;
+          }
+        }
+      }
+      
+      ASout << ""\n"";
+    }
+  }
+  
+  ASout.close();
+}
\ No newline at end of file"
gaynorr,AlphaSimR,d503e5c1d7a7ca2a0a4ec2e63f6fab72dbaa13c4,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-06-13T12:16:39Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-06-13T12:16:39Z,Another fix to GxE traits,R/createSimulation.R;R/phenotypes.R,False,True,True,False,9,13,22,"---FILE: R/createSimulation.R---
@@ -312,22 +312,20 @@ addTraitAG = function(nQtlPerChr,meanG,varG,varGE,corr=matrix(1),
   qtlLoci = pickQtlLoci(nQtlPerChr,simParam=simParam)
   addEff = matrix(mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
                           Sigma=corr),ncol=nTraits)
-  gxeEff = matrix(mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
-                          Sigma=corr),ncol=nTraits)
   geno = getGeno(founderPop@geno,
                  qtlLoci@lociPerChr,
                  qtlLoci@lociLoc)
   for(i in 1:nTraits){
     tmp = tuneTraitA(geno,addEff[,i],varG[i])
     intercept = tmp$output$intercept
     addEff[,i] = addEff[,i]*tmp$parameter
-    gxeEff[,i] = gxeEff[,i]*tmp$parameter*(varGE[i]/varG[i])^0.25
+    varGxeLoc = sqrt(popVar(addEff[,i,drop=FALSE])*varGE[i]/varG[i])
     trait = new(""TraitAG"",
                 qtlLoci,
                 addEff=addEff[,i],
                 intercept=meanG[i]-intercept,
-                gxeEff = gxeEff[,i],
-                varGxeLoci = (tmp$parameter*(varGE[i]/varG[i])^0.25)^2)
+                gxeEff = rnorm(qtlLoci@nLoci,sd=sqrt(varGxeLoc)),
+                varGxeLoci = c(varGxeLoc))
     simParam@nTraits = simParam@nTraits + 1L
     simParam@traits[[simParam@nTraits]] = trait
   }
@@ -364,8 +362,6 @@ addTraitADG = function(nQtlPerChr,meanG,varG,domDegree,varGE,corr=matrix(1),
   qtlLoci = pickQtlLoci(nQtlPerChr,simParam=simParam)
   addEff = matrix(mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
                           Sigma=corr),ncol=nTraits)
-  gxeEff = matrix(mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
-                          Sigma=corr),ncol=nTraits)
   if(length(domDegree)==1){
     domDegree = rep(domDegree,qtlLoci@nLoci)
   }else{
@@ -380,14 +376,14 @@ addTraitADG = function(nQtlPerChr,meanG,varG,domDegree,varGE,corr=matrix(1),
     intercept = tmp$output$intercept
     addEff[,i] = addEff[,i]*tmp$parameter
     domEffTmp = domEff*tmp$parameter
-    gxeEff[,i] = gxeEff[,i]*tmp$parameter*(varGE[i]/varG[i])^0.25
+    varGxeLoc = sqrt(popVar(addEff[,i,drop=FALSE])*varGE[i]/varG[i])
     trait = new(""TraitADG"",
                 qtlLoci,
                 addEff=addEff[,i],
                 domEff=as.numeric(domEffTmp),
                 intercept=meanG[i]-intercept,
-                gxeEff = gxeEff[,i],
-                varGxeLoci = (tmp$parameter*(varGE[i]/varG[i])^0.25)^2)
+                gxeEff = rnorm(qtlLoci@nLoci,sd=sqrt(varGxeLoc)),
+                varGxeLoci = c(varGxeLoc))
     simParam@nTraits = simParam@nTraits + 1L
     simParam@traits[[simParam@nTraits]] = trait
   }

---FILE: R/phenotypes.R---
@@ -12,9 +12,9 @@ addError = function(gv,varE,reps=1){
       varE = diag(varE)
     }
   }
-  error = mvrnorm(nInd,
-                  mu=rep(0,nTraits),
-                  Sigma=varE)
+  error = matrix(mvrnorm(nInd,
+                         mu=rep(0,nTraits),
+                        Sigma=varE),ncol=nTraits)
   error = error/sqrt(rep(reps,nrow(error)))
   pheno = gv + error
   return(pheno)"
gaynorr,AlphaSimR,3df609e4b040ee6a8df7687eb1487cdac3b7fcc0,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-06-13T10:13:57Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-06-13T10:13:57Z,Fixed bugs in GxE traits and chromosomes with 1 QTL,R/Class-LociMap.R;R/createSimulation.R;src/Makevars;src/Makevars.win,False,True,True,False,18,18,36,"---FILE: R/Class-LociMap.R---
@@ -253,12 +253,12 @@ setMethod(""getGv"",signature(""TraitAD""),
           })
 setMethod(""getGv"",signature(""TraitAG""),
           function(object,pop,w){
-            z = qnorm(w,sqrt(object@varGxeLoci))
+            z = qnorm(w,sd=sqrt(object@varGxeLoci))
             getGvAG(object,pop,z)
           })
 setMethod(""getGv"",signature(""TraitADG""),
           function(object,pop,w){
-            z = qnorm(w,sqrt(object@varGxeLoci))
+            z = qnorm(w,sd=sqrt(object@varGxeLoci))
             getGvADG(object,pop,z)
           })
 #getHybridGv----
@@ -275,11 +275,11 @@ setMethod(""getHybridGv"",signature(""TraitAD""),
           })
 setMethod(""getHybridGv"",signature(""TraitAG""),
           function(object,fPop,fPar,mPop,mPar,w){
-            z = qnorm(w,sqrt(object@varGxeLoci))
+            z = qnorm(w,sd=sqrt(object@varGxeLoci))
             getHybridGvAG(object,fPop,fPar,mPop,mPar,z)
           })
 setMethod(""getHybridGv"",signature(""TraitADG""),
           function(object,fPop,fPar,mPop,mPar,w){
-            z = qnorm(w,sqrt(object@varGxeLoci))
+            z = qnorm(w,sd=sqrt(object@varGxeLoci))
             getHybridGvADG(object,fPop,fPar,mPop,mPar,z)
           })

---FILE: R/createSimulation.R---
@@ -210,8 +210,8 @@ addTraitA = function(nQtlPerChr,meanG,varG,corr=matrix(1),
             length(meanG)==length(diag(corr)))
   nTraits = length(meanG)
   qtlLoci = pickQtlLoci(nQtlPerChr,simParam=simParam)
-  addEff = mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
-                   Sigma=corr)
+  addEff = matrix(mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
+                          Sigma=corr),ncol=nTraits)
   geno = getGeno(founderPop@geno,
                  qtlLoci@lociPerChr,
                  qtlLoci@lociLoc)
@@ -256,8 +256,8 @@ addTraitAD = function(nQtlPerChr,meanG,varG,domDegree,corr=matrix(1),
             length(meanG)==length(diag(corr)))
   nTraits = length(meanG)
   qtlLoci = pickQtlLoci(nQtlPerChr,simParam=simParam)
-  addEff = mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
-                   Sigma=corr)
+  addEff = matrix(mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
+                          Sigma=corr),ncol=nTraits)
   if(length(domDegree)==1){
     domDegree = rep(domDegree,qtlLoci@nLoci)
   }else{
@@ -310,10 +310,10 @@ addTraitAG = function(nQtlPerChr,meanG,varG,varGE,corr=matrix(1),
             length(meanG)==length(varGE))
   nTraits = length(meanG)
   qtlLoci = pickQtlLoci(nQtlPerChr,simParam=simParam)
-  addEff = mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
-                   Sigma=corr)
-  gxeEff = mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
-                   Sigma=corr)
+  addEff = matrix(mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
+                          Sigma=corr),ncol=nTraits)
+  gxeEff = matrix(mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
+                          Sigma=corr),ncol=nTraits)
   geno = getGeno(founderPop@geno,
                  qtlLoci@lociPerChr,
                  qtlLoci@lociLoc)
@@ -362,10 +362,10 @@ addTraitADG = function(nQtlPerChr,meanG,varG,domDegree,varGE,corr=matrix(1),
             length(meanG)==length(varGE))
   nTraits = length(meanG)
   qtlLoci = pickQtlLoci(nQtlPerChr,simParam=simParam)
-  addEff = mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
-                   Sigma=corr)
-  gxeEff = mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
-                   Sigma=corr)
+  addEff = matrix(mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
+                          Sigma=corr),ncol=nTraits)
+  gxeEff = matrix(mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
+                          Sigma=corr),ncol=nTraits)
   if(length(domDegree)==1){
     domDegree = rep(domDegree,qtlLoci@nLoci)
   }else{

---FILE: src/Makevars---
@@ -1,3 +1,3 @@
-PKG_CXXFLAGS=-I../inst/include -DARMA_64BIT_WORD
+PKG_CXXFLAGS=-DARMA_64BIT_WORD
 CXX_STD = CXX11
 PKG_LIBS = $(LAPACK_LIBS) $(BLAS_LIBS) $(FLIBS)

---FILE: src/Makevars.win---
@@ -1,4 +1,4 @@
 
-PKG_CXXFLAGS=-I../inst/include -DARMA_64BIT_WORD
+PKG_CXXFLAGS=-DARMA_64BIT_WORD
 CXX_STD = CXX11
 PKG_LIBS = $(LAPACK_LIBS) $(BLAS_LIBS) $(FLIBS)"
gaynorr,AlphaSimR,f9c9357bed60a0849032549d385b93df4e2afa6b,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-06-09T13:26:46Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-06-09T13:26:46Z,bugfix,R/RcppExports.R;R/calcPopG.R;src/RcppExports.cpp;src/calcPopG.cpp,False,True,True,False,290,342,632,"---FILE: R/RcppExports.R---
@@ -5,14 +5,6 @@ AlphaFormatter <- function() {
     .Call('AlphaSimR_AlphaFormatter', PACKAGE = 'AlphaSimR')
 }
 
-calcPopG <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_calcPopG', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-calcPopGIbs <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_calcPopGIbs', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
 gebvRR <- function(RRsol, pop) {
     .Call('AlphaSimR_gebvRR', PACKAGE = 'AlphaSimR', RRsol, pop)
 }
@@ -25,94 +17,6 @@ gebvSCA <- function(SCAsol, pop) {
     .Call('AlphaSimR_gebvSCA', PACKAGE = 'AlphaSimR', SCAsol, pop)
 }
 
-getGeno <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-getDomGeno <- function(geno) {
-    .Call('AlphaSimR_getDomGeno', PACKAGE = 'AlphaSimR', geno)
-}
-
-getHaplo <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
-    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
-}
-
-getGvA <- function(trait, pop) {
-    .Call('AlphaSimR_getGvA', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-getGvAG <- function(trait, pop, z) {
-    .Call('AlphaSimR_getGvAG', PACKAGE = 'AlphaSimR', trait, pop, z)
-}
-
-getGvAD <- function(trait, pop) {
-    .Call('AlphaSimR_getGvAD', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-getGvADG <- function(trait, pop, z) {
-    .Call('AlphaSimR_getGvADG', PACKAGE = 'AlphaSimR', trait, pop, z)
-}
-
-calcGenParam <- function(trait, pop) {
-    .Call('AlphaSimR_calcGenParam', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-getHybridGvA <- function(trait, fPop, fPar, mPop, mPar) {
-    .Call('AlphaSimR_getHybridGvA', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar)
-}
-
-getHybridGvAG <- function(trait, fPop, fPar, mPop, mPar, z) {
-    .Call('AlphaSimR_getHybridGvAG', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar, z)
-}
-
-getHybridGvAD <- function(trait, fPop, fPar, mPop, mPar) {
-    .Call('AlphaSimR_getHybridGvAD', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar)
-}
-
-getHybridGvADG <- function(trait, fPop, fPar, mPop, mPar, z) {
-    .Call('AlphaSimR_getHybridGvADG', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar, z)
-}
-
-cross2 <- function(fGeno, fPar, mGeno, mPar, genMaps) {
-    .Call('AlphaSimR_cross2', PACKAGE = 'AlphaSimR', fGeno, fPar, mGeno, mPar, genMaps)
-}
-
-createDH2 <- function(geno, nDH, genMaps) {
-    .Call('AlphaSimR_createDH2', PACKAGE = 'AlphaSimR', geno, nDH, genMaps)
-}
-
-crossPedigree <- function(founders, fPar, mPar, genMaps) {
-    .Call('AlphaSimR_crossPedigree', PACKAGE = 'AlphaSimR', founders, fPar, mPar, genMaps)
-}
-
-popVar <- function(X) {
-    .Call('AlphaSimR_popVar', PACKAGE = 'AlphaSimR', X)
-}
-
-mergeGeno <- function(x, y) {
-    .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
-}
-
-calcChrMinorFreq <- function(geno, ploidy) {
-    .Call('AlphaSimR_calcChrMinorFreq', PACKAGE = 'AlphaSimR', geno, ploidy)
-}
-
-convToImat <- function(X) {
-    .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
-}
-
-sampAllComb <- function(nLevel1, nLevel2, n) {
-    .Call('AlphaSimR_sampAllComb', PACKAGE = 'AlphaSimR', nLevel1, nLevel2, n)
-}
-
-sampHalfDialComb <- function(nLevel, n) {
-    .Call('AlphaSimR_sampHalfDialComb', PACKAGE = 'AlphaSimR', nLevel, n)
-}
-
 #' @title Solve Univariate Model
 #' 
 #' @description
@@ -254,6 +158,102 @@ gaussKernel <- function(D, theta) {
     .Call('AlphaSimR_gaussKernel', PACKAGE = 'AlphaSimR', D, theta)
 }
 
+calcPopGC <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_calcPopGC', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+calcPopGIbsC <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_calcPopGIbsC', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+getGeno <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+getDomGeno <- function(geno) {
+    .Call('AlphaSimR_getDomGeno', PACKAGE = 'AlphaSimR', geno)
+}
+
+getHaplo <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
+    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
+}
+
+getGvA <- function(trait, pop) {
+    .Call('AlphaSimR_getGvA', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+getGvAG <- function(trait, pop, z) {
+    .Call('AlphaSimR_getGvAG', PACKAGE = 'AlphaSimR', trait, pop, z)
+}
+
+getGvAD <- function(trait, pop) {
+    .Call('AlphaSimR_getGvAD', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+getGvADG <- function(trait, pop, z) {
+    .Call('AlphaSimR_getGvADG', PACKAGE = 'AlphaSimR', trait, pop, z)
+}
+
+calcGenParam <- function(trait, pop) {
+    .Call('AlphaSimR_calcGenParam', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+getHybridGvA <- function(trait, fPop, fPar, mPop, mPar) {
+    .Call('AlphaSimR_getHybridGvA', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar)
+}
+
+getHybridGvAG <- function(trait, fPop, fPar, mPop, mPar, z) {
+    .Call('AlphaSimR_getHybridGvAG', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar, z)
+}
+
+getHybridGvAD <- function(trait, fPop, fPar, mPop, mPar) {
+    .Call('AlphaSimR_getHybridGvAD', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar)
+}
+
+getHybridGvADG <- function(trait, fPop, fPar, mPop, mPar, z) {
+    .Call('AlphaSimR_getHybridGvADG', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar, z)
+}
+
+cross2 <- function(fGeno, fPar, mGeno, mPar, genMaps) {
+    .Call('AlphaSimR_cross2', PACKAGE = 'AlphaSimR', fGeno, fPar, mGeno, mPar, genMaps)
+}
+
+createDH2 <- function(geno, nDH, genMaps) {
+    .Call('AlphaSimR_createDH2', PACKAGE = 'AlphaSimR', geno, nDH, genMaps)
+}
+
+crossPedigree <- function(founders, fPar, mPar, genMaps) {
+    .Call('AlphaSimR_crossPedigree', PACKAGE = 'AlphaSimR', founders, fPar, mPar, genMaps)
+}
+
+popVar <- function(X) {
+    .Call('AlphaSimR_popVar', PACKAGE = 'AlphaSimR', X)
+}
+
+mergeGeno <- function(x, y) {
+    .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
+}
+
+calcChrMinorFreq <- function(geno, ploidy) {
+    .Call('AlphaSimR_calcChrMinorFreq', PACKAGE = 'AlphaSimR', geno, ploidy)
+}
+
+convToImat <- function(X) {
+    .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
+}
+
+sampAllComb <- function(nLevel1, nLevel2, n) {
+    .Call('AlphaSimR_sampAllComb', PACKAGE = 'AlphaSimR', nLevel1, nLevel2, n)
+}
+
+sampHalfDialComb <- function(nLevel, n) {
+    .Call('AlphaSimR_sampHalfDialComb', PACKAGE = 'AlphaSimR', nLevel, n)
+}
+
 readAF <- function(nInd, segSites, ploidy, keep, inbred) {
     .Call('AlphaSimR_readAF', PACKAGE = 'AlphaSimR', nInd, segSites, ploidy, keep, inbred)
 }

---FILE: R/calcPopG.R---
@@ -19,11 +19,11 @@
 calcPopG = function(pop, useSnp=TRUE, snpChip=1, trait=1, 
                     simParam=SIMPARAM){
   if(useSnp){
-    return(.calcPopG(pop@geno, 
+    return(calcPopGC(pop@geno, 
                      simParam@snpChips[[snpChip]]@lociPerChr,
                      simParam@snpChips[[snpChip]]@lociLoc))
   }else{
-    return(.calcPopG(pop@geno, 
+    return(calcPopGC(pop@geno, 
                      simParam@traits[[trait]]@lociPerChr,
                      simParam@traits[[trait]]@lociLoc))
   }
@@ -51,11 +51,11 @@ calcPopG = function(pop, useSnp=TRUE, snpChip=1, trait=1,
 calcPopGIbs = function(pop, useSnp=TRUE, snpChip=1, trait=1, 
                        simParam=SIMPARAM){
   if(useSnp){
-    return(.calcPopGIbs(pop@geno, 
+    return(calcPopGIbsC(pop@geno, 
                         simParam@snpChips[[snpChip]]@lociPerChr,
                         simParam@snpChips[[snpChip]]@lociLoc))
   }else{
-    return(.calcPopGIbs(pop@geno, 
+    return(calcPopGIbsC(pop@geno, 
                         simParam@traits[[trait]]@lociPerChr,
                         simParam@traits[[trait]]@lociLoc))
   }

---FILE: src/RcppExports.cpp---
@@ -16,32 +16,6 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// calcPopG
-arma::fmat calcPopG(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
-RcppExport SEXP AlphaSimR_calcPopG(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< const arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcPopG(geno, lociPerChr, lociLoc));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcPopGIbs
-arma::fmat calcPopGIbs(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
-RcppExport SEXP AlphaSimR_calcPopGIbs(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< const arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcPopGIbs(geno, lociPerChr, lociLoc));
-    return rcpp_result_gen;
-END_RCPP
-}
 // gebvRR
 arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
 RcppExport SEXP AlphaSimR_gebvRR(SEXP RRsolSEXP, SEXP popSEXP) {
@@ -79,6 +53,194 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// solveUVM
+Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
+RcppExport SEXP AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMVM
+Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol);
+RcppExport SEXP AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMKM
+Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist);
+RcppExport SEXP AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP
+Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_MV
+Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_GCA
+Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_SCA
+Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcG
+arma::mat calcG(arma::mat X);
+RcppExport SEXP AlphaSimR_calcG(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcG(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcGIbs
+arma::mat calcGIbs(arma::mat X);
+RcppExport SEXP AlphaSimR_calcGIbs(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcGIbs(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// fastDist
+arma::mat fastDist(const arma::mat& X);
+RcppExport SEXP AlphaSimR_fastDist(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(fastDist(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// fastPairDist
+arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y);
+RcppExport SEXP AlphaSimR_fastPairDist(SEXP XSEXP, SEXP YSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    rcpp_result_gen = Rcpp::wrap(fastPairDist(X, Y));
+    return rcpp_result_gen;
+END_RCPP
+}
+// gaussKernel
+arma::mat gaussKernel(arma::mat& D, double theta);
+RcppExport SEXP AlphaSimR_gaussKernel(SEXP DSEXP, SEXP thetaSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type D(DSEXP);
+    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
+    rcpp_result_gen = Rcpp::wrap(gaussKernel(D, theta));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcPopGC
+arma::fmat calcPopGC(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
+RcppExport SEXP AlphaSimR_calcPopGC(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< const arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcPopGC(geno, lociPerChr, lociLoc));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcPopGIbsC
+arma::fmat calcPopGIbsC(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
+RcppExport SEXP AlphaSimR_calcPopGIbsC(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< const arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcPopGIbsC(geno, lociPerChr, lociLoc));
+    return rcpp_result_gen;
+END_RCPP
+}
 // getGeno
 arma::Mat<unsigned char> getGeno(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
 RcppExport SEXP AlphaSimR_getGeno(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
@@ -367,168 +529,6 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// solveUVM
-Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
-RcppExport SEXP AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMVM
-Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol);
-RcppExport SEXP AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMKM
-Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist);
-RcppExport SEXP AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP
-Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_MV
-Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_GCA
-Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_SCA
-Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcG
-arma::mat calcG(arma::mat X);
-RcppExport SEXP AlphaSimR_calcG(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcG(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcGIbs
-arma::mat calcGIbs(arma::mat X);
-RcppExport SEXP AlphaSimR_calcGIbs(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcGIbs(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// fastDist
-arma::mat fastDist(const arma::mat& X);
-RcppExport SEXP AlphaSimR_fastDist(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(fastDist(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// fastPairDist
-arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y);
-RcppExport SEXP AlphaSimR_fastPairDist(SEXP XSEXP, SEXP YSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    rcpp_result_gen = Rcpp::wrap(fastPairDist(X, Y));
-    return rcpp_result_gen;
-END_RCPP
-}
-// gaussKernel
-arma::mat gaussKernel(arma::mat& D, double theta);
-RcppExport SEXP AlphaSimR_gaussKernel(SEXP DSEXP, SEXP thetaSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type D(DSEXP);
-    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
-    rcpp_result_gen = Rcpp::wrap(gaussKernel(D, theta));
-    return rcpp_result_gen;
-END_RCPP
-}
 // readAF
 arma::Cube<unsigned char> readAF(int nInd, int segSites, int ploidy, arma::uvec keep, bool inbred);
 RcppExport SEXP AlphaSimR_readAF(SEXP nIndSEXP, SEXP segSitesSEXP, SEXP ploidySEXP, SEXP keepSEXP, SEXP inbredSEXP) {
@@ -571,55 +571,3 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-
-static const R_CallMethodDef CallEntries[] = {
-    {""AlphaSimR_AlphaFormatter"", (DL_FUNC) &AlphaSimR_AlphaFormatter, 0},
-    {""AlphaSimR_calcPopG"", (DL_FUNC) &AlphaSimR_calcPopG, 3},
-    {""AlphaSimR_calcPopGIbs"", (DL_FUNC) &AlphaSimR_calcPopGIbs, 3},
-    {""AlphaSimR_gebvRR"", (DL_FUNC) &AlphaSimR_gebvRR, 2},
-    {""AlphaSimR_gebvGCA"", (DL_FUNC) &AlphaSimR_gebvGCA, 3},
-    {""AlphaSimR_gebvSCA"", (DL_FUNC) &AlphaSimR_gebvSCA, 2},
-    {""AlphaSimR_getGeno"", (DL_FUNC) &AlphaSimR_getGeno, 3},
-    {""AlphaSimR_getDomGeno"", (DL_FUNC) &AlphaSimR_getDomGeno, 1},
-    {""AlphaSimR_getHaplo"", (DL_FUNC) &AlphaSimR_getHaplo, 3},
-    {""AlphaSimR_getOneHaplo"", (DL_FUNC) &AlphaSimR_getOneHaplo, 4},
-    {""AlphaSimR_getGvA"", (DL_FUNC) &AlphaSimR_getGvA, 2},
-    {""AlphaSimR_getGvAG"", (DL_FUNC) &AlphaSimR_getGvAG, 3},
-    {""AlphaSimR_getGvAD"", (DL_FUNC) &AlphaSimR_getGvAD, 2},
-    {""AlphaSimR_getGvADG"", (DL_FUNC) &AlphaSimR_getGvADG, 3},
-    {""AlphaSimR_calcGenParam"", (DL_FUNC) &AlphaSimR_calcGenParam, 2},
-    {""AlphaSimR_getHybridGvA"", (DL_FUNC) &AlphaSimR_getHybridGvA, 5},
-    {""AlphaSimR_getHybridGvAG"", (DL_FUNC) &AlphaSimR_getHybridGvAG, 6},
-    {""AlphaSimR_getHybridGvAD"", (DL_FUNC) &AlphaSimR_getHybridGvAD, 5},
-    {""AlphaSimR_getHybridGvADG"", (DL_FUNC) &AlphaSimR_getHybridGvADG, 6},
-    {""AlphaSimR_cross2"", (DL_FUNC) &AlphaSimR_cross2, 5},
-    {""AlphaSimR_createDH2"", (DL_FUNC) &AlphaSimR_createDH2, 3},
-    {""AlphaSimR_crossPedigree"", (DL_FUNC) &AlphaSimR_crossPedigree, 4},
-    {""AlphaSimR_popVar"", (DL_FUNC) &AlphaSimR_popVar, 1},
-    {""AlphaSimR_mergeGeno"", (DL_FUNC) &AlphaSimR_mergeGeno, 2},
-    {""AlphaSimR_calcChrMinorFreq"", (DL_FUNC) &AlphaSimR_calcChrMinorFreq, 2},
-    {""AlphaSimR_convToImat"", (DL_FUNC) &AlphaSimR_convToImat, 1},
-    {""AlphaSimR_sampAllComb"", (DL_FUNC) &AlphaSimR_sampAllComb, 3},
-    {""AlphaSimR_sampHalfDialComb"", (DL_FUNC) &AlphaSimR_sampHalfDialComb, 2},
-    {""AlphaSimR_solveUVM"", (DL_FUNC) &AlphaSimR_solveUVM, 4},
-    {""AlphaSimR_solveMVM"", (DL_FUNC) &AlphaSimR_solveMVM, 5},
-    {""AlphaSimR_solveMKM"", (DL_FUNC) &AlphaSimR_solveMKM, 4},
-    {""AlphaSimR_callRRBLUP"", (DL_FUNC) &AlphaSimR_callRRBLUP, 5},
-    {""AlphaSimR_callRRBLUP_MV"", (DL_FUNC) &AlphaSimR_callRRBLUP_MV, 5},
-    {""AlphaSimR_callRRBLUP_GCA"", (DL_FUNC) &AlphaSimR_callRRBLUP_GCA, 6},
-    {""AlphaSimR_callRRBLUP_SCA"", (DL_FUNC) &AlphaSimR_callRRBLUP_SCA, 6},
-    {""AlphaSimR_calcG"", (DL_FUNC) &AlphaSimR_calcG, 1},
-    {""AlphaSimR_calcGIbs"", (DL_FUNC) &AlphaSimR_calcGIbs, 1},
-    {""AlphaSimR_fastDist"", (DL_FUNC) &AlphaSimR_fastDist, 1},
-    {""AlphaSimR_fastPairDist"", (DL_FUNC) &AlphaSimR_fastPairDist, 2},
-    {""AlphaSimR_gaussKernel"", (DL_FUNC) &AlphaSimR_gaussKernel, 2},
-    {""AlphaSimR_readAF"", (DL_FUNC) &AlphaSimR_readAF, 5},
-    {""AlphaSimR_tuneTraitA"", (DL_FUNC) &AlphaSimR_tuneTraitA, 3},
-    {""AlphaSimR_tuneTraitAD"", (DL_FUNC) &AlphaSimR_tuneTraitAD, 4},
-    {NULL, NULL, 0}
-};
-
-RcppExport void R_init_AlphaSimR(DllInfo *dll) {
-    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
-    R_useDynamicSymbols(dll, FALSE);
-}

---FILE: src/calcPopG.cpp---
@@ -2,7 +2,7 @@
 #include ""alphasimr.h""
 
 // [[Rcpp::export]]
-arma::fmat calcPopG(const arma::field<arma::Cube<unsigned char> >& geno, 
+arma::fmat calcPopGC(const arma::field<arma::Cube<unsigned char> >& geno, 
                                   const arma::ivec& lociPerChr,
                                   arma::uvec lociLoc){
   arma::fmat X = arma::conv_to<arma::fmat>::from(getGeno(geno, lociPerChr, lociLoc));
@@ -14,7 +14,7 @@ arma::fmat calcPopG(const arma::field<arma::Cube<unsigned char> >& geno,
 }
 
 // [[Rcpp::export]]
-arma::fmat calcPopGIbs(const arma::field<arma::Cube<unsigned char> >& geno, 
+arma::fmat calcPopGIbsC(const arma::field<arma::Cube<unsigned char> >& geno, 
                        const arma::ivec& lociPerChr,
                        arma::uvec lociLoc){
   arma::fmat X = arma::conv_to<arma::fmat>::from(getGeno(geno, lociPerChr, lociLoc));"
gaynorr,AlphaSimR,e99311b5ce590b061b80ba125b567ef3e0a2e247,MONEY Daniel,Daniel.Money@roslin.ed.ac.uk,2017-06-09T13:15:29Z,MONEY Daniel,Daniel.Money@roslin.ed.ac.uk,2017-06-09T13:15:29Z,Bug fix?  No idea whats going on here.,NAMESPACE;R/RcppExports.R;src/RcppExports.cpp;src/calcPopG.cpp,False,True,True,False,361,282,643,"---FILE: NAMESPACE---
@@ -5,6 +5,7 @@ export(RRBLUPMemUse)
 export(RRBLUP_GCA)
 export(RRBLUP_SCA)
 export(addSnpChip)
+export(addStructuredSnpChips)
 export(addTraitA)
 export(addTraitAD)
 export(addTraitADG)
@@ -20,12 +21,16 @@ export(fastDist)
 export(fastPairDist)
 export(gaussKernel)
 export(hybridCross)
+export(loadPedigreeFromFile)
 export(makeCross)
 export(makeCross2)
 export(makeDH)
 export(meanG)
 export(meanP)
 export(newPop)
+export(pedigreeCross)
+export(pullMultipleSnpGeno)
+export(pullMultipleSnpHaplo)
 export(pullQtlGeno)
 export(pullQtlHaplo)
 export(pullSnpGeno)
@@ -45,14 +50,18 @@ export(setPhenoGCA)
 export(solveMKM)
 export(solveMVM)
 export(solveUVM)
+export(sortPed)
 export(varAD)
 export(varG)
 export(varP)
+export(writeAlphaGenotypes)
+export(writeAlphaHaplotypes)
 export(writeRecords)
 exportClasses(GCAsol)
 exportClasses(HybridPop)
 exportClasses(LociMap)
 exportClasses(MapPop)
+exportClasses(Pedigree)
 exportClasses(Pop)
 exportClasses(RRsol)
 exportClasses(RawPop)

---FILE: R/RcppExports.R---
@@ -5,6 +5,14 @@ AlphaFormatter <- function() {
     .Call('AlphaSimR_AlphaFormatter', PACKAGE = 'AlphaSimR')
 }
 
+calcPopG <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_calcPopG', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+calcPopGIbs <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_calcPopGIbs', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
 gebvRR <- function(RRsol, pop) {
     .Call('AlphaSimR_gebvRR', PACKAGE = 'AlphaSimR', RRsol, pop)
 }
@@ -17,6 +25,94 @@ gebvSCA <- function(SCAsol, pop) {
     .Call('AlphaSimR_gebvSCA', PACKAGE = 'AlphaSimR', SCAsol, pop)
 }
 
+getGeno <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+getDomGeno <- function(geno) {
+    .Call('AlphaSimR_getDomGeno', PACKAGE = 'AlphaSimR', geno)
+}
+
+getHaplo <- function(geno, lociPerChr, lociLoc) {
+    .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
+}
+
+getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
+    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
+}
+
+getGvA <- function(trait, pop) {
+    .Call('AlphaSimR_getGvA', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+getGvAG <- function(trait, pop, z) {
+    .Call('AlphaSimR_getGvAG', PACKAGE = 'AlphaSimR', trait, pop, z)
+}
+
+getGvAD <- function(trait, pop) {
+    .Call('AlphaSimR_getGvAD', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+getGvADG <- function(trait, pop, z) {
+    .Call('AlphaSimR_getGvADG', PACKAGE = 'AlphaSimR', trait, pop, z)
+}
+
+calcGenParam <- function(trait, pop) {
+    .Call('AlphaSimR_calcGenParam', PACKAGE = 'AlphaSimR', trait, pop)
+}
+
+getHybridGvA <- function(trait, fPop, fPar, mPop, mPar) {
+    .Call('AlphaSimR_getHybridGvA', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar)
+}
+
+getHybridGvAG <- function(trait, fPop, fPar, mPop, mPar, z) {
+    .Call('AlphaSimR_getHybridGvAG', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar, z)
+}
+
+getHybridGvAD <- function(trait, fPop, fPar, mPop, mPar) {
+    .Call('AlphaSimR_getHybridGvAD', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar)
+}
+
+getHybridGvADG <- function(trait, fPop, fPar, mPop, mPar, z) {
+    .Call('AlphaSimR_getHybridGvADG', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar, z)
+}
+
+cross2 <- function(fGeno, fPar, mGeno, mPar, genMaps) {
+    .Call('AlphaSimR_cross2', PACKAGE = 'AlphaSimR', fGeno, fPar, mGeno, mPar, genMaps)
+}
+
+createDH2 <- function(geno, nDH, genMaps) {
+    .Call('AlphaSimR_createDH2', PACKAGE = 'AlphaSimR', geno, nDH, genMaps)
+}
+
+crossPedigree <- function(founders, fPar, mPar, genMaps) {
+    .Call('AlphaSimR_crossPedigree', PACKAGE = 'AlphaSimR', founders, fPar, mPar, genMaps)
+}
+
+popVar <- function(X) {
+    .Call('AlphaSimR_popVar', PACKAGE = 'AlphaSimR', X)
+}
+
+mergeGeno <- function(x, y) {
+    .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
+}
+
+calcChrMinorFreq <- function(geno, ploidy) {
+    .Call('AlphaSimR_calcChrMinorFreq', PACKAGE = 'AlphaSimR', geno, ploidy)
+}
+
+convToImat <- function(X) {
+    .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
+}
+
+sampAllComb <- function(nLevel1, nLevel2, n) {
+    .Call('AlphaSimR_sampAllComb', PACKAGE = 'AlphaSimR', nLevel1, nLevel2, n)
+}
+
+sampHalfDialComb <- function(nLevel, n) {
+    .Call('AlphaSimR_sampHalfDialComb', PACKAGE = 'AlphaSimR', nLevel, n)
+}
+
 #' @title Solve Univariate Model
 #' 
 #' @description
@@ -158,98 +254,6 @@ gaussKernel <- function(D, theta) {
     .Call('AlphaSimR_gaussKernel', PACKAGE = 'AlphaSimR', D, theta)
 }
 
-.calcPopG <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_calcPopG', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-.calcPopGIbs <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_calcPopGIbs', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-getGeno <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-getDomGeno <- function(geno) {
-    .Call('AlphaSimR_getDomGeno', PACKAGE = 'AlphaSimR', geno)
-}
-
-getHaplo <- function(geno, lociPerChr, lociLoc) {
-    .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
-}
-
-getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
-    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
-}
-
-getGvA <- function(trait, pop) {
-    .Call('AlphaSimR_getGvA', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-getGvAG <- function(trait, pop, z) {
-    .Call('AlphaSimR_getGvAG', PACKAGE = 'AlphaSimR', trait, pop, z)
-}
-
-getGvAD <- function(trait, pop) {
-    .Call('AlphaSimR_getGvAD', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-getGvADG <- function(trait, pop, z) {
-    .Call('AlphaSimR_getGvADG', PACKAGE = 'AlphaSimR', trait, pop, z)
-}
-
-calcGenParam <- function(trait, pop) {
-    .Call('AlphaSimR_calcGenParam', PACKAGE = 'AlphaSimR', trait, pop)
-}
-
-getHybridGvA <- function(trait, fPop, fPar, mPop, mPar) {
-    .Call('AlphaSimR_getHybridGvA', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar)
-}
-
-getHybridGvAG <- function(trait, fPop, fPar, mPop, mPar, z) {
-    .Call('AlphaSimR_getHybridGvAG', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar, z)
-}
-
-getHybridGvAD <- function(trait, fPop, fPar, mPop, mPar) {
-    .Call('AlphaSimR_getHybridGvAD', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar)
-}
-
-getHybridGvADG <- function(trait, fPop, fPar, mPop, mPar, z) {
-    .Call('AlphaSimR_getHybridGvADG', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar, z)
-}
-
-cross2 <- function(fGeno, fPar, mGeno, mPar, genMaps) {
-    .Call('AlphaSimR_cross2', PACKAGE = 'AlphaSimR', fGeno, fPar, mGeno, mPar, genMaps)
-}
-
-createDH2 <- function(geno, nDH, genMaps) {
-    .Call('AlphaSimR_createDH2', PACKAGE = 'AlphaSimR', geno, nDH, genMaps)
-}
-
-popVar <- function(X) {
-    .Call('AlphaSimR_popVar', PACKAGE = 'AlphaSimR', X)
-}
-
-mergeGeno <- function(x, y) {
-    .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
-}
-
-calcChrMinorFreq <- function(geno, ploidy) {
-    .Call('AlphaSimR_calcChrMinorFreq', PACKAGE = 'AlphaSimR', geno, ploidy)
-}
-
-convToImat <- function(X) {
-    .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
-}
-
-sampAllComb <- function(nLevel1, nLevel2, n) {
-    .Call('AlphaSimR_sampAllComb', PACKAGE = 'AlphaSimR', nLevel1, nLevel2, n)
-}
-
-sampHalfDialComb <- function(nLevel, n) {
-    .Call('AlphaSimR_sampHalfDialComb', PACKAGE = 'AlphaSimR', nLevel, n)
-}
-
 readAF <- function(nInd, segSites, ploidy, keep, inbred) {
     .Call('AlphaSimR_readAF', PACKAGE = 'AlphaSimR', nInd, segSites, ploidy, keep, inbred)
 }

---FILE: src/RcppExports.cpp---
@@ -16,6 +16,32 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// calcPopG
+arma::fmat calcPopG(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
+RcppExport SEXP AlphaSimR_calcPopG(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< const arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcPopG(geno, lociPerChr, lociLoc));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcPopGIbs
+arma::fmat calcPopGIbs(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
+RcppExport SEXP AlphaSimR_calcPopGIbs(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< const arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcPopGIbs(geno, lociPerChr, lociLoc));
+    return rcpp_result_gen;
+END_RCPP
+}
 // gebvRR
 arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
 RcppExport SEXP AlphaSimR_gebvRR(SEXP RRsolSEXP, SEXP popSEXP) {
@@ -53,194 +79,6 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// solveUVM
-Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
-RcppExport SEXP AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMVM
-Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol);
-RcppExport SEXP AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMKM
-Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist);
-RcppExport SEXP AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP
-Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_MV
-Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_GCA
-Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_SCA
-Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcG
-arma::mat calcG(arma::mat X);
-RcppExport SEXP AlphaSimR_calcG(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcG(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcGIbs
-arma::mat calcGIbs(arma::mat X);
-RcppExport SEXP AlphaSimR_calcGIbs(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcGIbs(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// fastDist
-arma::mat fastDist(const arma::mat& X);
-RcppExport SEXP AlphaSimR_fastDist(SEXP XSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    rcpp_result_gen = Rcpp::wrap(fastDist(X));
-    return rcpp_result_gen;
-END_RCPP
-}
-// fastPairDist
-arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y);
-RcppExport SEXP AlphaSimR_fastPairDist(SEXP XSEXP, SEXP YSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    rcpp_result_gen = Rcpp::wrap(fastPairDist(X, Y));
-    return rcpp_result_gen;
-END_RCPP
-}
-// gaussKernel
-arma::mat gaussKernel(arma::mat& D, double theta);
-RcppExport SEXP AlphaSimR_gaussKernel(SEXP DSEXP, SEXP thetaSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type D(DSEXP);
-    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
-    rcpp_result_gen = Rcpp::wrap(gaussKernel(D, theta));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcPopG
-arma::fmat calcPopG(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
-RcppExport SEXP AlphaSimR_calcPopG(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< const arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcPopG(geno, lociPerChr, lociLoc));
-    return rcpp_result_gen;
-END_RCPP
-}
-// calcPopGIbs
-arma::fmat calcPopGIbs(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
-RcppExport SEXP AlphaSimR_calcPopGIbs(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
-    Rcpp::traits::input_parameter< const arma::ivec& >::type lociPerChr(lociPerChrSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
-    rcpp_result_gen = Rcpp::wrap(calcPopGIbs(geno, lociPerChr, lociLoc));
-    return rcpp_result_gen;
-END_RCPP
-}
 // getGeno
 arma::Mat<unsigned char> getGeno(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
 RcppExport SEXP AlphaSimR_getGeno(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
@@ -444,6 +282,20 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// crossPedigree
+arma::field<arma::Cube<unsigned char> > crossPedigree(const arma::field<arma::Cube<unsigned char> >& founders, arma::uvec fPar, arma::uvec mPar, const arma::field<arma::vec>& genMaps);
+RcppExport SEXP AlphaSimR_crossPedigree(SEXP foundersSEXP, SEXP fParSEXP, SEXP mParSEXP, SEXP genMapsSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::field<arma::Cube<unsigned char> >& >::type founders(foundersSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type fPar(fParSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type mPar(mParSEXP);
+    Rcpp::traits::input_parameter< const arma::field<arma::vec>& >::type genMaps(genMapsSEXP);
+    rcpp_result_gen = Rcpp::wrap(crossPedigree(founders, fPar, mPar, genMaps));
+    return rcpp_result_gen;
+END_RCPP
+}
 // popVar
 arma::mat popVar(const arma::mat& X);
 RcppExport SEXP AlphaSimR_popVar(SEXP XSEXP) {
@@ -515,6 +367,168 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// solveUVM
+Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
+RcppExport SEXP AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMVM
+Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol);
+RcppExport SEXP AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMKM
+Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist);
+RcppExport SEXP AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP
+Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_MV
+Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_GCA
+Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_SCA
+Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcG
+arma::mat calcG(arma::mat X);
+RcppExport SEXP AlphaSimR_calcG(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcG(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// calcGIbs
+arma::mat calcGIbs(arma::mat X);
+RcppExport SEXP AlphaSimR_calcGIbs(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(calcGIbs(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// fastDist
+arma::mat fastDist(const arma::mat& X);
+RcppExport SEXP AlphaSimR_fastDist(SEXP XSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    rcpp_result_gen = Rcpp::wrap(fastDist(X));
+    return rcpp_result_gen;
+END_RCPP
+}
+// fastPairDist
+arma::mat fastPairDist(const arma::mat& X, const arma::mat& Y);
+RcppExport SEXP AlphaSimR_fastPairDist(SEXP XSEXP, SEXP YSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    rcpp_result_gen = Rcpp::wrap(fastPairDist(X, Y));
+    return rcpp_result_gen;
+END_RCPP
+}
+// gaussKernel
+arma::mat gaussKernel(arma::mat& D, double theta);
+RcppExport SEXP AlphaSimR_gaussKernel(SEXP DSEXP, SEXP thetaSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type D(DSEXP);
+    Rcpp::traits::input_parameter< double >::type theta(thetaSEXP);
+    rcpp_result_gen = Rcpp::wrap(gaussKernel(D, theta));
+    return rcpp_result_gen;
+END_RCPP
+}
 // readAF
 arma::Cube<unsigned char> readAF(int nInd, int segSites, int ploidy, arma::uvec keep, bool inbred);
 RcppExport SEXP AlphaSimR_readAF(SEXP nIndSEXP, SEXP segSitesSEXP, SEXP ploidySEXP, SEXP keepSEXP, SEXP inbredSEXP) {
@@ -557,3 +571,55 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+
+static const R_CallMethodDef CallEntries[] = {
+    {""AlphaSimR_AlphaFormatter"", (DL_FUNC) &AlphaSimR_AlphaFormatter, 0},
+    {""AlphaSimR_calcPopG"", (DL_FUNC) &AlphaSimR_calcPopG, 3},
+    {""AlphaSimR_calcPopGIbs"", (DL_FUNC) &AlphaSimR_calcPopGIbs, 3},
+    {""AlphaSimR_gebvRR"", (DL_FUNC) &AlphaSimR_gebvRR, 2},
+    {""AlphaSimR_gebvGCA"", (DL_FUNC) &AlphaSimR_gebvGCA, 3},
+    {""AlphaSimR_gebvSCA"", (DL_FUNC) &AlphaSimR_gebvSCA, 2},
+    {""AlphaSimR_getGeno"", (DL_FUNC) &AlphaSimR_getGeno, 3},
+    {""AlphaSimR_getDomGeno"", (DL_FUNC) &AlphaSimR_getDomGeno, 1},
+    {""AlphaSimR_getHaplo"", (DL_FUNC) &AlphaSimR_getHaplo, 3},
+    {""AlphaSimR_getOneHaplo"", (DL_FUNC) &AlphaSimR_getOneHaplo, 4},
+    {""AlphaSimR_getGvA"", (DL_FUNC) &AlphaSimR_getGvA, 2},
+    {""AlphaSimR_getGvAG"", (DL_FUNC) &AlphaSimR_getGvAG, 3},
+    {""AlphaSimR_getGvAD"", (DL_FUNC) &AlphaSimR_getGvAD, 2},
+    {""AlphaSimR_getGvADG"", (DL_FUNC) &AlphaSimR_getGvADG, 3},
+    {""AlphaSimR_calcGenParam"", (DL_FUNC) &AlphaSimR_calcGenParam, 2},
+    {""AlphaSimR_getHybridGvA"", (DL_FUNC) &AlphaSimR_getHybridGvA, 5},
+    {""AlphaSimR_getHybridGvAG"", (DL_FUNC) &AlphaSimR_getHybridGvAG, 6},
+    {""AlphaSimR_getHybridGvAD"", (DL_FUNC) &AlphaSimR_getHybridGvAD, 5},
+    {""AlphaSimR_getHybridGvADG"", (DL_FUNC) &AlphaSimR_getHybridGvADG, 6},
+    {""AlphaSimR_cross2"", (DL_FUNC) &AlphaSimR_cross2, 5},
+    {""AlphaSimR_createDH2"", (DL_FUNC) &AlphaSimR_createDH2, 3},
+    {""AlphaSimR_crossPedigree"", (DL_FUNC) &AlphaSimR_crossPedigree, 4},
+    {""AlphaSimR_popVar"", (DL_FUNC) &AlphaSimR_popVar, 1},
+    {""AlphaSimR_mergeGeno"", (DL_FUNC) &AlphaSimR_mergeGeno, 2},
+    {""AlphaSimR_calcChrMinorFreq"", (DL_FUNC) &AlphaSimR_calcChrMinorFreq, 2},
+    {""AlphaSimR_convToImat"", (DL_FUNC) &AlphaSimR_convToImat, 1},
+    {""AlphaSimR_sampAllComb"", (DL_FUNC) &AlphaSimR_sampAllComb, 3},
+    {""AlphaSimR_sampHalfDialComb"", (DL_FUNC) &AlphaSimR_sampHalfDialComb, 2},
+    {""AlphaSimR_solveUVM"", (DL_FUNC) &AlphaSimR_solveUVM, 4},
+    {""AlphaSimR_solveMVM"", (DL_FUNC) &AlphaSimR_solveMVM, 5},
+    {""AlphaSimR_solveMKM"", (DL_FUNC) &AlphaSimR_solveMKM, 4},
+    {""AlphaSimR_callRRBLUP"", (DL_FUNC) &AlphaSimR_callRRBLUP, 5},
+    {""AlphaSimR_callRRBLUP_MV"", (DL_FUNC) &AlphaSimR_callRRBLUP_MV, 5},
+    {""AlphaSimR_callRRBLUP_GCA"", (DL_FUNC) &AlphaSimR_callRRBLUP_GCA, 6},
+    {""AlphaSimR_callRRBLUP_SCA"", (DL_FUNC) &AlphaSimR_callRRBLUP_SCA, 6},
+    {""AlphaSimR_calcG"", (DL_FUNC) &AlphaSimR_calcG, 1},
+    {""AlphaSimR_calcGIbs"", (DL_FUNC) &AlphaSimR_calcGIbs, 1},
+    {""AlphaSimR_fastDist"", (DL_FUNC) &AlphaSimR_fastDist, 1},
+    {""AlphaSimR_fastPairDist"", (DL_FUNC) &AlphaSimR_fastPairDist, 2},
+    {""AlphaSimR_gaussKernel"", (DL_FUNC) &AlphaSimR_gaussKernel, 2},
+    {""AlphaSimR_readAF"", (DL_FUNC) &AlphaSimR_readAF, 5},
+    {""AlphaSimR_tuneTraitA"", (DL_FUNC) &AlphaSimR_tuneTraitA, 3},
+    {""AlphaSimR_tuneTraitAD"", (DL_FUNC) &AlphaSimR_tuneTraitAD, 4},
+    {NULL, NULL, 0}
+};
+
+RcppExport void R_init_AlphaSimR(DllInfo *dll) {
+    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
+    R_useDynamicSymbols(dll, FALSE);
+}

---FILE: src/calcPopG.cpp---
@@ -1,7 +1,7 @@
 // [[Rcpp::depends(RcppArmadillo)]]
 #include ""alphasimr.h""
 
-// [[Rcpp::export(.calcPopG)]]
+// [[Rcpp::export]]
 arma::fmat calcPopG(const arma::field<arma::Cube<unsigned char> >& geno, 
                                   const arma::ivec& lociPerChr,
                                   arma::uvec lociLoc){
@@ -13,7 +13,7 @@ arma::fmat calcPopG(const arma::field<arma::Cube<unsigned char> >& geno,
   return G;
 }
 
-// [[Rcpp::export(.calcPopGIbs)]]
+// [[Rcpp::export]]
 arma::fmat calcPopGIbs(const arma::field<arma::Cube<unsigned char> >& geno, 
                        const arma::ivec& lociPerChr,
                        arma::uvec lociLoc){"
gaynorr,AlphaSimR,a991698a8e243122e4768c6ba67eac9b8abf8097,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-06-05T10:13:28Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-06-05T10:13:28Z,Fixed bug with hybridCross and GxE traits,R/hybrids.R;inst/doc/introduction.Rmd;inst/doc/introduction.html;vignettes/introduction.Rmd,True,True,True,False,20,17,37,"---FILE: R/hybrids.R---
@@ -1,7 +1,5 @@
 #A wrapper for calling getHybridGv
 #This function uses chunking to reduce RAM usage
-#A wrapper for calling getHybridGv
-#This function uses chunking to reduce RAM usage
 getHybridGvByChunk = function(trait,fPop,fPar,
                               mPop,mPar,w,chunkSize){
   nOut = length(fPar)
@@ -83,8 +81,8 @@ hybridCross = function(fPop,mPop,crossPlan=""testcross"",varE=NULL,
   gv = NULL
   pheno = NULL
   for(trait in simParam@traits){
-    tmp = getHybridGvByChunk(trait,fPop,crossPlan[,1],
-                             mPop,crossPlan[,2],w=0.5,
+    tmp = getHybridGvByChunk(trait=trait,fPop=fPop,fPar=crossPlan[,1],
+                             mPop=mPop,mPar=crossPlan[,2],w=0.5,
                              chunkSize=chunkSize)
     gv = cbind(gv, tmp)
     #Will a phenotype be calculated
@@ -94,8 +92,8 @@ hybridCross = function(fPop,mPop,crossPlan=""testcross"",varE=NULL,
       #Does GxE matter
       if(class(trait)==""TraitAG"" | class(trait)==""TraitADG""){
         pheno = cbind(pheno, 
-                      getHybridGvByChunk(trait,fPop,fPar,
-                                         mPop,mPar,w=w,
+                      getHybridGvByChunk(trait=trait,fPop=fPop,fPar=crossPlan[,1],
+                                         mPop=mPop,mPar=crossPlan[,2],w=w,
                                          chunkSize=chunkSize))
       }else{
         pheno = cbind(pheno,tmp)

---FILE: inst/doc/introduction.Rmd---
@@ -17,7 +17,7 @@ The basic steps of an AlphaSimR simulation are:
 
 2. Set simulation parameters using `createSimulation`
 
-3. Add traits using `addTraitA` or `addTraitAD`
+3. Add traits using `addTraitA` or any other addTrait function
 
 4. Add SNP chips using `addSnpChip`
 
@@ -39,7 +39,7 @@ The `createSimulation` function will create a variable called `LASTID` in the gl
 
 ### Adding traits
 
-Traits are added to the simulation using the `addTraitA` and `addTraitAD` functions. These functions can be called multiple times to run simulations with multiple traits.
+Traits are added to the simulation using the one of the fullowing functions: `addTraitA`, `addTraitAD`, `addTraitAG`, or `addTraitADG`. These functions can be called multiple times to run simulations with multiple traits. These functions can also be used to simulate correlated pleiotropic traits.
 
 ### Adding SNP chips
 
@@ -57,11 +57,13 @@ Below are some key functions for operations carried out on populations.
 
 * Viewing genotypes: `pullSnpGeno`, `pullSnpHaplo`, `pullQtlGeno`, `pullQtlHaplo`
 
-* Viewing summary data: `meanG`, `meanP`, `varG`, `varP`
+* Viewing summary data: `meanG`, `meanP`, `varG`, `varP`, `varAD`
 
 * Setting phenotypes: `setPheno`, `calcPheno`
 
 * Making selection: `selectInd`, `selectFam`, `selectWithinFam`, `selectMale`, `selectFemale`
 
 * Crossing: `makeCross`, `randCross`, `makeCross2`, `randCross2`,
 `self`, `makeDH`
+
+* Genomic selection: `writeRecords`, `setEBV`

---FILE: inst/doc/introduction.html---
@@ -4,7 +4,7 @@
 
 <head>
 
-<meta charset=""utf-8"">
+<meta charset=""utf-8"" />
 <meta http-equiv=""Content-Type"" content=""text/html; charset=utf-8"" />
 <meta name=""generator"" content=""pandoc"" />
 
@@ -38,7 +38,7 @@ <h1 class=""title toc-ignore"">Introduction to AlphaSimR</h1>
 <ol style=""list-style-type: decimal"">
 <li><p>Create founder haplotypes using <code>runMacs</code></p></li>
 <li><p>Set simulation parameters using <code>createSimulation</code></p></li>
-<li><p>Add traits using <code>addTraitA</code> or <code>addTraitAD</code></p></li>
+<li><p>Add traits using <code>addTraitA</code> or any other addTrait function</p></li>
 <li><p>Add SNP chips using <code>addSnpChip</code></p></li>
 <li><p>Create one or more initial populations using <code>newPop</code></p></li>
 <li><p>Use the newly created populations for crossing and selection to simulate a breeding program</p></li>
@@ -55,7 +55,7 @@ <h3>Setting simulation parameters</h3>
 </div>
 <div id=""adding-traits"" class=""section level3"">
 <h3>Adding traits</h3>
-<p>Traits are added to the simulation using the <code>addTraitA</code> and <code>addTraitAD</code> functions. These functions can be called multiple times to run simulations with multiple traits.</p>
+<p>Traits are added to the simulation using the one of the fullowing functions: <code>addTraitA</code>, <code>addTraitAD</code>, <code>addTraitAG</code>, or <code>addTraitADG</code>. These functions can be called multiple times to run simulations with multiple traits. These functions can also be used to simulate correlated pleiotropic traits.</p>
 </div>
 <div id=""adding-snp-chips"" class=""section level3"">
 <h3>Adding SNP chips</h3>
@@ -71,10 +71,11 @@ <h3>Working with populations</h3>
 <p>Below are some key functions for operations carried out on populations.</p>
 <ul>
 <li><p>Viewing genotypes: <code>pullSnpGeno</code>, <code>pullSnpHaplo</code>, <code>pullQtlGeno</code>, <code>pullQtlHaplo</code></p></li>
-<li><p>Viewing summary data: <code>meanG</code>, <code>meanP</code>, <code>varG</code>, <code>varP</code></p></li>
+<li><p>Viewing summary data: <code>meanG</code>, <code>meanP</code>, <code>varG</code>, <code>varP</code>, <code>varAD</code></p></li>
 <li><p>Setting phenotypes: <code>setPheno</code>, <code>calcPheno</code></p></li>
 <li><p>Making selection: <code>selectInd</code>, <code>selectFam</code>, <code>selectWithinFam</code>, <code>selectMale</code>, <code>selectFemale</code></p></li>
 <li><p>Crossing: <code>makeCross</code>, <code>randCross</code>, <code>makeCross2</code>, <code>randCross2</code>, <code>self</code>, <code>makeDH</code></p></li>
+<li><p>Genomic selection: <code>writeRecords</code>, <code>setEBV</code></p></li>
 </ul>
 </div>
 
@@ -85,7 +86,7 @@ <h3>Working with populations</h3>
   (function () {
     var script = document.createElement(""script"");
     script.type = ""text/javascript"";
-    script.src  = ""https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"";
+    script.src  = ""https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"";
     document.getElementsByTagName(""head"")[0].appendChild(script);
   })();
 </script>

---FILE: vignettes/introduction.Rmd---
@@ -17,7 +17,7 @@ The basic steps of an AlphaSimR simulation are:
 
 2. Set simulation parameters using `createSimulation`
 
-3. Add traits using `addTraitA` or `addTraitAD`
+3. Add traits using `addTraitA` or any other addTrait function
 
 4. Add SNP chips using `addSnpChip`
 
@@ -39,7 +39,7 @@ The `createSimulation` function will create a variable called `LASTID` in the gl
 
 ### Adding traits
 
-Traits are added to the simulation using the `addTraitA` and `addTraitAD` functions. These functions can be called multiple times to run simulations with multiple traits.
+Traits are added to the simulation using the one of the fullowing functions: `addTraitA`, `addTraitAD`, `addTraitAG`, or `addTraitADG`. These functions can be called multiple times to run simulations with multiple traits. These functions can also be used to simulate correlated pleiotropic traits.
 
 ### Adding SNP chips
 
@@ -57,11 +57,13 @@ Below are some key functions for operations carried out on populations.
 
 * Viewing genotypes: `pullSnpGeno`, `pullSnpHaplo`, `pullQtlGeno`, `pullQtlHaplo`
 
-* Viewing summary data: `meanG`, `meanP`, `varG`, `varP`
+* Viewing summary data: `meanG`, `meanP`, `varG`, `varP`, `varAD`
 
 * Setting phenotypes: `setPheno`, `calcPheno`
 
 * Making selection: `selectInd`, `selectFam`, `selectWithinFam`, `selectMale`, `selectFemale`
 
 * Crossing: `makeCross`, `randCross`, `makeCross2`, `randCross2`,
 `self`, `makeDH`
+
+* Genomic selection: `writeRecords`, `setEBV`"
gaynorr,AlphaSimR,33291919b6c2bb09be5f1a0beb073f7178fcf9db,MONEY Daniel,Daniel.Money@roslin.ed.ac.uk,2017-06-01T16:00:17Z,MONEY Daniel,Daniel.Money@roslin.ed.ac.uk,2017-06-01T16:00:17Z,Bug fix (uniform_int_distribution uses closed intervals at both ends - I was assuming open at max),src/meiosis.cpp,False,False,False,False,1,1,2,"---FILE: src/meiosis.cpp---
@@ -193,7 +193,7 @@ arma::field<arma::Cube<unsigned char> > crossPedigree(
   typedef std::minstd_rand G;
   G g;
   typedef std::uniform_int_distribution<> D;
-  D d(0,founders(0).n_slices);
+  D d(0,founders(0).n_slices-1);
   
   //Output data
   arma::field<arma::Cube<unsigned char> > geno(nChr);"
gaynorr,AlphaSimR,9d868cb494560ff328a2108838fa2e3e818ce773,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-05-30T12:48:00Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-05-30T12:48:00Z,"Incomplete version 0.1.2

GS fully functional, but solveMKM is too slow. Will change to a different solver.

Contains unresolved bug in getHybridGvADG",NAMESPACE;R/Class-HybridPop.R;R/Class-LociMap.R;R/Class-Pop.R;R/GS.R;R/RcppExports.R;R/createSimulation.R;R/hybrids.R;R/pullGeno.R;man/GCAsol-class.Rd;man/MapPop-class.Rd;man/RRBLUP.Rd;man/RRBLUP_GCA.Rd;man/RRBLUP_SCA.Rd;man/RRBLUPsolution-class.Rd;man/RRsol-class.Rd;man/SCAsol-class.Rd;man/SC_GBLUP.Rd;man/addTraitA.Rd;man/addTraitAD.Rd;man/addTraitADG.Rd;man/addTraitAG.Rd;man/predict-RRBLUPsolution-method.Rd;man/pullQtlHaplo.Rd;man/pullSnpHaplo.Rd;man/setEBV.Rd;man/writeRecords.Rd;src/GEBV.cpp;src/MME.cpp;src/RcppExports.cpp;src/getGeno.cpp;src/getGeno.h,False,True,True,False,1091,674,1765,"---FILE: NAMESPACE---
@@ -1,7 +1,8 @@
 # Generated by roxygen2: do not edit by hand
 
 export(RRBLUP)
-export(SC_GBLUP)
+export(RRBLUP_GCA)
+export(RRBLUP_SCA)
 export(addSnpChip)
 export(addTraitA)
 export(addTraitAD)
@@ -30,6 +31,7 @@ export(selectInd)
 export(selectMale)
 export(selectWithinFam)
 export(self)
+export(setEBV)
 export(setPheno)
 export(setPhenoGCA)
 export(solveMKM)
@@ -39,18 +41,19 @@ export(varAD)
 export(varG)
 export(varP)
 export(writeRecords)
+exportClasses(GCAsol)
 exportClasses(HybridPop)
 exportClasses(LociMap)
 exportClasses(MapPop)
 exportClasses(Pop)
-exportClasses(RRBLUPsolution)
+exportClasses(RRsol)
 exportClasses(RawPop)
+exportClasses(SCAsol)
 exportClasses(SimParam)
 exportClasses(TraitA)
 exportClasses(TraitAD)
 exportClasses(TraitADG)
 exportClasses(TraitAG)
-exportMethods(predict)
 import(Rcpp)
 import(RcppArmadillo)
 importFrom(MASS,mvrnorm)

---FILE: R/Class-HybridPop.R---
@@ -28,6 +28,15 @@ setClass(""HybridPop"",
 
 setValidity(""HybridPop"",function(object){
   errors = character()
+  if(any(grepl("" "",object@id,fixed=TRUE))){
+    errors = c(errors,""id can not contain spaces"")
+  }
+  if(any(grepl("" "",object@mother,fixed=TRUE))){
+    errors = c(errors,""mother can not contain spaces"")
+  }
+  if(any(grepl("" "",object@father,fixed=TRUE))){
+    errors = c(errors,""father can not contain spaces"")
+  }
   if(object@nInd!=length(object@id)){
     errors = c(errors,""nInd!=length(id)"")
   }

---FILE: R/Class-LociMap.R---
@@ -137,6 +137,108 @@ setValidity(""TraitADG"",function(object){
   }
 })
 
+#RRsol----
+#' @title RR-BLUP Solution
+#' 
+#' @description Extends \code{\link{LociMap-class}} 
+#' to contain estimated effects from \code{\link{RRBLUP}}
+#' 
+#' @slot markerEff GEBVs for markers
+#' @slot fixEff Estimates for fixed effects
+#'
+#' @export
+setClass(""RRsol"",
+         slots=c(markerEff=""matrix"",
+                 fixEff=""matrix""),
+         contains=""LociMap"")
+
+setValidity(""RRsol"",function(object){
+  errors = character()
+  if(!is.numeric(object@markerEff)){
+    errors = c(errors,""!is.numeric(markerEff)"")
+  }
+  if(!is.numeric(object@fixEff)){
+    errors = c(errors,""!is.numeric(fixEff)"")
+  }
+  if(object@nLoci!=nrow(object@markerEff)){
+    errors = c(errors,""nLoci!=nrow(markerEff)"")
+  }
+  if(length(errors)==0){
+    return(TRUE)
+  }else{
+    return(errors)
+  }
+})
+
+#GCAsol----
+#' @title RR-BLUP GCA Solution
+#' 
+#' @description Extends \code{\link{LociMap-class}} 
+#' to contain estimated effects from \code{\link{RRBLUP_GCA}}
+#' 
+#' @slot femaleEff marker GCA for ""female"" pool
+#' @slot maleEff marker GCA for ""male"" pool
+#' @slot fixEff Estimates for fixed effects
+#'
+#' @export
+setClass(""GCAsol"",
+         slots=c(femaleEff=""matrix"",
+                 maleEff=""matrix"",
+                 fixEff=""matrix""),
+         contains=""LociMap"")
+
+setValidity(""GCAsol"",function(object){
+  errors = character()
+  if(!is.numeric(object@femaleEff)){
+    errors = c(errors,""!is.numeric(femaleEff)"")
+  }
+  if(!is.numeric(object@maleEff)){
+    errors = c(errors,""!is.numeric(maleEff)"")
+  }
+  if(!is.numeric(object@fixEff)){
+    errors = c(errors,""!is.numeric(fixEff)"")
+  }
+  if(object@nLoci!=nrow(object@femaleEff)){
+    errors = c(errors,""nLoci!=nrow(femaleEff)"")
+  }
+  if(object@nLoci!=nrow(object@maleEff)){
+    errors = c(errors,""nLoci!=nrow(maleEff)"")
+  }
+  if(length(errors)==0){
+    return(TRUE)
+  }else{
+    return(errors)
+  }
+})
+
+#SCAsol----
+#' @title RR-BLUP SCA Solution
+#' 
+#' @description Extends \code{\link{GCAsol-class}} 
+#' to contain estimated effects from \code{\link{RRBLUP_SCA}}
+#' 
+#' @slot scaEff marker SCA effects
+#'
+#' @export
+setClass(""SCAsol"",
+         slots=c(scaEff=""matrix""),
+         contains=""GCAsol"")
+
+setValidity(""SCAsol"",function(object){
+  errors = character()
+  if(!is.numeric(object@scaEff)){
+    errors = c(errors,""!is.numeric(scaEff)"")
+  }
+  if(object@nLoci!=nrow(object@scaEff)){
+    errors = c(errors,""nLoci!=nrow(scaEff)"")
+  }
+  if(length(errors)==0){
+    return(TRUE)
+  }else{
+    return(errors)
+  }
+})
+
 #getGv----
 setGeneric(""getGv"",function(object,...){
   standardGeneric(""getGv"")
@@ -181,4 +283,3 @@ setMethod(""getHybridGv"",signature(""TraitADG""),
             z = qnorm(w,sqrt(object@varGxeLoci))
             getHybridGvADG(object,fPop,fPar,mPop,mPar,z)
           })
-

---FILE: R/Class-Pop.R---
@@ -144,6 +144,24 @@ setMethod(""["",
           }
 )
 
+#' @describeIn MapPop Combine MapPop chromosomes
+setMethod(""c"",
+          signature(x = ""MapPop""),
+          function (x, ..., recursive = FALSE){
+            for(y in list(...)){
+              stopifnot(class(y)==""MapPop"",
+                        x@nInd==y@nInd,
+                        x@ploidy==y@ploidy)
+              x@nChr = x@nChr+y@nChr
+              x@geno = rbind(x@geno,y@geno)
+              x@genMaps = rbind(x@genMaps,y@genMaps)
+              x@nLoci = c(x@nLoci,y@nLoci)
+            }
+            validObject(x)
+            return(x)
+          }
+)
+
 # Pop ---------------------------------------------------------------------
 
 #' @title Population
@@ -176,6 +194,15 @@ setClass(""Pop"",
 
 setValidity(""Pop"",function(object){
   errors = character()
+  if(any(grepl("" "",object@id,fixed=TRUE))){
+    errors = c(errors,""id can not contain spaces"")
+  }
+  if(any(grepl("" "",object@mother,fixed=TRUE))){
+    errors = c(errors,""mother can not contain spaces"")
+  }
+  if(any(grepl("" "",object@father,fixed=TRUE))){
+    errors = c(errors,""father can not contain spaces"")
+  }
   if(object@nInd!=length(object@id)){
     errors = c(errors,""nInd!=length(id)"")
   }
@@ -194,6 +221,15 @@ setValidity(""Pop"",function(object){
   if(object@nInd!=nrow(object@ebv)){
     errors = c(errors,""nInd!=nrow(ebv)"")
   }
+  if(!is.numeric(object@gv)){
+    errors = c(errors,""!is.numeric(gv)"")
+  }
+  if(!is.numeric(object@pheno)){
+    errors = c(errors,""!is.numeric(pheno)"")
+  }
+  if(!is.numeric(object@ebv)){
+    errors = c(errors,""!is.numeric(ebv)"")
+  }
   if(object@nTraits!=ncol(object@gv)){
     errors = c(errors,""nTraits!=ncol(gv)"")
   }

---FILE: R/GS.R---
@@ -1,56 +1,3 @@
-#Class RRBLUPsolution----
-#' @title RR-BLUP Solution
-#' 
-#' @description 
-#' Contains estimated marker effects generated by \code{\link{RRBLUP}}.
-#' 
-#' @slot markerEffects list of estimated marker effects, stored as 
-#' \code{\link{TraitA-class}}
-#' @slot intercept vector of intercepts from RR-BLUP solutions
-#'
-#' @export
-setClass(""RRBLUPsolution"",
-         slots=c(markerEffects=""list"",
-                 intercept=""numeric""))
-
-setValidity(""RRBLUPsolution"",function(object){
-  errors = character()
-  if(length(object@markerEffects)!=length(object@intercept)){
-    errors = c(errors,""length(markerEffects)!=length(intercept)"")
-  }
-  if(length(errors)==0){
-    return(TRUE)
-  }else{
-    return(errors)
-  }
-})
-
-#' @title Predict GEBV
-#' 
-#' @description 
-#' Predicts GEBVs for a population using marker effects 
-#' estimated by \code{\link{RRBLUP}}.
-#' 
-#' @param object an object of \code{\link{RRBLUPsolution-class}}
-#' @param pop an object of \code{\link{Pop-class}}
-#' 
-#' @return an object of \code{\link{Pop-class}} containing the 
-#' estimated GEBVs.
-#' 
-#' @export
-#' @docType methods
-setMethod(""predict"",
-          signature(object = ""RRBLUPsolution""),
-          function(object, pop, ...){
-            ebv = lapply(object@markerEffects,getGv,pop=pop,w=0)
-            ebv = do.call(""cbind"",ebv)
-            pop@ebv = ebv
-            return(pop)
-          }
-)
-
-# GS functions----
-
 #' @title Write data records
 #' 
 #' @description
@@ -68,22 +15,34 @@ setMethod(""predict"",
 #' unless using reps for phenotypes.
 #' @param fixEff an integer indicating levels of fixed effect. Leave 
 #' value as 1 if not using different levels of fixed effects.
+#' @param includeHaplo should markers be seperated by female and male 
+#' haplotypes.
+#' @param append if true, new records are added to any existing records. 
+#' If false, any existing records are deleted before writing new records. 
+#' Note that this will delete all files in the 'dir' directory.
 #' @param simParam an object of \code{\link{SimParam-class}}
 #'
 #' @export
 writeRecords = function(pop,dir,snpChip,useQtl=FALSE,reps=1,fixEff=1,
-                        simParam=SIMPARAM){
-  stopifnot(dir.exists(dir))
+                        includeHaplo=FALSE,append=TRUE,simParam=SIMPARAM){
+  dir = normalizePath(dir, mustWork=TRUE)
+  if(!append){
+    #Delete any existing files
+    tmp = list.files(dir,full.names=TRUE)
+    if(length(tmp)>0){
+      unlink(tmp,recursive=TRUE)
+    }
+  }
   if(snpChip==0){
     nMarkers = 0
     markerType = ""NULL""
   }else{
     if(useQtl){
       nMarkers = simParam@traits[[snpChip]]@nLoci
-      markerType = paste0(""QTL_"",snpChip)
+      markerType = paste(""QTL"",snpChip,sep=""_"")
     }else{
       nMarkers = simParam@snpChips[[snpChip]]@nLoci
-      markerType = paste0(""SNP_"",snpChip)
+      markerType = paste(""SNP"",snpChip,sep=""_"")
     }
   }
   #Check that the marker set isn't being changed
@@ -108,7 +67,7 @@ writeRecords = function(pop,dir,snpChip,useQtl=FALSE,reps=1,fixEff=1,
   filePath = file.path(dir,""info.txt"")
   if(file.exists(filePath)){
     write.table(info,filePath,append=TRUE,col.names=FALSE,
-                row.names=FALSE)
+                row.names=FALSE,quote=FALSE)
   }else{
     write.table(info,filePath,row.names=FALSE)
   }
@@ -118,24 +77,40 @@ writeRecords = function(pop,dir,snpChip,useQtl=FALSE,reps=1,fixEff=1,
   #Write pheno.txt
   write.table(pop@pheno,file.path(dir,""pheno.txt""),append=TRUE,
               col.names=FALSE,row.names=FALSE)
-  #Write markers.txt, unless snpChip=0
+  #Write genotype.txt, unless snpChip=0
   if(snpChip!=0){
     if(useQtl){
       write.table(pullQtlGeno(pop,snpChip,simParam=simParam),
-                  file.path(dir,""markers.txt""),append=TRUE,
+                  file.path(dir,""genotype.txt""),append=TRUE,
                   col.names=FALSE,row.names=FALSE)
+      if(includeHaplo){
+        write.table(pullQtlHaplo(pop,snpChip,haplo=1,simParam=simParam),
+                    file.path(dir,""haplotype1.txt""),append=TRUE,
+                    col.names=FALSE,row.names=FALSE)
+        write.table(pullQtlHaplo(pop,snpChip,haplo=2,simParam=simParam),
+                    file.path(dir,""haplotype2.txt""),append=TRUE,
+                    col.names=FALSE,row.names=FALSE)
+      }
     }else{
       write.table(pullSnpGeno(pop,snpChip,simParam=simParam),
-                  file.path(dir,""markers.txt""),append=TRUE,
+                  file.path(dir,""genotype.txt""),append=TRUE,
                   col.names=FALSE,row.names=FALSE)
+      if(includeHaplo){
+        write.table(pullSnpHaplo(pop,snpChip,haplo=1,simParam=simParam),
+                    file.path(dir,""haplotype1.txt""),append=TRUE,
+                    col.names=FALSE,row.names=FALSE)
+        write.table(pullSnpHaplo(pop,snpChip,haplo=2,simParam=simParam),
+                    file.path(dir,""haplotype2.txt""),append=TRUE,
+                    col.names=FALSE,row.names=FALSE)
+      }
     }
   }
 }
 
 #' @title RR-BLUP Model
 #' 
 #' @description
-#' Fits an RR-BLUP model for subsequent prediction.
+#' Fits a typical RR-BLUP model for genomic predictions.
 #'
 #' @param dir path to a directory with output from /code{/link{writeRecords}}
 #' @param traits an integer indicating the trait or traits to model, or a 
@@ -144,7 +119,8 @@ writeRecords = function(pop,dir,snpChip,useQtl=FALSE,reps=1,fixEff=1,
 #' @param simParam an object of \code{\link{SimParam-class}}
 #'
 #' @export
-RRBLUP = function(dir,traits=1,useGv=FALSE, simParam=SIMPARAM){
+RRBLUP = function(dir, traits=1, useGv=FALSE, simParam=SIMPARAM){
+  dir = normalizePath(dir, mustWork=TRUE)
   #Read and calculate basic information
   markerInfo = read.table(file.path(dir,""info.txt""),header=TRUE,
                           comment.char="""",stringsAsFactors=FALSE)
@@ -165,83 +141,109 @@ RRBLUP = function(dir,traits=1,useGv=FALSE, simParam=SIMPARAM){
     y = y[,traits,drop=FALSE]
   }
   #Fit model
+  fixEff = as.integer(factor(markerInfo$fixEff))
   if(ncol(y)>1){
-    output = callRRBLUP_MV(y,markerInfo$fixEff,markerInfo$reps,
-                           file.path(dir,""markers.txt""),nMarkers)
+    ans = callRRBLUP_MV(y,fixEff,markerInfo$reps,
+                           file.path(dir,""genotype.txt""),nMarkers)
   }else{
-    output = callRRBLUP(y,markerInfo$fixEff,markerInfo$reps,
-                        file.path(dir,""markers.txt""),nMarkers)
+    ans = callRRBLUP(y,fixEff,markerInfo$reps,
+                        file.path(dir,""genotype.txt""),nMarkers)
   }
-  #ToDo
   tmp = unlist(strsplit(markerType,""_""))
   if(tmp[1]==""SNP""){
-    markerInfo = simParam@snpChips[[as.numeric(tmp[2])]]
+    markers = simParam@snpChips[[as.integer(tmp[2])]]
   }else{
-    markerInfo = simParam@traits[[as.numeric(tmp[2])]]
-  }
-  markerEffects = list()
-  for(i in 1:ncol(output$u)){
-    markerEffects[[i]] = new(""TraitA"",
-                             nLoci=markerInfo@nLoci,
-                             lociPerChr=markerInfo@lociPerChr,
-                             lociLoc=markerInfo@lociLoc,
-                             addEff=output$u[,i],
-                             intercept=0.0)
+    markers = simParam@traits[[as.integer(tmp[2])]]
   }
-  intercept = output$beta[1,]
-  output = new(""RRBLUPsolution"",
-               markerEffects=markerEffects,
-               intercept=intercept)
+  output = new(""RRsol"",
+               nLoci=markers@nLoci,
+               lociPerChr=markers@lociPerChr,
+               lociLoc=markers@lociLoc,
+               markerEff=ans$u,
+               fixEff=ans$beta)
   return(output)
 }
 
-#' @title SolveMKM Objective
+#' @title RR-BLUP GCA Model
 #' 
 #' @description
-#' Used internally by SolveMKM and not for to be used directly.
-#' 
-#' @param x a numeric vector
-#' @param ptrData a pointer
-#' 
+#' Fits an RR-BLUP model that estimates seperate marker effects for 
+#' the female and male gametes. Used for predicting GCA of parents 
+#' in single cross hybrids.
+#'
+#' @param dir path to a directory with output from /code{/link{writeRecords}}
+#' @param traits an integer indicating the trait or traits to model, or a 
+#' function of the traits returning a single value.
+#' @param useGv should genetic values be used instead of phenotypes
+#' @param simParam an object of \code{\link{SimParam-class}}
+#'
 #' @export
-objWeightsR = function(x, ptrData){
-  tmp = objWeights(x,ptrData)
-  return(tmp)
+RRBLUP_GCA = function(dir, traits=1, useGv=FALSE, simParam=SIMPARAM){
+  dir = normalizePath(dir, mustWork=TRUE)
+  #Read and calculate basic information
+  markerInfo = read.table(file.path(dir,""info.txt""),header=TRUE,
+                          comment.char="""",stringsAsFactors=FALSE)
+  nInd = nrow(markerInfo)
+  nMarkers = scan(file.path(dir,""nMarkers.txt""),integer(),quiet=TRUE)
+  markerType =scan(file.path(dir,""markerType.txt""),character(),quiet=TRUE)
+  #Set trait/traits for genomic selection
+  if(useGv){
+    y = scan(file.path(dir,""gv.txt""),numeric(),quiet=TRUE)
+  }else{
+    y = scan(file.path(dir,""pheno.txt""),numeric(),quiet=TRUE)
+  }
+  y = matrix(y,nrow=nInd,ncol=length(y)/nInd,byrow=TRUE)
+  if(is.function(traits)){
+    y = apply(y,1,traits)
+    y = as.matrix(y)
+  }else{
+    y = y[,traits,drop=FALSE]
+  }
+  stopifnot(ncol(y)==1)
+  #Fit model
+  fixEff = as.integer(factor(markerInfo$fixEff))
+  ans = callRRBLUP_GCA(y,fixEff,markerInfo$reps,
+                       file.path(dir,""haplotype1.txt""),
+                       file.path(dir,""haplotype2.txt""),
+                       nMarkers)
+  tmp = unlist(strsplit(markerType,""_""))
+  if(tmp[1]==""SNP""){
+    markers = simParam@snpChips[[as.integer(tmp[2])]]
+  }else{
+    markers = simParam@traits[[as.integer(tmp[2])]]
+  }
+  output = new(""GCAsol"",
+               nLoci=markers@nLoci,
+               lociPerChr=markers@lociPerChr,
+               lociLoc=markers@lociLoc,
+               femaleEff=ans$u[1:nMarkers,,drop=FALSE],
+               maleEff=ans$u[(nMarkers+1):(2*nMarkers),,drop=FALSE],
+               fixEff=ans$beta)
+  return(output)
 }
 
-#' @title Single Cross GBLUP
+#' @title RR-BLUP SCA Model
 #' 
 #' @description
-#' Saves a population's phenotypic and marker data to a directory.
+#' Fits an RR-BLUP model that models seperate effects for both female 
+#' and male gametes and dominance effects. Used for predicting single 
+#' cross hybrid performance.
 #'
-#' @param phenoDir path to a directory with hybrid phenotypes or genetic values. 
-#' The directory must contain output from /code{/link{writeRecords}} 
-#' @param femaleDir path to a directory with female genotype data. 
-#' The directory must contain output from /code{/link{writeRecords}} 
-#' @param maleDir path to a directory with male genotype data. 
-#' The directory must contain output from /code{/link{writeRecords}} 
-#' @param trait an integer indicating the trait to model, or a 
+#' @param dir path to a directory with output from /code{/link{writeRecords}}
+#' @param traits an integer indicating the trait or traits to model, or a 
 #' function of the traits returning a single value.
 #' @param useGv should genetic values be used instead of phenotypes
+#' @param simParam an object of \code{\link{SimParam-class}}
 #'
 #' @export
-SC_GBLUP = function(phenoDir,femaleDir,maleDir,trait=1,useGv=FALSE){
+RRBLUP_SCA = function(dir, traits=1, useGv=FALSE, simParam=SIMPARAM){
+  dir = normalizePath(dir, mustWork=TRUE)
   #Read and calculate basic information
-  markerInfo = read.table(file.path(phenoDir,""info.txt""),header=TRUE,
-                          comment.char="""",stringsAsFactors=FALSE)
-  femaleInfo = read.table(file.path(phenoDir,""info.txt""),header=TRUE,
+  markerInfo = read.table(file.path(dir,""info.txt""),header=TRUE,
                           comment.char="""",stringsAsFactors=FALSE)
-  maleInfo = read.table(file.path(phenoDir,""info.txt""),header=TRUE,
-                        comment.char="""",stringsAsFactors=FALSE)
   nInd = nrow(markerInfo)
-  nFemale = nrow(femaleInfo)
-  nMale = nrow(maleInfo)
-  nMarkers = scan(file.path(femaleDir,""nMarkers.txt""),integer(),quiet=TRUE)
-  tmp = scan(file.path(maleDir,""nMarkers.txt""),integer(),quiet=TRUE)
-  stopifnot(nMarkers==tmp)
-  markerType = scan(file.path(femaleDir,""markerType.txt""),character(),quiet=TRUE)
-  tmp = scan(file.path(maleDir,""markerType.txt""),character(),quiet=TRUE)
-  stopifnot(markerType==tmp)
+  nMarkers = scan(file.path(dir,""nMarkers.txt""),integer(),quiet=TRUE)
+  markerType =scan(file.path(dir,""markerType.txt""),character(),quiet=TRUE)
   #Set trait/traits for genomic selection
   if(useGv){
     y = scan(file.path(dir,""gv.txt""),numeric(),quiet=TRUE)
@@ -253,13 +255,88 @@ SC_GBLUP = function(phenoDir,femaleDir,maleDir,trait=1,useGv=FALSE){
     y = apply(y,1,traits)
     y = as.matrix(y)
   }else{
-    y = y[,trait,drop=FALSE]
+    y = y[,traits,drop=FALSE]
   }
+  stopifnot(ncol(y)==1)
   #Fit model
-  ## ToDo
-  #output = callRRBLUP(y,markerInfo$fixEff,markerInfo$reps,
-  #                    file.path(dir,""markers.txt""),nMarkers)
-  output[""markerType""] = markerType
-  class(output) = ""SC_GBLUP Solution""
+  fixEff = as.integer(factor(markerInfo$fixEff))
+  ans = callRRBLUP_SCA(y,fixEff,markerInfo$reps,
+                       file.path(dir,""haplotype1.txt""),
+                       file.path(dir,""haplotype2.txt""),
+                       nMarkers)
+  tmp = unlist(strsplit(markerType,""_""))
+  if(tmp[1]==""SNP""){
+    markers = simParam@snpChips[[as.integer(tmp[2])]]
+  }else{
+    markers = simParam@traits[[as.integer(tmp[2])]]
+  }
+  output = new(""SCAsol"",
+               nLoci=markers@nLoci,
+               lociPerChr=markers@lociPerChr,
+               lociLoc=markers@lociLoc,
+               femaleEff=ans$u[1:nMarkers,,drop=FALSE],
+               maleEff=ans$u[(nMarkers+1):(2*nMarkers),,drop=FALSE],
+               scaEff=ans$u[(2*nMarkers+1):(3*nMarkers),,drop=FALSE],
+               fixEff=ans$beta)
   return(output)
+}
+
+#' @title Set EBV
+#' 
+#' @description
+#' Sets a population's EBV with genomic estimated 
+#' values from \code{\link{RRBLUP}}, \code{\link{RRBLUP_GCA}}, 
+#' or \code{\link{RRBLUP_SCA}}.
+#' 
+#' @param pop an object of \code{\link{Pop-class}}
+#' @param solution an object of \code{\link{RRsol-class}}, 
+#' \code{\link{SCAsol-class}}, or \code{\link{GCAsol-class}}
+#' @param gender either ""male"" or ""female"" if solution is 
+#' \code{\link{GCAsol-class}}
+#' @param append should EBVs be appended to existing EBVs
+#' 
+#' @return Returns an object of \code{\link{Pop-class}}
+#' 
+#' @export
+setEBV = function(pop, solution, gender=NULL, append=FALSE){
+  if(class(solution)==""RRsol""){
+    ebv = gebvRR(solution, pop)
+  }else if(class(solution)==""GCAsol""){
+    if(toupper(gender)==""FEMALE""){
+      asFemale = TRUE
+    }else if(toupper(gender)==""MALE""){
+      asFemale = FALSE
+    }else{
+      stop(""You must specify gender as 'male' or 'female' with class(solution)='GCAsol'"")
+    }
+    ebv = gebvGCA(solution, pop, asFemale)
+  }else if(class(solution)==""SCAsol""){
+    ebv = gebvSCA(solution, pop)
+  }else{
+    stop(""No method for class(solution)="",class(solution))
+  }
+  if(append){
+    pop@ebv = cbind(pop@ebv,ebv)
+  }else{
+    pop@ebv = ebv
+  }
+  return(pop)
+}
+
+predictHybrid = function(){
+  
+}
+
+#' @title SolveMKM Objective
+#' 
+#' @description
+#' Used internally by SolveMKM and not for to be used directly.
+#' 
+#' @param x a numeric vector
+#' @param ptrData a pointer
+#' 
+#' @export
+objWeightsR = function(x, ptrData){
+  tmp = objWeights(x,ptrData)
+  return(tmp)
 }
\ No newline at end of file

---FILE: R/RcppExports.R---
@@ -5,6 +5,84 @@ AlphaFormatter <- function() {
     .Call('AlphaSimR_AlphaFormatter', PACKAGE = 'AlphaSimR')
 }
 
+gebvRR <- function(RRsol, pop) {
+    .Call('AlphaSimR_gebvRR', PACKAGE = 'AlphaSimR', RRsol, pop)
+}
+
+gebvGCA <- function(GCAsol, pop, female) {
+    .Call('AlphaSimR_gebvGCA', PACKAGE = 'AlphaSimR', GCAsol, pop, female)
+}
+
+gebvSCA <- function(SCAsol, pop) {
+    .Call('AlphaSimR_gebvSCA', PACKAGE = 'AlphaSimR', SCAsol, pop)
+}
+
+#' @title Solve Univariate Model
+#' 
+#' @description
+#' Solves a univariate mixed model of form \deqn{y=X\beta+Zu+e}.
+#'
+#' @param y a matrix with n rows and 1 column
+#' @param X a matrix with n rows and x columns
+#' @param Z a matrix with n rows and m columns
+#' @param K a matrix with m rows and m columns
+#'
+#' @export
+solveUVM <- function(y, X, Z, K) {
+    .Call('AlphaSimR_solveUVM', PACKAGE = 'AlphaSimR', y, X, Z, K)
+}
+
+#' @title Solve Multivariate Model
+#' 
+#' @description
+#' Solves a multivariate mixed model of form \deqn{Y=X\beta+Zu+e}.
+#'
+#' @param Y a matrix with n rows and q columns
+#' @param X a matrix with n rows and x columns
+#' @param Z a matrix with n rows and m columns
+#' @param K a matrix with m rows and m columns
+#' @param tol tolerance for convergence
+#'
+#' @export
+solveMVM <- function(Y, X, Z, K, tol = 1e-6) {
+    .Call('AlphaSimR_solveMVM', PACKAGE = 'AlphaSimR', Y, X, Z, K, tol)
+}
+
+objWeights <- function(x, ptrData) {
+    .Call('AlphaSimR_objWeights', PACKAGE = 'AlphaSimR', x, ptrData)
+}
+
+#' @title Solve Multikernel Model
+#' 
+#' @description
+#' Solves a univariate mixed model with multiple random effects.
+#'
+#' @param y a matrix with n rows and 1 column
+#' @param X a matrix with n rows and x columns
+#' @param Zlist a list of Z matrices
+#' @param Klist a list of K matrices
+#'
+#' @export
+solveMKM <- function(y, X, Zlist, Klist) {
+    .Call('AlphaSimR_solveMKM', PACKAGE = 'AlphaSimR', y, X, Zlist, Klist)
+}
+
+callRRBLUP <- function(y, x, reps, genoTrain, nMarker) {
+    .Call('AlphaSimR_callRRBLUP', PACKAGE = 'AlphaSimR', y, x, reps, genoTrain, nMarker)
+}
+
+callRRBLUP_MV <- function(Y, x, reps, genoTrain, nMarker) {
+    .Call('AlphaSimR_callRRBLUP_MV', PACKAGE = 'AlphaSimR', Y, x, reps, genoTrain, nMarker)
+}
+
+callRRBLUP_GCA <- function(y, x, reps, genoFemale, genoMale, nMarker) {
+    .Call('AlphaSimR_callRRBLUP_GCA', PACKAGE = 'AlphaSimR', y, x, reps, genoFemale, genoMale, nMarker)
+}
+
+callRRBLUP_SCA <- function(y, x, reps, genoFemale, genoMale, nMarker) {
+    .Call('AlphaSimR_callRRBLUP_SCA', PACKAGE = 'AlphaSimR', y, x, reps, genoFemale, genoMale, nMarker)
+}
+
 getGeno <- function(geno, lociPerChr, lociLoc) {
     .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
 }
@@ -17,6 +95,10 @@ getHaplo <- function(geno, lociPerChr, lociLoc) {
     .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
 }
 
+getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
+    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
+}
+
 getGvA <- function(trait, pop) {
     .Call('AlphaSimR_getGvA', PACKAGE = 'AlphaSimR', trait, pop)
 }
@@ -77,72 +159,6 @@ convToImat <- function(X) {
     .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
 }
 
-#' @title Solve Univariate Model
-#' 
-#' @description
-#' Solves a univariate mixed model of form \deqn{y=X\beta+Zu+e}.
-#'
-#' @param y a matrix with n rows and 1 column
-#' @param X a matrix with n rows and x columns
-#' @param Z a matrix with n rows and m columns
-#' @param K a matrix with m rows and m columns
-#'
-#' @export
-solveUVM <- function(y, X, Z, K) {
-    .Call('AlphaSimR_solveUVM', PACKAGE = 'AlphaSimR', y, X, Z, K)
-}
-
-#' @title Solve Multivariate Model
-#' 
-#' @description
-#' Solves a multivariate mixed model of form \deqn{Y=X\beta+Zu+e}.
-#'
-#' @param Y a matrix with n rows and q columns
-#' @param X a matrix with n rows and x columns
-#' @param Z a matrix with n rows and m columns
-#' @param K a matrix with m rows and m columns
-#' @param tol tolerance for convergence
-#'
-#' @export
-solveMVM <- function(Y, X, Z, K, tol = 1e-6) {
-    .Call('AlphaSimR_solveMVM', PACKAGE = 'AlphaSimR', Y, X, Z, K, tol)
-}
-
-objWeights <- function(x, ptrData) {
-    .Call('AlphaSimR_objWeights', PACKAGE = 'AlphaSimR', x, ptrData)
-}
-
-#' @title Solve Multikernel Model
-#' 
-#' @description
-#' Solves a univariate mixed model with multiple random effects.
-#'
-#' @param y a matrix with n rows and 1 column
-#' @param X a matrix with n rows and x columns
-#' @param Zlist a list of Z matrices
-#' @param Klist a list of K matrices
-#'
-#' @export
-solveMKM <- function(y, X, Zlist, Klist) {
-    .Call('AlphaSimR_solveMKM', PACKAGE = 'AlphaSimR', y, X, Zlist, Klist)
-}
-
-callGK <- function(y, x, reps, genoTrain, nMarker, maxTheta, maxIter, writeForPred = TRUE) {
-    .Call('AlphaSimR_callGK', PACKAGE = 'AlphaSimR', y, x, reps, genoTrain, nMarker, maxTheta, maxIter, writeForPred)
-}
-
-callPredGK <- function(genoPred) {
-    .Call('AlphaSimR_callPredGK', PACKAGE = 'AlphaSimR', genoPred)
-}
-
-callRRBLUP <- function(y, x, reps, genoTrain, nMarker) {
-    .Call('AlphaSimR_callRRBLUP', PACKAGE = 'AlphaSimR', y, x, reps, genoTrain, nMarker)
-}
-
-callRRBLUP_MV <- function(Y, x, reps, genoTrain, nMarker) {
-    .Call('AlphaSimR_callRRBLUP_MV', PACKAGE = 'AlphaSimR', Y, x, reps, genoTrain, nMarker)
-}
-
 readAF <- function(nInd, segSites, ploidy, keep, inbred) {
     .Call('AlphaSimR_readAF', PACKAGE = 'AlphaSimR', nInd, segSites, ploidy, keep, inbred)
 }

---FILE: R/createSimulation.R---
@@ -138,123 +138,153 @@ pickQtlLoci = function(nQtlPerChr, simParam){
   return(qtlLoci)
 }
 
-#' @title Add an additive trait
+#' @title Add additive traits
 #' 
 #' @description 
-#' Randomly assigns eligble QTLs for an additive trait. 
+#' Randomly assigns eligble QTLs for one ore more additive traits. 
+#' If simulating more than one trait, all traits will be pleiotrophic 
+#' with correlated additive effects.
 #' 
 #' @param nQtlPerChr number of QTLs per chromosome. Can be a single value or nChr values.
-#' @param meanG the mean genetic value for the trait
-#' @param varG the total genetic variance for the trait
+#' @param meanG a vector of mean genetic values for one or more traits
+#' @param varG a vector of total genetic variances for one or more traits
+#' @param corr a matrix of correlations between traits
 #' @param simParam an object of \code{\link{SimParam-class}}
 #' @param founderPop an object of \code{\link{MapPop-class}}
 #' 
 #' @return Returns an object of \code{\link{SimParam-class}}
 #' 
 #' @export
-addTraitA = function(nQtlPerChr,meanG,varG,simParam=SIMPARAM,
-                     founderPop=FOUNDERPOP){
+addTraitA = function(nQtlPerChr,meanG,varG,corr=matrix(1),
+                     simParam=SIMPARAM,founderPop=FOUNDERPOP){
+  stopifnot(length(meanG)==length(varG),
+            nrow(corr)==ncol(corr),
+            length(meanG)==length(diag(corr)))
+  nTraits = length(meanG)
   qtlLoci = pickQtlLoci(nQtlPerChr,simParam=simParam)
-  addEff = rnorm(qtlLoci@nLoci)
+  addEff = mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
+                   Sigma=corr)
   geno = getGeno(founderPop@geno,
                  qtlLoci@lociPerChr,
                  qtlLoci@lociLoc)
-  tmp = tuneTraitA(geno,addEff,varG)
-  intercept = tmp$output$intercept
-  addEff = addEff*tmp$parameter
-  trait = new(""TraitA"",
-              qtlLoci,
-              addEff=addEff,
-              intercept=meanG-intercept)
-  simParam@nTraits = simParam@nTraits + 1L
-  simParam@traits[[simParam@nTraits]] = trait
+  for(i in 1:nTraits){
+    tmp = tuneTraitA(geno,addEff[,i],varG[i])
+    intercept = tmp$output$intercept
+    addEff[,i] = addEff[,i]*tmp$parameter
+    trait = new(""TraitA"",
+                qtlLoci,
+                addEff=addEff[,i],
+                intercept=meanG[i]-intercept)
+    simParam@nTraits = simParam@nTraits + 1L
+    simParam@traits[[simParam@nTraits]] = trait
+  }
   validObject(simParam)
   return(simParam)
 }
 
-#' @title Add an additive and dominance trait
+#' @title Add additive and dominance traits
 #' 
 #' @description 
-#' Randomly assigns eligble QTLs for a trait with dominance. 
+#' Randomly assigns eligble QTLs for one or more traits with dominance. 
+#' If simulating more than one trait, all traits will be pleiotrophic 
+#' with correlated additive effects.
 #' 
 #' @param nQtlPerChr number of QTLs per chromosome. Can be a single value or nChr values.
-#' @param meanG the mean genetic value for the trait
-#' @param varG the total genetic variance for the trait
-#' @param domDegree the dominance degree of individual loci. Can be a single value or nLoci values.
+#' @param meanG a vector of mean genetic values for one or more traits
+#' @param varG a vector of total genetic variances for one or more traits
+#' @param domDegree the dominance degree of individual loci. 
+#' Can be a single value or nLoci values.
+#' @param corr a matrix of correlations between traits
 #' @param simParam an object of \code{\link{SimParam-class}}
 #' @param founderPop an object of \code{\link{MapPop-class}}
 #' 
 #' @return Returns an object of \code{\link{SimParam-class}}
 #'  
 #' @export
-addTraitAD = function(nQtlPerChr,meanG,varG,domDegree,simParam=SIMPARAM,
-                      founderPop=FOUNDERPOP){
+addTraitAD = function(nQtlPerChr,meanG,varG,domDegree,corr=matrix(1),
+                      simParam=SIMPARAM, founderPop=FOUNDERPOP){
+  stopifnot(length(meanG)==length(varG),
+            nrow(corr)==ncol(corr),
+            length(meanG)==length(diag(corr)))
+  nTraits = length(meanG)
   qtlLoci = pickQtlLoci(nQtlPerChr,simParam=simParam)
-  addEff = rnorm(qtlLoci@nLoci)
+  addEff = mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
+                   Sigma=corr)
   if(length(domDegree)==1){
     domDegree = rep(domDegree,qtlLoci@nLoci)
   }else{
     stopifnot(length(domDegree)==qtlLoci@nLoci) 
   }
-  addEff = rnorm(qtlLoci@nLoci)
-  domEff = abs(addEff)*domDegree
+  domEff = sweep(abs(addEff),1,domDegree,""*"")
   geno = getGeno(founderPop@geno,
                  qtlLoci@lociPerChr,
                  qtlLoci@lociLoc)
-  tmp = tuneTraitAD(geno,addEff,domEff,varG)
-  intercept = tmp$output$intercept
-  addEff = addEff*tmp$parameter
-  domEff = domEff*tmp$parameter
-  trait = new(""TraitAD"",
-              qtlLoci,
-              addEff=addEff,
-              domEff=domEff,
-              intercept=meanG-intercept)
-  simParam@nTraits = simParam@nTraits + 1L
-  simParam@traits[[simParam@nTraits]] = trait
+  for(i in 1:nTraits){
+    tmp = tuneTraitAD(geno,addEff[,i],domEff,varG[i])
+    intercept = tmp$output$intercept
+    addEff[,i] = addEff[,i]*tmp$parameter
+    domEffTmp = domEff*tmp$parameter
+    trait = new(""TraitAD"",
+                qtlLoci,
+                addEff=addEff[,i],
+                domEff=as.numeric(domEffTmp),
+                intercept=meanG[i]-intercept)
+    simParam@nTraits = simParam@nTraits + 1L
+    simParam@traits[[simParam@nTraits]] = trait
+  }
   validObject(simParam)
   return(simParam)
 }
 
-#' @title Add an additive GxE trait
+#' @title Add additive GxE traits
 #' 
 #' @description 
-#' Randomly assigns eligble QTLs for an additive GxE trait. 
+#' Randomly assigns eligble QTLs for one ore more additive GxE traits. 
+#' If simulating more than one trait, all traits will be pleiotrophic 
+#' with correlated effects.
 #' 
 #' @param nQtlPerChr number of QTLs per chromosome. Can be a single value or nChr values.
-#' @param meanG the mean genetic value for the trait
-#' @param varG the total genetic variance for the trait
-#' @param varGE the total genotype-by-environment variance for the 
-#' trait
+#' @param meanG a vector of mean genetic values for one or more traits
+#' @param varG a vector of total genetic variances for one or more traits
+#' @param varGE a vector of total genotype-by-environment variances for the traits
+#' @param corr a matrix of correlations between traits
 #' @param simParam an object of \code{\link{SimParam-class}}
 #' @param founderPop an object of \code{\link{MapPop-class}}
 #' 
 #' @return Returns an object of \code{\link{SimParam-class}}
 #' 
 #' @export
-addTraitAG = function(nQtlPerChr,meanG,varG,varGE,simParam=SIMPARAM,
-                      founderPop=FOUNDERPOP){
+addTraitAG = function(nQtlPerChr,meanG,varG,varGE,corr=matrix(1),
+                      simParam=SIMPARAM,founderPop=FOUNDERPOP){
+  stopifnot(length(meanG)==length(varG),
+            nrow(corr)==ncol(corr),
+            length(meanG)==length(diag(corr)),
+            length(meanG)==length(varGE))
+  nTraits = length(meanG)
   qtlLoci = pickQtlLoci(nQtlPerChr,simParam=simParam)
-  addEff = rnorm(qtlLoci@nLoci)
+  addEff = mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
+                   Sigma=corr)
+  gxeEff = mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
+                   Sigma=corr)
   geno = getGeno(founderPop@geno,
                  qtlLoci@lociPerChr,
                  qtlLoci@lociLoc)
-  tmp = tuneTraitA(geno,addEff,varG)
-  intercept = tmp$output$intercept
-  addEff = addEff*tmp$parameter
-  varGxeLoci = var(addEff)*varGE/varG
-  gxeEff = rnorm(qtlLoci@nLoci,sd=sqrt(varGxeLoci))
-  trait = new(""TraitAG"",
-              qtlLoci,
-              addEff=addEff,
-              intercept=meanG-intercept,
-              gxeEff = gxeEff,
-              varGxeLoci = varGxeLoci)
-  simParam@nTraits = simParam@nTraits + 1L
-  simParam@traits[[simParam@nTraits]] = trait
+  for(i in 1:nTraits){
+    tmp = tuneTraitA(geno,addEff[,i],varG[i])
+    intercept = tmp$output$intercept
+    addEff[,i] = addEff[,i]*tmp$parameter
+    gxeEff[,i] = gxeEff[,i]*tmp$parameter*(varGE[i]/varG[i])^0.25
+    trait = new(""TraitAG"",
+                qtlLoci,
+                addEff=addEff[,i],
+                intercept=meanG[i]-intercept,
+                gxeEff = gxeEff[,i],
+                varGxeLoci = (tmp$parameter*(varGE[i]/varG[i])^0.25)^2)
+    simParam@nTraits = simParam@nTraits + 1L
+    simParam@traits[[simParam@nTraits]] = trait
+  }
   validObject(simParam)
   return(simParam)
-  
 }
 
 #' @title Add an additive and dominance GxE trait
@@ -264,50 +294,57 @@ addTraitAG = function(nQtlPerChr,meanG,varG,varGE,simParam=SIMPARAM,
 #' 
 #' @param nQtlPerChr number of QTLs per chromosome. Can be a single 
 #' value or nChr values.
-#' @param meanG the mean genetic value for the trait
-#' @param varG the total genetic variance for the trait
+#' @param meanG a vector of mean genetic values for one or more traits
+#' @param varG a vector of total genetic variances for one or more traits
 #' @param domDegree the dominance degree of individual loci. 
 #' Can be a single value or nLoci values.
-#' @param varGE the total genotype-by-environment variance for the 
-#' trait
+#' @param varGE a vector of total genotype-by-environment variances for the traits
+#' @param corr a matrix of correlations between traits
 #' @param simParam an object of \code{\link{SimParam-class}}
 #' @param founderPop an object of \code{\link{MapPop-class}}
 #' 
 #' @return Returns an object of \code{\link{SimParam-class}}
 #'  
 #' @export
-addTraitADG = function(nQtlPerChr,meanG,varG,domDegree,varGE,
+addTraitADG = function(nQtlPerChr,meanG,varG,domDegree,varGE,corr=matrix(1),
                        simParam=SIMPARAM,founderPop=FOUNDERPOP){
+  stopifnot(length(meanG)==length(varG),
+            nrow(corr)==ncol(corr),
+            length(meanG)==length(diag(corr)),
+            length(meanG)==length(varGE))
+  nTraits = length(meanG)
   qtlLoci = pickQtlLoci(nQtlPerChr,simParam=simParam)
-  addEff = rnorm(qtlLoci@nLoci)
+  addEff = mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
+                   Sigma=corr)
+  gxeEff = mvrnorm(qtlLoci@nLoci,mu=rep(0,nTraits),
+                   Sigma=corr)
   if(length(domDegree)==1){
     domDegree = rep(domDegree,qtlLoci@nLoci)
   }else{
     stopifnot(length(domDegree)==qtlLoci@nLoci) 
   }
-  addEff = rnorm(qtlLoci@nLoci)
-  domEff = abs(addEff)*domDegree
+  domEff = sweep(abs(addEff),1,domDegree,""*"")
   geno = getGeno(founderPop@geno,
                  qtlLoci@lociPerChr,
                  qtlLoci@lociLoc)
-  tmp = tuneTraitAD(geno,addEff,domEff,varG)
-  intercept = tmp$output$intercept
-  addEff = addEff*tmp$parameter
-  domEff = domEff*tmp$parameter
-  varGxeLoci = var(addEff)*varGE/varG
-  gxeEff = rnorm(qtlLoci@nLoci,sd=sqrt(varGxeLoci))
-  trait = new(""TraitADG"",
-              qtlLoci,
-              addEff=addEff,
-              domEff=domEff,
-              intercept=meanG-intercept,
-              gxeEff = gxeEff,
-              varGxeLoci = varGxeLoci)
-  simParam@nTraits = simParam@nTraits + 1L
-  simParam@traits[[simParam@nTraits]] = trait
+  for(i in 1:nTraits){
+    tmp = tuneTraitAD(geno,addEff[,i],domEff,varG[i])
+    intercept = tmp$output$intercept
+    addEff[,i] = addEff[,i]*tmp$parameter
+    domEffTmp = domEff*tmp$parameter
+    gxeEff[,i] = gxeEff[,i]*tmp$parameter*(varGE[i]/varG[i])^0.25
+    trait = new(""TraitADG"",
+                qtlLoci,
+                addEff=addEff[,i],
+                domEff=as.numeric(domEffTmp),
+                intercept=meanG[i]-intercept,
+                gxeEff = gxeEff[,i],
+                varGxeLoci = (tmp$parameter*(varGE[i]/varG[i])^0.25)^2)
+    simParam@nTraits = simParam@nTraits + 1L
+    simParam@traits[[simParam@nTraits]] = trait
+  }
   validObject(simParam)
   return(simParam)
-  
 }
 
 #' @title Create new Population

---FILE: R/hybrids.R---
@@ -132,6 +132,9 @@ calcGCA = function(pop,useGv=FALSE){
     y=pop@gv
   }else{
     y=pop@pheno
+    if(any(is.na(y))){
+      stop(""Missing values in pop@pheno"")
+    }
   }
   colnames(y) = paste0(""Trait"",1:pop@nTraits)
   output = list()

---FILE: R/pullGeno.R---
@@ -47,17 +47,32 @@ pullQtlGeno = function(pop, trait=1, simParam=SIMPARAM){
 #' @param pop an object of \code{\link{Pop-class}}
 #' @param snpChip an integer. Indicates which SNP 
 #' chip's haplotypes to retrieve.
+#' @param haplo either ""all"" for all haplotypes or an integer 
+#' for a single set of haplotypes. Use a value of 1 for female 
+#' haplotyes and a value of 2 for male haplotypes.
 #' @param simParam an object of \code{\link{SimParam-class}}
 #'
 #' @return Returns a matrix of SNP haplotypes.
 #' @export
-pullSnpHaplo = function(pop, snpChip=1, simParam=SIMPARAM){
-  output = getHaplo(pop@geno,
-                    simParam@snpChips[[snpChip]]@lociPerChr,
-                    simParam@snpChips[[snpChip]]@lociLoc)
-  output = convToImat(output)
-  rownames(output) = paste(rep(pop@id,each=pop@ploidy),
-                           rep(1:pop@ploidy,pop@nInd),sep=""_"")
+pullSnpHaplo = function(pop, snpChip=1, haplo=""all"", 
+                        simParam=SIMPARAM){
+  if(haplo==""all""){
+    output = getHaplo(pop@geno,
+                      simParam@snpChips[[snpChip]]@lociPerChr,
+                      simParam@snpChips[[snpChip]]@lociLoc)
+    output = convToImat(output)
+    rownames(output) = paste(rep(pop@id,each=pop@ploidy),
+                             rep(1:pop@ploidy,pop@nInd),sep=""_"")
+  }else{
+    stopifnot(haplo%in%c(1,2))
+    output = getOneHaplo(pop@geno,
+                         simParam@snpChips[[snpChip]]@lociPerChr,
+                         simParam@snpChips[[snpChip]]@lociLoc,
+                         as.integer(haplo))
+    output = convToImat(output)
+    rownames(output) = paste(pop@id,rep(haplo,pop@nInd),sep=""_"")
+    
+  }
   colnames(output) = paste(""SNP"",1:ncol(output),sep=""_"")
   return(output)
 }
@@ -69,17 +84,32 @@ pullSnpHaplo = function(pop, snpChip=1, simParam=SIMPARAM){
 #' @param pop an object of \code{\link{Pop-class}}
 #' @param trait an integer. Indicates which trait's
 #' QTL haplotypes to retrieve.
+#' @param haplo either ""all"" for all haplotypes or an integer 
+#' for a single set of haplotypes. Use a value of 1 for female 
+#' haplotyes and a value of 2 for male haplotypes.
 #' @param simParam an object of \code{\link{SimParam-class}}
 #'
 #' @return Returns a matrix of QTL haplotypes.
 #' @export
-pullQtlHaplo = function(pop, trait=1, simParam=SIMPARAM){
-  output = getHaplo(pop@geno,
-                    simParam@traits[[trait]]@lociPerChr,
-                    simParam@traits[[trait]]@lociLoc)
-  output = convToImat(output)
-  rownames(output) = paste(rep(pop@id,each=pop@ploidy),
-                           rep(1:pop@ploidy,pop@nInd),sep=""_"")
+pullQtlHaplo = function(pop, trait=1, haplo=""all"", 
+                        simParam=SIMPARAM){
+  if(haplo==""all""){
+    output = getHaplo(pop@geno,
+                      simParam@traits[[trait]]@lociPerChr,
+                      simParam@traits[[trait]]@lociLoc)
+    output = convToImat(output)
+    rownames(output) = paste(rep(pop@id,each=pop@ploidy),
+                             rep(1:pop@ploidy,pop@nInd),sep=""_"")
+  }else{
+    stopifnot(haplo%in%c(1,2))
+    output = getOneHaplo(pop@geno,
+                         simParam@traits[[trait]]@lociPerChr,
+                         simParam@traits[[trait]]@lociLoc,
+                         as.integer(haplo))
+    output = convToImat(output)
+    rownames(output) = paste(pop@id,rep(haplo,pop@nInd),sep=""_"")
+    
+  }
   colnames(output) = paste(""QTL"",1:ncol(output),sep=""_"")
   return(output)
 }

---FILE: man/GCAsol-class.Rd---
@@ -0,0 +1,20 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/Class-LociMap.R
+\docType{class}
+\name{GCAsol-class}
+\alias{GCAsol-class}
+\title{RR-BLUP GCA Solution}
+\description{
+Extends \code{\link{LociMap-class}} 
+to contain estimated effects from \code{\link{RRBLUP_GCA}}
+}
+\section{Slots}{
+
+\describe{
+\item{\code{femaleEff}}{marker GCA for ""female"" pool}
+
+\item{\code{maleEff}}{marker GCA for ""male"" pool}
+
+\item{\code{fixEff}}{Estimates for fixed effects}
+}}
+

---FILE: man/MapPop-class.Rd---
@@ -4,9 +4,12 @@
 \name{MapPop-class}
 \alias{MapPop-class}
 \alias{[,MapPop-method}
+\alias{c,MapPop-method}
 \title{Raw population with genetic map}
 \usage{
 \S4method{[}{MapPop}(x, i)
+
+\S4method{c}{MapPop}(x, ..., recursive = FALSE)
 }
 \description{
 Extends \code{\link{RawPop-class}} to add a genetic map. 
@@ -17,6 +20,8 @@ for creating initial populations and setting traits in the
 \section{Methods (by generic)}{
 \itemize{
 \item \code{[}: Extract \code{\link{RawPop-class}} by index
+
+\item \code{c}: Combine MapPop chromosomes
 }}
 
 \section{Slots}{

---FILE: man/RRBLUP.Rd---
@@ -17,5 +17,5 @@ function of the traits returning a single value.}
 \item{simParam}{an object of \code{\link{SimParam-class}}}
 }
 \description{
-Fits an RR-BLUP model for subsequent prediction.
+Fits a typical RR-BLUP model for genomic predictions.
 }

---FILE: man/RRBLUP_GCA.Rd---
@@ -0,0 +1,23 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/GS.R
+\name{RRBLUP_GCA}
+\alias{RRBLUP_GCA}
+\title{RR-BLUP GCA Model}
+\usage{
+RRBLUP_GCA(dir, traits = 1, useGv = FALSE, simParam = SIMPARAM)
+}
+\arguments{
+\item{dir}{path to a directory with output from /code{/link{writeRecords}}}
+
+\item{traits}{an integer indicating the trait or traits to model, or a 
+function of the traits returning a single value.}
+
+\item{useGv}{should genetic values be used instead of phenotypes}
+
+\item{simParam}{an object of \code{\link{SimParam-class}}}
+}
+\description{
+Fits an RR-BLUP model that estimates seperate marker effects for 
+the female and male gametes. Used for predicting GCA of parents 
+in single cross hybrids.
+}

---FILE: man/RRBLUP_SCA.Rd---
@@ -0,0 +1,23 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/GS.R
+\name{RRBLUP_SCA}
+\alias{RRBLUP_SCA}
+\title{RR-BLUP SCA Model}
+\usage{
+RRBLUP_SCA(dir, traits = 1, useGv = FALSE, simParam = SIMPARAM)
+}
+\arguments{
+\item{dir}{path to a directory with output from /code{/link{writeRecords}}}
+
+\item{traits}{an integer indicating the trait or traits to model, or a 
+function of the traits returning a single value.}
+
+\item{useGv}{should genetic values be used instead of phenotypes}
+
+\item{simParam}{an object of \code{\link{SimParam-class}}}
+}
+\description{
+Fits an RR-BLUP model that models seperate effects for both female 
+and male gametes and dominance effects. Used for predicting single 
+cross hybrid performance.
+}

---FILE: man/RRBLUPsolution-class.Rd---
@@ -1,18 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/GS.R
-\docType{class}
-\name{RRBLUPsolution-class}
-\alias{RRBLUPsolution-class}
-\title{RR-BLUP Solution}
-\description{
-Contains estimated marker effects generated by \code{\link{RRBLUP}}.
-}
-\section{Slots}{
-
-\describe{
-\item{\code{markerEffects}}{list of estimated marker effects, stored as 
-\code{\link{TraitA-class}}}
-
-\item{\code{intercept}}{vector of intercepts from RR-BLUP solutions}
-}}
-

---FILE: man/RRsol-class.Rd---
@@ -0,0 +1,18 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/Class-LociMap.R
+\docType{class}
+\name{RRsol-class}
+\alias{RRsol-class}
+\title{RR-BLUP Solution}
+\description{
+Extends \code{\link{LociMap-class}} 
+to contain estimated effects from \code{\link{RRBLUP}}
+}
+\section{Slots}{
+
+\describe{
+\item{\code{markerEff}}{GEBVs for markers}
+
+\item{\code{fixEff}}{Estimates for fixed effects}
+}}
+

---FILE: man/SCAsol-class.Rd---
@@ -0,0 +1,16 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/Class-LociMap.R
+\docType{class}
+\name{SCAsol-class}
+\alias{SCAsol-class}
+\title{RR-BLUP SCA Solution}
+\description{
+Extends \code{\link{GCAsol-class}} 
+to contain estimated effects from \code{\link{RRBLUP_SCA}}
+}
+\section{Slots}{
+
+\describe{
+\item{\code{scaEff}}{marker SCA effects}
+}}
+

---FILE: man/SC_GBLUP.Rd---
@@ -1,26 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/GS.R
-\name{SC_GBLUP}
-\alias{SC_GBLUP}
-\title{Single Cross GBLUP}
-\usage{
-SC_GBLUP(phenoDir, femaleDir, maleDir, trait = 1, useGv = FALSE)
-}
-\arguments{
-\item{phenoDir}{path to a directory with hybrid phenotypes or genetic values. 
-The directory must contain output from /code{/link{writeRecords}}}
-
-\item{femaleDir}{path to a directory with female genotype data. 
-The directory must contain output from /code{/link{writeRecords}}}
-
-\item{maleDir}{path to a directory with male genotype data. 
-The directory must contain output from /code{/link{writeRecords}}}
-
-\item{trait}{an integer indicating the trait to model, or a 
-function of the traits returning a single value.}
-
-\item{useGv}{should genetic values be used instead of phenotypes}
-}
-\description{
-Saves a population's phenotypic and marker data to a directory.
-}

---FILE: man/addTraitA.Rd---
@@ -2,17 +2,19 @@
 % Please edit documentation in R/createSimulation.R
 \name{addTraitA}
 \alias{addTraitA}
-\title{Add an additive trait}
+\title{Add additive traits}
 \usage{
-addTraitA(nQtlPerChr, meanG, varG, simParam = SIMPARAM,
+addTraitA(nQtlPerChr, meanG, varG, corr = matrix(1), simParam = SIMPARAM,
   founderPop = FOUNDERPOP)
 }
 \arguments{
 \item{nQtlPerChr}{number of QTLs per chromosome. Can be a single value or nChr values.}
 
-\item{meanG}{the mean genetic value for the trait}
+\item{meanG}{a vector of mean genetic values for one or more traits}
 
-\item{varG}{the total genetic variance for the trait}
+\item{varG}{a vector of total genetic variances for one or more traits}
+
+\item{corr}{a matrix of correlations between traits}
 
 \item{simParam}{an object of \code{\link{SimParam-class}}}
 
@@ -22,5 +24,7 @@ addTraitA(nQtlPerChr, meanG, varG, simParam = SIMPARAM,
 Returns an object of \code{\link{SimParam-class}}
 }
 \description{
-Randomly assigns eligble QTLs for an additive trait.
+Randomly assigns eligble QTLs for one ore more additive traits. 
+If simulating more than one trait, all traits will be pleiotrophic 
+with correlated additive effects.
 }

---FILE: man/addTraitAD.Rd---
@@ -2,19 +2,22 @@
 % Please edit documentation in R/createSimulation.R
 \name{addTraitAD}
 \alias{addTraitAD}
-\title{Add an additive and dominance trait}
+\title{Add additive and dominance traits}
 \usage{
-addTraitAD(nQtlPerChr, meanG, varG, domDegree, simParam = SIMPARAM,
-  founderPop = FOUNDERPOP)
+addTraitAD(nQtlPerChr, meanG, varG, domDegree, corr = matrix(1),
+  simParam = SIMPARAM, founderPop = FOUNDERPOP)
 }
 \arguments{
 \item{nQtlPerChr}{number of QTLs per chromosome. Can be a single value or nChr values.}
 
-\item{meanG}{the mean genetic value for the trait}
+\item{meanG}{a vector of mean genetic values for one or more traits}
 
-\item{varG}{the total genetic variance for the trait}
+\item{varG}{a vector of total genetic variances for one or more traits}
 
-\item{domDegree}{the dominance degree of individual loci. Can be a single value or nLoci values.}
+\item{domDegree}{the dominance degree of individual loci. 
+Can be a single value or nLoci values.}
+
+\item{corr}{a matrix of correlations between traits}
 
 \item{simParam}{an object of \code{\link{SimParam-class}}}
 
@@ -24,5 +27,7 @@ addTraitAD(nQtlPerChr, meanG, varG, domDegree, simParam = SIMPARAM,
 Returns an object of \code{\link{SimParam-class}}
 }
 \description{
-Randomly assigns eligble QTLs for a trait with dominance.
+Randomly assigns eligble QTLs for one or more traits with dominance. 
+If simulating more than one trait, all traits will be pleiotrophic 
+with correlated additive effects.
 }

---FILE: man/addTraitADG.Rd---
@@ -4,22 +4,23 @@
 \alias{addTraitADG}
 \title{Add an additive and dominance GxE trait}
 \usage{
-addTraitADG(nQtlPerChr, meanG, varG, domDegree, varGE, simParam = SIMPARAM,
-  founderPop = FOUNDERPOP)
+addTraitADG(nQtlPerChr, meanG, varG, domDegree, varGE, corr = matrix(1),
+  simParam = SIMPARAM, founderPop = FOUNDERPOP)
 }
 \arguments{
 \item{nQtlPerChr}{number of QTLs per chromosome. Can be a single 
 value or nChr values.}
 
-\item{meanG}{the mean genetic value for the trait}
+\item{meanG}{a vector of mean genetic values for one or more traits}
 
-\item{varG}{the total genetic variance for the trait}
+\item{varG}{a vector of total genetic variances for one or more traits}
 
 \item{domDegree}{the dominance degree of individual loci. 
 Can be a single value or nLoci values.}
 
-\item{varGE}{the total genotype-by-environment variance for the 
-trait}
+\item{varGE}{a vector of total genotype-by-environment variances for the traits}
+
+\item{corr}{a matrix of correlations between traits}
 
 \item{simParam}{an object of \code{\link{SimParam-class}}}
 

---FILE: man/addTraitAG.Rd---
@@ -2,20 +2,21 @@
 % Please edit documentation in R/createSimulation.R
 \name{addTraitAG}
 \alias{addTraitAG}
-\title{Add an additive GxE trait}
+\title{Add additive GxE traits}
 \usage{
-addTraitAG(nQtlPerChr, meanG, varG, varGE, simParam = SIMPARAM,
-  founderPop = FOUNDERPOP)
+addTraitAG(nQtlPerChr, meanG, varG, varGE, corr = matrix(1),
+  simParam = SIMPARAM, founderPop = FOUNDERPOP)
 }
 \arguments{
 \item{nQtlPerChr}{number of QTLs per chromosome. Can be a single value or nChr values.}
 
-\item{meanG}{the mean genetic value for the trait}
+\item{meanG}{a vector of mean genetic values for one or more traits}
 
-\item{varG}{the total genetic variance for the trait}
+\item{varG}{a vector of total genetic variances for one or more traits}
 
-\item{varGE}{the total genotype-by-environment variance for the 
-trait}
+\item{varGE}{a vector of total genotype-by-environment variances for the traits}
+
+\item{corr}{a matrix of correlations between traits}
 
 \item{simParam}{an object of \code{\link{SimParam-class}}}
 
@@ -25,5 +26,7 @@ trait}
 Returns an object of \code{\link{SimParam-class}}
 }
 \description{
-Randomly assigns eligble QTLs for an additive GxE trait.
+Randomly assigns eligble QTLs for one ore more additive GxE traits. 
+If simulating more than one trait, all traits will be pleiotrophic 
+with correlated effects.
 }

---FILE: man/predict-RRBLUPsolution-method.Rd---
@@ -1,22 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/GS.R
-\docType{methods}
-\name{predict,RRBLUPsolution-method}
-\alias{predict,RRBLUPsolution-method}
-\title{Predict GEBV}
-\usage{
-\S4method{predict}{RRBLUPsolution}(object, pop, ...)
-}
-\arguments{
-\item{object}{an object of \code{\link{RRBLUPsolution-class}}}
-
-\item{pop}{an object of \code{\link{Pop-class}}}
-}
-\value{
-an object of \code{\link{Pop-class}} containing the 
-estimated GEBVs.
-}
-\description{
-Predicts GEBVs for a population using marker effects 
-estimated by \code{\link{RRBLUP}}.
-}

---FILE: man/pullQtlHaplo.Rd---
@@ -4,14 +4,18 @@
 \alias{pullQtlHaplo}
 \title{Pull QTL haplotypes}
 \usage{
-pullQtlHaplo(pop, trait = 1, simParam = SIMPARAM)
+pullQtlHaplo(pop, trait = 1, haplo = ""all"", simParam = SIMPARAM)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}}}
 
 \item{trait}{an integer. Indicates which trait's
 QTL haplotypes to retrieve.}
 
+\item{haplo}{either ""all"" for all haplotypes or an integer 
+for a single set of haplotypes. Use a value of 1 for female 
+haplotyes and a value of 2 for male haplotypes.}
+
 \item{simParam}{an object of \code{\link{SimParam-class}}}
 }
 \value{

---FILE: man/pullSnpHaplo.Rd---
@@ -4,14 +4,18 @@
 \alias{pullSnpHaplo}
 \title{Pull SNP haplotypes}
 \usage{
-pullSnpHaplo(pop, snpChip = 1, simParam = SIMPARAM)
+pullSnpHaplo(pop, snpChip = 1, haplo = ""all"", simParam = SIMPARAM)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}}}
 
 \item{snpChip}{an integer. Indicates which SNP 
 chip's haplotypes to retrieve.}
 
+\item{haplo}{either ""all"" for all haplotypes or an integer 
+for a single set of haplotypes. Use a value of 1 for female 
+haplotyes and a value of 2 for male haplotypes.}
+
 \item{simParam}{an object of \code{\link{SimParam-class}}}
 }
 \value{

---FILE: man/setEBV.Rd---
@@ -0,0 +1,27 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/GS.R
+\name{setEBV}
+\alias{setEBV}
+\title{Set EBV}
+\usage{
+setEBV(pop, solution, gender = NULL, append = FALSE)
+}
+\arguments{
+\item{pop}{an object of \code{\link{Pop-class}}}
+
+\item{solution}{an object of \code{\link{RRsol-class}}, 
+\code{\link{SCAsol-class}}, or \code{\link{GCAsol-class}}}
+
+\item{gender}{either ""male"" or ""female"" if solution is 
+\code{\link{GCAsol-class}}}
+
+\item{append}{should EBVs be appended to existing EBVs}
+}
+\value{
+Returns an object of \code{\link{Pop-class}}
+}
+\description{
+Sets a population's EBV with genomic estimated 
+values from \code{\link{RRBLUP}}, \code{\link{RRBLUP_GCA}}, 
+or \code{\link{RRBLUP_SCA}}.
+}

---FILE: man/writeRecords.Rd---
@@ -5,7 +5,7 @@
 \title{Write data records}
 \usage{
 writeRecords(pop, dir, snpChip, useQtl = FALSE, reps = 1, fixEff = 1,
-  simParam = SIMPARAM)
+  includeHaplo = FALSE, append = TRUE, simParam = SIMPARAM)
 }
 \arguments{
 \item{pop}{an object of \code{\link{Pop-class}}}
@@ -26,6 +26,13 @@ unless using reps for phenotypes.}
 \item{fixEff}{an integer indicating levels of fixed effect. Leave 
 value as 1 if not using different levels of fixed effects.}
 
+\item{includeHaplo}{should markers be seperated by female and male 
+haplotypes.}
+
+\item{append}{if true, new records are added to any existing records. 
+If false, any existing records are deleted before writing new records. 
+Note that this will delete all files in the 'dir' directory.}
+
 \item{simParam}{an object of \code{\link{SimParam-class}}}
 }
 \description{

---FILE: src/GEBV.cpp---
@@ -0,0 +1,55 @@
+// [[Rcpp::depends(RcppArmadillo)]]
+#include ""alphasimr.h""
+
+
+// Retrieves GEBVs for RRsol
+// [[Rcpp::export]]
+arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop){
+  arma::mat a = RRsol.slot(""markerEff"");
+  arma::Mat<unsigned char> geno;
+  geno = getGeno(pop.slot(""geno""), 
+                 RRsol.slot(""lociPerChr""),
+                 RRsol.slot(""lociLoc""));
+  arma::mat output = geno*a;
+  return output;
+}
+
+// [[Rcpp::export]]
+arma::mat gebvGCA(const Rcpp::S4& GCAsol, const Rcpp::S4& pop, 
+                  bool female){
+  arma::mat a;
+  if(female){
+    a = Rcpp::as<arma::mat>(GCAsol.slot(""femaleEff""));
+  }else{
+    a = Rcpp::as<arma::mat>(GCAsol.slot(""maleEff""));
+  }
+  arma::Mat<unsigned char> geno;
+  geno = getGeno(pop.slot(""geno""), 
+                 GCAsol.slot(""lociPerChr""),
+                 GCAsol.slot(""lociLoc""));
+  arma::mat X = arma::conv_to<arma::mat>::from(geno);
+  X = X/2;
+  return X*a;
+}
+
+// [[Rcpp::export]]
+arma::mat gebvSCA(const Rcpp::S4& SCAsol, const Rcpp::S4& pop){
+  arma::mat a1 = SCAsol.slot(""femaleEff"");
+  arma::mat a2 = SCAsol.slot(""maleEff"");
+  arma::mat a3 = SCAsol.slot(""scaEff"");
+  arma::Mat<unsigned char> geno;
+  geno = getOneHaplo(pop.slot(""geno""), 
+                     SCAsol.slot(""lociPerChr""),
+                     SCAsol.slot(""lociLoc""), 
+                     1);
+  arma::mat X1 = arma::conv_to<arma::mat>::from(geno);
+  X1 = X1*2-1;
+  geno = getOneHaplo(pop.slot(""geno""), 
+                     SCAsol.slot(""lociPerChr""),
+                     SCAsol.slot(""lociLoc""), 
+                     2);
+  arma::mat X2 = arma::conv_to<arma::mat>::from(geno);
+  X2 = X2*2-1;
+  arma::mat output = X1*a1 + X2*a2 + (X1%X2)*a3;
+  return output;
+}

---FILE: src/MME.cpp---
@@ -1,13 +1,4 @@
-/*
- * Initial code from:
- * ""A two-part strategy for using genomic selection to develop inbred lines""
- * (Gaynor et al., 2017)
- * 
- * Some of functions are not used
- * 
- * Based on code in R/EMMREML and R/rrBLUP
- * 
- */
+// Functions based on code in R/EMMREML
 #include ""alphasimr.h""
 #include <iostream>
 #include <string>
@@ -258,67 +249,6 @@ void sweepReps(arma::mat& X, arma::vec& reps){
   }
 }
 
-// Calculates a distance matrix from a marker matrix
-// Uses binomial theorem trick
-// Inspired by code from:
-// http://blog.felixriedel.com/2013/05/pairwise-distances-in-r/
-// First described here: 
-// http://blog.smola.org/post/969195661/in-praise-of-the-second-binomial-formula
-arma::mat fastDist(arma::mat& X){
-  arma::colvec Xn =  sum(square(X),1);
-  arma::mat D = -2*(X*X.t());
-  D.each_col() += Xn;
-  D.each_row() += Xn.t();
-  D = sqrt(D);
-  D.diag().zeros(); //Removes NaN values
-  if(D.has_nan()){
-    //Assuming there won't be any Inf values
-    D.elem(find_nonfinite(D)).fill(0.0); 
-  }
-  return D; 
-}
-
-arma::mat fastPairDist(arma::mat& X, arma::mat& Y){
-  arma::colvec Xn =  sum(square(X),1);
-  arma::colvec Yn =  sum(square(Y),1);
-  arma::mat D = -2*(X*Y.t());
-  D.each_col() += Xn;
-  D.each_row() += Yn.t();
-  D = sqrt(D);
-  if(D.has_nan()){
-    //Assuming there won't be any Inf values
-    D.elem(find_nonfinite(D)).fill(0.0); 
-  }
-  return D; 
-}
-
-// Calculates VanRaden's G matrix
-// uses 2,1,0 coding of markers
-// modifies X and p
-arma::mat calcG(arma::mat& X, arma::rowvec& p){
-  p = mean(X,0)/2.0;
-  X.each_row() -= 2*p;
-  arma::mat G = X*X.t();
-  G = G/(2.0*sum(p%(1-p)));
-  return G;
-}
-
-// Creates G matrix from markers using readMat for markers
-arma::mat makeG(std::string fileName, int rows, int cols, char sep=' ',
-                int skipRows=0, int skipCols=0){
-  arma::mat X = readMat(fileName,rows,cols,sep,skipRows,skipCols);
-  arma::rowvec p(X.n_cols);
-  arma::mat G = calcG(X,p);
-  return G;
-}
-
-// Gaussian kernel function
-// D is an Euclidean distance matrix
-// theta is the tuning parameter
-arma::mat calcGK(arma::mat& D, double theta){
-  return exp(-1.0*square(D/theta));
-}
-
 //' @title Solve Univariate Model
 //' 
 //' @description
@@ -464,6 +394,8 @@ Rcpp::NumericVector objWeights(Rcpp::NumericVector x,
   return output;
 }
 
+// Note that this function is slower than the R/EMMREML version on 
+// small datasets and faster on large datasets
 //' @title Solve Multikernel Model
 //' 
 //' @description
@@ -503,98 +435,12 @@ Rcpp::List solveMKM(arma::mat& y, arma::mat& X,
                             Rcpp::Named(""weights"")=ptrData->weights);
 }
 
-// Objective function for Gaussian kernel method
-Rcpp::List gaussObj(double theta, Rcpp::List args){
-  Rcpp::List output;
-  arma::mat D = args[""D""];
-  output = solveUVM(args[""y""],args[""X""],args[""Z""],calcGK(D,theta));
-  return Rcpp::List::create(Rcpp::Named(""objective"")=output[""LL""],
-                            Rcpp::Named(""output"")=output);
-}
-
-// Objective function for multivariate Gaussian kernel method
-Rcpp::List gaussObjMV(double theta, Rcpp::List args){
-  Rcpp::List output;
-  arma::mat D = args[""D""];
-  output = solveMVM(args[""Y""],args[""X""],args[""Z""],calcGK(D,theta));
-  return Rcpp::List::create(Rcpp::Named(""objective"")=output[""LL""],
-                            Rcpp::Named(""output"")=output);
-}
-
-// Called by GK R function
-// [[Rcpp::export]]
-Rcpp::List callGK(arma::mat y, arma::uvec x, arma::vec reps,
-                     std::string genoTrain, int nMarker, 
-                     double maxTheta, int maxIter, 
-                     bool writeForPred=true){
-  Rcpp::List output;
-  arma::mat X = makeX(x);
-  arma::mat Z;
-  Z.eye(y.n_elem,y.n_elem);
-  reps = sqrt(1.0/reps);
-  sweepReps(y,reps);
-  sweepReps(X,reps);
-  sweepReps(Z,reps);
-  arma::mat M = readMat(genoTrain,y.n_elem,nMarker,' ');
-  arma::mat D = fastDist(M);
-  output = optimize(*gaussObj,
-                    Rcpp::List::create(Rcpp::Named(""y"")=y,
-                                       Rcpp::Named(""X"")=X,
-                                       Rcpp::Named(""Z"")=Z,
-                                       Rcpp::Named(""D"")=D),
-                                       1e-10,
-                                       maxTheta*D.max(),
-                                       maxIter,
-                                       true);
-  if(writeForPred){
-    M.save(""M.bin"");
-    arma::mat theta(1,1);
-    theta(0,0) = double(output[""parameter""]);
-    theta.save(""theta.bin"");
-    Rcpp::List tmp = output[""output""];
-    double Vu = tmp[""Vu""];
-    double Ve = tmp[""Ve""];
-    Rcpp::NumericMatrix tmpBeta = tmp[""beta""];
-    arma::mat beta = Rcpp::as<arma::mat>(tmpBeta);
-    arma::mat intercept(1,1);
-    intercept = beta(0,0);
-    intercept.save(""intercept.bin"");
-    arma::mat Yt = y - X*beta;
-    arma::mat W = inv(calcGK(D, double(theta(0,0)))+
-      Ve/Vu*arma::eye(D.n_rows,D.n_cols));
-    W = W*Yt;
-    W.save(""W.bin"");
-  }
-  return output;
-}
-
-// Predicts BLUP from callGK output
-// Called from PredGK R function
-// [[Rcpp::export]]
-arma::mat callPredGK(const Rcpp::DataFrame& genoPred){
-  arma::mat X;
-  //X = df2mat1(genoPred);
-  arma::mat M;
-  M.load(""M.bin"");
-  arma::mat W;
-  W.load(""W.bin"");
-  arma::mat tmpInter;
-  tmpInter.load(""intercept.bin"");
-  double intercept = tmpInter(0,0);
-  arma::mat tmpTheta;
-  tmpTheta.load(""theta.bin"");
-  double theta = tmpTheta(0,0);
-  arma::mat Cut = fastPairDist(X,M);
-  Cut = calcGK(Cut,theta);
-  return Cut*W+intercept;
-}
-
 // Called by RRBLUP function
 // [[Rcpp::export]]
 Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, 
                          std::string genoTrain, int nMarker){
   arma::mat X = makeX(x);
-  arma::mat Z = readMat(genoTrain,y.n_elem,nMarker,' ');
+  arma::mat Z = readMat(genoTrain,y.n_elem,nMarker,' ',0,0);
   reps = sqrt(1.0/reps);
   sweepReps(y,reps);
   sweepReps(X,reps);
@@ -608,7 +454,7 @@ Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps,
 Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, 
                             std::string genoTrain, int nMarker){
   arma::mat X = makeX(x);
-  arma::mat Z = readMat(genoTrain,Y.n_rows,nMarker,' ');
+  arma::mat Z = readMat(genoTrain,Y.n_rows,nMarker,' ',0,0);
   reps = sqrt(1.0/reps);
   sweepReps(Y,reps);
   sweepReps(X,reps);
@@ -617,22 +463,44 @@ Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps,
   return solveMVM(Y, X, Z, K);
 }
 
-Rcpp::List callSC_GBLUP(arma::mat y, arma::uvec x, arma::vec reps,
-                        std::string genoFemale, int nFemale, 
-                        arma::uvec fPar, std::string genoMale, 
-                        int nMale, arma::uvec mPar, int nMarker){
+// Called by RRBLUP_GCA function
+// [[Rcpp::export]]
+Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps,
+                          std::string genoFemale, std::string genoMale, 
+                          int nMarker){
+  int n = y.n_rows;
+  arma::mat X = makeX(x);
+  arma::field<arma::mat> Zlist(2);
+  Zlist(0) = readMat(genoFemale,n,nMarker,' ',0,0);
+  Zlist(1) = readMat(genoMale,n,nMarker,' ',0,0);
+  arma::field<arma::mat> Klist(2);
+  Klist(0) = arma::eye(nMarker,nMarker);
+  Klist(1) = arma::eye(nMarker,nMarker);
+  reps = sqrt(1.0/reps);
+  sweepReps(y, reps);
+  sweepReps(X, reps);
+  sweepReps(Zlist(0), reps);
+  sweepReps(Zlist(1), reps);
+  return solveMKM(y,X,Zlist,Klist);
+}
+
+// Called by RRBLUP_SCA function
+// [[Rcpp::export]]
+Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps,
+                          std::string genoFemale, std::string genoMale, 
+                          int nMarker){
   int n = y.n_rows;
   arma::mat X = makeX(x);
   arma::field<arma::mat> Zlist(3);
-  Zlist(0) = makeZ(fPar, nFemale);
-  Zlist(1) = makeZ(mPar, nMale);
-  Zlist(2) = arma::eye(n,n);
+  Zlist(0) = readMat(genoFemale,n,nMarker,' ',0,0);
+  Zlist(0) = Zlist(0)*2-1;
+  Zlist(1) = readMat(genoMale,n,nMarker,' ',0,0);
+  Zlist(1) = Zlist(1)*2-1;
+  Zlist(2) = Zlist(0)%Zlist(1);
   arma::field<arma::mat> Klist(3);
-  Klist(0) = makeG(genoFemale,nFemale,nMarker);
-  Klist(1) = makeG(genoMale,nMale,nMarker);
-  // K3 = Z1*K1*Z1' % Z2*K2*Z2'
-  Klist(2) = (Zlist(0)*Klist(0)*Zlist(0).t())%
-  (Zlist(1)*Klist(1)*Zlist(1).t());
+  Klist(0) = arma::eye(nMarker,nMarker);
+  Klist(1) = arma::eye(nMarker,nMarker);
+  Klist(2) = arma::eye(nMarker,nMarker);
   reps = sqrt(1.0/reps);
   sweepReps(y, reps);
   sweepReps(X, reps);

---FILE: src/RcppExports.cpp---
@@ -16,6 +16,160 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// gebvRR
+arma::mat gebvRR(const Rcpp::S4& RRsol, const Rcpp::S4& pop);
+RcppExport SEXP AlphaSimR_gebvRR(SEXP RRsolSEXP, SEXP popSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type RRsol(RRsolSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
+    rcpp_result_gen = Rcpp::wrap(gebvRR(RRsol, pop));
+    return rcpp_result_gen;
+END_RCPP
+}
+// gebvGCA
+arma::mat gebvGCA(const Rcpp::S4& GCAsol, const Rcpp::S4& pop, bool female);
+RcppExport SEXP AlphaSimR_gebvGCA(SEXP GCAsolSEXP, SEXP popSEXP, SEXP femaleSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type GCAsol(GCAsolSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
+    Rcpp::traits::input_parameter< bool >::type female(femaleSEXP);
+    rcpp_result_gen = Rcpp::wrap(gebvGCA(GCAsol, pop, female));
+    return rcpp_result_gen;
+END_RCPP
+}
+// gebvSCA
+arma::mat gebvSCA(const Rcpp::S4& SCAsol, const Rcpp::S4& pop);
+RcppExport SEXP AlphaSimR_gebvSCA(SEXP SCAsolSEXP, SEXP popSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type SCAsol(SCAsolSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::S4& >::type pop(popSEXP);
+    rcpp_result_gen = Rcpp::wrap(gebvSCA(SCAsol, pop));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveUVM
+Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
+RcppExport SEXP AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMVM
+Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol);
+RcppExport SEXP AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
+    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
+    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol));
+    return rcpp_result_gen;
+END_RCPP
+}
+// objWeights
+Rcpp::NumericVector objWeights(Rcpp::NumericVector x, SEXP ptrData);
+RcppExport SEXP AlphaSimR_objWeights(SEXP xSEXP, SEXP ptrDataSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type x(xSEXP);
+    Rcpp::traits::input_parameter< SEXP >::type ptrData(ptrDataSEXP);
+    rcpp_result_gen = Rcpp::wrap(objWeights(x, ptrData));
+    return rcpp_result_gen;
+END_RCPP
+}
+// solveMKM
+Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist);
+RcppExport SEXP AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
+    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
+    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP
+Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_MV
+Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_GCA
+Rcpp::List callRRBLUP_GCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_GCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_GCA(y, x, reps, genoFemale, genoMale, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
+// callRRBLUP_SCA
+Rcpp::List callRRBLUP_SCA(arma::mat y, arma::uvec x, arma::vec reps, std::string genoFemale, std::string genoMale, int nMarker);
+RcppExport SEXP AlphaSimR_callRRBLUP_SCA(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoFemaleSEXP, SEXP genoMaleSEXP, SEXP nMarkerSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
+    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoFemale(genoFemaleSEXP);
+    Rcpp::traits::input_parameter< std::string >::type genoMale(genoMaleSEXP);
+    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
+    rcpp_result_gen = Rcpp::wrap(callRRBLUP_SCA(y, x, reps, genoFemale, genoMale, nMarker));
+    return rcpp_result_gen;
+END_RCPP
+}
 // getGeno
 arma::Mat<unsigned char> getGeno(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc);
 RcppExport SEXP AlphaSimR_getGeno(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP) {
@@ -53,6 +207,20 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// getOneHaplo
+arma::Mat<unsigned char> getOneHaplo(const arma::field<arma::Cube<unsigned char> >& geno, const arma::ivec& lociPerChr, arma::uvec lociLoc, int haplo);
+RcppExport SEXP AlphaSimR_getOneHaplo(SEXP genoSEXP, SEXP lociPerChrSEXP, SEXP lociLocSEXP, SEXP haploSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const arma::field<arma::Cube<unsigned char> >& >::type geno(genoSEXP);
+    Rcpp::traits::input_parameter< const arma::ivec& >::type lociPerChr(lociPerChrSEXP);
+    Rcpp::traits::input_parameter< arma::uvec >::type lociLoc(lociLocSEXP);
+    Rcpp::traits::input_parameter< int >::type haplo(haploSEXP);
+    rcpp_result_gen = Rcpp::wrap(getOneHaplo(geno, lociPerChr, lociLoc, haplo));
+    return rcpp_result_gen;
+END_RCPP
+}
 // getGvA
 arma::vec getGvA(const Rcpp::S4& trait, const Rcpp::S4& pop);
 RcppExport SEXP AlphaSimR_getGvA(SEXP traitSEXP, SEXP popSEXP) {
@@ -251,120 +419,6 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// solveUVM
-Rcpp::List solveUVM(const arma::mat& y, const arma::mat& X, const arma::mat& Z, const arma::mat& K);
-RcppExport SEXP AlphaSimR_solveUVM(SEXP ySEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveUVM(y, X, Z, K));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMVM
-Rcpp::List solveMVM(const arma::mat& Y, const arma::mat& X, const arma::mat& Z, const arma::mat& K, double tol);
-RcppExport SEXP AlphaSimR_solveMVM(SEXP YSEXP, SEXP XSEXP, SEXP ZSEXP, SEXP KSEXP, SEXP tolSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const arma::mat& >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type Z(ZSEXP);
-    Rcpp::traits::input_parameter< const arma::mat& >::type K(KSEXP);
-    Rcpp::traits::input_parameter< double >::type tol(tolSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMVM(Y, X, Z, K, tol));
-    return rcpp_result_gen;
-END_RCPP
-}
-// objWeights
-Rcpp::NumericVector objWeights(Rcpp::NumericVector x, SEXP ptrData);
-RcppExport SEXP AlphaSimR_objWeights(SEXP xSEXP, SEXP ptrDataSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type x(xSEXP);
-    Rcpp::traits::input_parameter< SEXP >::type ptrData(ptrDataSEXP);
-    rcpp_result_gen = Rcpp::wrap(objWeights(x, ptrData));
-    return rcpp_result_gen;
-END_RCPP
-}
-// solveMKM
-Rcpp::List solveMKM(arma::mat& y, arma::mat& X, arma::field<arma::mat>& Zlist, arma::field<arma::mat>& Klist);
-RcppExport SEXP AlphaSimR_solveMKM(SEXP ySEXP, SEXP XSEXP, SEXP ZlistSEXP, SEXP KlistSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat& >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::mat& >::type X(XSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Zlist(ZlistSEXP);
-    Rcpp::traits::input_parameter< arma::field<arma::mat>& >::type Klist(KlistSEXP);
-    rcpp_result_gen = Rcpp::wrap(solveMKM(y, X, Zlist, Klist));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callGK
-Rcpp::List callGK(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker, double maxTheta, int maxIter, bool writeForPred);
-RcppExport SEXP AlphaSimR_callGK(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP, SEXP maxThetaSEXP, SEXP maxIterSEXP, SEXP writeForPredSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    Rcpp::traits::input_parameter< double >::type maxTheta(maxThetaSEXP);
-    Rcpp::traits::input_parameter< int >::type maxIter(maxIterSEXP);
-    Rcpp::traits::input_parameter< bool >::type writeForPred(writeForPredSEXP);
-    rcpp_result_gen = Rcpp::wrap(callGK(y, x, reps, genoTrain, nMarker, maxTheta, maxIter, writeForPred));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callPredGK
-arma::mat callPredGK(const Rcpp::DataFrame& genoPred);
-RcppExport SEXP AlphaSimR_callPredGK(SEXP genoPredSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< const Rcpp::DataFrame& >::type genoPred(genoPredSEXP);
-    rcpp_result_gen = Rcpp::wrap(callPredGK(genoPred));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP
-Rcpp::List callRRBLUP(arma::mat y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP(SEXP ySEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type y(ySEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP(y, x, reps, genoTrain, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
-// callRRBLUP_MV
-Rcpp::List callRRBLUP_MV(arma::mat Y, arma::uvec x, arma::vec reps, std::string genoTrain, int nMarker);
-RcppExport SEXP AlphaSimR_callRRBLUP_MV(SEXP YSEXP, SEXP xSEXP, SEXP repsSEXP, SEXP genoTrainSEXP, SEXP nMarkerSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< arma::mat >::type Y(YSEXP);
-    Rcpp::traits::input_parameter< arma::uvec >::type x(xSEXP);
-    Rcpp::traits::input_parameter< arma::vec >::type reps(repsSEXP);
-    Rcpp::traits::input_parameter< std::string >::type genoTrain(genoTrainSEXP);
-    Rcpp::traits::input_parameter< int >::type nMarker(nMarkerSEXP);
-    rcpp_result_gen = Rcpp::wrap(callRRBLUP_MV(Y, x, reps, genoTrain, nMarker));
-    return rcpp_result_gen;
-END_RCPP
-}
 // readAF
 arma::Cube<unsigned char> readAF(int nInd, int segSites, int ploidy, arma::uvec keep, bool inbred);
 RcppExport SEXP AlphaSimR_readAF(SEXP nIndSEXP, SEXP segSitesSEXP, SEXP ploidySEXP, SEXP keepSEXP, SEXP inbredSEXP) {

---FILE: src/getGeno.cpp---
@@ -15,7 +15,7 @@ arma::Mat<unsigned char> getGeno(const arma::field<arma::Cube<unsigned char> >&
   
   int nInd = geno(0).n_slices;
   int nChr = geno.n_elem;
-  arma::Mat<unsigned char> output(nInd,arma::sum(lociPerChr), arma::fill::zeros);
+  arma::Mat<unsigned char> output(nInd,arma::sum(lociPerChr));
   int loc1;
   int loc2 = -1;
   for(int i=0; i<nChr; ++i){
@@ -54,11 +54,9 @@ arma::Mat<unsigned char> getHaplo(const arma::field<arma::Cube<unsigned char> >&
   int nInd = geno(0).n_slices;
   int nChr = geno.n_elem;
   int ploidy = geno(0).n_cols;
-  int nLoci = geno(0).n_rows;
-  arma::Mat<unsigned char> output(nInd*ploidy,arma::sum(lociPerChr), arma::fill::zeros);
+  arma::Mat<unsigned char> output(nInd*ploidy,arma::sum(lociPerChr));
   int loc1;
   int loc2 = -1;
-  arma::Mat<unsigned char> tmp(nLoci,ploidy);
   // Get chromosome data
   for(int i=0; i<nChr; ++i){
     // Get loci locations
@@ -73,4 +71,36 @@ arma::Mat<unsigned char> getHaplo(const arma::field<arma::Cube<unsigned char> >&
     }
   }
   return output;
+}
+
+// Returns haplotype data in a matrix of nInd by nLoci for a single
+// chromosome group. i.e. just female or male chromosomes for diploids
+// [[Rcpp::export]]
+arma::Mat<unsigned char> getOneHaplo(const arma::field<arma::Cube<unsigned char> >& geno, 
+                                     const arma::ivec& lociPerChr,
+                                     arma::uvec lociLoc, int haplo){
+  // R to C++ index correction
+  lociLoc -= 1;
+  haplo -= 1;
+  
+  int nInd = geno(0).n_slices;
+  int nChr = geno.n_elem;
+  arma::Mat<unsigned char> output(nInd,arma::sum(lociPerChr));
+  int loc1;
+  int loc2 = -1;
+  arma::uvec colSel(1);
+  colSel(0) = haplo;
+  // Get chromosome data
+  for(int i=0; i<nChr; ++i){
+    // Get loci locations
+    loc1 = loc2+1;
+    loc2 += lociPerChr[i];
+    arma::uvec chrLociLoc = lociLoc(arma::span(loc1,loc2));
+    // Get individual data
+    for(int ind=0; ind<nInd; ++ind){
+      output(ind,arma::span(loc1,loc2)) = 
+        (geno(i).slice(ind).submat(chrLociLoc,colSel)).t();
+    }
+  }
+  return output;
 }
\ No newline at end of file

---FILE: src/getGeno.h---
@@ -7,4 +7,8 @@ arma::Mat<unsigned char> getGeno(const arma::field<arma::Cube<unsigned char> >&
 
 arma::imat getDomGeno(const arma::Mat<unsigned char>& geno);
 
+arma::Mat<unsigned char> getOneHaplo(const arma::field<arma::Cube<unsigned char> >& geno, 
+                                     const arma::ivec& lociPerChr,
+                                     arma::uvec lociLoc, int haplo);
+
 #endif
\ No newline at end of file"
gaynorr,AlphaSimR,fbfaccf61d0f5f25c78f8f5243b87a044600dfff,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-04-25T10:52:46Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-04-25T10:52:46Z,Fixed bug in makeCross2,DESCRIPTION;R/crossing.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,7 +1,7 @@
 Package: AlphaSimR
 Type: Package
 Title: Breeding Program Simulations
-Version: 0.1.1
+Version: 0.1.2
 Author: Chris Gaynor
 Maintainer: Chris Gaynor <gaynor.robert@hotmail.com>
 Description: This package contains classes and functions for simulating plant and animal breeding programs.

---FILE: R/crossing.R---
@@ -195,7 +195,7 @@ makeCross2 = function(fPop,mPop,crossPlan,id=NULL,simParam=SIMPARAM){
 randCross2 = function(fPop,mPop,nCrosses,nProgeny=1,
                      id=NULL,simParam=SIMPARAM){
   if(simParam@gender==""no""){
-    crossPland = expand.grid(1:fPop@nInd,1:mPop@nInd)
+    crossPlan = expand.grid(1:fPop@nInd,1:mPop@nInd)
   }else{
     female = which(fPop@gender==""F"")
     if(length(female)==0){"
gaynorr,AlphaSimR,e5301f665bafe5daa8b50924652d8bda4812129f,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-04-05T12:23:03Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-04-05T12:23:03Z,windows fix part 2,R/runMacs.R,False,True,True,False,7,7,14,"---FILE: R/runMacs.R---
@@ -27,7 +27,7 @@ runMacs = function(macs,nInd,nChr,segSites,inbred=TRUE,species=""TEST"",
     popSize = ploidy*nInd
   }
   if(!is.null(manualCommand)){
-    command = paste0(macs,"" "",popSize,"" "",manualCommand,"" -s "",sample.int(1e8,1),"" 1>output.txt 2>/dev/null"")
+    command = paste0(macs,"" "",popSize,"" "",manualCommand,"" -s "",sample.int(1e8,1))
   }else{
     species = toupper(species)
     if(species==""WHEAT""){ #WHEAT----
@@ -81,12 +81,12 @@ runMacs = function(macs,nInd,nChr,segSites,inbred=TRUE,species=""TEST"",
       splitI = paste("" -I 2"",popSize%/%2,popSize%/%2)
       splitJ = paste("" -ej"",split/(4*Ne)+0.000001,""2 1"")
     }
-    if(.Platform$OS.type==""windows""){
-      directOutput = "" 1>output.txt 2>NUL""
-    }else{
-      directOutput = "" 1>output.txt 2>/dev/null""
-    }
-    command = paste0(macs,"" "",popSize,"" "",speciesParams,splitI,"" "",speciesHist,splitJ,"" -s "",sample.int(1e8,1),directOutput)
+    command = paste0(macs,"" "",popSize,"" "",speciesParams,splitI,"" "",speciesHist,splitJ,"" -s "",sample.int(1e8,1))
+  }
+  if(.Platform$OS.type==""windows""){
+    command = paste0(""powershell \""("",command,"") 1>output.txt 2>$null\"""")
+  }else{
+    command = paste(command,""1>output.txt 2>/dev/null"")
   }
   currentDir = getwd()
   tmpDir = tempdir()"
gaynorr,AlphaSimR,d4d89128fc0bca935a0ce009595adb23329b731e,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-04-04T21:39:29Z,GAYNOR Chris,chris.gaynor@roslin.ed.ac.uk,2017-04-04T21:39:29Z,Fix for windows,R/runMacs.R,False,True,True,False,6,1,7,"---FILE: R/runMacs.R---
@@ -81,7 +81,12 @@ runMacs = function(macs,nInd,nChr,segSites,inbred=TRUE,species=""TEST"",
       splitI = paste("" -I 2"",popSize%/%2,popSize%/%2)
       splitJ = paste("" -ej"",split/(4*Ne)+0.000001,""2 1"")
     }
-    command = paste0(macs,"" "",popSize,"" "",speciesParams,splitI,"" "",speciesHist,splitJ,"" -s "",sample.int(1e8,1),"" 1>output.txt 2>/dev/null"")
+    if(.Platform$OS.type==""windows""){
+      directOutput = "" 1>output.txt 2>NUL""
+    }else{
+      directOutput = "" 1>output.txt 2>/dev/null""
+    }
+    command = paste0(macs,"" "",popSize,"" "",speciesParams,splitI,"" "",speciesHist,splitJ,"" -s "",sample.int(1e8,1),directOutput)
   }
   currentDir = getwd()
   tmpDir = tempdir()"
