repo_owner,repo_name,commit_hash,author_name,author_email,author_date,committer_name,committer_email,committer_date,message,filenames,touches_rmd,touches_r,touches_r_or_rmd,is_merge,added,deleted,changed,diff
ecmerkle,blavaan,0df491092592f0c79d72314d6690a857bfbd909a,ecmerkle,merklee@missouri.edu,2025-09-11T20:15:48Z,ecmerkle,merklee@missouri.edu,2025-09-11T20:15:48Z,avoid floating point problem with parameters fixed to 0,DESCRIPTION;R/blav_adapt_quad.R;R/lav_export_stanmarg.R,False,True,True,False,10,4,14,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-8.1359
+Version: 0.5-8.1360
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_adapt_quad.R---
@@ -2,6 +2,12 @@
 adapted_ghq <- function(fit, ngq, samprow = NULL) {
   samps <- do.call(""rbind"", make_mcmc(fit@external$mcmcout, fit@external$stanlvs))
 
+  if (is.null(samprow)) {
+    ## compute ll at posterior mean
+    samps[1,] <- colMeans(samps)
+    samprow <- 1
+  }
+  
   lavmodel <- fill_params(samps[samprow, , drop = FALSE], fit@Model, fit@ParTable)
   GLIST <- lavmodel@GLIST
   if (any(GLIST$theta[lower.tri(GLIST$theta)] != 0L)) stop(""blavaan ERROR: The quadrature method cannot be used with non-diagonal theta matrix."")

---FILE: R/lav_export_stanmarg.R---
@@ -15,9 +15,9 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, wig, ...) {
 
   ## for corrmats, only use lower triangle
   if (grepl(""_r"", mat)) {
-    matskel[upper.tri(matskel)] <- 0
     for (i in 1:Ng) {
-      free[[i]][upper.tri(free[[i]])] <- 0
+      matskel[i,,][upper.tri(matskel[i,,])] <- 0L      
+      free[[i]][upper.tri(free[[i]])] <- 0L
 
       ## fixed covs that need to be cors
       fcov <- which(est[[i]] != 0 & free[[i]] == 0, arr.ind = TRUE)
@@ -34,7 +34,7 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, wig, ...) {
   start <- 1L
   free2 <- free
   for (i in 1:Ng) {
-    tmpmat <- est[[i]]
+    tmpmat <- round(est[[i]], 10)
     tmpmat[free[[i]] != 0L] <- Inf
     matskel[i, , ] <- tmpmat
     "
ecmerkle,blavaan,6f3b2b0a2ff418f757177aa131925f28954f19d4,ecmerkle,merklee@missouri.edu,2025-09-02T19:47:01Z,ecmerkle,merklee@missouri.edu,2025-09-02T19:47:01Z,further fix for 1d quadrature,DESCRIPTION;R/blav_adapt_quad.R,False,True,True,False,6,2,8,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-8.1358
+Version: 0.5-8.1359
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_adapt_quad.R---
@@ -30,7 +30,11 @@ adapted_ghq <- function(fit, ngq, samprow = NULL) {
                       casewise = TRUE, conditional = TRUE)
   }
 
-  out <- exp(out) * do.call(""rbind"", w.star.list)
+  if (nrow(etamncov[[2]][[1]]) == 1) {
+    out <- exp(out) * t(do.call(""cbind"", w.star.list))
+  } else {
+    out <- exp(out) * do.call(""rbind"", w.star.list)
+  }
   
   return( log( rowSums(out) ) )
 }"
ecmerkle,blavaan,b5526ef260c05316006b41185c87e324b9be023c,ecmerkle,merklee@missouri.edu,2025-03-10T21:11:54Z,ecmerkle,merklee@missouri.edu,2025-03-10T21:11:54Z,fix equality constraints involving correlation matrices,R/lav_export_stanmarg.R,False,True,True,False,15,4,19,"---FILE: R/lav_export_stanmarg.R---
@@ -413,11 +413,11 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
     dat <- c(dat, blkres$out)
     frnoblock <- blkres$frnoblock
     blktheta <- blkres$blkmats
-    
+
     frnums <- sapply(frnoblock, function(x) as.numeric(x[x != 0]))
     twsel <- lavpartable$free %in% frnums
     tmpwig <- lavpartable[twsel,'free'][which(lavpartable[twsel, 'plabel'] %in% wig)]
-    
+
     res <- matattr(frnoblock, es, constrain, mat = ""Theta_r"", Ng, opts$std.lv, tmpwig, dest = dest)
 
     dat$Theta_r_skeleton <- res$matskel
@@ -1348,7 +1348,18 @@ lav2standata <- function(lavobject, dosam = FALSE) {
 block_cov <- function(freemats, fr, mat, skel, Ng, dosam = FALSE) {
   out <- list()
 
-  blkinfo <- lapply(freemats, function(x) blkdiag(x[[mat]], attributes(x)$header))
+  cons <- attributes(freemats)$header
+  freemats <- lapply(freemats, function(x) {
+    outmat <- x[[mat]]
+    #outmat[outmat %in% cons$rhs] <- 0
+    outmat
+  })
+  fr <- lapply(fr, function(x) {
+    x[x %in% cons$rhs] <- 0
+    x
+  })
+  
+  blkinfo <- lapply(freemats, function(x) blkdiag(x, cons))
   blkmats <- all(sapply(blkinfo, function(x) x$isblk))
   blkse <- do.call(""rbind"", lapply(blkinfo, function(x) x$blkse))
   matorder <- do.call(""rbind"", lapply(blkinfo, function(x) x$neworder))
@@ -1378,7 +1389,7 @@ block_cov <- function(freemats, fr, mat, skel, Ng, dosam = FALSE) {
     if (dosam) {
       blkgrp <- rep(1:length(blkinfo), times = sapply(blkinfo, function(x) nrow(x$blkse)))
     } else {
-      blkgrp <- rep(1:length(blkinfo), times = sapply(blkinfo, function(x) sum(x$blkse[,2] - x$blkse[,1] > 0)))
+      blkgrp <- rep(1:length(blkinfo), times = sapply(blkinfo, function(x) sum((x$blkse[,2] - x$blkse[,1] > 0) & x$blkse[,3] == 1)))
     }
     arrayidx <- as.numeric(as.factor(blksizes))
     dupsiz <- duplicated(blksizes)"
ecmerkle,blavaan,415a116fd78c08b70fe889c1a2f777b8fd416496,ecmerkle,merklee@missouri.edu,2025-03-10T17:43:40Z,ecmerkle,merklee@missouri.edu,2025-03-10T17:43:40Z,fix some matrix dimensions,R/lav_export_stanmarg.R;inst/stan/stanmarg.stan,False,True,True,False,2,2,4,"---FILE: R/lav_export_stanmarg.R---
@@ -1378,7 +1378,7 @@ block_cov <- function(freemats, fr, mat, skel, Ng, dosam = FALSE) {
     if (dosam) {
       blkgrp <- rep(1:length(blkinfo), times = sapply(blkinfo, function(x) nrow(x$blkse)))
     } else {
-      blkgrp <- rep(1:length(blkinfo), times = sapply(blkinfo, function(x) sum(x$blkse[,2] - x$blkse[,1] > 1)))
+      blkgrp <- rep(1:length(blkinfo), times = sapply(blkinfo, function(x) sum(x$blkse[,2] - x$blkse[,1] > 0)))
     }
     arrayidx <- as.numeric(as.factor(blksizes))
     dupsiz <- duplicated(blksizes)

---FILE: inst/stan/stanmarg.stan---
@@ -1950,7 +1950,7 @@ generated quantities { // these matrices are saved in the output but do not figu
   }
   
   // off-diagonal covariance parameter vectors, from cor/sd matrices:
-  if (p > 0  && len_free[7] > 0) {
+  if (p > 0  && len_free[8] > 0) {
     /* iden is created so that we can re-use cor2cov, even though
        we don't need to multiply to get covariances */
     array[Ng] matrix[p, p] iden;"
ecmerkle,blavaan,599161cc2608f9fb49a4458c7e78ecc4c4c4c335,ecmerkle,merklee@missouri.edu,2025-03-10T16:02:29Z,ecmerkle,merklee@missouri.edu,2025-03-10T16:02:29Z,fix inits and etc for blocks of theta,R/blav_model_loglik.R;R/blavaan.R;R/lav_export_stanmarg.R;R/postpred.R;inst/stan/stanmarg.stan,False,True,True,False,18,20,38,"---FILE: R/blav_model_loglik.R---
@@ -512,15 +512,15 @@ samp_lls <- function(lavjags        = NULL,
   nchain <- length(lavmcmc)
 
   if(lavoptions$target != ""stan"" | conditional | lavInspect(lavobject, ""categorical"") | !lavInspect(lavobject, ""meanstructure"")) {
-    loop.args <- list(X = 1:nsamps, future.seed = TRUE, FUN = function(i){
+    loop.args <- list(X = 1:nsamps, FUN = function(i){
       tmpmat <- matrix(NA, nchain, 2)
       for(j in 1:nchain){
         tmpmat[j,1:2] <- get_ll(lavmcmc[[j]][itnums[i],],
                                 lavobject, conditional = conditional, standata = standata)
       }
-      tmpmat})
+      tmpmat})#, future.seed = TRUE)
 
-    llmat <- do.call(""future_lapply"", loop.args)
+    llmat <- do.call(""lapply"", loop.args)#""future_lapply"", loop.args)
     llmat <- array(unlist(llmat), c(nchain, 2, nsamps)) ## logl + baseline logl
     llmat <- aperm(llmat, c(3,1,2))
   } else {

---FILE: R/blavaan.R---
@@ -651,7 +651,7 @@ blavaan <- function(...,  # default lavaan arguments
                 if(""data"" %in% names(mcmcextra) & ""moment_match_k_threshold"" %in% names(mcmcextra$data)){
                     ## FIXME these do not cover level 2 parameters
                     moment_match_monitors <- c(""Lambda_y_free"", ""B_free"", 
-                        ""Theta_sd_free"", ""Theta_r_free"", ""Psi_sd_free"", 
+                        ""Theta_sd_free"", paste0(""Theta_r_mat_"", 1:5), ""Theta_r_free"", ""Psi_sd_free"", 
                         paste0(""Psi_r_mat_"", 1:5), ""Psi_r_free"", ""Nu_free"", ""Alpha_free"")
                     moment_match_monitors <- c(moment_match_monitors,
                                                paste0(moment_match_monitors, ""_c""))
@@ -1047,7 +1047,7 @@ blavaan <- function(...,  # default lavaan arguments
     if(target == ""stan"") {
       if(covres$dobf) {
         domll <- TRUE
-      } else if((covres$diagthet | covres$fullthet) & l2s$blkpsi) {
+      } else if(l2s$blktheta & l2s$blkpsi) {
         domll <- TRUE
       } else {
         domll <- FALSE

---FILE: R/lav_export_stanmarg.R---
@@ -412,7 +412,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
     blkres <- block_cov(freemats, fr, mat = ""theta"", skel = tmpatt$matskel, Ng = dat$Ng, dosam = dosam)
     dat <- c(dat, blkres$out)
     frnoblock <- blkres$frnoblock
-    blkthet <- blkres$blkmats
+    blktheta <- blkres$blkmats
     
     frnums <- sapply(frnoblock, function(x) as.numeric(x[x != 0]))
     twsel <- lavpartable$free %in% frnums
@@ -442,7 +442,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
     dat$Theta_r_skeleton_f <- res$matskel
     dat$w8skel <- res$wskel
   } else {
-    blkthet <- TRUE
+    blktheta <- TRUE
     dat$Theta_r_skeleton <- array(0, dim = c(Ng, 0, 0))
     dat$w7skel <- matrix(0, 0, 3)
     dat$Theta_r_skeleton_f <- array(0, dim = c(Ng, 0, 0))
@@ -828,7 +828,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
   }
   
   return(list(dat = dat, free2 = free2, lavpartable = lavpartable,
-              init = ini, dumlv = dumlv, wigpris = wigpris, blkpsi = blkpsi))
+              init = ini, dumlv = dumlv, wigpris = wigpris, blkpsi = blkpsi, blktheta = blktheta))
 }
 
 
@@ -858,8 +858,7 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, dmnames
   ## lavaan pars to stan par vectors
   mapping <- c(ly_sign = ""lambda"", g_sign = ""gamma"",
                bet_sign = ""beta"", Theta_cov = ""theta"",
-               Theta_var = ""theta"", Theta_x_cov = ""cov.x"",
-               Theta_x_var = ""cov.x"", Psi_cov = ""psi"",
+               Theta_var = ""theta"", Psi_cov = ""psi"",
                Psi_var = ""psi"", Nu_free = ""nu"", ## includes mean.x!
                al_sign = ""alpha"", Tau_free = ""tau"")
   matmod <- """"
@@ -875,16 +874,15 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, dmnames
 
   ## lavaan pars to w?skel (for equality constraints)
   mapping2 <- c(""lambda"", ""gamma"", ""beta"", ""theta"",
-                ""theta"", ""cov.x"", ""cov.x"", ""psi"",
+                ""theta"", ""psi"",
                 ""psi"", ""nu"", ""alpha"", ""tau"")
-  names(mapping2) <- as.character(c(1, 3, 4, 7, 5, 8, 6, 11, 9,
+  names(mapping2) <- as.character(c(1, 3, 4, 8, 5, 11, 9,
                                     13, 14, 15))
 
   ## stan pars to free2 pars
   mapping3 <- c(lambda = ""ly_sign"", gamma = ""g_sign"",
                 beta = ""bet_sign"", rtheta = ""Theta_cov"",
-                dtheta = ""Theta_var"", rtheta_x = ""Theta_x_cov"",
-                dtheta_x = ""Theta_x_var"", rpsi = ""Psi_cov"",
+                dtheta = ""Theta_var"", rpsi = ""Psi_cov"",
                 dpsi = ""Psi_var"", nu = ""Nu_free"",
                 alpha = ""al_sign"", tau = ""Tau_free"")
   if (level == 2L) {

---FILE: R/postpred.R---
@@ -113,7 +113,7 @@ postpred <- function(samplls = NULL, lavobject = NULL, measure = ""logl"", thin =
           fit@external$eta <- eta
           fit@external$implied <- implied
         }
-        
+
         ## Apply custom ""discFUN"" to observed data
         chisq.obs <- vector(""list"", length(discFUN))
         for (d in seq_along(discFUN)) {
@@ -280,9 +280,9 @@ postpred <- function(samplls = NULL, lavobject = NULL, measure = ""logl"", thin =
 
     result <- list(ind = ind, csdist = csdist, csboots = csboots)
     result
-  }, future.seed = TRUE)
+  })#, future.seed = TRUE)
 
-  res <- do.call(""future_lapply"", loop.args)
+  res <- do.call(""lapply"", loop.args)#do.call(""future_lapply"", loop.args)
   
   ## extract PPP and posterior (realized & predictive) distributions
   if (length(discFUN)) {

---FILE: inst/stan/stanmarg.stan---
@@ -1840,7 +1840,7 @@ generated quantities { // these matrices are saved in the output but do not figu
   array[Ng] matrix[p, p] Thet;
   array[Ng] matrix[m, m] PSmat;
   array[Ng] matrix[m, m] PS;
-  vector[len_free[7]] Theta_cov;
+  vector[len_free[8]] Theta_cov;
   vector[len_free[5]] Theta_var;
   vector[len_free[10]] P_r;
   vector[len_free[11]] Psi_cov;
@@ -1854,7 +1854,7 @@ generated quantities { // these matrices are saved in the output but do not figu
   array[Ng] matrix[p_c, p_c] Thet_c;
   array[Ng] matrix[m_c, m_c] PSmat_c;
   array[Ng] matrix[m_c, m_c] PS_c;
-  vector[len_free_c[7]] Theta_cov_c;
+  vector[len_free_c[8]] Theta_cov_c;
   vector[len_free_c[5]] Theta_var_c;
   vector[len_free_c[10]] P_r_c;
   vector[len_free_c[11]] Psi_cov_c;
@@ -1957,7 +1957,7 @@ generated quantities { // these matrices are saved in the output but do not figu
     for (g in 1:Ng) {
       iden[g] = diag_matrix(rep_vector(1, p));
     }
-    Theta_cov = cor2cov(Thet, iden, len_free[7], Theta_r_skeleton, w7skel, Ng);
+    Theta_cov = cor2cov(Thet, iden, len_free[8], Theta_r_skeleton_f, w8skel, Ng);
   }
   Theta_var = Theta_sd_free .* Theta_sd_free;
 "
ecmerkle,blavaan,b9fcd4b41994b0b5447f7575a457e86feafc799e,ecmerkle,ecmerkle@gmail.com,2025-03-07T19:30:35Z,ecmerkle,ecmerkle@gmail.com,2025-03-07T19:30:35Z,fix ordinal models with one missingness pattern,DESCRIPTION;NEWS.md;R/lav_export_stanmarg.R,False,True,True,False,7,4,11,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-8.1340
+Version: 0.5-8.1341
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: NEWS.md---
@@ -1,10 +1,12 @@
-# Version 0.5-7
+# Version 0.5-8
 ## New features
 * This release contains minor improvements and bug fixes.
 
 ## Bugs/glitches:
 * Models with the <~ operator fail under target = ""jags"" (reported by Thomas Riecke).
 
+* Ordinal models with missing data and only one missing data pattern fail (reported by Curtis Atkisson).
+
 # Version 0.5-6
 ## New features
 * This release contains minor improvements and bug fixes.

---FILE: R/lav_export_stanmarg.R---
@@ -1377,14 +1377,15 @@ lav2standata <- function(lavobject, dosam = FALSE) {
     dat$cov_b <- array(0, c(Ng, 0, 0))
     dat$gs <- array(1, Ng)
   } # multilevel
-  
+
   if (ord) {
     pta <- lav_partable_attributes(parTable(lavobject))
     ordidx <- pta$vidx$ov.ord[[1]]
     dat$YXo <- dat$YX[, ordidx, drop=FALSE]
     if (misflag) {
       dat$Noent <- sum(dat$YXo > 0)
-      dat$Nordobs <- do.call(""c"", lapply(Mp, function(x) rowSums(x$pat[, ordidx, drop = FALSE])))
+      Nordobs <- do.call(""c"", lapply(Mp, function(x) rowSums(x$pat[, ordidx, drop = FALSE])))
+      dat$Nordobs <- array(Nordobs, length(Nordobs))
       OrdObsvar <- do.call(""c"", lapply(Mp, function(x) apply(x$pat[, ordidx, drop = FALSE], 1, which, simplify = FALSE)))
 
       dat$OrdObsvar <- matrix(0, dat$Np, ncol(dat$YXo))"
ecmerkle,blavaan,a8b36df24b5e85ca8b628b13b12f52b872e774c5,ecmerkle,merklee@missouri.edu,2025-02-12T18:14:48Z,ecmerkle,merklee@missouri.edu,2025-02-12T18:14:48Z,fix bsem() and bcfa() default of int.lv.free=FALSE,DESCRIPTION;R/blavaan.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-8.1337
+Version: 0.5-8.1338
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blavaan.R---
@@ -1205,7 +1205,7 @@ bcfa <- bsem <- function(..., cp = ""srs"", dp = NULL,
     if(length(mc$model.type) == 3L) mc$model.type <- mc$model.type[3L]
     mc$model.type <- gsub(""^b"", """", mc$model.type)
     mc$n.chains <- n.chains
-    defparms <- c(int.ov.free = TRUE, int.lv.free = TRUE, auto.fix.first = !std.lv,
+    defparms <- c(int.ov.free = TRUE, int.lv.free = FALSE, auto.fix.first = !std.lv,
                   auto.fix.single = TRUE, auto.var = TRUE, auto.cov.lv.x = TRUE,
                   auto.cov.y = TRUE, auto.th = TRUE, auto.delta = TRUE)
     mc[names(defparms)[!(names(defparms) %in% names(mc))]] <- defparms[!(names(defparms) %in% names(mc))]"
ecmerkle,blavaan,19176f5fd0179036cca11578e2cc211344f12238,ecmerkle,merklee@missouri.edu,2025-01-15T16:09:39Z,ecmerkle,merklee@missouri.edu,2025-01-15T16:09:39Z,fix issue with length 1 array,DESCRIPTION;R/stanmarg_data.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-8.1335
+Version: 0.5-8.1336
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/stanmarg_data.R---
@@ -151,7 +151,7 @@ format_priors <- function(lavpartable, level = 1L) {
           param2 <- param2[!is.na(param2)]
         }
       } else if (blkmats) {
-        priblks <- priblks[thepris != """"]
+        priblks <- array(priblks[thepris != """"], sum(thepris != """"))
         pritype <- array(0, length(param1))
         pritype[prinms == ""shrink_t""] <- 1
         param2 <- sapply(prisplit, function(x) x[3])"
ecmerkle,blavaan,c2e06363909e605768f667b01fec496868c6f60f,ecmerkle,merklee@missouri.edu,2024-12-30T23:10:30Z,ecmerkle,merklee@missouri.edu,2024-12-30T23:10:30Z,avoid subtraction via -multi_normal_suff because check can mistake it as a flag,inst/stan/stanmarg.stan,False,False,False,False,11,11,22,"---FILE: inst/stan/stanmarg.stan---
@@ -1534,16 +1534,16 @@ model { // N.B.: things declared in the model block do not get saved in the outp
 	target += multi_normal_lpdf(YXstar[r1:r2,1:Nobs[mm]] | Mu[grpidx, obsidx[1:Nobs[mm]]], Sigma[grpidx, obsidx[1:Nobs[mm]], obsidx[1:Nobs[mm]]]);
 
 	if (Nx[mm] > 0) {
-	  target += -multi_normal_lpdf(YXstar[r1:r2,xdatidx[1:Nx[mm]]] | Mu[grpidx, xidx[1:Nx[mm]]], Sigma[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
+	  target += -1.0 * multi_normal_lpdf(YXstar[r1:r2,xdatidx[1:Nx[mm]]] | Mu[grpidx, xidx[1:Nx[mm]]], Sigma[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
 	}
       } else {
 	// sufficient stats
 	target += multi_normal_suff(YXbarstar[mm, 1:Nobs[mm]], Sstar[mm, 1:Nobs[mm], 1:Nobs[mm]], Mu[grpidx, obsidx[1:Nobs[mm]]], Sigmainv[mm, 1:(Nobs[mm] + 1), 1:(Nobs[mm] + 1)], r2 - r1 + 1);
       
 	if (Nx[mm] > 0 && !missing) {
-	  target += -multi_normal_suff(YXbarstar[mm, xdatidx[1:Nx[mm]]], Sstar[mm, xdatidx[1:Nx[mm]], xdatidx[1:Nx[mm]]], Mu[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigmainv[mm], xidx, Nx[mm], p + q, logdetSigma_grp[grpidx]), r2 - r1 + 1);
+	  target += -1.0 * multi_normal_suff(YXbarstar[mm, xdatidx[1:Nx[mm]]], Sstar[mm, xdatidx[1:Nx[mm]], xdatidx[1:Nx[mm]]], Mu[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigmainv[mm], xidx, Nx[mm], p + q, logdetSigma_grp[grpidx]), r2 - r1 + 1);
 	} else if (Nx[mm] > 0) {
-	  target += -multi_normal_lpdf(YXstar[r1:r2,xdatidx[1:Nx[mm]]] | Mu[grpidx, xidx[1:Nx[mm]]], Sigma[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
+	  target += -1.0 * multi_normal_lpdf(YXstar[r1:r2,xdatidx[1:Nx[mm]]] | Mu[grpidx, xidx[1:Nx[mm]]], Sigma[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
 	}
       }
     }
@@ -2055,9 +2055,9 @@ generated quantities { // these matrices are saved in the output but do not figu
 
 	  // TODO efficiency can be improved by getting inverse/chol of Sigma outside loop
 	  if (Nx[mm] > 0 && !missing) {
-	    log_lik[jj] += -multi_normal_suff(YXstar[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigmainv[grpidx], xidx, Nx[mm], p + q, logdetSigma_grp[grpidx]), 1);
+	    log_lik[jj] += -1.0 * multi_normal_suff(YXstar[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigmainv[grpidx], xidx, Nx[mm], p + q, logdetSigma_grp[grpidx]), 1);
 	  } else if (Nx[mm] > 0) {
-	    log_lik[jj] += -multi_normal_lpdf(YXstar[jj, xdatidx[1:Nx[mm]]] | Mu[grpidx, xidx[1:Nx[mm]]], Sigma[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
+	    log_lik[jj] += -1.0 * multi_normal_lpdf(YXstar[jj, xdatidx[1:Nx[mm]]] | Mu[grpidx, xidx[1:Nx[mm]]], Sigma[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
 	  }
 	}
       }
@@ -2128,17 +2128,17 @@ generated quantities { // these matrices are saved in the output but do not figu
 	    
 	    // TODO efficiency can be improved by getting inverse/chol of Sigma outside loop
 	    if (Nx[mm] > 0 && !missing) {
-	      log_lik_rep[jj] += -multi_normal_suff(YXstar_rep[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigmainv[grpidx], xidx, Nx[mm], p + q, logdetSigma_grp[grpidx]), 1);
+	      log_lik_rep[jj] += -1.0 * multi_normal_suff(YXstar_rep[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigmainv[grpidx], xidx, Nx[mm], p + q, logdetSigma_grp[grpidx]), 1);
 	    
-	      log_lik_sat[jj] += -multi_normal_suff(YXstar[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu_sat[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigma_sat_inv[grpidx], xidx, Nx[mm], p + q, logdetS_sat_grp[grpidx]), 1);
+	      log_lik_sat[jj] += -1.0 * multi_normal_suff(YXstar[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu_sat[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigma_sat_inv[grpidx], xidx, Nx[mm], p + q, logdetS_sat_grp[grpidx]), 1);
 	      
-	      log_lik_rep_sat[jj] += -multi_normal_suff(YXstar_rep[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu_rep_sat[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigma_rep_sat_inv[grpidx], xidx, Nx[mm], p + q, logdetS_rep_sat_grp[grpidx]), 1);
+	      log_lik_rep_sat[jj] += -1.0 * multi_normal_suff(YXstar_rep[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu_rep_sat[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigma_rep_sat_inv[grpidx], xidx, Nx[mm], p + q, logdetS_rep_sat_grp[grpidx]), 1);
 	    } else if (Nx[mm] > 0) {
-	      log_lik_rep[jj] += -multi_normal_lpdf(YXstar_rep[jj, xdatidx[1:Nx[mm]]] | Mu[grpidx, xidx[1:Nx[mm]]], Sigma[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
+	      log_lik_rep[jj] += -1.0 * multi_normal_lpdf(YXstar_rep[jj, xdatidx[1:Nx[mm]]] | Mu[grpidx, xidx[1:Nx[mm]]], Sigma[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
 	    
-	      log_lik_sat[jj] += -multi_normal_lpdf(YXstar[jj, xdatidx[1:Nx[mm]]] | Mu_sat[grpidx, xidx[1:Nx[mm]]], Sigma_sat[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
+	      log_lik_sat[jj] += -1.0 * multi_normal_lpdf(YXstar[jj, xdatidx[1:Nx[mm]]] | Mu_sat[grpidx, xidx[1:Nx[mm]]], Sigma_sat[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
 	      
-	      log_lik_rep_sat[jj] += -multi_normal_lpdf(YXstar_rep[jj, xdatidx[1:Nx[mm]]] | Mu_rep_sat[grpidx, xidx[1:Nx[mm]]], Sigma_rep_sat[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
+	      log_lik_rep_sat[jj] += -1.0 * multi_normal_lpdf(YXstar_rep[jj, xdatidx[1:Nx[mm]]] | Mu_rep_sat[grpidx, xidx[1:Nx[mm]]], Sigma_rep_sat[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
 	    }
 	  }
 	  "
ecmerkle,blavaan,98eb4c7a043cb58ac89526e6250f4bbb6d50fb45,ecmerkle,merklee@missouri.edu,2024-11-07T23:39:12Z,ecmerkle,merklee@missouri.edu,2024-11-07T23:39:12Z,"flip sign of alpha for std.lv=TRUE, fixes #94",DESCRIPTION;NEWS.md;R/blavaan.R;R/lav_export_stanmarg.R;R/stanmarg_data.R;inst/stan/stanmarg.stan,False,True,True,False,23,9,32,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-6.1311
+Version: 0.5-6.1313
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: NEWS.md---
@@ -5,6 +5,8 @@
 ## Bugs/glitches discovered after the release:
 * Models with the <~ operator fail under target = ""jags"" (reported by Thomas Riecke).
 
+* For multi-group models with free latent means and std.lv=TRUE, signs of latent means can be incorrect (positive instead of negative; reported by Joshua Pritikin).
+
 # Version 0.5-5
 ## New features
 * Minor changes to ensure compatibility with lavaan 0.6-18. 

---FILE: R/blavaan.R---
@@ -613,7 +613,7 @@ blavaan <- function(...,  # default lavaan arguments
                         if(inherits(jagtrans, ""try-error"")) stop(jagtrans)
 
                         stanmon <- c(""ly_sign"", ""bet_sign"", ""Theta_cov"", ""Theta_var"",
-                                     ""Psi_cov"", ""Psi_var"", ""Nu_free"", ""Alpha_free"", ""Tau_free"")
+                                     ""Psi_cov"", ""Psi_var"", ""Nu_free"", ""al_sign"", ""Tau_free"")
                         if(lavoptions$.multilevel){
                           stanmon <- c(stanmon, paste0(stanmon, ""_c""))
                           stanmon <- stanmon[-which(stanmon == ""Tau_free_c"")]
@@ -656,7 +656,7 @@ blavaan <- function(...,  # default lavaan arguments
                     moment_match_monitors <- c(moment_match_monitors,
                                                paste0(moment_match_monitors, ""_c""))
                     moment_match_monitors <- c(moment_match_monitors, ""Tau_ufree"", 
-                                               ""z_aug"", ""ly_sign"", ""bet_sign"", ""Theta_cov"",
+                                               ""z_aug"", ""ly_sign"", ""bet_sign"", ""al_sign"", ""Theta_cov"",
                                                ""Theta_var"", ""Psi_cov"", ""Psi_var"", ""Tau_free"",
                                                ""log_lik"", ""log_lik_sat"", ""ppp"")
                     jagtrans$monitors <- c(jagtrans$monitors, moment_match_monitors[!(moment_match_monitors %in% jagtrans$monitors)])

---FILE: R/lav_export_stanmarg.R---
@@ -89,7 +89,7 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, wig, ...) {
     wskel[wskel[,1]==1,2] <- freepars[wskel[wskel[,1]==1,2]]
   }
 
-  lvmat <- mat %in% c('Gamma', 'B', 'Psi_r')
+  lvmat <- mat %in% c('Alpha', 'Gamma', 'B', 'Psi_r')
   lammat <- grepl('Lambda', mat)
   sign <- matrix(0, len, 2 + lvmat)
   if (std.lv & (lvmat | lammat)) {
@@ -721,10 +721,13 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
     twsel <- lavpartable$free %in% frnums
     tmpwig <- lavpartable[twsel,'free'][which(lavpartable[twsel, 'plabel'] %in% wig)]
     
-    res <- matattr(fr, es, constrain, mat = ""Alpha"", Ng, opts$std.lv, tmpwig)
+    res <- matattr(fr, es, constrain, mat = ""Alpha"", Ng, opts$std.lv, tmpwig,
+                   free1 = free2$lambda, free2 = lyfree2, sign = dat$lam_y_sign,
+                   dest = dest)
 
     dat$Alpha_skeleton <- res$matskel
     dat$w14skel <- res$wskel
+    dat$alph_sign <- res$sign
     free2 <- c(free2, list(alpha = res$free))
     ptrows <- with(lavpartable, which(mat == ""alpha"" & free > 0))
     veclen <- length(ptrows)
@@ -737,6 +740,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
   } else {
     dat$Alpha_skeleton <- array(0, dim = c(Ng, 0, 0))
     dat$w14skel <- matrix(0, 0, 3)
+    dat$alph_sign <- matrix(0, 0, 3)
   }
 
   ## 15. Tau
@@ -931,7 +935,7 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, dmnames
                Theta_var = ""theta"", Theta_x_cov = ""cov.x"",
                Theta_x_var = ""cov.x"", Psi_cov = ""psi"",
                Psi_var = ""psi"", Nu_free = ""nu"", ## includes mean.x!
-               Alpha_free = ""alpha"", Tau_free = ""tau"")
+               al_sign = ""alpha"", Tau_free = ""tau"")
   matmod <- """"
   olpt <- lavpartable
   levlabs <- blav_partable_level_values(lavpartable)
@@ -956,7 +960,7 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, dmnames
                 dtheta = ""Theta_var"", rtheta_x = ""Theta_x_cov"",
                 dtheta_x = ""Theta_x_var"", rpsi = ""Psi_cov"",
                 dpsi = ""Psi_var"", nu = ""Nu_free"",
-                alpha = ""Alpha_free"", tau = ""Tau_free"")
+                alpha = ""al_sign"", tau = ""Tau_free"")
   if (level == 2L) {
     mapping3 <- sapply(mapping3, function(x) paste0(x, ""_c""))
     names(mapping3) <- sapply(names(mapping3), function(x) paste0(x, ""_c""))

---FILE: R/stanmarg_data.R---
@@ -218,7 +218,7 @@ stanmarg_data <- function(YX = NULL, S = NULL, YXo = NULL, N, Ng, grpnum, # data
                           w4skel, w5skel, w6skel, w7skel, w8skel,
                           w9skel, w10skel, w11skel, w12skel, w13skel,
                           w14skel, w15skel, emiter,
-                          lam_y_sign, lam_x_sign, # sign constraint matrices
+                          lam_y_sign, lam_x_sign, alph_sign, # sign constraint matrices
                           gam_sign, b_sign, psi_r_sign, psi_r_sign_f,
                           nblk, psidims, blkse, phi_r_sign,
                           lavpartable = NULL, # for priors
@@ -237,7 +237,7 @@ stanmarg_data <- function(YX = NULL, S = NULL, YXo = NULL, N, Ng, grpnum, # data
                           w1skel_c = NULL, w4skel_c = NULL, w5skel_c = NULL, w7skel_c = NULL,
                           w9skel_c = NULL, w10skel_c = NULL, w11skel_c = NULL, w13skel_c = NULL,
                           w14skel_c = NULL,
-                          lam_y_sign_c = NULL, b_sign_c = NULL, psi_r_sign_c = NULL,
+                          lam_y_sign_c = NULL, b_sign_c = NULL, alph_sign_c = NULL, psi_r_sign_c = NULL,
                           psi_r_sign_f_c, nblk_c, psidims_c, blkse_c,                          
                           phi_r_sign_c = NULL, dumlv_c = NULL, wigind_c = NULL,
                           Ndum = NULL, dum_ov_idx = NULL, dum_lv_idx = NULL, # for bsam
@@ -395,6 +395,7 @@ stanmarg_data <- function(YX = NULL, S = NULL, YXo = NULL, N, Ng, grpnum, # data
 
   dat$w13skel <- w13skel
   dat$w14skel <- w14skel
+  dat$alph_sign <- alph_sign
   dat$w15skel <- w15skel
 
   ## level 2 matrices
@@ -419,6 +420,7 @@ stanmarg_data <- function(YX = NULL, S = NULL, YXo = NULL, N, Ng, grpnum, # data
   dat$psidims_c <- psidims_c
   dat$blkse_c <- blkse_c
   dat$w13skel_c <- w13skel_c
+  dat$alph_sign_c <- alph_sign_c
   dat$w14skel_c <- w14skel_c
   
 

---FILE: inst/stan/stanmarg.stan---
@@ -734,6 +734,7 @@ data {
   array[Ng, len_w14] int<lower=0> v14;
   array[Ng, use_cov ? 1 : m + n + 1] int<lower=1> u14;
   array[sum(wg14), 3] int<lower=0> w14skel;
+  array[sum(wg14), 3] int<lower=0> alph_sign;
   int<lower=0> len_alph;
   array[len_alph] real alpha_mn;
   array[len_alph] real<lower=0> alpha_sd;
@@ -850,6 +851,7 @@ data {
   array[Ng, len_w14_c] int<lower=0> v14_c;
   array[Ng, m_c + 1] int<lower=1> u14_c;
   array[sum(wg14_c), 3] int<lower=0> w14skel_c;
+  array[sum(wg14_c), 3] int<lower=0> alph_sign_c;
   int<lower=0> len_alph_c;
   array[len_alph_c] real alpha_mn_c;
   array[len_alph_c] real<lower=0> alpha_sd_c;
@@ -1652,6 +1654,7 @@ generated quantities { // these matrices are saved in the output but do not figu
   // sign constraints and correlations
   vector[len_free[1]] ly_sign;
   vector[len_free[4]] bet_sign;
+  vector[len_free[14]] al_sign;
   array[Ng] matrix[m, m] PSmat;
   array[Ng] matrix[m, m] PS;
   vector[len_free[7]] Theta_cov;
@@ -1663,6 +1666,7 @@ generated quantities { // these matrices are saved in the output but do not figu
   // level 2
   vector[len_free_c[1]] ly_sign_c;
   vector[len_free_c[4]] bet_sign_c;
+  vector[len_free_c[14]] al_sign_c;
   array[Ng] matrix[m_c, m_c] PSmat_c;
   array[Ng] matrix[m_c, m_c] PS_c;
   vector[len_free_c[7]] Theta_cov_c;
@@ -1705,12 +1709,14 @@ generated quantities { // these matrices are saved in the output but do not figu
   // first deal with sign constraints:
   ly_sign = sign_constrain_load(Lambda_y_free, len_free[1], lam_y_sign);
   bet_sign = sign_constrain_reg(B_free, len_free[4], b_sign, Lambda_y_free, Lambda_y_free);
+  al_sign = sign_constrain_reg(Alpha_free, len_free[14], alph_sign, Lambda_y_free, rep_vector(1, len_free[1]));
   if (len_free[10] > 0) {
     P_r = sign_constrain_reg(Psi_r_free, len_free[10], psi_r_sign, Lambda_y_free, Lambda_y_free);
   }
 
   ly_sign_c = sign_constrain_load(Lambda_y_free_c, len_free_c[1], lam_y_sign_c);
   bet_sign_c = sign_constrain_reg(B_free_c, len_free_c[4], b_sign_c, Lambda_y_free_c, Lambda_y_free_c);
+  al_sign_c = sign_constrain_reg(Alpha_free_c, len_free_c[14], alph_sign_c, Lambda_y_free_c, rep_vector(1, len_free_c[1]));
   if (len_free_c[10] > 0) {
     P_r_c = sign_constrain_reg(Psi_r_free_c, len_free_c[10], psi_r_sign_c, Lambda_y_free_c, Lambda_y_free_c);
   }"
ecmerkle,blavaan,fdb319b2a93c82bc8f7da4ec13701b8ed866c48a,ecmerkle,merklee@missouri.edu,2024-09-27T18:59:23Z,ecmerkle,merklee@missouri.edu,2024-09-27T18:59:23Z,fix issue with indexing blocks of psi,DESCRIPTION;R/lav_export_stanmarg.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-6.1308
+Version: 0.5-6.1309
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lav_export_stanmarg.R---
@@ -581,7 +581,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
       } else {
         blkgrp <- rep(1:length(blkinfo), times = sapply(blkinfo, function(x) sum(x$blkse[,2] - x$blkse[,1] > 1)))
       }
-      arrayidx <- as.numeric(as.factor(ublksizes))
+      arrayidx <- as.numeric(as.factor(blksizes))
       dupsiz <- duplicated(blksizes)
       blkidx <- rep(NA, nrow(blkse))
       for (i in 1:length(ublksizes)) {"
ecmerkle,blavaan,2d14cc0fc5deed54527d5ffac944661fa3b7cbe4,ecmerkle,merklee@missouri.edu,2024-09-19T22:31:49Z,ecmerkle,merklee@missouri.edu,2024-09-19T22:31:49Z,fix covariance matrix check in two-level models,DESCRIPTION;R/blav_utils.R,False,True,True,False,3,2,5,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-6.1307
+Version: 0.5-6.1308
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_utils.R---
@@ -433,6 +433,7 @@ checkcovs <- function(lavobject){
     ## surprising if this happens:
     fullthet <- all(unlist(thetnums) > 0L, na.rm = TRUE) & (anyDuplicated(unlist(thetnums), MARGIN = 0) == 0L)
     ## check for blocks of free covariances that have no impact on each other
+    ## FIXME
     thetblk <- sapply(thets, function(x) {
       x[!lower.tri(x)] <- 0
       frnums <- which(x > 0, arr.ind = TRUE)
@@ -442,7 +443,7 @@ checkcovs <- function(lavobject){
         blk <- TRUE
       }
       blk} )
-    blkt <- all(thetblk)
+    blkt <- all(unlist(thetblk))
   } else {
     diagthet <- FALSE
     fullthet <- TRUE"
ecmerkle,blavaan,d2586d1e20cd78b135c5b5ab3177d55ef9b94a01,ecmerkle,merklee@missouri.edu,2024-09-06T02:42:45Z,ecmerkle,merklee@missouri.edu,2024-09-06T02:42:45Z,fix typo,DESCRIPTION,False,False,False,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-6.1305
+Version: 0.5-6.1306
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",
@@ -35,7 +35,7 @@ Description: Fit a variety of Bayesian latent variable models, including confirm
 License: GPL (>= 3)
 ByteCompile: true
 Depends: R(>= 3.5.0), methods, Rcpp(>= 0.12.15)
-Imports: stats, utils, graphics, lavaan(>= 0.6-17), coda, mnormt, nonnest2(>= 0.5-7)
+Imports: stats, utils, graphics, lavaan(>= 0.6-17), coda, mnormt, nonnest2(>= 0.5-7), loo(>= 2.0), rstan(>= 2.26.0), rstantools(>= 1.5.0), RcppParallel (>= 5.0.1), bayesplot, Matrix, future.apply, tmvnsim
 LinkingTo: StanHeaders (>= 2.26.0), rstan (>= 2.26.0), BH (>= 1.69.0), Rcpp (>= 0.12.15), RcppEigen (>= 0.3.3.4.0), RcppParallel (>= 5.0.1)
 Suggests: runjags(>= 2.0.4-3), modeest(>= 2.3.3), rjags, cmdstanr, semTools, bsam, tinytest
 SystemRequirements: GNU make"
ecmerkle,blavaan,20a95bd5f0389677835fd5dc2a6d538f928defa5,ecmerkle,merklee@missouri.edu,2024-09-06T01:45:13Z,ecmerkle,merklee@missouri.edu,2024-09-06T01:45:13Z,fix typo,DESCRIPTION,False,False,False,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-6.1304
+Version: 0.5-6.1305
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",
@@ -35,7 +35,7 @@ Description: Fit a variety of Bayesian latent variable models, including confirm
 License: GPL (>= 3)
 ByteCompile: true
 Depends: R(>= 3.5.0), methods, Rcpp(>= 0.12.15)
-Imports: stats, utils, graphics, lavaan(>= 0.6-17), coda, mnormt, nonnest2(>= 0.5-6.1304
+Imports: stats, utils, graphics, lavaan(>= 0.6-17), coda, mnormt, nonnest2(>= 0.5-7)
 LinkingTo: StanHeaders (>= 2.26.0), rstan (>= 2.26.0), BH (>= 1.69.0), Rcpp (>= 0.12.15), RcppEigen (>= 0.3.3.4.0), RcppParallel (>= 5.0.1)
 Suggests: runjags(>= 2.0.4-3), modeest(>= 2.3.3), rjags, cmdstanr, semTools, bsam, tinytest
 SystemRequirements: GNU make"
ecmerkle,blavaan,6bf4882d66b910912e1d80bf8913b2db43a6c7ba,ecmerkle,merklee@missouri.edu,2024-09-04T15:03:32Z,ecmerkle,merklee@missouri.edu,2024-09-04T15:03:32Z,fix calculation of number of ordered categories,DESCRIPTION;R/lav_export_stanmarg.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-5.1300
+Version: 0.5-5.1302
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lav_export_stanmarg.R---
@@ -1386,7 +1386,7 @@ lav2standata <- function(lavobject, dosam = FALSE) {
     dat$YX <- dat$YX[, -ordidx, drop=FALSE]
 
 
-    nlevs <- 1 + as.numeric( table(pta$th.idx[[1]]) )
+    nlevs <- 1 + as.numeric( table(pta$th.idx[[1]][pta$th.idx[[1]] != 0L]) )
     maxcat <- max(nlevs)
 
     dat$Nord <- length(ordidx)"
ecmerkle,blavaan,ba6da9b57b0f8463b339fa110813060225183825,ecmerkle,merklee@missouri.edu,2024-08-22T00:57:12Z,ecmerkle,merklee@missouri.edu,2024-08-22T00:57:12Z,fix anchors,man/bcfa.Rd;man/blavFitIndices.Rd;man/blavaan.Rd;man/bsem.Rd;man/ppmc.Rd,False,False,False,False,6,6,12,"---FILE: man/bcfa.Rd---
@@ -105,7 +105,7 @@ to 10000 for target=""jags"" and 1000 for Stan targets.}
     and \code{auto.cov.y = TRUE}.
 }
 \value{
-  An object that inherits from class \code{\linkS4class[lavaan]{lavaan}}, for which several methods
+  An object that inherits from class \link[lavaan:lavaan-class]{lavaan}, for which several methods
   are available, including a \code{summary} method.
 }
 \references{

---FILE: man/blavFitIndices.Rd---
@@ -48,7 +48,7 @@ blavFitIndices(object, thin = 1L, pD = c(""loo"",""waic"",""dic""),
     \code{""BGammaHat""}, \code{""adjBGammaHat""}, \code{""BMc""}, \code{""BCFI""},
     \code{""BTLI""}, or \code{""BNFI""}. If \code{rescale = ""MCMC""}, the user may
     request any indices returned by \code{\link[lavaan]{fitMeasures}} for
-    objects of class \code{\linkS4class[lavaan]{lavaan}}.}
+    objects of class \link[lavaan:lavaan-class]{lavaan}.}
   \item{baseline.model}{If not \code{NULL}, an object of class
     \code{\linkS4class{blavaan}}, representing a user-specified baseline model.
     If a \code{baseline.model} is provided, incremental fit indices (BCFI,

---FILE: man/blavaan.Rd---
@@ -94,7 +94,7 @@ to 10000 for target=""jags"" and 1000 for Stan targets.}
     overview of the additional parameters that can be set.}
 }
 \value{
-  An object that inherits from class \code{\linkS4class[lavaan]{lavaan}}, for which several methods
+  An object that inherits from class \link[lavaan:lavaan-class]{lavaan}, for which several methods
   are available, including a \code{summary} method.
 }
 \references{

---FILE: man/bsem.Rd---
@@ -103,7 +103,7 @@ to 10000 for target=""jags"" and 1000 for Stan targets.}
     and \code{auto.cov.y = TRUE}.
   }
 \value{
-  An object of class \code{\linkS4class[lavaan]{lavaan}}, for which several methods
+  An object of class \link[lavaan:lavaan-class]{lavaan}, for which several methods
   are available, including a \code{summary} method.
 }
 \references{

---FILE: man/ppmc.Rd---
@@ -11,7 +11,7 @@
 \description{
 This function allows users to conduct a posterior predictive model check to
 assess the global or local fit of a latent variable model using any discrepancy
-function that can be applied to a \code{\linkS4class[lavaan]{lavaan}} model.}
+function that can be applied to a \link[lavaan:lavaan-class]{lavaan} model.}
 \usage{
 ppmc(object, thin = 1, fit.measures = c(""srmr"",""chisq""), discFUN = NULL,
      conditional = FALSE)
@@ -44,7 +44,7 @@ ppmc(object, thin = 1, fit.measures = c(""srmr"",""chisq""), discFUN = NULL,
     \code{discFUN}. For ordinal models, the \code{""logl""} or \code{""chisq""}
     computations are done via lavaan.}
   \item{discFUN}{\code{function}, or a \code{list} of functions, that can be
-    called on an object of class \code{\linkS4class[lavaan]{lavaan}}. Each function
+    called on an object of class \link[lavaan:lavaan-class]{lavaan}. Each function
     must return an object whose \code{\link{mode}} is \code{numeric}, but may
     be a \code{vector}, \code{matrix}, or multidimensional \code{array}. In
     the \code{summary} and \code{plot} methods, \code{discFUN} is a"
ecmerkle,blavaan,c276d620672a871c146129224954170d9c1e78eb,ecmerkle,merklee@missouri.edu,2024-08-17T02:29:07Z,ecmerkle,merklee@missouri.edu,2024-08-17T02:29:07Z,"target=""jags"", fix vcov dimension for some models with complex equality constraints",R/lav_export_mcmc.R,False,True,True,False,1,1,2,"---FILE: R/lav_export_mcmc.R---
@@ -796,7 +796,7 @@ coeffun <- function(lavpartable, pxpartable, rjob, fun = ""mean"") {
   ## NB this automatically removes fixed parameters, just
   ##    like the psrf
   lmatch <- match(lavpartable$pxnames[lavpartable$free > 0],
-                  rownames(rjob$crosscorr))
+                  rownames(rjob$crosscorr), nomatch = 0)
   vcorr <- rjob$crosscorr[lmatch, lmatch]
   smatch <- match(lavpartable$pxnames[lavpartable$free > 0 | lavpartable$op == "":=""],
                   rownames(rjob$summary$statistics),"
ecmerkle,blavaan,eb9c76c0e5394f2c36518adce9fabd4546b25260,ecmerkle,merklee@missouri.edu,2024-07-25T16:53:53Z,ecmerkle,merklee@missouri.edu,2024-07-25T16:53:53Z,"improve decision about when to compute mll, fixing #81",DESCRIPTION;R/blav_utils.R;R/blavaan.R,False,True,True,False,44,5,49,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-5.1290
+Version: 0.5-5.1291
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_utils.R---
@@ -409,9 +409,21 @@ checkcovs <- function(lavobject){
     psinums <- sapply(psis, function(x) x[lower.tri(x)])
     diagpsi <- all(unlist(psinums) == 0L, na.rm = TRUE)
     fullpsi <- all(unlist(psinums) > 0L, na.rm = TRUE) & (anyDuplicated(unlist(psinums), MARGIN = 0) == 0L)
+    ## check for blocks of free covariances that have no impact on each other
+    psiblk <- sapply(psis, function(x) {
+      x[!lower.tri(x)] <- 0
+      frnums <- which(x > 0, arr.ind = TRUE)
+      if (nrow(frnums) > 0) {
+        blk <- !duplicated(as.numeric(frnums))
+      } else {
+        blk <- TRUE
+      }
+      blk} )
+    blkp <- all(psiblk)
   } else {
     diagpsi <- FALSE
     fullpsi <- TRUE
+    blkp <- TRUE
   }
 
   if (nrow(free[[1]]$theta) > 0) {
@@ -420,12 +432,24 @@ checkcovs <- function(lavobject){
     diagthet <- all(unlist(thetnums) == 0L, na.rm = TRUE)
     ## surprising if this happens:
     fullthet <- all(unlist(thetnums) > 0L, na.rm = TRUE) & (anyDuplicated(unlist(thetnums), MARGIN = 0) == 0L)
+    ## check for blocks of free covariances that have no impact on each other
+    thetblk <- sapply(thets, function(x) {
+      x[!lower.tri(x)] <- 0
+      frnums <- which(x > 0, arr.ind = TRUE)
+      if (nrow(frnums) > 0) {
+        blk <- !duplicated(as.numeric(frnums))
+      } else {
+        blk <- TRUE
+      }
+      blk} )
+    blkt <- all(thetblk)
   } else {
     diagthet <- FALSE
     fullthet <- TRUE
+    blkt <- TRUE
   }
 
-  list(diagpsi = diagpsi, fullpsi = fullpsi, diagthet = diagthet, fullthet = fullthet)
+  list(diagpsi = diagpsi, fullpsi = fullpsi, diagthet = diagthet, fullthet = fullthet, dobf = (blkp && blkt))
 }
 
 ## check whether model cov matrix is block diagonal

---FILE: R/blavaan.R---
@@ -1037,9 +1037,24 @@ blavaan <- function(...,  # default lavaan arguments
     domll <- TRUE
     covres <- checkcovs(LAV)
     ## in these cases, we cannot reliably evaluate the priors
-    if(ordmod | !(covres$diagthet | covres$fullthet)) domll <- FALSE
-    if(target == ""stan"" && !l2s$blkpsi) domll <- FALSE
-    if(target != ""stan"" && !(covres$diagpsi | covres$fullpsi)) domll <- FALSE
+    if(ordmod) domll <- FALSE
+    if(target == ""stan"") {
+      if(covres$dobf) {
+        domll <- TRUE
+      } else if((covres$diagthet | covres$fullthet) & l2s$blkpsi) {
+        domll <- TRUE
+      } else {
+        domll <- FALSE
+      }
+    } else {
+      if(covres$dobf) {
+        domll <- TRUE
+      } else if((covres$diagpsi | covres$fullpsi) & covres$diagthet) {
+        domll <- TRUE
+      } else {
+        domll <- FALSE
+      }
+    }
 
     if(lavoptions$test != ""none"") { # && attr(x, ""converged"")) {
         TEST <- blav_model_test(lavmodel            = lavmodel,"
ecmerkle,blavaan,b4205696a966da42c4acbe08d6ee33e925473aa4,ecmerkle,merklee@missouri.edu,2024-06-23T05:07:37Z,ecmerkle,merklee@missouri.edu,2024-06-23T05:07:37Z,"fix blavPredict when newdata is supplied with type=""ov"" or ""ypred""",DESCRIPTION;NEWS.md;R/blav_predict.R,False,True,True,False,11,1,12,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-5.1289
+Version: 0.5-5.1290
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: NEWS.md---
@@ -4,6 +4,11 @@
 
 * Bugs from 0.5-4 are fixed.
 
+## Bugs/glitches discovered after the release:
+* On some systems, blavaan installation fails with a ""parser failed badly"" message from rstan (reported by Larry Hunsicker).
+
+* blavPredict(, type=""ov""/""ypred"") can fail when the sample size of newdata differs from the sample size of the original data (reported by Niels Skovgaard-Olsen).
+
 # Version 0.5-4
 ## New features
 * New function sampleData() for generating data from a blavaan object.

---FILE: R/blav_predict.R---
@@ -40,6 +40,10 @@ blavPredict <- function(object, newdata = NULL, type = ""lv"", level = 1L) {
     if(!stantarget) stop(""blavaan ERROR: newdata is currently only available for target='stan'"")
     if(lavInspect(object, ""categorical"")) stop(""blavaan ERROR: newdata is not yet available for ordinal data."")
     object <- blav_fill_newdata(object, newdata)
+
+    blavsamplestats <- object@SampleStats
+    blavdata <- object@Data
+    standata <- object@external$mcmcdata
   }
 
   
@@ -138,6 +142,7 @@ blav_fill_newdata <- function(object, newdat, lvs = TRUE) {
                       ov.names.x = olddata@ov.names.x,
                       ordered = OV$names[ OV$type == ""ordered"" ],
                       lavoptions = object@Options, allow.single.case = TRUE)
+  object@SampleStats@ntotal <- NROW(newdat)
 
   ## Stan-formatted newdata
   l2s <- lav2stanmarg(object, dp = blavInspect(object, 'options')$dp,"
ecmerkle,blavaan,27a2de8954103c4eb05d5ad2be117c97c9719910,ecmerkle,merklee@missouri.edu,2024-06-10T18:34:10Z,ecmerkle,merklee@missouri.edu,2024-06-10T18:34:10Z,fix previous commit,DESCRIPTION,False,False,False,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-5.1287
+Version: 0.5-5.1288
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",
@@ -35,7 +35,7 @@ Description: Fit a variety of Bayesian latent variable models, including confirm
 License: GPL (>= 3)
 ByteCompile: true
 Depends: R(>= 3.5.0), methods, Rcpp(>= 0.12.15)
-Imports: stats, utils, graphics, lavaan(>= 0.6-17), coda, mnormt, nonnest2(>= 0.5-6)
+Imports: stats, utils, graphics, lavaan(>= 0.6-17), coda, mnormt, nonnest2(>= 0.5-6), loo(>= 2.0), rstan(>= 2.26.0), rstantools(>= 1.5.0), RcppParallel (>= 5.0.1), bayesplot, Matrix, future.apply, tmvnsim
 LinkingTo: StanHeaders (>= 2.26.0), rstan (>= 2.26.0), BH (>= 1.69.0), Rcpp (>= 0.12.15), RcppEigen (>= 0.3.3.4.0), RcppParallel (>= 5.0.1)
 Suggests: runjags(>= 2.0.4-3), modeest(>= 2.3.3), rjags, cmdstanr, semTools, bsam, tinytest
 SystemRequirements: GNU make"
ecmerkle,blavaan,e89f69184441a075f35096d3ce80f242af71eba4,ecmerkle,merklee@missouri.edu,2024-06-10T18:29:23Z,ecmerkle,merklee@missouri.edu,2024-06-10T18:29:23Z,fix previous commit,DESCRIPTION,False,False,False,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-5.1286
+Version: 0.5-5.1287
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",
@@ -35,7 +35,7 @@ Description: Fit a variety of Bayesian latent variable models, including confirm
 License: GPL (>= 3)
 ByteCompile: true
 Depends: R(>= 3.5.0), methods, Rcpp(>= 0.12.15)
-Imports: stats, utils, graphics, lavaan(>= 0.6-17), coda, mnormt, nonnest2(>= 0.5-5.1286
+Imports: stats, utils, graphics, lavaan(>= 0.6-17), coda, mnormt, nonnest2(>= 0.5-6)
 LinkingTo: StanHeaders (>= 2.26.0), rstan (>= 2.26.0), BH (>= 1.69.0), Rcpp (>= 0.12.15), RcppEigen (>= 0.3.3.4.0), RcppParallel (>= 5.0.1)
 Suggests: runjags(>= 2.0.4-3), modeest(>= 2.3.3), rjags, cmdstanr, semTools, bsam, tinytest
 SystemRequirements: GNU make"
ecmerkle,blavaan,14dffcef82f855784743b1f85d36ad7cf08f23fa,ecmerkle,merklee@missouri.edu,2024-06-09T16:10:03Z,ecmerkle,merklee@missouri.edu,2024-06-09T16:10:03Z,avoid verbose error coming from lavaan 0.6-18,DESCRIPTION;R/blavaan.R,False,True,True,False,10,1,11,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-4.1279
+Version: 0.5-4.1280
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blavaan.R---
@@ -352,6 +352,15 @@ blavaan <- function(...,  # default lavaan arguments
         if(!inherits(LAV2, 'try-error')) LAV <- LAV2
     }
 
+    ## ensure verbose appears in lavoptions, for 0.6-18 (FIXME also warn/debug?)
+    if(!(""verbose"" %in% names(LAV@Options))) {
+      if(!(""verbose"" %in% names(dotdotdot))) {
+        LAV@Options$verbose <- FALSE
+      } else {
+        LAV@Options$verbose <- dotdotdot$verbose
+      }
+    }
+  
     if(LAV@Data@data.type == ""moment"") {
         if(target != ""stan"") stop('blavaan ERROR: full data are required for ', target, ' target.\n  Try target=""stan"", or consider using kd() from package semTools.')
     }"
ecmerkle,blavaan,0f1e8f3b73fa9141d0b96294455d60615c295e8c,ecmerkle,merklee@missouri.edu,2024-06-06T02:51:54Z,ecmerkle,merklee@missouri.edu,2024-06-06T02:51:54Z,"for ordinal models, set up lavaan object using DWLS to avoid errors due to sparse categories",DESCRIPTION;R/blavaan.R,False,True,True,False,4,3,7,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-4.1278
+Version: 0.5-4.1279
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",
@@ -42,5 +42,5 @@ SystemRequirements: GNU make
 NeedsCompilation: yes
 URL: https://ecmerkle.github.io/blavaan/, https://github.com/ecmerkle/blavaan
 BugReports: https://github.com/ecmerkle/blavaan/issues
-Additional_repositories: https://mc-stan.org/r-packages/
+Additional_repositories: https://stan-dev.r-universe.dev
 Config/Needs/website: brms

---FILE: R/blavaan.R---
@@ -238,6 +238,7 @@ blavaan <- function(...,  # default lavaan arguments
     }
     dotdotdot$parameterization <- ""theta""
     dotdotdot$estimator <- ""default""
+    if(ordmod) dotdotdot$estimator <- ""DWLS"" ## to avoid errors setting up weight matrix
     dotdotdot$conditional.x <- FALSE
   
     # jags args
@@ -375,7 +376,7 @@ blavaan <- function(...,  # default lavaan arguments
     # ordinal only for stan
     ordmod <- lavInspect(LAV, 'categorical')
     if(ordmod) {
-        if(!(target %in% c(""stan"", ""cmdstan""))) stop(""blavaan ERROR: ordinal variables only work for target='stan' or 'cmdstan'."")
+        if(!(target %in% c(""stan"", ""cmdstan"", ""vb""))) stop(""blavaan ERROR: ordinal variables only work for target='stan' or 'cmdstan' or 'vb'."")
     }
         
     ineq <- which(LAV@ParTable$op %in% c(""<"","">""))"
ecmerkle,blavaan,adcf9e6b1d38ffdd4f54afc407f8c63f5213fdf8,ecmerkle,merklee@missouri.edu,2024-05-08T18:38:30Z,ecmerkle,merklee@missouri.edu,2024-05-08T18:38:30Z,fix count of bsam lvs,DESCRIPTION;R/lav_export_stanmarg.R,False,True,True,False,3,4,7,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-4.1274
+Version: 0.5-4.1275
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",
@@ -37,7 +37,7 @@ ByteCompile: true
 Depends: R(>= 3.5.0), methods, Rcpp(>= 0.12.15)
 Imports: stats, utils, graphics, lavaan(>= 0.6-17), coda, mnormt, nonnest2(>= 0.5-5), loo(>= 2.0), rstan(>= 2.26.0), rstantools(>= 1.5.0), RcppParallel (>= 5.0.1), bayesplot, Matrix, future.apply, tmvnsim
 LinkingTo: StanHeaders (>= 2.26.0), rstan (>= 2.26.0), BH (>= 1.69.0), Rcpp (>= 0.12.15), RcppEigen (>= 0.3.3.4.0), RcppParallel (>= 5.0.1)
-Suggests: runjags(>= 2.0.4-3), modeest(>= 2.3.3), rjags, cmdstanr, semTools, tinytest
+Suggests: runjags(>= 2.0.4-3), modeest(>= 2.3.3), rjags, cmdstanr, semTools, bsam, tinytest
 SystemRequirements: GNU make
 NeedsCompilation: yes
 URL: https://ecmerkle.github.io/blavaan/, https://github.com/ecmerkle/blavaan

---FILE: R/lav_export_stanmarg.R---
@@ -1133,8 +1133,7 @@ lav2standata <- function(lavobject, dosam = FALSE) {
     lavmodel <- lavobject@Model
 
     ## single group only
-    lvs <- lavNames(lavobject, type = 'lv')
-    lvvars <- 1:length(lvs)
+    lvvars <- 1:NCOL(lavmodel@GLIST$lambda)
     
     dummy.ov.x.idx <- lavmodel@ov.x.dummy.ov.idx[[1]]
     dummy.lv.x.idx <- lavmodel@ov.x.dummy.lv.idx[[1]]"
ecmerkle,blavaan,32f37b8414fa7ae7e80477ae6abee5f85f06bd14,ecmerkle,merklee@missouri.edu,2024-05-08T13:08:20Z,ecmerkle,merklee@missouri.edu,2024-05-08T13:08:20Z,fix previous commit,DESCRIPTION;R/blavaan.R,False,True,True,False,2,4,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-4.1273
+Version: 0.5-4.1274
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blavaan.R---
@@ -105,9 +105,7 @@ blavaan <- function(...,  # default lavaan arguments
         if(""syntax"" %in% names(mcmcextra)) stop(paste0(""blavaan ERROR: mcmcextra$syntax is not available for target='"", target, ""'.""))
       }
     } else if(target == ""jags""){
-      if(length(mcmcextra) > 0){
-        if(""dosam"" %in% names(mcmcextra)) stop(""blavaan ERROR: SAM requires target = 'stan'"")
-      }
+      if(mcmcextra$dosam) stop(""blavaan ERROR: SAM requires target = 'stan'"")
       if(!pkgcheck(""runjags"")){
         ## go to rstan if they have it
         if(pkgcheck(""rstan"")){"
ecmerkle,blavaan,d4b257006cd344df5f65d8cc40f646f60677db88,ecmerkle,merklee@missouri.edu,2024-05-07T14:40:39Z,ecmerkle,merklee@missouri.edu,2024-05-07T14:40:39Z,fix #78,DESCRIPTION;R/blavaan.R,False,True,True,False,3,2,5,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-4.1270
+Version: 0.5-4.1271
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blavaan.R---
@@ -1149,9 +1149,10 @@ bcfa <- bsem <- function(..., cp = ""srs"", dp = NULL,
     dotdotdot <- list(...)
     std.lv <- ifelse(any(names(dotdotdot) == ""std.lv""), dotdotdot$std.lv, FALSE)
 
-    mc <- match.call()  
+    mc <- match.call()
     mc$model.type      = as.character( mc[[1L]] )
     if(length(mc$model.type) == 3L) mc$model.type <- mc$model.type[3L]
+    mc$model.type <- gsub(""^b"", """", mc$model.type)
     mc$n.chains        = n.chains
     mc$int.ov.free     = TRUE
     mc$int.lv.free     = FALSE"
ecmerkle,blavaan,cdba940bbe32835e1a3689a846e105b88baf2e6b,ecmerkle,merklee@missouri.edu,2024-05-07T13:45:16Z,ecmerkle,merklee@missouri.edu,2024-05-07T13:45:16Z,"fix ppmc with length one fit.measures=""chisq""",DESCRIPTION;R/ctr_ppmc.R,False,True,True,False,4,4,8,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-4.1269
+Version: 0.5-4.1270
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/ctr_ppmc.R---
@@ -576,12 +576,12 @@ ppmc <- function(object, thin = 1, fit.measures = c(""srmr"",""chisq""),
   }
 
   ## differentiate between multiple possible chisq stats
-  if (length(fit.measures) == 1L & blavInspect(object, ""categorical"")) {
+  if (length(fit.measures) == 1L) {
     if (fit.measures == ""chisq"") {
-      ## add another so that the dwls chisq from lavaan is used
+      ## add another so that the chisq from lavaan is used
       ## (due to the way blav_model_loglik is structured)
       fit.measures <- c(""chisq"", ""chisq.scaled"")
-    } else if (fit.measures == ""marglogl"") {
+    } else if (fit.measures == ""marglogl"" & blavInspect(object, ""categorical"")) {
       ## approximate the marginal lrt
       fit.measures <- ""chisq""
     }"
ecmerkle,blavaan,58bf8b583834a341f0d50fed486f7a3326ec0284,ecmerkle,merklee@missouri.edu,2024-05-03T18:40:45Z,ecmerkle,merklee@missouri.edu,2024-05-03T18:40:45Z,fix equality-constrained loadings with std.lv=TRUE,DESCRIPTION;NEWS.md;R/lav_export_stanmarg.R,False,True,True,False,13,8,21,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-4.1266
+Version: 0.5-4.1269
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: NEWS.md---
@@ -9,6 +9,11 @@
 
 * Bugs from 0.5-3 are fixed.
 
+## Bugs/glitches discovered after the release:
+* Some two-level models fail when only one observed variable appears at a level (reported by Carl Falk).
+
+* For target = ""stan"", some models fail when loadings are equality constrained and std.lv = TRUE (reported by Amos Pagin).
+
 # Version 0.5-3
 ## New features
 * Functionality to find unrestricted blocks of the model's psi matrix (lv covariance matrix). lkj priors are assigned to these unrestricted blocks, improving the positive definite issue described in the ""Opaque priors"" paper.

---FILE: R/lav_export_stanmarg.R---
@@ -96,8 +96,8 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, wig, ...) {
     if (lvmat & length(ddd$sign) > 0) {
       lamfree <- ddd$free1
       lamfree2 <- ddd$free2
-      transtab <- cbind(sapply(lamfree, function(x) x[x != 0]),
-                        sapply(lamfree2, function(x) x[x != 0]))
+      transtab <- cbind(as.numeric(sapply(lamfree, function(x) x[x != 0])),
+                        as.numeric(sapply(lamfree2, function(x) x[x != 0])))
       lamsign <- ddd$sign
 
       for (i in 1:length(free2)) {
@@ -113,7 +113,7 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, wig, ...) {
 
             ## see whether any are equality constrained
             l1match <- match(lampar1, constraint$rhs, nomatch = 0L)
-            transconst <- transtab[match(constraint$lhs[l1match], transtab[,1]), 2*i]
+            transconst <- transtab[match(constraint$lhs[l1match], transtab[,1]), 2]
             lampar12[l1match != 0] <- as.numeric(transconst)
             if (all(lampar12 == 0)) { # ov converted to lv
               l1 <- 1
@@ -122,21 +122,21 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, wig, ...) {
               l1 <- lampar12[which(lampar12 %in% lamsign[,2])]
               ## for across-group equality constraint:
               if (length(l1) == 0) l1 <- lampar12[lampar12 != 0][1]
-              if (lamsign[l1,1] == 1) l1 <- lamsign[l1,2]
+              if (lamsign[l1[1],1] == 1) l1 <- lamsign[l1[1],2]
             }
 
             lampar2 <- lamfree[[i]][,fpar[j,1]]
             lampar22 <- lamfree2[[i]][,fpar[j,1]]
             l2match <- match(lampar2, constraint$rhs, nomatch = 0L)
-            transconst <- transtab[match(constraint$lhs[l2match], transtab[,1]), 2*i]
+            transconst <- transtab[match(constraint$lhs[l2match], transtab[,1]), 2]
             lampar22[l2match != 0] <- as.numeric(transconst)
             if (all(lampar22 == 0)) {
               l2 <- 1
             } else {
               lampar22 <- lampar22[lampar22 != 0]
               l2 <- lampar22[which(lampar22 %in% lamsign[,2])]
               if (length(l2) == 0) l2 <- lampar22[lampar22 != 0][1]
-              if (lamsign[l2,1] == 1) l2 <- lamsign[l2,2]
+              if (lamsign[l2[1],1] == 1) l2 <- lamsign[l2[1],2]
             }
 
             rowloc <- free2[[i]][fpar[j,1], fpar[j,2]]
@@ -632,7 +632,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
     frnums <- sapply(fr, function(x) as.numeric(x[x != 0]))
     twsel <- lavpartable$free %in% frnums
     tmpwig <- lavpartable[twsel,'free'][which(lavpartable[twsel, 'plabel'] %in% wig)]
-    
+
     res <- matattr(fr, es, constrain, mat = ""Psi_r"", Ng, opts$std.lv, tmpwig,
                    free1 = free2$lambda, free2 = lyfree2, sign = dat$lam_y_sign,
                    dest = dest)"
ecmerkle,blavaan,650c94d51c40ffbfc38ec6d410f3312a08db29e2,ecmerkle,merklee@missouri.edu,2024-04-15T00:32:45Z,ecmerkle,merklee@missouri.edu,2024-04-15T00:32:45Z,margloglik: error if cannot fill in unrestricted blocks of covariance matrix,DESCRIPTION;R/margloglik.R,False,True,True,False,7,2,9,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-3.1261
+Version: 0.5-3.1263
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/margloglik.R---
@@ -88,7 +88,12 @@ margloglik <- function(lavpartable, lavmodel, lavoptions,
       tmpmat <- diag(lavpartable$est[varpars])
 
       if(length(covpars) > 0){
-        tmpmat[lower.tri(tmpmat)] <- lavpartable$est[covpars]
+        if(sum(lower.tri(tmpmat)) != length(covpars)){
+          ## TODO need to evaluate blocks of the matrix at a time
+          stop(""blavaan ERROR: margloglik problem evaluating covariance matrix"")
+        } else {
+          tmpmat[lower.tri(tmpmat)] <- lavpartable$est[covpars]
+        }
       }
       tmpmat <- tmpmat + t(tmpmat)
       diag(tmpmat) <- diag(tmpmat)/2"
ecmerkle,blavaan,94522bf227ac3bab930d05fda7c76d6f24db14a5,ecmerkle,merklee@missouri.edu,2024-04-06T23:10:21Z,ecmerkle,merklee@missouri.edu,2024-04-06T23:10:21Z,"fix some warnings that, for two-level models, were false alarms",R/blavaan.R,False,True,True,False,11,9,20,"---FILE: R/blavaan.R---
@@ -353,8 +353,8 @@ blavaan <- function(...,  # default lavaan arguments
     # save.lvs in a model with no lvs
     if(save.lvs){
         clv <- lavInspect(LAV, 'cov.lv')
-        if(is.list(clv)) clv <- clv[[1]]
-        if(nrow(clv) == 0) warning(""blavaan WARNING: save.lvs=TRUE, but there are no lvs in the model."", call. = FALSE)
+        if(!is.list(clv)) clv <- list(clv)
+        if(all(sapply(clv, nrow) == 0)) warning(""blavaan WARNING: save.lvs=TRUE, but there are no lvs in the model."", call. = FALSE)
     }
         
     # turn warnings back on by default
@@ -1118,13 +1118,15 @@ blavaan <- function(...,  # default lavaan arguments
         lavInspect(blavaan, ""post.check"")
     }
 
-    if( ""psi"" %in% lavpartable$mat &&
-        ( (target == ""stan"" && !l2s$blkpsi) ||
-          (target != ""stan"" && with(covres, !(diagpsi | fullpsi))) ) ) {
-      warning(""blavaan WARNING: As specified, the psi covariance matrix is neither diagonal nor unrestricted, so the actual prior might differ from the stated prior. See\n https://arxiv.org/abs/2301.08667"", call. = FALSE)
-    }
-    if( ""theta"" %in% lavpartable$mat && with(covres, !(diagthet | fullthet)) ) {
-      warning(""blavaan WARNING: As specified, the theta covariance matrix is neither diagonal nor unrestricted, so the actual prior might differ from the stated prior. See\n https://arxiv.org/abs/2301.08667"", call. = FALSE)
+    if(!lavoptions$.multilevel) { # because checkcovs() has not been adapted to it
+      if( ""psi"" %in% lavpartable$mat &&
+          ( (target == ""stan"" && !l2s$blkpsi) ||
+            (target != ""stan"" && with(covres, !(diagpsi | fullpsi))) ) ) {
+        warning(""blavaan WARNING: As specified, the psi covariance matrix is neither diagonal nor unrestricted, so the actual prior might differ from the stated prior. See\n https://arxiv.org/abs/2301.08667"", call. = FALSE)
+      }
+      if( ""theta"" %in% lavpartable$mat && with(covres, !(diagthet | fullthet)) ) {
+        warning(""blavaan WARNING: As specified, the theta covariance matrix is neither diagonal nor unrestricted, so the actual prior might differ from the stated prior. See\n https://arxiv.org/abs/2301.08667"", call. = FALSE)
+      }
     }
     
     if(jag.do.fit & lavoptions$warn & !prisamp & !usevb & !grepl(""stan"", target)){"
ecmerkle,blavaan,782c37774e6f262a9d37e1ccc2be6301cf2ad957,ecmerkle,merklee@missouri.edu,2024-04-06T22:50:17Z,ecmerkle,merklee@missouri.edu,2024-04-06T22:50:17Z,throw error for use of sampleData() with two-level model,R/postpred.R,False,True,True,False,1,0,1,"---FILE: R/postpred.R---
@@ -332,6 +332,7 @@ sampleData <- sampledata <- function(object, nrep = NULL, conditional = FALSE, t
   if (is.null(nrep)) nrep <- maxreps
   if (nrep > maxreps) stop(""blavaan ERROR: nrep must be <= total number of posterior samples"")
   if (!blavoptions$do.fit) stop(""blavaan ERROR: to sample data, do.fit must be TRUE"")
+  if (blavoptions$.multilevel) stop(""blavaan ERROR: sampleData() cannot yet sample from two-level models"")
 
   out <- postdata(object, nrep, conditional, type, ...)
 "
ecmerkle,blavaan,70c1e1689532d5b04d29d17eb68f6d25459241f5,ecmerkle,merklee@missouri.edu,2024-03-07T18:31:16Z,ecmerkle,merklee@missouri.edu,2024-03-07T18:31:16Z,fix doc,man/sampleData.Rd,False,False,False,False,1,0,1,"---FILE: man/sampleData.Rd---
@@ -23,6 +23,7 @@ sampleData(object, nrep = NULL, conditional = FALSE, type = ""response"", ...)
   data). The \code{type = ""response""} option generates ordinal data. The
 \code{type = ""link""} option generates continuous variables underlying
 ordinal data (which would be cut by thresholds to yield ordinal data).}
+\item{...}{Other arguments, which for now is only \code{parallel}. Parallelization via \code{future_lapply()} is available by setting \code{parallel = TRUE}.}
 }
 \details{
 This is a convenience function to generate data for posterior or prior"
ecmerkle,blavaan,df6f12fcd09067c06192dbdeafc7c7c195edb743,ecmerkle,merklee@missouri.edu,2024-01-25T03:30:40Z,ecmerkle,merklee@missouri.edu,2024-01-25T03:30:40Z,fix logl computations related to bug from previous commit,DESCRIPTION;inst/stan/stanmarg.stan,False,False,False,False,14,4,18,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-3.1229
+Version: 0.5-3.1230
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: inst/stan/stanmarg.stan---
@@ -2047,8 +2047,11 @@ generated quantities { // these matrices are saved in the output but do not figu
 	for (jj in r1:r2) {
 	  log_lik[jj] = multi_normal_suff(YXstar[jj, 1:Nobs[mm]], zmat[1:Nobs[mm], 1:Nobs[mm]], Mu[grpidx, obsidx[1:Nobs[mm]]], Sigmainv[mm], 1);
 
-	  if (Nx[mm] > 0) {
+	  // TODO efficiency can be improved by getting inverse/chol of Sigma outside loop
+	  if (Nx[mm] > 0 && !missing) {
 	    log_lik[jj] += -multi_normal_suff(YXstar[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigmainv[grpidx], xidx, Nx[mm], p + q, logdetSigma_grp[grpidx]), 1);
+	  } else if (Nx[mm] > 0) {
+	    log_lik[jj] += -multi_normal_lpdf(YXstar[jj, xdatidx[1:Nx[mm]]] | Mu[grpidx, xidx[1:Nx[mm]]], Sigma[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
 	  }
 	}
       }
@@ -2110,19 +2113,26 @@ generated quantities { // these matrices are saved in the output but do not figu
 	  r1 = startrow[mm];
 	  r2 = endrow[mm];
 	  for (jj in r1:r2) {
+	    // log_lik_rep, _sat, _rep_sat
 	    log_lik_rep[jj] = multi_normal_suff(YXstar_rep[jj, 1:Nobs[mm]], zmat[1:Nobs[mm], 1:Nobs[mm]], Mu[grpidx, obsidx[1:Nobs[mm]]], Sigmainv[mm], 1);
 
 	    log_lik_sat[jj] = multi_normal_suff(YXstar[jj, 1:Nobs[mm]], zmat[1:Nobs[mm], 1:Nobs[mm]], Mu_sat[grpidx, obsidx[1:Nobs[mm]]], Sigma_sat_inv[mm], 1);	
 
 	    log_lik_rep_sat[jj] = multi_normal_suff(YXstar_rep[jj, 1:Nobs[mm]], zmat[1:Nobs[mm], 1:Nobs[mm]], Mu_rep_sat[grpidx, obsidx[1:Nobs[mm]]], Sigma_rep_sat_inv[mm], 1);
 	    
-	    // log_lik_sat, log_lik_sat_rep
-	    if (Nx[mm] > 0) {
+	    // TODO efficiency can be improved by getting inverse/chol of Sigma outside loop
+	    if (Nx[mm] > 0 && !missing) {
 	      log_lik_rep[jj] += -multi_normal_suff(YXstar_rep[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigmainv[grpidx], xidx, Nx[mm], p + q, logdetSigma_grp[grpidx]), 1);
 	    
 	      log_lik_sat[jj] += -multi_normal_suff(YXstar[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu_sat[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigma_sat_inv[grpidx], xidx, Nx[mm], p + q, logdetS_sat_grp[grpidx]), 1);
 	      
 	      log_lik_rep_sat[jj] += -multi_normal_suff(YXstar_rep[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu_rep_sat[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigma_rep_sat_inv[grpidx], xidx, Nx[mm], p + q, logdetS_rep_sat_grp[grpidx]), 1);
+	    } else if (Nx[mm] > 0) {
+	      log_lik_rep[jj] += -multi_normal_lpdf(YXstar_rep[jj, xdatidx[1:Nx[mm]]] | Mu[grpidx, xidx[1:Nx[mm]]], Sigma[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
+	    
+	      log_lik_sat[jj] += -multi_normal_lpdf(YXstar[jj, xdatidx[1:Nx[mm]]] | Mu_sat[grpidx, xidx[1:Nx[mm]]], Sigma_sat[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
+	      
+	      log_lik_rep_sat[jj] += -multi_normal_lpdf(YXstar_rep[jj, xdatidx[1:Nx[mm]]] | Mu_rep_sat[grpidx, xidx[1:Nx[mm]]], Sigma_rep_sat[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
 	    }
 	  }
 	  "
ecmerkle,blavaan,047c484dbb23c1a36bad1d898765b78604346797,ecmerkle,merklee@missouri.edu,2024-01-24T22:42:27Z,ecmerkle,merklee@missouri.edu,2024-01-24T22:42:27Z,"fix bug in models with fixed.x ovs and missing data, which leads to nonconvergence",DESCRIPTION;NEWS.md;inst/stan/stanmarg.stan,False,False,False,False,8,3,11,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-3
+Version: 0.5-3.1229
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: NEWS.md---
@@ -13,6 +13,9 @@
 
 * Bugs from 0.5-2 are fixed.
 
+## Bugs/glitches discovered after the release:
+* Some models with exogenous covariates, fixed.x=TRUE, and missing data fail to converge and yield implausible parameter values (reported by DeAnne Hunter).
+
 
 # Version 0.5-2
 ## New features

---FILE: inst/stan/stanmarg.stan---
@@ -1538,8 +1538,10 @@ model { // N.B.: things declared in the model block do not get saved in the outp
 	// sufficient stats
 	target += multi_normal_suff(YXbarstar[mm, 1:Nobs[mm]], Sstar[mm, 1:Nobs[mm], 1:Nobs[mm]], Mu[grpidx, obsidx[1:Nobs[mm]]], Sigmainv[mm, 1:(Nobs[mm] + 1), 1:(Nobs[mm] + 1)], r2 - r1 + 1);
       
-	if (Nx[mm] > 0) {
-	  target += -multi_normal_suff(YXbarstar[mm, xdatidx[1:Nx[mm]]], Sstar[mm, xdatidx[1:Nx[mm]], xdatidx[1:Nx[mm]]], Mu[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigmainv[grpidx], xidx, Nx[mm], p + q, logdetSigma_grp[grpidx]), r2 - r1 + 1);
+	if (Nx[mm] > 0 && !missing) {
+	  target += -multi_normal_suff(YXbarstar[mm, xdatidx[1:Nx[mm]]], Sstar[mm, xdatidx[1:Nx[mm]], xdatidx[1:Nx[mm]]], Mu[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigmainv[mm], xidx, Nx[mm], p + q, logdetSigma_grp[grpidx]), r2 - r1 + 1);
+	} else if (Nx[mm] > 0) {
+	  target += -multi_normal_lpdf(YXstar[r1:r2,xdatidx[1:Nx[mm]]] | Mu[grpidx, xidx[1:Nx[mm]]], Sigma[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
 	}
       }
     }"
ecmerkle,blavaan,3eefcfa2d1243a4439bfe2fab822f05eff96e6c7,ecmerkle,merklee@missouri.edu,2024-01-08T16:06:43Z,ecmerkle,merklee@missouri.edu,2024-01-08T16:06:43Z,fix encoding of Rd file,man/blavCompare.Rd,False,False,False,False,1,1,2,"---FILE: man/blavCompare.Rd---
@@ -32,7 +32,7 @@ and differences between WAIC and LOOIC.
 \references{
 Raftery, A. E. (1993). Bayesian model selection in structural equation models. In K. A. Bollen & J. S. Long (Eds.), Testing structural equation models (pp. 163-180). Beverly Hills, CA: Sage.
 
-Vehtari A, Gelman A, Gabry J (2017). Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC. _Statistics and Computing_, *27*, 1413-1432.
+Vehtari A., Gelman A., Gabry J. (2017). Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC. Statistics and Computing, 27, 1413-1432.
 }
 \examples{
 \dontrun{"
ecmerkle,blavaan,15ba2ffe58a6c86cf24da259f61a4761369b3089,ecmerkle,merklee@missouri.edu,2024-01-05T19:55:30Z,ecmerkle,merklee@missouri.edu,2024-01-05T19:55:30Z,update test models and fix a vignette,inst/testdata/sysdata.rda;vignettes/probability_direction.Rmd,True,False,True,False,3,3,6,"---FILE: vignettes/probability_direction.Rmd---
@@ -86,12 +86,12 @@ library(brms)
 Ans we will need to extract the posterior draws a matrix, 
 
 ```{r, eval=T}
-mc_out <- as.matrix(blavInspect(fit, ""mcmc""))
+mc_out <- as.matrix(blavInspect(fit, ""mcmc"", add.labels = FALSE))
 dim(mc_out)
 colnames(mc_out)
 ```
 
-It is also important to note that the parameters in the posterior draws are named after the ```Stan``` underlying object names, instead of the ```(b)lavaan``` parameter names. You can see what each parameter name equates to with ```partable()``` function, as follows
+It is also important to note that the parameters in the posterior draws are named after the ```Stan``` underlying object names, instead of the ```(b)lavaan``` parameter names. This is due to the argument `add.labels = FALSE` and is used here to avoid trouble with parameter names that have tildes or equal signs in them. You can see what each parameter name equates to with the ```partable()``` function, as follows
 
 ```{r}
 pt <- partable(fit)[,c(""lhs"",""op"",""rhs"",""pxnames"")]
@@ -104,7 +104,7 @@ For this example we will focus on the regressions between factors
 pt[pt$op==""~"",]
 ```
 
-Now, we can calculate pd, with the ```hypothesis()``` function from ```brms``` we can ask specific question of the posterior distributions, for example if we want to know what proportion of the regression ```dem65~ind60``` is higher than 0. The function requires 2 arguments, the posterior draws (```mc_out```) and a hypothesis (```bet_sign[2] > 0```), we are also adding the ``alpha``` argument that specifies the size for the credible intervals
+Now, we can calculate pd, with the ```hypothesis()``` function from ```brms```. We can ask specific questions of the posterior distributions, for example if we want to know what proportion of the regression ```dem65~ind60``` is higher than 0. The function requires 2 arguments, the posterior draws (```mc_out```) and a hypothesis (```bet_sign[2] > 0```). We are also adding the ``alpha``` argument that specifies the size for the credible intervals
 
 ```{r}
 hypothesis(mc_out, ""bet_sign[2] > 0"", alpha = 0.05)"
ecmerkle,blavaan,8fe9973c61295ef176083d274c1914248229baff,ecmerkle,merklee@missouri.edu,2024-01-05T18:33:17Z,ecmerkle,merklee@missouri.edu,2024-01-05T18:33:17Z,fix inits of free individual correlations,R/lav_export_stanmarg.R,False,True,True,False,1,1,2,"---FILE: R/lav_export_stanmarg.R---
@@ -623,7 +623,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
       fpars <- res$wskel[1:veclen,1] == 0 | res$wskel[1:veclen,3] == 1
       nfree <- c(nfree, list(sum(fpars)))
       names(nfree)[length(nfree)] <- 'lvrho'
-      freeparnums[ptrows[fpars]] <- 1:sum(fpars)
+      freeparnums[twsel][ptrows[fpars]] <- 1:sum(fpars)
     }
 
     ## repeated for all free cov entries including blocks"
ecmerkle,blavaan,c63c30191ec123eeaf725e4f9f9b4c8b634113a5,ecmerkle,merklee@missouri.edu,2024-01-03T15:41:29Z,ecmerkle,merklee@missouri.edu,2024-01-03T15:41:29Z,"add initial values for psi blocks, fix bsem doc",DESCRIPTION;R/lav_export_stanmarg.R;man/bsem.Rd,False,True,True,False,10,3,13,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-2.1210
+Version: 0.5-2.1211
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lav_export_stanmarg.R---
@@ -830,7 +830,14 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
       ## (needed because set_inits_stan() is also used for stanclassic and stancond targets
       if (""Theta_r_free"" %in% names(ini[[i]])) ini[[i]]$Theta_r_free <- -1 + 2 * ini[[i]]$Theta_r_free
       if (""Psi_r_free"" %in% names(ini[[i]])) ini[[i]]$Psi_r_free <- -1 + 2 * ini[[i]]$Psi_r_free
-        
+
+      if (any(dat$nblk > 0)) {
+        for (j in 1:sum(dat$nblk > 0)) {
+          tmpmat <- array(diag(dat$psidims[j]), c(dat$psidims[j], dat$psidims[j], dat$nblk[j]))
+          ini[[i]][[paste0(""Psi_r_mat_"", j)]] <- aperm(tmpmat, c(3, 1, 2))
+        }
+      }
+      
       if (level == 2L) {
         names(ini[[i]]) <- paste0(names(ini[[i]]), ""_c"")
       } else {

---FILE: man/bsem.Rd---
@@ -143,7 +143,7 @@ model <- '
     y6 ~~ y8
 '
 
-## unique priors for mv intercepts; parallel chains
+## unique priors for mv intercepts
 fit <- bsem(model, data=PoliticalDemocracy,
             dp=dpriors(nu=""normal(5,10)""))
 summary(fit)"
ecmerkle,blavaan,d4b2da3390332bca9d456e24c9d2bfa8db3f92aa,ecmerkle,merklee@missouri.edu,2024-01-01T21:46:13Z,ecmerkle,merklee@missouri.edu,2024-01-01T21:46:13Z,fix psi_r indexing for extracting posterior estimates,DESCRIPTION;R/lav_export_stanmarg.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-2.1209
+Version: 0.5-2.1210
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lav_export_stanmarg.R---
@@ -617,7 +617,6 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
     dat$Psi_r_skeleton <- res$matskel
     dat$w10skel <- res$wskel
     dat$psi_r_sign <- res$sign
-    free2 <- c(free2, list(rpsi = res$free))
     ptrows <- with(lavpartable[twsel, , drop = FALSE], which(mat == ""psi"" & free > 0 & row != col))
     veclen <- length(ptrows)
     if (veclen > 0) {
@@ -636,6 +635,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
                    free1 = free2$lambda, free2 = lyfree2, sign = dat$lam_y_sign,
                    dest = dest)
 
+    free2 <- c(free2, list(rpsi = res$free))
     dat$Psi_r_skeleton_f <- res$matskel
     dat$w11skel <- res$wskel
     dat$psi_r_sign_f <- res$sign"
ecmerkle,blavaan,5b71179377a570fb8f88728996abfa0a318b083c,ecmerkle,merklee@missouri.edu,2023-12-21T04:18:17Z,ecmerkle,merklee@missouri.edu,2023-12-21T04:18:17Z,fix false alarm about non-block-diagonal psi,DESCRIPTION;R/lav_export_stanmarg.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-2.1207
+Version: 0.5-2.1208
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lav_export_stanmarg.R---
@@ -561,7 +561,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
     ## a separate parameter specification in Stan
     if (length(ublksizes) > 5 | length(ublksizes) == 0) {
       blkinfo <- NULL
-      blkpsi <- FALSE
+      if (length(ublksizes) > 5) blkpsi <- FALSE
       dat$nblk <- array(0, dim = 5)
       dat$psidims <- array(3, dim = 5)
       dat$blkse <- matrix(nrow = 0, ncol = 7)"
ecmerkle,blavaan,cc89ddde2e57901744a618dce839a0a31bc75b06,ecmerkle,merklee@missouri.edu,2023-12-21T03:06:55Z,ecmerkle,merklee@missouri.edu,2023-12-21T03:06:55Z,fix variable names,DESCRIPTION;R/blav_compare.R,False,True,True,False,3,3,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-2.1205
+Version: 0.5-2.1207
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_compare.R---
@@ -17,7 +17,7 @@ blavCompare <- function(object1, object2, ...) {
   if(targ1 == ""stan"" && blavInspect(object1, ""meanstructure"")){
     ll1 <- loo::extract_log_lik(object1@external$mcmcout)
   } else if(blavInspect(object1, ""categorical"") && lavopt1$test != ""none""){
-    if(""llnsamp"" %in% names(lavopt)){
+    if(""llnsamp"" %in% names(lavopt1)){
       cat(""blavaan NOTE: These criteria involve likelihood approximations that may be imprecise.\n"",
           ""You could try running the model again to see how much the criteria fluctuate.\n"",
           ""You can also manually set llnsamp for greater accuracy (but also greater runtime).\n\n"")
@@ -36,7 +36,7 @@ blavCompare <- function(object1, object2, ...) {
   if(targ2 == ""stan"" && blavInspect(object2, ""meanstructure"")){
     ll2 <- loo::extract_log_lik(object2@external$mcmcout)
   } else if(blavInspect(object2, ""categorical"") && lavopt2$test != ""none""){
-    if(""llnsamp"" %in% names(lavopt)){
+    if(""llnsamp"" %in% names(lavopt2)){
       cat(""blavaan NOTE: These criteria involve likelihood approximations that may be imprecise.\n"",
           ""You could try running the model again to see how much the criteria fluctuate.\n"",
           ""You can also manually set llnsamp for greater accuracy (but also greater runtime).\n\n"")"
ecmerkle,blavaan,d8923483af3fb47bc8141d432c3cc99addb044e6,ecmerkle,merklee@missouri.edu,2023-12-20T19:43:17Z,ecmerkle,merklee@missouri.edu,2023-12-20T19:43:17Z,"fix for equality constraints via == using target=""stan""",DESCRIPTION;NEWS.md;R/lav_export_stanmarg.R,False,True,True,False,4,2,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-2.1204
+Version: 0.5-2.1205
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: NEWS.md---
@@ -9,6 +9,8 @@
 
 * models with both continuous and ordinal variables fail for cases where all ordinal variables are missing (reported by Sonja Winter).
 
+* certain equality constraints involving named parameters fail for target=""stan"" (reported by Niels Skovgaard-Olsen)
+
 # Version 0.5-1
 ## New features
 * Two-level models are now supported (for complete, continuous data) via the cluster argument.

---FILE: R/lav_export_stanmarg.R---
@@ -806,7 +806,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
   }
 
   ## remove priors from equality-constrained parameters
-  rmpri <- !(lavpartable$prior == """") & (lavpartable$plabel %in% lavpartable$rhs[lavpartable$op == ""==""])
+  rmpri <- !(lavpartable$prior == """") & ((lavpartable$plabel %in% lavpartable$rhs[lavpartable$op == ""==""]) | (lavpartable$label %in% lavpartable$rhs[lavpartable$op == ""==""]))
   lavpartable$prior[rmpri] <- """"
   
   ## add priors to wiggle params (mean value is handled in stan)"
ecmerkle,blavaan,81ec47ba77952b371d7f8d84b349f3702ed8f120,ecmerkle,merklee@missouri.edu,2023-12-13T23:01:53Z,ecmerkle,merklee@missouri.edu,2023-12-13T23:01:53Z,add drop = FALSE to avoid error in ordinal missing data,DESCRIPTION;R/lav_export_stanmarg.R,False,True,True,False,3,3,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-2.1202
+Version: 0.5-2.1203
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lav_export_stanmarg.R---
@@ -1318,8 +1318,8 @@ lav2standata <- function(lavobject) {
     dat$YXo <- dat$YX[, ordidx, drop=FALSE]
     if (misflag) {
       dat$Noent <- sum(dat$YXo > 0)
-      dat$Nordobs <- do.call(""c"", lapply(Mp, function(x) rowSums(x$pat[,ordidx])))
-      OrdObsvar <- do.call(""c"", lapply(Mp, function(x) apply(x$pat[,ordidx], 1, which, simplify = FALSE)))
+      dat$Nordobs <- do.call(""c"", lapply(Mp, function(x) rowSums(x$pat[, ordidx, drop = FALSE])))
+      OrdObsvar <- do.call(""c"", lapply(Mp, function(x) apply(x$pat[, ordidx, drop = FALSE], 1, which, simplify = FALSE)))
 
       dat$OrdObsvar <- matrix(0, dat$Np, ncol(dat$YXo))
       allvars <- 1:ncol(dat$YXo)"
ecmerkle,blavaan,038949391d361bc944260d9ad407e5e51f3f3b58,ecmerkle,merklee@missouri.edu,2023-12-05T21:38:57Z,ecmerkle,merklee@missouri.edu,2023-12-05T21:38:57Z,"fix multigroup, multilevel data setup",DESCRIPTION;R/lav_export_stanmarg.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-2.1201
+Version: 0.5-2.1202
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lav_export_stanmarg.R---
@@ -1248,7 +1248,7 @@ lav2standata <- function(lavobject) {
     dat$cov_d <- cov_d
     ## this evenly distributes loglik.x across unique cluster sizes; sums to correct value
     llx <- sapply(YLp, function(x) x[[2]]$loglik.x)
-    dat$log_lik_x <- array(rep(llx / dat$ncluster_sizes, dat$ncluster_sizes), dat$ncluster_sizes)
+    dat$log_lik_x <- array(rep(llx / dat$ncluster_sizes, dat$ncluster_sizes), sum(dat$ncluster_sizes))
 
     ## clusterwise data summaries, for loo and waic and etc
     cidx <- lavInspect(lavobject, 'cluster.idx')"
ecmerkle,blavaan,f76229a6d2c2469abe8aee54a8c42d462bb6360b,ecmerkle,merklee@missouri.edu,2023-12-05T21:22:09Z,ecmerkle,merklee@missouri.edu,2023-12-05T21:22:09Z,"two-level, fix handling of within-only ovs",DESCRIPTION;R/lav_export_stanmarg.R;inst/stan/stanmarg.stan,False,True,True,False,2,10,12,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-2.1200
+Version: 0.5-2.1201
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lav_export_stanmarg.R---
@@ -1261,11 +1261,7 @@ lav2standata <- function(lavobject) {
       cidx <- unlist(cidx)
     }
     mean_d_full <- rowsum.default(as.matrix(dat$YX), cidx) / dat$cluster_size
-    if (dat$N_within > 0) {
-      for (i in 1:dat$N_within) {
-        mean_d_full[, dat$within_idx[i]] <- mean(as.matrix(dat$YX)[, dat$within_idx[i]])
-      }
-    }
+
     tmpYX <- split.data.frame(dat$YX, cidx)
     dat$YX <- do.call(""rbind"", tmpYX)
     dat$log_lik_x_full <- llx_2l(Lp[[1]], dat$YX, mean_d_full, cidx)

---FILE: inst/stan/stanmarg.stan---
@@ -1841,10 +1841,6 @@ generated quantities { // these matrices are saved in the output but do not figu
 	  }
 	  
 	  for (cc in 1:nclus[gg, 2]) {
-	    if (N_within > 0) {
-	      mean_d_rep[clusidx, within_idx] = ov_mean_rep[gg, within_idx];
-	    }
-
 	    for (ii in r1:(r1 + cluster_size[clusidx] - 1)) {
 	      S_PW_rep_full[gg] += tcrossprod(to_matrix(YXstar_rep[ii] - mean_d_rep[clusidx]));
 	    }"
ecmerkle,blavaan,64a388cc9ad732847bf10731cf0eb0a14efba64d,ecmerkle,merklee@missouri.edu,2023-11-29T21:37:40Z,ecmerkle,merklee@missouri.edu,2023-11-29T21:37:40Z,fix issue with multilevel Psi covariances,DESCRIPTION;inst/stan/stanmarg.stan,False,False,False,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-2.1195
+Version: 0.5-2.1197
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: inst/stan/stanmarg.stan---
@@ -1669,7 +1669,7 @@ generated quantities { // these matrices are saved in the output but do not figu
   vector[len_free_c[7]] Theta_cov_c;
   vector[len_free_c[5]] Theta_var_c;
   vector[len_free_c[10]] P_r_c;
-  vector[len_free_c[10]] Psi_cov_c;
+  vector[len_free_c[11]] Psi_cov_c;
   vector[len_free_c[9]] Psi_var_c;
 
   // loglik + ppp"
ecmerkle,blavaan,8c801fff8a252e00a634a751fea005bc57ed4863,ecmerkle,merklee@missouri.edu,2023-11-29T04:15:51Z,ecmerkle,merklee@missouri.edu,2023-11-29T04:15:51Z,fix incompatiable vector dimensions,R/blav_model_loglik.R,False,True,True,False,1,1,2,"---FILE: R/blav_model_loglik.R---
@@ -594,7 +594,7 @@ llx_2l <- function(Lp, YX, mean_d, cidx){
   } else {
     loglik.x.b <- rep(0, nrow(mean_d))
   }
-  loglik.x <- loglik.x.w.clus + loglik.x.b
+  loglik.x <- loglik.x.w.clus + as.numeric(loglik.x.b)
 
   array(loglik.x, length(loglik.x))
 }"
ecmerkle,blavaan,17c904bb8b728958bdbdaac478ae1004d3bdb444,ecmerkle,merklee@missouri.edu,2023-11-02T18:04:22Z,ecmerkle,merklee@missouri.edu,2023-11-02T18:04:22Z,fix monitors for moment matching,DESCRIPTION;R/blavaan.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-2.1192
+Version: 0.5-2.1193
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blavaan.R---
@@ -613,7 +613,7 @@ blavaan <- function(...,  # default lavaan arguments
                     ## FIXME these do not cover level 2 parameters
                     moment_match_monitors <- c(""Lambda_y_free"", ""B_free"", 
                         ""Theta_sd_free"", ""Theta_r_free"", ""Psi_sd_free"", 
-                        ""Psi_r_mat"", ""Psi_r_free"", ""Nu_free"", ""Alpha_free"")
+                        paste0(""Psi_r_mat_"", 1:5), ""Psi_r_free"", ""Nu_free"", ""Alpha_free"")
                     moment_match_monitors <- c(moment_match_monitors,
                                                paste0(moment_match_monitors, ""_c""))
                     moment_match_monitors <- c(moment_match_monitors, ""Tau_ufree"", "
ecmerkle,blavaan,28befbac1147adf9092fa8a0c0fa318b1b0f73fb,ecmerkle,merklee@missouri.edu,2023-10-31T15:44:37Z,ecmerkle,merklee@missouri.edu,2023-10-31T15:44:37Z,avoid error if redundant priors are supplied for equality-constrained parameters,DESCRIPTION;R/stanmarg_data.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-2.1188
+Version: 0.5-2.1189
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/stanmarg_data.R---
@@ -123,7 +123,7 @@ format_priors <- function(lavpartable, level = 1L) {
       prisel <- prisel & (lavpartable$mat == mat)
     }
   
-    prisel <- prisel & (lavpartable$free > 0)
+    prisel <- prisel & (lavpartable$free > 0) & !(lavpartable$plabel %in% lavpartable$rhs[lavpartable$op == ""==""])
     thepris <- lavpartable$prior[prisel]
 
     if (length(thepris) > 0) {"
ecmerkle,blavaan,5e1ce87a0c3c9cb484d7d86cbd15bf651dec0e0e,ecmerkle,merklee@missouri.edu,2023-10-24T14:53:17Z,ecmerkle,merklee@missouri.edu,2023-10-24T14:53:17Z,fix prior translation from stan to R,R/blav_utils.R,False,True,True,False,3,2,5,"---FILE: R/blav_utils.R---
@@ -158,6 +158,7 @@ dist2r <- function(priors, target){
         rosetta <- rosetta
         prisplit <- strsplit(priors, ""[, ()]+"")
         pridist <- sapply(prisplit, function(x) x[1])
+        pridist <- paste0(pridist, ""_lpdf"")
         newdist <- rosetta$RFunction[match(pridist, rosetta$StanFunction)]
         for(i in 1:length(newdist)){
             if(!is.na(newdist[i])) prisplit[[i]][1] <- newdist[i]
@@ -452,7 +453,7 @@ blkdiag <- function(mat, eqcon = NULL) {
       othend <- sapply((cnum + 1):currend, function(i) {
         nzents <- which(mat[,i] > 0)
         if (length(nzents) > 0) {
-          out <- max(nzents)
+          out <- max(nzents, i)
         } else {
           out <- i
         }
@@ -481,7 +482,7 @@ blkdiag <- function(mat, eqcon = NULL) {
     cnum <- currend + 1
   }
 
-  blkse <- blkse[1:nblks, , drop = FALSE]
+  if (nrow(blkse) > 0) blkse <- blkse[1:nblks, , drop = FALSE]
   
   list(isblk = isblk, nblks = nblks, blkse = blkse)
 }"
ecmerkle,blavaan,f8a43106842193ab6c52c95bdd99a6ecdc76d27d,ecmerkle,merklee@missouri.edu,2023-10-18T17:36:55Z,ecmerkle,merklee@missouri.edu,2023-10-18T17:36:55Z,fixes #67,DESCRIPTION;R/lav_export_stanmarg.R,False,True,True,False,3,3,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-2.1183
+Version: 0.5-2.1185
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lav_export_stanmarg.R---
@@ -112,7 +112,7 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, wig, ...) {
             lampar12 <- lamfree2[[i]][,fpar[j,2]]
             ## see whether any are equality constrained
             l1match <- match(lampar1, constraint$rhs, nomatch = 0L)
-            transconst <- transtab[match(constraint$lhs[l1match], transtab[,1]), 2]
+            transconst <- transtab[match(constraint$lhs[l1match], transtab[,1]), 2*i]
             lampar12[l1match != 0] <- as.numeric(transconst)
             if (all(lampar12 == 0)) { # ov converted to lv
               l1 <- 1
@@ -127,7 +127,7 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, wig, ...) {
             lampar2 <- lamfree[[i]][,fpar[j,1]]
             lampar22 <- lamfree2[[i]][,fpar[j,1]]
             l2match <- match(lampar2, constraint$rhs, nomatch = 0L)
-            transconst <- transtab[match(constraint$lhs[l2match], transtab[,1]), 2]
+            transconst <- transtab[match(constraint$lhs[l2match], transtab[,1]), 2*i]
             lampar22[l2match != 0] <- as.numeric(transconst)
             if (all(lampar22 == 0)) {
               l2 <- 1"
ecmerkle,blavaan,9bf1257aab282ba3d9759ecb1bc265b13521e753,ecmerkle,merklee@missouri.edu,2023-10-06T16:22:15Z,ecmerkle,merklee@missouri.edu,2023-10-06T16:22:15Z,fix blavCompare() for meanstructure = FALSE,DESCRIPTION;NEWS.md;R/blav_compare.R,False,True,True,False,21,7,28,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-2
+Version: 0.5-2.1183
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: NEWS.md---
@@ -2,6 +2,9 @@
 ## New features
 * This is a maintenance release, primarily adding the new array declaration syntax in Stan models (syntax that became available in the new version of rstan).
 
+## Bugs/glitches discovered after the release:
+* blavCompare() does not work with models that have meanstructure = FALSE (reported by Pedro Ribeiro).
+
 # Version 0.5-1
 ## New features
 * Two-level models are now supported (for complete, continuous data) via the cluster argument.

---FILE: R/blav_compare.R---
@@ -14,11 +14,15 @@ blavCompare <- function(object1, object2, ...) {
   res <- c(bf, object1@test[[1]]$stat, object2@test[[1]]$stat)
   names(res) <- c(""bf"", ""mll1"", ""mll2"")
   
-  ## FIXME? We already get case_lls in blav_fit_measures and should really
-  ## only do it once. But, if we store it in the blavaan object, the size
-  ## of that object can get much larger.
-  if(targ1 == ""stan""){
+  if(targ1 == ""stan"" && blavInspect(object1, ""meanstructure"")){
     ll1 <- loo::extract_log_lik(object1@external$mcmcout)
+  } else if(blavInspect(object1, ""categorical"") && lavopt1$test != ""none""){
+    if(""llnsamp"" %in% names(lavopt)){
+      cat(""blavaan NOTE: These criteria involve likelihood approximations that may be imprecise.\n"",
+          ""You could try running the model again to see how much the criteria fluctuate.\n"",
+          ""You can also manually set llnsamp for greater accuracy (but also greater runtime).\n\n"")
+    }
+    ll1 <- object1@external$casells
   } else {
     lavopt1$estimator <- ""ML""
     ll1 <- case_lls(object1@external$mcmcout, make_mcmc(object1@external$mcmcout),
@@ -29,13 +33,20 @@ blavCompare <- function(object1, object2, ...) {
   cid1 <- rep(1:nchain1, each=niter1)
   ref1 <- relative_eff(exp(ll1), chain_id = cid1)
 
-  if(targ2 == ""stan""){
+  if(targ2 == ""stan"" && blavInspect(object2, ""meanstructure"")){
     ll2 <- loo::extract_log_lik(object2@external$mcmcout)
+  } else if(blavInspect(object2, ""categorical"") && lavopt2$test != ""none""){
+    if(""llnsamp"" %in% names(lavopt)){
+      cat(""blavaan NOTE: These criteria involve likelihood approximations that may be imprecise.\n"",
+          ""You could try running the model again to see how much the criteria fluctuate.\n"",
+          ""You can also manually set llnsamp for greater accuracy (but also greater runtime).\n\n"")
+    }
+    ll2 <- object2@external$casells
   } else {
     lavopt2$estimator <- ""ML""
     ll2 <- case_lls(object2@external$mcmcout, make_mcmc(object2@external$mcmcout),
                     object2)
-  }
+  }  
   nchain2 <- blavInspect(object1, ""n.chains"")
   niter2 <- nrow(ll2)/nchain2
   cid2 <- rep(1:nchain2, each=niter2)"
ecmerkle,blavaan,02ebd520c71041c16056894d1452c2849703e944,ecmerkle,merklee@missouri.edu,2023-09-25T18:02:34Z,ecmerkle,merklee@missouri.edu,2023-09-25T18:02:34Z,fix warnings from cran check,NAMESPACE;R/lav_export_stanmarg.R,False,True,True,False,3,3,6,"---FILE: NAMESPACE---
@@ -12,7 +12,7 @@ importFrom(""stats"",
            ""runif"", ""sd"", ""quantile"", ""rWishart"", ""cov"", ""cor"",
            ""coef"", ""logLik"",
            ""residuals"", ""resid"",
-           ""fitted.values"", ""fitted"",
+           ""fitted.values"", ""fitted"", ""na.omit"",
            ""predict"",
            ""update"",
            ""anova"",

---FILE: R/lav_export_stanmarg.R---
@@ -230,9 +230,9 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
   levlabs <- blav_partable_level_values(lavpartable)
   lavpartable <- lavMatrixRepresentation(lavpartable, add.attributes = TRUE)
   if (multilevel & level == 1L) {
-    lavpartable <- subset(lavpartable, (level == levlabs[1]) | (op %in% c(""=="", "":="")))
+    lavpartable <- subset(lavpartable, (lavpartable$level == levlabs[1]) | (lavpartable$op %in% c(""=="", "":="")))
   } else if (multilevel & level == 2L) {
-    lavpartable <- subset(lavpartable, (level == levlabs[2]) | (op %in% c(""=="", "":="")))
+    lavpartable <- subset(lavpartable, (lavpartable$level == levlabs[2]) | (lavpartable$op %in% c(""=="", "":="")))
   } else if (level == 2L) {
     lavpartable <- lavpartable[0,]
   }"
ecmerkle,blavaan,2c5d6f3723d247ce4146a7c6a89084336775638a,ecmerkle,merklee@missouri.edu,2023-09-21T15:51:52Z,ecmerkle,merklee@missouri.edu,2023-09-21T15:51:52Z,"target=""jags"", fix lv extraction via blavInspect()",DESCRIPTION;NEWS.md;R/blav_object_inspect.R,False,True,True,False,4,2,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.5-1.1172
+Version: 0.5-1.1175
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: NEWS.md---
@@ -3,8 +3,9 @@
 * Two-level models are now supported (for complete, continuous data) via the cluster argument.
 
 ## Bugs/glitches discovered after the release:
-* For two-level model specification, the levels have to be labeled ""within"" and ""between"". This is more restrictive than lavaan.
+* For two-level model specification, the levels have to be labeled ""within"" and ""between"". This is more restrictive than lavaan specification.
 
+* For target=""jags"", latent variable extraction via blavInspect(, ""lvs"") fails (reported by Joseph Saraceno).
 
 # Version 0.4-8
 ## New features

---FILE: R/blav_object_inspect.R---
@@ -130,6 +130,7 @@ blavInspect <- function(blavobject, what, ...) {
             draws <- make_mcmc(blavobject@external$mcmcout, blavobject@external$stanlvs)
 
             if(jagtarget){
+                drawcols <- grep(""^eta\\["", colnames(draws[[1]]))
                 ## remove phantoms
                 drawcols <- drawcols[1:(nlv * nsamp)]
             } else {"
ecmerkle,blavaan,95c4c62f2b38adac1fabd9e192c2b2118c0d3028,ecmerkle,merklee@missouri.edu,2023-08-29T20:21:09Z,ecmerkle,merklee@missouri.edu,2023-08-29T20:21:09Z,fix vignette refs,vignettes/multilevel.Rmd,True,False,True,False,2,0,2,"---FILE: vignettes/multilevel.Rmd---
@@ -1,5 +1,7 @@
 ---
 title: ""Two-level SEM""
+bibliography:
+  - refs.bib
 ---
 
 ```{r echo=FALSE, message=FALSE}"
ecmerkle,blavaan,47a326be4fe2b150497806a4b1d895e326efbc40,ecmerkle,merklee@missouri.edu,2023-08-28T21:03:22Z,ecmerkle,merklee@missouri.edu,2023-08-28T21:03:22Z,fix argument,R/lav_export_stanmarg.R,False,True,True,False,1,1,2,"---FILE: R/lav_export_stanmarg.R---
@@ -972,7 +972,7 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, dmnames
     }
     lavpartable <- c(lavpartable, list(mat = olpt$mat, row = olpt$row, col = olpt$col))
   } else {
-    lavpartable <- lavMatrixRepresentation(lavpartable, add.attributes = TRUE, as.data.frame = FALSE)
+    lavpartable <- lavMatrixRepresentation(lavpartable, add.attributes = TRUE, as.data.frame. = FALSE)
   } 
   
   list(x = lavpartable$est[lavpartable$free > 0],"
ecmerkle,blavaan,a9881ca11cef5f941bff3dc64a8422b36d72d2b3,ecmerkle,merklee@missouri.edu,2023-08-28T20:09:06Z,ecmerkle,merklee@missouri.edu,2023-08-28T20:09:06Z,fix summary method,DESCRIPTION;R/blav_object_methods.R,False,True,True,False,6,4,10,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-9.1161
+Version: 0.4-9.1162
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_object_methods.R---
@@ -127,9 +127,11 @@ function(object, header       = TRUE,
         }
         PE$group[PE$group == 0] <- 1
 
-        if(object@call$target == ""vb"") {
-            attributes(PE)$information <- ""VB""
-            attributes(PE)$se <- ""VB""
+        if(""target"" %in% names(object@call)){
+            if(object@call$target == ""vb""){
+                attributes(PE)$information <- ""VB""
+                attributes(PE)$se <- ""VB""
+            }
         } else {
             attributes(PE)$information <- ""MCMC""
             attributes(PE)$se <- ""MCMC"""
ecmerkle,blavaan,4307b8913a6cde9c6060cd2bcbedeca171f81b30,ecmerkle,merklee@missouri.edu,2023-08-24T03:25:04Z,ecmerkle,merklee@missouri.edu,2023-08-24T03:25:04Z,fix a previous commit that broke single-level models,DESCRIPTION;R/lav_export_stanmarg.R,False,True,True,False,3,2,5,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-9.1154
+Version: 0.4-9.1155
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lav_export_stanmarg.R---
@@ -772,10 +772,11 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
   }
 
   ## index of dummy lvs, for sampling lvs
+  dumlv <- NULL
   if (level == 1L) {
     dumlv <- c(lavobject@Model@ov.x.dummy.lv.idx[[1]],
                lavobject@Model@ov.y.dummy.lv.idx[[1]])
-  } else {
+  } else if (multilevel) {
     dumlv <- c(lavobject@Model@ov.x.dummy.lv.idx[[2]],
                lavobject@Model@ov.y.dummy.lv.idx[[2]])
   }"
ecmerkle,blavaan,202659b8f9a453816251a43a44c4094dbead59ef,ecmerkle,merklee@missouri.edu,2023-08-22T15:30:12Z,ecmerkle,merklee@missouri.edu,2023-08-22T15:30:12Z,small fixes for level 1 fixed.x,DESCRIPTION;R/blavaan.R;R/lav_export_stanmarg.R;inst/stan/stanmarg.stan,False,True,True,False,6,5,11,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-9.1150
+Version: 0.4-9.1151
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blavaan.R---
@@ -324,7 +324,7 @@ blavaan <- function(...,  # default lavaan arguments
     }
 
     # for initial values/parameter setup:
-    if(jag.do.fit) {
+    if(jag.do.fit & !any(lavInspect(LAV, 'nlevels') > 1)) {
         LAV2 <- try(do.call(""lavaan"", dotdotdot), silent = TRUE)
         if(!inherits(LAV2, 'try-error')) LAV <- LAV2
     }
@@ -766,7 +766,7 @@ blavaan <- function(...,  # default lavaan arguments
 
         timing$Estimate <- (proc.time()[3] - start.time)
         start.time <- proc.time()[3]
-        cat(""Computing post-estimation metrics (including lvs if requested)...\n"")
+        if(jag.do.fit) cat(""Computing post-estimation metrics (including lvs if requested)...\n"")
         
         ## FIXME: there is no pars argument. this saves all parameters and uses unnecessary memory
         ## see res@sim and line 284 of stan_csv.R... might cut it down manually

---FILE: R/lav_export_stanmarg.R---
@@ -738,7 +738,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
         ## remove Psi_r_free because handled as corr_mat
         ini[[i]]$Psi_r_free <- array(0, 0)
         psidim <- dim(dat$Psi_skeleton)[2]
-        psimat <- array(diag(1, psidim), dim = c(psidim, psidim, dat$Ng))
+        psimat <- array(diag(1, psidim), dim = c(psidim, psidim, Ng))
         ini[[i]]$Psi_r_mat <- aperm(psimat, perm = c(3, 1, 2))
       }
 

---FILE: inst/stan/stanmarg.stan---
@@ -501,6 +501,7 @@ functions { // you can use these in R following `rstan::expose_stan_functions(""f
 
       out[2, 1:Nx, 1:Nx] = cov_w;
       out[3, 1:Nx, 1:Nx] = cov_w_inv;
+      out[3, Nx + 1, Nx + 1] = log_determinant(cov_w); // need log_determinant for multi_normal_suff
     }
 
     if (Nx_between > 0) {
@@ -520,7 +521,7 @@ functions { // you can use these in R following `rstan::expose_stan_functions(""f
 
     for (cc in 1:nclus[2]) {
       if (Nx > 0) {
-	out[cc] += multi_normal_suff(mean_d[cc, Xvar[1:Nx]], cov_w[1:Nx, 1:Nx], mean_d[cc, Xvar[1:Nx]], cov_w_inv[1:Nx, 1:Nx], cluster_size[cc]);
+	out[cc] += multi_normal_suff(mean_d[cc, Xvar[1:Nx]], cov_w[1:Nx, 1:Nx], mean_d[cc, Xvar[1:Nx]], cov_w_inv[1:(Nx + 1), 1:(Nx + 1)], cluster_size[cc]);
       }
       if (Nx_between > 0) {
 	out[cc] += multi_normal_lpdf(mean_d[cc, 1:Nx_between] | ov_mean_d[1:Nx_between], cov_mean_d[1:Nx_between, 1:Nx_between]);"
ecmerkle,blavaan,2fc74badf62aded9120e8be6c9e89e3626f4a6d8,ecmerkle,merklee@missouri.edu,2023-08-21T16:53:21Z,ecmerkle,merklee@missouri.edu,2023-08-21T16:53:21Z,fix lv sampling for multigroup multilevel,DESCRIPTION;R/lvgqs.R,False,True,True,False,4,3,7,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-9.1148
+Version: 0.4-9.1149
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lvgqs.R---
@@ -300,8 +300,9 @@ samp_lvs_2lev <- function(mcobj, lavmodel, lavsamplestats, lavdata, lavpartable,
         standata$startrow <- c(1, standata$endrow[-length(standata$endrow)] + 1)
         standata$YX <- cbind(clusmns, matrix(0, nrow(clusmns), 2))
         standata$Ntot <- sum(standata$nclus[,2])
-        standata$Nobs <- with(standata, N_between + N_both)
-        standata$Obsvar <- with(standata, matrix(1:standata$Nobs, Np, N_between + N_both, byrow = TRUE))
+        standata$Nobs <- with(standata, rep(N_between + N_both, Np))
+        standata$Obsvar <- with(standata, matrix(1:standata$Nobs[1], Np, N_between + N_both, byrow = TRUE))
+
         tmpmat2[j,,] <- lvgqs(modmat2, standata)
 
         ## now level 1"
ecmerkle,blavaan,ce61b8ac79852e5c244a25537d2cd311ab90fcdb,ecmerkle,merklee@missouri.edu,2023-08-21T16:34:59Z,ecmerkle,merklee@missouri.edu,2023-08-21T16:34:59Z,fix lv extraction for unequal numbers of level 1 & level 2 variables,DESCRIPTION;R/lvgqs.R,False,True,True,False,3,1,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-9.1147
+Version: 0.4-9.1148
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lvgqs.R---
@@ -300,6 +300,8 @@ samp_lvs_2lev <- function(mcobj, lavmodel, lavsamplestats, lavdata, lavpartable,
         standata$startrow <- c(1, standata$endrow[-length(standata$endrow)] + 1)
         standata$YX <- cbind(clusmns, matrix(0, nrow(clusmns), 2))
         standata$Ntot <- sum(standata$nclus[,2])
+        standata$Nobs <- with(standata, N_between + N_both)
+        standata$Obsvar <- with(standata, matrix(1:standata$Nobs, Np, N_between + N_both, byrow = TRUE))
         tmpmat2[j,,] <- lvgqs(modmat2, standata)
 
         ## now level 1"
ecmerkle,blavaan,c07743abaaa6f4b6839860995ccaa9e76ddc3eca,ecmerkle,merklee@missouri.edu,2023-08-19T18:29:57Z,ecmerkle,merklee@missouri.edu,2023-08-19T18:29:57Z,fix 2-level lv sampling for multiple groups,R/lvgqs.R,False,True,True,False,10,7,17,"---FILE: R/lvgqs.R---
@@ -277,17 +277,20 @@ samp_lvs_2lev <- function(mcobj, lavmodel, lavsamplestats, lavdata, lavpartable,
 
             modmats[[b]] <- lavmodel@GLIST[mm.in.group]
         }
-        
         modmat2 <- modmats[2 * (1:standata$Ng)]
+        clusmns <- vector(""list"", length(modmat2))
+        modimp <- lav_model_implied(lavmodel) ## for all groups
+
         for(g in 1:length(modmat2)){
           if(!(""beta"" %in% names(modmat2[[g]]))) modmat2[[g]]$beta <- matrix(0, standata$m_c, standata$m_c)
-        }
 
-        out <- lav_implied22l(lavdata@Lp[[1]], lav_model_implied(lavmodel))
-        clusmns <- lav_estep(YLp = lavsamplestats@YLp[[1]], Lp = lavdata@Lp[[1]],
-                             sigma.w = out$sigma.w, sigma.b = out$sigma.b,
-                             sigma.zz = out$sigma.zz, sigma.yz = out$sigma.yz,
-                             mu.z = out$mu.z, mu.w = out$mu.w, mu.b = out$mu.b, se = FALSE)
+          out <- lav_implied22l(lavdata@Lp[[g]], lapply(modimp, function(x) x[(2*g - 1):(2*g)]))
+          clusmns[[g]] <- lav_estep(YLp = lavsamplestats@YLp[[g]], Lp = lavdata@Lp[[g]],
+                                    sigma.w = out$sigma.w, sigma.b = out$sigma.b,
+                                    sigma.zz = out$sigma.zz, sigma.yz = out$sigma.yz,
+                                    mu.z = out$mu.z, mu.w = out$mu.w, mu.b = out$mu.b, se = FALSE)
+        }
+        clusmns <- do.call(""rbind"", clusmns)
 
         ## manipulations to reuse existing lvgqs code
         standata$p <- standata$p_c"
ecmerkle,blavaan,94c3c2386bc49597ecc3104ac9bf15a2c4b22806,ecmerkle,merklee@missouri.edu,2023-07-16T20:22:58Z,ecmerkle,merklee@missouri.edu,2023-07-16T20:22:58Z,"fix inits of correlation parameters for target=""stan""",DESCRIPTION;NEWS.md;R/lav_export_stanmarg.R,False,True,True,False,8,1,9,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-9.1141
+Version: 0.4-9.1142
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: NEWS.md---
@@ -2,6 +2,8 @@
 ## New features
 * This is a maintenance release with bug fixes and some changes in compiler settings
 
+## Bugs/glitches discovered after the release:
+* For certain models with residual correlations and/or correlated factors, the initial values under target='stan' lead to non-positive definite matrices (reported by Yuanyuan Hu).
 
 # Version 0.4-7
 ## New features

---FILE: R/lav_export_stanmarg.R---
@@ -742,6 +742,11 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
         ini[[i]]$Psi_r_mat <- aperm(psimat, perm = c(3, 1, 2))
       }
 
+      ## for target = ""stan"", translate correlation parameters from (0,1) to (-1,1)
+      ## (needed because set_inits_stan() is also used for stanclassic and stancond targets
+      if (""Theta_r_free"" %in% names(ini[[i]])) ini[[i]]$Theta_r_free <- -1 + 2 * ini[[i]]$Theta_r_free
+      if (""Psi_r_free"" %in% names(ini[[i]])) ini[[i]]$Psi_r_free <- -1 + 2 * ini[[i]]$Psi_r_free
+        
       if (level == 2L) {
         names(ini[[i]]) <- paste0(names(ini[[i]]), ""_c"")
       } else {"
ecmerkle,blavaan,0ed36953037753d6c450c892e9754d100556e9d7,ecmerkle,merklee@missouri.edu,2023-07-11T15:06:58Z,ecmerkle,merklee@missouri.edu,2023-07-11T15:06:58Z,fix summary() problem when prisamp=TRUE,DESCRIPTION;R/blav_object_methods.R;R/blavaan.R,False,True,True,False,6,5,11,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-9.1137
+Version: 0.4-9.1140
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_object_methods.R---
@@ -197,6 +197,7 @@ function(object, header       = TRUE,
   if(estimates) {
         jagtarget <- lavInspect(object, ""options"")$target == ""jags""
         newpt <- object@ParTable
+        if(!(""group"" %in% names(newpt))) newpt$group <- rep(1, length(newpt$lhs))
         newpt$group[newpt$group == 0] <- 1 # for defined parameters
 
         if(!jagtarget){

---FILE: R/blavaan.R---
@@ -56,7 +56,10 @@ blavaan <- function(...,  # default lavaan arguments
     }
 
     # multilevel functionality
-    if(""cluster"" %in% dotNames) warning(""blavaan WARNING: two-level models are under development and may be unstable."")
+    if(""cluster"" %in% dotNames) {
+        cat(""blavaan NOTE: two-level models are new, please report bugs!\nhttps://github.com/ecmerkle/blavaan/issues\n\n"")
+        if(!(target == ""stan"")) stop(""blavaan ERROR: two-level functionality is not available for "", target, ""."")
+    }
   
     # prior predictives only for stan
     if(prisamp) {
@@ -468,9 +471,6 @@ blavaan <- function(...,  # default lavaan arguments
     lavoptions$estimator <- ""Bayes""
     lavoptions$se        <- ""standard""
     lavoptions$test <- ""standard""
-    if(ordmod) {
-        cat(""blavaan NOTE: ordinal models are new, please report bugs!\nhttps://github.com/ecmerkle/blavaan/issues\n\n"")
-    }
     if(""test"" %in% dotNames) {
         if(dotdotdot$test == ""none"") lavoptions$test <- ""none""
     } else {"
ecmerkle,blavaan,99e2bba2b35ea88c456634cdc449230f543ec5d5,ecmerkle,merklee@missouri.edu,2023-07-07T16:46:29Z,ecmerkle,merklee@missouri.edu,2023-07-07T16:46:29Z,restore error message for unavailable wiggle arguments,DESCRIPTION;R/blav_utils.R,False,True,True,False,6,2,8,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-9.1135
+Version: 0.4-9.1136
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_utils.R---
@@ -260,6 +260,11 @@ wiglabels <- function(lavpartable, wiggle, wiggle.sd, target = ""stan""){
   gqnames <- c(""loadings"", ""intercepts"", ""regressions"", ""means"", ""thresholds"")
   gqops <- c(""=~"", ""~1"", ""~"", ""~1"", ""|"")
 
+  badnames <- c(""residuals"", ""residual.covariances"", ""lv.variances"", ""lv.covariances"")
+  if(any(wiggle %in% badnames)){
+    stop(""blavaan ERROR: wiggle cannot be used on (co-)variance parameters."")
+  }
+  
   if(all(wiggle %in% gqnames)){
     ## ensure we have these things in this level of the model
     rmvars <- NULL
@@ -270,7 +275,6 @@ wiglabels <- function(lavpartable, wiggle, wiggle.sd, target = ""stan""){
     if(length(rmvars) > 0) wiggle <- wiggle[-rmvars]
   }
 
-  
   if(!any(wiggle %in% lavpartable$label) && !any(wiggle %in% gqnames)) return( list(outlist = NULL, lavpartable = list(prior = NULL)) )
   
   lv.names <- unique(unlist(lav_partable_attributes(lavpartable, pta=NULL)$vnames$lv))"
ecmerkle,blavaan,00e168eea00f04f30bf6a84f44d7272cedab8bb2,ecmerkle,merklee@missouri.edu,2023-07-07T16:35:52Z,ecmerkle,merklee@missouri.edu,2023-07-07T16:35:52Z,additional fix for wiggle argument,DESCRIPTION;R/blav_utils.R,False,True,True,False,4,2,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-9.1134
+Version: 0.4-9.1135
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_utils.R---
@@ -262,10 +262,12 @@ wiglabels <- function(lavpartable, wiggle, wiggle.sd, target = ""stan""){
 
   if(all(wiggle %in% gqnames)){
     ## ensure we have these things in this level of the model
+    rmvars <- NULL
     for(i in 1:length(wiggle)){
       relop <- gqops[match(wiggle[i], gqnames)]
-      if(!any(relop %in% lavpartable$op)) wiggle <- wiggle[-i]
+      if(!any(relop %in% lavpartable$op)) rmvars <- c(rmvars, i)
     }
+    if(length(rmvars) > 0) wiggle <- wiggle[-rmvars]
   }
 
   "
ecmerkle,blavaan,0680e8b875e251ac7e12a807dd9b8e9654c77094,ecmerkle,merklee@missouri.edu,2023-07-07T16:32:03Z,ecmerkle,merklee@missouri.edu,2023-07-07T16:32:03Z,fix wiggle argument,DESCRIPTION;R/blav_utils.R,False,True,True,False,10,1,11,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-9.1133
+Version: 0.4-9.1134
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_utils.R---
@@ -260,6 +260,15 @@ wiglabels <- function(lavpartable, wiggle, wiggle.sd, target = ""stan""){
   gqnames <- c(""loadings"", ""intercepts"", ""regressions"", ""means"", ""thresholds"")
   gqops <- c(""=~"", ""~1"", ""~"", ""~1"", ""|"")
 
+  if(all(wiggle %in% gqnames)){
+    ## ensure we have these things in this level of the model
+    for(i in 1:length(wiggle)){
+      relop <- gqops[match(wiggle[i], gqnames)]
+      if(!any(relop %in% lavpartable$op)) wiggle <- wiggle[-i]
+    }
+  }
+
+  
   if(!any(wiggle %in% lavpartable$label) && !any(wiggle %in% gqnames)) return( list(outlist = NULL, lavpartable = list(prior = NULL)) )
   
   lv.names <- unique(unlist(lav_partable_attributes(lavpartable, pta=NULL)$vnames$lv))"
ecmerkle,blavaan,a8cb06e1b8b82d6fa8967a51d2cd41a26ce90edc,ecmerkle,merklee@missouri.edu,2023-07-07T15:30:33Z,ecmerkle,merklee@missouri.edu,2023-07-07T15:30:33Z,fix empty beta matrix for lv sampling,DESCRIPTION;R/lvgqs.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-9.1125
+Version: 0.4-9.1133
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lvgqs.R---
@@ -37,6 +37,7 @@ lvgqs <- function(modmats, standata, getlvs = TRUE) {
       ovmean[[g]] <- t(standata$YXbar[g, , drop = FALSE])
     }
 
+    if(!(""beta"" %in% names(modmats[[g]]))) modmats[[g]]$beta <- matrix(0, standata$m, standata$m)
     if (p > 0){
       L_Y_A[[g]] <- modmats[[g]]$lambda %*% solve(I - modmats[[g]]$beta)
 
@@ -45,7 +46,6 @@ lvgqs <- function(modmats, standata, getlvs = TRUE) {
       }
     }
     if (!(""alpha"" %in% names(modmats[[g]]))) modmats[[g]]$alpha <- matrix(0, m, 1)
-    if(!(""beta"" %in% names(modmats[[g]]))) modmats[[g]]$beta <- matrix(0, standata$m, standata$m)
   }
 
   if ((w9use + w9no) > 0 | !getlvs) {"
ecmerkle,blavaan,043d586009293131e47c571b1329067f6765b7b0,ecmerkle,merklee@missouri.edu,2023-06-08T17:12:01Z,ecmerkle,merklee@missouri.edu,2023-06-08T17:12:01Z,fix do.fit=FALSE issue,DESCRIPTION;R/blavaan.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-8.1122
+Version: 0.4-8.1124
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blavaan.R---
@@ -481,7 +481,6 @@ blavaan <- function(...,  # default lavaan arguments
     }
     if(!jag.do.fit){
       lavoptions$test <- ""none""
-      lavoptions$se <- ""none""
     }
     lavoptions$missing   <- ""ml""
     lavoptions$cp        <- cp
@@ -805,6 +804,7 @@ blavaan <- function(...,  # default lavaan arguments
         LAV@ParTable <- lavpartable
         LAV@Model <- lavmodel
         LAV@external$mcmcout <- res
+        LAV@Options$se <- ""standard""
         LAV@Options$target <- ""jags"" ## to ensure computation in R, vs extraction of the
                                      ## log-likehoods from Stan
         ## FIXME: modify so that fx is commensurate with logl from Stan"
ecmerkle,blavaan,80d16265a628a3eda0524c1249f540e867123456,ecmerkle,merklee@missouri.edu,2023-06-08T14:35:21Z,ecmerkle,merklee@missouri.edu,2023-06-08T14:35:21Z,fix a cran note about documenting S3 methods,DESCRIPTION;man/blavFitIndices.Rd;man/ppmc.Rd,False,False,False,False,3,3,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-8.1106
+Version: 0.4-8.1122
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: man/blavFitIndices.Rd---
@@ -16,7 +16,7 @@ blavFitIndices(object, thin = 1L, pD = c(""loo"",""waic"",""dic""),
 ## S4 method for signature 'blavFitIndices'
 \S4method{summary}{blavFitIndices}(object, ...)
 
-summary.bfi(object, central.tendency = c(""mean"",""median"",""mode""),
+\method{summary}{bfi}(object, central.tendency = c(""mean"",""median"",""mode""),
         hpd = TRUE, prob = .90)
 }
 \arguments{

---FILE: man/ppmc.Rd---
@@ -18,7 +18,7 @@ ppmc(object, thin = 1, fit.measures = c(""srmr"",""chisq""), discFUN = NULL,
 
 \S4method{summary}{blavPPMC}(object, ...)
 
-summary.ppmc(object, discFUN, dist = c(""obs"",""sim""),
+\method{summary}{ppmc}(object, discFUN, dist = c(""obs"",""sim""),
         central.tendency = c(""mean"",""median"",""mode""),
         hpd = TRUE, prob = .95, to.data.frame = FALSE, diag = TRUE,
         sort.by = NULL, decreasing = FALSE)"
ecmerkle,blavaan,5270023b8af51592df3bb753e2ded64d2f4857c2,ecmerkle,merklee@missouri.edu,2023-05-24T18:43:13Z,ecmerkle,merklee@missouri.edu,2023-05-24T18:43:13Z,fix unconverged model,vignettes/cross_loadings_strong_priors.Rmd,True,False,True,False,9,9,18,"---FILE: vignettes/cross_loadings_strong_priors.Rmd---
@@ -46,20 +46,20 @@ We can see the overall model results with the ```summary()``` function, looking
 summary(fit_df)
 ```
 
-Next, we will add all possible cross-loadings with a strong prior of $N(0, \sigma = 0.1)$. The prior centers the loadings around 0 and allows them little space to move.
+Next, we will add all possible cross-loadings with a strong prior of $N(0, \sigma = 0.08)$. The prior centers the loadings around 0 and allows them little space to move.
 
 ```{r, eval=T, include=FALSE, cache=TRUE}
 HS.model.cl<-' visual  =~ x1 + x2 + x3
               textual =~ x4 + x5 + x6
               speed   =~ x7 + x8 + x9 
     
               ## Cross-loadings
-              visual =~  prior(""normal(0,.1)"")*x4 + prior(""normal(0,.1)"")*x5 + prior(""normal(0,.1)"")*x6 + prior(""normal(0,.1)"")*x7 + prior(""normal(0,.1)"")*x8 + prior(""normal(0,.1)"")*x9
-              textual =~ prior(""normal(0,.1)"")*x1 + prior(""normal(0,.1)"")*x2 + prior(""normal(0,.1)"")*x3 + prior(""normal(0,.1)"")*x7 + prior(""normal(0,.1)"")*x8 + prior(""normal(0,.1)"")*x9 
-              speed =~ prior(""normal(0,.1)"")*x1 + prior(""normal(0,.1)"")*x2 + prior(""normal(0,.1)"")*x3 + prior(""normal(0,.1)"")*x4 + prior(""normal(0,.1)"")*x5 + prior(""normal(0,.1)"")*x6'
+              visual =~  prior(""normal(0,.08)"")*x4 + prior(""normal(0,.08)"")*x5 + prior(""normal(0,.08)"")*x6 + prior(""normal(0,.08)"")*x7 + prior(""normal(0,.08)"")*x8 + prior(""normal(0,.08)"")*x9
+              textual =~ prior(""normal(0,.08)"")*x1 + prior(""normal(0,.08)"")*x2 + prior(""normal(0,.08)"")*x3 + prior(""normal(0,.08)"")*x7 + prior(""normal(0,.08)"")*x8 + prior(""normal(0,.08)"")*x9 
+              speed =~ prior(""normal(0,.08)"")*x1 + prior(""normal(0,.08)"")*x2 + prior(""normal(0,.08)"")*x3 + prior(""normal(0,.08)"")*x4 + prior(""normal(0,.08)"")*x5 + prior(""normal(0,.08)"")*x6'
 
 fit_cl <- bcfa(HS.model.cl, data=HolzingerSwineford1939, 
-            std.lv=TRUE, meanstructure=T, seed=867)
+               std.lv=TRUE, meanstructure=T, seed=867)
 ```
 
 ```{r, eval=F}
@@ -68,9 +68,9 @@ HS.model.cl<-' visual  =~ x1 + x2 + x3
               speed   =~ x7 + x8 + x9 
     
               ## Cross-loadings
-              visual =~  prior(""normal(0,.1)"")*x4 + prior(""normal(0,.1)"")*x5 + prior(""normal(0,.1)"")*x6 + prior(""normal(0,.1)"")*x7 + prior(""normal(0,.1)"")*x8 + prior(""normal(0,.1)"")*x9
-              textual =~ prior(""normal(0,.1)"")*x1 + prior(""normal(0,.1)"")*x2 + prior(""normal(0,.1)"")*x3 + prior(""normal(0,.1)"")*x7 + prior(""normal(0,.1)"")*x8 + prior(""normal(0,.1)"")*x9 
-              speed =~ prior(""normal(0,.1)"")*x1 + prior(""normal(0,.1)"")*x2 + prior(""normal(0,.1)"")*x3 + prior(""normal(0,.1)"")*x4 + prior(""normal(0,.1)"")*x5 + prior(""normal(0,.1)"")*x6'
+              visual =~  prior(""normal(0,.08)"")*x4 + prior(""normal(0,.08)"")*x5 + prior(""normal(0,.08)"")*x6 + prior(""normal(0,.08)"")*x7 + prior(""normal(0,.08)"")*x8 + prior(""normal(0,.08)"")*x9
+              textual =~ prior(""normal(0,.08)"")*x1 + prior(""normal(0,.08)"")*x2 + prior(""normal(0,.08)"")*x3 + prior(""normal(0,.08)"")*x7 + prior(""normal(0,.08)"")*x8 + prior(""normal(0,.08)"")*x9 
+              speed =~ prior(""normal(0,.08)"")*x1 + prior(""normal(0,.08)"")*x2 + prior(""normal(0,.08)"")*x3 + prior(""normal(0,.08)"")*x4 + prior(""normal(0,.08)"")*x5 + prior(""normal(0,.08)"")*x6'
 
 fit_cl <- bcfa(HS.model.cl, data=HolzingerSwineford1939, 
             std.lv=TRUE, meanstructure=T)
@@ -86,6 +86,6 @@ We suggest to not simply look at whether the CI excludes 0 (similar to the null
 
 ### Caveats
 
-The model with all possible cross-loadings should not be kept as the final analysis model, but should be used as a step to make decisions about model changes. This for two main reasons, (1) this model is overfitted and would present *good* overall fit just due to the inclusion of a lot of nuisance parameters. In this example the posterior predictive p-value goes from ```ppp = 0.000``` to ```ppp = 0.160```, and is not that the model is better theoretically but that we are inflating the model fit. And (2), the addition of small-variance priors can prevent detection of important misspecifications in Bayesian confirmatory factor analysis, as it can obscure underlying problems in the model by diluting it through a large number of nuisance parameters [@jorgensen_small_variance_2019].
+The model with all possible cross-loadings should not be kept as the final analysis model, but should be used as a step to make decisions about model changes. This for two main reasons, (1) this model is overfitted and would present *good* overall fit just due to the inclusion of a lot of nuisance parameters. In this example the posterior predictive p-value goes from `r paste0('ppp = ', round(fitMeasures(fit_df, 'ppp')[[1]], 3))` to `r paste0('ppp = ', round(fitMeasures(fit_cl, 'ppp')[[1]], 3))`, and is not that the model is better theoretically but that we are inflating the model fit. And (2), the addition of small-variance priors can prevent detection of important misspecifications in Bayesian confirmatory factor analysis, as it can obscure underlying problems in the model by diluting it through a large number of nuisance parameters [@jorgensen_small_variance_2019].
 
 ### References"
ecmerkle,blavaan,23a1c1345b7a867dba21e548826c7283323f7ea1,ecmerkle,merklee@missouri.edu,2023-05-24T03:09:01Z,ecmerkle,merklee@missouri.edu,2023-05-24T03:09:01Z,"updates to crossloading example, including model convergence issue",vignettes/cross_loadings_strong_priors.Rmd,True,False,True,False,9,9,18,"---FILE: vignettes/cross_loadings_strong_priors.Rmd---
@@ -14,13 +14,13 @@ library(lavaan, quietly=TRUE)
 
 An advantage of BSEM is that we can use priors to set up **soft** constraints in the model, by estimating a parameter with a strong prior. This way the parameter is estimated, but the prior will restrict the possible values. 
 
-This was suggested by @muthen_bayesian_2012, as a way to estimate all possible cross-loadings in a CFA. This way, if the posterior distribution of the restricted parameters presents values outside of the strong prior, can be interpreted as a model modification, meaning that the parameters should be more freely estimated or relax the respective prior. 
+This was suggested by @muthen_bayesian_2012, as a way to estimate all possible cross-loadings in a CFA. This way, if the posterior distribution of the restricted parameters includes values outside of the strong prior, it can be interpreted as a model modification. This means that the parameters should be less restricted, or that the prior distribution should be relaxed. 
 
-In this tutorial we present how to estimate a CFA with all possible cross-loadings restricted by a strong priors
+In this tutorial we present how to estimate a CFA where all possible cross-loadings are restricted by strong priors.
 
 ### Cross-loadings
 
-We will show an example with the @holswi39 data, first we will estimate the regular model with no cross-loadings and default priors
+We will show an example with the @holswi39 data. First we will estimate the regular model with no cross-loadings and default priors.
 
 ```{r, eval=T, include=FALSE, cache=TRUE}
 HS.model <- ' visual  =~ x1 + x2 + x3
@@ -40,13 +40,13 @@ fit_df <- bcfa(HS.model, data=HolzingerSwineford1939,
             std.lv=TRUE, meanstructure=T)
 ```
 
-We can see the overall model results with the ```summary``` function, looking at the posterior distribution for the factor loadings, correlations, intercepts and variances.  
+We can see the overall model results with the ```summary()``` function, looking at the posterior distribution for the factor loadings, correlations, intercepts and variances.  
 
 ```{r}
 summary(fit_df)
 ```
 
-Next, we will add all possible cross-loadings with a strong prior of $N(0, 0.1)$, having it center around 0 and allowing them little space to move
+Next, we will add all possible cross-loadings with a strong prior of $N(0, \sigma = 0.1)$. The prior centers the loadings around 0 and allows them little space to move.
 
 ```{r, eval=T, include=FALSE, cache=TRUE}
 HS.model.cl<-' visual  =~ x1 + x2 + x3
@@ -59,7 +59,7 @@ HS.model.cl<-' visual  =~ x1 + x2 + x3
               speed =~ prior(""normal(0,.1)"")*x1 + prior(""normal(0,.1)"")*x2 + prior(""normal(0,.1)"")*x3 + prior(""normal(0,.1)"")*x4 + prior(""normal(0,.1)"")*x5 + prior(""normal(0,.1)"")*x6'
 
 fit_cl <- bcfa(HS.model.cl, data=HolzingerSwineford1939, 
-            std.lv=TRUE, meanstructure=T)
+            std.lv=TRUE, meanstructure=T, seed=867)
 ```
 
 ```{r, eval=F}
@@ -76,16 +76,16 @@ fit_cl <- bcfa(HS.model.cl, data=HolzingerSwineford1939,
             std.lv=TRUE, meanstructure=T)
 ```
 
-Then you can look at the ```summary``` of this model and evaluate the cross-loadings and see if any of them seem large enough to suggest that should be kept in the model, by looking at the posterior mean (```Eestimate```) and credible interval. 
+Then you can look at the ```summary()``` of this model and evaluate the cross-loadings. You can specifically see whether any of the cross-loadings seem large enough to suggest that they should be kept in the model, by looking at the posterior mean (```Estimate```) and credible interval. 
 
 ```{r}
 summary(fit_cl)
 ```
 
-We suggest to not simple look of the CI excludes 0 (similar to the null hypothesis), but to evaluate of the minimum value of the CI (closer to 0) is far away from 0 to be relavant instead of just **different** from 0. 
+We suggest to not simply look at whether the CI excludes 0 (similar to the null hypothesis), but to evaluate whether the minimum value of the CI (the value closer to 0) is far enough away from 0 to be relavant instead of just **different** from 0. 
 
 ### Caveats
 
-The model with all possible cross-loadings should not be kept as the final analysis model, but use as a step to make decisions abdout model changes. This for two main reasons, (1) this model is overfitted and would present *good* overall fit just due to the inclusion of a lot of nuance parameters, in this example the posterior predictive p-value goes from ```ppp = 0.000``` to ```ppp = 0.160```, and is not that the model is better theoretically but we are inflating the model fit. And (2), the addition of small-variance priors can prevent detecting important misspecifications in Bayesian confirmatory factor analysis, as it can obscure the true underlying problems in the model by dilluting it through a large number of nuance parameters [@jorgensen_small_variance_2019]
+The model with all possible cross-loadings should not be kept as the final analysis model, but should be used as a step to make decisions about model changes. This for two main reasons, (1) this model is overfitted and would present *good* overall fit just due to the inclusion of a lot of nuisance parameters. In this example the posterior predictive p-value goes from ```ppp = 0.000``` to ```ppp = 0.160```, and is not that the model is better theoretically but that we are inflating the model fit. And (2), the addition of small-variance priors can prevent detection of important misspecifications in Bayesian confirmatory factor analysis, as it can obscure underlying problems in the model by diluting it through a large number of nuisance parameters [@jorgensen_small_variance_2019].
 
 ### References"
ecmerkle,blavaan,da7fad2c3231f422b6d87efe23914121ef6ee89d,ecmerkle,merklee@missouri.edu,2023-05-04T17:06:12Z,ecmerkle,merklee@missouri.edu,2023-05-04T17:06:12Z,handle fixed values on diagonal of Psi and Theta matrices,DESCRIPTION;R/stanmarg_data.R,False,True,True,False,3,3,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-8.1104
+Version: 0.4-8.1105
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/stanmarg_data.R---
@@ -334,7 +334,7 @@ stanmarg_data <- function(YX = NULL, S = NULL, YXo = NULL, N, Ng, grpnum, # data
   }
   tmpres <- group_sparse_skeleton(dThet)
   dat$len_w5 <- max(tmpres$g_len)
-  dat$w5 <- tmpres$w
+  dat$w5 <- sqrt(tmpres$w) # because we do SRS in the model
   dat$v5 <- tmpres$v
   dat$u5 <- tmpres$u
   dat$wg5 <- array(tmpres$g_len, length(tmpres$g_len))
@@ -382,7 +382,7 @@ stanmarg_data <- function(YX = NULL, S = NULL, YXo = NULL, N, Ng, grpnum, # data
   }
   tmpres <- group_sparse_skeleton(dPsi)
   dat$len_w9 <- max(tmpres$g_len)
-  dat$w9 <- tmpres$w
+  dat$w9 <- sqrt(tmpres$w) # because we do SRS in the model
   dat$v9 <- tmpres$v
   dat$u9 <- tmpres$u
   dat$wg9 <- array(tmpres$g_len, length(tmpres$g_len))"
ecmerkle,blavaan,04300dcc9d678cdbc1a1e00f787bd1445e9d5c40,ecmerkle,merklee@missouri.edu,2023-03-20T14:05:48Z,ecmerkle,merklee@missouri.edu,2023-03-20T14:05:48Z,"target = 'jags', fix single-indicator lvs regressed on other variables",DESCRIPTION;NEWS.md;R/blavaan.R;R/set_partable.R,False,True,True,False,7,5,12,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-8.1101
+Version: 0.4-8.1102
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: NEWS.md---
@@ -5,7 +5,9 @@
 * But bugs from 0.4-6 have also been fixed
 
 ## Bugs/glitches discovered after the release:
-* Sampling from the priors (prisamp = TRUE) fails for models with meanstructure = FALSE (the posterior is still estimated)
+* Sampling from the priors (prisamp = TRUE) fails for models with meanstructure = FALSE; the posterior is still estimated (reported by Armel Brizuela Rodrguez).
+
+* For target = ""jags"", models with a single-indicator latent variable, where the latent variable is regressed on other variables, return incorrect parameter estimates (reported by Brad Cosentino).
 
 
 # Version 0.4-6

---FILE: R/blavaan.R---
@@ -58,9 +58,9 @@ blavaan <- function(...,  # default lavaan arguments
     # multilevel functionality not available
     if(""cluster"" %in% dotNames) stop(""blavaan ERROR: two-level models are not yet available."")
   
-    # prior predictives only for stan
+    # prior sampling only for stan
     if(prisamp) {
-      if(target != 'stan') stop(""blavaan ERROR: prior predictives currently only work for target='stan'."")
+      if(target != 'stan') stop(""blavaan ERROR: prior sampling currently only work for target='stan'."")
       if(!('test' %in% dotNames)) {
         dotdotdot$test <- 'none'
         dotNames <- c(dotNames, ""test"")

---FILE: R/set_partable.R---
@@ -350,7 +350,7 @@ set_mv0 <- function(partable, ov.names, ngroups) {
                                partable$group == j)
 
                 lvreg <- which(partable$op == ""~"" &
-                               partable$lhs == ovn[i] &
+                               partable$lhs %in% c(ovn[i], partable$lhs[lvloc]) &
                                partable$group == j)
 
                 lvcov <- which(partable$op == ""~~"" &"
ecmerkle,blavaan,b8d87ad29e347a8720e94b6e12464755fc7e4ab9,ecmerkle,merklee@missouri.edu,2023-03-20T02:41:06Z,ecmerkle,merklee@missouri.edu,2023-03-20T02:41:06Z,fix previous commit,DESCRIPTION;R/stanmarg_data.R;inst/stan/stanmarg.stan,False,True,True,False,6,3,9,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-8.1100
+Version: 0.4-8.1101
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/stanmarg_data.R---
@@ -223,6 +223,7 @@ stanmarg_data <- function(YX = NULL, S = NULL, YXo = NULL, N, Ng, grpnum, # data
   dat$Nx <- array(Nx, length(Nx))
   dat$emiter <- emiter
   dat$do_reg <- do_reg
+  dat$pri_only <- pri_only
   
   dat$YX <- YX
   dat$YXo <- YXo
@@ -234,6 +235,7 @@ stanmarg_data <- function(YX = NULL, S = NULL, YXo = NULL, N, Ng, grpnum, # data
   dat$use_cov <- 0L
   if (pri_only) {
     dat$use_suff <- 0L
+    if (dim(Nu_skeleton)[2] == 0L) dat$use_cov <- 1L
     tmparr <- array(dim = c(dat$Ng, ncol(YX) + 1, ncol(YX) + 1))
     for (i in 1:Ng) {
       tmparr[i,,] <- diag(nrow=ncol(YX) + 1)

---FILE: inst/stan/stanmarg.stan---
@@ -278,6 +278,7 @@ data {
   int<lower=0> Xvar[Np, p + q]; // indexing of fixed.x variables
   int<lower=0> Xdatvar[Np, p + q]; // indexing of fixed.x in data (differs from Xvar when missing)
   int<lower=0, upper=1> use_cov;
+  int<lower=0, upper=1> pri_only; // sample only from the prior?
   int<lower=0> emiter; // number of em iterations for saturated model in ppp (missing data only)
   int<lower=0, upper=1> use_suff; // should we compute likelihood via mvn sufficient stats?
   int<lower=0, upper=1> do_test; // should we do everything in generated quantities?
@@ -847,15 +848,15 @@ model { // N.B.: things declared in the model block do not get saved in the outp
   vector[len_free[9]] Psi_pri;
   
   /* log-likelihood */
-  if (use_cov) {
+  if (use_cov && !pri_only) {
     for (g in 1:Ng) {
       target += wishart_lpdf((N[g] - 1) * Sstar[g] | N[g] - 1, Sigma[g]);
       if (Nx[g] > 0) {
 	int xvars[Nx[g]] = Xdatvar[g, 1:Nx[g]];
 	target += -wishart_lpdf((N[g] - 1) * Sstar[g, xvars, xvars] | N[g] - 1, Sigma[g, xvars, xvars]);
       }
     }
-  } else if (has_data) {
+  } else if (has_data && !pri_only) {
     int obsidx[p + q];
     int xidx[p + q];
     int xdatidx[p + q];"
ecmerkle,blavaan,d5804506e4cb3cca556fbd66b9e14fadfe82e5f2,ecmerkle,merklee@missouri.edu,2023-03-17T15:01:48Z,ecmerkle,merklee@missouri.edu,2023-03-17T15:01:48Z,fix prior sampling with meanstructure=FALSE,DESCRIPTION;NEWS.md;R/stanmarg_data.R,False,True,True,False,3,2,5,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-8.1093
+Version: 0.4-8.1100
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: NEWS.md---
@@ -4,6 +4,8 @@
 
 * But bugs from 0.4-6 have also been fixed
 
+## Bugs/glitches discovered after the release:
+* Sampling from the priors (prisamp = TRUE) fails for models with meanstructure = FALSE (the posterior is still estimated)
 
 
 # Version 0.4-6

---FILE: R/stanmarg_data.R---
@@ -234,7 +234,6 @@ stanmarg_data <- function(YX = NULL, S = NULL, YXo = NULL, N, Ng, grpnum, # data
   dat$use_cov <- 0L
   if (pri_only) {
     dat$use_suff <- 0L
-    if (dim(Nu_skeleton)[2] == 0L) dat$use_cov <- 1L
     tmparr <- array(dim = c(dat$Ng, ncol(YX) + 1, ncol(YX) + 1))
     for (i in 1:Ng) {
       tmparr[i,,] <- diag(nrow=ncol(YX) + 1)"
ecmerkle,blavaan,fbcbe7240993f1f4fc7f869428efb8504e7cdc3f,ecmerkle,merklee@missouri.edu,2023-03-03T20:15:37Z,ecmerkle,merklee@missouri.edu,2023-03-03T20:15:37Z,"avoid use of size() in Stan, to possibly fix #61",DESCRIPTION;src/stan_files/stanmarg.stan,False,False,False,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-7
+Version: 0.4-8.1091
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: src/stan_files/stanmarg.stan---
@@ -39,7 +39,7 @@ functions { // you can use these in R following `rstan::expose_stan_functions(""f
   }
     
   vector fill_prior(vector free_elements, real[] pri_mean, int[,] eq_skeleton) {
-    int R = size(eq_skeleton);
+    int R = dims(eq_skeleton)[1];
     int eqelem = 0;
     int pos = 1;
     vector[num_elements(pri_mean)] out;"
ecmerkle,blavaan,181efa28a13f6480447c456115e302e900104f5e,ecmerkle,merklee@missouri.edu,2023-02-28T15:23:05Z,ecmerkle,merklee@missouri.edu,2023-02-28T15:23:05Z,"fix bayes_fit null model under rescal=""ppmc""",R/ctr_bayes_fit.R,False,True,True,False,2,2,4,"---FILE: R/ctr_bayes_fit.R---
@@ -184,8 +184,8 @@ blavFitIndices <- function(object, thin = 1, pD = c(""loo"",""waic"",""dic""),
               "" the hypothesized and null models."", call. = FALSE)
     } else {
       if (rescale == ""ppmc"") {
-        reps_null <- postpred(samplls = baseline.model@external$samplls,
-                              lavobject = baseline.model)$ppdist[[""reps""]]
+        reps_null <- unlist(postpred(samplls = baseline.model@external$samplls,
+                                     lavobject = baseline.model)$ppdist[[""reps""]])
       }
       pD_null <- fitMeasures(baseline.model, paste0('p_', pD))
     }"
ecmerkle,blavaan,48672bc0e8a8183931e2c25c39c9a9cd3481afdc,ecmerkle,merklee@missouri.edu,2023-02-27T21:58:00Z,ecmerkle,merklee@missouri.edu,2023-02-27T21:58:00Z,fix blavPredict for meanstructure=FALSE,DESCRIPTION;R/blav_cond_utils.R;R/blav_predict.R,False,True,True,False,4,4,8,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-7.1084
+Version: 0.4-7.1085
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_cond_utils.R---
@@ -99,7 +99,7 @@ samp_kls <- function(lavjags        = NULL,
 
 ## fill in eta matrices (1 per group, in list)
 fill_eta <- function(postsamp, lavmodel, lavpartable, lavsamplestats, lavdata){
-    nlv <- length(lavmodel@GLIST$alpha)
+    nlv <- nrow(lavmodel@GLIST$psi)
     etapars <- grepl(""^eta"", names(postsamp))
     cnums <- strsplit(names(postsamp)[etapars], ""\\[|,|\\]"")
     cnums <- sapply(cnums, function(x) as.numeric(x[3]))

---FILE: R/blav_predict.R---
@@ -64,13 +64,13 @@ blavPredict <- function(object, newdata = NULL, type = ""lv"") {
 
       tmpres <- vector(""list"", nchain)
       for(j in 1:nchain) {
-        loop.args <- list(X = 1:nsamps, future.seed = TRUE, FUN = function(i, j){
+        loop.args <- list(X = 1:nsamps, FUN = function(i, j){
           cond_moments(lavmcmc[[j]][itnums[i],],
                        blavmodel,
                        blavpartable,
                        blavsamplestats,
                        blavdata,
-                       object)}, j = j)
+                       object)}, j = j, future.seed = TRUE)
         tmpres[[j]] <- do.call(""future_lapply"", loop.args)
       }
       tmpres <- unlist(tmpres, recursive = FALSE)"
ecmerkle,blavaan,a961df0ba53ba392cd7e464e0b23720caf70a854,ecmerkle,merklee@missouri.edu,2023-02-17T22:58:48Z,ecmerkle,merklee@missouri.edu,2023-02-17T22:58:48Z,fix some tests,inst/tinytest/tests.blavaan.R;inst/tinytest/tests.blavaanobject-methods.R,False,True,True,False,2,0,2,"---FILE: inst/tinytest/tests.blavaan.R---
@@ -1,4 +1,5 @@
 set.seed(8675309)
+library(lavaan, quietly = TRUE)
 x1 <- rnorm(100)
 x2 <- rnorm(100)
 y1 <- 0.5 + 2*x1 + rnorm(100)

---FILE: inst/tinytest/tests.blavaanobject-methods.R---
@@ -1,6 +1,7 @@
 if(requireNamespace(""rstan"", quietly = TRUE) &
    requireNamespace(""runjags"", quietly = TRUE)){
   load(system.file(""testdata"", ""sysdata.rda"", package=""blavaan""))
+  library(""lavaan"", quietly = TRUE)
 
   # classes
   expect_equal(class(fitjags@external), ""list"")"
ecmerkle,blavaan,c6c97cd751e12113050c3b4e8fdea6e3f1f40bd6,ecmerkle,merklee@missouri.edu,2023-02-17T22:48:31Z,ecmerkle,merklee@missouri.edu,2023-02-17T22:48:31Z,fix prisamp=TRUE for ordinal models,DESCRIPTION;src/stan_files/stanmarg.stan,False,False,False,False,4,4,8,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-7.1079
+Version: 0.4-7.1080
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: src/stan_files/stanmarg.stan---
@@ -886,11 +886,11 @@ model { // N.B.: things declared in the model block do not get saved in the outp
 	}
       }
     }
+    if (ord) {
+      target += tau_jacobian;
+    }
   }
   
-  if (ord) {
-    target += tau_jacobian;
-  }
   
   /* prior densities in log-units */
   target += normal_lpdf(Lambda_y_free | lambda_y_primn, lambda_y_sd);"
ecmerkle,blavaan,6c527d372e091662aa708cb0203b1ee2af855b27,ecmerkle,merklee@missouri.edu,2023-02-17T00:25:50Z,ecmerkle,merklee@missouri.edu,2023-02-17T00:25:50Z,add bugs to NEWS,NEWS.md,False,False,False,False,6,1,7,"---FILE: NEWS.md---
@@ -14,6 +14,11 @@
 
 * Column names are added to blavPredict(, type=""lv"")
 
+## Bugs/glitches discovered after the release:
+* blavFitIndices() and save.lvs = TRUE do not work correctly for models without meanstructure. Workaround is to use meanstructure = TRUE in the model estimation command (reported by Charles Hofacker).
+
+* The lavaan summary() method is sometimes called instead of the blavaan summary() method (reported by multiple users, with Shu Fai Cheung providing helpful examples).
+
 
 
 # Version 0.4-3
@@ -33,7 +38,7 @@
 * loo() moment matching available by passing mcmcextra = list(data = list(moment_match_k_threshold))
 
 ## Bugs/glitches discovered after the release:
-* target = ""stan"" fails when there are complete data in one group and missing data in another group
+* target = ""stan"" fails when there are complete data in one group and missing data in another group (reported by Ronja Runge).
 
 * blavPredict(, type=""ymis"") still not available for models with ordinal variables
 "
ecmerkle,blavaan,028556627c571d65fc8f237ef8bffa6c88cdf024,ecmerkle,merklee@missouri.edu,2023-02-11T16:51:47Z,ecmerkle,merklee@missouri.edu,2023-02-11T16:51:47Z,final for 0.4-6 (version bumps due to some CRAN issues),DESCRIPTION;NEWS.md;R/blavaan.R,False,True,True,False,3,3,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-5
+Version: 0.4-6
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: NEWS.md---
@@ -1,4 +1,4 @@
-# Version 0.4-5
+# Version 0.4-6
 ## New features
 * For target = ""stan"", meanstructure=FALSE is allowed, along with use of sample.cov and sample.nobs instead of raw data
 

---FILE: R/blavaan.R---
@@ -299,7 +299,7 @@ blavaan <- function(...,  # default lavaan arguments
     }
 
 
-    if(""meanstructure"" %in% names(dotdotdot) && ""sample.cov"" %in% names(dotdotdot)) stop('blavaan ERROR: meanstructure is not currently allowed when sample.cov is supplied')
+    if(""sample.mean"" %in% names(dotdotdot) && !(""data"" %in% names(dotdotdot))) stop('blavaan ERROR: sample.mean cannot currently be used in place of data')
   
     # call lavaan
     mcdebug <- FALSE"
ecmerkle,blavaan,cd5facd60a558d2f3d8e0c10a92e277f7d3fd7e0,ecmerkle,merklee@missouri.edu,2023-02-02T22:43:00Z,ecmerkle,merklee@missouri.edu,2023-02-02T22:43:00Z,fix translation error for targets 'jags' and 'stanclassic',DESCRIPTION;R/set_partable.R;R/set_stancovs.R,False,True,True,False,5,5,10,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-4.1029
+Version: 0.4-4.1030
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/set_partable.R---
@@ -48,7 +48,7 @@ set_phantoms <- function(partable, ov.names, lv.names, ov.names.x, lv.names.x, o
   ##   zcovs <- which(partable$ustart[covpars][fcovs] == 0)
   ##   covpars <- covpars[-fcovs[zcovs]]
   ## }
-  blkrow <- rep(NA, length(partable$id))
+  blkrow <- rep(NA, ncol(partable)) #length(partable$id))
   facovs <- NULL
 
   ## Only do this if covpars exist
@@ -123,7 +123,7 @@ nlvcovs)
           old.ridx <- ridx[old.idx]
           grp.idx <- partable$group[full.idx[1]]
         }
-          
+
         tmprows <- nrow(partable) + 1:3
         phname <- paste("".phant"", i, sep="""")
         partable <- rbind(partable, blkrow, blkrow, blkrow)

---FILE: R/set_stancovs.R---
@@ -24,9 +24,9 @@ set_stancovs <- function(partable, std.lv) {
                    partable$lhs != partable$rhs &
                    partable$free > 0L)
 
-  blkrow <- rep(NA, length(partable$id))
   partable$rhoidx <- rep(NA, length(partable$id))
-
+  blkrow <- rep(NA, ncol(partable)) #length(partable$id))
+  
   ## Only do this if covpars exist
   if(length(covpars) > 0){
     mvcov <- 0"
ecmerkle,blavaan,bb6908f7d6a31e9a5a86f4c083833d6c18d6f50e,ecmerkle,merklee@missouri.edu,2023-02-02T17:10:07Z,ecmerkle,merklee@missouri.edu,2023-02-02T17:10:07Z,fix check for missingness,DESCRIPTION;R/blavaan.R,False,True,True,False,3,3,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-4.1026
+Version: 0.4-4.1027
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blavaan.R---
@@ -309,8 +309,8 @@ blavaan <- function(...,  # default lavaan arguments
     LAV <- do.call(""lavaan"", dotdotdot)
     dotdotdot$do.fit <- TRUE; dotdotdot$warn <- FALSE
     if(LAV@Data@data.type != ""moment""){
-        ## if no missing, set missing = ""listwise"" to avoid meanstructure if possible  
-        if(!any(is.na(lavInspect(LAV, 'data')))) dotdotdot$missing <- ""listwise""
+        ## if no missing, set missing = ""listwise"" to avoid meanstructure if possible
+        if(!any(is.na(unlist(lavInspect(LAV, 'data'))))) dotdotdot$missing <- ""listwise""
     }
 
     # for initial values/parameter setup:"
ecmerkle,blavaan,4ab89756762efec3c3706c4ccc5942409a4e7572,TDJorgensen,TJorgensen314@gmail.com,2023-01-31T21:58:38Z,TDJorgensen,TJorgensen314@gmail.com,2023-01-31T21:58:38Z,fixes #58,R/ctr_bayes_fit.R,False,True,True,False,2,2,4,"---FILE: R/ctr_bayes_fit.R---
@@ -1,5 +1,5 @@
 ### Mauricio Garnier-Villareal and Terrence D. Jorgensen
-### Last updated: 9 June 2019
+### Last updated: 31 January 2023
 ### functions applying traditional SEM fit criteria to Bayesian models.
 ### Inspired by, and adpated from, Rens van de Schoot's idea for BRMSEA, as
 ### published in http://dx.doi.org/10.1177/0013164417709314
@@ -193,7 +193,7 @@ blavFitIndices <- function(object, thin = 1, pD = c(""loo"",""waic"",""dic""),
 
   if (rescale != ""mcmc"") {
     out <- BayesChiFit(obs = chisqs, reps = reps,
-                       nvar = object@Model@nvar, pD = fit_pd,
+                       nvar = sum(object@Model@nvar), pD = fit_pd,
                        N = blavInspect(object, 'ntotal'),
                        Ngr = blavInspect(object, 'ngroups'),
                        Min1 = blavInspect(object, 'options')$mimic == ""EQS"","
ecmerkle,blavaan,4b6d3bff406706e007cf52246f4aca8c04355b0d,ecmerkle,merklee@missouri.edu,2023-01-23T19:03:44Z,ecmerkle,merklee@missouri.edu,2023-01-23T19:03:44Z,update test models + fix if() error,DESCRIPTION;R/ctr_bayes_fit.R;inst/testdata/sysdata.rda,False,True,True,False,3,2,5,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-4.1015
+Version: 0.4-4.1016
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/ctr_bayes_fit.R---
@@ -253,7 +253,8 @@ BayesChiFit <- function(obs, reps = NULL, nvar, pD, N, Ngr = 1,
   p <- p * Ngr
   ## Substract parameters and estimated parameters
   dif.ppD <- p - pD
-  if (dif.ppD < 0) warning(""blavaan WARNING: The effective number of parameters exceeds the number of sample statistics (covariances, etc.), so fit index calculations may lead to uninterpretable results."", call. = FALSE)
+
+  if (dif.ppD[1] < 0) warning(""blavaan WARNING: The effective number of parameters exceeds the number of sample statistics (covariances, etc.), so fit index calculations may lead to uninterpretable results."", call. = FALSE)
   
   nonc <- obs - reps - dif.ppD # == obs - p when rescale == ""devm"" because reps = pD
   ## Correct if numerator is smaller than zero"
ecmerkle,blavaan,2824f1396460f3e2786f52560a1d169699bd983c,ecmerkle,merklee@missouri.edu,2023-01-20T18:16:15Z,ecmerkle,merklee@missouri.edu,2023-01-20T18:16:15Z,get fixed.x working for multilevel,R/lav_export_stanmarg.R;R/stanmarg_data.R;src/stan_files/stanmarg.stan,False,True,True,False,10,5,15,"---FILE: R/lav_export_stanmarg.R---
@@ -1042,9 +1042,10 @@ lav2standata <- function(lavobject) {
       dat$Nobs <- array(ptot, dat$Np)
     }
     dat$Nx <- array(length(xidx), dat$Np)
+
     dat$Xvar <- dat$Xdatvar <- matrix(xidx, dat$Np, length(xidx), byrow=TRUE)
     if (length(xidx) < nvar) {
-      if (multilevel & length(xidx) > 0) {
+      if (multilevel) {
         dat$Xvar <- dat$Xdatvar <- cbind(dat$Xvar,
                                          matrix(allvars[!(allvars %in% xidx)], dat$Np,
                                                 ptot - length(xidx), byrow = TRUE))
@@ -1083,6 +1084,7 @@ lav2standata <- function(lavobject) {
     YLp <- lavobject@SampleStats@YLp[[1]]
     dat$mean_d <- YLp[[2]]$mean.d
     dat$cov_w <- YLp[[2]]$Sigma.W
+    dat$log_lik_x <- YLp[[2]]$loglik.x
     
     cov_d <- YLp[[2]]$cov.d
     for (i in 1:length(cov_d)) {
@@ -1125,6 +1127,7 @@ lav2standata <- function(lavobject) {
     
     dat$mean_d <- array(0, c(1, 0))
     dat$cov_w <- array(0, c(0, 0))
+    dat$log_lik_x <- 0
     dat$cov_d <- array(0, c(1, 0, 0))
     dat$mean_d_full <- array(0, c(1, 0))
     dat$cov_d_full <- array(0, c(1, 0, 0))

---FILE: R/stanmarg_data.R---
@@ -216,7 +216,7 @@ stanmarg_data <- function(YX = NULL, S = NULL, YXo = NULL, N, Ng, grpnum, # data
                           dumlv = NULL, # for sampling lvs
                           wigind = NULL, # wiggle indicator
                           pri_only = FALSE, # prior predictive sampling
-                          mean_d, cov_w, cov_d, nclus, cluster_size, ncluster_sizes,
+                          mean_d, cov_w, log_lik_x, cov_d, nclus, cluster_size, ncluster_sizes,
                           mean_d_full, cov_d_full,              # level 2 data
                           cluster_sizes, cluster_size_ns, between_idx, N_between, within_idx,
                           N_within, both_idx, N_both, ov_idx1, ov_idx2, p_tilde, N_lev,
@@ -314,6 +314,7 @@ stanmarg_data <- function(YX = NULL, S = NULL, YXo = NULL, N, Ng, grpnum, # data
   ## level 2 data
   dat$mean_d <- mean_d
   dat$cov_w <- cov_w
+  dat$log_lik_x <- log_lik_x
   dat$cov_d <- cov_d
   dat$mean_d_full <- mean_d_full
   dat$cov_d_full <- cov_d_full

---FILE: src/stan_files/stanmarg.stan---
@@ -493,6 +493,7 @@ data {
   int ov_idx1[N_lev[1]];
   int ov_idx2[N_lev[2]];
   int both_idx[N_both];
+  real log_lik_x; // ll of fixed x variables
   
   
   /* sparse matrix representations of skeletons of coefficient matrices, 
@@ -1288,11 +1289,11 @@ model { // N.B.: things declared in the model block do not get saved in the outp
   if (nclus[2] > 1 && has_data) {
     // TODO compute loglik_x if we have fixed.x
 
-    // FIXME change Nx[1] for missing data/etc; S_PW for multiple groups; the final 0 is for loglik_x
+    // FIXME change Nx[1] for missing data/etc; S_PW for multiple groups
     target += twolevel_logdens(mean_d, cov_d, S_PW[1], nclus, cluster_size, cluster_sizes,
 			       ncluster_sizes, cluster_size_ns, Mu[1], Sigma[1], Mu_c[1], Sigma_c[1],
 			       ov_idx1, ov_idx2, within_idx, between_idx, both_idx,
-			       Xvar[1], p_tilde, N_within, N_between, N_both, 0.0);
+			       Xvar[1], p_tilde, N_within, N_between, N_both, log_lik_x);
   } else if (has_data) {
     int obsidx[p + q];
     int xidx[p + q];
@@ -1622,7 +1623,7 @@ generated quantities { // these matrices are saved in the output but do not figu
 	}
 
 	// log_lik_sat, log_lik_sat_rep
-	if (Nx[mm] > 0) {
+	if (Nx[mm] > 0 && nclus[2] == 1) {
 	  log_lik[jj] += -multi_normal_suff(YXstar[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigmainv[grpidx], xidx, Nx[mm], p + q, logdetSigma_grp[grpidx]), 1);
 	  if (do_test) {
 	    log_lik_sat[jj] += multi_normal_suff(YXstar[jj, xdatidx[1:Nx[mm]]], zmat[1:Nx[mm], 1:Nx[mm]], Mu[grpidx, xidx[1:Nx[mm]]], sig_inv_update(Sigmainv[grpidx], xidx, Nx[mm], p + q, logdetSigma_grp[grpidx]), 1);"
ecmerkle,blavaan,d1ea46abbbdd34ec9e238b864de1c6a49682b0d9,ecmerkle,merklee@missouri.edu,2023-01-16T23:02:14Z,ecmerkle,merklee@missouri.edu,2023-01-16T23:02:14Z,"clusterwise loglik computations, + fix a bug in the constant term",R/lav_export_stanmarg.R;R/stanmarg_data.R;src/stan_files/stanmarg.stan,False,True,True,False,41,6,47,"---FILE: R/lav_export_stanmarg.R---
@@ -1083,14 +1083,29 @@ lav2standata <- function(lavobject) {
     YLp <- lavobject@SampleStats@YLp[[1]]
     dat$mean_d <- YLp[[2]]$mean.d
     dat$cov_w <- YLp[[2]]$Sigma.W
-
+    
     cov_d <- YLp[[2]]$cov.d
     for (i in 1:length(cov_d)) {
       if (!inherits(cov_d[[i]], ""matrix"")) cov_d[[i]] <- with(dat,
                                                               matrix(0, N_between + N_both + N_within,
                                                                      N_between + N_both + N_within))
     }
     dat$cov_d <- cov_d
+
+    ## clusterwise data summaries, for loo and waic and etc
+    Lp$cluster.sizes[[2]] <- dat$cluster_size
+    Lp$ncluster.sizes[[2]] <- dat$nclus[2]
+    Lp$lcuster.size.ns[[2]] <- rep(1, dat$nclus[2])
+    sumfull <- lavaan:::lav_samplestats_cluster_patterns(lavInspect(lavobject, 'data'), Lp)
+    dat$mean_d_full <- sumfull[[2]]$mean.d
+
+    cov_d_full <- sumfull[[2]]$cov.d
+    for (i in 1:length(cov_d_full)) {
+      if (!inherits(cov_d_full[[i]], ""matrix"")) cov_d_full[[i]] <- with(dat,
+                                                                        matrix(0, N_between + N_both + N_within,
+                                                                               N_between + N_both + N_within))
+    }
+    dat$cov_d_full <- cov_d_full
   } else {
     dat$nclus <- array(1, 2)
     dat$cluster_size <- array(1, 1)
@@ -1111,6 +1126,8 @@ lav2standata <- function(lavobject) {
     dat$mean_d <- array(0, c(1, 0))
     dat$cov_w <- array(0, c(0, 0))
     dat$cov_d <- array(0, c(1, 0, 0))
+    dat$mean_d_full <- array(0, c(1, 0))
+    dat$cov_d_full <- array(0, c(1, 0, 0))
   } # multilevel
   
   if (ord) {

---FILE: R/stanmarg_data.R---
@@ -216,7 +216,8 @@ stanmarg_data <- function(YX = NULL, S = NULL, YXo = NULL, N, Ng, grpnum, # data
                           dumlv = NULL, # for sampling lvs
                           wigind = NULL, # wiggle indicator
                           pri_only = FALSE, # prior predictive sampling
-                          mean_d, cov_w, cov_d, nclus, cluster_size, ncluster_sizes, # level 2 data
+                          mean_d, cov_w, cov_d, nclus, cluster_size, ncluster_sizes,
+                          mean_d_full, cov_d_full,              # level 2 data
                           cluster_sizes, cluster_size_ns, between_idx, N_between, within_idx,
                           N_within, both_idx, N_both, ov_idx1, ov_idx2, p_tilde, N_lev,
                           Lambda_y_skeleton_c = NULL, # level 2 matrices
@@ -314,6 +315,8 @@ stanmarg_data <- function(YX = NULL, S = NULL, YXo = NULL, N, Ng, grpnum, # data
   dat$mean_d <- mean_d
   dat$cov_w <- cov_w
   dat$cov_d <- cov_d
+  dat$mean_d_full <- mean_d_full
+  dat$cov_d_full <- cov_d_full
   dat$nclus <- nclus
   dat$cluster_size <- cluster_size
   dat$ncluster_sizes <- ncluster_sizes

---FILE: src/stan_files/stanmarg.stan---
@@ -174,8 +174,8 @@ functions { // you can use these in R following `rstan::expose_stan_functions(""f
       B[clz] = q_zz + 2 * q_yz - q_yyc;
     }
 
-    q_W = (nperclus - 1) * sum(Sigma_w_inv .* S_PW);
-    L_W = (nperclus - 1) * Sigma_w_ld;
+    q_W = (nperclus - to_vector(clus_size_ns)) * sum(Sigma_w_inv .* S_PW);
+    L_W = (nperclus - to_vector(clus_size_ns)) * Sigma_w_ld;
 
     loglik = -.5 * ((L .* to_vector(clus_size_ns)) + (B .* to_vector(clus_size_ns)) + q_W + L_W);
     // add constant, line 300 lav_mvnorm_cluster
@@ -482,6 +482,8 @@ data {
   vector[p_tilde] mean_d[ncluster_sizes]; // sample means by unique cluster size
   matrix[p_tilde, p_tilde] cov_d[ncluster_sizes]; // sample covariances by unique cluster size
   matrix[p_tilde, p_tilde] cov_w; // observed ""within"" covariance matrix
+  vector[p_tilde] mean_d_full[nclus[2]]; // sample means/covs by cluster, for clusterwise log-densities
+  matrix[p_tilde, p_tilde] cov_d_full[nclus[2]];
   int N_within; // number of within variables
   int N_between; // number of between variables
   int N_both; // number of variables at both levels
@@ -721,6 +723,7 @@ transformed data { // (re)construct skeleton matrices in Stan (not that interest
   matrix[m_c, m_c] I_c = diag_matrix(rep_vector(1, m_c));
   
   int Ncont = p + q - Nord;
+  int<lower = 0> intone[nclus[2] > 1 ? nclus[2] : 0];
   
   int g_start1[Ng,2];
   int g_start4[Ng,2];
@@ -963,6 +966,9 @@ transformed data { // (re)construct skeleton matrices in Stan (not that interest
     }
   }
 
+  // for clusterwise loglik computations
+  if (nclus[2] > 1) for (i in 1:nclus[2]) intone[i] = 1;
+  
   if (!ord && use_suff) {
     // sufficient stat matrices by pattern, moved to left for missing
     for (patt in 1:Np) {
@@ -1419,7 +1425,7 @@ generated quantities { // these matrices are saved in the output but do not figu
   vector[len_free_c[9]] Psi_var_c;
 
   // loglik + ppp
-  vector[Ntot] log_lik; // for loo, etc
+  vector[nclus[2] > 1 ? nclus[2] : Ntot] log_lik; // for loo, etc
   vector[Ntot] log_lik_sat; // for ppp
   vector[p + q] YXstar_rep[Ntot]; // artificial data
   vector[Ntot] log_lik_rep; // for loo, etc
@@ -1584,6 +1590,13 @@ generated quantities { // these matrices are saved in the output but do not figu
     }
     
     // compute log-likelihoods
+    if (nclus[2] > 1) { // multilevel
+      log_lik = twolevel_logdens(mean_d_full, cov_d_full, S_PW[1], nclus, cluster_size, cluster_size,
+				 nclus[2], intone, Mu[1], Sigma[1], Mu_c[1], Sigma_c[1],
+				 ov_idx1, ov_idx2, within_idx, between_idx, both_idx,
+				 Xvar[1], p_tilde, N_within, N_between, N_both, 0.0);
+    }
+
     zmat = rep_matrix(0, p + q, p + q);
     for (mm in 1:Np) {
       obsidx = Obsvar[mm,];
@@ -1594,7 +1607,9 @@ generated quantities { // these matrices are saved in the output but do not figu
       grpidx = grpnum[mm];
       
       for (jj in r1:r2) {
-	log_lik[jj] = multi_normal_suff(YXstar[jj, 1:Nobs[mm]], zmat[1:Nobs[mm], 1:Nobs[mm]], Mu[grpidx, obsidx[1:Nobs[mm]]], Sigmainv[mm], 1);
+	if (nclus[2] == 1) {
+	  log_lik[jj] = multi_normal_suff(YXstar[jj, 1:Nobs[mm]], zmat[1:Nobs[mm], 1:Nobs[mm]], Mu[grpidx, obsidx[1:Nobs[mm]]], Sigmainv[mm], 1);
+	}
 	if (do_test) {
 	  // we add loglik[jj] here so that _sat always varies and does not lead to
 	  // problems with rhat and neff computations"
ecmerkle,blavaan,c07f6c968a47044b84ed068d74a6bdbd60158afd,ecmerkle,merklee@missouri.edu,2023-01-15T19:24:46Z,ecmerkle,merklee@missouri.edu,2023-01-15T19:24:46Z,fix the same nu/alpha prior issue for target='jags',DESCRIPTION;R/lav_export_mcmc.R;R/set_priors.R,False,True,True,False,5,3,8,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-4.1013
+Version: 0.4-4.1014
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lav_export_mcmc.R---
@@ -477,7 +477,7 @@ lav2mcmc <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
   TPS <- paste(TPS, ""\n"", t1, ""}"", sep="""")
 
   ## priors/constraints
-  TXT2 <- set_parvec(TXT2, partable, dp, cp, lv.x.wish, orig.lv.names.x, target)
+  TXT2 <- set_parvec(TXT2, partable, dp, cp, lv.x.wish, orig.lv.names.x, orig.ov.names, target)
   partable$prior <- TXT2$partable$prior
   partable$freeparnums <- TXT2$partable$freeparnums
   TXT3 <- TXT2$TXT3

---FILE: R/set_priors.R---
@@ -1,4 +1,4 @@
-set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x, target=""jags""){
+set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x, ov.names, target=""jags""){
     ## tabs
     t1 <- paste(rep("" "", 2L), collapse="""")
     t2 <- paste(rep("" "", 4L), collapse="""")
@@ -156,6 +156,8 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x, target=""ja
                     } else if(grepl(""star"", partable$mat[i])){
                         pname <- paste(""i"", strsplit(partable$mat[i], ""star"")[[1]][1], sep="""")
                         partype <- grep(pname, names(dp))
+                    } else if(partable$mat[i] == ""alpha"" & partable$lhs[i] %in% ov.names) {
+                      partype <- ""nu""
                     } else {
                         partype <- grep(partable$mat[i], names(dp))
                     }"
ecmerkle,blavaan,0c450fd9744579f76bd9e7dfcf7d42bb50fab027,ecmerkle,merklee@missouri.edu,2022-12-09T15:43:50Z,ecmerkle,merklee@missouri.edu,2022-12-09T15:43:50Z,fix crashes for 1-level models,R/blavaan.R;R/lav_export_stanmarg.R,False,True,True,False,3,3,6,"---FILE: R/blavaan.R---
@@ -768,7 +768,7 @@ blavaan <- function(...,  # default lavaan arguments
             ##parests$vcorr <- ## need level 1 by level 2!
             parests$sd <- c(parests$sd, parests2$sd)
           } else {
-            parests <- coeffun_stanmarg(lavpartable, lavInspect(LAV, 'free')$within, l2s$free2, jagtrans$data, res, colnames(draw_mat))
+            parests <- coeffun_stanmarg(lavpartable, lavInspect(LAV, 'free'), l2s$free2, jagtrans$data, res, colnames(draw_mat))
           }
           parests$vcorr <- cor(draw_mat[, with(parests$lavpartable, stansumnum[free > 0]), drop=FALSE])
           stansumm <- parests$stansumm

---FILE: R/lav_export_stanmarg.R---
@@ -892,8 +892,8 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, dmnames
           samppar <- (tmpw[,1] == 0) | (tmpw[,3] == 1) # free or constrained prior
           parvec <- tmpsd <- rowvec <- rowvec2 <- rep(NA, NROW(tmpw))
           if(level == 1L){
-            rowvec[samppar] <- which(grepl(stanvec[j], names(b.est)) & !(grepl(""_c"", names(b.est))))
-            rowvec2[samppar] <- which(grepl(stanvec[j], dmnames) & !(grepl(""_c"", dmnames)))
+            rowvec[samppar] <- which(grepl(stanvec[j], names(b.est)) & !(grepl(""_c$"", names(b.est))))
+            rowvec2[samppar] <- which(grepl(stanvec[j], dmnames) & !(grepl(""_c$"", dmnames)))
           } else {
             rowvec[samppar] <- grep(stanvec[j], names(b.est))
             rowvec2[samppar] <- grep(stanvec[j], dmnames)"
ecmerkle,blavaan,69325366394c4118b5cec0d3fb1660d229a65f8f,ecmerkle,merklee@missouri.edu,2022-12-07T20:24:19Z,ecmerkle,merklee@missouri.edu,2022-12-07T20:24:19Z,fix post-estimation multilevel parameter summaries,R/blavaan.R;R/lav_export_stanmarg.R,False,True,True,False,16,16,32,"---FILE: R/blavaan.R---
@@ -758,17 +758,19 @@ blavaan <- function(...,  # default lavaan arguments
                                   res)
           stansumm <- parests$stansumm
         } else {
+          draw_mat <- as.matrix(res)
           if(""level"" %in% names(lavpartable)) {
-            parests <- coeffun_stanmarg(lavpartable, lavInspect(LAV, 'free')$within, l2s$free2, jagtrans$data, res)
-            parests2 <- coeffun_stanmarg(lavpartable, lavInspect(LAV, 'free')[[2]], l2s$free2, jagtrans$data, res, level = 2L)
-            parests$x <- c(parests$x parests2$x)
-            ##parests$lavpartable <- ## combine list elements!
+            parests <- coeffun_stanmarg(lavpartable, lavInspect(LAV, 'free')$within, l2s$free2, jagtrans$data, res, colnames(draw_mat))
+            parests2 <- coeffun_stanmarg(lavpartable, lavInspect(LAV, 'free')[[2]], l2s$free2, jagtrans$data, res, colnames(draw_mat), level = 2L)
+            parests$x <- c(parests$x, parests2$x)
+            ## combine list elements of the partables
+            parests$lavpartable <- mapply(""c"", parests$lavpartable, parests2$lavpartable, SIMPLIFY = FALSE)
             ##parests$vcorr <- ## need level 1 by level 2!
             parests$sd <- c(parests$sd, parests2$sd)
-            browser()
           } else {
-            parests <- coeffun_stanmarg(lavpartable, lavInspect(LAV, 'free')$within, l2s$free2, jagtrans$data, res)
+            parests <- coeffun_stanmarg(lavpartable, lavInspect(LAV, 'free')$within, l2s$free2, jagtrans$data, res, colnames(draw_mat))
           }
+          parests$vcorr <- cor(draw_mat[, with(parests$lavpartable, stansumnum[free > 0]), drop=FALSE])
           stansumm <- parests$stansumm
         }
         x <- parests$x

---FILE: R/lav_export_stanmarg.R---
@@ -766,12 +766,12 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
 }
 
 
-coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, level = 1L, fun = ""mean"") {
+coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, dmnames, level = 1L, fun = ""mean"") {
   ## Extract posterior means from marginal stan model.
   ## free2 comes from lav2lers().
   ## lersdat is data passed to sem stan code.
   ## rsob is the result of sampling().
-  if (!(level %in% c(1L, 2L))) stop(""blavaan ERROR: Bad level specification in coeffun."", call. = FALSE)
+  if (!(level %in% c(1L, 2L))) stop(""blavaan ERROR: Bad level specification in coeffun()."", call. = FALSE)
   
   stanfit <- !is.null(rsob)
   if(stanfit){
@@ -783,6 +783,8 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, level =
       b.est <- rssumm$summary[,""mean""]
     } else if(fun == ""median""){
       b.est <- rssumm$summary[,""50%""]
+    } else {
+      stop(paste0(""blavaan ERROR: "", fun, "" not implemented in coeffun().""), call. = FALSE)
     }
     sd.est <- rssumm$summary[,""sd""]
   }
@@ -851,9 +853,8 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, level =
     nfree <- nfree - minpar + 1
   }
 
+  vcorr <- NULL
   if(stanfit){
-    draw_mat <- as.matrix(rsob)
-
     freevec <- rep(NA, nfree)
     rowidx <- rowidx2 <- rep(NA, nfree) # row index of stan est and summary containing the parameters (for vcorr)
 
@@ -892,10 +893,10 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, level =
           parvec <- tmpsd <- rowvec <- rowvec2 <- rep(NA, NROW(tmpw))
           if(level == 1L){
             rowvec[samppar] <- which(grepl(stanvec[j], names(b.est)) & !(grepl(""_c"", names(b.est))))
-            rowvec2[samppar] <- which(grepl(stanvec[j], colnames(draw_mat)) & !(grepl(""_c"", colnames(draw_mat))))
+            rowvec2[samppar] <- which(grepl(stanvec[j], dmnames) & !(grepl(""_c"", dmnames)))
           } else {
             rowvec[samppar] <- grep(stanvec[j], names(b.est))
-            rowvec2[samppar] <- grep(stanvec[j], colnames(draw_mat))
+            rowvec2[samppar] <- grep(stanvec[j], dmnames)
           }
           parvec[samppar] <- b.est[rowvec[samppar]]
           tmpsd[samppar] <- sd.est[rowvec[samppar]]
@@ -915,9 +916,7 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, level =
       }
     }
 
-    vcorr <- cor(draw_mat[, rowidx2, drop=FALSE])
-
-    names(sdvec) <- colnames(vcorr)
+    names(sdvec) <- dmnames[rowidx2]
 
     ## add to partable for other functions
     ## indexing of stan objects
@@ -936,7 +935,6 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, level =
     lavpartable$pxnames[lavpartable$free > 0] <- rownames(rssumm$summary)[rowidx2]
   } else {
     sdvec <- NULL
-    vcorr <- NULL
     rssumm <- list(summary = NULL)
   }
   "
ecmerkle,blavaan,55f56d737c3797ed591cc6c4b45447af62edb4d9,ecmerkle,merklee@missouri.edu,2022-11-29T01:44:08Z,ecmerkle,merklee@missouri.edu,2022-11-29T01:44:08Z,bug fixes and some efficiency improvements,R/lav_export_stanmarg.R;src/stan_files/stanmarg.stan,False,True,True,False,16,13,29,"---FILE: R/lav_export_stanmarg.R---
@@ -1035,7 +1035,7 @@ lav2standata <- function(lavobject) {
     dat$cluster_size_ns <- Lp$cluster.size.ns[[2]]
     dat$between_idx <- Lp$between.idx[[2]]
     dat$N_between <- length(dat$between_idx)
-    dat$within_idx <- Lp$within.idx[[2]]
+    dat$within_idx <- array(Lp$within.idx[[2]], length(Lp$within.idx[[2]]))
     dat$N_within <- length(dat$within_idx)
     dat$both_idx <- Lp$both.idx[[2]]
     dat$N_both <- length(dat$both_idx)

---FILE: src/stan_files/stanmarg.stan---
@@ -477,13 +477,13 @@ data {
   int<lower=1> ncluster_sizes; // number of unique cluster sizes
   int<lower=1> cluster_sizes[ncluster_sizes]; // unique cluster sizes
   int<lower=1> cluster_size_ns[ncluster_sizes]; // number of clusters of each size
-  vector[p_c] mean_d[ncluster_sizes]; // sample means by unique cluster size
-  matrix[p_c, p_c] cov_d[ncluster_sizes]; // sample covariances by unique cluster size
+  int p_tilde; // total number of variables
+  vector[p_tilde] mean_d[ncluster_sizes]; // sample means by unique cluster size
+  matrix[p_tilde, p_tilde] cov_d[ncluster_sizes]; // sample covariances by unique cluster size
   int N_within; // number of within variables
   int N_between; // number of between variables
   int N_both; // number of variables at both levels
   int N_lev[2]; // number of observed variables at each level
-  int p_tilde; // total number of variables
   int within_idx[N_within];
   int between_idx[p_tilde]; // between indexing, followed by within/both
   int ov_idx1[N_lev[1]];
@@ -961,7 +961,7 @@ transformed data { // (re)construct skeleton matrices in Stan (not that interest
     }
   }
 
-  if (!ord) {
+  if (!ord && use_suff) {
     // sufficient stat matrices by pattern, moved to left for missing
     for (patt in 1:Np) {
       Sstar[patt] = rep_matrix(0, p + q, p + q);
@@ -1131,10 +1131,11 @@ transformed parameters {
         Sigma_c[g, 1:p_c, 1:p_c] += quad_form_sym(Psi_c[g], transpose(Lambda_y_A_c[g]));
 	Mu_c[g, 1:p_c] += to_vector(Lambda_y_A_c[g] * Alpha_c[g, 1:m_c, 1]);
       }
+    }
 
+    if (nclus[2] > 1) {
       // remove between variables, for likelihood computations
-      S_PW[g] = Sigma_c[g, between_idx[(N_between + 1):p_tilde], between_idx[(N_between + 1):p_tilde]];
-    }
+      S_PW[g] = Sigma[g, between_idx[(N_between + 1):p_tilde], between_idx[(N_between + 1):p_tilde]];  }
   }
 
   
@@ -1256,12 +1257,14 @@ transformed parameters {
   }
 
   // for computing mvn with sufficient stats
-  for (g in 1:Ng) {
-    Sigmainv_grp[g] = inverse_spd(Sigma[g]);
-    logdetSigma_grp[g] = log_determinant(Sigma[g]);
-  }
-  for (patt in 1:Np) {    
-    Sigmainv[patt, 1:(Nobs[patt] + 1), 1:(Nobs[patt] + 1)] = sig_inv_update(Sigmainv_grp[grpnum[patt]], Obsvar[patt,], Nobs[patt], p + q, logdetSigma_grp[grpnum[patt]]);
+  if (use_suff) {
+    for (g in 1:Ng) {
+      Sigmainv_grp[g] = inverse_spd(Sigma[g]);
+      logdetSigma_grp[g] = log_determinant(Sigma[g]);
+    }
+    for (patt in 1:Np) {    
+      Sigmainv[patt, 1:(Nobs[patt] + 1), 1:(Nobs[patt] + 1)] = sig_inv_update(Sigmainv_grp[grpnum[patt]], Obsvar[patt,], Nobs[patt], p + q, logdetSigma_grp[grpnum[patt]]);
+    }
   }
 }
 model { // N.B.: things declared in the model block do not get saved in the output, which is okay here"
ecmerkle,blavaan,631f869c512206d99b048a9cc8b35644ed17dc00,ecmerkle,merklee@missouri.edu,2022-11-11T23:25:24Z,ecmerkle,merklee@missouri.edu,2022-11-11T23:25:24Z,"stanmarg, fix situations where there are missing data in one group but not the other",DESCRIPTION;R/lav_export_stanmarg.R;vignettes/refs.bib,False,True,True,False,5,5,10,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-4.1001
+Version: 0.4-4.1002
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lav_export_stanmarg.R---
@@ -903,7 +903,7 @@ lav2standata <- function(lavobject) {
     dat$grpnum <- rep(1:dat$Ng, npatt)
 
     dat$Nobs <- do.call(""c"", lapply(Mp, function(x) rowSums(x$pat)))
-    Obsvar <- do.call(""c"", lapply(Mp, function(x) apply(x$pat, 1, which)))
+    Obsvar <- do.call(""c"", lapply(Mp, function(x) apply(x$pat, 1, which, simplify = FALSE)))
     
     dat$Np <- length(unique(misgrps))
     dat$Ntot <- sum(dat$N)
@@ -965,7 +965,7 @@ lav2standata <- function(lavobject) {
     if (misflag) {
       dat$Noent <- sum(dat$YXo > 0)
       dat$Nordobs <- do.call(""c"", lapply(Mp, function(x) rowSums(x$pat[,ordidx])))
-      OrdObsvar <- do.call(""c"", lapply(Mp, function(x) apply(x$pat[,ordidx], 1, which)))
+      OrdObsvar <- do.call(""c"", lapply(Mp, function(x) apply(x$pat[,ordidx], 1, which, simplify = FALSE)))
 
       dat$OrdObsvar <- matrix(0, dat$Np, ncol(dat$YXo))
       allvars <- 1:ncol(dat$YXo)

---FILE: vignettes/refs.bib---
@@ -145,14 +145,14 @@ @ARTICLE{gen92
 
 @Manual{azzgen20,
     title = {The {R} package \texttt{mnormt}: The multivariate normal and $t$ distributions (version 2.0.2)},
-    author = {Adelchi Azzalini and Alan Genz},
+    author = {A. Azzalini and A. Genz},
     year = {2020},
     url = {http://azzalini.stat.unipd.it/SW/Pkg-mnormt/}
 }
 
 @Manual{genhot21,
   title = {{mvtnorm}: Multivariate Normal and t Distributions},
-  author = {Alan Genz and Frank Bretz and Tetsuhisa Miwa and Xuefei Mi and Friedrich Leisch and Fabian Scheipl and Torsten Hothorn},
+  author = {A. Genz and F. Bretz and T. Miwa and X. Mi and F. Leisch and F. Scheipl and T. Hothorn},
   year = {2021},
   note = {R package version 1.1-3},
   url = {https://CRAN.R-project.org/package=mvtnorm}"
ecmerkle,blavaan,2f621a6b494bb5227d0e3686f9a50a76a410ef41,ecmerkle,merklee@missouri.edu,2022-06-27T17:51:54Z,ecmerkle,merklee@missouri.edu,2022-06-27T17:51:54Z,more fixes for #54,DESCRIPTION;R/blav_fit_measures.R;R/blav_model_loglik.R;R/blav_predict.R;R/postpred.R;inst/testdata/sysdata.rda;inst/tinytest/tests.blavaan.R;tests/blavaan_examples.R,False,True,True,False,14,13,27,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-4.999
+Version: 0.4-4.1000
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_fit_measures.R---
@@ -71,7 +71,7 @@ blav_fit_measures <- function(object, fit.measures = ""all"",
     fx <- object@Fit@fx
     fx.group <- object@Fit@fx.group
     meanstructure <- object@Model@meanstructure
-    categorical   <- object@Model@categorical
+    categorical   <- lavInspect(object, ""categorical"")
     multigroup    <- object@Data@ngroups > 1L
     estimator     <- ""ML"" #object@Options$estimator
     test          <- object@Options$test
@@ -147,7 +147,7 @@ blav_fit_measures <- function(object, fit.measures = ""all"",
         indices[""ppp""] <- object@Fit@test[[2]]$stat
     }
     if(any(c(""bic"", ""dic"", ""p_dic"") %in% fit.measures & bopts$test != ""none"")) {
-        if(bopts$categorical && compareVersion(packageDescription('lavaan')$Version, '0.6-10') < 0) stop(""blavaan ERROR: lavaan 0.6-10 or higher is needed (you may need to install from github)"")
+        if(lavInspect(object, ""categorical"") && compareVersion(packageDescription('lavaan')$Version, '0.6-10') < 0) stop(""blavaan ERROR: lavaan 0.6-10 or higher is needed (you may need to install from github)"")
         df <- 2*(object@Fit@fx - mean(as.numeric(object@external$samplls[,,1])))
         indices[""bic""] <- -2*object@Fit@fx + npar*log(N)
         indices[""dic""] <- -2*object@Fit@fx + 2*df
@@ -178,12 +178,13 @@ blav_fit_measures <- function(object, fit.measures = ""all"",
     }
     if(any(c(""waic"", ""p_waic"", ""looic"", ""p_loo"") %in% fit.measures)) {
         lavopt <- object@Options
+        catmod <- lavInspect(object, ""categorical"")
         lavopt$estimator <- ""ML""
-        if(lavopt$target == ""stan"" && !lavopt$categorical){
+        if(lavopt$target == ""stan"" && !catmod){
           casells <- loo::extract_log_lik(object@external$mcmcout)
         } else {
-          if(lavopt$categorical & lavopt$test != ""none""){
-            if(bopts$categorical && compareVersion(packageDescription('lavaan')$Version, '0.6-10') < 0) stop(""blavaan ERROR: lavaan 0.6-10 or higher is needed (you may need to install from github)"")
+          if(catmod & lavopt$test != ""none""){
+            if(catmod && compareVersion(packageDescription('lavaan')$Version, '0.6-10') < 0) stop(""blavaan ERROR: lavaan 0.6-10 or higher is needed (you may need to install from github)"")
 
             if(""llnsamp"" %in% names(lavopt)){
               cat(""blavaan NOTE: These criteria involve likelihood approximations that may be imprecise.\n"",

---FILE: R/blav_model_loglik.R---
@@ -8,7 +8,7 @@ get_ll <- function(postsamp       = NULL, # one posterior sample
                    conditional    = FALSE,
                    standata       = NULL){
 
-    if(lavobject@Options$categorical){
+    if(lavInspect(lavobject, ""categorical"")){
       ll.samp <- get_ll_ord(postsamp, lavobject, measure, casewise, conditional, standata)
     } else {
       ll.samp <- get_ll_cont(postsamp, lavobject, measure, casewise, conditional)

---FILE: R/blav_predict.R---
@@ -29,7 +29,7 @@ blavPredict <- function(object, newdata = NULL, type = ""lv"") {
   lavopt <- lavInspect(object, ""options"")
   stantarget <- lavopt$target == ""stan""
 
-  if(lavopt$categorical & type == ""ymis"") stop(""blavaan ERROR: ymis is not yet implemented for ordinal models."", call. = FALSE)
+  if(lavInspect(object, ""categorical"") & type == ""ymis"") stop(""blavaan ERROR: ymis is not yet implemented for ordinal models."", call. = FALSE)
   
   if(!is.null(newdata)) stop(""blavaan ERROR: posterior predictions for newdata are not currently supported"")
   

---FILE: R/postpred.R---
@@ -29,6 +29,7 @@ postpred <- function(samplls = NULL, lavobject = NULL, measure = ""logl"", thin =
   lavpartable <- lavobject@ParTable
   lavmodel <- lavobject@Model
   lavoptions <- lavobject@Options
+  catmod <- lavInspect(lavobject, ""categorical"")
   lavsamplestats <- lavobject@SampleStats
   lavdata <- lavobject@Data
   lavcache <- lavobject@Cache
@@ -192,7 +193,7 @@ postpred <- function(samplls = NULL, lavobject = NULL, measure = ""logl"", thin =
         lavoptions2 <- lavoptions
         lavoptions2$verbose <- FALSE
         lavoptions2$estimator <- ""ML""
-        if(lavoptions2$categorical) lavoptions2$estimator <- ""DWLS""
+        if(catmod) lavoptions2$estimator <- ""DWLS""
         lavoptions2$se <- ""none""
         lavoptions2$test <- ""standard""
         lavoptions2$optim.method <- ""none""

---FILE: inst/tinytest/tests.blavaan.R---
@@ -86,7 +86,6 @@ expect_equal(class(bcfa(HS.model, data=HolzingerSwineford1939, target=""stanclass
 expect_equal(class(bcfa(HS.model, data=HolzingerSwineford1939, target=""jags"", do.fit=FALSE, group=""school"", group.equal=c(""intercepts"",""loadings""), wiggle=c(""intercepts""), wiggle.sd=.1))[1], ""blavaan"")
 
 ## moment match mcmcextra
-
 set.seed(341)
 
 x1 <- rnorm(100)

---FILE: tests/blavaan_examples.R---
@@ -34,13 +34,13 @@ fitstanfs <- bcfa(HS.model, data=HolzingerSwineford1939,
 
 ## this really blows up file size if kept:
 attr(fitstan@external$mcmcout, 'stanmodel') <- NULL
-attr(fitstan@external$mcmcout, 'sim') <- NULL
+#attr(fitstan@external$mcmcout, 'sim') <- NULL
 attr(fitstan@external$mcmcout, 'inits') <- NULL
 attr(fitstanc@external$mcmcout, 'stanmodel') <- NULL
-attr(fitstanc@external$mcmcout, 'sim') <- NULL
+#attr(fitstanc@external$mcmcout, 'sim') <- NULL
 attr(fitstanc@external$mcmcout, 'inits') <- NULL
 attr(fitstanfs@external$mcmcout, 'stanmodel') <- NULL
-attr(fitstanfs@external$mcmcout, 'sim') <- NULL
+#attr(fitstanfs@external$mcmcout, 'sim') <- NULL
 attr(fitstanfs@external$mcmcout, 'inits') <- NULL
 
 save(list=c(""fitjags"", ""fitstan"", ""fitstanc"", ""fitstanfs""), "
ecmerkle,blavaan,5aeef887e46770d6caf0aa0a3b56fd4607465da5,ecmerkle,merklee@missouri.edu,2022-06-27T15:51:12Z,ecmerkle,merklee@missouri.edu,2022-06-27T15:51:12Z,fixes #54,DESCRIPTION;R/blav_cond_utils.R;R/blav_model_loglik.R;R/blav_test.R;R/blavaan.R;vignettes/plotting.Rmd;vignettes/refs.bib,True,True,True,False,19,8,27,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-4.998
+Version: 0.4-4.999
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_cond_utils.R---
@@ -15,7 +15,7 @@ samp_kls <- function(lavjags        = NULL,
     ## need to implement plummer's approach of generating y_rep
     ##mis <- FALSE
     ##if(any(is.na(unlist(lavdata@X)))) mis <- TRUE
-    ##if(mis | lavoptions$categorical) stop(""blavaan ERROR: K-L divergence not implemented for missing data or ordinal variables."")
+    ##if(mis | lavInspect(lavobject, ""categorical"")) stop(""blavaan ERROR: K-L divergence not implemented for missing data or ordinal variables."")
 
     itnums <- sampnums(lavjags, thin = thin)
     lavmcmc <- lapply(lavmcmc, function(x) x[itnums,])

---FILE: R/blav_model_loglik.R---
@@ -165,7 +165,7 @@ get_ll_cont <- function(postsamp       = NULL, # one posterior sample
     lavoptions$se <- ""none""
     lavoptions$test <- ""standard""
     lavoptions$estimator <- ""ML""
-    if(lavoptions$categorical) lavoptions$estimator <- ""DWLS""
+    if(lavInspect(lavobject, ""categorical"")) lavoptions$estimator <- ""DWLS""
     ## control() is part of lavmodel (for now)
     lavoptions$optim.method <- ""none""
     lavoptions$check.gradient <- FALSE
@@ -450,7 +450,7 @@ samp_lls <- function(lavjags        = NULL,
 
   nchain <- length(lavmcmc)
 
-  if(lavoptions$target != ""stan"" | conditional | lavoptions$categorical) {
+  if(lavoptions$target != ""stan"" | conditional | lavInspect(lavobject, ""categorical"")) {
     loop.args <- list(X = 1:nsamps, future.seed = TRUE, FUN = function(i){
       tmpmat <- matrix(NA, nchain, 2)
       for(j in 1:nchain){

---FILE: R/blav_test.R---
@@ -21,7 +21,7 @@ blav_model_test <- function(lavmodel       = NULL,
     if(""syntax"" %in% names(jagextra)){
         warning(""blavaan WARNING: Marginal log-likelihood cannot be approximated when there is additional JAGS syntax."", call. = FALSE)
         mll <- NA
-    } else if(lavoptions$categorical){
+    } else if(lavInspect(lavobject, ""categorical"")) {
         mll <- NA # not tested, priors may cause problems
     } else {
         mll <- try(margloglik(lavpartable, lavmodel, lavoptions, 

---FILE: R/blavaan.R---
@@ -761,7 +761,7 @@ blavaan <- function(...,  # default lavaan arguments
                 }
                 ## lvs now in R instead of Stan
                 if(save.lvs & target == ""stan""){
-                    stanlvs <- samp_lvs(res, lavmodel, parests$lavpartable, jagtrans$data, lavoptions$categorical)
+                    stanlvs <- samp_lvs(res, lavmodel, parests$lavpartable, jagtrans$data, lavInspect(LAV, ""categorical""))
                     if(dim(stanlvs)[3L] > 0){
                         lvsumm <- as.matrix(rstan::monitor(stanlvs, print=FALSE))
                         cmatch <- match(colnames(stansumm), colnames(lvsumm))
@@ -832,7 +832,7 @@ blavaan <- function(...,  # default lavaan arguments
       lavmcmc <- make_mcmc(res)
       LAV@Options <- lavoptions
 
-      if(lavoptions$categorical) {
+      if(lavInspect(LAV, ""categorical"")) {
         LAV@external$mcmcdata <- rjarg$data
         casells <- case_lls(res, lavmcmc, lavobject = LAV)
         samplls <- array(0, dim = c(sample, n.chains, 2))

---FILE: vignettes/plotting.Rmd---
@@ -39,7 +39,7 @@ Many other plot types are available, coming from the *bayesplot* package. In gen
 
 
 ### Customization
-Users may wish to customize some aspects of the resulting plots. For this, the `plot()` function will output a *ggplot* object. This makes it possible to modify the plot as if it were any other *ggplot* object.
+Users may wish to customize some aspects of the resulting plots. For this, the `plot()` function will output a *ggplot* object. This makes it possible to modify the plot as if it were any other *ggplot* object, which allows for many possibilities. One starting point for exploring *ggplot2* is [here](https://ggplot2.tidyverse.org/).
 
 ```{r p2}
 p <- plot(fit, pars = 1:4, plot.type = ""trace"", showplot = FALSE)

---FILE: vignettes/refs.bib---
@@ -157,3 +157,14 @@ @Manual{genhot21
   note = {R package version 1.1-3},
   url = {https://CRAN.R-project.org/package=mvtnorm}
 }
+
+@Article{tlrmvnmvt,
+    title = {{tlrmvnmvt}: Computing High-Dimensional Multivariate Normal and {S}tudent-$t$ Probabilities with Low-Rank Methods in {R}},
+    author = {Jian Cao and Marc G. Genton and David E. Keyes and George M. Turkiyyah},
+    journal = {Journal of Statistical Software},
+    year = {2022},
+    volume = {101},
+    number = {4},
+    pages = {1--25},
+    doi = {10.18637/jss.v101.i04},
+}
\ No newline at end of file"
ecmerkle,blavaan,853d2b805d442dcf87100a66728d6a75b6824a93,ecmerkle,merklee@missouri.edu,2022-06-02T02:49:01Z,ecmerkle,merklee@missouri.edu,2022-06-02T02:49:01Z,fixes #53,DESCRIPTION;R/blav_predict.R,False,True,True,False,5,2,7,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-4.997
+Version: 0.4-4.998
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_predict.R---
@@ -45,7 +45,10 @@ blavPredict <- function(object, newdata = NULL, type = ""lv"") {
     N <- sum(lavInspect(object, ""ntotal""))
     etas <- lavNames(object, ""lv"")
 
-    out <- lapply(1:NROW(FS), function(i) matrix(FS[i,], N, length(etas)))
+    out <- lapply(1:NROW(FS), function(i) {
+      rowmat <- matrix(FS[i,], N, length(etas))
+      colnames(rowmat) <- etas
+      rowmat } )
   } else if(type == ""lvmeans"") {
     out <- blavInspect(object, 'lvmeans')
   } else if(type %in% c(""yhat"", ""ypred"", ""ymis"")) {"
ecmerkle,blavaan,fbaf2f87254245428dd5efb7acad4b590446916a,ecmerkle,merklee@missouri.edu,2022-05-16T16:10:50Z,ecmerkle,merklee@missouri.edu,2022-05-16T16:10:50Z,fix version dependencies,DESCRIPTION,False,False,False,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-4.994
+Version: 0.4-4.995
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",
@@ -37,7 +37,7 @@ ByteCompile: true
 Depends: R(>= 3.5.0), methods, lavaan(>= 0.6-10), Rcpp(>= 0.12.15)
 Imports: stats, utils, graphics, coda, mnormt, nonnest2(>= 0.5-5), loo(>= 2.0), rstan(>= 2.21.2), rstantools(>= 1.5.0), RcppParallel (>= 5.0.1), bayesplot, Matrix, future.apply, tmvnsim
 LinkingTo: StanHeaders (>= 2.18.1), rstan (>= 2.21.2), BH (>= 1.69.0), Rcpp (>= 0.12.15), RcppEigen (>= 0.3.3.4.0), RcppParallel (>= 5.0.1)
-Suggests: runjags(>= 2.0.4-4.994
+Suggests: runjags(>= 2.0.4-3)
 SystemRequirements: GNU make
 NeedsCompilation: yes
 Additional_repositories: https://mc-stan.org/r-packages/"
ecmerkle,blavaan,33ca5ba2c6b0d81338ee75a481d76a12f199630e,ecmerkle,merklee@missouri.edu,2022-05-10T19:24:14Z,ecmerkle,merklee@missouri.edu,2022-05-10T19:24:14Z,fix check issues,NAMESPACE;R/blav_adapt_quad.R;R/blav_predict.R;R/lvgqs.R;inst/testdata/sysdata.rda;inst/tinytest/tests.blavaanobject-methods.R,False,True,True,False,21,12,33,"---FILE: NAMESPACE---
@@ -7,7 +7,8 @@ importFrom(""utils"",
            ""capture.output"", ""head"", ""tail"", ""getFromNamespace"", ""compareVersion"")
 
 importFrom(""stats"",
-           ""approx"", ""density"", ""median"", ""dnorm"", ""pnorm"", ""rgamma"", ""rnorm"",
+           ""approx"", ""density"", ""median"",
+           ""dbinom"", ""dnorm"", ""pnorm"", ""rgamma"", ""rnorm"",
            ""runif"", ""sd"", ""quantile"", ""rWishart"", ""cov"", ""cor"",
            ""coef"", ""logLik"",
            ""residuals"", ""resid"",

---FILE: R/blav_adapt_quad.R---
@@ -26,8 +26,8 @@ adapted_ghq <- function(fit, ngq, samprow = NULL) {
   for(i in 1:nqpt){
     samps[samprow,grep(""^eta"", colnames(samps))] <- as.numeric( sapply(1:length(etamncov[[1]]), function(k) x.star.list[[k]][i,]) )
 
-    out[,i] <- blavaan:::get_ll(postsamp = samps[samprow,], fit,
-                                casewise = TRUE, conditional = TRUE)
+    out[,i] <- get_ll(postsamp = samps[samprow,], fit,
+                      casewise = TRUE, conditional = TRUE)
   }
 
   out <- exp(out) * do.call(""rbind"", w.star.list)
@@ -46,7 +46,8 @@ fixed_ghq <- function(fit, ngq, samprow = NULL) {
   samps <- do.call(""rbind"", make_mcmc(fit@external$mcmcout, fit@external$stanlvs))
   if(length(samprow) > 0) samps <- samps[samprow, , drop = FALSE]
 
-  XW <- lavaan:::lav_integration_gauss_hermite(n = ngq, ndim = ndim, dnorm = TRUE)
+  lavigh <- getFromNamespace(""lav_integration_gauss_hermite"", ""lavaan"")
+  XW <- lavigh(n = ngq, ndim = ndim, dnorm = TRUE)
   x.star <- XW$x
   x.star.eval <- apply(XW$x, 2, unique)
   w.star <- XW$w
@@ -141,21 +142,24 @@ fixed_ghq <- function(fit, ngq, samprow = NULL) {
 adapted_weights <- function(samps, ngq, alphas, psis, grpidx, etamns, etacovs, N) {
   ## adapt gh nodes/weights to each case
   ndim <- NROW(alphas[[1]])
-  XW <- lavaan:::lav_integration_gauss_hermite(n = ngq, ndim = ndim, dnorm = TRUE)
+  lavigh <- getFromNamespace(""lav_integration_gauss_hermite"", ""lavaan"")
+  lavdmvnorm <- getFromNamespace(""lav_mvnorm_dmvnorm"", ""lavaan"")
+  
+  XW <- lavigh(n = ngq, ndim = ndim, dnorm = TRUE)
   eXWxcp <- exp(0.5 * apply(XW$x, 1, crossprod))
 
   x.star.list <- vector(""list"", length(etamns))
   w.star.list <- vector(""list"", length(etamns))
   XW2pi <- XW$w * (2*pi)^(ndim/2)
 
   for(i in 1:N) {
-    C <- t(chol(etacovs[[j]]))
+    C <- t(chol(etacovs[[i]]))
     tmpmn <- as.numeric(etamns[[i]])
 
     x.star.list[[i]] <- t(as.matrix(C %*% t(XW$x)) + tmpmn)
     w.star.list[[i]] <- XW2pi * eXWxcp * prod(diag(C)) * ## = det(C) for triangular matrix
-      lavaan:::lav_mvnorm_dmvnorm(x.star.list[[i]], Mu = alphas[[grpidx[i]]],
-                                  Sigma = psis[[grpidx[i]]], log = FALSE)
+      lavdmvnorm(x.star.list[[i]], Mu = alphas[[grpidx[i]]],
+                 Sigma = psis[[grpidx[i]]], log = FALSE)
   }
   
   list(x.star.list, w.star.list)

---FILE: R/blav_predict.R---
@@ -25,9 +25,12 @@ blavPredict <- function(object, newdata = NULL, type = ""lv"") {
       type <- ""ymis""
       if(all(!is.na(unlist(blavdata@X)))) stop(""blavaan ERROR: No missing data are present."", call. = FALSE)
   }
-      
-  stantarget <- lavInspect(object, ""options"")$target == ""stan""
 
+  lavopt <- lavInspect(object, ""options"")
+  stantarget <- lavopt$target == ""stan""
+
+  if(lavopt$categorical & type == ""ymis"") stop(""blavaan ERROR: ymis is not yet implemented for ordinal models."", call. = FALSE)
+  
   if(!is.null(newdata)) stop(""blavaan ERROR: posterior predictions for newdata are not currently supported"")
   
   ## lv: posterior dist of lvs (use blavInspect functionality); matrix frame

---FILE: R/lvgqs.R---
@@ -269,5 +269,5 @@ if(FALSE){
               mcmcfile = TRUE)
   load('lavExport/semstan.rda')
 
-  blavaan:::samp_lvs(fit@external$mcmcout, fit@Model, fit@ParTable, stantrans$data)
+  samp_lvs(fit@external$mcmcout, fit@Model, fit@ParTable, stantrans$data)
 }

---FILE: inst/tinytest/tests.blavaanobject-methods.R---
@@ -161,7 +161,8 @@ if(requireNamespace(""rstan"", quietly = TRUE) &
   expect_error(blavPredict(fitstanc))
   expect_error(blavPredict(fitjags))
   
-  expect_equal(dim(blavPredict(fitstanfs)), c(20,602))
+  expect_equal(dim(blavPredict(fitstanfs)[[1]]), c(301,2))
+  expect_equal(length(blavPredict(fitstanfs)), 20)
   expect_equal(dim(blavPredict(fitstanfs, type=""lvmeans"")), c(301,2))
   expect_equal(dim(blavPredict(fitstanfs, type=""ov"")[[1]]), c(301,6))
   expect_equal(dim(blavPredict(fitstanfs, type=""ypred"")[[1]]), c(301,6))"
ecmerkle,blavaan,8bb45358f07101b3c62698b7cb526dfaf498a7a3,ecmerkle,merklee@missouri.edu,2022-05-09T15:18:01Z,ecmerkle,merklee@missouri.edu,2022-05-09T15:18:01Z,fix indexing of blavInspect lvs/lvmeans for multiple groups + missing data,NEWS.md;R/blav_object_inspect.R,False,True,True,False,19,23,42,"---FILE: NEWS.md---
@@ -7,6 +7,8 @@
 ##  Bugs/glitches discovered after the release:
 * blavPredict(, type=""ymis"") is not working for models with ordinal variables
 
+* blavInspect(, 'lvs') or (, 'lvmeans') can fail for models with a combination of multiple groups, missing values, and excluded cases
+
 * blavFitIndices() and ppmc() are not working for models with ordinal variables, or may indicate excessively bad fit
 
 * blavFitIndices(, rescale=""mcmc"") fails

---FILE: R/blav_object_inspect.R---
@@ -135,35 +135,28 @@ blavInspect <- function(blavobject, what, ...) {
             ## for target=""stan"" + missing, use @Data@Mp to reorder rows to correspond
             ## to original data
             mis <- any(is.na(unlist(blavobject@Data@X)))
+            Mp <- blavobject@Data@Mp
             if(blavobject@Options$target == ""stan"" & mis){
-                rorig <- sapply(blavobject@Data@Mp, function(x) unlist(x$case.idx))
-                cids <- sapply(blavobject@Data@Mp, function(x) x$case.idx)
-                ## reordering for lvmeans:
-                if(nlv > 1){
-                    norig <- length(rorig)
-                    rord <- rep(NA, nlv*norig)
-                    for(i in 1:nlv){
-                        rord[((i-1)*norig + 1):(i*norig)] <- i*rorig
+                rorig <- sapply(Mp, function(x) unlist(x$case.idx))
+                empties <- sapply(Mp, function(x) x$empty.idx)
+                if(inherits(rorig, ""list"")){
+                    ## multiple groups
+                    for(ii in length(rorig)){
+                        rorig[[ii]] <- blavobject@Data@case.idx[[ii]][rorig[[ii]]]
                     }
-                } else {
-                    rord <- rorig
+                    rorig <- unlist(rorig)
                 }
-                ## for lvs
-                rsamps <- rep(NA, nlv*norig)
+                cids <- Mp2dataidx(Mp, blavobject@Data@case.idx)
+
+                ## reordering for lvs:
+                nfit <- sum(lavInspect(blavobject, 'nobs'))
+                rsamps <- rep(NA, nlv*nfit)
                 for(j in 1:nlv){
-                    tmpsamp <- rep(NA, norig)
-                    cumn <- 0
-                    for(i in 1:length(cids)){
-                      tmpids <- cids[[i]]
-                      ncase <- length(tmpids)
-                      tmpsamp[(cumn + 1):(cumn + ncase)] <- (j-1)*norig + tmpids
-                      cumn <- cumn + ncase
-                    }
-                    rsamps[((j-1)*norig + 1):(j*norig)] <- tmpsamp
+                    rsamps[((j-1)*nfit + 1):(j*nfit)] <- (j-1)*nfit + cids
                 }
 
                 for(j in 1:length(draws)){
-                    draws[[j]][,rsamps] <- draws[[j]]#[,rsamps]
+                    draws[[j]][,rsamps] <- draws[[j]]
                 }
             }
             draws <- mcmc.list(draws)
@@ -183,8 +176,9 @@ blavInspect <- function(blavobject, what, ...) {
                 draws <- matrix(summ[mnrows,summname], nsamp,
                                 length(mnrows)/nsamp, byrow=br)[,1:nlv,drop=FALSE]
                 colnames(draws) <- names(lvmn)
+
                 if(blavobject@Options$target == ""stan"" & mis){
-                    draws[rorig,] <- draws
+                    draws[rank(rorig),] <- draws
                 }
             }
             draws"
ecmerkle,blavaan,d4adf521656a2773a0f2036224c9b52f353111bf,ecmerkle,merklee@missouri.edu,2022-05-06T01:49:59Z,ecmerkle,merklee@missouri.edu,2022-05-06T01:49:59Z,fix pripred=TRUE,DESCRIPTION;R/blavaan.R,False,True,True,False,5,5,10,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-2.983
+Version: 0.4-2.984
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blavaan.R---
@@ -826,19 +826,19 @@ blavaan <- function(...,  # default lavaan arguments
     }
 
     ## fx is mean ll, where ll is marginal log-likelihood (integrate out lvs)
+    casells <- NULL
     if(lavoptions$test != ""none"") {
       cat(""Computing posterior predictives...\n"")
       lavmcmc <- make_mcmc(res)
       LAV@Options <- lavoptions
 
-      if(!lavoptions$categorical) {
-        samplls <- samp_lls(res, lavmcmc, lavobject = LAV, standata = rjarg$data)
-        casells <- NULL
-      } else {
+      if(lavoptions$categorical) {
         LAV@external$mcmcdata <- rjarg$data
         casells <- case_lls(res, lavmcmc, lavobject = LAV)
         samplls <- array(0, dim = c(sample, n.chains, 2))
         samplls[,,1] <- rowSums(casells)
+      } else {
+        samplls <- samp_lls(res, lavmcmc, lavobject = LAV, standata = rjarg$data)
       }
       
       if(jags.ic) {"
ecmerkle,blavaan,b413b7f3cd038e0fda86ee86ed4266d401216a6a,ecmerkle,merklee@missouri.edu,2022-05-04T03:36:38Z,ecmerkle,merklee@missouri.edu,2022-05-04T03:36:38Z,working fixed quadrature method,R/blav_adapt_quad.R,False,True,True,False,19,11,30,"---FILE: R/blav_adapt_quad.R---
@@ -83,7 +83,7 @@ fixed_ghq <- function(fit, ngq, samprow = NULL) {
     ## for each entry in mnvec, compute univariate likelihoods for each set of thresholds
     ## a matrix per column of mnvec: number of rows in x.star.eval by number of ordered categories
     likevals <- array(NA, dim = c(NROW(x.star.eval), max(standata$YXo), NCOL(standata$YXo), Ng))
-browser()
+
     for(g in 1:Ng) {
       mm.in.group <- 1:lavmodel@nmat[g] + cumsum(c(0,lavmodel@nmat[g]))[g]
       mms <- lavmodel@GLIST[mm.in.group]
@@ -93,23 +93,31 @@ browser()
       for(j in 1:NCOL(standata$YXo)) {
         tmpidx <- unique(TH.idx[[g]])[j]
         tau <- c(-Inf, mms$tau[TH.idx[[g]] == tmpidx], Inf)
-        utau <- rep(tau[2:length(tau)], ncol(mnvec))
-        ltau <- rep(tau[1:(length(tau) - 1)], ncol(mnvec))
-        tmpprob <- pnorm(utau, mean = mnvec[tmpidx,], sd = sqrt(mms$theta[tmpidx, tmpidx])) -
-          pnorm(ltau, mean = mnvec[tmpidx,], sd = sqrt(mms$theta[tmpidx, tmpidx]))
+        utau <- tau[2:length(tau)]
+        ltau <- tau[1:(length(tau) - 1)]
+
+        for(k in 1:max(standata$YXo[,tmpidx])) {
+          tmpprob <- pnorm(utau[k], mean = mnvec[tmpidx,], sd = sqrt(mms$theta[tmpidx, tmpidx])) -
+            pnorm(ltau[k], mean = mnvec[tmpidx,], sd = sqrt(mms$theta[tmpidx, tmpidx]))
 
-        likevals[, 1:max(standata$YXo[,tmpidx]), j, g] <- log(tmpprob)
+          likevals[, k, j, g] <- log(tmpprob)
+        }
       }
     }
 
     ## for each response pattern, use x.star to pull values out of the above matrices and sum
     qpt.uniq <- matrix(NA, NROW(YXou), NROW(x.star))
+    diment <- apply(mms$lambda != 0, 1, which) ## FIXME only works for no cross-loadings
+    tmpmatch <- sapply(1:ndim, function(j) match(x.star[,j], x.star.eval[,j]))
 
     for(p in 1:NROW(x.star)) {
-      tmpmatch <- sapply(1:ndim, function(j) match(x.star[p,j], x.star.eval[,j]))
-      tmplik <- sapply(1:ndim, function(j) likevals[tmpmatch[j], YXou[,j], j, 1])
-    
-      qpt.uniq[,p] <- rowSums(tmplik)
+      tmpeval <- matrix(0, NROW(YXou), NCOL(YXou))
+      for(ii in 1:NROW(YXou)) {
+        for(jj in 1:NCOL(YXou)) {
+          tmpeval[ii, jj] <- likevals[tmpmatch[p, diment[jj]], YXou[ii,jj], jj, 1]
+        }
+      }
+      qpt.uniq[,p] <- rowSums(tmpeval)
     }
 
     qpt.uniq <- sweep(exp(qpt.uniq), 2, w.star, FUN = ""*"")
@@ -119,7 +127,7 @@ browser()
     ## assign values to full data matrix, for each response pattern
     full.lik <- rep(NA, NROW(YX))
     for(j in 1:length(ulocs)) {
-      tmpidx <- match(upatts[ulocs[j]], upatts)
+      tmpidx <- which(rpatts == rpatts[ulocs[j]])
       full.lik[tmpidx] <- log(sum(qpt.uniq[j,]))
     }
 "
ecmerkle,blavaan,65b912205d9f58b1d2b7b764ac79eff361a6a833,ecmerkle,merklee@missouri.edu,2022-05-03T17:58:56Z,ecmerkle,merklee@missouri.edu,2022-05-03T17:58:56Z,fix parens,DESCRIPTION;R/blav_adapt_quad.R;R/margloglik.R,False,True,True,False,3,3,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-2.972
+Version: 0.4-2.973
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_adapt_quad.R---
@@ -83,7 +83,7 @@ fixed_ghq <- function(fit, ngq, samprow = NULL) {
     ## for each entry in mnvec, compute univariate likelihoods for each set of thresholds
     ## a matrix per column of mnvec: number of rows in x.star.eval by number of ordered categories
     likevals <- array(NA, dim = c(NROW(x.star.eval), max(standata$YXo), NCOL(standata$YXo), Ng))
-
+browser()
     for(g in 1:Ng) {
       mm.in.group <- 1:lavmodel@nmat[g] + cumsum(c(0,lavmodel@nmat[g]))[g]
       mms <- lavmodel@GLIST[mm.in.group]

---FILE: R/margloglik.R---
@@ -84,7 +84,7 @@ margloglik <- function(lavpartable, lavmodel, lavoptions,
 
       ## NB wishart on precision matrix, so need to invert:
       if(targdist == ""dwish""){
-        priloglik <- priloglik + ldwish(solve(tmpmat), (dimen+1), diag(dimen)))
+        priloglik <- priloglik + ldwish(solve(tmpmat), (dimen+1), diag(dimen))
       } else {
         etapar <- as.numeric(pricom[[wps[1]]][2])
         ## etapar==1 has you adding 0, so avoid"
ecmerkle,blavaan,5265f56163641c2aefd32ebd5cfe6f9bdccfdee5,ecmerkle,merklee@missouri.edu,2022-05-03T04:03:47Z,ecmerkle,merklee@missouri.edu,2022-05-03T04:03:47Z,"progress on efficient, fixed quadrature method",R/blav_adapt_quad.R,False,True,True,False,49,13,62,"---FILE: R/blav_adapt_quad.R---
@@ -38,14 +38,15 @@ adapted_ghq <- function(fit, ngq, samprow = NULL) {
 }
 
 ## fixed gauss-hermite quadrature, to reuse quadrature points across cases
-## FIXME this is unfinished!!
 fixed_ghq <- function(fit, ngq, samprow = NULL) {
   GLIST <- fit@Model@GLIST
   if (any(GLIST$theta[lower.tri(GLIST$theta)] != 0L)) stop(""blavaan ERROR: The quadrature method cannot be used with non-diagonal theta matrix."")
   ndim <- NROW(GLIST$alpha)
+
+  if (blavInspect(fit, 'ngroups') > 1) stop(""blavaan ERROR: The quadrature method currently does not support multiple groups."")
   
   samps <- do.call(""rbind"", make_mcmc(fit@external$mcmcout, fit@external$stanlvs))
-  if(length(samprow) > 1) samps <- samps[samprow, , drop = FALSE]
+  if(length(samprow) > 0) samps <- samps[samprow, , drop = FALSE]
 
   XW <- lavaan:::lav_integration_gauss_hermite(n = ngq, ndim = ndim, dnorm = TRUE)
   x.star <- XW$x
@@ -54,40 +55,75 @@ fixed_ghq <- function(fit, ngq, samprow = NULL) {
 
   ## response patterns
   standata <- fit@external$mcmcdata
+  if(length(standata$YX) > 0) stop(""blavaan ERROR: The fixed quadrature method cannot handle mixes of continuous variables yet."")
   YX <- matrix(NA, NROW(standata$YX), NCOL(standata$YX) + NCOL(standata$YXo))
   YX[, standata$contidx] <- standata$YX
   YX[, standata$ordidx] <- standata$YXo
-  rpatts <- apply(standata$YXo, 1, paste0)
+  rpatts <- apply(standata$YXo, 1, paste0, collapse = """")
   upatts <- as.numeric(as.factor(rpatts))
+  ulocs <- which(!duplicated(upatts))
+  ## FIXME: also need to consider Ng > 1 in response patterns:
   YXou <- standata$YXo[!duplicated(upatts), , drop = FALSE]
   deltas <- which(names(fit@Model@GLIST) == ""delta"")
+  th.idx <- fit@Model@th.idx
+  Ng <- blavInspect(fit, 'ngroups')
+  TH.idx <- lapply(1:Ng, function(g) th.idx[[g]][th.idx[[g]] > 0])
 
   origlm <- fit@Model
-
   out <- matrix(NA, NROW(samps), NROW(YX))
   
   for(i in 1:NROW(samps)) {
     lavmodel <- fill_params(samps[i, , drop = FALSE], origlm, fit@ParTable)
     lavmodel@GLIST[[deltas]] <- NULL
-    fit@Model <- lavmodel
-    mnvec <- lavPredict(fit, type = ""ov"", ETA = x.star.eval)
-    if(inherits(mnvec, ""matrix"")) mnvec <- list(mnvec)
+    ## fit@Model <- lavmodel
+    ## mnvec <- lavPredict(fit, type = ""ov"", newdata = fakedat,
+    ##                     ETA = x.star.eval)
+    ## if(inherits(mnvec, ""matrix"")) mnvec <- list(mnvec)
 
-    ## for each entry in mnvec, do line 345 of model_loglik for each set of thresholds
+    ## for each entry in mnvec, compute univariate likelihoods for each set of thresholds
     ## a matrix per column of mnvec: number of rows in x.star.eval by number of ordered categories
-
-    ## check for continuous data and throw error for now
+    likevals <- array(NA, dim = c(NROW(x.star.eval), max(standata$YXo), NCOL(standata$YXo), Ng))
+
+    for(g in 1:Ng) {
+      mm.in.group <- 1:lavmodel@nmat[g] + cumsum(c(0,lavmodel@nmat[g]))[g]
+      mms <- lavmodel@GLIST[mm.in.group]
+      mnvec <- mms$lambda %*% t(x.star.eval)
+      mnvec <- sweep(mnvec, 1, mms$nu, FUN = ""+"")
+
+      for(j in 1:NCOL(standata$YXo)) {
+        tmpidx <- unique(TH.idx[[g]])[j]
+        tau <- c(-Inf, mms$tau[TH.idx[[g]] == tmpidx], Inf)
+        utau <- rep(tau[2:length(tau)], ncol(mnvec))
+        ltau <- rep(tau[1:(length(tau) - 1)], ncol(mnvec))
+        tmpprob <- pnorm(utau, mean = mnvec[tmpidx,], sd = sqrt(mms$theta[tmpidx, tmpidx])) -
+          pnorm(ltau, mean = mnvec[tmpidx,], sd = sqrt(mms$theta[tmpidx, tmpidx]))
+
+        likevals[, 1:max(standata$YXo[,tmpidx]), j, g] <- log(tmpprob)
+      }
+    }
 
     ## for each response pattern, use x.star to pull values out of the above matrices and sum
     qpt.uniq <- matrix(NA, NROW(YXou), NROW(x.star))
 
-
+    for(p in 1:NROW(x.star)) {
+      tmpmatch <- sapply(1:ndim, function(j) match(x.star[p,j], x.star.eval[,j]))
+      tmplik <- sapply(1:ndim, function(j) likevals[tmpmatch[j], YXou[,j], j, 1])
+    
+      qpt.uniq[,p] <- rowSums(tmplik)
+    }
 
     qpt.uniq <- sweep(exp(qpt.uniq), 2, w.star, FUN = ""*"")
-      
+
+    ## FIXME deal with continuous data here
+    
     ## assign values to full data matrix, for each response pattern
+    full.lik <- rep(NA, NROW(YX))
+    for(j in 1:length(ulocs)) {
+      tmpidx <- match(upatts[ulocs[j]], upatts)
+      full.lik[tmpidx] <- log(sum(qpt.uniq[j,]))
+    }
 
-    out[i,] <- above
+    out[i,] <- full.lik
   }
 
   out"
ecmerkle,blavaan,bcd73b96dc61aeff6a3ada6734c10cb4c07cc0ee,ecmerkle,merklee@missouri.edu,2022-04-28T17:14:45Z,ecmerkle,merklee@missouri.edu,2022-04-28T17:14:45Z,fix plot vignette,vignettes/plotting.Rmd,True,False,True,False,6,5,11,"---FILE: vignettes/plotting.Rmd---
@@ -4,17 +4,18 @@ bibliography:
   - refs.bib
 ---
 
-```{r include=FALSE}
+```{r pld, include=FALSE}
 library(blavaan, quietly=TRUE)
 library(ggplot2, quietly=TRUE)
+library(bayesplot, quietly=TRUE)
 ```
 
 ```{r modfit, include=FALSE, cache=TRUE}
 HS.model <- ' visual  =~ x1 + x2 + x3
               textual =~ x4 + x5 + x6
               speed   =~ x7 + x8 + x9 '
      
-fit <- bcfa(HS.model, data=HolzingerSwineford1939)
+fit <- bcfa(HS.model, data=HolzingerSwineford1939, seed=959)
 ```
 
 A `plot()` method exists for *blavaan* objects, with this method making use of the *bayesplot* package [@bayesplot]. We provide details here about how this functionality works. We will use a 3-factor model for demonstration:
@@ -38,12 +39,12 @@ Many other plot types are available, coming from the *bayesplot* package. In gen
 
 
 ### Customization
-Users may wish to customize some aspects of the resulting plots. For this, the `plot()` function will output a *ggplot2* object. This makes it possible to modify the plot as if it were any other *ggplot2* object.
+Users may wish to customize some aspects of the resulting plots. For this, the `plot()` function will output a *ggplot* object. This makes it possible to modify the plot as if it were any other *ggplot* object.
 
 ```{r p2}
-p <- plot(fit, pars = 1:4, plot.type = ""trace"")
+p <- plot(fit, pars = 1:4, plot.type = ""trace"", showplot = FALSE)
 
-p + theme_bw()
+p + facet_text(size=15) + legend_none()
 ```
 
 Alternatively, users may wish to create a plot that is entirely different from what is available via `plot()`. This can be facilitated by extracting the posterior samples or the Stan model, via `blavInspect()`:"
ecmerkle,blavaan,de0c68927453d270daf06d28abc4e4e406a83036,ecmerkle,merklee@missouri.edu,2022-04-28T16:19:50Z,ecmerkle,merklee@missouri.edu,2022-04-28T16:19:50Z,fix vignette,vignettes/plotting.Rmd,True,False,True,False,1,0,1,"---FILE: vignettes/plotting.Rmd---
@@ -6,6 +6,7 @@ bibliography:
 
 ```{r include=FALSE}
 library(blavaan, quietly=TRUE)
+library(ggplot2, quietly=TRUE)
 ```
 
 ```{r modfit, include=FALSE, cache=TRUE}"
ecmerkle,blavaan,7963d6bb7fce4ee8589b07883bfe4c8a75d1697b,ecmerkle,merklee@missouri.edu,2022-04-28T16:11:05Z,ecmerkle,merklee@missouri.edu,2022-04-28T16:11:05Z,"fix init generation for target=""jags"" under non-standard priors",DESCRIPTION;R/set_inits.R,False,True,True,False,3,3,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-2.965
+Version: 0.4-2.967
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/set_inits.R---
@@ -65,7 +65,7 @@ set_inits <- function(partable, ov.cp, lv.cp, n.chains, inits){
       ## FIXME do something smarter upon failure
       ivs <- try(do.call(pricom[1], list(n.chains, as.numeric(pricom[2]),
                                      as.numeric(pricom[3]))), silent = TRUE)
-      if(inherits(ivs, ""try-error"")) ivs <- rep(partable$start[i], n.chains)
+      if(inherits(ivs, ""try-error"") | all(is.na(ivs))) ivs <- rep(partable$start[i], n.chains)
     } else {
       ivs <- rep(partable$start[i], n.chains)
     }
@@ -75,8 +75,8 @@ set_inits <- function(partable, ov.cp, lv.cp, n.chains, inits){
     if(grepl(""\\[sd\\]"", partable$prior[i]) |
        grepl(""\\[var\\]"", partable$prior[i])){
       powval <- ifelse(grepl(""\\[sd\\]"", partable$prior[i]), -.5, -1)
-      ivs <- ivs^powval
       ivs[ivs <= 0] <- -ivs[ivs <= 0]
+      ivs <- ivs^powval
     }
     if(grepl(""dbeta"", partable$prior[i])){
       ivs <- rep(.5, n.chains)"
ecmerkle,blavaan,037b4b1743cc0131b62054cd3e5af307e414c1e5,ecmerkle,merklee@missouri.edu,2022-04-27T16:26:51Z,ecmerkle,merklee@missouri.edu,2022-04-27T16:26:51Z,fix approx fi chunk,vignettes/approx_fi.Rmd,True,False,True,False,1,1,2,"---FILE: vignettes/approx_fi.Rmd---
@@ -5,7 +5,7 @@ bibliography:
   - refs.bib
 ---
 
-```{r echo=FALSE, message=FALSE, eval=F}
+```{r pkgld, include=FALSE}
 library(blavaan, quietly=TRUE)
 library(bayesplot)
 ```"
ecmerkle,blavaan,b508145814b76aa7d18430033d64c0770e02cbb5,ecmerkle,merklee@missouri.edu,2022-04-11T14:00:40Z,ecmerkle,merklee@missouri.edu,2022-04-11T14:00:40Z,minor data fix,R/stanmarg_data.R,False,True,True,False,1,1,2,"---FILE: R/stanmarg_data.R---
@@ -269,7 +269,7 @@ stanmarg_data <- function(YX = NULL, S = NULL, YXo = NULL, N, Ng, grpnum, # data
             ## could model the ""closest"" PD matrix: dat$S[i,,] <- Matrix::nearPD(dat$S[i,,])
             dat$use_suff <- 0L
             dat$has_data <- 1L
-            dat$S[i,,] <- diag(1, NCOL(YX) + 1)
+            dat$S[i,,] <- diag(1, NCOL(YX))
           }
           dat$YXbar[i,] <- colMeans(YX[(startrow[i] : endrow[i]), ])
         }"
ecmerkle,blavaan,784a7f62486e824703c11ceea37b5b94ac607721,lstmemery,matthew.emery44@gmail.com,2022-03-26T23:20:34Z,lstmemery,matthew.emery44@gmail.com,2022-03-26T23:20:34Z,Now errors in checks,inst/testdata/sysdata.rda;inst/tinytest/tests.blavaan.R;inst/tinytest/tests.blavaanobject-methods.R,False,True,True,False,15,0,15,"---FILE: inst/tinytest/tests.blavaan.R---
@@ -87,7 +87,14 @@ expect_equal(class(bcfa(HS.model, data=HolzingerSwineford1939, target=""jags"", do
 
 ## moment match mcmcextra
 
+set.seed(341)
 
+x1 <- rnorm(100)
+y1 <- 0.5 + 2*x1 + rnorm(100)
+g <- rep(1:2, each=50)
+Data <- data.frame(y1 = y1, x1 = x1, g = g)
+
+model <- ' y1 ~ prior(""normal(0,1)"")*x1 '
 fitstanmomentmatch <- bsem(
   model, 
   data=Data, 

---FILE: inst/tinytest/tests.blavaanobject-methods.R---
@@ -133,6 +133,14 @@ if(requireNamespace(""rstan"", quietly = TRUE) &
   expect_equal(class(bf_res)[1], ""blavFitIndices"")
   expect_equal(class(summary(bf_res))[1], ""lavaan.data.frame"")
   
+  set.seed(341)
+  
+  x1 <- rnorm(100)
+  y1 <- 0.5 + 2*x1 + rnorm(100)
+  g <- rep(1:2, each=50)
+  Data <- data.frame(y1 = y1, x1 = x1, g = g)
+  
+  model <- ' y1 ~ prior(""normal(0,1)"")*x1 '
   fitstanmomentmatch <- bsem(
     model, 
     data=Data, "
ecmerkle,blavaan,b93153657e1b6aaa2ce5e63dda0de755f63d61f5,lstmemery,matthew.emery44@gmail.com,2022-03-26T02:55:52Z,lstmemery,matthew.emery44@gmail.com,2022-03-26T02:55:52Z,Actual fix to loo test,inst/tinytest/tests.blavaanobject-methods.R,False,True,True,False,1,1,2,"---FILE: inst/tinytest/tests.blavaanobject-methods.R---
@@ -146,7 +146,7 @@ if(requireNamespace(""rstan"", quietly = TRUE) &
   bf_mm_res <- blavFitIndices(fitstanmomentmatch, fit.measures = c(""looic""))
   expect_equal(class(bf_mm_res)[1], ""blavFitIndices"")
   expect_equal(class(summary(bf_mm_res))[1], ""lavaan.data.frame"")
-  expect_true(""p_loo"" %in% names(bf_mm_res))
+  expect_true(""p_loo"" %in% names(bf_mm_res@details$pD))
   
   
   ## blavPredict"
ecmerkle,blavaan,b5a6dd73dceefcd9c6f839aa443f622a571d1e29,ecmerkle,merklee@missouri.edu,2022-03-06T16:26:30Z,ecmerkle,merklee@missouri.edu,2022-03-06T16:26:30Z,attempt to fix summary confusion between lavaan and blavaan,DESCRIPTION;R/blav_object_methods.R,False,True,True,False,7,7,14,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-2.908
+Version: 0.4-2.909
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_object_methods.R---
@@ -1,7 +1,7 @@
 #
-# initial version: YR 25/03/2009
+# much of this comes from lav_object_methods.R
 
-short.summary <- function(object) {
+bl.short.summary <- function(object) {
 
     # catch FAKE run
     FAKE <- FALSE
@@ -154,16 +154,16 @@ setMethod(""show"", ""blavaan"",
 function(object) {
 
     # show only basic information
-    short.summary(object)
+    bl.short.summary(object)
 
 })
 
 
 summary.blavaan <- function(object, ...) {
-    long.summary(object, ...)
+    bl.long.summary(object, ...)
 }
 
-long.summary <- function(object,
+bl.long.summary <- function(object,
                  header       = TRUE,
                  fit.measures = FALSE,
                  estimates    = TRUE,
@@ -183,7 +183,7 @@ long.summary <- function(object,
 
     # print the 'short' summary
     if(header) {
-        short.summary(object)
+        bl.short.summary(object)
     }
 
     # only if requested, the fit measures"
ecmerkle,blavaan,f02d14cf2fe82cd120d9f586197ab7fe44eb0ea5,ecmerkle,merklee@missouri.edu,2022-03-01T17:10:03Z,ecmerkle,merklee@missouri.edu,2022-03-01T17:10:03Z,fix a test,DESCRIPTION;inst/tinytest/tests.blavaanobject-methods.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-2.907
+Version: 0.4-2.908
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: inst/tinytest/tests.blavaanobject-methods.R---
@@ -112,7 +112,7 @@ if(requireNamespace(""rstan"", quietly = TRUE) &
     fitMeasures(fit, fit.measures = c(""cfi"",""rmsea"",""srmr"",""chisq""))
   },
   std.cov.resid = function(fit) lavResiduals(fit, zstat = FALSE,
-                                             summary = FALSE)$cov)
+                                             summary = FALSE)$`1`$cov)
 
   ppmc_res <- ppmc(fitstan, discFUN = discFUN)
   expect_equal(class(ppmc_res)[1], ""blavPPMC"")"
ecmerkle,blavaan,c58e8059bef6640db99cd68e6ed1fb6f1416c7ed,ecmerkle,merklee@missouri.edu,2022-02-25T22:58:54Z,ecmerkle,merklee@missouri.edu,2022-02-25T22:58:54Z,fixes to blavFitIndices(),DESCRIPTION;NEWS.md;R/ctr_bayes_fit.R;R/postpred.R;inst/tinytest/tests.blavaanobject-methods.R,False,True,True,False,17,5,22,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-2.905
+Version: 0.4-2.906
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: NEWS.md---
@@ -7,6 +7,8 @@
 ##  Bugs/glitches discovered after the release:
 * blavPredict(, type=""ymis"") is not working for models with ordinal variables
 
+* blavFitIndices(, rescale=""mcmc"") fails
+
 
 # Version 0.3-18
 ## New features

---FILE: R/ctr_bayes_fit.R---
@@ -42,18 +42,20 @@ summary.bfi <- function(object,
 
     if (""mode"" %in% central.tendency || ""map"" %in% central.tendency) {
       ## can the modeest package be used?
-      if (suppressMessages(requireNamespace(""modeest"", quietly = TRUE))) {
+      if (suppressMessages(requireNamespace(""modeest"", quietly = TRUE)) & length(unique(x)) > 1) {
         out <- c(out, MAP =  modeest::mlv(x, method = ""kernel"", na.rm = TRUE))
-      } else {
+      } else if(!all(is.na(x))) {
         ## if not, use the quick-and-dirty way
         dd <- density(x, na.rm = TRUE)
         out <- c(out, MAP = dd$x[which.max(dd$y)])
+      } else {
+        out <- c(out, NA)
       }
     }
 
     out <- c(out, SD = sd(x, na.rm = TRUE))
 
-    if (hpd) {
+    if (hpd & !all(is.na(x))) {
       if (!""package:coda"" %in% search()) attachNamespace(""coda"")
       out <- c(out, HPDinterval(as.mcmc(x), prob = prob)[1, ] )
     }

---FILE: R/postpred.R---
@@ -25,7 +25,7 @@
 
 postpred <- function(lavpartable, lavmodel, lavoptions,
                      lavsamplestats, lavdata, lavcache, lavjags,
-                     samplls, lavobject = NULL, measure = ""logl"", thin = 1,
+                     samplls = NULL, lavobject = NULL, measure = ""logl"", thin = 1,
                      discFUN = NULL, probs = c(.025, .975)) {
 
   ## check custom discrepancy function(s)

---FILE: inst/tinytest/tests.blavaanobject-methods.R---
@@ -125,6 +125,14 @@ if(requireNamespace(""rstan"", quietly = TRUE) &
   expect_equal(class(bf_res)[1], ""blavFitIndices"")
   expect_equal(class(summary(bf_res))[1], ""lavaan.data.frame"")
 
+  bf_res <- blavFitIndices(fitstan, rescale = ""ppmc"")
+  expect_equal(class(bf_res)[1], ""blavFitIndices"")
+  expect_equal(class(summary(bf_res))[1], ""lavaan.data.frame"")  
+
+  bf_res <- blavFitIndices(fitstan, rescale = ""mcmc"")
+  expect_equal(class(bf_res)[1], ""blavFitIndices"")
+  expect_equal(class(summary(bf_res))[1], ""lavaan.data.frame"")  
+  
   ## blavPredict
   expect_error(blavPredict(fitstanc))
   expect_error(blavPredict(fitjags))"
ecmerkle,blavaan,fbb9ed840a88abc826e4c7cea7495e743c8c6bea,ecmerkle,merklee@missouri.edu,2022-02-03T23:20:01Z,ecmerkle,merklee@missouri.edu,2022-02-03T23:20:01Z,fix last commit,DESCRIPTION;R/blav_predict.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-2.892
+Version: 0.4-2.893
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_predict.R---
@@ -43,7 +43,7 @@ blavPredict <- function(object, newdata = NULL, type = ""lv"") {
     if(!stantarget) stop(paste0(""blavaan ERROR: '"", type, ""' is only supported for target='stan'""))
 
     if(type %in% c(""yhat"", ""ypred"")) {
-      if(is.null(bfit@external$stanlvs)) stop(""blavaan ERROR: for predictions, save.lvs must be TRUE during model estimation"")
+      if(is.null(object@external$stanlvs)) stop(""blavaan ERROR: for predictions, save.lvs must be TRUE during model estimation"")
       lavmcmc <- make_mcmc(blavInspect(object, 'mcobj'), object@external$stanlvs)
       itnums <- sampnums(object@external$mcmcout, thin = 1)
       nsamps <- length(itnums)"
ecmerkle,blavaan,825b87a6d39fec12d1555210b7539dc79eed8a77,ecmerkle,merklee@missouri.edu,2022-02-03T22:45:02Z,ecmerkle,merklee@missouri.edu,2022-02-03T22:45:02Z,fix versions of dependencies and describe a bug,DESCRIPTION;NEWS.md;R/lvgqs.R,False,True,True,False,7,2,9,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-2.891
+Version: 0.4-2.892
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",
@@ -33,6 +33,6 @@ ByteCompile: true
 Depends: R(>= 3.5.0), methods, lavaan(>= 0.6-10), Rcpp(>= 0.12.15)
 Imports: stats, utils, graphics, MCMCpack, coda, mnormt, nonnest2(>= 0.5-5), loo(>= 2.0), rstan(>= 2.21.2), rstantools(>= 1.5.0), RcppParallel (>= 5.0.1), bayesplot, Matrix, future.apply, tmvnsim
 LinkingTo: StanHeaders (>= 2.18.1), rstan (>= 2.21.2), BH (>= 1.69.0), Rcpp (>= 0.12.15), RcppEigen (>= 0.3.3.4.0), RcppParallel (>= 5.0.1)
-Suggests: runjags(>= 2.0.4-2.891
+Suggests: runjags(>= 2.0.4-4), modeest(>= 2.3.3), rjags, semTools, tinytest
 SystemRequirements: GNU make
 NeedsCompilation: yes

---FILE: NEWS.md---
@@ -4,6 +4,9 @@
 
 * For models with missing data, posterior summaries have been sped up (log-likelihood computations now done in Stan).
 
+##  Bugs/glitches discovered after the release:
+* blavPredict(, type=""ymis"") is not working for models with ordinal variables
+
 
 # Version 0.3-18
 ## New features

---FILE: R/lvgqs.R---
@@ -2,6 +2,8 @@ lvgqs <- function(modmats, standata, getlvs = TRUE) {
   Ng <- length(modmats)
 
   ## stan data
+  ## FIXME for getlvs=FALSE, YX only contains continuous data so dimensions
+  ## are wrong below
   p <- standata$p
   q <- standata$q
   m <- standata$m"
ecmerkle,blavaan,df23a2c9dab1690090363eb2794df9978186f51b,ecmerkle,merklee@missouri.edu,2022-01-26T17:19:13Z,ecmerkle,merklee@missouri.edu,2022-01-26T17:19:13Z,fix typo,DESCRIPTION;R/ctr_ppmc.R;man/ppmc.Rd,False,True,True,False,4,3,7,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.4-1.875
+Version: 0.4-1.877
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/ctr_ppmc.R---
@@ -602,7 +602,7 @@ ppmc <- function(object, thin = 1, fit.measures = c(""srmr"",""chisq""),
   jagtarget <- lavInspect(object, ""options"")$target == ""jags""
 
   if(jagtarget){
-    etas <- any(bobject@external$mcmcout$monitor == ""eta"")
+    etas <- any(object@external$mcmcout$monitor == ""eta"")
   } else {
     etas <- any(grepl(""^eta"", rownames(object@external$stansumm)))
   }

---FILE: man/ppmc.Rd---
@@ -13,7 +13,8 @@ This function allows users to conduct a posterior predictive model check to
 assess the global or local fit of a latent variable model using any discrepancy
 function that can be applied to a \code{\linkS4class{lavaan}} model.}
 \usage{
-ppmc(object, thin = 1, fit.measures = c(""srmr"",""chisq""), discFUN = NULL, conditional = FALSE)
+ppmc(object, thin = 1, fit.measures = c(""srmr"",""chisq""), discFUN = NULL,
+     conditional = FALSE)
 
 \S4method{summary}{blavPPMC}(object, ...)
 "
ecmerkle,blavaan,495346f048e74978e774eabcc8c5c29b944e791a,ecmerkle,merklee@missouri.edu,2021-11-19T19:31:31Z,ecmerkle,merklee@missouri.edu,2021-11-19T19:31:31Z,fix github actions (?),.github/workflows/R-CMD-check.yaml;.github/workflows/pkgdown.yaml,False,False,False,False,2,5,7,"---FILE: .github/workflows/R-CMD-check.yaml---
@@ -65,13 +65,9 @@ jobs:
         run: |
           remotes::install_deps(dependencies = TRUE)
           remotes::install_cran(""rcmdcheck"")
+          remotes::install_github(""yrosseel/lavaan"")
         shell: Rscript {0}
 
-      - name: Use lavaan devel version
-        run: |
-	  remotes::install_github(""yrosseel/lavaan"")
-	shell: Rscript {0}
-
       - name: Check
         env:
           _R_CHECK_CRAN_INCOMING_REMOTE_: false

---FILE: .github/workflows/pkgdown.yaml---
@@ -35,6 +35,7 @@ jobs:
       - name: Install dependencies
         run: |
           remotes::install_deps(dependencies = TRUE)
+          remotes::install_github(""yrosseel/lavaan"")
           install.packages(""pkgdown"", type = ""binary"")
         shell: Rscript {0}
 "
ecmerkle,blavaan,a8bc053e2738897a1d65b82b0f8f6ec00c40971e,ecmerkle,merklee@missouri.edu,2021-10-27T20:14:32Z,ecmerkle,merklee@missouri.edu,2021-10-27T20:14:32Z,fix postpred() change from previous commit,DESCRIPTION;R/postpred.R,False,True,True,False,6,2,8,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-18.858
+Version: 0.3-18.859
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/postpred.R---
@@ -39,7 +39,11 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
   probs <- as.numeric(probs)
 
   ## add sampled lvs to posterior samples, if they exist
-  save_lvs <- (!is.null(lavobject)) & (""stanlvs"" %in% names(lavobject@external)) & length(discFUN)
+  save_lvs <- FALSE
+  if (!is.null(lavobject)) {    
+    save_lvs <- (""stanlvs"" %in% names(lavobject@external)) & length(discFUN)
+  }
+  
   if (save_lvs) {
     lavmcmc <- make_mcmc(lavjags, lavobject@external$stanlvs)
   } else {"
ecmerkle,blavaan,78e8f881c23791ae8ab65163f81644e2da73d02f,ecmerkle,merklee@missouri.edu,2021-10-15T03:36:57Z,ecmerkle,merklee@missouri.edu,2021-10-15T03:36:57Z,handle thresholds with fixed values,DESCRIPTION;src/stan_files/stanmarg.stan,False,False,False,False,15,11,26,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-18.853
+Version: 0.3-18.856
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: src/stan_files/stanmarg.stan---
@@ -677,26 +677,30 @@ transformed parameters {
       for (i in 1:Nord) {
 	for (j in 1:(nlevs[i] - 1)) {
 	  real rc = Tau_skeleton[g, vecpos, 1];
-	  if (j == 1) {
-	    Tau[g, vecpos, 1] = Tau_un[g, vecpos, 1];
-	  } else {
-	    Tau[g, vecpos, 1] = Tau[g, (vecpos - 1), 1] + exp(Tau_un[g, vecpos, 1]);
-	  }
+	  int eq = w15skel[opos, 1];
+	  int wig = w15skel[opos, 3];
 
 	  if (is_inf(rc)) {
-	    int eq = w15skel[opos, 1];
-	    int wig = w15skel[opos, 3];
 	    if (eq == 0 || wig == 1) {
-	      Tau_free[ofreepos] = Tau[g, vecpos, 1];
+	      if (j == 1) {
+		Tau[g, vecpos, 1] = Tau_un[g, vecpos, 1];
+	      } else {
+		Tau[g, vecpos, 1] = Tau[g, (vecpos - 1), 1] + exp(Tau_un[g, vecpos, 1]);
+	      }
+
+	      Tau_free[ofreepos] = Tau[g, vecpos, 1];	      
 	      // this is used if a prior goes on Tau_free, instead of Tau_ufree:
 	      //if (j > 1) {
 	      //  tau_jacobian += Tau_un[g, vecpos, 1]; // see https://mc-stan.org/docs/2_24/reference-manual/ordered-vector.html
 	      // }
 	      ofreepos += 1;
 	    }
 	    opos += 1;
-	  }
-	  vecpos +=1;
+	  } else {
+	    // fixed value
+	    Tau[g, vecpos, 1] = Tau_un[g, vecpos, 1];
+	  }	  
+	  vecpos += 1;
 	}
       }
     }"
ecmerkle,blavaan,677bccbf8fc13ff5db95b21de52384db989413ae,ecmerkle,merklee@missouri.edu,2021-09-23T18:14:24Z,ecmerkle,merklee@missouri.edu,2021-09-23T18:14:24Z,fix prisamp=TRUE dimension sizes,DESCRIPTION;R/stanmarg_data.R,False,True,True,False,3,3,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-18.842
+Version: 0.3-18.845
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/stanmarg_data.R---
@@ -225,9 +225,9 @@ stanmarg_data <- function(YX = NULL, S = NULL, YXo = NULL, N, Ng, grpnum, # data
 
   dat$has_data <- dat$has_cov <- 0L
   if (pri_only) {
-    tmparr <- array(dim = c(dat$Ng, ncol(YX), ncol(YX)))
+    tmparr <- array(dim = c(dat$Ng, ncol(YX) + 1, ncol(YX) + 1))
     for (i in 1:Ng) {
-      tmparr[i,,] <- diag(nrow=ncol(YX))
+      tmparr[i,,] <- diag(nrow=ncol(YX) + 1)
     }
     dat$S <- tmparr
   } else {"
ecmerkle,blavaan,40e6692721a2357952c49b51fb93c455da344753,ecmerkle,merklee@missouri.edu,2021-09-23T02:02:32Z,ecmerkle,merklee@missouri.edu,2021-09-23T02:02:32Z,fix vignette evals and rendering,vignettes/ordinal.Rmd;vignettes/refs.bib,True,False,True,False,13,12,25,"---FILE: vignettes/ordinal.Rmd---
@@ -10,24 +10,24 @@ library(blavaan, quietly=TRUE)
 ```
 
 ### Introduction
-Structural equation models with ordinal observed variables are supported starting in *blavaan* 0.4-1 (`target=""stan""` only). This document describes the overall approach, which includes model estimation, threshold parameters, log-likelihood calculation, posterior predictive p-values, and Jacobians. We assume that you are somewhat familiar with the layout of SEM; if not, some technical detail and examples are found in @merros18 and, more recently, @merfit21. We aim here to provide enough detail to elucidate the new blavaan features, while being informal enough for you to not get (too) bored.
+Structural equation models with ordinal observed variables are supported starting in *blavaan* 0.4-1 (`target=""stan""` only). This document describes the overall approach, which includes model estimation, threshold parameters, log-likelihood calculation, posterior predictive p-values, and Jacobians. We assume that you are somewhat familiar with the layout of SEM; if not, some technical detail and examples are found in @merros18 and, more recently, @merfit21 (links to these papers are in the references section). We aim here to provide enough detail to elucidate the new blavaan features, while being informal enough for you to not get (too) bored.
 
 
 ### Estimation
 Ordinal observed variables are handled via data augmentation, in the style of @chigre98. You might already know this, but the phrase *data augmentation* is imprecise in the context of SEM. This is because there are many possible things that could be augmented, each of which can make model estimation easier. We could be augmenting observed data with predictions of missing values, which is related to multiple imputation methods. We could be augmenting the observed data with the latent variables, which can simplify likelihood calculation (leading to what is sometimes called a *conditional* likelihood, though *conditional* also has many meanings). Or we could be augmenting categorical observed variables with underlying, latent continuous variables. This last type of augmentation is what we are doing here. In our testing, we found it to be faster and more efficient than other approaches that would sample latent variables alongside other model parameters (the latent variables are integrated out of our likelihoods here; similar to the description from @merfit21).
 
-In our data augmentation implementation, each ordinal observation (e.g., $y$) is used to generate a continuous, underlying counterpart (e.g., $y^\ast$). This $y^\ast$ must obey the model's threshold parameters, commonly denoted as $\bm \tau$, based on the value of the observed data. For example, ignoring subscripts and assuming an ordinal variable with 4 categories, we would have
+In our data augmentation implementation, each ordinal observation (e.g., $y$) is used to generate a continuous, underlying counterpart (e.g., $y^\ast$). This $y^\ast$ must obey the model's threshold parameters (commonly denoted $\mathbf{\tau}$), based on the value of the observed data. For example, ignoring subscripts on $y^\ast$ and assuming an ordinal variable with 4 categories, we would have
 \begin{align*}
-y^* &< \tau_1 \text{if }y = 1 \\
-\tau_1 &< y^* < tau_2 \text{if }y = 2 \\
-\tau_2 &< y^* < \tau_3 \text{if }y = 3 \\
-\tau_3 &< y^* \text{if }y = 4
+y^* < \tau_1 &\text{ if }y = 1 \\
+\tau_1 <\ y^* < \tau_2 &\text{ if }y = 2 \\
+\tau_2 <\ y^* < \tau_3 &\text{ if }y = 3 \\
+y^* >\ \tau_3 &\text{ if }y = 4
 \end{align*}
 where we require $\tau_1 < \tau_2 < \tau_3$. We generate such a $y^*$ separately for each ordinal observation in the dataset. These all become additional, bounded parameters in the Stan file. 
 
 The Stan User's Guide has a helpful example of multivariate probit regression using a related approach; see 
-https://mc-stan.org/docs/2_27/stan-users-guide/multivariate-outcomes.html
-The trickiest parts involve enforcing the boundaries of the $y^*$ variables, and ensuring that the threshold parameters for each ordinal variable are ordered correctly (while allowing for the possibility that different ordinal variables have different numbers of thresholds). These require some Jacobian adjustments that took a good deal of time to code correctly.
+https://mc-stan.org/docs/2_27/stan-users-guide/multivariate-outcomes.html.
+The trickiest parts involve enforcing the boundaries of the $y^*$ variables, and ensuring that the threshold parameters for each ordinal variable are ordered correctly (while allowing for the possibility that different ordinal variables have different numbers of thresholds). These require some Jacobian adjustments that took a good deal of time to code correctly (some further detail appears in a later section).
 
 Once the above parameters are defined and generated, the remainder of the model estimation is similar to the simpler situation where all observed variables are continuous. In terms of the Stan file, most of the ordinal overhead comes in the transformed parameters block. Once we get to the model block, most things operate as they would with continuous data.
 
@@ -37,7 +37,7 @@ The prior distributions on the threshold ($\tau$) parameters are more involved t
 
 quote from https://discourse.mc-stan.org/t/prior-choice-for-ordered-inverse-transformed-parameters/16378/3
 
-To address this issue, we first define an unconstrained, unordered parameter vector whose length equal the number of thresholds in the model. Call this vector $\bm{\tau}^*$. We then obtain ordered thresholds by exponentiating the unordered parameter vector in a specific manner. The manner in which this works is exactly the same as how Stan defines a parameter of type `ordered`. See https://mc-stan.org/docs/2_27/reference-manual/ordered-vector.html
+To address this issue, we first define an unconstrained, unordered parameter vector whose length equal the number of thresholds in the model. Call this vector $\mathbf{\tau}^*$. We then obtain ordered thresholds by exponentiating the unordered parameter vector in a specific manner. The manner in which this works is exactly the same as how Stan defines a parameter of type `ordered`. See https://mc-stan.org/docs/2_27/reference-manual/ordered-vector.html.
 
 The idea is most easily shown via example. Say that we have an ordinal variable with 4 categories. Then the three thresholds for this variable are obtained via:
 \begin{align*}
@@ -97,7 +97,7 @@ The fact that our functions go from `model` to `parameters` is convenient, thoug
 
 As an example, consider the fact that *blavaan* allows users to choose whether priors go on standard deviation, variance, or precision parameters. The standard deviations appear in the `parameters` block regardless of what the user chooses (the Stan model is precompiled at the time of package installation). Say that the user wants priors on precisions. We transform the standard deviations to precisions in the `model` block, then put the prior on the precision. In addition to this prior, we need the Jacobian of the function that starts with a standard deviation (call it $\sigma$) and transforms to precision ($\sigma^{-2}$). The derivative of $\sigma^{-2}$ with respect to $\sigma$ is $-2 \sigma^{-3}$. And because this is a simple function mapping a single parameter to a different value, the Jacobian is the absolute value of this derivative, which is $2 \sigma^{-3}$. In the Stan file, we would then add the log of this Jacobian to `target`:
 
-```{stan, eval = FALSE}
+```{Rcpp, eval = FALSE}
 target += log(2) - 3*log(sigma)
 ```
 

---FILE: vignettes/refs.bib---
@@ -13,7 +13,8 @@ @ARTICLE{merros18
   year = {2018},
   volume = {85},
   number = {4},
-  pages = {1--30}  
+  pages = {1--30},
+  url = {https://www.jstatsoft.org/article/view/v085i04}
 }
 
 @BOOK{holswi39,
@@ -45,7 +46,7 @@ @ARTICLE{merfur19
 }
 
 @Manual{tmvnsim,
-    title = {tmvnsim: Truncated Multivariate Normal Simulation},
+    title = {{tmvnsim: Truncated} Multivariate Normal Simulation},
     author = {Samsiddhi Bhattacjarjee},
     year = {2016},
     note = {R package version 1.0-2},"
ecmerkle,blavaan,6a6e9e8585e1209016cae94afc73cf07e7dd25b7,ecmerkle,merklee@missouri.edu,2021-09-22T22:08:18Z,ecmerkle,merklee@missouri.edu,2021-09-22T22:08:18Z,fix vignette evals,vignettes/ordinal.Rmd,True,False,True,False,5,5,10,"---FILE: vignettes/ordinal.Rmd---
@@ -47,13 +47,13 @@ The idea is most easily shown via example. Say that we have an ordinal variable
 \end{align*}
 We then place normal prior distributions on the unordered $\tau^*$ parameters, as opposed to placing priors on the ordered $\tau$ parameters. These normal priors imply that the lowest threshold ($\tau_1$ above) has a normal prior, while differences between successive $\tau$'s have log-normal priors. In blavaan, these priors can be specified in the usual two ways. First, we could add the `dp` argument to a model estimation command as follows.
 
-```{r}
+```{r, eval = FALSE}
 dp = dpriors(tau = ""normal(0, .5)"")
 ```
 
 which would assign this prior to all the unordered $\tau^*$ parameters in the model. Second, we could specify priors for specific threshold parameters in the model specification syntax. For example, say that we have a 4-category observed variable called `x1`. Then unique priors for each the three thresholds could be specified in the model syntax via
 
-```{r}
+```{r, eval = FALSE}
 x1 | prior(""normal(-1, 1)"") * t1 + prior(""normal(0, .5)"") * t2 + prior(""normal(0, 1)"") * t3
 ```
 
@@ -67,7 +67,7 @@ Once we get to continuous data in the model block, it seems reasonable to expect
 
 All this means that, for quantities like WAIC and PSIS-LOO, we must compute a second model likelihood that involves the observed, ordinal $y$ variables and that integrates over the latent $y^*$ variables. This is a difficult problem that amounts to evaluating the CDF of a sometimes-high-dimensional, multivariate normal distribution [see @chigre98, Equation 11]. We follow @chigre98 in approximating these integrals via Monte Carlo simulation, relying on the *tmvnsim* package [@tmvnsim]. For each case, we generate many random samples from the appropriate truncated multivariate normal and average over the resulting importance sampling weights. The procedure is computationally intensive and also time intensive, so we have to balance the number of random samples drawn with the amount of time that it takes. The number of samples currently defaults to 20 times the number of ordinal variables, with a maximum of 200. Users can also set the number of samples to draw at the time of model estimation, by setting `llnsamp` within the `mcmcextra$data` argument. For example, to draw 100 samples for the approximation, an argument to `bsem()` or similar functions would be
 
-```{r}
+```{r, eval = FALSE}
 mcmcextra = list(data = list(llnsamp = 100))
 ```
 
@@ -81,7 +81,7 @@ TODO Bayes factor, use chib's identity?
 ### Posterior Predictive p-values
 Posterior predictive p-value (ppp) computations also receive a speed boost in the 0.4 series. These computations now occur in Stan, whereas they previously occurred in R after model estimation. As discussed by CITE_mplus, the ppp computations needed for models with missing data can be excessively slow, requiring us to run an EM algorithm for each posterior sample in order to find the ""H1"" (""saturated"") model covariance matrix. The solution by CITE_mplus is to realize that we do not need to use a fully-optimized H1 covariance matrix in order to compute the ppp. In *blavaan*, we consequently run an EM algorithm for a fixed number of iterations in order to compute an H1 covariance matrix that is ""good enough"" for the ppp. The default number of iterations it set to 20, and users can change the default by supplying an `emiter` value via the `mcmcextra` argument. For example,
 
-```{r}
+```{r, eval = FALSE}
 mcmcextra = list(data = list(emiter = 50))
 ```
 
@@ -97,7 +97,7 @@ The fact that our functions go from `model` to `parameters` is convenient, thoug
 
 As an example, consider the fact that *blavaan* allows users to choose whether priors go on standard deviation, variance, or precision parameters. The standard deviations appear in the `parameters` block regardless of what the user chooses (the Stan model is precompiled at the time of package installation). Say that the user wants priors on precisions. We transform the standard deviations to precisions in the `model` block, then put the prior on the precision. In addition to this prior, we need the Jacobian of the function that starts with a standard deviation (call it $\sigma$) and transforms to precision ($\sigma^{-2}$). The derivative of $\sigma^{-2}$ with respect to $\sigma$ is $-2 \sigma^{-3}$. And because this is a simple function mapping a single parameter to a different value, the Jacobian is the absolute value of this derivative, which is $2 \sigma^{-3}$. In the Stan file, we would then add the log of this Jacobian to `target`:
 
-```{stan}
+```{stan, eval = FALSE}
 target += log(2) - 3*log(sigma)
 ```
 "
ecmerkle,blavaan,84e6134af241ac2be2d16921a665f8cf40641b67,ecmerkle,merklee@missouri.edu,2021-09-17T03:02:52Z,ecmerkle,merklee@missouri.edu,2021-09-17T03:02:52Z,fixes to jacobians!!,DESCRIPTION;src/stan_files/stanmarg.stan,False,False,False,False,12,11,23,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-18.833
+Version: 0.3-18.835
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: src/stan_files/stanmarg.stan---
@@ -637,17 +637,18 @@ transformed parameters {
 	  if (j == 1) {
 	    Tau[g, vecpos, 1] = Tau_un[g, vecpos, 1];
 	  } else {
-	    Tau[g, vecpos, 1] = Tau[g, (vecpos-1), 1] + exp(Tau_un[g, vecpos, 1]);
+	    Tau[g, vecpos, 1] = Tau[g, (vecpos - 1), 1] + exp(Tau_un[g, vecpos, 1]);
 	  }
 
 	  if (is_inf(rc)) {
 	    int eq = w15skel[opos, 1];
 	    int wig = w15skel[opos, 3];
 	    if (eq == 0 || wig == 1) {
 	      Tau_free[ofreepos] = Tau[g, vecpos, 1];
-	      if (j > 1) {
-		tau_jacobian += log(1/(Tau[g, vecpos, 1] - Tau[g, (vecpos - 1), 1])); // see https://mc-stan.org/docs/2_24/reference-manual/ordered-vector.html
-	      }
+	      // this is used if a prior goes on Tau_free, instead of Tau_ufree:
+	      //if (j > 1) {
+	      //  tau_jacobian += Tau_un[g, vecpos, 1]; // see https://mc-stan.org/docs/2_24/reference-manual/ordered-vector.html
+	      // }
 	      ofreepos += 1;
 	    }
 	    opos += 1;
@@ -688,7 +689,7 @@ transformed parameters {
     b_primn = fill_prior(B_free, b_mn, w4skel);
     nu_primn = fill_prior(Nu_free, nu_mn, w13skel);
     alpha_primn = fill_prior(Alpha_free, alpha_mn, w14skel);
-    tau_primn = fill_prior(Tau_free, tau_mn, w15skel);
+    tau_primn = fill_prior(Tau_ufree, tau_mn, w15skel);
   } else {
     lambda_y_primn = to_vector(lambda_y_mn);
     b_primn = to_vector(b_mn);
@@ -723,13 +724,13 @@ transformed parameters {
 	  if (j > 1) vecpos += sum(nlevs[1:(j - 1)]) - (j - 1);
 	  if (YXo[i,j] == 1) {
 	    YXostar[i,j] = -10 + (Tau[grpnum[patt], (vecpos + 1), 1] + 10) .* z_aug[i,j];
-	    tau_jacobian += log(1/(Tau[grpnum[patt], (vecpos + 1), 1] + 10));  // must add log(U) to tau_jacobian
+	    tau_jacobian += log(fabs(Tau[grpnum[patt], (vecpos + 1), 1] + 10));  // must add log(U) to tau_jacobian
 	  } else if (YXo[i,j] == nlevs[j]) {
 	    YXostar[i,j] = Tau[grpnum[patt], vecpos, 1] + (10 - Tau[grpnum[patt], vecpos, 1]) .* z_aug[i,j];
-	    tau_jacobian += log(1/(10 - Tau[grpnum[patt], vecpos, 1]));
+	    tau_jacobian += log(fabs(10 - Tau[grpnum[patt], vecpos, 1]));
 	  } else {
 	    YXostar[i,j] = Tau[grpnum[patt], vecpos, 1] + (Tau[grpnum[patt], (vecpos + 1), 1] - Tau[grpnum[patt], vecpos, 1]) .* z_aug[i,j];
-	    tau_jacobian += log(1/(Tau[grpnum[patt], (vecpos + 1), 1] - Tau[grpnum[patt], vecpos, 1]));
+	    tau_jacobian += Tau_un[grpnum[patt], (vecpos + 1), 1]; // jacobian is log(exp(Tau_un))
 	  }
 	  YXstar[i, ordidx[j]] = YXostar[i, j];
 	}
@@ -794,7 +795,7 @@ model { // N.B.: things declared in the model block do not get saved in the outp
   }
 
   if (ord) {
-    target += fabs(tau_jacobian);
+    target += tau_jacobian;
   }
   
   /* prior densities in log-units */
@@ -804,7 +805,7 @@ model { // N.B.: things declared in the model block do not get saved in the outp
 
   target += normal_lpdf(Nu_free       | nu_primn, nu_sd);
   target += normal_lpdf(Alpha_free    | alpha_primn, alpha_sd);
-  target += normal_lpdf(Tau_free      | tau_primn, tau_sd);
+  target += normal_lpdf(Tau_ufree      | tau_primn, tau_sd);
 
   /* transform sd parameters to var or prec, depending on
      what the user wants. */"
ecmerkle,blavaan,264a73b6334201060d1eb4c6e0a0ec6ed2133f7f,ecmerkle,merklee@missouri.edu,2021-09-14T02:38:37Z,ecmerkle,merklee@missouri.edu,2021-09-14T02:38:37Z,further fix for across-group equality constraints + std.lv,DESCRIPTION;R/lav_export_stanmarg.R,False,True,True,False,4,1,5,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-18.832
+Version: 0.3-18.833
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lav_export_stanmarg.R---
@@ -113,6 +113,8 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, wig, ...) {
               l1 <- 1
             } else {
               l1 <- lampar1[which(lampar1 %in% lamsign[,2])]
+              ## for across-group equality constraint:
+              if (length(l1) == 0) l1 <- lampar1[lampar1 != 0][1]
               if (lamsign[l1,1] == 1) l1 <- lamsign[l1,2]
             }
 
@@ -123,6 +125,7 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, wig, ...) {
               l2 <- 1
             } else {
               l2 <- lampar2[which(lampar2 %in% lamsign[,2])]
+              if (length(l2) == 0) l2 <- lampar2[lampar2 != 0][1]
               if (lamsign[l2,1] == 1) l2 <- lamsign[l2,2]
             }
 "
ecmerkle,blavaan,553fa6f3fba79ff7b3cb59373d6fd67e4a2f16a7,ecmerkle,merklee@missouri.edu,2021-09-06T03:45:26Z,ecmerkle,merklee@missouri.edu,2021-09-06T03:45:26Z,fix equality-constrained parameters under std.lv,DESCRIPTION;R/lav_export_stanmarg.R,False,True,True,False,6,1,7,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-18.827
+Version: 0.3-18.828
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lav_export_stanmarg.R---
@@ -106,6 +106,9 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, wig, ...) {
             
             ## find sign-constrained loadings of the two lvs
             lampar1 <- lamfree[[i]][,fpar[j,2]]
+            ## see whether any are equality constrained
+            l1match <- match(lampar1, constraint$rhs, nomatch = 0L)
+            lampar1[l1match != 0] <- as.numeric(constraint$lhs[l1match])
             if (all(lampar1 == 0)) { # ov converted to lv
               l1 <- 1
             } else {
@@ -114,6 +117,8 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, wig, ...) {
             }
 
             lampar2 <- lamfree[[i]][,fpar[j,1]]
+            l2match <- match(lampar2, constraint$rhs, nomatch = 0L)
+            lampar2[l2match != 0] <- as.numeric(constraint$lhs[l2match])
             if (all(lampar2 == 0)) {
               l2 <- 1
             } else {"
ecmerkle,blavaan,89ecf91f2b6ded1169af0d453c85c769a4d8dbe2,ecmerkle,merklee@missouri.edu,2021-09-05T16:00:48Z,ecmerkle,merklee@missouri.edu,2021-09-05T16:00:48Z,fix check errors,DESCRIPTION;NAMESPACE;R/postpred.R,False,True,True,False,5,1,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-18.824
+Version: 0.3-18.825
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: NAMESPACE---
@@ -64,6 +64,9 @@ importFrom(""Matrix"",
 importFrom(""future.apply"",
            ""future_lapply"", ""future_sapply"")
 
+importFrom(""tmvnsim"",
+           ""tmvnsim"")
+
 ## need to import something, though others could be used
 importFrom(""bayesplot"",
            ""mcmc_trace"")

---FILE: R/postpred.R---
@@ -127,6 +127,7 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
         chisq.boot <- 2*diff(get_ll(lavmodel = lavmodel,
                                     lavsamplestats = lavsamplestats,
                                     lavdata = lavdata,
+                                    lavoptions = lavoptions,
                                     measure = measure[1]))
 
       ## chi-squared for (in)complete data"
ecmerkle,blavaan,73e3c0992328b198da64ef924797506c6b9ba312,ecmerkle,merklee@missouri.edu,2021-09-03T02:42:00Z,ecmerkle,merklee@missouri.edu,2021-09-03T02:42:00Z,fix saturated cov computation for loglik,src/stan_files/stanmarg.stan,False,False,False,False,2,2,4,"---FILE: src/stan_files/stanmarg.stan---
@@ -975,8 +975,8 @@ generated quantities { // these matrices are saved in the output but do not figu
 	  Mu_rep_sat[grpidx,jj] = mean(YXstar_rep[r1:r2,jj]);
 	}
 	for (jj in r1:r2) {
-	  YXsmat[jj - r1 + 1] = YXstar[jj]';
-	  YXsrepmat[jj - r1 + 1] = YXstar_rep[jj]';
+	  YXsmat[jj - r1 + 1] = (YXstar[jj] - Mu_sat[grpidx])';
+	  YXsrepmat[jj - r1 + 1] = (YXstar_rep[jj] - Mu_rep_sat[grpidx])';
 	}
 	Sigma_sat[grpidx] = crossprod(YXsmat)/N[grpidx];
 	Sigma_rep_sat[grpidx] = crossprod(YXsrepmat)/N[grpidx];"
ecmerkle,blavaan,8ba49985b55316a12a1bdbaf549eb5085461b91f,ecmerkle,merklee@missouri.edu,2021-09-01T17:45:50Z,ecmerkle,merklee@missouri.edu,2021-09-01T17:45:50Z,fix jags prior specification,R/dpriors.R,False,True,True,False,1,1,2,"---FILE: R/dpriors.R---
@@ -20,7 +20,7 @@ dpriors <- function(..., target=""stan""){
     userjags <- sapply(jagdists, function(x) grep(x, userspec))
 
     ## > 1 match can occur for things like ddexp:
-    if(length(unlist(userjags)) > length(userspec)){
+    if(length(unlist(userjags)) >= length(userspec)){
       if(target == ""jags""){
         dp <- do.call(""jagpriors"", userspec)
       } else {"
ecmerkle,blavaan,cabc0beb9a04688673a2f5042315399d7a6479de,ecmerkle,merklee@missouri.edu,2021-08-05T19:34:48Z,ecmerkle,merklee@missouri.edu,2021-08-05T19:34:48Z,fix jags prior check,R/dpriors.R,False,True,True,False,2,1,3,"---FILE: R/dpriors.R---
@@ -19,7 +19,8 @@ dpriors <- function(..., target=""stan""){
 
     userjags <- sapply(jagdists, function(x) grep(x, userspec))
 
-    if(length(unlist(userjags)) == length(userspec)){
+    ## > 1 match can occur for things like ddexp:
+    if(length(unlist(userjags)) > length(userspec)){
       if(target == ""jags""){
         dp <- do.call(""jagpriors"", userspec)
       } else {"
ecmerkle,blavaan,bef42e5e76d04473691bf5f4194aa5f2b1e79c96,ecmerkle,merklee@missouri.edu,2021-08-03T14:47:04Z,ecmerkle,merklee@missouri.edu,2021-08-03T14:47:04Z,fixes #35,R/blav_fit_measures.R;R/blav_object_methods.R,False,True,True,False,11,4,15,"---FILE: R/blav_fit_measures.R---
@@ -32,9 +32,11 @@ blav_fit_measures <- function(object, fit.measures = ""all"",
         }
     }
 
-    if(bopts$prisamp) {
+    if('prisamp' %in% names(bopts)) {
+      if(bopts$prisamp) {
         warning(""blavaan WARNING: These metrics are based on prior samples so may be meaningless."",
                 call. = FALSE)
+      }
     }
   
     if(""all"" %in% fit.measures) {

---FILE: R/blav_object_methods.R---
@@ -318,10 +318,15 @@ long.summary <- function(object,
         ## require ""est""
         #names(PE)[penames == ""est""] <- ""Post.Mean""
         #PE$est <- PE$Post.Mean
-        if(blavInspect(object, 'options')$prisamp){
-          names(PE)[penames == ""se""] <- ""Pri.SD""
-        } else {
+        if(!('prisamp' %in% names(blavInspect(object, 'options')))){
+          ## backwards compatibility before we had prisamp
           names(PE)[penames == ""se""] <- ""Post.SD""
+        } else {
+          if(blavInspect(object, 'options')$prisamp){
+            names(PE)[penames == ""se""] <- ""Pri.SD""
+          } else {
+            names(PE)[penames == ""se""] <- ""Post.SD""
+          }
         }
         names(PE)[penames == ""ci.lower""] <- ""pi.lower""
         names(PE)[penames == ""ci.upper""] <- ""pi.upper"""
ecmerkle,blavaan,82200e492553ff17a92ff26c6aa597f4a58ee857,ecmerkle,merklee@missouri.edu,2021-07-15T04:05:23Z,ecmerkle,merklee@missouri.edu,2021-07-15T04:05:23Z,fix ppp with missing data,DESCRIPTION;R/blav_utils.R,False,True,True,False,9,8,17,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-17.785
+Version: 0.3-17.787
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_utils.R---
@@ -30,8 +30,9 @@ get_ll <- function(postsamp       = NULL, # one posterior sample
     if(any(is.na(unlist(lavdata@X)))){
       mis <- TRUE
       lavmvh1 <- getFromNamespace(""lav_mvnorm_missing_h1_estimate_moments"", ""lavaan"")
+      lavmvll <- getFromNamespace(""lav_mvnorm_missing_loglik_data"", ""lavaan"")
     }
-    
+
     if(measure[1] %in% c(""logl"", ""chisq"") & !mis){
         if(casewise){
             ll.samp <- rep(NA, sum(unlist(lavdata@nobs)))
@@ -131,10 +132,10 @@ get_ll <- function(postsamp       = NULL, # one posterior sample
         tmpsat <- 0
         for(g in 1:length(implied$cov)){
           ## high tolerance speed boost
-          tmpsat <- tmpsat + lavmvh1(Y = lavdata@X[[g]],
-                                     Mp = lavdata@Mp[[g]],
-                                     #max.iter = 20,
-                                     tol = 1e-2)$fx
+          satmod <- lavmvh1(Y = lavdata@X[[g]], Mp = lavdata@Mp[[g]],
+                            #max.iter = 20,
+                            tol = 1e-2)
+          tmpsat <- tmpsat + lavmvll(Y = lavdata@X[[g]], Mu = satmod$Mu, Sigma = satmod$Sigma)
         }
         ll.samp <- c(tmpll, tmpsat)
     } else {
@@ -165,8 +166,8 @@ get_ll <- function(postsamp       = NULL, # one posterior sample
             if(casewise){
                 ll.samp <- llcont(fit.samp)
             } else if(measure[1] == ""logl""){
-              ll.samp <- fitMeasures(fit.samp,
-                                     c(""logl"", ""unrestricted.logl""))
+                ll.samp <- fitMeasures(fit.samp,
+                                       c(""logl"", ""unrestricted.logl""))
             } else {
                 ll.samp <- fitMeasures(fit.samp, measure)
             }"
ecmerkle,blavaan,0f59af9f322af4de5a6de22183dfd76718d4ab6d,ecmerkle,merklee@missouri.edu,2021-07-11T16:34:59Z,ecmerkle,merklee@missouri.edu,2021-07-11T16:34:59Z,fix npd check,DESCRIPTION;R/lvgqs.R,False,True,True,False,3,2,5,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-16.777
+Version: 0.3-16.778
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lvgqs.R---
@@ -80,7 +80,8 @@ lvgqs <- function(modmats, standata, getlvs = TRUE) {
         L <- bottom_right[usepsi,usepsi,drop=FALSE] - (corner[,obsidx[1:Nobs[mm]],drop=FALSE] %*% precision[1:Nobs[mm],1:Nobs[mm]] %*% t(corner[,obsidx[1:Nobs[mm]],drop=FALSE]))[usepsi,usepsi,drop=FALSE]
         L <- try(chol(L))
         if (inherits(L, 'try-error')) {
-          L <- matrix(0, nrow=NROW(L), ncol=NCOL(L))
+          ## occasionally negative variance
+          L <- matrix(0, nrow=length(usepsi), ncol=length(usepsi))
         }
         if (anymis) {
           corner <- corner[,obsidx[1:Nobs[mm]]]"
ecmerkle,blavaan,572e2b322f2f388baebd421ba7c3a8bf5df264ff,Mauricio Garnier-Villarreal,mgv@pm.me,2021-06-19T22:07:48Z,GitHub,noreply@github.com,2021-06-19T22:07:48Z,"fix bug that wasnt working with ppmc

added unlist() for the reps for ppmc",R/ctr_bayes_fit.R,False,True,True,False,2,2,4,"---FILE: R/ctr_bayes_fit.R---
@@ -156,14 +156,14 @@ blavFitIndices <- function(object, thin = 1, pD = c(""loo"",""waic"",""dic""),
     ##        that iteration's model-implied variances?
 
   } else if (rescale == ""ppmc"") {
-    reps <- postpred(lavpartable = object@ParTable,
+    reps <- unlist(postpred(lavpartable = object@ParTable,
                      lavmodel = object@Model,
                      lavoptions = object@Options,
                      lavsamplestats = object@SampleStats,
                      lavdata = object@Data,
                      lavcache = object@Cache,
                      lavjags = object@external$mcmcout,
-                     samplls = object@external$samplls)$ppdist[[""reps""]]
+                     samplls = object@external$samplls)$ppdist[[""reps""]])
   } else reps <- NULL
 
   if (is.null(baseline.model)) {"
ecmerkle,blavaan,e042cc2f97d882b941794f9fdec402cd33667076,ecmerkle,merklee@missouri.edu,2021-06-17T20:14:40Z,ecmerkle,merklee@missouri.edu,2021-06-17T20:14:40Z,fix clash between std.lv and strongly-informed cross-loadings,DESCRIPTION;R/lav_export_stanmarg.R,False,True,True,False,8,6,14,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-16.773
+Version: 0.3-16.774
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lav_export_stanmarg.R---
@@ -109,15 +109,15 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, wig, ...) {
             if (all(lampar1 == 0)) { # ov converted to lv
               l1 <- 1
             } else {
-              l1 <- min(lampar1[lampar1 != 0L])
+              l1 <- lampar1[which(lampar1 %in% lamsign[,2])]
               if (lamsign[l1,1] == 1) l1 <- lamsign[l1,2]
             }
 
             lampar2 <- lamfree[[i]][,fpar[j,1]]
             if (all(lampar2 == 0)) {
               l2 <- 1
             } else {
-              l2 <- min(lampar2[lampar2 != 0])
+              l2 <- lampar2[which(lampar2 %in% lamsign[,2])]
               if (lamsign[l2,1] == 1) l2 <- lamsign[l2,2]
             }
 
@@ -130,10 +130,12 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, wig, ...) {
     } else if (lammat) {
       for (i in 1:length(free2)) {
         for (j in 1:NCOL(free2[[i]])) {
-          col <- free2[[i]][,j]
-          parnums <- col[col != 0L]
+          col <- free[[i]][,j]
+          col2 <- free2[[i]][,j]
+          porg <- col[col != 0L]
+          parnums <- col2[col2 != 0L]
           if (length(parnums) > 0) {
-            psign <- min(parnums)
+            psign <- parnums[which.min(porg)] # sign constrain the first loading from user syntax
             ## if equality constraint, sign must involve the
             ## ""free"" parameter
             if (wskel[psign,1] == 1L) {"
ecmerkle,blavaan,d40f141a8ea280ecacb0fdbea12e29ef88f74876,ecmerkle,merklee@missouri.edu,2021-06-16T14:30:31Z,ecmerkle,merklee@missouri.edu,2021-06-16T14:30:31Z,fix summary() dispatch for FitIndices and ppmc,DESCRIPTION;NAMESPACE;R/ctr_bayes_fit.R;R/ctr_ppmc.R;man/blavFitIndices.Rd;man/ppmc.Rd,False,True,True,False,39,17,56,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-16.771
+Version: 0.3-16.772
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: NAMESPACE---
@@ -96,9 +96,11 @@ export(""blavaan"", ""bcfa"", ""bsem"", ""bgrowth"", ""dpriors"", ""BF"", ""blavCompare"",
 
 S3method(plot, blavaan)
 S3method(summary, blavaan)
+S3method(summary, blavPPMC)
 S3method(plot, blavPPMC)
 S3method(hist, blavPPMC)
 S3method(pairs, blavPPMC)
+S3method(summary, blavFitIndices)
 exportMethods(""summary"", ""coef"", ""show"", ""predict"")
 
 useDynLib(blavaan, .registration = TRUE)

---FILE: R/ctr_bayes_fit.R---
@@ -16,9 +16,9 @@ setClass(""blavFitIndices"",
                         # list of vectors, each storing the posterior of 1 index
                         indices = ""list""))
 
-summary.blavFitIndices <- function(object,
-                                   central.tendency = c(""mean"",""median"",""mode""),
-                                   hpd = TRUE, prob = .90) {
+summary.bfi <- function(object,
+                        central.tendency = c(""mean"",""median"",""mode""),
+                        hpd = TRUE, prob = .90) {
   if (!is.character(central.tendency)) {
     stop('blavaan ERROR: central.tendency must be a character vector')
   }
@@ -71,6 +71,11 @@ summary.blavFitIndices <- function(object,
                                 ""-based fit indices:"", sep = """")
   out
 }
+
+summary.blavFitIndices <- function(object, ...) {
+  summary.bfi(object, ...)
+}
+
 setMethod(""summary"", ""blavFitIndices"", summary.blavFitIndices)
 
 setMethod(""show"", ""blavFitIndices"", function(object) {

---FILE: R/ctr_ppmc.R---
@@ -15,11 +15,11 @@ setClass(""blavPPMC"",
                         obsDist = ""list"",  # posterior distribution of realized values
                         simDist = ""list"")) # posterior predictive distribution
 
-summary.blavPPMC <- function(object, discFUN, dist = c(""obs"",""sim""),
-                             central.tendency = c(""mean"",""median"",""mode""),
-                             hpd = TRUE, prob = .95,
-                             to.data.frame = FALSE, diag = TRUE,
-                             sort.by = NULL, decreasing = FALSE) {
+summary.ppmc <- function(object, discFUN, dist = c(""obs"",""sim""),
+                         central.tendency = c(""mean"",""median"",""mode""),
+                         hpd = TRUE, prob = .95,
+                         to.data.frame = FALSE, diag = TRUE,
+                         sort.by = NULL, decreasing = FALSE) {
   ## check choices
   if (!is.character(central.tendency)) {
     stop('blavaan ERROR: central.tendency must be a character vector')
@@ -247,6 +247,11 @@ summary.blavPPMC <- function(object, discFUN, dist = c(""obs"",""sim""),
 
   out
 }
+
+summary.blavPPMC <- function(object, ...) {
+  summary.ppmc(object, ...)
+}
+
 setMethod(""summary"", ""blavPPMC"", summary.blavPPMC)
 
 

---FILE: man/blavFitIndices.Rd---
@@ -3,6 +3,7 @@
 \alias{blavFitIndices-class}
 \alias{show,blavFitIndices-method}
 \alias{summary,blavFitIndices-method}
+\alias{summary.bfi}
 \title{SEM Fit Indices for Bayesian SEM}
 \description{
 This function provides a posterior distribution of some \eqn{\chi^2}-based fit
@@ -13,7 +14,9 @@ blavFitIndices(object, thin = 1L, pD = c(""loo"",""waic"",""dic""),
                fit.measures = ""all"", baseline.model = NULL)
 
 ## S4 method for signature 'blavFitIndices'
-\S4method{summary}{blavFitIndices}(object, central.tendency = c(""mean"",""median"",""mode""),
+\S4method{summary}{blavFitIndices}(object, ...)
+
+summary.bfi(object, central.tendency = c(""mean"",""median"",""mode""),
         hpd = TRUE, prob = .90)
 }
 \arguments{
@@ -51,14 +54,18 @@ blavFitIndices(object, thin = 1L, pD = c(""loo"",""waic"",""dic""),
     If a \code{baseline.model} is provided, incremental fit indices (BCFI,
     BTLI, or BNFI) can be requested in \code{fit.measures}. Ignored if
     \code{rescale = ""MCMC""}.}
-  \item{central.tendency}{\code{character} indicating which statistics should
+  \item{...}{Additional arguments to the summary method:}
+  \item{central.tendency}{Takes values ""mean"", ""median"", ""mode"", indicating which statistics should
     be used to characterize the location of the posterior distribution. By
     default, all 3 statistics are returned. The posterior mean is labeled
-    \code{EAP} for \emph{expected a posteriori} estimate, and the mode is
-    labeled \code{MAP} for \emph{modal a posteriori} estimate.}
-  \item{hpd}{\code{logical} indicating whether to calculate the highest
-    posterior density (HPD) credible interval for each fit index.}
-  \item{prob}{The ""confidence"" level of the credible interval(s).}
+    EAP for \emph{expected a posteriori} estimate, and the mode is
+    labeled MAP for \emph{modal a posteriori}
+    estimate.}
+  \item{hpd}{A \code{logical} indicating whether to calculate the highest
+    posterior density (HPD) credible interval for each fit
+    index (defaults to TRUE).}
+  \item{prob}{The ""confidence"" level of the
+  credible interval(s) (defaults to 0.9).}
 }
 \value{
   An S4 object of class \code{blavFitIndices} consisting of 2 slots:

---FILE: man/ppmc.Rd---
@@ -3,6 +3,7 @@
 \alias{blavPPMC-class}
 \alias{show,blavPPMC-method}
 \alias{summary,blavPPMC-method}
+\alias{summary.ppmc}
 \alias{plot.blavPPMC}
 \alias{hist.blavPPMC}
 \alias{pairs.blavPPMC}
@@ -14,7 +15,9 @@ function that can be applied to a \code{\linkS4class{lavaan}} model.}
 \usage{
 ppmc(object, thin = 1, fit.measures = c(""srmr"",""chisq""), discFUN = NULL)
 
-\S4method{summary}{blavPPMC}(object, discFUN, dist = c(""obs"",""sim""),
+\S4method{summary}{blavPPMC}(object, ...)
+
+summary.ppmc(object, discFUN, dist = c(""obs"",""sim""),
         central.tendency = c(""mean"",""median"",""mode""),
         hpd = TRUE, prob = .95, to.data.frame = FALSE, diag = TRUE,
         sort.by = NULL, decreasing = FALSE)"
ecmerkle,blavaan,25de242a7a2fd66f33ea67e0d32d008bc43ef07d,ecmerkle,merklee@missouri.edu,2021-05-28T18:26:22Z,ecmerkle,merklee@missouri.edu,2021-05-28T18:26:22Z,fix jacobian,DESCRIPTION;src/stan_files/stanmarg.stan,False,False,False,False,10,8,18,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-16.770
+Version: 0.3-16.771
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: src/stan_files/stanmarg.stan---
@@ -573,7 +573,9 @@ transformed parameters {
 	    int wig = w15skel[opos, 3];
 	    if (eq == 0 || wig == 1) {
 	      Tau_free[ofreepos] = Tau[g, vecpos, 1];
-	      tau_jacobian += Tau_un[g, vecpos, 1]; // see https://mc-stan.org/docs/2_24/reference-manual/ordered-vector.html
+	      if (j > 1) {
+		tau_jacobian += log(1/(Tau[g, vecpos, 1] - Tau[g, (vecpos - 1), 1])); // see https://mc-stan.org/docs/2_24/reference-manual/ordered-vector.html
+	      }
 	      ofreepos += 1;
 	    }
 	    opos += 1;
@@ -649,13 +651,13 @@ transformed parameters {
 	  if (j > 1) vecpos += sum(nlevs[1:(j - 1)]) - (j - 1);
 	  if (YXo[i,j] == 1) {
 	    YXstar[i, ordidx[j]] = -10 + (Tau[grpnum[patt], (vecpos + 1), 1] + 10) .* z_aug[i,j];
-	    tau_jacobian += log(Tau[grpnum[patt], (vecpos + 1), 1] + 10);  // must add log(U) to tau_jacobian
+	    tau_jacobian += log(1/(Tau[grpnum[patt], (vecpos + 1), 1] + 10));  // must add log(U) to tau_jacobian
 	  } else if (YXo[i,j] == nlevs[j]) {
 	    YXstar[i, ordidx[j]] = Tau[grpnum[patt], vecpos, 1] + (10 - Tau[grpnum[patt], vecpos, 1]) .* z_aug[i,j];
-	    tau_jacobian += log(10 - Tau[grpnum[patt], vecpos, 1]);
+	    tau_jacobian += log(1/(10 - Tau[grpnum[patt], vecpos, 1]));
 	  } else {
 	    YXstar[i, ordidx[j]] = Tau[grpnum[patt], vecpos, 1] + (Tau[grpnum[patt], (vecpos + 1), 1] - Tau[grpnum[patt], vecpos, 1]) .* z_aug[i,j];
-	    tau_jacobian += log(Tau[grpnum[patt], (vecpos + 1), 1] - Tau[grpnum[patt], vecpos, 1]);
+	    tau_jacobian += log(1/(Tau[grpnum[patt], (vecpos + 1), 1] - Tau[grpnum[patt], vecpos, 1]));
 	  }
 	}
       }
@@ -704,7 +706,7 @@ model { // N.B.: things declared in the model block do not get saved in the outp
   }
 
   if (ord) {
-    target += tau_jacobian;
+    target += fabs(tau_jacobian);
   }
   
   /* prior densities in log-units */
@@ -722,14 +724,14 @@ model { // N.B.: things declared in the model block do not get saved in the outp
   if (len_free[5] > 0 && theta_pow != 1) {
     for (i in 1:len_free[5]) {
       Theta_pri[i] = Theta_sd_free[i]^(theta_pow);
-      target += log(abs(theta_pow)) + (theta_pow - 1)*log(Theta_sd_free[i]);
+      target += log(fabs(theta_pow)) + (theta_pow - 1)*log(Theta_sd_free[i]);
     }
   }
   Psi_pri = Psi_sd_free;
   if (len_free[9] > 0 && psi_pow != 1) {
     for (i in 1:len_free[9]) {
       Psi_pri[i] = Psi_sd_free[i]^(psi_pow);
-      target += log(abs(psi_pow)) + (psi_pow - 1)*log(Psi_sd_free[i]);
+      target += log(fabs(psi_pow)) + (psi_pow - 1)*log(Psi_sd_free[i]);
     }
   }
 "
ecmerkle,blavaan,84e95d68c9deec28fe7089c99e0f080888c8e4b5,ecmerkle,merklee@missouri.edu,2021-05-05T02:33:30Z,ecmerkle,merklee@missouri.edu,2021-05-05T02:33:30Z,fixes to ord prep,R/blavaan.R;R/dpriors.R;R/lav_export_stanmarg.R,False,True,True,False,7,7,14,"---FILE: R/blavaan.R---
@@ -489,7 +489,7 @@ blavaan <- function(...,  # default lavaan arguments
                       psirows <- which(l2s$lavpartable$mat == ""lvrho"")
                       lavpartable$prior[as.numeric(rownames(l2s$lavpartable))[psirows]] <- paste0(""lkj_corr("", jagtrans$psi_r_alpha[1], "")"")
                     }
-                    
+
                     jagtrans <- list(data = jagtrans,
                                      monitors = c(""ly_sign"",
                                            #""lx_sign"",

---FILE: R/dpriors.R---
@@ -69,7 +69,7 @@ stanpriors <- function(nu=""normal(0,32)"",
                        beta=""normal(0,10)"", theta=""gamma(1,.5)[sd]"",
                        psi=""gamma(1,.5)[sd]"", rho=""beta(1,1)"",
                        ibpsi=""wishart(3,iden)"",
-                       tau=""normal(0,10^.5)"",
+                       tau=""normal(0,3.16)"",
                        delta=""gamma(1,.5)[sd]""){
 
   dp <- c(nu=nu, alpha=alpha, lambda=lambda, beta=beta,
@@ -84,7 +84,7 @@ stanclassicpriors <- function(nu=""normal(0,1000^.5)"",
                               beta=""normal(0,10)"", itheta=""gamma(1,.5)[prec]"",
                               ipsi=""gamma(1,.5)[prec]"", rho=""beta(1,1)"",
                               ibpsi=""wishart(3,iden)"",
-                              tau=""normal(0,10^.5)"",
+                              tau=""normal(0,3.16)"",
                               delta=""gamma(1,.5)[prec]""){
 
   dp <- c(nu=nu, alpha=alpha, lambda=lambda, beta=beta,

---FILE: R/lav_export_stanmarg.R---
@@ -225,14 +225,14 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
   dat$grpnum <- array(dat$grpnum, length(dat$grpnum))
 
   if (ord) {
-    pta <- lav_partable_attributes(parTable(fit))
+    pta <- lav_partable_attributes(parTable(lavobject))
 
     ordidx <- pta$vidx$ov.ord[[1]]
 
     nlevs <- rep(NA, length(ordidx))
     neach <- vector(""list"", length(ordidx))
     for(i in 1:length(ordidx)){
-      ordvar <- unlist(lapply(lavdata@X, function(x) x[,ordidx[i]]))
+      ordvar <- unlist(lapply(lavobject@Data@X, function(x) x[,ordidx[i]]))
       nlevs[i] <- length(unique(ordvar))
     
       neach[[i]] <- summary(factor(ordvar))
@@ -692,7 +692,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
     veclen <- length(ptrows)
     if (veclen > 0) {
       fpars <- res$wskel[1:veclen,1] == 0 | res$wskel[1:veclen,3] == 1
-      nfree <- c(nfree, list(alpha = sum(fpars)))
+      nfree <- c(nfree, list(tau = sum(fpars)))
       freeparnums[ptrows[fpars]] <- 1:sum(fpars)
     }
   } else {
@@ -733,7 +733,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
 
   ## add inits (manipulate partable to re-use set_inits_stan)
   lavpartable$freeparnums <- freeparnums
-  
+
   ## FIXME theta_x, cov.x not handled
   if (!(inits %in% c(""jags"", ""stan""))) {
     ini <- set_inits_stan(lavpartable, nfree, n.chains, inits)"
ecmerkle,blavaan,34cf6e4bc878b69347729a02daf11f574b0ac836,ecmerkle,merklee@missouri.edu,2021-04-08T16:41:37Z,ecmerkle,merklee@missouri.edu,2021-04-08T16:41:37Z,fixes #32,DESCRIPTION;R/blav_fit_measures.R;R/blav_object_methods.R;R/blavaan.R,False,True,True,False,16,6,22,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-16.736
+Version: 0.3-16.738
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_fit_measures.R---
@@ -18,18 +18,23 @@ blav_fit_measures <- function(object, fit.measures = ""all"",
     # has the model converged?
     if(object@Fit@npar > 0L && !object@optim$converged &&
        class(object@external$mcmcout) != ""NULL"") {
-        warning(""blavaan WARNING: the chains may not have converged."")
+        warning(""blavaan WARNING: the chains may not have converged."", call. = FALSE)
     }
 
     # do we have a test statistic?
-    if(object@Options$test == ""none"") {
+    if(blavInspect(object, ""options"")$test == ""none"") {
         stop(""blavaan ERROR: fit measures cannot be obtained when test=\""none\"""")
     }
 
+    if(blavInspect(object, ""options"")$prisamp) {
+        warning(""blavaan WARNING: These metrics are based on prior samples so may be meaningless."",
+                call. = FALSE)
+    }
+  
     if(""all"" %in% fit.measures) {
-       class.flag <- TRUE
+        class.flag <- TRUE
     } else {
-       class.flag <- FALSE
+        class.flag <- FALSE
     }
 
     # collect info from the lavaan slots

---FILE: R/blav_object_methods.R---
@@ -317,7 +317,11 @@ long.summary <- function(object,
         ## require ""est""
         #names(PE)[penames == ""est""] <- ""Post.Mean""
         #PE$est <- PE$Post.Mean
-        names(PE)[penames == ""se""] <- ""Post.SD""
+        if(blavInspect(object, 'options')$prisamp){
+          names(PE)[penames == ""se""] <- ""Pri.SD""
+        } else {
+          names(PE)[penames == ""se""] <- ""Post.SD""
+        }
         names(PE)[penames == ""ci.lower""] <- ""pi.lower""
         names(PE)[penames == ""ci.upper""] <- ""pi.upper""
         names(PE)[penames == ""psrf""] <- ""Rhat""

---FILE: R/blavaan.R---
@@ -434,6 +434,7 @@ blavaan <- function(...,  # default lavaan arguments
     lavoptions$missing   <- ""ml""
     lavoptions$cp        <- cp
     lavoptions$dp        <- dp
+    lavoptions$prisamp   <- prisamp
     lavoptions$target    <- target
 
     verbose <- lavoptions$verbose"
ecmerkle,blavaan,101091a4a5aba860e0a1d9fa8e16a38038c30883,ecmerkle,merklee@missouri.edu,2021-03-21T17:08:19Z,ecmerkle,merklee@missouri.edu,2021-03-21T17:08:19Z,deal with fixed.x in stan log_lik,R/lav_export_stanmarg.R;R/stanmarg_data.R;src/stan_files/stanmarg.stan,False,True,True,False,29,2,31,"---FILE: R/lav_export_stanmarg.R---
@@ -166,6 +166,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
   nvar <- ncol(YX[[1]])
   dat$N <- lavInspect(lavobject, 'nobs')
   dat$pri_only <- prisamp
+  xidx <- lavobject@SampleStats@x.idx[[1]]
 
   ## lavobject@SampleStats@missing.flag is TRUE when missing='ml',
   ## regardless of whether data are missing
@@ -190,9 +191,16 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
     dat$Np <- length(unique(misgrps))
     dat$Ntot <- sum(dat$N)
     dat$Obsvar <- matrix(0, dat$Np, nvar)
+    dat$Nx <- rep(0, dat$Np)
+    dat$Xvar <- matrix(0, dat$Np, length(xidx))
     
     for (i in 1:dat$Np) {
       dat$Obsvar[i, 1:dat$Nobs[i]] <- Obsvar[[i]]
+      xpat <- xidx[xidx %in% Obsvar[[i]]]
+      if (length(xpat) > 0) {
+        dat$Nx[i] <- length(xpat)
+        dat$Xvar[i, 1:length(xpat)] <- xpat
+      }
     }
 
     for (g in 1:dat$Ng) {
@@ -208,6 +216,8 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
     dat$Np <- dat$Ng
     dat$Nobs <- array(nvar, dat$Np)
     dat$Obsvar <- matrix(1:nvar, dat$Np, nvar, byrow=TRUE)
+    dat$Nx <- array(length(xidx), dat$Np)
+    dat$Xvar <- matrix(xidx, dat$Np, length(xidx), byrow=TRUE)
   }
   dat$YX <- do.call(""rbind"", YX)
   dat$grpnum <- array(dat$grpnum, length(dat$grpnum))

---FILE: R/stanmarg_data.R---
@@ -179,6 +179,7 @@ check_priors <- function(lavpartable) {
 #' # fill in
 stanmarg_data <- function(YX = NULL, S = NULL, N, Ng, grpnum, # data
                           miss, Np, Nobs, Obsvar, # missing
+                          Xvar, Nx, # fixed.x
                           startrow, endrow, save_lvs = FALSE, 
                           Lambda_y_skeleton, # skeleton matrices
                           Lambda_x_skeleton, Gamma_skeleton, B_skeleton,
@@ -210,6 +211,8 @@ stanmarg_data <- function(YX = NULL, S = NULL, N, Ng, grpnum, # data
   dat$Obsvar <- Obsvar
   dat$startrow <- startrow
   dat$endrow <- endrow
+  dat$Xvar <- Xvar
+  dat$Nx <- array(Nx, length(Nx))
 
   dat$YX <- YX
   stopifnot(nrow(dat$YX) == dat$Ntot)

---FILE: src/stan_files/stanmarg.stan---
@@ -157,16 +157,18 @@ data {
   int<lower=0, upper=1> missing; // are there missing values?
   int<lower=0, upper=1> save_lvs; // should we save lvs?
   int<lower=1> Np; // number of group-by-missing patterns combos
-  int<lower= 1> N[Ng]; // number of observations per group
+  int<lower=1> N[Ng]; // number of observations per group
   int<lower=1> Nobs[Np]; // number of observed variables in each missing pattern
-  int<lower=0> Obsvar[Np, p + q];
+  int<lower=0> Obsvar[Np, p + q]; // indexing of observed variables
   int<lower=1> Ntot; // number of observations across all groups
   int<lower=1> startrow[Np]; // starting row for each missing pattern
   int<lower=1,upper=Ntot> endrow[Np]; // ending row for each missing pattern
   int<lower=1,upper=Ng> grpnum[Np]; // group number for each row of data
   int<lower=0,upper=1> wigind; // do any parameters have approx equality constraint ('wiggle')?
   int<lower=0, upper=1> has_data; // are the raw data on y and x available?
   vector[p + q] YX[has_data ? Ntot : 0]; // if data, include them
+  int<lower=0> Nx[Np]; // number of fixed.x variables
+  int<lower=0> Xvar[Np, max(Nx)]; // indexing of fixed.x variables
   int<lower=0, upper=1> has_cov;
   cov_matrix[p + q] S[Ng];     // sample covariance matrix among all manifest variables NB!! multiply by (N-1) to use wishart lpdf!!
 
@@ -568,15 +570,21 @@ model { // N.B.: things declared in the model block do not get saved in the outp
   /* log-likelihood */
   if (has_data) {
     int obsidx[p + q];
+    int xidx[max(Nx)];
     int r1;
     int r2;
     int grpidx;
     for (mm in 1:Np) {
       obsidx = Obsvar[mm,];
+      xidx = Xvar[mm,];
       r1 = startrow[mm];
       r2 = endrow[mm];
       grpidx = grpnum[mm];
       target += multi_normal_lpdf(YX[r1:r2,1:Nobs[mm]] | Mu[grpidx, obsidx[1:Nobs[mm]]], Sigma[grpidx, obsidx[1:Nobs[mm]], obsidx[1:Nobs[mm]]]);
+
+      if (Nx[mm] > 0) {
+	target += -multi_normal_lpdf(YX[r1:r2,xidx[1:Nx[mm]]] | Mu[grpidx, xidx[1:Nx[mm]]], Sigma[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
+      }
     }
   } else if (has_cov) {
     for (g in 1:Ng) {
@@ -692,16 +700,22 @@ generated quantities { // these matrices are saved in the output but do not figu
   // log-likelihood
   if (has_data) {
     int obsidx[p + q];
+    int xidx[max(Nx)];
     int r1;
     int r2;
     int grpidx;
     for (mm in 1:Np) {
       obsidx = Obsvar[mm,];
+      xidx = Xvar[mm,];
       r1 = startrow[mm];
       r2 = endrow[mm];
       grpidx = grpnum[mm];
       for (jj in r1:r2) {
 	log_lik[jj] = multi_normal_lpdf(YX[jj,1:Nobs[mm]] | Mu[grpidx, obsidx[1:Nobs[mm]]], Sigma[grpidx, obsidx[1:Nobs[mm]], obsidx[1:Nobs[mm]]]);
+
+	if (Nx[mm] > 0) {
+	  log_lik[jj] -= multi_normal_lpdf(YX[jj,xidx[1:Nx[mm]]] | Mu[grpidx, xidx[1:Nx[mm]]], Sigma[grpidx, xidx[1:Nx[mm]], xidx[1:Nx[mm]]]);
+	}
       }
     }
   } else if (has_cov) {"
ecmerkle,blavaan,352f9ac1f288bc14a63efb7e8c4bd9d68b2d77a0,ecmerkle,merklee@missouri.edu,2021-03-20T14:52:39Z,ecmerkle,merklee@missouri.edu,2021-03-20T14:52:39Z,fix fitMeasures change,DESCRIPTION;R/blav_fit_measures.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-16.734
+Version: 0.3-16.735
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_fit_measures.R---
@@ -167,7 +167,7 @@ blav_fit_measures <- function(object, fit.measures = ""all"",
         lavopt <- object@Options
         lavopt$estimator <- ""ML""
         if(lavopt$target == ""stan""){
-          casells <- loo::extract_log_lik(object2@external$mcmcout)
+          casells <- loo::extract_log_lik(object@external$mcmcout)
         } else {
           casells <- case_lls(object@external$mcmcout, object@Model,
                               object@ParTable, object@SampleStats,"
ecmerkle,blavaan,ffa69b26f3fa3400b8936a9dece6e03878de845f,ecmerkle,merklee@missouri.edu,2021-03-08T18:15:51Z,ecmerkle,merklee@missouri.edu,2021-03-08T18:15:51Z,fix tests,DESCRIPTION;tests/testthat/tests.blavaanobject-methods.R,False,True,True,False,5,5,10,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-16.728
+Version: 0.3-16.729
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: tests/testthat/tests.blavaanobject-methods.R---
@@ -131,9 +131,9 @@ test_that(""blavaan object methods work"", {
   expect_error(blavPredict(fitstanc))
   expect_error(blavPredict(fitjags))
 
-  expect_true(dim(blavPredict(fitstanfs)), c(20,602))
-  expect_true(dim(blavPredict, type=""lvmeans""), c(301,2))
-  expect_true(dim(blavPredict(fitstanfs, type=""ov"")[[1]]), c(301,6))
-  expect_true(dim(blavPredict(fitstanfs, type=""ypred"")[[1]]), c(301,6))
+  expect_equal(dim(blavPredict(fitstanfs)), c(20,602))
+  expect_equal(dim(blavPredict(fitstanfs, type=""lvmeans"")), c(301,2))
+  expect_equal(dim(blavPredict(fitstanfs, type=""ov"")[[1]]), c(301,6))
+  expect_equal(dim(blavPredict(fitstanfs, type=""ypred"")[[1]]), c(301,6))
   expect_error(blavPredict(fitstanfs, type=""ymis""))
 })"
ecmerkle,blavaan,c88b9442e420dee6bad7e14723653a2a3f8f41fd,ecmerkle,merklee@missouri.edu,2021-03-06T18:00:31Z,ecmerkle,merklee@missouri.edu,2021-03-06T18:00:31Z,fix doc mismatches,DESCRIPTION;R/blav_predict.R;man/blavaan-class.Rd,False,True,True,False,20,20,40,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-16.726
+Version: 0.3-16.727
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_predict.R---
@@ -2,17 +2,17 @@
 ## overload standard R function `predict'
 setMethod(""predict"", ""blavaan"",
 function(object, newdata = NULL) {
-    blavPredict(blavobject = object, newdata = newdata, type = ""lv"")
+    blavPredict(object, newdata = newdata, type = ""lv"")
 })
 
-blavPredict <- function(blavobject, newdata = NULL, type = ""lv"") {
+blavPredict <- function(object, newdata = NULL, type = ""lv"") {
 
-  stopifnot(inherits(blavobject, ""blavaan""))
-  blavmodel <- blavobject@Model
-  blavpartable <- blavobject@ParTable
-  blavsamplestats <- blavobject@SampleStats
-  blavdata <- blavobject@Data
-  standata <- blavobject@external$mcmcdata
+  stopifnot(inherits(object, ""blavaan""))
+  blavmodel <- object@Model
+  blavpartable <- object@ParTable
+  blavsamplestats <- object@SampleStats
+  blavdata <- object@Data
+  standata <- object@external$mcmcdata
   
   type <- tolower(type)
   if(type %in% c(""latent"", ""lv"", ""factor"", ""factor.score"", ""factorscore""))
@@ -24,7 +24,7 @@ blavPredict <- function(blavobject, newdata = NULL, type = ""lv"") {
   if(type %in% c(""ymis"", ""ovmis""))
       type <- ""ymis""
   
-  stantarget <- lavInspect(blavobject, ""options"")$target == ""stan""
+  stantarget <- lavInspect(object, ""options"")$target == ""stan""
 
   if(!is.null(newdata)) stop(""blavaan ERROR: posterior predictions for newdata are not currently supported"")
   
@@ -34,18 +34,18 @@ blavPredict <- function(blavobject, newdata = NULL, type = ""lv"") {
   ## ypred: posterior predictive distribution of ovs conditioned on lv samples; mcmc list
   ## ymis: posterior predictive distribution of missing values conditioned on observed values; matrix
   if(type == ""lv"") {
-    out <- do.call(""rbind"", blavInspect(blavobject, 'lvs'))
+    out <- do.call(""rbind"", blavInspect(object, 'lvs'))
   } else if(type == ""lvmeans"") {
-    out <- blavInspect(blavobject, 'lvmeans')
+    out <- blavInspect(object, 'lvmeans')
   } else if(type %in% c(""yhat"", ""ypred"", ""ymis"")) {
     if(!stantarget) stop(paste0(""blavaan ERROR: '"", type, ""' is only supported for target='stan'""))
 
     if(type %in% c(""yhat"", ""ypred"")) {
-      lavmcmc <- make_mcmc(blavInspect(blavobject, 'mcobj'), blavobject@external$stanlvs)
-      itnums <- sampnums(blavobject@external$mcmcout, thin = 1)
+      lavmcmc <- make_mcmc(blavInspect(object, 'mcobj'), object@external$stanlvs)
+      itnums <- sampnums(object@external$mcmcout, thin = 1)
       nsamps <- length(itnums)
       nchain <- length(lavmcmc)
-      ng <- blavInspect(blavobject, 'ngroups')
+      ng <- blavInspect(object, 'ngroups')
 
       tmpres <- vector(""list"", nchain)
       for(j in 1:nchain) {
@@ -55,7 +55,7 @@ blavPredict <- function(blavobject, newdata = NULL, type = ""lv"") {
                        blavpartable,
                        blavsamplestats,
                        blavdata,
-                       blavobject)}, j = j)
+                       object)}, j = j)
         tmpres[[j]] <- do.call(""future_lapply"", loop.args)
       }
       tmpres <- unlist(tmpres, recursive = FALSE)
@@ -73,15 +73,15 @@ blavPredict <- function(blavobject, newdata = NULL, type = ""lv"") {
       }
 
       ## these are now lists by group; rearrange to match original data
-      cids <- unlist(blavInspect(blavobject, 'case.idx'))
-      cnms <- lavNames(blavobject)
+      cids <- unlist(blavInspect(object, 'case.idx'))
+      cnms <- lavNames(object)
       yres <- lapply(tmpres, function(x) do.call(""rbind"", x)[cids,])
       
       out <- yres
     }
 
     if(type == ""ymis"") {
-      out <- samp_data(blavobject@external$mcmcout, blavmodel, blavpartable, standata, blavdata)
+      out <- samp_data(object@external$mcmcout, blavmodel, blavpartable, standata, blavdata)
     }
   } else {
     stop(""blavaan ERROR: unknown type supplied; use lv lvmeans yhat ypred ymis"")

---FILE: man/blavaan-class.Rd---
@@ -3,7 +3,7 @@
 \alias{blavaan-class}
 \alias{coef,blavaan-method}
 \alias{show,blavaan-method}
-%\alias{predict,blavaan-method}
+\alias{predict,blavaan-method}
 %\alias{fitted,blavaan-method}
 %\alias{fitted.values,blavaan-method}    %% NOTE: no white space here!
 \alias{summary,blavaan-method}"
ecmerkle,blavaan,8c62a7abce3fbbb595843d4ec60ac8ad24f3ae0c,ecmerkle,merklee@missouri.edu,2021-02-18T20:50:31Z,ecmerkle,merklee@missouri.edu,2021-02-18T20:50:31Z,improve check for lvs manually fixed to 1,DESCRIPTION;R/blavaan.R,False,True,True,False,3,2,5,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-15.722
+Version: 0.3-15.723
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blavaan.R---
@@ -371,8 +371,9 @@ blavaan <- function(...,  # default lavaan arguments
         if(any(LAV@ParTable$op == ""~~"" &
                LAV@ParTable$free == 0 &
                LAV@ParTable$lhs == LAV@ParTable$rhs &
+               LAV@ParTable$ustart == 1L &
                LAV@ParTable$lhs %in% lvs)){
-            warning(""blavaan WARNING: If you are manually fixing lvs to 1 for identification,"",
+            warning(""blavaan WARNING: If you are manually fixing lv variances to 1 for identification, "",
                     ""please use std.lv=TRUE."", call. = FALSE)
         }
     }"
ecmerkle,blavaan,a7f7581fc9aa2ef1ae283f1c5ab87bed17f553d8,ecmerkle,merklee@missouri.edu,2021-02-18T20:12:41Z,ecmerkle,merklee@missouri.edu,2021-02-18T20:12:41Z,fix condition with length > 1,DESCRIPTION;R/blav_cond_utils.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-15.721
+Version: 0.3-15.722
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_cond_utils.R---
@@ -109,7 +109,7 @@ fill_eta <- function(postsamp, lavmodel, lavpartable, lavsamplestats, lavdata){
     if(foundlvs < nlv) etamat <- cbind(etamat, matrix(0, lavsamplestats@ntotal, (nlv - foundlvs)))
 
     ## fulleta needs to have rows for any excluded cases
-    if(lavdata@norig > lavsamplestats@ntotal){
+    if(sum(unlist(lavdata@norig)) > lavsamplestats@ntotal){
       fulleta <- matrix(NA, sum(unlist(lavdata@norig)), ncol(etamat))
       empties <- as.numeric(sapply(lavdata@Mp, function(x) x$empty.idx))
       fulleta[-empties,] <- etamat"
ecmerkle,blavaan,28165e0100d5cfcd62867c84dd25cb3ea989a8c8,ecmerkle,merklee@missouri.edu,2021-02-18T18:55:13Z,ecmerkle,merklee@missouri.edu,2021-02-18T18:55:13Z,"fix lv sampling with missing data, target='stan'",DESCRIPTION;R/lvgqs.R,False,True,True,False,6,4,10,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-15.719
+Version: 0.3-15.721
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lvgqs.R---
@@ -78,10 +78,12 @@ lvgqs <- function(modmats, standata, getlvs = TRUE) {
         bottom_right <- cov_eta
 
         L <- bottom_right[usepsi,usepsi,drop=FALSE] - (corner[,obsidx[1:Nobs[mm]],drop=FALSE] %*% precision[1:Nobs[mm],1:Nobs[mm]] %*% t(corner[,obsidx[1:Nobs[mm]],drop=FALSE]))[usepsi,usepsi,drop=FALSE]
-        if (all(round(L, 6) == 0)) {
+        L <- try(chol(L))
+        if (inherits(L, 'try-error')) {
           L <- matrix(0, nrow=NROW(L), ncol=NCOL(L))
-        } else {
-          L <- chol(L)
+        }
+        if (anymis) {
+          corner <- corner[,obsidx[1:Nobs[mm]]]
         }
       } else if (anymis) {
         ## impute missing observed values"
ecmerkle,blavaan,50de2f5b7829d17ad7c32e511768d3cf0a5e167a,ecmerkle,merklee@missouri.edu,2021-01-30T00:38:31Z,ecmerkle,merklee@missouri.edu,2021-01-30T00:38:31Z,warn if manually fixing lv variances to 1,DESCRIPTION;R/blavaan.R,False,True,True,False,11,3,14,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-15.714
+Version: 0.3-15.715
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blavaan.R---
@@ -338,13 +338,13 @@ blavaan <- function(...,  # default lavaan arguments
     if(con.cov) LAV@Options$auto.cov.lv.x <- FALSE
     
     # if std.lv, truncate the prior of each lv's first loading
+    loadpt <- LAV@ParTable$op == ""=~""
+    lvs <- unique(LAV@ParTable$lhs[loadpt])
     if(LAV@Options$std.lv){
         if(cp == ""fa"") stop(""blavaan ERROR: 'fa' prior strategy cannot be used with std.lv=TRUE."")
         if(!prispec){
             LAV@ParTable$prior <- rep("""", length(LAV@ParTable$id))
         }
-        loadpt <- LAV@ParTable$op == ""=~""
-        lvs <- unique(LAV@ParTable$lhs[loadpt])
         fload <- NULL
         if(length(lvs) > 0){
             for(i in 1:length(lvs)){
@@ -366,6 +366,14 @@ blavaan <- function(...,  # default lavaan arguments
                 }
             }
         }
+    } else {
+        ## check for lvs fixed to 1
+        if(any(LAV@ParTable$op == ""~~"" &
+               LAV@ParTable$free == 0 &
+               LAV@ParTable$lhs == LAV@ParTable$rhs &
+               LAV@ParTable$lhs %in% lvs)){
+            warning(""blavaan WARNING: If you are manually fixing lvs to 1 for identification, please use std.lv=TRUE."", call. = FALSE)
+        }
     }
 
     # if mcmcfile is a directory, vs list, vs logical"
ecmerkle,blavaan,e7779012c51b0d689f773a074d9ee30919b3f6f8,ecmerkle,merklee@missouri.edu,2021-01-05T15:51:54Z,ecmerkle,merklee@missouri.edu,2021-01-05T15:51:54Z,fix Matrix error,DESCRIPTION;R/blav_predict.R;R/stanmarg_data.R,False,True,True,False,6,4,10,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-13.704
+Version: 0.3-13.705
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",
@@ -33,6 +33,6 @@ ByteCompile: true
 Depends: R(>= 3.5.0), methods, lavaan(>= 0.6-5), Rcpp(>= 0.12.15), RcppParallel (>= 5.0.1)
 Imports: stats, utils, graphics, MCMCpack, coda, mnormt, nonnest2(>= 0.5-5), loo(>= 2.0), rstan(>= 2.19.2), rstantools(>= 1.5.0), bayesplot, future.apply
 LinkingTo: StanHeaders (>= 2.18.1), rstan (>= 2.19.2), BH (>= 1.69.0), Rcpp (>= 0.12.15), RcppEigen (>= 0.3.3.4.0), RcppParallel (>= 5.0.1)
-Suggests: runjags(>= 2.0.4-2), modeest(>= 2.3.3), rjags, semTools, testthat(>= 2.0.0)
+Suggests: Matrix, runjags(>= 2.0.4-2), modeest(>= 2.3.3), rjags, semTools, testthat(>= 2.0.0)
 SystemRequirements: GNU make
 NeedsCompilation: yes

---FILE: R/blav_predict.R---
@@ -2,7 +2,7 @@
 ## overload standard R function `predict'
 setMethod(""predict"", ""blavaan"",
 function(object, newdata = NULL) {
-    blavPredict(object = object, newdata = newdata, type = ""lv"")
+    blavPredict(blavobject = object, newdata = newdata, type = ""lv"")
 })
 
 blavPredict <- function(blavobject, newdata = NULL, type = ""lv"") {

---FILE: R/stanmarg_data.R---
@@ -13,7 +13,9 @@ make_sparse_skeleton <- function(skeleton) {
   stopifnot(is.matrix(skeleton))
   #skeleton[is.na(skeleton)] <- 1L
   vals <- c(t(skeleton)) # vals needs to be in row-major order
-  parts <- rstan::extract_sparse_parts(!(skeleton==0L)) #is.na(skeleton))
+  ## addresses change to Matrix clashing with extract_sparse_parts
+  spmat <- Matrix::Matrix(!(skeleton==0L), doDiag=FALSE, sparse=TRUE)
+  parts <- rstan::extract_sparse_parts(spmat) #is.na(skeleton))
   parts$w <- as.array(vals[!(vals==0L)]) #is.na(vals)])
   parts$v <- as.array(parts$v)
   parts$u <- as.array(parts$u)"
ecmerkle,blavaan,57a8a97d5b2336c24c509ae9e8bbfade6ddc727d,ecmerkle,merklee@missouri.edu,2020-11-05T22:17:05Z,ecmerkle,merklee@missouri.edu,2020-11-05T22:17:05Z,avoid conditional likelihood errors,R/blav_utils.R,False,True,True,False,2,0,2,"---FILE: R/blav_utils.R---
@@ -35,6 +35,8 @@ get_ll <- function(postsamp       = NULL, # one posterior sample
       ## to avoid warnings from mnormt::pd.solve
       covmat <- lapply(covmat, function(x){
         class(x) <- ""matrix""
+        zvar <- which(diag(x) == 0L)
+        if(length(zvar > 0)) diag(x)[zvar] <- 1e-4
         x})
 
       ngroups <- lavsamplestats@ngroups"
ecmerkle,blavaan,afa979b756c090ecbfaa8003eb779600241bcf69,ecmerkle,merklee@missouri.edu,2020-11-04T02:18:06Z,ecmerkle,merklee@missouri.edu,2020-11-04T02:18:06Z,fix up stanclassic,R/blavaan.R;R/lav_export_stanclassic.R,False,True,True,False,3,3,6,"---FILE: R/blavaan.R---
@@ -659,7 +659,7 @@ blavaan <- function(...,  # default lavaan arguments
                     lavpartable$est <- lav_model_get_parameters(lavmodel = lavmodel, type = ""user"", extra = TRUE)
                 }
                 ## lvs now in R instead of Stan
-                if(save.lvs){
+                if(save.lvs & target == ""stan""){
                     stanlvs <- samp_lvs(res, lavmodel, parests$lavpartable, jagtrans$data)
                     if(dim(stanlvs)[3L] > 0){
                         lvsumm <- as.matrix(rstan::monitor(stanlvs, print=FALSE))
@@ -851,7 +851,7 @@ blavaan <- function(...,  # default lavaan arguments
                     sample = sample)
     if(grepl(""stan"", target)){
       extslot <- c(extslot, list(stansumm = stansumm))
-      if(save.lvs) extslot <- c(extslot, list(stanlvs = stanlvs))
+      if(save.lvs & target==""stan"") extslot <- c(extslot, list(stanlvs = stanlvs))
     }
     if(jags.ic) extslot <- c(extslot, list(sampkls = sampkls))
     if(save.lvs) {

---FILE: R/lav_export_stanclassic.R---
@@ -1176,7 +1176,7 @@ coeffun_stan <- function(lavpartable, pxpartable, rsob, fun = ""mean"") {
     ## vcorr
     draw_mat <- as.matrix(rsob)
     cmatch <- match(ptnames[pxpartable$free > 0][order(pxpartable$free[pxpartable$free > 0])], colnames(draw_mat))
-    vcorr <- cor(draw_mat[,cmatch])
+    vcorr <- cor(draw_mat[, cmatch, drop=FALSE])
 
     svmatch <- match(colnames(vcorr), names(sdvec), nomatch = 0)
     sdvec <- sdvec[svmatch]"
ecmerkle,blavaan,7f0019229282da2ca7e82cb8b4edab060528b059,ecmerkle,merklee@missouri.edu,2020-11-03T23:41:04Z,ecmerkle,merklee@missouri.edu,2020-11-03T23:41:04Z,fix for models with only one free parameter,R/blavaan.R;R/lav_export_stanmarg.R,False,True,True,False,3,2,5,"---FILE: R/blavaan.R---
@@ -768,7 +768,8 @@ blavaan <- function(...,  # default lavaan arguments
     lavvcov <- list()
     VCOV <- NULL
     if(jag.do.fit){
-      dsd <- diag(parests$sd[names(parests$sd) %in% colnames(parests$vcorr)])
+      dsd <- parests$sd[names(parests$sd) %in% colnames(parests$vcorr)]
+      if(length(dsd) > 1) dsd <- diag(dsd)
       VCOV <- dsd %*% parests$vcorr %*% dsd
       rownames(VCOV) <- colnames(VCOV) <- colnames(parests$vcorr)
       #lavjags <- c(lavjags, list(vcov = VCOV))

---FILE: R/lav_export_stanmarg.R---
@@ -816,7 +816,7 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, fun = ""
       }
     }
 
-    vcorr <- cor(draw_mat[,rowidx2])
+    vcorr <- cor(draw_mat[, rowidx2, drop=FALSE])
 
     names(sdvec) <- colnames(vcorr)
 "
ecmerkle,blavaan,2b9a7cf4c4768755474249b307039b6fe7ace82a,ecmerkle,merklee@missouri.edu,2020-10-30T02:29:59Z,ecmerkle,merklee@missouri.edu,2020-10-30T02:29:59Z,fix test,NAMESPACE;R/blavaan.R,False,True,True,False,9,8,17,"---FILE: NAMESPACE---
@@ -15,7 +15,7 @@ importFrom(""stats"",
            ""predict"",
            ""update"",
            ""anova"",
-           ""vcov"", ""nobs"")
+           ""vcov"", ""nobs"", ""cov2cor"")
 
 importFrom(""graphics"",
            ""plot"", ""hist"", ""pairs"", ""legend"", ""par"", ""plot.new"",

---FILE: R/blavaan.R---
@@ -640,13 +640,6 @@ blavaan <- function(...,  # default lavaan arguments
         } else {
           parests <- coeffun_stanmarg(lavpartable, lavInspect(LAV, 'free'), l2s$free2, jagtrans$data, res)
           stansumm <- parests$stansumm
-          ## lvs now in R instead of Stan
-          if(save.lvs){
-            stanlvs <- samp_lvs(res, lavmodel, parests$lavpartable, jagtrans$data)
-            lvsumm <- as.matrix(rstan::monitor(stanlvs, print=FALSE))
-            cmatch <- match(colnames(stansumm), colnames(lvsumm))
-            stansumm <- rbind(stansumm, lvsumm[,cmatch])
-          }
         }
         x <- parests$x
         lavpartable <- parests$lavpartable
@@ -665,6 +658,13 @@ blavaan <- function(...,  # default lavaan arguments
                     ## defined variables come from delta method:
                     lavpartable$est <- lav_model_get_parameters(lavmodel = lavmodel, type = ""user"", extra = TRUE)
                 }
+                ## lvs now in R instead of Stan
+                if(save.lvs){
+                    stanlvs <- samp_lvs(res, lavmodel, parests$lavpartable, jagtrans$data)
+                    lvsumm <- as.matrix(rstan::monitor(stanlvs, print=FALSE))
+                    cmatch <- match(colnames(stansumm), colnames(lvsumm))
+                    stansumm <- rbind(stansumm, lvsumm[,cmatch])
+                }
                 # burnin + sample already defined, will be saved in
                 # @external so summary() can use it:
                 #burnin <- wrmup
@@ -677,6 +677,7 @@ blavaan <- function(...,  # default lavaan arguments
             attr(x, ""converged"") <- FALSE
             lavpartable$est <- lavpartable$start
             stansumm <- NULL
+            stanlvs <- NULL
         }
         attr(x, ""control"") <- bcontrol
 "
ecmerkle,blavaan,77ceb70625797790645b56ea2d0684979d9dfcde,ecmerkle,merklee@missouri.edu,2020-10-15T18:08:41Z,ecmerkle,merklee@missouri.edu,2020-10-15T18:08:41Z,fix variable name,R/margloglik.R,False,True,True,False,1,1,2,"---FILE: R/margloglik.R---
@@ -90,7 +90,7 @@ margloglik <- function(lavpartable, lavmodel, lavoptions,
       } else {
         etapar <- as.numeric(pricom[[wps[1]]][2])
         ## etapar==1 has you adding 0, so avoid
-        if(etapar != 1) priloglik <- priloglik + (eta - 1) * log(det(cov2cor(tmpmat)))
+        if(etapar != 1) priloglik <- priloglik + (etapar - 1) * log(det(cov2cor(tmpmat)))
       }
     }
   } else {"
ecmerkle,blavaan,2acd089f08a38789338c2d64ff5c6546422c019f,ecmerkle,merklee@missouri.edu,2020-10-15T03:18:33Z,ecmerkle,merklee@missouri.edu,2020-10-15T03:18:33Z,fix problem with evaluating psi,DESCRIPTION;R/lav_export_stanmarg.R,False,True,True,False,4,2,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-11.661
+Version: 0.3-11.670
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lav_export_stanmarg.R---
@@ -550,7 +550,9 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
     }
     ## check for completely unrestricted correlation matrix, for lkj
     fpars <- sapply(res$free2, function(x) as.numeric(x[lower.tri(x)]))
-    if(all(!duplicated(fpars)) & all(fpars > 0) & all(res$wskel[,1] == 0)) dat$fullpsi <- 1L
+    if (length(unlist(fpars)) > 0) {
+      if (all(!duplicated(fpars)) & all(fpars > 0) & all(res$wskel[,1] == 0)) dat$fullpsi <- 1L
+    }
   } else {
     dat$Psi_r_skeleton <- array(0, dim = c(Ng, 0, 0))
     dat$w10skel <- matrix(0, 0, 3)"
ecmerkle,blavaan,ca77176cf8af83eb90e4ea6bc31fc994e197d2f3,ecmerkle,merklee@missouri.edu,2020-09-23T15:22:27Z,ecmerkle,merklee@missouri.edu,2020-09-23T15:22:27Z,fix for #29,DESCRIPTION;R/lav_export_stanmarg.R,False,True,True,False,6,2,8,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-11.649
+Version: 0.3-11.656
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/lav_export_stanmarg.R---
@@ -136,7 +136,11 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, wig, ...) {
             psign <- min(parnums)
             ## if equality constraint, sign must involve the
             ## ""free"" parameter
-            if (wskel[psign,1] == 1L) psign <- wskel[psign,2]
+            if (wskel[psign,1] == 1L) {
+              psign <- wskel[psign,2]
+            } else {
+              psign <- psign - sum(wskel[1:(psign-1),1] == 1)
+            }
             sign[parnums, 1] <- 1L
             sign[parnums, 2] <- psign
           }"
ecmerkle,blavaan,f8072101e25838278d443ae56c8349c47cb78f43,ecmerkle,merklee@missouri.edu,2020-09-21T16:56:36Z,ecmerkle,merklee@missouri.edu,2020-09-21T16:56:36Z,fix stanclassic == constraints,R/blavaan.R;R/set_stanpars.R,False,True,True,False,6,1,7,"---FILE: R/blavaan.R---
@@ -49,7 +49,8 @@ blavaan <- function(...,  # default lavaan arguments
 
     # multilevel functionality not available
     if(""cluster"" %in% dotNames) stop(""blavaan ERROR: two-level models are not yet available."")
-
+    if(""ordered"" %in% dotNames) stop(""blavaan ERROR: ordinal models are not yet available."")
+  
     # prior predictives only for stan
     if(prisamp) {
       if(target != 'stan') stop(""blavaan ERROR: prior predictives currently only work for target='stan'."")

---FILE: R/set_stanpars.R---
@@ -79,6 +79,7 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
             } else if(length(eqpar) > 0){
                 eqpar <- which(partable$plabel == partable$lhs[eqpar] |
                                partable$label == partable$lhs[eqpar])
+                if(length(eqpar) > 1) eqpar <- eqpar[which(partable$label[eqpar] == partable$plabel[eqpar])]
                 if(partable$freeparnums[eqpar] == 0){
                     eqtxt <- paste(partable$mat[eqpar], ""["",
                                    partable$row[eqpar], "","",
@@ -175,10 +176,13 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
                 }
                 vpri <- grepl(""\\[var\\]"", partable$prior[i])
                 spri <- grepl(""\\[sd\\]"", partable$prior[i])
+                ppri <- grepl(""\\[prec\\]"", partable$prior[i])
                 if(vpri){
                     jagpri <- strsplit(partable$prior[i], ""\\[var"")[[1]][1]
                 } else if(spri){
                     jagpri <- strsplit(partable$prior[i], ""\\[sd"")[[1]][1]
+                } else if(ppri){
+                    jagpri <- strsplit(partable$prior[i], ""\\[prec"")[[1]][1]
                 } else {
                     jagpri <- partable$prior[i]
                 }"
ecmerkle,blavaan,9504401cc897d967cdd0d3e615aa6957eb22a38e,ecmerkle,merklee@missouri.edu,2020-09-21T03:06:05Z,ecmerkle,merklee@missouri.edu,2020-09-21T03:06:05Z,fix test,tests/testthat/tests.blavaan.R,False,True,True,False,4,4,8,"---FILE: tests/testthat/tests.blavaan.R---
@@ -28,11 +28,11 @@ test_that(""blavaan arguments"", {
   expect_error(bsem(model2, data=Data, fixed.x=TRUE))
 
   model2 <- ' y1 ~ b1*x1 + b2*x2
-              b1 == -b2 '
-  fit <- bsem(model2, data=Data, fixed.x=TRUE, target='jags', adapt=1,
-              burnin=1, sample=1)
+              b1 == -b2/2 '
+  fit <- bsem(model2, data=Data, target='jags', adapt=1,
+              burnin=1, sample=3)
   ## ensure that == constraints are being respected
-  expect_true(round(coef(fit)[['b1']] + coef(fit)[['b2']], 5) == 0L)
+  expect_true(round(2*coef(fit)[['b1']] + coef(fit)[['b2']], 5) == 0L)
 
   ## do.fit=FALSE
   fit <- bsem(model, data=Data, fixed.x=TRUE, adapt=2,"
ecmerkle,blavaan,e7c519f0b4e8339996544f92e6f7e9114c755682,ecmerkle,merklee@missouri.edu,2020-09-21T02:42:42Z,ecmerkle,merklee@missouri.edu,2020-09-21T02:42:42Z,fix complex equality constraints for jags and stanclassic,DESCRIPTION;R/set_priors.R;R/set_stanpars.R;tests/testthat/tests.blavaan.R,False,True,True,False,23,8,31,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-11.646
+Version: 0.3-11.649
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/set_priors.R---
@@ -29,7 +29,8 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x, target=""ja
                        partable$op == ""=="")
         defeq <- partable$op[i] %in% c(""=="", "":="") &
                  grepl(""\\+|-|/|\\*|\\(|\\)|\\^"", partable$rhs[i])
-        compeq <- which(partable$lhs == partable$plabel[i] &
+        compeq <- which((partable$lhs == partable$plabel[i] |
+                         partable$lhs == partable$label[i]) &
                         partable$op %in% c(""=="", "":="") &
                         grepl(""\\+|-|/|\\*|\\(|\\)|\\^"", partable$rhs))
         fixed <- partable$free[i] == 0 & partable$op[i] != "":=""
@@ -52,7 +53,8 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x, target=""ja
             ## rhs needs math expression
             defeq <- partable$op[i] %in% c(""=="", "":="") &
                      grepl(""\\+|-|/|\\*|\\(|\\)|\\^"", partable$rhs[i])
-            compeq <- which(partable$lhs == partable$plabel[i] &
+            compeq <- which((partable$lhs == partable$plabel[i] |
+                             partable$lhs == partable$label[i]) &
                             partable$op %in% c(""=="", "":="") &
                             grepl(""\\+|-|/|\\*|\\(|\\)|\\^"", partable$rhs))
             ## TODO block prior associated with lv.x.wish
@@ -86,7 +88,8 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x, target=""ja
                                   sep="""")
                 }
             } else if(length(eqpar) > 0){
-                eqpar <- which(partable$plabel == partable$lhs[eqpar])
+                eqpar <- which(partable$plabel == partable$lhs[eqpar] |
+                               partable$label == partable$lhs[eqpar])
                 ## in case it is an ""expanded"" variance
                 if(length(eqpar) > 1){
                     if(length(eqpar) > 2) stop(""blavaan ERROR: problem with parameter equality constraints"")
@@ -124,6 +127,7 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x, target=""ja
                     pvnum <- match(rhsvars, partable$label)
                 } else {
                     pvnum <- match(rhsvars, partable$plabel)
+                    if(is.na(pvnum[1])) pvnum <- match(rhsvars, partable$label)
                 }
 
                 rhstrans <- paste(partable$mat[pvnum], ""["",

---FILE: R/set_stanpars.R---
@@ -24,7 +24,8 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
                        partable$op == ""=="") |
                        (grepl(""rho"", partable$mat[i]) &
                         is.na(partable$rhoidx[i])))
-        compeq <- which(partable$lhs == partable$plabel[i] &
+        compeq <- which((partable$lhs == partable$plabel[i] |
+                         partable$lhs == partable$label[i]) &
                         partable$op %in% c(""=="", "":="") &
                         grepl(""\\+|-|/|\\*|\\(|\\)|\\^"", partable$rhs))
         fixed <- partable$free[i] == 0 & partable$op[i] != "":=""
@@ -48,7 +49,8 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
             ## rhs needs math expression
             defeq <- partable$op[i] %in% c(""=="", "":="") &
                      grepl(""\\+|-|/|\\*|\\(|\\)|\\^"", partable$rhs[i])
-            compeq <- which(partable$lhs == partable$plabel[i] &
+            compeq <- which((partable$lhs == partable$plabel[i] |
+                             partable$lhs == partable$label[i]) &
                             partable$op %in% c(""=="", "":="") &
                             grepl(""\\+|-|/|\\*|\\(|\\)|\\^"", partable$rhs))
 
@@ -75,7 +77,8 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
                                   sep="""")
                 }
             } else if(length(eqpar) > 0){
-                eqpar <- which(partable$plabel == partable$lhs[eqpar])
+                eqpar <- which(partable$plabel == partable$lhs[eqpar] |
+                               partable$label == partable$lhs[eqpar])
                 if(partable$freeparnums[eqpar] == 0){
                     eqtxt <- paste(partable$mat[eqpar], ""["",
                                    partable$row[eqpar], "","",
@@ -98,7 +101,7 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
                     TXT2 <- paste(TXT2, eqtxt, eolop, sep="""")
                 }
             } else if(defeq | length(compeq) > 0){
-                if(length(compeq) == 0) compeq <- i
+                 if(length(compeq) == 0) compeq <- i
                 ## constraints with one parameter label on lhs
                 ## FIXME? cannot handle, e.g., b1 + b2 == 2
                 ## see lav_partable_constraints.R
@@ -108,6 +111,7 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
                     pvnum <- match(rhsvars, partable$label)
                 } else {
                     pvnum <- match(rhsvars, partable$plabel)
+                    if(is.na(pvnum[1])) pvnum <- match(rhsvars, partable$label)
                 }
                     
                 rhstrans <- paste(partable$mat[pvnum], ""["", partable$row[pvnum],

---FILE: tests/testthat/tests.blavaan.R---
@@ -27,6 +27,13 @@ test_that(""blavaan arguments"", {
   ## equality constraint with multiple variables on lhs
   expect_error(bsem(model2, data=Data, fixed.x=TRUE))
 
+  model2 <- ' y1 ~ b1*x1 + b2*x2
+              b1 == -b2 '
+  fit <- bsem(model2, data=Data, fixed.x=TRUE, target='jags', adapt=1,
+              burnin=1, sample=1)
+  ## ensure that == constraints are being respected
+  expect_true(round(coef(fit)[['b1']] + coef(fit)[['b2']], 5) == 0L)
+
   ## do.fit=FALSE
   fit <- bsem(model, data=Data, fixed.x=TRUE, adapt=2,
               burnin=2, sample=2, do.fit=FALSE)"
ecmerkle,blavaan,b6c87ebcf0e11e53756778860ac8618acd7c70af,ecmerkle,merklee@missouri.edu,2020-08-26T03:56:45Z,ecmerkle,merklee@missouri.edu,2020-08-26T03:56:45Z,fix wiggle + test,R/blav_utils.R;tests/testthat/tests.blavaan.R,False,True,True,False,5,3,8,"---FILE: R/blav_utils.R---
@@ -730,14 +730,16 @@ wiglabels <- function(lavpartable, wiggle, wiggle.sd, target = ""stan""){
     tmplabs <- tmplabs[[1]]
   }
 
+  if(length(wiggle.sd) == 1) wiggle.sd <- rep(wiggle.sd, length(tmplabs))
+  
   for(i in 1:length(tmplabs)){
     if(inherits(tmplabs[[i]], ""list"")){
       tmpelem <- tmplabs[[i]]
     } else {
       tmpelem <- list(tmplabs[[i]])
     }
     multpars <- which(sapply(tmpelem, length) > 1)
-    if(length(multpars) > 1){
+    if(length(multpars) > 0){
       outlist <- c(outlist, tmpelem[multpars])
       outsd <- c(outsd, rep(wiggle.sd[i], length(tmpelem[multpars])))
     }
@@ -759,7 +761,7 @@ wiglabels <- function(lavpartable, wiggle, wiggle.sd, target = ""stan""){
       wigsc <- ifelse(grepl(""stan"", target), wiggle.sd, wiggle.sd^(-2))
       parname <- with(lavpartable, paste0(mat[tmprows[1]], ""["", row[tmprows[1]], "","",
                                           col[tmprows[1]], "","", group[tmprows[1]], ""]""))
-      wigpri <- paste0(dname, parname, "","", wigsc, "")"")
+      wigpri <- spri <- paste0(dname, parname, "","", wigsc, "")"")
 
       ## nuke == rows
       eqrows <- with(lavpartable, which(op == ""=="" & (rhs %in% plabel[tmprows])))

---FILE: tests/testthat/tests.blavaan.R---
@@ -62,7 +62,7 @@ test_that(""blavaan arguments"", {
 
   ## wiggle argument
   expect_error(bsem(model3, data=Data, wiggle='a', wiggle.sd=0))  ## sd=0 not allowed
-  #expect_error(bsem(model3, data=Data, wiggle='sponge'))          ## sd is string
+  expect_error(bsem(model3, data=Data, wiggle='sponge'))          ## sd is string
   expect_error(bsem(model3, data=Data, wiggle='b', wiggle.sd=c(1,2))) ## 2 sds, but 1 wiggle
   expect_error(bsem(model3, data=Data, wiggle=c('a','b'), wiggle.sd=c(.2,.3), target='jags'))
   expect_error(bsem(model3, data=Data, wiggle=c('a','b'), wiggle.sd=c(.2,.3), target='stanclassic')) ## wiggle.sd of length > 1 not allowed for these targets"
ecmerkle,blavaan,439fb238e25407054c73a32d734475a3aefd3fb8,ecmerkle,merklee@missouri.edu,2020-08-26T03:48:50Z,ecmerkle,merklee@missouri.edu,2020-08-26T03:48:50Z,omit test with try-error,R/blav_utils.R;tests/testthat/tests.blavaan.R,False,True,True,False,2,2,4,"---FILE: R/blav_utils.R---
@@ -719,7 +719,7 @@ wiglabels <- function(lavpartable, wiggle, wiggle.sd, target = ""stan""){
         })
       out
     } else {
-      stop(""blavaan ERROR: poorly-specified wiggle argument (cannot be used on variances)."")
+      stop(""blavaan ERROR: poorly-specified wiggle argument."")
     }
   })
 

---FILE: tests/testthat/tests.blavaan.R---
@@ -62,7 +62,7 @@ test_that(""blavaan arguments"", {
 
   ## wiggle argument
   expect_error(bsem(model3, data=Data, wiggle='a', wiggle.sd=0))  ## sd=0 not allowed
-  expect_error(bsem(model3, data=Data, wiggle='sponge'))          ## sd is string
+  #expect_error(bsem(model3, data=Data, wiggle='sponge'))          ## sd is string
   expect_error(bsem(model3, data=Data, wiggle='b', wiggle.sd=c(1,2))) ## 2 sds, but 1 wiggle
   expect_error(bsem(model3, data=Data, wiggle=c('a','b'), wiggle.sd=c(.2,.3), target='jags'))
   expect_error(bsem(model3, data=Data, wiggle=c('a','b'), wiggle.sd=c(.2,.3), target='stanclassic')) ## wiggle.sd of length > 1 not allowed for these targets"
ecmerkle,blavaan,f4bc33f888b9486631690ac328d1ad5ab0180b11,ecmerkle,merklee@missouri.edu,2020-08-26T02:51:57Z,ecmerkle,merklee@missouri.edu,2020-08-26T02:51:57Z,"fix wiggle + wiggle.sd when parameter names (loadings, intercepts, etc) are used",DESCRIPTION;R/blav_utils.R;R/lav_export_stanmarg.R,False,True,True,False,12,7,19,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-10
+Version: 0.3-11.643
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_utils.R---
@@ -725,6 +725,7 @@ wiglabels <- function(lavpartable, wiggle, wiggle.sd, target = ""stan""){
 
   ## fix list nesting, in case group.equal was used
   outlist <- NULL
+  outsd <- NULL
   if(length(tmplabs) == 1 & inherits(tmplabs[[1]], ""list"")){
     tmplabs <- tmplabs[[1]]
   }
@@ -735,21 +736,24 @@ wiglabels <- function(lavpartable, wiggle, wiggle.sd, target = ""stan""){
     } else {
       tmpelem <- list(tmplabs[[i]])
     }
-    if(length(tmpelem[[1]]) > 1){
-      outlist <- c(outlist, tmpelem)
+    multpars <- which(sapply(tmpelem, length) > 1)
+    if(length(multpars) > 1){
+      outlist <- c(outlist, tmpelem[multpars])
+      outsd <- c(outsd, rep(wiggle.sd[i], length(tmpelem[multpars])))
     }
   }
 
   ## prior for partable
   if(!(""prior"" %in% names(lavpartable))) lavpartable$prior <- rep("""", length(lavpartable$lhs))
+  stanpris <- lavpartable$prior
   for(i in 1:length(outlist)){
     tmprows <- which(lavpartable$plabel %in% outlist[[i]])
     eqrows <- NULL
     if(target == ""stan""){
       parname <- with(lavpartable, paste0(mat[tmprows[1]], ""["", group[tmprows[1]], "","",
                                           row[tmprows[1]], "","", col[tmprows[1]], ""]""))
-      wsd <- ifelse(length(wiggle.sd) > 1, wiggle.sd[i], wiggle.sd)
-      wigpri <- paste0(""normal("", parname, "","", wsd, "")"")
+      wigpri <- paste0(""normal("", parname, "","", outsd[i], "")"")
+      spri <- paste0(""normal(0,"", outsd[i], "")"")
     } else {
       dname <- ifelse(grepl(""stan"", target), ""normal("", ""dnorm("")
       wigsc <- ifelse(grepl(""stan"", target), wiggle.sd, wiggle.sd^(-2))
@@ -762,11 +766,12 @@ wiglabels <- function(lavpartable, wiggle, wiggle.sd, target = ""stan""){
     }
     lavpartable$prior[tmprows] <- c(lavpartable$prior[tmprows[1]],
                                     rep(wigpri, length(tmprows) - 1))
+    stanpris[tmprows] <- c(stanpris[tmprows[1]], rep(spri, length(tmprows) - 1))
     if(length(eqrows) > 0){
       lavpartable <- lavpartable[-eqrows,]
     }
   }
 
-  list(outlist = outlist, lavpartable = lavpartable)
+  list(outlist = outlist, lavpartable = lavpartable, stanpris = stanpris)
 }
   

---FILE: R/lav_export_stanmarg.R---
@@ -644,7 +644,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
   if (length(wig) > 0) {
     ## assign prior to wiggle params, (mean value is handled in stan)
     needpri <- (lavpartable$prior == """") & (lavpartable$plabel %in% wig)
-    lavpartable$prior[needpri] <- paste0(""normal(0,"", wiggle.sd[1], "")"")
+    lavpartable$prior[needpri] <- wigls$stanpris[wigls$stanpris != """"]
     dat$wigind <- 1L
   }
 "
ecmerkle,blavaan,20cdcf7d10f2986e6024c7a7c512659469db9141,ecmerkle,merklee@missouri.edu,2020-08-17T23:37:30Z,ecmerkle,merklee@missouri.edu,2020-08-17T23:37:30Z,fix test,tests/testthat/tests.blavaan.R,False,True,True,False,0,3,3,"---FILE: tests/testthat/tests.blavaan.R---
@@ -21,9 +21,6 @@ test_that(""blavaan arguments"", {
   ## cp/std.lv clash
   expect_error(bsem(model, data=Data, fixed.x=TRUE, std.lv=TRUE, cp=""fa""))
 
-  ## try to save lvs in a model without them
-  expect_error(bsem(model, data=Data, fixed.x=TRUE, save.lvs=TRUE))
-  
   model2 <- ' y1 ~ b1*x1 + b2*x2
               b1 + b2 == 0 '
 "
ecmerkle,blavaan,6caa0bd15f92d65505df093b5952c10f7e8ad080,ecmerkle,merklee@missouri.edu,2020-08-17T17:02:45Z,ecmerkle,merklee@missouri.edu,2020-08-17T17:02:45Z,improve error messages,R/blav_object_inspect.R,False,True,True,False,3,1,4,"---FILE: R/blav_object_inspect.R---
@@ -105,7 +105,6 @@ blavInspect <- function(blavobject, what, ...) {
             } else {
                 etas <- any(grepl(""^eta"", rownames(blavobject@external$stansumm)))
             }
-            if(!etas) stop(""blavaan ERROR: factor scores not saved; set save.lvs=TRUE"")
 
             ## how many lvs, excluding phantoms
             lvmn <- lavInspect(blavobject, ""mean.lv"")
@@ -114,6 +113,9 @@ blavInspect <- function(blavobject, what, ...) {
             }
             nlv <- length(lvmn)
 
+            if(nlv == 0) stop(""blavaan ERROR: no latent variables are in the model"")
+            if(!etas) stop(""blavaan ERROR: factor scores not saved; set save.lvs=TRUE"")
+            
             nsamp <- sum(lavInspect(blavobject, ""nobs""))
 
             draws <- make_mcmc(blavobject@external$mcmcout)"
ecmerkle,blavaan,f54024337fd28d9e3031dfcb2839893bcf4213de,ecmerkle,merklee@missouri.edu,2020-08-04T21:41:40Z,ecmerkle,merklee@missouri.edu,2020-08-04T21:41:40Z,"fix plot labels for target=""stan""",R/blav_object_methods.R;tests/testthat/tests.blavaanobject-methods.R,False,True,True,False,8,6,14,"---FILE: R/blav_object_methods.R---
@@ -333,25 +333,26 @@ plot.blavaan <- function(x, pars=NULL, plot.type=""trace"", showplot=TRUE, ...){
         pars <- x@ParTable$free
         pars <- pars[pars > 0 & !is.na(pars)]
     }
-    samps <- as.array(blavInspect(x, 'mcmc'), drop = FALSE)
 
     if(x@Options$target != ""stan""){
+        samps <- as.array(blavInspect(x, 'mcmc'), drop = FALSE)
         parnames <- x@ParTable$pxnames[match(pars, x@ParTable$free)]
         samps <- samps[, match(parnames, colnames(samps)), , drop = FALSE]
+        ## samps dims must be ""iteration, chain, parameter""
+        samps <- aperm(samps, c(1, 3, 2))
     } else {
+        samps <- as.array(x@external$mcmcout)
         parnums <- x@ParTable$stanpnum[match(pars, x@ParTable$free)]
-        samps <- samps[, parnums, , drop = FALSE]
+        samps <- samps[, , parnums, drop = FALSE]
     }
     if(blavInspect(x, 'ngroups') == 1L){
-        colnames(samps) <- with(x@ParTable, paste0(lhs,op,rhs)[match(pars, free)])
+        dimnames(samps)[[3]] <- with(x@ParTable, paste0(lhs,op,rhs)[match(pars, free)])
     } else {
-        colnames(samps) <- with(x@ParTable, paste0(lhs,op,rhs,"".g"",group)[match(pars, free)])
+        dimnames(samps)[[3]] <- with(x@ParTable, paste0(lhs,op,rhs,"".g"",group)[match(pars, free)])
     }
         
     plfun <- get(paste0(""mcmc_"", plot.type), asNamespace(""bayesplot""))
 
-    ## samps dims must be ""iteration, chain, parameter""
-    samps <- aperm(samps, c(1, 3, 2))
     pl <- do.call(plfun, c(list(x = samps), list(...)))
 
     if(showplot) plot(pl)

---FILE: tests/testthat/tests.blavaanobject-methods.R---
@@ -91,6 +91,7 @@ test_that(""blavaan object methods work"", {
 
     ## plots
     expect_silent(p <- plot(fitstan, showplot = FALSE))
+    expect_false(any(p$data$value[grep('~~', p$data$parameter)] < 0)) # check of parameter labels
     expect_silent(p <- plot(fitstan, 1:4, showplot = FALSE))
     expect_silent(p <- plot(fitstan, plot.type = ""hist"", showplot = FALSE))
     expect_silent(p <- plot(fitstan, 1:4, plot.type = ""dens"", showplot = FALSE))"
ecmerkle,blavaan,630efb8cf9cf476e75798d5af961883a3a82791c,ecmerkle,merklee@missouri.edu,2020-08-02T17:20:55Z,ecmerkle,merklee@missouri.edu,2020-08-02T17:20:55Z,"fix test, per #28",tests/testthat/tests.blavaanobject-methods.R,False,True,True,False,1,1,2,"---FILE: tests/testthat/tests.blavaanobject-methods.R---
@@ -87,7 +87,7 @@ test_that(""blavaan object methods work"", {
     fitlav <- cfa(HS.model, data=HolzingerSwineford1939,
                   meanstructure=TRUE)
     expect_true(cor(blavInspect(fitstanfs, 'lvmeans')[,1],
-                    lavPredict(fitlav, 'lv')[,1]) > .95)
+                    lavPredict(fitlav, type='lv')[,1]) > .95)
 
     ## plots
     expect_silent(p <- plot(fitstan, showplot = FALSE))"
ecmerkle,blavaan,93f414422b3661dab4349196740e15f33d851608,ecmerkle,merklee@missouri.edu,2020-06-21T02:49:40Z,ecmerkle,merklee@missouri.edu,2020-06-21T02:49:40Z,fix do.fit=F with missing values,R/blav_utils.R,False,True,True,False,1,0,1,"---FILE: R/blav_utils.R---
@@ -161,6 +161,7 @@ get_ll <- function(postsamp       = NULL, # one posterior sample
                                slotCache = lavcache), silent=TRUE)
         if(!inherits(fit.samp, ""try-error"")){
             fit.samp@Options$se <- ""standard"" # for nonnest2
+            fit.samp@test[[1]]$test <- ""standard"" # for do.fit=FALSE
 
             if(casewise){
                 ll.samp <- llcont(fit.samp)"
ecmerkle,blavaan,c59b9fd3b7324473c6cf6b517c7065f7db0c0939,ecmerkle,merklee@missouri.edu,2020-06-20T19:10:09Z,ecmerkle,merklee@missouri.edu,2020-06-20T19:10:09Z,improve wiggle error,R/blav_utils.R,False,True,True,False,1,1,2,"---FILE: R/blav_utils.R---
@@ -718,7 +718,7 @@ wiglabels <- function(lavpartable, wiggle, wiggle.sd, target = ""stan""){
         })
       out
     } else {
-      stop(""blavaan ERROR: poorly-specified wiggle argument."")
+      stop(""blavaan ERROR: poorly-specified wiggle argument (cannot be used on variances)."")
     }
   })
 "
ecmerkle,blavaan,a5845e7b3e4e26319b5ac772df60e8f33c38f105,ecmerkle,merklee@missouri.edu,2020-06-20T19:02:31Z,ecmerkle,merklee@missouri.edu,2020-06-20T19:02:31Z,"fix blavInspect(,""lvmeans"") for multiple groups",R/blav_object_inspect.R,False,True,True,False,2,3,5,"---FILE: R/blav_object_inspect.R---
@@ -110,10 +110,9 @@ blavInspect <- function(blavobject, what, ...) {
             ## how many lvs, excluding phantoms
             lvmn <- lavInspect(blavobject, ""mean.lv"")
             if(inherits(lvmn, ""list"")){
-                nlv <- length(lvmn[[1]])
-            } else {
-                nlv <- length(lvmn)
+                lvmn <- lvmn[[1]]
             }
+            nlv <- length(lvmn)
 
             nsamp <- sum(lavInspect(blavobject, ""nobs""))
 "
ecmerkle,blavaan,c178d03a83ad9902af25b22945393a20d874de9c,Mauricio Garnier-Villarreal,mgv@protonmail.com,2020-06-09T06:29:23Z,GitHub,noreply@github.com,2020-06-09T06:29:23Z,"remove $M from modeest::mlv

the $M no longer works, throws an error",R/ctr_bayes_fit.R,False,True,True,False,1,1,2,"---FILE: R/ctr_bayes_fit.R---
@@ -43,7 +43,7 @@ summary.blavFitIndices <- function(object,
     if (""mode"" %in% central.tendency || ""map"" %in% central.tendency) {
       ## can the modeest package be used?
       if (suppressMessages(requireNamespace(""modeest"", quietly = TRUE))) {
-        out <- c(out, MAP =  modeest::mlv(x, method = ""kernel"", na.rm = TRUE)$M)
+        out <- c(out, MAP =  modeest::mlv(x, method = ""kernel"", na.rm = TRUE))
       } else {
         ## if not, use the quick-and-dirty way
         dd <- density(x, na.rm = TRUE)"
ecmerkle,blavaan,f2d20cd4f2f86f63b80be5f824c70076cb3bb751,ecmerkle,merklee@missouri.edu,2020-05-19T15:32:44Z,ecmerkle,merklee@missouri.edu,2020-05-19T15:32:44Z,fix docs,man/bcfa.Rd;man/bgrowth.Rd;man/bsem.Rd,False,False,False,False,6,3,9,"---FILE: man/bcfa.Rd---
@@ -8,7 +8,8 @@ bcfa(..., cp = ""srs"",
      dp = NULL, n.chains = 3, burnin, sample,
      adapt, mcmcfile = FALSE, mcmcextra = list(), inits = ""prior"",
      convergence = ""manual"", target = ""stan"", save.lvs = FALSE,
-     jags.ic = FALSE, seed = NULL, bcontrol = list())
+     wiggle = NULL, wiggle.sd = 0.01, jags.ic = FALSE, seed = NULL,
+     bcontrol = list())
 }
 \arguments{
 \item{...}{Default lavaan arguments.  See \code{\link{lavaan}}.}

---FILE: man/bgrowth.Rd---
@@ -7,7 +7,8 @@ Fit a Growth Curve model.}
 bgrowth(..., cp = ""srs"", dp = NULL, n.chains = 3,
 burnin, sample, adapt, mcmcfile = FALSE, mcmcextra = list(), 
 inits = ""prior"", convergence = ""manual"", target = ""stan"",
-save.lvs = FALSE, jags.ic = FALSE, seed = NULL, bcontrol = list())
+save.lvs = FALSE, wiggle = NULL, wiggle.sd = 0.01, jags.ic = FALSE,
+seed = NULL, bcontrol = list())
 }
 \arguments{
 \item{...}{Default lavaan arguments.  See \code{\link{lavaan}}.}

---FILE: man/bsem.Rd---
@@ -8,7 +8,8 @@ bsem(..., cp = ""srs"",
      dp = NULL, n.chains = 3, burnin, sample,
      adapt, mcmcfile = FALSE, mcmcextra = list(), inits = ""prior"",
      convergence = ""manual"", target = ""stan"", save.lvs = FALSE,
-     jags.ic = FALSE, seed = NULL, bcontrol = list())
+     wiggle = NULL, wiggle.sd = 0.01, jags.ic = FALSE, seed = NULL,
+     bcontrol = list())
 }
 \arguments{
 \item{...}{Default lavaan arguments.  See \code{\link{lavaan}}.}"
ecmerkle,blavaan,9ee1f3b722feb5032127216bc6ae591a77034204,ecmerkle,merklee@missouri.edu,2020-05-19T03:08:56Z,ecmerkle,merklee@missouri.edu,2020-05-19T03:08:56Z,small wiggle fixes,R/blav_utils.R;tests/testthat/tests.blavaan.R,False,True,True,False,7,7,14,"---FILE: R/blav_utils.R---
@@ -754,14 +754,15 @@ wiglabels <- function(lavpartable, wiggle, wiggle.sd, target = ""stan""){
       parname <- with(lavpartable, paste0(mat[tmprows[1]], ""["", row[tmprows[1]], "","",
                                           col[tmprows[1]], "","", group[tmprows[1]], ""]""))
       wigpri <- paste0(dname, parname, "","", wigsc, "")"")
+
+      ## nuke == rows
+      eqrows <- with(lavpartable, which(op == ""=="" & (rhs %in% plabel[tmprows])))
+      if(length(eqrows) > 0){
+        lavpartable <- lavpartable[-eqrows,]
+      }
     }
     lavpartable$prior[tmprows] <- c(lavpartable$prior[tmprows[1]],
                                     rep(wigpri, length(tmprows) - 1))
-    ## nuke == rows
-    eqrows <- with(lavpartable, which(op == ""=="" & (rhs %in% plabel[tmprows])))
-    if(length(eqrows) > 0){
-      lavpartable <- lavpartable[-eqrows,]
-    }
   }
 
   list(outlist = outlist, lavpartable = lavpartable)

---FILE: tests/testthat/tests.blavaan.R---
@@ -61,7 +61,6 @@ test_that(""blavaan arguments"", {
   expect_error(bsem(model, data=Data, dp=dpriors(psi=""mydist(1,.5)"")))
 
   ## wiggle argument
-  expect_error(bsem(model, data=Data, wiggle='a', target='jags'))
-  expect_error(bsem(model, data=Data, wiggle='a', target='stanclassic'))
   expect_error(bsem(model, data=Data, wiggle='a', wiggle.sd=0))
+  expect_error(bsem(model, data=Data, wiggle='sponge'))
 })"
ecmerkle,blavaan,5b198033306dbea765263569c9a572d9de2ff5ee,ecmerkle,merklee@missouri.edu,2020-05-18T16:18:00Z,ecmerkle,merklee@missouri.edu,2020-05-18T16:18:00Z,"prelim wiggle with jags, fix stan with no wiggle",R/blav_utils.R;R/blavaan.R;R/lav_export_mcmc.R;R/lav_export_stanmarg.R;R/set_priors.R,False,True,True,False,30,8,38,"---FILE: R/blav_utils.R---
@@ -694,7 +694,7 @@ wiglabels <- function(lavpartable, wiggle, wiggle.sd, target = ""stan""){
   gqnames <- c(""loadings"", ""intercepts"", ""regressions"", ""means"", ""thresholds"")
   gqops <- c(""=~"", ""~1"", ""~"", ""~1"", ""|"")
   lv.names <- unique(unlist(lav_partable_attributes(lavpartable, pta=NULL)$vnames$lv))
-  lpt <- lavpartable[lavpartable$label != """",]
+  lpt <- lavpartable[lavpartable$label != """" & !is.na(lavpartable$label),]
 
   tmplabs <- lapply(wiggle, function(x){
     if(any(grepl(x, lpt$label))){
@@ -722,7 +722,7 @@ wiglabels <- function(lavpartable, wiggle, wiggle.sd, target = ""stan""){
       stop(""blavaan ERROR: poorly-specified wiggle argument."")
     }
   })
-  
+
   ## fix list nesting, in case group.equal was used
   outlist <- NULL
   if(length(tmplabs) == 1 & inherits(tmplabs[[1]], ""list"")){
@@ -751,11 +751,17 @@ wiglabels <- function(lavpartable, wiggle, wiggle.sd, target = ""stan""){
     } else {
       dname <- ifelse(grepl(""stan"", target), ""normal("", ""dnorm("")
       wigsc <- ifelse(grepl(""stan"", target), wiggle.sd, wiggle.sd^(-2))
-      parname <- lavpartable$pxnames[tmprows[1]]
+      parname <- with(lavpartable, paste0(mat[tmprows[1]], ""["", row[tmprows[1]], "","",
+                                          col[tmprows[1]], "","", group[tmprows[1]], ""]""))
       wigpri <- paste0(dname, parname, "","", wigsc, "")"")
     }
     lavpartable$prior[tmprows] <- c(lavpartable$prior[tmprows[1]],
                                     rep(wigpri, length(tmprows) - 1))
+    ## nuke == rows
+    eqrows <- with(lavpartable, which(op == ""=="" & (rhs %in% plabel[tmprows])))
+    if(length(eqrows) > 0){
+      lavpartable <- lavpartable[-eqrows,]
+    }
   }
 
   list(outlist = outlist, lavpartable = lavpartable)

---FILE: R/blavaan.R---
@@ -413,7 +413,8 @@ blavaan <- function(...,  # default lavaan arguments
                                          cp = cp, lv.x.wish = lavoptions$auto.cov.lv.x,
                                          dp = dp, n.chains = n.chains,
                                          mcmcextra = mcmcextra, inits = initsin,
-                                         blavmis = blavmis, target=""jags""),
+                                         blavmis = blavmis, wiggle = wiggle,
+                                         wiggle.sd = wiggle.sd, target = ""jags""),
                                 silent = TRUE)
             } else if(target == ""stanclassic""){
                 jagtrans <- try(lav2stan(model = LAV,
@@ -442,7 +443,9 @@ blavaan <- function(...,  # default lavaan arguments
                                               save_lvs = save.lvs))
 
                     ## add priors to lavpartable, including wiggle
-                    lavpartable$prior[as.numeric(rownames(l2s$lavpartable))] <- l2s$wigpris
+                    if(length(wiggle) > 0){
+                      lavpartable$prior[as.numeric(rownames(l2s$lavpartable))] <- l2s$wigpris
+                    }
 
                     jagtrans <- try(do.call(""stanmarg_data"", ldargs), silent = TRUE)
 

---FILE: R/lav_export_mcmc.R---
@@ -1,4 +1,4 @@
-lav2mcmc <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp = NULL, n.chains = 1, mcmcextra = """", inits = ""prior"", blavmis = ""da"", pta = NULL, target = ""stan"") {
+lav2mcmc <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp = NULL, n.chains = 1, mcmcextra = """", inits = ""prior"", blavmis = ""da"", pta = NULL, wiggle = NULL, wiggle.sd = NULL, target = ""stan"") {
   ## lots of code is taken from lav_export_bugs.R
 
   if(inherits(model, ""lavaan"")){
@@ -85,6 +85,11 @@ lav2mcmc <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
   phnames <- unique(partable$lhs[grep("".phant"", partable$lhs)])
   lv.names <- c(lv.names, phnames[!(phnames %in% lv.names)])
 
+  ## deal with wiggle
+  if(length(wiggle) > 0){
+    partable <- wiglabels(partable, wiggle, wiggle.sd, target=target)$lavpartable
+  }
+  
   ## tabs
   t1 <- paste(rep("" "", 2L), collapse="""")
   t2 <- paste(rep("" "", 4L), collapse="""")
@@ -695,7 +700,7 @@ lav2mcmc <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
     
     out <- c(out, list(data=jagsdata))
   }
-
+  
   if(target == ""stan""){
     nparms <- max(partable$freeparnums, na.rm = TRUE)
     parmblk <- paste0(""parameters{\n"", t1, ""vector["",

---FILE: R/lav_export_stanmarg.R---
@@ -231,6 +231,9 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits, wiggle=NULL, wiggle.sd=
     wigls <- wiglabels(lavpartable, wiggle, wiggle.sd)
     wig <- unlist(wigls$outlist)
     wigpris <- wigls$lavpartable$prior
+  } else {
+    wig <- NULL
+    wigpris <- NULL
   }
 
   freeparnums <- rep(0, length(lavpartable$free))

---FILE: R/set_priors.R---
@@ -160,7 +160,12 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x, target=""ja
 
                     partable$prior[i] <- dp[partype]
                 }
-                jagpri <- strsplit(partable$prior[i], ""\\["")[[1]][1]
+                if(grepl("")["", partable$prior[i], fixed=TRUE)){
+                    ## this avoids wiggle priors, which have param indexing
+                    jagpri <- paste0(strsplit(partable$prior[i], "")["", fixed=TRUE)[[1]][1], "")"")
+                } else {
+                    jagpri <- partable$prior[i]
+                }
                 vpri <- grepl(""\\[var\\]"", partable$prior[i])
                 spri <- grepl(""\\[sd\\]"", partable$prior[i])
                 if(!vpri & (grepl(""theta"", partable$mat[i]) | grepl(""psi"", partable$mat[i]))){"
ecmerkle,blavaan,04b0019a4caf4de33e2914a97f4db6037419d192,Mauricio Garnier-Villarreal,mgv@protonmail.com,2020-05-08T06:04:34Z,GitHub,noreply@github.com,2020-05-08T06:04:34Z,"add paste0('p_', pD) to basline model fitMeasures

add paste0('p_', pD) to basline model fitMeasures. This way the baseline model will use the pD selected by the user. Before it had the LOO pD as fixed, even if the user specified another one",R/ctr_bayes_fit.R,False,True,True,False,1,1,2,"---FILE: R/ctr_bayes_fit.R---
@@ -189,7 +189,7 @@ blavFitIndices <- function(object, thin = 1, pD = c(""loo"",""waic"",""dic""),
                               lavjags = baseline.model@external$mcmcout,
                               samplls = baseline.model@external$samplls)$ppdist[[""reps""]]
       }
-      pD_null <- fitMeasures(baseline.model, 'p_loo')
+      pD_null <- fitMeasures(baseline.model, paste0('p_', pD))
     }
   }
 "
ecmerkle,blavaan,73c9fd512ffbb35643b8464fbbab0b065f5965cc,ecmerkle,merklee@missouri.edu,2020-05-07T03:15:02Z,ecmerkle,merklee@missouri.edu,2020-05-07T03:15:02Z,improve error checking,R/blav_utils.R;R/blavaan.R;tests/testthat/tests.blavaan.R,False,True,True,False,9,4,13,"---FILE: R/blav_utils.R---
@@ -688,8 +688,8 @@ pkgload <- function(x){
   try(suppressMessages(attachNamespace(x)), silent = TRUE)
 }
 
-## get plabels that have ""wiggle"", for target=""stan""
-wiglabels <- function(lavpartable, wiggle){
+## get plabels that have ""wiggle""
+wiglabels <- function(lavpartable, wiggle, target = ""stan""){
   ## allowable group.equal names
   gqnames <- c(""loadings"", ""intercepts"", ""regressions"", ""means"", ""thresholds"")
   gqops <- c(""=~"", ""~1"", ""~"", ""~1"", ""|"")

---FILE: R/blavaan.R---
@@ -51,6 +51,7 @@ blavaan <- function(...,  # default lavaan arguments
 
     # wiggle only for target=""stan""
     if(length(wiggle) > 0 & target != ""stan"") stop(""blavaan ERROR: wiggle currently only works for target='stan'."")
+    if(wiggle.sd <= 0L) stop(""blavaan ERROR: wiggle.sd must be > 0."")
   
     # ensure rstan/runjags are here. if target is not installed but
     # the other is, then use the other instead.
@@ -247,7 +248,7 @@ blavaan <- function(...,  # default lavaan arguments
     }
 
     # ordinal functionality not available
-    if(lavInspect(LAV, 'categorical') {
+    if(lavInspect(LAV, 'categorical')) {
         stop(""blavaan ERROR: models with ordered variables are not yet available."")
     }
     

---FILE: tests/testthat/tests.blavaan.R---
@@ -59,5 +59,9 @@ test_that(""blavaan arguments"", {
   
   ## unknown prior
   expect_error(bsem(model, data=Data, dp=dpriors(psi=""mydist(1,.5)"")))
-  
+
+  ## wiggle argument
+  expect_error(bsem(model, data=Data, wiggle='a', target='jags'))
+  expect_error(bsem(model, data=Data, wiggle='a', target='stanclassic'))
+  expect_error(bsem(model, data=Data, wiggle='a', wiggle.sd=0))
 })"
ecmerkle,blavaan,6c1bb0ac500ee62138551dabf03a4fcb2e99148d,ecmerkle,merklee@missouri.edu,2020-05-06T21:32:42Z,ecmerkle,merklee@missouri.edu,2020-05-06T21:32:42Z,improve error checking,R/blavaan.R,False,True,True,False,8,3,11,"---FILE: R/blavaan.R---
@@ -46,12 +46,12 @@ blavaan <- function(...,  # default lavaan arguments
         }
     }
 
-    # ordinal functionality not available
-    if(""ordered"" %in% dotNames) stop(""blavaan ERROR: models with ordered variables are not yet available."")
-
     # multilevel functionality not available
     if(""cluster"" %in% dotNames) stop(""blavaan ERROR: two-level models are not yet available."")
 
+    # wiggle only for target=""stan""
+    if(length(wiggle) > 0 & target != ""stan"") stop(""blavaan ERROR: wiggle currently only works for target='stan'."")
+  
     # ensure rstan/runjags are here. if target is not installed but
     # the other is, then use the other instead.
     if(grepl(""stan"", target)){
@@ -246,6 +246,11 @@ blavaan <- function(...,  # default lavaan arguments
         stop(""blavaan ERROR: full data are required. consider using kd() from package semTools."")
     }
 
+    # ordinal functionality not available
+    if(lavInspect(LAV, 'categorical') {
+        stop(""blavaan ERROR: models with ordered variables are not yet available."")
+    }
+    
     # turn warnings back on by default
     LAV@Options$warn <- origwarn
 "
ecmerkle,blavaan,7fe51d9771d24fbf6c1aa29c331bab764559729a,ecmerkle,merklee@missouri.edu,2020-05-06T15:16:12Z,ecmerkle,merklee@missouri.edu,2020-05-06T15:16:12Z,fix partable for wiggle parameters,R/blavaan.R,False,True,True,False,8,3,11,"---FILE: R/blavaan.R---
@@ -426,15 +426,20 @@ blavaan <- function(...,  # default lavaan arguments
                                              debug = mcdebug),
                                 silent = TRUE)
             } else {
-                wigls <- unlist(wiglabels(parTable(LAV), wiggle))
+                wigls <- wiglabels(parTable(LAV), wiggle)
                 l2s <- try(lav2stanmarg(lavobject = LAV, dp = dp,
                                         n.chains = n.chains,
-                                        inits = initsin, wig = wigls),
+                                        inits = initsin, wig = unlist(wigls)),
                            silent = TRUE)
                 if(!inherits(l2s, ""try-error"")){
                     ldargs <- c(l2s$dat, list(lavpartable = l2s$lavpartable, dumlv = l2s$dumlv,
                                               save_lvs = save.lvs))
-                    lavpartable$prior <- l2s$lavpartable$prior
+
+                    ## add priors to lavpartable, including wiggle
+                    lavpartable$prior[as.numeric(rownames(l2s$lavpartable))] <- l2s$lavpartable$prior
+                    for(i in 1:length(wigls)){
+                        lavpartable$prior[lavpartable$plabel %in% wigls[[i]][-1]] <- ""wiggle[sd=0.1]""
+                    }
                     jagtrans <- try(do.call(""stanmarg_data"", ldargs), silent = TRUE)
 
                     if(inherits(jagtrans, ""try-error"")) stop(jagtrans)"
ecmerkle,blavaan,6f88ef99922fa6e91b178a0a296ae832eeb843df,ecmerkle,merklee@missouri.edu,2020-05-05T02:58:27Z,ecmerkle,merklee@missouri.edu,2020-05-05T02:58:27Z,"fixes for std.lv with target=""stan""",R/lav_export_stanmarg.R,False,True,True,False,14,10,24,"---FILE: R/lav_export_stanmarg.R---
@@ -88,12 +88,12 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, wig, ...) {
     freepars <- cumsum(wskel[,1] == 0)
     wskel[wskel[,1]==1,2] <- freepars[wskel[wskel[,1]==1,2]]
   }
-  
+
   lvmat <- mat %in% c('Gamma', 'B', 'Psi_r')
   lammat <- grepl('Lambda', mat)
   sign <- matrix(0, len, 2 + lvmat)
-  if (std.lv & (lvmat | lammat) & length(ddd$sign) > 0) {
-    if (lvmat) {
+  if (std.lv & (lvmat | lammat)) {
+    if (lvmat & length(ddd$sign) > 0) {
       lamfree <- ddd$free2
       lamsign <- ddd$sign
 
@@ -102,7 +102,7 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, wig, ...) {
         if (nrow(fpar) > 0) {
           for (j in 1:nrow(fpar)) {
             ## in case all loadings restricted to 0
-            if (all(lamfree[[i]][,fpar[j,2]] == 0L)) next
+            if (all(lamfree[[i]][,fpar[j,]] == 0L)) next
             
             ## find sign-constrained loadings of the two lvs
             lampar1 <- lamfree[[i]][,fpar[j,2]]
@@ -122,20 +122,24 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, wig, ...) {
             }
 
             rowloc <- free2[[i]][fpar[j,1], fpar[j,2]]
+            sign[rowloc, 1] <- 1L
             sign[rowloc, 2:3] <- c(l1, l2)
           }
         }
       }
-    } else {
+    } else if (lammat) {
       for (i in 1:length(free2)) {
         for (j in 1:NCOL(free2[[i]])) {
           col <- free2[[i]][,j]
           parnums <- col[col != 0L]
-          psign <- min(parnums)
-          ## if equality constraint, sign must involve the
-          ## ""free"" parameter
-          if (wskel[psign,1] == 1L) psign <- wskel[psign,2]
-          sign[parnums, 2] <- psign
+          if (length(parnums) > 0) {
+            psign <- min(parnums)
+            ## if equality constraint, sign must involve the
+            ## ""free"" parameter
+            if (wskel[psign,1] == 1L) psign <- wskel[psign,2]
+            sign[parnums, 1] <- 1L
+            sign[parnums, 2] <- psign
+          }
         }
       }
     }"
ecmerkle,blavaan,d2b8804aaba99ce28c9bcf413101a06db55993d7,ecmerkle,merklee@missouri.edu,2020-04-13T14:18:21Z,ecmerkle,merklee@missouri.edu,2020-04-13T14:18:21Z,fix typo in docs,man/bcfa.Rd;man/bgrowth.Rd;man/blavaan.Rd;man/bsem.Rd,False,False,False,False,4,4,8,"---FILE: man/bcfa.Rd---
@@ -62,7 +62,7 @@ bcfa(..., cp = ""srs"",
   \code{""stanclassic""}, which sample latent variables and provide some
   greater functionality (because syntax is written ""on the fly""). But
   they are slower and less efficient.}
-\item{save.lvs}{Should sample latent variables (factor scores) be saved? Logical; defaults to FALSE}
+\item{save.lvs}{Should sampled latent variables (factor scores) be saved? Logical; defaults to FALSE}
 \item{jags.ic}{Should DIC be computed the JAGS way, in addition to the BUGS way? Logical; defaults to FALSE}
 \item{seed}{A vector of length \code{n.chains} (for target
   \code{""jags""}) or an integer (for target \code{""stan""}) containing random

---FILE: man/bgrowth.Rd---
@@ -60,7 +60,7 @@ save.lvs = FALSE, jags.ic = FALSE, seed = NULL, bcontrol = list())
   \code{""stanclassic""}, which sample latent variables and provide some
   greater functionality (because syntax is written ""on the fly""). But
   they are slower and less efficient.}
-\item{save.lvs}{Should sample latent variables (factor scores) be saved? Logical; defaults to FALSE}
+\item{save.lvs}{Should sampled latent variables (factor scores) be saved? Logical; defaults to FALSE}
 \item{jags.ic}{Should DIC be computed the JAGS way, in addition to the BUGS way? Logical; defaults to FALSE}
 \item{seed}{A vector of length \code{n.chains} (for target
   \code{""jags""}) or an integer (for target \code{""stan""}) containing random

---FILE: man/blavaan.Rd---
@@ -62,7 +62,7 @@ blavaan(..., cp = ""srs"",
   \code{""stanclassic""}, which sample latent variables and provide some
   greater functionality (because syntax is written ""on the fly""). But
   they are slower and less efficient.}
-\item{save.lvs}{Should sample latent variables (factor scores) be saved? Logical; defaults to FALSE}
+\item{save.lvs}{Should sampled latent variables (factor scores) be saved? Logical; defaults to FALSE}
 \item{jags.ic}{Should DIC be computed the JAGS way, in addition to the BUGS way? Logical; defaults to FALSE}
 \item{seed}{A vector of length \code{n.chains} (for target
   \code{""jags""}) or an integer (for target \code{""stan""}) containing random

---FILE: man/bsem.Rd---
@@ -61,7 +61,7 @@ bsem(..., cp = ""srs"",
   \code{""stanclassic""}, which sample latent variables and provide some
   greater functionality (because syntax is written ""on the fly""). But
   they are slower and less efficient.}
-\item{save.lvs}{Should sample latent variables (factor scores) be saved? Logical; defaults to FALSE}
+\item{save.lvs}{Should sampled latent variables (factor scores) be saved? Logical; defaults to FALSE}
 \item{jags.ic}{Should DIC be computed the JAGS way, in addition to the BUGS way? Logical; defaults to FALSE}
 \item{seed}{A vector of length \code{n.chains} (for target
   \code{""jags""}) or an integer (for target \code{""stan""}) containing random"
ecmerkle,blavaan,adc485f4614ea4616e4db4227c06800748fc2b4f,ecmerkle,merklee@missouri.edu,2020-03-04T18:25:48Z,ecmerkle,merklee@missouri.edu,2020-03-04T18:25:48Z,fix another diag(1x1),R/stanmarg_data.R,False,True,True,False,1,1,2,"---FILE: R/stanmarg_data.R---
@@ -290,7 +290,7 @@ stanmarg_data <- function(YX = NULL, S = NULL, N, Ng, grpnum, # data
   dat$wg5 <- array(tmpres$g_len, length(tmpres$g_len))
   dat$w5skel <- w5skel
   ## for lv sampling
-  usethet <- array(which(diag(Theta_skeleton[1,,]) != 0))
+  usethet <- array(which(diag(as.matrix(Theta_skeleton[1,,])) != 0))
   dat$w5use <- length(usethet)
   dat$usethet <- usethet
   "
ecmerkle,blavaan,579506facbb0691c5549ab51725f7b024124ceaf,ecmerkle,merklee@missouri.edu,2020-03-04T18:24:50Z,ecmerkle,merklee@missouri.edu,2020-03-04T18:24:50Z,fix array with one entry,R/stanmarg_data.R,False,True,True,False,1,1,2,"---FILE: R/stanmarg_data.R---
@@ -340,7 +340,7 @@ stanmarg_data <- function(YX = NULL, S = NULL, N, Ng, grpnum, # data
   ## for lv sampling
   usepsi <- useorig <- array(which(diag(as.matrix(Psi_skeleton[1,,])) != 0))
   if (length(dumlv) > 0) {
-    usepsi <- usepsi[-match(dumlv, usepsi)]
+    usepsi <- array(usepsi[-match(dumlv, usepsi)])
   }
   dat$w9use <- length(usepsi)
   dat$usepsi <- usepsi"
ecmerkle,blavaan,960673e0333934832e50653f66b18e434cb99862,ecmerkle,merklee@missouri.edu,2020-03-04T17:54:43Z,ecmerkle,merklee@missouri.edu,2020-03-04T17:54:43Z,fix diag of 1x1 object,R/stanmarg_data.R,False,True,True,False,1,1,2,"---FILE: R/stanmarg_data.R---
@@ -338,7 +338,7 @@ stanmarg_data <- function(YX = NULL, S = NULL, N, Ng, grpnum, # data
   dat$wg9 <- array(tmpres$g_len, length(tmpres$g_len))
   dat$w9skel <- w9skel
   ## for lv sampling
-  usepsi <- useorig <- array(which(diag(Psi_skeleton[1,,]) != 0))
+  usepsi <- useorig <- array(which(diag(as.matrix(Psi_skeleton[1,,])) != 0))
   if (length(dumlv) > 0) {
     usepsi <- usepsi[-match(dumlv, usepsi)]
   }"
ecmerkle,blavaan,50c92c630b58f694a9896e66d0508ed8091376ff,ecmerkle,merklee@missouri.edu,2020-02-22T03:00:56Z,ecmerkle,merklee@missouri.edu,2020-02-22T03:00:56Z,fix do.fit=FALSE and save.lvs=TRUE,R/blavaan.R;tests/testthat/tests.blavaan.R,False,True,True,False,6,1,7,"---FILE: R/blavaan.R---
@@ -628,7 +628,7 @@ blavaan <- function(...,  # default lavaan arguments
             attr(x, ""fx"") <- get_ll(lavmodel = lavmodel, lavpartable = lavpartable,
                                     lavsamplestats = lavsamplestats, lavoptions = lavoptions,
                                     lavcache = lavcache, lavdata = lavdata)[1]
-            if(save.lvs) {
+            if(save.lvs & jag.do.fit) {
                 if(target == ""jags""){
                     fullpmeans <- summary(make_mcmc(res))[[1]][,""Mean""]
                 } else {
@@ -638,6 +638,8 @@ blavaan <- function(...,  # default lavaan arguments
                               lavsamplestats = lavsamplestats, lavoptions = lavoptions,
                               lavcache = lavcache, lavdata = lavdata,
                               lavobject = LAV, conditional = TRUE)[1]
+            } else {
+                cfx <- NULL
             }
         } else {
             attr(x, ""fx"") <- as.numeric(NA)

---FILE: tests/testthat/tests.blavaan.R---
@@ -32,6 +32,9 @@ test_that(""blavaan arguments"", {
               burnin=2, sample=2, do.fit=FALSE)
   expect_s4_class(fit, ""blavaan"")
 
+  fit <- bsem(model, data=Data, save.lvs=TRUE, do.fit=FALSE)
+  expect_s4_class(fit, ""blavaan"")
+  
   ## named variable that clashes
   names(Data)[1] <- ""lambda""
   model2 <- ' lambda ~ b1*x1 + b2*x2 '"
ecmerkle,blavaan,2a061e2427cee5a7f8c59948923f7fe3138f2da0,merkle,merklee@missouri.edu,2020-02-04T15:04:34Z,merkle,merklee@missouri.edu,2020-02-04T15:04:34Z,"target='stan', further fix to prior specifications",DESCRIPTION;R/stanmarg_data.R,False,True,True,False,3,3,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-9.564
+Version: 0.3-9.573
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/stanmarg_data.R---
@@ -65,8 +65,8 @@ group_sparse_skeleton <- function(skeleton) {
 format_priors <- function(lavpartable, mat) {
   ## parameter matrices are filled in by row, so need to make
   ## sure we get parameters in the right order!
-  lavpartable <- lavpartable[order(lavpartable$col),]
-  
+  lavpartable <- lavpartable[order(lavpartable$group, lavpartable$col, lavpartable$row),]
+
   if (grepl(""var"", mat)) {
     mat <- gsub(""var"", """", mat)
     prisel <- lavpartable$row == lavpartable$col"
ecmerkle,blavaan,552b4f7ca62d8a62c21be88f4b3abd6913132571,ecmerkle,merklee@missouri.edu,2020-01-29T21:02:35Z,ecmerkle,merklee@missouri.edu,2020-01-29T21:02:35Z,stancond: fix up noncentered code,R/lav_export_stancond.R,False,True,True,False,4,4,8,"---FILE: R/lav_export_stancond.R---
@@ -456,8 +456,8 @@ lav2stancond <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcext
     ## some real lvs and some with variances fixed to 0
     TPS <- paste0(TPS, t2, etaname, ""[i,etaind] = "")
     if(noncent){
-      TPS <- paste0(TPS, ""transpose(ibinv[g[i],lvind,lvind] * to_vector(alpha[lvind,1,g[i]]) + "")
-      TPS <- paste0(""psild[g[i],lvind,lvind] * "")
+      TPS <- paste0(TPS, ""transpose(ibinv[g[i],lvind,] * to_vector(alpha[,1,g[i]]) + "")
+      TPS <- paste0(TPS, ""psild[g[i],lvind,lvind] * "")
     }
     TPS <- paste0(TPS, ""etafree[i]"", ifelse(noncent[1], "")"", ""'""), "";\n"");
 
@@ -466,12 +466,12 @@ lav2stancond <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcext
       TPS <- paste0(TPS, t2, ""mueta[i] = ibinv[g[i],lvind,] * to_vector(alpha[,1,g[i]]);\n"")
     }
     
-    TPS <- paste0(TPS, t2, etaname, ""[i,eta0ind] = transpose(ibinv[g[i],eta0ind,eta0ind] * (to_vector(alpha[eta0ind,1,g[i]]) + to_matrix(beta[eta0ind,regind,g[i]]) * "", etaname, ""[i,regind]'));\n"")
+    TPS <- paste0(TPS, t2, etaname, ""[i,eta0ind] = transpose(ibinv[g[i],eta0ind,eta0ind] * to_vector(alpha[eta0ind,1,g[i]]) + ibinv[g[i],eta0ind,regind] * "", etaname, ""[i,regind]');\n"")
   } else if(nlv > 0){
     ## all real lvs
     TPS <- paste0(TPS, t2, etaname, ""[i,etaind] = "")
     if(noncent){
-      TPS <- paste0(TPS, ""transpose(ibinv[g[i],lvind,lvind] * to_vector(alpha[lvind,1,g[i]]) + "")
+      TPS <- paste0(TPS, ""transpose(ibinv[g[i],lvind,] * to_vector(alpha[,1,g[i]]) + "")
       TPS <- paste0(TPS, ""psild[g[i],lvind,lvind] * "")
     }
     TPS <- paste0(TPS, ""etafree[i]"", ifelse(noncent[1], "")"", ""'""), "";\n"");"
ecmerkle,blavaan,3924e936cd06d801da86371df5efdb09ca806032,ecmerkle,merklee@missouri.edu,2020-01-17T03:39:04Z,ecmerkle,merklee@missouri.edu,2020-01-17T03:39:04Z,stancond: possible fix for ovs in noncentered param,R/lav_export_stancond.R,False,True,True,False,12,2,14,"---FILE: R/lav_export_stancond.R---
@@ -464,7 +464,12 @@ lav2stancond <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcext
     ## some real lvs and some with variances fixed to 0
     TPS <- paste0(TPS, t2, etaname, ""[i,etaind] = "")
     if(noncent){
-      TPS <- paste0(TPS, ""transpose(to_vector(alpha[etaind,1,g[i]]) + psild[g[i],etaind,etaind] * "")
+      TPS <- paste0(TPS, ""transpose(to_vector(alpha[etaind,1,g[i]]) + "")
+      if(n.psi.ov > 0){
+        TPS <- paste0(TPS, ""to_matrix(beta[1:"", nlv, "","", (nlv + 1), "":"", (nlv + n.psi.ov),
+                      "",g[i]]) * "", etaname, ""[i,"", (nlv + 1), "":"", (nlv + n.psi.ov), ""]' + "")
+      }
+      TPS <- paste0(""psild[g[i],etaind,etaind] * "")
     }
     TPS <- paste0(TPS, ""etafree[i]"", ifelse(noncent[1], "")"", ""'""), "";\n"");
     if(noncent){
@@ -480,7 +485,12 @@ lav2stancond <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcext
     ## all real lvs
     TPS <- paste0(TPS, t2, etaname, ""[i,1:"", nlv, ""] = "")
     if(noncent){
-      TPS <- paste0(TPS, ""transpose(to_vector(alpha[1:"", nlv, "",1,g[i]]) + psild[g[i],1:"", nlv, "",1:"", nlv, ""] * "")
+      TPS <- paste0(TPS, ""transpose(to_vector(alpha[1:"", nlv, "",1,g[i]]) + "")
+      if(n.psi.ov > 0){
+        TPS <- paste0(TPS, ""to_matrix(beta[1:"", nlv, "","", (nlv + 1), "":"", (nlv + n.psi.ov),
+                      "",g[i]]) * "", etaname, ""[i,"", (nlv + 1), "":"", (nlv + n.psi.ov), ""]' + "")
+      }
+      TPS <- paste0(TPS, ""psild[g[i],1:"", nlv, "",1:"", nlv, ""] * "")
     }
     TPS <- paste0(TPS, ""etafree[i]"", ifelse(noncent[1], "")"", ""'""), "";\n"");
     TPS <- paste0(TPS, t2, etaname, ""[i,1:"", nlv, ""] = transpose(ibinv[g[i],"", 1, "":"", nlv,"
ecmerkle,blavaan,988f20737887dd5fa493e5121e06aae1fe80b24f,ecmerkle,merklee@missouri.edu,2020-01-08T16:07:44Z,ecmerkle,merklee@missouri.edu,2020-01-08T16:07:44Z,fix plots when n.chains=1,R/blav_object_methods.R,False,True,True,False,3,3,6,"---FILE: R/blav_object_methods.R---
@@ -333,14 +333,14 @@ plot.blavaan <- function(x, pars=NULL, plot.type=""trace"", showplot=TRUE, ...){
         pars <- x@ParTable$free
         pars <- pars[pars > 0 & !is.na(pars)]
     }
-    samps <- as.array(blavInspect(x, 'mcmc'))
+    samps <- as.array(blavInspect(x, 'mcmc'), drop = FALSE)
 
     if(x@Options$target != ""stan""){
         parnames <- x@ParTable$pxnames[match(pars, x@ParTable$free)]
-        samps <- samps[, match(parnames, colnames(samps)), ]
+        samps <- samps[, match(parnames, colnames(samps)), , drop = FALSE]
     } else {
         parnums <- x@ParTable$stanpnum[match(pars, x@ParTable$free)]
-        samps <- samps[, parnums, ]
+        samps <- samps[, parnums, , drop = FALSE]
     }
     if(blavInspect(x, 'ngroups') == 1L){
         colnames(samps) <- with(x@ParTable, paste0(lhs,op,rhs)[match(pars, free)])"
ecmerkle,blavaan,0b2644d875b20a36fb7064afff61b8350dee8fc1,merkle,merklee@missouri.edu,2020-01-07T14:18:21Z,merkle,merklee@missouri.edu,2020-01-07T14:18:21Z,fix std.lv issue reported in #22,DESCRIPTION;R/blavaan.R,False,True,True,False,7,7,14,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-9.558
+Version: 0.3-9.562
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blavaan.R---
@@ -325,12 +325,12 @@ blavaan <- function(...,  # default lavaan arguments
 
             ## NB truncation doesn't work well in stan. instead
             ##    use generated quantities after the fact.
-            trunop <- ifelse(target == ""jags"", "" T(0,)"", """")
-            for(i in 1:length(fload)){
-                if(LAV@ParTable$prior[fload[i]] != """"){
-                    LAV@ParTable$prior[fload[i]] <- paste(LAV@ParTable$prior[fload[i]], trunop, sep="""")
-                } else {
-                    LAV@ParTable$prior[fload[i]] <- paste(dp[[""lambda""]], trunop, sep="""")
+            trunop <- "" T(0,)""
+            if(target == ""jags""){
+                for(i in 1:length(fload)){
+                    if(LAV@ParTable$prior[fload[i]] != """"){
+                        LAV@ParTable$prior[fload[i]] <- paste(LAV@ParTable$prior[fload[i]], trunop, sep="""")
+                    }
                 }
             }
         }"
ecmerkle,blavaan,ef01c991fb40c1ff5edc505ec85a897acd19bd3d,merkle,merklee@missouri.edu,2020-01-03T15:33:26Z,merkle,merklee@missouri.edu,2020-01-03T15:33:26Z,fix test,DESCRIPTION;tests/testthat/tests.blavaan.R,False,True,True,False,2,1,3,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-9.541
+Version: 0.3-9.558
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: tests/testthat/tests.blavaan.R---
@@ -39,6 +39,7 @@ test_that(""blavaan arguments"", {
 
   ## one prior on variance, one on sd (problem for target=""stan"" only)
   ## and check that defined parameters translate
+  names(Data)[1] <- ""y1""
   model3 <- ' y1 ~ a*x1
               x2 ~ b*x1
               y1 ~~ prior(""gamma(1,.5)[sd]"")*y1"
ecmerkle,blavaan,6948ac463870cd9ef34734b531f4fe1fdb18d91f,ecmerkle,merklee@missouri.edu,2020-01-03T15:22:17Z,ecmerkle,merklee@missouri.edu,2020-01-03T15:22:17Z,fix jags issue with defined parameters and do.fit=FALSE,R/lav_export_mcmc.R;R/set_inits.R;tests/testthat/tests.blavaan.R,False,True,True,False,7,3,10,"---FILE: R/lav_export_mcmc.R---
@@ -776,8 +776,11 @@ coeffun <- function(lavpartable, pxpartable, rjob, fun = ""mean"") {
   ## defined variables
   defmatch <- which(pxpartable$op == "":="")
   if(length(defmatch) > 0){
-    lavpartable$est[lavpartable$op == "":=""] <- pxpartable$est[defmatch]
-    lavpartable$psrf[lavpartable$op == "":=""] <- pxpartable$psrf[defmatch]
+    ## not necessarily if do.fit=FALSE
+    if(""est"" %in% names(pxpartable)){
+      lavpartable$est[lavpartable$op == "":=""] <- pxpartable$est[defmatch]
+      lavpartable$psrf[lavpartable$op == "":=""] <- pxpartable$psrf[defmatch]
+    }
     lavpartable$pxnames[lavpartable$op == "":=""] <- pxpartable$pxnames[defmatch]
     lavpartable$jagpnum[lavpartable$op == "":=""] <- pxpartable$jagpnum[defmatch]
   }

---FILE: R/set_inits.R---
@@ -65,7 +65,7 @@ set_inits <- function(partable, ov.cp, lv.cp, n.chains, inits){
       ## FIXME do something smarter upon failure
       ivs <- try(do.call(pricom[1], list(n.chains, as.numeric(pricom[2]),
                                      as.numeric(pricom[3]))), silent = TRUE)
-      if(inherits(ivs, ""try-error"")) ivs <- rep(NA, n.chains)
+      if(inherits(ivs, ""try-error"")) ivs <- rep(partable$start[i], n.chains)
     } else {
       ivs <- rep(partable$start[i], n.chains)
     }

---FILE: tests/testthat/tests.blavaan.R---
@@ -46,6 +46,7 @@ test_that(""blavaan arguments"", {
               pprod := a/b '
   expect_error(bsem(model3, data=Data, target=""stan""))
 
+  ## priors are wrong form but will not throw error until estimation
   fit <- bsem(model3, data=Data, target=""jags"", do.fit=FALSE)
   expect_s4_class(fit, ""blavaan"")
 "
ecmerkle,blavaan,7a6c8b77e4224baf10e965907973f2f5608d7a73,ecmerkle,merklee@missouri.edu,2020-01-03T15:17:38Z,ecmerkle,merklee@missouri.edu,2020-01-03T15:17:38Z,fix coeffun_stan when do.fit=FALSE,R/lav_export_stanclassic.R,False,True,True,False,4,1,5,"---FILE: R/lav_export_stanclassic.R---
@@ -1190,10 +1190,13 @@ coeffun_stan <- function(lavpartable, pxpartable, rsob, fun = ""mean"") {
   defmatch <- which(pxpartable$op == "":="")
   if(length(defmatch) > 0){
     lavpartable$est[lavpartable$op == "":=""] <- pxpartable$est[defmatch]
-    lavpartable$psrf[lavpartable$op == "":=""] <- pxpartable$psrf[defmatch]
     lavpartable$pxnames[lavpartable$op == "":=""] <- pxpartable$pxnames[defmatch]
     lavpartable$stanpnum[lavpartable$op == "":=""] <- pxpartable$stanpnum[defmatch]
     lavpartable$stansumnum[lavpartable$op == "":=""] <- pxpartable$stansumnum[defmatch]
+    ## will not exist if do.fit=FALSE
+    if(""psrf"" %in% names(pxpartable)){
+      lavpartable$psrf[lavpartable$op == "":=""] <- pxpartable$psrf[defmatch]
+    }
   }
   
   list(x = lavpartable$est[lavpartable$free > 0],"
ecmerkle,blavaan,6f434553c83b2ba3de8fd993cef4c45ee936d776,ecmerkle,merklee@missouri.edu,2020-01-02T17:17:45Z,ecmerkle,merklee@missouri.edu,2020-01-02T17:17:45Z,fix defined parameters in jags,R/set_priors.R,False,True,True,False,13,3,16,"---FILE: R/set_priors.R---
@@ -27,11 +27,13 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x, target=""ja
 
         eqpar <- which(partable$rhs == partable$plabel[i] &
                        partable$op == ""=="")
+        defeq <- partable$op[i] %in% c(""=="", "":="") &
+                 grepl(""\\+|-|/|\\*|\\(|\\)|\\^"", partable$rhs[i])
         compeq <- which(partable$lhs == partable$plabel[i] &
                         partable$op %in% c(""=="", "":="") &
                         grepl(""\\+|-|/|\\*|\\(|\\)|\\^"", partable$rhs))
         fixed <- partable$free[i] == 0 & partable$op[i] != "":=""
-        if(length(eqpar) > 0 | length(compeq) > 0 | fixed |
+        if(length(eqpar) > 0 | defeq | length(compeq) > 0 | fixed |
            miscignore){
             next
         } else {
@@ -48,6 +50,8 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x, target=""ja
 
             ## only complex equality constraints and defined parameters;
             ## rhs needs math expression
+            defeq <- partable$op[i] %in% c(""=="", "":="") &
+                     grepl(""\\+|-|/|\\*|\\(|\\)|\\^"", partable$rhs[i])
             compeq <- which(partable$lhs == partable$plabel[i] &
                             partable$op %in% c(""=="", "":="") &
                             grepl(""\\+|-|/|\\*|\\(|\\)|\\^"", partable$rhs))
@@ -109,13 +113,18 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x, target=""ja
                 } else {
                     TXT2 <- paste(TXT2, eqtxt, sep="""")
                 }
-            } else if(length(compeq) > 0){
+            } else if(defeq | length(compeq) > 0){
+                if(length(compeq) == 0) compeq <- i
                 ## constraints with one parameter label on lhs
                 ## FIXME? cannot handle, e.g., b1 + b2 == 2
                 ## see lav_partable_constraints.R
                 rhsvars <- all.vars(parse(file="""",
                                           text=partable$rhs[compeq]))
-                pvnum <- match(rhsvars, partable$plabel)
+                if(compeq == i){
+                    pvnum <- match(rhsvars, partable$label)
+                } else {
+                    pvnum <- match(rhsvars, partable$plabel)
+                }
 
                 rhstrans <- paste(partable$mat[pvnum], ""["",
                                   partable$row[pvnum], "","",
@@ -148,6 +157,7 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x, target=""ja
                         partype <- grep(partable$mat[i], names(dp))
                     }
                     if(length(partype) > 1) partype <- partype[1] # due to psi and ibpsi
+
                     partable$prior[i] <- dp[partype]
                 }
                 jagpri <- strsplit(partable$prior[i], ""\\["")[[1]][1]"
ecmerkle,blavaan,41dfcc9721c6aca5dbf251fa4dd19275abab4b10,ecmerkle,merklee@missouri.edu,2019-12-26T20:41:02Z,ecmerkle,merklee@missouri.edu,2019-12-26T20:41:02Z,fix defined parameters in stanclassic,R/set_stanpars.R,False,True,True,False,11,3,14,"---FILE: R/set_stanpars.R---
@@ -46,9 +46,12 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
 
             ## only complex equality constraints and defined parameters;
             ## rhs needs math expression
+            defeq <- partable$op[i] %in% c(""=="", "":="") &
+                     grepl(""\\+|-|/|\\*|\\(|\\)|\\^"", partable$rhs[i])
             compeq <- which(partable$lhs == partable$plabel[i] &
                             partable$op %in% c(""=="", "":="") &
                             grepl(""\\+|-|/|\\*|\\(|\\)|\\^"", partable$rhs))
+
             ## TODO check for inequality constraints here?
           
             ## start parameter assignment
@@ -94,14 +97,19 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
                 } else {
                     TXT2 <- paste(TXT2, eqtxt, eolop, sep="""")
                 }
-            } else if(length(compeq) > 0){
+            } else if(defeq | length(compeq) > 0){
+                if(length(compeq) == 0) compeq <- i
                 ## constraints with one parameter label on lhs
                 ## FIXME? cannot handle, e.g., b1 + b2 == 2
                 ## see lav_partable_constraints.R
                 rhsvars <- all.vars(parse(file="""",
                                           text=partable$rhs[compeq]))
-                pvnum <- match(rhsvars, partable$plabel)
-
+                if(compeq == i){
+                    pvnum <- match(rhsvars, partable$label)
+                } else {
+                    pvnum <- match(rhsvars, partable$plabel)
+                }
+                    
                 rhstrans <- paste(partable$mat[pvnum], ""["", partable$row[pvnum],
                                   "","", partable$col[pvnum], "","", partable$group[pvnum],
                                   ""]"", sep="""")"
ecmerkle,blavaan,bdb11642c5b63a2890959747b17b0d84cad08ce9,ecmerkle,merklee@missouri.edu,2019-12-24T16:59:54Z,ecmerkle,merklee@missouri.edu,2019-12-24T16:59:54Z,fix use of dpriors() for stanclassic,R/dpriors.R,False,True,True,False,5,1,6,"---FILE: R/dpriors.R---
@@ -28,7 +28,11 @@ dpriors <- function(..., target=""stan""){
     } else if(length(unlist(userjags)) == 0){
       if(target == ""jags"") stop(""blavaan ERROR: target='jags', but no jags distributions were found"")
       ## assume they wanted stan
-      dp <- do.call(""stanpriors"", userspec)
+      if(target == ""stanclassic""){
+        dp <- do.call(""stanclassicpriors"", userspec)
+      } else {
+        dp <- do.call(""stanpriors"", userspec)
+      }
     } else {
       stop(""blavaan ERROR: Distributions sent to dpriors() do not match target."")
     }"
ecmerkle,blavaan,5e586500fa1fbb0ad7a9ceb3e9b7786e1293d9a8,ecmerkle,merklee@missouri.edu,2019-12-19T20:17:18Z,ecmerkle,merklee@missouri.edu,2019-12-19T20:17:18Z,"stan noncentered fix for fixed.x with regressions, also move travis to bionic",.travis.yml;R/lav_export_stan.R,False,True,True,False,43,22,65,"---FILE: .travis.yml---
@@ -10,7 +10,7 @@ warnings_are_errors: true
 matrix:
   include:
     - os: linux
-      dist: trusty
+      dist: bionic
       r: release
       addons:
         apt:
@@ -23,7 +23,7 @@ matrix:
         - MATRIX_EVAL=""CC=gcc-7 && CXX=g++-7""
         - _R_CHECK_FORCE_SUGGESTS_=false
     - os: linux
-      dist: trusty
+      dist: bionic
       r: devel
       addons:
         apt:

---FILE: R/lav_export_stan.R---
@@ -388,12 +388,16 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   if(any(partable$mat == ""theta"")){
     if(n.psi.ov > 0){
       for(i in 1:length(yind)){
-        for(j in i:length(yind)){
-          TPS <- paste0(TPS, t2, ""thetld[j,"", i, "","", j, ""] = "",
-                        ""theta["", yind[i], "","", yind[j], "",j];\n"")
+        thidx <- partable[partable$mat == ""theta"" & partable$row == yind[i],,drop=FALSE]
+        if(length(yind) > 0){
+          for(j in 1:nrow(thidx)){
+            ycol <- which(yind == thidx$col[j])
+            TPS <- paste0(TPS, t2, ""thetld[j,"", i, "","", ycol, ""] = "",
+                          ""theta["", yind[i], "","", thidx$col[j], "",j];\n"")
+          }
         }
       }
-      TPS <- paste0(TPS, t2, ""thetld[j] = fill_lower(thetld[j]);\n"")
+     TPS <- paste0(TPS, t2, ""thetld[j] = fill_lower(thetld[j]);\n"")
     } else {
       TPS <- paste0(TPS, t2, ""thetld[j] = fill_lower(to_matrix("",
                     ""theta[,,j]));\n"")
@@ -403,7 +407,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   }
 
   TPS <- paste0(TPS, t2, ""ibinv[j] = inverse(diag_matrix(rep_vector(1,"",
-                nlv + n.psi.ov, "")) - to_matrix(beta[,,j]));\n"")
+                nlv + n.psi.ov, "")) - to_matrix("", betaname, ""[,,j]));\n"")
 
   if(any(grepl(""psi"", partable$mat))){
     if(nlv - nlvno0 > 0){
@@ -414,12 +418,14 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
         }
       }
       TPS <- paste0(TPS, t2, ""psild[j] = fill_lower(psild[j]);\n"")
+      TPS <- paste0(TPS, t2, ""psild[j,eta0ind,eta0ind] = cholesky_decompose("",
+                    ""psild[j,eta0ind,eta0ind]);\n"")
     } else {
       TPS <- paste0(TPS, t2, ""psild[j] = fill_lower(to_matrix("",
                     psiname, ""[,,j]));\n"")
+      TPS <- paste0(TPS, t2, ""psild[j] = cholesky_decompose(psild[j]);\n"")
     }
-    TPS <- paste0(TPS, t2, ""psild[j] = cholesky_decompose("",
-                  ""psild[j]);\n"")
+
   }
 
   if(dumov & !model@Options$fixed.x &
@@ -463,9 +469,16 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     TPS <- paste0(TPS, t2, etaname, ""[i,lvind] = transpose(ibinv[g[i]] * (to_vector(alpha[lvind,1,g[i]]) + psild[g[i]] * "", etaname, ""[i]));\n"")
   } else if(nlv > 0){
     ## all real lvs
-    TPS <- paste0(TPS, t2, etaname, ""[i,1:"", nlv, ""] = transpose(to_vector(alpha[1:"", nlv, "",1,g[i]]) + psild[g[i], 1:"", nlv, "",1:"", nlv, ""] * etafree[i]);\n"")
-    TPS <- paste0(TPS, t2, etaname, ""[i,1:"", nlv, ""] = transpose(ibinv[g[i],1:"", nlv,
-                  "",] * "", etaname, ""[i]');\n"")
+    TPS <- paste0(TPS, t2, etaname, ""[i,1:"", nlv, ""] = transpose(to_vector(alpha[1:"", nlv, "",1,g[i]]) + psild[g[i],1:"", nlv, "",1:"", nlv, ""] * etafree[i]);\n"")
+    if(n.psi.ov == 0){
+      TPS <- paste0(TPS, t2, etaname, ""[i,1:"", nlv, ""] = transpose(ibinv[g[i],1:"", nlv,
+                    "",] * "", etaname, ""[i]');\n"")
+    } else {
+      TPS <- paste0(TPS, t2, etaname, ""[i,1:"", nlv, ""] = transpose(ibinv[g[i],1:"", nlv,
+                    "",1:"", nlv, ""] * "", etaname, ""[i,1:"", nlv, ""]' + to_matrix(beta[1:"", nlv,
+                    "","", (nlv + 1), "":"", (nlv + n.psi.ov), "",g[i]]) * "", etaname, ""[i,"", (nlv + 1),
+                    "":"", (nlv + n.psi.ov), ""]');\n"")
+    }
   }
 
 
@@ -868,16 +881,16 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
 
     pmats <- vector(""list"", length(matrows))
     for(i in 1:length(pmats)){
-        if(names(matrows)[i] == ""lambda""){
-            tmpmat <- parmattable[[1]]$lambda
-            pmats[[i]] <- array(tmpmat,
-                                c(nrow(tmpmat), ncol(tmpmat), ngroups))
-        } else {
-            pmats[[i]] <- array(0, c(matrows[i], matcols[i], ngroups))
-        }
+      if(names(matrows)[i] == ""lambda""){
+        tmpmat <- parmattable[[1]]$lambda
+        pmats[[i]] <- array(tmpmat,
+                            c(nrow(tmpmat), ncol(tmpmat), ngroups))
+      } else {
+        pmats[[i]] <- array(0, c(matrows[i], matcols[i], ngroups))
+      }
     }
     names(pmats) <- names(matrows)
-
+    
     ## monitored parameters
     monitors <- with(partable[partable$mat != """",], unique(mat))
     monitors[monitors==""lambdaUNC""] <- ""lambda""
@@ -921,8 +934,8 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
       }
 
       if(grepl(""psi"", tmpname)){
-        tpdecs <- paste0(tpdecs, t1, ""matrix["", nlvno0, "","",
-                         nlvno0, ""] psild["", tmpdim[3],
+        tpdecs <- paste0(tpdecs, t1, ""matrix["", (nlv + n.psi.ov), "","",
+                         (nlv + n.psi.ov), ""] psild["", tmpdim[3],
                          ""];\n"")
       }
       
@@ -942,6 +955,14 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
       tpeqs <- paste0(tpeqs, t1, tmpname, "" = "",
                       names(pmats)[i], "";\n"")
     }
+
+    if(""theta"" %in% names(matrows) & ny > 0){
+      pmats <- c(pmats, list(thetldframe = array(0, c(ngroups, ny, ny))))
+      datdecs <- paste0(datdecs, t1, ""matrix["", ny, "","", ny, ""] thetldframe["", ngroups,
+                        ""];\n"")
+      tpeqs <- paste0(tpeqs, t1, ""thetld = thetldframe;\n"")
+    }
+    
     ## beta always declared
     tpdecs <- paste0(tpdecs, t1, ""matrix["", nlvno0, "","",
                      nlvno0, ""] ibinv["", tmpdim[3],"
ecmerkle,blavaan,db08c8220102732d039fb23700c77aee622cd45c,ecmerkle,merklee@missouri.edu,2019-12-16T16:46:54Z,ecmerkle,merklee@missouri.edu,2019-12-16T16:46:54Z,fix set_inits_stan,R/set_inits.R,False,True,True,False,11,3,14,"---FILE: R/set_inits.R---
@@ -151,11 +151,12 @@ set_inits_stan <- function(partable, nfree, n.chains, inits,
   lazyLoad(rloc)
   rosetta <- rosetta
 
-  pricom <- dist2r(freepartable$prior, target = ""stan"")
+  prilist <- dist2r(freepartable$prior, target = ""stan"")
   for(i in 1:nrow(freepartable)){
     if(inits == ""prior""){
       ## Try to set sensible starting values, using some of the
       ## prior information
+      pricom <- prilist[[i]]
       if(grepl(""dnorm"", pricom[1])){
         pricom[3] <- ""1""
         ## keep loadings/regressions on one side
@@ -177,8 +178,15 @@ set_inits_stan <- function(partable, nfree, n.chains, inits,
       ## Generate initial values
       ## FIXME do something smarter upon failure
       ivs <- try(do.call(pricom[1], list(n.chains, as.numeric(pricom[2]),
-                                     as.numeric(pricom[3]))), silent = TRUE)
-      if(inherits(ivs, ""try-error"")) ivs <- rep(1, n.chains)
+                                         as.numeric(pricom[3]))), silent = TRUE)
+
+      if(inherits(ivs, ""try-error"")){
+        ivs <- rep(1, n.chains)
+      } else if(pricom[1] == ""rgamma"" & !grepl(""[sd]"", freepartable$prior[i], fixed = TRUE) &
+                !grepl(""[var]"", freepartable$prior[i], fixed = TRUE)){
+        ## free parameter is a precision, not a variance/sd:
+        ivs <- 1/ivs
+      }
     } else {
       ivs <- rep(freepartable$start[i], n.chains)
     }"
ecmerkle,blavaan,2ac08dbdbb2abf24679c096d93997f974ecc6a5c,ecmerkle,merklee@missouri.edu,2019-12-16T16:28:56Z,ecmerkle,merklee@missouri.edu,2019-12-16T16:28:56Z,fix inits check,R/blavaan.R,False,True,True,False,3,1,4,"---FILE: R/blavaan.R---
@@ -103,7 +103,9 @@ blavaan <- function(...,  # default lavaan arguments
       dotdotdot <- dotdotdot[-cplocs]; dotNames <- dotNames[-cplocs]
     }
     ## cannot use lavaan inits with fa priors; FIXME?
-    if(cp == ""fa"" & inits %in% c(""simple"", ""default"")) inits <- ""jags""
+    if(cp == ""fa"" & is.character(inits)){
+      if(inits[1] %in% c(""simple"", ""default"")) inits <- ""jags""
+    }
     if(cp == ""fa"" & grepl(""stan"", target)){
       cat(""blavaan NOTE: fa priors are not available with stan. srs priors will be used. \n"")
     }"
ecmerkle,blavaan,d75cd30be7a59e6357542c4c4e379f7711c45877,ecmerkle,merklee@missouri.edu,2019-12-12T03:45:06Z,ecmerkle,merklee@missouri.edu,2019-12-12T03:45:06Z,stanclassic: noncentered working for ovs in psi (regression),R/lav_export_stan.R;R/set_inits.R,False,True,True,False,26,15,41,"---FILE: R/lav_export_stan.R---
@@ -267,7 +267,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   }
 
   if(nlvno0 > 0){
-    parblk <- paste0(parblk, t1, ""vector["", nlvno0, ""] etavec[N]"",
+    parblk <- paste0(parblk, t1, ""vector["", nlvno0, ""] etafree[N]"",
                      eolop, ""\n"")
   }
   parblk <- paste0(parblk, ""}\n\n"")                     
@@ -363,14 +363,18 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
                     ""target += multi_normal_cholesky_lpdf(y[i] | "",
                     ""to_vector(mu[i,1:"", (nov - n.psi.ov),
                     ""]), thetld[g[i]]);\n"")
-
-      if(nlvno0 > 0){
-        TXT <- paste0(TXT, t2,
-                      ""target += std_normal_lpdf(etavec[i]);\n"")
-      }
-    }
+      
+    } 
   }
 
+  if(nlvno0 > 0){
+    TXT <- paste0(TXT, t2,
+                  ""target += std_normal_lpdf(etafree[i]);\n"")
+  }
+  if(nlvno0 < (nlv + n.psi.ov)){
+    TXT <- paste0(TXT, t2,
+                  ""target += multi_normal_cholesky_lpdf(etavec[i,eta0ind] | rep_vector(0, size(eta0ind)), psild[g[i], eta0ind, eta0ind]);\n"")
+  }
 
   TXT <- paste0(TXT, t1, ""}\n\n"")
   
@@ -399,7 +403,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   }
 
   TPS <- paste0(TPS, t2, ""ibinv[j] = inverse(diag_matrix(rep_vector(1,"",
-                nlvno0, "")) - to_matrix(beta[,,j]));\n"")
+                nlv + n.psi.ov, "")) - to_matrix(beta[,,j]));\n"")
 
   if(any(grepl(""psi"", partable$mat))){
     if(nlv - nlvno0 > 0){
@@ -417,7 +421,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     TPS <- paste0(TPS, t2, ""psild[j] = cholesky_decompose("",
                   ""psild[j]);\n"")
   }
-  
+
   if(dumov & !model@Options$fixed.x &
      !all(parmattable$lambda == diag(nrow(parmattable$lambda)))){
     TPS <- paste0(TPS, t2, ""alpha[dummylv,1,j] = to_array_1d(inverse((to_matrix(lambda"", ifelse(std.lv, ""UNC"", """"), ""[,,j]) * inverse(diag_matrix(rep_vector(1.0, "", (nlv + n.psi.ov), "")) - to_matrix(beta"", ifelse(std.lv, ""UNC"", """"), ""[,,j])))[dummyov,dummylv]) * to_vector(to_array_1d(alpha[dummylv,1,j])"")
@@ -448,11 +452,13 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
                ""for(i in 1:N) {\n"", sep="""")
   
   if(nlvno0 < nlv){
+    ## some real lvs and some dummy lvs
     #TPS <- paste0(TPS, t2, ""eta[i,etaind] = etavec[i];\n"")
     TPS <- paste0(TPS, t2, etaname, ""[i,eta0ind] = mueta[i,eta0ind]';\n"")
     TPS <- paste0(TPS, t2, etaname, ""[i,lvind] = transpose(ibinv[g[i]] * (to_vector(alpha[lvind,1,g[i]]) + psild[g[i]] * etavec[i]));\n"")
   } else if(nlv > 0){
-    TPS <- paste0(TPS, t2, etaname, ""[i,1:"", nlv, ""] = transpose(ibinv[g[i]] * (to_vector(alpha[,1,g[i]]) + psild[g[i]] * etavec[i]));\n"")
+    ## all real lvs
+    TPS <- paste0(TPS, t2, etaname, ""[i,1:"", nlv, ""] = transpose(ibinv[g[i]] * (to_vector(alpha[,1,g[i]]) + psild[g[i]] * etafree[i]));\n"")
   }
 
   if(n.psi.ov > 0){
@@ -520,6 +526,10 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     TPS <- paste(TPS, eolop, ""\n"", sep="""")
   }
 
+  if(n.psi.ov > 0){
+    TPS <- paste(TPS, t1, ""etavec[i,eta0ind] = eta[i,eta0ind]' - (to_vector(alpha[,1,g[i]]) + to_matrix(beta[,,g[i]]) * eta[i,eta0ind]');\n"")
+  }
+  
   ## priors/constraints
   if(std.lv){
     lamidx <- which(names(nfree) == ""lambda"")
@@ -564,8 +574,8 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   datablk <- paste0(""data{\n"", t1, ""int N;\n"", t1, ""int g[N];\n"",
                     t1, ""int lvind["", length(lvindall), ""];\n"",
                     t1, ""int etaind["", length(etaind), ""];\n"")
-  if(length(lv0.idx) > 0){
-    datablk <- paste0(datablk, t1, ""int eta0ind["", length(lv0.idx),
+  if((length(lv0.idx) + length(lv.dummy.idx)) > 0){
+    datablk <- paste0(datablk, t1, ""int eta0ind["", length(lv0.idx) + length(lv.dummy.idx),
                       ""];\n"")
   }
 
@@ -771,8 +781,8 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     standata <- list(g=g, N=ntot, regind=array(regind),
                      exoind=array(exoind), lvind=array(lvindall),
                      etaind=array(etaind))
-    if(length(lv0.idx) > 0){
-      standata <- c(standata, list(eta0ind=array(lv0.idx)))
+    if((length(lv0.idx) + length(lv.dummy.idx)) > 0){
+      standata <- c(standata, list(eta0ind=array(c(lv0.idx, lv.dummy.idx))))
     }
     standata <- c(standata, list(dummyov=array(ov.dummy.idx),
                                  dummylv=array(lv.dummy.idx),
@@ -942,6 +952,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
 
     if(nlv + n.psi.ov > 0){
       tpdecs <- paste0(tpdecs, t1, ""matrix[N,"", (nlv + n.psi.ov), ""] "", etaname, "";\n"")
+      tpdecs <- paste0(tpdecs, t1, ""vector["", (nlv + n.psi.ov), ""] etavec[N];\n"")
       if(nlvno0 < nlv){
         tpdecs <- paste0(tpdecs, t1, ""vector["", (nlv + n.psi.ov),
                          ""] mueta[N];\n"")

---FILE: R/set_inits.R---
@@ -120,7 +120,7 @@ set_inits_stan <- function(partable, nfree, n.chains, inits,
   }
   names(initmats) <- paste0(names(pveclen), ""free"")
   if(nlvno0 > 0){
-    initmats <- c(initmats, list(etavec = array(1, dim = c(ntot, nlvno0))))
+    initmats <- c(initmats, list(etafree = array(1, dim = c(ntot, nlvno0))))
   }
 
   for(i in 1:n.chains){"
ecmerkle,blavaan,562115dbde1845f159e5f940f34919b53c0032aa,ecmerkle,merklee@missouri.edu,2019-12-02T18:41:24Z,ecmerkle,merklee@missouri.edu,2019-12-02T18:41:24Z,"stanclassic, fix multi-group indexing",R/lav_export_stan.R,False,True,True,False,1,1,2,"---FILE: R/lav_export_stan.R---
@@ -928,7 +928,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     }
     ## beta always declared
     tpdecs <- paste0(tpdecs, t1, ""matrix["", nlvno0, "","",
-                     nlvno0, ""] ibinv["", tmpdim[1],
+                     nlvno0, ""] ibinv["", tmpdim[3],
                      ""];\n"")
     tpdecs <- paste0(tpdecs, t1, ""real mu[N,"", nov, ""];\n"")
     GQ <- paste0(GQ, gqeqs, ""\n"")"
ecmerkle,blavaan,5f7523254267f76ca3cfd657630510150e7e6351,merkle,merklee@missouri.edu,2019-11-14T20:07:53Z,merkle,merklee@missouri.edu,2019-11-14T20:07:53Z,fix test objects,DESCRIPTION;inst/testdata/sysdata.rda;tests/blavaan_examples.R,False,True,True,False,6,6,12,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-8.531
+Version: 0.3-8.532
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: tests/blavaan_examples.R---
@@ -13,22 +13,22 @@ library(""blavaan"")
 ## don't care that models are not converged, keeping file size small
 model <- ' y1 ~ prior(""dnorm(0,1)"")*x1 '
 fitjags <- bsem(model, data=Data, fixed.x=TRUE, burnin=20,
-                sample=20, target=""jags"", group=""g"")
+                sample=20, target=""jags"", group=""g"", seed=1:3)
 
 model <- ' y1 ~ prior(""normal(0,1)"")*x1 '
 fitstan <- bsem(model, data=Data, fixed.x=TRUE, burnin=20,
-                sample=20, target=""stan"", group=""g"")
+                sample=20, target=""stan"", group=""g"", seed=1)
 
 fitstanc <- bsem(model, data=Data, fixed.x=TRUE, burnin=20,
-                 sample=20, target=""stanclassic"", group=""g"")
+                 sample=20, target=""stanclassic"", group=""g"", seed=1)
 
 ## for checking factor score functionality
 HS.model <- ' visual  =~ x1 + x2 + x3
               textual =~ x4 + x5 + x6 '
 
 fitstanfs <- bcfa(HS.model, data=HolzingerSwineford1939,
-                  burnin=50, sample=10, target=""stan"",
-                  save.lvs=TRUE, n.chains=2)
+                  burnin=30, sample=10, target=""stan"",
+                  save.lvs=TRUE, n.chains=2, seed=1)
 
 ## this really blows up file size if kept:
 attr(fitstan@external$mcmcout, 'stanmodel') <- NULL"
ecmerkle,blavaan,6a4f6658fb89f91a5f44cb47f75a881a22f31771,merkle,merklee@missouri.edu,2019-11-14T19:43:31Z,merkle,merklee@missouri.edu,2019-11-14T19:43:31Z,"fix prior assignment for target='stan', per #19",DESCRIPTION;R/stanmarg_data.R;inst/testdata/sysdata.rda,False,True,True,False,7,2,9,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-8.529
+Version: 0.3-8.531
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/stanmarg_data.R---
@@ -63,6 +63,10 @@ group_sparse_skeleton <- function(skeleton) {
 # @param mat The matrix for which we are obtaining priors
 # @return A list containing the prior parameters
 format_priors <- function(lavpartable, mat) {
+  ## parameter matrices are filled in by row, so need to make
+  ## sure we get parameters in the right order!
+  lavpartable <- lavpartable[order(lavpartable$col),]
+  
   if (grepl(""var"", mat)) {
     mat <- gsub(""var"", """", mat)
     prisel <- lavpartable$row == lavpartable$col
@@ -81,6 +85,7 @@ format_priors <- function(lavpartable, mat) {
   } else {
     prisel <- prisel & (lavpartable$mat == mat)
   }
+  
   prisel <- prisel & (lavpartable$free > 0)
   thepris <- lavpartable$prior[prisel]
 
@@ -379,7 +384,7 @@ stanmarg_data <- function(YX = NULL, S = NULL, N, Ng, grpnum, # data
 
   ## priors; first make sure they match what is in the stan file
   check_priors(lavpartable)
-  
+
   pris <- format_priors(lavpartable, ""lambda"")
   dat$lambda_y_mn <- pris[['p1']]; dat$lambda_y_sd <- pris[['p2']]
   dat$len_lam_y <- length(dat$lambda_y_mn)"
ecmerkle,blavaan,f0155da43d75eb28cddabe9e1e428766242207a8,merkle,merklee@missouri.edu,2019-11-07T20:34:17Z,merkle,merklee@missouri.edu,2019-11-07T20:34:17Z,fix major postpred() speed issue,DESCRIPTION;R/postpred.R,False,True,True,False,8,2,10,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-8.528
+Version: 0.3-8.529
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/postpred.R---
@@ -289,6 +289,8 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
 ## generate data from posterior predictive dist
 postdata <- function(object = NULL, nrep = 50L, conditional = FALSE, ...){
 
+  ## parallel=TRUE can be sent here, but it slows everything down if
+  ## used within postpred() because it leads to nested parallelization.
   ddd <- list(...)
 
   if(conditional){
@@ -437,7 +439,11 @@ postdata <- function(object = NULL, nrep = 50L, conditional = FALSE, ...){
     }
     list(postdat = postdat, lavmod = lavmod)})
 
-  res <- do.call(""future_lapply"", loop.args)
+  lapcomm <- ""lapply""
+  if(""parallel"" %in% names(ddd)){
+    if(ddd$parallel) lapcomm <- ""future_lapply""
+  }
+  res <- do.call(lapcomm, loop.args)
 
   lavmod <- sapply(res, function(x) x$lavmod)
   res <- lapply(res, function(x) x$postdat)"
ecmerkle,blavaan,49c2cd3c243090d49dfceeba29a7631fa5e38378,ecmerkle,merklee@missouri.edu,2019-10-26T18:57:11Z,ecmerkle,merklee@missouri.edu,2019-10-26T18:57:11Z,fix use of modeest::mlv in ppmc,R/ctr_ppmc.R,False,True,True,False,1,1,2,"---FILE: R/ctr_ppmc.R---
@@ -57,7 +57,7 @@ summary.blavPPMC <- function(object, discFUN, dist = c(""obs"",""sim""),
     if (""mode"" %in% central.tendency || ""map"" %in% central.tendency) {
       ## can the modeest package be used?
       if (suppressMessages(requireNamespace(""modeest"", quietly = TRUE))) {
-        out <- c(out, MAP =  modeest::mlv(x, method = ""kernel"", na.rm = TRUE)$M)
+        out <- c(out, MAP =  modeest::mlv(x, method = ""kernel"", na.rm = TRUE)[1])
       } else {
         ## if not, use the quick-and-dirty way
         dd <- density(x, na.rm = TRUE)"
ecmerkle,blavaan,66555b8c88e1c557d237fc638869dead8f30c6c0,merkle,merklee@missouri.edu,2019-10-02T13:41:32Z,merkle,merklee@missouri.edu,2019-10-02T13:41:32Z,"fix blavInspect(,'lvmeans') and add related test",DESCRIPTION;R/blavaan.R;tests/testthat/tests.blavaanobject-methods.R,False,True,True,False,9,3,12,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-7
+Version: 0.3-8.513
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blavaan.R---
@@ -435,8 +435,7 @@ blavaan <- function(...,  # default lavaan arguments
                                            ""Theta_x_cov"", ""Theta_x_var"",
                                            ""Psi_cov"", ""Psi_var"",
                                            ""Ph_cov"", ""Ph_var"",
-                                           ""Nu_free"", ""Alpha_free"",
-                                           ""eta""))
+                                           ""Nu_free"", ""Alpha_free""))
                     if(""init"" %in% names(l2s)){
                       jagtrans <- c(jagtrans, list(inits = l2s$init))
                     }

---FILE: tests/testthat/tests.blavaanobject-methods.R---
@@ -82,6 +82,13 @@ test_that(""blavaan object methods work"", {
     expect_equal(dim(blavInspect(fitstanfs, 'lvs')[[2]]),
                  c(10, 602))
 
+    HS.model <- ' visual  =~ x1 + x2 + x3
+                  textual =~ x4 + x5 + x6 '
+    fitlav <- cfa(HS.model, data=HolzingerSwineford1939,
+                  meanstructure=TRUE)
+    expect_true(cor(blavInspect(fitstanfs, 'lvmeans')[,1],
+                    lavPredict(fitlav, 'lv')[,1]) > .95)
+
     ## plots
     expect_silent(p <- plot(fitstan, showplot = FALSE))
     expect_silent(p <- plot(fitstan, 1:4, showplot = FALSE))"
ecmerkle,blavaan,a073b6daad3f48b4541573d9cea0c2eec0a01288,ecmerkle,merklee@missouri.edu,2019-09-23T16:11:41Z,ecmerkle,merklee@missouri.edu,2019-09-23T16:11:41Z,fix comment in stan file,src/stan_files/stanmarg.stan,False,False,False,False,1,1,2,"---FILE: src/stan_files/stanmarg.stan---
@@ -130,7 +130,7 @@ data {
   int<lower=0> n; // number of latent exogenous variables
   int<lower=1> Ng; // number of groups
   cov_matrix[p + q] S[Ng];     // sample covariance matrix among all manifest variables NB!! multiply by (N-1) to use wishart lpdf!!
-  int<lower=0, upper=1> has_data; // are the raw (centered) data on y and x available?
+  int<lower=0, upper=1> has_data; // are the raw data on y and x available?
   int<lower=0, upper=1> missing; // are there missing values?
   int<lower=0, upper=1> save_lvs; // should we save lvs?
   int<lower=1> Np; // number of group-by-missing patterns combos"
ecmerkle,blavaan,79c62b1840108929869d0243a106dec5e9964536,merkle,merklee@missouri.edu,2019-09-17T13:45:57Z,merkle,merklee@missouri.edu,2019-09-17T13:45:57Z,fix missing priors for correlation parameters,DESCRIPTION;R/stanmarg_data.R,False,True,True,False,7,4,11,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-7.507
+Version: 0.3-7.508
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/stanmarg_data.R---
@@ -66,8 +66,11 @@ format_priors <- function(lavpartable, mat) {
   if (grepl(""var"", mat)) {
     mat <- gsub(""var"", """", mat)
     prisel <- lavpartable$row == lavpartable$col
-  } else if (grepl(""off"", mat)) {
-    mat <- gsub(""off"", """", mat)
+  } else if (grepl(""psioff"", mat)) {
+    mat <- ""lvrho""
+    prisel <- lavpartable$row != lavpartable$col
+  } else if (grepl(""thetaoff"", mat)) {
+    mat <- ""rho""
     prisel <- lavpartable$row != lavpartable$col
   } else {
     prisel <- rep(TRUE, length(lavpartable$row))
@@ -418,7 +421,7 @@ stanmarg_data <- function(YX = NULL, S = NULL, N, Ng, grpnum, # data
   dat$psi_sd_rate <- pris[['p2']]
   dat$len_psi_sd <- length(dat$psi_sd_rate)
   dat$psi_pow <- pris[['powpar']]
-  
+
   pris <- format_priors(lavpartable, ""psioff"")
   dat$psi_r_alpha <- pris[['p1']]; dat$psi_r_beta <- pris[['p2']]
   dat$len_psi_r <- length(dat$psi_r_alpha)"
ecmerkle,blavaan,70cebd58ec4583fee6da4db55e661aee8082a22a,merkle,merklee@missouri.edu,2019-09-11T15:10:47Z,merkle,merklee@missouri.edu,2019-09-11T15:10:47Z,fix sd/var/prec check and add tests,DESCRIPTION;R/stanmarg_data.R;tests/testthat/tests.blavaan.R,False,True,True,False,13,4,17,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-7.506
+Version: 0.3-7.507
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/stanmarg_data.R---
@@ -97,7 +97,7 @@ format_priors <- function(lavpartable, mat) {
     ## check that var/sd/prec is same for all
     powargs <- sapply(prisplit, tail, 1)
     if (any(grepl(""\\["", powargs))) {
-      if (length(unique(powargs)) > 0) stop(paste0(""blavaan ERROR: In matrix "", mat, "", all priors must be placed on either vars, sds, or precisions.""))
+      if (length(unique(powargs)) > 1) stop(paste0(""blavaan ERROR: In matrix "", mat, "", all priors must be placed on either vars, sds, or precisions.""))
     }
     powpar <- 1
     powarg <- powargs[1]
@@ -125,7 +125,6 @@ format_priors <- function(lavpartable, mat) {
 # @return nothing
 check_priors <- function(lavpartable) {
   right_pris <- sapply(dpriors(target = ""stan""), function(x) strsplit(x, ""[, ()]+"")[[1]][1])
-
   pt_pris <- sapply(lavpartable$prior[lavpartable$prior != """"], function(x) strsplit(x, ""[, ()]+"")[[1]][1])
   names(pt_pris) <- lavpartable$mat[lavpartable$prior != """"]
 

---FILE: tests/testthat/tests.blavaan.R---
@@ -36,5 +36,15 @@ test_that(""blavaan arguments"", {
   names(Data)[1] <- ""lambda""
   model2 <- ' lambda ~ b1*x1 + b2*x2 '
   expect_error(bsem(model2, data=Data))
-              
+
+  ## one prior on variance, one on sd (for target=""stan"" only)
+  model3 <- ' y1 ~ x1
+              x2 ~ x1
+              y1 ~~ prior(""gamma(1,.5)[sd]"")*y1
+              x2 ~~ prior(""gamma(1,.5)[var]"")*x2 '
+  expect_error(bsem(model3, data=Data, target=""stan""))
+
+  ## unknown prior
+  expect_error(bsem(model, data=Data, dp=dpriors(psi=""mydist(1,.5)"")))
+  
 })"
ecmerkle,blavaan,9c83a6c03309dccbc2e1e4e77039f56a334ad96d,ecmerkle,merklee@missouri.edu,2019-09-03T18:59:28Z,ecmerkle,merklee@missouri.edu,2019-09-03T18:59:28Z,fix stanclassic plots and tests,R/blav_object_methods.R;tests/testthat/tests.blavaanobject-methods.R,False,True,True,False,11,11,22,"---FILE: R/blav_object_methods.R---
@@ -334,8 +334,8 @@ plot.blavaan <- function(x, pars=NULL, plot.type=""trace"", showplot=TRUE, ...){
         pars <- pars[pars > 0 & !is.na(pars)]
     }
     samps <- as.array(blavInspect(x, 'mcmc'))
-  
-    if(x@Options$target == ""jags""){
+
+    if(x@Options$target != ""stan""){
         parnames <- x@ParTable$pxnames[match(pars, x@ParTable$free)]
         samps <- samps[, match(parnames, colnames(samps)), ]
     } else {

---FILE: tests/testthat/tests.blavaanobject-methods.R---
@@ -79,21 +79,21 @@ test_that(""blavaan object methods work"", {
     ## plots
     expect_silent(p <- plot(fitstan, showplot = FALSE))
     expect_silent(p <- plot(fitstan, 1:4, showplot = FALSE))
-    expect_silent(p <- plot(fitstan, plot.type = ""hist""))
-    expect_silent(p <- plot(fitstan, 1:4, plot.type = ""dens""))
-    expect_silent(p <- plot(fitstan, c(2,4), plot.type = ""scatter""))
+    expect_silent(p <- plot(fitstan, plot.type = ""hist"", showplot = FALSE))
+    expect_silent(p <- plot(fitstan, 1:4, plot.type = ""dens"", showplot = FALSE))
+    expect_silent(p <- plot(fitstan, c(2,4), plot.type = ""scatter"", showplot = FALSE))
 
     expect_silent(p <- plot(fitstanc, showplot = FALSE))
     expect_silent(p <- plot(fitstanc, 1:4, showplot = FALSE))
-    expect_silent(p <- plot(fitstanc, plot.type = ""hist""))
-    expect_silent(p <- plot(fitstanc, 1:4, plot.type = ""dens""))
-    expect_silent(p <- plot(fitstanc, c(2,4), plot.type = ""scatter""))
+    expect_silent(p <- plot(fitstanc, plot.type = ""hist"", showplot = FALSE))
+    expect_silent(p <- plot(fitstanc, 1:4, plot.type = ""dens"", showplot = FALSE))
+    expect_silent(p <- plot(fitstanc, c(2,4), plot.type = ""scatter"", showplot = FALSE))
 
     expect_silent(p <- plot(fitjags, showplot = FALSE))
     expect_silent(p <- plot(fitjags, 1:4, showplot = FALSE))
-    expect_silent(p <- plot(fitjags, plot.type = ""hist""))
-    expect_silent(p <- plot(fitjags, 1:4, plot.type = ""dens""))
-    expect_silent(p <- plot(fitjags, c(2,4), plot.type = ""scatter""))
+    expect_silent(p <- plot(fitjags, plot.type = ""hist"", showplot = FALSE))
+    expect_silent(p <- plot(fitjags, 1:4, plot.type = ""dens"", showplot = FALSE))
+    expect_silent(p <- plot(fitjags, c(2,4), plot.type = ""scatter"", showplot = FALSE))
   }
     
 })"
ecmerkle,blavaan,3f4ba9265d92a8e74081560a343b363a89638bce,ecmerkle,merklee@missouri.edu,2019-09-03T18:34:40Z,ecmerkle,merklee@missouri.edu,2019-09-03T18:34:40Z,"fix plots for multiple groups, add bayesplot to imports",DESCRIPTION;R/blav_object_methods.R,False,True,True,False,8,4,12,"---FILE: DESCRIPTION---
@@ -31,7 +31,7 @@ License: GPL (>= 3)
 ByteCompile: true
 Depends: R(>= 3.5.0), methods, lavaan(>= 0.6-4), Rcpp(>= 0.12.15)
 Imports: stats, utils, graphics, MCMCpack, coda, mnormt, nonnest2(>= 0.5-2), loo(>= 2.0), rstan(>= 2.19.2), rstantools(>= 1.5.0)
-LinkingTo: StanHeaders (>= 2.18.1), rstan (>= 2.19.2), BH (>= 1.69.0), Rcpp (>= 0.12.15), RcppEigen (>= 0.3.3.4.0)
-Suggests: runjags(>= 2.0.4-2), bayesplot, modeest, rjags, semTools, parallel, testthat(>= 2.0.0)
+LinkingTo: StanHeaders (>= 2.18.1), rstan (>= 2.19.2), BH (>= 1.69.0), Rcpp (>= 0.12.15), RcppEigen (>= 0.3.3.4.0), bayesplot
+Suggests: runjags(>= 2.0.4-2), modeest, rjags, semTools, parallel, testthat(>= 2.0.0)
 SystemRequirements: GNU make
 NeedsCompilation: yes

---FILE: R/blav_object_methods.R---
@@ -342,8 +342,12 @@ plot.blavaan <- function(x, pars=NULL, plot.type=""trace"", showplot=TRUE, ...){
         parnums <- x@ParTable$stanpnum[match(pars, x@ParTable$free)]
         samps <- samps[, parnums, ]
     }
-    colnames(samps) <- with(x@ParTable, paste0(lhs,op,rhs)[match(pars, free)])
-
+    if(blavInspect(x, 'ngroups') == 1L){
+        colnames(samps) <- with(x@ParTable, paste0(lhs,op,rhs)[match(pars, free)])
+    } else {
+        colnames(samps) <- with(x@ParTable, paste0(lhs,op,rhs,"".g"",group)[match(pars, free)])
+    }
+        
     plfun <- get(paste0(""mcmc_"", plot.type), asNamespace(""bayesplot""))
 
     ## samps dims must be ""iteration, chain, parameter"""
ecmerkle,blavaan,81ea76c0e40001d88a1b91953d18a4656fe5c2bb,ecmerkle,merklee@missouri.edu,2019-08-06T20:22:04Z,ecmerkle,merklee@missouri.edu,2019-08-06T20:22:04Z,fix for stan plot bug,DESCRIPTION;R/blav_object_methods.R,False,True,True,False,5,5,10,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-5
+Version: 0.3-6
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: R/blav_object_methods.R---
@@ -348,15 +348,15 @@ plot.blavaan <- function(x, pars=NULL, plot.type=""trace"", ...){
                   ddd))
     } else {
         parnums <- x@ParTable$stanpnum[match(pars, x@ParTable$free)]
-        parlabs <- with(x@ParTable, paste0(lhs,op,rhs)[match(pars, free)])
-        oldnames <- names(x@external$mcmcout)[parnums]
-        names(x@external$mcmcout)[parnums] <- parlabs
+        #parlabs <- with(x@ParTable, paste0(lhs,op,rhs)[match(pars, free)])
+        parlabs <- names(x@external$mcmcout)[parnums]
+        #names(x@external$mcmcout)[parnums] <- parlabs
         plargs <- list(x = x@external$mcmcout,
                        plotfun = plot.type)
         plargs <- c(plargs, list(pars = parlabs), list(...))
 
         do.call(rstan::plot, plargs)
-        names(x@external$mcmcout)[parnums] <- oldnames
+        #names(x@external$mcmcout)[parnums] <- oldnames
     }
 }
 "
ecmerkle,blavaan,1930277932cdabc5400cacfd7b44ddd212830e66,ecmerkle,merklee@missouri.edu,2019-08-02T03:01:50Z,ecmerkle,merklee@missouri.edu,2019-08-02T03:01:50Z,fix max warning for very simple models,R/lav_export_stanmarg.R,False,True,True,False,2,1,3,"---FILE: R/lav_export_stanmarg.R---
@@ -651,7 +651,8 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, fun = ""
 
   freeidx <- lapply(lavfree, function(x) lapply(x, function(y) which(y > 0, arr.ind = TRUE)))
   freenums <- lapply(free2, function(x) lapply(x, function(y) y[y > 0]))
-  nfree <- max(sapply(lavfree, function(x) sapply(x, max)))
+  nfree <- max(sapply(lavfree, function(x)
+    sapply(x, function(x) ifelse(length(x) > 0, max(x), 0))))
 
   if(stanfit){
     draw_mat <- as.matrix(rsob)"
ecmerkle,blavaan,8b6ca01a1ccb9a968db68fdf66469d6572953e52,ecmerkle,merklee@missouri.edu,2019-07-14T15:20:50Z,ecmerkle,merklee@missouri.edu,2019-07-14T15:20:50Z,fix defined parameters in new stan approach,R/blavaan.R;R/lav_export_stanmarg.R;R/set_stanpars.R,False,True,True,False,10,3,13,"---FILE: R/blavaan.R---
@@ -593,6 +593,10 @@ blavaan <- function(...,  # default lavaan arguments
                 wrmup <- ifelse(length(rjarg$warmup) > 0,
                                 rjarg$warmup, floor(rjarg$iter/2))
                 attr(x, ""iterations"") <- sample
+                if(target == ""stan""){
+                    ## defined variables come from delta method:
+                    lavpartable$est <- lav_model_get_parameters(lavmodel = lavmodel, type = ""user"", extra = TRUE)
+                }
                 # burnin + sample already defined, will be saved in
                 # @external so summary() can use it:
                 #burnin <- wrmup

---FILE: R/lav_export_stanmarg.R---
@@ -561,8 +561,11 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits) {
   prich <- prinames %in% mapping
   primap <- match(prinames[prich], mapping)
   names(prifree)[prich] <- names(mapping)[primap]
-  
-  stanprires <- set_stanpars("""", lavpartable, prifree, dp, """")
+
+  lpt <- lavpartable
+  lpt$mat[lpt$op == "":=""] <- ""def""
+  dp <- c(dp, def = """")
+  stanprires <- set_stanpars("""", lpt, prifree, dp, """")
   lavpartable$prior <- stanprires$partable$prior
   
   ## add inits (manipulate partable to re-use set_inits_stan)

---FILE: R/set_stanpars.R---
@@ -39,7 +39,7 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
     }
 
     for(i in 1:nrow(partable)){
-        if(partable$mat[i] != """" | partable$op[i] == "":=""){            
+        if(partable$mat[i] != """" | partable$op[i] == "":=""){
             ## to find equality constraints
             eqpar <- which(partable$rhs == partable$plabel[i] &
                            partable$op == ""=="")"
ecmerkle,blavaan,b4ad514dae3e90fdb80526aee93d920fe9ef0051,ecmerkle,merklee@missouri.edu,2019-07-08T18:20:18Z,ecmerkle,merklee@missouri.edu,2019-07-08T18:20:18Z,another travis fix,.travis.yml,False,False,False,False,1,1,2,"---FILE: .travis.yml---
@@ -39,5 +39,5 @@ matrix:
 
 before_install:
   - mkdir -p ~/.R
-  - echo ""CXX14FLAGS=-O3 -mtune=native -march=native -Wno-unused-variable -Wno-unused-function  -Wno-macro-redefined"" >> ~/.R/Makevars
+  - echo ""CXX14FLAGS=-O3 -mtune=native"" >> ~/.R/Makevars
   - echo ""CXX14=g++-7 -std=c++1y -fPIC"" >> ~/.R/Makevars"
ecmerkle,blavaan,ebfb83e6e573124c1420929de50a89328bdf1c87,ecmerkle,merklee@missouri.edu,2019-07-08T17:45:16Z,ecmerkle,merklee@missouri.edu,2019-07-08T17:45:16Z,fix travis,.travis.yml,False,False,False,False,7,6,13,"---FILE: .travis.yml---
@@ -1,10 +1,10 @@
 language: r
+sudo: required
 cache: packages
 
 r_github_packages:
   - yrosseel/lavaan
 
-sudo: required
 warnings_are_errors: true
 
 matrix:
@@ -18,10 +18,10 @@ matrix:
             - ubuntu-toolchain-r-test
           packages:
             - g++-7
-	    - jags
+            - jags
       env:
         - MATRIX_EVAL=""CC=gcc-7 && CXX=g++-7""
-	- _R_CHECK_FORCE_SUGGESTS_=false
+        - _R_CHECK_FORCE_SUGGESTS_=false
     - os: linux
       dist: trusty
       r: devel
@@ -31,11 +31,12 @@ matrix:
             - ubuntu-toolchain-r-test
           packages:
             - g++-7
-	    - jags
+            - jags
       env:
         - MATRIX_EVAL=""CC=gcc-7 && CXX=g++-7""
-	- _R_CHECK_FORCE_SUGGESTS_=false
-	
+        - _R_CHECK_FORCE_SUGGESTS_=false
+
+
 before_install:
   - mkdir -p ~/.R
   - echo ""CXX14FLAGS=-O3 -mtune=native -march=native -Wno-unused-variable -Wno-unused-function  -Wno-macro-redefined"" >> ~/.R/Makevars"
ecmerkle,blavaan,4df4dea401c2d761060742044eab1b241b616a11,merkle,merklee@missouri.edu,2019-07-04T18:59:44Z,merkle,merklee@missouri.edu,2019-07-04T18:59:44Z,"fix namespace, docs from pull request",DESCRIPTION;NAMESPACE;man/ppmc.Rd,False,False,False,False,9,5,14,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-5.450
+Version: 0.3-5.470
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",

---FILE: NAMESPACE---
@@ -18,7 +18,11 @@ importFrom(""stats"",
            ""vcov"")
 
 importFrom(""graphics"",
-           ""plot"", ""hist"", ""pairs"")
+           ""plot"", ""hist"", ""pairs"", ""legend"", ""par"", ""plot.new"",
+           ""polygon"")
+
+importFrom(""grDevices"",
+           ""adjustcolor"")
 
 importFrom(""lavaan"",
            ""lavaan"", ""logLik"",

---FILE: man/ppmc.Rd---
@@ -3,9 +3,9 @@
 \alias{blavPPMC-class}
 \alias{show,blavPPMC-method}
 \alias{summary,blavPPMC-method}
-\alias{plot,blavPPMC-method}
-\alias{hist,blavPPMC-method}
-\alias{pairs,blavPPMC-method}
+\alias{plot.blavPPMC}
+\alias{hist.blavPPMC}
+\alias{pairs.blavPPMC}
 \title{Posterior Predictive Model Checks}
 \description{
 This function allows users to conduct a posterior predictive model check to"
ecmerkle,blavaan,64ec60da2ef2da921f5ab1cfc1bd5c85b523c44b,ecmerkle,merklee@missouri.edu,2019-06-09T14:02:51Z,ecmerkle,merklee@missouri.edu,2019-06-09T14:02:51Z,fix some tests,R/lav_export_stanmarg.R;tests/testthat/tests.blavaanobject-methods.R,False,True,True,False,2,2,4,"---FILE: R/lav_export_stanmarg.R---
@@ -722,6 +722,7 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, fun = ""
     ## est + psrf
     lavpartable$est[lavpartable$free > 0] <- est
     lavpartable$psrf[lavpartable$free > 0] <- rssumm$summary[rowidx2,""Rhat""]
+    lavpartable$pxnames[lavpartable$free > 0] <- rownames(rssumm$summary)[rowidx2]
   } else {
     sdvec <- NULL
     vcorr <- NULL
@@ -730,7 +731,6 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, fun = ""
   
   ## matrices and names
   lavpartable <- lavMatrixRepresentation(lavpartable, add.attributes = TRUE, as.data.frame. = FALSE)
-  lavpartable$pxnames[lavpartable$free > 0] <- rownames(rssumm$summary)[rowidx2]
   
   list(x = lavpartable$est[lavpartable$free > 0],
        lavpartable = lavpartable,

---FILE: tests/testthat/tests.blavaanobject-methods.R---
@@ -10,7 +10,7 @@ test_that(""blavaan object methods work"", {
 
     ## parameter summaries
     expect_equal(dim(parTable(fitjags)), c(10,20))
-    expect_equal(dim(parTable(fitstan)), c(10,23))
+    expect_equal(dim(parTable(fitstan)), c(10,24))
 
     expect_equal(sum(fitjags@ParTable$free > 0, na.rm = TRUE),
                  length(blavInspect(fitjags, 'psrf')))"
ecmerkle,blavaan,66cea225ec0f0ee9dd791a1fde14487151558b59,merkle,merklee@missouri.edu,2019-06-09T13:29:46Z,merkle,merklee@missouri.edu,2019-06-09T13:29:46Z,fix RcppEigen version,DESCRIPTION,False,False,False,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-5.448
+Version: 0.3-5.450
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu"",
@@ -30,7 +30,7 @@ License: GPL (>= 3)
 ByteCompile: true
 Depends: R(>= 3.5.0), methods, lavaan(>= 0.6-3), Rcpp(>= 0.12.15)
 Imports: stats, utils, graphics, MCMCpack, coda, mnormt, nonnest2(>= 0.5-2), loo(>= 2.0), rstan(>= 2.17.3), rstantools(>= 1.5.0)
-LinkingTo: StanHeaders (>= 2.17.2), rstan (>= 2.17.3), BH (>= 1.66.0-1), Rcpp (>= 0.12.15), RcppEigen (>= 0.3-5.448
+LinkingTo: StanHeaders (>= 2.17.2), rstan (>= 2.17.3), BH (>= 1.66.0-1), Rcpp (>= 0.12.15), RcppEigen (>= 0.3.3.4.0)
 Suggests: runjags(>= 2.0.4-2), modeest, rjags, semTools, parallel, testthat(>= 2.0.0)
 SystemRequirements: GNU make
 NeedsCompilation: yes"
ecmerkle,blavaan,71063c5ad536db6139763641b8366d132a9b1cf5,ecmerkle,merklee@missouri.edu,2019-06-09T12:13:23Z,ecmerkle,merklee@missouri.edu,2019-06-09T12:13:23Z,fix margloglik for stanmarg,R/lav_export_stanmarg.R;R/margloglik.R,False,True,True,False,6,4,10,"---FILE: R/lav_export_stanmarg.R---
@@ -728,8 +728,9 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, fun = ""
     rssumm <- list(summary = NULL)
   }
   
-  ## matrices
+  ## matrices and names
   lavpartable <- lavMatrixRepresentation(lavpartable, add.attributes = TRUE, as.data.frame. = FALSE)
+  lavpartable$pxnames[lavpartable$free > 0] <- rownames(rssumm$summary)[rowidx2]
   
   list(x = lavpartable$est[lavpartable$free > 0],
        lavpartable = lavpartable,

---FILE: R/margloglik.R---
@@ -32,12 +32,13 @@ margloglik <- function(lavpartable, lavmodel, lavoptions,
                   rownames(summstats),
                   nomatch=0)
 
-  ## this is potentially under srs parameterization,
-  ## need to change below to use lavaan's log-likelihood
+  ## this is potentially under srs parameterization (unless stanmarg)
   if(target == ""jags""){
     thetstar <- summstats[cmatch,""Mean""]
-  } else if(target == ""stan""){
+  } else if(target == ""stanclassic""){
     thetstar <- summstats[cmatch,""mean""]
+  } else {
+    thetstar <- lavpartable$est[urows]
   }
   names(thetstar) <- NULL
 "
ecmerkle,blavaan,7f9032b3c5a51c564ad4231b88260fd7903535fb,ecmerkle,merklee@missouri.edu,2019-06-08T05:28:04Z,ecmerkle,merklee@missouri.edu,2019-06-08T05:28:04Z,fix some checks,R/blavaan.R;man/dpriors.Rd;tests/testthat/tests.blavaan.R;tests/testthat/tests.blavaanobject-methods.R,False,True,True,False,6,6,12,"---FILE: R/blavaan.R---
@@ -435,7 +435,7 @@ blavaan <- function(...,  # default lavaan arguments
                                            ""Nu_free"", ""Alpha_free"",
                                            ""eta""))
                     if(""init"" %in% names(l2s)){
-                      jagtrans <- c(jagtrans, list(init = l2s$init))
+                      jagtrans <- c(jagtrans, list(inits = l2s$init))
                     }
                 } else {
                     jagtrans <- l2s
@@ -500,7 +500,7 @@ blavaan <- function(...,  # default lavaan arguments
               rjarg <- with(jagtrans, list(object = stanmodels$stanmarg,
                                            data = data,
                                            pars = sampparms,
-                                           init = init))
+                                           init = inits))
             }
 
             ## user-supplied jags params

---FILE: man/dpriors.Rd---
@@ -48,5 +48,5 @@ Software, 85(4), 1-30. URL http://www.jstatsoft.org/v85/i04/.
 \code{\link{bcfa}}, \code{\link{bsem}}, \code{\link{bgrowth}}
 }
 \examples{
-dpriors(nu = ""dunif(0,10)"", lambda = ""dnorm(0,1e-2) T(0,)"", itheta = ""dexp(1)"")
+dpriors(nu = ""normal(0,10)"", lambda = ""normal(0,1)"", rho = ""beta(3,3)"")
 }

---FILE: tests/testthat/tests.blavaan.R---
@@ -9,8 +9,8 @@ test_that(""blavaan arguments"", {
   ## auto convergence in stan
   expect_error(bsem(model, data=Data, fixed.x=TRUE, target=""stan"", convergence=""auto""))
 
-  ## seed length != # chains
-  expect_error(bsem(model, data=Data, fixed.x=TRUE, seed=1))
+  ## seed length != # chains for jags
+  expect_error(bsem(model, data=Data, fixed.x=TRUE, seed=1, target=""jags""))
 
   ## supply ordinals
   #expect_error(bsem(model, data=Data, fixed.x=TRUE, ordered=c(""y1"", ""x1"", adapt=2, burnin=2, sample=2)))

---FILE: tests/testthat/tests.blavaanobject-methods.R---
@@ -10,7 +10,7 @@ test_that(""blavaan object methods work"", {
 
     ## parameter summaries
     expect_equal(dim(parTable(fitjags)), c(10,20))
-    expect_equal(dim(parTable(fitstan)), c(10,21))
+    expect_equal(dim(parTable(fitstan)), c(10,23))
 
     expect_equal(sum(fitjags@ParTable$free > 0, na.rm = TRUE),
                  length(blavInspect(fitjags, 'psrf')))"
ecmerkle,blavaan,2dea8c30e0bbd52c40b534c2c48eb613ffc10896,ecmerkle,merklee@missouri.edu,2019-05-20T16:06:18Z,ecmerkle,merklee@missouri.edu,2019-05-20T16:06:18Z,fix do.fit=FALSE for stanmarg,R/lav_export_stanmarg.R,False,True,True,False,74,66,140,"---FILE: R/lav_export_stanmarg.R---
@@ -609,8 +609,6 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, fun = ""
     }
     sd.est <- rssumm$summary[,""sd""]
   }
-
-  draw_mat <- as.matrix(rsob)
   
   ## lavaan pars to stan par vectors
   mapping <- c(ly_sign = ""lambda"", g_sign = ""gamma"",
@@ -652,79 +650,89 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, fun = ""
   freenums <- lapply(free2, function(x) lapply(x, function(y) y[y > 0]))
   nfree <- max(sapply(lavfree, function(x) sapply(x, max)))
 
-  freevec <- rep(NA, nfree)
-  rowidx <- rowidx2 <- rep(NA, nfree) # row index of stan est and summary containing the parameters (for vcorr)
-
-  ## 1. get free par vector
-  ## 2. expand it using w?skel for eq constraints
-  ## 3. fill ""x"" in using lavaan free
-  ## 4. record freeidx, double-counting free parameters
-  est <- sdvec <- rep(NA, nfree)
-
-  for(m in 1:length(freeidx[[1]])){
-    stanvec <- names(mapping)[mapping == names(freeidx[[1]])[m]]
-    wskel <- names(mapping2)[mapping == names(freeidx[[1]])[m]]
-    wvec <- paste0(""w"", wskel)
-    wgvec <- paste0(""wg"", wskel)
-    wskel <- paste0(wvec, ""skel"")
-
-    ## 2 for cov/var vectors, 1 otherwise
-    if(length(stanvec) > 2) stop(""blavaan ERROR: problem with mapping from stan to lavaan"")
-
-    for(j in 1:length(stanvec)){
-      freename <- names(mapping3)[mapping3 == stanvec[j]]
-      parnums <- do.call(""c"", freenums[[freename]])      
-      tmpw <- lersdat[[wskel[j]]]
-
-      if(is.na(parnums[1])) next
-
-      if(any(!is.finite(lersdat[[wvec[j]]]))){
-        tmpw <- tmpw[1:(sum(!is.finite(lersdat[[wvec[j]]]))), , drop=FALSE]
-      } else {
-        tmpw <- NULL
-      }
+  if(stanfit){
+    draw_mat <- as.matrix(rsob)
+
+    freevec <- rep(NA, nfree)
+    rowidx <- rowidx2 <- rep(NA, nfree) # row index of stan est and summary containing the parameters (for vcorr)
+
+    ## 1. get free par vector
+    ## 2. expand it using w?skel for eq constraints
+    ## 3. fill ""x"" in using lavaan free
+    ## 4. record freeidx, double-counting free parameters
+    est <- sdvec <- rep(NA, nfree)
+
+    for(m in 1:length(freeidx[[1]])){
+      stanvec <- names(mapping)[mapping == names(freeidx[[1]])[m]]
+      wskel <- names(mapping2)[mapping == names(freeidx[[1]])[m]]
+      wvec <- paste0(""w"", wskel)
+      wgvec <- paste0(""wg"", wskel)
+      wskel <- paste0(wvec, ""skel"")
+
+      ## 2 for cov/var vectors, 1 otherwise
+      if(length(stanvec) > 2) stop(""blavaan ERROR: problem with mapping from stan to lavaan"")
+
+      for(j in 1:length(stanvec)){
+        freename <- names(mapping3)[mapping3 == stanvec[j]]
+        parnums <- do.call(""c"", freenums[[freename]])      
+        tmpw <- lersdat[[wskel[j]]]
+
+        if(is.na(parnums[1])) next
+
+        if(any(!is.finite(lersdat[[wvec[j]]]))){
+          tmpw <- tmpw[1:(sum(!is.finite(lersdat[[wvec[j]]]))), , drop=FALSE]
+        } else {
+          tmpw <- NULL
+        }
 
-      if(NROW(tmpw) > 0){
-        ## need rowvec & rowvec2 because stan summary rows
-        ## ordered differently from stan draws rows
-        parvec <- tmpsd <- rowvec <- rowvec2 <- rep(NA, NROW(tmpw))
-        rowvec[tmpw[,1] == 0] <- grep(stanvec[j], names(b.est))
-        rowvec2[tmpw[,1] == 0] <- grep(stanvec[j], colnames(draw_mat))
-        parvec[tmpw[,1] == 0] <- b.est[rowvec[tmpw[,1] == 0]]
-        tmpsd[tmpw[,1] == 0] <- sd.est[rowvec[tmpw[,1] == 0]]
-
-        eqconst <- tmpw[,2][tmpw[,1] == 1]
-        rowvec[tmpw[,1] == 1] <- rowvec[tmpw[,1] == 0][eqconst]
-        rowvec2[tmpw[,1] == 1] <- rowvec2[tmpw[,1] == 0][eqconst]
-        parvec[tmpw[,1] == 1] <- parvec[tmpw[,1] == 0][eqconst]
-        tmpsd[tmpw[,1] == 1] <- tmpsd[tmpw[,1] == 0][eqconst]
-
-        rowidx[parnums] <- rowvec
-        rowidx2[parnums] <- rowvec2
-        est[parnums] <- parvec
-        sdvec[parnums] <- tmpsd
+        if(NROW(tmpw) > 0){
+          ## need rowvec & rowvec2 because stan summary rows
+          ## ordered differently from stan draws rows
+          parvec <- tmpsd <- rowvec <- rowvec2 <- rep(NA, NROW(tmpw))
+          rowvec[tmpw[,1] == 0] <- grep(stanvec[j], names(b.est))
+          rowvec2[tmpw[,1] == 0] <- grep(stanvec[j], colnames(draw_mat))
+          parvec[tmpw[,1] == 0] <- b.est[rowvec[tmpw[,1] == 0]]
+          tmpsd[tmpw[,1] == 0] <- sd.est[rowvec[tmpw[,1] == 0]]
+
+          eqconst <- tmpw[,2][tmpw[,1] == 1]
+          rowvec[tmpw[,1] == 1] <- rowvec[tmpw[,1] == 0][eqconst]
+          rowvec2[tmpw[,1] == 1] <- rowvec2[tmpw[,1] == 0][eqconst]
+          parvec[tmpw[,1] == 1] <- parvec[tmpw[,1] == 0][eqconst]
+          tmpsd[tmpw[,1] == 1] <- tmpsd[tmpw[,1] == 0][eqconst]
+          
+          rowidx[parnums] <- rowvec
+          rowidx2[parnums] <- rowvec2
+          est[parnums] <- parvec
+          sdvec[parnums] <- tmpsd
+        }
       }
     }
-  }
 
-  vcorr <- cor(draw_mat[,rowidx2])
+    vcorr <- cor(draw_mat[,rowidx2])
 
-  names(sdvec) <- colnames(vcorr)
+    names(sdvec) <- colnames(vcorr)
 
-  ## add to partable for other functions
-  ## indexing of stan objects
-  lavpartable$stanpnum <- rep(NA, length(lavpartable$est))
-  lavpartable$stansumnum <- rep(NA, length(lavpartable$est))
-  lavpartable$stanpnum[lavpartable$free > 0] <- rowidx
-  lavpartable$stansumnum[lavpartable$free > 0] <- rowidx2
+    ## add to partable for other functions
+    ## indexing of stan objects
+    lavpartable$stanpnum <- rep(NA, length(lavpartable$est))
+    lavpartable$stansumnum <- rep(NA, length(lavpartable$est))
+    lavpartable$stanpnum[lavpartable$free > 0] <- rowidx
+    lavpartable$stansumnum[lavpartable$free > 0] <- rowidx2
 
-  ## est + psrf
-  lavpartable$est[lavpartable$free > 0] <- est
-  lavpartable$psrf[lavpartable$free > 0] <- rssumm$summary[rowidx2,""Rhat""]
+    ## est + psrf
+    lavpartable$est[lavpartable$free > 0] <- est
+    lavpartable$psrf[lavpartable$free > 0] <- rssumm$summary[rowidx2,""Rhat""]
+  } else {
+    sdvec <- NULL
+    vcorr <- NULL
+    rssumm <- list(summary = NULL)
+  }
   
   ## matrices
   lavpartable <- lavMatrixRepresentation(lavpartable, add.attributes = TRUE, as.data.frame. = FALSE)
   
-  list(x = est, vcorr = vcorr, sd = sdvec,
-       stansumm = rssumm$summary, lavpartable = lavpartable)
+  list(x = lavpartable$est[lavpartable$free > 0],
+       lavpartable = lavpartable,
+       vcorr = vcorr, sd = sdvec,
+       stansumm = rssumm$summary)
 }"
ecmerkle,blavaan,86a63d1257c952cdeecb8c65a3958fc4744efd3e,ecmerkle,merklee@missouri.edu,2019-05-20T15:25:37Z,ecmerkle,merklee@missouri.edu,2019-05-20T15:25:37Z,do not include S in stanmarg due to non-pd error,R/stanmarg_data.R,False,True,True,False,2,1,3,"---FILE: R/stanmarg_data.R---
@@ -206,7 +206,8 @@ stanmarg_data <- function(YX = NULL, S = NULL, N, Ng, grpnum, # data
     
     dat$S <- array(NA, dim=c(Ng, NCOL(YX), NCOL(YX)))
     for(i in 1:Ng) {
-      dat$S[i,,] <- (dat$N[i] - 1) * cov(YX[(startrow[i] : endrow[i]), , drop = FALSE]) # NB!! this multiplication is needed to use wishart_lpdf
+      dat$S[i,,] <- diag(1, NCOL(YX))
+      ## not added because, if not pd, stan fails: (dat$N[i] - 1) * cov(YX[(startrow[i] : endrow[i]), , drop = FALSE]) # NB!! this multiplication is needed to use wishart_lpdf
     }
   }
 "
ecmerkle,blavaan,7a1caab288ad224a1fcb0ea07da856ec97b3097f,ecmerkle,merklee@missouri.edu,2019-05-17T13:48:21Z,ecmerkle,merklee@missouri.edu,2019-05-17T13:48:21Z,fix stanmarg ov sign constraint,R/lav_export_stanmarg.R,False,True,True,False,12,4,16,"---FILE: R/lav_export_stanmarg.R---
@@ -103,12 +103,20 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, ...) {
             
             ## find sign-constrained loadings of the two lvs
             lampar1 <- lamfree[[i]][,fpar[j,2]]
-            l1 <- min(lampar1[lampar1 != 0L])
-            if (lamsign[l1,1] == 1) l1 <- lamsign[l1,2]
+            if (all(lampar1 == 0)) { # ov converted to lv
+              l1 <- 1
+            } else {
+              l1 <- min(lampar1[lampar1 != 0L])
+              if (lamsign[l1,1] == 1) l1 <- lamsign[l1,2]
+            }
 
             lampar2 <- lamfree[[i]][,fpar[j,1]]
-            l2 <- min(lampar2[lampar2 != 0])
-            if (lamsign[l2,1] == 1) l2 <- lamsign[l2,2]
+            if (all(lampar2 == 0)) {
+              l2 <- 1
+            } else {
+              l2 <- min(lampar2[lampar2 != 0])
+              if (lamsign[l2,1] == 1) l2 <- lamsign[l2,2]
+            }
 
             rowloc <- free2[[i]][fpar[j,1], fpar[j,2]]
             sign[rowloc, 2:3] <- c(l1, l2)"
ecmerkle,blavaan,a8c82eca14cbb3d134a8eaa41fa2e5d2d4f9e62e,ecmerkle,merklee@missouri.edu,2019-05-17T13:27:08Z,ecmerkle,merklee@missouri.edu,2019-05-17T13:27:08Z,fix stanmarg for univariate model,src/stan_files/stanmarg.stan,False,False,False,False,5,4,9,"---FILE: src/stan_files/stanmarg.stan---
@@ -618,7 +618,9 @@ model { // N.B.: things declared in the model block do not get saved in the outp
   matrix[p, q] top_right[Ng];        // top right block of Sigma
   
   for (g in 1:Ng) {
-    Lambda_y_A[g] = mdivide_right(Lambda_y[g], I - B[g]);     // = Lambda_y * (I - B)^{-1}
+    if (m > 0) {
+      Lambda_y_A[g] = mdivide_right(Lambda_y[g], I - B[g]);     // = Lambda_y * (I - B)^{-1}
+    }
     Lambda_xt[g] = transpose(Lambda_x[g]);                         // copies so do it just once
 
     Mu[g] = to_vector(Nu[g]);
@@ -640,10 +642,9 @@ model { // N.B.: things declared in the model block do not get saved in the outp
       if (q > 0) {
 	GPG[g] = quad_form(PHI[g], transpose(Gamma[g]));
       }
-      Sigma[g, 1:p, 1:p] = quad_form(GPG[g] + Psi[g], transpose(Lambda_y_A[g]));
-      Sigma[g, 1:p, 1:p] += quad_form_sym(Theta_r[g], Theta_sd[g]);
-
+      Sigma[g, 1:p, 1:p] = quad_form_sym(Theta_r[g], Theta_sd[g]);
       if (m > 0) {
+        Sigma[g, 1:p, 1:p] += quad_form(GPG[g] + Psi[g], transpose(Lambda_y_A[g]));
 	Mu[g, 1:p] += to_vector(Lambda_y_A[g] * Alpha[g, 1:m, 1]);
       }
       if (n > 0) {"
ecmerkle,blavaan,cf5e9885bd3201597a085bc37eeb6e894e651f74,ecmerkle,merklee@missouri.edu,2019-05-17T13:03:39Z,ecmerkle,merklee@missouri.edu,2019-05-17T13:03:39Z,fix cov2cor() in stanmarg,R/stanmarg_data.R;src/stan_files/stanmarg.stan,False,True,True,False,7,8,15,"---FILE: R/stanmarg_data.R---
@@ -206,8 +206,7 @@ stanmarg_data <- function(YX = NULL, S = NULL, N, Ng, grpnum, # data
     
     dat$S <- array(NA, dim=c(Ng, NCOL(YX), NCOL(YX)))
     for(i in 1:Ng) {
-      dat$S[i,,] <- (dat$N[i] - 1) * cov(YX[(startrow[i] : endrow[i]),]) # NB!! this multiplication is needed to use
-                                        # wishart_lpdf
+      dat$S[i,,] <- (dat$N[i] - 1) * cov(YX[(startrow[i] : endrow[i]), , drop = FALSE]) # NB!! this multiplication is needed to use wishart_lpdf
     }
   }
 

---FILE: src/stan_files/stanmarg.stan---
@@ -100,7 +100,7 @@ functions { // you can use these in R following `rstan::expose_stan_functions(""f
   }
 
   // obtain covariance parameter vector for correlation/sd matrices
-  vector cor2cov(matrix[] cormat, matrix[] sdmat, vector free_elements, int[,] wskel, int ngrp) {
+  vector cor2cov(matrix[] cormat, matrix[] sdmat, vector free_elements, matrix[] matskel, int[,] wskel, int ngrp) {
     vector[num_elements(free_elements)] out;
     int R = rows(to_matrix(cormat[1]));
     int C = cols(to_matrix(cormat[1]));
@@ -109,7 +109,7 @@ functions { // you can use these in R following `rstan::expose_stan_functions(""f
     
     for (g in 1:ngrp) {
       for (c in 1:(R-1)) for (r in (c+1):R) {
-	if (cormat[g,r,c] != 0) {
+        if (is_inf(matskel[g,r,c])) {
 	  if (wskel[pos,1] == 0) {
 	    out[freepos] = sdmat[g,r,r] * sdmat[g,c,c] * cormat[g,r,c];
 	    freepos += 1;
@@ -759,9 +759,9 @@ generated quantities { // these matrices are saved in the output but do not figu
   }
 
   // off-diagonal covariance parameter vectors, from cor/sd matrices:
-  Theta_cov = cor2cov(Theta_r, Theta_sd, Theta_r_free, w7skel, Ng);
+  Theta_cov = cor2cov(Theta_r, Theta_sd, Theta_r_free, Theta_r_skeleton, w7skel, Ng);
   Theta_var = Theta_sd_free .* Theta_sd_free;
-  Theta_x_cov = cor2cov(Theta_x_r, Theta_x_sd, Theta_x_r_free, w8skel, Ng);
+  Theta_x_cov = cor2cov(Theta_x_r, Theta_x_sd, Theta_x_r_free, Theta_x_r_skeleton, w8skel, Ng);
   Theta_x_var = Theta_x_sd_free .* Theta_x_sd_free;
   if (m > 0 && len_free[10] > 0) {
     /* iden is created so that we can re-use cor2cov, even though
@@ -770,7 +770,7 @@ generated quantities { // these matrices are saved in the output but do not figu
     for (g in 1:Ng) {
       iden[g] = diag_matrix(rep_vector(1, m));
     }
-    Psi_cov = cor2cov(PS, iden, P_r, w10skel, Ng);
+    Psi_cov = cor2cov(PS, iden, P_r, Psi_r_skeleton, w10skel, Ng);
   } else {
     Psi_cov = P_r;
   }
@@ -779,7 +779,7 @@ generated quantities { // these matrices are saved in the output but do not figu
     for (g in 1:Ng) {
       iden[g] = diag_matrix(rep_vector(1, n));
     }
-    Ph_cov = cor2cov(PH, iden, Ph_r, w12skel, Ng);
+    Ph_cov = cor2cov(PH, iden, Ph_r, Phi_r_skeleton, w12skel, Ng);
   } else {
     Ph_cov = Ph_r;
   }"
ecmerkle,blavaan,bc04c994fed09b01dca6c8aafdddc49e91fe9d43,ecmerkle,merklee@missouri.edu,2019-05-15T19:11:52Z,ecmerkle,merklee@missouri.edu,2019-05-15T19:11:52Z,fix fixed cov parameters in stanmarg,R/blavaan.R;R/lav_export_stanmarg.R;src/stan_files/stanmarg.stan,False,True,True,False,50,35,85,"---FILE: R/blavaan.R---
@@ -421,6 +421,7 @@ blavaan <- function(...,  # default lavaan arguments
                          silent = TRUE)
                 if(!inherits(l2s, ""try-error"")){
                     ldargs <- c(l2s$dat, list(lavpartable = l2s$lavpartable))
+                    lavpartable$prior <- l2s$lavpartable$prior
                     jagtrans <- try(do.call(""stanmarg_data"", ldargs), silent = TRUE)
 browser()
                     jagtrans <- list(data = jagtrans,

---FILE: R/lav_export_stanmarg.R---
@@ -18,6 +18,15 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, ...) {
     matskel[upper.tri(matskel)] <- 0    
     for (i in 1:Ng) {
       free[[i]][upper.tri(free[[i]])] <- 0
+
+      ## fixed covs that need to be cors
+      fcov <- which(est[[i]] != 0 & free[[i]] == 0, arr.ind = TRUE)
+      fcov <- fcov[fcov[,1] != fcov[,2], , drop = FALSE]
+      if (length(fcov) > 0) {
+        for (j in 1:nrow(fcov)) {
+          est[[i]][fcov[j,1], fcov[j,2]] <- est[[i]][fcov[j,1], fcov[j,2]] / sqrt(ddd$dest[[i]][fcov[j,1], fcov[j,1]] * ddd$dest[[i]][fcov[j,2], fcov[j,2]])
+        }
+      }
     }
   }
 
@@ -292,6 +301,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits) {
       dmat[lower.tri(dmat)] <- dmat[upper.tri(dmat)] <- 0
       dmat}
       )
+    dest <- es
     
     res <- matattr(fr, es, constrain, mat = ""Theta"", Ng, opts$std.lv)
 
@@ -309,67 +319,69 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits) {
     dat$w5skel <- matrix(0, 0, 2)
   }
 
-  ## 6. diag(Theta_x)
-  if (""cov.x"" %in% names(freemats[[1]])) {
+  ## 7. Theta_r
+  if (""theta"" %in% names(freemats[[1]])) {
     fr <- lapply(freemats, function(x){
-      dmat <- x$cov.x
-      dmat[lower.tri(dmat)] <- dmat[upper.tri(dmat)] <- 0
+      dmat <- x$theta
+      diag(dmat) <- 0L
       dmat}
       )
     
     es <- lapply(estmats, function(x){
-      dmat <- x$cov.x
-      dmat[lower.tri(dmat)] <- dmat[upper.tri(dmat)] <- 0
+      dmat <- x$theta
+      diag(dmat) <- 1L
+      dmat[upper.tri(dmat)] <- 0L
       dmat}
       )
     
-    res <- matattr(fr, es, constrain, mat = ""Theta_x"", Ng, opts$std.lv)
+    res <- matattr(fr, es, constrain, mat = ""Theta_r"", Ng, opts$std.lv, dest = dest)
 
-    dat$Theta_x_skeleton <- res$matskel
-    dat$w6skel <- res$wskel
-    free2 <- c(free2, list(cov.x = res$free))
-    ptrows <- with(lavpartable, which(mat == ""cov.x"" & free > 0 & row == col))
+    dat$Theta_r_skeleton <- res$matskel
+    dat$w7skel <- res$wskel
+    free2 <- c(free2, list(rtheta = res$free))
+    ptrows <- with(lavpartable, which(mat == ""theta"" & free > 0 & row != col))
     veclen <- length(ptrows)
     if (veclen > 0) {
-      nfree <- c(nfree, list(cov.x = sum(res$wskel[1:veclen,1] == 0)))
+      nfree <- c(nfree, list(rho = sum(res$wskel[1:veclen,1] == 0)))
       freeparnums[ptrows[res$wskel[1:veclen,1] == 0]] <- 1:sum(res$wskel[1:veclen,1] == 0)
     }
   } else {
-    dat$Theta_x_skeleton <- array(0, dim = c(Ng, 0, 0))
-    dat$w6skel <- matrix(0, 0, 2)
+    dat$Theta_r_skeleton <- array(0, dim = c(Ng, 0, 0))
+    dat$w7skel <- matrix(0, 0, 2)
   }
-
-  ## 7. Theta_r
-  if (""theta"" %in% names(freemats[[1]])) {
+  
+  ## 6. diag(Theta_x)
+  if (""cov.x"" %in% names(freemats[[1]])) {
     fr <- lapply(freemats, function(x){
-      dmat <- x$theta
-      diag(dmat) <- 0L
+      dmat <- x$cov.x
+      dmat[lower.tri(dmat)] <- dmat[upper.tri(dmat)] <- 0
       dmat}
       )
     
     es <- lapply(estmats, function(x){
-      dmat <- x$theta
-      diag(dmat) <- 1L
-      dmat[upper.tri(dmat)] <- 0L
+      dmat <- x$cov.x
+      dmat[lower.tri(dmat)] <- dmat[upper.tri(dmat)] <- 0
       dmat}
       )
+    dest <- es
     
-    res <- matattr(fr, es, constrain, mat = ""Theta_r"", Ng, opts$std.lv)
+    res <- matattr(fr, es, constrain, mat = ""Theta_x"", Ng, opts$std.lv)
 
-    dat$Theta_r_skeleton <- res$matskel
-    dat$w7skel <- res$wskel
-    free2 <- c(free2, list(rtheta = res$free))
-    ptrows <- with(lavpartable, which(mat == ""theta"" & free > 0 & row != col))
+    dat$Theta_x_skeleton <- res$matskel
+    dat$w6skel <- res$wskel
+    free2 <- c(free2, list(cov.x = res$free))
+    ptrows <- with(lavpartable, which(mat == ""cov.x"" & free > 0 & row == col))
     veclen <- length(ptrows)
     if (veclen > 0) {
-      nfree <- c(nfree, list(rho = sum(res$wskel[1:veclen,1] == 0)))
+      nfree <- c(nfree, list(cov.x = sum(res$wskel[1:veclen,1] == 0)))
       freeparnums[ptrows[res$wskel[1:veclen,1] == 0]] <- 1:sum(res$wskel[1:veclen,1] == 0)
     }
   } else {
-    dat$Theta_r_skeleton <- array(0, dim = c(Ng, 0, 0))
-    dat$w7skel <- matrix(0, 0, 2)
+    dat$Theta_x_skeleton <- array(0, dim = c(Ng, 0, 0))
+    dat$w6skel <- matrix(0, 0, 2)
   }
 
+
   ## 8. Theta_x_r
   if (""cov.x"" %in% names(freemats[[1]])) {
     fr <- lapply(freemats, function(x){
@@ -385,7 +397,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits) {
       dmat}
       )
     
-    res <- matattr(fr, es, constrain, mat = ""Theta_x_r"", Ng, opts$std.lv)
+    res <- matattr(fr, es, constrain, mat = ""Theta_x_r"", Ng, opts$std.lv, dest = dest)
 
     dat$Theta_x_r_skeleton <- res$matskel
     dat$w8skel <- res$wskel
@@ -414,7 +426,8 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits) {
       dmat[lower.tri(dmat)] <- dmat[upper.tri(dmat)] <- 0
       dmat}
       )
-
+    dest <- es
+    
     ## std.lv only matters for off-diagonals
     res <- matattr(fr, es, constrain, mat = ""Psi"", Ng, FALSE)
 
@@ -448,7 +461,8 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits) {
       )
     
     res <- matattr(fr, es, constrain, mat = ""Psi_r"", Ng, opts$std.lv,
-                   free2 = lyfree2, sign = dat$lam_y_sign)
+                   free2 = lyfree2, sign = dat$lam_y_sign,
+                   dest = dest)
 
     dat$Psi_r_skeleton <- res$matskel
     dat$w10skel <- res$wskel

---FILE: src/stan_files/stanmarg.stan---
@@ -763,7 +763,7 @@ generated quantities { // these matrices are saved in the output but do not figu
   Theta_var = Theta_sd_free .* Theta_sd_free;
   Theta_x_cov = cor2cov(Theta_x_r, Theta_x_sd, Theta_x_r_free, w8skel, Ng);
   Theta_x_var = Theta_x_sd_free .* Theta_x_sd_free;
-  if (m > 0) {
+  if (m > 0 && len_free[10] > 0) {
     /* iden is created so that we can re-use cor2cov, even though
        we don't need to multiply to get covariances */
     matrix[m, m] iden[Ng];
@@ -772,7 +772,7 @@ generated quantities { // these matrices are saved in the output but do not figu
     }
     Psi_cov = cor2cov(PS, iden, P_r, w10skel, Ng);
   }
-  if (n > 0) {
+  if (n > 0 && len_free[12] > 0) {
     matrix[n, n] iden[Ng];
     for (g in 1:Ng) {
       iden[g] = diag_matrix(rep_vector(1, n));"
ecmerkle,blavaan,1e7fed3e1f3e6e27a0fd4b3b7c6081f0a570d271,ecmerkle,merklee@missouri.edu,2019-05-15T17:49:41Z,ecmerkle,merklee@missouri.edu,2019-05-15T17:49:41Z,fix issue with stanmarg priors on nu,R/stanmarg_data.R,False,True,True,False,2,1,3,"---FILE: R/stanmarg_data.R---
@@ -76,8 +76,9 @@ format_priors <- function(lavpartable, mat) {
   if (mat == ""nu"") {
     prisel <- prisel & (lavpartable$mat %in% c(mat, ""mean.x""))
   } else {
-    prisel <- prisel & (lavpartable$mat == mat) & (lavpartable$free > 0)
+    prisel <- prisel & (lavpartable$mat == mat)
   }
+  prisel <- prisel & (lavpartable$free > 0)
   thepris <- lavpartable$prior[prisel]
 
   if (length(thepris) > 0) {"
ecmerkle,blavaan,034d26721f5055fed28a6dd46041f2a0897ac694,ecmerkle,merklee@missouri.edu,2019-05-15T17:44:50Z,ecmerkle,merklee@missouri.edu,2019-05-15T17:44:50Z,fix stanmarg equality constraints involving covariance parms,R/lav_export_stanmarg.R;src/stan_files/stanmarg.stan,False,True,True,False,11,3,14,"---FILE: R/lav_export_stanmarg.R---
@@ -350,6 +350,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits) {
     es <- lapply(estmats, function(x){
       dmat <- x$theta
       diag(dmat) <- 1L
+      dmat[upper.tri(dmat)] <- 0L
       dmat}
       )
     
@@ -380,6 +381,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits) {
     es <- lapply(estmats, function(x){
       dmat <- x$cov.x
       diag(dmat) <- 1L
+      dmat[upper.tri(dmat)] <- 0L
       dmat}
       )
     
@@ -441,6 +443,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits) {
     es <- lapply(estmats, function(x){
       dmat <- x$psi
       diag(dmat) <- 1L
+      dmat[upper.tri(dmat)] <- 0L
       dmat}
       )
     

---FILE: src/stan_files/stanmarg.stan---
@@ -104,11 +104,16 @@ functions { // you can use these in R following `rstan::expose_stan_functions(""f
     vector[num_elements(free_elements)] out;
     int R = rows(to_matrix(cormat[1]));
     int C = cols(to_matrix(cormat[1]));
-    int pos = 1;
+    int pos = 1; // position of eq_skeleton
+    int freepos = 1; // position of free_elements
+    
     for (g in 1:ngrp) {
       for (c in 1:(R-1)) for (r in (c+1):R) {
-        if (cormat[g,r,c] != 0 && wskel[pos,1] == 0) {
-	  out[pos] = sdmat[g,r,r] * sdmat[g,c,c] * cormat[g,r,c];
+	if (cormat[g,r,c] != 0) {
+	  if (wskel[pos,1] == 0) {
+	    out[freepos] = sdmat[g,r,r] * sdmat[g,c,c] * cormat[g,r,c];
+	    freepos += 1;
+	  }
 	  pos += 1;
 	}
       }"
ecmerkle,blavaan,c1d8b93d88326092bbbdcaad06c7c95d30b9664a,ecmerkle,merklee@missouri.edu,2019-05-15T03:11:09Z,ecmerkle,merklee@missouri.edu,2019-05-15T03:11:09Z,fix sign restrictions with all dummy lvs,R/lav_export_stanmarg.R,False,True,True,False,5,2,7,"---FILE: R/lav_export_stanmarg.R---
@@ -80,15 +80,18 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, ...) {
   lvmat <- mat %in% c('Gamma', 'B', 'Psi_r')
   lammat <- grepl('Lambda', mat)
   sign <- matrix(0, len, 2 + lvmat)
-  if (std.lv & (lvmat | lammat)) {
+  if (std.lv & (lvmat | lammat) & length(ddd$sign) > 0) {
     if (lvmat) {
       lamfree <- ddd$free2
       lamsign <- ddd$sign
-      
+
       for (i in 1:length(free2)) {
         fpar <- which(free2[[i]] != 0, arr.ind = TRUE)
         if (nrow(fpar) > 0) {
           for (j in 1:nrow(fpar)) {
+            ## in case all loadings restricted to 0
+            if (all(lamfree[[i]][,fpar[j,2]] == 0L)) next
+            
             ## find sign-constrained loadings of the two lvs
             lampar1 <- lamfree[[i]][,fpar[j,2]]
             l1 <- min(lampar1[lampar1 != 0L])"
ecmerkle,blavaan,0b3ae7ba7f588773ba5df4f6992efcd037c28870,ecmerkle,merklee@missouri.edu,2019-05-15T03:00:06Z,ecmerkle,merklee@missouri.edu,2019-05-15T03:00:06Z,fix veclen problems in stanmarg,R/lav_export_stanmarg.R,False,True,True,False,21,11,32,"---FILE: R/lav_export_stanmarg.R---
@@ -213,8 +213,10 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits) {
     free2 <- c(free2, list(lambda = res$free))
     ptrows <- which(lavpartable$mat == ""lambda"" & lavpartable$free > 0)
     veclen <- length(ptrows)
-    nfree <- c(nfree, list(lambda = sum(res$wskel[1:veclen,1] == 0)))
-    freeparnums[ptrows[res$wskel[1:veclen,1] == 0]] <- 1:sum(res$wskel[1:veclen,1] == 0)
+    if (veclen > 0) {
+      nfree <- c(nfree, list(lambda = sum(res$wskel[1:veclen,1] == 0)))
+      freeparnums[ptrows[res$wskel[1:veclen,1] == 0]] <- 1:sum(res$wskel[1:veclen,1] == 0)
+    }
   } else {
     dat$Lambda_y_skeleton <- array(0, dim = c(Ng, 0, 0))
     dat$w1skel <- matrix(0, 0, 2)
@@ -241,8 +243,10 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits) {
     free2 <- c(free2, list(gamma = res$free))
     ptrows <- which(lavpartable$mat == ""gamma"" & lavpartable$free > 0)
     veclen <- length(ptrows)
-    nfree <- c(nfree, list(gamma = sum(res$wskel[1:veclen,1] == 0)))
-    freeparnums[ptrows[res$wskel[1:veclen,1] == 0]] <- 1:sum(res$wskel[1:veclen,1] == 0)
+    if (veclen > 0) {
+      nfree <- c(nfree, list(gamma = sum(res$wskel[1:veclen,1] == 0)))
+      freeparnums[ptrows[res$wskel[1:veclen,1] == 0]] <- 1:sum(res$wskel[1:veclen,1] == 0)
+    }
   } else {
     dat$Gamma_skeleton <- array(0, dim = c(Ng, dim(dat$Lambda_y_skeleton)[3], 0))
     dat$w3skel <- matrix(0, 0, 2)
@@ -262,14 +266,16 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits) {
     free2 <- c(free2, list(beta = res$free))
     ptrows <- which(lavpartable$mat == ""beta"" & lavpartable$free > 0)
     veclen <- length(ptrows)
-    nfree <- c(nfree, list(beta = sum(res$wskel[1:veclen,1] == 0)))
-    freeparnums[ptrows[res$wskel[1:veclen,1] == 0]] <- 1:sum(res$wskel[1:veclen,1] == 0)
+    if (veclen > 0) {
+      nfree <- c(nfree, list(beta = sum(res$wskel[1:veclen,1] == 0)))
+      freeparnums[ptrows[res$wskel[1:veclen,1] == 0]] <- 1:sum(res$wskel[1:veclen,1] == 0)
+    }
   } else {
     dat$B_skeleton <- array(0, dim = c(Ng, dim(dat$Lambda_y_skeleton)[3], 0))
     dat$w4skel <- matrix(0, 0, 2)
     dat$b_sign <- matrix(0, 0, 3)
   }
-  
+
   ## 5. diag(Theta)
   if (""theta"" %in% names(freemats[[1]])) {
     fr <- lapply(freemats, function(x){
@@ -291,8 +297,10 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits) {
     free2 <- c(free2, list(dtheta = res$free))
     ptrows <- with(lavpartable, which(mat == ""theta"" & free > 0 & row == col))
     veclen <- length(ptrows)
-    nfree <- c(nfree, list(theta = sum(res$wskel[1:veclen,1] == 0)))
-    freeparnums[ptrows[res$wskel[1:veclen,1] == 0]] <- 1:sum(res$wskel[1:veclen,1] == 0)
+    if (veclen > 0) {
+      nfree <- c(nfree, list(theta = sum(res$wskel[1:veclen,1] == 0)))
+      freeparnums[ptrows[res$wskel[1:veclen,1] == 0]] <- 1:sum(res$wskel[1:veclen,1] == 0)
+    }
   } else {
     dat$Theta_skeleton <- array(0, dim = c(Ng, 0, 0))
     dat$w5skel <- matrix(0, 0, 2)
@@ -319,8 +327,10 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits) {
     free2 <- c(free2, list(cov.x = res$free))
     ptrows <- with(lavpartable, which(mat == ""cov.x"" & free > 0 & row == col))
     veclen <- length(ptrows)
-    nfree <- c(nfree, list(cov.x = sum(res$wskel[1:veclen,1] == 0)))
-    freeparnums[ptrows[res$wskel[1:veclen,1] == 0]] <- 1:sum(res$wskel[1:veclen,1] == 0)    
+    if (veclen > 0) {
+      nfree <- c(nfree, list(cov.x = sum(res$wskel[1:veclen,1] == 0)))
+      freeparnums[ptrows[res$wskel[1:veclen,1] == 0]] <- 1:sum(res$wskel[1:veclen,1] == 0)
+    }
   } else {
     dat$Theta_x_skeleton <- array(0, dim = c(Ng, 0, 0))
     dat$w6skel <- matrix(0, 0, 2)"
ecmerkle,blavaan,7a587b572c8f374da56cbce31cc69b492fe7c73b,ecmerkle,merklee@missouri.edu,2019-05-14T19:27:46Z,ecmerkle,merklee@missouri.edu,2019-05-14T19:27:46Z,fix stanmarg coeffun,R/lav_export_stanmarg.R,False,True,True,False,10,2,12,"---FILE: R/lav_export_stanmarg.R---
@@ -50,10 +50,18 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, ...) {
     freemat <- do.call(""rbind"", free)
     free2mat <- do.call(""rbind"", free2)
     for (i in 1:NROW(constraint)) {
+
       usecon <- c(any(freemat == constraint$lhs[i]),
                   any(freemat == constraint$rhs[i]))
       if (sum(usecon) == 2) {
         lhsnum <- free2mat[freemat == constraint$lhs[i]]
+
+        ## lhs may also be equality constrained, need to find
+        ## the first occurrence
+        while (wskel[lhsnum, 1] == 1) {
+          lhsnum <- wskel[lhsnum, 2]
+        }
+        
         rhsnum <- free2mat[freemat == constraint$rhs[i]]
         constraint$rhs2 <- rhsnum ## for sign constraints below
 
@@ -650,8 +658,8 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, fun = ""
         eqconst <- tmpw[,2][tmpw[,1] == 1]
         rowvec[tmpw[,1] == 1] <- rowvec[tmpw[,1] == 0][eqconst]
         rowvec2[tmpw[,1] == 1] <- rowvec2[tmpw[,1] == 0][eqconst]
-        parvec[tmpw[,1] == 1] <- parvec[eqconst]
-        tmpsd[tmpw[,1] == 1] <- tmpsd[eqconst]
+        parvec[tmpw[,1] == 1] <- parvec[tmpw[,1] == 0][eqconst]
+        tmpsd[tmpw[,1] == 1] <- tmpsd[tmpw[,1] == 0][eqconst]
 
         rowidx[parnums] <- rowvec
         rowidx2[parnums] <- rowvec2"
ecmerkle,blavaan,4b73cb7fb10a42675a80af47db491c1cc1f05707,ecmerkle,merklee@missouri.edu,2019-05-09T03:20:39Z,ecmerkle,merklee@missouri.edu,2019-05-09T03:20:39Z,fix stanmarg priors and inits,R/lav_export_stanmarg.R;R/stanmarg_data.R,False,True,True,False,15,6,21,"---FILE: R/lav_export_stanmarg.R---
@@ -493,19 +493,28 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits) {
   }
 
   ## add priors by using set_stanpars() from classic approach
+  ## needs some partable mods
   lavpartable$rhoidx <- rep(0, length(lavpartable$mat))
   if (!(""prior"" %in% names(lavpartable))) lavpartable$prior <- rep("""", length(lavpartable$mat))
   offd <- with(lavpartable, mat == ""theta"" & row != col)
   lavpartable$mat[offd] <- ""rho""
   offd <- with(lavpartable, mat == ""psi"" & row != col)
   lavpartable$mat[offd] <- ""lvrho""
 
-  stanprires <- set_stanpars("""", lavpartable, free2, dp, """")
+  prifree <- free2
+  prinames <- names(prifree)
+  mapping <- c(theta = ""dtheta"", psi = ""dpsi"", rho = ""rtheta"",
+               lvrho = ""rpsi"")
+  prich <- prinames %in% mapping
+  primap <- match(prinames[prich], mapping)
+  names(prifree)[prich] <- names(mapping)[primap]
+  
+  stanprires <- set_stanpars("""", lavpartable, prifree, dp, """")
   lavpartable$prior <- stanprires$partable$prior
-
+  
   ## add inits (manipulate partable to re-use set_inits_stan)
   lavpartable$freeparnums <- freeparnums
-
+  
   ## FIXME theta_x, cov.x not handled
   if (!(inits %in% c(""jags"", ""stan""))) {
     ini <- set_inits_stan(lavpartable, nfree, n.chains, inits)

---FILE: R/stanmarg_data.R---
@@ -35,7 +35,7 @@ format_priors <- function(lavpartable, mat) {
   } else {
     prisel <- rep(TRUE, length(lavpartable$row))
   }
-  
+
   if (mat == ""nu"") {
     prisel <- prisel & (lavpartable$mat %in% c(mat, ""mean.x""))
   } else {
@@ -56,8 +56,8 @@ format_priors <- function(lavpartable, mat) {
       param2 <- rep(NA, length(param1))
     }
 
-    param1 <- as.numeric(param1)
-    param2 <- as.numeric(param2)
+    param1 <- array(as.numeric(param1), length(param1))
+    param2 <- array(as.numeric(param2), length(param2))
   } else {
     param1 <- array(0,0)
     param2 <- array(0,0)"
ecmerkle,blavaan,dcebd80def15b1affb0163c09360b951ffddbefd,ecmerkle,merklee@missouri.edu,2019-05-08T20:43:32Z,ecmerkle,merklee@missouri.edu,2019-05-08T20:43:32Z,fix partable mats for inits/priors,R/lav_export_stanmarg.R,False,True,True,False,6,8,14,"---FILE: R/lav_export_stanmarg.R---
@@ -184,7 +184,7 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits) {
   lavpartable <- parTable(lavobject)
   lavpartable <- lavMatrixRepresentation(lavpartable, add.attributes = TRUE)
   freeparnums <- rep(0, length(lavpartable$free))
-  
+
   ## 1. Lambda_y
   if (""lambda"" %in% names(freemats[[1]])) {
     fr <- lapply(freemats, function(x) x$lambda)
@@ -495,19 +495,17 @@ lav2stanmarg <- function(lavobject, dp, n.chains, inits) {
   ## add priors by using set_stanpars() from classic approach
   lavpartable$rhoidx <- rep(0, length(lavpartable$mat))
   if (!(""prior"" %in% names(lavpartable))) lavpartable$prior <- rep("""", length(lavpartable$mat))
-  covpars <- with(lavpartable, mat %in% c(""theta"", ""psi"") &
-                               row != col)
-  lavpartable$mat[covpars] <- ""rho""
+  offd <- with(lavpartable, mat == ""theta"" & row != col)
+  lavpartable$mat[offd] <- ""rho""
+  offd <- with(lavpartable, mat == ""psi"" & row != col)
+  lavpartable$mat[offd] <- ""lvrho""
 
   stanprires <- set_stanpars("""", lavpartable, free2, dp, """")
   lavpartable$prior <- stanprires$partable$prior
 
   ## add inits (manipulate partable to re-use set_inits_stan)
   lavpartable$freeparnums <- freeparnums
-  offd <- with(lavpartable, mat == ""theta"" & row != col)
-  lavpartable$mat[offd] <- ""rho""
-  offd <- with(lavpartable, mat == ""psi"" & row != col)
-  lavpartable$mat[offd] <- ""lvrho""
+
   ## FIXME theta_x, cov.x not handled
   if (!(inits %in% c(""jags"", ""stan""))) {
     ini <- set_inits_stan(lavpartable, nfree, n.chains, inits)"
ecmerkle,blavaan,cd84bf90ada52680492fe15bc4be8e6b16b885a1,ecmerkle,merklee@missouri.edu,2019-05-04T18:48:38Z,ecmerkle,merklee@missouri.edu,2019-05-04T18:48:38Z,progress towards fixing parameter indexing problems,R/blavaan.R;R/lav_export_stanmarg.R;R/stanmarg_data.R;src/stan_files/stanmarg.stan,False,True,True,False,156,140,296,"---FILE: R/blavaan.R---
@@ -423,6 +423,7 @@ blavaan <- function(...,  # default lavaan arguments
                                               sd_Gamma_small = 2, sd_B_small = 2,
                                               theta_sd_rate = .5, theta_x_sd_rate = .5))
                     jagtrans <- try(do.call(""stanmarg_data"", ldargs), silent = TRUE)
+browser()
                     jagtrans <- list(data = jagtrans, monitors = c(""ly_sign"",
                                            ""lx_sign"",
                                            ""bet_sign"", ""g_sign"",
@@ -433,7 +434,7 @@ blavaan <- function(...,  # default lavaan arguments
                                            ""Nu_free"", ""Alpha_free"",
                                            ""eta""))
                 } else {
-                    jagtrans <- l2s$dat
+                    jagtrans <- l2s
                 }  
             }
         }

---FILE: R/lav_export_stanmarg.R---
@@ -58,11 +58,16 @@ matattr <- function(free, est, constraint, mat, Ng, std.lv, ...) {
         stop(""blavaan ERROR: cross-matrix equality constraints not supported."")
       }
     }
-  }
 
+    ## wskel[,2] must refer to only free parameters, skipping over
+    ## constrained parameters
+    freepars <- cumsum(wskel[,1] == 0)
+    wskel[wskel[,1]==1,2] <- freepars[wskel[wskel[,1]==1,2]]
+  }
+  
   lvmat <- mat %in% c('Gamma', 'B', 'Psi_r')
   lammat <- grepl('Lambda', mat)
-  sign <- matrix(1, Ng * len, 2 + lvmat)
+  sign <- matrix(0, Ng * len, 2 + lvmat)
   if (std.lv & (lvmat | lammat)) {
     if (lvmat) {
       lamfree <- ddd$free2
@@ -125,10 +130,10 @@ lav2stanmarg <- function(lavobject) {
     dat$miss <- 1L
     Mp <- lavobject@Data@Mp
     cases <- lapply(Mp, function(x) do.call(""c"", x$case.idx))
-    misgrps <- sapply(Mp, function(x) x$freq)
-    if (length(misgrps) > 1) {
-      misgrps <- do.call(""c"", misgrps)
-    }
+    misgrps <- lapply(Mp, function(x) x$freq)
+#   if (length(misgrps) > 1) {
+    misgrps <- do.call(""c"", misgrps)
+#   }
     misgrps <- rep(1:length(misgrps), misgrps)
     npatt <- sapply(Mp, function(x) NROW(x$pat))
     dat$startrow <- tapply(1:NROW(misgrps), misgrps, head, 1)
@@ -525,7 +530,7 @@ coeffun_stanmarg <- function(lavpartable, lavfree, free2, lersdat, rsob, fun = ""
       } else {
         tmpw <- NULL
       }
-if(sum(tmpw[,1]==0) != length(grep(stanvec[j], names(b.est)))) browser()
+
       if(NROW(tmpw) > 0){
         ## need rowvec & rowvec2 because stan summary rows
         ## ordered differently from stan draws rows

---FILE: R/stanmarg_data.R---
@@ -361,13 +361,13 @@ stanmarg_data <- function(YX = NULL, S = NULL, N, Ng, grpnum, # data
   pris <- format_priors(Alpha_skeleton, dat$Ng, dat$w14skel, alpha_mn, alpha_sd)
   dat$alpha_mn <- pris[['p1']]; dat$alpha_sd <- pris[['p2']]
   dat$len_alph <- length(dat$alpha_mn)
-  
+
   stopifnot(length(theta_sd_rate) == 1L || length(theta_sd_rate) == (dat$Ng * dat$p - sum(dat$w5skel[,1] == 1L)))
-  if (length(theta_sd_rate) == 1L) dat$theta_sd_rate <- rep(theta_sd_rate, dat$Ng * (dat$p - sum(dat$w5skel[,1] == 1L)))
+  if (length(theta_sd_rate) == 1L) dat$theta_sd_rate <- rep(theta_sd_rate, dat$Ng * dat$p - sum(dat$w5skel[,1] == 1L))
   else dat$theta_sd_rate <- as.numeric(theta_sd_rate)
 
   stopifnot(length(theta_x_sd_rate) == 1L   || length(theta_x_sd_rate) == (dat$Ng * dat$q - sum(dat$w6skel[,1] == 1L)))
-  if (length(theta_x_sd_rate) == 1L) dat$theta_x_sd_rate <- rep(theta_x_sd_rate, dat$Ng * (dat$q - sum(dat$w6skel[,1] == 1L)))
+  if (length(theta_x_sd_rate) == 1L) dat$theta_x_sd_rate <- rep(theta_x_sd_rate, dat$Ng * dat$q - sum(dat$w6skel[,1] == 1L))
   else dat$theta_x_sd_rate <- as.numeric(theta_x_sd_rate)
   
   return(dat)

---FILE: src/stan_files/stanmarg.stan---
@@ -11,19 +11,22 @@ functions { // you can use these in R following `rstan::expose_stan_functions(""f
       other: if output element is fixed to that number
     @return matrix of coefficients
   */
-  matrix fill_matrix(vector free_elements, matrix skeleton, int[,] eq_skeleton, int pos_start) {
+  matrix fill_matrix(vector free_elements, matrix skeleton, int[,] eq_skeleton, int pos_start, int spos_start) {
     int R = rows(skeleton);
     int C = cols(skeleton);
     matrix[R, C] out;
 
-    int pos = pos_start;
+    int pos = spos_start; // position of eq_skeleton
+    int freepos = pos_start; // position of free_elements
     int eqelem = 0;
+    
     for (c in 1:C) for (r in 1:R) {
       real rc = skeleton[r, c];
       if (is_inf(rc)) { // free
 	real eq = eq_skeleton[pos, 1];
 	if (eq == 0) {
-	  out[r,c] = free_elements[pos];
+	  out[r,c] = free_elements[freepos];
+	  freepos += 1;
 	} else {
 	  eqelem = eq_skeleton[pos, 2];
 	  out[r,c] = free_elements[eqelem];
@@ -298,21 +301,6 @@ transformed data { // (re)construct skeleton matrices in Stan (not that interest
 
   matrix[m, m] I = diag_matrix(rep_vector(1, m));
 
-  int len_free1 = 0;
-  int len_free2 = 0;
-  int len_free3 = 0;
-  int len_free4 = 0;
-  int len_free5 = 0;
-  int len_free6 = 0;
-  int len_free7 = 0;
-  int len_free8 = 0;
-  int len_free9 = 0;
-  int len_free10 = 0;
-  int len_free11 = 0;
-  int len_free12 = 0;
-  int len_free13 = 0;
-  int len_free14 = 0;
-
   int g_start1[Ng];
   int g_start2[Ng];
   int g_start3[Ng];
@@ -328,182 +316,204 @@ transformed data { // (re)construct skeleton matrices in Stan (not that interest
   int g_start13[Ng];
   int g_start14[Ng];
 
-  int pos;
+  int f_start1[Ng];
+  int f_start2[Ng];
+  int f_start3[Ng];
+  int f_start4[Ng];
+  int f_start5[Ng];
+  int f_start6[Ng];
+  int f_start7[Ng];
+  int f_start8[Ng];
+  int f_start9[Ng];
+  int f_start10[Ng];
+  int f_start11[Ng];
+  int f_start12[Ng];
+  int f_start13[Ng];
+  int f_start14[Ng];
+  
+  int len_free[14];
+  int pos[14];
+
+  for (i in 1:14) {
+    len_free[i] = 0;
+    pos[i] = 1;
+  }
   
   for (g in 1:Ng) {
     // count free elements in Lambda_y_skeleton
-    pos = len_free1 + 1;
-    g_start1[g] = pos;
+    g_start1[g] = len_free[1] + 1;
+    f_start1[g] = pos[1];
     for (i in 1:p) {
       for (j in 1:m) {
         if (is_inf(Lambda_y_skeleton[i,j])) {
-	  if (w1skel[pos,1] == 0) len_free1 += 1;
-	  pos += 1;
+	  if (w1skel[pos[1],2] == 0) len_free[1] += 1;
+	  pos[1] += 1;
         }
       }
     }
 
     // same thing but for Lambda_x_skeleton
-    pos = len_free2 + 1;
-    g_start2[g] = pos;
+    g_start2[g] = len_free[2] + 1;
+    f_start2[g] = pos[2];
     for (i in 1:q) {
       for (j in 1:n) {
 	if (is_inf(Lambda_x_skeleton[i,j])) {
-	  if (w2skel[pos,2] == 0) len_free2 += 1;
-	  pos += 1;
+	  if (w2skel[pos[2],2] == 0) len_free[2] += 1;
+	  pos[2] += 1;
 	}
       }
     }
   
     // same thing but for Gamma_skeleton
-    pos = len_free3 + 1;
-    g_start3[g] = pos;
+    g_start3[g] = len_free[3] + 1;
+    f_start3[g] = pos[3];
     for (i in 1:m) {
       for (j in 1:n) {
 	if (is_inf(Gamma_skeleton[i,j])) {
-	  if (w3skel[pos,2] == 0) len_free3 += 1;
-	  pos += 1;
+	  if (w3skel[pos[3],2] == 0) len_free[3] += 1;
+	  pos[3] += 1;
 	}
       }
     }
 
     // same thing but for B_skeleton
-    pos = len_free4 + 1;
-    g_start4[g] = pos;
+    g_start4[g] = len_free[4] + 1;
+    f_start4[g] = pos[4];
     for (i in 1:m) {
       for (j in 1:m) {
 	if (is_inf(B_skeleton[i,j])) {
-	  if (w4skel[pos,2] == 0) len_free4 += 1;
-	  pos += 1;
+	  if (w4skel[pos[4],2] == 0) len_free[4] += 1;
+	  pos[4] += 1;
 	}
       }
     }
     
     // same thing but for Theta_skeleton
-    pos = len_free5 + 1;
-    g_start5[g] = pos;
+    g_start5[g] = len_free[5] + 1;
+    f_start5[g] = pos[5];
     for (i in 1:p) {
       if (is_inf(Theta_skeleton[i,i])) {
-	if (w5skel[pos,2] == 0) len_free5 += 1;
-	pos += 1;
+	if (w5skel[pos[5],2] == 0) len_free[5] += 1;
+	pos[5] += 1;
       }
     }
 
     // same thing but for Theta_x_skeleton
-    pos = len_free6 + 1;
-    g_start6[g] = pos;
+    g_start6[g] = len_free[6] + 1;
+    f_start6[g] = pos[6];
     for (i in 1:q) {
       if (is_inf(Theta_x_skeleton[i,i])) {
-	if (w6skel[pos,2] == 0) len_free6 += 1;
-	pos += 1;
+	if (w6skel[pos[6],2] == 0) len_free[6] += 1;
+	pos[6] += 1;
       }
     }
 
     // same thing but for Theta_r_skeleton
-    pos = len_free7 + 1;
-    g_start7[g] = pos;
+    g_start7[g] = len_free[7] + 1;
+    f_start7[g] = pos[7];
     for (i in 1:(p-1)) {
       for (j in (i+1):p) {
 	if (is_inf(Theta_r_skeleton[j,i])) {
-	  if (w7skel[pos,2] == 0) len_free7 += 1;
-	  pos += 1;
+	  if (w7skel[pos[7],2] == 0) len_free[7] += 1;
+	  pos[7] += 1;
 	}
       }
     }
 
     // same thing but for Theta_x_r_skeleton
-    pos = len_free8 + 1;
-    g_start8[g] = pos;
+    g_start8[g] = len_free[8] + 1;
+    f_start8[g] = pos[8];
     for (i in 1:(q-1)) {
       for (j in (i+1):q) {
 	if (is_inf(Theta_x_r_skeleton[j,i])) {
-	  if (w8skel[pos,2] == 0) len_free8 += 1;
-	  pos += 1;
+	  if (w8skel[pos[8],2] == 0) len_free[8] += 1;
+	  pos[8] += 1;
 	}
       }
     }
 
     // same thing but for Psi_skeleton
-    pos = len_free9 + 1;
-    g_start9[g] = pos;
+    g_start9[g] = len_free[9] + 1;
+    f_start9[g] = pos[9];
     for (i in 1:m) {
       if (is_inf(Psi_skeleton[i,i])) {
-	if (w9skel[pos,2] == 0) len_free9 += 1;
-	pos += 1;
+	if (w9skel[pos[9],2] == 0) len_free[9] += 1;
+	pos[9] += 1;
       }
     }
 
     // same thing but for Psi_r_skeleton
-    pos = len_free10 + 1;
-    g_start10[g] = pos;
+    g_start10[g] = len_free[10] + 1;
+    f_start10[g] = pos[10];
     for (i in 1:(m-1)) {
       for (j in (i+1):m) {
 	if (is_inf(Psi_r_skeleton[j,i])) {
-	  if (w10skel[pos,2] == 0) len_free10 += 1;
-	  pos += 1;
+	  if (w10skel[pos[10],2] == 0) len_free[10] += 1;
+	  pos[10] += 1;
 	}
       }
     }
 
     // same thing but for Phi_skeleton
-    pos = len_free11 + 1;
-    g_start11[g] = pos;
+    g_start11[g] = len_free[11] + 1;
+    f_start11[g] = pos[11];
     for (i in 1:n) {
       if (is_inf(Phi_skeleton[i,i])) {
-	if (w11skel[pos,2] == 0) len_free11 += 1;
-	pos += 1;
+	if (w11skel[pos[11],2] == 0) len_free[11] += 1;
+	pos[11] += 1;
       }
     }
 
     // same thing but for Phi_r_skeleton
-    pos = len_free12 + 1;
-    g_start12[g] = pos;
+    g_start12[g] = len_free[12] + 1;
+    f_start12[g] = pos[12];
     for (i in 1:(n-1)) {
       for (j in (i+1):n) {
 	if (is_inf(Phi_r_skeleton[j,i])) {
-	  if (w12skel[pos,2] == 0) len_free12 += 1;
-	  pos += 1;
+	  if (w12skel[pos[12],2] == 0) len_free[12] += 1;
+	  pos[12] += 1;
 	}
       }
     }
 
     // same thing but for Nu_skeleton
-    pos = len_free13 + 1;
-    g_start13[g] = pos;
+    // pos = len_free13 + 1;
+    g_start13[g] = len_free[13] + 1;
+    f_start13[g] = pos[13];
     for (i in 1:(p+q)) {
       if (is_inf(Nu_skeleton[i,1])) {
-	if (w13skel[pos,2] == 0) len_free13 += 1;
-	pos += 1;
+	if (w13skel[pos[13],2] == 0) len_free[13] += 1;
+	pos[13] += 1;
       }
     }
 
     // same thing but for Alpha_skeleton
-    pos = len_free14 + 1;
-    g_start14[g] = pos;
+    g_start14[g] = len_free[14] + 1;
+    f_start14[g] = pos[14];
     for (i in 1:(m+n)) {
       if (is_inf(Alpha_skeleton[i,1])) {
-	if (w14skel[pos,2] == 0) len_free14 += 1;
-	pos += 1;
+	if (w14skel[pos[14],2] == 0) len_free[14] += 1;
+	pos[14] += 1;
       }
     }
   }
 }
 parameters {
   // free elements (possibly with inequality constraints) for coefficient matrices
-  vector[len_free1] Lambda_y_free;
-  vector[len_free2] Lambda_x_free;
-  vector[len_free3] Gamma_free;
-  vector[len_free4] B_free;
-  vector<lower=0>[len_free5] Theta_sd_free;
-  vector<lower=0>[len_free6] Theta_x_sd_free;
-  vector<lower=0,upper=1>[len_free7] Theta_r_free; // to use beta prior
-  vector<lower=0,upper=1>[len_free8] Theta_x_r_free;
-  vector<lower=0>[len_free9] Psi_sd_free;
-  vector<lower=0,upper=1>[len_free10] Psi_r_free;
-  vector<lower=0>[len_free11] Phi_sd_free;
-  vector<lower=0,upper=1>[len_free12] Phi_r_free;
-  vector[len_free13] Nu_free;
-  vector[len_free14] Alpha_free;
+  vector[len_free[1]] Lambda_y_free;
+  vector[len_free[2]] Lambda_x_free;
+  vector[len_free[3]] Gamma_free;
+  vector[len_free[4]] B_free;
+  vector<lower=0>[len_free[5]] Theta_sd_free;
+  vector<lower=0>[len_free[6]] Theta_x_sd_free;
+  vector<lower=0,upper=1>[len_free[7]] Theta_r_free; // to use beta prior
+  vector<lower=0,upper=1>[len_free[8]] Theta_x_r_free;
+  vector<lower=0>[len_free[9]] Psi_sd_free;
+  vector<lower=0,upper=1>[len_free[10]] Psi_r_free;
+  vector<lower=0>[len_free[11]] Phi_sd_free;
+  vector<lower=0,upper=1>[len_free[12]] Phi_r_free;
+  vector[len_free[13]] Nu_free;
+  vector[len_free[14]] Alpha_free;
 }
 transformed parameters {
   matrix[p, m] Lambda_y[Ng];
@@ -531,32 +541,32 @@ transformed parameters {
 
   // Now fill them in
   for (g in 1:Ng) {
-    Lambda_y[g] = fill_matrix(Lambda_y_free, Lambda_y_skeleton, w1skel, g_start1[g]);
-    Lambda_x[g] = fill_matrix(Lambda_x_free, Lambda_x_skeleton, w2skel, g_start2[g]);
-    Gamma[g] = fill_matrix(Gamma_free, Gamma_skeleton, w3skel, g_start3[g]);
-    B[g] = fill_matrix(B_free, B_skeleton, w4skel, g_start4[g]);
-    Theta_sd[g] = fill_matrix(Theta_sd_free, Theta_skeleton, w5skel, g_start5[g]);
-    Theta_x_sd[g] = fill_matrix(Theta_x_sd_free, Theta_x_skeleton, w6skel, g_start6[g]);
-    T_r_lower[g] = fill_matrix(2*Theta_r_free - 1, Theta_r_skeleton, w7skel, g_start7[g]);
+    Lambda_y[g] = fill_matrix(Lambda_y_free, Lambda_y_skeleton, w1skel, g_start1[g], f_start1[g]);
+    Lambda_x[g] = fill_matrix(Lambda_x_free, Lambda_x_skeleton, w2skel, g_start2[g], f_start2[g]);
+    Gamma[g] = fill_matrix(Gamma_free, Gamma_skeleton, w3skel, g_start3[g], f_start3[g]);
+    B[g] = fill_matrix(B_free, B_skeleton, w4skel, g_start4[g], f_start4[g]);
+    Theta_sd[g] = fill_matrix(Theta_sd_free, Theta_skeleton, w5skel, g_start5[g], f_start5[g]);
+    Theta_x_sd[g] = fill_matrix(Theta_x_sd_free, Theta_x_skeleton, w6skel, g_start6[g], f_start6[g]);
+    T_r_lower[g] = fill_matrix(2*Theta_r_free - 1, Theta_r_skeleton, w7skel, g_start7[g], f_start7[g]);
     Theta_r[g] = T_r_lower[g] + transpose(T_r_lower[g]) - diag_matrix(rep_vector(1, p));
-    T_x_r_lower[g] = fill_matrix(2*Theta_x_r_free - 1, Theta_x_r_skeleton, w8skel, g_start8[g]);
+    T_x_r_lower[g] = fill_matrix(2*Theta_x_r_free - 1, Theta_x_r_skeleton, w8skel, g_start8[g], f_start8[g]);
     Theta_x_r[g] = T_x_r_lower[g] + transpose(T_x_r_lower[g]) - diag_matrix(rep_vector(1, q));
-    Nu[g] = fill_matrix(Nu_free, Nu_skeleton, w13skel, g_start13[g]);
-    Alpha[g] = fill_matrix(Alpha_free, Alpha_skeleton, w14skel, g_start14[g]);
+    Nu[g] = fill_matrix(Nu_free, Nu_skeleton, w13skel, g_start13[g], f_start13[g]);
+    Alpha[g] = fill_matrix(Alpha_free, Alpha_skeleton, w14skel, g_start14[g], f_start14[g]);
 
     Psi[g] = diag_matrix(rep_vector(0, m));
     PHI[g] = diag_matrix(rep_vector(0, n));
   
     if (m > 0) {
-      Psi_sd[g] = fill_matrix(Psi_sd_free, Psi_skeleton, w9skel, g_start9[g]);
-      Psi_r_lower[g] = fill_matrix(2*Psi_r_free - 1, Psi_r_skeleton, w10skel, g_start10[g]);
+      Psi_sd[g] = fill_matrix(Psi_sd_free, Psi_skeleton, w9skel, g_start9[g], f_start9[g]);
+      Psi_r_lower[g] = fill_matrix(2*Psi_r_free - 1, Psi_r_skeleton, w10skel, g_start10[g], f_start10[g]);
       Psi_r[g] = Psi_r_lower[g] + transpose(Psi_r_lower[g]) - diag_matrix(rep_vector(1, m));
       Psi[g] = quad_form_sym(Psi_r[g], Psi_sd[g]);
     }
 
     if (n > 0) {
-      Phi_sd[g] = fill_matrix(Phi_sd_free, Phi_skeleton, w11skel, g_start11[g]);
-      Phi_r_lower[g] = fill_matrix(2*Phi_r_free - 1, Phi_r_skeleton, w12skel, g_start12[g]);
+      Phi_sd[g] = fill_matrix(Phi_sd_free, Phi_skeleton, w11skel, g_start11[g], f_start11[g]);
+      Phi_r_lower[g] = fill_matrix(2*Phi_r_free - 1, Phi_r_skeleton, w12skel, g_start12[g], f_start12[g]);
       Phi_r[g] = Phi_r_lower[g] + transpose(Phi_r_lower[g]) - diag_matrix(rep_vector(1, n));
       PHI[g] = quad_form_sym(Phi_r[g], Phi_sd[g]);
     }
@@ -654,47 +664,47 @@ generated quantities { // these matrices are saved in the output but do not figu
   // matrix[Ntot, has_data ? n : 0] xi;
 
   // sign constraints and correlations
-  vector[len_free1] ly_sign;
+  vector[len_free[1]] ly_sign;
   matrix[p, m] L_Y[Ng];
-  vector[len_free2] lx_sign;
+  vector[len_free[2]] lx_sign;
   matrix[q, n] L_X[Ng];
-  vector[len_free3] g_sign;
+  vector[len_free[3]] g_sign;
   matrix[m, n] Gam[Ng];
-  vector[len_free4] bet_sign;
+  vector[len_free[4]] bet_sign;
   matrix[m, m] Bet[Ng];
   matrix[p, p] Theta[Ng];
   matrix[q, q] Theta_x[Ng];
   matrix[m, m] PSmat[Ng];
   matrix[m, m] PS[Ng];
   matrix[n, n] PHmat[Ng];
   matrix[n, n] PH[Ng];
-  vector[len_free7] Theta_cov;
-  vector[len_free5] Theta_var;
-  vector[len_free8] Theta_x_cov;
-  vector[len_free6] Theta_x_var;
-  vector[len_free10] P_r;
-  vector[len_free10] Psi_cov;
-  vector[len_free9] Psi_var;
-  vector[len_free12] Ph_r;
-  vector[len_free12] Ph_cov;
-  vector[len_free11] Ph_var;
+  vector[len_free[7]] Theta_cov;
+  vector[len_free[5]] Theta_var;
+  vector[len_free[8]] Theta_x_cov;
+  vector[len_free[6]] Theta_x_var;
+  vector[len_free[10]] P_r;
+  vector[len_free[10]] Psi_cov;
+  vector[len_free[9]] Psi_var;
+  vector[len_free[12]] Ph_r;
+  vector[len_free[12]] Ph_cov;
+  vector[len_free[11]] Ph_var;
 
   // first deal with sign constraints:
-  ly_sign = sign_constrain_load(Lambda_y_free, len_free1, lam_y_sign);
-  lx_sign = sign_constrain_load(Lambda_x_free, len_free2, lam_x_sign);
-  g_sign = sign_constrain_reg(Gamma_free, len_free3, gam_sign, Lambda_x_free, Lambda_y_free);
-  bet_sign = sign_constrain_reg(B_free, len_free4, b_sign, Lambda_y_free, Lambda_y_free);
-  P_r = sign_constrain_reg(2 * Psi_r_free - 1, len_free10, psi_r_sign, Lambda_y_free, Lambda_y_free);
-  Ph_r = sign_constrain_reg(2 * Phi_r_free - 1, len_free12, phi_r_sign, Lambda_x_free, Lambda_x_free);
+  ly_sign = sign_constrain_load(Lambda_y_free, len_free[1], lam_y_sign);
+  lx_sign = sign_constrain_load(Lambda_x_free, len_free[2], lam_x_sign);
+  g_sign = sign_constrain_reg(Gamma_free, len_free[3], gam_sign, Lambda_x_free, Lambda_y_free);
+  bet_sign = sign_constrain_reg(B_free, len_free[4], b_sign, Lambda_y_free, Lambda_y_free);
+  P_r = sign_constrain_reg(2 * Psi_r_free - 1, len_free[10], psi_r_sign, Lambda_y_free, Lambda_y_free);
+  Ph_r = sign_constrain_reg(2 * Phi_r_free - 1, len_free[12], phi_r_sign, Lambda_x_free, Lambda_x_free);
   
   for (g in 1:Ng) {
-    L_Y[g] = fill_matrix(ly_sign, Lambda_y_skeleton, w1skel, g_start1[g]);
+    L_Y[g] = fill_matrix(ly_sign, Lambda_y_skeleton, w1skel, g_start1[g], f_start1[g]);
 
-    L_X[g] = fill_matrix(lx_sign, Lambda_x_skeleton, w2skel, g_start2[g]);
+    L_X[g] = fill_matrix(lx_sign, Lambda_x_skeleton, w2skel, g_start2[g], f_start2[g]);
 
-    Gam[g] = fill_matrix(g_sign, Gamma_skeleton, w3skel, g_start3[g]);
+    Gam[g] = fill_matrix(g_sign, Gamma_skeleton, w3skel, g_start3[g], f_start3[g]);
 
-    Bet[g] = fill_matrix(bet_sign, B_skeleton, w4skel, g_start4[g]);
+    Bet[g] = fill_matrix(bet_sign, B_skeleton, w4skel, g_start4[g], f_start4[g]);
 
     Theta[g] = quad_form_sym(Theta_r[g], Theta_sd[g]);
 
@@ -703,12 +713,12 @@ generated quantities { // these matrices are saved in the output but do not figu
     }
 
     if (m > 0) {
-      PSmat[g] = fill_matrix(P_r, Psi_r_skeleton, w10skel, g_start10[g]);
+      PSmat[g] = fill_matrix(P_r, Psi_r_skeleton, w10skel, g_start10[g], f_start10[g]);
       PS[g] = quad_form_sym(PSmat[g] + transpose(PSmat[g]) - diag_matrix(rep_vector(1, m)), Psi_sd[g]);
     }
 
     if (n > 0) {
-      PHmat[g] = fill_matrix(Ph_r, Phi_r_skeleton, w12skel, g_start12[g]);
+      PHmat[g] = fill_matrix(Ph_r, Phi_r_skeleton, w12skel, g_start12[g], f_start12[g]);
       PH[g] = quad_form_sym(PHmat[g] + transpose(PHmat[g]) - diag_matrix(rep_vector(1, n)), Phi_sd[g]);
     }
     "
ecmerkle,blavaan,31be9e0ffb1ef5d5f331e83f0ddd875b9a2668c8,ecmerkle,merklee@missouri.edu,2019-04-30T13:20:39Z,ecmerkle,merklee@missouri.edu,2019-04-30T13:20:39Z,add error in blavInspect when do.fit=FALSE and ask for certain output,R/blav_object_inspect.R;R/blavaan.R,False,True,True,False,10,0,10,"---FILE: R/blav_object_inspect.R---
@@ -24,11 +24,18 @@ blavInspect <- function(blavobject, what, ...) {
                    ""postmedian"", ""hpd"", ""jagnames"", ""stannames"",
                    ""fscores"", ""lvs"", ""fsmeans"", ""lvmeans"", ""mcobj"")
 
+    ## blavwhats that don't require do.fit
+    blavnofit <- c(""start"", ""starting.values"", ""inits"", ""n.chains"", ""cp"", ""dp"",
+                   ""jagnames"", ""stannames"")
+  
     ## whats that are not handled
     nowhats <- c(""mi"", ""modindices"", ""modification.indices"",
                  ""wls.est"", ""wls.obs"", ""wls.v"")
 
     if(what %in% blavwhats){
+        if(!(what %in% blavnofit) & !blavobject@Options$do.fit){
+            stop(paste0(""blavaan ERROR: "", what, "" does not exist when do.fit = FALSE""))
+        }
         if(jagtarget){
             idx <- blavobject@ParTable$jagpnum
             idx <- idx[!is.na(idx)]

---FILE: R/blavaan.R---
@@ -256,6 +256,9 @@ blavaan <- function(...,  # default lavaan arguments
 
     # turn warnings back on by default
     LAV@Options$warn <- origwarn
+
+    # put original do.fit back
+    LAV@Options$do.fit <- jag.do.fit
   
     # check for conflicting mv names
     namecheck(LAV@Data@ov.names[[1]])"
ecmerkle,blavaan,092d7ec9f1326e32869b497c17ec50dbe0b091b5,ecmerkle,merklee@missouri.edu,2019-02-12T15:28:05Z,ecmerkle,merklee@missouri.edu,2019-02-12T15:28:05Z,fix tests,tests/blavaan_examples.R;tests/testthat/tests.blavaan.R,False,True,True,False,2,3,5,"---FILE: tests/blavaan_examples.R---
@@ -1,5 +1,4 @@
 ## short examples to test functionality
-if(FALSE){
 set.seed(341)
 
 x1 <- rnorm(100)
@@ -21,4 +20,4 @@ fitstan <- bsem(model, data=Data, fixed.x=TRUE, burnin=200,
 attr(fitstan@external$mcmcout, 'stanmodel') <- NULL
 
 save(list=c(""fitjags"", ""fitstan""), file=""../inst/testdata/sysdata.rda"")
-}
+

---FILE: tests/testthat/tests.blavaan.R---
@@ -13,7 +13,7 @@ test_that(""blavaan arguments"", {
   expect_error(bsem(model, data=Data, fixed.x=TRUE, seed=1))
 
   ## supply ordinals
-  expect_error(bsem(model, data=Data, fixed.x=TRUE, ordered=c(""y1"", ""x1"", adapt=2, burnin=2, sample=2)))
+  #expect_error(bsem(model, data=Data, fixed.x=TRUE, ordered=c(""y1"", ""x1"", adapt=2, burnin=2, sample=2)))
 
   ## unknown cp
   expect_error(bsem(model, data=Data, ov.cp=""blah"", fixed.x=TRUE))"
ecmerkle,blavaan,4227a8f8407ff07e22f7ad1edbe289bc8083383b,ecmerkle,merklee@missouri.edu,2019-01-22T16:25:23Z,ecmerkle,merklee@missouri.edu,2019-01-22T16:25:23Z,"fix bug in blavInspect(,""lvmeans"") when target=jags",R/blav_object_inspect.R,False,True,True,False,3,1,4,"---FILE: R/blav_object_inspect.R---
@@ -124,17 +124,19 @@ blavInspect <- function(blavobject, what, ...) {
             draws <- mcmc.list(draws)
 
             if(what %in% c(""lvmeans"", ""fsmeans"") | ""means"" %in% dotdotdot){
+                br <- TRUE
                 if(jagtarget){
                     summ <- blavobject@external$mcmcout$summaries
                     summname <- ""Mean""
+                    br <- FALSE
                 } else {
                     summ <- blavobject@external$stansumm
                     summname <- ""mean""
                 }
                 mnrows <- grep(""^eta"", rownames(summ))
 
                 draws <- matrix(summ[mnrows,summname], nsamp,
-                                length(mnrows)/nsamp, byrow=TRUE)[,1:nlv]
+                                length(mnrows)/nsamp, byrow=br)[,1:nlv]
             }
             draws
         } else if(what == ""n.chains""){"
ecmerkle,blavaan,77ad7dd80b05abf6ff6cd8d37c54c802c23e2c8a,ecmerkle,merklee@missouri.edu,2019-01-10T00:34:27Z,ecmerkle,merklee@missouri.edu,2019-01-10T00:34:27Z,fix postpred,R/postpred.R,False,True,True,False,1,0,1,"---FILE: R/postpred.R---
@@ -55,6 +55,7 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
                         lavsamplestats = lavsamplestats)
       lavmodel <- dataX$lavmod[[1]]
       dataX <- dataX[[1]]
+      dataeXo <- lavdata@eXo
 
       ## compute (i) X2 of generated data and model-implied
       ## moments, along with (ii) X2 of real data and model-implied"
ecmerkle,blavaan,f3e80fe81c51f1a8d3e5139ee1135a713c8e0319,ecmerkle,merklee@missouri.edu,2018-10-08T17:11:13Z,ecmerkle,merklee@missouri.edu,2018-10-08T17:11:13Z,"fix blavInspect(, ""start"") and add tests",R/blav_object_inspect.R;tests/testthat/tests.blavaanobject-methods.R,False,True,True,False,22,7,29,"---FILE: R/blav_object_inspect.R---
@@ -43,11 +43,7 @@ blavInspect <- function(blavobject, what, ...) {
         }
         labs <- lav_partable_labels(blavobject@ParTable, type = ""free"")
         if(what %in% c(""start"", ""starting.values"", ""inits"")){
-            if(jagtarget){
-                blavobject@external$mcmcout$inits
-            } else {
-                blavobject@external$inits
-            }
+            blavobject@external$inits
         } else if(what %in% c(""psrf"", ""ac.10"", ""neff"")){
             if(jagtarget){
                 mcmcsumm <- blavobject@external$mcmcout$summaries

---FILE: tests/testthat/tests.blavaanobject-methods.R---
@@ -3,8 +3,6 @@ test_that(""blavaan object methods work"", {
   if(requireNamespace(""rstan"", quietly = TRUE) &
      requireNamespace(""runjags"", quietly = TRUE)){
     load(system.file(""testdata"", ""sysdata.rda"", package=""blavaan""))
-    #fitj <- blavaan:::fitjags
-    #fits <- blavaan:::fitstan
 
     # classes
     expect_equal(class(fitjags@external), ""list"")
@@ -26,6 +24,27 @@ test_that(""blavaan object methods work"", {
     ## fitMeasures
     expect_equal(length(fitMeasures(fitjags)),
                  length(fitMeasures(fitstan)))
+
+    ## this is how summary() obtains its results, but have not figured out
+    ## how to get S4 methods to directly work in testthat
+    expect_equal(dim(parameterEstimates(fitjags)), c(10, 6))
+    expect_equal(dim(parameterEstimates(fitstan)), c(10, 6))
+
+    ## various blavInspect args
+    expect_equal(length(blavInspect(fitjags, 'psrf')),
+                 length(blavInspect(fitstan, 'psrf')))
+
+    expect_equal(length(blavInspect(fitjags, 'neff')),
+                 length(blavInspect(fitstan, 'neff')))
+
+    expect_equal(length(blavInspect(fitjags, 'mcmc')),
+                 length(blavInspect(fitstan, 'mcmc')))
+
+    expect_equal(length(blavInspect(fitjags, 'start')),
+                 length(blavInspect(fitstan, 'start')))
+
+    expect_equal(dim(blavInspect(fitjags, 'hpd')),
+                 dim(blavInspect(fitstan, 'hpd')))
   }
     
 })"
ecmerkle,blavaan,57710f1c73a28c23cc24abfcaa134bd1cbd51b04,ecmerkle,merklee@missouri.edu,2018-10-04T03:06:13Z,ecmerkle,merklee@missouri.edu,2018-10-04T03:06:13Z,fix Stan blavInspect() error,R/blav_object_inspect.R,False,True,True,False,6,2,8,"---FILE: R/blav_object_inspect.R---
@@ -34,8 +34,12 @@ blavInspect <- function(blavobject, what, ...) {
             idx <- idx[!is.na(idx)]
         } else {
             idx <- blavobject@ParTable$stansumnum
-            idx <- idx[blavobject@ParTable$free > 0 |
-                       grepl(""^def"", blavobject@ParTable$pxnames)]
+            if(""pxnames"" %in% names(blavobject@ParTable)){
+              drows <- grepl(""^def"", blavobject@ParTable$pxnames)
+            } else {
+              drows <- grepl(""def"", blavobject@ParTable$mat)
+            }
+            idx <- idx[blavobject@ParTable$free > 0 | drows]
         }
         labs <- lav_partable_labels(blavobject@ParTable, type = ""free"")
         if(what %in% c(""start"", ""starting.values"", ""inits"")){"
ecmerkle,blavaan,d75794875b251eb956116d3fd19c7efaa3e03209,ecmerkle,merklee@missouri.edu,2018-10-04T03:05:24Z,ecmerkle,merklee@missouri.edu,2018-10-04T03:05:24Z,attempt to solve 'rstan not installed' error,.travis.yml,False,False,False,False,5,1,6,"---FILE: .travis.yml---
@@ -1,7 +1,11 @@
 language: r
 cache: packages
 
-r_github_packages: yrosseel/lavaan
+r_packages:
+  - rstan
+
+r_github_packages:
+  - yrosseel/lavaan
 
 sudo: required
 warnings_are_errors: true"
ecmerkle,blavaan,3b444db75daa8af138df89567ae68c0c53e164e6,ecmerkle,merklee@missouri.edu,2018-10-04T02:29:47Z,ecmerkle,merklee@missouri.edu,2018-10-04T02:29:47Z,avoid travis errors for suggested packages,.travis.yml,False,False,False,False,4,0,4,"---FILE: .travis.yml---
@@ -6,6 +6,10 @@ r_github_packages: yrosseel/lavaan
 sudo: required
 warnings_are_errors: true
 
+env:
+  global:
+    - _R_CHECK_FORCE_SUGGESTS_=false
+
 addons:
   apt:
     packages:"
ecmerkle,blavaan,4d46e4333998924e1f5fed4560d5d5534490504a,ecmerkle,merklee@missouri.edu,2018-10-03T21:46:37Z,ecmerkle,merklee@missouri.edu,2018-10-03T21:46:37Z,fix error message and add test,R/blav_utils.R;tests/testthat/tests.blavaan.R,False,True,True,False,7,1,8,"---FILE: R/blav_utils.R---
@@ -465,7 +465,7 @@ namecheck <- function(ov.names){
     
     if(length(forbid.idx) > 0L){
         stop(""blavaan ERROR: the following variable names must be changed:\n"",
-             ""                   "", paste(forbidden[forbid.idx], collapse = "" ""))
+             ""                   "", paste(ov.names[forbid.idx], collapse = "" ""))
     }
 }
 

---FILE: tests/testthat/tests.blavaan.R---
@@ -31,4 +31,10 @@ test_that(""blavaan arguments"", {
   fit <- bsem(model, data=Data, fixed.x=TRUE, adapt=2,
               burnin=2, sample=2, do.fit=FALSE)
   expect_s4_class(fit, ""blavaan"")
+
+  ## named variable that clashes
+  names(Data)[1] <- ""lambda""
+  model2 <- ' lambda ~ b1*x1 + b2*x2 '
+  expect_error(bsem(model2, data=Data))
+              
 })"
ecmerkle,blavaan,56cf522ea99b9fd2cf26fd7d922e22dc3b416147,ecmerkle,merklee@missouri.edu,2018-10-03T21:40:53Z,ecmerkle,merklee@missouri.edu,2018-10-03T21:40:53Z,"fix error when test=""none"" and save.lvs=TRUE",R/blavaan.R,False,True,True,False,3,0,3,"---FILE: R/blavaan.R---
@@ -632,6 +632,9 @@ blavaan <- function(...,  # default lavaan arguments
       }
     } else {
       samplls <- NA
+      sampkls <- NA
+      csamplls <- NA
+      csampkls <- NA
     }
 
     timing$PostPred <- (proc.time()[3] - start.time)"
ecmerkle,blavaan,ede76e4df907198ace69566beca4f6a0c49c4b18,ecmerkle,merklee@missouri.edu,2018-09-10T19:22:09Z,ecmerkle,merklee@missouri.edu,2018-09-10T19:22:09Z,really fixed this time,inst/testdata/sysdata.rda,False,False,False,False,0,0,0,
ecmerkle,blavaan,73421439bbe2499c85f28bafd06557c68d5e0ac5,ecmerkle,merklee@missouri.edu,2018-09-10T19:11:34Z,ecmerkle,merklee@missouri.edu,2018-09-10T19:11:34Z,finally fix tests/install issues,.travis.yml;R/sysdata.rda;tests/testthat/tests.blavaan.R;tests/testthat/tests.blavaanobject-methods.R,False,True,True,False,10,8,18,"---FILE: .travis.yml---
@@ -4,7 +4,7 @@ cache: packages
 r_github_packages: yrosseel/lavaan
 
 sudo: required
-warnings_are_errors: false
+warnings_are_errors: true
 
 addons:
   apt:

---FILE: tests/testthat/tests.blavaan.R---
@@ -27,11 +27,8 @@ test_that(""blavaan arguments"", {
   ## equality constraint with multiple variables on lhs
   expect_error(bsem(model2, data=Data, fixed.x=TRUE))
 
-  ## do.fit=TRUE + FALSE
+  ## do.fit=FALSE
   fit <- bsem(model, data=Data, fixed.x=TRUE, adapt=2,
               burnin=2, sample=2, do.fit=FALSE)
   expect_s4_class(fit, ""blavaan"")
-  fit <- bsem(model, data=Data, fixed.x=TRUE, adapt=2,
-              burnin=2, sample=2, do.fit=TRUE)
-  expect_s4_class(fit, ""blavaan"")
 })

---FILE: tests/testthat/tests.blavaanobject-methods.R---
@@ -1,7 +1,12 @@
 test_that(""blavaan object methods work"", {
-  fitj <- blavaan:::fitjags
-  fits <- blavaan:::fitstan
 
-  expect_equal(fitjags@ParTable$free, fitstan@ParTable$free)
+  if(requireNamespace(""rstan"", quietly = TRUE) &
+     requireNamespace(""runjags"", quietly = TRUE)){
+    load(system.file(""testdata"", ""sysdata.rda"", package=""blavaan""))
+    #fitj <- blavaan:::fitjags
+    #fits <- blavaan:::fitstan
 
+    expect_equal(fitjags@ParTable$free, fitstan@ParTable$free)
+  }
+    
 })"
ecmerkle,blavaan,e385dd03f34fad6a3f5b54e50de2ea41ec212e5f,merkle,merklee@missouri.edu,2018-09-06T13:37:06Z,merkle,merklee@missouri.edu,2018-09-06T13:37:06Z,travis warnings are not errors for now,.travis.yml;tests/testthat/tests.blavaan.R,False,True,True,False,1,3,4,"---FILE: .travis.yml---
@@ -4,7 +4,7 @@ cache: packages
 r_github_packages: yrosseel/lavaan
 
 sudo: required
-warnings_are_errors: true
+warnings_are_errors: false
 
 addons:
   apt:

---FILE: tests/testthat/tests.blavaan.R---
@@ -34,6 +34,4 @@ test_that(""blavaan arguments"", {
   fit <- bsem(model, data=Data, fixed.x=TRUE, adapt=2,
               burnin=2, sample=2, do.fit=TRUE)
   expect_s4_class(fit, ""blavaan"")
-  unloadNamespace(""runjags"")
-  unloadNamespace(""rstan"")
 })"
ecmerkle,blavaan,34a517197f7154d10ddf7d37ac66f6b748dcca55,ecmerkle,merklee@missouri.edu,2018-08-02T03:24:44Z,ecmerkle,merklee@missouri.edu,2018-08-02T03:24:44Z,fix do.fit=TRUE (thanks to Esteban Montenegro),DESCRIPTION;R/blavaan.R,False,True,True,False,5,3,8,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-3.353
+Version: 0.3-3.355
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blavaan.R---
@@ -161,8 +161,10 @@ blavaan <- function(...,  # default lavaan arguments
     jag.do.fit <- TRUE
     if(""do.fit"" %in% dotNames){
         jag.do.fit <- dotdotdot$do.fit
-        burnin <- 0
-        sample <- 0
+        if(!jag.do.fit){
+            burnin <- 0
+            sample <- 0
+        }
     }
     if(""warn"" %in% dotNames){
         origwarn <- dotdotdot$warn"
ecmerkle,blavaan,6e83bc4c62b50f1cf2b7506bd23dbe0de7eddd24,ecmerkle,merklee@missouri.edu,2018-07-02T15:01:15Z,ecmerkle,merklee@missouri.edu,2018-07-02T15:01:15Z,further fixes to blavInspect(),DESCRIPTION;R/blav_object_inspect.R,False,True,True,False,11,5,16,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-3.352
+Version: 0.3-3.353
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blav_object_inspect.R---
@@ -39,7 +39,11 @@ blavInspect <- function(blavobject, what, ...) {
         }
         labs <- lav_partable_labels(blavobject@ParTable, type = ""free"")
         if(what %in% c(""start"", ""starting.values"", ""inits"")){
-            blavobject@external$mcmcout$inits
+            if(jagtarget){
+                blavobject@external$mcmcout$inits
+            } else {
+                blavobject@external$inits
+            }
         } else if(what %in% c(""psrf"", ""ac.10"", ""neff"")){
             if(jagtarget){
                 mcmcsumm <- blavobject@external$mcmcout$summaries
@@ -56,7 +60,7 @@ blavInspect <- function(blavobject, what, ...) {
                 if(jagtarget){
                     OUT <- mcmcsumm[idx,'AC.10']
                 } else {
-                    stop(""blavaan ERROR: autocorrelation stat currently unavailable for stan."")
+                    stop(""blavaan ERROR: autocorrelation stat currently unavailable for Stan."")
                 }
             } else {
                 if(jagtarget){
@@ -89,7 +93,7 @@ blavInspect <- function(blavobject, what, ...) {
             if(jagtarget){
                 etas <- any(blavobject@external$mcmcout$monitor == ""eta"")
             } else {
-                etas <- any(grepl(""eta"", rownames(blavobject@external$stansumm)))
+                etas <- any(grepl(""^eta"", rownames(blavobject@external$stansumm)))
             }
             if(!etas) stop(""blavaan ERROR: factor scores not saved; set save.lvs=TRUE"")
 
@@ -163,17 +167,19 @@ blavInspect <- function(blavobject, what, ...) {
                 if(jagtarget){
                     OUT <- mcmcsumm[idx,'Mode']
                 } else {
-                    stop(""blavaan ERROR: Modes unavailable for stan."")
+                    stop(""blavaan ERROR: Modes unavailable for Stan."")
                 }
             }
             if(add.labels) names(OUT) <- labs
             OUT
         } else if(what == ""jagnames""){
+            if(!jagtarget) stop(""blavaan ERROR: JAGS was not used for model estimation."")
             OUT <- blavobject@ParTable$pxnames[blavobject@ParTable$free > 0]
             OUT <- OUT[order(blavobject@ParTable$free[blavobject@ParTable$free > 0])]
             if(add.labels) names(OUT) <- labs
             OUT
         } else if(what == ""stannames""){
+            if(jagtarget) stop(""blavaan ERROR: Stan was not used for model estimation."")
             mcmcsumm <- rstan::summary(blavobject@external$mcmcout)$summary
             OUT <- rownames(mcmcsumm)[idx]
             if(add.labels) names(OUT) <- labs"
ecmerkle,blavaan,24fb18e4dc4afef0c6357eb9cd205758d2c3347f,ecmerkle,merklee@missouri.edu,2018-07-02T14:37:04Z,ecmerkle,merklee@missouri.edu,2018-07-02T14:37:04Z,fix small spacing issue,R/lav_export_stan.R,False,True,True,False,1,1,2,"---FILE: R/lav_export_stan.R---
@@ -892,7 +892,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     if(any(partable$mat == ""def"")){
       ndecs <- sum(partable$mat == ""def"" &
                    partable$group == 1)
-      tpdecs <- paste0(tpdecs, ""\n"", t1, ""real def["", ndecs, "", 1, "",
+      tpdecs <- paste0(tpdecs, ""\n"", t1, ""real def["", ndecs, "",1,"",
                        ngroups, ""];\n"")
     }
 "
ecmerkle,blavaan,ece6684dee5691f9937a3d57215cfb71212bb740,ecmerkle,merklee@missouri.edu,2018-07-02T02:49:04Z,ecmerkle,merklee@missouri.edu,2018-07-02T02:49:04Z,"and fix Stan regressions of lv on ov, when std.lv=TRUE",DESCRIPTION;R/lav_export_stan.R,False,True,True,False,13,3,16,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-3.349
+Version: 0.3-3.350
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_stan.R---
@@ -972,6 +972,11 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
                          partable$op == ""~"" &
                          !(partable$lhs %in% lvload) &
                          partable$group == k)
+          ## regressions of an ov on lv
+          reglv <- which(partable$lhs == lvload[i] &
+                         partable$op == ""~"" &
+                         !(partable$rhs %in% lvload) &
+                         partable$group == k)
 
           GQ <- paste0(GQ, t1, ""if(lambdaUNC["",
                        partable$row[tmpidx], "","", partable$col[tmpidx],
@@ -987,9 +992,14 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
                          ""betaUNC["", partable$row[regov], "","",
                          partable$col[regov], "","", k, ""];\n"")
           }
+          if(length(reglv) > 0){
+            GQ <- paste0(GQ, t2, ""beta["", partable$row[reglv], "","",
+                         partable$col[reglv], "","", k, ""] = -1 * "",
+                         ""betaUNC["", partable$row[reglv], "","",
+                         partable$col[reglv], "","", k, ""];\n"")
+          }
 
-          ## find regressions associated with this lv, they need
-          ## sign changes too
+          ## find lv-on-lv regressions, they need sign changes too
           regidx <- which(partable$rhs == lvload[i] &
                           partable$op == ""~"" &
                           partable$lhs %in% lvload &"
ecmerkle,blavaan,231c628e00a834609c523eee871fb75798671d7f,ecmerkle,merklee@missouri.edu,2018-06-29T16:01:48Z,ecmerkle,merklee@missouri.edu,2018-06-29T16:01:48Z,"fix Stan regressions of ov on lv, when std.lv=TRUE",DESCRIPTION;R/lav_export_stan.R,False,True,True,False,13,2,15,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-3.348
+Version: 0.3-3.349
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_stan.R---
@@ -275,7 +275,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
                   partable$op == ""~~"" &
                   partable$lhs == partable$rhs &
                   partable$group == 1 &
-                  partable$mat == ""psi"")
+                  grepl(""psi"", partable$mat))
   n.psi.ov <- length(psi.ov)
   ny <- nov - n.psi.ov
   if(n.psi.ov > 0){
@@ -967,6 +967,11 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
           tmpidx <- which(partable$lhs == lvload[i] &
                           partable$op == ""=~"" &
                           partable$group == k)[1]
+          ## regressions of the lv on ov
+          regov <- which(partable$rhs == lvload[i] &
+                         partable$op == ""~"" &
+                         !(partable$lhs %in% lvload) &
+                         partable$group == k)
 
           GQ <- paste0(GQ, t1, ""if(lambdaUNC["",
                        partable$row[tmpidx], "","", partable$col[tmpidx],
@@ -976,6 +981,12 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
                        k, ""]));\n"")
           GQ <- paste0(GQ, t2, ""eta[,"", partable$col[tmpidx],
                        ""] = to_vector(-1 * etaUNC[,"", partable$col[tmpidx], ""]);\n"")
+          if(length(regov) > 0){
+            GQ <- paste0(GQ, t2, ""beta["", partable$row[regov], "","",
+                         partable$col[regov], "","", k, ""] = -1 * "",
+                         ""betaUNC["", partable$row[regov], "","",
+                         partable$col[regov], "","", k, ""];\n"")
+          }
 
           ## find regressions associated with this lv, they need
           ## sign changes too"
ecmerkle,blavaan,d00a6b1435798c6ddad7a97feb14188ccf44a347,ecmerkle,merklee@missouri.edu,2018-05-29T02:55:47Z,ecmerkle,merklee@missouri.edu,2018-05-29T02:55:47Z,error on multilevel models,R/blavaan.R,False,True,True,False,2,1,3,"---FILE: R/blavaan.R---
@@ -44,8 +44,9 @@ blavaan <- function(...,  # default lavaan arguments
         }
     }
 
-    # ordinal functionality not available
+    # ordinal/multilevel functionality not available
     if(""ordered"" %in% dotNames) stop(""blavaan ERROR: models with ordered variables are not yet available."")
+    if(""cluster"" %in% dotNames) stop(""blavaan ERROR: two-level models are not yet available."")
   
     # ensure rstan/runjags are here. if target is not installed but
     # the other is, then use the other instead."
ecmerkle,blavaan,f92237a19c1fdf6f4ed1789109202f56ab3d96c2,ecmerkle,merklee@missouri.edu,2018-05-22T16:43:34Z,ecmerkle,merklee@missouri.edu,2018-05-22T16:43:34Z,throw error if ordered variables are supplied,R/blavaan.R,False,True,True,False,3,0,3,"---FILE: R/blavaan.R---
@@ -44,6 +44,9 @@ blavaan <- function(...,  # default lavaan arguments
         }
     }
 
+    # ordinal functionality not available
+    if(""ordered"" %in% dotNames) stop(""blavaan ERROR: models with ordered variables are not yet available.""
+  
     # ensure rstan/runjags are here. if target is not installed but
     # the other is, then use the other instead.
     if(target == ""stan""){"
ecmerkle,blavaan,72314c746a45552b52dbaca2490efd3585b4ed07,ecmerkle,merklee@missouri.edu,2018-04-23T03:12:15Z,ecmerkle,merklee@missouri.edu,2018-04-23T03:12:15Z,further fixes to ppp with missing x.idx variables,R/postpred.R,False,True,True,False,23,13,36,"---FILE: R/postpred.R---
@@ -40,12 +40,6 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
     
     origlavmodel <- lavmodel
     origlavdata <- lavdata
-    ## get rid of completely missing
-    for(g in 1:lavsamplestats@ngroups){
-      if(length(origlavdata@Mp[[g]]$empty.idx) > 0){
-        origlavdata@X[[g]] <- origlavdata@X[[g]][-origlavdata@Mp[[g]]$empty.idx,,drop=FALSE]
-      }
-    }
 
     ## check for missing, to see if we can easily get baseline ll for chisq
     mis <- FALSE
@@ -84,18 +78,29 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
                                                                       sqrt=sigchol,
                                                                       mean=x)))
             } else {
-              ## condition only on observed x values; to be revised after
+              ## condition only on observed x values; to be re-examined after
               ## lav_mvnorm_missing_loglik_samplestats handles x.idx
               M <- lavsamplestats@missing[[g]]
               Mp <- lavdata@Mp[[g]]
               for(p in 1:length(M)){
                 var.idx <- M[[p]][[""var.idx""]]
-                obsx <- which(x.idx %in% var.idx)
+                obsx <- x.idx[var.idx[x.idx]]
+
+                ## could also generate missing x's, but has no
+                ## impact
+                ##misx <- x.idx[!var.idx[x.idx]]
+                ##if(length(misx) > 0){
+                ##  dataX[[g]][Mp$case.idx[[p]],misx] <- mnormt::rmnorm(n = M[[p]]$freq,
+                ##                                         varcov = Sigma.hat[[g]][misx,misx],
+                ##                                         mean = Mu.hat[[g]][misx,])
+                ##  obsx <- x.idx
+                ##}
+                  
                 if(length(obsx) > 0){
-                  xp.idx <- x.idx[obsx]
+                  xp.idx <- obsx
                   tm1 <- Sigma.hat[[g]][nox,xp.idx] %*% solve(Sigma.hat[[g]][xp.idx,xp.idx])
                   cmu <- Mu.hat[[g]][nox,] +
-                    tm1 %*% apply(origlavdata@X[[g]][,xp.idx,drop=FALSE], 1,
+                    tm1 %*% apply(origlavdata@X[[g]][Mp$case.idx[[p]],xp.idx,drop=FALSE], 1,
                                   function(x) (x - Mu.hat[[g]][xp.idx,]))
                   csig <- Sigma.hat[[g]][nox,nox] - tm1 %*% Sigma.hat[[g]][xp.idx,nox]
                   sigchol <- chol(csig)
@@ -108,7 +113,7 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
                   cmu <- Mu.hat[[g]][nox,]
                   csig <- Sigma.hat[[g]][nox,nox]
 
-                  dataX[[g]][Mp$case.idx[[p]],nox] <- as.matrix(mnormt::rmnorm(n = length(Mp$case.idx[[p]]),
+                  dataX[[g]][Mp$case.idx[[p]],nox] <- as.matrix(mnormt::rmnorm(n = M[[p]]$freq,
                                                                                varcov = csig,
                                                                                mean = cmu))
                 }
@@ -119,13 +124,18 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
             cmu <- Mu.hat[[g]]
             csig <- Sigma.hat[[g]]
 
-            dataX[[g]] <- as.matrix(mnormt::rmnorm(n = lavsamplestats@nobs[[g]],
+            dataX[[g]] <- as.matrix(mnormt::rmnorm(n = nrow(dataX[[g]]),
                                     varcov = csig, mean = cmu))
           }
 
           dataX[[g]][is.na(origlavdata@X[[g]])] <- NA
-        }
 
+          ## get rid of completely missing
+          if(length(origlavdata@Mp[[g]]$empty.idx) > 0){
+            dataX[[g]] <- dataX[[g]][-origlavdata@Mp[[g]]$empty.idx,,drop=FALSE]
+          }
+        }
+        
         ## compute (i) X2 of generated data and model-implied
         ## moments, along with (ii) X2 of real data and model-implied
         ## moments."
ecmerkle,blavaan,e29dee58d8f4ffe03e410b7c7fabf0e05d810c7a,ecmerkle,merklee@missouri.edu,2018-04-20T19:55:56Z,ecmerkle,merklee@missouri.edu,2018-04-20T19:55:56Z,fix postpred when we drop completely missing rows,DESCRIPTION;R/postpred.R,False,True,True,False,10,9,19,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-2.318
+Version: 0.3-2.319
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/postpred.R---
@@ -40,7 +40,12 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
     
     origlavmodel <- lavmodel
     origlavdata <- lavdata
-
+    ## get rid of completely missing
+    for(g in 1:lavsamplestats@ngroups){
+      if(length(origlavdata@Mp[[g]]$empty.idx) > 0){
+        origlavdata@X[[g]] <- origlavdata@X[[g]][-origlavdata@Mp[[g]]$empty.idx,,drop=FALSE]
+      }
+    }
 
     ## check for missing, to see if we can easily get baseline ll for chisq
     mis <- FALSE
@@ -79,7 +84,8 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
                                                                       sqrt=sigchol,
                                                                       mean=x)))
             } else {
-              ## condition only on observed x values
+              ## condition only on observed x values; to be revised after
+              ## lav_mvnorm_missing_loglik_samplestats handles x.idx
               M <- lavsamplestats@missing[[g]]
               Mp <- lavdata@Mp[[g]]
               for(p in 1:length(M)){
@@ -106,8 +112,6 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
                                                                                varcov = csig,
                                                                                mean = cmu))
                 }
-
-
               }
             }
           } else {
@@ -118,11 +122,8 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
             dataX[[g]] <- as.matrix(mnormt::rmnorm(n = lavsamplestats@nobs[[g]],
                                     varcov = csig, mean = cmu))
           }
-  
+
           dataX[[g]][is.na(origlavdata@X[[g]])] <- NA
-          if(length(origlavdata@Mp[[g]]$empty.idx) > 0){
-            dataX[[g]] <- dataX[[g]][-origlavdata@Mp[[g]]$empty.idx,]
-          }
         }
 
         ## compute (i) X2 of generated data and model-implied"
ecmerkle,blavaan,d9ab73986c32bd3f9486bfbd1067542e571b3590,ecmerkle,merklee@missouri.edu,2018-04-04T20:03:14Z,ecmerkle,merklee@missouri.edu,2018-04-04T20:03:14Z,fix new postpred code to handle completely missing cases,DESCRIPTION;R/postpred.R,False,True,True,False,13,11,24,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-2.311
+Version: 0.3-2.315
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/postpred.R---
@@ -33,13 +33,22 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
     ## parallel across chains if we can
     ncores <- NA
     loop.comm <- ""lapply""
-    if(.Platform$OS.type != ""windows"" & requireNamespace(""parallel"", quietly = TRUE)){
+    if(FALSE){#.Platform$OS.type != ""windows"" & requireNamespace(""parallel"", quietly = TRUE)){
       ncores <- min(n.chains, parallel::detectCores())
       loop.comm <- ""mclapply""
     }
     
     origlavmodel <- lavmodel
     origlavdata <- lavdata
+
+    ## get completely missing observations out, or there
+    ## will be problems
+    for(g in 1:lavsamplestats@ngroups) {
+      allmis <- apply(is.na(origlavdata@X[[g]]), 1, all)
+      if(sum(allmis) > 0){
+        origlavdata@X[[g]] <- origlavdata@X[[g]][-which(allmis),,drop=FALSE]
+      }
+    }
   
     loop.args <- list(X = 1:n.chains, FUN = function(j){
       ind <- csdist <- csboots <- rep(NA, psamp)
@@ -78,14 +87,7 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
             csig <- Sigma.hat[[g]]
 
             dataX[[g]] <- as.matrix(mnormt::rmnorm(n = lavsamplestats@nobs[[g]],
-                                   varcov = csig, mean = cmu))
-          }
-
-          ## get completely missing observations out, or there
-          ## will be problems
-          allmis <- apply(is.na(origlavdata@X[[g]]), 1, all)
-          if(sum(allmis) > 0){
-            origlavdata@X[[g]] <- origlavdata@X[[g]][-which(allmis),]
+                                    varcov = csig, mean = cmu))
           }
   
           dataX[[g]][is.na(origlavdata@X[[g]])] <- NA
@@ -137,7 +139,7 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
             DATA <- DATA.X
           }
           DATA <- as.data.frame(DATA)
-  
+
           lavoptions2 <- lavoptions
           lavoptions2$verbose <- FALSE
           lavoptions2$estimator <- ""ML"""
ecmerkle,blavaan,887811841b298918383edbd71ba3ded5decd0853,ecmerkle,merklee@missouri.edu,2018-04-04T03:14:43Z,ecmerkle,merklee@missouri.edu,2018-04-04T03:14:43Z,fix postpred for 1-variable models,R/postpred.R,False,True,True,False,3,3,6,"---FILE: R/postpred.R---
@@ -76,10 +76,10 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
             cmu <- Mu.hat[[g]]
             csig <- Sigma.hat[[g]]
 
-            dataX[[g]] <- mnormt::rmnorm(n = lavsamplestats@nobs[[g]],
-                                         varcov = csig, mean = cmu)
+            dataX[[g]] <- matrix(mnormt::rmnorm(n = lavsamplestats@nobs[[g]],
+                                 varcov = csig, mean = cmu))
           }
-          
+
           ## get completely missing observations out, or there
           ## will be problems
           allmis <- apply(is.na(origlavdata@X[[g]]), 1, all)"
ecmerkle,blavaan,e3ffc2126d0fc742df8d07cfc1b07a9b67190cc8,ecmerkle,merklee@missouri.edu,2018-04-03T17:23:09Z,ecmerkle,merklee@missouri.edu,2018-04-03T17:23:09Z,fix prior settings in stan models with std.lv=TRUE,DESCRIPTION;R/set_stanpars.R,False,True,True,False,4,1,5,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-2.310
+Version: 0.3-2.311
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/set_stanpars.R---
@@ -137,6 +137,9 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
                     } else if(grepl(""star"", partable$mat[i])){
                         pname <- paste(""i"", strsplit(partable$mat[i], ""star"")[[1]][1], sep="""")
                         partype <- grep(pname, names(dp))
+                    } else if(grepl(""UNC"", partable$mat[i])){
+                        pname <- strsplit(partable$mat[i], ""UNC"")[[1]][1]
+                        partype <- grep(pname, names(dp))
                     } else {
                         partype <- grep(partable$mat[i], names(dp))
                     }"
ecmerkle,blavaan,7feb8ccc031666552c32196e9748d2aef9184048,ecmerkle,merklee@missouri.edu,2018-04-02T18:36:15Z,ecmerkle,merklee@missouri.edu,2018-04-02T18:36:15Z,explicitly condition on fixed.x variables for ppp,NAMESPACE;R/blavaan.R;R/postpred.R,False,True,True,False,28,29,57,"---FILE: NAMESPACE---
@@ -44,7 +44,8 @@ importFrom(""coda"",
            ""HPDinterval"")
 
 importFrom(""mnormt"",
-           ""dmnorm"")
+           ""dmnorm"",
+           ""rmnorm"")
 
 importFrom(""nonnest2"",
            ""llcont"")

---FILE: R/blavaan.R---
@@ -227,7 +227,7 @@ blavaan <- function(...,  # default lavaan arguments
       mcdebug <- dotdotdot$debug
       dotdotdot <- dotdotdot[-which(dotNames == ""debug"")]
     }
-    LAV <- do.call(""lavaan"", dotdotdot)
+    LAV <- suppressWarnings(do.call(""lavaan"", dotdotdot))
 
     if(LAV@Data@data.type == ""moment"") {
         stop(""blavaan ERROR: full data are required. consider using kd() from package semTools."")

---FILE: R/postpred.R---
@@ -48,18 +48,37 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
         ## cov matrix.
         lavmodel <- fill_params(lavmcmc[[j]][samp.indices[i],],
                                 origlavmodel, lavpartable)
-  
+
         ## generate data (some code from lav_bootstrap.R)
         implied <- lav_model_implied(lavmodel)
         Sigma.hat <- implied$cov
         Mu.hat <- implied$mean
         dataeXo <- lavdata@eXo
   
-        dataX <- vector(""list"", length=lavdata@ngroups)
+        dataX <- origlavdata@X
         for(g in 1:lavsamplestats@ngroups) {
-          dataX[[g]] <- MASS::mvrnorm(n     = lavsamplestats@nobs[[g]],
-                                      Sigma = Sigma.hat[[g]],
-                                      mu    = Mu.hat[[g]])
+          x.idx <- lavsamplestats@x.idx[[g]]
+          if(!is.null(x.idx) && length(x.idx) > 0L){
+            ## for fixed.x, generate the other ovs
+            ## conditional on the x values
+            nox <- (1:nrow(Mu.hat[[g]]))[-x.idx]
+            tm1 <- Sigma.hat[[g]][nox,x.idx] %*% solve(Sigma.hat[[g]][x.idx,x.idx])
+            cmu <- Mu.hat[[g]][nox,] +
+              tm1 %*% apply(origlavdata@X[[g]][,x.idx], 1, function(x) (x - Mu.hat[[g]][x.idx,]))
+            csig <- Sigma.hat[[g]][nox,nox] - tm1 %*% Sigma.hat[[g]][x.idx,nox]
+            sigchol <- chol(csig)
+            
+            dataX[[g]][,nox] <- t(apply(cmu, 2, function(x) mnormt::rmnorm(n=1,
+                                                                    sqrt=sigchol,
+                                                                    mean=x)))
+          } else {
+            nox <- 1:nrow(Mu.hat[[g]])
+            cmu <- Mu.hat[[g]]
+            csig <- Sigma.hat[[g]]
+
+            dataX[[g]] <- mnormt::rmnorm(n = lavsamplestats@nobs[[g]],
+                                         varcov = csig, mean = cmu)
+          }
           
           ## get completely missing observations out, or there
           ## will be problems
@@ -68,27 +87,14 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
             origlavdata@X[[g]] <- origlavdata@X[[g]][-which(allmis),]
           }
   
-          ## fixed x should also be generated, so don't need this:
-          ##x.idx <- lavsamplestats@x.idx[[g]]
-          ##if(!is.null(x.idx) && length(x.idx) > 0L){
-          ##  dataX[[g]][,x.idx] <- origlavdata@X[[g]][,x.idx]
-          ##}
-          
           dataX[[g]][is.na(origlavdata@X[[g]])] <- NA
         }
-  
+
         ## compute (i) X2 of generated data and model-implied
         ## moments, along with (ii) X2 of real data and model-implied
         ## moments.
         chisq.obs <- -2*(samplls[i, j, 1] -
                          samplls[i, j, 2])
-                             #get_ll(lavmodel = lavmodel,
-                             #    lavpartable = lavpartable,
-                             #    lavsamplestats = lavsamplestats,
-                             #    lavoptions = lavoptions,
-                             #    lavcache = lavcache,
-                             #    lavdata = origlavdata,
-                             #    measure = measure)
         
         #FIXME TDJ: apply custom ""discFUN"" here
   
@@ -98,14 +104,6 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
   
         if(!mis & length(discFUN) == 0){ #TDJ: if discFUN is supplied, we go right to ""else""
           lavdata@X <- dataX
-          x.idx <- lavsamplestats@x.idx[[g]]
-          if(!is.null(x.idx) && length(x.idx) > 0L){
-            for(g in 1:lavsamplestats@ngroups) {
-              lavsamplestats@mean.x[[g]] <- apply(lavdata@X[[g]][,x.idx,drop=FALSE], 2, mean)
-              lavsamplestats@cov.x[[g]] <- cov(lavdata@X[[g]][,x.idx,drop=FALSE])
-            }
-          }
-  
           chisq.boot <- 2*diff(get_ll(lavmodel = lavmodel,
                                       lavsamplestats = lavsamplestats,
                                       lavdata = lavdata,"
ecmerkle,blavaan,c68c8ea3b6014b9bca5600bdffc10e70b5591782,ecmerkle,merklee@missouri.edu,2018-03-26T04:09:52Z,ecmerkle,merklee@missouri.edu,2018-03-26T04:09:52Z,fix fitMeasures() when extra monitors are supplied,R/blav_utils.R,False,True,True,False,9,6,15,"---FILE: R/blav_utils.R---
@@ -144,7 +144,10 @@ get_ll <- function(postsamp       = NULL, # one posterior sample
         if(""control"" %in% slotNames(lavmodel)){
             lavmodel@control <- list(optim.method=""none"")
         }
-
+        ## FIXME: not sure when 'free' becomes numeric,
+        ## but S4 doesn't like it in the lavaan call
+        ## (only sometimes; related to extra monitors?)
+        lavpartable$free <- as.integer(lavpartable$free)
         fit.samp <- try(lavaan(slotParTable = lavpartable,
                                slotModel = lavmodel,
                                slotOptions = lavoptions,
@@ -430,12 +433,12 @@ add_monitors <- function(lavpartable, lavjags, jagextra){
     lavpartable$lhs <- c(lavpartable$lhs, xnms)
     lavpartable$op <- c(lavpartable$op, rep("":="", sum(nvars)))
     lavpartable$rhs <- c(lavpartable$rhs, rep("""", sum(nvars)))
-    lavpartable$user <- c(lavpartable$user, rep(2, sum(nvars)))
-    lavpartable$group <- c(lavpartable$group, rep(1, sum(nvars)))
-    lavpartable$block <- c(lavpartable$block, rep(1, sum(nvars)))
-    lavpartable$free <- c(lavpartable$free, rep(0, sum(nvars)))
+    lavpartable$user <- c(lavpartable$user, rep(2L, sum(nvars)))
+    lavpartable$group <- c(lavpartable$group, rep(1L, sum(nvars)))
+    lavpartable$block <- c(lavpartable$block, rep(1L, sum(nvars)))
+    lavpartable$free <- c(lavpartable$free, rep(0L, sum(nvars)))
     lavpartable$ustart <- c(lavpartable$ustart, rep(NA, sum(nvars)))
-    lavpartable$exo <- c(lavpartable$exo, rep(0, sum(nvars)))
+    lavpartable$exo <- c(lavpartable$exo, rep(0L, sum(nvars)))
     lavpartable$label <- c(lavpartable$label, rep("""", sum(nvars)))
     lavpartable$plabel <- c(lavpartable$plabel, rep("""", sum(nvars)))
     lavpartable$start <- c(lavpartable$start, rep(0, sum(nvars)))"
ecmerkle,blavaan,b41b08a5f48be26f8de14301e44dd072ae341a02,ecmerkle,merklee@missouri.edu,2018-03-26T03:40:45Z,ecmerkle,merklee@missouri.edu,2018-03-26T03:40:45Z,fix bug in supplying extra monitors,R/blav_utils.R;R/blavaan.R,False,True,True,False,2,3,5,"---FILE: R/blav_utils.R---
@@ -219,9 +219,8 @@ case_lls <- function(lavjags        = NULL,
                      thin           = 1){
 
     ## mcmc draws always in list
-    itnums <- sampnums(lavjags, thin=5)
+    itnums <- sampnums(lavjags, thin=thin)
     nsamps <- length(itnums)
-  
     nchain <- length(lavmcmc)
 
     ntot <- sum(unlist(lavdata@nobs))

---FILE: R/blavaan.R---
@@ -696,7 +696,7 @@ blavaan <- function(...,  # default lavaan arguments
 
         if(length(reservemons) < length(mcmcextra$monitor)){
             jecopy <- mcmcextra
-            jecopy$monitor <- jecopy$monitor[-reservemons]
+            if(length(reservemons) > 0) jecopy$monitor <- jecopy$monitor[-reservemons]
             lavpartable <- add_monitors(lavpartable, lavjags, jecopy)
         }
     }"
ecmerkle,blavaan,b96608db2857cf98e6b5cebdd87a664e54cd3456,ecmerkle,merklee@missouri.edu,2018-03-26T03:06:49Z,ecmerkle,merklee@missouri.edu,2018-03-26T03:06:49Z,fix small bug in conditional ICs,R/blav_utils.R,False,True,True,False,2,2,4,"---FILE: R/blav_utils.R---
@@ -507,13 +507,13 @@ samp_kls <- function(lavjags        = NULL,
 
             lavobject@Model <- lavmodel0
             mnvec0 <- lavPredict(lavobject, type=""ov"", ETA=eta0)
-            if(any(class(mnvec0) == ""matrix"")) mnvec <- list(mnvec0)
+            if(any(class(mnvec0) == ""matrix"")) mnvec0 <- list(mnvec0)
             cmat0 <- lavInspect(lavobject, 'theta')
             if(any(class(cmat0) == ""matrix"")) cmat0 <- list(cmat0)
 
             lavobject@Model <- lavmodel1
             mnvec1 <- lavPredict(lavobject, type=""ov"", ETA=eta1)
-            if(any(class(mnvec1) == ""matrix"")) mnvec <- list(mnvec1)
+            if(any(class(mnvec1) == ""matrix"")) mnvec1 <- list(mnvec1)
             cmat1 <- lavInspect(lavobject, 'theta')
             if(any(class(cmat1) == ""matrix"")) cmat1 <- list(cmat1)
 "
ecmerkle,blavaan,069873c670f4d85892106003f2cf5ead50079ac8,ecmerkle,merklee@missouri.edu,2018-03-21T02:24:53Z,ecmerkle,merklee@missouri.edu,2018-03-21T02:24:53Z,fix bug from related commit yesterday,DESCRIPTION;R/lav_export_stan.R,False,True,True,False,2,4,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-2.296
+Version: 0.3-2.298
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_stan.R---
@@ -323,16 +323,14 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
       if(length(lv0.idx) > 0){
         nlvno0 <- nlv - length(lv0.idx)
         regind <- c((1:nlv)[-lv0.idx], (nlvno0+regind))
-        exoind <- nlvno0 + exoind        
         etaind <- (1:nlv)[-lv0.idx]
       } else {
         nlvno0 <- nlv
         regind <- c(1:nlv, (nlv+regind))
-        exoind <- nlv + exoind
         etaind <- 1:nlv
       }
     }
-    lvindall <- c(regind, exoind)
+    lvindall <- regind
   }
 
   ## missingness of ovs split by whether or not they appear"
ecmerkle,blavaan,334d616ceb81cea41f4d45992a2ec2a2754c6bd6,ecmerkle,merklee@missouri.edu,2018-03-19T21:19:50Z,ecmerkle,merklee@missouri.edu,2018-03-19T21:19:50Z,fix index spacing,R/set_stanpars.R,False,True,True,False,1,1,2,"---FILE: R/set_stanpars.R---
@@ -103,7 +103,7 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
                 pvnum <- match(rhsvars, partable$label)
 
                 rhstrans <- paste(partable$mat[pvnum], ""["", partable$row[pvnum],
-                                  "", "", partable$col[pvnum], "", "", partable$group[pvnum],
+                                  "","", partable$col[pvnum], "","", partable$group[pvnum],
                                   ""]"", sep="""")
                 ## defined variables involved in another equality
                 defvars <- which(partable$mat[pvnum] == ""def"")"
ecmerkle,blavaan,959da1a3c9f606dfc88aaffa2bd072f21853925e,ecmerkle,merklee@missouri.edu,2018-03-05T20:57:17Z,ecmerkle,merklee@missouri.edu,2018-03-05T20:57:17Z,"fix jags inits for std.lv, multi groups with equality constraints",R/set_inits.R,False,True,True,False,4,2,6,"---FILE: R/set_inits.R---
@@ -32,8 +32,10 @@ set_inits <- function(partable, ov.cp, lv.cp, n.chains, inits){
   for(i in 1:nrow(partable)){
     eqcons <- which(partable$lhs == partable$label[i] &
                     partable$op %in% c(""=="", "":="", "">"", ""<""))
-    if((i %in% wps) | partable$free[i] == 0 | partable$prior[i] == """" | length(eqcons > 0)) next
-
+    if((i %in% wps) | partable$free[i] == 0 | partable$prior[i] == """") next
+    ## next unless it is a simple equality constraint:
+    if(length(eqcons) > 0 & !grepl('^\\.p', partable$rhs[eqcons[1]])) next
+    
     tmppri <- partable$prior[i]
       
     pricom <- unlist(strsplit(tmppri, ""[, ()]+""))"
ecmerkle,blavaan,fe568e662239b5c8acc421731360cbf37649ea83,ecmerkle,merklee@missouri.edu,2018-02-26T22:51:42Z,ecmerkle,merklee@missouri.edu,2018-02-26T22:51:42Z,further fixes for missing data in stan,DESCRIPTION;R/lav_export_stan.R;R/postpred.R,False,True,True,False,20,4,24,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-2.286
+Version: 0.3-2.288
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_stan.R---
@@ -694,6 +694,8 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     if(missflag){
       if(ny > 0){
         for(i in 1:nrow(y)){
+          ## TODO do this at first definition of obsvar?
+          obsvar[i,1:nseen[i]] <- match(obsvar[i,1:nseen[i]], yind)
           y[i,1:nseen[i]] <- y[i,obsvar[i,1:nseen[i]]]
           if(ny - nseen[i] > 0){
             y[i,(nseen[i]+1):ny] <- -999
@@ -703,8 +705,17 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     }
     if(miss.psi){
       if(n.psi.ov > 0){
+        for(gg in 1:ngroups){
+          for(m in 1:max(obspatt)){
+            if(nseenx[gg,obspatt[m]] > 0){
+              ## TODO do this at first definition of obsvarx?
+              xidx <- match(obsvarx[gg,m,1:nseenx[gg,m]], xind)
+              obsvarx[gg,m,1:nseenx[gg,m]] <- xidx
+            }
+          }
+        }
         for(i in 1:nrow(x)){
-          x[i,1:nseenx[obspatt[i]]] <- x[i,obsvarx[g[i],obspatt[i],1:nseenx[g[i],obspatt[i]]]]
+          x[i,1:nseenx[g[i],obspatt[i]]] <- x[i,obsvarx[g[i],obspatt[i],1:nseenx[g[i],obspatt[i]]]]
           if(n.psi.ov - nseenx[obspatt[i]] > 0){
             x[i,(nseenx[obspatt[i]]+1):n.psi.ov] <- -999
           }

---FILE: R/postpred.R---
@@ -97,8 +97,13 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
           DATA.X <- do.call(""rbind"", dataX)
           colnames(DATA.X) <- lavdata@ov.names[[1L]]
           DATA.eXo <- do.call(""rbind"", dataeXo)
-          empties <- as.numeric(sapply(lavdata@Mp, function(x) x$empty.idx))
-          DATA.eXo <- DATA.eXo[-empties, , drop = FALSE]
+          empties <- any(sapply(lavdata@Mp, function(x) length(x$empty.idx)) > 0)
+          if(empties){
+            empties <- as.numeric(sapply(lavdata@Mp, function(x) x$empty.idx))
+            if(!any(is.na(empties))){
+              DATA.eXo <- DATA.eXo[-empties, , drop = FALSE]
+            }
+          }
           if(!is.null(DATA.eXo)) {
             colnames(DATA.eXo) <- lavdata@ov.names.x[[1L]]
             DATA <- cbind(DATA.X, DATA.eXo)"
ecmerkle,blavaan,e329e13b286d96f50eb89c9d1256f51b7b94f785,ecmerkle,merklee@missouri.edu,2018-02-26T21:19:35Z,ecmerkle,merklee@missouri.edu,2018-02-26T21:19:35Z,fix ppp with fixed.x,R/postpred.R,False,True,True,False,15,1,16,"---FILE: R/postpred.R---
@@ -1,6 +1,6 @@
 postpred <- function(lavpartable, lavmodel, lavoptions, 
                      lavsamplestats, lavdata, lavcache, lavjags,
-                     samplls, measure = ""logl"", thin = 5) {
+                     samplls, measure = ""logl"", thin = 1) {
 
     ## run through lavjags$mcmc, generate data from various posterior
     ## samples. thin like we do in samp_lls
@@ -39,12 +39,19 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
           dataX[[g]] <- MASS::mvrnorm(n     = lavsamplestats@nobs[[g]],
                                       Sigma = Sigma.hat[[g]],
                                       mu    = Mu.hat[[g]])
+          
           ## get completely missing observations out, or there
           ## will be problems
           allmis <- apply(is.na(origlavdata@X[[g]]), 1, all)
           if(sum(allmis) > 0){
             origlavdata@X[[g]] <- origlavdata@X[[g]][-which(allmis),]
           }
+
+          ## fixed x should also be generated, so don't need this:
+          ##x.idx <- lavsamplestats@x.idx[[g]]
+          ##if(!is.null(x.idx) && length(x.idx) > 0L){
+          ##  dataX[[g]][,x.idx] <- origlavdata@X[[g]][,x.idx]
+          ##}
           
           dataX[[g]][is.na(origlavdata@X[[g]])] <- NA
         }
@@ -68,6 +75,13 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
 
         if(!mis){
           lavdata@X <- dataX
+          x.idx <- lavsamplestats@x.idx[[g]]
+          if(!is.null(x.idx) && length(x.idx) > 0L){
+            for(g in 1:lavsamplestats@ngroups) {
+              lavsamplestats@mean.x[[g]] <- apply(lavdata@X[[g]][,x.idx], 2, mean)
+              lavsamplestats@cov.x[[g]] <- cov(lavdata@X[[g]][,x.idx])
+            }
+          }
 
           chisq.boot <- 2*diff(get_ll(lavmodel = lavmodel,
                                       lavsamplestats = lavsamplestats,"
ecmerkle,blavaan,3db44b88c92fb249ed752778c2db37ced9a98b59,ecmerkle,merklee@missouri.edu,2018-02-25T17:29:13Z,ecmerkle,merklee@missouri.edu,2018-02-25T17:29:13Z,"further stan missingness fixes, adding drop=FALSE",DESCRIPTION;R/lav_export_stan.R,False,True,True,False,8,9,17,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-2.285
+Version: 0.3-2.286
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_stan.R---
@@ -535,12 +535,11 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   ## NB: if meanx is empty, we won't use it. so just
   ## set meanx to smean for stan.
   smean <- do.call(""cbind"", model@SampleStats@mean)
+  meanx <- smean
   if(length(model@SampleStats@mean.x[[1]]) > 0){
     if(!is.na(model@SampleStats@mean.x[[1]][1])){
       meanx <- do.call(""cbind"", model@SampleStats@mean.x)
     }
-  } else {
-    meanx <- smean
   }
   datablk <- paste0(datablk, t1, ""real sampmean["", nrow(smean), "","",
                     ncol(smean), ""];\n"", t1,
@@ -669,19 +668,19 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     nas <- which(yna | xna)
 
     if(length(nas) > 0){
-      if(ny > 0) y <- y[-nas,]
-      if(n.psi.ov > 0) x <- x[-nas,]
+      if(ny > 0) y <- y[-nas, , drop=FALSE]
+      if(n.psi.ov > 0) x <- x[-nas, , drop=FALSE]
       g <- g[-nas]
       if(ny > 0){
-        obsvar <- obsvar[-nas,]
-        misvar <- misvar[-nas,]
+        obsvar <- obsvar[-nas, , drop=FALSE]
+        misvar <- misvar[-nas, , drop=FALSE]
         nseen <- nseen[-nas]
         nmis <- nmis[-nas]
       }
       if(n.psi.ov > 0){
         #obsvarx <- obsvarx[-nas,]
-        misvarx <- misvarx[-nas,]
-        obsexo <- as.matrix(obsexo[-nas,]) # converts to numeric
+        misvarx <- misvarx[-nas, , drop=FALSE]
+        obsexo <- obsexo[-nas, , drop=FALSE]
         #nseenx <- nseenx[-nas]
         obspatt <- obspatt[-nas]
         nmisx <- nmisx[-nas]"
ecmerkle,blavaan,57a04830cdb4274fcc404c569251b89280e09ab7,ecmerkle,merklee@missouri.edu,2018-02-23T22:27:01Z,ecmerkle,merklee@missouri.edu,2018-02-23T22:27:01Z,remaining fix for meanx dimensions and postpred for stan missing data,DESCRIPTION;R/lav_export_stan.R;R/postpred.R,False,True,True,False,7,4,11,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.3-2.283
+Version: 0.3-2.285
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_stan.R---
@@ -535,9 +535,10 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   ## NB: if meanx is empty, we won't use it. so just
   ## set meanx to smean for stan.
   smean <- do.call(""cbind"", model@SampleStats@mean)
-  if(length(model@SampleStats@mean.x[[1]]) > 0 &
-     !is.na(model@SampleStats@mean.x[[1]][1])){
-    meanx <- do.call(""cbind"", model@SampleStats@mean.x)
+  if(length(model@SampleStats@mean.x[[1]]) > 0){
+    if(!is.na(model@SampleStats@mean.x[[1]][1])){
+      meanx <- do.call(""cbind"", model@SampleStats@mean.x)
+    }
   } else {
     meanx <- smean
   }

---FILE: R/postpred.R---
@@ -83,6 +83,8 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
           DATA.X <- do.call(""rbind"", dataX)
           colnames(DATA.X) <- lavdata@ov.names[[1L]]
           DATA.eXo <- do.call(""rbind"", dataeXo)
+          empties <- as.numeric(sapply(lavdata@Mp, function(x) x$empty.idx))
+          DATA.eXo <- DATA.eXo[-empties, , drop = FALSE]
           if(!is.null(DATA.eXo)) {
             colnames(DATA.eXo) <- lavdata@ov.names.x[[1L]]
             DATA <- cbind(DATA.X, DATA.eXo)"
ecmerkle,blavaan,5d834e7701f2555b9ee3054b1e40a2656d8d8200,ecmerkle,merklee@missouri.edu,2018-02-22T03:16:31Z,ecmerkle,merklee@missouri.edu,2018-02-22T03:16:31Z,partial fix for stan missingness and meanx dimensions,R/lav_export_stan.R,False,True,True,False,5,4,9,"---FILE: R/lav_export_stan.R---
@@ -535,7 +535,8 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   ## NB: if meanx is empty, we won't use it. so just
   ## set meanx to smean for stan.
   smean <- do.call(""cbind"", model@SampleStats@mean)
-  if(length(model@SampleStats@mean.x[[1]]) > 0){
+  if(length(model@SampleStats@mean.x[[1]]) > 0 &
+     !is.na(model@SampleStats@mean.x[[1]][1])){
     meanx <- do.call(""cbind"", model@SampleStats@mean.x)
   } else {
     meanx <- smean
@@ -679,7 +680,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
       if(n.psi.ov > 0){
         #obsvarx <- obsvarx[-nas,]
         misvarx <- misvarx[-nas,]
-        obsexo <- matrix(obsexo[-nas,]) # converts to numeric
+        obsexo <- as.matrix(obsexo[-nas,]) # converts to numeric
         #nseenx <- nseenx[-nas]
         obspatt <- obspatt[-nas]
         nmisx <- nmisx[-nas]
@@ -719,8 +720,8 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     }
     standata <- c(standata, list(dummyov=array(ov.dummy.idx),
                                  dummylv=array(lv.dummy.idx),
-                                 sampmean=smean,
-                                 meanx=meanx))
+                                 sampmean=array(smean, dim=c(nrow(smean), ncol(smean))),
+                                 meanx=array(meanx, dim=c(nrow(meanx), ncol(meanx)))))
 
     if(ny > 0) standata <- c(standata, list(y=y))
     if(n.psi.ov > 0) standata <- c(standata, list(x=x))"
ecmerkle,blavaan,41f52525b338108e87f20c5a302f61997b436980,ecmerkle,merklee@missouri.edu,2018-01-12T02:55:46Z,ecmerkle,merklee@missouri.edu,2018-01-12T02:55:46Z,fix casewise lls if some cases are missing all variables,R/blav_utils.R,False,True,True,False,13,9,22,"---FILE: R/blav_utils.R---
@@ -214,19 +214,23 @@ case_lls <- function(lavjags        = NULL,
   
     nchain <- length(lavmcmc)
 
+    ntot <- sum(unlist(lavdata@nobs))
     llmat <- matrix(NA, nchain*nsamps, sum(unlist(lavdata@nobs)))
 
     for(i in 1:nsamps){
         for(j in 1:nchain){
-            llmat[(i-1)*nchain + j,] <- get_ll(lavmcmc[[j]][itnums[i],],
-                                               lavmodel,
-                                               lavpartable, 
-                                               lavsamplestats, 
-                                               lavoptions, 
-                                               lavcache,
-                                               lavdata,
-                                               casewise = TRUE,
-                                               conditional = conditional)
+            clls <- get_ll(lavmcmc[[j]][itnums[i],],
+                           lavmodel,
+                           lavpartable, 
+                           lavsamplestats, 
+                           lavoptions, 
+                           lavcache,
+                           lavdata,
+                           casewise = TRUE,
+                           conditional = conditional)
+
+            if(length(clls) > ntot) clls <- clls[!is.na(clls)]
+            llmat[(i-1)*nchain + j,] <- clls
         }
     }
 "
ecmerkle,blavaan,4d0ccdf187515d2684615cb1e62b89e08b1ec068,ecmerkle,merklee@missouri.edu,2018-01-11T21:03:30Z,ecmerkle,merklee@missouri.edu,2018-01-11T21:03:30Z,fix std.lv=TRUE when used with no lvs,R/lav_export_stan.R,False,True,True,False,19,15,34,"---FILE: R/lav_export_stan.R---
@@ -11,13 +11,26 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   commop <- ""// ""
   eolop <- "";""
   if(length(dp) == 0) dp <- dpriors(target = ""stan"")
+  
+  ## get names of ovs before we add phantom variables
+  old.pta <- lav_partable_attributes(partable = partable, pta = NULL)
+  old.vnames <- old.pta$vnames
+  ngroups <- old.pta$ngroups
+  orig.ov.names <- old.vnames$ov[[1]]; nov <- length(orig.ov.names)
+  orig.lv.names <- old.vnames$lv[[1]]; orig.lv.names.x <- old.vnames$lv.x[[1]]
+  ## so ordering stays consistent:
+  orig.lv.names <- c(orig.lv.names[orig.lv.names %in% orig.lv.names.x],
+                     orig.lv.names[!(orig.lv.names %in% orig.lv.names.x)])
+  orig.ov.names.x <- old.vnames$ov.x[[1]]
+  nlvx <- length(orig.lv.names.x)
 
   ## to decide whether we need generated quantities
   etaname <- ""eta""
   betaname <- ""beta""
   psiname <- ""psi""
   std.lv <- lavInspect(model, ""options"")$std.lv
-  if(std.lv){
+  nlv <- length(lav_partable_attributes(partable = partable, pta = NULL)$vnames$lv[[1]])
+  if(std.lv & nlv > 0){
     etaname <- ""etaUNC""
     glist <- lavInspect(model, ""est"")
     if(lavInspect(model, ""ngroups"") > 1) glist <- glist[[1]]
@@ -27,20 +40,11 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     if(""psi"" %in% names(glist)){
       psiname <- ""psiUNC""
     }
+  } else {
+    ## in case std.lv=TRUE with no lvs
+    std.lv <- FALSE
   }
   
-  ## get names of ovs before we add phantom variables
-  old.pta <- lav_partable_attributes(partable = partable, pta = NULL)
-  old.vnames <- old.pta$vnames
-  ngroups <- old.pta$ngroups
-  orig.ov.names <- old.vnames$ov[[1]]; nov <- length(orig.ov.names)
-  orig.lv.names <- old.vnames$lv[[1]]; orig.lv.names.x <- old.vnames$lv.x[[1]]
-  ## so ordering stays consistent:
-  orig.lv.names <- c(orig.lv.names[orig.lv.names %in% orig.lv.names.x],
-                     orig.lv.names[!(orig.lv.names %in% orig.lv.names.x)])
-  orig.ov.names.x <- old.vnames$ov.x[[1]]
-  nlvx <- length(orig.lv.names.x)
-
   ## set up mvs with fixed 0 variances (single indicators of lvs)
   partable <- set_mv0(partable, orig.ov.names, ngroups)
   ## convert covariances to corr * sd1 * sd2
@@ -289,7 +293,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
                     model@Model@ov.x.dummy.lv.idx[[1]])
   dumov <- 0L
   if(length(ov.dummy.idx) > 0) dumov <- 1L
-
+  
   ## FIXME? see .internal_get_ALPHA from lav_representation_lisrel.R
   ## for alternative (better) way to handle this than eqs.x  
   if(nov.x > 0 | length(vnames$eqs.x[[1]]) > 0){
@@ -868,7 +872,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
       tpdecs <- paste0(tpdecs, ""\n"", t1, ""real def["", ndecs, "", 1, "",
                        ngroups, ""];\n"")
     }
-    
+
     if(nlv + n.psi.ov > 0){
       tpdecs <- paste0(tpdecs, t1, ""matrix[N,"", (nlv + n.psi.ov), ""] "", etaname, "";\n"")
       if(nlvno0 < nlv){"
ecmerkle,blavaan,b597cdb602467a8f0d5f70169523f4e7d9dd55d4,ecmerkle,merklee@missouri.edu,2018-01-11T20:10:46Z,ecmerkle,merklee@missouri.edu,2018-01-11T20:10:46Z,fix psiname problem,R/lav_export_stan.R,False,True,True,False,1,0,1,"---FILE: R/lav_export_stan.R---
@@ -15,6 +15,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   ## to decide whether we need generated quantities
   etaname <- ""eta""
   betaname <- ""beta""
+  psiname <- ""psi""
   std.lv <- lavInspect(model, ""options"")$std.lv
   if(std.lv){
     etaname <- ""etaUNC"""
ecmerkle,blavaan,91077eabb35fc28d95eda12fbf20c5eabedbe71d,ecmerkle,merklee@missouri.edu,2018-01-10T22:53:28Z,ecmerkle,merklee@missouri.edu,2018-01-10T22:53:28Z,fix lv cov sign changes under std.lv,R/lav_export_stan.R;R/set_stancovs.R,False,True,True,False,54,17,71,"---FILE: R/lav_export_stan.R---
@@ -23,6 +23,9 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     if(""beta"" %in% names(glist)){
       betaname <- ""betaUNC""
     }
+    if(""psi"" %in% names(glist)){
+      psiname <- ""psiUNC""
+    }
   }
   
   ## get names of ovs before we add phantom variables
@@ -40,8 +43,8 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   ## set up mvs with fixed 0 variances (single indicators of lvs)
   partable <- set_mv0(partable, orig.ov.names, ngroups)
   ## convert covariances to corr * sd1 * sd2
-  partable <- set_stancovs(partable)
-
+  partable <- set_stancovs(partable, std.lv)
+  
   ## ensure group parameters are in order, for parameter indexing:
   partable <- partable[order(partable$group),]
   ## get parameter table attributes 
@@ -116,11 +119,12 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   nmvs <- nov
   ov.names <- orig.ov.names
 
-  ## if std.lv, these are renamed to ""lambdaUNC"" and picked
+  ## if std.lv, these are renamed to ""lambdaUNC"", etc and picked
   ## up again in generated quantities
   if(std.lv){
     partable$mat[partable$mat == ""lambda""] <- ""lambdaUNC""
     partable$mat[partable$mat == ""beta""] <- ""betaUNC""
+    partable$mat[partable$mat == ""psi""] <- ""psiUNC""
   }
   
   eqlabs <- partable$rhs[partable$op %in% c(""=="", "":="")]
@@ -226,6 +230,9 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     if(parnm == ""beta"" & std.lv){
       parnm <- ""betaUNC""
     }
+    if(parnm == ""psi"" & std.lv){
+      parnm <- ""psiUNC""
+    }
     parblk <- paste0(parblk, ""["", nfree[i], ""]"")
     parblk <- paste0(parblk, "" "", parnm, ""free"", eolop, ""\n"")
   }
@@ -363,7 +370,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
       TXT <- paste0(TXT, ""sem_lv_lpdf("")
     }
 
-    TXT <- paste0(TXT, ""alpha, "", betaname, "", psi, "")
+    TXT <- paste0(TXT, ""alpha, "", betaname, "", "", psiname, "", "")
     TXT <- paste0(TXT, ifelse(gamind, ""gamma"", betaname), "", "")
     TXT <- paste0(TXT, as.numeric(gamind), "", meanx, "")
     TXT <- paste0(TXT, ""g, "", (nlv + n.psi.ov), "", N, "",
@@ -482,6 +489,10 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     if(length(betidx) > 0){
       names(nfree)[betidx] <- ""betaUNC""
     }
+    psiidx <- which(names(nfree) == ""psi"")
+    if(length(psiidx) > 0){
+      names(nfree)[psiidx] <- ""psiUNC""
+    }
   }
   TXT2 <- set_stanpars(TXT2, partable, nfree, dp, orig.lv.names.x)
   partable$prior <- TXT2$partable$prior
@@ -793,6 +804,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     monitors <- with(partable[partable$mat != """",], unique(mat))
     monitors[monitors==""lambdaUNC""] <- ""lambda""
     monitors[monitors==""betaUNC""] <- ""beta""
+    monitors[monitors==""psiUNC""] <- ""psi""
 
     ## these are passed in as data in stan, so are the ""frames""
     tpnames <- names(pmats)
@@ -821,6 +833,14 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
 
         tmpname <- ""betaUNC""
       }
+
+      if(tmpname == ""psi"" & std.lv){
+        GQ <- paste0(GQ, t1, ""real psi["", tmpdim[1], "","",
+                     tmpdim[2], "","", tmpdim[3], ""];\n"")
+        gqeqs <- paste0(gqeqs, t1, ""psi = psiUNC;\n"")
+
+        tmpname <- ""psiUNC""
+      }
       
       datdecs <- paste0(datdecs, t1, ""real "",
                         names(pmats)[i], ""["", tmpdim[1],
@@ -935,11 +955,16 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
                           partable$op == ""~"" &
                           partable$lhs %in% lvload &
                           partable$group == k)
+          covidx <- which(partable$rhs == lvload[i] &
+                          partable$op == ""~~"" &
+                          partable$lhs %in% lvload &
+                          partable$group == k)
+          nextlvs <- c(regidx, covidx)
           revtxt <- """" # for checking opposite (loading > 0 &
-                       # next lv loading < 0)
-          if(length(regidx) > 0){
-            for(j in 1:length(regidx)){
-              tmpidx <- which(partable$lhs == partable$lhs[regidx[j]] &
+                       # next restricted lv loading < 0)
+          if(length(nextlvs) > 0){
+            for(j in 1:length(nextlvs)){
+              tmpidx <- which(partable$lhs == partable$lhs[nextlvs[j]] &
                               partable$op == ""=~"" &
                               partable$group == k)[1]
 
@@ -951,16 +976,22 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
                                partable$row[tmpidx], "","",
                                partable$col[tmpidx], "","", k, ""] < 0){\n"")
 
-              GQ <- paste0(GQ, t3, ""beta["", partable$row[regidx[j]],
-                           "","", partable$col[regidx[j]], "","", k,
-                           ""] = -1 * betaUNC["", partable$row[regidx[j]],
-                           "","", partable$col[regidx[j]], "","", k,
+              if(partable$op[nextlvs[j]] == ""~""){
+                tmpmat <- ""beta""
+              } else {
+                tmpmat <- ""psi""
+              }
+
+              GQ <- paste0(GQ, t3, tmpmat, ""["", partable$row[nextlvs[j]],
+                           "","", partable$col[nextlvs[j]], "","", k,
+                           ""] = -1 * "", tmpmat, ""UNC["", partable$row[nextlvs[j]],
+                           "","", partable$col[nextlvs[j]], "","", k,
                            ""];\n"")
 
-              revtxt <- paste0(revtxt, t3, ""beta["", partable$row[regidx[j]],
-                               "","", partable$col[regidx[j]], "","", k,
-                               ""] = -1 * betaUNC["", partable$row[regidx[j]],
-                               "","", partable$col[regidx[j]], "","", k,
+              revtxt <- paste0(revtxt, t3, tmpmat, ""["", partable$row[nextlvs[j]],
+                               "","", partable$col[nextlvs[j]], "","", k,
+                               ""] = -1 * "", tmpmat, ""UNC["", partable$row[nextlvs[j]],
+                               "","", partable$col[nextlvs[j]], "","", k,
                                ""];\n"")
 
               GQ <- paste0(GQ, t2, ""}\n"")
@@ -1000,6 +1031,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     ## turn back to lambda so we get the right parameters!
     partable$mat[partable$mat == ""lambdaUNC""] <- ""lambda""
     partable$mat[partable$mat == ""betaUNC""] <- ""beta""
+    partable$mat[partable$mat == ""psiUNC""] <- ""psi""
   }
 
   ## insert function files, similar to brms approach:

---FILE: R/set_stancovs.R---
@@ -1,4 +1,4 @@
-set_stancovs <- function(partable) {
+set_stancovs <- function(partable, std.lv) {
   ## Add phantom lvs for covariance parameters
 
   ## first: parameter matrices + indexing
@@ -12,6 +12,11 @@ set_stancovs <- function(partable) {
     partable$group[defpar] <- 1
   }
 
+  ## must be psiUNC if std.lv
+  if(std.lv){
+    partable$mat[partable$mat == ""psi""] <- ""psiUNC""
+  }
+  
   ## add prior column if it doesn't exist
   if(is.na(match(""prior"", names(partable)))) partable$prior <- rep("""", length(partable$id))
   "
ecmerkle,blavaan,fb76ea8dcb8cbad1d72181ee8f0351343c2610ae,ecmerkle,merklee@missouri.edu,2018-01-10T17:00:33Z,ecmerkle,merklee@missouri.edu,2018-01-10T17:00:33Z,fix stan deep copy + multi-group missing x,R/lav_export_stan.R;inst/stanfuns/sem_lv_missing.stan,False,True,True,False,9,9,18,"---FILE: R/lav_export_stan.R---
@@ -622,7 +622,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
           
           nseenx[k,m] <- length(tmpobs)
           tmpobsexo <- which(tmpobs %in% exoind)
-          nseenexo[tmpidx] <- length(tmpobsexo)
+          nseenexo[lavdata@case.idx[[k]][tmpidx]] <- length(tmpobsexo)
           if(length(tmpobs) > 0){
             obsvarx[k, m, 1:length(tmpobs)] <- tmpobs
           }
@@ -631,18 +631,18 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
                                 length(tmpobsexo), byrow=TRUE)
             obsexo[tmpidx,1:nseenexo[tmpidx[1]]] <- tmpobsexo
           }
-          nmisx[tmpidx] <- length(tmpmis)
+          nmisx[lavdata@case.idx[[k]][tmpidx]] <- length(tmpmis)
           if(length(tmpmis) > 0){
             tmpmis <- matrix(tmpmis, length(tmpidx), length(tmpmis),
                              byrow=TRUE)
-            misvarx[tmpidx,1:nmisx[tmpidx[1]]] <- tmpmis
+            misvarx[lavdata@case.idx[[k]][tmpidx],1:nmisx[tmpidx[1]]] <- tmpmis
           }
         }
       }
     }
     if(ny > 0) colnames(y) <- ov.names[yind]
     if(n.psi.ov > 0) colnames(x) <- ov.names[xind]
-    
+
     ## remove fully deleted rows
     yna <- rep(FALSE, ntot)
     xna <- rep(FALSE, ntot)
@@ -687,7 +687,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     if(miss.psi){
       if(n.psi.ov > 0){
         for(i in 1:nrow(x)){
-          x[i,1:nseenx[obspatt[i]]] <- x[i,obsvarx[g[i],obspatt[i],1:nseenx[obspatt[i]]]]
+          x[i,1:nseenx[obspatt[i]]] <- x[i,obsvarx[g[i],obspatt[i],1:nseenx[g[i],obspatt[i]]]]
           if(n.psi.ov - nseenx[obspatt[i]] > 0){
             x[i,(nseenx[obspatt[i]]+1):n.psi.ov] <- -999
           }

---FILE: inst/stanfuns/sem_lv_missing.stan---
@@ -4,6 +4,7 @@
     vector[k] alpha2[Ng];
     vector[k] psivecinv[Ng];
     matrix[k,k] psimatinv[Ng];
+    matrix[k,k] psimat[Ng];
     matrix[k,k] siginv[Ng,max(gpatt)];
     vector[k] xvec;
     vector[k] evlv[Ng];
@@ -54,15 +55,14 @@
             ldetcomp[gg,m] = sum(log(diagonal(to_matrix(psi[idx[1:nidx],idx[1:nidx],gg]))));
   	  }
         } else {
-          psimatinv[gg] = to_matrix(psi[,,gg]);
-	  psimatinv[gg] = psimatinv[gg] + psimatinv[gg]' - diag_matrix(diagonal(psimatinv[gg]));
+          psimat[gg] = to_matrix(psi[,,gg]) + to_matrix(psi[,,gg])' - diag_matrix(diagonal(to_matrix(psi[,,gg])));
 
-	  ldetcomp[gg,m] = log_determinant(psimatinv[gg,idx[1:nidx],idx[1:nidx]]);
+	  ldetcomp[gg,m] = log_determinant(psimat[gg,idx[1:nidx],idx[1:nidx]]);
 	  if(fullbeta){
 	    ldetcomp[gg,m] = ldetcomp[gg,m] - 2 * log_determinant(iden[idx[1:nidx],idx[1:nidx]] - to_matrix(B[idx[1:nidx],idx[1:nidx],gg]));
 	  }
 
-	  psimatinv[gg,1:nidx,1:nidx] = inverse_spd(psimatinv[gg,idx[1:nidx],idx[1:nidx]]);
+	  psimatinv[gg,1:nidx,1:nidx] = inverse_spd(psimat[gg,idx[1:nidx],idx[1:nidx]]);
           siginv[gg,m,1:nidx,1:nidx] = (iden[idx[1:nidx],idx[1:nidx]] - to_matrix(B[idx[1:nidx],idx[1:nidx],gg])') * psimatinv[gg,1:nidx,1:nidx] * (iden[idx[1:nidx],idx[1:nidx]] - to_matrix(B[idx[1:nidx],idx[1:nidx],gg]));
         }
       }"
ecmerkle,blavaan,51553f209826aeacedcd051e471287d0f694f074,ecmerkle,merklee@missouri.edu,2018-01-09T18:33:32Z,ecmerkle,merklee@missouri.edu,2018-01-09T18:33:32Z,fix rosetta issues to pass check,R/blav_utils.R;R/set_inits.R,False,True,True,False,10,7,17,"---FILE: R/blav_utils.R---
@@ -28,7 +28,8 @@ get_ll <- function(postsamp       = NULL, # one posterior sample
       #                              lavsamplestats, ETA = eta)
       ## instead use lavInspect(,""est"")?
       #covmat <- lavaan:::computeTHETA(lavmodel, lavmodel@GLIST)
-
+      covmat <- cov(eta)
+      
       ngroups <- lavsamplestats@ngroups
       implied <- list(cov = covmat, mean = mnvec,
                       slopes = vector(""list"", ngroups),
@@ -377,10 +378,11 @@ dist2r <- function(priors, target){
         out <- jagsdist2r(priors)
     } else if(target == ""stan""){
         ## TODO need exported, or reverse rstan::lookup()
-        rosetta <- rstan:::rosetta
+        #rosetta <- rstan:::rosetta
         ## alternate way to possibly get around export
-        ##rloc <- paste0(system.file(""R"", package=""rstan""), ""/sysdata"")
-        ##lazyLoad(rloc)
+        rloc <- paste0(system.file(""R"", package=""rstan""), ""/sysdata"")
+        lazyLoad(rloc)
+        rosetta <- rosetta
         prisplit <- strsplit(priors, ""[, ()]+"")
         pridist <- sapply(prisplit, function(x) x[1])
         newdist <- rosetta$RFunction[match(pridist, rosetta$StanFunction)]

---FILE: R/set_inits.R---
@@ -139,10 +139,11 @@ set_inits_stan <- function(partable, nfree, n.chains, inits){
   }
 
   ## TODO need exported, or reverse rstan::lookup()
-  rosetta <- rstan:::rosetta
+  ## rosetta <- rstan:::rosetta
   ## alternate way to possibly get around export
-  ##rloc <- paste0(system.file(""R"", package=""rstan""), ""/sysdata"")
-  ##lazyLoad(rloc)
+  rloc <- paste0(system.file(""R"", package=""rstan""), ""/sysdata"")
+  lazyLoad(rloc)
+  rosetta <- rosetta
 
   pricom <- dist2r(freepartable$prior, target = ""stan"")
   for(i in 1:nrow(freepartable)){"
ecmerkle,blavaan,84d2a7da8788b9720acdeadf8f2d50762a25a20a,ecmerkle,merklee@missouri.edu,2018-01-04T22:20:03Z,ecmerkle,merklee@missouri.edu,2018-01-04T22:20:03Z,fix logl when fixed.x=TRUE (subtract logl.x),DESCRIPTION;R/blav_utils.R,False,True,True,False,31,1,32,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.267
+Version: 0.2-5.268
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blav_utils.R---
@@ -65,11 +65,41 @@ get_ll <- function(postsamp       = NULL, # one posterior sample
             tmpll <- try(dmnorm(lavdata@X[[g]], mnvec, cmat, log=TRUE))
             if(inherits(tmpll, ""try-error"")) tmpll <- NA
 
+            ## subtract logl.X
+            x.idx <- lavsamplestats@x.idx[[g]]
+            if(!is.null(x.idx) && length(x.idx) > 0L){
+                Mu.X <- lavsamplestats@mean.x[[g]]
+                Sigma.X <- lavsamplestats@cov.x[[g]]
+                if(is.null(Mu.X)){
+                    Mu.X <- mnvec[x.idx]
+                }
+                if(is.null(Sigma.X)){
+                    Sigma.X <- cmat[x.idx, x.idx, drop=FALSE]
+                }
+                tmpll.x <- try(dmnorm(lavdata@X[[g]][,x.idx], Mu.X, Sigma.X, log=TRUE))
+                if(inherits(tmpll.x, ""try-error"")) tmpll.x <- NA
+                tmpll <- tmpll - tmpll.x
+            }
+            
             if(!conditional){
                 sampmn <- apply(lavdata@X[[g]], 2, mean, na.rm=TRUE)
                 sampcov <- ((lavdata@nobs[[g]]-1)/(lavdata@nobs[[g]]))*cov(lavdata@X[[g]])
 
                 basell <- dmnorm(lavdata@X[[g]], sampmn, sampcov, log=TRUE)
+
+                if(!is.null(x.idx) && length(x.idx) > 0L){
+                    Mu.X <- lavsamplestats@mean.x[[g]]
+                    Sigma.X <- lavsamplestats@cov.x[[g]]
+                    if(is.null(Mu.X)){
+                        Mu.X <- sampmn[x.idx]
+                    }
+                    if(is.null(Sigma.X)){
+                        Sigma.X <- sampcov[x.idx, x.idx, drop=FALSE]
+                    }
+                    tmpll.x <- try(dmnorm(lavdata@X[[g]][,x.idx], Mu.X, Sigma.X, log=TRUE))
+                    if(inherits(tmpll.x, ""try-error"")) tmpll.x <- NA
+                    basell <- basell - tmpll.x
+                }
             }
 
             if(casewise){"
ecmerkle,blavaan,de73da82ded18a5ddab68945d89e684a8a057d14,ecmerkle,merklee@missouri.edu,2018-01-02T03:12:22Z,ecmerkle,merklee@missouri.edu,2018-01-02T03:12:22Z,fix rstan namespace issue,DESCRIPTION;R/blavaan.R,False,True,True,False,2,4,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.265
+Version: 0.2-5.266
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blavaan.R---
@@ -53,9 +53,7 @@ blavaan <- function(...,  # default lavaan arguments
       if(!(suppressMessages(requireNamespace(""rstan"", quietly = TRUE)))){
         stop(""blavaan ERROR: rstan package is not installed."")
       } else {
-        if(!isNamespaceLoaded(""rstan"")){
-          suppressMessages(attachNamespace(""rstan""))
-        }
+        try(suppressMessages(attachNamespace(""rstan"")), silent = TRUE)
       }
       rstan::rstan_options(auto_write = TRUE)
       options(mc.cores = min(n.chains, parallel::detectCores()))"
ecmerkle,blavaan,d14ec9d2b1c7c2861fe3f907f52706d2596a2962,ecmerkle,merklee@missouri.edu,2017-12-22T04:10:23Z,ecmerkle,merklee@missouri.edu,2017-12-22T04:10:23Z,fix burnin/sample in stan summary(),DESCRIPTION;R/blav_object_methods.R;R/blavaan.R,False,True,True,False,7,6,13,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.259
+Version: 0.2-5.264
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blav_object_methods.R---
@@ -17,7 +17,7 @@ short.summary <- function(object) {
                     packageDescription(""blavaan"", fields=""Version"")))
     } else if(object@Fit@iterations > 0) {
         if(object@Fit@converged) {
-	    cat(sprintf(""blavaan (%s) results of %3i samples after %3i adapt+burnin iterations\n"",
+	    cat(sprintf(""blavaan (%s) results of %3i samples after %3i adapt/burnin iterations\n"",
                     packageDescription(""blavaan"", fields=""Version""),
                     object@external$sample,
                     object@external$burnin))

---FILE: R/blavaan.R---
@@ -512,10 +512,11 @@ blavaan <- function(...,  # default lavaan arguments
             } else {
                 wrmup <- ifelse(length(rjarg$warmup) > 0,
                                 rjarg$warmup, floor(rjarg$iter/2))
-                attr(x, ""iterations"") <- wrmup
-                # saved in @external so summary() can use it:
-                burnin <- wrmup
-                sample <- sample - wrmup
+                attr(x, ""iterations"") <- sample
+                # burnin + sample already defined, will be saved in
+                # @external so summary() can use it:
+                #burnin <- wrmup
+                #sample <- sample - wrmup
             }
             attr(x, ""converged"") <- TRUE
         } else {"
ecmerkle,blavaan,56f839b17af423bb0922f435aa28e1c49319973c,ecmerkle,merklee@missouri.edu,2017-12-21T20:20:30Z,ecmerkle,merklee@missouri.edu,2017-12-21T20:20:30Z,avoid error is rstan namespace already loaded,R/blavaan.R,False,True,True,False,3,1,4,"---FILE: R/blavaan.R---
@@ -53,7 +53,9 @@ blavaan <- function(...,  # default lavaan arguments
       if(!(suppressMessages(requireNamespace(""rstan"", quietly = TRUE)))){
         stop(""blavaan ERROR: rstan package is not installed."")
       } else {
-        suppressMessages(attachNamespace(""rstan""))
+        if(!isNamespaceLoaded(""rstan"")){
+          suppressMessages(attachNamespace(""rstan""))
+        }
       }
       rstan::rstan_options(auto_write = TRUE)
       options(mc.cores = min(n.chains, parallel::detectCores()))"
ecmerkle,blavaan,04f1ec7e9de25a9b31f6dc3e278cbe75c11df7b5,ecmerkle,merklee@missouri.edu,2017-12-15T03:37:14Z,ecmerkle,merklee@missouri.edu,2017-12-15T03:37:14Z,fix namespace issues with rstan,DESCRIPTION;R/blavaan.R;R/lav_export_stan.R,False,True,True,False,5,3,8,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.257
+Version: 0.2-5.259
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blavaan.R---
@@ -50,8 +50,10 @@ blavaan <- function(...,  # default lavaan arguments
         stop(""blavaan ERROR: auto convergence is unavailable for stan."")
       }
       # could also use requireNamespace + attachNamespace
-      if(!(suppressMessages(require(""rstan"", quietly = TRUE)))){
+      if(!(suppressMessages(requireNamespace(""rstan"", quietly = TRUE)))){
         stop(""blavaan ERROR: rstan package is not installed."")
+      } else {
+        suppressMessages(attachNamespace(""rstan""))
       }
       rstan::rstan_options(auto_write = TRUE)
       options(mc.cores = min(n.chains, parallel::detectCores()))

---FILE: R/lav_export_stan.R---
@@ -89,7 +89,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   t4 <- paste(rep("" "", 8L), collapse="""")
   
   ## stan blocks
-  datblk <- parblk <- TPS <- TXT <- """"
+  datblk <- parblk <- TPS <- TXT <- GQ <- """"
   if(std.lv) GQ <- ""\ngenerated quantities {\n""
 
   ## hold priors to put at bottom of model block"
ecmerkle,blavaan,4e65003876f17ce195c9bfebfc049477be202fe1,ecmerkle,merklee@missouri.edu,2017-12-14T21:19:48Z,ecmerkle,merklee@missouri.edu,2017-12-14T21:19:48Z,"fix list, vs list of lists for ngroups=1 vs >1",DESCRIPTION;R/lav_export_stan.R,False,True,True,False,5,3,8,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.256
+Version: 0.2-5.257
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_stan.R---
@@ -18,7 +18,9 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   std.lv <- lavInspect(model, ""options"")$std.lv
   if(std.lv){
     etaname <- ""etaUNC""
-    if(""beta"" %in% names(lavInspect(model, ""est""))){
+    glist <- lavInspect(model, ""est"")
+    if(lavInspect(model, ""ngroups"") > 1) glist <- glist[[1]]
+    if(""beta"" %in% names(glist)){
       betaname <- ""betaUNC""
     }
   }
@@ -778,7 +780,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     pmats <- vector(""list"", length(matrows))
     for(i in 1:length(pmats)){
         if(names(matrows)[i] == ""lambda""){
-            tmpmat <- lavInspect(model, ""est"")$lambda
+            tmpmat <- parmattable[[1]]$lambda
             pmats[[i]] <- array(tmpmat,
                                 c(nrow(tmpmat), ncol(tmpmat), ngroups))
         } else {"
ecmerkle,blavaan,297bf5278d7dc5da8f522e73012598a874b236fc,ecmerkle,merklee@missouri.edu,2017-12-14T21:03:15Z,ecmerkle,merklee@missouri.edu,2017-12-14T21:03:15Z,fix std.lv for models with only dummy lvs,DESCRIPTION;R/blavaan.R,False,True,True,False,17,16,33,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.255
+Version: 0.2-5.256
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blavaan.R---
@@ -271,26 +271,27 @@ blavaan <- function(...,  # default lavaan arguments
         if(!prispec){
             LAV@ParTable$prior <- rep("""", length(LAV@ParTable$id))
         }
-        ## first loading for each lv
         loadpt <- LAV@ParTable$op == ""=~""
         lvs <- unique(LAV@ParTable$lhs[loadpt])
         fload <- NULL
-        for(i in 1:length(lvs)){
-            for(k in 1:max(LAV@ParTable$group)){
-                fload <- c(fload, which(LAV@ParTable$lhs == lvs[i] &
-                                        LAV@ParTable$op == ""=~"" &
-                                        LAV@ParTable$group == k)[1])
+        if(length(lvs) > 0){
+            for(i in 1:length(lvs)){
+                for(k in 1:max(LAV@ParTable$group)){
+                    fload <- c(fload, which(LAV@ParTable$lhs == lvs[i] &
+                                            LAV@ParTable$op == ""=~"" &
+                                            LAV@ParTable$group == k)[1])
+                }
             }
-        }
 
-        ## NB truncation doesn't work well in stan. instead
-        ##    use generated quantities after the fact.
-        trunop <- ifelse(target == ""jags"", "" T(0,)"", """")
-        for(i in 1:length(fload)){
-            if(LAV@ParTable$prior[fload[i]] != """"){
-                LAV@ParTable$prior[fload[i]] <- paste(LAV@ParTable$prior[fload[i]], trunop, sep="""")
-            } else {
-                LAV@ParTable$prior[fload[i]] <- paste(dp[[""lambda""]], trunop, sep="""")
+            ## NB truncation doesn't work well in stan. instead
+            ##    use generated quantities after the fact.
+            trunop <- ifelse(target == ""jags"", "" T(0,)"", """")
+            for(i in 1:length(fload)){
+                if(LAV@ParTable$prior[fload[i]] != """"){
+                    LAV@ParTable$prior[fload[i]] <- paste(LAV@ParTable$prior[fload[i]], trunop, sep="""")
+                } else {
+                    LAV@ParTable$prior[fload[i]] <- paste(dp[[""lambda""]], trunop, sep="""")
+                }
             }
         }
     }"
ecmerkle,blavaan,6effc79ea286cd394bb08b5d156eb0b6a95c0822,ecmerkle,merklee@missouri.edu,2017-12-11T18:58:36Z,ecmerkle,merklee@missouri.edu,2017-12-11T18:58:36Z,fix stan computations on 0-variance lvs,R/lav_export_stan.R;inst/stanfuns/sem_mean_eta.stan,False,True,True,False,24,12,36,"---FILE: R/lav_export_stan.R---
@@ -289,7 +289,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
       }
     }
   }
-  
+
   ## missingness of ovs split by whether or not they appear
   ## in psi
   missflag <- FALSE
@@ -354,13 +354,14 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   if(nlvno0 < nlv){
     if(nlvno0 > 0){
       TPS <- paste0(TPS, t1, ""for(i in 1:N) {\n"")
-      TPS <- paste0(TPS, t2, ""eta[i,etaind] = etavec[i];\n"", t1, ""}\n"")
+      TPS <- paste0(TPS, t2, ""eta[i,etaind] = etavec[i];\n"")
+      TPS <- paste0(TPS, t1, ""}\n"")
     }
-    
+
     TPS <- paste0(TPS, t1, ""mueta = sem_mean_eta(alpha, eta, "",
                   ""beta, "", ifelse(gamind, ""gamma"", ""beta""),
                   "", g, "", (nlv + n.psi.ov),
-                  "", N, "", ngroups, "", lvind);\n"")
+                  "", N, "", ngroups, "", "", nlv, "", lvind, eta0ind);\n"")
   }
   
   ## Define mean of each observed variable

---FILE: inst/stanfuns/sem_mean_eta.stan---
@@ -1,24 +1,35 @@
-  vector[] sem_mean_eta(real[,,] alpha, matrix eta, real[,,] B, real[,,] gamma, int[] g, int k, int N, int Ng, int[] lvind){
+  vector[] sem_mean_eta(real[,,] alpha, matrix eta, real[,,] B, real[,,] gamma, int[] g, int k, int N, int Ng, int nlv, int[] lvind, int[] lv0ind){
     matrix[k,k] iden;
     matrix[k,k] ibinv[Ng];
     vector[k] evlv[N];
     real alphvec[k,1,Ng];
+    int idx[(k - nlv + size(lvind))];
+    int nov;
+    int nlvno0;
+
+    nov = k - nlv;
+    nlvno0 = size(lvind);
 
     iden = diag_matrix(rep_vector(1.0, k));
 
     alphvec = alpha;
 
+    if(size(lvind) > 0){
+      idx[1:nlvno0] = lvind;
+    }
+    if(nov > 0){
+      for(j in 1:nov){
+        idx[nlvno0+j] = nlv + j; //nlvno0 + j?
+      }
+    }
+
     for(j in 1:Ng){
-      ibinv[j] = inverse(iden - to_matrix(B[,,j]));
-      alphvec[lvind,1,j] = rep_array(0,size(lvind));
+      ibinv[j,lv0ind,lv0ind] = inverse(iden[lv0ind,lv0ind] - to_matrix(B[lv0ind,lv0ind,j]));
     }
 
     for(i in 1:N){
-      // see regind/exoind stuff
-      // Works for MILCS:
-      //evlv[i] = to_matrix(B[,,g[i]]) * eta[i,]';
-      // Works for lcs model
-      evlv[i] = ibinv[g[i]] * (to_vector(alphvec[,1,g[i]]) + to_matrix(B[,,g[i]]) * eta[i,]');
+      // this line took way too long to get right:
+      evlv[i,lv0ind] = ibinv[g[i],lv0ind,lv0ind] * (to_vector(alphvec[lv0ind,1,g[i]]) + to_matrix(B[lv0ind,idx,g[i]]) * eta[i,idx]');
     }
 
     return evlv;"
ecmerkle,blavaan,fd4b7e628072ba186ae6fb296e47fa27a4d17f5a,ecmerkle,merklee@missouri.edu,2017-12-08T20:12:44Z,ecmerkle,merklee@missouri.edu,2017-12-08T20:12:44Z,note on stan bug,inst/stanfuns/sem_mean_eta.stan,False,False,False,False,4,0,4,"---FILE: inst/stanfuns/sem_mean_eta.stan---
@@ -14,6 +14,10 @@
     }
 
     for(i in 1:N){
+      // see regind/exoind stuff
+      // Works for MILCS:
+      //evlv[i] = to_matrix(B[,,g[i]]) * eta[i,]';
+      // Works for lcs model
       evlv[i] = ibinv[g[i]] * (to_vector(alphvec[,1,g[i]]) + to_matrix(B[,,g[i]]) * eta[i,]');
     }
 "
ecmerkle,blavaan,5dce451da5e701d0385e7428efc2cb81ed58b3df,ecmerkle,merklee@missouri.edu,2017-12-08T14:36:50Z,ecmerkle,merklee@missouri.edu,2017-12-08T14:36:50Z,"change sign on stan ldetcomp, fix typo",R/blavaan.R;inst/stanfuns/sem_lv.stan;inst/stanfuns/sem_lv_missing.stan,False,True,True,False,5,6,11,"---FILE: R/blavaan.R---
@@ -212,7 +212,7 @@ blavaan <- function(...,  # default lavaan arguments
     mcdebug <- FALSE
     if(""debug"" %in% dotNames){
       ## only debug mcmc stuff
-      mcdbebug <- dotdotdot$debug
+      mcdebug <- dotdotdot$debug
       dotdotdot <- dotdotdot[-which(dotNames == ""debug"")]
     }
     LAV <- do.call(""lavaan"", dotdotdot)

---FILE: inst/stanfuns/sem_lv.stan---
@@ -34,7 +34,6 @@
 
     evlv = sem_mean(alpha2, B, gamma, g, k, Ng, gamind, meanx);
 
-
     if(diagpsi){
       for(j in 1:Ng){
         for(i in 1:nidx){
@@ -46,7 +45,7 @@
 
 	if(fullbeta){
 	  ldetcomp[j] = log_determinant(iden[idx,idx] - to_matrix(B[idx,idx,j]));
-	  ldetcomp[j] = ldetcomp[j] + ldetcomp[j] + sum(log(diagonal(to_matrix(psi[idx,idx,j]))));
+	  ldetcomp[j] = -2 * ldetcomp[j] + sum(log(diagonal(to_matrix(psi[idx,idx,j]))));
 	} else {
           ldetcomp[j] = sum(log(diagonal(to_matrix(psi[idx,idx,j]))));
   	}
@@ -57,7 +56,7 @@
 
 	ldetcomp[j] = log_determinant(psimat[j,idx,idx]);
 	if(fullbeta){
-	  ldetcomp[j] = ldetcomp[j] + 2 * log_determinant(iden[idx,idx] - to_matrix(B[idx,idx,j]));
+	  ldetcomp[j] = ldetcomp[j] - 2 * log_determinant(iden[idx,idx] - to_matrix(B[idx,idx,j]));
 	}
 
 	psimatinv[j] = psimat[j];

---FILE: inst/stanfuns/sem_lv_missing.stan---
@@ -49,7 +49,7 @@
 
 	  if(fullbeta){
 	    ldetcomp[gg,m] = log_determinant(iden[idx[1:nidx],idx[1:nidx]] - to_matrix(B[idx[1:nidx],idx[1:nidx],gg]));
-	    ldetcomp[gg,m] = ldetcomp[gg,m] + ldetcomp[gg,m] + sum(log(diagonal(to_matrix(psi[idx[1:nidx],idx[1:nidx],gg]))));
+	    ldetcomp[gg,m] = -2 * ldetcomp[gg,m] + sum(log(diagonal(to_matrix(psi[idx[1:nidx],idx[1:nidx],gg]))));
 	  } else {
             ldetcomp[gg,m] = sum(log(diagonal(to_matrix(psi[idx[1:nidx],idx[1:nidx],gg]))));
   	  }
@@ -59,7 +59,7 @@
 
 	  ldetcomp[gg,m] = log_determinant(psimatinv[gg,idx[1:nidx],idx[1:nidx]]);
 	  if(fullbeta){
-	    ldetcomp[gg,m] = ldetcomp[gg,m] + 2 * log_determinant(iden[idx[1:nidx],idx[1:nidx]] - to_matrix(B[idx[1:nidx],idx[1:nidx],gg]));
+	    ldetcomp[gg,m] = ldetcomp[gg,m] - 2 * log_determinant(iden[idx[1:nidx],idx[1:nidx]] - to_matrix(B[idx[1:nidx],idx[1:nidx],gg]));
 	  }
 
 	  psimatinv[gg,1:nidx,1:nidx] = inverse_spd(psimatinv[gg,idx[1:nidx],idx[1:nidx]]);"
ecmerkle,blavaan,706d24a91bd568d4aa18da970ef5d61ce927184a,ecmerkle,merklee@missouri.edu,2017-12-07T03:14:06Z,ecmerkle,merklee@missouri.edu,2017-12-07T03:14:06Z,small sem_lv_missing fix,inst/stanfuns/sem_lv_missing.stan,False,False,False,False,1,1,2,"---FILE: inst/stanfuns/sem_lv_missing.stan---
@@ -7,7 +7,7 @@
     matrix[k,k] siginv[Ng,max(gpatt)];
     vector[k] xvec;
     vector[k] evlv[Ng];
-    int idx[(k-nlv-nlvno0)];
+    int idx[(k-nlv+nlvno0)];
     int tmpobs[k];
     real xvectm;
     real ldetsum;"
ecmerkle,blavaan,620937e17a9015647a536062fc0d1743037b3cb4,ecmerkle,merklee@missouri.edu,2017-11-30T22:35:19Z,ecmerkle,merklee@missouri.edu,2017-11-30T22:35:19Z,fix stan fitMeasure & associated computations,DESCRIPTION;R/blav_compare.R;R/blav_fit_measures.R;R/blav_object_inspect.R;R/blav_utils.R;R/blavaan.R,False,True,True,False,32,16,48,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.242
+Version: 0.2-5.244
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blav_compare.R---
@@ -18,14 +18,14 @@ blavCompare <- function(object1, object2, ...) {
   ll1 <- case_lls(object1@external$mcmcout, object1@Model,
                   object1@ParTable, object1@SampleStats,
                   lavopt1, object1@Cache,
-                  object1@Data)
+                  object1@Data, make_mcmc(object1@external$mcmcout))
 
   lavopt2 <- object2@Options
   lavopt2$estimator <- ""ML""
   ll2 <- case_lls(object2@external$mcmcout, object2@Model,
                   object2@ParTable, object2@SampleStats,
                   lavopt2, object2@Cache,
-                  object2@Data)
+                  object2@Data, make_mcmc(object2@external$mcmcout))
 
   loo1 <- loo(ll1); loo2 <- loo(ll2)
   waic1 <- waic(ll1); waic2 <- waic(ll2)

---FILE: R/blav_fit_measures.R---
@@ -160,7 +160,7 @@ blav_fit_measures <- function(object, fit.measures = ""all"",
         casells <- case_lls(object@external$mcmcout, object@Model,
                             object@ParTable, object@SampleStats,
                             lavopt, object@Cache,
-                            object@Data)
+                            object@Data, make_mcmc(object@external$mcmcout))
         fitres <- waic(casells)
         indices[""waic""] <- fitres$waic
         indices[""p_waic""] <- fitres$p_waic
@@ -191,6 +191,7 @@ fit_idx <- function(BLAV, thin = 5, measure = ""logl""){
                     BLAV@Options,
                     BLAV@Cache,
                     BLAV@Data,
+                    make_mcmc(BLAV@external$mcmcout),
                     thin = thin,
                     measure = measure)
 

---FILE: R/blav_object_inspect.R---
@@ -72,7 +72,7 @@ blavInspect <- function(blavobject, what, ...) {
             pt$free[pt$op == "":=""] <- max(pt$free, na.rm = TRUE) + 1:sum(pt$op == "":="")
             labs <- lav_partable_labels(pt, type = ""free"")
             draws <- make_mcmc(blavobject@external$mcmcout)
-            draws <- lapply(draws, function(x) x[,idx])
+            draws <- lapply(draws, function(x) mcmc(x[,idx]))
             draws <- mcmc.list(draws)
             if(what == ""hpd""){
                 pct <- .95

---FILE: R/blav_utils.R---
@@ -140,11 +140,11 @@ samp_lls <- function(lavjags        = NULL,
                      lavoptions     = NULL, 
                      lavcache       = NULL,
                      lavdata        = NULL,
+                     lavmcmc        = NULL,
                      thin           = 5,
                      conditional    = FALSE){
     itnums <- sampnums(lavjags, thin = thin)
     nsamps <- length(itnums)
-    lavmcmc <- make_mcmc(lavjags)
   
     nchain <- length(lavmcmc)
     llmat <- array(NA, c(nsamps, nchain, 2)) ## logl + baseline logl
@@ -173,14 +173,14 @@ case_lls <- function(lavjags        = NULL,
                      lavoptions     = NULL, 
                      lavcache       = NULL,
                      lavdata        = NULL,
+                     lavmcmc        = NULL,
                      conditional    = FALSE,
                      thin           = 5){
 
     ## mcmc draws always in list
     itnums <- sampnums(lavjags, thin=5)
     nsamps <- length(itnums)
   
-    lavmcmc <- make_mcmc(lavjags)
     nchain <- length(lavmcmc)
 
     llmat <- matrix(NA, nchain*nsamps, sum(unlist(lavdata@nobs)))
@@ -211,7 +211,7 @@ fill_params <- function(postsamp      = NULL,
                                        x = postsamp[lavpartable$jagpnum[!is.na(lavpartable$jagpnum)]])
   } else {
     filled <- lav_model_set_parameters(lavmodel,
-                                       x = postsamp[lavpartable$stanpnum[lavpartable$free > 0][order(lavpartable$free[lavpartable$free > 0])]])
+                                       x = postsamp[lavpartable$stansumnum[lavpartable$free > 0][order(lavpartable$free[lavpartable$free > 0])]])
   }
   filled
 }
@@ -231,7 +231,7 @@ rearr_params <- function(mcmc         = NULL,
     if(""jagpnum"" %in% names(lavpartable)){
         fullmat[,lavpartable$jagpnum[lavpartable$free > 0]]
     } else {
-        fullmat[,lavpartable$stanpnum[lavpartable$free > 0][order(lavpartable$free[lavpartable$free > 0])]]
+        fullmat[,lavpartable$stansumnum[lavpartable$free > 0][order(lavpartable$free[lavpartable$free > 0])]]
     }
 }   
 
@@ -428,6 +428,7 @@ samp_kls <- function(lavjags        = NULL,
                      lavoptions     = NULL, 
                      lavcache       = NULL,
                      lavdata        = NULL,
+                     lavmcmc        = NULL,
                      thin           = 5,
                      conditional    = FALSE){
 
@@ -437,7 +438,6 @@ samp_kls <- function(lavjags        = NULL,
     ##if(mis | lavoptions$categorical) stop(""blavaan ERROR: K-L divergence not implemented for missing data or ordinal variables."")
 
     itnums <- sampnums(lavjags, thin = thin)
-    lavmcmc <- make_mcmc(lavjags)
     lavmcmc <- lapply(lavmcmc, function(x) x[itnums,])
     draws <- do.call(""rbind"", lavmcmc)
   
@@ -518,7 +518,10 @@ samp_kls <- function(lavjags        = NULL,
 fill_eta <- function(postsamp, lavpartable, lavsamplestats, lavdata){
     nlv <- length(lav_partable_attributes(lavpartable)$vnames$lv[[1]])
     etapars <- grepl(""^eta"", names(postsamp))
-    etamat <- matrix(postsamp[etapars], lavsamplestats@ntotal, nlv)
+    cnums <- strsplit(names(postsamp)[etapars], ""\\[|,|\\]"")
+    cnums <- sapply(cnums, function(x) as.numeric(x[3]))
+    etavec <- postsamp[etapars][order(cnums)]
+    etamat <- matrix(etavec, lavsamplestats@ntotal, nlv)
     ngroups <- lavsamplestats@ngroups
 
     eta <- vector(""list"", ngroups)
@@ -545,6 +548,7 @@ kl_und <- function(mn0, mn1, cov0, invcov0, cov1, invcov1,
   (1/2) * (kl01 + kl10)
 }
 
+## now defunct:
 ## get various fit metrics from a fitted model for each
 ## posterior draw
 samp_idx <- function(lavjags        = NULL,
@@ -554,6 +558,7 @@ samp_idx <- function(lavjags        = NULL,
                      lavoptions     = NULL, 
                      lavcache       = NULL,
                      lavdata        = NULL,
+                     lavmcmc        = NULL,
                      thin           = 5,
                      measure        = ""logl""){
     itnums <- sampnums(lavjags, thin = thin)
@@ -584,8 +589,13 @@ make_mcmc <- function(mcmcout){
   if(class(mcmcout) == ""runjags""){
     lavmcmc <- mcmcout$mcmc
   } else {
+    ## for stan: as.array() gives parameters in a different order from summary()
+    ##           so reorder
+    tmpsumm <- rstan::summary(mcmcout)
     lavmcmc <- as.array(mcmcout)
     lavmcmc <- lapply(seq(dim(lavmcmc)[2]), function(x) lavmcmc[,x,])
+    reord <- match(rownames(tmpsumm$summary), colnames(lavmcmc[[1]]))
+    lavmcmc <- lapply(lavmcmc, function(x) x[,reord])
   }
   lavmcmc
 }

---FILE: R/blavaan.R---
@@ -514,7 +514,11 @@ blavaan <- function(...,  # default lavaan arguments
                                     lavsamplestats = lavsamplestats, lavoptions = lavoptions,
                                     lavcache = lavcache, lavdata = lavdata)[1]
             if(save.lvs) {
-                fullpmeans <- summary(make_mcmc(res))[[1]][,""Mean""]
+                if(target == ""jags""){
+                    fullpmeans <- summary(make_mcmc(res))[[1]][,""Mean""]
+                } else {
+                    fullpmeans <- rstan::summary(res)$summary[,""mean""]
+                }
                 cfx <- get_ll(fullpmeans, lavmodel = lavmodel, lavpartable = lavpartable,
                               lavsamplestats = lavsamplestats, lavoptions = lavoptions,
                               lavcache = lavcache, lavdata = lavdata,
@@ -545,24 +549,25 @@ blavaan <- function(...,  # default lavaan arguments
     ## fx is mean ll, where ll is marginal log-likelihood (integrate out lvs)
     if(lavoptions$test != ""none"") {
       cat(""Computing posterior predictives...\n"")
+      lavmcmc <- make_mcmc(res)
       samplls <- samp_lls(res, lavmodel, lavpartable, lavsamplestats,
-                          lavoptions, lavcache, lavdata)
+                          lavoptions, lavcache, lavdata, lavmcmc)
       if(jags.ic) {
         sampkls <- samp_kls(res, lavmodel, lavpartable,
                             lavsamplestats, lavoptions, lavcache,
-                            lavdata, conditional = FALSE)
+                            lavdata, lavmcmc, conditional = FALSE)
       } else {
         sampkls <- NULL
       }
       
       if(save.lvs) {
         csamplls <- samp_lls(res, lavmodel, lavpartable,
                              lavsamplestats, lavoptions, lavcache,
-                             lavdata, conditional = TRUE)
+                             lavdata, lavmcmc, conditional = TRUE)
         if(jags.ic) {
           csampkls <- samp_kls(res, lavmodel, lavpartable,
                               lavsamplestats, lavoptions, lavcache,
-                              lavdata, conditional = TRUE)
+                              lavdata, lavmcmc, conditional = TRUE)
         } else {
           csampkls <- NULL
         }"
ecmerkle,blavaan,6183ab5011f5a82586a8958b0d38dbb1414ccc83,ecmerkle,merklee@missouri.edu,2017-11-27T22:14:53Z,ecmerkle,merklee@missouri.edu,2017-11-27T22:14:53Z,improved decisions about when ov variances can be fixed to 0,DESCRIPTION;R/set_partable.R,False,True,True,False,6,2,8,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.240
+Version: 0.2-5.242
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/set_partable.R---
@@ -343,6 +343,10 @@ set_mv0 <- function(partable, ov.names, ngroups) {
                                partable$rhs == ovn[i] &
                                partable$group == j)
 
+                lvreg <- which(partable$op == ""~"" &
+                               partable$lhs == ovn[i] &
+                               partable$group == j)
+
                 lvcov <- which(partable$op == ""~~"" &
                                (partable$lhs %in% partable$lhs[lvloc] |
                                 partable$rhs %in% partable$lhs[lvloc]) &
@@ -351,7 +355,7 @@ set_mv0 <- function(partable, ov.names, ngroups) {
                 ## If this is an indicator of multiple lvs or
                 ## has covariances attached, we cannot handle it
                 ## in conditional (on lv) form:
-                if(length(lvloc) > 1 | length(lvcov) > 0){
+                if(length(lvloc) + length(lvreg) + length(lvcov) > 1){
                     if(length(mvloc) > 1){
                         stop(""blavaan ERROR: Problem with ov variances fixed to 0."")
                     }"
ecmerkle,blavaan,6eb08fd43548fff1d1a3e2504736ccad8dc0fd19,ecmerkle,merklee@missouri.edu,2017-11-27T19:13:35Z,ecmerkle,merklee@missouri.edu,2017-11-27T19:13:35Z,fix covs and missing data for mauricio's growth model,DESCRIPTION;R/lav_export_stan.R;R/set_priors.R;R/set_stancovs.R,False,True,True,False,18,9,27,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.239
+Version: 0.2-5.240
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_stan.R---
@@ -522,7 +522,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
       obsexo <- matrix(1, ntot, 1)
       nseenexo <- rep(1, ntot)
     }
-    
+
     g <- rep(NA, ntot)
 
     for(k in 1:ngroups){
@@ -602,7 +602,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
 
     if(length(nas) > 0){
       if(ny > 0) y <- y[-nas,]
-      if(n.psi.ov > 0) x <- x[-nas]
+      if(n.psi.ov > 0) x <- x[-nas,]
       g <- g[-nas]
       if(ny > 0){
         obsvar <- obsvar[-nas,]
@@ -613,7 +613,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
       if(n.psi.ov > 0){
         obsvarx <- obsvarx[-nas,]
         misvarx <- misvarx[-nas,]
-        obsexo <- obsexo[-nas,]
+        obsexo <- matrix(obsexo[-nas,]) # converts to numeric
         nseenx <- nseenx[-nas]
         nmisx <- nmisx[-nas]
         nseenexo <- nseenexo[-nas]

---FILE: R/set_priors.R---
@@ -200,14 +200,22 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x, target=""ja
     covs <- unique(partable$lhs[grep("".phant"", partable$lhs)])
     
     if(length(covs) > 0){
-        TXT2 <- paste(TXT2, ""\n\n"", t1, commop, ""Inferential covariances"", sep="""")
+      TXT2 <- paste(TXT2, ""\n\n"", t1, commop, ""Inferential covariances"", sep="""")
         for(i in 1:length(covs)){
             for(k in 1:max(partable$group)){
-                varlocs <- which(partable$lhs == covs[i] &
-                                 partable$op == ""=~"" &
+                varlocs <- which(((partable$lhs == covs[i] &
+                                   partable$op == ""=~"") |
+                                  (partable$rhs == covs[i] &
+                                   partable$op == ""~"")) &
                                  partable$group == k)
                 vartxt <- ""star""
                 vars <- partable$rhs[varlocs]
+                ## catch where we need lhs instead of rhs
+                lhsvars <- grepl("".phant"", vars)
+                if(any(lhsvars)){
+                    vars[lhsvars] <- partable$lhs[varlocs[lhsvars]]
+                }
+
                 if(length(varlocs) == 0){
                     ## lv
                     varlocs <- which(partable$rhs == covs[i] &
@@ -226,7 +234,8 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x, target=""ja
                               grepl(vartxt, partable$mat))
 
                 matname <- ifelse(grepl(""theta"", partable$mat[var1]), ""theta"", ""psi"")
-                phpars <- which(partable$lhs == covs[i] &
+                phpars <- which((partable$lhs == covs[i] |
+                                 partable$rhs == covs[i]) &
                                 partable$group == k)
                 if(length(phpars) == 1){
                     phpars <- which(partable$rhs == covs[i] &

---FILE: R/set_stancovs.R---
@@ -26,7 +26,7 @@ set_stancovs <- function(partable) {
   if(length(covpars) > 0){
     mvcov <- 0
     lvcov <- 0
-    
+
     for(i in 1:length(covpars)){      
       ## Is this constrained equal to a previous parameter?
       eq.const <- FALSE"
ecmerkle,blavaan,02f3f37c8b348a453bbcb8b544eb3af592b046fb,ecmerkle,merklee@missouri.edu,2017-11-27T15:55:43Z,ecmerkle,merklee@missouri.edu,2017-11-27T15:55:43Z,fix bug with 1-indicator lv,R/set_partable.R,False,True,True,False,3,3,6,"---FILE: R/set_partable.R---
@@ -344,8 +344,8 @@ set_mv0 <- function(partable, ov.names, ngroups) {
                                partable$group == j)
 
                 lvcov <- which(partable$op == ""~~"" &
-                               (partable$lhs %in% partable$lhs[lvloc]) |
-                               (partable$rhs %in% partable$lhs[lvloc]) &
+                               (partable$lhs %in% partable$lhs[lvloc] |
+                                partable$rhs %in% partable$lhs[lvloc]) &
                                partable$lhs != partable$rhs)
 
                 ## If this is an indicator of multiple lvs or
@@ -375,7 +375,7 @@ set_mv0 <- function(partable, ov.names, ngroups) {
                     partable$free[lvvar] <- partable$free[mvloc]
                     partable$ustart[lvvar] <- partable$ustart[mvloc]
                     partable$plabel[lvvar] <- partable$plabel[mvloc]
-                    partable$start[lvvar] <- partable$plabel[mvloc]
+                    partable$start[lvvar] <- partable$start[mvloc]
 
                     partable$free[mvloc] <- tmpfree
                     partable$ustart[mvloc] <- tmpustart"
ecmerkle,blavaan,386eb1cf9e091e9d3e7a89e906861c15dd5ab241,ecmerkle,merklee@missouri.edu,2017-11-21T03:32:44Z,ecmerkle,merklee@missouri.edu,2017-11-21T03:32:44Z,fixes for stan defined parameters,R/lav_export_stan.R,False,True,True,False,9,2,11,"---FILE: R/lav_export_stan.R---
@@ -139,7 +139,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   gamind <- ""gamma"" %in% names(parmats[[1]])
 
   ## so it is always a list of lists
-  if(model@Data@ngroups == 1){
+  if(ngroups == 1){
     parmats <- list(g1 = parmats)
     parmattable <- list(g1 = parmattable)
   }
@@ -758,14 +758,21 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     }
     tpdecs <- paste0(tpdecs, t1, ""real mu[N,"", nov, ""];\n"")
 
+    if(any(partable$mat == ""def"")){
+      ndecs <- sum(partable$mat == ""def"" &
+                   partable$group == 1)
+      tpdecs <- paste0(tpdecs, ""\n"", t1, ""real def["", ndecs, "", 1, "",
+                       ngroups, ""];\n"")
+    }
+    
     if(nlv + n.psi.ov > 0){
       tpdecs <- paste0(tpdecs, t1, ""matrix[N,"", (nlv + n.psi.ov), ""] eta;\n"")
       if(nlvno0 < nlv){
         tpdecs <- paste0(tpdecs, t1, ""vector["", (nlv + n.psi.ov),
                          ""] mueta[N];\n"")
       }
       tpdecs <- paste0(tpdecs, ""\n"", t1,
-                       ""eta = rep_matrix(0, N,"", (nlv + n.psi.ov),
+                       ""eta = rep_matrix(0, N, "", (nlv + n.psi.ov),
                        "");\n"")
     }
     "
ecmerkle,blavaan,c785c51c1b4f39342221f1ea96cb23e48b903ab8,ecmerkle,merklee@missouri.edu,2017-11-20T21:24:19Z,ecmerkle,merklee@missouri.edu,2017-11-20T21:24:19Z,fixes to stan covariance + defined parameters,DESCRIPTION;R/set_stancovs.R;R/set_stanpars.R,False,True,True,False,21,8,29,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.233
+Version: 0.2-5.235
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/set_stancovs.R---
@@ -50,7 +50,7 @@ set_stancovs <- function(partable) {
       partable$rhs[tmprows] <- partable$rhs[covpars[i]]
 
       ## Decide on =~ (ov) vs ~ (lv)
-      if(partable$mat[i] == ""theta""){
+      if(partable$mat[covpars[i]] == ""theta""){
         if(!eq.const){
           mvcov <- mvcov + 1
           covidx <- mvcov

---FILE: R/set_stanpars.R---
@@ -105,13 +105,26 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
                 rhstrans <- paste(partable$mat[pvnum], ""free["",
                                   partable$freeparnums[pvnum], ""]"",
                                   sep="""")
-
-                jageq <- partable$rhs[compeq]
-                for(j in 1:length(rhsvars)){
-                    jageq <- gsub(rhsvars[j], rhstrans[j], jageq)
+                ## defined variables involved in another equality
+                defvars <- which(partable$mat[pvnum] == ""def"")
+                if(length(defvars) > 0){
+                    defpt <- pvnum[defvars]
+                    rhstrans[defvars] <- paste0(partable$mat[defpt],
+                                                ""["", partable$row[defpt],
+                                                "","", partable$col[defpt],
+                                                "","", partable$group[defpt],
+                                                ""]"")
                 }
-                ## FIXME? no longer needed?
-                ##jageq <- gsub(""["", ""parvec["", jageq, fixed = TRUE)
+
+                oldjageq <- partable$rhs[compeq]
+                transtab <- as.list(rhstrans)
+                names(transtab) <- rhsvars
+                jagexpr <- parse(text=oldjageq)[[1]]
+                jageq <- do.call(""substitute"", list(jagexpr,
+                                                    transtab))
+                jageq <- paste(deparse(jageq, width.cutoff = 500), collapse="""")
+
+                jageq <- gsub('\""', '', jageq)
 
                 TXT2 <- paste(TXT2, jageq, eolop, sep="""")
             } else {"
ecmerkle,blavaan,12b1ede49411eec1610fa8d24bb87527cf4071ee,ecmerkle,merklee@missouri.edu,2017-11-16T22:24:31Z,ecmerkle,merklee@missouri.edu,2017-11-16T22:24:31Z,"more stan export fixes, dummy lvs, putting cov parameters in right place",DESCRIPTION;R/lav_export_stan.R;R/set_partable.R;R/set_stancovs.R,False,True,True,False,18,20,38,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.231
+Version: 0.2-5.233
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_stan.R---
@@ -27,8 +27,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   ## set up mvs with fixed 0 variances (single indicators of lvs)
   partable <- set_mv0(partable, orig.ov.names, ngroups)
   ## convert covariances to corr * sd1 * sd2
-  partable <- set_stancovs(partable, orig.ov.names, orig.ov.names.x,
-                           dp)
+  partable <- set_stancovs(partable)
 
   ## ensure group parameters are in order, for parameter indexing:
   partable <- partable[order(partable$group),]
@@ -135,24 +134,29 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   ## number of free parameters per type, for stan parameter vectors
   ## (need separated so can use ""lower"" and ""upper"")
   parmats <- lavInspect(model)
+  parmattable <- lavInspect(model, 'partable')
   parconst <- attr(parmats, ""header"")
   gamind <- ""gamma"" %in% names(parmats[[1]])
 
   ## so it is always a list of lists
-  if(model@Data@ngroups == 1) parmats <- list(g1 = parmats)
+  if(model@Data@ngroups == 1){
+    parmats <- list(g1 = parmats)
+    parmattable <- list(g1 = parmattable)
+  }
 
   ## decide whether psi is diagonal and whether beta is
   ## lower/upper triangular, for faster matrix computations
   ## in stan
   diagpsi <- 0L
-  if(""psi"" %in% names(parmats[[1]])){
-    tmppsi <- parmats[[1]]$psi
+  if(""psi"" %in% names(parmattable[[1]])){
+    tmppsi <- parmattable[[1]]$psi
     tmppsi <- tmppsi[lower.tri(tmppsi)]
     if(all(tmppsi == 0)) diagpsi <- 1L
   }
   fullbeta <- 1L
-  if(""beta"" %in% names(parmats[[1]])){
-    tmpbeta <- parmats[[1]]$beta
+
+  if(""beta"" %in% names(parmattable[[1]])){
+    tmpbeta <- parmattable[[1]]$beta
     if(all(tmpbeta[lower.tri(tmpbeta)] == 0) |
        all(tmpbeta[upper.tri(tmpbeta)] == 0)) fullbeta <- 0L
   }
@@ -797,7 +801,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
       TPS <- paste0(TPS, t2, ""thetld[j] = cholesky_decompose("",
                     ""thetld[j]);\n"")
     }
-    if(dumov & !model@Options$fixed.x){
+    if(dumov & !model@Options$fixed.x & !all(parmattable$lambda == 0)){
       TPS <- paste0(TPS, t2, ""alpha[dummylv,1,j] = to_array_1d(inverse((to_matrix(lambda[,,j]) * inverse(diag_matrix(rep_vector(1.0, "", (nlv + n.psi.ov), "")) - to_matrix(beta[,,j])))[dummyov,dummylv]) * to_vector(to_array_1d(alpha[dummylv,1,j])"")
       TPS <- paste0(TPS, ""));\n"")
     }

---FILE: R/set_partable.R---
@@ -357,7 +357,7 @@ set_mv0 <- function(partable, ov.names, ngroups) {
                     }
                     partable$ustart[mvloc] <- .001
                     message(paste(""blavaan NOTE: The variance of variable"", ovn[i],
-                               ""in group"", j, ""has been fixed to .001 instead of 0 (necessary for conditonal model specification).\n""))
+                               ""in group"", j, ""has been fixed to .001 instead of 0 (necessary for conditional model specification).\n""))
                 } else {
                     lvname <- partable$lhs[lvloc]
 

---FILE: R/set_stancovs.R---
@@ -1,4 +1,4 @@
-set_stancovs <- function(partable, ov.names, ov.names.x, dp) {
+set_stancovs <- function(partable) {
   ## Add phantom lvs for covariance parameters
 
   ## first: parameter matrices + indexing
@@ -17,18 +17,13 @@ set_stancovs <- function(partable, ov.names, ov.names.x, dp) {
   
   covpars <- which(partable$op == ""~~"" &
                    partable$lhs != partable$rhs &
-                   partable$free > 0L)# &
-#                   !(partable$lhs %in% ov.names.x))
+                   partable$free > 0L)
 
   blkrow <- rep(NA, length(partable$id))
   partable$rhoidx <- rep(NA, length(partable$id))
 
   ## Only do this if covpars exist
   if(length(covpars) > 0){
-    ## add to model matrices
-    nmvcovs <- sum(partable$lhs[covpars] %in% ov.names)
-    nlvcovs <- length(covpars) - nmvcovs
-
     mvcov <- 0
     lvcov <- 0
     
@@ -53,10 +48,9 @@ set_stancovs <- function(partable, ov.names, ov.names.x, dp) {
 
       partable$lhs[tmprows] <- partable$lhs[covpars[i]]
       partable$rhs[tmprows] <- partable$rhs[covpars[i]]
-      
+
       ## Decide on =~ (ov) vs ~ (lv)
-      if(partable$lhs[covpars[i]] %in% ov.names &
-         !(partable$lhs[covpars[i]] %in% ov.names.x)){
+      if(partable$mat[i] == ""theta""){
         if(!eq.const){
           mvcov <- mvcov + 1
           covidx <- mvcov"
ecmerkle,blavaan,8608fb46f474d9aac256cae5690ce20764e8098b,ecmerkle,merklee@missouri.edu,2017-11-16T04:30:55Z,ecmerkle,merklee@missouri.edu,2017-11-16T04:30:55Z,fixes to stan sem_lv_missing,R/lav_export_stan.R;inst/stanfuns/sem_lv2.stan;inst/stanfuns/sem_lv_missing.stan,False,True,True,False,14,17,31,"---FILE: R/lav_export_stan.R---
@@ -331,14 +331,14 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
       TXT <- paste0(TXT, ""sem_lv2_lpdf("")
     }
 
-    TXT <- paste0(TXT, ""alpha, beta, psi, lambda, "")
+    TXT <- paste0(TXT, ""alpha, beta, psi, "")
     TXT <- paste0(TXT, ifelse(gamind, ""gamma"", ""beta""), "", "")
-    TXT <- paste0(TXT, as.numeric(gamind), "", sampmean, meanx, "")
+    TXT <- paste0(TXT, as.numeric(gamind), "", meanx, "")
     TXT <- paste0(TXT, ""g, "", (nlv + n.psi.ov), "", N, "",
                   ngroups, "", "", diagpsi, "", "", fullbeta, "", "", nlv,
                   "", etaind, "", nlvno0)
     if(miss.psi){
-      TXT <- paste0(TXT, "", nseenx, obsvarx, nseenexo, obsexo"")
+      TXT <- paste0(TXT, "", nseenx, obsvarx"")
     }
     TXT <- paste0(TXT, "");\n"")
   }

---FILE: inst/stanfuns/sem_lv2.stan---
@@ -1,8 +1,7 @@
-  real sem_lv2_lpdf(matrix x, real[,,] alpha, real[,,] B, real[,,] psi, real[,,] lambda, real[,,] gamma, int gamind, real[,] sampmean, real[,] meanx, int[] g, int k, int N, int Ng, int diagpsi, int fullbeta, int nlv, int[] lvind, int nlvno0){
+  real sem_lv2_lpdf(matrix x, real[,,] alpha, real[,,] B, real[,,] psi, real[,,] gamma, int gamind, real[,] meanx, int[] g, int k, int N, int Ng, int diagpsi, int fullbeta, int nlv, int[] lvind, int nlvno0){
     real ldetcomp[Ng];
     matrix[k,k] iden;
     vector[k] alpha2[Ng];
-    matrix[dims(lambda)[1],k] lamib[Ng];
     vector[k] psivecinv[Ng];
     matrix[k,k] psimatinv[Ng];
     matrix[k,k] psimat[Ng];
@@ -41,7 +40,7 @@
         }
         psimatinv[j] = diag_matrix(psivecinv[j]);
 
-        siginv[j] = (iden[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)]] - to_matrix(B[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)],j])') * psimatinv[j] * (iden[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)]] - to_matrix(B[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)],j]));
+        siginv[j,1:(nlvno0+nov),1:(nlvno0+nov)] = (iden[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)]] - to_matrix(B[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)],j])') * psimatinv[j,tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)]] * (iden[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)]] - to_matrix(B[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)],j]));
 
 	if(fullbeta){
 	  ldetcomp[j] = log_determinant(iden[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)]] - to_matrix(B[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)],j]));

---FILE: inst/stanfuns/sem_lv_missing.stan---
@@ -1,6 +1,7 @@
-  real sem_lv_missing_lpdf(matrix x, real[,,] alpha, real[,,] B, real[,,] psi, int[] g, int[] regind, int[] exoind, int k, int N, int Ng, int diagpsi, int fullbeta, int nlv, int nexo, int[] lvind, int nlvno0, int[] nseen, int[,] obsvar, int[] nseenexo, int[,] obsexo){
+  real sem_lv_missing_lpdf(matrix x, real[,,] alpha, real[,,] B, real[,,] psi, real[,,] gamma, int gamind, real[,] meanx, int[] g, int k, int N, int Ng, int diagpsi, int fullbeta, int nlv, int[] lvind, int nlvno0, int[] nseen, int[,] obsvar){
     real ldetcomp[Ng];
     matrix[k,k] iden;
+    vector[k] alpha2[Ng];
     vector[k] psivecinv[Ng];
     matrix[k,k] psimatinv[Ng];
     matrix[k,k] siginv[Ng];
@@ -12,7 +13,11 @@
 
     iden = diag_matrix(rep_vector(1.0, k));
 
-    evlv = sem_mean(alpha, B, g, regind, exoind, k, Ng, nexo);
+    for(j in 1:Ng){
+      alpha2[j] = to_vector(alpha[,1,j]);
+    }
+
+    evlv = sem_mean2(alpha2, B, gamma, g, k, Ng, gamind, meanx);
 
     // TODO speed up by using missingness patterns
     xvectm = 0;
@@ -31,13 +36,6 @@
 	}
       }
 
-      // remove after testing this is needed for reg model with 
-      // 0 constraint, but not coded as exo?
-      //evlv[1,1] = alpha[1,1,1] + to_vector(B[1,2:3,1])' * to_vector(alpha[2:3,1,1]);
-      //if(nseen[i] > 1){
-      //  evlv[g[i],2:nseen[i]] = to_vector(alpha[tmpobs[2:nseen[i]],1,g[i]]);
-      //}
-
       if(diagpsi){
         for(j in 1:(nlvno0 + nseen[i])){
           psivecinv[g[i],tmpobs[j]] = 1/psi[tmpobs[j],tmpobs[j],g[i]];
@@ -61,8 +59,8 @@
 	  ldetcomp[g[i]] = ldetcomp[g[i]] + 2 * log_determinant(iden[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])]] - to_matrix(B[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])],g[i]]));
 	}
 
-	psimatinv[g[i]] = inverse_spd(psimatinv[g[i]]);
-        siginv[g[i],1:(nlvno0+nseen[i]),1:(nlvno0+nseen[i])] = (iden[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])]] - to_matrix(B[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])],g[i]])') * psimatinv[g[i],tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])]] * (iden[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])]] - to_matrix(B[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])],g[i]]));
+	psimatinv[g[i],1:(nlvno0+nseen[i]),1:(nlvno0+nseen[i])] = inverse_spd(psimatinv[g[i],tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])]]);
+        siginv[g[i],1:(nlvno0+nseen[i]),1:(nlvno0+nseen[i])] = (iden[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])]] - to_matrix(B[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])],g[i]])') * psimatinv[g[i],1:(nlvno0+nseen[i]),1:(nlvno0+nseen[i])] * (iden[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])]] - to_matrix(B[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])],g[i]]));
       }
 
       xvec[1:(nlvno0+nseen[i])] = x[i,1:(nlvno0+nseen[i])]';"
ecmerkle,blavaan,882af2f3efcf25a9a816efc359392ef399e52cdf,ecmerkle,merklee@missouri.edu,2017-11-14T22:44:13Z,ecmerkle,merklee@missouri.edu,2017-11-14T22:44:13Z,fix stan sem_mean_lv functioning with dummys,DESCRIPTION;R/lav_export_stan.R;inst/stanfuns/sem_mean_eta.stan,False,True,True,False,10,21,31,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.230
+Version: 0.2-5.231
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_stan.R---
@@ -351,10 +351,10 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     TPS <- paste0(TPS, t1, ""for(i in 1:N) {\n"")
     TPS <- paste0(TPS, t2, ""eta[i,etaind] = etavec[i];\n"", t1, ""}\n"")
     
-    ## TODO alpha entries of non-fixed-zero lvs should be zeroed?
     TPS <- paste0(TPS, t1, ""mueta = sem_mean_eta(alpha, eta, "",
-                  ""beta, g, regind, exoind, "", (nlv + n.psi.ov),
-                  "", N, "", nov.x, "", "", ngroups, "", lvind);\n"")
+                  ""beta, "", ifelse(gamind, ""gamma"", ""beta""),
+                  "", g, "", (nlv + n.psi.ov),
+                  "", N, "", ngroups, "", lvind);\n"")
   }
   
   ## Define mean of each observed variable

---FILE: inst/stanfuns/sem_mean_eta.stan---
@@ -1,31 +1,20 @@
-  vector[] sem_mean_eta(real[,,] alpha, matrix eta, real[,,] B, int[] g, int[] regind, int[] exoind, int k, int N, int nexo, int Ng, int[] lvind){
+  vector[] sem_mean_eta(real[,,] alpha, matrix eta, real[,,] B, real[,,] gamma, int[] g, int k, int N, int Ng, int[] lvind){
     matrix[k,k] iden;
     matrix[k,k] ibinv[Ng];
     vector[k] evlv[N];
-    real alphvec[k,1,1];
+    real alphvec[k,1,Ng];
 
     iden = diag_matrix(rep_vector(1.0, k));
 
     alphvec = alpha;
-    alphvec[lvind,1,1] = rep_array(0,size(lvind));
 
     for(j in 1:Ng){
-      if(nexo == 0){
-        ibinv[j] = inverse(iden - to_matrix(B[,,j]));
-      } else {
-        ibinv[j,1:size(regind),1:size(regind)] = inverse(iden[regind,regind] - to_matrix(B[regind,regind,j]));
-      }
+      ibinv[j] = inverse(iden - to_matrix(B[,,j]));
+      alphvec[lvind,1,j] = rep_array(0,size(lvind));
     }
 
-    if(nexo == 0){
-      for(i in 1:N){
-        evlv[i] = ibinv[g[i]] * (to_vector(alphvec[,1,g[i]]) + to_matrix(B[,,g[i]]) * eta[i,]');
-      }
-    } else {
-      for(i in 1:N){
-        evlv[i,regind] = ibinv[g[i],1:size(regind),1:size(regind)] * (to_vector(alphvec[regind,1,g[i]]) + to_matrix(B[regind,exoind,g[i]]) * eta[i,]');
-        evlv[i,exoind] = to_vector(alphvec[exoind,1,g[i]]);
-      }
+    for(i in 1:N){
+      evlv[i] = ibinv[g[i]] * (to_vector(alphvec[,1,g[i]]) + to_matrix(B[,,g[i]]) * eta[i,]');
     }
 
     return evlv;"
ecmerkle,blavaan,5cac41605c8b25973de33ba6c419ef543a4e86c1,ecmerkle,merklee@missouri.edu,2017-11-14T20:31:34Z,ecmerkle,merklee@missouri.edu,2017-11-14T20:31:34Z,further changes for sem_lv2 and fixed.x,DESCRIPTION;R/lav_export_stan.R,False,True,True,False,3,8,11,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.229
+Version: 0.2-5.230
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_stan.R---
@@ -797,13 +797,8 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
       TPS <- paste0(TPS, t2, ""thetld[j] = cholesky_decompose("",
                     ""thetld[j]);\n"")
     }
-    if(dumov){
-      TPS <- paste0(TPS, t2, ""alpha[dummylv,1,j] = to_array_1d(inverse((to_matrix(lambda[,,j]) * inverse(diag_matrix(rep_vector(1.0, "", (nlv + n.psi.ov), "")) - to_matrix(beta[,,j])))[dummyov,dummylv]) * to_vector("")
-      if(model@Options$fixed.x){
-        TPS <- paste0(TPS, ""sampmean[dummyov,j]"")
-      } else {
-        TPS <- paste0(TPS, ""to_array_1d(alpha[dummylv,1,j])"")
-      }
+    if(dumov & !model@Options$fixed.x){
+      TPS <- paste0(TPS, t2, ""alpha[dummylv,1,j] = to_array_1d(inverse((to_matrix(lambda[,,j]) * inverse(diag_matrix(rep_vector(1.0, "", (nlv + n.psi.ov), "")) - to_matrix(beta[,,j])))[dummyov,dummylv]) * to_vector(to_array_1d(alpha[dummylv,1,j])"")
       TPS <- paste0(TPS, ""));\n"")
     }
     "
ecmerkle,blavaan,dc1900447ed7e158c7bf5b8478d725bc373642ab,ecmerkle,merklee@missouri.edu,2017-11-02T20:48:47Z,ecmerkle,merklee@missouri.edu,2017-11-02T20:48:47Z,fix complex equality constraints with widths over 60char,DESCRIPTION;R/set_priors.R,False,True,True,False,3,2,5,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.226
+Version: 0.2-5.227
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/set_priors.R---
@@ -129,8 +129,9 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x, target=""ja
                 jagexpr <- parse(text=oldjageq)[[1]]
                 jageq <- do.call(""substitute"", list(jagexpr,
                                                     transtab))
+                jageq <- paste(deparse(jageq, width.cutoff = 500), collapse="""")
 
-                jageq <- gsub('\""', '', deparse(jageq))
+                jageq <- gsub('\""', '', jageq)
 
                 TXT2 <- paste(TXT2, jageq, eolop, sep="""")
             } else {"
ecmerkle,blavaan,42941a1f3b1206b97c5fa4586dcd5a2223b82af8,ecmerkle,merklee@missouri.edu,2017-11-02T02:15:02Z,ecmerkle,merklee@missouri.edu,2017-11-02T02:15:02Z,document jags.ic arg and fixes for R CMD check,DESCRIPTION;R/blav_utils.R;R/blavaan.R;man/bcfa.Rd;man/bgrowth.Rd;man/blavaan.Rd;man/bsem.Rd,False,True,True,False,14,10,24,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.225
+Version: 0.2-5.226
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blav_utils.R---
@@ -352,7 +352,7 @@ dist2r <- function(priors, target){
         ##rloc <- paste0(system.file(""R"", package=""rstan""), ""/sysdata"")
         ##lazyLoad(rloc)
         prisplit <- strsplit(priors, ""[, ()]+"")
-        pridist <- sapply(prisplit, head, 1)
+        pridist <- sapply(prisplit, function(x) x[1])
         newdist <- rosetta$RFunction[match(pridist, rosetta$StanFunction)]
         for(i in 1:length(newdist)){
             prisplit[[i]][1] <- newdist[i]

---FILE: R/blavaan.R---
@@ -686,7 +686,7 @@ bcfa <- bsem <- function(..., cp = ""srs"", dp = NULL,
     n.chains = 3, burnin, sample, adapt,
     jagfile = FALSE, jagextra = list(), inits = ""simple"",
     convergence = ""manual"", target = ""jags"", save.lvs = FALSE,
-    seed = NULL, jagcontrol = list()) {
+    jags.ic = FALSE, seed = NULL, jagcontrol = list()) {
 
     dotdotdot <- list(...)
     std.lv <- ifelse(any(names(dotdotdot) == ""std.lv""), dotdotdot$std.lv, FALSE)
@@ -730,7 +730,7 @@ bgrowth <- function(..., cp = ""srs"", dp = NULL,
     n.chains = 3, burnin, sample, adapt,
     jagfile = FALSE, jagextra = list(), inits = ""simple"",
     convergence = ""manual"", target = ""jags"", save.lvs = FALSE,
-    seed = NULL, jagcontrol = list()) {
+    jags.ic = FALSE, seed = NULL, jagcontrol = list()) {
 
     dotdotdot <- list(...)
     std.lv <- ifelse(any(names(dotdotdot) == ""std.lv""), dotdotdot$std.lv, FALSE)

---FILE: man/bcfa.Rd---
@@ -7,8 +7,8 @@ Fit a Confirmatory Factor Analysis (CFA) model.}
 bcfa(..., cp = ""srs"",
      dp = NULL, n.chains = 3, burnin, sample,
      adapt, jagfile = FALSE, jagextra = list(), inits = ""simple"",
-     convergence = ""manual"", target = ""jags"", save.lvs = FALSE, seed = NULL,
-     jagcontrol = list())
+     convergence = ""manual"", target = ""jags"", save.lvs = FALSE,
+     jags.ic = FALSE, seed = NULL, jagcontrol = list())
 }
 \arguments{
 \item{...}{Default lavaan arguments.  See \code{\link{lavaan}}.}
@@ -59,6 +59,7 @@ bcfa(..., cp = ""srs"",
 \item{target}{Desired MCMC package (currently, only \code{jags} is
   available).}
 \item{save.lvs}{Should sample latent variables (factor scores) be saved? Logical; defaults to FALSE}
+\item{jags.ic}{Should DIC be computed the JAGS way, in addition to the BUGS way? Logical; defaults to FALSE}
 \item{seed}{A vector of length \code{n.chains} containing random
   seeds for the MCMC run. If \code{NULL}, seeds will be chosen randomly.}
 \item{jagcontrol}{A list containing additional parameters passed to

---FILE: man/bgrowth.Rd---
@@ -7,7 +7,7 @@ Fit a Growth Curve model.}
 bgrowth(..., cp = ""srs"", dp = NULL, n.chains = 3,
 burnin, sample, adapt, jagfile = FALSE, jagextra = list(), 
 inits = ""simple"", convergence = ""manual"", target = ""jags"",
-save.lvs = FALSE, seed = NULL, jagcontrol = list())
+save.lvs = FALSE, jags.ic = FALSE, seed = NULL, jagcontrol = list())
 }
 \arguments{
 \item{...}{Default lavaan arguments.  See \code{\link{lavaan}}.}
@@ -58,6 +58,7 @@ save.lvs = FALSE, seed = NULL, jagcontrol = list())
 \item{target}{Desired MCMC package (currently, only \code{jags} is
   available).}
 \item{save.lvs}{Should sample latent variables (factor scores) be saved? Logical; defaults to FALSE}
+\item{jags.ic}{Should DIC be computed the JAGS way, in addition to the BUGS way? Logical; defaults to FALSE}
 \item{seed}{A vector of length \code{n.chains} containing random
   seeds for the MCMC run. If \code{NULL}, seeds will be chosen randomly.}
 \item{jagcontrol}{A list containing additional parameters passed to

---FILE: man/blavaan.Rd---
@@ -8,7 +8,7 @@ blavaan(..., cp = ""srs"",
     dp = NULL, n.chains = 3, burnin, sample,
     adapt, jagfile = FALSE, jagextra = list(), inits = ""simple"",
     convergence = ""manual"", target = ""jags"", save.lvs = FALSE,
-    seed = NULL, jagcontrol = list())
+    jags.ic = FALSE, seed = NULL, jagcontrol = list())
 }
 \arguments{
 \item{...}{Default lavaan arguments.  See \code{\link{lavaan}}.}
@@ -58,6 +58,7 @@ blavaan(..., cp = ""srs"",
 \item{target}{Desired MCMC package (currently, only \code{jags} is
   available).}
 \item{save.lvs}{Should sample latent variables (factor scores) be saved? Logical; defaults to FALSE}
+\item{jags.ic}{Should DIC be computed the JAGS way, in addition to the BUGS way? Logical; defaults to FALSE}
 \item{seed}{A vector of length \code{n.chains} containing random
   seeds for the MCMC run. If \code{NULL}, seeds will be chosen randomly.}
 \item{jagcontrol}{A list containing additional parameters passed to

---FILE: man/bsem.Rd---
@@ -7,8 +7,8 @@ Fit a Structural Equation Model (SEM).}
 bsem(..., cp = ""srs"",
      dp = NULL, n.chains = 3, burnin, sample,
      adapt, jagfile = FALSE, jagextra = list(), inits = ""simple"",
-     convergence = ""manual"", target = ""jags"", save.lvs = FALSE, seed = NULL,
-     jagcontrol = list())
+     convergence = ""manual"", target = ""jags"", save.lvs = FALSE,
+     jags.ic = FALSE, seed = NULL, jagcontrol = list())
 }
 \arguments{
 \item{...}{Default lavaan arguments.  See \code{\link{lavaan}}.}
@@ -59,6 +59,7 @@ bsem(..., cp = ""srs"",
 \item{target}{Desired MCMC package (currently, only \code{jags} is
   available).}
 \item{save.lvs}{Should sample latent variables (factor scores) be saved? Logical; defaults to FALSE}
+\item{jags.ic}{Should DIC be computed the JAGS way, in addition to the BUGS way? Logical; defaults to FALSE}
 \item{seed}{A vector of length \code{n.chains} containing random
   seeds for the MCMC run. If \code{NULL}, seeds will be chosen randomly.}
 \item{jagcontrol}{A list containing additional parameters passed to"
ecmerkle,blavaan,d27b073d04a8d8af061a8ff2eaa784e402a088dd,ecmerkle,merklee@missouri.edu,2017-11-01T15:05:11Z,ecmerkle,merklee@missouri.edu,2017-11-01T15:05:11Z,fix do.fit=FALSE with new neff check,DESCRIPTION;R/blavaan.R,False,True,True,False,5,3,8,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.224
+Version: 0.2-5.225
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blavaan.R---
@@ -672,8 +672,10 @@ blavaan <- function(...,  # default lavaan arguments
         lavInspect(blavaan, ""post.check"")
     }
 
-    if(any(blavInspect(blavaan, 'neff') < 100) & lavoptions$warn){
-        warning(""blavaan WARNING: Small effective sample sizes (< 100) for some parameters."")
+    if(jag.do.fit & lavoptions$warn){
+        if(any(blavInspect(blavaan, 'neff') < 100)){
+            warning(""blavaan WARNING: Small effective sample sizes (< 100) for some parameters."")
+        }
     }
     
     blavaan"
ecmerkle,blavaan,aa4b8ef8d752eeace6334c7aa6ef129334b248f5,ecmerkle,merklee@missouri.edu,2017-10-30T19:59:27Z,ecmerkle,merklee@missouri.edu,2017-10-30T19:59:27Z,fix margloglik() under complex equality constraints,DESCRIPTION;R/margloglik.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.222
+Version: 0.2-5.223
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/margloglik.R---
@@ -15,7 +15,7 @@ margloglik <- function(lavpartable, lavmodel, lavoptions,
     lavpartable$pxnames[lavpartable$freeparnums == 0] <- NA
   }
   eqpars <- lavpartable$rhs[lavpartable$op == ""==""]
-  fixpars <- which(lavpartable$free == 0)
+  fixpars <- which(lavpartable$free == 0 | lavpartable$prior == """")
   urows <- 1:length(lavpartable$pxnames)
   urows <- urows[!is.na(lavpartable$pxnames) &
                  !(lavpartable$plabel %in% eqpars) &"
ecmerkle,blavaan,c1c3156919edb6b301b3c7ef3eb8a3404815d1b6,ecmerkle,merklee@missouri.edu,2017-10-26T17:39:55Z,ecmerkle,merklee@missouri.edu,2017-10-26T17:39:55Z,improved note about ov variances fixed to 0,DESCRIPTION;R/set_partable.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.219
+Version: 0.2-5.221
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/set_partable.R---
@@ -357,7 +357,7 @@ set_mv0 <- function(partable, ov.names, ngroups) {
                     }
                     partable$ustart[mvloc] <- .001
                     message(paste(""blavaan NOTE: The variance of variable"", ovn[i],
-                               ""in group"", j, ""has been fixed to .001 instead of 0 (necessary for JAGS).\n""))
+                               ""in group"", j, ""has been fixed to .001 instead of 0 (necessary for conditonal model specification).\n""))
                 } else {
                     lvname <- partable$lhs[lvloc]
 "
ecmerkle,blavaan,83b6d03652f315e07c0c1d87e09cbc2542dc95b3,ecmerkle,merklee@missouri.edu,2017-10-16T20:59:55Z,ecmerkle,merklee@missouri.edu,2017-10-16T20:59:55Z,fix jags problems with equality constraints on variances,DESCRIPTION;R/set_priors.R,False,True,True,False,6,4,10,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.218
+Version: 0.2-5.219
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/set_priors.R---
@@ -61,9 +61,6 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x, target=""ja
                 partable$mat[i] <- rhoinf[[1]][1]
                 partable$row[i] <- rhoinf[[1]][2]
                 partable$col[i] <- rhoinf[[1]][3]
-                if(partable$free[i] == 0){
-                    partable$ustart[i] <- (as.numeric(partable$ustart[i]) + 1)/2
-                }
             }
           
             ## start parameter assignment
@@ -86,6 +83,11 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x, target=""ja
                 }
             } else if(length(eqpar) > 0){
                 eqpar <- which(partable$plabel == partable$lhs[eqpar])
+                ## in case it is an ""expanded"" variance
+                if(length(eqpar) > 1){
+                    if(length(eqpar) > 2) stop(""blavaan ERROR: problem with parameter equality constraints"")
+                    eqpar <- eqpar[which(partable$freeparnums[eqpar] > 0)]
+                }
                 if(partable$freeparnums[eqpar] == 0){
                     eqtxt <- paste(partable$mat[eqpar], ""["",
                                    partable$row[eqpar], "","","
ecmerkle,blavaan,c16a30db988d925a40045c10b962a948fd7f0d48,ecmerkle,merklee@missouri.edu,2017-10-13T15:53:08Z,ecmerkle,merklee@missouri.edu,2017-10-13T15:53:08Z,fix burnin/sample/adapt args,DESCRIPTION;R/blavaan.R,False,True,True,False,63,25,88,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.214
+Version: 0.2-5.215
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blavaan.R---
@@ -27,6 +27,21 @@ blavaan <- function(...,  # default lavaan arguments
     # default priors
     if(length(dp) == 0) dp <- dpriors(target = target)
 
+    # burnin/sample/adapt if not supplied (should only occur for direct
+    # blavaan call
+    sampargs <- c(""burnin"", ""sample"", ""adapt"")
+    suppargs <- which(!(sampargs %in% names(mc)))
+    if(length(suppargs) > 0){
+        if(target == ""jags""){
+            defiters <- c(4000L, 10000L, 1000L)
+        } else {
+            defiters <- c(500L, 1000L, 1000L)
+        }
+        for(i in 1:length(suppargs)){
+            assign(sampargs[suppargs[i]], defiters[suppargs[i]])
+        }
+    }
+
     # ensure stan is here
     if(target == ""stan""){
       # could also use requireNamespace + attachNamespace
@@ -108,32 +123,23 @@ blavaan <- function(...,  # default lavaan arguments
     if(""debug"" %in% dotNames) {
         if(dotdotdot$debug)  {
             ## short burnin/sample
-            mc$burnin <- 1000
-            mc$sample <- 1000
+            burnin <- 1000
+            sample <- 1000
         }
     }
-    jarg <- c(""burnin"", ""sample"", ""adapt"")
-    mcj <- match(jarg, names(mc), 0L)
-    if(any(mcj > 0)){
-        mfj <- as.list(mc[mcj])
-        if(convergence == ""auto""){
-            jarg <- c(""startburnin"", ""startsample"", ""adapt"")
-            names(mfj) <- jarg[mcj > 0]
-        }
-        if(target == ""stan""){
-            jarg <- c(""warmup"", ""iter"", ""adapt"")
-            names(mfj) <- jarg[mcj > 0]
-            ## stan iter argument includes warmup:
-            if(mcj[1] > 0 & mcj[2] > 0) mfj$iter <- mfj$iter + mfj$warmup
-            if(""adapt"" %in% names(mfj)){
-              mfj <- mfj[-which(names(mfj) == ""adapt"")]
-            }
-        }
-        if(""sample"" %in% names(mc)){
-            if(mc$sample*n.chains/5 < 1000) warning(""blavaan WARNING: small sample drawn, proceed with caution.\n"")
-        }
-    } else {
-        mfj <- list()
+
+    mfj <- list(burnin = burnin, sample = sample, adapt = adapt)
+
+    if(mfj$sample*n.chains/5 < 1000) warning(""blavaan WARNING: small sample drawn, proceed with caution.\n"")
+    
+    if(convergence == ""auto""){
+        names(mfj) <- c(""startburnin"", ""startsample"", ""adapt"")
+    }
+    if(target == ""stan""){
+        names(mfj) <- c(""warmup"", ""iter"", ""adapt"")
+        ## stan iter argument includes warmup:
+        mfj$iter <- mfj$warmup + mfj$iter
+        mfj <- mfj[-which(names(mfj) == ""adapt"")]
     }
 
     if(target == ""jags""){
@@ -658,6 +664,22 @@ bcfa <- bsem <- function(..., cp = ""srs"", dp = NULL,
     mc$auto.delta      = TRUE
     mc[[1L]] <- quote(blavaan)
 
+    ## change defaults depending on jags vs stan
+    sampargs <- c(""burnin"", ""sample"", ""adapt"")
+    if(target == ""jags""){
+        defiters <- c(4000L, 10000L, 1000L)
+    } else {
+        defiters <- c(500L, 1000L, 1000L)
+    }
+    suppargs <- which(!(sampargs %in% names(mc)))
+
+    if(length(suppargs) > 0){
+        for(i in 1:length(suppargs)){
+            mc[[(length(mc)+1)]] <- defiters[suppargs[i]]
+            names(mc)[length(mc)] <- sampargs[suppargs[i]]
+        }
+    }
+
     eval(mc, parent.frame())
 }
 
@@ -684,5 +706,21 @@ bgrowth <- function(..., cp = ""srs"", dp = NULL,
     mc$auto.delta      = TRUE
     mc[[1L]] <- quote(blavaan)
 
+    ## change defaults depending on jags vs stan
+    sampargs <- c(""burnin"", ""sample"", ""adapt"")
+    if(target == ""jags""){
+        defiters <- c(4000L, 10000L, 1000L)
+    } else {
+        defiters <- c(500L, 1000L, 1000L)
+    }
+    suppargs <- which(!(sampargs %in% names(mc)))
+
+    if(length(suppargs) > 0){
+        for(i in 1:length(suppargs)){
+            mc[[(length(mc)+1)]] <- defiters[suppargs[i]]
+            names(mc)[length(mc)] <- sampargs[suppargs[i]]
+        }
+    }
+    
     eval(mc, parent.frame())
 }"
ecmerkle,blavaan,6a854cf1cb304b0d21092e0bdfa198a733b2d2fe,ecmerkle,merklee@missouri.edu,2017-10-13T01:48:47Z,ecmerkle,merklee@missouri.edu,2017-10-13T01:48:47Z,small fix so summary() works on jags side,DESCRIPTION;R/blavaan.R,False,True,True,False,2,6,8,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.213
+Version: 0.2-5.214
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blavaan.R---
@@ -453,11 +453,7 @@ blavaan <- function(...,  # default lavaan arguments
         if(jag.do.fit){
             lavmodel <- lav_model_set_parameters(lavmodel, x = x)
             if(target == ""jags""){
-                if(convergence == ""auto""){
-                    attr(x, ""iterations"") <- res$sample
-                } else {
-                    attr(x, ""iterations"") <- rjarg$sample
-                }
+                attr(x, ""iterations"") <- res$sample
                 sample <- res$sample
                 burnin <- res$burnin
             } else {"
ecmerkle,blavaan,43f8b3c71841f5f3d9477e3aa264e1a9cf5eea4f,ecmerkle,merklee@missouri.edu,2017-10-03T17:27:37Z,ecmerkle,merklee@missouri.edu,2017-10-03T17:27:37Z,bug fix when jagextra includes reserved monitors,DESCRIPTION;R/blavaan.R,False,True,True,False,10,3,13,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.212
+Version: 0.2-5.213
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blavaan.R---
@@ -578,9 +578,16 @@ blavaan <- function(...,  # default lavaan arguments
         lavpartable$logBF <- SDBF(lavpartable)
     }
 
-    ## add monitors in jagextra as defined variables
+    ## add monitors in jagextra as defined variables (except reserved monitors)
     if(length(jagextra$monitor) > 0){
-      lavpartable <- add_monitors(lavpartable, lavjags, jagextra)
+        reservemons <- which(jagextra$monitor %in% c('deviance', 'pd', 'popt',
+                                                     'dic', 'ped', 'full.pd'))
+
+        if(length(reservemons) < length(jagextra$monitor)){
+            jecopy <- jagextra
+            jecopy$monitor <- jecopy$monitor[-reservemons]
+            lavpartable <- add_monitors(lavpartable, lavjags, jecopy)
+        }
     }
 
     ## 9b. move some stuff from lavfit to optim, for lavaan 0.5-21"
ecmerkle,blavaan,519ac580a51fc2bae03089baa958419764801238,ecmerkle,merklee@missouri.edu,2017-09-27T02:55:01Z,ecmerkle,merklee@missouri.edu,2017-09-27T02:55:01Z,"improve stan functionality: lvs fixed to 0, exo, missing data",DESCRIPTION;R/blavaan.R;R/lav_export_stan.R;inst/stanfuns/sem_lv.stan;inst/stanfuns/sem_lv_missing.stan;inst/stanfuns/sem_mean.stan;inst/stanfuns/sem_mean_eta.stan,False,True,True,False,208,83,291,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.210
+Version: 0.2-5.211
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blavaan.R---
@@ -491,7 +491,10 @@ blavaan <- function(...,  # default lavaan arguments
     lavimplied <- lav_model_implied(lavmodel)
     if(jag.do.fit & n.chains > 1){
       ## this also checks convergence of monitors from jagextra, which may not be optimal
-      if(any(lavpartable$psrf[!is.na(lavpartable$psrf)] > 1.2)) attr(x, ""converged"") <- FALSE
+      psrfrows <- which(!is.na(lavpartable$psrf) &
+                        !is.na(lavpartable$free) &
+                        lavpartable$free > 0)
+      if(any(lavpartable$psrf[psrfrows] > 1.2)) attr(x, ""converged"") <- FALSE
 
       ## warn if psrf is large
       if(!attr(x, ""converged"") && lavoptions$warn) {

---FILE: R/lav_export_stan.R---
@@ -52,8 +52,8 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   lv.nox <- vnames$lv.nox[[1]]
   lv.names <- vnames$lv[[1]]
   ## ensure that lv.x names always come first (so we can possibly use dmnorm)
-  lv.names <- c(lv.names[lv.names %in% orig.lv.names.x],
-                lv.names[!(lv.names %in% orig.lv.names.x)])
+  #lv.names <- c(lv.names[lv.names %in% orig.lv.names.x],
+  #              lv.names[!(lv.names %in% orig.lv.names.x)])
   nlv <- length(lv.names)
   
   ## check that variables are the same in all groups:
@@ -82,6 +82,23 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   TXT2 <- """"
   TXT <- paste(""model {\n"", sep="""")
 
+  ## lvs with variances fixed to 0
+  lv0 <- which(partable$op == ""~~"" &
+               partable$lhs %in% lv.names &
+               partable$rhs == partable$lhs &
+               partable$group == 1 &
+               partable$free == 0 &
+               partable$ustart == 0)
+  if(length(lv0) > 0){
+    lv0.names <- partable$lhs[lv0]
+    lv0.idx <- which(lv.names %in% lv0.names)
+    nlvno0 <- nlv - length(lv0.idx)
+  } else {
+    lv0.names <- NULL
+    lv0.idx <- NULL
+    nlvno0 <- nlv
+  }
+
   ## TODO if nov.x > 0, find the submatrix of psi that
   ## contains the vars/covs associated with ov.names.x
   nmvs <- nov
@@ -211,9 +228,9 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
                      nlrho, ""] lvrhofree;\n"")
   }
 
-  if(nlv > 0){
-    parblk <- paste0(parblk, t1, ""matrix[N, "", nlv, ""] eta"", eolop,
-                     ""\n"")
+  if(nlvno0 > 0){
+    parblk <- paste0(parblk, t1, ""matrix[N, "", nlvno0, ""] etavec"",
+                     eolop, ""\n"")
   }
   parblk <- paste0(parblk, ""}\n\n"")                     
 
@@ -239,13 +256,34 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     xnames <- c(ov.names.x, vnames$eqs.x[[1]])
     exoind <- which(ov.names[xind] %in% xnames)
     regind <- which(!(ov.names[xind] %in% xnames))
-    if(nlv > 0){
-      regind <- c(1:nlv, (nlv+regind))
-      exoind <- nlv + exoind
+    etaind <- 1:nlv
+    if(nlv > 0 & length(lv0.idx) < nlv){
+      if(length(lv0.idx) > 0){
+        nlvno0 <- nlv - length(lv0.idx)
+        regind <- c((1:nlv)[-lv0.idx], (nlvno0+regind))
+        exoind <- nlvno0 + exoind
+        etaind <- etaind[-lv0.idx]
+      } else {
+        nlvno0 <- nlv
+        regind <- c(1:nlv, (nlv+regind))
+        exoind <- nlv + exoind
+      }
     }
+    lvindall <- c(regind, exoind)
   } else {
-    exoind <- rep(0,length(xind))
     regind <- xind
+    exoind <- rep(0,length(xind))
+    lvindall <- regind
+    etaind <- exoind
+    if(nlv > 0){
+      if(length(lv0.idx) < nlv & length(lv0.idx) > 0){
+        nlvno0 <- nlv - length(lv0.idx)
+        etaind <- (1:nlv)[-lv0.idx]
+      } else {
+        nlvno0 <- nlv
+        etaind <- 1:nlv
+      }
+    }
   }
   
   ## missingness of ovs split by whether or not they appear
@@ -263,9 +301,6 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     }
   }
   
-  if((nlv + n.psi.ov) > 0){
-    TXT <- paste0(TXT, t1, ""matrix[N,"", (nlv + n.psi.ov), ""] etamat;\n"")
-  }
   TXT <- paste0(TXT, t1, ""for(i in 1:N) {\n"")
 
   if(ny > 0){
@@ -284,42 +319,63 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     }
   }
 
-  if(nlv > 0){
-    TXT <- paste0(TXT, t2, ""etamat[i,1:"", nlv, ""] = eta[i];\n"")
-  }
-  if(n.psi.ov > 0){
-    TXT <- paste0(TXT, t2, ""etamat[i,"", (nlv+1), "":"",
-                  (nlv + n.psi.ov), ""] = x[i]';\n"")
-  }
+
   TXT <- paste0(TXT, t1, ""}\n\n"")
 
   if((nlv + n.psi.ov) > 0){
-    TXT <- paste0(TXT, t1, ""etamat ~ "")
+    TXT <- paste0(TXT, t1, ""eta ~ "")
 
     if(miss.psi){
       TXT <- paste0(TXT, ""sem_lv_missing_lpdf("")
     } else {
       TXT <- paste0(TXT, ""sem_lv_lpdf("")
     }
-    TXT <- paste0(TXT, ""alpha, beta, psi, g, regind, exoind, "",
+
+    TXT <- paste0(TXT, ""alpha, beta, psi, "")
+    
+    TXT <- paste0(TXT, ""g, regind, exoind, "",
                   (nlv + n.psi.ov), "", N, "", ngroups, "", "",
-                  diagpsi, "", "", fullbeta, "", "", nlv, "", "", nov.x)
+                  diagpsi, "", "", fullbeta, "", "", nlv, "", "", nov.x,
+                  "", etaind, "", nlvno0)
     if(miss.psi){
       TXT <- paste0(TXT, "", nseenx, obsvarx, nseenexo, obsexo"")
     }
     TXT <- paste0(TXT, "");\n"")
   }
-  
+
   ## for missing==""fi"", to model variables on rhs of regression
   ovreg <- unique(regressions$rhs[regressions$rhs %in% ov.names])
   ovcol <- which(ov.names %in% ovreg)
 
+  if(nlvno0 < nlv){
+    TPS <- paste0(TPS, t1, ""for(i in 1:N) {\n"")
+    TPS <- paste0(TPS, t2, ""eta[i,etaind] = etavec[i];\n"", t1, ""}\n"")
+    
+    ## TODO alpha entries of non-fixed-zero lvs should be zeroed?
+    TPS <- paste0(TPS, t1, ""mueta = sem_mean_eta(alpha, eta, "",
+                  ""beta, g, regind, exoind, "", (nlv + n.psi.ov),
+                  "", N, "", nov.x, "", "", ngroups, "", lvind);\n"")
+  }
+  
   ## Define mean of each observed variable
   ## This assumes that the data matrix passed to jags
   ## is ordered in the same way as ov.names.nox.
   ## data would be cbind(ov.names.nox, ov.names.x)
   TPS <- paste(TPS, t1, commop, ""mu definitions\n"", t1,
-               ""for(i in 1:N) {"", sep="""")
+               ""for(i in 1:N) {\n"", sep="""")
+
+  if(nlvno0 < nlv){
+    #TPS <- paste0(TPS, t2, ""eta[i,etaind] = etavec[i];\n"")
+    TPS <- paste0(TPS, t2, ""eta[i,eta0ind] = mueta[i,eta0ind]';\n"")
+  } else if(nlv > 0){
+    TPS <- paste0(TPS, t2, ""eta[i,1:"", nlv, ""] = etavec[i];\n"")
+  }
+
+  if(n.psi.ov > 0){
+    TPS <- paste0(TPS, t2, ""eta[i,"", (nlv+1), "":"", (nlv + n.psi.ov),
+                  ""] = x[i]';\n"")
+  }
+  
   if(ny > 0) {
     for(i in 1:ny) {
       ov.idx <- i
@@ -408,7 +464,13 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   ## Now add data if we have it
   datablk <- paste0(""data{\n"", t1, ""int N;\n"", t1, ""int g[N];\n"",
                     t1, ""int regind["", length(regind), ""];\n"",
-                    t1, ""int exoind["", length(exoind), ""];\n"")
+                    t1, ""int exoind["", length(exoind), ""];\n"",
+                    t1, ""int lvind["", length(lvindall), ""];\n"",
+                    t1, ""int etaind["", length(etaind), ""];\n"")
+  if(length(lv0.idx) > 0){
+    datablk <- paste0(datablk, t1, ""int eta0ind["", length(lv0.idx),
+                      ""];\n"")
+  }
 
   if(!is.null(lavdata) | class(model)[1]==""lavaan""){
     if(class(model)[1] == ""lavaan"") lavdata <- model@Data
@@ -560,7 +622,11 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     }
 
     standata <- list(g=g, N=ntot, regind=array(regind),
-                     exoind=array(exoind))
+                     exoind=array(exoind), lvind=array(lvindall),
+                     etaind=array(etaind))
+    if(length(lv0.idx) > 0){
+      standata <- c(standata, list(eta0ind=array(lv0.idx)))
+    }
     if(ny > 0) standata <- c(standata, list(y=y))
     if(n.psi.ov > 0) standata <- c(standata, list(x=x))
     if(missflag){
@@ -658,6 +724,17 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     }
     tpdecs <- paste0(tpdecs, t1, ""real mu[N,"", nov, ""];\n"")
 
+    if(nlv + n.psi.ov > 0){
+      tpdecs <- paste0(tpdecs, t1, ""matrix[N,"", (nlv + n.psi.ov), ""] eta;\n"")
+      if(nlvno0 < nlv){
+        tpdecs <- paste0(tpdecs, t1, ""vector["", (nlv + n.psi.ov),
+                         ""] mueta[N];\n"")
+      }
+      tpdecs <- paste0(tpdecs, ""\n"", t1,
+                       ""eta = rep_matrix(0, N,"", (nlv + n.psi.ov),
+                       "");\n"")
+    }
+    
     ## if no beta, define it as 0 matrix
     if(!(""beta"" %in% tpnames)){
         matrows <- c(matrows, beta = matrows[[""psi""]])
@@ -705,6 +782,10 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
 
   funblk <- ""functions{\n""
   if((nlv + n.psi.ov) > 0){
+    funblk <- paste0(funblk, t1, ""#include 'sem_mean.stan' \n"")
+    if(nlvno0 < nlv){
+      funblk <- paste0(funblk, t1, ""#include 'sem_mean_eta.stan' \n"")
+    }
     if(miss.psi){
       funblk <- paste0(funblk, t1, ""#include 'sem_lv_missing.stan' \n"")
     } else {

---FILE: inst/stanfuns/sem_lv.stan---
@@ -1,61 +1,67 @@
-  real sem_lv_lpdf(matrix x, real[,,] alpha, real[,,] B, real[,,] psi, int[] g, int[] regind, int[] exoind, int k, int N, int Ng, int diagpsi, int fullbeta, int nlv, int nexo){
+  real sem_lv_lpdf(matrix x, real[,,] alpha, real[,,] B, real[,,] psi, int[] g, int[] regind, int[] exoind, int k, int N, int Ng, int diagpsi, int fullbeta, int nlv, int nexo, int[] lvind, int nlvno0){
     real ldetcomp[Ng];
     matrix[k,k] iden;
     vector[k] psivecinv[Ng];
     matrix[k,k] psimatinv[Ng];
     matrix[k,k] siginv[Ng];
     vector[k] xvec;
     vector[k] evlv[Ng];
+    int tmpobs[k];
     real xvectm;
     real ldetsum;
+    int nov;
+
+    nov = k - nlv;
 
     iden = diag_matrix(rep_vector(1.0, k));
 
-    for(j in 1:Ng){
-      if(nexo == 0){
-        evlv[j] = inverse(iden - to_matrix(B[,,j])) * (to_vector(alpha[,1,j]) + to_matrix(B[,,j]) * to_vector(alpha[,1,j]));
-      } else {
-        evlv[j,regind] = inverse(iden[regind,regind] - to_matrix(B[regind,regind,j])) * (to_vector(alpha[regind,1,j]) + to_matrix(B[regind,exoind,j]) * to_vector(alpha[exoind,1,j]));
-        evlv[j,exoind] = to_vector(alpha[exoind,1,j]);
+    evlv = sem_mean(alpha, B, g, regind, exoind, k, Ng, nexo);
+
+    if(nlvno0 > 0){
+      tmpobs[1:nlvno0] = lvind;
+    }
+    if(nov > 0){
+      for(j in 1:nov){
+        tmpobs[nlvno0+j] = nlvno0 + j;
       }
     }
 
     if(diagpsi){
       for(j in 1:Ng){
-        for(i in 1:k){
-          psivecinv[j,i] = 1/psi[i,i,j];
+        for(i in 1:(nlvno0+nov)){
+          psivecinv[j,tmpobs[i]] = 1/psi[tmpobs[i],tmpobs[i],j];
         }
         psimatinv[j] = diag_matrix(psivecinv[j]);
 
-        siginv[j] = (iden - to_matrix(B[,,j])') * psimatinv[j] * (iden - to_matrix(B[,,j]));
+        siginv[j] = (iden[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)]] - to_matrix(B[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)],j])') * psimatinv[j] * (iden[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)]] - to_matrix(B[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)],j]));
 
 	if(fullbeta){
-	  ldetcomp[j] = log_determinant(iden - to_matrix(B[,,j]));
-	  ldetcomp[j] = ldetcomp[j] + ldetcomp[j] + sum(log(diagonal(to_matrix(psi[,,j]))));
+	  ldetcomp[j] = log_determinant(iden[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)]] - to_matrix(B[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)],j]));
+	  ldetcomp[j] = ldetcomp[j] + ldetcomp[j] + sum(log(diagonal(to_matrix(psi[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)],j]))));
 	} else {
-          ldetcomp[j] = sum(log(diagonal(to_matrix(psi[,,j]))));
+          ldetcomp[j] = sum(log(diagonal(to_matrix(psi[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)],j]))));
   	}
       }
     } else {
       for(j in 1:Ng){
         psimatinv[j] = to_matrix(psi[,,j]);
 	psimatinv[j] = psimatinv[j] + psimatinv[j]' - diag_matrix(diagonal(psimatinv[j]));
 
-	ldetcomp[j] = log_determinant(psimatinv[j]);
+	ldetcomp[j] = log_determinant(psimatinv[j,tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)]]);
 	if(fullbeta){
-	  ldetcomp[j] = ldetcomp[j] + 2 * log_determinant(iden - to_matrix(B[,,j]));
+	  ldetcomp[j] = ldetcomp[j] + 2 * log_determinant(iden[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)]] - to_matrix(B[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)],j]));
 	}
 
-	psimatinv[j] = inverse_spd(psimatinv[j]);
-        siginv[j] = (iden - to_matrix(B[,,j])') * psimatinv[j] * (iden - to_matrix(B[,,j]));
+	psimatinv[j,1:(nlvno0+nov),1:(nlvno0+nov)] = inverse_spd(psimatinv[j,tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)]]);
+        siginv[j,1:(nlvno0+nov),1:(nlvno0+nov)] = (iden[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)]] - to_matrix(B[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)],j])') * psimatinv[j,1:(nlvno0+nov),1:(nlvno0+nov)] * (iden[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)]] - to_matrix(B[tmpobs[1:(nlvno0+nov)],tmpobs[1:(nlvno0+nov)],j]));
       }
     }
 
     xvectm = 0;
     ldetsum = 0;
     for(i in 1:N){
       xvec = x[i,]';
-      xvectm = xvectm + (xvec - evlv[g[i],])' * siginv[g[i]] * (xvec - evlv[g[i],]);
+      xvectm = xvectm + (xvec[tmpobs[1:(nlvno0+nov)]] - evlv[g[i],tmpobs[1:(nlvno0+nov)]])' * siginv[g[i],1:(nlvno0+nov),1:(nlvno0+nov)] * (xvec[tmpobs[1:(nlvno0+nov)]] - evlv[g[i],tmpobs[1:(nlvno0+nov)]]);
       ldetsum = ldetsum + ldetcomp[g[i]];
     }
 

---FILE: inst/stanfuns/sem_lv_missing.stan---
@@ -1,4 +1,4 @@
-  real sem_lv_missing_lpdf(matrix x, real[,,] alpha, real[,,] B, real[,,] psi, int[] g, int[] regind, int[] exoind, int k, int N, int Ng, int diagpsi, int fullbeta, int nlv, int nexo, int[] nseen, int[,] obsvar, int[] nseenexo, int[,] obsexo){
+  real sem_lv_missing_lpdf(matrix x, real[,,] alpha, real[,,] B, real[,,] psi, int[] g, int[] regind, int[] exoind, int k, int N, int Ng, int diagpsi, int fullbeta, int nlv, int nexo, int[] lvind, int nlvno0, int[] nseen, int[,] obsvar, int[] nseenexo, int[,] obsexo){
     real ldetcomp[Ng];
     matrix[k,k] iden;
     vector[k] psivecinv[Ng];
@@ -12,75 +12,61 @@
 
     iden = diag_matrix(rep_vector(1.0, k));
 
+    evlv = sem_mean(alpha, B, g, regind, exoind, k, Ng, nexo);
+
     // TODO speed up by using missingness patterns
     xvectm = 0;
     ldetsum = 0;
     for(i in 1:N){
-      if(nlv > 0){
-        for(j in 1:nlv){
-	  tmpobs[j] = j;
+      if(nlvno0 > 0){
+        for(j in 1:nlvno0){
+	  tmpobs[j] = lvind[j];
 	}
-	for(j in (nlv + 1):(nlv + nseen[i])){
+	for(j in (nlvno0 + 1):(nlvno0 + nseen[i])){
 	  tmpobs[j] = nlv + obsvar[i,(j - nlv)];
 	}
       } else {
         for(j in 1:nseen[i]){
-	  tmpobs[j] = obsvar[i,j];
-	}
-      }
-
-      if(nexo == 0){
-        evlv[g[i]] = inverse(iden - to_matrix(B[,,g[i]])) * (to_vector(alpha[,1,g[i]]) + to_matrix(B[,,g[i]]) * to_vector(alpha[,1,g[i]]));
-        evlv[g[i],1:(nlv+nseen[i])] = evlv[g[i],tmpobs[1:(nlv+nseen[i])]];
-      } else {
-        if(nseen[i] - nseenexo[i] > 0){
-          evlv[g[i],1:(nlv+nseen[i]-nseenexo[i])] = inverse(iden[tmpobs[1:(nlv+nseen[i]-nseenexo[i])],tmpobs[1:(nlv+nseen[i]-nseenexo[i])]] - to_matrix(B[tmpobs[1:(nlv+nseen[i]-nseenexo[i])],tmpobs[1:(nlv+nseen[i]-nseenexo[i])],g[i]])) * (to_vector(alpha[tmpobs[1:(nlv+nseen[i]-nseenexo[i])],1,g[i]]) + to_matrix(B[tmpobs[1:(nlv+nseen[i]-nseenexo[i])],tmpobs[1:(nlv+nseen[i]-nseenexo[i])],g[i]]) * to_vector(alpha[tmpobs[1:(nlv+nseen[i]-nseenexo[i])],1,g[i]]));
-	} else if(nlv > 0){
-          evlv[g[i],1:nlv] = inverse(iden[tmpobs[1:nlv],tmpobs[1:nlv]] - to_matrix(B[tmpobs[1:nlv],tmpobs[1:nlv],g[i]])) * (to_vector(alpha[tmpobs[1:nlv],1,g[i]]) + to_matrix(B[tmpobs[1:nlv],tmpobs[1:nlv],g[i]]) * to_vector(alpha[tmpobs[1:nlv],1,g[i]]));
+	  tmpobs[j] = nlv + obsvar[i,j];
 	}
-
-        if(nseenexo[i] > 0){
-          // assume exo is always at the end
-          evlv[g[i],(nlv + nseen[i] - nseenexo[i] + 1):(nlv + nseen[i])] = to_vector(alpha[obsexo[i,1:nseenexo[i]],1,g[i]]);
-        }
       }
 
       // remove after testing this is needed for reg model with 
       // 0 constraint, but not coded as exo?
-      evlv[1,1] = alpha[1,1,1] + to_vector(B[1,2:3,1])' * to_vector(alpha[2:3,1,1]);
-      if(nseen[i] > 1){
-        evlv[g[i],2:nseen[i]] = to_vector(alpha[tmpobs[2:nseen[i]],1,g[i]]);
-      }
+      //evlv[1,1] = alpha[1,1,1] + to_vector(B[1,2:3,1])' * to_vector(alpha[2:3,1,1]);
+      //if(nseen[i] > 1){
+      //  evlv[g[i],2:nseen[i]] = to_vector(alpha[tmpobs[2:nseen[i]],1,g[i]]);
+      //}
 
       if(diagpsi){
-        for(j in 1:k){
-          psivecinv[g[i],j] = 1/psi[j,j,g[i]];
+        for(j in 1:(nlvno0 + nseen[i])){
+          psivecinv[g[i],tmpobs[j]] = 1/psi[tmpobs[j],tmpobs[j],g[i]];
         }
         psimatinv[g[i]] = diag_matrix(psivecinv[g[i]]);
 
-        siginv[g[i],1:(nlv+nseen[i]),1:(nlv+nseen[i])] = (iden[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])]] - to_matrix(B[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])],g[i]])') * psimatinv[g[i],tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])]] * (iden[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])]] - to_matrix(B[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])],g[i]]));
+        siginv[g[i],1:(nlvno0+nseen[i]),1:(nlvno0+nseen[i])] = (iden[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])]] - to_matrix(B[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])],g[i]])') * psimatinv[g[i],tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])]] * (iden[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])]] - to_matrix(B[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])],g[i]]));
 
 	if(fullbeta){
-	  ldetcomp[g[i]] = log_determinant(iden[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])]] - to_matrix(B[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])],g[i]]));
-	  ldetcomp[g[i]] = ldetcomp[g[i]] + ldetcomp[g[i]] + sum(log(diagonal(to_matrix(psi[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])],g[i]]))));
+	  ldetcomp[g[i]] = log_determinant(iden[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])]] - to_matrix(B[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])],g[i]]));
+	  ldetcomp[g[i]] = ldetcomp[g[i]] + ldetcomp[g[i]] + sum(log(diagonal(to_matrix(psi[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])],g[i]]))));
 	} else {
-          ldetcomp[g[i]] = sum(log(diagonal(to_matrix(psi[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])],g[i]]))));
+          ldetcomp[g[i]] = sum(log(diagonal(to_matrix(psi[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])],g[i]]))));
   	}
       } else {
         psimatinv[g[i]] = to_matrix(psi[,,g[i]]);
 	psimatinv[g[i]] = psimatinv[g[i]] + psimatinv[g[i]]' - diag_matrix(diagonal(psimatinv[g[i]]));
 
-	ldetcomp[g[i]] = log_determinant(psimatinv[g[i],tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])]]);
+	ldetcomp[g[i]] = log_determinant(psimatinv[g[i],tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])]]);
 	if(fullbeta){
-	  ldetcomp[g[i]] = ldetcomp[g[i]] + 2 * log_determinant(iden[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])]] - to_matrix(B[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])],g[i]]));
+	  ldetcomp[g[i]] = ldetcomp[g[i]] + 2 * log_determinant(iden[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])]] - to_matrix(B[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])],g[i]]));
 	}
 
 	psimatinv[g[i]] = inverse_spd(psimatinv[g[i]]);
-        siginv[g[i],1:(nlv+nseen[i]),1:(nlv+nseen[i])] = (iden[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])]] - to_matrix(B[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])],g[i]])') * psimatinv[g[i],tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])]] * (iden[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])]] - to_matrix(B[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])],g[i]]));
+        siginv[g[i],1:(nlvno0+nseen[i]),1:(nlvno0+nseen[i])] = (iden[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])]] - to_matrix(B[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])],g[i]])') * psimatinv[g[i],tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])]] * (iden[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])]] - to_matrix(B[tmpobs[1:(nlvno0+nseen[i])],tmpobs[1:(nlvno0+nseen[i])],g[i]]));
       }
 
-      xvec[1:(nlv+nseen[i])] = x[i,1:(nlv+nseen[i])]';
-      xvectm = xvectm + (xvec[1:(nlv+nseen[i])] - evlv[g[i],1:(nlv+nseen[i])])' * siginv[g[i],1:(nlv+nseen[i]),1:(nlv+nseen[i])] * (xvec[1:(nlv+nseen[i])] - evlv[g[i],1:(nlv+nseen[i])]);
+      xvec[1:(nlvno0+nseen[i])] = x[i,1:(nlvno0+nseen[i])]';
+      xvectm = xvectm + (xvec[1:(nlvno0+nseen[i])] - evlv[g[i],tmpobs[1:(nlvno0+nseen[i])]])' * siginv[g[i],1:(nlvno0+nseen[i]),1:(nlvno0+nseen[i])] * (xvec[1:(nlvno0+nseen[i])] - evlv[g[i],tmpobs[1:(nlvno0+nseen[i])]]);
       ldetsum = ldetsum + ldetcomp[g[i]];
     }
 

---FILE: inst/stanfuns/sem_mean.stan---
@@ -0,0 +1,17 @@
+  vector[] sem_mean(real[,,] alpha, real[,,] B, int[] g, int[] regind, int[] exoind, int k, int Ng, int nexo){
+    matrix[k,k] iden;
+    vector[k] evlv[Ng];
+
+    iden = diag_matrix(rep_vector(1.0, k));
+
+    for(j in 1:Ng){
+      if(nexo == 0){
+        evlv[j] = inverse(iden - to_matrix(B[,,j])) * (to_vector(alpha[,1,j]) + to_matrix(B[,,j]) * to_vector(alpha[,1,j]));
+      } else {
+        evlv[j,regind] = inverse(iden[regind,regind] - to_matrix(B[regind,regind,j])) * (to_vector(alpha[regind,1,j]) + to_matrix(B[regind,exoind,j]) * to_vector(alpha[exoind,1,j]));
+        evlv[j,exoind] = to_vector(alpha[exoind,1,j]);
+      }
+    }
+
+    return evlv;
+  }

---FILE: inst/stanfuns/sem_mean_eta.stan---
@@ -0,0 +1,32 @@
+  vector[] sem_mean_eta(real[,,] alpha, matrix eta, real[,,] B, int[] g, int[] regind, int[] exoind, int k, int N, int nexo, int Ng, int[] lvind){
+    matrix[k,k] iden;
+    matrix[k,k] ibinv[Ng];
+    vector[k] evlv[N];
+    real alphvec[k,1,1];
+
+    iden = diag_matrix(rep_vector(1.0, k));
+
+    alphvec = alpha;
+    alphvec[lvind,1,1] = rep_array(0,size(lvind));
+
+    for(j in 1:Ng){
+      if(nexo == 0){
+        ibinv[j] = inverse(iden - to_matrix(B[,,j]));
+      } else {
+        ibinv[j,1:size(regind),1:size(regind)] = inverse(iden[regind,regind] - to_matrix(B[regind,regind,j]));
+      }
+    }
+
+    if(nexo == 0){
+      for(i in 1:N){
+        evlv[i] = ibinv[g[i]] * (to_vector(alphvec[,1,g[i]]) + to_matrix(B[,,g[i]]) * eta[i,]');
+      }
+    } else {
+      for(i in 1:N){
+        evlv[i,regind] = ibinv[g[i],1:size(regind),1:size(regind)] * (to_vector(alphvec[regind,1,g[i]]) + to_matrix(B[regind,exoind,g[i]]) * eta[i,]');
+        evlv[i,exoind] = to_vector(alphvec[exoind,1,g[i]]);
+      }
+    }
+
+    return evlv;
+  }"
ecmerkle,blavaan,a427bb865f7186eed9323d2a27043a1f5b44a1db,ecmerkle,merklee@missouri.edu,2017-08-16T20:19:35Z,ecmerkle,merklee@missouri.edu,2017-08-16T20:19:35Z,fix for user-specified correlation parameters,DESCRIPTION;R/set_priors.R,False,True,True,False,4,2,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.209
+Version: 0.2-5.210
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/set_priors.R---
@@ -71,7 +71,9 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x, target=""ja
                           partable$row[i], "","", partable$col[i],
                           "","", partable$group[i], ""] "", eqop,
                           "" "", sep="""")
-            if(grepl(""rho"", partable$id[i])) TXT2 <- paste(TXT2, ""-1 + 2*"", sep="""")
+            if(grepl(""rho"", partable$id[i]) & partable$free[i] > 0){
+              TXT2 <- paste(TXT2, ""-1 + 2*"", sep="""")
+            }
           
             if(partable$free[i] == 0 & partable$op[i] != "":=""){
                 if(is.na(partable$ustart[i])){"
ecmerkle,blavaan,7055293601c9962bbef54a58927f703b733789eb,ecmerkle,merklee@missouri.edu,2017-06-29T02:47:08Z,ecmerkle,merklee@missouri.edu,2017-06-29T02:47:08Z,fix postpred() when some cases are missing all values,DESCRIPTION;R/postpred.R,False,True,True,False,8,3,11,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.206
+Version: 0.2-5.207
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/postpred.R---
@@ -34,13 +34,18 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
         Mu.hat <- implied$mean
         dataeXo <- lavdata@eXo
 
-        ## TODO? this generates complete cases; maybe we want missing
-        ## observations to stay missing in the generated data:
         dataX <- vector(""list"", length=lavdata@ngroups)
         for(g in 1:lavsamplestats@ngroups) {
           dataX[[g]] <- MASS::mvrnorm(n     = lavsamplestats@nobs[[g]],
                                       Sigma = Sigma.hat[[g]],
                                       mu    = Mu.hat[[g]])
+          ## get completely missing observations out, or there
+          ## will be problems
+          allmis <- apply(is.na(origlavdata@X[[g]]), 1, all)
+          if(sum(allmis) > 0){
+            origlavdata@X[[g]] <- origlavdata@X[[g]][-which(allmis),]
+          }
+          
           dataX[[g]][is.na(origlavdata@X[[g]])] <- NA
         }
 "
ecmerkle,blavaan,388ff8654f5bc6c7b5e6aeb99cd6d7cd8fac7819,ecmerkle,merklee@missouri.edu,2017-06-09T04:21:00Z,ecmerkle,merklee@missouri.edu,2017-06-09T04:21:00Z,fix summary() for stan covariances in psi,DESCRIPTION;R/blav_object_methods.R;R/set_stanpars.R,False,True,True,False,24,12,36,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.205
+Version: 0.2-5.206
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blav_object_methods.R---
@@ -192,6 +192,17 @@ function(object, header       = TRUE,
 
 
     if(estimates) {
+        jagtarget <- class(object@external$mcmcout) == ""runjags""
+        newpt <- object@ParTable
+        newpt$group[newpt$group == 0] <- 1 # for defined parameters
+
+        if(!jagtarget){
+            rhorows <- which(newpt$mat == ""rho"" | newpt$mat == ""lvrho"")
+            if(length(rhorows) > 0){
+                newpt <- lapply(newpt, function(x) x[-rhorows])
+                object@ParTable <- lapply(object@ParTable, function(x) x[-rhorows])
+            }
+        }
         PE <- parameterEstimates(object, se = TRUE, zstat = FALSE,
                                  ci = TRUE,
                                  standardized = standardized,
@@ -203,6 +214,7 @@ function(object, header       = TRUE,
         if(standardized && std.nox) {
             PE$std.all <- PE$std.nox
         }
+        PE$group[PE$group == 0] <- 1
 
         attributes(PE)$information <- ""MCMC""
         attributes(PE)$se <- ""MCMC""
@@ -211,17 +223,6 @@ function(object, header       = TRUE,
 
         ## TODO put parameter priors in partable
 
-        newpt <- object@ParTable
-        newpt$group[newpt$group == 0] <- 1 # for defined parameters
-        PE$group[PE$group == 0] <- 1
-        jagtarget <- class(object@external$mcmcout) == ""runjags""
-        if(!jagtarget){
-            rhorows <- which(newpt$mat == ""rho"")
-            if(length(rhorows) > 0){
-                newpt <- lapply(newpt, function(x) x[-rhorows])
-            }
-        }
-
         ## match jags names to partable, then partable to PE
         if(jagtarget){
             pte2 <- which(!is.na(newpt$jagpnum))

---FILE: R/set_stanpars.R---
@@ -129,6 +129,17 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
                     }
                     if(length(partype) > 1) partype <- partype[1] # due to psi and ibpsi
                     partable$prior[i] <- dp[partype]
+
+                    ## if rho, re-add prior to cov row
+                    if(partable$mat[i] %in% c(""rho"", ""lvrho"")){
+                      browser()
+                        covr <- grep(paste0(partable$mat[i], ""["",
+                                            partable$row[i], "","",
+                                            partable$col[i], "","",
+                                            partable$group[i], ""]""),
+                                     partable$ustart, fixed = TRUE)
+                        partable$prior[covr] <- dp[partype]
+                    }
                 }
                 jagpri <- strsplit(partable$prior[i], ""\\["")[[1]][1]
                 vpri <- grepl(""\\[var\\]"", partable$prior[i])"
ecmerkle,blavaan,201a48b29e22f99757a26f9cb57060efe2e4ca06,ecmerkle,merklee@missouri.edu,2017-05-29T03:41:18Z,ecmerkle,merklee@missouri.edu,2017-05-29T03:41:18Z,"handle missing ov.x in stan, and fixes for fixed.x=FALSE",DESCRIPTION;R/lav_export_stan.R;R/set_stancovs.R;inst/stanfuns/sem_lv_missing.stan,False,True,True,False,83,48,131,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.203
+Version: 0.2-5.205
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_stan.R---
@@ -40,7 +40,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   ## lavaan FIXME? if no x, ov.names.x is sometimes length 0,
   ## sometimes NA
   if(length(ov.names.x) > 0){
-    if(is.na(ov.names.x)){
+    if(all(is.na(ov.names.x))){
       nov.x <- 0
     } else {
       nov.x <- length(ov.names.x)
@@ -157,8 +157,17 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
 
   nfree <- sapply(parmats, sapply, function(x){
     if(class(x)[1] == ""lavaan.matrix.symmetric""){
-      # off-diagonals handled via rho parameters!
-      sum(diag(x) > 0)
+      # off-diagonals handled via rho parameters, unless they
+      # are both ov.names.x
+      if(FALSE){ #rownames(x)[1] %in% c(lv.names, ov.names.x)){
+        covpars <- which(partable$op == ""~~"" &
+                         partable$lhs != partable$rhs &
+                         partable$free > 0L &
+                         partable$lhs %in% ov.names.x)
+        length(covpars) + sum(diag(x) > 0)
+      } else {
+        sum(diag(x) > 0)
+      }
     } else {
       sum(x > 0)
     }})
@@ -232,9 +241,12 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   }
   yind <- which(ov.names %in% thet.ov.names)
   xind <- which(ov.names %in% psi.ov.names)
-  if(nov.x > 0){
-    exoind <- which(ov.names[xind] %in% ov.names.x)
-    regind <- which(!(ov.names[xind] %in% ov.names.x))
+  ## FIXME? see .internal_get_ALPHA from lav_representation_lisrel.R
+  ## for alternative (better) way to handle this than eqs.x
+  if(nov.x > 0 | length(vnames$eqs.x[[1]]) > 0){
+    xnames <- c(ov.names.x, vnames$eqs.x[[1]])
+    exoind <- which(ov.names[xind] %in% xnames)
+    regind <- which(!(ov.names[xind] %in% xnames))
     if(nlv > 0){
       regind <- c(1:nlv, (nlv+regind))
       exoind <- nlv + exoind
@@ -301,7 +313,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
                   (nlv + n.psi.ov), "", N, "", ngroups, "", "",
                   diagpsi, "", "", fullbeta, "", "", nlv, "", "", nov.x)
     if(miss.psi){
-      TXT <- paste0(TXT, "", nseenx, obsvarx"")
+      TXT <- paste0(TXT, "", nseenx, obsvarx, nseenexo, obsexo"")
     }
     TXT <- paste0(TXT, "");\n"")
   }
@@ -426,6 +438,14 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
       misvarx <- matrix(-999, ntot, n.psi.ov)
       nmisx <- rep(NA, ntot)
     }
+    if(length(exoind) > 0){
+      obsexo <- matrix(-999, ntot, length(exoind))
+      nseenexo <- rep(NA, ntot)
+    } else {
+      obsexo <- matrix(1, ntot, 1)
+      nseenexo <- rep(1, ntot)
+    }
+    
     g <- rep(NA, ntot)
 
     for(k in 1:ngroups){
@@ -442,7 +462,6 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
       g[lavdata@case.idx[[k]]] <- k
       
       ## missingness patterns
-      ## FIXME handle missing eXo
       npatt <- lavdata@Mp[[k]]$npatterns
       for(m in 1:npatt){
         if(ny > 0){
@@ -467,17 +486,24 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
 
         if(n.psi.ov > 0){
           ## now for x
-          tmpobs <- which(lavdata@Mp[[k]]$pat[m,])
-          tmpobs <- tmpobs[tmpobs %in% xind]
+          tmpobsx <- which(lavdata@Mp[[k]]$pat[m,])
+          tmpobs <- tmpobsx[tmpobsx %in% xind]
           tmpmis <- which(!lavdata@Mp[[k]]$pat[m,])
           tmpmis <- tmpmis[tmpmis %in% xind]
           tmpidx <- lavdata@Mp[[k]]$case.idx[[m]]
           nseenx[tmpidx] <- length(tmpobs)
+          tmpobsexo <- which(tmpobs %in% exoind)
+          nseenexo[tmpidx] <- length(tmpobsexo)
           if(length(tmpobs) > 0){
             tmpobs <- matrix(tmpobs, length(tmpidx), length(tmpobs),
                              byrow=TRUE)
             obsvarx[tmpidx,1:nseenx[tmpidx[1]]] <- tmpobs
           }
+          if(length(tmpobsexo) > 0){
+            tmpobsexo <- matrix(tmpobsexo, length(tmpidx),
+                                length(tmpobsexo), byrow=TRUE)
+            obsexo[tmpidx,1:nseenexo[tmpidx[1]]] <- tmpobsexo
+          }
           nmisx[tmpidx] <- length(tmpmis)
           if(length(tmpmis) > 0){
             tmpmis <- matrix(tmpmis, length(tmpidx), length(tmpmis),
@@ -510,8 +536,10 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
       if(n.psi.ov > 0){
         obsvarx <- obsvarx[-nas,]
         misvarx <- misvarx[-nas,]
+        obsexo <- obsexo[-nas,]
         nseenx <- nseenx[-nas]
         nmisx <- nmisx[-nas]
+        nseenexo <- nseenexo[-nas]
       }
       ntot <- sum(unlist(lavdata@nobs))
     }
@@ -538,8 +566,9 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
         }
       }
     }
-    
-    standata <- list(g=g, N=ntot, regind=regind, exoind=exoind)
+
+    standata <- list(g=g, N=ntot, regind=array(regind),
+                     exoind=array(exoind))
     if(ny > 0) standata <- c(standata, list(y=y))
     if(n.psi.ov > 0) standata <- c(standata, list(x=x))
     if(missflag){
@@ -553,7 +582,9 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
       if(n.psi.ov > 0){
         standata <- c(standata, list(obsvarx=obsvarx,
                                      misvarx=misvarx,
-                                     nseenx=nseenx, nmisx=nmisx))
+                                     obsexo=obsexo,
+                                     nseenx=nseenx, nmisx=nmisx,
+                                     nseenexo=nseenexo))
         standata$x[is.na(standata$x)] <- -999
       }
     }
@@ -582,33 +613,13 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
       if(n.psi.ov > 0){
         datablk <- paste0(datablk, t1, ""int obsvarx[N,"", n.psi.ov,
                           ""];\n"", t1, ""int misvarx[N,"", n.psi.ov,
-                          ""];\n"", t1, ""int nseenx[N];\n"",
-                          t1, ""int nmisx[N];\n"")
+                          ""];\n"", t1, ""int obsexo[N,"",
+                          ncol(obsexo), ""];\n"", t1,
+                          ""int nseenx[N];\n"", t1,
+                          ""int nmisx[N];\n"", t1,
+                          ""int nseenexo[N];\n"")
       }
     }
-    
-    if(FALSE){ #blavmis == ""fi""){
-      ## keep only modeled y's not on rhs of regression
-      matvars <- which(orig.ov.names %in% ov.names &
-                       !(orig.ov.names %in% ovreg))
-      ## NB y is now a matrix, so no need for ymat
-      ymat <- ymat[,matvars]
-      nmvs <- length(matvars)
-  
-      ydf <- data.frame(y=as.numeric(ymat),
-                        g=rep(g, nmvs),
-                        sub=rep(1:ntot, nmvs),
-                        mv=rep(matvars, each=ntot))
-      
-      ydf <- subset(ydf, !is.na(ydf$y) & !(ydf$mv %in% ovcol))
-      ## sub index excluding completely missing observations
-      ydf$sub <- as.numeric(as.factor(ydf$sub))
-
-      standata <- c(standata, list(yvec=ydf$y, sub=ydf$sub,
-                                   mv=ydf$mv, nrows=nrow(ydf)))
-      standata$g <- ydf$g
-      standata$N <- max(ydf$sub)
-    }
 
     ## parameter matrices/vectors
     matrows <- sapply(parmats[[1]], nrow)
@@ -752,7 +763,7 @@ coeffun_stan <- function(lavpartable, rsob, fun = ""mean"") {
 
       tmpfree <- lavpartable$free[idx]
 
-      lavpartable$free[idx] <- 0
+      lavpartable$free[idx] <- 0L
       lavpartable$free[newidx] <- tmpfree
     }
   }

---FILE: R/set_stancovs.R---
@@ -17,8 +17,8 @@ set_stancovs <- function(partable, ov.names, ov.names.x, dp) {
   
   covpars <- which(partable$op == ""~~"" &
                    partable$lhs != partable$rhs &
-                   partable$free > 0L &
-                   !(partable$lhs %in% ov.names.x))
+                   partable$free > 0L)# &
+#                   !(partable$lhs %in% ov.names.x))
 
   blkrow <- rep(NA, length(partable$id))
   partable$rhoidx <- rep(NA, length(partable$id))
@@ -55,7 +55,8 @@ set_stancovs <- function(partable, ov.names, ov.names.x, dp) {
       partable$rhs[tmprows] <- partable$rhs[covpars[i]]
       
       ## Decide on =~ (ov) vs ~ (lv)
-      if(partable$lhs[covpars[i]] %in% ov.names){
+      if(partable$lhs[covpars[i]] %in% ov.names &
+         !(partable$lhs[covpars[i]] %in% ov.names.x)){
         if(!eq.const){
           mvcov <- mvcov + 1
           covidx <- mvcov

---FILE: inst/stanfuns/sem_lv_missing.stan---
@@ -1,18 +1,18 @@
-  real sem_lv_missing_lpdf(matrix x, real[,,] alpha, real[,,] B, real[,,] psi, int[] g, int[] regind, int[] exoind, int k, int N, int Ng, int diagpsi, int fullbeta, int nlv, int nexo, int[] nseen, int[,] obsvar){
+  real sem_lv_missing_lpdf(matrix x, real[,,] alpha, real[,,] B, real[,,] psi, int[] g, int[] regind, int[] exoind, int k, int N, int Ng, int diagpsi, int fullbeta, int nlv, int nexo, int[] nseen, int[,] obsvar, int[] nseenexo, int[,] obsexo){
     real ldetcomp[Ng];
     matrix[k,k] iden;
     vector[k] psivecinv[Ng];
     matrix[k,k] psimatinv[Ng];
     matrix[k,k] siginv[Ng];
     vector[k] xvec;
+    vector[k] evlv[Ng];
     int tmpobs[k];
     real xvectm;
     real ldetsum;
 
     iden = diag_matrix(rep_vector(1.0, k));
 
     // TODO speed up by using missingness patterns
-    // TODO handle nexo > 0
     xvectm = 0;
     ldetsum = 0;
     for(i in 1:N){
@@ -29,6 +29,29 @@
 	}
       }
 
+      if(nexo == 0){
+        evlv[g[i]] = inverse(iden - to_matrix(B[,,g[i]])) * (to_vector(alpha[,1,g[i]]) + to_matrix(B[,,g[i]]) * to_vector(alpha[,1,g[i]]));
+        evlv[g[i],1:(nlv+nseen[i])] = evlv[g[i],tmpobs[1:(nlv+nseen[i])]];
+      } else {
+        if(nseen[i] - nseenexo[i] > 0){
+          evlv[g[i],1:(nlv+nseen[i]-nseenexo[i])] = inverse(iden[tmpobs[1:(nlv+nseen[i]-nseenexo[i])],tmpobs[1:(nlv+nseen[i]-nseenexo[i])]] - to_matrix(B[tmpobs[1:(nlv+nseen[i]-nseenexo[i])],tmpobs[1:(nlv+nseen[i]-nseenexo[i])],g[i]])) * (to_vector(alpha[tmpobs[1:(nlv+nseen[i]-nseenexo[i])],1,g[i]]) + to_matrix(B[tmpobs[1:(nlv+nseen[i]-nseenexo[i])],tmpobs[1:(nlv+nseen[i]-nseenexo[i])],g[i]]) * to_vector(alpha[tmpobs[1:(nlv+nseen[i]-nseenexo[i])],1,g[i]]));
+	} else if(nlv > 0){
+          evlv[g[i],1:nlv] = inverse(iden[tmpobs[1:nlv],tmpobs[1:nlv]] - to_matrix(B[tmpobs[1:nlv],tmpobs[1:nlv],g[i]])) * (to_vector(alpha[tmpobs[1:nlv],1,g[i]]) + to_matrix(B[tmpobs[1:nlv],tmpobs[1:nlv],g[i]]) * to_vector(alpha[tmpobs[1:nlv],1,g[i]]));
+	}
+
+        if(nseenexo[i] > 0){
+          // assume exo is always at the end
+          evlv[g[i],(nlv + nseen[i] - nseenexo[i] + 1):(nlv + nseen[i])] = to_vector(alpha[obsexo[i,1:nseenexo[i]],1,g[i]]);
+        }
+      }
+
+      // remove after testing this is needed for reg model with 
+      // 0 constraint, but not coded as exo?
+      evlv[1,1] = alpha[1,1,1] + to_vector(B[1,2:3,1])' * to_vector(alpha[2:3,1,1]);
+      if(nseen[i] > 1){
+        evlv[g[i],2:nseen[i]] = to_vector(alpha[tmpobs[2:nseen[i]],1,g[i]]);
+      }
+
       if(diagpsi){
         for(j in 1:k){
           psivecinv[g[i],j] = 1/psi[j,j,g[i]];
@@ -53,11 +76,11 @@
 	}
 
 	psimatinv[g[i]] = inverse_spd(psimatinv[g[i]]);
-        siginv[g[i],1:(nlv+nseen[i]),1:(nlv+nseen[i])] = (iden[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])]] - to_matrix(B[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])],g[i]])') * inverse_spd(psimatinv[g[i],tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])]]) * (iden[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])]] - to_matrix(B[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])],g[i]]));
+        siginv[g[i],1:(nlv+nseen[i]),1:(nlv+nseen[i])] = (iden[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])]] - to_matrix(B[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])],g[i]])') * psimatinv[g[i],tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])]] * (iden[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])]] - to_matrix(B[tmpobs[1:(nlv+nseen[i])],tmpobs[1:(nlv+nseen[i])],g[i]]));
       }
-    
+
       xvec[1:(nlv+nseen[i])] = x[i,1:(nlv+nseen[i])]';
-      xvectm = xvectm + (xvec[1:(nlv+nseen[i])] - to_vector(alpha[tmpobs[1:(nlv+nseen[i])],1,g[i]]))' * siginv[g[i],1:(nlv+nseen[i]),1:(nlv+nseen[i])] * (xvec[1:(nlv+nseen[i])] - to_vector(alpha[tmpobs[1:(nlv+nseen[i])],1,g[i]]));
+      xvectm = xvectm + (xvec[1:(nlv+nseen[i])] - evlv[g[i],1:(nlv+nseen[i])])' * siginv[g[i],1:(nlv+nseen[i]),1:(nlv+nseen[i])] * (xvec[1:(nlv+nseen[i])] - evlv[g[i],1:(nlv+nseen[i])]);
       ldetsum = ldetsum + ldetcomp[g[i]];
     }
 "
ecmerkle,blavaan,62c4da6a75a1b95d1638b5507e9668c4ef3aa6cf,ecmerkle,merklee@missouri.edu,2017-05-16T17:50:09Z,ecmerkle,merklee@missouri.edu,2017-05-16T17:50:09Z,fixes for exo variables in stan,DESCRIPTION;R/lav_export_stan.R;inst/stanfuns/sem_lv.stan;inst/stanfuns/sem_lv_missing.stan,False,True,True,False,15,8,23,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.202
+Version: 0.2-5.203
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_stan.R---
@@ -36,7 +36,18 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   pta <- lav_partable_attributes(partable = partable, pta = NULL)
   vnames <- pta$vnames; nvar <- pta$nvar; nfac <- pta$nfac
   ov.names.nox <- vnames$ov.nox[[1]]; nov.nox <- length(ov.names.nox)
-  ov.names.x <- vnames$ov.x[[1]]; nov.x <- length(ov.names.x)
+  ov.names.x <- vnames$ov.x[[1]]
+  ## lavaan FIXME? if no x, ov.names.x is sometimes length 0,
+  ## sometimes NA
+  if(length(ov.names.x) > 0){
+    if(is.na(ov.names.x)){
+      nov.x <- 0
+    } else {
+      nov.x <- length(ov.names.x)
+    }
+  } else {
+    nov.x <- 0
+  }
   ov.ord <- vnames$ov.ord[[1]]
   lv.nox <- vnames$lv.nox[[1]]
   lv.names <- vnames$lv[[1]]
@@ -252,7 +263,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     TXT <- paste0(TXT, t1, ""matrix[N,"", (nlv + n.psi.ov), ""] etamat;\n"")
   }
   TXT <- paste0(TXT, t1, ""for(i in 1:N) {\n"")
-  missflag <- any(grepl(""0"", model@Data@Mp[[1]]$id))
+
   if(ny > 0){
     if(missflag){
       TXT <- paste0(TXT, t2,

---FILE: inst/stanfuns/sem_lv.stan---
@@ -54,11 +54,6 @@
     xvectm = 0;
     ldetsum = 0;
     for(i in 1:N){
-      //if(fullbeta){
-      //  evlv[g[i],1:3] = inverse(iden[1:3,1:3] - to_matrix(B[1:3,1:3,g[i]])) * (to_vector(alpha[1:3,1,g[i]]) + to_matrix(B[1:3,4:5,g[i]]) * to_vector(alpha[4:5,1,g[i]]));
-      //  evlv[g[i],4:5] = to_vector(alpha[4:5,1,g[i]]);
-      //}
-
       xvec = x[i,]';
       xvectm = xvectm + (xvec - evlv[g[i],])' * siginv[g[i]] * (xvec - evlv[g[i],]);
       ldetsum = ldetsum + ldetcomp[g[i]];

---FILE: inst/stanfuns/sem_lv_missing.stan---
@@ -12,6 +12,7 @@
     iden = diag_matrix(rep_vector(1.0, k));
 
     // TODO speed up by using missingness patterns
+    // TODO handle nexo > 0
     xvectm = 0;
     ldetsum = 0;
     for(i in 1:N){"
ecmerkle,blavaan,280526df6f8f6ddc1e2ca1b8a7ef618841141709,ecmerkle,merklee@missouri.edu,2017-05-04T14:15:48Z,ecmerkle,merklee@missouri.edu,2017-05-04T14:15:48Z,fix for use of default burnin/sample iterations,DESCRIPTION;R/blavaan.R,False,True,True,False,3,3,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.198
+Version: 0.2-5.199
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blavaan.R---
@@ -455,11 +455,11 @@ blavaan <- function(...,  # default lavaan arguments
             if(target == ""jags""){
                 if(convergence == ""auto""){
                     attr(x, ""iterations"") <- res$sample
-                    sample <- res$sample
-                    burnin <- res$burnin
                 } else {
                     attr(x, ""iterations"") <- rjarg$sample
                 }
+                sample <- res$sample
+                burnin <- res$burnin
             } else {
                 wrmup <- ifelse(length(rjarg$warmup) > 0,
                                 rjarg$warmup, floor(rjarg$iter/2))"
ecmerkle,blavaan,233c72548f372c96f673b539f219790ddf91637a,ecmerkle,merklee@missouri.edu,2017-05-03T19:17:53Z,ecmerkle,merklee@missouri.edu,2017-05-03T19:17:53Z,fixes to fixed cov parameters in stan,DESCRIPTION;R/lav_export_stan.R;R/set_inits.R;R/set_stancovs.R;R/set_stanpars.R,False,True,True,False,46,14,60,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.197
+Version: 0.2-5.198
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_stan.R---
@@ -139,7 +139,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     tmppsi <- tmppsi[lower.tri(tmppsi)]
     if(all(tmppsi == 0)) diagpsi <- 1L
   }
-  
+
   nfree <- sapply(parmats, sapply, function(x){
     if(class(x)[1] == ""lavaan.matrix.symmetric""){
       # off-diagonals handled via rho parameters!
@@ -176,7 +176,9 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     #nrhofix <- sum(sapply(parmats, function(x){
     #  sum(x$theta[lower.tri(x$theta)] %in% parconst$rhs)
     #}))
-    nrho <- max(partable$rhoidx[partable$mat == ""rho""], na.rm = TRUE)# - nrhofix
+    nrho <- sum(partable$mat == ""rho"" &
+                partable$free > 0 &
+                !is.na(partable$rhoidx), na.rm = TRUE)# - nrhofix
     nfree <- c(nfree, rho = nrho)
     parblk <- paste0(parblk, t1, ""vector<lower=0,upper=1>["",
                      nrho, ""] rhofree;\n"")
@@ -185,7 +187,9 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     #nlrhofix <- sum(sapply(parmats, function(x){
     #  sum(x$psi[lower.tri(x$psi)] %in% parconst$rhs)
     #}))
-    nlrho <- max(partable$rhoidx[partable$mat == ""lvrho""], na.rm = TRUE)# - nlrhofix
+    nlrho <- sum(partable$mat == ""lvrho"" &
+                 partable$free > 0 &
+                 !is.na(partable$rhoidx), na.rm = TRUE)# - nlrhofix
     nfree <- c(nfree, lvrho = nlrho)
     parblk <- paste0(parblk, t1, ""vector<lower=0,upper=1>["",
                      nlrho, ""] lvrhofree;\n"")
@@ -213,8 +217,11 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
                  ""to_vector(mu[i]), thetld[g[i]]);\n"", t1,
                  ""}\n\n"")
   }
-  TXT <- paste0(TXT, t1, ""eta ~ sem_lv_lpdf(alpha, beta, psi, g, "",
-                nlv, "", N, "", ngroups, "", "", diagpsi, "");\n"")
+
+  if(nlv > 0){
+      TXT <- paste0(TXT, t1, ""eta ~ sem_lv_lpdf(alpha, beta, psi, g, "",
+                    nlv, "", N, "", ngroups, "", "", diagpsi, "");\n"")
+  }
   
   ## for missing==""fi"", to model variables on rhs of regression
   ovreg <- unique(regressions$rhs[regressions$rhs %in% ov.names])
@@ -271,7 +278,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
       if(rhs %in% lv.names) {
         RHS <- paste(""eta[i,"", match(rhs, lv.names), ""]"", sep="""")
       } else if(rhs %in% orig.ov.names) {
-        RHS <- paste(rhs, ""[i]"", sep="""")
+        RHS <- paste(""y[i,"", match(rhs, ov.names), ""]"", sep="""")
       }
       
       ## deal with fixed later
@@ -487,9 +494,15 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     }
     
     ## add cholesky decomp of theta matrix
+    ## FIXME if some ovs are in theta and others in psi
     TPS <- paste0(TPS, t1, ""}\n\n"")
     TPS <- paste0(TPS, t1, ""for(j in 1:"", ngroups, ""){\n"")
-    TPS <- paste0(TPS, t2, ""thetld[j] = fill_lower(to_matrix(theta[,,j]));\n"")
+    TPS <- paste0(TPS, t2, ""thetld[j] = fill_lower(to_matrix("")
+    if(any(partable$mat == ""theta"")){
+        TPS <- paste0(TPS, ""theta[,,j]));\n"")
+    } else {
+        TPS <- paste0(TPS, ""psi[,,j]));\n"")
+    }
     TPS <- paste0(TPS, t2, ""thetld[j] = cholesky_decompose("",
                   ""thetld[j]);\n"", t1, ""}\n"")
     
@@ -503,8 +516,11 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     out <- c(out, list(data=standata))
   }
 
-  funblk <- paste0(""functions{\n"", t1, ""#include 'sem_lv.stan' \n"",
-                   t1, ""#include 'fill_lower.stan' \n"")
+  funblk <- ""functions{\n""
+  if(nlv > 0){
+      funblk <- paste0(funblk, t1, ""#include 'sem_lv.stan' \n"")
+  }
+  funblk <- paste0(funblk, t1, ""#include 'fill_lower.stan' \n"")
   ## could insert other functions as needed
   funblk <- paste0(funblk, ""}\n\n"")
 
@@ -516,7 +532,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   isystem <- system.file(""stanfuns"", package = ""blavaan"")
   out$model <- rstan::stanc_builder(file = tmp, isystem = isystem,
                                     obfuscate_model_name = TRUE)$model_code
-  
+
   out <- c(out, list(monitors = monitors, pxpartable = partable))
 
   out

---FILE: R/set_inits.R---
@@ -123,6 +123,21 @@ set_inits_stan <- function(partable, nfree, n.chains, inits){
 
   partable$freeparnums[is.na(partable$freeparnums)] <- 0
   freepartable <- partable[partable$freeparnums > 0,]
+  if(""rhoidx"" %in% names(freepartable)){
+      rhorows <- which(!is.na(freepartable$rhoidx) &
+                       freepartable$free > 0 &
+                       freepartable$mat == ""rho"")
+      if(length(rhorows) > 0){
+          freepartable$freeparnums[rhorows] <- 1:length(rhorows)
+      }
+      lvrhorows <- which(!is.na(freepartable$rhoidx) &
+                         freepartable$free > 0 &
+                         freepartable$mat == ""lvrho"")
+      if(length(rhorows) > 0){
+          freepartable$freeparnums[lvrhorows] <- 1:length(lvrhorows)
+      }
+  }
+
   ## TODO need exported, or reverse rstan::lookup()
   rosetta <- rstan:::rosetta
   ## alternate way to possibly get around export

---FILE: R/set_stancovs.R---
@@ -17,8 +17,8 @@ set_stancovs <- function(partable, ov.names, ov.names.x, dp) {
   
   covpars <- which(partable$op == ""~~"" &
                    partable$lhs != partable$rhs &
-                   !(partable$lhs %in% ov.names.x &
-                     partable$free == 0))
+                   partable$free > 0 &
+                   !(partable$lhs %in% ov.names.x))
 
   blkrow <- rep(NA, length(partable$id))
   partable$rhoidx <- rep(NA, length(partable$id))
@@ -108,6 +108,7 @@ set_stancovs <- function(partable, ov.names, ov.names.x, dp) {
                                               "","", partable$group[tmprows],
                                               ""] * sqrt("", tmpv1,
                                               "" * "", tmpv2, "")"")
+        partable$start[tmprows] <- partable$start[covpars[i]]
       }
       partable$free[tmprows] <- partable$free[covpars[i]]
       partable$free[covpars[i]] <- 0

---FILE: R/set_stanpars.R---
@@ -57,7 +57,7 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
                           "","", partable$group[i], ""] "", eqop,
                           "" "", sep="""")
 
-            if(grepl(""rho"", partable$mat[i]) & is.na(partable$ustart[i])){
+            if(grepl(""rho"", partable$mat[i]) & is.na(partable$ustart[i]) & partable$free[i] > 0){
                 TXT2 <- paste(TXT2, ""-1 + 2*"", sep="""")
             }
           "
ecmerkle,blavaan,85c6696d98bac22c35301a9ce508324f435090f4,ecmerkle,merklee@missouri.edu,2017-04-30T19:35:40Z,ecmerkle,merklee@missouri.edu,2017-04-30T19:35:40Z,address ov vars fixed to 0 when lv has covariances,DESCRIPTION;R/set_partable.R,False,True,True,False,14,6,20,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-5.194
+Version: 0.2-5.195
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/set_partable.R---
@@ -343,12 +343,20 @@ set_mv0 <- function(partable, ov.names, ngroups) {
                                partable$rhs == ovn[i] &
                                partable$group == j)
 
-                ## This should always be length 1 because, if it is also
-                ## an indicator of another lv (with other mvs), then
-                ## we can estimate the variance
-                if(length(lvloc) > 1){
+                lvcov <- which(partable$op == ""~~"" &
+                               (partable$lhs %in% partable$lhs[lvloc]) |
+                               (partable$rhs %in% partable$lhs[lvloc]) &
+                               partable$lhs != partable$rhs)
+
+                ## If this is an indicator of multiple lvs or
+                ## has covariances attached, we cannot handle it
+                ## in conditional (on lv) form:
+                if(length(lvloc) > 1 | length(lvcov) > 0){
+                    if(length(mvloc) > 1){
+                        stop(""blavaan ERROR: Problem with ov variances fixed to 0."")
+                    }
                     partable$ustart[mvloc] <- .001
-                    warning(paste(""blavaan WARNING: The variance of variable"", ovn[i],
+                    message(paste(""blavaan NOTE: The variance of variable"", ovn[i],
                                ""in group"", j, ""has been fixed to .001 instead of 0 (necessary for JAGS).\n""))
                 } else {
                     lvname <- partable$lhs[lvloc]"
ecmerkle,blavaan,08cbd83baf8919961724260d40bab1269c0d9b20,ecmerkle,merklee@missouri.edu,2017-04-27T15:54:26Z,ecmerkle,merklee@missouri.edu,2017-04-27T15:54:26Z,fix stan burnin/sample args,DESCRIPTION;R/blavaan.R,False,True,True,False,3,1,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-4
+Version: 0.2-5.193
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blavaan.R---
@@ -123,6 +123,8 @@ blavaan <- function(...,  # default lavaan arguments
         if(target == ""stan""){
             jarg <- c(""warmup"", ""iter"", ""adapt"")
             names(mfj) <- jarg[mcj > 0]
+            ## stan iter argument includes warmup:
+            if(mcj[1] > 0 & mcj[2] > 0) mfj$iter <- mfj$iter + mfj$warmup
             if(""adapt"" %in% names(mfj)){
               mfj <- mfj[-which(names(mfj) == ""adapt"")]
             }"
ecmerkle,blavaan,eeebe5e467aa8f46f130ad20b9902e612ae45470,ecmerkle,merklee@missouri.edu,2017-04-26T19:57:11Z,ecmerkle,merklee@missouri.edu,2017-04-26T19:57:11Z,fix do.fit=FALSE,DESCRIPTION;R/blav_fit.R;R/blav_fit_measures.R;R/blavaan.R,False,True,True,False,13,5,18,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-4.187
+Version: 0.2-4.189
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blav_fit.R---
@@ -7,7 +7,11 @@ blav_model_fit <- function(lavpartable = NULL,
 
     stopifnot(is.list(lavpartable), class(lavmodel) %in% c(""Model"",
                                                            ""lavModel""))
-    lavmcmc <- make_mcmc(lavjags)
+    if(class(lavjags) != ""NULL""){
+        lavmcmc <- make_mcmc(lavjags)
+    } else {
+        lavmcmc <- NULL
+    }
       
     # extract information from 'x'
     iterations <- attr(x, ""iterations"")

---FILE: R/blav_fit_measures.R---
@@ -11,12 +11,12 @@ function(object, fit.measures = ""all"", baseline.model = NULL) {
 })
 
 
-#fitMeasures <- fitmeasures <- function(object, fit.measures=""all"") {
 blav_fit_measures <- function(object, fit.measures = ""all"", 
                               baseline.model = NULL) {
 
     # has the model converged?
-    if(object@Fit@npar > 0L && !object@optim$converged) {
+    if(object@Fit@npar > 0L && !object@optim$converged &&
+       class(object@external$mcmcout) != ""NULL"") {
         warning(""blavaan WARNING: the chains may not have converged."")
     }
 

---FILE: R/blavaan.R---
@@ -86,7 +86,11 @@ blavaan <- function(...,  # default lavaan arguments
     }
     # if do.fit supplied, save it for jags stuff
     jag.do.fit <- TRUE
-    if(""do.fit"" %in% dotNames) jag.do.fit <- dotdotdot$do.fit
+    if(""do.fit"" %in% dotNames){
+        jag.do.fit <- dotdotdot$do.fit
+        burnin <- 0
+        sample <- 0
+    }
     if(""warn"" %in% dotNames){
         origwarn <- dotdotdot$warn
     } else {"
ecmerkle,blavaan,d08d4c31e3cd7bffe2a60d46d3741153b5ad34af,ecmerkle,merklee@missouri.edu,2017-04-26T18:51:31Z,ecmerkle,merklee@missouri.edu,2017-04-26T18:51:31Z,further fix for auto convergence,DESCRIPTION;R/blavaan.R,False,True,True,False,8,2,10,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-4.186
+Version: 0.2-4.187
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blavaan.R---
@@ -445,7 +445,13 @@ blavaan <- function(...,  # default lavaan arguments
         if(jag.do.fit){
             lavmodel <- lav_model_set_parameters(lavmodel, x = x)
             if(target == ""jags""){
-                attr(x, ""iterations"") <- rjarg$sample
+                if(convergence == ""auto""){
+                    attr(x, ""iterations"") <- res$sample
+                    sample <- res$sample
+                    burnin <- res$burnin
+                } else {
+                    attr(x, ""iterations"") <- rjarg$sample
+                }
             } else {
                 wrmup <- ifelse(length(rjarg$warmup) > 0,
                                 rjarg$warmup, floor(rjarg$iter/2))"
ecmerkle,blavaan,2a64975a8f03e932a7f95aca3bcdec2f0b7566e8,ecmerkle,merklee@missouri.edu,2017-04-24T03:14:35Z,ecmerkle,merklee@missouri.edu,2017-04-24T03:14:35Z,fix to sem_lv stan code,DESCRIPTION;inst/stanfuns/sem_lv.stan,False,False,False,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-4.184
+Version: 0.2-4.185
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: inst/stanfuns/sem_lv.stan---
@@ -23,8 +23,8 @@
     } else {
       for(j in 1:Ng){
         psimatinv[j] = to_matrix(psi[,,j]);
-	ldetcomp[j] = log_determinant(psimatinv[j]);
 	psimatinv[j] = psimatinv[j] + psimatinv[j]' - diag_matrix(diagonal(psimatinv[j]));
+	ldetcomp[j] = log_determinant(psimatinv[j]);
 	psimatinv[j] = inverse_spd(psimatinv[j]);
         siginv[j] = (iden - to_matrix(B[,,j])') * psimatinv[j] * (iden - to_matrix(B[,,j]));
       }"
ecmerkle,blavaan,311459e3b4aa962c461a071f91d1fb68123721e4,ecmerkle,merklee@missouri.edu,2017-04-21T21:25:52Z,ecmerkle,merklee@missouri.edu,2017-04-21T21:25:52Z,small blav_compare fix,DESCRIPTION;R/blav_compare.R,False,True,True,False,3,3,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-4.183
+Version: 0.2-4.184
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blav_compare.R---
@@ -15,14 +15,14 @@ blavCompare <- function(object1, object2, ...) {
   ## of that object can get much larger.
   lavopt1 <- object1@Options
   lavopt1$estimator <- ""ML""
-  ll1 <- case_lls(object1@external$runjags, object1@Model,
+  ll1 <- case_lls(object1@external$mcmcout, object1@Model,
                   object1@ParTable, object1@SampleStats,
                   lavopt1, object1@Cache,
                   object1@Data)
 
   lavopt2 <- object2@Options
   lavopt2$estimator <- ""ML""
-  ll2 <- case_lls(object2@external$runjags, object2@Model,
+  ll2 <- case_lls(object2@external$mcmcout, object2@Model,
                   object2@ParTable, object2@SampleStats,
                   lavopt2, object2@Cache,
                   object2@Data)"
ecmerkle,blavaan,4e839434df045c25086abe784a1a7f6db6815393,ecmerkle,merklee@missouri.edu,2017-04-18T18:46:26Z,ecmerkle,merklee@missouri.edu,2017-04-18T18:46:26Z,handle covariances fixed to 0 in stan,DESCRIPTION;R/blav_object_methods.R;R/lav_export_stan.R;R/set_inits.R;R/set_stancovs.R;R/set_stanpars.R,False,True,True,False,45,23,68,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-4.181
+Version: 0.2-4.182
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blav_object_methods.R---
@@ -400,7 +400,7 @@ setMethod(""coef"", ""blavaan"",
 ##     else call
 ## })
 
-plot.blavaan <- function(x, pars, plot.type=""trace"", ...){
+plot.blavaan <- function(x, pars=NULL, plot.type=""trace"", ...){
     # NB: arguments go to plot.runjags() or stan plot functions
     if(x@Options$target == ""jags""){
         parnames <- x@ParTable$pxnames[match(pars, x@ParTable$free)]
@@ -409,11 +409,15 @@ plot.blavaan <- function(x, pars, plot.type=""trace"", ...){
         ## checkvalidrunjagsobject somehow destroys name changes.
         plot(x@external$mcmcout, plot.type=plot.type, vars=parnames, ...)
     } else {
-        allpars <- colnames(as.matrix(x@external$mcmcout))
-        parnums <- x@ParTable$stanpnum[match(pars, x@ParTable$free)]
-        parnames <- allpars[parnums]
-        rstan::plot(x@external$mcmcout, pars = parnames,
-                    plotfun = plot.type)
+        plargs <- list(x = x@external$mcmcout,
+                       plotfun = plot.type)
+        if(length(pars) > 0){
+            allpars <- colnames(as.matrix(x@external$mcmcout))
+            parnums <- x@ParTable$stanpnum[match(pars, x@ParTable$free)]
+            parnames <- allpars[parnums]
+            plargs <- c(plargs, list(pars = parnames))
+        }
+        do.call(rstan::plot, plargs)
     }
 }
     

---FILE: R/lav_export_stan.R---
@@ -173,13 +173,19 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   }
 
   if(any(partable$mat == ""rho"")){
-    nrho <- max(partable$rhoidx[partable$mat == ""rho""], na.rm = TRUE)
+    #nrhofix <- sum(sapply(parmats, function(x){
+    #  sum(x$theta[lower.tri(x$theta)] %in% parconst$rhs)
+    #}))
+    nrho <- max(partable$rhoidx[partable$mat == ""rho""], na.rm = TRUE)# - nrhofix
     nfree <- c(nfree, rho = nrho)
     parblk <- paste0(parblk, t1, ""vector<lower=0,upper=1>["",
                      nrho, ""] rhofree;\n"")
   }
   if(any(partable$mat == ""lvrho"")){
-    nlrho <- max(partable$rhoidx[partable$mat == ""lvrho""], na.rm = TRUE)
+    #nlrhofix <- sum(sapply(parmats, function(x){
+    #  sum(x$psi[lower.tri(x$psi)] %in% parconst$rhs)
+    #}))
+    nlrho <- max(partable$rhoidx[partable$mat == ""lvrho""], na.rm = TRUE)# - nlrhofix
     nfree <- c(nfree, lvrho = nlrho)
     parblk <- paste0(parblk, t1, ""vector<lower=0,upper=1>["",
                      nlrho, ""] lvrhofree;\n"")
@@ -293,7 +299,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   out <- list(model = out, inits = NA)
 
   ## Initial values
-  inits <- set_inits_stan(partable, n.chains, inits)
+  inits <- set_inits_stan(partable, nfree, n.chains, inits)
   out$inits <- inits
 
   ## Now add data if we have it

---FILE: R/set_inits.R---
@@ -100,12 +100,11 @@ set_inits <- function(partable, ov.cp, lv.cp, n.chains, inits){
   initvals
 }
 
-set_inits_stan <- function(partable, n.chains, inits){
+set_inits_stan <- function(partable, nfree, n.chains, inits){
   ## Generate initial values for each chain
   initvals <- vector(""list"", n.chains)
   names(initvals) <- paste(""c"", 1:n.chains, sep="""")
-  pveclen <- with(partable, tapply(freeparnums, mat, max, na.rm = TRUE))
-  pveclen <- pveclen[pveclen > 0]
+  pveclen <- nfree[nfree > 0]
 
   initmats <- list()
   for(i in 1:length(pveclen)){
@@ -122,6 +121,7 @@ set_inits_stan <- function(partable, n.chains, inits){
     initvals[[i]] <- initmats
   }
 
+  partable$freeparnums[is.na(partable$freeparnums)] <- 0
   freepartable <- partable[partable$freeparnums > 0,]
   ## TODO need exported, or reverse rstan::lookup()
   rosetta <- rstan:::rosetta

---FILE: R/set_stancovs.R---
@@ -56,12 +56,16 @@ set_stancovs <- function(partable, ov.names, ov.names.x, dp) {
       
       ## Decide on =~ (ov) vs ~ (lv)
       if(partable$lhs[covpars[i]] %in% ov.names){
-        mvcov <- mvcov + 1
-        partable$rhoidx[tmprows] <- partable$rhoidx[covpars[i]] <- mvcov
+        if(!eq.const){
+          mvcov <- mvcov + 1
+          covidx <- mvcov
+        }
         partable$mat[tmprows] <- ""rho""
       } else {
-        lvcov <- lvcov + 1
-        partable$rhoidx[tmprows] <- partable$rhoidx[covpars[i]] <- lvcov
+        if(!eq.const){
+          lvcov <- lvcov + 1
+          covidx <- lvcov
+        }
         partable$mat[tmprows] <- ""lvrho""
       }
       partable$op[tmprows] <- ""~~""
@@ -88,23 +92,25 @@ set_stancovs <- function(partable, ov.names, ov.names.x, dp) {
         partable$prior[tmprows] <- """"
       }
 
-      partable$free[tmprows] <- partable$free[covpars[i]]
-      partable$free[covpars[i]] <- 0
       if(eq.const){
         partable$ustart[covpars[i]] <- paste0(partable$mat[full.idx],
                                               ""["",
                                               partable$row[full.idx],
                                               "","", partable$col[full.idx],
                                               "","", partable$group[full.idx],
                                               ""]"")
+        partable$ustart[tmprows] <- paste0(partable$ustart[covpars[i]], ""/sqrt("", tmpv1, ""*"", tmpv2, "")"")
       } else {
+        partable$rhoidx[tmprows] <- partable$rhoidx[covpars[i]] <- covidx
         partable$ustart[covpars[i]] <- paste0(partable$mat[tmprows],
                                               ""["", partable$row[tmprows],
                                               "","", partable$col[tmprows],
                                               "","", partable$group[tmprows],
                                               ""] * sqrt("", tmpv1,
                                               "" * "", tmpv2, "")"")
       }
+      partable$free[tmprows] <- partable$free[covpars[i]]
+      partable$free[covpars[i]] <- 0
       partable$plabel[tmprows] <- paste("".p"", tmprows, ""."", sep="""")
       partable$label[tmprows] <- """"
     }

---FILE: R/set_stanpars.R---
@@ -20,8 +20,10 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
     for(i in 1:nrow(partable)){
         miscignore <- partable$mat[i] == """"
 
-        eqpar <- which(partable$rhs == partable$plabel[i] &
-                       partable$op == ""=="")
+        eqpar <- which((partable$rhs == partable$plabel[i] &
+                       partable$op == ""=="") |
+                       (grepl(""rho"", partable$mat[i]) &
+                        is.na(partable$rhoidx[i])))
         compeq <- which(partable$lhs == partable$label[i] &
                         partable$op %in% c(""=="", "":="") &
                         grepl(""\\+|-|/|\\*|\\(|\\)|\\^"", partable$rhs))
@@ -54,9 +56,13 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
                           partable$row[i], "","", partable$col[i],
                           "","", partable$group[i], ""] "", eqop,
                           "" "", sep="""")
-            if(grepl(""rho"", partable$mat[i])) TXT2 <- paste(TXT2, ""-1 + 2*"", sep="""")
+
+            if(grepl(""rho"", partable$mat[i]) & is.na(partable$ustart[i])){
+                TXT2 <- paste(TXT2, ""-1 + 2*"", sep="""")
+            }
           
-            if(partable$free[i] == 0 & partable$op[i] != "":=""){
+            if((partable$free[i] == 0 & partable$op[i] != "":="") |
+               (grepl(""rho"", partable$mat[i]) & !is.na(partable$ustart[i]))){
                 if(is.na(partable$ustart[i])){
                     ## exo
                     TXT2 <- paste(TXT2, partable$start[i], eolop,"
ecmerkle,blavaan,dc7f3aea4b76f79fe83cdfb9cd70684f2e517c5f,ecmerkle,merklee@missouri.edu,2017-04-18T14:49:16Z,ecmerkle,merklee@missouri.edu,2017-04-18T14:49:16Z,allow blavaan to approximately fit deterministic functions (ov variance fixed to .001),DESCRIPTION;R/set_partable.R,False,True,True,False,27,26,53,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-4.180
+Version: 0.2-4.181
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/set_partable.R---
@@ -347,32 +347,33 @@ set_mv0 <- function(partable, ov.names, ngroups) {
                 ## an indicator of another lv (with other mvs), then
                 ## we can estimate the variance
                 if(length(lvloc) > 1){
-                    stop(paste(""blavaan ERROR: Problem with"", ovn[i],
-                               ""as a single indicator of a latent variable.\n""))
+                    partable$ustart[mvloc] <- .001
+                    warning(paste(""blavaan WARNING: The variance of variable"", ovn[i],
+                               ""in group"", j, ""has been fixed to .001 instead of 0 (necessary for JAGS).\n""))
+                } else {
+                    lvname <- partable$lhs[lvloc]
+
+                    ## TODO? check for covariances with the lv?
+                    lvvar <- which(partable$lhs == lvname &
+                                   partable$rhs == lvname &
+                                   partable$op == ""~~"" &
+                                   partable$group == j)
+
+                    tmpfree <- partable$free[lvvar]
+                    tmpustart <- partable$ustart[lvvar]
+                    tmpplabel <- partable$plabel[lvvar]
+                    tmpstart <- partable$start[lvvar]
+
+                    partable$free[lvvar] <- partable$free[mvloc]
+                    partable$ustart[lvvar] <- partable$ustart[mvloc]
+                    partable$plabel[lvvar] <- partable$plabel[mvloc]
+                    partable$start[lvvar] <- partable$plabel[mvloc]
+
+                    partable$free[mvloc] <- tmpfree
+                    partable$ustart[mvloc] <- tmpustart
+                    partable$plabel[mvloc] <- tmpplabel
+                    partable$start[mvloc] <- tmpstart
                 }
-
-                lvname <- partable$lhs[lvloc]
-
-                ## TODO? check for covariances with the lv?
-                lvvar <- which(partable$lhs == lvname &
-                               partable$rhs == lvname &
-                               partable$op == ""~~"" &
-                               partable$group == j)
-
-                tmpfree <- partable$free[lvvar]
-                tmpustart <- partable$ustart[lvvar]
-                tmpplabel <- partable$plabel[lvvar]
-                tmpstart <- partable$start[lvvar]
-
-                partable$free[lvvar] <- partable$free[mvloc]
-                partable$ustart[lvvar] <- partable$ustart[mvloc]
-                partable$plabel[lvvar] <- partable$plabel[mvloc]
-                partable$start[lvvar] <- partable$plabel[mvloc]
-
-                partable$free[mvloc] <- tmpfree
-                partable$ustart[mvloc] <- tmpustart
-                partable$plabel[mvloc] <- tmpplabel
-                partable$start[mvloc] <- tmpstart
             }
         }
     }"
ecmerkle,blavaan,3fbc1e0dcfd86f156ee3c96892d5438eba3bf83e,ecmerkle,merklee@missouri.edu,2017-04-18T14:19:09Z,ecmerkle,merklee@missouri.edu,2017-04-18T14:19:09Z,fix blavInspect() when 'what' is sent to lavaan,DESCRIPTION;R/blav_object_inspect.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-4.179
+Version: 0.2-4.180
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blav_object_inspect.R---
@@ -132,7 +132,7 @@ blavInspect <- function(blavobject, what, ...) {
                    ""not available for Bayesian models.""))
     } else {
         ## we can use lavInspect
-        lavargs <- c(dotdotdot, list(lavobject = blavobject, what = what))
+        lavargs <- c(dotdotdot, list(object = blavobject, what = what))
         do.call(""lavInspect"", lavargs)
     }
 }"
ecmerkle,blavaan,cc968d534dda380690540e4a2a84bf4246e8514a,ecmerkle,merklee@missouri.edu,2017-04-17T21:48:34Z,ecmerkle,merklee@missouri.edu,2017-04-17T21:48:34Z,fixes to equality constraints in stan,DESCRIPTION;R/lav_export_stan.R;R/set_stancovs.R,False,True,True,False,22,10,32,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-4.178
+Version: 0.2-4.179
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_stan.R---
@@ -149,7 +149,11 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     }})
   if(length(parconst) > 0){
     nfix <- sapply(parmats, sapply, function(x){
-      sum(x %in% parconst$rhs)})
+      if(class(x)[1] == ""lavaan.matrix.symmetric""){
+        sum(diag(x) %in% parconst$rhs)
+      } else {
+        sum(x %in% parconst$rhs)
+      }})
   } else {
     nfix <- 0
   }
@@ -287,7 +291,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   out <- paste0(out, TXT3, ""\n}"")
   class(out) <- c(""lavaan.character"", ""character"")
   out <- list(model = out, inits = NA)
-    
+
   ## Initial values
   inits <- set_inits_stan(partable, n.chains, inits)
   out$inits <- inits

---FILE: R/set_stancovs.R---
@@ -90,13 +90,21 @@ set_stancovs <- function(partable, ov.names, ov.names.x, dp) {
 
       partable$free[tmprows] <- partable$free[covpars[i]]
       partable$free[covpars[i]] <- 0
-      partable$ustart[covpars[i]] <- paste0(partable$mat[tmprows],
-                                            ""["", partable$row[tmprows],
-                                            "","", partable$col[tmprows],
-                                            "","", partable$group[tmprows],
-                                            ""] * sqrt("", tmpv1,
-                                            "" * "", tmpv2, "")"")
-
+      if(eq.const){
+        partable$ustart[covpars[i]] <- paste0(partable$mat[full.idx],
+                                              ""["",
+                                              partable$row[full.idx],
+                                              "","", partable$col[full.idx],
+                                              "","", partable$group[full.idx],
+                                              ""]"")
+      } else {
+        partable$ustart[covpars[i]] <- paste0(partable$mat[tmprows],
+                                              ""["", partable$row[tmprows],
+                                              "","", partable$col[tmprows],
+                                              "","", partable$group[tmprows],
+                                              ""] * sqrt("", tmpv1,
+                                              "" * "", tmpv2, "")"")
+      }
       partable$plabel[tmprows] <- paste("".p"", tmprows, ""."", sep="""")
       partable$label[tmprows] <- """"
     }"
ecmerkle,blavaan,eb2b98b0513a6ba9f79e72f65d032622c968bcc0,ecmerkle,merklee@missouri.edu,2017-04-17T20:55:35Z,ecmerkle,merklee@missouri.edu,2017-04-17T20:55:35Z,fix plot method for stan,DESCRIPTION;R/blav_object_methods.R;R/blavaan.R,False,True,True,False,16,7,23,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-4.177
+Version: 0.2-4.178
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blav_object_methods.R---
@@ -401,12 +401,20 @@ setMethod(""coef"", ""blavaan"",
 ## })
 
 plot.blavaan <- function(x, pars, plot.type=""trace"", ...){
-    # NB: arguments go to plot.runjags()
-    parnames <- x@ParTable$pxnames[match(pars, x@ParTable$free)]
-    # TODO get lavaan parameter names to show up. Tougher than
-    # expected... see line 216 of runjags::summary.R;
-    # checkvalidrunjagsobject somehow destroys name changes.
-    plot(x@external$mcmcout, plot.type=plot.type, vars=parnames, ...)
+    # NB: arguments go to plot.runjags() or stan plot functions
+    if(x@Options$target == ""jags""){
+        parnames <- x@ParTable$pxnames[match(pars, x@ParTable$free)]
+        ## TODO get lavaan parameter names to show up. Tougher than
+        ## expected... see line 216 of runjags::summary.R;
+        ## checkvalidrunjagsobject somehow destroys name changes.
+        plot(x@external$mcmcout, plot.type=plot.type, vars=parnames, ...)
+    } else {
+        allpars <- colnames(as.matrix(x@external$mcmcout))
+        parnums <- x@ParTable$stanpnum[match(pars, x@ParTable$free)]
+        parnames <- allpars[parnums]
+        rstan::plot(x@external$mcmcout, pars = parnames,
+                    plotfun = plot.type)
+    }
 }
     
 #setMethod(""anova"", signature(object = ""blavaan""),

---FILE: R/blavaan.R---
@@ -300,6 +300,7 @@ blavaan <- function(...,  # default lavaan arguments
     lavoptions$missing   <- ""ml""
     lavoptions$cp        <- cp
     lavoptions$dp        <- dp
+    lavoptions$target    <- target
 
     verbose <- lavoptions$verbose
 "
ecmerkle,blavaan,724538124cd675c8340440d4c852db89f465c67e,ecmerkle,merklee@missouri.edu,2017-04-17T20:32:58Z,ecmerkle,merklee@missouri.edu,2017-04-17T20:32:58Z,fix std.lv=TRUE for stan,DESCRIPTION;R/blavaan.R;R/set_stanpars.R,False,True,True,False,11,3,14,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-4.176
+Version: 0.2-4.177
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blavaan.R---
@@ -235,11 +235,12 @@ blavaan <- function(...,  # default lavaan arguments
             }
         }
 
+        trunop <- ifelse(target == ""stan"", "" T[0,]"", "" T(0,)"")
         for(i in 1:length(fload)){
             if(LAV@ParTable$prior[fload[i]] != """"){
-                LAV@ParTable$prior[fload[i]] <- paste(LAV@ParTable$prior[fload[i]], ""T(0,)"", sep="""")
+                LAV@ParTable$prior[fload[i]] <- paste(LAV@ParTable$prior[fload[i]], trunop, sep="""")
             } else {
-                LAV@ParTable$prior[fload[i]] <- paste(dp[[""lambda""]], ""T(0,)"", sep="""")
+                LAV@ParTable$prior[fload[i]] <- paste(dp[[""lambda""]], trunop, sep="""")
             }
         }
     }

---FILE: R/set_stanpars.R---
@@ -127,6 +127,13 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
                 jagpri <- strsplit(partable$prior[i], ""\\["")[[1]][1]
                 vpri <- grepl(""\\[var\\]"", partable$prior[i])
                 spri <- grepl(""\\[sd\\]"", partable$prior[i])
+                if(vpri){
+                    jagpri <- strsplit(partable$prior[i], ""\\[var"")[[1]][1]
+                } else if(spri){
+                    jagpri <- strsplit(partable$prior[i], ""\\[sd"")[[1]][1]
+                } else {
+                    jagpri <- partable$prior[i]
+                }
                 if(!vpri & (grepl(""theta"", partable$mat[i]) | grepl(""psi"", partable$mat[i]))){
                     sq <- ifelse(spri, ""2"", ""-1"")
                     TXT2 <- paste(TXT2, ""pow("", partable$mat[i], ""free["","
ecmerkle,blavaan,746243a4580bc6715bc503a2bd30f8f0b6922a50,ecmerkle,merklee@missouri.edu,2017-04-13T20:14:26Z,ecmerkle,merklee@missouri.edu,2017-04-13T20:14:26Z,fix stan summary() + other minor changes,DESCRIPTION;R/blav_object_methods.R;R/blavaan.R,False,True,True,False,15,3,18,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-4.173
+Version: 0.2-4.174
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),
@@ -14,7 +14,7 @@ Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
             )
 Description: Fit a variety of Bayesian latent variable models, including confirmatory
    factor analysis, structural equation models, and latent growth curve models.
-Depends: R(>= 3.2.0), methods, runjags, lavaan(>= 0.5-21)
+Depends: R(>= 3.2.0), methods, runjags, lavaan(>= 0.5-23)
 Imports: stats, utils, graphics, MASS, MCMCpack, coda, mnormt, nonnest2(>= 0.4-1), loo
 Suggests: rstan, modeest, rjags, semTools, parallel
 License: GPL (>= 2)

---FILE: R/blav_object_methods.R---
@@ -217,7 +217,9 @@ function(object, header       = TRUE,
         jagtarget <- class(object@external$mcmcout) == ""runjags""
         if(!jagtarget){
             rhorows <- which(newpt$mat == ""rho"")
-            newpt <- lapply(newpt, function(x) x[-rhorows])
+            if(length(rhorows) > 0){
+                newpt <- lapply(newpt, function(x) x[-rhorows])
+            }
         }
 
         ## match jags names to partable, then partable to PE

---FILE: R/blavaan.R---
@@ -27,6 +27,16 @@ blavaan <- function(...,  # default lavaan arguments
     # default priors
     if(length(dp) == 0) dp <- dpriors(target = target)
 
+    # ensure stan is here
+    if(target == ""stan""){
+      # could also use requireNamespace + attachNamespace
+      if(!(suppressMessages(require(""rstan"", quietly = TRUE)))){
+        stop(""blavaan ERROR: rstan package is not installed."")
+      }
+      rstan_options(auto_write = TRUE)
+      options(mc.cores = min(n.chains, parallel::detectCores()))
+    }
+
     # if seed supplied, check that there is one per chain
     seedlen <- length(seed)
     if(seedlen > 0 & seedlen != n.chains){"
ecmerkle,blavaan,98d1556aa4126f5e4771d425a8adadb40a13183e,ecmerkle,merklee@missouri.edu,2017-04-13T03:53:00Z,ecmerkle,merklee@missouri.edu,2017-04-13T03:53:00Z,"stan fixes to handle multiple groups, equality constraints",DESCRIPTION;R/lav_export_stan.R;R/set_inits.R;R/set_stanpars.R,False,True,True,False,13,7,20,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-4.172
+Version: 0.2-4.173
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_stan.R---
@@ -164,8 +164,8 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     if(parnm %in% c(""theta"", ""psi"")){
       parblk <- paste0(parblk, ""<lower=0>"")        
     }
-    parblk <- paste0(parblk, ""["", nfree[i], ""] "", parnm,
-                     ""free"", eolop, ""\n"")
+    parblk <- paste0(parblk, ""["", nfree[i], ""]"")
+    parblk <- paste0(parblk, "" "", parnm, ""free"", eolop, ""\n"")
   }
 
   if(any(partable$mat == ""rho"")){
@@ -444,6 +444,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   funblk <- paste0(funblk, ""}\n\n"")
 
   fullmodel <- paste0(funblk, datablk, parblk, TPS, out$model, ""\n"")
+
   ## insert function files, similar to brms approach:
   tmp <- tempfile(fileext = "".stan"")
   cat(fullmodel, file = tmp)

---FILE: R/set_inits.R---
@@ -109,7 +109,12 @@ set_inits_stan <- function(partable, n.chains, inits){
 
   initmats <- list()
   for(i in 1:length(pveclen)){
-    initmats <- c(initmats, list(rep(NA, pveclen[i])))
+    initmats <- c(initmats, list(array(NA, dim=pveclen[i])))
+    ## if(pveclen[i] == 1){
+    ##   initmats <- c(initmats, list(as.vector(NA)))
+    ## } else {
+    ##   initmats <- c(initmats, list(rep(NA, pveclen[i])))
+    ## }
   }
   names(initmats) <- paste0(names(pveclen), ""free"")
 

---FILE: R/set_stanpars.R---
@@ -72,11 +72,11 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
                                    partable$row[eqpar], "","",
                                    partable$col[eqpar], "","",
                                    partable$group[eqpar], ""]"",
-                                   eolop, sep="""")
+                                   sep="""")
                 } else {
                     eqtxt <- paste(partable$mat[eqpar], ""free["",
                                    partable$freeparnums[eqpar],
-                                   ""]"", eolop, sep="""")
+                                   ""]"", sep="""")
                 }
 
                 vpri <- grepl(""\\[var\\]"", partable$prior[eqpar])
@@ -86,7 +86,7 @@ set_stanpars <- function(TXT2, partable, nfree, dp, lv.names.x){
                     TXT2 <- paste(TXT2, ""pow("", eqtxt, "","", sq,
                                   "")"", eolop, sep="""")
                 } else {
-                    TXT2 <- paste(TXT2, eqtxt, sep="""")
+                    TXT2 <- paste(TXT2, eqtxt, eolop, sep="""")
                 }
             } else if(length(compeq) > 0){
                 ## constraints with one parameter label on lhs"
ecmerkle,blavaan,499c7fdff654389ba2355d43a1e541c5dd2e0845,ecmerkle,merklee@missouri.edu,2017-04-10T03:02:25Z,ecmerkle,merklee@missouri.edu,2017-04-10T03:02:25Z,fixes to stan export with non-diagonal psi,DESCRIPTION;R/lav_export_stan.R;inst/stanfuns/sem_lv.stan,False,True,True,False,20,6,26,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-4.168
+Version: 0.2-4.169
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_stan.R---
@@ -388,7 +388,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     ## these are passed in as data in stan, so are the ""frames""
     tpnames <- names(pmats)
     names(pmats) <- paste0(names(pmats), ""frame"")
-
+    
     ## declare data variables and defined params
     datdecs <- tpdecs <- tpeqs <- """"
     for(i in 1:length(tpnames)){
@@ -409,6 +409,18 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     }
     tpdecs <- paste0(tpdecs, t1, ""real mu[N,"", tmpnmvs, ""];\n"")
 
+    ## if no beta, define it as 0 matrix
+    if(!(""beta"" %in% tpnames)){
+        matrows <- c(matrows, beta = matrows[[""psi""]])
+        matcols <- c(matcols, beta = matcols[[""psi""]])
+        pmats <- c(pmats, list(beta = array(0, c(matrows[[""psi""]],
+                                                 matcols[[""psi""]],
+                                                 ngroups))))
+        datdecs <- paste0(datdecs, t1, ""real beta["",
+                          matrows[[""psi""]], "","", matcols[[""psi""]],
+                          "","", ngroups, ""];\n"")
+    }
+    
     ## add cholesky decomp of theta matrix
     TPS <- paste0(TPS, t1, ""}\n\n"")
     TPS <- paste0(TPS, t1, ""for(j in 1:"", ngroups, ""){\n"")
@@ -417,8 +429,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
                   ""thetld[j] = thetld[j] - "",
                   ""diag_matrix(0.5 * diagonal(thetld[j]));\n"")
     TPS <- paste0(TPS, t2, ""thetld[j] = cholesky_decompose("",
-                  ""thetld[j]);\n"",
-                  t1, ""}\n"")
+                  ""thetld[j]);\n"", t1, ""}\n"")
     
     TPS <- paste0(""transformed parameters{\n"", tpdecs, ""\n"",
                   tpeqs, TXT2, ""\n\n"", TPS,

---FILE: inst/stanfuns/sem_lv.stan---
@@ -22,8 +22,11 @@
       }
     } else {
       for(j in 1:Ng){
-        siginv[j] = (iden - to_matrix(B[j])') * inverse_spd(to_matrix(psi[,,j])) * (iden - to_matrix(B[j]));
-        ldetcomp[j] = log_determinant(to_matrix(psi[,,j]));
+        psimatinv[j] = to_matrix(psi[,,j]);
+	ldetcomp[j] = log_determinant(psimatinv[j]);
+	psimatinv[j] = psimatinv[j] + psimatinv[j]' - diag_matrix(diagonal(psimatinv[j]));
+	psimatinv[j] = inverse_spd(psimatinv[j]);
+        siginv[j] = (iden - to_matrix(B[,,j])') * psimatinv[j] * (iden - to_matrix(B[,,j]));
       }
     }
 "
ecmerkle,blavaan,e47d7dbd2c1753f4cd48c1af8e16cfeeadd9b65d,ecmerkle,merklee@missouri.edu,2017-04-05T02:37:52Z,ecmerkle,merklee@missouri.edu,2017-04-05T02:37:52Z,minor fixes to stan export,DESCRIPTION;R/lav_export_stan.R,False,True,True,False,4,2,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-4.165
+Version: 0.2-4.167
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_stan.R---
@@ -150,6 +150,8 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
   if(length(parconst) > 0){
     nfix <- sapply(parmats, sapply, function(x){
       sum(x %in% parconst$rhs)})
+  } else {
+    nfix <- 0
   }
   nfree <- apply(nfree - nfix, 1, sum)
 
@@ -176,7 +178,7 @@ lav2stan <- function(model, lavdata = NULL, dp = NULL, n.chains = 1, mcmcextra =
     nlrho <- max(partable$rhoidx[partable$mat == ""lvrho""], na.rm = TRUE)
     nfree <- c(nfree, lvrho = nlrho)
     parblk <- paste0(parblk, t1, ""vector<lower=0,upper=1>["",
-                     nrho, ""] lvrhofree;\n"")
+                     nlrho, ""] lvrhofree;\n"")
   }
 
   if(nlv > 0){"
ecmerkle,blavaan,2a7945b331e4e8fb847457e9813f6c38a1dbb6eb,ecmerkle,merklee@missouri.edu,2017-04-04T17:12:17Z,ecmerkle,merklee@missouri.edu,2017-04-04T17:12:17Z,further fixes to stan summary + se,R/blav_fit.R;R/blav_object_methods.R;R/blav_utils.R;R/lav_export_stan.R,False,True,True,False,18,12,30,"---FILE: R/blav_fit.R---
@@ -7,7 +7,6 @@ blav_model_fit <- function(lavpartable = NULL,
 
     stopifnot(is.list(lavpartable), class(lavmodel) %in% c(""Model"",
                                                            ""lavModel""))
-
     lavmcmc <- make_mcmc(lavjags)
       
     # extract information from 'x'

---FILE: R/blav_object_methods.R---
@@ -214,6 +214,8 @@ function(object, header       = TRUE,
         newpt <- object@ParTable
         newpt$group[newpt$group == 0] <- 1 # for defined parameters
         PE$group[PE$group == 0] <- 1
+        rhorows <- which(newpt$mat == ""rho"")
+        newpt <- lapply(newpt, function(x) x[-rhorows])
 
         ## match jags names to partable, then partable to PE
         if(""jagpnum"" %in% names(newpt)){
@@ -279,6 +281,7 @@ function(object, header       = TRUE,
           PE$logBF[is.na(PE$logBF)] <- """"
           PE$logBF <- sprintf(char.format, PE$logBF)
         }
+        
         ## alternative names because this is not ML
         penames <- names(PE)
         ## This could be called ""Post.Mean"" except constraints
@@ -289,8 +292,8 @@ function(object, header       = TRUE,
         names(PE)[penames == ""ci.lower""] <- ""HPD.025""
         names(PE)[penames == ""ci.upper""] <- ""HPD.975""
         names(PE)[penames == ""psrf""] <- ""PSRF""
-        print(PE, nd = nd)
 
+        print(PE, nd = nd)
     } # parameter estimates
 })
 

---FILE: R/blav_utils.R---
@@ -209,7 +209,7 @@ fill_params <- function(postsamp      = NULL,
                                        x = postsamp[lavpartable$jagpnum[!is.na(lavpartable$jagpnum)]])
   } else {
     filled <- lav_model_set_parameters(lavmodel,
-                                       x = postsamp[lavpartable$stanpnum[lavpartable$stanpnum > 0 & lavpartable$free > 0]])
+                                       x = postsamp[lavpartable$stanpnum[lavpartable$free > 0][order(lavpartable$free[lavpartable$free > 0])]])
   }
   filled
 }
@@ -225,8 +225,12 @@ rearr_params <- function(mcmc         = NULL,
         for(i in 2:length(mcmc)){
             fullmat <- rbind(fullmat, mcmc[[i]])
         }
-    }    
-    fullmat[,lavpartable$jagpnum[lavpartable$free > 0]]
+    }
+    if(""jagpnum"" %in% names(lavpartable)){
+        fullmat[,lavpartable$jagpnum[lavpartable$free > 0]]
+    } else {
+        fullmat[,lavpartable$stanpnum[lavpartable$free > 0][order(lavpartable$free[lavpartable$free > 0])]]
+    }
 }   
 
 ## iteration numbers for samp_lls and postpred

---FILE: R/lav_export_stan.R---
@@ -475,11 +475,8 @@ coeffun_stan <- function(lavpartable, rsob, fun = ""mean"") {
       lavpartable$free[newidx] <- tmpfree
     }
   }
-
-  ## order lavpartable by free column
-  ## FIXME this is necessary later but makes summary()
-  ## look bad
-  lavpartable <- lavpartable[order(lavpartable$free),]
+  lavord <- order(lavpartable$id)
+  lavpartable <- lapply(lavpartable, function(x) x[lavord])
   
   ## from stan to partable
   ptnames <- with(lavpartable, paste0(mat, ""["", row, "","", col, "","",
@@ -497,13 +494,16 @@ coeffun_stan <- function(lavpartable, rsob, fun = ""mean"") {
 
   ## vcorr
   draw_mat <- as.matrix(rsob)
-  cmatch <- match(ptnames[lavpartable$free > 0], colnames(draw_mat))
+  cmatch <- match(ptnames[lavpartable$free > 0][order(lavpartable$free[lavpartable$free > 0])], colnames(draw_mat))
   vcorr <- cor(draw_mat[,cmatch])
 
+  svmatch <- match(colnames(vcorr), names(sdvec), nomatch = 0)
+  sdvec <- sdvec[svmatch]
+  
   ## convert to list
   lavpartable <- as.list(lavpartable, seq(ncol(lavpartable)))
 
-  list(x = lavpartable$est[lavpartable$free > 0],
+  list(x = lavpartable$est[lavpartable$free > 0][order(lavpartable$free[lavpartable$free > 0])],
        lavpartable = lavpartable,
        vcorr = vcorr,
        sd = sdvec)"
ecmerkle,blavaan,fadd6f1657ce981562383af049f175fbbc0577e9,ecmerkle,merklee@missouri.edu,2017-04-03T17:38:10Z,ecmerkle,merklee@missouri.edu,2017-04-03T17:38:10Z,add extra args to manpages + fix location of samplls,R/blav_fit_measures.R;man/bcfa.Rd;man/bgrowth.Rd;man/blavaan.Rd;man/bsem.Rd,False,True,True,False,33,9,42,"---FILE: R/blav_fit_measures.R---
@@ -126,7 +126,7 @@ blav_fit_measures <- function(object, fit.measures = ""all"",
         indices[""ppp""] <- object@Fit@test[[2]]$stat
     }
     if(any(c(""bic"", ""dic"", ""p_dic"") %in% fit.measures)) {
-        df <- 2*(object@Fit@fx - mean(as.numeric(object@external$runjags$samplls[,,1])))
+        df <- 2*(object@Fit@fx - mean(as.numeric(object@external$samplls[,,1])))
         indices[""bic""] <- -2*object@Fit@fx + npar*log(N)
         indices[""dic""] <- -2*object@Fit@fx + 2*df
         indices[""p_dic""] <- df

---FILE: man/bcfa.Rd---
@@ -7,7 +7,8 @@ Fit a Confirmatory Factor Analysis (CFA) model.}
 bcfa(..., cp = ""srs"",
      dp = dpriors(), n.chains = 3, burnin, sample,
      adapt, jagfile = FALSE, jagextra = list(), inits = ""simple"",
-     convergence = ""manual"", jagcontrol = list())
+     convergence = ""manual"", target = ""jags"", seed = NULL,
+     jagcontrol = list())
 }
 \arguments{
 \item{...}{Default lavaan arguments.  See \code{\link{lavaan}}.}
@@ -53,7 +54,12 @@ bcfa(..., cp = ""srs"",
   this case, the arguments \code{burnin} and \code{sample} are passed to
   \code{autorun.jags} as \code{startburnin} and \code{startsample},
   respectively. Otherwise, parameters
-  are sampled as specified by the user (or by the \code{run.jags} defaults).}
+  are sampled as specified by the user (or by the \code{run.jags}
+  defaults).}
+\item{target}{Desired MCMC package (currently, only \code{jags} is
+  available).}
+\item{seed}{A vector of length \code{n.chains} containing random
+  seeds for the MCMC run. If \code{NULL}, seeds will be chosen randomly.}
 \item{jagcontrol}{A list containing additional parameters passed to
     \code{run.jags} (or \code{autorun.jags}).  See the manpage of those functions for an
     overview of the additional parameters that can be set.  No other

---FILE: man/bgrowth.Rd---
@@ -6,7 +6,8 @@ Fit a Growth Curve model.}
 \usage{
 bgrowth(..., cp = ""srs"", dp = dpriors(), n.chains = 3,
 burnin, sample, adapt, jagfile = FALSE, jagextra = list(), 
-inits = ""simple"", convergence = ""manual"", jagcontrol = list())
+inits = ""simple"", convergence = ""manual"", target = ""jags"",
+seed = NULL, jagcontrol = list())
 }
 \arguments{
 \item{...}{Default lavaan arguments.  See \code{\link{lavaan}}.}
@@ -52,7 +53,12 @@ inits = ""simple"", convergence = ""manual"", jagcontrol = list())
   this case, the arguments \code{burnin} and \code{sample} are passed to
   \code{autorun.jags} as \code{startburnin} and \code{startsample},
   respectively. Otherwise, parameters
-  are sampled as specified by the user (or by the \code{run.jags} defaults).}
+  are sampled as specified by the user (or by the \code{run.jags}
+  defaults).}
+\item{target}{Desired MCMC package (currently, only \code{jags} is
+  available).}
+\item{seed}{A vector of length \code{n.chains} containing random
+  seeds for the MCMC run. If \code{NULL}, seeds will be chosen randomly.}
 \item{jagcontrol}{A list containing additional parameters passed to
     \code{run.jags} (or \code{autorun.jags}).  See the manpage of those functions for an
     overview of the additional parameters that can be set.  No other

---FILE: man/blavaan.Rd---
@@ -7,7 +7,8 @@ Fit a Bayesian latent variable model.}
 blavaan(..., cp = ""srs"", 
     dp = dpriors(), n.chains = 3, burnin, sample,
     adapt, jagfile = FALSE, jagextra = list(), inits = ""simple"",
-    convergence = ""manual"", jagcontrol = list())
+    convergence = ""manual"", target = ""jags"", seed = NULL,
+    jagcontrol = list())
 }
 \arguments{
 \item{...}{Default lavaan arguments.  See \code{\link{lavaan}}.}
@@ -52,7 +53,12 @@ blavaan(..., cp = ""srs"",
   this case, the arguments \code{burnin} and \code{sample} are passed to
   \code{autorun.jags} as \code{startburnin} and \code{startsample},
   respectively. Otherwise, parameters
-  are sampled as specified by the user (or by the \code{run.jags} defaults).}
+  are sampled as specified by the user (or by the \code{run.jags}
+  defaults).}
+\item{target}{Desired MCMC package (currently, only \code{jags} is
+  available).}
+\item{seed}{A vector of length \code{n.chains} containing random
+  seeds for the MCMC run. If \code{NULL}, seeds will be chosen randomly.}
 \item{jagcontrol}{A list containing additional parameters passed to
     \code{run.jags} (or \code{autorun.jags}).  See the manpage of those functions for an
     overview of the additional parameters that can be set.  No other

---FILE: man/bsem.Rd---
@@ -7,7 +7,8 @@ Fit a Structural Equation Model (SEM).}
 bsem(..., cp = ""srs"",
      dp = dpriors(), n.chains = 3, burnin, sample,
      adapt, jagfile = FALSE, jagextra = list(), inits = ""simple"",
-     convergence = ""manual"", jagcontrol = list())
+     convergence = ""manual"", target = ""jags"", seed = NULL,
+     jagcontrol = list())
 }
 \arguments{
 \item{...}{Default lavaan arguments.  See \code{\link{lavaan}}.}
@@ -53,7 +54,12 @@ bsem(..., cp = ""srs"",
   this case, the arguments \code{burnin} and \code{sample} are passed to
   \code{autorun.jags} as \code{startburnin} and \code{startsample},
   respectively. Otherwise, parameters
-  are sampled as specified by the user (or by the \code{run.jags} defaults).}
+  are sampled as specified by the user (or by the \code{run.jags}
+  defaults).}
+\item{target}{Desired MCMC package (currently, only \code{jags} is
+  available).}
+\item{seed}{A vector of length \code{n.chains} containing random
+  seeds for the MCMC run. If \code{NULL}, seeds will be chosen randomly.}
 \item{jagcontrol}{A list containing additional parameters passed to
     \code{run.jags} (or \code{autorun.jags}).  See the manpage of those functions for an
     overview of the additional parameters that can be set.  No other"
ecmerkle,blavaan,aed5e07127fdfe3b14455d946184c2f5fce0dde0,ecmerkle,merklee@missouri.edu,2017-03-02T18:55:59Z,ecmerkle,merklee@missouri.edu,2017-03-02T18:55:59Z,fix do.fit=FALSE,R/blavaan.R,False,True,True,False,3,3,6,"---FILE: R/blavaan.R---
@@ -355,16 +355,16 @@ blavaan <- function(...,  # default lavaan arguments
         parests <- coeffun(lavpartable, jagtrans$pxpartable, res)
         x <- parests$x
         lavpartable <- parests$lavpartable
-        
+
         attr(x, ""control"") <- jagcontrol
         if(jag.do.fit){
             lavmodel <- lav_model_set_parameters(lavmodel, x = x)
             attr(x, ""iterations"") <- res$sample
             attr(x, ""converged"") <- TRUE
         } else {
-            x <- numeric(0L)
+            #x <- numeric(0L)
             attr(x, ""iterations"") <- 0L
-            attr(x, ""converged"") <- FALSE          
+            attr(x, ""converged"") <- FALSE
             lavpartable$est <- lavpartable$start
         }
 "
ecmerkle,blavaan,3a5a78812f95a5630b1bdda20f927de15f2116a3,ecmerkle,merklee@missouri.edu,2017-02-28T04:06:29Z,ecmerkle,merklee@missouri.edu,2017-02-28T04:06:29Z,fix 'block' column when extra monitors are used,DESCRIPTION;R/blav_utils.R,False,True,True,False,2,1,3,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-4.148
+Version: 0.2-4.150
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blav_utils.R---
@@ -332,6 +332,7 @@ add_monitors <- function(lavpartable, lavjags, jagextra){
     lavpartable$rhs <- c(lavpartable$rhs, rep("""", sum(nvars)))
     lavpartable$user <- c(lavpartable$user, rep(2, sum(nvars)))
     lavpartable$group <- c(lavpartable$group, rep(1, sum(nvars)))
+    lavpartable$block <- c(lavpartable$block, rep(1, sum(nvars)))
     lavpartable$free <- c(lavpartable$free, rep(0, sum(nvars)))
     lavpartable$ustart <- c(lavpartable$ustart, rep(NA, sum(nvars)))
     lavpartable$exo <- c(lavpartable$exo, rep(0, sum(nvars)))"
ecmerkle,blavaan,04a8e067c164e48e2059a4c99245ca40988f6930,ecmerkle,merklee@missouri.edu,2017-02-23T20:19:06Z,ecmerkle,merklee@missouri.edu,2017-02-23T20:19:06Z,many minor fixes to make blavaan work with lavaan devel as well as release,R/blav_object_methods.R;R/blav_utils.R;R/lav_export_jags.R;R/margloglik.R;R/postpred.R;R/set_partable.R,False,True,True,False,19,8,27,"---FILE: R/blav_object_methods.R---
@@ -5,8 +5,8 @@ short.summary <- function(object) {
 
     # catch FAKE run
     FAKE <- FALSE
-    if(!is.null(object@Model@control$optim.method)) {
-        if(tolower(object@Model@control$optim.method) == ""none"") {
+    if(!is.null(object@Options$optim.method)) {
+        if(tolower(object@Options$optim.method) == ""none"") {
             FAKE <- TRUE
         }
     }
@@ -192,7 +192,8 @@ function(object, header       = TRUE,
 
 
     if(estimates) {
-        PE <- parameterEstimates(object, zstat = FALSE, ci = TRUE,
+        PE <- parameterEstimates(object, se = TRUE, zstat = FALSE,
+                                 ci = TRUE,
                                  standardized = standardized,
                                  rsquare = rsquare,
                                  remove.eq = FALSE, remove.system.eq = TRUE,

---FILE: R/blav_utils.R---
@@ -108,7 +108,10 @@ get_ll <- function(postsamp       = NULL, # one posterior sample
         lavoptions$test <- ""standard""
         lavoptions$estimator <- ""ML""
         ## control() is part of lavmodel (for now)
-        lavmodel@control <- list(optim.method=""none"")
+        lavoptions$optim.method <- ""none""
+        if(""control"" %in% slotNames(lavmodel)){
+            lavmodel@control <- list(optim.method=""none"")
+        }
 
         fit.samp <- try(lavaan(slotParTable = lavpartable,
                                slotModel = lavmodel,

---FILE: R/lav_export_jags.R---
@@ -50,7 +50,7 @@ lav2jags <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
     ## TODO seems like this is already hidden somewhere in lavaan...
     ncats <- sapply(ov.ord, function(x) length(grep(x, vnames$th[[1]])) + 1)
   }
-    
+
   lv.nox <- vnames$lv.nox[[1]]
   lv.names <- vnames$lv[[1]]
   ## ensure that lv.x names always come first (so we can possibly use dmnorm)

---FILE: R/margloglik.R---
@@ -149,7 +149,10 @@ margloglik <- function(lavpartable, lavmodel, lavoptions,
   lavoptions$test <- ""standard""
   lavoptions$estimator <- ""ML""
   ## control() is part of lavmodel (for now)
-  lavmodel@control <- list(optim.method=""none"")
+  lavoptions$optim.method <- ""none""
+  if(""control"" %in% slotNames(lavmodel)){
+    lavmodel@control <- list(optim.method=""none"")
+  }
 
   fit.new <- try(lavaan(slotParTable = lavpartable,
                         slotModel = lavmodel,

---FILE: R/postpred.R---
@@ -91,8 +91,11 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
           lavoptions2$estimator <- ""ML""
           lavoptions2$se <- ""none""
           lavoptions2$test <- ""standard""
+          lavoptions2$optim.method <- ""none""
           lavmodel2 <- lavmodel
-          lavmodel2@control <- list(optim.method=""none"")
+          if(""control"" %in% slotNames(lavmodel2)){
+            lavmodel2@control <- list(optim.method=""none"")
+          }
           if(lavsamplestats@ngroups > 1L) {
             DATA$.g. <- rep(1:lavdata@ngroups, 
                             times = unlist(lavdata@nobs))

---FILE: R/set_partable.R---
@@ -128,7 +128,8 @@ nlvcovs)
         phname <- paste("".phant"", i, sep="""")
         partable <- rbind(partable, blkrow, blkrow, blkrow)
 
-        partable$group[tmprows] <- k
+        ## TODO? should 'block' ever differ from 'group'?
+        partable$group[tmprows] <- partable$block[tmprows] <- k
 
         partable$rhs[tmprows[1]] <- partable$lhs[covpars[i]]
         partable$rhs[tmprows[2]] <- partable$rhs[covpars[i]]"
ecmerkle,blavaan,d96aa60e7f317ca88bbbdb7742bfdf84a3f5492e,ecmerkle,merklee@missouri.edu,2017-02-23T15:49:42Z,ecmerkle,merklee@missouri.edu,2017-02-23T15:49:42Z,fix postpred computation,R/blav_utils.R,False,True,True,False,2,2,4,"---FILE: R/blav_utils.R---
@@ -71,8 +71,8 @@ get_ll <- function(postsamp       = NULL, # one posterior sample
             if(inherits(tmpll, ""try-error"")) tmpll <- NA
 
             if(!conditional){
-                sampmn <- lavsamplestats@mean[[g]]
-                sampcov <- lavsamplestats@cov[[g]] #((lavdata@nobs[[g]]-1)/(lavdata@nobs[[g]]))*cov(lavdata@X[[g]])
+                sampmn <- apply(lavdata@X[[g]], 2, mean, na.rm=TRUE)
+                sampcov <- ((lavdata@nobs[[g]]-1)/(lavdata@nobs[[g]]))*cov(lavdata@X[[g]])
 
                 basell <- dmnorm(lavdata@X[[g]], sampmn, sampcov, log=TRUE)
             }"
ecmerkle,blavaan,de2e229c4b362330e068984d78b73ba3c41afe18,ecmerkle,merklee@missouri.edu,2017-02-22T21:53:52Z,ecmerkle,merklee@missouri.edu,2017-02-22T21:53:52Z,fix postpred issue caused by last commit,DESCRIPTION;R/blav_utils.R;R/postpred.R,False,True,True,False,5,2,7,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-3.139
+Version: 0.2-3.140
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blav_utils.R---
@@ -30,6 +30,8 @@ get_ll <- function(postsamp       = NULL, # one posterior sample
       }
 
       ## implied meanvec + covmat
+      ## TODO replace with lav_predict_yhat and lavInspect?
+      ## (lav_predict_yhat unavailable from lavPredict with custom ETA)
       mnvec <- lavaan:::computeYHAT(lavmodel, lavmodel@GLIST,
                                     lavsamplestats, ETA = eta)
       covmat <- lavaan:::computeTHETA(lavmodel, lavmodel@GLIST)

---FILE: R/postpred.R---
@@ -63,8 +63,9 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
 
         if(!mis){
           lavdata@X <- dataX
-          
+
           chisq.boot <- 2*diff(get_ll(lavmodel = lavmodel,
+                                      lavsamplestats = lavsamplestats,
                                       lavdata = lavdata,
                                       measure = measure))
         } else {"
ecmerkle,blavaan,ebf3b938f6fd0bf5d84f9cc164a35b04d1563a23,ecmerkle,merklee@missouri.edu,2017-01-05T18:28:38Z,ecmerkle,merklee@missouri.edu,2017-01-05T18:28:38Z,fix margloglik under cp='fa' and equality constraints,R/margloglik.R,False,True,True,False,3,1,4,"---FILE: R/margloglik.R---
@@ -129,8 +129,10 @@ margloglik <- function(lavpartable, lavmodel, lavoptions,
       }
     } else if(i %in% c(ocpvars, lcpvars)){
       ## kernel density estimation of fa variance's prior
+      partype <- ifelse(i %in% ocpvars, ""itheta"", ""ipsi"")
+      varpri <- jagsdist2r(dpriors()[[partype]])
       tmpdist <- (rnorm(1e5,sd=sqrt(1/1e-4))*rnorm(1e5,sd=sqrt(1/1e-4)))/rgamma(1e5,1,.5) +
-                 1/rgamma(1e5, as.numeric(pricom[[i]][2]), as.numeric(pricom[[i]][3]))
+                 1/rgamma(1e5, as.numeric(varpri[[1]][2]), as.numeric(varpri[[1]][3]))
       tmpkd <- density(tmpdist)
       tmpdens <- log(approx(tmpkd$x, tmpkd$y, thetstar[i])$y)
     } else {"
ecmerkle,blavaan,e090ce114d0c1c8d32688261c0e3de542438fa08,ecmerkle,merklee@missouri.edu,2016-12-01T17:41:31Z,ecmerkle,merklee@missouri.edu,2016-12-01T17:41:31Z,fix npar count for models with complex equality constraints,DESCRIPTION;R/blavaan.R,False,True,True,False,9,6,15,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-3.125
+Version: 0.2-3.127
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blavaan.R---
@@ -66,7 +66,10 @@ blavaan <- function(...,  # default lavaan arguments
     # if do.fit supplied, save it for jags stuff
     jag.do.fit <- TRUE
     if(""do.fit"" %in% dotNames) jag.do.fit <- dotdotdot$do.fit
-    dotdotdot$do.fit <- FALSE        # implies se=""none"" and test=""none""
+    dotdotdot$do.fit <- TRUE
+    dotdotdot$se <- ""none""; dotdotdot$test <- ""none""
+    # run for 1 iteration to obtain info about equality constraints, for npar
+    dotdotdot$control <- list(iter.max = 1); dotdotdot$warn <- FALSE
     dotdotdot$meanstructure <- TRUE
     dotdotdot$missing <- ""direct""   # direct/ml creates error? (bug in lavaan?)
     dotdotdot$estimator <- ""default"" # until 'Bayes' is accepted by lavaan()
@@ -124,7 +127,7 @@ blavaan <- function(...,  # default lavaan arguments
         dotdotdot$test <- ""none""
         dotNames <- names(dotdotdot)
     }
-  
+
     # call lavaan
     LAV <- do.call(""lavaan"", dotdotdot)
 
@@ -225,7 +228,7 @@ blavaan <- function(...,  # default lavaan arguments
     # if inits is list
     initsin <- inits
     if(class(inits) == ""list"") initsin <- ""jags""
-  
+
     # extract slots from dummy lavaan object
     lavpartable    <- LAV@ParTable
     if(!(""prior"" %in% names(lavpartable))) lavpartable$prior <- rep("""", length(lavpartable$lhs))
@@ -343,8 +346,9 @@ blavaan <- function(...,  # default lavaan arguments
 
         parests <- coeffun(lavpartable, jagtrans$pxpartable, res)
         x <- parests$x
-
         lavpartable <- parests$lavpartable
+        
+        attr(x, ""control"") <- jagcontrol
         if(jag.do.fit){
             lavmodel <- lav_model_set_parameters(lavmodel, x = x)
             attr(x, ""iterations"") <- res$sample
@@ -355,7 +359,6 @@ blavaan <- function(...,  # default lavaan arguments
             attr(x, ""converged"") <- FALSE          
             lavpartable$est <- lavpartable$start
         }
-        attr(x, ""control"") <- jagcontrol
 
         if(!(""ordered"" %in% dotNames)) {
             attr(x, ""fx"") <- get_ll(lavmodel = lavmodel, lavpartable = lavpartable,"
ecmerkle,blavaan,031c59966c0fef6c8564f42a68d2d5650abdc128,ecmerkle,merklee@missouri.edu,2016-11-29T17:45:41Z,ecmerkle,merklee@missouri.edu,2016-11-29T17:45:41Z,fix ordinal model with fixed.x=TRUE,R/blav_fit.R;R/blavaan.R,False,True,True,False,38,45,83,"---FILE: R/blav_fit.R---
@@ -37,6 +37,10 @@ blav_model_fit <- function(lavpartable = NULL,
 
     # for convenience: compute lavmodel-implied Sigma and Mu
     implied <- lav_model_implied(lavmodel)
+    # change names back if conditional.x (see lav_model_implied.R)
+    if(lavmodel@conditional.x) {
+        names(implied) <- c(""cov"", ""mean"", ""slopes"", ""th"", ""group.w"")
+    }
 
     # partrace?
     if(!is.null(attr(x, ""partrace""))) {

---FILE: R/blavaan.R---
@@ -301,26 +301,26 @@ blavaan <- function(...,  # default lavaan arguments
             if(suppressMessages(requireNamespace(""modeest"", quietly = TRUE))) runjags.options(mode.continuous = TRUE)
 
             if(jag.do.fit){
-              runjags.options(force.summary = TRUE)
-              rjcall <- ""run.jags""
-              if(convergence == ""auto""){
-                  rjcall <- ""autorun.jags""
-                  if(""raftery.options"" %in% names(rjarg)){
-                      ## autorun defaults
-                      if(!(""r"" %in% names(rjarg$raftery.options))){
-                          rjarg$raftery.options$r <- .01
-                      }
-                      if(!(""converge.eps"" %in% names(rjarg$raftery.options))){
-                          rjarg$raftery.options$converge.eps <- .01
-                      }
-                  } else {
-                      rjarg$raftery.options <- list(r=.01, converge.eps=.01)
-                  }
-                  if(!(""max.time"" %in% names(rjarg))) rjarg$max.time <- ""5m""
-              }
-              res <- try(do.call(rjcall, rjarg))
+                runjags.options(force.summary = TRUE)
+                rjcall <- ""run.jags""
+                if(convergence == ""auto""){
+                    rjcall <- ""autorun.jags""
+                    if(""raftery.options"" %in% names(rjarg)){
+                        ## autorun defaults
+                        if(!(""r"" %in% names(rjarg$raftery.options))){
+                            rjarg$raftery.options$r <- .01
+                        }
+                        if(!(""converge.eps"" %in% names(rjarg$raftery.options))){
+                            rjarg$raftery.options$converge.eps <- .01
+                        }
+                    } else {
+                        rjarg$raftery.options <- list(r=.01, converge.eps=.01)
+                    }
+                    if(!(""max.time"" %in% names(rjarg))) rjarg$max.time <- ""5m""
+                }
+                res <- try(do.call(rjcall, rjarg))
             } else {
-              res <- NULL
+                res <- NULL
             }
 
             if(inherits(res, ""try-error"")) {
@@ -346,34 +346,23 @@ blavaan <- function(...,  # default lavaan arguments
 
         lavpartable <- parests$lavpartable
         if(jag.do.fit){
-          lavmodel <- lav_model_set_parameters(lavmodel, x = x)
-
-          ## TODO: needed??
-          # overwrite lavpartable$est to include def/con values
-          #lavpartable$est <- lav_model_get_parameters(lavmodel = lavmodel,
-          #                                            type = ""user"", extra = TRUE)
-
-          attr(x, ""iterations"") <- res$sample
-          attr(x, ""converged"") <- TRUE
-
-          attr(x, ""control"") <- jagcontrol
-
-          attr(x, ""fx"") <- get_ll(lavmodel = lavmodel, lavpartable = lavpartable,
-                                  lavsamplestats = lavsamplestats, lavoptions = lavoptions,
-                                  lavcache = lavcache, lavdata = lavdata)[1]
+            lavmodel <- lav_model_set_parameters(lavmodel, x = x)
+            attr(x, ""iterations"") <- res$sample
+            attr(x, ""converged"") <- TRUE
+        } else {
+            x <- numeric(0L)
+            attr(x, ""iterations"") <- 0L
+            attr(x, ""converged"") <- FALSE          
+            lavpartable$est <- lavpartable$start
+        }
+        attr(x, ""control"") <- jagcontrol
 
+        if(!(""ordered"" %in% dotNames)) {
+            attr(x, ""fx"") <- get_ll(lavmodel = lavmodel, lavpartable = lavpartable,
+                                    lavsamplestats = lavsamplestats, lavoptions = lavoptions,
+                                    lavcache = lavcache, lavdata = lavdata)[1]
         } else {
-          x <- numeric(0L)
-          attr(x, ""iterations"") <- 0L; attr(x, ""converged"") <- FALSE
-          attr(x, ""control"") <- jagcontrol
-          attr(x, ""fx"") <- get_ll(lavmodel = lavmodel, 
-                                  lavpartable = lavpartable,
-                                  lavsamplestats = lavsamplestats,
-                                  lavoptions = lavoptions,
-                                  lavcache = lavcache,
-                                  lavdata = lavdata)[1]
-          
-          lavpartable$est <- lavpartable$start
+            attr(x, ""fx"") <- as.numeric(NA)
         }
     }
 "
ecmerkle,blavaan,5760e346949c67b9b45ea3ecf8c9040c7ed4abb3,ecmerkle,merklee@missouri.edu,2016-10-20T21:05:31Z,ecmerkle,merklee@missouri.edu,2016-10-20T21:05:31Z,fixes for ordinal estimation (variance matrices and eXo data),DESCRIPTION;R/lav_export_jags.R,False,True,True,False,14,4,18,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-3.124
+Version: 0.2-3.125
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_jags.R---
@@ -210,14 +210,18 @@ lav2jags <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
     if(blavmis == ""fi"") stop(""blavaan ERROR: missing='fi' not yet supported for ordinal data"")
     for(j in 1:nmvs){
       if(ov.names[j] %in% ov.ord){
-        tvname <- ""theta""
+        tvname <- partable$mat[partable$lhs == ov.names[j] &
+                               partable$lhs == partable$rhs &
+                               partable$op == ""~~"" &
+                               partable$group == 1]
         ord.num <- match(ov.names[j], ov.ord)
         TXT <- paste(TXT, t2, ""ones[i,"", ord.num, ""] ~ dbern(probs[i,"", ord.num,
                      "","", ov.names[j], ""[i]])\n"", sep="""")
 
         ## category probs from pnorm
         taus <- which(partable$lhs == ov.names[j] &
-                      partable$op == ""|"")
+                      partable$op == ""|"" &
+                      partable$group == 1)
         TXT <- paste(TXT, t2, ""probs[i,"", ord.num, "",1] <- pnorm(tau["", partable$row[taus[1]],
                      "","", partable$col[taus[1]], "",g[i]], mu[i,"", j, ""], 1/"", tvname, ""["", j, "","", j, "",g[i]])\n"", sep="""")
         if(ncats[ord.num] > 2){
@@ -456,10 +460,16 @@ lav2jags <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
 
     y <- lapply(1:tmpnmvs, function(x) rep(NA,ntot))
     g <- rep(NA, ntot)
+    nX <- ncol(lavdata@X[[1]])
     for(k in 1:ngroups){
-      for(j in 1:tmpnmvs){
+      for(j in 1:nX){
         y[[j]][lavdata@case.idx[[k]]] <- lavdata@X[[k]][,j]
       }
+      if(tmpnmvs > nX){
+        for(j in 1:(tmpnmvs - nX)){
+          y[[j + nX]][lavdata@case.idx[[k]]] <- lavdata@eXo[[k]][,j]
+        }
+      }
       g[lavdata@case.idx[[k]]] <- k
     }
     names(y) <- orig.ov.names"
ecmerkle,blavaan,ac08681315148968163fecf8787007129cfed90b,ecmerkle,merklee@missouri.edu,2016-10-07T14:56:19Z,ecmerkle,merklee@missouri.edu,2016-10-07T14:56:19Z,fix bug in summary() related to defined parameters,DESCRIPTION;R/blav_object_methods.R,False,True,True,False,2,1,3,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-3.120
+Version: 0.2-3.121
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blav_object_methods.R---
@@ -212,6 +212,7 @@ function(object, header       = TRUE,
 
         newpt <- object@ParTable
         newpt$group[newpt$group == 0] <- 1 # for defined parameters
+        PE$group[PE$group == 0] <- 1
 
         ## match jags names to partable, then partable to PE
         pte2 <- which(!is.na(newpt$jagpnum))"
ecmerkle,blavaan,4e79e17de32ec2174b97d197f7fccc79266f6af3,ecmerkle,merklee@missouri.edu,2016-10-06T18:19:29Z,ecmerkle,merklee@missouri.edu,2016-10-06T18:19:29Z,fix errors associated with := operator,R/lav_export_jags.R;R/set_inits.R,False,True,True,False,10,10,20,"---FILE: R/lav_export_jags.R---
@@ -120,8 +120,8 @@ lav2jags <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
     ov.names <- orig.ov.names[orig.ov.names %in% ov.names.nox]
     #ov.names <- ov.names.nox
   }
-  eqlabs <- partable$rhs[partable$op == ""==""]
-  eqplabs <- partable$lhs[partable$op == ""==""]
+  eqlabs <- partable$rhs[partable$op %in% c(""=="", "":="")]
+  eqplabs <- partable$lhs[partable$op %in% c(""=="", "":="")]
   eqplabs <- eqplabs[eqplabs %in% partable$label]
   eqlabs <- c(eqlabs, eqplabs)
 
@@ -152,13 +152,13 @@ lav2jags <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
   ## Smaller partables for different parameter types +
   ## dimensions of parameter matrices (for initial values)
   ovintercepts <- partable[ovi,]
-  ovintercepts <- rbind(ovintercepts, partable[which(partable$op == ""==""),])
+  ovintercepts <- rbind(ovintercepts, partable[which(partable$op %in% c(""=="", "":="")),])
   lvintercepts <- partable[lvi,]
-  lvintercepts <- rbind(lvintercepts, partable[which(partable$op == ""==""),])
+  lvintercepts <- rbind(lvintercepts, partable[which(partable$op %in% c(""=="", "":="")),])
   loadings <- partable[load,]
-  loadings <- rbind(loadings, partable[which(partable$op == ""==""),])
+  loadings <- rbind(loadings, partable[which(partable$op %in% c(""=="", "":="")),])
   regressions <- partable[reg,]
-  regressions <- rbind(regressions, partable[which(partable$op == ""==""),])
+  regressions <- rbind(regressions, partable[which(partable$op %in% c(""=="", "":="")),])
 
   ## for missing==""fi"", to model variables on rhs of regression
   ovreg <- unique(regressions$rhs[regressions$rhs %in% ov.names])
@@ -568,7 +568,7 @@ coeffun <- function(lavpartable, pxpartable, rjob, fun = ""mean"") {
   ## the jags model.
 
   ## remove any rhos or unnamed parameters
-  pxpartable <- pxpartable[!is.na(pxpartable$id) & pxpartable$op != ""=="",]
+  pxpartable <- pxpartable[!is.na(pxpartable$id) & !(pxpartable$op %in% c(""=="", "":="")),]
   pxnames <- paste(pxpartable$mat, ""["", pxpartable$row, "","", pxpartable$col,
                    "","", pxpartable$group, ""]"", sep="""")
   pxpartable$pxnames <- pxnames

---FILE: R/set_inits.R---
@@ -3,8 +3,8 @@ set_inits <- function(partable, ov.cp, lv.cp, n.chains, inits){
   ## TODO write start values to new columns of coefvec, so can include in partable
   initvals <- vector(""list"", n.chains)
   names(initvals) <- paste(""c"", 1:n.chains, sep="""")
-  pveclen <- max(partable$parnums, na.rm = TRUE)
-    
+  pveclen <- max(partable$parnums[partable$mat != """"], na.rm = TRUE)
+
   for(i in 1:n.chains){
     initvals[[i]] <- list(parvec = rep(NA, pveclen))
   }
@@ -31,7 +31,7 @@ set_inits <- function(partable, ov.cp, lv.cp, n.chains, inits){
 
   for(i in 1:nrow(partable)){
     eqcons <- which(partable$lhs == partable$label[i] &
-                    partable$op %in% c(""=="", "">"", ""<""))
+                    partable$op %in% c(""=="", "":="", "">"", ""<""))
     if((i %in% wps) | partable$free[i] == 0 | partable$prior[i] == """" | length(eqcons > 0)) next
 
     tmppri <- partable$prior[i]"
ecmerkle,blavaan,f2a15cbe14d89c2e77be58a2e1d91c0b8d3fec96,ecmerkle,merklee@missouri.edu,2016-09-20T17:30:15Z,ecmerkle,merklee@missouri.edu,2016-09-20T17:30:15Z,fix do.fit=FALSE,R/lav_export_jags.R,False,True,True,False,4,1,5,"---FILE: R/lav_export_jags.R---
@@ -610,7 +610,10 @@ coeffun <- function(lavpartable, pxpartable, rjob, fun = ""mean"") {
   }
 
   ptmatch <- match(lavpartable$free[lavpartable$free > 0], pxpartable$free)
-  lavpartable$est[lavpartable$free > 0] <- pxpartable$est[ptmatch]
+  if(""est"" %in% names(pxpartable)){
+    ## to handle do.fit = FALSE
+    lavpartable$est[lavpartable$free > 0] <- pxpartable$est[ptmatch]
+  }
   lavpartable$psrf <- rep(NA, length(lavpartable$free))
   lavpartable$psrf[lavpartable$free > 0] <- pxpartable$psrf[ptmatch]
   lavpartable$prior[lavpartable$free > 0] <- pxpartable$prior[ptmatch]"
ecmerkle,blavaan,e7a6ea338c3d0b5e7653425baafa08394d479b7f,ecmerkle,merklee@missouri.edu,2016-09-20T16:49:29Z,ecmerkle,merklee@missouri.edu,2016-09-20T16:49:29Z,improved handling of failures to obtain loglikelihoods,R/blav_utils.R,False,True,True,False,11,7,18,"---FILE: R/blav_utils.R---
@@ -78,15 +78,19 @@ get_ll <- function(postsamp       = NULL, # one posterior sample
                                slotSampleStats = lavsamplestats,
                                slotData = lavdata,
                                slotCache = lavcache), silent=TRUE)
-        fit.samp@Options$se <- ""standard"" # for nonnest2
+        if(!inherits(fit.samp, ""try-error"")){
+            fit.samp@Options$se <- ""standard"" # for nonnest2
 
-        if(casewise){
-            ll.samp <- llcont(fit.samp)
-        } else if(measure == ""logl""){
-            ll.samp <- c(fitMeasures(fit.samp, ""logl""),
-                         fitMeasures(fit.samp, ""unrestricted.logl""))
+            if(casewise){
+                ll.samp <- llcont(fit.samp)
+            } else if(measure == ""logl""){
+                ll.samp <- c(fitMeasures(fit.samp, ""logl""),
+                             fitMeasures(fit.samp, ""unrestricted.logl""))
+            } else {
+                ll.samp <- fitMeasures(fit.samp, measure)
+            }
         } else {
-            ll.samp <- fitMeasures(fit.samp, measure)
+            ll.samp <- NA
         }
     }
 "
ecmerkle,blavaan,46e5301b0fd18c4d5f23b4f3de495dcf494d72a6,ecmerkle,merklee@missouri.edu,2016-09-12T19:15:40Z,ecmerkle,merklee@missouri.edu,2016-09-12T19:15:40Z,minor fix for using llcont() under new nonnest2,R/blav_utils.R,False,True,True,False,1,0,1,"---FILE: R/blav_utils.R---
@@ -78,6 +78,7 @@ get_ll <- function(postsamp       = NULL, # one posterior sample
                                slotSampleStats = lavsamplestats,
                                slotData = lavdata,
                                slotCache = lavcache), silent=TRUE)
+        fit.samp@Options$se <- ""standard"" # for nonnest2
 
         if(casewise){
             ll.samp <- llcont(fit.samp)"
ecmerkle,blavaan,4b5cbcb609d462ce101f2b3cab1b729eafce0de5,ecmerkle,merklee@missouri.edu,2016-09-09T18:37:42Z,ecmerkle,merklee@missouri.edu,2016-09-09T18:37:42Z,fix margloglik() and remove unneeded jlabel/merging,DESCRIPTION,False,False,False,False,1,1,2,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-1.90
+Version: 0.2-1.95
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),"
ecmerkle,blavaan,c4a2cd88f593a438be9d77ab021ff9d969c9d4c4,ecmerkle,merklee@missouri.edu,2016-09-09T18:36:31Z,ecmerkle,merklee@missouri.edu,2016-09-09T18:36:31Z,fix margloglik() and get rid of unneeded jlabel/merging,DESCRIPTION;R/blav_utils.R;R/blavaan.R;R/margloglik.R,False,True,True,False,9,59,68,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-1.89
+Version: 0.2-1.90
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blav_utils.R---
@@ -1,54 +1,4 @@
 ## utility functions for blavaan
-mergejag <- function(lavpartable, coefvec){
-    ## add results of jags translation to the partable
-    ## TODO plus starting values
-    plmatch <- sapply(coefvec$plabel, function(x) strsplit(x, ""@"")[[1]][1])
-    pldups <- duplicated(plmatch)
-
-    ## distinguish rhos from others
-    rhos <- grepl(""rho"", coefvec$jlabel)
-
-    ## match existing parameters with partable
-    parlocs <- match(plmatch[!rhos & !pldups], lavpartable$plabel)
-    lavpartable$plabel[parlocs] <- coefvec$plabel[!rhos & !pldups]
-
-    ## add priors to partable
-    nrlpt <- length(lavpartable$plabel)
-    if(!(""prior"" %in% names(lavpartable))) lavpartable$prior <- rep("""", nrlpt)
-    lavpartable$prior[parlocs] <- coefvec$prior[!rhos & !pldups]
-
-    ## add jags labels (jlabel)
-    lavpartable$jlabel <- rep("""", nrlpt)
-    lavpartable$jlabel[parlocs] <- coefvec$jlabel[!rhos & !pldups]
-
-    ## create new rho rows (that's a pun!) if needed and add info
-    nrhos <- sum(rhos)
-    if(nrhos > 0){
-        lavpartable <- lapply(lavpartable, function(x) c(x, rep(NA, nrhos)))
-        rhof <- nrlpt + 1
-        rhol <- nrlpt + nrhos
-
-        ## fill in most stuff the same as covariances
-        covpars <- which(grepl(""cov"", lavpartable$jlabel) & !(grepl(""dwish"", lavpartable$prior)) & grepl(""@"", lavpartable$plabel))
-
-        samevals <- c(""id"", ""lhs"", ""op"", ""rhs"", ""user"", ""group"", ""ustart"",
-                      ""exo"", ""label"", ""prior"")
-
-        for(i in 1:length(samevals)){
-            nameloc <- which(names(lavpartable) == samevals[i])
-            lavpartable[[nameloc]][rhof:rhol] <- lavpartable[[nameloc]][covpars]
-        }
-
-        ## remove priors from covariance parameters, because they technically have none?
-        lavpartable$prior[covpars] <- """"
-        lavpartable$free[rhof:rhol] <- 0L # so that parameterEstimates() works
-
-        lavpartable$plabel[rhof:rhol] <- coefvec$plabel[rhos]
-        lavpartable$jlabel[rhof:rhol] <- coefvec$jlabel[rhos]
-    }
-    
-    lavpartable
-}
 
 ## calculate model log-likelihood given some sampled parameter
 ## values (with lvs integrated out)
@@ -317,10 +267,13 @@ add_monitors <- function(lavpartable, lavjags, jagextra){
     monres <- vector(""list"", length(jagextra$monitor))
     for(i in 1:length(jagextra$monitor)){
         tmploc <- grep(paste(""^"", jagextra$monitor[i], sep=""""), rownames(lavjags$summaries))
-        monres[[i]] <- list(xlocs = tmploc, xnms = rownames(lavjags$summaries)[tmploc],
+        tmploc2 <- grep(paste(""^"", jagextra$monitor[i], sep=""""), rownames(lavjags$psrf$psrf))
+        monres[[i]] <- list(xlocs = tmploc, psrfloc = tmploc2,
+                            xnms = rownames(lavjags$summaries)[tmploc],
                             nvars = length(tmploc))
     }
     xlocs <- sapply(monres, function(x) x$xlocs)
+    psrflocs <- sapply(monres, function(x) x$psrfloc)
     xnms <- sapply(monres, function(x) x$xnms)
     nvars <- sapply(monres, function(x) x$nvars)
         
@@ -340,7 +293,9 @@ add_monitors <- function(lavpartable, lavjags, jagextra){
     lavpartable$est <- c(lavpartable$est, lavjags$summaries[xlocs,'Mean'])
     lavpartable$se <- c(lavpartable$se, lavjags$summaries[xlocs,'SD'])
     lavpartable$prior <- c(lavpartable$prior, rep("""", sum(nvars)))
-    lavpartable$jlabel <- c(lavpartable$jlabel, xnms)
+    lavpartable$psrf <- c(lavpartable$psrf, lavjags$psrf$psrf[psrflocs,1])
+    lavpartable$pxnames <- c(lavpartable$pxnames, xnms)
+    lavpartable$jagpnum <- c(lavpartable$jagpnum, xlocs)
     lavpartable$logBF <- c(lavpartable$logBF, rep(NA, sum(nvars)))
 
     lavpartable

---FILE: R/blavaan.R---
@@ -436,14 +436,9 @@ blavaan <- function(...,  # default lavaan arguments
 
     ## 9b. misc blavaan changes to partable
     ## remove rhos from partable + ses, so lavaan built-ins work
-    rhos <- grep(""rho"", lavpartable$jlabel)
     lavjags <- c(lavjags, list(origpt = lavpartable,
                                inits = jagtrans$inits))
     class(lavjags) <- ""runjags""
-    if(length(rhos) > 0){
-        lavpartable <- lapply(lavpartable, function(x) x[-rhos])
-        lavfit@se <- lavfit@se[-rhos]
-    }
 
     ## add monitors in jagextra as defined variables
     if(length(jagextra$monitor) > 0){

---FILE: R/margloglik.R---
@@ -136,7 +136,7 @@ margloglik <- function(lavpartable, lavmodel, lavoptions,
     } else {
       ## we have an explicit prior;
       ## convert to R parameterization of distributions & evaluate
-      tmpdens <- eval_prior(pricom[[i]], thetstar[i], lavpartable$jlabel[urows][i])
+      tmpdens <- eval_prior(pricom[[i]], thetstar[i], lavpartable$pxnames[urows][i])
     }
     priloglik <- priloglik + tmpdens
   }"
ecmerkle,blavaan,be532ebd8f04920f8e92e12de2ea8317cd4272ad,ecmerkle,merklee@missouri.edu,2016-09-07T16:02:28Z,ecmerkle,merklee@missouri.edu,2016-09-07T16:02:28Z,fix [sd] and [var] prior modifiers,R/set_priors.R,False,True,True,False,3,2,5,"---FILE: R/set_priors.R---
@@ -88,14 +88,15 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x){
 
                 vpri <- grepl(""\\[var\\]"", partable$prior[i])
                 spri <- grepl(""\\[sd\\]"", partable$prior[i])
+                jagpri <- strsplit(partable$prior[i], ""\\["")[[1]][1]
                 if(!vpri & (grepl(""theta"", partable$mat[i]) | grepl(""psi"", partable$mat[i]))){
                     sq <- ifelse(spri, ""2"", ""-1"")
                     TXT3 <- paste(TXT3, "" <- pow(pvec"", partable$parnums[i], "","", sq,
                                   "")\n"", sep="""")
                     TXT3 <- paste(TXT3, t1, ""pvec"", partable$parnums[i], "" ~ "",
-                                  partable$prior[i], sep="""")
+                                  jagpri, sep="""")
                 } else {
-                    TXT3 <- paste(TXT3, "" ~ "", partable$prior[i], sep="""")
+                    TXT3 <- paste(TXT3, "" ~ "", jagpri, sep="""")
                 }
             }
 "
ecmerkle,blavaan,6f6ec15c46c2214c0c459b9f460545032583dd10,ecmerkle,merklee@missouri.edu,2016-08-30T01:58:48Z,ecmerkle,merklee@missouri.edu,2016-08-30T01:58:48Z,fix summary() for models with equality constraints,R/blav_object_methods.R,False,True,True,False,4,2,6,"---FILE: R/blav_object_methods.R---
@@ -269,8 +269,10 @@ function(object, header       = TRUE,
         }
         ## alternative names because this is not ML
         penames <- names(PE)
-        names(PE)[penames == ""est""] <- ""Post.Mean""
-        PE$est <- PE$Post.Mean
+        ## This could be called ""Post.Mean"" except constraints
+        ## require ""est""
+        #names(PE)[penames == ""est""] <- ""Post.Mean""
+        #PE$est <- PE$Post.Mean
         names(PE)[penames == ""se""] <- ""Post.SD""
         names(PE)[penames == ""ci.lower""] <- ""HPD.025""
         names(PE)[penames == ""ci.upper""] <- ""HPD.975"""
ecmerkle,blavaan,0b5496242faf06faeac9d85b15cf2136014df9b5,ecmerkle,merklee@missouri.edu,2016-08-30T01:50:00Z,ecmerkle,merklee@missouri.edu,2016-08-30T01:50:00Z,fix summary() for models with parameter constraints,DESCRIPTION;R/blav_object_methods.R,False,True,True,False,2,2,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.2-1.80
+Version: 0.2-1.85
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blav_object_methods.R---
@@ -269,8 +269,8 @@ function(object, header       = TRUE,
         }
         ## alternative names because this is not ML
         penames <- names(PE)
-        ## FIXME we need an est column for print.lavaan if we have constraints
         names(PE)[penames == ""est""] <- ""Post.Mean""
+        PE$est <- PE$Post.Mean
         names(PE)[penames == ""se""] <- ""Post.SD""
         names(PE)[penames == ""ci.lower""] <- ""HPD.025""
         names(PE)[penames == ""ci.upper""] <- ""HPD.975"""
ecmerkle,blavaan,7d9951e3c37bec46fe396512cdf3fc89f738a7ff,ecmerkle,merklee@missouri.edu,2016-08-29T21:11:01Z,ecmerkle,merklee@missouri.edu,2016-08-29T21:11:01Z,fix margloglik when cp='fa',R/margloglik.R,False,True,True,False,15,9,24,"---FILE: R/margloglik.R---
@@ -7,9 +7,11 @@ margloglik <- function(lavpartable, lavmodel, lavoptions,
   ## unique parameters (remove equality constraints and
   ## cov parameters under srs priors)
   eqpars <- lavpartable$rhs[lavpartable$op == ""==""]
+  fixpars <- which(lavpartable$free == 0)
   urows <- 1:length(lavpartable$pxnames)
   urows <- urows[!is.na(lavpartable$pxnames) &
-                 !(lavpartable$plabel %in% eqpars)]
+                 !(lavpartable$plabel %in% eqpars) &
+                 !(urows %in% fixpars)]
 
   q <- length(urows)
 
@@ -78,15 +80,21 @@ margloglik <- function(lavpartable, lavmodel, lavoptions,
                    lavpartable$lhs[urows] != lavpartable$rhs[urows])
 
   lv.names <- lav_partable_attributes(partable = lavpartable, pta = NULL)$vnames$lv
-  lcpcovs <- which(!(lavpartable$lhs[urows] %in% unlist(lv.names)) &
-                   !(lavpartable$rhs[urows] %in% unlist(lv.names)) &
+  lcpcovs <- which(lavpartable$lhs[urows] %in% unlist(lv.names) &
+                   lavpartable$rhs[urows] %in% unlist(lv.names) &
                    lavpartable$op[urows] == ""~~"" &
                    lavpartable$lhs[urows] != lavpartable$rhs[urows])
   
   if(lavoptions$cp == ""fa""){
-    ocpvars <- unique(c(lavpartable$lhs[urows][ocpcovs], lavpartable$rhs[urows][ocpcovs]))
-
-    lcpvars <- unique(c(lavpartable$lhs[urows][lcpcovs], lavpartable$rhs[urows][lcpcovs]))
+    ocpvars <- which(lavpartable$lhs[urows] %in% unlist(lavdata@ov.names) &
+                     lavpartable$rhs[urows] %in% unlist(lavdata@ov.names) &
+                     lavpartable$op[urows] == ""~~"" &
+                     lavpartable$lhs[urows] == lavpartable$rhs[urows])
+
+    lcpvars <- which(lavpartable$lhs[urows] %in% unlist(lv.names) &
+                     lavpartable$rhs[urows] %in% unlist(lv.names) &
+                     lavpartable$op[urows] == ""~~"" &
+                     lavpartable$lhs[urows] == lavpartable$rhs[urows])
   } else {
     ocpvars <- """"
     lcpvars <- """"
@@ -119,9 +127,7 @@ margloglik <- function(lavpartable, lavmodel, lavoptions,
         tmpkd <- density(tmpdist)
         tmpdens <- log(approx(tmpkd$x, tmpkd$y, thetstar[i])$y)
       }
-    } else if(lavpartable$lhs[urows][i] %in% c(ocpvars, lcpvars) &
-              lavpartable$op[urows][i] == ""~~"" &
-              lavpartable$rhs[urows][i] == lavpartable$lhs[urows][i]){
+    } else if(i %in% c(ocpvars, lcpvars)){
       ## kernel density estimation of fa variance's prior
       tmpdist <- (rnorm(1e5,sd=sqrt(1/1e-4))*rnorm(1e5,sd=sqrt(1/1e-4)))/rgamma(1e5,1,.5) +
                  1/rgamma(1e5, as.numeric(pricom[[i]][2]), as.numeric(pricom[[i]][3]))"
ecmerkle,blavaan,b15ec301bcd305fd4a91e4abbf11b4e0f78d10ce,ecmerkle,merklee@missouri.edu,2016-08-24T17:41:03Z,ecmerkle,merklee@missouri.edu,2016-08-24T17:41:03Z,corrections to margloglik with wishart priors,R/margloglik.R;R/set_priors.R,False,True,True,False,17,16,33,"---FILE: R/margloglik.R---
@@ -45,17 +45,18 @@ margloglik <- function(lavpartable, lavmodel, lavoptions,
   wps <- which(sapply(pricom, function(x) x[1] == ""dwish""))
   if(length(wps) > 0){
     ngroups <- max(lavpartable$group)
-    dimen <- sum(grepl(""dwish"", lavpartable$prior) &
-                 grepl(""psi"", lavpartable$jlabel) &
-                 grepl("",1]"", lavpartable$jlabel))
     for(k in 1:ngroups){
-      tmpmat <- diag(lavpartable$est[grepl(""psi"", lavpartable$jlabel) &
-                                     grepl(paste("","", ngroups, ""]"", sep=""""), lavpartable$jlabel)])
-      covlocs <- grepl(""cov"", lavpartable$jlabel) &
-                                                   grepl(""dwish"", lavpartable$prior) &
-                                                   grepl(paste("","", ngroups, ""]"", sep=""""), lavpartable$jlabel)
-      if(sum(covlocs) > 0){
-        tmpmat[lower.tri(tmpmat)] <- lavpartable$est[covlocs]
+      varpars <- which(grepl(""dwish"", lavpartable$prior) &
+                       lavpartable$group == k &
+                       lavpartable$lhs == lavpartable$rhs)
+      dimen <- length(varpars)
+      tmpmat <- diag(lavpartable$est[varpars])
+      ## TODO? ensure that covpars are ordered the same as varpars?
+      covpars <- which(grepl(""dwish"", lavpartable$prior) &
+                       lavpartable$group == k &
+                       lavpartable$lhs != lavpartable$rhs)
+      if(length(covpars) > 0){
+        tmpmat[lower.tri(tmpmat)] <- lavpartable$est[covpars]
       }
       tmpmat <- tmpmat + t(tmpmat)
       diag(tmpmat) <- diag(tmpmat)/2

---FILE: R/set_priors.R---
@@ -8,13 +8,13 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x){
     TXT3 <- paste(""\n\n"", t1, ""# Priors/constraints"", sep="""")
 
     ## find parameters with wishart priors
-    wishpars <- 0
-    if(lv.x.wish){
+    wishpars <- NULL
+    if(lv.x.wish & length(lv.names.x) > 1){
       wishpars <- which(partable$lhs %in% lv.names.x &
                         partable$rhs %in% lv.names.x &
                         partable$op == ""~~"")
     }
-      
+
     for(i in 1:nrow(partable)){
         if(partable$mat[i] != """" & !(i %in% wishpars)){
             ## to find equality constraints
@@ -110,9 +110,9 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x){
       nlvx <- length(lv.names.x)
       ngroups <- max(partable$group, na.rm = TRUE)
 
-      TXT3 <- paste(TXT3, t1, ""for(k in 1:"", ngroups, "") {\n"", t2,
-                    ""ibpsi[1:"", nlvx, "",1:"", nlvx, "",k] ~ dwish(iden,"", nlvx+1, "")\n"",
-                    sep="""")
+      TXT3 <- paste(TXT3, ""\n"", t1, ""for(k in 1:"", ngroups,
+                    "") {\n"", t2, ""ibpsi[1:"", nlvx, "",1:"", nlvx,
+                    "",k] ~ dwish(iden,"", nlvx+1, "")\n"", sep="""")
       
       TXT3 <- paste(TXT3, t2, ""bpsi[1:"", nlvx, "",1:"", nlvx, "",k] <- inverse(ibpsi[1:"",
                     nlvx, "",1:"", nlvx, "",k])\n"", t1, ""}\n"", sep="""")"
ecmerkle,blavaan,d4f9996202c3b93eaf841af9a65c112f229c618a,ecmerkle,merklee@missouri.edu,2016-08-15T21:39:39Z,ecmerkle,merklee@missouri.edu,2016-08-15T21:39:39Z,fix parallel postpred,DESCRIPTION;R/postpred.R,False,True,True,False,8,4,12,"---FILE: DESCRIPTION---
@@ -12,5 +12,5 @@ Description: Fit a variety of Bayesian latent variable models, including confirm
    factor analysis, structural equation models, and latent growth curve models.
 Depends: R(>= 3.2.0), methods, runjags, lavaan(>= 0.5-20)
 Imports: stats, utils, graphics, MASS, MCMCpack, mnormt, nonnest2, loo
-Suggests: modeest, rjags, semTools
+Suggests: modeest, rjags, semTools, parallel
 License: GPL (>= 2)

---FILE: R/postpred.R---
@@ -13,7 +13,7 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
     ncores <- NA
     loop.comm <- ""lapply""
     if(requireNamespace(""parallel"", quietly = TRUE)){
-      ncores <- min(n.chains, detectCores())
+      ncores <- min(n.chains, parallel::detectCores())
       loop.comm <- ""mclapply""
     }
   
@@ -132,9 +132,13 @@ postpred <- function(lavpartable, lavmodel, lavoptions,
       list(ind = ind, csdist = csdist)
     })
 
-    if(loop.comm == ""mclapply"") loop.args <- c(loop.args, list(mc.cores = ncores))
+    if(loop.comm == ""mclapply""){
+        loop.args <- c(loop.args, list(mc.cores = ncores))
+        res <- do.call(parallel::mclapply, loop.args)
+    } else {
+        res <- do.call(lapply, loop.args)
+    }
 
-    res <- do.call(loop.comm, args = loop.args)
     ind <- unlist(lapply(res, function(x) x$ind))
     csdist <- unlist(lapply(res, function(x) x$csdist))
 "
ecmerkle,blavaan,218a5fff23d012fd254971b65a88e4b8f4e268ae,ecmerkle,merklee@missouri.edu,2016-08-12T03:35:33Z,ecmerkle,merklee@missouri.edu,2016-08-12T03:35:33Z,fixes to margloglik under parvec approach,R/blav_utils.R;R/margloglik.R,False,True,True,False,55,47,102,"---FILE: R/blav_utils.R---
@@ -258,7 +258,7 @@ set_blocks <- function(partable){
 }
 
 ## evaluate prior density using result of jagsdist2r
-eval_prior <- function(pricom, thetstar, jlabel){
+eval_prior <- function(pricom, thetstar, pxname){
     ## check for truncation and [sd]/[var] modifiers
     trun <- which(pricom == ""T"")
     sdvar <- which(pricom %in% c(""[sd]"",""[var]""))
@@ -277,11 +277,10 @@ eval_prior <- function(pricom, thetstar, jlabel){
     }
 
     ## thetstar modifications:
-    ## convert beta with (-1,1) support to beta with (0,1)
-    if(grepl(""rho"", jlabel)) thetstar <- (thetstar+1)/2
     ## convert to precision or sd, vs variance (depending on prior)
-    if(jlabel %in% c(""theta"", ""psi"")){
-        if(length(sdvar) == 0) thetstar <- 1/thetstar
+    if(grepl(""theta"", pxname) | grepl(""psi"", pxname)){
+        ## FIXME assumes correlation prior under srs is dbeta
+        if(length(sdvar) == 0 & pricom[1] != ""dbeta"") thetstar <- 1/thetstar
         if(any(grepl(""\\[sd"", pricom))) thetstar <- sqrt(thetstar)
     }
     ## dt() in R assumes mean=0, precision=1

---FILE: R/margloglik.R---
@@ -2,31 +2,27 @@ margloglik <- function(lavpartable, lavmodel, lavoptions,
                        lavsamplestats, lavdata, lavcache, lavjags) {
   ## compute marginal log-likelihood given model output
   ## the lavs are created via blavaan()
-
   bayesout <- lavjags
-  
+
   ## unique parameters (remove equality constraints and
   ## cov parameters under srs priors)
-  urows <- 1:length(lavpartable$jlabel)
-  ## FIXME If there are inequality constraints or complex
-  ##       equality constraints, we may have problems here:
   eqpars <- lavpartable$rhs[lavpartable$op == ""==""]
-  urows <- urows[!(lavpartable$plabel %in% eqpars) &
-                 !grepl(""@"", lavpartable$plabel) &
-                 !lavpartable$jlabel == """"]
+  urows <- 1:length(lavpartable$pxnames)
+  urows <- urows[!is.na(lavpartable$pxnames) &
+                 !(lavpartable$plabel %in% eqpars)]
 
   q <- length(urows)
 
   ## re-arrange crosscorr rows/columns to match partable,
   ## then remove redundant rows/columns
-  rearr <- match(lavpartable$jlabel[urows], rownames(bayesout$crosscorr))
-  rearr <- rearr[!is.na(rearr)] # assume NAs only come at end (for deviance, etc)
+  rearr <- match(lavpartable$pxnames[urows], rownames(bayesout$crosscorr))
+  rearr2 <- match(lavpartable$pxnames[urows], rownames(bayesout$summary$statistics))
 
-  Jinv <- diag(bayesout$summary$statistics[rearr,""SD""]) %*%
+  Jinv <- diag(bayesout$summary$statistics[rearr2,""SD""]) %*%
           bayesout$crosscorr[rearr,rearr] %*%
-          diag(bayesout$summary$statistics[rearr,""SD""])
+          diag(bayesout$summary$statistics[rearr2,""SD""])
 
-  cmatch <- match(lavpartable$jlabel[urows],
+  cmatch <- match(lavpartable$pxnames[urows],
                   rownames(bayesout$summary$statistics),
                   nomatch=0)
 
@@ -40,7 +36,7 @@ margloglik <- function(lavpartable, lavmodel, lavoptions,
   pricom <- jagsdist2r(pri)
 
   ## warn about fa priors
-  if(any((sapply(pricom, length) == 0) & grepl(""cov"", lavpartable$jlabel[urows]))) warning(""blavaan WARNING: marginal log-likelihoods under ov.cp=fa or lv.cp=fa may be unstable."")
+  if(lavoptions$cp == ""fa"") warning(""blavaan WARNING: marginal log-likelihoods under ov.cp=fa or lv.cp=fa may be unstable."")
 
   ## evaluate each prior
   priloglik <- 0
@@ -74,35 +70,54 @@ margloglik <- function(lavpartable, lavmodel, lavoptions,
     wps <- 0
   }
 
-  ## pick out variance parameters under fa priors
-  if(lavoptions$ov.cp == ""fa""){
-    ocpcovs <- which(lavpartable$lhs[urows] %in% lavdata@ov.names &
-                     lavpartable$rhs[urows] %in% lavdata@ov.names &
-                     lavpartable$op[urows] == ""~~"" &
-                     lavpartable$lhs[urows] != lavpartable$rhs[urows])
+  ## pick out var/cov parameters under fa priors
+  ocpcovs <- which(lavpartable$lhs[urows] %in% unlist(lavdata@ov.names) &
+                   lavpartable$rhs[urows] %in% unlist(lavdata@ov.names) &
+                   lavpartable$op[urows] == ""~~"" &
+                   lavpartable$lhs[urows] != lavpartable$rhs[urows])
+
+  lv.names <- lav_partable_attributes(partable = lavpartable, pta = NULL)$vnames$lv
+  lcpcovs <- which(!(lavpartable$lhs[urows] %in% unlist(lv.names)) &
+                   !(lavpartable$rhs[urows] %in% unlist(lv.names)) &
+                   lavpartable$op[urows] == ""~~"" &
+                   lavpartable$lhs[urows] != lavpartable$rhs[urows])
+  
+  if(lavoptions$cp == ""fa""){
     ocpvars <- unique(c(lavpartable$lhs[urows][ocpcovs], lavpartable$rhs[urows][ocpcovs]))
-  } else {
-    ocpvars <- """"
-  }
-  if(lavoptions$lv.cp == ""fa""){
-    lcpcovs <- which(!(lavpartable$lhs[urows] %in% lavdata@ov.names) &
-                     !(lavpartable$rhs[urows] %in% lavdata@ov.names) &
-                     lavpartable$op[urows] == ""~~"" &
-                     lavpartable$lhs[urows] != lavpartable$rhs[urows])
+
     lcpvars <- unique(c(lavpartable$lhs[urows][lcpcovs], lavpartable$rhs[urows][lcpcovs]))
   } else {
+    ocpvars <- """"
     lcpvars <- """"
   }
 
   for(i in 1:q){
     if(i %in% wps) next # already got it above
-    ## TODO do we need to use dp in kernel density to get correct priors?
-    if(length(pricom[[i]])==0 & grepl(""cov"", lavpartable$jlabel[urows][i])){
-      ## deal with covariances under fa parameterization using
-      ## kernel density estimation of covariance parameter's prior
-      tmpdist <- rnorm(1e5,sd=sqrt(1/1e-4))*rnorm(1e5,sd=sqrt(1/1e-4))/rgamma(1e5,1,.5)
-      tmpkd <- density(tmpdist)
-      tmpdens <- log(approx(tmpkd$x, tmpkd$y, thetstar[i])$y)
+
+    if(i %in% c(ocpcovs, lcpcovs)){
+      if(lavoptions$cp == ""srs""){
+        ## for srs, convert to correlation and use eval_prior()
+        var1 <- which(lavpartable$lhs == lavpartable$lhs[urows][i] &
+                      lavpartable$lhs == lavpartable$rhs &
+                      lavpartable$op == ""~~"" &
+                      lavpartable$group == lavpartable$group[urows][i])
+        var2 <- which(lavpartable$lhs == lavpartable$rhs[urows][i] &
+                      lavpartable$lhs == lavpartable$rhs &
+                      lavpartable$op == ""~~"" &
+                      lavpartable$group == lavpartable$group[urows][i])
+        tstar <- thetstar[i]/sqrt(lavpartable$est[var1] * lavpartable$est[var2])
+        # convert to support on 0,1
+        tstar <- (tstar + 1)/2
+
+        tmpdens <- eval_prior(pricom[[i]], tstar, lavpartable$pxnames[urows][i])
+      } else {
+        ## fa; TODO? use dp in kernel density to get correct priors?
+        ## deal with covariances under fa parameterization using
+        ## kernel density estimation of covariance parameter's prior
+        tmpdist <- rnorm(1e5,sd=sqrt(1/1e-4))*rnorm(1e5,sd=sqrt(1/1e-4))/rgamma(1e5,1,.5)
+        tmpkd <- density(tmpdist)
+        tmpdens <- log(approx(tmpkd$x, tmpkd$y, thetstar[i])$y)
+      }
     } else if(lavpartable$lhs[urows][i] %in% c(ocpvars, lcpvars) &
               lavpartable$op[urows][i] == ""~~"" &
               lavpartable$rhs[urows][i] == lavpartable$lhs[urows][i]){
@@ -127,12 +142,6 @@ margloglik <- function(lavpartable, lavmodel, lavoptions,
   ## control() is part of lavmodel (for now)
   lavmodel@control <- list(optim.method=""none"")
 
-  ## to compute likelihood, we need to remove the rho rows
-  ## from lavpartable
-  rhos <- grep(""rho"", lavpartable$jlabel)
-  if(length(rhos) > 0) lavpartable <- lapply(lavpartable, function(x) x[-rhos])
-  lavpartable$plabel <- sapply(lavpartable$plabel, function(x) strsplit(x, ""@"")[[1]][1])
-
   fit.new <- try(lavaan(slotParTable = lavpartable,
                         slotModel = lavmodel,
                         slotOptions = lavoptions,
@@ -145,7 +154,7 @@ margloglik <- function(lavpartable, lavmodel, lavoptions,
   } else {
     loglik <- NA
   }
-  ##print(c(priloglik, loglik, log(det(Jinv))))
+  print(c(priloglik, loglik, log(det(Jinv))))
   margloglik <- (q/2)*log(2*pi) + log(det(Jinv))/2 +
                 priloglik + loglik
   names(margloglik) <- """""
ecmerkle,blavaan,86ae42b539d670c340f188fd51df985c08c680e5,ecmerkle,merklee@missouri.edu,2016-08-08T20:33:27Z,ecmerkle,merklee@missouri.edu,2016-08-08T20:33:27Z,fix truncation of priors under std.lv,R/blavaan.R;R/set_partable.R;R/set_priors.R,False,True,True,False,12,3,15,"---FILE: R/blavaan.R---
@@ -167,7 +167,14 @@ blavaan <- function(...,  # default lavaan arguments
         ## first loading for each lv
         loadpt <- LAV@ParTable$op == ""=~""
         lvs <- unique(LAV@ParTable$lhs[loadpt])
-        fload <- sapply(lvs, function(x) which(LAV@ParTable$lhs[loadpt] == x)[1])
+        fload <- NULL
+        for(i in 1:length(lvs)){
+            for(k in 1:max(LAV@ParTable$group)){
+                fload <- c(fload, which(LAV@ParTable$lhs == lvs[i] &
+                                        LAV@ParTable$op == ""=~"" &
+                                        LAV@ParTable$group == k)[1])
+            }
+        }
 
         for(i in 1:length(fload)){
             if(LAV@ParTable$prior[fload[i]] != """"){

---FILE: R/set_partable.R---
@@ -205,7 +205,7 @@ nlvcovs)
         tpcs <- tpcs + 1
         if((ctype == ""ov"" & ov.cp == ""srs"") | (ctype == ""lv"" & lv.cp == ""srs"")){
           rhomat <- ""rho""
-          if(ctype == ""lv"") rhomat <- ""lvrho""
+          if(partable$mat[i] == ""psi"") rhomat <- ""lvrho""
           rhoind <- paste(partable$row[covpars[i]], "","", partable$col[covpars[i]], sep="""")
           ## srs priors
           partable$free[tmprows[1:3]] <- 0

---FILE: R/set_priors.R---
@@ -63,7 +63,9 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x){
             } else {
                 ## needs a prior
                 if(partable$prior[i] == """"){
-                    if(grepl(""star"", partable$mat[i])){
+                    if(partable$mat[i] == ""lvrho""){
+                        partype <- grep(""rho"", names(dp))
+                    } else if(grepl(""star"", partable$mat[i])){
                         pname <- paste(""i"", strsplit(partable$mat[i], ""star"")[[1]][1], sep="""")
                         partype <- grep(pname, names(dp))
                     } else {"
ecmerkle,blavaan,254c934b1706c429f4783f2e11a61c2bdb771b59,ecmerkle,merklee@missouri.edu,2016-08-08T00:27:36Z,ecmerkle,merklee@missouri.edu,2016-08-08T00:27:36Z,fix problem with rho indexing,R/set_partable.R,False,True,True,False,6,4,10,"---FILE: R/set_partable.R---
@@ -204,18 +204,20 @@ nlvcovs)
         ## Decide what priors to use
         tpcs <- tpcs + 1
         if((ctype == ""ov"" & ov.cp == ""srs"") | (ctype == ""lv"" & lv.cp == ""srs"")){
+          rhomat <- ""rho""
+          if(ctype == ""lv"") rhomat <- ""lvrho""
           rhoind <- paste(partable$row[covpars[i]], "","", partable$col[covpars[i]], sep="""")
           ## srs priors
           partable$free[tmprows[1:3]] <- 0
           partable$exo[tmprows[1:3]] <- 0
-          partable$ustart[tmprows[1]] <- paste(""sqrt(abs(rho["", rhoind, "","", k, ""])*"", tmpv1, "")"", sep="""")
-          partable$ustart[tmprows[2]] <- paste(""(-1 + 2*step(rho["", rhoind, "","", k,
-                                             ""]))*sqrt(abs(rho["", rhoind, "","", k, ""])*"", tmpv2, "")"", sep="""")
+          partable$ustart[tmprows[1]] <- paste(""sqrt(abs("", rhomat, ""["", rhoind, "","", k, ""])*"", tmpv1, "")"", sep="""")
+          partable$ustart[tmprows[2]] <- paste(""(-1 + 2*step("", rhomat, ""["", rhoind, "","", k,
+                                             ""]))*sqrt(abs("", rhomat, ""["", rhoind, "","", k, ""])*"", tmpv2, "")"", sep="""")
           partable$ustart[tmprows[3]] <- 1
           partable$mat[tmprows[3]] <- ""psi""
           partable$row[tmprows[3]] <- partable$col[tmprows[3]] <- tpcs
 
-          partable$id[covparg] <- paste(""rho["", rhoind, "","", k, ""]"", sep="""")
+          partable$id[covparg] <- paste(rhomat, ""["", rhoind, "","", k, ""]"", sep="""")
           partable$plabel[tmprows] <- paste("".p"", tmprows,
                                                    ""."", sep="""")
 "
ecmerkle,blavaan,95f8785e0c90c1c977c5f6ac817ce5d9ee266471,ecmerkle,merklee@missouri.edu,2016-08-08T00:04:57Z,ecmerkle,merklee@missouri.edu,2016-08-08T00:04:57Z,fix variance indexing issue and fixed exo parameters,R/blavaan.R;R/lav_export_jags.R;R/set_partable.R;R/set_priors.R,False,True,True,False,9,8,17,"---FILE: R/blavaan.R---
@@ -1,7 +1,3 @@
-# blavaan2
-#
-# different strategy: call lavaan() first, without fitting
-
 blavaan <- function(...,  # default lavaan arguments
  
                     # bayes-specific stuff

---FILE: R/lav_export_jags.R---
@@ -183,7 +183,7 @@ lav2jags <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
         }
           
         TXT <- paste(TXT, t2, ov.names[j], 
-                     ""[i] ~ dnorm(mu[i,"", j, ""], 1/"", tvname, ""["", j, "","", j, "",g[i]])\n"",
+                     ""[i] ~ dnorm(mu[i,"", j, ""], 1/"", tvname, ""["", partable$row[mvvar], "","", partable$col[mvvar], "",g[i]])\n"",
                      sep="""")
       }
     } else {

---FILE: R/set_partable.R---
@@ -436,6 +436,6 @@ set_phanvars <- function(partable, ov.names, lv.names, ov.cp, lv.cp, ngroups){
                 partable$ustart[vvar] <- eqconst
             }
         }
-    }    
+    }
     partable
 }

---FILE: R/set_priors.R---
@@ -32,8 +32,13 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x){
             }
           
             if(partable$free[i] == 0){
-                TXT3 <- paste(TXT3, "" <- "", partable$ustart[i],
-                              sep="""")
+                TXT3 <- paste(TXT3, "" <- "", sep="""")
+                if(is.na(partable$ustart[i])){
+                    ## exo
+                    TXT3 <- paste(TXT3, partable$start[i], sep="""")
+                } else {
+                    TXT3 <- paste(TXT3, partable$ustart[i], sep="""")
+                }
             } else if(length(eqpar) > 0){
                 eqpar <- which(partable$plabel == partable$lhs[eqpar])
                 TXT3 <- paste(TXT3, "" <- parvec["", partable$parnums[eqpar],"
ecmerkle,blavaan,6a13c9caf18996e8be8601bac83137bbae20b992,ecmerkle,merklee@missouri.edu,2016-08-07T23:21:18Z,ecmerkle,merklee@missouri.edu,2016-08-07T23:21:18Z,multiple group cfa fixed,R/lav_export_jags.R,False,True,True,False,21,21,42,"---FILE: R/lav_export_jags.R---
@@ -572,6 +572,7 @@ coeffun <- function(lavpartable, pxpartable, rjob, fun = ""mean"") {
   pxpartable <- subset(pxpartable, !is.na(id) & op != ""=="")
   pxnames <- paste(pxpartable$mat, ""["", pxpartable$row, "","", pxpartable$col,
                    "","", pxpartable$group, ""]"", sep="""")
+  pxpartable$pxnames <- pxnames
 
   ## posterior means:
   if(fun == ""mean""){
@@ -581,11 +582,12 @@ coeffun <- function(lavpartable, pxpartable, rjob, fun = ""mean"") {
   }
 
   ## from jags to pxpartable
-  cmatch <- match(names(b.est), pxnames, nomatch=0)
-  pxpartable$est[cmatch[cmatch != 0]] <- b.est[cmatch != 0]
-  psrfmatch <- match(rownames(rjob$psrf$psrf), pxnames, nomatch=0)
+  cmatch <- match(pxnames, names(b.est), nomatch=0)
+  pxpartable$est <- b.est[cmatch]
+  psrfmatch <- match(pxnames, rownames(rjob$psrf$psrf))
   pxpartable$psrf <- rep(NA, length(pxpartable$free))
-  pxpartable$psrf[psrfmatch[psrfmatch != 0]] <- rjob$psrf$psrf[psrfmatch != 0,1]
+  pxpartable$psrf <- rjob$psrf$psrf[psrfmatch,1]
+  pxpartable$jagpnum <- cmatch
 
   ## from pxpartable to lavpartable
   ## first check for px parameters with ""free"" labels (fa priors)
@@ -605,29 +607,27 @@ coeffun <- function(lavpartable, pxpartable, rjob, fun = ""mean"") {
       }
     }
   }
-  
-  ptmatch <- match(pxpartable$free[pxpartable$free > 0], lavpartable$free, nomatch=0)
-  lavpartable$est[ptmatch] <- pxpartable$est[pxpartable$free > 0]
+
+  ptmatch <- match(lavpartable$free[lavpartable$free > 0], pxpartable$free)
+  lavpartable$est[lavpartable$free > 0] <- pxpartable$est[ptmatch]
   lavpartable$psrf <- rep(NA, length(lavpartable$free))
-  lavpartable$psrf[ptmatch] <- pxpartable$psrf[pxpartable$free > 0]
-  lavpartable$prior[ptmatch] <- pxpartable$prior[pxpartable$free > 0]
+  lavpartable$psrf[lavpartable$free > 0] <- pxpartable$psrf[ptmatch]
+  lavpartable$prior[lavpartable$free > 0] <- pxpartable$prior[ptmatch]
+  lavpartable$pxnames[lavpartable$free > 0] <- pxpartable$pxnames[ptmatch]
+  lavpartable$jagpnum[lavpartable$free > 0] <- pxpartable$jagpnum[ptmatch]
   
-  ## from lavpartable to jags
-  xmatch <- match(lavpartable$free[lavpartable$free > 0],
-                  pxpartable$free)
-  jmatch <- match(pxnames, names(b.est))
-  lavpartable$jagpnum <- rep(NA, length(lavpartable$free))
-  lavpartable$jagpnum[lavpartable$free > 0] <- jmatch[xmatch]
-
   ## NB this automatically removes fixed parameters, just
   ##    like the psrf
-  vcorr <- rjob$crosscorr[order(psrfmatch[psrfmatch != 0]),
-                          order(psrfmatch[psrfmatch != 0])]
-  vcorr <- vcorr[ptmatch, ptmatch]
+  lmatch <- match(lavpartable$pxnames[lavpartable$free > 0],
+                  rownames(rjob$crosscorr))
+  vcorr <- rjob$crosscorr[lmatch, lmatch]
+  smatch <- match(lavpartable$pxnames[lavpartable$free > 0],
+                  rownames(rjob$summary$statistics),
+                  nomatch=0)
+  sdvec <- rjob$summary$statistics[smatch, ""SD""]
 
   list(x = lavpartable$est[lavpartable$free > 0],
        lavpartable = lavpartable,
        vcorr = vcorr,
-       sd = rjob$summary$statistics[
-         lavpartable$jagpnum[lavpartable$free > 0],""SD""])
+       sd = sdvec)
 }"
ecmerkle,blavaan,ac5a83b55e21158dedce903c502bb00ebd5dad36,ecmerkle,merklee@missouri.edu,2016-08-07T19:45:13Z,ecmerkle,merklee@missouri.edu,2016-08-07T19:45:13Z,fix bug in fa covariances + progress towards multigroup,R/set_partable.R;R/set_priors.R,False,True,True,False,46,35,81,"---FILE: R/set_partable.R---
@@ -410,14 +410,19 @@ set_phanvars <- function(partable, ov.names, lv.names, ov.cp, lv.cp, ngroups){
                     eqconst <- paste(partable$mat[vvar], ""star["", partable$row[vvar],
                                      "","", partable$col[vvar], "","", k, ""]"", sep="""")
                     for(j in 1:length(phanlvs)){
-                        phanvar <- which(partable$lhs == partable$lhs[phanlvs[j]] &
+                        if(vnames[i] %in% ov.names){
+                          phname <- partable$lhs[phanlvs[j]]
+                        } else {
+                          phname <- partable$rhs[phanlvs[j]]
+                        }
+                        phanvar <- which(partable$lhs == phname &
                                      partable$lhs == partable$rhs &
                                      partable$op == ""~~"" &
                                      partable$group == k)
                         eqconst <- paste(eqconst, "" + ("", partable$mat[phanlvs[j]], ""["",
                                          partable$row[phanlvs[j]], "","",
                                          partable$col[phanlvs[j]], "","", k, ""]^2*"",
-                                         partable$mat[phanvar], ""star["",
+                                         partable$mat[phanvar], ""["",
                                          partable$row[phanvar], "","", partable$col[phanvar],
                                          "","", k, ""])"", sep="""")
                     }

---FILE: R/set_priors.R---
@@ -99,42 +99,48 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x){
     if(length(covs) > 0){
         TXT2 <- paste(TXT2, ""\n\n"", t1, ""# Inferential covariances"", sep="""")
         for(i in 1:length(covs)){
-            varlocs <- which(partable$lhs == covs[i] &
-                             partable$op == ""=~"")
-            vartxt <- ""star""
-            vars <- partable$rhs[varlocs]
-            if(length(varlocs) == 0){
-              ## lv
-              varlocs <- which(partable$rhs == covs[i] &
-                               partable$op == ""~"")
-              vars <- partable$lhs[varlocs]
-            }
+            for(k in 1:max(partable$group)){
+                varlocs <- which(partable$lhs == covs[i] &
+                                 partable$op == ""=~"" &
+                                 partable$group == k)
+                vartxt <- ""star""
+                vars <- partable$rhs[varlocs]
+                if(length(varlocs) == 0){
+                    ## lv
+                    varlocs <- which(partable$rhs == covs[i] &
+                                     partable$op == ""~"" &
+                                     partable$group == k)
+                    vars <- partable$lhs[varlocs]
+                }
 
-            var1 <- which(partable$lhs == vars[1] &
-                          partable$lhs == partable$rhs &
-                          partable$group == partable$group[varlocs[1]] &
-                          grepl(vartxt, partable$mat))
-            var2 <- which(partable$lhs == vars[2] &
-                          partable$lhs == partable$rhs &
-                          partable$group == partable$group[varlocs[1]] &
-                          grepl(vartxt, partable$mat))
+                var1 <- which(partable$lhs == vars[1] &
+                              partable$lhs == partable$rhs &
+                              partable$group == partable$group[varlocs[1]] &
+                              grepl(vartxt, partable$mat))
+                var2 <- which(partable$lhs == vars[2] &
+                              partable$lhs == partable$rhs &
+                              partable$group == partable$group[varlocs[1]] &
+                              grepl(vartxt, partable$mat))
 
-            matname <- ifelse(grepl(""theta"", partable$mat[var1]), ""theta"", ""psi"")
-            phpars <- which(partable$lhs == covs[i])
-            if(length(phpars) == 1){
-              phpars <- which(partable$rhs == covs[i])
-            }
+                matname <- ifelse(grepl(""theta"", partable$mat[var1]), ""theta"", ""psi"")
+                phpars <- which(partable$lhs == covs[i] &
+                                partable$group == k)
+                if(length(phpars) == 1){
+                    phpars <- which(partable$rhs == covs[i] &
+                                    partable$group == k)
+                }
 
-            ## covariances
-            TXT2 <- paste(TXT2, ""\n"", t1, matname, ""["", partable$row[var1],
-                          "","", partable$row[var2], "","", partable$group[varlocs[1]], ""] <- "",
-                          partable$mat[phpars[1]], ""["", partable$row[phpars[1]], "","",
-                          partable$col[phpars[1]], "","", partable$group[phpars[1]], ""]*"",
-                          partable$mat[phpars[2]], ""["", partable$row[phpars[2]], "","",
-                          partable$col[phpars[2]], "","", partable$group[phpars[2]], ""]*"",
-                          partable$mat[phpars[3]], ""["", partable$row[phpars[3]], "","",
-                          partable$col[phpars[3]], "","", partable$group[phpars[3]], ""]"",
-                          sep="""")
+                ## covariances
+                TXT2 <- paste(TXT2, ""\n"", t1, matname, ""["", partable$row[var1],
+                              "","", partable$row[var2], "","", partable$group[varlocs[1]], ""] <- "",
+                              partable$mat[phpars[1]], ""["", partable$row[phpars[1]], "","",
+                              partable$col[phpars[1]], "","", partable$group[phpars[1]], ""]*"",
+                              partable$mat[phpars[2]], ""["", partable$row[phpars[2]], "","",
+                              partable$col[phpars[2]], "","", partable$group[phpars[2]], ""]*"",
+                              partable$mat[phpars[3]], ""["", partable$row[phpars[3]], "","",
+                              partable$col[phpars[3]], "","", partable$group[phpars[3]], ""]"",
+                              sep="""")
+            }
 
         }
     }"
ecmerkle,blavaan,37736e0eae145df31ea4eb9024cd427a021da26b,ecmerkle,merklee@missouri.edu,2016-08-06T02:36:18Z,ecmerkle,merklee@missouri.edu,2016-08-06T02:36:18Z,fix bug in px approach to lvs,R/lav_export_jags.R;R/set_partable.R;R/set_priors.R,False,True,True,False,22,10,32,"---FILE: R/lav_export_jags.R---
@@ -320,10 +320,12 @@ lav2jags <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
         psi.free.idx <- which(partable$group == 1 &
                               partable$op == ""~~"" &
                               partable$lhs == partable$rhs &
-                              partable$lhs == lv.names[j])
+                              partable$lhs == lv.names[j] &
+                              !grepl(""star"", partable$mat))
 
         if(length(psi.free.idx) != 1L) {
-          stop(""lavaan ERROR: parameter for residual variance "",
+          browser()
+          stop(""blavaan ERROR: parameter for residual variance "",
                lv.names[j], "" not found"")
         }
 
@@ -336,10 +338,10 @@ lav2jags <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
             ## now change ustart to 1000 so no divide by 0 in jags
             partable$ustart[lv.var] <- 1000
         } else {
-            lvcovs <- length(which(partable$lhs != partable$rhs &
-                                   partable$op == ""~~"" &
-                                   (partable$lhs == lv.names[j] |
-                                    partable$rhs == lv.names[j])))
+            lvcovs <- length(which(partable$lhs == lv.names[j] &
+                                   grepl("".phant"", partable$rhs) &
+                                   partable$op == ""~""))
+
             pvname <- ifelse(lvcovs > 0, ""psistar"", ""psi"")
             
             TXT <- paste(TXT, ""\n"", t2,

---FILE: R/set_partable.R---
@@ -417,7 +417,7 @@ set_phanvars <- function(partable, ov.names, lv.names, ov.cp, lv.cp, ngroups){
                         eqconst <- paste(eqconst, "" + ("", partable$mat[phanlvs[j]], ""["",
                                          partable$row[phanlvs[j]], "","",
                                          partable$col[phanlvs[j]], "","", k, ""]^2*"",
-                                         partable$mat[phanvar], ""["",
+                                         partable$mat[phanvar], ""star["",
                                          partable$row[phanvar], "","", partable$col[phanvar],
                                          "","", k, ""])"", sep="""")
                     }

---FILE: R/set_priors.R---
@@ -98,22 +98,32 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x){
     
     if(length(covs) > 0){
         TXT2 <- paste(TXT2, ""\n\n"", t1, ""# Inferential covariances"", sep="""")
-
         for(i in 1:length(covs)){
             varlocs <- which(partable$lhs == covs[i] &
                              partable$op == ""=~"")
+            vartxt <- ""star""
             vars <- partable$rhs[varlocs]
+            if(length(varlocs) == 0){
+              ## lv
+              varlocs <- which(partable$rhs == covs[i] &
+                               partable$op == ""~"")
+              vars <- partable$lhs[varlocs]
+            }
+
             var1 <- which(partable$lhs == vars[1] &
                           partable$lhs == partable$rhs &
                           partable$group == partable$group[varlocs[1]] &
-                          grepl(""star"", partable$mat))
+                          grepl(vartxt, partable$mat))
             var2 <- which(partable$lhs == vars[2] &
                           partable$lhs == partable$rhs &
                           partable$group == partable$group[varlocs[1]] &
-                          grepl(""star"", partable$mat))
+                          grepl(vartxt, partable$mat))
 
             matname <- ifelse(grepl(""theta"", partable$mat[var1]), ""theta"", ""psi"")
             phpars <- which(partable$lhs == covs[i])
+            if(length(phpars) == 1){
+              phpars <- which(partable$rhs == covs[i])
+            }
 
             ## covariances
             TXT2 <- paste(TXT2, ""\n"", t1, matname, ""["", partable$row[var1],"
ecmerkle,blavaan,d5a11a12bb4757c1cf84ae841006273694dd26a7,ecmerkle,merklee@missouri.edu,2016-08-05T20:43:53Z,ecmerkle,merklee@missouri.edu,2016-08-05T20:43:53Z,fix covariances constrained to 0 and fixed x error,R/blavaan.R;R/lav_export_jags.R;R/set_partable.R;R/set_priors.R,False,True,True,False,33,21,54,"---FILE: R/blavaan.R---
@@ -138,7 +138,8 @@ blavaan <- function(...,  # default lavaan arguments
         cp <- ""fa""
         cat(""blavaan NOTE: covariance priors can no longer be set separately for ov and lv.\n Using 'fa' approach for all covariances.\n"")
     }
-    
+
+    prispec <- ""prior"" %in% names(LAV@ParTable)
     # block priors off for now
     LAV@Options$auto.cov.lv.x <- FALSE
     ## # cannot currently use wishart prior with std.lv=TRUE
@@ -152,7 +153,6 @@ blavaan <- function(...,  # default lavaan arguments
     ## ## catch some regressions without fixed x:
     ## ov.noy <- LAV@pta$vnames$ov.nox[[1]]
     ## ov.noy <- ov.noy[!(ov.noy %in% LAV@pta$vnames$ov.y)]
-    ## prispec <- ""prior"" %in% names(LAV@ParTable)
     ## ndpriors <- rep(FALSE, length(LAV@ParTable$lhs))
     ## if(prispec) ndpriors <- LAV@ParTable$prior != """"
     ## cov.pars <- (LAV@ParTable$lhs %in% c(lv.x, ov.noy)) & LAV@ParTable$op == ""~~""

---FILE: R/lav_export_jags.R---
@@ -120,7 +120,6 @@ lav2jags <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
     ov.names <- orig.ov.names[orig.ov.names %in% ov.names.nox]
     #ov.names <- ov.names.nox
   }
-
   eqlabs <- partable$rhs[partable$op == ""==""]
 
   ## TODO add thresholds here
@@ -169,10 +168,19 @@ lav2jags <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
       for(j in 1:nmvs){
         ## decide whether we need px on ovs/lvs by searching
         ## for covariances:
+        mvvar <- which(partable$op == ""~~"" &
+                       partable$lhs == ov.names[j] &
+                       partable$lhs == partable$rhs &
+                       !(grepl(""star"", partable$mat)) &
+                       partable$group == 1)
+        tvname <- partable$mat[mvvar]
         mvcovs <- length(which(grepl("".phant"", partable$lhs) &
                                partable$op == ""=~"" &
                                partable$rhs == ov.names[j]))
-        tvname <- ifelse(mvcovs > 0, ""thetastar"", ""theta"")
+
+        if(mvcovs > 0){
+          tvname <- paste(tvname, ""star"", sep="""")
+        }
           
         TXT <- paste(TXT, t2, ov.names[j], 
                      ""[i] ~ dnorm(mu[i,"", j, ""], 1/"", tvname, ""["", j, "","", j, "",g[i]])\n"",
@@ -324,7 +332,7 @@ lav2jags <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
                         partable$op == ""~~"")
         if(any(partable$free[lv.var] == 0 & partable$ustart[lv.var] == 0)){
             TXT <- paste(TXT, ""\n"", t2, ""eta[i,"", j, ""] <- mu.eta[i,"",
-                         partable$row[psi.free.idx], ""]"", sep="""")
+                         j, ""]"", sep="""")
             ## now change ustart to 1000 so no divide by 0 in jags
             partable$ustart[lv.var] <- 1000
         } else {
@@ -337,7 +345,7 @@ lav2jags <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
             TXT <- paste(TXT, ""\n"", t2,
                          ## TODO check for alternative distribution?
                          ""eta[i,"", j, ""] ~ dnorm(mu.eta[i,"", 
-                         partable$row[psi.free.idx], ""], 1/"", pvname, ""["",
+                         j, ""], 1/"", pvname, ""["",
                          partable$row[psi.free.idx], "","", partable$col[psi.free.idx],
                          "",g[i]])"", sep="""")
         }
@@ -521,11 +529,11 @@ lav2jags <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
     if(cp == ""fa""){
         if(nrow(facovs) > 0){
             for(i in 1:nrow(facovs)){
-                wmat <- match(""theta"", names(pmats))
+                wmat <- match(facovs$mat[i], names(pmats))
 
                 pmats[[wmat]][facovs$row[i], facovs$col[i], facovs$group[i]] <- NA
 
-                monitors <- c(monitors, paste(""theta["", facovs$row[i], "","",
+                monitors <- c(monitors, paste(facovs$mat[i], ""["", facovs$row[i], "","",
                                               facovs$col[i], "","",
                                               facovs$group[i], ""]"", sep=""""))
             }
@@ -611,8 +619,8 @@ coeffun <- function(lavpartable, pxpartable, rjob, fun = ""mean"") {
 
   ## NB this automatically removes fixed parameters, just
   ##    like the psrf
-  vcorr <- rjob$crosscorr[psrfmatch[psrfmatch != 0],
-                          psrfmatch[psrfmatch != 0]]
+  vcorr <- rjob$crosscorr[order(psrfmatch[psrfmatch != 0]),
+                          order(psrfmatch[psrfmatch != 0])]
   vcorr <- vcorr[ptmatch, ptmatch]
 
   list(x = lavpartable$est[lavpartable$free > 0],

---FILE: R/set_partable.R---
@@ -141,11 +141,11 @@ nlvcovs)
                          partable$rhs == partable$lhs[covpars[i]] &
                          partable$group == k &
                          partable$op == ""~~"")
-          tmpv1 <- paste(""theta["", partable$row[v1var], "","", partable$col[v1var], "","", k,
+          tmpv1 <- paste(partable$mat[v1var], ""["", partable$row[v1var], "","", partable$col[v1var], "","", k,
                          ""]"", sep="""")
           if(eq.const){
             oldr <- match(partable$lhs[full.idx], patts$mmDimNames[[k]]$lambda[[1]])
-            oldv1 <- paste(""theta["", oldr , "","", oldr, "","", grp.idx, ""]"", sep="""")
+            oldv1 <- paste(partable$mat[v1var], ""["", oldr , "","", oldr, "","", grp.idx, ""]"", sep="""")
           }
           ctype <- ""ov""
         } else {
@@ -178,10 +178,10 @@ nlvcovs)
                          partable$rhs == partable$rhs[covpars[i]] &
                          partable$group == k &
                          partable$op == ""~~"")
-          tmpv2 <- paste(""theta["", partable$row[v2var], "","", partable$col[v2var], "","", k, ""]"", sep="""")
+          tmpv2 <- paste(partable$mat[v2var], ""["", partable$row[v2var], "","", partable$col[v2var], "","", k, ""]"", sep="""")
           if(eq.const){
             oldr <- match(partable$rhs[full.idx], patts$mmDimNames[[k]]$lambda[[1]])
-            oldv2 <- paste(""theta["", oldr, "","", oldr, "","", grp.idx, ""]"", sep="""")
+            oldv2 <- paste(partable$mat[v2var], ""["", oldr, "","", oldr, "","", grp.idx, ""]"", sep="""")
           }
         } else {
           partable$lhs[tmprows[2]] <- partable$rhs[covpars[i]]

---FILE: R/set_priors.R---
@@ -20,6 +20,17 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x){
             TXT3 <- paste(TXT3, ""\n"", t1, ""parvec["",
                           partable$parnums[i], ""]"", sep="""")
 
+            ## correlation parameter under srs
+            if(grepl(""rho"", partable$id[i])){
+                rhoinf <- strsplit(partable$id[i], ""[, \\[^\\]]+"", perl=TRUE)
+                partable$mat[i] <- rhoinf[[1]][1]
+                partable$row[i] <- rhoinf[[1]][2]
+                partable$col[i] <- rhoinf[[1]][3]
+                if(partable$free[i] == 0){
+                    partable$ustart[i] <- (as.numeric(partable$ustart[i]) + 1)/2
+                }
+            }
+          
             if(partable$free[i] == 0){
                 TXT3 <- paste(TXT3, "" <- "", partable$ustart[i],
                               sep="""")
@@ -46,13 +57,6 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x){
                 TXT3 <- paste(TXT3, "" <- "", jageq, sep="""")
             } else {
                 ## needs a prior
-                ## correlation parameter under srs
-                if(grepl(""rho"", partable$id[i])){
-                    rhoinf <- strsplit(partable$id[i], ""[, \\[^\\]]+"", perl=TRUE)
-                    partable$mat[i] <- rhoinf[[1]][1]
-                    partable$row[i] <- rhoinf[[1]][2]
-                    partable$col[i] <- rhoinf[[1]][3]
-                }
                 if(partable$prior[i] == """"){
                     if(grepl(""star"", partable$mat[i])){
                         pname <- paste(""i"", strsplit(partable$mat[i], ""star"")[[1]][1], sep="""")"
ecmerkle,blavaan,c186eaccc5d9f6b746efe57d859fde32ae8e0aaa,ecmerkle,merklee@missouri.edu,2016-08-03T18:00:13Z,ecmerkle,merklee@missouri.edu,2016-08-03T18:00:13Z,fix bug in fa covariances,R/lav_export_jags.R,False,True,True,False,3,4,7,"---FILE: R/lav_export_jags.R---
@@ -170,10 +170,9 @@ lav2jags <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
       for(j in 1:nmvs){
         ## decide whether we need px on ovs/lvs by searching
         ## for covariances:
-        mvcovs <- length(which(partable$lhs != partable$rhs &
-                               partable$op == ""~~"" &
-                               (partable$lhs == ov.names[j] |
-                                partable$rhs == ov.names[j])))
+        mvcovs <- length(which(grepl("".phant"", partable$lhs) &
+                               partable$op == ""=~"" &
+                               partable$rhs == ov.names[j]))
         tvname <- ifelse(mvcovs > 0, ""thetastar"", ""theta"")
           
         TXT <- paste(TXT, t2, ov.names[j], "
ecmerkle,blavaan,9510874a5abbb2d3789d9486fa3e766987863b98,ecmerkle,merklee@missouri.edu,2016-08-01T20:22:46Z,ecmerkle,merklee@missouri.edu,2016-08-01T20:22:46Z,parvec approach runs for pdem; suspect bug in fa priors,R/blavaan.R;R/lav_export_jags.R;R/set_priors.R,False,True,True,False,78,26,104,"---FILE: R/blavaan.R---
@@ -262,7 +262,7 @@ blavaan <- function(...,  # default lavaan arguments
             lavpartable <- mergejag(lavpartable, jagtrans$coefvec)
 
             ## add extras to monitor, if specified
-            sampparms <- jagtrans$coefvec[,1]
+            sampparms <- jagtrans$monitors
             if(""monitor"" %in% names(jagextra)){
                 sampparms <- c(sampparms, jagextra$monitor)
             }
@@ -315,6 +315,8 @@ blavaan <- function(...,  # default lavaan arguments
             print(jagtrans)
             stop(""blavaan ERROR: problem with translation from lavaan to jags."")
         }
+browser()
+        ## NEXT: fix up summaries
         parests <- coeffun(lavpartable, res)
         x <- parests$x
 

---FILE: R/lav_export_jags.R---
@@ -29,19 +29,6 @@ lav2jags <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
     dp[[""ibpsi""]] <- paste(""dwish(iden,"", length(orig.lv.names.x) + 1, "")"", sep="""")
   }
 
-  ## decide whether we need px on ovs/lvs by searching
-  ## for covariances:
-  mvcovs <- length(which(partable$lhs != partable$rhs &
-                         partable$op == ""~~"" &
-                         (partable$lhs %in% orig.ov.names |
-                          partable$rhs %in% orig.ov.names)))
-  tvname <- ifelse(mvcovs > 0, ""thetastar"", ""theta"")
-  lvcovs <- length(which(partable$lhs != partable$rhs &
-                         partable$op == ""~~"" &
-                         (partable$lhs %in% orig.lv.names |
-                          partable$rhs %in% orig.lv.names)))
-  pvname <- ifelse(lvcovs > 0, ""psistar"", ""psi"")
-
   ## set up mvs with fixed 0 variances (single indicators of lvs)
   partable <- set_mv0(partable, orig.ov.names, ngroups)
   ## add necessary phantom lvs/mvs to model:
@@ -181,13 +168,21 @@ lav2jags <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
   if(length(ov.ord) == 0){
     if(blavmis == ""da""){
       for(j in 1:nmvs){
+        ## decide whether we need px on ovs/lvs by searching
+        ## for covariances:
+        mvcovs <- length(which(partable$lhs != partable$rhs &
+                               partable$op == ""~~"" &
+                               (partable$lhs == ov.names[j] |
+                                partable$rhs == ov.names[j])))
+        tvname <- ifelse(mvcovs > 0, ""thetastar"", ""theta"")
+          
         TXT <- paste(TXT, t2, ov.names[j], 
-                     ""[i] ~ dnorm(mu[i,"", j, ""], 1/"", tvname, ""["", j, "",g[i]])\n"",
+                     ""[i] ~ dnorm(mu[i,"", j, ""], 1/"", tvname, ""["", j, "","", j, "",g[i]])\n"",
                      sep="""")
       }
     } else {
       TXT <- paste(TXT, t2, ""yvec[i] ~ dnorm(mu[sub[i], mv[i]], 1/"",
-                   tvname, ""[mv[i], g[i]])\n"", sep="""")
+                   tvname, ""[mv[i], mv[i], g[i]])\n"", sep="""")
       # now close this loop and start the usual one
       TXT <- paste(TXT, t1, ""}\n\n"", sep="""")
       TXT <- paste(TXT, t1, ""for(i in 1:N) {\n"", sep="""")
@@ -335,12 +330,18 @@ lav2jags <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
             ## now change ustart to 1000 so no divide by 0 in jags
             partable$ustart[lv.var] <- 1000
         } else {
-              TXT <- paste(TXT, ""\n"", t2,
-                           ## TODO check for alternative distribution?
-                           ""eta[i,"", j, ""] ~ dnorm(mu.eta[i,"", 
-                           partable$row[psi.free.idx], ""], 1/"", pvname, ""["",
-                           partable$row[psi.free.idx], "","", partable$col[psi.free.idx],
-                           "",g[i]])"", sep="""")
+            lvcovs <- length(which(partable$lhs != partable$rhs &
+                                   partable$op == ""~~"" &
+                                   (partable$lhs == lv.names[j] |
+                                    partable$rhs == lv.names[j])))
+            pvname <- ifelse(lvcovs > 0, ""psistar"", ""psi"")
+            
+            TXT <- paste(TXT, ""\n"", t2,
+                         ## TODO check for alternative distribution?
+                         ""eta[i,"", j, ""] ~ dnorm(mu.eta[i,"", 
+                         partable$row[psi.free.idx], ""], 1/"", pvname, ""["",
+                         partable$row[psi.free.idx], "","", partable$col[psi.free.idx],
+                         "",g[i]])"", sep="""")
         }
       } # j
     } # if
@@ -424,13 +425,13 @@ lav2jags <- function(model, lavdata = NULL, cp = ""srs"", lv.x.wish = FALSE, dp =
     TXT <- paste(TXT, ""\n"", jagextra, ""\n"", sep="""")
   }
   TXT <- paste(TXT, ""\n"", ""} # End of model\n"", sep="""")
-browser()
+
   out <- TXT
   class(out) <- c(""lavaan.character"", ""character"")
   out <- list(model = out, inits = NA)
     
   ## Initial values
-  if(inits != ""jags""){
+  if(FALSE){ ## FIXME! inits != ""jags""){
       inits <- set_inits(partable, priorres$coefvec, matdims, cp, cp, n.chains, inits)
       out$inits <- inits
   }
@@ -492,6 +493,52 @@ browser()
       jagsdata$N <- max(ydf$sub)
     }
 
+    ## parameter matrices/vectors
+    matrows <- with(subset(partable, mat != """"), tapply(row, mat, max, na.rm=TRUE))
+    matcols <- with(subset(partable, mat != """"), tapply(col, mat, max, na.rm=TRUE))
+    ngrp <- max(partable$group, na.rm=TRUE)
+
+    pmats <- vector(""list"", length(matrows))
+    for(i in 1:length(pmats)){
+        pmats[[i]] <- array(0, c(matrows[i], matcols[i], ngrp))
+    }
+    names(pmats) <- names(matrows)
+
+    ## replace parameter entries with NA
+    for(i in 1:nrow(partable)){
+        if(partable$mat[i] == """") next
+
+        wmat <- match(partable$mat[i], names(pmats))
+        pmats[[wmat]][partable$row[i], partable$col[i], partable$group[i]] <- NA
+    }
+
+    ## monitored parameters
+    monitors <- with(subset(partable, mat != """"),
+                     paste(mat, ""["", row, "","", col, "","", group, ""]"",
+                           sep=""""))
+    
+    ## inferential covariances under fa priors
+    if(cp == ""fa""){
+        facovs <- unique(partable$lhs[grep("".phant"", partable$lhs)])
+        if(length(facovs) > 0){
+            for(i in 1:length(facovs)){
+                crows <- which((partable$lhs == facovs[i] | partable$rhs == facovs[i]) &
+                               partable$op %in% c(""=~"", ""~""))
+
+                wmat <- match(""theta"", names(pmats))
+
+                pmats[[wmat]][partable$row[crows[1]], partable$row[crows[2]],
+                              partable$group[crows[1]]] <- NA
+
+                monitors <- c(monitors, paste(""theta["", partable$row[crows[1]], "","",
+                                              partable$row[crows[2]], "","",
+                                              partable$group[crows[1]], ""]"", sep=""""))
+            }
+        }
+    }
+
+    jagsdata <- c(jagsdata, pmats)
+    
     ## identity matrix for wishart prior
     ## TODO allow user to specify this matrix
     if(lv.x.wish & length(orig.lv.names.x) > 1){
@@ -501,7 +548,9 @@ browser()
     
     out <- c(out, list(data=jagsdata))
   }
-  
+
+  out <- c(out, list(monitors = monitors))
+    
   out
 }
 

---FILE: R/set_priors.R---
@@ -658,9 +658,10 @@ set_parvec <- function(TXT2, partable, dp, cp, lv.x.wish, lv.names.x){
                     if(length(partype) > 1) partype <- partype[1] # due to psi and ibpsi
                     partable$prior[i] <- dp[partype]
                 }
+
                 vpri <- grepl(""\\[var\\]"", partable$prior[i])
                 spri <- grepl(""\\[sd\\]"", partable$prior[i])
-                if(!vpri){
+                if(!vpri & (grepl(""theta"", partable$mat[i]) | grepl(""psi"", partable$mat[i]))){
                     sq <- ifelse(spri, ""2"", ""-1"")
                     TXT3 <- paste(TXT3, "" <- pow(pvec"", partable$parnums[i], "","", sq,
                                   "")\n"", sep="""")"
ecmerkle,blavaan,94016dfdeb2cbf51adc9688bf9d08c6ab1e28475,ecmerkle,merklee@missouri.edu,2016-07-29T20:53:32Z,ecmerkle,merklee@missouri.edu,2016-07-29T20:53:32Z,"modify lav_export for parvec approach, bug fixes",R/blavaan.R;R/lav_export_jags.R;R/set_priors.R,False,True,True,False,87,88,175,"---FILE: R/blavaan.R---
@@ -307,7 +307,7 @@ blavaan <- function(...,  # default lavaan arguments
                 stop(""blavaan ERROR: problem with jags estimation.  The jags model and data have been exported."")
             }
         } else {
-            #print(jagtrans)
+            print(jagtrans)
             stop(""blavaan ERROR: problem with translation from lavaan to jags."")
         }
         parests <- coeffun(lavpartable, res)

---FILE: R/lav_export_jags.R---
@@ -104,7 +104,7 @@ lav2jags <- function(model, lavdata = NULL, ov.cp = ""srs"", lv.cp = ""srs"", lv.x.w
   }
 
   ## Second object for priors/constraints
-  TXT2 <- ""\n""
+  TXT2 <- """"
   ## Matrix that keeps track of parameter ordering, priors,
   ## and starting values
   coefvec <- matrix(NA, nparam, 3)
@@ -299,7 +299,6 @@ lav2jags <- function(model, lavdata = NULL, ov.cp = ""srs"", lv.cp = ""srs"", lv.x.w
   if(length(lv.names) > 0L) {
     TXT <- paste(TXT, ""\n\n"", t2,
                  ""# lvs"", sep="""")
-    TXT2 <- paste(TXT2, ""\n"", sep="""")
 
     lvstart <- 1
     ## if(lv.x.wish & nlvx > 1){
@@ -331,15 +330,15 @@ lav2jags <- function(model, lavdata = NULL, ov.cp = ""srs"", lv.cp = ""srs"", lv.x.w
                         partable$rhs == lv.names[j] &
                         partable$op == ""~~"")
         if(any(partable$free[lv.var] == 0 & partable$ustart[lv.var] == 0)){
-            TXT <- paste(TXT, ""\n"", t2,
-                         ""eta[i,"", j, ""] <- mu.eta[i,"", psi.free.idx, ""]"", sep="""")
+            TXT <- paste(TXT, ""\n"", t2, ""eta[i,"", j, ""] <- mu.eta[i,"",
+                         partable$row[psi.free.idx], ""]"", sep="""")
             ## now change ustart to 1000 so no divide by 0 in jags
             partable$ustart[lv.var] <- 1000
         } else {
               TXT <- paste(TXT, ""\n"", t2,
                            ## TODO check for alternative distribution?
                            ""eta[i,"", j, ""] ~ dnorm(mu.eta[i,"", 
-                           psi.free.idx, ""], 1/"", pvname, ""["",
+                           partable$row[psi.free.idx], ""], 1/"", pvname, ""["",
                            partable$row[psi.free.idx], "","", partable$col[psi.free.idx],
                            "",g[i]])"", sep="""")
         }
@@ -360,8 +359,8 @@ lav2jags <- function(model, lavdata = NULL, ov.cp = ""srs"", lv.cp = ""srs"", lv.x.w
                        lvintercepts$lhs == lv.names[j])
       if(length(int.idx) == 1L) {
         ## fixed or free?
-        TXT <- paste(TXT, intercepts$mat[int.idx], ""["", intercepts$row[int.idx],
-                     "","", intercepts$col[int.idx], "",g[i]]"", sep="""")
+        TXT <- paste(TXT, lvintercepts$mat[int.idx], ""["", lvintercepts$row[int.idx],
+                     "","", lvintercepts$col[int.idx], "",g[i]]"", sep="""")
       } else { # no intercept, say '0', so we always have rhs
         TXT <- paste(TXT, ""0"", sep="""")
       }
@@ -402,76 +401,21 @@ lav2jags <- function(model, lavdata = NULL, ov.cp = ""srs"", lv.cp = ""srs"", lv.x.w
 
       ## 4. lv variances now handled separately
     } # end j loop
-    if(any(lv.names %in% lv.nox)) TXT2 <- paste(TXT2, ""\n"", sep="""")
   } # end if length(lv.names)
-  
-  ## end of main model specification (still need priors + equality constraints)
-  TXT <- paste(TXT, ""\n"", t1,
-               ""}"", sep="""")
 
-  ## TODO 28Jul2016 modify here and below these for use with new parvecs
-  ## now get priors for residual variance parameters of non-exo mvs and lvs
-  priorres <- set_priors(priorres, partable, 1, c(ov.names, lv.names), ngroups,
-                         type=""vars"", dp=dp, blk=TRUE, nov=nmvs, lv.names.x=orig.lv.names.x, ov.cp=ov.cp, lv.cp=lv.cp, lv.x.wish=lv.x.wish, mvcovs=mvcovs)
-  ## and for correlation parameters
-  priorres <- set_priors(priorres, partable, 1, c(ov.names, lv.names), ngroups,
-                         type=""covs"", dp=dp, blk=TRUE, nov=nmvs, lv.names.x=orig.lv.names.x, ov.cp=ov.cp, lv.cp=lv.cp, lv.x.wish=lv.x.wish)
+  ## end of main model specification (still need priors + equality constraints)
+  TXT <- paste(TXT, ""\n"", t1, ""}"", sep="""")
 
   ## and for blocked multivariate normal parameters, now that
   ## priorres$coefvec should have all the jags labels
   ##if(any(!is.na(partable$blk))) priorres <- block_priors(priorres, partable)
-    
-  ## covariances resulting from phantoms go in TXT3
-  TXT3 <- paste(TXT3, ""\n"", sep="""")
-  covtable <- partable[which(partable$op == ""~~"" &
-                             partable$lhs %in% phnames &
-                             partable$group == 1),]
-  if(nrow(covtable) > 0){
-    for(j in 1:nrow(covtable)){
-      phname <- covtable$lhs[j]
-      tmp.ind <- match(phname, lv.names)
-      var.ind <- lv.ind[which(lv.ind[,1]==tmp.ind),2]
-      for(k in 1:ngroups){
-        TXT3 <- paste(TXT3, t1, ""cov["", j, "","", k, ""] <- "",
-                      ""psi["", var.ind, "","", k, ""]"", sep="""")
-      
-        tmp.ov <- partable$rhs[partable$lhs == phname &
-                               partable$op == ""=~"" &
-                               partable$group == k]
-        ## find parameters from loadings, multiply by
-        ## 1/invtheta
-        if(length(tmp.ov) > 0L){
-          for(p in 1:length(tmp.ov)){
-            lam.idx <- which(loadings$op == ""=~"" &
-                             loadings$lhs == phname &
-                             loadings$rhs == tmp.ov[p] &
-                             loadings$group == 1)
-            TXT3 <- paste(TXT3, ""*lambda["", lam.idx, "","", k, ""]"", sep="""")
-          }
-        }
-      
-        tmp.lv <- partable$lhs[partable$rhs == phname &
-                               partable$op == ""~"" &
-                               partable$group == k]
-        ## find parameters from regressions, multiply by
-        ## 1/invpsi
-        if(length(tmp.lv) > 0L){
-          for(p in 1:length(tmp.lv)){
-            bet.idx <- which(regressions$op == ""~"" &
-                             regressions$lhs == tmp.lv[p] &
-                             regressions$rhs == phname &
-                             regressions$group == 1)
-            TXT3 <- paste(TXT3, ""*beta["", bet.idx, "","", k, ""]"", sep="""")
-          }
-        }
-        TXT3 <- paste(TXT3, ""\n"", sep="""")
-      } # end k
-    } # end j
-  } # end if
+
+  ## priors/constraints
+  TXT2 <- set_parvec(TXT2, partable, dp, lv.x.wish, lv.names.x)
 
   ## end of model
-  TXT <- paste(TXT, ""\n\n"", t1, ""# Priors/constraints"", priorres$TXT2, sep="""")
-  TXT <- paste(TXT, TXT3, sep="""")
+  TXT <- paste(TXT, ""\n\n"", t1, ""# Assignments from parameter vector"", TXT2, sep="""")
+
   ## extra stuff from the user, formatted to look nice-ish
   if(""syntax"" %in% names(jagextra)){
     jagextra <- unlist(strsplit(jagextra$syntax, ""\n""))
@@ -483,7 +427,7 @@ lav2jags <- function(model, lavdata = NULL, ov.cp = ""srs"", lv.cp = ""srs"", lv.x.w
 
   out <- TXT
   class(out) <- c(""lavaan.character"", ""character"")
-
+browser()
   priorres$coefvec <- data.frame(priorres$coefvec, stringsAsFactors = FALSE)
   names(priorres$coefvec) <- c(""jlabel"", ""plabel"", ""prior"")
   out <- list(model = out, coefvec = priorres$coefvec, inits = NA)

---FILE: R/set_priors.R---
@@ -598,7 +598,9 @@ set_parvec <- function(TXT2, partable, dp, lv.x.wish, lv.names.x){
     t1 <- paste(rep("" "", 2L), collapse="""")
     t2 <- paste(rep("" "", 4L), collapse="""")
     t3 <- paste(rep("" "", 6L), collapse="""")
-  
+
+    ## parameter assignments separate from priors
+    TXT3 <- paste(""\n\n"", t1, ""# Priors/constraints"", sep="""")
     for(i in 1:nrow(partable)){
         if(partable$mat[i] != """"){
             ## to find equality constraints
@@ -610,15 +612,15 @@ set_parvec <- function(TXT2, partable, dp, lv.x.wish, lv.names.x){
             ##      put entries of parvec in matrix for dwish?
             ## TODO check for inequality constraints here?
 
-            TXT2 <- paste(TXT2, ""\n"", t1, ""parvec["",
+            TXT3 <- paste(TXT3, ""\n"", t1, ""parvec["",
                           partable$parnums[i], ""]"", sep="""")
 
             if(partable$free[i] == 0){
-                TXT2 <- paste(TXT2, "" <- "", partable$ustart[i],
+                TXT3 <- paste(TXT3, "" <- "", partable$ustart[i],
                               sep="""")
             } else if(length(eqpar) > 0){
                 eqpar <- which(partable$plabel == partable$lhs[eqpar])
-                TXT2 <- paste(TXT2, "" <- parvec["", partable$parnums[eqpar],
+                TXT3 <- paste(TXT3, "" <- parvec["", partable$parnums[eqpar],
                               ""]"", sep="""")
             } else if(length(compeq) > 0){
                 ## constraints with one parameter label on lhs
@@ -636,7 +638,7 @@ set_parvec <- function(TXT2, partable, dp, lv.x.wish, lv.names.x){
                     jageq <- gsub(rhsvars[j], rhstrans[j], jageq)
                 }
 
-                TXT2 <- paste(TXT2, "" <- "", jageq, sep="""")
+                TXT3 <- paste(TXT3, "" <- "", jageq, sep="""")
             } else {
                 ## needs a prior
                 ## correlation parameter under srs
@@ -647,24 +649,24 @@ set_parvec <- function(TXT2, partable, dp, lv.x.wish, lv.names.x){
                     partable$col[i] <- rhoinf[[1]][3]
                 }
                 if(partable$prior[i] == """"){
-                    partype <- grep(partable$mat[i], names(dp))
+                    if(grepl(""star"", partable$mat[i])){
+                        partype <- grep(strsplit(partable$mat[i], ""star"")[[1]][1], names(dp))
+                    } else {
+                        partype <- grep(partable$mat[i], names(dp))
+                    }
                     if(length(partype) > 1) partype <- partype[1] # due to psi and ibpsi
                     partable$prior[i] <- dp[partype]
                 }
                 vpri <- grepl(""\\[var\\]"", partable$prior[i])
                 spri <- grepl(""\\[sd\\]"", partable$prior[i])
-                if(vpri | spri){
-                    txtmod <- ifelse(vpri, ""var"", ""sd"")
-                    sq <- ifelse(vpri, """", ""^2"")
-
-
-                    TXT2 <- paste(TXT2, "" <- 1/pvec"", partable$parnums[i], sq, ""\n"", sep="""")
-                    TXT2 <- paste(TXT2, t1, ""pvec"", partable$parnums[i], "" ~ "",
-                                  strsplit(partable$prior[i], ""\\["")[[1]][1], sep="""")
+                if(!vpri){
+                    sq <- ifelse(spri, ""2"", ""-1"")
+                    TXT3 <- paste(TXT3, "" <- pow(pvec"", partable$parnums[i], "","", sq,
+                                  "")\n"", sep="""")
+                    TXT3 <- paste(TXT3, t1, ""pvec"", partable$parnums[i], "" ~ "",
+                                  partable$prior[i], sep="""")
                 } else {
-                    ## also need invtheta/invthetastar/etc
-                    ## also need to convert back to inferential model
-                    TXT2 <- paste(TXT2, "" ~ "", partable$prior[i], sep="""")
+                    TXT3 <- paste(TXT3, "" ~ "", partable$prior[i], sep="""")
                 }
             }
 
@@ -676,5 +678,58 @@ set_parvec <- function(TXT2, partable, dp, lv.x.wish, lv.names.x){
         }
     }
 
+    ## add priors/constraints after model parameter declarations
+    TXT2 <- paste(TXT2, TXT3, sep="""")
+    
+    ## now define inferential covariances and priors for inferential
+    ## variances, if needed
+    ## FIXME: this does not find the covariances, need new approach
+    ##        the inferential variances are not addressed
+    mvcovs <- which(partable$mat == ""thetastar"" &
+                    partable$row != partable$col)
+
+    lvcovs <- which(partable$mat == ""psistar"" &
+                    partable$row != partable$col) # TODO revisit for block prior
+
+    if((length(mvcovs) + length(lvcovs)) > 0){
+        TXT2 <- paste(TXT2, ""\n\n"", t1, ""# Inferential covariances"", sep="""")
+
+        if(length(mvcovs) > 0){
+            for(i in 1:length(mvcovs)){
+                var1 <- which(partable$lhs == partable$lhs[mvcovs[i]] &
+                              partable$lhs == partable$rhs &
+                              partable$group == partable$group[mvcovs[i]])
+                var2 <- which(partable$lhs == partable$rhs[mvcovs[i]] &
+                              partable$lhs == partable$rhs &
+                              partable$group == partable$group[mvcovs[i]])
+                TXT2 <- paste(TXT2, ""\n"", t1, ""theta["", partable$row[mvcovs[i]],
+                              "","", partable$col[mvcovs[i]], "","",
+                              partable$group[mvcovs[i]], ""] <- "",
+                              partable$id[mvcovs[i]], ""*"", partable$mat[var1], ""["",
+                              partable$row[var1], "","", partable$col[var1], "","",
+                              partable$group[var1], ""]*"", partable$mat[var2], ""["",
+                              partable$row[var2], "","", partable$col[var2], "","",
+                              partable$group[var2], ""]"", sep="""")
+            }
+        }
+        if(length(lvcovs) > 0){
+            for(i in 1:length(lvcovs)){
+                var1 <- which(partable$lhs == partable$lhs[lvcovs[i]] &
+                              partable$lhs == partable$rhs &
+                              partable$group == partable$group[lvcovs[i]])
+                var2 <- which(partable$lhs == partable$rhs[lvcovs[i]] &
+                              partable$lhs == partable$rhs &
+                              partable$group == partable$group[lvcovs[i]])                
+                TXT2 <- paste(TXT2, ""\n"", t1, ""psi["", partable$row[lvcovs[i]],
+                              "","", partable$col[lvcovs[i]], "","",
+                              partable$group[lvcovs[i]], ""] <- "",
+                              partable$id[lvcovs[i]], ""*"", partable$mat[var1], ""["",
+                              partable$row[var1], "","", partable$col[var1], "","",
+                              partable$group[var1], ""]*"", partable$mat[var2], ""["",
+                              partable$row[var2], "","", partable$col[var2], "","",
+                              partable$group[var2], ""]"", sep="""")
+            }
+        }
+    }
     TXT2
 }"
ecmerkle,blavaan,11d7cf21af3a9f477be7ad01ae8f461c7a9f9e6c,ecmerkle,merklee@missouri.edu,2016-07-01T21:45:18Z,ecmerkle,merklee@missouri.edu,2016-07-01T21:45:18Z,fix indexing issues related to preserved variable names,DESCRIPTION;R/lav_export_jags.R;R/set_partable.R,False,True,True,False,15,12,27,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.1-5.43
+Version: 0.1-5.45
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_jags.R---
@@ -228,7 +228,7 @@ lav2jags <- function(model, lavdata = NULL, ov.cp = ""srs"", lv.cp = ""srs"", lv.x.w
   if(length(ov.ord) == 0){
     for(j in 1:nmvs){
       TXT <- paste(TXT, t2, ov.names[j], 
-                   ""[i] ~ dnorm(mu[i,"", j, ""],"", tvname, ""["", j, "",g[i]])\n"",
+                   ""[i] ~ dnorm(mu[i,"", j, ""], "", tvname, ""["", j, "",g[i]])\n"",
                    sep="""")
     }
   } else {
@@ -312,8 +312,7 @@ lav2jags <- function(model, lavdata = NULL, ov.cp = ""srs"", lv.cp = ""srs"", lv.x.w
         RHS <- paste(""eta[i,"",
                      match(rhs, lv.names), ""]"", sep="""")
       } else if(rhs %in% orig.ov.names) {
-        RHS <- paste(""y[i,"",
-                     match(rhs, orig.ov.names), ""]"", sep="""")
+        RHS <- paste(rhs, ""[i]"", sep="""")
       }
       
       ## deal with fixed later
@@ -403,7 +402,6 @@ lav2jags <- function(model, lavdata = NULL, ov.cp = ""srs"", lv.cp = ""srs"", lv.x.w
           lv.ind <- rbind(lv.ind, c(j, lv.ind[nrow(lv.ind),2] + 1))
           mu.ind <- lv.ind[nrow(lv.ind),2]
           ## TODO see whether we need invpsistar?
-          
           lv.var <- which(partable$lhs == lv.names[mu.ind] &
                           partable$rhs == lv.names[mu.ind] &
                           partable$op == ""~~"")
@@ -497,7 +495,7 @@ lav2jags <- function(model, lavdata = NULL, ov.cp = ""srs"", lv.cp = ""srs"", lv.x.w
             ## Is the rhs an lv or ov?
             lvmatch <- match(regressions$rhs[rhs.idx[p]], lv.names)
             if(is.na(lvmatch)){
-              TXT <- paste(TXT, ""*y[i,"", match(regressions$rhs[rhs.idx[p]], orig.ov.names), ""]"", sep="""")
+              TXT <- paste(TXT, ""*"", regressions$rhs[rhs.idx[p]], ""[i]"", sep="""")
             } else {
               TXT <- paste(TXT, ""*eta[i,"", lvmatch, ""]"", sep="""")
             }
@@ -638,6 +636,7 @@ lav2jags <- function(model, lavdata = NULL, ov.cp = ""srs"", lv.cp = ""srs"", lv.x.w
   if(!is.null(lavdata) | class(model)==""lavaan""){
     if(class(model) == ""lavaan"") lavdata <- model@Data
     ntot <- sum(unlist(lavdata@norig))
+    nmvs <- length(orig.ov.names)
     y <- lapply(1:nmvs, function(x) rep(NA,ntot))
     g <- rep(NA, ntot)
     for(k in 1:ngroups){
@@ -646,7 +645,7 @@ lav2jags <- function(model, lavdata = NULL, ov.cp = ""srs"", lv.cp = ""srs"", lv.x.w
         }
         g[lavdata@case.idx[[k]]] <- k
     }
-    names(y) <- ov.names
+    names(y) <- orig.ov.names
     ## remove deleted rows
     ymat <- matrix(unlist(y), ntot, nmvs)
     nas <- which(apply(is.na(ymat), 1, sum) == nmvs)

---FILE: R/set_partable.R---
@@ -145,10 +145,12 @@ nlvcovs)
           tbcs <- tbcs + 1
           partable$row[tmprows[1]] <- tbcs
           partable$col[tmprows[1]] <- match(partable$lhs[covpars[i]],
-                                            patts$mmDimNames[[k]]$psi[[1]])
-          tmpv1 <- paste(""psi["", match(partable$lhs[covpars[i]], patts$mmDimNames[[k]]$psi[[1]]), "","", k, ""]"", sep="""")
+                                            lv.names) # FIXME here and below will be patts$mmDimNames[[k]]$psi[[1]])
+          tmpv1 <- paste(""psi["", match(partable$lhs[covpars[i]], lv.names), #patts$mmDimNames[[k]]$psi[[1]]),
+                                       "","", k, ""]"", sep="""")
           if(eq.const){
-            oldv1 <- paste(""psi["", match(partable$lhs[full.idx], patts$mmDimNames[[k]]$psi[[1]]), "","", grp.idx, ""]"", sep="""")
+            oldv1 <- paste(""psi["", match(partable$lhs[full.idx], lv.names), #patts$mmDimNames[[k]]$psi[[1]]),
+                                         "","", grp.idx, ""]"", sep="""")
           }
           ctype <- ""lv""
         }
@@ -174,9 +176,11 @@ nlvcovs)
           partable$row[tmprows[2]] <- tbcs
           partable$col[tmprows[2]] <- match(partable$rhs[covpars[i]],
                                             patts$mmDimNames[[k]]$psi[[1]])
-          tmpv2 <- paste(""psi["", match(partable$rhs[covpars[i]], patts$mmDimNames[[k]]$psi[[1]]), "","", k, ""]"", sep="""")
+          tmpv2 <- paste(""psi["", match(partable$rhs[covpars[i]], lv.names), #patts$mmDimNames[[k]]$psi[[1]]),
+                                       "","", k, ""]"", sep="""")
           if(eq.const){
-            oldv2 <- paste(""psi["", match(partable$rhs[full.idx], patts$mmDimNames[[k]]$psi[[1]]), "","", grp.idx, ""]"", sep="""")
+            oldv2 <- paste(""psi["", match(partable$rhs[full.idx], lv.names), #patts$mmDimNames[[k]]$psi[[1]]),
+                                         "","", grp.idx, ""]"", sep="""")
           }
         }
 "
ecmerkle,blavaan,8fd7f1abab7a5933692c3bdc0049c3c59f40a3c5,ecmerkle,merklee@missouri.edu,2016-05-29T20:38:38Z,ecmerkle,merklee@missouri.edu,2016-05-29T20:38:38Z,disallow EM failures in LAV object,DESCRIPTION;R/blavaan.R,False,True,True,False,2,7,9,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.1-4.38
+Version: 0.1-4.39
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blavaan.R---
@@ -92,12 +92,7 @@ blavaan <- function(...,  # default lavaan arguments
     }
 
     # call lavaan
-    LAV <- try(do.call(""lavaan"", dotdotdot), silent = TRUE)
-    if(inherits(LAV, ""try-error"")){
-        warning(""blavaan WARNING: could not compute EM covariance matrix from missing data; fitMeasures may be incorrect.\n"")
-        dotdotdot$missing <- ""listwise""
-        LAV <- do.call(""lavaan"", dotdotdot)
-    }
+    LAV <- do.call(""lavaan"", dotdotdot)
 
     # check for ordered data
     if(lavInspect(LAV, ""categorical"")) {"
ecmerkle,blavaan,5548c73a68ede40bd0ba5186af605504b121f017,ecmerkle,merklee@missouri.edu,2016-05-18T21:08:58Z,ecmerkle,merklee@missouri.edu,2016-05-18T21:08:58Z,manual convergence is default until bugfix,DESCRIPTION;R/blavaan.R;man/bcfa.Rd;man/bgrowth.Rd;man/blavaan.Rd;man/bsem.Rd,False,True,True,False,18,11,29,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.1-4.37
+Version: 0.1-4.38
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blavaan.R---
@@ -15,7 +15,7 @@ blavaan <- function(...,  # default lavaan arguments
                     jagfile            = FALSE,
                     jagextra           = list(),
                     inits              = ""prior"",
-                    convergence        = ""auto"",
+                    convergence        = ""manual"",
                     jagcontrol         = list()
                    )
 {
@@ -67,9 +67,16 @@ blavaan <- function(...,  # default lavaan arguments
         mfj <- list()
     }
     mfj <- c(mfj, list(n.chains = n.chains))
-    if(convergence == ""auto"" & !(""startsample"" %in% names(mfj))){
-        ## bump down default
-        mfj$startsample <- 4000
+    if(convergence == ""auto""){
+        if(!(""startsample"" %in% names(mfj))){
+            ## bump down default
+            mfj$startsample <- 4000
+        } else {
+            if(mfj$startsample < 4000){
+                cat(""blavaan NOTE: starting sample was increased to 4000 for auto-convergence\n"")
+                mfj$startsample <- 4000 # needed for runjags
+            }
+        }
     }
                                              
     # which argument do we remove/ignore?
@@ -457,7 +464,7 @@ blavaan <- function(...,  # default lavaan arguments
 ## cfa + sem
 bcfa <- bsem <- function(..., ov.cp = ""srs"", lv.cp = ""srs"", dp = dpriors(),
     n.chains = 3, burnin, sample, adapt,
-    jagfile = FALSE, jagextra = list(), inits = ""prior"", convergence = ""auto"",
+    jagfile = FALSE, jagextra = list(), inits = ""prior"", convergence = ""manual"",
     jagcontrol = list()) {
 
     dotdotdot <- list(...)
@@ -484,7 +491,7 @@ bcfa <- bsem <- function(..., ov.cp = ""srs"", lv.cp = ""srs"", dp = dpriors(),
 # simple growth models
 bgrowth <- function(..., ov.cp = ""srs"", lv.cp = ""srs"", dp = dpriors(),
     n.chains = 3, burnin, sample, adapt,
-    jagfile = FALSE, jagextra = list(), inits = ""prior"", convergence = ""auto"",
+    jagfile = FALSE, jagextra = list(), inits = ""prior"", convergence = ""manual"",
     jagcontrol = list()) {
 
     dotdotdot <- list(...)

---FILE: man/bcfa.Rd---
@@ -7,7 +7,7 @@ Fit a Confirmatory Factor Analysis (CFA) model.}
 bcfa(..., ov.cp = ""srs"", lv.cp = ""srs"",
      dp = dpriors(), n.chains = 3, burnin, sample,
      adapt, jagfile = FALSE, jagextra = list(), inits = ""prior"",
-     convergence = ""auto"", jagcontrol = list())
+     convergence = ""manual"", jagcontrol = list())
 }
 \arguments{
 \item{...}{Default lavaan arguments.  See \code{\link{lavaan}}.}

---FILE: man/bgrowth.Rd---
@@ -6,7 +6,7 @@ Fit a Growth Curve model.}
 \usage{
 bgrowth(..., ov.cp = ""srs"", lv.cp = ""srs"", dp = dpriors(), n.chains = 3,
 burnin, sample, adapt, jagfile = FALSE, jagextra = list(), 
-inits = ""prior"", convergence = ""auto"", jagcontrol = list())
+inits = ""prior"", convergence = ""manual"", jagcontrol = list())
 }
 \arguments{
 \item{...}{Default lavaan arguments.  See \code{\link{lavaan}}.}

---FILE: man/blavaan.Rd---
@@ -7,7 +7,7 @@ Fit a Bayesian latent variable model.}
 blavaan(..., ov.cp = ""srs"", lv.cp = ""srs"",
     dp = dpriors(), n.chains = 3, burnin, sample,
     adapt, jagfile = FALSE, jagextra = list(), inits = ""prior"",
-    convergence = ""auto"", jagcontrol = list())
+    convergence = ""manual"", jagcontrol = list())
 }
 \arguments{
 \item{...}{Default lavaan arguments.  See \code{\link{lavaan}}.}

---FILE: man/bsem.Rd---
@@ -7,7 +7,7 @@ Fit a Structural Equation Model (SEM).}
 bsem(..., ov.cp = ""srs"", lv.cp = ""srs"",
      dp = dpriors(), n.chains = 3, burnin, sample,
      adapt, jagfile = FALSE, jagextra = list(), inits = ""prior"",
-     convergence = ""auto"", jagcontrol = list())
+     convergence = ""manual"", jagcontrol = list())
 }
 \arguments{
 \item{...}{Default lavaan arguments.  See \code{\link{lavaan}}.}"
ecmerkle,blavaan,da1f3dcd1f0ac6f5b01a0e9e10bc1f17166c4ee3,ecmerkle,merklee@missouri.edu,2016-05-04T16:22:20Z,ecmerkle,merklee@missouri.edu,2016-05-04T16:22:20Z,allow EM failures in LAV object (due to missing data) to pass through,DESCRIPTION,False,False,False,False,1,1,2,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.1-3.27
+Version: 0.1-4.28
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),"
ecmerkle,blavaan,9575ef2b91c68ac435078431fce0c7f21525818f,ecmerkle,merklee@missouri.edu,2016-04-29T21:26:05Z,ecmerkle,merklee@missouri.edu,2016-04-29T21:26:05Z,allow EM failures (due to missing data) to pass with warning,DESCRIPTION;R/blavaan.R,False,True,True,False,8,3,11,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.1-3.26
+Version: 0.1-3.27
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/blavaan.R---
@@ -72,11 +72,16 @@ blavaan <- function(...,  # default lavaan arguments
     if(length(warn.idx) > 0L) {
         warning(""blavaan WARNING: the following arguments are ignored:\n"",
                 ""                   "",
-                paste(lavArgsRemove[warn.idx], collapse = "" ""))
+                paste(lavArgsRemove[warn.idx], collapse = "" ""), ""\n"")
     }
 
     # call lavaan
-    LAV <- do.call(""lavaan"", dotdotdot)
+    LAV <- try(do.call(""lavaan"", dotdotdot), silent = TRUE)
+    if(inherits(LAV, ""try-error"")){
+        warning(""blavaan WARNING: could not compute EM covariance matrix from missing data; fitMeasures may be incorrect.\n"")
+        dotdotdot$missing <- ""listwise""
+        LAV <- do.call(""lavaan"", dotdotdot)
+    }
 
     # check for ordered data
     if(lavInspect(LAV, ""categorical"")) {"
ecmerkle,blavaan,47c70dbd13c3eafbb54df08934286d8249b6dd78,ecmerkle,merklee@missouri.edu,2016-03-25T19:43:47Z,ecmerkle,merklee@missouri.edu,2016-03-25T19:43:47Z,allow for lvs with variances fixed to 0,DESCRIPTION;R/lav_export_jags.R;R/set_priors.R,False,True,True,False,22,5,27,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: blavaan
 Title: Bayesian Latent Variable Analysis
-Version: 0.1-3.22
+Version: 0.1-3.24
 Authors@R: c(person(given = ""Edgar"", family = ""Merkle"",
                     role = c(""aut"", ""cre""),
                     email = ""merklee@missouri.edu""),

---FILE: R/lav_export_jags.R---
@@ -18,6 +18,9 @@ lav2jags <- function(model, lavdata = NULL, ov.cp = ""srs"", lv.cp = ""srs"", lv.x.w
   nparam <- sum(partable$free > 0)
   orig.ov.names <- old.vnames$ov[[1]]; nov <- length(orig.ov.names)
   orig.lv.names <- old.vnames$lv[[1]]; orig.lv.names.x <- old.vnames$lv.x[[1]]
+  ## so ordering stays consistent:
+  orig.lv.names <- c(orig.lv.names[orig.lv.names %in% orig.lv.names.x],
+                     orig.lv.names[!(orig.lv.names %in% orig.lv.names.x)])
   orig.ov.names.x <- old.vnames$ov.x[[1]]
   nlvx <- length(orig.lv.names.x)
   
@@ -389,10 +392,22 @@ lav2jags <- function(model, lavdata = NULL, ov.cp = ""srs"", lv.cp = ""srs"", lv.x.w
           lv.ind <- rbind(lv.ind, c(j, lv.ind[nrow(lv.ind),2] + 1))
           mu.ind <- lv.ind[nrow(lv.ind),2]
           ## TODO see whether we need invpsistar?
-          TXT <- paste(TXT, ""\n"", t2,
-                       ## TODO check for alternative distribution?
-                       ""eta[i,"", j, ""] ~ dnorm(mu.eta[i,"", 
-                       mu.ind, ""], invpsistar["", mu.ind, "",g[i]])"", sep="""")
+          
+          lv.var <- which(partable$lhs == lv.names[mu.ind] &
+                          partable$rhs == lv.names[mu.ind] &
+                          partable$op == ""~~"")
+          ## if lv variance is 0, don't assign a distribution!
+          if(partable$free[lv.var] == 0 & partable$ustart[lv.var] == 0){
+            TXT <- paste(TXT, ""\n"", t2,
+                         ""eta[i,"", j, ""] <- mu.eta[i,"", mu.ind, ""]"", sep="""")
+            ## now change ustart to 1000 so no divide by 0 in jags
+            partable$ustart[lv.var] <- 1000
+          } else {
+            TXT <- paste(TXT, ""\n"", t2,
+                         ## TODO check for alternative distribution?
+                         ""eta[i,"", j, ""] ~ dnorm(mu.eta[i,"", 
+                         mu.ind, ""], invpsistar["", mu.ind, "",g[i]])"", sep="""")
+          }
         } else {
           ## latent interaction:
           eta.eq[j] <- tmp.eq

---FILE: R/set_priors.R---
@@ -342,6 +342,8 @@ set_priors <- function(priorres, partable, i, varnames, ngroups, type=""int"", dp,
                         partable$lhs == partable$rhs &
                         partable$group == 1)
         lvpt <- partable[ptrows,]
+        ## ensure ordering of lvpt corresponds to varnames
+        lvpt <- lvpt[match(lvpt$lhs, varnames[(nov + lvstart):(nov + nlv)]),]
         for(i in lvstart:nlv){
           tmp.eq <- which(partable$op == ""=="" &
                           partable$lhs == varnames[(nov+i)] &"
ecmerkle,blavaan,404e6788ab15c95b6ea5483c58d4ad470181eef8,ecmerkle,merklee@missouri.edu,2015-12-26T21:39:16Z,ecmerkle,merklee@missouri.edu,2015-12-26T21:39:16Z,bug fixes related to custom prior specification,R/blav_utils.R;R/blavaan.R;R/jags2r.R,False,True,True,False,6,3,9,"---FILE: R/blav_utils.R---
@@ -299,7 +299,7 @@ eval_prior <- function(pricom, thetstar, jlabel){
         if(any(grepl(""\\[sd"", pricom))) thetstar <- sqrt(thetstar)
     }
     ## dt() in R assumes mean=0, precision=1
-    if(pricom[1] <- ""dt""){
+    if(pricom[1] == ""dt""){
         tmn <- dpars[2]
         tprec <- dpars[3]
         dpars <- dpars[1]

---FILE: R/blavaan.R---
@@ -118,11 +118,12 @@ blavaan <- function(...,  # default lavaan arguments
     ov.noy <- LAV@pta$vnames$ov.nox[[1]]
     ov.noy <- ov.noy[!(ov.noy %in% LAV@pta$vnames$ov.y)]
     prispec <- ""prior"" %in% names(LAV@ParTable)
+    ndpriors <- rep(FALSE, length(LAV@ParTable$lhs))
+    if(prispec) ndpriors <- LAV@ParTable$prior != """"
     con.cov <- any(LAV@ParTable$lhs %in% c(lv.x, ov.noy) &
                    LAV@ParTable$op == ""~~"" &
                    (LAV@ParTable$free == 0 |
-                    ifelse(prispec, LAV@ParTable$prior != """",
-                           rep(FALSE, length(LAV@ParTable$lhs)))))
+                    ndpriors))
     if(con.cov) LAV@Options$auto.cov.lv.x <- FALSE
 
     # if std.lv, truncate the prior of each lv's first loading

---FILE: R/jags2r.R---
@@ -13,6 +13,8 @@ jagsdist2r <- function(priors, direction = 'jags2r'){
         rnum <- match(x[1], disttrans[,1])
         if(length(x) == 0){
             res <- """"
+        } else if(grepl(""dwish"", x[1])){
+            res <- x
         } else {
             trun <- which(x == ""T"")
             sdvar <- grep(""\\["", x)"
ecmerkle,blavaan,55fe55ab782b4e8107d2a9ced0ec5de3534031cb,ecmerkle,merklee@missouri.edu,2015-11-30T22:09:41Z,ecmerkle,merklee@missouri.edu,2015-11-30T22:09:41Z,fix bug in random initial values when some cov srs parameters are fixed,R/lav_export_jags.R;R/set_priors.R,False,True,True,False,18,5,23,"---FILE: R/lav_export_jags.R---
@@ -144,9 +144,10 @@ lav2jags <- function(model, lavdata = NULL, ov.cp = ""srs"", lv.cp = ""srs"", lv.x.w
              !(partable$lhs %in% orig.lv.names.x) &
              !(partable$rhs %in% orig.lv.names.x))
   }
-  ##cov.eq <- which(partable$op == ""=="" & partable$rhs %in% partable$plabel[covs])
+  cov.eq <- which(covs & partable$free == 0) #partable$op == ""=="" & partable$rhs %in% partable$plabel[covs])
   ##partable$prior[covs & partable$prior==""""] <- dp[[""rho""]]
-  covdim <- sum(covs)/ngroups #(length(covs) - length(cov.eq))/ngroups
+  covdim <- sum(covs)/ngroups
+  #covdim <- (sum(covs) - length(cov.eq))/ngroups
   matdims[3,] <- c(covdim, ngroups)
 
   eqlabs <- partable$rhs[partable$op == ""==""]

---FILE: R/set_priors.R---
@@ -476,9 +476,21 @@ set_priors <- function(priorres, partable, i, varnames, ngroups, type=""int"", dp,
                                                 partable$plabel[c.idx], dp[[""ibpsi""]])
           }
           else if(partable$free[c.idx] == 0){
-            TXT2 <- paste(TXT2, t1, partable$id[c.idx],
-                          "" <- "", partable$ustart[c.idx], ""\n"",
-                          sep="""")
+            if((partable$lhs[c.idx] %in% varnames[1:nov] &
+                ov.cp==""srs"") |
+               (partable$lhs[c.idx] %in% varnames[(nov+1):length(varnames)] &
+                lv.cp==""srs"")){
+              ## define rstar to make initial values easier
+              tmprc <- strsplit(partable$id[c.idx], ""\\["")[[1]][2]
+              TXT2 <- paste(TXT2, t1, partable$id[c.idx],
+                            "" <- -1 + 2*rstar["", tmprc, ""\n"", sep="""")
+              TXT2 <- paste(TXT2, t1, ""rstar["", tmprc, "" <- "",
+                            (as.numeric(partable$ustart[c.idx])+1)/2, ""\n"", sep="""")
+            } else {
+              TXT2 <- paste(TXT2, t1, partable$id[c.idx],
+                            "" <- "", partable$ustart[c.idx], ""\n"",
+                            sep="""")
+            }
           }
           else if(any(partable$op == ""=="" &
                       partable$rhs == partable$rhs[c.idx])){"
