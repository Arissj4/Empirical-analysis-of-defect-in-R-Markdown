repo_owner,repo_name,commit_hash,author_name,author_email,author_date,committer_name,committer_email,committer_date,message,filenames,touches_rmd,touches_r,touches_r_or_rmd,is_merge,added,deleted,changed,diff
ajrgodfrey,BrailleR,95a982d7df2aa635158e588b279382c8692795c9,Florian Kohrt,fkohrt@anche.no,2024-04-12T19:41:16Z,GitHub,noreply@github.com,2024-04-12T19:41:16Z,"Fix CRAN Checks Badge

The domain for CRAN Checks Badges changed from
cranchecks.info to badges.cranchecks.info",README.md,False,False,False,False,1,1,2,"---FILE: README.md---
@@ -14,7 +14,7 @@ The BrailleR package does have dependencies, all of which are available on CRAN.
 
 [![CRAN_Status_Badge](http://www.r-pkg.org/badges/version/BrailleR)](https://cran.r-project.org/package=BrailleR)  
 
-[![CRAN checks](https://cranchecks.info/badges/summary/BrailleR)](https://cran.r-project.org/web/checks/check_results_BrailleR.html)
+[![CRAN checks](https://badges.cranchecks.info/summary/BrailleR.svg)](https://cran.r-project.org/web/checks/check_results_BrailleR.html)
 
 [![Downloads per month](http://cranlogs.r-pkg.org/badges/last-month/BrailleR?color=green)](https://cran.r-project.org/package=BrailleR)
 "
ajrgodfrey,BrailleR,e1638dd866b567b6a44c044bd473ecdddc942f44,Florian Kohrt,fkohrt@anche.no,2024-04-12T19:38:06Z,GitHub,noreply@github.com,2024-04-12T19:38:06Z,"Fix GeomPoint heading

The level 3 heading ""GeomPoint"" lacked a preceding
empty newline, causing it to be treated as another
paragraph on the {pkgdown} website. This commit
adds the newline.",vignettes/ExploringGraphs.Rmd,True,False,True,False,1,0,1,"---FILE: vignettes/ExploringGraphs.Rmd---
@@ -270,6 +270,7 @@ Within each individual line subtree if the line is disjoint there will be more s
 Once you are looking at either the continuous section or the whole section you can click through to actually look at the line.
 
 If there are more than 5 lines then it will summarizes them. If there are 5 or less then you can press through and individually see the line start and finish locations.
+
 ### Geom_Point
 ```{r svg geom point, eval = FALSE, echo=FALSE}
 point <- ggplot(iris, aes(Sepal.Length, Sepal.Width)) +"
ajrgodfrey,BrailleR,4102381ac9a9f31b0f866b496f1424be33ab8363,ajrgodfrey,a.j.godfrey@massey.ac.nz,2023-09-18T08:17:22Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2023-09-18T08:17:22Z,fix spelling stuff up,NAMESPACE;R/RSprint2023.R;R/SpellCheckFiles.R,False,True,True,False,4,4,8,"---FILE: NAMESPACE---
@@ -16,7 +16,7 @@ importFrom(""Rdpack"",""reprompt"")
 import(rmarkdown)
 import(roloc)
 import(rolocISCCNBS)
-importFrom(""spelling"", ""spell_check_file"")
+importFrom(""spelling"", ""spell_check_files"")
 importFrom(""stats"", ""aggregate"", ""anova"", ""as.ts"", ""coef"", ""cor"", ""lm"", ""median"", ""na.omit"", ""qnorm"", ""rstudent"", ""sd"", ""is.ts"") 
 importFrom(""tools"", ""Rd2ex"")
 importFrom(""utils"", ""browseURL"", ""capture.output"", ""create.post"", ""download.file"", ""file.edit"", ""head"", ""menu"", ""packageVersion"", ""read.csv"", ""read.table"", ""savehistory"", ""Sweave"", ""str"", ""tail"", ""unzip"", ""write.csv"") 

---FILE: R/RSprint2023.R---
@@ -104,7 +104,7 @@ return(invisible(NULL))
 
 .VI_C_plot_new = function(...) {
 cat(""A new graph has been created.\n"")
-8:00 pm 18/09/2023return(invisible(NULL))
+return(invisible(NULL))
 } 
 
 .VI_C_title =   function(main, sub, xlab, ylab, line, outer, ...){

---FILE: R/SpellCheckFiles.R---
@@ -27,12 +27,12 @@ SpellCheckFiles =
                      read.table(localIgnoreFile, colClasses = ""character"")[, 1])
         }
       }
-      # a little hack because Hadley doesn't want to export spell_check_file  from the devtools package
+      # a little hack because Hadley doesn't want to export spell_check_files  from the devtools package
 #      NS = getNamespace(""devtools"")
 #      spell_check_file = get(""spell_check_file"", NS)
       checkLines = list()
       checkLines <- lapply(
-          checkFiles, spelling::spell_check_file, ignore = ignore, dict=""en_us"")
+          checkFiles, spelling::spell_check_files, ignore = ignore, dict=""en_us"")
       names(checkLines) = filenames
       class(checkLines) = c(""wordlist"", ""data.frame"")
       return(checkLines)"
ajrgodfrey,BrailleR,daa9cc4ac19e9d4982b32d0aaf99030dacc29a95,ajrgodfrey,a.j.godfrey@massey.ac.nz,2023-09-15T00:22:37Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2023-09-15T00:22:37Z,fixing spelling,DESCRIPTION;R/RSprint2023.R;R/SpellCheckFiles.R,False,True,True,False,71,35,106,"---FILE: DESCRIPTION---
@@ -90,6 +90,6 @@ RdMacros:
     mathjaxr,
     Rdpack
 Encoding: UTF-8
-Language: en-US
+Language: en-GB
 RoxygenNote: 7.1.2
 SystemRequirements: Python 3 and wxPython 4.0

---FILE: R/RSprint2023.R---
@@ -1,63 +1,56 @@
-# this was made possible with much help and insight from Deepayan
-
 
 # to be named more helpfully
 wtf <- function()
 {
     recordedPlot <- recordPlot()
-summary(recordedPlot)
-#now pass through a whisker template
+Out = summary(recordedPlot)#now pass each list element through a whisker template by using .VI_*() below
+for(Element in 1:length(names(Out))){
+do.call(paste0("".VI_"", names(Out)[Element]), Out[[Element]])
+}
+return(NULL)
 }
 
-summary.recordedplot = function(object, ...){
+summary.recordedplot = function(object){
      .getCall <- function(x) {
          structure(list(x[[2]][-1]), 
                   names = x[[2]][1][[1]]$name)
      }
-semiOut=    lapply(object[[1]], .getCall) |> do.call(what = c)
-Out = lapply(semiOut, unlist)
-# name the vectors now
-#Out = .addCFunctionArgNames(Out)
+Out=    lapply(object[[1]], .getCall) |> do.call(what = c)
+# do not name the vectors in here as there is a chance of duplication if the same C function is called twice.
+# result must be cycled through item by item
 return(Out)
 }
 
 
-.addCFunctionArgNames = function(summaryDisplayList){
-for(Element in summaryDisplayList){
-# add the names from DS' argument list found in .plotc_arglist
-
-}
-return(summaryDisplayList)
-}
-
 
+# Note from Deepayan
 # Initial list of functions that get recorded on the display list, along with a potential list of arguments. 
 # The argument list may not be complete or correct in all cases, and will need to be verified.
 # There are other functions that may be called (that definitely happens for grid-based plots), so this should only be considered as a starting point.
 
 .plotc_arglist <- 
     list(C_plot_new = c(""""),
          C_plot_window = c(""""),
-         C_axis = c(""side, at, labels, tick, line, pos, outer, font, lty, lwd, lwd.ticks, col, col.ticks, hadj, padj, gap.axis, ...""),
-         C_plotXY = c(""x, y, type, pch, lty, col, bg, cex, lwd, ...""),
-         C_segments = c(""x0, y0, x1, y1, col, lty, lwd, ...""),
-         C_rect = c(""xl, yb, xr, yt, col, border, lty, ...""),
-         C_path = c(""x, y, col, border, lty, ...""),
-         C_raster = c(""image, xl, yb, xr, yt, angle, interpolate, ...""),
-         C_arrows = c(""x0, y0, x1, y1, length, angle, code, col, lty, lwd, ...""),
-         C_polygon = c(""x, y, col, border, lty, ...""),
-         C_text = c(""xy, labels, adj, pos, offset, vfont, cex, col, font, ...""),
-         C_mtext = c(""text, side, line, outer, at, adj, padj, cex, col, font, ...""),
-         C_title = c(""main, sub, xlab, ylab, line, outer, ...""),
-         C_abline = c(""a, b, h, v, col, lty, lwd, ...""),
-         C_box = c(""which, lty, ...""),
+         C_axis = c(""side, at, labels, tick, line, pos, outer, font, lty, lwd, lwd.ticks, col, col.ticks, hadj, padj, gap.axis""),
+         C_plotXY = c(""x, y, type, pch, lty, col, bg, cex, lwd""),
+        C_segments = c(""x0, y0, x1, y1, col, lty, lwd""),
+         C_rect = c(""xl, yb, xr, yt, col, border, lty""),
+         C_path = c(""x, y, col, border, lty""),
+         C_raster = c(""image, xl, yb, xr, yt, angle, interpolate""),
+         C_arrows = c(""x0, y0, x1, y1, length, angle, code, col, lty, lwd""),
+         C_polygon = c(""x, y, col, border, lty""),
+         C_text = c(""xy, labels, adj, pos, offset, vfont, cex, col, font""),
+         C_mtext = c(""text, side, line, outer, at, adj, padj, cex, col, font""),
+         C_title = c(""main, sub, xlab, ylab, line, outer""),
+         C_abline = c(""a, b, h, v, something, col, lty, lwd""),
+         C_box = c(""which, lty""), 
          C_locator = c(""x, y, nobs, ans, saveans, stype""),
          C_identify = c(""ans, x, y, l, ind, pos, order, Offset, draw, saveans""),
          C_strHeight = c(""?""),
          C_dend = c(""?""),
          C_dendwindow = c(""?""),
          C_erase = c(""?""),
-         C_symbols = c(""x, y, type, data, inches, bg, fg, ...""),
+         C_symbols = c(""x, y, type, data, inches, bg, fg""),
          C_xspline = c(""sx, sy, ss, col, border, res""),
          C_clip = c(""x1, x2, y1, y2""),
          C_convertX = c(""from, to""),
@@ -67,3 +60,46 @@ return(summaryDisplayList)
 lapply(\(x) trimws(strsplit(x, "","")[[1]]))
 
 
+
+
+.addListNames = function(ListToName, NamesList){
+for(Item in names(ListToName)){
+#cat(Item,""\n"") # helps tracking during testing
+try(names(ListToName[[Item]]) <- NamesList[[Item]])
+}
+return(invisible(ListToName))
+}
+
+.print_function_name <- function(...) {
+  arg_name <- deparse(substitute(...))
+  cat(""Function name:"", arg_name, ""\n"")
+}
+
+.VI_palette2 = function(x, ...){cat(""Something unnecessary\n"")}
+
+.VI_C_abline =  .VI_C_plot_new =  .VI_C_plot_window =  .VI_C_axis =  .VI_C_plotXY =  .VI_C_segments =  .VI_C_rect =  .VI_C_path =  .VI_C_raster =  .VI_C_arrows =  .VI_C_polygon =  .VI_C_text =  .VI_C_mtext =  .VI_C_title =   .VI_C_box =  
+.VI_C_locator =  .VI_C_identify =  .VI_C_strHeight =  .VI_C_dend =  .VI_C_dendwindow =  .VI_C_erase =  .VI_C_symbols =  .VI_C_xspline =  .VI_C_clip =  .VI_C_convertX =  .VI_C_convertY = 
+function(x, ...){
+cat(as.character(match.call()), ""\n"")
+}
+
+.VI_C_abline = function(a, b, h, v, something, col, lty, lwd){
+Working = data.frame(a=a, b=b, h=h, v=v, 
+#something=as.logical(something), 
+col=col, lty=lty, lwd=lwd)
+# next bits using cat() go to whisker somehow
+#Working$a = replace(Working$a, is.null(Working$a) & !is.null(Working$b), 0)
+#Working$b = replace(Working$b, !is.null(Working$a) & is.null(Working$b), 0)
+if(any(!is.null(Working$a))) {
+SlopedLines = Working [!is.null(Working$a) | !is.null(Working$b), ]
+ cat(paste(""There  is a"", SlopedLines$lty, SlopedLines$col,  ""line with slope"", SlopedLines$b, ""and intercept"", SlopedLines$a, collapse=""\n""), ""\n"") }
+
+}
+
+# following example used to make elements more identifiable during testing; not likely  in the real world :)
+XVec=(1:5)/2
+YVec=XVec^2
+plot(YVec~XVec)
+title(main=""a main title"")
+abline(b=1.1)
+abline(h=1.3)

---FILE: R/SpellCheckFiles.R---
@@ -28,11 +28,11 @@ SpellCheckFiles =
         }
       }
       # a little hack because Hadley doesn't want to export spell_check_file  from the devtools package
-      NS = getNamespace(""devtools"")
-      spell_check_file = get(""spell_check_file"", NS)
+#      NS = getNamespace(""devtools"")
+#      spell_check_file = get(""spell_check_file"", NS)
       checkLines = list()
       checkLines <- lapply(
-          checkFiles, spell_check_file, ignore = ignore, dict=""en_us"")
+          checkFiles, spelling::spell_check_file, ignore = ignore, dict=""en_us"")
       names(checkLines) = filenames
       class(checkLines) = c(""wordlist"", ""data.frame"")
       return(checkLines)"
ajrgodfrey,BrailleR,ddb348a3a7d0e47b60bf9e3c25f253d93ec219a6,ajrgodfrey,a.j.godfrey@massey.ac.nz,2023-09-06T06:08:49Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2023-09-06T06:08:49Z,fix pkgdown entries,_pkgdown.yml,False,False,False,False,2,0,2,"---FILE: _pkgdown.yml---
@@ -30,6 +30,7 @@ reference:
   - ViewSVG
   - AddXML
   - WTF
+  - summary.recordedplot
   
 - title: Graph and analysis shortcuts
   desc: Functions to help speed up graph making and analysis tasks
@@ -79,6 +80,7 @@ reference:
   - MakeAllFormats
   - MakeSlideShow
   - unfinished
+  - SessionLog
   
 - title: BrailleR related
   desc: All other function not otherwise categorized"
ajrgodfrey,BrailleR,e3feae3c92117a1c77cb9c68e35e0b53275beadd,ajrgodfrey,a.j.godfrey@massey.ac.nz,2023-09-04T10:45:18Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2023-09-04T10:45:18Z,spelling fixes,NEWS.md;R/UseTemplate.R;inst/WORDLIST;man/Deprecated.Rd;man/GetGoing.Rd;man/MakeBatch.Rd;man/OneFactor.Rd;man/OnePredictor.Rd;man/SessionLog.Rd;man/ThreeFactors.Rd;man/TwoFactors.Rd;man/VI.Rd;man/WhichFile.Rd;man/summary.recordedplot.Rd,False,True,True,False,17,20,37,"---FILE: NEWS.md---
@@ -16,7 +16,7 @@
 - removed explicit CITATION file. This then required explicit date specification in DESCRIPTION.
 
 # BrailleR 0.99.0
-- did some cleaning up to de-clutter, check examples, add documentation, and all the good things that must be done prior to v1.0.0
+- did some cleaning up to reduce clutter, check examples, add documentation, and all the good things that must be done prior to v1.0.0
 - removed dependency on magrittr as now using native pipe
 - removed rlang as a dependency; redundant for some time probably
 - removed other dependencies (on base packages) from imports
@@ -143,7 +143,7 @@
 - attempting to remove all references to the reticulate package
 - added TestPython() and TestWX() functions which test system setup.
 - added Messages.R and Warnings.R to create text strings that get used in multiple functions. All now use internal functions
-- deprecated GetPython27() and GetWxPython27(); updated help pages to show deprocation
+- deprecated GetPython27() and GetWxPython27(); updated help pages to show deprecation
 
 
 

---FILE: R/UseTemplate.R---
@@ -18,10 +18,10 @@ for(i in 1:length(replace)){
 TXT = gsub(find[i], replace[i], TXT)
 }
 }
+return(paste0(TXT, collapse=""\n""))
       } else {
         .InteractiveOnly()
       }
-return(paste0(TXT, collapse=""\n""))
 }
 
 
@@ -33,10 +33,10 @@ if(!is.null(NewFile)){
 cat(OutText, file=NewFile)
 .NewFile(NewFile)
 }
+return(OutText)
       } else {
         .InteractiveOnly()
       }
-return(OutText)
 }
 
 .ChooseTemplate = function(){

---FILE: inst/WORDLIST---
@@ -13,7 +13,6 @@ Bengtsson
 bibtex
 BlindRUG
 BOM
-brailleR
 BrailleR
 BrailleRHistory
 BrailleRHome
@@ -47,8 +46,6 @@ dcf
 De
 DEIMS
 Dengler
-deprocated
-deprocation
 desc
 Devian
 devian
@@ -77,6 +74,7 @@ FittedLinePlot
 fittedlineplot
 flavours
 forma
+Gabe
 Galili
 gam
 GeomArea
@@ -293,7 +291,6 @@ wordlist
 WriteR
 WriteROptions
 WTF
-wth
 www
 WxPython
 wxPython

---FILE: man/Deprecated.Rd---
@@ -14,7 +14,7 @@ MakeSlidy(...)
 MakeSlideShow(...)
 }
 \arguments{
-\item{...}{cover for unnecessary arguments going to deprocated functions.}
+\item{...}{cover for unnecessary arguments going to deprecated functions.}
 }
 \details{ These functions are redundant.
 

---FILE: man/GetGoing.Rd---
@@ -1,7 +1,7 @@
 \name{GetGoing}
 \alias{GetGoing}
 \alias{GetingStarted}
-\title{Set options for using brailleR}
+\title{Set options for using BrailleR}
 \description{An interactive question-and-answer interface suitable for blind users wanting to set the options for using the BrailleR package.}
 \usage{
 GetGoing()

---FILE: man/MakeBatch.Rd---
@@ -2,7 +2,7 @@
 \alias{MakeBatch}
 \alias{MakeAdminBatch}
 \title{Create batch files for processing R scripts and markdown files under Windows}
-\description{Convenience function for creating batch files that can be used under Windows to process R scripts, R markdown, and quarto  files. The main idea is that a user can click on the bacth files within Windows Explorer to get the desired task done faster.}
+\description{Convenience function for creating batch files that can be used under Windows to process R scripts, R markdown, and quarto  files. The main idea is that a user can click on the batch files within Windows Explorer to get the desired task done faster.}
 \usage{
 MakeBatch(file=NULL, static = FALSE)
 

---FILE: man/OneFactor.Rd---
@@ -20,7 +20,7 @@ View = getOption(""BrailleR.View""), Modern=TRUE)
   \item{VI}{Logical: Should the VI method for blind users be employed?}
   \item{Latex}{Logical: Should the tabulated sections be saved in LaTeX format?}
   \item{View}{Logical: Should the HTML file be opened for inspection?}
-  \item{Modern}{Logical: Should the graphics be createdusing ggplot?}
+  \item{Modern}{Logical: Should the graphics be created using ggplot?}
 }
 \details{This function writes an R markdown file that is knitted into HTML and purled into an R script. All graphs are saved in subdirectories in png, eps, pdf and svg formats. Tabulated results are stored in files suitable for importing into LaTeX documents.}
 \value{This function is used for creation of the files saved in the working directory and a few of its subdirectories.}

---FILE: man/OnePredictor.Rd---
@@ -18,7 +18,7 @@ OnePredictor(Response, Predictor, Data = NULL,
   \item{VI}{Logical: Should the VI method for blind users be employed?}
   \item{Latex}{Logical: Should the tabulated sections be saved in LaTeX format?}
   \item{View}{Logical: Should the HTML file be opened for inspection?}
-  \item{Modern}{Logical: Should the graphics be createdusing ggplot?}
+  \item{Modern}{Logical: Should the graphics be created using ggplot?}
 }
 \details{This function writes an R markdown file that is knitted into HTML and purled into an R script. All graphs are saved in subdirectories in png, eps, pdf and svg formats. Tabulated results can be stored in files suitable for importing into LaTeX documents.}
 \value{This function is used for creation of the files saved in the working directory and a few of its subdirectories.}

---FILE: man/SessionLog.Rd---
@@ -15,6 +15,6 @@ SessionLog(file = """", n=NULL)
 }
 \details{
 A stack of top level calls and the resulting output is stored, courtesy of a setting established on package load. These functions retrieve elements from that stack.}
-\value{NULL, invisibly; not the output wich is either printed to the console or the file specified}
+\value{NULL, invisibly; not the output which is either printed to the console or the file specified}
 \author{Gabe Becker and some very minor edits from A. Jonathan R. Godfrey}
 

---FILE: man/ThreeFactors.Rd---
@@ -16,7 +16,7 @@ ThreeFactors(Response, Factor1, Factor2, Factor3, Data = NULL, Filename = NULL,
   \item{VI}{Logical: Should the VI method for blind users be employed?}
   \item{Latex}{Logical: Should the tabulated sections be saved in LaTeX format?}
   \item{View}{Logical: Should the HTML file be opened for inspection?}
-  \item{Modern}{Logical: Should the graphics be createdusing ggplot?}
+  \item{Modern}{Logical: Should the graphics be created using ggplot?}
 }
 \details{
 to complete}

---FILE: man/TwoFactors.Rd---
@@ -20,7 +20,7 @@ TwoFactors(Response, Factor1, Factor2, Inter = FALSE, HSD = TRUE,
   \item{VI}{Logical: Should the VI method for blind users be employed?}
   \item{Latex}{Logical: Should the tabulated sections be saved in LaTeX format?}
   \item{View}{Logical: Should the HTML file be opened for inspection?}
-  \item{Modern}{Logical: Should the graphics be createdusing ggplot?}
+  \item{Modern}{Logical: Should the graphics be created using ggplot?}
 }
 \details{
 to complete}

---FILE: man/VI.Rd---
@@ -65,7 +65,7 @@ description is printed.
 \note{
 The \code{VI.lm} method fails if you use  the one line \code{VI(lm(...))} even if the model is named using \code{VI(Model1 <- lm(...))}. It does work if two explicit commands are used. For example \code{Model1 = lm(...)} followed by \code{VI(Model1)}.
 
-The ggplot2 package contains many layers and not all of them have a VI output yet. However most of the commonly used ones do. Regardless the VI output should be considered experimental with some results being potenitally misleading.
+The ggplot2 package contains many layers and not all of them have a VI output yet. However most of the commonly used ones do. Regardless the VI output should be considered experimental with some results being potentially misleading.
 }
 \author{
 A. Jonathan R. Godfrey, Debra Warren, Sophie Banks, Tony Hirst, Timothy P. Bilton and James A. Thompson

---FILE: man/WhichFile.Rd---
@@ -8,7 +8,7 @@ WhichFile(String, Folder, fixed = TRUE, DoesExist = TRUE)
 \arguments{
   \item{String}{The text string or regular expression being sought.}
   \item{Folder}{The head folder to start searching in.}
-  \item{fixed}{Fixed text string or if FALSE, a regular expression that will be passed togrep().}
+  \item{fixed}{Fixed text string or if FALSE, a regular expression that will be passed to grep().}
   \item{DoesExist}{If TRUE, it shows the files that do include the text string of interest; if FALSE, files that lack the search string are returned.}
 }
 \details{

---FILE: man/summary.recordedplot.Rd---
@@ -1,13 +1,13 @@
 \name{summary.recordedplot}
 \alias{summary.recordedplot}
 \title{Summarise the display list for a  graphics device}
-\description{Base graphics are created using a series of calls to C routines. This function gathers the names of these calls and the values of the arguments as supplied. Names of the arguments are then added. The display list must be retrived before the graphics device is closed, but this could be stored for later summarisation.}
+\description{Base graphics are created using a series of calls to C routines. This function gathers the names of these calls and the values of the arguments as supplied. Names of the arguments are then added. The display list must be retrieved before the graphics device is closed, but this could be stored for later summarisation.}
 \usage{
 \method{summary}{recordedplot}(object, ...)
 }
 \arguments{
   \item{object}{the display list created by recordPlot().}
-  \item{\dots}{nenessary argument for the method; currently ignored}
+  \item{\dots}{necessary argument for the method; currently ignored}
 }
 \details{
 The outcome of this command must be further processed to give it  context."
ajrgodfrey,BrailleR,6a5d41bd4bdb630b8961b937852a486dedeb7f95,ajrgodfrey,a.j.godfrey@massey.ac.nz,2023-09-04T09:52:33Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2023-09-04T09:52:33Z,fix,R/UseTemplate.R,False,True,True,False,0,3,3,"---FILE: R/UseTemplate.R---
@@ -54,9 +54,6 @@ message(paste(""The"", file, ""uses the following terms that must be replaced:"", Su
         .InteractiveOnly()
 file=NULL
       }
-      } else {
-        .InteractiveOnly()
-      }
 return(file)
 }
 "
ajrgodfrey,BrailleR,ea9dd373fc6b09571c83af5adc775a4daf24db15,ajrgodfrey,a.j.godfrey@massey.ac.nz,2023-09-03T21:29:32Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2023-09-03T21:29:32Z,fix checks,NAMESPACE;man/SessionLog.Rd;man/summary.recordedplot.Rd,False,False,False,False,3,3,6,"---FILE: NAMESPACE---
@@ -19,7 +19,7 @@ import(roloc)
 import(rolocISCCNBS)
 importFrom(""stats"", ""aggregate"", ""anova"", ""as.ts"", ""coef"", ""cor"", ""lm"", ""median"", ""na.omit"", ""qnorm"", ""rstudent"", ""sd"", ""is.ts"") 
 importFrom(""tools"", ""Rd2ex"")
-importFrom(""utils"", ""browseURL"", ""create.post"", ""download.file"", ""file.edit"", ""head"", ""menu"", ""packageVersion"", ""read.csv"", ""read.table"", ""savehistory"", ""Sweave"", ""str"", ""tail"", ""unzip"", ""write.csv"") 
+importFrom(""utils"", ""browseURL"", ""capture.output"", ""create.post"", ""download.file"", ""file.edit"", ""head"", ""menu"", ""packageVersion"", ""read.csv"", ""read.table"", ""savehistory"", ""Sweave"", ""str"", ""tail"", ""unzip"", ""write.csv"") 
 importFrom(""whisker"", ""whisker.render"")
 importFrom(""XML"", ""addAttributes"", ""newXMLDoc"", ""newXMLNode"", ""ensureNamespace"", ""newXMLTextNode"", ""xmlName"", ""xmlRoot"", ""saveXML"", ""getNodeSet"", ""xmlGetAttr"", ""addChildren"", ""removeChildren"", ""xmlChildren"")
 importFrom(""xtable"", ""xtable"")

---FILE: man/SessionLog.Rd---
@@ -5,7 +5,7 @@
 \description{
 Retrieve the output from the last n top level calls, or the hole current session. These functions are designed to cater for situations where the output scrolls off the screen and is no longer accessible to a screen reader user.}
 \usage{
-Grablast(file = """", n=1)
+GrabLast(file = """", n=1)
 
 SessionLog(file = """", n=MULL)
 }

---FILE: man/summary.recordedplot.Rd---
@@ -19,7 +19,7 @@ A named list of named vectors. Names of list elements are the C function calls u
 }
 \seealso{
 %% ~~objects to See Also as \code{\link{help}}, ~~~
-}
+to fix
 \examples{
 plot(x=c(1:20), y=runif(20))
 abline(h=0.5)"
ajrgodfrey,BrailleR,a6f3a9b23f12364911e599fa00b055a59e37de6e,ajrgodfrey,a.j.godfrey@massey.ac.nz,2023-08-31T13:23:41Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2023-08-31T13:23:41Z,fix addNames,R/RSprint2023.R;man/summary.recordedplot.Rd,False,True,True,False,3,2,5,"---FILE: R/RSprint2023.R---
@@ -27,6 +27,7 @@ for(Element in summaryDisplayList){
 # add the names from DS' argument list found in .plotc_arglist
 
 }
+return(summaryDisplayList)
 }
 
 

---FILE: man/summary.recordedplot.Rd---
@@ -21,8 +21,8 @@ A named list of named vectors. Names of list elements are the C function calls u
 %% ~~objects to See Also as \code{\link{help}}, ~~~
 }
 \examples{
-plot(x=1:20, y=x^2)
-abline(h=100)
+plot(x=c(1:20), y=runif(20))
+abline(h=0.5)
 
 p = recordPlot()
 summary(p)"
ajrgodfrey,BrailleR,73b63e861dc9f614848a7553385e39e5cc8c3bc2,ajrgodfrey,ajgodfre@massey.ac.nz,2023-07-09T09:09:17Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-07-09T09:09:17Z,v1.0.2 fixes for CRAN submission,NEWS.md;cran-comments.md;man/BrailleR-package.Rd,False,False,False,False,6,2,8,"---FILE: NEWS.md---
@@ -1,4 +1,8 @@
 # BrailleR 1.0.2
+- improved CRAN test picked up inconsistencies with internal functions
+
+# BrailleR 1.0.1
+- deleted detritus
 
 # BrailleR 1.0.0
 - first production release. Still plenty to add, but the original intention of the package has now been met.

---FILE: cran-comments.md---
@@ -2,7 +2,7 @@
 nothing to note (I hope) except:
 
 
-- NOTE re run time for examples. I get these sporadically. If pain persists, I will need to remove the examples.
+- NOTE re run time for examples. I get these sporadically. If pain persists, I will need to remove the examples. CRAN servers and Win-builder seem to have adequate grunt to avoid this issue.
 
 - Any functions relying on package 'installr' (which was originally created for Windows only and listed as Suggests), only try to make use of installr::foo() within sufficient OS checking if() statements and requireNamespace().
 

---FILE: man/BrailleR-package.Rd---
@@ -10,7 +10,7 @@ Improved Access for Blind Users}
 \tabular{ll}{
 Package: \tab BrailleR\cr
 Type: \tab Package\cr
-Version: \tab 1.0.1 \cr
+Version: \tab 1.0.2 \cr
 Date: \tab 2023-07-07\cr
 License: \tab GPL-2\cr
 }"
ajrgodfrey,BrailleR,9ec694c32e0f84dcc1981af1bec756980815f014,ajrgodfrey,ajgodfre@massey.ac.nz,2023-07-09T09:05:47Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-07-09T09:05:47Z,v1.0.2 fixes for CRAN submission,DESCRIPTION;NEWS.md,False,False,False,False,3,1,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: BrailleR
 Title: Improved Access for Blind Users
-Version: 1.0.1
+Version: 1.0.2
 Date: 2023-07-07
 Authors@R: c(
     person(""A. Jonathan R."", ""Godfrey"", , ""a.j.godfrey@massey.ac.nz"", role = c(""aut"", ""cre""),

---FILE: NEWS.md---
@@ -1,3 +1,5 @@
+# BrailleR 1.0.2
+
 # BrailleR 1.0.0
 - first production release. Still plenty to add, but the original intention of the package has now been met.
 - removed explicit CITATION file. This then required explicit date specification in DESCRIPTION."
ajrgodfrey,BrailleR,d308276f96f57f45d4c425b6c5921f966c2d81b6,ajrgodfrey,ajgodfre@massey.ac.nz,2023-07-09T09:05:21Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-07-09T09:05:21Z,v1.0.2 fixes for CRAN submission,R/AddXMLInternal.R;R/RewriteSVG.R,False,True,True,False,9,9,18,"---FILE: R/AddXMLInternal.R---
@@ -624,7 +624,7 @@
   stop(""This type is not supported: "", class(graphObject))
 }
 
-.AddXMLGGplotGeomItem.smooth <- function(root, graphObject, position = 1, id = NULL, speech, speech2 = speech, lineDesc, ciDesc, layer) {
+.AddXMLGGplotGeomItem.smooth <- function(root, graphObject, position = 1, id = NULL, speech, speech2 = speech, lineDesc, ciDesc, layer, ...) {
   annotation <- .AddXMLAddAnnotation(root, position = position, id = paste(id, letters[position], sep = "".""), kind = ""grouped"")
   XML::addAttributes(annotation$root, speech = speech, speech2 = speech2)
 
@@ -658,7 +658,7 @@
 
 .AddXMLGGplotGeomItem.bar <- function(root, graphObject, position = 1, id = NULL, speech, speech2 = speech,
                                       x = NULL, count = NULL, density = NULL, start = NULL, end = NULL,
-                                      categorical = TRUE) {
+                                      categorical = TRUE, ...) {
   rectId <- ifelse(is.null(id), .AddXMLmakeId(""rect"", .CreateID(""1.1"", position)), id)
   annotation <- .AddXMLAddAnnotation(root,
     position = position,
@@ -685,7 +685,7 @@
   return(invisible(annotation))
 }
 
-.AddXMLGGplotGeomItem.line <- function(root, graphObject, position = 1, id = NULL, speech, speech2 = speech) {
+.AddXMLGGplotGeomItem.line <- function(root, graphObject, position = 1, id = NULL, speech, speech2 = speech, ...) {
   return(.AddXMLGGplotGeomItem.point(root, graphObject, position, id, speech, speech2))
 }
 

---FILE: R/RewriteSVG.R---
@@ -1,6 +1,6 @@
-#' Rewrite a SVG so that it cna be properly explored with diagcess via the XML.
+#' Rewrite a SVG so that it can be properly explored with diagcess via the XML.
 #' @rdname .RewriteSVG
-#' The Rewrite SVG is a wrapper around the .RewrtieSVGGeom function. It will loop through each
+#' The Rewrite SVG is a wrapper around the .RewriteSVGGeom function. It will loop through each
 #' of the layers and do the necessary changes.
 #'
 #' @param x The graph object that the svg comes from
@@ -48,10 +48,10 @@
 }
 
 .RewriteSVGGeom.default <- function(x, type, geomGTagID, geomGTag, ...) {
-  # Nothing is to be done by deafult
+  # Nothing is to be done by default
 }
 
-.RewriteSVGGeom.GeomLine <- function(x, type, geomGTagID, geomGTag, layer = 1) {
+.RewriteSVGGeom.GeomLine <- function(x, type, geomGTagID, geomGTag, layer = 1, ...) {
   struct <- .VIstruct.ggplot(x)[[""panels""]][[1]][[""panellayers""]][[layer]]
 
   # Need to figure out how many lines there are
@@ -100,7 +100,7 @@
   }
 }
 
-.RewriteSVGGeom.GeomPoint <- function(x, type, geomGTagID, geomGTag, layer = 1) {
+.RewriteSVGGeom.GeomPoint <- function(x, type, geomGTagID, geomGTag, layer = 1, ...) {
   pointNodes <- XML::xmlChildren(geomGTag)
 
   structLayer <- .VIstruct.ggplot(x)[[""panels""]][[1]][[""panellayers""]][[layer]][[""scaledata""]]
@@ -133,7 +133,7 @@
   }
 }
 
-.RewriteSVGGeom.GeomSmooth <- function(x, type, geomGTagID, geomGTag, layer = 1) {
+.RewriteSVGGeom.GeomSmooth <- function(x, type, geomGTagID, geomGTag, layer = 1, ...) {
   ribbonAndLine <- XML::xmlChildren(geomGTag)
   ## Checking to see if it has a SE ribbon around the fitted line.
   if (length(ribbonAndLine) == 3) {"
ajrgodfrey,BrailleR,b3d8480eaef577b83ba35249280e4a13d8aeefe8,James,1jamesthompson1@gmail.com,2023-07-09T06:34:00Z,James,1jamesthompson1@gmail.com,2023-07-09T06:34:00Z,Remove AddXMLInternal to fix pkgdown build,man/AddXMLInternal.Rd,False,False,False,False,0,7,7,"---FILE: man/AddXMLInternal.Rd---
@@ -1,7 +0,0 @@
-\name{AddXMLInternal}
-\alias{.AddXMLAddTitle}
-\title{Internal functions for adding the necessary XML content for accessible graphs in SVG format}
-\description{Mostly internal functions for adding XML content to an external file}
-\details{Not for use as exported functions}
-\value{Either the filename written to, or NULL}
-\author{Volker Sorge and A. Jonathan R. Godfrey}"
ajrgodfrey,BrailleR,e83e3b9111c4e6eb00c960026cf6a081dcc13600,ajrgodfrey,ajgodfre@massey.ac.nz,2023-07-08T22:52:41Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-07-08T22:52:41Z,v1.0.1 late fixes before CRAN submission,README.md,False,False,False,False,1,1,2,"---FILE: README.md---
@@ -2,7 +2,7 @@
 
 
 
-BrailleR version numbers are of the form a.b.c, where a.b is the major version and c is the minor version. From July 2023, the version number starts with a 1 because development over ten years means we believe the package delivers on the original aims of the BrailleR Project. The second part of the major version is odd for development and even for CRAN releases. Minor version increments just help track progress.
+BrailleR version numbers are of the form a.b.c, where a is the major version b is the minor version, and c is the pactch version. From July 2023, the version number starts with a 1 because development over ten years means we believe the package delivers on the original aims of the BrailleR Project. The minor version is odd for development and even for CRAN releases. Patch version increments just help track progress.
 
 The BrailleR package does have dependencies, all of which are available on CRAN. 
 <!-- badges: start -->"
ajrgodfrey,BrailleR,64ea2a73c73531fced944224cdcb9dc530c2b2b9,ajrgodfrey,ajgodfre@massey.ac.nz,2023-07-08T22:20:44Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-07-08T22:20:44Z,v1.0.1 late fixes before CRAN submission,DESCRIPTION;man/BrailleR-package.Rd,False,False,False,False,3,3,6,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: BrailleR
 Title: Improved Access for Blind Users
-Version: 1.0.0
+Version: 1.0.1
 Date: 2023-07-07
 Authors@R: c(
     person(""A. Jonathan R."", ""Godfrey"", , ""a.j.godfrey@massey.ac.nz"", role = c(""aut"", ""cre""),

---FILE: man/BrailleR-package.Rd---
@@ -10,8 +10,8 @@ Improved Access for Blind Users}
 \tabular{ll}{
 Package: \tab BrailleR\cr
 Type: \tab Package\cr
-Version: \tab 1.0.0 \cr
-Date: \tab 2023-07-01\cr
+Version: \tab 1.0.1 \cr
+Date: \tab 2023-07-07\cr
 License: \tab GPL-2\cr
 }
 }"
ajrgodfrey,BrailleR,fd26fe4778f0a7f08b66953ceb75f7c70ce3d010,ajrgodfrey,ajgodfre@massey.ac.nz,2023-07-08T22:10:44Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-07-08T22:10:44Z,v1.0.0 late fixes before CRAN submission,man/MakeSlideShow.Rd,False,False,False,False,0,5,5,"---FILE: man/MakeSlideShow.Rd---
@@ -1,5 +0,0 @@
-\name{MakeSlideShow}
-\title{Turn a set of Rmd files into an HTML slide show}
-\description{
-These functions used to take a set of Rmd files in alphabetical order and makes them a set of linked HTML files or a single slidy presentation suitable for delivering a presentation., or a single plain HTML file suitable for distribution They have been overtaken by bookdown, pkgdown, rmarkdown, etc.}
-"
ajrgodfrey,BrailleR,e8edf5ed32611577f15d7c8a26b75b2e2aa3fee9,ajrgodfrey,ajgodfre@massey.ac.nz,2023-07-08T21:43:30Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-07-08T21:43:30Z,v1.0.0 late fixes before CRAN submission,DESCRIPTION,False,False,False,False,1,1,2,"---FILE: DESCRIPTION---
@@ -1,7 +1,7 @@
 Package: BrailleR
 Title: Improved Access for Blind Users
 Version: 1.0.0
-Date: 2023-07-01
+Date: 2023-07-07
 Authors@R: c(
     person(""A. Jonathan R."", ""Godfrey"", , ""a.j.godfrey@massey.ac.nz"", role = c(""aut"", ""cre""),
     comment = c(ORCID = ""0000-0002-8129-8835"")),"
ajrgodfrey,BrailleR,203a8a639b9253bc1f59b23951283652930dc659,ajrgodfrey,ajgodfre@massey.ac.nz,2023-07-02T03:48:51Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-07-02T03:48:51Z,v1.0.0 late fixes before CRAN submission,DESCRIPTION;NAMESPACE;NEWS.md;cran-comments.md;inst/CITATION,False,False,False,False,8,26,34,"---FILE: DESCRIPTION---
@@ -1,6 +1,7 @@
 Package: BrailleR
 Title: Improved Access for Blind Users
 Version: 1.0.0
+Date: 2023-07-01
 Authors@R: c(
     person(""A. Jonathan R."", ""Godfrey"", , ""a.j.godfrey@massey.ac.nz"", role = c(""aut"", ""cre""),
     comment = c(ORCID = ""0000-0002-8129-8835"")),
@@ -43,7 +44,6 @@ URL: https://github.com/ajrgodfrey/BrailleR,
     http://ajrgodfrey.github.io/BrailleR/
 BugReports: https://github.com/ajrgodfrey/BrailleR/issues
 Depends:
-    mathjaxr,
     R (>= 3.4.0)
 Imports:
     devtools,
@@ -54,6 +54,7 @@ Imports:
     gridSVG,
     hunspell,
     knitr,
+    mathjaxr,
     moments,
     quarto,
     Rdpack,

---FILE: NAMESPACE---
@@ -10,6 +10,7 @@ import(gridGraphics)
 importFrom(""gridSVG"", ""dev.off"", ""elementGrob"", ""textNodeGrob"")
 importFrom(""hunspell"", ""hunspell"")
 import(knitr)
+import(mathjaxr)
 importFrom(""moments"", ""skewness"")
 importFrom(""quarto"", ""quarto_path"")
 importFrom(""Rdpack"",""reprompt"")

---FILE: NEWS.md---
@@ -1,8 +1,6 @@
 # BrailleR 1.0.0
 - first production release. Still plenty to add, but the original intention of the package has now been met.
-
-
-
+- removed explicit CITATION file. This then required explicit date specification in DESCRIPTION.
 
 # BrailleR 0.99.0
 - did some cleaning up to de-clutter, check examples, add documentation, and all the good things that must be done prior to v1.0.0
@@ -11,8 +9,6 @@
 - removed other dependencies (on base packages) from imports
 - responded to June 28 CRAN check
 
-
-
 # BrailleR 0.33.4
 - fix issue #35 with incorrect bin counts
 - fix issue #24, correcting base r plot titles in VI

---FILE: cran-comments.md---
@@ -2,7 +2,9 @@
 nothing to note (I hope) except:
 
 
-Any functions relying on package 'installr' (which was originally created for Windows only and listed as Suggests), only try to make use of installr::foo() within sufficient OS checking if() statements and requireNamespace().
+- NOTE re run time for examples. I get these sporadically. If pain persists, I will need to remove the examples.
 
-Any use of the shell() command do so with OS conditioning and interactive mode protection
+- Any functions relying on package 'installr' (which was originally created for Windows only and listed as Suggests), only try to make use of installr::foo() within sufficient OS checking if() statements and requireNamespace().
+
+- Any use of the shell() command do so with OS conditioning and interactive mode protection
 

---FILE: inst/CITATION---
@@ -1,18 +0,0 @@
-citHeader(""To cite package 'BrailleR' in publications use:"")
-
-if(!exists(""meta"") || is.null(meta)) meta <- packageDescription(""BrailleR"")
-year <- sub("".*(2[[:digit:]]{3})-.*"", ""\\1"", meta$Date)
-vers <- paste(""R package version"", meta$Version)
-
-citEntry(entry=""Manual"",
-  title = ""BrailleR: Improved access for blind users"",
-author = personList(as.person(""A. Jonathan R. Godfrey"")), year = year,
-organization=""Massey University"",   note = vers, url = ""https://cran.r-project.org/package=BrailleR"",
-
-  textVersion =
-  paste(""A. Jonathan R. Godfrey
-("",
-year,
-  ""). BrailleR: Improved access for blind users. "",
-  vers, ""."", sep=""""))
-"
ajrgodfrey,BrailleR,cac4e10b32765de0cadf996933ae7c9747608e2b,ajrgodfrey,ajgodfre@massey.ac.nz,2023-07-02T01:18:13Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-07-02T01:18:13Z,v1.0.0 late fixes before CRAN submission,DESCRIPTION;NAMESPACE;NEWS.md;README.md;cran-comments.md;inst/Templates/PCA.Rmd;inst/Templates/SplitPlot.Rmd;man/AddXMLInternal.Rd;man/BrailleR-package.Rd;man/R2txtJG.Rd,True,False,True,False,25,11,36,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: BrailleR
 Title: Improved Access for Blind Users
-Version: 0.99.0
+Version: 1.0.0
 Authors@R: c(
     person(""A. Jonathan R."", ""Godfrey"", , ""a.j.godfrey@massey.ac.nz"", role = c(""aut"", ""cre""),
     comment = c(ORCID = ""0000-0002-8129-8835"")),
@@ -43,6 +43,7 @@ URL: https://github.com/ajrgodfrey/BrailleR,
     http://ajrgodfrey.github.io/BrailleR/
 BugReports: https://github.com/ajrgodfrey/BrailleR/issues
 Depends:
+    mathjaxr,
     R (>= 3.4.0)
 Imports:
     devtools,
@@ -53,7 +54,6 @@ Imports:
     gridSVG,
     hunspell,
     knitr,
-    mathjaxr,
     moments,
     quarto,
     Rdpack,

---FILE: NAMESPACE---
@@ -10,7 +10,6 @@ import(gridGraphics)
 importFrom(""gridSVG"", ""dev.off"", ""elementGrob"", ""textNodeGrob"")
 importFrom(""hunspell"", ""hunspell"")
 import(knitr)
-import(mathjaxr)
 importFrom(""moments"", ""skewness"")
 importFrom(""quarto"", ""quarto_path"")
 importFrom(""Rdpack"",""reprompt"")

---FILE: NEWS.md---
@@ -1,8 +1,16 @@
+# BrailleR 1.0.0
+- first production release. Still plenty to add, but the original intention of the package has now been met.
+
+
+
+
 # BrailleR 0.99.0
 - did some cleaning up to de-clutter, check examples, add documentation, and all the good things that must be done prior to v1.0.0
 - removed dependency on magrittr as now using native pipe
 - removed rlang as a dependency; redundant for some time probably
 - removed other dependencies (on base packages) from imports
+- responded to June 28 CRAN check
+
 
 
 # BrailleR 0.33.4

---FILE: README.md---
@@ -2,7 +2,7 @@
 
 
 
-BrailleR version numbers are of the form a.b.c, where a.b is the major version and c is the minor version. The leading zero infers that this package is under ongoing development to get to the state where it delivers the original aims of the package. The second part of the major version is odd for development and even for CRAN releases. Minor version increments just help track progress.
+BrailleR version numbers are of the form a.b.c, where a.b is the major version and c is the minor version. From July 2023, the version number starts with a 1 because development over ten years means we believe the package delivers on the original aims of the BrailleR Project. The second part of the major version is odd for development and even for CRAN releases. Minor version increments just help track progress.
 
 The BrailleR package does have dependencies, all of which are available on CRAN. 
 <!-- badges: start -->
@@ -37,7 +37,7 @@ R is perhaps the most blind-friendly statistical software option because all scr
 3. Make it easier for blind users to create their own R markdown documents.
 5. Replace the tasks other users can do quickly using the RStudio IDE.
 
-If these criteria were met, then the `BrailleR` package would be supporting blind people through their first courses in statistics, and perhaps/hopefully into second or third courses.
+If these criteria are all met, then the `BrailleR` package can support blind people through their first courses in statistics, and perhaps/hopefully into second or third courses.
 
 ### Installation of BrailleR
 

---FILE: cran-comments.md---
@@ -1,5 +1,5 @@
 
-nothing else to note (I hope) except:
+nothing to note (I hope) except:
 
 
 Any functions relying on package 'installr' (which was originally created for Windows only and listed as Suggests), only try to make use of installr::foo() within sufficient OS checking if() statements and requireNamespace().

---FILE: inst/Templates/PCA.Rmd---
@@ -45,7 +45,7 @@ kable(caption=""Principal Component Loadings for the {{DataName}} data."")
 
 ```{r}
 #| label = ""augment{{DataName}}.pc""
-{{DataName}}.pc.fit = {{DataName}}.pc |> augment(DataName)  
+{{DataName}}.pc.fit = {{DataName}}.pc |> augment({{DataName}})  
 ```
 
 

---FILE: inst/Templates/SplitPlot.Rmd---
@@ -2,7 +2,7 @@
 ```{r}
 #| label = ""{{DataName}}.lme""
 library(nlme)
-{{DataName}}.lme = lme({{ResponseName}} ~ {{BlockingName}}+{{Factor1Name}}*{{Factor2Name}}, random=1|{{MainPlotID}}, data = {{DataName}})
+{{DataName}}.lme = lme({{ResponseName}} ~ {{BlockingName}}+{{Factor1Name}}*{{Factor2Name}}, random=~1|{{MainPlotID}}, data = {{DataName}})
 library(broom)
 {{DataName}}.lme |> augment()
 {{DataName}}.lme |> anova()

---FILE: man/AddXMLInternal.Rd---
@@ -0,0 +1,7 @@
+\name{AddXMLInternal}
+\alias{.AddXMLAddTitle}
+\title{Internal functions for adding the necessary XML content for accessible graphs in SVG format}
+\description{Mostly internal functions for adding XML content to an external file}
+\details{Not for use as exported functions}
+\value{Either the filename written to, or NULL}
+\author{Volker Sorge and A. Jonathan R. Godfrey}

---FILE: man/BrailleR-package.Rd---
@@ -10,8 +10,8 @@ Improved Access for Blind Users}
 \tabular{ll}{
 Package: \tab BrailleR\cr
 Type: \tab Package\cr
-Version: \tab 0.99.0 \cr
-Date: \tab 2023-02-15\cr
+Version: \tab 1.0.0 \cr
+Date: \tab 2023-07-01\cr
 License: \tab GPL-2\cr
 }
 }

---FILE: man/R2txtJG.Rd---
@@ -87,7 +87,7 @@ The txtOut function is a short cut for the txtStart command that uses the curren
 	 output.  Use the \code{txtComment} functions to add a comment.  This will show up as a line offset
 	 by whitespace in the transcript file.
 	 If \code{cmdtxt} is specified then that line
-	 will be inserted into \code{cmdfile} preceded by a \# so it
+	 will be inserted into \code{cmdfile} preceded by a hash symbol  so it
 	 will be skipped if sourced or copied.
 
 	 The \code{txtSkip}  function will run the"
ajrgodfrey,BrailleR,d9be5385fb9db372518a712becb8bb3a3870c600,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-17T07:00:40Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-17T07:00:40Z,v0.99.0 late fixes before major release,R/FindReplace.R;R/SVGThis.R;R/SpellCheck.R;R/VIInternals.R;R/ViewSVG.R;R/Warnings.R,False,True,True,False,9,10,19,"---FILE: R/FindReplace.R---
@@ -1,7 +1,7 @@
 FindReplace =
     function(file, find, replace) {
       if (file.exists(file)) {
-        cat(""\n"", file = file, append = TRUE)  # otherwise warnings returned on
+        cat(""\n"", file = file, append = TRUE)  # otherwise problems on
                                                # readLines() below
         OldText <- readLines(con = file)
         NoLines = length(OldText)

---FILE: R/SVGThis.R---
@@ -21,7 +21,7 @@
 .MakeTigerReady <-
   function(svgfile) { # for alterations needed on all SVG files
     if (file.exists(svgfile)) {
-      cat(""\n"", file = svgfile, append = TRUE) # otherwise warnings returned
+      cat(""\n"", file = svgfile, append = TRUE) # otherwise problems 
       # on readLines() below
       temp <- readLines(con = svgfile)
       writeLines(gsub(""ISO8859-1"", ""ASCII"", temp), con = svgfile)
@@ -53,7 +53,7 @@ SVGThis.default <-
         # no specific processing to be done in this function.
       } # end open device condition
       else { # no current device
-        warning(""There is no current graphics device to convert to SVG.\n"")
+        .NoGraphicsDevice(""to convert to SVG."")
       }
     } # end interactive condition
     else { # not interactive session

---FILE: R/SpellCheck.R---
@@ -6,9 +6,8 @@ SpellCheck =
           cat(paste0(ThisFile, "": ""))
           if (file.exists(ThisFile)) {
             file.copy(ThisFile, paste0(ThisFile, "".bak""), overwrite = FALSE)
-            cat(""\n"", file = ThisFile, append = TRUE)  # otherwise warnings
-                                                       # returned on readLines()
-                                                       # below
+            cat(""\n"", file = ThisFile, append = TRUE)  # otherwise problems 
+                                                       # on readLines() below
             OldText <- readLines(con = ThisFile)
             Mistakes = SpellCheckFiles(file = ThisFile)
             for (i in names(Mistakes[[1]])) {

---FILE: R/VIInternals.R---
@@ -446,4 +446,4 @@
 ## Tests if the given axis is the theta axis
 .isGGAxisTheta = function(x, axis) {
   x$coordinates$theta == axis
-}
\ No newline at end of file
+}

---FILE: R/ViewSVG.R---
@@ -40,4 +40,4 @@ ViewSVG = function(file = ""index""){
     }
   }
   svgHTMLFiles
-}
\ No newline at end of file
+}

---FILE: R/Warnings.R---
@@ -82,8 +82,8 @@ warning(""There was a problem and no conversion was possible."")
 return(invisible(NULL))
 }
 
-.NoGraphicsDevice =     function() {
-warning(""There is no current graphics device to investigate."")
+.NoGraphicsDevice =     function(Text=""to investigate."") {
+warning(""There is no current graphics device"", Text)
 return(invisible(NULL))
 }
 "
ajrgodfrey,BrailleR,8e95fd94893f7cc61285d92707905debca430dc3,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-16T08:50:10Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-16T08:50:10Z,v0.99.0 late fixes before major release,DESCRIPTION;NAMESPACE,False,False,False,False,0,5,5,"---FILE: DESCRIPTION---
@@ -64,7 +64,6 @@ Imports:
     whisker,
     XML,
     xtable,
-    methods,
     grDevices
 Suggests:
     broom,

---FILE: NAMESPACE---
@@ -23,10 +23,6 @@ importFrom(""utils"", ""browseURL"", ""create.post"", ""download.file"", ""file.edit"", ""h
 importFrom(""whisker"", ""whisker.render"")
 importFrom(""XML"", ""addAttributes"", ""newXMLDoc"", ""newXMLNode"", ""ensureNamespace"", ""newXMLTextNode"", ""xmlName"", ""xmlRoot"", ""saveXML"", ""getNodeSet"", ""xmlGetAttr"", ""addChildren"", ""removeChildren"", ""xmlChildren"")
 importFrom(""xtable"", ""xtable"")
-<<<<<<< HEAD
-importFrom(""grDevices"", ""dev.size"")
-=======
->>>>>>> 0b9cc93d69dd2757e0c93a7f99da02c70e09b2c5
 S3method(AddXML,default)
   S3method(AddXML,boxplot)
   S3method(AddXML,dotplot)"
ajrgodfrey,BrailleR,086b2bba432190331eb0022bc71d1119c3bf3236,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-16T08:16:21Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-16T08:16:21Z,v0.99.0 late fixes before major release,DESCRIPTION;NAMESPACE;NEWS.md,False,False,False,False,5,4,9,"---FILE: DESCRIPTION---
@@ -64,8 +64,7 @@ Imports:
     whisker,
     XML,
     xtable,
-    methods,
-    grDevices
+    methods
 Suggests:
     broom,
     emmeans,

---FILE: NAMESPACE---
@@ -1,9 +1,10 @@
+
 importFrom(""devtools"", ""spell_check"")
 import(dplyr)
 import(extrafont)
 importFrom(""ggplot2"", ""aes"", ""geom_point"", ""geom_smooth"", ""ggplot"", ""ggplot_build"", ""qplot"", ""labs"", ""ylab"", ""xlab"", ""geom_line"") 
 importFrom(""graphics"", ""abline"", ""par"", ""plot"") 
-importFrom(""grDevices"", ""dev.cur"", ""dev.list"", ""pdf"") 
+importFrom(""grDevices"", ""dev.cur"", ""dev.list"", ""pdf"")
 import(grid)
 import(gridGraphics)
 importFrom(""gridSVG"", ""dev.off"", ""elementGrob"", ""textNodeGrob"")
@@ -23,7 +24,6 @@ importFrom(""whisker"", ""whisker.render"")
 importFrom(""XML"", ""addAttributes"", ""newXMLDoc"", ""newXMLNode"", ""ensureNamespace"", ""newXMLTextNode"", ""xmlName"", ""xmlRoot"", ""saveXML"", ""getNodeSet"", ""xmlGetAttr"", ""addChildren"", ""removeChildren"", ""xmlChildren"")
 importFrom(""xtable"", ""xtable"")
 importFrom(""grDevices"", ""dev.size"")
-importFrom(""methods"", ""is"")
 S3method(AddXML,default)
   S3method(AddXML,boxplot)
   S3method(AddXML,dotplot)

---FILE: NEWS.md---
@@ -1,6 +1,8 @@
 # BrailleR 0.99.0
 - did some cleaning up to de-clutter, check examples, add documentation, and all the good things that must be done prior to v1.0.0
 - removed dependency on magrittr as now using native pipe
+- removed rlang as a dependency; redundant for some time probably
+- removed other dependencies (on base packages) from imports
 
 
 # BrailleR 0.33.4"
ajrgodfrey,BrailleR,dbb474f0963b9b028f0fa92c45f36764092c391d,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-16T07:37:29Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-16T07:37:29Z,v0.99.0 late fixes before major release,DESCRIPTION;NAMESPACE,False,False,False,False,0,2,2,"---FILE: DESCRIPTION---
@@ -57,7 +57,6 @@ Imports:
     moments,
     quarto,
     Rdpack,
-    rlang,
     rmarkdown,
     roloc,
     rolocISCCNBS,

---FILE: NAMESPACE---
@@ -13,7 +13,6 @@ import(mathjaxr)
 importFrom(""moments"", ""skewness"")
 importFrom(""quarto"", ""quarto_path"")
 importFrom(""Rdpack"",""reprompt"")
-importFrom(""rlang"", ""is_true"")
 import(rmarkdown)
 import(roloc)
 import(rolocISCCNBS)"
ajrgodfrey,BrailleR,90455798731ae486c20c54be0770c80095ec9f49,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-16T06:35:22Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-16T06:35:22Z,v0.99.0 late fixes before major release,R/Options.R;vignettes/qplot.Rmd,True,True,True,False,1,2,3,"---FILE: R/Options.R---
@@ -379,7 +379,7 @@ GoNovice =
 ViewOn = function() {
            options(BrailleR.View = TRUE)
            .ViewOnMSG()
-           return(invisble(NULL))
+           return(invisible(NULL))
          }
 
 ViewOff =

---FILE: vignettes/qplot.Rmd---
@@ -19,7 +19,6 @@ commands are included below but commented out.
 ```{r GetLibraries}     
 library(BrailleR)   
 library(ggplot2)   
-library(magrittr)
 dsmall = diamonds[1:100,]   
 ```  
 "
ajrgodfrey,BrailleR,18cf64a0f7d15e2564af59440b3d1bdf6c30bff8,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-16T06:23:28Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-16T06:23:28Z,v0.99.0 late fixes before major release,R/PandocAll.R,False,True,True,False,1,4,5,"---FILE: R/PandocAll.R---
@@ -6,11 +6,8 @@ for(i in FileList){
 Outfile = sub(paste0(""."", intype), paste0(""."", outtype),  i)
 if(file.mtime(i) > file.mtime(Outfile)| !file.exists(Outfile)) {
 shell(paste0('pandoc -s ""', i, '"" -o ""', Outfile, '""'))
-.FileUpdated(file=Outfile, where=""in your current working directory.""))
+.FileUpdated(file=Outfile, where=""in your current working directory."")
 }
 }
-
-
-
 return(invisible(TRUE))
 }"
ajrgodfrey,BrailleR,89cd8398bcf860519ef943113f37c93608770a92,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-16T06:13:56Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-16T06:13:56Z,v0.99.0 late fixes before major release,R/Messages.R;R/Options.R;R/PandocAll.R,False,True,True,False,53,17,70,"---FILE: R/Messages.R---
@@ -75,13 +75,44 @@ message(NewFile, "" has been updated "", where)
 return(invisible(NULL))
 }
 
+.GoAdvancedMSG =     function() {
+message(""By going advanced, you have reduced the verbosity of text descriptions of graphs."")
+return(invisible(NULL))
+}
+
+
+.GoBlindMSG =     function() {
+message(""By going blind, you have turned on the automatic generation of text descriptions of graphs."")
+return(invisible(NULL))
+}
+
+.GoNoviceMSG =     function() {
+message(""By going novice, you have returned to receiving all of the automatically generated text descriptions of graphs."")
+return(invisible(NULL))
+}
+
+.GoSightedMSG =     function() {
+message(""By going sighted, you have turned off the automatic generation of text descriptions of graphs."")
+return(invisible(NULL))
+}
 
 
 .InstallPython =     function() {
 message(""You could use GetPython3() and GetWxPython3() to help install them."")
 return(invisible(NULL))
 }
 
+
+.LatexOffMSG =     function() {
+message(""You have turned the automatic generation of LaTeX tables off."")
+return(invisible(NULL))
+}
+
+.LatexOnMSG =     function() {
+message(""You have turned the automatic generation of LaTeX tables on."")
+return(invisible(NULL))
+}
+
 .MoveOntoPath=     function() {
 message(""These files need to be moved to a folder that is on your system path."")
 return(invisible(NULL))
@@ -182,3 +213,14 @@ return(invisible(NULL))
 message(            ""The"", What, ""has been changed to "", To, ""and saved in your settings file."")
 return(invisible(NULL))
 }
+
+
+.ViewOffMSG =     function() {
+message(""You have turned the automatic opening of html pages off."")
+return(invisible(NULL))
+}
+
+.ViewOnMSG =     function() {
+message(""You have turned the automatic opening of html pages on."")
+return(invisible(NULL))
+}

---FILE: R/Options.R---
@@ -320,9 +320,7 @@ SetSigLevel =
     function(alpha, Permanent = interactive(), Local = interactive()) {
       if ((0 < alpha) & (alpha < 1)) {
         options(BrailleR.SigLevel = alpha)
-        message(
-            ""The BrailleR.SigLevel option for the level of alpha has been changed to "",
-            alpha, ""."")
+        .UpdatedSettingMSG(""BrailleR.SigLevel option for the level of alpha"",To=alpha)
         if (Permanent) {
           Prefs = paste0(getOption(""BrailleR.Folder""), ""BrailleROptions"")
           OpSet = as.data.frame(read.dcf(Prefs, all = TRUE))
@@ -350,62 +348,58 @@ SetSigLevel =
 GoSighted =
     function() {
       options(BrailleR.VI = FALSE)
-      message(
-          ""By going sighted, you have turned off the automatic generation of text descriptions of graphs.\n"")
+      .GoSightedMSG()
       return(invisible(NULL))
     }
 
 GoBlind =
     function() {
       options(BrailleR.VI = TRUE)
-      message(
-          ""By going blind, you have turned on the automatic generation of text descriptions of graphs.\n"")
+      .GoBlindMSG()
       return(invisible(NULL))
     }
 
 GoAdvanced =
     function() {
       options(BrailleR.Advanced = TRUE)
-      message(
-          ""By going advanced, you have reduced the verbosity of text descriptions of graphs.\n"")
+      .GoAdvancedMSG()
       return(invisible(NULL))
     }
 
 
 GoNovice =
     function() {
       options(BrailleR.Advanced = FALSE)
-      message(
-          ""By going novice, you have returned to receiving all of the automatically generated text descriptions of graphs.\n"")
+      .GoNoviceMSG()
       return(invisible(NULL))
     }
 
 
 
 ViewOn = function() {
            options(BrailleR.View = TRUE)
-           message(""You have turned the automatic opening of html pages on.\n"")
-           return(invisible(NULL))
+           .ViewOnMSG()
+           return(invisble(NULL))
          }
 
 ViewOff =
     function() {
       options(BrailleR.View = FALSE)
-      message(""You have turned the automatic opening of html pages off.\n\n"")
+      .ViewOffMSG()
       return(invisible(NULL))
     }
 
 LatexOn =
     function() {
       options(BrailleR.Latex = TRUE)
-      message(""You have turned the automatic generation of LaTeX tables on.\n"")
+      .LatexOnMSG()
       return(invisible(NULL))
     }
 
 LatexOff =
     function() {
       options(BrailleR.Latex = FALSE)
-      message(""You have turned the automatic generation of LaTeX tables off.\n"")
+      .LatexOffMSG()
       return(invisible(NULL))
     }
 

---FILE: R/PandocAll.R---
@@ -6,7 +6,7 @@ for(i in FileList){
 Outfile = sub(paste0(""."", intype), paste0(""."", outtype),  i)
 if(file.mtime(i) > file.mtime(Outfile)| !file.exists(Outfile)) {
 shell(paste0('pandoc -s ""', i, '"" -o ""', Outfile, '""'))
-message(paste(""File"", i, ""converted to"", Outfile))
+.FileUpdated(file=Outfile, where=""in your current working directory.""))
 }
 }
 "
ajrgodfrey,BrailleR,ca82044d2981ce3573a6657f46e3873877613a01,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-16T05:43:52Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-16T05:43:52Z,v0.99.0 late fixes before major release,DESCRIPTION;NAMESPACE;NEWS.md,False,False,False,False,1,2,3,"---FILE: DESCRIPTION---
@@ -53,7 +53,6 @@ Imports:
     gridSVG,
     hunspell,
     knitr,
-    magrittr,
     mathjaxr,
     moments,
     quarto,

---FILE: NAMESPACE---
@@ -9,7 +9,6 @@ import(gridGraphics)
 importFrom(""gridSVG"", ""dev.off"", ""elementGrob"", ""textNodeGrob"")
 importFrom(""hunspell"", ""hunspell"")
 import(knitr)
-import(magrittr)
 import(mathjaxr)
 importFrom(""moments"", ""skewness"")
 importFrom(""quarto"", ""quarto_path"")

---FILE: NEWS.md---
@@ -1,5 +1,6 @@
 # BrailleR 0.99.0
 - did some cleaning up to de-clutter, check examples, add documentation, and all the good things that must be done prior to v1.0.0
+- removed dependency on magrittr as now using native pipe
 
 
 # BrailleR 0.33.4"
ajrgodfrey,BrailleR,3000f5a918562d9aa4d7e17368aa789eb763ad02,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-16T04:49:17Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-16T04:49:17Z,v0.99.0 late fixes before major release,R/Options.R,False,True,True,False,1,1,2,"---FILE: R/Options.R---
@@ -293,7 +293,7 @@ SetPValDigits =
       digits = as.integer(digits)
       if (digits > 1) {
         options(BrailleR.PValDigits = digits)
-        .UpdatedSettingMSG(What=""BrailleR.PValDigits option for the number of decimal places to display for p values"", To=digits))
+        .UpdatedSettingMSG(What=""BrailleR.PValDigits option for the number of decimal places to display for p values"", To=digits)
         if (Permanent) {
           Prefs = paste0(getOption(""BrailleR.Folder""), ""BrailleROptions"")
           OpSet = as.data.frame(read.dcf(Prefs, all = TRUE))"
ajrgodfrey,BrailleR,bb62a82f9fadf53983a5a86566b8285ae5c7fc4b,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-16T04:47:14Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-16T04:47:14Z,v0.99.0 late fixes before major release,R/Describe.R;R/GettingStarted.R;R/MakeQmdFiles.R;R/MakeRmdFiles.R;R/MakeSlideShow.R;R/Messages.R;R/Options.R;R/VIMethod1_JG.R;R/Warnings.R;R/dotplots.R,False,True,True,False,62,49,111,"---FILE: R/Describe.R---
@@ -135,7 +135,7 @@ Describe.ggplot <-
       return(NULL)
       # No available description
     } else if (length(descriptions) == 0) {
-      warning(""None of you selected layers have a description yet."")
+      warning(""None of your selected layers have a description yet."")
       return(NULL)
       # Only one description
     } else {

---FILE: R/GettingStarted.R---
@@ -1,21 +1,18 @@
 GetGoing =
     function() {
       if (interactive()) {
-        .AnswerQuestions()
+        .AnswerQuestionsMSG()
 
-        .AuthorName()
+        .AuthorNameMSG()
         name = readLines(n = 1)
         if (name != """") SetAuthor(name)
 
-        message(
-            ""\nHow many decimal places do you wish p values to be rounded to? ("",
-            getOption(""BrailleR.PValDigits""), "")\n"")
+        .PValueDigitsMSG()
+
         digits = as.numeric(readLines(n = 1))
         if (!is.na(digits)) SetSigLevel(digits)
 
-        message(
-            ""\nWhat is the level of significance you plan to use as your default? ("",
-            getOption(""BrailleR.SigLevel""), "")"")
+        .DefaultSignificanceMSG()
        alpha = as.numeric(readLines(n = 1))
         if (!is.na(alpha)) SetSigLevel(alpha)
 

---FILE: R/MakeQmdFiles.R---
@@ -39,7 +39,7 @@ R2Qmd =
             file = QmdFile)
         cat(paste0(""\n"", Lines, ""  ""), file = QmdFile, append = TRUE)
         cat(""\n# end of input  \n```  \n\n"", file = QmdFile, append = TRUE)
-        .NewFile()
+        .NewFile(file = QmdFile)
         return(QmdFile)
       } else {
         .FileDoesNotExist(file)

---FILE: R/MakeRmdFiles.R---
@@ -11,7 +11,7 @@ opts_chunk$set(comment="""", fig.cap=""to fix"")
 ```\n\n'), file = file)
         cat(paste0(""```{r line"", LineNo, ""}  \n"", Lines, ""\n```  \n\n""),
             file = file, append = TRUE)
-        .NewFile()
+        .NewFile(file = file)
         return(file)
       } else {
         .InteractiveOnly()
@@ -37,7 +37,7 @@ R2Rmd =
             file = RmdFile)
         cat(paste0(""\n"", Lines, ""  ""), file = RmdFile, append = TRUE)
         cat(""\n# end of input  \n```  \n\n"", file = RmdFile, append = TRUE)
-        .NewFile()
+        .NewFile(file = RmdFile)
         return(RmdFile)
       } else {
         .FileDoesNotExist()

---FILE: R/MakeSlideShow.R---
@@ -35,7 +35,7 @@ MakeAllInOneSlide =
 
         }  # end css file condition
             else {
-          warning(""Cannot find the specified css file."")
+          ## war ning(""Cannot find the specified css file."")
         }
       }  # end folder existence condition
           else {
@@ -133,7 +133,7 @@ MakeSlideShow =
 
         }  # end css file condition
             else {
-          warning(""Cannot find the specified css file."")
+          ## war ning(""Cannot find the specified css file."")
         }
       }  # end folder existence condition
           else {

---FILE: R/Messages.R---
@@ -11,12 +11,12 @@ return(invisible(NULL))
 }
 
 
-        .AnswerQuestions=function(){
+.AnswerQuestionsMSG = function(){
 message(""You will be asked to enter answers for a series of questions.Hit <enter> to use the default shown in parentheses."")
 return(invisible(NULL))
 }
 
-.AuthorName =     function() {
+.AuthorNameMSG =     function() {
 message(""Enter the name you want to use for authoring content. ("",
                 getOption(""BrailleR.Author""), "")"")
 return(invisible(NULL))
@@ -46,6 +46,11 @@ message(""Consult the help page for guidance on using these files in Windows Expl
 return(invisible(NULL))
 }
 
+.DefaultSignificanceMSG =     function() {
+message(""What is the level of significance you plan to use as your default? ("",
+getOption(""BrailleR.SigLevel""), "")"")
+return(invisible(NULL))
+}
 
 .DeleteAnytime  = function(){
 message(""You can delete it at any time, but that will not uninstall the application."")
@@ -107,7 +112,7 @@ return(invisible(NULL))
 }
 
 .NoVIMethod =     function() {
-      message(""There is no specific method written for  this type of object."")
+message(""There is no specific method written for  this type of object."")
 message(""You might try to use the print() function on the object or the str() command to investigate its contents."")
 return(invisible(NULL))
 }
@@ -119,7 +124,7 @@ return(invisible(NULL))
 }
 
 .OptionPermanent =     function() {
-message(""and has overwritten the setting for all folders."")
+message(""This has overwritten the setting for all folders."")
 return(invisible(NULL))
 }
 
@@ -137,6 +142,12 @@ return(invisible(NULL))
 }
 
 
+
+.PValueDigitsMSG =     function() {
+message(""How many decimal places do you wish p values to be rounded to? ("", getOption(""BrailleR.PValDigits""), "")"")
+return(invisible(NULL))
+}
+
 .PythonVersion =     function() {
 VersionString = system2(""python"", ""--version"", stdout=TRUE, stderr=TRUE)
 message(""Your system is using "", VersionString, """")
@@ -165,3 +176,9 @@ return(invisible(NULL))
 }
 
 
+
+
+.UpdatedSettingMSG =     function(What, To) {
+message(            ""The"", What, ""has been changed to "", To, ""and saved in your settings file."")
+return(invisible(NULL))
+}

---FILE: R/Options.R---
@@ -168,8 +168,7 @@ SetBRLPointSize =
           .OptionLocal()
         }
       } else {
-        warning(
-            ""The point size must be between 10 and 40 . \nNo change has been made to this setting.\n"")
+        .NoChangeWarning(""The point size must be between 10 and 40 ."")
       }
       return(invisible(NULL))
     }
@@ -209,9 +208,8 @@ SetMakeUpper =
       Upper = as.logical(Upper)
       if (is.logical(Upper)) {
         options(BrailleR.MakeUpper = Upper)
-        message(
-            ""The BrailleR.MakeUpper option for capitalising the initial letter of variable names has been changed to "",
-            Upper, ""."")
+        .UpdatedSettingMSG(What=""BrailleR.MakeUpper option for capitalising the initial letter of variable names"", To=Upper) 
+
         if (Permanent) {
           Prefs = paste0(getOption(""BrailleR.Folder""), ""BrailleROptions"")
           OpSet = as.data.frame(read.dcf(Prefs, all = TRUE))
@@ -229,8 +227,7 @@ SetMakeUpper =
           .OptionLocal()
         }
       } else {
-        warning(
-            ""The option must be either TRUE or FALSE.\nNo change has been made to this setting.\n"")
+        .NoChangeWarning()
       }
       return(invisible(NULL))
     }
@@ -239,9 +236,7 @@ SetPaperHeight =
     function(Inches, Permanent = FALSE, Local = interactive()) {
       if ((5 < Inches) & (Inches < 14)) {
         options(BrailleR.PaperHeight = Inches)
-        message(
-            ""The BrailleR.PaperHeight option for the height of the embossed images has been changed to "",
-            Inches, "" inches."")
+        .UpdatedSettingMSG(What = ""BrailleR.PaperHeight option for the height of the embossed images"", To=paste(Inches, ""inches""))
         if (Permanent) {
           Prefs = paste0(getOption(""BrailleR.Folder""), ""BrailleROptions"")
           OpSet = as.data.frame(read.dcf(Prefs, all = TRUE))
@@ -259,8 +254,7 @@ SetPaperHeight =
           .OptionLocal()
         }
       } else {
-        warning(
-            ""The height must be between 5 and 14 inches. \nNo change has been made to this setting.\n"")
+        .NoChangeWarning(""The height must be between 5 and 14 inches."")
       }
       return(invisible(NULL))
     }
@@ -269,9 +263,7 @@ SetPaperWidth =
     function(Inches, Permanent = FALSE, Local = interactive()) {
       if ((5 < Inches) & (Inches < 14)) {
         options(BrailleR.PaperWidth = Inches)
-        message(
-            ""The BrailleR.PaperWidth option for the width of the embossed images has been changed to "",
-            Inches, "" inches."")
+        .UpdatedSettingMSG(What=""BrailleR.PaperWidth option for the width of the embossed images"", To=paste(Inches, ""inches""))
         if (Permanent) {
           Prefs = paste0(getOption(""BrailleR.Folder""), ""BrailleROptions"")
           OpSet = as.data.frame(read.dcf(Prefs, all = TRUE))
@@ -289,8 +281,7 @@ SetPaperWidth =
           .OptionLocal()
         }
       } else {
-        warning(
-            ""The width must be between 5 and 14 inches. \nNo change has been made to this setting.\n"")
+        .NoChangeWarning(""The width must be between 5 and 14 inches."")
       }
       return(invisible(NULL))
     }
@@ -302,9 +293,7 @@ SetPValDigits =
       digits = as.integer(digits)
       if (digits > 1) {
         options(BrailleR.PValDigits = digits)
-        message(
-            ""The BrailleR.PValDigits option for the number of decimal places to display for p values has been changed to "",
-            digits, ""."")
+        .UpdatedSettingMSG(What=""BrailleR.PValDigits option for the number of decimal places to display for p values"", To=digits))
         if (Permanent) {
           Prefs = paste0(getOption(""BrailleR.Folder""), ""BrailleROptions"")
           OpSet = as.data.frame(read.dcf(Prefs, all = TRUE))
@@ -322,8 +311,7 @@ SetPValDigits =
           .OptionLocal()
         }
       } else {
-        warning(
-            ""The number of digits must be an integer greater than one.\nNo change has been made to this setting.\n"")
+        .NoChangeWarning(""The number of digits must be an integer greater than one"")
       }
       return(invisible(NULL))
     }
@@ -352,8 +340,7 @@ SetSigLevel =
           .OptionLocal()
         }
       } else {
-        warning(
-            ""The level of alpha must be between 0 and 1. \nNo change has been made to this setting.\n"")
+        .NoChangeWarning(""The level of alpha must be between 0 and 1."")
       }
       return(invisible(NULL))
     }

---FILE: R/VIMethod1_JG.R---
@@ -101,8 +101,7 @@ VI.dotplot =
       cat(paste0('This graph has ', x$dotplots, ' printed ', x$VertHorz, '\n',
                  .getGraphName(x), '\n'))
       if (!is.null(x$ExtraArgs$dlab) | !is.null(x$ExtraArgs$glab)) {
-        warning(
-            ""Use of dlab or glab arguments is not advised. Use xlab and ylab instead."")
+        .OldCodeWarning(Old=""dlab or glab arguments"", New = ""xlab and ylab "")
       } else {
         cat(paste0(ifelse(length(x$ExtraArgs$xlab) > 0, InQuotes(x$ExtraArgs$xlab), 'No label'),
                    ' appears on the x-axis.\n',

---FILE: R/Warnings.R---
@@ -71,6 +71,12 @@ return(invisible(NULL))
 }
 
 
+
+.NoChangeWarning =     function(text=""The option must be either TRUE or FALSE."") {
+warning(text, ""\nNo change has been made to this setting."")
+return(invisible(NULL))
+}
+
 .NoConversion =     function() {
 warning(""There was a problem and no conversion was possible."")
 return(invisible(NULL))
@@ -81,7 +87,16 @@ warning(""There is no current graphics device to investigate."")
 return(invisible(NULL))
 }
 
+.NotBaseRWarning =     function(text = """") {
+warning(text, ""and is not a base R function."")
+return(invisible(NULL))
+}
+
 
+.OldCodeWarning =     function(Old="""", New="""") {
+warning(""Use of "", Old, ""is not advised. Use"", New, ""instead."")
+return(invisible(NULL))
+}
 
 
 .OverWriteNeeded =     function(file=NULL) {
@@ -96,7 +111,7 @@ return(invisible(NULL))
 }
 
 .TempUnavailable =     function() {
-message(""This command is temporarily unavailable."")
+warning(""This command is temporarily unavailable."")
 return(invisible(NULL))
 }
 

---FILE: R/dotplots.R---
@@ -4,8 +4,7 @@ dotplot = function(x, ...) {
 
 dotplot.default =
     function(x, ...) {
-      warning(
-          ""The dotplot command is a wrapper for stripchart, and is not a base R function."")
+      .NotBaseRWarning(""The dotplot command is a wrapper for stripchart,"")
       MC <- match.call(expand.dots = TRUE)
       MC[[1L]] <- quote(graphics::stripchart)
       names(MC)[2] = """"
@@ -33,8 +32,7 @@ dotplot.default =
 
 dotplot.formula =
     function(x, ...) {
-      warning(
-          ""The dotplot command is a wrapper for stripchart, and is not a base R function."")
+      .NotBaseRWarning(""The dotplot command is a wrapper for stripchart,"")
       MC <- match.call(expand.dots = TRUE)
       MC[[1L]] <- quote(graphics::stripchart)
       names(MC)[2] = """""
ajrgodfrey,BrailleR,d95e9e1686178f530ac324627f3d9f5d76742f48,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-15T23:42:48Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-15T23:42:48Z,v0.99.0 late fixes before major release,DESCRIPTION;NEWS.md,False,False,False,False,3,1,4,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: BrailleR
 Title: Improved Access for Blind Users
-Version: 0.33.4
+Version: 0.99.0
 Authors@R: c(
     person(""A. Jonathan R."", ""Godfrey"", , ""a.j.godfrey@massey.ac.nz"", role = c(""aut"", ""cre""),
     comment = c(ORCID = ""0000-0002-8129-8835"")),

---FILE: NEWS.md---
@@ -1,4 +1,6 @@
 # BrailleR 0.99.0
+- did some cleaning up to de-clutter, check examples, add documentation, and all the good things that must be done prior to v1.0.0
+
 
 # BrailleR 0.33.4
 - fix issue #35 with incorrect bin counts"
ajrgodfrey,BrailleR,f31868e69b0baf1adf752d4a6999161d340574cb,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-15T23:29:15Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-02-15T23:29:15Z,v0.99.0 late fixes before major release,NEWS.md;man/BrailleR-package.Rd,False,False,False,False,4,2,6,"---FILE: NEWS.md---
@@ -1,3 +1,5 @@
+# BrailleR 0.99.0
+
 # BrailleR 0.33.4
 - fix issue #35 with incorrect bin counts
 - fix issue #24, correcting base r plot titles in VI

---FILE: man/BrailleR-package.Rd---
@@ -10,8 +10,8 @@ Improved Access for Blind Users}
 \tabular{ll}{
 Package: \tab BrailleR\cr
 Type: \tab Package\cr
-Version: \tab 0.33.2 \cr
-Date: \tab 2022-07-09\cr
+Version: \tab 0.99.0 \cr
+Date: \tab 2023-02-15\cr
 License: \tab GPL-2\cr
 }
 }"
ajrgodfrey,BrailleR,c09fab60c49d67295945cbf4d09b04c48c0109f2,James,1jamesthompson1@gmail.com,2023-02-14T23:07:13Z,James,1jamesthompson1@gmail.com,2023-02-14T23:07:13Z,"Fix problems

Add pakcage referneces to function calls

Updathe titleGrob grid.grep location in the AddXML.ggplot function",R/AddXMLInternal.R;R/AddXMLMethod.R,False,True,True,False,3,3,6,"---FILE: R/AddXMLInternal.R---
@@ -145,7 +145,7 @@
     lapply(function(indexs) {
       data |>
         dplyr::slice(indexs) |>
-        drop_na(x, y) |>
+        tidyr::drop_na(x, y) |>
         dplyr::distinct() |>
         FUN()
     })
@@ -177,7 +177,7 @@
 .AddXMLAddGGPlotLayer.point <- function(root, layerRoot, graphObjectStruct, geomID, panel = 1, summarisedSections = 5, ...) {
   # Rmeove all the NAs in the data
   data <- graphObjectStruct$data |>
-    drop_na(x, y)
+    tidyr::drop_na(x, y)
 
   numberOfPoints <- nrow(data)
 

---FILE: R/AddXMLMethod.R---
@@ -80,7 +80,7 @@ AddXML.ggplot <- function(x, file) {
   components <- list()
 
   backgroundGrob <- grid.grep(gPath(""panel.background..rect""), grep = TRUE)
-  titleGrob <- grid.grep(gPath(""title"", ""text""), grep = TRUE)
+  titleGrob <- grid.grep(gPath(""plot.title"", ""text""), grep = TRUE)
   if (length(titleGrob) > 0) {
     titleId <- paste0(titleGrob$name, "".1"")
     title <- .AddXMLAddTitle(annotations, title = xs$title, id = titleId)"
ajrgodfrey,BrailleR,08b6cdd1602352b590158093e519e2fc24c7c595,James,1jamesthompson1@gmail.com,2023-02-09T03:37:56Z,James,1jamesthompson1@gmail.com,2023-02-09T03:37:56Z,"0.33.4 Add support for multilayer ggplot SVGs

geomLine, geomPoint, geomSmooth and geomBar should work for all sorts of
multilayer ggplots

These are a bunch of squashed commits.
There was some work to rewrite part of hoe the MakeAccessibleSVG works.

Hopefully some refactoring work gets done shrotly to help make future
dev work easier.

commit 1234ccbff1a7faa0379c940e968cdd4451a32bb6
Author: James <1jamesthompson1@gmail.com>
Date:   Thu Feb 9 15:57:51 2023 +1300

    Fix up small errors with types in AddXMLInternal and the BrowseSVg that were causing them to not function correctly.

commit 9b43759b32d1fcdd8eaf92de6a9e0782d28b05d4
Author: James <1jamesthompson1@gmail.com>
Date:   Thu Feb 9 15:02:37 2023 +1300

    Fix up geom_point support of NA values

commit d5ba4ac098dd040b912fb58bbe6748ec3c264d97
Author: James <1jamesthompson1@gmail.com>
Date:   Wed Feb 8 21:21:37 2023 +1300

    Add support for geom_line to have disjoints lines.

commit 9d86eb4d0f71e39ee57ec56f28ebb0e5cff2a910
Author: James <1jamesthompson1@gmail.com>
Date:   Fri Feb 3 19:53:43 2023 +1300

    Add support for goem_bar to be multi layered

    In this process found some errors with geom_line.

    This is with the dijointed lines. I will need to work on that now.

commit 7aba33150fab0736deaff32e8b25bc10661ddd15
Author: James <1jamesthompson1@gmail.com>
Date:   Fri Feb 3 16:43:09 2023 +1300

    Update geom_smooth to work with multi layers

    This has had a few changes here and there however it was quite a smooth process. I have also added in a .CreateID function. This means that anytime you want create a ID reference for hte svg or the xml you use this function. However it isnt used much yet and I will need to do a fancy regex find and replace to fix this issue.

commit babfd989ccd1f36645f316169e52fd361e97dac8
Author: James <1jamesthompson1@gmail.com>
Date:   Fri Feb 3 14:46:42 2023 +1300

    Update MakeAccessibleSVg to be more supportive of multiple layers. Add full support for geom_line and multiple layers.

    There was a significant rewrite of how the getGeomID works. This makes it take into account for layers in a way that should work for all sorts of multi layer plots.",R/AddXMLInternal.R;R/AddXMLMethod.R;R/BrowseSVG.R;R/MakeAccessibleSVGInternal.R;R/RewriteSVG.R;R/SVGThis.R,False,True,True,False,304,159,463,"---FILE: R/AddXMLInternal.R---
@@ -125,20 +125,22 @@
 }
 
 ## Constructs a ggplot layer
-.AddXMLAddGGPlotLayer <- function(root, x = NULL, panel = 1, summarisedSections = 5) {
+.AddXMLAddGGPlotLayer <- function(root, x = NULL, graphObject, panel = 1, summarisedSections = 5) {
   # Functions used within this function
-  summariseLayer <- function(data, FUN = function(x) x) {
-    .SplitData(seq_along(data$x)) |>
+  summariseLayer <- function(data, FUN = function(x) x, overlap = FALSE) {
+    .SplitData(seq_along(data$x), overlapping = overlap) |>
       lapply(function(indexs) {
         data |>
           dplyr::slice(indexs) |>
+          drop_na(x, y) |>
+          dplyr::distinct() |>
           FUN()
       })
   }
 
   layerGroupID <- paste(""center"", panel, x$layernum, sep = ""-"")
   annotation <- .AddXMLAddAnnotation(root,
-    position = 4,
+    position = 3 + x$layernum,
     id = layerGroupID, kind = ""grouped""
   )
   # TODO:  For all layer types:  need heuristic to avoid trying to describe
@@ -148,44 +150,44 @@
   data <- x$data
   if (x$type == ""bar"") { # Bar chart
     barCount <- nrow(x$data)
-    barGrob <- grid.grep(gPath(""geom_rect""), grep = TRUE)
+    barGeomID <- .GetGeomID(graphObject, x$layernum)
     XML::addAttributes(annotation$root,
-      speech = ""Histogram bars"",
-      speech2 = paste(""Histogram with"", barCount, ""bars""),
+      speech = ""Bar graph"",
+      speech2 = paste(""Bar graph with"", barCount, ""bars""),
       type = ""Center""
     )
-    chartData <- x$data
+
     for (i in 1:barCount) {
-      barId <- paste(barGrob$name, ""1"", i, sep = ""."")
+      barId <- .CreateID(barGeomID, i)
       # TODO: histogram bars have density but other geom_bar objects won't
       # Need to not fail if density not present
       # Generally, need to deal with missing values better
 
       # If no density values then assume it's a categorical x-axis
-      if (is.null(chartData$density)) {
+      if (is.null(data$density)) {
         annotations[[i]] <- .AddXMLcategoricalBar(
           root,
           position = i,
-          x = signif(chartData$x[i], 4),
-          count = chartData$ymax[i] - chartData$ymin[i],
+          x = signif(data$x[i], 4),
+          count = data$ymax[i] - data$ymin[i],
           id = barId
         )
       } else {
         annotations[[i]] <- .AddXMLcenterBar(
           root,
           position = i,
-          mid = signif(chartData$x[i], 4),
-          count = chartData$ymax[i] - chartData$ymin[i],
-          density = ifelse(is.null(chartData$density), NA, chartData$density[i]),
-          start = signif(chartData$xmin[i], 4),
-          end = signif(chartData$xmax[i], 4),
+          mid = signif(data$x[i], 4),
+          count = data$ymax[i] - data$ymin[i],
+          density = ifelse(is.null(data$density), NA, data$density[i]),
+          start = signif(data$xmin[i], 4),
+          end = signif(data$xmax[i], 4),
           id = barId
         )
       }
     }
   } else if (x$type == ""line"") { # Line chart
     numberOfLines <- length(x$lines)
-    lineGrobName <- .GetGeomID.GeomLine()
+    lineGrobName <- .GetGeomID(graphObject, x$layernum)
     XML::addAttributes(annotation$root,
       speech = ""Line graph"",
       speech2 = paste(""Line graph with"", numberOfLines, ""lines""),
@@ -196,9 +198,8 @@
 
     for (lineNum in 1:numberOfLines) {
       lineData <- x$lines[[lineNum]]$scaledata
-      lineCount <- nrow(lineData) - 1
+      disjointLine <- .IsGeomLineDisjoint(lineData)
 
-      segmentAnnotations <- list()
       # ID of the line g tag
       lineGTagID <- paste(lineGrobName, lineNum, sep = ""."")
 
@@ -209,87 +210,162 @@
       )
       XML::addAttributes(lineGTagAnnotation$root,
         speech = paste(""Line"", lineNum),
-        speech2 = paste(""Line"", lineNum, ""with"", lineCount, ""segments""),
+        speech2 = ifelse(disjointLine,
+          paste(""Line"", lineNum, ""is disjoint""),
+          paste(""Line"", lineNum, ""with"", lineData$x |> length() - 1, ""segments"")
+        ),
         type = ""Center""
       )
 
+      segmentAnnotations <- list()
 
-      # Summarizing the data
-      if (lineCount > summarisedSections) {
-        slope_Range_Median <- summariseLayer(lineData, function(data) {
-          data |>
-            dplyr::mutate(startX = x, endX = lead(x), startY = y, endY = lead(y)) |>
-            tidyr::drop_na() |>
-            dplyr::select(matches(""(start|end)\\w"")) |>
-            dplyr::mutate(slope = (startY - endY) / (startX - endX)) |>
-            dplyr::summarise(min = min(slope), max = max(slope), mean = mean(slope)) |>
-            as.list()
-        })
-        summarised <- TRUE
-        lineCount <- summarisedSections
+      # Test if the lineData has na and by extension if there will be disjointness
+      if (disjointLine) {
+        # This bit of code was made iwth help from SO:
+        # https://stackoverflow.com/questions/75379649/split-a-df-into-a-list-with-groups-of-values-withouts-nas
+        disjointLines <- lineData |>
+          group_by(group = cumsum(is.na(y))) |>
+          filter(!(is.na(y) & n() > 1)) |>
+          group_split() |>
+          Filter(function(x) nrow(x) >= 2, x = _)
+
+        numOfDisjointLines <- length(disjointLines)
+        lineSeq <- seq_along(disjointLines)
       } else {
-        summarised <- FALSE
+        lineSeq <- c(1)
       }
 
-      # Getting this data so that I can get the starts and finishes of the line groups
-      breaks <- seq(min(data$x), max(data$x), length.out = summarisedSections + 1)
-      mins <- breaks[1:(summarisedSections)]
-      maxs <- breaks[2:(summarisedSections + 1)]
-      for (i in 1:(lineCount)) {
-        if (summarised) {
-          desc <- paste(
-            ""slope range"",
-            .AddXMLFormatNumber(slope_Range_Median[[i]]$min),
-            ""to"",
-            .AddXMLFormatNumber(slope_Range_Median[[i]]$max),
-            ""with mean"",
-            .AddXMLFormatNumber(slope_Range_Median[[i]]$mean)
-          )
-          desc2 <- paste(
-            ""x from "",
-            lineData$x[lineData$x >= mins[i]][1],
-            ""to"",
-            lineData$x[lineData$x < maxs[i]] |> tail(n = 1),
-            ""y from "",
-            lineData$y[lineData$x >= mins[i]][1],
-            ""to"",
-            lineData$y[lineData$x < maxs[i]] |> tail(n = 1)
-          )
-        } else {
-          desc <- paste(
-            .AddXMLFormatNumber((lineData$y[i + 1] - lineData$y[i]) / (lineData$x[i + 1] - lineData$x[i])),
-            ""slope from x"",
-            .AddXMLFormatNumber(lineData$x[i]),
-            ""to x"",
-            .AddXMLFormatNumber(lineData$x[i + 1])
-          )
-          desc2 <- paste0(
-            ""line from ("",
-            .AddXMLFormatNumber(lineData$x[i]),
-            "","",
-            .AddXMLFormatNumber(lineData$y[i]),
-            "") to ("",
-            .AddXMLFormatNumber(lineData$x[i + 1]),
-            "","",
-            .AddXMLFormatNumber(lineData$y[i + 1]),
-            "")""
-          )
-        }
 
-        segmentAnnotations[[i]] <- .AddXMLLine(root, position = i, id = paste(lineGTagID, letters[i], sep = "".""), speech = desc, speech2 = desc2)
-        # TODO:  Not correctly handling NA or out-of-range data values, nor dates
-        # Should check for dates with inherit(,""Date"") -- but looks like I
-        # need to do that on the main data not the layer data
+      if (disjointLine && numOfDisjointLines == 0) {
+        segmentAnnotations[[1]] <- .AddXMLAddAnnotation(root,
+          position = 1,
+          id = lineGrobName, kind = ""active""
+        )
+        XML::addAttributes(segmentAnnotations[[1]]$root,
+          speech = ""There are not enough points for this line to actually be drawn."",
+          speech2 = ""This means there are less than 2 points without that are sequential to each other in the data""
+        )
+      } else {
+        for (disjointLineIndex in lineSeq) {
+          if (disjointLine) {
+            lineData <- disjointLines[[disjointLineIndex]]
+            lineCount <- lineData$x |> length() - 1
+
+            disjointLineGTag <- paste(lineGrobName, paste0(lineNum, letters[disjointLineIndex]), sep = ""."")
+            segmentAnnotations[[disjointLineIndex]] <- .AddXMLAddAnnotation(root,
+              position = disjointLineIndex,
+              id = disjointLineGTag, kind = ""grouped""
+            )
+            XML::addAttributes(segmentAnnotations[[disjointLineIndex]]$root,
+              speech = paste(""Disjoint Line"", disjointLineIndex),
+              speech2 = paste(
+                ""Disjoint Line"", disjointLineIndex,
+                ""with"", lineCount, ""segments""
+              )
+            )
+          } else {
+            lineCount <- nrow(lineData) - 1
+          }
+
+          if (lineCount > summarisedSections) {
+            slope_Range_Median <- summariseLayer(lineData, function(data) {
+              data |>
+                dplyr::mutate(startX = x, endX = lead(x), startY = y, endY = lead(y)) |>
+                tidyr::drop_na() |>
+                dplyr::select(matches(""(start|end)\\w"")) |>
+                dplyr::mutate(slope = (startY - endY) / (startX - endX)) |>
+                dplyr::summarise(min = min(slope), max = max(slope), mean = mean(slope)) |>
+                as.list()
+            }, overlap = TRUE)
+            summarised <- TRUE
+            lineCount <- summarisedSections
+          } else {
+            summarised <- FALSE
+            # This just needs some value for the mapply to loop through correctly
+            slope_Range_Median <- 1:lineCount
+          }
+
+          splitData <- lineData$x |>
+            seq_along() |>
+            .SplitData(overlapping = TRUE)
+
+          subLineSegmentsAnnotations <- mapply(
+            function(i, splitIndices, lineData, summary) {
+              if (summarised) {
+                desc <- paste(
+                  ""slope range"",
+                  .AddXMLFormatNumber(summary$min),
+                  ""to"",
+                  .AddXMLFormatNumber(summary$max),
+                  ""with mean"",
+                  .AddXMLFormatNumber(summary$mean)
+                )
+                desc2 <- paste(
+                  ""x from "",
+                  lineData$x[splitIndices[1]],
+                  ""to"",
+                  lineData$x[splitIndices |> tail(n = 1)],
+                  ""y from "",
+                  lineData$y[splitIndices[1]],
+                  ""to"",
+                  lineData$y[splitIndices |> tail(n = 1)]
+                )
+              } else {
+                desc <- paste(
+                  .AddXMLFormatNumber((lineData$y[i + 1] - lineData$y[i]) / (lineData$x[i + 1] - lineData$x[i])),
+                  ""slope from x"",
+                  .AddXMLFormatNumber(lineData$x[i]),
+                  ""to x"",
+                  .AddXMLFormatNumber(lineData$x[i + 1])
+                )
+                desc2 <- paste0(
+                  ""line from ("",
+                  .AddXMLFormatNumber(lineData$x[i]),
+                  "","",
+                  .AddXMLFormatNumber(lineData$y[i]),
+                  "") to ("",
+                  .AddXMLFormatNumber(lineData$x[i + 1]),
+                  "","",
+                  .AddXMLFormatNumber(lineData$y[i + 1]),
+                  "")""
+                )
+              }
+              .AddXMLLine(root,
+                position = i,
+                id = .CreateID(ifelse(disjointLine, disjointLineGTag, lineGTagID), letters[i]),
+                speech = desc, speech2 = desc2
+              )
+            },
+            i = if (summarised) seq_along(splitData) else 1:lineCount,
+            splitIndices = splitData,
+            summary = slope_Range_Median,
+            MoreArgs = list(lineData = lineData),
+            SIMPLIFY = FALSE
+          ) |>
+            suppressWarnings()
+
+          if (disjointLine) {
+            .AddXMLAddComponents(segmentAnnotations[[disjointLineIndex]], subLineSegmentsAnnotations)
+            .AddXMLAddChildren(segmentAnnotations[[disjointLineIndex]], subLineSegmentsAnnotations)
+            .AddXMLAddParents(segmentAnnotations[[disjointLineIndex]], subLineSegmentsAnnotations)
+          } else {
+            segmentAnnotations <- subLineSegmentsAnnotations
+          }
+        }
       }
       .AddXMLAddComponents(lineGTagAnnotation, segmentAnnotations)
       .AddXMLAddChildren(lineGTagAnnotation, segmentAnnotations)
       .AddXMLAddParents(lineGTagAnnotation, segmentAnnotations)
       annotations[[lineNum]] <- lineGTagAnnotation
     }
   } else if (x$type == ""point"") {
-    numberOfPoints <- nrow(x$data)
+    # Rmeove all the NAs in the data
+    data <- x$data |>
+      drop_na(x, y)
 
-    pointGrobID <- .GetGeomID.GeomPoint()
+    numberOfPoints <- nrow(data)
+
+    pointGrobID <- .GetGeomID(graphObject, x$layernum)
 
     XML::addAttributes(annotation$root,
       speech = ""Point graph"",
@@ -380,7 +456,7 @@
       }
     }
   } else if (x$type == ""smooth"") {
-    geomGrobID <- .GetGeomID.GeomSmooth()
+    geomGrobID <- .GetGeomID(graphObject, x$layernum)
 
 
     XML::addAttributes(annotation$root,
@@ -429,9 +505,9 @@
         position = i,
         id = geomGrobID,
         speech = sectionDesc,
-        ci = x$ci,
         lineDesc = lineDesc,
-        ciDesc = ciDesc
+        ciDesc = ciDesc,
+        layer = x$layernum
       )
     }
   } else { # TODO:  warn about layer types we don't recognize
@@ -446,19 +522,19 @@
 # Still a work in progress as the se bars are not shown.
 # TODO: make se bars actually display.
 .AddXMLSmooth <- function(root, position = 1, id = NULL, speech, speech2 = speech,
-                          ci = TRUE, lineDesc, ciDesc) {
+                          lineDesc, ciDesc, layer) {
   annotation <- .AddXMLAddAnnotation(root, position = position, id = paste(id, letters[position], sep = "".""), kind = ""grouped"")
   XML::addAttributes(annotation$root, speech = speech, speech2 = speech2)
 
   # Add in a reference to the seGrob if it exists
   items <- .AddXMLAddAnnotation(root, 1,
-    id = paste(""line"", letters[position], sep = "".""),
+    id = .CreateID(layer, ""smoother_line"", letters[position]),
     attributes = list(speech = lineDesc)
   ) |>
     list()
-  if (ci) {
+  if (ciDesc != """") {
     items <- .AddXMLAddAnnotation(root, 2,
-      id = paste(""ci"", letters[position], sep = "".""),
+      id = .CreateID(layer, ""smoother_ci"", letters[position]),
       attributes = list(speech = ciDesc)
     ) |>
       list() |>
@@ -877,20 +953,3 @@
   }
   format(x, digits = 4, scientific = useScientific)
 }
-
-#' Get the number of data points and how many to summarise it to for a geom layer
-#'
-#' @param xs A .VI.struct pbject layer. To get the right data it would look something
-#' like this `.VIstruct.ggplot_object[[""panels""]][[panelNum]][[""panellayers""]][[layerNum]]`
-#' @param ...
-#'
-#' @return A 2 length vector with the first item being the number of summarized
-#' section to make and the second element being the number of data points in
-#' geom_layer
-.getSummarizedAmount <- function(xs, ...) {
-  UseMethod("".getSummarizedAmount"")
-}
-
-.getSummarizedAmount.GeomLine <- function(xs, ...) {
-  # Nothing
-}

---FILE: R/AddXMLMethod.R---
@@ -137,7 +137,8 @@ AddXML.ggplot <- function(x, file) {
     for (layerNum in 1:xs$nlayers) {
       layer <- .AddXMLAddGGPlotLayer(
         annotations,
-        xs$panels[[1]]$panellayers[[layerNum]]
+        xs$panels[[1]]$panellayers[[layerNum]],
+        graphObject = x
       )
       components[[length(components) + 1]] <- layer
     }

---FILE: R/BrowseSVG.R---
@@ -24,7 +24,7 @@ BrowseSVG <- function(file = ""test"", key = TRUE, footer = TRUE, view = interacti
   if (!is.null(ggplot_object)) {
     # Get the Describe output
     Description <- Describe(ggplot_object, whichLayer = ""all"")
-    if (is(Description, ""multidescription"")) {
+    if (is(Description, ""multiDescription"")) {
       Description <- unclass(Description)
       Description <- lapply(seq_along(Description), function(i) {
         Description[[i]]$name <- names(Description)[[i]]

---FILE: R/MakeAccessibleSVGInternal.R---
@@ -11,33 +11,74 @@
 #' It is very important to remember that the graph must be current plotted for the
 #' grid.grep style commands to work
 #'
-#' @param x This is the object with the class you want to use
+#' @param graphObject The graph object you want to be getting the id from
 #' @param layer Which layer is this geom.
-#' @param ...  These are extra paramter that might be needed for particular geoms
 #'
 #' @return A ID string that is the overall string needed in the svg and xml
 #' If there are many elements then it is the most overarching selection
-.GetGeomID <- function(x, layer = 1, ...) {
-  UseMethod("".GetGeomID"")
+.GetGeomID <- function(graphObject, layer = 1) {
+  graphLayers <- graphObject$layers
+
+  thisLayerIDBase <- graphLayers[[layer]]$geom |>
+    .GetGeomIDBase()
+
+  if (is.null(thisLayerIDBase)) {
+    return()
+  }
+
+  geomGrobs <- grid.grep(gPath(""panel"", ""panel-1"", thisLayerIDBase), grep = TRUE, global = TRUE) |>
+    Filter(function(element) {
+      element$n == 4
+    }, x = _)
+
+  numberOfPreviousMatches <- if (layer == 1) {
+    # No previous matches if this is the first layer
+    0
+  } else {
+    graphLayers[1:(layer - 1)] |>
+      lapply(function(layer) {
+        thisLayerIDBase == .GetGeomIDBase(layer$geom)
+      }) |>
+      unlist() |>
+      sum()
+  }
+  geomGrob <- geomGrobs[[numberOfPreviousMatches + 1]]
+
+  # Always need to add the .1 to the end.
+  .CreateID(geomGrob$name, ""1"")
+}
+#' @rdname MakeAccessibleSVgInternal
+#'
+#' This is more or less a dictionary that will return what the base g tag
+#' Id for the geom will start with.
+#'
+#' For Example a geom_line layer will have a g tag that starts with GRID.poyline
+#' This function is used by the .GetGeomID to get the correct layers base g tag id.
+#'
+#' @param layerClass The geom object that has the layer class.
+#'
+.GetGeomIDBase <- function(layerClass) {
+  UseMethod("".GetGeomIDBase"")
+}
+
+.GetGeomIDBase.default <- function(layerClass) {
+  # Nothing to happen on return
 }
 
-.GetGeomID.default <- function(x, layer = 1, ...) {
-  # By default we dont know what it is
+.GetGeomIDBase.GeomLine <- function(layerClass) {
+  return(""GRID.polyline"")
 }
 
-.GetGeomID.GeomLine <- function(x, layer = 1, ...) {
-  lineGrob <- grid.grep(gPath(""panel"", ""panel-1"", ""GRID.polyline""), grep = TRUE, global = TRUE)[[1]]
-  paste(lineGrob$name, ""1"", sep = ""."")
+.GetGeomIDBase.GeomPoint <- function(layerClass) {
+  return(""geom_point"")
 }
 
-.GetGeomID.GeomPoint <- function(x, layer = 1, ...) {
-  pointGrob <- grid.grep(gPath(""panel"", ""panel-1"", ""geom_point""), grep = TRUE, global = TRUE)[[layer]]
-  paste(pointGrob$name, ""1"", sep = ""."")
+.GetGeomIDBase.GeomSmooth <- function(layerClass) {
+  return(""geom_smooth"")
 }
 
-.GetGeomID.GeomSmooth <- function(x, layer = 1, ...) {
-  smoothGrob <- grid.grep(gPath(""panel"", ""panel-1"", ""geom_smooth""), grep = TRUE, global = TRUE)[[layer]]
-  paste(smoothGrob$name, ""1"", sep = ""."")
+.GetGeomIDBase.GeomBar <- function(layerClass) {
+  return(""geom_rect"")
 }
 
 #' @rdname MakeAccessibleSVGInternal
@@ -71,3 +112,25 @@
     pointsSplit
   }
 }
+
+#' Create label from parts
+#'
+#' This shold be used rather than doing a manual paste to help prevent any changes
+#' in the future from being to damaging.
+#'
+#' @param ... These should be strings to be added togather
+.CreateID <- function(...) {
+  paste(..., sep = ""."")
+}
+
+#' Find out if a GeomLine line is disjoint
+#'
+#' Given the scale data for a line find out if it is disjoint or not.
+#'
+#' @param scaleData Scale data from the ggplot_build object. Can easily be retirieved
+#' from the .VIStruct
+#'
+#' @return A Boolean value as to whether this line from the line data is disjoint.
+.IsGeomLineDisjoint <- function(scaledata) {
+  any(is.na(scaledata$y))
+}

---FILE: R/RewriteSVG.R---
@@ -9,10 +9,10 @@
 #' the svg for.
 #' @return NULL
 #'
-.RewriteSVG <- function(x, file, type, ...) {
+.RewriteSVG <- function(x, file, type, layer, ...) {
   svgDoc <- XML::xmlParseDoc(file)
 
-  geomGTagID <- .GetGeomID(type)
+  geomGTagID <- .GetGeomID(x, layer)
   if (is.null(geomGTagID)) {
     return()
   }
@@ -21,17 +21,13 @@
     paste0('//*[@id=""', geomGTagID, '""]')
   )[[1]]
 
-  .RewriteSVGGeom(x, type, geomGTagID, geomGTag, ...)
+  .RewriteSVGGeom(x, type, geomGTagID, geomGTag, layer, ...)
 
   XML::saveXML(svgDoc, file = file)
 
   return(invisible())
 }
 
-.RewriteSVGGeom.default <- function(x, type, geomGTagID, geomGTag, ...) {
-  # Nothing is to be done by deafult
-}
-
 #' @rdname .RewriteSVG
 #'
 #' The internal workhorse of the RewriteSVG function. These functions have all the specific
@@ -46,30 +42,56 @@
   UseMethod("".RewriteSVGGeom"", type)
 }
 
+.RewriteSVGGeom.default <- function(x, type, geomGTagID, geomGTag, ...) {
+  # Nothing is to be done by deafult
+}
+
 .RewriteSVGGeom.GeomLine <- function(x, type, geomGTagID, geomGTag, layer = 1) {
+  struct <- .VIstruct.ggplot(x)[[""panels""]][[1]][[""panellayers""]][[layer]]
+
   # Need to figure out how many lines there are
-  numLines <- .VIstruct.ggplot(x)[[""panels""]][[1]][[""panellayers""]][[layer]][[""lines""]] |>
+  numLines <- struct[[""lines""]] |>
     length()
 
   for (lineNum in 1:numLines) {
     # Will grab the correct polyline as there will be a text and polyline for each line.
     # The poly line gets deleted at end of this loop
     # So the next polyine will always be + 1 the line number
-    actualPolyLine <- XML::xmlChildren(geomGTag)[[lineNum + 1]]
+    if (.IsGeomLineDisjoint(struct$lines[[lineNum]]$scaledata)) {
+      regex <- paste0(.CreateID(geomGTagID, lineNum), ""[a-z]"")
+      polylinesToBeSplit <- XML::xmlChildren(geomGTag) |>
+        Filter(function(polyline) {
+          numMatches <- XML::xmlGetAttr(polyline, ""id"") |>
+            grep(regex, x = _) |>
+            length()
+          # Only if there is just one match
+          numMatches == 1
+        }, x = _)
+
+      newSegmentIDs <- polylinesToBeSplit |>
+        lapply(XML::xmlGetAttr, name = ""id"")
+    } else {
+      polylinesToBeSplit <- XML::xmlChildren(geomGTag)[[lineNum + 1]] |>
+        list()
+      newSegmentIDs <- .CreateID(geomGTagID, lineNum)
+    }
 
-    # Get the g tag for the line for the segments to go into
-    segmentParentGTagID <- paste(geomGTagID, lineNum, sep = ""."")
-    segmentParentGTag <- XML::newXMLNode(""g"",
-      parent = geomGTag,
-      attrs = list(id = segmentParentGTagID)
-    )
-    XML::addChildren(geomGTag, segmentParentGTag)
 
-    # Split the line into smaller polylines
-    .RewriteSVG_SplitPoly(segmentParentGTag,
-      actualPolyLine,
-      id = segmentParentGTagID
-    )
+    polylinesToBeSplit |>
+      mapply(function(line, i, segmentIDs) {
+        # Get the g tag for the line for the segments to go into
+        segmentParentGTag <- XML::newXMLNode(""g"",
+          parent = geomGTag,
+          attrs = list(id = segmentIDs)
+        )
+        XML::addChildren(geomGTag, segmentParentGTag)
+
+        # Split the line into smaller polylines
+        .RewriteSVG_SplitPoly(segmentParentGTag,
+          line,
+          id = segmentIDs
+        )
+      }, line = _, i = seq_along(polylinesToBeSplit), segmentIDs = newSegmentIDs)
   }
 }
 
@@ -124,7 +146,7 @@
     # it will actually be highlighted
     XML::`xmlAttrs<-`(polygonTag, value = c(`stroke-opacity` = 0.4, `stroke-width` = 0.4))
 
-    .RewriteSVG_SplitPoly(polygonGTag, polygonTag, id = ""ci"", type = ""polygon"")
+    .RewriteSVG_SplitPoly(polygonGTag, polygonTag, id = .CreateID(layer, ""smoother_ci""), type = ""polygon"")
 
     ## Move polygon to base geomGTag
     XML::addChildren(geomGTag, polygonGTag)
@@ -138,7 +160,7 @@
 
   polylineTag <- XML::xmlChildren(polylineGTag)$polyline
 
-  .RewriteSVG_SplitPoly(polylineGTag, polylineTag, id = ""line"")
+  .RewriteSVG_SplitPoly(polylineGTag, polylineTag, id = .CreateID(layer, ""smoother_line""))
 
   ## Take the 2 g tag with 5 polygon/polyline tags inside each of them.
   ## I want to zip them together so that I have 5 g tags with a polyline and polygon in each of them.
@@ -181,9 +203,9 @@
 #'
 .RewriteSVG_SplitPoly <- function(parentGTag, originalPoly, id = """", type = ""polyline"") {
   ## Copy attributes from the original segment
-  lineAttr <- XML::xmlAttrs(originalPoly)
-  lineAttr <- lineAttr[!(names(lineAttr) %in% c(""id"", ""points""))]
-  lineAttr <- split(lineAttr, names(lineAttr))
+  polyAttr <- XML::xmlAttrs(originalPoly)
+  polyAttr <- polyAttr[!(names(polyAttr) %in% c(""id"", ""points""))]
+  polyAttr <- split(polyAttr, names(polyAttr))
 
   ## Get the line points
   points <- originalPoly |>
@@ -251,7 +273,7 @@
   ## For each segment add in a new poly with all the correct attributes
   seq_along(pointsSplit) |>
     lapply(function(i) {
-      args <- lineAttr
+      args <- polyAttr
       args$id <- paste(id, letters[i], sep = ""."")
       if (type == ""polyline"") args$`fill-opacity` <- ""0""
       args$points <- paste(pointsSplit[[i]], collapse = "" "")

---FILE: R/SVGThis.R---
@@ -117,21 +117,21 @@ SVGThis.ggplot <-
     #      x=Augment(x)
     #      grid.force()
 
-    if (length(x$data$x) > 1000) {
-      warning(""You are trying to make a svg from a plot with lots of points it might take quite some time."")
+    if (length(x$data$x) > 10000) {
+      warning(""You are trying to make a svg from a plot with lots of data it might take quite some time."")
     }
 
-
     if (createDevice) {
       pdf(NULL)
     }
     print(x)
     gridSVG::grid.export(name = file)
 
     # Loop through layers and change svg as needed
-    lapply(x$layers, function(x, graphObject, file) {
-      .RewriteSVG(graphObject, file, x$geom)
-    }, graphObject = x, file = file)
+    1:length(x$layers) |>
+      lapply(function(layerIndex, graphObject, file) {
+        .RewriteSVG(graphObject, file, x$layer[[layerIndex]]$geom, layerIndex)
+      }, graphObject = x, file = file)
 
     if (createDevice) {
       dev.off()"
ajrgodfrey,BrailleR,2856301beca8f5745cafb6119462d707318a8fab,James,1jamesthompson1@gmail.com,2023-01-26T05:22:13Z,James,1jamesthompson1@gmail.com,2023-01-26T05:22:13Z,"Add in support for geom_line

commit fb09ce28d2c9d89cb2f55ed4e3b6f33ab79c855d
Author: James <1jamesthompson1@gmail.com>
Date:   Thu Jan 26 18:20:05 2023 +1300

    Fix error with showing in filled spaces.

    Also a few minor changes to remove some notes from the cmd check.

commit 5c344cb7217d93cec27901975e1eabe756bca9b2
Author: James <1jamesthompson1@gmail.com>
Date:   Thu Jan 26 15:39:14 2023 +1300

    Add proper multiline support plus fix incorrect summary information and change it to tell you mean instead.

commit 66d30aaa1ce798ea428260b229119e4cc8b11fd9
Author: James <1jamesthompson1@gmail.com>
Date:   Wed Jan 25 21:13:07 2023 +1300

    Add in basic geom_line for the SVG and XML.
    It follow works with the new verion and even has a basic multiple line implmentation.
    This mulitple line implementation is linear and would need to be made less linear if it is too work.",DESCRIPTION;NAMESPACE;R/AddXMLInternal.R;R/AddXMLMethod.R;R/BrowseSVG.R;R/MakeAccessibleSVGInternal.R;R/RewriteSVG.R;R/SVGThis.R;man/MakeAccessibleSVGMethod.Rd,False,True,True,False,425,228,653,"---FILE: DESCRIPTION---
@@ -57,7 +57,8 @@ Imports:
     tidyr,
     whisker,
     XML,
-    xtable
+    xtable,
+    methods
 Suggests:
     broom,
     emmeans,

---FILE: NAMESPACE---
@@ -25,6 +25,7 @@ importFrom(""whisker"", ""whisker.render"")
 importFrom(""XML"", ""addAttributes"", ""newXMLDoc"", ""newXMLNode"", ""ensureNamespace"", ""newXMLTextNode"", ""xmlName"", ""xmlRoot"", ""saveXML"", ""getNodeSet"", ""xmlGetAttr"", ""addChildren"", ""removeChildren"", ""xmlChildren"")
 importFrom(""xtable"", ""xtable"")
 importFrom(""grDevices"", ""dev.size"")
+importFrom(""methods"", ""is"")
 S3method(AddXML,default)
   S3method(AddXML,boxplot)
   S3method(AddXML,dotplot)
@@ -99,4 +100,3 @@ S3method(VI,default)
   S3method(VI,tsplot)
   S3method(VI,TukeyHSD)
 exportPattern(""^[[:alpha:]]+"")
-

---FILE: R/AddXMLInternal.R---
@@ -127,26 +127,25 @@
 ## Constructs a ggplot layer
 .AddXMLAddGGPlotLayer <- function(root, x = NULL, panel = 1, summarisedSections = 5) {
   # Functions used within this function
-  summariseLayer <- function(data, FUN) {
-    breaks <- seq(min(data$x), max(data$x), length.out = summarisedSections + 1)
-    mins <- breaks[1:(summarisedSections)]
-    maxs <- breaks[2:(summarisedSections + 1)]
-    # As max will be the same as the last item we will increase max by 1 to include the final data point
-    maxs[5] <- maxs[5] + 1
+  summariseLayer <- function(data, FUN = function(x) x) {
+    mins_maxs <- length(data$x) |>
+      .GetSummarizedAmounts()
+
     summarisedData <- mapply(
       function(min, max, data) {
         data |>
-          dplyr::filter(x < max, x >= min) |>
+          dplyr::slice(min:max) |>
           FUN()
       },
-      mins, maxs, list(data = data),
+      min = mins_maxs$mins, max = mins_maxs$maxs, list(data = data),
       SIMPLIFY = FALSE
     )
   }
 
+  layerGroupID <- paste(""center"", panel, x$layernum, sep = ""-"")
   annotation <- .AddXMLAddAnnotation(root,
     position = 4,
-    id = paste(""center"", panel, x$layernum, sep = ""-""), kind = ""grouped""
+    id = layerGroupID, kind = ""grouped""
   )
   # TODO:  For all layer types:  need heuristic to avoid trying to describe
   # individual data points if there are thousands of them
@@ -191,25 +190,36 @@
       }
     }
   } else if (x$type == ""line"") { # Line chart
-    segmentCount <- nrow(x$data) - 1 # One less than the number of points
-    # For now, assume that all layers are this layer type
-    # TODO:  Fix this
-    lineGrobs <- grid.grep(gPath(""panel"", ""panel-1"", ""GRID.polyline""), grep = TRUE, global = TRUE)
-    lineGrob <- lineGrobs[[x$layernum]]
+    numberOfLines <- length(x$lines)
+    lineGrobName <- .GetGeomID.GeomLine()
     XML::addAttributes(annotation$root,
       speech = ""Line graph"",
-      speech2 = paste(""Line graph with"", segmentCount, ""segments""),
+      speech2 = paste(""Line graph with"", numberOfLines, ""lines""),
       # Better to report #lines or #segs?
       # Line can be discontinuous (comprised of polylines 1a, 1b, ...)
       type = ""Center""
     )
-    numberOfLines <- length(x$lines)
 
     for (lineNum in 1:numberOfLines) {
-      lineId <- paste(lineGrob$name, lineNum, sep = ""."") # ID of the polyline
-
       lineData <- x$lines[[lineNum]]$scaledata
       lineCount <- nrow(lineData) - 1
+
+      segmentAnnotations <- list()
+      # ID of the line g tag
+      lineGTagID <- paste(lineGrobName, lineNum, sep = ""."")
+
+      # Add the lineGTag annotation
+      lineGTagAnnotation <- .AddXMLAddAnnotation(root,
+        position = lineNum,
+        id = lineGTagID, kind = ""grouped""
+      )
+      XML::addAttributes(lineGTagAnnotation$root,
+        speech = paste(""Line"", lineNum),
+        speech2 = paste(""Line"", lineNum, ""with"", lineCount, ""segments""),
+        type = ""Center""
+      )
+
+
       # Summarizing the data
       if (lineCount > summarisedSections) {
         slope_Range_Median <- summariseLayer(lineData, function(data) {
@@ -218,7 +228,7 @@
             tidyr::drop_na() |>
             dplyr::select(matches(""(start|end)\\w"")) |>
             dplyr::mutate(slope = (startY - endY) / (startX - endX)) |>
-            dplyr::summarise(min = min(slope), max = max(slope), median = median(slope)) |>
+            dplyr::summarise(min = min(slope), max = max(slope), mean = mean(slope)) |>
             as.list()
         })
         summarised <- TRUE
@@ -231,15 +241,15 @@
       breaks <- seq(min(data$x), max(data$x), length.out = summarisedSections + 1)
       mins <- breaks[1:(summarisedSections)]
       maxs <- breaks[2:(summarisedSections + 1)]
-
       for (i in 1:(lineCount)) {
         if (summarised) {
           desc <- paste(
+            ""slope range"",
             .AddXMLFormatNumber(slope_Range_Median[[i]]$min),
             ""to"",
             .AddXMLFormatNumber(slope_Range_Median[[i]]$max),
-            ""with median"",
-            .AddXMLFormatNumber(slope_Range_Median[[i]]$median)
+            ""with mean"",
+            .AddXMLFormatNumber(slope_Range_Median[[i]]$mean)
           )
           desc2 <- paste(
             ""x from "",
@@ -253,19 +263,34 @@
           )
         } else {
           desc <- paste(
-            .AddXMLFormatNumber(lineData$y[i]),
-            ""at"",
+            .AddXMLFormatNumber((lineData$y[i + 1] - lineData$y[i]) / (lineData$x[i + 1] - lineData$x[i])),
+            ""slope from x"",
             .AddXMLFormatNumber(lineData$x[i]),
-            ifelse(i < segmentCount, "" line start"", "" line end""),
-            i
+            ""to x"",
+            .AddXMLFormatNumber(lineData$x[i + 1])
+          )
+          desc2 <- paste0(
+            ""line from ("",
+            .AddXMLFormatNumber(lineData$x[i]),
+            "","",
+            .AddXMLFormatNumber(lineData$y[i]),
+            "") to ("",
+            .AddXMLFormatNumber(lineData$x[i + 1]),
+            "","",
+            .AddXMLFormatNumber(lineData$y[i + 1]),
+            "")""
           )
-          desc2 <- desc
         }
-        annotations[[i]] <- .AddXMLLines(root, position = i, id = lineId, speech = desc, speech2 = desc2)
+
+        segmentAnnotations[[i]] <- .AddXMLLine(root, position = i, id = paste(lineGTagID, letters[i], sep = "".""), speech = desc, speech2 = desc2)
         # TODO:  Not correctly handling NA or out-of-range data values, nor dates
         # Should check for dates with inherit(,""Date"") -- but looks like I
         # need to do that on the main data not the layer data
       }
+      .AddXMLAddComponents(lineGTagAnnotation, segmentAnnotations)
+      .AddXMLAddChildren(lineGTagAnnotation, segmentAnnotations)
+      .AddXMLAddParents(lineGTagAnnotation, segmentAnnotations)
+      annotations[[lineNum]] <- lineGTagAnnotation
     }
   } else if (x$type == ""point"") {
     numberOfPoints <- nrow(x$data)
@@ -429,19 +454,9 @@
   return(invisible(annotation))
 }
 
-# Polyline is problematic as we can't highlight each segment visually, but still want
-# to describle them separately
-# Current fudge for this -- define each segment with a dummy name that doesn't actually
-# exist in the SVG.  Then give it a passive child which is the whole
-# polyline.  This keeps the whole line visible while individual segments are described
-.AddXMLLines <- function(root, position = 1, x, y, id = NULL, speech = paste0(""("", signif(x), "","", signif(y), "") number "", position), speech2 = speech) {
-  fakeSegmentId <- paste(id, position, sep = ""."")
-  annotation <- .AddXMLAddAnnotation(root, position = position, id = fakeSegmentId, kind = ""active"")
-  dummyAnnotation <- list(.AddXMLAddAnnotation(root, position = position, id = id, kind = ""passive""))
+.AddXMLLine <- function(root, position = 1, id = NULL, speech = NULL, speech2 = speech) {
+  annotation <- .AddXMLAddAnnotation(root, position = position, id = id, kind = ""active"")
   XML::addAttributes(annotation$root, speech = speech, speech2 = speech2)
-  .AddXMLAddComponents(annotation, dummyAnnotation)
-  .AddXMLAddChildren(annotation, dummyAnnotation)
-  .AddXMLAddParents(annotation, dummyAnnotation)
   return(invisible(annotation))
 }
 
@@ -803,3 +818,20 @@
   }
   format(x, digits = 4, scientific = useScientific)
 }
+
+#' Get the number of data points and how many to summarise it to for a geom layer
+#'
+#' @param xs A .VI.struct pbject layer. To get the right data it would look something
+#' like this `.VIstruct.ggplot_object[[""panels""]][[panelNum]][[""panellayers""]][[layerNum]]`
+#' @param ...
+#'
+#' @return A 2 length vector with the first item being the number of summarized
+#' section to make and the second element being the number of data points in
+#' geom_layer
+.getSummarizedAmount <- function(xs, ...) {
+  UseMethod("".getSummarizedAmount"")
+}
+
+.getSummarizedAmount.GeomLine <- function(xs, ...) {
+  # Nothing
+}

---FILE: R/AddXMLMethod.R---
@@ -278,7 +278,7 @@ AddXML.tsplot <- function(x, file) {
   XMax <- max(x$xTicks)
   xAxis <- .AddXMLAddAxis(
     annotations,
-    axsi = ""x"", label = x$ExtraArgs$xlab, values = xValues,
+    axis = ""x"", label = x$ExtraArgs$xlab, values = xValues,
     speechLong = paste(""x axis"", x$ExtraArgs$xlab, ""ranges from"", XMin, ""to"", XMax)
   )
 

---FILE: R/BrowseSVG.R---
@@ -24,7 +24,7 @@ BrowseSVG <- function(file = ""test"", key = TRUE, footer = TRUE, view = interacti
   if (!is.null(ggplot_object)) {
     # Get the Describe output
     Description <- Describe(ggplot_object, whichLayer = ""all"")
-    if (class(Description) == ""multidescription"") {
+    if (is(Description, ""multidescription"")) {
       Description <- unclass(Description)
       Description <- lapply(seq_along(Description), function(i) {
         Description[[i]]$name <- names(Description)[[i]]

---FILE: R/MakeAccessibleSVGInternal.R---
@@ -0,0 +1,54 @@
+#' This r file is to be a store for all of the fucntions that are used when making
+#' the xml and svg then putting it togather. It is only for functions that are
+#' used by both the svg and xml pathways
+
+
+#' Search graphic for ID of Geom
+#'
+#' This can be used by the AddXML function as well as SVG functions to know how to
+#' modify and create the XML / svg. These IDs are the link that is between the XML and the SVG
+#'
+#' It is very important to remember that the graph must be current plotted for the
+#' grid.grep style commands to work
+#'
+#' @param x This is the object with the class you want to use
+#'
+#' @return A ID string that is the overall string needed in the svg and xml
+#' If there are many elements then it is the most overarching selection
+.GetGeomID <- function(x, ...) {
+  UseMethod("".GetGeomID"")
+}
+
+.GetGeomID.GeomLine <- function(x, ...) {
+  # Currently hard coded to get the first layer will need to change later
+  lineGrob <- grid.grep(gPath(""panel"", ""panel-1"", ""GRID.polyline""), grep = TRUE, global = TRUE)[[1]]
+  paste(lineGrob$name, ""1"", sep = ""."")
+}
+
+
+#' Get summarized counts for a length
+#'
+#' @param numberOfDataPoints This is the number of data points that are to be
+#' put into groups
+#'
+#' @return A list with 2 vectors. There is a mins and a max vecotr. These vectors
+#' are where the sections start and stop. The max will be the same as the next min.
+#' Theses numbers will be returned as rank indices rather than the actual data.
+#'
+#'
+
+.GetSummarizedAmounts <- function(numberOfDataPoints, numberOfSections = 5) {
+  UseMethod("".GetSummarizedAmounts"")
+}
+
+.GetSummarizedAmounts.default <- function(numberOfDataPoints, numberOfSections = 5) {
+  if (numberOfDataPoints > 5) {
+    breaks <- seq(1, numberOfDataPoints, length.out = numberOfSections + 1)
+    mins <- breaks[1:(numberOfSections)]
+    maxs <- breaks[2:(numberOfSections + 1)]
+
+    list(mins = mins, maxs = maxs) |> lapply(round)
+  } else {
+    list(mins = 1:(numberOfDataPoints - 1), maxs = 2:numberOfDataPoints)
+  }
+}

---FILE: R/RewriteSVG.R---
@@ -1,47 +1,125 @@
+#' Rewrite a SVG so that it cna be properly explored with diagcess via the XML.
+#'
+#' @param x The graph object that the svg comes from
+#' @param file The file of the SVG
+#' @param type This should be a ojbect of the class of geom you are trying to rewrite
+#' the svg for.
+#' @return NULL
+#'
+.RewriteSVG <- function(x, file, type, ...) {
+  UseMethod("".RewriteSVG"", type)
+}
+
+.RewriteSVG.default <- function(x, file, type, ...) {
+  # Nothing is to be done by deafult
+}
+
+.RewriteSVG.GeomLine <- function(x, file, type, layer = 1) {
+  parentPolylineID <- .GetGeomID(type)
+  svgDoc <- XML::xmlParseDoc(file)
+  parentPolyline <- XML::getNodeSet(
+    svgDoc,
+    paste0('//*[@id=""', parentPolylineID, '""]')
+  )[[1]]
+
+  # Need to figure out how many lines there are
+  struct <- .VIstruct.ggplot(x)
+  numLines <- struct[[""panels""]][[1]][[""panellayers""]][[layer]][[""lines""]] |> length()
+
+  for (lineNum in 1:numLines) {
+    # Will grab the correct polyline as there will be a text and polyline for each line.
+    # The poly line gets deleted at end of this loop
+    # So the next polyine will always be + 1 the line number
+    actualPolyLine <- XML::xmlChildren(parentPolyline)[[lineNum + 1]]
+
+    # Get the g tag for the line for the segments to go into
+    segmentParentGTag <- XML::newXMLNode(""g"",
+      parent = parentPolyline,
+      attrs = list(id = paste(parentPolylineID, lineNum, sep = "".""))
+    )
+    XML::addChildren(parentPolyline, segmentParentGTag)
+
+    # Split the line into smaller polylines
+
+    ## Copy attributes from the original segment
+    lineAttr <- XML::xmlAttrs(actualPolyLine)
+    lineAttr <- lineAttr[!(names(lineAttr) %in% c(""id"", ""points""))]
+    lineAttr <- split(lineAttr, names(lineAttr))
+
+    ## Get the line points
+    coordinates <- XML::xmlGetAttr(actualPolyLine, ""points"") |>
+      strsplit("" "") |>
+      unlist()
 
+    ## There could a unknown number of points
+    mins_maxs <- length(coordinates) |>
+      .GetSummarizedAmounts()
 
-.RewriteSVG.tsplot = function(x, file) {
+    numberOfBreaks <- mins_maxs$min |> length() + 1
+    ## For each segment add in a new poly line with all the correct attributes
+    1:(numberOfBreaks - 1) |>
+      lapply(function(i) {
+        segmentCoords <- coordinates[mins_maxs$mins[i]:mins_maxs$maxs[i]]
+
+        args <- lineAttr
+        args$id <- paste(parentPolylineID, lineNum, letters[i], sep = ""."")
+        args$`fill-opacity` <- ""0""
+        args$points <- paste(segmentCoords, collapse = "" "")
+
+        newPolyline <- XML::newXMLNode(""polyline"", parent = segmentParentGTag, attrs = args)
+
+        XML::addChildren(segmentParentGTag, newPolyline)
+      })
+
+    # Remove old line
+    XML::removeChildren(parentPolyline, actualPolyLine)
+  }
+  # Save modified svg doc
+  XML::saveXML(svgDoc, file = file)
+}
+
+.RewriteSVG.tsplot <- function(x, file) {
   svgDoc <- XML::xmlParseDoc(file) ## ""Temperature.svg""
-  nodes <- XML::getNodeSet(svgDoc,
-                      '//*[@id=""graphics-plot-1-lines-1.1""]')
+  nodes <- XML::getNodeSet(
+    svgDoc,
+    '//*[@id=""graphics-plot-1-lines-1.1""]'
+  )
   if (length(nodes) == 0) {
     return(invisible(""Something went wrong!""))
   }
   .SplitPolyline(x$GroupSummaries$N, nodes[[1]])
-  XML::saveXML(svgDoc, file=file)
+  XML::saveXML(svgDoc, file = file)
   return(invisible(NULL))
 }
 
-#vs Currently we hardcode the attributes. Should simply be copied.
-.SplitPolyline = function(points, root, start=0, child=1) {
-  children <- XML::getNodeSet(root, '//*[@points]')
+# vs Currently we hardcode the attributes. Should simply be copied.
+.SplitPolyline <- function(points, root, start = 0, child = 1) {
+  children <- XML::getNodeSet(root, ""//*[@points]"")
   polyline <- children[[child]]
-  attr <- XML::xmlGetAttr(polyline, 'points')
+  attr <- XML::xmlGetAttr(polyline, ""points"")
   coordinates <- strsplit(attr, "" "")[[1]]
   count <- 1
   ## result <- list()
   for (i in 1:length(points)) {
-    node <- XML::newXMLNode('polyline', parent=root)
-    end <- count+points[i]
+    node <- XML::newXMLNode(""polyline"", parent = root)
+    end <- count + points[i]
     segment <- coordinates[count:end]
     XML::addAttributes(
-           node,
-           id = paste(""graphics-plot-1-lines-1.1.1"", intToUtf8(utf8ToInt('a') + (i - 1)) , sep=""""),
-           points = paste(segment[!is.na(segment)], collapse="" ""),
-           ""stroke-dasharray""=""none"",
-           stroke=""rgb(0,0,0)"",
-           ""stroke-width""=""1"",
-           ""stroke-linecap""=""round"",
-           ""stroke-miterlimit""=""10"",
-           ""stroke-linejoin""=""round"",
-           ""stroke-opacity""=""1"",
-           fill=""none"")
+      node,
+      id = paste(""graphics-plot-1-lines-1.1.1"", intToUtf8(utf8ToInt(""a"") + (i - 1)), sep = """"),
+      points = paste(segment[!is.na(segment)], collapse = "" ""),
+      ""stroke-dasharray"" = ""none"",
+      stroke = ""rgb(0,0,0)"",
+      ""stroke-width"" = ""1"",
+      ""stroke-linecap"" = ""round"",
+      ""stroke-miterlimit"" = ""10"",
+      ""stroke-linejoin"" = ""round"",
+      ""stroke-opacity"" = ""1"",
+      fill = ""none""
+    )
     XML::addChildren(root, node, at = i + (child - 1))
     count <- end
   }
   XML::removeChildren(root, polyline)
   return(invisible(NULL))
 }
-
-
-

---FILE: R/SVGThis.R---
@@ -1,187 +1,216 @@
-
 # this file is only for the SVGThis method and associated utility functions.
 # SVGThis.default() needs interactive session but specific methods need not be
 
 # this from Paul via maps example
 ## chekc it is not already incorporated into new version of gridSVG.
 .addInfo <- function(name, title, desc) {
   grid::grid.set(
-      name,
-      grid::gTree(
-          children = grid::gList(
-              elementGrob(""title"", children = grid::gList(textNodeGrob(title))),
-              elementGrob(""desc"", children = grid::gList(textNodeGrob(desc))),
-              grid::grid.get(name)), name = name), redraw = FALSE)
+    name,
+    grid::gTree(
+      children = grid::gList(
+        elementGrob(""title"", children = grid::gList(textNodeGrob(title))),
+        elementGrob(""desc"", children = grid::gList(textNodeGrob(desc))),
+        grid::grid.get(name)
+      ), name = name
+    ),
+    redraw = FALSE
+  )
 }
 
 # next is partly from Paul via maps example, with additions from Jonathan
-.MakeTigerReady =
-    function(svgfile) {  # for alterations needed on all SVG files
-      if (file.exists(svgfile)) {
-        cat(""\n"", file = svgfile, append = TRUE)  # otherwise warnings returned
-                                                  # on readLines() below
-        temp <- readLines(con = svgfile)
-        writeLines(gsub(""ISO8859-1"", ""ASCII"", temp), con = svgfile)
-      } else {
-        .FileDoesNotExist(svgfile)
-      }
-      return(invisible(NULL))
+.MakeTigerReady <-
+  function(svgfile) { # for alterations needed on all SVG files
+    if (file.exists(svgfile)) {
+      cat(""\n"", file = svgfile, append = TRUE) # otherwise warnings returned
+      # on readLines() below
+      temp <- readLines(con = svgfile)
+      writeLines(gsub(""ISO8859-1"", ""ASCII"", temp), con = svgfile)
+    } else {
+      .FileDoesNotExist(svgfile)
     }
+    return(invisible(NULL))
+  }
 
 # method is mostly Jonathan's use of Paul/Simon's work
-SVGThis = function(x, file = ""test.svg"", ...) {
-            UseMethod(""SVGThis"")
-          }
-
-SVGThis.default =
-    function(x, file = ""test.svg"", ...) {
-      if (is.null(x)) {  # must be running interactively
-        if (dev.cur() > 1) {  # there must also be an open graphics/grid device
-
-          if (length(grid::grid.ls(print = FALSE)$name) == 0) {  # if not grid
-                                                                 # already, then
-                                                                 # convert
-            gridGraphics::grid.echo()
-          }
-
-          # then export to SVG
-          gridSVG::grid.export(name = file)
-          .MakeTigerReady(svgfile = file)
-          # no specific processing to be done in this function.
-        }  # end open device condition
-            else {  # no current device
-          warning(""There is no current graphics device to convert to SVG.\n"")
-        }
-      }  # end interactive condition
-          else {  # not interactive session
-        warning(
-            ""The default SVGThis() method only works for objects of specific classes.\nThe object supplied does not yet have a method written for it.\n"")
-      }
-      return(invisible(NULL))
-    }
-
-SVGThis.boxplot =
-    function(x, file = ""test.svg"", ...) {
-      # really should check that the boxplot wasn't plotted already before...
-      # but simpler to just do the plotting ourselves and close the device later
-      x  # ensure we create a boxplot on a new graphics device
-      gridGraphics::grid.echo()  # boxplot() currently uses graphics package
-      gridSVG::grid.export(name = file)
-      dev.off()  # remove our graph window
-      .MakeTigerReady(svgfile = file)
-      return(invisible(NULL))
-    }
+SVGThis <- function(x, file = ""test.svg"", ...) {
+  UseMethod(""SVGThis"")
+}
 
-SVGThis.dotplot =
-    function(x, file = ""test.svg"", ...) {
-      # really should check that the dotplot wasn't plotted already before...
-      # but simpler to just do the plotting ourselves and close the device later
-      x  # ensure we create a dotplot on a new graphics device
-      gridGraphics::grid.echo()  # dotplot() currently uses graphics package
-      gridSVG::grid.export(name = file)
-      dev.off()  # remove our graph window
-      .MakeTigerReady(svgfile = file)
-      return(invisible(NULL))
-    }
+SVGThis.default <-
+  function(x, file = ""test.svg"", ...) {
+    if (is.null(x)) { # must be running interactively
+      if (dev.cur() > 1) { # there must also be an open graphics/grid device
 
-SVGThis.eulerr = 
-    function(x, file = ""test.svg"", ...) {
-      x=Augment(x)
-      X = stats::coef(x)[, 1L]
-      Y = stats::coef(x)[, 2L]
-      R = stats::coef(x)[, 3L]
-      Labels = rownames(x$coefficients)
-      TextX = x$TextPositions$x
-      TextY = x$TextPositions$y
-
-      pushViewport(dataViewport(c(X-R, X+R), c(Y-R, Y+R))) 
-      grid.circle(X, Y, R, default.units=""native"", name=""VennCircles"") 
-      grid.text(Labels, TextX, TextY, default.units=""native"",           name=""VennLabels"")
-
-      gridSVG::grid.export(name = file)
-      dev.off()
+        if (length(grid::grid.ls(print = FALSE)$name) == 0) { # if not grid
+          # already, then
+          # convert
+          gridGraphics::grid.echo()
+        }
 
-      .MakeTigerReady(svgfile = file)
-      return(invisible(NULL))
+        # then export to SVG
+        gridSVG::grid.export(name = file)
+        .MakeTigerReady(svgfile = file)
+        # no specific processing to be done in this function.
+      } # end open device condition
+      else { # no current device
+        warning(""There is no current graphics device to convert to SVG.\n"")
+      }
+    } # end interactive condition
+    else { # not interactive session
+      warning(
+        ""The default SVGThis() method only works for objects of specific classes.\nThe object supplied does not yet have a method written for it.\n""
+      )
     }
+    return(invisible(NULL))
+  }
+
+SVGThis.boxplot <-
+  function(x, file = ""test.svg"", ...) {
+    # really should check that the boxplot wasn't plotted already before...
+    # but simpler to just do the plotting ourselves and close the device later
+    x # ensure we create a boxplot on a new graphics device
+    gridGraphics::grid.echo() # boxplot() currently uses graphics package
+    gridSVG::grid.export(name = file)
+    dev.off() # remove our graph window
+    .MakeTigerReady(svgfile = file)
+    return(invisible(NULL))
+  }
+
+SVGThis.dotplot <-
+  function(x, file = ""test.svg"", ...) {
+    # really should check that the dotplot wasn't plotted already before...
+    # but simpler to just do the plotting ourselves and close the device later
+    x # ensure we create a dotplot on a new graphics device
+    gridGraphics::grid.echo() # dotplot() currently uses graphics package
+    gridSVG::grid.export(name = file)
+    dev.off() # remove our graph window
+    .MakeTigerReady(svgfile = file)
+    return(invisible(NULL))
+  }
+
+SVGThis.eulerr <-
+  function(x, file = ""test.svg"", ...) {
+    x <- Augment(x)
+    X <- stats::coef(x)[, 1L]
+    Y <- stats::coef(x)[, 2L]
+    R <- stats::coef(x)[, 3L]
+    Labels <- rownames(x$coefficients)
+    TextX <- x$TextPositions$x
+    TextY <- x$TextPositions$y
+
+    pushViewport(dataViewport(c(X - R, X + R), c(Y - R, Y + R)))
+    grid.circle(X, Y, R, default.units = ""native"", name = ""VennCircles"")
+    grid.text(Labels, TextX, TextY, default.units = ""native"", name = ""VennLabels"")
+
+    gridSVG::grid.export(name = file)
+    dev.off()
+
+    .MakeTigerReady(svgfile = file)
+    return(invisible(NULL))
+  }
 
 # if createDevice is TRUE (the default) SVGThis will create its own
 # (non-displaying) graphics device and destroy it when complete
 # if FALSE it will use the currently active device
-SVGThis.ggplot =
-    function(x, file = ""test.svg"", createDevice = TRUE, ...) {
-#      x=Augment(x)
-#      grid.force()
-      if (createDevice) 
-        pdf(NULL)
-      print(x)
-      gridSVG::grid.export(name = file)
-      if (createDevice) 
-        dev.off()
-      .MakeTigerReady(svgfile = file)
-      return(invisible(NULL))
+SVGThis.ggplot <-
+  function(x, file = ""test.svg"", createDevice = TRUE, ...) {
+    #      x=Augment(x)
+    #      grid.force()
+    if (createDevice) {
+      pdf(NULL)
     }
+    print(x)
+    gridSVG::grid.export(name = file)
 
+    # Loop through layers and change svg as needed
+    lapply(x$layers, function(x, graphObject, file) {
+      .RewriteSVG(graphObject, file, x$geom)
+    }, graphObject = x, file = file)
 
-SVGThis.histogram =
-    function(x, file = ""test.svg"", ...) {
-      # really should check that the histogram wasn't plotted already before...
-      # but simpler to just do the plotting ourselves and close the device later
-      x  # ensure we create a histogram on a new graphics device
-      gridGraphics::grid.echo()  # hist() currently uses graphics package
-      # use gridSVG ideas in here
-      gridSVG::grid.garnish(
-          ""graphics-plot-1-bottom-axis-line-1"", title = ""the x axis"")
-      gridSVG::grid.garnish(
-          ""graphics-plot-1-left-axis-line-1"", title = ""the y axis"")
-      # these titles are included in the <g> tag not a <title> tag
-      .addInfo(""graphics-plot-1-bottom-axis-line-1"", title = ""the x axis"",
-              desc = ""need something much smarter in here"")
-      .addInfo(""graphics-plot-1-left-axis-line-1"", title = ""the y axis"",
-              desc = ""need something much smarter in here"")
-#.SVGThisBase(x)
-      # add class-specific content to svg file from here onwards
-      # short descriptions should be automatic, such as axis labels or marks
-      # long descriptions need to be constructed, such as describe all axis marks together
-      # find some way to embed the object from which the graph was created
-      gridSVG::grid.export(name = file)
-      dev.off()  # remove our graph window
-      .MakeTigerReady(svgfile = file)
-      return(invisible(NULL))
+    if (createDevice) {
+      dev.off()
     }
-
-.SVGThisBase = function(x){
-      # use gridSVG ideas in here
-      gridSVG::grid.garnish(
-          ""graphics-plot-1-bottom-axis-line-1"", title = ""the x axis"")
-      gridSVG::grid.garnish(
-          ""graphics-plot-1-left-axis-line-1"", title = ""the y axis"")
-      # these titles are included in the <g> tag not a <title> tag
-      .addInfo(""graphics-plot-1-bottom-axis-line-1"", title = ""the x axis"",
-              desc = ""need something much smarter in here"")
-      .addInfo(""graphics-plot-1-left-axis-line-1"", title = ""the y axis"",
-              desc = ""need something much smarter in here"")
+    .MakeTigerReady(svgfile = file)
+    return(invisible(NULL))
+  }
+
+
+
+SVGThis.histogram <-
+  function(x, file = ""test.svg"", ...) {
+    # really should check that the histogram wasn't plotted already before...
+    # but simpler to just do the plotting ourselves and close the device later
+    x # ensure we create a histogram on a new graphics device
+    gridGraphics::grid.echo() # hist() currently uses graphics package
+    # use gridSVG ideas in here
+    gridSVG::grid.garnish(
+      ""graphics-plot-1-bottom-axis-line-1"",
+      title = ""the x axis""
+    )
+    gridSVG::grid.garnish(
+      ""graphics-plot-1-left-axis-line-1"",
+      title = ""the y axis""
+    )
+    # these titles are included in the <g> tag not a <title> tag
+    .addInfo(""graphics-plot-1-bottom-axis-line-1"",
+      title = ""the x axis"",
+      desc = ""need something much smarter in here""
+    )
+    .addInfo(""graphics-plot-1-left-axis-line-1"",
+      title = ""the y axis"",
+      desc = ""need something much smarter in here""
+    )
+    # .SVGThisBase(x)
+    # add class-specific content to svg file from here onwards
+    # short descriptions should be automatic, such as axis labels or marks
+    # long descriptions need to be constructed, such as describe all axis marks together
+    # find some way to embed the object from which the graph was created
+    gridSVG::grid.export(name = file)
+    dev.off() # remove our graph window
+    .MakeTigerReady(svgfile = file)
+    return(invisible(NULL))
+  }
+
+.SVGThisBase <- function(x) {
+  # use gridSVG ideas in here
+  gridSVG::grid.garnish(
+    ""graphics-plot-1-bottom-axis-line-1"",
+    title = ""the x axis""
+  )
+  gridSVG::grid.garnish(
+    ""graphics-plot-1-left-axis-line-1"",
+    title = ""the y axis""
+  )
+  # these titles are included in the <g> tag not a <title> tag
+  .addInfo(""graphics-plot-1-bottom-axis-line-1"",
+    title = ""the x axis"",
+    desc = ""need something much smarter in here""
+  )
+  .addInfo(""graphics-plot-1-left-axis-line-1"",
+    title = ""the y axis"",
+    desc = ""need something much smarter in here""
+  )
 }
 
-SVGThis.scatterplot = function(x, file = ""test.svg"", ...) {
-x$x= x$data$x
-x$y = x$data$y
-x$data=NULL
-      suppressWarnings(do.call(plot, x))  # ensure we create a plot on a new graphics device
-      gridGraphics::grid.echo()  # plot() uses graphics package
-      gridSVG::grid.export(name = file)
-      dev.off()  # remove our graph window
-      .MakeTigerReady(svgfile = file)
-      .FileCreated(file)
-      return(invisible(NULL))
+SVGThis.scatterplot <- function(x, file = ""test.svg"", ...) {
+  x$x <- x$data$x
+  x$y <- x$data$y
+  x$data <- NULL
+  suppressWarnings(do.call(plot, x)) # ensure we create a plot on a new graphics device
+  gridGraphics::grid.echo() # plot() uses graphics package
+  gridSVG::grid.export(name = file)
+  dev.off() # remove our graph window
+  .MakeTigerReady(svgfile = file)
+  .FileCreated(file)
+  return(invisible(NULL))
 }
 
-SVGThis.tsplot = function(x, file = ""test.svg"", ...) {
-      suppressWarnings(do.call(plot, x))  # ensure we create a plot on a new graphics device
-      gridGraphics::grid.echo()  # plot() uses graphics package
-      gridSVG::grid.export(name = file)
-      dev.off()  # remove our graph window
-      .MakeTigerReady(svgfile = file)
-      .FileCreated(file)
-      return(invisible(NULL))
+SVGThis.tsplot <- function(x, file = ""test.svg"", ...) {
+  suppressWarnings(do.call(plot, x)) # ensure we create a plot on a new graphics device
+  gridGraphics::grid.echo() # plot() uses graphics package
+  gridSVG::grid.export(name = file)
+  dev.off() # remove our graph window
+  .MakeTigerReady(svgfile = file)
+  .FileCreated(file)
+  return(invisible(NULL))
 }

---FILE: man/MakeAccessibleSVGMethod.Rd---
@@ -9,9 +9,12 @@
 \title{Create and display a accessible exploration webpage SVG of graph}
 \description{Creates the necessary SVG and XML files for a graph object (as long as it has a class assigned). Then turns them into a html file and opens it for viewing (if a interactive session) in your browser.}
 \usage{
-MakeAccessibleSVG(x, file = paste0(deparse(substitute(x)), ""-SVG""), view=interactive(), cleanup = TRUE, ...)
-
-MakeAccessibleSVG.ggplot(x, file = paste0(deparse(substitute(x)), ""-SVG""), view=interactive(), cleanup = TRUE, VI_and_Describe = TRUE, ...)
+MakeAccessibleSVG(x,
+file = paste0(deparse(substitute(x)), ""-SVG""),
+view=interactive(), cleanup = TRUE, ...)
+\method{MakeAccessibleSVG}{ggplot}(x,
+file = paste0(deparse(substitute(x)), ""-SVG""),
+view=interactive(), cleanup = TRUE, VI_and_Describe = TRUE, ...)
 }
 \arguments{
   \item{x}{a graph object for which a method exists}"
ajrgodfrey,BrailleR,3824f97587b6820007c71081960a746652bf0f94,James,1jamesthompson1@gmail.com,2023-01-20T01:36:20Z,James,1jamesthompson1@gmail.com,2023-01-20T01:36:20Z,0.33.4 Fix error with Describe not letting you choose the layer you want using the parameter.,R/Describe.R,False,True,True,False,117,116,233,"---FILE: R/Describe.R---
@@ -1,143 +1,144 @@
 
 
-#The heavy lifting of this function is done with these internal functions which 
-#Interact with the mustache templates.
-
-#This method is somewhat inefficient as it will just get slower and slower as more templates are added.
-.readTxtCSV = function(location) {
-  temp = read.csv(system.file(paste0(""whisker/"", location), package=""BrailleR""), header = T, as.is = T)
-  sublists = length(temp) > 2
-  templates = list()
-  for (plot in 1:length(temp[,1])) {
-    templates[[temp[plot,1]]] = if (sublists) {
-      sublist = as.list(gsub(""\n"", """",temp[plot,2:length(temp)]))
-      names(sublist) = colnames(temp)[2:length(temp)]
+# The heavy lifting of this function is done with these internal functions which
+# Interact with the mustache templates.
+
+# This method is somewhat inefficient as it will just get slower and slower as more templates are added.
+.readTxtCSV <- function(location) {
+  temp <- read.csv(system.file(paste0(""whisker/"", location), package = ""BrailleR""), header = T, as.is = T)
+  sublists <- length(temp) > 2
+  templates <- list()
+  for (plot in 1:length(temp[, 1])) {
+    templates[[temp[plot, 1]]] <- if (sublists) {
+      sublist <- as.list(gsub(""\n"", """", temp[plot, 2:length(temp)]))
+      names(sublist) <- colnames(temp)[2:length(temp)]
       sublist
     } else {
-      gsub(""\n"", """",temp[plot,2])
+      gsub(""\n"", """", temp[plot, 2])
     }
   }
   return(templates)
 }
 
-.renderDescription = function(name, baseR = T) {
+.renderDescription <- function(name, baseR = T) {
   if (baseR) {
-    template = .readTxtCSV(""Describe/baseR.txt"")
+    template <- .readTxtCSV(""Describe/baseR.txt"")
   } else {
-    template = .readTxtCSV(""Describe/ggplot.txt"")
+    template <- .readTxtCSV(""Describe/ggplot.txt"")
   }
-  generics = .readTxtCSV(""Describe/generics.txt"")
-  
-  rendered = list(
-    title = whisker::whisker.render(template = template[[name]][""title""], data=generics),
-    general = whisker::whisker.render(template = template[[name]][""general""], data=generics),
-    RHints = whisker::whisker.render(template = template[[name]][""RHints""], data=generics)
+  generics <- .readTxtCSV(""Describe/generics.txt"")
+
+  rendered <- list(
+    title = whisker::whisker.render(template = template[[name]][""title""], data = generics),
+    general = whisker::whisker.render(template = template[[name]][""general""], data = generics),
+    RHints = whisker::whisker.render(template = template[[name]][""RHints""], data = generics)
   )
-  class(rendered) = ""description""
+  class(rendered) <- ""description""
   return(rendered)
 }
 
-Describe = 
-    function(x, VI=FALSE, ...){
-      UseMethod(""Describe"")
-    }
+Describe <-
+  function(x, VI = FALSE, ...) {
+    UseMethod(""Describe"")
+  }
 
-print.description = 
-    function(x, ...){
-        template = paste(readLines(system.file(""whisker/Describe/Describedefault.txt"", package=""BrailleR"")), collapse=""\n"")
-        output = whisker::whisker.render(template, x)
-        cat(output, ""\n\n"")
-        return(invisible(NULL))
-    }
+print.description <-
+  function(x, ...) {
+    template <- paste(readLines(system.file(""whisker/Describe/Describedefault.txt"", package = ""BrailleR"")), collapse = ""\n"")
+    output <- whisker::whisker.render(template, x)
+    cat(output, ""\n\n"")
+    return(invisible(NULL))
+  }
 
-print.multiDescription = 
-    function(x, ...){
-      for (element in x) {
-        print(element)
-      }
+print.multiDescription <-
+  function(x, ...) {
+    for (element in x) {
+      print(element)
     }
+  }
 
-Describe.default = 
-    function(x, VI=FALSE, ...){
-        if(VI) VI(x)
-        .renderDescription(""default"")
-    }
+Describe.default <-
+  function(x, VI = FALSE, ...) {
+    if (VI) VI(x)
+    .renderDescription(""default"")
+  }
 
-Describe.histogram = 
-    function(x, VI=FALSE, ...){
-        if(VI) VI(x)
-        .renderDescription(""histogram"")
-    }
+Describe.histogram <-
+  function(x, VI = FALSE, ...) {
+    if (VI) VI(x)
+    .renderDescription(""histogram"")
+  }
 
-Describe.scatterplot = 
-    function(x, VI=FALSE, ...){
-        if(VI) VI(x)
-        .renderDescription(""scatterplot"")
+Describe.scatterplot <-
+  function(x, VI = FALSE, ...) {
+    if (VI) VI(x)
+    .renderDescription(""scatterplot"")
+  }
+
+Describe.tsplot <-
+  function(x, VI = FALSE, ...) {
+    if (VI) VI(x)
+    .renderDescription(""tsplot"")
+  }
+
+Describe.ggplot <-
+  function(x, VI = FALSE, whichLayer = NULL, ...) {
+    if (VI) VI(x)
+    layers <- x$layers
+
+    # Interactive version to find out which layers to print
+    if (length(layers) == 1) {
+      whichLayer <- 1
+    } else if (is.null(whichLayer) && interactive()) {
+      cat(""Please select which layers you will want to see descriptions for:\n"")
+      for (i in seq_along(layers)) {
+        cat(i, "": "", class(layers[[i]]$geom)[1], ""\n"")
+      }
+      cat(""Each layer should be seperated by a comma\n"")
+      userInput <- readline(prompt = ""Which layers do you want to see? "")
+      whichLayer <- gsub("" "", """", userInput) |>
+        strsplit(split = "","") |>
+        lapply(FUN = strtoi) |>
+        unlist()
+      # Default for non interactive is to print all layers
+    } else if (!interactive() || whichLayer == ""all"") {
+      whichLayer <- 1:length(layers)
     }
 
-Describe.tsplot = 
-    function(x, VI=FALSE, ...){
-        if(VI) VI(x)
-        .renderDescription(""tsplot"")
+    # Filter out any number that arent
+    whichLayer <- whichLayer[whichLayer %in% 1:length(layers)]
+    # Get the descriptions of the layers
+    descriptions <- list()
+    for (layer in whichLayer) {
+      currentClass <- class(layers[[layer]]$geom)[1]
+      descriptions[[currentClass]] <- .renderDescription(currentClass, F)
     }
 
-Describe.ggplot = 
-    function(x, VI=FALSE, whichLayer = NULL, ...){
-      if(VI) VI(x)
-      layers = x$layers
-      
-      #Interactive version to find out which layers to print
-      if (length(layers) == 1) {
-        whichLayer = 1
-      } else if(is.null(whichLayer) && interactive()) {
-          cat(""Please select which layers you will want to see descriptions for:\n"")
-          for(i in seq_along(layers)) {
-            cat(i,"": "", class(layers[[i]]$geom)[1],""\n"")
-          }
-          cat(""Each layer should be seperated by a comma\n"")
-          userInput = readline(prompt=""Which layers do you want to see? "")
-          whichLayer = gsub("" "", """", userInput) |>
-            strsplit(split="","") |>
-            lapply(FUN=strtoi) |> 
-            unlist()
-      #Default for non interactive is to print all layers
-      } else {
-        whichLayer = 1:length(layers)
-      }
-      
-      #Filter out any number that arent 
-      whichLayer = whichLayer[whichLayer %in% 1:length(layers)]
-      #Get the descriptions of the layers
-      descriptions = list()
-      for (layer in whichLayer) {
-        currentClass = class(layers[[layer]]$geom)[1]
-        descriptions[[currentClass]] = .renderDescription(currentClass, F)
-      }
-      
-      #Make sure that all descriptions actually have a valid descriptions
-      descriptions = descriptions[
-        lapply(descriptions,
-               \(desc) {
-                  nchar(desc$title) + nchar(desc$general) + nchar(desc$RHints) != 0
-            }
-        ) |> unlist()
-      ]
-      
-      
-      #Output multiple descriptions
-      if (length(descriptions) > 1) {
-        class(descriptions) = ""multiDescription""
-        return(descriptions)
-      #No valid indexes
-      } else if (length(whichLayer) == 0){
-        warning(""You havent entered any valid layer indexes"")
-        return(NULL)
-      #No available description
-      } else if (length(descriptions) == 0){
-        warning(""None of you selected layers have a description yet."")
-        return(NULL)
-      #Only one description
-      } else {
-        return(descriptions[[1]])
-      }
+    # Make sure that all descriptions actually have a valid descriptions
+    descriptions <- descriptions[
+      lapply(
+        descriptions,
+        \(desc) {
+          nchar(desc$title) + nchar(desc$general) + nchar(desc$RHints) != 0
+        }
+      ) |> unlist()
+    ]
+
+
+    # Output multiple descriptions
+    if (length(descriptions) > 1) {
+      class(descriptions) <- ""multiDescription""
+      return(descriptions)
+      # No valid indexes
+    } else if (length(whichLayer) == 0) {
+      warning(""You havent entered any valid layer indexes"")
+      return(NULL)
+      # No available description
+    } else if (length(descriptions) == 0) {
+      warning(""None of you selected layers have a description yet."")
+      return(NULL)
+      # Only one description
+    } else {
+      return(descriptions[[1]])
     }
+  }"
ajrgodfrey,BrailleR,d7828379f6537e173879dbbd4263ede12e8e4250,James,1jamesthompson1@gmail.com,2023-01-19T03:33:18Z,James,1jamesthompson1@gmail.com,2023-01-19T03:33:18Z,Fix mismatch paramet names.,R/AddXMLInternal.R,False,True,True,False,5,5,10,"---FILE: R/AddXMLInternal.R---
@@ -346,7 +346,7 @@
         position = i,
         id = smoothLineGrob$name,
         speech = desc,
-        CI_ID = seGrob
+        seGrobs = seGrob
       )
     }
   } else { # TODO:  warn about layer types we don't recognize
@@ -360,17 +360,17 @@
 
 # Still a work in progress as the se bars are not shown.
 # TODO: make se bars actually display.
-.AddXMLSmooth <- function(root, position = 1, id = NULL, speech, speech2 = speech, seGrob_ID = NULL) {
+.AddXMLSmooth <- function(root, position = 1, id = NULL, speech, speech2 = speech, seGrobs = NULL) {
   annotation <- .AddXMLAddAnnotation(root, position = position, id = paste(id, 1, position, sep = "".""), kind = ""active"")
   XML::addAttributes(annotation$root, speech = speech, speech2 = speech2)
 
   ## This current section doesn't do anything to display the error bars.
   ## Work need to be done on this
-  if (!rlang::is_empty(seGrob_ID)) {
-    .AddXMLAddAnnotation(root, position = position, id = paste0(seGrob_ID[[1]]$name, "".1"", "".1""), kind = ""passive"") |>
+  if (!rlang::is_empty(seGrobs)) {
+    .AddXMLAddAnnotation(root, position = position, id = paste0(seGrobs[[1]]$name, "".1"", "".1""), kind = ""passive"") |>
       list() |>
       .AddXMLAddComponents(annotation, node = _)
-    .AddXMLAddAnnotation(root, position = position, id = paste0(seGrob_ID[[2]]$name, "".1"", "".1""), kind = ""passive"") |>
+    .AddXMLAddAnnotation(root, position = position, id = paste0(seGrobs[[2]]$name, "".1"", "".1""), kind = ""passive"") |>
       list() |>
       .AddXMLAddComponents(annotation, node = _)
   }"
ajrgodfrey,BrailleR,3813af2aa757587bec06c512e7b77c8049f79922,James,1jamesthompson1@gmail.com,2023-01-15T21:57:25Z,James,1jamesthompson1@gmail.com,2023-01-15T21:57:25Z,"Fix build errors and cleanup files from examples

There were additional help pages and the old GettingStarted vignettes added back in. These have been removed.

Also all of the SVG examples were leaving residual files. For completeness these are now explicitly deleted.",R/ViewSVG.R;man/AddXMLMethod.Rd;man/BrowseSVG.Rd;man/MakeAccessibleSVGMethod.Rd;man/SVGThis.Rd;man/VI.ggplot.Rd;man/ViewSVG.Rd;vignettes/GettingStarted.Rmd,True,True,True,False,21,149,170,"---FILE: R/ViewSVG.R---
@@ -20,7 +20,7 @@ ViewSVG = function(file = ""index""){
   
   
   if(interactive()){
-    browseURL(""index.html"") 
+    browseURL(fileName) 
   }
   
   return(invisible(NULL))

---FILE: man/AddXMLMethod.Rd---
@@ -53,6 +53,8 @@ AddXML(simpleHist, file = ""histogram.xml"")
 # Close the current PDF graphic device
 dev.off()
 
+#Cleaning up afterwards
+unlink(""histogram.xml"")
 }
 
 \seealso{

---FILE: man/BrowseSVG.Rd---
@@ -37,6 +37,11 @@ xmlfile = AddXML(simpleHist, paste0(file, "".xml""))
 dev.off()  # destroy graphics device, now that we're done with it
 
 BrowseSVG(file)
+
+#Cleaing up from BrowseSVG
+unlink(paste0(file, "".svg""))
+unlink(paste0(file, "".xml""))
+unlink(paste0(file, "".html""))
 }
 
 \seealso{

---FILE: man/MakeAccessibleSVGMethod.Rd---
@@ -46,6 +46,9 @@ histogram = ggplot(attenu, aes(x=dist)) +
 geom_histogram()
   histogram
 MakeAccessibleSVG(histogram)
+
+# Cleaning up
+unlink(""test.html"")
 }
 
 \references{

---FILE: man/SVGThis.Rd---
@@ -45,6 +45,9 @@ P. Dengler et al. (2011) Scalable vector graphics (SVG) 1.1, second edition. W3C
 library(ggplot2)
 p = ggplot(mtcars, aes(x=wt, y=mpg)) + geom_point()
 SVGThis(p)
+
+# Cleaning up afterwards
+unlink(""test.svg"")
 }
 
 \seealso{

---FILE: man/VI.ggplot.Rd---
@@ -1,41 +0,0 @@
-\name{VI.ggplot}
-\alias{VI.ggplot}
-\alias{print.VIgraph}
-\title{VI for graphs created using ggplot2}
-\usage{
-\method{VI}{ggplot}(x, Describe=FALSE, threshold=10, 
-   template=system.file(""whisker/VIdefault.txt"", package=""BrailleR""),
-   ...)
-}
-\arguments{
-\item{x}{an object created by ggplot() or qplot() from the ggplot2 package which therefore has class gg or ggplot.}
-\item{Describe}{Should the Describe function be called at the same time. Not currently implemented for ggplot objects.}
-\item{threshold}{Maximum number of data items that should be individually listed in the output.}
-\item{template}{Template file, in mustache format, to be used in creating the text}
-\item{...}{other arguments, currently ignored}
-}
-\value{
-Returns a structure containing a hierarchical representation of the graph as well as the text description as a character vector.  When run interactively, the text
-description is printed.
-}
-\description{
-Prints a textual description of a graph produced by ggplot or qplot.
-}
-\note{
-This function is experimental.  The ggplot2 package produces many different types
-of graphs and offers many options for modifying the graph appearance. Not all
-options have been fully catered for, so text descriptions of these graphs may still be less complete than those created using base graphics, or may be 
-misleading in some circumstances.
-}
-\examples{
-if(require(ggplot2)){
-g = ggplot(economics_long, aes(date, value01, colour = variable))
-g = g + geom_line() + ggtitle('dummy title')
-VI(g)
-g
-}
-}
-\author{
-Sophie Banks, Debra Warren, Tony Hirst, A. Jonathan R. Godfrey and James A. Thompson
-}
-

---FILE: man/ViewSVG.Rd---
@@ -40,6 +40,13 @@ MakeAccessibleSVG(histogram, file=""histogram"")
 
 # Display the 'home' page
 ViewSVG()
+
+# Cleaning up afterwards
+# Created by the MakeAccessibleSVG (xml and svg are auto deleted)
+unlink(""histogram.html"")
+unlink(""barChart.html"")
+unlink(""tsplot.html"")
+unlink(""index.html"") # Created by the ViewSVG function
 }
 
 \seealso{

---FILE: vignettes/GettingStarted.Rmd---
@@ -1,107 +0,0 @@
----
-title: ""Getting started with the BrailleR package""
-author: ""A. Jonathan R. Godfrey""
-bibliography: BrailleRPublications.bib
-vignette: >
-  %\VignetteIndexEntry{GettingStarted}
-  %\VignetteEngine{knitr::rmarkdown}
-output: knitr:::html_vignette
----
-
-The BrailleR package has been created for the benefit of blind people wishing to
-get more out of R than it already offers --- which is actually quite a
-lot!
-
-## What you need
-
-You obviously have R installed or an intention to do so soon if you are reading this document. Aside from R and the add-on packages that BrailleR needs, there are no other software requirements. There are several optional software installations that could make life easier if they are installed before you need them. In order of necessity, they are:
-
-### The document converter --- pandoc
-
-BrailleR requires the very useful file converter called pandoc. Get it from the 
-[pandoc download page](https://github.com/jgm/pandoc/releases)
-
-### The principal integrated development environment --- RStudio
-
-It is a good idea to install RStudio, even if you can't actually use it as a blind person using screen reading software. The reason is that RStudio installs a few other useful tools that we will make use of by other means. Get it from the
-[RStudio download page](https://posit.co/download/rstudio-desktop/)
-
-### One programming language --- Python
-
-WriteR is a simple text editor written in wxPython that needs Python and wxPython. Unfortunately, they are two separate downloads at present. You do not need this editor so do not install Python unless you are really keen. 
-
-
-## Installing the BrailleR package
-
-To use the functionality of the BrailleR package you need to have it installed. The package has several dependencies so installation from the CRAN repository is recommended. This would be done by issuing the following two commands in an R session:
-```{r download, eval=FALSE}
-chooseCRANmirror(ind=1)
-install.packages(""BrailleR"")
-```
-
-If for some reason you have difficulty with the above commands, you can install the BrailleR package using a zip file version available from a CRAN repository or the latest version on GitHub. 
-
-From time to time, you should check that you are using the most recent version of the BrailleR package. You  can update all installed packages using the commands:
-```{r update, eval=FALSE}
-chooseCRANmirror(ind=1)
-update.packages(ask=FALSE)
-```
-
-Once you've got the package installed, you still need to get it running in your current R session by issuing one last command. When you issue the first of the following lines, the package start messages will also appear.
-```{r start, eval=FALSE}
-library(BrailleR)
-```
-
-You're ready to go!
-
-## Why will I use the BrailleR package as a novice?
-
-Blind users will want to use the BrailleR package while they are novice R users, but may also want to continue using some of the tools as their skill levels increase. Each of the following reasons for using the BrailleR package have their own example document which goes into more detail.
-
-### BrailleR improves the accessibility of graphical information 
-
-BrailleR converts standard graphs created by standard R commands into a textual form that can
-be interpreted by blind students who cannot access the graphs without
-printing the image to a tactile embosser, or who need the extra text to
-support any tactile images they do create.
-
-At present this is limited to only a few graph types found in base R functionality. [Example 1 shows how histogram](Ex1histograms.html) can be converted to a text representation.
-
-### BrailleR helps gain access to the content of the R console
-
-BrailleR makes text output (that is
-visually appealing) more useful for a blind user who is reliant on
-synthesized speech or braille output to interpret the results.
-
-[Example 2 on data summaries](Ex2BasicNumerical.html) shows this for a data frame.
-
-### BrailleR includes convenience functions
-
-Many analyses get repeated over and over again with different variables. Some people like a graphical user interface (GUI) but none of the GUIs developed for R to date are accessible by screen reader users.
-
-BrailleR includes some functions which generate pro forma analyses. When these functions are employed, they generate an HTML document that includes the analysis in an easy to use format. The R commands used to create the analysis are stored in an R script file so that a user can modify the commands if changes are necessary.
-
-[Example 3 Univariate Description](Ex3UnivariateDescription.html) shows how the UniDesc() function works, and [Example 4 for one response and one factor](Ex4SingleResponseOneGroupingFactor.html) shows how descriptive tools are created before a simple one-way analysis of variance model is fitted.
-
-
-## Why will I use the BrailleR package if I am not a novice?
-
-I think some of the reasons for using the package while you are  a novice R user remain relevant to more-experienced users, but perhaps the main reason for continuing to use BrailleR is that of efficiency. The convenience functions give you a starting point for analyses. Behind those convenience functions was an R markdown file that generated the R script and the HTML document. Getting into markdown is a great idea and will not take you long to learn.
-
-BrailleR also includes some tools for helping run your R jobs without running R. Experienced users do this all the time so these tools aren't really meant for blind users alone.
- 
-## Personalising BrailleR
-
-Once you've played with a few examples, you might want to settle on the way you want BrailleR to work for you.
-
-You might want your analyses to use your name instead of the default name `BrailleR`. Do this using the `SetAuthor()` function. e.g.
-```{r SetAuthor, eval=FALSE}
-SetAuthor(""Jonathan Godfrey"")
-```
-OK, you ought to use your name not mine, but you get the point.
-
-
-
-
-
-"
ajrgodfrey,BrailleR,2cab4fe1daf9a9dda66e3877b1e6edc3bc5a594e,James,1jamesthompson1@gmail.com,2023-01-11T02:36:39Z,James,1jamesthompson1@gmail.com,2023-01-11T02:36:39Z,"Fix up ignore files

It will now ignore both user folder and proj file.",.Rbuildignore;.gitignore,False,False,False,False,6,2,8,"---FILE: .Rbuildignore---
@@ -1,7 +1,9 @@
+^.*\.Rproj$
 ^CONDUCT\.md$
-^cran-comments\.md$
-^readme.md$
+^\.Rproj\.user$
 ^\.github$
 ^_pkgdown\.yml$
+^cran-comments\.md$
 ^docs$
 ^pkgdown$
+^readme.md$

---FILE: .gitignore---
@@ -2,3 +2,5 @@
 docs
 .Rhistory
 .RData
+BrailleR.Rproj
+.Rproj.user"
ajrgodfrey,BrailleR,f1060b0a4455e7c71c98b4404740b106e71a8f4f,ajrgodfrey,ajgodfre@massey.ac.nz,2023-01-05T06:09:37Z,ajrgodfrey,ajgodfre@massey.ac.nz,2023-01-05T06:09:37Z,v0.33.4 attempting to fix pkgdown,DESCRIPTION;_pkgdown.yml,False,False,False,False,5,2,7,"---FILE: DESCRIPTION---
@@ -31,7 +31,8 @@ Description: Blind users do not have access to the graphical output from R
     functionality for optimising graphical content to prepare it for
     embossing as tactile images.
 License: GPL-2
-URL: https://github.com/ajrgodfrey/BrailleR
+URL: https://github.com/ajrgodfrey/BrailleR,
+    http://ajrgodfrey.github.io/BrailleR/
 BugReports: https://github.com/ajrgodfrey/BrailleR/issues
 Depends:
     R (>= 3.4.0)

---FILE: _pkgdown.yml---
@@ -1,2 +1,4 @@
-url: ~
+url: http://ajrgodfrey.github.io/BrailleR/
+template:
+  bootstrap: 5
 "
ajrgodfrey,BrailleR,5b590471c641fcb938acaa349017056d9146ca4a,James,1jamesthompson1@gmail.com,2022-12-08T21:37:50Z,James,1jamesthompson1@gmail.com,2022-12-08T21:37:50Z,"0.33.4 Reinstate the TSPlot examples

They ahve been added back in as they dont seem to cause any errors.",man/TSPlot.Rd,False,False,False,False,19,17,36,"---FILE: man/TSPlot.Rd---
@@ -37,25 +37,27 @@ A. Jonathan R. Godfrey and James A. Thompson
 }
 \examples{
 # with base
-#attach(airquality)
-#op = par(mfcol=c(3,2))
-#plot(as.ts(Wind), ylab=""Wind"", col=4)
-#test1 = TimeSeriesPlot(x=Wind, col=4, base=TRUE)
-#test1 #does the plot method work?
-#plot(as.ts(Ozone), ylab=""Ozone"")
-#test2 = TimeSeriesPlot(x=Ozone, base=TRUE)
-#test2 # does the plot method work?
-#par(op)
-#detach(airquality)
+attach(airquality)
+op = par(mfcol=c(3,2))
+plot(as.ts(Wind), ylab=""Wind"", col=4)
+test1 = TimeSeriesPlot(x=Wind, col=4, base=TRUE)
+test1 #does the plot method work?
+plot(as.ts(Ozone), ylab=""Ozone"")
+test2 = TimeSeriesPlot(x=Ozone, base=TRUE)
+test2 # does the plot method work?
+par(op)
+detach(airquality)
 
 # with ggplot
 if(require(ggplot2)){
-#  basic = TimeSeriesPlot(airquality, x=airquality$Temp)
-#  basic
-  #ts data
-#  withTitle = TimeSeriesPlot(UKDriverDeaths,  main = ""UK driver deaths"", sub = ""For the month Januaray"")
-#  withTitle
-#  withLabs = TimeSeriesPlot(sunspots, ylab=""Number of spots"", xlab=""Year"")
-#  withLabs
+   basic = TimeSeriesPlot(airquality, x=airquality$Temp)
+   basic
+   # ts data
+   withTitle = TimeSeriesPlot(UKDriverDeaths,  
+    main = ""UK driver deaths"",
+    sub = ""For the month Januaray"")
+   withTitle
+   withLabs = TimeSeriesPlot(sunspots, ylab=""Number of spots"", xlab=""Year"")
+   withLabs
 }
 }"
ajrgodfrey,BrailleR,d73457d3340a98810ee2f85fe193537580d12739,1jamesthompson1,103026808+1jamesthompson1@users.noreply.github.com,2022-12-07T21:17:04Z,GitHub,noreply@github.com,2022-12-07T21:17:04Z,"add specification forXML

Seems to be a bit of a known error, It supposedly fixed recently but I don't think it has made it to release yet to.

https://github.com/r-lib/actions/issues/559#issuecomment-1249009987

This could help.",.github/workflows/pkgdown.yaml,False,False,False,False,1,1,2,"---FILE: .github/workflows/pkgdown.yaml---
@@ -23,7 +23,7 @@ jobs:
 
       - uses: r-lib/actions/setup-r-dependencies@v2
         with:
-          extra-packages: any::pkgdown, local::.
+          extra-packages: any::pkgdown, any::XML, local::.
           needs: website
 
       - name: Deploy package"
ajrgodfrey,BrailleR,c23fac61ea94b0652e29ad65f3ad7c3d7881dce5,James,1jamesthompson1@gmail.com,2022-12-06T23:45:45Z,James,1jamesthompson1@gmail.com,2022-12-06T23:45:45Z,"0.33.4 Fix build errors with TSPlot

Fixed errors with RD help file
Added imports to the NAMESPACE
Update tsplot code a bit for it to work with ts data correctly and handle the labels and title correctly.",NAMESPACE;R/TSPlot.R;man/TSPlot.Rd,False,True,True,False,28,17,45,"---FILE: NAMESPACE---
@@ -1,7 +1,7 @@
 importFrom(""devtools"", ""spell_check"")
 import(dplyr)
 import(extrafont)
-importFrom(""ggplot2"", ""aes"", ""geom_point"", ""geom_smooth"", ""ggplot"", ""ggplot_build"", ""qplot"") 
+importFrom(""ggplot2"", ""aes"", ""geom_point"", ""geom_smooth"", ""ggplot"", ""ggplot_build"", ""qplot"", ""labs"", ""ylab"", ""xlab"", ""geom_line"") 
 importFrom(""graphics"", ""abline"", ""par"", ""plot"") 
 importFrom(""grDevices"", ""dev.cur"", ""dev.list"", ""pdf"") 
 import(grid)
@@ -18,7 +18,7 @@ importFrom(""rlang"", ""is_true"")
 import(rmarkdown)
 import(roloc)
 import(rolocISCCNBS)
-importFrom(""stats"", ""aggregate"", ""anova"", ""as.ts"", ""coef"", ""cor"", ""lm"", ""median"", ""na.omit"", ""qnorm"", ""rstudent"", ""sd"") 
+importFrom(""stats"", ""aggregate"", ""anova"", ""as.ts"", ""coef"", ""cor"", ""lm"", ""median"", ""na.omit"", ""qnorm"", ""rstudent"", ""sd"", ""is.ts"") 
 importFrom(""tools"", ""Rd2ex"")
 importFrom(""utils"", ""browseURL"", ""create.post"", ""download.file"", ""file.edit"", ""head"", ""menu"", ""packageVersion"", ""read.csv"", ""read.table"", ""savehistory"", ""Sweave"", ""str"", ""tail"", ""unzip"", ""write.csv"") 
 importFrom(""whisker"", ""whisker.render"")

---FILE: R/TSPlot.R---
@@ -3,13 +3,9 @@
 TimeSeriesPlot = function(.data, x, time=NULL, base=FALSE, ...){
   Out = list()
   MC = match.call(expand.dots = TRUE)
-  MC$ylab= ifelse(is.null(MC$ylab), as.character(MC$x), MC$ylab)
-  if (length(MC$sub) > 0) Out$sub = as.character(MC$sub)
-  if (length(MC$xlab) > 0) Out$xlab = as.character(MC$xlab) else {Out$xlab = ""Time""}
-  if (length(MC$ylab) > 0) Out$ylab = as.character(MC$ylab)
   if(base){
     Out = list(x=as.ts(x))
-
+    MC$ylab= ifelse(is.null(MC$ylab), as.character(MC$x), MC$ylab)
     MC[[1L]] <- quote(graphics::plot)
     MC$x <- Out$x
     
@@ -18,16 +14,31 @@ TimeSeriesPlot = function(.data, x, time=NULL, base=FALSE, ...){
     Out$par = par()
     class(Out) = ""tsplot""
     if (length(MC$main) > 0) Out$main = as.character(MC$main) else {Out$main = """"}
+    if (length(MC$sub) > 0) Out$sub = as.character(MC$sub)
+    if (length(MC$xlab) > 0) Out$xlab = as.character(MC$xlab) else {Out$xlab = ""Time""}
+    if (length(MC$ylab) > 0) Out$ylab = as.character(MC$ylab)
     Out=Augment(Out)
   }
   else{ ## do it in ggplot2
+    print(MC$ylab)
+    MC$ylab = ifelse(is.null(MC$ylab), tail(strsplit(as.character(MC$x), ""$""),n=1), MC$ylab)
+    if (length(MC$sub) > 0) Out$sub = as.character(MC$sub)
+    if (length(MC$xlab) > 0) Out$xlab = as.character(MC$xlab) else {Out$xlab = ""Time""}
+    if (length(MC$ylab) > 0) Out$ylab = as.character(MC$ylab)
+    if (length(MC$main) > 0) Out$main = as.character(MC$main)
+    
+    #Special care has to be taken if it is a dataframe
     if (is.ts(.data)) {
+      #Sort out data frame
       .data = data.frame(Y=as.matrix(.data), date=time(.data))
       time = .data$date
       x = .data$Y
+      #Get correct ylab
+      Out$ylab = ifelse(is.null(MC$ylab[[1]]), deparse(MC$.data), MC$ylab)
     }
-    if (length(MC$main) > 0) Out$main = as.character(MC$main)
+    
     if (is.null(time)) time = 1:length(x)
+    
     Out = ggplot(.data, aes(y=x, x=time)) +
       geom_line() +
       ylab(Out$ylab) + xlab(Out$xlab) +

---FILE: man/TSPlot.Rd---
@@ -7,7 +7,6 @@
 \description{This function is a wrapper to the standard \code{plott()} function in the \pkg{graphics} package. It is tailored to generating a time series plot, and adds detail to the stored object so that a better text description can be formulated using the \code{VI()} method in the \pkg{BrailleR} package. The function will become redundant once all other \pkg{BrailleR} functionality is working well with ggplot style graphics.}
 \usage{
 TimeSeriesPlot(.data, x, time=NULL, base=FALSE, ...)
-TimeSeriesPlot(.data, x, base=TRUE, ...)
 }
 \arguments{
 \item{.data}{the data.frame from which variables are drawn. Ignored if using base graphics.}
@@ -50,12 +49,13 @@ par(op)
 detach(airquality)
 
 # with ggplot
-#Normal data
-basic = TimeSeriesPlot(airquality, x=Temp)
-basic
-#ts data
-withTitle = TimeSeriesPlot(UKDriverDeaths,  main = ""UK driver deaths"", sub = ""For the month Januaray"")
-withTitle
-withLabs = TimeSeriesPlot(sunspots, ylab=""Number of spots"", xlab=""Year"")
-withLabs
+if(require(ggplot2)){
+  basic = TimeSeriesPlot(airquality, x=airquality$Temp)
+  basic
+  #ts data
+  withTitle = TimeSeriesPlot(UKDriverDeaths,  main = ""UK driver deaths"", sub = ""For the month Januaray"")
+  withTitle
+  withLabs = TimeSeriesPlot(sunspots, ylab=""Number of spots"", xlab=""Year"")
+  withLabs
+}
 }"
ajrgodfrey,BrailleR,6994cfe6698d9761c989aa3fc2cc0f1bda075421,James,1jamesthompson1@gmail.com,2022-12-06T20:44:21Z,James,1jamesthompson1@gmail.com,2022-12-06T20:44:21Z,"0.33.4 resolves #67

This hopefully with remove the build error by only importing the required functions from XML package. Have to push to repo to see if it will build properly.",NAMESPACE,False,False,False,False,1,1,2,"---FILE: NAMESPACE---
@@ -22,7 +22,7 @@ importFrom(""stats"", ""aggregate"", ""anova"", ""as.ts"", ""coef"", ""cor"", ""lm"", ""median""
 importFrom(""tools"", ""Rd2ex"")
 importFrom(""utils"", ""browseURL"", ""create.post"", ""download.file"", ""file.edit"", ""head"", ""menu"", ""packageVersion"", ""read.csv"", ""read.table"", ""savehistory"", ""Sweave"", ""str"", ""tail"", ""unzip"", ""write.csv"") 
 importFrom(""whisker"", ""whisker.render"")
-import(XML)
+importFrom(""XML"", ""addAttributes"", ""newXMLDoc"", ""newXMLNode"", ""ensureNamespace"", ""newXMLTextNode"", ""xmlName"", ""xmlRoot"", ""saveXML"", ""getNodeSet"", ""xmlGetAttr"", ""addChildren"", ""removeChildren"", ""xmlChildren"")
 importFrom(""xtable"", ""xtable"")
 S3method(AddXML,default)
   S3method(AddXML,boxplot)"
ajrgodfrey,BrailleR,9502e0988a4e33c88d4631c4a2cab9b9eda17a17,ajrgodfrey,ajgodfre@massey.ac.nz,2022-12-06T19:24:18Z,ajrgodfrey,ajgodfre@massey.ac.nz,2022-12-06T19:24:18Z,v0.33.4 fix ups,R/WriteR.R,False,True,True,False,8,3,11,"---FILE: R/WriteR.R---
@@ -1,9 +1,14 @@
 
+
+.RunWriteRExecutable = function(file=NULL){
+            shell(paste0(Sys.which(""WriteR""), ifelse(is.null(file), """", file)), wait=FALSE)
+}
+)
 .IsWriteRAvailable =
     function(){
       Success = FALSE
       PyExists = TestPython()
-      if(PyExists && .IsWxAvailable()){
+      if(PyExists && .sWxAvailable()){
         Success=TRUE
       }else{
         if(PyExists){
@@ -22,10 +27,10 @@ WriteR =
     function(file = NULL, math = c(""webTeX"", ""MathJax"")) {
       if (interactive()) {
         if (.Platform$OS.type == ""windows"") {
-          if (.IsWriteRAvailable()) {
+          if (.IsWriteRAvailable() | Sys.which(""WriteR"") != """") {
             if (!is.null(file)) {
               if (!file.exists(file)) {
-                #cat(""Starting new file\n"", file = file)
+                .FileCreated(file=file, where=""in the current directory."") 
                 file.copy(system.file(""Templates/simpleYAMLHeader.Rmd"", package=""BrailleR""), file)
               }
             }"
ajrgodfrey,BrailleR,25421944882562b6d24df196e75094299a358730,James,1jamesthompson1@gmail.com,2022-12-06T03:46:13Z,James,1jamesthompson1@gmail.com,2022-12-06T03:46:13Z,"fix build error

Forgot to add a check to make sure that ggplot package is loaded in the examples section.

Also fixed some warnings and notes.",man/Describe.Rd;man/VI.Rd,False,False,False,False,10,6,16,"---FILE: man/Describe.Rd---
@@ -24,25 +24,25 @@ A function to help describe what a graph model would look like, to a vision impa
 \usage{
 Describe(x, VI=FALSE, ...)
 
-\method{Describe}{histogram}(x, VI=TRUE, ...)
+\method{Describe}{histogram}(x, VI=FALSE, ...)
 
 \method{Describe}{ggplot}(x,VI=FALSE, whichLayer=NULL, ...)
 }
 \arguments{
 \item{x}{any \R object}
-\item{VI}{Should \code{\link{VI()}} be called at the same time}
+\item{VI}{Should \code{VI()} be called at the same time}
 \item{whichLayer}{Only used with Describe.ggplot, if NULL will either display the layer if ggplot has one layer, ask user for input if it is an interactive session or print out all of the layers}
 \item{...}{other arguments, currently ignored}
 }
 \details{
 Describe() is for explaining how a given type of graph appears to a sighted person and is intended for use by blind people who do not know how the graph looks. There is room to add hints for displaying the graphs in a more visually appealing manner.
 
-The text description will only be generic to the plot type and not specific information for specific information see \code{\link{VI()}}.
+The text description will only be generic to the plot type and not specific information for specific information see \code{VI()}.
 
-Unlike \code{\link{VI()}} and ggplot Describe needs to be explicitly called to show its output.
+Unlike \code{VI()} and ggplot Describe needs to be explicitly called to show its output.
 }
 \value{
-A description in the format of a list. It will ahve the title, general info and RHints. If multiple layers of a ggplot are being described then it will be a list of descriptions for each layer.
+A description in the format of a list. It will have the title, general info and RHints. If multiple layers of a ggplot are being described then it will be a list of descriptions for each layer.
 }
 \author{
 A. Jonathan R. Godfrey and James A. Thompson
@@ -56,7 +56,9 @@ hist = hist(rnorm(1e3))
 Describe(hist)
 
 # ggplot
+if(require(ggplot2)){
 simplePoint = ggplot(NULL, aes(rnorm(1e2), rnorm(1e2))) +
   geom_point()
 Describe(simplePoint)
+}
 }
\ No newline at end of file

---FILE: man/VI.Rd---
@@ -43,7 +43,7 @@ VI(x, Describe=FALSE, ...)
 }
 \arguments{
 \item{x}{any \R object}
-\item{Describe}{Should the \code{\link{Describe()}} function be called at the same time}
+\item{Describe}{Should the \code{Describe()} function be called at the same time}
 \item{digits }{number of decimal places to show}
 \item{threshold}{Only for ggplot. Maximum number of data items that should be individually listed in the output.}
 \item{template}{Only for ggplot. Template file, in mustache format, to be used in creating the text}
@@ -78,7 +78,9 @@ PlottedFig=hist(RandomX)
 VI(PlottedFig)
 
 # ggplot
+if(require(ggplot2)){
 ggplot(economics_long, aes(date, value01, colour = variable)) +
   geom_line() +
   ggtitle('dummy title')
 }
+}"
ajrgodfrey,BrailleR,0c977326d9c43a3faa48e0386416bc6929d12749,ajrgodfrey,ajgodfre@massey.ac.nz,2022-12-04T18:41:10Z,ajrgodfrey,ajgodfre@massey.ac.nz,2022-12-04T18:41:10Z,v0.33.4 fixing more messages,R/Messages.R;R/Warnings.R,False,True,True,False,75,72,147,"---FILE: R/Messages.R---
@@ -1,4 +1,3 @@
-# add filenames to messages for file creation
 
 
 .BlankMSG =     function() {
@@ -13,27 +12,22 @@ return(invisible(NULL))
 
 
         .AnswerQuestions=function(){
-message(""You will be asked to enter answers for a series of questions.\nHit <enter> to use the default shown in parentheses."")
+message(""You will be asked to enter answers for a series of questions.Hit <enter> to use the default shown in parentheses."")
 return(invisible(NULL))
 }
 
 .AuthorName =     function() {
-message(""\nEnter the name you want to use for authoring content. ("",
+message(""Enter the name you want to use for authoring content. ("",
                 getOption(""BrailleR.Author""), "")"")
 return(invisible(NULL))
-    }
+}
 
 .AutoLoadBrailleR  =     function() {
 message(""The BrailleR package will be automatically loaded on startup in this working directory."")
 return(invisible(NULL))
-    }
-
+}
 
 
-.CannotSeeWxPython = function(){
-message(""Python cannot see the necessary wx module.\nYou need to get that fixed."")
-return(invisible(NULL))
-}
 
 
 
@@ -50,7 +44,7 @@ return(invisible(NULL))
 .ConsultHelpPage  =     function() {
 message(""Consult the help page for guidance on using these files in Windows Explorer."")
 return(invisible(NULL))
-    }
+}
 
 
 .DeleteAnytime  = function(){
@@ -63,65 +57,60 @@ message(""Done."")
 return(invisible(NULL))
 }
 
-.DownloadAFile = function(){
-message(""This command will download a file and save it to your hard drive."")
-return(invisible(NULL))
-}
-
 
 .FileCreated =     function(file=NULL, where=""in your MyBrailleR directory."") {
-NewFile = ifelse(is.null(file), """", file)
+NewFile = ifelse(is.null(file), ""A new file"", file)
 message(NewFile, "" has been created "", where)
 return(invisible(NULL))
-    }
+}
 
 .FileUpdated =     function(file=NULL, where=""in your MyBrailleR directory."") {
-NewFile = ifelse(is.null(file), """", file)
+NewFile = ifelse(is.null(file), ""The specified"", file)
 message(NewFile, "" has been updated "", where)
 return(invisible(NULL))
-    }
+}
 
 
 
 .InstallPython =     function() {
 message(""You could use GetPython3() and GetWxPython3() to help install them."")
 return(invisible(NULL))
-    }
+}
 
 .MoveOntoPath=     function() {
 message(""These files need to be moved to a folder that is on your system path."")
 return(invisible(NULL))
-    }
+}
 
 
 .NewFile =     function(file=NULL) {
 NewFile = ifelse(is.null(file), """", file)
 message(NewFile, "" has been created in your working directory."")
 return(invisible(NULL))
-    }
+}
 
 .NoActionTaken =     function() {
 message(""No action taken."")
 return(invisible(NULL))
-    }
+}
 
 
 
 .NoSeePython = function(){
-message(""Python cannot be seen on your system.\nIf it is installed, then you may need to ensure your system settings are correct."")
+message(""Python cannot be seen on your system.If it is installed, then you may need to ensure your system settings are correct."")
 return(invisible(NULL))
 }
 
 .NothingDoneGraph =     function() {
 message(""Nothing done to augment this graph object."")
 return(invisible(NULL))
-    }
+}
 
 .NoVIMethod =     function() {
-      message(""There is no specific method written for  this type of object.\n"")
-      message(""You might try to use the print() function on the object or the str() command to investigate its contents.\n"")
-      return(invisible(NULL))
-    }
+      message(""There is no specific method written for  this type of object."")
+message(""You might try to use the print() function on the object or the str() command to investigate its contents."")
+return(invisible(NULL))
+}
 
 
 .OptionLocal =     function() {
@@ -143,7 +132,7 @@ return(invisible(NULL))
 
 
 .OriginalDefaults =     function() {
-message(""You have reset all preferences to the original package defaults.\n"")
+message(""You have reset all preferences to the original package defaults."")
 return(invisible(NULL))
 }
 
@@ -152,12 +141,19 @@ return(invisible(NULL))
 VersionString = system2(""python"", ""--version"", stdout=TRUE, stderr=TRUE)
 message(""Your system is using "", VersionString, """")
 return(invisible(NULL))
-    }
+}
+
+.QuartoVersion =     function() {
+VersionString = system2(""quarto"", ""--version"", stdout=TRUE, stderr=TRUE)
+message(""Your system is using "", VersionString, """")
+return(invisible(NULL))
+}
+
 
 .SavedInPath =     function() {
 message(""These details are saved in path.txt for reference."")
 return(invisible(NULL))
-    }
+}
 
 
 
@@ -166,11 +162,6 @@ return(invisible(NULL))
 .SVGAndXMLMade =     function() {
 message(""SVG and XML files created successfully."")
 return(invisible(NULL))
-    }
-
+}
 
-.TempUnavailable =     function() {
-  message(""This command is temporarily unavailable."")
-return(invisible(NULL))
-    }
 

---FILE: R/Warnings.R---
@@ -1,96 +1,108 @@
 
 .BlankWarning =     function() {
-warning(""\n"")
+warning("""")
 return(invisible(NULL))
 }
 
+.CannotSeeWxPython = function(){
+warning(""Python cannot see the necessary wx module.You need to get that fixed."")
+return(invisible(NULL))
+}
+
+
 .DeprecatedFunction =     function() {
-warning(""This function has been deprecated.\n"")
+warning(""This function has been deprecated."")
 return(invisible(NULL))
-    }
+}
+
 
 
 
+.DownloadAFile = function(){
+warning(""This command will download a file and save it to your hard drive."")
+return(invisible(NULL))
+}
+
 
 .ExpectingText =     function() {
-warning(""A text string was expected. No action taken.\n"")
+warning(""A text string was expected. No action taken."")
 return(invisible(NULL))
 }
 
 .ExperimentalFunction =     function() {
-warning(""This function is purely experimental. Use it at your own risk.\n"")
+warning(""This function is purely experimental. Use it at your own risk."")
 return(invisible(NULL))
 }
 
 .FileDoesNotExist =     function(file=NULL) {
-warning(ifelse(is.null(file), ""The specified file"", file),  "" does not exist.\n"")
+warning(ifelse(is.null(file), ""The specified file"", file),  "" does not exist."")
 return(invisible(NULL))
-    }
+}
 
 .FileExists =     function(file) {
-warning(file, ""already exists.\n"")
+warning(file, ""already exists."")
 return(invisible(NULL))
-    }
+}
 
 
 
-##kill this one
-.FileNotFound =     function(file=NULL) {
-warning(""The specified file does not exist.\n"")
-return(invisible(NULL))
-    }
 
 
-.FolderNotFound =     function() {
-warning(""The specified folder does not exist.\n"")
+.FolderNotFound =     function(folder=NULL) {
+warning(ifelse(is.null(folder), ""The specified folder"", folder),  "" does not exist."")
 return(invisible(NULL))
-    }
+}
 
 
 .InteractiveOnly =     function() {
-warning(""This function is meant for use in interactive mode only.\n"")
+warning(""This function is meant for use in interactive mode only."")
 return(invisible(NULL))
-    }
+}
 
 
 .NeedsPython =     function() {
- warning(""This function requires installation of Python 3.0 or above.\n"")
+warning(""This function requires installation of Python 3.0 or above."")
 return(invisible(NULL))
-    }
+}
 
 .NeedsWX =     function() {
-warning(""This function requires an installation of Python and wxPython.\n"")
+warning(""This function requires an installation of Python and wxPython."")
 return(invisible(NULL))
-    }
+}
 
 
 .NoConversion =     function() {
-warning(""There was a problem and no conversion was possible.\n"")
+warning(""There was a problem and no conversion was possible."")
 return(invisible(NULL))
-    }
+}
 
 .NoGraphicsDevice =     function() {
-warning(""There is no current graphics device to investigate.\n"")
+warning(""There is no current graphics device to investigate."")
 return(invisible(NULL))
 }
 
 
 
 
 .OverWriteNeeded =     function(file=NULL) {
-warning(""No action has been taken. Use `Overwrite=TRUE` if you want to replace it.\n"")
+warning(""No action has been taken. Use `Overwrite=TRUE` if you want to replace it."")
 return(invisible(NULL))
-    }
+}
 
 
-.PkgNotFound =     function() {
-warning(""The specified package is not installed.\n"")
+.PkgNotFound =     function(Pkg=NULL) {
+warning(""The "", ifelse(is.null(Pkg), ""specified package"", Pkg),  "" does not exist."")
 return(invisible(NULL))
-    }
+}
+
+.TempUnavailable =     function() {
+message(""This command is temporarily unavailable."")
+return(invisible(NULL))
+}
 
 
 
 .WindowsOnly =     function() {
-warning(""This function is for users running R under the Windows operating system.\n"")
+warning(""This function is for users running R under the Windows operating system."")
 return(invisible(NULL))
-    }
+}"
ajrgodfrey,BrailleR,86ff432a1433cbaa638087cd970ac74e2258d22d,ajrgodfrey,ajgodfre@massey.ac.nz,2022-12-03T03:14:30Z,ajrgodfrey,ajgodfre@massey.ac.nz,2022-12-03T03:14:30Z,v0.33.4 fixing more messages,R/CleanCSV.R;R/FindReplace.R;R/MakeRmdFiles.R,False,True,True,False,3,3,6,"---FILE: R/CleanCSV.R---
@@ -11,7 +11,7 @@ CleanCSV =
             .Done() 
           }  # end ThisFile exists condition
               else {
-            .FileNotFound()
+            .FileDoesNotExist()
           }
         }  # end for loop for files
       }  # end interactive ondition

---FILE: R/FindReplace.R---
@@ -12,7 +12,7 @@ FindReplace =
         }
         writeLines(gsub(find, replace, OldText, fixed=TRUE)[1:NoLines], con = file)
       } else {
-        .FileNotFound()
+        .FileDoesNotExist()
       }
       return(invisible(NULL))
     }

---FILE: R/MakeRmdFiles.R---
@@ -40,7 +40,7 @@ R2Rmd =
         .NewFile()
         return(RmdFile)
       } else {
-        .FileNotFound()
+        .FileDoesNotExist()
         return(invisible(NULL))
       }
     }"
ajrgodfrey,BrailleR,f8b237222e4ba9c5bd2eb4892d03a3ee3f74fe76,ajrgodfrey,ajgodfre@massey.ac.nz,2022-12-03T03:07:24Z,ajrgodfrey,ajgodfre@massey.ac.nz,2022-12-03T03:07:24Z,v0.33.4 fixing more messages,R/Options.R;R/Warnings.R,False,True,True,False,2,2,4,"---FILE: R/Options.R---
@@ -180,7 +180,7 @@ SetLanguage =
         Language = ""en_us"", Permanent = interactive(), Local = interactive()) {
       if (is.character(Language)) {
         options(BrailleR.Language = Language)
-        .OptionUpdated""Language"", Language)
+        .OptionUpdated(""Language"", Language)
         if (Permanent) {
           Prefs = paste0(getOption(""BrailleR.Folder""), ""BrailleROptions"")
           OpSet = as.data.frame(read.dcf(Prefs, all = TRUE))

---FILE: R/Warnings.R---
@@ -23,7 +23,7 @@ return(invisible(NULL))
 }
 
 .FileDoesNotExist =     function(file=NULL) {
-warning(is.null(file), ""The specified file"", file),  "" does not exist.\n"")
+warning(ifelse(is.null(file), ""The specified file"", file),  "" does not exist.\n"")
 return(invisible(NULL))
     }
 "
ajrgodfrey,BrailleR,57906df421114f8eea008efe8e072e05c5386df5,ajrgodfrey,ajgodfre@massey.ac.nz,2022-12-03T03:01:33Z,ajrgodfrey,ajgodfre@massey.ac.nz,2022-12-03T03:01:33Z,v0.33.4 fixing more messages,R/Messages.R,False,True,True,False,1,1,2,"---FILE: R/Messages.R---
@@ -137,7 +137,7 @@ return(invisible(NULL))
 
 
 .OptionUpdated =     function(option, to=NULL) {
-message(""The BrailleR."", option, "" option has been updated"", ifelse(is.null(to), """", paste0(""to "", to ), ""."")
+message(""The BrailleR."", option, "" option has been updated"", ifelse(is.null(to), """", paste0(""to "", to )), ""."")
 return(invisible(NULL))
 }
 "
ajrgodfrey,BrailleR,9032a1238481ac5b4080de62057edebd8bf67a65,ajrgodfrey,ajgodfre@massey.ac.nz,2022-12-02T07:17:50Z,ajrgodfrey,ajgodfre@massey.ac.nz,2022-12-02T07:17:50Z,v0.33.4 fixing more messages,R/MakeReadable.R;R/Messages.R;R/Options.R;R/PrepareWriteR.R;R/RemoveBOM.R;R/SVGThis.R;R/Warnings.R,False,True,True,False,31,54,85,"---FILE: R/MakeReadable.R---
@@ -29,7 +29,7 @@ setwd(MoveTo)
             RnwFiles = c(list.files(pattern = ""Rnw""),
                          list.files(pattern = ""rnw""))
 
-#              message(""Copying and converting line breaks:"", file)
+              # Copying and converting line breaks
 
             for (i in RnwFiles) {
 try(Sweave(i))
@@ -61,15 +61,15 @@ unlink(MoveTo)
 
 
 .RemoveWhiteSpace = function(file){
-message(""done"")
+.Done()
 writeLines(gsub(""  *"", "" "", readLines(file)), file)
 return(invisible(NULL))
 }
 
 
 
 .RemoveTabs = function(file){
-              message(""Converting tabs to spaces:"", file)
+              # Converting tabs to spaces
 writeLines(gsub(""\t"", ""    "", readLines(file)), file)
 #              shell(paste0(system.file(
 #                               ""Python/RemoveTabs.py"", package = ""BrailleR""),
@@ -80,7 +80,6 @@ return(invisible(NULL))
 .MakeBackUp = function(file){
 OldFile=paste0(file, "".bak"")
 file.copy(file, OldFile)
-# message
 return(invisible(NULL))
 }
 

---FILE: R/Messages.R---
@@ -124,6 +124,11 @@ return(invisible(NULL))
     }
 
 
+.OptionLocal =     function() {
+message(""The new setting will remain in effect next time you load the BrailleR package in this directory."")
+return(invisible(NULL))
+}
+
 .OptionPermanent =     function() {
 message(""and has overwritten the setting for all folders."")
 return(invisible(NULL))
@@ -137,6 +142,11 @@ return(invisible(NULL))
 }
 
 
+.OriginalDefaults =     function() {
+message(""You have reset all preferences to the original package defaults.\n"")
+return(invisible(NULL))
+}
+
 
 .PythonVersion =     function() {
 VersionString = system2(""python"", ""--version"", stdout=TRUE, stderr=TRUE)

---FILE: R/Options.R---
@@ -10,8 +10,7 @@ ResetDefaults =
         PrefSettings =
             file.path(getOption(""BrailleR.Folder""), ""BrailleROptions"")
         file.copy(DefSettings, PrefSettings, overwrite = TRUE)
-        message(
-            ""You have reset all preferences to the original package defaults.\n"")
+        .OriginalDefaults()
         if (Local) file.remove(""BrailleROptions"")
         devtools::reload(""BrailleR"")
       } else {
@@ -41,8 +40,7 @@ ChooseEmbosser =
           }
           OpSet$BrailleR.Embosser = Embosser
           write.dcf(OpSet, file = Prefs)
-          message(
-              ""The new setting will remain in effect next time you load the BrailleR package in this directory."")
+          .OptionLocal()
         }
       } else {
         .ExpectingText()
@@ -75,8 +73,7 @@ ChooseSlideStyle =
             }
             OpSet$BrailleR.SlideStyle = css
             write.dcf(OpSet, file = Prefs)
-            message(
-                ""The new setting will remain in effect next time you load the BrailleR package in this directory."")
+            .OptionLocal()
           }
         }
       } else {
@@ -110,8 +107,7 @@ ChooseStyle =
             }
             OpSet$BrailleR.Style = css
             write.dcf(OpSet, file = Prefs)
-            message(
-                ""The new setting will remain in effect next time you load the BrailleR package in this directory."")
+            .OptionLocal()
           }
         }
       } else {
@@ -141,8 +137,7 @@ SetAuthor =
           }
           OpSet$BrailleR.Author = name
           write.dcf(OpSet, file = Prefs)
-          message(
-              ""The new setting will remain in effect next time you load the BrailleR package in this directory."")
+          .OptionLocal()
         }
       } else {
         .ExpectingText()
@@ -170,8 +165,7 @@ SetBRLPointSize =
           }
           OpSet$BrailleR.BRLPointSize = pt
           write.dcf(OpSet, file = Prefs)
-          message(
-              ""The new setting will remain in effect next time you load the BrailleR package in this directory."")
+          .OptionLocal()
         }
       } else {
         warning(
@@ -201,8 +195,7 @@ SetLanguage =
           }
           OpSet$BrailleR.Language = Language
           write.dcf(OpSet, file = Prefs)
-          message(
-              ""The new setting will remain in effect next time you load the BrailleR package in this directory."")
+          .OptionLocal()
         }
       } else {
         .ExpectingText()
@@ -233,8 +226,7 @@ SetMakeUpper =
           }
           OpSet$BrailleR.MakeUpper = Upper
           write.dcf(OpSet, file = Prefs)
-          message(
-              ""The new setting will remain in effect next time you load the BrailleR package in this directory."")
+          .OptionLocal()
         }
       } else {
         warning(
@@ -264,8 +256,7 @@ SetPaperHeight =
           }
           OpSet$BrailleR.PaperHeight = Inches
           write.dcf(OpSet, file = Prefs)
-          message(
-              ""The new setting will remain in effect next time you load the BrailleR package in this directory."")
+          .OptionLocal()
         }
       } else {
         warning(
@@ -295,8 +286,7 @@ SetPaperWidth =
           }
           OpSet$BrailleR.PaperWidth = Inches
           write.dcf(OpSet, file = Prefs)
-          message(
-              ""The new setting will remain in effect next time you load the BrailleR package in this directory."")
+          .OptionLocal()
         }
       } else {
         warning(
@@ -329,8 +319,7 @@ SetPValDigits =
           }
           OpSet$BrailleR.PValDigits = digits
           write.dcf(OpSet, file = Prefs)
-          message(
-              ""The new setting will remain in effect next time you load the BrailleR package in this directory."")
+          .OptionLocal()
         }
       } else {
         warning(
@@ -360,8 +349,7 @@ SetSigLevel =
           }
           OpSet$BrailleR.SigLevel = alpha
           write.dcf(OpSet, file = Prefs)
-          message(
-              ""The new setting will remain in effect next time you load the BrailleR package in this directory."")
+          .OptionLocal()
         }
       } else {
         warning(

---FILE: R/PrepareWriteR.R---
@@ -7,28 +7,8 @@ PrepareWriteR =
     function(Author = getOption(""BrailleR.Author"")) {
       if (interactive()) {
         if (.Platform$OS.type == ""windows"") {
-          RHome = gsub(""/"", ""\\\\\\\\"", Sys.getenv(""R_HOME""))
-          MyHome = gsub(""/"", ""\\\\\\\\"", gsub(""\\\\"", ""/"", Sys.getenv(""HOME"")))
 
-          cat(paste0(
-                  '{
-    ""RDirectory"": ""', RHome, '\\\\bin\\\\', version$arch,
-                  '\\\\Rscript.exe"",
-    ""filename"": ""untitled.Rmd"",
-    ""newText"": ""# \\n## by ',
-                  Author, ' on \\n\\n"",
-}
-'), file = 'WriteROptions')
-
-          message(""The settings file for WriteR has been created."")
 
-          file.copy(paste0(system.file(package = ""BrailleR""), ""/Python/Writer/"",
-                           c(""WriteR.pyw"", ""HelpPage.html"", ""HelpPage.Rmd"",
-                             ""Basics.Rmd"")), ""."")
-          message(
-              ""Copies of the main wxPython script and help page documents have been copied \ninto your working directory."")
-          message(
-              ""You can move these files to your preferred folder for WriteR, \nor start working here."")
         } else {
           .WindowsOnly()
         }

---FILE: R/RemoveBOM.R---
@@ -5,7 +5,7 @@ Line1 = FileLines[1]
 if(nchar(Line1)==6 & nchar(strsplit(Line1,""---"")) ==3){
 FileLines[1] = ""---""
 writeLines(FileLines, con=file)
-message(""BOM removed from file"")
+.Done()
 return(invisible(TRUE))
 }
 return(invisible(TRUE))

---FILE: R/SVGThis.R---
@@ -23,7 +23,7 @@
         temp <- readLines(con = svgfile)
         writeLines(gsub(""ISO8859-1"", ""ASCII"", temp), con = svgfile)
       } else {
-        warning(""The specified file does not exist.\n"")
+        .FileDoesNotExist(svgfile)
       }
       return(invisible(NULL))
     }
@@ -172,7 +172,7 @@ x$data=NULL
       gridSVG::grid.export(name = file)
       dev.off()  # remove our graph window
       .MakeTigerReady(svgfile = file)
-      message(""SVG file created.\n"")
+      .FileCreated(file)
       return(invisible(NULL))
 }
 
@@ -182,6 +182,6 @@ SVGThis.tsplot = function(x, file = ""test.svg"", ...) {
       gridSVG::grid.export(name = file)
       dev.off()  # remove our graph window
       .MakeTigerReady(svgfile = file)
-      message(""SVG file created.\n"")
+      .FileCreated(file)
       return(invisible(NULL))
 }

---FILE: R/Warnings.R---
@@ -22,8 +22,8 @@ warning(""This function is purely experimental. Use it at your own risk.\n"")
 return(invisible(NULL))
 }
 
-.FileDoesNotExist =     function(file) {
-warning(file, ""does not exist.\n"")
+.FileDoesNotExist =     function(file=NULL) {
+warning(is.null(file), ""The specified file"", file),  "" does not exist.\n"")
 return(invisible(NULL))
     }
 "
ajrgodfrey,BrailleR,4ea30990687198aba188dadbdbd5444248b0ba93,ajrgodfrey,ajgodfre@massey.ac.nz,2022-12-02T05:16:14Z,ajrgodfrey,ajgodfre@massey.ac.nz,2022-12-02T05:16:14Z,v0.33.4 fixing more messages,R/Messages.R;R/Options.R,False,True,True,False,33,24,57,"---FILE: R/Messages.R---
@@ -1,9 +1,10 @@
 # add filenames to messages for file creation
 
-.BlankMSG  =     function() {
+
+.BlankMSG =     function() {
 message("""")
 return(invisible(NULL))
-    }
+}
 
 .Added2MyBrailleR = function(){
 message(""The installer file has been added to your MyBrailleR folder."")
@@ -123,6 +124,19 @@ return(invisible(NULL))
     }
 
 
+.OptionPermanent =     function() {
+message(""and has overwritten the setting for all folders."")
+return(invisible(NULL))
+}
+
+
+
+.OptionUpdated =     function(option, to=NULL) {
+message(""The BrailleR."", option, "" option has been updated"", ifelse(is.null(to), """", paste0(""to "", to ), ""."")
+return(invisible(NULL))
+}
+
+
 
 .PythonVersion =     function() {
 VersionString = system2(""python"", ""--version"", stdout=TRUE, stderr=TRUE)

---FILE: R/Options.R---
@@ -26,14 +26,13 @@ ChooseEmbosser =
         Embosser = ""none"", Permanent = interactive(), Local = interactive()) {
       if (is.character(Embosser)) {
         options(BrailleR.Embosser = Embosser)
-        message(
-            ""The BrailleR.Embosser option has been updated to "", Embosser, ""."")
+        .OptionUpdated(""Embosser"", Embosser)
         if (Permanent) {
           Prefs = paste0(getOption(""BrailleR.Folder""), ""BrailleROptions"")
           OpSet = as.data.frame(read.dcf(Prefs, all = TRUE))
           OpSet$BrailleR.Embosser = Embosser
           write.dcf(OpSet, file = Prefs)
-          message(""and has overwritten the setting for all folders."")
+          .OptionPermanent()
         }
         if (Local) {
           Prefs = ""BrailleROptions""
@@ -61,14 +60,13 @@ ChooseSlideStyle =
               ""The file"", css,
               ""is not in the css folder of the BrailleR package.\nPlease put it there before re-issuing this command.\n"")
         } else {
-          message(
-              ""The BrailleR.SlideStyle option has been updated to "", css, ""."")
+          .OptionUpdated(""SlideStyle"", css)
           if (Permanent) {
             Prefs = paste0(getOption(""BrailleR.Folder""), ""BrailleROptions"")
             OpSet = as.data.frame(read.dcf(Prefs, all = TRUE))
             OpSet$BrailleR.SlideStyle = css
             write.dcf(OpSet, file = Prefs)
-            message(""and has overwritten the setting for all folders."")
+            .OptionPermanent()
           }
           if (Local) {
             Prefs = ""BrailleROptions""
@@ -97,13 +95,13 @@ ChooseStyle =
               ""The file"", css,
               ""is not in the css folder of the BrailleR package.\nPlease put it there before re-issuing this command.\n"")
         } else {
-          message(""The BrailleR.Style option has been updated to "", css, ""."")
+          .OptionUpdated(""Style"", css)
           if (Permanent) {
             Prefs = paste0(getOption(""BrailleR.Folder""), ""BrailleROptions"")
             OpSet = as.data.frame(read.dcf(Prefs, all = TRUE))
             OpSet$BrailleR.Style = css
             write.dcf(OpSet, file = Prefs)
-            message(""and has overwritten the setting for all folders."")
+            .OptionPermanent()
           }
           if (Local) {
             Prefs = ""BrailleROptions""
@@ -128,13 +126,13 @@ SetAuthor =
         name = ""BrailleR"", Permanent = interactive(), Local = interactive()) {
       if (is.character(name)) {
         options(BrailleR.Author = name)
-        message(""The BrailleR.Author option has been updated to "", name, ""."")
+        .OptionUpdated(""Author"", name)
         if (Permanent) {
           Prefs = paste0(getOption(""BrailleR.Folder""), ""BrailleROptions"")
           OpSet = as.data.frame(read.dcf(Prefs, all = TRUE))
           OpSet$BrailleR.Author = name
           write.dcf(OpSet, file = Prefs)
-          message(""and has overwritten the setting for all folders."")
+          .OptionPermanent()
         }
         if (Local) {
           Prefs = ""BrailleROptions""
@@ -157,15 +155,13 @@ SetBRLPointSize =
     function(pt, Permanent = FALSE, Local = interactive()) {
       if ((10 < pt) & (pt < 40)) {
         options(BrailleR.BRLPointSize = pt)
-        message(
-            ""The BrailleR.BRLPointSize option for the braille font has been changed to "",
-            pt, "" inches."")
+        .OptionUpdated(""BRLPointSize (for the braille font)"", paste0(pt, "" inches""))
         if (Permanent) {
           Prefs = paste0(getOption(""BrailleR.Folder""), ""BrailleROptions"")
           OpSet = as.data.frame(read.dcf(Prefs, all = TRUE))
           OpSet$BrailleR.BRLPointSize = pt
           write.dcf(OpSet, file = Prefs)
-          message(""and has overwritten the setting for all folders."")
+          .OptionPermanent()
         }
         if (Local) {
           Prefs = ""BrailleROptions""
@@ -190,14 +186,13 @@ SetLanguage =
         Language = ""en_us"", Permanent = interactive(), Local = interactive()) {
       if (is.character(Language)) {
         options(BrailleR.Language = Language)
-        message(
-            ""The BrailleR.Language option has been updated to "", Language, ""."")
+        .OptionUpdated""Language"", Language)
         if (Permanent) {
           Prefs = paste0(getOption(""BrailleR.Folder""), ""BrailleROptions"")
           OpSet = as.data.frame(read.dcf(Prefs, all = TRUE))
           OpSet$BrailleR.Language = Language
           write.dcf(OpSet, file = Prefs)
-          message(""and has overwritten the setting for all folders."")
+          .OptionPermanent()
         }
         if (Local) {
           Prefs = ""BrailleROptions""
@@ -229,7 +224,7 @@ SetMakeUpper =
           OpSet = as.data.frame(read.dcf(Prefs, all = TRUE))
           OpSet$BrailleR.MakeUpper = Upper
           write.dcf(OpSet, file = Prefs)
-          message(""and has overwritten the setting for all folders."")
+          .OptionPermanent()
         }
         if (Local) {
           Prefs = ""BrailleROptions""
@@ -260,7 +255,7 @@ SetPaperHeight =
           OpSet = as.data.frame(read.dcf(Prefs, all = TRUE))
           OpSet$BrailleR.PaperHeight = Inches
           write.dcf(OpSet, file = Prefs)
-          message(""and has overwritten the setting for all folders."")
+          .OptionPermanent()
         }
         if (Local) {
           Prefs = ""BrailleROptions""
@@ -291,7 +286,7 @@ SetPaperWidth =
           OpSet = as.data.frame(read.dcf(Prefs, all = TRUE))
           OpSet$BrailleR.PaperWidth = Inches
           write.dcf(OpSet, file = Prefs)
-          message(""and has overwritten the setting for all folders."")
+          .OptionPermanent()
         }
         if (Local) {
           Prefs = ""BrailleROptions""
@@ -325,7 +320,7 @@ SetPValDigits =
           OpSet = as.data.frame(read.dcf(Prefs, all = TRUE))
           OpSet$BrailleR.PValDigits = digits
           write.dcf(OpSet, file = Prefs)
-          message(""and has overwritten the setting for all folders."")
+          .OptionPermanent()
         }
         if (Local) {
           Prefs = ""BrailleROptions""
@@ -356,7 +351,7 @@ SetSigLevel =
           OpSet = as.data.frame(read.dcf(Prefs, all = TRUE))
           OpSet$BrailleR.SigLevel = alpha
           write.dcf(OpSet, file = Prefs)
-          message(""and has overwritten the setting for all folders."")
+          .OptionPermanent()
         }
         if (Local) {
           Prefs = ""BrailleROptions"""
ajrgodfrey,BrailleR,034929789be4a06bd1f98af439127f3e05e8dd3d,ajrgodfrey,ajgodfre@massey.ac.nz,2022-12-02T04:17:55Z,ajrgodfrey,ajgodfre@massey.ac.nz,2022-12-02T04:17:55Z,v0.33.4 fixing more messages,R/Messages.R;R/Options.R;R/SpellCheck.R;R/VIMethod1_JG.R;R/WTF.R;R/Warnings.R;R/WhatIs.R;R/pdf2html.R;inst/MyBrailleR/WriteROptions,False,True,True,False,56,24,80,"---FILE: R/Messages.R---
@@ -116,6 +116,13 @@ message(""Nothing done to augment this graph object."")
 return(invisible(NULL))
     }
 
+.NoVIMethod =     function() {
+      message(""There is no specific method written for  this type of object.\n"")
+      message(""You might try to use the print() function on the object or the str() command to investigate its contents.\n"")
+      return(invisible(NULL))
+    }
+
+
 
 .PythonVersion =     function() {
 VersionString = system2(""python"", ""--version"", stdout=TRUE, stderr=TRUE)

---FILE: R/Options.R---
@@ -15,7 +15,7 @@ ResetDefaults =
         if (Local) file.remove(""BrailleROptions"")
         devtools::reload(""BrailleR"")
       } else {
-        warning(""This function is meant for use in interactive mode only.\n"")
+        .InteractiveOnly()
       }
       return(invisible(NULL))
     }
@@ -46,7 +46,7 @@ ChooseEmbosser =
               ""The new setting will remain in effect next time you load the BrailleR package in this directory."")
         }
       } else {
-        warning(""A text string was expected. No action taken.\n"")
+        .ExpectingText()
       }
       return(invisible(NULL))
     }
@@ -82,7 +82,7 @@ ChooseSlideStyle =
           }
         }
       } else {
-        warning(""A text string was expected. No action taken.\n"")
+        .ExpectingText()
       }
       return(invisible(NULL))
     }
@@ -117,7 +117,7 @@ ChooseStyle =
           }
         }
       } else {
-        warning(""A text string was expected. No action taken.\n"")
+        .ExpectingText()
       }
       return(invisible(NULL))
     }
@@ -147,7 +147,7 @@ SetAuthor =
               ""The new setting will remain in effect next time you load the BrailleR package in this directory."")
         }
       } else {
-        warning(""A text string was expected. No action taken.\n"")
+        .ExpectingText()
       }
       return(invisible(NULL))
     }
@@ -210,7 +210,7 @@ SetLanguage =
               ""The new setting will remain in effect next time you load the BrailleR package in this directory."")
         }
       } else {
-        warning(""A text string was expected. No action taken.\n"")
+        .ExpectingText()
       }
       return(invisible(NULL))
     }

---FILE: R/SpellCheck.R---
@@ -55,15 +55,15 @@ SpellCheck =
               }
             }
             writeLines(OldText[1:NoLines], con = ThisFile)
-            message(""Done."")
+            .Done()
           }  # end ThisFile exists condition
               else {
-            warning(""The specified file does not exist.\n"")
+            .FileDoesNotExist(file)
           }
         }  # end for loop for files
       }  # end interactive ondition
           else {
-        warning(""This function is meant for use in interactive mode only.\n"")
+        .InteractiveOnly()
       }
       return(invisible(NULL))
     }

---FILE: R/VIMethod1_JG.R---
@@ -11,8 +11,7 @@ return(invisible(x))
 
 VI.default =
     function(x, Describe=FALSE, ...) {
-      message(""There is no specific method written for  this type of object.\n"")
-      message(""You might try to use the print() function on the object or the str() command to investigate its contents.\n"")
+      .NoVIMethod()
       print(x)
     }
 

---FILE: R/WTF.R---
@@ -10,17 +10,16 @@ WTF =
       }  # end open device condition
 
       if (length(grid::grid.ls(print = FALSE)$name) == 0) {
-        warning(""There is no current graphics device to investigate.\n"")
+        .NoGraphicsDevice()
         GridLS = NULL
       } else {
         GridLS = grid::grid.ls(print = FALSE, flatten = TRUE)
       }
 
 
-      #message(""Now looking for things using the grobs on device "", dev.cur(), ""."")
+      # Now looking for things using the grobs on device "", dev.cur(), "".
       #print(GridLS)
       ## there is a dictionary listing of these in the gridGraphs paper.
-      #cat(""\n\n"")
 
 
       if (is.null(names(grid.get(""graphics-plot-1-points-2"")))) {
@@ -83,6 +82,5 @@ WTF =
       ## ""This window has <b> rectangles."" etc. etc.
 
       ## I would guess that a window having boxes and lines might be a boxplot, while a window having no lines but rectangles is a histogram. etc.
-      #message(""\n\nDone."")
       return(invisible(NULL))
     }

---FILE: R/Warnings.R---
@@ -1,14 +1,27 @@
-.BlankWarning  =     function() {
+
+.BlankWarning =     function() {
 warning(""\n"")
 return(invisible(NULL))
-    }
+}
 
 .DeprecatedFunction =     function() {
 warning(""This function has been deprecated.\n"")
 return(invisible(NULL))
     }
 
 
+
+
+.ExpectingText =     function() {
+warning(""A text string was expected. No action taken.\n"")
+return(invisible(NULL))
+}
+
+.ExperimentalFunction =     function() {
+warning(""This function is purely experimental. Use it at your own risk.\n"")
+return(invisible(NULL))
+}
+
 .FileDoesNotExist =     function(file) {
 warning(file, ""does not exist.\n"")
 return(invisible(NULL))
@@ -20,7 +33,9 @@ return(invisible(NULL))
     }
 
 
-.FileNotFound =     function() {
+
+##kill this one
+.FileNotFound =     function(file=NULL) {
 warning(""The specified file does not exist.\n"")
 return(invisible(NULL))
     }
@@ -49,6 +64,17 @@ return(invisible(NULL))
     }
 
 
+.NoConversion =     function() {
+warning(""There was a problem and no conversion was possible.\n"")
+return(invisible(NULL))
+    }
+
+.NoGraphicsDevice =     function() {
+warning(""There is no current graphics device to investigate.\n"")
+return(invisible(NULL))
+}
+
+
 
 
 .OverWriteNeeded =     function(file=NULL) {

---FILE: R/WhatIs.R---
@@ -8,8 +8,8 @@ check_it = CheckIt = function(x, ...){
 
 
 what_is = WhatIs = function(x, ...){
-message(""\n"")
-    message(VI(x, ...))
-message(""\n"")
+cat(""\n"")
+VI(x, ...)
+cat(""\n"")
 return(    invisible(x))
 }

---FILE: R/pdf2html.R---
@@ -96,8 +96,7 @@ return(LastPageNo)
         if(TestPython()){
           Success = .PullPDFMinerUsingPip()
         }else{
-          warning(""This function requires installation of Python.\n"")
-message(""You can install Python with the GetPython3() function.\n"")
+          .NeedsPython()
         }
       }
       return(invisible(Success))
@@ -106,6 +105,7 @@ message(""You can install Python with the GetPython3() function.\n"")
 
 pdf2html =
     function(pdffile, htmlfile=sub("".pdf"", "".html"", pdffile), HeadingLevels=4, PageTag=""h6""){
+      .ExperimentalFunction()
       Success = FALSE
       if (.IsPDFMinerAvailable()) {
         shell(paste(""pdf2txt.py -O TempDir -o tempfile.html -t html"", pdffile))
@@ -115,7 +115,7 @@ pdf2html =
 .PageNumbers2Headings(htmlfile, outfile=htmlfile, HeadingTag=PageTag)
         Success = TRUE
       } else {
-        warning(""There was a problem and no conversion was possible.\n"")
+        .NoConversion()
       }
       return(invisible(Success))
     }

---FILE: inst/MyBrailleR/WriteROptions---
@@ -0,0 +1,2 @@
+lastdir: .
+newText: Use WriteR to edit your R markdown files, perhaps by starting from a template file"
ajrgodfrey,BrailleR,3629ab4d4ea49b0ed81903b066e53d7acd8a5734,James,1jamesthompson1@gmail.com,2022-11-28T22:26:10Z,James,1jamesthompson1@gmail.com,2022-11-28T22:26:10Z,"resolves #24

Fixing base r plot titles so that they reflect correctly what is seen.",NEWS.md;R/VIMethod1_JG.R,False,True,True,False,23,5,28,"---FILE: NEWS.md---
@@ -1,5 +1,6 @@
 # BrailleR 0.33.4
 - fix issue #35 with incorrect bin counts
+- fix issue #24, correcting base r plot titles in VI
 - Add shaded area for geom_smooth CI info to VI output.
 - Add geom_ribbon support
 - Add geom_area support. This has been added to the geom_ribbon branch and is treated like a geom_ribbon almost exactly the same.

---FILE: R/VIMethod1_JG.R---
@@ -1,3 +1,22 @@
+### Internal functions for base R plots
+
+.getGraphName = function(graph, titlePreamble = ""With the title:"", noTitleMessage=""With no title"") {
+  if (length(graph$main) > 0) {
+    if (nchar(gsub("" "", """",graph$main, fixed=T)) != 0) {
+      paste(titlePreamble,graph$main)
+    } else {
+      noTitleMessage
+    }
+    
+  } else if (nchar(graph$ExtraArgs$main) > 0) {
+    paste(titlePreamble,graph$ExtraArgs$main)
+  } else {
+    noTitleMessage
+  }
+}
+
+
+###VI methods
 
 VI = function(x, Describe=FALSE, ...) {
        UseMethod(""VI"")
@@ -23,8 +42,7 @@ VI.boxplot =
 x=Augment(x)
       cat(paste0(
               'This graph has ', x$Boxplots, ' printed ', x$VertHorz,
-              '\n', ifelse(length(x$ExtraArgs$main) > 0, 'with the title: ',
-                           'but has no title'), x$ExtraArgs$main, '\n',
+              '\n', .getGraphName(x), '\n',
               ifelse(length(x$ExtraArgs$xlab) > 0, InQuotes(x$ExtraArgs$xlab), 'No label'),
               ' appears on the x-axis.\n',
               ifelse(length(x$ExtraArgs$ylab) > 0, paste0('""', x$ExtraArgs$ylab, '""'), 'No label'),
@@ -82,8 +100,7 @@ VI.dotplot =
       Cuts = seq(MinVal, MaxVal, (MaxVal - MinVal) / Bins)
       # now do the description bit
       cat(paste0('This graph has ', x$dotplots, ' printed ', x$VertHorz, '\n',
-                 ifelse(length(x$ExtraArgs$main) > 0, 'with the title: ',
-                        'but has no title'), x$ExtraArgs$main, '\n'))
+                 .getGraphName(x), '\n'))
       if (!is.null(x$ExtraArgs$dlab) | !is.null(x$ExtraArgs$glab)) {
         warning(
             ""Use of dlab or glab arguments is not advised. Use xlab and ylab instead."")
@@ -112,7 +129,7 @@ VI.dotplot =
 VI.histogram =
     function(x, Describe=FALSE, ...) {
       cat(paste0('This is a histogram, with the title: ',
-          ifelse(length(x$ExtraArgs$main) > 0, x$ExtraArgs$main, paste(""Histogram of"", x$xname)),
+                 .getGraphName(x, titlePreamble = ""with the title:"", noTitleMessage = ""with no title""),
           '\n', ifelse(length(x$ExtraArgs$xlab) > 0, InQuotes(x$ExtraArgs$xlab), InQuotes(x$xname)),
           ' is marked on the x-axis.\n'))
       cat(""Tick marks for the x-axis are at:"", .GetAxisTicks(x$par$xaxp), ""\n"")"
ajrgodfrey,BrailleR,2e8e8bc2bafdabe5d74a0f0b4b0413c5bafaf30c,ajrgodfrey,ajgodfre@massey.ac.nz,2022-11-28T09:48:33Z,ajrgodfrey,ajgodfre@massey.ac.nz,2022-11-28T09:48:33Z,v0.33.4 fixing more messages,NEWS.md,False,False,False,False,2,6,8,"---FILE: NEWS.md---
@@ -1,16 +1,12 @@
-#BrailleR 0.33.4
+# BrailleR 0.33.4
+- fix issue #35 with incorrect bin counts
 - Add shaded area for geom_smooth CI info to VI output.
 - Add geom_ribbon support
 - Add geom_area support. This has been added to the geom_ribbon branch and is treated like a geom_ribbon almost exactly the same.
 - Add support for showing expand_limit effect on graph.
 - add functionality for winget tools into new winget.R file; should streamline software installation down the track
-<<<<<<< HEAD
 - deprecated functions relating to Python 2.7 and functions for making slide shows
 - updated template files so that chunk options are moved from opening fence to commented lines
-=======
-- deprecated functions relating to Python 2.7 and functions relating to making slide shows
-- fix issue #35 with incorrect bin counts
->>>>>>> d556f987adfc6434675689daea035a3dd142bf63
 
 # BrailleR 0.33.3
 -Update author files"
ajrgodfrey,BrailleR,2e2adee71bcaab5f00015032ec619f76a9fa11e0,ajrgodfrey,ajgodfre@massey.ac.nz,2022-11-28T09:28:21Z,ajrgodfrey,ajgodfre@massey.ac.nz,2022-11-28T09:28:21Z,v0.33.4 fixing more messages,R/MakeSlideShow.R;R/Messages.R;R/PrepareWriteR.R,False,True,True,False,15,6,21,"---FILE: R/MakeSlideShow.R---
@@ -39,7 +39,8 @@ MakeAllInOneSlide =
         }
       }  # end folder existence condition
           else {
-        warning(""Specified folder does not exist. No action taken."")
+        .FolderNotFound()
+ .NoActionTaken()
       }
       return(invisible(NULL))
     }
@@ -69,7 +70,8 @@ Slidy presentation
           rmarkdown::render(OutRMD, output_format=slidy_presentation())
       }  # end folder existence condition
           else {
-        warning(""Specified folder does not exist. No action taken."")
+        .FolderNotFound()
+ .NoActionTaken()
       }
       return(invisible(NULL))
     }
@@ -135,7 +137,8 @@ MakeSlideShow =
         }
       }  # end folder existence condition
           else {
-        warning(""Specified folder does not exist. No action taken."")
+        .FolderNotFound()
+ .NoActionTaken()
       }
       return(invisible(NULL))
     }

---FILE: R/Messages.R---
@@ -99,6 +99,13 @@ message(NewFile, "" has been created in your working directory."")
 return(invisible(NULL))
     }
 
+.NoActionTaken =     function() {
+message(""No action taken."")
+return(invisible(NULL))
+    }
+
+
+
 .NoSeePython = function(){
 message(""Python cannot be seen on your system.\nIf it is installed, then you may need to ensure your system settings are correct."")
 return(invisible(NULL))

---FILE: R/PrepareWriteR.R---
@@ -30,11 +30,10 @@ PrepareWriteR =
           message(
               ""You can move these files to your preferred folder for WriteR, \nor start working here."")
         } else {
-          warning(
-              ""This function is for users running R under the Windows operating system.\n"")
+          .WindowsOnly()
         }
       } else {
-        warning(""This function is meant for use in interactive mode only.\n"")
+        .InteractiveOnly()
       }
       return(invisible(NULL))
     }"
ajrgodfrey,BrailleR,c17a574407357b27e90df26471511eb5414e6293,ajrgodfrey,ajgodfre@massey.ac.nz,2022-11-28T09:14:21Z,ajrgodfrey,ajgodfre@massey.ac.nz,2022-11-28T09:14:21Z,v0.33.4 fixing more messages,R/GettingStarted.R;R/MakeAdminBatch.R;R/MakeBatch.R;R/MakeRprofile.R;R/Messages.R;R/NewFunction.R;R/VIInternals.R,False,True,True,False,45,19,64,"---FILE: R/GettingStarted.R---
@@ -1,11 +1,9 @@
 GetGoing =
     function() {
       if (interactive()) {
-        message(
-            ""You will be asked to enter answers for a series of questions.\nHit <enter> to use the default shown in parentheses."")
+        .AnswerQuestions()
 
-        message(""\nEnter the name you want to use for authoring content. ("",
-                getOption(""BrailleR.Author""), "")"")
+        .AuthorName()
         name = readLines(n = 1)
         if (name != """") SetAuthor(name)
 
@@ -18,7 +16,7 @@ GetGoing =
         message(
             ""\nWhat is the level of significance you plan to use as your default? ("",
             getOption(""BrailleR.SigLevel""), "")"")
-        alpha = as.numeric(readLines(n = 1))
+       alpha = as.numeric(readLines(n = 1))
         if (!is.na(alpha)) SetSigLevel(alpha)
 
         message(

---FILE: R/MakeAdminBatch.R---
@@ -1,8 +1,3 @@
-.FileCreated =     function(file=NULL) {
-NewFile = ifelse(is.null(file), """", file)
-message(NewFile, "" has been created in your MyBrailleR directory."")
-return(invisible(NULL))
-    }
 
 
 # getting some useful batch files for admin tasks

---FILE: R/MakeBatch.R---
@@ -30,7 +30,7 @@ paste0('""', gsub(""/"", ""\\\\"", R.home())), paste0(.FindRInstallPathText, '""%Insta
 
             # write a file to show the system path settings
             cat(Sys.getenv(""PATH""), file = ""path.txt"")
-            message(""These details are saved in path.txt for reference."")
+            .SavedInPath()
             # write a test Rmd file
             cat(""# a test file
 ## created by the BrailleR package

---FILE: R/MakeRprofile.R---
@@ -5,8 +5,9 @@ MakeRprofile =
       if (Overwrite) {
         cat('.First=function(){\n  .First.sys()\n  library(BrailleR)\n}\n',
             file = "".Rprofile"")
-        message(
-            ""The .Rprofile file has been updated. The BrailleR package will be automatically loaded on startup in this working directory."")
+
+        .FileCreated("".Rprofile"", ""in the current working directory."") 
+        .AutoLoadBrailleR()
       } else {
 .FileExists(file="".Rprofile"")
         .OverWriteNeeded()

---FILE: R/Messages.R---
@@ -10,6 +10,25 @@ message(""The installer file has been added to your MyBrailleR folder."")
 return(invisible(NULL))
 }
 
+
+        .AnswerQuestions=function(){
+message(""You will be asked to enter answers for a series of questions.\nHit <enter> to use the default shown in parentheses."")
+return(invisible(NULL))
+}
+
+.AuthorName =     function() {
+message(""\nEnter the name you want to use for authoring content. ("",
+                getOption(""BrailleR.Author""), "")"")
+return(invisible(NULL))
+    }
+
+.AutoLoadBrailleR  =     function() {
+message(""The BrailleR package will be automatically loaded on startup in this working directory."")
+return(invisible(NULL))
+    }
+
+
+
 .CannotSeeWxPython = function(){
 message(""Python cannot see the necessary wx module.\nYou need to get that fixed."")
 return(invisible(NULL))
@@ -49,13 +68,20 @@ return(invisible(NULL))
 }
 
 
-.FileCreated =     function(file=NULL) {
+.FileCreated =     function(file=NULL, where=""in your MyBrailleR directory."") {
+NewFile = ifelse(is.null(file), """", file)
+message(NewFile, "" has been created "", where)
+return(invisible(NULL))
+    }
+
+.FileUpdated =     function(file=NULL, where=""in your MyBrailleR directory."") {
 NewFile = ifelse(is.null(file), """", file)
-message(NewFile, "" has been created in your MyBrailleR directory."")
+message(NewFile, "" has been updated "", where)
 return(invisible(NULL))
     }
 
 
+
 .InstallPython =     function() {
 message(""You could use GetPython3() and GetWxPython3() to help install them."")
 return(invisible(NULL))
@@ -90,6 +116,12 @@ message(""Your system is using "", VersionString, """")
 return(invisible(NULL))
     }
 
+.SavedInPath =     function() {
+message(""These details are saved in path.txt for reference."")
+return(invisible(NULL))
+    }
+
+
 
 
 

---FILE: R/NewFunction.R---
@@ -39,7 +39,6 @@ NewFunction =
 }
 ""), file = Filename,
           append = TRUE)
-      return(
-          message(
-              ""Script file successfully created in current working directory.\n""))
+        .FileCreated(Filename, ""in the current working directory."") 
+      return(invisible(NULL))
     }

---FILE: R/VIInternals.R---
@@ -378,4 +378,5 @@
   
   
   return(areaPercentageStr)
-}
\ No newline at end of file
+}
+"
ajrgodfrey,BrailleR,2901b8436c8f178c75b0e7a17636824deafb234c,James,1jamesthompson1@gmail.com,2022-11-27T22:59:12Z,James,1jamesthompson1@gmail.com,2022-11-27T22:59:12Z,"Fix geom_bar orientation issue

It should now display information about orientation correctly.",R/VIInternals.R;R/VIMethod3_TH.R;inst/whisker/VIdefault.txt,False,True,True,False,55,11,66,"---FILE: R/VIInternals.R---
@@ -91,6 +91,30 @@
   #Vertical bars
   if (sum(layer$flipped_aes == T) == 0) {
     return(""vertical"")
+    #Horizontal bars
+  } else if (sum(layer$flipped_aes == T) == length(layer$count)) {
+    return(""horizontal"")
+  } else {
+    return(""(error with orientation)"")
+  }
+}
+
+#Get number of bars in a geom_bar
+.getNumOfBars = function(data, flipped_aes) {
+  #Vertical bars
+  if (flipped_aes == ""vertical"") {
+    min = data$xmin
+    max = data$xmax
+  #Horizontal bars
+  } else {
+    min = data$ymin
+    max = data$ymax
+  }
+  widths = vector()
+  for (i in 1:length(min)) {
+    widths[length(widths)+1] = paste(toString(min[i]), "" to "", toString(max[i]))
+  }
+  length(unique(widths))
 }
 
 ## Scales

---FILE: R/VIMethod3_TH.R---
@@ -374,23 +374,43 @@ VI.ggplot = function(x, Describe=FALSE, threshold=10, template=system.file(""whis
       # as they won't be displayed
       cleandata = layer$data[!is.na(layer$data$xmin) & !is.na(layer$data$xmax),]
       # Recount rows
+      
+      # Whether the bar is vertical or horizontal
+      layer$orientation = .findBarOrientation(x, xbuild, layeri)
+      
       # Count how many bars are seen visually this is different
       # to the number of actual bars as bars may be stacked on top of each other
       layer$numberOfBars = .getNumOfBars(cleandata, layer$orientation)
       layer$n = nrow(cleandata)
-      map = .mapDataValues(x, xbuild, list(""x"", ""ymin"", ""ymax""), panel, 
-                           list(x=cleandata$x, ymin=cleandata$ymin, ymax=cleandata$ymax))
+    
+      # If bar width varies then we should report xmin and xmax instead
+      if (layer$orientation == ""vertical"") {
+        width = cleandata$xmax - cleandata$xmin
+        valueList = list(loc=cleandata$x, min=cleandata$ymin, max=cleandata$ymax)
+      } else {
+        width = cleandata$ymax - cleandata$ymin
+        valueList = list(loc=cleandata$y, min=cleandata$xmin, max=cleandata$xmax)
+      }
+      map = .mapDataValues(x, xbuild, list(""loc"", ""min"", ""max""), panel, 
+                           valueList)
+      
       if (!is.null(map$badTransform)) {
         layer$badtransform = TRUE
         layer$transform = map$badTransform
       } 
       layer$scaledata = map$value
-      # If bar width varies then we should report xmin and xmax instead
-      width = cleandata$xmax - cleandata$xmin
-      if (max(width) - min(width) > .0001)   # allow for small rounding error
-        layer$scaledata = cbind(layer$scaledata, xmin=cleandata$xmin, xmax=cleandata$xmax)
-      # Whether the bar is vertical or horizontal
-      layer$orientation = .findBarOrientation(x, xbuild, layeri)
+
+      #Print out information of width of bar if they vary
+      if (max(width) - min(width) > .0001) {  # allow for small rounding error
+        if (layer$orientation == ""vertical"") {
+          layer$scaledata = cbind(layer$scaledata, widthmin=cleandata$xmin, widthmin=cleandata$xmax)
+        } else {
+          layer$scaledata = cbind(layer$scaledata, widthmin=cleandata$ymin, widthmin=cleandata$ymax)
+        }
+        layer$varyingWidths = T
+      } else {
+        layer$varyingWidths = F
+      }
       # Also report on any aesthetic variables that vary across the layer
       layer = .addAesVars(x, xbuild, cleandata, layeri, layer, panel)
 

---FILE: inst/whisker/VIdefault.txt---
@@ -82,9 +82,9 @@ Data values may be reported incorrectly.
 a bar chart with {{numberOfBars}} {{orientation}} bar{{#s}}s{{/s}}.<br>
 {{^largecount}}
 {{#items}}Bar {{itemnum}}
-{{#xmin}} spans horizontally from {{xmin}} to {{xmax}}{{/xmin}}
-{{^xmin}} is centered horizontally at {{x}}{{/xmin}}
-, and spans vertically from {{ymin}} to {{ymax}}
+{{#varyingWidths}} spans width from {{widthmin}} to {{widthmin}}{{/varyingWidths}}
+{{^varyingWidths}} is centered at {{loc}}{{/varyingWidths}}
+, and length is from {{min}} to {{max}}
 {{#fill}} with fill colour {{fill}}{{#fillmap}} which maps to {{filllabel}} = {{fillmap}}{{/fillmap}}{{/fill}}
 {{#colour}} with border colour {{colour}}{{#colourmap}} which maps to {{colourlabel}} = {{colourmap}}{{/colourmap}}{{/colour}}
 {{#linetype}} with border line type {{linetype}}{{#linetypemap}} which maps to {{linetypelabel}} = {{linetypemap}}{{/linetypemap}}{{/linetype}}"
ajrgodfrey,BrailleR,e448e1cdbe549bfe4220323cd905628cfabf1b1b,James,1jamesthompson1@gmail.com,2022-11-27T22:58:43Z,James,1jamesthompson1@gmail.com,2022-11-27T22:58:43Z,"Fix issue with incorrect bin count for geom_bar

It has been changed to calculate seen bars by checking the widths rather than the number of rows. closes #35",NEWS.md;R/VIInternals.R;R/VIMethod3_TH.R;inst/whisker/VIdefault.txt,False,True,True,False,14,10,24,"---FILE: NEWS.md---
@@ -1,10 +1,11 @@
 #BrailleR 0.33.4
--Add shaded area for geom_smooth CI info to VI output.
--Add geom_ribbon support
--Add geom_area support. This has been added to the geom_ribbon branch and is treated like a geom_ribbon almost exactly the same.
--Add support for showing expand_limit effect on graph.
+- Add shaded area for geom_smooth CI info to VI output.
+- Add geom_ribbon support
+- Add geom_area support. This has been added to the geom_ribbon branch and is treated like a geom_ribbon almost exactly the same.
+- Add support for showing expand_limit effect on graph.
 - add functionality for winget tools into new winget.R file; should streamline software installation down the track
 - deprecated functions relating to Python 2.7 and functions relating to making slide shows
+- fix issue #35 with incorrect bin counts
 
 # BrailleR 0.33.3
 -Update author files

---FILE: R/VIInternals.R---
@@ -85,11 +85,11 @@
 }
 
 #Bar Orientation
-.findBarOrientation = function(x, xbuild, layer) {
-  flipped = xbuild$plot$layers[[layer]]$geom_params$flipped_aes
-  if (rlang::is_true(flipped))
-    return(""horizontal"")
-  else
+# It is done by looking at the the flipped_aes in the build object
+.findBarOrientation = function(x, xbuild, layeri) {
+  layer = xbuild$data[[layeri]]
+  #Vertical bars
+  if (sum(layer$flipped_aes == T) == 0) {
     return(""vertical"")
 }
 

---FILE: R/VIMethod3_TH.R---
@@ -374,6 +374,9 @@ VI.ggplot = function(x, Describe=FALSE, threshold=10, template=system.file(""whis
       # as they won't be displayed
       cleandata = layer$data[!is.na(layer$data$xmin) & !is.na(layer$data$xmax),]
       # Recount rows
+      # Count how many bars are seen visually this is different
+      # to the number of actual bars as bars may be stacked on top of each other
+      layer$numberOfBars = .getNumOfBars(cleandata, layer$orientation)
       layer$n = nrow(cleandata)
       map = .mapDataValues(x, xbuild, list(""x"", ""ymin"", ""ymax""), panel, 
                            list(x=cleandata$x, ymin=cleandata$ymin, ymax=cleandata$ymax))

---FILE: inst/whisker/VIdefault.txt---
@@ -79,7 +79,7 @@ Data values may be reported incorrectly.
 {{/largecount}}.<br>
 {{/typehline}}
 {{#typebar}}
-a bar chart with {{n}} {{orientation}} bar{{#s}}s{{/s}}.<br>
+a bar chart with {{numberOfBars}} {{orientation}} bar{{#s}}s{{/s}}.<br>
 {{^largecount}}
 {{#items}}Bar {{itemnum}}
 {{#xmin}} spans horizontally from {{xmin}} to {{xmax}}{{/xmin}}"
ajrgodfrey,BrailleR,2e94bce7e4a0e4fd171999832431b661e315f8ba,ajrgodfrey,ajgodfre@massey.ac.nz,2022-11-27T02:08:49Z,ajrgodfrey,ajgodfre@massey.ac.nz,2022-11-27T02:08:49Z,v0.33.4 fixing small blunders,R/WhatIs.R;R/WinGet.R,False,True,True,False,2,2,4,"---FILE: R/WhatIs.R---
@@ -1,7 +1,7 @@
 ## N.B. The first function was created before glimpse() was working nicely for a screen reader user; 
 ## it is somewhat redundant now, but kept for backwards compatibility
 
-check_it = CheckIt = function(x){
+check_it = CheckIt = function(x, ...){
     dplyr::glimpse(x)
     return(x)
 }

---FILE: R/WinGet.R---
@@ -6,7 +6,7 @@
 ## once working, look to update GetPython.R GetSoftware.R  and installPython.R
 
 .winget = function(what, action=c(""upgrade"", ""install"", ""show"", ""uninstall"")){
-    out = shell(paste(""winget"", action, what), intern=TRUE)
+    Out = shell(paste(""winget"", action, what), intern=TRUE)
     return(Out)
 }
 "
ajrgodfrey,BrailleR,19da9a0880a64c36a6a4ac8de8f16ceac798e4e6,Henrik Bengtsson,hb@aroma-project.org,2021-09-26T06:17:06Z,Henrik Bengtsson,hb@aroma-project.org,2021-09-26T06:17:06Z,FIX: Trim spaces from BibTeX URL,vignettes/BrailleRPublications.bib,False,False,False,False,1,1,2,"---FILE: vignettes/BrailleRPublications.bib---
@@ -171,7 +171,7 @@ @article{GodfreyRJournal
 month=Jun,
   number       = {1},
   pages        = {73-79},
-  url          = { https://journal.r-project.org/archive/2013-1/godfrey.pdf }
+  url          = {https://journal.r-project.org/archive/2013-1/godfrey.pdf}
 }
 
 "
ajrgodfrey,BrailleR,fd9101231f6ecbcb6d1f88254d1f77bd45f493b4,Henrik Bengtsson,hb@aroma-project.org,2021-09-25T15:55:04Z,Henrik Bengtsson,hb@aroma-project.org,2021-09-25T15:55:04Z,Spell corrections. Package now passes spelling::spell_check_package(),NEWS.md;README.md;inst/WORDLIST,False,False,False,False,7,4,11,"---FILE: NEWS.md---
@@ -4,7 +4,7 @@
 # BrailleR 0.31.4!
 - Testing for a return to CRAN; looked right.
 - changed dates and version numbers in readiness for CRAN
-- had to remove orientation checkinig for bars in ggplot() graphs; see VI.internals. this forced introduction of rlang package dependency
+- had to remove orientation checking for bars in ggplot() graphs; see VI.internals. this forced introduction of rlang package dependency
 - forced option to be set that is equivalent to GoBlind() to get VI.ggplot() to be automatic
 - minor cosmetic updates for Rmd files
 - Some improved messaging.
@@ -142,7 +142,7 @@ Pushed to CRAN on 6 July 2017
 - changes from VS merged via GitHub (not to be reported again)
 - moved knitr package to imports. This means some of the Rmd files need more explicit mention of the package to get chunk options working properly.
 - JG implemented the ViewSVG() so that anyone can use the interactive graph viewing system; required various internal functions to move and write necessary files 
-- added FittedLinePlot() which adds a fitted line to the ScatterPlot() implmented through ScatterPlot(); these use a few internal functions, found in ScatterPlot.R
+- added FittedLinePlot() which adds a fitted line to the ScatterPlot() implemented through ScatterPlot(); these use a few internal functions, found in ScatterPlot.R
 - added plot and print methods for various graph types. The print method refers to the plot function so acts just like the ggplot and lattice packages.
 - restructured the storage of graph parameters and arguments for a variety of the masked functions. The intention is to make cleaning things up easier.
 - adding examples to the graph making help pages to show that the BrailleR functions replicate base graphics functions
@@ -282,7 +282,7 @@ type; it will also include the code chunks that are reused frequently in other f
 # BrailleR 0.23.5
 - Implemented use of local settings stored in .BrailleROptions object (hidden)
 - There is now  a set of defaults that can be restored in addition to the currently active set of preferences in the BrailleROptions file within the package.
-- SaveMySettings() and RestoreMySettings() functions created for obvious outcomes. These are needed to protec from losing settings when the package is updated.
+- SaveMySettings() and RestoreMySettings() functions created for obvious outcomes. These are needed to protect from losing settings when the package is updated.
 - A wrapper for WriteR is now included.
 - MakeAllFormats() added to create pandoc settings files based on the foo.pandoc file in the inst folder.
 - What's this figure? function WTF() now incorporated.

---FILE: README.md---
@@ -33,7 +33,7 @@ By participating in the BrailleR Project, you are agreeing to this code of condu
 
 Some issues to resolve:
 
-1. storing the graphical parameters in ScatterPlot() etc. does not necessarily get the right ones slected. Need to replace this by somehow keeping the ... arguments supplied by the user. Tested using col and pch in FittedLinePlot()
+1. storing the graphical parameters in ScatterPlot() etc. does not necessarily get the right ones selected. Need to replace this by somehow keeping the ... arguments supplied by the user. Tested using col and pch in FittedLinePlot()
 2. Get extra bits of information for WTF() coming through, such as other shapes, lines etc.
 1. Add to the work done by Debra Warren and Paul Murrell on VI.ggplot()  and related functions.
 2. ascertain which shiny app widgets are useful for blind users' screen reading software.

---FILE: inst/WORDLIST---
@@ -30,6 +30,7 @@ GetPython
 GetRStudio
 GetWriteR
 GetWxPython
+GoBlind
 HB
 HSD
 ICCHP
@@ -191,6 +192,7 @@ optimising
 packageVersion
 pandoc
 pch
+pkgdown
 png
 prcomp
 pyw
@@ -203,6 +205,7 @@ repo
 requireNamespace
 reticulate
 rfmt
+rlang
 rmarkdown
 roloc
 scalable"
ajrgodfrey,BrailleR,f1936abae38dabc3fe2f44be88bfe227727571a9,Henrik Bengtsson,hb@aroma-project.org,2021-09-25T15:49:08Z,Henrik Bengtsson,hb@aroma-project.org,2021-09-25T15:49:08Z,"Fix URLs that redirects to other URLS, e.g. HTTP -> HTTPS",.Rhistory;vignettes/BrailleRPublications.bib;vignettes/GettingStarted.Rmd;vignettes/qplot.Rmd,True,False,True,False,5,5,10,"---FILE: .Rhistory---
@@ -1,4 +1,3 @@
-q()
 library(BrailleR)
 update.packages(ask=F)
 q()
@@ -510,3 +509,4 @@ q()
 library(usethis)
 use_github_action(""pkgdown"")
 q()
+remotes::install_github(""ajrgodfrey/BrailleR"", dependencies=TRUE)

---FILE: vignettes/BrailleRPublications.bib---
@@ -340,7 +340,7 @@ @inproceedings{GodfreyMurrell2016TactileGraphsPaper
 editor={Katsuhito Yamaguchi and Masakazu Suzuki},
 address={Kanegawa, Japan},
 pages={69-74},
-uUrl={http://workshop.sciaccess.net/DEIMS2016/index.html}
+uUrl={https://workshop.sciaccess.net/DEIMS2016/index.html}
 }
 
 @misc{GodfreyBilton2016UseROral,
@@ -368,6 +368,6 @@ @inproceedings{GodfreyCurtis2016WriteRPaper
 editor={Katsuhito Yamaguchi and Masakazu Suzuki},
 address={Kanegawa, Japan},
 pages={47-54},
-url={http://workshop.sciaccess.net/DEIMS2016/index.html}
+url={https://workshop.sciaccess.net/DEIMS2016/index.html}
 }
 

---FILE: vignettes/GettingStarted.Rmd---
@@ -24,7 +24,7 @@ BrailleR requires the very useful file converter called pandoc. Get it from the
 ### The principal integrated development environment --- RStudio
 
 It is a good idea to install RStudio, even if you can't actually use it as a blind person using screen reading software. The reason is that RStudio installs a few other useful tools that we will make use of by other means. Get it from the
-[RStudio download page](https://rstudio.com/products/rstudio/download/)
+[RStudio download page](https://www.rstudio.com/products/rstudio/download/)
 
 ### One programming language --- Python
 

---FILE: vignettes/qplot.Rmd---
@@ -9,7 +9,7 @@ output: knitr:::html_vignette
 ---
 
 
-This vignette  contained many more plots in its initial development. The set has been cut back considerably to offer meaningful testing only, and because much of the material was moved over to a book called [BrailleR in Action.](https://R-Resources.massey.ac.nz/BrailleRInAction) Doing so also had an advantage of speeding up the package creation, testing, and installation.
+This vignette  contained many more plots in its initial development. The set has been cut back considerably to offer meaningful testing only, and because much of the material was moved over to a book called [BrailleR in Action](https://R-Resources.massey.ac.nz/BrailleRInAction/). Doing so also had an advantage of speeding up the package creation, testing, and installation.
 N.B.  the commands here are either exact copies of the commands presented in Wickham (2009) or some minor alterations to them.    Notably, some code given in the book no longer works. This is given a `#!`    
 
 "
ajrgodfrey,BrailleR,f73a7966e548486892a9197e67a94250e2c89590,Sophie Banks,61633685+boringNectarine0@users.noreply.github.com,2021-02-10T00:33:56Z,GitHub,noreply@github.com,2021-02-10T00:33:56Z,"Positioning patch (#3)

* Update VIdefault.txt

* Update VIMethod3_TH.R

* Update VIInternals.R",R/VIInternals.R;R/VIMethod3_TH.R;inst/whisker/VIdefault.txt,False,True,True,False,38,6,44,"---FILE: R/VIInternals.R---
@@ -307,10 +307,11 @@
     return(TRUE)
   return(FALSE)
 }
-  
 #Helper list for finding whether words start with vowels to give them an/a accordingly
 .giveAnOrA =function(wordChosen){
   vowels = c(""a"", ""e"", ""i"", ""o"", ""u"")
   AnA = ifelse(is.element(substr(wordChosen, 1,1), vowels), ""an"", ""a"")
   return(AnA)
 }
+
+

---FILE: R/VIMethod3_TH.R---
@@ -460,12 +460,40 @@ VI.ggplot = function(x, Describe=FALSE, threshold=10, template=system.file(""whis
     } else {
       layer$type = ""unknown""
       #Name the unknown type and give it a/an accordingly
-      vowels = c(""a"", ""e"", ""i"", ""o"", ""u"")
       className = tolower(gsub(""^.*?Geom"","""",layerClass))
       layer$assign = className
       layer$anA = .giveAnOrA(className)
     }
-    layers[[layeri]] = layer  
+    
+    ##Positioning
+    layerPos = .getGGLayerPosition(x, xbuild, layeri)
+    if (is.null(layerPos)){
+      layer$hasPos = FALSE
+    }else{layer$hasPos = TRUE}
+    if (layerPos == ""dodge""){
+      layer$position = ""adjacent, as sorted by""
+    }else if (layerPos == ""fill""){
+      if(layerClass == ""GeomBar""){
+        layer$position = ""stacked and shown as propotions of""
+      }else{layer$hasPos = FALSE}
+    }else if (layerPos == ""identity""){
+      if(layerClass == ""GeomBar""){
+        layer$position = ""stacked, as sorted by""
+      }else{layer$hasPos = FALSE}
+    }else if (layerPos == ""stack""){
+      layer$position = ""stacked, as sorted by""
+    }else if (layerPos == ""jitter""){
+      layer$position = ""offset by added random noise, and sorted by""
+    }else if (layerPos == ""jitterdodge""){
+      layer$position = ""offset along the x axis to avoid overlapping points, and sorted by""
+    }else if (layerPos == ""nudge""){
+      if(layerClass == ""GeomText""){""adjusted text placement for tidier graph""
+      }else{layer$hasPos = FALSE}
+    }
+    layer$mapping2 = .getGGGuideLabels(x, xbuild)
+    
+    layers[[layeri]] = layer
+    
   }
   return(layers)
 }

---FILE: inst/whisker/VIdefault.txt---
@@ -79,7 +79,7 @@ Data values may be reported incorrectly.
 {{/largecount}}.<br>
 {{/typehline}}
 {{#typebar}}
-a bar chart containing {{n}} {{orientation}} bar{{#s}}s{{/s}}.<br>
+a bar chart containing {{n}} {{orientation}} bar{{#s}}s{{/s}}
 {{^largecount}}
 {{#items}}Bar {{itemnum}}
 {{#xmin}} spans horizontally from {{xmin}} to {{xmax}}{{/xmin}}
@@ -93,7 +93,7 @@ a bar chart containing {{n}} {{orientation}} bar{{#s}}s{{/s}}.<br>
 {{/largecount}}
 {{/typebar}}
 {{#typepoint}}
-a set of {{n}} point{{#s}}s{{/s}}.<br>
+a set of {{n}} point{{#s}}s{{/s}}
 {{^largecount}}
 The points are at:<br>
 {{#items}}({{x}}, {{y}})
@@ -137,11 +137,14 @@ There are {{noutliers}} outliers for this boxplot.<br>
 {{/items}}
 {{/typebox}}
 {{#typesmooth}}
-a '{{method}}' smoothed curve {{#ci}} with {{level}} confidence intervals {{/ci}}.<br>
+a '{{method}}' smoothed curve{{#ci}} with {{level}} confidence intervals{{/ci}}
 {{/typesmooth}}
 {{#typeunknown}}
 {{anA}} {{assign}} graph that VI isn't able to process.<br>
 {{/typeunknown}}
+{{#hasPos}}
+ which are {{position}} {{mapping2}}
+{{/hasPos}}.<br>
 {{#layeraes}}
 {{^singlelayer}}Layer {{layernum}} {{/singlelayer}}{{#singlelayer}}The chart {{/singlelayer}}
 has {{aes}} set to {{mapping}}.<br>"
ajrgodfrey,BrailleR,7c6ff26d9e7387e54e8f3985697dc8d2529af151,Sophie Banks,61633685+boringNectarine0@users.noreply.github.com,2021-01-31T06:53:08Z,GitHub,noreply@github.com,2021-01-31T06:53:08Z,"v0.31.3 small fixes from package checks (#2)

Co-authored-by: ajrgodfrey <a.j.godfrey@massey.ac.nz>",NEWS.md;R/UpdateGraph.R;man/UpdateGraph.Rd;vignettes/BrailleRHistory.rmd,True,True,True,False,9,9,18,"---FILE: NEWS.md---
@@ -1,5 +1,5 @@
 # BrailleR 0.31.3
-- cleaned SB's code. We now have geom_smooth() reporting method and existence of CIs.
+- cleaned Sophie's code. We now have geom_smooth() reporting method and existence of confidence intervals.
 - renamed BrailleR functions xlab() and ylab() to use upper camel case to resolve conflict with ggplot2.
 - getting ready for contributions from Sophie Banks; added her to contributors list
 

---FILE: R/UpdateGraph.R---
@@ -1,5 +1,5 @@
-# NB xlab() and ylab() are also functions in ggplot2; 
-# this BrailleR  implementation is inconsistent with ggplot2.
+# NB xlab() and ylab() are functions in the ggplot2 package; 
+# the original BrailleR  implementation was inconsistent with ggplot2 so the function names were chantged to camel case.
 
 Main = XLab = YLab = function(graph, label=NULL){
     arg = as.character(match.call()[[1]])

---FILE: man/UpdateGraph.Rd---
@@ -1,11 +1,11 @@
 \name{UpdateGraph}
 \alias{UpdateGraph}
-\alias{main}
+\alias{Main}
 \alias{update.fittedlineplot}
 \alias{update.scatterplot}
 \alias{update.tsplot}
-\alias{xlab}
-\alias{ylab}
+\alias{XLab}
+\alias{YLab}
 \title{extract or alter graph parameters}
 \description{Either grabs the specified label or sets it to a newly specified value. In this case the graph is re-drawn and the graph object is updated.}
 \usage{
@@ -30,9 +30,9 @@ Specify the label to be an empty text string if the desire is to delete the curr
 attach(airquality)
 op = par(mfcol=c(3,2))
 test1 = TimeSeriesPlot(Wind, col=4)
-xlab(test1, ""Day"")
+XLab(test1, ""Day"")
 # check the change is permanent by doing another change
-test1 %>% main(""titles are important"") # nice that the pipe works!
+test1 %>% Main(""titles are important"") # nice that the pipe works!
 
 test2 = TimeSeriesPlot(Ozone)
 # using the update method

---FILE: vignettes/BrailleRHistory.rmd---
@@ -91,7 +91,7 @@ University event in 2013. This gave me the first opportunity to
 put the package in front of an audience that I hope will gain from the
 package's existence. 
 
-I've already mentioned the following contributors above:Paul Murrell, Yihui Xie, Timothy Bilton, and James Curtis. In December 2016, I was visiting Donal Fitzpatrick at Dublin City University and we were joined by Volker Sorge for a few days. Volker's work in creating an accessible tool for explorationof chemical molecules is being broadened into statistical graphs.
+I've already mentioned the following contributors above:Paul Murrell, Yihui Xie, Timothy Bilton, and James Curtis. In December 2016, I was visiting Donal Fitzpatrick at Dublin City University and we were joined by Volker Sorge for a few days. Volker's work in creating an accessible tool for exploration of chemical molecules is now being broadened into statistical graphs.
 
 I also need to acknowledge the value of attending the Summer University events.  I gain so much from my interactions with the students who attend, the other workshop leaders who gave me feedback, and the other professionals who assist blind students in their own countries.
  "
ajrgodfrey,BrailleR,437c4524535445da47429ac293fb199d17704aa7,ajrgodfrey,a.j.godfrey@massey.ac.nz,2021-01-17T11:39:15Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2021-01-17T11:39:15Z,v0.31.3 small fixes from package checks,NEWS.md;R/UpdateGraph.R;man/UpdateGraph.Rd;vignettes/BrailleRHistory.rmd,True,True,True,False,9,9,18,"---FILE: NEWS.md---
@@ -1,5 +1,5 @@
 # BrailleR 0.31.3
-- cleaned SB's code. We now have geom_smooth() reporting method and existence of CIs.
+- cleaned Sophie's code. We now have geom_smooth() reporting method and existence of confidence intervals.
 - renamed BrailleR functions xlab() and ylab() to use upper camel case to resolve conflict with ggplot2.
 - getting ready for contributions from Sophie Banks; added her to contributors list
 

---FILE: R/UpdateGraph.R---
@@ -1,5 +1,5 @@
-# NB xlab() and ylab() are also functions in ggplot2; 
-# this BrailleR  implementation is inconsistent with ggplot2.
+# NB xlab() and ylab() are functions in the ggplot2 package; 
+# the original BrailleR  implementation was inconsistent with ggplot2 so the function names were chantged to camel case.
 
 Main = XLab = YLab = function(graph, label=NULL){
     arg = as.character(match.call()[[1]])

---FILE: man/UpdateGraph.Rd---
@@ -1,11 +1,11 @@
 \name{UpdateGraph}
 \alias{UpdateGraph}
-\alias{main}
+\alias{Main}
 \alias{update.fittedlineplot}
 \alias{update.scatterplot}
 \alias{update.tsplot}
-\alias{xlab}
-\alias{ylab}
+\alias{XLab}
+\alias{YLab}
 \title{extract or alter graph parameters}
 \description{Either grabs the specified label or sets it to a newly specified value. In this case the graph is re-drawn and the graph object is updated.}
 \usage{
@@ -30,9 +30,9 @@ Specify the label to be an empty text string if the desire is to delete the curr
 attach(airquality)
 op = par(mfcol=c(3,2))
 test1 = TimeSeriesPlot(Wind, col=4)
-xlab(test1, ""Day"")
+XLab(test1, ""Day"")
 # check the change is permanent by doing another change
-test1 %>% main(""titles are important"") # nice that the pipe works!
+test1 %>% Main(""titles are important"") # nice that the pipe works!
 
 test2 = TimeSeriesPlot(Ozone)
 # using the update method

---FILE: vignettes/BrailleRHistory.rmd---
@@ -91,7 +91,7 @@ University event in 2013. This gave me the first opportunity to
 put the package in front of an audience that I hope will gain from the
 package's existence. 
 
-I've already mentioned the following contributors above:Paul Murrell, Yihui Xie, Timothy Bilton, and James Curtis. In December 2016, I was visiting Donal Fitzpatrick at Dublin City University and we were joined by Volker Sorge for a few days. Volker's work in creating an accessible tool for explorationof chemical molecules is being broadened into statistical graphs.
+I've already mentioned the following contributors above:Paul Murrell, Yihui Xie, Timothy Bilton, and James Curtis. In December 2016, I was visiting Donal Fitzpatrick at Dublin City University and we were joined by Volker Sorge for a few days. Volker's work in creating an accessible tool for exploration of chemical molecules is now being broadened into statistical graphs.
 
 I also need to acknowledge the value of attending the Summer University events.  I gain so much from my interactions with the students who attend, the other workshop leaders who gave me feedback, and the other professionals who assist blind students in their own countries.
  "
ajrgodfrey,BrailleR,58afaa80651368883ad227f66e00e3dd8db44532,ajrgodfrey,a.j.godfrey@massey.ac.nz,2021-01-17T07:53:54Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2021-01-17T07:53:54Z,v0.31.3 resolving issues from PR29,DESCRIPTION;NEWS.md,False,False,False,False,3,2,5,"---FILE: DESCRIPTION---
@@ -3,7 +3,7 @@ Type: Package
 Title: Improved Access for Blind Users
 Version: 0.31.3
 Author: A. Jonathan R. Godfrey [aut, cre], Debra Warren [aut], Donal Fitzpatrick [ctb], Duncan Murdoch [ctb], Greg Snow
-    [ctb], Henrik Bengtsson [ctb], James Curtis [ctb], JooYoung Seo [ctb], Marshall Flax [ctb], Paul Murrell [aut], Timothy Bilton [aut], Tony Hirst [ctb], Tsan-Kuang Lee [ctb], Volker Sorge [aut], Yihui Xie
+    [ctb], Henrik Bengtsson [ctb], James Curtis [ctb], JooYoung Seo [ctb], Marshall Flax [ctb], Paul Murrell [aut], Sophie Banks [ctb], Timothy Bilton [aut], Tony Hirst [ctb], Tsan-Kuang Lee [ctb], Volker Sorge [aut], Yihui Xie
     [ctb]
 Maintainer: A. Jonathan R. Godfrey <a.j.godfrey@massey.ac.nz>
 Authors@R: c(person(""A. Jonathan R."", ""Godfrey"", role=c(""aut"", ""cre""), email=""a.j.godfrey@massey.ac.nz""),
@@ -16,6 +16,7 @@ Authors@R: c(person(""A. Jonathan R."", ""Godfrey"", role=c(""aut"", ""cre""), email=""a.
     person(""JooYoung"", ""Seo"", email = ""jooyoung@psu.edu"", role = ""ctb""),
     person(""Marshall"", ""Flax"", email = ""marshall.flax@gmail.com"", role = ""ctb""),
     person(""Paul"", ""Murrell"", email = ""paul@stat.auckland.ac.nz"", role = ""aut""),
+    person(""Sophie"", ""Banks"", email = ""sb@xxx.com"", role = ""ctb""),
     person(""Timothy"", ""Bilton"", email = ""tbilton@gmail.com"", role = ""aut""),
     person(""Tony"", ""Hirst"", email = ""tony.hirst@open.ac.uk"", role = ""ctb""),
     person(""Tsan-Kuang"", ""Lee"", email = ""developer@tklee.com"", role = ""ctb""),

---FILE: NEWS.md---
@@ -1,7 +1,7 @@
 # BrailleR 0.31.3
 - cleaned SB's code. We now have geom_smooth() reporting method and existence of CIs.
 - renamed BrailleR functions xlab() and ylab() to use upper camel case to resolve conflict with ggplot2.
-- getting ready for contributions from Sophie Banks
+- getting ready for contributions from Sophie Banks; added her to contributors list
 
 # BrailleR 0.31.2
 - removed travis-ci package service as it will move to a fee-for-service model in 2021"
ajrgodfrey,BrailleR,00bd67b548d2b5161258b6bd9cea97ffa657d4dc,ajrgodfrey,a.j.godfrey@massey.ac.nz,2021-01-17T07:17:46Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2021-01-17T07:17:46Z,v0.31.3 resolving issues from PR29,NEWS.md;R/UpdateGraph.R;R/VIInternals.R;R/VIMethod3_TH.R;man/UpdateGraph.Rd,False,True,True,False,19,11,30,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
-#- getting ready for contributions from Sophie Banks
- BrailleR 0.31.3
+# BrailleR 0.31.3
+- cleaned SB's code. We now have geom_smooth() reporting method and existence of CIs.
+- renamed BrailleR functions xlab() and ylab() to use upper camel case to resolve conflict with ggplot2.
+- getting ready for contributions from Sophie Banks
 
 # BrailleR 0.31.2
 - removed travis-ci package service as it will move to a fee-for-service model in 2021

---FILE: R/UpdateGraph.R---
@@ -1,9 +1,9 @@
 # NB xlab() and ylab() are also functions in ggplot2; 
 # this BrailleR  implementation is inconsistent with ggplot2.
 
-main = xlab = ylab = function(graph, label=NULL){
+Main = XLab = YLab = function(graph, label=NULL){
     arg = as.character(match.call()[[1]])
-    Obj = as.character(match.call()[[""graph""]])
+    Obj = tolower(as.character(match.call()[[""graph""]]))
     if(any(class(graph)==""Augmented"")){
         if(is.null(label)){
             Out = .GetGraphText(graph, arg)

---FILE: R/VIInternals.R---
@@ -253,9 +253,15 @@
 }
 
 # Smooth layer details
+
+.getGGSmoothParams = function(x, xbuild, layer) {
+  return(xbuild$plot$layers[[layer]]$stat_params)
+}
+
 .getGGSmoothMethod = function(x, xbuild, layer) {
-  ifelse(is.null(xbuild$plot$layers[[layer]]$stat_params$method), 
-         return(""lowess""), return(xbuild$plot$layers[[layer]]$stat_params$method))
+  Out = xbuild$plot$layers[[layer]]$stat_params$method
+  if(is.null(Out))          Out = c(""lowess"")
+  return(Out)
 }
 
 .getGGSmoothSEflag = function(x, xbuild, layer) {

---FILE: R/VIMethod3_TH.R---
@@ -449,8 +449,8 @@ VI.ggplot = function(x, Describe=FALSE, threshold=10, template=system.file(""whis
     } else if (layerClass == ""GeomSmooth"") {
       layer$type = ""smooth""
       layer$method = .getGGSmoothMethod(x, xbuild, layeri)
-      layer$ci = if (.getGGSmoothSEflag(x, xbuild, layeri)) TRUE
-      layer$level = ifelse(.getGGSmoothSEflag(x, xbuild, layeri) == FALSE, '', .getGGSmoothLevel(x, xbuild, layeri))
+      layer$ci = .getGGSmoothSEflag(x, xbuild, layeri)
+#      layer$level = ifelse(layer$ci, .getGGSmoothLevel(x, xbuild, layeri))
 
       #U UNKNOWN
     } else {

---FILE: man/UpdateGraph.Rd---
@@ -11,11 +11,11 @@
 \usage{
 UpdateGraph(object, ...)
 
-main(graph, label = NULL)
+Main(graph, label = NULL)
 
-xlab(graph, label = NULL)
+XLab(graph, label = NULL)
 
-ylab(graph, label = NULL)
+YLab(graph, label = NULL)
 }
 \arguments{
   \item{graph,object}{The graph object to be updated.}"
ajrgodfrey,BrailleR,4dd7f1d8c55c5bb6e81d8381f54e7f07a64ded1b,Sophie Banks,61633685+boringNectarine0@users.noreply.github.com,2021-01-14T00:46:59Z,GitHub,noreply@github.com,2021-01-14T00:46:59Z,"Update VIInternals.R

fixed spelling error",R/VIInternals.R,False,True,True,False,1,1,2,"---FILE: R/VIInternals.R---
@@ -254,7 +254,7 @@
 
 # Smooth layer details
 .getGGSmoothMethod = function(x, xbuild, layer) {
-  ifelse(isnull(xbuild$plot$layers[[layer]]$stat_params$method), return(""lowess""), return(xbuild$plot$layers[[layer]]$stat_params$method))
+  ifelse(is.null(xbuild$plot$layers[[layer]]$stat_params$method), return(""lowess""), return(xbuild$plot$layers[[layer]]$stat_params$method))
 }
 
 .getGGSmoothSEflag = function(x, xbuild, layer) {"
ajrgodfrey,BrailleR,66d1eda5d1e2787e8141715470340378a5ab6e42,Hector Rincon,hecerinc@hotmail.com,2020-11-21T21:33:17Z,Hector Rincon,hecerinc@hotmail.com,2020-11-21T21:33:17Z,Fix ggplot 3.0 x and y ticks fetching for VI.ggplot(),R/VIInternals.R;R/VIMethod3_TH.R,False,True,True,False,57,55,112,"---FILE: R/VIInternals.R---
@@ -46,18 +46,24 @@
 
 .getGGXTicks = function(x, xbuild, layer) {
   # The location of this item is changing in an upcoming ggplot version
-  if (""panel_ranges"" %in% names(xbuild$layout))
+  if (""panel_ranges"" %in% names(xbuild$layout)) {
     return(xbuild$layout$panel_ranges[[layer]]$x.labels)   # ggplot 2.2.1
-  else
-    return(xbuild$layout$panel_params[[layer]]$x.labels)   # dev version as at 5 Sept 2017
+  }
+  else {
+    xlabs <- xbuild$layout$panel_params[[1]]$x$get_labels()
+    return (xlabs[!is.na(xlabs)])
+  }
 }
 
 .getGGYTicks = function(x, xbuild, layer) {
   # The location of this item is changing in an upcoming ggplot version
-  if (""panel_ranges"" %in% names(xbuild$layout))
+  if (""panel_ranges"" %in% names(xbuild$layout)) {
     return(xbuild$layout$panel_ranges[[layer]]$y.labels)   # ggplot 2.2.1
-  else
-    return(xbuild$layout$panel_params[[layer]]$y.labels)   # dev version as at 5 Sept 2017
+  }
+  else {
+    ylabs <- xbuild$layout$panel_params[[1]]$y$get_labels()
+    return (ylabs[!is.na(ylabs)])
+  }
 }
 
 # Guides

---FILE: R/VIMethod3_TH.R---
@@ -14,7 +14,7 @@
       result[[i]] = character(0)
     } else {
       render = whisker::whisker.render(templates[names(x[i])], x[[i]], partials=templates)
-    result[[i]] = as.vector(strsplit(render, ""<br>"", fixed=TRUE)[[1]])
+      result[[i]] = as.vector(strsplit(render, ""<br>"", fixed=TRUE)[[1]])
     }
   }
   names(result) = names(x)
@@ -44,7 +44,7 @@
     x$xaxis$xtickitems = .listifyVars(list(label=x$xaxis$xticklabels))
   if (!is.null(x$yaxis$yticklabels))
     x$yaxis$ytickitems = .listifyVars(list(label=x$yaxis$yticklabels))
-  
+
   for (legendi in 1:length(x$legends)) {
     if (!is.null(x$legends[[legendi]]$scalelevels))
       x$legends[[legendi]]$scalelevelitems = 
@@ -168,49 +168,45 @@ sort.VIgraph <- function(x, decreasing = FALSE, by=""x"", ...) {
 }
 
 grep <- function(pattern, x, ...) {
-    ## Dispatch on 'x' rather than 'pattern' !!!
-    UseMethod(""grep"", x)
+  ## Dispatch on 'x' rather than 'pattern' !!!
+  UseMethod(""grep"", x)
 }
 
-grep.default <-
-    function(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE,
-             fixed = FALSE, useBytes = FALSE, invert = FALSE, ...) {
-        base::grep(pattern, x, ignore.case, perl, value,
-                   fixed, useBytes, invert)
-    }
+grep.default <- function(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE, fixed = FALSE, useBytes = FALSE, invert = FALSE, ...) {
+  base::grep(pattern, x, ignore.case, perl, value, fixed, useBytes, invert)
+}
 
 # Returns the VIgraph object with the text trimmed down to only those rows
 # containing the specified pattern.  Passes extra parameters on to grepl.
 # Note that only the text portion of the VIgraph is modified; the complete
 # VIgg structure is still included
 grep.VIgraph <- function(pattern, x, ...) {
-    x$text = grep(pattern, x$text, value=TRUE, ...)
-    x
+  x$text = grep(pattern, x$text, value=TRUE, ...)
+  x
 }
 
 gsub <- function(pattern, replacement, x, ...) {
-    ## Dispatch on 'x' rather than 'pattern' !!!
-    UseMethod(""gsub"", x)
+  ## Dispatch on 'x' rather than 'pattern' !!!
+  UseMethod(""gsub"", x)
 }
-  
+
 gsub.default <-
-    function(pattern, replacement, x,
-             ignore.case = FALSE, perl = FALSE,
-             fixed = FALSE, useBytes = FALSE, ...) {
-        base::gsub(pattern, replacement, x, ignore.case, perl, 
-                   fixed, useBytes)
-    }
+  function(pattern, replacement, x,
+           ignore.case = FALSE, perl = FALSE,
+           fixed = FALSE, useBytes = FALSE, ...) {
+    base::gsub(pattern, replacement, x, ignore.case, perl, 
+               fixed, useBytes)
+  }
 
 gsub.VIgraph <- function(pattern, replacement, x, ...) {
-    x$text = gsub(pattern, replacement, x$text, ...)
-    x
+  x$text = gsub(pattern, replacement, x$text, ...)
+  x
 }
 
 # threshold specifies how many points, lines, etc will be explicitly listed.
 # Greater numbers will be summarised (e.g. ""is a set of 32 horizontal lines"" vs
 # ""is a set of 3 horizontal lines at 5, 7.5, 10"")
-VI.ggplot = function(x, Describe=FALSE, threshold=10, 
-                     template=system.file(""whisker/VIdefault.txt"", package=""BrailleR""), ...) {
+VI.ggplot = function(x, Describe=FALSE, threshold=10, template=system.file(""whisker/VIdefault.txt"", package=""BrailleR""), ...) {
   VIstruct = .VIstruct.ggplot(x)
   text = .VItextify(list(VIgg=.VIpreprocess(VIstruct, threshold)), template)[[1]]
   VIgraph = list(VIgg=VIstruct, text=text, threshold=threshold, template=template)
@@ -249,7 +245,7 @@ VI.ggplot = function(x, Describe=FALSE, threshold=10,
   panelcols = as.list(.getGGFacetCols(x, xbuild))
   layerCount = .getGGLayerCount(x, xbuild);
   VIstruct = .VIlist(annotations=annotations, xaxis=xaxis, yaxis=yaxis, legends=legends, panels=panels,
-              npanels=length(panels), nlayers=layerCount, panelrows=panelrows, panelcols=panelcols, type=""ggplot"")
+                     npanels=length(panels), nlayers=layerCount, panelrows=panelrows, panelcols=panelcols, type=""ggplot"")
   class(VIstruct) = ""VIstruct""
   return(VIstruct)
 }
@@ -266,7 +262,7 @@ VI.ggplot = function(x, Describe=FALSE, threshold=10,
     ## From ggplot2 3.0.0 can have x$labels without any corresponding
     ## xbuild$plot$scales
     if (is.null(scale))
-        break;
+      break;
     scalediscrete = if (""ScaleDiscrete"" %in% class(scale)) TRUE
     hidden = if (.isGuideHidden(x, xbuild, name)) TRUE
     maplevels = data.frame(col1=scale$map(scale$range$range), stringsAsFactors=FALSE)
@@ -311,12 +307,12 @@ VI.ggplot = function(x, Describe=FALSE, threshold=10,
       panel[[""yticklabels""]] = .getGGYTicks(x, xbuild, i)
       panel[[""xlabel""]] = .getGGXLab(x, xbuild) # Won't actually change over the panels
       panel[[""ylabel""]] = .getGGYLab(x, xbuild) # But we still want to mention them
-      
+
     }
     vars = list()
-      for (j in seq_along(panelvars)) {
-        vars[[j]] = list(varname=as.character(panelvars[j]), value=as.character(f[[i, panelvars[j]]]))
-      }
+    for (j in seq_along(panelvars)) {
+      vars[[j]] = list(varname=as.character(panelvars[j]), value=as.character(f[[i, panelvars[j]]]))
+    }
     panel[[""vars""]] = vars
     panel[[""panellayers""]] = .buildLayers(x, xbuild, i)
     panels[[i]] = panel
@@ -336,7 +332,7 @@ VI.ggplot = function(x, Describe=FALSE, threshold=10,
     else
       ngroups = 1
     layerClass = .getGGLayerType(x, xbuild, layeri)
-    
+
     # HLINE
     if (layerClass == ""GeomHline"") {
       layer$type = ""hline""
@@ -352,8 +348,8 @@ VI.ggplot = function(x, Describe=FALSE, threshold=10,
       layer$scaledata = map$value
       # Also report on any aesthetic variables that vary across the layer
       layer = .addAesVars(x, xbuild, cleandata, layeri, layer, panel)
-      
-    # POINT
+
+      # POINT
     } else if (layerClass == ""GeomPoint"") {
       layer$type = ""point""
       # Mark as hidden points that go outside the bounds of the plot,
@@ -369,7 +365,7 @@ VI.ggplot = function(x, Describe=FALSE, threshold=10,
       layer$scaledata = map$value
       # Also report on any aesthetic variables that vary across the layer
       layer = .addAesVars(x, xbuild, cleandata, layeri, layer, panel)
-      
+
 
       # BAR
     } else if (layerClass == ""GeomBar"") {
@@ -392,8 +388,8 @@ VI.ggplot = function(x, Describe=FALSE, threshold=10,
         layer$scaledata = cbind(layer$scaledata, xmin=cleandata$xmin, xmax=cleandata$xmax)
       # Also report on any aesthetic variables that vary across the layer
       layer = .addAesVars(x, xbuild, cleandata, layeri, layer, panel)
-      
-    # LINE
+
+      # LINE
     } else if (layerClass == ""GeomLine"") {
       layer$type = ""line""
       # Lines are funny - each item in the data is a point
@@ -423,17 +419,17 @@ VI.ggplot = function(x, Describe=FALSE, threshold=10,
         line = .addLineAesVars(x, xbuild, line, layeri, groupdata, panel)
         layer$lines[[length(layer$lines) + 1]] = line
       }
-      
-    #BOXPLOT
+
+      #BOXPLOT
     } else if (layerClass == ""GeomBoxplot"") {
       layer$type = ""box""
       cleandata = layer$data   # No need for cleaning since this data is already aggregated
       layer$n = nrow(layer$data)
       nOutliers = sapply(cleandata$outliers,length)
       map = .mapDataValues(x, xbuild,list(""x"", ""ymin"", ""lower"", ""middle"", ""upper"", ""ymax""), panel,
-                          list(x=cleandata$x, ymin=cleandata$ymin, lower=cleandata$lower, 
-                               middle=cleandata$middle, upper=cleandata$upper, 
-                               ymax=cleandata$ymax))
+                           list(x=cleandata$x, ymin=cleandata$ymin, lower=cleandata$lower, 
+                                middle=cleandata$middle, upper=cleandata$upper, 
+                                ymax=cleandata$ymax))
       if (!is.null(map$badTransform)) {
         layer$badtransform = TRUE
         layer$transform = map$badTransform
@@ -445,17 +441,17 @@ VI.ggplot = function(x, Describe=FALSE, threshold=10,
       # scaledata is currently a list of vectors.  If we wanted to include outliers
       # within each boxes object for reporting, then boxes would need to become
       # a list of lists.
-      
+
       # Also report on any aesthetic variables that vary across the layer
       layer = .addAesVars(x, xbuild, cleandata, layeri, layer, panel)
-      
-    # SMOOTH
+
+      # SMOOTH
     } else if (layerClass == ""GeomSmooth"") {
       layer$type = ""smooth""
       layer$method = .getGGSmoothMethod(x, xbuild, layeri)
       layer$ci = if (.getGGSmoothSEflag(x, xbuild, layeri)) TRUE
-      
-    #U UNKNOWN
+
+      #U UNKNOWN
     } else {
       layer$type = ""unknown""
     }
@@ -469,7 +465,7 @@ VI.ggplot = function(x, Describe=FALSE, threshold=10,
   for (var in varlist) {
     value = valuelist[[var]]
     scale = .getGGScale(x, xbuild, var)
-    
+
     if (is.null(scale))   # No scale found
       next
     else if ((""ScaleDiscrete"" %in% class(scale))) { # Try to map back to levels
@@ -559,7 +555,7 @@ VI.ggplot = function(x, Describe=FALSE, threshold=10,
   ## Use unconverted aesthetics for reverse lookup of mappings
   ## groupdata[1,aesvars,drop=FALSE] rather than aesvals[1,,drop=FALSE]
   aesmap = .mapAesDataValues(x, xbuild, layeri, aesvars,
-                            groupdata[1,aesvars,drop=FALSE])
+                             groupdata[1,aesvars,drop=FALSE])
   line[aesvars] = aesvals
   if (length(aesmap) > 0) {
     names(aesmap) = paste0(names(aesmap), ""map"")"
ajrgodfrey,BrailleR,6a41588e00e37c99d245599bce1540bd567cec69,ajrgodfrey,a.j.godfrey@massey.ac.nz,2018-07-23T20:00:43Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2018-07-23T20:00:43Z,v0.29.0 ggplot2 fixes,DESCRIPTION;NAMESPACE;README.md,False,False,False,False,3,1,4,"---FILE: DESCRIPTION---
@@ -36,6 +36,7 @@ Depends:
     R (>= 3.4.0)
 Imports:
     devtools,
+    dplyr,
     extrafont,
     ggplot2,
     grid,

---FILE: NAMESPACE---
@@ -1,4 +1,5 @@
 importFrom(""devtools"", ""spell_check"")
+import(dplyr)
 import(extrafont)
 importFrom(""ggplot2"", ""qplot"", ""ggplot_build"") 
 importFrom(""graphics"", ""abline"", ""par"", ""plot"") 

---FILE: README.md---
@@ -49,7 +49,7 @@ Some issues to resolve:
 5. Multiple language support was started but is in serious need of some love.
 7. Functions for the VI method to be completed include: VI.prcomp(), VI.factanal(), VI.glm(), VI.htest()?
 4. added functionality to compile all Rmd files in the current directory. Request from JYS; initial implementation done in June 2017. Includes batch file for use in Windows explorer and DOS prompt. Needs testing.
-- VI.scatterplot() needs creating
+5. VI.scatterplot() needs creating
 
 
 "
ajrgodfrey,BrailleR,f047706282e2a3c9ba3bfd3324a1ae022b5b80dd,ajrgodfrey,a.j.godfrey@massey.ac.nz,2018-07-23T18:49:52Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2018-07-23T18:49:52Z,v0.29.0 ggplot2 fixes,man/unfinished.Rd;vignettes/BrailleRPublications.bib;vignettes/WriteROptions,False,False,False,False,18,7,25,"---FILE: man/unfinished.Rd---
@@ -10,7 +10,7 @@
 \alias{VI.stepfun}
 \alias{VI.table}
 \title{
-Unfinished Methods to help vision impaired users
+Unfinished Methods to help vision impaired useRs
 }
 \description{
 A set of methods that will (once coded) extract the most relevant information from a graphical object (or implied set of graphical objects) and display the interpreted results in text form.

---FILE: vignettes/BrailleRPublications.bib---
@@ -1,9 +1,9 @@
   @Manual{BrailleRPackage,
     title = {BrailleR: Improved access for blind users},
     author = {A. Jonathan R. Godfrey},
-    year = {2016},
+    year = {2018},
     organization = {Massey University},
-    note = {R package version 0.25.3},
+    note = {R package version 0.28.0},
     url = {https://CRAN.R-project.org/package=BrailleR}
   }
 
@@ -285,6 +285,21 @@ @misc{Godfrey2014SU-StatsSoft
 startedday = 5,
 note={Plenary address delivered on 8 July, 2014 at the 5$^{th}$ Summer university held in Paris, France}
 }
+@misc{Godfrey2016SU-StatsSoft,
+author={A. Jonathan R. Godfrey},
+year=2016,
+title={A review of statistical software for blind students},
+conference = {6$^{th}$ Summer University held in conjunction with the International Conference on Computers Helping People},
+address = {Linz, Austria},
+finishyear = 2016,
+finishmonth = Jul,
+finishday = 12,
+startedyear = 2016,
+startedmonth = Jul,
+startedday = 8,
+note={Plenary address delivered on 12 July, 2016 at the 6$^{th}$ Summer University held in Linz, Austria}
+}
+
 
 
 @misc{Godfrey2016SU-TextTactileGraphs,

---FILE: vignettes/WriteROptions---
@@ -1,4 +0,0 @@
-RDirectory: C:\Program Files\R\R-devel\bin\x64\Rscript.exe
-filename: BrailleRHistory.rmd
-lastdir: C:\Users\ajgodfre\Documents\Research\BrailleR\PackageFiles\vignettes
-newText: Use WriteR to edit your R markdown files, perhaps by starting from a template file"
ajrgodfrey,BrailleR,3a47cbc93d9e4c84cbe0c7bfe01e3c93c1cc0993,dewarren,dwar068@aucklanduni.ac.nz,2017-10-02T04:24:21Z,Jonathan Godfrey,a.j.godfrey@massey.ac.nz,2017-10-02T04:24:21Z,"Debra's project work on VI.ggplot and MakeAccessibleSVG.ggplot (#13)

* Move all querying of the ggplot structure into functions.  Correctly
report axis labels.  Try reporting some info on layers (very preliminary)

* Return object and create print method; process additional layer data.

* Eliminate build warnings and document print.VItext function

Modify processing of call in .GrabExtraArgs and update.fittedlineplot
to eliminate warnings when resulting list is empty.  Document newly
introduced print.VItext function for VI.ggplot

* Start reporting on facets; suppress messages from ggplot_build calls

Initial steps to incorporate reporting on facets.  Note thaat counts
reported by .getGGLayerDataCount are misleading when facets are present.
Suppress warning messages (e.g. about bincount) from calls to
ggplot_build within our functions.

* Add .travis.yml file for Travis CI integration

* Start on getting MakeAccessibleSVG working with ggplot histograms

Proof of concept, assumes histogram and only partially working for them.
Temporarily commenting out dev.off in SVGThis.ggplot, so that I can do
grid.grep later.  This probably isn't the right answer.
Needed to add a small stylesheet to the html to set stroke-opacity=1 for
the bars.
Adding optional id parameter to .AddXMLAdd... functions since ggplot
IDs are different, but those functions otherwise do what I need.

* Get axes working in MakeAccessibleSVG.ggplot; other small improvements

* Get MakeAccessibleSVG partly working for geom_lines including multiples

MakeAccessibleSVG.ggplot now handles plots with a single geom_line (more
or less). Because the whole line is a single polyline, can't highlight
segments visually, but have included a work-around so we can still
describe them individually in text.
Have started to handle multiple layers -- only for lines currently, and
only if all layers are lines

* Correct SVGThis.ggplot device handling (using new createDevice parameter)

Handle devices better so as to not display extraneous graphs to the user
during MakeAccessibleSVG call (by drawing to null PDF device).
Includes man page update to reflect new ""..."" parameter to SVGThis
generic.  Also minor AddXML tidyup.

* Introduce (very incomplete) templating for VI output

Separate building of VIgg object (which logically represents the graph)
from production of text output (textify).  Text output is built using a
mustache template.  Requires whisker package.  Still very incomplete.

* Include whisker package for mustache templating, and other small changes

Update DESCRIPTION and NAMESPACE files re: inclusion of whisker package.
Implement a few other small fixes to address build warnings and fix
handling of fill and colour factors

* Read mustache template from file.  Implement more VI functionality

Mustache template is now read from a file - default is in inst/whisker.
Re-implementing more of the old VI.ggplot functionality into this scheme.

* Revamp VI.ggplot code flow; have MakeAccessibleSVG.ggplot use VIstruct

Create separate function VIstruct.ggplot to build object describing graph,
which is called by VI.ggplot and also now called by MakeAccessibleSVG
Add some new content into the structure to meet the needs of
MakeAccessibleSVG.  Tidy up NAMESPACE and man page to get a clean build.

* Generalize re: legends; introduce threshold param; other tidyup

Replace specific handling of colour and fill colour legends with more
generalized legend reporting.  Introduce threshold to specify maximum
number of individual data elements that should be individually listed in
the output.  Fix extraction of yintercepts for hline geom.

* Handle (minimally) some additional layer types, including smoothers

Add more layer types with minimal description.  Capture some layer data
irrespective of layer type.  Fix some MakeAccessible bugs introduced by
last commit.

* Fix overzealous claims re: legends. Report on non-default layer aesthetics

* Handle hidden guides correctly

If guide has been set to ""none"", don't say that there is a legend.
Mapping is still reported and we explicitly say that the legend has
been hidden

* Get facets working correctly (mostly) in VI.  Breaks MakeAccessible

Report correctly on facets, including ones containing multiple layers.
Still doesn't work correctly if facet specified with no dot, e.g.:
facets =~ year
Will temporarily break MakeAccessible.ggplot, until it's updated to
reflect the new structure

* Separate whisker preprocessing; print as side-effect; allow threshhod param

Fields only needed in the structure due to the limitations of whisker are
now added in a separate preprocessing step.
VI now prints as a side-effect, and print.VIgraph now correctly returns
the object invisibly.
Threshold parameter is now correctly set up to be passed in to VI.
Incomplete MakeAccessible code for handling panels has been tidied up.

* Fix MakeAccessibleSVG bug introduced when removing type flags from VIstruct

VIstruct object no longer contains the binary flags for type.  Changed
MakeAccessible to use the type variable instead.

* Cater for changes in ggplot2 dev version

The ggplot_build structure apparently has some changes coming.  We now
cater for either the ggplot 2.2.1 structure or the new structure

* Report on x,y for points; Fix bug from prior commit

Prior commit didn't actually report labels correctly for ggplot 2.2.1.
Now reporting (x,y) values for charts of type point (if not more than
threshold) of them.

* Describe individual lines, bars, boxes

Print details of bars, lines, or boxes.  Note, doesn't work correctly for
factors -- integer values are printed rather than levels

* Try to report x,y values that are factors correctly

X or Y values that were factors were getting their integer values reported.
Now we try to look up the values using the relevant scale.  Still fails
or gets it wrong if the value is jittered or log-transformed, or if the
chart is faceted with 'scales = ""free""'

* Remove printing as a side-effect. Don't run summary in qplot vignette

* Add VIgrep function for filtering VI.ggplot output. Update man pages.

* Detect & fail on non-standard coordinate systems

Any coordinate sysem other than Cartesian or fixed (equal) will cause a warning
message and character(0) output text.
Would be nice to at least handle flipped coordinates, but for now better to
say nothing than say something incorrect.

* Report scale info correctly. Play with reporting original x,y for points

Factor level for scales was being found with reference to x$data, which
doesn't always exist.  Now reported correctly (hopefully) from scales.
X and Y values for plot body are hard to report correctly from the
ggplot_build table as it's already transformed in a number of ways.  Try
reporting them from the raw data instead.  Still experimenting.  Only
implemented for points so far.  Haven't yet taken account of non-identity
stats for this.

* Handle scale_free correctly. Round some real values to 2 decimal places

If scale_free set for either axis, we will now report axis ticks at the
panel level rather than the top level.
Rounding of real values implemented within .getGGRawValues which is
currently only used for points -- still figuring out how to identify
which values are aggregated vs coming directly from the raw data

* Handle layer-specific data when getting raw values

Also now coping with x,y specified outside of aes() when getting raw
values.

* Move helper functions into separate file; report grouped lines better

Have moved all the helper functions that access the ggplot object into
a separate file.  Report correct number of lines, for grouped lines.
Reporting of points within the lines is still incorrect.  Fixed bug
in reporting of axes when scale_free is false.

* Fix handling of facet equations with nothing on left-hand side

Also removed debugging print

* Map data values back to original scales for all plot types

Requires use of inverse transforms for continuous variables.  We complain
if a transformation is used with no inverse function provided

* Delay creation of item detail lists until preprocessing

This is much more efficient as we only need to create these lists if
the number of items is below the threshold for printing

* Report correctly on points within lines

* Correct reporting for stacked bars, and item numbers for all item types.

For stacked bars we were reporting the y-position of the top of the bar
rather than its height.  Now explicitly reporting y-min and y-max instead.
Also were reporting item number incorrectly.

* Make a start on reporting for individual chart items

Only points and bars handled so far.  Reporting may not be very
meaningful to the user yet -- e.g. linetype 42, color #619CFF, shape 15.

* Don't report on zero height bars or those outside x-limits of chart

Didn't need to handle bars going outside y-limits as ggplot excludes
them from its plot data.
Still will report on bars that are invisible due to transparency, color,
or alpha, or those not visible due to very small but non-zero values.
Still need to code similar processing for other chart types.

* Stop reporting on items that are NA or outside limits or 0-height bars

Exact details vary by geom type.
Also report bar width if it's not constant.

* Tidy up code	- adding spaces mostly

* Introduce list separator text.  Include README describing VIgg object

We nnow can print lists with grammatical separators (commas and the word
""and"" between the last 2 items).  Axis tick labels are also in a proper
list now (not just a vector) so they can be nicely printed.
Also, list the number of panels at the start for faceted graphs.
Have introduced README.md file in whisker folder that describes the
VIgg object that the template has to work with.

* Start on mapping aesthetics back to corresponding data values

Only done for points and hlines currently, and only for categorical
values not continuous.
Also fixes bug in .getGGPanelScale

* Try to report hidden guides correctly; add separators for legend levels

Try to capture all the different ways that the guides (legends) can be
hidden - in new function isGuideHidden.
Convert legend levels from vector to list, for prettier printing.

* Correctly check layers in .isGuideHidden

Need to check for show.legend specified on all layers that might use
this guide.

* Introduce test script.  Describe shape aesthetic

* Generalise reporting of aesthetics on the data points

Still not implemented for lines, which are a bit special, and still
not mapping continuous variables

* Update test output; Put space in (x, y)

* Introduce VIsort function.  Fix MakeAccessible problem with missing bars

The change on 13 Sept discarded data regarding zero-height histogram bars,
which broke MakeAccessible since those bars are still present in the SVG.
This change puts those bars back into the $data dataframe.
Introduce VIsort function that sorts data by x or y for reporting (not
very fully tested as yet).
Start work on getting MakeAccessible working when x variable is a factor -
still incomplete

* Include zero-height bars; partly improve MakeAccessible for categorical x

As per Jonathan's feedback, we now do report even on zero-height bars when
reporting on histograms.
Making a start on having MakeAccessibleSVG correctly handle categorical x
axis values.  It now doesn't report x-start and x-end, but it still
reports the factor integer rather than the correct value.  Needs to use
sampledata rather than data, but need to sort out handling of bars outside
xlim first.

* Introduce more tests for aesthetics, and fix gaps found. Add .Rbuildignore.

Test output of all aesthetics that are valid for each handled plot type.
Some gaps were found which have been addressed.  Note that no aesthetics
are reported currently for lines - this remains a ""to do"" item.
Introduced .Rbuildignore file to prevent .travis.yml file being included
in the build.

* Improve reporting for aesthetic scales.  Include more test cases.

Giving up for now on the idea of mapping continuous aesthetics back to
their starting value -- since I've realised that .getGGRawValues isn't
going to do the trick. But, now reporting the mapping better when
describing the scale.
Introduced more test cases involving different ways of providing data
(using a data= parameter, variables in the environment, or constants).

* Report aesthetics for lines

Report aesthetics for each line, if the aesthetic is constant over the
entire line -- otherwise say that it varies
Had to change name of flags for geom types -- as ""linetype"" conflicted
with the linetype aesthetic.

* Code tidy-up for MakeAccessibleSVG.ggplot stuff (spacing mainly)",.Rbuildignore;.travis.yml;DESCRIPTION;NAMESPACE;R/AddXMLInternal.R;R/AddXMLMethod.R;R/BrowseSVG.R;R/MakeAccessibleSVGMethod.R;R/SVGThis.R;R/ScatterPlot.R;R/UpdateGraph.R;R/VIInternals.R;R/VIMethod3_TH.R;inst/whisker/README.md;inst/whisker/VIdefault.txt;man/MakeAccessibleSVGMethod.Rd;man/SVGThis.Rd;man/VI.ggplot.Rd;man/VIgrep.Rd;man/VIsort.Rd;tests/VI.ggplot.test.R;tests/VI.ggplot.test.Rout.save;vignettes/qplot.Rmd,True,True,True,False,2024,115,2139,"---FILE: .Rbuildignore---
@@ -0,0 +1 @@
+^\.travis\.yml$
\ No newline at end of file

---FILE: .travis.yml---
@@ -0,0 +1,2 @@
+language: r
+cache: packages
\ No newline at end of file

---FILE: DESCRIPTION---
@@ -47,6 +47,7 @@ Imports:
     nortest,
     rmarkdown,
     utils,
+    whisker,
     XML,
     xtable
 Suggests:

---FILE: NAMESPACE---
@@ -15,6 +15,7 @@ import(rmarkdown)
 importFrom(""stats"", ""aggregate"", ""anova"", ""as.ts"", ""coef"", ""cor"", ""lm"", ""median"", ""na.omit"", ""qnorm"", ""rstudent"", ""sd"") 
 importFrom(""tools"", ""Rd2ex"")
 importFrom(""utils"", ""browseURL"", ""create.post"", ""download.file"", ""file.edit"", ""installed.packages"", ""menu"", ""packageVersion"", ""read.csv"", ""read.table"", ""savehistory"", ""tail"", ""unzip"", ""write.csv"") 
+importFrom(""whisker"", ""whisker.render"")
 import(XML)
 importFrom(""xtable"", ""xtable"")
 S3method(AddXML,default)
@@ -51,6 +52,7 @@ S3method(print,fittedlineplot)
 S3method(print,scatterplot)
 S3method(print,tsplot)
 S3method(print,wordlist)
+S3method(print,VIgraph)
 S3method(SVGThis,default)
   S3method(SVGThis,boxplot)
   S3method(SVGThis,dotplot)

---FILE: R/AddXMLInternal.R---
@@ -8,8 +8,9 @@
 #}
 
 ## Annotating title elements
-.AddXMLAddTitle = function(root, title="""", longTitle = paste(""Title:"", title)) {
-    annotation = .AddXMLAddAnnotation(root, position=1, .AddXMLmakeId(""main"", ""1.1""), kind=""active"")
+.AddXMLAddTitle = function(root, title="""", longTitle = paste(""Title:"", title), id=NULL) {
+    titleId = ifelse(is.null(id), .AddXMLmakeId(""main"", ""1.1""), id)
+    annotation = .AddXMLAddAnnotation(root, position=1, titleId, kind=""active"")
     XML::addAttributes(annotation$root, speech=paste(""Title:"", title), speech2=longTitle, type=""Title"")
     return(invisible(annotation))
 }
@@ -20,7 +21,8 @@
 .AddXMLAddAxis = function(root, values, label, groupPosition, name, groupId, labelId, lineId, ...) {
     position = 0
     labelNode = .AddXMLAxisLabel(root, label=label, position=position <- position + 1,
-                     id=labelId, axis=groupId)
+                     id=labelId, axis=groupId, ...)
+    # Shouldn't try to add lineNode if this is a ggplot
     lineNode = .AddXMLAxisLine(root, id=lineId, axis=groupId)
     tickNodes = .AddXMLAxisValues(root, values=values,
                               position=position <- position + 1, id=lineId, axis=groupId, ...)
@@ -31,7 +33,7 @@
 
 ## Parameterisation for x-axis
 .AddXMLAddXAxis = function(root, values=NULL, label="""", groupPosition=2, ...) {
-    .AddXMLAddAxis(root, values, label, groupPosition, ""x axis:"", ""xaxis"", ""xlab"", ""bottom"", ...)
+  .AddXMLAddAxis(root, values, label, groupPosition, ""x axis:"", ""xaxis"", ""xlab"", ""bottom"", ...)
 }
 
 ## Parameterisation for y-axis
@@ -56,9 +58,10 @@
 ## Aux methods for axes annotation.
 ##
 ## Axis labelling
-.AddXMLAxisLabel = function(root, label="""", position=1, id="""", axis="""", speechShort=paste(""Label"", label), speechLong=speechShort) {
-    annotation = .AddXMLAddAnnotation(root, position=position,
-                                      id=.AddXMLmakeId(id, ""1.1""), kind=""active"")
+.AddXMLAxisLabel = function(root, label="""", position=1, id="""", axis="""", speechShort=paste(""Label"", label), 
+                            speechLong=speechShort, fullLabelId=NULL,...) {
+    labelId=ifelse(is.null(fullLabelId),.AddXMLmakeId(id, ""1.1""),fullLabelId)
+    annotation = .AddXMLAddAnnotation(root, position=position,id=labelId, kind=""active"")
     XML::addAttributes(annotation$root, speech=speechShort, speech2=speechLong, type=""Label"")
     return(invisible(annotation))
 }
@@ -72,11 +75,14 @@
 }
 
 ## Axis values and ticks
-.AddXMLAxisValues = function(root, values=NULL, detailedValues=values, position=1, id="""", axis="""", ...) {
+.AddXMLAxisValues = function(root, values=NULL, detailedValues=values, position=1, id="""", axis="""", 
+                             fullTickLabelId=NULL, ...) {
     annotations <- list()
     if (length(values) <= 0) return(invisible(annotations))
     for (i in 1:length(values)) {
-        valueId = .AddXMLmakeId(id, ""axis"", ""labels"", paste(""1.1"", i, sep="".""))
+        valueId = ifelse(is.null(fullTickLabelId),
+                         .AddXMLmakeId(id, ""axis"", ""labels"", paste(""1.1"", i, sep=""."")),
+                         paste(fullTickLabelId,i,sep="".""))
         value = .AddXMLAddAnnotation(root, position=position + i - 1,
                                      id=valueId, kind=""active"")
         XML::addAttributes(value$root, speech=paste(""Tick mark"", values[i]), speech2=detailedValues[i], type=""Value"")
@@ -110,10 +116,77 @@
     return(invisible(annotation))
 }
 
+## Constructs a ggplot layer
+## TODO:  Currently assumes histogram or line (and probably plenty of other assumptions)
+.AddXMLAddGGPlotLayer = function(root, x=NULL, panel=1) {
+  annotation = .AddXMLAddAnnotation(root, position=4, 
+                                    id=paste(""center"", panel, x$layernum, sep=""-""), kind=""grouped"")
+  # TODO:  For all layer types:  need heuristic to avoid trying to describe
+  # individual data points if there are thousands of them
+  if (x$type == ""bar"") {    # Bar chart
+    barCount = nrow(x$data)
+    barGrob = grid.grep(gPath(""geom_rect""), grep=TRUE)
+    XML::addAttributes(annotation$root, speech=""Histogram bars"",
+                     speech2=paste(""Histogram with"", barCount, ""bars""),
+                     type=""Center"")
+    annotations = list()
+    chartData = x$data  
+    for (i in 1:barCount) {
+      barId = paste(barGrob$name, ""1"", i, sep=""."")
+      # TODO: histogram bars have density but other geom_bar objects won't
+      # Need to not fail if density not present
+      # Generally, need to deal with missing values better
+      
+      # If no density values then assume it's a categorical x-axis
+      if (is.null(chartData$density))  
+        annotations[[i]] = .AddXMLcategoricalBar(root, position=i, 
+                                            x=signif(chartData$x[i], 4),
+                                            count=chartData$ymax[i] - chartData$ymin[i], 
+                                            id=barId)
+      
+      else
+        annotations[[i]] = .AddXMLcenterBar(root, position=i, mid=signif(chartData$x[i],4),
+                                        count=chartData$ymax[i] - chartData$ymin[i], 
+                                        density=ifelse(is.null(chartData$density), NA, chartData$density[i]),
+                                        start=signif(chartData$xmin[i], 4), 
+                                        end=signif(chartData$xmax[i], 4), id=barId)
+    }
+  } else if (x$type==""line"") { # Line chart
+    segmentCount = nrow(x$data)-1    # One less than the number of points
+    # For now, assume that all layers are this layer type
+    # TODO:  Fix this
+    lineGrobs = grid.grep(gPath(""GRID.polyline""), grep=TRUE, global=TRUE)
+    lineGrob = lineGrobs[[x$layernum]]
+    XML::addAttributes(annotation$root, speech=""Line graph"",
+                       speech2=paste(""Line graph with"", segmentCount, ""segments""),
+                       # Better to report #lines or #segs?  
+                       # Line can be discontiguous (comprised of polylines 1a, 1b, ...)
+                       type=""Center"")
+    annotations = list()
+    data = x$data 
+    for (i in 1:segmentCount) {
+      lineId = paste(lineGrob$name, ""1"", sep=""."") # ID of the polyline
+      annotations[[i]] = .AddXMLcenterLine(root, position=i, id=lineId,
+                                           data$x[i], data$y[i],
+                                           data$x[i+1], data$y[i+1])
+      # TODO:  Not correctly handling NA or out-of-range data values, nor dates
+      # Should check for dates with inherit(,""Date"") -- but looks like I
+      # need to do that on the main data not the layer data
+    }
+  } else {            # TODO:  warn about layer types we don't recognize
+    return(NULL)
+  }
+  .AddXMLAddComponents(annotation, annotations)
+  .AddXMLAddChildren(annotation, annotations)
+  .AddXMLAddParents(annotation, annotations)
+  return(invisible(annotation))
+}
 
-.AddXMLcenterBar = function(root, position=1, mid=NULL, count=NULL, density=NULL, start=NULL, end=NULL) {
+.AddXMLcenterBar = function(root, position=1, mid=NULL, count=NULL, density=NULL, start=NULL, end=NULL,
+                            id=NULL) {
+    rectId = ifelse(is.null(id), .AddXMLmakeId(""rect"", paste(""1.1"", position, sep=""."")), id)
     annotation = .AddXMLAddAnnotation(root, position=position,
-                                      id=.AddXMLmakeId(""rect"", paste(""1.1"", position, sep=""."")),
+                                      id=rectId,
                                       kind=""active"")
     XML::addAttributes(annotation$root,
                        speech=paste(""Bar"", position, ""at"", mid, ""with value"", count),
@@ -122,6 +195,35 @@
                        type=""Bar"")
     return(invisible(annotation))
 }
+.AddXMLcategoricalBar = function(root, position=1, x=NULL, count=NULL, id=NULL) {
+  rectId = ifelse(is.null(id), .AddXMLmakeId(""rect"", paste(""1.1"", position, sep=""."")), id)
+  annotation = .AddXMLAddAnnotation(root, position=position,
+                                    id=rectId,
+                                    kind=""active"")
+  XML::addAttributes(annotation$root,
+                     speech=paste(""Bar"", position, ""at"", x, ""with value"", count),
+                     speech2=paste(""Bar"", position, ""at x value"", x, "" with y value"", count),
+                     type=""Bar"")
+  return(invisible(annotation))
+}
+# Polyline is problematic as we can't highlight each segment visually, but still want
+# to describle them separately
+# Current fudge for this -- define each segment with a dummy name that doesn't actually
+# exist in the SVG.  Then give it a passive child which is the whole
+# polyline.  This keeps the whole line visible while individual segments are described
+.AddXMLcenterLine = function(root, position=1, startx, starty, endx, endy,
+                            id=NULL) {
+  fakeSegmentId = paste(id,position,sep=""."") # Pretend there are separate segments
+  
+  annotation = .AddXMLAddAnnotation(root, position=position, id=fakeSegmentId, kind=""active"")
+  dummyAnnotation = list(.AddXMLAddAnnotation(root, position=position, id=id, kind=""passive""))
+  speech=paste0(""Line "", position, "" from ("", startx, "","", starty, "") to ("", endx, "","", endy, "")"")
+  XML::addAttributes(annotation$root, speech=speech, speech2=speech)
+  .AddXMLAddComponents(annotation, dummyAnnotation)
+  .AddXMLAddChildren(annotation, dummyAnnotation)
+  .AddXMLAddParents(annotation, dummyAnnotation)
+  return(invisible(annotation))
+}
 
 
 ## Auxiliary methods for annotations

---FILE: R/AddXMLMethod.R---
@@ -70,12 +70,49 @@ AddXML.eulerr = function(x, file) {
 }
 
 AddXML.ggplot = function(x, file) {
+    grid.force()
+    xs = .VIstruct.ggplot(x)
     doc = .AddXMLDocument(""ggplot"")
     root = XML::xmlRoot(doc)
     annotations = .AddXMLAddNode(root, ""annotations"")
-    .AddXMLAddXAxis(annotations, label=x$ExtraArgs$xlab)
-    .AddXMLAddYAxis(annotations, label=x$ExtraArgs$ylab)
-
+    components = list()
+    backgroundGrob = grid.grep(gPath(""panel.background..rect""), grep=TRUE)
+    titleGrob = grid.grep(gPath(""title"", ""text""), grep=TRUE)
+    if (length(titleGrob) > 0) {
+      titleId = paste0(titleGrob$name, "".1"")
+      title = .AddXMLAddTitle(annotations, title=xs$title, id=titleId)
+      components[[length(components) + 1]] = title
+    }
+    xAxisLabelGrob = paste0(grid.grep(gPath(""xlab-b"", ""text""), grep=TRUE)$name, "".1"")
+    xAxisTickLabelGrob = paste0(grid.grep(gPath(""axis-b"", ""axis"", ""axis"", ""text""), grep = TRUE)$name, "".1"")
+    xAxis = .AddXMLAddXAxis(annotations, label=xs$xaxis$xlabel, values=xs$xaxis$xticklabels,
+                            fullLabelId=xAxisLabelGrob, fullTickLabelId=xAxisTickLabelGrob)
+    components[[length(components) + 1]] = xAxis
+    yAxisLabelGrob = paste0(grid.grep(gPath(""ylab-l"", ""text""), grep=TRUE)$name, "".1"")
+    yAxisTickLabelGrob = paste0(grid.grep(gPath(""axis-l"", ""axis"", ""axis"", ""text""), grep = TRUE)$name, "".1"")
+    yAxis = .AddXMLAddYAxis(annotations, label=xs$yaxis$ylabel, values=xs$yaxis$yticklabels,
+                            fullLabelId=yAxisLabelGrob, fullTickLabelId=yAxisTickLabelGrob)
+    components[[length(components)+1]] = yAxis
+    if (xs$npanels == 1) {
+          for (layerNum in 1:xs$nlayers) {
+            layer = .AddXMLAddGGPlotLayer(annotations, xs$panels[[1]]$panellayers[[layerNum]])    
+            components[[length(components) + 1]] = layer
+          }
+    } 
+    # Else, should warn about not handling faceted charts -- or else handle them!
+    chart <- .AddXMLAddChart(annotations, type=""Chart"",
+                             speech=paste(ifelse(is.null(xs$title), ""Chart"",
+                                                 paste(""Chart with title "", xs$title)),
+                                          "" with x-axis "", xs$xaxis$xlabel,
+                                          "" and y-axis "",xs$yaxis$ylabel),
+                             # Currently speech2 is same as speech
+                             speech2=paste(ifelse(is.null(xs$title), ""Chart"",
+                                                 paste(""Chart with title "", xs$title)),
+                                          "" with x-axis "", xs$xaxis$xlabel,
+                                          "" and y-axis "",xs$yaxis$ylabel),  
+                             children=components)
+    .AddXMLAddComponents(chart, components)
+    
     XML::saveXML(doc=doc, file=file)
     return(invisible(NULL))
 }

---FILE: R/BrowseSVG.R---
@@ -5,6 +5,7 @@ BrowseSVG = function(file=""test"", dir=""."", key=TRUE, footer=TRUE, view=interacti
   svgString <- readLines(svgFile)
   htmlFile <- paste0(file, "".html"")
   .AddHeader2HTML(file=htmlFile, dir=dir)
+  .AddStyleFix2HTML(file=htmlFile, dir=dir)
   .AddContainer2HTML(svgString, xmlString, file=htmlFile, dir=dir)
   if (key) {
     .AddKey2HTML(file=htmlFile, dir=dir)
@@ -19,7 +20,16 @@ BrowseSVG = function(file=""test"", dir=""."", key=TRUE, footer=TRUE, view=interacti
   return(invisible(NULL))
 }
 
+# DW - This fix needed for ggplot, as its bars otherwise have only a fill and no border and hence
+#      don't display correctly in MakeAccessibleSVG
+#      Should consider whether to only run this for MakeAccessibleSVG.ggplot
+#      Tried to make the selection as narrow as possible to avoid unwanted side-effects
+.AddStyleFix2HTML = function(svg, file=""test.html"", dir=""."") {
+  cat('          <style>svg g[id^=geom_rect] rect {stroke-opacity: 1;}</style>\n', file=file, append=TRUE)
+}
+
 
+  
 .CleanXml = function(file=""test"", dir=""."") {
   fileName <- paste0(file, "".xml"")
   xmlString <- readLines(fileName)

---FILE: R/MakeAccessibleSVGMethod.R---
@@ -38,3 +38,17 @@ MakeAccessibleSVG.tsplot =
       message(""SVG and XML files created successfully"")
       return(invisible(NULL))
 }
+
+MakeAccessibleSVG.ggplot =
+    function(x, file = ""test"", view=interactive(), ...) {
+      pdf(NULL)  # create non-displaying graphics device for SVGThis
+      svgfile = SVGThis(x, paste0(file, "".svg""),createDevice=FALSE)
+      xmlfile = AddXML(x, paste0(file, "".xml""))  # needs device to do grid.grep()
+      dev.off()  # destroy graphics device, now that we're done with it
+      
+      if (view) {
+        BrowseSVG(file=file, view=view, ...)
+      }
+      message(""SVG and XML files created successfully"")
+      return(invisible(NULL))
+}
\ No newline at end of file

---FILE: R/SVGThis.R---
@@ -29,12 +29,12 @@ MakeTigerReady =
     }
 
 # method is mostly Jonathan's use of Paul/Simon's work
-SVGThis = function(x, file = ""test.svg"") {
+SVGThis = function(x, file = ""test.svg"", ...) {
             UseMethod(""SVGThis"")
           }
 
 SVGThis.default =
-    function(x, file = ""test.svg"") {
+    function(x, file = ""test.svg"", ...) {
       if (is.null(x)) {  # must be running interactively
         if (dev.cur() > 1) {  # there must also be an open graphics/grid device
 
@@ -61,7 +61,7 @@ SVGThis.default =
     }
 
 SVGThis.boxplot =
-    function(x, file = ""test.svg"") {
+    function(x, file = ""test.svg"", ...) {
       # really should check that the boxplot wasn't plotted already before...
       # but simpler to just do the plotting ourselves and close the device later
       x  # ensure we create a boxplot on a new graphics device
@@ -73,7 +73,7 @@ SVGThis.boxplot =
     }
 
 SVGThis.dotplot =
-    function(x, file = ""test.svg"") {
+    function(x, file = ""test.svg"", ...) {
       # really should check that the dotplot wasn't plotted already before...
       # but simpler to just do the plotting ourselves and close the device later
       x  # ensure we create a dotplot on a new graphics device
@@ -85,7 +85,7 @@ SVGThis.dotplot =
     }
 
 SVGThis.eulerr = 
-    function(x, file = ""test.svg"") {
+    function(x, file = ""test.svg"", ...) {
       x=Augment(x)
       X = stats::coef(x)[, 1L]
       Y = stats::coef(x)[, 2L]
@@ -105,19 +105,26 @@ SVGThis.eulerr =
       return(invisible(NULL))
     }
 
+# if createDevice is TRUE (the default) SVGThis will create its own
+# (non-displaying) graphics device and destroy it when complete
+# if FALSE it will use the currently active device
 SVGThis.ggplot =
-    function(x, file = ""test.svg"") {
-      x=Augment(x)
-      x
+    function(x, file = ""test.svg"", createDevice = TRUE, ...) {
+#      x=Augment(x)
+#      grid.force()
+      if (createDevice) 
+        pdf(NULL)
+      print(x)
       gridSVG::grid.export(name = file)
-      dev.off()
+      if (createDevice) 
+        dev.off()
       MakeTigerReady(svgfile = file)
       return(invisible(NULL))
     }
 
 
 SVGThis.histogram =
-    function(x, file = ""test.svg"") {
+    function(x, file = ""test.svg"", ...) {
       # really should check that the histogram wasn't plotted already before...
       # but simpler to just do the plotting ourselves and close the device later
       x  # ensure we create a histogram on a new graphics device
@@ -156,7 +163,7 @@ SVGThis.histogram =
               desc = ""need something much smarter in here"")
 }
 
-SVGThis.scatterplot = function(x, file = ""test.svg"") {
+SVGThis.scatterplot = function(x, file = ""test.svg"", ...) {
 x$x= x$data$x
 x$y = x$data$y
 x$data=NULL
@@ -169,7 +176,7 @@ x$data=NULL
       return(invisible(NULL))
 }
 
-SVGThis.tsplot = function(x, file = ""test.svg"") {
+SVGThis.tsplot = function(x, file = ""test.svg"", ...) {
       suppressWarnings(do.call(plot, x))  # ensure we create a plot on a new graphics device
       gridGraphics::grid.echo()  # plot() uses graphics package
       gridSVG::grid.export(name = file)

---FILE: R/ScatterPlot.R---
@@ -68,7 +68,7 @@ return(invisible(x2))
 
 .GrabExtraArgs = function(x){
     ToRemove = c("""", ""x"", ""y"", ""main"", ""xlab"", ""ylab"", ""sub"", ""line.col"")
-    ExtraArgs = as.list(x[setdiff(names(x), ToRemove)])
+    ExtraArgs = (as.list(x))[setdiff(names(x), ToRemove)]
     return(invisible(ExtraArgs))
 }
 

---FILE: R/UpdateGraph.R---
@@ -19,7 +19,7 @@ main = xlab = ylab = function(graph, label=NULL){
 
 update.scatterplot = update.tsplot = update.fittedlineplot = UpdateGraph = function(object, ...){
       MC <- match.call(expand.dots = TRUE)
-      ParSet = as.list(MC[-c(1,2)])
+      ParSet = (as.list(MC))[-c(1,2)]
       Obj = as.character(match.call()[[""object""]])
       Out = object
 # now sift ExtraArgs from ParSet and update them

---FILE: R/VIInternals.R---
@@ -0,0 +1,276 @@
+### This file is for internal functions used by VI.ggplot
+### These functions access the objects created by ggplot and ggplot_build,
+### and may be sensitive to changes in those structure in later ggplot versions.
+
+## All of these functions take as parameters:
+##   x = the object created by ggplot
+##   xbuild = the object resulting from ggplot_build(x)
+# Some also take a panel or layer index
+
+## Annotations
+.getGGTitle = function(x, xbuild) {
+  if (is.null(x$labels$title)) {
+    text = NULL
+  } else {
+    text =  x$labels$title
+  }
+  return(invisible(text))
+}
+
+.getGGSubtitle = function(x, xbuild) {
+  if (is.null(x$labels$subtitle)) {
+    text = NULL
+  } else {
+    text =  x$labels$subtitle
+  }
+  return(invisible(text))
+}
+
+.getGGCaption = function(x, xbuild) {
+  if (is.null(x$labels$caption)) {
+    text = NULL
+  } else {
+    text =  x$labels$caption
+  }
+  return(invisible(text))
+}
+
+## Axes
+.getGGXLab = function(x, xbuild) {
+  return(x$labels$x)
+}
+
+.getGGYLab = function(x, xbuild) {
+  return(x$labels$y)
+}
+
+.getGGXTicks = function(x, xbuild, layer) {
+  # The location of this item is changing in an upcoming ggplot version
+  if (""panel_ranges"" %in% names(xbuild$layout))
+    return(xbuild$layout$panel_ranges[[layer]]$x.labels)   # ggplot 2.2.1
+  else
+    return(xbuild$layout$panel_params[[layer]]$x.labels)   # dev version as at 5 Sept 2017
+}
+
+.getGGYTicks = function(x, xbuild, layer) {
+  # The location of this item is changing in an upcoming ggplot version
+  if (""panel_ranges"" %in% names(xbuild$layout))
+    return(xbuild$layout$panel_ranges[[layer]]$y.labels)   # ggplot 2.2.1
+  else
+    return(xbuild$layout$panel_params[[layer]]$y.labels)   # dev version as at 5 Sept 2017
+}
+
+# Guides
+.getGGGuideLabels = function(x, xbuild) {
+  labels = x$labels
+  # Note: checking against char string ""NA"" is correct - label is set that way.
+  labels = labels[which(names(labels) %in% 
+                          c(""colour"", ""fill"", ""size"", ""shape"", ""alpha"", ""radius"", ""linetype"") & labels != ""NA"")]
+  return(labels)
+}
+
+.getGGGuides = function(x, xbuild) {
+  return(xbuild$plot$guides)
+}
+
+# Coordinates
+.getGGCoord = function(x, xbuild) {
+  return(class(x$coordinates)[1])
+}
+
+## Scales
+.getGGScaleFree = function(x, xbuild) {
+  free = x$facet$params$free
+  if (is.null(free))
+    return(FALSE)
+  else
+    return (free$x | free$y)
+}
+
+.getGGScale = function(x, xbuild, aes) {
+  scalelist = xbuild$plot$scales$scales
+  scale = which(sapply(scalelist, function(x) aes %in% x$aesthetics))
+  if (any(scale))
+    return(scalelist[[scale]])
+  else
+    return(NULL)
+}
+
+.getGGTransInverse = function(x, xbuild, var) {
+  scalelist = x$scales$scales
+  scale = which(sapply(scalelist, function(x) var %in% x$aesthetics))
+  if (is.null(scale) || is.null(scale$trans))
+      return(NULL)
+  else
+    return(scale$trans$inverse)
+}
+
+# Small helper function for .getGGPanelScale
+.findScale = function(x, var, panel) {
+  panelIndex = min(panel, length(x))
+  var %in% x[[panelIndex]]$aesthetics
+}
+
+.getGGPanelScale = function(x, xbuild, var, panel) {
+  # Need to find the scale that matches the var we're translating
+  # Depending on scalefree and layout, we might have separate scales
+  # for each panel or just one
+  scales = xbuild$layout$panel_scales
+  findscale = which(sapply(scales, .findScale, var, panel))
+  if (length(findscale) == 1) {
+    panelIndex = min(panel, length(scales[[findscale]]))
+    return(xbuild$layout$panel_scales[[findscale]][[panelIndex]])
+  } else {
+    return(NULL) # Something went wrong -- no matching scale, or more than one
+  }
+}
+
+## Facets
+# Getting facet row and col names from a different place than the 
+# rest of the panel info. Does it matter?
+.getGGFacetRows = function(x, xbuild) {
+  if (length(x$facet$params$rows) > 0)
+    return(names(x$facet$params$rows))
+  else
+    return(NULL)
+}
+
+.getGGFacetCols = function(x, xbuild) {
+  if (length(x$facet$params$cols) > 0)
+    return(names(x$facet$params$cols))
+  else if (length(x$facet$params$facets) > 0) # If nothing on left side of tilde in facet formula
+    return(names(x$facet$params$facets))      # then it's stored like this (??)
+  else
+    return(NULL)
+}
+
+# This returns a data frame with fields PANEL, ROW, COL, plus one column
+# for each faceted variable, plus SCALE_X and SCALE_Y
+# e.g. for facets=cut~color the data frame contains:
+#    PANEL, ROW, COL, cut, color, SCALE_X, SCALE_Y
+# The name of this item is panel_layout in ggplot 2.2.1 but looks like
+# it's going to be just layout in the next ggplot version
+.getGGFacetLayout = function(x, xbuild) {
+  if (""panel_layout"" %in% names(xbuild$layout))
+    return(xbuild$layout$panel_layout)
+  else
+    return(xbuild$layout$layout)
+}
+
+## Layers
+.getGGLayerCount = function(x, xbuild) {
+  count=length(xbuild$plot$layers)
+}
+
+.getGGLayerType = function(x, xbuild, layer) {
+  plotClass = class(xbuild$plot$layers[[layer]]$geom)[1]
+}
+
+# Report on non-default aesthetics set on this layer 
+.getGGLayerAes = function(x, xbuild, layer) {
+  layeraes = list()
+  params = xbuild$plot$layers[[layer]]$aes_params
+  params = params[which(!(names(params) %in% c(""x"", ""y"")))]  # Exclude x, y
+  values = .convertAes(as.data.frame(params))
+  for (i in seq_along(params))
+    layeraes[[i]] = list(aes=names(params)[i], mapping=values[,i])
+  return(layeraes)
+}
+
+# Find those aesthetics that are varying within this layer 
+# (e.g not all points in a scatterplot have the same colour)
+.findVaryingAesthetics = function(x, xbuild, layer) {
+  aeslist = c(""colour"", ""fill"", ""linetype"", ""alpha"", ""size"", ""weight"", ""shape"")
+  data = xbuild$data[[layer]]
+  names = names(data)
+  data = data[names[names %in% aeslist]]
+  data = data[sapply(data, function(col) { length(unique(col)) > 1 })]
+  return(names(data))
+}
+
+# Layer position
+.getGGLayerPosition = function(x, xbuild, layer) {
+  pos = switch (class(x$layers[[layer]]$position)[1],
+    PositionDodge = ""dodge"",
+    PositionFill = ""fill"",
+    PositionIdentity = ""identity"",
+    PositionJitter = ""jitter"",
+    PositionJitterdodge = ""jitterdodge"",
+    PositionNudge = ""nudge"",
+    PositionStack = ""stack"",
+    class(x$layers[[layer]]$position)[1]
+    )
+  return(pos)
+}
+
+# Plot data
+# Layer-specific mapping overrides the higher level one
+# Mapping is an expression to be evaluated in the x$data environment
+# Will return null if there is no mapping (e.g. for y with stat_bin)
+.getGGMapping = function(x, xbuild, layer, aes) {
+  m = xbuild$plot$layers[[layer]]$mapping
+  if (!is.null(m) & !is.null(m[[aes]]))
+    return(m[[aes]])
+  m=xbuild$plot$layers[[layer]]$aes_params[[aes]]
+  if (!is.null(m))
+    return(m)
+  if (xbuild$plot$layers[[layer]]$inherit.aes)
+    return(xbuild$plot$mapping[[aes]])
+  else
+    return(NULL)
+}
+
+.getGGPlotData = function(x, xbuild, layer, panel) {
+  # This returns a data frame -- useable by MakeAccessible, but will need to change
+  # if it's going to be used by VI via the whisker template
+  fulldata = xbuild$data[[layer]]
+  return(fulldata[fulldata$PANEL == panel,])
+}
+
+# Get the original data values for variable var in the given layer
+# NOT CURRENTLY IN USE
+# Dangerous since the original data may have changed or no longer be present in the env
+# Also note that the returned data won't necessarily align to the plot data -- e.g. if
+# facets are present or a stat other than identity is in play
+.getGGRawValues = function(x, xbuild, layer, var) {
+  map = .getGGMapping(x, xbuild, layer, var)
+  if (class(x$layers[[layer]]$data) == ""waiver"")
+    return(eval(map,x$data))
+  else
+    return(eval(map,x$layers[[layer]]$data))
+}
+
+# Smooth layer details
+.getGGSmoothMethod = function(x, xbuild, layer) {
+  return(xbuild$plot$layers[[layer]]$stat_params$method)
+}
+
+.getGGSmoothSEflag = function(x, xbuild, layer) {
+  return(xbuild$plot$layers[[layer]]$stat_params$se)
+}
+
+.isGuideHidden = function(x, xbuild, aes) {
+#  Need to look through all layers to figure out whether this aesthetic is involved, and
+#  if so, has show.legend been specified?
+  someLayerShows = FALSE
+  for (layer in xbuild$plot$layers) {
+    mapped = aes %in% names(layer$mapping) ||
+                (layer$inherit.aes && aes %in% names(xbuild$plot$mapping))
+    if (mapped && (is.na(layer$show.legend) || layer$show.legend)) {
+       someLayerShows = TRUE
+     }
+  }
+  if (!someLayerShows)
+    return(TRUE)
+  scale = .getGGScale(x, xbuild, aes)
+  if (!is.null(scale) && !is.null(scale$guide) && scale$guide %in% c(""none"",FALSE))
+    return(TRUE)
+  guides = xbuild$plot$guides
+  if (!is.null(guides) && !is.null(guides[[aes]]) && guides[[aes]] %in% c(""none"",FALSE))
+    return(TRUE)
+  legend.position = xbuild$plot$theme$legend.position
+  if (!is.null(legend.position) && legend.position == ""none"")
+    return(TRUE)
+  return(FALSE)
+}
+  

---FILE: R/VIMethod3_TH.R---
@@ -1,74 +1,566 @@
-VI.ggplot =
-    function(x, Describe=FALSE, ...) {
-      TitleText = ifelse(is.null(x$labels$title), ""This untitled chart;\n"",
-              paste0('This chart titled ', .getTextGGTitle(x), ';\n'))
-      SubtitleText = ifelse(is.null(x$labels$subtitle), ""has no subtitle;\n"",
-              paste0('has the subtitle: ', .getTextGGSubtitle(x), ';\n'))
-      CaptionText = ifelse(is.null(x$labels$caption), ""and no caption.\n"",
-              paste0('and the caption: ', .getTextGGCaption(x), '.\n'))
-
-      txt =
-          paste0(TitleText, SubtitleText, CaptionText,
-              'with x-axis ', BrailleR::InQuotes(x$labels$x), ' labeled from ',
-              ggplot_build(x)$panel$ranges[[1]]$x.labels[1], ' to ',
-              tail(ggplot_build(x)$panel$ranges[[1]]$x.labels, n = 1),
-              ' and y-axis ', BrailleR::InQuotes(x$labels$y), ' labeled from ',
-              ggplot_build(x)$panel$ranges[[1]]$y.labels[1], ' to ',
-              tail(ggplot_build(x)$panel$ranges[[1]]$y.labels, n = 1), ';\n')
-
-      if ('colour' %in% names(x$labels)) {
-        txt = paste0(txt, '\nColour is used to represent ',
-                     BrailleR::InQuotes(x$labels$colour))
-
-        if ('factor' %in% class(x$data[[x$labels$colour]])) {
-          txt =
-              paste0(txt, ', a factor with levels: ',
-                     paste(levels(x$data[[x$labels$colour]]), collapse = ', '),
-                     '.\n')
+## Textify performs whisker rendering
+## First parameter is a list of objects.  
+## Second parameter is the name of a template file.
+## Each object is rendered using the template of the same name 
+## found within the template file.  Partial templates can also
+## be present in the template file and will be used if needed.
+.VItextify = function(x, template=system.file(""whisker/VIdefault.txt"", package=""BrailleR"")) {
+  temp = read.csv(template,header=FALSE, as.is=TRUE)
+  templates = as.list(gsub(""\n"", """", temp[,2]))
+  names(templates) = temp[,1]
+  result = list()
+  for (i in 1:length(x)) {
+    if (is.null(x[[i]])) {
+      result[[i]] = character(0)
+    } else {
+      render = whisker::whisker.render(templates[names(x[i])], x[[i]], partials=templates)
+    result[[i]] = as.vector(strsplit(render, ""<br>"", fixed=TRUE)[[1]])
+    }
+  }
+  names(result) = names(x)
+  return(result)
+}
+
+# This function adds flags to the VIstruct object that are only 
+# required because of the limitations of mustache templating, as well
+# as implementing the threshold for printing by setting ""largecount"" flags.
+# Mustache can't check a field's value, only whether it's present or not.
+# So flags are either set to true or not included at all
+.VIpreprocess = function(x, threshold=10) {
+  if (is.null(x))
+    return(NULL)
+  if (x$npanels == 1) 
+    x$singlepanel = TRUE
+  if (x$nlayers == 1) 
+    x$singlelayer = TRUE
+  if (length(x$panelrows) == 0) 
+    x$singlerow = TRUE   
+  if (length(x$panelcols) == 0) 
+    x$singlecol = TRUE
+  if (length(x$panelrows) > 0 && length(x$panelcols) > 0) 
+    x$panelgrid = TRUE
+  # If samescale then axis labels are at top level
+  if (!is.null(x$xaxis$xticklabels))
+    x$xaxis$xtickitems = .listifyVars(list(label=x$xaxis$xticklabels))
+  if (!is.null(x$yaxis$yticklabels))
+    x$yaxis$ytickitems = .listifyVars(list(label=x$yaxis$yticklabels))
+  
+  for (legendi in 1:length(x$legends)) {
+    if (!is.null(x$legends[[legendi]]$scalelevels))
+      x$legends[[legendi]]$scalelevelitems = 
+        .listifyVars(list(level = x$legends[[legendi]]$scalelevels,
+                          map = x$legends[[legendi]]$scalemaps))
+  }
+  for (paneli in 1:x$npanels) {
+    # Othewise they're within the panels
+    if (!is.null(x$panels[[paneli]]$xticklabels))
+      x$panels[[paneli]]$xtickitems = .listifyVars(list(label=x$panels[[paneli]]$xticklabels))
+    if (!is.null(x$panels[[paneli]]$yticklabels))
+      x$panels[[paneli]]$ytickitems = .listifyVars(list(label=x$panels[[paneli]]$yticklabels))
+    for (layeri in 1:x$nlayers) {
+      layer = x$panels[[paneli]]$panellayers[[layeri]]
+      typeflag = paste0(""type"",layer$type)
+      layer[[typeflag]] = TRUE
+      n = layer$n
+      if (!is.null(n)) {
+        if (n > 1) 
+          layer$s = TRUE
+        if (n > threshold) {
+          layer$largecount = TRUE
         } else {
-          txt = paste0(txt, ';\n')
+          if (layer$type == ""line"") {  # Lines are special, items are within groups
+            for (i in 1:length(layer$lines)) {
+              layer$lines[[i]]$linenum = i
+              npoints = nrow(layer$lines[[i]]$scaledata)
+              layer$lines[[i]]$npoints = npoints
+              if (npoints > threshold)
+                layer$lines[[i]]$largecount = TRUE
+              else 
+                layer$lines[[i]]$items = .listifyVars(layer$lines[[i]]$scaledata)
+            }
+          }
+          else {
+            layer$items = .listifyVars(layer$scaledata)
+          }
         }
       }
-      cat(txt)
-      return(invisible(NULL))
+      x$panels[[paneli]]$panellayers[[layeri]] = layer
     }
+  }
+  return(x)
+}
+
+# This function will convert vectors into lists for mustache
+# Takes a named list of vectors, result is a list of lists
+# Also adds item numbers and separator
+# e.g. converts list(x=c(1,2),y=c(3,4)) into 
+#     list(list(itemnum=1,x=1,y=3,sep="" and ""),list(itemnum=2,x=2,y=4,sep=""""))
+# This code isn't efficient, but hopefully we aren't printing a huge number of points
+.listifyVars = function(varlist) {
+  itemlist = list()
+  for (i in seq_along(varlist[[1]])) {  # Assumes all varlists are the same length
+    item = list()
+    for (j in seq_along(varlist)) {
+      item$itemnum = i
+      var = varlist[[j]]
+      name = names(varlist)[j]
+      item[[name]] = .cleanPrint(var[i])
+    }
+    len = length(varlist[[1]])
+    # Separator, to allow whisker template to create and-separated lists
+    if (i == len)
+      item[[""sep""]] = """"
+    else if (i == len - 1)
+      item[[""sep""]] = "" and ""
+    else
+      item[[""sep""]] = "", ""
+    itemlist[[i]] = item
+  }
+  return(itemlist)
+}
+
+# For now, limit all values printed to 2 decimal places.  Should do something smarter -- what does
+# ggplot itself do?
+.cleanPrint = function(x) {
+  if (is.numeric(x))
+    return(round(x,2))
+  else
+    return(x)
+}
 
-.getTextGGTitle = function(x){
-if(is.null(x$labels$title)){
-text = ""no label""
-} else {
-text =  BrailleR::InQuotes(x$labels$title)
+### Print function for the object created by VI.ggplot
+### Prints the text component of the object
+print.VIgraph = function(x, ...) {
+  cat(x$text, sep=""\n"")
+  invisible(x)
 }
-return(invisible(text))
+
+# Small helper function - builds list excluding items that are null or length 0
+.VIlist = function(...) {
+  l = list(...)
+  l[(lapply(l,length) > 0)] 
 }
 
-.getTextGGSubtitle = function(x){
-if(is.null(x$labels$subtitle)){
-text = ""no label""
-} else {
-text =  BrailleR::InQuotes(x$labels$subtitle)
+VIsort = function(x, sortby=""x"", decreasing = FALSE) {
+  if (!sortby %in% c(""x"", ""y"")) {
+    message('Valid sortby parameters are ""x"" or ""y"".')
+    return(x)    # Return unchanged
+  }
+  VIgg = x$VIgg
+  for (i in 1:VIgg$npanels) {
+    for (j in 1:VIgg$nlayers) {
+      if (VIgg$panels[[i]]$panellayers[[j]]$type != ""point"") {
+        message(""Sorting is only supported on plots of type 'point'"")
+        return(x) # Return unchanged
+      }
+      df = VIgg$panel[[i]]$panellayers[[j]]$scaledata
+      VIgg$panels[[i]]$panellayers[[j]] = within(VIgg$panels[[i]]$panellayers[[j]],
+      {
+        sortorder = order(if (sortby==""x"") scaledata$x else scaledata$y, decreasing=decreasing)
+        scaledata = scaledata[sortorder,]
+      })
+    }
+  }
+  text = .VItextify(list(VIgg=.VIpreprocess(VIgg, x$threshold)), x$template)[[1]]
+  VIgraph = list(VIgg=VIgg, text=text, threshold=x$threshold, template=x$template)
+  class(VIgraph) = ""VIgraph""
+  return(VIgraph)
 }
-return(invisible(text))
+
+
+# Returns the VIgraph object with the text trimmed down to only those rows
+# containing the specified pattern.  Passes extra parameters on to grepl.
+# Note that only the text portion of the VIgraph is modified; the complete
+# VIgg structure is still included
+VIgrep = function(pattern, x,...) {
+  if (class(x) != ""VIgraph"") {
+    message(paste(""VIgrep doesn't know how to process this object."",
+                  ""Only the output from running VI on a ggplot object can be processed by VIgrep.""))
+    return(NULL)
+   }
+  x$text = x$text[grepl(pattern, x$text, ...)]
+  x
+}
+
+# threshold specifies how many points, lines, etc will be explicitly listed.
+# Greater numbers will be summarised (e.g. ""is a set of 32 horizontal lines"" vs
+# ""is a set of 3 horizontal lines at 5, 7.5, 10"")
+VI.ggplot = function(x, Describe=FALSE, threshold=10, 
+                     template=system.file(""whisker/VIdefault.txt"", package=""BrailleR""), ...) {
+  VIstruct = .VIstruct.ggplot(x)
+  text = .VItextify(list(VIgg=.VIpreprocess(VIstruct, threshold)), template)[[1]]
+  VIgraph = list(VIgg=VIstruct, text=text, threshold=threshold, template=template)
+  class(VIgraph) = ""VIgraph""
+  return(VIgraph)
+}
+
+# Builds the VIgg structure describing the graph
+.VIstruct.ggplot = function(x) {
+  xbuild = suppressMessages(ggplot_build(x))
+  # If this is a plot we really can't deal with, say so now
+  if (!(.getGGCoord(x, xbuild) %in% c(""CoordCartesian"", ""CoordFixed""))) {
+    message(""VI cannot process ggplot objects with flipped or non-Cartesian coordinates"")
+    return(NULL)
+  }
+  title = .getGGTitle(x, xbuild)
+  subtitle = .getGGSubtitle(x, xbuild)
+  caption = .getGGCaption(x, xbuild)
+  annotations = .VIlist(title=title, subtitle=subtitle, caption=caption)
+  xlabel = .getGGXLab(x, xbuild)
+  ylabel = .getGGYLab(x, xbuild)
+  if (!.getGGScaleFree(x, xbuild)) {    # Can talk about axis ticks at top level unless scale_free
+    samescale = TRUE
+    xticklabels = .getGGXTicks(x, xbuild, 1)
+    yticklabels = .getGGYTicks(x, xbuild, 1)
+  } else {
+    samescale = NULL
+    xticklabels = NULL
+    yticklabels = NULL
+  }
+  xaxis = .VIlist(xlabel=xlabel, xticklabels=xticklabels, samescale=samescale)
+  yaxis = .VIlist(ylabel=ylabel, yticklabels=yticklabels, samescale=samescale)
+  legends = .buildLegends(x, xbuild)
+  panels = .buildPanels(x, xbuild)
+  panelrows = as.list(.getGGFacetRows(x, xbuild))
+  panelcols = as.list(.getGGFacetCols(x, xbuild))
+  layerCount = .getGGLayerCount(x, xbuild);
+  VIstruct = .VIlist(annotations=annotations, xaxis=xaxis, yaxis=yaxis, legends=legends, panels=panels,
+              npanels=length(panels), nlayers=layerCount, panelrows=panelrows, panelcols=panelcols, type=""ggplot"")
+  class(VIstruct) = ""VIstruct""
+  return(VIstruct)
 }
 
-.getTextGGCaption = function(x){
-if(is.null(x$labels$caption)){
-text = ""no label""
-} else {
-text =  BrailleR::InQuotes(x$labels$caption)
+.buildLegends = function(x, xbuild) {
+  legends = list()
+  labels = .getGGGuideLabels(x, xbuild)
+  names = names(labels)
+  guides = .getGGGuides(x, xbuild)
+  for (i in seq_along(labels)) {
+    name = names[i]
+    mapping = labels[[i]]
+    scale = .getGGScale(x, xbuild, name)
+    scalediscrete = if (""ScaleDiscrete"" %in% class(scale)) TRUE
+    hidden = if (.isGuideHidden(x, xbuild, name)) TRUE
+    maplevels = data.frame(col1=scale$map(scale$range$range), stringsAsFactors=FALSE)
+    colnames(maplevels) = name
+    maplevels = .convertAes(maplevels)
+    maplevels = maplevels[[name]]
+    if (!is.null(scalediscrete)) {
+      scalenlevels = length(scale$range$range)
+      scalelevels = scale$range$range
+      scalemaps = maplevels
+      legend = .VIlist(aes=name, mapping=unname(mapping), scalediscrete=scalediscrete, 
+                       scalenlevels=scalenlevels, scalelevels=scalelevels, 
+                       scalemaps=scalemaps, hidden=hidden)
+    } else {
+      scalefrom = scale$range$range[1]
+      scaleto = scale$range$range[2]
+      scalemapfrom = maplevels[1]
+      scalemapto = maplevels[2]
+      legend = .VIlist(aes=name, mapping=unname(mapping), scalediscrete=scalediscrete, 
+                       scalefrom=scalefrom, scaleto=scaleto, 
+                       scalemapfrom=scalemapfrom, scalemapto=scalemapto, hidden=hidden)
+    }
+    legends[[i]] = legend
+  }
+  return(legends)
 }
-return(invisible(text))
+
+.buildPanels = function(x, xbuild) {
+  f = .getGGFacetLayout(x, xbuild)
+  panels = list()
+  names = colnames(f)
+  panelvars = names[which(!names %in% c(""PANEL"", ""ROW"", ""COL"", ""SCALE_X"", ""SCALE_Y""))]
+  for (i in seq_along(f$PANEL)) {
+    panel = list()
+    panel[[""panelnum""]] = as.character(f$PANEL[i])
+    panel[[""row""]] = f$ROW[i]
+    panel[[""col""]] = f$COL[i]
+    scalefree = .getGGScaleFree(x, xbuild)
+    panel[[""samescale""]] = if (!scalefree) TRUE      # Might want to move this into pre-processing step
+    if (scalefree) { 
+      panel[[""xticklabels""]] = .getGGXTicks(x, xbuild, i)
+      panel[[""yticklabels""]] = .getGGYTicks(x, xbuild, i)
+      panel[[""xlabel""]] = .getGGXLab(x, xbuild) # Won't actually change over the panels
+      panel[[""ylabel""]] = .getGGYLab(x, xbuild) # But we still want to mention them
+      
+    }
+    vars = list()
+      for (j in seq_along(panelvars)) {
+        vars[[j]] = list(varname=as.character(panelvars[j]), value=as.character(f[[i, panelvars[j]]]))
+      }
+    panel[[""vars""]] = vars
+    panel[[""panellayers""]] = .buildLayers(x, xbuild, i)
+    panels[[i]] = panel
+  }
+  return(panels)  
 }
 
+.buildLayers = function(x, xbuild, panel) {
+  layerCount = .getGGLayerCount(x, xbuild)
+  layers = list()
+  for (layeri in 1:layerCount) {
+    layeraes = .getGGLayerAes(x, xbuild, layeri)
+    layer = .VIlist(layernum=layeri, layeraes=layeraes)
+    layer$data =.getGGPlotData(x, xbuild, layeri, panel)
+    if (length(layer$data$group) > 0 && max(layer$data$group) > 0)  # ungrouped data have group = -1 
+      ngroups = length(unique(layer$data$group))
+    else
+      ngroups = 1
+    layerClass = .getGGLayerType(x, xbuild, layeri)
+    
+    # HLINE
+    if (layerClass == ""GeomHline"") {
+      layer$type = ""hline""
+      # Discard lines that go outside the bounds of the plot,
+      # as they won't be displayed
+      cleandata = layer$data[!is.na(layer$data$yintercept),]
+      layer$n = nrow(cleandata)
+      map = .mapDataValues(x, xbuild, list(""yintercept""), panel, list(yintercept=cleandata$yintercept))
+      if (!is.null(map$badTransform)) {
+        layer$badtransform = TRUE
+        layer$transform = map$badTransform
+      } 
+      layer$scaledata = map$value
+      # Also report on any aesthetic variables that vary across the layer
+      layer = .addAesVars(x, xbuild, cleandata, layeri, layer, panel)
+      
+    # POINT
+    } else if (layerClass == ""GeomPoint"") {
+      layer$type = ""point""
+      # Mark as hidden points that go outside the bounds of the plot,
+      # as they won't be displayed
+      cleandata = layer$data[!is.na(layer$data$x) & !is.na(layer$data$y),]
+      layer$n = nrow(cleandata)
+      map = .mapDataValues(x, xbuild, list(""x"", ""y""), panel, 
+                           list(x=cleandata$x, y=cleandata$y))
+      if (!is.null(map$badTransform)) {
+        layer$badtransform = TRUE
+        layer$transform = map$badTransform
+      } 
+      layer$scaledata = map$value
+      # Also report on any aesthetic variables that vary across the layer
+      layer = .addAesVars(x, xbuild, cleandata, layeri, layer, panel)
+      
 
-.getTextGGXLab = function(x){
-text = BrailleR::InQuotes(x$labels$x)
+      # BAR
+    } else if (layerClass == ""GeomBar"") {
+      layer$type = ""bar""
+      # Discard bars that go outside the bounds of the plot,
+      # as they won't be displayed
+      cleandata = layer$data[!is.na(layer$data$xmin) & !is.na(layer$data$xmax),]
+      # Recount rows
+      layer$n = nrow(cleandata)
+      map = .mapDataValues(x, xbuild, list(""x"", ""ymin"", ""ymax""), panel, 
+                           list(x=cleandata$x, ymin=cleandata$ymin, ymax=cleandata$ymax))
+      if (!is.null(map$badTransform)) {
+        layer$badtransform = TRUE
+        layer$transform = map$badTransform
+      } 
+      layer$scaledata = map$value
+      # If bar width varies then we should report xmin and xmax instead
+      width = cleandata$xmax - cleandata$xmin
+      if (max(width) - min(width) > .0001)   # allow for small rounding error
+        layer$scaledata = cbind(layer$scaledata, xmin=cleandata$xmin, xmax=cleandata$xmax)
+      # Also report on any aesthetic variables that vary across the layer
+      layer = .addAesVars(x, xbuild, cleandata, layeri, layer, panel)
+      
+    # LINE
+    } else if (layerClass == ""GeomLine"") {
+      layer$type = ""line""
+      # Lines are funny - each item in the data is a point
+      # The number of actual lines depends on the group parameter
+      layer$n = ngroups
+      # Y values of NA or past ylims create broken lines
+      if (any(is.na(layer$data$y)))  
+        layer$broken = TRUE
+      # X values of NA or past xlims should just not be reported on
+      # as they won't be displayed but the line will still be continuous
+      cleandata = layer$data[!is.na(layer$data$x),]
+      layer = .addLineAesLabels(x, xbuild, layeri, layer, panel)
+      # Each group is a line which has its own information including its own scaledata
+      layer$lines = list()
+      for (groupi in unique(cleandata$group)) {
+        line = list()
+        groupdata = cleandata[cleandata$group == groupi,]
+        groupx = groupdata$x
+        groupy = groupdata$y
+        map = .mapDataValues(x, xbuild, list(""x"",""y""), panel, list(x=groupx, y=groupy))
+        if (!is.null(map$badTransform)) {
+          layer$badtransform = TRUE
+          layer$transform = map$badTransform
+        } 
+        # Lines have a separate scaledata for each group
+        line$scaledata = map$value
+        line = .addLineAesVars(x, xbuild, line, layeri, groupdata, panel)
+        layer$lines[[length(layer$lines) + 1]] = line
+      }
+      
+    #BOXPLOT
+    } else if (layerClass == ""GeomBoxplot"") {
+      layer$type = ""box""
+      cleandata = layer$data   # No need for cleaning since this data is already aggregated
+      layer$n = nrow(layer$data)
+      nOutliers = sapply(cleandata$outliers,length)
+      map = .mapDataValues(x, xbuild,list(""x"", ""ymin"", ""lower"", ""middle"", ""upper"", ""ymax""), panel,
+                          list(x=cleandata$x, ymin=cleandata$ymin, lower=cleandata$lower, 
+                               middle=cleandata$middle, upper=cleandata$upper, 
+                               ymax=cleandata$ymax))
+      if (!is.null(map$badTransform)) {
+        layer$badtransform = TRUE
+        layer$transform = map$badTransform
+      } 
+      layer$scaledata = map$value
+      layer$scaledata[[""noutliers""]] = nOutliers
+      # Might want to report high and low outliers separately?
+      # Would like to include outlier detail as well.
+      # scaledata is currently a list of vectors.  If we wanted to include outliers
+      # within each boxes object for reporting, then boxes would need to become
+      # a list of lists.
+      
+      # Also report on any aesthetic variables that vary across the layer
+      layer = .addAesVars(x, xbuild, cleandata, layeri, layer, panel)
+      
+    # SMOOTH
+    } else if (layerClass == ""GeomSmooth"") {
+      layer$type = ""smooth""
+      layer$method = .getGGSmoothMethod(x, xbuild, layeri)
+      layer$ci = if (.getGGSmoothSEflag(x, xbuild, layeri)) TRUE
+      
+    #U UNKNOWN
+    } else {
+      layer$type = ""unknown""
+    }
+    layers[[layeri]] = layer  
+  }
+  return(layers)
+}
+
+.mapAesDataValues = function(x, xbuild, layer, varlist, valuelist) {
+  transformed = list()
+  for (var in varlist) {
+    value = valuelist[[var]]
+    scale = .getGGScale(x, xbuild, var)
+    
+    if (is.null(scale))   # No scale found
+      next
+    else if ((""ScaleDiscrete"" %in% class(scale))) { # Try to map back to levels
+      match = match(value, scale$palette.cache)
+      transformed[[var]] = scale$range$range[match]
+    } else {  # Continuous scale - We can't currently map these
+      next
+    }
+  }
+  return(transformed)
 }
 
+# Converts positional data values back to their original scales -- converting factor
+# variables back to their levels, and undoisng transforms
+.mapDataValues = function(x, xbuild, varlist, panel, valuelist) {
+  badTransform = NULL
+  transformed = list()
+  for (var in varlist) {
+    value = valuelist[[var]]
+    scale = .getGGPanelScale(x, xbuild, var, panel)
 
+    if (is.null(scale))   # No scale - just return the stored value
+      r = value
+    else if ((""ScaleDiscrete"" %in% class(scale))) { # Try to map back to levels
+      map = scale$range$range
+      if (is.null(map))
+        r = value
+      else {
+        mapping = as.character(map[value])
+        if (length(mapping) != length(value))  # Can happen with jittered data
+          r = value     # Something's gone wrong - bail
+        else
+          r = mapping
+      }
+    } else {  # Continuous scale - try to undo any transform
+      if (is.null(scale$trans)) {   # No transform
+        r = value
+      } else if (is.null(scale$trans$inverse)) {
+        badTransform = scale$trans$name
+        r = value
+      } else {
+        r = scale$trans$inverse(value)
+      }
+    }
+    transformed[[var]] = r
+  }
+  return(list(value=as.data.frame(transformed), badTransform=badTransform))
+}
 
-.getTextGGYLab = function(x){
-text = BrailleR::InQuotes(x$labels$y)
+# Convert aesthetic values to something more friendly for the user
+# Takes a dataframe and converts all of its columns if possible
+# *** ONLY HANDLING LINETYPES AND SHAPES SO FAR - and not defaults 42, 22, ...
+# SHOULD DO COLOURS BY FINDING CLOSEST
+.convertAes = function(values) {
+  linetypes = c(""0""=""blank"", ""1""=""solid"", ""2""=""dashed"",
+                ""3""=""dotted"", ""4""=""dotdash"", ""5""=""longdash"", ""6""=""twodash"")
+  shapes = c(""open square"", ""open circle"", ""open triangle"", ""plus"", ""X"", ""open diamond"", ""downward triangle"",
+             ""boxed X"", ""star"", ""crossed diamond"", ""circled plus"", ""six-pointed star"", ""boxed plus"",
+             ""crossed circle"", ""boxed triangle"", ""solid square"", ""solid circle"", ""solid triangle"",
+             ""solid diamond"", ""big solid circle"", ""small solid circle"", ""fillable circle"", 
+             ""fillable square"", ""fillable diamond"", ""fillable triangle"", ""fillable downward triangle"") 
+  c = values
+  for (col in seq_along(values)) {
+    aes = names(values)[col]
+    if (aes == ""linetype"") {
+      c[,col] = ifelse(values[[col]] %in% names(linetypes),
+                       linetypes[as.character(values[[col]])],
+                       c[,col])  # If not found just return what we got
+    } else if (aes == ""shape"") {
+      c[,col] = ifelse(values[,col] %in% 1:25, shapes[values[,col]+1], c[,col])
+    }
+  }
+  return(c)  
 }
 
+.addLineAesVars = function(x, xbuild, line, layeri, groupdata, panel) {
+  aesvars = .findVaryingAesthetics(x, xbuild, layeri)
+  linedata = groupdata[,aesvars,drop=FALSE]
+  nvals = sapply(linedata,function(x) length(unique(x)))
+  nonconstantAes = aesvars[nvals > 1]
+  for (aes in seq_along(nonconstantAes))
+    line[[paste0(nonconstantAes[aes],""varying"")]] = TRUE
+  aesvars = aesvars[nvals == 1]
+  aesvals = .convertAes(groupdata[1,aesvars,drop=FALSE])
+  aesmap = .mapAesDataValues(x, xbuild, layeri, aesvars, aesvals[1,,drop=FALSE])
+  line[aesvars] = aesvals
+  if (length(aesmap) > 0) {
+    names(aesmap) = paste0(names(aesmap), ""map"")
+    line[names(aesmap)] = aesmap
+  }
+  return(line)
+}
+
+.addLineAesLabels = function(x, xbuild, layeri, layer, panel) {
+  aesvars = .findVaryingAesthetics(x, xbuild, layeri)
+  aeslabel = .getGGGuideLabels(x, xbuild)[aesvars]
+  if (length(aeslabel)>0) {
+    names(aeslabel) = paste0(names(aeslabel),""label"")
+    layer = append(layer, aeslabel)
+  }
+  return(layer)
+}
 
+.addAesVars = function(x, xbuild, data, layeri, layer, panel) {
+  # panel is not currently used in this function
+  aesvars = .findVaryingAesthetics(x, xbuild, layeri)
+  aesvals = .convertAes(data[aesvars])
+  aeslabel = .getGGGuideLabels(x, xbuild)[aesvars]
+  if (length(aeslabel)>0) {
+    names(aeslabel) = paste0(names(aeslabel),""label"")
+    layer = append(layer, aeslabel)
+  }
+  aesmap = .mapAesDataValues(x, xbuild, layeri, aesvars, data[aesvars])
+  layer$scaledata = append(layer$scaledata, aesvals)
+  if (length(aesmap) == 0) {
+    layer$scaledata = cbind(layer$scaledata, aesvals)
+  } else {
+    names(aesmap) = paste0(names(aesmap), ""map"")
+    layer$scaledata = cbind(layer$scaledata, aesvals, aesmap)
+  }
+  return(layer)
+}

---FILE: inst/whisker/README.md---
@@ -0,0 +1,109 @@
+
+This file documents the full object structure which is available to the whisker template.
+Trailing asterisk indicates items introduced in the mustache preprocessing step.
+
+Lists have a ""sep"" field to assist with natural language description of the list. 
+Sep is blank for the final list item, ""and"" for the penultimate one, and "","" otherwise.
+
+```    
+annotations  
+* title  
+* subtitle  
+* caption 
+
+xaxis 
+*	samescale         # do all facets have the same scale (currently only present if same on both axes)  
+*	xlabel      
+*	xticklabels       # if samescale present.  This is a vector
+*	xtickitems (list) * 
+	+ itemnum *
+	+ label           # the tick label
+	+ sep
+
+yaxis  
+*	samescale         # do all facets have the same scale (currently only present if same on both axes)  
+*	ylabel  
+*	yticklabels       # if samescale present.  This is a vector
+*	ytickitems (list) * 
+	+ itemnum *
+	+ label           # the tick label
+	+ sep
+
+legends (list)		  # this includes colour, fill, shape, etc
+*	aes
+*	mapping
+*	scalediscrete
+*	scalefrom         # If scalediscrete not present
+*	scaleto           # if scalediscrete not present
+*	scalelevels       # if scalediscrete present
+*	hidden            # If this legend has been hidden
+
+npanels  
+panelrows             # What variable(s) are varying in the facet rows. Missing if not faceted.  
+panelcols             # What variable(s) are varying in the facet columns. Missing if not faceted.  
+singlepanel *  
+singlerow *  
+singlecol *  
+panelgrid *  
+nlayers  
+singlelayer *  
+panels (list)  
+
+*	panelnum		
+*	row               # What row of the panel grid is this panel in
+*	col               # What col of the panel grid is this panel in
+*	vars (list)       # What data is included in this panel
+    +	varname
+    +	value			
+*	samescale         # Duplicated from xaxis,yaxis
+*	xlabel            # if samescale not present, axis labelling for this panel
+*	ylabel            # if samescale not present, axis labelling for this panel
+*	xticklabels       # if samescale not present, axis labelling for this panel
+*	xtickitems (list) * 
+	+ itemnum *
+	+ label           # the tick label
+	+ sep
+*	yticklabels       # if samescale not present, axis labelling for this panel
+*	ytickitems (list) * 
+	+ itemnum *
+	+ label           # the tick label
+	+ sep
+	
+* panellayers (list)
+
+	+ layernum
+	+ type            # One of hline, bar, line, point, box, smooth, unknown
+	+ hlinetype *
+	+ bartype *
+	+ boxtype *
+	+ linetype *
+	+ pointtype *
+	+ smoothtype *
+	+ unknowntype *
+	+ layeraes (list) # Non-default aesthetics that were specified for this layer
+		+ aes
+		+ mapping
+	+ badtransform	  # A transform used in this layer has no inverse, can't report original values
+	+ transform	      # If badtransform present, the name of the tranform
+	+ data         	  # Raw plot data for this layer & panel. Used by MakeAccessibleSVG, not by VI
+	+ scaledata	      # Plot data converted back to original scale
+	+ n *             # Number of items present
+	+ s *             # If number of items > 1 (useful for pluralizing)
+	+ largecount *    # If no item details will be provided because there are too many
+	+ items (list) *  # Plot data converted to lists for mustache
+		+ itemnum
+		+ sep *       # text separator
+		+ yintercept  # if type hline
+		+ x           # if type point or line or box, or type bar with constant width bars  
+		+ y           # if type point or line
+		+ xmin        # if type bar with non-constant-width bars
+		+ xmax        # if type bar with non-constant-width bars
+		+ ymin        # if type box or bar
+		+ lower       # if type box
+		+ middle      # if type box
+		+ upper       # if type box
+		+ ymax        # if type box or bar
+		+ noutliers   # if type box
+	+ method          # if type smooth
+	+ ci              # if type smooth   
+```

---FILE: inst/whisker/VIdefault.txt---
@@ -0,0 +1,150 @@
+VIgg,""
+{{^annotations}}
+This is an untitled chart with no subtitle or caption.<br>
+{{/annotations}}
+{{#annotations}}
+{{#title}}This chart has title '{{title}}'.<br>{{/title}}
+{{^title}}This chart is untitled.<br>{{/title}}
+{{#subtitle}}It has the subtitle '{{subtitle}}'.<br>{{/subtitle}}
+{{#caption}}It has caption '{{caption}}'.<br>{{/caption}}
+{{/annotations}}
+{{#^singlepanel}}The chart is comprised of {{npanels}} panels containing sub-charts,
+{{#singlerow}} arranged horizontally.<br>{{/singlerow}}
+{{#singlecol}} arranged vertically.<br>{{/singlecol}}
+{{#panelgrid}} arranged in a grid.<br>{{/panelgrid}}
+{{^singlerow}}The {{#singlecol}}panels{{/singlecol}}{{^singlecol}}panel rows{{/singlecol}}
+ represent different values of {{panelrows}}.<br>{{/singlerow}}
+{{^singlecol}}The {{#singlerow}}panels{{/singlerow}}{{^singlerow}}panel columns{{/singlerow}}
+ represent different values of {{panelcols}}.<br>{{/singlecol}}
+{{/singlepanel}}
+{{^xaxis}}There is no x-axis.<br>{{/xaxis}}
+{{#xaxis}}{{#^singlepanel}}Each sub-chart{{/singlepanel}}{{#singlepanel}}It{{/singlepanel}} has x-axis '{{xlabel}}'
+{{#samescale}} with labels {{#xtickitems}}{{label}}{{sep}}{{/xtickitems}}{{/samescale}}
+.<br>{{/xaxis}}
+{{^yaxis}}There is no y-axis.<br>{{/yaxis}}
+{{#yaxis}}{{^singlepanel}}Each sub-chart{{/singlepanel}}{{#singlepanel}}It{{/singlepanel}} has y-axis '{{ylabel}}'
+{{#samescale}} with labels {{#ytickitems}}{{label}}{{sep}}{{/ytickitems}}{{/samescale}}
+.<br>{{/yaxis}}
+{{#legends}}
+{{^hidden}}There is a legend indicating that {{aes}} is used to represent {{mapping}}
+{{#scalediscrete}}, with {{scalenlevels}} levels:
+{{#scalelevelitems}}<br>{{level}} represented by {{aes}} {{map}}{{sep}}
+{{/scalelevelitems}}
+{{/scalediscrete}}
+{{^scalediscrete}}, ranging from {{scalefrom}} represented by {{aes}} {{scalemapfrom}}
+ to {{scaleto}} represented by {{aes}} {{scalemapto}}{{/scalediscrete}}
+.<br>
+{{/hidden}}
+{{#hidden}}In this chart {{aes}} is used to represent {{mapping}}
+{{#isfactor}}, a factor with levels: {{levels}}{{/isfactor}}. The legend that would normally indicate this has been hidden.<br>
+{{/hidden}}
+{{/legends}}
+{{^singlelayer}}{{^singlepanel}}Each sub-chart{{/singlepanel}}{{#singlepanel}}It{{/singlepanel}} has {{nlayers}} layers.<br>{{/singlelayer}}
+{{#panels}}
+{{>ggPanelTemplate}}
+{{/panels}}
+""
+ggPanelTemplate,""
+{{^singlepanel}}
+Panel {{panelnum}}
+{{#panelgrid}} is in row {{row}} and col {{col}} and{{/panelgrid}}
+ represents data for{{#vars}} {{varname}} = {{value}}{{/vars}}.<br>
+{{^samescale}}
+In this panel, x-axis '{{xlabel}}' has labels {{#xtickitems}}{{label}}{{sep}}{{/xtickitems}}.<br>
+In this panel, y-axis '{{ylabel}}' has labels {{#ytickitems}}{{label}}{{sep}}{{/ytickitems}}.<br>
+{{/samescale}}
+{{/singlepanel}}
+{{#panellayers}}
+{{>ggLayerTemplate}}
+{{/panellayers}}
+""
+ggLayerTemplate,""
+{{#badtransform}}
+Data is transformed with tranformation {{transform}} which doesn't seem to have an inverse. 
+Data values may be reported incorrectly.
+{{/badtransform}}
+{{^singlelayer}}Layer {{layernum}}
+{{^singlepanel}} of panel {{panelnum}}{{/singlepanel}} is {{/singlelayer}}
+{{#singlelayer}}
+{{^singlepanel}}Panel {{panelnum}} is {{/singlepanel}}
+{{#singlepanel}}The chart is {{/singlepanel}}
+{{/singlelayer}}
+{{#typehline}}
+{{n}} horizontal line{{#s}}s{{/s}}
+{{^largecount}} as follows:{{#items}}<br>Line at y position {{yintercept}}
+{{#size}} with size {{size}}{{#sizemap}} which maps to {{sizelabel}} = {{sizemap}}{{/sizemap}},{{/size}}
+{{#linetype}} with line type {{linetype}}{{#linetypemap}} which maps to {{linetypelabel}} = {{linetypemap}}{{/linetypemap}},{{/linetype}}
+{{#colour}} with colour {{colour}}{{#colourmap}} which maps to {{colourlabel}} = {{colourmap}}{{/colourmap}}{{/colour}}
+{{sep}}{{/items}}
+{{/largecount}}.<br>
+{{/typehline}}
+{{#typebar}}
+a bar chart containing {{n}} vertical bar{{#s}}s{{/s}}.<br>
+{{^largecount}}
+{{#items}}Bar {{itemnum}}
+{{#xmin}} spans horizontally from {{xmin}} to {{xmax}}{{/xmin}}
+{{^xmin}} is centered horizontally at {{x}}{{/xmin}}
+, and spans vertically from {{ymin}} to {{ymax}}
+{{#fill}} with fill colour {{fill}}{{#fillmap}} which maps to {{filllabel}} = {{fillmap}}{{/fillmap}}{{/fill}}
+{{#colour}} with border colour {{colour}}{{#colourmap}} which maps to {{colourlabel}} = {{colourmap}}{{/colourmap}}{{/colour}}
+{{#linetype}} with border line type {{linetype}}{{#linetypemap}} which maps to {{linetypelabel}} = {{linetypemap}}{{/linetypemap}}{{/linetype}}
+{{#size}} with border line width {{size}}{{#sizemap}} which maps to {{sizelabel}} = {{sizemap}}{{/sizemap}}{{/size}}
+.<br>{{/items}}
+{{/largecount}}
+{{/typebar}}
+{{#typepoint}}
+a set of {{n}} point{{#s}}s{{/s}}.<br>
+{{^largecount}}
+The points are at:<br>
+{{#items}}({{x}}, {{y}})
+{{#size}} size {{size}} mm{{#sizemap}} which maps to {{sizelabel}} = {{sizemap}}{{/sizemap}}{{/size}}
+{{#shape}} shape {{shape}}{{#shapemap}} which maps to {{shapelabel}} = {{shapemap}}{{/shapemap}}{{/shape}}
+{{#colour}} colour {{colour}}{{#colourmap}} which maps to {{colourlabel}} = {{colourmap}}{{/colourmap}}{{/colour}}
+{{#fill}} fill {{fill}}{{#fillmap}} which maps to {{filllabel}} = {{fillmap}}{{/fillmap}}{{/fill}}
+{{#alpha}} alpha {{alpha}}{{#alphamap}} which maps to {{alphalabel}} = {{alphamap}}{{/alphamap}}{{/alpha}}
+{{sep}}<br>{{/items}}
+{{/largecount}}
+{{/typepoint}}
+{{#typeline}}
+a set of {{n}} line{{#s}}s{{/s}}.<br>
+{{#broken}}The line{{#s}}s are{{/s}}{{^s}} is{{/s}} broken or missing where NA values appear or where points exceed the plot boundaries.<br>{{/broken}}
+{{^largecount}}
+{{#lines}}
+Line {{linenum}} connects {{npoints}} points{{^largecount}}, at {{#items}}({{x}}, {{y}}){{sep}}{{/items}}{{/largecount}}.<br>
+{{#alphavarying}}The alpha value varies along the length of this line.<br>{{/alphavarying}}
+{{#alpha}}This line has alpha {{alpha}}{{#alphamap}} which maps to {{alphalabel}} = {{alphamap}}{{/alphamap}}.<br>{{/alpha}}
+{{#colourvarying}}The colour varies along the length of this line.<br>{{/colourvarying}}
+{{#colour}}This line has colour {{colour}}{{#colourmap}} which maps to {{colourlabel}} = {{colourmap}}{{/colourmap}}.<br>{{/colour}}
+{{#sizevarying}}The line size varies along the length of this line.<br>{{/sizevarying}}
+{{#size}}This line has line size {{size}} mm{{#sizemap}} which maps to {{sizelabel}} = {{sizemap}}{{/sizemap}}.<br>{{/size}}
+{{#linetypevarying}}The line type varies along the length of this line.<br>{{/linetypevarying}}
+{{#linetype}}This line has line type {{linetype}}{{#linetypemap}} which maps to {{linetypelabel}} = {{linetypemap}}{{/linetypemap}}.<br>{{/linetype}}
+{{/lines}}
+{{/largecount}}
+{{/typeline}}
+{{#typebox}}
+a boxplot comprised of {{n}} box{{#s}}es{{/s}} with whiskers.<br>
+{{#items}}
+There is a box at x={{x}}
+{{#alpha}} with alpha {{alpha}}{{#alphamap}} which maps to {{alphalabel}} = {{alphamap}}{{/alphamap}}{{/alpha}}
+{{#colour}} with colour {{colour}}{{#colourmap}} which maps to {{colourlabel}} = {{colourmap}}{{/colourmap}}{{/colour}}
+{{#fill}} with fill {{fill}}{{#fillmap}} which maps to {{filllabel}} = {{fillmap}}{{/fillmap}}{{/fill}}
+{{#size}} with line size {{size}} mm{{#sizemap}} which maps to {{sizelabel}} = {{sizemap}}{{/sizemap}}{{/size}}
+{{#linetype}} with line type {{linetype}}{{#linetypemap}} which maps to {{linetypelabel}} = {{linetypemap}}{{/linetypemap}}{{/linetype}}
+.<br>It has median {{middle}}.
+ The box goes from {{lower}} to {{upper}}, and the whiskers extend to {{ymin}} and {{ymax}}.<br>
+There are {{noutliers}} outliers for this boxplot.<br>
+{{/items}}
+{{/typebox}}
+{{#typesmooth}}
+a smoothed curve using method '{{method}}'{{#ci}} with confidence intervals{{/ci}}.<br>
+{{/typesmooth}}
+{{#typeunknown}}
+a type that VI isn't able to process.<br>
+{{/typeunknown}}
+{{#layeraes}}
+{{^singlelayer}}Layer {{layernum}} {{/singlelayer}}{{#singlelayer}}The chart {{/singlelayer}}
+has {{aes}} set to {{mapping}}.<br>
+{{/layeraes}}
+""
+

---FILE: man/MakeAccessibleSVGMethod.Rd---
@@ -4,6 +4,7 @@
 \alias{MakeAccessibleSVG.histogram}
 \alias{MakeAccessibleSVG.scatterplot}
 \alias{MakeAccessibleSVG.tsplot}
+\alias{MakeAccessibleSVG.ggplot}
 
 \title{Create matched pairs of SVG and XML files to make an accessible graph experience.}
 \description{Creates the necessary SVG and XML files for a graph object (as long as it has a class assigned) or the current graph window.}

---FILE: man/SVGThis.Rd---
@@ -14,14 +14,16 @@
 \title{Save commonly used graphs as structured SVG files.}
 \description{Converts a graph object (as long as it has a class assigned) or the current graph window to an SVG file that can be viewed using the  Tiger Player software available from ViewPlus Inc. At present, the SVG needs manual editing using the Tiger Transformer software before viewing.}
 \usage{
-SVGThis(x, file = ""test.svg"")
-}
+SVGThis(x, file = ""test.svg"", ...)}
 \arguments{
   \item{x}{a graph object for which a method exists, or the current graphics device if set to NULL.}
   \item{file}{The SVG file to be created.}
+  \item{...}{Arguments to be passed to the methods.}
 }
 \details{
-The Cairo SVG device found in the \pkg{gr.devices} package does not create a structured SVG file that includes the semantics of the graphic being displayed. The SVG created by the \pkg{gridSVG} package does meet this need, but only works on graphs drawn using the \pkg{grid} package. Any graph created using functions from the more common \pkg{graphics} package can be converted to the \pkg{grid} package system using the \pkg{gridGraphics} package.}
+The Cairo SVG device found in the \pkg{gr.devices} package does not create a structured SVG file that includes the semantics of the graphic being displayed. The SVG created by the \pkg{gridSVG} package does meet this need, but only works on graphs drawn using the \pkg{grid} package. Any graph created using functions from the more common \pkg{graphics} package can be converted to the \pkg{grid} package system using the \pkg{gridGraphics} package.
+
+The \code{SVGThis.ggplot} method accepts argument \code{createDevice} (default TRUE) - if true the method creates its own null pdf device to draw the graph on, if false it draws on the current device.}
 \value{NULL. This function is solely for the purpose of creating SVG files in the current working directory or in a path of the user's choosing.}
 \references{
 P. Murrell and S. Potter (2014) \dQuote{{The \pkg{gridSVG} package}} The R Journal 6/1, pp. 133-143. http://journal.r-project.org/archive/2014-1/RJournal_2014-1_murrell-potter.pdf

---FILE: man/VI.ggplot.Rd---
@@ -1,22 +1,31 @@
 \name{VI.ggplot}
 \alias{VI.ggplot}
+\alias{print.VIgraph}
 \title{VI for graphs created using ggplot2}
 \usage{
-\method{VI}{ggplot}(x, Describe, ...)
+\method{VI}{ggplot}(x, Describe=FALSE, threshold=10, 
+   template=system.file(""whisker/VIdefault.txt"", package=""BrailleR""),
+   ...)
 }
 \arguments{
 \item{x}{an object created by ggplot() or qplot() from the ggplot2 package which therefore has class gg or ggplot.}
-\item{Describe}{Should the Describe function be called at the same time}
+\item{Describe}{Should the Describe function be called at the same time. Not currently implemented for ggplot objects.}
+\item{threshold}{Maximum number of data items that should be individually listed in the output.}
+\item{template}{Template file, in mustache format, to be used in creating the text}
 \item{...}{other arguments, currently ignored}
 }
 \value{
-A text description is printed out as a side effect. The function returns NULL invisibly.
+Returns a structure containing a hierarchical representation of the graph as well as the text description as a character vector.  When run interactively, the text
+description is printed.
 }
 \description{
-The popular ggplot2 package creates graphs using many default settings and it is unlikely that all ramifications of using this package will be understood by reading the code alone. Text descriptions of these graphs may still be less complete than those created using base graphics.
+Prints a textual description of a graph produced by ggplot or qplot.
 }
-\details{
-Still lots to do with this functionality. The theme of the graph may prove important to blind users although less interesting to the creation of purely text alternatives of the graphs.
+\note{
+This function is experimental.  The ggplot2 package produces many different types
+of graphs and offers many options for modifying the graph appearance. Not all
+options have been fully catered for, so text descriptions of these graphs may still be less complete than those created using base graphics, or may be 
+misleading in some circumstances.
 }
 \examples{
 if(require(ggplot2)){
@@ -27,6 +36,6 @@ g
 }
 }
 \author{
-A. Jonathan R. Godfrey and Tony Hirst
+A. Jonathan R. Godfrey, Tony Hirst and Debra Warren
 }
 

---FILE: man/VIgrep.Rd---
@@ -0,0 +1,28 @@
+\name{VIgrep}
+\alias{VIgrep}
+\title{
+Grep within the output produced by VI.ggplot
+}
+\description{
+Allows the output from VI.ggplot to be limited based on a search pattern.
+}
+\usage{
+VIgrep(pattern, x, ...)
+}
+\arguments{
+  \item{pattern}{Charater string for matching, as per \code{grepl}} 
+  \item{x}{object returned by \code{VI.ggplot}}
+  \item{...}{other arguments passed on to \code{grepl} to control matching behaviour}
+}
+\value{
+Returns a new object of the same type as that returned by VI.ggplot, but with the text component restricted to only those lines that matched the pattern.
+}
+\author{
+Debra Warren
+}
+
+\examples{
+if(require(ggplot2)){
+VIgrep(""axis"",VI(qplot(1,1)))
+}
+}

---FILE: man/VIsort.Rd---
@@ -0,0 +1,29 @@
+\name{VIsort}
+\alias{VIsort}
+\title{
+Sort VI.ggplot points list
+}
+\description{
+Allows the list of data points listed by VI.ggplot to be sorted by x or y values, ascending or descending.  Currently only implemented for geom_points.  This function is experimental and has not been extensively tested.
+}
+\usage{
+VIsort(x, sortby=""x"", decreasing = FALSE)
+}
+\arguments{
+  \item{x}{object returned by \code{VI.ggplot}}
+  \item{sortby}{value on which to sort, ""x"" or ""y""}
+  \item{decreasing}{logical: should the sort be decreasing}
+}
+\value{
+Returns a new object of the same type as that returned by VI.ggplot, but with data re-ordered.
+}
+\author{
+Debra Warren
+}
+
+\examples{
+if(require(ggplot2)){
+VIsort(VI(qplot(x=1:5,y=c(2,5,1,4,3))),sortby=""y"",dec=TRUE)
+}
+}
+

---FILE: tests/VI.ggplot.test.R---
@@ -0,0 +1,79 @@
+library(BrailleR)
+library(ggplot2)
+
+# Add some factor variables to mtcars
+m= within(mtcars,{am = as.factor(ifelse(am,""auto"",""manual"")); cyl = as.factor(cyl)})
+
+# qplot - exercise the various qplot parameters and geoms
+# points, smoothing, log-transform, xlim
+VI(qplot(data=m, disp,mpg, facets=.~am, margins=TRUE, 
+          geom=c(""point"",""smooth""), main=""Cars, cars, cars"", xlab=""displacement"", 
+          ylab=""Miles per gallon"", log=""y"", xlim=c(90,450)))
+
+# boxplot, title, subtitle & caption
+VI(qplot(data=m, cyl, mpg, geom=""boxplot"") + 
+     labs(title = ""MPG by cyl"",subtitle=""for mtcars dataset"",caption=""some caption here""))
+
+# line, no annotation
+VI(qplot(data=economics[1:8,], date, unemploy, geom=""line""))
+
+# Add a horizontal line
+VI(qplot(data=economics[1:20,], x=date, y=unemploy, geom=""line"") + 
+  geom_hline(yintercept=3000, col=""blue""))
+
+# Set some constant aesthetics
+VI(qplot(data=m, disp, mpg, shape=I(""x""), size=I(5), alpha=I(0.3)))
+
+# With some variable aesthetics
+VI(qplot(data=m[1:10,], disp, mpg, mapping=aes(shape=am,size=hp)))
+
+# Categorical axis with not all categories in all facets
+VI(qplot(data=m, cyl, mpg) + facet_grid(.~round(disp/100), scales = ""free""))
+
+# Faceted histogram
+VI(qplot(data=m, mpg, facets=.~cyl))
+
+# Test all aesthetics for all supported plot types
+# Note: These charts don't necessarily make sense, and some look disgusting.
+# They're just to test printing all the aesthetic information
+### Points
+VI(qplot(data=m[1:10,], mpg, disp, alpha=cyl, colour=mpg, fill=mpg, shape=I(20), size=disp))
+### Histogram
+VI(qplot(data=m[1:10,], mpg, geom=""histogram"", bins=5, alpha=am, colour=am, fill=am,
+         linetype=am, size=am))
+### Boxplots
+VI(qplot(data=m, cyl, mpg, geom=""boxplot"", alpha=am, colour=am, fill=am, linetype=am, size=am))
+### Hline
+VI(qplot(data=m[1:10,], geom=""hline"", mapping=aes(yintercept=mpg, alpha=am, colour=am,
+         linetype=am, size=am)))
+### Line
+VI(qplot(data=m[1:10,], geom=""line"", disp, mpg, alpha=am, colour=am, linetype=am, size=am))
+
+# Test all graph types when number of items exceeds threshold, so no detail printed
+VI(qplot(data=m, mpg, disp, geom=""point""))
+VI(qplot(data=m, mpg, disp, geom=""line""))
+VI(qplot(data=m, as.factor(mpg), disp, geom=""boxplot""))
+VI(qplot(data=m, mpg, geom=""histogram""))
+VI(qplot(data=m, mapping=aes(yintercept=mpg), geom=""hline""))
+VI(qplot(data=m, mpg, disp, geom=""smooth""))
+
+# Test cases for different methods of providing data
+x = 1:10
+y = c(2,5,1,4,3,5,1,3,2,4)
+z = as.factor(rep(c(""yes"",""no""),5))
+df = data.frame(x,y,z)
+# data frame provided to data param
+VI(qplot(data=df, x=x, y=y, facets=.~z))
+# data frame provided to data param, function eval
+VI(qplot(data=df, x=x*2, y=10-y, facets=.~z))
+# No data param, data frame accessed directly
+# Doesn't seem to be possible to facet this way
+VI(qplot(x=df$x, y=df$y))
+# No data param, data frame accessed directly, function eval
+VI(qplot(x=df$x*2, y=10-df$y))
+# Separate vectors accessed directly
+VI(qplot(x=x, y=y))
+# Separate vectors accessed directly, function eval
+VI(qplot(x=x*2, y=10-y))
+# Constants
+VI(qplot(1:10,c(2,5,1,4,3,5,1,3,2,4)))
\ No newline at end of file

---FILE: tests/VI.ggplot.test.Rout.save---
@@ -0,0 +1,552 @@
+
+R version 3.3.3 (2017-03-06) -- ""Another Canoe""
+Copyright (C) 2017 The R Foundation for Statistical Computing
+Platform: x86_64-w64-mingw32/x64 (64-bit)
+
+R is free software and comes with ABSOLUTELY NO WARRANTY.
+You are welcome to redistribute it under certain conditions.
+Type 'license()' or 'licence()' for distribution details.
+
+R is a collaborative project with many contributors.
+Type 'contributors()' for more information and
+'citation()' on how to cite R or R packages in publications.
+
+Type 'demo()' for some demos, 'help()' for on-line help, or
+'help.start()' for an HTML browser interface to help.
+Type 'q()' to quit R.
+
+> library(BrailleR)
+The BrailleR.View,  option is set to FALSE.
+
+Attaching package: 'BrailleR'
+
+The following objects are masked from 'package:graphics':
+
+    boxplot, hist
+
+The following object is masked from 'package:utils':
+
+    history
+
+> library(ggplot2)
+
+Attaching package: 'ggplot2'
+
+The following objects are masked from 'package:BrailleR':
+
+    xlab, ylab
+
+> 
+> # Add some factor variables to mtcars
+> m= within(mtcars,{am = as.factor(ifelse(am,""auto"",""manual"")); cyl = as.factor(cyl)})
+> 
+> # qplot - exercise the various qplot parameters and geoms
+> # points, smoothing, log-transform, xlim
+> VI(qplot(data=m, disp,mpg, facets=.~am, margins=TRUE, 
++           geom=c(""point"",""smooth""), main=""Cars, cars, cars"", xlab=""displacement"", 
++           ylab=""Miles per gallon"", log=""y"", xlim=c(90,450)))
+This chart has title 'Cars, cars, cars'.
+The chart is comprised of 3 panels containing sub-charts, arranged horizontally.
+The panels represent different values of am.
+Each sub-chart has x-axis 'displacement' with labels 100, 200, 300 and 400.
+Each sub-chart has y-axis 'Miles per gallon' with labels 10.
+Each sub-chart has 2 layers.
+Panel 1 represents data for am = auto.
+Layer 1 of panel 1 is a set of 9 points.
+The points are at:
+(160, 21), 
+(160, 21), 
+(108, 22.8), 
+(120.3, 26), 
+(95.1, 30.4), 
+(351, 15.8), 
+(145, 19.7), 
+(301, 15) and 
+(121, 21.4)
+Layer 2 of panel 1 is a smoothed curve using method 'auto' with confidence intervals.
+Panel 2 represents data for am = manual.
+Layer 1 of panel 2 is a set of 17 points.
+Layer 2 of panel 2 is a smoothed curve using method 'auto' with confidence intervals.
+Panel 3 represents data for am = (all).
+Layer 1 of panel 3 is a set of 26 points.
+Layer 2 of panel 3 is a smoothed curve using method 'auto' with confidence intervals.
+Warning message:
+Removed 12 rows containing non-finite values (stat_smooth). 
+> 
+> # boxplot, title, subtitle & caption
+> VI(qplot(data=m, cyl, mpg, geom=""boxplot"") + 
++      labs(title = ""MPG by cyl"",subtitle=""for mtcars dataset"",caption=""some caption here""))
+This chart has title 'MPG by cyl'.
+It has the subtitle 'for mtcars dataset'.
+It has caption 'some caption here'.
+It has x-axis 'cyl' with labels 4, 6 and 8.
+It has y-axis 'mpg' with labels 10, 15, 20, 25, 30 and 35.
+The chart is a boxplot comprised of 3 boxes with whiskers.
+There is a box at x=4.
+It has median 26. The box goes from 22.8 to 30.4, and the whiskers extend to 21.4 and 33.9.
+There are 0 outliers for this boxplot.
+There is a box at x=6.
+It has median 19.7. The box goes from 18.65 to 21, and the whiskers extend to 17.8 and 21.4.
+There are 0 outliers for this boxplot.
+There is a box at x=8.
+It has median 15.2. The box goes from 14.4 to 16.25, and the whiskers extend to 13.3 and 18.7.
+There are 3 outliers for this boxplot.
+> 
+> # line, no annotation
+> VI(qplot(data=economics[1:8,], date, unemploy, geom=""line""))
+This is an untitled chart with no subtitle or caption.
+It has x-axis 'date' with labels Jul, Oct and Jan.
+It has y-axis 'unemploy' with labels 2900, 2950, 3000, 3050, 3100 and 3150.
+The chart is a set of 1 line.
+Line 1 connects 8 points, at (1967-07-01, 2944), (1967-08-01, 2945), (1967-09-01, 2958), (1967-10-01, 3143), (1967-11-01, 3066), (1967-12-01, 3018), (1968-01-01, 2878) and (1968-02-01, 3001).
+> 
+> # Add a horizontal line
+> VI(qplot(data=economics[1:20,], x=date, y=unemploy, geom=""line"") + 
++   geom_hline(yintercept=3000, col=""blue""))
+This is an untitled chart with no subtitle or caption.
+It has x-axis 'date' with labels 1967-07, 1968-01, 1968-07 and 1969-01.
+It has y-axis 'unemploy' with labels 2700, 2800, 2900, 3000 and 3100.
+It has 2 layers.
+Layer 1 is a set of 1 line.
+Line 1 connects 20 points.
+Layer 2 is 1 horizontal line as follows:
+Line at y position 3000.
+Layer 2 has colour set to blue.
+> 
+> # Set some constant aesthetics
+> VI(qplot(data=m, disp, mpg, shape=I(""x""), size=I(5), alpha=I(0.3)))
+This is an untitled chart with no subtitle or caption.
+It has x-axis 'disp' with labels 100, 200, 300 and 400.
+It has y-axis 'mpg' with labels 10, 15, 20, 25, 30 and 35.
+The chart is a set of 32 points.
+The chart has shape set to x.
+The chart has size set to 5.
+The chart has alpha set to 0.3.
+> 
+> # With some variable aesthetics
+> VI(qplot(data=m[1:10,], disp, mpg, mapping=aes(shape=am,size=hp)))
+This is an untitled chart with no subtitle or caption.
+It has x-axis 'disp' with labels 100, 200 and 300.
+It has y-axis 'mpg' with labels 15.0, 17.5, 20.0 and 22.5.
+There is a legend indicating that shape is used to represent am, with 2 levels:
+auto represented by shape solid circle and 
+manual represented by shape solid triangle.
+There is a legend indicating that size is used to represent hp, ranging from 62 represented by size 1 to 245 represented by size 6.
+The chart is a set of 10 points.
+The points are at:
+(160, 21) size 3.56 mm shape solid circle which maps to am = auto, 
+(160, 21) size 3.56 mm shape solid circle which maps to am = auto, 
+(108, 22.8) size 3.06 mm shape solid circle which maps to am = auto, 
+(258, 21.4) size 3.56 mm shape solid triangle which maps to am = manual, 
+(360, 18.7) size 4.93 mm shape solid triangle which maps to am = manual, 
+(225, 18.1) size 3.42 mm shape solid triangle which maps to am = manual, 
+(360, 14.3) size 6 mm shape solid triangle which maps to am = manual, 
+(146.7, 24.4) size 1 mm shape solid triangle which maps to am = manual, 
+(140.8, 22.8) size 3.12 mm shape solid triangle which maps to am = manual and 
+(167.6, 19.2) size 3.89 mm shape solid triangle which maps to am = manual
+> 
+> # Categorical axis with not all categories in all facets
+> VI(qplot(data=m, cyl, mpg) + facet_grid(.~round(disp/100), scales = ""free""))
+This is an untitled chart with no subtitle or caption.
+The chart is comprised of 5 panels containing sub-charts, arranged horizontally.
+The panels represent different values of round(disp/100).
+Each sub-chart has x-axis 'cyl'.
+Each sub-chart has y-axis 'mpg'.
+Panel 1 represents data for round(disp/100) = 1.
+In this panel, x-axis 'cyl' has labels 4 and 6.
+In this panel, y-axis 'mpg' has labels 10, 15, 20, 25, 30 and 35.
+Panel 1 is a set of 12 points.
+Panel 2 represents data for round(disp/100) = 2.
+In this panel, x-axis 'cyl' has labels 6.
+In this panel, y-axis 'mpg' has labels 10, 15, 20, 25, 30 and 35.
+Panel 2 is a set of 5 points.
+The points are at:
+(6, 21), 
+(6, 21), 
+(6, 18.1), 
+(6, 19.2) and 
+(6, 17.8)
+Panel 3 represents data for round(disp/100) = 3.
+In this panel, x-axis 'cyl' has labels 6 and 8.
+In this panel, y-axis 'mpg' has labels 10, 15, 20, 25, 30 and 35.
+Panel 3 is a set of 7 points.
+The points are at:
+(6, 21.4), 
+(8, 16.4), 
+(8, 17.3), 
+(8, 15.2), 
+(8, 15.5), 
+(8, 15.2) and 
+(8, 15)
+Panel 4 represents data for round(disp/100) = 4.
+In this panel, x-axis 'cyl' has labels 8.
+In this panel, y-axis 'mpg' has labels 10, 15, 20, 25, 30 and 35.
+Panel 4 is a set of 6 points.
+The points are at:
+(8, 18.7), 
+(8, 14.3), 
+(8, 14.7), 
+(8, 13.3), 
+(8, 19.2) and 
+(8, 15.8)
+Panel 5 represents data for round(disp/100) = 5.
+In this panel, x-axis 'cyl' has labels 8.
+In this panel, y-axis 'mpg' has labels 10, 15, 20, 25, 30 and 35.
+Panel 5 is a set of 2 points.
+The points are at:
+(8, 10.4) and 
+(8, 10.4)
+> 
+> # Faceted histogram
+> VI(qplot(data=m, mpg, facets=.~cyl))
+This is an untitled chart with no subtitle or caption.
+The chart is comprised of 3 panels containing sub-charts, arranged horizontally.
+The panels represent different values of cyl.
+Each sub-chart has x-axis 'mpg' with labels 10, 15, 20, 25, 30 and 35.
+Each sub-chart has y-axis 'count' with labels 0, 1, 2, 3, 4 and 5.
+Panel 1 represents data for cyl = 4.
+Panel 1 is a bar chart containing 30 vertical bars.
+Panel 2 represents data for cyl = 6.
+Panel 2 is a bar chart containing 30 vertical bars.
+Panel 3 represents data for cyl = 8.
+Panel 3 is a bar chart containing 30 vertical bars.
+> 
+> # Test all aesthetics for all supported plot types
+> # Note: These charts don't necessarily make sense, and some look disgusting.
+> # They're just to test printing all the aesthetic information
+> ### Points
+> VI(qplot(data=m[1:10,], mpg, disp, alpha=cyl, colour=mpg, fill=mpg, shape=I(20), size=disp))
+This is an untitled chart with no subtitle or caption.
+It has x-axis 'mpg' with labels 15.0, 17.5, 20.0 and 22.5.
+It has y-axis 'disp' with labels 100, 200 and 300.
+There is a legend indicating that alpha is used to represent cyl, with 3 levels:
+4 represented by alpha 0.1, 
+6 represented by alpha 0.55 and 
+8 represented by alpha 1.
+There is a legend indicating that colour is used to represent mpg, ranging from 14.3 represented by colour #132B43 to 24.4 represented by colour #56B1F7.
+There is a legend indicating that fill is used to represent mpg, ranging from 14.3 represented by fill #132B43 to 24.4 represented by fill #56B1F7.
+There is a legend indicating that size is used to represent disp, ranging from 108 represented by size 1 to 360 represented by size 6.
+The chart is a set of 10 points.
+The points are at:
+(21, 160) size 3.27 mm colour #3E81B6 fill #3E81B6 alpha 0.55 which maps to cyl = 6, 
+(21, 160) size 3.27 mm colour #3E81B6 fill #3E81B6 alpha 0.55 which maps to cyl = 6, 
+(22.8, 108) size 1 mm colour #4B9AD8 fill #4B9AD8 alpha 0.1 which maps to cyl = 4, 
+(21.4, 258) size 4.86 mm colour #4186BD fill #4186BD alpha 0.55 which maps to cyl = 6, 
+(18.7, 360) size 6 mm colour #2E628C fill #2E628C alpha 1 which maps to cyl = 8, 
+(18.1, 225) size 4.41 mm colour #2B5A82 fill #2B5A82 alpha 0.55 which maps to cyl = 6, 
+(14.3, 360) size 6 mm colour #132B43 fill #132B43 alpha 1 which maps to cyl = 8, 
+(24.4, 146.7) size 2.96 mm colour #56B1F7 fill #56B1F7 alpha 0.1 which maps to cyl = 4, 
+(22.8, 140.8) size 2.8 mm colour #4B9AD8 fill #4B9AD8 alpha 0.1 which maps to cyl = 4 and 
+(19.2, 167.6) size 3.43 mm colour #326895 fill #326895 alpha 0.55 which maps to cyl = 6
+The chart has shape set to small solid circle.
+> ### Histogram
+> VI(qplot(data=m[1:10,], mpg, geom=""histogram"", bins=5, alpha=am, colour=am, fill=am,
++          linetype=am, size=am))
+This is an untitled chart with no subtitle or caption.
+It has x-axis 'mpg' with labels 16, 20 and 24.
+It has y-axis 'count' with labels 0, 1, 2, 3 and 4.
+There is a legend indicating that alpha is used to represent am, with 2 levels:
+auto represented by alpha 0.1 and 
+manual represented by alpha 1.
+There is a legend indicating that colour is used to represent am, with 2 levels:
+auto represented by colour #F8766D and 
+manual represented by colour #00BFC4.
+There is a legend indicating that fill is used to represent am, with 2 levels:
+auto represented by fill #F8766D and 
+manual represented by fill #00BFC4.
+There is a legend indicating that linetype is used to represent am, with 2 levels:
+auto represented by linetype solid and 
+manual represented by linetype 22.
+There is a legend indicating that size is used to represent am, with 2 levels:
+auto represented by size 2 and 
+manual represented by size 6.
+The chart is a bar chart containing 10 vertical bars.
+Bar 1 is centered horizontally at 15.15, and spans vertically from 0 to 1 with fill colour #00BFC4 which maps to am = manual with border colour #00BFC4 which maps to am = manual with border line type 22 which maps to am = manual with border line width 6 which maps to am = manual.
+Bar 2 is centered horizontally at 15.15, and spans vertically from 1 to 1 with fill colour #F8766D which maps to am = auto with border colour #F8766D which maps to am = auto with border line type solid which maps to am = auto with border line width 2 which maps to am = auto.
+Bar 3 is centered horizontally at 17.67, and spans vertically from 0 to 2 with fill colour #00BFC4 which maps to am = manual with border colour #00BFC4 which maps to am = manual with border line type 22 which maps to am = manual with border line width 6 which maps to am = manual.
+Bar 4 is centered horizontally at 17.67, and spans vertically from 2 to 2 with fill colour #F8766D which maps to am = auto with border colour #F8766D which maps to am = auto with border line type solid which maps to am = auto with border line width 2 which maps to am = auto.
+Bar 5 is centered horizontally at 20.2, and spans vertically from 0 to 2 with fill colour #00BFC4 which maps to am = manual with border colour #00BFC4 which maps to am = manual with border line type 22 which maps to am = manual with border line width 6 which maps to am = manual.
+Bar 6 is centered horizontally at 20.2, and spans vertically from 2 to 4 with fill colour #F8766D which maps to am = auto with border colour #F8766D which maps to am = auto with border line type solid which maps to am = auto with border line width 2 which maps to am = auto.
+Bar 7 is centered horizontally at 22.72, and spans vertically from 0 to 1 with fill colour #00BFC4 which maps to am = manual with border colour #00BFC4 which maps to am = manual with border line type 22 which maps to am = manual with border line width 6 which maps to am = manual.
+Bar 8 is centered horizontally at 22.72, and spans vertically from 1 to 2 with fill colour #F8766D which maps to am = auto with border colour #F8766D which maps to am = auto with border line type solid which maps to am = auto with border line width 2 which maps to am = auto.
+Bar 9 is centered horizontally at 25.25, and spans vertically from 0 to 1 with fill colour #00BFC4 which maps to am = manual with border colour #00BFC4 which maps to am = manual with border line type 22 which maps to am = manual with border line width 6 which maps to am = manual.
+Bar 10 is centered horizontally at 25.25, and spans vertically from 1 to 1 with fill colour #F8766D which maps to am = auto with border colour #F8766D which maps to am = auto with border line type solid which maps to am = auto with border line width 2 which maps to am = auto.
+Warning message:
+Using size for a discrete variable is not advised. 
+> ### Boxplots
+> VI(qplot(data=m, cyl, mpg, geom=""boxplot"", alpha=am, colour=am, fill=am, linetype=am, size=am))
+This is an untitled chart with no subtitle or caption.
+It has x-axis 'cyl' with labels 4, 6 and 8.
+It has y-axis 'mpg' with labels 10, 15, 20, 25, 30 and 35.
+There is a legend indicating that alpha is used to represent am, with 2 levels:
+auto represented by alpha 0.1 and 
+manual represented by alpha 1.
+There is a legend indicating that colour is used to represent am, with 2 levels:
+auto represented by colour #F8766D and 
+manual represented by colour #00BFC4.
+There is a legend indicating that fill is used to represent am, with 2 levels:
+auto represented by fill #F8766D and 
+manual represented by fill #00BFC4.
+There is a legend indicating that linetype is used to represent am, with 2 levels:
+auto represented by linetype solid and 
+manual represented by linetype 22.
+There is a legend indicating that size is used to represent am, with 2 levels:
+auto represented by size 2 and 
+manual represented by size 6.
+The chart is a boxplot comprised of 6 boxes with whiskers.
+There is a box at x=1.19 with alpha 1 which maps to am = manual with colour #00BFC4 which maps to am = manual with fill #00BFC4 which maps to am = manual with line size 6 mm which maps to am = manual with line type 22 which maps to am = manual.
+It has median 22.8. The box goes from 22.15 to 23.6, and the whiskers extend to 21.5 and 24.4.
+There are 0 outliers for this boxplot.
+There is a box at x=0.81 with alpha 0.1 which maps to am = auto with colour #F8766D which maps to am = auto with fill #F8766D which maps to am = auto with line size 2 mm which maps to am = auto with line type solid which maps to am = auto.
+It has median 28.85. The box goes from 25.2 to 30.9, and the whiskers extend to 21.4 and 33.9.
+There are 0 outliers for this boxplot.
+There is a box at x=2.19 with alpha 1 which maps to am = manual with colour #00BFC4 which maps to am = manual with fill #00BFC4 which maps to am = manual with line size 6 mm which maps to am = manual with line type 22 which maps to am = manual.
+It has median 18.65. The box goes from 18.03 to 19.75, and the whiskers extend to 17.8 and 21.4.
+There are 0 outliers for this boxplot.
+There is a box at x=1.81 with alpha 0.1 which maps to am = auto with colour #F8766D which maps to am = auto with fill #F8766D which maps to am = auto with line size 2 mm which maps to am = auto with line type solid which maps to am = auto.
+It has median 21. The box goes from 20.35 to 21, and the whiskers extend to 19.7 and 21.
+There are 0 outliers for this boxplot.
+There is a box at x=3.19 with alpha 1 which maps to am = manual with colour #00BFC4 which maps to am = manual with fill #00BFC4 which maps to am = manual with line size 6 mm which maps to am = manual with line type 22 which maps to am = manual.
+It has median 15.2. The box goes from 14.05 to 16.62, and the whiskers extend to 10.4 and 19.2.
+There are 0 outliers for this boxplot.
+There is a box at x=2.81 with alpha 0.1 which maps to am = auto with colour #F8766D which maps to am = auto with fill #F8766D which maps to am = auto with line size 2 mm which maps to am = auto with line type solid which maps to am = auto.
+It has median 15.4. The box goes from 15.2 to 15.6, and the whiskers extend to 15 and 15.8.
+There are 0 outliers for this boxplot.
+Warning message:
+Using size for a discrete variable is not advised. 
+> ### Hline
+> VI(qplot(data=m[1:10,], geom=""hline"", mapping=aes(yintercept=mpg, alpha=am, colour=am,
++          linetype=am, size=am)))
+This is an untitled chart with no subtitle or caption.
+It has x-axis '' with labels .
+It has y-axis 'mpg' with labels 15.0, 17.5, 20.0 and 22.5.
+There is a legend indicating that alpha is used to represent am, with 2 levels:
+auto represented by alpha 0.1 and 
+manual represented by alpha 1.
+There is a legend indicating that colour is used to represent am, with 2 levels:
+auto represented by colour #F8766D and 
+manual represented by colour #00BFC4.
+There is a legend indicating that linetype is used to represent am, with 2 levels:
+auto represented by linetype solid and 
+manual represented by linetype 22.
+There is a legend indicating that size is used to represent am, with 2 levels:
+auto represented by size 2 and 
+manual represented by size 6.
+The chart is 10 horizontal lines as follows:
+Line at y position 21 with size 2 which maps to am = auto, with line type solid which maps to am = auto, with colour #F8766D which maps to am = auto, 
+Line at y position 21 with size 2 which maps to am = auto, with line type solid which maps to am = auto, with colour #F8766D which maps to am = auto, 
+Line at y position 22.8 with size 2 which maps to am = auto, with line type solid which maps to am = auto, with colour #F8766D which maps to am = auto, 
+Line at y position 21.4 with size 6 which maps to am = manual, with line type 22 which maps to am = manual, with colour #00BFC4 which maps to am = manual, 
+Line at y position 18.7 with size 6 which maps to am = manual, with line type 22 which maps to am = manual, with colour #00BFC4 which maps to am = manual, 
+Line at y position 18.1 with size 6 which maps to am = manual, with line type 22 which maps to am = manual, with colour #00BFC4 which maps to am = manual, 
+Line at y position 14.3 with size 6 which maps to am = manual, with line type 22 which maps to am = manual, with colour #00BFC4 which maps to am = manual, 
+Line at y position 24.4 with size 6 which maps to am = manual, with line type 22 which maps to am = manual, with colour #00BFC4 which maps to am = manual, 
+Line at y position 22.8 with size 6 which maps to am = manual, with line type 22 which maps to am = manual, with colour #00BFC4 which maps to am = manual and 
+Line at y position 19.2 with size 6 which maps to am = manual, with line type 22 which maps to am = manual, with colour #00BFC4 which maps to am = manual.
+Warning message:
+Using size for a discrete variable is not advised. 
+> ### Line
+> VI(qplot(data=m[1:10,], geom=""line"", disp, mpg, alpha=am, colour=am, linetype=am, size=am))
+This is an untitled chart with no subtitle or caption.
+It has x-axis 'disp' with labels 100, 200 and 300.
+It has y-axis 'mpg' with labels 15.0, 17.5, 20.0 and 22.5.
+There is a legend indicating that alpha is used to represent am, with 2 levels:
+auto represented by alpha 0.1 and 
+manual represented by alpha 1.
+There is a legend indicating that colour is used to represent am, with 2 levels:
+auto represented by colour #F8766D and 
+manual represented by colour #00BFC4.
+There is a legend indicating that linetype is used to represent am, with 2 levels:
+auto represented by linetype solid and 
+manual represented by linetype 22.
+There is a legend indicating that size is used to represent am, with 2 levels:
+auto represented by size 2 and 
+manual represented by size 6.
+The chart is a set of 2 lines.
+Line 1 connects 3 points, at (108, 22.8), (160, 21) and (160, 21).
+This line has alpha 0.1 which maps to am = auto.
+This line has colour #F8766D which maps to am = auto.
+This line has line size 2 mm which maps to am = auto.
+This line has line type solid which maps to am = auto.
+Line 2 connects 7 points, at (140.8, 22.8), (146.7, 24.4), (167.6, 19.2), (225, 18.1), (258, 21.4), (360, 18.7) and (360, 14.3).
+This line has alpha 1 which maps to am = manual.
+This line has colour #00BFC4 which maps to am = manual.
+This line has line size 6 mm which maps to am = manual.
+This line has line type 22 which maps to am = manual.
+Warning message:
+Using size for a discrete variable is not advised. 
+> 
+> # Test all graph types when number of items exceeds threshold, so no detail printed
+> VI(qplot(data=m, mpg, disp, geom=""point""))
+This is an untitled chart with no subtitle or caption.
+It has x-axis 'mpg' with labels 10, 15, 20, 25, 30 and 35.
+It has y-axis 'disp' with labels 100, 200, 300 and 400.
+The chart is a set of 32 points.
+> VI(qplot(data=m, mpg, disp, geom=""line""))
+This is an untitled chart with no subtitle or caption.
+It has x-axis 'mpg' with labels 10, 15, 20, 25, 30 and 35.
+It has y-axis 'disp' with labels 100, 200, 300 and 400.
+The chart is a set of 1 line.
+Line 1 connects 32 points.
+> VI(qplot(data=m, as.factor(mpg), disp, geom=""boxplot""))
+This is an untitled chart with no subtitle or caption.
+It has x-axis 'as.factor(mpg)' with labels 10.4, 13.3, 14.3, 14.7, 15, 15.2, 15.5, 15.8, 16.4, 17.3, 17.8, 18.1, 18.7, 19.2, 19.7, 21, 21.4, 21.5, 22.8, 24.4, 26, 27.3, 30.4, 32.4 and 33.9.
+It has y-axis 'disp' with labels 100, 200, 300 and 400.
+The chart is a boxplot comprised of 25 boxes with whiskers.
+> VI(qplot(data=m, mpg, geom=""histogram""))
+This is an untitled chart with no subtitle or caption.
+It has x-axis 'mpg' with labels 10, 15, 20, 25, 30 and 35.
+It has y-axis 'count' with labels 0, 1, 2, 3, 4 and 5.
+The chart is a bar chart containing 30 vertical bars.
+> VI(qplot(data=m, mapping=aes(yintercept=mpg), geom=""hline""))
+This is an untitled chart with no subtitle or caption.
+It has x-axis '' with labels .
+It has y-axis 'mpg' with labels 10, 15, 20, 25, 30 and 35.
+The chart is 32 horizontal lines.
+> VI(qplot(data=m, mpg, disp, geom=""smooth""))
+This is an untitled chart with no subtitle or caption.
+It has x-axis 'mpg' with labels 10, 15, 20, 25, 30 and 35.
+It has y-axis 'disp' with labels 0, 200 and 400.
+The chart is a smoothed curve using method 'auto' with confidence intervals.
+> 
+> # Test cases for different methods of providing data
+> x = 1:10
+> y = c(2,5,1,4,3,5,1,3,2,4)
+> z = as.factor(rep(c(""yes"",""no""),5))
+> df = data.frame(x,y,z)
+> # data frame provided to data param
+> VI(qplot(data=df, x=x, y=y, facets=.~z))
+This is an untitled chart with no subtitle or caption.
+The chart is comprised of 2 panels containing sub-charts, arranged horizontally.
+The panels represent different values of z.
+Each sub-chart has x-axis 'x' with labels 2.5, 5.0, 7.5 and 10.0.
+Each sub-chart has y-axis 'y' with labels 1, 2, 3, 4 and 5.
+Panel 1 represents data for z = no.
+Panel 1 is a set of 5 points.
+The points are at:
+(2, 5), 
+(4, 4), 
+(6, 5), 
+(8, 3) and 
+(10, 4)
+Panel 2 represents data for z = yes.
+Panel 2 is a set of 5 points.
+The points are at:
+(1, 2), 
+(3, 1), 
+(5, 3), 
+(7, 1) and 
+(9, 2)
+> # data frame provided to data param, function eval
+> VI(qplot(data=df, x=x*2, y=10-y, facets=.~z))
+This is an untitled chart with no subtitle or caption.
+The chart is comprised of 2 panels containing sub-charts, arranged horizontally.
+The panels represent different values of z.
+Each sub-chart has x-axis 'x * 2' with labels 5, 10, 15 and 20.
+Each sub-chart has y-axis '10 - y' with labels 5, 6, 7, 8 and 9.
+Panel 1 represents data for z = no.
+Panel 1 is a set of 5 points.
+The points are at:
+(4, 5), 
+(8, 6), 
+(12, 5), 
+(16, 7) and 
+(20, 6)
+Panel 2 represents data for z = yes.
+Panel 2 is a set of 5 points.
+The points are at:
+(2, 8), 
+(6, 9), 
+(10, 7), 
+(14, 9) and 
+(18, 8)
+> # No data param, data frame accessed directly
+> # Doesn't seem to be possible to facet this way
+> VI(qplot(x=df$x, y=df$y))
+This is an untitled chart with no subtitle or caption.
+It has x-axis 'df$x' with labels 2.5, 5.0, 7.5 and 10.0.
+It has y-axis 'df$y' with labels 1, 2, 3, 4 and 5.
+The chart is a set of 10 points.
+The points are at:
+(1, 2), 
+(2, 5), 
+(3, 1), 
+(4, 4), 
+(5, 3), 
+(6, 5), 
+(7, 1), 
+(8, 3), 
+(9, 2) and 
+(10, 4)
+> # No data param, data frame accessed directly, function eval
+> VI(qplot(x=df$x*2, y=10-df$y))
+This is an untitled chart with no subtitle or caption.
+It has x-axis 'df$x * 2' with labels 5, 10, 15 and 20.
+It has y-axis '10 - df$y' with labels 5, 6, 7, 8 and 9.
+The chart is a set of 10 points.
+The points are at:
+(2, 8), 
+(4, 5), 
+(6, 9), 
+(8, 6), 
+(10, 7), 
+(12, 5), 
+(14, 9), 
+(16, 7), 
+(18, 8) and 
+(20, 6)
+> # Separate vectors accessed directly
+> VI(qplot(x=x, y=y))
+This is an untitled chart with no subtitle or caption.
+It has x-axis 'x' with labels 2.5, 5.0, 7.5 and 10.0.
+It has y-axis 'y' with labels 1, 2, 3, 4 and 5.
+The chart is a set of 10 points.
+The points are at:
+(1, 2), 
+(2, 5), 
+(3, 1), 
+(4, 4), 
+(5, 3), 
+(6, 5), 
+(7, 1), 
+(8, 3), 
+(9, 2) and 
+(10, 4)
+> # Separate vectors accessed directly, function eval
+> VI(qplot(x=x*2, y=10-y))
+This is an untitled chart with no subtitle or caption.
+It has x-axis 'x * 2' with labels 5, 10, 15 and 20.
+It has y-axis '10 - y' with labels 5, 6, 7, 8 and 9.
+The chart is a set of 10 points.
+The points are at:
+(2, 8), 
+(4, 5), 
+(6, 9), 
+(8, 6), 
+(10, 7), 
+(12, 5), 
+(14, 9), 
+(16, 7), 
+(18, 8) and 
+(20, 6)
+> # Constants
+> VI(qplot(1:10,c(2,5,1,4,3,5,1,3,2,4)))
+This is an untitled chart with no subtitle or caption.
+It has x-axis '1:10' with labels 2.5, 5.0, 7.5 and 10.0.
+It has y-axis 'c(2, 5, 1, 4, 3, 5, 1, 3, 2, 4)' with labels 1, 2, 3, 4 and 5.
+The chart is a set of 10 points.
+The points are at:
+(1, 2), 
+(2, 5), 
+(3, 1), 
+(4, 4), 
+(5, 3), 
+(6, 5), 
+(7, 1), 
+(8, 3), 
+(9, 2) and 
+(10, 4)
+> 
+> proc.time()
+   user  system elapsed 
+   4.73    0.31    5.04 

---FILE: vignettes/qplot.Rmd---
@@ -12,7 +12,8 @@ output: knitr:::html_vignette
 N.B.  the commands here are either exact copies of the commands presented in Wickham (2009) or some minor alterations to them.    Notably, some code given in the book no longer works. This is given a `#!`    
 
 
-The `ggplot2` package has  a `summary` method that often but not always offers something to show that things have changed from one plot to another. I've kept the use of this command in as it shows where we need to look for more information and from where we ought to look for it.
+The `ggplot2` package has  a `summary` method that often but not always offers something to show that things have changed from one plot to another. Summary 
+commands are included below but commented out.
 
 ```{r GetLibraries}     
 library(BrailleR)   
@@ -23,14 +24,14 @@ dsmall = diamonds[1:100,]
 
 ```{r g1}     
 g1 = qplot(carat, price, data = diamonds)   
-summary(g1)   
+# summary(g1)   
 g1  
 VI(g1)  
 ```  
 
 ```{r g2}          
 g2 = qplot(carat, price, data = dsmall, colour = color)    
-summary(g2)   
+# summary(g2)   
 g2
 g2 %>% VI()   
 # to get the content of the graph to be printed we need:   
@@ -39,7 +40,7 @@ g2 %>% VI()
 
 ```{r g3}     
 g3 = qplot(carat, price, data = dsmall, shape = cut)    
-summary(g3)   
+# summary(g3)   
 g3
 VI(g3)   
 #class(g3)=""list""; g3   
@@ -48,15 +49,15 @@ VI(g3)
 ```{r g4}     
 # to get semi-transparent points   
 g4 = qplot(carat, price, data = diamonds, alpha = I(1/100))    
-summary(g4)   
+# summary(g4)   
 g4
 VI(g4)   
 ```  
 
 ```{r g5}     
 # to add a smoother (default is loess for n<1000)   
 g5 = qplot(carat, price, data = dsmall, geom = c(""point"", ""smooth""))    
-summary(g5)   
+# summary(g5)   
 g5
 VI(g5)   
 #! g5a = qplot(carat, price, data = dsmall, geom = c(""point"", ""smooth""), span = 1)    
@@ -68,76 +69,80 @@ library(splines)
 ```{r g6}     
 # continuous v categorical   
 g6 = qplot(color, price / carat, data = diamonds, geom = ""jitter"", alpha = I(1 / 50))    
-summary(g6)   
+# summary(g6)   
 g6
 VI(g6)   
 g6a = qplot(color, price / carat, data = diamonds, geom = ""boxplot"")    
-summary(g6a)   
+# summary(g6a)   
 g6a
 VI(g6a)   
 ```  
 
 ```{r g7}     
 # univariate plots   
 g7a = qplot(carat, data = diamonds, geom = ""histogram"")    
-summary(g7a)   
+# summary(g7a)   
 g7a
 VI(g7a)   
 g7b = qplot(carat, data = diamonds, geom = ""histogram"", binwidth = 1, xlim = c(0,3))    
-g7c = qplot(carat, data = diamonds, geom = ""histogram"", binwidth = 0.1, xlim = c(0,3))    
+g7b
+VI(g7b)   
+g7c = qplot(carat, data = diamonds, geom = ""histogram"", binwidth = 0.1, xlim = c(0,3))
+g7c
+VI(g7c)   
 g7d = qplot(carat, data = diamonds, geom = ""histogram"", binwidth = 0.01, xlim = c(0,3))    
-summary(g7d)   
+# summary(g7d)   
 g7d
 VI(g7d)   
 ```  
 
 ```{r g8}     
 g8 = qplot(carat, data = diamonds, geom = ""density"")    
-summary(g8)   
+# summary(g8)   
 g8
 VI(g8)   
 ```  
 
 ```{r g9}     
 # data is separated by implication using the following...   
 g9 = qplot(carat, data = diamonds, geom = ""density"", colour = color)    
-summary(g9)   
+# summary(g9)   
 g9
 VI(g9)   
 g10 = qplot(carat, data = diamonds, geom = ""histogram"", fill = color)    
-summary(g10)   
+# summary(g10)   
 g10
 VI(g10)   
 ```  
 
 ```{r g11}     
 # bar charts for categorical variable   
 g11a = qplot(color, data = diamonds)    
-summary(g11a)   
+# summary(g11a)   
 g11a
 VI(g11a)   
 g11b = qplot(color, data = diamonds, geom = ""bar"")    
-summary(g11b)   
+# summary(g11b)   
 g11b
 VI(g11b)   
 g12a = qplot(color, data = diamonds, geom = ""bar"", weight = carat)   
-summary(g12a)   
+# summary(g12a)   
 g12a
 VI(g12a)   
 g12b = qplot(color, data = diamonds, geom = ""bar"", weight = carat) + scale_y_continuous(""carat"")    
-summary(g12b)   
+# summary(g12b)   
 g12b
 VI(g12b)   
 ```  
 
 ```{r g13}     
 # time series plots   
 g13a = qplot(date, unemploy / pop, data = economics, geom = ""line"")    
-summary(g13a)   
+# summary(g13a)   
 g13a
 VI(g13a)   
 g13b = qplot(date, uempmed, data = economics, geom = ""line"")    
-summary(g13b)   
+# summary(g13b)   
 g13b
 VI(g13b)   
 ```  
@@ -146,7 +151,7 @@ VI(g13b)
 # path plots   
 year <- function(x) as.POSIXlt(x)$year + 1900    
 g14a = qplot(unemploy / pop, uempmed, data = economics, geom = c(""point"", ""path""))    
-summary(g14a)   
+# summary(g14a)   
 g14a
 VI(g14a)   
 #g14b = qplot(unemploy / pop, uempmed, data = economics, geom = ""path"", colour = year(date)) + scale_area()    
@@ -157,26 +162,27 @@ VI(g14a)
 ```{r g15}     
 # facets is the ggplot term for trellis' panels   
 g15a = qplot(carat, data = diamonds, facets = color ~ ., geom = ""histogram"", binwidth = 0.1, xlim = c(0, 3))    
-summary(g15a)   
+# summary(g15a)   
 g15a
 VI(g15a)   
 g15b = qplot(carat, ..density.., data = diamonds, facets = color ~ ., geom = ""histogram"", binwidth = 0.1, xlim = c(0, 3))   
-summary(g15b)   
+# summary(g15b)   
 g15b
 VI(g15b)   
 ```  
 
 ```{r g16}     
 # rescaling of the axes   
 g16 = qplot(carat, price, data = dsmall, log = ""xy"")   
-summary(g16)   
+# summary(g16)   
 g16
 VI(g16)   
 ```  
 
 ```{r g17}     
+# Facets syntax without a ""."" before the ""~"" causes grief
 g17 = qplot(displ, hwy, data=mpg, facets =~ year) + geom_smooth()    
-summary(g17)   
+# summary(g17)   
 g17
 VI(g17)   
 ```  "
ajrgodfrey,BrailleR,2a6c7b9356190802b09f966b10787553adfcbe85,Debra Warren,dwar068@aucklanduni.ac.nz,2017-07-14T22:51:38Z,Debra Warren,dwar068@aucklanduni.ac.nz,2017-07-14T22:51:38Z,"Correct computation of tick list in .GetAxisTicks

The function .GetAxisTicks in TextStrings.R was incorrectly computing
the list of ticks, sometimes causing an error condition and sometimes
just failing to report the full list of ticks correctly.",DESCRIPTION;R/TextStrings.R,False,True,True,False,4,3,7,"---FILE: DESCRIPTION---
@@ -5,7 +5,7 @@ Version: 0.27.0
 Date: 2017-06-29
 Author: A. Jonathan R. Godfrey [aut, cre], Donal Fitzpatrick [ctb], Duncan Murdoch [ctb], Greg Snow
     [ctb], Henrik Bengtsson [ctb], James Curtis [ctb], JooYoung Seo [ctb], Paul Murrell [ctb], Timothy Bilton [aut], Tony Hirst [ctb], Tsan-Kuang Lee [ctb], Volker Sorge [aut], Yihui Xie
-    [ctb]
+    [ctb], Debra Waren [ctb]
 Maintainer: A. Jonathan R. Godfrey <a.j.godfrey@massey.ac.nz>
 Authors@R: c(person(""A. Jonathan R."", ""Godfrey"", role=c(""aut"", ""cre""), email=""a.j.godfrey@massey.ac.nz""),
     person(""Donal"", ""Fitzpatrick"", email = ""donal.fitzpatrick@dcu.ie"", role = ""ctb""),
@@ -19,7 +19,8 @@ Authors@R: c(person(""A. Jonathan R."", ""Godfrey"", role=c(""aut"", ""cre""), email=""a.
     person(""Tony"", ""Hirst"", email = ""tony.hirst@open.ac.uk"", role = ""ctb""),
     person(""Tsan-Kuang"", ""Lee"", email = ""developer@tklee.com"", role = ""ctb""),
     person(""Volker"", ""Sorge"", email = ""v.sorge@mathjax.org"", role = ""aut""),
-    person(""Yihui"", ""Xie"", email = ""xie@yihui.name"", role = ""ctb""))
+    person(""Yihui"", ""Xie"", email = ""xie@yihui.name"", role = ""ctb""),
+    person(""Debra"", ""Warren"", email = ""dwar068@aucklanduni.ac.nz"", role = ""ctb""))
 Description: Blind users do not have access to the graphical output from R
     without printing the content of graphics windows to an embosser of some kind. This
     is not as immediate as is required for efficient access to statistical output.

---FILE: R/TextStrings.R---
@@ -35,7 +35,7 @@ return(invisible(list(Short=ShortText, Long=LongText)))
       A = x[1]
       B = x[2]
       Ticks = x[3]
-      paste(paste0(seq(A, B - Ticks, (B - A) / Ticks), "","", collapse = "" ""),
+      paste(paste0(seq(A, B - (B - A)/Ticks, (B - A) / Ticks), "","", collapse = "" ""),
             ""and"", B, collapse = "" "")
     }
 "
ajrgodfrey,BrailleR,45ed36bb4443290971df689e4e56717a538acf3d,ajrgodfrey,a.j.godfrey@massey.ac.nz,2017-05-11T09:16:57Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2017-05-11T09:16:57Z,changes for v0.25.7 (fixing scatter and fitted line plots),R/Augment.R;man/TSPlot.Rd;vignettes/BrailleRHistory.rmd;vignettes/WriteROptions,True,True,True,False,13,12,25,"---FILE: R/Augment.R---
@@ -153,10 +153,10 @@ Augment.tsplot =
 
 
 .AugmentBase = function(x){
-    x$xaxp = par()$xaxp
-    x$yaxp = par()$yaxp
-    x$xTicks = seq(x$xaxp[1], x$xaxp[2], length.out=x$xaxp[3]+1)
-    x$yTicks = seq(x$yaxp[1], x$yaxp[2], length.out=x$yaxp[3]+1)
+    x$par$xaxp = par()$xaxp
+    x$par$yaxp = par()$yaxp
+    x$xTicks = seq(x$par$xaxp[1], x$par$xaxp[2], length.out=x$par$xaxp[3]+1)
+    x$yTicks = seq(x$par$yaxp[1], x$par$yaxp[2], length.out=x$par$yaxp[3]+1)
     x$ExtraArgs$main <- if (is.null(x$ExtraArgs$main)) {""""} else {x$ExtraArgs$main}
     x$ExtraArgs$sub <- if (is.null(x$ExtraArgs$sub)) {""""} else {x$ExtraArgs$sub}
     x$ExtraArgs$xlab <- if (is.null(x$ExtraArgs$xlab)) {""""} else {x$ExtraArgs$xlab}

---FILE: man/TSPlot.Rd---
@@ -29,13 +29,10 @@ op = par(mfcol=c(3,2))
 plot(as.ts(Wind), ylab=""Wind"", col=4)
 test1 = TimeSeriesPlot(Wind, col=4)
 test1 #does the plot method work?
-plot(as.ts(Ozone), ylab=""Ozone"", lty=3)
-test2 = TimeSeriesPlot(Ozone, lty=3)
-test2 #does the plot method work?
+plot(as.ts(Ozone), ylab=""Ozone"")
+test2 = TimeSeriesPlot(Ozone)
+test2 # does the plot method work?
 par(op)
 detach(airquality)
 rm(test1); rm(test2); rm(op)
 }
-
-
-

---FILE: vignettes/BrailleRHistory.rmd---
@@ -91,9 +91,9 @@ University event in 2013. This gave me the first opportunity to
 put the package in front of an audience that I hope will gain from the
 package's existence. 
 
-I've already mentioned the following contributors above:Paul Murrell, Yihui Xie, Timothy Bilton, and James Curtis.
+I've already mentioned the following contributors above:Paul Murrell, Yihui Xie, Timothy Bilton, and James Curtis. In December 2016, I was visiting Donal Fitzpatrick at Dublin City University and we were joined by Volker Sorge for a few days. Volker's work in creating an accessible tool for explorationof chemical molecules is being broadened into statistical graphs.
 
-I also need to acknowledge the value of attending the Summer University events.  I gain so much from my interactions with the students who attend, the other workshop leaders twho give me feedback, and the other professionals who assist blind students in their own countries.
+I also need to acknowledge the value of attending the Summer University events.  I gain so much from my interactions with the students who attend, the other workshop leaders who gave me feedback, and the other professionals who assist blind students in their own countries.
  
 
 

---FILE: vignettes/WriteROptions---
@@ -0,0 +1,4 @@
+RDirectory: C:\Program Files\R\R-devel\bin\x64\Rscript.exe
+filename: BrailleRHistory.rmd
+lastdir: C:\Users\ajgodfre\Documents\Research\BrailleR\PackageFiles\vignettes
+newText: Use WriteR to edit your R markdown files, perhaps by starting from a template file"
ajrgodfrey,BrailleR,615e94d8ee4cf0126e5f6812dcdba9248eb72de7,ajrgodfrey,a.j.godfrey@massey.ac.nz,2017-05-11T08:51:05Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2017-05-11T08:51:05Z,changes for v0.25.7 (fixing scatter and fitted line plots),R/AddXMLMethod.R;R/Augment.R;R/ScatterPlot.R;R/VIMethod1_JG.R;README.md;inst/NEWS;man/ScatterPlot.Rd;man/TSPlot.Rd;man/boxplot.Rd;man/dotplot.Rd;man/hist.Rd,False,True,True,False,106,102,208,"---FILE: R/AddXMLMethod.R---
@@ -12,7 +12,7 @@ AddXML.boxplot = function(x, file) {
     root = XML::xmlRoot(doc)
     annotations = .AddXMLAddNode(root, ""annotations"")
 
-    title = .AddXMLAddTitle(annotations, title=x$main)
+    title = .AddXMLAddTitle(annotations, title=x$ExtraArgs$main)
 
     if (x$horizontal) {
       xValues <- x$xTicks
@@ -26,23 +26,23 @@ AddXML.boxplot = function(x, file) {
       YMax = max(yValues)
     }
     if (x$horizontal) {
-      xSpeech <- paste(""x axis"", x$xlab, ""ranges from"", YMin, ""to"", YMax)
+      xSpeech <- paste(""x axis"", x$ExtraArgs$xlab, ""ranges from"", YMin, ""to"", YMax)
       ySpeech <- paste(""y axis with values"", paste(yValues, collapse="", ""))
     } else {
       xSpeech <- paste(""x axis with values"", paste(xValues, collapse="", ""))
-      ySpeech <- paste(""y axis"", x$ylab, ""ranges from"", YMin, ""to"", YMax)
+      ySpeech <- paste(""y axis"", x$ExtraArgs$ylab, ""ranges from"", YMin, ""to"", YMax)
     }
 
 
-    xAxis = .AddXMLAddXAxis(annotations, label=x$xlab, values=xValues, speechLong=xSpeech)
+    xAxis = .AddXMLAddXAxis(annotations, label=x$ExtraArgs$xlab, values=xValues, speechLong=xSpeech)
 
-    yAxis = .AddXMLAddYAxis(annotations, label=x$ylab, values=yValues, speechLong=ySpeech)
+    yAxis = .AddXMLAddYAxis(annotations, label=x$ExtraArgs$ylab, values=yValues, speechLong=ySpeech)
 
     center = .AddXMLAddBoxplotCenter(annotations,boxplot=x)
 
     chart <- .AddXMLAddChart(annotations, type=""BoxPlot"",
-                    speech=paste(x$Boxplots, ""for"", x$main),
-                    speech2=paste(x$Boxplots, ""for"", x$xlab, paste(x$names, collapse="", "")),
+                    speech=paste(x$Boxplots, ""for"", x$ExtraArgs$main),
+                    speech2=paste(x$Boxplots, ""for"", x$ExtraArgs$xlab, paste(x$names, collapse="", "")),
                     children=list(title, xAxis, yAxis, center))
     .AddXMLAddComponents(chart, list(title, xAxis, yAxis, center))
     XML::saveXML(doc=doc, file=file)
@@ -54,8 +54,8 @@ AddXML.dotplot = function(x, file) {
     doc = .AddXMLDocument(""dotplot"")
     root = XML::xmlRoot(doc)
     annotations = .AddXMLAddNode(root, ""annotations"")
-    .AddXMLAddXAxis(annotations, label=x$xlab)
-    .AddXMLAddYAxis(annotations, label=x$ylab)
+    .AddXMLAddXAxis(annotations, label=x$ExtraArgs$xlab)
+    .AddXMLAddYAxis(annotations, label=x$ExtraArgs$ylab)
     XML::saveXML(doc=doc, file=file)
     return(invisible(NULL))
 }
@@ -73,8 +73,8 @@ AddXML.ggplot = function(x, file) {
     doc = .AddXMLDocument(""ggplot"")
     root = XML::xmlRoot(doc)
     annotations = .AddXMLAddNode(root, ""annotations"")
-    .AddXMLAddXAxis(annotations, label=x$xlab)
-    .AddXMLAddYAxis(annotations, label=x$ylab)
+    .AddXMLAddXAxis(annotations, label=x$ExtraArgs$xlab)
+    .AddXMLAddYAxis(annotations, label=x$ExtraArgs$ylab)
 
     XML::saveXML(doc=doc, file=file)
     return(invisible(NULL))
@@ -86,31 +86,31 @@ AddXML.histogram = function(x, file) {
     annotations = .AddXMLAddNode(root, ""annotations"")
 
 # still need to allow for main and sub titles
-    title = .AddXMLAddTitle(annotations, title=x$main)
+    title = .AddXMLAddTitle(annotations, title=x$ExtraArgs$main)
 
     xValues <- x$xTicks
     XMax = max(x$breaks, x$xTicks)
-    xAxis = .AddXMLAddXAxis(annotations, label=x$xlab, values=xValues,
-                            speechLong=paste(""x axis"", x$xlab, ""ranges from 0 to"", XMax))
+    xAxis = .AddXMLAddXAxis(annotations, label=x$ExtraArgs$xlab, values=xValues,
+                            speechLong=paste(""x axis"", x$ExtraArgs$xlab, ""ranges from 0 to"", XMax))
 
     AboveY = x$yTicks
     for(i in 1:length(x$yTicks)){
         AboveY[i] = length(x$counts[x$counts > x$yTicks[i] ])
     }
     yValues <- x$yTicks
-    DetYValues <- paste(AboveY, ""of the"", x$NBars, ""bars exceed the"", x$ylab, x$yTicks)
+    DetYValues <- paste(AboveY, ""of the"", x$NBars, ""bars exceed the"", x$ExtraArgs$ylab, x$yTicks)
     YMax = max(x$counts, x$yTicks)
-    yAxis = .AddXMLAddYAxis(annotations, label=x$ylab,
+    yAxis = .AddXMLAddYAxis(annotations, label=x$ExtraArgs$ylab,
                             values=yValues, detailedValues=DetYValues,
-                            speechLong=paste(""y axis"", x$ylab, ""ranges from 0 to"", YMax))
+                            speechLong=paste(""y axis"", x$ExtraArgs$ylab, ""ranges from 0 to"", YMax))
 
     center = .AddXMLAddHistogramCenter(annotations,hist=x)
 
     chart <- .AddXMLAddChart(annotations, type=""Histogram"",
-                    speech=paste(""Histogram of"", x$xlab),
+                    speech=paste(""Histogram of"", x$ExtraArgs$xlab),
                     speech2=paste(""Histogram showing "", x$NBars, ""bars for "",
-                                  x$xlab, ""over the range"", min(x$breaks),  
-                                  ""to"",max(x$breaks), ""and"", x$ylab,
+                                  x$ExtraArgs$xlab, ""over the range"", min(x$breaks),  
+                                  ""to"",max(x$breaks), ""and"", x$ExtraArgs$ylab,
                                   ""from 0 to"", max(x$counts)), # must allow for density
                     children=list(title, xAxis, yAxis, center))
     .AddXMLAddComponents(chart, list(title, xAxis, yAxis, center))
@@ -125,30 +125,30 @@ AddXML.tsplot = function(x, file) {
     annotations = .AddXMLAddNode(root, ""annotations"")
 
 # still need to allow for main and sub titles
-    title = .AddXMLAddTitle(annotations, title=x$main)
+    title = .AddXMLAddTitle(annotations, title=x$ExtraArgs$main)
 
     xValues <- x$xTicks
     XMin = min(x$xTicks)
     XMax = max(x$xTicks)
     xAxis = .AddXMLAddXAxis(
-        annotations, label=x$xlab, values=xValues,
-        speechLong=paste(""x axis"", x$xlab, ""ranges from"", XMin, ""to"", XMax))
+        annotations, label=x$ExtraArgs$xlab, values=xValues,
+        speechLong=paste(""x axis"", x$ExtraArgs$xlab, ""ranges from"", XMin, ""to"", XMax))
 
    yValues <- x$yTicks
     YMin = min(x$yTicks)
     YMax = max(x$yTicks)
     yAxis = .AddXMLAddYAxis(
-        annotations, label=x$ylab, values=yValues,
-        speechLong=paste(""y axis"", x$ylab, ""ranges from"", YMin, ""to"", YMax))
+        annotations, label=x$ExtraArgs$ylab, values=yValues,
+        speechLong=paste(""y axis"", x$ExtraArgs$ylab, ""ranges from"", YMin, ""to"", YMax))
 
     ## now to add the other content related bits
     center = .AddXMLAddTimeseriesCenter(annotations,ts=x)
 
     chart <- .AddXMLAddChart(annotations, type=""TimeSeriesPlot"",
-                    speech=paste(""Time series plot of"", x$ylab),
+                    speech=paste(""Time series plot of"", x$ExtraArgs$ylab),
                     speech2=paste(""Time series plot showing "",
-                                  x$ylab, ""over the range"", YMin,
-                                  ""to"", YMax,  ""for"", x$ylab,
+                                  x$ExtraArgs$ylab, ""over the range"", YMin,
+                                  ""to"", YMax,  ""for"", x$ExtraArgs$ylab,
                                   ""which ranges from"", XMin,  ""to"", XMax), 
                     children=list(title, xAxis, yAxis, center))
     .AddXMLAddComponents(chart, list(title, xAxis, yAxis, center))

---FILE: R/Augment.R---
@@ -60,9 +60,9 @@ return(invisible(x))
 
 
 Augment.histogram = function(x) {
-    x$main <- if (is.null(x$main)) {paste(""Histogram of"", x$xname)} else {x$main}
-    x$xlab <- if (is.null(x$xlab)) {x$xname} else {x$xlab}
-    x$ylab <- if (is.null(x$ylab)) {""Frequency""} else {x$ylab}
+    x$ExtraArgs$main <- if (is.null(x$ExtraArgs$main)) {paste(""Histogram of"", x$xname)} else {x$ExtraArgs$main}
+    x$ExtraArgs$xlab <- if (is.null(x$ExtraArgs$xlab)) {x$xname} else {x$ExtraArgs$xlab}
+    x$ExtraArgs$ylab <- if (is.null(x$ExtraArgs$ylab)) {""Frequency""} else {x$ExtraArgs$ylab}
     x$NBars = length(x$counts)
     x=.AugmentBase(x)
 return(invisible(x))
@@ -99,7 +99,7 @@ NBreaks= 6 #specified as something from 6 to 10 depending on how many obs there
 
 Augment.tsplot = 
   function(x) {
-    x$xlab <- if (is.null(x$xlab)) {""Time""} else {x$xlab}
+    x$ExtraArgs$xlab <- if (is.null(x$ExtraArgs$xlab)) {""Time""} else {x$ExtraArgs$xlab}
     x=.AugmentBase(x)
     series =x [[1]]
     if (is.na(match(NA, series))) {
@@ -157,10 +157,10 @@ Augment.tsplot =
     x$yaxp = par()$yaxp
     x$xTicks = seq(x$xaxp[1], x$xaxp[2], length.out=x$xaxp[3]+1)
     x$yTicks = seq(x$yaxp[1], x$yaxp[2], length.out=x$yaxp[3]+1)
-    x$main <- if (is.null(x$main)) {""""} else {x$main}
-    x$sub <- if (is.null(x$sub)) {""""} else {x$sub}
-    x$xlab <- if (is.null(x$xlab)) {""""} else {x$xlab}
-    x$ylab <- if (is.null(x$ylab)) {""""} else {x$ylab}
+    x$ExtraArgs$main <- if (is.null(x$ExtraArgs$main)) {""""} else {x$ExtraArgs$main}
+    x$ExtraArgs$sub <- if (is.null(x$ExtraArgs$sub)) {""""} else {x$ExtraArgs$sub}
+    x$ExtraArgs$xlab <- if (is.null(x$ExtraArgs$xlab)) {""""} else {x$ExtraArgs$xlab}
+    x$ExtraArgs$ylab <- if (is.null(x$ExtraArgs$ylab)) {""""} else {x$ExtraArgs$ylab}
       class(x)=c(""Augmented"", class(x))
       return(invisible(x))
       }

---FILE: R/ScatterPlot.R---
@@ -24,16 +24,14 @@ FittedLinePlot = function(x, y, line.col=2, ...){
     Out = list()
     Out$data = .CleanData4TwoWayPlot(x, y)
     Out$fittedline = list(coef = coef(lm(y~x, data=Out$data)),
-             col = line.col)
+                    col = line.col)
     Out$ExtraArgs  = .GrabExtraArgs(MC)
     Out$ExtraArgs$xlab  = MC$xlab = ifelse(is.null(MC$xlab), as.character(MC$x), MC$xlab)
     Out$ExtraArgs$ylab  =     MC$ylab= ifelse(is.null(MC$ylab), as.character(MC$y), MC$ylab)
     Out = .checkTextLabels(MC, Out)
-    MC[[1L]] <- quote(graphics::plot)
     MC$x <- Out$data$x
     MC$y <- Out$data$y
     MC$line.col=NULL
-#    Out$graph <- eval(MC, envir=parent.frame())
     Out$graph <- do.call(graphics::plot, as.list(MC[-1]))
     Out$par = par()
     class(Out) = c(""fittedlineplot"", ""scatterplot"")
@@ -43,41 +41,19 @@ FittedLinePlot = function(x, y, line.col=2, ...){
 }
 
 
-.CleanData4TwoWayPlot = function(x, y){
-    Ord = order(x,y)
-return(invisible(na.omit(data.frame(x=x[Ord], y=y[Ord]))))
-}
-
-
-.checkTextLabels = function(MC, Out){
-    if (length(MC$main) > 0) Out$ExtraArgs$main = as.character(MC$main) else {Out$ExtraArgs$main = """"}
-    if (length(MC$sub) > 0) Out$ExtraArgs$sub = as.character(MC$sub)
-    if (length(MC$xlab) > 0) Out$ExtraArgs$xlab = as.character(MC$xlab)
-    if (length(MC$ylab) > 0) Out$ExtraArgs$ylab = as.character(MC$ylab)
-    return(invisible(Out))
-}
-
-plot.scatterplot = function(x, ...){
-x$x= x$data$x
-x$y = x$data$y
- Pars = x$ExtraArgs
-x = .RemoveExtraGraphPars(x)
-suppressWarnings(do.call(plot, c(x, Pars)))
-return(invisible(NULL))
-}
-
 
 plot.fittedlineplot = function(x, ...){
-x$x= x$data$x
-x$y = x$data$y
-Pars=x$ExtraPars
-fitline = x$fittedline
-x = .RemoveExtraGraphPars(x)
-suppressWarnings(do.call(plot, c(x, Pars)))
-    do.call(abline, fitline)
-return(invisible(NULL))
+    x$x= x$data$x
+    x$y = x$data$y
+    Pars=x$ExtraArgs
+  if(any(class(x) == ""fittedlineplot"")) fitline = x$fittedline
+    x = .RemoveExtraGraphPars(x)
+    suppressWarnings(do.call(plot, c(x, Pars)))
+  if(any(class(x) == ""fittedlineplot"")) do.call(abline, fitline)
+    return(invisible(NULL))
 }
 
+plot.scatterplot = plot.fittedlineplot
 print.fittedlineplot = plot.fittedlineplot
 print.scatterplot = plot.scatterplot
 
@@ -91,7 +67,24 @@ return(invisible(x2))
 }
 
 .GrabExtraArgs = function(x){
-ToRemove = c("""", ""x"", ""y"", ""main"", ""xlab"", ""ylab"", ""sub"", ""line.col"")
-ExtraArgs = as.list(x[setdiff(names(x), ToRemove)])
-return(invisible(ExtraArgs))
+    ToRemove = c("""", ""x"", ""y"", ""main"", ""xlab"", ""ylab"", ""sub"", ""line.col"")
+    ExtraArgs = as.list(x[setdiff(names(x), ToRemove)])
+    return(invisible(ExtraArgs))
 }
+
+
+.CleanData4TwoWayPlot = function(x, y){
+    Ord = order(x,y)
+return(invisible(na.omit(data.frame(x=x[Ord], y=y[Ord]))))
+}
+
+
+.checkTextLabels = function(MC, Out){
+    if (length(MC$main) > 0) Out$ExtraArgs$main = as.character(MC$main) else {Out$ExtraArgs$main = """"}
+    if (length(MC$sub) > 0) Out$ExtraArgs$sub = as.character(MC$sub)
+    if (length(MC$xlab) > 0) Out$ExtraArgs$xlab = as.character(MC$xlab)
+    if (length(MC$ylab) > 0) Out$ExtraArgs$ylab = as.character(MC$ylab)
+    return(invisible(Out))
+}
+
+

---FILE: R/VIMethod1_JG.R---
@@ -17,16 +17,16 @@ VI.boxplot =
 x=Augment(x)
       cat(paste0(
               'This graph has ', x$Boxplots, ' printed ', x$VertHorz,
-              '\n', ifelse(length(x$main) > 0, 'with the title: ',
-                           'but has no title'), x$main, '\n',
-              ifelse(length(x$xlab) > 0, InQuotes(x$xlab), 'No label'),
+              '\n', ifelse(length(x$ExtraArgs$main) > 0, 'with the title: ',
+                           'but has no title'), x$ExtraArgs$main, '\n',
+              ifelse(length(x$ExtraArgs$xlab) > 0, InQuotes(x$ExtraArgs$xlab), 'No label'),
               ' appears on the x-axis.\n',
-              ifelse(length(x$ylab) > 0, paste0('""', x$ylab, '""'), 'No label'),
+              ifelse(length(x$ExtraArgs$ylab) > 0, paste0('""', x$ExtraArgs$ylab, '""'), 'No label'),
               ' appears on the y-axis.\n'))
       if (x$horizontal) {
-        cat(""Tick marks for the x-axis are at:"", .GetAxisTicks(x$xaxp), ""\n"")
+        cat(""Tick marks for the x-axis are at:"", .GetAxisTicks(x$par$xaxp), ""\n"")
       } else {
-        cat(""Tick marks for the y-axis are at:"", .GetAxisTicks(x$yaxp), ""\n"")
+        cat(""Tick marks for the y-axis are at:"", .GetAxisTicks(x$par$yaxp), ""\n"")
       }
       for (i in 1:x$NBox) {
         cat(x$VarGroupUpp, x$names[i], 'has', x$n[i], 'values.\n')
@@ -76,21 +76,21 @@ VI.dotplot =
       Cuts = seq(MinVal, MaxVal, (MaxVal - MinVal) / Bins)
       # now do the description bit
       cat(paste0('This graph has ', x$dotplots, ' printed ', x$VertHorz, '\n',
-                 ifelse(length(x$main) > 0, 'with the title: ',
-                        'but has no title'), x$main, '\n'))
-      if (!is.null(x$dlab) | !is.null(x$glab)) {
+                 ifelse(length(x$ExtraArgs$main) > 0, 'with the title: ',
+                        'but has no title'), x$ExtraArgs$main, '\n'))
+      if (!is.null(x$ExtraArgs$dlab) | !is.null(x$ExtraArgs$glab)) {
         warning(
             ""Use of dlab or glab arguments is not advised. Use xlab and ylab instead."")
       } else {
-        cat(paste0(ifelse(length(x$xlab) > 0, InQuotes(x$xlab), 'No label'),
+        cat(paste0(ifelse(length(x$ExtraArgs$xlab) > 0, InQuotes(x$ExtraArgs$xlab), 'No label'),
                    ' appears on the x-axis.\n',
-                   ifelse(length(x$ylab) > 0, paste0('""', x$ylab, '""'),
+                   ifelse(length(x$ExtraArgs$ylab) > 0, paste0('""', x$ExtraArgs$ylab, '""'),
                           'No label'), ' appears on the y-axis.\n'))
       }
       if (x$vertical) {
-        cat(""Tick marks for the y-axis are at:"", .GetAxisTicks(x$yaxp), ""\n"")
+        cat(""Tick marks for the y-axis are at:"", .GetAxisTicks(x$par$yaxp), ""\n"")
       } else {
-        cat(""Tick marks for the x-axis are at:"", .GetAxisTicks(x$xaxp), ""\n"")
+        cat(""Tick marks for the x-axis are at:"", .GetAxisTicks(x$par$xaxp), ""\n"")
       }
       cat(paste(""the data that range from"", MinVal, ""to"", MaxVal,
                 ""has been broken into"", Bins, ""bins.\nThe counts are:\n""))
@@ -106,13 +106,13 @@ VI.dotplot =
 VI.histogram =
     function(x, ...) {
       cat(paste0('This is a histogram, with the title: ',
-          ifelse(length(x$main) > 0, x$main, paste(""Histogram of"", x$xname)),
-          '\n', ifelse(length(x$xlab) > 0, InQuotes(x$xlab), InQuotes(x$xname)),
+          ifelse(length(x$ExtraArgs$main) > 0, x$ExtraArgs$main, paste(""Histogram of"", x$xname)),
+          '\n', ifelse(length(x$ExtraArgs$xlab) > 0, InQuotes(x$ExtraArgs$xlab), InQuotes(x$xname)),
           ' is marked on the x-axis.\n'))
-      cat(""Tick marks for the x-axis are at:"", .GetAxisTicks(x$xaxp), ""\n"")
+      cat(""Tick marks for the x-axis are at:"", .GetAxisTicks(x$par$xaxp), ""\n"")
       cat('There are a total of', sum(x$counts),
           'elements for this variable.\n')
-      cat(""Tick marks for the y-axis are at:"", .GetAxisTicks(x$yaxp), ""\n"")
+      cat(""Tick marks for the y-axis are at:"", .GetAxisTicks(x$par$yaxp), ""\n"")
       NoBins = length(x$breaks) - 1
       if (x$equidist) {
         cat('It has', NoBins, 'bins with equal widths, starting at',

---FILE: README.md---
@@ -25,7 +25,8 @@ Any assistance to fill in the numerous gaps in what BrailleR delivers will be mo
 
 Some issues to resolve:
 
-1. storing the graphical parameters in ScatterPlot() etc. does not get the right ones slected. Need to replace this by somehow keeping the ... arguments supplie by the user. Tested using col and pch in FittedLinePlot()
+1. storing the graphical parameters in ScatterPlot() etc. does not necessarily get the right ones slected. Need to replace this by somehow keeping the ... arguments supplied by the user. Tested using col and pch in FittedLinePlot()
+2. Get extra bits of information for WTF() coming through, such as other shapes, lines etc.
 1. get VI.ggplot() doing more; see vignette
 2. get more graphics ready for making into SVG for use on Tiger products; mostly in SVGThis() method
 3. Get more Graph types working with the additional XML to make them interactive.

---FILE: inst/NEWS---
@@ -5,6 +5,7 @@
 - JG implemented the ViewSVG() so that anyone can use the interactive graph viewing system; required various internal functions to move and write necessary files 
 - added FittedLinePlot() which adds a fitted line to the ScatterPlot() implmented through ScatterPlot(); these use a few internal functions, found in ScatterPlot.R
 - added plot and print methods for various graph types. The print method refers to the plot function so acts just like the ggplot and lattice packages.
+- restructured the storage of graph parameters and arguments for a variety of the masked functions. The intention is to make cleaning things up easier.
 
 # v0.25.6
 - working on accessible Venn diagrams and time series plots

---FILE: man/ScatterPlot.Rd---
@@ -27,13 +27,16 @@ An object of class scatterplot of fittedlineplot, with the addition of any calls
 
 \examples{
 attach(airquality)
-op = par(mfcol=c(2,2))
+op = par(mfcol=c(3,2))
 plot(Wind, Ozone, pch=4)
-ScatterPlot(Wind, Ozone, pch=4)
+test1 = ScatterPlot(Wind, Ozone, pch=4)
+test1 #does the plot method work?
 plot(Wind, Ozone)
 abline(coef(lm(Ozone~Wind)), col=4)
-FittedLinePlot(Wind, Ozone, line.col=4)
+test2 = FittedLinePlot(Wind, Ozone, line.col=4)
+test2 #does the plot method work?
 par(op)
 detach(airquality)
+rm(test1); rm(test2); rm(op)
 }
 

---FILE: man/TSPlot.Rd---
@@ -23,5 +23,19 @@ Godfrey, A.J.R. (2013) \sQuote{Statistical Software from a Blind Person's Perspe
 \author{
 A. Jonathan R. Godfrey
 }
+\examples{
+attach(airquality)
+op = par(mfcol=c(3,2))
+plot(as.ts(Wind), ylab=""Wind"", col=4)
+test1 = TimeSeriesPlot(Wind, col=4)
+test1 #does the plot method work?
+plot(as.ts(Ozone), ylab=""Ozone"", lty=3)
+test2 = TimeSeriesPlot(Ozone, lty=3)
+test2 #does the plot method work?
+par(op)
+detach(airquality)
+rm(test1); rm(test2); rm(op)
+}
+
 
 

---FILE: man/boxplot.Rd---
@@ -49,7 +49,3 @@ MyBoxplot
 # The VI() method then uses the extra information stored
 VI(MyBoxplot)
 }
-% Add one or more standard keywords, see file 'KEYWORDS' in the
-% R documentation directory.
-\keyword{ ~kwd1 }
-\keyword{ ~kwd2 }% __ONLY ONE__ keyword per line

---FILE: man/dotplot.Rd---
@@ -24,5 +24,3 @@ This function is dependent on the \code{\link[graphics]{stripchart}} function fr
 \examples{
 VI(with(airquality, dotplot(Ozone~Month)))
 }
-\keyword{ ~kwd1 }
-\keyword{ ~kwd2 }% __ONLY ONE__ keyword per line

---FILE: man/hist.Rd---
@@ -40,5 +40,3 @@ MyHist
 # The VI() method then uses the extra information stored
 VI(MyHist)
 }
-\keyword{ ~kwd1 }
-\keyword{ ~kwd2 }% __ONLY ONE__ keyword per line"
ajrgodfrey,BrailleR,984e5aaa6cc208fedf54ea1bc1dea588998cd81a,ajrgodfrey,a.j.godfrey@massey.ac.nz,2017-05-11T01:18:36Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2017-05-11T01:18:36Z,changes for v0.25.7 (fixing scatter and fitted line plots),R/ScatterPlot.R;man/ScatterPlot.Rd,False,True,True,False,28,15,43,"---FILE: R/ScatterPlot.R---
@@ -4,16 +4,16 @@ ScatterPlot = function(x, y=NULL, ...){
     MC <- match.call(expand.dots = TRUE)
     Out = list()
     Out$data = .CleanData4TwoWayPlot(x, y)
-    MC$xlab= ifelse(is.null(MC$xlab), as.character(MC$x), MC$xlab)
-    MC$ylab= ifelse(is.null(MC$ylab), as.character(MC$y), MC$ylab)
+    Out$ExtraArgs  = .GrabExtraArgs(MC)
+    Out$ExtraArgs$xlab =     MC$xlab= ifelse(is.null(MC$xlab), as.character(MC$x), MC$xlab)
+    Out$ExtraArgs$ylab =     MC$ylab= ifelse(is.null(MC$ylab), as.character(MC$y), MC$ylab)
+    Out = .checkTextLabels(MC, Out)
     MC[[1L]] <- quote(graphics::plot)
     MC$x <- Out$data$x
     MC$y <- Out$data$y
     Out$graph <- eval(MC, envir=parent.frame())
-    Out$ExtraArgs  = .GrabExtraArgs(MC)
     Out$par = par()
     class(Out) = ""scatterplot""
-    Out = .checkTextLabels(MC, Out)
     Out=Augment(Out)
     return(invisible(Out))
 }
@@ -23,20 +23,22 @@ FittedLinePlot = function(x, y, line.col=2, ...){
     MC <- match.call(expand.dots = TRUE)
     Out = list()
     Out$data = .CleanData4TwoWayPlot(x, y)
-    MC$xlab= ifelse(is.null(MC$xlab), as.character(MC$x), MC$xlab)
-    MC$ylab= ifelse(is.null(MC$ylab), as.character(MC$y), MC$ylab)
+    Out$fittedline = list(coef = coef(lm(y~x, data=Out$data)),
+             col = line.col)
+    Out$ExtraArgs  = .GrabExtraArgs(MC)
+    Out$ExtraArgs$xlab  = MC$xlab = ifelse(is.null(MC$xlab), as.character(MC$x), MC$xlab)
+    Out$ExtraArgs$ylab  =     MC$ylab= ifelse(is.null(MC$ylab), as.character(MC$y), MC$ylab)
+    Out = .checkTextLabels(MC, Out)
     MC[[1L]] <- quote(graphics::plot)
     MC$x <- Out$data$x
     MC$y <- Out$data$y
-    Out$graph <- eval(MC, envir=parent.frame())
-    Out$ExtraArgs  = .GrabExtraArgs(MC)
+    MC$line.col=NULL
+#    Out$graph <- eval(MC, envir=parent.frame())
+    Out$graph <- do.call(graphics::plot, as.list(MC[-1]))
     Out$par = par()
     class(Out) = c(""fittedlineplot"", ""scatterplot"")
-    Out = .checkTextLabels(MC, Out)
     Out=Augment(Out)
-    Out$fittedline$coef = coef(lm(y~x, data=Out$data))
-    Out$fittedline$col = line.col
-    abline(Out$fittedline$coef, col=line.col)
+    do.call(abline, Out$fittedline)
     return(invisible(Out))
 }
 
@@ -72,15 +74,15 @@ Pars=x$ExtraPars
 fitline = x$fittedline
 x = .RemoveExtraGraphPars(x)
 suppressWarnings(do.call(plot, c(x, Pars)))
-    abline(fitline$coef, col=fitline$col)
+    do.call(abline, fitline)
 return(invisible(NULL))
 }
 
 print.fittedlineplot = plot.fittedlineplot
 print.scatterplot = plot.scatterplot
 
 .RemoveExtraGraphPars = function(x){
-ToRemoveBrailleRBits = c(""xTicks"", ""yTicks"", ""par"", ""GroupSummaries"", ""Continuous"", ""coef"", ""data"", ""fittedline"", ""main"", ""sub"", ""xlab"", ""ylab"", ""ExtraArgs"")
+ToRemoveBrailleRBits = c(""xTicks"", ""yTicks"", ""par"", ""GroupSummaries"", ""Continuous"", ""coef"", ""data"", ""fittedline"", ""main"", ""sub"", ""xlab"", ""ylab"", ""ExtraArgs"", ""line.col"")
 ToRemoveBasePar = c(""cin"", ""cra"", ""csi"", ""cxy"", ""din"", ""page"")
 ToRemove = c(ToRemoveBasePar, ToRemoveBrailleRBits)
 x2 = x[setdiff(names(x), ToRemove)]
@@ -89,7 +91,7 @@ return(invisible(x2))
 }
 
 .GrabExtraArgs = function(x){
-ToRemove = c("""", ""x"", ""y"", ""main"", ""xlab"", ""ylab"", ""sub"")
+ToRemove = c("""", ""x"", ""y"", ""main"", ""xlab"", ""ylab"", ""sub"", ""line.col"")
 ExtraArgs = as.list(x[setdiff(names(x), ToRemove)])
 return(invisible(ExtraArgs))
 }

---FILE: man/ScatterPlot.Rd---
@@ -25,4 +25,15 @@ An object of class scatterplot of fittedlineplot, with the addition of any calls
 \references{Godfrey, A.J.R. (2013) \sQuote{Statistical Software from a Blind Person's Perspective: R is the Best, but we can make it better}, The R Journal 5(1), pp73-79.}
 \author{A. Jonathan R. Godfrey}
 
+\examples{
+attach(airquality)
+op = par(mfcol=c(2,2))
+plot(Wind, Ozone, pch=4)
+ScatterPlot(Wind, Ozone, pch=4)
+plot(Wind, Ozone)
+abline(coef(lm(Ozone~Wind)), col=4)
+FittedLinePlot(Wind, Ozone, line.col=4)
+par(op)
+detach(airquality)
+}
 "
ajrgodfrey,BrailleR,4527d4794a36e2078e87451f11e0da1d4ae40ff4,ajrgodfrey,a.j.godfrey@massey.ac.nz,2017-05-09T07:52:36Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2017-05-09T07:52:36Z,changes for v0.25.7 (fixing scatter and fitted line plots),R/ScatterPlot.R;man/ScatterPlot.Rd,False,True,True,False,12,15,27,"---FILE: R/ScatterPlot.R---
@@ -19,7 +19,7 @@ ScatterPlot = function(x, y=NULL, ...){
 }
 
 
-FittedLinePlot = function(x, y, ...){
+FittedLinePlot = function(x, y, line.col=2, ...){
     MC <- match.call(expand.dots = TRUE)
     Out = list()
     Out$data = .CleanData4TwoWayPlot(x, y)
@@ -29,12 +29,14 @@ FittedLinePlot = function(x, y, ...){
     MC$x <- Out$data$x
     MC$y <- Out$data$y
     Out$graph <- eval(MC, envir=parent.frame())
+    Out$ExtraArgs  = .GrabExtraArgs(MC)
     Out$par = par()
     class(Out) = c(""fittedlineplot"", ""scatterplot"")
     Out = .checkTextLabels(MC, Out)
     Out=Augment(Out)
     Out$fittedline$coef = coef(lm(y~x, data=Out$data))
-    abline(Out$fittedline$coef, col=2)
+    Out$fittedline$col = line.col
+    abline(Out$fittedline$coef, col=line.col)
     return(invisible(Out))
 }
 
@@ -56,7 +58,6 @@ return(invisible(na.omit(data.frame(x=x[Ord], y=y[Ord]))))
 plot.scatterplot = function(x, ...){
 x$x= x$data$x
 x$y = x$data$y
-x = .RemoveExtraGraphPars(x)
  Pars = x$ExtraArgs
 x = .RemoveExtraGraphPars(x)
 suppressWarnings(do.call(plot, c(x, Pars)))
@@ -71,15 +72,15 @@ Pars=x$ExtraPars
 fitline = x$fittedline
 x = .RemoveExtraGraphPars(x)
 suppressWarnings(do.call(plot, c(x, Pars)))
-    abline(fitline$coef, col=2)
+    abline(fitline$coef, col=fitline$col)
 return(invisible(NULL))
 }
 
 print.fittedlineplot = plot.fittedlineplot
 print.scatterplot = plot.scatterplot
 
 .RemoveExtraGraphPars = function(x){
-ToRemoveBrailleRBits = c(""xTicks"", ""yTicks"", ""par"", ""GroupSummaries"", ""Continuous"", ""coef"", ""data"", ""fittedline"", ""main"", ""sub"", ""xlab"", ""ylab"")
+ToRemoveBrailleRBits = c(""xTicks"", ""yTicks"", ""par"", ""GroupSummaries"", ""Continuous"", ""coef"", ""data"", ""fittedline"", ""main"", ""sub"", ""xlab"", ""ylab"", ""ExtraArgs"")
 ToRemoveBasePar = c(""cin"", ""cra"", ""csi"", ""cxy"", ""din"", ""page"")
 ToRemove = c(ToRemoveBasePar, ToRemoveBrailleRBits)
 x2 = x[setdiff(names(x), ToRemove)]

---FILE: man/ScatterPlot.Rd---
@@ -10,23 +10,19 @@
 \usage{
 ScatterPlot(x, y, ...)
 
-FittedLinePlot(x, y, ...)
+FittedLinePlot(x, y, line.col=2, ...)
 
 }
 \arguments{
   \item{x,y}{numeric variables.}
-  \item{\dots}{
-additional arguments passed on to the plotting function.}
+\item{line.col}{colour to be used for the fitted line; col is used to modify the colour of the points.}
+  \item{\dots}{additional arguments passed on to the plotting function.}
 }
 \details{
-These wrapper functions will draw the graphics plots for a set of points. The only difference is tha the fitted line is added for the FittedLinePlot()}
+These wrapper functions will draw the graphics plots for a set of points. The only difference is that the fitted line is added for the FittedLinePlot()}
 \value{
 An object of class scatterplot of fittedlineplot, with the addition of any calls to the main title or axis labels being explicitly stored even if a zero length character string.}
-\references{
-Godfrey, A.J.R. (2013) \sQuote{Statistical Software from a Blind Person's Perspective: R is the Best, but we can make it better}, The R Journal 5(1), pp73-79.
-}
-\author{
-A. Jonathan R. Godfrey
-}
+\references{Godfrey, A.J.R. (2013) \sQuote{Statistical Software from a Blind Person's Perspective: R is the Best, but we can make it better}, The R Journal 5(1), pp73-79.}
+\author{A. Jonathan R. Godfrey}
 
 "
ajrgodfrey,BrailleR,c8aaeebdc3b3b7d025998306708e5d765e41906e,ajrgodfrey,a.j.godfrey@massey.ac.nz,2017-05-09T05:17:09Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2017-05-09T05:17:09Z,changes for v0.25.7 (fixing scatter and fitted line plots),R/ScatterPlot.R;inst/NEWS,False,True,True,False,19,10,29,"---FILE: R/ScatterPlot.R---
@@ -1,6 +1,6 @@
 
 
-ScatterPlot = function(x, y, ...){
+ScatterPlot = function(x, y=NULL, ...){
     MC <- match.call(expand.dots = TRUE)
     Out = list()
     Out$data = .CleanData4TwoWayPlot(x, y)
@@ -10,6 +10,7 @@ ScatterPlot = function(x, y, ...){
     MC$x <- Out$data$x
     MC$y <- Out$data$y
     Out$graph <- eval(MC, envir=parent.frame())
+    Out$ExtraArgs  = .GrabExtraArgs(MC)
     Out$par = par()
     class(Out) = ""scatterplot""
     Out = .checkTextLabels(MC, Out)
@@ -45,29 +46,31 @@ return(invisible(na.omit(data.frame(x=x[Ord], y=y[Ord]))))
 
 
 .checkTextLabels = function(MC, Out){
-    if (length(MC$main) > 0) Out$main = as.character(MC$main) else {Out$main = """"}
-    if (length(MC$sub) > 0) Out$sub = as.character(MC$sub)
-    if (length(MC$xlab) > 0) Out$xlab = as.character(MC$xlab)
-    if (length(MC$ylab) > 0) Out$ylab = as.character(MC$ylab)
+    if (length(MC$main) > 0) Out$ExtraArgs$main = as.character(MC$main) else {Out$ExtraArgs$main = """"}
+    if (length(MC$sub) > 0) Out$ExtraArgs$sub = as.character(MC$sub)
+    if (length(MC$xlab) > 0) Out$ExtraArgs$xlab = as.character(MC$xlab)
+    if (length(MC$ylab) > 0) Out$ExtraArgs$ylab = as.character(MC$ylab)
     return(invisible(Out))
 }
 
 plot.scatterplot = function(x, ...){
 x$x= x$data$x
 x$y = x$data$y
 x = .RemoveExtraGraphPars(x)
-suppressWarnings(do.call(plot, x))
+ Pars = x$ExtraArgs
+x = .RemoveExtraGraphPars(x)
+suppressWarnings(do.call(plot, c(x, Pars)))
 return(invisible(NULL))
 }
 
 
 plot.fittedlineplot = function(x, ...){
 x$x= x$data$x
 x$y = x$data$y
-Pars=x$par
+Pars=x$ExtraPars
 fitline = x$fittedline
 x = .RemoveExtraGraphPars(x)
-suppressWarnings(do.call(plot, c(x,Pars)))
+suppressWarnings(do.call(plot, c(x, Pars)))
     abline(fitline$coef, col=2)
 return(invisible(NULL))
 }
@@ -76,10 +79,16 @@ print.fittedlineplot = plot.fittedlineplot
 print.scatterplot = plot.scatterplot
 
 .RemoveExtraGraphPars = function(x){
-ToRemoveBrailleRBits = c(""xTicks"", ""yTicks"", ""par"", ""GroupSummaries"", ""Continuous"", ""coef"", ""data"", ""fittedline"")
+ToRemoveBrailleRBits = c(""xTicks"", ""yTicks"", ""par"", ""GroupSummaries"", ""Continuous"", ""coef"", ""data"", ""fittedline"", ""main"", ""sub"", ""xlab"", ""ylab"")
 ToRemoveBasePar = c(""cin"", ""cra"", ""csi"", ""cxy"", ""din"", ""page"")
 ToRemove = c(ToRemoveBasePar, ToRemoveBrailleRBits)
 x2 = x[setdiff(names(x), ToRemove)]
 class(x2) = class(x)
 return(invisible(x2))
 }
+
+.GrabExtraArgs = function(x){
+ToRemove = c("""", ""x"", ""y"", ""main"", ""xlab"", ""ylab"", ""sub"")
+ExtraArgs = as.list(x[setdiff(names(x), ToRemove)])
+return(invisible(ExtraArgs))
+}

---FILE: inst/NEWS---
@@ -3,7 +3,7 @@
 - changes from VS merged via GitHub (not to be reported again)
 - moved knitr package to imports. This means some of the Rmd files need more explicit mention of the package to get chunk options working properly.
 - JG implemented the ViewSVG() so that anyone can use the interactive graph viewing system; required various internal functions to move and write necessary files 
-- added FittedLinePlot() which adds a fitted line to the ScatterPlot() implmented through ScatterPlot()
+- added FittedLinePlot() which adds a fitted line to the ScatterPlot() implmented through ScatterPlot(); these use a few internal functions, found in ScatterPlot.R
 - added plot and print methods for various graph types. The print method refers to the plot function so acts just like the ggplot and lattice packages.
 
 # v0.25.6"
ajrgodfrey,BrailleR,4d0a9f134da04ebd9cbde58af684a31143d441eb,ajrgodfrey,a.j.godfrey@massey.ac.nz,2017-05-08T23:18:02Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2017-05-08T23:18:02Z,changes for v0.25.7 (fixing scatter and fitted line plots),R/ScatterPlot.R;R/TSPlot.R;README.md,False,True,True,False,22,3,25,"---FILE: R/ScatterPlot.R---
@@ -33,7 +33,7 @@ FittedLinePlot = function(x, y, ...){
     Out = .checkTextLabels(MC, Out)
     Out=Augment(Out)
     Out$fittedline$coef = coef(lm(y~x, data=Out$data))
-    abline(Out$fittedline$coef)
+    abline(Out$fittedline$coef, col=2)
     return(invisible(Out))
 }
 
@@ -53,16 +53,33 @@ return(invisible(na.omit(data.frame(x=x[Ord], y=y[Ord]))))
 }
 
 plot.scatterplot = function(x, ...){
+x$x= x$data$x
+x$y = x$data$y
+x = .RemoveExtraGraphPars(x)
 suppressWarnings(do.call(plot, x))
 return(invisible(NULL))
 }
 
 
 plot.fittedlineplot = function(x, ...){
-suppressWarnings(do.call(plot, x$data))
-    abline(x$fittedline$coef)
+x$x= x$data$x
+x$y = x$data$y
+Pars=x$par
+fitline = x$fittedline
+x = .RemoveExtraGraphPars(x)
+suppressWarnings(do.call(plot, c(x,Pars)))
+    abline(fitline$coef, col=2)
 return(invisible(NULL))
 }
 
 print.fittedlineplot = plot.fittedlineplot
 print.scatterplot = plot.scatterplot
+
+.RemoveExtraGraphPars = function(x){
+ToRemoveBrailleRBits = c(""xTicks"", ""yTicks"", ""par"", ""GroupSummaries"", ""Continuous"", ""coef"", ""data"", ""fittedline"")
+ToRemoveBasePar = c(""cin"", ""cra"", ""csi"", ""cxy"", ""din"", ""page"")
+ToRemove = c(ToRemoveBasePar, ToRemoveBrailleRBits)
+x2 = x[setdiff(names(x), ToRemove)]
+class(x2) = class(x)
+return(invisible(x2))
+}

---FILE: R/TSPlot.R---
@@ -20,6 +20,7 @@ Out$par = par()
 }
 
 plot.tsplot = function(x, ...){
+x = .RemoveExtraGraphPars(x) # see ScatterPlot.R for this function
 suppressWarnings(do.call(plot, x))
 return(invisible(NULL))
 }

---FILE: README.md---
@@ -25,6 +25,7 @@ Any assistance to fill in the numerous gaps in what BrailleR delivers will be mo
 
 Some issues to resolve:
 
+1. storing the graphical parameters in ScatterPlot() etc. does not get the right ones slected. Need to replace this by somehow keeping the ... arguments supplie by the user. Tested using col and pch in FittedLinePlot()
 1. get VI.ggplot() doing more; see vignette
 2. get more graphics ready for making into SVG for use on Tiger products; mostly in SVGThis() method
 3. Get more Graph types working with the additional XML to make them interactive."
ajrgodfrey,BrailleR,bc50102af1c130ce14a5845f4757922377ec92aa,ajrgodfrey,a.j.godfrey@massey.ac.nz,2017-05-08T09:52:45Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2017-05-08T09:52:45Z,changes for v0.25.7 (fixing scatter and fitted line plots),NAMESPACE;man/ScatterPlot.Rd;man/TSPlot.Rd,False,False,False,False,5,2,7,"---FILE: NAMESPACE---
@@ -1,7 +1,7 @@
 importFrom(""devtools"", ""spell_check"")
 import(extrafont)
 importFrom(""ggplot2"", ""qplot"", ""ggplot_build"") 
-importFrom(""graphics"", ""par"", ""plot"") 
+importFrom(""graphics"", ""abline"", ""par"", ""plot"") 
 importFrom(""grDevices"", ""dev.cur"", ""dev.list"", ""pdf"") 
 import(grid)
 import(gridGraphics)
@@ -13,7 +13,7 @@ importFrom(""moments"", ""skewness"")
 importFrom(""nortest"", ""ad.test"")
 importFrom(""pander"", ""pander"")
 import(rmarkdown)
-importFrom(""stats"", ""aggregate"", ""anova"", ""as.ts"", ""cor"", ""median"", ""na.omit"", ""qnorm"", ""rstudent"", ""sd"") 
+importFrom(""stats"", ""aggregate"", ""anova"", ""as.ts"", ""coef"", ""cor"", ""lm"", ""median"", ""na.omit"", ""qnorm"", ""rstudent"", ""sd"") 
 importFrom(""utils"", ""browseURL"", ""create.post"", ""download.file"", ""file.edit"", ""installed.packages"", ""menu"", ""packageVersion"", ""read.csv"", ""read.table"", ""savehistory"", ""tail"", ""unzip"", ""write.csv"") 
 import(XML)
 importFrom(""xtable"", ""xtable"")

---FILE: man/ScatterPlot.Rd---
@@ -3,6 +3,8 @@
 \alias{ScatterPlot}
 \alias{plot.scatterplot}
 \alias{plot.fittedlineplot}
+\alias{print.scatterplot}
+\alias{print.fittedlineplot}
 \title{Create a standard scatter plot with a few extra elements added to the output object}
 \description{This function is a wrapper to the standard \code{plott()} function in the \pkg{graphics} package. It is tailored to generating a scatter plot, and adds detail to the stored object so that a better text description can be formulated using the \code{VI()} method in the \pkg{BrailleR} package.}
 \usage{

---FILE: man/TSPlot.Rd---
@@ -1,6 +1,7 @@
 \name{TSPlot}
 \alias{TimeSeriesPlot}
 \alias{plot.tsplot}
+\alias{print.tsplot}
 
 \title{Create a standard time series plot with a few extra elements added to the output object}
 \description{This function is a wrapper to the standard \code{plott()} function in the \pkg{graphics} package. It is tailored to generating a time series plot, and adds detail to the stored object so that a better text description can be formulated using the \code{VI()} method in the \pkg{BrailleR} package.}"
ajrgodfrey,BrailleR,e2ac86e205450e98ba604fa2d8ef72fb32658364,ajrgodfrey,a.j.godfrey@massey.ac.nz,2017-05-08T09:30:25Z,ajrgodfrey,a.j.godfrey@massey.ac.nz,2017-05-08T09:30:25Z,changes for v0.25.7 (fixing scatter and fitted line plots),NAMESPACE;R/ScatterPlot.R;R/TSPlot.R;README.md;inst/NEWS,False,True,True,False,25,8,33,"---FILE: NAMESPACE---
@@ -41,6 +41,9 @@ S3method(MakeAccessibleSVG,default)
 S3method(plot,fittedlineplot)
 S3method(plot,scatterplot)
 S3method(plot,tsplot)
+S3method(print,fittedlineplot)
+S3method(print,scatterplot)
+S3method(print,tsplot)
 S3method(print,wordlist)
 S3method(SVGThis,default)
   S3method(SVGThis,boxplot)

---FILE: R/ScatterPlot.R---
@@ -3,8 +3,7 @@
 ScatterPlot = function(x, y, ...){
     MC <- match.call(expand.dots = TRUE)
     Out = list()
-    Ord = order(x,y)
-    Out$data = na.omit(data.frame(x=x[Ord], y=y[Ord]))
+    Out$data = .CleanData4TwoWayPlot(x, y)
     MC$xlab= ifelse(is.null(MC$xlab), as.character(MC$x), MC$xlab)
     MC$ylab= ifelse(is.null(MC$ylab), as.character(MC$y), MC$ylab)
     MC[[1L]] <- quote(graphics::plot)
@@ -22,8 +21,7 @@ ScatterPlot = function(x, y, ...){
 FittedLinePlot = function(x, y, ...){
     MC <- match.call(expand.dots = TRUE)
     Out = list()
-    Ord = order(x,y)
-    Out$data = na.omit(data.frame(x=x[Ord], y=y[Ord]))
+    Out$data = .CleanData4TwoWayPlot(x, y)
     MC$xlab= ifelse(is.null(MC$xlab), as.character(MC$x), MC$xlab)
     MC$ylab= ifelse(is.null(MC$ylab), as.character(MC$y), MC$ylab)
     MC[[1L]] <- quote(graphics::plot)
@@ -34,9 +32,18 @@ FittedLinePlot = function(x, y, ...){
     class(Out) = c(""fittedlineplot"", ""scatterplot"")
     Out = .checkTextLabels(MC, Out)
     Out=Augment(Out)
+    Out$fittedline$coef = coef(lm(y~x, data=Out$data))
+    abline(Out$fittedline$coef)
     return(invisible(Out))
 }
 
+
+.CleanData4TwoWayPlot = function(x, y){
+    Ord = order(x,y)
+return(invisible(na.omit(data.frame(x=x[Ord], y=y[Ord]))))
+}
+
+
 .checkTextLabels = function(MC, Out){
     if (length(MC$main) > 0) Out$main = as.character(MC$main) else {Out$main = """"}
     if (length(MC$sub) > 0) Out$sub = as.character(MC$sub)
@@ -52,6 +59,10 @@ return(invisible(NULL))
 
 
 plot.fittedlineplot = function(x, ...){
-suppressWarnings(do.call(plot, x))
+suppressWarnings(do.call(plot, x$data))
+    abline(x$fittedline$coef)
 return(invisible(NULL))
 }
+
+print.fittedlineplot = plot.fittedlineplot
+print.scatterplot = plot.scatterplot

---FILE: R/TSPlot.R---
@@ -23,3 +23,5 @@ plot.tsplot = function(x, ...){
 suppressWarnings(do.call(plot, x))
 return(invisible(NULL))
 }
+
+print.tsplot = plot.tsplot

---FILE: README.md---
@@ -27,7 +27,7 @@ Some issues to resolve:
 
 1. get VI.ggplot() doing more; see vignette
 2. get more graphics ready for making into SVG for use on Tiger products; mostly in SVGThis() method
-3. Get more Graph types orking with the additional XML to mke them interactive.
+3. Get more Graph types working with the additional XML to make them interactive.
 1. fix background of all code chunks in slides being made. This is probably an issue in the css file.
 2. get graph files named properly by TwoFactors(); including  boxplots etc vs each factor not both.
 3. In OneFactor() and TwoFactors(): ensure that boxplots are created for each factor unless a level is short of reps.

---FILE: inst/NEWS---
@@ -1,9 +1,10 @@
 # v0.25.7
 - VS offered BrowseSVG() and replacement cacc.js for improved interactive experience; JG fixed for CRAN checks.
+- changes from VS merged via GitHub (not to be reported again)
 - moved knitr package to imports. This means some of the Rmd files need more explicit mention of the package to get chunk options working properly.
 - JG implemented the ViewSVG() so that anyone can use the interactive graph viewing system; required various internal functions to move and write necessary files 
-- added FittedLinePlot() which adds a fitted line to the ScatterPlot() already implmented
-
+- added FittedLinePlot() which adds a fitted line to the ScatterPlot() implmented through ScatterPlot()
+- added plot and print methods for various graph types. The print method refers to the plot function so acts just like the ggplot and lattice packages.
 
 # v0.25.6
 - working on accessible Venn diagrams and time series plots"
ajrgodfrey,BrailleR,758a863803402f59c32140be02f2f6b999daf922,zorkow,volker.sorge@gmail.com,2017-05-07T23:59:44Z,zorkow,volker.sorge@gmail.com,2017-05-07T23:59:44Z,Fixes bug in horizontal boxplots.,R/AddXMLMethod.R,False,True,True,False,1,1,2,"---FILE: R/AddXMLMethod.R---
@@ -26,7 +26,7 @@ AddXML.boxplot = function(x, file) {
       YMax = max(yValues)
     }
     if (x$horizontal) {
-      xSpeech <- paste(""x axis"", x$ylab, ""ranges from"", YMin, ""to"", YMax)
+      xSpeech <- paste(""x axis"", x$xlab, ""ranges from"", YMin, ""to"", YMax)
       ySpeech <- paste(""y axis with values"", paste(yValues, collapse="", ""))
     } else {
       xSpeech <- paste(""x axis with values"", paste(xValues, collapse="", ""))"
ajrgodfrey,BrailleR,8a263419db84ada813c3085763028553a0208f98,zorkow,volker.sorge@gmail.com,2017-05-07T18:53:00Z,zorkow,volker.sorge@gmail.com,2017-05-07T18:53:00Z,Grammar corrections for outliers.,R/AddXMLInternal.R,False,True,True,False,17,9,26,"---FILE: R/AddXMLInternal.R---
@@ -316,13 +316,13 @@
     ## References: 
     ## http://www.bbc.co.uk/schools/gcsebitesize/maths/statistics/representingdata3hirev6.shtml
     ## https://www.khanacademy.org/math/probability/data-distributions-a1/box--whisker-plots-a1/v/reading-box-and-whisker-plots
-    q1 <- ifelse(min(outliers) < quartiles[1],
+    q1 <- ifelse(suppressWarnings(min(outliers)) < quartiles[1],
                  paste(""Lower whisker"", quartiles[1]),
                  paste(""Minimum"", quartiles[1]))
     q2 <- paste(""Lower quartile"", quartiles[2])
     q3 <- paste(""Median"", quartiles[3])
     q4 <- paste(""Upper quartile"", quartiles[4])
-    q5 <- ifelse(max(outliers) > quartiles[5],
+    q5 <- ifelse(suppressWarnings(max(outliers)) > quartiles[5],
                  paste(""Upper whisker"", quartiles[5]),
                  paste(""Maximum"", quartiles[5]))
     ## Position counting:
@@ -350,22 +350,30 @@
       root, position=2,  id=paste0(""graphics-root."", counter + 2), kind=""passive"")
     annotations[[3]] <- .AddXMLAddAnnotation(
       root, position=3, id=paste0(""graphics-root."", counter + 4), kind=""active"")
-    XML::addAttributes(annotations[[3]]$root, speech=paste(q2, ""and"", q4),
+    XML::addAttributes(annotations[[3]]$root, speech=paste0(paste(q2, ""and"", q4), "".""),
                        type=""component"")
     annotations[[4]] <- .AddXMLAddAnnotation(
       root, position=4, id=paste0(""graphics-root."", counter + 3), kind=""active"")
-    XML::addAttributes(annotations[[4]]$root, speech=paste(q1, ""and"", q5),
+    XML::addAttributes(annotations[[4]]$root, speech=paste0(paste(q1, ""and"", q5), "".""),
                        type=""component"")
     speech <- paste(""Boxplot"", ifelse(name == """", """", paste(""for"", name)),
                     ""and quartiles in"", paste(quartiles, collapse="", ""))
     speech2 <- paste(""Boxplot"", ifelse(name == """", """", paste(""for"", name)),
-                     ""for"", datapoints, ""datapoints."", q1, q2, q3, q4, q5)
+                     ""for"", datapoints, ""datapoints."",
+                     paste0(paste(q1, q2, q3, q4, q5, sep="", ""), "".""))
     if (length(outliers) > 0) {
       ## Add outliers
-      annotations[[5]] <- .AddXMLAddAnnotation(
-        root, position=5, id=paste0(""graphics-root."", counter + 6), kind=""active"")
-      speech <- paste(speech, ""and"", length(outliers), ""outliers"")
-      descr <- paste(length(outliers), ""outliers at"", paste(outliers, collapse="", ""))
+      if (length(outliers) > 1) {
+        annotations[[5]] <- .AddXMLAddAnnotation(
+          root, position=5, id=paste0(""graphics-root."", counter + 6), kind=""active"")
+        name <- ""outliers""
+      } else {
+        annotations[[5]] <- .AddXMLAddAnnotation(
+          root, position=5, id=paste0(""graphics-root."", counter + 6), kind=""active"")
+        name <- ""outlier""
+      }
+      speech <- paste(speech, ""and"", length(outliers), name)
+      descr <- paste(length(outliers), name, ""at"", paste(outliers, collapse="", ""))
       speech2 <- paste(speech2, descr)
       XML::addAttributes(annotations[[5]]$root, speech=descr, type=""component"")
     } else {"
ajrgodfrey,BrailleR,aa35c7552bcf6bbd82283dce5e548b12822ee749,zorkow,volker.sorge@gmail.com,2017-04-27T00:28:52Z,zorkow,volker.sorge@gmail.com,2017-04-27T00:28:52Z,Fixes regexp bug and copies JavaScript library to working directory,R/BrowseSVG.R,False,True,True,False,10,3,13,"---FILE: R/BrowseSVG.R---
@@ -2,7 +2,7 @@
 BrowseSVG = function(file=""test"", dir=""."", key=TRUE, view=interactive()) {
   xmlString <- .CleanXml(file=file, dir=dir)
   svgFile <- paste0(file, "".svg"")
-  svgString <- readLines(svgFile)  # was readChar(svgFile, file.info(svgFile)$size)
+  svgString <- readLines(svgFile)
   htmlFile <- paste0(file, "".html"")
   .AddHeader2HTML(file=htmlFile, dir=dir)
   .AddContainer2HTML(svgString, xmlString, file=htmlFile, dir=dir)
@@ -11,6 +11,7 @@ BrowseSVG = function(file=""test"", dir=""."", key=TRUE, view=interactive()) {
   }
   .AddFooter2HTML(file=htmlFile, dir=dir)
   if (view) {
+    .CopyLibrary(dir=dir)
     browseURL(htmlFile) 
   }
   return(invisible(NULL))
@@ -19,9 +20,9 @@ BrowseSVG = function(file=""test"", dir=""."", key=TRUE, view=interactive()) {
 
 .CleanXml = function(file=""test"", dir=""."") {
   fileName <- paste0(file, "".xml"")
-  xmlString <- readLines(fileName) # was readChar(fileName, file.info(fileName)$size)
+  xmlString <- readLines(fileName)
   xmlString <- gsub(""sre:"", """", xmlString)
-  gsub("" *<[a-zA-Z]+/>\n"", """", xmlString)
+  gsub("" *<[a-zA-Z]+/>"", """", xmlString)
 }
 
 
@@ -111,3 +112,9 @@ file=file, append=TRUE)
 }
 
 
+.CopyLibrary = function(dir="".""){
+  if(!file.exists(file.path(dir, ""cacc.js""))){
+    file.copy(file.path(system.file(package = ""BrailleR""), ""Web"", c(""cacc.js"")), dir)
+  }
+  return(invisible(NULL))
+}"
