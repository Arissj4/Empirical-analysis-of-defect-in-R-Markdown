repo_owner,repo_name,commit_hash,author_name,author_email,author_date,committer_name,committer_email,committer_date,message,filenames,touches_rmd,touches_r,touches_r_or_rmd,is_merge,added,deleted,changed,diff
strengejacke,sjPlot,fee386216bcfcf293026597abceeb4ccafc65d07,Daniel,mail@danielluedecke.de,2025-07-04T09:41:12Z,Daniel,mail@danielluedecke.de,2025-07-04T09:41:12Z,fix,R/sjPlotDist.R,False,True,True,False,55,37,92,"---FILE: R/sjPlotDist.R---
@@ -483,17 +483,22 @@ dist_f <- function(
 #' dist_t(p = 0.4, deg.f = 6)
 #'
 #' @export
-dist_t <- function(t = NULL,
-                  deg.f = NULL,
-                  p = NULL,
-                  xmax = NULL,
-                  geom.colors = NULL,
-                  geom.alpha = 0.7) {
+dist_t <- function(
+  t = NULL,
+  deg.f = NULL,
+  p = NULL,
+  xmax = NULL,
+  geom.colors = NULL,
+  geom.alpha = 0.7
+) {
   # --------------------------------------
   # check parameters
   # --------------------------------------
   if (is.null(deg.f)) {
-    warning(""Degrees of freedom ('deg.f') needs to be specified."", call. = FALSE)
+    warning(
+      ""Degrees of freedom ('deg.f') needs to be specified."",
+      call. = FALSE
+    )
     return(invisible(NULL))
   }
   # --------------------------------------
@@ -505,20 +510,18 @@ dist_t <- function(t = NULL,
   if (is.null(xmax)) {
     if (is.null(t)) {
       t.max <- stats::qt(0.00001, deg.f, lower.tail = FALSE)
-    }
-    # --------------------------------------
-    # else, if we have a t-value, take into
-    # account all possible t-values that would lead
-    # to a theoretical p-value of 0.00001.
-    # --------------------------------------
-    else {
+    } else {
+      # --------------------------------------
+      # else, if we have a t-value, take into
+      # account all possible t-values that would lead
+      # to a theoretical p-value of 0.00001.
+      # --------------------------------------
       t.max <- t
       while (stats::pt(t.max, deg.f, lower.tail = FALSE) > 0.00001) {
         t.max <- t.max + 1
       }
     }
-  }
-  else {
+  } else {
     t.max <- xmax
   }
   # --------------------------------------
@@ -528,45 +531,60 @@ dist_t <- function(t = NULL,
   # density distribution of t
   mydat$y <- stats::dt(mydat$x, deg.f)
   # base plot with t-distribution
-  gp <- ggplot2::ggplot(mydat, ggplot2::aes(x = .data$x, y = .data$y)) + ggplot2::geom_line()
+  gp <- ggplot2::ggplot(mydat, ggplot2::aes(x = .data$x, y = .data$y)) +
+    ggplot2::geom_line()
   sub.df <- NULL
   if (!is.null(p)) {
     # plot area for indicated t-value...
     sub.df <- mydat[mydat$x > stats::qt(p, deg.f, lower.tail = FALSE), ]
-  }
-  else if (!is.null(t)) {
+  } else if (!is.null(t)) {
     # resp. for p-value...
     sub.df <- mydat[mydat$x > t, ]
   }
   if (!is.null(sub.df)) {
-    sub.df$p.level  <- ifelse(sub.df$x > stats::qt(0.05, deg.f, lower.tail = FALSE), ""sig"", ""non-sig"")
+    sub.df$p.level <- ifelse(
+      sub.df$x > stats::qt(0.05, deg.f, lower.tail = FALSE),
+      ""sig"",
+      ""non-sig""
+    )
     tv <- stats::qt(0.05, deg.f, lower.tail = FALSE)
     gp <- gp +
-      ggplot2::geom_ribbon(data = sub.df,
-                  ggplot2::aes(ymax = .data$y, fill = .data$p.level),
-                  ymin = 0,
-                  alpha = geom.alpha) +
-      ggplot2::annotate(""text"",
-               label = sprintf(""t = %.2f"", tv),
-               x = tv,
-               y = 0,
-               vjust = 1.3)
+      ggplot2::geom_ribbon(
+        data = sub.df,
+        ggplot2::aes(ymax = .data$y, fill = .data$p.level),
+        ymin = 0,
+        alpha = geom.alpha
+      ) +
+      ggplot2::annotate(
+        ""text"",
+        label = sprintf(""t = %.2f"", tv),
+        x = tv,
+        y = 0,
+        vjust = 1.3
+      )
     # add limit of p-value
     if (!is.null(t)) {
       pv <- stats::pt(t, deg.f, lower.tail = FALSE)
       if (pv >= 0.05) {
         gp <- gp +
-          ggplot2::annotate(""text"",
-                   label = sprintf(""p = %.2f"", pv),
-                   x = TRUE,
-                   y = 0,
-                   hjust = -0.1,
-                   vjust = -0.5,
-                   angle = 90)
+          ggplot2::annotate(
+            ""text"",
+            label = sprintf(""p = %.2f"", pv),
+            x = t,
+            y = 0,
+            hjust = -0.1,
+            vjust = -0.5,
+            angle = 90
+          )
       }
     }
   }
-  gp <- sj.setGeomColors(gp, geom.colors, pal.len = 2, labels = c(""p > 5%"", ""p < 0.05""))
+  gp <- sj.setGeomColors(
+    gp,
+    geom.colors,
+    pal.len = 2,
+    labels = c(""p > 5%"", ""p < 0.05"")
+  )
   gp <- gp + ggplot2::ylab(NULL) + ggplot2::xlab(""t-value"")
   print(gp)
 }"
strengejacke,sjPlot,0e9efdd1839345267171f45fe5d6c50697057bff,Daniel,mail@danielluedecke.de,2025-07-04T06:29:36Z,Daniel,mail@danielluedecke.de,2025-07-04T06:29:36Z,Fix #960,R/plot_model.R;R/tab_model.R;man/plot_model.Rd;man/plot_models.Rd;man/tab_model.Rd,False,True,True,False,6,6,12,"---FILE: R/plot_model.R---
@@ -269,7 +269,7 @@
 #'   will be occupied by the jittered values.
 #' @param digits Numeric, amount of digits after decimal point when rounding
 #'   estimates or values.
-#' @param p.adjust Character vector, if not \code{NULL}, indicates the method
+#' @param p.adjust String value, if not \code{NULL}, indicates the method
 #'   to adjust p-values. See \code{\link[stats]{p.adjust}} for details.
 #' @param value.size Numeric, indicates the size of value labels. Can be used
 #'   for all plot types where the argument \code{show.values} is applicable,

---FILE: R/tab_model.R---
@@ -92,7 +92,7 @@
 #' @param string.se Character vector, used for the column heading of standard error values. Default is \code{""std. Error""}.
 #' @param string.std_se Character vector, used for the column heading of standard error of standardized coefficients. Default is \code{""standardized std. Error""}.
 #' @param string.std_ci Character vector, used for the column heading of confidence intervals of standardized coefficients. Default is \code{""standardized std. Error""}.
-#' @param string.p Character vector, used for the column heading of p values. Default is \code{""p""}.
+#' @param string.p String value, used for the column heading of p values. Default is \code{""p""}.
 #' @param string.std.p Character vector, used for the column heading of p values. Default is \code{""std. p""}.
 #' @param string.df Character vector, used for the column heading of degrees of freedom. Default is \code{""df""}.
 #' @param string.stat Character vector, used for the test statistic. Default is \code{""Statistic""}.

---FILE: man/plot_model.Rd---
@@ -362,7 +362,7 @@ annotating p-values with asterisks. Only applies if
 \item{p.val}{Character specifying method to be used to calculate p-values.
 Defaults to ""profile"" for glm/polr models, otherwise ""wald"".}
 
-\item{p.adjust}{Character vector, if not \code{NULL}, indicates the method
+\item{p.adjust}{String value, if not \code{NULL}, indicates the method
 to adjust p-values. See \code{\link[stats]{p.adjust}} for details.}
 
 \item{grid}{Logical, if \code{TRUE}, multiple plots are plotted as grid

---FILE: man/plot_models.Rd---
@@ -174,7 +174,7 @@ is \code{FALSE}.}
 annotating p-values with asterisks. Only applies if
 \code{p.style = ""asterisk""}.}
 
-\item{p.adjust}{Character vector, if not \code{NULL}, indicates the method
+\item{p.adjust}{String value, if not \code{NULL}, indicates the method
 to adjust p-values. See \code{\link[stats]{p.adjust}} for details.}
 
 \item{ci.lvl}{Numeric, the level of the confidence intervals (error bars).

---FILE: man/tab_model.Rd---
@@ -261,7 +261,7 @@ Default is based on the response scale, e.g. for logistic regression models,
 
 \item{string.std_ci}{Character vector, used for the column heading of confidence intervals of standardized coefficients. Default is \code{""standardized std. Error""}.}
 
-\item{string.p}{Character vector, used for the column heading of p values. Default is \code{""p""}.}
+\item{string.p}{String value, used for the column heading of p values. Default is \code{""p""}.}
 
 \item{string.std.p}{Character vector, used for the column heading of p values. Default is \code{""std. p""}.}
 
@@ -336,7 +336,7 @@ combined with ""stars"", e.g. \code{""numeric_stars""}}
 annotating p-values with asterisks. Only applies if
 \code{p.style = ""asterisk""}.}
 
-\item{p.adjust}{Character vector, if not \code{NULL}, indicates the method
+\item{p.adjust}{String value, if not \code{NULL}, indicates the method
 to adjust p-values. See \code{\link[stats]{p.adjust}} for details.}
 
 \item{case}{Desired target case. Labels will automatically converted into the"
strengejacke,sjPlot,887684823c76058a73eeed1c25c620f3d5f405c7,Daniel,mail@danielluedecke.de,2025-07-04T06:25:58Z,Daniel,mail@danielluedecke.de,2025-07-04T06:25:58Z,fix,R/utils.R,False,True,True,False,1,1,2,"---FILE: R/utils.R---
@@ -123,7 +123,7 @@ estimate_axis_title <- function(fit, axis.title, type, transform = NULL, multi.r
       fitfam$is_ordinal ~ ""Odds Ratios"",
       fitfam$is_multinomial ~ ""Odds Ratios"",
       fitfam$is_categorical ~ ""Odds Ratios"",
-      fitfam$is_Probit ~ ""Coefficients"",
+      fitfam$is_probit ~ ""Coefficients"",
       fitfam$is_binomial && !fitfam$is_logit ~ ""Risk Ratios"",
       fitfam$is_binomial ~ ""Odds Ratios"",
       TRUE ~ ""Estimates"""
strengejacke,sjPlot,d0bf66826359c10153e724f14d91e2c47dbdc7da,Daniel,mail@danielluedecke.de,2025-07-04T06:25:45Z,Daniel,mail@danielluedecke.de,2025-07-04T06:25:45Z,Fix #964,R/utils.R,False,True,True,False,2,0,2,"---FILE: R/utils.R---
@@ -113,6 +113,7 @@ estimate_axis_title <- function(fit, axis.title, type, transform = NULL, multi.r
 
     axis.title <- dplyr::case_when(
       !is.null(transform) && transform == ""plogis"" ~ ""Probabilities"",
+      is.null(transform) && fitfam$is_probit ~ ""Z-Scores"",
       is.null(transform) && fitfam$is_binomial ~ ""Log-Odds"",
       is.null(transform) && fitfam$is_ordinal ~ ""Log-Odds"",
       is.null(transform) && fitfam$is_multinomial ~ ""Log-Odds"",
@@ -122,6 +123,7 @@ estimate_axis_title <- function(fit, axis.title, type, transform = NULL, multi.r
       fitfam$is_ordinal ~ ""Odds Ratios"",
       fitfam$is_multinomial ~ ""Odds Ratios"",
       fitfam$is_categorical ~ ""Odds Ratios"",
+      fitfam$is_Probit ~ ""Coefficients"",
       fitfam$is_binomial && !fitfam$is_logit ~ ""Risk Ratios"",
       fitfam$is_binomial ~ ""Odds Ratios"",
       TRUE ~ ""Estimates"""
strengejacke,sjPlot,71d764f8248923db258918deed8e7886f930c54f,Daniel,mail@danielluedecke.de,2025-07-04T06:14:56Z,Daniel,mail@danielluedecke.de,2025-07-04T06:14:56Z,fix #966,R/plot_type_int.R,False,True,True,False,0,1,1,"---FILE: R/plot_type_int.R---
@@ -109,7 +109,6 @@ plot_type_int <- function(
       terms = ia,
       ci_level = ci.lvl,
       type = pred.type,
-      full.data = FALSE,
       ...
     )
 "
strengejacke,sjPlot,409fc921e90d3b41a64ef71c5b13cc6574be1d14,Daniel,mail@danielluedecke.de,2025-07-04T06:07:24Z,Daniel,mail@danielluedecke.de,2025-07-04T06:07:24Z,fix,R/sjPlotDist.R,False,True,True,False,59,34,93,"---FILE: R/sjPlotDist.R---
@@ -332,18 +332,23 @@ dist_chisq <- function(
 #' dist_f(p = 0.2, deg.f1 = 6, deg.f2 = 45)
 #'
 #' @export
-dist_f <- function(f = NULL,
-                  deg.f1 = NULL,
-                  deg.f2 = NULL,
-                  p = NULL,
-                  xmax = NULL,
-                  geom.colors = NULL,
-                  geom.alpha = 0.7) {
+dist_f <- function(
+  f = NULL,
+  deg.f1 = NULL,
+  deg.f2 = NULL,
+  p = NULL,
+  xmax = NULL,
+  geom.colors = NULL,
+  geom.alpha = 0.7
+) {
   # --------------------------------------
   # check parameters
   # --------------------------------------
   if (is.null(deg.f1) || is.null(deg.f2)) {
-    warning(""Both degrees of freedom ('deg.f1' and 'deg.f2') needs to be specified."", call. = FALSE)
+    warning(
+      ""Both degrees of freedom ('deg.f1' and 'deg.f2') needs to be specified."",
+      call. = FALSE
+    )
     return(invisible(NULL))
   }
   # --------------------------------------
@@ -355,14 +360,16 @@ dist_f <- function(f = NULL,
   if (is.null(xmax)) {
     if (is.null(f)) {
       f.max <- stats::qf(0.00001, deg.f1, deg.f2, lower.tail = FALSE)
-    # --------------------------------------
-    # else, if we have a f-value, take into
-    # account all possible f-values that would lead
-    # to a theoretical p-value of 0.00001.
-    # --------------------------------------
+      # --------------------------------------
+      # else, if we have a f-value, take into
+      # account all possible f-values that would lead
+      # to a theoretical p-value of 0.00001.
+      # --------------------------------------
     } else {
       f.max <- f
-      while (stats::pf(f.max, deg.f1, deg.f2, lower.tail = FALSE) > 0.00001) f.max <- f.max + 1
+      while (stats::pf(f.max, deg.f1, deg.f2, lower.tail = FALSE) > 0.00001) {
+        f.max <- f.max + 1
+      }
     }
   } else {
     f.max <- xmax
@@ -374,44 +381,62 @@ dist_f <- function(f = NULL,
   # density distribution of f
   mydat$y <- stats::df(mydat$x, deg.f1, deg.f2)
   # base plot with f-distribution
-  gp <- ggplot2::ggplot(mydat, ggplot2::aes(x = .data$x, y = .data$y)) + ggplot2::geom_line()
+  gp <- ggplot2::ggplot(mydat, ggplot2::aes(x = .data$x, y = .data$y)) +
+    ggplot2::geom_line()
   sub.df <- NULL
   if (!is.null(p)) {
     # plot area for indicated f-value...
-    sub.df <- mydat[mydat$x > stats::qf(p, deg.f1, deg.f2, lower.tail = FALSE), ]
+    sub.df <- mydat[
+      mydat$x > stats::qf(p, deg.f1, deg.f2, lower.tail = FALSE),
+    ]
   } else if (!is.null(f)) {
     # resp. for p-value...
     sub.df <- mydat[mydat$x > f, ]
   }
   if (!is.null(sub.df)) {
-    sub.df$p.level  <- ifelse(sub.df$x > stats::qf(0.05, deg.f1, deg.f2, lower.tail = FALSE), ""sig"", ""non-sig"")
+    sub.df$p.level <- ifelse(
+      sub.df$x > stats::qf(0.05, deg.f1, deg.f2, lower.tail = FALSE),
+      ""sig"",
+      ""non-sig""
+    )
     fv <- stats::qf(0.05, deg.f1, deg.f2, lower.tail = FALSE)
     gp <- gp +
-      ggplot2::geom_ribbon(data = sub.df,
-                  ggplot2::aes(ymax = .data$y, fill = .data$p.level),
-                  ymin = 0,
-                  alpha = geom.alpha) +
-      ggplot2::annotate(""text"",
-               label = sprintf(""F = %.2f"", fv),
-               x = fv,
-               y = 0,
-               vjust = 1.3)
+      ggplot2::geom_ribbon(
+        data = sub.df,
+        ggplot2::aes(ymax = .data$y, fill = .data$p.level),
+        ymin = 0,
+        alpha = geom.alpha
+      ) +
+      ggplot2::annotate(
+        ""text"",
+        label = sprintf(""F = %.2f"", fv),
+        x = fv,
+        y = 0,
+        vjust = 1.3
+      )
     # add limit of p-value
     if (!is.null(f)) {
       pv <- stats::pf(f, deg.f1, deg.f2, lower.tail = FALSE)
       if (pv >= 0.05) {
         gp <- gp +
-          ggplot2::annotate(""text"",
-                   label = sprintf(""p = %.2f"", pv),
-                   x = FALSE,
-                   y = 0,
-                   hjust = -0.1,
-                   vjust = -0.5,
-                   angle = 90)
+          ggplot2::annotate(
+            ""text"",
+            label = sprintf(""p = %.2f"", pv),
+            x = f,
+            y = 0,
+            hjust = -0.1,
+            vjust = -0.5,
+            angle = 90
+          )
       }
     }
   }
-  gp <- sj.setGeomColors(gp, geom.colors, pal.len = 2, labels = c(""p > 5%"", ""p < 0.05""))
+  gp <- sj.setGeomColors(
+    gp,
+    geom.colors,
+    pal.len = 2,
+    labels = c(""p > 5%"", ""p < 0.05"")
+  )
   gp <- gp + ggplot2::ylab(NULL) + ggplot2::xlab(""F-value"")
   print(gp)
 }"
strengejacke,sjPlot,1808f9e4ad10b0cd8fd6ec296c432109f6f34427,Daniel,mail@danielluedecke.de,2025-07-02T20:54:30Z,Daniel,mail@danielluedecke.de,2025-07-02T20:54:30Z,fix,R/helpfunctions.R,False,True,True,False,1,0,1,"---FILE: R/helpfunctions.R---
@@ -298,6 +298,7 @@ crosstabsum <- function(x, grp, weight.by) {
     # if variables have two categories (2x2 table), use phi to calculate
     # the degree of association
   } else {
+    insight::check_if_installed(""MASS"")
     # check whether fisher's test or chi-squared should be printed
     if (is.null(fish)) {
       modsum <- as.character(as.expression("
strengejacke,sjPlot,fd36a1daf1be47d77fba9a65c36322cf8c0f1453,Daniel,mail@danielluedecke.de,2025-07-02T20:51:33Z,Daniel,mail@danielluedecke.de,2025-07-02T20:51:33Z,fix,DESCRIPTION;R/plot_xtab.R,False,True,True,False,2,0,2,"---FILE: DESCRIPTION---
@@ -58,6 +58,7 @@ Suggests:
     ggridges,
     httr,
     lme4,
+    MASS,
     nFactors,
     pscl,
     psych,

---FILE: R/plot_xtab.R---
@@ -115,6 +115,7 @@ plot_xtab <- function(
   y.offset = NULL,
   coord.flip = FALSE
 ) {
+  insight::check_if_installed(""MASS"")
   # --------------------------------------------------------
   # get variable name
   # --------------------------------------------------------"
strengejacke,sjPlot,83ab84d98155aef785f4ef7c1b50d2adc644643e,Daniel,mail@danielluedecke.de,2025-07-02T20:38:08Z,Daniel,mail@danielluedecke.de,2025-07-02T20:38:08Z,fix,DESCRIPTION,False,False,False,False,0,1,1,"---FILE: DESCRIPTION---
@@ -34,7 +34,6 @@ Imports:
     ggplot2 (>= 3.2.0),
     knitr,
     insight,
-    MASS,
     parameters,
     performance,
     purrr,"
strengejacke,sjPlot,59887d8a695363bfebb1f0ab0c969724108164d1,Daniel,mail@danielluedecke.de,2025-07-02T17:38:03Z,Daniel,mail@danielluedecke.de,2025-07-02T17:38:03Z,"fix, styler",R/plot_models.R;man/plot_models.Rd,False,True,True,False,145,112,257,"---FILE: R/plot_models.R---
@@ -68,60 +68,60 @@
 #' }
 #' @importFrom rlang .data
 #' @export
-plot_models <- function(...,
-                        transform = NULL,
-                        std.est = NULL,
-                        std.response = TRUE,
-                        rm.terms = NULL,
-                        title = NULL,
-                        m.labels = NULL,
-                        legend.title = ""Dependent Variables"",
-                        legend.pval.title = ""p-level"",
-                        axis.labels = NULL,
-                        axis.title = NULL,
-                        axis.lim = NULL,
-                        wrap.title = 50,
-                        wrap.labels = 25,
-                        wrap.legend.title = 20,
-                        grid.breaks = NULL,
-                        dot.size = 3,
-                        line.size = NULL,
-                        value.size = NULL,
-                        spacing = 0.4,
-                        colors = ""Set1"",
-                        show.values = FALSE,
-                        show.legend = TRUE,
-                        show.intercept = FALSE,
-                        show.p = TRUE,
-                        p.shape = FALSE,
-                        p.threshold = c(0.05, 0.01, 0.001),
-                        p.adjust = NULL,
-                        ci.lvl = .95,
-                        robust = FALSE,
-                        vcov.fun = NULL,
-                        vcov.type = c(""HC3"", ""const"", ""HC"", ""HC0"", ""HC1"", ""HC2"", ""HC4"", ""HC4m"", ""HC5""),
-                        vcov.args = NULL,
-                        vline.color = NULL,
-                        digits = 2,
-                        grid = FALSE,
-                        auto.label = TRUE,
-                        prefix.labels = c(""none"", ""varname"", ""label"")) {
+plot_models <- function(
+  ...,
+  transform = NULL,
+  std.est = NULL,
+  std.response = TRUE,
+  rm.terms = NULL,
+  title = NULL,
+  m.labels = NULL,
+  legend.title = ""Dependent Variables"",
+  legend.pval.title = ""p-level"",
+  axis.labels = NULL,
+  axis.title = NULL,
+  axis.lim = NULL,
+  wrap.title = 50,
+  wrap.labels = 25,
+  wrap.legend.title = 20,
+  grid.breaks = NULL,
+  dot.size = 3,
+  line.size = NULL,
+  value.size = NULL,
+  spacing = 0.4,
+  colors = ""Set1"",
+  show.values = FALSE,
+  show.legend = TRUE,
+  show.intercept = FALSE,
+  show.p = TRUE,
+  p.shape = FALSE,
+  p.threshold = c(0.05, 0.01, 0.001),
+  p.adjust = NULL,
+  ci.lvl = .95,
+  vcov.fun = NULL,
+  vcov.args = NULL,
+  vline.color = NULL,
+  digits = 2,
+  grid = FALSE,
+  auto.label = TRUE,
+  prefix.labels = c(""none"", ""varname"", ""label"")
+) {
   # retrieve list of fitted models
   input_list <- list(...)
-  names(input_list) <- unlist(lapply(match.call(expand.dots = FALSE)$`...`, deparse))
-
-  vcov.type <- match.arg(vcov.type)
-
-  if (isTRUE(robust)) {
-    vcov.type <- ""HC3""
-    vcov.fun <- ""vcovHC""
-  }
+  names(input_list) <- unlist(lapply(
+    match.call(expand.dots = FALSE)$`...`,
+    deparse
+  ))
 
   # check se-argument
   vcov.fun <- check_se_argument(se = vcov.fun, type = ""est"")
 
-  if (missing(line.size) || is.null(line.size)) line.size <- .7
-  if (missing(value.size) || is.null(value.size)) value.size <- 4
+  if (missing(line.size) || is.null(line.size)) {
+    line.size <- .7
+  }
+  if (missing(value.size) || is.null(value.size)) {
+    value.size <- 4
+  }
 
   # check length. if we have a list of fitted model, we need to ""unlist"" them
   if (length(input_list) == 1 && inherits(input_list[[1]], ""list"")) {
@@ -140,8 +140,9 @@ plot_models <- function(...,
   # get info on model family
   fam.info <- insight::model_info(input_list[[1]])
 
-  if (insight::is_multivariate(input_list[[1]]))
+  if (insight::is_multivariate(input_list[[1]])) {
     fam.info <- fam.info[[1]]
+  }
 
   # check whether estimates should be transformed or not
 
@@ -155,12 +156,10 @@ plot_models <- function(...,
     tf <- transform
   }
 
-
   # check for standardization, only applies to linear models
   # if (!any(inherits(input_list[[1]], c(""lm"", ""lmerMod"", ""lme""), which = TRUE) == 1))
   #   std.est <- NULL
 
-
   if (!is.null(std.est)) {
     std_method <- switch(std.est, ""std"" = ""refit"", ""std2"" = ""2sd"", ""refit"")
   } else {
@@ -178,7 +177,7 @@ plot_models <- function(...,
       tf = transform,
       type = ""est"",
       bpe = ""median"",
-      robust = list(vcov.fun = vcov.fun, vcov.type = vcov.type, vcov.args = vcov.args),
+      robust = list(vcov.fun = vcov.fun, vcov.args = vcov.args),
       facets = TRUE,
       show.zeroinf = FALSE,
       p.val = ""wald"",
@@ -191,20 +190,18 @@ plot_models <- function(...,
     )
   )
 
-
   # remove intercept from output
   if (!show.intercept) {
     fl <- purrr::map(fl, function(x) {
       rm.i <- string_ends_with(""(Intercept)"", x = x$term)
       if (length(rm.i)) {
-        dplyr::slice(x, !! -rm.i)
+        dplyr::slice(x, !!-rm.i)
       } else {
         x
       }
     })
   }
 
-
   # exponentiation
 
   if (!is.null(tf)) {
@@ -218,50 +215,54 @@ plot_models <- function(...,
     })
   }
 
-
   # add grouping index
   for (i in seq_along(fl)) {
-    fl[[i]] <- sjmisc::add_variables(fl[[i]], group = as.character(i), .after = Inf)
+    fl[[i]] <- sjmisc::add_variables(
+      fl[[i]],
+      group = as.character(i),
+      .after = Inf
+    )
   }
 
   # merge models to one data frame
   ff <- dplyr::bind_rows(fl)
 
-
   # remove further estimates
 
   rm.terms <- parse_terms(rm.terms)
   rems <- !(ff$term %in% rm.terms)
-  if (!is.null(rm.terms)) ff <- dplyr::filter(ff, !! rems)
-
+  if (!is.null(rm.terms)) {
+    ff <- dplyr::filter(ff, !!rems)
+  }
 
   # get labels of dependent variables, and wrap them if too long
 
-  if (is.null(m.labels)) m.labels <- sjlabelled::response_labels(input_list)
+  if (is.null(m.labels)) {
+    m.labels <- sjlabelled::response_labels(input_list)
+  }
   m.labels <- sjmisc::word_wrap(m.labels, wrap = wrap.labels)
 
-
   # make sure we have distinct labels, because we use them as
   # factor levels. else, duplicated factor levels will be dropped,
   # leading to missing groups in plot output
 
-  if (anyDuplicated(m.labels) > 0)
+  if (anyDuplicated(m.labels) > 0) {
     m.labels <- suppressMessages(tidy_label(m.labels))
+  }
 
   ff$group <- as.factor(ff$group)
   levels(ff$group) <- m.labels
 
-
   # reverse group, to plot correct order from top to bottom
   ff$group <- factor(ff$group, levels = rev(unique(ff$group)))
 
-
   # add p-asterisks to data
 
   ff$p.stars <- get_p_stars(ff$p.value, p.threshold)
   ff$p.label <- sprintf(""%.*f"", digits, ff$estimate)
-  if (show.p) ff$p.label <- sprintf(""%s %s"", ff$p.label, ff$p.stars)
-
+  if (show.p) {
+    ff$p.label <- sprintf(""%s %s"", ff$p.label, ff$p.stars)
+  }
 
   # axis limits and tick breaks for y-axis
 
@@ -275,11 +276,14 @@ plot_models <- function(...,
     max.est = max(ff$estimate)
   )
 
-
   # based on current ggplot theme, highlights vertical default line
 
   yintercept <- if (isTRUE(tf == ""exp"")) 1 else 0
-  layer_vertical_line <- geom_intercept_line(yintercept, axis.scaling, vline.color)
+  layer_vertical_line <- geom_intercept_line(
+    yintercept,
+    axis.scaling,
+    vline.color
+  )
 
   # reorder terms
   ff$term <- factor(ff$term, levels = rev(unique(ff$term)))
@@ -290,15 +294,29 @@ plot_models <- function(...,
 
   # set up base plot
 
-  if (p.shape)
-    p <- ggplot2::ggplot(ff, ggplot2::aes(x = .data$term, y = .data$estimate, colour = .data$group, shape = .data$p.stars))
-  else
-    p <- ggplot2::ggplot(ff, ggplot2::aes(x = .data$term, y = .data$estimate, colour = .data$group))
-
+  if (p.shape) {
+    p <- ggplot2::ggplot(
+      ff,
+      ggplot2::aes(
+        x = .data$term,
+        y = .data$estimate,
+        colour = .data$group,
+        shape = .data$p.stars
+      )
+    )
+  } else {
+    p <- ggplot2::ggplot(
+      ff,
+      ggplot2::aes(x = .data$term, y = .data$estimate, colour = .data$group)
+    )
+  }
 
   p <- p +
     layer_vertical_line +
-    ggplot2::geom_point(position = ggplot2::position_dodge(spacing), size = dot.size) +
+    ggplot2::geom_point(
+      position = ggplot2::position_dodge(spacing),
+      size = dot.size
+    ) +
     ggplot2::geom_errorbar(
       ggplot2::aes(ymin = .data$conf.low, ymax = .data$conf.high),
       position = ggplot2::position_dodge(spacing),
@@ -308,68 +326,85 @@ plot_models <- function(...,
     ggplot2::coord_flip() +
     ggplot2::guides(colour = ggplot2::guide_legend(reverse = TRUE))
 
-
   # show different shapes depending on p-value
 
-  if (p.shape) p <- p + ggplot2::scale_shape_manual(values = c(1, 16, 17, 15))
-
+  if (p.shape) {
+    p <- p + ggplot2::scale_shape_manual(values = c(1, 16, 17, 15))
+  }
 
   # add value labels
 
-  if (show.values) p <- p +
-    ggplot2::geom_text(
-      ggplot2::aes(label = .data$p.label),
-      position = ggplot2::position_dodge(spacing),
-      vjust = spacing * -1.5,
-      hjust = -.1,
-      show.legend = FALSE,
-      size = value.size
-    )
-
+  if (show.values) {
+    p <- p +
+      ggplot2::geom_text(
+        ggplot2::aes(label = .data$p.label),
+        position = ggplot2::position_dodge(spacing),
+        vjust = spacing * -1.5,
+        hjust = -.1,
+        show.legend = FALSE,
+        size = value.size
+      )
+  }
 
   # check axis labels
-  if (is.null(axis.labels) && isTRUE(auto.label))
+  if (is.null(axis.labels) && isTRUE(auto.label)) {
     axis.labels <- sjlabelled::term_labels(input_list, prefix = prefix.labels)
+  }
 
   # set axis labels
-  p <- p + ggplot2::scale_x_discrete(labels = sjmisc::word_wrap(axis.labels, wrap = wrap.labels))
-
+  p <- p +
+    ggplot2::scale_x_discrete(
+      labels = sjmisc::word_wrap(axis.labels, wrap = wrap.labels)
+    )
 
   # hide legend?
-  if (!show.legend) p <- p + ggplot2::guides(colour = ""none"", shape = ""none"")
+  if (!show.legend) {
+    p <- p + ggplot2::guides(colour = ""none"", shape = ""none"")
+  }
 
   # facets
-  if (grid) p <- p + ggplot2::facet_grid(~group)
-
+  if (grid) {
+    p <- p + ggplot2::facet_grid(~group)
+  }
 
   # we need transformed scale for exponentiated estimates
 
   if (isTRUE(tf == ""exp"")) {
-    p <- p + ggplot2::scale_y_continuous(
-      trans = ""log10"",
-      limits = axis.scaling$axis.lim,
-      breaks = axis.scaling$ticks,
-      labels = prettyNum
-    )
+    p <- p +
+      ggplot2::scale_y_continuous(
+        trans = ""log10"",
+        limits = axis.scaling$axis.lim,
+        breaks = axis.scaling$ticks,
+        labels = prettyNum
+      )
   } else {
-    p <- p + ggplot2::scale_y_continuous(
-      limits = axis.scaling$axis.lim,
-      breaks = axis.scaling$ticks,
-      labels = axis.scaling$ticks
-    )
+    p <- p +
+      ggplot2::scale_y_continuous(
+        limits = axis.scaling$axis.lim,
+        breaks = axis.scaling$ticks,
+        labels = axis.scaling$ticks
+      )
   }
 
-
   # set colors
-  p <- p + ggplot2::scale_colour_manual(values = col_check2(colors, length(m.labels)))
-
+  p <- p +
+    ggplot2::scale_colour_manual(values = col_check2(colors, length(m.labels)))
 
   # set axis and plot titles
 
   p <-
-    p + ggplot2::labs(
+    p +
+    ggplot2::labs(
       x = NULL,
-      y = sjmisc::word_wrap(estimate_axis_title(input_list[[1]], axis.title, type = ""est"", transform = !is.null(tf)), wrap = wrap.title),
+      y = sjmisc::word_wrap(
+        estimate_axis_title(
+          input_list[[1]],
+          axis.title,
+          type = ""est"",
+          transform = !is.null(tf)
+        ),
+        wrap = wrap.title
+      ),
       title = sjmisc::word_wrap(title, wrap = wrap.title),
       colour = sjmisc::word_wrap(legend.title, wrap = wrap.legend.title),
       shape = sjmisc::word_wrap(legend.pval.title, wrap = wrap.legend.title)

---FILE: man/plot_models.Rd---
@@ -34,9 +34,7 @@ plot_models(
   p.threshold = c(0.05, 0.01, 0.001),
   p.adjust = NULL,
   ci.lvl = 0.95,
-  robust = FALSE,
   vcov.fun = NULL,
-  vcov.type = c(""HC3"", ""const"", ""HC"", ""HC0"", ""HC1"", ""HC2"", ""HC4"", ""HC4m"", ""HC5""),
   vcov.args = NULL,
   vline.color = NULL,
   digits = 2,"
strengejacke,sjPlot,7744b4e4a52329e621b211c90a6fee65dce1ba34,Daniel,mail@danielluedecke.de,2025-07-02T13:40:06Z,Daniel,mail@danielluedecke.de,2025-07-02T13:40:06Z,fix,NAMESPACE;R/sjPlotCorr.R;R/sjPlotPearsonsChi2Test.R;_pkgdown.yml;man/sjp.corr.Rd,False,True,True,False,5,335,340,"---FILE: NAMESPACE---
@@ -43,7 +43,6 @@ export(scale_fill_sjplot)
 export(set_theme)
 export(show_sjplot_pals)
 export(sjp.chi2)
-export(sjp.corr)
 export(sjp.poly)
 export(sjplot)
 export(sjplot_pal)

---FILE: R/sjPlotCorr.R---
@@ -1,232 +0,0 @@
-#' @title Plot correlation matrix
-#' @name sjp.corr
-#'
-#' @description Plot correlation matrix as ellipses or tiles.
-#'
-#' @param data Matrix with correlation coefficients as returned by the
-#'          \code{\link{cor}}-function, or a \code{data.frame} of variables where
-#'          correlations between columns should be computed.
-#' @param sort.corr Logical, if \code{TRUE} (default), the axis labels are sorted
-#'          according to the correlation strength. If \code{FALSE}, axis labels
-#'          appear in order of how variables were included in the cor-computation or
-#'          data frame.
-#' @param decimals Indicates how many decimal values after comma are printed when
-#'          the values labels are shown. Default is 3. Only applies when
-#'          \code{show.values = TRUE}.
-#' @param na.deletion Indicates how missing values are treated. May be either
-#'          \code{""listwise""} (default) or \code{""pairwise""}. May be
-#'          abbreviated.
-#' @param corr.method Indicates the correlation computation method. May be one of
-#'          \code{""pearson""} (default), \code{""spearman""} or \code{""kendall""}.
-#'          May be abbreviated.
-#' @param p.numeric Logical, if \code{TRUE}, the p-values are printed
-#'          as numbers. If \code{FALSE} (default), asterisks are used.
-#'
-#' @inheritParams plot_grpfrq
-#' @inheritParams plot_gpt
-#'
-#' @return (Insisibily) returns the ggplot-object with the complete plot (\code{plot}) as well as the data frame that
-#'           was used for setting up the ggplot-object (\code{df}) and the original correlation matrix
-#'           (\code{corr.matrix}).
-#'
-#' @note If \code{data} is a matrix with correlation coefficients as returned by
-#'       the \code{\link{cor}}-function, p-values can't be computed.
-#'       Thus, \code{show.p} and \code{p.numeric}
-#'       only have an effect if \code{data} is a \code{\link{data.frame}}.
-#'
-#' @details Required argument is either a \code{\link{data.frame}} or a matrix with correlation coefficients
-#'            as returned by the \code{\link{cor}}-function. In case of ellipses, the
-#'            ellipses size indicates the strength of the correlation. Furthermore,
-#'            blue and red colors indicate positive or negative correlations, where
-#'            stronger correlations are darker.
-#'
-#' @export
-sjp.corr <- function(data,
-                     title = NULL,
-                     axis.labels = NULL,
-                     sort.corr = TRUE,
-                     decimals = 3,
-                     na.deletion = c(""listwise"", ""pairwise""),
-                     corr.method = c(""pearson"", ""spearman"", ""kendall""),
-                     geom.colors = ""RdBu"",
-                     wrap.title = 50,
-                     wrap.labels = 20,
-                     show.legend = FALSE,
-                     legend.title = NULL,
-                     show.values = TRUE,
-                     show.p = TRUE,
-                     p.numeric = FALSE) {
-  .Deprecated(msg = ""'sjp.corr' is deprecated. Please use 'correlation::correlation()' and its related plot()-method."")
-
-  # --------------------------------------------------------
-  # check p-value-style option
-  # --------------------------------------------------------
-  opt <- getOption(""p_zero"")
-  if (is.null(opt) || opt == FALSE) {
-    p_zero <- """"
-  } else {
-    p_zero <- ""0""
-  }
-  # --------------------------------------------------------
-  # check args
-  # --------------------------------------------------------
-  na.deletion <- match.arg(na.deletion)
-  corr.method <- match.arg(corr.method)
-  # --------------------------------------------------------
-  # try to automatically set labels is not passed as argument
-  # --------------------------------------------------------
-  if (is.null(axis.labels) && is.data.frame(data)) {
-    axis.labels <- unname(sjlabelled::get_label(data, def.value = colnames(data)))
-  }
-  # ----------------------------
-  # set color palette
-  # ----------------------------
-  if (is.brewer.pal(geom.colors[1])) {
-    geom.colors <- scales::brewer_pal(palette = geom.colors[1])(5)
-  } else if (geom.colors[1] == ""gs"") {
-    geom.colors <- scales::grey_pal()(5)
-  }
-  # ----------------------------
-  # check if user has passed a data frame
-  # or a pca object
-  # ----------------------------
-  if (any(class(data) == ""matrix"")) {
-    corr <- data
-    cpvalues <- NULL
-  } else {
-    # missing deletion corresponds to
-    # SPSS listwise
-    if (na.deletion == ""listwise"") {
-      data <- stats::na.omit(data)
-      corr <- stats::cor(data, method = corr.method)
-    }
-    # missing deletion corresponds to
-    # SPSS pairwise
-    else {
-      corr <- stats::cor(data, method = corr.method, use = ""pairwise.complete.obs"")
-    }
-    #---------------------------------------
-    # if we have a data frame as argument,
-    # compute p-values of significances
-    #---------------------------------------
-    computePValues <- function(df) {
-      cp <- c()
-      for (i in seq_len(ncol(df))) {
-        pv <- c()
-        for (j in seq_len(ncol(df))) {
-          test <- suppressWarnings(stats::cor.test(df[[i]], df[[j]],
-                                                   alternative = ""two.sided"",
-                                                   method = corr.method))
-          pv <- c(pv, round(test$p.value, 4))
-        }
-        cp <- rbind(cp, pv)
-      }
-      return(cp)
-    }
-    cpvalues <- computePValues(data)
-  }
-  # ----------------------------
-  # check if user defined labels have been supplied
-  # if not, use variable names from data frame
-  # ----------------------------
-  if (is.null(axis.labels)) axis.labels <- row.names(corr)
-  # ----------------------------
-  # Prepare length of title and labels
-  # ----------------------------
-  # check length of diagram title and split longer string at into new lines
-  if (!is.null(title)) title <- sjmisc::word_wrap(title, wrap.title)
-  # check length of x-axis-labels and split longer strings at into new lines
-  if (!is.null(axis.labels)) axis.labels <- sjmisc::word_wrap(axis.labels, wrap.labels)
-  # --------------------------------------------------------
-  # order correlations from highest to lowest correlation coefficient
-  # --------------------------------------------------------
-  if (sort.corr) {
-    neword <- order(corr[1, ])
-    orderedCorr <- corr[neword, neword]
-    # order variable labels as well
-    axis.labels <- axis.labels[neword]
-    if (!is.null(cpvalues)) cpvalues <- cpvalues[neword, neword]
-  } else {
-    cl <- ncol(corr)
-    orderedCorr <- corr[cl:1, cl:1]
-    axis.labels <- rev(axis.labels)
-    if (!is.null(cpvalues)) cpvalues <- cpvalues[cl:1, cl:1]
-  }
-  # --------------------------------------------------------
-  # prepare a ordering-index-column needed for the data frame
-  # that is passed to the ggplot
-  # --------------------------------------------------------
-  yo <- c()
-  for (i in seq_len(nrow(corr))) {
-    yo <- c(yo, rep(i, nrow(corr)))
-  }
-  # --------------------------------------------------------
-  # melt correlation matrix and create data frame
-  # --------------------------------------------------------
-  orderedCorr <- tidyr::gather(data.frame(orderedCorr), ""var"", ""value"",
-                               !! seq_len(ncol(orderedCorr)), factor_key = TRUE)
-  # orderedCorr <- melt(orderedCorr)
-  if (!is.null(cpvalues))
-    cpvalues <- tidyr::gather(data.frame(cpvalues), ""var"", ""value"",
-                              !! seq_len(ncol(cpvalues)), factor_key = TRUE)
-  # if (!is.null(cpvalues)) cpvalues <- melt(cpvalues)
-  # bind additional information like order for x- and y-axis
-  # as well as the size of plotted points
-  orderedCorr <- cbind(orderedCorr, ordx = seq_len(nrow(corr)), ordy = yo)
-  # --------------------------------------------------------
-  # add column with significance value
-  # --------------------------------------------------------
-  if (!is.null(cpvalues)) {
-    if (!p.numeric) {
-      cpv <- sapply(cpvalues$value, get_p_stars)
-    } else {
-      cpv <- sapply(cpvalues$value, function(x) {
-        if (x < 0.001)
-          x <- sprintf(""\n(< %s.001)"", p_zero)
-        else
-          x <- sub(""0"", p_zero, sprintf(""\n(%.*f)"", decimals, x))
-      })
-    }
-  } else {
-    cpv <- """"
-  }
-  orderedCorr$ps <- cpv
-  # --------------------------------------------------------
-  # set visibility of labels
-  # --------------------------------------------------------
-  if (!show.values) {
-    orderedCorr$val.labels <- """"
-  } else {
-    if (show.p) {
-      orderedCorr$val.labels <- sprintf(""%.*f%s"", decimals, orderedCorr$value, orderedCorr$ps)
-    } else {
-      orderedCorr$val.labels <- sprintf(""%.*f"", decimals, orderedCorr$value)
-    }
-  }
-  orderedCorr$val.labels[orderedCorr$ordx >= orderedCorr$ordy] <- NA
-
-  orderedCorr$ordx <- as.factor(orderedCorr$ordx)
-  orderedCorr$ordy <- as.factor(orderedCorr$ordy)
-  message(sprintf(""Computing correlation using %s-method with %s-deletion..."", corr.method, na.deletion))
-  # --------------------------------------------------------
-  # start with base plot object here
-  # --------------------------------------------------------
-  corrPlot <- ggplot2::ggplot(orderedCorr, ggplot2::aes_string(x = ""ordx"", y = ""ordy"", fill = ""value"", label = ""val.labels"")) +
-    ggplot2::geom_tile(size = 0, colour = ""black"") +
-  # fill gradient colour from distinct color brewer palette. negative correlations are dark
-  # red, positive corr. are dark blue, and they become lighter the closer they are to a
-  # correlation coefficient of zero
-    ggplot2::scale_x_discrete(labels = axis.labels, breaks = seq_len(length(axis.labels))) +
-    ggplot2::scale_y_discrete(labels = axis.labels, breaks = seq_len(length(axis.labels))) +
-    # set limits to (-1,1) to make sure the whole color palette is used. this
-    # is the colour scale for geoms
-    ggplot2::scale_fill_gradientn(colours = geom.colors, limits = c(-1,1)) +
-    ggplot2::geom_text(size = 3.5, colour = ""black"") +
-    ggplot2::labs(title = title, x = NULL, y = NULL)
-  if (show.legend)
-    corrPlot <- corrPlot + ggplot2::guides(fill = legend.title)
-  else
-    corrPlot <- corrPlot + ggplot2::guides(fill = ""none"")
-
-  corrPlot
-}

---FILE: R/sjPlotPearsonsChi2Test.R---
@@ -93,11 +93,11 @@ sjp.chi2 <- function(
   # --------------------------------------------------------
   chiPlot <- ggplot2::ggplot(
     data = m,
-    ggplot2::aes_string(
-      x = ""Row"",
-      y = ""Column"",
-      fill = ""p.value"",
-      label = ""p.value""
+    ggplot2::aes(
+      x = .data$Row,
+      y = .data$Column,
+      fill = .data$p.value,
+      label = .data$p.value
     )
   ) +
     ggplot2::geom_tile() +

---FILE: _pkgdown.yml---
@@ -46,7 +46,6 @@ reference:
   - plot_grpfrq
   - plot_xtab
   - sjp.chi2
-  - sjp.corr
   - sjplot
 
 - title: ""Descriptive Statistics Tables""

---FILE: man/sjp.corr.Rd---
@@ -1,96 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/sjPlotCorr.R
-\name{sjp.corr}
-\alias{sjp.corr}
-\title{Plot correlation matrix}
-\usage{
-sjp.corr(
-  data,
-  title = NULL,
-  axis.labels = NULL,
-  sort.corr = TRUE,
-  decimals = 3,
-  na.deletion = c(""listwise"", ""pairwise""),
-  corr.method = c(""pearson"", ""spearman"", ""kendall""),
-  geom.colors = ""RdBu"",
-  wrap.title = 50,
-  wrap.labels = 20,
-  show.legend = FALSE,
-  legend.title = NULL,
-  show.values = TRUE,
-  show.p = TRUE,
-  p.numeric = FALSE
-)
-}
-\arguments{
-\item{data}{Matrix with correlation coefficients as returned by the
-\code{\link{cor}}-function, or a \code{data.frame} of variables where
-correlations between columns should be computed.}
-
-\item{title}{character vector, used as plot title. Depending on plot type and function,
-will be set automatically. If \code{title = """"}, no title is printed.
-For effect-plots, may also be a character vector of length > 1,
-to define titles for each sub-plot or facet.}
-
-\item{axis.labels}{character vector with labels used as axis labels. Optional
-argument, since in most cases, axis labels are set automatically.}
-
-\item{sort.corr}{Logical, if \code{TRUE} (default), the axis labels are sorted
-according to the correlation strength. If \code{FALSE}, axis labels
-appear in order of how variables were included in the cor-computation or
-data frame.}
-
-\item{decimals}{Indicates how many decimal values after comma are printed when
-the values labels are shown. Default is 3. Only applies when
-\code{show.values = TRUE}.}
-
-\item{na.deletion}{Indicates how missing values are treated. May be either
-\code{""listwise""} (default) or \code{""pairwise""}. May be
-abbreviated.}
-
-\item{corr.method}{Indicates the correlation computation method. May be one of
-\code{""pearson""} (default), \code{""spearman""} or \code{""kendall""}.
-May be abbreviated.}
-
-\item{geom.colors}{user defined color for geoms. See 'Details' in \code{\link{plot_grpfrq}}.}
-
-\item{wrap.title}{numeric, determines how many chars of the plot title are displayed in
-one line and when a line break is inserted.}
-
-\item{wrap.labels}{numeric, determines how many chars of the value, variable or axis
-labels are displayed in one line and when a line break is inserted.}
-
-\item{show.legend}{logical, if \code{TRUE}, and depending on plot type and
-function, a legend is added to the plot.}
-
-\item{legend.title}{character vector, used as title for the plot legend.}
-
-\item{show.values}{Logical, whether values should be plotted or not.}
-
-\item{show.p}{Logical, adds significance levels to values, or value and
-variable labels.}
-
-\item{p.numeric}{Logical, if \code{TRUE}, the p-values are printed
-as numbers. If \code{FALSE} (default), asterisks are used.}
-}
-\value{
-(Insisibily) returns the ggplot-object with the complete plot (\code{plot}) as well as the data frame that
-          was used for setting up the ggplot-object (\code{df}) and the original correlation matrix
-          (\code{corr.matrix}).
-}
-\description{
-Plot correlation matrix as ellipses or tiles.
-}
-\details{
-Required argument is either a \code{\link{data.frame}} or a matrix with correlation coefficients
-           as returned by the \code{\link{cor}}-function. In case of ellipses, the
-           ellipses size indicates the strength of the correlation. Furthermore,
-           blue and red colors indicate positive or negative correlations, where
-           stronger correlations are darker.
-}
-\note{
-If \code{data} is a matrix with correlation coefficients as returned by
-      the \code{\link{cor}}-function, p-values can't be computed.
-      Thus, \code{show.p} and \code{p.numeric}
-      only have an effect if \code{data} is a \code{\link{data.frame}}.
-}"
strengejacke,sjPlot,b0591d5a9dd7ac296e13091e3053262c640d483a,Daniel,mail@danielluedecke.de,2025-07-02T09:37:32Z,Daniel,mail@danielluedecke.de,2025-07-02T09:37:32Z,fix,R/plot_kfold_cv.R,False,True,True,False,48,44,92,"---FILE: R/plot_kfold_cv.R---
@@ -94,26 +94,28 @@ plot_kfold_cv <- function(data, formula, k = 5, fit) {
           data.frame(train = I(list(out[[1]])), test = I(list(out$test)))
         })
       )
-      res <- kfolds |>
-        dplyr::mutate(
-          model = purrr::map(
-            .data$train,
-            ~ stats::glm(
-              formula,
-              data = .x,
-              family = stats::poisson(link = ""log"")
-            )
+      res <- dplyr::mutate(
+        kfolds,
+        model = purrr::map(
+          .data$train,
+          ~ stats::glm(
+            formula,
+            data = .x,
+            family = stats::poisson(link = ""log"")
           )
-        ) |>
-        dplyr::mutate(
-          residuals = purrr::map(
-            .data$model,
-            ~ stats::residuals(.x, ""deviance"")
-          )
-        ) |>
-        dplyr::mutate(
-          .response = purrr::map(.data$model, ~ insight::get_response(.x))
         )
+      )
+      res <- dplyr::mutate(,
+        res,
+        residuals = purrr::map(
+          .data$model,
+          ~ stats::residuals(.x, ""deviance"")
+        )
+      )
+      res <- dplyr::mutate(
+        res,
+        .response = purrr::map(.data$model, ~ insight::get_response(.x))
+      )
       # for negative binomial models, show deviance residuals
     } else if (inherits(fit, ""negbin"")) {
       # create cross-validated test-training pairs, run poisson-model on each
@@ -125,23 +127,25 @@ plot_kfold_cv <- function(data, formula, k = 5, fit) {
           data.frame(train = I(list(out[[1]])), test = I(list(out$test)))
         })
       )
-      res <- kfolds |>
-        dplyr::mutate(
-          model = purrr::map(.data$train, ~ MASS::glm.nb(formula, data = .))
-        ) |>
-        dplyr::mutate(
-          residuals = purrr::map(
-            .data$model,
-            ~ stats::residuals(.x, ""deviance"")
-          )
-        ) |>
-        dplyr::mutate(
-          .response = purrr::map(.data$model, ~ insight::get_response(.x))
+      res <- dplyr::mutate(
+        kfolds,
+        model = purrr::map(.data$train, ~ MASS::glm.nb(formula, data = .))
+      )
+      res <- dplyr::mutate(
+        res,
+        residuals = purrr::map(
+          .data$model,
+          ~ stats::residuals(.x, ""deviance"")
         )
+      )
+      res <- dplyr::mutate(
+        res,
+        .response = purrr::map(.data$model, ~ insight::get_response(.x))
+      )
     }
 
     # unnest residuals and response values
-    res <- suppressWarnings(res |> tidyr::unnest(""residuals"", .data$.response))
+    res <- suppressWarnings(tidyr::unnest(res, ""residuals"", .data$.response))
   } else {
     # create cross-validated test-training pairs, run linear model on each
     # pair, get predicted values and quality measures for models fitted on the
@@ -153,24 +157,24 @@ plot_kfold_cv <- function(data, formula, k = 5, fit) {
         data.frame(train = I(list(out[[1]])), test = I(list(out$test)))
       })
     )
-    res <- kfolds |>
-      dplyr::mutate(
-        model = purrr::map(.data$train, ~ stats::lm(formula, data = .))
-      ) |>
-      dplyr::mutate(
-        predicted = purrr::map2(.data$model, .data$test, function(.x, .y) {
-          out <- data.frame(.fitted = stats::predict(.x, newdata = .y))
-          cbind(.y, out)
-        })
-      ) |>
-      tidyr::unnest(cols = .data$predicted)
+    res <- dplyr::mutate(
+      kfolds,
+      model = purrr::map(.data$train, ~ stats::lm(formula, data = .))
+    )
+    res <- dplyr::mutate(
+      res,
+      predicted = purrr::map2(.data$model, .data$test, function(.x, .y) {
+        out <- data.frame(.fitted = stats::predict(.x, newdata = .y))
+        cbind(.y, out)
+      })
+    )
+    res <- tidyr::unnest(res, cols = .data$predicted)
 
     # make sure that response vector has an identifiably name
     colnames(res)[which(colnames(res) == deparse(resp))] <- "".response""
 
     # compute residuals for each k-fold model
-    res <- res |>
-      dplyr::mutate(residuals = .data$.response - .data$.fitted)
+    res <- dplyr::mutate(res, residuals = .data$.response - .data$.fitted)
   }
 
   # plot response against residuals, to see where our model over- or"
strengejacke,sjPlot,4416801acfee7c7946622c2efec0df255a8362a4,Daniel,mail@danielluedecke.de,2025-07-02T05:47:42Z,Daniel,mail@danielluedecke.de,2025-07-02T05:47:42Z,fix,vignettes/custplot.Rmd,True,False,True,False,2,2,4,"---FILE: vignettes/custplot.Rmd---
@@ -122,7 +122,7 @@ plot_grpfrq(efc$e42dep, efc$e16sex, expand.grid = TRUE)
 
 ## Theme options
 
-You can use any pre-defined theme from ggplot, like `theme_bw()`, `theme_classic()` or `ggplot2::theme_minimal()` as default theme.
+You can use any pre-defined theme from ggplot, like `theme_bw()`, `theme_classic()` or `theme_minimal()` as default theme.
 
 ```{r}
 sjPlot::set_theme(base = theme_light())
@@ -197,7 +197,7 @@ plot_grpfrq(
   coord.flip = TRUE,
   show.axis.values = FALSE
 ) +
-  theme(axis.line.x = ggplot2::element_line(color = ""white""))
+  theme(axis.line.x = element_line(color = ""white""))
 ```
 
 ## Plot legend"
strengejacke,sjPlot,23f396e7d43a81ae3ac1d498775eeb7e827d5aa5,Daniel,mail@danielluedecke.de,2025-07-02T05:46:04Z,Daniel,mail@danielluedecke.de,2025-07-02T05:46:04Z,fix note,R/plot_kfold_cv.R;R/plot_type_eff.R;R/sjPlotSetTheme.R;R/sjplot_themes.R,False,True,True,False,131,78,209,"---FILE: R/plot_kfold_cv.R---
@@ -47,7 +47,9 @@
 #' @export
 plot_kfold_cv <- function(data, formula, k = 5, fit) {
   # make sure that data is a data frame
-  if (!is.data.frame(data)) data <- as.data.frame(data)
+  if (!is.data.frame(data)) {
+    data <- as.data.frame(data)
+  }
 
   # check if a formula was passed as argument...
   if (!missing(formula)) {
@@ -74,53 +76,93 @@ plot_kfold_cv <- function(data, formula, k = 5, fit) {
   # get name of response variable and get variable label, if
   # there is any... used for labelling plot axis
   resp <- formula[[2]]
-  resp.name <- sjlabelled::get_label(data[[deparse(resp)]], def.value = deparse(resp))
+  resp.name <- sjlabelled::get_label(
+    data[[deparse(resp)]],
+    def.value = deparse(resp)
+  )
 
   # check if fit parameter was specified, and we have a model family
   if (!is.null(fam)) {
     # for poisson models, show deviance residuals
     if (fam$family == ""poisson"") {
       # create cross-validated test-training pairs, run poisson-model on each
       # pair, get deviance residuals and response value
-      kfolds <- do.call(rbind, lapply(1:k, function(i) {
-        out <- datawizard::data_partition(data, training_proportion = .8)
-        data.frame(train = I(list(out[[1]])), test = I(list(out$test)))
-      }))
+      kfolds <- do.call(
+        rbind,
+        lapply(1:k, function(i) {
+          out <- datawizard::data_partition(data, training_proportion = .8)
+          data.frame(train = I(list(out[[1]])), test = I(list(out$test)))
+        })
+      )
       res <- kfolds |>
-        dplyr::mutate(model = purrr::map(.data$train, ~ stats::glm(formula, data = .x, family = stats::poisson(link = ""log"")))) |>
-        dplyr::mutate(residuals = purrr::map(.data$model, ~ stats::residuals(.x, ""deviance""))) |>
-        dplyr::mutate(.response = purrr::map(.data$model, ~ insight::get_response(.x)))
-    # for negative binomial models, show deviance residuals
+        dplyr::mutate(
+          model = purrr::map(
+            .data$train,
+            ~ stats::glm(
+              formula,
+              data = .x,
+              family = stats::poisson(link = ""log"")
+            )
+          )
+        ) |>
+        dplyr::mutate(
+          residuals = purrr::map(
+            .data$model,
+            ~ stats::residuals(.x, ""deviance"")
+          )
+        ) |>
+        dplyr::mutate(
+          .response = purrr::map(.data$model, ~ insight::get_response(.x))
+        )
+      # for negative binomial models, show deviance residuals
     } else if (inherits(fit, ""negbin"")) {
       # create cross-validated test-training pairs, run poisson-model on each
       # pair, get deviance residuals and response value
-      kfolds <- do.call(rbind, lapply(1:k, function(i) {
-        out <- datawizard::data_partition(data, training_proportion = .8)
-        data.frame(train = I(list(out[[1]])), test = I(list(out$test)))
-      }))
+      kfolds <- do.call(
+        rbind,
+        lapply(1:k, function(i) {
+          out <- datawizard::data_partition(data, training_proportion = .8)
+          data.frame(train = I(list(out[[1]])), test = I(list(out$test)))
+        })
+      )
       res <- kfolds |>
-        dplyr::mutate(model = purrr::map(.data$train, ~ MASS::glm.nb(formula, data = .))) |>
-        dplyr::mutate(residuals = purrr::map(.data$model, ~ stats::residuals(.x, ""deviance""))) |>
-        dplyr::mutate(.response = purrr::map(.data$model, ~ insight::get_response(.x)))
+        dplyr::mutate(
+          model = purrr::map(.data$train, ~ MASS::glm.nb(formula, data = .))
+        ) |>
+        dplyr::mutate(
+          residuals = purrr::map(
+            .data$model,
+            ~ stats::residuals(.x, ""deviance"")
+          )
+        ) |>
+        dplyr::mutate(
+          .response = purrr::map(.data$model, ~ insight::get_response(.x))
+        )
     }
 
     # unnest residuals and response values
-    res <- suppressWarnings(res |> tidyr::unnest(residuals, .data$.response))
-
+    res <- suppressWarnings(res |> tidyr::unnest(""residuals"", .data$.response))
   } else {
     # create cross-validated test-training pairs, run linear model on each
     # pair, get predicted values and quality measures for models fitted on the
     # train data
-    kfolds <- do.call(rbind, lapply(1:k, function(i) {
-      out <- datawizard::data_partition(data, training_proportion = .8)
-      data.frame(train = I(list(out[[1]])), test = I(list(out$test)))
-    }))
+    kfolds <- do.call(
+      rbind,
+      lapply(1:k, function(i) {
+        out <- datawizard::data_partition(data, training_proportion = .8)
+        data.frame(train = I(list(out[[1]])), test = I(list(out$test)))
+      })
+    )
     res <- kfolds |>
-      dplyr::mutate(model = purrr::map(.data$train, ~ stats::lm(formula, data = .))) |>
-      dplyr::mutate(predicted = purrr::map2(.data$model, .data$test, function(.x, .y) {
-        out <- data.frame(.fitted = stats::predict(.x, newdata = .y))
-        cbind(.y, out)
-      })) |>
+      dplyr::mutate(
+        model = purrr::map(.data$train, ~ stats::lm(formula, data = .))
+      ) |>
+      dplyr::mutate(
+        predicted = purrr::map2(.data$model, .data$test, function(.x, .y) {
+          out <- data.frame(.fitted = stats::predict(.x, newdata = .y))
+          cbind(.y, out)
+        })
+      ) |>
       tidyr::unnest(cols = .data$predicted)
 
     # make sure that response vector has an identifiably name
@@ -133,7 +175,10 @@ plot_kfold_cv <- function(data, formula, k = 5, fit) {
 
   # plot response against residuals, to see where our model over- or
   # underestimates the outcome
-  p <- ggplot2::ggplot(data = res, ggplot2::aes(x = .data$.response, y = .data$residuals)) +
+  p <- ggplot2::ggplot(
+    data = res,
+    ggplot2::aes(x = .data$.response, y = .data$residuals)
+  ) +
     ggplot2::geom_hline(yintercept = 0) +
     ggplot2::geom_point() +
     ggplot2::stat_smooth(method = ""loess"") +

---FILE: R/plot_type_eff.R---
@@ -1,29 +1,28 @@
-plot_type_eff <- function(type,
-                          model,
-                          terms,
-                          ci.lvl,
-                          pred.type,
-                          facets,
-                          show.data,
-                          jitter,
-                          geom.colors,
-                          axis.title,
-                          title,
-                          legend.title,
-                          axis.lim,
-                          case,
-                          show.legend,
-                          dot.size,
-                          line.size,
-                          ...) {
-
-  if (missing(facets) || is.null(facets)) facets <- FALSE
+plot_type_eff <- function(
+  type,
+  model,
+  terms,
+  ci.lvl,
+  pred.type,
+  facets,
+  show.data,
+  jitter,
+  geom.colors,
+  axis.title,
+  title,
+  legend.title,
+  axis.lim,
+  case,
+  show.legend,
+  dot.size,
+  line.size,
+  ...
+) {
+  if (missing(facets) || is.null(facets)) {
+    facets <- FALSE
+  }
 
-  pred.type <- switch(pred.type,
-    fe = ""fixed"",
-    re = ""random"",
-    pred.type
-  )
+  pred.type <- switch(pred.type, fe = ""fixed"", re = ""random"", pred.type)
 
   if (type == ""pred"") {
     dat <- ggeffects::ggpredict(
@@ -50,8 +49,9 @@ plot_type_eff <- function(type,
     )
   }
 
-
-  if (is.null(dat)) return(NULL)
+  if (is.null(dat)) {
+    return(NULL)
+  }
 
   # evaluate dots-arguments
   alpha <- .15
@@ -60,14 +60,25 @@ plot_type_eff <- function(type,
   log.y <- FALSE
 
   # save number of terms, needed later
-  n.terms <- length(insight::find_predictors(model, component = ""conditional"", flatten = TRUE))
+  n.terms <- length(insight::find_predictors(
+    model,
+    component = ""conditional"",
+    flatten = TRUE
+  ))
 
   add.args <- lapply(match.call(expand.dots = FALSE)$`...`, function(x) x)
-  if (""alpha"" %in% names(add.args)) alpha <- eval(add.args[[""alpha""]])
-  if (""dodge"" %in% names(add.args)) dodge <- eval(add.args[[""dodge""]])
-  if (""dot.alpha"" %in% names(add.args)) dot.alpha <- eval(add.args[[""dot.alpha""]])
-  if (""log.y"" %in% names(add.args)) log.y <- eval(add.args[[""log.y""]])
-
+  if (""alpha"" %in% names(add.args)) {
+    alpha <- eval(add.args[[""alpha""]])
+  }
+  if (""dodge"" %in% names(add.args)) {
+    dodge <- eval(add.args[[""dodge""]])
+  }
+  if (""dot.alpha"" %in% names(add.args)) {
+    dot.alpha <- eval(add.args[[""dot.alpha""]])
+  }
+  if (""log.y"" %in% names(add.args)) {
+    log.y <- eval(add.args[[""log.y""]])
+  }
 
   # select color palette
   if (geom.colors[1] != ""bw"") {
@@ -84,7 +95,6 @@ plot_type_eff <- function(type,
     geom.colors <- col_check2(geom.colors, .ngrp)
   }
 
-
   p <- graphics::plot(
     dat,
     show_ci = !is.na(ci.lvl),
@@ -103,7 +113,6 @@ plot_type_eff <- function(type,
     line_size = line.size
   )
 
-
   # set axis and plot titles
   if (!is.null(axis.title) && !is.null(terms)) {
     if (length(axis.title) > 1) {
@@ -113,17 +122,21 @@ plot_type_eff <- function(type,
     }
   } else if (!is.null(axis.title) && is.null(terms)) {
     if (length(axis.title) > 1) {
-      p <- purrr::map(p, ~ .x + ggplot2::labs(x = axis.title[1], y = axis.title[2]))
+      p <- purrr::map(
+        p,
+        ~ .x + ggplot2::labs(x = axis.title[1], y = axis.title[2])
+      )
     } else {
       p <- purrr::map(p, ~ .x + ggplot2::labs(y = axis.title))
     }
   }
 
   # set axis and plot titles
-  if (!is.null(title) && !is.null(terms))
+  if (!is.null(title) && !is.null(terms)) {
     p <- p + ggplot2::ggtitle(title)
-  else if (!is.null(title) && is.null(terms))
+  } else if (!is.null(title) && is.null(terms)) {
     p <- purrr::map(p, ~ .x + ggplot2::ggtitle(title))
+  }
 
   # set axis and plot titles
   if (!is.null(legend.title)) {
@@ -136,15 +149,14 @@ plot_type_eff <- function(type,
     }
   }
 
-
   # set axis limits
   if (!is.null(axis.lim)) {
-    if (is.list(axis.lim))
-      p <- p + xlim(axis.lim[[1]]) + ylim(axis.lim[[2]])
-    else
-      p <- p + ylim(axis.lim)
+    if (is.list(axis.lim)) {
+      p <- p + ggplot2::xlim(axis.lim[[1]]) + ggplot2::ylim(axis.lim[[2]])
+    } else {
+      p <- p + ggplot2::ylim(axis.lim)
+    }
   }
 
-
   p
 }

---FILE: R/sjPlotSetTheme.R---
@@ -338,10 +338,6 @@ set_theme <- function(base = ggplot2::theme_grey(),
   # check if theme-preset is requested
   # ----------------------------------------
   if (
-    !is.null(theme) && any(class(theme) == ""theme"") && any(class(theme) == ""gg"")
-  ) {
-    ggplot2::theme_set(theme)
-  } else if (
     !is.null(base) && any(class(base) == ""theme"") && any(class(base) == ""gg"")
   ) {
     # ----------------------------------------

---FILE: R/sjplot_themes.R---
@@ -314,7 +314,7 @@ scale_fill_sjplot <- function(palette = ""metro"", discrete = TRUE, reverse = FALS
   pal <- get_sjplot_pal(palette = palette, reverse = reverse)
 
   if (discrete) {
-    discrete_scale(""fill"", paste0(""sjplot_pal_"", palette), palette = pal, ...)
+    ggplot2::discrete_scale(""fill"", paste0(""sjplot_pal_"", palette), palette = pal, ...)
   } else {
     ggplot2::scale_fill_gradientn(colours = pal(256), ...)
   }"
strengejacke,sjPlot,5df90ea779f17b5c42fc18fb0842f3039e7c869b,Daniel,mail@danielluedecke.de,2025-07-01T21:11:37Z,Daniel,mail@danielluedecke.de,2025-07-01T21:11:37Z,fix,R/plot_diag_stan.R;R/plot_grpfrq.R;R/plot_type_eff.R;R/plot_type_int.R;R/save_plot.R;man/save_plot.Rd;man/set_theme.Rd;vignettes/blackwhitefigures.Rmd;vignettes/plot_model_estimates.Rmd,True,True,True,False,25,25,50,"---FILE: R/plot_diag_stan.R---
@@ -139,7 +139,7 @@ plot_diag_stan <- function(
           ~Term,
           scales = ""free"",
           labeller = ggplot2::labeller(
-            .default = label_value,
+            .default = ggplot2::label_value,
             Term = axis.labels
           )
         )

---FILE: R/plot_grpfrq.R---
@@ -506,7 +506,7 @@ plot_grpfrq <- function(
       !is.null(axis.labels) &&
         length(axis.labels) > dplyr::n_distinct(mydf$group, na.rm = TRUE)
     ) {
-      axis.labels <- axis.labels[na.omit(unique(mydf$group))]
+      axis.labels <- axis.labels[stats::na.omit(unique(mydf$group))]
     }
 
     mydf$ia <- as.factor(mydf$ia)

---FILE: R/plot_type_eff.R---
@@ -121,9 +121,9 @@ plot_type_eff <- function(type,
 
   # set axis and plot titles
   if (!is.null(title) && !is.null(terms))
-    p <- p + ggtitle(title)
+    p <- p + ggplot2::ggtitle(title)
   else if (!is.null(title) && is.null(terms))
-    p <- purrr::map(p, ~ .x + ggtitle(title))
+    p <- purrr::map(p, ~ .x + ggplot2::ggtitle(title))
 
   # set axis and plot titles
   if (!is.null(legend.title)) {

---FILE: R/plot_type_int.R---
@@ -164,7 +164,7 @@ plot_type_int <- function(model,
 
     # set axis and plot titles
     if (!is.null(title))
-      p <- p + ggtitle(title)
+      p <- p + ggplot2::ggtitle(title)
 
     # set axis and plot titles
     if (!is.null(legend.title))
@@ -173,9 +173,9 @@ plot_type_int <- function(model,
     # set axis limits
     if (!is.null(axis.lim)) {
       if (is.list(axis.lim))
-        p <- p + xlim(axis.lim[[1]]) + ylim(axis.lim[[2]])
+        p <- p + ggplot2::xlim(axis.lim[[1]]) + ggplot2::ylim(axis.lim[[2]])
       else
-        p <- p + ylim(axis.lim)
+        p <- p + ggplot2::ylim(axis.lim)
     }
 
 

---FILE: R/save_plot.R---
@@ -28,7 +28,7 @@
 #'
 #' @export
 save_plot <- function(filename,
-                      fig = last_plot(),
+                      fig = ggplot2::last_plot(),
                       width = 12,
                       height = 9,
                       dpi = 300,

---FILE: man/save_plot.Rd---
@@ -6,7 +6,7 @@
 \usage{
 save_plot(
   filename,
-  fig = last_plot(),
+  fig = ggplot2::last_plot(),
   width = 12,
   height = 9,
   dpi = 300,

---FILE: man/set_theme.Rd---
@@ -5,7 +5,7 @@
 \title{Set global theme options for sjp-functions}
 \usage{
 set_theme(
-  base = theme_grey(),
+  base = ggplot2::theme_grey(),
   theme.font = NULL,
   title.color = ""black"",
   title.size = 1.2,

---FILE: vignettes/blackwhitefigures.Rmd---
@@ -60,9 +60,9 @@ fit <- glm(y ~., data = df, family = binomial(link = ""logit""))
 
 # plot marginal effects
 plot_model(
-  fit, 
-  type = ""pred"", 
-  terms = c(""barthel"", ""sex"",""dep""), 
+  fit,
+  type = ""pred"",
+  terms = c(""barthel"", ""sex"",""dep""),
   colors = ""bw"",
   ci.lvl = NA
 )

---FILE: vignettes/plot_model_estimates.Rmd---
@@ -68,20 +68,20 @@ The simplest function call is just passing the model object as argument. By defa
 
 ```{r}
 plot_model(m1)
-``` 
+```
 
 The ""neutral"" line, i.e. the vertical intercept that indicates no effect (x-axis position 1 for most glm's and position 0 for most linear models), is drawn slightly thicker than the other grid lines. You can change the line color with the `vline.color`-argument.
 
 ```{r}
 plot_model(m1, vline.color = ""red"")
-``` 
+```
 
 ## Sorting estimates
 
 By default, the estimates are sorted in the same order as they were introduced into the model. Use `sort.est = TRUE` to sort estimates in descending order, from highest to lowest value.
 ```{r}
 plot_model(m1, sort.est = TRUE)
-``` 
+```
 
 Another way to sort estimates is to use the `order.terms`-argument. This is a numeric vector, indicating the order of estimates in the plot. In the summary, we see that ""sex2"" is the first term, followed by the three dependency-categories (position 2-4), the Barthel-Index (5) and two levels for intermediate and high level of education (6 and 7).
 
@@ -93,24 +93,24 @@ Now we want the educational levels (6 and 7) first, than gender (1), followed by
 
 ```{r}
 plot_model(m1, order.terms = c(6, 7, 1, 2, 3, 4, 5))
-``` 
+```
 
-## Estimates on the untransformed scale 
+## Estimates on the untransformed scale
 
 By default, `plot_model()` automatically exponentiates coefficients, if appropriate (e.g. for models with log or logit link). You can explicitley prevent transformation by setting the `transform`-argument to `NULL`, or apply any transformation by using a character vector with the function name.
 
 ```{r}
 plot_model(m1, transform = NULL)
 plot_model(m1, transform = ""plogis"")
-``` 
+```
 
 ## Showing value labels
 
 By default, just the dots and error bars are plotted. Use `show.values = TRUE` to show the value labels with the estimates values, and use `show.p = FALSE` to suppress the asterisks that indicate the significance level of the p-values. Use `value.offset` to adjust the relative positioning of value labels to the dots and lines.
 
 ```{r}
 plot_model(m1, show.values = TRUE, value.offset = .3)
-``` 
+```
 
 ## Labelling the plot
 
@@ -163,16 +163,16 @@ if (require(""rstanarm"", quietly = TRUE)) {
   # make sure we apply a nice theme
   library(ggplot2)
   theme_set(theme_sjplot())
-  
+
   data(mtcars)
   m <- stan_glm(mpg ~ wt + am + cyl + gear, data = mtcars, chains = 1)
-  
+
   # default model
   plot_model(m)
   # same model, with mean point estimate, dot-style for point estimate
   # and different inner/outer probabilities of the HDI
   plot_model(
-    m, 
+    m,
     bpe = ""mean"",
     bpe.style = ""dot"",
     prob.inner = .4,
@@ -193,8 +193,8 @@ There are several options to customize the plot appearance:
 
 ```{r}
 plot_model(
-  m1, 
-  colors = ""Accent"", 
+  m1,
+  colors = ""Accent"",
   show.values = TRUE,
   value.offset = .4,
   value.size = 4,"
strengejacke,sjPlot,a609b32bfd2fa5cba90c6ed1688077d731781d0f,Daniel,mail@danielluedecke.de,2025-07-01T21:07:52Z,Daniel,mail@danielluedecke.de,2025-07-01T21:07:52Z,fix,R/plot_diag_linear.R;R/plot_frq.R;R/sjplot_themes.R,False,True,True,False,4,4,8,"---FILE: R/plot_diag_linear.R---
@@ -64,7 +64,7 @@ diag_norm <- function(model, geom.colors) {
   ggplot2::ggplot(res_, ggplot2::aes(x = .data$res)) +
     ggplot2::geom_density(fill = geom.colors[1], alpha = 0.2) +
     ggplot2::stat_function(
-      fun = dnorm,
+      fun = stats::dnorm,
       args = list(
         mean = mean(unname(stats::residuals(model)), na.rm = TRUE),
         sd = stats::sd(unname(stats::residuals(model)), na.rm = TRUE)

---FILE: R/plot_frq.R---
@@ -788,7 +788,7 @@ plot_frq_helper <- function(
     if (normal.curve) {
       baseplot <- baseplot +
         ggplot2::stat_function(
-          fun = dnorm,
+          fun = stats::dnorm,
           args = list(
             mean = mean(hist.dat$xv),
             sd = stats::sd(hist.dat$xv)

---FILE: R/sjplot_themes.R---
@@ -301,9 +301,9 @@ scale_color_sjplot <- function(palette = ""metro"", discrete = TRUE, reverse = FAL
   pal <- get_sjplot_pal(palette = palette, reverse = reverse)
 
   if (discrete) {
-    discrete_scale(""colour"", paste0(""sjplot_pal_"", palette), palette = pal, ...)
+    ggplot2::discrete_scale(""colour"", paste0(""sjplot_pal_"", palette), palette = pal, ...)
   } else {
-    scale_color_gradientn(colours = pal(256), ...)
+    ggplot2::scale_color_gradientn(colours = pal(256), ...)
   }
 }
 "
strengejacke,sjPlot,f11938e4f3e517be852f2a822642177ea57f8dca,Daniel,mail@danielluedecke.de,2025-07-01T21:06:50Z,Daniel,mail@danielluedecke.de,2025-07-01T21:06:50Z,fix,R/sjPlotCorr.R;R/sjPlotPearsonsChi2Test.R;R/sjplot_themes.R;R/tab_fa.R,False,True,True,False,6,6,12,"---FILE: R/sjPlotCorr.R---
@@ -212,15 +212,15 @@ sjp.corr <- function(data,
   # start with base plot object here
   # --------------------------------------------------------
   corrPlot <- ggplot2::ggplot(orderedCorr, ggplot2::aes_string(x = ""ordx"", y = ""ordy"", fill = ""value"", label = ""val.labels"")) +
-    geom_tile(size = 0, colour = ""black"") +
+    ggplot2::geom_tile(size = 0, colour = ""black"") +
   # fill gradient colour from distinct color brewer palette. negative correlations are dark
   # red, positive corr. are dark blue, and they become lighter the closer they are to a
   # correlation coefficient of zero
     ggplot2::scale_x_discrete(labels = axis.labels, breaks = seq_len(length(axis.labels))) +
     ggplot2::scale_y_discrete(labels = axis.labels, breaks = seq_len(length(axis.labels))) +
     # set limits to (-1,1) to make sure the whole color palette is used. this
     # is the colour scale for geoms
-    scale_fill_gradientn(colours = geom.colors, limits = c(-1,1)) +
+    ggplot2::scale_fill_gradientn(colours = geom.colors, limits = c(-1,1)) +
     ggplot2::geom_text(size = 3.5, colour = ""black"") +
     ggplot2::labs(title = title, x = NULL, y = NULL)
   if (show.legend)

---FILE: R/sjPlotPearsonsChi2Test.R---
@@ -53,7 +53,7 @@ sjp.chi2 <- function(
   # ----------------------------------------------------------------
   m <- data.frame()
   for (i in seq_len(ncol(combos))) {
-    test <- chisq.test(df[, combos[1, i]], df[, combos[2, i]])
+    test <- stats::chisq.test(df[, combos[1, i]], df[, combos[2, i]])
     out <- data.frame(
       Row = colnames(df)[combos[1, i]],
       Column = colnames(df)[combos[2, i]],
@@ -100,7 +100,7 @@ sjp.chi2 <- function(
       label = ""p.value""
     )
   ) +
-    geom_tile() +
+    ggplot2::geom_tile() +
     ggplot2::scale_x_discrete(labels = axis.labels) +
     ggplot2::scale_y_discrete(labels = axis.labels) +
     ggplot2::scale_fill_gradient2(

---FILE: R/sjplot_themes.R---
@@ -316,7 +316,7 @@ scale_fill_sjplot <- function(palette = ""metro"", discrete = TRUE, reverse = FALS
   if (discrete) {
     discrete_scale(""fill"", paste0(""sjplot_pal_"", palette), palette = pal, ...)
   } else {
-    scale_fill_gradientn(colours = pal(256), ...)
+    ggplot2::scale_fill_gradientn(colours = pal(256), ...)
   }
 }
 

---FILE: R/tab_fa.R---
@@ -110,7 +110,7 @@ tab_fa <- function(data,
 
     if (is.null(nmbr.fctr)) {
       nr_factors <- psych::fa.parallel(data, fa = ""fa"", fm = method)$nfact
-      dev.off()
+      grDevices::dev.off()
       fadata <- psych::fa(data, nfactors = nr_factors, fm = method, rotate = rotation)
       if (sort == TRUE) {
         fadata <- psych::fa.sort(fadata) #resort loadings"
strengejacke,sjPlot,1035ff24384a036c254ea5c5c09ad32c74af549e,Daniel,mail@danielluedecke.de,2025-07-01T21:05:21Z,Daniel,mail@danielluedecke.de,2025-07-01T21:05:21Z,fix,R/sjPlotSetTheme.R,False,True,True,False,10,10,20,"---FILE: R/sjPlotSetTheme.R---
@@ -146,7 +146,7 @@
 #' plot_frq(efc$e42dep)}
 #'
 #' @export
-set_theme <- function(base = theme_grey(),
+set_theme <- function(base = ggplot2::theme_grey(),
                       theme.font = NULL,
                      # title defaults
                      title.color = ""black"",
@@ -340,7 +340,7 @@ set_theme <- function(base = theme_grey(),
   if (
     !is.null(theme) && any(class(theme) == ""theme"") && any(class(theme) == ""gg"")
   ) {
-    theme_set(theme)
+    ggplot2::theme_set(theme)
   } else if (
     !is.null(base) && any(class(base) == ""theme"") && any(class(base) == ""gg"")
   ) {
@@ -353,37 +353,37 @@ set_theme <- function(base = theme_grey(),
       # ----------------------------------------
       ggplot2::theme(
         plot.title = ggplot2::element_text(
-          size = rel(title.size),
+          size = ggplot2::rel(title.size),
           colour = title.color,
           hjust = title.align
         ),
         axis.text = ggplot2::element_text(
           angle = axis.angle,
-          size = rel(axis.textsize),
+          size = ggplot2::rel(axis.textsize),
           colour = axis.textcolor
         ),
         axis.text.x = ggplot2::element_text(
           angle = axis.angle.x,
-          size = rel(axis.textsize.x),
+          size = ggplot2::rel(axis.textsize.x),
           colour = axis.textcolor.x
         ),
         axis.text.y = ggplot2::element_text(
           angle = axis.angle.y,
-          size = rel(axis.textsize.y),
+          size = ggplot2::rel(axis.textsize.y),
           colour = axis.textcolor.y
         ),
         axis.title = ggplot2::element_text(
-          size = rel(axis.title.size),
+          size = ggplot2::rel(axis.title.size),
           colour = axis.title.color
         ),
         legend.position = legend.pos,
         legend.justification = legend.just,
         legend.text = ggplot2::element_text(
-          size = rel(legend.size),
+          size = ggplot2::rel(legend.size),
           colour = legend.color
         ),
         legend.title = ggplot2::element_text(
-          size = rel(legend.title.size),
+          size = ggplot2::rel(legend.title.size),
           colour = legend.title.color,
           face = legend.title.face
         ),
@@ -559,7 +559,7 @@ set_theme <- function(base = theme_grey(),
     # ----------------------------------------
     # finally, set theme
     # ----------------------------------------
-    theme_set(sjtheme)
+    ggplot2::theme_set(sjtheme)
   } else {
     warning(
       ""Either `theme` or `base` must be supplied as ggplot-theme-object to set global theme options for sjPlot."","
strengejacke,sjPlot,e1aa63130328a5352248fa73f20a76ab46a36a34,Daniel,mail@danielluedecke.de,2025-07-01T15:56:52Z,Daniel,mail@danielluedecke.de,2025-07-01T15:56:52Z,fix,R/plot_diag_linear.R;R/plot_likert.R;R/plot_point_estimates.R;R/save_plot.R;R/sjPlotSetTheme.R;R/sjplot_themes.R;R/utils.R;man/save_plot.Rd,False,True,True,False,106,58,164,"---FILE: R/plot_diag_linear.R---
@@ -45,7 +45,7 @@ diag_ncv <- function(model, dot.size, line.size) {
   )
 
   ggplot2::ggplot(dat, ggplot2::aes(x = .data$fitted, y = .data$res)) +
-    ggplot2::geom_intercept_line2(0, NULL) +
+    geom_intercept_line2(0, NULL) +
     ggplot2::geom_point(size = dot.size) +
     ggplot2::geom_smooth(method = ""loess"", se = FALSE, size = line.size) +
     ggplot2::labs(
@@ -196,7 +196,7 @@ diag_reqq <- function(model, dot.size) {
         x = ""Standard normal quantiles"",
         y = ""Random effect quantiles""
       ) +
-      ggplot2::geom_intercept_line2(0, NULL) +
+      geom_intercept_line2(0, NULL) +
       ggplot2::stat_smooth(method = ""lm"", alpha = alpha) +
       ggplot2::geom_errorbar(
         ggplot2::aes(ymin = .data$conf.low, ymax = .data$conf.high),

---FILE: R/plot_likert.R---
@@ -230,11 +230,11 @@ plot_likert <- function(
       if (legend.pos %in% c(""top"", ""both"") && i == 1) {
         .pl <- .pl +
           ggplot2::theme(legend.position = ""top"") +
-          ggplot2::guides(fill = do.call(guide_legend, group.legend.options))
+          ggplot2::guides(fill = do.call(ggplot2::guide_legend, group.legend.options))
       } else if (legend.pos %in% c(""bottom"", ""both"") && i == length(findex)) {
         .pl <- .pl +
           ggplot2::theme(legend.position = ""bottom"") +
-          ggplot2::guides(fill = do.call(guide_legend, group.legend.options))
+          ggplot2::guides(fill = do.call(ggplot2::guide_legend, group.legend.options))
       } else if (legend.pos != ""all"") {
         .pl <- .pl + ggplot2::theme(legend.position = ""none"")
       }

---FILE: R/plot_point_estimates.R---
@@ -219,15 +219,15 @@ plot_point_estimates <- function(
           ggplot2::aes(ymin = .data$conf.low, ymax = .data$conf.high),
           position = ggplot2::position_dodge(width = spacing),
           width = width,
-          size = line.size
+          linewidth = line.size
         )
     } else {
       p <- p +
         ggplot2::geom_point(size = geom.size) +
         ggplot2::geom_errorbar(
           ggplot2::aes(ymin = .data$conf.low, ymax = .data$conf.high),
           width = width,
-          size = line.size
+          linewidth = line.size
         )
     }
   }

---FILE: R/save_plot.R---
@@ -32,7 +32,7 @@ save_plot <- function(filename,
                       width = 12,
                       height = 9,
                       dpi = 300,
-                      theme = theme_get(),
+                      theme = ggplot2::theme_get(),
                       label.color = ""black"",
                       label.size = 2.4,
                       axis.textsize = .8,

---FILE: R/sjPlotSetTheme.R---
@@ -589,48 +589,75 @@ set_theme <- function(base = theme_grey(),
 }
 
 
-sj.theme_geoms <- function(geom.alpha,
-                           geom.linetype,
-                           geom.outline.size,
-                           geom.outline.color,
-                           geom.boxoutline.size,
-                           geom.boxoutline.color,
-                           geom.errorbar.size,
-                           geom.errorbar.linetype,
-                           geom.label.size,
-                           geom.label.color,
-                           geom.label.alpha,
-                           geom.label.angle) {
+sj.theme_geoms <- function(
+  geom.alpha,
+  geom.linetype,
+  geom.outline.size,
+  geom.outline.color,
+  geom.boxoutline.size,
+  geom.boxoutline.color,
+  geom.errorbar.size,
+  geom.errorbar.linetype,
+  geom.label.size,
+  geom.label.color,
+  geom.label.alpha,
+  geom.label.angle
+) {
   # ----------------------------------------
   # helper function to customize geoms
   # ----------------------------------------
   updateGeoms <- function(geoms, parameters) {
-    for (geom in geoms) update_geom_defaults(geom, parameters)
+    for (geom in geoms) {
+      ggplot2::update_geom_defaults(geom, parameters)
+    }
   }
 
   # Geoms that only require a default colour.
-  updateGeoms(c('abline',
-                'point',
-                'density',
-                'errorbar',
-                'errorbarh',
-                'hline',
-                'line',
-                'area',
-                'tile',
-                'dotplot',
-                'bar'), list(alpha = geom.alpha))
+  updateGeoms(
+    c(
+      'abline',
+      'point',
+      'density',
+      'errorbar',
+      'errorbarh',
+      'hline',
+      'line',
+      'area',
+      'tile',
+      'dotplot',
+      'bar'
+    ),
+    list(alpha = geom.alpha)
+  )
 
-  update_geom_defaults('text', list(size = geom.label.size,
-                                    colour = geom.label.color,
-                                    alpha = geom.label.alpha,
-                                    angle = geom.label.angle))
+  ggplot2::update_geom_defaults(
+    'text',
+    list(
+      size = geom.label.size,
+      colour = geom.label.color,
+      alpha = geom.label.alpha,
+      angle = geom.label.angle
+    )
+  )
 
   # Special geoms.
-  update_geom_defaults('boxplot', list(size = geom.boxoutline.size, colour = geom.boxoutline.color, alpha = geom.alpha))
-  update_geom_defaults('bar', list(colour = geom.outline.color, size = geom.outline.size))
-  update_geom_defaults('line', list(linetype = geom.linetype))
-  updateGeoms(c('errorbar', 'errorbarh'), list(size = geom.errorbar.size, linetype = geom.errorbar.linetype))
+  ggplot2::update_geom_defaults(
+    'boxplot',
+    list(
+      size = geom.boxoutline.size,
+      colour = geom.boxoutline.color,
+      alpha = geom.alpha
+    )
+  )
+  ggplot2::update_geom_defaults(
+    'bar',
+    list(colour = geom.outline.color, size = geom.outline.size)
+  )
+  ggplot2::update_geom_defaults('line', list(linetype = geom.linetype))
+  updateGeoms(
+    c('errorbar', 'errorbarh'),
+    list(size = geom.errorbar.size, linetype = geom.errorbar.linetype)
+  )
 }
 
 

---FILE: R/sjplot_themes.R---
@@ -151,12 +151,22 @@ theme_538 <- function(base_size = 12, base_family = """") {
 
 #' @rdname sjPlot-themes
 #' @export
-font_size <- function(title, axis_title.x, axis_title.y, labels.x, labels.y, offset.x, offset.y, base.theme) {
+font_size <- function(
+  title,
+  axis_title.x,
+  axis_title.y,
+  labels.x,
+  labels.y,
+  offset.x,
+  offset.y,
+  base.theme
+) {
   # get current theme
-  if (!missing(base.theme))
+  if (!missing(base.theme)) {
     cur.theme <- base.theme
-  else
-    cur.theme <- theme_get()
+  } else {
+    cur.theme <- ggplot2::theme_get()
+  }
 
   if (!missing(title)) {
     cur.theme <- cur.theme +
@@ -175,12 +185,12 @@ font_size <- function(title, axis_title.x, axis_title.y, labels.x, labels.y, off
 
   if (!missing(labels.x)) {
     cur.theme <- cur.theme +
-      ggplot2::theme(axis.text.x =  ggplot2::element_text(size = labels.x))
+      ggplot2::theme(axis.text.x = ggplot2::element_text(size = labels.x))
   }
 
   if (!missing(labels.y)) {
     cur.theme <- cur.theme +
-      ggplot2::theme(axis.text.y =  ggplot2::element_text(size = labels.y))
+      ggplot2::theme(axis.text.y = ggplot2::element_text(size = labels.y))
   }
 
   if (!missing(offset.x)) {
@@ -201,10 +211,11 @@ font_size <- function(title, axis_title.x, axis_title.y, labels.x, labels.y, off
 #' @export
 label_angle <- function(angle.x, angle.y, base.theme) {
   # get current theme
-  if (!missing(base.theme))
+  if (!missing(base.theme)) {
     cur.theme <- base.theme
-  else
-    cur.theme <- theme_get()
+  } else {
+    cur.theme <- ggplot2::theme_get()
+  }
 
   if (!missing(angle.x)) {
     cur.theme <- cur.theme +
@@ -224,10 +235,11 @@ label_angle <- function(angle.x, angle.y, base.theme) {
 #' @export
 legend_style <- function(inside, pos, justify, base.theme) {
   # get current theme
-  if (!missing(base.theme))
+  if (!missing(base.theme)) {
     cur.theme <- base.theme
-  else
-    cur.theme <- theme_get()
+  } else {
+    cur.theme <- ggplot2::theme_get()
+  }
 
   # convert legend position from character to numeric index
   if (!missing(inside) && inside) {
@@ -245,7 +257,9 @@ legend_style <- function(inside, pos, justify, base.theme) {
   }
 
   # set default justification
-  if (missing(justify)) justify <- ""center""
+  if (missing(justify)) {
+    justify <- ""center""
+  }
 
   if (!missing(pos)) {
     cur.theme <- cur.theme +

---FILE: R/utils.R---
@@ -189,9 +189,14 @@ nulldef <- function(x, y, z = NULL) {
 
 
 geom_intercept_line <- function(yintercept, axis.scaling, vline.color) {
-  if (yintercept > axis.scaling$axis.lim[1] && yintercept < axis.scaling$axis.lim[2]) {
-    t <- theme_get()
-    if (is.null(t$panel.grid.major)) t$panel.grid.major <- t$panel.grid
+  if (
+    yintercept > axis.scaling$axis.lim[1] &&
+      yintercept < axis.scaling$axis.lim[2]
+  ) {
+    t <- ggplot2::theme_get()
+    if (is.null(t$panel.grid.major)) {
+      t$panel.grid.major <- t$panel.grid
+    }
     color <- nulldef(vline.color, t$panel.grid.major$colour, ""grey90"")
     minor_size <- nulldef(t$panel.grid.minor$size, .125)
     major_size <- nulldef(t$panel.grid.major$size, minor_size * 1.5)
@@ -204,8 +209,10 @@ geom_intercept_line <- function(yintercept, axis.scaling, vline.color) {
 
 # same as above, but no check if intercept is within boundaries or not
 geom_intercept_line2 <- function(yintercept, vline.color) {
-  t <- theme_get()
-  if (is.null(t$panel.grid.major)) t$panel.grid.major <- t$panel.grid
+  t <- ggplot2::theme_get()
+  if (is.null(t$panel.grid.major)) {
+    t$panel.grid.major <- t$panel.grid
+  }
   color <- nulldef(vline.color, t$panel.grid.major$colour, ""grey90"")
   minor_size <- nulldef(t$panel.grid.minor$size, .125)
   major_size <- nulldef(t$panel.grid.major$size, minor_size * 1.5)

---FILE: man/save_plot.Rd---
@@ -10,7 +10,7 @@ save_plot(
   width = 12,
   height = 9,
   dpi = 300,
-  theme = theme_get(),
+  theme = ggplot2::theme_get(),
   label.color = ""black"",
   label.size = 2.4,
   axis.textsize = 0.8,"
strengejacke,sjPlot,237237a1ddddc9f2f695e86d9d939c2373c27ed0,Daniel,mail@danielluedecke.de,2025-07-01T12:11:13Z,Daniel,mail@danielluedecke.de,2025-07-01T12:11:13Z,fix,R/plot_diag_linear.R,False,True,True,False,2,2,4,"---FILE: R/plot_diag_linear.R---
@@ -45,9 +45,9 @@ diag_ncv <- function(model, dot.size, line.size) {
   )
 
   ggplot2::ggplot(dat, ggplot2::aes(x = .data$fitted, y = .data$res)) +
-    geom_intercept_line2(0, NULL) +
+    ggplot2::geom_intercept_line2(0, NULL) +
     ggplot2::geom_point(size = dot.size) +
-    geom_smooth(method = ""loess"", se = FALSE, size = line.size) +
+    ggplot2::geom_smooth(method = ""loess"", se = FALSE, size = line.size) +
     ggplot2::labs(
       x = ""Fitted values"",
       y = ""Residuals"","
strengejacke,sjPlot,1e230897e258d7ad3db5798237681741692a3d19,Daniel,mail@danielluedecke.de,2025-07-01T12:10:35Z,Daniel,mail@danielluedecke.de,2025-07-01T12:10:35Z,fix,R/plot_diag_linear.R;R/plot_likert.R,False,True,True,False,103,45,148,"---FILE: R/plot_diag_linear.R---
@@ -32,16 +32,19 @@ plot_diag_glm <- function(model, geom.colors, dot.size, line.size, ...) {
 
 
 diag_ncv <- function(model, dot.size, line.size) {
-
-  if (is.null(dot.size)) dot.size <- 1
-  if (is.null(line.size)) line.size <- 1
+  if (is.null(dot.size)) {
+    dot.size <- 1
+  }
+  if (is.null(line.size)) {
+    line.size <- 1
+  }
 
   dat <- data.frame(
     res = stats::residuals(model),
     fitted = stats::fitted(model)
   )
 
-  ggplot2::ggplot(dat, ggplot2::aes_string(x = ""fitted"", y = ""res"")) +
+  ggplot2::ggplot(dat, ggplot2::aes(x = .data$fitted, y = .data$res)) +
     geom_intercept_line2(0, NULL) +
     ggplot2::geom_point(size = dot.size) +
     geom_smooth(method = ""loess"", se = FALSE, size = line.size) +
@@ -58,7 +61,7 @@ diag_ncv <- function(model, dot.size, line.size) {
 diag_norm <- function(model, geom.colors) {
   res_ <- data.frame(res = stats::residuals(model))
 
-  ggplot2::ggplot(res_, ggplot2::aes_string(x = ""res"")) +
+  ggplot2::ggplot(res_, ggplot2::aes(x = .data$res)) +
     ggplot2::geom_density(fill = geom.colors[1], alpha = 0.2) +
     ggplot2::stat_function(
       fun = dnorm,
@@ -79,9 +82,12 @@ diag_norm <- function(model, geom.colors) {
 
 
 diag_qq <- function(model, geom.colors, dot.size, line.size, ...) {
-
-  if (is.null(dot.size)) dot.size <- 1
-  if (is.null(line.size)) line.size <- 1
+  if (is.null(dot.size)) {
+    dot.size <- 1
+  }
+  if (is.null(line.size)) {
+    line.size <- 1
+  }
 
   # qq-plot of studentized residuals
   if (inherits(model, c(""lme"", ""lmerMod"", ""glmmTMB""))) {
@@ -99,7 +105,7 @@ diag_qq <- function(model, geom.colors, dot.size, line.size, ...) {
   mydf <- stats::na.omit(data.frame(x = fitted_, y = res_))
 
   # plot it
-  ggplot2::ggplot(mydf, ggplot2::aes_string(x = ""x"", y = ""y"")) +
+  ggplot2::ggplot(mydf, ggplot2::aes(x = .data$x, y = .data$y)) +
     ggplot2::geom_point(size = dot.size) +
     ggplot2::scale_colour_manual(values = geom.colors) +
     ggplot2::stat_smooth(method = ""lm"", se = FALSE, size = line.size) +
@@ -113,14 +119,19 @@ diag_qq <- function(model, geom.colors, dot.size, line.size, ...) {
 
 
 diag_reqq <- function(model, dot.size) {
-
-  if (!is_merMod(model) && !inherits(model, ""glmmTMB"")) return(NULL)
+  if (!is_merMod(model) && !inherits(model, ""glmmTMB"")) {
+    return(NULL)
+  }
 
   if (!requireNamespace(""lme4"", quietly = TRUE)) {
-    stop(""Package 'lme4' required for this function to work, please install it."")
+    stop(
+      ""Package 'lme4' required for this function to work, please install it.""
+    )
   }
   if (!requireNamespace(""glmmTMB"", quietly = TRUE)) {
-    stop(""Package 'glmmTMB' required for this function to work, please install it."")
+    stop(
+      ""Package 'glmmTMB' required for this function to work, please install it.""
+    )
   }
 
   if (inherits(model, ""glmmTMB"")) {
@@ -134,49 +145,61 @@ diag_reqq <- function(model, dot.size) {
       s3
     })
   } else {
-    re   <- lme4::ranef(model, condVar = TRUE)
+    re <- lme4::ranef(model, condVar = TRUE)
     se <- purrr::map(re, function(.x) {
-      pv   <- attr(.x, ""postVar"")
+      pv <- attr(.x, ""postVar"")
       cols <- seq_len(dim(pv)[1])
       unlist(lapply(cols, function(.y) sqrt(pv[.y, .y, ])))
     })
   }
 
-
   alpha <- .3
-  if (is.null(dot.size)) dot.size <- 2
+  if (is.null(dot.size)) {
+    dot.size <- 2
+  }
 
   # get ...-arguments
   add.args <- lapply(match.call(expand.dots = FALSE)$`...`, function(x) x)
-  if (""alpha"" %in% names(add.args)) alpha <- eval(add.args[[""alpha""]])
-
+  if (""alpha"" %in% names(add.args)) {
+    alpha <- eval(add.args[[""alpha""]])
+  }
 
   purrr::map2(re, se, function(.re, .se) {
-    ord  <- unlist(lapply(.re, order)) + rep((0:(ncol(.re) - 1)) * nrow(.re), each = nrow(.re))
+    ord <- unlist(lapply(.re, order)) +
+      rep((0:(ncol(.re) - 1)) * nrow(.re), each = nrow(.re))
 
     df.y <- unlist(.re)[ord]
     df.ci <- stats::qnorm(.975) * .se[ord]
 
-    pDf  <- data_frame(
+    pDf <- data_frame(
       y = df.y,
       ci = df.ci,
       nQQ = rep(stats::qnorm(stats::ppoints(nrow(.re))), ncol(.re)),
-      ID = factor(rep(rownames(.re), ncol(.re))[ord], levels = rownames(.re)[ord]),
+      ID = factor(
+        rep(rownames(.re), ncol(.re))[ord],
+        levels = rownames(.re)[ord]
+      ),
       ind = gl(ncol(.re), nrow(.re), labels = names(.re)),
       conf.low = df.y - df.ci,
       conf.high = df.y + df.ci
     )
 
-    ggplot2::ggplot(pDf, ggplot2::aes_string(
-      x = ""nQQ"",
-      y = ""y""
-    )) +
-      ggplot2::facet_wrap(~ ind, scales = ""free"") +
-      ggplot2::labs(x = ""Standard normal quantiles"", y = ""Random effect quantiles"") +
-      geom_intercept_line2(0, NULL) +
+    ggplot2::ggplot(
+      pDf,
+      ggplot2::aes(
+        x = .data$nQQ,
+        y = .data$y
+      )
+    ) +
+      ggplot2::facet_wrap(~ind, scales = ""free"") +
+      ggplot2::labs(
+        x = ""Standard normal quantiles"",
+        y = ""Random effect quantiles""
+      ) +
+      ggplot2::geom_intercept_line2(0, NULL) +
       ggplot2::stat_smooth(method = ""lm"", alpha = alpha) +
       ggplot2::geom_errorbar(
-        ggplot2::aes_string(ymin = ""conf.low"", ymax = ""conf.high""),
+        ggplot2::aes(ymin = .data$conf.low, ymax = .data$conf.high),
         width = 0,
         colour = ""black""
       ) +
@@ -186,19 +209,22 @@ diag_reqq <- function(model, dot.size) {
 
 
 diag_vif <- function(fit) {
-
-  if (is_merMod(fit) || inherits(fit, ""lme""))
+  if (is_merMod(fit) || inherits(fit, ""lme"")) {
     return(NULL)
+  }
 
-  if (!requireNamespace(""car"", quietly = TRUE))
-    stop(""Package `car` needed for this function to work. Please install it."", call. = FALSE)
+  if (!requireNamespace(""car"", quietly = TRUE)) {
+    stop(
+      ""Package `car` needed for this function to work. Please install it."",
+      call. = FALSE
+    )
+  }
 
   vifplot <- NULL
 
   # check if we have more than 1 term
 
   if (length(stats::coef(fit)) > 2) {
-
     # variance inflation factor
     # claculate VIF
 
@@ -219,19 +245,51 @@ diag_vif <- function(fit) {
     # check whether maxval exceeds the critical VIF-Limit
     # of 10. If so, set upper limit to max. value
 
-    if (maxval >= upperLimit) upperLimit <- ceiling(maxval)
+    if (maxval >= upperLimit) {
+      upperLimit <- ceiling(maxval)
+    }
 
     mydat <- data.frame(vif = round(val, 2)) |>
       rownames_as_column(var = ""vars"")
 
-
-    vifplot <- ggplot2::ggplot(mydat, ggplot2::aes_string(x = ""vars"", y = ""vif"")) +
+    vifplot <- ggplot2::ggplot(
+      mydat,
+      ggplot2::aes(x = .data$vars, y = .data$vif)
+    ) +
       ggplot2::geom_bar(stat = ""identity"", width = 0.7, fill = ""#80acc8"") +
-      ggplot2::geom_hline(yintercept = 5, linetype = 2, colour = ""darkgreen"", alpha = 0.7) +
-      ggplot2::geom_hline(yintercept = 10, linetype = 2, colour = ""darkred"", alpha = 0.7) +
-      ggplot2::annotate(""text"", x = 1, y = 4.7, label = ""good"", size = 4, colour = ""darkgreen"") +
-      ggplot2::annotate(""text"", x = 1, y = 9.7, label = ""tolerable"", size = 4, colour = ""darkred"") +
-      ggplot2::labs(title = ""Variance Inflation Factors (multicollinearity)"", x = NULL, y = NULL) +
+      ggplot2::geom_hline(
+        yintercept = 5,
+        linetype = 2,
+        colour = ""darkgreen"",
+        alpha = 0.7
+      ) +
+      ggplot2::geom_hline(
+        yintercept = 10,
+        linetype = 2,
+        colour = ""darkred"",
+        alpha = 0.7
+      ) +
+      ggplot2::annotate(
+        ""text"",
+        x = 1,
+        y = 4.7,
+        label = ""good"",
+        size = 4,
+        colour = ""darkgreen""
+      ) +
+      ggplot2::annotate(
+        ""text"",
+        x = 1,
+        y = 9.7,
+        label = ""tolerable"",
+        size = 4,
+        colour = ""darkred""
+      ) +
+      ggplot2::labs(
+        title = ""Variance Inflation Factors (multicollinearity)"",
+        x = NULL,
+        y = NULL
+      ) +
       ggplot2::scale_y_continuous(limits = c(0, upperLimit), expand = c(0, 0))
   }
 

---FILE: R/plot_likert.R---
@@ -749,13 +749,13 @@ plot_likert <- function(
 
   gp <- ggplot2::ggplot() +
     # positive value bars
-    geom_col(
+    ggplot2::geom_col(
       data = mydat.pos,
       ggplot2::aes(x = .data$x, y = .data$frq, fill = .data$grp),
       width = geom.size
     ) +
     # negative value bars
-    geom_col(
+    ggplot2::geom_col(
       data = mydat.neg,
       ggplot2::aes(x = .data$x, y = .data$frq, fill = .data$grp),
       width = geom.size,"
strengejacke,sjPlot,7b2d7e5443b6985dab13be3ec8583b26dfeb6780,Daniel,mail@danielluedecke.de,2025-07-01T10:59:43Z,Daniel,mail@danielluedecke.de,2025-07-01T10:59:43Z,fix,R/plot_grpfrq.R,False,True,True,False,322,165,487,"---FILE: R/plot_grpfrq.R---
@@ -165,51 +165,52 @@
 #'
 #' @importFrom rlang .data
 #' @export
-plot_grpfrq <- function(var.cnt,
-                       var.grp,
-                       type = c(""bar"", ""dot"", ""line"", ""boxplot"", ""violin""),
-                       bar.pos = c(""dodge"", ""stack""),
-                       weight.by = NULL,
-                       intr.var = NULL,
-                       title = """",
-                       title.wtd.suffix = NULL,
-                       legend.title = NULL,
-                       axis.titles = NULL,
-                       axis.labels = NULL,
-                       legend.labels = NULL,
-                       intr.var.labels = NULL,
-                       wrap.title = 50,
-                       wrap.labels = 15,
-                       wrap.legend.title = 20,
-                       wrap.legend.labels = 20,
-                       geom.size = NULL,
-                       geom.spacing = 0.15,
-                       geom.colors = ""Paired"",
-                       show.values = TRUE,
-                       show.n = TRUE,
-                       show.prc = TRUE,
-                       show.axis.values = TRUE,
-                       show.ci = FALSE,
-                       show.grpcnt = FALSE,
-                       show.legend = TRUE,
-                       show.na = FALSE,
-                       show.summary = FALSE,
-                       drop.empty = TRUE,
-                       auto.group = NULL,
-                       ylim = NULL,
-                       grid.breaks = NULL,
-                       expand.grid = FALSE,
-                       inner.box.width = 0.15,
-                       inner.box.dotsize = 3,
-                       smooth.lines = FALSE,
-                       emph.dots = TRUE,
-                       summary.pos = ""r"",
-                       facet.grid = FALSE,
-                       coord.flip = FALSE,
-                       y.offset = NULL,
-                       vjust = ""bottom"",
-                       hjust = ""center"") {
-
+plot_grpfrq <- function(
+  var.cnt,
+  var.grp,
+  type = c(""bar"", ""dot"", ""line"", ""boxplot"", ""violin""),
+  bar.pos = c(""dodge"", ""stack""),
+  weight.by = NULL,
+  intr.var = NULL,
+  title = """",
+  title.wtd.suffix = NULL,
+  legend.title = NULL,
+  axis.titles = NULL,
+  axis.labels = NULL,
+  legend.labels = NULL,
+  intr.var.labels = NULL,
+  wrap.title = 50,
+  wrap.labels = 15,
+  wrap.legend.title = 20,
+  wrap.legend.labels = 20,
+  geom.size = NULL,
+  geom.spacing = 0.15,
+  geom.colors = ""Paired"",
+  show.values = TRUE,
+  show.n = TRUE,
+  show.prc = TRUE,
+  show.axis.values = TRUE,
+  show.ci = FALSE,
+  show.grpcnt = FALSE,
+  show.legend = TRUE,
+  show.na = FALSE,
+  show.summary = FALSE,
+  drop.empty = TRUE,
+  auto.group = NULL,
+  ylim = NULL,
+  grid.breaks = NULL,
+  expand.grid = FALSE,
+  inner.box.width = 0.15,
+  inner.box.dotsize = 3,
+  smooth.lines = FALSE,
+  emph.dots = TRUE,
+  summary.pos = ""r"",
+  facet.grid = FALSE,
+  coord.flip = FALSE,
+  y.offset = NULL,
+  vjust = ""bottom"",
+  hjust = ""center""
+) {
   # get variable names
   var.name.cnt <- get_var_name(deparse(substitute(var.cnt)))
   var.name.grp <- get_var_name(deparse(substitute(var.grp)))
@@ -226,24 +227,28 @@ plot_grpfrq <- function(var.cnt,
     axisTitle.y <- NULL
   } else {
     axisTitle.x <- axis.titles[1]
-    if (length(axis.titles) > 1)
+    if (length(axis.titles) > 1) {
       axisTitle.y <- axis.titles[2]
-    else
+    } else {
       axisTitle.y <- NULL
+    }
   }
 
   # match arguments
   type <- match.arg(type)
   bar.pos <- match.arg(bar.pos)
 
   # turn off legend by default for facet grids
-  if (facet.grid && missing(show.legend)) show.legend <- FALSE
+  if (facet.grid && missing(show.legend)) {
+    show.legend <- FALSE
+  }
 
   # Plot margins
-  if (expand.grid)
+  if (expand.grid) {
     expand.grid <- ggplot2::waiver()
-  else
+  } else {
     expand.grid <- c(0, 0)
+  }
 
   # check default geom.size
   if (is.null(geom.size)) {
@@ -263,43 +268,55 @@ plot_grpfrq <- function(var.cnt,
     y.offset <- ceiling(max(table(var.cnt, var.grp)) / 100)
 
     if (coord.flip) {
-      if (missing(vjust)) vjust <- ""center""
-      if (missing(hjust)) hjust <- ""bottom""
+      if (missing(vjust)) {
+        vjust <- ""center""
+      }
+      if (missing(hjust)) {
+        hjust <- ""bottom""
+      }
 
       # for flipped coordinates, we need to adjust
       # y-offset according to horizontal adjustemnt of labels
-      if (hjust == ""bottom"")
+      if (hjust == ""bottom"") {
         y_offset <- y.offset
-      else if (hjust == ""top"")
+      } else if (hjust == ""top"") {
         y_offset <- -y.offset
-      else
+      } else {
         y_offset <- 0
+      }
     } else {
       # for non-flipped coordinates, we need to adjust
       # y-offset according to vertical adjustemnt of labels
-      if (vjust == ""bottom"")
+      if (vjust == ""bottom"") {
         y_offset <- y.offset
-      else if (vjust == ""top"")
+      } else if (vjust == ""top"") {
         y_offset <- -y.offset
-      else
+      } else {
         y_offset <- 0
+      }
     }
   } else {
     y_offset <- y.offset
   }
 
   # Interaction variable defined for invalid plot type?
   if (!is.null(intr.var) && type != ""boxplot"" && type != ""violin"") {
-    message(""`intr.var` only applies to boxplots and violinplots (see `type`) and will be ignored."")
+    message(
+      ""`intr.var` only applies to boxplots and violinplots (see `type`) and will be ignored.""
+    )
   }
 
   if (show.grpcnt && type %in% c(""boxplot"", ""violin"")) {
-    message(""`show.grpcnt` does not apply to boxplots and violinplots and will be ignored."")
+    message(
+      ""`show.grpcnt` does not apply to boxplots and violinplots and will be ignored.""
+    )
     show.grpcnt <- FALSE
   }
 
   # auto-set plot title for box plots?
-  if (missing(title) && (type == ""boxplot"" || type == ""violin"")) title <- NULL
+  if (missing(title) && (type == ""boxplot"" || type == ""violin"")) {
+    title <- NULL
+  }
 
   # check whether variable should be auto-grouped
   if (!is.null(auto.group) && length(unique(var.cnt)) >= auto.group) {
@@ -358,16 +375,19 @@ plot_grpfrq <- function(var.cnt,
     if (missing(show.legend)) show.legend <- !is.null(intr.var)
   }
 
-  if (is.null(axis.labels)) axis.labels <- mydat$labels.cnt
+  if (is.null(axis.labels)) {
+    axis.labels <- mydat$labels.cnt
+  }
 
   # we need to know later whether user has supplied legend labels or not
   we_have_legend_labels <- FALSE
 
   # check for auto-getting labels, ot if user passed legend labels as argument
-  if (is.null(legend.labels))
+  if (is.null(legend.labels)) {
     legend.labels <- mydat$labels.grp
-  else
+  } else {
     we_have_legend_labels <- TRUE
+  }
 
   # go to interaction terms. in this case, due to interaction, the axis
   # labels become legend labels, but only if user has not specified
@@ -377,11 +397,14 @@ plot_grpfrq <- function(var.cnt,
       intr.var,
       attr.only = FALSE,
       values = FALSE,
-      non.labelled = T
+      non.labelled = TRUE
     )
 
     # create repeating label for x-axis
-    intr.var.labels <- rep(intr.var.labels, length.out = length(axis.labels) * length(intr.var.labels))
+    intr.var.labels <- rep(
+      intr.var.labels,
+      length.out = length(axis.labels) * length(intr.var.labels)
+    )
 
     # we need a legend, cause x axis is labelled with interaction var value
     show.legend <- TRUE
@@ -390,8 +413,12 @@ plot_grpfrq <- function(var.cnt,
     if (!we_have_legend_labels) legend.labels <- axis.labels
   }
 
-  if (is.null(axisTitle.x)) axisTitle.x <- sjlabelled::get_label(var.cnt, def.value = var.name.cnt)
-  if (is.null(legend.title)) legend.title <- sjlabelled::get_label(var.grp, def.value = var.name.grp)
+  if (is.null(axisTitle.x)) {
+    axisTitle.x <- sjlabelled::get_label(var.cnt, def.value = var.name.cnt)
+  }
+  if (is.null(legend.title)) {
+    legend.title <- sjlabelled::get_label(var.grp, def.value = var.name.grp)
+  }
 
   if (is.null(title)) {
     t1 <- sjlabelled::get_label(var.cnt, def.value = var.name.cnt)
@@ -400,21 +427,31 @@ plot_grpfrq <- function(var.cnt,
   }
 
   # remove titles if empty
-  if (!is.null(legend.title) && legend.title == """") legend.title <- NULL
-  if (!is.null(axisTitle.x) && axisTitle.x == """") axisTitle.x <- NULL
-  if (!is.null(axisTitle.y) && axisTitle.y == """") axisTitle.y <- NULL
-  if (!is.null(title) && title == """") title <- NULL
+  if (!is.null(legend.title) && legend.title == """") {
+    legend.title <- NULL
+  }
+  if (!is.null(axisTitle.x) && axisTitle.x == """") {
+    axisTitle.x <- NULL
+  }
+  if (!is.null(axisTitle.y) && axisTitle.y == """") {
+    axisTitle.y <- NULL
+  }
+  if (!is.null(title) && title == """") {
+    title <- NULL
+  }
 
   # variables may not be factors
-  if (anyNA(as.numeric(stats::na.omit(var.cnt))))
+  if (anyNA(as.numeric(stats::na.omit(var.cnt)))) {
     var.cnt <- sjmisc::to_value(var.cnt, keep.labels = FALSE)
-  else
+  } else {
     var.cnt <- as.numeric(var.cnt)
+  }
 
-  if (anyNA(as.numeric(stats::na.omit(var.grp))))
+  if (anyNA(as.numeric(stats::na.omit(var.grp)))) {
     var.grp <- sjmisc::to_value(var.grp, keep.labels = FALSE)
-  else
+  } else {
     var.grp <- as.numeric(var.grp)
+  }
 
   # Define amount of categories
   grpcount <- length(legend.labels)
@@ -423,7 +460,13 @@ plot_grpfrq <- function(var.cnt,
   # and weight variable
   colrange <- 2:(grpcount + 1)
   mydf <-
-    tidyr::gather(mydat$mydat, key = ""group"", value = ""frq"", !! colrange, factor_key = TRUE)
+    tidyr::gather(
+      mydat$mydat,
+      key = ""group"",
+      value = ""frq"",
+      !!colrange,
+      factor_key = TRUE
+    )
 
   # add xpos now
   mydf$xpos <- as.factor(as.numeric(bars.xpos))
@@ -444,10 +487,11 @@ plot_grpfrq <- function(var.cnt,
     w <- ifelse(is.null(weight.by), 1, weight.by)
 
     # interaction variable
-    if (is.null(intr.var))
+    if (is.null(intr.var)) {
       iav <- 1
-    else
+    } else {
       iav <- intr.var
+    }
 
     # new data frame for box plots
     mydf <-
@@ -458,8 +502,10 @@ plot_grpfrq <- function(var.cnt,
         wb = w
       )))
 
-    if (!is.null(axis.labels) &&
-        length(axis.labels) > dplyr::n_distinct(mydf$group, na.rm = TRUE)) {
+    if (
+      !is.null(axis.labels) &&
+        length(axis.labels) > dplyr::n_distinct(mydf$group, na.rm = TRUE)
+    ) {
       axis.labels <- axis.labels[na.omit(unique(mydf$group))]
     }
 
@@ -470,7 +516,9 @@ plot_grpfrq <- function(var.cnt,
   # create expression with model summarys. used
   # for plotting in the diagram later
   mannwhitneyu <- function(count, grp) {
-    if (min(grp, na.rm = TRUE) == 0) grp <- grp + 1
+    if (min(grp, na.rm = TRUE) == 0) {
+      grp <- grp + 1
+    }
     completeString <- """"
     cnt <- length(unique(stats::na.omit(grp)))
     for (i in 1:cnt) {
@@ -485,64 +533,74 @@ plot_grpfrq <- function(var.cnt,
 
           if (wt$p.value < 0.001) {
             modsum <- as.character(as.expression(substitute(
-              p[pgrp] < pval, list(pgrp = sprintf(""(%i|%i)"", i, j), pval = 0.001)
+              p[pgrp] < pval,
+              list(pgrp = sprintf(""(%i|%i)"", i, j), pval = 0.001)
             )))
           } else {
             modsum <- as.character(as.expression(substitute(
               p[pgrp] == pval,
-              list(pgrp = sprintf(""(%i|%i)"", i, j),
-                   pval = sprintf(""%.3f"", wt$p.value)))))
+              list(
+                pgrp = sprintf(""(%i|%i)"", i, j),
+                pval = sprintf(""%.3f"", wt$p.value)
+              )
+            )))
           }
-          completeString <- sprintf(""%s * \"",\"" ~ ~ %s"",
-                                    completeString,
-                                    modsum)
+          completeString <- sprintf(""%s * \"",\"" ~ ~ %s"", completeString, modsum)
         }
       }
     }
-    return(paste(""\""Mann-Whitney-U:\"" ~ ~ "",
-                 substring(completeString, 12),
-                 sep = """"))
+    return(paste(
+      ""\""Mann-Whitney-U:\"" ~ ~ "",
+      substring(completeString, 12),
+      sep = """"
+    ))
   }
 
   # Check whether table summary should be printed
   modsum <- NULL
   if (show.summary) {
-    if (type == ""boxplot"" || type == ""violin"")
+    if (type == ""boxplot"" || type == ""violin"") {
       modsum <- mannwhitneyu(var.cnt, var.grp)
-    else
+    } else {
       modsum <- crosstabsum(var.cnt, var.grp, weight.by)
+    }
   }
 
   # Prepare and trim legend labels to appropriate size
-  if (!is.null(legend.labels))
+  if (!is.null(legend.labels)) {
     legend.labels <- sjmisc::word_wrap(legend.labels, wrap.legend.labels)
+  }
 
-  if (!is.null(legend.title))
+  if (!is.null(legend.title)) {
     legend.title <- sjmisc::word_wrap(legend.title, wrap.legend.title)
+  }
 
   if (!is.null(title)) {
     # if we have weighted values, say that in diagram's title
-    if (!is.null(title.wtd.suffix))
+    if (!is.null(title.wtd.suffix)) {
       title <- paste(title, title.wtd.suffix, sep = """")
+    }
     title <- sjmisc::word_wrap(title, wrap.title)
   }
 
-  if (!is.null(axisTitle.x))
+  if (!is.null(axisTitle.x)) {
     axisTitle.x <- sjmisc::word_wrap(axisTitle.x, wrap.title)
+  }
 
-  if (!is.null(axisTitle.y))
+  if (!is.null(axisTitle.y)) {
     axisTitle.y <- sjmisc::word_wrap(axisTitle.y, wrap.title)
+  }
 
-  if (!is.null(axis.labels))
+  if (!is.null(axis.labels)) {
     axis.labels <- sjmisc::word_wrap(axis.labels, wrap.labels)
+  }
 
   if (!is.null(intr.var)) {
     if (!is.null(intr.var.labels)) {
       intr.var.labels <- sjmisc::word_wrap(intr.var.labels, wrap.labels)
-    }
-    # If interaction-variable-labels were not defined, simply set numbers from 1 to
-    # amount of categories instead
-    else {
+    } else {
+      # If interaction-variable-labels were not defined, simply set numbers from 1 to
+      # amount of categories instead
       iavarLabLength <- length(unique(stats::na.omit(intr.var)))
       intr.var.labels <- 1:iavarLabLength
     }
@@ -594,8 +652,10 @@ plot_grpfrq <- function(var.cnt,
     # the y axis
     if (type == ""boxplot"" || type == ""violin"") {
       # use an extra standard-deviation as limits for the y-axis when we have boxplots
-      lower_lim <- min(var.cnt, na.rm = TRUE) - floor(stats::sd(var.cnt, na.rm = TRUE))
-      upper_lim <- max(var.cnt, na.rm = TRUE) + ceiling(stats::sd(var.cnt, na.rm = TRUE))
+      lower_lim <- min(var.cnt, na.rm = TRUE) -
+        floor(stats::sd(var.cnt, na.rm = TRUE))
+      upper_lim <- max(var.cnt, na.rm = TRUE) +
+        ceiling(stats::sd(var.cnt, na.rm = TRUE))
       # make sure that the y-axis is not below zero
       if (lower_lim < 0) {
         lower_lim <- 0
@@ -612,12 +672,13 @@ plot_grpfrq <- function(var.cnt,
   }
 
   # align dodged position of labels to bar positions
-  if (type == ""line"")
+  if (type == ""line"") {
     posdodge <- 0
-  else if (type == ""dot"")
+  } else if (type == ""dot"") {
     posdodge <- geom.spacing
-  else
+  } else {
     posdodge <- geom.size + geom.spacing
+  }
 
   # init shaded rectangles for plot
   ganno <- NULL
@@ -627,7 +688,11 @@ plot_grpfrq <- function(var.cnt,
     # position_dodge displays dots in a dodged position so we avoid overlay here. This may lead
     # to a more difficult distinction of group belongings, since the dots are ""horizontally spread""
     # over the digram. For a better overview, we can add a ""PlotAnnotation"" (see ""emph.dots) here.
-    geob <- ggplot2::geom_point(position = ggplot2::position_dodge(posdodge),size = geom.size, shape = 16)
+    geob <- ggplot2::geom_point(
+      position = ggplot2::position_dodge(posdodge),
+      size = geom.size,
+      shape = 16
+    )
 
     # create shaded rectangle, so we know which dots belong to the same category
     if (emph.dots) {
@@ -642,47 +707,84 @@ plot_grpfrq <- function(var.cnt,
       )
     }
   } else if (type == ""bar"") {
-    if (bar.pos == ""dodge"")
-      geob <- ggplot2::geom_bar(stat = ""identity"", width = geom.size, position = ggplot2::position_dodge(posdodge))
-    else
-      geob <- ggplot2::geom_bar(stat = ""identity"", width = geom.size, position = ggplot2::position_stack(reverse = TRUE))
+    if (bar.pos == ""dodge"") {
+      geob <- ggplot2::geom_bar(
+        stat = ""identity"",
+        width = geom.size,
+        position = ggplot2::position_dodge(posdodge)
+      )
+    } else {
+      geob <- ggplot2::geom_bar(
+        stat = ""identity"",
+        width = geom.size,
+        position = ggplot2::position_stack(reverse = TRUE)
+      )
+    }
   } else if (type == ""line"") {
-    if (smooth.lines)
-      geob <- ggplot2::geom_line(linewidth = geom.size, stat = ""smooth"", method = ""loess"")
-    else
+    if (smooth.lines) {
+      geob <- ggplot2::geom_line(
+        linewidth = geom.size,
+        stat = ""smooth"",
+        method = ""loess""
+      )
+    } else {
       geob <- ggplot2::geom_line(linewidth = geom.size)
+    }
   } else if (type == ""boxplot"") {
-      geob <- ggplot2::geom_boxplot(width = geom.size, notch = show.ci)
+    geob <- ggplot2::geom_boxplot(width = geom.size, notch = show.ci)
   } else if (type == ""violin"") {
     geob <- ggplot2::geom_violin(trim = trimViolin, width = geom.size)
   } else {
-    geob <- ggplot2::geom_bar(stat = ""identity"", position = bar.pos, width = geom.size)
+    geob <- ggplot2::geom_bar(
+      stat = ""identity"",
+      position = bar.pos,
+      width = geom.size
+    )
   }
 
   # don't display value labels when we have boxplots or violin plots
-  if (type == ""boxplot"" || type == ""violin"") show.values <- FALSE
+  if (type == ""boxplot"" || type == ""violin"") {
+    show.values <- FALSE
+  }
 
   if (show.values) {
     # set text positioning
-    if (facet.grid)
+    if (facet.grid) {
       text.pos <- ""identity""
-    else
+    } else {
       text.pos <- ggplot2::position_dodge(posdodge)
+    }
 
     # if we have stacked bars, we need to apply
     # this stacked y-position to the labels as well
     if (bar.pos == ""stack"") {
       if (show.prc && show.n) {
         ggvaluelabels <-
-          ggplot2::geom_text(ggplot2::aes(y = .data$ypos, label = sprintf(""%i\n(%.01f%%)"", .data$frq, .data$prz)), show.legend = FALSE)
+          ggplot2::geom_text(
+            ggplot2::aes(
+              y = .data$ypos,
+              label = sprintf(""%i\n(%.01f%%)"", .data$frq, .data$prz)
+            ),
+            show.legend = FALSE
+          )
       } else if (show.n) {
         ggvaluelabels <-
-          ggplot2::geom_text(ggplot2::aes(y = .data$ypos, label = sprintf(""%i"", .data$frq)), show.legend = FALSE)
+          ggplot2::geom_text(
+            ggplot2::aes(y = .data$ypos, label = sprintf(""%i"", .data$frq)),
+            show.legend = FALSE
+          )
       } else if (show.prc) {
         ggvaluelabels <-
-          ggplot2::geom_text(ggplot2::aes(y = .data$ypos, label = sprintf(""%.01f%%"", .data$prz)), show.legend = FALSE)
+          ggplot2::geom_text(
+            ggplot2::aes(y = .data$ypos, label = sprintf(""%.01f%%"", .data$prz)),
+            show.legend = FALSE
+          )
       } else {
-        ggvaluelabels <- ggplot2::geom_text(ggplot2::aes(y = .data$frq), label = """", show.legend = FALSE)
+        ggvaluelabels <- ggplot2::geom_text(
+          ggplot2::aes(y = .data$frq),
+          label = """",
+          show.legend = FALSE
+        )
       }
     } else {
       # if we have dodged bars or dots, we have to use a slightly
@@ -692,7 +794,10 @@ plot_grpfrq <- function(var.cnt,
         if (coord.flip) {
           ggvaluelabels <-
             ggplot2::geom_text(
-              ggplot2::aes(y = .data$frq + y_offset, label = sprintf(""%i (%.01f%%)"", .data$frq, .data$prz)),
+              ggplot2::aes(
+                y = .data$frq + y_offset,
+                label = sprintf(""%i (%.01f%%)"", .data$frq, .data$prz)
+              ),
               position = text.pos,
               vjust = vjust,
               hjust = hjust,
@@ -701,7 +806,10 @@ plot_grpfrq <- function(var.cnt,
         } else {
           ggvaluelabels <-
             ggplot2::geom_text(
-              ggplot2::aes(y = .data$frq + y_offset, label = sprintf(""%i\n(%.01f%%)"", .data$frq, .data$prz)),
+              ggplot2::aes(
+                y = .data$frq + y_offset,
+                label = sprintf(""%i\n(%.01f%%)"", .data$frq, .data$prz)
+              ),
               position = text.pos,
               vjust = vjust,
               hjust = hjust,
@@ -711,7 +819,10 @@ plot_grpfrq <- function(var.cnt,
       } else if (show.n) {
         ggvaluelabels <-
           ggplot2::geom_text(
-            ggplot2::aes(y = .data$frq + y_offset, label = sprintf(""%i"", .data$frq)),
+            ggplot2::aes(
+              y = .data$frq + y_offset,
+              label = sprintf(""%i"", .data$frq)
+            ),
             position = text.pos,
             hjust = hjust,
             vjust = vjust,
@@ -720,25 +831,37 @@ plot_grpfrq <- function(var.cnt,
       } else if (show.prc) {
         ggvaluelabels <-
           ggplot2::geom_text(
-            ggplot2::aes(y = .data$frq + y_offset, label = sprintf(""%.01f%%"", .data$prz)),
+            ggplot2::aes(
+              y = .data$frq + y_offset,
+              label = sprintf(""%.01f%%"", .data$prz)
+            ),
             position = text.pos,
             hjust = hjust,
             vjust = vjust,
             show.legend = FALSE
           )
       } else {
-        ggvaluelabels <- ggplot2::geom_text(ggplot2::aes(y = .data$frq), label = """", show.legend = FALSE)
+        ggvaluelabels <- ggplot2::geom_text(
+          ggplot2::aes(y = .data$frq),
+          label = """",
+          show.legend = FALSE
+        )
       }
     }
   } else {
-    ggvaluelabels <- ggplot2::geom_text(ggplot2::aes(y = .data$frq), label = """", show.legend = FALSE)
+    ggvaluelabels <- ggplot2::geom_text(
+      ggplot2::aes(y = .data$frq),
+      label = """",
+      show.legend = FALSE
+    )
   }
 
   # Set up grid breaks
-  if (is.null(grid.breaks))
+  if (is.null(grid.breaks)) {
     gridbreaks <- ggplot2::waiver()
-  else
+  } else {
     gridbreaks <- seq(lower_lim, upper_lim, by = grid.breaks)
+  }
 
   # Print plot
   if (type == ""line"") {
@@ -747,35 +870,45 @@ plot_grpfrq <- function(var.cnt,
 
     # lines need colour aes
     baseplot <-
-      ggplot2::ggplot(mydf,
-             ggplot2::aes_string(
-               x = ""xpos"",
-               y = ""frq"",
-               colour = ""group"",
-               linetype = ""group""
-             )) + geob
+      ggplot2::ggplot(
+        mydf,
+        ggplot2::aes_string(
+          x = ""xpos"",
+          y = ""frq"",
+          colour = ""group"",
+          linetype = ""group""
+        )
+      ) +
+      geob
 
     # continuous scale for lines needed
     scalex <- ggplot2::scale_x_continuous()
   } else if (type == ""boxplot"" || type == ""violin"") {
     if (is.null(intr.var)) {
       baseplot <-
-        ggplot2::ggplot(mydf,
-               ggplot2::aes_string(
-                 x = ""group"",
-                 y = ""frq"",
-                 fill = ""group"",
-                 weight = ""wb""
-               )) + geob
+        ggplot2::ggplot(
+          mydf,
+          ggplot2::aes_string(
+            x = ""group"",
+            y = ""frq"",
+            fill = ""group"",
+            weight = ""wb""
+          )
+        ) +
+        geob
       scalex <- ggplot2::scale_x_discrete(labels = axis.labels)
     } else {
       baseplot <-
-        ggplot2::ggplot(mydf, ggplot2::aes(
-          x = interaction(.data$ia, .data$group),
-          y = .data$frq,
-          fill = .data$group,
-          weight = .data$wb
-        )) + geob
+        ggplot2::ggplot(
+          mydf,
+          ggplot2::aes(
+            x = interaction(.data$ia, .data$group),
+            y = .data$frq,
+            fill = .data$group,
+            weight = .data$wb
+          )
+        ) +
+        geob
       scalex <- ggplot2::scale_x_discrete(labels = intr.var.labels)
     }
 
@@ -784,10 +917,19 @@ plot_grpfrq <- function(var.cnt,
     if (type == ""violin"") {
       if (show.ci) {
         baseplot <- baseplot +
-          ggplot2::geom_boxplot(width = inner.box.width, fill = ""white"", outlier.colour = NA, notch = TRUE)
+          ggplot2::geom_boxplot(
+            width = inner.box.width,
+            fill = ""white"",
+            outlier.colour = NA,
+            notch = TRUE
+          )
       } else {
         baseplot <- baseplot +
-          ggplot2::geom_boxplot(width = inner.box.width, fill = ""white"", outlier.colour = NA)
+          ggplot2::geom_boxplot(
+            width = inner.box.width,
+            fill = ""white"",
+            outlier.colour = NA
+          )
       }
     }
 
@@ -796,19 +938,30 @@ plot_grpfrq <- function(var.cnt,
     # different fill colours, because violin boxplots have white background
     fcsp <- ifelse(type == ""boxplot"", ""white"", ""black"")
     baseplot <- baseplot +
-      ggplot2::stat_summary(fun = ""mean"", geom = ""point"", shape = 21,
-                   size = inner.box.dotsize, fill = fcsp)
+      ggplot2::stat_summary(
+        fun = ""mean"",
+        geom = ""point"",
+        shape = 21,
+        size = inner.box.dotsize,
+        fill = fcsp
+      )
   } else {
     if (type == ""dot"") {
-      baseplot <- ggplot2::ggplot(mydf, ggplot2::aes_string(x = ""xpos"", y = ""frq"", colour = ""group""))
+      baseplot <- ggplot2::ggplot(
+        mydf,
+        ggplot2::aes_string(x = ""xpos"", y = ""frq"", colour = ""group"")
+      )
 
       # check whether we have dots plotted, and if so, use annotation
       # We have to use annotation first, because the diagram's layers are plotted
       # in the order as they're passed to the ggplot-command. Since we don't want the
       # shaded rectangles to overlay the dots, we add them first
       if (!is.null(ganno) && !facet.grid) baseplot <- baseplot + ganno
     } else {
-      baseplot <- ggplot2::ggplot(mydf, ggplot2::aes_string(x = ""xpos"", y = ""frq"", fill = ""group""))
+      baseplot <- ggplot2::ggplot(
+        mydf,
+        ggplot2::aes_string(x = ""xpos"", y = ""frq"", fill = ""group"")
+      )
     }
 
     # add geom
@@ -861,7 +1014,9 @@ plot_grpfrq <- function(var.cnt,
     y_scale
 
   # check whether coordinates should be flipped
-  if (coord.flip) baseplot <- baseplot + ggplot2::coord_flip()
+  if (coord.flip) {
+    baseplot <- baseplot + ggplot2::coord_flip()
+  }
 
   # Here we start when we have a faces grid instead of
   # a grouped bar plot.
@@ -874,11 +1029,13 @@ plot_grpfrq <- function(var.cnt,
 
   # set geom colors
   baseplot <-
-    sj.setGeomColors(baseplot,
-                     geom.colors,
-                     length(legend.labels),
-                     show.legend,
-                     legend.labels)
+    sj.setGeomColors(
+      baseplot,
+      geom.colors,
+      length(legend.labels),
+      show.legend,
+      legend.labels
+    )
 
   # Plot integrated bar chart here
   baseplot"
strengejacke,sjPlot,c170b1e8753ec76b0311333579f9ef7ef987c9f1,Daniel,mail@danielluedecke.de,2025-07-01T10:58:32Z,Daniel,mail@danielluedecke.de,2025-07-01T10:58:32Z,fix,R/plot_gpt.R,False,True,True,False,179,43,222,"---FILE: R/plot_gpt.R---
@@ -110,10 +110,31 @@ plot_gpt <- function(
       # plot
 
       plots <- gpt_helper(
-        x, y, grp, colors, geom.size, shape.fill.color, shapes, title = tmp.title,
-        axis.labels, axis.titles, legend.title, legend.labels, wrap.title,
-        wrap.labels, wrap.legend.title, wrap.legend.labels, axis.lim,
-        grid.breaks, show.total, annotate.total, show.p, show.n, name.x, name.y, name.grp
+        x,
+        y,
+        grp,
+        colors,
+        geom.size,
+        shape.fill.color,
+        shapes,
+        title = tmp.title,
+        axis.labels,
+        axis.titles,
+        legend.title,
+        legend.labels,
+        wrap.title,
+        wrap.labels,
+        wrap.legend.title,
+        wrap.legend.labels,
+        axis.lim,
+        grid.breaks,
+        show.total,
+        annotate.total,
+        show.p,
+        show.n,
+        name.x,
+        name.y,
+        name.grp
       )
 
       # add plots, check for NULL results
@@ -128,10 +149,31 @@ plot_gpt <- function(
     # plot
 
     pl <- gpt_helper(
-      x, y, grp, colors, geom.size, shape.fill.color, shapes, title,
-      axis.labels, axis.titles, legend.title, legend.labels, wrap.title,
-      wrap.labels, wrap.legend.title, wrap.legend.labels, axis.lim,
-      grid.breaks, show.total, annotate.total, show.p, show.n, name.x, name.y, name.grp
+      x,
+      y,
+      grp,
+      colors,
+      geom.size,
+      shape.fill.color,
+      shapes,
+      title,
+      axis.labels,
+      axis.titles,
+      legend.title,
+      legend.labels,
+      wrap.title,
+      wrap.labels,
+      wrap.legend.title,
+      wrap.legend.labels,
+      axis.lim,
+      grid.breaks,
+      show.total,
+      annotate.total,
+      show.p,
+      show.n,
+      name.x,
+      name.y,
+      name.grp
     )
   }
 
@@ -140,27 +182,55 @@ plot_gpt <- function(
 
 
 gpt_helper <- function(
-  x, y, grp, colors, geom.size, shape.fill.color, shapes, title,
-  axis.labels, axis.titles, legend.title, legend.labels, wrap.title,
-  wrap.labels, wrap.legend.title, wrap.legend.labels, axis.lim,
-  grid.breaks, show.total, annotate.total, show.p, show.n, name.x, name.y, name.grp
+  x,
+  y,
+  grp,
+  colors,
+  geom.size,
+  shape.fill.color,
+  shapes,
+  title,
+  axis.labels,
+  axis.titles,
+  legend.title,
+  legend.labels,
+  wrap.title,
+  wrap.labels,
+  wrap.legend.title,
+  wrap.legend.labels,
+  axis.lim,
+  grid.breaks,
+  show.total,
+  annotate.total,
+  show.p,
+  show.n,
+  name.x,
+  name.y,
+  name.grp
 ) {
   # any missing names?
 
-  if (is.null(name.x) || name.x == ""NULL"") name.x <- """"
-  if (is.null(name.y) || name.y == ""NULL"") name.y <- """"
-  if (is.null(name.grp) || name.grp == ""NULL"") name.grp <- """"
+  if (is.null(name.x) || name.x == ""NULL"") {
+    name.x <- """"
+  }
+  if (is.null(name.y) || name.y == ""NULL"") {
+    name.y <- """"
+  }
+  if (is.null(name.grp) || name.grp == ""NULL"") {
+    name.grp <- """"
+  }
 
   # copy titles
   if (is.null(axis.titles)) {
     axisTitle.x <- NULL
     axisTitle.y <- NULL
   } else {
     axisTitle.x <- axis.titles[1]
-    if (length(axis.titles) > 1)
+    if (length(axis.titles) > 1) {
       axisTitle.y <- axis.titles[2]
-    else
+    } else {
       axisTitle.y <- NULL
+    }
   }
 
   # try to automatically set labels if not passed as argument
@@ -170,7 +240,7 @@ gpt_helper <- function(
       y,
       attr.only = FALSE,
       values = NULL,
-      non.labelled = T
+      non.labelled = TRUE
     )
 
   # get only value label for hightest category
@@ -181,7 +251,7 @@ gpt_helper <- function(
         grp,
         attr.only = FALSE,
         values = NULL,
-        non.labelled = T
+        non.labelled = TRUE
       )
   }
 
@@ -208,20 +278,34 @@ gpt_helper <- function(
         x,
         attr.only = FALSE,
         values = NULL,
-        non.labelled = T
+        non.labelled = TRUE
       )
   }
 
   # set labels that are still missing, but which need values
-  if (is.null(axis.labels)) axis.labels <- as.character(seq_len(length(grp)))
+  if (is.null(axis.labels)) {
+    axis.labels <- as.character(seq_len(length(grp)))
+  }
 
   # wrap titles and labels
-  if (!is.null(legend.labels)) legend.labels <- sjmisc::word_wrap(legend.labels, wrap.legend.labels)
-  if (!is.null(legend.title)) legend.title <- sjmisc::word_wrap(legend.title, wrap.legend.title)
-  if (!is.null(title)) title <- sjmisc::word_wrap(title, wrap.title)
-  if (!is.null(axisTitle.x)) axisTitle.x <- sjmisc::word_wrap(axisTitle.x, wrap.title)
-  if (!is.null(axisTitle.y)) axisTitle.y <- sjmisc::word_wrap(axisTitle.y, wrap.title)
-  if (!is.null(axis.labels)) axis.labels <- sjmisc::word_wrap(axis.labels, wrap.labels)
+  if (!is.null(legend.labels)) {
+    legend.labels <- sjmisc::word_wrap(legend.labels, wrap.legend.labels)
+  }
+  if (!is.null(legend.title)) {
+    legend.title <- sjmisc::word_wrap(legend.title, wrap.legend.title)
+  }
+  if (!is.null(title)) {
+    title <- sjmisc::word_wrap(title, wrap.title)
+  }
+  if (!is.null(axisTitle.x)) {
+    axisTitle.x <- sjmisc::word_wrap(axisTitle.x, wrap.title)
+  }
+  if (!is.null(axisTitle.y)) {
+    axisTitle.y <- sjmisc::word_wrap(axisTitle.y, wrap.title)
+  }
+  if (!is.null(axis.labels)) {
+    axis.labels <- sjmisc::word_wrap(axis.labels, wrap.labels)
+  }
 
   # final data frame for plot
   newdf <- data.frame()
@@ -254,14 +338,22 @@ gpt_helper <- function(
 
   pvals <- mydf |>
     dplyr::group_by(.data$grp) |>
-    dplyr::summarise(N = dplyr::n(), p = suppressWarnings(stats::chisq.test(table(.data$xpos, .data$dep))$p.value))
+    dplyr::summarise(
+      N = dplyr::n(),
+      p = suppressWarnings(
+        stats::chisq.test(table(.data$xpos, .data$dep))$p.value
+      )
+    )
 
   # copy p values
-  for (i in seq_len(length(pvals$grp))) group.p[i] <- get_p_stars(pvals$p[i])
+  for (i in seq_len(length(pvals$grp))) {
+    group.p[i] <- get_p_stars(pvals$p[i])
+  }
 
   # copy N
-  for (i in seq_len(length(pvals$grp)))
+  for (i in seq_len(length(pvals$grp))) {
     group.n[i] <- prettyNum(pvals$N[i], big.mark = "","", scientific = FALSE)
+  }
 
   # if we want total line, repeat all for
   # complete data frame
@@ -272,15 +364,23 @@ gpt_helper <- function(
 
     # pvalues and N
     pvals <- mydf |>
-      dplyr::summarise(N = dplyr::n(), p = suppressWarnings(stats::chisq.test(table(.data$xpos, .data$dep))$p.value))
+      dplyr::summarise(
+        N = dplyr::n(),
+        p = suppressWarnings(
+          stats::chisq.test(table(.data$xpos, .data$dep))$p.value
+        )
+      )
 
     # bind total row to final df
     newdf <- dplyr::bind_rows(newdf, tmp)
 
     # copy p values
     group.p <- c(group.p, get_p_stars(pvals$p))
     # copy N
-    group.n <- c(group.n, prettyNum(pvals$N, big.mark = "","", scientific = FALSE))
+    group.n <- c(
+      group.n,
+      prettyNum(pvals$N, big.mark = "","", scientific = FALSE)
+    )
     # add ""total"" to axis labels
     axis.labels <- c(axis.labels, ""Total"")
   }
@@ -293,35 +393,71 @@ gpt_helper <- function(
   newdf$ypos <- sjlabelled::as_numeric(newdf$ypos, keep.labels = FALSE)
 
   # add N and p-values to axis labels?
-  if (show.n) axis.labels <- paste0(axis.labels, "" (n="", group.n, "")"")
-  if (show.p) axis.labels <- paste0(axis.labels, "" "", group.p)
+  if (show.n) {
+    axis.labels <- paste0(axis.labels, "" (n="", group.n, "")"")
+  }
+  if (show.p) {
+    axis.labels <- paste0(axis.labels, "" "", group.p)
+  }
 
   # Set up axis limits
-  if (is.null(axis.lim)) axis.lim <- c(0, max(pretty(max(newdf$ypos, na.rm = TRUE), 10)))
+  if (is.null(axis.lim)) {
+    axis.lim <- c(0, max(pretty(max(newdf$ypos, na.rm = TRUE), 10)))
+  }
 
   # Set up grid breaks
-  if (is.null(grid.breaks))
+  if (is.null(grid.breaks)) {
     gridbreaks <- ggplot2::waiver()
-  else
+  } else {
     gridbreaks <- seq(axis.lim[1], axis.lim[2], by = grid.breaks)
+  }
 
   # Set up geom colors
   pal.len <- length(legend.labels)
   geom.colors <- col_check2(colors, pal.len)
 
   # Set up plot
-  p <- ggplot2::ggplot(newdf, ggplot2::aes(x = rev(.data$grp), y = .data$ypos, colour = .data$xpos, shape = .data$xpos)) +
+  p <- ggplot2::ggplot(
+    newdf,
+    ggplot2::aes(
+      x = rev(.data$grp),
+      y = .data$ypos,
+      colour = .data$xpos,
+      shape = .data$xpos
+    )
+  ) +
     ggplot2::geom_point(size = geom.size, fill = shape.fill.color) +
-    ggplot2::scale_y_continuous(labels = scales::percent, breaks = gridbreaks, limits = axis.lim) +
+    ggplot2::scale_y_continuous(
+      labels = scales::percent,
+      breaks = gridbreaks,
+      limits = axis.lim
+    ) +
     ggplot2::scale_x_discrete(labels = rev(axis.labels)) +
-    ggplot2::scale_shape_manual(name = legend.title, labels = legend.labels, values = shapes[1:pal.len]) +
-    ggplot2::scale_colour_manual(name = legend.title, labels = legend.labels, values = geom.colors) +
+    ggplot2::scale_shape_manual(
+      name = legend.title,
+      labels = legend.labels,
+      values = shapes[1:pal.len]
+    ) +
+    ggplot2::scale_colour_manual(
+      name = legend.title,
+      labels = legend.labels,
+      values = geom.colors
+    ) +
     ggplot2::labs(x = axisTitle.x, y = axisTitle.y, title = title) +
     ggplot2::coord_flip()
 
   # Annotate total line?
-  if (show.total && annotate.total)
-    p <- p + ggplot2::annotate(""rect"", xmin = 0.5,  xmax = 1.5, ymin = -Inf, ymax = Inf, alpha = 0.15)
+  if (show.total && annotate.total) {
+    p <- p +
+      ggplot2::annotate(
+        ""rect"",
+        xmin = 0.5,
+        xmax = 1.5,
+        ymin = -Inf,
+        ymax = Inf,
+        alpha = 0.15
+      )
+  }
 
   p
 }"
strengejacke,sjPlot,11d0a2b79a4e819c2931a683eb11d2e002178635,Daniel,mail@danielluedecke.de,2025-07-01T10:55:41Z,Daniel,mail@danielluedecke.de,2025-07-01T10:55:41Z,fix,R/plot_diag_linear.R;R/plot_frq.R;R/plot_grpfrq.R,False,True,True,False,364,157,521,"---FILE: R/plot_diag_linear.R---
@@ -60,7 +60,7 @@ diag_norm <- function(model, geom.colors) {
 
   ggplot2::ggplot(res_, ggplot2::aes_string(x = ""res"")) +
     ggplot2::geom_density(fill = geom.colors[1], alpha = 0.2) +
-    stat_function(
+    ggplot2::stat_function(
       fun = dnorm,
       args = list(
         mean = mean(unname(stats::residuals(model)), na.rm = TRUE),

---FILE: R/plot_frq.R---
@@ -111,53 +111,54 @@ utils::globalVariables(""density"")
 #' }
 #' @importFrom rlang .data
 #' @export
-plot_frq <- function(data,
-                     ...,
-                    title = """",
-                    weight.by = NULL,
-                    title.wtd.suffix = NULL,
-                    sort.frq = c(""none"", ""asc"", ""desc""),
-                    type = c(""bar"", ""dot"", ""histogram"", ""line"", ""density"", ""boxplot"", ""violin""),
-                    geom.size = NULL,
-                    geom.colors = ""#336699"",
-                    errorbar.color = ""darkred"",
-                    axis.title = NULL,
-                    axis.labels = NULL,
-                    xlim = NULL,
-                    ylim = NULL,
-                    wrap.title = 50,
-                    wrap.labels = 20,
-                    grid.breaks = NULL,
-                    expand.grid = FALSE,
-                    show.values = TRUE,
-                    show.n = TRUE,
-                    show.prc = TRUE,
-                    show.axis.values = TRUE,
-                    show.ci = FALSE,
-                    show.na = FALSE,
-                    show.mean = FALSE,
-                    show.mean.val = TRUE,
-                    show.sd = TRUE,
-                    drop.empty = TRUE,
-                    mean.line.type = 2,
-                    mean.line.size = 0.5,
-                    inner.box.width = 0.15,
-                    inner.box.dotsize = 3,
-                    normal.curve = FALSE,
-                    normal.curve.color = ""red"",
-                    normal.curve.size = 0.8,
-                    normal.curve.alpha = 0.4,
-                    auto.group = NULL,
-                    coord.flip = FALSE,
-                    vjust = ""bottom"",
-                    hjust = ""center"",
-                    y.offset = NULL) {
-
+plot_frq <- function(
+  data,
+  ...,
+  title = """",
+  weight.by = NULL,
+  title.wtd.suffix = NULL,
+  sort.frq = c(""none"", ""asc"", ""desc""),
+  type = c(""bar"", ""dot"", ""histogram"", ""line"", ""density"", ""boxplot"", ""violin""),
+  geom.size = NULL,
+  geom.colors = ""#336699"",
+  errorbar.color = ""darkred"",
+  axis.title = NULL,
+  axis.labels = NULL,
+  xlim = NULL,
+  ylim = NULL,
+  wrap.title = 50,
+  wrap.labels = 20,
+  grid.breaks = NULL,
+  expand.grid = FALSE,
+  show.values = TRUE,
+  show.n = TRUE,
+  show.prc = TRUE,
+  show.axis.values = TRUE,
+  show.ci = FALSE,
+  show.na = FALSE,
+  show.mean = FALSE,
+  show.mean.val = TRUE,
+  show.sd = TRUE,
+  drop.empty = TRUE,
+  mean.line.type = 2,
+  mean.line.size = 0.5,
+  inner.box.width = 0.15,
+  inner.box.dotsize = 3,
+  normal.curve = FALSE,
+  normal.curve.color = ""red"",
+  normal.curve.size = 0.8,
+  normal.curve.alpha = 0.4,
+  auto.group = NULL,
+  coord.flip = FALSE,
+  vjust = ""bottom"",
+  hjust = ""center"",
+  y.offset = NULL
+) {
   # Match arguments -----
   type <- match.arg(type)
   sort.frq <- match.arg(sort.frq)
 
-  plot_data  <- get_dplyr_dot_data(data, dplyr::quos(...))
+  plot_data <- get_dplyr_dot_data(data, dplyr::quos(...))
 
   if (!is.data.frame(plot_data)) {
     plot_data <- data.frame(plot_data, stringsAsFactors = FALSE)
@@ -182,13 +183,47 @@ plot_frq <- function(data,
 
       plots <- lapply(colnames(tmp), function(.d) {
         plot_frq_helper(
-          var.cnt = tmp[[.d]], title = tmp.title, weight.by = weight.by, title.wtd.suffix, sort.frq, type, geom.size, geom.colors,
-          errorbar.color, axis.title, axis.labels, xlim, ylim, wrap.title, wrap.labels, grid.breaks,
-          expand.grid, show.values, show.n, show.prc, show.axis.values, show.ci, show.na,
-          show.mean, show.mean.val, show.sd, drop.empty, mean.line.type, mean.line.size,
-          inner.box.width, inner.box.dotsize, normal.curve, normal.curve.color,
-          normal.curve.size, normal.curve.alpha, auto.group, coord.flip, vjust,
-          hjust, y.offset, var.name = .d
+          var.cnt = tmp[[.d]],
+          title = tmp.title,
+          weight.by = weight.by,
+          title.wtd.suffix,
+          sort.frq,
+          type,
+          geom.size,
+          geom.colors,
+          errorbar.color,
+          axis.title,
+          axis.labels,
+          xlim,
+          ylim,
+          wrap.title,
+          wrap.labels,
+          grid.breaks,
+          expand.grid,
+          show.values,
+          show.n,
+          show.prc,
+          show.axis.values,
+          show.ci,
+          show.na,
+          show.mean,
+          show.mean.val,
+          show.sd,
+          drop.empty,
+          mean.line.type,
+          mean.line.size,
+          inner.box.width,
+          inner.box.dotsize,
+          normal.curve,
+          normal.curve.color,
+          normal.curve.size,
+          normal.curve.alpha,
+          auto.group,
+          coord.flip,
+          vjust,
+          hjust,
+          y.offset,
+          var.name = .d
         )
       })
 
@@ -198,13 +233,47 @@ plot_frq <- function(data,
   } else {
     pl <- lapply(colnames(plot_data), function(.d) {
       plot_frq_helper(
-        var.cnt = plot_data[[.d]], title, weight.by = weight.by, title.wtd.suffix, sort.frq, type, geom.size, geom.colors,
-        errorbar.color, axis.title, axis.labels, xlim, ylim, wrap.title, wrap.labels, grid.breaks,
-        expand.grid, show.values, show.n, show.prc, show.axis.values, show.ci, show.na,
-        show.mean, show.mean.val, show.sd, drop.empty, mean.line.type, mean.line.size,
-        inner.box.width, inner.box.dotsize, normal.curve, normal.curve.color,
-        normal.curve.size, normal.curve.alpha, auto.group, coord.flip, vjust,
-        hjust, y.offset, var.name = .d
+        var.cnt = plot_data[[.d]],
+        title,
+        weight.by = weight.by,
+        title.wtd.suffix,
+        sort.frq,
+        type,
+        geom.size,
+        geom.colors,
+        errorbar.color,
+        axis.title,
+        axis.labels,
+        xlim,
+        ylim,
+        wrap.title,
+        wrap.labels,
+        grid.breaks,
+        expand.grid,
+        show.values,
+        show.n,
+        show.prc,
+        show.axis.values,
+        show.ci,
+        show.na,
+        show.mean,
+        show.mean.val,
+        show.sd,
+        drop.empty,
+        mean.line.type,
+        mean.line.size,
+        inner.box.width,
+        inner.box.dotsize,
+        normal.curve,
+        normal.curve.color,
+        normal.curve.size,
+        normal.curve.alpha,
+        auto.group,
+        coord.flip,
+        vjust,
+        hjust,
+        y.offset,
+        var.name = .d
       )
     })
 
@@ -216,55 +285,104 @@ plot_frq <- function(data,
 
 
 plot_frq_helper <- function(
-  var.cnt, title, weight.by, title.wtd.suffix, sort.frq, type, geom.size, geom.colors,
-  errorbar.color, axis.title, axis.labels, xlim, ylim, wrap.title, wrap.labels, grid.breaks,
-  expand.grid, show.values, show.n, show.prc, show.axis.values, show.ci, show.na,
-  show.mean, show.mean.val, show.sd, drop.empty, mean.line.type, mean.line.size,
-  inner.box.width, inner.box.dotsize, normal.curve, normal.curve.color,
-  normal.curve.size, normal.curve.alpha, auto.group, coord.flip, vjust,
-  hjust, y.offset, var.name = NULL) {
-
+  var.cnt,
+  title,
+  weight.by,
+  title.wtd.suffix,
+  sort.frq,
+  type,
+  geom.size,
+  geom.colors,
+  errorbar.color,
+  axis.title,
+  axis.labels,
+  xlim,
+  ylim,
+  wrap.title,
+  wrap.labels,
+  grid.breaks,
+  expand.grid,
+  show.values,
+  show.n,
+  show.prc,
+  show.axis.values,
+  show.ci,
+  show.na,
+  show.mean,
+  show.mean.val,
+  show.sd,
+  drop.empty,
+  mean.line.type,
+  mean.line.size,
+  inner.box.width,
+  inner.box.dotsize,
+  normal.curve,
+  normal.curve.color,
+  normal.curve.size,
+  normal.curve.alpha,
+  auto.group,
+  coord.flip,
+  vjust,
+  hjust,
+  y.offset,
+  var.name = NULL
+) {
   # remove empty value-labels
   if (drop.empty) {
     var.cnt <- sjlabelled::drop_labels(var.cnt)
   }
 
-
   # try to find some useful default offsets for textlabels,
   # depending on plot range and flipped coordinates
   if (is.null(y.offset)) {
     # get maximum y-pos
     y.offset <- ceiling(max(table(var.cnt)) / 100)
     if (coord.flip) {
-      if (missing(vjust)) vjust <- ""center""
-      if (missing(hjust)) hjust <- ""bottom""
-      if (hjust == ""bottom"")
+      if (missing(vjust)) {
+        vjust <- ""center""
+      }
+      if (missing(hjust)) {
+        hjust <- ""bottom""
+      }
+      if (hjust == ""bottom"") {
         y_offset <- y.offset
-      else if (hjust == ""top"")
+      } else if (hjust == ""top"") {
         y_offset <- -y.offset
-      else
+      } else {
         y_offset <- 0
+      }
     } else {
-      if (vjust == ""bottom"")
+      if (vjust == ""bottom"") {
         y_offset <- y.offset
-      else if (vjust == ""top"")
+      } else if (vjust == ""top"") {
         y_offset <- -y.offset
-      else
+      } else {
         y_offset <- 0
+      }
     }
   } else {
     y_offset <- y.offset
   }
 
-  if (is.null(axis.title)) axis.title <- sjlabelled::get_label(var.cnt, def.value = var.name)
-  if (is.null(title)) title <- sjlabelled::get_label(var.cnt, def.value = var.name)
+  if (is.null(axis.title)) {
+    axis.title <- sjlabelled::get_label(var.cnt, def.value = var.name)
+  }
+  if (is.null(title)) {
+    title <- sjlabelled::get_label(var.cnt, def.value = var.name)
+  }
 
   # remove titles if empty
-  if (!is.null(axis.title) && axis.title == """") axis.title <- NULL
-  if (!is.null(title) && title == """") title <- NULL
+  if (!is.null(axis.title) && axis.title == """") {
+    axis.title <- NULL
+  }
+  if (!is.null(title) && title == """") {
+    title <- NULL
+  }
 
   # check color argument
-  if (length(geom.colors) > 1) geom.colors <- geom.colors[1]
+  if (length(geom.colors) > 1) {
+    geom.colors <- geom.colors[1]
+  }
 
   # default grid-expansion
   if (isTRUE(expand.grid) || (missing(expand.grid) && type == ""histogram"")) {
@@ -277,10 +395,16 @@ plot_frq_helper <- function(
   xv <- sjmisc::to_value(stats::na.omit(var.cnt))
 
   # check for nice bin-width defaults
-  if (type %in% c(""histogram"", ""density"") &&
+  if (
+    type %in%
+      c(""histogram"", ""density"") &&
       !is.null(geom.size) &&
-      geom.size < round(diff(range(xv)) / 40))
-    message(""Using very small binwidth. Consider adjusting `geom.size` argument."")
+      geom.size < round(diff(range(xv)) / 40)
+  ) {
+    message(
+      ""Using very small binwidth. Consider adjusting `geom.size` argument.""
+    )
+  }
 
   # create second data frame
   hist.dat <- data.frame(xv)
@@ -333,7 +457,9 @@ plot_frq_helper <- function(
 
   mydat <- df.frq[[1]]
   # remove empty
-  if (drop.empty) mydat <- mydat[mydat$frq > 0, ]
+  if (drop.empty) {
+    mydat <- mydat[mydat$frq > 0, ]
+  }
 
   # add confindence intervals for frequencies
   total_n = sum(mydat$frq)
@@ -345,31 +471,41 @@ plot_frq_helper <- function(
   mydat$rel.lower.ci <- rel_frq - ci
 
   # any labels detected?
-  if (!is.null(mydat$label) && is.null(axis.labels) && !all(stats::na.omit(mydat$label) == ""<none>""))
+  if (
+    !is.null(mydat$label) &&
+      is.null(axis.labels) &&
+      !all(stats::na.omit(mydat$label) == ""<none>"")
+  ) {
     axis.labels <- mydat$label
-  else if (is.null(axis.labels))
+  } else if (is.null(axis.labels)) {
     axis.labels <- mydat$val
+  }
 
   # wrap labels
   axis.labels <- sjmisc::word_wrap(axis.labels, wrap.labels)
 
   # define text label position
-  if (show.ci)
+  if (show.ci) {
     mydat$label.pos <- mydat$upper.ci
-  else
+  } else {
     mydat$label.pos <- mydat$frq
+  }
 
   # Trim labels and title to appropriate size -----
   # check length of diagram title and split longer string into new lines
   # every 50 chars
   if (!is.null(title)) {
     # if we have weighted values, say that in diagram's title
-    if (!is.null(title.wtd.suffix)) title <- paste(title, title.wtd.suffix, sep = """")
+    if (!is.null(title.wtd.suffix)) {
+      title <- paste(title, title.wtd.suffix, sep = """")
+    }
     title <- sjmisc::word_wrap(title, wrap.title)
   }
   # check length of x-axis title and split longer string into new lines
   # every 50 chars
-  if (!is.null(axis.title)) axis.title <- sjmisc::word_wrap(axis.title, wrap.title)
+  if (!is.null(axis.title)) {
+    axis.title <- sjmisc::word_wrap(axis.title, wrap.title)
+  }
 
   # count variable may not be a factor!
   if (is.factor(var.cnt) || is.character(var.cnt)) {
@@ -409,8 +545,10 @@ plot_frq_helper <- function(
     # the y axis
     if (type == ""boxplot"" || type == ""violin"") {
       # use an extra standard-deviation as limits for the y-axis when we have boxplots
-      lower_lim <- min(var.cnt, na.rm = TRUE) - floor(stats::sd(var.cnt, na.rm = TRUE))
-      upper_lim <- max(var.cnt, na.rm = TRUE) + ceiling(stats::sd(var.cnt, na.rm = TRUE))
+      lower_lim <- min(var.cnt, na.rm = TRUE) -
+        floor(stats::sd(var.cnt, na.rm = TRUE))
+      upper_lim <- max(var.cnt, na.rm = TRUE) +
+        ceiling(stats::sd(var.cnt, na.rm = TRUE))
       # make sure that the y-axis is not below zero
       if (lower_lim < 0) {
         lower_lim <- 0
@@ -421,27 +559,35 @@ plot_frq_helper <- function(
       hist.grp.cnt <- ceiling(diff(range(var.cnt, na.rm = TRUE)) / geom.size)
       # ... or the amount of max. answers per category
       # add 10% margin to upper limit
-      upper_lim <- max(pretty(table(
-        sjmisc::group_var(
-          var.cnt,
-          size = ""auto"",
-          n = hist.grp.cnt,
-          append = FALSE
-        )
-      ) * 1.1))
+      upper_lim <- max(pretty(
+        table(
+          sjmisc::group_var(
+            var.cnt,
+            size = ""auto"",
+            n = hist.grp.cnt,
+            append = FALSE
+          )
+        ) *
+          1.1
+      ))
     } else {
-      if (show.ci)
+      if (show.ci) {
         upper_lim <- max(pretty(mydat$upper.ci * 1.1))
-      else
+      } else {
         upper_lim <- max(pretty(mydat$frq * 1.1))
+      }
     }
   }
 
   # If we want to include NA, use raw percentages as valid percentages
-  if (show.na) mydat$valid.prc <- mydat$raw.prc
+  if (show.na) {
+    mydat$valid.prc <- mydat$raw.prc
+  }
 
   # don't display value labels when we have boxplots or violin plots
-  if (type == ""boxplot"" || type == ""violin"") show.values <- FALSE
+  if (type == ""boxplot"" || type == ""violin"") {
+    show.values <- FALSE
+  }
   if (show.values) {
     # here we have counts and percentages
     if (show.prc && show.n) {
@@ -464,7 +610,7 @@ plot_frq_helper <- function(
       }
     } else if (show.n) {
       # here we have counts, without percentages
-      ggvaluelabels <-  ggplot2::geom_text(
+      ggvaluelabels <- ggplot2::geom_text(
         label = sprintf(""%i"", mydat$frq),
         hjust = hjust,
         vjust = vjust,
@@ -481,18 +627,22 @@ plot_frq_helper <- function(
         )
     } else {
       # no labels
-      ggvaluelabels <-  ggplot2::geom_text(ggplot2::aes(y = .data$frq), label = """")
+      ggvaluelabels <- ggplot2::geom_text(
+        ggplot2::aes(y = .data$frq),
+        label = """"
+      )
     }
   } else {
     # no labels
-    ggvaluelabels <-  ggplot2::geom_text(ggplot2::aes(y = .data$frq), label = """")
+    ggvaluelabels <- ggplot2::geom_text(ggplot2::aes(y = .data$frq), label = """")
   }
 
   # Set up grid breaks
-  maxx <- if (is.numeric(mydat$val))
+  maxx <- if (is.numeric(mydat$val)) {
     max(mydat$val) + 1
-  else
+  } else {
     nrow(mydat)
+  }
 
   if (is.null(grid.breaks)) {
     gridbreaks <- ggplot2::waiver()
@@ -524,7 +674,11 @@ plot_frq_helper <- function(
   if (type == ""bar"" || type == ""dot"") {
     # define geom
     if (type == ""bar"") {
-      geob <- ggplot2::geom_bar(stat = ""identity"", width = geom.size, fill = geom.colors)
+      geob <- ggplot2::geom_bar(
+        stat = ""identity"",
+        width = geom.size,
+        fill = geom.colors
+      )
     } else if (type == ""dot"") {
       geob <- ggplot2::geom_point(size = geom.size, colour = geom.colors)
     }
@@ -535,7 +689,10 @@ plot_frq_helper <- function(
     # mydat is a data frame that only contains one variable (var).
     # Must be declared as factor, so the bars are central aligned to
     # each x-axis-break.
-    baseplot <- ggplot2::ggplot(mydat, ggplot2::aes(x = .data$val, y = .data$frq)) +
+    baseplot <- ggplot2::ggplot(
+      mydat,
+      ggplot2::aes(x = .data$val, y = .data$frq)
+    ) +
       geob +
       yscale +
       # remove guide / legend
@@ -552,33 +709,40 @@ plot_frq_helper <- function(
       ebcol <- ifelse(type == ""dot"", geom.colors, errorbar.color)
       # print confidence intervalls (error bars)
       baseplot <- baseplot +
-        ggplot2::geom_errorbar(ggplot2::aes_string(ymin = ""lower.ci"", ymax = ""upper.ci""), colour = ebcol, width = 0)
+        ggplot2::geom_errorbar(
+          ggplot2::aes_string(ymin = ""lower.ci"", ymax = ""upper.ci""),
+          colour = ebcol,
+          width = 0
+        )
     }
 
     # check whether coordinates should be flipped, i.e.
     # swap x and y axis
     if (coord.flip) baseplot <- baseplot + ggplot2::coord_flip()
 
-  # Start box plot here -----
+    # Start box plot here -----
   } else if (type == ""boxplot"" || type == ""violin"") {
     # setup base plot
-    baseplot <- ggplot2::ggplot(mydat, ggplot2::aes_string(x = ""grp"", y = ""frq""))
+    baseplot <- ggplot2::ggplot(
+      mydat,
+      ggplot2::aes_string(x = ""grp"", y = ""frq"")
+    )
     # and x-axis
     scalex <- ggplot2::scale_x_discrete(labels = """")
     if (type == ""boxplot"") {
       baseplot <- baseplot +
-        geom_boxplot(width = geom.size, fill = geom.colors, notch = show.ci)
+        ggplot2::geom_boxplot(width = geom.size, fill = geom.colors, notch = show.ci)
     } else {
       baseplot <- baseplot +
-        geom_violin(trim = trimViolin, width = geom.size, fill = geom.colors)
+        ggplot2::geom_violin(trim = trimViolin, width = geom.size, fill = geom.colors)
       # if we have a violin plot, add an additional boxplot inside to show
       # more information
       if (show.ci) {
         baseplot <- baseplot +
-          geom_boxplot(width = inner.box.width, fill = ""white"", notch = TRUE)
+          ggplot2::geom_boxplot(width = inner.box.width, fill = ""white"", notch = TRUE)
       } else {
         baseplot <- baseplot +
-          geom_boxplot(width = inner.box.width, fill = ""white"")
+          ggplot2::geom_boxplot(width = inner.box.width, fill = ""white"")
       }
     }
 
@@ -587,26 +751,43 @@ plot_frq_helper <- function(
     # different fill colours, because violin boxplots have white background
     fcsp <- ifelse(type == ""boxplot"", ""white"", ""black"")
     baseplot <- baseplot +
-      stat_summary(fun = ""mean"", geom = ""point"", shape = 21,
-                   size = inner.box.dotsize, fill = fcsp)
+      ggplot2::stat_summary(
+        fun = ""mean"",
+        geom = ""point"",
+        shape = 21,
+        size = inner.box.dotsize,
+        fill = fcsp
+      )
     # no additional labels for the x- and y-axis, only diagram title
     baseplot <- baseplot + yscale + scalex
 
-  # Start density plot here -----
+    # Start density plot here -----
   } else if (type == ""density"") {
     # First, plot histogram with density curve
     baseplot <- ggplot2::ggplot(hist.dat, ggplot2::aes(x = .data$xv)) +
-      geom_histogram(ggplot2::aes(y = stat(density)), binwidth = geom.size, fill = geom.colors) +
+      ggplot2::geom_histogram(
+        ggplot2::aes(y = ggplot2::after_stat(density)),
+        binwidth = geom.size,
+        fill = geom.colors
+      ) +
       # transparent density curve above bars
-      ggplot2::geom_density(ggplot2::aes(y = stat(density)), fill = ""cornsilk"", alpha = 0.3) +
+      ggplot2::geom_density(
+        ggplot2::aes(y = ggplot2::after_stat(density)),
+        fill = ""cornsilk"",
+        alpha = 0.3
+      ) +
       # remove margins from left and right diagram side
-      ggplot2::scale_x_continuous(expand = expand.grid, breaks = histgridbreaks, limits = xlim)
+      ggplot2::scale_x_continuous(
+        expand = expand.grid,
+        breaks = histgridbreaks,
+        limits = xlim
+      )
 
     # check whether user wants to overlay the histogram
     # with a normal curve
     if (normal.curve) {
       baseplot <- baseplot +
-        stat_function(
+        ggplot2::stat_function(
           fun = dnorm,
           args = list(
             mean = mean(hist.dat$xv),
@@ -625,26 +806,37 @@ plot_frq_helper <- function(
       # original data needed for normal curve
       baseplot <- ggplot2::ggplot(mydat) +
         # second data frame mapped to the histogram geom
-        geom_histogram(data = hist.dat, ggplot2::aes(x = .data$xv), binwidth = geom.size, fill = geom.colors)
+        ggplot2::geom_histogram(
+          data = hist.dat,
+          ggplot2::aes(x = .data$xv),
+          binwidth = geom.size,
+          fill = geom.colors
+        )
     } else {
-      baseplot <- ggplot2::ggplot(mydat, ggplot2::aes(x = .data$val, y = .data$frq)) +
-        geom_area(alpha = 0.3) +
+      baseplot <- ggplot2::ggplot(
+        mydat,
+        ggplot2::aes(x = .data$val, y = .data$frq)
+      ) +
+        ggplot2::geom_area(alpha = 0.3) +
         ggplot2::geom_line(linewidth = geom.size, colour = geom.colors) +
         ggvaluelabels
     }
     # check whether user wants to overlay the histogram
     # with a normal curve
     if (normal.curve) {
       baseplot <- baseplot +
-        stat_function(
+        ggplot2::stat_function(
           fun = function(xx, mean, sd, n) {
             n * stats::dnorm(x = xx, mean = mean, sd = sd)
           },
-          args = with(mydat, c(
-            mean = mittelwert,
-            sd = stddev,
-            n = length(var.cnt)
-          )),
+          args = with(
+            mydat,
+            c(
+              mean = mittelwert,
+              sd = stddev,
+              n = length(var.cnt)
+            )
+          ),
           colour = normal.curve.color,
           size = normal.curve.size,
           alpha = normal.curve.alpha
@@ -654,7 +846,11 @@ plot_frq_helper <- function(
     if (show.mean) {
       baseplot <- baseplot +
         # vertical lines indicating the mean
-        geom_vline(xintercept = mittelwert, linetype = mean.line.type, size = mean.line.size)
+        ggplot2::geom_vline(
+          xintercept = mittelwert,
+          linetype = mean.line.type,
+          size = mean.line.size
+        )
       # check whether meanvalue should be shown.
       if (show.mean.val) {
         baseplot <- baseplot +
@@ -678,29 +874,40 @@ plot_frq_helper <- function(
       if (show.sd) {
         baseplot <- baseplot +
           # first draw shaded rectangle. these are by default in grey colour with very high transparancy
-          ggplot2::annotate(""rect"",
-                   xmin = mittelwert - stddev,
-                   xmax = mittelwert + stddev,
-                   ymin = 0,
-                   ymax = c(upper_lim),
-                   fill = ""grey70"",
-                   alpha = 0.2) +
+          ggplot2::annotate(
+            ""rect"",
+            xmin = mittelwert - stddev,
+            xmax = mittelwert + stddev,
+            ymin = 0,
+            ymax = c(upper_lim),
+            fill = ""grey70"",
+            alpha = 0.2
+          ) +
           # draw border-lines for shaded rectangle
-          geom_vline(xintercept = mittelwert - stddev,
-                     linetype = 3,
-                     size = mean.line.size,
-                     alpha = 0.7) +
-          geom_vline(xintercept = mittelwert + stddev,
-                     linetype = 3,
-                     size = mean.line.size,
-                     alpha = 0.7)
+          ggplot2::geom_vline(
+            xintercept = mittelwert - stddev,
+            linetype = 3,
+            size = mean.line.size,
+            alpha = 0.7
+          ) +
+          ggplot2::geom_vline(
+            xintercept = mittelwert + stddev,
+            linetype = 3,
+            size = mean.line.size,
+            alpha = 0.7
+          )
       }
     }
 
     # show absolute and percentage value of each bar.
-    baseplot <- baseplot + yscale +
+    baseplot <- baseplot +
+      yscale +
       # continuous x-scale for histograms
-      ggplot2::scale_x_continuous(limits = xlim, expand = expand.grid, breaks = histgridbreaks)
+      ggplot2::scale_x_continuous(
+        limits = xlim,
+        expand = expand.grid,
+        breaks = histgridbreaks
+      )
   }
 
   # set axes text and

---FILE: R/plot_grpfrq.R---
@@ -652,9 +652,9 @@ plot_grpfrq <- function(var.cnt,
     else
       geob <- ggplot2::geom_line(linewidth = geom.size)
   } else if (type == ""boxplot"") {
-      geob <- geom_boxplot(width = geom.size, notch = show.ci)
+      geob <- ggplot2::geom_boxplot(width = geom.size, notch = show.ci)
   } else if (type == ""violin"") {
-    geob <- geom_violin(trim = trimViolin, width = geom.size)
+    geob <- ggplot2::geom_violin(trim = trimViolin, width = geom.size)
   } else {
     geob <- ggplot2::geom_bar(stat = ""identity"", position = bar.pos, width = geom.size)
   }
@@ -784,10 +784,10 @@ plot_grpfrq <- function(var.cnt,
     if (type == ""violin"") {
       if (show.ci) {
         baseplot <- baseplot +
-          geom_boxplot(width = inner.box.width, fill = ""white"", outlier.colour = NA, notch = TRUE)
+          ggplot2::geom_boxplot(width = inner.box.width, fill = ""white"", outlier.colour = NA, notch = TRUE)
       } else {
         baseplot <- baseplot +
-          geom_boxplot(width = inner.box.width, fill = ""white"", outlier.colour = NA)
+          ggplot2::geom_boxplot(width = inner.box.width, fill = ""white"", outlier.colour = NA)
       }
     }
 
@@ -796,7 +796,7 @@ plot_grpfrq <- function(var.cnt,
     # different fill colours, because violin boxplots have white background
     fcsp <- ifelse(type == ""boxplot"", ""white"", ""black"")
     baseplot <- baseplot +
-      stat_summary(fun = ""mean"", geom = ""point"", shape = 21,
+      ggplot2::stat_summary(fun = ""mean"", geom = ""point"", shape = 21,
                    size = inner.box.dotsize, fill = fcsp)
   } else {
     if (type == ""dot"") {"
strengejacke,sjPlot,be155029100cdbe2c6207d311a233c19375830bc,Daniel,mail@danielluedecke.de,2025-07-01T10:51:39Z,Daniel,mail@danielluedecke.de,2025-07-01T10:51:39Z,fix,R/sjPlotCorr.R;R/sjPlotPearsonsChi2Test.R,False,True,True,False,47,28,75,"---FILE: R/sjPlotCorr.R---
@@ -217,7 +217,7 @@ sjp.corr <- function(data,
   # red, positive corr. are dark blue, and they become lighter the closer they are to a
   # correlation coefficient of zero
     ggplot2::scale_x_discrete(labels = axis.labels, breaks = seq_len(length(axis.labels))) +
-    scale_y_discrete(labels = axis.labels, breaks = seq_len(length(axis.labels))) +
+    ggplot2::scale_y_discrete(labels = axis.labels, breaks = seq_len(length(axis.labels))) +
     # set limits to (-1,1) to make sure the whole color palette is used. this
     # is the colour scale for geoms
     scale_fill_gradientn(colours = geom.colors, limits = c(-1,1)) +

---FILE: R/sjPlotPearsonsChi2Test.R---
@@ -26,13 +26,15 @@
 #' sjp.chi2(mydf, axis.labels = items)
 #'
 #' @export
-sjp.chi2 <- function(df,
-                     title = ""Pearson's Chi2-Test of Independence"",
-                     axis.labels = NULL,
-                     wrap.title = 50,
-                     wrap.labels = 20,
-                     show.legend = FALSE,
-                     legend.title = NULL) {
+sjp.chi2 <- function(
+  df,
+  title = ""Pearson's Chi2-Test of Independence"",
+  axis.labels = NULL,
+  wrap.title = 50,
+  wrap.labels = 20,
+  show.legend = FALSE,
+  legend.title = NULL
+) {
   # --------------------------------------------------------
   # try to automatically set labels is not passed as parameter
   # --------------------------------------------------------
@@ -52,19 +54,23 @@ sjp.chi2 <- function(df,
   m <- data.frame()
   for (i in seq_len(ncol(combos))) {
     test <- chisq.test(df[, combos[1, i]], df[, combos[2, i]])
-    out <- data.frame(Row = colnames(df)[combos[1, i]],
-                      Column = colnames(df)[combos[2, i]],
-                      Chi.Square = round(test$statistic, 4),
-                      df =  test$parameter,
-                      p.value = round(test$p.value, 4),
-                      stringsAsFactors = FALSE)
+    out <- data.frame(
+      Row = colnames(df)[combos[1, i]],
+      Column = colnames(df)[combos[2, i]],
+      Chi.Square = round(test$statistic, 4),
+      df = test$parameter,
+      p.value = round(test$p.value, 4),
+      stringsAsFactors = FALSE
+    )
     m <- suppressWarnings(dplyr::bind_rows(m, out))
   }
   # ----------------------------
   # check if user defined labels have been supplied
   # if not, use variable names from data frame
   # ----------------------------
-  if (is.null(axis.labels)) axis.labels <- row.names(m)
+  if (is.null(axis.labels)) {
+    axis.labels <- row.names(m)
+  }
   # --------------------------------------------------------
   # unlist labels
   # --------------------------------------------------------
@@ -75,29 +81,42 @@ sjp.chi2 <- function(df,
   # Prepare length of title and labels
   # ----------------------------
   # check length of diagram title and split longer string at into new lines
-  if (!is.null(title)) title <- sjmisc::word_wrap(title, wrap.title)
+  if (!is.null(title)) {
+    title <- sjmisc::word_wrap(title, wrap.title)
+  }
   # check length of x-axis-labels and split longer strings at into new lines
-  if (!is.null(axis.labels)) axis.labels <- sjmisc::word_wrap(axis.labels, wrap.labels)
+  if (!is.null(axis.labels)) {
+    axis.labels <- sjmisc::word_wrap(axis.labels, wrap.labels)
+  }
   # --------------------------------------------------------
   # start with base plot object here
   # --------------------------------------------------------
-  chiPlot <- ggplot2::ggplot(data = m, ggplot2::aes_string(x = ""Row"", y = ""Column"", fill = ""p.value"", label = ""p.value"")) +
+  chiPlot <- ggplot2::ggplot(
+    data = m,
+    ggplot2::aes_string(
+      x = ""Row"",
+      y = ""Column"",
+      fill = ""p.value"",
+      label = ""p.value""
+    )
+  ) +
     geom_tile() +
     ggplot2::scale_x_discrete(labels = axis.labels) +
-    scale_y_discrete(labels = axis.labels) +
-    ggplot2::scale_fill_gradient2(low = grDevices::rgb(128, 205, 193, maxColorValue = 255),
-                         mid = ""white"",
-                         high = grDevices::rgb(5, 113, 176, maxColorValue = 255),
-                         midpoint = 0.05) +
+    ggplot2::scale_y_discrete(labels = axis.labels) +
+    ggplot2::scale_fill_gradient2(
+      low = grDevices::rgb(128, 205, 193, maxColorValue = 255),
+      mid = ""white"",
+      high = grDevices::rgb(5, 113, 176, maxColorValue = 255),
+      midpoint = 0.05
+    ) +
     ggplot2::geom_text(label = sprintf(""%.3f"", m$p.value)) +
-    ggplot2::labs(title = title,
-         x = NULL,
-         y = NULL,
-         fill = legend.title)
+    ggplot2::labs(title = title, x = NULL, y = NULL, fill = legend.title)
   # ---------------------------------------------------------
   # hide legend?
   # ---------------------------------------------------------
-  if (!show.legend) chiPlot <- chiPlot + ggplot2::guides(fill = ""none"")
+  if (!show.legend) {
+    chiPlot <- chiPlot + ggplot2::guides(fill = ""none"")
+  }
 
   chiPlot
 }"
strengejacke,sjPlot,6866a36e380322a178b6ed4222cb65191447e2c3,Daniel,mail@danielluedecke.de,2025-07-01T10:50:55Z,Daniel,mail@danielluedecke.de,2025-07-01T10:50:55Z,fix,R/tab_corr.R;R/tab_model.R,False,True,True,False,300,98,398,"---FILE: R/tab_corr.R---
@@ -89,24 +89,26 @@
 #'            CSS = list(css.valueremove = 'color:blue;'))
 #' }}
 #' @export
-tab_corr <- function(data,
-                     na.deletion = c(""listwise"", ""pairwise""),
-                     corr.method = c(""pearson"", ""spearman"", ""kendall""),
-                     title = NULL,
-                     var.labels = NULL,
-                     wrap.labels = 40,
-                     show.p = TRUE,
-                     p.numeric = FALSE,
-                     fade.ns = TRUE,
-                     val.rm = NULL,
-                     digits = 3,
-                     triangle = ""both"",
-                     string.diag = NULL,
-                     CSS = NULL,
-                     encoding = NULL,
-                     file = NULL,
-                     use.viewer = TRUE,
-                     remove.spaces = TRUE) {
+tab_corr <- function(
+  data,
+  na.deletion = c(""listwise"", ""pairwise""),
+  corr.method = c(""pearson"", ""spearman"", ""kendall""),
+  title = NULL,
+  var.labels = NULL,
+  wrap.labels = 40,
+  show.p = TRUE,
+  p.numeric = FALSE,
+  fade.ns = TRUE,
+  val.rm = NULL,
+  digits = 3,
+  triangle = ""both"",
+  string.diag = NULL,
+  CSS = NULL,
+  encoding = NULL,
+  file = NULL,
+  use.viewer = TRUE,
+  remove.spaces = TRUE
+) {
   # --------------------------------------------------------
   # check p-value-style option
   # --------------------------------------------------------
@@ -134,7 +136,9 @@ tab_corr <- function(data,
     triangle <- ""upper""
   } else if (triangle == ""l"" || triangle == ""lower"") {
     triangle <- ""lower""
-  } else triangle <- ""both""
+  } else {
+    triangle <- ""both""
+  }
   # --------------------------------------------------------
   # try to automatically set labels is not passed as argument
   # --------------------------------------------------------
@@ -144,7 +148,11 @@ tab_corr <- function(data,
   # ----------------------------
   # check for valid argument
   # ----------------------------
-  if (corr.method != ""pearson"" && corr.method != ""spearman"" && corr.method != ""kendall"") {
+  if (
+    corr.method != ""pearson"" &&
+      corr.method != ""spearman"" &&
+      corr.method != ""kendall""
+  ) {
     stop(""argument 'corr.method' must be one of: pearson, spearman or kendall"")
   }
   # ----------------------------
@@ -163,9 +171,11 @@ tab_corr <- function(data,
     } else {
       # missing deletion corresponds to
       # SPSS pairwise
-      corr <- stats::cor(data,
-                  method = corr.method,
-                  use = ""pairwise.complete.obs"")
+      corr <- stats::cor(
+        data,
+        method = corr.method,
+        use = ""pairwise.complete.obs""
+      )
     }
     #---------------------------------------
     # if we have a data frame as argument,
@@ -218,17 +228,18 @@ tab_corr <- function(data,
         round(x, digits)
       }
     }
-    cpvalues <- apply(cpvalues, c(1,2), fun.star)
+    cpvalues <- apply(cpvalues, c(1, 2), fun.star)
     if (p.numeric) {
       cpvalues <-
         apply(
           cpvalues,
-          c(1,2),
+          c(1, 2),
           function(x) {
-            if (x < 0.001)
+            if (x < 0.001) {
               x <- sprintf(""&lt;%s.001"", p_zero)
-            else
+            } else {
               x <- sub(""0"", p_zero, sprintf(""%.*f"", digits, x))
+            }
           }
         )
     }
@@ -247,7 +258,10 @@ tab_corr <- function(data,
   # -------------------------------------
   # init header
   # -------------------------------------
-  toWrite <- table.header <- sprintf(""<html>\n<head>\n<meta http-equiv=\""Content-type\"" content=\""text/html;charset=%s\"">\n"", encoding)
+  toWrite <- table.header <- sprintf(
+    ""<html>\n<head>\n<meta http-equiv=\""Content-type\"" content=\""text/html;charset=%s\"">\n"",
+    encoding
+  )
   # -------------------------------------
   # init style sheet and tags used for css-definitions
   # we can use these variables for string-replacement
@@ -273,34 +287,110 @@ tab_corr <- function(data,
   css.notsig <- ""color:#999999;""
   css.summary <- ""border-bottom:double black; border-top:1px solid black; font-style:italic; font-size:0.9em; text-align:right;""
   css.pval <- ""vertical-align:super;font-size:0.8em;""
-  if (p.numeric) css.pval <- ""font-style:italic;""
+  if (p.numeric) {
+    css.pval <- ""font-style:italic;""
+  }
   # ------------------------
   # check user defined style sheets
   # ------------------------
   if (!is.null(CSS)) {
-    if (!is.null(CSS[['css.table']])) css.table <- ifelse(substring(CSS[['css.table']], 1, 1) == '+', paste0(css.table, substring(CSS[['css.table']], 2)), CSS[['css.table']])
-    if (!is.null(CSS[['css.thead']])) css.thead <- ifelse(substring(CSS[['css.thead']], 1, 1) == '+', paste0(css.thead, substring(CSS[['css.thead']], 2)), CSS[['css.thead']])
-    if (!is.null(CSS[['css.tdata']])) css.tdata <- ifelse(substring(CSS[['css.tdata']], 1, 1) == '+', paste0(css.tdata, substring(CSS[['css.tdata']], 2)), CSS[['css.tdata']])
-    if (!is.null(CSS[['css.caption']])) css.caption <- ifelse(substring(CSS[['css.caption']], 1, 1) == '+', paste0(css.caption, substring(CSS[['css.caption']], 2)), CSS[['css.caption']])
-    if (!is.null(CSS[['css.summary']])) css.summary <- ifelse(substring(CSS[['css.summary']], 1, 1) == '+', paste0(css.summary, substring(CSS[['css.summary']], 2)), CSS[['css.summary']])
-    if (!is.null(CSS[['css.centeralign']])) css.centeralign <- ifelse(substring(CSS[['css.centeralign']], 1, 1) == '+', paste0(css.centeralign, substring(CSS[['css.centeralign']], 2)), CSS[['css.centeralign']])
-    if (!is.null(CSS[['css.firsttablecol']])) css.firsttablecol <- ifelse(substring(CSS[['css.firsttablecol']], 1, 1) == '+', paste0(css.firsttablecol, substring(CSS[['css.firsttablecol']], 2)), CSS[['css.firsttablecol']])
-    if (!is.null(CSS[['css.notsig']])) css.notsig <- ifelse(substring(CSS[['css.notsig']], 1, 1) == '+', paste0(css.notsig, substring(CSS[['css.notsig']], 2)), CSS[['css.notsig']])
-    if (!is.null(CSS[['css.pval']])) css.pval <- ifelse(substring(CSS[['css.pval']], 1, 1) == '+', paste0(css.pval, substring(CSS[['css.pval']], 2)), CSS[['css.pval']])
-    if (!is.null(CSS[['css.valueremove']])) css.valueremove <- ifelse(substring(CSS[['css.valueremove']], 1, 1) == '+', paste0(css.valueremove, substring(CSS[['css.valueremove']], 2)), CSS[['css.valueremove']])
+    if (!is.null(CSS[['css.table']])) {
+      css.table <- ifelse(
+        substring(CSS[['css.table']], 1, 1) == '+',
+        paste0(css.table, substring(CSS[['css.table']], 2)),
+        CSS[['css.table']]
+      )
+    }
+    if (!is.null(CSS[['css.thead']])) {
+      css.thead <- ifelse(
+        substring(CSS[['css.thead']], 1, 1) == '+',
+        paste0(css.thead, substring(CSS[['css.thead']], 2)),
+        CSS[['css.thead']]
+      )
+    }
+    if (!is.null(CSS[['css.tdata']])) {
+      css.tdata <- ifelse(
+        substring(CSS[['css.tdata']], 1, 1) == '+',
+        paste0(css.tdata, substring(CSS[['css.tdata']], 2)),
+        CSS[['css.tdata']]
+      )
+    }
+    if (!is.null(CSS[['css.caption']])) {
+      css.caption <- ifelse(
+        substring(CSS[['css.caption']], 1, 1) == '+',
+        paste0(css.caption, substring(CSS[['css.caption']], 2)),
+        CSS[['css.caption']]
+      )
+    }
+    if (!is.null(CSS[['css.summary']])) {
+      css.summary <- ifelse(
+        substring(CSS[['css.summary']], 1, 1) == '+',
+        paste0(css.summary, substring(CSS[['css.summary']], 2)),
+        CSS[['css.summary']]
+      )
+    }
+    if (!is.null(CSS[['css.centeralign']])) {
+      css.centeralign <- ifelse(
+        substring(CSS[['css.centeralign']], 1, 1) == '+',
+        paste0(css.centeralign, substring(CSS[['css.centeralign']], 2)),
+        CSS[['css.centeralign']]
+      )
+    }
+    if (!is.null(CSS[['css.firsttablecol']])) {
+      css.firsttablecol <- ifelse(
+        substring(CSS[['css.firsttablecol']], 1, 1) == '+',
+        paste0(css.firsttablecol, substring(CSS[['css.firsttablecol']], 2)),
+        CSS[['css.firsttablecol']]
+      )
+    }
+    if (!is.null(CSS[['css.notsig']])) {
+      css.notsig <- ifelse(
+        substring(CSS[['css.notsig']], 1, 1) == '+',
+        paste0(css.notsig, substring(CSS[['css.notsig']], 2)),
+        CSS[['css.notsig']]
+      )
+    }
+    if (!is.null(CSS[['css.pval']])) {
+      css.pval <- ifelse(
+        substring(CSS[['css.pval']], 1, 1) == '+',
+        paste0(css.pval, substring(CSS[['css.pval']], 2)),
+        CSS[['css.pval']]
+      )
+    }
+    if (!is.null(CSS[['css.valueremove']])) {
+      css.valueremove <- ifelse(
+        substring(CSS[['css.valueremove']], 1, 1) == '+',
+        paste0(css.valueremove, substring(CSS[['css.valueremove']], 2)),
+        CSS[['css.valueremove']]
+      )
+    }
   }
   # ------------------------
   # set page style
   # ------------------------
-  page.style <-  sprintf(""<style>\nhtml, body { background-color: white; }\n%s { %s }\n%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n</style>"",
-                         tag.table, css.table, tag.caption, css.caption,
-                         tag.thead, css.thead, tag.tdata, css.tdata,
-                         tag.firsttablecol, css.firsttablecol,
-                         tag.centeralign, css.centeralign,
-                         tag.notsig, css.notsig,
-                         tag.pval, css.pval,
-                         tag.summary, css.summary,
-                         tag.valueremove, css.valueremove)
+  page.style <- sprintf(
+    ""<style>\nhtml, body { background-color: white; }\n%s { %s }\n%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n</style>"",
+    tag.table,
+    css.table,
+    tag.caption,
+    css.caption,
+    tag.thead,
+    css.thead,
+    tag.tdata,
+    css.tdata,
+    tag.firsttablecol,
+    css.firsttablecol,
+    tag.centeralign,
+    css.centeralign,
+    tag.notsig,
+    css.notsig,
+    tag.pval,
+    css.pval,
+    tag.summary,
+    css.summary,
+    tag.valueremove,
+    css.valueremove
+  )
   # ------------------------
   # start content
   # ------------------------
@@ -313,7 +403,12 @@ tab_corr <- function(data,
   # -------------------------------------
   # table caption, variable label
   # -------------------------------------
-  if (!is.null(title)) page.content <- paste0(page.content, sprintf(""  <caption>%s</caption>\n"", title))
+  if (!is.null(title)) {
+    page.content <- paste0(
+      page.content,
+      sprintf(""  <caption>%s</caption>\n"", title)
+    )
+  }
   # -------------------------------------
   # header row
   # -------------------------------------
@@ -323,7 +418,10 @@ tab_corr <- function(data,
   page.content <- paste0(page.content, ""    <th class=\""thead\"">&nbsp;</th>\n"")
   # iterate columns
   for (i in 1:ncol(corr)) {
-    page.content <- paste0(page.content, sprintf(""    <th class=\""thead\"">%s</th>\n"", var.labels[i]))
+    page.content <- paste0(
+      page.content,
+      sprintf(""    <th class=\""thead\"">%s</th>\n"", var.labels[i])
+    )
   }
   # close table row
   page.content <- paste0(page.content, ""  </tr>\n"")
@@ -335,7 +433,10 @@ tab_corr <- function(data,
     # write tr-tag
     page.content <- paste0(page.content, ""  <tr>\n"")
     # print first table cell
-    page.content <- paste0(page.content, sprintf(""    <td class=\""firsttablecol\"">%s</td>\n"", var.labels[i]))
+    page.content <- paste0(
+      page.content,
+      sprintf(""    <td class=\""firsttablecol\"">%s</td>\n"", var.labels[i])
+    )
     # --------------------------------------------------------
     # iterate all columns
     # --------------------------------------------------------
@@ -345,17 +446,29 @@ tab_corr <- function(data,
       # --------------------------------------------------------
       if (j == i) {
         if (is.null(string.diag) || length(string.diag) > ncol(corr)) {
-          page.content <- paste0(page.content, ""    <td class=\""tdata centeralign\"">&nbsp;</td>\n"")
+          page.content <- paste0(
+            page.content,
+            ""    <td class=\""tdata centeralign\"">&nbsp;</td>\n""
+          )
         } else {
-          page.content <- paste0(page.content, sprintf(""    <td class=\""tdata centeralign\"">%s</td>\n"",
-                                                       string.diag[j]))
+          page.content <- paste0(
+            page.content,
+            sprintf(
+              ""    <td class=\""tdata centeralign\"">%s</td>\n"",
+              string.diag[j]
+            )
+          )
         }
       } else {
         # --------------------------------------------------------
         # check whether only lower or upper triangle of correlation
         # table should be printed
         # --------------------------------------------------------
-        if ((triangle == ""upper"" && j > i) || (triangle == ""lower"" && i > j) || triangle == ""both"") {
+        if (
+          (triangle == ""upper"" && j > i) ||
+            (triangle == ""lower"" && i > j) ||
+            triangle == ""both""
+        ) {
           # --------------------------------------------------------
           # print table-cell-data (cor-value)
           # --------------------------------------------------------
@@ -368,12 +481,20 @@ tab_corr <- function(data,
               # --------------------------------------------------------
               # if we have p-values as number, print them in new row
               # --------------------------------------------------------
-              cellval <- sprintf(""%s<br><span class=\""pval\"">(%s)</span>"", cellval, cpvalues[i, j])
+              cellval <- sprintf(
+                ""%s<br><span class=\""pval\"">(%s)</span>"",
+                cellval,
+                cpvalues[i, j]
+              )
             } else {
               # --------------------------------------------------------
               # if we have p-values as ""*"", add them
               # --------------------------------------------------------
-              cellval <- sprintf(""%s<span class=\""pval\"">%s</span>"", cellval, cpvalues[i, j])
+              cellval <- sprintf(
+                ""%s<span class=\""pval\"">%s</span>"",
+                cellval,
+                cpvalues[i, j]
+              )
             }
           }
           # --------------------------------------------------------
@@ -399,12 +520,20 @@ tab_corr <- function(data,
           if (!is.null(val.rm) && abs(corr[i, j]) < abs(val.rm)) {
             value.remove <- "" valueremove""
           }
-          page.content <- paste0(page.content, sprintf(""    <td class=\""tdata centeralign%s%s\"">%s</td>\n"",
-                                                       notsig,
-                                                       value.remove,
-                                                       cellval))
+          page.content <- paste0(
+            page.content,
+            sprintf(
+              ""    <td class=\""tdata centeralign%s%s\"">%s</td>\n"",
+              notsig,
+              value.remove,
+              cellval
+            )
+          )
         } else {
-          page.content <- paste0(page.content, ""    <td class=\""tdata centeralign\"">&nbsp;</td>\n"")
+          page.content <- paste0(
+            page.content,
+            ""    <td class=\""tdata centeralign\"">&nbsp;</td>\n""
+          )
         }
       }
     }
@@ -415,8 +544,18 @@ tab_corr <- function(data,
   # feedback...
   # -------------------------------------
   page.content <- paste0(page.content, ""  <tr>\n"")
-  page.content <- paste0(page.content, sprintf(""    <td colspan=\""%i\"" class=\""summary\"">"", ncol(corr) + 1))
-  page.content <- paste0(page.content, sprintf(""Computed correlation used %s-method with %s-deletion."", corr.method, na.deletion))
+  page.content <- paste0(
+    page.content,
+    sprintf(""    <td colspan=\""%i\"" class=\""summary\"">"", ncol(corr) + 1)
+  )
+  page.content <- paste0(
+    page.content,
+    sprintf(
+      ""Computed correlation used %s-method with %s-deletion."",
+      corr.method,
+      na.deletion
+    )
+  )
   page.content <- paste0(page.content, ""</td>\n  </tr>\n"")
   # -------------------------------------
   # finish table
@@ -438,19 +577,49 @@ tab_corr <- function(data,
   # set style attributes for main table tags
   # -------------------------------------
   knitr <- gsub(""class="", ""style="", knitr, fixed = TRUE, useBytes = TRUE)
-  knitr <- gsub(""<table"", sprintf(""<table style=\""%s\"""", css.table), knitr, fixed = TRUE, useBytes = TRUE)
-  knitr <- gsub(""<caption"", sprintf(""<caption style=\""%s\"""", css.caption), knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(
+    ""<table"",
+    sprintf(""<table style=\""%s\"""", css.table),
+    knitr,
+    fixed = TRUE,
+    useBytes = TRUE
+  )
+  knitr <- gsub(
+    ""<caption"",
+    sprintf(""<caption style=\""%s\"""", css.caption),
+    knitr,
+    fixed = TRUE,
+    useBytes = TRUE
+  )
   # -------------------------------------
   # replace class-attributes with inline-style-definitions
   # -------------------------------------
   knitr <- gsub(tag.tdata, css.tdata, knitr, fixed = TRUE, useBytes = TRUE)
   knitr <- gsub(tag.thead, css.thead, knitr, fixed = TRUE, useBytes = TRUE)
-  knitr <- gsub(tag.centeralign, css.centeralign, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(
+    tag.centeralign,
+    css.centeralign,
+    knitr,
+    fixed = TRUE,
+    useBytes = TRUE
+  )
   knitr <- gsub(tag.notsig, css.notsig, knitr, fixed = TRUE, useBytes = TRUE)
   knitr <- gsub(tag.pval, css.pval, knitr, fixed = TRUE, useBytes = TRUE)
   knitr <- gsub(tag.summary, css.summary, knitr, fixed = TRUE, useBytes = TRUE)
-  knitr <- gsub(tag.firsttablecol, css.firsttablecol, knitr, fixed = TRUE, useBytes = TRUE)
-  knitr <- gsub(tag.valueremove, css.valueremove, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(
+    tag.firsttablecol,
+    css.firsttablecol,
+    knitr,
+    fixed = TRUE,
+    useBytes = TRUE
+  )
+  knitr <- gsub(
+    tag.valueremove,
+    css.valueremove,
+    knitr,
+    fixed = TRUE,
+    useBytes = TRUE
+  )
   # -------------------------------------
   # remove spaces?
   # -------------------------------------

---FILE: R/tab_model.R---
@@ -1304,18 +1304,20 @@ sort_columns <- function(x, is.stan, col.order) {
 }
 
 
-remove_unwanted <- function(dat,
-                            show.intercept,
-                            show.est,
-                            show.std,
-                            show.ci,
-                            show.se,
-                            show.stat,
-                            show.p,
-                            show.df,
-                            show.response,
-                            terms,
-                            rm.terms) {
+remove_unwanted <- function(
+  dat,
+  show.intercept,
+  show.est,
+  show.std,
+  show.ci,
+  show.se,
+  show.stat,
+  show.p,
+  show.df,
+  show.response,
+  terms,
+  rm.terms
+) {
   if (!show.intercept) {
     ints1 <- string_contains(""(Intercept"", x = dat$term)
     ints2 <- string_contains(""b_Intercept"", x = dat$term)
@@ -1324,8 +1326,9 @@ remove_unwanted <- function(dat,
 
     ints <- c(ints1, ints2, ints3, ints4)
 
-    if (!sjmisc::is_empty(ints))
-      dat <- dplyr::slice(dat, !! -ints)
+    if (!sjmisc::is_empty(ints)) {
+      dat <- dplyr::slice(dat, !!-ints)
+    }
   }
 
   if (show.est == FALSE) {
@@ -1338,7 +1341,10 @@ remove_unwanted <- function(dat,
   }
 
   if (is.null(show.std) || show.std == FALSE) {
-    dat <- dplyr::select(dat, -string_starts_with(""std.estimate"", x = colnames(dat)))
+    dat <- dplyr::select(
+      dat,
+      -string_starts_with(""std.estimate"", x = colnames(dat))
+    )
   }
 
   if (is.null(show.ci) || show.ci == FALSE) {
@@ -1359,17 +1365,26 @@ remove_unwanted <- function(dat,
   }
 
   if (show.stat == FALSE) {
-    dat <- dplyr::select(dat, -string_starts_with(""statistic"", x = colnames(dat)),
-                         -string_starts_with(""std.statistic"", x = colnames(dat)))
+    dat <- dplyr::select(
+      dat,
+      -string_starts_with(""statistic"", x = colnames(dat)),
+      -string_starts_with(""std.statistic"", x = colnames(dat))
+    )
   }
 
   if (show.response == FALSE) {
-    dat <- dplyr::select(dat, -string_starts_with(""response.level"", x = colnames(dat)))
+    dat <- dplyr::select(
+      dat,
+      -string_starts_with(""response.level"", x = colnames(dat))
+    )
   }
 
   if (show.p == FALSE) {
-    dat <- dplyr::select(dat, -string_starts_with(""p.value"", x = colnames(dat)),
-                         -string_starts_with(""std.p.value"", x = colnames(dat)))
+    dat <- dplyr::select(
+      dat,
+      -string_starts_with(""p.value"", x = colnames(dat)),
+      -string_starts_with(""std.p.value"", x = colnames(dat))
+    )
   }
 
   if (show.df == FALSE) {
@@ -1379,13 +1394,13 @@ remove_unwanted <- function(dat,
   if (!is.null(terms)) {
     terms <- parse_terms(terms)
     keep_terms <- which(dat$term %in% terms)
-    dat <- dplyr::slice(dat, !! keep_terms)
+    dat <- dplyr::slice(dat, !!keep_terms)
   }
 
   if (!is.null(rm.terms)) {
     rm.terms <- parse_terms(rm.terms)
     keep_terms <- which(!(dat$term %in% rm.terms))
-    dat <- dplyr::slice(dat, !! keep_terms)
+    dat <- dplyr::slice(dat, !!keep_terms)
   }
 
   dat
@@ -1430,9 +1445,9 @@ format_p_values <- function(dat, p.style, digits.p, emph.p, p.threshold) {
 
   dat <- dat |>
     dplyr::mutate(
-    p.stars = get_p_stars(.data$p.value, p.threshold),
-    p.sig = .data$p.value < .05
-  )
+      p.stars = get_p_stars(.data$p.value, p.threshold),
+      p.sig = .data$p.value < .05
+    )
 
   # scientific notation ----
 
@@ -1444,15 +1459,33 @@ format_p_values <- function(dat, p.style, digits.p, emph.p, p.threshold) {
 
   # emphasize p-values ----
 
-  if (emph.p && !all(dat$p.value == ""NA"")) dat$p.value[which(dat$p.sig)] <- sprintf(""<strong>%s</strong>"", dat$p.value[which(dat$p.sig)])
+  if (emph.p && !all(dat$p.value == ""NA"")) {
+    dat$p.value[which(dat$p.sig)] <- sprintf(
+      ""<strong>%s</strong>"",
+      dat$p.value[which(dat$p.sig)]
+    )
+  }
   dat <- dplyr::select(dat, -.data$p.sig)
 
   # indicate p <0.001 ----
 
   pv <- paste0(""0."", paste(rep(""0"", digits.p), collapse = """"))
-  dat$p.value[dat$p.value == pv] <- paste(""&lt;"", format(10^(-digits.p), scientific = FALSE), sep = """")
+  dat$p.value[dat$p.value == pv] <- paste(
+    ""&lt;"",
+    format(10^(-digits.p), scientific = FALSE),
+    sep = """"
+  )
 
-  pv <- paste0(""<strong>0."", paste(rep(""0"", digits.p), collapse = """"), ""</strong>"")
-  dat$p.value[dat$p.value == pv] <- paste(""<strong>&lt;"", format(10^(-digits.p), scientific = FALSE), ""</strong>"", sep = """")
+  pv <- paste0(
+    ""<strong>0."",
+    paste(rep(""0"", digits.p), collapse = """"),
+    ""</strong>""
+  )
+  dat$p.value[dat$p.value == pv] <- paste(
+    ""<strong>&lt;"",
+    format(10^(-digits.p), scientific = FALSE),
+    ""</strong>"",
+    sep = """"
+  )
   dat
 }"
strengejacke,sjPlot,41fb825f249d500ef014c09a8291aa60c955f995,Daniel,mail@danielluedecke.de,2025-07-01T10:50:07Z,Daniel,mail@danielluedecke.de,2025-07-01T10:50:07Z,fix,R/plot_frq.R;R/plot_grpfrq.R;R/plot_xtab.R;R/sjPlotDist.R;R/sjPlotPolynomials.R,False,True,True,False,86,46,132,"---FILE: R/plot_frq.R---
@@ -629,7 +629,7 @@ plot_frq_helper <- function(
     } else {
       baseplot <- ggplot2::ggplot(mydat, ggplot2::aes(x = .data$val, y = .data$frq)) +
         geom_area(alpha = 0.3) +
-        geom_line(linewidth = geom.size, colour = geom.colors) +
+        ggplot2::geom_line(linewidth = geom.size, colour = geom.colors) +
         ggvaluelabels
     }
     # check whether user wants to overlay the histogram

---FILE: R/plot_grpfrq.R---
@@ -648,9 +648,9 @@ plot_grpfrq <- function(var.cnt,
       geob <- ggplot2::geom_bar(stat = ""identity"", width = geom.size, position = ggplot2::position_stack(reverse = TRUE))
   } else if (type == ""line"") {
     if (smooth.lines)
-      geob <- geom_line(linewidth = geom.size, stat = ""smooth"", method = ""loess"")
+      geob <- ggplot2::geom_line(linewidth = geom.size, stat = ""smooth"", method = ""loess"")
     else
-      geob <- geom_line(linewidth = geom.size)
+      geob <- ggplot2::geom_line(linewidth = geom.size)
   } else if (type == ""boxplot"") {
       geob <- geom_boxplot(width = geom.size, notch = show.ci)
   } else if (type == ""violin"") {

---FILE: R/plot_xtab.R---
@@ -418,7 +418,7 @@ plot_xtab <- function(x,
     # for lines, numeric scale
     mydf$xpos <- sjlabelled::as_numeric(mydf$xpos, keep.labels = FALSE)
     line.stat <- ifelse(isTRUE(smooth.lines), ""smooth"", ""identity"")
-    geob <- geom_line(ggplot2::aes_string(colour = ""group""), linewidth = geom.size, stat = line.stat)
+    geob <- ggplot2::geom_line(ggplot2::aes_string(colour = ""group""), linewidth = geom.size, stat = line.stat)
   }
   # --------------------------------------------------------
   # start plot here

---FILE: R/sjPlotDist.R---
@@ -74,7 +74,7 @@ dist_norm <- function(norm = NULL,
   # density normal distribution
   mydat$y <- stats::dnorm(mydat$x, mean, sd)
   # base plot with normal-distribution
-  gp <- ggplot2::ggplot(mydat, ggplot2::aes_string(x = ""x"", y = ""y"")) + geom_line()
+  gp <- ggplot2::ggplot(mydat, ggplot2::aes_string(x = ""x"", y = ""y"")) + ggplot2::geom_line()
   sub.df <- NULL
   if (!is.null(p)) {
     # plot area for indicated x-value...
@@ -210,7 +210,7 @@ dist_chisq <- function(chi2 = NULL,
   # density distribution of chi2
   mydat$y <- stats::dchisq(mydat$x, deg.f)
   # base plot with chi2-distribution
-  gp <- ggplot2::ggplot(mydat, ggplot2::aes_string(x = ""x"", y = ""y"")) + geom_line()
+  gp <- ggplot2::ggplot(mydat, ggplot2::aes_string(x = ""x"", y = ""y"")) + ggplot2::geom_line()
   sub.df <- NULL
   if (!is.null(p)) {
     # plot area for indicated chi2-value...
@@ -338,7 +338,7 @@ dist_f <- function(f = NULL,
   # density distribution of f
   mydat$y <- stats::df(mydat$x, deg.f1, deg.f2)
   # base plot with f-distribution
-  gp <- ggplot2::ggplot(mydat, ggplot2::aes_string(x = ""x"", y = ""y"")) + geom_line()
+  gp <- ggplot2::ggplot(mydat, ggplot2::aes_string(x = ""x"", y = ""y"")) + ggplot2::geom_line()
   sub.df <- NULL
   if (!is.null(p)) {
     # plot area for indicated f-value...
@@ -467,7 +467,7 @@ dist_t <- function(t = NULL,
   # density distribution of t
   mydat$y <- stats::dt(mydat$x, deg.f)
   # base plot with t-distribution
-  gp <- ggplot2::ggplot(mydat, ggplot2::aes_string(x = ""x"", y = ""y"")) + geom_line()
+  gp <- ggplot2::ggplot(mydat, ggplot2::aes_string(x = ""x"", y = ""y"")) + ggplot2::geom_line()
   sub.df <- NULL
   if (!is.null(p)) {
     # plot area for indicated t-value...

---FILE: R/sjPlotPolynomials.R---
@@ -92,32 +92,35 @@
 #' plot_model(fit, type = ""pred"", terms = ""e17age"")}
 #'
 #' @export
-sjp.poly <- function(x,
-                     poly.term,
-                     poly.degree,
-                     poly.scale = FALSE,
-                     fun = NULL,
-                     axis.title = NULL,
-                     geom.colors = NULL,
-                     geom.size = .8,
-                     show.loess = TRUE,
-                     show.loess.ci = TRUE,
-                     show.p = TRUE,
-                     show.scatter = TRUE,
-                     point.alpha = .2,
-                     point.color = ""#404040"",
-                     loess.color = ""#808080"") {
+sjp.poly <- function(
+  x,
+  poly.term,
+  poly.degree,
+  poly.scale = FALSE,
+  fun = NULL,
+  axis.title = NULL,
+  geom.colors = NULL,
+  geom.size = .8,
+  show.loess = TRUE,
+  show.loess.ci = TRUE,
+  show.p = TRUE,
+  show.scatter = TRUE,
+  point.alpha = .2,
+  point.color = ""#404040"",
+  loess.color = ""#808080""
+) {
   # --------------------------------------------
   # check color parameter
   # --------------------------------------------
   geom.colors <- col_check2(geom.colors, length(poly.degree))
   # --------------------------------------------
   # check poly.term parameter
   # --------------------------------------------
-  if (is.character(poly.term))
+  if (is.character(poly.term)) {
     defv <- poly.term
-  else
+  } else {
     defv <- get_var_name(deparse(substitute(poly.term)))
+  }
   # --------------------------------------------
   # parameter check: fitted model or variables?
   # --------------------------------------------
@@ -144,14 +147,18 @@ sjp.poly <- function(x,
   # --------------------------------------------
   # retrieve labels
   # --------------------------------------------
-  if (is.null(axis.title)) axis.title <- sjlabelled::get_label(poly.term, def.value = defv)
+  if (is.null(axis.title)) {
+    axis.title <- sjlabelled::get_label(poly.term, def.value = defv)
+  }
   axisTitle.y <- sjlabelled::get_label(resp, def.value = ""Response"")
   # --------------------------------------------
   # init data frame
   # --------------------------------------------
   plot.df <- data.frame()
   # scale polynomial term?
-  if (poly.scale) poly.term <- scale(poly.term)
+  if (poly.scale) {
+    poly.term <- scale(poly.term)
+  }
   # --------------------------------------------
   # get cutpoints for loess curve
   # --------------------------------------------
@@ -164,49 +171,82 @@ sjp.poly <- function(x,
     # poly-function can't cope with missings, so remove them here
     mydat <- stats::na.omit(data.frame(x = poly.term, y = resp))
     # fit model with polynomials
-    if (fun == ""lm"")
+    if (fun == ""lm"") {
       fit <- stats::lm(mydat$y ~ stats::poly(mydat$x, i, raw = TRUE))
-    else
-      fit <- stats::glm(mydat$y ~ stats::poly(mydat$x, i, raw = TRUE), family = stats::family(x))
+    } else {
+      fit <- stats::glm(
+        mydat$y ~ stats::poly(mydat$x, i, raw = TRUE),
+        family = stats::family(x)
+      )
+    }
     # check whether we have an integer poly.degree
     # or a float value
     poly.digit <- ifelse(i %% 1 == 0, 0, 1)
     # create data frame with raw data and the fitted poly-curve
-    plot.df <- rbind(plot.df, cbind(mydat,
-                                    stats::predict(fit),
-                                    sprintf(""x^%.*f"", poly.digit, i)))
+    plot.df <- rbind(
+      plot.df,
+      cbind(mydat, stats::predict(fit), sprintf(""x^%.*f"", poly.digit, i))
+    )
     # print p-values?
     if (show.p) {
       # get p-values
       pvals <- summary(fit)$coefficients[-1, 4]
       # prepare output string
-      p.out <- sprintf(""Polynomial degrees: %.*f\n---------------------\n"", poly.digit, i)
+      p.out <- sprintf(
+        ""Polynomial degrees: %.*f\n---------------------\n"",
+        poly.digit,
+        i
+      )
       # iterate polynomial terms and print p-value for each polynom
-      for (j in seq_len(i)) p.out <- paste0(p.out, sprintf(""p(x^%i): %.3f\n"", j, unname(pvals[j])))
+      for (j in seq_len(i)) {
+        p.out <- paste0(p.out, sprintf(""p(x^%i): %.3f\n"", j, unname(pvals[j])))
+      }
       # add separator line after each model
       p.out <- paste0(p.out, ""\n"")
       # print p-values for fitted model
       cat(p.out)
     }
   }
+
   # name df
-  colnames(plot.df) <- c(""x"",""y"", ""pred"", ""grp"")
+  colnames(plot.df) <- c(""x"", ""y"", ""pred"", ""grp"")
   # create plot
-  polyplot <- ggplot2::ggplot(plot.df, ggplot2::aes_string(x = ""x"", y = ""y"", colour = ""grp""))
+  polyplot <- ggplot2::ggplot(
+    plot.df,
+    ggplot2::aes_string(x = ""x"", y = ""y"", colour = ""grp"")
+  )
   # show scatter plot as well?
-  if (show.scatter) polyplot <- polyplot +
-    ggplot2::geom_jitter(colour = point.color, alpha = point.alpha, shape = 16)
+  if (show.scatter) {
+    polyplot <- polyplot +
+      ggplot2::geom_jitter(
+        colour = point.color,
+        alpha = point.alpha,
+        shape = 16
+      )
+  }
   # show loess curve? this curve indicates the ""perfect"" curve through
   # the data
-  if (show.loess) polyplot <- polyplot + ggplot2::stat_smooth(method = ""loess"",
-                                                    color = loess.color,
-                                                    se = show.loess.ci,
-                                                    size = geom.size)
+  if (show.loess) {
+    polyplot <- polyplot +
+      ggplot2::stat_smooth(
+        method = ""loess"",
+        color = loess.color,
+        se = show.loess.ci,
+        size = geom.size
+      )
+  }
   # add curves for polynomials
   polyplot <- polyplot +
-    geom_line(ggplot2::aes_string(y = ""pred""), linewidth = geom.size) +
-    scale_color_manual(values = geom.colors, labels = lapply(poly.degree, function(j) bquote(x^.(j)))) +
-    ggplot2::labs(x = axis.title, y = axisTitle.y, colour = ""Polynomial\ndegrees"")
+    ggplot2::geom_line(ggplot2::aes_string(y = ""pred""), linewidth = geom.size) +
+    ggplot2::scale_color_manual(
+      values = geom.colors,
+      labels = lapply(poly.degree, function(j) bquote(x^.(j)))
+    ) +
+    ggplot2::labs(
+      x = axis.title,
+      y = axisTitle.y,
+      colour = ""Polynomial\ndegrees""
+    )
 
   polyplot
 }"
strengejacke,sjPlot,be455d8f6f7b57e29bb5ab5f60389aa334395c5b,Daniel,mail@danielluedecke.de,2025-07-01T10:48:59Z,Daniel,mail@danielluedecke.de,2025-07-01T10:48:59Z,fix,R/plot_grid.R;R/plot_grpfrq.R;R/plot_xtab.R;R/save_plot.R;R/sjPlotSetTheme.R;R/sjplot_themes.R;man/plot_xtab.Rd;vignettes/custplot.Rmd,True,True,True,False,174,88,262,"---FILE: R/plot_grid.R---
@@ -58,7 +58,7 @@ plot_grid <- function(x, margin = c(1, 1, 1, 1), tags = NULL) {
 
   # add margin to each plot, so no axis labels are cropped
   x <- lapply(x, function(pl) {
-    pl + ggplot2::theme(plot.margin = unit(margin, ""cm""))
+    pl + ggplot2::theme(plot.margin = ggplot2::unit(margin, ""cm""))
   })
 
   tags_labels <- NULL

---FILE: R/plot_grpfrq.R---
@@ -868,7 +868,7 @@ plot_grpfrq <- function(var.cnt,
   if (facet.grid) {
     baseplot <- baseplot +
       # set font size for axes.
-      # ggplot2::theme(strip.text = element_text(face = ""bold"", size = rel(1.1))) +
+      # ggplot2::theme(strip.text = ggplot2::element_text(face = ""bold"", size = rel(1.1))) +
       ggplot2::facet_wrap(~group, scales = ""free"")
   }
 

---FILE: R/plot_xtab.R---
@@ -46,7 +46,7 @@
 #' library(sjmisc)
 #' library(sjlabelled)
 #' data(efc)
-#' set_ggplot2::theme(geom.label.angle = 90)
+#' sjPlot::set_theme(geom.label.angle = 90)
 #' plot_xtab(efc$e42dep, efc$e16sex, vjust = ""center"", hjust = ""bottom"")
 #'
 #' # grouped bars with EUROFAMCARE sample dataset

---FILE: R/save_plot.R---
@@ -52,7 +52,7 @@ save_plot <- function(filename,
   # set printable theme, adjust font sizes.
   # this is the most critical point...
 
-  set_ggplot2::theme(
+  sjPlot::set_theme(
     base = theme,
     geom.label.color = label.color,
     axis.title.color = label.color,

---FILE: R/sjPlotSetTheme.R---
@@ -247,10 +247,11 @@ set_theme <- function(base = theme_grey(),
   if (!is.null(axis.textcolor)) {
     axis.textcolor.x <- axis.textcolor.y <- axis.textcolor
   } else {
-    if (is.null(axis.textcolor.x))
+    if (is.null(axis.textcolor.x)) {
       axis.textcolor <- axis.textcolor.y
-    else
+    } else {
       axis.textcolor <- axis.textcolor.x
+    }
   }
   # ----------------------------------------
   # set defaults for axis line color
@@ -336,102 +337,168 @@ set_theme <- function(base = theme_grey(),
   # ----------------------------------------
   # check if theme-preset is requested
   # ----------------------------------------
-  if (!is.null(theme) && any(class(theme) == ""theme"") && any(class(theme) == ""gg"")) {
+  if (
+    !is.null(theme) && any(class(theme) == ""theme"") && any(class(theme) == ""gg"")
+  ) {
     theme_set(theme)
-  }
-  # ----------------------------------------
-  # else, customize theme
-  # ----------------------------------------
-  else if (!is.null(base) && any(class(base) == ""theme"") && any(class(base) == ""gg"")) {
+  } else if (
+    !is.null(base) && any(class(base) == ""theme"") && any(class(base) == ""gg"")
+  ) {
+    # ----------------------------------------
+    # else, customize theme
+    # ----------------------------------------
     sjtheme <- base +
       # ----------------------------------------
       # set base elements that are always set
       # ----------------------------------------
-      ggplot2::theme(plot.title = element_text(size = rel(title.size),  colour = title.color, hjust = title.align),
-            axis.text = element_text(angle = axis.angle, size = rel(axis.textsize), colour = axis.textcolor),
-            axis.text.x = element_text(angle = axis.angle.x, size = rel(axis.textsize.x), colour = axis.textcolor.x),
-            axis.text.y = element_text(angle = axis.angle.y, size = rel(axis.textsize.y), colour = axis.textcolor.y),
-            axis.title = element_text(size = rel(axis.title.size), colour = axis.title.color),
-            legend.position = legend.pos,
-            legend.justification = legend.just,
-            legend.text = element_text(size = rel(legend.size), colour = legend.color),
-            legend.title = element_text(size = rel(legend.title.size), colour = legend.title.color, face = legend.title.face),
-            legend.background = element_rect(colour = legend.bordercol, fill = legend.backgroundcol))
+      ggplot2::theme(
+        plot.title = ggplot2::element_text(
+          size = rel(title.size),
+          colour = title.color,
+          hjust = title.align
+        ),
+        axis.text = ggplot2::element_text(
+          angle = axis.angle,
+          size = rel(axis.textsize),
+          colour = axis.textcolor
+        ),
+        axis.text.x = ggplot2::element_text(
+          angle = axis.angle.x,
+          size = rel(axis.textsize.x),
+          colour = axis.textcolor.x
+        ),
+        axis.text.y = ggplot2::element_text(
+          angle = axis.angle.y,
+          size = rel(axis.textsize.y),
+          colour = axis.textcolor.y
+        ),
+        axis.title = ggplot2::element_text(
+          size = rel(axis.title.size),
+          colour = axis.title.color
+        ),
+        legend.position = legend.pos,
+        legend.justification = legend.just,
+        legend.text = ggplot2::element_text(
+          size = rel(legend.size),
+          colour = legend.color
+        ),
+        legend.title = ggplot2::element_text(
+          size = rel(legend.title.size),
+          colour = legend.title.color,
+          face = legend.title.face
+        ),
+        legend.background = ggplot2::element_rect(
+          colour = legend.bordercol,
+          fill = legend.backgroundcol
+        )
+      )
     # ----------------------------------------
     # set base font for theme
     # ----------------------------------------
     if (!is.null(theme.font)) {
       sjtheme <- sjtheme +
-        ggplot2::theme(text = element_text(family = theme.font))
+        ggplot2::theme(text = ggplot2::element_text(family = theme.font))
     }
     # ----------------------------------------
     # set legend items background-color
     # ----------------------------------------
     if (!is.null(legend.item.backcol)) {
       sjtheme <- sjtheme +
-        ggplot2::theme(legend.key = element_rect(colour = legend.item.bordercol, fill = legend.item.backcol))
+        ggplot2::theme(
+          legend.key = ggplot2::element_rect(
+            colour = legend.item.bordercol,
+            fill = legend.item.backcol
+          )
+        )
     }
     # ----------------------------------------
     # set legend item size
     # ----------------------------------------
     if (!is.null(legend.item.size)) {
       sjtheme <- sjtheme +
-        ggplot2::theme(legend.key.size = unit(legend.item.size, ""cm""))
+        ggplot2::theme(legend.key.size = ggplot2::unit(legend.item.size, ""cm""))
     }
     # ----------------------------------------
     # set axis line colors, if defined
     # ----------------------------------------
     if (!is.null(axis.linecolor)) {
       sjtheme <- sjtheme +
-        ggplot2::theme(axis.line = element_line(colour = axis.linecolor, size = axis.line.size),
-              axis.line.x = element_line(colour = axis.linecolor.x),
-              axis.line.y = element_line(colour = axis.linecolor.y))
+        ggplot2::theme(
+          axis.line = ggplot2::element_line(
+            colour = axis.linecolor,
+            size = axis.line.size
+          ),
+          axis.line.x = ggplot2::element_line(colour = axis.linecolor.x),
+          axis.line.y = ggplot2::element_line(colour = axis.linecolor.y)
+        )
     }
     # ----------------------------------------
     # set axis ticks, if defined
     # ----------------------------------------
     if (!is.null(axis.tickscol)) {
       sjtheme <- sjtheme +
-        ggplot2::theme(axis.ticks = element_line(colour = axis.tickscol))
+        ggplot2::theme(axis.ticks = ggplot2::element_line(colour = axis.tickscol))
     }
     if (!is.null(axis.tickslen)) {
       sjtheme <- sjtheme +
-        ggplot2::theme(axis.ticks.length = unit(axis.tickslen, ""cm""))
+        ggplot2::theme(axis.ticks.length = ggplot2::unit(axis.tickslen, ""cm""))
     }
     if (!is.null(axis.ticksmar)) {
       sjtheme <- sjtheme +
-        ggplot2::theme(axis.text = element_text(margin = margin(t = axis.ticksmar, unit = ""cm"")))
+        ggplot2::theme(
+          axis.text = ggplot2::element_text(
+            margin = ggplot2::margin(t = axis.ticksmar, unit = ""cm"")
+          )
+        )
     }
     if (!is.null(axis.ticksize.x)) {
       sjtheme <- sjtheme +
-        ggplot2::theme(axis.ticks.x = element_line(size = axis.ticksize.x))
+        ggplot2::theme(axis.ticks.x = ggplot2::element_line(size = axis.ticksize.x))
     }
     if (!is.null(axis.ticksize.y)) {
       sjtheme <- sjtheme +
-        ggplot2::theme(axis.ticks.y = element_line(size = axis.ticksize.y))
+        ggplot2::theme(axis.ticks.y = ggplot2::element_line(size = axis.ticksize.y))
     }
     # ----------------------------------------
     # set plot colors, if defined
     # ----------------------------------------
     if (!is.null(plot.col)) {
       sjtheme <- sjtheme +
-        ggplot2::theme(plot.background = element_rect(colour = plot.bordercol, fill = plot.backcol))
+        ggplot2::theme(
+          plot.background = ggplot2::element_rect(
+            colour = plot.bordercol,
+            fill = plot.backcol
+          )
+        )
     }
     # ----------------------------------------
     # set panel colors, if defined
     # ----------------------------------------
     if (!is.null(panel.col)) {
       sjtheme <- sjtheme +
-        ggplot2::theme(panel.background = element_rect(colour = panel.bordercol, fill = panel.backcol),
-              panel.border = element_rect(colour = panel.bordercol))
+        ggplot2::theme(
+          panel.background = ggplot2::element_rect(
+            colour = panel.bordercol,
+            fill = panel.backcol
+          ),
+          panel.border = ggplot2::element_rect(colour = panel.bordercol)
+        )
     }
     # ----------------------------------------
     # set panel grids, if defined
     # ----------------------------------------
     if (!is.null(panel.gridcol)) {
       sjtheme <- sjtheme +
-        ggplot2::theme(panel.grid.minor = element_line(colour = panel.minor.gridcol, linetype = panel.minor.linetype),
-              panel.grid.major = element_line(colour = panel.major.gridcol, linetype = panel.major.linetype))
+        ggplot2::theme(
+          panel.grid.minor = ggplot2::element_line(
+            colour = panel.minor.gridcol,
+            linetype = panel.minor.linetype
+          ),
+          panel.grid.major = ggplot2::element_line(
+            colour = panel.major.gridcol,
+            linetype = panel.major.linetype
+          )
+        )
     }
     # ----------------------------------------
     # set plot margins. onyl applies to pre-set themes
@@ -450,35 +517,54 @@ set_theme <- function(base = theme_grey(),
     }
     if (!is.null(title.vjust)) {
       sjtheme <- sjtheme +
-        ggplot2::theme(plot.title = element_text(vjust = title.vjust))
+        ggplot2::theme(plot.title = ggplot2::element_text(vjust = title.vjust))
     }
     if (!is.null(axis.title.x.vjust)) {
       sjtheme <- sjtheme +
-        ggplot2::theme(axis.title.x = element_text(vjust = axis.title.x.vjust))
+        ggplot2::theme(axis.title.x = ggplot2::element_text(vjust = axis.title.x.vjust))
     }
     if (!is.null(axis.title.y.vjust)) {
       sjtheme <- sjtheme +
-        ggplot2::theme(axis.title.y = element_text(vjust = axis.title.y.vjust))
+        ggplot2::theme(axis.title.y = ggplot2::element_text(vjust = axis.title.y.vjust))
     }
     # ----------------------------------------
     # panel grid colors
     # ----------------------------------------
     if (!is.null(panel.gridcol.x)) {
       sjtheme <- sjtheme +
-        ggplot2::theme(panel.grid.minor.x = element_line(colour = panel.gridcol.x, linetype = panel.minor.linetype),
-              panel.grid.major.x = element_line(colour = panel.gridcol.x, linetype = panel.major.linetype))
+        ggplot2::theme(
+          panel.grid.minor.x = ggplot2::element_line(
+            colour = panel.gridcol.x,
+            linetype = panel.minor.linetype
+          ),
+          panel.grid.major.x = ggplot2::element_line(
+            colour = panel.gridcol.x,
+            linetype = panel.major.linetype
+          )
+        )
     }
     if (!is.null(panel.gridcol.y)) {
       sjtheme <- sjtheme +
-        ggplot2::theme(panel.grid.minor.y = element_line(colour = panel.gridcol.y, linetype = panel.minor.linetype),
-              panel.grid.major.y = element_line(colour = panel.gridcol.y, linetype = panel.major.linetype))
+        ggplot2::theme(
+          panel.grid.minor.y = ggplot2::element_line(
+            colour = panel.gridcol.y,
+            linetype = panel.minor.linetype
+          ),
+          panel.grid.major.y = ggplot2::element_line(
+            colour = panel.gridcol.y,
+            linetype = panel.major.linetype
+          )
+        )
     }
     # ----------------------------------------
     # finally, set theme
     # ----------------------------------------
     theme_set(sjtheme)
   } else {
-    warning(""Either `theme` or `base` must be supplied as ggplot-theme-object to set global theme options for sjPlot."", call. = FALSE)
+    warning(
+      ""Either `theme` or `base` must be supplied as ggplot-theme-object to set global theme options for sjPlot."",
+      call. = FALSE
+    )
   }
 
   # ----------------------------------------

---FILE: R/sjplot_themes.R---
@@ -87,14 +87,14 @@
 theme_sjplot <- function(base_size = 12, base_family = """") {
   (ggplot2::theme_minimal(base_size = base_size, base_family = base_family) +
      ggplot2::theme(
-       axis.line.x      = element_line(colour = ""grey80""),
-       axis.line.y      = element_line(colour = ""grey80""),
-       axis.text        = element_text(colour = ""grey50""),
-       axis.title       = element_text(colour = ""grey30""),
-       strip.background = element_rect(colour = ""grey70"", fill = ""grey90""),
-       strip.text       = element_text(colour = ""grey30""),
-       legend.title     = element_text(colour = ""grey30""),
-       legend.text      = element_text(colour = ""grey30"")
+       axis.line.x      = ggplot2::element_line(colour = ""grey80""),
+       axis.line.y      = ggplot2::element_line(colour = ""grey80""),
+       axis.text        = ggplot2::element_text(colour = ""grey50""),
+       axis.title       = ggplot2::element_text(colour = ""grey30""),
+       strip.background = ggplot2::element_rect(colour = ""grey70"", fill = ""grey90""),
+       strip.text       = ggplot2::element_text(colour = ""grey30""),
+       legend.title     = ggplot2::element_text(colour = ""grey30""),
+       legend.text      = ggplot2::element_text(colour = ""grey30"")
      ))
 }
 
@@ -104,14 +104,14 @@ theme_sjplot <- function(base_size = 12, base_family = """") {
 theme_sjplot2 <- function(base_size = 12, base_family = """") {
   (ggplot2::theme_minimal(base_size = base_size, base_family = base_family) +
      ggplot2::theme(
-       axis.line.x      = element_line(colour = ""grey50""),
-       axis.line.y      = element_line(colour = ""grey50""),
-       axis.text        = element_text(colour = ""grey10""),
-       axis.title       = element_text(colour = ""black""),
-       strip.background = element_rect(colour = ""grey50"", fill = ""grey70""),
-       strip.text       = element_text(colour = ""grey20""),
-       legend.title     = element_text(colour = ""grey10""),
-       legend.text      = element_text(colour = ""grey20"")
+       axis.line.x      = ggplot2::element_line(colour = ""grey50""),
+       axis.line.y      = ggplot2::element_line(colour = ""grey50""),
+       axis.text        = ggplot2::element_text(colour = ""grey10""),
+       axis.title       = ggplot2::element_text(colour = ""black""),
+       strip.background = ggplot2::element_rect(colour = ""grey50"", fill = ""grey70""),
+       strip.text       = ggplot2::element_text(colour = ""grey20""),
+       legend.title     = ggplot2::element_text(colour = ""grey10""),
+       legend.text      = ggplot2::element_text(colour = ""grey20"")
      ))
 }
 
@@ -121,12 +121,12 @@ theme_sjplot2 <- function(base_size = 12, base_family = """") {
 theme_blank <- function(base_size = 12, base_family = """") {
   (ggplot2::theme_minimal(base_size = base_size, base_family = base_family) +
      ggplot2::theme(
-       axis.line.x      = element_line(colour = ""white""),
-       axis.line.y      = element_line(colour = ""white""),
-       axis.text        = element_text(colour = ""grey50""),
-       axis.title       = element_text(colour = ""grey30""),
-       panel.grid.minor = element_line(colour = ""white"", linetype = 1),
-       panel.grid.major = element_line(colour = ""white"", linetype = 1)
+       axis.line.x      = ggplot2::element_line(colour = ""white""),
+       axis.line.y      = ggplot2::element_line(colour = ""white""),
+       axis.text        = ggplot2::element_text(colour = ""grey50""),
+       axis.title       = ggplot2::element_text(colour = ""grey30""),
+       panel.grid.minor = ggplot2::element_line(colour = ""white"", linetype = 1),
+       panel.grid.major = ggplot2::element_line(colour = ""white"", linetype = 1)
      ))
 }
 
@@ -136,15 +136,15 @@ theme_blank <- function(base_size = 12, base_family = """") {
 theme_538 <- function(base_size = 12, base_family = """") {
   (ggplot2::theme_minimal(base_size = base_size, base_family = base_family) +
      ggplot2::theme(
-       axis.line.x        = element_line(colour = ""#F0F0F0""),
-       axis.line.y        = element_line(colour = ""#F0F0F0""),
-       axis.text          = element_text(colour = ""#737373""),
-       axis.title         = element_text(colour = ""#525252""),
-       plot.background    = element_rect(colour = ""#F0F0F0"", fill = ""#F0F0F0""),
-       panel.grid.minor.x = element_line(colour = ""#F0F0F0"", linetype = 1),
-       panel.grid.major   = element_line(colour = ""#BDBDBD"", linetype = 1),
-       panel.grid.major.y = element_line(colour = ""#F0F0F0"", linetype = 1),
-       panel.grid.minor.y = element_line(colour = ""#F0F0F0"", linetype = 1)
+       axis.line.x        = ggplot2::element_line(colour = ""#F0F0F0""),
+       axis.line.y        = ggplot2::element_line(colour = ""#F0F0F0""),
+       axis.text          = ggplot2::element_text(colour = ""#737373""),
+       axis.title         = ggplot2::element_text(colour = ""#525252""),
+       plot.background    = ggplot2::element_rect(colour = ""#F0F0F0"", fill = ""#F0F0F0""),
+       panel.grid.minor.x = ggplot2::element_line(colour = ""#F0F0F0"", linetype = 1),
+       panel.grid.major   = ggplot2::element_line(colour = ""#BDBDBD"", linetype = 1),
+       panel.grid.major.y = ggplot2::element_line(colour = ""#F0F0F0"", linetype = 1),
+       panel.grid.minor.y = ggplot2::element_line(colour = ""#F0F0F0"", linetype = 1)
      ))
 }
 
@@ -160,37 +160,37 @@ font_size <- function(title, axis_title.x, axis_title.y, labels.x, labels.y, off
 
   if (!missing(title)) {
     cur.theme <- cur.theme +
-      ggplot2::theme(title = element_text(size = title))
+      ggplot2::theme(title = ggplot2::element_text(size = title))
   }
 
   if (!missing(axis_title.x)) {
     cur.theme <- cur.theme +
-      ggplot2::theme(axis.title.x = element_text(size = axis_title.x))
+      ggplot2::theme(axis.title.x = ggplot2::element_text(size = axis_title.x))
   }
 
   if (!missing(axis_title.y)) {
     cur.theme <- cur.theme +
-      ggplot2::theme(axis.title.y = element_text(size = axis_title.y))
+      ggplot2::theme(axis.title.y = ggplot2::element_text(size = axis_title.y))
   }
 
   if (!missing(labels.x)) {
     cur.theme <- cur.theme +
-      ggplot2::theme(axis.text.x =  element_text(size = labels.x))
+      ggplot2::theme(axis.text.x =  ggplot2::element_text(size = labels.x))
   }
 
   if (!missing(labels.y)) {
     cur.theme <- cur.theme +
-      ggplot2::theme(axis.text.y =  element_text(size = labels.y))
+      ggplot2::theme(axis.text.y =  ggplot2::element_text(size = labels.y))
   }
 
   if (!missing(offset.x)) {
     cur.theme <- cur.theme +
-      ggplot2::theme(axis.title.x = element_text(vjust = offset.x))
+      ggplot2::theme(axis.title.x = ggplot2::element_text(vjust = offset.x))
   }
 
   if (!missing(offset.y)) {
     cur.theme <- cur.theme +
-      ggplot2::theme(axis.title.y = element_text(vjust = offset.y))
+      ggplot2::theme(axis.title.y = ggplot2::element_text(vjust = offset.y))
   }
 
   cur.theme
@@ -208,12 +208,12 @@ label_angle <- function(angle.x, angle.y, base.theme) {
 
   if (!missing(angle.x)) {
     cur.theme <- cur.theme +
-      ggplot2::theme(axis.text.x = element_text(angle = angle.x))
+      ggplot2::theme(axis.text.x = ggplot2::element_text(angle = angle.x))
   }
 
   if (!missing(angle.y)) {
     cur.theme <- cur.theme +
-      ggplot2::theme(axis.text.y = element_text(angle = angle.y))
+      ggplot2::theme(axis.text.y = ggplot2::element_text(angle = angle.y))
   }
 
   cur.theme

---FILE: man/plot_xtab.Rd---
@@ -199,7 +199,7 @@ plot_xtab(x, grp, margin = ""row"", bar.pos = ""stack"",
 library(sjmisc)
 library(sjlabelled)
 data(efc)
-set_ggplot2::theme(geom.label.angle = 90)
+sjPlot::set_theme(geom.label.angle = 90)
 plot_xtab(efc$e42dep, efc$e16sex, vjust = ""center"", hjust = ""bottom"")
 
 # grouped bars with EUROFAMCARE sample dataset

---FILE: vignettes/custplot.Rmd---
@@ -197,7 +197,7 @@ plot_grpfrq(
   coord.flip = TRUE,
   show.axis.values = FALSE
 ) +
-  theme(axis.line.x = element_line(color = ""white""))
+  theme(axis.line.x = ggplot2::element_line(color = ""white""))
 ```
 
 ## Plot legend"
strengejacke,sjPlot,9c20a2f6f0705762092f89a92615cc1a6cfcca7f,Daniel,mail@danielluedecke.de,2025-07-01T10:41:55Z,Daniel,mail@danielluedecke.de,2025-07-01T10:41:55Z,fix,NAMESPACE;R/S3-methods.R,False,True,True,False,11,10,21,"---FILE: NAMESPACE---
@@ -1,5 +1,13 @@
 # Generated by roxygen2: do not edit by hand
 
+S3method(knit_print,sjTable)
+S3method(knit_print,sjt_descr)
+S3method(knit_print,sjt_frq)
+S3method(knit_print,sjt_grpdescr)
+S3method(knit_print,sjt_grpmean)
+S3method(knit_print,sjt_grpmeans)
+S3method(knit_print,sjt_mwu)
+S3method(knit_print,sjt_reliab)
 S3method(print,sjTable)
 S3method(print,sjt_descr)
 S3method(print,sjt_equi_test)
@@ -16,14 +24,6 @@ export(dist_norm)
 export(dist_t)
 export(font_size)
 export(get_model_data)
-export(knit_print.sjTable)
-export(knit_print.sjt_descr)
-export(knit_print.sjt_frq)
-export(knit_print.sjt_grpdescr)
-export(knit_print.sjt_grpmean)
-export(knit_print.sjt_grpmeans)
-export(knit_print.sjt_mwu)
-export(knit_print.sjt_reliab)
 export(label_angle)
 export(legend_style)
 export(plot_frq)
@@ -81,7 +81,6 @@ importFrom(ggeffects,ggeffect)
 importFrom(ggeffects,ggpredict)
 importFrom(grDevices,axisTicks)
 importFrom(grDevices,cm)
-importFrom(grDevices,colorRampPalette)
 importFrom(grDevices,dev.off)
 importFrom(grDevices,jpeg)
 importFrom(grDevices,png)
@@ -91,6 +90,8 @@ importFrom(grDevices,tiff)
 importFrom(graphics,plot)
 importFrom(insight,is_multivariate)
 importFrom(insight,model_info)
+importFrom(knitr,asis_output)
+importFrom(knitr,knit_print)
 importFrom(performance,cronbachs_alpha)
 importFrom(performance,performance_aic)
 importFrom(performance,performance_aicc)

---FILE: R/S3-methods.R---
@@ -19,7 +19,7 @@ print.sjTable <- function(x, ...) {
   }
 }
 
-
+#' @importFrom knitr knit_print asis_output
 #' @export
 knit_print.sjTable <-  function(x, ...) {
   out <- x$knitr"
strengejacke,sjPlot,fd8786ba9245b327cc7f912a1387e242441e7ffb,Daniel,mail@danielluedecke.de,2025-07-01T10:38:57Z,Daniel,mail@danielluedecke.de,2025-07-01T10:38:57Z,fix,DESCRIPTION;NAMESPACE;R/S3-methods.R;R/helpfunctions.R;R/html_print.R;R/html_print_utils.R;R/plot_diag_linear.R;R/plot_diag_stan.R;R/plot_frq.R;R/plot_gpt.R;R/plot_grid.R;R/plot_grpfrq.R;R/plot_kfold_cv.R;R/plot_likert.R;R/plot_model.R;R/plot_residuals.R;R/plot_stackfrq.R;R/plot_xtab.R;R/sjplot.R;R/sjplot_themes.R;R/tab_model.R;R/tidiers.R;R/utils.R;man/plot_frq.Rd;man/plot_grid.Rd;man/plot_likert.Rd;man/plot_stackfrq.Rd;man/sjplot.Rd;vignettes/plot_likert_scales.Rmd,True,True,True,False,130,202,332,"---FILE: DESCRIPTION---
@@ -21,7 +21,7 @@ Description: Collection of plotting and table output functions for data
     labelled data.
 License: GPL-3
 Depends:
-    R (>= 3.6)
+    R (>= 4.1)
 Imports:
     graphics,
     grDevices,

---FILE: NAMESPACE---
@@ -1,13 +1,5 @@
 # Generated by roxygen2: do not edit by hand
 
-S3method(knit_print,sjTable)
-S3method(knit_print,sjt_descr)
-S3method(knit_print,sjt_frq)
-S3method(knit_print,sjt_grpdescr)
-S3method(knit_print,sjt_grpmean)
-S3method(knit_print,sjt_grpmeans)
-S3method(knit_print,sjt_mwu)
-S3method(knit_print,sjt_reliab)
 S3method(print,sjTable)
 S3method(print,sjt_descr)
 S3method(print,sjt_equi_test)
@@ -24,6 +16,14 @@ export(dist_norm)
 export(dist_t)
 export(font_size)
 export(get_model_data)
+export(knit_print.sjTable)
+export(knit_print.sjt_descr)
+export(knit_print.sjt_frq)
+export(knit_print.sjt_grpdescr)
+export(knit_print.sjt_grpmean)
+export(knit_print.sjt_grpmeans)
+export(knit_print.sjt_mwu)
+export(knit_print.sjt_reliab)
 export(label_angle)
 export(legend_style)
 export(plot_frq)
@@ -66,14 +66,11 @@ export(theme_blank)
 export(theme_sjplot)
 export(theme_sjplot2)
 export(view_df)
-importFrom(dplyr,""%>%"")
 importFrom(dplyr,arrange)
 importFrom(dplyr,bind_rows)
 importFrom(dplyr,case_when)
 importFrom(dplyr,filter)
 importFrom(dplyr,group_by)
-importFrom(dplyr,group_modify)
-importFrom(dplyr,group_vars)
 importFrom(dplyr,if_else)
 importFrom(dplyr,mutate)
 importFrom(dplyr,n_distinct)
@@ -92,56 +89,40 @@ importFrom(grDevices,rgb)
 importFrom(grDevices,svg)
 importFrom(grDevices,tiff)
 importFrom(graphics,plot)
-importFrom(insight,has_intercept)
 importFrom(insight,is_multivariate)
 importFrom(insight,model_info)
-importFrom(knitr,asis_output)
-importFrom(knitr,knit_print)
 importFrom(performance,cronbachs_alpha)
 importFrom(performance,performance_aic)
 importFrom(performance,performance_aicc)
 importFrom(purrr,as_vector)
 importFrom(purrr,flatten_chr)
 importFrom(purrr,map)
-importFrom(purrr,map_chr)
 importFrom(purrr,map_dbl)
 importFrom(purrr,map_df)
-importFrom(purrr,map_if)
 importFrom(purrr,map_lgl)
-importFrom(purrr,pmap)
 importFrom(rlang,.data)
 importFrom(rlang,enquo)
 importFrom(rlang,quo_name)
 importFrom(scales,brewer_pal)
 importFrom(scales,grey_pal)
 importFrom(scales,percent)
-importFrom(sjlabelled,copy_labels)
 importFrom(sjlabelled,drop_labels)
 importFrom(sjlabelled,get_label)
 importFrom(sjlabelled,get_labels)
 importFrom(sjlabelled,get_values)
-importFrom(sjlabelled,set_labels)
 importFrom(sjmisc,add_variables)
 importFrom(sjmisc,frq)
-importFrom(sjmisc,group_labels)
-importFrom(sjmisc,group_var)
 importFrom(sjmisc,is_empty)
 importFrom(sjmisc,is_even)
 importFrom(sjmisc,is_float)
-importFrom(sjmisc,is_num_fac)
 importFrom(sjmisc,to_value)
 importFrom(sjmisc,trim)
 importFrom(sjmisc,var_type)
 importFrom(sjmisc,word_wrap)
-importFrom(sjstats,cramer)
 importFrom(sjstats,crosstable_statistics)
-importFrom(sjstats,phi)
 importFrom(sjstats,table_values)
 importFrom(stats,aov)
 importFrom(stats,binomial)
-importFrom(stats,chisq.test)
-importFrom(stats,coef)
-importFrom(stats,complete.cases)
 importFrom(stats,confint)
 importFrom(stats,cor)
 importFrom(stats,cor.test)
@@ -150,11 +131,8 @@ importFrom(stats,deviance)
 importFrom(stats,df)
 importFrom(stats,dnorm)
 importFrom(stats,dt)
-importFrom(stats,fisher.test)
-importFrom(stats,fitted)
 importFrom(stats,ftable)
 importFrom(stats,glm)
-importFrom(stats,kruskal.test)
 importFrom(stats,lm)
 importFrom(stats,loess)
 importFrom(stats,logLik)
@@ -164,7 +142,6 @@ importFrom(stats,pchisq)
 importFrom(stats,pf)
 importFrom(stats,pnorm)
 importFrom(stats,poly)
-importFrom(stats,ppoints)
 importFrom(stats,prcomp)
 importFrom(stats,predict)
 importFrom(stats,pt)
@@ -174,15 +151,8 @@ importFrom(stats,qnorm)
 importFrom(stats,qt)
 importFrom(stats,quantile)
 importFrom(stats,reshape)
-importFrom(stats,residuals)
-importFrom(stats,rstudent)
-importFrom(stats,sd)
 importFrom(stats,summary.lm)
-importFrom(stats,weighted.mean)
 importFrom(stats,xtabs)
 importFrom(tidyr,gather)
-importFrom(tidyr,nest)
-importFrom(tidyr,spread)
-importFrom(utils,browseURL)
 importFrom(utils,setTxtProgressBar)
 importFrom(utils,txtProgressBar)

---FILE: R/S3-methods.R---
@@ -1,4 +1,3 @@
-#' @importFrom utils browseURL
 #' @export
 print.sjTable <- function(x, ...) {
   # check if we have filename specified
@@ -21,7 +20,6 @@ print.sjTable <- function(x, ...) {
 }
 
 
-#' @importFrom knitr knit_print asis_output
 #' @export
 knit_print.sjTable <-  function(x, ...) {
   out <- x$knitr
@@ -209,7 +207,6 @@ pgrpmean <- function(x, ...) {
 }
 
 
-#' @importFrom purrr map_chr
 pgrpmeans <- function(x, ...) {
   uv <- attr(x, ""print"", exact = TRUE) == ""viewer""
   enc <- attr(x, ""encoding"", exact = TRUE)
@@ -343,8 +340,6 @@ preliab <- function(x, ...) {
 }
 
 
-#' @importFrom purrr map_if
-#' @importFrom sjmisc is_float
 pdescr <- function(x, ...) {
   digits <- 2
 
@@ -376,8 +371,8 @@ pdescr <- function(x, ...) {
   present_columns <- c(""var"", ""type"", ""label"", ""n"", ""NA.prc"", ""mean"", ""sd"", ""se"", ""md"", ""trimmed"", ""range"", ""skew"")
   chead <- chead[which(present_columns %in% colnames(x))]
 
-  x <- x %>%
-    purrr::map_if(sjmisc::is_float, ~ round(.x, digits)) %>%
+  x <- x |>
+    purrr::map_if(sjmisc::is_float, ~ round(.x, digits)) |>
     as.data.frame()
 
   tab_df(
@@ -404,8 +399,6 @@ pdescr <- function(x, ...) {
 }
 
 
-#' @importFrom purrr map_if map_chr map
-#' @importFrom sjmisc is_float
 pgdescr <- function(x, ...) {
   titles <- purrr::map_chr(x, ~ sprintf(
     ""Basic descriptives<br><span class=\""subtitle\""><em>grouped by</em> %s</span>"",
@@ -439,12 +432,12 @@ pgdescr <- function(x, ...) {
     ""Skewness""
   )
 
-  x <- x %>%
+  x <- x |>
     purrr::map(~ purrr::map_if(
       .x,
       sjmisc::is_float,
       ~ round(.x, digits)
-    ) %>% as.data.frame())
+    ) |> as.data.frame())
 
   tab_dfs(
     x = x,
@@ -468,9 +461,6 @@ pgdescr <- function(x, ...) {
 }
 
 
-#' @importFrom purrr map_if map_chr map
-#' @importFrom dplyr n_distinct select
-#' @importFrom sjmisc is_empty
 pfrq <- function(x, ...) {
 
   uv <- attr(x, ""print"", exact = TRUE) == ""viewer""
@@ -549,7 +539,6 @@ pfrq <- function(x, ...) {
 }
 
 
-#' @importFrom stats na.omit kruskal.test
 pmwu <- function(x, ...) {
   fn <- NULL
 

---FILE: R/helpfunctions.R---
@@ -81,8 +81,6 @@ get_var_name <- function(x) {
 
 # Create frequency data frame of a variable
 # for sjp and sjt frq functions
-#' @importFrom stats na.omit ftable na.pass
-#' @importFrom tidyr spread
 create.xtab.df <- function(x,
                            grp,
                            round.prz = 2,
@@ -209,8 +207,6 @@ get.encoding <- function(encoding, data = NULL) {
 
 
 # Calculate statistics of cross tabs
-#' @importFrom sjstats cramer phi table_values
-#' @importFrom stats chisq.test fisher.test xtabs
 crosstabsum <- function(x, grp, weight.by) {
   # --------------------------------------------------------
   # check p-value-style option

---FILE: R/html_print.R---
@@ -168,8 +168,6 @@ tab_df <- function(x,
 }
 
 
-#' @importFrom sjmisc var_type is_even
-#' @importFrom purrr flatten_chr pmap
 #' @rdname tab_df
 #' @export
 tab_dfs <- function(x,
@@ -273,7 +271,6 @@ tab_dfs <- function(x,
   )
 }
 
-#' @importFrom dplyr ""%>%""
 # this function is used from tab_model()
 tab_model_df <- function(x,
                          zeroinf,
@@ -439,9 +436,9 @@ tab_model_df <- function(x,
     rem <- 1:nrow(x)
 
     zero.part <- suppressMessages(
-      x %>%
-        dplyr::full_join(zeroinf) %>%
-        dplyr::slice(!! -rem) %>%
+      x |>
+        dplyr::full_join(zeroinf) |>
+        dplyr::slice(!! -rem) |>
         sjmisc::replace_na(value = """")
     )
 

---FILE: R/html_print_utils.R---
@@ -17,7 +17,6 @@ check_css_param <- function(CSS) {
 # This functions creates the body of the HTML page, i.e. it puts
 # the content of a data frame into a HTML table that is returned.
 
-#' @importFrom sjmisc is_empty var_type is_even trim
 tab_df_content <- function(
   mydf,
   title,

---FILE: R/plot_diag_linear.R---
@@ -31,7 +31,6 @@ plot_diag_glm <- function(model, geom.colors, dot.size, line.size, ...) {
 }
 
 
-#' @importFrom stats residuals fitted
 diag_ncv <- function(model, dot.size, line.size) {
 
   if (is.null(dot.size)) dot.size <- 1
@@ -56,7 +55,6 @@ diag_ncv <- function(model, dot.size, line.size) {
 
 
 #' @importFrom rlang .data
-#' @importFrom stats residuals sd
 diag_norm <- function(model, geom.colors) {
   res_ <- data.frame(res = stats::residuals(model))
 
@@ -80,7 +78,6 @@ diag_norm <- function(model, geom.colors) {
 }
 
 
-#' @importFrom stats residuals rstudent fitted
 diag_qq <- function(model, geom.colors, dot.size, line.size, ...) {
 
   if (is.null(dot.size)) dot.size <- 1
@@ -115,8 +112,6 @@ diag_qq <- function(model, geom.colors, dot.size, line.size, ...) {
 }
 
 
-#' @importFrom purrr map map_dbl
-#' @importFrom stats qnorm ppoints
 diag_reqq <- function(model, dot.size) {
 
   if (!is_merMod(model) && !inherits(model, ""glmmTMB"")) return(NULL)
@@ -190,7 +185,6 @@ diag_reqq <- function(model, dot.size) {
 }
 
 
-#' @importFrom stats coef
 diag_vif <- function(fit) {
 
   if (is_merMod(fit) || inherits(fit, ""lme""))
@@ -227,7 +221,7 @@ diag_vif <- function(fit) {
 
     if (maxval >= upperLimit) upperLimit <- ceiling(maxval)
 
-    mydat <- data.frame(vif = round(val, 2)) %>%
+    mydat <- data.frame(vif = round(val, 2)) |>
       rownames_as_column(var = ""vars"")
 
 

---FILE: R/plot_diag_stan.R---
@@ -87,7 +87,7 @@ plot_diag_stan <- function(model, geom.colors, axis.lim, facets, axis.labels, ..
 
   # join data frames and convert to long format
 
-  pp <- dplyr::bind_rows(d1, d2) %>%
+  pp <- dplyr::bind_rows(d1, d2) |>
     tidyr::gather(key = ""Term"", value = ""Estimate"", !! gather.cols)
 
 

---FILE: R/plot_frq.R---
@@ -75,8 +75,8 @@ utils::globalVariables(""density"")
 #'
 #' if (require(""dplyr"")) {
 #'   # histogram, pipe-workflow
-#'   efc %>%
-#'     dplyr::select(e17age, c160age) %>%
+#'   efc |>
+#'     dplyr::select(e17age, c160age) |>
 #'     plot_frq(type = ""hist"", show.mean = TRUE)
 #'
 #'   # bar plot(s)
@@ -85,9 +85,9 @@ utils::globalVariables(""density"")
 #'
 #' if (require(""dplyr"") && require(""gridExtra"")) {
 #'   # grouped data frame, all panels in one plot
-#'   efc %>%
-#'     group_by(e42dep) %>%
-#'     plot_frq(c161sex) %>%
+#'   efc |>
+#'     group_by(e42dep) |>
+#'     plot_frq(c161sex) |>
 #'     plot_grid()
 #' }
 #'
@@ -109,9 +109,6 @@ utils::globalVariables(""density"")
 #'         normal.curve = TRUE, show.sd = TRUE, normal.curve.color = ""blue"",
 #'         normal.curve.size = 3, ylim = c(0,50))
 #' }
-#' @importFrom sjmisc group_labels group_var to_value frq
-#' @importFrom sjlabelled set_labels drop_labels
-#' @importFrom stats na.omit sd weighted.mean dnorm
 #' @importFrom rlang .data
 #' @export
 plot_frq <- function(data,

---FILE: R/plot_gpt.R---
@@ -244,16 +244,16 @@ gpt_helper <- function(
   # group data by grouping variable, and inside
   # groups, group the x-variable
 
-  newdf <- mydf %>%
-    dplyr::group_by(.data$grp, .data$xpos) %>%
+  newdf <- mydf |>
+    dplyr::group_by(.data$grp, .data$xpos) |>
     dplyr::summarise(ypos = mean(.data$dep))
 
   # group data by grouping variable,
   # and summarize N per group and chisq.test
   # of grp and x within each group
 
-  pvals <- mydf %>%
-    dplyr::group_by(.data$grp) %>%
+  pvals <- mydf |>
+    dplyr::group_by(.data$grp) |>
     dplyr::summarise(N = dplyr::n(), p = suppressWarnings(stats::chisq.test(table(.data$xpos, .data$dep))$p.value))
 
   # copy p values
@@ -266,12 +266,12 @@ gpt_helper <- function(
   # if we want total line, repeat all for
   # complete data frame
   if (show.total) {
-    tmp <- mydf %>%
-      dplyr::group_by(.data$xpos) %>%
+    tmp <- mydf |>
+      dplyr::group_by(.data$xpos) |>
       dplyr::summarise(ypos = mean(.data$dep))
 
     # pvalues and N
-    pvals <- mydf %>%
+    pvals <- mydf |>
       dplyr::summarise(N = dplyr::n(), p = suppressWarnings(stats::chisq.test(table(.data$xpos, .data$dep))$p.value))
 
     # bind total row to final df

---FILE: R/plot_grid.R---
@@ -30,13 +30,13 @@
 #'   )
 #'
 #'   # plot marginal effects for each predictor, each as single plot
-#'   p1 <- ggpredict(fit, ""c12hour"") %>%
+#'   p1 <- ggpredict(fit, ""c12hour"") |>
 #'     plot(show_y_title = FALSE, show_title = FALSE)
-#'   p2 <- ggpredict(fit, ""e17age"") %>%
+#'   p2 <- ggpredict(fit, ""e17age"") |>
 #'     plot(show_y_title = FALSE, show_title = FALSE)
-#'   p3 <- ggpredict(fit, ""e42dep"") %>%
+#'   p3 <- ggpredict(fit, ""e42dep"") |>
 #'     plot(show_y_title = FALSE, show_title = FALSE)
-#'   p4 <- ggpredict(fit, ""neg_c_7"") %>%
+#'   p4 <- ggpredict(fit, ""neg_c_7"") |>
 #'     plot(show_y_title = FALSE, show_title = FALSE)
 #'
 #'   # plot grid

---FILE: R/plot_grpfrq.R---
@@ -430,9 +430,9 @@ plot_grpfrq <- function(var.cnt,
 
   # add half of Percentage values as new y-position for stacked bars
   # mydat <- ddply(mydat, ""count"", transform, ypos = cumsum(frq) - 0.5*frq)
-  mydf <- mydf %>%
-    dplyr::group_by(.data$label) %>%
-    dplyr::mutate(ypos = cumsum(.data$frq) - 0.5 * .data$frq) %>%
+  mydf <- mydf |>
+    dplyr::group_by(.data$label) |>
+    dplyr::mutate(ypos = cumsum(.data$frq) - 0.5 * .data$frq) |>
     dplyr::arrange(.data$label)
 
   # add percentages

---FILE: R/plot_kfold_cv.R---
@@ -86,9 +86,9 @@ plot_kfold_cv <- function(data, formula, k = 5, fit) {
         out <- datawizard::data_partition(data, training_proportion = .8)
         data.frame(train = I(list(out[[1]])), test = I(list(out$test)))
       }))
-      res <- kfolds %>%
-        dplyr::mutate(model = purrr::map(.data$train, ~ stats::glm(formula, data = .x, family = stats::poisson(link = ""log"")))) %>%
-        dplyr::mutate(residuals = purrr::map(.data$model, ~ stats::residuals(.x, ""deviance""))) %>%
+      res <- kfolds |>
+        dplyr::mutate(model = purrr::map(.data$train, ~ stats::glm(formula, data = .x, family = stats::poisson(link = ""log"")))) |>
+        dplyr::mutate(residuals = purrr::map(.data$model, ~ stats::residuals(.x, ""deviance""))) |>
         dplyr::mutate(.response = purrr::map(.data$model, ~ insight::get_response(.x)))
     # for negative binomial models, show deviance residuals
     } else if (inherits(fit, ""negbin"")) {
@@ -98,14 +98,14 @@ plot_kfold_cv <- function(data, formula, k = 5, fit) {
         out <- datawizard::data_partition(data, training_proportion = .8)
         data.frame(train = I(list(out[[1]])), test = I(list(out$test)))
       }))
-      res <- kfolds %>%
-        dplyr::mutate(model = purrr::map(.data$train, ~ MASS::glm.nb(formula, data = .))) %>%
-        dplyr::mutate(residuals = purrr::map(.data$model, ~ stats::residuals(.x, ""deviance""))) %>%
+      res <- kfolds |>
+        dplyr::mutate(model = purrr::map(.data$train, ~ MASS::glm.nb(formula, data = .))) |>
+        dplyr::mutate(residuals = purrr::map(.data$model, ~ stats::residuals(.x, ""deviance""))) |>
         dplyr::mutate(.response = purrr::map(.data$model, ~ insight::get_response(.x)))
     }
 
     # unnest residuals and response values
-    res <- suppressWarnings(res %>% tidyr::unnest(residuals, .data$.response))
+    res <- suppressWarnings(res |> tidyr::unnest(residuals, .data$.response))
 
   } else {
     # create cross-validated test-training pairs, run linear model on each
@@ -115,19 +115,19 @@ plot_kfold_cv <- function(data, formula, k = 5, fit) {
       out <- datawizard::data_partition(data, training_proportion = .8)
       data.frame(train = I(list(out[[1]])), test = I(list(out$test)))
     }))
-    res <- kfolds %>%
-      dplyr::mutate(model = purrr::map(.data$train, ~ stats::lm(formula, data = .))) %>%
+    res <- kfolds |>
+      dplyr::mutate(model = purrr::map(.data$train, ~ stats::lm(formula, data = .))) |>
       dplyr::mutate(predicted = purrr::map2(.data$model, .data$test, function(.x, .y) {
         out <- data.frame(.fitted = stats::predict(.x, newdata = .y))
         cbind(.y, out)
-      })) %>%
+      })) |>
       tidyr::unnest(cols = .data$predicted)
 
     # make sure that response vector has an identifiably name
     colnames(res)[which(colnames(res) == deparse(resp))] <- "".response""
 
     # compute residuals for each k-fold model
-    res <- res %>%
+    res <- res |>
       dplyr::mutate(residuals = .data$.response - .data$.fitted)
   }
 

---FILE: R/plot_likert.R---
@@ -120,7 +120,7 @@
 #'
 #' \dontrun{
 #' six_cat_example <-
-#'   six_cat_example %>%
+#'   six_cat_example |>
 #'   dplyr::mutate_all(~ordered(.,labels = c(""+++"",""++"",""+"",""-"",""--"",""---"")))
 #'
 #' # Old default
@@ -396,10 +396,10 @@ plot_likert <- function(
     # add new unique item values to catcount, so catcount
     # finally contains all unique values of items
 
-    catcount <- items %>%
-      purrr::map(~ stats::na.omit(unique(.x))) %>%
-      purrr::flatten_dbl() %>%
-      unique() %>%
+    catcount <- items |>
+      purrr::map(~ stats::na.omit(unique(.x))) |>
+      purrr::flatten_dbl() |>
+      unique() |>
       sort()
 
     neutral.between <- FALSE
@@ -967,5 +967,4 @@ plot_likert <- function(
 
 
 # is factor with char levels?
-#' @importFrom sjmisc is_num_fac
 is_labelled_factor <- function(x) is.factor(x) && !sjmisc::is_num_fac(x)

---FILE: R/plot_model.R---
@@ -809,7 +809,6 @@ plot_model <- function(model,
 }
 
 
-#' @importFrom purrr map
 #' @rdname plot_model
 #' @export
 get_model_data <- function(model,
@@ -856,7 +855,6 @@ get_model_data <- function(model,
 }
 
 
-#' @importFrom insight has_intercept
 one_par <- function(model) {
   tryCatch(
     {

---FILE: R/plot_residuals.R---
@@ -66,7 +66,7 @@ plot_residuals <- function(fit, geom.size = 2, remove.estimates = NULL, show.lin
   rv <- insight::find_response(fit)
 
   # remove estimates, if required
-  dummy <- mydat %>% dplyr::select(keep, .data$predicted, .data$residuals)
+  dummy <- mydat |> dplyr::select(keep, .data$predicted, .data$residuals)
 
   # set default variable labels, used as column names, so labelled
   # data variable labels appear in facet grid header.
@@ -78,7 +78,7 @@ plot_residuals <- function(fit, geom.size = 2, remove.estimates = NULL, show.lin
   colnames(dummy)[sel] <- var.labels
 
   # melt data
-  mydat <- suppressWarnings(dummy %>%
+  mydat <- suppressWarnings(dummy |>
     tidyr::gather(key = ""grp"", value = ""x"", -1, -.data$predicted, -.data$residuals))
 
   colnames(mydat)[1] <- "".response""

---FILE: R/plot_stackfrq.R---
@@ -40,9 +40,9 @@
 #'
 #' # works on grouped data frames as well
 #' library(dplyr)
-#' efc %>%
-#'   group_by(c161sex) %>%
-#'   select(start:end) %>%
+#' efc |>
+#'   group_by(c161sex) |>
+#'   select(start:end) |>
 #'   plot_stackfrq()
 #'
 #' @export

---FILE: R/plot_xtab.R---
@@ -265,9 +265,9 @@ plot_xtab <- function(x,
   # --------------------------------------------------------
   # add half of Percentage values as new y-position for stacked bars
   # --------------------------------------------------------
-  mydf <- mydf %>%
-    dplyr::group_by(.data$xpos) %>%
-    dplyr::mutate(ypos = cumsum(.data$prc) - 0.5 * .data$prc) %>%
+  mydf <- mydf |>
+    dplyr::group_by(.data$xpos) |>
+    dplyr::mutate(ypos = cumsum(.data$prc) - 0.5 * .data$prc) |>
     dplyr::arrange(.data$group)
   # --------------------------------------------------------
   # add line-break char
@@ -322,9 +322,9 @@ plot_xtab <- function(x,
   } else if (bar.pos == ""stack"") {
     # check upper limits. we may have rounding errors, so values
     # sum up to more than 100%
-    ul <- max(mydf %>%
-                dplyr::group_by(.data$rowname) %>%
-                dplyr::summarize(ges = sum(.data$prc)) %>%
+    ul <- max(mydf |>
+                dplyr::group_by(.data$rowname) |>
+                dplyr::summarize(ges = sum(.data$prc)) |>
                 dplyr::select(.data$ges), na.rm = TRUE)
     if (ul > 1L)
       upper_lim <- ul

---FILE: R/sjplot.R---
@@ -50,24 +50,19 @@
 #' data(efc)
 #'
 #' # Grouped frequencies
-#' efc %>% sjplot(e42dep, c172code, fun = ""grpfrq"")
+#' efc |> sjplot(e42dep, c172code, fun = ""grpfrq"")
 #'
 #' # Grouped frequencies, as box plots
-#' efc %>% sjplot(e17age, c172code, fun = ""grpfrq"",
+#' efc |> sjplot(e17age, c172code, fun = ""grpfrq"",
 #'                type = ""box"", geom.colors = ""Set1"")
 #'
 #' \dontrun{
 #' # table output of grouped data frame
-#' efc %>%
-#'   group_by(e16sex, c172code) %>%
-#'   select(e42dep, n4pstu, e16sex, c172code) %>%
-#'   sjtab(fun = ""xtab"", use.viewer = FALSE) # open all tables in browser}
-#'
-#' @importFrom sjmisc is_empty
-#' @importFrom sjlabelled copy_labels get_label get_labels
-#' @importFrom dplyr filter
-#' @importFrom tidyr nest
-#' @importFrom stats complete.cases
+#' efc |>
+#'   group_by(e16sex, c172code) |>
+#'   select(e42dep, n4pstu, e16sex, c172code) |>
+#'   sjtab(fun = ""xtab"", use.viewer = FALSE) # open all tables in browser
+#'}
 #' @export
 sjplot <- function(data, ..., fun = c(""grpfrq"", ""xtab"", ""aov1"", ""likert"")) {
   # check if x is a data frame
@@ -233,7 +228,6 @@ get_grouped_title <- function(x, grps, args, i, sep = ""\n"") {
 }
 
 
-#' @importFrom sjlabelled get_values get_label get_labels
 get_title_part <- function(x, grps, level, i) {
   # prepare title for group
   var.name <- colnames(grps)[level]
@@ -258,13 +252,11 @@ get_title_part <- function(x, grps, level, i) {
 
 
 #' @importFrom rlang .data
-#' @importFrom dplyr select filter group_modify group_vars
-#' @importFrom stats complete.cases
 #'
 get_grouped_data <- function(x) {
   # retain observations that are complete wrt grouping vars, then nest
-  grps <- x %>%
-    dplyr::group_modify(~ dplyr::filter(.x, stats::complete.cases(.y))) %>%
+  grps <- x |>
+    dplyr::group_modify(~ dplyr::filter(.x, stats::complete.cases(.y))) |>
     tidyr::nest()
 
   # arrange data

---FILE: R/sjplot_themes.R---
@@ -221,7 +221,6 @@ label_angle <- function(angle.x, angle.y, base.theme) {
 
 
 #' @rdname sjPlot-themes
-#' @importFrom dplyr case_when
 #' @export
 legend_style <- function(inside, pos, justify, base.theme) {
   # get current theme
@@ -308,7 +307,6 @@ scale_fill_sjplot <- function(palette = ""metro"", discrete = TRUE, reverse = FALS
 }
 
 
-#' @importFrom stats quantile
 #' @rdname sjPlot-themes
 #' @export
 sjplot_pal <- function(palette = ""metro"", n = NULL) {
@@ -348,10 +346,10 @@ show_sjplot_pals <- function() {
   })
 
   x <- suppressWarnings(
-    sjpc %>%
-      as.data.frame() %>%
-      purrr::map_df(~ .x[length(.x):1]) %>%
-      tidyr::gather() %>%
+    sjpc |>
+      as.data.frame() |>
+      purrr::map_df(~ .x[length(.x):1]) |>
+      tidyr::gather() |>
       dplyr::arrange(.data$key)
   )
 
@@ -376,7 +374,6 @@ show_sjplot_pals <- function() {
 }
 
 
-#' @importFrom grDevices colorRampPalette
 get_sjplot_pal <- function(palette = ""metro"", reverse = FALSE, ...) {
   pal <- sjplot_colors[[palette]]
   if (reverse) pal <- rev(pal)

---FILE: R/tab_model.R---
@@ -485,31 +485,31 @@ tab_model <- function(
       # merge CI columns
 
       if (all(c(""conf.low"", ""conf.high"") %in% names(dat))) {
-        dat <- dat %>%
+        dat <- dat |>
           dplyr::mutate(conf.int = sprintf(
             ""%.*f%s%.*f"",
             digits,
             .data$conf.low,
             ci.hyphen,
             digits,
             .data$conf.high
-          )) %>%
+          )) |>
           dplyr::select(-.data$conf.low, -.data$conf.high)
       }
 
       # get inner probability (i.e. 2nd CI for Stan-models) ----
 
       if (is.stan(model)) {
-        dat <- dat %>%
-          sjmisc::var_rename(conf.int = ""ci.outer"") %>%
+        dat <- dat |>
+          sjmisc::var_rename(conf.int = ""ci.outer"") |>
           dplyr::mutate(ci.inner = sprintf(
             ""%.*f%s%.*f"",
             digits,
             .data$conf.low50,
             ci.hyphen,
             digits,
             .data$conf.high50
-          )) %>%
+          )) |>
             dplyr::select(-.data$conf.low50, -.data$conf.high50)
       }
 
@@ -535,8 +535,8 @@ tab_model <- function(
           keep = keep,
           drop = drop,
           std.response = std.response
-        ) %>%
-          format_p_values(p.style, digits.p, emph.p, p.threshold) %>%
+        ) |>
+          format_p_values(p.style, digits.p, emph.p, p.threshold) |>
           sjmisc::var_rename(
             estimate = ""std.estimate"",
             std.error = ""std.se"",
@@ -545,7 +545,7 @@ tab_model <- function(
             p.value = ""std.p.value"",
             statistic = ""std.statistic"",
             p.stars = ""std.p.stars""
-          ) %>%
+          ) |>
           dplyr::select(-1)
 
         # transform estimates
@@ -558,21 +558,21 @@ tab_model <- function(
           tmp_dat[[""std.se""]] <- tmp_dat[[""std.se""]] * tmp_dat[[""std.estimate""]]
         }
 
-        dat <- tmp_dat %>%
-          sjmisc::add_columns(dat) %>%
+        dat <- tmp_dat |>
+          sjmisc::add_columns(dat) |>
           dplyr::mutate(std.conf.int = sprintf(
             ""%.*f%s%.*f"",
             digits,
             .data$std.conf.low,
             ci.hyphen,
             digits,
             .data$std.conf.high
-          )) %>%
+          )) |>
           dplyr::select(-.data$std.conf.low, -.data$std.conf.high)
         # if t-statistic is the same for standardized and unstandardized model
         # remove standardized; ignore intercept
         if (all(round(dat$statistic[-1], 3) == round(dat$std.statistic[-1], 3))) {
-          dat <- dat %>%
+          dat <- dat |>
             dplyr::select(-.data$std.statistic, -.data$std.p.value)
         }
       }
@@ -609,8 +609,8 @@ tab_model <- function(
 
       # for HTML, convert numerics to character ----
 
-      dat <- dat %>%
-        purrr::map_if(is.numeric, ~ sprintf(""%.*f"", digits, .x)) %>%
+      dat <- dat |>
+        purrr::map_if(is.numeric, ~ sprintf(""%.*f"", digits, .x)) |>
         as.data.frame(stringsAsFactors = FALSE)
 
 
@@ -684,8 +684,8 @@ tab_model <- function(
         zi <- which(dat[[wf]] %in% c(""Zero-Inflated Model"", ""Zero Inflation Model"", ""zero_inflated"", ""zi""))
 
         if (show.zeroinf && !sjmisc::is_empty(zi)) {
-          zidat <- dat %>%
-            dplyr::slice(!! zi) %>%
+          zidat <- dat |>
+            dplyr::slice(!! zi) |>
             dplyr::select(!! -wf)
         }
 
@@ -953,8 +953,8 @@ tab_model <- function(
 
   # Join all models into one data frame, and replace NA by empty strings
 
-  dat <- model.data %>%
-    purrr::reduce(~ dplyr::full_join(.x, .y, by = ""term"")) %>%
+  dat <- model.data |>
+    purrr::reduce(~ dplyr::full_join(.x, .y, by = ""term"")) |>
     purrr::map_df(~ dplyr::if_else(.x %in% na.vals | is.na(.x), """", .x))
 
   # remove unwanted columns and rows ----
@@ -980,8 +980,8 @@ tab_model <- function(
 
   zeroinf <- NULL
   if (!sjmisc::is_empty(zeroinf.data)) {
-    zeroinf <- zeroinf.data %>%
-      purrr::reduce(~ dplyr::full_join(.x, .y, by = ""term"")) %>%
+    zeroinf <- zeroinf.data |>
+      purrr::reduce(~ dplyr::full_join(.x, .y, by = ""term"")) |>
       purrr::map_df(~ dplyr::if_else(.x %in% na.vals | is.na(.x), """", .x))
 
     zeroinf <-
@@ -1127,7 +1127,7 @@ tab_model <- function(
       linesep = ""<br>""
     )
   } else if (is.null(dv.labels)) {
-    dv.labels <- purrr::map(models, insight::find_response) %>% purrr::flatten_chr()
+    dv.labels <- purrr::map(models, insight::find_response) |> purrr::flatten_chr()
   }
 
 
@@ -1430,7 +1430,7 @@ format_p_values <- function(dat, p.style, digits.p, emph.p, p.threshold) {
     return(dat)
   }
 
-  dat <- dat %>%
+  dat <- dat |>
     dplyr::mutate(
     p.stars = get_p_stars(.data$p.value, p.threshold),
     p.sig = .data$p.value < .05

---FILE: R/tidiers.R---
@@ -154,11 +154,11 @@ tidy_stan_model <- function(model, ci.lvl, tf, type, bpe, show.zeroinf, facets,
 
   # bind columns, so we have inner and outer hdi interval
 
-  dat <- d2 %>%
-    dplyr::select(.data$CI_low, .data$CI_high) %>%
-    sjmisc::var_rename(CI_low = ""conf.low50"", CI_high = ""conf.high50"") %>%
-    sjmisc::add_columns(d1) %>%
-    sjmisc::var_rename(CI_low = ""conf.low"", CI_high = ""conf.high"", Parameter = ""term"") %>%
+  dat <- d2 |>
+    dplyr::select(.data$CI_low, .data$CI_high) |>
+    sjmisc::var_rename(CI_low = ""conf.low50"", CI_high = ""conf.high50"") |>
+    sjmisc::add_columns(d1) |>
+    sjmisc::var_rename(CI_low = ""conf.low"", CI_high = ""conf.high"", Parameter = ""term"") |>
     dplyr::select(-.data$CI, -.data$Effects, -.data$Component)
 
   # for brmsfit models, we need to remove some columns here to
@@ -209,7 +209,7 @@ tidy_stan_model <- function(model, ci.lvl, tf, type, bpe, show.zeroinf, facets,
     estimate = est,
     p.value = 0,
     std.error = purrr::map_dbl(mod.dat, stats::mad)
-  ) %>%
+  ) |>
     dplyr::inner_join(
       dat,
       by = ""term""

---FILE: R/utils.R---
@@ -282,8 +282,8 @@ parse_terms <- function(x) {
   # see if we have multiple values, split at comma
   tmp <- sjmisc::trim(strsplit(tmp, "","", fixed = TRUE))
 
-  parsed.terms <- seq_len(length(tmp)) %>%
-    purrr::map(~ sprintf(""%s%s"", vars.names[.x], tmp[[.x]])) %>%
+  parsed.terms <- seq_len(length(tmp)) |>
+    purrr::map(~ sprintf(""%s%s"", vars.names[.x], tmp[[.x]])) |>
     purrr::flatten_chr()
 
   c(x[-vars.pos], parsed.terms)
@@ -373,8 +373,8 @@ tidy_label <- function(labs, sep = ""."") {
   duped.val <- names(which(table(labs) > 1))
 
   # find position of duplicated labels
-  dupes <- duped.val %>%
-    purrr::map(~which(labs == .x)) %>%
+  dupes <- duped.val |>
+    purrr::map(~which(labs == .x)) |>
     purrr::as_vector(.type = ""double"")
 
   # prefix labels with value

---FILE: man/plot_frq.Rd---
@@ -234,8 +234,8 @@ plot_frq(efc$e17age, type = ""box"")
 
 if (require(""dplyr"")) {
   # histogram, pipe-workflow
-  efc \%>\%
-    dplyr::select(e17age, c160age) \%>\%
+  efc |>
+    dplyr::select(e17age, c160age) |>
     plot_frq(type = ""hist"", show.mean = TRUE)
 
   # bar plot(s)
@@ -244,9 +244,9 @@ if (require(""dplyr"")) {
 
 if (require(""dplyr"") && require(""gridExtra"")) {
   # grouped data frame, all panels in one plot
-  efc \%>\%
-    group_by(e42dep) \%>\%
-    plot_frq(c161sex) \%>\%
+  efc |>
+    group_by(e42dep) |>
+    plot_frq(c161sex) |>
     plot_grid()
 }
 

---FILE: man/plot_grid.Rd---
@@ -41,13 +41,13 @@ if (require(""dplyr"") && require(""gridExtra"")) {
   )
 
   # plot marginal effects for each predictor, each as single plot
-  p1 <- ggpredict(fit, ""c12hour"") \%>\%
+  p1 <- ggpredict(fit, ""c12hour"") |>
     plot(show_y_title = FALSE, show_title = FALSE)
-  p2 <- ggpredict(fit, ""e17age"") \%>\%
+  p2 <- ggpredict(fit, ""e17age"") |>
     plot(show_y_title = FALSE, show_title = FALSE)
-  p3 <- ggpredict(fit, ""e42dep"") \%>\%
+  p3 <- ggpredict(fit, ""e42dep"") |>
     plot(show_y_title = FALSE, show_title = FALSE)
-  p4 <- ggpredict(fit, ""neg_c_7"") \%>\%
+  p4 <- ggpredict(fit, ""neg_c_7"") |>
     plot(show_y_title = FALSE, show_title = FALSE)
 
   # plot grid

---FILE: man/plot_likert.Rd---
@@ -239,7 +239,7 @@ six_cat_example = data.frame(
 
 \dontrun{
 six_cat_example <-
-  six_cat_example \%>\%
+  six_cat_example |>
   dplyr::mutate_all(~ordered(.,labels = c(""+++"",""++"",""+"",""-"",""--"",""---"")))
 
 # Old default

---FILE: man/plot_stackfrq.Rd---
@@ -131,9 +131,9 @@ plot_stackfrq(efc[, start:end])
 
 # works on grouped data frames as well
 library(dplyr)
-efc \%>\%
-  group_by(c161sex) \%>\%
-  select(start:end) \%>\%
+efc |>
+  group_by(c161sex) |>
+  select(start:end) |>
   plot_stackfrq()
 
 }

---FILE: man/sjplot.Rd---
@@ -65,17 +65,17 @@ library(dplyr)
 data(efc)
 
 # Grouped frequencies
-efc \%>\% sjplot(e42dep, c172code, fun = ""grpfrq"")
+efc |> sjplot(e42dep, c172code, fun = ""grpfrq"")
 
 # Grouped frequencies, as box plots
-efc \%>\% sjplot(e17age, c172code, fun = ""grpfrq"",
+efc |> sjplot(e17age, c172code, fun = ""grpfrq"",
                type = ""box"", geom.colors = ""Set1"")
 
 \dontrun{
 # table output of grouped data frame
-efc \%>\%
-  group_by(e16sex, c172code) \%>\%
-  select(e42dep, n4pstu, e16sex, c172code) \%>\%
-  sjtab(fun = ""xtab"", use.viewer = FALSE) # open all tables in browser}
-
+efc |>
+  group_by(e16sex, c172code) |>
+  select(e42dep, n4pstu, e16sex, c172code) |>
+  sjtab(fun = ""xtab"", use.viewer = FALSE) # open all tables in browser
+}
 }

---FILE: vignettes/plot_likert_scales.Rmd---
@@ -76,7 +76,7 @@ six_cat_example = data.frame(
 )
 
 six_cat_example <-
-  six_cat_example %>%
+  six_cat_example |>
   dplyr::mutate_all( ~ ordered(., labels = c(""+++"", ""++"", ""+"", ""-"", ""--"", ""---"")))
 
 # Old default"
strengejacke,sjPlot,7cc25f83709b1bdd03bea2a82904dfaa86704af4,Daniel,mail@danielluedecke.de,2025-07-01T10:29:17Z,Daniel,mail@danielluedecke.de,2025-07-01T10:29:17Z,fix,R/plot_diag_linear.R;R/plot_frq.R;R/plot_gpt.R;R/plot_kfold_cv.R;R/plot_likert.R;R/plot_model.R;R/plot_models.R;R/plot_point_estimates.R;R/sjPlotAnova.R;R/sjplot_themes.R;R/utils.R;man/plot_model.Rd;vignettes/custplot.Rmd,True,True,True,False,203,113,316,"---FILE: R/plot_diag_linear.R---
@@ -180,7 +180,7 @@ diag_reqq <- function(model, dot.size) {
       ggplot2::labs(x = ""Standard normal quantiles"", y = ""Random effect quantiles"") +
       geom_intercept_line2(0, NULL) +
       ggplot2::stat_smooth(method = ""lm"", alpha = alpha) +
-      geom_errorbar(
+      ggplot2::geom_errorbar(
         ggplot2::aes_string(ymin = ""conf.low"", ymax = ""conf.high""),
         width = 0,
         colour = ""black""
@@ -233,8 +233,8 @@ diag_vif <- function(fit) {
 
     vifplot <- ggplot2::ggplot(mydat, ggplot2::aes_string(x = ""vars"", y = ""vif"")) +
       ggplot2::geom_bar(stat = ""identity"", width = 0.7, fill = ""#80acc8"") +
-      geom_hline(yintercept = 5, linetype = 2, colour = ""darkgreen"", alpha = 0.7) +
-      geom_hline(yintercept = 10, linetype = 2, colour = ""darkred"", alpha = 0.7) +
+      ggplot2::geom_hline(yintercept = 5, linetype = 2, colour = ""darkgreen"", alpha = 0.7) +
+      ggplot2::geom_hline(yintercept = 10, linetype = 2, colour = ""darkred"", alpha = 0.7) +
       ggplot2::annotate(""text"", x = 1, y = 4.7, label = ""good"", size = 4, colour = ""darkgreen"") +
       ggplot2::annotate(""text"", x = 1, y = 9.7, label = ""tolerable"", size = 4, colour = ""darkred"") +
       ggplot2::labs(title = ""Variance Inflation Factors (multicollinearity)"", x = NULL, y = NULL) +

---FILE: R/plot_frq.R---
@@ -555,7 +555,7 @@ plot_frq_helper <- function(
       ebcol <- ifelse(type == ""dot"", geom.colors, errorbar.color)
       # print confidence intervalls (error bars)
       baseplot <- baseplot +
-        geom_errorbar(ggplot2::aes_string(ymin = ""lower.ci"", ymax = ""upper.ci""), colour = ebcol, width = 0)
+        ggplot2::geom_errorbar(ggplot2::aes_string(ymin = ""lower.ci"", ymax = ""upper.ci""), colour = ebcol, width = 0)
     }
 
     # check whether coordinates should be flipped, i.e.

---FILE: R/plot_gpt.R---
@@ -314,7 +314,7 @@ gpt_helper <- function(
     ggplot2::geom_point(size = geom.size, fill = shape.fill.color) +
     ggplot2::scale_y_continuous(labels = scales::percent, breaks = gridbreaks, limits = axis.lim) +
     ggplot2::scale_x_discrete(labels = rev(axis.labels)) +
-    scale_shape_manual(name = legend.title, labels = legend.labels, values = shapes[1:pal.len]) +
+    ggplot2::scale_shape_manual(name = legend.title, labels = legend.labels, values = shapes[1:pal.len]) +
     ggplot2::scale_colour_manual(name = legend.title, labels = legend.labels, values = geom.colors) +
     ggplot2::labs(x = axisTitle.x, y = axisTitle.y, title = title) +
     ggplot2::coord_flip()

---FILE: R/plot_kfold_cv.R---
@@ -52,18 +52,21 @@ plot_kfold_cv <- function(data, formula, k = 5, fit) {
   # check if a formula was passed as argument...
   if (!missing(formula)) {
     # make sure we have a formula
-    if (!inherits(formula, ""formula"")) formula <- stats::as.formula(formula)
+    if (!inherits(formula, ""formula"")) {
+      formula <- stats::as.formula(formula)
+    }
     # reset fam
     fam <- NULL
   } else if (!missing(fit)) {
     # ... or a fitted model
     formula <- stats::formula(fit)
 
     # get model family for glm
-    if (inherits(fit, ""glm""))
+    if (inherits(fit, ""glm"")) {
       fam <- stats::family(fit)
-    else
+    } else {
       fam <- NULL
+    }
   } else {
     stop(""Either `formula` or `fit` must be supplied."", call. = FALSE)
   }
@@ -130,11 +133,11 @@ plot_kfold_cv <- function(data, formula, k = 5, fit) {
 
   # plot response against residuals, to see where our model over- or
   # underestimates the outcome
-  p <- ggplot2::ggplot(data = res, ggplot2::aes_string(x = "".response"", y = ""residuals"")) +
-    geom_hline(yintercept = 0) +
+  p <- ggplot2::ggplot(data = res, ggplot2::aes(x = .data$.response, y = .data$residuals)) +
+    ggplot2::geom_hline(yintercept = 0) +
     ggplot2::geom_point() +
     ggplot2::stat_smooth(method = ""loess"") +
-    theme_minimal() +
+    ggplot2::theme_minimal() +
     ggplot2::labs(y = ""Residuals"", x = resp.name)
 
   # plot it

---FILE: R/plot_likert.R---
@@ -924,7 +924,7 @@ plot_likert <- function(
     # for neutral category work...
 
     scale_x_continuous(breaks = seq_len(ncol(freq.df)), labels = axis.labels) +
-    geom_hline(yintercept = 0, color = intercept.line.color)
+    ggplot2::geom_hline(yintercept = 0, color = intercept.line.color)
 
   # check wether percentage scale (y-axis) should be reversed
 

---FILE: R/plot_model.R---
@@ -316,7 +316,7 @@
 #'       removes the inner probability regions.
 #'     }
 #'     \item{\code{width}, \code{alpha}, and \code{scale}}{Passed
-#'       down to \code{geom_errorbar()} or \code{geom_density_ridges()}, for
+#'       down to \code{ggplot2::geom_errorbar()} or \code{geom_density_ridges()}, for
 #'       forest or diagnostic plots.
 #'     }
 #'     \item{\code{width}, \code{alpha}, \code{dot.alpha}, \code{dodge} and \code{log.y}}{Passed

---FILE: R/plot_models.R---
@@ -291,15 +291,15 @@ plot_models <- function(...,
   # set up base plot
 
   if (p.shape)
-    p <- ggplot2::ggplot(ff, ggplot2::aes_string(x = ""term"", y = ""estimate"", colour = ""group"", shape = ""p.stars""))
+    p <- ggplot2::ggplot(ff, ggplot2::aes(x = .data$term, y = .data$estimate, colour = .data$group, shape = .data$p.stars))
   else
-    p <- ggplot2::ggplot(ff, ggplot2::aes_string(x = ""term"", y = ""estimate"", colour = ""group""))
+    p <- ggplot2::ggplot(ff, ggplot2::aes(x = .data$term, y = .data$estimate, colour = .data$group))
 
 
   p <- p +
     layer_vertical_line +
     ggplot2::geom_point(position = ggplot2::position_dodge(spacing), size = dot.size) +
-    geom_errorbar(
+    ggplot2::geom_errorbar(
       ggplot2::aes_string(ymin = ""conf.low"", ymax = ""conf.high""),
       position = ggplot2::position_dodge(spacing),
       width = 0,
@@ -311,7 +311,7 @@ plot_models <- function(...,
 
   # show different shapes depending on p-value
 
-  if (p.shape) p <- p + scale_shape_manual(values = c(1, 16, 17, 15))
+  if (p.shape) p <- p + ggplot2::scale_shape_manual(values = c(1, 16, 17, 15))
 
 
   # add value labels

---FILE: R/plot_point_estimates.R---
@@ -1,24 +1,25 @@
-plot_point_estimates <- function(model,
-                                 dat,
-                                 tf,
-                                 title,
-                                 axis.labels,
-                                 axis.title,
-                                 axis.lim,
-                                 grid.breaks,
-                                 show.values,
-                                 value.offset,
-                                 geom.size,
-                                 line.size,
-                                 geom.colors,
-                                 bpe.style,
-                                 bpe.color,
-                                 vline.color,
-                                 value.size,
-                                 facets,
-                                 ci.style,
-                                 ...) {
-
+plot_point_estimates <- function(
+  model,
+  dat,
+  tf,
+  title,
+  axis.labels,
+  axis.title,
+  axis.lim,
+  grid.breaks,
+  show.values,
+  value.offset,
+  geom.size,
+  line.size,
+  geom.colors,
+  bpe.style,
+  bpe.color,
+  vline.color,
+  value.size,
+  facets,
+  ci.style,
+  ...
+) {
   # some defaults...
 
   size.inner <- .07
@@ -28,24 +29,33 @@ plot_point_estimates <- function(model,
   # check additional arguments, for stan-geoms
 
   add.args <- lapply(match.call(expand.dots = FALSE)$`...`, function(x) x)
-  if (""size.inner"" %in% names(add.args)) size.inner <- eval(add.args[[""size.inner""]])
-  if (""width"" %in% names(add.args)) width <- eval(add.args[[""width""]])
-  if (""spacing"" %in% names(add.args)) spacing <- eval(add.args[[""spacing""]])
-
+  if (""size.inner"" %in% names(add.args)) {
+    size.inner <- eval(add.args[[""size.inner""]])
+  }
+  if (""width"" %in% names(add.args)) {
+    width <- eval(add.args[[""width""]])
+  }
+  if (""spacing"" %in% names(add.args)) {
+    spacing <- eval(add.args[[""spacing""]])
+  }
 
   # need some additional data, for stan-geoms
 
   dat$xpos <- sjlabelled::as_numeric(dat$term, start.at = 1)
   dat$xmin <- dat$xpos - (geom.size * size.inner)
   dat$xmax <- dat$xpos + (geom.size * size.inner)
 
-
   # set default for empty titles/labels
 
-  if (sjmisc::is_empty(title)) title <- NULL
-  if (sjmisc::is_empty(axis.labels)) axis.labels <- attributes(dat)$pretty_names
-  if (sjmisc::is_empty(axis.title)) axis.title <- NULL
-
+  if (sjmisc::is_empty(title)) {
+    title <- NULL
+  }
+  if (sjmisc::is_empty(axis.labels)) {
+    axis.labels <- attributes(dat)$pretty_names
+  }
+  if (sjmisc::is_empty(axis.title)) {
+    axis.title <- NULL
+  }
 
   # if we have non-estimable coefficients (i.e. missings)
   # remove them here
@@ -67,7 +77,6 @@ plot_point_estimates <- function(model,
     max.est = max(dat$estimate)
   )
 
-
   # based on current ggplot theme, highlights vertical default line
 
   yintercept = dplyr::if_else(isTRUE(tf == ""exp""), 1, 0)
@@ -82,13 +91,29 @@ plot_point_estimates <- function(model,
 
   # basis aes mapping
 
-  if (multinomial)
-    p <- ggplot2::ggplot(dat, ggplot2::aes_string(x = ""term"", y = ""estimate"", colour = ""response.level"", fill = ""response.level""))
-  else
-    p <- ggplot2::ggplot(dat, ggplot2::aes_string(x = ""term"", y = ""estimate"", colour = ""group"", fill = ""group""))
+  if (multinomial) {
+    p <- ggplot2::ggplot(
+      dat,
+      ggplot2::aes(
+        x = .data$term,
+        y = .data$estimate,
+        colour = .data$response.level,
+        fill = .data$response.level
+      )
+    )
+  } else {
+    p <- ggplot2::ggplot(
+      dat,
+      ggplot2::aes(
+        x = .data$term,
+        y = .data$estimate,
+        colour = .data$group,
+        fill = .data$group
+      )
+    )
+  }
 
   if (is.stan(model)) {
-
     if (ci.style == ""whisker"") {
       hdi_alpha <- 1
       dot.fac <- 1.2
@@ -100,53 +125,113 @@ plot_point_estimates <- function(model,
     # special setup for rstan-models
     p <- p + layer_vertical_line
 
-    if (ci.style == ""whisker"")
-      p <- p + geom_errorbar(ggplot2::aes_string(ymin = ""conf.low"", ymax = ""conf.high""), size = line.size, width = width)
-    else
-      p <- p + geom_rect(ggplot2::aes_string(ymin = ""conf.low"", ymax = ""conf.high"", xmin = ""xmin"", xmax = ""xmax""), alpha = hdi_alpha, colour = ""white"", size = .5)
-
+    if (ci.style == ""whisker"") {
+      p <- p +
+        ggplot2::geom_errorbar(
+          ggplot2::aes_string(ymin = ""conf.low"", ymax = ""conf.high""),
+          size = line.size,
+          width = width
+        )
+    } else {
+      p <- p +
+        geom_rect(
+          ggplot2::aes_string(
+            ymin = ""conf.low"",
+            ymax = ""conf.high"",
+            xmin = ""xmin"",
+            xmax = ""xmax""
+          ),
+          alpha = hdi_alpha,
+          colour = ""white"",
+          size = .5
+        )
+    }
 
     # only add inner region if requested
     if (size.inner > 0) {
       p <- p +
-        geom_rect(ggplot2::aes_string(ymin = ""conf.low50"", ymax = ""conf.high50"", xmin = ""xmin"", xmax = ""xmax""), alpha = hdi_alpha, colour = ""white"", size = .5)
+        geom_rect(
+          ggplot2::aes_string(
+            ymin = ""conf.low50"",
+            ymax = ""conf.high50"",
+            xmin = ""xmin"",
+            xmax = ""xmax""
+          ),
+          alpha = hdi_alpha,
+          colour = ""white"",
+          size = .5
+        )
     }
 
     # define style for Bayesian point estimate
     if (bpe.style == ""line"") {
       if (is.null(bpe.color)) {
         p <- p +
-          ggplot2::geom_segment(ggplot2::aes_string(x = ""xmin"", xend = ""xmax"", y = ""estimate"", yend = ""estimate""), size = geom.size * .9)
+          ggplot2::geom_segment(
+            ggplot2::aes_string(
+              x = ""xmin"",
+              xend = ""xmax"",
+              y = ""estimate"",
+              yend = ""estimate""
+            ),
+            size = geom.size * .9
+          )
       } else {
         p <- p +
-          ggplot2::geom_segment(ggplot2::aes_string(x = ""xmin"", xend = ""xmax"", y = ""estimate"", yend = ""estimate""), colour = bpe.color, size = geom.size * .9)
+          ggplot2::geom_segment(
+            ggplot2::aes_string(
+              x = ""xmin"",
+              xend = ""xmax"",
+              y = ""estimate"",
+              yend = ""estimate""
+            ),
+            colour = bpe.color,
+            size = geom.size * .9
+          )
       }
     } else if (is.null(bpe.color)) {
-        p <- p +
-          ggplot2::geom_point(ggplot2::aes_string(y = ""estimate""), fill = ""white"", size = geom.size * dot.fac)
+      p <- p +
+        ggplot2::geom_point(
+          ggplot2::aes_string(y = ""estimate""),
+          fill = ""white"",
+          size = geom.size * dot.fac
+        )
     } else {
       p <- p +
-        ggplot2::geom_point(ggplot2::aes_string(y = ""estimate""), fill = ""white"", colour = bpe.color, size = geom.size * dot.fac)
+        ggplot2::geom_point(
+          ggplot2::aes_string(y = ""estimate""),
+          fill = ""white"",
+          colour = bpe.color,
+          size = geom.size * dot.fac
+        )
     }
-
   } else {
-
     # setup base plot
     p <- p + layer_vertical_line
 
     if (multinomial) {
       p <- p +
-        ggplot2::geom_point(size = geom.size, position = ggplot2::position_dodge(width = spacing)) +
-        geom_errorbar(ggplot2::aes_string(ymin = ""conf.low"", ymax = ""conf.high""), position = ggplot2::position_dodge(width = spacing), width = width, size = line.size)
+        ggplot2::geom_point(
+          size = geom.size,
+          position = ggplot2::position_dodge(width = spacing)
+        ) +
+        ggplot2::geom_errorbar(
+          ggplot2::aes_string(ymin = ""conf.low"", ymax = ""conf.high""),
+          position = ggplot2::position_dodge(width = spacing),
+          width = width,
+          size = line.size
+        )
     } else {
       p <- p +
         ggplot2::geom_point(size = geom.size) +
-        geom_errorbar(ggplot2::aes_string(ymin = ""conf.low"", ymax = ""conf.high""), width = width, size = line.size)
+        ggplot2::geom_errorbar(
+          ggplot2::aes_string(ymin = ""conf.low"", ymax = ""conf.high""),
+          width = width,
+          size = line.size
+        )
     }
-
   }
 
-
   # set up base aes, either with or w/o groups
 
   p <- p + ggplot2::coord_flip()
@@ -161,86 +246,88 @@ plot_point_estimates <- function(model,
     p <- p + ggplot2::guides(colour = ""none"", fill = ""none"")
   }
 
-
   # add value labels
 
-  if (show.values) p <- p +
+  if (show.values) {
+    p <- p +
       ggplot2::geom_text(
         ggplot2::aes_string(label = ""p.label""),
         nudge_x = value.offset,
         show.legend = FALSE,
         size = value.size
       )
-
+  }
 
   # set axis labels
 
-  if (!is.null(axis.labels))
+  if (!is.null(axis.labels)) {
     p <- p + ggplot2::scale_x_discrete(labels = axis.labels)
-
+  }
 
   # we need transformed scale for exponentiated estimates
 
-  has_zeroinf <- (obj_has_name(dat, ""wrap.facet"") && dplyr::n_distinct(dat$wrap.facet, na.rm = TRUE) > 1)
+  has_zeroinf <- (obj_has_name(dat, ""wrap.facet"") &&
+    dplyr::n_distinct(dat$wrap.facet, na.rm = TRUE) > 1)
 
   if (isTRUE(tf == ""exp"")) {
-
     if (has_zeroinf) {
       p <- p + ggplot2::scale_y_continuous(trans = ""log10"")
     } else {
-      p <- p + ggplot2::scale_y_continuous(
-        trans = ""log10"",
-        limits = axis.scaling$axis.lim,
-        breaks = axis.scaling$ticks,
-        labels = prettyNum
-      )
+      p <- p +
+        ggplot2::scale_y_continuous(
+          trans = ""log10"",
+          limits = axis.scaling$axis.lim,
+          breaks = axis.scaling$ticks,
+          labels = prettyNum
+        )
     }
-
   } else {
-
-    if (has_zeroinf) {
-
-    } else {
-      p <- p + ggplot2::scale_y_continuous(
-        limits = axis.scaling$axis.lim,
-        breaks = axis.scaling$ticks,
-        labels = axis.scaling$ticks
-      )
+    if (has_zeroinf) {} else {
+      p <- p +
+        ggplot2::scale_y_continuous(
+          limits = axis.scaling$axis.lim,
+          breaks = axis.scaling$ticks,
+          labels = axis.scaling$ticks
+        )
     }
-
   }
 
-
   # set colors
 
   p <- p +
     ggplot2::scale_colour_manual(values = col_check2(geom.colors, col.len)) +
     ggplot2::scale_fill_manual(values = col_check2(geom.colors, col.len))
 
-
   # facets?
 
-  if (obj_has_name(dat, ""facet"") && dplyr::n_distinct(dat$facet, na.rm = TRUE) > 1)
+  if (
+    obj_has_name(dat, ""facet"") && dplyr::n_distinct(dat$facet, na.rm = TRUE) > 1
+  ) {
     p <- p +
       ggplot2::facet_grid(~facet)
-  else if (has_zeroinf)
+  } else if (has_zeroinf) {
     p <- p +
       ggplot2::facet_wrap(~wrap.facet, ncol = 1, scales = ""free"")
-
+  }
 
   # set axis and plot titles
 
-  if (length(axis.title) > 1) axis.title <- axis.title[1]
+  if (length(axis.title) > 1) {
+    axis.title <- axis.title[1]
+  }
 
   p <-
-    p + ggplot2::labs(
+    p +
+    ggplot2::labs(
       x = NULL,
       y = axis.title,
       title = title
     )
 
   # for multinomial models, set response variable name as name for legend
-  if (multinomial) p <- p + ggplot2::labs(colour = insight::find_response(model))
+  if (multinomial) {
+    p <- p + ggplot2::labs(colour = insight::find_response(model))
+  }
 
   p
 }

---FILE: R/sjPlotAnova.R---
@@ -248,7 +248,7 @@ sjp.aov1 <- function(var.dep,
     # print point
     ggplot2::geom_point(size = geom.size, colour = df$geocol) +
     # and error bar
-    geom_errorbar(ggplot2::aes(ymin = .data$lower, ymax = .data$upper), colour = df$geocol, width = 0) +
+    ggplot2::geom_errorbar(ggplot2::aes(ymin = .data$lower, ymax = .data$upper), colour = df$geocol, width = 0) +
     # Print p-values. With vertical adjustment, so
     # they don't overlap with the errorbars
     ggplot2::geom_text(ggplot2::aes(label = .data$pv, y = .data$means), nudge_x = y.offset, show.legend = FALSE) +

---FILE: R/sjplot_themes.R---
@@ -85,7 +85,7 @@
 #' @rdname sjPlot-themes
 #' @export
 theme_sjplot <- function(base_size = 12, base_family = """") {
-  (theme_minimal(base_size = base_size, base_family = base_family) +
+  (ggplot2::theme_minimal(base_size = base_size, base_family = base_family) +
      ggplot2::theme(
        axis.line.x      = element_line(colour = ""grey80""),
        axis.line.y      = element_line(colour = ""grey80""),
@@ -102,7 +102,7 @@ theme_sjplot <- function(base_size = 12, base_family = """") {
 #' @rdname sjPlot-themes
 #' @export
 theme_sjplot2 <- function(base_size = 12, base_family = """") {
-  (theme_minimal(base_size = base_size, base_family = base_family) +
+  (ggplot2::theme_minimal(base_size = base_size, base_family = base_family) +
      ggplot2::theme(
        axis.line.x      = element_line(colour = ""grey50""),
        axis.line.y      = element_line(colour = ""grey50""),
@@ -119,7 +119,7 @@ theme_sjplot2 <- function(base_size = 12, base_family = """") {
 #' @rdname sjPlot-themes
 #' @export
 theme_blank <- function(base_size = 12, base_family = """") {
-  (theme_minimal(base_size = base_size, base_family = base_family) +
+  (ggplot2::theme_minimal(base_size = base_size, base_family = base_family) +
      ggplot2::theme(
        axis.line.x      = element_line(colour = ""white""),
        axis.line.y      = element_line(colour = ""white""),
@@ -134,7 +134,7 @@ theme_blank <- function(base_size = 12, base_family = """") {
 #' @rdname sjPlot-themes
 #' @export
 theme_538 <- function(base_size = 12, base_family = """") {
-  (theme_minimal(base_size = base_size, base_family = base_family) +
+  (ggplot2::theme_minimal(base_size = base_size, base_family = base_family) +
      ggplot2::theme(
        axis.line.x        = element_line(colour = ""#F0F0F0""),
        axis.line.y        = element_line(colour = ""#F0F0F0""),
@@ -370,7 +370,7 @@ show_sjplot_pals <- function() {
     ggplot2::scale_y_continuous(breaks = NULL, labels = NULL) +
     ggplot2::guides(fill = ""none"") +
     ggplot2::coord_flip() +
-    theme_minimal() +
+    ggplot2::theme_minimal() +
     ggplot2::labs(x = NULL, y = NULL) +
     ggplot2::facet_wrap(~group, ncol = 1, scales = ""free"")
 }

---FILE: R/utils.R---
@@ -203,7 +203,7 @@ geom_intercept_line <- function(yintercept, axis.scaling, vline.color) {
     minor_size <- nulldef(t$panel.grid.minor$size, .125)
     major_size <- nulldef(t$panel.grid.major$size, minor_size * 1.5)
     size <- major_size * 1.5
-    geom_hline(yintercept = yintercept, color = color, size = size)
+    ggplot2::geom_hline(yintercept = yintercept, color = color, size = size)
   } else {
     NULL
   }
@@ -217,7 +217,7 @@ geom_intercept_line2 <- function(yintercept, vline.color) {
   minor_size <- nulldef(t$panel.grid.minor$size, .125)
   major_size <- nulldef(t$panel.grid.major$size, minor_size * 1.5)
   size <- major_size * 1.5
-  geom_hline(yintercept = yintercept, color = color, size = size)
+  ggplot2::geom_hline(yintercept = yintercept, color = color, size = size)
 }
 
 

---FILE: man/plot_model.Rd---
@@ -443,7 +443,7 @@ of supported arguments and their description in detail.
     removes the inner probability regions.
   }
   \item{\code{width}, \code{alpha}, and \code{scale}}{Passed
-    down to \code{geom_errorbar()} or \code{geom_density_ridges()}, for
+    down to \code{ggplot2::geom_errorbar()} or \code{geom_density_ridges()}, for
     forest or diagnostic plots.
   }
   \item{\code{width}, \code{alpha}, \code{dot.alpha}, \code{dodge} and \code{log.y}}{Passed

---FILE: vignettes/custplot.Rmd---
@@ -122,7 +122,7 @@ plot_grpfrq(efc$e42dep, efc$e16sex, expand.grid = TRUE)
 
 ## Theme options
 
-You can use any pre-defined theme from ggplot, like `theme_bw()`, `theme_classic()` or `theme_minimal()` as default theme.
+You can use any pre-defined theme from ggplot, like `theme_bw()`, `theme_classic()` or `ggplot2::theme_minimal()` as default theme.
 
 ```{r}
 sjPlot::set_theme(base = theme_light())"
strengejacke,sjPlot,9df3be41cb8bd894de778aee709a6264a9032542,Daniel,mail@danielluedecke.de,2025-07-01T10:14:10Z,Daniel,mail@danielluedecke.de,2025-07-01T10:14:10Z,fix,R/plot_grpfrq.R;R/plot_models.R;R/plot_point_estimates.R;R/plot_xtab.R,False,True,True,False,13,13,26,"---FILE: R/plot_grpfrq.R---
@@ -627,7 +627,7 @@ plot_grpfrq <- function(var.cnt,
     # position_dodge displays dots in a dodged position so we avoid overlay here. This may lead
     # to a more difficult distinction of group belongings, since the dots are ""horizontally spread""
     # over the digram. For a better overview, we can add a ""PlotAnnotation"" (see ""emph.dots) here.
-    geob <- ggplot2::geom_point(position = position_dodge(posdodge),size = geom.size, shape = 16)
+    geob <- ggplot2::geom_point(position = ggplot2::position_dodge(posdodge),size = geom.size, shape = 16)
 
     # create shaded rectangle, so we know which dots belong to the same category
     if (emph.dots) {
@@ -643,7 +643,7 @@ plot_grpfrq <- function(var.cnt,
     }
   } else if (type == ""bar"") {
     if (bar.pos == ""dodge"")
-      geob <- geom_bar(stat = ""identity"", width = geom.size, position = position_dodge(posdodge))
+      geob <- geom_bar(stat = ""identity"", width = geom.size, position = ggplot2::position_dodge(posdodge))
     else
       geob <- geom_bar(stat = ""identity"", width = geom.size, position = position_stack(reverse = TRUE))
   } else if (type == ""line"") {
@@ -667,7 +667,7 @@ plot_grpfrq <- function(var.cnt,
     if (facet.grid)
       text.pos <- ""identity""
     else
-      text.pos <- position_dodge(posdodge)
+      text.pos <- ggplot2::position_dodge(posdodge)
 
     # if we have stacked bars, we need to apply
     # this stacked y-position to the labels as well

---FILE: R/plot_models.R---
@@ -298,15 +298,15 @@ plot_models <- function(...,
 
   p <- p +
     layer_vertical_line +
-    ggplot2::geom_point(position = position_dodge(spacing), size = dot.size) +
+    ggplot2::geom_point(position = ggplot2::position_dodge(spacing), size = dot.size) +
     geom_errorbar(
       ggplot2::aes_string(ymin = ""conf.low"", ymax = ""conf.high""),
-      position = position_dodge(spacing),
+      position = ggplot2::position_dodge(spacing),
       width = 0,
       size = line.size
     ) +
     coord_flip() +
-    ggplot2::guides(colour = guide_legend(reverse = TRUE))
+    ggplot2::guides(colour = ggplot2::guide_legend(reverse = TRUE))
 
 
   # show different shapes depending on p-value
@@ -319,7 +319,7 @@ plot_models <- function(...,
   if (show.values) p <- p +
     geom_text(
       ggplot2::aes_string(label = ""p.label""),
-      position = position_dodge(spacing),
+      position = ggplot2::position_dodge(spacing),
       vjust = spacing * -1.5,
       hjust = -.1,
       show.legend = FALSE,

---FILE: R/plot_point_estimates.R---
@@ -136,8 +136,8 @@ plot_point_estimates <- function(model,
 
     if (multinomial) {
       p <- p +
-        ggplot2::geom_point(size = geom.size, position = position_dodge(width = spacing)) +
-        geom_errorbar(ggplot2::aes_string(ymin = ""conf.low"", ymax = ""conf.high""), position = position_dodge(width = spacing), width = width, size = line.size)
+        ggplot2::geom_point(size = geom.size, position = ggplot2::position_dodge(width = spacing)) +
+        geom_errorbar(ggplot2::aes_string(ymin = ""conf.low"", ymax = ""conf.high""), position = ggplot2::position_dodge(width = spacing), width = width, size = line.size)
     } else {
       p <- p +
         ggplot2::geom_point(size = geom.size) +

---FILE: R/plot_xtab.R---
@@ -361,15 +361,15 @@ plot_xtab <- function(x,
     if (bar.pos == ""dodge"") {
       if (show.prc && show.n) {
         ggvaluelabels <- geom_text(ggplot2::aes(y = .data$ypos + y_offset, label = sprintf(""%.01f%%%s(n=%i)"", 100 * .data$prc, .data$line.break, .data$n)),
-                                   position = position_dodge(posdodge),
+                                   position = ggplot2::position_dodge(posdodge),
                                    vjust = vjust, hjust = hjust)
       } else if (show.prc) {
         ggvaluelabels <- geom_text(ggplot2::aes(y = .data$ypos + y_offset, label = sprintf(""%.01f%%"", 100 * .data$prc)),
-                                   position = position_dodge(posdodge),
+                                   position = ggplot2::position_dodge(posdodge),
                                    vjust = vjust, hjust = hjust)
       } else if (show.n) {
         ggvaluelabels <- geom_text(ggplot2::aes(y = .data$ypos + y_offset, label = sprintf(""n=%i"", .data$n)),
-                                   position = position_dodge(posdodge),
+                                   position = ggplot2::position_dodge(posdodge),
                                    vjust = vjust, hjust = hjust)
       }
     } else {
@@ -409,7 +409,7 @@ plot_xtab <- function(x,
   if (type == ""bar"") {
     if (bar.pos == ""dodge"") {
       geob <- geom_bar(stat = ""identity"",
-                       position = position_dodge(posdodge),
+                       position = ggplot2::position_dodge(posdodge),
                        width = geom.size)
     } else {
       geob <- geom_bar(stat = ""identity"","
strengejacke,sjPlot,36bed3c5591042814b33040b778bf09c73a1a547,Daniel,mail@danielluedecke.de,2025-07-01T10:06:55Z,Daniel,mail@danielluedecke.de,2025-07-01T10:06:55Z,fix,DESCRIPTION;NAMESPACE;R/plot_frq.R;R/plot_gpt.R;R/plot_grid.R;R/plot_grpfrq.R;R/plot_kfold_cv.R;R/plot_likert.R;R/plot_models.R;R/plot_scatter.R;R/plot_stackfrq.R;R/plot_xtab.R;R/save_plot.R;R/sjPlotAnova.R;R/sjPlotCorr.R;R/sjPlotDist.R;R/sjPlotPearsonsChi2Test.R;R/sjPlotPolynomials.R;R/sjPlotSetTheme.R;R/sjplot_themes.R;man/plot_xtab.Rd;vignettes/custplot.Rmd,True,True,True,False,73,95,168,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 2.8.17
+Version: 2.9.0
 Authors@R: c(
     person(""Daniel"", ""Ldecke"", email = ""d.luedecke@uke.de"", role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0002-8895-3206"")),
     person(""Alexander"", ""Bartel"", role = ""ctb"", comment = c(ORCID = ""0000-0002-1280-6138"")),

---FILE: NAMESPACE---
@@ -66,7 +66,6 @@ export(theme_blank)
 export(theme_sjplot)
 export(theme_sjplot2)
 export(view_df)
-import(ggplot2)
 importFrom(dplyr,""%>%"")
 importFrom(dplyr,arrange)
 importFrom(dplyr,bind_rows)

---FILE: R/plot_frq.R---
@@ -109,7 +109,6 @@ utils::globalVariables(""density"")
 #'         normal.curve = TRUE, show.sd = TRUE, normal.curve.color = ""blue"",
 #'         normal.curve.size = 3, ylim = c(0,50))
 #' }
-#' @import ggplot2
 #' @importFrom sjmisc group_labels group_var to_value frq
 #' @importFrom sjlabelled set_labels drop_labels
 #' @importFrom stats na.omit sd weighted.mean dnorm

---FILE: R/plot_gpt.R---
@@ -54,7 +54,6 @@ utils::globalVariables(""n"")
 #'   # care levels
 #'   plot_gpt(efc, c172code, e42dep, n4pstu)
 #' }
-#' @import ggplot2
 #' @export
 plot_gpt <- function(
   data,

---FILE: R/plot_grid.R---
@@ -58,7 +58,7 @@ plot_grid <- function(x, margin = c(1, 1, 1, 1), tags = NULL) {
 
   # add margin to each plot, so no axis labels are cropped
   x <- lapply(x, function(pl) {
-    pl + theme(plot.margin = unit(margin, ""cm""))
+    pl + ggplot2::theme(plot.margin = unit(margin, ""cm""))
   })
 
   tags_labels <- NULL

---FILE: R/plot_grpfrq.R---
@@ -163,7 +163,6 @@
 #' # show all categories, even if not in data
 #' plot_grpfrq(efc$c161sex, efc$e42dep, drop.empty = FALSE)
 #'
-#' @import ggplot2
 #' @importFrom rlang .data
 #' @export
 plot_grpfrq <- function(var.cnt,
@@ -869,7 +868,7 @@ plot_grpfrq <- function(var.cnt,
   if (facet.grid) {
     baseplot <- baseplot +
       # set font size for axes.
-      # theme(strip.text = element_text(face = ""bold"", size = rel(1.1))) +
+      # ggplot2::theme(strip.text = element_text(face = ""bold"", size = rel(1.1))) +
       facet_wrap(~group, scales = ""free"")
   }
 

---FILE: R/plot_kfold_cv.R---
@@ -44,7 +44,6 @@
 #' fit <- MASS::glm.nb(tot_sc_e ~ neg_c_7 + c172code, data = efc)
 #' plot_kfold_cv(efc, fit = fit)
 #'
-#' @import ggplot2
 #' @export
 plot_kfold_cv <- function(data, formula, k = 5, fit) {
   # make sure that data is a data frame

---FILE: R/plot_likert.R---
@@ -140,7 +140,6 @@
 #'   group.legend.options = list(nrow = 1)
 #' )}
 #' }
-#' @import ggplot2
 #' @export
 plot_likert <- function(items,
                         groups = NULL,
@@ -214,11 +213,11 @@ plot_likert <- function(items,
     # If there are 2 or more groups, the legend will be plotted according to legend.pos.
     if (length(findex) != 1) {
       if (legend.pos %in% c(""top"", ""both"") && i == 1)
-        .pl <- .pl + theme(legend.position = ""top"") + guides(fill = do.call(guide_legend, group.legend.options))
+        .pl <- .pl + ggplot2::theme(legend.position = ""top"") + guides(fill = do.call(guide_legend, group.legend.options))
       else if (legend.pos %in% c(""bottom"", ""both"") && i == length(findex))
-        .pl <- .pl + theme(legend.position = ""bottom"") + guides(fill = do.call(guide_legend, group.legend.options))
+        .pl <- .pl + ggplot2::theme(legend.position = ""bottom"") + guides(fill = do.call(guide_legend, group.legend.options))
       else if (legend.pos != ""all"")
-        .pl <- .pl + theme(legend.position = ""none"")
+        .pl <- .pl + ggplot2::theme(legend.position = ""none"")
     }
 
     .plot_list[i] <-  list(.pl)

---FILE: R/plot_models.R---
@@ -66,7 +66,6 @@
 #'
 #' plot_models(fit1, fit2, fit3, std.est = ""std2"")
 #' }
-#' @import ggplot2
 #' @importFrom rlang .data
 #' @export
 plot_models <- function(...,

---FILE: R/plot_scatter.R---
@@ -63,7 +63,6 @@
 #'   grid = TRUE
 #' )
 #'
-#' @import ggplot2
 #' @export
 plot_scatter <- function(
   data,

---FILE: R/plot_stackfrq.R---
@@ -45,7 +45,6 @@
 #'   select(start:end) %>%
 #'   plot_stackfrq()
 #'
-#' @import ggplot2
 #' @export
 plot_stackfrq <- function(items,
                          title = NULL,

---FILE: R/plot_xtab.R---
@@ -46,7 +46,7 @@
 #' library(sjmisc)
 #' library(sjlabelled)
 #' data(efc)
-#' set_theme(geom.label.angle = 90)
+#' set_ggplot2::theme(geom.label.angle = 90)
 #' plot_xtab(efc$e42dep, efc$e16sex, vjust = ""center"", hjust = ""bottom"")
 #'
 #' # grouped bars with EUROFAMCARE sample dataset
@@ -74,7 +74,6 @@
 #' plot_xtab(efc$e16sex, efc$e42dep, margin = ""row"",
 #'          bar.pos = ""stack"", coord.flip = TRUE)
 #'
-#' @import ggplot2
 #' @importFrom dplyr group_by mutate arrange filter select summarize
 #' @importFrom scales percent
 #' @importFrom stats na.omit

---FILE: R/save_plot.R---
@@ -26,7 +26,6 @@
 #'         \cr \cr
 #'         For adjusting plot appearance, see also \code{\link{sjPlot-themes}}.
 #'
-#' @import ggplot2
 #' @importFrom grDevices png jpeg tiff dev.off cm svg
 #' @export
 save_plot <- function(filename,
@@ -54,7 +53,7 @@ save_plot <- function(filename,
   # set printable theme, adjust font sizes.
   # this is the most critical point...
 
-  set_theme(
+  set_ggplot2::theme(
     base = theme,
     geom.label.color = label.color,
     axis.title.color = label.color,

---FILE: R/sjPlotAnova.R---
@@ -30,7 +30,6 @@
 #' sjp.aov1(efc$c12hour, efc$e42dep)
 #'
 #'
-#' @import ggplot2
 #' @importFrom sjmisc trim word_wrap to_value
 #' @importFrom stats confint aov summary.lm
 #' @importFrom rlang .data

---FILE: R/sjPlotCorr.R---
@@ -40,7 +40,6 @@
 #'            blue and red colors indicate positive or negative correlations, where
 #'            stronger correlations are darker.
 #'
-#' @import ggplot2
 #' @importFrom tidyr gather
 #' @importFrom scales brewer_pal grey_pal
 #' @importFrom stats cor cor.test na.omit

---FILE: R/sjPlotDist.R---
@@ -37,7 +37,6 @@
 #' # a simple normal distribution
 #' dist_norm(p = 0.2)
 #'
-#' @import ggplot2
 #' @importFrom stats qchisq pchisq dchisq qf pf df qnorm pnorm dnorm qt pt dt
 #' @export
 dist_norm <- function(norm = NULL,
@@ -166,7 +165,6 @@ dist_norm <- function(norm = NULL,
 #' # value 12.59 (p-level < 0.05) is filled as ""significant"".
 #' dist_chisq(p = 0.125, deg.f = 6)
 #'
-#' @import ggplot2
 #' @export
 dist_chisq <- function(chi2 = NULL,
                       deg.f = NULL,
@@ -298,7 +296,6 @@ dist_chisq <- function(chi2 = NULL,
 #' # (F-Value about 1.5).
 #' dist_f(p = 0.2, deg.f1 = 6, deg.f2 = 45)
 #'
-#' @import ggplot2
 #' @export
 dist_f <- function(f = NULL,
                   deg.f1 = NULL,
@@ -425,7 +422,6 @@ dist_f <- function(f = NULL,
 #' # (t-value of about 0.26).
 #' dist_t(p = 0.4, deg.f = 6)
 #'
-#' @import ggplot2
 #' @export
 dist_t <- function(t = NULL,
                   deg.f = NULL,

---FILE: R/sjPlotPearsonsChi2Test.R---
@@ -25,7 +25,6 @@
 #' # plot Chi2-contingency-table
 #' sjp.chi2(mydf, axis.labels = items)
 #'
-#' @import ggplot2
 #' @importFrom grDevices rgb
 #' @importFrom dplyr bind_rows
 #' @export

---FILE: R/sjPlotPolynomials.R---
@@ -91,7 +91,6 @@
 #' # plot marginal effects of polynomial term
 #' plot_model(fit, type = ""pred"", terms = ""e17age"")}
 #'
-#' @import ggplot2
 #' @importFrom scales grey_pal brewer_pal
 #' @importFrom stats lm glm binomial predict poly
 #' @importFrom graphics plot

---FILE: R/sjPlotSetTheme.R---
@@ -145,7 +145,6 @@
 #' )
 #' plot_frq(efc$e42dep)}
 #'
-#' @import ggplot2
 #' @importFrom scales brewer_pal grey_pal
 #' @importFrom dplyr case_when
 #' @export
@@ -350,7 +349,7 @@ set_theme <- function(base = theme_grey(),
       # ----------------------------------------
       # set base elements that are always set
       # ----------------------------------------
-      theme(plot.title = element_text(size = rel(title.size),  colour = title.color, hjust = title.align),
+      ggplot2::theme(plot.title = element_text(size = rel(title.size),  colour = title.color, hjust = title.align),
             axis.text = element_text(angle = axis.angle, size = rel(axis.textsize), colour = axis.textcolor),
             axis.text.x = element_text(angle = axis.angle.x, size = rel(axis.textsize.x), colour = axis.textcolor.x),
             axis.text.y = element_text(angle = axis.angle.y, size = rel(axis.textsize.y), colour = axis.textcolor.y),
@@ -365,28 +364,28 @@ set_theme <- function(base = theme_grey(),
     # ----------------------------------------
     if (!is.null(theme.font)) {
       sjtheme <- sjtheme +
-        theme(text = element_text(family = theme.font))
+        ggplot2::theme(text = element_text(family = theme.font))
     }
     # ----------------------------------------
     # set legend items background-color
     # ----------------------------------------
     if (!is.null(legend.item.backcol)) {
       sjtheme <- sjtheme +
-        theme(legend.key = element_rect(colour = legend.item.bordercol, fill = legend.item.backcol))
+        ggplot2::theme(legend.key = element_rect(colour = legend.item.bordercol, fill = legend.item.backcol))
     }
     # ----------------------------------------
     # set legend item size
     # ----------------------------------------
     if (!is.null(legend.item.size)) {
       sjtheme <- sjtheme +
-        theme(legend.key.size = unit(legend.item.size, ""cm""))
+        ggplot2::theme(legend.key.size = unit(legend.item.size, ""cm""))
     }
     # ----------------------------------------
     # set axis line colors, if defined
     # ----------------------------------------
     if (!is.null(axis.linecolor)) {
       sjtheme <- sjtheme +
-        theme(axis.line = element_line(colour = axis.linecolor, size = axis.line.size),
+        ggplot2::theme(axis.line = element_line(colour = axis.linecolor, size = axis.line.size),
               axis.line.x = element_line(colour = axis.linecolor.x),
               axis.line.y = element_line(colour = axis.linecolor.y))
     }
@@ -395,85 +394,85 @@ set_theme <- function(base = theme_grey(),
     # ----------------------------------------
     if (!is.null(axis.tickscol)) {
       sjtheme <- sjtheme +
-        theme(axis.ticks = element_line(colour = axis.tickscol))
+        ggplot2::theme(axis.ticks = element_line(colour = axis.tickscol))
     }
     if (!is.null(axis.tickslen)) {
       sjtheme <- sjtheme +
-        theme(axis.ticks.length = unit(axis.tickslen, ""cm""))
+        ggplot2::theme(axis.ticks.length = unit(axis.tickslen, ""cm""))
     }
     if (!is.null(axis.ticksmar)) {
       sjtheme <- sjtheme +
-        theme(axis.text = element_text(margin = margin(t = axis.ticksmar, unit = ""cm"")))
+        ggplot2::theme(axis.text = element_text(margin = margin(t = axis.ticksmar, unit = ""cm"")))
     }
     if (!is.null(axis.ticksize.x)) {
       sjtheme <- sjtheme +
-        theme(axis.ticks.x = element_line(size = axis.ticksize.x))
+        ggplot2::theme(axis.ticks.x = element_line(size = axis.ticksize.x))
     }
     if (!is.null(axis.ticksize.y)) {
       sjtheme <- sjtheme +
-        theme(axis.ticks.y = element_line(size = axis.ticksize.y))
+        ggplot2::theme(axis.ticks.y = element_line(size = axis.ticksize.y))
     }
     # ----------------------------------------
     # set plot colors, if defined
     # ----------------------------------------
     if (!is.null(plot.col)) {
       sjtheme <- sjtheme +
-        theme(plot.background = element_rect(colour = plot.bordercol, fill = plot.backcol))
+        ggplot2::theme(plot.background = element_rect(colour = plot.bordercol, fill = plot.backcol))
     }
     # ----------------------------------------
     # set panel colors, if defined
     # ----------------------------------------
     if (!is.null(panel.col)) {
       sjtheme <- sjtheme +
-        theme(panel.background = element_rect(colour = panel.bordercol, fill = panel.backcol),
+        ggplot2::theme(panel.background = element_rect(colour = panel.bordercol, fill = panel.backcol),
               panel.border = element_rect(colour = panel.bordercol))
     }
     # ----------------------------------------
     # set panel grids, if defined
     # ----------------------------------------
     if (!is.null(panel.gridcol)) {
       sjtheme <- sjtheme +
-        theme(panel.grid.minor = element_line(colour = panel.minor.gridcol, linetype = panel.minor.linetype),
+        ggplot2::theme(panel.grid.minor = element_line(colour = panel.minor.gridcol, linetype = panel.minor.linetype),
               panel.grid.major = element_line(colour = panel.major.gridcol, linetype = panel.major.linetype))
     }
     # ----------------------------------------
     # set plot margins. onyl applies to pre-set themes
     # ----------------------------------------
     if (!is.null(plot.margins)) {
       sjtheme <- sjtheme +
-        theme(plot.margin = plot.margins)
+        ggplot2::theme(plot.margin = plot.margins)
     }
     # ----------------------------------------
     # set title adjustments. only applies to
     # pre-set themes
     # ----------------------------------------
     if (!is.null(plot.margins)) {
       sjtheme <- sjtheme +
-        theme(plot.margin = plot.margins)
+        ggplot2::theme(plot.margin = plot.margins)
     }
     if (!is.null(title.vjust)) {
       sjtheme <- sjtheme +
-        theme(plot.title = element_text(vjust = title.vjust))
+        ggplot2::theme(plot.title = element_text(vjust = title.vjust))
     }
     if (!is.null(axis.title.x.vjust)) {
       sjtheme <- sjtheme +
-        theme(axis.title.x = element_text(vjust = axis.title.x.vjust))
+        ggplot2::theme(axis.title.x = element_text(vjust = axis.title.x.vjust))
     }
     if (!is.null(axis.title.y.vjust)) {
       sjtheme <- sjtheme +
-        theme(axis.title.y = element_text(vjust = axis.title.y.vjust))
+        ggplot2::theme(axis.title.y = element_text(vjust = axis.title.y.vjust))
     }
     # ----------------------------------------
     # panel grid colors
     # ----------------------------------------
     if (!is.null(panel.gridcol.x)) {
       sjtheme <- sjtheme +
-        theme(panel.grid.minor.x = element_line(colour = panel.gridcol.x, linetype = panel.minor.linetype),
+        ggplot2::theme(panel.grid.minor.x = element_line(colour = panel.gridcol.x, linetype = panel.minor.linetype),
               panel.grid.major.x = element_line(colour = panel.gridcol.x, linetype = panel.major.linetype))
     }
     if (!is.null(panel.gridcol.y)) {
       sjtheme <- sjtheme +
-        theme(panel.grid.minor.y = element_line(colour = panel.gridcol.y, linetype = panel.minor.linetype),
+        ggplot2::theme(panel.grid.minor.y = element_line(colour = panel.gridcol.y, linetype = panel.minor.linetype),
               panel.grid.major.y = element_line(colour = panel.gridcol.y, linetype = panel.major.linetype))
     }
     # ----------------------------------------

---FILE: R/sjplot_themes.R---
@@ -82,12 +82,11 @@
 #' sjplot_pal(pal = ""breakfast club"")
 #' }
 #'
-#' @import ggplot2
 #' @rdname sjPlot-themes
 #' @export
 theme_sjplot <- function(base_size = 12, base_family = """") {
   (theme_minimal(base_size = base_size, base_family = base_family) +
-     theme(
+     ggplot2::theme(
        axis.line.x      = element_line(colour = ""grey80""),
        axis.line.y      = element_line(colour = ""grey80""),
        axis.text        = element_text(colour = ""grey50""),
@@ -104,7 +103,7 @@ theme_sjplot <- function(base_size = 12, base_family = """") {
 #' @export
 theme_sjplot2 <- function(base_size = 12, base_family = """") {
   (theme_minimal(base_size = base_size, base_family = base_family) +
-     theme(
+     ggplot2::theme(
        axis.line.x      = element_line(colour = ""grey50""),
        axis.line.y      = element_line(colour = ""grey50""),
        axis.text        = element_text(colour = ""grey10""),
@@ -121,7 +120,7 @@ theme_sjplot2 <- function(base_size = 12, base_family = """") {
 #' @export
 theme_blank <- function(base_size = 12, base_family = """") {
   (theme_minimal(base_size = base_size, base_family = base_family) +
-     theme(
+     ggplot2::theme(
        axis.line.x      = element_line(colour = ""white""),
        axis.line.y      = element_line(colour = ""white""),
        axis.text        = element_text(colour = ""grey50""),
@@ -136,7 +135,7 @@ theme_blank <- function(base_size = 12, base_family = """") {
 #' @export
 theme_538 <- function(base_size = 12, base_family = """") {
   (theme_minimal(base_size = base_size, base_family = base_family) +
-     theme(
+     ggplot2::theme(
        axis.line.x        = element_line(colour = ""#F0F0F0""),
        axis.line.y        = element_line(colour = ""#F0F0F0""),
        axis.text          = element_text(colour = ""#737373""),
@@ -161,37 +160,37 @@ font_size <- function(title, axis_title.x, axis_title.y, labels.x, labels.y, off
 
   if (!missing(title)) {
     cur.theme <- cur.theme +
-      theme(title = element_text(size = title))
+      ggplot2::theme(title = element_text(size = title))
   }
 
   if (!missing(axis_title.x)) {
     cur.theme <- cur.theme +
-      theme(axis.title.x = element_text(size = axis_title.x))
+      ggplot2::theme(axis.title.x = element_text(size = axis_title.x))
   }
 
   if (!missing(axis_title.y)) {
     cur.theme <- cur.theme +
-      theme(axis.title.y = element_text(size = axis_title.y))
+      ggplot2::theme(axis.title.y = element_text(size = axis_title.y))
   }
 
   if (!missing(labels.x)) {
     cur.theme <- cur.theme +
-      theme(axis.text.x =  element_text(size = labels.x))
+      ggplot2::theme(axis.text.x =  element_text(size = labels.x))
   }
 
   if (!missing(labels.y)) {
     cur.theme <- cur.theme +
-      theme(axis.text.y =  element_text(size = labels.y))
+      ggplot2::theme(axis.text.y =  element_text(size = labels.y))
   }
 
   if (!missing(offset.x)) {
     cur.theme <- cur.theme +
-      theme(axis.title.x = element_text(vjust = offset.x))
+      ggplot2::theme(axis.title.x = element_text(vjust = offset.x))
   }
 
   if (!missing(offset.y)) {
     cur.theme <- cur.theme +
-      theme(axis.title.y = element_text(vjust = offset.y))
+      ggplot2::theme(axis.title.y = element_text(vjust = offset.y))
   }
 
   cur.theme
@@ -209,12 +208,12 @@ label_angle <- function(angle.x, angle.y, base.theme) {
 
   if (!missing(angle.x)) {
     cur.theme <- cur.theme +
-      theme(axis.text.x = element_text(angle = angle.x))
+      ggplot2::theme(axis.text.x = element_text(angle = angle.x))
   }
 
   if (!missing(angle.y)) {
     cur.theme <- cur.theme +
-      theme(axis.text.y = element_text(angle = angle.y))
+      ggplot2::theme(axis.text.y = element_text(angle = angle.y))
   }
 
   cur.theme
@@ -251,7 +250,7 @@ legend_style <- function(inside, pos, justify, base.theme) {
 
   if (!missing(pos)) {
     cur.theme <- cur.theme +
-      theme(
+      ggplot2::theme(
         legend.position = pos,
         legend.justification = justify
       )

---FILE: man/plot_xtab.Rd---
@@ -199,7 +199,7 @@ plot_xtab(x, grp, margin = ""row"", bar.pos = ""stack"",
 library(sjmisc)
 library(sjlabelled)
 data(efc)
-set_theme(geom.label.angle = 90)
+set_ggplot2::theme(geom.label.angle = 90)
 plot_xtab(efc$e42dep, efc$e16sex, vjust = ""center"", hjust = ""bottom"")
 
 # grouped bars with EUROFAMCARE sample dataset

---FILE: vignettes/custplot.Rmd---
@@ -27,7 +27,7 @@ The examples refer to `plot_grpfrq()`, but most arguments are similar across all
 
 ## Tweaking plot appearance
 
-The base function to globally change theme option for all sjp-function is `set_theme()`. Except for geom-colors and geom-sizes, all theme-options can be set via this function. This new theme will be applied to all following plots created with the **sjPlot** package.
+The base function to globally change theme option for all sjp-function is `sjPlot::set_theme()`. Except for geom-colors and geom-sizes, all theme-options can be set via this function. This new theme will be applied to all following plots created with the **sjPlot** package.
 
 There are various arguments to change colors, sizes, angles etc. of labels. Following example show changes to colors, sizes, angles, geom-outlines and theme.
 
@@ -40,23 +40,23 @@ library(ggplot2) # to access ggplot-themes
 # load sample data set
 data(efc)
 
-set_theme(
-  geom.outline.color = ""antiquewhite4"", 
-  geom.outline.size = 1, 
+sjPlot::set_theme(
+  geom.outline.color = ""antiquewhite4"",
+  geom.outline.size = 1,
   geom.label.size = 2,
   geom.label.color = ""grey50"",
-  title.color = ""red"", 
-  title.size = 1.5, 
-  axis.angle.x = 45, 
-  axis.textcolor = ""blue"", 
+  title.color = ""red"",
+  title.size = 1.5,
+  axis.angle.x = 45,
+  axis.textcolor = ""blue"",
   base = theme_bw()
 )
 
 plot_grpfrq(
-  efc$e42dep, 
-  efc$e16sex, 
-  title = NULL, 
-  geom.colors = c(""cadetblue"", ""coral""), 
+  efc$e42dep,
+  efc$e16sex,
+  title = NULL,
+  geom.colors = c(""cadetblue"", ""coral""),
   geom.size = 0.4
 )
 ```
@@ -67,7 +67,7 @@ All plotting functions support the usage of the [Colorbrewer]( https://colorbrew
 
 ```{r}
 # blank theme
-set_theme(
+sjPlot::set_theme(
   base = theme_blank(),
   axis.title.size = .9,
   axis.textsize = .9,
@@ -77,9 +77,9 @@ set_theme(
 )
 
 plot_grpfrq(
-  efc$e42dep, 
-  efc$e15relat, 
-  geom.colors = ""PuRd"", 
+  efc$e42dep,
+  efc$e15relat,
+  geom.colors = ""PuRd"",
   show.values = FALSE
 )
 ```
@@ -96,7 +96,7 @@ display.brewer.all()
 The plot's axes can be flipped using `coord.flip = TRUE`. If needed, labels can be placed inside the bars with the `vjust` or `hjust` arguments. In such cases, you might need to adjust the label colors with `geom.label.color = ""white""`.
 
 ```{r}
-set_theme(geom.label.color = ""white"", geom.label.size = 3)
+sjPlot::set_theme(geom.label.color = ""white"", geom.label.size = 3)
 
 # labels appear very large due to export metrics
 plot_grpfrq(efc$e42dep, efc$e16sex, coord.flip = TRUE)
@@ -107,7 +107,7 @@ plot_grpfrq(efc$e42dep, efc$e16sex, coord.flip = TRUE)
 Plots with no margins towards the axes may look strange to some people (not to me, though). To restore the ggplot-default behaviour, use the `expand.grid` argument:
 
 ```{r results='hide', echo=FALSE}
-set_theme(
+sjPlot::set_theme(
   axis.title.size = .9,
   axis.textsize = .9,
   legend.size = .7,
@@ -125,7 +125,7 @@ plot_grpfrq(efc$e42dep, efc$e16sex, expand.grid = TRUE)
 You can use any pre-defined theme from ggplot, like `theme_bw()`, `theme_classic()` or `theme_minimal()` as default theme.
 
 ```{r}
-set_theme(base = theme_light())
+sjPlot::set_theme(base = theme_light())
 plot_frq(efc$e42dep)
 ```
 
@@ -140,7 +140,7 @@ efc <- to_factor(efc, e42dep, c172code)
 m <- lm(neg_c_7 ~ pos_v_4 + c12hour + e42dep + c172code, data = efc)
 
 # reset theme
-set_theme(base = theme_grey())
+sjPlot::set_theme(base = theme_grey())
 
 # forest plot of regression model
 p <- plot_model(m)
@@ -153,11 +153,11 @@ p + theme_sjplot()
 
 ## Pre-defined scales
 
-There is also a new scale for **ggplot**-objects, `scale_color_sjplot()` and `scale_fill_sjplot()`. 
+There is also a new scale for **ggplot**-objects, `scale_color_sjplot()` and `scale_fill_sjplot()`.
 
 ```{r}
-p + 
-  theme_sjplot2() + 
+p +
+  theme_sjplot2() +
   scale_color_sjplot(""simply"")
 ```
 
@@ -171,7 +171,7 @@ show_sjplot_pals()
 
 If you want to use a specific theme as base for building your own theme, use the `base` argument. When using `base` instead of `theme`, further arguments for settings colors etc. are not ignored.
 ```{r}
-set_theme(base = theme_bw(), axis.linecolor = ""darkgreen"")
+sjPlot::set_theme(base = theme_bw(), axis.linecolor = ""darkgreen"")
 plot_frq(efc$e42dep)
 ```
 
@@ -181,7 +181,7 @@ plot_frq(efc$e42dep)
 Each plotting function invisibly returns the ggplot-object. You can further add options to customize the appearance of the plot, like in the following example, where the count axis is hidden (color set to white):
 
 ```{r}
-set_theme(
+sjPlot::set_theme(
   base = theme_classic(),
   axis.tickslen = 0, # hides tick marks
   axis.title.size = .9,
@@ -190,7 +190,7 @@ set_theme(
   legend.title.size = .8,
   geom.label.size = 3.5
 )
-  
+
 plot_grpfrq(
   efc$e42dep,
   efc$e16sex,
@@ -205,8 +205,8 @@ plot_grpfrq(
 The plot's legend can be customized via various `legend.`-arguments, see following examples:
 
 ```{r}
-set_theme(
-  base = theme_classic(), 
+sjPlot::set_theme(
+  base = theme_classic(),
   legend.title.face = ""italic"", # title font face
   legend.inside = TRUE,         # legend inside plot
   legend.color = ""grey50"",      # legend label color
@@ -223,8 +223,8 @@ plot_grpfrq(efc$e42dep, efc$e16sex, coord.flip = TRUE)
 
 
 ```{r}
-set_theme(
-  base = theme_classic(), 
+sjPlot::set_theme(
+  base = theme_classic(),
   axis.linecolor = ""white"",     # ""remove"" axis lines
   axis.textcolor.y = ""darkred"", # set axis label text only for y axis
   axis.tickslen = 0,            # ""remove"" tick marks
@@ -240,4 +240,3 @@ set_theme(
 
 plot_grpfrq(efc$e42dep, efc$e16sex)
 ```
-"
strengejacke,sjPlot,28e26306c0d85bbc4f6e0cd0178a154c4f2cea21,Daniel,mail@danielluedecke.de,2025-07-01T10:02:24Z,Daniel,mail@danielluedecke.de,2025-07-01T10:02:24Z,"Namespace clash with new ggplot2 version
Fixes #970",R/plot_diag_linear.R;R/plot_diag_stan.R;R/plot_frq.R;R/plot_gpt.R;R/plot_grpfrq.R;R/plot_kfold_cv.R;R/plot_likert.R;R/plot_models.R;R/plot_point_estimates.R;R/plot_residuals.R;R/plot_scatter.R;R/plot_stackfrq.R;R/plot_type_slope.R;R/plot_xtab.R;R/sjPlotAnova.R;R/sjPlotCorr.R;R/sjPlotDist.R;R/sjPlotPearsonsChi2Test.R;R/sjPlotPolynomials.R;R/sjplot_themes.R,False,True,True,False,40,41,81,"---FILE: R/plot_diag_linear.R---
@@ -42,7 +42,7 @@ diag_ncv <- function(model, dot.size, line.size) {
     fitted = stats::fitted(model)
   )
 
-  ggplot(dat, aes_string(x = ""fitted"", y = ""res"")) +
+  ggplot2::ggplot(dat, aes_string(x = ""fitted"", y = ""res"")) +
     geom_intercept_line2(0, NULL) +
     geom_point(size = dot.size) +
     geom_smooth(method = ""loess"", se = FALSE, size = line.size) +
@@ -60,7 +60,7 @@ diag_ncv <- function(model, dot.size, line.size) {
 diag_norm <- function(model, geom.colors) {
   res_ <- data.frame(res = stats::residuals(model))
 
-  ggplot(res_, aes_string(x = ""res"")) +
+  ggplot2::ggplot(res_, aes_string(x = ""res"")) +
     geom_density(fill = geom.colors[1], alpha = 0.2) +
     stat_function(
       fun = dnorm,
@@ -102,7 +102,7 @@ diag_qq <- function(model, geom.colors, dot.size, line.size, ...) {
   mydf <- stats::na.omit(data.frame(x = fitted_, y = res_))
 
   # plot it
-  ggplot(mydf, aes_string(x = ""x"", y = ""y"")) +
+  ggplot2::ggplot(mydf, aes_string(x = ""x"", y = ""y"")) +
     geom_point(size = dot.size) +
     scale_colour_manual(values = geom.colors) +
     stat_smooth(method = ""lm"", se = FALSE, size = line.size) +
@@ -172,7 +172,7 @@ diag_reqq <- function(model, dot.size) {
       conf.high = df.y + df.ci
     )
 
-    ggplot(pDf, aes_string(
+    ggplot2::ggplot(pDf, aes_string(
       x = ""nQQ"",
       y = ""y""
     )) +
@@ -231,7 +231,7 @@ diag_vif <- function(fit) {
       rownames_as_column(var = ""vars"")
 
 
-    vifplot <- ggplot(mydat, aes_string(x = ""vars"", y = ""vif"")) +
+    vifplot <- ggplot2::ggplot(mydat, aes_string(x = ""vars"", y = ""vif"")) +
       geom_bar(stat = ""identity"", width = 0.7, fill = ""#80acc8"") +
       geom_hline(yintercept = 5, linetype = 2, colour = ""darkgreen"", alpha = 0.7) +
       geom_hline(yintercept = 10, linetype = 2, colour = ""darkred"", alpha = 0.7) +

---FILE: R/plot_diag_stan.R---
@@ -98,12 +98,12 @@ plot_diag_stan <- function(model, geom.colors, axis.lim, facets, axis.labels, ..
 
 
   if (!facets && requireNamespace(""ggridges"", quietly = TRUE)) {
-    p <- ggplot(pp, aes_string(y = ""Term"", x = ""Estimate"", fill = ""Sample"")) +
+    p <- ggplot2::ggplot(pp, aes_string(y = ""Term"", x = ""Estimate"", fill = ""Sample"")) +
       ggridges::geom_density_ridges2(alpha = alpha, rel_min_height = .005, scale = scale) +
       scale_fill_manual(values = col_check2(geom.colors, 2))
   } else {
 
-    p <- ggplot(pp, aes_string(x = ""Estimate"", fill = ""Sample"")) +
+    p <- ggplot2::ggplot(pp, aes_string(x = ""Estimate"", fill = ""Sample"")) +
       geom_density(alpha = alpha) +
       scale_fill_manual(values = col_check2(geom.colors, 2))
 
@@ -121,4 +121,3 @@ plot_diag_stan <- function(model, geom.colors, axis.lim, facets, axis.labels, ..
 
   p + xlab(""Distribution"")
 }
-

---FILE: R/plot_frq.R---
@@ -539,7 +539,7 @@ plot_frq_helper <- function(
     # mydat is a data frame that only contains one variable (var).
     # Must be declared as factor, so the bars are central aligned to
     # each x-axis-break.
-    baseplot <- ggplot(mydat, aes(x = .data$val, y = .data$frq)) +
+    baseplot <- ggplot2::ggplot(mydat, aes(x = .data$val, y = .data$frq)) +
       geob +
       yscale +
       # remove guide / legend
@@ -566,7 +566,7 @@ plot_frq_helper <- function(
   # Start box plot here -----
   } else if (type == ""boxplot"" || type == ""violin"") {
     # setup base plot
-    baseplot <- ggplot(mydat, aes_string(x = ""grp"", y = ""frq""))
+    baseplot <- ggplot2::ggplot(mydat, aes_string(x = ""grp"", y = ""frq""))
     # and x-axis
     scalex <- scale_x_discrete(labels = """")
     if (type == ""boxplot"") {
@@ -599,7 +599,7 @@ plot_frq_helper <- function(
   # Start density plot here -----
   } else if (type == ""density"") {
     # First, plot histogram with density curve
-    baseplot <- ggplot(hist.dat, aes(x = .data$xv)) +
+    baseplot <- ggplot2::ggplot(hist.dat, aes(x = .data$xv)) +
       geom_histogram(aes(y = stat(density)), binwidth = geom.size, fill = geom.colors) +
       # transparent density curve above bars
       geom_density(aes(y = stat(density)), fill = ""cornsilk"", alpha = 0.3) +
@@ -627,11 +627,11 @@ plot_frq_helper <- function(
     # counts on the y-axis
     if (type == ""histogram"") {
       # original data needed for normal curve
-      baseplot <- ggplot(mydat) +
+      baseplot <- ggplot2::ggplot(mydat) +
         # second data frame mapped to the histogram geom
         geom_histogram(data = hist.dat, aes(x = .data$xv), binwidth = geom.size, fill = geom.colors)
     } else {
-      baseplot <- ggplot(mydat, aes(x = .data$val, y = .data$frq)) +
+      baseplot <- ggplot2::ggplot(mydat, aes(x = .data$val, y = .data$frq)) +
         geom_area(alpha = 0.3) +
         geom_line(linewidth = geom.size, colour = geom.colors) +
         ggvaluelabels

---FILE: R/plot_gpt.R---
@@ -311,7 +311,7 @@ gpt_helper <- function(
   geom.colors <- col_check2(colors, pal.len)
 
   # Set up plot
-  p <- ggplot(newdf, aes(x = rev(.data$grp), y = .data$ypos, colour = .data$xpos, shape = .data$xpos)) +
+  p <- ggplot2::ggplot(newdf, aes(x = rev(.data$grp), y = .data$ypos, colour = .data$xpos, shape = .data$xpos)) +
     geom_point(size = geom.size, fill = shape.fill.color) +
     scale_y_continuous(labels = scales::percent, breaks = gridbreaks, limits = axis.lim) +
     scale_x_discrete(labels = rev(axis.labels)) +

---FILE: R/plot_grpfrq.R---
@@ -748,7 +748,7 @@ plot_grpfrq <- function(var.cnt,
 
     # lines need colour aes
     baseplot <-
-      ggplot(mydf,
+      ggplot2::ggplot(mydf,
              aes_string(
                x = ""xpos"",
                y = ""frq"",
@@ -761,7 +761,7 @@ plot_grpfrq <- function(var.cnt,
   } else if (type == ""boxplot"" || type == ""violin"") {
     if (is.null(intr.var)) {
       baseplot <-
-        ggplot(mydf,
+        ggplot2::ggplot(mydf,
                aes_string(
                  x = ""group"",
                  y = ""frq"",
@@ -771,7 +771,7 @@ plot_grpfrq <- function(var.cnt,
       scalex <- scale_x_discrete(labels = axis.labels)
     } else {
       baseplot <-
-        ggplot(mydf, aes(
+        ggplot2::ggplot(mydf, aes(
           x = interaction(.data$ia, .data$group),
           y = .data$frq,
           fill = .data$group,
@@ -801,15 +801,15 @@ plot_grpfrq <- function(var.cnt,
                    size = inner.box.dotsize, fill = fcsp)
   } else {
     if (type == ""dot"") {
-      baseplot <- ggplot(mydf, aes_string(x = ""xpos"", y = ""frq"", colour = ""group""))
+      baseplot <- ggplot2::ggplot(mydf, aes_string(x = ""xpos"", y = ""frq"", colour = ""group""))
 
       # check whether we have dots plotted, and if so, use annotation
       # We have to use annotation first, because the diagram's layers are plotted
       # in the order as they're passed to the ggplot-command. Since we don't want the
       # shaded rectangles to overlay the dots, we add them first
       if (!is.null(ganno) && !facet.grid) baseplot <- baseplot + ganno
     } else {
-      baseplot <- ggplot(mydf, aes_string(x = ""xpos"", y = ""frq"", fill = ""group""))
+      baseplot <- ggplot2::ggplot(mydf, aes_string(x = ""xpos"", y = ""frq"", fill = ""group""))
     }
 
     # add geom

---FILE: R/plot_kfold_cv.R---
@@ -131,7 +131,7 @@ plot_kfold_cv <- function(data, formula, k = 5, fit) {
 
   # plot response against residuals, to see where our model over- or
   # underestimates the outcome
-  p <- ggplot(data = res, aes_string(x = "".response"", y = ""residuals"")) +
+  p <- ggplot2::ggplot(data = res, aes_string(x = "".response"", y = ""residuals"")) +
     geom_hline(yintercept = 0) +
     geom_point() +
     stat_smooth(method = ""loess"") +

---FILE: R/plot_likert.R---
@@ -672,7 +672,7 @@ plot_likert <- function(items,
 
   # start plot here
 
-  gp <- ggplot() +
+  gp <- ggplot2::ggplot() +
     # positive value bars
     geom_col(
       data = mydat.pos,

---FILE: R/plot_models.R---
@@ -291,9 +291,9 @@ plot_models <- function(...,
   # set up base plot
 
   if (p.shape)
-    p <- ggplot(ff, aes_string(x = ""term"", y = ""estimate"", colour = ""group"", shape = ""p.stars""))
+    p <- ggplot2::ggplot(ff, aes_string(x = ""term"", y = ""estimate"", colour = ""group"", shape = ""p.stars""))
   else
-    p <- ggplot(ff, aes_string(x = ""term"", y = ""estimate"", colour = ""group""))
+    p <- ggplot2::ggplot(ff, aes_string(x = ""term"", y = ""estimate"", colour = ""group""))
 
 
   p <- p +

---FILE: R/plot_point_estimates.R---
@@ -79,9 +79,9 @@ plot_point_estimates <- function(model,
   # basis aes mapping
 
   if (multinomial)
-    p <- ggplot(dat, aes_string(x = ""term"", y = ""estimate"", colour = ""response.level"", fill = ""response.level""))
+    p <- ggplot2::ggplot(dat, aes_string(x = ""term"", y = ""estimate"", colour = ""response.level"", fill = ""response.level""))
   else
-    p <- ggplot(dat, aes_string(x = ""term"", y = ""estimate"", colour = ""group"", fill = ""group""))
+    p <- ggplot2::ggplot(dat, aes_string(x = ""term"", y = ""estimate"", colour = ""group"", fill = ""group""))
 
   if (is.stan(model)) {
 

---FILE: R/plot_residuals.R---
@@ -82,7 +82,7 @@ plot_residuals <- function(fit, geom.size = 2, remove.estimates = NULL, show.lin
   colnames(mydat)[1] <- "".response""
 
   # melt data, build basic plot
-  res.plot <- ggplot(mydat, aes(x = .data$x, y = .data$.response)) +
+  res.plot <- ggplot2::ggplot(mydat, aes(x = .data$x, y = .data$.response)) +
     stat_smooth(method = ""lm"", se = show.ci, colour = ""grey70"")
 
   if (show.lines) res.plot <- res.plot +

---FILE: R/plot_scatter.R---
@@ -305,7 +305,7 @@ scatter_helper <- function(
 
   # Plot scatter plot
 
-  scp <- ggplot(dat, aes_string(x = ""x"", y = ""y"", colour = ""grp""))
+  scp <- ggplot2::ggplot(dat, aes_string(x = ""x"", y = ""y"", colour = ""grp""))
 
 
   # add marginal rug

---FILE: R/plot_stackfrq.R---
@@ -351,9 +351,9 @@ plot_stackfrq <- function(items,
   # change x axis order then
 
   if (reverseOrder && is.null(sort.frq)) {
-    baseplot <- ggplot(mydat, aes(x = rev(.data$grp), y = .data$prc, fill = .data$cat))
+    baseplot <- ggplot2::ggplot(mydat, aes(x = rev(.data$grp), y = .data$prc, fill = .data$cat))
   } else {
-    baseplot <- ggplot(mydat, aes(x = .data$grp, y = .data$prc, fill = .data$cat))
+    baseplot <- ggplot2::ggplot(mydat, aes(x = .data$grp, y = .data$prc, fill = .data$cat))
   }
 
   baseplot <- baseplot +

---FILE: R/plot_type_slope.R---
@@ -110,7 +110,7 @@ plot_type_slope <- function(model,
 
   if (facets) {
 
-    p <- ggplot(mydat, aes(x = .data$x, y = .data$y)) +
+    p <- ggplot2::ggplot(mydat, aes(x = .data$x, y = .data$y)) +
       stat_smooth(
         method = ""lm"", se = !is.na(ci.lvl), colour = lineColor,
         fill = lineColor, alpha = alpha, level = ci.lvl
@@ -145,7 +145,7 @@ plot_type_slope <- function(model,
 
       dat <- dplyr::filter(mydat, .data$group == !! p_v)
 
-      pl <- ggplot(dat, aes(x = .data$x, y = .data$y)) +
+      pl <- ggplot2::ggplot(dat, aes(x = .data$x, y = .data$y)) +
         stat_smooth(
           method = ""lm"", se = !is.na(ci.lvl), colour = lineColor,
           fill = lineColor, alpha = alpha, level = ci.lvl

---FILE: R/plot_xtab.R---
@@ -427,7 +427,7 @@ plot_xtab <- function(x,
   # --------------------------------------------------------
   # start plot here
   # --------------------------------------------------------
-  baseplot <- ggplot(mydf, aes_string(x = ""xpos"", y = ""prc"", fill = ""group"")) + geob
+  baseplot <- ggplot2::ggplot(mydf, aes_string(x = ""xpos"", y = ""prc"", fill = ""group"")) + geob
   # if we have line diagram, print lines here
   if (type == ""line"") {
     baseplot <- baseplot +

---FILE: R/sjPlotAnova.R---
@@ -245,7 +245,7 @@ sjp.aov1 <- function(var.dep,
   # --------------------------------------------------------
   # Start plot here!
   # --------------------------------------------------------
-  anovaplot <- ggplot(df, aes(y = .data$means, x = .data$xv)) +
+  anovaplot <- ggplot2::ggplot(df, aes(y = .data$means, x = .data$xv)) +
     # print point
     geom_point(size = geom.size, colour = df$geocol) +
     # and error bar

---FILE: R/sjPlotCorr.R---
@@ -215,7 +215,7 @@ sjp.corr <- function(data,
   # --------------------------------------------------------
   # start with base plot object here
   # --------------------------------------------------------
-  corrPlot <- ggplot(orderedCorr, aes_string(x = ""ordx"", y = ""ordy"", fill = ""value"", label = ""val.labels"")) +
+  corrPlot <- ggplot2::ggplot(orderedCorr, aes_string(x = ""ordx"", y = ""ordy"", fill = ""value"", label = ""val.labels"")) +
     geom_tile(size = 0, colour = ""black"") +
   # fill gradient colour from distinct color brewer palette. negative correlations are dark
   # red, positive corr. are dark blue, and they become lighter the closer they are to a

---FILE: R/sjPlotDist.R---
@@ -76,7 +76,7 @@ dist_norm <- function(norm = NULL,
   # density normal distribution
   mydat$y <- stats::dnorm(mydat$x, mean, sd)
   # base plot with normal-distribution
-  gp <- ggplot(mydat, aes_string(x = ""x"", y = ""y"")) + geom_line()
+  gp <- ggplot2::ggplot(mydat, aes_string(x = ""x"", y = ""y"")) + geom_line()
   sub.df <- NULL
   if (!is.null(p)) {
     # plot area for indicated x-value...
@@ -213,7 +213,7 @@ dist_chisq <- function(chi2 = NULL,
   # density distribution of chi2
   mydat$y <- stats::dchisq(mydat$x, deg.f)
   # base plot with chi2-distribution
-  gp <- ggplot(mydat, aes_string(x = ""x"", y = ""y"")) + geom_line()
+  gp <- ggplot2::ggplot(mydat, aes_string(x = ""x"", y = ""y"")) + geom_line()
   sub.df <- NULL
   if (!is.null(p)) {
     # plot area for indicated chi2-value...
@@ -342,7 +342,7 @@ dist_f <- function(f = NULL,
   # density distribution of f
   mydat$y <- stats::df(mydat$x, deg.f1, deg.f2)
   # base plot with f-distribution
-  gp <- ggplot(mydat, aes_string(x = ""x"", y = ""y"")) + geom_line()
+  gp <- ggplot2::ggplot(mydat, aes_string(x = ""x"", y = ""y"")) + geom_line()
   sub.df <- NULL
   if (!is.null(p)) {
     # plot area for indicated f-value...
@@ -472,7 +472,7 @@ dist_t <- function(t = NULL,
   # density distribution of t
   mydat$y <- stats::dt(mydat$x, deg.f)
   # base plot with t-distribution
-  gp <- ggplot(mydat, aes_string(x = ""x"", y = ""y"")) + geom_line()
+  gp <- ggplot2::ggplot(mydat, aes_string(x = ""x"", y = ""y"")) + geom_line()
   sub.df <- NULL
   if (!is.null(p)) {
     # plot area for indicated t-value...

---FILE: R/sjPlotPearsonsChi2Test.R---
@@ -84,7 +84,7 @@ sjp.chi2 <- function(df,
   # --------------------------------------------------------
   # start with base plot object here
   # --------------------------------------------------------
-  chiPlot <- ggplot(data = m, aes_string(x = ""Row"", y = ""Column"", fill = ""p.value"", label = ""p.value"")) +
+  chiPlot <- ggplot2::ggplot(data = m, aes_string(x = ""Row"", y = ""Column"", fill = ""p.value"", label = ""p.value"")) +
     geom_tile() +
     scale_x_discrete(labels = axis.labels) +
     scale_y_discrete(labels = axis.labels) +

---FILE: R/sjPlotPolynomials.R---
@@ -196,7 +196,7 @@ sjp.poly <- function(x,
   # name df
   colnames(plot.df) <- c(""x"",""y"", ""pred"", ""grp"")
   # create plot
-  polyplot <- ggplot(plot.df, aes_string(x = ""x"", y = ""y"", colour = ""grp""))
+  polyplot <- ggplot2::ggplot(plot.df, aes_string(x = ""x"", y = ""y"", colour = ""grp""))
   # show scatter plot as well?
   if (show.scatter) polyplot <- polyplot +
     geom_jitter(colour = point.color, alpha = point.alpha, shape = 16)

---FILE: R/sjplot_themes.R---
@@ -365,7 +365,7 @@ show_sjplot_pals <- function() {
   x$group[.is_cont_scale(x$key)] <- ""Continuous Palettes""
   x$group[x$key %in% c(""breakfast.club"", ""flat"", ""metro"", ""quadro"", ""set1"", ""simply"", ""social"")] <- ""Red-Blue-Green Palettes""
 
-  ggplot(x, aes_string(x = ""key"", fill = ""cols"")) +
+  ggplot2::ggplot(x, aes_string(x = ""key"", fill = ""cols"")) +
     geom_bar(width = .7) +
     scale_fill_manual(values = x$value) +
     scale_y_continuous(breaks = NULL, labels = NULL) +"
strengejacke,sjPlot,d487b64316757dcd9e86f0a4dc5da52ca65980bf,Daniel,mail@danielluedecke.de,2024-11-27T09:21:47Z,Daniel,mail@danielluedecke.de,2024-11-27T09:21:47Z,fix,R/plot_type_int.R,False,True,True,False,5,0,5,"---FILE: R/plot_type_int.R---
@@ -98,6 +98,11 @@ plot_type_int <- function(model,
 
 
     # compute marginal effects for interaction terms
+    pred.type <- switch(pred.type,
+      fe = ""fixed"",
+      re = ""random"",
+      pred.type
+    )
 
     dat <- ggeffects::ggpredict(
       model = model,"
strengejacke,sjPlot,29725241b4755277b89addda2aef9821d379be9f,Daniel,mail@danielluedecke.de,2024-11-27T09:11:11Z,Daniel,mail@danielluedecke.de,2024-11-27T09:11:11Z,fix,R/plot_type_eff.R,False,True,True,False,6,0,6,"---FILE: R/plot_type_eff.R---
@@ -20,6 +20,12 @@ plot_type_eff <- function(type,
 
   if (missing(facets) || is.null(facets)) facets <- FALSE
 
+  pred.type <- switch(pred.type,
+    fe = ""fixed"",
+    re = ""random"",
+    pred.type
+  )
+
   if (type == ""pred"") {
     dat <- ggeffects::ggpredict(
       model = model,"
strengejacke,sjPlot,a345db93d605f161d4b15bcafa2397f9ff33b8bb,Daniel,mail@danielluedecke.de,2024-11-25T16:14:44Z,Daniel,mail@danielluedecke.de,2024-11-25T16:14:44Z,"Warning message: The `fun.y` argument of `stat_summary()` is deprecated as of ggplot2 3.3.0.
Fixes #954",DESCRIPTION;R/plot_frq.R;R/plot_grid.R;R/plot_grpfrq.R,False,True,True,False,8,10,18,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 2.8.16.1
+Version: 2.8.16.2
 Authors@R: c(
     person(""Daniel"", ""Ldecke"", email = ""d.luedecke@uke.de"", role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0002-8895-3206"")),
     person(""Alexander"", ""Bartel"", role = ""ctb"", comment = c(ORCID = ""0000-0002-1280-6138"")),

---FILE: R/plot_frq.R---
@@ -591,7 +591,7 @@ plot_frq_helper <- function(
     # different fill colours, because violin boxplots have white background
     fcsp <- ifelse(type == ""boxplot"", ""white"", ""black"")
     baseplot <- baseplot +
-      stat_summary(fun.y = ""mean"", geom = ""point"", shape = 21,
+      stat_summary(fun = ""mean"", geom = ""point"", shape = 21,
                    size = inner.box.dotsize, fill = fcsp)
     # no additional labels for the x- and y-axis, only diagram title
     baseplot <- baseplot + yscale + scalex

---FILE: R/plot_grid.R---
@@ -64,15 +64,13 @@ plot_grid <- function(x, margin = c(1, 1, 1, 1), tags = NULL) {
   tags_labels <- NULL
 
   # Add tags
-  if (isTRUE(tags)) {
+  if (isTRUE(tags) || is.null(tags)) {
+    tags_labels = LETTERS
+  } else if (length(tags) < length(x)) {
+    insight::format_warning(""Not enough tags labels in list. Using letters instead."")
     tags_labels = LETTERS
   } else{
-    if (length(tags) < length(x)) {
-      warning(""Not enough tags labels in list. Using letters instead."")
-      tags_labels = LETTERS
-    } else{
-      tags_labels = tags
-    }
+    tags_labels = tags
   }
 
   if (!is.null(tags_labels)) {

---FILE: R/plot_grpfrq.R---
@@ -797,7 +797,7 @@ plot_grpfrq <- function(var.cnt,
     # different fill colours, because violin boxplots have white background
     fcsp <- ifelse(type == ""boxplot"", ""white"", ""black"")
     baseplot <- baseplot +
-      stat_summary(fun.y = ""mean"", geom = ""point"", shape = 21,
+      stat_summary(fun = ""mean"", geom = ""point"", shape = 21,
                    size = inner.box.dotsize, fill = fcsp)
   } else {
     if (type == ""dot"") {"
strengejacke,sjPlot,1ae43ad5b10cd7c42d551da65d0e26114a6d2312,Daniel,mail@danielluedecke.de,2024-08-16T10:40:35Z,Daniel,mail@danielluedecke.de,2024-08-16T10:40:35Z,"plot_model not changing confidence intervals with ci.lvl function
Fixes #947",DESCRIPTION;NEWS.md;R/plot_type_eff.R;R/plot_type_int.R,False,True,True,False,21,15,36,"---FILE: DESCRIPTION---
@@ -2,21 +2,21 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 2.8.16
+Version: 2.8.16.1
 Authors@R: c(
     person(""Daniel"", ""Ldecke"", email = ""d.luedecke@uke.de"", role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0002-8895-3206"")),
     person(""Alexander"", ""Bartel"", role = ""ctb"", comment = c(ORCID = ""0000-0002-1280-6138"")),
     person(""Carsten"", ""Schwemmer"", email = ""carsten.schwemmer@uni-bamberg.de"", role = ""ctb""),
-    person(given = ""Chuck"", family = ""Powell"", role = ""ctb"", email = ""ibecav@gmail.com"", comment = c(ORCID = ""0000-0002-3606-2188"")), 
+    person(given = ""Chuck"", family = ""Powell"", role = ""ctb"", email = ""ibecav@gmail.com"", comment = c(ORCID = ""0000-0002-3606-2188"")),
     person(given = ""Amir"", family = ""Djalovski"", role = ""ctb"", email = ""Amir.DJV@gmail.com""),
     person(given = ""Johannes"", family = ""Titz"", role = ""ctb"", email = ""johannes@titz.science"", comment = c(ORCID = ""0000-0002-1102-5719"")))
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of plotting and table output functions for data
     visualization. Results of various statistical analyses (that are commonly used
     in social sciences) can be visualized using this package, including simple and
     cross tabulated frequencies, histograms, box plots, (generalized) linear models,
-    mixed effects models, principal component analysis and correlation matrices, 
-    cluster analyses, scatter plots, stacked scales, effects plots of regression 
+    mixed effects models, principal component analysis and correlation matrices,
+    cluster analyses, scatter plots, stacked scales, effects plots of regression
     models (including interaction terms) and much more. This package supports
     labelled data.
 License: GPL-3

---FILE: NEWS.md---
@@ -1,3 +1,9 @@
+# sjPlot 2.8.17
+
+## Bug fixes
+
+* Fixed issues with renamed arguments in upstream package *ggeffects*.
+
 # sjPlot 2.8.15
 
 * Minor fix in vignettes.
@@ -23,21 +29,21 @@
 
 ## General
 
-* Minor changes to work properly with updates of upstream packages and 
+* Minor changes to work properly with updates of upstream packages and
   various smaller bug fixes and improvements.
-  
+
 # sjPlot 2.8.11
 
 ## General
 
-* Minor changes to work properly with updates of upstream packages and 
+* Minor changes to work properly with updates of upstream packages and
   various smaller bug fixes and improvements.
 
 # sjPlot 2.8.10
 
 ## General
 
-* Minor changes to work properly with updates of downstream packages and 
+* Minor changes to work properly with updates of downstream packages and
   various smaller bug fixes and improvements.
 
 # sjPlot 2.8.9
@@ -206,7 +212,7 @@
 ## Bug fixes
 
 * Fixed bug in `plot_stackfrq()` for data frames with many missing values.
-* Fixed bug with sorting frequencies in `plot_frq()` when vector had more labels than values. 
+* Fixed bug with sorting frequencies in `plot_frq()` when vector had more labels than values.
 * Fixed bug in `tab_model()` where `show.reflvl = TRUE` did not insert the reference category in first place, but in alphabetical order.
 
 # sjPlot 2.7.1
@@ -270,7 +276,7 @@
 * Argument `string.est` in `tab_model()` did not overwrite the default label for the estimate-column-header.
 * Minor fix in `tab_model()` for mixed models that can't compute R2.
 * Fix issue in `tab_model()` when printing robust standard errors and CI (i.e. when using arguments `vcov*`).
-* The `plot_likert()` option `reverse.scale = TRUE` resulted in `values = ""sum.inside""` being outside and the other way around. This is fixed now. 
+* The `plot_likert()` option `reverse.scale = TRUE` resulted in `values = ""sum.inside""` being outside and the other way around. This is fixed now.
 * `view_df()` mixed up labels and frequency values when value labels were present, but no such values were in the data.
 * Argument `wrap.labels` in `plot_frq()` did not properly work for factor levels.
 * Fix issue in `plot_models()` that stopped for some models.
@@ -339,7 +345,7 @@ Following functions are now defunct:
 ## Bug fixes
 
 * `plot_model()` no longer automatically changes the plot-type to `""slope""` for models with only one predictor that is categorical and has more than two levels.
-* `type = ""eff""` and `type = ""pred""` in `plot_model()` did not work when `terms` was not specified. 
+* `type = ""eff""` and `type = ""pred""` in `plot_model()` did not work when `terms` was not specified.
 * If robust standard errors are requested in `tab_model()`, the confidence intervals and p-values are now re-calculated and adjusted based on the robust standard errors.
 * `colors = ""bw""` was not recognized correctly for `plot_model(..., type = ""int"")`.
 * Fix issue in `sjp.frq()` with correct axis labels for non-labelled character vectors.

---FILE: R/plot_type_eff.R---
@@ -24,23 +24,23 @@ plot_type_eff <- function(type,
     dat <- ggeffects::ggpredict(
       model = model,
       terms = terms,
-      ci_lvl = ci.lvl,
+      ci_level = ci.lvl,
       type = pred.type,
       ...
     )
   } else if (type == ""emm"") {
     dat <- ggeffects::ggemmeans(
       model = model,
       terms = terms,
-      ci_lvl = ci.lvl,
+      ci_level = ci.lvl,
       type = pred.type,
       ...
     )
   } else {
     dat <- ggeffects::ggeffect(
       model = model,
       terms = terms,
-      ci_lvl = ci.lvl,
+      ci_level = ci.lvl,
       ...
     )
   }

---FILE: R/plot_type_int.R---
@@ -102,7 +102,7 @@ plot_type_int <- function(model,
     dat <- ggeffects::ggpredict(
       model = model,
       terms = ia,
-      ci_lvl = ci.lvl,
+      ci_level = ci.lvl,
       type = pred.type,
       full.data = FALSE,
       ..."
strengejacke,sjPlot,5227a3e519c112933df166f8b6c0fb1f91280427,Daniel,mail@danielluedecke.de,2024-05-13T14:46:40Z,Daniel,mail@danielluedecke.de,2024-05-13T14:46:40Z,fix,NAMESPACE;R/plot_frq.R,False,True,True,False,0,2,2,"---FILE: NAMESPACE---
@@ -138,7 +138,6 @@ importFrom(sjstats,cramer)
 importFrom(sjstats,crosstable_statistics)
 importFrom(sjstats,phi)
 importFrom(sjstats,table_values)
-importFrom(sjstats,weighted_sd)
 importFrom(stats,aov)
 importFrom(stats,binomial)
 importFrom(stats,chisq.test)

---FILE: R/plot_frq.R---
@@ -110,7 +110,6 @@ utils::globalVariables(""density"")
 #'         normal.curve.size = 3, ylim = c(0,50))
 #' }
 #' @import ggplot2
-#' @importFrom sjstats weighted_sd
 #' @importFrom sjmisc group_labels group_var to_value frq
 #' @importFrom sjlabelled set_labels drop_labels
 #' @importFrom stats na.omit sd weighted.mean dnorm"
strengejacke,sjPlot,9fdbd3e1116f75d4956372831ce461a0e3bf2acb,Daniel,mail@danielluedecke.de,2024-05-13T13:22:15Z,Daniel,mail@danielluedecke.de,2024-05-13T13:22:15Z,fix,R/tab_itemscale.R;man/tab_itemscale.Rd,False,True,True,False,2,2,4,"---FILE: R/tab_itemscale.R---
@@ -85,7 +85,7 @@
 #'              \item Jorion N, Self B, James K, Schroeder L, DiBello L, Pellegrino J (2013) Classical Test Theory Analysis of the Dynamics Concept Inventory. (\href{https://www.academia.edu/4104752/Classical_Test_Theory_Analysis_of_the_Dynamics_Concept_Inventory}{web})
 #'              \item Briggs SR, Cheek JM (1986) The role of factor analysis in the development and evaluation of personality scales. Journal of Personality, 54(1), 106-148. doi: 10.1111/j.1467-6494.1986.tb00391.x
 #'              \item McLean S et al. (2013) Stigmatizing attitudes and beliefs about bulimia nervosa: Gender, age, education and income variability in a community sample. International Journal of Eating Disorders. doi: 10.1002/eat.22227
-#'              \item Trochim WMK (2008) Types of Reliability. (\href{https://conjointly.com/kb/types-of-reliability/}{web})
+#'              \item Trochim WMK (2008) Types of Reliability.
 #'             }
 #'
 #' @examples

---FILE: man/tab_itemscale.Rd---
@@ -196,6 +196,6 @@ if (interactive()) {
              \item Jorion N, Self B, James K, Schroeder L, DiBello L, Pellegrino J (2013) Classical Test Theory Analysis of the Dynamics Concept Inventory. (\href{https://www.academia.edu/4104752/Classical_Test_Theory_Analysis_of_the_Dynamics_Concept_Inventory}{web})
              \item Briggs SR, Cheek JM (1986) The role of factor analysis in the development and evaluation of personality scales. Journal of Personality, 54(1), 106-148. doi: 10.1111/j.1467-6494.1986.tb00391.x
              \item McLean S et al. (2013) Stigmatizing attitudes and beliefs about bulimia nervosa: Gender, age, education and income variability in a community sample. International Journal of Eating Disorders. doi: 10.1002/eat.22227
-             \item Trochim WMK (2008) Types of Reliability. (\href{https://conjointly.com/kb/types-of-reliability/}{web})
+             \item Trochim WMK (2008) Types of Reliability.
             }
 }"
strengejacke,sjPlot,04e87a6d3de2d05373f5ed5e48abde0c64f89131,Daniel,mail@danielluedecke.de,2024-05-13T12:35:58Z,Daniel,mail@danielluedecke.de,2024-05-13T12:35:58Z,minor fix,R/tab_itemscale.R,False,True,True,False,1,1,2,"---FILE: R/tab_itemscale.R---
@@ -220,7 +220,7 @@ tab_itemscale <- function(df,
     reli <- performance::item_reliability(df.sub, standardize = scale)
 
     # get index score value, by retrieving the row mean
-    item.score <- sjstats::mean_n(df.sub, min.valid.rowmean)
+    item.score <- datawizard::row_means(df.sub, min_valid = min.valid.rowmean)
 
     # store scaled values of each item's total score
     # to compute correlation coefficients between identified components"
strengejacke,sjPlot,d389bd8c10175d2d2add2b9f86c1b5c4e14f6952,Daniel,mail@danielluedecke.de,2024-03-08T13:18:24Z,Daniel,mail@danielluedecke.de,2024-03-08T13:18:24Z,Fixes #930,README.md,False,False,False,False,0,2,2,"---FILE: README.md---
@@ -27,8 +27,6 @@ install.packages(""sjPlot"")
 
 Please visit [https://strengejacke.github.io/sjPlot/](https://strengejacke.github.io/sjPlot/) for documentation and vignettes.
 
-See also this [package-review](https://yuzar-blog.netlify.app/posts/2022-08-01-sjplot/), which provides a comprehensive overview on how to easily visualize data and model results.
-
 ## Citation
 
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since core functionality of package depends on the [ggplot-package](https://cran.r-project.org/package=ggplot2), consider citing this package as well."
strengejacke,sjPlot,c5abb860dd8a90e8e3736073b5121d339782328f,Daniel,mail@danielluedecke.de,2023-11-23T22:18:54Z,Daniel,mail@danielluedecke.de,2023-11-23T22:18:54Z,"Error ci_style with typre=""pred"" for ggeffects version 1.3.2
Fixes #921",R/plot_type_eff.R;R/plot_type_int.R,False,True,True,False,20,20,40,"---FILE: R/plot_type_eff.R---
@@ -24,23 +24,23 @@ plot_type_eff <- function(type,
     dat <- ggeffects::ggpredict(
       model = model,
       terms = terms,
-      ci.lvl = ci.lvl,
+      ci_lvl = ci.lvl,
       type = pred.type,
       ...
     )
   } else if (type == ""emm"") {
     dat <- ggeffects::ggemmeans(
       model = model,
       terms = terms,
-      ci.lvl = ci.lvl,
+      ci_lvl = ci.lvl,
       type = pred.type,
       ...
     )
   } else {
     dat <- ggeffects::ggeffect(
       model = model,
       terms = terms,
-      ci.lvl = ci.lvl,
+      ci_lvl = ci.lvl,
       ...
     )
   }
@@ -82,20 +82,20 @@ plot_type_eff <- function(type,
 
   p <- graphics::plot(
     dat,
-    ci = !is.na(ci.lvl),
+    show_ci = !is.na(ci.lvl),
     facets = facets,
-    rawdata = show.data,
+    show_data = show.data,
     colors = geom.colors,
-    use.theme = FALSE,
+    use_theme = FALSE,
     jitter = jitter,
     case = case,
-    show.legend = show.legend,
-    dot.alpha = dot.alpha,
+    show_legend = show.legend,
+    dot_alpha = dot.alpha,
     alpha = alpha,
     dodge = dodge,
-    log.y = log.y,
-    dot.size = dot.size,
-    line.size = line.size
+    log_y = log.y,
+    dot_size = dot.size,
+    line_size = line.size
   )
 
 

---FILE: R/plot_type_int.R---
@@ -102,7 +102,7 @@ plot_type_int <- function(model,
     dat <- ggeffects::ggpredict(
       model = model,
       terms = ia,
-      ci.lvl = ci.lvl,
+      ci_lvl = ci.lvl,
       type = pred.type,
       full.data = FALSE,
       ...
@@ -132,20 +132,20 @@ plot_type_int <- function(model,
 
     p <- graphics::plot(
       dat,
-      ci = !is.na(ci.lvl),
+      show_ci = !is.na(ci.lvl),
       facets = facets,
-      rawdata = show.data,
+      show_data = show.data,
       colors = geom.colors,
       jitter = jitter,
-      use.theme = FALSE,
+      use_theme = FALSE,
       case = case,
-      show.legend = show.legend,
-      dot.alpha = dot.alpha,
+      show_legend = show.legend,
+      dot_alpha = dot.alpha,
       alpha = alpha,
       dodge = dodge,
-      log.y = log.y,
-      dot.size = dot.size,
-      line.size = line.size
+      log_y = log.y,
+      dot_size = dot.size,
+      line_size = line.size
     )
 
     # set axis and plot titles"
strengejacke,sjPlot,c52c7c420270ea57b56d337263153f117b8c516d,Daniel,mail@danielluedecke.de,2023-08-17T11:11:24Z,Daniel,mail@danielluedecke.de,2023-08-17T11:11:24Z,s3-method name fix,R/plot_grpfrq.R,False,True,True,False,1,1,2,"---FILE: R/plot_grpfrq.R---
@@ -821,7 +821,7 @@ plot_grpfrq <- function(var.cnt,
 
   # If we have bars or dot plots, we show
   # Pearson's chi-square test results
-  baseplot <- print.table.summary(baseplot, modsum, summary.pos)
+  baseplot <- .print.table.summary(baseplot, modsum, summary.pos)
 
   # prepare y-axis and
   # show or hide y-axis-labels"
strengejacke,sjPlot,e685b218d205379dbb3c455aadaad955d1f61186,Daniel,mail@danielluedecke.de,2023-03-31T09:27:51Z,Daniel,mail@danielluedecke.de,2023-03-31T09:27:51Z,fix example,R/plot_model.R;man/plot_model.Rd,False,True,True,False,4,0,4,"---FILE: R/plot_model.R---
@@ -415,6 +415,7 @@
 #'
 #' @examples
 #' # prepare data
+#' if (requireNamespace(""haven"")) {
 #' library(sjmisc)
 #' data(efc)
 #' efc <- to_factor(efc, c161sex, e42dep, c172code)
@@ -429,6 +430,7 @@
 #' # keep only selected terms in the model: pos_v_4, the
 #' # levels 3 and 4 of factor e42dep and levels 2 and 3 for c172code
 #' plot_model(m, terms = c(""pos_v_4"", ""e42dep [3,4]"", ""c172code [2,3]""))
+#' }
 #'
 #' # multiple plots, as returned from ""diagnostic""-plot type,
 #' # can be arranged with 'plot_grid()'

---FILE: man/plot_model.Rd---
@@ -539,6 +539,7 @@ Depending on the plot-type, \code{plot_model()} returns a
 }
 \examples{
 # prepare data
+if (requireNamespace(""haven"")) {
 library(sjmisc)
 data(efc)
 efc <- to_factor(efc, c161sex, e42dep, c172code)
@@ -553,6 +554,7 @@ plot_model(m, group.terms = c(1, 2, 3, 3, 3, 4, 4))
 # keep only selected terms in the model: pos_v_4, the
 # levels 3 and 4 of factor e42dep and levels 2 and 3 for c172code
 plot_model(m, terms = c(""pos_v_4"", ""e42dep [3,4]"", ""c172code [2,3]""))
+}
 
 # multiple plots, as returned from ""diagnostic""-plot type,
 # can be arranged with 'plot_grid()'"
strengejacke,sjPlot,b52daa8a4f1da3fa508cbe9aacfadf60067ba3f7,Daniel,mail@danielluedecke.de,2023-03-31T09:02:03Z,Daniel,mail@danielluedecke.de,2023-03-31T09:02:03Z,fixes,DESCRIPTION;vignettes/tab_bayes.Rmd,True,False,True,False,2,1,3,"---FILE: DESCRIPTION---
@@ -30,7 +30,6 @@ Imports:
     bayestestR,
     datawizard,
     dplyr,
-    effectsize,
     ggeffects,
     ggplot2 (>= 3.2.0),
     knitr,

---FILE: vignettes/tab_bayes.Rmd---
@@ -31,6 +31,8 @@ if (!requireNamespace(""insight"", quietly = TRUE) ||
   knitr::opts_chunk$set(eval = TRUE)
   library(insight)
   library(httr)
+  library(sjPlot)
+  library(brms)
   m1 <- tryCatch(insight::download_model(""brms_zi_2""), error = function(e) NULL)
   m2 <- tryCatch(insight::download_model(""brms_mv_3""), error = function(e) NULL)
 }"
strengejacke,sjPlot,ee1de23a9caa8c654c7921aac2f53f5967a8d194,Daniel,mail@danielluedecke.de,2023-03-29T14:52:55Z,Daniel,mail@danielluedecke.de,2023-03-29T14:52:55Z,fix vignette,vignettes/tab_bayes.Rmd,True,False,True,False,29,24,53,"---FILE: vignettes/tab_bayes.Rmd---
@@ -21,45 +21,50 @@ knitr::opts_chunk$set(
   message = FALSE
 )
 
+m1 <- m2 <- NULL
+
 if (!requireNamespace(""insight"", quietly = TRUE) ||
     !requireNamespace(""httr"", quietly = TRUE) ||
     !requireNamespace(""brms"", quietly = TRUE)) {
   knitr::opts_chunk$set(eval = FALSE)
 } else {
   knitr::opts_chunk$set(eval = TRUE)
+  library(insight)
+  library(httr)
+  m1 <- tryCatch(insight::download_model(""brms_zi_2""), error = function(e) NULL)
+  m2 <- tryCatch(insight::download_model(""brms_mv_3""), error = function(e) NULL)
+}
+
+if (is.null(m1) || is.null(m2)) {
+  knitr::opts_chunk$set(eval = FALSE)
 }
 ```
 
 This vignette shows examples for using `tab_model()` to create HTML tables for mixed models. Basically, `tab_model()` behaves in a very similar way for mixed models as for other, simple regression models, as shown [in this vignette](tab_model_estimates.html).
 
-```{r, results='hide', message=FALSE, warning=FALSE}
+```{r, results='hide', message=FALSE, warning=FALSE, eval=FALSE}
 # load required packages
 library(sjPlot)
-library(insight)
-library(httr)
 library(brms)
 
-# load sample models
-
-# zinb <- read.csv(""http://stats.idre.ucla.edu/stat/data/fish.csv"")
-# set.seed(123)
-# m1 <- brm(bf(
-#     count ~ persons + child + camper + (1 | persons),
-#     zi ~ child + camper + (1 | persons)
-#   ),
-#   data = zinb,
-#   family = zero_inflated_poisson()
-# )
-m1 <- insight::download_model(""brms_zi_2"")
-
-# data(epilepsy)
-# set.seed(123)
-# epilepsy$visit <- as.numeric(epilepsy$visit)
-# epilepsy$Base2 <- sample(epilepsy$Base, nrow(epilepsy), replace = TRUE)
-# f1 <- bf(Base ~ zAge + count + (1 |ID| patient))
-# f2 <- bf(Base2 ~ zAge + Trt + (1 |ID| patient))
-# m2 <- brm(f1 + f2 + set_rescor(FALSE), data = epilepsy)
-m2 <- insight::download_model(""brms_mv_3"")
+# sample models
+zinb <- read.csv(""http://stats.idre.ucla.edu/stat/data/fish.csv"")
+set.seed(123)
+m1 <- brm(bf(
+    count ~ persons + child + camper + (1 | persons),
+    zi ~ child + camper + (1 | persons)
+  ),
+  data = zinb,
+  family = zero_inflated_poisson()
+)
+
+data(epilepsy)
+set.seed(123)
+epilepsy$visit <- as.numeric(epilepsy$visit)
+epilepsy$Base2 <- sample(epilepsy$Base, nrow(epilepsy), replace = TRUE)
+f1 <- bf(Base ~ zAge + count + (1 |ID| patient))
+f2 <- bf(Base2 ~ zAge + Trt + (1 |ID| patient))
+m2 <- brm(f1 + f2 + set_rescor(FALSE), data = epilepsy)
 ```
 
 ## Bayesian models summaries as HTML table"
strengejacke,sjPlot,b3fd38990d3947fcff0397c1cc3a72bc2456e563,Daniel,mail@danielluedecke.de,2023-03-13T11:10:48Z,Daniel,mail@danielluedecke.de,2023-03-13T11:10:48Z,fix URL,R/tab_model.R;man/tab_corr.Rd;man/tab_df.Rd;man/tab_fa.Rd;man/tab_itemscale.Rd;man/tab_model.Rd;man/tab_pca.Rd;man/tab_stackfrq.Rd;man/tab_xtab.Rd;man/view_df.Rd,False,True,True,False,10,10,20,"---FILE: R/tab_model.R---
@@ -159,7 +159,7 @@
 #'   or scientific (\code{""scientific""}). Scientific and numeric style can be
 #'   combined with ""stars"", e.g. \code{""numeric_stars""}
 #' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions,
-#'    according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+#'    according to the \href{https://www.w3.org/Style/CSS/}{official CSS syntax}.
 #'    See 'Details' or \href{https://strengejacke.github.io/sjPlot/articles/table_css.html}{this package-vignette}.
 #' @param file Destination file, if the output should be saved as file.
 #'    If \code{NULL} (default), the output will be saved as temporary file and

---FILE: man/tab_corr.Rd---
@@ -75,7 +75,7 @@ where row and column item are identical (i.e. the ""self-correlation""). By defaui
 this argument is \code{NULL} and the diagnal cells are empty.}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
-according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+according to the \href{https://www.w3.org/Style/CSS/}{official CSS syntax}.
 See 'Details' or \href{https://strengejacke.github.io/sjPlot/articles/table_css.html}{this package-vignette}.}
 
 \item{encoding}{Character vector, indicating the charset encoding used

---FILE: man/tab_df.Rd---
@@ -83,7 +83,7 @@ Systems, \code{encoding = ""Windows-1252""} might be necessary for proper
 display of special characters.}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
-according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+according to the \href{https://www.w3.org/Style/CSS/}{official CSS syntax}.
 See 'Details' or \href{https://strengejacke.github.io/sjPlot/articles/table_css.html}{this package-vignette}.}
 
 \item{file}{Destination file, if the output should be saved as file.

---FILE: man/tab_fa.Rd---
@@ -77,7 +77,7 @@ alternatig colors (white and light grey by default).}
 \item{digits}{Amount of decimals for estimates}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
-according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+according to the \href{https://www.w3.org/Style/CSS/}{official CSS syntax}.
 See 'Details' or \href{https://strengejacke.github.io/sjPlot/articles/table_css.html}{this package-vignette}.}
 
 \item{encoding}{Character vector, indicating the charset encoding used

---FILE: man/tab_itemscale.Rd---
@@ -89,7 +89,7 @@ After that, each case (df's row) has a scales sum score for each component.
 Finally, a correlation of these ""scale sum scores"" is computed.}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
-according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+according to the \href{https://www.w3.org/Style/CSS/}{official CSS syntax}.
 See 'Details' or \href{https://strengejacke.github.io/sjPlot/articles/table_css.html}{this package-vignette}.}
 
 \item{encoding}{Character vector, indicating the charset encoding used

---FILE: man/tab_model.Rd---
@@ -372,7 +372,7 @@ naming the specific function, which is passed to the \code{fun}-argument in
 calculate the mean value of the posterior distribution.}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
-according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+according to the \href{https://www.w3.org/Style/CSS/}{official CSS syntax}.
 See 'Details' or \href{https://strengejacke.github.io/sjPlot/articles/table_css.html}{this package-vignette}.}
 
 \item{file}{Destination file, if the output should be saved as file.

---FILE: man/tab_pca.Rd---
@@ -76,7 +76,7 @@ alternatig colors (white and light grey by default).}
 \emph{""Cumulative Proportion""} will be used.}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
-according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+according to the \href{https://www.w3.org/Style/CSS/}{official CSS syntax}.
 See 'Details' or \href{https://strengejacke.github.io/sjPlot/articles/table_css.html}{this package-vignette}.}
 
 \item{encoding}{Character vector, indicating the charset encoding used

---FILE: man/tab_stackfrq.Rd---
@@ -97,7 +97,7 @@ Systems, \code{encoding = ""Windows-1252""} might be necessary for proper
 display of special characters.}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
-according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+according to the \href{https://www.w3.org/Style/CSS/}{official CSS syntax}.
 See 'Details' or \href{https://strengejacke.github.io/sjPlot/articles/table_css.html}{this package-vignette}.}
 
 \item{use.viewer}{Logical, if \code{TRUE}, the HTML table is shown in the IDE's

---FILE: man/tab_xtab.Rd---
@@ -158,7 +158,7 @@ the percentage value.}
 may lead to non-exact results). Default is \code{""100.0""}.}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
-according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+according to the \href{https://www.w3.org/Style/CSS/}{official CSS syntax}.
 See 'Details' or \href{https://strengejacke.github.io/sjPlot/articles/table_css.html}{this package-vignette}.}
 
 \item{encoding}{String, indicating the charset encoding used for variable and

---FILE: man/view_df.Rd---
@@ -89,7 +89,7 @@ or axis labels are displayed in one line and when a line break is inserted.}
 while creating the output.}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
-according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+according to the \href{https://www.w3.org/Style/CSS/}{official CSS syntax}.
 See 'Details' or \href{https://strengejacke.github.io/sjPlot/articles/table_css.html}{this package-vignette}.}
 
 \item{encoding}{Character vector, indicating the charset encoding used"
strengejacke,sjPlot,c06ac087170149736267a5a5648320848c7a20dd,Daniel,mail@danielluedecke.de,2023-03-13T08:33:55Z,Daniel,mail@danielluedecke.de,2023-03-13T08:33:55Z,fix,R/plot_likert.R;man/plot_likert.Rd,False,True,True,False,7,3,10,"---FILE: R/plot_likert.R---
@@ -77,6 +77,7 @@
 #' @return A ggplot-object.
 #'
 #' @examples
+#' if (requireNamespace(""ggrepel"") && requireNamespace(""sjmisc"")) {
 #' library(sjmisc)
 #' data(efc)
 #' # find all variables from COPE-Index, which all have a ""cop"" in their
@@ -138,6 +139,7 @@
 #'   groups = c(1, 1, 1, 2, 2, 2),
 #'   group.legend.options = list(nrow = 1)
 #' )}
+#' }
 #' @import ggplot2
 #' @export
 plot_likert <- function(items,
@@ -199,7 +201,7 @@ plot_likert <- function(items,
   if (sort.groups) findex <- sort(findex)
 
   # Add empty title to plots, to create space for the group.labels
-  if (is.null(title) & length(findex) != 1) title <- rep("""", length(findex))
+  if (is.null(title) && length(findex) != 1) title <- rep("""", length(findex))
 
   .plot_list <- list()
 
@@ -211,9 +213,9 @@ plot_likert <- function(items,
 
     # If there are 2 or more groups, the legend will be plotted according to legend.pos.
     if (length(findex) != 1) {
-      if (legend.pos %in% c(""top"", ""both"") & i == 1)
+      if (legend.pos %in% c(""top"", ""both"") && i == 1)
         .pl <- .pl + theme(legend.position = ""top"") + guides(fill = do.call(guide_legend, group.legend.options))
-      else if (legend.pos %in% c(""bottom"", ""both"") & i == length(findex))
+      else if (legend.pos %in% c(""bottom"", ""both"") && i == length(findex))
         .pl <- .pl + theme(legend.position = ""bottom"") + guides(fill = do.call(guide_legend, group.legend.options))
       else if (legend.pos != ""all"")
         .pl <- .pl + theme(legend.position = ""none"")

---FILE: man/plot_likert.Rd---
@@ -196,6 +196,7 @@ Note that only even numbers of categories are possible to plot, so the ""positive
        with the \code{catcount}-argument.
 }
 \examples{
+if (requireNamespace(""ggrepel"") && requireNamespace(""sjmisc"")) {
 library(sjmisc)
 data(efc)
 # find all variables from COPE-Index, which all have a ""cop"" in their
@@ -258,3 +259,4 @@ plot_likert(
   group.legend.options = list(nrow = 1)
 )}
 }
+}"
strengejacke,sjPlot,1774f8732cb05c4a469e80375ff4d96cf7fe4a65,Daniel,mail@danielluedecke.de,2023-03-13T08:12:45Z,Daniel,mail@danielluedecke.de,2023-03-13T08:12:45Z,fix,DESCRIPTION;R/plot_gpt.R;man/plot_gpt.Rd,False,True,True,False,25,23,48,"---FILE: DESCRIPTION---
@@ -71,5 +71,5 @@ Suggests:
     testthat
 URL: https://strengejacke.github.io/sjPlot/
 BugReports: https://github.com/strengejacke/sjPlot/issues
-RoxygenNote: 7.2.2
+RoxygenNote: 7.2.3
 VignetteBuilder: knitr

---FILE: R/plot_gpt.R---
@@ -41,18 +41,19 @@ utils::globalVariables(""n"")
 #'            and \code{y} for each \code{grp}.
 #'
 #' @examples
-#' data(efc)
+#' if (requireNamespace(""haven"")) {
+#'   data(efc)
 #'
-#' # the proportion of dependency levels in female
-#' # elderly, for each family carer's relationship
-#' # to elderly
-#' plot_gpt(efc, e42dep, e16sex, e15relat)
-#'
-#' # proportion of educational levels in highest
-#' # dependency category of elderly, for different
-#' # care levels
-#' plot_gpt(efc, c172code, e42dep, n4pstu)
+#'   # the proportion of dependency levels in female
+#'   # elderly, for each family carer's relationship
+#'   # to elderly
+#'   plot_gpt(efc, e42dep, e16sex, e15relat)
 #'
+#'   # proportion of educational levels in highest
+#'   # dependency category of elderly, for different
+#'   # care levels
+#'   plot_gpt(efc, c172code, e42dep, n4pstu)
+#' }
 #' @import ggplot2
 #' @export
 plot_gpt <- function(

---FILE: man/plot_gpt.Rd---
@@ -128,16 +128,17 @@ The p-values are based on \code{\link[stats]{chisq.test}} of \code{x}
            and \code{y} for each \code{grp}.
 }
 \examples{
-data(efc)
-
-# the proportion of dependency levels in female
-# elderly, for each family carer's relationship
-# to elderly
-plot_gpt(efc, e42dep, e16sex, e15relat)
-
-# proportion of educational levels in highest
-# dependency category of elderly, for different
-# care levels
-plot_gpt(efc, c172code, e42dep, n4pstu)
-
+if (requireNamespace(""haven"")) {
+  data(efc)
+
+  # the proportion of dependency levels in female
+  # elderly, for each family carer's relationship
+  # to elderly
+  plot_gpt(efc, e42dep, e16sex, e15relat)
+
+  # proportion of educational levels in highest
+  # dependency category of elderly, for different
+  # care levels
+  plot_gpt(efc, c172code, e42dep, n4pstu)
+}
 }"
strengejacke,sjPlot,c79703601cbafe488a7d2c61a10eae2af14275d4,Daniel,mail@danielluedecke.de,2023-03-13T07:45:28Z,Daniel,mail@danielluedecke.de,2023-03-13T07:45:28Z,fix vignette issues,vignettes/plot_interactions.Rmd;vignettes/plot_likert_scales.Rmd;vignettes/plot_marginal_effects.Rmd;vignettes/plot_model_estimates.Rmd,True,False,True,False,4,0,4,"---FILE: vignettes/plot_interactions.Rmd---
@@ -15,6 +15,7 @@ options(width = 800, tibble.width = Inf)
 
 if (!requireNamespace(""sjmisc"", quietly = TRUE) ||
     !requireNamespace(""ggplot2"", quietly = TRUE) ||
+    !requireNamespace(""haven"", quietly = TRUE) ||
     !requireNamespace(""sjlabelled"", quietly = TRUE)) {
   knitr::opts_chunk$set(eval = FALSE)
 }

---FILE: vignettes/plot_likert_scales.Rmd---
@@ -14,6 +14,7 @@ knitr::opts_chunk$set(collapse = TRUE, comment = ""#>"", dev = ""png"", fig.width =
 options(width = 800, tibble.width = Inf)
 if (!requireNamespace(""dplyr"", quietly = TRUE) ||
     !requireNamespace(""sjmisc"", quietly = TRUE) ||
+    !requireNamespace(""haven"", quietly = TRUE) ||
     !requireNamespace(""parameters"", quietly = TRUE)) {
   knitr::opts_chunk$set(eval = FALSE)
 } else {

---FILE: vignettes/plot_marginal_effects.Rmd---
@@ -31,6 +31,7 @@ options(width = 800, tibble.width = Inf)
 if (!requireNamespace(""sjmisc"", quietly = TRUE) ||
     !requireNamespace(""splines"", quietly = TRUE) ||
     !requireNamespace(""ggplot2"", quietly = TRUE) ||
+    !requireNamespace(""haven"", quietly = TRUE) ||
     !requireNamespace(""sjlabelled"", quietly = TRUE)) {
   knitr::opts_chunk$set(eval = FALSE)
 }

---FILE: vignettes/plot_model_estimates.Rmd---
@@ -13,6 +13,7 @@ knitr::opts_chunk$set(collapse = TRUE, comment = ""#>"", dev = ""png"", fig.width =
 
 if (!requireNamespace(""sjlabelled"", quietly = TRUE) ||
     !requireNamespace(""sjmisc"", quietly = TRUE) ||
+    !requireNamespace(""haven"", quietly = TRUE) ||
     !requireNamespace(""ggplot2"", quietly = TRUE)) {
   knitr::opts_chunk$set(eval = FALSE)
 } else {"
strengejacke,sjPlot,6038a4b6fcf39ccf2780bb9a9fd2192d270e1e60,Daniel,mail@danielluedecke.de,2023-03-13T06:53:39Z,Daniel,mail@danielluedecke.de,2023-03-13T06:53:39Z,fix issues with  generics,R/S3-methods.R,False,True,True,False,20,20,40,"---FILE: R/S3-methods.R---
@@ -23,10 +23,10 @@ print.sjTable <- function(x, ...) {
 
 #' @importFrom knitr knit_print asis_output
 #' @export
-knit_print.sjTable <-  function(input, ...) {
-  x <- input$knitr
-  x <- replace_umlauts(x)
-  knitr::asis_output(x)
+knit_print.sjTable <-  function(x, ...) {
+  out <- x$knitr
+  out <- replace_umlauts(out)
+  knitr::asis_output(out)
   # knitr::asis_output(input$knitr)
 }
 
@@ -54,58 +54,58 @@ replace_umlauts <- function(x) {
 # knitr method for grpmean() ----
 
 #' @export
-knit_print.sjt_grpmean <-  function(input, ...) {
-  knitr::asis_output(pgrpmean(input, ...)$knitr)
+knit_print.sjt_grpmean <-  function(x, ...) {
+  knitr::asis_output(pgrpmean(x, ...)$knitr)
 }
 
 #' @export
-knit_print.sjt_grpmeans <-  function(input, ...) {
-  knitr::asis_output(pgrpmeans(input, ...)$knitr)
+knit_print.sjt_grpmeans <-  function(x, ...) {
+  knitr::asis_output(pgrpmeans(x, ...)$knitr)
 }
 
 
 # knitr method method for reliab_test() ----
 
 #' @export
-knit_print.sjt_reliab <-  function(input, ...) {
-  knitr::asis_output(preliab(input, ...)$knitr)
+knit_print.sjt_reliab <-  function(x, ...) {
+  knitr::asis_output(preliab(x, ...)$knitr)
 }
 
 
 # knitr method method for descr() ----
 
 #' @export
-knit_print.sjt_descr <-  function(input, ...) {
-  knitr::asis_output(pdescr(input, ...)$knitr)
+knit_print.sjt_descr <-  function(x, ...) {
+  knitr::asis_output(pdescr(x, ...)$knitr)
 }
 
 #' @export
-knit_print.sjt_grpdescr <-  function(input, ...) {
-  knitr::asis_output(pgdescr(input, ...)$knitr)
+knit_print.sjt_grpdescr <-  function(x, ...) {
+  knitr::asis_output(pgdescr(x, ...)$knitr)
 }
 
 
 # knitr method method for equi_test() ----
 
 #' @export
-knit_print.sjt_descr <-  function(input, ...) {
-  knitr::asis_output(pequi_test(input, ...)$knitr)
+knit_print.sjt_descr <-  function(x, ...) {
+  knitr::asis_output(pequi_test(x, ...)$knitr)
 }
 
 
 # knitr method for frq() ----
 
 #' @export
-knit_print.sjt_frq <-  function(input, ...) {
-  knitr::asis_output(pfrq(input, ...)$knitr)
+knit_print.sjt_frq <-  function(x, ...) {
+  knitr::asis_output(pfrq(x, ...)$knitr)
 }
 
 
 # knitr method for mwu() ----
 
 #' @export
-knit_print.sjt_mwu <-  function(input, ...) {
-  knitr::asis_output(pmwu(input, ...)$knitr)
+knit_print.sjt_mwu <-  function(x, ...) {
+  knitr::asis_output(pmwu(x, ...)$knitr)
 }
 
 "
strengejacke,sjPlot,9a1019ab6e1efe18388f8b558b78a3c7bc84184d,Patrick Bolger,patrick.bolger@nottingham.ac.uk,2023-02-17T15:34:18Z,Patrick Bolger,patrick.bolger@nottingham.ac.uk,2023-02-17T15:34:18Z,Documentation: wording fix for drop.empty in plot_grpfrq,R/plot_grpfrq.R,False,True,True,False,3,4,7,"---FILE: R/plot_grpfrq.R---
@@ -98,10 +98,9 @@
 #'          Use \code{""l""} for upper left corner.
 #' @param axis.titles character vector of length one or two, defining the title(s)
 #'          for the x-axis and y-axis.
-#' @param drop.empty Logical, if \code{TRUE} and the variable's values are labeled,
-#'          values that have no observations are still printed in the table (with
-#'          frequency \code{0}). If \code{FALSE}, values / factor levels with no occurrence
-#'          in the data are omitted from the output.
+#' @param drop.empty Logical, if \code{TRUE} and the variable's values are labeled, values / factor
+#'          levels with no occurrence in the data are omitted from the output. If \code{FALSE},
+#'          labeled values that have no observations are still printed in the table (with frequency \code{0}).
 #' @param auto.group numeric value, indicating the minimum amount of unique values
 #'          in the count variable, at which automatic grouping into smaller units
 #'          is done (see \code{\link[sjmisc]{group_var}}). Default value for"
strengejacke,sjPlot,1ec67c779d8def9ba55847dc97a76304fd224124,Daniel,mail@danielluedecke.de,2022-12-17T08:37:16Z,Daniel,mail@danielluedecke.de,2022-12-17T08:37:16Z,give informative message on error,R/plot_models.R,False,True,True,False,8,0,8,"---FILE: R/plot_models.R---
@@ -127,6 +127,14 @@ plot_models <- function(...,
   if (length(input_list) == 1 && inherits(input_list[[1]], ""list""))
     input_list <- purrr::map(input_list[[1]], ~ .x)
 
+  # check input if really models
+  is_model <- vapply(input_list, insight::is_model, logical(1))
+  if (!all(is_model)) {
+    insight::format_error(
+      ""Some of the provided objects were not recognized as regression models."",
+      ""Maybe you are using invalid function arguments? Please check the documentation (`?plot_models`) and your code.""
+    )
+  }
 
   # get info on model family
   fam.info <- insight::model_info(input_list[[1]])"
strengejacke,sjPlot,50d34019d0001daacd79228abb3c55a578f74c08,Daniel,mail@danielluedecke.de,2022-10-06T12:08:03Z,Daniel,mail@danielluedecke.de,2022-10-06T12:08:03Z,fix for parameters changes,NEWS.md;R/plot_model.R;R/tab_model.R;man/plot_model.Rd;man/tab_model.Rd,False,True,True,False,13,12,25,"---FILE: NEWS.md---
@@ -1,3 +1,10 @@
+# sjPlot 2.8.11
+
+## General
+
+* Minor changes to work properly with updates of upstream packages and 
+  various smaller bug fixes and improvements.
+
 # sjPlot 2.8.10
 
 ## General

---FILE: R/plot_model.R---
@@ -188,9 +188,8 @@
 #' @param se Logical, if \code{TRUE}, the standard errors are
 #'   also printed. If robust standard errors are required, use arguments
 #'   \code{vcov.fun}, \code{vcov.type} and \code{vcov.args} (see
-#'   \code{\link[parameters]{standard_error_robust}} and
-#'   \href{https://easystats.github.io/parameters/articles/model_parameters_robust.html}{this vignette}
-#'   for details), or use argument \code{robust} as shortcut. \code{se} overrides
+#'   \code{\link[parameters]{standard_error}} for details), or use argument
+#'   \code{robust} as shortcut. \code{se} overrides
 #'   \code{ci.lvl}: if not \code{NULL}, arguments \code{ci.lvl} and \code{transform}
 #'   will be ignored. Currently, \code{se} only applies to \emph{Coefficients} plots.
 #' @param show.intercept Logical, if \code{TRUE}, the intercept of the fitted

---FILE: R/tab_model.R---
@@ -72,9 +72,7 @@
 #' @param show.se Logical, if \code{TRUE}, the standard errors are
 #'   also printed. If robust standard errors are required, use arguments
 #'   \code{vcov.fun}, \code{vcov.type} and \code{vcov.args} (see
-#'   \code{\link[parameters]{standard_error_robust}} and
-#'   \href{https://easystats.github.io/parameters/articles/model_parameters_robust.html}{this vignette}
-#'   for details).
+#'   \code{\link[parameters]{standard_error}} for details).
 #' @param show.r2 Logical, if \code{TRUE}, the r-squared value is also printed.
 #'    Depending on the model, these might be pseudo-r-squared values, or Bayesian
 #'    r-squared etc. See \code{\link[performance]{r2}} for details.

---FILE: man/plot_model.Rd---
@@ -287,9 +287,8 @@ such cases. See \code{prob.inner} and \code{prob.outer} under the
 \item{se}{Logical, if \code{TRUE}, the standard errors are
 also printed. If robust standard errors are required, use arguments
 \code{vcov.fun}, \code{vcov.type} and \code{vcov.args} (see
-\code{\link[parameters]{standard_error_robust}} and
-\href{https://easystats.github.io/parameters/articles/model_parameters_robust.html}{this vignette}
-for details), or use argument \code{robust} as shortcut. \code{se} overrides
+\code{\link[parameters]{standard_error}} for details), or use argument
+\code{robust} as shortcut. \code{se} overrides
 \code{ci.lvl}: if not \code{NULL}, arguments \code{ci.lvl} and \code{transform}
 will be ignored. Currently, \code{se} only applies to \emph{Coefficients} plots.}
 

---FILE: man/tab_model.Rd---
@@ -112,9 +112,7 @@ credible interval is added to the table output.}
 \item{show.se}{Logical, if \code{TRUE}, the standard errors are
 also printed. If robust standard errors are required, use arguments
 \code{vcov.fun}, \code{vcov.type} and \code{vcov.args} (see
-\code{\link[parameters]{standard_error_robust}} and
-\href{https://easystats.github.io/parameters/articles/model_parameters_robust.html}{this vignette}
-for details).}
+\code{\link[parameters]{standard_error}} for details).}
 
 \item{show.std}{Indicates whether standardized beta-coefficients should
 also printed, and if yes, which type of standardization is done."
strengejacke,sjPlot,b2eb112a8bbb00cc93faed2d37e3e1ced1bd5ecb,Daniel,mail@danielluedecke.de,2022-08-06T20:19:28Z,Daniel,mail@danielluedecke.de,2022-08-06T20:19:28Z,fix check issues,DESCRIPTION;R/plot_models.R;R/tab_model.R,False,True,True,False,3,3,6,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 2.8.10.2
+Version: 2.8.11
 Authors@R: c(
     person(""Daniel"", ""Ldecke"", email = ""d.luedecke@uke.de"", role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0002-8895-3206"")),
     person(""Alexander"", ""Bartel"", role = ""ctb"", comment = c(ORCID = ""0000-0002-1280-6138"")),

---FILE: R/plot_models.R---
@@ -124,7 +124,7 @@ plot_models <- function(...,
   if (missing(value.size) || is.null(value.size)) value.size <- 4
 
   # check length. if we have a list of fitted model, we need to ""unlist"" them
-  if (length(input_list) == 1 && class(input_list[[1]]) == ""list"")
+  if (length(input_list) == 1 && inherits(input_list[[1]], ""list""))
     input_list <- purrr::map(input_list[[1]], ~ .x)
 
 

---FILE: R/tab_model.R---
@@ -370,7 +370,7 @@ tab_model <- function(
 
   models <- list(...)
 
-  if (length(class(models[[1]])) == 1 && class(models[[1]]) == ""list"")
+  if (length(class(models[[1]])) == 1 && inherits(models[[1]], ""list""))
     models <- lapply(models[[1]], function(x) x)
 
   names(models) <- unlist(lapply("
strengejacke,sjPlot,f2eaf679b754cf86f402e77e93cae03d93655b0e,Daniel,mail@danielluedecke.de,2022-08-06T20:15:55Z,Daniel,mail@danielluedecke.de,2022-08-06T20:15:55Z,fixes,.Rbuildignore;NEWS.md,False,False,False,False,6,1,7,"---FILE: .Rbuildignore---
@@ -9,3 +9,8 @@
 ^Meta$
 ^pkgdown$
 ^.github$
+
+\.code-workspace$
+\.lintr$
+^CRAN-SUBMISSION$
+^cran-comments.md$
\ No newline at end of file

---FILE: NEWS.md---
@@ -130,7 +130,7 @@
 
 ## General
 
-* Standardization of model parameters (in `plot_model()` or `tab_model()`) now uses standardization based on refitting the model (see [vignette](https://easystats.github.io/effectsize/articles/standardize_parameters.html) for details).
+* Standardization of model parameters (in `plot_model()` or `tab_model()`) now uses standardization based on refitting the model (see [vignette](https://easystats.github.io/parameters/articles/model_parameters_standardized.html) for details).
 
 ## Changes to functions
 "
strengejacke,sjPlot,3339370e552b8bce3a8e20efb4cac9a2e8a49592,Daniel,mail@danielluedecke.de,2022-08-06T16:46:19Z,Daniel,mail@danielluedecke.de,2022-08-06T16:46:19Z,fix datawizard issues,.lintr;DESCRIPTION;R/plot_kfold_cv.R;man/plot_kfold_cv.Rd;man/tab_model.Rd;man/tab_stackfrq.Rd;sjPlot.code-workspace,False,True,True,False,36,14,50,"---FILE: .lintr---
@@ -0,0 +1,6 @@
+linters: with_defaults(object_name_linter = NULL,
+                       object_length_linter(40),
+                       commented_code_linter = NULL,
+                       object_usage_linter = NULL,
+                       line_length_linter(120),
+                       cyclocomp_linter = cyclocomp_linter(20))

---FILE: DESCRIPTION---
@@ -71,6 +71,6 @@ Suggests:
     testthat
 URL: https://strengejacke.github.io/sjPlot/
 BugReports: https://github.com/strengejacke/sjPlot/issues
-RoxygenNote: 7.1.2
+RoxygenNote: 7.2.1
 VignetteBuilder: knitr
 Remotes: easystats/parameters

---FILE: R/plot_kfold_cv.R---
@@ -2,8 +2,8 @@
 #' @name plot_kfold_cv
 #'
 #' @description This function plots the aggregated residuals of k-fold cross-validated
-#'                models against the outcome. This allows to evaluate how the model performs
-#'                according over- or underestimation of the outcome.
+#'   models against the outcome. This allows to evaluate how the model performs
+#'   according over- or underestimation of the outcome.
 #'
 #' @param data A data frame, used to split the data into \code{k} training-test-pairs.
 #' @param formula A model formula, used to fit linear models (\code{\link[stats]{lm}})
@@ -82,7 +82,7 @@ plot_kfold_cv <- function(data, formula, k = 5, fit) {
       # pair, get deviance residuals and response value
       kfolds <- do.call(rbind, lapply(1:k, function(i) {
         out <- datawizard::data_partition(data, training_proportion = .8)
-        data.frame(train = I(list(out$training)), test = I(list(out$test)))
+        data.frame(train = I(list(out[[1]])), test = I(list(out$test)))
       }))
       res <- kfolds %>%
         dplyr::mutate(model = purrr::map(.data$train, ~ stats::glm(formula, data = .x, family = stats::poisson(link = ""log"")))) %>%
@@ -94,7 +94,7 @@ plot_kfold_cv <- function(data, formula, k = 5, fit) {
       # pair, get deviance residuals and response value
       kfolds <- do.call(rbind, lapply(1:k, function(i) {
         out <- datawizard::data_partition(data, training_proportion = .8)
-        data.frame(train = I(list(out$training)), test = I(list(out$test)))
+        data.frame(train = I(list(out[[1]])), test = I(list(out$test)))
       }))
       res <- kfolds %>%
         dplyr::mutate(model = purrr::map(.data$train, ~ MASS::glm.nb(formula, data = .))) %>%
@@ -111,7 +111,7 @@ plot_kfold_cv <- function(data, formula, k = 5, fit) {
     # train data
     kfolds <- do.call(rbind, lapply(1:k, function(i) {
       out <- datawizard::data_partition(data, training_proportion = .8)
-      data.frame(train = I(list(out$training)), test = I(list(out$test)))
+      data.frame(train = I(list(out[[1]])), test = I(list(out$test)))
     }))
     res <- kfolds %>%
       dplyr::mutate(model = purrr::map(.data$train, ~ stats::lm(formula, data = .))) %>%

---FILE: man/plot_kfold_cv.Rd---
@@ -23,8 +23,8 @@ only linear, poisson and negative binomial regression models are supported.}
 }
 \description{
 This function plots the aggregated residuals of k-fold cross-validated
-               models against the outcome. This allows to evaluate how the model performs
-               according over- or underestimation of the outcome.
+  models against the outcome. This allows to evaluate how the model performs
+  according over- or underestimation of the outcome.
 }
 \details{
 This function, first, generates \code{k} cross-validated test-training

---FILE: man/tab_model.Rd---
@@ -64,8 +64,8 @@ tab_model(
   collapse.ci = FALSE,
   collapse.se = FALSE,
   linebreak = TRUE,
-  col.order = c(""est"", ""se"", ""std.est"", ""std.se"", ""ci"", ""std.ci"", ""ci.inner"",
-    ""ci.outer"", ""stat"", ""std.stat"", ""p"", ""std.p"", ""df.error"", ""response.level""),
+  col.order = c(""est"", ""se"", ""std.est"", ""std.se"", ""ci"", ""std.ci"", ""ci.inner"", ""ci.outer"",
+    ""stat"", ""std.stat"", ""p"", ""std.p"", ""df.error"", ""response.level""),
   digits = 2,
   digits.p = 3,
   digits.rsq = 3,

---FILE: man/tab_stackfrq.Rd---
@@ -36,10 +36,7 @@ tab_stackfrq(
 Must be a vector of same length as the input vector. Default is
 \code{NULL}, so no weights are used.}
 
-\item{title}{Character vector with table
-caption(s) resp. footnote(s). For  \code{tab_df()}, must be a character
-of length 1; for \code{tab_dfs()}, a character vector of same length as
-\code{x} (i.e. one title or footnote per data frame).}
+\item{title}{String, will be used as table caption.}
 
 \item{var.labels}{Character vector with variable names, which will be used
 to label variables in the output.}

---FILE: sjPlot.code-workspace---
@@ -0,0 +1,19 @@
+{
+	""folders"": [
+		{
+			""path"": "".""
+		}
+  ],
+  ""launch"": {
+    ""version"": ""0.2.0"",
+    ""configurations"": [
+    {
+      ""type"": ""R-Debugger"",
+      ""name"": ""Launch R-Workspace"",
+      ""request"": ""launch"",
+      ""debugMode"": ""workspace"",
+      ""workingDirectory"": """"
+    }
+    ]
+  }
+}
\ No newline at end of file"
strengejacke,sjPlot,c2012fded7718ff5b75c38304d483470efd27f1d,Douglas Whitaker,douglas.whitaker@gmail.com,2022-07-16T22:51:33Z,Douglas Whitaker,douglas.whitaker@gmail.com,2022-07-16T22:51:33Z,Fix for issue #841,R/plot_stackfrq.R,False,True,True,False,1,1,2,"---FILE: R/plot_stackfrq.R---
@@ -197,7 +197,7 @@ plot_stackfrq <- function(items,
 
   if (is.null(legend.labels)) {
     legend.labels <- as.character(sort(unique(unlist(
-      apply(items, 2, function(x) unique(stats::na.omit(x)))))))
+      apply(items, 2, function(x) unique(stats::na.omit(x)), simplify = FALSE)))))
   }
 
   # if we have legend labels, we know the exact"
strengejacke,sjPlot,336360b0018147cec1eba16d7bb195632cc9c2f3,Daniel,mail@danielluedecke.de,2022-05-16T15:21:14Z,Daniel,mail@danielluedecke.de,2022-05-16T15:21:14Z,check issues,R/html_print.R;man/tab_df.Rd,False,True,True,False,3,0,3,"---FILE: R/html_print.R---
@@ -33,6 +33,7 @@
 #'   alternatig colors (white and light grey by default).
 #' @param digits Numeric, amount of digits after decimal point when rounding
 #'   values.
+#' @param rnames Character vector, can be used to set row names when \code{show.rownames=TRUE}.
 #' @param ... Currently not used.
 #'
 #' @inheritParams tab_model

---FILE: man/tab_df.Rd---
@@ -95,6 +95,8 @@ viewer pane. If \code{FALSE} or no viewer available, the HTML table is
 opened in a web browser.}
 
 \item{...}{Currently not used.}
+
+\item{rnames}{Character vector, can be used to set row names when \code{show.rownames=TRUE}.}
 }
 \value{
 A list with following items:"
strengejacke,sjPlot,d8cd8cd3be8605916c7b621753970c5af7bf9948,Daniel,mail@danielluedecke.de,2021-12-17T12:35:02Z,Daniel,mail@danielluedecke.de,2021-12-17T12:35:02Z,fix issue with missing rownames,DESCRIPTION;R/html_print.R,False,True,True,False,11,1,12,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 2.8.10
+Version: 2.8.10.1
 Authors@R: c(
     person(""Daniel"", ""Ldecke"", email = ""d.luedecke@uke.de"", role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0002-8895-3206"")),
     person(""Alexander"", ""Bartel"", role = ""ctb"", comment = c(ORCID = ""0000-0002-1280-6138"")),

---FILE: R/html_print.R---
@@ -187,6 +187,7 @@ tab_dfs <- function(x,
                     CSS = NULL,
                     file = NULL,
                     use.viewer = TRUE,
+                    rnames = NULL,
                     ...) {
 
   # make sure list elements in CSS argument have proper name attribute
@@ -217,6 +218,14 @@ tab_dfs <- function(x,
             .i
         })
 
+        if (isTRUE(show.rownames)) {
+          if (!is.null(rnames)) {
+            tmp_rnames <- rnames
+          } else {
+            tmp_rnames <- row.names(dat)
+          }
+        }
+
         tab_df_content(
           mydf = dat,
           title = title,
@@ -228,6 +237,7 @@ tab_dfs <- function(x,
           altr.row.col = alternate.rows,
           sort.column = sort.column,
           include.table.tag = TRUE,
+          rnames = tmp_rnames,
           ...
         )
       })),"
strengejacke,sjPlot,8bdf864ab464b33c6ceed951c837a081570b4b00,Daniel,mail@danielluedecke.de,2021-11-23T22:06:05Z,Daniel,mail@danielluedecke.de,2021-11-23T22:06:05Z,fix tests,DESCRIPTION;tests/testthat/test-plot_grpfrq.R;tests/testthat/test-tab_model.R;vignettes/blackwhitefigures.Rmd;vignettes/custplot.Rmd;vignettes/plot_interactions.Rmd;vignettes/plot_marginal_effects.Rmd,True,True,True,False,33,0,33,"---FILE: DESCRIPTION---
@@ -65,6 +65,7 @@ Suggests:
     rmarkdown,
     rstanarm,
     sandwich,
+    splines,
     survey,
     TMB,
     testthat

---FILE: tests/testthat/test-plot_grpfrq.R---
@@ -1,5 +1,7 @@
 if (suppressWarnings(
   require(""testthat"") &&
+  require(""sjlabelled"") &&
+  require(""haven"") &&
   require(""sjPlot"")
 )) {
 

---FILE: tests/testthat/test-tab_model.R---
@@ -3,6 +3,8 @@
 if (suppressWarnings(
   require(""testthat"") &&
   require(""sjPlot"") &&
+  require(""sjlabelled"") &&
+  require(""haven"") &&
   require(""sjmisc"") &&
   require(""lme4"") &&
   require(""glmmTMB"") &&

---FILE: vignettes/blackwhitefigures.Rmd---
@@ -10,6 +10,13 @@ vignette: >
 ---
 ```{r echo = FALSE}
 knitr::opts_chunk$set(collapse = TRUE, comment = ""#>"", dev = ""png"", fig.width = 7, fig.height = 5, message = FALSE, warning = FALSE)
+
+if (!requireNamespace(""sjmisc"", quietly = TRUE) ||
+    !requireNamespace(""haven"", quietly = TRUE) ||
+    !requireNamespace(""ggplot2"", quietly = TRUE) ||
+    !requireNamespace(""sjlabelled"", quietly = TRUE)) {
+  knitr::opts_chunk$set(eval = FALSE)
+}
 ```
 
 This document shows examples how to create b/w figures, e.g. if you don't want colored figures for print-journals.

---FILE: vignettes/custplot.Rmd---
@@ -11,6 +11,13 @@ vignette: >
 
 ```{r echo = FALSE}
 knitr::opts_chunk$set(collapse = TRUE, comment = ""#>"", fig.width = 7, fig.height = 5, warning = FALSE, message = FALSE)
+
+if (!requireNamespace(""sjmisc"", quietly = TRUE) ||
+    !requireNamespace(""haven"", quietly = TRUE) ||
+    !requireNamespace(""ggplot2"", quietly = TRUE) ||
+    !requireNamespace(""sjlabelled"", quietly = TRUE)) {
+  knitr::opts_chunk$set(eval = FALSE)
+}
 ```
 
 

---FILE: vignettes/plot_interactions.Rmd---
@@ -12,6 +12,12 @@ vignette: >
 ```{r set-options, echo = FALSE}
 knitr::opts_chunk$set(collapse = TRUE, comment = ""#>"", dev = ""png"", fig.width = 7, fig.height = 3.5, message = FALSE, warning = FALSE)
 options(width = 800, tibble.width = Inf)
+
+if (!requireNamespace(""sjmisc"", quietly = TRUE) ||
+    !requireNamespace(""ggplot2"", quietly = TRUE) ||
+    !requireNamespace(""sjlabelled"", quietly = TRUE)) {
+  knitr::opts_chunk$set(eval = FALSE)
+}
 ```
 
 This document describes how to plot marginal effects of interaction terms from various regression models, using the `plot_model()` function. `plot_model()` is a generic plot-function, which accepts many model-objects, like `lm`, `glm`, `lme`, `lmerMod` etc.

---FILE: vignettes/plot_marginal_effects.Rmd---
@@ -27,6 +27,14 @@ knitr::opts_chunk$set(
   # eval = if (isTRUE(exists(""params""))) params$EVAL else FALSE
 )
 options(width = 800, tibble.width = Inf)
+
+if (!requireNamespace(""sjmisc"", quietly = TRUE) ||
+    !requireNamespace(""splines"", quietly = TRUE) ||
+    !requireNamespace(""ggplot2"", quietly = TRUE) ||
+    !requireNamespace(""sjlabelled"", quietly = TRUE)) {
+  knitr::opts_chunk$set(eval = FALSE)
+}
+
 ```
 
 This document describes how to plot marginal effects of various regression models, using the `plot_model()` function. `plot_model()` is a generic plot-function, which accepts many model-objects, like `lm`, `glm`, `lme`, `lmerMod` etc."
strengejacke,sjPlot,716147053d948006035e60b60e8c81b74bf5e325,Daniel,mail@danielluedecke.de,2021-11-23T21:58:59Z,Daniel,mail@danielluedecke.de,2021-11-23T21:58:59Z,fix test,.github/workflows/R-check.yaml;DESCRIPTION;tests/testthat/test-plot_model_std.R,False,True,True,False,6,3,9,"---FILE: .github/workflows/R-check.yaml---
@@ -24,9 +24,9 @@ jobs:
           - {os: windows-latest, r: 'devel'}
           - {os: windows-latest, r: 'release'}
           - {os: windows-latest, r: 'oldrel'}
-          - {os: ubuntu-16.04,   r: 'devel', rspm: ""https://packagemanager.rstudio.com/cran/__linux__/xenial/latest""}
-          - {os: ubuntu-16.04,   r: 'release', rspm: ""https://packagemanager.rstudio.com/cran/__linux__/xenial/latest""}
-          - {os: ubuntu-16.04,   r: 'oldrel',  rspm: ""https://packagemanager.rstudio.com/cran/__linux__/xenial/latest""}
+          - {os: ubuntu-18.04,   r: 'devel'}
+          - {os: ubuntu-18.04,   r: 'release'}
+          - {os: ubuntu-18.04,   r: 'oldrel'}
 
     env:
       R_REMOTES_NO_ERRORS_FROM_WARNINGS: true

---FILE: DESCRIPTION---
@@ -51,6 +51,7 @@ Suggests:
     clubSandwich,
     cluster,
     cowplot,
+    haven,
     GPArotation,
     ggrepel,
     glmmTMB,

---FILE: tests/testthat/test-plot_model_std.R---
@@ -4,6 +4,8 @@ if (suppressWarnings(
   require(""testthat"") &&
   require(""sjPlot"") &&
   require(""sjmisc"") &&
+  require(""sjlabelled"") &&
+  require(""haven"") &&
   require(""lme4"")
 )) {
   context(""sjPlot, tab_model type std"")"
strengejacke,sjPlot,e5f4beeba2dfab435d5f8f8b9d38b38eba969558,Daniel,mail@danielluedecke.de,2021-07-10T07:22:37Z,Daniel,mail@danielluedecke.de,2021-07-10T07:22:37Z,fix check issues,DESCRIPTION;NAMESPACE;NEWS.md;R/plot_model.R;R/tab_stackfrq.R;man/plot_model.Rd;vignettes/plot_model_estimates.Rmd;vignettes/tab_model_estimates.Rmd,True,True,True,False,35,6,41,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 2.8.8
+Version: 2.8.9
 Authors@R: c(
     person(""Daniel"", ""Ldecke"", email = ""d.luedecke@uke.de"", role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0002-8895-3206"")),
     person(""Alexander"", ""Bartel"", role = ""ctb"", comment = c(ORCID = ""0000-0002-1280-6138"")),

---FILE: NAMESPACE---
@@ -70,6 +70,7 @@ import(ggplot2)
 importFrom(MASS,glm.nb)
 importFrom(bayestestR,ci)
 importFrom(datawizard,data_partition)
+importFrom(datawizard,skewness)
 importFrom(dplyr,""%>%"")
 importFrom(dplyr,arrange)
 importFrom(dplyr,between)
@@ -121,7 +122,6 @@ importFrom(parameters,closest_component)
 importFrom(parameters,kurtosis)
 importFrom(parameters,model_parameters)
 importFrom(parameters,principal_components)
-importFrom(parameters,skewness)
 importFrom(performance,cronbachs_alpha)
 importFrom(performance,item_intercor)
 importFrom(performance,item_reliability)

---FILE: NEWS.md---
@@ -1,3 +1,9 @@
+# sjPlot 2.8.9
+
+## Bug fixes
+
+* Fixed issues from CRAN checks.
+
 # sjPlot 2.8.8
 
 ## Changes to functions

---FILE: R/plot_model.R---
@@ -432,7 +432,7 @@
 #' plot_grid(p)}
 #'
 #' # plot random effects
-#' if (require(""lme4"")) {
+#' if (require(""lme4"") && require(""glmmTMB"")) {
 #'   m <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
 #'   plot_model(m, type = ""re"")
 #'

---FILE: R/tab_stackfrq.R---
@@ -89,7 +89,8 @@
 #'                           css.summary = ""font-style:italic;""))
 #' }
 #' }
-#' @importFrom parameters skewness kurtosis
+#' @importFrom parameters kurtosis
+#' @importFrom datawizard skewness
 #' @importFrom sjmisc frq
 #' @export
 tab_stackfrq <- function(items,
@@ -181,7 +182,7 @@ tab_stackfrq <- function(items,
   # ----------------------------
   # additional statistics required from psych-package?
   # ----------------------------
-  if (show.skew) pstat_skewness <- parameters::skewness(items)
+  if (show.skew) pstat_skewness <- datawizard::skewness(items)
   if (show.kurtosis) pstat_kurtosis <- parameters::kurtosis(items)
   if (is.null(weight.by)) {
     dummy <- sjmisc::frq(items, show.strings = TRUE, show.na = show.na)

---FILE: man/plot_model.Rd---
@@ -552,7 +552,7 @@ p <- plot_model(m, type = ""diag"")
 plot_grid(p)}
 
 # plot random effects
-if (require(""lme4"")) {
+if (require(""lme4"") && require(""glmmTMB"")) {
   m <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
   plot_model(m, type = ""re"")
 

---FILE: vignettes/plot_model_estimates.Rmd---
@@ -10,6 +10,16 @@ vignette: >
 ---
 ```{r echo = FALSE}
 knitr::opts_chunk$set(collapse = TRUE, comment = ""#>"", dev = ""png"", fig.width = 7, fig.height = 5, message = FALSE, warning = FALSE)
+
+if (!requireNamespace(""sjlabelled"", quietly = TRUE) ||
+    !requireNamespace(""sjmisc"", quietly = TRUE) ||
+    !requireNamespace(""ggplot2"", quietly = TRUE)) {
+  knitr::opts_chunk$set(eval = FALSE)
+} else {
+  knitr::opts_chunk$set(eval = TRUE)
+  library(sjPlot)
+}
+
 ```
 
 This document describes how to plot estimates as forest plots (or dot whisker plots) of various regression models, using the `plot_model()` function. `plot_model()` is a generic plot-function, which accepts many model-objects, like `lm`, `glm`, `lme`, `lmerMod` etc.

---FILE: vignettes/tab_model_estimates.Rmd---
@@ -11,6 +11,18 @@ vignette: >
 
 ```{r echo = FALSE}
 knitr::opts_chunk$set(collapse = TRUE, comment = ""#>"", warning = FALSE, message = FALSE)
+
+if (!requireNamespace(""sjlabelled"", quietly = TRUE) ||
+    !requireNamespace(""sjmisc"", quietly = TRUE) ||
+    !requireNamespace(""lme4"", quietly = TRUE) ||
+    !requireNamespace(""pscl"", quietly = TRUE) ||
+    !requireNamespace(""glmmTMB"", quietly = TRUE)) {
+  knitr::opts_chunk$set(eval = FALSE)
+} else {
+  knitr::opts_chunk$set(eval = TRUE)
+  library(sjPlot)
+}
+
 ```
 
 `tab_model()` is the pendant to `plot_model()`, however, instead of creating plots, `tab_model()` creates HTML-tables that will be displayed either in your IDE's viewer-pane, in a web browser or in a knitr-markdown-document (like this vignette)."
strengejacke,sjPlot,af51e00a2d5c657b7c8fdedae509a37b8724c7bb,Mairead Shaw,mairead.shaw@mail.mcgill.ca,2021-02-22T22:52:56Z,GitHub,noreply@github.com,2021-02-22T22:52:56Z,"Update README.md

Small typo fixes.",README.md,False,False,False,False,3,3,6,"---FILE: README.md---
@@ -10,16 +10,16 @@ Collection of plotting and table output functions for data visualization. Result
 
 ### Latest development build
 
-To install the latest development snapshot (see latest changes below), type following commands into the R console:
+To install the latest development snapshot (see latest changes below), type the following commands into the R console:
 
 ```r
 library(devtools)
 devtools::install_github(""strengejacke/sjPlot"")
 ```
 
-### Officiale, stable release
+### Official, stable release
 
-To install the latest stable release from CRAN, type following command into the R console:
+To install the latest stable release from CRAN, type the following command into the R console:
 
 ```r
 install.packages(""sjPlot"")"
strengejacke,sjPlot,a1c9c0c0508fbc847819e8d4ea70c358d44471db,Daniel,mail@danielluedecke.de,2021-01-09T14:10:24Z,Daniel,mail@danielluedecke.de,2021-01-09T14:10:24Z,fix rd,R/plot_kfold_cv.R;man/plot_kfold_cv.Rd;man/tab_model.Rd,False,True,True,False,3,3,6,"---FILE: R/plot_kfold_cv.R---
@@ -17,7 +17,7 @@
 #'          only linear, poisson and negative binomial regression models are supported.
 #'
 #' @details This function, first, generates \code{k} cross-validated test-training
-#'            pairs (using the \code{\link[modelr]{crossv_kfold}}-function) and
+#'            pairs and
 #'            fits the same model, specified in the \code{formula}- or \code{fit}-
 #'            argument, over all training data sets. \cr \cr
 #'            Then, the test data is used to predict the outcome from all

---FILE: man/plot_kfold_cv.Rd---
@@ -28,7 +28,7 @@ This function plots the aggregated residuals of k-fold cross-validated
 }
 \details{
 This function, first, generates \code{k} cross-validated test-training
-           pairs (using the \code{\link[modelr]{crossv_kfold}}-function) and
+           pairs and
            fits the same model, specified in the \code{formula}- or \code{fit}-
            argument, over all training data sets. \cr \cr
            Then, the test data is used to predict the outcome from all

---FILE: man/tab_model.Rd---
@@ -328,7 +328,7 @@ annotating p-values with asterisks. Only applies if
 to adjust p-values. See \code{\link[stats]{p.adjust}} for details.}
 
 \item{case}{Desired target case. Labels will automatically converted into the
-specified character case. See \code{\link[snakecase]{to_any_case}} for more
+specified character case. See \code{snakecase::to_any_case()} for more
 details on this argument. By default, if \code{case} is not specified,
 it will be set to \code{""parsed""}, unless \code{prefix.labels} is not
 \code{""none""}. If \code{prefix.labels} is either \code{""label""} (or"
strengejacke,sjPlot,4fd93b1f0e898dfd9f418753405f2d575d5dd467,Daniel,mail@danielluedecke.de,2021-01-09T14:10:06Z,Daniel,mail@danielluedecke.de,2021-01-09T14:10:06Z,fix crossref,R/plot_frq.R;R/plot_grpfrq.R;R/plot_model.R;man/plot_frq.Rd;man/plot_gpt.Rd;man/plot_grpfrq.Rd;man/plot_model.Rd;man/plot_models.Rd;man/plot_scatter.Rd,False,True,True,False,13,13,26,"---FILE: R/plot_frq.R---
@@ -13,7 +13,7 @@ utils::globalVariables(""density"")
 #'   further processing. Required, if \code{data} is a data frame (and no
 #'   vector) and only selected variables from \code{data} should be processed.
 #'   You may also use functions like \code{:} or tidyselect's
-#'   \code{\link[tidyselect]{select_helpers}}.
+#'   select_helpers.
 #' @param sort.frq Determines whether categories should be sorted
 #'          according to their frequencies or not. Default is \code{""none""}, so
 #'          categories are not sorted by frequency. Use \code{""asc""} or

---FILE: R/plot_grpfrq.R---
@@ -133,7 +133,7 @@
 #'            \item If not specified, a default color brewer palette will be used, which is suitable for the plot style (i.e. diverging for likert scales, qualitative for grouped bars etc.).
 #'            \item If \code{""gs""}, a greyscale will be used.
 #'            \item If \code{""bw""}, and plot-type is a line-plot, the plot is black/white and uses different line types to distinguish groups (see \href{https://strengejacke.github.io/sjPlot/articles/blackwhitefigures.html}{this package-vignette}).
-#'            \item If \code{geom.colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
+#'            \item If \code{geom.colors} is any valid color brewer palette name, the related palette will be used. Use \code{RColorBrewer::display.brewer.all()} to view all available palette names.
 #'            \item Else specify own color values or names as vector (e.g. \code{geom.colors = c(""#f00000"", ""#00ff00"")}).
 #'          }
 #'

---FILE: R/plot_model.R---
@@ -231,7 +231,7 @@
 #'     \item If not specified, a default color brewer palette will be used, which is suitable for the plot style.
 #'     \item If \code{""gs""}, a greyscale will be used.
 #'     \item If \code{""bw""}, and plot-type is a line-plot, the plot is black/white and uses different line types to distinguish groups (see \href{https://strengejacke.github.io/sjPlot/articles/blackwhitefigures.html}{this package-vignette}).
-#'     \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
+#'     \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{RColorBrewer::display.brewer.all()} to view all available palette names.
 #'     \item There are some pre-defined color palettes in this package, see \code{\link{sjPlot-themes}} for details.
 #'     \item Else specify own color values or names as vector (e.g. \code{colors = ""#00ff00""} or \code{colors = c(""firebrick"", ""blue"")}).
 #'   }
@@ -245,7 +245,7 @@
 #' @param wrap.labels Numeric, determines how many chars of the value, variable
 #'   or axis labels are displayed in one line and when a line break is inserted.
 #' @param case Desired target case. Labels will automatically converted into the
-#'   specified character case. See \code{\link[snakecase]{to_any_case}} for more
+#'   specified character case. See \code{snakecase::to_any_case()} for more
 #'   details on this argument. By default, if \code{case} is not specified,
 #'   it will be set to \code{""parsed""}, unless \code{prefix.labels} is not
 #'   \code{""none""}. If \code{prefix.labels} is either \code{""label""} (or
@@ -327,7 +327,7 @@
 #'     }
 #'     \item{Case conversion of labels}{For case conversion of labels (see argument
 #'       \code{case}), arguments \code{sep_in} and \code{sep_out} will be passed
-#'       down to \code{\link[snakecase]{to_any_case}}. This only
+#'       down to \code{snakecase::to_any_case()}. This only
 #'       applies to automatically retrieved term labels, \emph{not} if
 #'       term labels are provided by the \code{axis.labels}-argument.
 #'     }

---FILE: man/plot_frq.Rd---
@@ -55,7 +55,7 @@ plot_frq(
 further processing. Required, if \code{data} is a data frame (and no
 vector) and only selected variables from \code{data} should be processed.
 You may also use functions like \code{:} or tidyselect's
-\code{\link[tidyselect]{select_helpers}}.}
+select_helpers.}
 
 \item{title}{Character vector, used as plot title. By default,
 \code{\link[sjlabelled]{response_labels}} is called to retrieve the label of

---FILE: man/plot_gpt.Rd---
@@ -50,7 +50,7 @@ color palette. Following options are valid for the \code{colors} argument:
   \item If not specified, a default color brewer palette will be used, which is suitable for the plot style.
   \item If \code{""gs""}, a greyscale will be used.
   \item If \code{""bw""}, and plot-type is a line-plot, the plot is black/white and uses different line types to distinguish groups (see \href{https://strengejacke.github.io/sjPlot/articles/blackwhitefigures.html}{this package-vignette}).
-  \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
+  \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{RColorBrewer::display.brewer.all()} to view all available palette names.
   \item There are some pre-defined color palettes in this package, see \code{\link{sjPlot-themes}} for details.
   \item Else specify own color values or names as vector (e.g. \code{colors = ""#00ff00""} or \code{colors = c(""firebrick"", ""blue"")}).
 }}

---FILE: man/plot_grpfrq.Rd---
@@ -230,7 +230,7 @@ Plot grouped or stacked frequencies of variables as bar/dot,
            \item If not specified, a default color brewer palette will be used, which is suitable for the plot style (i.e. diverging for likert scales, qualitative for grouped bars etc.).
            \item If \code{""gs""}, a greyscale will be used.
            \item If \code{""bw""}, and plot-type is a line-plot, the plot is black/white and uses different line types to distinguish groups (see \href{https://strengejacke.github.io/sjPlot/articles/blackwhitefigures.html}{this package-vignette}).
-           \item If \code{geom.colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
+           \item If \code{geom.colors} is any valid color brewer palette name, the related palette will be used. Use \code{RColorBrewer::display.brewer.all()} to view all available palette names.
            \item Else specify own color values or names as vector (e.g. \code{geom.colors = c(""#f00000"", ""#00ff00"")}).
          }
 }

---FILE: man/plot_model.Rd---
@@ -317,7 +317,7 @@ color palette. Following options are valid for the \code{colors} argument:
   \item If not specified, a default color brewer palette will be used, which is suitable for the plot style.
   \item If \code{""gs""}, a greyscale will be used.
   \item If \code{""bw""}, and plot-type is a line-plot, the plot is black/white and uses different line types to distinguish groups (see \href{https://strengejacke.github.io/sjPlot/articles/blackwhitefigures.html}{this package-vignette}).
-  \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
+  \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{RColorBrewer::display.brewer.all()} to view all available palette names.
   \item There are some pre-defined color palettes in this package, see \code{\link{sjPlot-themes}} for details.
   \item Else specify own color values or names as vector (e.g. \code{colors = ""#00ff00""} or \code{colors = c(""firebrick"", ""blue"")}).
 }}
@@ -374,7 +374,7 @@ to adjust p-values. See \code{\link[stats]{p.adjust}} for details.}
 layout.}
 
 \item{case}{Desired target case. Labels will automatically converted into the
-specified character case. See \code{\link[snakecase]{to_any_case}} for more
+specified character case. See \code{snakecase::to_any_case()} for more
 details on this argument. By default, if \code{case} is not specified,
 it will be set to \code{""parsed""}, unless \code{prefix.labels} is not
 \code{""none""}. If \code{prefix.labels} is either \code{""label""} (or
@@ -450,7 +450,7 @@ of supported arguments and their description in detail.
   }
   \item{Case conversion of labels}{For case conversion of labels (see argument
     \code{case}), arguments \code{sep_in} and \code{sep_out} will be passed
-    down to \code{\link[snakecase]{to_any_case}}. This only
+    down to \code{snakecase::to_any_case()}. This only
     applies to automatically retrieved term labels, \emph{not} if
     term labels are provided by the \code{axis.labels}-argument.
   }

---FILE: man/plot_models.Rd---
@@ -144,7 +144,7 @@ color palette. Following options are valid for the \code{colors} argument:
   \item If not specified, a default color brewer palette will be used, which is suitable for the plot style.
   \item If \code{""gs""}, a greyscale will be used.
   \item If \code{""bw""}, and plot-type is a line-plot, the plot is black/white and uses different line types to distinguish groups (see \href{https://strengejacke.github.io/sjPlot/articles/blackwhitefigures.html}{this package-vignette}).
-  \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
+  \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{RColorBrewer::display.brewer.all()} to view all available palette names.
   \item There are some pre-defined color palettes in this package, see \code{\link{sjPlot-themes}} for details.
   \item Else specify own color values or names as vector (e.g. \code{colors = ""#00ff00""} or \code{colors = c(""firebrick"", ""blue"")}).
 }}

---FILE: man/plot_scatter.Rd---
@@ -71,7 +71,7 @@ color palette. Following options are valid for the \code{colors} argument:
   \item If not specified, a default color brewer palette will be used, which is suitable for the plot style.
   \item If \code{""gs""}, a greyscale will be used.
   \item If \code{""bw""}, and plot-type is a line-plot, the plot is black/white and uses different line types to distinguish groups (see \href{https://strengejacke.github.io/sjPlot/articles/blackwhitefigures.html}{this package-vignette}).
-  \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
+  \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{RColorBrewer::display.brewer.all()} to view all available palette names.
   \item There are some pre-defined color palettes in this package, see \code{\link{sjPlot-themes}} for details.
   \item Else specify own color values or names as vector (e.g. \code{colors = ""#00ff00""} or \code{colors = c(""firebrick"", ""blue"")}).
 }}"
strengejacke,sjPlot,ecf28477e462ffe421c249c30b0968eccfaea0ca,Daniel,mail@danielluedecke.de,2021-01-09T10:34:29Z,Daniel,mail@danielluedecke.de,2021-01-09T10:34:29Z,minor fix,R/html_print_utils.R,False,True,True,False,1,1,2,"---FILE: R/html_print_utils.R---
@@ -370,7 +370,7 @@ tab_df_prepare_style <- function(CSS = NULL, content = NULL, task, ...) {
 
   if (task == 1) {
     content <- sprintf(
-      ""<style>\nhtml, body { background-color: white; }\n%s { %s }\n%s { %s }\n%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n</style>"",
+      ""<style>\nhtml, body { background-color: white; }\n%s { %s }\n%s { %s }\n%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n</style>"",
       tag.table, css.table,
       tag.caption, css.caption,
       tag.td, css.td,"
strengejacke,sjPlot,32c81bf0c6085574761621f969cf055293453b48,Daniel,mail@danielluedecke.de,2020-10-28T15:35:00Z,Daniel,mail@danielluedecke.de,2020-10-28T15:35:00Z,fix CRAN check issues,R/plot_model.R;man/plot_model.Rd;man/plot_models.Rd;man/tab_model.Rd,False,True,True,False,6,5,11,"---FILE: R/plot_model.R---
@@ -217,7 +217,7 @@
 #'    if robust standard errors are required.
 #' @param vcov.type Character vector, specifying the estimation type for the
 #'    robust covariance matrix estimation (see \code{\link[sandwich:vcovHC]{vcovHC()}}
-#'    or \code{\link[clubSandwich:vcovCR]{vcovCR()}} for details).
+#'    or \code{clubSandwich::vcovCR()} for details).
 #' @param vcov.args List of named vectors, used as additional arguments that
 #'    are passed down to \code{vcov.fun}.
 #' @param value.offset Numeric, offset for text labels to adjust their position

---FILE: man/plot_model.Rd---
@@ -305,7 +305,7 @@ if robust standard errors are required.}
 
 \item{vcov.type}{Character vector, specifying the estimation type for the
 robust covariance matrix estimation (see \code{\link[sandwich:vcovHC]{vcovHC()}}
-or \code{\link[clubSandwich:vcovCR]{vcovCR()}} for details).}
+or \code{clubSandwich::vcovCR()} for details).}
 
 \item{vcov.args}{List of named vectors, used as additional arguments that
 are passed down to \code{vcov.fun}.}

---FILE: man/plot_models.Rd---
@@ -196,7 +196,7 @@ if robust standard errors are required.}
 
 \item{vcov.type}{Character vector, specifying the estimation type for the
 robust covariance matrix estimation (see \code{\link[sandwich:vcovHC]{vcovHC()}}
-or \code{\link[clubSandwich:vcovCR]{vcovCR()}} for details).}
+or \code{clubSandwich::vcovCR()} for details).}
 
 \item{vcov.args}{List of named vectors, used as additional arguments that
 are passed down to \code{vcov.fun}.}

---FILE: man/tab_model.Rd---
@@ -205,7 +205,8 @@ related predictor in the table, no matter in which way the predictors
 are sorted. See 'Examples'.}
 
 \item{dv.labels}{Character vector with labels of dependent variables of all
-fitted models. See 'Examples'.}
+fitted models. If \code{dv.labels = """"}, the row with names of dependent
+variabled is omitted from the table.}
 
 \item{wrap.labels}{Numeric, determines how many chars of the value, variable
 or axis labels are displayed in one line and when a line break is inserted.}
@@ -229,7 +230,7 @@ if robust standard errors are required.}
 
 \item{vcov.type}{Character vector, specifying the estimation type for the
 robust covariance matrix estimation (see \code{\link[sandwich:vcovHC]{vcovHC()}}
-or \code{\link[clubSandwich:vcovCR]{vcovCR()}} for details).}
+or \code{clubSandwich::vcovCR()} for details).}
 
 \item{vcov.args}{List of named vectors, used as additional arguments that
 are passed down to \code{vcov.fun}.}"
strengejacke,sjPlot,78902233df177ab10b0ca0319403a3e769ab4156,Daniel,mail@danielluedecke.de,2020-10-09T09:45:17Z,Daniel,mail@danielluedecke.de,2020-10-09T09:45:17Z,fix namespace,NAMESPACE;R/tidiers.R,False,True,True,False,4,3,7,"---FILE: NAMESPACE---
@@ -113,6 +113,7 @@ importFrom(insight,has_intercept)
 importFrom(insight,is_multivariate)
 importFrom(insight,model_info)
 importFrom(insight,n_obs)
+importFrom(insight,standardize_names)
 importFrom(knitr,asis_output)
 importFrom(knitr,knit_print)
 importFrom(parameters,closest_component)
@@ -121,7 +122,6 @@ importFrom(parameters,kurtosis)
 importFrom(parameters,model_parameters)
 importFrom(parameters,principal_components)
 importFrom(parameters,skewness)
-importFrom(parameters,standardize_names)
 importFrom(performance,cronbachs_alpha)
 importFrom(performance,item_intercor)
 importFrom(performance,item_reliability)

---FILE: R/tidiers.R---
@@ -1,6 +1,7 @@
 #' @importFrom stats qnorm pnorm
 #' @importFrom effectsize standardize
-#' @importFrom parameters model_parameters standardize_names
+#' @importFrom parameters model_parameters
+#' @importFrom insight standardize_names
 tidy_model <- function(
   model, ci.lvl, tf, type, bpe, robust, facets, show.zeroinf, p.val,
   standardize = FALSE, bootstrap = FALSE, iterations = 1000, seed = NULL, p_adjust = NULL, ...) {
@@ -46,7 +47,7 @@ tidy_model <- function(
     } else {
       model_params <- parameters::model_parameters(model, ci = ci.lvl, component = component, bootstrap = bootstrap, iterations = iterations, df_method = df_method, p_adjust = p_adjust)
     }
-    out <- parameters::standardize_names(model_params, style = ""broom"")
+    out <- insight::standardize_names(model_params, style = ""broom"")
 
     # warning for p-values?
     tryCatch({"
strengejacke,sjPlot,c563cdf9786da06351ce9b94b70a8bc115532c82,Daniel,mail@danielluedecke.de,2020-09-24T11:36:29Z,Daniel,mail@danielluedecke.de,2020-09-24T11:36:29Z,fix URLs,DESCRIPTION;R/plot_grpfrq.R;R/plot_model.R;R/sjPlotPearsonsChi2Test.R;R/tab_itemscale.R;README.md;man/plot_frq.Rd;man/plot_grpfrq.Rd;man/plot_model.Rd;man/plot_xtab.Rd;man/sjPlot-package.Rd;man/sjp.aov1.Rd;man/sjp.chi2.Rd;man/tab_itemscale.Rd;man/tab_xtab.Rd;vignettes/custplot.Rmd;vignettes/plot_interactions.Rmd;vignettes/plot_marginal_effects.Rmd;vignettes/plot_model_estimates.Rmd,True,True,True,False,36,41,77,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 2.8.4.9000
+Version: 2.8.4.9
 Authors@R: c(
     person(""Daniel"", ""Ldecke"", email = ""d.luedecke@uke.de"", role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0002-8895-3206"")),
     person(""Alexander"", ""Bartel"", role = ""ctb"", comment = c(ORCID = ""0000-0002-1280-6138"")),

---FILE: R/plot_grpfrq.R---
@@ -88,19 +88,19 @@
 #' @param show.summary logical, if \code{TRUE} (default), a summary with chi-squared
 #'          statistics (see \code{\link{chisq.test}}), Cramer's V or Phi-value etc.
 #'          is shown. If a cell contains expected values lower than five (or lower than 10
-#'          if df is 1), the Fisher's excact test (see \code{\link{fisher.test}}) is
+#'          if df is 1), the Fisher's exact test (see \code{\link{fisher.test}}) is
 #'          computed instead of chi-squared test. If the table's matrix is larger
-#'          than 2x2, Fisher's excact test with Monte Carlo simulation is computed.
+#'          than 2x2, Fisher's exact test with Monte Carlo simulation is computed.
 #' @param show.grpcnt logical, if \code{TRUE}, the count within each group is added
 #'          to the category labels (e.g. \code{""Cat 1 (n=87)""}). Default value is \code{FALSE}.
 #' @param summary.pos position of the model summary which is printed when \code{show.summary}
 #'          is \code{TRUE}. Default is \code{""r""}, i.e. it's printed to the upper right corner.
 #'          Use \code{""l""} for upper left corner.
 #' @param axis.titles character vector of length one or two, defining the title(s)
 #'          for the x-axis and y-axis.
-#' @param drop.empty Logical, if \code{TRUE} and the variable's values are labelled,
+#' @param drop.empty Logical, if \code{TRUE} and the variable's values are labeled,
 #'          values that have no observations are still printed in the table (with
-#'          frequency \code{0}). If \code{FALSE}, values / factor levels with no occurence
+#'          frequency \code{0}). If \code{FALSE}, values / factor levels with no occurrence
 #'          in the data are omitted from the output.
 #' @param auto.group numeric value, indicating the minimum amount of unique values
 #'          in the count variable, at which automatic grouping into smaller units
@@ -127,7 +127,7 @@
 #'
 #' @details \code{geom.colors} may be a character vector of color values
 #'          in hex-format, valid color value names (see \code{demo(""colors"")} or
-#'          a name of a \href{http://colorbrewer2.org}{color brewer} palette.
+#'          a name of a \href{ https://colorbrewer2.org/}{color brewer} palette.
 #'          Following options are valid for the \code{geom.colors} argument:
 #'          \itemize{
 #'            \item If not specified, a default color brewer palette will be used, which is suitable for the plot style (i.e. diverging for likert scales, qualitative for grouped bars etc.).

---FILE: R/plot_model.R---
@@ -131,7 +131,7 @@
 #'   popularized by Aiken and West (1991), i.e. using the mean, the value one
 #'   standard deviation above, and the value one standard deviation below the
 #'   mean as values of the moderator, see
-#'   \href{http://www.theanalysisfactor.com/3-tips-interpreting-moderation/}{Grace-Martin
+#'   \href{https://www.theanalysisfactor.com/3-tips-interpreting-moderation/}{Grace-Martin
 #'   K: 3 Tips to Make Interpreting Moderation Effects Easier}).}
 #'   \item{\code{""zeromax""}}{is similar to the \code{""minmax""} option, however,
 #'   \code{0} is always used as minimum value for the moderator. This may be

---FILE: R/sjPlotPearsonsChi2Test.R---
@@ -1,8 +1,6 @@
 #' @title Plot Pearson's Chi2-Test of multiple contingency tables
 #' @name sjp.chi2
 #'
-#' @seealso \href{http://talesofr.wordpress.com/2013/05/05/ridiculously-photogenic-factors-heatmap-with-p-values/}{Tales of R}.
-#'
 #' @description Plot p-values of Pearson's Chi2-tests for multiple contingency tables as ellipses or tiles.
 #'                Requires a data frame with dichotomous (dummy) variables.
 #'                Calculation of Chi2-matrix taken from

---FILE: R/tab_itemscale.R---
@@ -85,7 +85,7 @@
 #'              \item Jorion N, Self B, James K, Schroeder L, DiBello L, Pellegrino J (2013) Classical Test Theory Analysis of the Dynamics Concept Inventory. (\href{https://www.academia.edu/4104752/Classical_Test_Theory_Analysis_of_the_Dynamics_Concept_Inventory}{web})
 #'              \item Briggs SR, Cheek JM (1986) The role of factor analysis in the development and evaluation of personality scales. Journal of Personality, 54(1), 106-148. doi: 10.1111/j.1467-6494.1986.tb00391.x
 #'              \item McLean S et al. (2013) Stigmatizing attitudes and beliefs about bulimia nervosa: Gender, age, education and income variability in a community sample. International Journal of Eating Disorders. doi: 10.1002/eat.22227
-#'              \item Trochim WMK (2008) Types of Reliability. (\href{http://www.socialresearchmethods.net/kb/reltypes.php}{web})
+#'              \item Trochim WMK (2008) Types of Reliability. (\href{https://conjointly.com/kb/types-of-reliability/}{web})
 #'             }
 #'
 #' @examples

---FILE: README.md---
@@ -1,7 +1,7 @@
 # sjPlot - Data Visualization for Statistics in Social Science <img src=""man/figures/logo.png"" align=""right"" />
 
-[![CRAN_Status_Badge](http://www.r-pkg.org/badges/version/sjPlot)](https://cran.r-project.org/package=sjPlot) &#160;&#160; [![Documentation](https://img.shields.io/badge/documentation-sjPlot-orange.svg?colorB=E91E63)](https://strengejacke.github.io/sjPlot/) &#160;&#160; [![downloads](http://cranlogs.r-pkg.org/badges/sjPlot)](http://cranlogs.r-pkg.org/)
-&#160;&#160; [![total](http://cranlogs.r-pkg.org/badges/grand-total/sjPlot)](http://cranlogs.r-pkg.org/)
+[![CRAN_Status_Badge](http://www.r-pkg.org/badges/version/sjPlot)](https://cran.r-project.org/package=sjPlot) &#160;&#160; [![Documentation](https://img.shields.io/badge/documentation-sjPlot-orange.svg?colorB=E91E63)](https://strengejacke.github.io/sjPlot/) &#160;&#160; [![downloads](https://cranlogs.r-pkg.org/badges/sjPlot)](https://cranlogs.r-pkg.org/)
+&#160;&#160; [![total](https://cranlogs.r-pkg.org/badges/grand-total/sjPlot)](https://cranlogs.r-pkg.org/)
 
 
 Collection of plotting and table output functions for data visualization. Results of various statistical analyses (that are commonly used in social sciences) can be visualized using this package, including simple and cross tabulated frequencies, histograms, box plots, (generalized) linear models, mixed effects models, PCA and correlation matrices, cluster analyses, scatter plots, Likert scales, effects plots of interaction terms in regression models, constructing index or score variables and much more.

---FILE: man/plot_frq.Rd---
@@ -156,9 +156,9 @@ mean. Only applies to histogram-charts.}
 is annotated as shaded rectangle around the mean intercept
 line. Only applies to histogram-charts.}
 
-\item{drop.empty}{Logical, if \code{TRUE} and the variable's values are labelled,
+\item{drop.empty}{Logical, if \code{TRUE} and the variable's values are labeled,
 values that have no observations are still printed in the table (with
-frequency \code{0}). If \code{FALSE}, values / factor levels with no occurence
+frequency \code{0}). If \code{FALSE}, values / factor levels with no occurrence
 in the data are omitted from the output.}
 
 \item{mean.line.type}{Numeric value, indicating the linetype of the mean

---FILE: man/plot_grpfrq.Rd---
@@ -151,13 +151,13 @@ are added to the output.}
 \item{show.summary}{logical, if \code{TRUE} (default), a summary with chi-squared
 statistics (see \code{\link{chisq.test}}), Cramer's V or Phi-value etc.
 is shown. If a cell contains expected values lower than five (or lower than 10
-if df is 1), the Fisher's excact test (see \code{\link{fisher.test}}) is
+if df is 1), the Fisher's exact test (see \code{\link{fisher.test}}) is
 computed instead of chi-squared test. If the table's matrix is larger
-than 2x2, Fisher's excact test with Monte Carlo simulation is computed.}
+than 2x2, Fisher's exact test with Monte Carlo simulation is computed.}
 
-\item{drop.empty}{Logical, if \code{TRUE} and the variable's values are labelled,
+\item{drop.empty}{Logical, if \code{TRUE} and the variable's values are labeled,
 values that have no observations are still printed in the table (with
-frequency \code{0}). If \code{FALSE}, values / factor levels with no occurence
+frequency \code{0}). If \code{FALSE}, values / factor levels with no occurrence
 in the data are omitted from the output.}
 
 \item{auto.group}{numeric value, indicating the minimum amount of unique values
@@ -224,7 +224,7 @@ Plot grouped or stacked frequencies of variables as bar/dot,
 \details{
 \code{geom.colors} may be a character vector of color values
          in hex-format, valid color value names (see \code{demo(""colors"")} or
-         a name of a \href{http://colorbrewer2.org}{color brewer} palette.
+         a name of a \href{ https://colorbrewer2.org/}{color brewer} palette.
          Following options are valid for the \code{geom.colors} argument:
          \itemize{
            \item If not specified, a default color brewer palette will be used, which is suitable for the plot style (i.e. diverging for likert scales, qualitative for grouped bars etc.).

---FILE: man/plot_model.Rd---
@@ -214,7 +214,7 @@ variable (following the convention suggested by Cohen and Cohen and
 popularized by Aiken and West (1991), i.e. using the mean, the value one
 standard deviation above, and the value one standard deviation below the
 mean as values of the moderator, see
-\href{http://www.theanalysisfactor.com/3-tips-interpreting-moderation/}{Grace-Martin
+\href{https://www.theanalysisfactor.com/3-tips-interpreting-moderation/}{Grace-Martin
 K: 3 Tips to Make Interpreting Moderation Effects Easier}).}
 \item{\code{""zeromax""}}{is similar to the \code{""minmax""} option, however,
 \code{0} is always used as minimum value for the moderator. This may be

---FILE: man/plot_xtab.Rd---
@@ -105,17 +105,17 @@ function, a legend is added to the plot.}
 \item{show.summary}{logical, if \code{TRUE} (default), a summary with chi-squared
 statistics (see \code{\link{chisq.test}}), Cramer's V or Phi-value etc.
 is shown. If a cell contains expected values lower than five (or lower than 10
-if df is 1), the Fisher's excact test (see \code{\link{fisher.test}}) is
+if df is 1), the Fisher's exact test (see \code{\link{fisher.test}}) is
 computed instead of chi-squared test. If the table's matrix is larger
-than 2x2, Fisher's excact test with Monte Carlo simulation is computed.}
+than 2x2, Fisher's exact test with Monte Carlo simulation is computed.}
 
 \item{summary.pos}{position of the model summary which is printed when \code{show.summary}
 is \code{TRUE}. Default is \code{""r""}, i.e. it's printed to the upper right corner.
 Use \code{""l""} for upper left corner.}
 
-\item{drop.empty}{Logical, if \code{TRUE} and the variable's values are labelled,
+\item{drop.empty}{Logical, if \code{TRUE} and the variable's values are labeled,
 values that have no observations are still printed in the table (with
-frequency \code{0}). If \code{FALSE}, values / factor levels with no occurence
+frequency \code{0}). If \code{FALSE}, values / factor levels with no occurrence
 in the data are omitted from the output.}
 
 \item{string.total}{String for the legend label when a total-column is added. Only applies

---FILE: man/sjPlot-package.Rd---
@@ -10,19 +10,19 @@
 The package supports labelled data, i.e. value and variable labels from labelled data (like vectors or data frames) are automatically used to label the output. Own labels can be specified as well.
 
   \emph{What does this package do?}
-  
+
   In short, the functions in this package mostly do two things:
   \enumerate{
     \item compute basic or advanced statistical analyses
     \item either plot the results as ggplot-figure or print them as html-table
   }
-  
+
   \emph{How does this package help me?}
-  
+
   One of the more challenging tasks when working with R is to get nicely formatted output of statistical analyses, either in graphical or table format. The sjPlot-package takes over these tasks and makes it easy to create beautiful figures or tables.
 
-  There are many examples for each function in the related help files and a comprehensive online documentation at \url{http://www.strengejacke.de/sjPlot}.
-  
+  There are many examples for each function in the related help files and a comprehensive online documentation at \url{https://strengejacke.github.io/sjPlot/}.
+
   \emph{A note on the package functions}
 
   The main functions follow specific naming conventions, hence starting with a specific prefix, which indicates what kind of task these functions perform.

---FILE: man/sjp.aov1.Rd---
@@ -94,9 +94,9 @@ variable labels.}
 \item{show.summary}{logical, if \code{TRUE} (default), a summary with chi-squared
 statistics (see \code{\link{chisq.test}}), Cramer's V or Phi-value etc.
 is shown. If a cell contains expected values lower than five (or lower than 10
-if df is 1), the Fisher's excact test (see \code{\link{fisher.test}}) is
+if df is 1), the Fisher's exact test (see \code{\link{fisher.test}}) is
 computed instead of chi-squared test. If the table's matrix is larger
-than 2x2, Fisher's excact test with Monte Carlo simulation is computed.}
+than 2x2, Fisher's exact test with Monte Carlo simulation is computed.}
 }
 \value{
 A ggplot-object.

---FILE: man/sjp.chi2.Rd---
@@ -59,6 +59,3 @@ items <- list(c(""Item 1"", ""Item 2"", ""Item 3"", ""Item 4"", ""Item 5""))
 sjp.chi2(mydf, axis.labels = items)
 
 }
-\seealso{
-\href{http://talesofr.wordpress.com/2013/05/05/ridiculously-photogenic-factors-heatmap-with-p-values/}{Tales of R}.
-}

---FILE: man/tab_itemscale.Rd---
@@ -196,6 +196,6 @@ if (interactive()) {
              \item Jorion N, Self B, James K, Schroeder L, DiBello L, Pellegrino J (2013) Classical Test Theory Analysis of the Dynamics Concept Inventory. (\href{https://www.academia.edu/4104752/Classical_Test_Theory_Analysis_of_the_Dynamics_Concept_Inventory}{web})
              \item Briggs SR, Cheek JM (1986) The role of factor analysis in the development and evaluation of personality scales. Journal of Personality, 54(1), 106-148. doi: 10.1111/j.1467-6494.1986.tb00391.x
              \item McLean S et al. (2013) Stigmatizing attitudes and beliefs about bulimia nervosa: Gender, age, education and income variability in a community sample. International Journal of Eating Disorders. doi: 10.1002/eat.22227
-             \item Trochim WMK (2008) Types of Reliability. (\href{http://www.socialresearchmethods.net/kb/reltypes.php}{web})
+             \item Trochim WMK (2008) Types of Reliability. (\href{https://conjointly.com/kb/types-of-reliability/}{web})
             }
 }

---FILE: man/tab_xtab.Rd---
@@ -120,9 +120,9 @@ are added to the output.}
 chi-squared statistics, degrees of freedom and Cramer's V or Phi
 coefficient and p-value for the chi-squared statistics.}
 
-\item{drop.empty}{Logical, if \code{TRUE} and the variable's values are labelled,
+\item{drop.empty}{Logical, if \code{TRUE} and the variable's values are labeled,
 values that have no observations are still printed in the table (with
-frequency \code{0}). If \code{FALSE}, values / factor levels with no occurence
+frequency \code{0}). If \code{FALSE}, values / factor levels with no occurrence
 in the data are omitted from the output.}
 
 \item{statistics}{Name of measure of association that should be computed. May

---FILE: vignettes/custplot.Rmd---
@@ -56,7 +56,7 @@ plot_grpfrq(
 
 ## Using the Color Brewer palettes
 
-All plotting functions support the usage of the [Colorbrewer](http://colorbrewer2.org) palettes. To apply a color brewer palette, use specify the palette as `geom.colors`. Any valid color brewer palette is recognized automatically.
+All plotting functions support the usage of the [Colorbrewer]( https://colorbrewer2.org/) palettes. To apply a color brewer palette, use specify the palette as `geom.colors`. Any valid color brewer palette is recognized automatically.
 
 ```{r}
 # blank theme

---FILE: vignettes/plot_interactions.Rmd---
@@ -25,7 +25,7 @@ This document describes how to plot marginal effects of interaction terms from v
 
 `plot_model()` supports [labelled data](https://cran.r-project.org/package=sjlabelled) and automatically uses variable and value labels to annotate the plot. This works with most regression modelling functions.
 
-***Note:** For marginal effects plots, **sjPlot** calls functions from the [**ggeffects-package**](http://strengejacke.github.io/ggeffects). If you need more flexibility when creating marginal effects plots, consider directly using the **ggeffects**-package.*
+***Note:** For marginal effects plots, **sjPlot** calls functions from the [**ggeffects-package**](https://strengejacke.github.io/ggeffects/). If you need more flexibility when creating marginal effects plots, consider directly using the **ggeffects**-package.*
 
 # Two-Way-Interactions
 

---FILE: vignettes/plot_marginal_effects.Rmd---
@@ -42,7 +42,7 @@ To plot marginal effects of regression models, at least one model term needs to
 
 `plot_model()` supports [labelled data](https://cran.r-project.org/package=sjlabelled) and automatically uses variable and value labels to annotate the plot. This works with most regression modelling functions.
 
-***Note:** For marginal effects plots, **sjPlot** calls functions from the [**ggeffects-package**](http://strengejacke.github.io/ggeffects). If you need more flexibility when creating marginal effects plots, consider directly using the **ggeffects**-package.*
+***Note:** For marginal effects plots, **sjPlot** calls functions from the [**ggeffects-package**](https://strengejacke.github.io/ggeffects/). If you need more flexibility when creating marginal effects plots, consider directly using the **ggeffects**-package.*
 
 # Marginal effects
 

---FILE: vignettes/plot_model_estimates.Rmd---
@@ -174,7 +174,7 @@ if (require(""rstanarm"", quietly = TRUE)) {
 
 There are several options to customize the plot appearance:
 
-  * The `colors`-argument either takes the name of a valid [colorbrewer palette](http://colorbrewer2.org) (see also the related [vignette](custplot.html)), `""bw""` or `""gs""` for black/white or greyscaled colors, or a string with a color name.
+  * The `colors`-argument either takes the name of a valid [colorbrewer palette](https://colorbrewer2.org/) (see also the related [vignette](custplot.html)), `""bw""` or `""gs""` for black/white or greyscaled colors, or a string with a color name.
   * `value.offset` and `value.size` adjust the positioning and size of value labels, if shown.
   * `dot.size` and `line.size` change the size of dots and error bars.
   * `vline.color` changes the neutral ""intercept"" line."
strengejacke,sjPlot,326255b6a5fa77c9c3f425802088b46eda127a1f,Daniel,mail@danielluedecke.de,2020-09-24T10:27:40Z,Daniel,mail@danielluedecke.de,2020-09-24T10:27:40Z,fix pkgdown issues,_pkgdown.yml,False,False,False,False,12,0,12,"---FILE: _pkgdown.yml---
@@ -7,6 +7,10 @@ template:
     bootswatch: flatly
 
 reference:
+- title: ""Package Description""
+  contents:
+  - sjPlot-package
+
 - title: ""Plotting Regression Models""
   contents:
   - plot_model
@@ -33,6 +37,9 @@ reference:
   - plot_grpfrq
   - plot_xtab
   - sjp.chi2
+  - sjp.aov1
+  - sjp.corr
+  - sjplot
 
 - title: ""Descriptive Statistics Tables""
   contents:
@@ -68,6 +75,11 @@ reference:
   - plot_grid
   - save_plot
 
+- title: ""Example Data""
+  contents:
+  - efc
+  - save_plot
+
 navbar:
   type: default
   left:"
strengejacke,sjPlot,df083d789b0fd2196890f41e76559be1f591a581,Johannes Titz,johannes@titz.science,2020-07-24T16:24:31Z,Johannes Titz,johannes@titz.science,2020-07-24T16:25:57Z,fix typo in contributor,DESCRIPTION,False,False,False,False,2,2,4,"---FILE: DESCRIPTION---
@@ -8,8 +8,8 @@ Authors@R: c(
     person(""Alexander"", ""Bartel"", role = ""ctb"", comment = c(ORCID = ""0000-0002-1280-6138"")),
     person(""Carsten"", ""Schwemmer"", email = ""carsten.schwemmer@uni-bamberg.de"", role = ""ctb""),
     person(given = ""Chuck"", family = ""Powell"", role = ""ctb"", email = ""ibecav@gmail.com"", comment = c(ORCID = ""0000-0002-3606-2188"")), 
-    person(given = ""Amir"", family = ""Djalovski"", role = ""ctb"", email = ""Amir.DJV@gmail.com"")),
-    person(given = ""Johannes"", family = ""Titz"", role = ""ctb"", email = ""johannes@titz.science"", comment = c(ORCID = ""0000-0002-1102-5719""))
+    person(given = ""Amir"", family = ""Djalovski"", role = ""ctb"", email = ""Amir.DJV@gmail.com""),
+    person(given = ""Johannes"", family = ""Titz"", role = ""ctb"", email = ""johannes@titz.science"", comment = c(ORCID = ""0000-0002-1102-5719"")))
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of plotting and table output functions for data
     visualization. Results of various statistical analyses (that are commonly used"
strengejacke,sjPlot,dd8b1c93d7ee5399dc86264816ded78538a58a2f,Johannes Titz,johannes@titz.science,2020-07-24T16:12:43Z,Johannes Titz,johannes@titz.science,2020-07-24T16:12:43Z,"fix show.stat and show.p

I thought string_starts_with is a dplyr function, but it is just a helper-function which does not accept grep OR (|). The problem was that the show.stat and show.p parameters did not work anymore. Now I call string_starts_with two times (for ustandardized and standardized parameters).",R/tab_model.R,False,True,True,False,4,2,6,"---FILE: R/tab_model.R---
@@ -1309,15 +1309,17 @@ remove_unwanted <- function(dat, show.intercept, show.est, show.std, show.ci, sh
   }
 
   if (show.stat == FALSE) {
-    dat <- dplyr::select(dat, -string_starts_with(""statistic|std.statistic"", x = colnames(dat)))
+    dat <- dplyr::select(dat, -string_starts_with(""statistic"", x = colnames(dat)),
+                         -string_starts_with(""std.statistic"", x = colnames(dat)))
   }
 
   if (show.response == FALSE) {
     dat <- dplyr::select(dat, -string_starts_with(""response.level"", x = colnames(dat)))
   }
 
   if (show.p == FALSE) {
-    dat <- dplyr::select(dat, -string_starts_with(""p.value|std.p.value"", x = colnames(dat)))
+    dat <- dplyr::select(dat, -string_starts_with(""p.value"", x = colnames(dat)),
+                         -string_starts_with(""std.p.value"", x = colnames(dat)))
   }
 
   if (show.df == FALSE) {"
strengejacke,sjPlot,5c058b5f18cd84f31e4d370770896f4de609385c,Johannes Titz,johannes@titz.science,2020-06-28T15:41:26Z,Johannes Titz,johannes@titz.science,2020-06-28T15:41:26Z,"change behavior of show.std (fixes #649)

If standardized coefficients are displayed (show.std = TRUE), the model is refitted. For mixed models this can result in different p-values and t-values as compared to the unstandardized coefficients. At the moment this can result in a mismatch between the t-value (coming from the standardized model) and the p-value (coming from the unstandardized model). The fix shows p-values and t-values for both unstandardized and standardized coefficients (if they are different).

Formatting of p-values is moved to a separate function to call it for both models.

Parameters string.std.p and string.std.stat are added.",R/tab_model.R;man/tab_model.Rd,False,True,True,False,79,35,114,"---FILE: R/tab_model.R---
@@ -86,8 +86,10 @@
 #' @param string.std_se Character vector, used for the column heading of standard error of standardized coefficients. Default is \code{""standardized std. Error""}.
 #' @param string.std_ci Character vector, used for the column heading of confidence intervals of standardized coefficients. Default is \code{""standardized std. Error""}.
 #' @param string.p Character vector, used for the column heading of p values. Default is \code{""p""}.
+#' @param string.std.p Character vector, used for the column heading of p values. Default is \code{""std. p""}.
 #' @param string.df Character vector, used for the column heading of degrees of freedom. Default is \code{""df""}.
 #' @param string.stat Character vector, used for the test statistic. Default is \code{""Statistic""}.
+#' @param string.std.stat Character vector, used for the test statistic. Default is \code{""std. Statistic""}.
 #' @param string.resp Character vector, used for the column heading of of the response level for multinominal or categorical models. Default is \code{""Response""}.
 #' @param string.intercept Character vector, used as name for the intercept parameter. Default is \code{""(Intercept)""}.
 #' @param strings Named character vector, as alternative to arguments like \code{string.ci}
@@ -278,8 +280,10 @@ tab_model <- function(
   string.std_se = ""standardized std. Error"",
   string.std_ci = ""standardized CI"",
   string.p = ""p"",
+  string.std.p = ""std. p"",
   string.df = ""df"",
   string.stat = ""Statistic"",
+  string.std.stat = ""std. Statistic"",
   string.resp = ""Response"",
   string.intercept = ""(Intercept)"",
   strings = NULL,
@@ -301,7 +305,9 @@ tab_model <- function(
     ""ci.inner"",
     ""ci.outer"",
     ""stat"",
+    ""std.stat"",
     ""p"",
+    ""std.p"",
     ""df.error"",
     ""response.level""
   ),
@@ -386,9 +392,14 @@ tab_model <- function(
   copos <- which(""p"" == col.order)
   if (!sjmisc::is_empty(copos)) col.order[copos] <- ""p.value""
 
+  copos <- which(""std.p"" == col.order)
+  if (!sjmisc::is_empty(copos)) col.order[copos] <- ""std.p.value""
+
   copos <- which(""stat"" == col.order)
   if (!sjmisc::is_empty(copos)) col.order[copos] <- ""statistic""
 
+  copos <- which(""std.stat"" == col.order)
+  if (!sjmisc::is_empty(copos)) col.order[copos] <- ""std.statistic""
 
   # match strings, to label the default strings in the table,
   # like ""Estimate"", ""CI"" etc.
@@ -402,8 +413,10 @@ tab_model <- function(
     if (""std_se"" %in% s.names) string.std_se <- strings[[""std_se""]]
     if (""std_ci"" %in% s.names) string.std_ci <- strings[[""std_ci""]]
     if (""p"" %in% s.names) string.p <- strings[[""p""]]
+    if (""std.p"" %in% s.names) string.std.p <- strings[[""std.p""]]
     if (""df"" %in% s.names) string.df <- strings[[""df""]]
     if (""stat"" %in% s.names) string.stat <- strings[[""stat""]]
+    if (""std.stat"" %in% s.names) string.std.stat <- strings[[""std.stat""]]
     if (""resp"" %in% s.names) string.resp <- strings[[""resp""]]
     if (""intercept"" %in% s.names) string.intercept <- strings[[""intercept""]]
   }
@@ -468,24 +481,7 @@ tab_model <- function(
           digits,
           .data$conf.high
         )) %>%
-        dplyr::select(-.data$conf.low, -.data$conf.high) %>%
-        dplyr::mutate(
-          p.stars = get_p_stars(.data$p.value, p.threshold),
-          p.sig = .data$p.value < .05
-        )
-
-      if (grepl(""scientific"", p.style)) {
-        dat$p.value <- formatC(dat$p.value, format = ""e"", digits = digits.p)
-      } else {
-        dat$p.value <- sprintf(""%.*f"", digits.p, dat$p.value)
-      }
-
-
-      # emphasize p-values ----
-
-      if (emph.p && !all(dat$p.value == ""NA"")) dat$p.value[which(dat$p.sig)] <- sprintf(""<strong>%s</strong>"", dat$p.value[which(dat$p.sig)])
-      dat <- dplyr::select(dat, -.data$p.sig)
-
+        dplyr::select(-.data$conf.low, -.data$conf.high)
 
       # get inner probability (i.e. 2nd CI for Stan-models) ----
 
@@ -503,16 +499,6 @@ tab_model <- function(
             dplyr::select(-.data$conf.low50, -.data$conf.high50)
       }
 
-
-      # indicate p <0.001 ----
-
-      pv <- paste0(""0."", paste(rep(""0"", digits.p), collapse = """"))
-      dat$p.value[dat$p.value == pv] <- ""&lt;0.001""
-
-      pv <- paste0(""<strong>0."", paste(rep(""0"", digits.p), collapse = """"), ""</strong>"")
-      dat$p.value[dat$p.value == pv] <- ""<strong>&lt;0.001""
-
-
       # tidy output of standardized values ----
 
       if (!is.null(show.std) && !is.stan(model)) {
@@ -533,13 +519,17 @@ tab_model <- function(
           iterations = iterations,
           seed = seed
         ) %>%
+          format_p_values(p.style, digits.p, emph.p, p.threshold) %>%
           sjmisc::var_rename(
             estimate = ""std.estimate"",
             std.error = ""std.se"",
             conf.low = ""std.conf.low"",
-            conf.high = ""std.conf.high""
+            conf.high = ""std.conf.high"",
+            p.value = ""std.p.value"",
+            statistic = ""std.statistic"",
+            p.stars = ""std.p.stars""
           ) %>%
-          dplyr::select(-1, -.data$p.value) %>%
+          dplyr::select(-1) %>%
           sjmisc::add_columns(dat) %>%
           dplyr::mutate(std.conf.int = sprintf(
             ""%.*f%s%.*f"",
@@ -550,16 +540,26 @@ tab_model <- function(
             .data$std.conf.high
           )) %>%
           dplyr::select(-.data$std.conf.low, -.data$std.conf.high)
+        # if t-statistic is the same for standardized and unstandardized model
+        # remove standardized; ignore intercept
+        if (all(round(dat$statistic[-1], 3) == round(dat$std.statistic[-1], 3))) {
+          dat <- dat %>%
+            dplyr::select(-.data$std.statistic, -.data$std.p.value)
+        }
       }
 
+      # format p values for unstandardized model
+      dat <- format_p_values(dat, p.style, digits.p, emph.p, p.threshold)
 
       # add asterisks to estimates ----
 
       if (grepl(""stars"", p.style)) {
         if (obj_has_name(dat, ""estimate""))
           dat$estimate <- sprintf(""%.*f <sup>%s</sup>"", digits, dat$estimate, dat$p.stars)
-        if (!show.est && obj_has_name(dat, ""std.estimate""))
-          dat$std.estimate <- sprintf(""%.*f <sup>%s</sup>"", digits, dat$std.estimate, dat$p.stars)
+        if (!show.est && obj_has_name(dat, ""std.estimate"")){
+          dat$std.estimate <- sprintf(""%.*f <sup>%s</sup>"", digits, dat$std.estimate, dat$std.p.stars)
+          dat <- dplyr::select(dat, -.data$std.p.stars)
+        }
       }
 
       dat <- dplyr::select(dat, -.data$p.stars)
@@ -1163,12 +1163,18 @@ tab_model <- function(
     pos <- grep(""^p.value"", x)
     if (!sjmisc::is_empty(pos)) x <- string.p
 
+    pos <- grep(""^std.p.value"", x)
+    if (!sjmisc::is_empty(pos)) x <- string.std.p
+
     pos <- grep(""^df"", x)
     if (!sjmisc::is_empty(pos)) x <- string.df
 
     pos <- grep(""^statistic"", x)
     if (!sjmisc::is_empty(pos)) x <- string.stat
 
+    pos <- grep(""^std.statistic"", x)
+    if (!sjmisc::is_empty(pos)) x <- string.std.stat
+
     pos <- grep(""^response.level"", x)
     if (!sjmisc::is_empty(pos)) x <- string.resp
 
@@ -1303,15 +1309,15 @@ remove_unwanted <- function(dat, show.intercept, show.est, show.std, show.ci, sh
   }
 
   if (show.stat == FALSE) {
-    dat <- dplyr::select(dat, -string_starts_with(""statistic"", x = colnames(dat)))
+    dat <- dplyr::select(dat, -string_starts_with(""statistic|std.statistic"", x = colnames(dat)))
   }
 
   if (show.response == FALSE) {
     dat <- dplyr::select(dat, -string_starts_with(""response.level"", x = colnames(dat)))
   }
 
   if (show.p == FALSE) {
-    dat <- dplyr::select(dat, -string_starts_with(""p.value"", x = colnames(dat)))
+    dat <- dplyr::select(dat, -string_starts_with(""p.value|std.p.value"", x = colnames(dat)))
   }
 
   if (show.df == FALSE) {
@@ -1362,3 +1368,35 @@ prepare.labels <- function(x, grp, categorical, models) {
 
   x
 }
+
+format_p_values <- function(dat, p.style, digits.p, emph.p, p.threshold){
+  # get stars and significance at alpha = 0.05 ----
+
+  dat <- dat %>%
+    dplyr::mutate(
+    p.stars = get_p_stars(.data$p.value, p.threshold),
+    p.sig = .data$p.value < .05
+  )
+
+  # scientific notation ----
+
+  if (grepl(""scientific"", p.style)) {
+    dat$p.value <- formatC(dat$p.value, format = ""e"", digits = digits.p)
+  } else {
+    dat$p.value <- sprintf(""%.*f"", digits.p, dat$p.value)
+  }
+
+  # emphasize p-values ----
+
+  if (emph.p && !all(dat$p.value == ""NA"")) dat$p.value[which(dat$p.sig)] <- sprintf(""<strong>%s</strong>"", dat$p.value[which(dat$p.sig)])
+  dat <- dplyr::select(dat, -.data$p.sig)
+
+  # indicate p <0.001 ----
+
+  pv <- paste0(""0."", paste(rep(""0"", digits.p), collapse = """"))
+  dat$p.value[dat$p.value == pv] <- ""&lt;0.001""
+
+  pv <- paste0(""<strong>0."", paste(rep(""0"", digits.p), collapse = """"), ""</strong>"")
+  dat$p.value[dat$p.value == pv] <- ""<strong>&lt;0.001""
+  dat
+}

---FILE: man/tab_model.Rd---
@@ -51,8 +51,10 @@ tab_model(
   string.std_se = ""standardized std. Error"",
   string.std_ci = ""standardized CI"",
   string.p = ""p"",
+  string.std.p = ""std. p"",
   string.df = ""df"",
   string.stat = ""Statistic"",
+  string.std.stat = ""std. Statistic"",
   string.resp = ""Response"",
   string.intercept = ""(Intercept)"",
   strings = NULL,
@@ -62,7 +64,7 @@ tab_model(
   collapse.se = FALSE,
   linebreak = TRUE,
   col.order = c(""est"", ""se"", ""std.est"", ""std.se"", ""ci"", ""std.ci"", ""ci.inner"",
-    ""ci.outer"", ""stat"", ""p"", ""df.error"", ""response.level""),
+    ""ci.outer"", ""stat"", ""std.stat"", ""p"", ""std.p"", ""df.error"", ""response.level""),
   digits = 2,
   digits.p = 3,
   digits.re = 2,
@@ -251,10 +253,14 @@ Default is based on the response scale, e.g. for logistic regression models,
 
 \item{string.p}{Character vector, used for the column heading of p values. Default is \code{""p""}.}
 
+\item{string.std.p}{Character vector, used for the column heading of p values. Default is \code{""std. p""}.}
+
 \item{string.df}{Character vector, used for the column heading of degrees of freedom. Default is \code{""df""}.}
 
 \item{string.stat}{Character vector, used for the test statistic. Default is \code{""Statistic""}.}
 
+\item{string.std.stat}{Character vector, used for the test statistic. Default is \code{""std. Statistic""}.}
+
 \item{string.resp}{Character vector, used for the column heading of of the response level for multinominal or categorical models. Default is \code{""Response""}.}
 
 \item{string.intercept}{Character vector, used as name for the intercept parameter. Default is \code{""(Intercept)""}.}"
strengejacke,sjPlot,ad29bf13500748e5b5ac53830c7b016d07826605,Daniel,mail@danielluedecke.de,2020-05-23T09:04:01Z,Daniel,mail@danielluedecke.de,2020-05-23T09:04:01Z,check issues,R/tab_fa.R;man/tab_fa.Rd,False,True,True,False,17,0,17,"---FILE: R/tab_fa.R---
@@ -9,6 +9,14 @@
 #'                reliability test. The result is an alpha value for each factor dimension.
 #'
 #' @param show.comm Logical, if \code{TRUE}, show the communality column in the table.
+#' @param method the factoring method to be used. \code{""ml""} will do a maximum likelihood factor analysis (default).
+#'         \code{""minres""} will do a minimum residual (OLS),
+#'         \code{""wls""} will do a weighted least squares (WLS) solution,
+#'         \code{""gls""} does a generalized weighted least squares (GLS),
+#'         \code{""pa""} will do the principal factor solution,
+#'         \code{""minchi""} will minimize the sample size weighted chi square
+#'         when treating pairwise correlations with different number of
+#'         subjects per pair. \code{""minrank""} will do a minimum rank factor analysis.
 #'
 #' @inheritParams tab_pca
 #' @inheritParams tab_model

---FILE: man/tab_fa.Rd---
@@ -31,6 +31,15 @@ tab_fa(
 \code{""varimax"", ""quartimax"", ""promax"", ""oblimin"", ""simplimax"", ""cluster""}
 or \code{""none""}.}
 
+\item{method}{the factoring method to be used. \code{""ml""} will do a maximum likelihood factor analysis (default).
+\code{""minres""} will do a minimum residual (OLS),
+\code{""wls""} will do a weighted least squares (WLS) solution,
+\code{""gls""} does a generalized weighted least squares (GLS),
+\code{""pa""} will do the principal factor solution,
+\code{""minchi""} will minimize the sample size weighted chi square
+when treating pairwise correlations with different number of
+subjects per pair. \code{""minrank""} will do a minimum rank factor analysis.}
+
 \item{nmbr.fctr}{Number of factors used for calculating the rotation. By
 default, this value is \code{NULL} and the amount of factors is
 calculated according to the Kaiser-criteria.}"
strengejacke,sjPlot,7c88e11b1609a9d87ea6411b69856167e33facb5,Daniel,mail@danielluedecke.de,2020-05-23T08:55:33Z,Daniel,mail@danielluedecke.de,2020-05-23T08:55:33Z,fix vignettes,vignettes/plot_likert_scales.Rmd;vignettes/sjtitemanalysis.Rmd;vignettes/table_css.Rmd,True,False,True,False,19,5,24,"---FILE: vignettes/plot_likert_scales.Rmd---
@@ -12,12 +12,20 @@ vignette: >
 ```{r set-options, echo = FALSE}
 knitr::opts_chunk$set(collapse = TRUE, comment = ""#>"", dev = ""png"", fig.width = 7, fig.height = 6, message = FALSE, warning = FALSE)
 options(width = 800, tibble.width = Inf)
+if (!requireNamespace(""dplyr"", quietly = TRUE) ||
+    !requireNamespace(""sjmisc"", quietly = TRUE) ||
+    !requireNamespace(""parameters"", quietly = TRUE)) {
+  knitr::opts_chunk$set(eval = FALSE)
+} else {
+  knitr::opts_chunk$set(eval = TRUE)
+}
 ```
 
 ```{r fig.height = 5.5}
 library(dplyr)
 library(sjPlot)
 library(sjmisc)
+library(parameters)
 data(efc)
 # find all variables from COPE-Index, which all have a ""cop"" in their
 # variable name, and then plot that subset as likert-plot
@@ -41,7 +49,8 @@ plot_likert(mydf, groups = c(2, 1, 1, 1, 1, 2, 2, 2, 1))
 ```
 
 ```{r fig.height = 6.5}
-groups <- sjt.pca(mydf)$factor.index
+pca <- parameters::principal_components(mydf)
+groups <- parameters::closest_component(pca)
 plot_likert(mydf, groups = groups)
 ```
 

---FILE: vignettes/sjtitemanalysis.Rmd---
@@ -12,7 +12,10 @@ vignette: >
 ```{r echo = FALSE}
 knitr::opts_chunk$set(collapse = TRUE, comment = ""#>"")
 
-if (!requireNamespace(""psych"", quietly = TRUE)) {
+if (!requireNamespace(""dplyr"", quietly = TRUE) ||
+    !requireNamespace(""sjmisc"", quietly = TRUE) ||
+    !requireNamespace(""parameters"", quietly = TRUE) ||
+    !requireNamespace(""psych"", quietly = TRUE)) {
   knitr::opts_chunk$set(eval = FALSE)
 } else {
   knitr::opts_chunk$set(eval = TRUE)
@@ -39,7 +42,7 @@ Optional, following statistics can be computed as well:
 * kurstosis
 * Shapiro-Wilk Normality Test
 
-If the argument `factor.groups` is _not_ `NULL`, the data frame df will be splitted into groups, assuming that `factor.groups` indicate those columns (variables) of the data frame that belong to a certain factor (see, for instance, return value of function `sjt.pca()` or `sjp.pca()` as example for retrieving factor groups for a scale). This is useful when you have perfomed a principal component analysis or factor analysis as first step, and now want to see whether the found factors / components represent a scale or index score.
+If the argument `factor.groups` is _not_ `NULL`, the data frame df will be splitted into groups, assuming that `factor.groups` indicate those columns (variables) of the data frame that belong to a certain factor (see, for instance, return value of function `tab_pca()` or `parameters::principal_components()` as example for retrieving factor groups for a scale). This is useful when you have perfomed a principal component analysis or factor analysis as first step, and now want to see whether the found factors / components represent a scale or index score.
 
 To demonstrate this function, we first need some data:
 
@@ -71,9 +74,11 @@ To interprete the output, we may consider following values as rule-of-thumbs for
 The items of the COPE index used for our example do not represent a single factor. We can check this, for instance, with a principle component analysis. If you know, which variable belongs to which factor (i.e. which variable is part of which component), you can pass a numeric vector with these group indices to the argument `factor.groups`. In this case, the data frame is divided into the components specified by `factor.groups`, and each component (or factor) is analysed.
 
 ```{r}
+library(parameters)
 # Compute PCA on Cope-Index, and retrieve 
 # factor indices for each COPE index variable
-factor.groups <- sjt.pca(mydf)$factor.index
+pca <- parameters::principal_components(mydf)
+factor.groups <- parameters::closest_component(pca)
 ```
 
 The PCA extracted two components. Now `tab_itemscale()` ...

---FILE: vignettes/table_css.Rmd---
@@ -13,7 +13,7 @@ vignette: >
 knitr::opts_chunk$set(collapse = TRUE, comment = ""#>"", warning = FALSE, message = FALSE)
 ```
 
-All `sjt.*`-functions as well as `tab_model()` create a HTML page with the table output. This table, by default, is opened in the viewer pane of your IDE (in case youre using an IDE that also supports the viewer pane). If a viewer pane is not available, the created HTML output is saved as temporary file and opened in your default web browser. The temporary files are deleted after your R session ends.
+All `tab_*`-functions create a HTML page with the table output. This table, by default, is opened in the viewer pane of your IDE (in case youre using an IDE that also supports the viewer pane). If a viewer pane is not available, the created HTML output is saved as temporary file and opened in your default web browser. The temporary files are deleted after your R session ends.
 
 ## Copying table output to office or word processors
 "
strengejacke,sjPlot,afff315015c706152d464e3ebe4983bb2209b762,Daniel,mail@danielluedecke.de,2020-05-23T08:44:59Z,Daniel,mail@danielluedecke.de,2020-05-23T08:44:59Z,fix check issues,DESCRIPTION;NAMESPACE;R/plot_likert.R;R/tab_corr.R;R/tab_fa.R;R/tab_pca.R;man/plot_likert.Rd,False,True,True,False,3,17,20,"---FILE: DESCRIPTION---
@@ -57,6 +57,7 @@ Suggests:
     ggridges,
     httr,
     lme4 (>= 1.1-12),
+    nFactors,
     pscl,
     psych,
     rmarkdown,

---FILE: NAMESPACE---
@@ -49,10 +49,7 @@ export(sjp.corr)
 export(sjp.poly)
 export(sjplot)
 export(sjplot_pal)
-export(sjt.corr)
-export(sjt.fa)
 export(sjt.itemanalysis)
-export(sjt.pca)
 export(sjt.xtab)
 export(sjtab)
 export(tab_corr)

---FILE: R/plot_likert.R---
@@ -97,7 +97,7 @@
 #'
 #' plot_likert(mydf, c(2,1,1,1,1,2,2,2,1))
 #'
-#' if (require(""parameters"")) {
+#' if (require(""parameters"") && require(""nFactors"")) {
 #'   groups <- parameters::principal_components(mydf)
 #'   plot_likert(mydf, groups = parameters::closest_component(groups))
 #' }

---FILE: R/tab_corr.R---
@@ -477,7 +477,3 @@ tab_corr <- function(data,
     )
   )
 }
-
-
-#' @export
-sjt.corr <- tab_corr

---FILE: R/tab_fa.R---
@@ -462,7 +462,3 @@ tab_fa <- function(data,
     )
   )
 }
-
-
-#' @export
-sjt.fa <- tab_fa

---FILE: R/tab_pca.R---
@@ -540,7 +540,3 @@ tab_pca <- function(data,
                            header = table.header,
                            viewer = use.viewer))
 }
-
-
-#' @export
-sjt.pca <- tab_pca

---FILE: man/plot_likert.Rd---
@@ -216,7 +216,7 @@ plot_likert(
 
 plot_likert(mydf, c(2,1,1,1,1,2,2,2,1))
 
-if (require(""parameters"")) {
+if (require(""parameters"") && require(""nFactors"")) {
   groups <- parameters::principal_components(mydf)
   plot_likert(mydf, groups = parameters::closest_component(groups))
 }"
strengejacke,sjPlot,9c4972ba9cb72d84c8756fe876451fe203f710c3,Daniel,mail@danielluedecke.de,2020-03-07T14:03:21Z,Daniel,mail@danielluedecke.de,2020-03-07T14:03:21Z,minor fix,R/tidiers.R,False,True,True,False,3,0,3,"---FILE: R/tidiers.R---
@@ -33,6 +33,9 @@ tidy_model <- function(
     )
 
     if (!is.null(robust) && !is.null(robust$vcov.fun)) {
+      if (grepl(""^vcov"", robust$vcov.fun)) {
+        robust$vcov.fun <- sub(""^vcov"", """", robust$vcov.fun)
+      }
       model_params <- parameters::model_parameters(model, ci = ci.lvl, component = component, bootstrap = bootstrap, iterations = iterations, robust = TRUE, vcov_estimation = robust$vcov.fun, vcov_type = robust$vcov.type, vcov_args = robust$vcov.args, df_method = df_method, p_adjust = p_adjust, ...)
     } else {
       model_params <- parameters::model_parameters(model, ci = ci.lvl, component = component, bootstrap = bootstrap, iterations = iterations, df_method = df_method, p_adjust = p_adjust)"
strengejacke,sjPlot,9ea23755ff6a7fc2fb1b6e7012279a544746798d,Daniel,mail@danielluedecke.de,2020-03-06T15:31:04Z,Daniel,mail@danielluedecke.de,2020-03-06T15:31:04Z,minor fix for forthcoming package changes,R/tab_itemscale.R,False,True,True,False,1,1,2,"---FILE: R/tab_itemscale.R---
@@ -254,7 +254,7 @@ tab_itemscale <- function(df,
 
     # include kurtosis statistics
     if (show.kurtosis) {
-      df.dummy <- data_frame(cbind(df.dummy, round(parameters::kurtosis(df.sub), 2)))
+      df.dummy <- data_frame(cbind(df.dummy, round(as.numeric(parameters::kurtosis(df.sub)), 2)))
       df.colnames <- c(df.colnames, ""Kurtosis"")
     }
 "
strengejacke,sjPlot,adaca9db1bf644bd055dab30cb8d05f5cd2350f8,Daniel,mail@danielluedecke.de,2020-03-04T06:34:46Z,Daniel,mail@danielluedecke.de,2020-03-04T06:34:46Z,fix test,tests/testthat/test-tab_model.R,False,True,True,False,1,1,2,"---FILE: tests/testthat/test-tab_model.R---
@@ -33,7 +33,7 @@ if (suppressWarnings(
   })
 
   test_that(""tab_model"", {
-    expect_warning(tab_model(m1, m2, m3, m4))
+    tab_model(m1, m2, m3, m4)
   })
 
   test_that(""tab_model, check shows"", {"
strengejacke,sjPlot,50ba5ef37d657052c3efd2d4464a672bd753ef75,Daniel,mail@danielluedecke.de,2020-03-02T07:07:13Z,Daniel,mail@danielluedecke.de,2020-03-02T07:07:13Z,fix in order.terms,R/plot_model_estimates.R,False,True,True,False,1,1,2,"---FILE: R/plot_model_estimates.R---
@@ -134,7 +134,7 @@ plot_model_estimates <- function(model,
   ordered.terms <- FALSE
   if (!is.null(term.order)) {
     if (length(term.order) == nrow(dat)) {
-      dat$term <- factor(dat$term, levels = unique(dat$term)[term.order])
+      dat$term <- factor(dat$term, levels = unique(dat$term)[rev(term.order)])
       sort.est <- FALSE
       ordered.terms <- TRUE
     } else {"
strengejacke,sjPlot,96583bdb31aa0c1c0c85a64a70e7774f033c021c,Daniel,mail@danielluedecke.de,2020-03-01T17:37:02Z,Daniel,mail@danielluedecke.de,2020-03-01T17:37:02Z,fix ordering of terms,DESCRIPTION;R/plot_model_estimates.R;R/plot_models.R;R/plot_type_ranef.R;R/sjPlotFA.R;R/sjPlotPCA.R;R/tab_model.R,False,True,True,False,14,19,33,"---FILE: DESCRIPTION---
@@ -21,16 +21,15 @@ Description: Collection of plotting and table output functions for data
     labelled data.
 License: GPL-3
 Depends:
-    R (>= 3.2),
+    R (>= 3.2)
+Imports:
     graphics,
     grDevices,
     stats,
-    utils
-Imports:
+    utils,
     bayestestR (>= 0.5.0),
     dplyr (>= 0.8.1),
     effectsize,
-    forcats,
     ggeffects (>= 0.14.0),
     ggplot2 (>= 3.2.0),
     knitr,

---FILE: R/plot_model_estimates.R---
@@ -131,10 +131,12 @@ plot_model_estimates <- function(model,
 
   # does user want a specific order for terms?
 
+  ordered.terms <- FALSE
   if (!is.null(term.order)) {
     if (length(term.order) == nrow(dat)) {
-      dat$term <- forcats::fct_reorder(dat$term, order(term.order))
+      dat$term <- factor(dat$term, levels = unique(dat$term)[term.order])
       sort.est <- FALSE
+      ordered.terms <- TRUE
     } else {
       message(""Number of values in `order.terms` does not match number of terms. Terms are not sorted."")
     }
@@ -145,10 +147,10 @@ plot_model_estimates <- function(model,
 
   if (isTRUE(sort.est)) {
     if (!is.null(group.terms))
-      dat$term <- forcats::fct_reorder(dat$term, dat$group)
+      dat$term <- factor(dat$term, levels = unique(dat$term[order(dat$group)]))
     else
-      dat$term <- forcats::fct_reorder(dat$term, dat$estimate)
-  } else {
+      dat$term <- factor(dat$term, levels = unique(dat$term[order(dat$estimate)]))
+  } else if (!ordered.terms) {
     dat$term <- factor(dat$term, levels = rev(unique(dat$term)))
   }
 
@@ -189,7 +191,7 @@ plot_model_estimates <- function(model,
         }
         x$reihe <- order(reihe)
 
-        x$term <- forcats::fct_reorder(x$term, x$reihe)
+        x$term <- factor(x$term, levels = unique(x$term[order(x$reihe)]))
 
         # plot title
 

---FILE: R/plot_models.R---
@@ -226,7 +226,7 @@ plot_models <- function(...,
 
 
   # reverse group, to plot correct order from top to bottom
-  ff$group <- forcats::fct_rev(ff$group)
+  ff$group <- factor(ff$group, levels = rev(unique(ff$group)))
 
 
   # add p-asterisks to data

---FILE: R/plot_type_ranef.R---
@@ -286,7 +286,7 @@ plot_type_ranef <- function(model,
       function(x, y) {
 
         # sort terms
-        x$term <- forcats::fct_reorder(x$term, x$reihe)
+        x$term <- factor(x$term, levels = unique(x$term[order(x$reihe)]))
 
 
         # now we need a named vector, in order

---FILE: R/sjPlotFA.R---
@@ -76,8 +76,7 @@ sjp.fa <- function(data,
                     show.values = TRUE,
                     show.cronb = TRUE) {
 
-  ## TODO change to deprecated
-  warning(""'sjp.fa()' will become deprecated in a future update. Please use 'parameters::factor_analysis()' and the 'plot()' method instead."", call. = FALSE)
+  .Deprecated(msg = ""'sjp.fa()' will become deprecated in a future update. Please use 'parameters::factor_analysis()' and the 'plot()' method instead."")
 
   if (!requireNamespace(""psych"", quietly = TRUE)) {
     stop(""Package 'psych' required for this function to work. Please install it."", call. = FALSE)

---FILE: R/sjPlotPCA.R---
@@ -74,7 +74,7 @@ sjp.pca <- function(data,
                     show.cronb = TRUE) {
 
   ## TODO change to deprecated
-  warning(""'sjp.pca()' will become deprecated in a future update. Please use 'parameters::principal_components()' and the 'plot()' method instead."", call. = FALSE)
+  .Deprecated(msg = ""'sjp.pca()' will become deprecated in a future update. Please use 'parameters::principal_components()' and the 'plot()' method instead."")
 
   if (!requireNamespace(""psych"", quietly = TRUE)) {
     stop(""Package 'psych' required for this function to work. Please install it."", call. = FALSE)

---FILE: R/tab_model.R---
@@ -324,11 +324,6 @@ tab_model <- function(
   prefix.labels <- match.arg(prefix.labels)
   vcov.type <- match.arg(vcov.type)
 
-  ## TODO remove once parameters update is on CRAN
-  if (p.val != ""wald"" && utils::packageVersion(""parameters"") <= ""0.4.1"") {
-    message(""Computation of Kenward-Roger or Satterthwaite approximated degrees of freedom for p-values will be inaccurate with the current version of the 'parameters' package. Please update package 'parameters' from GitHub to get reliable p-values."")
-  }
-
   change_string_est <- !missing(string.est)
 
   # if we prefix labels, use different default for case conversion,"
strengejacke,sjPlot,68ed5258213aa1a9f53ad8cf66d710256e03104b,Daniel,mail@danielluedecke.de,2020-03-01T11:53:41Z,Daniel,mail@danielluedecke.de,2020-03-01T11:53:41Z,fixes in tab_model with formatting,NEWS.md;R/html_print.R;R/html_print_utils.R,False,True,True,False,12,1,13,"---FILE: NEWS.md---
@@ -13,6 +13,7 @@
 * Fixed issue in `tab_model()` and `plot_model()` for certain cases when coefficients could not be estimated and were `NA`.
 * Fixed issue in `tab_model()` when `p.val=""kr""` and `show.df=TRUE`.
 * Fixed issue in `tab_model()` with formatting issues of p-values when standardized coefficients where requested.
+* Fixed issue in `tab_model()` due to changes in other packages *sjPlot* depends on.
 
 # sjPlot 2.8.2
 

---FILE: R/html_print.R---
@@ -313,6 +313,7 @@ tab_model_df <- function(x,
     sort.column = NULL,
     include.table.tag = FALSE,
     no.last.table.row = TRUE,
+    zeroinf = is.zeroinf,
     ...
   )
 
@@ -389,7 +390,7 @@ tab_model_df <- function(x,
     )
 
     page.content <- paste0(page.content, ""  <tr>\n"")
-    page.content <- paste0(page.content, sprintf(""    <td colspan=\""%i\"" class=\""simplexparts\"">Simplex Parameters</td>\n"", ncol(x)))
+    page.content <- paste0(page.content, sprintf(""    <td colspan=\""%i\"" class=\""simplexparts\"">Monotonic Effects</td>\n"", ncol(x)))
     page.content <- paste0(page.content, ""  </tr>\n"")
 
     page.content <- paste0(page.content, sp.content)
@@ -426,6 +427,7 @@ tab_model_df <- function(x,
       sort.column = NULL,
       include.table.tag = FALSE,
       no.last.table.row = TRUE,
+      zeroinf = FALSE,
       ...
     )
 

---FILE: R/html_print_utils.R---
@@ -32,6 +32,7 @@ tab_df_content <- function(
   include.table.tag = TRUE,
   no.last.table.row = FALSE,
   show.header = TRUE,
+  zeroinf = FALSE,
   ...) {
 
   # save no of rows and columns
@@ -122,6 +123,13 @@ tab_df_content <- function(
   }
 
 
+  if (isTRUE(zeroinf)) {
+    page.content <- paste0(page.content, ""  <tr>\n"")
+    page.content <- paste0(page.content, sprintf(""    <td colspan=\""%i\"" class=\""zeroparts\"">Count Model</td>\n"", colcnt + 1))
+    page.content <- paste0(page.content, ""  </tr>\n"")
+  }
+
+
   # subsequent rows ----
 
   for (rcnt in 1:rowcnt) {"
strengejacke,sjPlot,10511b6c50bb7b991396af057ec9665c3d2f489c,Daniel,mail@danielluedecke.de,2020-03-01T11:42:51Z,Daniel,mail@danielluedecke.de,2020-03-01T11:42:51Z,minor fix,R/tidiers.R,False,True,True,False,2,2,4,"---FILE: R/tidiers.R---
@@ -101,8 +101,8 @@ tidy_stan_model <- function(model, ci.lvl, tf, type, bpe, show.zeroinf, facets,
   else
     ty <- ""fixed""
 
-  d1 <- bayestestR::ci(model, ci = p.outer, effects = ty)
-  d2 <- bayestestR::ci(model, ci = p.inner, effects = ty)
+  d1 <- bayestestR::ci(model, ci = p.outer, effects = ty, component = ""all"")
+  d2 <- bayestestR::ci(model, ci = p.inner, effects = ty, component = ""all"")
 
   if (!is.null(tf)) {
     funtrans <- match.fun(tf)"
strengejacke,sjPlot,114c93ff22416977275bad8a4daee1725d0a46d2,Daniel,mail@danielluedecke.de,2020-02-11T12:20:55Z,Daniel,mail@danielluedecke.de,2020-02-11T12:20:55Z,fixed issue,NEWS.md;R/tab_model.R,False,True,True,False,3,2,5,"---FILE: NEWS.md---
@@ -7,6 +7,7 @@
 ## Bug fixes
 
 * Fixed issue in `tab_model()` and `plot_model()` for certain cases when coefficients could not be estimated and were `NA`.
+* Fixed issue in `tab_model()` when `p.val=""kr""` and `show.df=TRUE`.
 
 # sjPlot 2.8.2
 

---FILE: R/tab_model.R---
@@ -295,7 +295,7 @@ tab_model <- function(
     ""ci.outer"",
     ""stat"",
     ""p"",
-    ""df"",
+    ""df.error"",
     ""response.level""
   ),
 
@@ -1218,7 +1218,7 @@ sort_columns <- function(x, is.stan, col.order) {
     ""ci.outer"",
     ""statistic"",
     ""p.value"",
-    ""df"",
+    ""df.error"",
     ""wrap.facet"",
     ""response.level""
   )"
strengejacke,sjPlot,56db4289fca56e4f334ccae3f7f4c5d0d61c1a2e,Daniel,mail@danielluedecke.de,2020-01-23T09:11:00Z,Daniel,mail@danielluedecke.de,2020-01-23T09:11:00Z,fix check issues,R/plot_frq.R;R/plot_grid.R;man/plot_frq.Rd;man/plot_grid.Rd,False,True,True,False,76,72,148,"---FILE: R/plot_frq.R---
@@ -63,7 +63,6 @@ utils::globalVariables(""density"")
 #'
 #' @examples
 #' library(sjlabelled)
-#' library(dplyr)
 #' data(efc)
 #' data(iris)
 #'
@@ -74,19 +73,23 @@ utils::globalVariables(""density"")
 #' # boxplot
 #' plot_frq(efc$e17age, type = ""box"")
 #'
-#' # histogram, pipe-workflow
-#' efc %>%
-#'   dplyr::select(e17age, c160age) %>%
-#'   plot_frq(type = ""hist"", show.mean = TRUE)
+#' if (require(""dplyr"")) {
+#'   # histogram, pipe-workflow
+#'   efc %>%
+#'     dplyr::select(e17age, c160age) %>%
+#'     plot_frq(type = ""hist"", show.mean = TRUE)
 #'
-#' # bar plot(s)
-#' plot_frq(efc, e42dep, c172code)
+#'   # bar plot(s)
+#'   plot_frq(efc, e42dep, c172code)
+#' }
 #'
-#' # grouped data frame, all panels in one plot
-#' efc %>%
-#'   group_by(e42dep) %>%
-#'   plot_frq(c161sex) %>%
-#'   plot_grid()
+#' if (require(""dplyr"") && require(""gridExtra"")) {
+#'   # grouped data frame, all panels in one plot
+#'   efc %>%
+#'     group_by(e42dep) %>%
+#'     plot_frq(c161sex) %>%
+#'     plot_grid()
+#' }
 #'
 #' library(sjmisc)
 #' # grouped variable
@@ -104,7 +107,6 @@ utils::globalVariables(""density"")
 #' plot_frq(efc$c160age, type = ""h"", show.mean = TRUE, show.mean.val = TRUE,
 #'         normal.curve = TRUE, show.sd = TRUE, normal.curve.color = ""blue"",
 #'         normal.curve.size = 3, ylim = c(0,50))
-#'
 #' @import ggplot2
 #' @importFrom sjstats weighted_sd
 #' @importFrom sjmisc group_labels group_var to_value frq

---FILE: R/plot_grid.R---
@@ -18,33 +18,33 @@
 #'          To arrange these plots as grid as a single plot, use \code{plot_grid}.
 #'
 #' @examples
-#' library(ggeffects)
-#' library(dplyr)
-#' data(efc)
+#' if (require(""dplyr"") && require(""gridExtra"")) {
+#'   library(ggeffects)
+#'   data(efc)
 #'
-#' # fit model
-#' fit <- glm(
-#'   tot_sc_e ~ c12hour + e17age + e42dep + neg_c_7,
-#'   data = efc,
-#'   family = poisson
-#' )
+#'   # fit model
+#'   fit <- glm(
+#'     tot_sc_e ~ c12hour + e17age + e42dep + neg_c_7,
+#'     data = efc,
+#'     family = poisson
+#'   )
 #'
-#' # plot marginal effects for each predictor, each as single plot
-#' p1 <- ggpredict(fit, ""c12hour"") %>%
-#'   plot(show.y.title = FALSE, show.title = FALSE)
-#' p2 <- ggpredict(fit, ""e17age"") %>%
-#'   plot(show.y.title = FALSE, show.title = FALSE)
-#' p3 <- ggpredict(fit, ""e42dep"") %>%
-#'   plot(show.y.title = FALSE, show.title = FALSE)
-#' p4 <- ggpredict(fit, ""neg_c_7"") %>%
-#'   plot(show.y.title = FALSE, show.title = FALSE)
+#'   # plot marginal effects for each predictor, each as single plot
+#'   p1 <- ggpredict(fit, ""c12hour"") %>%
+#'     plot(show.y.title = FALSE, show.title = FALSE)
+#'   p2 <- ggpredict(fit, ""e17age"") %>%
+#'     plot(show.y.title = FALSE, show.title = FALSE)
+#'   p3 <- ggpredict(fit, ""e42dep"") %>%
+#'     plot(show.y.title = FALSE, show.title = FALSE)
+#'   p4 <- ggpredict(fit, ""neg_c_7"") %>%
+#'     plot(show.y.title = FALSE, show.title = FALSE)
 #'
-#' # plot grid
-#' plot_grid(list(p1, p2, p3, p4))
-#'
-#' # plot grid
-#' plot_grid(list(p1, p2, p3, p4), tags = TRUE)
+#'   # plot grid
+#'   plot_grid(list(p1, p2, p3, p4))
 #'
+#'   # plot grid
+#'   plot_grid(list(p1, p2, p3, p4), tags = TRUE)
+#' }
 #' @export
 plot_grid <- function(x, margin = c(1, 1, 1, 1), tags = NULL) {
   # check package availability -----

---FILE: man/plot_frq.Rd---
@@ -223,7 +223,6 @@ This function only works with variables with integer values (or numeric
 }
 \examples{
 library(sjlabelled)
-library(dplyr)
 data(efc)
 data(iris)
 
@@ -234,19 +233,23 @@ plot_frq(efc$tot_sc_e)
 # boxplot
 plot_frq(efc$e17age, type = ""box"")
 
-# histogram, pipe-workflow
-efc \%>\%
-  dplyr::select(e17age, c160age) \%>\%
-  plot_frq(type = ""hist"", show.mean = TRUE)
+if (require(""dplyr"")) {
+  # histogram, pipe-workflow
+  efc \%>\%
+    dplyr::select(e17age, c160age) \%>\%
+    plot_frq(type = ""hist"", show.mean = TRUE)
 
-# bar plot(s)
-plot_frq(efc, e42dep, c172code)
+  # bar plot(s)
+  plot_frq(efc, e42dep, c172code)
+}
 
-# grouped data frame, all panels in one plot
-efc \%>\%
-  group_by(e42dep) \%>\%
-  plot_frq(c161sex) \%>\%
-  plot_grid()
+if (require(""dplyr"") && require(""gridExtra"")) {
+  # grouped data frame, all panels in one plot
+  efc \%>\%
+    group_by(e42dep) \%>\%
+    plot_frq(c161sex) \%>\%
+    plot_grid()
+}
 
 library(sjmisc)
 # grouped variable
@@ -264,5 +267,4 @@ plot_frq(
 plot_frq(efc$c160age, type = ""h"", show.mean = TRUE, show.mean.val = TRUE,
         normal.curve = TRUE, show.sd = TRUE, normal.curve.color = ""blue"",
         normal.curve.size = 3, ylim = c(0,50))
-
 }

---FILE: man/plot_grid.Rd---
@@ -29,31 +29,31 @@ This function takes a \code{list} of ggplot-objects as argument.
          To arrange these plots as grid as a single plot, use \code{plot_grid}.
 }
 \examples{
-library(ggeffects)
-library(dplyr)
-data(efc)
+if (require(""dplyr"") && require(""gridExtra"")) {
+  library(ggeffects)
+  data(efc)
 
-# fit model
-fit <- glm(
-  tot_sc_e ~ c12hour + e17age + e42dep + neg_c_7,
-  data = efc,
-  family = poisson
-)
+  # fit model
+  fit <- glm(
+    tot_sc_e ~ c12hour + e17age + e42dep + neg_c_7,
+    data = efc,
+    family = poisson
+  )
 
-# plot marginal effects for each predictor, each as single plot
-p1 <- ggpredict(fit, ""c12hour"") \%>\%
-  plot(show.y.title = FALSE, show.title = FALSE)
-p2 <- ggpredict(fit, ""e17age"") \%>\%
-  plot(show.y.title = FALSE, show.title = FALSE)
-p3 <- ggpredict(fit, ""e42dep"") \%>\%
-  plot(show.y.title = FALSE, show.title = FALSE)
-p4 <- ggpredict(fit, ""neg_c_7"") \%>\%
-  plot(show.y.title = FALSE, show.title = FALSE)
+  # plot marginal effects for each predictor, each as single plot
+  p1 <- ggpredict(fit, ""c12hour"") \%>\%
+    plot(show.y.title = FALSE, show.title = FALSE)
+  p2 <- ggpredict(fit, ""e17age"") \%>\%
+    plot(show.y.title = FALSE, show.title = FALSE)
+  p3 <- ggpredict(fit, ""e42dep"") \%>\%
+    plot(show.y.title = FALSE, show.title = FALSE)
+  p4 <- ggpredict(fit, ""neg_c_7"") \%>\%
+    plot(show.y.title = FALSE, show.title = FALSE)
 
-# plot grid
-plot_grid(list(p1, p2, p3, p4))
-
-# plot grid
-plot_grid(list(p1, p2, p3, p4), tags = TRUE)
+  # plot grid
+  plot_grid(list(p1, p2, p3, p4))
 
+  # plot grid
+  plot_grid(list(p1, p2, p3, p4), tags = TRUE)
+}
 }"
strengejacke,sjPlot,3c1a94cefcfe3b1b52b97ab1f9799d6e3edd4706,Daniel,mail@danielluedecke.de,2020-01-22T22:47:06Z,Daniel,mail@danielluedecke.de,2020-01-22T22:47:06Z,fix check issues,R/plot_kfold_cv.R,False,True,True,False,3,3,6,"---FILE: R/plot_kfold_cv.R---
@@ -90,7 +90,7 @@ plot_kfold_cv <- function(data, formula, k = 5, fit) {
       # pair, get deviance residuals and response value
       kfolds <- do.call(rbind, lapply(1:k, function(i) {
         out <- parameters::data_partition(data, training_proportion = .8)
-        data.frame(training = I(list(out$training)), test = I(list(out$test)))
+        data.frame(train = I(list(out$training)), test = I(list(out$test)))
       }))
       res <- kfolds %>%
         dplyr::mutate(model = purrr::map(.data$train, ~ stats::glm(formula, data = .x, family = stats::poisson(link = ""log"")))) %>%
@@ -102,7 +102,7 @@ plot_kfold_cv <- function(data, formula, k = 5, fit) {
       # pair, get deviance residuals and response value
       kfolds <- do.call(rbind, lapply(1:k, function(i) {
         out <- parameters::data_partition(data, training_proportion = .8)
-        data.frame(training = I(list(out$training)), test = I(list(out$test)))
+        data.frame(train = I(list(out$training)), test = I(list(out$test)))
       }))
       res <- kfolds %>%
         dplyr::mutate(model = purrr::map(.data$train, ~ MASS::glm.nb(formula, data = .))) %>%
@@ -119,7 +119,7 @@ plot_kfold_cv <- function(data, formula, k = 5, fit) {
     # train data
     kfolds <- do.call(rbind, lapply(1:k, function(i) {
       out <- parameters::data_partition(data, training_proportion = .8)
-      data.frame(training = I(list(out$training)), test = I(list(out$test)))
+      data.frame(train = I(list(out$training)), test = I(list(out$test)))
     }))
     res <- kfolds %>%
       dplyr::mutate(model = purrr::map(.data$train, ~ stats::lm(formula, data = .))) %>%"
strengejacke,sjPlot,7b7a68173e25b341e765fede1f746951bf835ee7,Daniel,mail@danielluedecke.de,2020-01-22T20:52:50Z,Daniel,mail@danielluedecke.de,2020-01-22T20:52:50Z,fix check issues,R/plot_grid.R;man/plot_grid.Rd,False,True,True,False,2,0,2,"---FILE: R/plot_grid.R---
@@ -19,6 +19,7 @@
 #'
 #' @examples
 #' library(ggeffects)
+#' library(dplyr)
 #' data(efc)
 #'
 #' # fit model

---FILE: man/plot_grid.Rd---
@@ -30,6 +30,7 @@ This function takes a \code{list} of ggplot-objects as argument.
 }
 \examples{
 library(ggeffects)
+library(dplyr)
 data(efc)
 
 # fit model"
strengejacke,sjPlot,7bfc0d05a2a51c3f0707561d371053f3859b2ef3,Daniel,mail@danielluedecke.de,2020-01-22T15:19:47Z,Daniel,mail@danielluedecke.de,2020-01-22T15:19:47Z,fix check issues,NAMESPACE;R/tab_model.R,False,True,True,False,3,1,4,"---FILE: NAMESPACE---
@@ -260,5 +260,6 @@ importFrom(tidyr,nest)
 importFrom(tidyr,spread)
 importFrom(tidyr,unnest)
 importFrom(utils,browseURL)
+importFrom(utils,packageVersion)
 importFrom(utils,setTxtProgressBar)
 importFrom(utils,txtProgressBar)

---FILE: R/tab_model.R---
@@ -217,6 +217,7 @@
 #' @importFrom performance r2 icc
 #' @importFrom stats nobs setNames
 #' @importFrom rlang .data
+#' @importFrom utils packageVersion
 #' @export
 tab_model <- function(
   ...,
@@ -320,7 +321,7 @@ tab_model <- function(
   vcov.type <- match.arg(vcov.type)
 
   ## TODO remove once parameters update is on CRAN
-  if (p.val != ""wald"" && packageVersion(""parameters"") <= ""0.4.1"") {
+  if (p.val != ""wald"" && utils::packageVersion(""parameters"") <= ""0.4.1"") {
     message(""Computation of Kenward-Roger or Satterthwaite approximated degrees of freedom for p-values will be inaccurate with the current version of the 'parameters' package. Please update package 'parameters' from GitHub to get reliable p-values."")
   }
 "
strengejacke,sjPlot,5401f5a3cbb84e78b1f400606eba2878d2425385,Daniel,mail@danielluedecke.de,2020-01-22T10:44:59Z,Daniel,mail@danielluedecke.de,2020-01-22T10:44:59Z,"minor fixes, update website",NAMESPACE;NEWS.md;R/tab_model.R;R/tidiers.R;docs/404.html;docs/articles/blackwhitefigures.html;docs/articles/custplot.html;docs/articles/index.html;docs/articles/plot_interactions.html;docs/articles/plot_likert_scales.html;docs/articles/plot_likert_scales_files/figure-html/unnamed-chunk-1-1.png;docs/articles/plot_likert_scales_files/figure-html/unnamed-chunk-3-1.png;docs/articles/plot_likert_scales_files/figure-html/unnamed-chunk-4-1.png;docs/articles/plot_likert_scales_files/figure-html/unnamed-chunk-5-1.png;docs/articles/plot_likert_scales_files/figure-html/unnamed-chunk-6-1.png;docs/articles/plot_likert_scales_files/figure-html/unnamed-chunk-6-2.png;docs/articles/plot_marginal_effects.html;docs/articles/plot_model_estimates.html;docs/articles/plot_model_estimates_files/figure-html/unnamed-chunk-14-1.png;docs/articles/sjtitemanalysis.html;docs/articles/tab_bayes.html;docs/articles/tab_mixed.html;docs/articles/tab_model_estimates.html;docs/articles/table_css.html;docs/authors.html;docs/index.html;docs/news/index.html;docs/reference/dist_chisq.html;docs/reference/dist_f.html;docs/reference/dist_norm.html;docs/reference/dist_t.html;docs/reference/efc.html;docs/reference/index.html;docs/reference/plot_frq.html;docs/reference/plot_gpt.html;docs/reference/plot_grid.html;docs/reference/plot_grpfrq.html;docs/reference/plot_kfold_cv.html;docs/reference/plot_likert.html;docs/reference/plot_model.html;docs/reference/plot_models.html;docs/reference/plot_residuals.html;docs/reference/plot_scatter.html;docs/reference/plot_stackfrq.html;docs/reference/plot_xtab.html;docs/reference/reexports.html;docs/reference/save_plot.html;docs/reference/set_theme.html;docs/reference/sjPlot-package.html;docs/reference/sjPlot-themes.html;docs/reference/sjp.aov1.html;docs/reference/sjp.chi2.html;docs/reference/sjp.corr.html;docs/reference/sjp.fa.html;docs/reference/sjp.pca.html;docs/reference/sjp.poly.html;docs/reference/sjplot.html;docs/reference/sjt.corr.html;docs/reference/sjt.fa.html;docs/reference/sjt.pca.html;docs/reference/tab_df.html;docs/reference/tab_itemscale.html;docs/reference/tab_model.html;docs/reference/tab_stackfrq.html;docs/reference/tab_xtab.html;docs/reference/view_df.html;vignettes/tab_bayes.Rmd,True,True,True,False,138,126,264,"---FILE: NAMESPACE---
@@ -246,6 +246,7 @@ importFrom(stats,reshape)
 importFrom(stats,residuals)
 importFrom(stats,rstudent)
 importFrom(stats,sd)
+importFrom(stats,setNames)
 importFrom(stats,shapiro.test)
 importFrom(stats,summary.lm)
 importFrom(stats,terms)

---FILE: NEWS.md---
@@ -13,6 +13,7 @@
 ## Bug fixes
 
 * Improved `tab_df()` now uses value labels for factors instead of numeric values.
+* Fixed some issues related to the lates *brms*-update.
 
 # sjPlot 2.8.1
 

---FILE: R/tab_model.R---
@@ -215,7 +215,7 @@
 #' @importFrom sjmisc word_wrap var_rename add_columns add_case
 #' @importFrom insight model_info is_multivariate find_random get_data find_predictors
 #' @importFrom performance r2 icc
-#' @importFrom stats nobs
+#' @importFrom stats nobs setNames
 #' @importFrom rlang .data
 #' @export
 tab_model <- function(
@@ -869,17 +869,10 @@ tab_model <- function(
 
         model.data <- split(model.data[[1]], model.data[[1]][""response.level_1""])
       } else {
-        dv.labels <- sjmisc::word_wrap(
-          sjlabelled::get_dv_labels(models, mv = TRUE, case = case),
-          wrap = wrap.labels,
-          linesep = ""<br>""
-        )
-
-        if (sjmisc::is_empty(dv.labels) || !isTRUE(auto.label))
-          dv.labels <- insight::find_response(models[[1]])
-
+        dv.labels <- insight::find_response(models[[1]])
         model.data <- split(model.data[[1]], model.data[[1]][""response.level_1""])
         dv.labels <- dv.labels[match(names(dv.labels), names(model.data))]
+        dv.labels <- sjmisc::word_wrap(dv.labels, wrap = wrap.labels, linesep = ""<br>"")
       }
 
       model.data <- purrr::map2(model.data, 1:length(model.data), function(x, y) {

---FILE: R/tidiers.R---
@@ -125,7 +125,7 @@ tidy_stan_model <- function(model, ci.lvl, tf, type, bpe, show.zeroinf, facets,
   # for brmsfit models, we need to remove some columns here to
   # match data rows later
 
-  mod.dat <- as.data.frame(model)
+  mod.dat <- as.data.frame(model, optional = FALSE)
 
   if (inherits(model, ""brmsfit"")) {
     re.sd <- string_starts_with(""sd_"", x = colnames(mod.dat))

---FILE: docs/404.html---
@@ -76,7 +76,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/articles/blackwhitefigures.html---
@@ -38,7 +38,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 
@@ -139,7 +139,7 @@
       <h1>Black &amp; White Figures for Print Journals</h1>
                         <h4 class=""author"">Daniel Ldecke</h4>
             
-            <h4 class=""date"">2020-01-20</h4>
+            <h4 class=""date"">2020-01-22</h4>
       
       
       <div class=""hidden name""><code>blackwhitefigures.Rmd</code></div>

---FILE: docs/articles/custplot.html---
@@ -38,7 +38,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 
@@ -139,7 +139,7 @@
       <h1>Customize Plot Appearance</h1>
                         <h4 class=""author"">Daniel Ldecke</h4>
             
-            <h4 class=""date"">2020-01-20</h4>
+            <h4 class=""date"">2020-01-22</h4>
       
       
       <div class=""hidden name""><code>custplot.Rmd</code></div>

---FILE: docs/articles/index.html---
@@ -76,7 +76,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/articles/plot_interactions.html---
@@ -38,7 +38,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 
@@ -139,7 +139,7 @@
       <h1>Plotting Interaction Effects of Regression Models</h1>
                         <h4 class=""author"">Daniel Ldecke</h4>
             
-            <h4 class=""date"">2020-01-20</h4>
+            <h4 class=""date"">2020-01-22</h4>
       
       
       <div class=""hidden name""><code>plot_interactions.Rmd</code></div>

---FILE: docs/articles/plot_likert_scales.html---
@@ -38,7 +38,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 
@@ -139,7 +139,7 @@
       <h1>Plotting Likert Scales</h1>
                         <h4 class=""author"">Daniel Ldecke</h4>
             
-            <h4 class=""date"">2020-01-20</h4>
+            <h4 class=""date"">2020-01-22</h4>
       
       
       <div class=""hidden name""><code>plot_likert_scales.Rmd</code></div>

---FILE: docs/articles/plot_marginal_effects.html---
@@ -38,7 +38,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 
@@ -139,7 +139,7 @@
       <h1>Plotting Marginal Effects of Regression Models</h1>
                         <h4 class=""author"">Daniel Ldecke</h4>
             
-            <h4 class=""date"">2020-01-20</h4>
+            <h4 class=""date"">2020-01-22</h4>
       
       
       <div class=""hidden name""><code>plot_marginal_effects.Rmd</code></div>

---FILE: docs/articles/plot_model_estimates.html---
@@ -38,7 +38,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 
@@ -139,7 +139,7 @@
       <h1>Plotting Estimates (Fixed Effects) of Regression Models</h1>
                         <h4 class=""author"">Daniel Ldecke</h4>
             
-            <h4 class=""date"">2020-01-20</h4>
+            <h4 class=""date"">2020-01-22</h4>
       
       
       <div class=""hidden name""><code>plot_model_estimates.Rmd</code></div>

---FILE: docs/articles/sjtitemanalysis.html---
@@ -38,7 +38,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 
@@ -139,7 +139,7 @@
       <h1>Item Analysis of a Scale or an Index</h1>
                         <h4 class=""author"">Daniel Ldecke</h4>
             
-            <h4 class=""date"">2020-01-20</h4>
+            <h4 class=""date"">2020-01-22</h4>
       
       
       <div class=""hidden name""><code>sjtitemanalysis.Rmd</code></div>

---FILE: docs/articles/tab_bayes.html---
@@ -38,7 +38,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 
@@ -139,7 +139,7 @@
       <h1>Summary of Bayesian Models as HTML Table</h1>
                         <h4 class=""author"">Daniel Ldecke</h4>
             
-            <h4 class=""date"">2020-01-20</h4>
+            <h4 class=""date"">2020-01-22</h4>
       
       
       <div class=""hidden name""><code>tab_bayes.Rmd</code></div>
@@ -154,39 +154,42 @@ <h4 class=""date"">2020-01-20</h4>
   %\VignetteEngine{knitr::rmarkdown}
   %\VignetteEncoding{UTF-8}
 -->
+<pre><code>## Registered S3 method overwritten by 'xts':
+##   method     from
+##   as.zoo.xts zoo</code></pre>
 <p>This vignette shows examples for using <code><a href=""../reference/tab_model.html"">tab_model()</a></code> to create HTML tables for mixed models. Basically, <code><a href=""../reference/tab_model.html"">tab_model()</a></code> behaves in a very similar way for mixed models as for other, simple regression models, as shown <a href=""tab_model_estimates.html"">in this vignette</a>.</p>
-<div class=""sourceCode"" id=""cb1""><pre class=""sourceCode r""><code class=""sourceCode r""><a class=""sourceLine"" id=""cb1-1"" title=""1""><span class=""co""># load required packages</span></a>
-<a class=""sourceLine"" id=""cb1-2"" title=""2""><span class=""kw""><a href=""https://rdrr.io/r/base/library.html"">library</a></span>(sjPlot)</a>
-<a class=""sourceLine"" id=""cb1-3"" title=""3""><span class=""kw""><a href=""https://rdrr.io/r/base/library.html"">library</a></span>(insight)</a>
-<a class=""sourceLine"" id=""cb1-4"" title=""4""><span class=""kw""><a href=""https://rdrr.io/r/base/library.html"">library</a></span>(httr)</a>
-<a class=""sourceLine"" id=""cb1-5"" title=""5""><span class=""kw""><a href=""https://rdrr.io/r/base/library.html"">library</a></span>(brms)</a>
-<a class=""sourceLine"" id=""cb1-6"" title=""6""></a>
-<a class=""sourceLine"" id=""cb1-7"" title=""7""><span class=""co""># load sample models</span></a>
-<a class=""sourceLine"" id=""cb1-8"" title=""8""></a>
-<a class=""sourceLine"" id=""cb1-9"" title=""9""><span class=""co""># zinb &lt;- read.csv(""http://stats.idre.ucla.edu/stat/data/fish.csv"")</span></a>
-<a class=""sourceLine"" id=""cb1-10"" title=""10""><span class=""co""># set.seed(123)</span></a>
-<a class=""sourceLine"" id=""cb1-11"" title=""11""><span class=""co""># m1 &lt;- brm(bf(</span></a>
-<a class=""sourceLine"" id=""cb1-12"" title=""12""><span class=""co"">#     count ~ persons + child + camper + (1 | persons),</span></a>
-<a class=""sourceLine"" id=""cb1-13"" title=""13""><span class=""co"">#     zi ~ child + camper + (1 | persons)</span></a>
-<a class=""sourceLine"" id=""cb1-14"" title=""14""><span class=""co"">#   ),</span></a>
-<a class=""sourceLine"" id=""cb1-15"" title=""15""><span class=""co"">#   data = zinb,</span></a>
-<a class=""sourceLine"" id=""cb1-16"" title=""16""><span class=""co"">#   family = zero_inflated_poisson()</span></a>
-<a class=""sourceLine"" id=""cb1-17"" title=""17""><span class=""co""># )</span></a>
-<a class=""sourceLine"" id=""cb1-18"" title=""18"">m1 &lt;-<span class=""st""> </span>insight<span class=""op"">::</span><span class=""kw""><a href=""https://rdrr.io/pkg/insight/man/download_model.html"">download_model</a></span>(<span class=""st"">""brms_zi_2""</span>)</a>
-<a class=""sourceLine"" id=""cb1-19"" title=""19""></a>
-<a class=""sourceLine"" id=""cb1-20"" title=""20""><span class=""co""># data(epilepsy)</span></a>
-<a class=""sourceLine"" id=""cb1-21"" title=""21""><span class=""co""># set.seed(123)</span></a>
-<a class=""sourceLine"" id=""cb1-22"" title=""22""><span class=""co""># epilepsy$visit &lt;- as.numeric(epilepsy$visit)</span></a>
-<a class=""sourceLine"" id=""cb1-23"" title=""23""><span class=""co""># epilepsy$Base2 &lt;- sample(epilepsy$Base, nrow(epilepsy), replace = TRUE)</span></a>
-<a class=""sourceLine"" id=""cb1-24"" title=""24""><span class=""co""># f1 &lt;- bf(Base ~ zAge + count + (1 |ID| patient))</span></a>
-<a class=""sourceLine"" id=""cb1-25"" title=""25""><span class=""co""># f2 &lt;- bf(Base2 ~ zAge + Trt + (1 |ID| patient))</span></a>
-<a class=""sourceLine"" id=""cb1-26"" title=""26""><span class=""co""># m2 &lt;- brm(f1 + f2 + set_rescor(FALSE), data = epilepsy)</span></a>
-<a class=""sourceLine"" id=""cb1-27"" title=""27"">m2 &lt;-<span class=""st""> </span>insight<span class=""op"">::</span><span class=""kw""><a href=""https://rdrr.io/pkg/insight/man/download_model.html"">download_model</a></span>(<span class=""st"">""brms_mv_3""</span>)</a></code></pre></div>
+<div class=""sourceCode"" id=""cb2""><pre class=""sourceCode r""><code class=""sourceCode r""><a class=""sourceLine"" id=""cb2-1"" title=""1""><span class=""co""># load required packages</span></a>
+<a class=""sourceLine"" id=""cb2-2"" title=""2""><span class=""kw""><a href=""https://rdrr.io/r/base/library.html"">library</a></span>(sjPlot)</a>
+<a class=""sourceLine"" id=""cb2-3"" title=""3""><span class=""kw""><a href=""https://rdrr.io/r/base/library.html"">library</a></span>(insight)</a>
+<a class=""sourceLine"" id=""cb2-4"" title=""4""><span class=""kw""><a href=""https://rdrr.io/r/base/library.html"">library</a></span>(httr)</a>
+<a class=""sourceLine"" id=""cb2-5"" title=""5""><span class=""kw""><a href=""https://rdrr.io/r/base/library.html"">library</a></span>(brms)</a>
+<a class=""sourceLine"" id=""cb2-6"" title=""6""></a>
+<a class=""sourceLine"" id=""cb2-7"" title=""7""><span class=""co""># load sample models</span></a>
+<a class=""sourceLine"" id=""cb2-8"" title=""8""></a>
+<a class=""sourceLine"" id=""cb2-9"" title=""9""><span class=""co""># zinb &lt;- read.csv(""http://stats.idre.ucla.edu/stat/data/fish.csv"")</span></a>
+<a class=""sourceLine"" id=""cb2-10"" title=""10""><span class=""co""># set.seed(123)</span></a>
+<a class=""sourceLine"" id=""cb2-11"" title=""11""><span class=""co""># m1 &lt;- brm(bf(</span></a>
+<a class=""sourceLine"" id=""cb2-12"" title=""12""><span class=""co"">#     count ~ persons + child + camper + (1 | persons),</span></a>
+<a class=""sourceLine"" id=""cb2-13"" title=""13""><span class=""co"">#     zi ~ child + camper + (1 | persons)</span></a>
+<a class=""sourceLine"" id=""cb2-14"" title=""14""><span class=""co"">#   ),</span></a>
+<a class=""sourceLine"" id=""cb2-15"" title=""15""><span class=""co"">#   data = zinb,</span></a>
+<a class=""sourceLine"" id=""cb2-16"" title=""16""><span class=""co"">#   family = zero_inflated_poisson()</span></a>
+<a class=""sourceLine"" id=""cb2-17"" title=""17""><span class=""co""># )</span></a>
+<a class=""sourceLine"" id=""cb2-18"" title=""18"">m1 &lt;-<span class=""st""> </span>insight<span class=""op"">::</span><span class=""kw""><a href=""https://rdrr.io/pkg/insight/man/download_model.html"">download_model</a></span>(<span class=""st"">""brms_zi_2""</span>)</a>
+<a class=""sourceLine"" id=""cb2-19"" title=""19""></a>
+<a class=""sourceLine"" id=""cb2-20"" title=""20""><span class=""co""># data(epilepsy)</span></a>
+<a class=""sourceLine"" id=""cb2-21"" title=""21""><span class=""co""># set.seed(123)</span></a>
+<a class=""sourceLine"" id=""cb2-22"" title=""22""><span class=""co""># epilepsy$visit &lt;- as.numeric(epilepsy$visit)</span></a>
+<a class=""sourceLine"" id=""cb2-23"" title=""23""><span class=""co""># epilepsy$Base2 &lt;- sample(epilepsy$Base, nrow(epilepsy), replace = TRUE)</span></a>
+<a class=""sourceLine"" id=""cb2-24"" title=""24""><span class=""co""># f1 &lt;- bf(Base ~ zAge + count + (1 |ID| patient))</span></a>
+<a class=""sourceLine"" id=""cb2-25"" title=""25""><span class=""co""># f2 &lt;- bf(Base2 ~ zAge + Trt + (1 |ID| patient))</span></a>
+<a class=""sourceLine"" id=""cb2-26"" title=""26""><span class=""co""># m2 &lt;- brm(f1 + f2 + set_rescor(FALSE), data = epilepsy)</span></a>
+<a class=""sourceLine"" id=""cb2-27"" title=""27"">m2 &lt;-<span class=""st""> </span>insight<span class=""op"">::</span><span class=""kw""><a href=""https://rdrr.io/pkg/insight/man/download_model.html"">download_model</a></span>(<span class=""st"">""brms_mv_3""</span>)</a></code></pre></div>
 <div id=""bayesian-models-summaries-as-html-table"" class=""section level2"">
 <h2 class=""hasAnchor"">
 <a href=""#bayesian-models-summaries-as-html-table"" class=""anchor""></a>Bayesian models summaries as HTML table</h2>
 <p>For Bayesian regression models, some of the differences to the table output from <a href=""tab_model_estimates.html"">simple models</a> or <a href=""tab_mixed.html"">mixed models</a> of <code>tab_models()</code> are the use of <em>Highest Density Intervals</em> instead of confidence intervals, the Bayes-R-squared values, and a different point estimate (which is, by default, the median from the posterior draws).</p>
-<div class=""sourceCode"" id=""cb2""><pre class=""sourceCode r""><code class=""sourceCode r""><a class=""sourceLine"" id=""cb2-1"" title=""1""><span class=""kw""><a href=""../reference/tab_model.html"">tab_model</a></span>(m1)</a></code></pre></div>
+<div class=""sourceCode"" id=""cb3""><pre class=""sourceCode r""><code class=""sourceCode r""><a class=""sourceLine"" id=""cb3-1"" title=""1""><span class=""kw""><a href=""../reference/tab_model.html"">tab_model</a></span>(m1)</a></code></pre></div>
 <table class=""table"">
 <tr>
 <th style=""border-top: double; text-align:center; font-style:normal; font-weight:bold; padding:0.2cm;  text-align:left; "">
@@ -261,23 +264,23 @@ <h2 class=""hasAnchor"">
 <sup>2</sup>
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""2"">
--0.32
+-0.12
 </td>
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; padding-top:0.1cm; padding-bottom:0.1cm;"">
 <sub>00</sub>
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""2"">
-34.21
+33.92
 </td>
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; padding-top:0.1cm; padding-bottom:0.1cm;"">
 ICC
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""2"">
--0.01
+-0.00
 </td>
 </tr>
 <tr>
@@ -310,14 +313,17 @@ <h2 class=""hasAnchor"">
 <h2 class=""hasAnchor"">
 <a href=""#multivariate-response-models"" class=""anchor""></a>Multivariate response models</h2>
 <p>For multivariate response models, like mediator-analysis-models, it is recommended to print just one model in the table, as each regression is displayed as own model in the output.</p>
-<div class=""sourceCode"" id=""cb3""><pre class=""sourceCode r""><code class=""sourceCode r""><a class=""sourceLine"" id=""cb3-1"" title=""1""><span class=""kw""><a href=""../reference/tab_model.html"">tab_model</a></span>(m2)</a></code></pre></div>
+<div class=""sourceCode"" id=""cb4""><pre class=""sourceCode r""><code class=""sourceCode r""><a class=""sourceLine"" id=""cb4-1"" title=""1""><span class=""kw""><a href=""../reference/tab_model.html"">tab_model</a></span>(m2)</a></code></pre></div>
 <table class=""table"">
 <tr>
 <th style=""border-top: double; text-align:center; font-style:normal; font-weight:bold; padding:0.2cm;  text-align:left; "">
 
 </th>
 <th colspan=""2"" style=""border-top: double; text-align:center; font-style:normal; font-weight:bold; padding:0.2cm; "">
-Base,Base 2
+Base
+</th>
+<th colspan=""2"" style=""border-top: double; text-align:center; font-style:normal; font-weight:bold; padding:0.2cm; "">
+Base2
 </th>
 </tr>
 <tr>
@@ -411,15 +417,15 @@ <h2 class=""hasAnchor"">
 <sup>2</sup>
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""4"">
-131.25
+130.52
 </td>
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; padding-top:0.1cm; padding-bottom:0.1cm;"">
 <sub>00</sub>
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""4"">
-1.34
+1.29
 </td>
 </tr>
 <tr>
@@ -452,14 +458,17 @@ <h2 class=""hasAnchor"">
 <h2 class=""hasAnchor"">
 <a href=""#show-two-credible-interval-column"" class=""anchor""></a>Show two Credible Interval-column</h2>
 <p>To show a second CI-column, use <code>show.ci50 = TRUE</code>.</p>
-<div class=""sourceCode"" id=""cb4""><pre class=""sourceCode r""><code class=""sourceCode r""><a class=""sourceLine"" id=""cb4-1"" title=""1""><span class=""kw""><a href=""../reference/tab_model.html"">tab_model</a></span>(m2, <span class=""dt"">show.ci50 =</span> <span class=""ot"">TRUE</span>)</a></code></pre></div>
+<div class=""sourceCode"" id=""cb5""><pre class=""sourceCode r""><code class=""sourceCode r""><a class=""sourceLine"" id=""cb5-1"" title=""1""><span class=""kw""><a href=""../reference/tab_model.html"">tab_model</a></span>(m2, <span class=""dt"">show.ci50 =</span> <span class=""ot"">TRUE</span>)</a></code></pre></div>
 <table class=""table"">
 <tr>
 <th style=""border-top: double; text-align:center; font-style:normal; font-weight:bold; padding:0.2cm;  text-align:left; "">
 
 </th>
 <th colspan=""3"" style=""border-top: double; text-align:center; font-style:normal; font-weight:bold; padding:0.2cm; "">
-Base,Base 2
+Base
+</th>
+<th colspan=""3"" style=""border-top: double; text-align:center; font-style:normal; font-weight:bold; padding:0.2cm; "">
+Base2
 </th>
 </tr>
 <tr>
@@ -581,15 +590,15 @@ <h2 class=""hasAnchor"">
 <sup>2</sup>
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""6"">
-129.96
+130.56
 </td>
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; padding-top:0.1cm; padding-bottom:0.1cm;"">
 <sub>00</sub>
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""6"">
-1.29
+1.26
 </td>
 </tr>
 <tr>
@@ -622,7 +631,7 @@ <h2 class=""hasAnchor"">
 <h2 class=""hasAnchor"">
 <a href=""#mixing-multivariate-and-univariate-response-models"" class=""anchor""></a>Mixing multivariate and univariate response models</h2>
 <p>When both multivariate and univariate response models are displayed in one table, a column <em>Response</em> is added for the multivariate response model, to indicate the different outcomes.</p>
-<div class=""sourceCode"" id=""cb5""><pre class=""sourceCode r""><code class=""sourceCode r""><a class=""sourceLine"" id=""cb5-1"" title=""1""><span class=""kw""><a href=""../reference/tab_model.html"">tab_model</a></span>(m1, m2)</a></code></pre></div>
+<div class=""sourceCode"" id=""cb6""><pre class=""sourceCode r""><code class=""sourceCode r""><a class=""sourceLine"" id=""cb6-1"" title=""1""><span class=""kw""><a href=""../reference/tab_model.html"">tab_model</a></span>(m1, m2)</a></code></pre></div>
 <table class=""table"">
 <tr>
 <th style=""border-top: double; text-align:center; font-style:normal; font-weight:bold; padding:0.2cm;  text-align:left; "">
@@ -828,21 +837,21 @@ <h2 class=""hasAnchor"">
 <sup>2</sup>
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""2"">
--0.47
+-0.22
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""3"">
-129.26
+129.28
 </td>
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; padding-top:0.1cm; padding-bottom:0.1cm;"">
 <sub>00</sub>
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""2"">
-33.76
+33.90
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""3"">
-1.33
+1.31
 </td>
 </tr>
 <tr>

---FILE: docs/articles/tab_mixed.html---
@@ -38,7 +38,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 
@@ -139,7 +139,7 @@
       <h1>Summary of Mixed Models as HTML Table</h1>
                         <h4 class=""author"">Daniel Ldecke</h4>
             
-            <h4 class=""date"">2020-01-20</h4>
+            <h4 class=""date"">2020-01-22</h4>
       
       
       <div class=""hidden name""><code>tab_mixed.Rmd</code></div>

---FILE: docs/articles/tab_model_estimates.html---
@@ -38,7 +38,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 
@@ -139,7 +139,7 @@
       <h1>Summary of Regression Models as HTML Table</h1>
                         <h4 class=""author"">Daniel Ldecke</h4>
             
-            <h4 class=""date"">2020-01-20</h4>
+            <h4 class=""date"">2020-01-22</h4>
       
       
       <div class=""hidden name""><code>tab_model_estimates.Rmd</code></div>

---FILE: docs/articles/table_css.html---
@@ -38,7 +38,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 
@@ -139,7 +139,7 @@
       <h1>Customizing HTML tables</h1>
                         <h4 class=""author"">Daniel Ldecke</h4>
             
-            <h4 class=""date"">2020-01-20</h4>
+            <h4 class=""date"">2020-01-22</h4>
       
       
       <div class=""hidden name""><code>table_css.Rmd</code></div>

---FILE: docs/authors.html---
@@ -76,7 +76,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 
@@ -182,12 +182,12 @@ <h1>Citation</h1>
 
     <p>Ldecke D (????).
 <em>sjPlot: Data Visualization for Statistics in Social Science</em>.
-doi: <a href=""https://doi.org/10.5281/zenodo.1308157"">10.5281/zenodo.1308157</a>, R package version 2.8.1, <a href=""https://CRAN.R-project.org/package=sjPlot"">https://CRAN.R-project.org/package=sjPlot</a>. 
+doi: <a href=""https://doi.org/10.5281/zenodo.1308157"">10.5281/zenodo.1308157</a>, R package version 2.8.2, <a href=""https://CRAN.R-project.org/package=sjPlot"">https://CRAN.R-project.org/package=sjPlot</a>. 
 </p>
     <pre>@Manual{,
   title = {sjPlot: Data Visualization for Statistics in Social Science},
   author = {Daniel Ldecke},
-  note = {R package version 2.8.1},
+  note = {R package version 2.8.2},
   url = {https://CRAN.R-project.org/package=sjPlot},
   doi = {10.5281/zenodo.1308157},
 }</pre>

---FILE: docs/index.html---
@@ -45,7 +45,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/news/index.html---
@@ -76,7 +76,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 
@@ -199,13 +199,15 @@ <h2 class=""hasAnchor"">
 <a href=""#changes-to-functions"" class=""anchor""></a>Changes to functions</h2>
 <ul>
 <li>Improved handling for <code><a href=""../reference/tab_model.html"">tab_model()</a></code> of robust estimation in general and Kenward-Roger or Satterthwaite approximations in particular for linear mixed models.</li>
+<li>Fixed issue to cope with forthcoming <em>tidyselect</em>-update.</li>
 </ul>
 </div>
 <div id=""bug-fixes"" class=""section level2"">
 <h2 class=""hasAnchor"">
 <a href=""#bug-fixes"" class=""anchor""></a>Bug fixes</h2>
 <ul>
 <li>Improved <code><a href=""../reference/tab_df.html"">tab_df()</a></code> now uses value labels for factors instead of numeric values.</li>
+<li>Fixed some issues related to the lates <em>brms</em>-update.</li>
 </ul>
 </div>
 </div>

---FILE: docs/reference/dist_chisq.html---
@@ -79,7 +79,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/dist_f.html---
@@ -79,7 +79,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/dist_norm.html---
@@ -79,7 +79,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/dist_t.html---
@@ -79,7 +79,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/efc.html---
@@ -77,7 +77,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/index.html---
@@ -76,7 +76,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/plot_frq.html---
@@ -77,7 +77,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/plot_gpt.html---
@@ -79,7 +79,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/plot_grid.html---
@@ -77,7 +77,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/plot_grpfrq.html---
@@ -78,7 +78,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/plot_kfold_cv.html---
@@ -79,7 +79,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/plot_likert.html---
@@ -77,7 +77,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/plot_model.html---
@@ -78,7 +78,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/plot_models.html---
@@ -78,7 +78,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/plot_residuals.html---
@@ -81,7 +81,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/plot_scatter.html---
@@ -79,7 +79,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/plot_stackfrq.html---
@@ -79,7 +79,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/plot_xtab.html---
@@ -77,7 +77,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/reexports.html---
@@ -82,7 +82,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/save_plot.html---
@@ -78,7 +78,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/set_theme.html---
@@ -77,7 +77,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/sjPlot-package.html---
@@ -94,7 +94,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/sjPlot-themes.html---
@@ -78,7 +78,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/sjp.aov1.html---
@@ -80,7 +80,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/sjp.chi2.html---
@@ -80,7 +80,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/sjp.corr.html---
@@ -77,7 +77,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/sjp.fa.html---
@@ -82,7 +82,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/sjp.pca.html---
@@ -82,7 +82,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/sjp.poly.html---
@@ -81,7 +81,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/sjplot.html---
@@ -82,7 +82,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/sjt.corr.html---
@@ -79,7 +79,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/sjt.fa.html---
@@ -82,7 +82,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/sjt.pca.html---
@@ -82,7 +82,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/tab_df.html---
@@ -78,7 +78,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/tab_itemscale.html---
@@ -95,7 +95,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/tab_model.html---
@@ -77,7 +77,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/tab_stackfrq.html---
@@ -80,7 +80,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/tab_xtab.html---
@@ -77,7 +77,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: docs/reference/view_df.html---
@@ -81,7 +81,7 @@
       </button>
       <span class=""navbar-brand"">
         <a class=""navbar-link"" href=""../index.html"">sjPlot</a>
-        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.1</span>
+        <span class=""version label label-default"" data-toggle=""tooltip"" data-placement=""bottom"" title=""Released version"">2.8.2</span>
       </span>
     </div>
 

---FILE: vignettes/tab_bayes.Rmd---
@@ -18,10 +18,16 @@ vignette: >
 knitr::opts_chunk$set(
   collapse = TRUE, 
   comment = ""#>"", 
-  message = FALSE,
-  eval = TRUE
-  # eval = if (isTRUE(exists(""params""))) params$EVAL else FALSE
+  message = FALSE
 )
+
+if (!requireNamespace(""insight"", quietly = TRUE) ||
+    !requireNamespace(""httr"", quietly = TRUE) ||
+    !requireNamespace(""brms"", quietly = TRUE)) {
+  knitr::opts_chunk$set(eval = FALSE)
+} else {
+  knitr::opts_chunk$set(eval = TRUE)
+}
 ```
 
 This vignette shows examples for using `tab_model()` to create HTML tables for mixed models. Basically, `tab_model()` behaves in a very similar way for mixed models as for other, simple regression models, as shown [in this vignette](tab_model_estimates.html)."
strengejacke,sjPlot,e7306145b5606a259cfae37dbefa151044d12bfc,Daniel,mail@danielluedecke.de,2020-01-22T08:04:07Z,Daniel,mail@danielluedecke.de,2020-01-22T08:04:07Z,fix issues,DESCRIPTION;NAMESPACE;NEWS.md;R/utils.R;tests/testthat/test-plot_grpfrq.R;tests/testthat/test-sjp_grpfrq.R,False,True,True,False,59,65,124,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 2.8.1
+Version: 2.8.2
 Authors@R: c(
     person(""Daniel"", ""Ldecke"", email = ""d.luedecke@uke.de"", role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0002-8895-3206"")),
     person(""Alexander"", ""Bartel"", role = ""ctb"", comment = c(ORCID = ""0000-0002-1280-6138"")),

---FILE: NAMESPACE---
@@ -130,6 +130,7 @@ importFrom(performance,cronbachs_alpha)
 importFrom(performance,icc)
 importFrom(performance,item_intercor)
 importFrom(performance,item_reliability)
+importFrom(performance,performance_aic)
 importFrom(performance,performance_aicc)
 importFrom(performance,r2)
 importFrom(psych,KMO)
@@ -199,7 +200,6 @@ importFrom(sjstats,robust)
 importFrom(sjstats,table_values)
 importFrom(sjstats,weight2)
 importFrom(sjstats,weighted_sd)
-importFrom(stats,AIC)
 importFrom(stats,aov)
 importFrom(stats,as.formula)
 importFrom(stats,binomial)

---FILE: NEWS.md---
@@ -8,6 +8,7 @@
 ## Changes to functions
 
 * Improved handling for `tab_model()` of robust estimation in general and Kenward-Roger or Satterthwaite approximations in particular for linear mixed models.
+* Fixed issue to cope with forthcoming *tidyselect*-update.
 
 ## Bug fixes
 

---FILE: R/utils.R---
@@ -320,14 +320,9 @@ model_deviance <- function(x) {
 }
 
 
-#' @importFrom stats AIC
+#' @importFrom performance performance_aic
 model_aic <- function(x) {
-  tryCatch(
-    {
-      stats::AIC(x)
-    },
-    error = function(x) { NULL }
-  )
+  performance::performance_aic(x)
 }
 
 

---FILE: tests/testthat/test-plot_grpfrq.R---
@@ -0,0 +1,54 @@
+if (suppressWarnings(
+  require(""testthat"") &&
+  require(""sjPlot"")
+)) {
+
+  # glm, logistic regression ----
+  data(efc)
+  efc$gewicht <- rnorm(nrow(efc), 1, .2)
+
+  test_that(""plot_grpfrq"", {
+    p <- plot_grpfrq(efc$e17age, efc$e16sex)
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, type = ""dot"")
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, type = ""line"")
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, type = ""boxplot"")
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, type = ""violin"")
+
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, bar.pos = ""stack"")
+
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, type = ""boxplot"", intr.var = efc$c172code)
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, type = ""violin"", intr.var = efc$c172code)
+
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, show.values = FALSE)
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, show.values = FALSE, show.n = TRUE)
+
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, show.values = TRUE, show.n = TRUE)
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, type = ""dot"", show.values = TRUE, show.n = TRUE)
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, show.values = TRUE, show.n = TRUE, show.prc = TRUE)
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, type = ""dot"", show.values = TRUE, show.n = TRUE, show.prc = TRUE)
+
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, show.grpcnt = TRUE)
+    expect_message(p <- plot_grpfrq(efc$e17age, efc$e16sex, type = ""boxplot"", show.grpcnt = TRUE))
+    expect_message(p <- plot_grpfrq(efc$e17age, efc$e16sex, type = ""boxplot"", intr.var = efc$c172code, show.grpcnt = TRUE))
+
+    p <- plot_grpfrq(efc$e42dep, efc$e16sex, type = ""bar"", show.grpcnt = TRUE)
+
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, type = ""dot"")
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, type = ""dot"", show.ci = T)
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, type = ""line"", show.ci = T)
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, type = ""boxplot"", show.ci = T)
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, type = ""violin"", show.ci = T)
+
+    p <- plot_grpfrq(efc$e42dep, efc$e16sex, weight.by = efc$gewicht)
+    p <- plot_grpfrq(efc$e42dep, efc$e16sex, type = ""dot"", weight.by = efc$gewicht)
+    p <- plot_grpfrq(efc$e42dep, efc$e16sex, type = ""line"", weight.by = efc$gewicht)
+    p <- plot_grpfrq(efc$e42dep, efc$e16sex, type = ""boxplot"", weight.by = efc$gewicht)
+    p <- plot_grpfrq(efc$e42dep, efc$e16sex, type = ""violin"", weight.by = efc$gewicht)
+
+    p <- plot_grpfrq(efc$e42dep, efc$e16sex, legend.title = ""Geschlecht"", legend.labels = c(""M"", ""W""), axis.titles = ""Dependency"", axis.labels = c(""gar nicht"", ""leicht"", ""mittel"", ""schwer""))
+    p <- plot_grpfrq(efc$e42dep, efc$e16sex, type = ""dot"", legend.title = ""Geschlecht"", legend.labels = c(""M"", ""W""), axis.titles = ""Dependency"", axis.labels = c(""gar nicht"", ""leicht"", ""mittel"", ""schwer""))
+    p <- plot_grpfrq(efc$e42dep, efc$e16sex, type = ""line"", legend.title = ""Geschlecht"", legend.labels = c(""M"", ""W""), axis.titles = ""Dependency"", axis.labels = c(""gar nicht"", ""leicht"", ""mittel"", ""schwer""))
+    p <- plot_grpfrq(efc$e42dep, efc$e16sex, type = ""boxplot"", legend.title = ""Geschlecht"", legend.labels = c(""M"", ""W""), axis.titles = ""Dependency"", axis.labels = c(""A"", ""B""))
+    p <- plot_grpfrq(efc$e17age, efc$e16sex, type = ""violin"", legend.title = ""Geschlecht"", legend.labels = c(""M"", ""W""), axis.titles = ""Dependency"", axis.labels = c(""A"", ""B""))
+  })
+}

---FILE: tests/testthat/test-sjp_grpfrq.R---
@@ -1,56 +0,0 @@
-if (suppressWarnings(
-  require(""testthat"") &&
-  require(""sjPlot"")
-)) {
-
-  context(""sjPlot, sjp.grpfrq"")
-
-  # glm, logistic regression ----
-  data(efc)
-  efc$gewicht <- rnorm(nrow(efc), 1, .2)
-
-  test_that(""sjp.grpfrq"", {
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex)
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, type = ""dot"")
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, type = ""line"")
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, type = ""boxplot"")
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, type = ""violin"")
-
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, bar.pos = ""stack"")
-
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, type = ""boxplot"", intr.var = efc$c172code)
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, type = ""violin"", intr.var = efc$c172code)
-
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, show.values = FALSE)
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, show.values = FALSE, show.n = TRUE)
-
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, show.values = TRUE, show.n = TRUE)
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, type = ""dot"", show.values = TRUE, show.n = TRUE)
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, show.values = TRUE, show.n = TRUE, show.prc = TRUE)
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, type = ""dot"", show.values = TRUE, show.n = TRUE, show.prc = TRUE)
-
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, show.grpcnt = TRUE)
-    expect_message(p <- sjp.grpfrq(efc$e17age, efc$e16sex, type = ""boxplot"", show.grpcnt = TRUE))
-    expect_message(p <- sjp.grpfrq(efc$e17age, efc$e16sex, type = ""boxplot"", intr.var = efc$c172code, show.grpcnt = TRUE))
-
-    p <- sjp.grpfrq(efc$e42dep, efc$e16sex, type = ""bar"", show.grpcnt = TRUE)
-
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, type = ""dot"")
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, type = ""dot"", show.ci = T)
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, type = ""line"", show.ci = T)
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, type = ""boxplot"", show.ci = T)
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, type = ""violin"", show.ci = T)
-
-    p <- sjp.grpfrq(efc$e42dep, efc$e16sex, weight.by = efc$gewicht)
-    p <- sjp.grpfrq(efc$e42dep, efc$e16sex, type = ""dot"", weight.by = efc$gewicht)
-    p <- sjp.grpfrq(efc$e42dep, efc$e16sex, type = ""line"", weight.by = efc$gewicht)
-    p <- sjp.grpfrq(efc$e42dep, efc$e16sex, type = ""boxplot"", weight.by = efc$gewicht)
-    p <- sjp.grpfrq(efc$e42dep, efc$e16sex, type = ""violin"", weight.by = efc$gewicht)
-
-    p <- sjp.grpfrq(efc$e42dep, efc$e16sex, legend.title = ""Geschlecht"", legend.labels = c(""M"", ""W""), axis.titles = ""Dependency"", axis.labels = c(""gar nicht"", ""leicht"", ""mittel"", ""schwer""))
-    p <- sjp.grpfrq(efc$e42dep, efc$e16sex, type = ""dot"", legend.title = ""Geschlecht"", legend.labels = c(""M"", ""W""), axis.titles = ""Dependency"", axis.labels = c(""gar nicht"", ""leicht"", ""mittel"", ""schwer""))
-    p <- sjp.grpfrq(efc$e42dep, efc$e16sex, type = ""line"", legend.title = ""Geschlecht"", legend.labels = c(""M"", ""W""), axis.titles = ""Dependency"", axis.labels = c(""gar nicht"", ""leicht"", ""mittel"", ""schwer""))
-    p <- sjp.grpfrq(efc$e42dep, efc$e16sex, type = ""boxplot"", legend.title = ""Geschlecht"", legend.labels = c(""M"", ""W""), axis.titles = ""Dependency"", axis.labels = c(""A"", ""B""))
-    p <- sjp.grpfrq(efc$e17age, efc$e16sex, type = ""violin"", legend.title = ""Geschlecht"", legend.labels = c(""M"", ""W""), axis.titles = ""Dependency"", axis.labels = c(""A"", ""B""))
-  })
-}"
strengejacke,sjPlot,9b8af3f0fe5984d0ef8491eb27729ff7ebd56f5a,Daniel,mail@danielluedecke.de,2020-01-12T19:42:36Z,Daniel,mail@danielluedecke.de,2020-01-12T19:42:36Z,fix issues inm forthcoming tidyselect,NAMESPACE;R/select_helpers.R;R/sjPlotxtab.R,False,True,True,False,26,3,29,"---FILE: NAMESPACE---
@@ -250,6 +250,7 @@ importFrom(stats,qf)
 importFrom(stats,qnorm)
 importFrom(stats,qt)
 importFrom(stats,quantile)
+importFrom(stats,reshape)
 importFrom(stats,residuals)
 importFrom(stats,rstudent)
 importFrom(stats,sd)

---FILE: R/select_helpers.R---
@@ -34,3 +34,26 @@ obj_has_name <- function(x, name) {
 obj_has_rownames <- function(x) {
   !identical(as.character(1:nrow(x)), rownames(x))
 }
+
+
+
+#' @importFrom stats reshape
+#' @keywords internal
+.gather <- function(x, names_to = ""key"", values_to = ""value"", columns = colnames(x)) {
+  if (is.numeric(columns)) columns <- colnames(x)[columns]
+  dat <- stats::reshape(
+    x,
+    idvar = ""id"",
+    ids = row.names(x),
+    times = columns,
+    timevar = names_to,
+    v.names = values_to,
+    varying = list(columns),
+    direction = ""long""
+  )
+
+  if (is.factor(dat[[values_to]]))
+    dat[[values_to]] <- as.character(dat[[values_to]])
+
+  dat[, 1:(ncol(dat) - 1), drop = FALSE]
+}

---FILE: R/sjPlotxtab.R---
@@ -76,7 +76,6 @@
 #'
 #' @import ggplot2
 #' @importFrom dplyr group_by mutate arrange filter select summarize
-#' @importFrom tidyr gather
 #' @importFrom scales percent
 #' @importFrom stats na.omit
 #' @export
@@ -241,7 +240,7 @@ plot_xtab <- function(x,
   # -----------------------------------------------
   # tidy data
   #---------------------------------------------------
-  mydf <- tidyr::gather(myptab, ""group"", ""prc"", !! 2:(grpcount + 1), factor_key = TRUE)
+  mydf <- .gather(myptab, names_to = ""group"", values_to = ""prc"", columns = 2:(grpcount + 1))
   # -----------------------------------------------
   # add total column and row to n-values
   #---------------------------------------------------
@@ -252,7 +251,7 @@ plot_xtab <- function(x,
   # -----------------------------------------------
   # add n-values to tidy data frame
   #---------------------------------------------------
-  dummydf <- tidyr::gather(mydat$mydat, ""group"", ""n"", !! 2:(grpcount + 1), factor_key = TRUE)
+  dummydf <- .gather(mydat$mydat, names_to = ""group"", values_to = ""n"", columns = 2:(grpcount + 1))
   mydf$n <- as.numeric(dummydf$n)
   # -----------------------------------------------
   # remove total for row and column index"
strengejacke,sjPlot,b458fede6ec2b0c686c4ce237045db4a81e1d7e0,iago-pssjd,40892925+iago-pssjd@users.noreply.github.com,2019-12-16T16:08:08Z,GitHub,noreply@github.com,2019-12-16T16:08:08Z,"Update tab_df_content specifying suitably data.frame element

To solve issue #337, data.frame element is suitably specified.",R/html_print_utils.R,False,True,True,False,1,1,2,"---FILE: R/html_print_utils.R---
@@ -164,7 +164,7 @@ tab_df_content <- function(
         arcstring,
         mcc,
         ccnt,
-        mydf[rcnt, ccnt])
+        mydf[[ccnt]][rcnt])
       )
     }
 "
strengejacke,sjPlot,ad23ee12e79b1b479cd2bb172aad73d4abe887a2,Daniel,mail@danielluedecke.de,2019-11-27T07:54:16Z,Daniel,mail@danielluedecke.de,2019-11-27T07:54:16Z,hotfix for CRAN,DESCRIPTION,False,False,False,False,2,2,4,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 2.8.0.1
+Version: 2.8.1
 Authors@R: c(
     person(""Daniel"", ""Ldecke"", email = ""d.luedecke@uke.de"", role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0002-8895-3206"")),
     person(""Alexander"", ""Bartel"", role = ""ctb"", comment = c(ORCID = ""0000-0002-1280-6138"")),
@@ -36,7 +36,7 @@ Imports:
     ggplot2 (>= 3.2.0),
     ggrepel,
     knitr,
-    insight (>= 0.6.0),
+    insight (>= 0.7.0),
     lme4 (>= 1.1-12),
     magrittr,
     MASS,"
strengejacke,sjPlot,d5c9ff9867624db0edbbd66d8532911467edcea9,Daniel,mail@danielluedecke.de,2019-11-26T16:27:14Z,Daniel,mail@danielluedecke.de,2019-11-26T16:27:14Z,fix check issues,R/plot_models.R;R/plot_type_est.R,False,True,True,False,6,0,6,"---FILE: R/plot_models.R---
@@ -164,6 +164,9 @@ plot_models <- function(...,
       show.zeroinf = FALSE,
       p.val = ""wald"",
       standardize = std_method,
+      bootstrap = FALSE,
+      iterations = 1000,
+      seed = NULL,
       ...
     )
   )

---FILE: R/plot_type_est.R---
@@ -61,6 +61,9 @@ plot_type_est <- function(type,
       show.zeroinf = show.zeroinf,
       p.val = ""wald"",
       standardize = std_method,
+      bootstrap = FALSE,
+      iterations = 1000,
+      seed = NULL,
       ...
     )
 "
strengejacke,sjPlot,9bc7a9092eff48643016a0ee34fd7098de533aef,Daniel,mail@danielluedecke.de,2019-11-26T15:46:28Z,Daniel,mail@danielluedecke.de,2019-11-26T15:46:28Z,fix with label sorting,R/tab_model.R,False,True,True,False,5,1,6,"---FILE: R/tab_model.R---
@@ -982,7 +982,11 @@ tab_model <- function(
         models = models
       )
     } else {
-      pred.labels <- unique(unlist(lapply(models, parameters::format_parameters)))
+      pred.labels <- NULL
+      for (pl_counter in 1:length(models)) {
+        pred.labels <- c(pred.labels, parameters::format_parameters(models[[pl_counter]]))
+      }
+      pred.labels <- pred.labels[!duplicated(names(pred.labels))]
       show.reflvl <- FALSE
     }
   } else {"
strengejacke,sjPlot,c2a03771e416c11d39500b66f6ac39fd3c7cc842,AmirDJV,Amir.DJV@gmail.com,2019-11-26T12:55:37Z,AmirDJV,Amir.DJV@gmail.com,2019-11-26T12:55:37Z,fixed ctb in DESCRIPTION,DESCRIPTION,False,False,False,False,1,1,2,"---FILE: DESCRIPTION---
@@ -8,7 +8,7 @@ Authors@R: c(
     person(""Alexander"", ""Bartel"", role = ""ctb"", comment = c(ORCID = ""0000-0002-1280-6138"")),
     person(""Carsten"", ""Schwemmer"", email = ""carsten.schwemmer@uni-bamberg.de"", role = ""ctb""),
     person(given = ""Chuck"", family = ""Powell"", role = ""ctb"", email = ""ibecav@gmail.com"", comment = c(ORCID = ""0000-0002-3606-2188"")), 
-    person(given = ""Amir"", family = ""Djalovski"", role = ""ctb"", email = ""Amir.DJV@gmail.com""))
+    person(given = ""Amir"", family = ""Djalovski"", role = ""ctb"", email = ""Amir.DJV@gmail.com"")
           )
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of plotting and table output functions for data"
strengejacke,sjPlot,2852c72c40612f0d2ff712a2c00f7512efe78263,AmirDJV,Amir.DJV@gmail.com,2019-11-26T09:57:16Z,AmirDJV,Amir.DJV@gmail.com,2019-11-26T09:57:16Z,fixed argument,R/tab_model.R,False,True,True,False,2,2,4,"---FILE: R/tab_model.R---
@@ -223,8 +223,8 @@ tab_model <- function(
   show.intercept = TRUE,
   show.est = TRUE,
   show.ci = .95,
-  bootstrap = bootstrap,
-  iterations = iterations,
+  bootstrap = FALSE,
+  iterations = 1000,
   seed = NULL,
   show.ci50 = FALSE,
   show.se = NULL,"
strengejacke,sjPlot,89cabc9ae882cff18ddf9c576ea39879cf515fea,Daniel,mail@danielluedecke.de,2019-11-22T10:52:31Z,Daniel,mail@danielluedecke.de,2019-11-22T10:52:31Z,fix check issues,R/tab_model.R;tests/testthat/test-tab_model.R,False,True,True,False,15,3,18,"---FILE: R/tab_model.R---
@@ -646,7 +646,7 @@ tab_model <- function(
       }
 
       # sanity check for models currently not supported by ""get_variance()""
-      if (!is.null(vars) && is.na(vars)) vars <- NULL
+      if (!is.null(vars) && length(vars) == 1 && is.na(vars)) vars <- NULL
 
       # Add ICC statistic ----
 

---FILE: tests/testthat/test-tab_model.R---
@@ -4,12 +4,14 @@ if (suppressWarnings(
   require(""testthat"") &&
   require(""sjPlot"") &&
   require(""sjmisc"") &&
-  require(""lme4"")
+  require(""lme4"") &&
+  require(""glmmTMB"")
 )) {
 
   context(""sjPlot, tab_model type std"")
 
   data(sleepstudy)
+  data(Salamanders)
   data(iris)
   data(efc)
 
@@ -19,10 +21,21 @@ if (suppressWarnings(
   m2 <- lmer(Sepal.Length ~ Sepal.Width + Petal.Length + (1 | Species), data = iris)
   m3 <- lm(neg_c_7 ~ e42dep + barthtot + c161sex, data = efc)
 
+  m4 <- glmmTMB(
+    count ~ spp + mined + (1 | site),
+    ziformula = ~ spp + mined,
+    family = truncated_nbinom2,
+    Salamanders
+  )
+
   test_that(""tab_model"", {
     p <- tab_model(m1, m2, m3)
   })
 
+  test_that(""tab_model"", {
+    expect_warning(tab_model(m1, m2, m3, m4))
+  })
+
   test_that(""tab_model, check shows"", {
     p <- tab_model(m1, m2, m3, show.intercept = FALSE, show.fstat = TRUE, show.se = TRUE)
     p <- tab_model(m1, m2, m3, show.intercept = FALSE, show.fstat = TRUE, show.se = TRUE, show.ci = F, show.df = TRUE, p.val = ""kr"")
@@ -44,7 +57,6 @@ if (suppressWarnings(
     p <- tab_model(m1, m2, m3, show.std = ""std2"")
   })
 
-
   if (.runThisTest) {
 
     if (suppressWarnings("
strengejacke,sjPlot,56bdcad318fbf8f280b2c04c6e3903e44b11b9e5,Daniel,mail@danielluedecke.de,2019-11-22T09:04:15Z,Daniel,mail@danielluedecke.de,2019-11-22T09:04:15Z,fix check issues,NAMESPACE;R/plot_frq.R,False,True,True,False,4,3,7,"---FILE: NAMESPACE---
@@ -205,7 +205,7 @@ importFrom(sjstats,phi)
 importFrom(sjstats,robust)
 importFrom(sjstats,table_values)
 importFrom(sjstats,weight2)
-importFrom(sjstats,weighted_sd)
+importFrom(sjstats,wtd_sd)
 importFrom(sjstats,xtab_statistics)
 importFrom(stats,AIC)
 importFrom(stats,aov)

---FILE: R/plot_frq.R---
@@ -106,7 +106,7 @@ utils::globalVariables(""density"")
 #'         normal.curve.size = 3, ylim = c(0,50))
 #'
 #' @import ggplot2
-#' @importFrom sjstats weighted_sd
+#' @importFrom sjstats wtd_sd
 #' @importFrom sjmisc group_labels group_var to_value frq
 #' @importFrom sjlabelled set_labels drop_labels
 #' @importFrom stats na.omit sd weighted.mean dnorm
@@ -383,7 +383,8 @@ plot_frq_helper <- function(
     stddev <- stats::sd(var.cnt, na.rm = TRUE)
   } else {
     mittelwert <- stats::weighted.mean(var.cnt, weight.by, na.rm = TRUE)
-    stddev <- sjstats::weighted_sd(var.cnt, weights = weight.by)
+    ## TODO replace with ""weighted_sd()"" later
+    stddev <- sjstats::wtd_sd(var.cnt, weights = weight.by)
   }
 
   # If we have boxplots, use different data frame structure"
strengejacke,sjPlot,2ce7fcf63a7a74d75192350409d142e72e64aec4,Daniel,mail@danielluedecke.de,2019-11-22T08:19:14Z,Daniel,mail@danielluedecke.de,2019-11-22T08:19:14Z,fix glmmTMB trunc negbin,NEWS.md;R/tab_model.R,False,True,True,False,4,0,4,"---FILE: NEWS.md---
@@ -3,6 +3,7 @@
 ## Bug fixes
 
 * Fixed issue in `tab_model()` with detecting labels when `auto.label = TRUE`.
+* Fixed issue in `tab_model()` for negative binomial hurdle mixed models (i.e. *glmmTMB* models with truncated negative-binomial family).
 * Fixed bug in `tab_model()` with `show.reflvl = TRUE`.
 
 # sjPlot 2.8.0

---FILE: R/tab_model.R---
@@ -645,6 +645,9 @@ tab_model <- function(
         vars <- NULL
       }
 
+      # sanity check for models currently not supported by ""get_variance()""
+      if (!is.null(vars) && is.na(vars)) vars <- NULL
+
       # Add ICC statistic ----
 
       icc <- NULL"
strengejacke,sjPlot,30d0fa35d4aee7c33af2cecd68f87b10be891250,Daniel,mail@danielluedecke.de,2019-11-19T08:42:28Z,Daniel,mail@danielluedecke.de,2019-11-19T08:42:28Z,"fix to auto.label, update vignettes",R/tab_model.R;docs/articles/tab_bayes.html;docs/articles/tab_mixed.html;docs/articles/tab_model_estimates.html,False,True,True,False,70,70,140,"---FILE: R/tab_model.R---
@@ -963,7 +963,7 @@ tab_model <- function(
         categorical = category.values[no.dupes],
         models = models
       )
-    } else {
+    } else if (!show.reflvl) {
       pred.labels <- unique(unlist(lapply(models, parameters::format_parameters)))
       show.reflvl <- FALSE
     }

---FILE: docs/articles/tab_bayes.html---
@@ -139,7 +139,7 @@
       <h1>Summary of Bayesian Models as HTML Table</h1>
                         <h4 class=""author"">Daniel Ldecke</h4>
             
-            <h4 class=""date"">2019-11-18</h4>
+            <h4 class=""date"">2019-11-19</h4>
       
       
       <div class=""hidden name""><code>tab_bayes.Rmd</code></div>
@@ -261,15 +261,15 @@ <h2 class=""hasAnchor"">
 <sup>2</sup>
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""2"">
-5.43
+5.34
 </td>
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; padding-top:0.1cm; padding-bottom:0.1cm;"">
 <sub>00</sub>
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""2"">
-34.09
+34.02
 </td>
 </tr>
 <tr>
@@ -414,15 +414,15 @@ <h2 class=""hasAnchor"">
 <sup>2</sup>
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""4"">
-131.16
+130.56
 </td>
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; padding-top:0.1cm; padding-bottom:0.1cm;"">
 <sub>00</sub>
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""4"">
-1.31
+1.27
 </td>
 </tr>
 <tr>
@@ -587,15 +587,15 @@ <h2 class=""hasAnchor"">
 <sup>2</sup>
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""6"">
-130.72
+128.97
 </td>
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; padding-top:0.1cm; padding-bottom:0.1cm;"">
 <sub>00</sub>
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""6"">
-1.37
+1.35
 </td>
 </tr>
 <tr>
@@ -834,29 +834,29 @@ <h2 class=""hasAnchor"">
 <sup>2</sup>
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""2"">
-5.21
+5.22
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""3"">
-130.04
+133.99
 </td>
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; padding-top:0.1cm; padding-bottom:0.1cm;"">
 <sub>00</sub>
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""2"">
-33.99
+33.84
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""3"">
-1.38
+1.29
 </td>
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; padding-top:0.1cm; padding-bottom:0.1cm;"">
 ICC
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""2"">
-0.13
+0.14
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;"" colspan=""3"">
 0.98

---FILE: docs/articles/tab_mixed.html---
@@ -139,7 +139,7 @@
       <h1>Summary of Mixed Models as HTML Table</h1>
                         <h4 class=""author"">Daniel Ldecke</h4>
             
-            <h4 class=""date"">2019-11-18</h4>
+            <h4 class=""date"">2019-11-19</h4>
       
       
       <div class=""hidden name""><code>tab_mixed.Rmd</code></div>
@@ -231,7 +231,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c160age
+carerage
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 -0.00
@@ -251,7 +251,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c161sex
+carers gender
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 0.47
@@ -271,7 +271,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-e42dep
+elders dependency
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 1.45
@@ -635,7 +635,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c160age
+carerage
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 -0.00
@@ -658,7 +658,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c161sex
+carers gender
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 0.47
@@ -681,7 +681,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-e42dep
+elders dependency
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 1.45
@@ -857,7 +857,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c160age
+carerage
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 -0.00
@@ -878,7 +878,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c161sex
+carers gender
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 0.47
@@ -899,7 +899,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-e42dep
+elders dependency
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 1.45
@@ -922,7 +922,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-spp [PR]
+spp: PR
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 </td>
@@ -941,7 +941,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-spp [DM]
+spp: DM
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 </td>
@@ -960,7 +960,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-spp [EC-A]
+spp: EC-A
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 </td>
@@ -979,7 +979,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-spp [EC-L]
+spp: EC-L
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 </td>
@@ -999,7 +999,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-spp [DES-L]
+spp: DES-L
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 </td>
@@ -1019,7 +1019,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-spp [DF]
+spp: DF
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 </td>
@@ -1038,7 +1038,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-mined [no]
+mined: no
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 </td>
@@ -1083,7 +1083,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-sppPR
+spp: PR
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 </td>
@@ -1103,7 +1103,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-sppDM
+spp: DM
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 </td>
@@ -1122,7 +1122,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-sppEC-A
+spp: EC-A
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 </td>
@@ -1141,7 +1141,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-sppEC-L
+spp: EC-L
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 </td>
@@ -1160,7 +1160,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-sppDES-L
+spp: DES-L
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 </td>
@@ -1179,7 +1179,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-sppDF
+spp: DF
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 </td>
@@ -1198,7 +1198,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-minedno
+mined: no
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 </td>

---FILE: docs/articles/tab_model_estimates.html---
@@ -139,7 +139,7 @@
       <h1>Summary of Regression Models as HTML Table</h1>
                         <h4 class=""author"">Daniel Ldecke</h4>
             
-            <h4 class=""date"">2019-11-18</h4>
+            <h4 class=""date"">2019-11-19</h4>
       
       
       <div class=""hidden name""><code>tab_model_estimates.Rmd</code></div>
@@ -600,7 +600,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c160age
+carerage
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 -0.21
@@ -623,7 +623,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c12hour
+average number of hours<br>of care per week
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 -0.28
@@ -648,7 +648,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c161sex [2]
+carers gender: Female
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 -0.39
@@ -671,7 +671,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c172code [2]
+carers level of<br>education: intermediate<br>level of education
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 1.37
@@ -691,7 +691,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c172code [3]
+carers level of<br>education: high level of<br>education
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 -1.64
@@ -711,7 +711,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-e17age
+elderage
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 </td>
@@ -833,7 +833,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c160age
+carerage
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 1.01
@@ -854,7 +854,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c12hour
+average number of hours<br>of care per week
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 1.00
@@ -875,7 +875,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c161sex [2]
+carers gender: Female
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 1.01
@@ -898,7 +898,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c172code [2]
+carers level of<br>education: intermediate<br>level of education
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 1.47
@@ -922,7 +922,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c172code [3]
+carers level of<br>education: high level of<br>education
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 1.90
@@ -946,7 +946,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-barthtot
+Total score BARTHEL INDEX
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 </td>
@@ -2904,7 +2904,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-spp [PR]
+sppPR
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 0.25
@@ -2919,7 +2919,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-spp [DM]
+sppDM
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 1.26
@@ -2933,7 +2933,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-spp [EC-A]
+sppEC-A
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 0.46
@@ -2948,7 +2948,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-spp [EC-L]
+sppEC-L
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 1.86
@@ -2963,7 +2963,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-spp [DES-L]
+sppDES-L
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 1.97
@@ -2978,7 +2978,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-spp [DF]
+sppDF
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 1.08
@@ -3006,7 +3006,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-mined [no]
+minedno
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 9.97
@@ -3093,7 +3093,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-spp [PR]
+sppPR
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 0.25
@@ -3108,7 +3108,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-spp [DM]
+sppDM
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 1.26
@@ -3122,7 +3122,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-spp [EC-A]
+sppEC-A
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 0.46
@@ -3137,7 +3137,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-spp [EC-L]
+sppEC-L
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 1.86
@@ -3152,7 +3152,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-spp [DES-L]
+sppDES-L
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 1.97
@@ -3167,7 +3167,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-spp [DF]
+sppDF
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 1.08
@@ -3195,7 +3195,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-mined [no]
+minedno
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 9.97
@@ -3294,7 +3294,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c160age
+carerage
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 -0.21 <sup>**</sup>
@@ -3311,7 +3311,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c12hour
+average number of hours<br>of care per week
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 -0.28 <sup>***</sup>
@@ -3328,7 +3328,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c161sex [2]
+carers gender: Female
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 -0.39 <sup></sup>
@@ -3345,7 +3345,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c172code [2]
+carers level of<br>education: intermediate<br>level of education
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 1.37 <sup></sup>
@@ -3360,7 +3360,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-c172code [3]
+carers level of<br>education: high level of<br>education
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 -1.64 <sup></sup>
@@ -3375,7 +3375,7 @@ <h2 class=""hasAnchor"">
 </tr>
 <tr>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; "">
-e17age
+elderage
 </td>
 <td style="" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  "">
 </td>"
strengejacke,sjPlot,a55afdf57c7a07215e431847d9d94ba2e88f62d7,Daniel Ldecke,mail@danielluedecke.de,2019-11-18T09:00:17Z,Daniel Ldecke,mail@danielluedecke.de,2019-11-18T09:00:17Z,fix check issues,DESCRIPTION;NAMESPACE;NEWS.md;R/sjPlotPearsonsChi2Test.R;R/sjTabItemAnalysis.R;man/sjt.itemanalysis.Rd,False,True,True,False,10,8,18,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 2.7.2.1
+Version: 2.8.0
 Authors@R: c(
     person(""Daniel"", ""Ldecke"", email = ""d.luedecke@uke.de"", role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0002-8895-3206"")),
     person(""Alexander"", ""Bartel"", role = ""ctb"", comment = c(ORCID = ""0000-0002-1280-6138"")),

---FILE: NAMESPACE---
@@ -110,6 +110,7 @@ importFrom(grDevices,colorRampPalette)
 importFrom(grDevices,dev.off)
 importFrom(grDevices,jpeg)
 importFrom(grDevices,png)
+importFrom(grDevices,rgb)
 importFrom(grDevices,svg)
 importFrom(grDevices,tiff)
 importFrom(graphics,plot)

---FILE: NEWS.md---
@@ -1,4 +1,4 @@
-# sjPlot 2.7.3
+# sjPlot 2.8.0
 
 ## Breaking changes
 

---FILE: R/sjPlotPearsonsChi2Test.R---
@@ -28,6 +28,7 @@
 #' sjp.chi2(mydf, axis.labels = items)
 #'
 #' @import ggplot2
+#' @importFrom grDevices rgb
 #' @importFrom dplyr bind_rows
 #' @export
 sjp.chi2 <- function(df,
@@ -89,9 +90,9 @@ sjp.chi2 <- function(df,
     geom_tile() +
     scale_x_discrete(labels = axis.labels) +
     scale_y_discrete(labels = axis.labels) +
-    scale_fill_gradient2(low = rgb(128, 205, 193, maxColorValue = 255),
+    scale_fill_gradient2(low = grDevices::rgb(128, 205, 193, maxColorValue = 255),
                          mid = ""white"",
-                         high = rgb(5, 113, 176, maxColorValue = 255),
+                         high = grDevices::rgb(5, 113, 176, maxColorValue = 255),
                          midpoint = 0.05) +
     geom_text(label = sprintf(""%.3f"", m$p.value)) +
     labs(title = title,

---FILE: R/sjTabItemAnalysis.R---
@@ -83,8 +83,8 @@
 #'
 #' @references \itemize{
 #'              \item Jorion N, Self B, James K, Schroeder L, DiBello L, Pellegrino J (2013) Classical Test Theory Analysis of the Dynamics Concept Inventory. (\href{https://www.academia.edu/4104752/Classical_Test_Theory_Analysis_of_the_Dynamics_Concept_Inventory}{web})
-#'              \item Briggs SR, Cheek JM (1986) The role of factor analysis in the development and evaluation of personality scales. Journal of Personality, 54(1), 106-148. \doi{10.1111/j.1467-6494.1986.tb00391.x}
-#'              \item McLean S et al. (2013) Stigmatizing attitudes and beliefs about bulimia nervosa: Gender, age, education and income variability in a community sample. International Journal of Eating Disorders. \doi{10.1002/eat.22227}
+#'              \item Briggs SR, Cheek JM (1986) The role of factor analysis in the development and evaluation of personality scales. Journal of Personality, 54(1), 106-148. doi: 10.1111/j.1467-6494.1986.tb00391.x
+#'              \item McLean S et al. (2013) Stigmatizing attitudes and beliefs about bulimia nervosa: Gender, age, education and income variability in a community sample. International Journal of Eating Disorders. doi: 10.1002/eat.22227
 #'              \item Trochim WMK (2008) Types of Reliability. (\href{http://www.socialresearchmethods.net/kb/reltypes.php}{web})
 #'             }
 #'

---FILE: man/sjt.itemanalysis.Rd---
@@ -163,8 +163,8 @@ sjt.itemanalysis(mydf, factor.groups = ""auto"")}
 \references{
 \itemize{
              \item Jorion N, Self B, James K, Schroeder L, DiBello L, Pellegrino J (2013) Classical Test Theory Analysis of the Dynamics Concept Inventory. (\href{https://www.academia.edu/4104752/Classical_Test_Theory_Analysis_of_the_Dynamics_Concept_Inventory}{web})
-             \item Briggs SR, Cheek JM (1986) The role of factor analysis in the development and evaluation of personality scales. Journal of Personality, 54(1), 106-148. \doi{10.1111/j.1467-6494.1986.tb00391.x}
-             \item McLean S et al. (2013) Stigmatizing attitudes and beliefs about bulimia nervosa: Gender, age, education and income variability in a community sample. International Journal of Eating Disorders. \doi{10.1002/eat.22227}
+             \item Briggs SR, Cheek JM (1986) The role of factor analysis in the development and evaluation of personality scales. Journal of Personality, 54(1), 106-148. doi: 10.1111/j.1467-6494.1986.tb00391.x
+             \item McLean S et al. (2013) Stigmatizing attitudes and beliefs about bulimia nervosa: Gender, age, education and income variability in a community sample. International Journal of Eating Disorders. doi: 10.1002/eat.22227
              \item Trochim WMK (2008) Types of Reliability. (\href{http://www.socialresearchmethods.net/kb/reltypes.php}{web})
             }
 }"
strengejacke,sjPlot,3ecfdd6de4bddb1e1b6d1461d4b8efdbdbb5eb64,Daniel,mail@danielluedecke.de,2019-11-16T21:32:25Z,Daniel,mail@danielluedecke.de,2019-11-16T21:32:25Z,minor fix,R/plot_model.R;R/tab_model.R,False,True,True,False,2,2,4,"---FILE: R/plot_model.R---
@@ -555,7 +555,7 @@ plot_model <- function(model,
     # labels for axis with term names
     if (is.null(axis.labels)) {
       term_labels <- sjlabelled::get_term_labels(model, case = case, prefix = prefix.labels, ...)
-      if (.labelled_model_data(model)) axis.labels <- term_labels
+      if (.labelled_model_data(model) || is.stan(model)) axis.labels <- term_labels
     }
     axis.labels <- sjmisc::word_wrap(axis.labels, wrap = wrap.labels)
 

---FILE: R/tab_model.R---
@@ -931,7 +931,7 @@ tab_model <- function(
   # get default labels for dv and terms ----
 
   if (isTRUE(auto.label) && sjmisc::is_empty(pred.labels)) {
-    if (.labelled_model_data(models)) {
+    if (.labelled_model_data(models) || any(sapply(models, is.stan))) {
       pred.labels <- sjlabelled::get_term_labels(models, case = case, mark.cat = TRUE, prefix = prefix.labels)
       category.values <- attr(pred.labels, ""category.value"")
 "
strengejacke,sjPlot,50d22d9fbd6837d9d378ca5910cddd632e119336,Daniel,mail@danielluedecke.de,2019-11-16T21:08:14Z,Daniel,mail@danielluedecke.de,2019-11-16T21:08:14Z,fix test issues,R/tidiers.R,False,True,True,False,2,1,3,"---FILE: R/tidiers.R---
@@ -70,9 +70,10 @@ get_tidy_data <- function(model, ci.lvl, tf, type, bpe, facets, show.zeroinf, p.
         error = function(x) { out }
       )
     }
+
+    attr(out, ""pretty_names"") <- attributes(model_params)$pretty_names
   }
 
-  attr(out, ""pretty_names"") <- attributes(model_params)$pretty_names
   out
 }
 "
strengejacke,sjPlot,e7a8d3569477261d681dafc2bbbc1681e346711f,Daniel Ldecke,mail@danielluedecke.de,2019-11-16T10:52:50Z,Daniel Ldecke,mail@danielluedecke.de,2019-11-16T10:52:50Z,fix auto labelling,R/plot_model.R;R/tab_model.R;R/tidiers.R;R/utils.R,False,True,True,False,30,5,35,"---FILE: R/plot_model.R---
@@ -555,7 +555,7 @@ plot_model <- function(model,
     # labels for axis with term names
     if (is.null(axis.labels)) {
       term_labels <- sjlabelled::get_term_labels(model, case = case, prefix = prefix.labels, ...)
-      if (!identical(names(term_labels), unname(term_labels))) axis.labels <- term_labels
+      if (.labelled_model_data(model)) axis.labels <- term_labels
     }
     axis.labels <- sjmisc::word_wrap(axis.labels, wrap = wrap.labels)
 

---FILE: R/tab_model.R---
@@ -482,7 +482,7 @@ tab_model <- function(
       # tidy output of standardized values ----
 
       if (!is.null(show.std) && !is.stan(model)) {
-        std_method <- switch(show.std, ""std"" = ""refit"", ""std2"" = ""2sd"", ""refit"")
+        std_method <- switch(show.std, ""std"" = ""refit"", ""std2"" = ""2sd"", """")
         dat <- tidy_model(
           model = model,
           ci.lvl = ci.lvl,
@@ -930,8 +930,8 @@ tab_model <- function(
 
   # get default labels for dv and terms ----
 
-  if (isTRUE(auto.label)) {
-    if (sjmisc::is_empty(pred.labels)) {
+  if (isTRUE(auto.label) && sjmisc::is_empty(pred.labels)) {
+    if (.labelled_model_data(models)) {
       pred.labels <- sjlabelled::get_term_labels(models, case = case, mark.cat = TRUE, prefix = prefix.labels)
       category.values <- attr(pred.labels, ""category.value"")
 

---FILE: R/tidiers.R---
@@ -1,6 +1,8 @@
 #' @importFrom sjstats robust
 #' @importFrom stats qnorm pnorm
 tidy_model <- function(model, ci.lvl, tf, type, bpe, se, robust, facets, show.zeroinf, p.val, standardize = FALSE, ...) {
+  if (!is.logical(standardize) && standardize == """") standardize <- NULL
+  if (is.logical(standardize) && standardize == FALSE) standardize <- NULL
   dat <- get_tidy_data(model, ci.lvl, tf, type, bpe, facets, show.zeroinf, p.val, standardize, ...)
 
   # get robust standard errors, if requestes, and replace former s.e.
@@ -31,7 +33,7 @@ get_tidy_data <- function(model, ci.lvl, tf, type, bpe, facets, show.zeroinf, p.
     out <- tidy_stan_model(model, ci.lvl, tf, type, bpe, show.zeroinf, facets, ...)
   } else {
     if (!is.null(standardize)) {
-      if (is.logical(standardize)) standardize <- ""std""
+      if (isTRUE(standardize)) standardize <- ""std""
       model <- effectsize::standardize(model, two_sd = isTRUE(standardize == ""std2""))
     }
 

---FILE: R/utils.R---
@@ -438,3 +438,26 @@ get_observations <- function(model) {
     error = function(x) { NULL }
   )
 }
+
+
+#' @importFrom insight find_predictors get_data
+.labelled_model_data <- function(models) {
+  # to be generic, make sure argument is a list
+  if (!inherits(models, ""list"")) models <- list(models)
+
+  # get model terms and model frame
+  mf <- try(lapply(models, function(.x) insight::get_data(.x)[, -1, drop = FALSE]), silent = TRUE)
+
+  # return NULL on error
+  if (inherits(mf, ""try-error"")) {
+    return(FALSE)
+  }
+
+
+  # get all variable labels for predictors
+  lbs <- unlist(lapply(mf, function(x) {
+    any(sapply(x, function(i) !is.null(attributes(i)$label)))
+  }))
+
+  any(isTRUE(lbs))
+}"
strengejacke,sjPlot,d2fe29070d68ea0919966a02211fafd2c15a9fec,Daniel Ldecke,mail@danielluedecke.de,2019-11-16T10:01:52Z,Daniel Ldecke,mail@danielluedecke.de,2019-11-16T10:01:52Z,fix check issues,R/plot_scatter.R;R/sjplot_themes.R;man/plot_scatter.Rd;man/sjPlot-themes.Rd,False,True,True,False,9,9,18,"---FILE: R/plot_scatter.R---
@@ -79,7 +79,7 @@ plot_scatter <- function(
   axis.titles = NULL,
   dot.size = 1.5,
   label.size = 3,
-  colors = ""metro ui"",
+  colors = ""metro"",
   fit.line = NULL,
   fit.grps = NULL,
   show.rug = FALSE,

---FILE: R/sjplot_themes.R---
@@ -283,7 +283,7 @@ sjplot_colors <- list(
 
 #' @rdname sjPlot-themes
 #' @export
-scale_color_sjplot <- function(palette = ""metro ui"", discrete = TRUE, reverse = FALSE, ...) {
+scale_color_sjplot <- function(palette = ""metro"", discrete = TRUE, reverse = FALSE, ...) {
   pal <- get_sjplot_pal(palette = palette, reverse = reverse)
 
   if (discrete) {
@@ -296,7 +296,7 @@ scale_color_sjplot <- function(palette = ""metro ui"", discrete = TRUE, reverse =
 
 #' @rdname sjPlot-themes
 #' @export
-scale_fill_sjplot <- function(palette = ""metro ui"", discrete = TRUE, reverse = FALSE, ...) {
+scale_fill_sjplot <- function(palette = ""metro"", discrete = TRUE, reverse = FALSE, ...) {
   pal <- get_sjplot_pal(palette = palette, reverse = reverse)
 
   if (discrete) {
@@ -310,7 +310,7 @@ scale_fill_sjplot <- function(palette = ""metro ui"", discrete = TRUE, reverse = F
 #' @importFrom stats quantile
 #' @rdname sjPlot-themes
 #' @export
-sjplot_pal <- function(palette = ""metro ui"", n = NULL) {
+sjplot_pal <- function(palette = ""metro"", n = NULL) {
   pl <- sjplot_colors[[palette]]
 
   if (!is.null(n) && n <= length(pl)) {
@@ -376,7 +376,7 @@ show_sjplot_pals <- function() {
 
 
 #' @importFrom grDevices colorRampPalette
-get_sjplot_pal <- function(palette = ""metro ui"", reverse = FALSE, ...) {
+get_sjplot_pal <- function(palette = ""metro"", reverse = FALSE, ...) {
   pal <- sjplot_colors[[palette]]
   if (reverse) pal <- rev(pal)
   grDevices::colorRampPalette(pal, ...)

---FILE: man/plot_scatter.Rd---
@@ -6,7 +6,7 @@
 \usage{
 plot_scatter(data, x, y, grp, title = """", legend.title = NULL,
   legend.labels = NULL, dot.labels = NULL, axis.titles = NULL,
-  dot.size = 1.5, label.size = 3, colors = ""metro ui"",
+  dot.size = 1.5, label.size = 3, colors = ""metro"",
   fit.line = NULL, fit.grps = NULL, show.rug = FALSE,
   show.legend = TRUE, show.ci = FALSE, wrap.title = 50,
   wrap.legend.title = 20, wrap.legend.labels = 20, jitter = 0.05,

---FILE: man/sjPlot-themes.Rd---
@@ -31,13 +31,13 @@ label_angle(angle.x, angle.y, base.theme)
 
 legend_style(inside, pos, justify, base.theme)
 
-scale_color_sjplot(palette = ""metro ui"", discrete = TRUE,
+scale_color_sjplot(palette = ""metro"", discrete = TRUE,
   reverse = FALSE, ...)
 
-scale_fill_sjplot(palette = ""metro ui"", discrete = TRUE,
+scale_fill_sjplot(palette = ""metro"", discrete = TRUE,
   reverse = FALSE, ...)
 
-sjplot_pal(palette = ""metro ui"", n = NULL)
+sjplot_pal(palette = ""metro"", n = NULL)
 
 show_sjplot_pals()
 "
strengejacke,sjPlot,a956c267c732c8da5b5571b9e9aae5f7fa7f8f8e,Daniel,mail@danielluedecke.de,2019-11-15T18:31:26Z,Daniel,mail@danielluedecke.de,2019-11-15T18:31:26Z,fix check issues,DESCRIPTION;NAMESPACE;R/plot_gpt.R;R/reexports.R;man/plot_gpt.Rd,False,True,True,False,10,15,25,"---FILE: DESCRIPTION---
@@ -26,29 +26,29 @@ Depends:
     stats,
     utils
 Imports:
-    bayestestR (>= 0.3.0),
+    bayestestR (>= 0.4.0),
     dplyr (>= 0.8.1),
     effectsize,
     forcats,
-    ggeffects (>= 0.12.0),
+    ggeffects (>= 0.13.0),
     glmmTMB,
     ggplot2 (>= 3.2.0),
     ggrepel,
     knitr,
-    insight (>= 0.5.0),
+    insight (>= 0.6.0),
     lme4 (>= 1.1-12),
     magrittr,
     MASS,
     modelr,
     parameters (>= 0.2.0),
-    performance (>= 0.3.0),
+    performance (>= 0.4.0),
     psych,
     purrr,
     rlang,
     scales,
-    sjlabelled (>= 1.1.0),
+    sjlabelled (>= 1.1.1),
     sjmisc (>= 2.8.2),
-    sjstats (>= 0.17.5),
+    sjstats (>= 0.17.7),
     tidyr (>= 1.0.0)
 Suggests:
     brms,
@@ -59,6 +59,7 @@ Suggests:
     gridExtra,
     ggridges,
     httr,
+    nlme,
     pscl,
     rstanarm,
     survey,
@@ -67,5 +68,5 @@ Suggests:
     testthat
 URL: https://strengejacke.github.io/sjPlot/
 BugReports: https://github.com/strengejacke/sjPlot/issues
-RoxygenNote: 7.0.0
+RoxygenNote: 6.1.1
 VignetteBuilder: knitr

---FILE: NAMESPACE---
@@ -68,7 +68,6 @@ export(sjt.xtab)
 export(sjtab)
 export(tab_df)
 export(tab_dfs)
-export(tab_frq)
 export(tab_model)
 export(tab_stackfrq)
 export(theme_538)

---FILE: R/plot_gpt.R---
@@ -64,7 +64,7 @@ plot_gpt <- function(
   x,
   y,
   grp,
-  colors = ""metro ui"",
+  colors = ""metro"",
   geom.size = 2.5,
   shape.fill.color = ""#f0f0f0"",
   shapes = c(15, 16, 17, 18, 21, 22, 23, 24, 25, 7, 8, 9, 10, 12),

---FILE: R/reexports.R---
@@ -1,8 +1,3 @@
 #' @importFrom magrittr %>%
 #' @export
 magrittr::`%>%`
-
-#' @importFrom sjmisc frq
-#' @export
-tab_frq <- sjmisc::frq
-

---FILE: man/plot_gpt.Rd---
@@ -4,7 +4,7 @@
 \alias{plot_gpt}
 \title{Plot grouped proportional tables}
 \usage{
-plot_gpt(data, x, y, grp, colors = ""metro ui"", geom.size = 2.5,
+plot_gpt(data, x, y, grp, colors = ""metro"", geom.size = 2.5,
   shape.fill.color = ""#f0f0f0"", shapes = c(15, 16, 17, 18, 21, 22, 23,
   24, 25, 7, 8, 9, 10, 12), title = NULL, axis.labels = NULL,
   axis.titles = NULL, legend.title = NULL, legend.labels = NULL,"
strengejacke,sjPlot,85d0d278b175b835ae2979126db5212882405ea2,Daniel,mail@danielluedecke.de,2019-11-10T09:45:54Z,Daniel,mail@danielluedecke.de,2019-11-10T09:45:54Z,minor bug fixes,NAMESPACE;NEWS.md;R/plot_frq.R;R/reexports.R;R/utils.R;man/plot_frq.Rd;man/reexports.Rd,False,True,True,False,28,7,35,"---FILE: NAMESPACE---
@@ -68,6 +68,7 @@ export(sjt.xtab)
 export(sjtab)
 export(tab_df)
 export(tab_dfs)
+export(tab_frq)
 export(tab_model)
 export(tab_stackfrq)
 export(theme_538)

---FILE: NEWS.md---
@@ -12,6 +12,8 @@
 ## Bug fixes
 
 * `sort.est = NULL` in `plot_model()` now preserves original order of coefficients.
+* Fixed bug in automatic axis labelling for `plot_frq()` for non-labelled, numeric values.
+* Fixed bug in `plot_frq()` when plotting factors.
 
 # sjPlot 2.7.2
 

---FILE: R/plot_frq.R---
@@ -65,6 +65,11 @@ utils::globalVariables(""density"")
 #' library(sjlabelled)
 #' library(dplyr)
 #' data(efc)
+#' data(iris)
+#'
+#' # simple plots, two different notations
+#' plot_frq(iris, Species)
+#' plot_frq(efc$tot_sc_e)
 #'
 #' # boxplot
 #' plot_frq(efc$e17age, type = ""box"")
@@ -341,7 +346,7 @@ plot_frq_helper <- function(
   mydat$rel.lower.ci <- rel_frq - ci
 
   # any labels detected?
-  if (!is.null(mydat$label) && is.null(axis.labels))
+  if (!is.null(mydat$label) && is.null(axis.labels) && !all(stats::na.omit(mydat$label) == ""<none>""))
     axis.labels <- mydat$label
   else if (is.null(axis.labels))
     axis.labels <- mydat$val
@@ -485,7 +490,11 @@ plot_frq_helper <- function(
   }
 
   # Set up grid breaks
-  maxx <- max(mydat$val) + 1
+  maxx <- if (is.numeric(mydat$val))
+    max(mydat$val) + 1
+  else
+    nrow(mydat)
+
   if (is.null(grid.breaks)) {
     gridbreaks <- waiver()
     histgridbreaks <- waiver()

---FILE: R/reexports.R---
@@ -0,0 +1,8 @@
+#' @importFrom magrittr %>%
+#' @export
+magrittr::`%>%`
+
+#' @importFrom sjmisc frq
+#' @export
+tab_frq <- sjmisc::frq
+

---FILE: R/utils.R---
@@ -1,7 +1,3 @@
-#' @importFrom magrittr %>%
-#' @export
-magrittr::`%>%`
-
 data_frame <- function(...) {
   x <- data.frame(..., stringsAsFactors = FALSE)
   rownames(x) <- NULL

---FILE: man/plot_frq.Rd---
@@ -197,6 +197,11 @@ This function only works with variables with integer values (or numeric
 library(sjlabelled)
 library(dplyr)
 data(efc)
+data(iris)
+
+# simple plots, two different notations
+plot_frq(iris, Species)
+plot_frq(efc$tot_sc_e)
 
 # boxplot
 plot_frq(efc$e17age, type = ""box"")

---FILE: man/reexports.Rd---
@@ -1,5 +1,5 @@
 % Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/utils.R
+% Please edit documentation in R/reexports.R
 \docType{import}
 \name{reexports}
 \alias{reexports}"
strengejacke,sjPlot,18439eebd17b3f542e902bc552d15a21f963b3d4,Daniel,mail@danielluedecke.de,2019-09-29T19:10:05Z,Daniel,mail@danielluedecke.de,2019-09-29T19:10:05Z,fix NOTE,DESCRIPTION,False,False,False,False,0,1,1,"---FILE: DESCRIPTION---
@@ -41,7 +41,6 @@ Imports:
     magrittr,
     MASS,
     modelr,
-    nlme,
     parameters (>= 0.2.0),
     performance (>= 0.3.0),
     psych,"
strengejacke,sjPlot,437ef241b82f72cc242e7b525f650300da5f1f05,Daniel Ldecke,mail@danielluedecke.de,2019-09-25T10:27:29Z,Daniel Ldecke,mail@danielluedecke.de,2019-09-25T10:27:29Z,fix check issues,vignettes/tab_model_estimates.Rmd,True,False,True,False,1,1,2,"---FILE: vignettes/tab_model_estimates.Rmd---
@@ -109,8 +109,8 @@ Other models, like hurdle- or zero-inflated models, also work with `tab_model()`
 ```{r}
 library(pscl)
 data(""bioChemists"")
+m5 <- zeroinfl(art ~ fem + mar + kid5 + ment | kid5 + phd + ment, data = bioChemists)
 
-m5 <- zeroinfl(art ~ . | ., data = bioChemists)
 tab_model(m5)
 ```
 "
strengejacke,sjPlot,1565b14aa61fe16346a8e671a6f2d2e7af9eeca8,Daniel Ldecke,mail@danielluedecke.de,2019-09-25T10:17:16Z,Daniel Ldecke,mail@danielluedecke.de,2019-09-25T10:17:16Z,fix check errors,NAMESPACE;R/plot_model.R;R/plot_models.R;R/plot_type_est.R;R/tidiers.R;man/sjp.corr.Rd;man/sjt.corr.Rd,False,True,True,False,9,7,16,"---FILE: NAMESPACE---
@@ -132,6 +132,7 @@ importFrom(magrittr,""%>%"")
 importFrom(modelr,crossv_kfold)
 importFrom(parameters,dof_kenward)
 importFrom(parameters,model_parameters)
+importFrom(parameters,p_value)
 importFrom(parameters,p_value_wald)
 importFrom(parameters,principal_components)
 importFrom(parameters,se_kenward)
@@ -204,7 +205,6 @@ importFrom(sjmisc,word_wrap)
 importFrom(sjmisc,zap_inf)
 importFrom(sjstats,cramer)
 importFrom(sjstats,mean_n)
-importFrom(sjstats,p_value)
 importFrom(sjstats,phi)
 importFrom(sjstats,robust)
 importFrom(sjstats,std_beta)

---FILE: R/plot_model.R---
@@ -442,7 +442,7 @@
 #'   plot_model(m, bpe.style = ""dot"")
 #' }}
 #'
-#' @importFrom sjstats std_beta p_value
+#' @importFrom sjstats std_beta
 #' @importFrom insight model_info find_predictors
 #' @importFrom sjmisc word_wrap str_contains
 #' @importFrom sjlabelled get_dv_labels get_term_labels

---FILE: R/plot_models.R---
@@ -72,7 +72,7 @@
 #' @importFrom purrr map map_df map2
 #' @importFrom dplyr slice bind_rows filter
 #' @importFrom forcats fct_rev
-#' @importFrom sjstats std_beta p_value
+#' @importFrom sjstats std_beta
 #' @importFrom sjlabelled get_dv_labels get_term_labels
 #' @importFrom rlang .data
 #' @importFrom sjmisc word_wrap var_rename add_variables
@@ -156,7 +156,7 @@ plot_models <- function(...,
       purrr::map(~ sjstats::std_beta(.x, type = std.est)) %>%
       purrr::map(~ sjmisc::var_rename(.x, std.estimate = ""estimate"")) %>%
       purrr::map2(input_list, ~ sjmisc::add_variables(
-        .x, p.value = suppressMessages(sjstats::p_value(.y)[[""p.value""]][-1])
+        .x, p.value = suppressMessages(parameters::p_value(.y)[[""p""]][-1])
       ))
 
   } else {

---FILE: R/plot_type_est.R---
@@ -1,3 +1,4 @@
+#' @importFrom parameters p_value
 #' @importFrom sjstats robust
 #' @importFrom sjmisc add_variables
 plot_type_est <- function(type,
@@ -60,7 +61,7 @@ plot_type_est <- function(type,
   } else {
     dat <- model %>%
       sjstats::std_beta(type = type, ci.lvl = ci.lvl) %>%
-      sjmisc::add_variables(p.value = sjstats::p_value(model)[[""p.value""]][-1]) %>%
+      sjmisc::add_variables(p.value = parameters::p_value(model)[[""p""]][-1]) %>%
       sjmisc::var_rename(std.estimate = ""estimate"")
 
     show.intercept <- FALSE

---FILE: R/tidiers.R---
@@ -59,6 +59,7 @@ get_tidy_data <- function(model, ci.lvl, tf, type, bpe, facets, show.zeroinf, p.
           out$std.error <- parameters::se_kenward(model)
           out$df <- dof
           out$statistic <- out$estimate / out$std.error
+          out
         },
         error = function(x) { out }
       )

---FILE: man/sjp.corr.Rd---
@@ -38,7 +38,7 @@ the values labels are shown. Default is 3. Only applies when
 abbreviated.}
 
 \item{corr.method}{Indicates the correlation computation method. May be one of
-\code{""spearman""} (default), \code{""pearson""} or \code{""kendall""}.
+\code{""pearson""} (default), \code{""spearman""} or \code{""kendall""}.
 May be abbreviated.}
 
 \item{geom.colors}{user defined color for geoms. See 'Details' in \code{\link{sjp.grpfrq}}.}

---FILE: man/sjt.corr.Rd---
@@ -22,7 +22,7 @@ correlations between columns should be computed.}
 abbreviated.}
 
 \item{corr.method}{Indicates the correlation computation method. May be one of
-\code{""spearman""} (default), \code{""pearson""} or \code{""kendall""}.
+\code{""pearson""} (default), \code{""spearman""} or \code{""kendall""}.
 May be abbreviated.}
 
 \item{title}{String, will be used as table caption.}"
strengejacke,sjPlot,80f7ec378cc150bfb29591ebee366e2db279e1f3,Daniel Ldecke,mail@danielluedecke.de,2019-09-25T09:28:24Z,Daniel Ldecke,mail@danielluedecke.de,2019-09-25T09:28:24Z,fix CRAN check issues,R/tab_model.R;R/tidiers.R,False,True,True,False,13,2,15,"---FILE: R/tab_model.R---
@@ -594,7 +594,7 @@ tab_model <- function(
       wf <- string_starts_with(""wrap.facet"", x = colnames(dat))
 
       if (!sjmisc::is_empty(wf)) {
-        zi <- which(dat[[wf]] %in% c(""Zero-Inflated Model"", ""Zero Inflation Model""))
+        zi <- which(dat[[wf]] %in% c(""Zero-Inflated Model"", ""Zero Inflation Model"", ""zero_inflated"", ""zi""))
 
         if (show.zeroinf && !sjmisc::is_empty(zi)) {
           zidat <- dat %>%

---FILE: R/tidiers.R---
@@ -44,6 +44,13 @@ get_tidy_data <- function(model, ci.lvl, tf, type, bpe, facets, show.zeroinf, p.
     column <- which(colnames(out) == ""group"")
     if (length(column)) colnames(out)[column] <- ""wrap.facet""
 
+    if (""component"" %in% colnames(out)) {
+      out$component[out$component == ""zero_inflated""] <- ""Zero-Inflated Model""
+      out$component[out$component == ""zi""] <- ""Zero-Inflated Model""
+      out$component[out$component == ""conditional""] <- ""Conditional Model""
+      out$component[out$component == ""count""] <- ""Conditional Model""
+    }
+
     if (is_merMod(model) && !is.null(p.val) && p.val == ""kr"") {
       out <- tryCatch(
         {
@@ -177,7 +184,11 @@ tidy_stan_model <- function(model, ci.lvl, tf, type, bpe, show.zeroinf, facets,
     )
 
   # sort columns, for tab_model()
-  dat <- dat[, c(1, 2, 4:8, 3)]
+  sorted_columns <- intersect(
+    c(""term"", ""estimate"", ""std.error"", ""conf.low"", ""conf.high"", ""conf.low50"", ""conf.high50"", ""p.value""),
+    colnames(dat)
+  )
+  dat <- dat[, sorted_columns]
 
   # remove some of the information not needed for plotting
 "
strengejacke,sjPlot,13fdf0a8f8ac82d6d752fc7cda8a46d941ef9277,helix123,kevintappe@gmx.de,2019-09-14T19:03:36Z,GitHub,noreply@github.com,2019-09-14T19:03:36Z,"doc fix

mention correct default for `corr.method`",R/sjPlotCorr.R,False,True,True,False,1,1,2,"---FILE: R/sjPlotCorr.R---
@@ -19,7 +19,7 @@
 #'          \code{""listwise""} (default) or \code{""pairwise""}. May be
 #'          abbreviated.
 #' @param corr.method Indicates the correlation computation method. May be one of
-#'          \code{""spearman""} (default), \code{""pearson""} or \code{""kendall""}.
+#'          \code{""pearson""} (default), \code{""spearman""} or \code{""kendall""}.
 #'          May be abbreviated.
 #' @param p.numeric Logical, if \code{TRUE}, the p-values are printed
 #'          as numbers. If \code{FALSE} (default), asterisks are used."
strengejacke,sjPlot,d4e04f21f59bcc062da91803e7db93a58884a6f4,Alexander Bartel,github@ndevln.org,2019-09-11T11:46:27Z,Alexander Bartel,github@ndevln.org,2019-09-11T11:46:27Z,"Fix rounding errors when using ""sum.outside"" and Percentages are now correct for option digits > 1",R/plot_likert.R,False,True,True,False,2,2,4,"---FILE: R/plot_likert.R---
@@ -483,9 +483,9 @@ plot_likert <- function(items,
     # create proportional frequency table
 
     if (is.null(weight.by)) {
-      tab <- round(prop.table(table(items[[i]])), 3)
+      tab <- round(prop.table(table(items[[i]])), digits + 3)
     } else {
-      tab <- round(prop.table(stats::xtabs(weight.by ~ items[[i]])), 3)
+      tab <- round(prop.table(stats::xtabs(weight.by ~ items[[i]])), digits + 3)
     }
 
 "
strengejacke,sjPlot,14067715b3b42b7403fc51d6689ce46d548ec4e2,Daniel Ldecke,mail@danielluedecke.de,2019-09-06T10:40:05Z,Daniel Ldecke,mail@danielluedecke.de,2019-09-06T10:40:05Z,fix deps,DESCRIPTION,False,False,False,False,1,1,2,"---FILE: DESCRIPTION---
@@ -49,7 +49,7 @@ Imports:
     scales,
     sjlabelled (>= 1.1.0),
     sjmisc (>= 2.8.0),
-    sjstats (>= 0.17.6),
+    sjstats (>= 0.17.5),
     tidyr (>= 0.7.0)
 Suggests:
     brms,"
strengejacke,sjPlot,e0e57d804fca6226d52fcb4992c4a9fac03a8f4a,Daniel Ldecke,mail@danielluedecke.de,2019-09-06T10:39:43Z,Daniel Ldecke,mail@danielluedecke.de,2019-09-06T10:39:43Z,fix deps,DESCRIPTION;R/sjTabStackFrq.R,False,True,True,False,9,5,14,"---FILE: DESCRIPTION---
@@ -36,7 +36,7 @@ Imports:
     ggplot2 (>= 3.2.0),
     ggrepel,
     knitr,
-    insight (>= 0.5.0),
+    insight (>= 0.4.1),
     lme4 (>= 1.1-12),
     magrittr,
     MASS,

---FILE: R/sjTabStackFrq.R---
@@ -385,15 +385,19 @@ tab_stackfrq <- function(items,
 
 .transform_data <- function(x, col) {
   dat <- suppressWarnings(Reduce(function(x, y) merge(x, y, all = TRUE, sort = FALSE, by = ""val""), x))
-  if (is.factor(dat$val))
-    dat <- dat[order(dat$val, levels(dat$val)), ]
-  else
+  if (is.factor(dat$val)) {
+    reihe <- levels(dat$val)
+    if (anyNA(dat$val))
+      reihe <- c(reihe, NA)
+    dat <- dat[order(dat$val, reihe), ]
+  } else {
     dat <- dat[order(dat$val), ]
+  }
   colnames(dat) <- make.names(colnames(dat), unique = TRUE)
   keep <- (colnames(dat) == ""val"") | grepl(paste0(""^"", col), colnames(dat))
   dat <- as.data.frame(t(dat[, keep, drop = FALSE]))
-  dat[is.na(dat)] <- 0
   dat <- as.data.frame(sapply(dat[-1, ], function(i) as.numeric(as.character(i))))
+  dat[is.na(dat)] <- 0
   colnames(dat) <- sprintf(""V%i"", 1:ncol(dat))
   dat
 }"
strengejacke,sjPlot,67ba428335efa3d4d34e8d965e4f87eaedb2358e,Daniel,mail@danielluedecke.de,2019-08-11T18:44:39Z,Daniel,mail@danielluedecke.de,2019-08-11T18:44:39Z,fix for tidyr,DESCRIPTION;NEWS.md;R/sjplot.R,False,True,True,False,7,11,18,"---FILE: DESCRIPTION---
@@ -29,7 +29,7 @@ Depends:
 Imports:
     bayestestR (>= 0.2.5),
     broom,
-    dplyr (>= 0.7.5),
+    dplyr (>= 0.8.1),
     forcats,
     ggeffects (>= 0.11.0),
     glmmTMB,

---FILE: NEWS.md---
@@ -2,6 +2,7 @@
 
 ## General
 
+* Minor revisions to meet the changes in the forthcoming update from tidyr.
 * new color palettes were added (see `show_sjplot_pals()`).
 
 ## Bug fixes

---FILE: R/sjplot.R---
@@ -258,19 +258,14 @@ get_title_part <- function(x, grps, level, i) {
 
 
 #' @importFrom rlang .data
-#' @importFrom dplyr select filter group_vars
+#' @importFrom dplyr select filter group_modify group_vars
 #' @importFrom stats complete.cases
 #'
 get_grouped_data <- function(x) {
-  # nest data frame
-  grps <- tidyr::nest(x)
-
-  # remove NA category
-  cc <- grps %>%
-    dplyr::select(-.data$data) %>%
-    stats::complete.cases()
-  # select only complete cases
-  grps <- grps %>% dplyr::filter(!! cc)
+  # retain observations that are complete wrt grouping vars, then nest
+  grps <- x %>%
+    dplyr::group_modify(~ dplyr::filter(.x, stats::complete.cases(.y))) %>%
+    tidyr::nest()
 
   # arrange data
   if (length(dplyr::group_vars(x)) == 1)"
strengejacke,sjPlot,64229cc8c29f048c89cd06004bec19c17e9b2338,Daniel,mail@danielluedecke.de,2019-08-02T17:26:52Z,Daniel,mail@danielluedecke.de,2019-08-02T17:26:52Z,fix check issues,DESCRIPTION;R/plot_likert.R;R/plot_stackfrq.R;man/plot_likert.Rd;man/plot_stackfrq.Rd;vignettes/tab_bayes.Rmd,True,True,True,False,6,7,13,"---FILE: DESCRIPTION---
@@ -59,6 +59,7 @@ Suggests:
     GPArotation,
     gridExtra,
     ggridges,
+    httr,
     pscl,
     rstanarm,
     survey,

---FILE: R/plot_likert.R---
@@ -117,6 +117,7 @@
 #'   ncol = 6)
 #' )
 #'
+#' \dontrun{
 #' six_cat_example <-
 #'   six_cat_example %>%
 #'   dplyr::mutate_all(~ordered(.,labels = c(""+++"",""++"",""+"",""-"",""--"",""---"")))
@@ -136,7 +137,7 @@
 #'   six_cat_example,
 #'   groups = c(1, 1, 1, 2, 2, 2),
 #'   group.legend.options = list(nrow = 1)
-#' )
+#' )}
 #'
 #' @import ggplot2
 #' @importFrom stats na.omit xtabs

---FILE: R/plot_stackfrq.R---
@@ -5,8 +5,6 @@
 #'                function is useful when several items with identical scale/categoroies
 #'                should be plotted to compare the distribution of answers.
 #'
-#' @note Thanks to \href{http://www.clas.ufl.edu/users/forrest/}{Forrest Stevens} for bug fixes.
-#'
 #' @param items Data frame, or a grouped data frame, with each column representing one item.
 #' @param sort.frq Indicates whether the \code{items} should be ordered by
 #'   by highest count of first or last category of \code{items}.

---FILE: man/plot_likert.Rd---
@@ -209,6 +209,7 @@ six_cat_example = data.frame(
   ncol = 6)
 )
 
+\dontrun{
 six_cat_example <-
   six_cat_example \%>\%
   dplyr::mutate_all(~ordered(.,labels = c(""+++"",""++"",""+"",""-"",""--"",""---"")))
@@ -228,6 +229,6 @@ plot_likert(
   six_cat_example,
   groups = c(1, 1, 1, 2, 2, 2),
   group.legend.options = list(nrow = 1)
-)
+)}
 
 }

---FILE: man/plot_stackfrq.Rd---
@@ -100,9 +100,6 @@ Plot items (variables) of a scale as stacked proportional bars. This
                function is useful when several items with identical scale/categoroies
                should be plotted to compare the distribution of answers.
 }
-\note{
-Thanks to \href{http://www.clas.ufl.edu/users/forrest/}{Forrest Stevens} for bug fixes.
-}
 \examples{
 # Data from the EUROFAMCARE sample dataset
 library(sjmisc)

---FILE: vignettes/tab_bayes.Rmd---
@@ -30,6 +30,7 @@ This vignette shows examples for using `tab_model()` to create HTML tables for m
 # load required packages
 library(sjPlot)
 library(insight)
+library(httr)
 library(brms)
 
 # load sample models"
strengejacke,sjPlot,2afa1c76aaabf6ee3fb09b563af2cdf8329d5bbf,Daniel Ldecke,mail@danielluedecke.de,2019-08-02T12:30:26Z,Daniel Ldecke,mail@danielluedecke.de,2019-08-02T12:30:26Z,fix check issues,R/utils.R,False,True,True,False,6,1,7,"---FILE: R/utils.R---
@@ -175,8 +175,13 @@ is_brms_mixed <- function(fit) {
 
 
 # short checker so we know if we need more summary statistics like ICC
+#' @importFrom insight model_info is_multivariate
 is_mixed_model <- function(fit) {
-  insight::model_info(fit)$is_mixed
+  mi <- insight::model_info(fit)
+  if (insight::is_multivariate(fit))
+    mi[[1]]$is_mixed
+  else
+    mi$is_mixed
 }
 
 "
strengejacke,sjPlot,88fd5eed1922f65cd0a36079ac7ac624f0d31155,Daniel,mail@danielluedecke.de,2019-06-21T08:02:23Z,Daniel,mail@danielluedecke.de,2019-06-21T08:02:23Z,fix issue in view_df,NEWS.md;R/sjTabSPSS.R,False,True,True,False,4,0,4,"---FILE: NEWS.md---
@@ -5,6 +5,7 @@
 * `sjt.itemanalysis()` now works on ordered factors. A clearer error message was added when unordered factors are used. The old error message was not helpful.
 * `plot_likert()` showed category labels in the top and bottom legends in two rows if there are more than six categories. Also, the categories are ordered column wise instead of row wise. This behaviour can now be controlled for grouped likert plots, using `group.legend.options`. The ordering now defaults to row wise and the user can force all categories onto a single row.
 * `tab_model()` gets a `show.aicc`-argument to show the second order AIC.
+* `view_df()` now automatically drops unused value labels from data, so output of frequencies and value labels matches.
 
 ## Bug fixes
 

---FILE: R/sjTabSPSS.R---
@@ -136,6 +136,9 @@ view_df <- function(x,
   id <- seq_len(ncol(x))
   cnames <- colnames(x)
 
+  # drop unused labels
+  x <- sjlabelled::drop_labels(x)
+
   # do we have any ""all-missing-variables""?
   if (any(all.na)) {
     rem.col <- seq_len(ncol(x))[all.na]"
strengejacke,sjPlot,89f61ff08e83614ebd1ff036b99f420080944e0e,Alexander Bartel,github@ndevln.org,2019-06-01T11:43:11Z,Alexander Bartel,github@ndevln.org,2019-06-01T11:43:11Z,Minor Bug Fix: fixed plot_likert sum.inside and sum.outside are reversed when using reverse.scale. No both options have the expected behavior.,R/plot_likert.R,False,True,True,False,8,1,9,"---FILE: R/plot_likert.R---
@@ -725,8 +725,15 @@ plot_likert <- function(items,
         )
     }
   } else if (values == ""sum.inside"" || values == ""sum.outside"") {
+    # choose label offsets for summed proportions
+    move_pos_labels_left = case_when(
+      values == ""sum.outside"" & !reverse.scale ~ T,
+      values == ""sum.inside"" & !reverse.scale ~ F,
+      values == ""sum.outside"" & reverse.scale ~ F,
+      values == ""sum.inside"" & reverse.scale ~ T
+    )
     # show cumulative outside bar
-    if (values == ""sum.outside"") {
+    if (move_pos_labels_left) {
       hort.pos <- -0.15
       hort.neg <- 1.15
       hort.dk <- -0.15"
strengejacke,sjPlot,c1093afbd934f6d14ec56c88120508f4c17f8cca,Daniel Ldecke,mail@danielluedecke.de,2019-05-08T08:33:50Z,Daniel Ldecke,mail@danielluedecke.de,2019-05-08T08:33:50Z,minor fix for tab_model(),DESCRIPTION;NEWS.md;R/html_print.R;R/tab_model.R,False,True,True,False,9,3,12,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 2.6.3
+Version: 2.6.3.9000
 Date: 2019-04-27
 Authors@R: c(
     person(""Daniel"", ""Ldecke"", email = ""d.luedecke@uke.de"", role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0002-8895-3206"")),

---FILE: NEWS.md---
@@ -1,3 +1,9 @@
+# sjPlot 2.6.4
+
+## Bug fixes
+
+* Minor fix in `tab_model()` for mixed models that can't compute R2.
+
 # sjPlot 2.6.3
 
 ## General

---FILE: R/html_print.R---
@@ -662,7 +662,7 @@ tab_model_df <- function(x,
       else
         colspan <- length(string_ends_with(sprintf(""_%i"", i), x = colnames(x)))
 
-      if (is.null(rsq.list[[i]])) {
+      if (is.null(rsq.list[[i]]) || all(is.na(rsq.list[[i]])) || all(sjmisc::is_empty(rsq.list[[i]], first.only = FALSE))) {
 
         page.content <- paste0(
           page.content,

---FILE: R/tab_model.R---
@@ -654,7 +654,7 @@ tab_model <- function(
                 `Conditional R2` = rsqdummy$R2_Bayes
               )
             }
-          } else {
+          } else if (!is.null(vars) && !all(is.na(vars))) {
             rsq <- list(
               `Marginal R2` = vars$var.fixed / (vars$var.fixed + vars$var.random + vars$var.residual),
               `Conditional R2` = (vars$var.fixed + vars$var.random) / (vars$var.fixed + vars$var.random + vars$var.residual)"
strengejacke,sjPlot,2d6b7c81b8c8b880f4129258a9a9aa6438af6898,Daniel,mail@danielluedecke.de,2019-04-27T15:09:02Z,Daniel,mail@danielluedecke.de,2019-04-27T15:09:02Z,fix issues with brms and tab_model(),R/html_print.R;R/tidiers.R,False,True,True,False,2,2,4,"---FILE: R/html_print.R---
@@ -828,7 +828,7 @@ create_random_effects <- function(rv.len, rv, rv.string, clean.rv, var.names, su
       else
         colspan <- length(string_ends_with(sprintf(""_%i"", j), x = var.names))
 
-      if (is.null(rv[[j]]) || is.na(rv[[j]][i])) {
+      if (is.null(rv[[j]]) || is.na(rv[[j]][i]) || sjmisc::is_empty(rv[[j]][i])) {
 
         page.content <- paste0(
           page.content,

---FILE: R/tidiers.R---
@@ -472,7 +472,7 @@ tidy_stan_model <- function(model, ci.lvl, tf, type, bpe, show.zeroinf, facets,
     # and remove response name from term name
 
     for (i in responses) {
-      m <- string_contains(i, x = dat$term)
+      m <- grep(pattern = sprintf(""_%s_"", i), x = dat$term)
       dat$response.level[intersect(which(dat$response.level == """"), m)] <- i
       dat$term <- gsub(sprintf(""b_%s_"", i), """", dat$term, fixed = TRUE)
       dat$term <- gsub(sprintf(""s_%s_"", i), """", dat$term, fixed = TRUE)"
strengejacke,sjPlot,cbd00e74385dbfae6248663bb5d5425f956f7adc,Daniel Ldecke,mail@danielluedecke.de,2019-04-26T14:06:55Z,Daniel Ldecke,mail@danielluedecke.de,2019-04-26T14:06:55Z,fix issues,R/plot_type_slope.R;tests/testthat/test-tab_model.R,False,True,True,False,3,3,6,"---FILE: R/plot_type_slope.R---
@@ -49,7 +49,7 @@ plot_type_slope <- function(model,
 
   model_data <- insight::get_data(model)
   depvar.label <- sjlabelled::get_label(model_data[[1]], def.value = insight::find_response(model), case = case)
-  predvars <- insight::find_predictors(model, component = ""conditional"")
+  predvars <- insight::find_predictors(model, component = ""conditional"", flatten = TRUE)
 
 
   # tell user that interaction terms are not supported by this method

---FILE: tests/testthat/test-tab_model.R---
@@ -77,8 +77,8 @@ if (suppressWarnings(
         p <- tab_model(m1)
         p <- tab_model(m2)
         p <- tab_model(m1, m2)
-        p <- tab_model(m1, m2, show.hdi50 = FALSE)
-        p <- tab_model(m1, m2, col.order = c(""hdi.outer"", ""hdi.inner"", ""est""))
+        p <- tab_model(m1, m2, show.ci50 = FALSE)
+        p <- tab_model(m1, m2, col.order = c(""ci.outer"", ""ci.inner"", ""est""))
         p <- tab_model(m1, m2, bpe = ""mean"")
       })
     }"
strengejacke,sjPlot,d0a9d2bb9bd7c80f5c68cad52aa3abcff11757f7,Daniel Ldecke,mail@danielluedecke.de,2019-04-26T13:49:23Z,Daniel Ldecke,mail@danielluedecke.de,2019-04-26T13:49:23Z,fix check issues,R/plot_likert.R;R/sjplot.R;man/plot_likert.Rd;man/sjplot.Rd;vignettes/tab_bayes.Rmd,True,True,True,False,11,20,31,"---FILE: R/plot_likert.R---
@@ -106,8 +106,6 @@
 #'             wrap.labels = 40,
 #'             reverse.scale = TRUE)
 #'
-#' )
-#'
 #' @import ggplot2
 #' @importFrom stats na.omit xtabs
 #' @importFrom sjmisc is_odd set_na is_empty

---FILE: R/sjplot.R---
@@ -30,10 +30,6 @@
 #'             \item{\code{""aov1""}}{calls \code{\link{sjp.aov1}}. The first
 #'             two variables in \code{data} are used (and required) to create the plot.
 #'             }
-#'             \item{\code{""frq""}}{calls \code{\link{sjp.frq}}.
-#'             If \code{data} has more than one variable, a plot for each
-#'             variable in \code{data} is plotted.
-#'             }
 #'             \item{\code{""grpfrq""}}{calls \code{\link{sjp.grpfrq}}. The first
 #'             two variables in \code{data} are used (and required) to create the plot.
 #'             }

---FILE: man/plot_likert.Rd---
@@ -199,6 +199,4 @@ plot_likert(mydf,
             wrap.labels = 40,
             reverse.scale = TRUE)
 
-)
-
 }

---FILE: man/sjplot.Rd---
@@ -37,10 +37,6 @@ Following \code{fun}-values are currently supported:
             \item{\code{""aov1""}}{calls \code{\link{sjp.aov1}}. The first
             two variables in \code{data} are used (and required) to create the plot.
             }
-            \item{\code{""frq""}}{calls \code{\link{sjp.frq}}.
-            If \code{data} has more than one variable, a plot for each
-            variable in \code{data} is plotted.
-            }
             \item{\code{""grpfrq""}}{calls \code{\link{sjp.grpfrq}}. The first
             two variables in \code{data} are used (and required) to create the plot.
             }

---FILE: vignettes/tab_bayes.Rmd---
@@ -34,22 +34,25 @@ library(brms)
 
 # load sample models
 
-# set.seed(123)
-# f1 <- bf(mpg ~ wt + disp + cyl + hp + (1 |CAR| gear))
-# f2 <- bf(wt ~ disp + cyl + hp + (1 |CAR| gear))
-# m1 <- brms::brm(f1 + f2 + set_rescor(FALSE), data = mtcars)
-m1 <- insight::download_model(""brms_zi_2"")
-
 # zinb <- read.csv(""http://stats.idre.ucla.edu/stat/data/fish.csv"")
 # set.seed(123)
-# m2 <- brms::brm(bf(
+# m1 <- brm(bf(
 #     count ~ persons + child + camper + (1 | persons),
 #     zi ~ child + camper + (1 | persons)
 #   ),
 #   data = zinb,
 #   family = zero_inflated_poisson()
 # )
-m2 <- insight::download_model(""brms_mv_2"")
+m1 <- insight::download_model(""brms_zi_2"")
+
+# data(epilepsy)
+# set.seed(123)
+# epilepsy$visit <- as.numeric(epilepsy$visit)
+# epilepsy$Base2 <- sample(epilepsy$Base, nrow(epilepsy), replace = TRUE)
+# f1 <- bf(Base ~ zAge + count + (1 |ID| patient))
+# f2 <- bf(Base2 ~ zAge + Trt + (1 |ID| patient))
+# m2 <- brm(f1 + f2 + set_rescor(FALSE), data = epilepsy)
+m2 <- insight::download_model(""brms_mv_3"")
 ```
 
 ## Bayesian models summaries as HTML table"
strengejacke,sjPlot,9219a18dc721a02166b77abd2ef643ba70f6a923,Daniel Ldecke,mail@danielluedecke.de,2019-04-26T13:18:43Z,Daniel Ldecke,mail@danielluedecke.de,2019-04-26T13:18:43Z,fix some issue due to new package-situation,R/html_print.R;R/tab_model.R;R/utils.R;vignettes/tab_bayes.Rmd,True,True,True,False,8,6,14,"---FILE: R/html_print.R---
@@ -839,7 +839,7 @@ create_random_effects <- function(rv.len, rv, rv.string, clean.rv, var.names, su
 
         rv.name <- gsub(pattern, """", names(rv[[j]][i]))
 
-        if (length(rv) > 1)
+        if (length(rv) > 1 && !sjmisc::is_empty(rv.name))
           suffix <- sprintf("" <sub>%s</sub>"", rv.name)
         else
           suffix <- """"

---FILE: R/tab_model.R---
@@ -636,7 +636,7 @@ tab_model <- function(
 
       rsq <- NULL
 
-      if (show.r2) {
+      if (show.r2 && !insight::is_multivariate(model)) {
         # if marginal and conditional r-squared already have been computed
         # via adjusted ICC, use these results and avoid time consuming
         # multiple computation

---FILE: R/utils.R---
@@ -119,6 +119,8 @@ estimate_axis_title <- function(fit, axis.title, type, transform = NULL, multi.r
 
     if (!is.null(multi.resp))
       fitfam <- fitfam[[multi.resp]]
+    else if (insight::is_multivariate(fit))
+      fitfam <- fitfam[[1]]
 
     axis.title <- dplyr::case_when(
       !is.null(transform) && transform == ""plogis"" ~ ""Probabilities"",

---FILE: vignettes/tab_bayes.Rmd---
@@ -68,18 +68,18 @@ For multivariate response models, like mediator-analysis-models, it is recommend
 tab_model(m2)
 ``` 
 
-## Just show one HDI-column
+## Just show one Credible Interval-column
 
-To show just one HDI-column, use `show.hdi50 = FALSE`.
+To show just one CI-column, use `show.ci50 = FALSE`.
 
 ```{r}
-tab_model(m2, show.hdi50 = FALSE)
+tab_model(m2, show.ci50 = FALSE)
 ``` 
 
 ## Mixing multivariate and univariate response models
 
 When both multivariate and univariate response models are displayed in one table, a column _Response_ is added for the multivariate response model, to indicate the different outcomes.
 
 ```{r}
-tab_model(m1, m2, show.hdi50 = F)
+tab_model(m1, m2, show.ci50 = FALSE)
 ``` "
strengejacke,sjPlot,e494ea3f1f1eae5c9c352cedc392c6c4e7f4d366,Daniel Ldecke,mail@danielluedecke.de,2019-04-25T14:56:13Z,Daniel Ldecke,mail@danielluedecke.de,2019-04-25T14:56:13Z,fix brms-issues in tab_model,NAMESPACE;R/html_print.R;R/tab_model.R;vignettes/plot_marginal_effects.Rmd;vignettes/tab_bayes.Rmd;vignettes/tab_mixed.Rmd,True,True,True,False,73,47,120,"---FILE: NAMESPACE---
@@ -120,7 +120,6 @@ importFrom(insight,find_predictors)
 importFrom(insight,find_random)
 importFrom(insight,find_response)
 importFrom(insight,get_data)
-importFrom(insight,get_random)
 importFrom(insight,get_response)
 importFrom(insight,is_multivariate)
 importFrom(insight,model_info)
@@ -133,6 +132,7 @@ importFrom(magrittr,""%>%"")
 importFrom(modelr,crossv_kfold)
 importFrom(nlme,intervals)
 importFrom(performance,cronbachs_alpha)
+importFrom(performance,icc)
 importFrom(performance,item_intercor)
 importFrom(performance,item_reliability)
 importFrom(performance,r2)

---FILE: R/html_print.R---
@@ -475,7 +475,7 @@ tab_model_df <- function(x,
 
     # random effects: Between-group-variance: tau.00 ----
 
-    tau00 <-  tau00 <- purrr::map(variance.list, ~ .x$var.intercept)
+    tau00 <- purrr::map(variance.list, ~ .x$var.intercept)
     tau00.len <- max(purrr::map_dbl(tau00, length))
 
     page.content <- paste0(
@@ -541,7 +541,7 @@ tab_model_df <- function(x,
       create_random_effects(
         rv.len = 1,
         rv = icc.list,
-        rv.string = ""ICC <sub>adjusted</sub>"",
+        rv.string = ""ICC"",
         clean.rv = ""icc"",
         var.names = colnames(x),
         summary.css = summary.css,
@@ -732,7 +732,7 @@ tab_model_df <- function(x,
   }
 
 
-  # add aic ----
+  # add logLik ----
 
   if (!is_empty_list(loglik.list)) {
     page.content <- paste0(page.content, create_stats(
@@ -810,7 +810,7 @@ create_random_effects <- function(rv.len, rv, rv.string, clean.rv, var.names, su
     rvs <- rv.string
     rv.name <- gsub(pattern, """", names(rv[[1]][i]))
 
-    if (length(rv) == 1)
+    if (length(rv) == 1 && !sjmisc::is_empty(rv.name))
       rvs <- sprintf(""%s <sub>%s</sub>"", rv.string, rv.name)
     else if (i > 1)
       rvs <- """"

---FILE: R/tab_model.R---
@@ -205,8 +205,8 @@
 #' @importFrom sjlabelled get_dv_labels get_term_labels
 #' @importFrom sjmisc word_wrap var_rename add_columns add_case
 #' @importFrom sjstats std_beta
-#' @importFrom insight model_info is_multivariate get_random
-#' @importFrom performance r2
+#' @importFrom insight model_info is_multivariate find_random get_data
+#' @importFrom performance r2 icc
 #' @importFrom stats nobs
 #' @importFrom rlang .data
 #' @export
@@ -604,10 +604,18 @@ tab_model <- function(
       }
 
 
+      vars <- NULL
+
       # extract variance components ----
 
       if ((show.icc || show.re.var || show.r2) && is_mixed_model(model)) {
-        vars <- insight::get_variance(model)
+        if (inherits(model, ""brmsfit"")) {
+          vars_brms <- performance::icc(model)
+          vars$var.intercept <- attr(vars_brms, ""var_rand_intercept"")
+          vars$var.residual <- attr(vars_brms, ""var_residual"")
+        } else {
+          vars <- insight::get_variance(model)
+        }
       } else {
         vars <- NULL
       }
@@ -617,7 +625,11 @@ tab_model <- function(
       icc <- NULL
 
       if (show.icc && is_mixed_model(model) && !is.null(vars) && !all(is.na(vars))) {
-        icc <- list(icc.adjusted = vars$var.random / (vars$var.random + vars$var.residual))
+        if (inherits(model, ""brmsfit"")) {
+          icc <- list(icc.adjusted = vars_brms$ICC_decomposed)
+        } else {
+          icc <- list(icc.adjusted = vars$var.random / (vars$var.random + vars$var.residual))
+        }
       }
 
       # Add r-squared statistic ----
@@ -629,10 +641,25 @@ tab_model <- function(
         # via adjusted ICC, use these results and avoid time consuming
         # multiple computation
         if (is_mixed_model(model)) {
-          rsq <- list(
-            `Marginal R2` = vars$var.fixed / (vars$var.fixed + vars$var.random + vars$var.residual),
-            `Conditional R2` = (vars$var.fixed + vars$var.random) / (vars$var.fixed + vars$var.random + vars$var.residual)
-          )
+          if (inherits(model, ""brmsfit"")) {
+            rsqdummy <- tryCatch(
+              {
+                suppressWarnings(performance::r2(model))
+              },
+              error = function(x) { NULL }
+            )
+            if (!is.null(rsqdummy)) {
+              rsq <- list(
+                `Marginal R2` = rsqdummy$R2_Bayes_marginal,
+                `Conditional R2` = rsqdummy$R2_Bayes
+              )
+            }
+          } else {
+            rsq <- list(
+              `Marginal R2` = vars$var.fixed / (vars$var.fixed + vars$var.random + vars$var.residual),
+              `Conditional R2` = (vars$var.fixed + vars$var.random) / (vars$var.fixed + vars$var.random + vars$var.residual)
+            )
+          }
         } else {
           rsq <- tryCatch(
             {
@@ -662,7 +689,8 @@ tab_model <- function(
       n_re_grps <- NULL
 
       if (show.ngroups && is_mixed_model(model)) {
-        n_re_grps <- sapply(insight::get_random(model), function(.i) length(unique(.i, na.rm = TRUE)))
+        rand_eff <- insight::get_data(model)[, insight::find_random(model, split_nested = TRUE, flatten = TRUE), drop = FALSE]
+        n_re_grps <- sapply(rand_eff, function(.i) length(unique(.i, na.rm = TRUE)))
         names(n_re_grps) <- sprintf(""ngrps.%s"", names(n_re_grps))
       }
 
@@ -949,22 +977,22 @@ tab_model <- function(
     if (!sjmisc::is_empty(pos)) {
       i <- as.numeric(sub(""estimate_"", """", x = x, fixed = T))
 
+      if (insight::is_multivariate(models[[1]]))
+        mr <- i
+      else
+        mr <- NULL
+
       if (i <= length(models)) {
         x <- estimate_axis_title(
           models[[i]],
           axis.title = NULL,
           type = ""est"",
           transform = transform.data[[i]],
-          multi.resp = NULL,
+          multi.resp = mr,
           include.zeroinf = FALSE
         )
       } else if (length(models) == 1) {
 
-        if (insight::is_multivariate(models[[1]]))
-          mr <- i
-        else
-          mr <- NULL
-
         x <- estimate_axis_title(
           models[[1]],
           axis.title = NULL,

---FILE: vignettes/plot_marginal_effects.Rmd---
@@ -23,7 +23,8 @@ knitr::opts_chunk$set(
   fig.width = 7, 
   fig.height = 3.5, 
   warning = FALSE,
-  eval = if (isTRUE(exists(""params""))) params$EVAL else FALSE
+  eval = TRUE
+  # eval = if (isTRUE(exists(""params""))) params$EVAL else FALSE
 )
 options(width = 800, tibble.width = Inf)
 ```

---FILE: vignettes/tab_bayes.Rmd---
@@ -19,7 +19,8 @@ knitr::opts_chunk$set(
   collapse = TRUE, 
   comment = ""#>"", 
   message = FALSE,
-  eval = if (isTRUE(exists(""params""))) params$EVAL else FALSE
+  eval = TRUE
+  # eval = if (isTRUE(exists(""params""))) params$EVAL else FALSE
 )
 ```
 
@@ -28,32 +29,27 @@ This vignette shows examples for using `tab_model()` to create HTML tables for m
 ```{r, results='hide', message=FALSE, warning=FALSE}
 # load required packages
 library(sjPlot)
-library(sjmisc)
+library(insight)
 library(brms)
 
-# load sample datasets
-data(""efc"")
-efc <- to_factor(efc, e42dep, c172code, c161sex, e15relat)
-zinb <- read.csv(""http://stats.idre.ucla.edu/stat/data/fish.csv"")
-
-# fit two sample models
-m1 <- brm(
-  bf(count ~ child + camper + (1 | persons), 
-     zi ~ child + camper),
-  data = zinb,
-  family = zero_inflated_poisson(),
-  cores = 4,
-  iter = 1000
-)
-
-f1 <- bf(neg_c_7 ~ e42dep + c12hour + c172code + (1 |ID| e15relat))
-f2 <- bf(c12hour ~ c172code + (1 |ID| e15relat))
-m2 <- brm(
-  f1 + f2 + set_rescor(FALSE), 
-  data = efc, 
-  cores = 4,
-  iter = 1000
-)
+# load sample models
+
+# set.seed(123)
+# f1 <- bf(mpg ~ wt + disp + cyl + hp + (1 |CAR| gear))
+# f2 <- bf(wt ~ disp + cyl + hp + (1 |CAR| gear))
+# m1 <- brms::brm(f1 + f2 + set_rescor(FALSE), data = mtcars)
+m1 <- insight::download_model(""brms_zi_2"")
+
+# zinb <- read.csv(""http://stats.idre.ucla.edu/stat/data/fish.csv"")
+# set.seed(123)
+# m2 <- brms::brm(bf(
+#     count ~ persons + child + camper + (1 | persons),
+#     zi ~ child + camper + (1 | persons)
+#   ),
+#   data = zinb,
+#   family = zero_inflated_poisson()
+# )
+m2 <- insight::download_model(""brms_mv_2"")
 ```
 
 ## Bayesian models summaries as HTML table

---FILE: vignettes/tab_mixed.Rmd---
@@ -19,7 +19,8 @@ knitr::opts_chunk$set(
   collapse = TRUE, 
   comment = ""#>"", 
   message = FALSE,
-  eval = TRUE # if (isTRUE(exists(""params""))) params$EVAL else FALSE
+  eval = TRUE
+  # eval = if (isTRUE(exists(""params""))) params$EVAL else FALSE
 )
 ```
 "
strengejacke,sjPlot,88c4ca93d6a6838fd97276c0513bd8bee392b62a,Daniel Ldecke,mail@danielluedecke.de,2019-04-24T10:29:37Z,Daniel Ldecke,mail@danielluedecke.de,2019-04-24T10:29:37Z,fix issue,R/tidiers.R,False,True,True,False,1,1,2,"---FILE: R/tidiers.R---
@@ -244,7 +244,7 @@ tidy_stan_model <- function(model, ci.lvl, tf, type, bpe, show.zeroinf, facets,
     dplyr::select(.data$CI_low, .data$CI_high) %>%
     sjmisc::var_rename(CI_low = ""conf.low50"", CI_high = ""conf.high50"") %>%
     sjmisc::add_columns(d1) %>%
-    sjmisc::var_rename(CI_low = ""conf.low"", CI_high = ""conf.high"") %>%
+    sjmisc::var_rename(CI_low = ""conf.low"", CI_high = ""conf.high"", Parameter = ""term"") %>%
     dplyr::select(-.data$CI)
 
   # for brmsfit models, we need to remove some columns here to"
strengejacke,sjPlot,c8e9cb48b722d0e8a94c15f7f94ead1f51a986be,Daniel Ldecke,mail@danielluedecke.de,2019-04-24T10:22:28Z,Daniel Ldecke,mail@danielluedecke.de,2019-04-24T10:22:28Z,fix bug,R/tidiers.R;vignettes/custplot.Rmd,True,True,True,False,10,6,16,"---FILE: R/tidiers.R---
@@ -229,10 +229,14 @@ tidy_stan_model <- function(model, ci.lvl, tf, type, bpe, show.zeroinf, facets,
   d1 <- bayestestR::ci(model, ci = p.outer, effects = ty)
   d2 <- bayestestR::ci(model, ci = p.inner, effects = ty)
 
-  d1$CI_low <- tf(d1$CI_low)
-  d1$CI_high <- tf(d1$CI_high)
-  d2$CI_low <- tf(d2$CI_low)
-  d2$CI_high <- tf(d2$CI_high)
+  if (!is.null(tf)) {
+    funtrans <- match.fun(tf)
+
+    d1$CI_low <- funtrans(d1$CI_low)
+    d1$CI_high <- funtrans(d1$CI_high)
+    d2$CI_low <- funtrans(d2$CI_low)
+    d2$CI_high <- funtrans(d2$CI_high)
+  }
 
   # bind columns, so we have inner and outer hdi interval
 

---FILE: vignettes/custplot.Rmd---
@@ -119,7 +119,7 @@ You can use any pre-defined theme from ggplot, like `theme_bw()`, `theme_classic
 
 ```{r}
 set_theme(base = theme_light())
-sjp.frq(efc$e42dep)
+plot_frq(efc$e42dep)
 ```
 
 ## Pre-defined themes
@@ -165,7 +165,7 @@ show_sjplot_pals()
 If you want to use a specific theme as base for building your own theme, use the `base` argument. When using `base` instead of `theme`, further arguments for settings colors etc. are not ignored.
 ```{r}
 set_theme(base = theme_bw(), axis.linecolor = ""darkgreen"")
-sjp.frq(efc$e42dep)
+plot_frq(efc$e42dep)
 ```
 
 "
strengejacke,sjPlot,2b759303aa6b2695aca7fb45a2c080f9c293a02b,Daniel Ldecke,mail@danielluedecke.de,2019-04-24T08:59:02Z,Daniel Ldecke,mail@danielluedecke.de,2019-04-24T08:59:02Z,fix naming of r2,R/tab_model.R,False,True,True,False,11,1,12,"---FILE: R/tab_model.R---
@@ -635,8 +635,18 @@ tab_model <- function(
             },
             error = function(x) { NULL }
           )
+
+          # fix names of r-squared values
+
           if (!is.null(rsq)) {
-            names(rsq) <- as.vector(sapply(rsq, names))
+            r_has_names <- sapply(rsq, function(.n) !is.null(names(.n)))
+            if (all(r_has_names)) {
+              rnames <- as.vector(sapply(rsq, names))
+            } else {
+              rnames <- names(rsq)
+            }
+            rnames <- sub(""_"", "" "", rnames)
+            names(rsq) <- rnames
           }
         }
       }"
strengejacke,sjPlot,6797f3d2f7931968b0a4871f76331640454928de,Daniel Ldecke,mail@danielluedecke.de,2019-04-24T08:47:32Z,Daniel Ldecke,mail@danielluedecke.de,2019-04-24T08:47:32Z,fix names,R/tab_model.R,False,True,True,False,3,0,3,"---FILE: R/tab_model.R---
@@ -635,6 +635,9 @@ tab_model <- function(
             },
             error = function(x) { NULL }
           )
+          if (!is.null(rsq)) {
+            names(rsq) <- as.vector(sapply(rsq, names))
+          }
         }
       }
 "
strengejacke,sjPlot,6a541191727268147fea3dd0651b92019ed70874,Alexander Bartel,github@ndevln.org,2019-04-24T08:31:16Z,Alexander Bartel,github@ndevln.org,2019-04-24T08:31:16Z,Bugfix plot_likert(): add default option for proper y-axis alignment,R/plot_likert.R,False,True,True,False,1,1,2,"---FILE: R/plot_likert.R---
@@ -152,7 +152,7 @@ plot_likert <- function(items,
                         sort.groups = TRUE, # Group Options
                         legend.pos = ""bottom"",
                         rel_heights = 1,
-                        cowplot.options = list(label_x = 0.01, hjust = 0) # Fix for label position depending on label length bug in cowplot
+                        cowplot.options = list(label_x = 0.01, hjust = 0, align=""v"") # Fix for label position depending on label length bug in cowplot
                         ) {
 
   # Select options to be passed to .plot_likert()"
strengejacke,sjPlot,ec851b047bb1e4fd7a0ebbb932e667a4228c2d9e,Daniel Ldecke,mail@danielluedecke.de,2019-04-24T07:15:10Z,Daniel Ldecke,mail@danielluedecke.de,2019-04-24T07:15:10Z,fix pkg-references,R/plot_model.R;R/sjTabItemAnalysis.R;R/tab_model.R;man/plot_model.Rd;man/plot_models.Rd;man/sjt.itemanalysis.Rd;man/tab_model.Rd,False,True,True,False,12,12,24,"---FILE: R/plot_model.R---
@@ -177,7 +177,7 @@
 #' @param ci.lvl Numeric, the level of the confidence intervals (error bars).
 #'   Use \code{ci.lvl = NA} to remove error bars. For \code{stanreg}-models,
 #'   \code{ci.lvl} defines the (outer) probability for the \emph{credible interval}
-#'   that is plotted (see \code{\link[sjstats]{credint}}). By
+#'   that is plotted (see \code{\link[bayestestR]{ci}}). By
 #'   default, \code{stanreg}-models are printed with two intervals: the ""inner""
 #'   interval, which defaults to the 50\%-CI; and the ""outer"" interval, which
 #'   defaults to the 89\%-CI. \code{ci.lvl} affects only the outer interval in
@@ -268,7 +268,7 @@
 #'   of the posterior distribution. Use \code{bpe} to define other functions to
 #'   calculate the Bayesian point estimate. \code{bpe} needs to be a character
 #'   naming the specific function, which is passed to the \code{fun}-argument in
-#'   \code{\link[sjstats]{typical_value}}. So, \code{bpe = ""mean""} would
+#'   \code{\link[sjmisc]{typical_value}}. So, \code{bpe = ""mean""} would
 #'   calculate the mean value of the posterior distribution.
 #' @param bpe.style For \strong{Stan}-models (fitted with the \pkg{rstanarm}- or
 #'   \pkg{brms}-package), the Bayesian point estimate is indicated as a small,

---FILE: R/sjTabItemAnalysis.R---
@@ -35,7 +35,7 @@
 #'          Default is \code{""auto""}, which means that each table has a standard caption \emph{Component x}.
 #'          Use \code{NULL} to suppress table captions.
 #' @param scale Logical, if \code{TRUE}, the data frame's vectors will be scaled when calculating the
-#'          Cronbach's Alpha value (see \code{\link[sjstats]{reliab_test}}). Recommended, when
+#'          Cronbach's Alpha value (see \code{\link[performance]{item_reliability}}). Recommended, when
 #'          the variables have different measures / scales.
 #' @param min.valid.rowmean Minimum amount of valid values to compute row means for index scores.
 #'          Default is 2, i.e. the return values \code{index.scores} and \code{df.index.scores} are
@@ -75,7 +75,7 @@
 #' @note \itemize{
 #'          \item The \emph{Shapiro-Wilk Normality Test} (see column \code{W(p)}) tests if an item has a distribution that is significantly different from normal.
 #'          \item \emph{Item difficulty} should range between 0.2 and 0.8. Ideal value is \code{p+(1-p)/2} (which mostly is between 0.5 and 0.8).
-#'          \item For \emph{item discrimination}, acceptable values are 0.20 or higher; the closer to 1.00 the better. See \code{\link[sjstats]{reliab_test}} for more details.
+#'          \item For \emph{item discrimination}, acceptable values are 0.20 or higher; the closer to 1.00 the better. See \code{\link[performance]{item_reliability}} for more details.
 #'          \item In case the total \emph{Cronbach's Alpha} value is below the acceptable cut-off of 0.7 (mostly if an index has few items), the \emph{mean inter-item-correlation} is an alternative measure to indicate acceptability. Satisfactory range lies between 0.2 and 0.4. See also \code{\link[performance]{item_intercor}}.
 #'        }
 #'

---FILE: R/tab_model.R---
@@ -61,7 +61,7 @@
 #'   \code{\link[sjstats]{robust}} for details).
 #' @param show.r2 Logical, if \code{TRUE}, the r-squared value is also printed.
 #'    Depending on the model, these might be pseudo-r-squared values, or Bayesian
-#'    r-squared etc. See \code{\link[sjstats]{r2}} for details.
+#'    r-squared etc. See \code{\link[performance]{r2}} for details.
 #' @param show.stat Logical, if \code{TRUE}, the coefficients' test statistic
 #'    is also printed.
 #' @param show.df Logical, if \code{TRUE} and \code{p.val = ""kr""}, the p-values

---FILE: man/plot_model.Rd---
@@ -227,7 +227,7 @@ axis positions of the major grid lines.}
 \item{ci.lvl}{Numeric, the level of the confidence intervals (error bars).
 Use \code{ci.lvl = NA} to remove error bars. For \code{stanreg}-models,
 \code{ci.lvl} defines the (outer) probability for the \emph{credible interval}
-that is plotted (see \code{\link[sjstats]{credint}}). By
+that is plotted (see \code{\link[bayestestR]{ci}}). By
 default, \code{stanreg}-models are printed with two intervals: the ""inner""
 interval, which defaults to the 50\%-CI; and the ""outer"" interval, which
 defaults to the 89\%-CI. \code{ci.lvl} affects only the outer interval in
@@ -338,7 +338,7 @@ details.}
 of the posterior distribution. Use \code{bpe} to define other functions to
 calculate the Bayesian point estimate. \code{bpe} needs to be a character
 naming the specific function, which is passed to the \code{fun}-argument in
-\code{\link[sjstats]{typical_value}}. So, \code{bpe = ""mean""} would
+\code{\link[sjmisc]{typical_value}}. So, \code{bpe = ""mean""} would
 calculate the mean value of the posterior distribution.}
 
 \item{bpe.style}{For \strong{Stan}-models (fitted with the \pkg{rstanarm}- or

---FILE: man/plot_models.Rd---
@@ -141,7 +141,7 @@ annotating p-values with asterisks. Only applies if
 \item{ci.lvl}{Numeric, the level of the confidence intervals (error bars).
 Use \code{ci.lvl = NA} to remove error bars. For \code{stanreg}-models,
 \code{ci.lvl} defines the (outer) probability for the \emph{credible interval}
-that is plotted (see \code{\link[sjstats]{credint}}). By
+that is plotted (see \code{\link[bayestestR]{ci}}). By
 default, \code{stanreg}-models are printed with two intervals: the ""inner""
 interval, which defaults to the 50\%-CI; and the ""outer"" interval, which
 defaults to the 89\%-CI. \code{ci.lvl} affects only the outer interval in

---FILE: man/sjt.itemanalysis.Rd---
@@ -25,7 +25,7 @@ Default is \code{""auto""}, which means that each table has a standard caption \em
 Use \code{NULL} to suppress table captions.}
 
 \item{scale}{Logical, if \code{TRUE}, the data frame's vectors will be scaled when calculating the
-Cronbach's Alpha value (see \code{\link[sjstats]{reliab_test}}). Recommended, when
+Cronbach's Alpha value (see \code{\link[performance]{item_reliability}}). Recommended, when
 the variables have different measures / scales.}
 
 \item{min.valid.rowmean}{Minimum amount of valid values to compute row means for index scores.
@@ -121,7 +121,7 @@ This function performs an item analysis with certain statistics that are
 \itemize{
          \item The \emph{Shapiro-Wilk Normality Test} (see column \code{W(p)}) tests if an item has a distribution that is significantly different from normal.
          \item \emph{Item difficulty} should range between 0.2 and 0.8. Ideal value is \code{p+(1-p)/2} (which mostly is between 0.5 and 0.8).
-         \item For \emph{item discrimination}, acceptable values are 0.20 or higher; the closer to 1.00 the better. See \code{\link[sjstats]{reliab_test}} for more details.
+         \item For \emph{item discrimination}, acceptable values are 0.20 or higher; the closer to 1.00 the better. See \code{\link[performance]{item_reliability}} for more details.
          \item In case the total \emph{Cronbach's Alpha} value is below the acceptable cut-off of 0.7 (mostly if an index has few items), the \emph{mean inter-item-correlation} is an alternative measure to indicate acceptability. Satisfactory range lies between 0.2 and 0.4. See also \code{\link[performance]{item_intercor}}.
        }
 }

---FILE: man/tab_model.Rd---
@@ -76,7 +76,7 @@ model part, this is also printed to the table.}
 
 \item{show.r2}{Logical, if \code{TRUE}, the r-squared value is also printed.
 Depending on the model, these might be pseudo-r-squared values, or Bayesian
-r-squared etc. See \code{\link[sjstats]{r2}} for details.}
+r-squared etc. See \code{\link[performance]{r2}} for details.}
 
 \item{show.icc}{Logical, if \code{TRUE}, prints the intraclass correlation
 coefficient for mixed models. See \code{\link[performance]{icc}} for details.}
@@ -258,7 +258,7 @@ details.}
 of the posterior distribution. Use \code{bpe} to define other functions to
 calculate the Bayesian point estimate. \code{bpe} needs to be a character
 naming the specific function, which is passed to the \code{fun}-argument in
-\code{\link[sjstats]{typical_value}}. So, \code{bpe = ""mean""} would
+\code{\link[sjmisc]{typical_value}}. So, \code{bpe = ""mean""} would
 calculate the mean value of the posterior distribution.}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,"
strengejacke,sjPlot,a760016f27c3655f76b13e9f67609ddd78a279ed,NeoDevlin,neodevlin@gmail.com,2019-03-23T13:21:22Z,Alexander Bartel,github@ndevln.org,2019-04-15T09:43:09Z,"Integrate grouping into plot_likert(). Behavior mimics sjt.itemanalysis(). Cowplot still an optional dependency. Add to suggest?

Linting and upper/lower case corrections",NAMESPACE;R/plot_likert.R;R/plot_likert_grp.R;man/plot_likert.Rd;man/plot_likert_grp.Rd,False,True,True,False,205,216,421,"---FILE: NAMESPACE---
@@ -30,7 +30,6 @@ export(legend_style)
 export(plot_gpt)
 export(plot_grid)
 export(plot_likert)
-export(plot_likert_grp)
 export(plot_model)
 export(plot_models)
 export(plot_residuals)

---FILE: R/plot_likert.R---
@@ -13,7 +13,7 @@
 #'        of categories fails. In such cases, specify the amount of categories
 #'        with the \code{catcount}-argument.
 #'
-#' @param catcount Optional, amount of categories of \code{items} (e.g. \emph{""strongly disagree"",
+#' @param catcount optional, amount of categories of \code{items} (e.g. \emph{""strongly disagree"",
 #'          ""disagree"", ""agree""} and \emph{""strongly agree""} would be \code{catcount = 4}).
 #'          Note that this argument only applies to ""valid"" answers, i.e. if you
 #'          have an additional neutral category (see \code{cat.neutral}) like \emph{""don't know""},
@@ -33,7 +33,7 @@
 #'            \item{\code{""neg.desc""}}{for sorting descending negative answers}
 #'            \item{\code{NULL}}{(default) for no sorting}
 #'          }
-#' @param reverse.colors Logical, if \code{TRUE}, the color scale from \code{geom.colors} will be reversed,
+#' @param reverse.colors logical, if \code{TRUE}, the color scale from \code{geom.colors} will be reversed,
 #'          so positive and negative values switch colors.
 #' @param cat.neutral.color Color of the neutral category, if plotted (see \code{cat.neutral}).
 #' @param intercept.line.color Color of the vertical intercept line that divides positive and negative values.
@@ -44,14 +44,29 @@
 #'            \item{\code{""sum.inside""}}{shows the sums of percentage values for both negative and positive values and prints them inside the end of each bar}
 #'            \item{\code{""sum.outside""}}{shows the sums of percentage values for both negative and positive values and prints them outside the end of each bar}
 #'          }
-#' @param show.prc.sign Logical, if \code{TRUE}, \%-signs for value labels are shown.
+#' @param show.prc.sign logical, if \code{TRUE}, \%-signs for value labels are shown.
 #' @param grid.range Numeric, limits of the x-axis-range, as proportion of 100.
 #'          Default is 1, so the x-scale ranges from zero to 100\% on both sides from the center.
 #'          Can alternatively be supplied as a vector of 2 positive numbers (e.g. \code{grid.range = c(1, .8)})
 #'          to set the left and right limit separately. You can use values beyond 1 (100\%) in case bar labels are not printed because
 #'          they exceed the axis range. E.g. \code{grid.range = 1.4} will set the axis from -140 to +140\%, however, only
 #'          (valid) axis labels from -100 to +100\% are printed. Neutral categories are adjusted to the most left limit.
-#' @param reverse.scale Logical, if \code{TRUE}, the ordering of the categories is reversed, so positive and negative values switch position.
+#' @param reverse.scale logical, if \code{TRUE}, the ordering of the categories is reversed, so positive and negative values switch position.
+#' 
+#' @param factor.groups (optional) Must be a vector of same length as \code{ncol(df)}, 
+#'                      where each item in this vector represents the group number 
+#'                      of the related columns of \code{df}. See 'Examples'.
+#' @param factor.groups.titles (optional, only used if groups are supplied) Titles for each factor group that will be used as table caption for each
+#'          component-table. Must be a character vector of same length as \code{length(unique(factor.groups))}.
+#'          Default is \code{""auto""}, which means that each table has a standard caption \emph{Component x}.
+#'          Use \code{NULL} to use names as supplied to \code{factor.groups} and use \code{FALSE} to suppress table captions.
+#' @param sort.groups (optional, only used if groups are supplied) logical, if groups should be sorted according to the values supplied to \code{factor.groups}. Defaults to \code{TRUE}.
+#' @param legend.pos (optional, only used if groups are supplied) Defines the legend position. Possible values are \code{c(""bottom"", ""top"", ""both"", ""all"", ""none"")}. 
+#'                   If the is only one group or this option is set to \code{""all""} legends will be printed as defined with \code{\link{set_theme}}.
+#' @param rel_heights (optional, only used if groups are supplied) This option can be used to adjust the height of the subplots. The bars in subplots can have different heights due to a differing number of items 
+#'                    or due to legend placement. This can be adjusted here. 
+#'                    Takes a vector of numbers, one for each plot. Values are evaluated relative to each other.
+#' @param cowplot.options (optional, only used if groups are supplied) List of label options to be passed to \code{\link[cowplot]{plot_grid}}.
 #'
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjp.stackfrq
@@ -64,14 +79,33 @@
 #' data(efc)
 #' # find all variables from COPE-Index, which all have a ""cop"" in their
 #' # variable name, and then plot that subset as likert-plot
-#' find_var(efc, pattern = ""cop"", out = ""df"") %>% plot_likert()
+#' mydf <- find_var(efc, pattern = ""cop"", out = ""df"")
+#' 
+#' plot_likert(mydf)
 #'
 #' plot_likert(
-#'   find_var(efc, pattern = ""cop"", out = ""df""),
+#'   mydf,
 #'   grid.range = c(1.2, 1.4),
 #'   expand.grid = FALSE,
 #'   values = ""sum.outside"",
 #'   show.prc.sign = TRUE
+#'   
+#' # Plot in groups
+#' 
+#' plot_likert(mydf, c(2,1,1,1,1,2,2,2,1))
+#' 
+#' factor.groups <- sjt.pca(mydf)$factor.index
+#' plot_likert(mydf, c(2,1,1,1,1,2,2,2,1), factor.groups = factor.groups)
+#' 
+#' plot_likert(mydf, 
+#'             c(rep(""B"",4),rep(""A"",5)), 
+#'             sort.groups = F, 
+#'             grid.range = c(0.9,1.1), 
+#'             geom.colors = ""RdBu"", 
+#'             rel_heights = c(6,8), 
+#'             wrap.labels = 40, 
+#'             reverse.scale=T)   
+#'
 #' )
 #'
 #' @import ggplot2
@@ -82,7 +116,110 @@
 #' @importFrom dplyr between
 #'
 #' @export
+
 plot_likert <- function(items,
+                        factor.groups = NULL,
+                        factor.groups.titles = ""auto"",
+                        title = NULL,
+                        legend.title = NULL,  # Options to be passed directly to .plot_likert()
+                        legend.labels = NULL,
+                        axis.titles = NULL,
+                        axis.labels = NULL,
+                        catcount = NULL,
+                        cat.neutral = NULL,
+                        sort.frq = NULL,
+                        weight.by = NULL,
+                        title.wtd.suffix = NULL,
+                        wrap.title = 50,
+                        wrap.labels = 30,
+                        wrap.legend.title = 30,
+                        wrap.legend.labels = 28,
+                        geom.size = .6,
+                        geom.colors = ""BrBG"",
+                        cat.neutral.color = ""grey70"",
+                        intercept.line.color = ""grey50"",
+                        reverse.colors = FALSE,
+                        values = ""show"",
+                        show.n = TRUE,
+                        show.legend = TRUE,
+                        show.prc.sign = FALSE,
+                        grid.range = 1,
+                        grid.breaks = 0.2,
+                        expand.grid = TRUE,
+                        digits = 1,
+                        reverse.scale = FALSE,
+                        coord.flip = TRUE,
+                        sort.groups = TRUE, # Group Options
+                        legend.pos = ""bottom"",
+                        rel_heights = 1,
+                        cowplot.options = list(label_x = 0.01, hjust = 0) # Fix for label position depending on label length bug in cowplot
+                        ) {
+
+  # Select options to be passed to .plot_likert()
+  .likert_options <- as.list(environment())[5:32]
+
+  ## If now no groups are supplied only 1 group will be assumed. Check for cowplot is only performed if there are groups supplied.
+  if (is.null(factor.groups))
+    factor.groups <- rep(1, length.out = ncol(items))
+  else
+    if (!requireNamespace(""cowplot"", quietly = T))
+      stop(""plot_likert_grp: Please install the package \""cowplot\"""", call. = F)
+
+  if (ncol(items) != length(factor.groups))
+    stop(""plot_likert_grp: Length of groups has to equal the number of items: ncol(items) != length(groups)"", call. = F)
+
+  # retrieve unique factor / group index values
+  findex <- unique(factor.groups)
+
+  if (sort.groups) findex <- sort(findex)
+
+  # Add empty title to plots, to create space for the group.labels
+  if (is.null(title) & length(findex) != 1) title <- rep("""", length(findex))
+
+  .plot_list <- list()
+
+  # iterate all sub-plots (groups)
+  for (i in seq_along(findex)) {
+    index <- which(factor.groups == findex[i])
+
+    .pl <- do.call("".plot_likert"", args = c(list(items[, index], title = title[i]), .likert_options))
+    # If there are 2 or more groups, the legend will be plotted according to legend.pos.
+    if (length(findex) != 1) {
+      if (legend.pos %in% c(""top"", ""both"") & i == 1)
+        .pl <- .pl + theme(legend.position = ""top"")
+      else if (legend.pos %in% c(""bottom"", ""both"") & i == length(findex))
+        .pl <- .pl + theme(legend.position = ""bottom"")
+      else if (legend.pos != ""all"")
+        .pl <- .pl + theme(legend.position = ""none"")
+    }
+
+    .plot_list[i] <-  list(.pl)
+  }
+
+  # Options to turn off or overwrite cowplot group.labels.
+  if (isFALSE(factor.groups.titles))
+    factor.groups.titles <- rep("""", length(findex))
+  else if (!is.null(factor.groups.titles) && (factor.groups.titles[1] == ""auto"" || length(factor.groups.titles) != length(findex)) && (is.numeric(factor.groups))) {
+    factor.groups.titles <- sprintf(""Component %i"", seq_along(findex)) # For sjt.itemanalysis compatibility
+  } else if (length(factor.groups.titles) != length(findex))
+    factor.groups.titles <- findex
+
+  # If groups were supplied, combine the subplots with cowplot::plot_grid()
+  if (length(findex) == 1)
+    .out <- .plot_list[[1]]
+  else
+    .out <- do.call(get(""plot_grid"", asNamespace(""cowplot"")),
+                    args = c(list(
+                              ""plotlist"" = .plot_list,
+                              ""labels"" = factor.groups.titles,
+                              ""rel_heights"" = rel_heights,
+                              ""ncol"" = 1),
+                            cowplot.options))
+
+  return(.out)
+}
+
+.plot_likert <- function(items,
                        title = NULL,
                        legend.title = NULL,
                        legend.labels = NULL,
@@ -119,7 +256,7 @@ plot_likert <- function(items,
   if (!is.data.frame(items) && !is.matrix(items)) items <- as.data.frame(items)
 
   # if grid.range is supplied as 1 value, it is duplicated for symmetric results. This is for compatibillity with older versions.
-  if (length(grid.range) == 1) grid.range = c(grid.range, grid.range)
+  if (length(grid.range) == 1) grid.range <- c(grid.range, grid.range)
 
   # copy titles
 
@@ -618,10 +755,10 @@ plot_likert <- function(items,
 
   # check wether percentage scale (y-axis) should be reversed
 
-  if(!reverse.scale) {
-    gp <- gp +scale_y_continuous(breaks = gridbreaks, limits = c(-grid.range[1], grid.range[2]), expand = expgrid, labels = gridlabs)
+  if (!reverse.scale) {
+    gp <- gp + scale_y_continuous(breaks = gridbreaks, limits = c(-grid.range[1], grid.range[2]), expand = expgrid, labels = gridlabs)
   } else {
-    gp <- gp +scale_y_reverse(breaks = gridbreaks, limits = c(grid.range[2], -grid.range[1]), expand = expgrid, labels = gridlabs)
+    gp <- gp + scale_y_reverse(breaks = gridbreaks, limits = c(grid.range[2], -grid.range[1]), expand = expgrid, labels = gridlabs)
   }
 
   # check whether coordinates should be flipped, i.e.

---FILE: R/plot_likert_grp.R---
@@ -1,121 +0,0 @@
-#' Plot likert scales as centered stacked bars in groups
-#' 
-#' @name plot_likert_grp
-#' 
-#' @description Plot likert scales as centered stacked bars in groups
-#'
-#' @param factor.groups Must be a vector of same length as \code{ncol(df)}, 
-#'                      where each item in this vector represents the group number 
-#'                      of the related columns of \code{df}. See 'Examples'.
-#' @param factor.groups.titles Titles for each factor group that will be used as table caption for each
-#'          component-table. Must be a character vector of same length as \code{length(unique(factor.groups))}.
-#'          Default is \code{""auto""}, which means that each table has a standard caption \emph{Component x}.
-#'          Use \code{NULL} to use names as supplied to \code{factor.groups} and use \code{FALSE} to suppress table captions.
-#' @param sort.groups If groups should be sorted according to the values supplied to \code{factor.groups}. Defaults to \code{TRUE}.
-#' @param legend.pos Defines the legend position. Possible values are \code{c(""bottom"", ""top"", ""all"", ""none"")}. 
-#'                   \code{""all""} will print legends as defined with \code{\link{set_theme}}.
-#' @param rel_heights This option can be used to adjust the height of the subplots. The bars in subplots can have different heights due to a differing number of items 
-#'                    or due to legend placement. This can be adjusted here. 
-#'                    Takes a vector of numbers, one for each plot. Values are evaluated relative to each other.
-#' @param label_x,hjust,align,label_size,label_fontfamily,label_fontface,label_colour,label_y,vjust Label options. See \code{\link[cowplot]{plot_grid}}.
-#' @param ... Extra arguments to be passed to \code{\link{plot_likert}}.
-#'
-#' @inheritParams sjp.grpfrq
-#' @inheritParams sjp.stackfrq
-#' 
-#' @examples
-#' library(sjmisc)
-#' data(efc)
-#' # find all variables from COPE-Index, which all have a ""cop"" in their
-#' # variable name, and then plot that subset as likert-plot
-#' mydf <- find_var(efc, pattern = ""cop"", out = ""df"")
-#' 
-#' plot_likert_grp(mydf, c(2,1,1,1,1,2,2,2,1))
-#' 
-#' factor.groups <- sjt.pca(mydf)$factor.index
-#' plot_likert_grp(mydf, c(2,1,1,1,1,2,2,2,1), factor.groups = factor.groups)
-#' 
-#' plot_likert_grp(mydf, 
-#'                 c(rep(""B"",4),rep(""A"",5)), 
-#'                 sort.groups = F, 
-#'                 grid.range = c(0.9,1.1), 
-#'                 geom.colors = ""RdBu"", 
-#'                 rel_heights = c(6,8), 
-#'                 wrap.labels = 40, 
-#'                 reverse.scale=T)
-#' 
-#' @export
-plot_likert_grp <- function(items,
-                            factor.groups,
-                            factor.groups.titles = ""auto"",
-                            sort.groups = TRUE,
-                            legend.pos = ""bottom"",
-                            rel_heights = 1,
-                            title = NULL,
-                            label_x = 0.01, # Fix for label position depending on label length bug in cowplot
-                            hjust = 0,
-                            align = ""v"",
-                            label_size = 14, # Cowplot label Options
-                            label_fontfamily = NULL,
-                            label_fontface = ""bold"",
-                            label_colour = NULL,
-                            label_y = 1,
-                            vjust = 1.5,
-                            ...) {
-  
-  if (!requireNamespace(""cowplot"", quietly = T)) 
-    stop(""plot_likert_grp: Please install the package \""cowplot\"""", call. = F)
-
-  if (ncol(items) != length(factor.groups))
-    stop(""plot_likert_grp: Length of groups has to equal the number of items: ncol(items) != length(groups)"", call. = F)
-
-  # retrieve unique factor / group index values
-  findex <- unique(factor.groups)
-
-  if (sort.groups) findex <- sort(findex)
-
-  # Add empty title to plots, to create space for the group.labels
-  if (is.null(title)) title <- rep("""", length(findex))
-
-  .plot_list <- list()
-
-  # iterate all sub-plots (groups)
-  for (i in seq_along(findex)) {
-    index <- which(factor.groups == findex[i])
-
-    .pl <- plot_likert(items[, index], title = title[i], ...)
-
-    # Only the first or the last plot will have a legend, Maybe add option both
-    if (legend.pos == ""top"" & i == 1)
-      .pl <- .pl + theme(legend.position = ""top"")
-    else if (legend.pos == ""bottom"" & i == length(findex))
-      .pl <- .pl + theme(legend.position = ""bottom"")
-    else if (legend.pos != ""all"") 
-      .pl <- .pl + theme(legend.position = ""none"")
-
-    .plot_list[i] <-  list(.pl)
-  }
-
-  # Options to turn off or overwrite cowplot group.labels
-  if (isFALSE(factor.groups.titles))
-    factor.groups.titles <- rep("""", length(findex))
-  else if (!is.null(factor.groups.titles) && (factor.groups.titles[1] == ""auto"" || length(factor.groups.titles) != length(findex)) && (is.numeric(factor.groups))) {
-    factor.groups.titles <- sprintf(""Component %i"", seq_along(findex)) # For sjt.itemanalysis compatibility
-  } else if (length(factor.groups.titles) != length(findex))
-    factor.groups.titles <- findex
-
-  return(cowplot::plot_grid(plotlist = .plot_list,
-                            labels = factor.groups.titles,
-                            rel_heights = rel_heights,
-                            ncol = 1,
-                            align = align,
-                            label_x = label_x, # Cowplot label options can't be passed on using ...
-                            label_size = label_size,
-                            label_fontfamily = label_fontfamily,
-                            label_fontface = label_fontface,
-                            label_colour = label_colour,
-                            label_y = label_y,
-                            hjust = hjust,
-                            vjust = vjust)
-  )
-}

---FILE: man/plot_likert.Rd---
@@ -4,21 +4,32 @@
 \alias{plot_likert}
 \title{Plot likert scales as centered stacked bars}
 \usage{
-plot_likert(items, title = NULL, legend.title = NULL,
-  legend.labels = NULL, axis.titles = NULL, axis.labels = NULL,
-  catcount = NULL, cat.neutral = NULL, sort.frq = NULL,
-  weight.by = NULL, title.wtd.suffix = NULL, wrap.title = 50,
-  wrap.labels = 30, wrap.legend.title = 30, wrap.legend.labels = 28,
-  geom.size = 0.6, geom.colors = ""BrBG"",
-  cat.neutral.color = ""grey70"", intercept.line.color = ""grey50"",
-  reverse.colors = FALSE, values = ""show"", show.n = TRUE,
-  show.legend = TRUE, show.prc.sign = FALSE, grid.range = 1,
-  grid.breaks = 0.2, expand.grid = TRUE, digits = 1,
-  reverse.scale = FALSE, coord.flip = TRUE)
+plot_likert(items, factor.groups = NULL, factor.groups.titles = ""auto"",
+  title = NULL, legend.title = NULL, legend.labels = NULL,
+  axis.titles = NULL, axis.labels = NULL, catcount = NULL,
+  cat.neutral = NULL, sort.frq = NULL, weight.by = NULL,
+  title.wtd.suffix = NULL, wrap.title = 50, wrap.labels = 30,
+  wrap.legend.title = 30, wrap.legend.labels = 28, geom.size = 0.6,
+  geom.colors = ""BrBG"", cat.neutral.color = ""grey70"",
+  intercept.line.color = ""grey50"", reverse.colors = FALSE,
+  values = ""show"", show.n = TRUE, show.legend = TRUE,
+  show.prc.sign = FALSE, grid.range = 1, grid.breaks = 0.2,
+  expand.grid = TRUE, digits = 1, reverse.scale = FALSE,
+  coord.flip = TRUE, sort.groups = TRUE, legend.pos = ""bottom"",
+  rel_heights = 1, cowplot.options = list(label_x = 0.01, hjust = 0))
 }
 \arguments{
 \item{items}{Data frame, with each column representing one item.}
 
+\item{factor.groups}{(optional) Must be a vector of same length as \code{ncol(df)}, 
+where each item in this vector represents the group number 
+of the related columns of \code{df}. See 'Examples'.}
+
+\item{factor.groups.titles}{(optional, only used if groups are supplied) Titles for each factor group that will be used as table caption for each
+component-table. Must be a character vector of same length as \code{length(unique(factor.groups))}.
+Default is \code{""auto""}, which means that each table has a standard caption \emph{Component x}.
+Use \code{NULL} to use names as supplied to \code{factor.groups} and use \code{FALSE} to suppress table captions.}
+
 \item{title}{character vector, used as plot title. Depending on plot type and function,
 will be set automatically. If \code{title = """"}, no title is printed.
 For effect-plots, may also be a character vector of length > 1,
@@ -34,7 +45,7 @@ for the x-axis and y-axis.}
 \item{axis.labels}{character vector with labels used as axis labels. Optional
 argument, since in most cases, axis labels are set automatically.}
 
-\item{catcount}{Optional, amount of categories of \code{items} (e.g. \emph{""strongly disagree"",
+\item{catcount}{optional, amount of categories of \code{items} (e.g. \emph{""strongly disagree"",
 ""disagree"", ""agree""} and \emph{""strongly agree""} would be \code{catcount = 4}).
 Note that this argument only applies to ""valid"" answers, i.e. if you
 have an additional neutral category (see \code{cat.neutral}) like \emph{""don't know""},
@@ -87,7 +98,7 @@ need smaller values than dot sizes.}
 
 \item{intercept.line.color}{Color of the vertical intercept line that divides positive and negative values.}
 
-\item{reverse.colors}{Logical, if \code{TRUE}, the color scale from \code{geom.colors} will be reversed,
+\item{reverse.colors}{logical, if \code{TRUE}, the color scale from \code{geom.colors} will be reversed,
 so positive and negative values switch colors.}
 
 \item{values}{Determines style and position of percentage value labels on the bars:
@@ -104,7 +115,7 @@ group or category to the labels.}
 \item{show.legend}{logical, if \code{TRUE}, and depending on plot type and
 function, a legend is added to the plot.}
 
-\item{show.prc.sign}{Logical, if \code{TRUE}, \%-signs for value labels are shown.}
+\item{show.prc.sign}{logical, if \code{TRUE}, \%-signs for value labels are shown.}
 
 \item{grid.range}{Numeric, limits of the x-axis-range, as proportion of 100.
 Default is 1, so the x-scale ranges from zero to 100\% on both sides from the center.
@@ -122,9 +133,20 @@ axes and plotting region. Default is \code{FALSE}.}
 \item{digits}{Numeric, amount of digits after decimal point when rounding
 estimates or values.}
 
-\item{reverse.scale}{Logical, if \code{TRUE}, the ordering of the categories is reversed, so positive and negative values switch position.}
+\item{reverse.scale}{logical, if \code{TRUE}, the ordering of the categories is reversed, so positive and negative values switch position.}
 
 \item{coord.flip}{logical, if \code{TRUE}, the x and y axis are swapped.}
+
+\item{sort.groups}{(optional, only used if groups are supplied) logical, if groups should be sorted according to the values supplied to \code{factor.groups}. Defaults to \code{TRUE}.}
+
+\item{legend.pos}{(optional, only used if groups are supplied) Defines the legend position. Possible values are \code{c(""bottom"", ""top"", ""both"", ""all"", ""none"")}. 
+If the is only one group or this option is set to \code{""all""} legends will be printed as defined with \code{\link{set_theme}}.}
+
+\item{rel_heights}{(optional, only used if groups are supplied) This option can be used to adjust the height of the subplots. The bars in subplots can have different heights due to a differing number of items 
+or due to legend placement. This can be adjusted here. 
+Takes a vector of numbers, one for each plot. Values are evaluated relative to each other.}
+
+\item{cowplot.options}{(optional, only used if groups are supplied) List of label options to be passed to \code{\link[cowplot]{plot_grid}}.}
 }
 \value{
 A ggplot-object.
@@ -148,14 +170,33 @@ library(sjmisc)
 data(efc)
 # find all variables from COPE-Index, which all have a ""cop"" in their
 # variable name, and then plot that subset as likert-plot
-find_var(efc, pattern = ""cop"", out = ""df"") \%>\% plot_likert()
+mydf <- find_var(efc, pattern = ""cop"", out = ""df"")
+
+plot_likert(mydf)
 
 plot_likert(
-  find_var(efc, pattern = ""cop"", out = ""df""),
+  mydf,
   grid.range = c(1.2, 1.4),
   expand.grid = FALSE,
   values = ""sum.outside"",
   show.prc.sign = TRUE
+  
+# Plot in groups
+
+plot_likert(mydf, c(2,1,1,1,1,2,2,2,1))
+
+factor.groups <- sjt.pca(mydf)$factor.index
+plot_likert(mydf, c(2,1,1,1,1,2,2,2,1), factor.groups = factor.groups)
+
+plot_likert(mydf, 
+            c(rep(""B"",4),rep(""A"",5)), 
+            sort.groups = F, 
+            grid.range = c(0.9,1.1), 
+            geom.colors = ""RdBu"", 
+            rel_heights = c(6,8), 
+            wrap.labels = 40, 
+            reverse.scale=T)   
+
 )
 
 }

---FILE: man/plot_likert_grp.Rd---
@@ -1,67 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/plot_likert_grp.R
-\name{plot_likert_grp}
-\alias{plot_likert_grp}
-\title{Plot likert scales as centered stacked bars in groups}
-\usage{
-plot_likert_grp(items, factor.groups, factor.groups.titles = ""auto"",
-  sort.groups = TRUE, legend.pos = ""bottom"", rel_heights = 1,
-  title = NULL, label_x = 0.01, hjust = 0, align = ""v"",
-  label_size = 14, label_fontfamily = NULL, label_fontface = ""bold"",
-  label_colour = NULL, label_y = 1, vjust = 1.5, ...)
-}
-\arguments{
-\item{items}{Data frame, with each column representing one item.}
-
-\item{factor.groups}{Must be a vector of same length as \code{ncol(df)}, 
-where each item in this vector represents the group number 
-of the related columns of \code{df}. See 'Examples'.}
-
-\item{factor.groups.titles}{Titles for each factor group that will be used as table caption for each
-component-table. Must be a character vector of same length as \code{length(unique(factor.groups))}.
-Default is \code{""auto""}, which means that each table has a standard caption \emph{Component x}.
-Use \code{NULL} to use names as supplied to \code{factor.groups} and use \code{FALSE} to suppress table captions.}
-
-\item{sort.groups}{If groups should be sorted according to the values supplied to \code{factor.groups}. Defaults to \code{TRUE}.}
-
-\item{legend.pos}{Defines the legend position. Possible values are \code{c(""bottom"", ""top"", ""all"", ""none"")}. 
-\code{""all""} will print legends as defined with \code{\link{set_theme}}.}
-
-\item{rel_heights}{This option can be used to adjust the height of the subplots. The bars in subplots can have different heights due to a differing number of items 
-or due to legend placement. This can be adjusted here. 
-Takes a vector of numbers, one for each plot. Values are evaluated relative to each other.}
-
-\item{title}{character vector, used as plot title. Depending on plot type and function,
-will be set automatically. If \code{title = """"}, no title is printed.
-For effect-plots, may also be a character vector of length > 1,
-to define titles for each sub-plot or facet.}
-
-\item{label_x, hjust, align, label_size, label_fontfamily, label_fontface, label_colour, label_y, vjust}{Label options. See \code{\link[cowplot]{plot_grid}}.}
-
-\item{...}{Extra arguments to be passed to \code{\link{plot_likert}}.}
-}
-\description{
-Plot likert scales as centered stacked bars in groups
-}
-\examples{
-library(sjmisc)
-data(efc)
-# find all variables from COPE-Index, which all have a ""cop"" in their
-# variable name, and then plot that subset as likert-plot
-mydf <- find_var(efc, pattern = ""cop"", out = ""df"")
-
-plot_likert_grp(mydf, c(2,1,1,1,1,2,2,2,1))
-
-factor.groups <- sjt.pca(mydf)$factor.index
-plot_likert_grp(mydf, c(2,1,1,1,1,2,2,2,1), factor.groups = factor.groups)
-
-plot_likert_grp(mydf, 
-                c(rep(""B"",4),rep(""A"",5)), 
-                sort.groups = F, 
-                grid.range = c(0.9,1.1), 
-                geom.colors = ""RdBu"", 
-                rel_heights = c(6,8), 
-                wrap.labels = 40, 
-                reverse.scale=T)
-
-}"
strengejacke,sjPlot,aa1c984be4a932a488c8332501ed75c930325c8a,Daniel,mail@danielluedecke.de,2019-03-11T07:27:33Z,Daniel,mail@danielluedecke.de,2019-03-11T07:27:33Z,Fixed encoding issues with help-files.,NEWS.md;R/plot_model.R;man/plot_model.Rd,False,True,True,False,3,2,5,"---FILE: NEWS.md---
@@ -14,6 +14,7 @@
 
 * Legend labels were inverted for **brms**-models in `plot_model(..., type = ""diag"")`.
 * Legend labels were duplicated for marginal effects plots when `color =""bw""` and `legend.title` was specified.
+* Fixed encoding issues with help-files.
 
 # sjPlot 2.6.2
 

---FILE: R/plot_model.R---
@@ -380,7 +380,7 @@
 #'
 #' @references
 #'   Gelman A (2008) ""Scaling regression inputs by dividing by two
-#'   standard deviations."" \emph{Statistics in Medicine 27: 28652873.}
+#'   standard deviations."" \emph{Statistics in Medicine 27: 2865-2873.}
 #'   \url{http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf}
 #'   \cr \cr
 #'   Aiken and West (1991). Multiple Regression: Testing and Interpreting Interactions.

---FILE: man/plot_model.Rd---
@@ -516,7 +516,7 @@ if (require(""rstanarm"")) {
 }
 \references{
 Gelman A (2008) ""Scaling regression inputs by dividing by two
-  standard deviations."" \emph{Statistics in Medicine 27: 28652873.}
+  standard deviations."" \emph{Statistics in Medicine 27: 2865-2873.}
   \url{http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf}
   \cr \cr
   Aiken and West (1991). Multiple Regression: Testing and Interpreting Interactions."
strengejacke,sjPlot,2014655125a1bbacb3be0a76a0c8d5af49112f65,Daniel,mail@danielluedecke.de,2019-03-05T21:12:01Z,Daniel,mail@danielluedecke.de,2019-03-05T21:12:01Z,fix dplyr issues,NAMESPACE;R/sjplot.R,False,True,True,False,5,4,9,"---FILE: NAMESPACE---
@@ -86,6 +86,7 @@ importFrom(dplyr,case_when)
 importFrom(dplyr,filter)
 importFrom(dplyr,full_join)
 importFrom(dplyr,group_by)
+importFrom(dplyr,group_vars)
 importFrom(dplyr,if_else)
 importFrom(dplyr,inner_join)
 importFrom(dplyr,mutate)

---FILE: R/sjplot.R---
@@ -225,7 +225,7 @@ get_grouped_plottitle <- function(x, grps, i, sep = ""\n"") {
   title <- sprintf(""%s: %s"", tp[1], tp[2])
 
   # do we have another groupng variable?
-  if (length(attr(x, ""vars"", exact = T)) > 1) {
+  if (length(dplyr::group_vars(x)) > 1) {
     # prepare title for group
     tp <- get_title_part(x, grps, 2, i)
     title <- sprintf(""%s%s%s: %s"", title, sep, tp[1], tp[2])
@@ -241,7 +241,7 @@ get_grouped_title <- function(x, grps, args, i, sep = ""\n"") {
   title <- sprintf(""%s: %s"", tp[1], tp[2])
 
   # do we have another groupng variable?
-  if (length(attr(x, ""vars"", exact = T)) > 1) {
+  if (length(dplyr::group_vars(x)) > 1) {
     # prepare title for group
     tp <- get_title_part(x, grps, 2, i)
     title <- sprintf(""%s%s%s: %s"", title, sep, tp[1], tp[2])
@@ -277,7 +277,7 @@ get_title_part <- function(x, grps, level, i) {
 
 
 #' @importFrom rlang .data
-#' @importFrom dplyr select filter
+#' @importFrom dplyr select filter group_vars
 #' @importFrom stats complete.cases
 #'
 get_grouped_data <- function(x) {
@@ -292,7 +292,7 @@ get_grouped_data <- function(x) {
   grps <- grps %>% dplyr::filter(!! cc)
 
   # arrange data
-  if (length(attr(x, ""vars"", exact = T)) == 1)
+  if (length(dplyr::group_vars(x)) == 1)
     reihe <- order(grps[[1]])
   else
     reihe <- order(grps[[1]], grps[[2]])"
strengejacke,sjPlot,6d2d29ea9ac135ad4f5158c182c6cd03fb163fa1,Daniel,mail@danielluedecke.de,2019-03-03T20:52:51Z,Daniel,mail@danielluedecke.de,2019-03-03T20:52:51Z,fix docs,R/sjTabPCA.R;man/sjp.pca.Rd;man/sjt.pca.Rd,False,True,True,False,9,6,15,"---FILE: R/sjTabPCA.R---
@@ -9,8 +9,9 @@
 #'                reliability test. The result is an alpha value for each factor dimension.
 #'
 #' @param data A data frame that should be used to compute a PCA, or a \code{\link{prcomp}} object.
-#' @param rotation Rotation of the factor loadings. May be \code{""varimax""} for orthogonal rotation
-#'          or \code{""oblimin""} for oblique transformation.
+#' @param rotation Rotation of the factor loadings. May be one of
+#'    \code{""varimax"", ""quartimax"", ""promax"", ""oblimin"", ""simplimax"", ""cluster""}
+#'    or \code{""none""}.
 #' @param nmbr.fctr Number of factors used for calculating the rotation. By
 #'          default, this value is \code{NULL} and the amount of factors is
 #'          calculated according to the Kaiser-criteria.

---FILE: man/sjp.pca.Rd---
@@ -14,8 +14,9 @@ sjp.pca(data, rotation = c(""varimax"", ""quartimax"", ""promax"", ""oblimin"",
 \arguments{
 \item{data}{A data frame that should be used to compute a PCA, or a \code{\link{prcomp}} object.}
 
-\item{rotation}{Rotation of the factor loadings. May be \code{""varimax""} for orthogonal rotation
-or \code{""oblimin""} for oblique transformation.}
+\item{rotation}{Rotation of the factor loadings. May be one of
+\code{""varimax"", ""quartimax"", ""promax"", ""oblimin"", ""simplimax"", ""cluster""}
+or \code{""none""}.}
 
 \item{nmbr.fctr}{Number of factors used for calculating the rotation. By
 default, this value is \code{NULL} and the amount of factors is

---FILE: man/sjt.pca.Rd---
@@ -16,8 +16,9 @@ sjt.pca(data, rotation = c(""varimax"", ""quartimax"", ""promax"", ""oblimin"",
 \arguments{
 \item{data}{A data frame that should be used to compute a PCA, or a \code{\link{prcomp}} object.}
 
-\item{rotation}{Rotation of the factor loadings. May be \code{""varimax""} for orthogonal rotation
-or \code{""oblimin""} for oblique transformation.}
+\item{rotation}{Rotation of the factor loadings. May be one of
+\code{""varimax"", ""quartimax"", ""promax"", ""oblimin"", ""simplimax"", ""cluster""}
+or \code{""none""}.}
 
 \item{nmbr.fctr}{Number of factors used for calculating the rotation. By
 default, this value is \code{NULL} and the amount of factors is"
strengejacke,sjPlot,5342263d3310d5ae4707a3dea35ebf01b57687ce,Daniel,mail@danielluedecke.de,2019-01-27T12:20:50Z,Daniel,mail@danielluedecke.de,2019-01-27T12:20:50Z,fix issue with single r2-values,R/html_print.R,False,True,True,False,1,1,2,"---FILE: R/html_print.R---
@@ -633,7 +633,7 @@ tab_model_df <- function(x,
     for (i in 1:length(rsq.list)) {
       if (!is.null(rsq.list[[i]])) {
         rname <- names(rsq.list[[i]][[1]])
-        if (length(rsq.list[[i]] > 1))
+        if (length(rsq.list[[i]]) > 1)
           rname <- sprintf(""%s / %s"", rname, names(rsq.list[[i]][[2]]))
         break
       }"
strengejacke,sjPlot,5cfdbd71dbb1aad957ca0fa44d80d7a6a54b4553,Daniel,mail@danielluedecke.de,2018-12-20T18:30:20Z,Daniel,mail@danielluedecke.de,2018-12-20T18:30:20Z,fix issue with inverted legend labels,DESCRIPTION;NEWS.md;R/plot_diag_stan.R;R/plot_gpt.R,False,True,True,False,22,16,38,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 2.6.2
+Version: 2.6.2.9000
 Date: 2018-12-18
 Authors@R: c(
     person(""Daniel"", ""Ldecke"", email = ""d.luedecke@uke.de"", role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0002-8895-3206"")),

---FILE: NEWS.md---
@@ -1,3 +1,9 @@
+# sjPlot 2.6.3
+
+## Bug fixes
+
+* Legend labels were inverted for **brms**-models in `plot_model(..., type = ""diag"")`.
+
 # sjPlot 2.6.2
 
 ## General

---FILE: R/plot_diag_stan.R---
@@ -19,29 +19,29 @@ plot_diag_stan <- function(model, geom.colors, axis.lim, facets, axis.labels, ..
 
     # check if prior sample are available
 
-    d1 <- brms::prior_samples(model)
+    d2 <- brms::prior_samples(model)
 
-    if (is.null(d1))
+    if (is.null(d2))
       stop(""No prior-samples found. Please use option `sample_prior = TRUE` when fitting the model."", call. = FALSE)
 
 
     # get samples from posterior and prior
 
-    d1 <- dplyr::select(
-      d1,
-      string_starts_with(""b_"", colnames(d1)),
-      -string_starts_with(""b_Intercept"", colnames(d1))
-    )
-
-
-    d2 <- brms::posterior_samples(model)
-
     d2 <- dplyr::select(
       d2,
       string_starts_with(""b_"", colnames(d2)),
       -string_starts_with(""b_Intercept"", colnames(d2))
     )
 
+
+    d1 <- brms::posterior_samples(model)
+
+    d1 <- dplyr::select(
+      d1,
+      string_starts_with(""b_"", colnames(d1)),
+      -string_starts_with(""b_Intercept"", colnames(d1))
+    )
+
   } else if (inherits(model, c(""stanreg"", ""stanfit""))) {
 
     # check if rstanarm can be loaded

---FILE: R/plot_gpt.R---
@@ -229,8 +229,8 @@ gpt_helper <- function(
 
   # final data frame for plot
   newdf <- data.frame()
-  group.p <- c()
-  group.n <- c()
+  group.p <- character()
+  group.n <- character()
 
   # create data frame, for dplyr-chain
   mydf <-
@@ -261,11 +261,11 @@ gpt_helper <- function(
     dplyr::summarise(N = n(), p = suppressWarnings(stats::chisq.test(table(.data$xpos, .data$dep))$p.value))
 
   # copy p values
-  for (i in seq_len(length(pvals$grp))) group.p <- c(group.p, get_p_stars(pvals$p[i]))
+  for (i in seq_len(length(pvals$grp))) group.p[i] <- get_p_stars(pvals$p[i])
 
   # copy N
   for (i in seq_len(length(pvals$grp)))
-    group.n <- c(group.n, prettyNum(pvals$N[i], big.mark = "","", scientific = F))
+    group.n[i] <- prettyNum(pvals$N[i], big.mark = "","", scientific = F)
 
   # if we want total line, repeat all for
   # complete data frame"
strengejacke,sjPlot,6d430c93aee8b57a985ea34dcdc33bbc7fcd93ba,Daniel,mail@danielluedecke.de,2018-11-16T21:23:14Z,Daniel,mail@danielluedecke.de,2018-11-16T21:23:14Z,fix #258,DESCRIPTION;NEWS.md;R/plot_type_int.R,False,True,True,False,6,4,10,"---FILE: DESCRIPTION---
@@ -42,8 +42,8 @@ Imports:
     rlang,
     scales,
     sjlabelled (>= 1.0.14),
-    sjmisc (>= 2.7.5),
-    sjstats (>= 0.17.1),
+    sjmisc (>= 2.7.6),
+    sjstats (>= 0.17.2),
     tidyr (>= 0.7.0)
 Suggests:
     AICcmodavg,
@@ -62,5 +62,5 @@ Suggests:
     testthat
 URL: https://strengejacke.github.io/sjPlot/
 BugReports: https://github.com/strengejacke/sjPlot/issues
-RoxygenNote: 6.1.0
+RoxygenNote: 6.1.1
 VignetteBuilder: knitr

---FILE: NEWS.md---
@@ -19,6 +19,7 @@ Following functions are now defunct:
 * `plot_model()` does no longer automatically change the plot-type to `""slope""` for models with only one predictor that is categorical and has more than two levels.
 * `type = ""eff""` and `type = ""pred""` in `plot_model()` did not when `terms` was not specified. 
 * If robust standard errors are requested in `tab_model()`, the confidence intervals and p-values are now re-calculated and adjusted based on the robust standard errors.
+* `colors = ""bw""` was not recognized correctly for `plot_model(..., type = ""int"")`.
 
 # sjPlot 2.6.1
 

---FILE: R/plot_type_int.R---
@@ -135,7 +135,8 @@ plot_type_int <- function(model,
 
 
     # select color palette
-    geom.colors <- col_check2(geom.colors, dplyr::n_distinct(dat$group))
+    if (is.null(geom.colors) || geom.colors[1] != ""bw"")
+      geom.colors <- col_check2(geom.colors, dplyr::n_distinct(dat$group))
 
 
     # save plot of marginal effects for interaction terms"
strengejacke,sjPlot,b88a8c6d397d13e701b18bb4f5f2c34595558454,Daniel,mail@danielluedecke.de,2018-11-06T19:49:43Z,Daniel,mail@danielluedecke.de,2018-11-06T19:49:43Z,fix issues with tryCatch,R/plot_model.R;R/tab_model.R;R/tidiers.R;R/utils.R,False,True,True,False,27,9,36,"---FILE: R/plot_model.R---
@@ -794,7 +794,9 @@ get_model_data <- function(model,
 
 one_par <- function(model) {
   tryCatch(
-    length(stats::coef(model)) <= 2,
+    {
+      length(stats::coef(model)) <= 2
+    },
     error = function(x) { FALSE }
   )
 }

---FILE: R/tab_model.R---
@@ -556,7 +556,9 @@ tab_model <- function(
 
       if (show.obs) {
         n_obs <- tryCatch(
-          stats::nobs(model),
+          {
+            stats::nobs(model)
+          },
           error = function(x) { NULL }
         )
       }
@@ -568,7 +570,9 @@ tab_model <- function(
 
       if ((show.icc || show.re.var) && is_mixed_model(model)) {
         icc <- tryCatch(
-          suppressWarnings(sjstats::icc(model)),
+          {
+            suppressWarnings(sjstats::icc(model))
+          },
           error = function(x) { NULL }
         )
       }
@@ -580,7 +584,9 @@ tab_model <- function(
 
       if ((show.adj.icc) && is_mixed_model(model)) {
         icc.adjusted <- tryCatch(
-          sjstats::icc(model, adjusted = TRUE, type = ""all""),
+          {
+            sjstats::icc(model, adjusted = TRUE, type = ""all"")
+          },
           error = function(x) { NULL }
         )
       }
@@ -598,7 +604,9 @@ tab_model <- function(
           rsq <- icc.adjusted[[1]]
         } else {
           rsq <- tryCatch(
-            suppressWarnings(sjstats::r2(model)),
+            {
+              suppressWarnings(sjstats::r2(model))
+            },
             error = function(x) { NULL }
           )
         }

---FILE: R/tidiers.R---
@@ -100,7 +100,9 @@ tidy_generic <- function(model, ci.lvl, facets, p.val) {
 
     if (is_merMod(model) && !is.null(p.val) && p.val == ""kr"") {
       pv <- tryCatch(
-        suppressMessages(sjstats::p_value(model, p.kr = TRUE)),
+        {
+          suppressMessages(sjstats::p_value(model, p.kr = TRUE))
+        },
         error = function(x) { NULL }
       )
 
@@ -118,7 +120,9 @@ tidy_generic <- function(model, ci.lvl, facets, p.val) {
       # see if we have p-values. if not, add them
       if (!obj_has_name(dat, ""p.value""))
         dat$p.value <- tryCatch(
-          sjstats::p_value(model, p.kr = FALSE)[[""p.value""]],
+          {
+            sjstats::p_value(model, p.kr = FALSE)[[""p.value""]]
+          },
           error = function(x) { NA }
         )
     }

---FILE: R/utils.R---
@@ -318,7 +318,9 @@ is_empty_list <- function(x) {
 
 model_deviance <- function(x) {
   tryCatch(
-    m_deviance(x),
+    {
+      m_deviance(x)
+    },
     error = function(x) { NULL }
   )
 }
@@ -327,7 +329,9 @@ model_deviance <- function(x) {
 #' @importFrom stats AIC
 model_aic <- function(x) {
   tryCatch(
-    stats::AIC(x),
+    {
+      stats::AIC(x)
+    },
     error = function(x) { NULL }
   )
 }"
strengejacke,sjPlot,e953006af7164e3d5fdfa10fa31194d5c40f0c51,Daniel,mail@danielluedecke.de,2018-11-02T17:31:51Z,Daniel,mail@danielluedecke.de,2018-11-02T17:31:51Z,"If robust standard errors are requested in `tab_model()`, the confidence intervals and p-values are now re-calculated and adjusted based on the robust standard errors.",NEWS.md;R/tidiers.R,False,True,True,False,17,1,18,"---FILE: NEWS.md---
@@ -14,6 +14,7 @@ Following functions are now defunct:
 
 * `plot_model()` does no longer automatically change the plot-type to `""slope""` for models with only one predictor that is categorical and has more than two levels.
 * `type = ""eff""` and `type = ""pred""` in `plot_model()` did not when `terms` was not specified. 
+* If robust standard errors are requested in `tab_model()`, the confidence intervals and p-values are now re-calculated and adjusted based on the robust standard errors.
 
 # sjPlot 2.6.1
 

---FILE: R/tidiers.R---
@@ -2,9 +2,24 @@ tidy_model <- function(model, ci.lvl, tf, type, bpe, se, facets, show.zeroinf, p
   dat <- get_tidy_data(model, ci.lvl, tf, type, bpe, facets, show.zeroinf, p.val, ...)
 
   # get robust standard errors, if requestes, and replace former s.e.
-  if (!is.null(se) && !is.logical(se)) {
+
+  if (!is.null(se) && !is.logical(se) && obj_has_name(dat, ""std.error"")) {
     std.err <- sjstats::robust(model, vcov.type = se)
     dat[[""std.error""]] <- std.err[[""std.error""]]
+
+    # also fix CI and p-value after robust SE
+
+    if (!is.null(ci.lvl) && !is.na(ci.lvl))
+      ci <- 1 - ((1 - ci.lvl) / 2)
+    else
+      ci <- .975
+
+    dat$conf.low <- dat$estimate - stats::qnorm(ci) * dat$std.error
+    dat$conf.high <- dat$estimate + stats::qnorm(ci) * dat$std.error
+
+    if (obj_has_name(dat, ""p.value"")) {
+      dat$p.value <- 2 * stats::pnorm(abs(dat$estimate / dat$std.error), lower.tail = FALSE)
+    }
   }
 
   dat"
strengejacke,sjPlot,dea62d113c473ee2062033bdc34ea1ab1686454c,Daniel,mail@danielluedecke.de,2018-08-29T17:03:43Z,Daniel,mail@danielluedecke.de,2018-08-29T17:03:43Z,Fixed bug from the last update that made value labels disappear for `plot_likert()`.,NEWS.md;R/plot_likert.R,False,True,True,False,5,1,6,"---FILE: NEWS.md---
@@ -12,6 +12,10 @@
 
 * Arguments `dot.size` and `line.size` in `plot_model()` now also apply to marginal effects and diagnostic plots.
 
+## Bug fixes
+
+* Fixed bug from the last update that made value labels disappear for `plot_likert()`.
+
 # sjPlot 2.6.0
 
 ## General

---FILE: R/plot_likert.R---
@@ -560,7 +560,7 @@ plot_likert <- function(items,
         )
       ) +
       geom_text(
-        data = dplyr::filter(mydat.pos, .data$frq < 0),
+        data = dplyr::filter(mydat.neg, .data$frq < 0),
         aes(
           x = .data$x,
           y = .data$ypos,"
strengejacke,sjPlot,913b7d0ab99262fdca03a45d93972efb0a8ae9d5,Daniel,mail@danielluedecke.de,2018-08-22T07:23:27Z,Daniel,mail@danielluedecke.de,2018-08-22T07:23:27Z,"fix CHECK issues, remove globalVariables",R/sjPlotCorr.R;R/sjPlotFrequencies.R;R/sjPlotPCA.R;R/sjPlotPolynomials.R;R/sjPlotxtab.R;man/sjp.poly.Rd,False,True,True,False,10,13,23,"---FILE: R/sjPlotCorr.R---
@@ -1,6 +1,3 @@
-# bind global variables
-utils::globalVariables(c(""ordx"", ""ordy""))
-
 #' @title Plot correlation matrix
 #' @name sjp.corr
 #'

---FILE: R/sjPlotFrequencies.R---
@@ -1,7 +1,3 @@
-# bind global variables
-utils::globalVariables(c(""val"", ""frq"", ""grp"", ""label.pos"", ""upper.ci"", ""lower.ci"", ""..density..""))
-
-
 #' @title Plot frequencies of variables
 #' @name sjp.frq
 #'

---FILE: R/sjPlotPCA.R---
@@ -122,7 +122,7 @@ sjp.pca <- function(data,
     # plot eigenvalues as line curve
     eigenplot <-
       # indicate eigen vlaues > 1
-      ggplot(mydat, aes(x = xpos, y = eigen, colour = eigen > 1)) +
+      ggplot(mydat, aes(x = .data$xpos, y = .data$eigen, colour = .data$eigen > 1)) +
         geom_line() + geom_point() +
         geom_hline(yintercept = 1, linetype = 2, colour = ""grey50"") +
         # print best number of factors according to eigen value
@@ -269,9 +269,9 @@ sjp.pca <- function(data,
   # start with base plot object here
   # --------------------------------------------------------
   if (type == ""bar"") {
-    heatmap <- ggplot(df, aes(x = rev(factor(ypos)), y = abs(value), fill = value))
+    heatmap <- ggplot(df, aes(x = rev(factor(.data$ypos)), y = abs(.data$value), fill = .data$value))
   } else {
-    heatmap <- ggplot(data = df, aes(x = xpos, y = ypos, fill = value))
+    heatmap <- ggplot(data = df, aes(x = .data$xpos, y = .data$ypos, fill = .data$value))
   }
   # --------------------------------------------------------
   # determine the geom type, either points when ""type"" is ""circles""

---FILE: R/sjPlotPolynomials.R---
@@ -30,8 +30,13 @@
 #' @param show.p Logical, if \code{TRUE} (default), p-values for polynomial terms are
 #'          printed to the console.
 #' @param loess.color Color of the loess-smoothed line. Only applies, if \code{show.loess = TRUE}.
+#' @param show.scatter
+#' @param point.alpha
+#' @param point.color
+#'
 #' @return A ggplot-object.
 #'
+#'
 #' @inheritParams plot_model
 #' @inheritParams plot_scatter
 #' @inheritParams sjp.grpfrq

---FILE: R/sjPlotxtab.R---
@@ -1,6 +1,3 @@
-# bind global variables
-utils::globalVariables(c(""prc"",""ges"", ""n"", ""Count"", ""Group"", ""line.break""))
-
 #' @title Plot contingency tables
 #' @name sjp.xtab
 #'

---FILE: man/sjp.poly.Rd---
@@ -55,6 +55,8 @@ will be plotted.}
 \item{show.p}{Logical, if \code{TRUE} (default), p-values for polynomial terms are
 printed to the console.}
 
+\item{point.color}{}
+
 \item{loess.color}{Color of the loess-smoothed line. Only applies, if \code{show.loess = TRUE}.}
 }
 \value{"
strengejacke,sjPlot,95c580dafcd77cc190accb7135b3ce07cd245557,Daniel,mail@danielluedecke.de,2018-08-21T21:36:05Z,Daniel,mail@danielluedecke.de,2018-08-21T21:36:05Z,fix NAMESPACE,NAMESPACE;R/sjPlotKfoldCV.R;R/sjTabLinReg.R;R/sjplot.R,False,True,True,False,8,8,16,"---FILE: NAMESPACE---
@@ -101,12 +101,10 @@ importFrom(dplyr,case_when)
 importFrom(dplyr,filter)
 importFrom(dplyr,full_join)
 importFrom(dplyr,group_by)
-importFrom(dplyr,group_by_)
 importFrom(dplyr,if_else)
 importFrom(dplyr,inner_join)
 importFrom(dplyr,mutate)
 importFrom(dplyr,n_distinct)
-importFrom(dplyr,rename_)
 importFrom(dplyr,select)
 importFrom(dplyr,select_)
 importFrom(dplyr,slice)

---FILE: R/sjPlotKfoldCV.R---
@@ -46,7 +46,7 @@
 #'
 #' @import ggplot2
 #' @importFrom modelr crossv_kfold
-#' @importFrom dplyr mutate group_by_ ungroup summarise
+#' @importFrom dplyr mutate ungroup summarise
 #' @importFrom purrr map map2
 #' @importFrom broom augment
 #' @importFrom tidyr unnest

---FILE: R/sjTabLinReg.R---
@@ -122,7 +122,7 @@
 #'            }
 #'
 #'
-#' @importFrom dplyr full_join slice bind_cols select_ rename_
+#' @importFrom dplyr full_join slice bind_cols select_
 #' @importFrom stats nobs AIC confint coef deviance runif
 #' @importFrom lme4 VarCorr
 #' @importFrom sjstats std_beta icc r2 cod chisq_gof hoslem_gof p_value robust
@@ -330,9 +330,11 @@ sjt.lm <- function(...,
       fit.df,
       sbvals %>%
         dplyr::select_(""-term"") %>%
-        dplyr::rename_(""std.conf.low"" = ""conf.low"",
-                       ""std.conf.high"" = ""conf.high"",
-                       ""std.std.error"" = ""std.error"")
+        sjmisc::var_rename(
+          ""std.conf.low"" = ""conf.low"",
+          ""std.conf.high"" = ""conf.high"",
+          ""std.std.error"" = ""std.error""
+        )
       )
     # -------------------------------------
     # formate values

---FILE: R/sjplot.R---
@@ -84,7 +84,7 @@
 #'
 #' @importFrom sjmisc is_empty
 #' @importFrom sjlabelled copy_labels get_label get_labels
-#' @importFrom dplyr select_ filter
+#' @importFrom dplyr filter
 #' @importFrom tidyr nest
 #' @importFrom stats complete.cases
 #' @export"
strengejacke,sjPlot,eb4ddd1da85baa1d202b1289b2904a94c1509953,Daniel,mail@danielluedecke.de,2018-08-21T21:18:18Z,Daniel,mail@danielluedecke.de,2018-08-21T21:18:18Z,fix,R/S3-methods.R,False,True,True,False,1,1,2,"---FILE: R/S3-methods.R---
@@ -459,7 +459,7 @@ pfrq <- function(x, ...) {
     else
       vt <- """"
 
-    if (!is.null(lab)) ret <- sprintf(""%s"", lab, vt)
+    if (!is.null(lab)) ret <- sprintf(""%s%s"", lab, vt)
 
     # get grouping title label
     grp <- attr(i, ""group"", exact = T)"
strengejacke,sjPlot,dc948accb7148af379fd3b8466db97b0cfaad17b,Daniel,mail@danielluedecke.de,2018-08-21T21:02:57Z,Daniel,mail@danielluedecke.de,2018-08-21T21:02:57Z,minor fixes,NAMESPACE;R/S3-methods.R;R/select_helpers.R,False,True,True,False,9,4,13,"---FILE: NAMESPACE---
@@ -283,9 +283,7 @@ importFrom(stats,vcov)
 importFrom(stats,weighted.mean)
 importFrom(stats,wilcox.test)
 importFrom(stats,xtabs)
-importFrom(tibble,add_case)
 importFrom(tibble,add_column)
-importFrom(tibble,as_tibble)
 importFrom(tibble,has_name)
 importFrom(tibble,rownames_to_column)
 importFrom(tibble,tibble)

---FILE: R/S3-methods.R---
@@ -441,6 +441,7 @@ pgdescr <- function(x, ...) {
 
 #' @importFrom purrr map_if map_chr map
 #' @importFrom dplyr n_distinct select
+#' @importFrom sjmisc is_empty
 pfrq <- function(x, ...) {
   uv <- attr(x, ""print"", exact = TRUE) == ""viewer""
 
@@ -452,7 +453,13 @@ pfrq <- function(x, ...) {
     lab <- attr(i, ""label"", exact = T)
     vt <- attr(i, ""vartype"", exact = T)
 
-    if (!is.null(lab)) ret <- sprintf(""%s <span style=\""font-weight: normal; font-style: italic\"">&lt;%s&gt;</span>"", lab, vt)
+    # fix variable type string
+    if (!sjmisc::is_empty(vt))
+      vt <- sprintf("" <span style=\""font-weight: normal; font-style: italic\"">&lt;%s&gt;</span>"", vt)
+    else
+      vt <- """"
+
+    if (!is.null(lab)) ret <- sprintf(""%s"", lab, vt)
 
     # get grouping title label
     grp <- attr(i, ""group"", exact = T)

---FILE: R/select_helpers.R---
@@ -79,7 +79,7 @@ add_cases <- function(data, ..., .after = -1, .before = NULL) {
   else if (is.infinite(.after))
     o <- 1:last.row
   else
-    o <- c(1:.after, last.row, (.after + 1):(last.row) - 1)
+    o <- c(1:.after, last.row, (.after + 1):(last.row - 1))
 
   x[o, , drop = FALSE]
 }"
strengejacke,sjPlot,96ca77995904fc320b45ae9ecaefe16d7ef253d5,Daniel,mail@danielluedecke.de,2018-08-14T20:50:26Z,Daniel,mail@danielluedecke.de,2018-08-14T20:50:26Z,fix issue with incorrect closing HTML-tag,R/html_print.R,False,True,True,False,1,1,2,"---FILE: R/html_print.R---
@@ -686,7 +686,7 @@ tab_model_df <- function(x,
 
   # surround output with table-tag ----
 
-  page.content <- paste0(""<table>\n"", table.caption, page.content, ""\n<table>\n"")
+  page.content <- paste0(""<table>\n"", table.caption, page.content, ""\n</table>\n"")
 
   # create HTML page with header information
   page.complete <- tab_create_page("
strengejacke,sjPlot,d56d95b536a730a854471cde35123487a521d062,Daniel,mail@danielluedecke.de,2018-08-14T17:06:00Z,Daniel,mail@danielluedecke.de,2018-08-14T17:06:00Z,fix issue,R/tab_model.R,False,True,True,False,2,6,8,"---FILE: R/tab_model.R---
@@ -691,13 +691,9 @@ tab_model <- function(
   # get default labels for dv and terms ----
 
   if (isTRUE(auto.label) && sjmisc::is_empty(pred.labels)) {
-    ## TODO fix in sjlabelled
-    pred.labels <- sjlabelled::get_term_labels(models, case = case)
-    pred.cat <- sjlabelled::get_term_labels(models, mark.cat = TRUE)
+    pred.labels <- sjlabelled::get_term_labels(models, case = case, mark.cat = TRUE)
     no.dupes <- !duplicated(names(pred.labels))
-    pred.labels <- pred.labels[no.dupes]
-    attr(pred.labels, ""category.value"") <- attr(pred.cat, ""category.value"")[no.dupes]
-    pred.labels <- prepare.labels(pred.labels, grp = group.terms)
+    pred.labels <- prepare.labels(pred.labels[no.dupes], grp = group.terms)
   } else {
     # no automatic grouping of table rows for categorical variables
     # when user supplies own labels"
strengejacke,sjPlot,4836ebb0dd5ec95723d7988ec9c979a25849d8cf,Daniel,mail@danielluedecke.de,2018-08-12T12:00:34Z,Daniel,mail@danielluedecke.de,2018-08-12T12:00:34Z,fix CHECK issues,R/sjPlotAnova.R;R/sjPlotLikert.R;R/sjPlotPolynomials.R;R/sjPlotResiduals.R;R/sjPlotStackFrequencies.R;R/sjTabLinReg.R;man/sjp.aov1.Rd;man/sjp.likert.Rd;man/sjp.poly.Rd;man/sjp.resid.Rd;man/sjp.stackfrq.Rd;man/sjt.lm.Rd,False,True,True,False,46,60,106,"---FILE: R/sjPlotAnova.R---
@@ -10,7 +10,7 @@
 #'          \code{aov(var.dep ~ var.grp)}
 #' @param var.grp Factor with the cross-classifying variable, where \code{var.dep}
 #'          is grouped into the categories represented by \code{var.grp}.
-#' @param meansums Logical, if \code{TRUE}, the values reported are the true group mean values (see also \code{\link{sjt.grpmean}}).
+#' @param meansums Logical, if \code{TRUE}, the values reported are the true group mean values.
 #'          If \code{FALSE} (default), the values are reported in the standard way, i.e. the values indicate the difference of
 #'          the group mean in relation to the intercept (reference group).
 #' @param string.interc Character vector that indicates the reference group (intercept), that is appended to

---FILE: R/sjPlotLikert.R---
@@ -55,7 +55,7 @@
 #'
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjp.stackfrq
-#' @inheritParams sjp.glmer
+#' @inheritParams plot_model
 #'
 #' @return A ggplot-object.
 #'

---FILE: R/sjPlotPolynomials.R---
@@ -30,15 +30,10 @@
 #' @param show.p Logical, if \code{TRUE} (default), p-values for polynomial terms are
 #'          printed to the console.
 #' @param loess.color Color of the loess-smoothed line. Only applies, if \code{show.loess = TRUE}.
-#' @return (Insisibily) returns
-#'           \describe{
-#'            \item{\code{plot}}{the ggplot-object with the complete plot}
-#'            \item{\code{df}}{the data frame that was used for setting up the ggplot-object}
-#'            \item{\code{cutpoints}}{a data frame that indicates x-values and predicted y-values of each direction change in the loess curvature}
-#'           }
+#' @return A ggplot-object.
 #'
-#' @inheritParams sjp.glmer
-#' @inheritParams sjp.lm
+#' @inheritParams plot_model
+#' @inheritParams scatterplot
 #'
 #' @details For each polynomial degree, a simple linear regression on \code{x} (resp.
 #'            the extracted response, if \code{x} is a fitted model) is performed,
@@ -56,9 +51,6 @@
 #'            that comes closest to the loess-smoothed line should be the best
 #'            fit to the data.
 #'
-#' @seealso To plot marginal effects of polynomial terms, call \code{\link{sjp.lm}} with \code{type = ""poly""},
-#'            or \code{\link{sjp.lmer}} respectively for linear mixed models.
-#'
 #' @examples
 #' library(sjmisc)
 #' data(efc)
@@ -109,8 +101,7 @@ sjp.poly <- function(x,
                      show.scatter = TRUE,
                      point.alpha = .2,
                      point.color = ""#404040"",
-                     loess.color = ""#808080"",
-                     prnt.plot = TRUE) {
+                     loess.color = ""#808080"") {
   # --------------------------------------------
   # check color parameter
   # --------------------------------------------
@@ -164,7 +155,7 @@ sjp.poly <- function(x,
   # --------------------------------------------
   # get cutpoints for loess curve
   # --------------------------------------------
-  cutpoints <- get_loess_cutpoints(stats::na.omit(data.frame(x = poly.term, y = resp)))
+  # cutpoints <- get_loess_cutpoints(stats::na.omit(data.frame(x = poly.term, y = resp)))
   # --------------------------------------------
   # if user wants to plot multiple curves for
   # polynomials, create data frame for each curve here
@@ -216,17 +207,8 @@ sjp.poly <- function(x,
     geom_line(aes_string(y = ""pred""), size = geom.size) +
     scale_color_manual(values = geom.colors, labels = lapply(poly.degree, function(j) bquote(x^.(j)))) +
     labs(x = axis.title, y = axisTitle.y, colour = ""Polynomial\ndegrees"")
-  # ---------------------------------------------------------
-  # Check whether ggplot object should be returned or plotted
-  # ---------------------------------------------------------
-  if (prnt.plot) graphics::plot(polyplot)
-  # -------------------------------------
-  # return results
-  # -------------------------------------
-  invisible(structure(class = ""sjppoly"",
-                      list(plot = polyplot,
-                           df = plot.df,
-                           cutpoints = cutpoints)))
+
+  polyplot
 }
 
 

---FILE: R/sjPlotResiduals.R---
@@ -14,11 +14,12 @@
 #'        plot-building is too time consuming.
 #' @param show.resid Logical, if \code{TRUE}, residual values are plotted.
 #' @param show.pred Logical, if \code{TRUE}, predicted values are plotted.
-#' @inheritParams sjp.lm
 #'
-#' @return (Insisibily) returns the ggplot-object with the complete plot (\code{plot}),
-#'           the residual pattern (\code{pattern}) as well as the data frame that
-#'           was used for setting up the ggplot-object (\code{mydf}).
+#' @inheritParams plot_model
+#' @inheritParams scatterplot
+#'
+#' @return One ggplot-object with the complete plot and one with
+#'           the residual pattern.
 #'
 #' @note The actual (observed) values have a coloured fill, while the predicted
 #'       values have a solid outline without filling.
@@ -40,7 +41,7 @@
 #' @importFrom rlang .data
 #' @export
 sjp.resid <- function(fit, geom.size = 2, remove.estimates = NULL, show.lines = TRUE,
-                      show.resid = TRUE, show.pred = TRUE, show.ci = F, prnt.plot = TRUE) {
+                      show.resid = TRUE, show.pred = TRUE, show.ci = FALSE) {
   # show lines only when both residual and predicted
   # values are plotted - else, lines make no sense
   if (!show.pred || !show.resid) show.lines <- FALSE
@@ -101,12 +102,5 @@ sjp.resid <- function(fit, geom.size = 2, remove.estimates = NULL, show.lines =
     facet_grid(~grp, scales = ""free"") +
     labs(x = NULL, y = sjlabelled::get_label(mydat[[1]], def.value = rv))
 
-  # Check whether ggplot object should be returned or plotted
-  if (prnt.plot) graphics::plot(res.plot)
-
-  # return results
-  invisible(structure(class = ""sjpresid"",
-                      list(plot = res.plot,
-                           pattern = pattern.plot,
-                           mydf = mydat)))
+  list(res.plot, pattern.plot)
 }

---FILE: R/sjPlotStackFrequencies.R---
@@ -23,7 +23,7 @@
 #'
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjp.frq
-#' @inheritParams sjp.glmer
+#' @inheritParams plot_model
 #'
 #' @examples
 #' # Data from the EUROFAMCARE sample dataset

---FILE: R/sjTabLinReg.R---
@@ -104,6 +104,8 @@
 #'          column will be added to the output; however, when copying tables to
 #'          office applications, it might be helpful not to add this separator column
 #'          when modifying the table layout.
+#' @param p.kr Logical, if \code{TRUE}, the computation of p-values is based on
+#'         conditional F-tests with Kenward-Roger approximation for the df.
 #'
 #' @inheritParams tab_model
 #' @inheritParams plot_model
@@ -1123,9 +1125,6 @@ sjt.lm <- function(...,
 #'                or saves them as file. The fitted models may have different
 #'                predictors, e.g. when comparing different stepwise fitted models.
 #'
-#' @param p.kr Logical, if \code{TRUE}, the computation of p-values is based on
-#'         conditional F-tests with Kenward-Roger approximation for the df.
-#'
 #' @inheritParams tab_model
 #' @inheritParams sjt.lm
 #' @inheritParams sjt.xtab

---FILE: man/sjp.aov1.Rd---
@@ -19,7 +19,7 @@ sjp.aov1(var.dep, var.grp, meansums = FALSE, title = NULL,
 \item{var.grp}{Factor with the cross-classifying variable, where \code{var.dep}
 is grouped into the categories represented by \code{var.grp}.}
 
-\item{meansums}{Logical, if \code{TRUE}, the values reported are the true group mean values (see also \code{\link{sjt.grpmean}}).
+\item{meansums}{Logical, if \code{TRUE}, the values reported are the true group mean values.
 If \code{FALSE} (default), the values are reported in the standard way, i.e. the values indicate the difference of
 the group mean in relation to the intercept (reference group).}
 

---FILE: man/sjp.likert.Rd---
@@ -120,6 +120,9 @@ i.e. at every \code{grid.breaks}'th position a major grid is being printed.}
 \item{expand.grid}{logical, if \code{TRUE}, the plot grid is expanded, i.e. there is a small margin between
 axes and plotting region. Default is \code{FALSE}.}
 
+\item{digits}{Numeric, amount of digits after decimal point when rounding
+estimates or values.}
+
 \item{coord.flip}{logical, if \code{TRUE}, the x and y axis are swapped.}
 }
 \value{

---FILE: man/sjp.poly.Rd---
@@ -8,7 +8,7 @@ sjp.poly(x, poly.term, poly.degree, poly.scale = FALSE, fun = NULL,
   axis.title = NULL, geom.colors = NULL, geom.size = 0.8,
   show.loess = TRUE, show.loess.ci = TRUE, show.p = TRUE,
   show.scatter = TRUE, point.alpha = 0.2, point.color = ""#404040"",
-  loess.color = ""#808080"", prnt.plot = TRUE)
+  loess.color = ""#808080"")
 }
 \arguments{
 \item{x}{A vector, representing the response variable of a linear (mixed) model; or
@@ -33,6 +33,14 @@ When \code{x} is not a vector, but a fitted model object, the function
 is detected automatically. If \code{x} is a vector, \code{fun} defaults
 to \code{""lm""}.}
 
+\item{axis.title}{Character vector of length one or two (depending on the
+plot function and type), used as title(s) for the x and y axis. If not
+specified, a default labelling  is chosen. \strong{Note:} Some plot types
+may not support this argument sufficiently. In such cases, use the returned
+ggplot-object and add axis titles manually with
+\code{\link[ggplot2]{labs}}. Use \code{axis.title = """"} to remove axis
+titles.}
+
 \item{show.loess}{Logical, if \code{TRUE}, an additional loess-smoothed line is plotted.}
 
 \item{show.loess.ci}{Logical, if \code{TRUE}, a confidence region for the loess-smoothed line
@@ -44,12 +52,7 @@ printed to the console.}
 \item{loess.color}{Color of the loess-smoothed line. Only applies, if \code{show.loess = TRUE}.}
 }
 \value{
-(Insisibily) returns
-          \describe{
-           \item{\code{plot}}{the ggplot-object with the complete plot}
-           \item{\code{df}}{the data frame that was used for setting up the ggplot-object}
-           \item{\code{cutpoints}}{a data frame that indicates x-values and predicted y-values of each direction change in the loess curvature}
-          }
+A ggplot-object.
 }
 \description{
 This function plots a scatter plot of a term \code{poly.term}
@@ -107,7 +110,3 @@ fit <- lm(tot_sc_e ~ c12hour + e42dep + e17age + I(e17age^2) + I(e17age^3),
 plot_model(fit, type = ""pred"", terms = ""e17age"")}
 
 }
-\seealso{
-To plot marginal effects of polynomial terms, call \code{\link{sjp.lm}} with \code{type = ""poly""},
-           or \code{\link{sjp.lmer}} respectively for linear mixed models.
-}

---FILE: man/sjp.resid.Rd---
@@ -6,7 +6,7 @@
 \usage{
 sjp.resid(fit, geom.size = 2, remove.estimates = NULL,
   show.lines = TRUE, show.resid = TRUE, show.pred = TRUE,
-  show.ci = F, prnt.plot = TRUE)
+  show.ci = FALSE)
 }
 \arguments{
 \item{fit}{Fitted linear (mixed) regression model (including objects of class
@@ -19,11 +19,14 @@ plot-building is too time consuming.}
 \item{show.resid}{Logical, if \code{TRUE}, residual values are plotted.}
 
 \item{show.pred}{Logical, if \code{TRUE}, predicted values are plotted.}
+
+\item{show.ci}{Logical, if \code{TRUE)}, adds notches to the box plot, which are
+used to compare groups; if the notches of two boxes do not overlap,
+medians are considered to be significantly different.}
 }
 \value{
-(Insisibily) returns the ggplot-object with the complete plot (\code{plot}),
-          the residual pattern (\code{pattern}) as well as the data frame that
-          was used for setting up the ggplot-object (\code{mydf}).
+One ggplot-object with the complete plot and one with
+          the residual pattern.
 }
 \description{
 This function plots observed and predicted values of the response

---FILE: man/sjp.stackfrq.Rd---
@@ -79,6 +79,9 @@ i.e. at every \code{grid.breaks}'th position a major grid is being printed.}
 \item{expand.grid}{logical, if \code{TRUE}, the plot grid is expanded, i.e. there is a small margin between
 axes and plotting region. Default is \code{FALSE}.}
 
+\item{digits}{Numeric, amount of digits after decimal point when rounding
+estimates or values.}
+
 \item{vjust}{character vector, indicating the vertical position of value
 labels. Allowed are same values as for \code{vjust} aesthetics from
 \code{ggplot2}: ""left"", ""center"", ""right"", ""bottom"", ""middle"", ""top"" and

---FILE: man/sjt.lm.Rd---
@@ -58,6 +58,9 @@ as numbers. If \code{FALSE} (default), asterisks are used.}
 period (e.g. \emph{0.002}), else p-values start with a period and
 without a zero (e.g. \emph{.002}).}
 
+\item{p.kr}{Logical, if \code{TRUE}, the computation of p-values is based on
+conditional F-tests with Kenward-Roger approximation for the df.}
+
 \item{robust}{Logical, if \code{TRUE}, robust standard errors and confidence
 intervals will be reported. Computation of robust standard errors is
 based on the \code{\link[sjstats]{robust}}-function in the"
strengejacke,sjPlot,bb1a75e8aa9a26e3f65efe0d1eaa7a2898b3c2b6,Daniel,mail@danielluedecke.de,2018-08-12T11:31:07Z,Daniel,mail@danielluedecke.de,2018-08-12T11:31:07Z,fix CHECK issues,R/sjPlotAnova.R;R/sjPlotCorr.R;R/sjPlotFrequencies.R;R/sjPlotGroupPropTable.R;R/sjTabFA.R;R/sjTabItemAnalysis.R;R/sjTabLinReg.R;R/sjTabPCA.R;R/sjTabSPSS.R;R/sjTabStackFrq.R;R/sjplot.R;man/sjp.aov1.Rd;man/sjp.corr.Rd;man/sjp.frq.Rd;man/sjp.gpt.Rd;man/sjplot.Rd;man/sjt.fa.Rd;man/sjt.itemanalysis.Rd;man/sjt.lmer.Rd;man/sjt.pca.Rd;man/sjt.stackfrq.Rd;man/view_df.Rd,False,True,True,False,218,119,337,"---FILE: R/sjPlotAnova.R---
@@ -1,7 +1,3 @@
-# bind global variables
-utils::globalVariables(c(""pv"", ""xv""))
-
-
 #' @title Plot One-Way-Anova tables
 #' @name sjp.aov1
 #'
@@ -10,8 +6,6 @@ utils::globalVariables(c(""pv"", ""xv""))
 #'                dependent variable (variance within and between groups) is printed to
 #'                the model summary.
 #'
-#' @seealso \code{\link{sjt.grpmean}}
-#'
 #' @param var.dep Dependent variable. Will be used with following formula:
 #'          \code{aov(var.dep ~ var.grp)}
 #' @param var.grp Factor with the cross-classifying variable, where \code{var.dep}
@@ -23,13 +17,11 @@ utils::globalVariables(c(""pv"", ""xv""))
 #'          the value label of the grouping variable. Default is \code{""(Intercept)""}.
 #'
 #' @inheritParams sjp.grpfrq
-#' @inheritParams sjp.lm
-#' @inheritParams sjp.glmer
 #' @inheritParams sjp.xtab
 #' @inheritParams sjp.gpt
+#' @inheritParams plot_model
 #'
-#' @return (Insisibily) returns the ggplot-object with the complete plot (\code{plot}) as well as the data frame that
-#'           was used for setting up the ggplot-object (\code{df}).
+#' @return A ggplot-object.
 #'
 #' @examples
 #' data(efc)
@@ -42,6 +34,8 @@ utils::globalVariables(c(""pv"", ""xv""))
 #' @importFrom sjmisc trim word_wrap to_value
 #' @importFrom stats confint aov summary.lm
 #' @importFrom tibble rownames_to_column
+#' @importFrom rlang .data
+#' @importFrom sjlabelled get_label get_labels
 #' @export
 sjp.aov1 <- function(var.dep,
                      var.grp,
@@ -59,10 +53,9 @@ sjp.aov1 <- function(var.dep,
                      grid.breaks = NULL,
                      show.values = TRUE,
                      digits = 2,
-                     y.offset = .1,
+                     y.offset = .15,
                      show.p = TRUE,
-                     show.summary = FALSE,
-                     prnt.plot = TRUE) {
+                     show.summary = FALSE) {
   # --------------------------------------------------------
   # get variable name
   # --------------------------------------------------------
@@ -192,26 +185,27 @@ sjp.aov1 <- function(var.dep,
   # create new data.frame, since ggplot requires data.frame as parameter
   # The data frame contains means, CI and p-values
   # --------------------------------------------------------
-  df <- data.frame(means,     # Append coefficients
-                   means.lci, # append CI
-                   means.uci,
-                   means.p,   # append p-value
-                   ps,
-                   catorder)
+  df <- data.frame(
+    means = means,     # Append coefficients
+    lower = means.lci, # append CI
+    upper = means.uci,
+    p = means.p,   # append p-value
+    pv = ps,
+    xv = catorder
+  )
   # --------------------------------------------------------
   # check if user defined labels have been supplied
   # if not, use variable names from data frame
   # --------------------------------------------------------
   if (is.null(axis.labels)) axis.labels <- row.names(df)
   # order labels
   axis.labels <- axis.labels[catorder]
-  # give columns names
-  names(df) <- c(""means"", ""lower"", ""upper"", ""p"", ""pv"", ""xv"")
   df$means <- sjmisc::to_value(df$means, keep.labels = F)
   df$lower <- sjmisc::to_value(df$lower, keep.labels = F)
   df$upper <- sjmisc::to_value(df$upper, keep.labels = F)
   df$p <- sjmisc::to_value(df$p, keep.labels = F)
   df$pv <- as.character(df$pv)
+  df$xv <- as.factor(df$xv)
   # bind color values to data frame, because we cannot use several
   # different color aesthetics in ggplot
   df <- cbind(df, geocol = ifelse(df$means >= 0, geom.colors[1], geom.colors[2]))
@@ -244,49 +238,38 @@ sjp.aov1 <- function(var.dep,
   # --------------------------------------------------------
   # Set up plot padding (margins inside diagram)
   # --------------------------------------------------------
-  scaley <- scale_y_continuous(limits = c(lower_lim, upper_lim),
-                               breaks = ticks,
-                               labels = ticks)
+  scaley <- ggplot2::scale_y_continuous(
+    limits = c(lower_lim, upper_lim),
+    breaks = ticks,
+    labels = ticks
+  )
   # --------------------------------------------------------
   # Start plot here!
   # --------------------------------------------------------
-  anovaplot <- ggplot(df, aes(y = means, x = as.factor(xv))) +
+  anovaplot <- ggplot2::ggplot(df, ggplot2::aes(y = .data$means, x = .data$xv)) +
     # print point
-    geom_point(size = geom.size, colour = df$geocol) +
+    ggplot2::geom_point(size = geom.size, colour = df$geocol) +
     # and error bar
-    geom_errorbar(aes(ymin = lower, ymax = upper), colour = df$geocol, width = 0) +
+    ggplot2::geom_errorbar(ggplot2::aes(ymin = .data$lower, ymax = .data$upper), colour = df$geocol, width = 0) +
     # Print p-values. With vertical adjustment, so
     # they don't overlap with the errorbars
-    geom_text(aes(label = pv, y = means), nudge_x = y.offset, show.legend = FALSE) +
+    ggplot2::geom_text(ggplot2::aes(label = .data$pv, y = .data$means), nudge_x = y.offset, show.legend = FALSE) +
     # set y-scale-limits, breaks and tick labels
     scaley +
     # set value labels to x-axis
-    scale_x_discrete(labels = axis.labels, limits = 1:length(axis.labels)) +
+    ggplot2::scale_x_discrete(labels = axis.labels, limits = 1:length(axis.labels)) +
     # flip coordinates
-    labs(title = title, x = NULL, y = axis.title) +
-    coord_flip()
+    ggplot2::labs(title = title, x = NULL, y = axis.title) +
+    ggplot2::coord_flip()
+
   # check whether modelsummary should be printed
   if (show.summary) {
     # add annotations with model summary
     # annotations include intercept-value and model's r-square
     anovaplot <- anovaplot +
-      annotate(""text"", label = modsum, parse = TRUE, x = -Inf, y = Inf,
+      ggplot2::annotate(""text"", label = modsum, parse = TRUE, x = -Inf, y = Inf,
                hjust = ""right"", vjust = ""bottom"")
   }
-  # ---------------------------------------------------------
-  # Check whether ggplot object should be returned or plotted
-  # ---------------------------------------------------------
-  if (prnt.plot) graphics::plot(anovaplot)
-  # -------------------------------------
-  # set proper column names
-  # -------------------------------------
-  df <- tibble::rownames_to_column(df)
-  colnames(df) <- c(""term"", ""estimate"", ""conf.low"", ""conf.high"",
-                    ""p.value"", ""p.string"", ""xpos"", ""geom.color"")
-  # -------------------------------------
-  # return results
-  # -------------------------------------
-  invisible(structure(class = ""sjpaov1"",
-                      list(plot = anovaplot,
-                           data = df)))
+
+  anovaplot
 }

---FILE: R/sjPlotCorr.R---
@@ -28,7 +28,7 @@ utils::globalVariables(c(""ordx"", ""ordy""))
 #'          as numbers. If \code{FALSE} (default), asterisks are used.
 #'
 #' @inheritParams sjp.grpfrq
-#' @inheritParams sjp.lm
+#' @inheritParams sjp.gpt
 #'
 #' @return (Insisibily) returns the ggplot-object with the complete plot (\code{plot}) as well as the data frame that
 #'           was used for setting up the ggplot-object (\code{df}) and the original correlation matrix

---FILE: R/sjPlotFrequencies.R---
@@ -46,6 +46,12 @@ utils::globalVariables(c(""val"", ""frq"", ""grp"", ""label.pos"", ""upper.ci"", ""lower.ci
 #' @param xlim Numeric vector of length two, defining lower and upper axis limits
 #'          of the x scale. By default, this argument is set to \code{NULL}, i.e. the
 #'          x-axis fits to the required range of the data.
+#' @param axis.title Character vector of length one or two (depending on
+#'          the plot function and type), used as title(s) for the x and y axis.
+#'          If not specified, a default labelling  is chosen.
+#'          \strong{Note:} Some plot types do not support this argument. In such
+#'          cases, use the return value and add axis titles manually with
+#'          \code{\link[ggplot2]{labs}}, e.g.: \code{$plot.list[[1]] + labs(x = ...)}
 #'
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjp.lm

---FILE: R/sjPlotGroupPropTable.R---
@@ -28,13 +28,14 @@ utils::globalVariables(c(""dep"", ""n""))
 #'          \code{type = ""slope""} in \code{\link{sjp.glm}}), \code{axis.lim} may
 #'          also be a list of vectors of length 2, defining axis limits for each
 #'          plot (only if non-faceted).
+#' @param show.p Logical, adds significance levels to values, or value and
+#'          variable labels.
 #'
 #' @return (Insisibily) returns the ggplot-object with the complete plot
 #'           (\code{plot}) as well as the data frame that
 #'           was used for setting up the ggplot-object (\code{df}).
 #'
 #' @inheritParams sjp.grpfrq
-#' @inheritParams sjp.lm
 #' @inheritParams sjp.xtab
 #'
 #' @details The p-values are based on \code{\link[stats]{chisq.test}} of \code{x}

---FILE: R/sjTabFA.R---
@@ -14,6 +14,7 @@
 #' @inheritParams sjp.pca
 #' @inheritParams sjt.pca
 #' @inheritParams tab_model
+#' @inheritParams tab_df
 #' @inheritParams sjt.xtab
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjt.corr
@@ -57,18 +58,18 @@ sjt.fa <- function(data,
                    method = c(""ml"", ""minres"", ""wls"", ""gls"", ""pa"", ""minchi"", ""minrank""),
                    nmbr.fctr = NULL,
                    fctr.load.tlrn = 0.1,
-                    title = ""Factor Analysis"",
-                    var.labels = NULL,
-                    wrap.labels = 40,
-                    show.cronb = TRUE,
-                    show.comm = FALSE,
-                    altr.row.col = FALSE,
-                    digits = 2,
-                    CSS = NULL,
-                    encoding = NULL,
-                    file = NULL,
-                    use.viewer = TRUE,
-                    remove.spaces = TRUE) {
+                   title = ""Factor Analysis"",
+                   var.labels = NULL,
+                   wrap.labels = 40,
+                   show.cronb = TRUE,
+                   show.comm = FALSE,
+                   alternate.rows = FALSE,
+                   digits = 2,
+                   CSS = NULL,
+                   encoding = NULL,
+                   file = NULL,
+                   use.viewer = TRUE,
+                   remove.spaces = TRUE) {
   # -------------------------------------
   # check encoding
   # -------------------------------------
@@ -332,7 +333,7 @@ sjt.fa <- function(data,
     # default row string for alternative row colors
     arcstring <- """"
     # if we have alternating row colors, set css
-    if (altr.row.col) arcstring <- ifelse(sjmisc::is_even(i), "" arc"", """")
+    if (alternate.rows) arcstring <- ifelse(sjmisc::is_even(i), "" arc"", """")
     # write tr-tag with class-attributes
     page.content <- paste0(page.content, ""  <tr>\n"")
     # print first table cell

---FILE: R/sjTabItemAnalysis.R---
@@ -54,6 +54,7 @@
 #'          Finally, a correlation of these ""scale sum scores"" is computed.
 #'
 #' @inheritParams tab_model
+#' @inheritParams view_df
 #' @inheritParams sjt.xtab
 #' @inheritParams tab_df
 #'
@@ -124,7 +125,7 @@ sjt.itemanalysis <- function(df,
                              factor.groups.titles = ""auto"",
                              scale = FALSE,
                              min.valid.rowmean = 2,
-                             altr.row.col = TRUE,
+                             alternate.rows = TRUE,
                              sort.column = NULL,
                              show.shapiro = FALSE,
                              show.kurtosis = FALSE,
@@ -276,7 +277,7 @@ sjt.itemanalysis <- function(df,
     x = df.ia,
     titles = factor.groups.titles,
     col.header = NULL,
-    alternate.rows = altr.row.col,
+    alternate.rows = alternate.rows,
     CSS = CSS,
     sort.column = sort.column,
     show.type = FALSE,

---FILE: R/sjTabLinReg.R---
@@ -106,6 +106,7 @@
 #'          when modifying the table layout.
 #'
 #' @inheritParams tab_model
+#' @inheritParams plot_model
 #' @inheritParams sjt.xtab
 #' @inheritParams sjp.lmer
 #' @inheritParams sjp.corr
@@ -1122,7 +1123,11 @@ sjt.lm <- function(...,
 #'                or saves them as file. The fitted models may have different
 #'                predictors, e.g. when comparing different stepwise fitted models.
 #'
+#' @param p.kr Logical, if \code{TRUE}, the computation of p-values is based on
+#'         conditional F-tests with Kenward-Roger approximation for the df.
+#'
 #' @inheritParams tab_model
+#' @inheritParams sjt.lm
 #' @inheritParams sjt.xtab
 #' @inheritParams sjp.corr
 #'

---FILE: R/sjTabPCA.R---
@@ -34,6 +34,8 @@
 #'          \emph{""Cumulative Proportion""} will be used.
 #'
 #' @inheritParams tab_model
+#' @inheritParams view_df
+#' @inheritParams tab_df
 #' @inheritParams sjt.xtab
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjt.corr
@@ -75,7 +77,7 @@ sjt.pca <- function(data,
                     show.cronb = TRUE,
                     show.msa = FALSE,
                     show.var = FALSE,
-                    altr.row.col = FALSE,
+                    alternate.rows = FALSE,
                     digits = 2,
                     string.pov = ""Proportion of Variance"",
                     string.cpov = ""Cumulative Proportion"",
@@ -371,7 +373,7 @@ sjt.pca <- function(data,
     # default row string for alternative row colors
     arcstring <- """"
     # if we have alternating row colors, set css
-    if (altr.row.col) arcstring <- ifelse(sjmisc::is_even(i), "" arc"", """")
+    if (alternate.rows) arcstring <- ifelse(sjmisc::is_even(i), "" arc"", """")
     # write tr-tag with class-attributes
     page.content <- paste0(page.content, ""  <tr>\n"")
     # print first table cell

---FILE: R/sjTabSPSS.R---
@@ -83,7 +83,7 @@
 #' @export
 view_df <- function(x,
                     weight.by = NULL,
-                    altr.row.col = TRUE,
+                    alternate.rows = TRUE,
                     show.id = TRUE,
                     show.type = FALSE,
                     show.values = TRUE,
@@ -226,7 +226,7 @@ view_df <- function(x,
     arcstring <- """"
 
     # if we have alternating row colors, set css
-    if (altr.row.col) arcstring <- ifelse(sjmisc::is_even(ccnt), "" arc"", """")
+    if (alternate.rows) arcstring <- ifelse(sjmisc::is_even(ccnt), "" arc"", """")
     page.content <- paste0(page.content, ""  <tr>\n"")
 
     # ID

---FILE: R/sjTabStackFrq.R---
@@ -25,6 +25,7 @@
 #' @param digits.stats amount of digits for rounding the skewness and kurtosis valuess.
 #'          Default is 2, i.e. skewness and kurtosis values have 2 digits after decimal point.
 #'
+#' @inheritParams tab_df
 #' @inheritParams sjt.itemanalysis
 #' @inheritParams sjp.glmer
 #' @inheritParams sjt.xtab
@@ -74,15 +75,15 @@
 #' # recveive first item of COPE-index scale
 #' end <- which(colnames(efc) == ""c90cop9"")
 #'
-#' sjt.stackfrq(efc[, c(start:end)], altr.row.col = TRUE)
+#' sjt.stackfrq(efc[, c(start:end)], alternate.rows = TRUE)
 #'
-#' sjt.stackfrq(efc[, c(start:end)], altr.row.col = TRUE,
+#' sjt.stackfrq(efc[, c(start:end)], alternate.rows = TRUE,
 #'              show.n = TRUE, show.na = TRUE)
 #'
 #' # --------------------------------
 #' # User defined style sheet
 #' # --------------------------------
-#' sjt.stackfrq(efc[, c(start:end)], altr.row.col = TRUE,
+#' sjt.stackfrq(efc[, c(start:end)], alternate.rows = TRUE,
 #'              show.total = TRUE, show.skew = TRUE, show.kurtosis = TRUE,
 #'              CSS = list(css.ncol = ""border-left:1px dotted black;"",
 #'                         css.summary = ""font-style:italic;""))}
@@ -97,7 +98,7 @@ sjt.stackfrq <- function(items,
                          value.labels = NULL,
                          wrap.labels = 20,
                          sort.frq = NULL,
-                         altr.row.col = FALSE,
+                         alternate.rows = FALSE,
                          digits = 2,
                          string.total = ""N"",
                          string.na = ""NA"",
@@ -376,7 +377,7 @@ sjt.stackfrq <- function(items,
     # default row string for alternative row colors
     arcstring <- """"
     # if we have alternating row colors, set css
-    if (altr.row.col) arcstring <- ifelse(sjmisc::is_even(i), "" arc"", """")
+    if (alternate.rows) arcstring <- ifelse(sjmisc::is_even(i), "" arc"", """")
     # write tr-tag
     page.content <- paste0(page.content, ""  <tr>\n"")
     # print first table cell

---FILE: R/sjplot.R---
@@ -66,11 +66,6 @@
 #' efc %>% sjplot(e17age, c172code, fun = ""grpfrq"",
 #'                type = ""box"", geom.colors = ""Set1"")
 #'
-#' # scatter plot, grouped
-#' efc %>%
-#'   select(e42dep, c172code, c161sex) %>%
-#'   sjplot(fun = ""scatter"")
-#'
 #' # frequencies, as plot grid
 #' efc %>%
 #'   select(e42dep, c172code, e16sex, c161sex) %>%

---FILE: man/sjp.aov1.Rd---
@@ -9,8 +9,8 @@ sjp.aov1(var.dep, var.grp, meansums = FALSE, title = NULL,
   string.interc = ""(Intercept)"", axis.title = """", axis.lim = NULL,
   geom.colors = c(""#3366a0"", ""#aa3333""), geom.size = 3,
   wrap.title = 50, wrap.labels = 25, grid.breaks = NULL,
-  show.values = TRUE, digits = 2, y.offset = 0.1, show.p = TRUE,
-  show.summary = FALSE, prnt.plot = TRUE)
+  show.values = TRUE, digits = 2, y.offset = 0.15, show.p = TRUE,
+  show.summary = FALSE)
 }
 \arguments{
 \item{var.dep}{Dependent variable. Will be used with following formula:
@@ -36,6 +36,14 @@ argument, since in most cases, axis labels are set automatically.}
 \item{string.interc}{Character vector that indicates the reference group (intercept), that is appended to
 the value label of the grouping variable. Default is \code{""(Intercept)""}.}
 
+\item{axis.title}{Character vector of length one or two (depending on the
+plot function and type), used as title(s) for the x and y axis. If not
+specified, a default labelling  is chosen. \strong{Note:} Some plot types
+may not support this argument sufficiently. In such cases, use the returned
+ggplot-object and add axis titles manually with
+\code{\link[ggplot2]{labs}}. Use \code{axis.title = """"} to remove axis
+titles.}
+
 \item{axis.lim}{Numeric vector of length 2, defining the range of the plot axis.
 Depending on plot type, may effect either x- or y-axis, or both.
 For multiple plot outputs (e.g., from \code{type = ""eff""} or
@@ -60,22 +68,24 @@ i.e. at every \code{grid.breaks}'th position a major grid is being printed.}
 
 \item{show.values}{Logical, whether values should be plotted or not.}
 
+\item{digits}{Numeric, amount of digits after decimal point when rounding
+estimates or values.}
+
 \item{y.offset}{numeric, offset for text labels when their alignment is adjusted
 to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
 
+\item{show.p}{Logical, adds significance levels to values, or value and
+variable labels.}
+
 \item{show.summary}{logical, if \code{TRUE} (default), a summary with chi-squared
 statistics (see \code{\link{chisq.test}}), Cramer's V or Phi-value etc.
 is shown. If a cell contains expected values lower than five (or lower than 10
 if df is 1), the Fisher's excact test (see \code{\link{fisher.test}}) is
 computed instead of chi-squared test. If the table's matrix is larger
 than 2x2, Fisher's excact test with Monte Carlo simulation is computed.}
-
-\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
-want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }
 \value{
-(Insisibily) returns the ggplot-object with the complete plot (\code{plot}) as well as the data frame that
-          was used for setting up the ggplot-object (\code{df}).
+A ggplot-object.
 }
 \description{
 Plot One-Way-Anova table sum of squares (SS) of each factor level (group)
@@ -91,6 +101,3 @@ sjp.aov1(efc$c12hour, efc$e42dep)
 
 
 }
-\seealso{
-\code{\link{sjt.grpmean}}
-}

---FILE: man/sjp.corr.Rd---
@@ -56,6 +56,9 @@ function, a legend is added to the plot.}
 
 \item{show.values}{Logical, whether values should be plotted or not.}
 
+\item{show.p}{Logical, adds significance levels to values, or value and
+variable labels.}
+
 \item{p.numeric}{Logical, if \code{TRUE}, the p-values are printed
 as numbers. If \code{FALSE} (default), asterisks are used.}
 

---FILE: man/sjp.frq.Rd---
@@ -63,6 +63,13 @@ need smaller values than dot sizes.}
 Only applies to \code{type = ""bar""}. In case of dot plots, error bars
 will have same colors as dots (see \code{geom.colors}).}
 
+\item{axis.title}{Character vector of length one or two (depending on
+the plot function and type), used as title(s) for the x and y axis.
+If not specified, a default labelling  is chosen.
+\strong{Note:} Some plot types do not support this argument. In such
+cases, use the return value and add axis titles manually with
+\code{\link[ggplot2]{labs}}, e.g.: \code{$plot.list[[1]] + labs(x = ...)}}
+
 \item{axis.labels}{character vector with labels used as axis labels. Optional
 argument, since in most cases, axis labels are set automatically.}
 

---FILE: man/sjp.gpt.Rd---
@@ -79,6 +79,9 @@ i.e. at every \code{grid.breaks}'th position a major grid is being printed.}
 the total-row in the figure will be highlighted with a slightly
 shaded background.}
 
+\item{show.p}{Logical, adds significance levels to values, or value and
+variable labels.}
+
 \item{show.n}{logical, if \code{TRUE}, adds total number of cases for each
 group or category to the labels.}
 

---FILE: man/sjplot.Rd---
@@ -82,11 +82,6 @@ efc \%>\% sjplot(e42dep, c172code, fun = ""grpfrq"")
 efc \%>\% sjplot(e17age, c172code, fun = ""grpfrq"",
                type = ""box"", geom.colors = ""Set1"")
 
-# scatter plot, grouped
-efc \%>\%
-  select(e42dep, c172code, c161sex) \%>\%
-  sjplot(fun = ""scatter"")
-
 # frequencies, as plot grid
 efc \%>\%
   select(e42dep, c172code, e16sex, c161sex) \%>\%

---FILE: man/sjt.fa.Rd---
@@ -8,7 +8,7 @@ sjt.fa(data, rotation = c(""promax"", ""varimax""), method = c(""ml"",
   ""minres"", ""wls"", ""gls"", ""pa"", ""minchi"", ""minrank""), nmbr.fctr = NULL,
   fctr.load.tlrn = 0.1, title = ""Factor Analysis"", var.labels = NULL,
   wrap.labels = 40, show.cronb = TRUE, show.comm = FALSE,
-  altr.row.col = FALSE, digits = 2, CSS = NULL, encoding = NULL,
+  alternate.rows = FALSE, digits = 2, CSS = NULL, encoding = NULL,
   file = NULL, use.viewer = TRUE, remove.spaces = TRUE)
 }
 \arguments{
@@ -55,16 +55,19 @@ Only applies when \code{data} is a data frame.}
 
 \item{show.comm}{Logical, if \code{TRUE}, show the communality column in the table.}
 
+\item{alternate.rows}{Logical, if \code{TRUE}, rows are printed in
+alternatig colors (white and light grey by default).}
+
 \item{digits}{Amount of decimals for estimates}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
 according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
 See 'Details' or \href{../doc/table_css.html}{this package-vignette}.}
 
-\item{encoding}{String, indicating the charset encoding used for variable and
-value labels. Default is \code{NULL}, so encoding will be auto-detected
-depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
+\item{encoding}{Character vector, indicating the charset encoding used
+for variable and value labels. Default is \code{""UTF-8""}. For Windows
+Systems, \code{encoding = ""Windows-1252""} might be necessary for proper
+display of special characters.}
 
 \item{file}{Destination file, if the output should be saved as file.
 If \code{NULL} (default), the output will be saved as temporary file and

---FILE: man/sjt.itemanalysis.Rd---
@@ -6,7 +6,7 @@
 \usage{
 sjt.itemanalysis(df, factor.groups = NULL,
   factor.groups.titles = ""auto"", scale = FALSE,
-  min.valid.rowmean = 2, altr.row.col = TRUE, sort.column = NULL,
+  min.valid.rowmean = 2, alternate.rows = TRUE, sort.column = NULL,
   show.shapiro = FALSE, show.kurtosis = FALSE,
   show.corr.matrix = TRUE, CSS = NULL, encoding = NULL,
   file = NULL, use.viewer = TRUE, remove.spaces = TRUE)
@@ -33,6 +33,9 @@ Default is 2, i.e. the return values \code{index.scores} and \code{df.index.scor
 computed for those items that have at least \code{min.valid.rowmean} per case (observation, or
 technically, row). See \code{mean_n} for details.}
 
+\item{alternate.rows}{Logical, if \code{TRUE}, rows are printed in
+alternatig colors (white and light grey by default).}
+
 \item{sort.column}{Numeric vector, indicating the index of the column
 that should sorted. by default, the column is sorted in ascending order.
 Use negative index for descending order, for instance,
@@ -57,10 +60,10 @@ Finally, a correlation of these ""scale sum scores"" is computed.}
 according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
 See 'Details' or \href{../doc/table_css.html}{this package-vignette}.}
 
-\item{encoding}{String, indicating the charset encoding used for variable and
-value labels. Default is \code{NULL}, so encoding will be auto-detected
-depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
+\item{encoding}{Character vector, indicating the charset encoding used
+for variable and value labels. Default is \code{""UTF-8""}. For Windows
+Systems, \code{encoding = ""Windows-1252""} might be necessary for proper
+display of special characters.}
 
 \item{file}{Destination file, if the output should be saved as file.
 If \code{NULL} (default), the output will be saved as temporary file and

---FILE: man/sjt.lmer.Rd---
@@ -40,11 +40,41 @@ names of \code{pred.labels}. This ensures that labels always match the
 related predictor in the table, no matter in which way the predictors
 are sorted. See 'Examples'.}
 
+\item{depvar.labels}{Character vector with labels of dependent
+variables of all fitted models. See 'Examples'.}
+
+\item{remove.estimates}{Numeric vector with indices (order equals to row index of \code{coef(fit)})
+or character vector with coefficient names that indicate which estimates should be removed
+from the table output. The first estimate is the intercept, followed by the model predictors.
+\emph{The intercept cannot be removed from the table output!} \code{remove.estimates = c(2:4)}
+would remove the 2nd to the 4th estimate (1st to 3rd predictor after intercept) from the output.
+\code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default
+is \code{NULL}, i.e. all estimates are printed.}
+
+\item{group.pred}{Logical, if \code{TRUE} (default), automatically groups table rows with
+factor levels of same factor, i.e. predictors of type \code{\link{factor}} will
+be grouped, if the factor has more than two levels. Grouping means that a separate headline
+row is inserted to the table just before the predictor values.}
+
 \item{p.numeric}{Logical, if \code{TRUE}, the p-values are printed
 as numbers. If \code{FALSE} (default), asterisks are used.}
 
 \item{emph.p}{Logical, if \code{TRUE}, significant p-values are shown bold faced.}
 
+\item{p.zero}{logical, if \code{TRUE}, p-values have a leading 0 before the
+period (e.g. \emph{0.002}), else p-values start with a period and
+without a zero (e.g. \emph{.002}).}
+
+\item{p.kr}{Logical, if \code{TRUE}, the computation of p-values is based on
+conditional F-tests with Kenward-Roger approximation for the df.}
+
+\item{separate.ci.col}{Logical, if \code{TRUE}, the CI values are shown in a separate table column.
+Default is \code{FALSE}.}
+
+\item{newline.ci}{Logical, if \code{TRUE} and \code{separate.ci.col = FALSE}, inserts a line break
+between estimate and CI values. If \code{FALSE}, CI values are printed in the same
+line as estimate values.}
+
 \item{show.est}{Logical, if \code{TRUE}, the estimates are printed.}
 
 \item{show.std}{Indicates whether standardized beta-coefficients should
@@ -58,6 +88,12 @@ confidence intervals.}
 
 \item{show.se}{Logical, if \code{TRUE}, the standard errors are also printed.}
 
+\item{show.header}{Logical, if \code{TRUE}, the header strings \code{string.pred}
+and \code{string.dv} are shown. By default, they're hidden.}
+
+\item{show.col.header}{Logical, if \code{TRUE} (default), the table data columns have a headline with
+abbreviations for estimates, std. beta-values, confidence interval and p-values.}
+
 \item{show.r2}{Logical, if \code{TRUE}, the r-squared value is also printed.
 Depending on the model, these might be pseudo-r-squared values, or Bayesian
 r-squared etc. See \code{\link[sjstats]{r2}} for details.}
@@ -82,6 +118,17 @@ is printed in the table summary.}
 \item{string.pred}{Character vector,used as headline for the predictor column.
 Default is \code{""Predictors""}.}
 
+\item{string.dv}{Character vector, used as headline for the
+dependent variable columns. Default is \code{""Dependent Variables""}.}
+
+\item{string.interc}{Character vector, used as headline for the Intercept row.
+Default is \code{""Intercept""}.}
+
+\item{string.obs}{character vector, used in the summary row for the count of observation
+(cases). Default is \code{""Observations""}.}
+
+\item{string.est}{Character vector, used for the column heading of estimates.}
+
 \item{string.std}{Character vector, used for the column heading of standardized beta coefficients. Default is \code{""std. Beta""}.}
 
 \item{string.ci}{Character vector, used for the column heading of confidence interval values. Default is \code{""CI""}.}
@@ -96,8 +143,32 @@ May be an HTML entity. See 'Examples'.}
 \item{minus.sign}{string, indicating the minus sign for negative numbers.
 May be an HTML entity. See 'Examples'.}
 
+\item{digits.est}{Amount of decimals for table values.}
+
+\item{digits.std}{Amount of decimals for standardized beta.}
+
 \item{digits.p}{Amount of decimals for p-values}
 
+\item{digits.ci}{Amount of decimals for confidence intervals.}
+
+\item{digits.se}{Amount of decimals for standard error.}
+
+\item{digits.summary}{Amount of decimals for values in model summary.}
+
+\item{cell.spacing}{Numeric, inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
+suitable for viewing the table. Decrease this value (0.05 to 0.1) if you want to import the table
+into Office documents. This is a convenient argument for the \code{CSS} argument for changing
+cell spacing, which would be: \code{CSS = list(css.thead = ""padding:0.2cm;"", css.tdata = ""padding:0.2cm;"")}.}
+
+\item{cell.gpr.indent}{Indent for table rows with grouped factor predictors. Only applies
+if \code{group.pred = TRUE}.}
+
+\item{sep.column}{Logical, if \code{TRUE}, an empty table column is added after
+each model column, to add margins between model columns. By default, this
+column will be added to the output; however, when copying tables to
+office applications, it might be helpful not to add this separator column
+when modifying the table layout.}
+
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
 according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
 See 'Details' or \href{../doc/table_css.html}{this package-vignette}.}

---FILE: man/sjt.pca.Rd---
@@ -7,7 +7,7 @@
 sjt.pca(data, rotation = c(""varimax"", ""oblimin""), nmbr.fctr = NULL,
   fctr.load.tlrn = 0.1, title = ""Principal Component Analysis"",
   var.labels = NULL, wrap.labels = 40, show.cronb = TRUE,
-  show.msa = FALSE, show.var = FALSE, altr.row.col = FALSE,
+  show.msa = FALSE, show.var = FALSE, alternate.rows = FALSE,
   digits = 2, string.pov = ""Proportion of Variance"",
   string.cpov = ""Cumulative Proportion"", CSS = NULL, encoding = NULL,
   file = NULL, use.viewer = TRUE, remove.spaces = TRUE)
@@ -48,6 +48,9 @@ dor each component.}
 \item{show.var}{Logical, if \code{TRUE}, the proportions of variances for each component as well as cumulative
 variance are shown in the table footer.}
 
+\item{alternate.rows}{Logical, if \code{TRUE}, rows are printed in
+alternatig colors (white and light grey by default).}
+
 \item{digits}{Amount of decimals for estimates}
 
 \item{string.pov}{String for the table row that contains the proportions of variances. By default,
@@ -60,10 +63,10 @@ variance are shown in the table footer.}
 according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
 See 'Details' or \href{../doc/table_css.html}{this package-vignette}.}
 
-\item{encoding}{String, indicating the charset encoding used for variable and
-value labels. Default is \code{NULL}, so encoding will be auto-detected
-depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
+\item{encoding}{Character vector, indicating the charset encoding used
+for variable and value labels. Default is \code{""UTF-8""}. For Windows
+Systems, \code{encoding = ""Windows-1252""} might be necessary for proper
+display of special characters.}
 
 \item{file}{Destination file, if the output should be saved as file.
 If \code{NULL} (default), the output will be saved as temporary file and

---FILE: man/sjt.stackfrq.Rd---
@@ -6,7 +6,7 @@
 \usage{
 sjt.stackfrq(items, weight.by = NULL, title = NULL,
   var.labels = NULL, value.labels = NULL, wrap.labels = 20,
-  sort.frq = NULL, altr.row.col = FALSE, digits = 2,
+  sort.frq = NULL, alternate.rows = FALSE, digits = 2,
   string.total = ""N"", string.na = ""NA"", show.n = FALSE,
   show.total = FALSE, show.na = FALSE, show.skew = FALSE,
   show.kurtosis = FALSE, digits.stats = 2, file = NULL,
@@ -20,7 +20,10 @@ sjt.stackfrq(items, weight.by = NULL, title = NULL,
 Must be a vector of same length as the input vector. Default is
 \code{NULL}, so no weights are used.}
 
-\item{title}{String, will be used as table caption.}
+\item{title}{Character vector with table
+caption(s) resp. footnote(s). For  \code{tab_df()}, must be a character
+of length 1; for \code{tab_dfs()}, a character vector of same length as
+\code{x} (i.e. one title or footnote per data frame).}
 
 \item{var.labels}{Character vector with variable names, which will be used
 to label variables in the output.}
@@ -42,6 +45,9 @@ by highest count of first or last category of \code{items}.
   \item or \code{NULL} (default) for no sorting.
 }}
 
+\item{alternate.rows}{Logical, if \code{TRUE}, rows are printed in
+alternatig colors (white and light grey by default).}
+
 \item{digits}{Amount of decimals for estimates}
 
 \item{string.total}{label for the total N column.}
@@ -71,10 +77,10 @@ Default is 2, i.e. skewness and kurtosis values have 2 digits after decimal poin
 If \code{NULL} (default), the output will be saved as temporary file and
 openend either in the IDE's viewer pane or the default web browser.}
 
-\item{encoding}{String, indicating the charset encoding used for variable and
-value labels. Default is \code{NULL}, so encoding will be auto-detected
-depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
+\item{encoding}{Character vector, indicating the charset encoding used
+for variable and value labels. Default is \code{""UTF-8""}. For Windows
+Systems, \code{encoding = ""Windows-1252""} might be necessary for proper
+display of special characters.}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
 according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
@@ -138,15 +144,15 @@ start <- which(colnames(efc) == ""c82cop1"")
 # recveive first item of COPE-index scale
 end <- which(colnames(efc) == ""c90cop9"")
 
-sjt.stackfrq(efc[, c(start:end)], altr.row.col = TRUE)
+sjt.stackfrq(efc[, c(start:end)], alternate.rows = TRUE)
 
-sjt.stackfrq(efc[, c(start:end)], altr.row.col = TRUE,
+sjt.stackfrq(efc[, c(start:end)], alternate.rows = TRUE,
              show.n = TRUE, show.na = TRUE)
 
 # --------------------------------
 # User defined style sheet
 # --------------------------------
-sjt.stackfrq(efc[, c(start:end)], altr.row.col = TRUE,
+sjt.stackfrq(efc[, c(start:end)], alternate.rows = TRUE,
              show.total = TRUE, show.skew = TRUE, show.kurtosis = TRUE,
              CSS = list(css.ncol = ""border-left:1px dotted black;"",
                         css.summary = ""font-style:italic;""))}

---FILE: man/view_df.Rd---
@@ -4,7 +4,7 @@
 \alias{view_df}
 \title{View structure of labelled data frames}
 \usage{
-view_df(x, weight.by = NULL, altr.row.col = TRUE, show.id = TRUE,
+view_df(x, weight.by = NULL, alternate.rows = TRUE, show.id = TRUE,
   show.type = FALSE, show.values = TRUE, show.string.values = FALSE,
   show.labels = TRUE, show.frq = FALSE, show.prc = FALSE,
   show.wtd.frq = FALSE, show.wtd.prc = FALSE, show.na = FALSE,
@@ -23,6 +23,9 @@ and \code{\link[sjlabelled]{set_labels}}).}
 weights that will be applied to weight all  observations. Default is
 \code{NULL}, so no weights are used.}
 
+\item{alternate.rows}{Logical, if \code{TRUE}, rows are printed in
+alternatig colors (white and light grey by default).}
+
 \item{show.id}{Logical, if \code{TRUE} (default), the variable ID is shown in
 the first column.}
 "
strengejacke,sjPlot,55d2e5bde943d85a175bed40872022673d0f4782,Daniel,mail@danielluedecke.de,2018-08-10T22:35:48Z,Daniel,mail@danielluedecke.de,2018-08-10T22:35:48Z,"revert changes, fix issue in sjstats",R/html_print_utils.R;R/tab_model.R,False,True,True,False,4,8,12,"---FILE: R/html_print_utils.R---
@@ -401,6 +401,7 @@ tab_df_prepare_style <- function(CSS = NULL, content = NULL, task, ...) {
     content <- gsub(""<caption"", sprintf(""<caption style=\""%s\"""", css.caption), content, fixed = TRUE, useBytes = TRUE)
 
     # replace class-attributes with inline-style-definitions
+    # gsub(""\""(.*)(summary)(.*)\"""", ""\\1haha\\3"", ""test \""abc summary def\"""")
     content <- gsub(tag.tdata, css.tdata, content, fixed = TRUE, useBytes = TRUE)
     content <- gsub(tag.thead, css.thead, content, fixed = TRUE, useBytes = TRUE)
     content <- gsub(tag.arc, css.arc, content, fixed = TRUE, useBytes = TRUE)

---FILE: R/tab_model.R---
@@ -351,19 +351,14 @@ tab_model <- function(
       # tidy output of standardized values ----
 
       if (!is.null(show.std) && fam.info$is_linear && !is.stan(model)) {
-        tmp.dat <- model %>%
+        dat <- model %>%
           sjstats::std_beta(type = show.std, ci.lvl = ci.lvl) %>%
           sjmisc::var_rename(
             std.error = ""std.se"",
             conf.low = ""std.conf.low"",
             conf.high = ""std.conf.high""
-          )
-
-        if (sjmisc::is_empty(grep(""(Intercept)"", tmp.dat$term, fixed = T))) {
-          tmp.dat <- tibble::add_case(tmp.dat, .before = 1)
-        }
-
-        dat <- tmp.dat %>%
+          ) %>%
+          tibble::add_case(.before = 1) %>%
           dplyr::select(-1) %>%
           sjmisc::add_columns(dat) %>%
           dplyr::mutate(std.conf.int = sprintf("
strengejacke,sjPlot,6a4dff88c0ee265b1bb8cf30d5f696b0c3cc624a,Daniel,mail@danielluedecke.de,2018-08-10T19:25:53Z,Daniel,mail@danielluedecke.de,2018-08-10T19:25:53Z,Fix issue with standardized coefficient (argument `show.std`) in `tab_model()`.,NEWS.md;R/tab_model.R;R/tidiers.R,False,True,True,False,21,6,27,"---FILE: NEWS.md---
@@ -20,7 +20,7 @@ Following functions are now defunct:
 ## Bug fixes
 
 * Due to changes in the _broom_ and _lmerTest_ packages, tidiers did no longer work for `lmerModLmerTest` objects.
-
+* Fix issue with standardized coefficient (argument `show.std`) in `tab_model()`.
 
 # sjPlot 2.5.0
 

---FILE: R/tab_model.R---
@@ -351,14 +351,19 @@ tab_model <- function(
       # tidy output of standardized values ----
 
       if (!is.null(show.std) && fam.info$is_linear && !is.stan(model)) {
-        dat <- model %>%
+        tmp.dat <- model %>%
           sjstats::std_beta(type = show.std, ci.lvl = ci.lvl) %>%
           sjmisc::var_rename(
             std.error = ""std.se"",
             conf.low = ""std.conf.low"",
             conf.high = ""std.conf.high""
-          ) %>%
-          tibble::add_case(.before = 1) %>%
+          )
+
+        if (sjmisc::is_empty(grep(""(Intercept)"", tmp.dat$term, fixed = T))) {
+          tmp.dat <- tibble::add_case(tmp.dat, .before = 1)
+        }
+
+        dat <- tmp.dat %>%
           dplyr::select(-1) %>%
           sjmisc::add_columns(dat) %>%
           dplyr::mutate(std.conf.int = sprintf(
@@ -370,7 +375,6 @@ tab_model <- function(
             .data$std.conf.high
           )) %>%
           dplyr::select(-.data$std.conf.low, -.data$std.conf.high)
-
       }
 
 

---FILE: R/tidiers.R---
@@ -567,7 +567,18 @@ tidy_glmmTMB_model <- function(model, ci.lvl, show.zeroinf) {
   # get fixed effects
 
   est <- glmmTMB::fixef(model)
-  vcovs <- stats::vcov(model)
+
+  # model may have error ""system is computationally singular"", then
+  # no vcov can be calculated
+
+  vcovs <- tryCatch(
+    {
+      stats::vcov(model)
+    },
+    error = function(x) { c(list(matrix(NA)), list(matrix(NA))) },
+    warning = function(x) { c(list(matrix(NA)), list(matrix(NA))) },
+    finally = function(x) { c(list(matrix(NA)), list(matrix(NA))) }
+  )
 
 
   # save conditional model"
strengejacke,sjPlot,914b51b4ae9a374b59fb9e057a9f6e76ba147a0f,Daniel,mail@danielluedecke.de,2018-07-31T10:15:33Z,Daniel,mail@danielluedecke.de,2018-07-31T10:15:33Z,close #389 and fix docs,R/html_print.R;R/sjTabCorr.R;R/sjTabFA.R;R/sjTabItemAnalysis.R;R/sjTabLinReg.R;R/sjTabOdds.R;R/sjTabPCA.R;R/sjTabPropTable.R;R/sjTabSPSS.R;R/tab_model.R;man/sjp.fa.Rd;man/sjp.pca.Rd;man/sjt.corr.Rd;man/sjt.fa.Rd;man/sjt.glm.Rd;man/sjt.glmer.Rd;man/sjt.itemanalysis.Rd;man/sjt.lm.Rd;man/sjt.lmer.Rd;man/sjt.pca.Rd;man/sjt.stackfrq.Rd;man/sjt.xtab.Rd;man/tab_df.Rd;man/tab_model.Rd;man/view_df.Rd,False,True,True,False,447,169,616,"---FILE: R/html_print.R---
@@ -33,7 +33,7 @@
 #'   alternatig colors (white and light grey by default).
 #' @param ... Currently not used.
 #'
-#' @inheritParams sjt.frq
+#' @inheritParams tab_model
 #'
 #' @return A list with following items:
 #'   \itemize{

---FILE: R/sjTabCorr.R---
@@ -23,7 +23,7 @@
 #'          where row and column item are identical (i.e. the ""self-correlation""). By defauilt,
 #'          this argument is \code{NULL} and the diagnal cells are empty.
 #'
-#' @inheritParams sjt.frq
+#' @inheritParams tab_model
 #' @inheritParams sjt.xtab
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjp.glmer

---FILE: R/sjTabFA.R---
@@ -13,7 +13,7 @@
 #' @inheritParams sjp.fa
 #' @inheritParams sjp.pca
 #' @inheritParams sjt.pca
-#' @inheritParams sjt.frq
+#' @inheritParams tab_model
 #' @inheritParams sjt.xtab
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjt.corr

---FILE: R/sjTabItemAnalysis.R---
@@ -53,7 +53,8 @@
 #'          After that, each case (df's row) has a scales sum score for each component.
 #'          Finally, a correlation of these ""scale sum scores"" is computed.
 #'
-#' @inheritParams sjt.frq
+#' @inheritParams tab_model
+#' @inheritParams sjt.xtab
 #' @inheritParams tab_df
 #'
 #' @return Invisibly returns

---FILE: R/sjTabLinReg.R---
@@ -105,7 +105,8 @@
 #'          office applications, it might be helpful not to add this separator column
 #'          when modifying the table layout.
 #'
-#' @inheritParams sjt.frq
+#' @inheritParams tab_model
+#' @inheritParams sjt.xtab
 #' @inheritParams sjp.lmer
 #' @inheritParams sjp.corr
 #'
@@ -1123,8 +1124,8 @@ sjt.lm <- function(...,
 #'                or saves them as file. The fitted models may have different
 #'                predictors, e.g. when comparing different stepwise fitted models.
 #'
-#' @inheritParams sjt.lm
-#' @inheritParams sjt.frq
+#' @inheritParams tab_model
+#' @inheritParams sjt.xtab
 #' @inheritParams sjp.corr
 #'
 #' @return Invisibly returns

---FILE: R/sjTabOdds.R---
@@ -32,7 +32,8 @@
 #'          for more details. It is recommended to inspect the model \code{\link{AIC}} (see \code{show.aic}) to get a
 #'          decision help for which model to choose.
 #'
-#' @inheritParams sjt.frq
+#' @inheritParams tab_model
+#' @inheritParams sjt.xtab
 #' @inheritParams sjt.lm
 #' @inheritParams sjp.corr
 #'
@@ -1036,7 +1037,8 @@ sjt.glm <- function(...,
 #'                e.g. when comparing different stepwise fitted models.
 #'
 #' @inheritParams sjt.glm
-#' @inheritParams sjt.frq
+#' @inheritParams tab_model
+#' @inheritParams sjt.xtab
 #' @inheritParams sjp.corr
 #'
 #' @return Invisibly returns

---FILE: R/sjTabPCA.R---
@@ -33,7 +33,7 @@
 #' @param string.cpov String for the table row that contains the cumulative variances. By default,
 #'          \emph{""Cumulative Proportion""} will be used.
 #'
-#' @inheritParams sjt.frq
+#' @inheritParams tab_model
 #' @inheritParams sjt.xtab
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjt.corr

---FILE: R/sjTabPropTable.R---
@@ -35,8 +35,22 @@
 #'          \code{""kendall""} or \code{""pearson""}. See 'Details'.
 #' @param ... Other arguments, currently passed down to the test statistics functions
 #'        \code{chisq.test()} or \code{fisher.test()}.
+#' @param encoding String, indicating the charset encoding used for variable and
+#'          value labels. Default is \code{NULL}, so encoding will be auto-detected
+#'          depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+#'          Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).
+#' @param no.output Logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
+#'          the viewer pane and not even saved to file. This option is useful when the html output
+#'          should be used in \code{knitr} documents. The html output can be accessed via the return
+#'          value.
+#' @param remove.spaces Logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
+#'          that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
+#'          may look less pretty, but it may help when exporting html-tables to office tools.
+#' @param value.labels Character vector (or \code{list} of character vectors)
+#'          with value labels of the supplied variables, which will be used
+#'          to label variable values in the output.
 #'
-#' @inheritParams sjt.frq
+#' @inheritParams tab_model
 #' @inheritParams sjp.glmer
 #' @inheritParams sjp.grpfrq
 #'

---FILE: R/sjTabSPSS.R---
@@ -43,7 +43,7 @@
 #'   bar is visible.
 #'
 #' @inheritParams tab_df
-#' @inheritParams sjt.frq
+#' @inheritParams tab_model
 #' @inheritParams sjt.xtab
 #' @inheritParams sjp.grpfrq
 #'

---FILE: R/tab_model.R---
@@ -116,6 +116,12 @@
 #' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions,
 #'    according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
 #'    See 'Details' or \href{../doc/table_css.html}{this package-vignette}.
+#' @param file Destination file, if the output should be saved as file.
+#'    If \code{NULL} (default), the output will be saved as temporary file and
+#'    openend either in the IDE's viewer pane or the default web browser.
+#' @param use.viewer Logical, if \code{TRUE}, the HTML table is shown in the IDE's
+#'    viewer pane. If \code{FALSE} or no viewer available, the HTML table is
+#'    opened in a web browser.
 #'
 #' @inheritParams plot_models
 #' @inheritParams plot_model
@@ -239,7 +245,9 @@ tab_model <- function(
   case = ""parsed"",
   auto.label = TRUE,
   bpe = ""median"",
-  CSS = css_theme(""regression"")
+  CSS = css_theme(""regression""),
+  file = NULL,
+  use.viewer = TRUE
 ) {
 
   p.val <- match.arg(p.val)
@@ -838,7 +846,9 @@ tab_model <- function(
     n.models = length(model.list),
     show.re.var = show.re.var,
     show.icc = show.icc,
-    CSS = CSS
+    CSS = CSS,
+    file = file,
+    use.viewer = use.viewer
   )
 }
 

---FILE: man/sjp.fa.Rd---
@@ -38,6 +38,8 @@ on 3 possible factors can not be clearly assigned to just one factor and thus wo
 from the principal component analysis. By default, the minimum difference of loading values
 between the highest and 2nd highest factor should be 0.1}
 
+\item{digits}{Amount of decimals for estimates}
+
 \item{title}{character vector, used as plot title. Depending on plot type and function,
 will be set automatically. If \code{title = """"}, no title is printed.
 For effect-plots, may also be a character vector of length > 1,

---FILE: man/sjp.pca.Rd---
@@ -31,6 +31,8 @@ between the highest and 2nd highest factor should be 0.1}
 \item{plot.eigen}{If \code{TRUE}, a plot showing the Eigenvalues according to the
 Kaiser criteria is plotted to determine the number of factors.}
 
+\item{digits}{Amount of decimals for estimates}
+
 \item{title}{character vector, used as plot title. Depending on plot type and function,
 will be set automatically. If \code{title = """"}, no title is printed.
 For effect-plots, may also be a character vector of length > 1,

---FILE: man/sjt.corr.Rd---
@@ -25,16 +25,15 @@ abbreviated.}
 \code{""spearman""} (default), \code{""pearson""} or \code{""kendall""}.
 May be abbreviated.}
 
-\item{title}{character vector, used as plot title. Depending on plot type and function,
-will be set automatically. If \code{title = """"}, no title is printed.
-For effect-plots, may also be a character vector of length > 1,
-to define titles for each sub-plot or facet.}
+\item{title}{String, will be used as table caption.}
 
 \item{var.labels}{Character vector with variable names, which will be used
 to label variables in the output.}
 
-\item{wrap.labels}{numeric, determines how many chars of the value, variable or axis
-labels are displayed in one line and when a line break is inserted.}
+\item{wrap.labels}{Numeric, determines how many chars of the value, variable
+or axis labels are displayed in one line and when a line break is inserted.}
+
+\item{show.p}{Logical, if \code{TRUE}, p-values are also printed.}
 
 \item{p.numeric}{Logical, if \code{TRUE}, the p-values are printed
 as numbers. If \code{FALSE} (default), asterisks are used.}
@@ -51,6 +50,8 @@ the HTML table, but made ""invisible"" with white foreground color. You can use th
 argument (\code{""css.valueremove""}) to change color and appearance of those correlation value that are smaller than
 the limit specified by \code{val.rm}.}
 
+\item{digits}{Amount of decimals for estimates}
+
 \item{triangle}{Indicates whether only the upper right (use \code{""upper""}), lower left (use \code{""lower""})
 or both (use \code{""both""}) triangles of the correlation table is filled with values. Default
 is \code{""both""}. You can specifiy the inital letter only.}
@@ -59,6 +60,32 @@ is \code{""both""}. You can specifiy the inital letter only.}
 correlated items) that can be used to display content in the diagonal cells
 where row and column item are identical (i.e. the ""self-correlation""). By defauilt,
 this argument is \code{NULL} and the diagnal cells are empty.}
+
+\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
+according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+See 'Details' or \href{../doc/table_css.html}{this package-vignette}.}
+
+\item{encoding}{String, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
+
+\item{file}{Destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
+
+\item{use.viewer}{Logical, if \code{TRUE}, the HTML table is shown in the IDE's
+viewer pane. If \code{FALSE} or no viewer available, the HTML table is
+opened in a web browser.}
+
+\item{no.output}{Logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
+the viewer pane and not even saved to file. This option is useful when the html output
+should be used in \code{knitr} documents. The html output can be accessed via the return
+value.}
+
+\item{remove.spaces}{Logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
+that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
+may look less pretty, but it may help when exporting html-tables to office tools.}
 }
 \value{
 Invisibly returns

---FILE: man/sjt.fa.Rd---
@@ -55,6 +55,34 @@ reliability test. The result is an alpha value for each factor dimension.
 Only applies when \code{data} is a data frame.}
 
 \item{show.comm}{Logical, if \code{TRUE}, show the communality column in the table.}
+
+\item{digits}{Amount of decimals for estimates}
+
+\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
+according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+See 'Details' or \href{../doc/table_css.html}{this package-vignette}.}
+
+\item{encoding}{String, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
+
+\item{file}{Destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
+
+\item{use.viewer}{Logical, if \code{TRUE}, the HTML table is shown in the IDE's
+viewer pane. If \code{FALSE} or no viewer available, the HTML table is
+opened in a web browser.}
+
+\item{no.output}{Logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
+the viewer pane and not even saved to file. This option is useful when the html output
+should be used in \code{knitr} documents. The html output can be accessed via the return
+value.}
+
+\item{remove.spaces}{Logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
+that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
+may look less pretty, but it may help when exporting html-tables to office tools.}
 }
 \value{
 Invisibly returns

---FILE: man/sjt.glm.Rd---
@@ -27,10 +27,16 @@ sjt.glm(..., pred.labels = NULL, depvar.labels = NULL,
 
 \item{pred.labels}{Character vector with labels of predictor variables.
 If not \code{NULL}, \code{pred.labels} will be used in the first
-table column with the predictors' names. If \code{NULL}, variable
-labels are set based on label attributes (see \code{\link[sjlabelled]{get_label}}).
-If \code{pred.labels = """"}, column names (vector names) are used
-as predictor labels. See 'Examples'.}
+table column with the predictors' names. By default, if \code{auto.label = TRUE}
+and \code{\link[sjlabelled]{get_term_labels}} is called to retrieve the labels
+of the coefficients, which will be used as predictor labels.
+If \code{pred.labels = """"} or \code{auto.label = FALSE}, the raw
+variable names as used in the model formula are used as predictor
+labels. If \code{pred.labels} is a named vector, predictor labels (by
+default, the names of the model's coefficients) will be matched with the
+names of \code{pred.labels}. This ensures that labels always match the
+related predictor in the table, no matter in which way the predictors
+are sorted. See 'Examples'.}
 
 \item{depvar.labels}{Character vector with labels of dependent
 variables of all fitted models. See 'Examples'.}
@@ -74,11 +80,12 @@ Default is \code{FALSE}.}
 between estimate and CI values. If \code{FALSE}, CI values are printed in the same
 line as estimate values.}
 
-\item{show.ci}{Logical, if \code{TRUE} (default), the confidence intervall is also printed to the table. Use
-\code{FALSE} to omit the CI in the table.}
+\item{show.ci}{Either logical, and if \code{TRUE}, the confidence intervals
+is printed to the table; if \code{FALSE}, confidence intervals are
+omitted. Or numeric, between 0 and 1, indicating the range of the
+confidence intervals.}
 
-\item{show.se}{Logical, if \code{TRUE}, the standard errors are also printed.
-Default is \code{FALSE}.}
+\item{show.se}{Logical, if \code{TRUE}, the standard errors are also printed.}
 
 \item{show.header}{Logical, if \code{TRUE}, the header strings \code{string.pred}
 and \code{string.dv} are shown. By default, they're hidden.}
@@ -91,24 +98,22 @@ in the model summary. R2cs is the Cox-Snell-pseudo R-squared value, R2n is Nagel
 pseudo R-squared value and \code{D} is Tjur's Coefficient of Discrimination
 (see \code{\link[sjstats]{cod}}).}
 
-\item{show.icc}{Logical, if \code{TRUE}, the intra-class-correlation for each
-model is printed in the model summary. Only applies to mixed models.}
+\item{show.icc}{Logical, if \code{TRUE}, prints the intraclass correlation
+coefficient for mixed models. See \code{\link[sjstats]{icc}} for details.}
 
-\item{show.re.var}{Logical, if \code{TRUE}, the variance parameters for the random
-effects for each model are printed in the model summary. Only applies to mixed models.
-For details output, see 'Note' in \code{\link[sjstats]{icc}}.}
+\item{show.re.var}{Logical, if \code{TRUE}, prints the random effect variances
+for mixed models. See \code{\link[sjstats]{re_var}} for details.}
 
 \item{show.loglik}{Logical, if \code{TRUE}, the Log-Likelihood for each model is printed
 in the model summary. Default is \code{FALSE}.}
 
 \item{show.aic}{Logical, if \code{TRUE}, the AIC value for each model is printed
-in the model summary. Default is \code{FALSE}.}
+in the table summary.}
 
 \item{show.aicc}{Logical, if \code{TRUE}, the second-order AIC value for each model
-is printed in the model summary. Default is \code{FALSE}.}
+is printed in the table summary.}
 
-\item{show.dev}{Logical, if \code{TRUE}, the deviance for each model
-is printed in the model summary.}
+\item{show.dev}{Logical, if \code{TRUE}, shows the deviance of the model.}
 
 \item{show.hoslem}{Logical, if \code{TRUE}, a Hosmer-Lemeshow-Goodness-of-fit-test is
 performed. A well-fitting model shows no significant difference between
@@ -153,7 +158,7 @@ May be an HTML entity. See 'Examples'.}
 
 \item{digits.est}{Amount of decimals for table values.}
 
-\item{digits.p}{Amount of decimals for p-values.}
+\item{digits.p}{Amount of decimals for p-values}
 
 \item{digits.ci}{Amount of decimals for confidence intervals.}
 
@@ -174,6 +179,32 @@ each model column, to add margins between model columns. By default, this
 column will be added to the output; however, when copying tables to
 office applications, it might be helpful not to add this separator column
 when modifying the table layout.}
+
+\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
+according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+See 'Details' or \href{../doc/table_css.html}{this package-vignette}.}
+
+\item{encoding}{String, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
+
+\item{file}{Destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
+
+\item{use.viewer}{Logical, if \code{TRUE}, the HTML table is shown in the IDE's
+viewer pane. If \code{FALSE} or no viewer available, the HTML table is
+opened in a web browser.}
+
+\item{no.output}{Logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
+the viewer pane and not even saved to file. This option is useful when the html output
+should be used in \code{knitr} documents. The html output can be accessed via the return
+value.}
+
+\item{remove.spaces}{Logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
+that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
+may look less pretty, but it may help when exporting html-tables to office tools.}
 }
 \value{
 Invisibly returns

---FILE: man/sjt.glmer.Rd---
@@ -26,10 +26,16 @@ sjt.glmer(..., pred.labels = NULL, depvar.labels = NULL,
 
 \item{pred.labels}{Character vector with labels of predictor variables.
 If not \code{NULL}, \code{pred.labels} will be used in the first
-table column with the predictors' names. If \code{NULL}, variable
-labels are set based on label attributes (see \code{\link[sjlabelled]{get_label}}).
-If \code{pred.labels = """"}, column names (vector names) are used
-as predictor labels. See 'Examples'.}
+table column with the predictors' names. By default, if \code{auto.label = TRUE}
+and \code{\link[sjlabelled]{get_term_labels}} is called to retrieve the labels
+of the coefficients, which will be used as predictor labels.
+If \code{pred.labels = """"} or \code{auto.label = FALSE}, the raw
+variable names as used in the model formula are used as predictor
+labels. If \code{pred.labels} is a named vector, predictor labels (by
+default, the names of the model's coefficients) will be matched with the
+names of \code{pred.labels}. This ensures that labels always match the
+related predictor in the table, no matter in which way the predictors
+are sorted. See 'Examples'.}
 
 \item{depvar.labels}{Character vector with labels of dependent
 variables of all fitted models. See 'Examples'.}
@@ -68,11 +74,12 @@ Default is \code{FALSE}.}
 between estimate and CI values. If \code{FALSE}, CI values are printed in the same
 line as estimate values.}
 
-\item{show.ci}{Logical, if \code{TRUE} (default), the confidence intervall is also printed to the table. Use
-\code{FALSE} to omit the CI in the table.}
+\item{show.ci}{Either logical, and if \code{TRUE}, the confidence intervals
+is printed to the table; if \code{FALSE}, confidence intervals are
+omitted. Or numeric, between 0 and 1, indicating the range of the
+confidence intervals.}
 
-\item{show.se}{Logical, if \code{TRUE}, the standard errors are also printed.
-Default is \code{FALSE}.}
+\item{show.se}{Logical, if \code{TRUE}, the standard errors are also printed.}
 
 \item{show.header}{Logical, if \code{TRUE}, the header strings \code{string.pred}
 and \code{string.dv} are shown. By default, they're hidden.}
@@ -85,24 +92,22 @@ in the model summary. R2cs is the Cox-Snell-pseudo R-squared value, R2n is Nagel
 pseudo R-squared value and \code{D} is Tjur's Coefficient of Discrimination
 (see \code{\link[sjstats]{cod}}).}
 
-\item{show.icc}{Logical, if \code{TRUE}, the intra-class-correlation for each
-model is printed in the model summary. Only applies to mixed models.}
+\item{show.icc}{Logical, if \code{TRUE}, prints the intraclass correlation
+coefficient for mixed models. See \code{\link[sjstats]{icc}} for details.}
 
-\item{show.re.var}{Logical, if \code{TRUE}, the variance parameters for the random
-effects for each model are printed in the model summary. Only applies to mixed models.
-For details output, see 'Note' in \code{\link[sjstats]{icc}}.}
+\item{show.re.var}{Logical, if \code{TRUE}, prints the random effect variances
+for mixed models. See \code{\link[sjstats]{re_var}} for details.}
 
 \item{show.loglik}{Logical, if \code{TRUE}, the Log-Likelihood for each model is printed
 in the model summary. Default is \code{FALSE}.}
 
 \item{show.aic}{Logical, if \code{TRUE}, the AIC value for each model is printed
-in the model summary. Default is \code{FALSE}.}
+in the table summary.}
 
 \item{show.aicc}{Logical, if \code{TRUE}, the second-order AIC value for each model
-is printed in the model summary. Default is \code{FALSE}.}
+is printed in the table summary.}
 
-\item{show.dev}{Logical, if \code{TRUE}, the deviance for each model
-is printed in the model summary.}
+\item{show.dev}{Logical, if \code{TRUE}, shows the deviance of the model.}
 
 \item{show.hoslem}{Logical, if \code{TRUE}, a Hosmer-Lemeshow-Goodness-of-fit-test is
 performed. A well-fitting model shows no significant difference between
@@ -140,7 +145,7 @@ May be an HTML entity. See 'Examples'.}
 
 \item{digits.est}{Amount of decimals for table values.}
 
-\item{digits.p}{Amount of decimals for p-values.}
+\item{digits.p}{Amount of decimals for p-values}
 
 \item{digits.ci}{Amount of decimals for confidence intervals.}
 
@@ -161,6 +166,32 @@ each model column, to add margins between model columns. By default, this
 column will be added to the output; however, when copying tables to
 office applications, it might be helpful not to add this separator column
 when modifying the table layout.}
+
+\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
+according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+See 'Details' or \href{../doc/table_css.html}{this package-vignette}.}
+
+\item{encoding}{String, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
+
+\item{file}{Destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
+
+\item{use.viewer}{Logical, if \code{TRUE}, the HTML table is shown in the IDE's
+viewer pane. If \code{FALSE} or no viewer available, the HTML table is
+opened in a web browser.}
+
+\item{no.output}{Logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
+the viewer pane and not even saved to file. This option is useful when the html output
+should be used in \code{knitr} documents. The html output can be accessed via the return
+value.}
+
+\item{remove.spaces}{Logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
+that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
+may look less pretty, but it may help when exporting html-tables to office tools.}
 }
 \value{
 Invisibly returns

---FILE: man/sjt.itemanalysis.Rd---
@@ -54,10 +54,31 @@ each component (a component is represented by each group of \code{factor.groups}
 After that, each case (df's row) has a scales sum score for each component.
 Finally, a correlation of these ""scale sum scores"" is computed.}
 
-\item{encoding}{Character vector, indicating the charset encoding used
-for variable and value labels. Default is \code{""UTF-8""}. For Windows
-Systems, \code{encoding = ""Windows-1252""} might be necessary for proper
-display of special characters.}
+\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
+according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+See 'Details' or \href{../doc/table_css.html}{this package-vignette}.}
+
+\item{encoding}{String, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
+
+\item{file}{Destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
+
+\item{use.viewer}{Logical, if \code{TRUE}, the HTML table is shown in the IDE's
+viewer pane. If \code{FALSE} or no viewer available, the HTML table is
+opened in a web browser.}
+
+\item{no.output}{Logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
+the viewer pane and not even saved to file. This option is useful when the html output
+should be used in \code{knitr} documents. The html output can be accessed via the return
+value.}
+
+\item{remove.spaces}{Logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
+that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
+may look less pretty, but it may help when exporting html-tables to office tools.}
 }
 \value{
 Invisibly returns

---FILE: man/sjt.lm.Rd---
@@ -165,6 +165,32 @@ each model column, to add margins between model columns. By default, this
 column will be added to the output; however, when copying tables to
 office applications, it might be helpful not to add this separator column
 when modifying the table layout.}
+
+\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
+according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+See 'Details' or \href{../doc/table_css.html}{this package-vignette}.}
+
+\item{encoding}{String, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
+
+\item{file}{Destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
+
+\item{use.viewer}{Logical, if \code{TRUE}, the HTML table is shown in the IDE's
+viewer pane. If \code{FALSE} or no viewer available, the HTML table is
+opened in a web browser.}
+
+\item{no.output}{Logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
+the viewer pane and not even saved to file. This option is useful when the html output
+should be used in \code{knitr} documents. The html output can be accessed via the return
+value.}
+
+\item{remove.spaces}{Logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
+that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
+may look less pretty, but it may help when exporting html-tables to office tools.}
 }
 \value{
 Invisibly returns

---FILE: man/sjt.lmer.Rd---
@@ -24,103 +24,64 @@ sjt.lmer(..., pred.labels = NULL, depvar.labels = NULL,
   no.output = FALSE, remove.spaces = TRUE)
 }
 \arguments{
-\item{...}{One or more fitted linear (mixed) models.}
+\item{...}{One or more regression models, including glm's or mixed models.
+May also be a \code{list} with fitted models. See 'Examples'.}
 
 \item{pred.labels}{Character vector with labels of predictor variables.
 If not \code{NULL}, \code{pred.labels} will be used in the first
-table column with the predictors' names. If \code{NULL}, variable
-labels are set based on label attributes (see \code{\link[sjlabelled]{get_label}}).
-If \code{pred.labels = """"}, column names (vector names) are used
-as predictor labels. See 'Examples'.}
-
-\item{depvar.labels}{Character vector with labels of dependent
-variables of all fitted models. See 'Examples'.}
-
-\item{remove.estimates}{Numeric vector with indices (order equals to row index of \code{coef(fit)})
-or character vector with coefficient names that indicate which estimates should be removed
-from the table output. The first estimate is the intercept, followed by the model predictors.
-\emph{The intercept cannot be removed from the table output!} \code{remove.estimates = c(2:4)}
-would remove the 2nd to the 4th estimate (1st to 3rd predictor after intercept) from the output.
-\code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default
-is \code{NULL}, i.e. all estimates are printed.}
-
-\item{group.pred}{Logical, if \code{TRUE} (default), automatically groups table rows with
-factor levels of same factor, i.e. predictors of type \code{\link{factor}} will
-be grouped, if the factor has more than two levels. Grouping means that a separate headline
-row is inserted to the table just before the predictor values.}
+table column with the predictors' names. By default, if \code{auto.label = TRUE}
+and \code{\link[sjlabelled]{get_term_labels}} is called to retrieve the labels
+of the coefficients, which will be used as predictor labels.
+If \code{pred.labels = """"} or \code{auto.label = FALSE}, the raw
+variable names as used in the model formula are used as predictor
+labels. If \code{pred.labels} is a named vector, predictor labels (by
+default, the names of the model's coefficients) will be matched with the
+names of \code{pred.labels}. This ensures that labels always match the
+related predictor in the table, no matter in which way the predictors
+are sorted. See 'Examples'.}
 
 \item{p.numeric}{Logical, if \code{TRUE}, the p-values are printed
 as numbers. If \code{FALSE} (default), asterisks are used.}
 
 \item{emph.p}{Logical, if \code{TRUE}, significant p-values are shown bold faced.}
 
-\item{p.zero}{logical, if \code{TRUE}, p-values have a leading 0 before the
-period (e.g. \emph{0.002}), else p-values start with a period and
-without a zero (e.g. \emph{.002}).}
-
-\item{separate.ci.col}{Logical, if \code{TRUE}, the CI values are shown in a separate table column.
-Default is \code{FALSE}.}
-
-\item{newline.ci}{Logical, if \code{TRUE} and \code{separate.ci.col = FALSE}, inserts a line break
-between estimate and CI values. If \code{FALSE}, CI values are printed in the same
-line as estimate values.}
-
-\item{show.est}{Logical, if \code{TRUE} (default), the estimates are printed.}
+\item{show.est}{Logical, if \code{TRUE}, the estimates are printed.}
 
 \item{show.std}{Indicates whether standardized beta-coefficients should
 also printed, and if yes, which type of standardization is done.
 See 'Details'.}
 
-\item{show.ci}{Logical, if \code{TRUE} (default), the confidence intervall is also printed to the table. Use
-\code{FALSE} to omit the CI in the table.}
+\item{show.ci}{Either logical, and if \code{TRUE}, the confidence intervals
+is printed to the table; if \code{FALSE}, confidence intervals are
+omitted. Or numeric, between 0 and 1, indicating the range of the
+confidence intervals.}
 
-\item{show.se}{Logical, if \code{TRUE}, the standard errors are also printed.
-Default is \code{FALSE}.}
+\item{show.se}{Logical, if \code{TRUE}, the standard errors are also printed.}
 
-\item{show.header}{Logical, if \code{TRUE}, the header strings \code{string.pred}
-and \code{string.dv} are shown. By default, they're hidden.}
+\item{show.r2}{Logical, if \code{TRUE}, the r-squared value is also printed.
+Depending on the model, these might be pseudo-r-squared values, or Bayesian
+r-squared etc. See \code{\link[sjstats]{r2}} for details.}
 
-\item{show.col.header}{Logical, if \code{TRUE} (default), the table data columns have a headline with
-abbreviations for estimates, std. beta-values, confidence interval and p-values.}
+\item{show.icc}{Logical, if \code{TRUE}, prints the intraclass correlation
+coefficient for mixed models. See \code{\link[sjstats]{icc}} for details.}
 
-\item{show.r2}{Logical, if \code{TRUE} (default), the R2 and adjusted R2 values for each model are printed
-in the model summary. For linear mixed models, the R2 and Omega-squared values are printed
-(see \code{\link[sjstats]{r2}} for details).}
+\item{show.re.var}{Logical, if \code{TRUE}, prints the random effect variances
+for mixed models. See \code{\link[sjstats]{re_var}} for details.}
 
-\item{show.icc}{Logical, if \code{TRUE}, the intra-class-correlation for each
-model is printed in the model summary. Only applies to mixed models.}
-
-\item{show.re.var}{Logical, if \code{TRUE}, the variance parameters for the random
-effects for each model are printed in the model summary. Only applies to mixed models.
-For details output, see 'Note' in \code{\link[sjstats]{icc}}.}
-
-\item{show.fstat}{Logical, if \code{TRUE}, the F-statistics for each model is printed
-in the model summary. Default is \code{FALSE}. This argument does not apply to
-\code{\link{sjt.lmer}}.}
+\item{show.fstat}{Logical, if \code{TRUE}, the F-statistics for each model is
+printed in the table summary. This option is not supported by all model types.}
 
 \item{show.aic}{Logical, if \code{TRUE}, the AIC value for each model is printed
-in the model summary. Default is \code{FALSE}.}
+in the table summary.}
 
 \item{show.aicc}{Logical, if \code{TRUE}, the second-order AIC value for each model
-is printed in the model summary. Default is \code{FALSE}.}
+is printed in the table summary.}
 
-\item{show.dev}{Logical, if \code{TRUE}, the deviance for each model
-is printed in the model summary.}
+\item{show.dev}{Logical, if \code{TRUE}, shows the deviance of the model.}
 
 \item{string.pred}{Character vector,used as headline for the predictor column.
 Default is \code{""Predictors""}.}
 
-\item{string.dv}{Character vector, used as headline for the
-dependent variable columns. Default is \code{""Dependent Variables""}.}
-
-\item{string.interc}{Character vector, used as headline for the Intercept row.
-Default is \code{""Intercept""}.}
-
-\item{string.obs}{character vector, used in the summary row for the count of observation
-(cases). Default is \code{""Observations""}.}
-
-\item{string.est}{Character vector, used for the column heading of estimates.}
-
 \item{string.std}{Character vector, used for the column heading of standardized beta coefficients. Default is \code{""std. Beta""}.}
 
 \item{string.ci}{Character vector, used for the column heading of confidence interval values. Default is \code{""CI""}.}
@@ -135,31 +96,33 @@ May be an HTML entity. See 'Examples'.}
 \item{minus.sign}{string, indicating the minus sign for negative numbers.
 May be an HTML entity. See 'Examples'.}
 
-\item{digits.est}{Amount of decimals for table values.}
-
-\item{digits.std}{Amount of decimals for standardized beta.}
-
-\item{digits.p}{Amount of decimals for p-values.}
+\item{digits.p}{Amount of decimals for p-values}
 
-\item{digits.ci}{Amount of decimals for confidence intervals.}
+\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
+according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+See 'Details' or \href{../doc/table_css.html}{this package-vignette}.}
 
-\item{digits.se}{Amount of decimals for standard error.}
+\item{encoding}{String, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
 
-\item{digits.summary}{Amount of decimals for values in model summary.}
+\item{file}{Destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
 
-\item{cell.spacing}{Numeric, inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
-suitable for viewing the table. Decrease this value (0.05 to 0.1) if you want to import the table
-into Office documents. This is a convenient argument for the \code{CSS} argument for changing
-cell spacing, which would be: \code{CSS = list(css.thead = ""padding:0.2cm;"", css.tdata = ""padding:0.2cm;"")}.}
+\item{use.viewer}{Logical, if \code{TRUE}, the HTML table is shown in the IDE's
+viewer pane. If \code{FALSE} or no viewer available, the HTML table is
+opened in a web browser.}
 
-\item{cell.gpr.indent}{Indent for table rows with grouped factor predictors. Only applies
-if \code{group.pred = TRUE}.}
+\item{no.output}{Logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
+the viewer pane and not even saved to file. This option is useful when the html output
+should be used in \code{knitr} documents. The html output can be accessed via the return
+value.}
 
-\item{sep.column}{Logical, if \code{TRUE}, an empty table column is added after
-each model column, to add margins between model columns. By default, this
-column will be added to the output; however, when copying tables to
-office applications, it might be helpful not to add this separator column
-when modifying the table layout.}
+\item{remove.spaces}{Logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
+that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
+may look less pretty, but it may help when exporting html-tables to office tools.}
 }
 \value{
 Invisibly returns

---FILE: man/sjt.pca.Rd---
@@ -30,16 +30,13 @@ on 3 possible factors can not be clearly assigned to just one factor and thus wo
 from the principal component analysis. By default, the minimum difference of loading values
 between the highest and 2nd highest factor should be 0.1}
 
-\item{title}{character vector, used as plot title. Depending on plot type and function,
-will be set automatically. If \code{title = """"}, no title is printed.
-For effect-plots, may also be a character vector of length > 1,
-to define titles for each sub-plot or facet.}
+\item{title}{String, will be used as table caption.}
 
 \item{var.labels}{Character vector with variable names, which will be used
 to label variables in the output.}
 
-\item{wrap.labels}{numeric, determines how many chars of the value, variable or axis
-labels are displayed in one line and when a line break is inserted.}
+\item{wrap.labels}{Numeric, determines how many chars of the value, variable
+or axis labels are displayed in one line and when a line break is inserted.}
 
 \item{show.cronb}{Logical, if \code{TRUE} (default), the cronbach's alpha value for each factor scale will be calculated,
 i.e. all variables with the highest loading for a factor are taken for the
@@ -52,11 +49,39 @@ dor each component.}
 \item{show.var}{Logical, if \code{TRUE}, the proportions of variances for each component as well as cumulative
 variance are shown in the table footer.}
 
+\item{digits}{Amount of decimals for estimates}
+
 \item{string.pov}{String for the table row that contains the proportions of variances. By default,
 \emph{""Proportion of Variance""} will be used.}
 
 \item{string.cpov}{String for the table row that contains the cumulative variances. By default,
 \emph{""Cumulative Proportion""} will be used.}
+
+\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
+according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+See 'Details' or \href{../doc/table_css.html}{this package-vignette}.}
+
+\item{encoding}{String, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
+
+\item{file}{Destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
+
+\item{use.viewer}{Logical, if \code{TRUE}, the HTML table is shown in the IDE's
+viewer pane. If \code{FALSE} or no viewer available, the HTML table is
+opened in a web browser.}
+
+\item{no.output}{Logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
+the viewer pane and not even saved to file. This option is useful when the html output
+should be used in \code{knitr} documents. The html output can be accessed via the return
+value.}
+
+\item{remove.spaces}{Logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
+that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
+may look less pretty, but it may help when exporting html-tables to office tools.}
 }
 \value{
 Invisibly returns

---FILE: man/sjt.stackfrq.Rd---
@@ -20,14 +20,15 @@ sjt.stackfrq(items, weight.by = NULL, title = NULL,
 Must be a vector of same length as the input vector. Default is
 \code{NULL}, so no weights are used.}
 
-\item{title}{character vector, used as plot title. Depending on plot type and function,
-will be set automatically. If \code{title = """"}, no title is printed.
-For effect-plots, may also be a character vector of length > 1,
-to define titles for each sub-plot or facet.}
+\item{title}{String, will be used as table caption.}
 
 \item{var.labels}{Character vector with variable names, which will be used
 to label variables in the output.}
 
+\item{value.labels}{Character vector (or \code{list} of character vectors)
+with value labels of the supplied variables, which will be used
+to label variable values in the output.}
+
 \item{wrap.labels}{numeric, determines how many chars of the value, variable or axis
 labels are displayed in one line and when a line break is inserted.}
 
@@ -41,6 +42,8 @@ by highest count of first or last category of \code{items}.
   \item or \code{NULL} (default) for no sorting.
 }}
 
+\item{digits}{Amount of decimals for estimates}
+
 \item{string.total}{label for the total N column.}
 
 \item{string.na}{label for the missing column/row.}
@@ -64,10 +67,31 @@ and \code{\link[psych]{describe}} in the \code{psych}-package for more details.}
 \item{digits.stats}{amount of digits for rounding the skewness and kurtosis valuess.
 Default is 2, i.e. skewness and kurtosis values have 2 digits after decimal point.}
 
-\item{encoding}{Character vector, indicating the charset encoding used
-for variable and value labels. Default is \code{""UTF-8""}. For Windows
-Systems, \code{encoding = ""Windows-1252""} might be necessary for proper
-display of special characters.}
+\item{file}{Destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
+
+\item{encoding}{String, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
+
+\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
+according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+See 'Details' or \href{../doc/table_css.html}{this package-vignette}.}
+
+\item{use.viewer}{Logical, if \code{TRUE}, the HTML table is shown in the IDE's
+viewer pane. If \code{FALSE} or no viewer available, the HTML table is
+opened in a web browser.}
+
+\item{no.output}{Logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
+the viewer pane and not even saved to file. This option is useful when the html output
+should be used in \code{knitr} documents. The html output can be accessed via the return
+value.}
+
+\item{remove.spaces}{Logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
+that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
+may look less pretty, but it may help when exporting html-tables to office tools.}
 }
 \value{
 Invisibly returns

---FILE: man/sjt.xtab.Rd---
@@ -26,14 +26,15 @@ sjt.xtab(var.row, var.col, weight.by = NULL, title = NULL,
 Must be a vector of same length as the input vector. Default is
 \code{NULL}, so no weights are used.}
 
-\item{title}{character vector, used as plot title. Depending on plot type and function,
-will be set automatically. If \code{title = """"}, no title is printed.
-For effect-plots, may also be a character vector of length > 1,
-to define titles for each sub-plot or facet.}
+\item{title}{String, will be used as table caption.}
 
 \item{var.labels}{Character vector with variable names, which will be used
 to label variables in the output.}
 
+\item{value.labels}{Character vector (or \code{list} of character vectors)
+with value labels of the supplied variables, which will be used
+to label variable values in the output.}
+
 \item{wrap.labels}{numeric, determines how many chars of the value, variable or axis
 labels are displayed in one line and when a line break is inserted.}
 
@@ -63,6 +64,8 @@ be one of \code{""auto""}, \code{""cramer""}, \code{""phi""}, \code{""spearman""},
 
 \item{string.total}{Character label for the total column / row header}
 
+\item{digits}{Amount of decimals for estimates}
+
 \item{tdcol.n}{Color for highlighting count (observed) values in table cells. Default is black.}
 
 \item{tdcol.expected}{Color for highlighting expected values in table cells. Default is cyan.}
@@ -86,6 +89,32 @@ the percentage value.}
 \item{hundret}{Default value that indicates the 100-percent column-sums (since rounding values
 may lead to non-exact results). Default is \code{""100.0""}.}
 
+\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
+according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+See 'Details' or \href{../doc/table_css.html}{this package-vignette}.}
+
+\item{encoding}{String, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
+
+\item{file}{Destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
+
+\item{use.viewer}{Logical, if \code{TRUE}, the HTML table is shown in the IDE's
+viewer pane. If \code{FALSE} or no viewer available, the HTML table is
+opened in a web browser.}
+
+\item{no.output}{Logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
+the viewer pane and not even saved to file. This option is useful when the html output
+should be used in \code{knitr} documents. The html output can be accessed via the return
+value.}
+
+\item{remove.spaces}{Logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
+that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
+may look less pretty, but it may help when exporting html-tables to office tools.}
+
 \item{...}{Other arguments, currently passed down to the test statistics functions
 \code{chisq.test()} or \code{fisher.test()}.}
 }

---FILE: man/tab_df.Rd---
@@ -52,6 +52,18 @@ for variable and value labels. Default is \code{""UTF-8""}. For Windows
 Systems, \code{encoding = ""Windows-1252""} might be necessary for proper
 display of special characters.}
 
+\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
+according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+See 'Details' or \href{../doc/table_css.html}{this package-vignette}.}
+
+\item{file}{Destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
+
+\item{use.viewer}{Logical, if \code{TRUE}, the HTML table is shown in the IDE's
+viewer pane. If \code{FALSE} or no viewer available, the HTML table is
+opened in a web browser.}
+
 \item{...}{Currently not used.}
 }
 \value{

---FILE: man/tab_model.Rd---
@@ -20,7 +20,7 @@ tab_model(..., transform, show.intercept = TRUE, show.est = TRUE,
   collapse.ci = FALSE, collapse.se = FALSE, linebreak = TRUE,
   digits = 2, digits.p = 3, emph.p = TRUE, p.val = c(""wald"", ""kr""),
   case = ""parsed"", auto.label = TRUE, bpe = ""median"",
-  CSS = css_theme(""regression""))
+  CSS = css_theme(""regression""), file = NULL, use.viewer = TRUE)
 }
 \arguments{
 \item{...}{One or more regression models, including glm's or mixed models.
@@ -209,6 +209,14 @@ calculate the mean value of the posterior distribution.}
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
 according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
 See 'Details' or \href{../doc/table_css.html}{this package-vignette}.}
+
+\item{file}{Destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
+
+\item{use.viewer}{Logical, if \code{TRUE}, the HTML table is shown in the IDE's
+viewer pane. If \code{FALSE} or no viewer available, the HTML table is
+opened in a web browser.}
 }
 \value{
 Invisibly returns

---FILE: man/view_df.Rd---
@@ -62,17 +62,38 @@ can be truncated.}
 variable names. By default, rows (variables) are ordered according to their
 order in the data frame.}
 
-\item{wrap.labels}{numeric, determines how many chars of the value, variable or axis
-labels are displayed in one line and when a line break is inserted.}
+\item{wrap.labels}{Numeric, determines how many chars of the value, variable
+or axis labels are displayed in one line and when a line break is inserted.}
 
 \item{hide.progress}{logical, if \code{TRUE}, the progress bar that is displayed
 when creating the output is hidden. Default in \code{FALSE}, hence the
 bar is visible.}
 
+\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions,
+according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+See 'Details' or \href{../doc/table_css.html}{this package-vignette}.}
+
 \item{encoding}{Character vector, indicating the charset encoding used
 for variable and value labels. Default is \code{""UTF-8""}. For Windows
 Systems, \code{encoding = ""Windows-1252""} might be necessary for proper
 display of special characters.}
+
+\item{file}{Destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
+
+\item{use.viewer}{Logical, if \code{TRUE}, the HTML table is shown in the IDE's
+viewer pane. If \code{FALSE} or no viewer available, the HTML table is
+opened in a web browser.}
+
+\item{no.output}{Logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
+the viewer pane and not even saved to file. This option is useful when the html output
+should be used in \code{knitr} documents. The html output can be accessed via the return
+value.}
+
+\item{remove.spaces}{Logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
+that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
+may look less pretty, but it may help when exporting html-tables to office tools.}
 }
 \value{
 Invisibly returns"
strengejacke,sjPlot,c3dbca38574c74918657ee711a4df1abef5fe1f5,Daniel,mail@danielluedecke.de,2018-07-30T22:51:51Z,Daniel,mail@danielluedecke.de,2018-07-30T22:51:51Z,"fix conflicts, update docs",DESCRIPTION;man/dist_f.Rd;man/plot_model.Rd;man/plot_models.Rd;man/save_plot.Rd;man/set_theme.Rd;man/sjPlot-themes.Rd;man/sjc.cluster.Rd;man/sjc.dend.Rd;man/sjc.grpdisc.Rd;man/sjc.kgap.Rd;man/sjc.qclus.Rd;man/sjp.aov1.Rd;man/sjp.corr.Rd;man/sjp.fa.Rd;man/sjp.frq.Rd;man/sjp.gpt.Rd;man/sjp.likert.Rd;man/sjp.pca.Rd;man/sjp.resid.Rd;man/sjp.stackfrq.Rd;man/sjp.xtab.Rd;man/sjplot.Rd;man/sjt.corr.Rd;man/sjt.fa.Rd;man/sjt.glm.Rd;man/sjt.itemanalysis.Rd;man/sjt.lm.Rd;man/sjt.lmer.Rd;man/sjt.pca.Rd;man/sjt.stackfrq.Rd;man/sjt.xtab.Rd;man/tab_model.Rd,False,False,False,False,227,201,428,"---FILE: DESCRIPTION---
@@ -2,8 +2,6 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 2.5.0
-Date: 2018-07-10
 Version: 2.5.0.9000
 Date: 2018-07-23
 Authors@R: c(
@@ -69,5 +67,5 @@ Suggests:
     Zelig
 URL: https://strengejacke.github.io/sjPlot/
 BugReports: https://github.com/strengejacke/sjPlot/issues
-RoxygenNote: 6.0.1
+RoxygenNote: 6.1.0
 VignetteBuilder: knitr

---FILE: man/dist_f.Rd---
@@ -4,8 +4,8 @@
 \alias{dist_f}
 \title{Plot F distributions}
 \usage{
-dist_f(f = NULL, deg.f1 = NULL, deg.f2 = NULL, p = NULL, xmax = NULL,
-  geom.colors = NULL, geom.alpha = 0.7)
+dist_f(f = NULL, deg.f1 = NULL, deg.f2 = NULL, p = NULL,
+  xmax = NULL, geom.colors = NULL, geom.alpha = 0.7)
 }
 \arguments{
 \item{f}{Numeric, optional. If specified, an F distribution with \code{deg.f1} and \code{deg.f2} degrees

---FILE: man/plot_model.Rd---
@@ -5,27 +5,28 @@
 \alias{get_model_data}
 \title{Plot regression models}
 \usage{
-plot_model(model, type = c(""est"", ""re"", ""eff"", ""pred"", ""int"", ""std"", ""std2"",
-  ""slope"", ""resid"", ""diag""), transform, terms = NULL, sort.est = NULL,
-  rm.terms = NULL, group.terms = NULL, order.terms = NULL,
-  pred.type = c(""fe"", ""re""), mdrt.values = c(""minmax"", ""meansd"", ""zeromax"",
-  ""quart"", ""all""), ri.nr = NULL, title = NULL, axis.title = NULL,
+plot_model(model, type = c(""est"", ""re"", ""eff"", ""pred"", ""int"", ""std"",
+  ""std2"", ""slope"", ""resid"", ""diag""), transform, terms = NULL,
+  sort.est = NULL, rm.terms = NULL, group.terms = NULL,
+  order.terms = NULL, pred.type = c(""fe"", ""re""),
+  mdrt.values = c(""minmax"", ""meansd"", ""zeromax"", ""quart"", ""all""),
+  ri.nr = NULL, title = NULL, axis.title = NULL,
   axis.labels = NULL, legend.title = NULL, wrap.title = 50,
-  wrap.labels = 25, axis.lim = NULL, grid.breaks = NULL, ci.lvl = NULL,
-  se = NULL, colors = ""Set1"", show.intercept = FALSE,
-  show.values = FALSE, show.p = TRUE, show.data = FALSE,
-  show.legend = TRUE, show.zeroinf = TRUE, value.offset = NULL,
-  value.size, jitter = NULL, digits = 2, dot.size = NULL,
-  line.size = NULL, vline.color = NULL, grid, case, auto.label = TRUE,
-  prefix.labels = c(""none"", ""varname"", ""label""), bpe = ""median"",
-  bpe.style = ""line"", bpe.color = ""white"", ...)
+  wrap.labels = 25, axis.lim = NULL, grid.breaks = NULL,
+  ci.lvl = NULL, se = NULL, colors = ""Set1"",
+  show.intercept = FALSE, show.values = FALSE, show.p = TRUE,
+  show.data = FALSE, show.legend = TRUE, show.zeroinf = TRUE,
+  value.offset = NULL, value.size, jitter = NULL, digits = 2,
+  dot.size = NULL, line.size = NULL, vline.color = NULL, grid, case,
+  auto.label = TRUE, prefix.labels = c(""none"", ""varname"", ""label""),
+  bpe = ""median"", bpe.style = ""line"", bpe.color = ""white"", ...)
 
 get_model_data(model, type = c(""est"", ""re"", ""eff"", ""pred"", ""int"", ""std"",
   ""std2"", ""slope"", ""resid"", ""diag""), transform, terms = NULL,
   sort.est = NULL, rm.terms = NULL, group.terms = NULL,
   order.terms = NULL, pred.type = c(""fe"", ""re""), ri.nr = NULL,
-  ci.lvl = NULL, colors = ""Set1"", grid, case = ""parsed"", digits = 2,
-  ...)
+  ci.lvl = NULL, colors = ""Set1"", grid, case = ""parsed"",
+  digits = 2, ...)
 }
 \arguments{
 \item{model}{A regression model object. Depending on the \code{type}, many

---FILE: man/plot_models.Rd---
@@ -4,16 +4,16 @@
 \alias{plot_models}
 \title{Forest plot of multiple regression models}
 \usage{
-plot_models(..., transform, std.est = NULL, rm.terms = NULL, title = NULL,
-  m.labels = NULL, legend.title = ""Dependent Variables"",
-  legend.pval.title = ""p-level"", axis.labels = NULL, axis.title = NULL,
-  axis.lim = NULL, wrap.title = 50, wrap.labels = 25,
-  wrap.legend.title = 20, grid.breaks = NULL, dot.size = 3,
-  spacing = 0.4, colors = ""Set1"", show.values = FALSE,
-  show.legend = TRUE, show.intercept = FALSE, show.p = TRUE,
-  p.shape = FALSE, ci.lvl = 0.95, vline.color = NULL, digits = 2,
-  grid = FALSE, auto.label = TRUE, prefix.labels = c(""none"", ""varname"",
-  ""label""))
+plot_models(..., transform, std.est = NULL, rm.terms = NULL,
+  title = NULL, m.labels = NULL,
+  legend.title = ""Dependent Variables"", legend.pval.title = ""p-level"",
+  axis.labels = NULL, axis.title = NULL, axis.lim = NULL,
+  wrap.title = 50, wrap.labels = 25, wrap.legend.title = 20,
+  grid.breaks = NULL, dot.size = 3, spacing = 0.4, colors = ""Set1"",
+  show.values = FALSE, show.legend = TRUE, show.intercept = FALSE,
+  show.p = TRUE, p.shape = FALSE, ci.lvl = 0.95,
+  vline.color = NULL, digits = 2, grid = FALSE, auto.label = TRUE,
+  prefix.labels = c(""none"", ""varname"", ""label""))
 }
 \arguments{
 \item{...}{One or more regression models, including glm's or mixed models.

---FILE: man/save_plot.Rd---
@@ -4,10 +4,11 @@
 \alias{save_plot}
 \title{Save ggplot-figure for print publication}
 \usage{
-save_plot(filename, fig = ggplot2::last_plot(), width = 12, height = 9,
-  dpi = 300, theme = ggplot2::theme_get(), label.color = ""black"",
-  label.size = 2.4, axis.textsize = 0.8, axis.titlesize = 0.75,
-  legend.textsize = 0.6, legend.titlesize = 0.65, legend.itemsize = 0.5)
+save_plot(filename, fig = ggplot2::last_plot(), width = 12,
+  height = 9, dpi = 300, theme = ggplot2::theme_get(),
+  label.color = ""black"", label.size = 2.4, axis.textsize = 0.8,
+  axis.titlesize = 0.75, legend.textsize = 0.6,
+  legend.titlesize = 0.65, legend.itemsize = 0.5)
 }
 \arguments{
 \item{filename}{Name of the output file; filename must end with one

---FILE: man/set_theme.Rd---
@@ -4,25 +4,28 @@
 \alias{set_theme}
 \title{Set global theme options for sjp-functions}
 \usage{
-set_theme(base = theme_grey(), theme.font = NULL, title.color = ""black"",
-  title.size = 1.2, title.align = ""left"", title.vjust = NULL,
-  geom.outline.color = NULL, geom.outline.size = 0,
-  geom.boxoutline.size = 0.5, geom.boxoutline.color = ""black"",
-  geom.alpha = 1, geom.linetype = 1, geom.errorbar.size = 0.7,
-  geom.errorbar.linetype = 1, geom.label.color = NULL,
-  geom.label.size = 4, geom.label.alpha = 1, geom.label.angle = 0,
-  axis.title.color = ""grey30"", axis.title.size = 1.1,
-  axis.title.x.vjust = NULL, axis.title.y.vjust = NULL, axis.angle.x = 0,
-  axis.angle.y = 0, axis.angle = NULL, axis.textcolor.x = ""grey30"",
+set_theme(base = theme_grey(), theme.font = NULL,
+  title.color = ""black"", title.size = 1.2, title.align = ""left"",
+  title.vjust = NULL, geom.outline.color = NULL,
+  geom.outline.size = 0, geom.boxoutline.size = 0.5,
+  geom.boxoutline.color = ""black"", geom.alpha = 1, geom.linetype = 1,
+  geom.errorbar.size = 0.7, geom.errorbar.linetype = 1,
+  geom.label.color = NULL, geom.label.size = 4, geom.label.alpha = 1,
+  geom.label.angle = 0, axis.title.color = ""grey30"",
+  axis.title.size = 1.1, axis.title.x.vjust = NULL,
+  axis.title.y.vjust = NULL, axis.angle.x = 0, axis.angle.y = 0,
+  axis.angle = NULL, axis.textcolor.x = ""grey30"",
   axis.textcolor.y = ""grey30"", axis.textcolor = NULL,
-  axis.linecolor.x = NULL, axis.linecolor.y = NULL, axis.linecolor = NULL,
-  axis.line.size = 0.5, axis.textsize.x = 1, axis.textsize.y = 1,
-  axis.textsize = NULL, axis.tickslen = NULL, axis.tickscol = NULL,
-  axis.ticksmar = NULL, axis.ticksize.x = NULL, axis.ticksize.y = NULL,
-  panel.backcol = NULL, panel.bordercol = NULL, panel.col = NULL,
+  axis.linecolor.x = NULL, axis.linecolor.y = NULL,
+  axis.linecolor = NULL, axis.line.size = 0.5, axis.textsize.x = 1,
+  axis.textsize.y = 1, axis.textsize = NULL, axis.tickslen = NULL,
+  axis.tickscol = NULL, axis.ticksmar = NULL, axis.ticksize.x = NULL,
+  axis.ticksize.y = NULL, panel.backcol = NULL,
+  panel.bordercol = NULL, panel.col = NULL,
   panel.major.gridcol = NULL, panel.minor.gridcol = NULL,
-  panel.gridcol = NULL, panel.gridcol.x = NULL, panel.gridcol.y = NULL,
-  panel.major.linetype = 1, panel.minor.linetype = 1, plot.backcol = NULL,
+  panel.gridcol = NULL, panel.gridcol.x = NULL,
+  panel.gridcol.y = NULL, panel.major.linetype = 1,
+  panel.minor.linetype = 1, plot.backcol = NULL,
   plot.bordercol = NULL, plot.col = NULL, plot.margins = NULL,
   legend.pos = ""right"", legend.just = NULL, legend.inside = FALSE,
   legend.size = 1, legend.color = ""black"", legend.title.size = 1,

---FILE: man/sjPlot-themes.Rd---
@@ -31,11 +31,11 @@ label_angle(angle.x, angle.y, base.theme)
 
 legend_style(inside, pos, justify, base.theme)
 
-scale_color_sjplot(palette = ""metro ui"", discrete = TRUE, reverse = FALSE,
-  ...)
+scale_color_sjplot(palette = ""metro ui"", discrete = TRUE,
+  reverse = FALSE, ...)
 
-scale_fill_sjplot(palette = ""metro ui"", discrete = TRUE, reverse = FALSE,
-  ...)
+scale_fill_sjplot(palette = ""metro ui"", discrete = TRUE,
+  reverse = FALSE, ...)
 
 sjplot_pal(palette = ""metro ui"", n = NULL)
 

---FILE: man/sjc.cluster.Rd---
@@ -7,8 +7,8 @@
 sjc.cluster(data, groupcount = NULL, method = c(""hclust"", ""kmeans""),
   distance = c(""euclidean"", ""maximum"", ""manhattan"", ""canberra"", ""binary"",
   ""minkowski""), agglomeration = c(""ward"", ""ward.D"", ""ward.D2"", ""single"",
-  ""complete"", ""average"", ""mcquitty"", ""median"", ""centroid""), iter.max = 20,
-  algorithm = c(""Hartigan-Wong"", ""Lloyd"", ""MacQueen""))
+  ""complete"", ""average"", ""mcquitty"", ""median"", ""centroid""),
+  iter.max = 20, algorithm = c(""Hartigan-Wong"", ""Lloyd"", ""MacQueen""))
 }
 \arguments{
 \item{data}{A data frame with variables that should be used for the

---FILE: man/sjc.dend.Rd---
@@ -4,7 +4,8 @@
 \alias{sjc.dend}
 \title{Compute hierarchical cluster analysis and visualize group classification}
 \usage{
-sjc.dend(data, groupcount, distance = ""euclidean"", agglomeration = ""ward"")
+sjc.dend(data, groupcount, distance = ""euclidean"",
+  agglomeration = ""ward"")
 }
 \arguments{
 \item{data}{A data frame with variables that should be used for the

---FILE: man/sjc.grpdisc.Rd---
@@ -4,7 +4,8 @@
 \alias{sjc.grpdisc}
 \title{Compute a linear discriminant analysis on classified cluster groups}
 \usage{
-sjc.grpdisc(data, groups, groupcount, clss.fit = TRUE, prnt.plot = TRUE)
+sjc.grpdisc(data, groups, groupcount, clss.fit = TRUE,
+  prnt.plot = TRUE)
 }
 \arguments{
 \item{data}{A data frame with variables that should be used for the

---FILE: man/sjc.kgap.Rd---
@@ -4,8 +4,8 @@
 \alias{sjc.kgap}
 \title{Compute gap statistics for k-means-cluster}
 \usage{
-sjc.kgap(x, max = 10, B = 100, SE.factor = 1, method = ""Tibs2001SEmax"",
-  plotResults = TRUE)
+sjc.kgap(x, max = 10, B = 100, SE.factor = 1,
+  method = ""Tibs2001SEmax"", plotResults = TRUE)
 }
 \arguments{
 \item{x}{matrix, where rows are observations and columns are individual dimensions,

---FILE: man/sjc.qclus.Rd---
@@ -4,17 +4,19 @@
 \alias{sjc.qclus}
 \title{Compute quick cluster analysis}
 \usage{
-sjc.qclus(data, groupcount = NULL, groups = NULL, method = c(""kmeans"",
-  ""hclust""), distance = c(""euclidean"", ""maximum"", ""manhattan"", ""canberra"",
-  ""binary"", ""minkowski""), agglomeration = c(""ward"", ""ward.D"", ""ward.D2"",
-  ""single"", ""complete"", ""average"", ""mcquitty"", ""median"", ""centroid""),
-  iter.max = 20, algorithm = c(""Hartigan-Wong"", ""Lloyd"", ""MacQueen""),
+sjc.qclus(data, groupcount = NULL, groups = NULL,
+  method = c(""kmeans"", ""hclust""), distance = c(""euclidean"", ""maximum"",
+  ""manhattan"", ""canberra"", ""binary"", ""minkowski""),
+  agglomeration = c(""ward"", ""ward.D"", ""ward.D2"", ""single"", ""complete"",
+  ""average"", ""mcquitty"", ""median"", ""centroid""), iter.max = 20,
+  algorithm = c(""Hartigan-Wong"", ""Lloyd"", ""MacQueen""),
   show.accuracy = FALSE, title = NULL, axis.labels = NULL,
   wrap.title = 40, wrap.labels = 20, wrap.legend.title = 20,
-  wrap.legend.labels = 20, facet.grid = FALSE, geom.colors = ""Paired"",
-  geom.size = 0.5, geom.spacing = 0.1, show.legend = TRUE,
-  show.grpcnt = TRUE, legend.title = NULL, legend.labels = NULL,
-  coord.flip = FALSE, reverse.axis = FALSE, prnt.plot = TRUE)
+  wrap.legend.labels = 20, facet.grid = FALSE,
+  geom.colors = ""Paired"", geom.size = 0.5, geom.spacing = 0.1,
+  show.legend = TRUE, show.grpcnt = TRUE, legend.title = NULL,
+  legend.labels = NULL, coord.flip = FALSE, reverse.axis = FALSE,
+  prnt.plot = TRUE)
 }
 \arguments{
 \item{data}{A data frame with variables that should be used for the

---FILE: man/sjp.aov1.Rd---
@@ -5,9 +5,10 @@
 \title{Plot One-Way-Anova tables}
 \usage{
 sjp.aov1(var.dep, var.grp, meansums = FALSE, title = NULL,
-  axis.labels = NULL, rev.order = FALSE, string.interc = ""(Intercept)"",
-  axis.title = """", axis.lim = NULL, geom.colors = c(""#3366a0"", ""#aa3333""),
-  geom.size = 3, wrap.title = 50, wrap.labels = 25, grid.breaks = NULL,
+  axis.labels = NULL, rev.order = FALSE,
+  string.interc = ""(Intercept)"", axis.title = """", axis.lim = NULL,
+  geom.colors = c(""#3366a0"", ""#aa3333""), geom.size = 3,
+  wrap.title = 50, wrap.labels = 25, grid.breaks = NULL,
   show.values = TRUE, digits = 2, y.offset = 0.1, show.p = TRUE,
   show.summary = FALSE, prnt.plot = TRUE)
 }

---FILE: man/sjp.corr.Rd---
@@ -6,10 +6,10 @@
 \usage{
 sjp.corr(data, title = NULL, axis.labels = NULL, sort.corr = TRUE,
   decimals = 3, na.deletion = c(""listwise"", ""pairwise""),
-  corr.method = c(""pearson"", ""spearman"", ""kendall""), geom.colors = ""RdBu"",
-  wrap.title = 50, wrap.labels = 20, show.legend = FALSE,
-  legend.title = NULL, show.values = TRUE, show.p = TRUE,
-  p.numeric = FALSE, prnt.plot = TRUE)
+  corr.method = c(""pearson"", ""spearman"", ""kendall""),
+  geom.colors = ""RdBu"", wrap.title = 50, wrap.labels = 20,
+  show.legend = FALSE, legend.title = NULL, show.values = TRUE,
+  show.p = TRUE, p.numeric = FALSE, prnt.plot = TRUE)
 }
 \arguments{
 \item{data}{Matrix with correlation coefficients as returned by the

---FILE: man/sjp.fa.Rd---
@@ -4,12 +4,13 @@
 \alias{sjp.fa}
 \title{Plot FA results}
 \usage{
-sjp.fa(data, rotation = c(""promax"", ""varimax""), method = c(""ml"", ""minres"",
-  ""wls"", ""gls"", ""pa"", ""minchi"", ""minrank""), nmbr.fctr = NULL,
-  fctr.load.tlrn = 0.1, digits = 2, title = NULL, axis.labels = NULL,
-  type = c(""bar"", ""circle"", ""tile""), geom.size = 0.6,
-  geom.colors = ""RdBu"", wrap.title = 50, wrap.labels = 30,
-  show.values = TRUE, show.cronb = TRUE, prnt.plot = TRUE)
+sjp.fa(data, rotation = c(""promax"", ""varimax""), method = c(""ml"",
+  ""minres"", ""wls"", ""gls"", ""pa"", ""minchi"", ""minrank""), nmbr.fctr = NULL,
+  fctr.load.tlrn = 0.1, digits = 2, title = NULL,
+  axis.labels = NULL, type = c(""bar"", ""circle"", ""tile""),
+  geom.size = 0.6, geom.colors = ""RdBu"", wrap.title = 50,
+  wrap.labels = 30, show.values = TRUE, show.cronb = TRUE,
+  prnt.plot = TRUE)
 }
 \arguments{
 \item{data}{A data frame that should be used to compute a FA, or a \code{\link[psych]{fa}} object.}

---FILE: man/sjp.frq.Rd---
@@ -4,20 +4,22 @@
 \alias{sjp.frq}
 \title{Plot frequencies of variables}
 \usage{
-sjp.frq(var.cnt, title = """", weight.by = NULL, title.wtd.suffix = NULL,
-  sort.frq = c(""none"", ""asc"", ""desc""), type = c(""bar"", ""dot"", ""histogram"",
-  ""line"", ""density"", ""boxplot"", ""violin""), geom.size = NULL,
-  geom.colors = ""#336699"", errorbar.color = ""darkred"", axis.title = NULL,
-  axis.labels = NULL, xlim = NULL, ylim = NULL, wrap.title = 50,
-  wrap.labels = 20, grid.breaks = NULL, expand.grid = FALSE,
-  show.values = TRUE, show.n = TRUE, show.prc = TRUE,
-  show.axis.values = TRUE, show.ci = FALSE, show.na = FALSE,
-  show.mean = FALSE, show.mean.val = TRUE, show.sd = TRUE,
-  mean.line.type = 2, mean.line.size = 0.5, inner.box.width = 0.15,
-  inner.box.dotsize = 3, normal.curve = FALSE, normal.curve.color = ""red"",
-  normal.curve.size = 0.8, normal.curve.alpha = 0.4, auto.group = NULL,
-  coord.flip = FALSE, vjust = ""bottom"", hjust = ""center"",
-  y.offset = NULL, prnt.plot = TRUE)
+sjp.frq(var.cnt, title = """", weight.by = NULL,
+  title.wtd.suffix = NULL, sort.frq = c(""none"", ""asc"", ""desc""),
+  type = c(""bar"", ""dot"", ""histogram"", ""line"", ""density"", ""boxplot"",
+  ""violin""), geom.size = NULL, geom.colors = ""#336699"",
+  errorbar.color = ""darkred"", axis.title = NULL, axis.labels = NULL,
+  xlim = NULL, ylim = NULL, wrap.title = 50, wrap.labels = 20,
+  grid.breaks = NULL, expand.grid = FALSE, show.values = TRUE,
+  show.n = TRUE, show.prc = TRUE, show.axis.values = TRUE,
+  show.ci = FALSE, show.na = FALSE, show.mean = FALSE,
+  show.mean.val = TRUE, show.sd = TRUE, mean.line.type = 2,
+  mean.line.size = 0.5, inner.box.width = 0.15,
+  inner.box.dotsize = 3, normal.curve = FALSE,
+  normal.curve.color = ""red"", normal.curve.size = 0.8,
+  normal.curve.alpha = 0.4, auto.group = NULL, coord.flip = FALSE,
+  vjust = ""bottom"", hjust = ""center"", y.offset = NULL,
+  prnt.plot = TRUE)
 }
 \arguments{
 \item{var.cnt}{Vector of counts, for which frequencies or means will be plotted or printed.}

---FILE: man/sjp.gpt.Rd---
@@ -5,8 +5,8 @@
 \title{Plot grouped proportional tables}
 \usage{
 sjp.gpt(x, y, groups, geom.colors = ""Set1"", geom.size = 2.5,
-  shape.fill.color = ""#f0f0f0"", shapes = c(15, 16, 17, 18, 21, 22, 23, 24,
-  25, 7, 8, 9, 10, 12), title = NULL, axis.labels = NULL,
+  shape.fill.color = ""#f0f0f0"", shapes = c(15, 16, 17, 18, 21, 22, 23,
+  24, 25, 7, 8, 9, 10, 12), title = NULL, axis.labels = NULL,
   axis.titles = NULL, legend.title = NULL, legend.labels = NULL,
   wrap.title = 50, wrap.labels = 15, wrap.legend.title = 20,
   wrap.legend.labels = 20, axis.lim = NULL, grid.breaks = NULL,

---FILE: man/sjp.likert.Rd---
@@ -4,16 +4,17 @@
 \alias{sjp.likert}
 \title{Plot likert scales as centered stacked bars}
 \usage{
-sjp.likert(items, title = NULL, legend.title = NULL, legend.labels = NULL,
-  axis.titles = NULL, axis.labels = NULL, catcount = NULL,
-  cat.neutral = NULL, sort.frq = NULL, weight.by = NULL,
-  title.wtd.suffix = NULL, wrap.title = 50, wrap.labels = 30,
-  wrap.legend.title = 30, wrap.legend.labels = 28, geom.size = 0.6,
-  geom.colors = ""BrBG"", cat.neutral.color = ""grey70"",
-  intercept.line.color = ""grey50"", reverse.colors = FALSE,
-  values = ""show"", show.n = TRUE, show.legend = TRUE,
-  show.prc.sign = FALSE, grid.range = 1, grid.breaks = 0.2,
-  expand.grid = TRUE, digits = 1, coord.flip = TRUE, prnt.plot = TRUE)
+sjp.likert(items, title = NULL, legend.title = NULL,
+  legend.labels = NULL, axis.titles = NULL, axis.labels = NULL,
+  catcount = NULL, cat.neutral = NULL, sort.frq = NULL,
+  weight.by = NULL, title.wtd.suffix = NULL, wrap.title = 50,
+  wrap.labels = 30, wrap.legend.title = 30, wrap.legend.labels = 28,
+  geom.size = 0.6, geom.colors = ""BrBG"",
+  cat.neutral.color = ""grey70"", intercept.line.color = ""grey50"",
+  reverse.colors = FALSE, values = ""show"", show.n = TRUE,
+  show.legend = TRUE, show.prc.sign = FALSE, grid.range = 1,
+  grid.breaks = 0.2, expand.grid = TRUE, digits = 1,
+  coord.flip = TRUE, prnt.plot = TRUE)
 }
 \arguments{
 \item{items}{Data frame, with each column representing one item.}

---FILE: man/sjp.pca.Rd---
@@ -5,10 +5,11 @@
 \title{Plot PCA results}
 \usage{
 sjp.pca(data, rotation = c(""varimax"", ""oblimin""), nmbr.fctr = NULL,
-  fctr.load.tlrn = 0.1, plot.eigen = FALSE, digits = 2, title = NULL,
-  axis.labels = NULL, type = c(""bar"", ""circle"", ""tile""), geom.size = 0.6,
-  geom.colors = ""RdBu"", wrap.title = 50, wrap.labels = 30,
-  show.values = TRUE, show.cronb = TRUE, prnt.plot = TRUE)
+  fctr.load.tlrn = 0.1, plot.eigen = FALSE, digits = 2,
+  title = NULL, axis.labels = NULL, type = c(""bar"", ""circle"",
+  ""tile""), geom.size = 0.6, geom.colors = ""RdBu"", wrap.title = 50,
+  wrap.labels = 30, show.values = TRUE, show.cronb = TRUE,
+  prnt.plot = TRUE)
 }
 \arguments{
 \item{data}{A data frame that should be used to compute a PCA, or a \code{\link{prcomp}} object.}

---FILE: man/sjp.resid.Rd---
@@ -4,8 +4,9 @@
 \alias{sjp.resid}
 \title{Plot predicted values and their residuals}
 \usage{
-sjp.resid(fit, geom.size = 2, remove.estimates = NULL, show.lines = TRUE,
-  show.resid = TRUE, show.pred = TRUE, show.ci = F, prnt.plot = TRUE)
+sjp.resid(fit, geom.size = 2, remove.estimates = NULL,
+  show.lines = TRUE, show.resid = TRUE, show.pred = TRUE,
+  show.ci = F, prnt.plot = TRUE)
 }
 \arguments{
 \item{fit}{Fitted linear (mixed) regression model (including objects of class

---FILE: man/sjp.stackfrq.Rd---
@@ -6,12 +6,12 @@
 \usage{
 sjp.stackfrq(items, title = NULL, legend.title = NULL,
   legend.labels = NULL, axis.titles = NULL, axis.labels = NULL,
-  weight.by = NULL, sort.frq = NULL, wrap.title = 50, wrap.labels = 30,
-  wrap.legend.title = 30, wrap.legend.labels = 28, geom.size = 0.5,
-  geom.colors = ""Blues"", show.values = TRUE, show.n = TRUE,
-  show.prc = TRUE, show.legend = TRUE, grid.breaks = 0.2,
-  expand.grid = FALSE, digits = 1, vjust = ""center"", coord.flip = TRUE,
-  prnt.plot = TRUE)
+  weight.by = NULL, sort.frq = NULL, wrap.title = 50,
+  wrap.labels = 30, wrap.legend.title = 30, wrap.legend.labels = 28,
+  geom.size = 0.5, geom.colors = ""Blues"", show.values = TRUE,
+  show.n = TRUE, show.prc = TRUE, show.legend = TRUE,
+  grid.breaks = 0.2, expand.grid = FALSE, digits = 1,
+  vjust = ""center"", coord.flip = TRUE, prnt.plot = TRUE)
 }
 \arguments{
 \item{items}{Data frame, with each column representing one item.}

---FILE: man/sjp.xtab.Rd---
@@ -4,17 +4,18 @@
 \alias{sjp.xtab}
 \title{Plot contingency tables}
 \usage{
-sjp.xtab(x, grp, type = c(""bar"", ""line""), margin = c(""col"", ""cell"", ""row""),
-  bar.pos = c(""dodge"", ""stack""), title = """", title.wtd.suffix = NULL,
-  axis.titles = NULL, axis.labels = NULL, legend.title = NULL,
-  legend.labels = NULL, weight.by = NULL, rev.order = FALSE,
-  show.values = TRUE, show.n = TRUE, show.prc = TRUE, show.total = TRUE,
-  show.legend = TRUE, show.summary = FALSE, summary.pos = ""r"",
-  string.total = ""Total"", wrap.title = 50, wrap.labels = 15,
-  wrap.legend.title = 20, wrap.legend.labels = 20, geom.size = 0.7,
-  geom.spacing = 0.1, geom.colors = ""Paired"", dot.size = 3,
-  smooth.lines = FALSE, grid.breaks = 0.2, expand.grid = FALSE,
-  ylim = NULL, vjust = ""bottom"", hjust = ""center"", y.offset = NULL,
+sjp.xtab(x, grp, type = c(""bar"", ""line""), margin = c(""col"", ""cell"",
+  ""row""), bar.pos = c(""dodge"", ""stack""), title = """",
+  title.wtd.suffix = NULL, axis.titles = NULL, axis.labels = NULL,
+  legend.title = NULL, legend.labels = NULL, weight.by = NULL,
+  rev.order = FALSE, show.values = TRUE, show.n = TRUE,
+  show.prc = TRUE, show.total = TRUE, show.legend = TRUE,
+  show.summary = FALSE, summary.pos = ""r"", string.total = ""Total"",
+  wrap.title = 50, wrap.labels = 15, wrap.legend.title = 20,
+  wrap.legend.labels = 20, geom.size = 0.7, geom.spacing = 0.1,
+  geom.colors = ""Paired"", dot.size = 3, smooth.lines = FALSE,
+  grid.breaks = 0.2, expand.grid = FALSE, ylim = NULL,
+  vjust = ""bottom"", hjust = ""center"", y.offset = NULL,
   coord.flip = FALSE, prnt.plot = TRUE)
 }
 \arguments{

---FILE: man/sjplot.Rd---
@@ -5,8 +5,8 @@
 \alias{sjtab}
 \title{Wrapper to create plots and tables within a pipe-workflow}
 \usage{
-sjplot(data, ..., fun = c(""frq"", ""grpfrq"", ""xtab"", ""gpt"", ""scatter"", ""aov1"",
-  ""likert"", ""stackfrq""))
+sjplot(data, ..., fun = c(""frq"", ""grpfrq"", ""xtab"", ""gpt"", ""scatter"",
+  ""aov1"", ""likert"", ""stackfrq""))
 
 sjtab(data, ..., fun = c(""xtab"", ""stackfrq""))
 }

---FILE: man/sjt.corr.Rd---
@@ -6,10 +6,11 @@
 \usage{
 sjt.corr(data, na.deletion = c(""listwise"", ""pairwise""),
   corr.method = c(""pearson"", ""spearman"", ""kendall""), title = NULL,
-  var.labels = NULL, wrap.labels = 40, show.p = TRUE, p.numeric = FALSE,
-  fade.ns = TRUE, val.rm = NULL, digits = 3, triangle = ""both"",
-  string.diag = NULL, CSS = NULL, encoding = NULL, file = NULL,
-  use.viewer = TRUE, no.output = FALSE, remove.spaces = TRUE)
+  var.labels = NULL, wrap.labels = 40, show.p = TRUE,
+  p.numeric = FALSE, fade.ns = TRUE, val.rm = NULL, digits = 3,
+  triangle = ""both"", string.diag = NULL, CSS = NULL,
+  encoding = NULL, file = NULL, use.viewer = TRUE,
+  no.output = FALSE, remove.spaces = TRUE)
 }
 \arguments{
 \item{data}{Matrix with correlation coefficients as returned by the

---FILE: man/sjt.fa.Rd---
@@ -4,8 +4,8 @@
 \alias{sjt.fa}
 \title{Summary of factor analysis as HTML table}
 \usage{
-sjt.fa(data, rotation = c(""promax"", ""varimax""), method = c(""ml"", ""minres"",
-  ""wls"", ""gls"", ""pa"", ""minchi"", ""minrank""), nmbr.fctr = NULL,
+sjt.fa(data, rotation = c(""promax"", ""varimax""), method = c(""ml"",
+  ""minres"", ""wls"", ""gls"", ""pa"", ""minchi"", ""minrank""), nmbr.fctr = NULL,
   fctr.load.tlrn = 0.1, title = ""Factor Analysis"", var.labels = NULL,
   wrap.labels = 40, show.cronb = TRUE, show.comm = FALSE,
   altr.row.col = FALSE, digits = 2, CSS = NULL, encoding = NULL,

---FILE: man/sjt.glm.Rd---
@@ -17,10 +17,10 @@ sjt.glm(..., pred.labels = NULL, depvar.labels = NULL,
   string.obs = ""Observations"", string.est = NULL, string.ci = ""CI"",
   string.se = ""std. Error"", string.p = ""p"",
   ci.hyphen = ""&nbsp;&ndash;&nbsp;"", digits.est = 2, digits.p = 3,
-  digits.ci = 2, digits.se = 2, digits.summary = 3, cell.spacing = 0.2,
-  cell.gpr.indent = 0.6, sep.column = TRUE, CSS = NULL, encoding = NULL,
-  file = NULL, use.viewer = TRUE, no.output = FALSE,
-  remove.spaces = TRUE)
+  digits.ci = 2, digits.se = 2, digits.summary = 3,
+  cell.spacing = 0.2, cell.gpr.indent = 0.6, sep.column = TRUE,
+  CSS = NULL, encoding = NULL, file = NULL, use.viewer = TRUE,
+  no.output = FALSE, remove.spaces = TRUE)
 }
 \arguments{
 \item{...}{One or more fitted generalized linear (mixed) models.}

---FILE: man/sjt.itemanalysis.Rd---
@@ -4,11 +4,13 @@
 \alias{sjt.itemanalysis}
 \title{Summary of item analysis of an item scale as HTML table}
 \usage{
-sjt.itemanalysis(df, factor.groups = NULL, factor.groups.titles = ""auto"",
-  scale = FALSE, min.valid.rowmean = 2, altr.row.col = TRUE,
-  sort.column = NULL, show.shapiro = FALSE, show.kurtosis = FALSE,
-  show.corr.matrix = TRUE, CSS = NULL, encoding = NULL, file = NULL,
-  use.viewer = TRUE, no.output = FALSE, remove.spaces = TRUE)
+sjt.itemanalysis(df, factor.groups = NULL,
+  factor.groups.titles = ""auto"", scale = FALSE,
+  min.valid.rowmean = 2, altr.row.col = TRUE, sort.column = NULL,
+  show.shapiro = FALSE, show.kurtosis = FALSE,
+  show.corr.matrix = TRUE, CSS = NULL, encoding = NULL,
+  file = NULL, use.viewer = TRUE, no.output = FALSE,
+  remove.spaces = TRUE)
 }
 \arguments{
 \item{df}{A data frame with items.}

---FILE: man/sjt.lm.Rd---
@@ -8,18 +8,20 @@ sjt.lm(..., pred.labels = NULL, depvar.labels = NULL,
   remove.estimates = NULL, group.pred = TRUE, p.numeric = TRUE,
   emph.p = FALSE, p.zero = FALSE, p.kr = TRUE, robust = FALSE,
   separate.ci.col = TRUE, newline.ci = TRUE, show.est = TRUE,
-  show.std = NULL, show.ci = TRUE, show.se = FALSE, show.header = FALSE,
-  show.col.header = TRUE, show.r2 = TRUE, show.icc = FALSE,
-  show.re.var = FALSE, show.fstat = FALSE, show.aic = FALSE,
-  show.aicc = FALSE, show.dev = FALSE, string.pred = ""Predictors"",
-  string.dv = ""Dependent Variables"", string.interc = ""(Intercept)"",
-  string.obs = ""Observations"", string.est = ""B"", string.std = ""std. Beta"",
-  string.ci = ""CI"", string.se = ""std. Error"", string.p = ""p"",
-  ci.hyphen = ""&nbsp;&ndash;&nbsp;"", minus.sign = ""&#45;"", digits.est = 2,
-  digits.std = 2, digits.p = 3, digits.ci = 2, digits.se = 2,
-  digits.summary = 3, cell.spacing = 0.2, cell.gpr.indent = 0.6,
-  sep.column = TRUE, CSS = NULL, encoding = NULL, file = NULL,
-  use.viewer = TRUE, no.output = FALSE, remove.spaces = TRUE)
+  show.std = NULL, show.ci = TRUE, show.se = FALSE,
+  show.header = FALSE, show.col.header = TRUE, show.r2 = TRUE,
+  show.icc = FALSE, show.re.var = FALSE, show.fstat = FALSE,
+  show.aic = FALSE, show.aicc = FALSE, show.dev = FALSE,
+  string.pred = ""Predictors"", string.dv = ""Dependent Variables"",
+  string.interc = ""(Intercept)"", string.obs = ""Observations"",
+  string.est = ""B"", string.std = ""std. Beta"", string.ci = ""CI"",
+  string.se = ""std. Error"", string.p = ""p"",
+  ci.hyphen = ""&nbsp;&ndash;&nbsp;"", minus.sign = ""&#45;"",
+  digits.est = 2, digits.std = 2, digits.p = 3, digits.ci = 2,
+  digits.se = 2, digits.summary = 3, cell.spacing = 0.2,
+  cell.gpr.indent = 0.6, sep.column = TRUE, CSS = NULL,
+  encoding = NULL, file = NULL, use.viewer = TRUE,
+  no.output = FALSE, remove.spaces = TRUE)
 }
 \arguments{
 \item{...}{One or more fitted linear (mixed) models.}

---FILE: man/sjt.lmer.Rd---
@@ -6,20 +6,22 @@
 \usage{
 sjt.lmer(..., pred.labels = NULL, depvar.labels = NULL,
   remove.estimates = NULL, group.pred = FALSE, p.numeric = TRUE,
-  emph.p = FALSE, p.zero = FALSE, p.kr = TRUE, separate.ci.col = TRUE,
-  newline.ci = TRUE, show.est = TRUE, show.std = NULL, show.ci = TRUE,
-  show.se = FALSE, show.header = FALSE, show.col.header = TRUE,
-  show.r2 = TRUE, show.icc = TRUE, show.re.var = TRUE,
-  show.fstat = FALSE, show.aic = FALSE, show.aicc = FALSE,
-  show.dev = FALSE, string.pred = ""Predictors"",
-  string.dv = ""Dependent Variables"", string.interc = ""(Intercept)"",
-  string.obs = ""Observations"", string.est = ""B"", string.std = ""std. Beta"",
-  string.ci = ""CI"", string.se = ""std. Error"", string.p = ""p"",
-  ci.hyphen = ""&nbsp;&ndash;&nbsp;"", minus.sign = ""&#45;"", digits.est = 2,
-  digits.std = 2, digits.p = 3, digits.ci = 2, digits.se = 2,
-  digits.summary = 3, cell.spacing = 0.2, cell.gpr.indent = 0.6,
-  sep.column = TRUE, CSS = NULL, encoding = NULL, file = NULL,
-  use.viewer = TRUE, no.output = FALSE, remove.spaces = TRUE)
+  emph.p = FALSE, p.zero = FALSE, p.kr = TRUE,
+  separate.ci.col = TRUE, newline.ci = TRUE, show.est = TRUE,
+  show.std = NULL, show.ci = TRUE, show.se = FALSE,
+  show.header = FALSE, show.col.header = TRUE, show.r2 = TRUE,
+  show.icc = TRUE, show.re.var = TRUE, show.fstat = FALSE,
+  show.aic = FALSE, show.aicc = FALSE, show.dev = FALSE,
+  string.pred = ""Predictors"", string.dv = ""Dependent Variables"",
+  string.interc = ""(Intercept)"", string.obs = ""Observations"",
+  string.est = ""B"", string.std = ""std. Beta"", string.ci = ""CI"",
+  string.se = ""std. Error"", string.p = ""p"",
+  ci.hyphen = ""&nbsp;&ndash;&nbsp;"", minus.sign = ""&#45;"",
+  digits.est = 2, digits.std = 2, digits.p = 3, digits.ci = 2,
+  digits.se = 2, digits.summary = 3, cell.spacing = 0.2,
+  cell.gpr.indent = 0.6, sep.column = TRUE, CSS = NULL,
+  encoding = NULL, file = NULL, use.viewer = TRUE,
+  no.output = FALSE, remove.spaces = TRUE)
 }
 \arguments{
 \item{...}{One or more fitted linear (mixed) models.}

---FILE: man/sjt.pca.Rd---
@@ -7,8 +7,8 @@
 sjt.pca(data, rotation = c(""varimax"", ""oblimin""), nmbr.fctr = NULL,
   fctr.load.tlrn = 0.1, title = ""Principal Component Analysis"",
   var.labels = NULL, wrap.labels = 40, show.cronb = TRUE,
-  show.msa = FALSE, show.var = FALSE, altr.row.col = FALSE, digits = 2,
-  string.pov = ""Proportion of Variance"",
+  show.msa = FALSE, show.var = FALSE, altr.row.col = FALSE,
+  digits = 2, string.pov = ""Proportion of Variance"",
   string.cpov = ""Cumulative Proportion"", CSS = NULL, encoding = NULL,
   file = NULL, use.viewer = TRUE, no.output = FALSE,
   remove.spaces = TRUE)

---FILE: man/sjt.stackfrq.Rd---
@@ -4,12 +4,13 @@
 \alias{sjt.stackfrq}
 \title{Summary of stacked frequencies as HTML table}
 \usage{
-sjt.stackfrq(items, weight.by = NULL, title = NULL, var.labels = NULL,
-  value.labels = NULL, wrap.labels = 20, sort.frq = NULL,
-  altr.row.col = FALSE, digits = 2, string.total = ""N"",
-  string.na = ""NA"", show.n = FALSE, show.total = FALSE, show.na = FALSE,
-  show.skew = FALSE, show.kurtosis = FALSE, digits.stats = 2,
-  file = NULL, encoding = NULL, CSS = NULL, use.viewer = TRUE,
+sjt.stackfrq(items, weight.by = NULL, title = NULL,
+  var.labels = NULL, value.labels = NULL, wrap.labels = 20,
+  sort.frq = NULL, altr.row.col = FALSE, digits = 2,
+  string.total = ""N"", string.na = ""NA"", show.n = FALSE,
+  show.total = FALSE, show.na = FALSE, show.skew = FALSE,
+  show.kurtosis = FALSE, digits.stats = 2, file = NULL,
+  encoding = NULL, CSS = NULL, use.viewer = TRUE,
   no.output = FALSE, remove.spaces = TRUE)
 }
 \arguments{

---FILE: man/sjt.xtab.Rd---
@@ -8,11 +8,12 @@ sjt.xtab(var.row, var.col, weight.by = NULL, title = NULL,
   var.labels = NULL, value.labels = NULL, wrap.labels = 20,
   show.obs = TRUE, show.cell.prc = FALSE, show.row.prc = FALSE,
   show.col.prc = FALSE, show.exp = FALSE, show.legend = FALSE,
-  show.na = FALSE, show.summary = TRUE, statistics = c(""auto"", ""cramer"",
-  ""phi"", ""spearman"", ""kendall"", ""pearson""), string.total = ""Total"",
-  digits = 1, tdcol.n = ""black"", tdcol.expected = ""#339999"",
-  tdcol.cell = ""#993333"", tdcol.row = ""#333399"", tdcol.col = ""#339933"",
-  emph.total = FALSE, emph.color = ""#f8f8f8"", prc.sign = ""&nbsp;&#37;"",
+  show.na = FALSE, show.summary = TRUE, statistics = c(""auto"",
+  ""cramer"", ""phi"", ""spearman"", ""kendall"", ""pearson""),
+  string.total = ""Total"", digits = 1, tdcol.n = ""black"",
+  tdcol.expected = ""#339999"", tdcol.cell = ""#993333"",
+  tdcol.row = ""#333399"", tdcol.col = ""#339933"", emph.total = FALSE,
+  emph.color = ""#f8f8f8"", prc.sign = ""&nbsp;&#37;"",
   hundret = ""100.0"", CSS = NULL, encoding = NULL, file = NULL,
   use.viewer = TRUE, no.output = FALSE, remove.spaces = TRUE, ...)
 }

---FILE: man/tab_model.Rd---
@@ -5,20 +5,22 @@
 \title{Print regression models as HTML table}
 \usage{
 tab_model(..., transform, show.intercept = TRUE, show.est = TRUE,
-  show.ci = 0.95, show.hdi50 = TRUE, show.se = NULL, show.std = NULL,
-  show.p = TRUE, show.stat = FALSE, show.df = FALSE,
-  show.zeroinf = TRUE, show.r2 = TRUE, show.icc = TRUE,
-  show.re.var = TRUE, show.fstat = FALSE, show.aic = FALSE,
-  show.aicc = FALSE, show.dev = FALSE, show.obs = TRUE, terms = NULL,
-  rm.terms = NULL, group.terms = TRUE, order.terms = NULL, title = NULL,
+  show.ci = 0.95, show.hdi50 = TRUE, show.se = NULL,
+  show.std = NULL, show.p = TRUE, show.stat = FALSE,
+  show.df = FALSE, show.zeroinf = TRUE, show.r2 = TRUE,
+  show.icc = TRUE, show.re.var = TRUE, show.fstat = FALSE,
+  show.aic = FALSE, show.aicc = FALSE, show.dev = FALSE,
+  show.obs = TRUE, terms = NULL, rm.terms = NULL,
+  group.terms = TRUE, order.terms = NULL, title = NULL,
   pred.labels = NULL, dv.labels = NULL, wrap.labels = 25,
-  string.pred = ""Predictors"", string.std = ""std. Beta"", string.ci = ""CI"",
-  string.se = ""std. Error"", string.p = ""p"", string.df = ""df"",
-  string.stat = ""Statistic"", ci.hyphen = ""&nbsp;&ndash;&nbsp;"",
-  minus.sign = ""&#45;"", collapse.ci = FALSE, collapse.se = FALSE,
-  linebreak = TRUE, digits = 2, digits.p = 3, emph.p = TRUE,
-  p.val = c(""wald"", ""kr""), case = ""parsed"", auto.label = TRUE,
-  bpe = ""median"", CSS = css_theme(""regression""))
+  string.pred = ""Predictors"", string.std = ""std. Beta"",
+  string.ci = ""CI"", string.se = ""std. Error"", string.p = ""p"",
+  string.df = ""df"", string.stat = ""Statistic"",
+  ci.hyphen = ""&nbsp;&ndash;&nbsp;"", minus.sign = ""&#45;"",
+  collapse.ci = FALSE, collapse.se = FALSE, linebreak = TRUE,
+  digits = 2, digits.p = 3, emph.p = TRUE, p.val = c(""wald"", ""kr""),
+  case = ""parsed"", auto.label = TRUE, bpe = ""median"",
+  CSS = css_theme(""regression""))
 }
 \arguments{
 \item{...}{One or more regression models, including glm's or mixed models."
strengejacke,sjPlot,6339102f35f4f8a7a2fbd20c91e37ff44c955f4b,Daniel,mail@danielluedecke.de,2018-07-09T22:08:26Z,Daniel,mail@danielluedecke.de,2018-07-09T22:08:26Z,Fix CRAN check issue,NEWS.md;R/tab_model.R,False,True,True,False,12,1,13,"---FILE: NEWS.md---
@@ -47,7 +47,7 @@ Following functions are now defunct:
 * `plot_model(type = ""int"")` could not automatically select `mdrt.values` properly for non-integer variables.
 * `sjp.grpfrq()` now correctly uses the complete space in facets when `facet.grid = TRUE`.
 * `sjp.grpfrq(type = ""boxplot"")` did not correctly label the x-axis when one category had no elements in a vector.
-
+* Problems with German umlauts when printing HTML tables were fixed.
 
 # sjPlot 2.4.1
 

---FILE: R/tab_model.R---
@@ -91,6 +91,17 @@
 #'    factor levels of same factor, i.e. predictors of type \code{\link{factor}} will
 #'    be grouped, if the factor has more than two levels. Grouping means that a separate headline
 #'    row is inserted to the table just before the predictor values.
+#' @param show.hdi50
+#' @param show.fstat
+#' @param show.aic
+#' @param show.aicc
+#' @param show.obs
+#' @param string.df
+#' @param string.stat
+#' @param p.val
+#' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions,
+#'    according to the \href{http://www.w3.org/Style/CSS/}{official CSS syntax}.
+#'    See 'Details' or \href{../doc/table_css.html}{this package-vignette}.
 #'
 #' @inheritParams plot_models
 #' @inheritParams plot_model"
strengejacke,sjPlot,07e8e2cb03fa57c237db716d65e2bdb5288d7173,Daniel,mail@danielluedecke.de,2018-07-09T21:42:13Z,Daniel,mail@danielluedecke.de,2018-07-09T21:42:13Z,"fix issues, revise vignettes",DESCRIPTION;R/tab_model.R;devel.Rproj;vignettes/sjtlmer.Rmd;vignettes/tab_bayes.Rmd;vignettes/tab_mixed.Rmd;vignettes/tab_model_estimates.Rmd,True,True,True,False,186,191,377,"---FILE: DESCRIPTION---
@@ -58,6 +58,7 @@ Suggests:
     gridExtra,
     ggrepel,
     ggridges,
+    pscl,
     rstanarm,
     survey,
     TMB,

---FILE: R/tab_model.R---
@@ -407,7 +407,7 @@ tab_model <- function(
       wf <- tidyselect::starts_with(""wrap.facet"", vars = colnames(dat))
 
       if (!sjmisc::is_empty(wf)) {
-        zi <- which(dat[[wf]] == ""Zero-Inflated Model"")
+        zi <- which(dat[[wf]] %in% c(""Zero-Inflated Model"", ""Zero Inflation Model""))
 
         if (show.zeroinf && !sjmisc::is_empty(zi)) {
           zidat <- dat %>%
@@ -468,7 +468,7 @@ tab_model <- function(
 
       if (inherits(model, ""brmsfit"")) {
         dat$term <- gsub(""^b_"", """", dat$term)
-        zidat$term <- gsub(""^b_"", """", zidat$term)
+        if (!is.null(zidat)) zidat$term <- gsub(""^b_"", """", zidat$term)
       }
 
 
@@ -510,6 +510,11 @@ tab_model <- function(
   zeroinf.data <- purrr::compact(zeroinf.data)
 
 
+  # make sure we don't have zi-data if not wanted
+
+  if (!show.zeroinf) zeroinf.data <- NULL
+
+
   # sort multivariate response models by response level
 
   model.data <- purrr::map(model.data, function(.x) {

---FILE: devel.Rproj---
@@ -19,4 +19,4 @@ BuildType: Package
 PackageUseDevtools: Yes
 PackageInstallArgs: --no-multiarch --with-keep.source
 PackageCheckArgs: --as-cran
-PackageRoxygenize: rd,collate,namespace
+PackageRoxygenize: rd,collate,namespace,vignette

---FILE: vignettes/sjtlmer.Rmd---
@@ -1,187 +0,0 @@
----
-title: ""Summary of Linear Mixed Regression Models as HTML Table""
-author: ""Daniel Ldecke""
-date: ""`r Sys.Date()`""
-output: rmarkdown::html_vignette
-vignette: >
-  %\VignetteIndexEntry{Summary of Linear Mixed Regression Models as HTML Table}
-  %\VignetteEngine{knitr::rmarkdown}
-  %\VignetteEncoding{UTF-8}
----
-
-```{r echo = FALSE}
-knitr::opts_chunk$set(collapse = TRUE, comment = ""#>"", message = FALSE)
-```
-
-This document shows examples for using the `sjt.lmer()` function of the sjPlot package.
-
-```{r, results='hide', message=FALSE, warning=FALSE}
-# load required packages
-library(sjPlot)
-library(sjmisc)
-library(sjlabelled)
-library(lme4)
-```
-
-## Linear mixed models summaries as HTML table
-
-The `sjt.lmer()` function prints summaries of linear mixed models (fitted with the `lmer()` function of the **lme4**-package) as nicely formatted html-tables.
-
-Before starting, sample data is loaded and sample models are fitted:
-
-```{r, results='hide'}
-# load sample data
-data(efc)
-# prepare grouping variables
-efc$grp = as.factor(efc$e15relat)
-levels(x = efc$grp) <- get_labels(efc$e15relat)
-efc$care.level <- rec(efc$n4pstu, rec = ""0=0;1=1;2=2;3:4=4"", val.labels = c(""none"", ""I"", ""II"", ""III""))
-
-# data frame for fitted model
-mydf <- data.frame(
-  neg_c_7 = efc$neg_c_7,
-  sex = to_factor(efc$c161sex),
-  c12hour = efc$c12hour,
-  barthel = efc$barthtot,
-  education = to_factor(efc$c172code),
-  grp = efc$grp,
-  carelevel = to_factor(efc$care.level)
-  )
-
-# fit sample models
-fit1 <- lmer(neg_c_7 ~ sex + c12hour + barthel + (1 | grp), data = mydf)
-fit2 <- lmer(neg_c_7 ~ sex + c12hour + education + barthel + (1 | grp), data = mydf)
-fit3 <- lmer(neg_c_7 ~ sex + c12hour + education + barthel +
-              (1 | grp) + (1 | carelevel), data = mydf)
-``` 
-
-The simplest way of producing the table output is by passing the fitted models as parameter. By default, estimates (_B_), confidence intervals (_CI_) and p-values (_p_) are reported. The models are named _Model 1_ and _Model 2_.
-
-The resulting table is divided into three parts:
-
-1. _Fixed effects_ - the model's fixed effects coefficients, including confidence intervals and p-values.
-2. _Random effects_ - the model's group count (amount of random intercepts) as well as the Intra-Class-Correlation-Coefficient _ICC_ and information on the random effect variances (within-group, between-group etc.)
-3. _Summary_ - Observations, AIC etc.
-
-```{r}
-sjt.lmer(fit1, fit2)
-```
-
-
-### Custom labels
-You can specify the 'model' label via `depvar.labels` parameter:
-
-```{r}
-sjt.lmer(fit1, fit2,
-         depvar.labels = c(""Negative Impact"", ""Negative Impact""))
-```
-
-
-### More custom labels
-Here is an example how to change the other labels. Note that `show.header` makes the two labels on top and top left corner appear in the table.
-
-```{r}
-sjt.lmer(fit1, fit2, show.header = TRUE, string.est = ""Estimate"", 
-         string.ci = ""Conf. Int."", string.p = ""p-value"",
-         string.dv = ""Response"", string.pred = ""Coefficients"",
-         string.interc = ""Konstante"",
-         depvar.labels = c(""Negative Impact"", ""Negative Impact""))
-```
-
-
-## Changing summary style and content
-
-You can change the table style with specific parameters, e.g. to include CI into the same table cell as the estimates, print asterisks instead of numeric p-values etc.
-
-```{r}
-sjt.lmer(fit1, fit2,
-         separate.ci.col = FALSE, # ci in same cell as estimates
-         show.std = TRUE,         # also show standardized beta values
-         p.numeric = FALSE,       # ""*"" instead of numeric values
-         show.re.var = FALSE,     # no random effect variances
-         show.aic = TRUE,         # AIC
-         show.dev = FALSE,        # no deviance
-         show.r2 = FALSE)          # no Pseudo-R2
-```
-
-
-## Custom variable labels
-
-In the above example, the original variable labels are long and not much pretty. You can change variable labels either with `sjmisc::set_label()`, which will affect all future plots and tables, or pass own labels via `pred.labels`.
-
-```{r}
-sjt.lmer(fit1, fit2, pred.labels = c(""Carer's Sex"",
-         ""Hours of Care"", ""Elder's Dependency"",
-         ""Mid Educational Level"", ""High Educational Level""))
-```
-
-
-## Grouping predictors
-
-Categorical variables with more than two levels can be grouped in the table output. Grouping means, that a row with the variable label is inserted before these variables, and a value label for each category (i.e. factor level) is printed with a small margin.
-
-```{r}
-sjt.lmer(fit3, fit2, fit1, group.pred = TRUE)
-```
-
-
-Note that in the above example, the order of fitted model was changed. This is sometimes necessary, because grouping categorical predictors does not always work properly when multiple models with different amount and order of predictors are printed in one table.
-
-## Models with different random intercepts
-
-When models have different random intercepts, the `sjt.lmer()` function tries to detect these information from each model. In the _Random effects_ section of the table, information on multiple grouping levels and ICC's are printed then.
-
-```{r}
-sjt.lmer(fit1, fit2, fit3)
-```
-
-
-_Note that in certain cases, depending on the order of fitted models with several random intercepts, the group label might be incorrect._
-
-## More space bewteen model columns
-
-Especially when fitting and summarizing some more models, it might help to increase the distance between the columns that separate the models. This can be done by tweaking the `css.separatorcol` style-sheet:
-
-```{r}
-sjt.lmer(fit1, fit2, fit3, 
-         CSS = list(css.separatorcol = 'padding-right:1.5em; padding-left:1.5em;'),
-         show.re.var = FALSE,
-         show.icc = FALSE,
-         show.r2 = FALSE)
-```
-
-
-## Removing estimates from the output
-
-With `remove.estmates`, specific estimates can be removed from the table output. This may make sense in case you have stepwise regression models and only want to compare the varying predictors but not the controls. `remove.estmates` either accepts the row indices of the rows of the table output that should be removed, or the coefficient's names.
-
-When using numeric indices, the estimates' index number relates to the same order as `coef(fit)`.
-
-### Example 1: Complete table output
-
-Here you have the complete table output. This helps you identify the row index numbers. Especially when you have multiple models with different predictors, the estimate's position in the last model may differ from this estimate's position in the table output.
-
-```{r}
-sjt.lmer(fit1, fit2, fit3,
-         show.re.var = FALSE,
-         show.icc = FALSE)
-```
-
-### Example 2: Remove first coefficient (after intercept)
-
-```{r}
-sjt.lmer(fit1, fit2, fit3,
-         remove.estimates = 2,
-         show.re.var = FALSE,
-         show.icc = FALSE)
-```
-
-
-### Example 3: Remove hours of care and sex
-
-```{r}
-sjt.lmer(fit1, fit2, fit3,
-         remove.estimates = c(""c12hour"", ""sex2""),
-         show.re.var = FALSE,
-         show.icc = FALSE)
-```

---FILE: vignettes/tab_bayes.Rmd---
@@ -0,0 +1,78 @@
+---
+title: ""Summary of Baysian Models as HTML Table""
+author: ""Daniel Ldecke""
+date: ""`r Sys.Date()`""
+output: rmarkdown::html_vignette
+params:
+    EVAL: !r identical(Sys.getenv(""NOT_CRAN""), ""true"")
+vignette: >
+  %\VignetteIndexEntry{Summary of Baysian Models as HTML Table}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+
+```{r echo = FALSE}
+knitr::opts_chunk$set(
+  collapse = TRUE, 
+  comment = ""#>"", 
+  message = FALSE,
+  eval = if (isTRUE(exists(""params""))) params$EVAL else FALSE
+)
+```
+
+This vignette shows examples for using `tab_model()` to create HTML tables for mixed models. Basically, `tab_model()` behaves in a very similar way for mixed models as for other, simple regression models, as shown [in this vignette](tab_model_estimates.html).
+
+```{r, results='hide', message=FALSE, warning=FALSE}
+# load required packages
+library(sjPlot)
+library(sjmisc)
+library(brms)
+
+# load sample datasets
+data(""efc"")
+efc <- to_factor(efc, e42dep, c172code, c161sex, e15relat)
+zinb <- read.csv(""http://stats.idre.ucla.edu/stat/data/fish.csv"")
+```
+
+## Bayesian models summaries as HTML table
+
+For Bayesian regression models, some of the differences to the table output from [simple models](tab_model_estimates.html) or [mixed models](tab_mixed.html) of `tab_models()` are the use of _Highest Density Intervals_ instead of confidence intervals, the Bayes-R-squared values, and a different ""point estimate"" (which is, by default, the median from the posterior draws).
+
+```{r}
+m1 <- brm(
+  bf(count ~ child + camper + (1 | persons), 
+     zi ~ child + camper),
+  data = zinb,
+  family = zero_inflated_poisson()
+)
+
+tab_model(m1)
+``` 
+
+## Multivariate response models
+
+For multivariate response models, like mediator-analysis-models, it is recommended to print just one model in the table, as each regression is displayed as own ""model"" in the output.
+
+```{r}
+f1 <- bf(neg_c_7 ~ e42dep + c12hour + c172code + (1 |ID| e15relat))
+f2 <- bf(c12hour ~ c172code + (1 |ID| e15relat))
+m2 <- brm(f1 + f2 + set_rescor(FALSE), data = efc)
+
+tab_model(m2)
+``` 
+
+## Just show one HDI-column
+
+To show just one HDI-column, use `show.hdi50 = FALSE`.
+
+```{r}
+tab_model(m2, show.hdi50 = FALSE)
+``` 
+
+## Mixing multivariate and univariate response models
+
+When both multivariate and univariate response models are displayed in one table, a columns _Response_ is added for the multivariate response model, to indicate the different outcomes.
+
+```{r}
+tab_model(m1, m2, show.hdi50 = F)
+``` 

---FILE: vignettes/tab_mixed.Rmd---
@@ -0,0 +1,80 @@
+---
+title: ""Summary of Mixed Models as HTML Table""
+author: ""Daniel Ldecke""
+date: ""`r Sys.Date()`""
+output: rmarkdown::html_vignette
+vignette: >
+  %\VignetteIndexEntry{Summary of Mixed Models as HTML Table}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+
+```{r echo = FALSE}
+knitr::opts_chunk$set(collapse = TRUE, comment = ""#>"", message = FALSE)
+```
+
+This vignette shows examples for using `tab_model()` to create HTML tables for mixed models. Basically, `tab_model()` behaves in a very similar way for mixed models as for other, simple regression models, as shown [in this vignette](tab_model_estimates.html).
+
+```{r, results='hide', message=FALSE, warning=FALSE}
+# load required packages
+library(sjPlot)
+library(lme4)
+library(nlme)
+data(""sleepstudy"")
+data(""Orthodont"")
+```
+
+## Mixed models summaries as HTML table
+
+Unlike tables for [non-mixed models](tab_model_estimates.html), `tab_models()` adds additional information on the random effects to the table output for mixed models. You can hide these information with `show.icc = FALSE` and `show.re.var = FALSE`. Furthermore, the R-squared values are marginal and conditional R-squared statistics, based on _Nakagawa et al. 2017_.
+
+```{r}
+m1 <- lmer(distance ~ age + Sex + (1 | Subject), data = Orthodont)
+m2 <- lmer(Reaction ~ Days + (1 + Days | Subject), data = sleepstudy)
+
+tab_model(m1, m2)
+``` 
+
+The marginal R-squared considers only the variance of the fixed effects, while the conditional R-squared takes both the fixed and random effects into account.
+
+The p-value is a simple approximation, based on the t-statistics and using the normal distribution function. A more precise p-value can be computed using `p.val = ""kr""`. In this case, which only applies to linear mixed models, the computation of p-values is based on conditional F-tests with Kenward-Roger approximation for the degrees of freedom (using the using the **pbkrtest**-package). Note that here the computation is more time consuming and thus not used as default. You can also display the approximated degrees of freedom with `show.df`.
+
+```{r}
+tab_model(m1, p.val = ""kr"", show.df = TRUE)
+``` 
+
+## Generalized linear mixed models
+
+`tab_model()` can also print and combine models with different link-functions.
+
+```{r}
+data(""cvpp"")
+m3 <- glmer(
+  cbind(incidence, size - incidence) ~ period + (1 | herd),
+  data = cbpp, 
+  family = binomial(link = ""logit"")
+)
+
+tab_model(m1, m3)
+``` 
+
+## More complex models
+
+Finally, an example from the **glmmTMB**-package to show how easy it is to print zero-inflated generalized linear mixed models as HTML table.
+
+```{r}
+library(glmmTMB)
+data(""Salamanders"")
+m4 <- glmmTMB(
+  count ~ spp + mined + (1 | site),
+  ziformula = ~ spp + mined, 
+  family = truncated_poisson(link = ""log""), 
+  data = Salamanders
+)
+
+tab_model(m1, m3, m4, show.ci = FALSE)
+``` 
+
+## References
+
+Nakagawa S, Johnson P, Schielzeth H (2017) _The coefficient of determination R2 and intra-class correlation coefficient from generalized linear mixed-effects models revisted and expanded._ J. R. Soc. Interface 14. doi: 10.1098/rsif.2017.0213

---FILE: vignettes/tab_model_estimates.Rmd---
@@ -28,7 +28,7 @@ library(sjmisc)
 library(sjlabelled)
 
 # sample data
-data(efc)
+data(""efc"")
 efc <- as_factor(efc, c161sex, c172code)
 ```
 
@@ -102,6 +102,24 @@ To plot the estimates on the linear scale, use `transform = NULL`.
 tab_model(m3, m4, transform = NULL, auto.label = FALSE)
 ``` 
 
+## More complex models
+
+Other models, like hurdle- or zero-inflated models, also work with `tab_model()`. In this case, the zero inflation model is indicated in the table. Use `show.zeroinf = FALSE` to hide this part from the table.
+
+```{r}
+library(pscl)
+data(""bioChemists"")
+
+m5 <- zeroinfl(art ~ . | ., data = bioChemists)
+tab_model(m5)
+```
+
+You can combine any model in one table.
+
+```{r}
+tab_model(m1, m3, m5, auto.label = FALSE, show.ci = FALSE)
+```
+
 ## Show or hide further columns
 
 `tab_model()` has some argument that allow to show or hide specific columns from the output:"
strengejacke,sjPlot,c198146053013984e57f60181a06609788dade1c,Daniel,mail@danielluedecke.de,2018-07-09T16:56:03Z,Daniel,mail@danielluedecke.de,2018-07-09T16:56:03Z,"fix minor issues, revise vignettes",DESCRIPTION;R/S3-methods.R;R/html_print.R;R/html_print_utils.R;R/plot_model.R;R/plot_point_estimates.R;R/plot_type_est.R;R/sjTabFrequencies.R;R/sjTabLinReg.R;R/tab_model.R;R/utils.R;man/plot_model.Rd;man/sjt.frq.Rd;man/sjt.lm.Rd;man/tab_model.Rd;vignettes/sjtlm.Rmd;vignettes/tab_model_estimates.Rmd;vignettes/table_css.Rmd,True,True,True,False,503,382,885,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 2.4.1.9000
-Date: 2018-07-06
+Version: 2.4.5
+Date: 2018-07-09
 Authors@R: c(
     person(""Daniel"", ""Ldecke"", email = ""d.luedecke@uke.de"", role = c(""aut"", ""cre""), comment = c(ORCID = ""0000-0002-8895-3206"")),
     person(""Carsten"", ""Schwemmer"", email = ""carsten.schwemmer@uni-bamberg.de"", role = ""ctb"")
@@ -43,7 +43,7 @@ Imports:
     purrr,
     rlang,
     scales,
-    sjlabelled (>= 1.0.11),
+    sjlabelled (>= 1.0.12),
     sjmisc (>= 2.7.3),
     sjstats (>= 0.15.0),
     tidyselect,

---FILE: R/S3-methods.R---
@@ -2,12 +2,12 @@
 #' @export
 print.sjTable <- function(x, ...) {
   if (x$show) {
-
     # check if we have filename specified
     if (!is.null(x$file)) {
       # write file
       write(x$knitr, file = x$file)
     } else {
+      x$page.complete <- replace_umlauts(x$page.complete)
       # else open in viewer pane
       htmlFile <- tempfile(fileext = "".html"")
       write(x$page.complete, file = htmlFile)
@@ -27,15 +27,29 @@ print.sjTable <- function(x, ...) {
 #' @export
 knit_print.sjTable <-  function(input, ...) {
   x <- input$knitr
+  x <- replace_umlauts(x)
+  knitr::asis_output(x)
+  # knitr::asis_output(input$knitr)
+}
+
+
+replace_umlauts <- function(x) {
   x <- gsub(""\u00E4"", ""&auml;"", x, fixed = TRUE, useBytes = FALSE)
   x <- gsub(""\u00F6"", ""&ouml;"", x, fixed = TRUE, useBytes = FALSE)
   x <- gsub(""\u00FC"", ""&uuml;"", x, fixed = TRUE, useBytes = FALSE)
   x <- gsub(""\u00C4"", ""&Auml;"", x, fixed = TRUE, useBytes = FALSE)
   x <- gsub(""\u00D6"", ""&Ouml;"", x, fixed = TRUE, useBytes = FALSE)
   x <- gsub(""\u00DC"", ""&Uuml;"", x, fixed = TRUE, useBytes = FALSE)
   x <- gsub(""\u00DF"", ""&szlig;"", x, fixed = TRUE, useBytes = FALSE)
-  knitr::asis_output(x)
-  # knitr::asis_output(input$knitr)
+  # x <- gsub("""", ""&auml;"", x, fixed = TRUE, useBytes = TRUE)
+  # x <- gsub("""", ""&ouml;"", x, fixed = TRUE, useBytes = TRUE)
+  # x <- gsub("""", ""&uuml;"", x, fixed = TRUE, useBytes = TRUE)
+  # x <- gsub("""", ""&Auml;"", x, fixed = TRUE, useBytes = TRUE)
+  # x <- gsub("""", ""&Ouml;"", x, fixed = TRUE, useBytes = TRUE)
+  # x <- gsub("""", ""&Uuml;"", x, fixed = TRUE, useBytes = TRUE)
+  # x <- gsub("""", ""&szlig;"", x, fixed = TRUE, useBytes = TRUE)
+
+  x
 }
 
 

---FILE: R/html_print.R---
@@ -277,8 +277,6 @@ tab_model_df <- function(x,
   style <- tab_df_style(CSS = CSS, ...)
 
 
-  ## TODO add table caption afterwards
-
   # get HTML content
   page.content <- tab_df_content(
     mydf = x,
@@ -643,10 +641,17 @@ tab_model_df <- function(x,
 
   ## TODO add bottom table border
 
+  # add table-caption ----
+
+  if (!is.null(title))
+    table.caption <- sprintf(""<caption>%s</caption>\n"", title)
+  else
+    table.caption <- """"
+
 
   # surround output with table-tag ----
 
-  page.content <- paste0(""<table>\n"", page.content, ""\n<table>\n"")
+  page.content <- paste0(""<table>\n"", table.caption, page.content, ""\n<table>\n"")
 
   # create HTML page with header information
   page.complete <- tab_create_page(

---FILE: R/html_print_utils.R---
@@ -399,7 +399,6 @@ tab_df_prepare_style <- function(CSS = NULL, content = NULL, task, ...) {
     content <- gsub(""class="", ""style="", content, fixed = TRUE, useBytes = TRUE)
     content <- gsub(""<table"", sprintf(""<table style=\""%s\"""", css.table), content, fixed = TRUE, useBytes = TRUE)
     content <- gsub(""<caption"", sprintf(""<caption style=\""%s\"""", css.caption), content, fixed = TRUE, useBytes = TRUE)
-    content <- gsub(""<td"", sprintf(""<td style=\""%s\"""", css.td), content, fixed = TRUE, useBytes = TRUE)
 
     # replace class-attributes with inline-style-definitions
     content <- gsub(tag.tdata, css.tdata, content, fixed = TRUE, useBytes = TRUE)
@@ -412,8 +411,8 @@ tab_df_prepare_style <- function(CSS = NULL, content = NULL, task, ...) {
     content <- gsub(tag.firsttablecol, css.firsttablecol, content, fixed = TRUE, useBytes = TRUE)
     content <- gsub(tag.leftalign, css.leftalign, content, fixed = TRUE, useBytes = TRUE)
     content <- gsub(tag.centeralign, css.centeralign, content, fixed = TRUE, useBytes = TRUE)
-    content <- gsub(tag.summary, css.summary, content, fixed = TRUE, useBytes = TRUE)
     content <- gsub(tag.summarydata, css.summarydata, content, fixed = TRUE, useBytes = TRUE)
+    content <- gsub(tag.summary, css.summary, content, fixed = TRUE, useBytes = TRUE)
     content <- gsub(tag.fixedparts, css.fixedparts, content, fixed = TRUE, useBytes = TRUE)
     content <- gsub(tag.randomparts, css.randomparts, content, fixed = TRUE, useBytes = TRUE)
     content <- gsub(tag.zeroparts, css.zeroparts, content, fixed = TRUE, useBytes = TRUE)
@@ -434,6 +433,8 @@ tab_df_prepare_style <- function(CSS = NULL, content = NULL, task, ...) {
     content <- gsub(tag.modelcolumn5, css.modelcolumn5, content, fixed = TRUE, useBytes = TRUE)
     content <- gsub(tag.modelcolumn6, css.modelcolumn6, content, fixed = TRUE, useBytes = TRUE)
     content <- gsub(tag.modelcolumn7, css.modelcolumn7, content, fixed = TRUE, useBytes = TRUE)
+
+    content <- gsub(""<td style=\"""", sprintf(""<td style=\""%s "", css.td), content, fixed = TRUE, useBytes = TRUE)
   }
 
   content

---FILE: R/plot_model.R---
@@ -253,7 +253,7 @@
 #' @param bpe For \strong{Stan}-models (fitted with the \pkg{rstanarm}- or
 #'   \pkg{brms}-package), the Bayesian point estimate is, by default, the median
 #'   of the posterior distribution. Use \code{bpe} to define other functions to
-#'   calculate the Bayesion point estimate. \code{bpe} needs to be a character
+#'   calculate the Bayesian point estimate. \code{bpe} needs to be a character
 #'   naming the specific function, which is passed to the \code{fun}-argument in
 #'   \code{\link[sjstats]{typical_value}}. So, \code{bpe = ""mean""} would
 #'   calculate the mean value of the posterior distribution.
@@ -508,7 +508,7 @@ plot_model <- function(model,
   if (type %in% c(""est"", ""std"", ""std2"") && isTRUE(auto.label)) {
 
     # get labels of dependent variables, and wrap them if too long
-    if (is.null(title)) title <- sjlabelled::get_dv_labels(model, case = case, ...)
+    if (is.null(title)) title <- sjlabelled::get_dv_labels(model, case = case, multi.resp = fam.info$is_multivariate, ...)
     title <- sjmisc::word_wrap(title, wrap = wrap.title)
 
     # labels for axis with term names

---FILE: R/plot_point_estimates.R---
@@ -93,22 +93,21 @@ plot_point_estimates <- function(model,
     }
 
     # define style for Bayesian point estimate
-    if (bpe.style == ""line"")
+    if (bpe.style == ""line"") {
       if (is.null(bpe.color)) {
         p <- p +
           geom_segment(aes_string(x = ""xmin"", xend = ""xmax"", y = ""estimate"", yend = ""estimate""), size = geom.size * .9)
       } else {
         p <- p +
           geom_segment(aes_string(x = ""xmin"", xend = ""xmax"", y = ""estimate"", yend = ""estimate""), colour = bpe.color, size = geom.size * .9)
       }
-    else
-      if (is.null(bpe.color)) {
+    } else if (is.null(bpe.color)) {
         p <- p +
           geom_point(aes_string(y = ""estimate""), fill = ""white"", size = geom.size * 1.2)
-      } else {
-        p <- p +
-          geom_point(aes_string(y = ""estimate""), fill = ""white"", colour = bpe.color, size = geom.size * 1.2)
-      }
+    } else {
+      p <- p +
+        geom_point(aes_string(y = ""estimate""), fill = ""white"", colour = bpe.color, size = geom.size * 1.2)
+    }
 
   } else {
 

---FILE: R/plot_type_est.R---
@@ -48,6 +48,40 @@ plot_type_est <- function(type,
     show.intercept <- FALSE
   }
 
+  # fix brms coefficient names
+
+  if (inherits(model, ""brmsfit"")) {
+    dat$term <- gsub(""^b_"", """", dat$term)
+  }
+
+
+  # check if facet groups need to be replaced with title
+
+  if (length(title) > 1) {
+
+    tnames <- names(title)
+
+    if (tibble::has_name(dat, ""facet"") && !is.null(tnames)) {
+      if (all(tnames %in% dat$facet)) {
+        for (i in tnames) {
+          dat$facet[which(dat$facet == i)] <- title[i]
+        }
+        title <- """"
+      }
+    }
+
+    if (tibble::has_name(dat, ""response.level"") && !is.null(tnames)) {
+      if (all(tnames %in% dat$response.level)) {
+        for (i in tnames) {
+          dat$response.level[which(dat$response.level == i)] <- title[i]
+        }
+        title <- """"
+      }
+    }
+
+  }
+
+
   # se needs to be logical from here on
   if (!is.null(se) && !is.logical(se)) se <- TRUE
 

---FILE: R/sjTabFrequencies.R---
@@ -87,33 +87,6 @@
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjp.frq
 #'
-#' @note The HTML tables can either be saved as file and manually opened (use argument \code{file}) or
-#'         they can be saved as temporary files and will be displayed in the RStudio Viewer pane (if working with RStudio)
-#'         or opened with the default web browser. Displaying resp. opening a temporary file is the
-#'         default behaviour (i.e. \code{file = NULL}).
-#'
-#' @details \bold{How do I use \code{CSS}-argument?}
-#'            \cr \cr
-#'            With the \code{CSS}-argument, the visual appearance of the tables
-#'            can be modified. To get an overview of all style-sheet-classnames
-#'            that are used in this function, see return value \code{page.style} for details.
-#'            Arguments for this list have following syntax:
-#'          \enumerate{
-#'            \item the class-names with \code{""css.""}-prefix as argument name and
-#'            \item each style-definition must end with a semicolon
-#'          }
-#'          You can add style information to the default styles by using a + (plus-sign) as
-#'          initial character for the argument attributes. Examples:
-#'          \itemize{
-#'            \item \code{css.table = 'border:2px solid red;'} for a solid 2-pixel table border in red.
-#'            \item \code{css.summary = 'font-weight:bold;'} for a bold fontweight in the summary row.
-#'            \item \code{css.lasttablerow = 'border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-#'            \item \code{css.colnames = '+color:green'} to add green color formatting to column names.
-#'            \item \code{css.arc = 'color:blue;'} for a blue text color each 2nd row.
-#'            \item \code{css.caption = '+color:red;'} to add red font-color to the default table caption style.
-#'          }
-#'          See further examples in \href{../doc/sjtbasic.html}{this package-vignette}.
-#'
 #' @examples
 #' \dontrun{
 #' # load sample data

---FILE: R/sjTabLinReg.R---
@@ -120,25 +120,6 @@
 #'            }
 #'            for further use.
 #'
-#' @note See 'Note' in \code{\link{sjt.frq}}.
-#'
-#' @details Concerning the \code{show.std} argument, \code{show.std = ""std""}
-#'            will print normal standardized estimates. For \code{show.std = ""std2""},
-#'            however, standardization of estimates follows
-#'            \href{http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf}{Gelman's (2008)}
-#'            suggestion, rescaling the estimates by dividing them by two standard
-#'            deviations instead of just one. Resulting coefficients are then
-#'            directly comparable for untransformed binary predictors. This type
-#'            of standardization uses the \code{\link[arm]{standardize}}-function
-#'            from the \pkg{arm}-package.
-#'            For backward compatibility reasons, \code{show.std} also may be
-#'            a logical value; if \code{TRUE}, normal standardized estimates are
-#'            printed (same effect as \code{show.std = ""std""}). Use
-#'            \code{show.std = NULL} (default) or \code{show.std = FALSE},
-#'            if standardized estimats should not be printed.
-#'            \cr \cr
-#'            Furthermore, see 'Details' in \code{\link{sjt.frq}}.
-#'
 #' @examples
 #' \dontrun{
 #' # Now fit the models. Note that both models share the same predictors

---FILE: R/tab_model.R---
@@ -1,9 +1,10 @@
-#' @title Print regression models to HTML table
+#' @title Print regression models as HTML table
 #' @name tab_model
 #'
 #' @description
 #'   \code{tab_model()} creates HTML tables from regression models.
 #'
+#' @param title String, will be used as table caption.
 #' @param transform A character vector, naming a function that will be applied
 #'   on estimates and confidence intervals. By default, \code{transform} will
 #'   automatically use \code{""exp""} as transformation for applicable classes of
@@ -59,6 +60,7 @@
 #' @param show.std Indicates whether standardized beta-coefficients should
 #'    also printed, and if yes, which type of standardization is done.
 #'    See 'Details'.
+#' @param show.p Logical, if \code{TRUE}, p-values are also printed.
 #' @param show.se Logical, if \code{TRUE}, the standard errors are also printed.
 #' @param show.r2 Logical, if \code{TRUE}, the r-squared value is also printed.
 #'    Depending on the model, these might be pseudo-r-squared values, or Bayesian
@@ -93,6 +95,57 @@
 #' @inheritParams plot_models
 #' @inheritParams plot_model
 #'
+#' @return Invisibly returns
+#'          \itemize{
+#'            \item the web page style sheet (\code{page.style}),
+#'            \item the web page content (\code{page.content}),
+#'            \item the complete html-output (\code{page.complete}) and
+#'            \item the html-table with inline-css for use with knitr (\code{knitr})
+#'            }
+#'            for further use.
+#'
+#' @note The HTML tables can either be saved as file and manually opened (use argument \code{file}) or
+#'         they can be saved as temporary files and will be displayed in the RStudio Viewer pane (if working with RStudio)
+#'         or opened with the default web browser. Displaying resp. opening a temporary file is the
+#'         default behaviour (i.e. \code{file = NULL}).
+#'
+#' @details \strong{Standardized Estimates}
+#'    \cr \cr
+#'    Concerning the \code{show.std} argument, \code{show.std = ""std""}
+#'    will print normal standardized estimates. For \code{show.std = ""std2""},
+#'    however, standardization of estimates follows
+#'    \href{http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf}{Gelman's (2008)}
+#'    suggestion, rescaling the estimates by dividing them by two standard
+#'    deviations instead of just one. Resulting coefficients are then
+#'    directly comparable for untransformed binary predictors. This type
+#'    of standardization uses the \code{\link[arm]{standardize}}-function
+#'    from the \pkg{arm}-package.
+#'    For backward compatibility reasons, \code{show.std} also may be
+#'    a logical value; if \code{TRUE}, normal standardized estimates are
+#'    printed (same effect as \code{show.std = ""std""}). Use
+#'    \code{show.std = NULL} (default) or \code{show.std = FALSE},
+#'    if standardized estimats should not be printed.
+#'    \cr \cr
+#'    \strong{How do I use \code{CSS}-argument?}
+#'    \cr \cr
+#'    With the \code{CSS}-argument, the visual appearance of the tables
+#'    can be modified. To get an overview of all style-sheet-classnames
+#'    that are used in this function, see return value \code{page.style} for details.
+#'    Arguments for this list have following syntax:
+#'    \enumerate{
+#'      \item the class-names with \code{""css.""}-prefix as argument name and
+#'      \item each style-definition must end with a semicolon
+#'    }
+#'    You can add style information to the default styles by using a + (plus-sign) as
+#'    initial character for the argument attributes. Examples:
+#'    \itemize{
+#'      \item \code{css.table = 'border:2px solid red;'} for a solid 2-pixel table border in red.
+#'      \item \code{css.summary = 'font-weight:bold;'} for a bold fontweight in the summary row.
+#'      \item \code{css.lasttablerow = 'border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+#'      \item \code{css.colnames = '+color:green'} to add green color formatting to column names.
+#'      \item \code{css.arc = 'color:blue;'} for a blue text color each 2nd row.
+#'      \item \code{css.caption = '+color:red;'} to add red font-color to the default table caption style.
+#'    }
 #
 #' @importFrom dplyr full_join select if_else mutate
 #' @importFrom tibble lst add_case as_tibble
@@ -409,6 +462,14 @@ tab_model <- function(
       if (show.dev) dev <- model_deviance(model)
 
 
+      # fix brms coefficient names
+
+      if (inherits(model, ""brmsfit"")) {
+        dat$term <- gsub(""^b_"", """", dat$term)
+        zidat$term <- gsub(""^b_"", """", zidat$term)
+      }
+
+
       list(
         dat = dat,
         transform = transform,
@@ -547,8 +608,12 @@ tab_model <- function(
   # get default labels for dv and terms ----
 
   if (isTRUE(auto.label) && sjmisc::is_empty(pred.labels)) {
-    pred.labels <- sjlabelled::get_term_labels(models, mark.cat = TRUE, case = case)
-    pred.labels <- pred.labels[!duplicated(names(pred.labels))]
+    ## TODO fix in sjlabelled
+    pred.labels <- sjlabelled::get_term_labels(models, case = case)
+    pred.cat <- sjlabelled::get_term_labels(models, mark.cat = TRUE)
+    no.dupes <- !duplicated(names(pred.labels))
+    pred.labels <- pred.labels[no.dupes]
+    attr(pred.labels, ""category.value"") <- attr(pred.cat, ""category.value"")[no.dupes]
     pred.labels <- prepare.labels(pred.labels, grp = group.terms)
   } else {
     # no automatic grouping of table rows for categorical variables
@@ -635,7 +700,7 @@ tab_model <- function(
   # get proper column header labels ----
 
   col.header <- purrr::map_chr(colnames(dat), function(x) {
-    pos <- grep(""estimate"", x, fixed = T)
+    pos <- grep(""^estimate_"", x)
 
     if (!sjmisc::is_empty(pos)) {
       i <- as.numeric(sub(""estimate_"", """", x = x, fixed = T))
@@ -671,40 +736,40 @@ tab_model <- function(
     }
 
 
-    pos <- grep(""term"", x, fixed = T)
+    pos <- grep(""^term"", x)
     if (!sjmisc::is_empty(pos)) x <- string.pred
 
-    pos <- grep(""conf.int"", x, fixed = T)
+    pos <- grep(""^conf.int"", x)
     if (!sjmisc::is_empty(pos)) x <- string.ci
 
-    pos <- grep(""std.error"", x, fixed = T)
+    pos <- grep(""^std.error"", x)
     if (!sjmisc::is_empty(pos)) x <- string.se
 
-    pos <- grep(""std.estimate"", x, fixed = T)
+    pos <- grep(""^std.estimate"", x)
     if (!sjmisc::is_empty(pos)) x <- string.std
 
-    pos <- grep(""std.se"", x, fixed = T)
-    if (!sjmisc::is_empty(pos)) x <- paste(""std."", string.se)
+    pos <- grep(""^std.se"", x)
+    if (!sjmisc::is_empty(pos)) x <- paste(""standardized"", string.se)
 
-    pos <- grep(""std.conf.int"", x, fixed = T)
-    if (!sjmisc::is_empty(pos)) x <- paste(""std."", string.ci)
+    pos <- grep(""^std.conf.int"", x)
+    if (!sjmisc::is_empty(pos)) x <- paste(""standardized"", string.ci)
 
-    pos <- grep(""p.value"", x, fixed = T)
+    pos <- grep(""^p.value"", x)
     if (!sjmisc::is_empty(pos)) x <- string.p
 
-    pos <- grep(""df"", x, fixed = T)
+    pos <- grep(""^df"", x)
     if (!sjmisc::is_empty(pos)) x <- string.df
 
-    pos <- grep(""statistic"", x, fixed = T)
+    pos <- grep(""^statistic"", x)
     if (!sjmisc::is_empty(pos)) x <- string.stat
 
-    pos <- grep(""response.level"", x, fixed = T)
+    pos <- grep(""^response.level"", x)
     if (!sjmisc::is_empty(pos)) x <- ""Response""
 
-    pos <- grep(""hdi.inner"", x, fixed = T)
+    pos <- grep(""^hdi.inner"", x)
     if (!sjmisc::is_empty(pos)) x <- ""HDI (50%)""
 
-    pos <- grep(""hdi.outer"", x, fixed = T)
+    pos <- grep(""^hdi.outer"", x)
     if (!sjmisc::is_empty(pos)) x <- sprintf(""HDI (%i%%)"", round(100 * show.ci))
 
     x

---FILE: R/utils.R---
@@ -121,6 +121,7 @@ estimate_axis_title <- function(fit, axis.title, type, transform = NULL, multi.r
       !is.null(transform) && transform == ""plogis"" ~ ""Probabilities"",
       is.null(transform) && fitfam$is_bin ~ ""Log-Odds"",
       is.null(transform) && fitfam$is_ordinal ~ ""Log-Odds"",
+      is.null(transform) && fitfam$is_pois ~ ""Log-Mean"",
       fitfam$is_pois ~ ""Incidence Rate Ratios"",
       fitfam$is_ordinal ~ ""Odds Ratios"",
       fitfam$is_bin && !fitfam$is_logit ~ ""Risk Ratios"",
@@ -175,10 +176,11 @@ nulldef <- function(x, y, z = NULL) {
 geom_intercept_line <- function(yintercept, axis.scaling, vline.color) {
   if (yintercept > axis.scaling$axis.lim[1] && yintercept < axis.scaling$axis.lim[2]) {
     t <- theme_get()
+    if (is.null(t$panel.grid.major)) t$panel.grid.major <- t$panel.grid
     color <- nulldef(vline.color, t$panel.grid.major$colour, ""grey90"")
     minor_size <- nulldef(t$panel.grid.minor$size, .125)
-    major_size <- nulldef(t$panel.grid.major$size, minor_size * 2)
-    size <- major_size * 2
+    major_size <- nulldef(t$panel.grid.major$size, minor_size * 1.5)
+    size <- major_size * 1.5
     geom_hline(yintercept = yintercept, color = color, size = size)
   } else {
     NULL
@@ -188,10 +190,11 @@ geom_intercept_line <- function(yintercept, axis.scaling, vline.color) {
 # same as above, but no check if intercept is within boundaries or not
 geom_intercept_line2 <- function(yintercept, vline.color) {
   t <- theme_get()
+  if (is.null(t$panel.grid.major)) t$panel.grid.major <- t$panel.grid
   color <- nulldef(vline.color, t$panel.grid.major$colour, ""grey90"")
   minor_size <- nulldef(t$panel.grid.minor$size, .125)
-  major_size <- nulldef(t$panel.grid.major$size, minor_size * 2)
-  size <- major_size * 2
+  major_size <- nulldef(t$panel.grid.major$size, minor_size * 1.5)
+  size <- major_size * 1.5
   geom_hline(yintercept = yintercept, color = color, size = size)
 }
 

---FILE: man/plot_model.Rd---
@@ -315,7 +315,7 @@ details.}
 \item{bpe}{For \strong{Stan}-models (fitted with the \pkg{rstanarm}- or
 \pkg{brms}-package), the Bayesian point estimate is, by default, the median
 of the posterior distribution. Use \code{bpe} to define other functions to
-calculate the Bayesion point estimate. \code{bpe} needs to be a character
+calculate the Bayesian point estimate. \code{bpe} needs to be a character
 naming the specific function, which is passed to the \code{fun}-argument in
 \code{\link[sjstats]{typical_value}}. So, \code{bpe = ""mean""} would
 calculate the mean value of the posterior distribution.}

---FILE: man/sjt.frq.Rd---
@@ -140,35 +140,6 @@ Invisibly returns
 \description{
 Shows (multiple) frequency tables as HTML file, or saves them as file.
 }
-\details{
-\bold{How do I use \code{CSS}-argument?}
-           \cr \cr
-           With the \code{CSS}-argument, the visual appearance of the tables
-           can be modified. To get an overview of all style-sheet-classnames
-           that are used in this function, see return value \code{page.style} for details.
-           Arguments for this list have following syntax:
-         \enumerate{
-           \item the class-names with \code{""css.""}-prefix as argument name and
-           \item each style-definition must end with a semicolon
-         }
-         You can add style information to the default styles by using a + (plus-sign) as
-         initial character for the argument attributes. Examples:
-         \itemize{
-           \item \code{css.table = 'border:2px solid red;'} for a solid 2-pixel table border in red.
-           \item \code{css.summary = 'font-weight:bold;'} for a bold fontweight in the summary row.
-           \item \code{css.lasttablerow = 'border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-           \item \code{css.colnames = '+color:green'} to add green color formatting to column names.
-           \item \code{css.arc = 'color:blue;'} for a blue text color each 2nd row.
-           \item \code{css.caption = '+color:red;'} to add red font-color to the default table caption style.
-         }
-         See further examples in \href{../doc/sjtbasic.html}{this package-vignette}.
-}
-\note{
-The HTML tables can either be saved as file and manually opened (use argument \code{file}) or
-        they can be saved as temporary files and will be displayed in the RStudio Viewer pane (if working with RStudio)
-        or opened with the default web browser. Displaying resp. opening a temporary file is the
-        default behaviour (i.e. \code{file = NULL}).
-}
 \examples{
 \dontrun{
 # load sample data

---FILE: man/sjt.lm.Rd---
@@ -212,27 +212,6 @@ Summarizes (multiple) fitted linear models (coefficients, std. beta values etc.)
                from the \pkg{plm}-package and generalized least squares models fitted with
                the \code{gls}-function from the \pkg{nlme}-package.
 }
-\details{
-Concerning the \code{show.std} argument, \code{show.std = ""std""}
-           will print normal standardized estimates. For \code{show.std = ""std2""},
-           however, standardization of estimates follows
-           \href{http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf}{Gelman's (2008)}
-           suggestion, rescaling the estimates by dividing them by two standard
-           deviations instead of just one. Resulting coefficients are then
-           directly comparable for untransformed binary predictors. This type
-           of standardization uses the \code{\link[arm]{standardize}}-function
-           from the \pkg{arm}-package.
-           For backward compatibility reasons, \code{show.std} also may be
-           a logical value; if \code{TRUE}, normal standardized estimates are
-           printed (same effect as \code{show.std = ""std""}). Use
-           \code{show.std = NULL} (default) or \code{show.std = FALSE},
-           if standardized estimats should not be printed.
-           \cr \cr
-           Furthermore, see 'Details' in \code{\link{sjt.frq}}.
-}
-\note{
-See 'Note' in \code{\link{sjt.frq}}.
-}
 \examples{
 \dontrun{
 # Now fit the models. Note that both models share the same predictors

---FILE: man/tab_model.Rd---
@@ -2,7 +2,7 @@
 % Please edit documentation in R/tab_model.R
 \name{tab_model}
 \alias{tab_model}
-\title{Print regression models to HTML table}
+\title{Print regression models as HTML table}
 \usage{
 tab_model(..., transform, show.intercept = TRUE, show.est = TRUE,
   show.ci = 0.95, show.hdi50 = TRUE, show.se = NULL, show.std = NULL,
@@ -46,8 +46,7 @@ confidence intervals.}
 also printed, and if yes, which type of standardization is done.
 See 'Details'.}
 
-\item{show.p}{Logical, adds asterisks that indicate the significance level of
-estimates to the value labels.}
+\item{show.p}{Logical, if \code{TRUE}, p-values are also printed.}
 
 \item{show.stat}{Logical, if \code{TRUE}, the coefficients' test statistic
 is also printed.}
@@ -101,10 +100,7 @@ row is inserted to the table just before the predictor values.}
 should be plotted. See examples in
 \href{../doc/plot_model_estimates.html}{this package-vignette}.}
 
-\item{title}{Character vector, used as plot title. By default,
-\code{\link[sjlabelled]{get_dv_labels}} is called to retrieve the label of
-the dependent variable, which will be used as title. Use \code{title = """"}
-to remove title.}
+\item{title}{String, will be used as table caption.}
 
 \item{pred.labels}{Character vector with labels of predictor variables.
 If not \code{NULL}, \code{pred.labels} will be used in the first
@@ -172,11 +168,66 @@ original variable names and value labels (factor levels) are used.}
 \item{bpe}{For \strong{Stan}-models (fitted with the \pkg{rstanarm}- or
 \pkg{brms}-package), the Bayesian point estimate is, by default, the median
 of the posterior distribution. Use \code{bpe} to define other functions to
-calculate the Bayesion point estimate. \code{bpe} needs to be a character
+calculate the Bayesian point estimate. \code{bpe} needs to be a character
 naming the specific function, which is passed to the \code{fun}-argument in
 \code{\link[sjstats]{typical_value}}. So, \code{bpe = ""mean""} would
 calculate the mean value of the posterior distribution.}
 }
+\value{
+Invisibly returns
+         \itemize{
+           \item the web page style sheet (\code{page.style}),
+           \item the web page content (\code{page.content}),
+           \item the complete html-output (\code{page.complete}) and
+           \item the html-table with inline-css for use with knitr (\code{knitr})
+           }
+           for further use.
+}
 \description{
 \code{tab_model()} creates HTML tables from regression models.
 }
+\details{
+\strong{Standardized Estimates}
+   \cr \cr
+   Concerning the \code{show.std} argument, \code{show.std = ""std""}
+   will print normal standardized estimates. For \code{show.std = ""std2""},
+   however, standardization of estimates follows
+   \href{http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf}{Gelman's (2008)}
+   suggestion, rescaling the estimates by dividing them by two standard
+   deviations instead of just one. Resulting coefficients are then
+   directly comparable for untransformed binary predictors. This type
+   of standardization uses the \code{\link[arm]{standardize}}-function
+   from the \pkg{arm}-package.
+   For backward compatibility reasons, \code{show.std} also may be
+   a logical value; if \code{TRUE}, normal standardized estimates are
+   printed (same effect as \code{show.std = ""std""}). Use
+   \code{show.std = NULL} (default) or \code{show.std = FALSE},
+   if standardized estimats should not be printed.
+   \cr \cr
+   \strong{How do I use \code{CSS}-argument?}
+   \cr \cr
+   With the \code{CSS}-argument, the visual appearance of the tables
+   can be modified. To get an overview of all style-sheet-classnames
+   that are used in this function, see return value \code{page.style} for details.
+   Arguments for this list have following syntax:
+   \enumerate{
+     \item the class-names with \code{""css.""}-prefix as argument name and
+     \item each style-definition must end with a semicolon
+   }
+   You can add style information to the default styles by using a + (plus-sign) as
+   initial character for the argument attributes. Examples:
+   \itemize{
+     \item \code{css.table = 'border:2px solid red;'} for a solid 2-pixel table border in red.
+     \item \code{css.summary = 'font-weight:bold;'} for a bold fontweight in the summary row.
+     \item \code{css.lasttablerow = 'border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+     \item \code{css.colnames = '+color:green'} to add green color formatting to column names.
+     \item \code{css.arc = 'color:blue;'} for a blue text color each 2nd row.
+     \item \code{css.caption = '+color:red;'} to add red font-color to the default table caption style.
+   }
+}
+\note{
+The HTML tables can either be saved as file and manually opened (use argument \code{file}) or
+        they can be saved as temporary files and will be displayed in the RStudio Viewer pane (if working with RStudio)
+        or opened with the default web browser. Displaying resp. opening a temporary file is the
+        default behaviour (i.e. \code{file = NULL}).
+}

---FILE: vignettes/sjtlm.Rmd---
@@ -1,235 +0,0 @@
----
-title: ""Summary of Linear Regression Models as HTML Table""
-author: ""Daniel Ldecke""
-date: ""`r Sys.Date()`""
-output: rmarkdown::html_vignette
-vignette: >
-  %\VignetteIndexEntry{Summary of Linear Regression Models as HTML Table}
-  %\VignetteEngine{knitr::rmarkdown}
-  %\VignetteEncoding{UTF-8}
----
-
-```{r echo = FALSE}
-knitr::opts_chunk$set(collapse = TRUE, comment = ""#>"", warning = FALSE, message = FALSE)
-```
-
-This document shows examples for using the `sjt.lm()` function of the sjPlot package.
-
-```{r}
-# load package
-library(sjPlot)
-library(sjmisc)
-library(sjlabelled)
-
-# sample data
-data(efc)
-```
-
-## Linear model summaries as HTML table
-
-The `sjt.lm()` function prints summaries of linear models (fitted with the `lm()` function) as nicely formatted html-tables.
-
-Before starting, sample data is loaded and sample models are fitted:
-
-```{r, results='hide'}
-# fit first model
-fit1 <- lm(barthtot ~ c160age + c12hour + c161sex + c172code, data = efc)
-# fit second model 
-fit2 <- lm(neg_c_7 ~ c160age + c12hour + c161sex + c172code, data = efc)
-# Note that both models share the same predictors and only differ 
-# in their dependent variable. See examples of stepwise models 
-# later...
-``` 
-
-The simplest way of producing the table output is by passing the fitted models as parameter. By default, estimates (_B_), confidence intervals (_CI_) and p-values (_p_) are reported. The models are named _Model 1_ and _Model 2_.
-
-```{r}
-sjt.lm(fit1, fit2)
-```
-
-
-### Custom labels
-You can specify the 'model' label via `depvar.labels` parameter:
-
-```{r}
-sjt.lm(fit1, fit2, depvar.labels = c(""Barthel-Index"", ""Negative Impact""))
-```
-
-
-### More custom labels
-Here is an example how to change the other labels. Note that `show.header` makes the two labels on top and top left corner appear in the table.
-
-```{r}
-sjt.lm(
-  fit1,
-  fit2,
-  show.header = TRUE,
-  string.est = ""Estimate"",
-  string.ci = ""Conf. Int."",
-  string.p = ""p-value"",
-  string.dv = ""Response"",
-  string.pred = ""Coefficients"",
-  string.interc = ""Konstante"",
-  depvar.labels = c(""Barthel-Index"", ""Negative Impact"")
-)
-```
-
-
-## Changing summary style and content
-
-You can change the table style with specific parameters, e.g. to include CI into the same table cell as the estimates, print asterisks instead of numeric p-values etc.
-
-```{r}
-sjt.lm(
-  fit1,
-  fit2,
-  separate.ci.col = FALSE, # ci in same cell as estimates
-  show.std = TRUE,         # also show standardized beta values
-  p.numeric = FALSE        # ""*"" instead of numeric values
-)       
-```
-
-
-
-## Custom variable labels
-
-In the above example, the original variable labels are long and not so pretty. You can change variable labels either with `sjmisc::set_label()`, which will affect all future plots and tables, or pass own labels via `pred.labels`.
-
-```{r}
-sjt.lm(fit1, fit2, pred.labels = c(""Carer's Age"", ""Hours of Care"", ""Carer's Sex"", ""Educational Status""))
-```
-
-
-## Compare models with different predictors
-
-In some cases, for instance stepwise regressions, you have different predictors on the same response. The proper grouping of predictors, resp. rows, is done automatically.
-
-First, let's fit some example models.
-
-```{r, results='hide'}
-# fit first model
-fit1 <- lm(neg_c_7 ~ c160age + c172code + c161sex, data = efc)
-# fit second model
-fit2 <- lm(neg_c_7 ~ c160age + c172code + c161sex + c12hour, data = efc)
-# fit second model
-fit3 <- lm(neg_c_7 ~ c160age + c172code + e42dep + tot_sc_e, data = efc)
-```
-
-Note that printing tables with fitted models, which have different predictors do not automatically detect variable labels (maybe this will be implemented in a future package version).
-
-```{r}
-sjt.lm(fit1, fit2, fit3, 
-       separate.ci.col = FALSE,
-       show.aic = TRUE,
-       show.fstat = TRUE)
-```
-
-
-## More space bewteen model columns
-
-Especially when fitting and summarizing some more models, it might help to increase the distance between the columns that separate the models. This can be done by tweaking the `css.separatorcol` style-sheet:
-
-```{r}
-sjt.lm(fit1, fit2, fit3, CSS = list(css.separatorcol = 'padding-right:1.5em; padding-left:1.5em;'))
-```
-
-
-## Automatic grouping of categorical predictors
-
-In case you have categorical variables with more than two factor levels, the `sjt.lm()` function automatically groups the category levels to give a better overview of predictors in the table.
-
-By default, automatic grouping is activated. To disable this feature, use `group.pred = FALSE` as parameter.
-
-To demonstrate this feature, we first convert two predictors to factors (what they actually are, indeed). To do this, we use the `sjmisc::to_factor()` function, which converts numerical variables into factors, however, does not remove the variable and value label attributes.
-
-```{r, results='hide'}
-# make education categorical
-efc$c172code <- to_factor(efc$c172code)
-# make dependency categorical
-efc$e42dep <- to_factor(efc$e42dep)
-# fit first model again (with c172code as factor)
-fit1 <- lm(barthtot ~ c160age + c12hour + c172code + c161sex + e42dep, data = efc)
-# fit second model again (with c172code as factor)
-fit2 <- lm(neg_c_7 ~ c160age + c12hour + c172code + c161sex + e42dep, data = efc)
-```
-
-Now we can print the table.
-
-```{r}
-sjt.lm(fit1, fit2)
-```
-
-
-## Removing estimates from the output
-
-With `remove.estimates`, specific estimates can be removed from the table output. This may make sense in case you have stepwise regression models and only want to compare the varying predictors but not the controls. `remove.estimates` either accepts the row indices of the rows of the table output that should be removed, or the coefficient's names.
-
-When using numeric indices, the estimates' index number relates to the same order as `coef(fit)`.
-
-_Note that automatic grouping of categorical predictors (argument_ `group.pred`_) does not yet work properly when removing estimates!_ See also Example 6 for further details.
-
-```{r, results='hide'}
-data(efc)
-# make education categorical
-efc$c172code <- to_factor(efc$c172code)
-# make education categorical
-efc$e42dep <- to_factor(efc$e42dep)
-# make prettier variable labels
-set_label(efc$c172code) <- ""Education""
-set_label(efc$e42dep) <- ""Dependency""
-# fit first model
-fit1 <- lm(neg_c_7 ~ c160age + c172code + c161sex, data = efc)
-# fit second model
-fit2 <- lm(neg_c_7 ~ c160age + c172code + c161sex + c12hour, data = efc)
-# fit third model
-fit3 <- lm(neg_c_7 ~ c160age + c172code + e42dep + tot_sc_e, data = efc)
-```
-
-### Example 1: Complete table output
-
-Here you have the complete table output. This helps you identify the row index numbers. Especially when you have multiple models with different predictors, the estimate's position in the last model may differ from this estimate's position in the table output.
-
-```{r}
-sjt.lm(fit1, fit2, fit3, group.pred = FALSE)
-```
-
-### Example 2: Removing the intercept
-
-Note that currently the intercept cannot be removed from the model output. However, you can ""fake"" a removed intercept by setting the font size of the first row (with intercept) to zero via `CSS = list(css.topcontentborder = ""+font-size: 0px;"")`.
-
-```{r}
-sjt.lm(fit1, fit2, fit3, group.pred = FALSE, CSS = list(css.topcontentborder = ""+font-size: 0px;""))
-```
-
-### Example 3: Remove first coefficient (after intercept)
-
-```{r}
-sjt.lm(fit1, fit2, fit3, group.pred = FALSE, remove.estimates = 2)
-```
-
-### Example 4: Remove age and sex
-
-```{r}
-sjt.lm(fit1, fit2, fit3, group.pred = FALSE, remove.estimates = c(""c160age"", ""c161sex""))
-```
-
-### Example 5: Remove many esimates
-
-```{r}
-sjt.lm(fit1, fit2, fit3, group.pred = FALSE, remove.estimates = c(2,5,6,10))
-```
-
-### Example 6: Custom predictor labels
-
-In most cases you need to define your own labels when removing estimates, especially when you have grouped categorical predictors, because automatic label detection is quite tricky in such situations. If you provide own labels, please note that grouped predictors' headings (the variable name of the grouped, categorical variable) are still automatically set by the `sjt.lm()` function (variable labels are used, so use `set_label()` for those categorical predictors). All data rows in the table, i.e. for each coefficient appearing in the model, you need to specify a label string.
-
-In the next example, we have seven table rows with data (excluding intercept): mid and hi education (categories of the variable Education), Hours of Care, slight, moderate and severe dependency (categories of the variable Dependency) and Service Usage. These 'rows' need to be labelled.
-
-```{r}
-sjt.lm(fit1, fit2, fit3,
-       pred.labels = c(""mid education"", ""hi education"", ""Hours of Care"", 
-                       ""slight dependency"", ""moderate dependency"", 
-                       ""severe dependency"", ""Service Usage""),
-       remove.estimates = c(""c160age"", ""c161sex""))
-```
-

---FILE: vignettes/tab_model_estimates.Rmd---
@@ -0,0 +1,187 @@
+---
+title: ""Summary of Regression Models as HTML Table""
+author: ""Daniel Ldecke""
+date: ""`r Sys.Date()`""
+output: rmarkdown::html_vignette
+vignette: >
+  %\VignetteIndexEntry{Summary of Regression Models as HTML Table}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+
+```{r echo = FALSE}
+knitr::opts_chunk$set(collapse = TRUE, comment = ""#>"", warning = FALSE, message = FALSE)
+```
+
+`tab_model()` is the pendant to `plot_model()`, however, instead of creating plots, `tab_model()` creates HTML-tables that will be displayed either in your IDE's viewer-pane, in a web browser or in a knitr-markdown-document (like this vignette).
+
+HTML is the only output-format, you can't (directly) create a LaTex or PDF output from `tab_model()` and related table-functions. However, it is possible to easily export the tables into Microsoft Word or Libre Office Writer.
+
+This vignette shows how to create table from regression models with `tab_model()`.
+
+**Note!** Due to the custom CSS, the layout of the table inside a knitr-document differs from the output in the viewer-pane and web browser!
+
+```{r}
+# load package
+library(sjPlot)
+library(sjmisc)
+library(sjlabelled)
+
+# sample data
+data(efc)
+efc <- as_factor(efc, c161sex, c172code)
+```
+
+## A simple HTML table from regression results
+
+First, we fit two linear models to demonstrate the `tab_model()`-function.
+
+```{r, results='hide'}
+m1 <- lm(barthtot ~ c160age + c12hour + c161sex + c172code, data = efc)
+m2 <- lm(neg_c_7 ~ c160age + c12hour + c161sex + e17age, data = efc)
+``` 
+
+The simplest way of producing the table output is by passing the fitted model as parameter. By default, estimates, confidence intervals (_CI_) and p-values (_p_) are reported. As summary, the numbers of observations as well as the R-squared values are shown.
+
+```{r}
+tab_model(m1)
+```
+
+## Automatic labelling
+
+As the **sjPlot**-packages features [labelled data](https://strengejacke.github.io/sjlabelled/), the coefficients in the table are already labelled in this example. The name of the dependent variable(s) is used as main column header for each model. For non-labelled data, the coefficient names are shown.
+
+```{r}
+data(mtcars)
+m.mtcars <- lm(mpg ~ cyl + hp + wt, data = mtcars)
+tab_model(m.mtcars)
+```
+
+### Turn off automatic labelling
+
+To turn off automatic labelling, use `auto.label = FALSE`, or provide an empty character vector for `pred.labels` and `dv.labels`.
+
+```{r}
+tab_model(m1, auto.label = FALSE)
+```
+
+## More than one model
+
+`tab_model()` can print multiple models at once, which are then printed side-by-side. Identical coefficients are matched in a row.
+
+```{r}
+tab_model(m1, m2)
+```
+
+## Generalized linear models
+
+For generalized linear models, the ouput is slightly adapted. Instead of _Estimates_, the column is named _Odds Ratios_, _Incidence Rate Ratios_ etc., depending on the model. The coefficients are in this case automatically converted (exponentiated). Furthermore, pseudo R-squared statistics are shown in the summary.
+
+```{r}
+m3 <- glm(
+  tot_sc_e ~ c160age + c12hour + c161sex + c172code, 
+  data = efc,
+  family = poisson(link = ""log"")
+)
+
+efc$neg_c_7d <- ifelse(efc$neg_c_7 < median(efc$neg_c_7, na.rm = TRUE), 0, 1)
+m4 <- glm(
+  neg_c_7d ~ c161sex + barthtot + c172code,
+  data = efc,
+  family = binomial(link = ""logit"")
+)
+
+tab_model(m3, m4)
+``` 
+
+### Untransformed estimates on the linear scale
+
+To plot the estimates on the linear scale, use `transform = NULL`. 
+
+```{r}
+tab_model(m3, m4, transform = NULL, auto.label = FALSE)
+``` 
+
+## Show or hide further columns
+
+`tab_model()` has some argument that allow to show or hide specific columns from the output:
+
+* `show.est` to show/hide the column with model estimates.
+* `show.ci` to show/hide the column with confidence intervals.
+* `show.se` to show/hide the column with standard errors.
+* `show.std` to show/hide the column with standardized estimates (and their standard errors).
+* `show.p` to show/hide the column with p-values.
+* `show.stat` to show/hide the column with the coefficients' test statistics.
+* `show.df` for linear mixed models, when p-values are based on degrees of freedom with Kenward-Rogers approximation, these degrees of freedom are shown.
+
+### Adding columns
+
+In the following example, standard errors, standardized coefficients and test statistics are also shown.
+
+```{r}
+tab_model(m1, show.se = TRUE, show.std = TRUE, show.stat = TRUE)
+``` 
+
+### Removing columns
+
+In the following example, default columns are removed.
+
+```{r}
+tab_model(m3, m4, show.ci = FALSE, show.p = FALSE, auto.label = FALSE)
+``` 
+
+## Defining own labels
+
+There are different options to change the labels of the column headers or coefficients, e.g. with:
+
+* `pred.labels` to change the names of the coefficients in the _Predictors_ column. Note that the length of `pred.labels` must exactly match the amount of predictors in the _Predictor_ column.
+* `dv.labels` to change the names of the model columns, which are labelled with the variable labels / names from the dependent variables.
+* Further more, there are various `string.*`-arguments, to change the name of column headings.
+
+```{r}
+tab_model(
+  m1, m2, 
+  pred.labels = c(""Intercept"", ""Age (Carer)"", ""Hours per Week"", ""Gender (Carer)"",
+                  ""Education: middle (Carer)"", ""Education: high (Carer)"", 
+                  ""Age (Older Person)""),
+  dv.labels = c(""First Model"", ""M2""),
+  string.pred = ""Coeffcient"",
+  string.ci = ""Conf. Int (95%)"",
+  string.p = ""P-Value""
+)
+``` 
+
+### Automatic matching for names vectors
+
+Another way to easily assign labels are _named vectors_. In this case, it doesn't matter if `pred.labels` has more labels than coefficients in the model(s), or in which order the labels are passed to `tab_model()`. The only requirement is that the labels' names equal the coefficients names as they appear in the `summary()`-output.
+
+```{r}
+# example, coefficients are ""c161sex2"" or ""c172code3""
+summary(m1)
+
+pl <- c(
+  `(Intercept)` = ""Intercept"",
+  e17age = ""Age (Older Person)"",
+  c160age = ""Age (Carer)"", 
+  c12hour = ""Hours per Week"", 
+  barthtot = ""Barthel-Index"",
+  c161sex2 = ""Gender (Carer)"",
+  c172code2 = ""Education: middle (Carer)"", 
+  c172code3 = ""Education: high (Carer)"",
+  a_non_used_label = ""We don't care""
+)
+ 
+tab_model(
+  m1, m2, m3, m4, 
+  pred.labels = pl, 
+  dv.labels = c(""Model1"", ""Model2"", ""Model3"", ""Model4""),
+  show.ci = FALSE, 
+  show.p = FALSE, 
+  transform = NULL
+)
+``` 
+
+## Keep or remove coefficients from the table
+
+## Change order of coefficients
+

---FILE: vignettes/table_css.Rmd---
@@ -0,0 +1,93 @@
+---
+title: ""Customizing HTML tables""
+author: ""Daniel Ldecke""
+date: ""`r Sys.Date()`""
+output: rmarkdown::html_vignette
+vignette: >
+  %\VignetteIndexEntry{Customizing HTML tables}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+
+```{r echo = FALSE}
+knitr::opts_chunk$set(collapse = TRUE, comment = ""#>"", warning = FALSE, message = FALSE)
+```
+
+All `sjt.*`-functions as well as `tab_model()` create a HTML page with the table output. This table, by default, is opened in the viewer pane of your IDE (in case youre using an IDE that also supports the viewer pane). If a viewer pane is not available, the created HTML output is saved as temporary file and opened in your default web browser. The temporary files are deleted after your R session ends.
+
+## Copying table output to office or word processors
+
+### Export table as HTML file to open in word processors
+
+You can save the HTML page as file for further usage by specifying the `file`-argument The saved HTML file can be opened by word processors like LibreOffice or Microsoft Office.
+
+### Drag and drop from browser or RStudio viewer pane
+
+You can directly drag and drop a table from the RStudio viewer pane or browser into your word processor. Simply select the complete table with your mouse and drag it into office.
+
+## Customizing table output with the CSS parameter
+
+The table output is in in HTML format. The table style (visual appearance) is formatted using _Cascading Style Sheets_ (CSS). If you are a bit familiar with these topics, you can easily customize the appearance of the table output.
+
+Many table elements (header, row, column, cell, summary row, first row or column...) have CSS-class attributes, which can be used to change the table style. Since each `sjt.*` function as well as `tab_model()` has different table elements and thus different class attributes, you first need to know which styles can be customized.
+
+### Retrieving customizable styles
+
+The table functions invisibly return several values. The return value `page.style` contains the style information for the HTML table. You can print this style sheet to console using the `cat()`-function:
+
+```{r}
+library(sjPlot)
+data(efc)
+m <- lm(barthtot ~ c160age + c12hour + c161sex + c172code, data = efc)
+tab <- tab_model(m)
+```
+
+```{r echo = TRUE}
+cat(tab$page.style)
+```
+
+The HTML code is in the `page.content` return value. The following code prints the HTML code of the table to the R console:
+
+```{r echo = TRUE}
+cat(tab$page.content)
+```
+
+Now you can see which table elements are associated with which CSS class attributes.
+
+## Customizing table output with the CSS parameter
+
+You can customize the table output with the `CSS` parameter. This parameter requires a list of attributes, which follow a certain pattern:
+
+1) each attributes needs a `css.` prefix
+2) followed by the class name (e.g. `caption`, `thead`, `centeralign`, etc.)
+3) equal-sign
+4) the CSS format (in (single) quotation marks)
+5) the CSS format must end with a colon (;)
+
+Example:
+
+```{r}
+tab_model(
+  m,
+  CSS = list(
+    css.depvarhead = 'color: red;',
+    css.centeralign = 'text-align: left;', 
+    css.firsttablecol = 'font-weight: bold;', 
+    css.summary = 'color: blue;'
+  )
+)
+```
+
+In the above example, the header row lost the original style and just became red. If you want to keep the original style and just add additional style information, use the plus-sign (+) as initial character for the parameter attributes. In the following example, the header row keeps its original style and is additionally printed in red:
+
+```{r}
+tab_model(m, CSS = list(css.depvarhead = '+color: red;'))
+```
+
+## Pre-defined Table-Layouts
+
+There are a few pre-defined CSS-themes, which can be accessed with the `css_theme()`-function. There are more pre-defined themes planned for the future.
+
+```{r}
+tab_model(m, CSS = css_theme(""cells""))
+```"
strengejacke,sjPlot,43e8552cab1f6172ae18c825f9b867f4e58cf953,Daniel,mail@danielluedecke.de,2018-07-04T17:01:45Z,Daniel,mail@danielluedecke.de,2018-07-04T17:01:45Z,fix docs and CRAN check issues,DESCRIPTION;R/plot_grid.R;R/plot_type_int.R;R/sjPlotGroupFrequencies.R;R/sjPlotPolynomials.R;R/tab_model.R;man/plot_grid.Rd;man/sjp.grpfrq.Rd;man/sjp.poly.Rd,False,True,True,False,60,43,103,"---FILE: DESCRIPTION---
@@ -26,11 +26,11 @@ Depends:
     utils
 Imports:
     arm,
-    broom (>= 0.4.2),
-    dplyr (>= 0.7.1),
+    broom (>= 0.4.5),
+    dplyr (>= 0.7.5),
     effects,
     forcats,
-    ggeffects (>= 0.3.3),
+    ggeffects (>= 0.4.0),
     glmmTMB,
     ggplot2 (>= 2.2.1),
     knitr,
@@ -43,9 +43,9 @@ Imports:
     purrr,
     rlang,
     scales,
-    sjlabelled (>= 1.0.10),
-    sjmisc (>= 2.7.1),
-    sjstats (>= 0.14.3),
+    sjlabelled (>= 1.0.11),
+    sjmisc (>= 2.7.3),
+    sjstats (>= 0.15.0),
     tidyselect,
     tibble (>= 1.3.3),
     tidyr (>= 0.7.0)

---FILE: R/plot_grid.R---
@@ -16,17 +16,28 @@
 #'          To arrange these plots as grid as a single plot, use \code{plot_grid}.
 #'
 #' @examples
+#' library(ggeffects)
 #' data(efc)
+#'
 #' # fit model
-#' fit <- lm(tot_sc_e ~ c12hour + e17age + e42dep + neg_c_7, data = efc)
+#' fit <- glm(
+#'   tot_sc_e ~ c12hour + e17age + e42dep + neg_c_7,
+#'   data = efc,
+#'   family = poisson
+#' )
+#'
 #' # plot marginal effects for each predictor, each as single plot
-#' p <- sjp.lm(fit, type = ""eff"", facet.grid = FALSE, prnt.plot = FALSE)
+#' p1 <- ggpredict(fit, ""c12hour"") %>%
+#'   plot(show.y.title = FALSE, show.title = FALSE)
+#' p2 <- ggpredict(fit, ""e17age"") %>%
+#'   plot(show.y.title = FALSE, show.title = FALSE)
+#' p3 <- ggpredict(fit, ""e42dep"") %>%
+#'   plot(show.y.title = FALSE, show.title = FALSE)
+#' p4 <- ggpredict(fit, ""neg_c_7"") %>%
+#'   plot(show.y.title = FALSE, show.title = FALSE)
 #'
 #' # plot grid
-#' plot_grid(p$plot.list)
-#'
-#' # or
-#' plot_grid(p)
+#' plot_grid(list(p1, p2, p3, p4))
 #'
 #' @export
 plot_grid <- function(x, margin = c(1, 1, 1, 1)) {

---FILE: R/plot_type_int.R---
@@ -157,16 +157,16 @@ plot_type_int <- function(model,
     # set axis and plot titles
     if (!is.null(axis.title)) {
       if (length(axis.title) > 1) {
-        p <- p + ggplot::labs(x = axis.title[1],
+        p <- p + ggplot2::labs(x = axis.title[1],
                       y = axis.title[2])
       } else {
-        p <- p + ggplot::labs(y = axis.title)
+        p <- p + ggplot2::labs(y = axis.title)
       }
     }
 
     # set axis and plot titles
     if (!is.null(title))
-      p <- p + ggplot::ggtitle(title)
+      p <- p + ggplot2::ggtitle(title)
 
     # set axis and plot titles
     if (!is.null(legend.title))
@@ -175,9 +175,9 @@ plot_type_int <- function(model,
     # set axis limits
     if (!is.null(axis.lim)) {
       if (is.list(axis.lim))
-        p <- p + ggplot::xlim(axis.lim[[1]]) + ylim(axis.lim[[2]])
+        p <- p + ggplot2::xlim(axis.lim[[1]]) + ylim(axis.lim[[2]])
       else
-        p <- p + ggplot::ylim(axis.lim)
+        p <- p + ggplot2::ylim(axis.lim)
     }
 
 

---FILE: R/sjPlotGroupFrequencies.R---
@@ -136,7 +136,7 @@ utils::globalVariables(c(""."", ""label"", ""prz"", ""frq"", ""ypos"", ""wb"", ""ia"", ""mw"", ""
 #'          \itemize{
 #'            \item If not specified, a default color brewer palette will be used, which is suitable for the plot style (i.e. diverging for likert scales, qualitative for grouped bars etc.).
 #'            \item If \code{""gs""}, a greyscale will be used.
-#'            \item If \code{""bw""}, and plot-type is a line-plot (like \code{sjp.int()} or \code{sjp.glm(type = ""pred"")}), the plot is black/white and uses different line types to distinguish groups (see \href{../doc/blackwhitefigures.html}{this package-vignette}).
+#'            \item If \code{""bw""}, and plot-type is a line-plot, the plot is black/white and uses different line types to distinguish groups (see \href{../doc/blackwhitefigures.html}{this package-vignette}).
 #'            \item If \code{geom.colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
 #'            \item Else specify own color values or names as vector (e.g. \code{geom.colors = c(""#f00000"", ""#00ff00"")}).
 #'          }

---FILE: R/sjPlotPolynomials.R---
@@ -76,7 +76,7 @@
 #' # fit sample model
 #' fit <- lm(tot_sc_e ~ c12hour + e17age + e42dep, data = efc)
 #' # inspect relationship between predictors and response
-#' sjp.lm(fit, type = ""slope"", show.loess = TRUE, show.scatter = FALSE)
+#' plot_model(fit, type = ""slope"")
 #' # ""e17age"" does not seem to be linear correlated to response
 #' # try to find appropiate polynomial. Grey line (loess smoothed)
 #' # indicates best fit. Looks like x^4 has the best fit,
@@ -88,7 +88,7 @@
 #' fit <- lm(tot_sc_e ~ c12hour + e42dep + e17age + I(e17age^2) + I(e17age^3),
 #'           data = efc)
 #' # plot marginal effects of polynomial term
-#' sjp.lm(fit, type = ""poly"", poly.term = ""e17age"")}
+#' plot_model(fit, type = ""pred"", terms = ""e17age"")}
 #'
 #' @import ggplot2
 #' @importFrom scales grey_pal brewer_pal

---FILE: R/tab_model.R---
@@ -373,22 +373,17 @@ tab_model <- function(
 
   zeroinf.data <- purrr::compact(zeroinf.data)
 
-  ## TODO split multivariate response models into multiple data frames for table output
+  ## sort multivariate response models by response level
+
+  model.data <- purrr::map(model.data, function(.x) {
+    resp.col <- tidyselect::starts_with(""response.level"", vars = colnames(.x))
+    if (!sjmisc::is_empty(resp.col))
+      .x[order(match(.x[[resp.col]], unique(.x[[resp.col]]))), ]
+    else
+      .x
+  })
 
   dat <- model.data %>%
-    # purrr::map(function(i) {
-    #   pos <- tidyselect::starts_with(""response.level"", vars = colnames(i))
-    #   if (!sjmisc::is_empty(pos)) {
-    #     i <- split(i, i[[pos]], drop = TRUE)
-    #   }
-    #   i
-    # }) %>%
-    # purrr::map(function(i) {
-    #   if (list.depth(i) > 1)
-    #     unlist(i, recursive = T)
-    #   else
-    #     i
-    # }) %>%
     purrr::reduce(~ dplyr::full_join(.x, .y, by = ""term"")) %>%
     purrr::map_df(~ dplyr::if_else(.x %in% na.vals | is.na(.x), """", .x))
 

---FILE: man/plot_grid.Rd---
@@ -26,16 +26,27 @@ This function takes a \code{list} of ggplot-objects as argument.
          To arrange these plots as grid as a single plot, use \code{plot_grid}.
 }
 \examples{
+library(ggeffects)
 data(efc)
+
 # fit model
-fit <- lm(tot_sc_e ~ c12hour + e17age + e42dep + neg_c_7, data = efc)
+fit <- glm(
+  tot_sc_e ~ c12hour + e17age + e42dep + neg_c_7,
+  data = efc,
+  family = poisson
+)
+
 # plot marginal effects for each predictor, each as single plot
-p <- sjp.lm(fit, type = ""eff"", facet.grid = FALSE, prnt.plot = FALSE)
+p1 <- ggpredict(fit, ""c12hour"") \%>\%
+  plot(show.y.title = FALSE, show.title = FALSE)
+p2 <- ggpredict(fit, ""e17age"") \%>\%
+  plot(show.y.title = FALSE, show.title = FALSE)
+p3 <- ggpredict(fit, ""e42dep"") \%>\%
+  plot(show.y.title = FALSE, show.title = FALSE)
+p4 <- ggpredict(fit, ""neg_c_7"") \%>\%
+  plot(show.y.title = FALSE, show.title = FALSE)
 
 # plot grid
-plot_grid(p$plot.list)
-
-# or
-plot_grid(p)
+plot_grid(list(p1, p2, p3, p4))
 
 }

---FILE: man/sjp.grpfrq.Rd---
@@ -197,7 +197,7 @@ Plot grouped or stacked frequencies of variables as bar/dot,
          \itemize{
            \item If not specified, a default color brewer palette will be used, which is suitable for the plot style (i.e. diverging for likert scales, qualitative for grouped bars etc.).
            \item If \code{""gs""}, a greyscale will be used.
-           \item If \code{""bw""}, and plot-type is a line-plot (like \code{sjp.int()} or \code{sjp.glm(type = ""pred"")}), the plot is black/white and uses different line types to distinguish groups (see \href{../doc/blackwhitefigures.html}{this package-vignette}).
+           \item If \code{""bw""}, and plot-type is a line-plot, the plot is black/white and uses different line types to distinguish groups (see \href{../doc/blackwhitefigures.html}{this package-vignette}).
            \item If \code{geom.colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
            \item Else specify own color values or names as vector (e.g. \code{geom.colors = c(""#f00000"", ""#00ff00"")}).
          }

---FILE: man/sjp.poly.Rd---
@@ -127,7 +127,7 @@ sjp.poly(efc$c160age, efc$quol_5, 1:4, show.scatter = FALSE)
 # fit sample model
 fit <- lm(tot_sc_e ~ c12hour + e17age + e42dep, data = efc)
 # inspect relationship between predictors and response
-sjp.lm(fit, type = ""slope"", show.loess = TRUE, show.scatter = FALSE)
+plot_model(fit, type = ""slope"")
 # ""e17age"" does not seem to be linear correlated to response
 # try to find appropiate polynomial. Grey line (loess smoothed)
 # indicates best fit. Looks like x^4 has the best fit,
@@ -139,7 +139,7 @@ sjp.poly(fit, ""e17age"", 2:4, show.scatter = FALSE)
 fit <- lm(tot_sc_e ~ c12hour + e42dep + e17age + I(e17age^2) + I(e17age^3),
           data = efc)
 # plot marginal effects of polynomial term
-sjp.lm(fit, type = ""poly"", poly.term = ""e17age"")}
+plot_model(fit, type = ""pred"", terms = ""e17age"")}
 
 }
 \seealso{"
strengejacke,sjPlot,87179d5a7475838bef9ad136a67461761de6b666,Daniel,mail@danielluedecke.de,2018-06-21T16:20:57Z,Daniel,mail@danielluedecke.de,2018-06-21T16:20:57Z,"fix typo, change plot_model() in accordance with ggpredict()",R/plot_model.R;R/sjPlotLikert.R;man/plot_model.Rd;man/sjp.likert.Rd,False,True,True,False,8,8,16,"---FILE: R/plot_model.R---
@@ -70,9 +70,9 @@
 #'       Values for predictions will then be transformed, e.g.
 #'       \code{terms = ""income [exp]""}. This is useful when model predictors were
 #'       transformed for fitting the model and should be back-transformed to the
-#'       original scale for predictions. Finally, using \code{range} for numeric
-#'       variables (e.g. \code{terms = ""age [range]""}) calculates a pretty range
-#'       of values for the term, roughly of proportional length of the term's
+#'       original scale for predictions. Finally, using \code{pretty} for numeric
+#'       variables (e.g. \code{terms = ""age [pretty]""}) calculates a pretty range
+#'       of values for the term, roughly of proportional length to the term's
 #'       value range. For more details, see \code{\link[ggeffects]{ggpredict}}.}
 #'  }
 #' @param sort.est Determines in which way estimates are sorted in the plot:

---FILE: R/sjPlotLikert.R---
@@ -47,7 +47,7 @@ utils::globalVariables(c(""offset""))
 #'            \item{\code{""show""}}{(default) shows percentage value labels in the middle of each category bar}
 #'            \item{\code{""hide""}}{hides the value labels, so no percentage values on the bars are printed}
 #'            \item{\code{""sum.inside""}}{shows the sums of percentage values for both negative and positive values and prints them inside the end of each bar}
-#'            \item{\code{""sum.outide""}}{shows the sums of percentage values for both negative and positive values and prints them outside the end of each bar}
+#'            \item{\code{""sum.outside""}}{shows the sums of percentage values for both negative and positive values and prints them outside the end of each bar}
 #'          }
 #' @param show.prc.sign Logical, if \code{TRUE}, \%-signs for value labels are shown.
 #' @param grid.range Numeric, limits of the x-axis-range, as proportion of 100.

---FILE: man/plot_model.Rd---
@@ -96,9 +96,9 @@ non-transformed estimates.}
      Values for predictions will then be transformed, e.g.
      \code{terms = ""income [exp]""}. This is useful when model predictors were
      transformed for fitting the model and should be back-transformed to the
-     original scale for predictions. Finally, using \code{range} for numeric
-     variables (e.g. \code{terms = ""age [range]""}) calculates a pretty range
-     of values for the term, roughly of proportional length of the term's
+     original scale for predictions. Finally, using \code{pretty} for numeric
+     variables (e.g. \code{terms = ""age [pretty]""}) calculates a pretty range
+     of values for the term, roughly of proportional length to the term's
      value range. For more details, see \code{\link[ggeffects]{ggpredict}}.}
 }}
 

---FILE: man/sjp.likert.Rd---
@@ -94,7 +94,7 @@ so positive and negative values switch colors.}
   \item{\code{""show""}}{(default) shows percentage value labels in the middle of each category bar}
   \item{\code{""hide""}}{hides the value labels, so no percentage values on the bars are printed}
   \item{\code{""sum.inside""}}{shows the sums of percentage values for both negative and positive values and prints them inside the end of each bar}
-  \item{\code{""sum.outide""}}{shows the sums of percentage values for both negative and positive values and prints them outside the end of each bar}
+  \item{\code{""sum.outside""}}{shows the sums of percentage values for both negative and positive values and prints them outside the end of each bar}
 }}
 
 \item{show.n}{logical, if \code{TRUE}, adds total number of cases for each"
strengejacke,sjPlot,448b77893b9fd5f4c24c5f1f2a13a95034533a71,Daniel,mail@danielluedecke.de,2018-06-12T19:30:10Z,Daniel,mail@danielluedecke.de,2018-06-12T19:30:10Z,Fix x-axis-label for ordinal models in `plot_model()`,R/utils.R;man/sjp.glmer.Rd;man/sjp.lmer.Rd;man/sjt.glmer.Rd;man/sjt.lmer.Rd,False,True,True,False,7,5,12,"---FILE: R/utils.R---
@@ -116,7 +116,9 @@ get_estimate_axis_title <- function(fit, axis.title, type, transform = NULL) {
     axis.title <-  dplyr::case_when(
       !is.null(transform) && transform == ""plogis"" ~ ""Probabilities"",
       is.null(transform) && fitfam$is_bin ~ ""Log-Odds"",
+      is.null(transform) && fitfam$is_ordinal ~ ""Log-Odds"",
       fitfam$is_pois ~ ""Incidence Rate Ratios"",
+      fitfam$is_ordinal ~ ""Odds Ratios"",
       fitfam$is_bin && !fitfam$is_logit ~ ""Risk Ratios"",
       fitfam$is_bin ~ ""Odds Ratios"",
       TRUE ~ ""Estimates""

---FILE: man/sjp.glmer.Rd---
@@ -26,7 +26,7 @@ sjp.glmer(fit, type = ""re"", vars = NULL, ri.nr = NULL,
   \item{\code{""fe.cor""}}{for correlation matrix of fixed effects}
   \item{\code{""re.qq""}}{for a QQ-plot of random effects (random effects quantiles against standard normal quantiles)}
   \item{\code{""ri.slope""}}{to plot probability or incidents curves (predicted probabilities or incidents) of random intercept variances for all fixed effects coefficients. Use \code{facet.grid} to decide whether to plot each coefficient as separate plot or as integrated faceted plot. See 'Details'.}
-  \item{\code{""rs.ri""}}{for fitted probability curves (predicted probabilities) indicating the random slope-intercept pairs. Use this to visualize the random parts of random slope-intercept (or repeated measure) models. When having too many groups, use \code{sample.n} argument.}
+  \item{\code{""rs.ri""}}{for fitted probability curves (predicted probabilities) indicating the random slope-intercept pairs. Use this to visualize the random effects of random slope-intercept (or repeated measure) models. When having too many groups, use \code{sample.n} argument.}
   \item{\code{""eff""}}{to plot marginal effects of predicted probabilities or incidents for each fixed term, where remaining co-variates are set to the mean. Use \code{facet.grid} to decide whether to plot each coefficient as separate plot or as integrated faceted plot. See 'Details'.}
   \item{\code{""pred""}}{to plot predicted probabilities or incidents for the response, related to specific model predictors and conditioned on random effects. See 'Details'.}
   \item{\code{""pred.fe""}}{to plot predicted probabilities or incidents for the response, related to specific model predictors, only for fixed effects. See 'Details'.}

---FILE: man/sjp.lmer.Rd---
@@ -29,7 +29,7 @@ sjp.lmer(fit, type = ""re"", vars = NULL, ri.nr = NULL,
   \item{\code{""fe.cor""}}{for correlation matrix of fixed effects}
   \item{\code{""re.qq""}}{for a QQ-plot of random effects (random effects quantiles against standard normal quantiles)}
   \item{\code{""ri.slope""}}{for fixed effects slopes depending on the random intercept.}
-  \item{\code{""rs.ri""}}{for fitted regression lines indicating the random slope-intercept pairs. Use this to visualize the random parts of random slope-intercept (or repeated measure) models. When having too many groups, use \code{sample.n} argument.}
+  \item{\code{""rs.ri""}}{for fitted regression lines indicating the random slope-intercept pairs. Use this to visualize the random effects of random slope-intercept (or repeated measure) models. When having too many groups, use \code{sample.n} argument.}
   \item{\code{""coef""}}{for joint (sum of) random and fixed effects coefficients for each explanatory variable for each level of each grouping factor as forest plot.}
   \item{\code{""pred""}}{to plot predicted values for the response, related to specific model predictors and conditioned on random effects. See 'Details'.}
   \item{\code{""pred.fe""}}{to plot predicted values for the response, related to specific model predictors and conditioned on fixed effects only. See 'Details'.}
@@ -249,7 +249,7 @@ By default, this function plots estimates (coefficients) with confidence
            set to zero, but adjusted for. This plot type differs from \code{type = ""ri.slope""}
            only in the adjusted y-axis-scale}
            \item{\code{type = ""rs.ri""}}{plots regression lines for the random
-           parts of the model, i.e. all random slopes for each random intercept.
+           effects of the model, i.e. all random slopes for each random intercept.
            As the random intercepts describe the deviation from the global intercept,
            the regression lines are computed as global intercept + random intercept +
            random slope. In case of overplotting,

---FILE: man/sjt.glmer.Rd---
@@ -210,7 +210,7 @@ See 'Details' in \code{\link{sjt.frq}}.
 Computation of p-values (if necessary) is based on normal-distribution
         assumption, treating the t-statistics as Wald z-statistics.
         \cr \cr
-        The variance components of the random parts (see \code{show.re.var}) are
+        The variance components of the random effects (see \code{show.re.var}) are
         denoted like:
         \itemize{
          \item between-group-variance: tau-zero-zero

---FILE: man/sjt.lmer.Rd---
@@ -235,7 +235,7 @@ Concerning the \code{show.std} argument, \code{show.std = ""std""}
            Furthermore, see 'Details' in \code{\link{sjt.frq}}.
 }
 \note{
-The variance components of the random parts (see \code{show.re.var}) are
+The variance components of the random effects (see \code{show.re.var}) are
         denoted like:
         \itemize{
          \item within-group variance: sigma-squared"
strengejacke,sjPlot,734b9f4a2abd208e49abe4353411109a3058f83d,Daniel,mail@danielluedecke.de,2018-05-31T15:14:50Z,Daniel,mail@danielluedecke.de,2018-05-31T15:14:50Z,fix #286,R/plot_models.R;R/plot_type_est.R;R/plot_type_jointcoef.R;R/tab_model.R;R/tidiers.R;man/tab_model.Rd,False,True,True,False,67,24,91,"---FILE: R/plot_models.R---
@@ -160,7 +160,19 @@ plot_models <- function(...,
     # need to check whether intercept should be removed or not
 
     fl <- purrr::map(
-      input_list, ~ tidy_model(.x, ci.lvl, tf = transform, type = ""est"", bpe = ""line"", se = FALSE, facets = TRUE, show.zeroinf = FALSE, ...)
+      input_list,
+      ~ tidy_model(
+        .x,
+        ci.lvl,
+        tf = transform,
+        type = ""est"",
+        bpe = ""line"",
+        se = FALSE,
+        facets = TRUE,
+        show.zeroinf = FALSE,
+        p.val = ""wald"",
+        ...
+      )
     )
 
     # remove intercept from output

---FILE: R/plot_type_est.R---
@@ -38,7 +38,7 @@ plot_type_est <- function(type,
   # get tidy output of summary ----
 
   if (type == ""est"" || type == ""re"") {
-    dat <- tidy_model(model, ci.lvl, tf, type, bpe, se, facets, show.zeroinf, ...)
+    dat <- tidy_model(model, ci.lvl, tf, type, bpe, se, facets, show.zeroinf, p.val = ""wald"", ...)
   } else {
     dat <- model %>%
       sjstats::std_beta(type = type, ci.lvl = ci.lvl) %>%

---FILE: R/plot_type_jointcoef.R---
@@ -1,4 +1,4 @@
-plot_type_jointcoef <- function(fit, ri.nr) {
+plot_type_jointcoef <- function(fit, ri.nr, ...) {
 
   ri.cnt <- length(lme4::ranef(fit))
 

---FILE: R/tab_model.R---
@@ -84,6 +84,7 @@ tab_model <- function(
   show.std = NULL,
   show.p = TRUE,
   show.stat = FALSE,
+  show.df = FALSE,
 
   show.header = FALSE,
   show.col.header = TRUE,
@@ -113,6 +114,7 @@ tab_model <- function(
   string.ci = ""CI"",
   string.se = ""std. Error"",
   string.p = ""p"",
+  string.df = ""df"",
   ci.hyphen = ""&nbsp;&ndash;&nbsp;"",
   minus.sign = ""&#45;"",
 
@@ -122,12 +124,15 @@ tab_model <- function(
   digits = 2,
   digits.p = 3,
   emph.p = TRUE,
+  p.val = c(""wald"", ""kr""),
 
   case = ""parsed"",
   auto.label = TRUE,
   bpe = ""median""
 ) {
 
+  p.val <- match.arg(p.val)
+
   models <- tibble::lst(...)
   auto.transform <- missing(transform)
   ci.lvl <- ifelse(is.null(show.ci), .95, show.ci)
@@ -159,7 +164,8 @@ tab_model <- function(
         bpe,
         se = show.se,
         facets = FALSE,
-        show.zeroinf = show.zeroinf
+        show.zeroinf = show.zeroinf,
+        p.val = p.val
       )
 
 
@@ -386,6 +392,7 @@ tab_model <- function(
       show.se,
       show.stat,
       show.p,
+      show.df,
       terms,
       rm.terms
     )
@@ -409,6 +416,7 @@ tab_model <- function(
         show.se,
         show.stat,
         show.p,
+        show.df,
         terms,
         rm.terms
       )
@@ -535,6 +543,9 @@ tab_model <- function(
     pos <- grep(""p.value"", x, fixed = T)
     if (!sjmisc::is_empty(pos)) x <- string.p
 
+    pos <- grep(""df"", x, fixed = T)
+    if (!sjmisc::is_empty(pos)) x <- string.df
+
     pos <- grep(""hdi.inner"", x, fixed = T)
     if (!sjmisc::is_empty(pos)) x <- ""HDI (50%)""
 
@@ -564,6 +575,7 @@ sort_columns <- function(x, is.stan) {
     ""hdi.outer"",
     ""statistic"",
     ""p.value"",
+    ""df"",
     ""wrap.facet"",
     ""response.level""
   )
@@ -575,7 +587,7 @@ sort_columns <- function(x, is.stan) {
 
 #' @importFrom tidyselect starts_with
 #' @importFrom dplyr select slice
-remove_unwanted <- function(dat, show.intercept, show.est, show.std, show.ci, show.se, show.stat, show.p, terms, rm.terms) {
+remove_unwanted <- function(dat, show.intercept, show.est, show.std, show.ci, show.se, show.stat, show.p, show.df, terms, rm.terms) {
   if (!show.intercept) {
     ints1 <- tidyselect::contains(""(Intercept"", vars = dat$term)
     ints2 <- tidyselect::contains(""b_Intercept"", vars = dat$term)
@@ -622,6 +634,10 @@ remove_unwanted <- function(dat, show.intercept, show.est, show.std, show.ci, sh
     dat <- dplyr::select(dat, -tidyselect::starts_with(""p.value""))
   }
 
+  if (show.df == FALSE) {
+    dat <- dplyr::select(dat, -tidyselect::starts_with(""df""))
+  }
+
   if (!is.null(terms)) {
     keep <- which(dat$term %in% terms)
     dat <- dplyr::slice(dat, !! keep)

---FILE: R/tidiers.R---
@@ -1,5 +1,5 @@
-tidy_model <- function(model, ci.lvl, tf, type, bpe, se, facets, show.zeroinf, ...) {
-  dat <- get_tidy_data(model, ci.lvl, tf, type, bpe, facets, show.zeroinf, ...)
+tidy_model <- function(model, ci.lvl, tf, type, bpe, se, facets, show.zeroinf, p.val, ...) {
+  dat <- get_tidy_data(model, ci.lvl, tf, type, bpe, facets, show.zeroinf, p.val, ...)
 
   # get robust standard errors, if requestes, and replace former s.e.
   if (!is.null(se) && !is.logical(se)) {
@@ -11,7 +11,7 @@ tidy_model <- function(model, ci.lvl, tf, type, bpe, se, facets, show.zeroinf, .
 }
 
 
-get_tidy_data <- function(model, ci.lvl, tf, type, bpe, facets, show.zeroinf, ...) {
+get_tidy_data <- function(model, ci.lvl, tf, type, bpe, facets, show.zeroinf, p.val, ...) {
   if (is.stan(model))
     tidy_stan_model(model, ci.lvl, tf, type, bpe, show.zeroinf, facets, ...)
   else if (inherits(model, ""lme""))
@@ -39,7 +39,7 @@ get_tidy_data <- function(model, ci.lvl, tf, type, bpe, facets, show.zeroinf, ..
   else if (inherits(model, ""Zelig-relogit""))
     tidy_zelig_model(model, ci.lvl)
   else
-    tidy_generic(model, ci.lvl, facets)
+    tidy_generic(model, ci.lvl, facets, p.val)
 }
 
 
@@ -48,7 +48,7 @@ get_tidy_data <- function(model, ci.lvl, tf, type, bpe, facets, show.zeroinf, ..
 #' @importFrom sjstats p_value
 #' @importFrom stats coef qnorm
 #' @importFrom dplyr mutate
-tidy_generic <- function(model, ci.lvl, facets) {
+tidy_generic <- function(model, ci.lvl, facets, p.val) {
 
   # check for multiple reponse levels
 
@@ -86,9 +86,23 @@ tidy_generic <- function(model, ci.lvl, facets) {
     # tidy the model
     dat <- broom::tidy(model, conf.int = TRUE, conf.level = ci.lvl, effects = ""fixed"")
 
-    # see if we have p-values. if not, add them
-    if (!tibble::has_name(dat, ""p.value""))
-      dat$p.value <- sjstats::p_value(model, p.kr = FALSE)[[""p.value""]]
+    if (is_merMod(model) && !is.null(p.val) && p.val == ""kr"") {
+      pv <- sjstats::p_value(model, p.kr = TRUE)
+
+      dat$p.value <- pv$p.value
+      dat$std.error <- attr(pv, ""se.kr"", exact = TRUE)
+      dat$statistic <- attr(pv, ""t.kr"", exact = TRUE)
+      dat$df <- round(attr(pv, ""df.kr"", exact = TRUE))
+
+      dat$conf.low <- dat$estimate - stats::qnorm(ci.lvl) * dat$std.error
+      dat$conf.high <- dat$estimate + stats::qnorm(ci.lvl) * dat$std.error
+
+    } else {
+
+      # see if we have p-values. if not, add them
+      if (!tibble::has_name(dat, ""p.value""))
+        dat$p.value <- sjstats::p_value(model, p.kr = FALSE)[[""p.value""]]
+    }
   }
 
   dat

---FILE: man/tab_model.Rd---
@@ -6,18 +6,19 @@
 \usage{
 tab_model(..., transform, show.intercept = TRUE, show.est = TRUE,
   show.ci = 0.95, show.hdi50 = TRUE, show.se = NULL, show.std = NULL,
-  show.p = TRUE, show.stat = FALSE, show.header = FALSE,
-  show.col.header = TRUE, show.zeroinf = TRUE, show.r2 = TRUE,
-  show.icc = FALSE, show.re.var = FALSE, show.fstat = FALSE,
-  show.aic = FALSE, show.aicc = FALSE, show.dev = FALSE,
-  show.obs = TRUE, terms = NULL, rm.terms = NULL, group.terms = TRUE,
-  order.terms = NULL, title = NULL, pred.labels = NULL,
-  dv.labels = NULL, wrap.labels = 25, string.pred = ""Predictors"",
-  string.std = ""std. Beta"", string.ci = ""CI"", string.se = ""std. Error"",
-  string.p = ""p"", ci.hyphen = ""&nbsp;&ndash;&nbsp;"", minus.sign = ""&#45;"",
+  show.p = TRUE, show.stat = FALSE, show.df = FALSE,
+  show.header = FALSE, show.col.header = TRUE, show.zeroinf = TRUE,
+  show.r2 = TRUE, show.icc = FALSE, show.re.var = FALSE,
+  show.fstat = FALSE, show.aic = FALSE, show.aicc = FALSE,
+  show.dev = FALSE, show.obs = TRUE, terms = NULL, rm.terms = NULL,
+  group.terms = TRUE, order.terms = NULL, title = NULL,
+  pred.labels = NULL, dv.labels = NULL, wrap.labels = 25,
+  string.pred = ""Predictors"", string.std = ""std. Beta"", string.ci = ""CI"",
+  string.se = ""std. Error"", string.p = ""p"", string.df = ""df"",
+  ci.hyphen = ""&nbsp;&ndash;&nbsp;"", minus.sign = ""&#45;"",
   separate.ci.col = TRUE, separate.se.col = TRUE, digits = 2,
-  digits.p = 3, emph.p = TRUE, case = ""parsed"", auto.label = TRUE,
-  bpe = ""median"")
+  digits.p = 3, emph.p = TRUE, p.val = c(""wald"", ""kr""), case = ""parsed"",
+  auto.label = TRUE, bpe = ""median"")
 }
 \arguments{
 \item{...}{One or more regression models, including glm's or mixed models."
strengejacke,sjPlot,3348d9b84f89be6d9e1c2b4d0798747fea0959cc,Daniel,mail@danielluedecke.de,2018-05-06T12:27:28Z,Daniel,mail@danielluedecke.de,2018-05-06T12:27:28Z,fix sorting,R/plot_model_estimates.R,False,True,True,False,3,2,5,"---FILE: R/plot_model_estimates.R---
@@ -180,10 +180,11 @@ plot_model_estimates <- function(model,
         # sort terms
 
         if (!is.null(sort.est)) {
-          x$reihe <- order(x$estimate)
+          reihe <- order(x$estimate)
         } else {
-          x$reihe <- 1:nrow(x)
+          reihe <- 1:nrow(x)
         }
+        x$reihe <- order(reihe)
 
         x$term <- forcats::fct_reorder(x$term, x$reihe)
 "
strengejacke,sjPlot,27824a8ba6782c97a03d8aa083a1852422794ffd,Daniel,mail@danielluedecke.de,2018-04-26T18:16:27Z,Daniel,mail@danielluedecke.de,2018-04-26T18:16:27Z,fix issue in stan-diagnostic-plot,R/plot_diag_stan.R;R/tab_model.R,False,True,True,False,13,6,19,"---FILE: R/plot_diag_stan.R---
@@ -2,6 +2,7 @@
 #' @importFrom dplyr bind_rows select mutate
 #' @importFrom tidyr gather
 #' @importFrom tidyselect starts_with
+#' @importFrom tibble has_name
 plot_diag_stan <- function(model, geom.colors, axis.lim, facets, ...) {
 
   # check some defaults
@@ -53,10 +54,18 @@ plot_diag_stan <- function(model, geom.colors, axis.lim, facets, ...) {
     # remove intercept from output for ridgeline plot.
     # this would increase the range of the scale too much
 
-    d1 <- dplyr::select(d1, -.data$`(Intercept)`)
-    d2 <- dplyr::select(d2, -.data$`(Intercept)`)
-    d1 <- dplyr::select(d1, -.data$sigma)
-    d2 <- dplyr::select(d2, -.data$sigma)
+    if (tibble::has_name(d1, ""(Intercept)""))
+      d1 <- dplyr::select(d1, -.data$`(Intercept)`)
+
+    if (tibble::has_name(d2, ""(Intercept)""))
+      d2 <- dplyr::select(d2, -.data$`(Intercept)`)
+
+    if (tibble::has_name(d1, ""sigma""))
+      d1 <- dplyr::select(d1, -.data$sigma)
+
+    if (tibble::has_name(d2, ""sigma""))
+      d2 <- dplyr::select(d2, -.data$sigma)
+
     d1 <- dplyr::select(d1, -tidyselect::starts_with(""b[(Intercept)""))
     d2 <- dplyr::select(d2, -tidyselect::starts_with(""b[(Intercept)""))
     d1 <- dplyr::select(d1, -tidyselect::starts_with(""Sigma[""))

---FILE: R/tab_model.R---
@@ -149,8 +149,6 @@ tab_model <- function(
           transform <- ""exp""
       }
 
-      ## TODO probably indicate estimate with ""*""
-
       # get tidy output of summary ----
 
       dat <- model %>%"
strengejacke,sjPlot,c50e1ad588b7702b5090875bd817298bcf7081e2,Daniel,mail@danielluedecke.de,2018-04-24T17:04:27Z,Daniel,mail@danielluedecke.de,2018-04-24T17:04:27Z,fix check-issues,NAMESPACE;R/S3-methods.R;R/plot_model.R;R/sjPlotGLME.R;R/sjPlotInteractions.R;R/sjPlotLinreg.R;R/sjPlotOdds.R;R/sjTabSPSS.R;R/sjplot.R;R/sjplot_themes.R;man/plot_model.Rd;man/plot_models.Rd;man/sjPlot-themes.Rd;man/sjp.glm.Rd;man/sjp.glmer.Rd;man/sjp.int.Rd;man/sjp.lm.Rd;man/sjp.lmer.Rd;man/sjplot.Rd;vignettes/sjtbasic.Rmd,True,True,True,False,92,1023,1115,"---FILE: NAMESPACE---
@@ -119,11 +119,18 @@ importFrom(forcats,fct_rev)
 importFrom(ggeffects,ggeffect)
 importFrom(ggeffects,ggpredict)
 importFrom(ggplot2,discrete_scale)
+importFrom(ggplot2,element_line)
+importFrom(ggplot2,element_rect)
+importFrom(ggplot2,element_text)
 importFrom(ggplot2,scale_color_gradientn)
 importFrom(ggplot2,scale_fill_gradientn)
+importFrom(ggplot2,theme)
+importFrom(ggplot2,theme_get)
+importFrom(ggplot2,theme_minimal)
 importFrom(glmmTMB,fixef)
 importFrom(grDevices,axisTicks)
 importFrom(grDevices,cm)
+importFrom(grDevices,colorRampPalette)
 importFrom(grDevices,dev.off)
 importFrom(grDevices,jpeg)
 importFrom(grDevices,png)

---FILE: R/S3-methods.R---
@@ -27,14 +27,15 @@ print.sjTable <- function(x, ...) {
 #' @export
 knit_print.sjTable <-  function(input, ...) {
   x <- input$knitr
-  x <- gsub("""", ""&auml;"", x, fixed = TRUE, useBytes = TRUE)
-  x <- gsub("""", ""&ouml;"", x, fixed = TRUE, useBytes = TRUE)
-  x <- gsub("""", ""&uuml;"", x, fixed = TRUE, useBytes = TRUE)
-  x <- gsub("""", ""&Auml;"", x, fixed = TRUE, useBytes = TRUE)
-  x <- gsub("""", ""&Ouml;"", x, fixed = TRUE, useBytes = TRUE)
-  x <- gsub("""", ""&Uuml;"", x, fixed = TRUE, useBytes = TRUE)
-  x <- gsub("""", ""&szlig;"", x, fixed = TRUE, useBytes = TRUE)
-  knitr::asis_output(x, ...)
+  x <- gsub(""\u00E4"", ""&auml;"", x, fixed = TRUE, useBytes = FALSE)
+  x <- gsub(""\u00F6"", ""&ouml;"", x, fixed = TRUE, useBytes = FALSE)
+  x <- gsub(""\u00FC"", ""&uuml;"", x, fixed = TRUE, useBytes = FALSE)
+  x <- gsub(""\u00C4"", ""&Auml;"", x, fixed = TRUE, useBytes = FALSE)
+  x <- gsub(""\u00D6"", ""&Ouml;"", x, fixed = TRUE, useBytes = FALSE)
+  x <- gsub(""\u00DC"", ""&Uuml;"", x, fixed = TRUE, useBytes = FALSE)
+  x <- gsub(""\u00DF"", ""&szlig;"", x, fixed = TRUE, useBytes = FALSE)
+  knitr::asis_output(x)
+  # knitr::asis_output(input$knitr)
 }
 
 

---FILE: R/plot_model.R---
@@ -188,7 +188,7 @@
 #'     \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
 #'     \item If \pkg{wesanderson} is installed, you may also specify a name of a palette from that package.
 #'     \item If \pkg{viridis} is installed, use \code{colors = ""v""} to get the viridis color palette.
-#'     \item There are some pre-defined color palettes in this package, see \code{\link{sjplot-themes}} for details.
+#'     \item There are some pre-defined color palettes in this package, see \code{\link{sjPlot-themes}} for details.
 #'     \item Else specify own color values or names as vector (e.g. \code{colors = ""#00ff00""} or \code{colors = c(""firebrick"", ""blue"")}).
 #'   }
 #' @param grid Logical, if \code{TRUE}, multiple plots are plotted as grid

---FILE: R/sjPlotGLME.R---
@@ -177,57 +177,6 @@ utils::globalVariables(c(""estimate"", ""nQQ"", ""ci"", ""fixef"", ""fade"", ""conf.low"", ""
 #'            one or two model predictors. See 'Examples'.}
 #'          }
 #'
-#' @examples
-#' library(lme4)
-#' library(sjmisc)
-#' library(sjlabelled)
-#' # create binary response
-#' sleepstudy$Reaction.dicho <- dicho(sleepstudy$Reaction, dich.by = ""median"")
-#' # fit model
-#' fit <- glmer(Reaction.dicho ~ Days + (Days | Subject),
-#'              data = sleepstudy, family = binomial(""logit""))
-#'
-#' # simple plot
-#' sjp.glmer(fit)
-#'
-#' # sort by predictor Days
-#' sjp.glmer(fit, sort.est = ""Days"")
-#'
-#' \dontrun{
-#' data(efc)
-#' # create binary response
-#' efc$hi_qol <- dicho(efc$quol_5)
-#' # prepare group variable
-#' efc$grp = as.factor(efc$e15relat)
-#' levels(x = efc$grp) <- get_labels(efc$e15relat)
-#' # data frame for fitted model
-#' mydf <- data.frame(hi_qol = to_factor(efc$hi_qol),
-#'                    sex = to_factor(efc$c161sex),
-#'                    education = to_factor(efc$c172code),
-#'                    c12hour = efc$c12hour,
-#'                    neg_c_7 = efc$neg_c_7,
-#'                    grp = efc$grp)
-#'
-#' # fit glmer, with categorical predictor with more than 2 levels
-#' fit <- glmer(hi_qol ~ sex + education + c12hour + neg_c_7 + (1|grp),
-#'              data = mydf, family = binomial(""logit""))
-#'
-#' # plot and sort fixed effects, axis labels automatically retrieved
-#' sjp.glmer(fit, type = ""fe"", sort.est = TRUE)
-#'
-#' # plot probability curves (predicted probabilities)
-#' # for each covariate, grouped by random intercepts
-#' # in integrated plots, emphasizing groups 1 and 4
-#' sjp.glmer(fit, type = ""ri.slope"", emph.grp = c(1, 4), facet.grid = FALSE)
-#'
-#' # plot predicted probabilities for response,
-#' # non faceted, with ci
-#' sjp.glmer(fit, type = ""pred.fe"", vars = c(""neg_c_7"", ""education""),
-#'           show.ci = TRUE, facet.grid = FALSE)
-#'
-#' # predictions by gender and education
-#' sjp.glmer(fit, type = ""pred.fe"", vars = c(""neg_c_7"", ""sex"", ""education""))}
-#'
 #' @import ggplot2
 #' @importFrom dplyr slice sample_n
 #' @importFrom lme4 fixef ranef confint.merMod getME
@@ -446,89 +395,6 @@ sjp.glmer <- function(fit,
 #'         on normal-distribution assumption, treating the t-statistics as Wald
 #'         z-statistics. See 'Details' in \code{\link[sjstats]{p_value}}.
 #'
-#' @examples
-#' # fit model
-#' library(lme4)
-#' fit <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
-#'
-#' # simple plot
-#' sjp.lmer(fit)
-#'
-#' # plot fixed effects
-#' sjp.lmer(fit, type = ""fe"")
-#'
-#' # sort by predictor Days
-#' sjp.lmer(fit, sort.est = ""Days"")
-#'
-#' # plot each predictor as own plot
-#' # sort each plot
-#' sjp.lmer(fit, facet.grid = FALSE, sort.est = ""sort.all"")
-#'
-#' library(sjmisc)
-#' library(sjlabelled)
-#' data(efc)
-#' # prepare group variable
-#' efc$grp = as.factor(efc$e15relat)
-#' levels(x = efc$grp) <- get_labels(efc$e15relat)
-#' # data frame for fitted model
-#' mydf <- data.frame(neg_c_7 = as.numeric(efc$neg_c_7),
-#'                    sex = as.factor(efc$c161sex),
-#'                    c12hour = as.numeric(efc$c12hour),
-#'                    barthel = as.numeric(efc$barthtot),
-#'                    grp = efc$grp)
-#' # fit lmer
-#' fit <- lmer(neg_c_7 ~ sex + c12hour + barthel + (1|grp), data = mydf)
-#'
-#  # plot and sort standardized fixed effects
-#' sjp.lmer(fit, type = ""fe.std"", sort.est = TRUE)
-#'
-#' # highlight specific grouping levels, in this case we compare
-#' # spouses, children and children-in-law
-#' sjp.lmer(fit, type = ""ri.slope"", emph.grp = c(1, 2, 4), vars = ""c12hour"")
-#'
-#' \dontrun{
-#' # plotting polynomial terms
-#' # check linear relation between predictors and response
-#' sjp.lmer(fit, type = ""fe.slope"", show.loess = TRUE)
-#'
-#' # ""barthel"" does not seem to be linear correlated to response
-#' # try to find appropiate polynomial. Grey line (loess smoothed)
-#' # indicates best fit. Looks like x^4 has the best fit,
-#' # however, x^2 seems to be suitable according to p-values.
-#' sjp.poly(fit, ""barthel"", 2:4, show.scatter = FALSE)
-#'
-#' # fit new model
-#' fit <- lmer(neg_c_7 ~ sex + c12hour + barthel +
-#'             I(barthel^2) + (1|grp), data = mydf)
-#'
-#' # plot marginal effects of polynomial term
-#' sjp.lmer(fit, type = ""poly"", poly.term = ""barthel"")
-#'
-#' # lme4 complaints about scale of polynomial term, so
-#' # try centering this predictor
-#' mydf$barthel_s <- sjmisc::std(mydf$barthel)
-#'
-#' # re-fit model
-#' fit_s <- lmer(neg_c_7 ~ sex + c12hour + barthel_s +
-#'               I(barthel_s^2) + (1|grp), data = mydf)
-#'
-#' # plot marginal effects of centered, scaled polynomial term
-#' sjp.lmer(fit_s, type = ""poly"", poly.term = ""barthel_s"")
-#'
-#' # scaling also improved p-values
-#' sjt.lmer(fit, fit_s)
-#'
-#' # plotting predicted values for response
-#' # conditioned on random effects
-#' sjp.lmer(fit, type = ""pred"", vars = ""c12hour"")
-#'
-#' # grouped, for fixed effects only
-#' sjp.lmer(fit, type = ""pred.fe"", vars = c(""c12hour"", ""sex""))
-#'
-#' # grouped, for fixed effects only, non-facted
-#' sjp.lmer(fit, type = ""pred.fe"", vars = c(""c12hour"", ""sex""),
-#'          facet.grid = FALSE, show.ci = FALSE)}
-#'
 #' @import ggplot2
 #' @importFrom sjstats se std_beta p_value
 #' @importFrom dplyr sample_n slice

---FILE: R/sjPlotInteractions.R---
@@ -145,99 +145,6 @@
 #'        are used as grouping variable, while the latter predictor is printed along the x-axis
 #'        (i.e. lm(y~a+b+a:b) means that ""a"" is used as grouping variable and ""b"" is plotted along the x-axis).
 #'
-#' @examples
-#' # Note that the data sets used in this example may not be perfectly suitable for
-#' # fitting linear models. I just used them because they are part of the R-software.
-#'
-#' # fit ""dummy"" model. Note that moderator should enter
-#' # first the model, followed by predictor. Else, use
-#' # argument ""swap.pred"" to change predictor on
-#' # x-axis with moderator
-#' fit <- lm(weight ~ Diet * Time, data = ChickWeight)
-#'
-#' # show summary to see significant interactions
-#' summary(fit)
-#'
-#' # plot regression line of interaction terms, including value labels
-#' sjp.int(fit, type = ""eff"", show.values = TRUE)
-#'
-#'
-#' # load sample data set
-#' library(sjmisc)
-#' library(sjlabelled)
-#' data(efc)
-#' # create data frame with variables that should be included
-#' # in the model
-#' mydf <- data.frame(usage = efc$tot_sc_e,
-#'                    sex = efc$c161sex,
-#'                    education = efc$c172code,
-#'                    burden = efc$neg_c_7,
-#'                    dependency = efc$e42dep)
-#' # convert gender predictor to factor
-#' mydf$sex <- relevel(factor(mydf$sex), ref = ""2"")
-#' # fit ""dummy"" model
-#' fit <- lm(usage ~ .*., data = mydf)
-#' summary(fit)
-#'
-#' # plot interactions. note that type = ""cond"" only considers
-#' # significant interactions by default. use ""plevel"" to
-#' # adjust p-level sensivity
-#' sjp.int(fit, type = ""cond"")
-#'
-#' # plot only selected interaction term for
-#' # type = ""eff""
-#' sjp.int(fit, type = ""eff"", int.term = ""sex*education"")
-#'
-#' # plot interactions, using mean and sd as moderator
-#' # values to calculate interaction effect
-#' sjp.int(fit, type = ""eff"", mdrt.values = ""meansd"")
-#' sjp.int(fit, type = ""cond"", mdrt.values = ""meansd"")
-#'
-#' # plot interactions, including those with p-value up to 0.1
-#' sjp.int(fit, type = ""cond"", plevel = 0.1)
-#'
-#' # -------------------------------
-#' # Predictors for negative impact of care.
-#' # Data from the EUROFAMCARE sample dataset
-#' # -------------------------------
-#' # create binary response
-#' y <- ifelse(efc$neg_c_7 < median(stats::na.omit(efc$neg_c_7)), 0, 1)
-#' # create data frame for fitted model
-#' mydf <- data.frame(y = as.factor(y),
-#'                    sex = as.factor(efc$c161sex),
-#'                    barthel = as.numeric(efc$barthtot))
-#' # fit model
-#' fit <- glm(y ~ sex * barthel, data = mydf, family = binomial(link = ""logit""))
-#' # plot interaction, increase p-level sensivity
-#' sjp.int(fit, type = ""eff"", legend.labels = get_labels(efc$c161sex), plevel = 0.1)
-#' sjp.int(fit, type = ""cond"", legend.labels = get_labels(efc$c161sex), plevel = 0.1)
-#'
-#' \dontrun{
-#' # load sample data set
-#' library(sjmisc)
-#' data(efc)
-#' # create data frame with variables that should be included
-#' # in the model
-#' mydf <- data.frame(burden = efc$neg_c_7,
-#'                    sex = efc$c161sex,
-#'                    education = efc$c172code,
-#'                    barthel = efc$barthtot)
-#' # convert gender predictor to factor
-#' mydf$sex <- factor(mydf$sex)
-#' mydf$education <- factor(mydf$education)
-#' # name factor levels and dependent variable
-#' levels(mydf$sex) <- c(""female"", ""male"")
-#' levels(mydf$education) <- c(""low"", ""mid"", ""high"")
-#' mydf$burden <- set_label(mydf$burden, lab = ""care burden"")
-#' # fit ""dummy"" model
-#' fit <- lm(burden ~ .*., data = mydf)
-#'
-#' # plot effects
-#' sjp.int(fit, type = ""eff"", show.ci = TRUE)
-#'
-#' # plot effects, faceted
-#' sjp.int(fit, type = ""eff"", int.plot.index = 3, show.ci = TRUE, facet.grid = TRUE)}
-#'
 #' @import ggplot2
 #' @importFrom stats family quantile sd
 #' @importFrom sjmisc is_num_fac

---FILE: R/sjPlotLinreg.R---
@@ -130,122 +130,6 @@ utils::globalVariables(c(""fit"", ""vars"", ""stdbeta"", ""x"", ""ydiff"", ""y"", ""grp"", "".s
 #'           ggplot-object (\code{df}). For \code{type = ""ma""}, an updated model
 #'           with removed outliers is returned.
 #'
-#' @examples
-#' # --------------------------------------------------
-#' # plotting estimates of linear models as forest plot
-#' # --------------------------------------------------
-#' # fit linear model
-#' fit <- lm(airquality$Ozone ~ airquality$Wind + airquality$Temp + airquality$Solar.R)
-#'
-#' # plot estimates with CI
-#' sjp.lm(fit, grid.breaks = 2)
-#'
-#' # plot estimates with CI
-#' # and with narrower tick marks
-#' # (because ""grid.breaks"" was not specified)
-#' sjp.lm(fit)
-#'
-#' # ---------------------------------------------------
-#' # plotting regression line of linear model (done
-#' # automatically if fitted model has only 1 predictor)
-#' # ---------------------------------------------------
-#' library(sjmisc)
-#' data(efc)
-#' # fit model
-#' fit <- lm(neg_c_7 ~ quol_5, data=efc)
-#' # plot regression line with label strings
-#' sjp.lm(fit, resp.label = ""Burden of care"",
-#'        axis.labels = ""Quality of life"", show.loess = TRUE)
-#'
-#' # --------------------------------------------------
-#' # plotting regression lines of each single predictor
-#' # of a fitted model
-#' # --------------------------------------------------
-#' library(sjmisc)
-#' data(efc)
-#' # fit model
-#' fit <- lm(tot_sc_e ~ c12hour + e17age + e42dep, data=efc)
-#'
-#' # reression line and scatter plot
-#' sjp.lm(fit, type = ""slope"")
-#'
-#' # reression line w/o scatter plot
-#' sjp.lm(fit, type = ""slope"", show.scatter = FALSE)
-#'
-#' # --------------------------
-#' # plotting model assumptions
-#' # --------------------------
-#' sjp.lm(fit, type = ""ma"")
-#'
-#' \dontrun{
-#' # --------------------------
-#' # grouping estimates
-#' # --------------------------
-#' library(sjmisc)
-#' data(efc)
-#' fit <- lm(barthtot ~ c160age + e17age + c12hour + e16sex + c161sex + c172code,
-#'           data = efc)
-#'
-#' # order estimates according to coefficient's order
-#' sjp.lm(fit, group.estimates = c(1, 1, 2, 3, 3, 4),
-#'        geom.colors = c(""green"", ""red"", ""blue"", ""grey""), sort.est = FALSE)
-#'
-#' fit <- lm(barthtot ~ c160age + c12hour + e17age+ c161sex + c172code + e16sex,
-#'           data = efc)
-#'
-#' # force order of estimates according to group assignment
-#' sjp.lm(fit, group.estimates = c(1, 2, 1, 3, 4, 3),
-#'        geom.colors = c(""green"", ""red"", ""blue"", ""grey""), sort.est = TRUE)
-#'
-#' # --------------------------
-#' # predicted values for response
-#' # --------------------------
-#' library(sjmisc)
-#' data(efc)
-#' efc$education <- to_label(to_factor(efc$c172code))
-#' efc$gender <- to_label(to_factor(efc$c161sex))
-#' fit <- lm(barthtot ~ c160age + c12hour + e17age + gender + education,
-#'           data = efc)
-#'
-#' sjp.lm(fit, type = ""pred"", vars = ""c160age"")
-#'
-#' # with loess
-#' sjp.lm(fit, type = ""pred"", vars = ""e17age"", show.loess = TRUE)
-#'
-#' # grouped
-#' sjp.lm(fit, type = ""pred"", vars = c(""c12hour"", ""education""))
-#'
-#' # grouped, non-facet
-#' sjp.lm(fit, type = ""pred"", vars = c(""c12hour"", ""education""),
-#'        facet.grid = FALSE)
-#'
-#' # two groupings
-#' sjp.lm(fit, type = ""pred"", vars = c(""c12hour"", ""gender"", ""education""))
-#'
-#' # --------------------------
-#' # plotting polynomial terms
-#' # --------------------------
-#' library(sjmisc)
-#' data(efc)
-#' # fit sample model
-#' fit <- lm(tot_sc_e ~ c12hour + e17age + e42dep, data = efc)
-#' # ""e17age"" does not seem to be linear correlated to response
-#' # try to find appropiate polynomial. Grey line (loess smoothed)
-#' # indicates best fit. Looks like x^3 has a good fit.
-#' # (not checked for significance yet).
-#' sjp.poly(fit, ""e17age"", 2:4, show.scatter = FALSE)
-#' # fit new model
-#' fit <- lm(tot_sc_e ~ c12hour + e42dep +
-#'           e17age + I(e17age^2) + I(e17age^3),
-#'           data = efc)
-#' # plot marginal effects of polynomial term
-#' sjp.lm(fit, type = ""poly"", poly.term = ""e17age"")
-#'
-#' library(splines)
-#' # fit new model with ""splines""-package, ""bs""
-#' fit <- lm(tot_sc_e ~ c12hour + e42dep + bs(e17age, 3), data = efc)
-#' # plot marginal effects of polynomial term, same call as above
-#' sjp.lm(fit, type = ""poly"", poly.term = ""e17age"")}
 #'
 #' @import ggplot2
 #' @importFrom stats model.matrix confint coef residuals sd

---FILE: R/sjPlotOdds.R---
@@ -68,59 +68,6 @@ utils::globalVariables(c(""OR"", ""lower"", ""upper"", ""p"", ""grp.est"", ""ci.low"", ""ci.h
 #'            one or two model predictors. See 'Examples'.}
 #'          }
 #'
-#' @examples
-#' # prepare dichotomous dependent variable
-#' swiss$y <- ifelse(swiss$Fertility < median(swiss$Fertility), 0, 1)
-#'
-#' # fit model
-#' fitOR <- glm(y ~ Education + Examination + Infant.Mortality + Catholic,
-#'              family = binomial(link = ""logit""), data = swiss)
-#'
-#' # print Odds Ratios as dots
-#' sjp.glm(fitOR)
-#'
-#' # -------------------------------
-#' # Predictors for negative impact of care. Data from
-#' # the EUROFAMCARE sample dataset
-#' # -------------------------------
-#' library(sjmisc)
-#' library(sjlabelled)
-#' data(efc)
-#' # create binary response
-#' y <- ifelse(efc$neg_c_7 < median(na.omit(efc$neg_c_7)), 0, 1)
-#' # create data frame for fitted model
-#' mydf <- data.frame(y = as.factor(y),
-#'                    sex = to_factor(efc$c161sex),
-#'                    dep = to_factor(efc$e42dep),
-#'                    barthel = efc$barthtot,
-#'                    education = to_factor(efc$c172code))
-#' # fit model
-#' fit <- glm(y ~., data = mydf, family = binomial(link = ""logit""))
-#'
-#' # plot odds ratios
-#' sjp.glm(fit, title = get_label(efc$neg_c_7))
-#'
-#' # plot probability curves (relationship between predictors and response)
-#' sjp.glm(fit, title = get_label(efc$neg_c_7), type = ""slope"")
-#'
-#' # --------------------------
-#' # grouping estimates
-#' # --------------------------
-#' sjp.glm(fit,  group.estimates = c(1, 2, 2, 2, 3, 4, 4))
-#'
-#' # --------------------------
-#' # model predictions, with selected model terms.
-#' # 'vars' needs to be a character vector of length 1 to 3
-#' # with names of model terms for x-axis and grouping factor.
-#' # --------------------------
-#' sjp.glm(fit, type = ""pred"", vars = ""barthel"")
-#' # faceted, with ci
-#' sjp.glm(fit, type = ""pred"", vars = c(""barthel"", ""dep""), show.ci = TRUE)
-#' # w/o facets
-#' sjp.glm(fit, type = ""pred"", vars = c(""barthel"", ""dep""), facet.grid = FALSE)
-#' # with third grouping variable - this type automatically uses grid layout
-#' sjp.glm(fit, type = ""pred"", vars = c(""barthel"", ""sex"", ""education""))
-#'
 #' @import ggplot2
 #' @importFrom stats na.omit coef confint logLik
 #' @export

---FILE: R/sjTabSPSS.R---
@@ -273,7 +273,7 @@ view_df <- function(x,
         if (sjmisc::is_float(x[[index]]))
           valstring <- paste0(sprintf(""%.1f"", range(x[[index]], na.rm = T)), collapse = ""-"")
         else
-          valstring <- paste0(sprintf(""%i"", range(x[[index]], na.rm = T)), collapse = ""-"")
+          valstring <- paste0(sprintf(""%i"", as.integer(range(x[[index]], na.rm = T))), collapse = ""-"")
 
         if (show.values && show.labels) {
           colsp <- "" colspan=\""2\""""

---FILE: R/sjplot.R---
@@ -30,7 +30,7 @@
 #'             \item{\code{""aov1""}}{calls \code{\link{sjp.aov1}}. The first
 #'             two variables in \code{data} are used (and required) to create the plot.
 #'             }
-#'             \item{\code{""frq""}}{calls \code{\link{sjp.frq}} or \code{\link{sjt.frq}}.
+#'             \item{\code{""frq""}}{calls \code{\link{sjp.frq}}.
 #'             If \code{data} has more than one variable, a plot for each
 #'             variable in \code{data} is plotted.
 #'             }
@@ -40,10 +40,6 @@
 #'             \item{\code{""grpfrq""}}{calls \code{\link{sjp.grpfrq}}. The first
 #'             two variables in \code{data} are used (and required) to create the plot.
 #'             }
-#'             \item{\code{""grpmean""}}{calls \code{\link{sjt.grpmean}}.
-#'             The first two variables in \code{data} are used (and required)
-#'             to create the table.
-#'             }
 #'             \item{\code{""likert""}}{calls \code{\link{sjp.likert}}. \code{data}
 #'             must be a data frame with items to plot.
 #'             }
@@ -164,7 +160,7 @@ sjplot <- function(data, ..., fun = c(""frq"", ""grpfrq"", ""xtab"", ""gpt"", ""scatter"",
 
 #' @rdname sjplot
 #' @export
-sjtab <- function(data, ..., fun = c(""frq"", ""xtab"", ""grpmean"", ""stackfrq"")) {
+sjtab <- function(data, ..., fun = c(""xtab"", ""stackfrq"")) {
   # check if x is a data frame
   if (!is.data.frame(data)) stop(""`data` must be a data frame."", call. = F)
 
@@ -363,24 +359,16 @@ tab_sj <- function(x, fun, args) {
 
   # choose plottype, and call plot-function with or w/o additional arguments
   if (sjmisc::is_empty(args)) {
-    if (fun == ""frq"") {
-      sjt.frq(x)
-    } else if (fun  == ""xtab"") {
+    if (fun  == ""xtab"") {
       sjt.xtab(x[[1]], x[[2]])
     } else if (fun  == ""stackfrq"") {
       sjt.stackfrq(x)
-    } else if (fun  == ""grpmean"") {
-      sjt.grpmean(x[[1]], x[[2]])
     }
   } else {
-    if (fun == ""frq"") {
-      do.call(sjt.frq, args = c(list(data = x), args))
-    } else if (fun  == ""stackfrq"") {
+    if (fun  == ""stackfrq"") {
       do.call(sjt.stackfrq, args = c(list(items = x), args))
     } else if (fun  == ""xtab"") {
       do.call(sjt.xtab, args = c(list(var.row = x[[1]], var.col = x[[2]]), args))
-    } else if (fun  == ""grpmean"") {
-      do.call(sjt.grpmean, args = c(list(var.cnt = x[[1]], var.grp = x[[2]]), args))
     }
   }
 }

---FILE: R/sjplot_themes.R---
@@ -44,6 +44,7 @@
 #' @param reverse Logical, if \code{TRUE}, order of returned colours is reversed.
 #' @param n Numeric, number of colors to be returned. By default, the complete
 #'   colour palette is returned.
+#' @param ... Further arguments passed down to ggplot's \code{scale()}-functions.
 #'
 #' @details
 #'   When using the \code{colors} argument in function calls (e.g.
@@ -81,114 +82,116 @@
 #' sjplot_pal(pal = ""breakfast club"")
 #'
 #' @rdname sjPlot-themes
+#' @importFrom ggplot2 element_line element_text element_rect theme theme_minimal
 #' @export
 theme_sjplot <- function(base_size = 12, base_family = """") {
-  (theme_minimal(base_size = base_size, base_family = base_family) +
-     theme(
-       axis.line.x      = element_line(colour = ""grey80""),
-       axis.line.y      = element_line(colour = ""grey80""),
-       axis.text        = element_text(colour = ""grey50""),
-       axis.title       = element_text(colour = ""grey30""),
-       strip.background = element_rect(colour = ""grey70"", fill = ""grey90""),
-       strip.text       = element_text(colour = ""grey30""),
-       legend.title     = element_text(colour = ""grey30""),
-       legend.text      = element_text(colour = ""grey30"")
+  (ggplot2::theme_minimal(base_size = base_size, base_family = base_family) +
+     ggplot2::theme(
+       axis.line.x      = ggplot2::element_line(colour = ""grey80""),
+       axis.line.y      = ggplot2::element_line(colour = ""grey80""),
+       axis.text        = ggplot2::element_text(colour = ""grey50""),
+       axis.title       = ggplot2::element_text(colour = ""grey30""),
+       strip.background = ggplot2::element_rect(colour = ""grey70"", fill = ""grey90""),
+       strip.text       = ggplot2::element_text(colour = ""grey30""),
+       legend.title     = ggplot2::element_text(colour = ""grey30""),
+       legend.text      = ggplot2::element_text(colour = ""grey30"")
      ))
 }
 
 
 #' @rdname sjPlot-themes
 #' @export
 theme_sjplot2 <- function(base_size = 12, base_family = """") {
-  (theme_minimal(base_size = base_size, base_family = base_family) +
-     theme(
-       axis.line.x      = element_line(colour = ""grey50""),
-       axis.line.y      = element_line(colour = ""grey50""),
-       axis.text        = element_text(colour = ""grey10""),
-       axis.title       = element_text(colour = ""black""),
-       strip.background = element_rect(colour = ""grey50"", fill = ""grey70""),
-       strip.text       = element_text(colour = ""grey20""),
-       legend.title     = element_text(colour = ""grey10""),
-       legend.text      = element_text(colour = ""grey20"")
+  (ggplot2::theme_minimal(base_size = base_size, base_family = base_family) +
+     ggplot2::theme(
+       axis.line.x      = ggplot2::element_line(colour = ""grey50""),
+       axis.line.y      = ggplot2::element_line(colour = ""grey50""),
+       axis.text        = ggplot2::element_text(colour = ""grey10""),
+       axis.title       = ggplot2::element_text(colour = ""black""),
+       strip.background = ggplot2::element_rect(colour = ""grey50"", fill = ""grey70""),
+       strip.text       = ggplot2::element_text(colour = ""grey20""),
+       legend.title     = ggplot2::element_text(colour = ""grey10""),
+       legend.text      = ggplot2::element_text(colour = ""grey20"")
      ))
 }
 
 
 #' @rdname sjPlot-themes
 #' @export
 theme_blank <- function(base_size = 12, base_family = """") {
-  (theme_minimal(base_size = base_size, base_family = base_family) +
-     theme(
-       axis.line.x      = element_line(colour = ""white""),
-       axis.line.y      = element_line(colour = ""white""),
-       axis.text        = element_text(colour = ""grey50""),
-       axis.title       = element_text(colour = ""grey30""),
-       panel.grid.minor = element_line(colour = ""white"", linetype = 1),
-       panel.grid.major = element_line(colour = ""white"", linetype = 1)
+  (ggplot2::theme_minimal(base_size = base_size, base_family = base_family) +
+     ggplot2::theme(
+       axis.line.x      = ggplot2::element_line(colour = ""white""),
+       axis.line.y      = ggplot2::element_line(colour = ""white""),
+       axis.text        = ggplot2::element_text(colour = ""grey50""),
+       axis.title       = ggplot2::element_text(colour = ""grey30""),
+       panel.grid.minor = ggplot2::element_line(colour = ""white"", linetype = 1),
+       panel.grid.major = ggplot2::element_line(colour = ""white"", linetype = 1)
      ))
 }
 
 
 #' @rdname sjPlot-themes
 #' @export
 theme_538 <- function(base_size = 12, base_family = """") {
-  (theme_minimal(base_size = base_size, base_family = base_family) +
-     theme(
-       axis.line.x        = element_line(colour = ""#F0F0F0""),
-       axis.line.y        = element_line(colour = ""#F0F0F0""),
-       axis.text          = element_text(colour = ""#737373""),
-       axis.title         = element_text(colour = ""#525252""),
-       plot.background    = element_rect(colour = ""#F0F0F0"", fill = ""#F0F0F0""),
-       panel.grid.minor.x = element_line(colour = ""#F0F0F0"", linetype = 1),
-       panel.grid.major   = element_line(colour = ""#BDBDBD"", linetype = 1),
-       panel.grid.major.y = element_line(colour = ""#F0F0F0"", linetype = 1),
-       panel.grid.minor.y = element_line(colour = ""#F0F0F0"", linetype = 1)
+  (ggplot2::theme_minimal(base_size = base_size, base_family = base_family) +
+     ggplot2::theme(
+       axis.line.x        = ggplot2::element_line(colour = ""#F0F0F0""),
+       axis.line.y        = ggplot2::element_line(colour = ""#F0F0F0""),
+       axis.text          = ggplot2::element_text(colour = ""#737373""),
+       axis.title         = ggplot2::element_text(colour = ""#525252""),
+       plot.background    = ggplot2::element_rect(colour = ""#F0F0F0"", fill = ""#F0F0F0""),
+       panel.grid.minor.x = ggplot2::element_line(colour = ""#F0F0F0"", linetype = 1),
+       panel.grid.major   = ggplot2::element_line(colour = ""#BDBDBD"", linetype = 1),
+       panel.grid.major.y = ggplot2::element_line(colour = ""#F0F0F0"", linetype = 1),
+       panel.grid.minor.y = ggplot2::element_line(colour = ""#F0F0F0"", linetype = 1)
      ))
 }
 
 
 #' @rdname sjPlot-themes
+#' @importFrom ggplot2 theme_get
 #' @export
 font_size <- function(title, axis_title.x, axis_title.y, labels.x, labels.y, offset.x, offset.y, base.theme) {
   # get current theme
   if (!missing(base.theme))
     cur.theme <- base.theme
   else
-    cur.theme <- theme_get()
+    cur.theme <- ggplot2::theme_get()
 
   if (!missing(title)) {
     cur.theme <- cur.theme +
-      theme(title = element_text(size = title))
+      ggplot2::theme(title = ggplot2::element_text(size = title))
   }
 
   if (!missing(axis_title.x)) {
     cur.theme <- cur.theme +
-      theme(axis.title.x = element_text(size = axis_title.x))
+      ggplot2::theme(axis.title.x = ggplot2::element_text(size = axis_title.x))
   }
 
   if (!missing(axis_title.y)) {
     cur.theme <- cur.theme +
-      theme(axis.title.y = element_text(size = axis_title.y))
+      ggplot2::theme(axis.title.y = ggplot2::element_text(size = axis_title.y))
   }
 
   if (!missing(labels.x)) {
     cur.theme <- cur.theme +
-      theme(axis.text.x =  element_text(size = labels.x))
+      ggplot2::theme(axis.text.x =  ggplot2::element_text(size = labels.x))
   }
 
   if (!missing(labels.y)) {
     cur.theme <- cur.theme +
-      theme(axis.text.y =  element_text(size = labels.y))
+      ggplot2::theme(axis.text.y =  ggplot2::element_text(size = labels.y))
   }
 
   if (!missing(offset.x)) {
     cur.theme <- cur.theme +
-      theme(axis.title.x = element_text(vjust = offset.x))
+      ggplot2::theme(axis.title.x = ggplot2::element_text(vjust = offset.x))
   }
 
   if (!missing(offset.y)) {
     cur.theme <- cur.theme +
-      theme(axis.title.y = element_text(vjust = offset.y))
+      ggplot2::theme(axis.title.y = ggplot2::element_text(vjust = offset.y))
   }
 
   cur.theme
@@ -202,30 +205,31 @@ label_angle <- function(angle.x, angle.y, base.theme) {
   if (!missing(base.theme))
     cur.theme <- base.theme
   else
-    cur.theme <- theme_get()
+    cur.theme <- ggplot2::theme_get()
 
   if (!missing(angle.x)) {
     cur.theme <- cur.theme +
-      theme(axis.text.x = element_text(angle = angle.x))
+      ggplot2::theme(axis.text.x = ggplot2::element_text(angle = angle.x))
   }
 
   if (!missing(angle.y)) {
     cur.theme <- cur.theme +
-      theme(axis.text.y = element_text(angle = angle.y))
+      ggplot2::theme(axis.text.y = ggplot2::element_text(angle = angle.y))
   }
 
   cur.theme
 }
 
 
 #' @rdname sjPlot-themes
+#' @importFrom dplyr case_when
 #' @export
 legend_style <- function(inside, pos, justify, base.theme) {
   # get current theme
   if (!missing(base.theme))
     cur.theme <- base.theme
   else
-    cur.theme <- theme_get()
+    cur.theme <- ggplot2::theme_get()
 
   # convert legend position from character to numeric index
   if (!missing(inside) && inside) {
@@ -247,7 +251,7 @@ legend_style <- function(inside, pos, justify, base.theme) {
 
   if (!missing(pos)) {
     cur.theme <- cur.theme +
-      theme(
+      ggplot2::theme(
         legend.position = pos,
         legend.justification = justify
       )
@@ -287,8 +291,8 @@ scale_fill_sjplot <- function(palette = ""metro ui"", discrete = TRUE, reverse = F
 
 #' @rdname sjPlot-themes
 #' @export
-sjplot_pal <- function(pal = ""metro ui"", n = NULL) {
-  pl <- sjplot_colors[[pal]]
+sjplot_pal <- function(palette = ""metro ui"", n = NULL) {
+  pl <- sjplot_colors[[palette]]
 
   if (!is.null(n) && n <= length(pl))
     pl <- pl[1:n]
@@ -300,6 +304,8 @@ sjplot_pal <- function(pal = ""metro ui"", n = NULL) {
 #' @rdname sjPlot-themes
 #' @importFrom purrr map_df
 #' @importFrom tidyr gather
+#' @importFrom dplyr arrange mutate
+#' @importFrom rlang .data
 #' @export
 show_sjplot_pals <- function() {
 
@@ -327,7 +333,8 @@ show_sjplot_pals <- function() {
       )
     )
 
-  ggplot(x, aes(x = rev(key), fill = cols)) +
+  x$key <- rev(x$key)
+  ggplot(x, aes_string(x = ""key"", fill = ""cols"")) +
     geom_bar(width = .7) +
     scale_fill_manual(values = x$value) +
     scale_x_discrete(labels = rev(sort(names(sjpc)))) +
@@ -339,6 +346,7 @@ show_sjplot_pals <- function() {
 }
 
 
+#' @importFrom grDevices colorRampPalette
 get_sjplot_pal <- function(palette = ""metro ui"", reverse = FALSE, ...) {
   pal <- sjplot_colors[[palette]]
   if (reverse) pal <- rev(pal)

---FILE: man/plot_model.Rd---
@@ -217,7 +217,7 @@ color palette. Following options are valid for the \code{colors} argument:
   \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
   \item If \pkg{wesanderson} is installed, you may also specify a name of a palette from that package.
   \item If \pkg{viridis} is installed, use \code{colors = ""v""} to get the viridis color palette.
-  \item There are some pre-defined color palettes in this package, see \code{\link{sjplot-themes}} for details.
+  \item There are some pre-defined color palettes in this package, see \code{\link{sjPlot-themes}} for details.
   \item Else specify own color values or names as vector (e.g. \code{colors = ""#00ff00""} or \code{colors = c(""firebrick"", ""blue"")}).
 }}
 

---FILE: man/plot_models.Rd---
@@ -110,7 +110,7 @@ color palette. Following options are valid for the \code{colors} argument:
   \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
   \item If \pkg{wesanderson} is installed, you may also specify a name of a palette from that package.
   \item If \pkg{viridis} is installed, use \code{colors = ""v""} to get the viridis color palette.
-  \item There are some pre-defined color palettes in this package, see \code{\link{sjplot-themes}} for details.
+  \item There are some pre-defined color palettes in this package, see \code{\link{sjPlot-themes}} for details.
   \item Else specify own color values or names as vector (e.g. \code{colors = ""#00ff00""} or \code{colors = c(""firebrick"", ""blue"")}).
 }}
 

---FILE: man/sjPlot-themes.Rd---
@@ -36,7 +36,7 @@ scale_color_sjplot(palette = ""metro ui"", discrete = TRUE, reverse = FALSE,
 scale_fill_sjplot(palette = ""metro ui"", discrete = TRUE, reverse = FALSE,
   ...)
 
-sjplot_pal(pal = ""metro ui"", n = NULL)
+sjplot_pal(palette = ""metro ui"", n = NULL)
 
 show_sjplot_pals()
 }
@@ -97,6 +97,8 @@ are interpolated using \code{\link[grDevices]{colorRampPalette}}.}
 
 \item{reverse}{Logical, if \code{TRUE}, order of returned colours is reversed.}
 
+\item{...}{Further arguments passed down to ggplot's \code{scale()}-functions.}
+
 \item{n}{Numeric, number of colors to be returned. By default, the complete
 colour palette is returned.}
 }

---FILE: man/sjp.glm.Rd---
@@ -205,60 +205,6 @@ Plot odds or incident rate ratios with confidence intervalls as dot plot.
            Hence, \code{vars} must be a character vector with the names of
            one or two model predictors. See 'Examples'.}
          }
-}
-\examples{
-# prepare dichotomous dependent variable
-swiss$y <- ifelse(swiss$Fertility < median(swiss$Fertility), 0, 1)
-
-# fit model
-fitOR <- glm(y ~ Education + Examination + Infant.Mortality + Catholic,
-             family = binomial(link = ""logit""), data = swiss)
-
-# print Odds Ratios as dots
-sjp.glm(fitOR)
-
-# -------------------------------
-# Predictors for negative impact of care. Data from
-# the EUROFAMCARE sample dataset
-# -------------------------------
-library(sjmisc)
-library(sjlabelled)
-data(efc)
-# create binary response
-y <- ifelse(efc$neg_c_7 < median(na.omit(efc$neg_c_7)), 0, 1)
-# create data frame for fitted model
-mydf <- data.frame(y = as.factor(y),
-                   sex = to_factor(efc$c161sex),
-                   dep = to_factor(efc$e42dep),
-                   barthel = efc$barthtot,
-                   education = to_factor(efc$c172code))
-# fit model
-fit <- glm(y ~., data = mydf, family = binomial(link = ""logit""))
-
-# plot odds ratios
-sjp.glm(fit, title = get_label(efc$neg_c_7))
-
-# plot probability curves (relationship between predictors and response)
-sjp.glm(fit, title = get_label(efc$neg_c_7), type = ""slope"")
-
-# --------------------------
-# grouping estimates
-# --------------------------
-sjp.glm(fit,  group.estimates = c(1, 2, 2, 2, 3, 4, 4))
-
-# --------------------------
-# model predictions, with selected model terms.
-# 'vars' needs to be a character vector of length 1 to 3
-# with names of model terms for x-axis and grouping factor.
-# --------------------------
-sjp.glm(fit, type = ""pred"", vars = ""barthel"")
-# faceted, with ci
-sjp.glm(fit, type = ""pred"", vars = c(""barthel"", ""dep""), show.ci = TRUE)
-# w/o facets
-sjp.glm(fit, type = ""pred"", vars = c(""barthel"", ""dep""), facet.grid = FALSE)
-# with third grouping variable - this type automatically uses grid layout
-sjp.glm(fit, type = ""pred"", vars = c(""barthel"", ""sex"", ""education""))
-
 }
 \seealso{
 \href{http://www.strengejacke.de/sjPlot/sjp.glm/}{sjPlot manual: sjp.glm}

---FILE: man/sjp.glmer.Rd---
@@ -270,58 +270,6 @@ By default, this function plots estimates (odds, risk or incidents
                to compute fixed effects correlation matrices and qq-plots of
                random effects.}
        }
-}
-\examples{
-library(lme4)
-library(sjmisc)
-library(sjlabelled)
-# create binary response
-sleepstudy$Reaction.dicho <- dicho(sleepstudy$Reaction, dich.by = ""median"")
-# fit model
-fit <- glmer(Reaction.dicho ~ Days + (Days | Subject),
-             data = sleepstudy, family = binomial(""logit""))
-
-# simple plot
-sjp.glmer(fit)
-
-# sort by predictor Days
-sjp.glmer(fit, sort.est = ""Days"")
-
-\dontrun{
-data(efc)
-# create binary response
-efc$hi_qol <- dicho(efc$quol_5)
-# prepare group variable
-efc$grp = as.factor(efc$e15relat)
-levels(x = efc$grp) <- get_labels(efc$e15relat)
-# data frame for fitted model
-mydf <- data.frame(hi_qol = to_factor(efc$hi_qol),
-                   sex = to_factor(efc$c161sex),
-                   education = to_factor(efc$c172code),
-                   c12hour = efc$c12hour,
-                   neg_c_7 = efc$neg_c_7,
-                   grp = efc$grp)
-
-# fit glmer, with categorical predictor with more than 2 levels
-fit <- glmer(hi_qol ~ sex + education + c12hour + neg_c_7 + (1|grp),
-             data = mydf, family = binomial(""logit""))
-
-# plot and sort fixed effects, axis labels automatically retrieved
-sjp.glmer(fit, type = ""fe"", sort.est = TRUE)
-
-# plot probability curves (predicted probabilities)
-# for each covariate, grouped by random intercepts
-# in integrated plots, emphasizing groups 1 and 4
-sjp.glmer(fit, type = ""ri.slope"", emph.grp = c(1, 4), facet.grid = FALSE)
-
-# plot predicted probabilities for response,
-# non faceted, with ci
-sjp.glmer(fit, type = ""pred.fe"", vars = c(""neg_c_7"", ""education""),
-          show.ci = TRUE, facet.grid = FALSE)
-
-# predictions by gender and education
-sjp.glmer(fit, type = ""pred.fe"", vars = c(""neg_c_7"", ""sex"", ""education""))}
-
 }
 \seealso{
 \href{http://www.strengejacke.de/sjPlot/sjp.glmer/}{sjPlot manual: sjp.glmer}

---FILE: man/sjp.int.Rd---
@@ -221,100 +221,6 @@ Note that beside interaction terms, also the single predictors of each interacti
        For \code{type = ""eff""}, predictors of interactions that are introduced first into the model
        are used as grouping variable, while the latter predictor is printed along the x-axis
        (i.e. lm(y~a+b+a:b) means that ""a"" is used as grouping variable and ""b"" is plotted along the x-axis).
-}
-\examples{
-# Note that the data sets used in this example may not be perfectly suitable for
-# fitting linear models. I just used them because they are part of the R-software.
-
-# fit ""dummy"" model. Note that moderator should enter
-# first the model, followed by predictor. Else, use
-# argument ""swap.pred"" to change predictor on
-# x-axis with moderator
-fit <- lm(weight ~ Diet * Time, data = ChickWeight)
-
-# show summary to see significant interactions
-summary(fit)
-
-# plot regression line of interaction terms, including value labels
-sjp.int(fit, type = ""eff"", show.values = TRUE)
-
-
-# load sample data set
-library(sjmisc)
-library(sjlabelled)
-data(efc)
-# create data frame with variables that should be included
-# in the model
-mydf <- data.frame(usage = efc$tot_sc_e,
-                   sex = efc$c161sex,
-                   education = efc$c172code,
-                   burden = efc$neg_c_7,
-                   dependency = efc$e42dep)
-# convert gender predictor to factor
-mydf$sex <- relevel(factor(mydf$sex), ref = ""2"")
-# fit ""dummy"" model
-fit <- lm(usage ~ .*., data = mydf)
-summary(fit)
-
-# plot interactions. note that type = ""cond"" only considers
-# significant interactions by default. use ""plevel"" to
-# adjust p-level sensivity
-sjp.int(fit, type = ""cond"")
-
-# plot only selected interaction term for
-# type = ""eff""
-sjp.int(fit, type = ""eff"", int.term = ""sex*education"")
-
-# plot interactions, using mean and sd as moderator
-# values to calculate interaction effect
-sjp.int(fit, type = ""eff"", mdrt.values = ""meansd"")
-sjp.int(fit, type = ""cond"", mdrt.values = ""meansd"")
-
-# plot interactions, including those with p-value up to 0.1
-sjp.int(fit, type = ""cond"", plevel = 0.1)
-
-# -------------------------------
-# Predictors for negative impact of care.
-# Data from the EUROFAMCARE sample dataset
-# -------------------------------
-# create binary response
-y <- ifelse(efc$neg_c_7 < median(stats::na.omit(efc$neg_c_7)), 0, 1)
-# create data frame for fitted model
-mydf <- data.frame(y = as.factor(y),
-                   sex = as.factor(efc$c161sex),
-                   barthel = as.numeric(efc$barthtot))
-# fit model
-fit <- glm(y ~ sex * barthel, data = mydf, family = binomial(link = ""logit""))
-# plot interaction, increase p-level sensivity
-sjp.int(fit, type = ""eff"", legend.labels = get_labels(efc$c161sex), plevel = 0.1)
-sjp.int(fit, type = ""cond"", legend.labels = get_labels(efc$c161sex), plevel = 0.1)
-
-\dontrun{
-# load sample data set
-library(sjmisc)
-data(efc)
-# create data frame with variables that should be included
-# in the model
-mydf <- data.frame(burden = efc$neg_c_7,
-                   sex = efc$c161sex,
-                   education = efc$c172code,
-                   barthel = efc$barthtot)
-# convert gender predictor to factor
-mydf$sex <- factor(mydf$sex)
-mydf$education <- factor(mydf$education)
-# name factor levels and dependent variable
-levels(mydf$sex) <- c(""female"", ""male"")
-levels(mydf$education) <- c(""low"", ""mid"", ""high"")
-mydf$burden <- set_label(mydf$burden, lab = ""care burden"")
-# fit ""dummy"" model
-fit <- lm(burden ~ .*., data = mydf)
-
-# plot effects
-sjp.int(fit, type = ""eff"", show.ci = TRUE)
-
-# plot effects, faceted
-sjp.int(fit, type = ""eff"", int.plot.index = 3, show.ci = TRUE, facet.grid = TRUE)}
-
 }
 \references{
 \itemize{

---FILE: man/sjp.lm.Rd---
@@ -246,124 +246,6 @@ Depending on the \code{type}, this function plots coefficients (estimates)
                  Values greater than 10 are not acceptable and indicate multicollinearity
                  between model's predictors.}
            }
-}
-\examples{
-# --------------------------------------------------
-# plotting estimates of linear models as forest plot
-# --------------------------------------------------
-# fit linear model
-fit <- lm(airquality$Ozone ~ airquality$Wind + airquality$Temp + airquality$Solar.R)
-
-# plot estimates with CI
-sjp.lm(fit, grid.breaks = 2)
-
-# plot estimates with CI
-# and with narrower tick marks
-# (because ""grid.breaks"" was not specified)
-sjp.lm(fit)
-
-# ---------------------------------------------------
-# plotting regression line of linear model (done
-# automatically if fitted model has only 1 predictor)
-# ---------------------------------------------------
-library(sjmisc)
-data(efc)
-# fit model
-fit <- lm(neg_c_7 ~ quol_5, data=efc)
-# plot regression line with label strings
-sjp.lm(fit, resp.label = ""Burden of care"",
-       axis.labels = ""Quality of life"", show.loess = TRUE)
-
-# --------------------------------------------------
-# plotting regression lines of each single predictor
-# of a fitted model
-# --------------------------------------------------
-library(sjmisc)
-data(efc)
-# fit model
-fit <- lm(tot_sc_e ~ c12hour + e17age + e42dep, data=efc)
-
-# reression line and scatter plot
-sjp.lm(fit, type = ""slope"")
-
-# reression line w/o scatter plot
-sjp.lm(fit, type = ""slope"", show.scatter = FALSE)
-
-# --------------------------
-# plotting model assumptions
-# --------------------------
-sjp.lm(fit, type = ""ma"")
-
-\dontrun{
-# --------------------------
-# grouping estimates
-# --------------------------
-library(sjmisc)
-data(efc)
-fit <- lm(barthtot ~ c160age + e17age + c12hour + e16sex + c161sex + c172code,
-          data = efc)
-
-# order estimates according to coefficient's order
-sjp.lm(fit, group.estimates = c(1, 1, 2, 3, 3, 4),
-       geom.colors = c(""green"", ""red"", ""blue"", ""grey""), sort.est = FALSE)
-
-fit <- lm(barthtot ~ c160age + c12hour + e17age+ c161sex + c172code + e16sex,
-          data = efc)
-
-# force order of estimates according to group assignment
-sjp.lm(fit, group.estimates = c(1, 2, 1, 3, 4, 3),
-       geom.colors = c(""green"", ""red"", ""blue"", ""grey""), sort.est = TRUE)
-
-# --------------------------
-# predicted values for response
-# --------------------------
-library(sjmisc)
-data(efc)
-efc$education <- to_label(to_factor(efc$c172code))
-efc$gender <- to_label(to_factor(efc$c161sex))
-fit <- lm(barthtot ~ c160age + c12hour + e17age + gender + education,
-          data = efc)
-
-sjp.lm(fit, type = ""pred"", vars = ""c160age"")
-
-# with loess
-sjp.lm(fit, type = ""pred"", vars = ""e17age"", show.loess = TRUE)
-
-# grouped
-sjp.lm(fit, type = ""pred"", vars = c(""c12hour"", ""education""))
-
-# grouped, non-facet
-sjp.lm(fit, type = ""pred"", vars = c(""c12hour"", ""education""),
-       facet.grid = FALSE)
-
-# two groupings
-sjp.lm(fit, type = ""pred"", vars = c(""c12hour"", ""gender"", ""education""))
-
-# --------------------------
-# plotting polynomial terms
-# --------------------------
-library(sjmisc)
-data(efc)
-# fit sample model
-fit <- lm(tot_sc_e ~ c12hour + e17age + e42dep, data = efc)
-# ""e17age"" does not seem to be linear correlated to response
-# try to find appropiate polynomial. Grey line (loess smoothed)
-# indicates best fit. Looks like x^3 has a good fit.
-# (not checked for significance yet).
-sjp.poly(fit, ""e17age"", 2:4, show.scatter = FALSE)
-# fit new model
-fit <- lm(tot_sc_e ~ c12hour + e42dep +
-          e17age + I(e17age^2) + I(e17age^3),
-          data = efc)
-# plot marginal effects of polynomial term
-sjp.lm(fit, type = ""poly"", poly.term = ""e17age"")
-
-library(splines)
-# fit new model with ""splines""-package, ""bs""
-fit <- lm(tot_sc_e ~ c12hour + e42dep + bs(e17age, 3), data = efc)
-# plot marginal effects of polynomial term, same call as above
-sjp.lm(fit, type = ""poly"", poly.term = ""e17age"")}
-
 }
 \references{
 Gelman A (2008) ""Scaling regression inputs by dividing by two standard deviations."" \emph{Statistics in Medicine 27: 28652873.} \url{http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf}

---FILE: man/sjp.lmer.Rd---
@@ -286,89 +286,6 @@ Computation of p-values (if necessary and if \code{p.kr = TRUE}) are based
         on normal-distribution assumption, treating the t-statistics as Wald
         z-statistics. See 'Details' in \code{\link[sjstats]{p_value}}.
 }
-\examples{
-# fit model
-library(lme4)
-fit <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
-
-# simple plot
-sjp.lmer(fit)
-
-# plot fixed effects
-sjp.lmer(fit, type = ""fe"")
-
-# sort by predictor Days
-sjp.lmer(fit, sort.est = ""Days"")
-
-# plot each predictor as own plot
-# sort each plot
-sjp.lmer(fit, facet.grid = FALSE, sort.est = ""sort.all"")
-
-library(sjmisc)
-library(sjlabelled)
-data(efc)
-# prepare group variable
-efc$grp = as.factor(efc$e15relat)
-levels(x = efc$grp) <- get_labels(efc$e15relat)
-# data frame for fitted model
-mydf <- data.frame(neg_c_7 = as.numeric(efc$neg_c_7),
-                   sex = as.factor(efc$c161sex),
-                   c12hour = as.numeric(efc$c12hour),
-                   barthel = as.numeric(efc$barthtot),
-                   grp = efc$grp)
-# fit lmer
-fit <- lmer(neg_c_7 ~ sex + c12hour + barthel + (1|grp), data = mydf)
-
-sjp.lmer(fit, type = ""fe.std"", sort.est = TRUE)
-
-# highlight specific grouping levels, in this case we compare
-# spouses, children and children-in-law
-sjp.lmer(fit, type = ""ri.slope"", emph.grp = c(1, 2, 4), vars = ""c12hour"")
-
-\dontrun{
-# plotting polynomial terms
-# check linear relation between predictors and response
-sjp.lmer(fit, type = ""fe.slope"", show.loess = TRUE)
-
-# ""barthel"" does not seem to be linear correlated to response
-# try to find appropiate polynomial. Grey line (loess smoothed)
-# indicates best fit. Looks like x^4 has the best fit,
-# however, x^2 seems to be suitable according to p-values.
-sjp.poly(fit, ""barthel"", 2:4, show.scatter = FALSE)
-
-# fit new model
-fit <- lmer(neg_c_7 ~ sex + c12hour + barthel +
-            I(barthel^2) + (1|grp), data = mydf)
-
-# plot marginal effects of polynomial term
-sjp.lmer(fit, type = ""poly"", poly.term = ""barthel"")
-
-# lme4 complaints about scale of polynomial term, so
-# try centering this predictor
-mydf$barthel_s <- sjmisc::std(mydf$barthel)
-
-# re-fit model
-fit_s <- lmer(neg_c_7 ~ sex + c12hour + barthel_s +
-              I(barthel_s^2) + (1|grp), data = mydf)
-
-# plot marginal effects of centered, scaled polynomial term
-sjp.lmer(fit_s, type = ""poly"", poly.term = ""barthel_s"")
-
-# scaling also improved p-values
-sjt.lmer(fit, fit_s)
-
-# plotting predicted values for response
-# conditioned on random effects
-sjp.lmer(fit, type = ""pred"", vars = ""c12hour"")
-
-# grouped, for fixed effects only
-sjp.lmer(fit, type = ""pred.fe"", vars = c(""c12hour"", ""sex""))
-
-# grouped, for fixed effects only, non-facted
-sjp.lmer(fit, type = ""pred.fe"", vars = c(""c12hour"", ""sex""),
-         facet.grid = FALSE, show.ci = FALSE)}
-
-}
 \seealso{
 \href{http://www.strengejacke.de/sjPlot/sjp.lmer/}{sjPlot manual: sjp.lmer}
 }

---FILE: man/sjplot.Rd---
@@ -8,7 +8,7 @@
 sjplot(data, ..., fun = c(""frq"", ""grpfrq"", ""xtab"", ""gpt"", ""scatter"", ""aov1"",
   ""likert"", ""stackfrq""))
 
-sjtab(data, ..., fun = c(""frq"", ""xtab"", ""grpmean"", ""stackfrq""))
+sjtab(data, ..., fun = c(""xtab"", ""stackfrq""))
 }
 \arguments{
 \item{data}{A data frame. May also be a grouped data frame (see 'Note' and
@@ -37,7 +37,7 @@ Following \code{fun}-values are currently supported:
             \item{\code{""aov1""}}{calls \code{\link{sjp.aov1}}. The first
             two variables in \code{data} are used (and required) to create the plot.
             }
-            \item{\code{""frq""}}{calls \code{\link{sjp.frq}} or \code{\link{sjt.frq}}.
+            \item{\code{""frq""}}{calls \code{\link{sjp.frq}}.
             If \code{data} has more than one variable, a plot for each
             variable in \code{data} is plotted.
             }
@@ -47,10 +47,6 @@ Following \code{fun}-values are currently supported:
             \item{\code{""grpfrq""}}{calls \code{\link{sjp.grpfrq}}. The first
             two variables in \code{data} are used (and required) to create the plot.
             }
-            \item{\code{""grpmean""}}{calls \code{\link{sjt.grpmean}}.
-            The first two variables in \code{data} are used (and required)
-            to create the table.
-            }
             \item{\code{""likert""}}{calls \code{\link{sjp.likert}}. \code{data}
             must be a data frame with items to plot.
             }

---FILE: vignettes/sjtbasic.Rmd---
@@ -1,136 +0,0 @@
----
-title: ""Basics of the sjt Table Functions""
-author: ""Daniel Ldecke""
-date: ""`r Sys.Date()`""
-output: rmarkdown::html_vignette
-vignette: >
-  %\VignetteIndexEntry{Basics of the sjt Table Functions}
-  %\VignetteEngine{knitr::rmarkdown}
-  %\VignetteEncoding{UTF-8}
----
-
-```{r echo = FALSE}
-knitr::opts_chunk$set(collapse = TRUE, comment = ""#>"")
-```
-
-
-This vignette describes some basic features of all `sjt` functions from the **sjPlot** package. These functions create HTML table outputs.
-
-
-## Printing HTML tables
-
-Before starting, we need to load the required packages and sample data.
-
-```{r, message=FALSE, warning=FALSE}
-# load packages
-library(sjPlot)
-library(sjmisc)
-library(dplyr)
-# load sample data set.
-data(efc)
-```
-
-All `sjt` functions create a HTML page with the data table. This table, by default, is opened in the viewer pane of your IDE (in case you're using an IDE which also supports the viewer pane, see parameter `use.viewer` for details). If a viewer pane is not available, the created HTML output is saved as temporary file and opened in your default webbrowser. The temporary files are deleted after your R session ends.
-
-## Copying table output to office or word processors
-
-### Export table as HTML file to open in word processors
-
-You can save the HTML page as file for further usage by specifying the `file` parameter. The saved HTML file can be opened by word processors like [LibreOffice](http://www.libreoffice.org) or [Microsoft Office](http://office.microsoft.com).
-
-### Drag and drop from browser or RStudio viewer pane
-
-You can directly drag and drop a table from the RStudio viewer pane oder browser into your word processor. Simply select the complete table with your mouse and drag it into office.
-
-## Character encoding
-
-In some cases, you may have to specify a character encoding in order to get proper labels in the HTML tables. If you face problems with correctly displaying labels, use the `encoding` parameter to change the character encoding. This value dependes on your region where you live. Following example, which works for western European countries, is the default behaviour of all `sjt`-functions:
-
-```{r eval=FALSE}
-# don't need to do this, because all sjt-functions
-# use this code as default encoding-detection
-if (.Platform$OS.type == ""unix"") 
-  encoding <- ""UTF-8"" 
-else 
-  encoding <- ""Windows-1252""
-
-sjt.frq(efc$e15relat, encoding = encoding)
-```
-
-This example first detects your operating system and then chooses the associated character encoding, which is used in the HTML file. If this does not work for you, you have to use the `encoding` parameter.
-
-## Knitr integration of HTML tables
-
-**sjPlot** provides a print-method for HTML-tables to use in knitr-documents, so you can use the `sjt`-functions inside code chunks in knitr-rmarkdown files. The HTML-table will be printed to the knitr-document 'as is':
-
-```{r}
-sjt.frq(efc$e42dep)
-```
-
-This also works for table-outputs from `sjtab()`. For instance, you can easily create multiple tables from grouped data frames.
-
-```{r}
-efc %>% 
-  group_by(e16sex, c172code) %>% 
-  select(e16sex, c172code, e42dep) %>% 
-  sjtab()
-```
-
-Note that this does not properly work for PDF-documents, but only if the output of the rmarkdown-file is HTML.
-
-## Customizing table output with the CSS parameter
-
-The table output is in in [HTML format](http://en.wikipedia.org/wiki/HTML). The table style (visual appearance) is formatted using [Cascading Style Sheets](http://en.wikipedia.org/wiki/Cascading_Style_Sheets). If you are a bit familiar with these topics, you can easily customize the appearance of the table output.
-
-Many table elements (header, row, column, cell, summary row, first row or column...) have CSS-class attributes, which can be used to change the table style. Since each `sjt` function has different table elements and thus different class attributes, you first need to know which styles can be customized.
-
-### Retrieving customizable styles
-
-Each `sjt` function invisibly returns several values. The return value `page.style` contains the style information for the HTML table. You can print this style sheet to console using the base R `cat()` function:
-
-```{r eval=TRUE, warning=FALSE}
-cat(sjt.frq(efc$e42dep, no.output = TRUE)$page.style)
-```
-
-The HTML code is obtained by using the `page.content` return value. Since the `sjt.frq()` function allows to plot multiple tables at once, this function returns a list of HTML tables as `page.content.list`. The following code prints the HTML code of the table to the R console:
-
-```{r eval=TRUE, warning=FALSE}
-cat(sjt.frq(efc$e42dep, no.output = TRUE)$page.content.list[[1]])
-# not that other sjt-functions don't return a page.content-list, but
-# just '$page.content'...
-```
-
-Now you can see which table elements are associated with which CSS class attributes. If you compare the `page.style` with the related `page.content`, you see that not all style attributes are used:
-
-* `.arc` is the attribute for the parameter `altr.row.col` and appears only in the `page.content` if it is set to `TRUE`.
-* `.qrow` and `.mdrow` are the class attributes for the `emph.quart` and `emph.md` parameters.
-* `.firsttablecol` is empty, but used. This class attribute is assigned in case you want to customize the appearance of the first table column (the one with value labels).
-
-### Customizing table output with the CSS parameter
-
-You can customize the table output with the `CSS` parameter. This parameter requires a list of attributes, which follow a certain pattern:
-
-1. each attributes needs a `css.` prefix
-2. followed by the class name (e.g. `caption`, `thead`, `centeralign`, `arc` etc.)
-3. equal-sign
-4. the CSS format (in (single) quotation marks)
-5. the CSS format must end with a colon (;)
-
-Example:
-```{r }
-sjt.frq(
-  efc$e42dep, 
-  CSS = list(css.centeralign = 'text-align: left;', 
-             css.caption = 'font-weight: normal; font-style: italic;', 
-             css.firsttablecol = 'font-weight: bold;', 
-             css.lasttablerow = 'border-top: 1px solid; border-bottom: none;', 
-             css.summary = 'color: blue;')
-)
-```
-
-In the above example, the summary-table row lost the original style and just became blue. If you want to keep the original style and just *add* additional style information, use the plus-sign (`+`) as initial character for the parameter attributes. In the following example, the summary row keeps its original style and is additionally printed in blue:
-
-```{r }
-sjt.frq(efc$e42dep, CSS = list(css.summary = '+color: blue;'))
-```
-"
strengejacke,sjPlot,afaa5ecda01c235a7b9ad2ec9fde469e0d749947,Daniel,mail@danielluedecke.de,2018-04-15T19:50:33Z,Daniel,mail@danielluedecke.de,2018-04-15T19:50:33Z,fix issues with tidyrs for multivariate-response-models from brms,R/tidiers.R,False,True,True,False,6,11,17,"---FILE: R/tidiers.R---
@@ -333,7 +333,10 @@ tidy_stan_model <- function(model, ci.lvl, tf, type, bpe, show.zeroinf, facets,
     responses <- stats::formula(model)$response
 
     # also clean prepared data frame
-    resp.sigma <- tidyselect::starts_with(""sigma_"", vars = dat$term)
+    resp.sigma1 <- tidyselect::starts_with(""sigma_"", vars = dat$term)
+    resp.sigma2 <- tidyselect::starts_with(""b_sigma_"", vars = dat$term)
+
+    resp.sigma <- c(resp.sigma1, resp.sigma2)
 
     if (!sjmisc::is_empty(resp.sigma))
       dat <- dplyr::slice(dat, !! -resp.sigma)
@@ -349,9 +352,10 @@ tidy_stan_model <- function(model, ci.lvl, tf, type, bpe, show.zeroinf, facets,
     for (i in responses) {
       m <- tidyselect::contains(i, vars = dat$term)
       dat$response.level[m] <- i
+      dat$term <- gsub(sprintf(""b_%s_"", i), """", dat$term, fixed = TRUE)
+      dat$term <- gsub(sprintf(""s_%s_"", i), """", dat$term, fixed = TRUE)
     }
 
-    dat$term <- gsub(""b_(.*)\\_"", """", dat$term)
 
     # check whether each category should be printed in facets, or
     # in a single graph (with dodged geoms)
@@ -383,15 +387,6 @@ tidy_stan_model <- function(model, ci.lvl, tf, type, bpe, show.zeroinf, facets,
   }
 
 
-  # fix term-names from brmsfit
-
-  if (inherits(model, ""brmsfit"")) {
-    ## TODO check if this works for multivariate response models as well
-    dat$term <- sub(pattern = ""b_Intercept"", replacement = ""(Intercept)"", x = dat$term, fixed = T)
-    dat$term <- sub(pattern = ""b_"", replacement = """", x = dat$term, fixed = T)
-  }
-
-
   # need to transform point estimate as well
   if (!is.null(tf)) {
     funtrans <- match.fun(tf)"
strengejacke,sjPlot,4d135c0782d353b78c881020869109efbd15e968,Daniel,mail@danielluedecke.de,2018-04-04T19:10:34Z,Daniel,mail@danielluedecke.de,2018-04-04T19:10:34Z,close https://github.com/strengejacke/sjmisc/issues/80,R/S3-methods.R,False,True,True,False,2,2,4,"---FILE: R/S3-methods.R---
@@ -369,7 +369,7 @@ pfrq <- function(x, ...) {
     lab <- attr(i, ""label"", exact = T)
     vt <- attr(i, ""vartype"", exact = T)
 
-    if (!is.null(lab)) ret <- sprintf(""%s <span style=\""font-weight: normal; font-style: italic\"">&lt;%s&gt</span>"", lab, vt)
+    if (!is.null(lab)) ret <- sprintf(""%s <span style=\""font-weight: normal; font-style: italic\"">&lt;%s&gt;</span>"", lab, vt)
 
     # get grouping title label
     grp <- attr(i, ""group"", exact = T)
@@ -382,7 +382,7 @@ pfrq <- function(x, ...) {
 
 
   footnotes <- purrr::map_chr(x, ~ sprintf(
-    ""total N=%i &middot; valid N=%i &middot; x&#772=%.2f &middot; &sigma;=%.2f\n"",
+    ""total N=%i &middot; valid N=%i &middot; x&#772;=%.2f &middot; &sigma;=%.2f\n"",
     sum(.x$frq, na.rm = TRUE),
     sum(.x$frq[1:(nrow(.x) - 1)], na.rm = TRUE),
     attr(.x, ""mean"", exact = T),"
strengejacke,sjPlot,371ab0194fb8f8cf561344f1e3d9f82884c3b61b,Daniel,mail@danielluedecke.de,2018-03-28T07:36:57Z,Daniel,mail@danielluedecke.de,2018-03-28T07:36:57Z,fix term-names from brmsfit,R/tab_model.R,False,True,True,False,8,0,8,"---FILE: R/tab_model.R---
@@ -118,6 +118,14 @@ tab_model <- function(
       }
 
 
+      # fix term-names from brmsfit ----
+
+      if (inherits(model, ""brmsfit"")) {
+        dat$term <- sub(pattern = ""b_Intercept"", replacement = ""(Intercept)"", x = dat$term, fixed = T)
+        dat$term <- sub(pattern = ""b_"", replacement = """", x = dat$term, fixed = T)
+      }
+
+
       # indicate p <0.001
 
       pv <- paste0(""0."", paste(rep(""0"", digits.p), collapse = """"))"
strengejacke,sjPlot,c9860793be9349ad8435c808e4837cad9a9d98ea,Daniel,mail@danielluedecke.de,2018-03-27T17:56:47Z,Daniel,mail@danielluedecke.de,2018-03-27T17:56:47Z,minor fix,R/tab_model.R,False,True,True,False,6,1,7,"---FILE: R/tab_model.R---
@@ -92,10 +92,15 @@ tab_model <- function(
           digits,
           .data$conf.high
         )) %>%
-        dplyr::select(-.data$conf.low, -.data$conf.high, -.data$wrap.facet) %>%
+        dplyr::select(-.data$conf.low, -.data$conf.high) %>%
         dplyr::mutate(p.value = sprintf(""%.*f"", digits.p, .data$p.value))
 
 
+      # remove special columns ----
+
+      if (tibble::has_name(dat, ""wrap.facet"")) dat <- dplyr::select(dat, -.data$wrap.facet)
+
+
       # indicate p <0.001
 
       pv <- paste0(""0."", paste(rep(""0"", digits.p), collapse = """"))"
strengejacke,sjPlot,76af0a2d311e3b3f604ababa2fff0c0c8fb41268,Daniel,mail@danielluedecke.de,2018-03-06T19:22:28Z,Daniel,mail@danielluedecke.de,2018-03-06T19:22:28Z,fix issue with grid breaks for very small values,R/utils.R,False,True,True,False,4,0,4,"---FILE: R/utils.R---
@@ -56,6 +56,10 @@ get_axis_limits_and_ticks <- function(axis.lim, min.val, max.val, grid.breaks, e
       lower_lim <- round(lower_lim, 2)
       upper_lim <- round(upper_lim, 2)
 
+      # for *very* small values, lower_lim might be zero, so
+      # correct value here. else we have Inf as limit
+      if (lower_lim == 0) lower_lim <- min.val * fac.ll / 10
+
       # use pretty distances for log-scale
       ticks <- grDevices::axisTicks(log10(c(lower_lim, upper_lim)), log = TRUE)
 "
strengejacke,sjPlot,f4580f0c8a8ef75b8292a873894844b9e23637b3,Daniel,mail@danielluedecke.de,2018-02-04T13:58:34Z,Daniel,mail@danielluedecke.de,2018-02-04T13:58:34Z,fix issue with tab_df(),NAMESPACE;R/S3-methods.R;R/html_print.R;man/tab_df.Rd,False,True,True,False,77,37,114,"---FILE: NAMESPACE---
@@ -176,6 +176,7 @@ importFrom(sjmisc,replace_na)
 importFrom(sjmisc,set_na)
 importFrom(sjmisc,std)
 importFrom(sjmisc,str_contains)
+importFrom(sjmisc,str_start)
 importFrom(sjmisc,to_factor)
 importFrom(sjmisc,to_label)
 importFrom(sjmisc,to_value)

---FILE: R/S3-methods.R---
@@ -65,7 +65,10 @@ print.sjt_grpmean <- function(x, ...) {
     show.footnote = TRUE,
     alternate.rows = FALSE,
     encoding = ""UTF-8"",
-    CSS = list(css.firsttablecol = '+text-align:left;'),
+    CSS = list(
+      css.firsttablecol = '+text-align:left;',
+      css.lasttablerow = 'border-top:1px solid; border-bottom: double;'
+    ),
     file = NULL,
     use.viewer = attr(x, ""print"", exact = TRUE) == ""viewer"",
     ...
@@ -109,7 +112,10 @@ print.sjt_grpmeans <- function(x, ...) {
     show.footnote = TRUE,
     alternate.rows = FALSE,
     encoding = ""UTF-8"",
-    CSS = list(css.firsttablecol = '+text-align:left;'),
+    CSS = list(
+      css.firsttablecol = '+text-align:left;',
+      css.lasttablerow = 'border-top:1px solid; border-bottom: double;'
+    ),
     file = NULL,
     use.viewer = uv,
     ...

---FILE: R/html_print.R---
@@ -51,22 +51,29 @@
 #'   that are used in this function, see return value \code{page.style} for
 #'   details. Arguments for this list have following syntax:
 #'   \enumerate{
-#'     \item the class-names with \code{""css.""}-prefix as argument name and
+#'     \item the class-name as argument name and
 #'     \item each style-definition must end with a semicolon
 #'   }
 #'   You can add style information to the default styles by using a +
 #'   (plus-sign) as initial character for the argument attributes.
 #'   Examples:
 #'   \itemize{
-#'     \item \code{css.table = 'border:2px solid red;'} for a solid 2-pixel table border in red.
-#'     \item \code{css.summary = 'font-weight:bold;'} for a bold fontweight in the summary row.
-#'     \item \code{css.lasttablerow = 'border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-#'     \item \code{css.colnames = '+color:green'} to add green color formatting to column names.
-#'     \item \code{css.arc = 'color:blue;'} for a blue text color each 2nd row.
-#'     \item \code{css.caption = '+color:red;'} to add red font-color to the default table caption style.
+#'     \item \code{table = 'border:2px solid red;'} for a solid 2-pixel table border in red.
+#'     \item \code{summary = 'font-weight:bold;'} for a bold fontweight in the summary row.
+#'     \item \code{lasttablerow = 'border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+#'     \item \code{colnames = '+color:green'} to add green color formatting to column names.
+#'     \item \code{arc = 'color:blue;'} for a blue text color each 2nd row.
+#'     \item \code{caption = '+color:red;'} to add red font-color to the default table caption style.
 #'   }
 #'   See further examples in \href{../doc/sjtbasic.html}{this package-vignette}.
 #'
+#' @examples
+#' \dontrun{
+#' data(iris)
+#' data(mtcars)
+#' tab_df(iris[1:5, ])
+#' tab_dfs(list(iris[1:5, ], mtcars[1:5, 1:5]))}
+#'
 #' @importFrom sjmisc var_type is_even
 #' @importFrom purrr flatten_chr map
 #' @export
@@ -84,6 +91,9 @@ tab_df <- function(x,
                    use.viewer = TRUE,
                    ...) {
 
+  # make sure list elements in CSS argument have proper name attribute
+  CSS <- check_css_param(CSS)
+
   # get style definition
   style <- tab_df_style(CSS = CSS, ...)
 
@@ -151,6 +161,9 @@ tab_dfs <- function(x,
                     use.viewer = TRUE,
                     ...) {
 
+  # make sure list elements in CSS argument have proper name attribute
+  CSS <- check_css_param(CSS)
+
   # get style definition
   style <- tab_df_style(CSS = CSS, ...)
 
@@ -216,31 +229,53 @@ tab_dfs <- function(x,
 }
 
 
+#' @importFrom sjmisc is_empty str_start
+check_css_param <- function(CSS) {
+  if (sjmisc::is_empty(CSS)) return(CSS)
+
+  n <- names(CSS)
+  nocss <-
+    unlist(lapply(sjmisc::str_start(x = n, pattern = ""css.""), sjmisc::is_empty))
+
+  if (any(nocss)) {
+    n[nocss] <- paste0(""css."", n[nocss])
+    names(CSS) <- n
+  }
+
+  CSS
+}
+
+
 # This functions creates the body of the HTML page, i.e. it puts
 # the content of a data frame into a HTML table that is returned.
 
 #' @importFrom sjmisc is_empty
-#' @importFrom tibble has_rownames has_name
+#' @importFrom tibble has_rownames has_name rownames_to_column
 tab_df_content <- function(mydf, title, footnote, col.header, show.type, show.rownames, show.footnote, altr.row.col, ...) {
 
+  # save no of rows and columns
+
   rowcnt <- nrow(mydf)
   colcnt <- ncol(mydf)
 
   cnames <- colnames(mydf)
 
+
+  # if user supplied own column header, which also has the same length
+  # as no. columns, replace column names with user header
+
   if (!sjmisc::is_empty(col.header) && length(col.header) == length(cnames))
     cnames <- col.header
 
-  if (tibble::has_rownames(mydf))
-    rnames <- rownames(mydf)
-  else if (tibble::has_name(mydf, ""rownames""))
-    rnames <- mydf[[""rownames""]]
-  else
-    rnames <- """"
 
+  # check if rownames should be shown and data has any rownames at all
+  # if so, we need to update our information on column names
 
-  if (show.rownames && sjmisc::is_empty(rnames))
-    show.rownames <- FALSE
+  if (show.rownames && tibble::has_rownames(mydf)) {
+    mydf <- tibble::rownames_to_column(mydf)
+    colcnt <- colcnt + 1
+    cnames <- c(""Row"", cnames)
+  }
 
 
   # start table tag
@@ -296,20 +331,11 @@ tab_df_content <- function(mydf, title, footnote, col.header, show.type, show.ro
 
     page.content <- paste0(page.content, ""  <tr>\n"")
 
-    # first table cell is rowname
-    if (show.rownames)
-      page.content <- paste0(page.content, sprintf(
-        ""    <td class=\""tdata leftalign firsttablecol%s%s\"">%s</td>\n"",
-        ltr,
-        arcstring,
-        rnames[rcnt])
-      )
-
     # all columns of a row
     for (ccnt in 1:colcnt) {
 
       # separate CSS for first column
-      if (ccnt == 1 && !show.rownames)
+      if (ccnt == 1)
         ftc <- "" firsttablecol""
       else
         ftc <- """"
@@ -333,7 +359,6 @@ tab_df_content <- function(mydf, title, footnote, col.header, show.type, show.ro
 
   if (show.footnote) {
     page.content <- paste0(page.content, ""  <tr>\n"")
-    if (!show.rownames) colcnt <- colcnt - 1
     page.content <- paste0(page.content, sprintf(""    <td colspan=\""%i\"" class=\""footnote\"">%s</td>\n"", colcnt + 1, footnote))
     page.content <- paste0(page.content, ""</tr>\n"")
   }
@@ -417,7 +442,7 @@ tab_df_prepare_style <- function(CSS = NULL, content = NULL, task, ...) {
   css.thead <- ""border-top: double; text-align:center; font-style:italic; font-weight:normal; padding:0.2cm;""
   css.tdata <- ""padding:0.2cm; text-align:left; vertical-align:top;""
   css.arc <- ""background-color:#f2f2f2;""
-  css.lasttablerow <- ""border-top:1px solid; border-bottom: double;""
+  css.lasttablerow <- ""border-bottom: double;""
   css.firsttablerow <- ""border-bottom:1px solid black;""
   css.firsttablecol <- """"
   css.leftalign <- ""text-align:left;""

---FILE: man/tab_df.Rd---
@@ -80,19 +80,19 @@ These functions print data frames as HTML-table, showing
   that are used in this function, see return value \code{page.style} for
   details. Arguments for this list have following syntax:
   \enumerate{
-    \item the class-names with \code{""css.""}-prefix as argument name and
+    \item the class-name as argument name and
     \item each style-definition must end with a semicolon
   }
   You can add style information to the default styles by using a +
   (plus-sign) as initial character for the argument attributes.
   Examples:
   \itemize{
-    \item \code{css.table = 'border:2px solid red;'} for a solid 2-pixel table border in red.
-    \item \code{css.summary = 'font-weight:bold;'} for a bold fontweight in the summary row.
-    \item \code{css.lasttablerow = 'border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-    \item \code{css.colnames = '+color:green'} to add green color formatting to column names.
-    \item \code{css.arc = 'color:blue;'} for a blue text color each 2nd row.
-    \item \code{css.caption = '+color:red;'} to add red font-color to the default table caption style.
+    \item \code{table = 'border:2px solid red;'} for a solid 2-pixel table border in red.
+    \item \code{summary = 'font-weight:bold;'} for a bold fontweight in the summary row.
+    \item \code{lasttablerow = 'border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+    \item \code{colnames = '+color:green'} to add green color formatting to column names.
+    \item \code{arc = 'color:blue;'} for a blue text color each 2nd row.
+    \item \code{caption = '+color:red;'} to add red font-color to the default table caption style.
   }
   See further examples in \href{../doc/sjtbasic.html}{this package-vignette}.
 }
@@ -103,3 +103,11 @@ The HTML tables can either be saved as file and manually opened
   or opened with the default web browser. Displaying resp. opening a
   temporary file is the default behaviour.
 }
+\examples{
+\dontrun{
+data(iris)
+data(mtcars)
+tab_df(iris[1:5, ])
+tab_dfs(list(iris[1:5, ], mtcars[1:5, 1:5]))}
+
+}"
strengejacke,sjPlot,31aa988673dc752dfea2765569209ec4e6956d78,Daniel,mail@danielluedecke.de,2018-01-26T17:20:35Z,Daniel,mail@danielluedecke.de,2018-01-26T17:20:35Z,"Fixed issue when plotting random effects (`type = ""re""`) for specific `brms`-models.",NEWS.md;R/tidiers.R,False,True,True,False,3,1,4,"---FILE: NEWS.md---
@@ -27,6 +27,7 @@
 * Fixed a bug that was introduced during the past update in `sjt.grpmean()`, resulting in multiple table outputs and a wrong overall p-value in the summary line.
 * Model weights are now correctly taken into account for marginal effect plots in `plot_model()`.
 * `sjp.likert()` did not show correct order for factors with character levels, when a neutral category was specified and was not the last factor level.
+* Fixed issue when plotting random effects (`type = ""re""`) for specific `brms`-models.
 
 # sjPlot 2.4.0
 

---FILE: R/tidiers.R---
@@ -153,8 +153,9 @@ tidy_stan_model <- function(model, ci.lvl, tf, type, bpe, ...) {
   if (inherits(model, ""brmsfit"")) {
     re.sd <- tidyselect::starts_with(""sd_"", vars = colnames(mod.dat))
     re.cor <- tidyselect::starts_with(""cor_"", vars = colnames(mod.dat))
+    lp <- tidyselect::starts_with(""lp__"", vars = colnames(mod.dat))
 
-    brmsfit.removers <- unique(c(re.sd, re.cor))
+    brmsfit.removers <- unique(c(re.sd, re.cor, lp))
 
     if (!sjmisc::is_empty(brmsfit.removers))
       mod.dat <- dplyr::select(mod.dat, !! -brmsfit.removers)"
strengejacke,sjPlot,ca2f78ca6df111c4c6a630c40adc168891794368,Daniel,mail@danielluedecke.de,2018-01-12T17:40:01Z,Daniel,mail@danielluedecke.de,2018-01-12T17:40:01Z,"fix formatting in docs, prepare `tab_df()`",R/html_print.R;R/plot_model.R;man/plot_model.Rd,False,True,True,False,205,8,213,"---FILE: R/html_print.R---
@@ -0,0 +1,195 @@
+#' @importFrom sjmisc var_type is_even
+tab_df <- function(x, encoding = ""UTF-8"", CSS = NULL, ...) {
+  # init style sheet and tags used for css-definitions
+  # we can use these variables for string-replacement
+  # later for return value
+
+  tag.table <- ""table""
+  tag.caption <- ""caption""
+  tag.thead <- ""thead""
+  tag.tdata <- ""tdata""
+  tag.arc <- ""arc""
+  tag.comment <- ""comment""
+  tag.firsttablerow <- ""firsttablerow""
+  tag.lasttablerow <- ""lasttablerow""
+  tag.firsttablecol <- ""firsttablecol""
+  tag.leftalign <- ""leftalign""
+  tag.centertalign <- ""centertalign""
+  css.table <- ""border-collapse:collapse; border:none;""
+  css.caption <- ""font-weight: bold; text-align:left;""
+  css.thead <- ""border-top: double; text-align:center; font-style:italic; font-weight:normal; padding:0.2cm;""
+  css.tdata <- ""padding:0.2cm; text-align:left; vertical-align:top;""
+  css.arc <- ""background-color:#eaeaea;""
+  css.lasttablerow <- ""border-top:1px solid; border-bottom: double;""
+  css.firsttablerow <- ""border-bottom:1px solid black;""
+  css.firsttablecol <- """"
+  css.leftalign <- ""text-align:left;""
+  css.centeralign <- ""text-align:center;""
+  css.comment <- ""font-style:italic; border-top:double black; text-align:right;""
+  if (show.cmmn.row && repeat.header) css.comment <- ""font-style:italic; text-align:right;""
+
+
+  # check user defined style sheets
+
+  if (!is.null(CSS)) {
+    if (!is.null(CSS[['css.table']])) css.table <- ifelse(substring(CSS[['css.table']], 1, 1) == '+', paste0(css.table, substring(CSS[['css.table']], 2)), CSS[['css.table']])
+    if (!is.null(CSS[['css.caption']])) css.caption <- ifelse(substring(CSS[['css.caption']], 1, 1) == '+', paste0(css.caption, substring(CSS[['css.caption']], 2)), CSS[['css.caption']])
+    if (!is.null(CSS[['css.thead']])) css.thead <- ifelse(substring(CSS[['css.thead']], 1, 1) == '+', paste0(css.thead, substring(CSS[['css.thead']], 2)), CSS[['css.thead']])
+    if (!is.null(CSS[['css.tdata']])) css.tdata <- ifelse(substring(CSS[['css.tdata']], 1, 1) == '+', paste0(css.tdata, substring(CSS[['css.tdata']], 2)), CSS[['css.tdata']])
+    if (!is.null(CSS[['css.arc']])) css.arc <- ifelse(substring(CSS[['css.arc']], 1, 1) == '+', paste0(css.arc, substring(CSS[['css.arc']], 2)), CSS[['css.arc']])
+    if (!is.null(CSS[['css.lasttablerow']])) css.lasttablerow <- ifelse(substring(CSS[['css.lasttablerow']], 1, 1) == '+', paste0(css.lasttablerow, substring(CSS[['css.lasttablerow']], 2)), CSS[['css.lasttablerow']])
+    if (!is.null(CSS[['css.firsttablerow']])) css.firsttablerow <- ifelse(substring(CSS[['css.firsttablerow']], 1, 1) == '+', paste0(css.firsttablerow, substring(CSS[['css.firsttablerow']], 2)), CSS[['css.firsttablerow']])
+    if (!is.null(CSS[['css.leftalign']])) css.leftalign <- ifelse(substring(CSS[['css.leftalign']], 1, 1) == '+', paste0(css.leftalign, substring(CSS[['css.leftalign']], 2)), CSS[['css.leftalign']])
+    if (!is.null(CSS[['css.centeralign']])) css.centeralign <- ifelse(substring(CSS[['css.centeralign']], 1, 1) == '+', paste0(css.centeralign, substring(CSS[['css.centeralign']], 2)), CSS[['css.centeralign']])
+    if (!is.null(CSS[['css.firsttablecol']])) css.firsttablecol <- ifelse(substring(CSS[['css.firsttablecol']], 1, 1) == '+', paste0(css.firsttablecol, substring(CSS[['css.firsttablecol']], 2)), CSS[['css.firsttablecol']])
+    if (!is.null(CSS[['css.comment']])) css.comment <- ifelse(substring(CSS[['css.comment']], 1, 1) == '+', paste0(css.comment, substring(CSS[['css.comment']], 2)), CSS[['css.comment']])
+  }
+
+
+  # set style sheet
+
+  page.style <- sprintf(""<style>\nhtml, body { background-color: white; }\n%s { %s }\n%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n</style>"",
+                        tag.table, css.table, tag.caption, css.caption,
+                        tag.thead, css.thead, tag.tdata, css.tdata, tag.arc, css.arc,
+                        tag.lasttablerow, css.lasttablerow, tag.firsttablerow, css.firsttablerow,
+                        tag.leftalign, css.leftalign, tag.centertalign, css.centeralign,
+                        tag.firsttablecol, css.firsttablecol, tag.comment, css.comment)
+
+  # first, save table header
+  toWrite <- table.header <- sprintf(""<html>\n<head>\n<meta http-equiv=\""Content-type\"" content=\""text/html;charset=%s\"">\n"", encoding)
+
+  # then also set page-CSS-stylesheet
+  toWrite <- sprintf(""%s%s\n</head>\n<body>\n"", toWrite, page.style)
+
+  # get row and column count of data frame
+  rowcnt <- nrow(mydf)
+  colcnt <- ncol(mydf)
+
+  # start table tag
+  page.content <- ""<table>\n""
+
+  # table caption, variable label
+  if (!is.null(title)) page.content <- paste0(page.content, sprintf(""  <caption>%s</caption>\n"", title))
+
+  # header row
+  page.content <- paste0(page.content, ""  <tr>\n"")
+
+  # first columns are rownames
+  for (i in 1:colcnt) {
+    # check variable type
+    vartype <- sjmisc::var_type(mydf[[i]])
+    # column names and variable as table headline
+    page.content <- paste0(page.content, sprintf(""    <th class=\""thead firsttablerow\"">%s"", cnames[i]))
+    if (show.type) page.content <- paste0(page.content, sprintf(""<br>(%s)"", vartype))
+    page.content <- paste0(page.content, ""</th>\n"")
+  }
+  page.content <- paste0(page.content, ""  </tr>\n"")
+
+  # -------------------------------------
+  # subsequent rows
+  # -------------------------------------
+  for (rcnt in 1:rowcnt) {
+    # default row string
+    arcstring <- """"
+    # if we have alternating row colors, set css
+    if (altr.row.col) arcstring <- ifelse(sjmisc::is_even(rcnt), "" arc"", """")
+    page.content <- paste0(page.content, ""  <tr>\n"")
+    # first table cell is rowname
+    if (show.rownames) page.content <- paste0(page.content, sprintf(""    <td class=\""tdata leftalign firsttablecol%s\"">%s</td>\n"", arcstring, rnames[rcnt]))
+    # all columns of a row
+    for (ccnt in 1:colcnt) {
+      page.content <- paste0(page.content, sprintf(""    <td class=\""tdata centertalign%s\"">%s</td>\n"", arcstring, mydf[rcnt, ccnt]))
+    }
+    # close row tag
+    page.content <- paste0(page.content, ""</tr>\n"")
+  }
+  if (!hide.progress) close(pb)
+  # -------------------------------------
+  # repeat header row?
+  # -------------------------------------
+  if (repeat.header) {
+    page.content <- paste0(page.content, ""  <tr>\n"")
+    if (show.rownames) page.content <- paste0(page.content, sprintf(""    <th class=\""thead lasttablerow firsttablecol\"">%s</th>\n"", string.var))
+    for (i in 1:colcnt) {
+      # check variable type
+      vartype <- sjmisc::var_type(mydf[[i]])
+      # column names and variable as table headline
+      page.content <- paste0(page.content, sprintf(""    <th class=\""thead lasttablerow\"">%s"", cnames[i]))
+      if (show.type) page.content <- paste0(page.content, sprintf(""<br>(%s)"", vartype))
+      page.content <- paste0(page.content, ""</th>\n"")
+    }
+    page.content <- paste0(page.content, ""  </tr>\n"")
+  }
+  # -------------------------------------
+  # add optional ""comment"" row
+  # -------------------------------------
+  if (show.cmmn.row) {
+    page.content <- paste0(page.content, ""  <tr>\n"")
+    if (!show.rownames) colcnt <- colcnt - 1
+    page.content <- paste0(page.content, sprintf(""    <td colspan=\""%i\"" class=\""comment\"">%s</td>\n"", colcnt + 1, string.cmmn))
+    # close row tag
+    page.content <- paste0(page.content, ""</tr>\n"")
+  }
+  # -------------------------------------
+  # finish html page
+  # -------------------------------------
+  page.content <- paste0(page.content, ""</table>\n"")
+  toWrite <- paste0(toWrite, sprintf(""%s\n</body></html>"", page.content))
+  # -------------------------------------
+  # replace class attributes with inline style,
+  # useful for knitr
+  # -------------------------------------
+  # copy page content
+  # -------------------------------------
+  knitr <- page.content
+  # -------------------------------------
+  # set style attributes for main table tags
+  # -------------------------------------
+  knitr <- gsub(""class="", ""style="", knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(""<table"", sprintf(""<table style=\""%s\"""", css.table), knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(""<caption"", sprintf(""<caption style=\""%s\"""", css.caption), knitr, fixed = TRUE, useBytes = TRUE)
+  # -------------------------------------
+  # replace class-attributes with inline-style-definitions
+  # -------------------------------------
+  knitr <- gsub(tag.tdata, css.tdata, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.thead, css.thead, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.arc, css.arc, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.comment, css.comment, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.lasttablerow, css.lasttablerow, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.firsttablerow, css.firsttablerow, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.firsttablecol, css.firsttablecol, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.leftalign, css.leftalign, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.centertalign, css.centeralign, knitr, fixed = TRUE, useBytes = TRUE)
+  # -------------------------------------
+  # remove spaces?
+  # -------------------------------------
+  knitr <- rmspc(knitr)
+  toWrite <- rmspc(toWrite)
+  page.content <- rmspc(page.content)
+  # -------------------------------------
+  # return results
+  # -------------------------------------
+
+  structure(
+    class = c(""sjtatsTable""),
+    list(
+      page.style = page.style,
+      page.content = page.content,
+      output.complete = toWrite,
+      header = table.header,
+      knitr = knitr,
+      file = file,
+      show = !no.output,
+      use.viewer = use.viewer
+    )
+  )
+}
+
+
+rmspc <- function(html.table) {
+  cleaned <- gsub(""      <"", ""<"", html.table, fixed = TRUE, useBytes = TRUE)
+  cleaned <- gsub(""    <"", ""<"", cleaned, fixed = TRUE, useBytes = TRUE)
+  cleaned <- gsub(""  <"", ""<"", cleaned, fixed = TRUE, useBytes = TRUE)
+
+  cleaned
+}

---FILE: R/plot_model.R---
@@ -265,16 +265,16 @@
 #'   \code{\link[ggeffects]{ggpredict}}. } \item{\code{type = ""eff""}}{ Plots
 #'   marginal effects. Simply wraps \code{\link[ggeffects]{ggeffect}}. }
 #'   \item{\code{type = ""int""}}{ A shortcut for marginal effects plots, where
-#'   interaction terms are automatically detected and used as `terms`-argument.
+#'   interaction terms are automatically detected and used as \code{terms}-argument.
 #'   Furthermore, if the moderator variable (the second - and third - term in an
 #'   interaction) is continuous, \code{type = ""int""} automatically chooses
-#'   useful values based on the `mdrt.values`-argument, which are passed to
-#'   `terms`. Then, \code{\link[ggeffects]{ggpredict}} is called. \code{type =
+#'   useful values based on the \code{mdrt.values}-argument, which are passed to
+#'   \code{terms}. Then, \code{\link[ggeffects]{ggpredict}} is called. \code{type =
 #'   ""int""} plots the interaction term that appears first in the formula along
 #'   the x-axis, while the second (and possibly third) variable in an
 #'   interaction is used as grouping factor(s) (moderating variable). Use
 #'   \code{type = ""pred""} or \code{type = ""eff""} and specify a certain order in
-#'   the `terms`-argument to indicate which variable(s) should be used as
+#'   the \code{terms}-argument to indicate which variable(s) should be used as
 #'   moderator. } }
 #'
 #' @note \code{plot_model()} replaces the functions \code{sjp.lm},
@@ -329,6 +329,7 @@
 #' # identical to:
 #' # plot_model(m, type = ""pred"", terms = c(""c172code"", ""neg_c_7 [7,28]""))
 #' plot_model(m, type = ""int"")
+#'
 #' # switch moderator
 #' plot_model(m, type = ""pred"", terms = c(""neg_c_7"", ""c172code""))
 #' # same as

---FILE: man/plot_model.Rd---
@@ -330,16 +330,16 @@ Depending on the plot-type, \code{plot_model()} returns a
   \code{\link[ggeffects]{ggpredict}}. } \item{\code{type = ""eff""}}{ Plots
   marginal effects. Simply wraps \code{\link[ggeffects]{ggeffect}}. }
   \item{\code{type = ""int""}}{ A shortcut for marginal effects plots, where
-  interaction terms are automatically detected and used as `terms`-argument.
+  interaction terms are automatically detected and used as \code{terms}-argument.
   Furthermore, if the moderator variable (the second - and third - term in an
   interaction) is continuous, \code{type = ""int""} automatically chooses
-  useful values based on the `mdrt.values`-argument, which are passed to
-  `terms`. Then, \code{\link[ggeffects]{ggpredict}} is called. \code{type =
+  useful values based on the \code{mdrt.values}-argument, which are passed to
+  \code{terms}. Then, \code{\link[ggeffects]{ggpredict}} is called. \code{type =
   ""int""} plots the interaction term that appears first in the formula along
   the x-axis, while the second (and possibly third) variable in an
   interaction is used as grouping factor(s) (moderating variable). Use
   \code{type = ""pred""} or \code{type = ""eff""} and specify a certain order in
-  the `terms`-argument to indicate which variable(s) should be used as
+  the \code{terms}-argument to indicate which variable(s) should be used as
   moderator. } }
 }
 \note{
@@ -386,6 +386,7 @@ m <- glm(
 # identical to:
 # plot_model(m, type = ""pred"", terms = c(""c172code"", ""neg_c_7 [7,28]""))
 plot_model(m, type = ""int"")
+
 # switch moderator
 plot_model(m, type = ""pred"", terms = c(""neg_c_7"", ""c172code""))
 # same as"
strengejacke,sjPlot,d46b59f1907ee33d9cba93f4ad5141f3507958be,Daniel,mail@danielluedecke.de,2017-12-06T19:46:27Z,Daniel,mail@danielluedecke.de,2017-12-06T19:46:27Z,fix issue with view_df(),NEWS.md;R/sjTabDataFrame.R;R/sjTabSPSS.R;R/utils.R,False,True,True,False,28,9,37,"---FILE: NEWS.md---
@@ -16,6 +16,7 @@
 ## Bug fixes
 
 * `view_df()` did not work with double values (with decimal points) when `show.values = TRUE`.
+* `view_df()` caused an error when a variable has completely missing values.
 * `plot_models()` did not properly remove intercepts from output for survey models, when `show.intercept = FALSE`.
 * `plot_models()` did not automatically transform axis for all applicable model types.
 * `get_model_data()` did not work for marginal effects plots.

---FILE: R/sjTabDataFrame.R---
@@ -93,7 +93,7 @@
 #'
 #' @importFrom utils txtProgressBar setTxtProgressBar
 #' @importFrom psych describe
-#' @importFrom sjmisc var_type
+#' @importFrom sjmisc var_type is_even
 #' @export
 sjt.df <- function(mydf,
                    describe = TRUE,

---FILE: R/sjTabSPSS.R---
@@ -77,6 +77,7 @@
 #' @importFrom utils txtProgressBar setTxtProgressBar
 #' @importFrom sjmisc is_even var_type is_float
 #' @importFrom sjlabelled get_values
+#' @importFrom purrr map_lgl
 #' @export
 view_df <- function(x,
                     weight.by = NULL,
@@ -108,16 +109,32 @@ view_df <- function(x,
   # unique handling for the data
   if (!is.data.frame(x)) stop(""Parameter needs to be a data frame!"", call. = FALSE)
 
+  # save name of object
+  dfname <- deparse(substitute(x))
+
+  # variables with all missings?
+  all.na <- purrr::map_lgl(x, ~ all(is.na(.x)))
+  id <- seq_len(ncol(x))
+  cnames <- colnames(x)
+
+  # do we have any ""all-missing-variables""?
+  if (any(all.na)) {
+    rem.col <- seq_len(ncol(x))[all.na]
+
+    message(sprintf(""Following %i variables have only missing values and are not shown:"", sum(all.na)))
+    cat(paste(sprintf(""%s [%i]"", cnames[all.na], rem.col), collapse = "", ""))
+    cat(""\n"")
+
+    id <- id[!all.na]
+    cnames <- cnames[!all.na]
+  }
+
   # retrieve value and variable labels
   df.var <- sjlabelled::get_label(x)
   df.val <- sjlabelled::get_labels(x)
 
-  # get row count and ID's
-  colcnt <- ncol(x)
-  id <- seq_len(colcnt)
-
   # Order data set if requested
-  if (sort.by.name) id <- id[order(colnames(x))]
+  if (sort.by.name) id <- id[order(cnames)]
 
   # init style sheet and tags used for css-definitions
   # we can use these variables for string-replacement
@@ -154,7 +171,7 @@ view_df <- function(x,
   toWrite <- sprintf(""<html>\n<head>\n<meta http-equiv=\""Content-type\"" content=\""text/html;charset=%s\"">\n%s\n</head>\n<body>\n"", encoding, page.style)
 
   # table caption, data frame name
-  page.content <- sprintf(""<table>\n  <caption>Data frame: %s</caption>\n"", deparse(substitute(x)))
+  page.content <- sprintf(""<table>\n  <caption>Data frame: %s</caption>\n"", dfname)
 
   # header row
   page.content <- paste0(page.content, ""  <tr>\n    "")
@@ -172,10 +189,10 @@ view_df <- function(x,
   page.content <- paste0(page.content, ""\n  </tr>\n"")
 
   # create progress bar
-  if (!hide.progress) pb <- utils::txtProgressBar(min = 0, max = colcnt, style = 3)
+  if (!hide.progress) pb <- utils::txtProgressBar(min = 0, max = length(id), style = 3)
 
   # subsequent rows
-  for (ccnt in seq_len(colcnt)) {
+  for (ccnt in 1:length(id)) {
     # get index number, depending on sorting
     index <- id[ccnt]
     # default row string

---FILE: R/utils.R---
@@ -87,6 +87,7 @@ get_estimate_axis_title <- function(fit, axis.title, type, transform = NULL) {
 
     axis.title <-  dplyr::case_when(
       !is.null(transform) && transform == ""plogis"" ~ ""Probabilities"",
+      is.null(transform) && fitfam$is_bin ~ ""Log-Odds"",
       fitfam$is_pois ~ ""Incidence Rate Ratios"",
       fitfam$is_bin && !fitfam$is_logit ~ ""Risk Ratios"",
       fitfam$is_bin ~ ""Odds Ratios"","
strengejacke,sjPlot,0cdbdf83f86aa67378f05d9123c0fb32ce40f036,Daniel,mail@danielluedecke.de,2017-10-18T20:30:04Z,Daniel,mail@danielluedecke.de,2017-10-18T20:30:04Z,fix (CRAN check) issues,DESCRIPTION;R/plot_type_eff.R;man/plot_model.Rd;man/plot_models.Rd,False,True,True,False,7,1,8,"---FILE: DESCRIPTION---
@@ -62,7 +62,8 @@ Suggests:
     lmerTest,
     lmtest,
     rstanarm,
-    survey
+    survey,
+    wesanderson
 URL: https://github.com/strengejacke/sjPlot
 BugReports: https://github.com/strengejacke/sjPlot/issues
 RoxygenNote: 6.0.1

---FILE: R/plot_type_eff.R---
@@ -30,6 +30,9 @@ plot_type_eff <- function(type,
     )
   }
 
+  # select color palette
+  geom.colors <- col_check2(geom.colors, dplyr::n_distinct(dat$group))
+
   p <- graphics::plot(
     dat,
     ci = !is.na(ci.lvl),

---FILE: man/plot_model.Rd---
@@ -175,6 +175,7 @@ are valid for the \code{colors} argument:
   \item If \code{""gs""}, a greyscale will be used.
   \item If \code{""bw""}, and plot-type is a line-plot, the plot is black/white and uses different line types to distinguish groups (see \href{../doc/blackwhitefigures.html}{this package-vignette}).
   \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
+  \item If \pkg{wesanderson} is installed, you may also specify a name of a palette from that package.
   \item Else specify own color values or names as vector (e.g. \code{colors = ""#00ff00""}).
 }}
 

---FILE: man/plot_models.Rd---
@@ -107,6 +107,7 @@ are valid for the \code{colors} argument:
   \item If \code{""gs""}, a greyscale will be used.
   \item If \code{""bw""}, and plot-type is a line-plot, the plot is black/white and uses different line types to distinguish groups (see \href{../doc/blackwhitefigures.html}{this package-vignette}).
   \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
+  \item If \pkg{wesanderson} is installed, you may also specify a name of a palette from that package.
   \item Else specify own color values or names as vector (e.g. \code{colors = ""#00ff00""}).
 }}
 "
strengejacke,sjPlot,cce11ac5b042c0e5aa2c5b148189fc1c1a505920,Daniel,mail@danielluedecke.de,2017-10-18T20:17:22Z,Daniel,mail@danielluedecke.de,2017-10-18T20:17:22Z,fix CRAN check issues,DESCRIPTION;R/color_utils.R;R/plot_model.R;R/sjPlotFrequencies.R;R/sjPlotKfoldCV.R;R/sjPlotPolynomials.R;R/sjTabLinReg.R;R/sjTabOdds.R;man/sjp.frq.Rd,False,True,True,False,31,6,37,"---FILE: DESCRIPTION---
@@ -22,7 +22,6 @@ Depends:
     R (>= 3.2),
     graphics,
     grDevices,
-    methods,
     stats,
     utils
 Imports:

---FILE: R/color_utils.R---
@@ -10,6 +10,8 @@ col_check2 <- function(geom.colors, collen) {
       geom.colors <- scales::brewer_pal(palette = geom.colors[1])(collen)
     } else if (is.sjplot.pal(geom.colors[1])) {
       geom.colors <- get_sjplot_colorpalette(geom.colors[1], collen)
+    } else if (is.wes.pal(geom.colors[1])) {
+      geom.colors <- get_wesanderson_colorpalette(geom.colors[1], collen)
     } else if (geom.colors[1] == ""gs"") {
       geom.colors <- scales::grey_pal()(collen)
       # do we have correct amount of colours?
@@ -53,11 +55,28 @@ is.sjplot.pal <- function(pal) {
 }
 
 
+is.wes.pal <- function(pal) {
+  pal %in% c(""GrandBudapest"", ""Moonrise1"", ""Royal1"", ""Moonrise2"", ""Cavalcanti"", ""Royal2"",
+             ""GrandBudapest2"", ""Moonrise3"", ""Chevalier"", ""Zissou"", ""FantasticFox"",
+             ""Darjeeling"", ""Rushmore"", ""BottleRocket"", ""Darjeeling2"")
+}
+
+
+get_wesanderson_colorpalette <- function(pal, len) {
+  if (!requireNamespace(""wesanderson"", quietly = TRUE)) {
+    warning(""Package `wesanderson` required for this color palette."", call. = F)
+    return(NULL)
+  }
+
+  wesanderson::wes_palette(name = pal, n = len)
+}
+
+
 get_sjplot_colorpalette <- function(pal, len) {
   col <- NULL
 
   if (pal == ""random"")
-    pal <- sample(c(""aqua"", ""warm"", ""dust"", ""blambus""), size = 1)
+    pal <- sample(c(""aqua"", ""warm"", ""dust"", ""blambus"", ""simply"", ""us""), size = 1)
 
   if (pal == ""aqua"")
     col <- c(""#BAF5F3"", ""#46A9BE"", ""#8B7B88"", ""#BD7688"", ""#F2C29E"", ""#BAF5F3"", ""#46A9BE"", ""#8B7B88"")
@@ -67,6 +86,10 @@ get_sjplot_colorpalette <- function(pal, len) {
     col <- c(""#AAAE9D"", ""#F8F7CF"", ""#F7B98B"", ""#7B5756"", ""#232126"", ""#AAAE9D"", ""#F8F7CF"", ""#F7B98B"")
   else if (pal == ""blambus"")
     col <- c(""#5D8191"", ""#F2DD26"", ""#494949"", ""#BD772D"", ""#E02E1F"", ""#5D8191"", ""#F2DD26"", ""#494949"")
+  else if (pal == ""simply"")
+    col <- c(""#CD423F"", ""#FCDA3B"", ""#0171D3"", ""#018F77"", ""#F5C6AC"", ""#CD423F"", ""#FCDA3B"", ""#0171D3"")
+  else if (pal == ""us"")
+    col <- c(""#004D80"", ""#376C8E"", ""#37848E"", ""#9BC2B6"", ""#B5D2C0"", ""#004D80"", ""#376C8E"", ""#37848E"")
 
   if (len > length(col)) {
     warning(""More colors requested than length of color palette."", call. = F)

---FILE: R/plot_model.R---
@@ -143,6 +143,7 @@
 #'      \item If \code{""gs""}, a greyscale will be used.
 #'      \item If \code{""bw""}, and plot-type is a line-plot, the plot is black/white and uses different line types to distinguish groups (see \href{../doc/blackwhitefigures.html}{this package-vignette}).
 #'      \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
+#'      \item If \pkg{wesanderson} is installed, you may also specify a name of a palette from that package.
 #'      \item Else specify own color values or names as vector (e.g. \code{colors = ""#00ff00""}).
 #'    }
 #' @param grid Logical, if \code{TRUE}, multiple plots are plotted as grid layout.

---FILE: R/sjPlotFrequencies.R---
@@ -75,6 +75,7 @@ utils::globalVariables(c(""val"", ""frq"", ""grp"", ""label.pos"", ""upper.ci"", ""lower.ci
 #' # bar plot
 #' sjp.frq(efc$e42dep)
 #'
+#' library(sjmisc)
 #' # grouped variable
 #' ageGrp <- group_var(efc$e17age)
 #' ageGrpLab <- group_labels(efc$e17age)

---FILE: R/sjPlotKfoldCV.R---
@@ -1,5 +1,5 @@
 # bind global variables
-utils::globalVariables(c(""train"", ""model"", ""test"", "".response"", ""sse"", ""sst""))
+utils::globalVariables(c(""train"", ""model"", ""test"", ""predicted"", "".response"", ""sse"", ""sst""))
 
 #' @title Plot model fit from k-fold cross-validation
 #' @name sjp.kfold_cv

---FILE: R/sjPlotPolynomials.R---
@@ -124,7 +124,7 @@ sjp.poly <- function(x,
   # --------------------------------------------
   # parameter check: fitted model or variables?
   # --------------------------------------------
-  mf <- sjstats::model_frame(x)
+  if (!is.vector(x) && !is.numeric(x) && !is.factor(x)) mf <- sjstats::model_frame(x)
 
   if (is_merMod(x)) {
     # retrieve response vector

---FILE: R/sjTabLinReg.R---
@@ -1176,7 +1176,7 @@ sjt.lm <- function(...,
     # -------------------------------------
     if (lmerob && length(input_list) > 1) {
       # check whether we have mixed models fitted with REML
-      models.reml <- vapply(input_list, function(x) is(x, ""merMod"") && lme4::isREML(x), NA)
+      models.reml <- purrr::map_lgl(input_list, ~ is_merMod(.x) && lme4::isREML(.x))
       if (any(models.reml)) warning(""Some models were fit with REML. To get meaningful AIC values for comparison, refit models with ML (`REML = FALSE`)."", call. = F)
     }
     page.content <- paste(page.content, ""  <tr>\n     <td class=\""tdata leftalign summary\"">AIC</td>\n"")

---FILE: R/sjTabOdds.R---
@@ -961,7 +961,7 @@ sjt.glm <- function(...,
     # -------------------------------------
     if (lmerob && length(input_list) > 1) {
       # check whether we have mixed models fitted with REML
-      models.reml <- vapply(input_list, function(x) is(x, ""merMod"") && lme4::isREML(x), NA)
+      models.reml <- purrr::map_lgl(input_list, ~ is_merMod(.x) && lme4::isREML(.x))
       if (any(models.reml)) warning(""Some models were fit with REML. To get meaningful AIC values for comparison, refit models with ML (`REML = FALSE`)."", call. = F)
     }
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">AIC</td>"")

---FILE: man/sjp.frq.Rd---
@@ -206,6 +206,7 @@ sjp.frq(efc$e17age, type = ""v"")
 # bar plot
 sjp.frq(efc$e42dep)
 
+library(sjmisc)
 # grouped variable
 ageGrp <- group_var(efc$e17age)
 ageGrpLab <- group_labels(efc$e17age)"
strengejacke,sjPlot,f67b2439797ea64fc0ad5b641ace41100d7620b6,Daniel,mail@danielluedecke.de,2017-10-18T19:20:35Z,Daniel,mail@danielluedecke.de,2017-10-18T19:20:35Z,"close #215, many minor fixes/improvements, finish interaction-plot-type",NAMESPACE;NEWS.md;R/color_utils.R;R/helpfunctions.R;R/plot_diag_linear.R;R/plot_grid.R;R/plot_model.R;R/plot_type_int.R;R/plot_type_ranef.R;R/sjPlotAnova.R;R/sjPlotFA.R;R/sjPlotFrequencies.R;R/sjPlotGroupFrequencies.R;R/sjPlotGroupPropTable.R;R/sjPlotKfoldCV.R;R/sjPlotLikert.R;R/sjTabPropTable.R;R/sjTabSPSS.R;R/sjTabStackFrq.R;R/sjplot.R;R/utils.R;man/plot_grid.Rd;man/plot_model.Rd;man/plot_models.Rd;man/sjp.aov1.Rd;man/sjp.fa.Rd;man/sjp.frq.Rd;man/sjp.gpt.Rd;man/sjp.grpfrq.Rd;man/sjp.kfold_cv.Rd;man/sjp.likert.Rd;man/sjplot.Rd;man/sjt.stackfrq.Rd;man/sjt.xtab.Rd;man/view_df.Rd;vignettes/plot_model_estimates.Rmd,True,True,True,False,420,191,611,"---FILE: NAMESPACE---
@@ -129,8 +129,10 @@ importFrom(psych,principal)
 importFrom(purrr,map)
 importFrom(purrr,map2)
 importFrom(purrr,map2_df)
+importFrom(purrr,map_chr)
 importFrom(purrr,map_dbl)
 importFrom(purrr,map_df)
+importFrom(purrr,map_lgl)
 importFrom(rlang,.data)
 importFrom(scales,brewer_pal)
 importFrom(scales,grey_pal)

---FILE: NEWS.md---
@@ -14,7 +14,7 @@
 
 * `view_df()` now better handles string variables and gets a `show.string.values`-argument to omit the output of values from string variables.
 * `view_df()` gets a `max.len`-argument to truncate output for variables with many values.
-* `view_df()` displayes more information on non-labelled, numeric variables.
+* `view_df()` displays more information on non-labelled, numeric variables.
 * `sjp.pca()` and `sjt.pca()` now give more informative error messages when just one component is extracted.
 
 ## Bug fixes

---FILE: R/color_utils.R---
@@ -0,0 +1,77 @@
+#' @importFrom scales brewer_pal grey_pal
+col_check2 <- function(geom.colors, collen) {
+  # --------------------------------------------
+  # check color argument
+  # --------------------------------------------
+  # check for corrct color argument
+  if (!is.null(geom.colors)) {
+    # check for color brewer palette
+    if (is.brewer.pal(geom.colors[1])) {
+      geom.colors <- scales::brewer_pal(palette = geom.colors[1])(collen)
+    } else if (is.sjplot.pal(geom.colors[1])) {
+      geom.colors <- get_sjplot_colorpalette(geom.colors[1], collen)
+    } else if (geom.colors[1] == ""gs"") {
+      geom.colors <- scales::grey_pal()(collen)
+      # do we have correct amount of colours?
+    } else if (geom.colors[1] == ""bw"") {
+      geom.colors <- rep(""black"", times = collen)
+      # do we have correct amount of colours?
+    } else if (length(geom.colors) > collen) {
+      # shorten palette
+      geom.colors <- geom.colors[1:collen]
+    } else if (length(geom.colors) < collen) {
+      # repeat color palette
+      geom.colors <- rep(geom.colors, times = collen)
+      # shorten to required length
+      geom.colors <- geom.colors[1:collen]
+    }
+  } else {
+    geom.colors <- scales::brewer_pal(palette = ""Set1"")(collen)
+  }
+
+  geom.colors
+}
+
+
+# check whether a color value is indicating
+# a color brewer palette
+is.brewer.pal <- function(pal) {
+  bp.seq <- c(""BuGn"", ""BuPu"", ""GnBu"", ""OrRd"", ""PuBu"", ""PuBuGn"", ""PuRd"", ""RdPu"",
+              ""YlGn"", ""YlGnBu"", ""YlOrBr"", ""YlOrRd"", ""Blues"", ""Greens"", ""Greys"",
+              ""Oranges"", ""Purples"", ""Reds"")
+  bp.div <- c(""BrBG"", ""PiYG"", ""PRGn"", ""PuOr"", ""RdBu"", ""RdGy"", ""RdYlBu"",
+              ""RdYlGn"", ""Spectral"")
+  bp.qul <- c(""Accent"", ""Dark2"", ""Paired"", ""Pastel1"", ""Pastel2"", ""Set1"",
+              ""Set2"", ""Set3"")
+  bp <- c(bp.seq, bp.div, bp.qul)
+  pal %in% bp
+}
+
+
+is.sjplot.pal <- function(pal) {
+  pal %in% c(""aqua"", ""warm"", ""dust"", ""blambus"", ""random"")
+}
+
+
+get_sjplot_colorpalette <- function(pal, len) {
+  col <- NULL
+
+  if (pal == ""random"")
+    pal <- sample(c(""aqua"", ""warm"", ""dust"", ""blambus""), size = 1)
+
+  if (pal == ""aqua"")
+    col <- c(""#BAF5F3"", ""#46A9BE"", ""#8B7B88"", ""#BD7688"", ""#F2C29E"", ""#BAF5F3"", ""#46A9BE"", ""#8B7B88"")
+  else if (pal == ""warm"")
+    col <- c(""#F8EB85"", ""#F1B749"", ""#C45B46"", ""#664458"", ""#072835"", ""#F8EB85"", ""#F1B749"", ""#C45B46"")
+  else if (pal == ""dust"")
+    col <- c(""#AAAE9D"", ""#F8F7CF"", ""#F7B98B"", ""#7B5756"", ""#232126"", ""#AAAE9D"", ""#F8F7CF"", ""#F7B98B"")
+  else if (pal == ""blambus"")
+    col <- c(""#5D8191"", ""#F2DD26"", ""#494949"", ""#BD772D"", ""#E02E1F"", ""#5D8191"", ""#F2DD26"", ""#494949"")
+
+  if (len > length(col)) {
+    warning(""More colors requested than length of color palette."", call. = F)
+    len <- length(col)
+  }
+
+  col[1:len]
+}

---FILE: R/helpfunctions.R---
@@ -433,21 +433,6 @@ get.encoding <- function(encoding, data = NULL) {
 }
 
 
-# check whether a color value is indicating
-# a color brewer palette
-is.brewer.pal <- function(pal) {
-  bp.seq <- c(""BuGn"", ""BuPu"", ""GnBu"", ""OrRd"", ""PuBu"", ""PuBuGn"", ""PuRd"", ""RdPu"",
-              ""YlGn"", ""YlGnBu"", ""YlOrBr"", ""YlOrRd"", ""Blues"", ""Greens"", ""Greys"",
-              ""Oranges"", ""Purples"", ""Reds"")
-  bp.div <- c(""BrBG"", ""PiYG"", ""PRGn"", ""PuOr"", ""RdBu"", ""RdGy"", ""RdYlBu"",
-              ""RdYlGn"", ""Spectral"")
-  bp.qul <- c(""Accent"", ""Dark2"", ""Paired"", ""Pastel1"", ""Pastel2"", ""Set1"",
-              ""Set2"", ""Set3"")
-  bp <- c(bp.seq, bp.div, bp.qul)
-  pal %in% bp
-}
-
-
 # Calculate statistics of cross tabs
 #' @importFrom stats chisq.test fisher.test xtabs
 crosstabsum <- function(x, grp, weight.by) {
@@ -626,11 +611,6 @@ retrieveModelGroupIndices <- function(models, rem_rows = NULL) {
 }
 
 
-is_merMod <- function(fit) {
-  return(inherits(fit, c(""lmerMod"", ""glmerMod"", ""nlmerMod"", ""merModLmerTest"")))
-}
-
-
 # automatically retrieve predictor labels
 # of fitted (g)lm
 #' @importFrom stats formula terms
@@ -847,14 +827,3 @@ sju.rmspc <- function(html.table) {
   cleaned <- gsub(""  <"", ""<"", cleaned, fixed = TRUE, useBytes = TRUE)
   return(cleaned)
 }
-
-
-get_p_stars <- function(pval) {
-  dplyr::case_when(
-    is.na(pval) ~ """",
-    pval < 0.001 ~ ""***"",
-    pval < 0.01 ~ ""**"",
-    pval < 0.05 ~ ""*"",
-    TRUE ~ """"
-  )
-}

---FILE: R/plot_diag_linear.R---
@@ -0,0 +1,155 @@
+plot_diag_linear <- function(model,
+                             geom.colors,
+                             ...) {
+  plot.list <- list()
+  geom.colors <- col_check2(geom.colors, 2)
+
+  p <- diag_vif(model)
+  if (!is.null(p)) plot.list[[length(plot.list) + 1]] <- p
+
+  p <- diag_qq(model, geom.colors)
+  if (!is.null(p)) plot.list[[length(plot.list) + 1]] <- p
+
+  p <- diag_norm(model, geom.colors)
+  if (!is.null(p)) plot.list[[length(plot.list) + 1]] <- p
+
+  p <- diag_ncv(model)
+  if (!is.null(p)) plot.list[[length(plot.list) + 1]] <- p
+
+  plot.list
+}
+
+
+#' @importFrom tibble tibble
+#' @importFrom stats residuals fitted
+diag_ncv <- function(model) {
+  dat <- tibble::tibble(
+    res = stats::residuals(model),
+    fitted = stats::fitted(model)
+  )
+
+  ggplot(dat, aes_string(x = ""fitted"", y = ""res"")) +
+    geom_hline(yintercept = 0, alpha = 0.7) +
+    geom_point() +
+    geom_smooth(method = ""loess"", se = FALSE) +
+    labs(
+      x = ""Fitted values"",
+      y = ""Residuals"",
+      title = ""Homoscedasticity (constant variance of residuals)"",
+      subtitle = ""Amount and distance of points scattered above/below line is equal or randomly spread""
+    )
+}
+
+
+#' @importFrom rlang .data
+#' @importFrom tibble tibble
+#' @importFrom stats residuals sd
+diag_norm <- function(model, geom.colors) {
+  res_ <- tibble::tibble(res = stats::residuals(model))
+
+  ggplot(res_, aes_string(x = ""res"")) +
+    geom_density(fill = geom.colors[1], alpha = 0.2) +
+    stat_function(
+      fun = dnorm,
+      args = list(
+        mean = mean(unname(stats::residuals(model)), na.rm = TRUE),
+        sd = stats::sd(unname(stats::residuals(model)), na.rm = TRUE)
+      ),
+      colour = geom.colors[2],
+      size = 0.8
+    ) +
+    labs(
+      x = ""Residuals"",
+      y = ""Density"",
+      title = ""Non-normality of residuals"",
+      subtitle = ""Distribution should look like normal curve""
+    )
+}
+
+
+#' @importFrom stats residuals rstudent fitted
+diag_qq <- function(model, geom.colors) {
+  # qq-plot of studentized residuals for base model
+  # mixed model model?
+  if (inherits(model, c(""lme"", ""lmerMod""))) {
+    res_ <- sort(stats::residuals(model), na.last = NA)
+    y_lab <- ""Residuals""
+  } else {
+    # else, normal model
+    res_ <- sort(stats::rstudent(model), na.last = NA)
+    y_lab <- ""Studentized Residuals""
+  }
+
+  fitted_ <- sort(stats::fitted(model), na.last = NA)
+
+  # create data frame
+  mydf <- na.omit(data.frame(x = fitted_, y = res_))
+
+  # plot it
+  ggplot(mydf, aes_string(x = ""x"", y = ""y"")) +
+    geom_point() +
+    scale_colour_manual(values = geom.colors) +
+    stat_smooth(method = ""lm"", se = FALSE) +
+    labs(
+      title = ""Non-normality of residuals and outliers"",
+      subtitle = ""Dots should be plotted along the line"",
+      y = y_lab,
+      x = ""Theoretical quantiles (predicted values)""
+    )
+}
+
+
+#' @importFrom stats coef
+#' @importFrom tibble rownames_to_column
+diag_vif <- function(fit) {
+
+  if (is_merMod(fit) || inherits(fit, ""lme""))
+    return(NULL)
+
+  if (!requireNamespace(""car"", quietly = TRUE))
+    stop(""Package `car` needed for this function to work. Please install it."", call. = F)
+
+  vifplot <- NULL
+
+  # check if we have more than 1 term
+
+  if (length(stats::coef(fit)) > 2) {
+
+    # variance inflation factor
+    # claculate VIF
+
+    vifval <- car::vif(fit)
+
+    if (is.matrix(vifval)) {
+      val <- vifval[, 1]
+    } else {
+      val <- vifval
+    }
+
+    # retrieve highest VIF-value to determine y-axis range
+    maxval <- val[which.max(val)]
+
+    # determine upper limit of y-axis
+    upperLimit <- 10
+
+    # check whether maxval exceeds the critical VIF-Limit
+    # of 10. If so, set upper limit to max. value
+
+    if (maxval >= upperLimit) upperLimit <- ceiling(maxval)
+
+    mydat <- data.frame(vif = round(val, 2)) %>%
+      tibble::rownames_to_column(var = ""vars"")
+
+
+    vifplot <- ggplot(mydat, aes_string(x = ""vars"", y = ""vif"")) +
+      geom_bar(stat = ""identity"", width = 0.7, fill = ""#80acc8"") +
+      geom_hline(yintercept = 5, linetype = 2, colour = ""darkgreen"", alpha = 0.7) +
+      geom_hline(yintercept = 10, linetype = 2, colour = ""darkred"", alpha = 0.7) +
+      annotate(""text"", x = 1, y = 4.7, label = ""good"", size = 4, colour = ""darkgreen"") +
+      annotate(""text"", x = 1, y = 9.7, label = ""tolerable"", size = 4, colour = ""darkred"") +
+      labs(title = ""Variance Inflation Factors (multicollinearity)"", x = NULL, y = NULL) +
+      scale_y_continuous(limits = c(0, upperLimit), expand = c(0, 0))
+  }
+
+  vifplot
+}

---FILE: R/plot_grid.R---
@@ -16,7 +16,6 @@
 #'          To arrange these plots as grid as a single plot, use \code{plot_grid}.
 #'
 #' @examples
-#' library(sjmisc)
 #' data(efc)
 #' # fit model
 #' fit <- lm(tot_sc_e ~ c12hour + e17age + e42dep + neg_c_7, data = efc)

---FILE: R/plot_model.R---
@@ -8,7 +8,7 @@
 #'    kinds of models are supported, e.g. from packages like \pkg{stats},
 #'    \pkg{lme4}, \pkg{nlme}, \pkg{rstanarm}, \pkg{survey}, \pkg{glmmTMB},
 #'    \pkg{MASS}, \pkg{brms} etc.
-#' @param type Type of plot. There are three higher groups of plot-tyes:
+#' @param type Type of plot. There are three groups of plot-types:
 #'    \cr \cr
 #'    \emph{Coefficients}
 #'    \describe{
@@ -25,14 +25,14 @@
 #'    }
 #'    \emph{Model diagnostics}
 #'    \describe{
-#'      \item{\code{type = ""slope""}}{slope of coefficients for each single predictor, against the response (linear relationship between each model term and response).}
-#'      \item{\code{type = ""resid""}}{slope of coefficients for each single predictor, against the residuals (linear relationship between each model term and residuals).}
+#'      \item{\code{type = ""slope""}}{Slope of coefficients for each single predictor, against the response (linear relationship between each model term and response).}
+#'      \item{\code{type = ""resid""}}{Slope of coefficients for each single predictor, against the residuals (linear relationship between each model term and residuals).}
 #'      \item{\code{type = ""diag""}}{Check model assumptions.}
 #'    }
 #' @param transform A character vector, naming a function that will be applied
 #'    on estimates and confidence intervals. By default, \code{transform} will
 #'    automatically use \code{""exp""} as transformation for applicable classes
-#'    of \code{fit} (e.g. logistic or poisson regression). Estimates of linear
+#'    of \code{model} (e.g. logistic or poisson regression). Estimates of linear
 #'    models remain untransformed. Use \code{NULL} if you want the raw, non-transformed
 #'    estimates.
 #' @param terms Character vector with the names of those terms from \code{model}
@@ -47,7 +47,8 @@
 #'        should be displayed. At least one term is required to calculate
 #'        effects, maximum length is three terms, where the second and
 #'        third term indicate the groups, i.e. predictions of first term
-#'        are grouped by the levels of the second (and third) term.
+#'        are grouped by the levels of the second (and third) term. \code{terms}
+#'        may also indicate higher order terms (e.g. interaction terms).
 #'        Indicating levels in square brackets allows for selecting only
 #'        specific groups. Term name and levels in brackets must be separated
 #'        by a whitespace character, e.g. \code{terms = c(""age"", ""education [1,3]"")}.
@@ -65,8 +66,7 @@
 #'    be removed from the plot. Counterpart to \code{terms}.
 #'    \code{rm.terms = ""t_name""} would remove the term \emph{t_name}.
 #'    Default is \code{NULL}, i.e. all terms are used. Note that this
-#'    argument does not apply to \code{type = ""eff""}, \code{type = ""pred""}
-#'    or \code{type = ""int""}.
+#'    argument does not apply to \emph{Marginal Effects} plots.
 #' @param group.terms Numeric vector with group indices, to group coefficients.
 #'    Each group of coefficients gets its own color (see 'Examples').
 #' @param order.terms Numeric vector, indicating in which order the coefficients
@@ -77,19 +77,19 @@
 #'    conditioned on random effects (\code{pred.type = ""re""}) or fixed effects
 #'    only (\code{pred.type = ""fe""}, the default).
 #' @param mdrt.values Indicates which values of the moderator variable should be
-#'    used when plotting the interaction effects.
+#'    used when plotting interaction terms (i.e. \code{type = ""int""}).
 #'    \describe{
 #'      \item{\code{""minmax""}}{(default) minimum and maximum values (lower and upper bounds) of the moderator are used to plot the interaction between independent variable and moderator(s).}
 #'      \item{\code{""meansd""}}{uses the mean value of the moderator as well as one standard deviation below and above mean value to plot the effect of the moderator on the independent variable (following the convention suggested by Cohen and Cohen and popularized by Aiken and West, i.e. using the mean, the value one standard deviation above, and the value one standard deviation below the mean as values of the moderator, see \href{http://www.theanalysisfactor.com/3-tips-interpreting-moderation/}{Grace-Martin K: 3 Tips to Make Interpreting Moderation Effects Easier}).}
 #'      \item{\code{""zeromax""}}{is similar to the \code{""minmax""} option, however, \code{0} is always used as minimum value for the moderator. This may be useful for predictors that don't have an empirical zero-value, but absence of moderation should be simulated by using 0 as minimum.}
 #'      \item{\code{""quart""}}{calculates and uses the quartiles (lower, median and upper) of the moderator value.}
 #'      \item{\code{""all""}}{uses all values of the moderator variable.}
 #'    }
-#' @param ri.nr Numeric vector. If \code{type = ""re""} or \code{type = ""ri.slope""},
-#'    and fitted model has more than one random intercept, \code{ri.nr} indicates
-#'    which random effects of which random intercept (or: which list elements
-#'    of \code{\link[lme4]{ranef}}) will be plotted. Default is \code{NULL},
-#'    so all random effects will be plotted.
+#' @param ri.nr Numeric vector. If \code{type = ""re""} and fitted model has more
+#'    than one random intercept, \code{ri.nr} indicates which random effects of
+#'    which random intercept (or: which list elements of \code{\link[lme4]{ranef}})
+#'    will be plotted. Default is \code{NULL}, so all random effects will be
+#'    plotted.
 #' @param title Character vector, used as plot title. By default,
 #'    \code{\link[sjlabelled]{get_dv_labels}} is called to retrieve the
 #'    label of the dependent variable, which will be used as title. Use
@@ -105,7 +105,7 @@
 #'    axis labels. By default, \code{\link[sjlabelled]{get_term_labels}} is
 #'    called to retrieve the labels of the coefficients, which will be used as
 #'    axis labels. Use \code{axis.labels = """"} or \code{auto.label = FALSE}
-#'    to use the bare term names as labels instead.
+#'    to use the variable names as labels instead.
 #' @param axis.lim Numeric vector of length 2, defining the range of the plot
 #'    axis. Depending on plot-type, may effect either x- or y-axis. For
 #'    \emph{Marginal Effects} plots, \code{axis.lim} may also be a list of two
@@ -135,7 +135,7 @@
 #' @param dot.size Numeric, size of the dots that indicate the point estimates.
 #' @param line.size Numeric, size of the lines that indicate the error bars.
 #' @param colors May be a character vector of color values in hex-format, valid
-#'    color value names (see \code{demo(""colors"")} or a name of a
+#'    color value names (see \code{demo(""colors"")}) or a name of a
 #'    \href{http://colorbrewer2.org}{color brewer} palette. Following options
 #'    are valid for the \code{colors} argument:
 #'    \itemize{
@@ -190,14 +190,14 @@
 #'        outer probability).
 #'      }
 #'      \item{\code{size.inner}}{
-#'        For \strong{Stan}-models and coefficients plot-types, you
+#'        For \strong{Stan}-models and \emph{Coefficients} plot-types, you
 #'        can specify the width of the bar for the inner probabilities.
 #'        Default is \code{0.1}.
 #'      }
 #'      \item{\code{width}, \code{alpha} and \code{scale}}{
 #'        Passed down to \code{geom_errorbar()} or \code{geom_density_ridges()},
 #'        for forest or diagnostic plots; or passed down to
-#'        \code{\link[ggeffects]{plot.ggeffects}} for marginal effects plots.
+#'        \code{\link[ggeffects]{plot.ggeffects}} for \emph{Marginal Effects} plots.
 #'      }
 #'      \item{\code{show.loess}}{
 #'        Logical, for diagnostic plot-types \code{""slope""} and \code{""resid""},
@@ -231,16 +231,21 @@
 #'       the \pkg{arm}-package.
 #'     }
 #'     \item{\code{type = ""pred""}}{
-#'       Plots marginal effetcs. Simply wraps \code{\link[ggeffects]{ggpredict}}.
+#'       Plots marginal effects. Simply wraps \code{\link[ggeffects]{ggpredict}}.
 #'     }
 #'     \item{\code{type = ""eff""}}{
-#'       Plots marginal effetcs. Simply wraps \code{\link[ggeffects]{ggeffect}}.
+#'       Plots marginal effects. Simply wraps \code{\link[ggeffects]{ggeffect}}.
+#'     }
+#'     \item{\code{type = ""int""}}{
+#'       A shortcut for marginal effects plots, where interaction terms are
+#'       automatically detected and used as `terms`-argument. Then,
+#'       \code{\link[ggeffects]{ggpredict}} is called.
 #'     }
 #'   }
 #'
 #' @note \code{plot_model()} replaces the functions \code{sjp.lm}, \code{sjp.glm},
-#'   \code{sjp.lmer} and \code{sjp.glmer}. These are becoming softly deprecated
-#'   and will be removed in a future update.
+#'   \code{sjp.lmer}, \code{sjp.glmer} and \code{sjp.int}. These are becoming
+#'   softly deprecated and will be removed in a future update.
 #'
 #' @references Gelman A (2008) ""Scaling regression inputs by dividing by two standard deviations."" \emph{Statistics in Medicine 27: 28652873.} \url{http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf}
 #'
@@ -259,6 +264,12 @@
 #' # grouped coefficients
 #' plot_model(m, group.terms = c(1, 2, 3, 3, 3, 4, 4))
 #'
+#' # multiple plots, as returned from ""diagnostic""-plot type,
+#' # can be arranged with 'plot_grid()'
+#' \dontrun{
+#' p <- plot_model(m, type = ""diag"")
+#' plot_grid(p)}
+#'
 #' # plot random effects
 #' library(lme4)
 #' m <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
@@ -389,9 +400,9 @@ plot_model <- function(model,
 
   # check if plot-type is applicable
 
-  if (type %in% c(""slope"", ""resid"") && !fam.info$is_linear) {
+  if (type == ""slope"" && !fam.info$is_linear) {
     type <- ""est""
-    message(""Plot-types \""slope\"" and \""resid\"" only available for linear models. Using `type = \""est\""` now."")
+    message(""Plot-type \""slope\"" only available for linear models. Using `type = \""est\""` now."")
   }
 
 
@@ -435,7 +446,6 @@ plot_model <- function(model,
 
     p <- plot_type_ranef(
       model = model,
-      type = type,
       ri.nr = ri.nr,
       ci.lvl = ci.lvl,
       tf = transform,
@@ -480,7 +490,6 @@ plot_model <- function(model,
     # plot interaction terms ----
 
     p <- plot_type_int(
-      type = type,
       model = model,
       mdrt.values = mdrt.values,
       ci.lvl = ci.lvl,
@@ -519,15 +528,25 @@ plot_model <- function(model,
     # plot diagnostic plots ----
 
     if (is.stan(model)) {
+
       p <- plot_diag_stan(
         model = model,
         geom.colors = colors,
         facets = grid,
         ...
       )
 
-    } else {
+    } else if (fam.info$is_linear) {
 
+      p <- plot_diag_linear(
+        model = model,
+        geom.colors = colors,
+        ...
+      )
+
+    } else {
+      message(""Not implemented yet."")
+      p <- NULL
     }
 
   }

---FILE: R/plot_type_int.R---
@@ -1,6 +1,11 @@
 #' @importFrom sjstats model_frame
-plot_type_int <- function(type,
-                          model,
+#' @importFrom stats formula sd quantile
+#' @importFrom purrr map map_lgl map_chr
+#' @importFrom sjmisc trim is_empty str_contains
+#' @importFrom dplyr select n_distinct
+#' @importFrom ggeffects ggpredict
+#' @importFrom graphics plot
+plot_type_int <- function(model,
                           mdrt.values,
                           ci.lvl,
                           pred.type,
@@ -13,9 +18,11 @@ plot_type_int <- function(type,
                           case,
                           ...) {
 
-  # get interaction terms
-  it <- stats::terms(model)
-  int.terms <- attr(it, ""order"", exact = TRUE) > 1
+  # find right hand side of formula, to extract interaction terms
+  rhs <- unlist(strsplit(as.character(stats::formula(model))[3], ""+"", fixed = TRUE))
+
+  # interaction terms are separated with "":""
+  int.terms <- purrr::map_lgl(rhs, ~ sjmisc::str_contains(.x, ""*""))
 
 
   # stop if no interaction found
@@ -26,10 +33,10 @@ plot_type_int <- function(type,
 
   # get interaction terms and model frame
 
-  ia.terms <- attr(it, ""term.labels"", exact = TRUE)[int.terms]
-  ia.terms <- purrr::map(ia.terms, ~ sjmisc::trim(unlist(strsplit(.x, "":"", fixed = TRUE))))
+  ia.terms <- purrr::map(rhs[int.terms], ~ sjmisc::trim(unlist(strsplit(.x, ""*"", fixed = TRUE))))
   mf <- sjstats::model_frame(model)
 
+  pl <- list()
 
   # intertate interaction terms
 
@@ -45,24 +52,70 @@ plot_type_int <- function(type,
     check_cont <- ia[-1][!find.fac[2:length(find.fac)]]
 
 
-    # for quartiles used as moderator values, make sure
-    # that the variable's range is large enough to compute
-    # quartiles
+    # if we have just categorical as interaction terms,
+    # we plot all category values
+
+    if (!sjmisc::is_empty(check_cont)) {
+
+      # get data from continuous interaction terms. we
+      # need this to compute the specific values that
+      # should be used as group characteristic for the plot
+
+      cont_terms <- dplyr::select(mf, !! check_cont)
+
 
-    mdrt.val <- mv_check(mdrt.values = mdrt.values, dplyr::select(mf, !! check_cont))
+      # for quartiles used as moderator values, make sure
+      # that the variable's range is large enough to compute
+      # quartiles
 
+      mdrt.val <- mv_check(mdrt.values = mdrt.values, cont_terms)
+
+      # prepare terms for ggpredict()-call. terms is a character-vector
+      # with term name and values to plot in square brackets
+
+      terms <- purrr::map_chr(check_cont, function(x) {
+        if (mdrt.val == ""minmax"") {
+          sprintf(""%s [%i,%i]"",
+                  x,
+                  min(cont_terms[[x]], na.rm = TRUE),
+                  max(cont_terms[[x]], na.rm = TRUE))
+        } else if (mdrt.val == ""meansd"") {
+          mw <- mean(cont_terms[[x]], na.rm = TRUE)
+          sabw <- stats::sd(cont_terms[[x]], na.rm = TRUE)
+          sprintf(""%s [%.2f,%.2f,%.2f]"", x, mw, mw - sabw, mw + sabw)
+        } else if (mdrt.val == ""zeromax"") {
+          sprintf(""%s [0,%i]"", x, max(cont_terms[[x]], na.rm = TRUE))
+        } else if (mdrt.val == ""quart"") {
+          qu <- as.vector(stats::quantile(cont_terms[[x]], na.rm = T))
+          sprintf(""%s [%.2f,%.2f,%.2f]"", x, qu[3], qu[2], qu[4])
+        } else {
+          x
+        }
+      })
+
+      ia[match(check_cont, ia)] <- terms
+    }
 
 
+    # compute marginal effects for interaction terms
 
     dat <- ggeffects::ggpredict(
       model = model,
-      terms = terms,
+      terms = ia,
       ci.lvl = ci.lvl,
       type = pred.type,
       full.data = FALSE,
       ...
     )
 
+
+    # select color palette
+
+    geom.colors <- col_check2(geom.colors, dplyr::n_distinct(dat$group))
+
+
+    # save plot of marginal effects for interaction terms
+
     p <- graphics::plot(
       dat,
       ci = !is.na(ci.lvl),
@@ -91,20 +144,21 @@ plot_type_int <- function(type,
     # set axis limits
     if (!is.null(axis.lim)) {
       if (is.list(axis.lim))
-        p <- p + xlim(axis.lim[[1]]) + + ylim(axis.lim[[2]])
+        p <- p + xlim(axis.lim[[1]]) + ylim(axis.lim[[2]])
       else
         p <- p + ylim(axis.lim)
     }
 
 
-    p
+    # add plot result to final return value
 
+    if (length(ia.terms) == 1)
+      pl <- p
+    else
+      pl[[length(pl) + 1]] <- p
   }
 
-
-
-
-  p
+  pl
 }
 
 

---FILE: R/plot_type_ranef.R---
@@ -8,7 +8,6 @@
 #' @importFrom sjmisc remove_var
 plot_type_ranef <- function(model,
                             dat,
-                            type,
                             ri.nr,
                             ci.lvl,
                             tf,

---FILE: R/sjPlotAnova.R---
@@ -32,7 +32,6 @@ utils::globalVariables(c(""pv"", ""xv""))
 #'           was used for setting up the ggplot-object (\code{df}).
 #'
 #' @examples
-#' library(sjmisc)
 #' data(efc)
 #' # note: ""var.grp"" does not need to be a factor.
 #' # coercion to factor is done by the function

---FILE: R/sjPlotFA.R---
@@ -47,7 +47,6 @@
 #'       from the psych package.
 #'
 #' @examples
-#' library(sjmisc)
 #' library(GPArotation)
 #' data(efc)
 #' # recveive first item of COPE-index scale

---FILE: R/sjPlotFrequencies.R---
@@ -60,36 +60,26 @@ utils::globalVariables(c(""val"", ""frq"", ""grp"", ""label.pos"", ""upper.ci"", ""lower.ci
 #'           was used for setting up the ggplot-object (\code{data}).
 #'
 #' @examples
-#' # Using EUROFAMCARE sample dataset
-#' # dataset was importet from an SPSS-file, using:
-#' # efc <- sjlabelled::read_spss(""efc.sav"", enc = ""UTF-8"")
-#' library(sjmisc)
 #' library(sjlabelled)
 #' data(efc)
 #'
 #' # boxplot
-#' sjp.frq(ChickWeight$weight, type = ""box"")
+#' sjp.frq(efc$e17age, type = ""box"")
 #'
 #' # histogram
 #' sjp.frq(efc$e17age, type = ""hist"", show.mean = TRUE)
 #'
 #' # violin plot
-#' sjp.frq(ChickWeight$weight, type = ""v"")
+#' sjp.frq(efc$e17age, type = ""v"")
 #'
 #' # bar plot
-#' sjp.frq(ChickWeight$Diet)
-#'
-#' # you may use set_theme() here to change axis textangle
-#' sjp.frq(efc$e15relat)
+#' sjp.frq(efc$e42dep)
 #'
 #' # grouped variable
 #' ageGrp <- group_var(efc$e17age)
 #' ageGrpLab <- group_labels(efc$e17age)
 #' sjp.frq(ageGrp, title = get_label(efc$e17age), axis.labels = ageGrpLab)
 #'
-#' # negative impact scale, ranging from 7-28
-#' sjp.frq(efc$neg_c_7)
-#'
 #' # plotting confidence intervals. expand grid and v/hjust for text labels
 #' sjp.frq(
 #'   efc$e15relat, type = ""dot"", show.ci = TRUE, sort.frq = ""desc"",

---FILE: R/sjPlotGroupFrequencies.R---
@@ -139,8 +139,6 @@ utils::globalVariables(c(""."", ""label"", ""prz"", ""frq"", ""ypos"", ""wb"", ""ia"", ""mw"", ""
 #'          }
 #'
 #' @examples
-#' # histrogram with EUROFAMCARE sample dataset
-#' library(sjmisc)
 #' data(efc)
 #' sjp.grpfrq(efc$e17age, efc$e16sex, show.values = FALSE)
 #'

---FILE: R/sjPlotGroupPropTable.R---
@@ -41,7 +41,6 @@ utils::globalVariables(c(""dep"", ""n""))
 #'            and \code{y} for each \code{groups}.
 #'
 #' @examples
-#' library(sjmisc)
 #' data(efc)
 #'
 #' # the proportion of dependency levels in female

---FILE: R/sjPlotKfoldCV.R---
@@ -34,7 +34,6 @@ utils::globalVariables(c(""train"", ""model"", ""test"", "".response"", ""sse"", ""sst""))
 #' @note Currently, only linear, poisson and negative binomial regression models are supported.
 #'
 #' @examples
-#' library(sjmisc)
 #' data(efc)
 #'
 #' sjp.kfold_cv(efc, neg_c_7 ~ e42dep + c172code + c12hour)

---FILE: R/sjPlotLikert.R---
@@ -67,7 +67,6 @@ utils::globalVariables(c(""offset""))
 #'           \code{df.pos} for the positive values and \code{df.neutral} for the neutral category values).
 #'
 #' @examples
-#' # Data from the EUROFAMCARE sample dataset
 #' library(sjmisc)
 #' data(efc)
 #' # find all variables from COPE-Index, which all have a ""cop"" in their

---FILE: R/sjTabPropTable.R---
@@ -70,7 +70,6 @@
 #'
 #' @examples
 #' # prepare sample data set
-#' library(sjmisc)
 #' data(efc)
 #'
 #' # print simple cross table with labels

---FILE: R/sjTabSPSS.R---
@@ -57,7 +57,6 @@
 #' @examples
 #' \dontrun{
 #' # init dataset
-#' library(sjmisc)
 #' data(efc)
 #'
 #' # view variables

---FILE: R/sjTabStackFrq.R---
@@ -80,7 +80,6 @@
 #' # Data from the EUROFAMCARE sample dataset
 #' # Auto-detection of labels
 #' # -------------------------------
-#' library(sjmisc)
 #' data(efc)
 #' # recveive first item of COPE-index scale
 #' start <- which(colnames(efc) == ""c82cop1"")

---FILE: R/sjplot.R---
@@ -62,7 +62,6 @@
 #'          }
 #'
 #' @examples
-#' library(sjmisc)
 #' library(dplyr)
 #' data(efc)
 #'

---FILE: R/utils.R---
@@ -110,36 +110,8 @@ get_p_stars <- function(pval) {
 }
 
 
-#' @importFrom scales brewer_pal grey_pal
-col_check2 <- function(geom.colors, collen) {
-  # --------------------------------------------
-  # check color argument
-  # --------------------------------------------
-  # check for corrct color argument
-  if (!is.null(geom.colors)) {
-    # check for color brewer palette
-    if (is.brewer.pal(geom.colors[1])) {
-      geom.colors <- scales::brewer_pal(palette = geom.colors[1])(collen)
-    } else if (geom.colors[1] == ""gs"") {
-      geom.colors <- scales::grey_pal()(collen)
-      # do we have correct amount of colours?
-    } else if (geom.colors[1] == ""bw"") {
-      geom.colors <- rep(""black"", times = collen)
-      # do we have correct amount of colours?
-    } else if (length(geom.colors) > collen) {
-      # shorten palette
-      geom.colors <- geom.colors[1:collen]
-    } else if (length(geom.colors) < collen) {
-      # repeat color palette
-      geom.colors <- rep(geom.colors, times = collen)
-      # shorten to required length
-      geom.colors <- geom.colors[1:collen]
-    }
-  } else {
-    geom.colors <- scales::brewer_pal(palette = ""Set1"")(collen)
-  }
-
-  geom.colors
+is_merMod <- function(fit) {
+  inherits(fit, c(""lmerMod"", ""glmerMod"", ""nlmerMod"", ""merModLmerTest""))
 }
 
 

---FILE: man/plot_grid.Rd---
@@ -26,7 +26,6 @@ This function takes a \code{list} of ggplot-objects as argument.
          To arrange these plots as grid as a single plot, use \code{plot_grid}.
 }
 \examples{
-library(sjmisc)
 data(efc)
 # fit model
 fit <- lm(tot_sc_e ~ c12hour + e17age + e42dep + neg_c_7, data = efc)

---FILE: man/plot_model.Rd---
@@ -31,7 +31,7 @@ kinds of models are supported, e.g. from packages like \pkg{stats},
 \pkg{lme4}, \pkg{nlme}, \pkg{rstanarm}, \pkg{survey}, \pkg{glmmTMB},
 \pkg{MASS}, \pkg{brms} etc.}
 
-\item{type}{Type of plot. There are three higher groups of plot-tyes:
+\item{type}{Type of plot. There are three groups of plot-types:
 \cr \cr
 \emph{Coefficients}
 \describe{
@@ -48,15 +48,15 @@ kinds of models are supported, e.g. from packages like \pkg{stats},
 }
 \emph{Model diagnostics}
 \describe{
-  \item{\code{type = ""slope""}}{slope of coefficients for each single predictor, against the response (linear relationship between each model term and response).}
-  \item{\code{type = ""resid""}}{slope of coefficients for each single predictor, against the residuals (linear relationship between each model term and residuals).}
+  \item{\code{type = ""slope""}}{Slope of coefficients for each single predictor, against the response (linear relationship between each model term and response).}
+  \item{\code{type = ""resid""}}{Slope of coefficients for each single predictor, against the residuals (linear relationship between each model term and residuals).}
   \item{\code{type = ""diag""}}{Check model assumptions.}
 }}
 
 \item{transform}{A character vector, naming a function that will be applied
 on estimates and confidence intervals. By default, \code{transform} will
 automatically use \code{""exp""} as transformation for applicable classes
-of \code{fit} (e.g. logistic or poisson regression). Estimates of linear
+of \code{model} (e.g. logistic or poisson regression). Estimates of linear
 models remain untransformed. Use \code{NULL} if you want the raw, non-transformed
 estimates.}
 
@@ -72,7 +72,8 @@ that should be plotted. This argument depends on the plot-type:
     should be displayed. At least one term is required to calculate
     effects, maximum length is three terms, where the second and
     third term indicate the groups, i.e. predictions of first term
-    are grouped by the levels of the second (and third) term.
+    are grouped by the levels of the second (and third) term. \code{terms}
+    may also indicate higher order terms (e.g. interaction terms).
     Indicating levels in square brackets allows for selecting only
     specific groups. Term name and levels in brackets must be separated
     by a whitespace character, e.g. \code{terms = c(""age"", ""education [1,3]"")}.
@@ -92,8 +93,7 @@ that should be plotted. This argument depends on the plot-type:
 be removed from the plot. Counterpart to \code{terms}.
 \code{rm.terms = ""t_name""} would remove the term \emph{t_name}.
 Default is \code{NULL}, i.e. all terms are used. Note that this
-argument does not apply to \code{type = ""eff""}, \code{type = ""pred""}
-or \code{type = ""int""}.}
+argument does not apply to \emph{Marginal Effects} plots.}
 
 \item{group.terms}{Numeric vector with group indices, to group coefficients.
 Each group of coefficients gets its own color (see 'Examples').}
@@ -108,7 +108,7 @@ conditioned on random effects (\code{pred.type = ""re""}) or fixed effects
 only (\code{pred.type = ""fe""}, the default).}
 
 \item{mdrt.values}{Indicates which values of the moderator variable should be
-used when plotting the interaction effects.
+used when plotting interaction terms (i.e. \code{type = ""int""}).
 \describe{
   \item{\code{""minmax""}}{(default) minimum and maximum values (lower and upper bounds) of the moderator are used to plot the interaction between independent variable and moderator(s).}
   \item{\code{""meansd""}}{uses the mean value of the moderator as well as one standard deviation below and above mean value to plot the effect of the moderator on the independent variable (following the convention suggested by Cohen and Cohen and popularized by Aiken and West, i.e. using the mean, the value one standard deviation above, and the value one standard deviation below the mean as values of the moderator, see \href{http://www.theanalysisfactor.com/3-tips-interpreting-moderation/}{Grace-Martin K: 3 Tips to Make Interpreting Moderation Effects Easier}).}
@@ -117,11 +117,11 @@ used when plotting the interaction effects.
   \item{\code{""all""}}{uses all values of the moderator variable.}
 }}
 
-\item{ri.nr}{Numeric vector. If \code{type = ""re""} or \code{type = ""ri.slope""},
-and fitted model has more than one random intercept, \code{ri.nr} indicates
-which random effects of which random intercept (or: which list elements
-of \code{\link[lme4]{ranef}}) will be plotted. Default is \code{NULL},
-so all random effects will be plotted.}
+\item{ri.nr}{Numeric vector. If \code{type = ""re""} and fitted model has more
+than one random intercept, \code{ri.nr} indicates which random effects of
+which random intercept (or: which list elements of \code{\link[lme4]{ranef}})
+will be plotted. Default is \code{NULL}, so all random effects will be
+plotted.}
 
 \item{title}{Character vector, used as plot title. By default,
 \code{\link[sjlabelled]{get_dv_labels}} is called to retrieve the
@@ -140,7 +140,7 @@ titles.}
 axis labels. By default, \code{\link[sjlabelled]{get_term_labels}} is
 called to retrieve the labels of the coefficients, which will be used as
 axis labels. Use \code{axis.labels = """"} or \code{auto.label = FALSE}
-to use the bare term names as labels instead.}
+to use the variable names as labels instead.}
 
 \item{wrap.title}{Numeric, determines how many chars of the plot title are
 displayed in one line and when a line break is inserted.}
@@ -167,7 +167,7 @@ the 50\%-HDI; and the ""outer"" interval, which defaults to the 89\%-HDI.
 for more details.}
 
 \item{colors}{May be a character vector of color values in hex-format, valid
-color value names (see \code{demo(""colors"")} or a name of a
+color value names (see \code{demo(""colors"")}) or a name of a
 \href{http://colorbrewer2.org}{color brewer} palette. Following options
 are valid for the \code{colors} argument:
 \itemize{
@@ -247,14 +247,14 @@ of supported arguments and their description in detail.
     outer probability).
   }
   \item{\code{size.inner}}{
-    For \strong{Stan}-models and coefficients plot-types, you
+    For \strong{Stan}-models and \emph{Coefficients} plot-types, you
     can specify the width of the bar for the inner probabilities.
     Default is \code{0.1}.
   }
   \item{\code{width}, \code{alpha} and \code{scale}}{
     Passed down to \code{geom_errorbar()} or \code{geom_density_ridges()},
     for forest or diagnostic plots; or passed down to
-    \code{\link[ggeffects]{plot.ggeffects}} for marginal effects plots.
+    \code{\link[ggeffects]{plot.ggeffects}} for \emph{Marginal Effects} plots.
   }
   \item{\code{show.loess}}{
     Logical, for diagnostic plot-types \code{""slope""} and \code{""resid""},
@@ -294,17 +294,22 @@ Depending on the plot-type, \code{plot_model()} returns a
       the \pkg{arm}-package.
     }
     \item{\code{type = ""pred""}}{
-      Plots marginal effetcs. Simply wraps \code{\link[ggeffects]{ggpredict}}.
+      Plots marginal effects. Simply wraps \code{\link[ggeffects]{ggpredict}}.
     }
     \item{\code{type = ""eff""}}{
-      Plots marginal effetcs. Simply wraps \code{\link[ggeffects]{ggeffect}}.
+      Plots marginal effects. Simply wraps \code{\link[ggeffects]{ggeffect}}.
+    }
+    \item{\code{type = ""int""}}{
+      A shortcut for marginal effects plots, where interaction terms are
+      automatically detected and used as `terms`-argument. Then,
+      \code{\link[ggeffects]{ggpredict}} is called.
     }
   }
 }
 \note{
 \code{plot_model()} replaces the functions \code{sjp.lm}, \code{sjp.glm},
-  \code{sjp.lmer} and \code{sjp.glmer}. These are becoming softly deprecated
-  and will be removed in a future update.
+  \code{sjp.lmer}, \code{sjp.glmer} and \code{sjp.int}. These are becoming
+  softly deprecated and will be removed in a future update.
 }
 \examples{
 # prepare data
@@ -319,6 +324,12 @@ plot_model(m)
 # grouped coefficients
 plot_model(m, group.terms = c(1, 2, 3, 3, 3, 4, 4))
 
+# multiple plots, as returned from ""diagnostic""-plot type,
+# can be arranged with 'plot_grid()'
+\dontrun{
+p <- plot_model(m, type = ""diag"")
+plot_grid(p)}
+
 # plot random effects
 library(lme4)
 m <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)

---FILE: man/plot_models.Rd---
@@ -27,7 +27,7 @@ May also be a \code{list} with fitted models. See 'Examples'.}
 \item{transform}{A character vector, naming a function that will be applied
 on estimates and confidence intervals. By default, \code{transform} will
 automatically use \code{""exp""} as transformation for applicable classes
-of \code{fit} (e.g. logistic or poisson regression). Estimates of linear
+of \code{model} (e.g. logistic or poisson regression). Estimates of linear
 models remain untransformed. Use \code{NULL} if you want the raw, non-transformed
 estimates.}
 
@@ -43,8 +43,7 @@ be used for plotting. Default is no standardization.
 be removed from the plot. Counterpart to \code{terms}.
 \code{rm.terms = ""t_name""} would remove the term \emph{t_name}.
 Default is \code{NULL}, i.e. all terms are used. Note that this
-argument does not apply to \code{type = ""eff""}, \code{type = ""pred""}
-or \code{type = ""int""}.}
+argument does not apply to \emph{Marginal Effects} plots.}
 
 \item{title}{Character vector, used as plot title. By default,
 \code{\link[sjlabelled]{get_dv_labels}} is called to retrieve the
@@ -67,7 +66,7 @@ indicates the p-values. Default is \code{""p-level""}. Only applies if
 axis labels. By default, \code{\link[sjlabelled]{get_term_labels}} is
 called to retrieve the labels of the coefficients, which will be used as
 axis labels. Use \code{axis.labels = """"} or \code{auto.label = FALSE}
-to use the bare term names as labels instead.}
+to use the variable names as labels instead.}
 
 \item{axis.title}{Character vector of length one or two (depending on
 the plot function and type), used as title(s) for the x and y axis.
@@ -100,7 +99,7 @@ i.e. at every \code{grid.breaks}'th position a major grid is plotted.}
 plotted fitted models. Default is 0.3.}
 
 \item{colors}{May be a character vector of color values in hex-format, valid
-color value names (see \code{demo(""colors"")} or a name of a
+color value names (see \code{demo(""colors"")}) or a name of a
 \href{http://colorbrewer2.org}{color brewer} palette. Following options
 are valid for the \code{colors} argument:
 \itemize{

---FILE: man/sjp.aov1.Rd---
@@ -99,7 +99,6 @@ Plot One-Way-Anova table sum of squares (SS) of each factor level (group)
                the model summary.
 }
 \examples{
-library(sjmisc)
 data(efc)
 # note: ""var.grp"" does not need to be a factor.
 # coercion to factor is done by the function

---FILE: man/sjp.fa.Rd---
@@ -98,7 +98,6 @@ This method for factor analysis relies on the functions
       from the psych package.
 }
 \examples{
-library(sjmisc)
 library(GPArotation)
 data(efc)
 # recveive first item of COPE-index scale

---FILE: man/sjp.frq.Rd---
@@ -191,36 +191,26 @@ This function only works with variables with integer values (or numeric
         with decimals may result in unexpected behaviour.
 }
 \examples{
-# Using EUROFAMCARE sample dataset
-# dataset was importet from an SPSS-file, using:
-# efc <- sjlabelled::read_spss(""efc.sav"", enc = ""UTF-8"")
-library(sjmisc)
 library(sjlabelled)
 data(efc)
 
 # boxplot
-sjp.frq(ChickWeight$weight, type = ""box"")
+sjp.frq(efc$e17age, type = ""box"")
 
 # histogram
 sjp.frq(efc$e17age, type = ""hist"", show.mean = TRUE)
 
 # violin plot
-sjp.frq(ChickWeight$weight, type = ""v"")
+sjp.frq(efc$e17age, type = ""v"")
 
 # bar plot
-sjp.frq(ChickWeight$Diet)
-
-# you may use set_theme() here to change axis textangle
-sjp.frq(efc$e15relat)
+sjp.frq(efc$e42dep)
 
 # grouped variable
 ageGrp <- group_var(efc$e17age)
 ageGrpLab <- group_labels(efc$e17age)
 sjp.frq(ageGrp, title = get_label(efc$e17age), axis.labels = ageGrpLab)
 
-# negative impact scale, ranging from 7-28
-sjp.frq(efc$neg_c_7)
-
 # plotting confidence intervals. expand grid and v/hjust for text labels
 sjp.frq(
   efc$e15relat, type = ""dot"", show.ci = TRUE, sort.frq = ""desc"",

---FILE: man/sjp.gpt.Rd---
@@ -103,7 +103,6 @@ The p-values are based on \code{\link[stats]{chisq.test}} of \code{x}
            and \code{y} for each \code{groups}.
 }
 \examples{
-library(sjmisc)
 data(efc)
 
 # the proportion of dependency levels in female

---FILE: man/sjp.grpfrq.Rd---
@@ -198,8 +198,6 @@ Plot grouped or stacked frequencies of variables as bar/dot,
          }
 }
 \examples{
-# histrogram with EUROFAMCARE sample dataset
-library(sjmisc)
 data(efc)
 sjp.grpfrq(efc$e17age, efc$e16sex, show.values = FALSE)
 

---FILE: man/sjp.kfold_cv.Rd---
@@ -43,7 +43,6 @@ This function, first, generates \code{k} cross-validated test-training
 Currently, only linear, poisson and negative binomial regression models are supported.
 }
 \examples{
-library(sjmisc)
 data(efc)
 
 sjp.kfold_cv(efc, neg_c_7 ~ e42dep + c172code + c12hour)

---FILE: man/sjp.likert.Rd---
@@ -146,7 +146,6 @@ Note that only even numbers of categories are possible to plot, so the ""positive
        with the \code{catcount}-argument.
 }
 \examples{
-# Data from the EUROFAMCARE sample dataset
 library(sjmisc)
 data(efc)
 # find all variables from COPE-Index, which all have a ""cop"" in their

---FILE: man/sjplot.Rd---
@@ -78,7 +78,6 @@ The \code{...}-argument is used, first, to specify the variables from \code{data
       with up to two grouping variables. Plots are created for each subgroup then.
 }
 \examples{
-library(sjmisc)
 library(dplyr)
 data(efc)
 

---FILE: man/sjt.stackfrq.Rd---
@@ -146,7 +146,6 @@ sjt.stackfrq(likert_4, value.labels = levels_4, var.labels = items)
 # Data from the EUROFAMCARE sample dataset
 # Auto-detection of labels
 # -------------------------------
-library(sjmisc)
 data(efc)
 # recveive first item of COPE-index scale
 start <- which(colnames(efc) == ""c82cop1"")

---FILE: man/sjt.xtab.Rd---
@@ -146,7 +146,6 @@ The p-value for Cramer's V and the Phi coefficient are based
 }
 \examples{
 # prepare sample data set
-library(sjmisc)
 data(efc)
 
 # print simple cross table with labels

---FILE: man/view_df.Rd---
@@ -118,7 +118,6 @@ See 'Notes' in \code{\link{sjt.frq}}.
 \examples{
 \dontrun{
 # init dataset
-library(sjmisc)
 data(efc)
 
 # view variables

---FILE: vignettes/plot_model_estimates.Rmd---
@@ -19,6 +19,7 @@ This document describes how to plot estimates as forest plots (or dot whisker pl
 ```{r results='hide'}
 library(sjPlot)
 library(sjlabelled)
+library(sjmisc)
 library(ggplot2)
 
 data(efc)
@@ -136,15 +137,15 @@ For linear models, you can also plot standardized beta coefficients, using `type
 plot_model(m2, type = ""std"")
 ```
 
-## Bayesian models from rstanarm
+## Bayesian models (fitted with Stan)
 
-`plot_model()` also supports stan-models fitted with the **rstanarm** package. However, there are a few differences compared to the previous plot examples.
+`plot_model()` also supports stan-models fitted with the **rstanarm** or **brms** packages. However, there are a few differences compared to the previous plot examples.
 
 First, of course, there are no _confidence intervals_, but _uncertainty intervals_ - high density intervals, to be precise.
 
-Second, there's not just one interval range, but an inner and outer probability. By default, the inner probability is fixed to `.5`, while the outer probability is specified via `ci.lvl`. However, you can also use the arguments `prob.inner` and `prob.outer` to define the intervals boundaries.
+Second, there's not just one interval range, but an _inner_ and _outer_ probability. By default, the inner probability is fixed to `.5` (50%), while the outer probability is specified via `ci.lvl` (which defaults to `.89` (89%) for Bayesian models). However, you can also use the arguments `prob.inner` and `prob.outer` to define the intervals boundaries.
 
-Third, the point estimate is by default the median, but can also be another value, like mean. This can be specified with the `bpe`-argument.
+Third, the point estimate is by default the _median_, but can also be another value, like mean. This can be specified with the `bpe`-argument.
 
 ```{r results='hide'}
 library(rstanarm)
@@ -166,11 +167,26 @@ plot_model(
 
 ## Tweaking plot appearance
 
+There are several options to customize the plot appearance:
+
+  * The `colors`-argument either takes the name of a valid [colorbrewer palette](http://colorbrewer2.org) (see also the related [vignette](custplot.html)), `""bw""` or `""gs""` for black/white or greyscaled colors, or a string with a color name.
+  * `value.offset` and `value.size` adjust the positioning and size of value labels, if shown.
+  * `dot.size` and `line.size` change the size of dots and error bars.
+  * `vline.color` changes the neutral ""intercept"" line.
+  * `width`, `alpha` and `scale` are passed down to certain ggplot-geoms, like `geom_errorbar()` or `geom_density_ridges()`.
+
 ```{r}
-# keep only coefficients sex2, dep2 and dep3
-plot_model(m1, terms = c(""sex2"", ""dep2"", ""dep3""))
-# remove coefficients sex2, dep2 and dep3
-plot_model(m1, rm.terms = c(""sex2"", ""dep2"", ""dep3""))
+plot_model(
+  m1, 
+  colors = ""Accent"", 
+  show.values = TRUE,
+  value.offset = .4,
+  value.size = 4,
+  dot.size = 3,
+  line.size = 1.5,
+  vline.color = ""blue"",
+  width = 1.5
+)
 ```
 
 # References"
strengejacke,sjPlot,c8b242e52819d91c1f505ef163a2ee56759276ef,Daniel,mail@danielluedecke.de,2017-10-13T18:07:10Z,Daniel,mail@danielluedecke.de,2017-10-13T18:07:10Z,close various issues,NAMESPACE;NEWS.md;R/helpfunctions.R;R/plot_type_int.R;R/plot_type_slope.R;R/sjPlotPCA.R;R/sjPlotPropTable.R;R/sjTabPCA.R;R/utils.R;vignettes/plot_model_estimates.Rmd,True,True,True,False,32,78,110,"---FILE: NAMESPACE---
@@ -83,7 +83,6 @@ importFrom(dplyr,group_by_)
 importFrom(dplyr,if_else)
 importFrom(dplyr,mutate)
 importFrom(dplyr,n_distinct)
-importFrom(dplyr,one_of)
 importFrom(dplyr,rename_)
 importFrom(dplyr,sample_n)
 importFrom(dplyr,select)
@@ -122,7 +121,6 @@ importFrom(nlme,getCovariateFormula)
 importFrom(nlme,getData)
 importFrom(nlme,getResponse)
 importFrom(nlme,intervals)
-importFrom(prediction,find_data)
 importFrom(psych,KMO)
 importFrom(psych,describe)
 importFrom(psych,fa)
@@ -131,10 +129,8 @@ importFrom(psych,principal)
 importFrom(purrr,map)
 importFrom(purrr,map2)
 importFrom(purrr,map2_df)
-importFrom(purrr,map_chr)
 importFrom(purrr,map_dbl)
 importFrom(purrr,map_df)
-importFrom(purrr,map_lgl)
 importFrom(rlang,.data)
 importFrom(scales,brewer_pal)
 importFrom(scales,grey_pal)
@@ -173,6 +169,7 @@ importFrom(sjstats,chisq_gof)
 importFrom(sjstats,cod)
 importFrom(sjstats,cramer)
 importFrom(sjstats,cronb)
+importFrom(sjstats,get_model_frame)
 importFrom(sjstats,hdi)
 importFrom(sjstats,hoslem_gof)
 importFrom(sjstats,icc)

---FILE: NEWS.md---
@@ -6,7 +6,7 @@
 
 ## New functions
 
-* `plot_model()` as replacement for `sjp.lm()`, `sjp.glm()`, `sjp.lmer()` and `sjp.glmer()` (which will become deprecated in the future, and will later be removed).
+* `plot_model()` as replacement for `sjp.lm()`, `sjp.glm()`, `sjp.lmer()`, `sjp.glmer()` and `sjp.int()` (which will become deprecated in the future, and will later be removed).
 * `get_model_data()` to get the data from plot-objects created with `plot_model()`.
 * `font_size()`, `label_angle()` and `legend_style()` as convenient ways to tweak common ggplot-theme-elements.
 
@@ -15,11 +15,14 @@
 * `view_df()` now better handles string variables and gets a `show.string.values`-argument to omit the output of values from string variables.
 * `view_df()` gets a `max.len`-argument to truncate output for variables with many values.
 * `view_df()` displayes more information on non-labelled, numeric variables.
+* `sjp.pca()` and `sjt.pca()` now give more informative error messages when just one component is extracted.
 
 ## Bug fixes
 
 * Fixed bug with `rm.terms`-argument in `plot_models()`.
 * In rare situations, `view_df()` did not work for string variables with missing values.
+* Fixed issue with wrong footnote text when saving the output of `sjt.pca()` as file.
+* `sjp.xtab()` did not work when `show.n` and `show.prc` were set to `FALSE`, but `show.values` was `TRUE`.
 
 # sjPlot 2.3.3
 

---FILE: R/helpfunctions.R---
@@ -748,7 +748,7 @@ varimaxrota <- function(data, factors) {
   # mit den Faktorladungen der ausgewhlten Faktoren (Anzahl = Parameter ""factors"")
   # Varimax Rotation durchfhren
   varib <- stats::varimax(ladungen[, seq_len(factors)])
-  return(varib)
+  varib
 }
 
 

---FILE: R/plot_type_int.R---
@@ -1,3 +1,4 @@
+#' @importFrom sjstats get_model_frame
 plot_type_int <- function(type,
                           model,
                           mdrt.values,
@@ -28,7 +29,7 @@ plot_type_int <- function(type,
   # get interaction terms and model frame
 
   ia.terms <- purrr::map(rhs[int.terms], ~ sjmisc::trim(unlist(strsplit(.x, ""*"", fixed = TRUE))))
-  mf <- get_model_frame(model)
+  mf <- sjstats::get_model_frame(model)
 
 
   # intertate interaction terms

---FILE: R/plot_type_slope.R---
@@ -1,5 +1,5 @@
 #' @importFrom sjlabelled get_label
-#' @importFrom sjstats resp_val pred_vars resp_var
+#' @importFrom sjstats resp_val pred_vars resp_var get_model_frame
 #' @importFrom sjmisc str_contains is_empty
 #' @importFrom stats formula residuals
 #' @importFrom dplyr filter
@@ -45,7 +45,7 @@ plot_type_slope <- function(model,
   # retrieve column names of dataset so we can identify in which
   # column the data for each predictor is.
 
-  model_data <- get_model_frame(model)
+  model_data <- sjstats::get_model_frame(model)
   depvar.label <- sjlabelled::get_label(model_data[[1]], def.value = sjstats::resp_var(model), case = case)
   predvars <- sjstats::pred_vars(model)
 

---FILE: R/sjPlotPCA.R---
@@ -60,7 +60,7 @@
 #' @import ggplot2
 #' @importFrom tidyr gather
 #' @importFrom scales brewer_pal grey_pal
-#' @importFrom stats na.omit prcomp
+#' @importFrom stats na.omit prcomp varimax
 #' @importFrom sjstats cronb
 #' @importFrom psych principal
 #' @export
@@ -150,6 +150,10 @@ sjp.pca <- function(data,
   # check for predefined number of factors
   if (!is.null(nmbr.fctr) && is.numeric(nmbr.fctr)) pcadata.kaiser <- nmbr.fctr
 
+  if (pcadata.kaiser < 2) {
+    stop(""Only one principal component extracted. Can't rotate loading matrices. You may use `nmbr.fctr` to extract more than one component."", call. = F)
+  }
+
   # rotate matrix
   if (rotation == ""varimax"")
     pcadata.rotate <- varimaxrota(pcadata, pcadata.kaiser)

---FILE: R/sjPlotPropTable.R---
@@ -193,6 +193,9 @@ sjp.xtab <- function(x,
   # total column only applies to column percentages
   # --------------------------------------------------------
   if (margin != ""col"") show.total <- FALSE
+
+  # need to set this to FALSE
+  if (!show.n && !show.prc) show.values <- F
   # --------------------------------------------------------
   # create cross table of frequencies and percentages
   # --------------------------------------------------------

---FILE: R/sjTabPCA.R---
@@ -143,7 +143,7 @@ sjt.pca <- function(data,
   tag.msa <- ""msa""
   tag.pov <- ""pov""
   tag.cpov <- ""cpov""
-  tag.rotation <- ""rotation""
+  tag.rotate <- ""rotate""
   tag.kmo <- ""kmo""
   tag.arc <- ""arc""
   tag.minval <- ""minval""
@@ -159,7 +159,7 @@ sjt.pca <- function(data,
   css.cronbach <- ""font-style:italic;""
   css.msa <- ""font-style:italic; color:#666666;""
   css.kmo <- ""font-style:italic; border-bottom:double;""
-  css.rotation <- ""font-style:italic; font-size:0.9em;""
+  css.rotate <- ""font-style:italic; font-size:0.9em;""
   css.pov <- ""font-style:italic; border-top:1px solid;""
   css.cpov <- ""font-style:italic;""
   css.minval <- ""color:#cccccc;""
@@ -188,7 +188,7 @@ sjt.pca <- function(data,
     if (!is.null(CSS[['css.cronbach']])) css.cronbach <- ifelse(substring(CSS[['css.cronbach']], 1, 1) == '+', paste0(css.cronbach, substring(CSS[['css.cronbach']], 2)), CSS[['css.cronbach']])
     if (!is.null(CSS[['css.msa']])) css.msa <- ifelse(substring(CSS[['css.msa']], 1, 1) == '+', paste0(css.msa, substring(CSS[['css.msa']], 2)), CSS[['css.msa']])
     if (!is.null(CSS[['css.kmo']])) css.kmo <- ifelse(substring(CSS[['css.kmo']], 1, 1) == '+', paste0(css.kmo, substring(CSS[['css.kmo']], 2)), CSS[['css.kmo']])
-    if (!is.null(CSS[['css.rotation']])) css.rotation <- ifelse(substring(CSS[['css.rotation']], 1, 1) == '+', paste0(css.rotation, substring(CSS[['css.rotation']], 2)), CSS[['css.rotation']])
+    if (!is.null(CSS[['css.rotate']])) css.rotate <- ifelse(substring(CSS[['css.rotate']], 1, 1) == '+', paste0(css.rotate, substring(CSS[['css.rotate']], 2)), CSS[['css.rotate']])
     if (!is.null(CSS[['css.pov']])) css.pov <- ifelse(substring(CSS[['css.pov']], 1, 1) == '+', paste0(css.pov, substring(CSS[['css.pov']], 2)), CSS[['css.pov']])
     if (!is.null(CSS[['css.cpov']])) css.cpov <- ifelse(substring(CSS[['css.cpov']], 1, 1) == '+', paste0(css.cpov, substring(CSS[['css.cpov']], 2)), CSS[['css.cpov']])
     if (!is.null(CSS[['css.minval']])) css.minval <- ifelse(substring(CSS[['css.minval']], 1, 1) == '+', paste0(css.minval, substring(CSS[['css.minval']], 2)), CSS[['css.minval']])
@@ -202,7 +202,7 @@ sjt.pca <- function(data,
                          tag.tdata, css.tdata, tag.cronbach, css.cronbach, tag.minval, css.minval,
                          tag.removable, css.removable, tag.firsttablerow, css.firsttablerow,
                          tag.firsttablecol, css.firsttablecol, tag.centeralign, css.centeralign,
-                         tag.rightalign, css.rightalign, tag.rotation, css.rotation,
+                         tag.rightalign, css.rightalign, tag.rotate, css.rotate,
                          tag.msa, css.msa, tag.kmo, css.kmo, tag.pov, css.pov, tag.cpov,
                          css.cpov, tag.arc, css.arc)
   # ------------------------
@@ -225,6 +225,10 @@ sjt.pca <- function(data,
   # check for predefined number of factors
   if (!is.null(nmbr.fctr) && is.numeric(nmbr.fctr)) pcadata.kaiser <- nmbr.fctr
 
+  if (pcadata.kaiser < 2) {
+    stop(""Only one principal component extracted. Can't rotate loading matrices. You may use `nmbr.fctr` to extract more than one component."", call. = F)
+  }
+
   # rotate matrix
   if (rotation == ""varimax"")
     pcadata.rotate <- varimaxrota(pcadata, pcadata.kaiser)
@@ -467,7 +471,7 @@ sjt.pca <- function(data,
   colsp <- ncol(df) + 1
   if (show.msa) colsp <- colsp + 1
   page.content <- paste0(page.content, ""  <tr>\n"")
-  page.content <- paste0(page.content, sprintf(""    <td class=\""tdata rightalign rotation\"" colspan=\""%i\"">%s-rotation</td>\n"", colsp, rotation))
+  page.content <- paste0(page.content, sprintf(""    <td class=\""tdata rightalign rotate\"" colspan=\""%i\"">%s-rotation</td>\n"", colsp, rotation))
   page.content <- paste0(page.content, ""  </tr>\n"")
   # -------------------------------------
   # finish table
@@ -510,7 +514,7 @@ sjt.pca <- function(data,
   knitr <- gsub(tag.arc, css.arc, knitr, fixed = TRUE, useBytes = TRUE)
   knitr <- gsub(tag.cpov, css.cpov, knitr, fixed = TRUE, useBytes = TRUE)
   knitr <- gsub(tag.kmo, css.kmo, knitr, fixed = TRUE, useBytes = TRUE)
-  knitr <- gsub(tag.rotation, css.rotation, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.rotate, css.rotate, knitr, fixed = TRUE, useBytes = TRUE)
   knitr <- gsub(tag.minval, css.minval, knitr, fixed = TRUE, useBytes = TRUE)
   knitr <- gsub(tag.removable, css.removable, knitr, fixed = TRUE, useBytes = TRUE)
   knitr <- gsub(tag.firsttablerow, css.firsttablerow, knitr, fixed = TRUE, useBytes = TRUE)

---FILE: R/utils.R---
@@ -232,65 +232,6 @@ geom_intercep_line <- function(yintercept, axis.scaling, vline.color) {
     size <- major_size * 2
     geom_hline(yintercept = yintercept, color = color, size = size)
   } else {
-    geom_blank(
-      mapping = NULL,
-      data = NULL,
-      show.legend = FALSE,
-      inherit.aes = FALSE
-    )
-  }
-}
-
-
-#' @importFrom stats model.frame
-#' @importFrom prediction find_data
-#' @importFrom purrr map_lgl
-#' @importFrom dplyr select bind_cols one_of
-get_model_frame <- function(model) {
-  if (inherits(model, c(""merMod"", ""lmerMod"", ""glmerMod"", ""nlmerMod"", ""merModLmerTest"")))
-    fitfram <- stats::model.frame(model, fixed.only = TRUE)
-  else if (inherits(model, ""lme""))
-    fitfram <- model$data
-  else if (inherits(model, ""vgam""))
-    fitfram <- prediction::find_data(model)
-  else
-    fitfram <- stats::model.frame(model)
-
-  # check if we have any matrix columns, e.g. from splines
-  mc <- purrr::map_lgl(fitfram, is.matrix)
-
-  # if we have any matrix columns, we remove them from original
-  # model frame and convert them to regular data frames, give
-  # proper column names and bind them back to the original model frame
-  if (any(mc)) {
-    fitfram <- dplyr::select(fitfram, -which(mc))
-    spline.term <- get_cleaned_varnames(names(which(mc)))
-    # try to get model data from environment
-    md <- eval(stats::getCall(model)$data, environment(stats::formula(model)))
-    # bind spline terms to model frame
-    fitfram <- dplyr::bind_cols(fitfram, dplyr::select(md, dplyr::one_of(spline.term)))
+    NULL
   }
-
-  # clean variable names
-  colnames(fitfram) <- get_cleaned_varnames(colnames(fitfram))
-
-  fitfram
-}
-
-
-#' @importFrom purrr map_chr
-get_cleaned_varnames <- function(x) {
-  # for gam-smoothers/loess, remove s()- and lo()-function in column name
-  # for survival, remove strata()
-  pattern <- c(""log"", ""s"", ""lo"", ""bs"", ""poly"", ""strata"")
-
-  # do we have a ""log()"" pattern here? if yes, get capture region
-  # which matches the ""cleaned"" variable name
-  purrr::map_chr(1:length(x), function(i) {
-    for (j in 1:length(pattern)) {
-      p <- paste0(""^"", pattern[j], ""\\(([^,)]*).*"")
-      x[i] <- unique(sub(p, ""\\1"", x[i]))
-    }
-    x[i]
-  })
 }

---FILE: vignettes/plot_model_estimates.Rmd---
@@ -85,10 +85,11 @@ plot_model(m1, order.terms = c(6, 7, 1, 2, 3, 4, 5))
 
 ## Estimates on the untransformed scale 
 
-By default, `plot_model()` automatically exponentiates coefficients, if appropriate (e.g. for models with log or logit link). You can explicitley (dis-)allow this transformation using the `exponentiate`-argument.
+By default, `plot_model()` automatically exponentiates coefficients, if appropriate (e.g. for models with log or logit link). You can explicitley prevent transformation by setting the `transform`-argument to `NULL`, or apply any transformation by using a character vector with the function name.
 
 ```{r}
-plot_model(m1, exponentiate = FALSE)
+plot_model(m1, transform = NULL)
+plot_model(m1, transform = ""plogis"")
 ``` 
 
 ## Showing value labels"
strengejacke,sjPlot,89d5eb0c35b640c29e06ba4fcba80f6625b91984,Daniel,mail@danielluedecke.de,2017-10-12T16:08:01Z,Daniel,mail@danielluedecke.de,2017-10-12T16:08:01Z,fix issues in sjt.corr and view_df,NAMESPACE;R/plot_model.R;R/sjPlotPolynomials.R;R/sjTabCorr.R;R/sjTabDataFrame.R;R/sjTabSPSS.R;man/plot_model.Rd;man/view_df.Rd,False,True,True,False,42,58,100,"---FILE: NAMESPACE---
@@ -117,7 +117,6 @@ importFrom(lme4,getME)
 importFrom(lme4,ranef)
 importFrom(magrittr,""%>%"")
 importFrom(merTools,predictInterval)
-importFrom(methods,is)
 importFrom(modelr,crossv_kfold)
 importFrom(nlme,getCovariateFormula)
 importFrom(nlme,getData)
@@ -167,6 +166,7 @@ importFrom(sjmisc,to_label)
 importFrom(sjmisc,to_value)
 importFrom(sjmisc,trim)
 importFrom(sjmisc,var_rename)
+importFrom(sjmisc,var_type)
 importFrom(sjmisc,word_wrap)
 importFrom(sjmisc,zap_inf)
 importFrom(sjstats,chisq_gof)

---FILE: R/plot_model.R---
@@ -180,7 +180,7 @@
 #'    \describe{
 #'      \item{\code{prob.inner} and \code{prob.outer}}{
 #'        For \strong{Stan}-models (fitted with the \pkg{rstanarm}- or
-#'        \pkg{brms}-package) and plot-type \code{type = ""est""}, you can specify
+#'        \pkg{brms}-package) and coefficients plot-types, you can specify
 #'        numeric values between 0 and 1 for \code{prob.inner} and
 #'        \code{prob.outer}, which will then be used as inner and outer
 #'        probabilities for the uncertainty intervals (HDI). By default, the
@@ -189,7 +189,7 @@
 #'        outer probability).
 #'      }
 #'      \item{\code{size.inner}}{
-#'        For \strong{Stan}-models and plot-type \code{type = ""est""}, you
+#'        For \strong{Stan}-models and coefficients plot-types, you
 #'        can specify the width of the bar for the inner probabilities.
 #'        Default is \code{0.1}.
 #'      }

---FILE: R/sjPlotPolynomials.R---
@@ -145,7 +145,7 @@ sjp.poly <- function(x,
   # check for glm or lm
   # --------------------------------------------
   if (is.null(fun)) {
-    if (any(class(x) == ""glmerMod"") || any(class(x) == ""glm"")) {
+    if (inherits(x, c(""glmerMod"", ""glm""))) {
       fun <- ""glm""
     } else {
       fun <- ""lm""

---FILE: R/sjTabCorr.R---
@@ -91,7 +91,7 @@
 #' sjt.corr(efc[, c(start:end)], triangle = ""lower"",val.rm = 0.3,
 #'          CSS = list(css.valueremove = 'color:blue;'))}
 #'
-#' @importFrom stats na.omit
+#' @importFrom stats na.omit cor cor.test
 #' @export
 sjt.corr <- function(data,
                      na.deletion = c(""listwise"", ""pairwise""),
@@ -156,19 +156,19 @@ sjt.corr <- function(data,
   # check if user has passed a data frame
   # or a pca object
   # ----------------------------
-  if (any(class(data) == ""matrix"")) {
+  if (is.matrix(data)) {
     corr <- data
     cpvalues <- NULL
   } else {
     # missing deletion corresponds to
     # SPSS listwise
     if (na.deletion == ""listwise"") {
       data <- stats::na.omit(data)
-      corr <- cor(data, method = corr.method)
+      corr <- stats::cor(data, method = corr.method)
     } else {
       # missing deletion corresponds to
       # SPSS pairwise
-      corr <- cor(data,
+      corr <- stats::cor(data,
                   method = corr.method,
                   use = ""pairwise.complete.obs"")
     }

---FILE: R/sjTabDataFrame.R---
@@ -93,6 +93,7 @@
 #'
 #' @importFrom utils txtProgressBar setTxtProgressBar
 #' @importFrom psych describe
+#' @importFrom sjmisc var_type
 #' @export
 sjt.df <- function(mydf,
                    describe = TRUE,
@@ -252,7 +253,7 @@ sjt.df <- function(mydf,
   if (show.rownames) page.content <- paste0(page.content, sprintf(""    <th class=\""thead firsttablerow firsttablecol\"">%s</th>\n"", string.var))
   for (i in 1:colcnt) {
     # check variable type
-    vartype <- get.vartype(mydf[[i]])
+    vartype <- sjmisc::var_type(mydf[[i]])
     # column names and variable as table headline
     page.content <- paste0(page.content, sprintf(""    <th class=\""thead firsttablerow\"">%s"", cnames[i]))
     if (show.type) page.content <- paste0(page.content, sprintf(""<br>(%s)"", vartype))
@@ -292,7 +293,7 @@ sjt.df <- function(mydf,
     if (show.rownames) page.content <- paste0(page.content, sprintf(""    <th class=\""thead lasttablerow firsttablecol\"">%s</th>\n"", string.var))
     for (i in 1:colcnt) {
       # check variable type
-      vartype <- get.vartype(mydf[[i]])
+      vartype <- sjmisc::var_type(mydf[[i]])
       # column names and variable as table headline
       page.content <- paste0(page.content, sprintf(""    <th class=\""thead lasttablerow\"">%s"", cnames[i]))
       if (show.type) page.content <- paste0(page.content, sprintf(""<br>(%s)"", vartype))
@@ -370,36 +371,3 @@ sjt.df <- function(mydf,
     )
   )
 }
-
-
-# -------------------------------------
-# helper function to retrieve type
-# of variables
-# -------------------------------------
-#' @importFrom methods is
-get.vartype <- function(x) {
-  vt <- c(""unknown type"")
-  if (methods::is(x, ""Date""))
-    vt <- c(""date"")
-  else if (inherits(x, ""POSIXct""))
-    vt <- c(""POSIXct"")
-  else if (inherits(x, ""POSIXlt""))
-    vt <- c(""POSIXlt"")
-  else if (inherits(x, ""POSIXt""))
-    vt <- c(""POSIXt"")
-  else if (is.character(x))
-    vt <- c(""character"")
-  else if (is.ordered(x))
-    vt <- c(""ordinal"")
-  else if (is.factor(x))
-    vt <- c(""categorical"")
-  else if (is.integer(x))
-    vt <- c(""numeric"")
-  else if (is.double(x))
-    vt <- c(""numeric-double"")
-  else if (is.numeric(x))
-    vt <- c(""numeric"")
-  else if (is.atomic(x))
-    vt <- c(""atomic"")
-  return(vt)
-}

---FILE: R/sjTabSPSS.R---
@@ -18,6 +18,9 @@
 #'          and \code{\link[sjlabelled]{set_labels}}).
 #' @param show.id Logical, if \code{TRUE} (default), the variable ID is shown in the first column.
 #' @param show.values Logical, if \code{TRUE} (default), the variable values are shown as additional column.
+#' @param show.string.values Logical, if \code{TRUE}, elements of character vectors
+#'    are also shown. By default, these are omitted due to possibly overlengthy
+#'    tables.
 #' @param show.labels Logical, if \code{TRUE} (default), the value labels are shown as additional column.
 #' @param show.frq Logical, if \code{TRUE}, an additional column with frequencies for each variable is shown.
 #' @param show.prc Logical, if \code{TRUE}, an additional column with percentage of frequencies for each variable is shown.
@@ -70,7 +73,7 @@
 #'                    css.arc = ""color:blue;""))}
 #'
 #' @importFrom utils txtProgressBar setTxtProgressBar
-#' @importFrom sjmisc is_even
+#' @importFrom sjmisc is_even var_type
 #' @importFrom sjlabelled get_values
 #' @export
 view_df <- function(x,
@@ -79,6 +82,7 @@ view_df <- function(x,
                     show.id = TRUE,
                     show.type = FALSE,
                     show.values = TRUE,
+                    show.string.values = FALSE,
                     show.labels = TRUE,
                     show.frq = FALSE,
                     show.prc = FALSE,
@@ -120,11 +124,13 @@ view_df <- function(x,
   tag.tdata <- ""tdata""
   tag.arc <- ""arc""
   tag.caption <- ""caption""
+  tag.omit <- ""omit""
   css.table <- ""border-collapse:collapse; border:none;""
   css.thead <- ""border-bottom:double; font-style:italic; font-weight:normal; padding:0.2cm; text-align:left; vertical-align:top;""
   css.tdata <- ""padding:0.2cm; text-align:left; vertical-align:top;""
   css.arc <- ""background-color:#eaeaea""
   css.caption <- ""font-weight: bold; text-align:left;""
+  css.omit <- ""color:#999999;""
 
   # check user defined style sheets
   if (!is.null(CSS)) {
@@ -133,12 +139,13 @@ view_df <- function(x,
     if (!is.null(CSS[['css.tdata']])) css.tdata <- ifelse(substring(CSS[['css.tdata']], 1, 1) == '+', paste0(css.tdata, substring(CSS[['css.tdata']], 2)), CSS[['css.tdata']])
     if (!is.null(CSS[['css.arc']])) css.arc <- ifelse(substring(CSS[['css.arc']], 1, 1) == '+', paste0(css.arc, substring(CSS[['css.arc']], 2)), CSS[['css.arc']])
     if (!is.null(CSS[['css.caption']])) css.caption <- ifelse(substring(CSS[['css.caption']], 1, 1) == '+', paste0(css.caption, substring(CSS[['css.caption']], 2)), CSS[['css.caption']])
+    if (!is.null(CSS[['css.omit']])) css.omit <- ifelse(substring(CSS[['css.omit']], 1, 1) == '+', paste0(css.omit, substring(CSS[['css.omit']], 2)), CSS[['css.omit']])
   }
 
   # set style sheet
-  page.style <- sprintf(""<style>\nhtml, body { background-color: white; }\n%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n%s { %s }\n</style>"",
+  page.style <- sprintf(""<style>\nhtml, body { background-color: white; }\n%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n%s { %s }\n.%s { %s }\n</style>"",
                         tag.table, css.table, tag.thead, css.thead, tag.tdata, css.tdata,
-                        tag.arc, css.arc, tag.caption, css.caption)
+                        tag.arc, css.arc, tag.caption, css.caption, tag.omit, css.omit)
 
   # table init
   toWrite <- sprintf(""<html>\n<head>\n<meta http-equiv=\""Content-type\"" content=\""text/html;charset=%s\"">\n%s\n</head>\n<body>\n"", encoding, page.style)
@@ -200,7 +207,7 @@ view_df <- function(x,
 
     # type
     if (show.type) {
-      vartype <- get.vartype(x[[index]])
+      vartype <- sjmisc::var_type(x[[index]])
       page.content <-
         paste0(page.content,
                sprintf(""    <td class=\""tdata%s\"">%s</td>\n"", arcstring, vartype))
@@ -261,11 +268,16 @@ view_df <- function(x,
         # if yes, get value labels
         # the code here corresponds to the above code
         # for variable values
-        vals <- df.val[[index]]
+        vals <- na.omit(df.val[[index]])
 
         # sort character vectors
-        if (is.character(x[[index]]) && !is.null(vals) && !sjmisc::is_empty(vals))
-          vals <- sort(vals)
+        if (is.character(x[[index]]) && !is.null(vals) && !sjmisc::is_empty(vals)) {
+          if (show.string.values)
+            vals <- sort(vals)
+          else
+            vals <- ""<span class=\""omit\"">&lt;output omitted&gt;</span>""
+        }
+
 
         # check if we have any values...
         if (!is.null(vals)) {

---FILE: man/plot_model.Rd---
@@ -237,7 +237,7 @@ of supported arguments and their description in detail.
 \describe{
   \item{\code{prob.inner} and \code{prob.outer}}{
     For \strong{Stan}-models (fitted with the \pkg{rstanarm}- or
-    \pkg{brms}-package) and plot-type \code{type = ""est""}, you can specify
+    \pkg{brms}-package) and coefficients plot-types, you can specify
     numeric values between 0 and 1 for \code{prob.inner} and
     \code{prob.outer}, which will then be used as inner and outer
     probabilities for the uncertainty intervals (HDI). By default, the
@@ -246,7 +246,7 @@ of supported arguments and their description in detail.
     outer probability).
   }
   \item{\code{size.inner}}{
-    For \strong{Stan}-models and plot-type \code{type = ""est""}, you
+    For \strong{Stan}-models and coefficients plot-types, you
     can specify the width of the bar for the inner probabilities.
     Default is \code{0.1}.
   }

---FILE: man/view_df.Rd---
@@ -5,12 +5,12 @@
 \title{View structure of labelled data frames}
 \usage{
 view_df(x, weight.by = NULL, altr.row.col = TRUE, show.id = TRUE,
-  show.type = FALSE, show.values = TRUE, show.labels = TRUE,
-  show.frq = FALSE, show.prc = FALSE, show.wtd.frq = FALSE,
-  show.wtd.prc = FALSE, show.na = FALSE, sort.by.name = FALSE,
-  wrap.labels = 50, hide.progress = FALSE, CSS = NULL, encoding = NULL,
-  file = NULL, use.viewer = TRUE, no.output = FALSE,
-  remove.spaces = TRUE)
+  show.type = FALSE, show.values = TRUE, show.string.values = FALSE,
+  show.labels = TRUE, show.frq = FALSE, show.prc = FALSE,
+  show.wtd.frq = FALSE, show.wtd.prc = FALSE, show.na = FALSE,
+  sort.by.name = FALSE, wrap.labels = 50, hide.progress = FALSE,
+  CSS = NULL, encoding = NULL, file = NULL, use.viewer = TRUE,
+  no.output = FALSE, remove.spaces = TRUE)
 }
 \arguments{
 \item{x}{A (labelled) data frame, imported by \code{\link[sjlabelled]{read_spss}},
@@ -32,6 +32,10 @@ row respectively column.}
 
 \item{show.values}{Logical, if \code{TRUE} (default), the variable values are shown as additional column.}
 
+\item{show.string.values}{Logical, if \code{TRUE}, elements of character vectors
+are also shown. By default, these are omitted due to possibly overlengthy
+tables.}
+
 \item{show.labels}{Logical, if \code{TRUE} (default), the value labels are shown as additional column.}
 
 \item{show.frq}{Logical, if \code{TRUE}, an additional column with frequencies for each variable is shown.}"
strengejacke,sjPlot,d79078590fb6e828bbfcfcd41016ed0e554b6027,Daniel,mail@danielluedecke.de,2017-10-08T19:38:14Z,Daniel,mail@danielluedecke.de,2017-10-08T19:38:14Z,fix issue with specific model objects,R/tidiers.R,False,True,True,False,32,0,32,"---FILE: R/tidiers.R---
@@ -17,6 +17,8 @@ tidy_model <- function(model, ci.lvl, exponentiate, type, bpe, ...) {
     tidy_hurdle_model(model, ci.lvl)
   else if (inherits(model, ""logistf""))
     tidy_logistf_model(model, ci.lvl)
+  else if (inherits(model, ""gam""))
+    tidy_gam_model(model, ci.lvl)
   else
     tidy_generic(model, ci.lvl)
 }
@@ -341,3 +343,33 @@ tidy_logistf_model <- function(model, ci.lvl) {
     p.value = model$prob
   )
 }
+
+
+#' @importFrom stats coef qnorm pnorm
+#' @importFrom tibble tibble
+tidy_gam_model <- function(model, ci.lvl) {
+
+  # compute ci, two-ways
+
+  if (!is.null(ci.lvl) && !is.na(ci.lvl))
+    ci <- 1 - ((1 - ci.lvl) / 2)
+  else
+    ci <- .975
+
+
+  # get estimates
+
+  est <- stats::coef(model)
+  se <- sqrt(diag(model$Ve))
+  sm <- summary(model)
+
+  tibble::tibble(
+    term = names(est),
+    estimate = est,
+    std.error = se,
+    statistic = sm$p.t,
+    conf.low = estimate - stats::qnorm(ci) * std.error,
+    conf.high = estimate + stats::qnorm(ci) * std.error,
+    p.value = sm$p.pv
+  )
+}"
strengejacke,sjPlot,e2ab02f44ea645bda31603a9ed9e53be7e750c83,Daniel,mail@danielluedecke.de,2017-10-07T20:13:18Z,Daniel,mail@danielluedecke.de,2017-10-07T20:13:18Z,"various improvements, new vignettes, fix check issues",DESCRIPTION;NEWS.md;R/plot_model.R;R/plot_model_estimates.R;R/plot_models.R;R/plot_point_estimates.R;R/plot_type_eff.R;R/plot_type_est.R;R/plot_type_ranef.R;R/sjPlotGroupFrequencies.R;R/sjplot_themes.R;R/tidiers.R;R/utils.R;data/efc.RData;man/efc.Rd;man/plot_model.Rd;man/plot_models.Rd;man/sjPlot-themes.Rd;man/sjp.aov1.Rd;man/sjp.corr.Rd;man/sjp.fa.Rd;man/sjp.frq.Rd;man/sjp.glm.Rd;man/sjp.glmer.Rd;man/sjp.grpfrq.Rd;man/sjp.int.Rd;man/sjp.lm.Rd;man/sjp.lmer.Rd;man/sjp.pca.Rd;man/sjp.stackfrq.Rd;man/sjp.xtab.Rd;vignettes/blackwhitefigures.Rmd;vignettes/custplot.Rmd;vignettes/plot_model_estimates.Rmd;vignettes/sjpglm.Rmd,True,True,True,False,985,443,1428,"---FILE: DESCRIPTION---
@@ -44,7 +44,7 @@ Imports:
     purrr,
     rlang,
     scales,
-    sjlabelled (>= 1.0.3),
+    sjlabelled (>= 1.0.4),
     sjmisc (>= 2.6.1),
     sjstats (>= 0.11.2),
     tidyselect,

---FILE: NEWS.md---
@@ -1,5 +1,15 @@
 # sjPlot 2.4.0
 
+## General
+
+* The old `set_theme()` was removed. Instead, there are some new predifined themes available (see `?""sjPlot-themes""`). The former `sjp.setThemes()` was renamed to `set_theme()` instead.
+
+## New functions
+
+* `plot_model()` as replacement for `sjp.lm()`, `sjp.glm()`, `sjp.lmer()` and `sjp.glmer()` (which will become deprecated in the future, and will later be removed).
+* `get_model_data()` to get the data from plot-objects created with `plot_model()`.
+* `font_size()`, `label_angle()` and `legend_style()` as convenient ways to tweak common ggplot-theme-elements.
+
 ## Bug fixes
 
 * Fixed bug with `rm.terms`-argument in `plot_models()`.

---FILE: R/plot_model.R---
@@ -1,108 +1,261 @@
-#' @title Various plot types for regression models
+#' @title Plot regression models
 #' @name plot_model
 #'
-#' @description To Do...
+#' @description \code{plot_model()} creates plots from regression models, either
+#'    estimates (as so-called forest or dot whisker plots) or marginal effects.
 #'
-#' @param type Type of plot. Use one of following:
-#'          \describe{
-#'            \item{\code{""est""}}{(default) for forest-plot of estimates. If the fitted model only contains one predictor, slope-line is plotted.}
-#'            \item{\code{""re""}}{for mixed effects models, plots the random effects.}
-#'            \item{\code{""pred""}}{to plot predicted values (marginal effects) for specific model terms. See \code{\link[ggeffects]{ggpredict}} for details.}
-#'            \item{\code{""eff""}}{similar to \code{type = ""pred""}, however, discrete predictors are held constant at their proportions (not reference level). See \code{\link[ggeffects]{ggeffect}} for details.}
-#'            \item{\code{""int""}}{to plot marginal effects of interaction terms in \code{model}.}
-#'            \item{\code{""std""}}{for forest-plot of standardized beta values.}
-#'            \item{\code{""std2""}}{for forest-plot of standardized beta values, however, standardization is done by dividing by two sd (see 'Details').}
-#'            \item{\code{""slope""}}{to plot regression lines for each single predictor of the fitted model, against the response (linear relationship between each model term and response).}
-#'            \item{\code{""resid""}}{to plot regression lines for each single predictor of the fitted model, against the residuals (linear relationship between each model term and residuals). May be used for model diagnostics.}
-#'            \item{\code{""diag""}}{to check model assumptions.}
-#'            \item{\code{""vif""}}{to plot Variance Inflation Factors.}
-#'          }
-#' @param sort.est Determines in which way estimates are sorted in the plot:
-#'          \itemize{
-#'            \item If \code{NULL} (default), no sorting is done and estimates are sorted in the same order as they appear in the model formula.
-#'            \item If \code{TRUE}, estimates are sorted in descending order, with highedt estimate at the top.
-#'            \item If \code{sort.est = ""sort.all""}, estimates are re-sorted for each coefficient (only applies if \code{type = ""re""} and \code{facets = FALSE}), i.e. the estimates of the random effects for each predictor are sorted and plotted to an own plot.
-#'            \item If \code{type = ""re""}, specify a predictor's / coefficient's name to sort estimates according to this random effect.
-#'            }
+#' @param model A regression model object. Depending on the \code{type}, many
+#'    kinds of models are supported, e.g. from packages like \pkg{stats},
+#'    \pkg{lme4}, \pkg{nlme}, \pkg{rstanarm}, \pkg{survey}, \pkg{glmmTMB},
+#'    \pkg{MASS} etc.
+#' @param type Type of plot. There are three higher groups of plot-tyes:
+#'    \cr \cr
+#'    \emph{Coefficients}
+#'    \describe{
+#'      \item{\code{type = ""est""}}{Forest-plot of estimates. If the fitted model only contains one predictor, slope-line is plotted.}
+#'      \item{\code{type = ""re""}}{For mixed effects models, plots the random effects.}
+#'      \item{\code{type = ""std""}}{Forest-plot of standardized beta values.}
+#'      \item{\code{type = ""std2""}}{Forest-plot of standardized beta values, however, standardization is done by dividing by two sd (see 'Details').}
+#'    }
+#'    \emph{Marginal Effects}
+#'    \describe{
+#'      \item{\code{type = ""pred""}}{Predicted values (marginal effects) for specific model terms. See \code{\link[ggeffects]{ggpredict}} for details.}
+#'      \item{\code{type = ""eff""}}{Similar to \code{type = ""pred""}, however, discrete predictors are held constant at their proportions (not reference level). See \code{\link[ggeffects]{ggeffect}} for details.}
+#'      \item{\code{type = ""int""}}{Marginal effects of interaction terms in \code{model}.}
+#'    }
+#'    \emph{Model diagnostics}
+#'    \describe{
+#'      \item{\code{type = ""diag""}}{Check model assumptions.}
+#'    }
 #' @param exponentiate Logical, if \code{TRUE} and models inherit from generalized
-#'          linear models, estimates will be exponentiated (e.g., log-odds will
-#'          be displayed as odds ratios). By default, \code{exponentiate} will
-#'          automatically be set to \code{FALSE} or \code{TRUE}, depending on
-#'          the class of \code{fit}.
-#' @param rm.terms Character vector with names that indicate which terms should
-#'          be removed from the plot. Counterpart to \code{terms}.
-#'          \code{rm.terms = ""t_name""} would remove the term \emph{t_name}.
-#'          Default is \code{NULL}, i.e. all terms are used. Note that this
-#'          argument does not apply to \code{type = ""eff""}, \code{type = ""pred""}
-#'          or \code{type = ""int""}.
+#'    linear models, estimates will be exponentiated (e.g., log-odds will
+#'    be displayed as odds ratios). By default, \code{exponentiate} will
+#'    automatically be set to \code{FALSE} or \code{TRUE}, depending on
+#'    the class of \code{fit}.
 #' @param terms Character vector with the names of those terms from \code{model}
-#'          that should be plotted. This argument depends on the plot-type:
-#'          \describe{
-#'            \item{\code{type = ""est""}}{
-#'              Select terms that should be plotted. All other term are removed
-#'              from the output.
-#'            }
-#'            \item{\code{type = ""pred""} or \code{type = ""eff""}}{
-#'              Here \code{terms} indicates for which terms marginal effects
-#'              should be displayed. At least one term is required to calculate
-#'              effects, maximum length is three terms, where the second and
-#'              third term indicate the groups, i.e. predictions of first term
-#'              are grouped by the levels of the second (and third) term.
-#'              Indicating levels in square brackets allows for selecting only
-#'              specific groups. Term name and levels in brackets must be separated
-#'              by a whitespace character, e.g. \code{terms = c(""age"", ""education [1,3]"")}.
-#'              For more details, see \code{\link[ggeffects]{ggpredict}}.
-#'            }
-#'          }
+#'    that should be plotted. This argument depends on the plot-type:
+#'    \describe{
+#'      \item{\emph{Coefficients}}{
+#'        Select terms that should be plotted. All other term are removed
+#'        from the output.
+#'      }
+#'      \item{\emph{Marginal Effects}}{
+#'        Here \code{terms} indicates for which terms marginal effects
+#'        should be displayed. At least one term is required to calculate
+#'        effects, maximum length is three terms, where the second and
+#'        third term indicate the groups, i.e. predictions of first term
+#'        are grouped by the levels of the second (and third) term.
+#'        Indicating levels in square brackets allows for selecting only
+#'        specific groups. Term name and levels in brackets must be separated
+#'        by a whitespace character, e.g. \code{terms = c(""age"", ""education [1,3]"")}.
+#'        For more details, see \code{\link[ggeffects]{ggpredict}}.
+#'      }
+#'    }
+#' @param sort.est Determines in which way estimates are sorted in the plot:
+#'    \itemize{
+#'      \item If \code{NULL} (default), no sorting is done and estimates are sorted in the same order as they appear in the model formula.
+#'      \item If \code{TRUE}, estimates are sorted in descending order, with highedt estimate at the top.
+#'      \item If \code{sort.est = ""sort.all""}, estimates are re-sorted for each coefficient (only applies if \code{type = ""re""} and \code{facets = FALSE}), i.e. the estimates of the random effects for each predictor are sorted and plotted to an own plot.
+#'      \item If \code{type = ""re""}, specify a predictor's / coefficient's name to sort estimates according to this random effect.
+#'    }
+#' @param rm.terms Character vector with names that indicate which terms should
+#'    be removed from the plot. Counterpart to \code{terms}.
+#'    \code{rm.terms = ""t_name""} would remove the term \emph{t_name}.
+#'    Default is \code{NULL}, i.e. all terms are used. Note that this
+#'    argument does not apply to \code{type = ""eff""}, \code{type = ""pred""}
+#'    or \code{type = ""int""}.
+#' @param group.terms Numeric vector with group indices, to group coefficients.
+#'    Each group of coefficients gets its own color (see 'Examples').
+#' @param order.terms Numeric vector, indicating in which order the coefficients
+#'    should be plotted. See examples in
+#'    \href{../doc/plot_model_estimates.html}{this package-vignette}.
+#' @param pred.type Character, only applies for \emph{Marginal Effects} plots
+#'    with mixed effects models. Indicates whether predicted values should be
+#'    conditioned on random effects (\code{pred.type = ""re""}) or fixed effects
+#'    only (\code{pred.type = ""fe""}, the default).
+#' @param ri.nr Numeric vector. If \code{type = ""re""} or \code{type = ""ri.slope""},
+#'    and fitted model has more than one random intercept, \code{ri.nr} indicates
+#'    which random effects of which random intercept (or: which list elements
+#'    of \code{\link[lme4]{ranef}}) will be plotted. Default is \code{NULL},
+#'    so all random effects will be plotted.
+#' @param title Character vector, used as plot title. By default,
+#'    \code{\link[sjlabelled]{get_dv_labels}} is called to retrieve the
+#'    label of the dependent variable, which will be used as title. Use
+#'    \code{title = """"} to remove title.
 #' @param axis.title Character vector of length one or two (depending on
-#'          the plot function and type), used as title(s) for the x and y axis.
-#'          If not specified, a default labelling  is chosen. \strong{Note:}
-#'          Some plot types may not support this argument sufficiently. In such
-#'          cases, use the returned ggplot-object and add axis titles manually with
-#'          \code{\link[ggplot2]{labs}}.
+#'    the plot function and type), used as title(s) for the x and y axis.
+#'    If not specified, a default labelling  is chosen. \strong{Note:}
+#'    Some plot types may not support this argument sufficiently. In such
+#'    cases, use the returned ggplot-object and add axis titles manually with
+#'    \code{\link[ggplot2]{labs}}. Use \code{axis.title = """"} to remove axis
+#'    titles.
+#' @param axis.labels Character vector with labels for the model terms, used as
+#'    axis labels. By default, \code{\link[sjlabelled]{get_term_labels}} is
+#'    called to retrieve the labels of the coefficients, which will be used as
+#'    axis labels. Use \code{axis.labels = """"} or \code{auto.label = FALSE}
+#'    to use the bare term names as labels instead.
+#' @param axis.lim Numeric vector of length 2, defining the range of the plot
+#'    axis. Depending on plot-type, may effect either x- or y-axis. For
+#'    \emph{Marginal Effects} plots, \code{axis.lim} may also be a list of two
+#'    vectors of length 2, defining axis limits for both the x and y axis.
+#' @param grid.breaks Numeric; sets the distance between breaks for the axis,
+#'    i.e. at every \code{grid.breaks}'th position a major grid is plotted.
+#' @param ci.lvl Numeric, the level of the confidence intervals (error bars).
+#'    Use \code{ci.lvl = NA} to remove error bars. For \code{stanreg}-models,
+#'    \code{ci.lvl} defines the (outer) probability for the \code{\link[sjstats]{hdi}}
+#'    (High Density Interval) that is plotted. By default, \code{stanreg}-models
+#'    are printed with two intervals: the ""inner"" interval, which defaults to
+#'    the 50\%-HDI; and the ""outer"" interval, which defaults to the 89\%-HDI.
+#'    \code{ci.lvl} affects only the outer interval in such cases. See
+#'    \code{prob.inner} and \code{prob.outer} under the \code{...}-argument
+#'    for more details.
 #' @param show.intercept Logical, if \code{TRUE}, the intercept of the fitted
-#'          model is also plotted. Default is \code{FALSE}. If \code{exponentiate = TRUE},
-#'          please note that due to exponential transformation of estimates, the
-#'          intercept in some cases is non-finite and the plot can not be created.
-#' @param ... Other arguments, passed down to various functions. Here is the
-#'        description of these arguments in detail.
-#'        \describe{
-#'          \item{\code{auto.label}}{
-#'            Logical value, if \code{TRUE} (the default), plot-labels are based
-#'            on value and variable labels, if the data is labelled. See
-#'            \code{\link[sjlabelled]{get_label}} and
-#'            \code{\link[sjlabelled]{get_term_labels}} for details.
-#'          }
-#'          \item{\code{value.size}}{
-#'            Numeric value, which can be used for all plot types where the
-#'            argument \code{show.values} is applicable, e.g.
-#'            \code{value.size = 4}.
-#'          }
-#'          \item{\code{prob.inner} and \code{prob.outer}}{
-#'            For \code{stanreg}-models (fitted with the \pkg{rstanarm}-package)
-#'            and plot-type \code{type = ""est""}, you can specify numeric values
-#'            between 0 and 1 for \code{prob.inner} and \code{prob.outer}, which
-#'            will then be used as inner and outer probabilities for the uncertainty
-#'            intervals (HDI). By default, the inner probability is 0.5 and the
-#'            outer probability is 0.89 (unless \code{ci.lvl} is specified - in
-#'            this case, \code{ci.lvl} is used as outer probability).
-#'          }
-#'          \item{\code{bpe}}{
-#'            Also for \code{stanreg}-models (fitted with the \pkg{rstanarm}-package),
-#'            the Bayesian point estimate is, by default, the median of the posterior
-#'            distribution. Use \code{bpe} to define other functions to calculate
-#'            the Bayesion point estimate. \code{bpe} needs to be a character naming
-#'            the specific function, which is passed to the \code{fun}-argument
-#'            in \code{\link[sjstats]{typical_value}}. So, \code{bpe = ""mean""}
-#'            would calculate the mean value of the posterior distribution.
-#'          }
-#'          \item{\code{bpe.style}}{
-#'            Again for \code{stanreg}-models (fitted with the \pkg{rstanarm}-package),
-#'            the Bayesian point estimate is indicated as a small, vertical line
-#'            by default. Use \code{bpe.style = ""dot""} to plot a dot instead
-#'            of a line for the point estimate.
-#'          }
-#'        }
+#'    model is also plotted. Default is \code{FALSE}. If \code{exponentiate = TRUE},
+#'    please note that due to exponential transformation of estimates, the
+#'    intercept in some cases is non-finite and the plot can not be created.
+#' @param show.values Logical, whether values should be plotted or not.
+#' @param show.p Logical, adds asterisks that indicate the significance level
+#'    of estimates to the value labels.
+#' @param show.data Logical, for \emph{Marginal Effects} plots, also plots
+#'    the raw data points.
+#' @param value.offset Numeric, offset for text labels to adjust their position
+#'    relative to the dots or lines.
+#' @param dot.size Numeric, size of the dots that indicate the point estimates.
+#' @param line.size Numeric, size of the lines that indicate the error bars.
+#' @param colors May be a character vector of color values in hex-format, valid
+#'    color value names (see \code{demo(""colors"")} or a name of a
+#'    \href{http://colorbrewer2.org}{color brewer} palette. Following options
+#'    are valid for the \code{colors} argument:
+#'    \itemize{
+#'      \item If not specified, a default color brewer palette will be used, which is suitable for the plot style.
+#'      \item If \code{""gs""}, a greyscale will be used.
+#'      \item If \code{""bw""}, and plot-type is a line-plot, the plot is black/white and uses different line types to distinguish groups (see \href{../doc/blackwhitefigures.html}{this package-vignette}).
+#'      \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
+#'      \item Else specify own color values or names as vector (e.g. \code{colors = ""#00ff00""}).
+#'    }
+#' @param facets Logical, if \code{TRUE} multiple plots are plotted as facet grid.
+#' @param wrap.title Numeric, determines how many chars of the plot title are
+#'    displayed in one line and when a line break is inserted.
+#' @param wrap.labels Numeric, determines how many chars of the value, variable
+#'    or axis labels are displayed in one line and when a line break is inserted.
+#' @param case Desired target case. Labels will automatically converted into the
+#'    specified character case. See \code{\link[snakecase]{to_any_case}} for
+#'    more details on this argument.
+#' @param auto.label Logical, if \code{TRUE} (the default), plot-labels are based
+#'    on value and variable labels, if the data is labelled. See
+#'    \code{\link[sjlabelled]{get_label}} and \code{\link[sjlabelled]{get_term_labels}}
+#'    for details.
+#' @param digits Numeric, amount of digits after decimal point when rounding
+#'    estimates or values.
+#' @param value.size Numeric, indicates the size of value labels. Can be used
+#'    for all plot types where the argument \code{show.values} is applicable,
+#'    e.g. \code{value.size = 4}.
+#' @param vline.color Color of the vertical ""zero effect"" line. Default color
+#'    is inherited from the current theme.
+#' @param bpe For \code{stanreg}-models (fitted with the \pkg{rstanarm}-package),
+#'    the Bayesian point estimate is, by default, the median of the posterior
+#'    distribution. Use \code{bpe} to define other functions to calculate the
+#'    Bayesion point estimate. \code{bpe} needs to be a character naming the
+#'    specific function, which is passed to the \code{fun}-argument in
+#'    \code{\link[sjstats]{typical_value}}. So, \code{bpe = ""mean""} would
+#'    calculate the mean value of the posterior distribution.
+#' @param bpe.style For \code{stanreg}-models (fitted with the \pkg{rstanarm}-package),
+#'    the Bayesian point estimate is indicated as a small, vertical line by
+#'    default. Use \code{bpe.style = ""dot""} to plot a dot instead of a line
+#'    for the point estimate.
+#' @param ... Other arguments, passed down to various functions. Here is a list
+#'    of supported arguments and their description in detail.
+#'    \describe{
+#'      \item{\code{prob.inner} and \code{prob.outer}}{
+#'        For \code{stanreg}-models (fitted with the \pkg{rstanarm}-package)
+#'        and plot-type \code{type = ""est""}, you can specify numeric values
+#'        between 0 and 1 for \code{prob.inner} and \code{prob.outer}, which
+#'        will then be used as inner and outer probabilities for the uncertainty
+#'        intervals (HDI). By default, the inner probability is 0.5 and the
+#'        outer probability is 0.89 (unless \code{ci.lvl} is specified - in
+#'        this case, \code{ci.lvl} is used as outer probability).
+#'      }
+#'      \item{\code{size.inner}}{
+#'        For \code{stanreg}-models and plot-type \code{type = ""est""}, you
+#'        can specify the width of the bar for the inner probabilities.
+#'        Default is \code{0.1}.
+#'      }
+#'      \item{\code{width}, \code{alpha} and \code{scale}}{
+#'        Passed down to \code{geom_errorbar()} or \code{geom_density_ridges()},
+#'        for forest or diagnostic plots; or passed down to
+#'        \code{\link[ggeffects]{plot.ggeffects}} for marginal effects plots.
+#'      }
+#'      \item{\emph{Marginal Effects} plot-types}{
+#'        When plotting marginal effects, arguments are also passed down to
+#'        \code{\link[ggeffects]{ggpredict}}, \code{\link[ggeffects]{ggeffect}}
+#'        or \code{\link[ggeffects]{plot.ggeffects}}.
+#'      }
+#'    }
+#'
+#' @return Depending on the plot-type, \code{plot_model()} returns a
+#'   \code{ggplot}-object or a list of such objects. \code{get_model_data}
+#'   returns the associated data with the plot-object as tidy data frame,
+#'   or (depending on the plot-type) a list of such data frames.
+#'
+#' @details \code{get_model_data} simply calls \code{plot_model()} and returns
+#'   the data from the ggplot-object. Hence, it is rather inefficient and should
+#'   be used as alternative to \pkg{brooms} \code{tidy()}-function only in
+#'   specific situations.
+#'   \cr \cr
+#'   Some notes on the different plot-types:
+#'   \describe{
+#'     \item{\code{type = ""std2""}}{
+#'       Plots standardized beta values, however, standardization follows
+#'       Gelman's (2008) suggestion, rescaling the estimates by dividing them
+#'       by two standard deviations instead of just one. Resulting coefficients
+#'       are then directly comparable for untransformed binary predictors. This
+#'       standardization uses the \code{\link[arm]{standardize}}-function from
+#'       the \pkg{arm}-package.
+#'     }
+#'     \item{\code{type = ""pred""}}{
+#'       Plots marginal effetcs. Simply wraps \code{\link[ggeffects]{ggpredict}}.
+#'     }
+#'     \item{\code{type = ""eff""}}{
+#'       Plots marginal effetcs. Simply wraps \code{\link[ggeffects]{ggeffect}}.
+#'     }
+#'   }
+#'
+#' @note \code{plot_model()} replaces the functions \code{sjp.lm}, \code{sjp.glm},
+#'   \code{sjp.lmer} and \code{sjp.glmer}. These are becoming softly deprecated
+#'   and will be removed in a future update.
+#'
+#' @references Gelman A (2008) ""Scaling regression inputs by dividing by two standard deviations."" \emph{Statistics in Medicine 27: 28652873.} \url{http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf}
+#'
+#' @seealso Package-vignette about \href{../doc/plot_model_estimates.html}{plot_model()}.
+#'
+#' @examples
+#' # prepare data
+#' library(sjmisc)
+#' data(efc)
+#' efc <- to_factor(efc, c161sex, e42dep, c172code)
+#' m <- lm(neg_c_7 ~ pos_v_4 + c12hour + e42dep + c172code, data = efc)
+#'
+#' # simple forest plot
+#' plot_model(m)
+#'
+#' # grouped coefficients
+#' plot_model(m, group.terms = c(1, 2, 3, 3, 3, 4, 4))
+#'
+#' # plot random effects
+#' library(lme4)
+#' m <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
+#' plot_model(m, type = ""re"")
+#'
+#' # plot marginal effects
+#' plot_model(m, type = ""eff"", terms = ""Days"")
+#'
+#' # plot Stan-model
+#' \dontrun{
+#' if (require(""rstanarm"")) {
+#'   data(mtcars)
+#'   m <- stan_glm(mpg ~ wt + am + cyl + gear, data = mtcars, chains = 1)
+#'   plot_model(m, bpe.style = ""dot"")
+#' }}
 #'
 #' @importFrom sjstats pred_vars std_beta p_value
 #' @importFrom sjmisc word_wrap str_contains
@@ -142,21 +295,18 @@ plot_model <- function(model,
                        wrap.title = 50,
                        wrap.labels = 25,
                        case = ""parsed"",
+                       auto.label = TRUE,
                        digits = 2,
+                       value.size,
                        vline.color = NULL,
+                       bpe = ""median"",
+                       bpe.style = ""line"",
                        ...
                        ) {
 
   type <- match.arg(type)
   pred.type <- match.arg(pred.type)
 
-  auto.label <- TRUE
-
-  # additional arguments?
-
-  add.args <- lapply(match.call(expand.dots = F)$`...`, function(x) x)
-  if (""auto.label"" %in% names(add.args)) auto.label <- add.args[[""auto.label""]]
-
 
   # get titles and labels for axis ----
 
@@ -236,6 +386,9 @@ plot_model <- function(model,
       line.size = line.size,
       order.terms = order.terms,
       vline.color = vline.color,
+      value.size = value.size,
+      bpe = bpe,
+      bpe.style = bpe.style,
       ...
     )
   } else if (type == ""re"") {
@@ -260,6 +413,7 @@ plot_model <- function(model,
       geom.size = dot.size,
       line.size = line.size,
       vline.color = vline.color,
+      value.size = value.size,
       ...
     )
 
@@ -311,6 +465,7 @@ plot_model <- function(model,
 }
 
 
+#' @importFrom purrr map
 #' @rdname plot_model
 #' @export
 get_model_data <- function(model,
@@ -323,26 +478,11 @@ get_model_data <- function(model,
                        order.terms = NULL,
                        pred.type = c(""fe"", ""re""),
                        ri.nr = NULL,
-                       title = NULL,
-                       axis.title = NULL,
-                       axis.labels = NULL,
-                       axis.lim = NULL,
-                       grid.breaks = NULL,
                        ci.lvl = NULL,
-                       show.intercept = FALSE,
-                       show.values = FALSE,
-                       show.p = TRUE,
-                       show.data = FALSE,
-                       value.offset = NULL,
-                       dot.size = NULL,
-                       line.size = NULL,
                        colors = ""Set1"",
                        facets,
-                       wrap.title = 50,
-                       wrap.labels = 25,
                        case = ""parsed"",
                        digits = 2,
-                       vline.color = NULL,
                        ...) {
   p <- plot_model(
     model = model,
@@ -355,28 +495,17 @@ get_model_data <- function(model,
     order.terms = order.terms,
     pred.type = pred.type,
     ri.nr = ri.nr,
-    title = title,
-    axis.title = axis.title,
-    axis.labels = axis.labels,
-    axis.lim = axis.lim,
-    grid.breaks = grid.breaks,
     ci.lvl = ci.lvl,
-    show.intercept = show.intercept,
-    show.values = show.values,
-    show.p = show.p,
-    show.data = show.data,
-    value.offset = value.offset,
-    dot.size = dot.size,
-    line.size = line.size,
     colors = colors,
     facets = facets,
-    wrap.title = wrap.title,
-    wrap.labels = wrap.labels,
     case = case,
     digits = digits,
-    vline.color = vline.color,
     ...
   )
 
-  p$data
+
+  if (inherits(p, ""list""))
+    purrr::map(p, ~ .x$data)
+  else
+    p$data
 }

---FILE: R/plot_model_estimates.R---
@@ -1,7 +1,7 @@
 #' @importFrom dplyr slice filter if_else
 #' @importFrom forcats fct_reorder fct_rev
 #' @importFrom rlang .data
-plot_model_estimates <- function(fit,
+plot_model_estimates <- function(model,
                                  dat,
                                  exponentiate,
                                  terms,
@@ -24,32 +24,34 @@ plot_model_estimates <- function(fit,
                                  bpe.style,
                                  term.order,
                                  vline.color,
-                                 value.size) {
+                                 value.size,
+                                 ...) {
 
   # remove intercept from output
 
-  if (!show.intercept) dat <- dplyr::slice(dat, -1)
+  if (!show.intercept && ""(Intercept)"" %in% dat$term)
+    dat <- dplyr::slice(dat, -1)
 
 
   # exponentiation from broom::tidy does not work with merMod-objecs,
   # so we do it manually for all model classes
 
-  if (exponentiate && !is.stan(fit)) {
+  if (exponentiate && !is.stan(model)) {
     dat[[""estimate""]] <- exp(dat[[""estimate""]])
     dat[[""conf.low""]] <- exp(dat[[""conf.low""]])
     dat[[""conf.high""]] <- exp(dat[[""conf.high""]])
   }
 
   # remove further estimates
 
-  filter.remove <- !(dat$term %in% terms)
-  if (!is.null(rm.terms)) dat <- dplyr::filter(dat, !! filter.remove)
+  filter.remove <- dat$term %in% terms
+  if (!is.null(terms)) dat <- dplyr::filter(dat, !! filter.remove)
 
 
   # or select further estimates
 
-  filter.remove <- dat$term %in% rm.terms
-  if (!is.null(terms)) dat <- dplyr::filter(dat, !! filter.remove)
+  filter.remove <- !(dat$term %in% rm.terms)
+  if (!is.null(rm.terms)) dat <- dplyr::filter(dat, !! filter.remove)
 
 
   # add p-asterisks to data
@@ -114,7 +116,7 @@ plot_model_estimates <- function(fit,
 
 
   plot_point_estimates(
-    model = fit,
+    model = model,
     dat = dat,
     exponentiate = exponentiate,
     title = title,
@@ -129,7 +131,8 @@ plot_model_estimates <- function(fit,
     geom.colors = geom.colors,
     bpe.style = bpe.style,
     vline.color = vline.color,
-    value.size = value.size
+    value.size = value.size,
+    ...
   )
 }
 

---FILE: R/plot_models.R---
@@ -19,7 +19,7 @@
 #' @param legend.pval.title Character vector, used as title of the plot legend that
 #'        indicates the p-values. Default is \code{""p-level""}. Only applies if
 #'        \code{p.shape = TRUE}.
-#' @param geom.spacing Numeric, spacing between the dots and error bars of the
+#' @param spacing Numeric, spacing between the dots and error bars of the
 #'        plotted fitted models. Default is 0.3.
 #' @param p.shape Logical, if \code{TRUE}, significant levels are distinguished by
 #'        different point shapes and a related legend is plotted. Default
@@ -34,7 +34,6 @@
 #' @return A ggplot-object.
 #'
 #' @examples
-#' library(sjmisc)
 #' data(efc)
 #'
 #' # fit three models
@@ -98,16 +97,17 @@ plot_models <- function(...,
                         wrap.labels = 25,
                         wrap.legend.title = 20,
                         grid.breaks = NULL,
-                        geom.size = 3,
-                        geom.spacing = 0.4,
-                        geom.colors = ""Set1"",
+                        dot.size = 3,
+                        spacing = 0.4,
+                        colors = ""Set1"",
                         show.values = FALSE,
                         show.legend = TRUE,
                         show.intercept = FALSE,
                         show.p = TRUE,
                         p.shape = FALSE,
+                        ci.lvl = .95,
                         vline.type = 2,
-                        vline.color = ""grey70"",
+                        vline.color = NULL,
                         digits = 2,
                         facet.grid = FALSE) {
   # retrieve list of fitted models
@@ -128,29 +128,36 @@ plot_models <- function(...,
 
   # tidy output
   if (!is.null(std.est)) {
+
     # for standardized estimates, we need to rename a column,
     # and manually add p-values to the output. intercept is already
     # removed from output
+
     fl <- input_list %>%
       purrr::map(~ sjstats::std_beta(.x, type = std.est)) %>%
       purrr::map(~ sjmisc::var_rename(.x, std.estimate = ""estimate"")) %>%
       purrr::map2(input_list, ~ tibble::add_column(
         .x, p.value = sjstats::p_value(.y)[[""p.value""]][-1])
       )
+
   } else {
+
     # if not standardized, we can get simple tidy output and
     # need to check whether intercept should be removed or not
+
     fl <- purrr::map(
-      input_list, ~ broom::tidy(.x, conf.int = TRUE, effects = ""fixed"")
+      input_list, ~ tidy_model(.x, ci.lvl, exponentiate, type = ""est"", bpe = ""line"", ...)
     )
 
     # remove intercept from output
     if (!show.intercept) fl <- purrr::map(fl, ~ dplyr::slice(.x, -1))
+
   }
 
 
   # exponentiation from broom::tidy does not work with merMod-objecs,
   # so we do it manually for all model classes
+
   if (exponentiate) fl <- purrr::map(fl, function(x) {
     x[[""estimate""]] <- exp(x[[""estimate""]])
     x[[""conf.low""]] <- exp(x[[""conf.low""]])
@@ -166,22 +173,30 @@ plot_models <- function(...,
   # merge models to one data frame
   ff <- dplyr::bind_rows(fl)
 
+
   # rename terms, if we did std2-type of standardization. pkg ""arm"" adds
   # a ""z."" suffix to each term name
+
   if (!is.null(std.est) && std.est == ""std2"")
     ff$term <- substring(ff$term, first = 3)
 
+
   # remove further estimates
+
   rems <- !(ff$term %in% rm.terms)
   if (!is.null(rm.terms)) ff <- dplyr::filter(ff, !! rems)
 
+
   # get labels of dependent variables, and wrap them if too long
+
   if (is.null(m.labels)) m.labels <- sjlabelled::get_dv_labels(input_list)
   m.labels <- sjmisc::word_wrap(m.labels, wrap = wrap.labels)
 
+
   # make sure we have distinct labels, because we use them as
   # factor levels. else, duplicated factor levels will be dropped,
   # leading to missing groups in plot output
+
   if (anyDuplicated(m.labels) > 0)
     m.labels <- suppressMessages(tibble::tidy_names(m.labels))
 
@@ -192,48 +207,74 @@ plot_models <- function(...,
   # reverse group, to plot correct order from top to bottom
   ff$group <- forcats::fct_rev(ff$group)
 
+
   # add p-asterisks to data
+
   ff$p.stars <- get_p_stars(ff$p.value)
   ff$p.label <- sprintf(""%.*f"", digits, ff$estimate)
   if (show.p) ff$p.label <- sprintf(""%s %s"", ff$p.label, ff$p.stars)
 
 
+  # axis limits and tick breaks for y-axis
+
+  axis.scaling <- get_axis_limits_and_ticks(
+    axis.lim = axis.lim,
+    min.val = min(ff$conf.low),
+    max.val = max(ff$conf.high),
+    grid.breaks = grid.breaks,
+    exponentiate = exponentiate,
+    min.est = min(ff$estimate),
+    max.est = max(ff$estimate)
+  )
+
+
+  # based on current ggplot theme, highlights vertical default line
+
+  yintercept = ifelse(exponentiate, 1, 0)
+  layer_vertical_line <- geom_intercep_line(yintercept, axis.scaling, vline.color)
+
+
   # set up base plot
+
   if (p.shape)
     p <- ggplot(ff, aes_string(x = ""term"", y = ""estimate"", colour = ""group"", shape = ""p.stars""))
   else
     p <- ggplot(ff, aes_string(x = ""term"", y = ""estimate"", colour = ""group""))
 
 
   p <- p +
-    geom_hline(yintercept = 0, linetype = vline.type, color = vline.color) +
-    geom_point(position = position_dodge(geom.spacing), size = geom.size) +
+    layer_vertical_line +
+    geom_point(position = position_dodge(spacing), size = dot.size) +
     geom_errorbar(
       aes_string(ymin = ""conf.low"", ymax = ""conf.high""),
-      position = position_dodge(geom.spacing),
+      position = position_dodge(spacing),
       width = 0
     ) +
     coord_flip() +
     guides(colour = guide_legend(reverse = TRUE))
 
 
   # show different shapes depending on p-value
+
   if (p.shape) p <- p +
     scale_shape_manual(
       values = c(1, 16, 17, 15),
       labels = c(""n.s."", ""*"", ""**"", ""***"")
     )
 
+
   # add value labels
+
   if (show.values) p <- p +
     geom_text(
       aes_string(label = ""p.label""),
-      position = position_dodge(geom.spacing),
-      vjust = geom.spacing * -1.5,
+      position = position_dodge(spacing),
+      vjust = spacing * -1.5,
       hjust = -.1,
       show.legend = FALSE
     )
 
+
   # check axis labels
   if (is.null(axis.labels)) axis.labels <- sjlabelled::get_term_labels(input_list)
 
@@ -248,17 +289,8 @@ plot_models <- function(...,
   if (facet.grid) p <- p + facet_grid(~group)
 
 
-  # axis limits and tick breaks for y-axis
-  axis.scaling <- get_axis_limits_and_ticks(
-    axis.lim = axis.lim,
-    min.val = min(ff$conf.low),
-    max.val = max(ff$conf.high),
-    grid.breaks = grid.breaks,
-    exponentiate = exponentiate
-  )
-
-
   # we need transformed scale for exponentiated estimates
+
   if (exponentiate) {
     p <- p + scale_y_continuous(
       trans = ""log10"",
@@ -276,9 +308,11 @@ plot_models <- function(...,
 
 
   # set colors
-  p <- p + scale_colour_manual(values = col_check2(geom.colors, length(m.labels)))
+  p <- p + scale_colour_manual(values = col_check2(colors, length(m.labels)))
+
 
   # set axis and plot titles
+
   p <-
     p + labs(
       x = NULL,

---FILE: R/plot_point_estimates.R---
@@ -16,13 +16,26 @@ plot_point_estimates <- function(model,
                                  geom.colors,
                                  bpe.style,
                                  vline.color,
-                                 value.size) {
+                                 value.size,
+                                 ...) {
+
+  # some defaults...
+
+  size.inner <- .1
+  width <- ifelse(is.stan(model), .06, 0)
+
+  # check additional arguments, for stan-geoms
+
+  add.args <- lapply(match.call(expand.dots = F)$`...`, function(x) x)
+  if (""size.inner"" %in% names(add.args)) size.inner <- add.args[[""size.inner""]]
+  if (""width"" %in% names(add.args)) width <- add.args[[""width""]]
+
 
   # need some additional data, for stan-geoms
 
   dat$xpos <- sjmisc::to_value(dat$term, start.at = 1)
-  dat$xmin <- dat$xpos - (geom.size * .1)
-  dat$xmax <- dat$xpos + (geom.size * .1)
+  dat$xmin <- dat$xpos - (geom.size * size.inner)
+  dat$xmax <- dat$xpos + (geom.size * size.inner)
 
 
   # set default for empty titles/labels
@@ -39,29 +52,16 @@ plot_point_estimates <- function(model,
     min.val = min(dat$conf.low),
     max.val = max(dat$conf.high),
     grid.breaks = grid.breaks,
-    exponentiate = exponentiate
+    exponentiate = exponentiate,
+    min.est = min(dat$estimate),
+    max.est = max(dat$estimate)
   )
 
 
   # based on current ggplot theme, highlights vertical default line
 
   yintercept = ifelse(exponentiate, 1, 0)
-
-  layer_vertical_line <- if (yintercept > axis.scaling$axis.lim[1] && yintercept < axis.scaling$axis.lim[2]) {
-    t <- theme_get()
-    color <- nulldef(vline.color, t$panel.grid.major$colour, ""grey90"")
-    minor_size <- nulldef(t$panel.grid.minor$size, .125)
-    major_size <- nulldef(t$panel.grid.major$size, minor_size * 2)
-    size <- major_size * 2
-    geom_hline(yintercept = yintercept, color = color, size = size)
-  } else {
-    geom_blank(
-      mapping = NULL,
-      data = NULL,
-      show.legend = FALSE,
-      inherit.aes = FALSE
-    )
-  }
+  layer_vertical_line <- geom_intercep_line(yintercept, axis.scaling, vline.color)
 
 
   # basis aes mapping
@@ -74,7 +74,7 @@ plot_point_estimates <- function(model,
     # special setup for rstan-models
     p <- p +
       layer_vertical_line +
-      geom_errorbar(aes_string(ymin = ""conf.low"", ymax = ""conf.high""), size = line.size, width = .06) +
+      geom_errorbar(aes_string(ymin = ""conf.low"", ymax = ""conf.high""), size = line.size, width = width) +
       geom_rect(aes_string(ymin = ""conf.low50"", ymax = ""conf.high50"", xmin = ""xmin"", xmax = ""xmax""), colour = ""white"", size = .5)
 
     # define style for Bayesian point estimate
@@ -91,7 +91,7 @@ plot_point_estimates <- function(model,
     p <- p +
       layer_vertical_line +
       geom_point(size = geom.size) +
-      geom_errorbar(aes_string(ymin = ""conf.low"", ymax = ""conf.high""), width = 0, size = line.size)
+      geom_errorbar(aes_string(ymin = ""conf.low"", ymax = ""conf.high""), width = width, size = line.size)
 
   }
 

---FILE: R/plot_type_eff.R---
@@ -56,8 +56,13 @@ plot_type_eff <- function(type,
     p <- p + ggtitle(title)
 
   # set axis limits
-  if (!is.null(axis.lim))
-    p <- p + ylim(axis.lim)
+  if (!is.null(axis.lim)) {
+    if (is.list(axis.lim))
+      p <- p + xlim(axis.lim[[1]]) + + ylim(axis.lim[[2]])
+    else
+      p <- p + ylim(axis.lim)
+  }
+
 
   p
 }

---FILE: R/plot_type_est.R---
@@ -23,12 +23,15 @@ plot_type_est <- function(type,
                           line.size,
                           order.terms,
                           vline.color,
+                          value.size,
+                          bpe,
+                          bpe.style,
                           ...) {
 
   # get tidy output of summary ----
 
   if (type == ""est"") {
-    dat <- tidy_model(model, ci.lvl, exponentiate, type, ...)
+    dat <- tidy_model(model, ci.lvl, exponentiate, type, bpe, ...)
   } else {
     dat <- model %>%
       sjstats::std_beta(type = type, ci.lvl = ci.lvl) %>%
@@ -42,19 +45,12 @@ plot_type_est <- function(type,
   # for stan-models, we can define the style of the Bayesian point estimate,
   # which may be a line or a dot.
 
-  bpe.style <- ""line""
-  value.size <- 4
-
-
-  # additional arguments for 'effects()'-function?
-
-  add.args <- lapply(match.call(expand.dots = F)$`...`, function(x) x)
-  if (""bpe.style"" %in% names(add.args)) bpe.style <- add.args[[""bpe.style""]]
-  if (""value.size"" %in% names(add.args)) value.size <- add.args[[""value.size""]]
+  if (missing(bpe.style) || is.null(bpe.style)) bpe.style <- ""line""
+  if (missing(value.size) || is.null(value.size)) value.size <- 4
 
 
   plot_model_estimates(
-    fit = model,
+    model = model,
     dat = dat,
     exponentiate = exponentiate,
     terms = terms,
@@ -77,6 +73,7 @@ plot_type_est <- function(type,
     bpe.style = bpe.style,
     term.order = order.terms,
     vline.color = vline.color,
-    value.size = value.size
+    value.size = value.size,
+    ...
   )
 }

---FILE: R/plot_type_ranef.R---
@@ -24,6 +24,7 @@ plot_type_ranef <- function(model,
                             geom.size,
                             line.size,
                             vline.color,
+                            value.size,
                             ...) {
 
   # get tidy output of summary ----
@@ -41,14 +42,8 @@ plot_type_ranef <- function(model,
   # set some initial values
 
   loops <- 1
-  value.size <- 3.5
   p <- list()
-
-
-  # additional arguments?
-
-  add.args <- lapply(match.call(expand.dots = F)$`...`, function(x) x)
-  if (""value.size"" %in% names(add.args)) value.size <- add.args[[""value.size""]]
+  if (missing(value.size) || is.null(value.size)) value.size <- 4
 
 
   # do we have a specific random intercept
@@ -248,7 +243,7 @@ plot_type_ranef <- function(model,
         # plot random effects
 
         plot_point_estimates(
-          model = fit,
+          model = model,
           dat = x,
           exponentiate = exponentiate,
           title = x[[""title""]],
@@ -262,7 +257,8 @@ plot_type_ranef <- function(model,
           line.size = line.size,
           geom.colors = geom.colors,
           vline.color = vline.color,
-          value.size = value.size
+          value.size = value.size,
+          ...
         )
       }
     )

---FILE: R/sjPlotGroupFrequencies.R---
@@ -79,7 +79,7 @@ utils::globalVariables(c(""."", ""label"", ""prz"", ""frq"", ""ypos"", ""wb"", ""ia"", ""mw"", ""
 #' @param smooth.lines prints a smooth line curve. Only applies, when argument \code{type = ""line""}.
 #' @param expand.grid logical, if \code{TRUE}, the plot grid is expanded, i.e. there is a small margin between
 #'          axes and plotting region. Default is \code{FALSE}.
-#' @param show.values logical, whether values should be plotted or not.
+#' @param show.values Logical, whether values should be plotted or not.
 #' @param show.n logical, if \code{TRUE}, adds total number of cases for each
 #'          group or category to the labels.
 #' @param show.axis.values logical, whether category, count or percentage values for the axis
@@ -137,7 +137,7 @@ utils::globalVariables(c(""."", ""label"", ""prz"", ""frq"", ""ypos"", ""wb"", ""ia"", ""mw"", ""
 #'            \item If \code{geom.colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
 #'            \item Else specify own color values or names as vector (e.g. \code{geom.colors = c(""#f00000"", ""#00ff00"")}).
 #'          }
-
+#'
 #' @examples
 #' # histrogram with EUROFAMCARE sample dataset
 #' library(sjmisc)

---FILE: R/sjplot_themes.R---
@@ -33,11 +33,26 @@
 #'          two-element numeric vector with values from 0-1.
 #' @param inside Logical, use \code{TRUE} to put legend inside the plotting area.
 #'        See also \code{pos}.
-#' @param theme Optional ggplot-theme-object, which is needed in case multiple
+#' @param base.theme Optional ggplot-theme-object, which is needed in case multiple
 #'        functions should be combined, e.g. \code{theme_sjplot() + label_angle()}.
-#'        In such cases, use \code{label_angle(theme = theme_sjplot())}.
-
-
+#'        In such cases, use \code{label_angle(base.theme = theme_sjplot())}.
+#'
+#' @examples
+#' # prepare data
+#' library(sjmisc)
+#' data(efc)
+#' efc <- to_factor(efc, c161sex, e42dep, c172code)
+#' m <- lm(neg_c_7 ~ pos_v_4 + c12hour + e42dep + c172code, data = efc)
+#'
+#' # create plot-object
+#' p <- plot_model(m)
+#'
+#' # change theme
+#' p + theme_sjplot()
+#'
+#' # change font-size
+#' p + font_size(axis_title.x = 30)
+#'
 #' @rdname sjPlot-themes
 #' @export
 theme_sjplot <- function(base_size = 12, base_family = """") {
@@ -107,10 +122,10 @@ theme_538 <- function(base_size = 12, base_family = """") {
 
 #' @rdname sjPlot-themes
 #' @export
-font_size <- function(title, axis_title.x, axis_title.y, labels.x, labels.y, offset.x, offset.y, theme) {
+font_size <- function(title, axis_title.x, axis_title.y, labels.x, labels.y, offset.x, offset.y, base.theme) {
   # get current theme
-  if (!missing(theme))
-    cur.theme <- theme
+  if (!missing(base.theme))
+    cur.theme <- base.theme
   else
     cur.theme <- theme_get()
 
@@ -155,10 +170,10 @@ font_size <- function(title, axis_title.x, axis_title.y, labels.x, labels.y, off
 
 #' @rdname sjPlot-themes
 #' @export
-label_angle <- function(angle.x, angle.y, theme) {
+label_angle <- function(angle.x, angle.y, base.theme) {
   # get current theme
-  if (!missing(theme))
-    cur.theme <- theme
+  if (!missing(base.theme))
+    cur.theme <- base.theme
   else
     cur.theme <- theme_get()
 
@@ -178,10 +193,10 @@ label_angle <- function(angle.x, angle.y, theme) {
 
 #' @rdname sjPlot-themes
 #' @export
-legend_style <- function(inside, pos, justify, theme) {
+legend_style <- function(inside, pos, justify, base.theme) {
   # get current theme
-  if (!missing(theme))
-    cur.theme <- theme
+  if (!missing(base.theme))
+    cur.theme <- base.theme
   else
     cur.theme <- theme_get()
 

---FILE: R/tidiers.R---
@@ -1,12 +1,14 @@
 ## TODO provide own tidier for not-supported models
 
-tidy_model <- function(model, ci.lvl, exponentiate, type, ...) {
+tidy_model <- function(model, ci.lvl, exponentiate, type, bpe, ...) {
   if (is.stan(model))
-    tidy_stan_model(model, ci.lvl, exponentiate, type, ...)
+    tidy_stan_model(model, ci.lvl, exponentiate, type, bpe, ...)
   else if (inherits(model, ""lme""))
     tidy_lme_model(model, ci.lvl)
   else if (inherits(model, ""gls""))
     tidy_gls_model(model, ci.lvl)
+  else if (inherits(model, ""coxph""))
+    tidy_cox_model(model, ci.lvl)
   else
     tidy_generic(model, ci.lvl)
 }
@@ -27,14 +29,30 @@ tidy_generic <- function(model, ci.lvl) {
   dat
 }
 
+
+#' @importFrom broom tidy
+#' @importFrom tibble has_name
+#' @importFrom sjstats p_value
+tidy_cox_model <- function(model, ci.lvl) {
+  # tidy the model
+  dat <- broom::tidy(model, conf.int = ci.lvl)
+
+  # see if we have p-values. if not, add them
+  if (!tibble::has_name(dat, ""p.value""))
+    dat$p.value <- sjstats::p_value(model)[[""p.value""]]
+
+  dat
+}
+
+
 #' @importFrom sjstats hdi typical_value
 #' @importFrom sjmisc var_rename add_columns is_empty
 #' @importFrom dplyr select filter slice
 #' @importFrom tibble add_column
 #' @importFrom purrr map_dbl
 #' @importFrom rlang .data
 #' @importFrom tidyselect starts_with
-tidy_stan_model <- function(fit, ci.lvl, exponentiate, type, ...) {
+tidy_stan_model <- function(model, ci.lvl, exponentiate, type, bpe, ...) {
 
   # check if values should be exponentiated
 
@@ -48,24 +66,22 @@ tidy_stan_model <- function(fit, ci.lvl, exponentiate, type, ...) {
 
   p.inner <- .5
   p.outer <- ci.lvl
-  best <- ""median""
 
 
   # additional arguments for 'effects()'-function?
   add.args <- lapply(match.call(expand.dots = F)$`...`, function(x) x)
 
-  # check whether we have ""prob.inner"", ""prob.outer"" and ""bpe"" argument
+  # check whether we have ""prob.inner"" and ""prob.outer"" argument
   # and if so, use these for HDI and Bayesian point estimate
 
   if (""prob.inner"" %in% names(add.args)) p.inner <- add.args[[""prob.inner""]]
   if (""prob.outer"" %in% names(add.args)) p.outer <- add.args[[""prob.outer""]]
-  if (""bpe"" %in% names(add.args)) best <- add.args[[""bpe""]]
 
 
   # get two HDI-intervals
 
-  d1 <- sjstats::hdi(fit, prob = p.outer, trans = funtrans, type = ""all"")
-  d2 <- sjstats::hdi(fit, prob = p.inner, trans = funtrans, type = ""all"")
+  d1 <- sjstats::hdi(model, prob = p.outer, trans = funtrans, type = ""all"")
+  d2 <- sjstats::hdi(model, prob = p.inner, trans = funtrans, type = ""all"")
 
 
   # bind columns, so we have inner and outer hdi interval
@@ -81,7 +97,7 @@ tidy_stan_model <- function(fit, ci.lvl, exponentiate, type, ...) {
 
   dat <- dat %>%
     tibble::add_column(
-      estimate = purrr::map_dbl(as.data.frame(fit), sjstats::typical_value, best),
+      estimate = purrr::map_dbl(as.data.frame(model), sjstats::typical_value, bpe),
       .after = 1
     ) %>%
     tibble::add_column(p.value = 0)

---FILE: R/utils.R---
@@ -10,19 +10,29 @@ is.stan <- function(x) inherits(x, c(""stanreg"", ""stanfit"", ""brmsfit""))
 #' @importFrom grDevices axisTicks
 #' @importFrom dplyr if_else
 #' @importFrom sjmisc is_empty
-get_axis_limits_and_ticks <- function(axis.lim, min.val, max.val, grid.breaks, exponentiate) {
+get_axis_limits_and_ticks <- function(axis.lim, min.val, max.val, grid.breaks, exponentiate, min.est, max.est) {
 
   # factor to multiply the axis limits. for exponentiated scales,
   # these need to be large enough to find appropriate pretty numbers
+
   fac.ll <- dplyr::if_else(exponentiate, .3, .95)
   fac.ul <- dplyr::if_else(exponentiate, 3.3, 1.05)
 
+
+  # check for correct boundaries
+
+  if (is.infinite(min.val) || is.na(min.val)) min.val <- min.est
+  if (is.infinite(max.val) || is.na(max.val)) max.val <- max.est
+
+
   # for negative signes, need to change multiplier
+
   if (min.val < 0) fac.ll <- 1 / fac.ll
   if (max.val < 0) fac.ul <- 1 / fac.ul
 
 
   # axis limits
+
   if (is.null(axis.lim)) {
     lower_lim <- min.val * fac.ll
     upper_lim <- max.val * fac.ul
@@ -31,18 +41,25 @@ get_axis_limits_and_ticks <- function(axis.lim, min.val, max.val, grid.breaks, e
     upper_lim <- axis.lim[2]
   }
 
+
   # determine gridbreaks
+
   if (is.null(grid.breaks)) {
     if (exponentiate) {
+
       # use pretty distances for log-scale
       ticks <- grDevices::axisTicks(log10(c(lower_lim, upper_lim)), log = TRUE)
+
       # truncate ticks to highest value below lower lim and
       # lowest value above upper lim
+
       ll <- which(ticks < lower_lim)
       if (!sjmisc::is_empty(ll) && length(ll) > 1) ticks <- ticks[ll[length(ll)]:length(ticks)]
+
       ul <- which(ticks > upper_lim)
       if (!sjmisc::is_empty(ul) && length(ul) > 1) ticks <- ticks[1:ul[1]]
-    } else {
+
+      } else {
       ticks <- pretty(c(lower_lim, upper_lim))
     }
   } else {
@@ -189,3 +206,22 @@ nulldef <- function(x, y, z = NULL) {
   } else
     x
 }
+
+
+geom_intercep_line <- function(yintercept, axis.scaling, vline.color) {
+  if (yintercept > axis.scaling$axis.lim[1] && yintercept < axis.scaling$axis.lim[2]) {
+    t <- theme_get()
+    color <- nulldef(vline.color, t$panel.grid.major$colour, ""grey90"")
+    minor_size <- nulldef(t$panel.grid.minor$size, .125)
+    major_size <- nulldef(t$panel.grid.major$size, minor_size * 2)
+    size <- major_size * 2
+    geom_hline(yintercept = yintercept, color = color, size = size)
+  } else {
+    geom_blank(
+      mapping = NULL,
+      data = NULL,
+      show.legend = FALSE,
+      inherit.aes = FALSE
+    )
+  }
+}

---FILE: man/efc.Rd---
@@ -0,0 +1,8 @@
+\docType{data}
+\name{efc}
+\alias{efc}
+\title{Sample dataset from the EUROFAMCARE project}
+\description{
+A SPSS sample data set, imported with the \code{\link[sjlabelled]{read_spss}} function.
+}
+\keyword{data}

---FILE: man/plot_model.Rd---
@@ -3,7 +3,7 @@
 \name{plot_model}
 \alias{plot_model}
 \alias{get_model_data}
-\title{Various plot types for regression models}
+\title{Plot regression models}
 \usage{
 plot_model(model, type = c(""est"", ""re"", ""eff"", ""pred"", ""int"", ""std"", ""std2"",
   ""slope"", ""resid"", ""diag""), exponentiate, terms = NULL, sort.est = NULL,
@@ -14,33 +14,40 @@ plot_model(model, type = c(""est"", ""re"", ""eff"", ""pred"", ""int"", ""std"", ""std2"",
   show.values = FALSE, show.p = TRUE, show.data = FALSE,
   value.offset = NULL, dot.size = NULL, line.size = NULL,
   colors = ""Set1"", facets, wrap.title = 50, wrap.labels = 25,
-  case = ""parsed"", digits = 2, vline.color = NULL, ...)
+  case = ""parsed"", auto.label = TRUE, digits = 2, value.size,
+  vline.color = NULL, bpe = ""median"", bpe.style = ""line"", ...)
 
 get_model_data(model, type = c(""est"", ""re"", ""eff"", ""pred"", ""int"", ""std"",
   ""std2"", ""slope"", ""resid"", ""diag""), exponentiate, terms = NULL,
   sort.est = NULL, rm.terms = NULL, group.terms = NULL,
   order.terms = NULL, pred.type = c(""fe"", ""re""), ri.nr = NULL,
-  title = NULL, axis.title = NULL, axis.labels = NULL, axis.lim = NULL,
-  grid.breaks = NULL, ci.lvl = NULL, show.intercept = FALSE,
-  show.values = FALSE, show.p = TRUE, show.data = FALSE,
-  value.offset = NULL, dot.size = NULL, line.size = NULL,
-  colors = ""Set1"", facets, wrap.title = 50, wrap.labels = 25,
-  case = ""parsed"", digits = 2, vline.color = NULL, ...)
+  ci.lvl = NULL, colors = ""Set1"", facets, case = ""parsed"", digits = 2,
+  ...)
 }
 \arguments{
-\item{type}{Type of plot. Use one of following:
+\item{model}{A regression model object. Depending on the \code{type}, many
+kinds of models are supported, e.g. from packages like \pkg{stats},
+\pkg{lme4}, \pkg{nlme}, \pkg{rstanarm}, \pkg{survey}, \pkg{glmmTMB},
+\pkg{MASS} etc.}
+
+\item{type}{Type of plot. There are three higher groups of plot-tyes:
+\cr \cr
+\emph{Coefficients}
+\describe{
+  \item{\code{type = ""est""}}{Forest-plot of estimates. If the fitted model only contains one predictor, slope-line is plotted.}
+  \item{\code{type = ""re""}}{For mixed effects models, plots the random effects.}
+  \item{\code{type = ""std""}}{Forest-plot of standardized beta values.}
+  \item{\code{type = ""std2""}}{Forest-plot of standardized beta values, however, standardization is done by dividing by two sd (see 'Details').}
+}
+\emph{Marginal Effects}
 \describe{
-  \item{\code{""est""}}{(default) for forest-plot of estimates. If the fitted model only contains one predictor, slope-line is plotted.}
-  \item{\code{""re""}}{for mixed effects models, plots the random effects.}
-  \item{\code{""pred""}}{to plot predicted values (marginal effects) for specific model terms. See \code{\link[ggeffects]{ggpredict}} for details.}
-  \item{\code{""eff""}}{similar to \code{type = ""pred""}, however, discrete predictors are held constant at their proportions (not reference level). See \code{\link[ggeffects]{ggeffect}} for details.}
-  \item{\code{""int""}}{to plot marginal effects of interaction terms in \code{model}.}
-  \item{\code{""std""}}{for forest-plot of standardized beta values.}
-  \item{\code{""std2""}}{for forest-plot of standardized beta values, however, standardization is done by dividing by two sd (see 'Details').}
-  \item{\code{""slope""}}{to plot regression lines for each single predictor of the fitted model, against the response (linear relationship between each model term and response).}
-  \item{\code{""resid""}}{to plot regression lines for each single predictor of the fitted model, against the residuals (linear relationship between each model term and residuals). May be used for model diagnostics.}
-  \item{\code{""diag""}}{to check model assumptions.}
-  \item{\code{""vif""}}{to plot Variance Inflation Factors.}
+  \item{\code{type = ""pred""}}{Predicted values (marginal effects) for specific model terms. See \code{\link[ggeffects]{ggpredict}} for details.}
+  \item{\code{type = ""eff""}}{Similar to \code{type = ""pred""}, however, discrete predictors are held constant at their proportions (not reference level). See \code{\link[ggeffects]{ggeffect}} for details.}
+  \item{\code{type = ""int""}}{Marginal effects of interaction terms in \code{model}.}
+}
+\emph{Model diagnostics}
+\describe{
+  \item{\code{type = ""diag""}}{Check model assumptions.}
 }}
 
 \item{exponentiate}{Logical, if \code{TRUE} and models inherit from generalized
@@ -52,11 +59,11 @@ the class of \code{fit}.}
 \item{terms}{Character vector with the names of those terms from \code{model}
 that should be plotted. This argument depends on the plot-type:
 \describe{
-  \item{\code{type = ""est""}}{
+  \item{\emph{Coefficients}}{
     Select terms that should be plotted. All other term are removed
     from the output.
   }
-  \item{\code{type = ""pred""} or \code{type = ""eff""}}{
+  \item{\emph{Marginal Effects}}{
     Here \code{terms} indicates for which terms marginal effects
     should be displayed. At least one term is required to calculate
     effects, maximum length is three terms, where the second and
@@ -75,7 +82,7 @@ that should be plotted. This argument depends on the plot-type:
   \item If \code{TRUE}, estimates are sorted in descending order, with highedt estimate at the top.
   \item If \code{sort.est = ""sort.all""}, estimates are re-sorted for each coefficient (only applies if \code{type = ""re""} and \code{facets = FALSE}), i.e. the estimates of the random effects for each predictor are sorted and plotted to an own plot.
   \item If \code{type = ""re""}, specify a predictor's / coefficient's name to sort estimates according to this random effect.
-  }}
+}}
 
 \item{rm.terms}{Character vector with names that indicate which terms should
 be removed from the plot. Counterpart to \code{terms}.
@@ -84,32 +91,136 @@ Default is \code{NULL}, i.e. all terms are used. Note that this
 argument does not apply to \code{type = ""eff""}, \code{type = ""pred""}
 or \code{type = ""int""}.}
 
+\item{group.terms}{Numeric vector with group indices, to group coefficients.
+Each group of coefficients gets its own color (see 'Examples').}
+
+\item{order.terms}{Numeric vector, indicating in which order the coefficients
+should be plotted. See examples in
+\href{../doc/plot_model_estimates.html}{this package-vignette}.}
+
+\item{pred.type}{Character, only applies for \emph{Marginal Effects} plots
+with mixed effects models. Indicates whether predicted values should be
+conditioned on random effects (\code{pred.type = ""re""}) or fixed effects
+only (\code{pred.type = ""fe""}, the default).}
+
+\item{ri.nr}{Numeric vector. If \code{type = ""re""} or \code{type = ""ri.slope""},
+and fitted model has more than one random intercept, \code{ri.nr} indicates
+which random effects of which random intercept (or: which list elements
+of \code{\link[lme4]{ranef}}) will be plotted. Default is \code{NULL},
+so all random effects will be plotted.}
+
+\item{title}{Character vector, used as plot title. By default,
+\code{\link[sjlabelled]{get_dv_labels}} is called to retrieve the
+label of the dependent variable, which will be used as title. Use
+\code{title = """"} to remove title.}
+
 \item{axis.title}{Character vector of length one or two (depending on
 the plot function and type), used as title(s) for the x and y axis.
 If not specified, a default labelling  is chosen. \strong{Note:}
 Some plot types may not support this argument sufficiently. In such
 cases, use the returned ggplot-object and add axis titles manually with
-\code{\link[ggplot2]{labs}}.}
+\code{\link[ggplot2]{labs}}. Use \code{axis.title = """"} to remove axis
+titles.}
+
+\item{axis.labels}{Character vector with labels for the model terms, used as
+axis labels. By default, \code{\link[sjlabelled]{get_term_labels}} is
+called to retrieve the labels of the coefficients, which will be used as
+axis labels. Use \code{axis.labels = """"} or \code{auto.label = FALSE}
+to use the bare term names as labels instead.}
+
+\item{axis.lim}{Numeric vector of length 2, defining the range of the plot
+axis. Depending on plot-type, may effect either x- or y-axis. For
+\emph{Marginal Effects} plots, \code{axis.lim} may also be a list of two
+vectors of length 2, defining axis limits for both the x and y axis.}
+
+\item{grid.breaks}{Numeric; sets the distance between breaks for the axis,
+i.e. at every \code{grid.breaks}'th position a major grid is plotted.}
+
+\item{ci.lvl}{Numeric, the level of the confidence intervals (error bars).
+Use \code{ci.lvl = NA} to remove error bars. For \code{stanreg}-models,
+\code{ci.lvl} defines the (outer) probability for the \code{\link[sjstats]{hdi}}
+(High Density Interval) that is plotted. By default, \code{stanreg}-models
+are printed with two intervals: the ""inner"" interval, which defaults to
+the 50\%-HDI; and the ""outer"" interval, which defaults to the 89\%-HDI.
+\code{ci.lvl} affects only the outer interval in such cases. See
+\code{prob.inner} and \code{prob.outer} under the \code{...}-argument
+for more details.}
 
 \item{show.intercept}{Logical, if \code{TRUE}, the intercept of the fitted
 model is also plotted. Default is \code{FALSE}. If \code{exponentiate = TRUE},
 please note that due to exponential transformation of estimates, the
 intercept in some cases is non-finite and the plot can not be created.}
 
-\item{...}{Other arguments, passed down to various functions. Here is the
-description of these arguments in detail.
+\item{show.values}{Logical, whether values should be plotted or not.}
+
+\item{show.p}{Logical, adds asterisks that indicate the significance level
+of estimates to the value labels.}
+
+\item{show.data}{Logical, for \emph{Marginal Effects} plots, also plots
+the raw data points.}
+
+\item{value.offset}{Numeric, offset for text labels to adjust their position
+relative to the dots or lines.}
+
+\item{dot.size}{Numeric, size of the dots that indicate the point estimates.}
+
+\item{line.size}{Numeric, size of the lines that indicate the error bars.}
+
+\item{colors}{May be a character vector of color values in hex-format, valid
+color value names (see \code{demo(""colors"")} or a name of a
+\href{http://colorbrewer2.org}{color brewer} palette. Following options
+are valid for the \code{colors} argument:
+\itemize{
+  \item If not specified, a default color brewer palette will be used, which is suitable for the plot style.
+  \item If \code{""gs""}, a greyscale will be used.
+  \item If \code{""bw""}, and plot-type is a line-plot, the plot is black/white and uses different line types to distinguish groups (see \href{../doc/blackwhitefigures.html}{this package-vignette}).
+  \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
+  \item Else specify own color values or names as vector (e.g. \code{colors = ""#00ff00""}).
+}}
+
+\item{facets}{Logical, if \code{TRUE} multiple plots are plotted as facet grid.}
+
+\item{wrap.title}{Numeric, determines how many chars of the plot title are
+displayed in one line and when a line break is inserted.}
+
+\item{wrap.labels}{Numeric, determines how many chars of the value, variable
+or axis labels are displayed in one line and when a line break is inserted.}
+
+\item{case}{Desired target case. Labels will automatically converted into the
+specified character case. See \code{\link[snakecase]{to_any_case}} for
+more details on this argument.}
+
+\item{auto.label}{Logical, if \code{TRUE} (the default), plot-labels are based
+on value and variable labels, if the data is labelled. See
+\code{\link[sjlabelled]{get_label}} and \code{\link[sjlabelled]{get_term_labels}}
+for details.}
+
+\item{digits}{Numeric, amount of digits after decimal point when rounding
+estimates or values.}
+
+\item{value.size}{Numeric, indicates the size of value labels. Can be used
+for all plot types where the argument \code{show.values} is applicable,
+e.g. \code{value.size = 4}.}
+
+\item{vline.color}{Color of the vertical ""zero effect"" line. Default color
+is inherited from the current theme.}
+
+\item{bpe}{For \code{stanreg}-models (fitted with the \pkg{rstanarm}-package),
+the Bayesian point estimate is, by default, the median of the posterior
+distribution. Use \code{bpe} to define other functions to calculate the
+Bayesion point estimate. \code{bpe} needs to be a character naming the
+specific function, which is passed to the \code{fun}-argument in
+\code{\link[sjstats]{typical_value}}. So, \code{bpe = ""mean""} would
+calculate the mean value of the posterior distribution.}
+
+\item{bpe.style}{For \code{stanreg}-models (fitted with the \pkg{rstanarm}-package),
+the Bayesian point estimate is indicated as a small, vertical line by
+default. Use \code{bpe.style = ""dot""} to plot a dot instead of a line
+for the point estimate.}
+
+\item{...}{Other arguments, passed down to various functions. Here is a list
+of supported arguments and their description in detail.
 \describe{
-  \item{\code{auto.label}}{
-    Logical value, if \code{TRUE} (the default), plot-labels are based
-    on value and variable labels, if the data is labelled. See
-    \code{\link[sjlabelled]{get_label}} and
-    \code{\link[sjlabelled]{get_term_labels}} for details.
-  }
-  \item{\code{value.size}}{
-    Numeric value, which can be used for all plot types where the
-    argument \code{show.values} is applicable, e.g.
-    \code{value.size = 4}.
-  }
   \item{\code{prob.inner} and \code{prob.outer}}{
     For \code{stanreg}-models (fitted with the \pkg{rstanarm}-package)
     and plot-type \code{type = ""est""}, you can specify numeric values
@@ -119,23 +230,95 @@ description of these arguments in detail.
     outer probability is 0.89 (unless \code{ci.lvl} is specified - in
     this case, \code{ci.lvl} is used as outer probability).
   }
-  \item{\code{bpe}}{
-    Also for \code{stanreg}-models (fitted with the \pkg{rstanarm}-package),
-    the Bayesian point estimate is, by default, the median of the posterior
-    distribution. Use \code{bpe} to define other functions to calculate
-    the Bayesion point estimate. \code{bpe} needs to be a character naming
-    the specific function, which is passed to the \code{fun}-argument
-    in \code{\link[sjstats]{typical_value}}. So, \code{bpe = ""mean""}
-    would calculate the mean value of the posterior distribution.
+  \item{\code{size.inner}}{
+    For \code{stanreg}-models and plot-type \code{type = ""est""}, you
+    can specify the width of the bar for the inner probabilities.
+    Default is \code{0.1}.
+  }
+  \item{\code{width}, \code{alpha} and \code{scale}}{
+    Passed down to \code{geom_errorbar()} or \code{geom_density_ridges()},
+    for forest or diagnostic plots; or passed down to
+    \code{\link[ggeffects]{plot.ggeffects}} for marginal effects plots.
   }
-  \item{\code{bpe.style}}{
-    Again for \code{stanreg}-models (fitted with the \pkg{rstanarm}-package),
-    the Bayesian point estimate is indicated as a small, vertical line
-    by default. Use \code{bpe.style = ""dot""} to plot a dot instead
-    of a line for the point estimate.
+  \item{\emph{Marginal Effects} plot-types}{
+    When plotting marginal effects, arguments are also passed down to
+    \code{\link[ggeffects]{ggpredict}}, \code{\link[ggeffects]{ggeffect}}
+    or \code{\link[ggeffects]{plot.ggeffects}}.
   }
 }}
 }
+\value{
+Depending on the plot-type, \code{plot_model()} returns a
+  \code{ggplot}-object or a list of such objects. \code{get_model_data}
+  returns the associated data with the plot-object as tidy data frame,
+  or (depending on the plot-type) a list of such data frames.
+}
 \description{
-To Do...
+\code{plot_model()} creates plots from regression models, either
+   estimates (as so-called forest or dot whisker plots) or marginal effects.
+}
+\details{
+\code{get_model_data} simply calls \code{plot_model()} and returns
+  the data from the ggplot-object. Hence, it is rather inefficient and should
+  be used as alternative to \pkg{brooms} \code{tidy()}-function only in
+  specific situations.
+  \cr \cr
+  Some notes on the different plot-types:
+  \describe{
+    \item{\code{type = ""std2""}}{
+      Plots standardized beta values, however, standardization follows
+      Gelman's (2008) suggestion, rescaling the estimates by dividing them
+      by two standard deviations instead of just one. Resulting coefficients
+      are then directly comparable for untransformed binary predictors. This
+      standardization uses the \code{\link[arm]{standardize}}-function from
+      the \pkg{arm}-package.
+    }
+    \item{\code{type = ""pred""}}{
+      Plots marginal effetcs. Simply wraps \code{\link[ggeffects]{ggpredict}}.
+    }
+    \item{\code{type = ""eff""}}{
+      Plots marginal effetcs. Simply wraps \code{\link[ggeffects]{ggeffect}}.
+    }
+  }
+}
+\note{
+\code{plot_model()} replaces the functions \code{sjp.lm}, \code{sjp.glm},
+  \code{sjp.lmer} and \code{sjp.glmer}. These are becoming softly deprecated
+  and will be removed in a future update.
+}
+\examples{
+# prepare data
+library(sjmisc)
+data(efc)
+efc <- to_factor(efc, c161sex, e42dep, c172code)
+m <- lm(neg_c_7 ~ pos_v_4 + c12hour + e42dep + c172code, data = efc)
+
+# simple forest plot
+plot_model(m)
+
+# grouped coefficients
+plot_model(m, group.terms = c(1, 2, 3, 3, 3, 4, 4))
+
+# plot random effects
+library(lme4)
+m <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
+plot_model(m, type = ""re"")
+
+# plot marginal effects
+plot_model(m, type = ""eff"", terms = ""Days"")
+
+# plot Stan-model
+\dontrun{
+if (require(""rstanarm"")) {
+  data(mtcars)
+  m <- stan_glm(mpg ~ wt + am + cyl + gear, data = mtcars, chains = 1)
+  plot_model(m, bpe.style = ""dot"")
+}}
+
+}
+\references{
+Gelman A (2008) ""Scaling regression inputs by dividing by two standard deviations."" \emph{Statistics in Medicine 27: 28652873.} \url{http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf}
+}
+\seealso{
+Package-vignette about \href{../doc/plot_model_estimates.html}{plot_model()}.
 }

---FILE: man/plot_models.Rd---
@@ -10,11 +10,11 @@ plot_models(..., exponentiate, std.est = NULL, rm.terms = NULL,
   title = NULL, m.labels = NULL, legend.title = ""Dependent Variables"",
   legend.pval.title = ""p-level"", axis.labels = NULL, axis.title = NULL,
   axis.lim = NULL, wrap.title = 50, wrap.labels = 25,
-  wrap.legend.title = 20, grid.breaks = NULL, geom.size = 3,
-  geom.spacing = 0.4, geom.colors = ""Set1"", show.values = FALSE,
+  wrap.legend.title = 20, grid.breaks = NULL, dot.size = 3,
+  spacing = 0.4, colors = ""Set1"", show.values = FALSE,
   show.legend = TRUE, show.intercept = FALSE, show.p = TRUE,
-  p.shape = FALSE, vline.type = 2, vline.color = ""grey70"", digits = 2,
-  facet.grid = FALSE)
+  p.shape = FALSE, ci.lvl = 0.95, vline.type = 2,
+  vline.color = ""grey70"", digits = 2, facet.grid = FALSE)
 
 sjp.lmm(...)
 
@@ -45,10 +45,10 @@ Default is \code{NULL}, i.e. all terms are used. Note that this
 argument does not apply to \code{type = ""eff""}, \code{type = ""pred""}
 or \code{type = ""int""}.}
 
-\item{title}{character vector, used as plot title. Depending on plot type and function,
-will be set automatically. If \code{title = """"}, no title is printed.
-For effect-plots, may also be a character vector of length > 1,
-to define titles for each sub-plot or facet.}
+\item{title}{Character vector, used as plot title. By default,
+\code{\link[sjlabelled]{get_dv_labels}} is called to retrieve the
+label of the dependent variable, which will be used as title. Use
+\code{title = """"} to remove title.}
 
 \item{m.labels}{Character vector, used to indicate the different models
 in the plot's legend. If not specified, the labels of the dependent
@@ -62,49 +62,55 @@ grouping estimates with \code{group.estimates}).}
 indicates the p-values. Default is \code{""p-level""}. Only applies if
 \code{p.shape = TRUE}.}
 
-\item{axis.labels}{character vector with labels used as axis labels. Optional
-argument, since in most cases, axis labels are set automatically.}
+\item{axis.labels}{Character vector with labels for the model terms, used as
+axis labels. By default, \code{\link[sjlabelled]{get_term_labels}} is
+called to retrieve the labels of the coefficients, which will be used as
+axis labels. Use \code{axis.labels = """"} or \code{auto.label = FALSE}
+to use the bare term names as labels instead.}
 
 \item{axis.title}{Character vector of length one or two (depending on
 the plot function and type), used as title(s) for the x and y axis.
 If not specified, a default labelling  is chosen. \strong{Note:}
 Some plot types may not support this argument sufficiently. In such
 cases, use the returned ggplot-object and add axis titles manually with
-\code{\link[ggplot2]{labs}}.}
+\code{\link[ggplot2]{labs}}. Use \code{axis.title = """"} to remove axis
+titles.}
 
-\item{axis.lim}{Numeric vector of length 2, defining the range of the plot axis.
-Depending on plot type, may effect either x- or y-axis, or both.
-For multiple plot outputs (e.g., from \code{type = ""eff""} or
-\code{type = ""slope""} in \code{\link{sjp.glm}}), \code{axis.lim} may
-also be a list of vectors of length 2, defining axis limits for each
-plot (only if non-faceted).}
+\item{axis.lim}{Numeric vector of length 2, defining the range of the plot
+axis. Depending on plot-type, may effect either x- or y-axis. For
+\emph{Marginal Effects} plots, \code{axis.lim} may also be a list of two
+vectors of length 2, defining axis limits for both the x and y axis.}
 
-\item{wrap.title}{numeric, determines how many chars of the plot title are displayed in
-one line and when a line break is inserted.}
+\item{wrap.title}{Numeric, determines how many chars of the plot title are
+displayed in one line and when a line break is inserted.}
 
-\item{wrap.labels}{numeric, determines how many chars of the value, variable or axis
-labels are displayed in one line and when a line break is inserted.}
+\item{wrap.labels}{Numeric, determines how many chars of the value, variable
+or axis labels are displayed in one line and when a line break is inserted.}
 
 \item{wrap.legend.title}{numeric, determines how many chars of the legend's title
 are displayed in one line and when a line break is inserted.}
 
-\item{grid.breaks}{numeric; sets the distance between breaks for the axis,
-i.e. at every \code{grid.breaks}'th position a major grid is being printed.}
+\item{grid.breaks}{Numeric; sets the distance between breaks for the axis,
+i.e. at every \code{grid.breaks}'th position a major grid is plotted.}
 
-\item{geom.size}{size resp. width of the geoms (bar width, line thickness or point size,
-depending on plot type and function). Note that bar and bin widths mostly
-need smaller values than dot sizes.}
+\item{dot.size}{Numeric, size of the dots that indicate the point estimates.}
 
-\item{geom.spacing}{Numeric, spacing between the dots and error bars of the
+\item{spacing}{Numeric, spacing between the dots and error bars of the
 plotted fitted models. Default is 0.3.}
 
-\item{geom.colors}{User defined color palette for geoms. If \code{group.estimates}
-is \emph{not} specified, must either be vector with two color values or a specific
-color palette code (see 'Details' in \code{\link{sjp.grpfrq}}). Else, if
-\code{group.estimates} is specified, \code{geom.colors} must be a vector
-of same length as groups. See 'Examples'.}
+\item{colors}{May be a character vector of color values in hex-format, valid
+color value names (see \code{demo(""colors"")} or a name of a
+\href{http://colorbrewer2.org}{color brewer} palette. Following options
+are valid for the \code{colors} argument:
+\itemize{
+  \item If not specified, a default color brewer palette will be used, which is suitable for the plot style.
+  \item If \code{""gs""}, a greyscale will be used.
+  \item If \code{""bw""}, and plot-type is a line-plot, the plot is black/white and uses different line types to distinguish groups (see \href{../doc/blackwhitefigures.html}{this package-vignette}).
+  \item If \code{colors} is any valid color brewer palette name, the related palette will be used. Use \code{\link[RColorBrewer]{display.brewer.all}} to view all available palette names.
+  \item Else specify own color values or names as vector (e.g. \code{colors = ""#00ff00""}).
+}}
 
-\item{show.values}{logical, whether values should be plotted or not.}
+\item{show.values}{Logical, whether values should be plotted or not.}
 
 \item{show.legend}{logical, if \code{TRUE}, and depending on plot type and
 function, a legend is added to the plot.}
@@ -114,18 +120,30 @@ model is also plotted. Default is \code{FALSE}. If \code{exponentiate = TRUE},
 please note that due to exponential transformation of estimates, the
 intercept in some cases is non-finite and the plot can not be created.}
 
-\item{show.p}{Logical, adds significance levels to values, or value and
-variable labels.}
+\item{show.p}{Logical, adds asterisks that indicate the significance level
+of estimates to the value labels.}
 
 \item{p.shape}{Logical, if \code{TRUE}, significant levels are distinguished by
 different point shapes and a related legend is plotted. Default
 is \code{FALSE}.}
 
+\item{ci.lvl}{Numeric, the level of the confidence intervals (error bars).
+Use \code{ci.lvl = NA} to remove error bars. For \code{stanreg}-models,
+\code{ci.lvl} defines the (outer) probability for the \code{\link[sjstats]{hdi}}
+(High Density Interval) that is plotted. By default, \code{stanreg}-models
+are printed with two intervals: the ""inner"" interval, which defaults to
+the 50\%-HDI; and the ""outer"" interval, which defaults to the 89\%-HDI.
+\code{ci.lvl} affects only the outer interval in such cases. See
+\code{prob.inner} and \code{prob.outer} under the \code{...}-argument
+for more details.}
+
 \item{vline.type}{Linetype of the vertical ""zero point"" line. Default is \code{2} (dashed line).}
 
-\item{vline.color}{Color of the vertical ""zero point"" line. Default value is \code{""grey70""}.}
+\item{vline.color}{Color of the vertical ""zero effect"" line. Default color
+is inherited from the current theme.}
 
-\item{digits}{Numeric, amount of digits after decimal point when rounding estimates and values.}
+\item{digits}{Numeric, amount of digits after decimal point when rounding
+estimates or values.}
 
 \item{facet.grid}{\code{TRUE} to arrange the lay out of of multiple plots
 in a grid of an integrated single plot. This argument calls

---FILE: man/sjPlot-themes.Rd---
@@ -20,11 +20,11 @@ theme_blank(base_size = 12, base_family = """")
 theme_538(base_size = 12, base_family = """")
 
 font_size(title, axis_title.x, axis_title.y, labels.x, labels.y, offset.x,
-  offset.y, theme)
+  offset.y, base.theme)
 
-label_angle(angle.x, angle.y, theme)
+label_angle(angle.x, angle.y, base.theme)
 
-legend_style(inside, pos, justify, theme)
+legend_style(inside, pos, justify, base.theme)
 }
 \arguments{
 \item{base_size}{Base font size.}
@@ -45,9 +45,9 @@ legend_style(inside, pos, justify, theme)
 
 \item{offset.y}{Offset for y-axis titles.}
 
-\item{theme}{Optional ggplot-theme-object, which is needed in case multiple
+\item{base.theme}{Optional ggplot-theme-object, which is needed in case multiple
 functions should be combined, e.g. \code{theme_sjplot() + label_angle()}.
-In such cases, use \code{label_angle(theme = theme_sjplot())}.}
+In such cases, use \code{label_angle(base.theme = theme_sjplot())}.}
 
 \item{angle.x}{Angle for x-axis labels.}
 
@@ -78,3 +78,20 @@ two-element numeric vector with values from 0-1.}
 \description{
 Set default theme plots.
 }
+\examples{
+# prepare data
+library(sjmisc)
+data(efc)
+efc <- to_factor(efc, c161sex, e42dep, c172code)
+m <- lm(neg_c_7 ~ pos_v_4 + c12hour + e42dep + c172code, data = efc)
+
+# create plot-object
+p <- plot_model(m)
+
+# change theme
+p + theme_sjplot()
+
+# change font-size
+p + font_size(axis_title.x = 30)
+
+}

---FILE: man/sjp.aov1.Rd---
@@ -68,7 +68,7 @@ labels are displayed in one line and when a line break is inserted.}
 \item{grid.breaks}{numeric; sets the distance between breaks for the axis,
 i.e. at every \code{grid.breaks}'th position a major grid is being printed.}
 
-\item{show.values}{logical, whether values should be plotted or not.}
+\item{show.values}{Logical, whether values should be plotted or not.}
 
 \item{digits}{Numeric, amount of digits after decimal point when rounding estimates and values.}
 

---FILE: man/sjp.corr.Rd---
@@ -54,7 +54,7 @@ function, a legend is added to the plot.}
 
 \item{legend.title}{character vector, used as title for the plot legend.}
 
-\item{show.values}{logical, whether values should be plotted or not.}
+\item{show.values}{Logical, whether values should be plotted or not.}
 
 \item{show.p}{Logical, adds significance levels to values, or value and
 variable labels.}

---FILE: man/sjp.fa.Rd---
@@ -63,7 +63,7 @@ one line and when a line break is inserted.}
 \item{wrap.labels}{numeric, determines how many chars of the value, variable or axis
 labels are displayed in one line and when a line break is inserted.}
 
-\item{show.values}{logical, whether values should be plotted or not.}
+\item{show.values}{Logical, whether values should be plotted or not.}
 
 \item{show.cronb}{Logical, if \code{TRUE} (default), the cronbach's alpha value for each factor scale will be calculated,
 i.e. all variables with the highest loading for a factor are taken for the

---FILE: man/sjp.frq.Rd---
@@ -95,7 +95,7 @@ i.e. at every \code{grid.breaks}'th position a major grid is being printed.}
 \item{expand.grid}{logical, if \code{TRUE}, the plot grid is expanded, i.e. there is a small margin between
 axes and plotting region. Default is \code{FALSE}.}
 
-\item{show.values}{logical, whether values should be plotted or not.}
+\item{show.values}{Logical, whether values should be plotted or not.}
 
 \item{show.n}{logical, if \code{TRUE}, adds total number of cases for each
 group or category to the labels.}

---FILE: man/sjp.glm.Rd---
@@ -107,7 +107,7 @@ Default is \code{FALSE}. For \code{glm}'s, please note that due to exponential
 transformation of estimates, the intercept in some cases can not be calculated, thus the
 function call is interrupted and no plot printed.}
 
-\item{show.values}{logical, whether values should be plotted or not.}
+\item{show.values}{Logical, whether values should be plotted or not.}
 
 \item{show.p}{Logical, adds significance levels to values, or value and
 variable labels.}

---FILE: man/sjp.glmer.Rd---
@@ -112,7 +112,7 @@ of same length as groups. See 'Examples'.}
 depending on plot type and function). Note that bar and bin widths mostly
 need smaller values than dot sizes.}
 
-\item{show.values}{logical, whether values should be plotted or not.}
+\item{show.values}{Logical, whether values should be plotted or not.}
 
 \item{show.p}{Logical, adds significance levels to values, or value and
 variable labels.}

---FILE: man/sjp.grpfrq.Rd---
@@ -92,7 +92,7 @@ need smaller values than dot sizes.}
 
 \item{geom.colors}{user defined color for geoms. See 'Details' in \code{\link{sjp.grpfrq}}.}
 
-\item{show.values}{logical, whether values should be plotted or not.}
+\item{show.values}{Logical, whether values should be plotted or not.}
 
 \item{show.n}{logical, if \code{TRUE}, adds total number of cases for each
 group or category to the labels.}

---FILE: man/sjp.int.Rd---
@@ -111,7 +111,7 @@ Either set \code{fill.color} to \code{NULL} or use 0 for \code{fill.alpha} if yo
 \item{fill.alpha}{Alpha value (transparancy) of the shaded area between the minimum and maximum lines. Default is 0.4.
 Use either 0 or set \code{fill.color} to \code{NULL} if you want to hide the shaded area.}
 
-\item{show.values}{logical, whether values should be plotted or not.}
+\item{show.values}{Logical, whether values should be plotted or not.}
 
 \item{show.ci}{Logical, if \code{TRUE}, depending on \code{type}, a confidence
 interval or region is added to the plot. For frequency plots, the

---FILE: man/sjp.lm.Rd---
@@ -107,7 +107,7 @@ plot (only if non-faceted).}
 \item{grid.breaks}{numeric; sets the distance between breaks for the axis,
 i.e. at every \code{grid.breaks}'th position a major grid is being printed.}
 
-\item{show.values}{logical, whether values should be plotted or not.}
+\item{show.values}{Logical, whether values should be plotted or not.}
 
 \item{show.p}{Logical, adds significance levels to values, or value and
 variable labels.}

---FILE: man/sjp.lmer.Rd---
@@ -122,7 +122,7 @@ color palette code (see 'Details' in \code{\link{sjp.grpfrq}}). Else, if
 \code{group.estimates} is specified, \code{geom.colors} must be a vector
 of same length as groups. See 'Examples'.}
 
-\item{show.values}{logical, whether values should be plotted or not.}
+\item{show.values}{Logical, whether values should be plotted or not.}
 
 \item{show.p}{Logical, adds significance levels to values, or value and
 variable labels.}

---FILE: man/sjp.pca.Rd---
@@ -56,7 +56,7 @@ one line and when a line break is inserted.}
 \item{wrap.labels}{numeric, determines how many chars of the value, variable or axis
 labels are displayed in one line and when a line break is inserted.}
 
-\item{show.values}{logical, whether values should be plotted or not.}
+\item{show.values}{Logical, whether values should be plotted or not.}
 
 \item{show.cronb}{Logical, if \code{TRUE} (default), the cronbach's alpha value for each factor scale will be calculated,
 i.e. all variables with the highest loading for a factor are taken for the

---FILE: man/sjp.stackfrq.Rd---
@@ -63,7 +63,7 @@ need smaller values than dot sizes.}
 
 \item{geom.colors}{user defined color for geoms. See 'Details' in \code{\link{sjp.grpfrq}}.}
 
-\item{show.values}{logical, whether values should be plotted or not.}
+\item{show.values}{Logical, whether values should be plotted or not.}
 
 \item{show.n}{logical, if \code{TRUE}, adds total number of cases for each
 group or category to the labels.}

---FILE: man/sjp.xtab.Rd---
@@ -59,7 +59,7 @@ Must be a vector of same length as the input vector. Default is
 
 \item{rev.order}{Logical, if \code{TRUE}, order of categories (groups) is reversed.}
 
-\item{show.values}{logical, whether values should be plotted or not.}
+\item{show.values}{Logical, whether values should be plotted or not.}
 
 \item{show.n}{logical, if \code{TRUE}, adds total number of cases for each
 group or category to the labels.}

---FILE: vignettes/blackwhitefigures.Rmd---
@@ -30,22 +30,12 @@ sjp.grpfrq(efc$e42dep, efc$c172code, geom.colors = ""gs"")
 
 ## Lineplots in b/w with different linetypes
 
-Similar to barplots, lineplots can be plotted in greyscale as well (with `geom.colors = ""gs""`). However, in most cases lines colored in greyscale are difficult to distinguish. In this case, certain plot types in **sjPlot** support black & white figures with different linetypes.
-
-Following plot-types allow black & white figures:
-
-* `sjp.grpfrq(type = ""line"")`
-* `sjp.int()`
-* `sjp.lm(type = ""pred"")`
-* `sjp.glm(type = ""pred"")`
-* `sjp.lmer(type = ""pred"")`
-* `sjp.glmer(type = ""pred"")`
-
-Use `geom.colors = ""bw""` to create a b/w-plot.
+Similar to barplots, lineplots - mostly from `plot_model()` - can be plotted in greyscale as well (with `colors = ""gs""`). However, in most cases lines colored in greyscale are difficult to distinguish. In this case, `plot_model()` supports black & white figures with different linetypes. Use `colors = ""bw""` to create a b/w-plot.
 
 ```{r}
 # create binrary response
 y <- ifelse(efc$neg_c_7 < median(na.omit(efc$neg_c_7)), 0, 1)
+
 # create data frame for fitting model
 df <- data.frame(
   y = to_factor(y),
@@ -54,12 +44,26 @@ df <- data.frame(
   barthel = efc$barthtot,
   education = to_factor(efc$c172code)
 )
+
 # set variable label for response
 set_label(df$y) <- ""High Negative Impact""
+
 # fit model
 fit <- glm(y ~., data = df, family = binomial(link = ""logit""))
-# print predicted propbabilities
-sjp.glm(fit, type = ""pred"", vars = c(""barthel"", ""sex"",""dep""), geom.colors = ""bw"")
+
+# plot marginal effects
+plot_model(
+  fit, 
+  type = ""pred"", 
+  terms = c(""barthel"", ""sex"",""dep""), 
+  colors = ""bw"",
+  ci.lvl = NA
+)
 ```
 
-Different linetypes do not apply to other linetyped plots (like `sjp.lm(type = ""eff"")` or `sjp.lm(type = ""slope"")`), because these usually only plot a single line - so there's no need for different linetypes, you can just set `geom.colors = ""black""` (or `geom.colors = ""bw""`).
+Different linetypes do not apply to all linetyped plots, if these usually only plot a single line - so there's no need for different linetypes, and you can just set `colors = ""black""` (or `colors = ""bw""`).
+
+```{r}
+# plot coefficients
+plot_model(fit, colors = ""black"")
+```

---FILE: vignettes/custplot.Rmd---
@@ -20,49 +20,60 @@ The examples refer to the `sjp.grpfrq` function, but most arguments are similar
 
 Tweaking plot appearance
 ------------------------
-The base function to globally change theme option for all sjp-function is `sjp.setTheme()`. Except for geom-colors and geom-sizes, all theme-options can be set via this function. This new theme will be applied to all following plots created with the `sjPlot` package.
+The base function to globally change theme option for all sjp-function is `set_theme()`. Except for geom-colors and geom-sizes, all theme-options can be set via this function. This new theme will be applied to all following plots created with the `sjPlot` package.
 
 There are various arguments to change colors, sizes, angles etc. of labels. Following example show changes to colors, sizes, angles, geom-outlines and theme.
 ```{r}
 # load libraries
 library(sjPlot)  # for plotting
 library(sjmisc)  # for sample data
 library(ggplot2) # to access ggplot-themes
+
 # load sample data set
 data(efc)
-sjp.setTheme(geom.outline.color = ""antiquewhite4"", 
-             geom.outline.size = 1, 
-             geom.label.size = 2,
-             geom.label.color = ""grey50"",
-             title.color = ""red"", 
-             title.size = 1.5, 
-             axis.angle.x = 45, 
-             axis.textcolor = ""blue"", 
-             base = theme_bw())
-sjp.grpfrq(efc$e42dep, 
-           efc$e16sex, 
-           title = NULL, 
-           geom.colors = c(""cadetblue"", ""coral""), 
-           geom.size = 0.4)
+
+set_theme(
+  geom.outline.color = ""antiquewhite4"", 
+  geom.outline.size = 1, 
+  geom.label.size = 2,
+  geom.label.color = ""grey50"",
+  title.color = ""red"", 
+  title.size = 1.5, 
+  axis.angle.x = 45, 
+  axis.textcolor = ""blue"", 
+  base = theme_bw()
+)
+
+sjp.grpfrq(
+  efc$e42dep, 
+  efc$e16sex, 
+  title = NULL, 
+  geom.colors = c(""cadetblue"", ""coral""), 
+  geom.size = 0.4
+)
 ```
 
 ### Using the Color Brewer palettes
+
 All plotting functions support the usage of the [Colorbrewer](http://colorbrewer2.org) palettes. To apply a color brewer palette, use specify the palette as `geom.colors`. Any valid color brewer palette is recognized automatically.
 
 ```{r}
 # blank theme
-sjp.setTheme(
+set_theme(
   base = theme_blank(),
   axis.title.size = .9,
   axis.textsize = .9,
   legend.size = .7,
   legend.title.size = .8,
   geom.label.size = 3
 )
-sjp.grpfrq(efc$e42dep, 
-           efc$e15relat, 
-           geom.colors = ""PuRd"", 
-           show.values = FALSE)
+
+sjp.grpfrq(
+  efc$e42dep, 
+  efc$e15relat, 
+  geom.colors = ""PuRd"", 
+  show.values = FALSE
+)
 ```
 
 An overview of all supported color codes can be obtained with `display.brewer.all()` from the `RColorBrewer` package.
@@ -77,38 +88,36 @@ Plot with flipped coordinates
 The plot's axes can be flipped using `coord.flip = TRUE`. If needed, labels can be placed inside the bars with the `vjust` or `hjust` arguments. In such cases, you might need to adjust the label colors with `geom.label.color = ""white""`.
 
 ```{r}
-sjp.setTheme(geom.label.color = ""white"",
-             geom.label.size = 3)
+set_theme(geom.label.color = ""white"", geom.label.size = 3)
+
 # labels appear very large due to export metrics
-sjp.grpfrq(efc$e42dep, 
-           efc$e16sex, 
-           coord.flip = TRUE)
+sjp.grpfrq(efc$e42dep, efc$e16sex, coord.flip = TRUE)
 ```
 
 Adding plot margins
 -------------------
 Plots with no margins towards the axes may look strange to some people (not to me, though). To restore the ggplot-default behaviour, use the `expand.grid` argument:
 
 ```{r results='hide', echo=FALSE}
-sjp.setTheme(axis.title.size = .9,
-             axis.textsize = .9,
-             legend.size = .7,
-             legend.title.size = .8,
-             geom.label.size = 3)
+set_theme(
+  axis.title.size = .9,
+  axis.textsize = .9,
+  legend.size = .7,
+  legend.title.size = .8,
+  geom.label.size = 3
+)
 ```
 
 ```{r}
-sjp.grpfrq(efc$e42dep,
-           efc$e16sex,
-           expand.grid = TRUE)
+sjp.grpfrq(efc$e42dep, efc$e16sex, expand.grid = TRUE)
 ```
 
 Theme options
 -------------
-You can use any pre-defined theme from ggplot, like `theme_bw()`, `theme_classic()` or `theme_minimal()` as default theme. See the list of supported themes at the online-help `?sjp.setTheme` under argument _theme_.
+You can use any pre-defined theme from ggplot, like `theme_bw()`, `theme_classic()` or `theme_minimal()` as default theme.
 
 ```{r}
-sjp.setTheme(base = theme_light())
+set_theme(base = theme_light())
 sjp.frq(efc$e42dep)
 ```
 
@@ -117,20 +126,12 @@ Pre-defined themes
 
 There is a set of pre-defined themes from the sjPlot-package. See `?""sjPlot-themes""` for a complete list.
 
-```{r}
-sjp.frq(efc$e42dep) + theme_blank()
-
-sjp.frq(efc$e42dep, geom.colors = ""#2255aa"") + theme_sjplot()
-```
-
-
 Set up own themes based on existing themes
 ------------------------------------------
 
 If you want to use a specific theme as base for building your own theme, use the `base` argument. When using `base` instead of `theme`, further arguments for settings colors etc. are not ignored.
 ```{r}
-sjp.setTheme(base = theme_bw(),            # bw-base
-             axis.linecolor = ""darkgreen"") # with green axes.
+set_theme(base = theme_bw(), axis.linecolor = ""darkgreen"")
 sjp.frq(efc$e42dep)
 ```
 
@@ -139,7 +140,7 @@ Further customization options
 -----------------------------
 Each plotting function invisibly returns the ggplot-object. You can further add options to customize the appearance of the plot, like in the following example, where the count axis is hidden (color set to white):
 ```{r}
-sjp.setTheme(
+set_theme(
   base = theme_classic(),
   axis.tickslen = 0, # hides tick marks
   axis.title.size = .9,
@@ -166,35 +167,39 @@ Plot legend
 The plot's legend can be customized via various `legend.`-arguments, see following examples:
 
 ```{r}
-sjp.setTheme(base = theme_classic(), 
-             legend.title.face = ""italic"", # title font face
-             legend.inside = TRUE,         # legend inside plot
-             legend.color = ""grey50"",      # legend label color
-             legend.pos = ""bottom right"",  # legend position inside plot
-             axis.title.size = .9,
-             axis.textsize = .9,
-             legend.size = .7,
-             legend.title.size = .8,
-             geom.label.size = 3)
-sjp.grpfrq(efc$e42dep, 
-           efc$e16sex, 
-           coord.flip = TRUE)
+set_theme(
+  base = theme_classic(), 
+  legend.title.face = ""italic"", # title font face
+  legend.inside = TRUE,         # legend inside plot
+  legend.color = ""grey50"",      # legend label color
+  legend.pos = ""bottom right"",  # legend position inside plot
+  axis.title.size = .9,
+  axis.textsize = .9,
+  legend.size = .7,
+  legend.title.size = .8,
+  geom.label.size = 3
+)
+
+sjp.grpfrq(efc$e42dep, efc$e16sex, coord.flip = TRUE)
 ```
 
 
 ```{r}
-sjp.setTheme(base = theme_classic(), 
-             axis.linecolor = ""white"",     # ""remove"" axis lines
-             axis.textcolor.y = ""darkred"", # set axis label text only for y axis
-             axis.tickslen = 0,            # ""remove"" tick marks
-             legend.title.color = ""red"",   # legend title color
-             legend.title.size = 2,        # legend title size
-             legend.color = ""green"",       # legend label color
-             legend.pos = ""top"",           # legend position above plot
-             axis.title.size = .9,
-             axis.textsize = .9,
-             legend.size = .7,
-             geom.label.size = 3)
+set_theme(
+  base = theme_classic(), 
+  axis.linecolor = ""white"",     # ""remove"" axis lines
+  axis.textcolor.y = ""darkred"", # set axis label text only for y axis
+  axis.tickslen = 0,            # ""remove"" tick marks
+  legend.title.color = ""red"",   # legend title color
+  legend.title.size = 2,        # legend title size
+  legend.color = ""green"",       # legend label color
+  legend.pos = ""top"",           # legend position above plot
+  axis.title.size = .9,
+  axis.textsize = .9,
+  legend.size = .7,
+  geom.label.size = 3
+)
+
 sjp.grpfrq(efc$e42dep, efc$e16sex)
 ```
 

---FILE: vignettes/plot_model_estimates.Rmd---
@@ -16,17 +16,19 @@ This document describes how to plot estimates as forest plots (or dot whisker pl
 
 `plot_model()` allows to create various plot tyes, which can be defined via the `type`-argument. The default is `type = ""fe""`, which means that fixed effects (model coefficients) are plotted. For mixed effects models, only fixed effects are plotted by default as well.
 
-```{r, results='hide'}
+```{r results='hide'}
 library(sjPlot)
-library(sjmisc)
 library(sjlabelled)
+library(ggplot2)
+
 data(efc)
+theme_set(theme_sjplot())
 ```
 
 
 ## Fitting a logistic regression model
 
-First, we fit an example model, which will be used in the following examples. The examples work in the same way for any other model as well.
+First, we fit a model that will be used in the following examples. The examples work in the same way for any other model as well.
 
 ```{r results='hide'}
 # create binary response
@@ -46,9 +48,6 @@ set_label(df$y) <- ""High Negative Impact""
 
 # fit model
 m1 <- glm(y ~., data = df, family = binomial(link = ""logit""))
-
-# set variable label for service usage
-set_label(efc$tot_sc_e) <- ""Total number of services used by carer""
 ```
 
 ## Plotting estimates of generalized linear models
@@ -67,9 +66,9 @@ plot_model(m1, vline.color = ""red"")
 
 ## Sorting estimates
 
-By default, the odds ratios are sorted from highest to lowest value. You can also keep the order of predictors as they were introduced into the model if you set `sort.est` to `FALSE`.
+By default, the estimates are sorted in the same order as they were introduced into the model. Use `sort.est = TRUE` to sort estimates in descending order, from highest to lowest value.
 ```{r}
-plot_model(m1, sort.est = FALSE)
+plot_model(m1, sort.est = TRUE)
 ``` 
 
 Another way to sort estimates is to use the `order.terms`-argument. This is a numeric vector, indicating the order of estimates in the plot. In the summary, we see that ""sex2"" is the first term, followed by the three dependency-categories (position 2-4), the Barthel-Index (5) and two levels for intermediate and high level of education (6 and 7).
@@ -94,9 +93,76 @@ plot_model(m1, exponentiate = FALSE)
 
 ## Showing value labels
 
-By default, just the dots and error bars are plotted. Use `show.values = TRUE` to show the value labels with the estimates values, and use `show.p = FALSE` to suppress the asterisks that indicate the significance level of the p-values.
+By default, just the dots and error bars are plotted. Use `show.values = TRUE` to show the value labels with the estimates values, and use `show.p = FALSE` to suppress the asterisks that indicate the significance level of the p-values. Use `value.offset` to adjust the relative positioning of value labels to the dots and lines.
 
 ```{r}
-plot_model(m1, show.values = TRUE)
+plot_model(m1, show.values = TRUE, value.offset = .3)
 ``` 
 
+## Labelling the plot
+
+As seen in the above examples, by default, the plotting-functions of **sjPlot** retrieve value and variable labels if the data is _labelled_, using the [sjlabelled-package](https://cran.r-project.org/package=sjlabelled). If the data is not labelled, the variable names are used. In such cases, use the arguments `title`, `axis.labels` and `axis.title` to annotate the plot title and axes. If you want variable names instead of labels, even for labelled data, use `""""` as argument-value, e.g. `axis.labels = """"`, or set `auto.label` to `FALSE`.
+
+Furthermore, `plot_model()` applies case-conversion to all labels by default, using the [snakecase-package](https://cran.r-project.org/package=snakecase). This converts labels into human-readable versions. Use `case = NULL` to turn case-conversion off.
+
+```{r}
+data(iris)
+m2 <- lm(Sepal.Length ~ Sepal.Width + Petal.Length + Species, data = iris)
+
+# variable names as labels, but made ""human readable""
+# separating dots are removed
+plot_model(m2)
+# to use variable names even for labelled data
+plot_model(m1, axis.labels = """", title = ""my own title"")
+```
+
+## Pick or remove specific terms from plot
+
+Use `terms` resp. `rm.terms` to select specific terms that should (not) be plotted.
+
+```{r}
+# keep only coefficients sex2, dep2 and dep3
+plot_model(m1, terms = c(""sex2"", ""dep2"", ""dep3""))
+# remove coefficients sex2, dep2 and dep3
+plot_model(m1, rm.terms = c(""sex2"", ""dep2"", ""dep3""))
+```
+
+## Standardized estimates
+
+For linear models, you can also plot standardized beta coefficients, using `type = ""std""` or `type = ""std2""`. These two options differ in the way how coefficients are standardized. `type = ""std2""` plots standardized beta values, however, standardization follows Gelman's (2008) suggestion, rescaling the estimates by dividing them by two standard deviations instead of just one.
+
+```{r}
+plot_model(m2, type = ""std"")
+```
+
+## Bayesian models from rstanarm
+
+`plot_model()` also supports stan-models fitted with the **rstanarm** package. However, there are a few differences compared to the previous plot examples.
+
+First, of course, there are no _confidence intervals_, but _uncertainty intervals_ - high density intervals, to be precise.
+
+Second, there's not just one interval range, but an inner and outer probability. By default, the inner probability is fixed to `.5`, while the outer probability is specified via `ci.lvl`. However, you can also use the arguments `prob.inner` and `prob.outer` to define the intervals boundaries.
+
+Third, the point estimate is by default the median, but can also be another value, like mean. This can be specified with the `bpe`-argument.
+
+```{r results='hide'}
+library(rstanarm)
+data(mtcars)
+m <- stan_glm(mpg ~ wt + am + cyl + gear, data = mtcars, chains = 1)
+
+# default model
+plot_model(m)
+# same model, with mean point estimate, dot-style for point estimate
+# and different inner/outer probabilities of the HDI
+plot_model(
+  m, 
+  bpe = ""mean"",
+  bpe.style = ""dot"",
+  prob.inner = .4,
+  prob.outer = .8
+)
+```
+
+# References
+
+Gelman A (2008) _Scaling regression inputs by dividing by two standard deviations._ Statistics in Medicine 27: 28652873.

---FILE: vignettes/sjpglm.Rmd---
@@ -20,7 +20,7 @@ library(sjmisc)
 library(sjlabelled)
 data(efc)
 # set basic theme options
-sjp.setTheme(
+set_theme(
   base = theme_sjplot(),
   axis.title.size = .85, 
   axis.textsize = .85, "
strengejacke,sjPlot,9762b47e3edc26aa194eee13fffdb04034687585,Daniel,mail@danielluedecke.de,2017-10-06T13:16:43Z,Daniel,mail@danielluedecke.de,2017-10-06T13:16:43Z,fixing issues for CRAN submission,DESCRIPTION;NAMESPACE;NEWS;R/plot_model.R;R/plot_model_estimates.R;R/plot_models.R;R/plot_point_estimates.R;R/plot_type_ranef.R;R/sjPlotFrequencies.R;R/sjPlotGLME.R;R/sjPlotInteractions.R;R/sjPlotLikert.R;R/sjPlotLinreg.R;R/sjPlotOdds.R;R/sjPlotPropTable.R;R/sjPlotSetTheme.R;man/plot_model.Rd;man/plot_models.Rd;man/save_plot.Rd;man/set_theme.Rd;man/sjp.frq.Rd;man/sjp.likert.Rd;man/sjp.xtab.Rd;vignettes/custplot.Rmd;vignettes/plot_model_estimates.Rmd;vignettes/sjpglm.Rmd;vignettes/sjplmer.Rmd,True,True,True,False,431,844,1275,"---FILE: DESCRIPTION---
@@ -26,6 +26,7 @@ Depends:
     stats,
     utils
 Imports:
+    arm,
     broom (>= 0.4.2),
     dplyr (>= 0.7.1),
     effects,
@@ -51,15 +52,15 @@ Imports:
     tidyr (>= 0.7.0)
 Suggests:
     AICcmodavg,
-    arm,
     car,
     cluster,
     GPArotation,
     gridExtra,
     ggrepel,
     ggridges,
     lmerTest,
-    lmtest
+    lmtest,
+    rstanarm
 URL: https://github.com/strengejacke/sjPlot
 BugReports: https://github.com/strengejacke/sjPlot/issues
 RoxygenNote: 6.0.1

---FILE: NAMESPACE---
@@ -8,12 +8,13 @@ export(dist_f)
 export(dist_norm)
 export(dist_t)
 export(font_size)
+export(get_model_data)
 export(label_angle)
 export(legend_style)
 export(plot_grid)
 export(plot_model)
 export(plot_models)
-export(save_plot)
+export(set_theme)
 export(sjc.cluster)
 export(sjc.dend)
 export(sjc.elbow)
@@ -40,7 +41,6 @@ export(sjp.pca)
 export(sjp.poly)
 export(sjp.resid)
 export(sjp.scatter)
-export(sjp.setTheme)
 export(sjp.stackfrq)
 export(sjp.xtab)
 export(sjplot)
@@ -98,13 +98,8 @@ importFrom(forcats,fct_rev)
 importFrom(ggeffects,ggeffect)
 importFrom(ggeffects,ggpredict)
 importFrom(grDevices,axisTicks)
-importFrom(grDevices,cm)
 importFrom(grDevices,dev.off)
-importFrom(grDevices,jpeg)
-importFrom(grDevices,png)
 importFrom(grDevices,rgb)
-importFrom(grDevices,svg)
-importFrom(grDevices,tiff)
 importFrom(graphics,abline)
 importFrom(graphics,par)
 importFrom(graphics,plot)

---FILE: NEWS---
@@ -1,463 +0,0 @@
-Version 2.4.0
------------------------------------------------------------------------------
-Bug fixes:
-* Fixed bug with `rm.terms`-argument in `plot_models()`.
-
-Version 2.3.3
------------------------------------------------------------------------------
-General:
-* Fixed issue with latest tidyr-update on CRAN.
-* HTML-tables (`sjt.*`-functions) displayed in the viewer pane now automatically add a CSS-style for white page background. This fixes an RStudio issue on OS X, where the new look'n'feel used dark backgrounds in the viewer pane, making output hardly readable.
-
-Version 2.3.2
------------------------------------------------------------------------------
-General:
-* Revising package code from scratch. Part of the old functions will be replaced by new ones, making the code base easier to maintain and reduce redundant functions by merging them together. In the course of the next updates, functions will first become deprecated and later defunct.
-* Changed imports to avoid using deprecated functions.
-* Use more informative warning- and error-messages for certain functions.
-
-New functions:
-* `plot_models()` as replacement for `sjp.lmm()` and `sjp.glmm()` (which are now deprecated).
-* `sjp.fa()` and `sjt.fa()` to plot or print as table the results of factor analyses.
-
-Bug fixes:
-* The mean and standard deviation in the summary of `sjt.frq()` were not correctly computed, when `auto.group`-argument was specified. This bug was introduced in the last update and is not fixed again.
-* Values of character vectors were not always correctly sorted in `view_df()` (if `show.frq = TRUE`).
-
-Version 2.3.1
------------------------------------------------------------------------------
-General:
-* All `sjt`-functions can now be directly integrated into knitr-code-chunks, because sjPlot exports a knitr-print-method (see `vignette(""sjtbasic"", ""sjPlot"")`).
-* `sjtab()` now also works within knitr-documents (see `vignette(""sjtbasic"", ""sjPlot"")`).
-* Updated Namespace for functions that moved from package 'sjstats' to 'sjmisc'.
-
-Changes to functions:
-* Changed defaults for `save_plot()`.
-* `save_plot()` now also supports _svg_-format.
-* For effect-plots (`type = ""eff""`), the `axis.title`-argument can now be used to change the title of y-axes.
-* For `sjp.lm()`, `sjp.glm()`, `sjp.lmer()` and `sjp.glmer()`, if color palette has more values than needed, it is silently shortend to the required length.
-* When plotting mixed models, argument `geom.colors` now also applies to plot-type `type = ""ri.slope""`.
-* Default correlation-method for `sjt.corr()` and `sjp.corr()` is now `pearson`.
-* Argument `emph.p` for printing tables of regression models now defaults to `FALSE`.
-
-Bug fixes:
-* Fixed bug in `sjt.frq()` for variables with many missing values and labelled values that did not occur on that variable.
-* Argument `value.labels` had no effect for `sjt.frq()`.
-* Automatic label detection in `sjt.grpmean()` sometimes not worked for factors without variable labels.
-* `sjp.glm()` used ""Odds Ratios"" as default title for y-axis when plotting marginal effects. Fixed, now y-axis is correctly labelled.
-* `sjt.glm()` used ""Odds Ratios"" as default column heading for the estimates, even for poisson or other models. Now the string for column headers is selected based on the first model input of the function.
-* Solved issue with warning in prediction-plots (`type = ""pred""`) for categorical variables on the x-axis.
-
-Version 2.3.0
------------------------------------------------------------------------------
-General:
-* Vignettes were added to this package.
-
-Changes to functions:
-* You can use `geom.colors = ""bw""` for linetype-plots, to create black & white figures that use different linetypes instead of different colors.
-* `sjp.kfold_cv()` now also supports poisson and negative binomial regression models.
-* `sjp.pca()` and `sjt.pca()` get a `rotation`-argument, to use either varimax- or oblimin-transformation of factor loadings.
-* Argument `show.value` now also applies to bar plots in `sjp.pca()`.
-* `sjt.glm()`, for generalized linar (mixed) models, now shows adjusted standard errors, using the Taylor series-based delta method.
-* More precise rounding of percentage values in `sjt.xtab()`, `sjp.xtab()` and `sjp.grpfrq()`.
-* Cramer's V in `sjt.xtab()` is now dentoted as V.
-* `sjt.xtab()` gets a `...`-argument, to pass down further arguments to the test statistics functions `chisq.test()` and `fisher.test()`.
-* `sjt.xtab()` gets a `statistics`-argument, to select one of different measures of associations for the table summary.
-
-Bug fixes:
-* Plotting or table output of regression models did not work with null-models (i.e. with intercept only).
-
-Version 2.2.1
------------------------------------------------------------------------------
-Changes to functions:
-* `sjp.lm()` for `type = ""ma""` now uses subtitles in multi-line plot-titles.
-
-Bug fixes:
-* Residuals in `sjp.kfold_cv()` had wrong leading sign (i.e. positive residuals were negative and vice versa).
-
-Version 2.2.0
------------------------------------------------------------------------------
-New Functions:
-* `sjp.kfold_cv()` to plot model fit from k-fold cross-validation.
-
-Changes to functions:
-* Argument `scatter.plot` was renamed to `show.scatter`.
-* Argument `var.labels` in `sjt.frq()` was renamed to `title`.
-* `sjplot()` and `sjtab()` also accept grouped data frames, to create plots or tables for all subgroups.
-* For `sjp.glm()` and `sjp.glmer()`, `type = ""pred""`, `type = ""slope""`, `type = ""pred.fe""` and `type = ""fe.slope""` can now also plot data points when `show.scatter = TRUE`. Use `point.alpha` to adjust alpha-level of data points.
-* For `sjp.glm()` and `sjp.glmer()`, `type = ""pred""` and `type = ""pred.fe""` now accept three variables for the `vars`-argument, to facet grouped predictions by a third variable.
-* For `sjp.lm()`, `sjp.lmer()`, `sjp.glm()` and `sjp.glmer()`, `type = ""pred""` and `type = ""pred.fe""` now plot error bars for `show.ci = TRUE` and a discrete variable on the x-axis.
-* For `sjp.lm()`, `sjp.lmer()`, `sjp.glm()` and `sjp.glmer()`, the `...`-ellipses argument now is also passed down to all errorbars- and smooth-geoms in prediction- and effect-plots, so you can now use the `width`-argument to show the small stripes at the lower/upper end of the error bars, the `alpha`-argument to define alpha-level or the `level`-argument to define the level of confidence bands.
-* `sjp.lm()`, `sjp.lmer()`, `sjp.glm()` and `sjp.glmer()` get a `point.color`-argument, do define color of point-geoms when `show.scatter = TRUE`. If not defined, point-geoms will have same group-color as lines.
-* Effect-plots (`type = ""eff""`) now plot data points for discrete variables on the x-axis.
-* `sjt.lm()` and `sjt.glm()` get a `robust`-argument to compute robust standard errors and confidence intervals.
-* `sjp.resid()` now also returns a plot with the residual pattern, `$pattern`.
-* Plot and axis titles from effect-plots can now be changed with `title` or `axis.title` argument. Use a character vector of length > 1 to define (axis) titles for each plot or facet; use `""""` to remove the title.
-* Pick better defaults for `geom.size`-argument for histogram and density plots in `sjp.frq()`.
-* Improved automatic label detection for regression models for plot or table output.
-
-Bug fixes:
-* Restored correct order of categories in `sjp.xtab()` and `sjp.grpfrq()` for stacked bars (`position_stack()` reversed order since  last ggplot2-update), so labels are now correclty positioned again.
-* Restored correct order of categories in `sjp.likert()`, so groups are now in correct order again.
-* Fixed bug in `sjt.grpmean()` for variables with unused value labels (values that were labelled, but did not appear on the vector).
-* Fixed wrong documentation for `show.summary`-argument in `sjt.xtab()`.
-* `sjt.frq()` and `sjp.frq()` showed messed up labels when a labelled vector had both `NA` values and `NaN` or infinite values.
-* `sjtab()` did not create tables for `fun = ""xtab""` with additional arguments.
-
-Version 2.1.2
------------------------------------------------------------------------------
-General:
-* Effect-plots from `sjp.int()`, `sjp.glm()` and `sjp.glmer()` now support the `transformation`-argument from the 'effects'-package. For example, when calling `sjp.glm(fit, type = ""eff"", transformation = NULL)`, predictions are on their original scale (y-scale) and the title for the y-scale is changed accordingly.
-
-Changes to functions:
-* Restored order of categories in `sjp.stackfrq()`, which were reversed by the last ggplot2-update, where `position_stack()` now sorts the stacking order to match grouping order.
-
-Bug fixes:
-* Fixed bug in `sjplot()` that caused figures not being plotted in certain situations.
-* Fixed bug in `sjp.lmm()`, which caused an error for plotting multiple mixed models when Intercept was hidden.
-* Fixed bug in `sjp.lmm()`, which caused an error for plotting multiple mixed models when `type = ""std""` or `type = ""std2""`.
-
-Version 2.1.1
------------------------------------------------------------------------------
-General:
-* Some fixes needed to be compatible with the latest ggplot2-update.
-
-New functions:
-* `sjplot`, a pipe-friendly wrapper for some of this package's plotting-functions.
-* `sjtab`, a pipe-friendly wrapper for some of this package's table-functions.
-
-Version 2.1.0
------------------------------------------------------------------------------
-New functions:
-* `sjp.resid`, an experimental function to plot and analyze residuals from linear models.
-* `plot_grid` to plot a list of ggplot-objects as arranged grid in a single plot.
-* `set_theme` to use a preset of default themes for plots from the sjp-functions.
-
-Changes to functions:
-* For `sjp.glmer` and `sjp.lmer`, argument `show.ci` now also applies for plotting random effects (`type = ""re""`, the default), so confidence intervals may not be calculated. This may be useful in some cases where computation of standard errors for random effects caused an error.
-* Effect plots (`type = ""eff""`) for `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer` should now better handle categorical variables and their labels, including using error bars insted of regions for confidence intervals.
-* `table(*, exclude = NULL)` was changed to `table(*, useNA = ""always"")`, because of planned changes in upcoming R version 3.4.
-* `get_option(""p_zero"")` was removed, and `sjt.lm`, `sjt.glm`, `sjt.lmer` and `sjt.glmer` get a `p.zero` argument.
-* `sjp.setTheme` no longer sets default theme presets for plots; use `set_theme` instead.
-
-Bug fixes:
-* A bug introduced in update 2.0.2 caused an error in `sjp.lm` for `type = ""std""`.
-* Effect plots (`type = ""eff""`) for `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer` did not plot all predictors, when predictor name was not exactly specified in formula, but transformed inside formula (e.g. `log(pred + 1)`).
-
-
-Version 2.0.2
------------------------------------------------------------------------------
-General:
-* Replace deprecated `dplyr::add_rownames()` with `tibble::rownames_to_column()`.
-* Improved title labelling for `type = ""pred""` in `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer`.
-* Improved title and facet title labelling for `type = ""eff""` in `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer`.
-
-Changes to functions:
-* Added argument `theme.font` to `sjp.setTheme` to apply a base font family for themes.
-* `sjp.lmer` gets a new plot type `eff.ri` to plot marginal effects, varying by random intercepts.
-
-Bug fixes:
-* In some cases, `sjp.int` cropped parts of the plot, when `jitter.ci` was `TRUE`.
-* In `sjp.corr`, argument `sort.corr = FALSE` caused an error.
-* In `sjt.glm` and `sjt.glmer`, setting argument `sep.column` to `FALSE` still added separator columns at the right end of the table.
-* `sjp.xtab` caused an error when a value from `x` was completely missing in `grp` (or vice versa).
-
-
-Version 2.0.1
------------------------------------------------------------------------------
-General:
-* `sjt.lmer` and `sjt.glmer` now warn when `show.aic = TRUE` and models were fitted with REML instead of ML.
-* Better support for `plm` objects in `sjt.lm`, `sjp.lm` and `sjp.int`.
-
-Changes to functions:
-* Added `group.estimate` argument to `sjp.lmer` and `sjp.glmer` (for fixed effetcs only).
-* `sjt.frq`, `sjt.xtab` and `view_df` now show notes (`note`-attribute, see `sjmisc::set_note`) of labelled data as tooltip, when mouse hovers the variable name/label, in the HTML-output.
-* `axis.title` argument for `sjp.glmer` and `sjp.lmer` can now be a vector of length one or two, to be more flexible with axis titles for the various plot types.
-* `sjt.lm`, `sjt.glm`, `sjt.lmer` and `sjt.glmer` get a `sep.column` argument to add (default) or remove a separator column (i.e. margin) between model columns.
-* `sjp.scatter` now uses value labels from grouping variable as title for plots if `facet.grid = TRUE`.
-* Argument `axis.title` now also applies to `type = ""pred""` for `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer`.
-* Argument `geom.colors` now applies to more plot types in `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer`.
-* Added argument `legend.title` to `sjp.lmer` and `sjp.glmer` to set legend title for those plot types who have legends.
-* Added argument `jitter.ci` to `sjp.int` to add jittering to confidence bands for error bars, to avoid overlap.
-* Added argument `string.total` to `sjt.stackfrq` to label the column with total N (see `show.total`).
-
-Bug fixes:
-* `axis.lim` was not recognized for non-binomial model families and linear models slope- and effect-plot-types.
-
-
-Version 2.0.0
------------------------------------------------------------------------------
-Major changes:
-* This package update includes a major revision of function arguments and their naming, in order to get a consistent argument pattern across all package functions. This means that your existing code, which uses **sjPlot**-package-functions, most likely needs adaptions to work again.
-* Arguments were harmonized across all package functions. This includes refactoring of many function argument names, to get consistent argument names in functions (e.g. `sort.coef` now no longer exists, and was renamed to `sort.est`, which was already used by some other functions).
-* Camel cased argument names were replaced by lowercase dot-separated names (e.g. `showCI` was renamed to `show.ci`) and harmonized bewteen different functions
-* `type` arguments of `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer` were harmonized, so that one type does the same in all functions. `""pred""` and `""fe.pred""` were renamed to `""slope""` and `""fe.slope""`, `""fe.ri""` and `""ri.pc""` were renamed to `""ri.slope""`, `""resp""` and `""y.pc""` were renamed to `""pred""` and `""pred.fe""`.
-* Arguments in functions were re-ordered and bundled according to their functionality (e.g., the variuous `show...` arguments now should appear on after another in the function and package manual).
-
-General:
-* Improved label detection for `sjp.lm`, `sjp.glm`, `sjt.lm`, `sjt.glm`, `sjt.lmer` and `sjt.glmer`.
-* Improved handling of different link functions for generalized linear (mixed) models (including negative binomial) for effect plots in `sjp.glmer` and `sjp.glm`.
-
-Changes to functions:
-* Effect plots (`type = ""eff""`) for (generalized) linear (mixed) models (`sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer`) get a `vars` and `facet.grid` argument.
-* Effect plots (`type = ""eff""`) get a `...` argument, to pass down other arguments to the `effects`-package.
-* Predicted values for response (`type = ""pred""` or `type = ""pred.re""`) for `sjp.glm`, `sjp.glmer`, `sjp.lm` and `sjp.lmer` get a `vars` argument to specify x-axis and optional grouping variables. Furthermore, models from other model families and link functions (including negative binomial) now also work with this plot type.
-* Functions `sjp.lmer`, `sjp.glmer`, `sjt.lmer`, `sjt.glmer`, `sjp.lmm` and `sjp.glmm` get a `p.kr` argument, to decide whether computation of p-values should be based on Kenward-Roger approximation or not (for very large data sets, it's recommended to set this argument to `FALSE` because it is very time consuming).
-
-Bug fixes:
-* During code clean-up, argument `group.pred` did not work for `sjt`-functions in past update.
-* Fixed bug with computation of confidence intervals and relative confidence intervals in `sjp.frq`.
-
-Version 1.9.4
------------------------------------------------------------------------------
-General:
-* Package is now depending on R >= 3.2, because some functions did not work on older R-releases.
-
-Bug fixes:
-* `type = ""rs.ri""` for `sjp.lmer` and `sjp.glmer` did not work with three-level (or more) mixed models or with mixed models with more than one random part.
-
-
-Version 1.9.3
------------------------------------------------------------------------------
-General:
-* P-values for linear mixed models are now computed using conditional F-tests with Kenward-Roger approximation for the df from the 'pbkrtest' package, if available.
-
-Changes to functions:
-* Better support for different model families in `sjp.glm` and `sjp.glmer`.
-* `sjt.lm`, `sjt.lmer`, `sjt.glm` and `sjt.glmer` get a `showDeviance` argument to display model's deviance in the table summary.
-* `sjt.lmer` and `sjt.glmer` now show R2-values (based on sjmisc::r2 function).
-* `sjt.lmer` and `sjt.glmer` get argument `showREvar` to show random effect variances.
-* `sjt.df` gets a `...` argument to pass down other arguments to `psych::describe`.
-* Argument `sample.n` in `sjp.lmer` and `sjp.glmer` may now also be a numeric vector of length > 1, indicating speficic random effects to select for plotting.
-* Plot-type of `sjp.int` now defaults to `type = ""eff""`.
-* Minor improvements to `sjp.int` according to plot labels (legend, axis).
-
-Bug fixes:
-* `sjt.xtab` did not apply `highlightTotal` to total column.
-* `sjt.xtab` showed wrong total percentages for row and column percentages.
-* `geom.outline.color` and `geom.outline.size` did not apply to bar geoms after ggplot-update.
-
-
-Version 1.9.2
------------------------------------------------------------------------------
-General:
-* Updates package vignettes (http://strengejacke.de/sjPlot/) to work with the latest package versions.
-
-Changes to functions:
-* `sjp.lmm` and `sjp.glmm` now also support linear mixed effects models (of class `merMod`).
-* `sjp.int` now uses proper x-axis-tick-labels for `type = ""eff""`, when predictor on x-axis is a factor with non-numeric factor-levels (or has label attributes).
-* `sjp.glm` gets a `group.estimates` argument to group estimates in forest plots and colour them according to group assignment. Use arguments `show.legend` and `legendTitle` to modify group legend.
-* `sjp.poly` now has better variable label detection for automatic axis labelling.
-* `sjp.lmer` and `sjp.glmer` now support model diagnostics with `type = ""ma""`.
-* Better support for different model families in `sjp.glm`.
-* Better axis labelling for `type = ""poly""` in `sjp.lm` and `sjp.lmer`.
-
-Bug fixes:
-* Fixed bug in `sjp.int`, where automatic y-axis-scaling for binary outcomes cut off parts of confidence region in some cases.
-* Fixed bug in `sjp.lmer` and `sjp.glmer` with doubled y-axis for faceted random effect plots.
-* `sjt.xtab` ignored value labels when weighting data.
-* Fixed bug with position of value labels in `sjp.xtab`.
-* Fixed bug in `sjp.likert` that plotted categories in wrong order when neutral category was lower than amount of categories.
-* Fixed bug in `sjp.grpfrq` with argument `autoGroupAt`.
-* Fixed minor bugs in `sjp.lm` with axis range for forest plots.
-* Fixed bug in `sjp.stackfrq`, where the use of argument `showSeparatorLine` caused an error.
-
-
-Version 1.9.1
------------------------------------------------------------------------------
-Changes to functions:
-* Improved text label positioning for plotting functions.
-* Plotting functions now get an argument `y.offset` to specify an offset for text labels from geoms.
-* `sjp.lm` and `sjt.lm` now support `gls` models fitted with `nlme::gls`.
-* `sjp.int` now fits the y-axis to the required range for predicted probabilities for logistic regressions instead of always using a range from 0 to 1, even for smaller effects.
-* `sjp.glmer` and `sjp.lmer` get a `axisLimits.y` argument to specify y-axis limits specifically for predicted probability or effect plots.
-* `view_df` now supports showing missings and missing percentages.
-* Harmonized column names of returned data frames to match `broom`s naming convention for `sjp.lm`, `sjp.glm`, `sjp.lmer`, `sjp.glmer`, `sjp.lmm`, `sjp.glmm`, `sjp.aov1` and `sjp.int`.
-* Functions with harmonized data frames as return value now also gain the class attribute `sjPlot`, and all returned data frame values are named `data`.
-* `sjp.scatter` gets a `useCount` argument to indicate overplotting by point size.
-* `sjp.scatter` now also plots data points when using argument `pointLabels`, so exact position of labelled data points is visible. `geom_text_repel` is used to avoid overlapping of points and labels.
-* `sjt.xtab` gets a `title` argument to print a table caption.
-
-Bug fixes:
-* Automatic label detection did not choose column names when no variable labels were present for functions that accepted data frames as data argument, now works again.
-* `sjp.int` did not work with fitted models from class `lme`, now works again.
-* `sjt.xtab` did not show `NA` values for `showNA = TRUE`, now works again.
-* `sjt.xtab` did not use arguments `valueLabels`, now works again.
-* Table summary (chi-squared, phi, p) for `sjt.xtab` were wrong, now works again.
-* Due to rounding, total percentage in `sjt.xtab` could differ from 100%.
-* Minor fixes.
-
-
-Version 1.9
------------------------------------------------------------------------------
-General:
-* Fixed many issues related to the latest update of ggplot2.
-* Argument `show.se` is now deprecated. Use `show.ci` instead.
-* Redesign of computation of frequency tables for `sjp.frq` and `sjt.frq`, being more robust and generally working with labelled, non-labelled, numeric, character vectors and factors.
-* Redesign of computation of frequency tables for `sjp.grpfrq`, `sjp.xtab` and `sjt.xtab`, being more robust and generally working with labelled, non-labelled, numeric, character vectors and factors.
-* Better automatic handling of variable and value labels that are used for labelling plot axes and titles or table columns.
-
-Changes to functions due to new ggplot2-version:
-* `sjp.grpfrq` no longer has plot type `type = ""histogram""`. Maybe re-implemented in a later update. Due to this change, arguments like `showMeanIntercept` and similar were removed.
-* Plotting functions no longer have argument `labelPosition`. Instead, use arguments `vjust` and `hjust`, which correspond to the same ggplot2-aesthetics according to their possible values.
-
-Changes to functions:
-* `sjp.lm` gets a `group.estimates` argument to group estimates in forest plots and colour them according to group assignment. Use arguments `show.legend` and `legendTitle` to modify group legend.
-* `sjp.lmer` and `sjp.glmer` can now plot random effect parts of random slope-intercept models (with `type = ""rs.ri""`), where regression lines or predicted probabilities of random intercept and slopes are plotted.
-* Intercept line plotting in `sjp.int` for `type = ""cond""` was removed.
-* Line geoms for `type = ""cond""` in `sjp.int` now always start at y-position zero, to better indicate the effective change of interaction effect compared to base reference. Now, the y-position indicates the change in the reponse due to the interaction effect.
-* `sjp.int` gets a `geom.size` argument to specify line width.
-
-Bug fixes:
-* Argument `ci.hyphen` in function `sjt.lm` and `sjt.lmer` was not correctly applied to confidence intervals of standardized beta values.
-
-
-Version 1.8.4
------------------------------------------------------------------------------
-General:
-* Improved encoding detection for `sjt`-functions.
-
-Changes to functions:
-* Predictor grouping with argument `group.pred` now also works for `sjt.lmer` and `sjt.glmer` (in certain cases may be buggy, so `group.pred` defaults to `FALSE`).
-* Argument `vars` in `sjp.lmer` and `sjp.glmer` now also applies when plotting estimates (`type = ""fe""` or `type = ""re""`).
-* `view_df` gets a `weightBy` argument.
-* Argument `showCI` in `sjp.int` accepts numeric values for `type = ""eff""`,  indicating the confidence interval value.
-* Minor improvements to `view_df`, `sjp.lm` and `sjp.lmm`.
-* Improved accuracy of computation of skewness value in `sjt.itemanalysis`.
-
-Bug fixes:
-* Fixed bug where in certain cases, ordered factors were not labelled correctly in `sjp.frq`.
-* Value labels were not shown in `sjp.aov1`.
-* Axis labels were reversed in `sjp.pca` for `type = ""bar""`.
-
-Version 1.8.3
------------------------------------------------------------------------------
-New functions:
-* `sjp.gpt` to plot grouped proportional tables.
-* `save_plot` as convenient function to save the last ggplot-figure in high quality for publication.
-
-Changes to functions:
-* `sjp.lmm` can now also plot standardized estimates.
-* `sjp.lm`, `sjp.lmm` and `sjt.lm` can now plot standardized estimates, where standardization is computed following Gelman's approach by dividing estimates by two standard deviations.
-* Added parameters `ci.hyphen` and `minus.sign` to `sjt.lm`, `sjt.glm`, `sjt.lmer` and `sjt.glmer` to set specific symbols or HTML entitities for hyphens and minus signs of negative numbers.
-* Added `type = 'coeff'` to `sjp.lmer` to plot joint random and fixed effects coefficients.
-* `sjp.lm`, `sjp.glm`, `sjp.lmm`, `sjp.glmm`, `sjp.lmer` and `sjp.glmer` get a `remove.estimates` argument to remove specific estimates from the plot output.
-* `type = 'poly'` in `sjp.lm` can now deal with fitted models that either use polynomials with `poly` or splines with `bs`.
-* `sjt.df` gets a `big.mark` parameter to add thousands-separators if parameter `describe = TRUE`.
-* `sjt.df` and `view_df` now recognize Date and POSIX-classes, if `showType = TRUE`.
-* `sjp.poly` now also returns cutpoints of loess curvature, to get maximum / minimum values of loess curvature.
-* `sjp.lm` with `type = 'ma'` now also returns all plots as list of ggplot-objects.
-* `sjp.setTheme` now allows for custom label and title colors when using pre-set-themes.
-* Improved automatic y-axis-limit detection in `sjp.frq` and `sjp.grpfrq`.
-* Minor improvements to `sjp.lmm` and `sjp.glmm`.
-
-Bug fixes:
-* Fixed bug in `sjp.lmer`, which misleadingly printed wrong beta coefficients (they were exponentiated as for odds ratios).
-* Fixed bug with computation of predicted probabilities in `sjp.glm` and `sjp.glmer` (only occured when `type = 'y.pc'`).
-* `sjp.grpfrq` did not show correct number of missings (argument `na.rm = FALSE`), if grouping variable startet with zero.
-* Fixed bug with `sjp.frq` and `sjt.frq`, when variable was a labelled factor with lowest factor level smaller than 1.
-* Fixed bug in `view_df` with parameter `showFreq = TRUE`, when variable was a character vector.
-* Minor bug fixes with p-shapes in `sjp.lmm` and `sjp.glmm`.
-* Fixed bug in `sjt`-table functions that occured with invalid multibyte strings.
-
-Version 1.8.2
-------------------------------------------------------------------------------
-General:
-* `view_spss` is now deprecated. Use `view_df` instead.
-* Package documentation got major revisions.
-* Updated namespaces to meet new CRAN namespace requirements.
-
-New functions:
-* `sjp.poly` to plot polynomial curves for (generalized) linear regressions.
-
-Changes to functions:
-* Model and table summaries in plotting functions (like `sjp.lm` or `sjp.grpfrq`) are no longer printed by default. Use `showTableSummary = TRUE` or `showModelSummary = TRUE` to print summaries in plots.
-* Added more plotting type options (see `type` parameter) to `sjp.glm`, `sjp.glmer`, `sjp.lm` and `sjp.lmer`: `eff` for plotting marginal effects of model terms, and `poly` to plot predicted values of polynomial terms (only for linear (mixed) models).
-* Added parameter `pointLabels` to `sjp.scatter` to plot scattered text labels.
-* Added parameter `int.term` to `sjp.int`, to plot selected interaction terms for `type = 'eff'`. May be used in cases where effect computation takes too long or even crashes due to out-of-memory-problems.
-* Added parameter `axisLimits.x` to `sjp.int`, `sjp.frq` and `sjp.grpfrq`.
-* Added parameter `showAICc` to `sjt.lm`, `sjt.glm`, `sjt.lmer` and `sjt.glmer` to print second-order AIC.
-* Improved automatic y-axis-limit detection in `sjp.frq` and `sjp.grpfrq`.
-* For `sjt.lm` and `sjt.glm`, if `digits.p` is greater than 3, p-values less than 0.001 will no longer be abbreviated to `<0.001`. Instead, the exact value (rounded to digits.p) will be printed.
-* Minor improvements to `sjp.likert`, `sjp.int`, `sjp.glm`, `sjp.frq` and `sjp.grpfrq`.
-
-Bug fixes:
-* `sjp.int` sometimes crashed with mixed models, due to slow Kenward-Roger-computation of standard errors, provided by the `effects`-package. Fixed, `KR`-parameter, when calling `allEffects`, now defaults to `FALSE`.
-* Fixed bug in `view_spss`, where frequencies were not displayed correctly when a category value had zero counts.
-* Fixed bug in `sjp.frq` and `sjt.frq`, where non-incremental levels in some cases were not displayed correctly.
-* Fixed bug in `sjp.frq` and `sjt.frq`, where categories of ordered factors were messed up.
-* Some minor bug fixes.
-
-Version 1.8.1
-------------------------------------------------------------------------------
-General:
-* Deprecated function `sjp.emm.int` was removed. Use `sjp.int` with parameter `type = 'emm'` to plot estimated marginal means.
-* Minor improvements for `sjt.lm` and `sjt.glm`.
-
-New functions:
-* `sjt.lmer` to print summary tables of linear mixed models.
-* `sjt.glmer` to print summary tables of generalized linear mixed models.
-
-Changes to functions:
-* Added 'type = `probc`' to `sjp.glm` as alternative to 'type = `prob`'. 'type = `probc`' calculates predicted probabilities based on the `predict` function.
-* Added 'type = `y.prob`' to `sjp.glm` and `sjp.glmer` to plot predicted probabilities of the response.
-* Added 'type = `resp`' to `sjp.lm` and to `sjp.lmer` to plot predicted values of the response.
-* `sjt.grpmean` gets a `weightBy` parameter to compute weighted group-means.
-* `sjt.glm` gets a `showHosLem` parameter to print results of the Hosmer-Lemeshow-Goodness-of-fit-Test for generalized linear models.
-* Added white-background-alternative-themes of 538, 539 and scatter to `sjp.setTheme`.
-* `sjt.frq` now warns when a variable has less labels than unique values.
-* `sjp.int` for `type = 'emm'` now warns if interaction terms are not factors.
-
-Bug fixes:
-* Fixed bug with `options(p_zero = TRUE)`, where leading zero was inserted after, instead of before decimal point.
-* Fixed formatting bug for pseudo-R2 in `sjt.glm`.
-* Fixed bug in `sjp.likert` when data frame had only one column.
-* Fixed bug in `sjt.frq` when a data frame contained variables with only NA values.
-* Fixed bugs in `sjt.frq` with weighted variables.
-* Fixed wrong warning message, saying that package `lme4` is missing (should be package `arm` instead).
-
-
-Version 1.8
-------------------------------------------------------------------------------
-General:
-* Utility, recode and statistical test functions have been moved to another package called `sjmisc`! sjPlot now imports sjmisc.
-* R-Version dependency changed to R >= 3.1, due to import of `tidyr` and `dplyr` packages.
-* `sjp.emm.int` is now deprecated. Use `sjp.int` with parameter `type = 'emm'` to plot estimated marginal means. Estimated marginal means can now also be applied to lmerMod-objects from lme4-package.
-
-New functions:
-* `sjt.mwu` to print Mann-Whitney-tests as HTML-table.
-
-Changes to function 'sjp.int':
-* `sjp.int` now supports `plm` objects (from plm-package).
-* Added parameter `type` to `sjp.int` to plot different types of interactions, including estimated marginal means.
-* Added parameter `legendTitle` to `sjp.int`.
-* Added parameter `int.plot.index` to `sjp.int`, so only selected interaction terms may be plotted.
-* Added parameter `showCI` to `sjp.int` (only for type = `emm` and `eff`) to add confidence intervals to estimated marginal means.
-* Added parameter `facet.grid` to `sjp.int` to plot each effect in a separate plot.
-* Parameter `legendLabels` of `sjp.int` now accepts a list of character vectors, with one vector of legend labels for each interaction plot plotted.
-* Parameter `title` of `sjp.int` now accepts a character vector of same length as interaction terms, with one title character string for each interaction plot plotted.
-* Parameter `moderatorValues` in `sjp.int` has two new options `zeromax` and `quart` for chosing the moderator values.
-
-Changes to other functions:
-* Linear mixed model methods (`sjp.int`, `sjp.lmer`) can now cope with `modMerLmerTest` objects (fitted with `lmerTest` package)
-* `sjp.lmer` now calculates approximate p-values based on Wald chi-squared tests.
-* `sjp.lmer` and `sjp.glmer` now plot all random effects (when type = `re`) by default, instead of only the first random effect. Furthermore, parameter `ri.nr` now may be a numeric vector (instead of single numeric value) with several random effect index numbers.
-* `sjp.glm` now supports plotting `logistf` objects.
-* `sjp.glmm` and `sjp.lmm` now also accept a list of fitted models (see examples in ?sjp.glmm and ?sjp.lmm).
-* `sjp.int` and `sjp.lm` now support `plm` objects (from plm-package).
-* Parameters `orderBy` and `reverseOrder` in `sjp.stackfrq` and `sjt.stackfrq` were merged into new parameter `sort.frq`.
-* Parameter `transformTicks` in `sjp.glm` and `sjp.glmm` now defaults to `TRUE`.
-* Added parameter `emph.grp` to `sjp.lmer` and `sjp.glmer` to emphasize specific grouping levels when plot-type is either `fe.ri` or `ri.pc`.
-* Added parameter `labelDigits` to functions `sjp.likert` and `sjp.stackfrq`, so digits of value labels can be changed.
-* Added option `fe.pred` to `type`-parameter of `sjp.lmer` to plot slopes for each single fixed effect.
-* Added parameter `bar` to `sjp.pca` to plot loadings of principle components as bar charts.
-* Renamed parameters `y` and `x` in `sjp.xtab` into `var` and `grp`.
-* Added further pre-set themes to `sjp.setTheme`.
-* Minor improvements of `sjp.setTheme`.
-
-Bug fixes:
-* `sjp.int` did not work for interaction terms of factors with more than two levels in mixed effects models (`merMod`-objects) - fixed.
-* `sjp.glm` and `sjp.glmm` should catch axis limits, which are out of printable bounds, hence these function should no longer stop in such cases.
-* `sjp.lmer` and `sjp.glmer` wrongly stated that paramter `ri.nr` was out of bound when `type` was `re`, `fe.ri` or `ri.pc` - fixed.
-* Weights with decimals in `sjt.xtab` (e.g. `weightBy = abs(rnorm(100, 2, 1)`) caused an error - fixed.
-* `sjp.int` did not work with interaction terms that used `AsIs` conversion (function `I`) - fixed.

---FILE: R/plot_model.R---
@@ -17,6 +17,24 @@
 #'            \item{\code{""diag""}}{to check model assumptions.}
 #'            \item{\code{""vif""}}{to plot Variance Inflation Factors.}
 #'          }
+#' @param sort.est Determines in which way estimates are sorted in the plot:
+#'          \itemize{
+#'            \item If \code{NULL} (default), no sorting is done and estimates are sorted in the same order as they appear in the model formula.
+#'            \item If \code{TRUE}, estimates are sorted in descending order, with highedt estimate at the top.
+#'            \item If \code{sort.est = ""sort.all""}, estimates are re-sorted for each coefficient (only applies if \code{type = ""re""} and \code{facets = FALSE}), i.e. the estimates of the random effects for each predictor are sorted and plotted to an own plot.
+#'            \item If \code{type = ""re""}, specify a predictor's / coefficient's name to sort estimates according to this random effect.
+#'            }
+#' @param exponentiate Logical, if \code{TRUE} and models inherit from generalized
+#'          linear models, estimates will be exponentiated (e.g., log-odds will
+#'          be displayed as odds ratios). By default, \code{exponentiate} will
+#'          automatically be set to \code{FALSE} or \code{TRUE}, depending on
+#'          the class of \code{fit}.
+#' @param rm.terms Character vector with names that indicate which terms should
+#'          be removed from the plot. Counterpart to \code{terms}.
+#'          \code{rm.terms = ""t_name""} would remove the term \emph{t_name}.
+#'          Default is \code{NULL}, i.e. all terms are used. Note that this
+#'          argument does not apply to \code{type = ""eff""}, \code{type = ""pred""}
+#'          or \code{type = ""int""}.
 #' @param terms Character vector with the names of those terms from \code{model}
 #'          that should be plotted. This argument depends on the plot-type:
 #'          \describe{
@@ -36,9 +54,25 @@
 #'              For more details, see \code{\link[ggeffects]{ggpredict}}.
 #'            }
 #'          }
+#' @param axis.title Character vector of length one or two (depending on
+#'          the plot function and type), used as title(s) for the x and y axis.
+#'          If not specified, a default labelling  is chosen. \strong{Note:}
+#'          Some plot types may not support this argument sufficiently. In such
+#'          cases, use the returned ggplot-object and add axis titles manually with
+#'          \code{\link[ggplot2]{labs}}.
+#' @param show.intercept Logical, if \code{TRUE}, the intercept of the fitted
+#'          model is also plotted. Default is \code{FALSE}. If \code{exponentiate = TRUE},
+#'          please note that due to exponential transformation of estimates, the
+#'          intercept in some cases is non-finite and the plot can not be created.
 #' @param ... Other arguments, passed down to various functions. Here is the
 #'        description of these arguments in detail.
 #'        \describe{
+#'          \item{\code{auto.label}}{
+#'            Logical value, if \code{TRUE} (the default), plot-labels are based
+#'            on value and variable labels, if the data is labelled. See
+#'            \code{\link[sjlabelled]{get_label}} and
+#'            \code{\link[sjlabelled]{get_term_labels}} for details.
+#'          }
 #'          \item{\code{value.size}}{
 #'            Numeric value, which can be used for all plot types where the
 #'            argument \code{show.values} is applicable, e.g.
@@ -84,7 +118,7 @@ plot_model <- function(model,
                        type = c(""est"", ""re"", ""eff"", ""pred"", ""int"", ""std"", ""std2"", ""slope"", ""resid"", ""diag""),
                        exponentiate,
                        terms = NULL,
-                       sort.est = FALSE,
+                       sort.est = NULL,
                        rm.terms = NULL,
                        group.terms = NULL,
                        order.terms = NULL,
@@ -116,12 +150,20 @@ plot_model <- function(model,
   type <- match.arg(type)
   pred.type <- match.arg(pred.type)
 
+  auto.label <- TRUE
+
+  # additional arguments?
+
+  add.args <- lapply(match.call(expand.dots = F)$`...`, function(x) x)
+  if (""auto.label"" %in% names(add.args)) auto.label <- add.args[[""auto.label""]]
+
+
   # get titles and labels for axis ----
 
   # this is not appropriate when plotting random effects,
   # so retrieve labels only for other plot types
 
-  if (type != ""re"") {
+  if (type != ""re"" && isTRUE(auto.label)) {
 
     # get labels of dependent variables, and wrap them if too long
     if (is.null(title)) title <- sjlabelled::get_dv_labels(model, case = case)
@@ -267,3 +309,74 @@ plot_model <- function(model,
 
   p
 }
+
+
+#' @rdname plot_model
+#' @export
+get_model_data <- function(model,
+                       type = c(""est"", ""re"", ""eff"", ""pred"", ""int"", ""std"", ""std2"", ""slope"", ""resid"", ""diag""),
+                       exponentiate,
+                       terms = NULL,
+                       sort.est = NULL,
+                       rm.terms = NULL,
+                       group.terms = NULL,
+                       order.terms = NULL,
+                       pred.type = c(""fe"", ""re""),
+                       ri.nr = NULL,
+                       title = NULL,
+                       axis.title = NULL,
+                       axis.labels = NULL,
+                       axis.lim = NULL,
+                       grid.breaks = NULL,
+                       ci.lvl = NULL,
+                       show.intercept = FALSE,
+                       show.values = FALSE,
+                       show.p = TRUE,
+                       show.data = FALSE,
+                       value.offset = NULL,
+                       dot.size = NULL,
+                       line.size = NULL,
+                       colors = ""Set1"",
+                       facets,
+                       wrap.title = 50,
+                       wrap.labels = 25,
+                       case = ""parsed"",
+                       digits = 2,
+                       vline.color = NULL,
+                       ...) {
+  p <- plot_model(
+    model = model,
+    type = type,
+    exponentiate = exponentiate,
+    terms = terms,
+    sort.est = sort.est,
+    rm.terms = rm.terms,
+    group.terms = group.terms,
+    order.terms = order.terms,
+    pred.type = pred.type,
+    ri.nr = ri.nr,
+    title = title,
+    axis.title = axis.title,
+    axis.labels = axis.labels,
+    axis.lim = axis.lim,
+    grid.breaks = grid.breaks,
+    ci.lvl = ci.lvl,
+    show.intercept = show.intercept,
+    show.values = show.values,
+    show.p = show.p,
+    show.data = show.data,
+    value.offset = value.offset,
+    dot.size = dot.size,
+    line.size = line.size,
+    colors = colors,
+    facets = facets,
+    wrap.title = wrap.title,
+    wrap.labels = wrap.labels,
+    case = case,
+    digits = digits,
+    vline.color = vline.color,
+    ...
+  )
+
+  p$data
+}

---FILE: R/plot_model_estimates.R---
@@ -88,7 +88,7 @@ plot_model_estimates <- function(fit,
 
   if (!is.null(term.order)) {
     if (length(term.order) == nrow(dat)) {
-      dat$term <- forcats::fct_reorder(dat$term, term.order)
+      dat$term <- forcats::fct_reorder(dat$term, order(term.order))
       sort.est <- FALSE
     } else {
       message(""Number of values in `order.terms` does not match number of terms. Terms are not sorted."")
@@ -98,7 +98,7 @@ plot_model_estimates <- function(fit,
 
   # sort estimates by effect size
 
-  if (sort.est) {
+  if (isTRUE(sort.est)) {
     if (!is.null(group.terms))
       dat$term <- forcats::fct_reorder(dat$term, dat$group)
     else

---FILE: R/plot_models.R---
@@ -6,15 +6,6 @@
 #'
 #' @param ... One or more regression models, including glm's or mixed models.
 #'        May also be a \code{list} with fitted models. See 'Examples'.
-#' @param exponentiate Logical, if \code{TRUE} and models inherit from generalized
-#'          linear models, estimates will be exponentiated (e.g., log-odds will
-#'          be displayed as odds ratios). By default, \code{exponentiate} will
-#'          automatically be set to \code{FALSE} or \code{TRUE}, depending on
-#'          the class of \code{fit}.
-#' @param rm.terms Character vector with names that indicate which terms should
-#'          be removed from the plot. \code{rm.terms = ""t_name""} would remove the
-#'          term \emph{t_name}. Default is \code{NULL}, i.e. all terms are
-#'          used.
 #' @param std.est For linear models, choose whether standardized coefficients should
 #'        be used for plotting. Default is no standardization.
 #'        \describe{
@@ -25,10 +16,6 @@
 #' @param m.labels Character vector, used to indicate the different models
 #'          in the plot's legend. If not specified, the labels of the dependent
 #'          variables for each model are used.
-#' @param show.intercept Logical, if \code{TRUE}, the intercept of the fitted
-#'          model is also plotted. Default is \code{FALSE}. If \code{exponentiate = TRUE},
-#'          please note that due to exponential transformation of estimates, the
-#'          intercept in some cases is non-finite and the plot can not be created.
 #' @param legend.pval.title Character vector, used as title of the plot legend that
 #'        indicates the p-values. Default is \code{""p-level""}. Only applies if
 #'        \code{p.shape = TRUE}.
@@ -38,6 +25,7 @@
 #'        different point shapes and a related legend is plotted. Default
 #'        is \code{FALSE}.
 #'
+#' @inheritParams plot_model
 #' @inheritParams sjp.lm
 #' @inheritParams sjp.lmer
 #' @inheritParams sjt.lm

---FILE: R/plot_point_estimates.R---
@@ -28,7 +28,7 @@ plot_point_estimates <- function(model,
   # set default for empty titles/labels
 
   if (sjmisc::is_empty(title)) title <- NULL
-  if (sjmisc::is_empty(axis.labels)) axis.labels <- dat$term
+  if (sjmisc::is_empty(axis.labels)) axis.labels <- NULL
   if (sjmisc::is_empty(axis.title)) axis.title <- NULL
 
 
@@ -121,7 +121,8 @@ plot_point_estimates <- function(model,
 
   # set axis labels
 
-  p <- p + scale_x_discrete(labels = axis.labels)
+  if (!is.null(axis.labels))
+    p <- p + scale_x_discrete(labels = axis.labels)
 
 
   # we need transformed scale for exponentiated estimates

---FILE: R/plot_type_ranef.R---
@@ -45,7 +45,7 @@ plot_type_ranef <- function(model,
   p <- list()
 
 
-  # additional arguments for 'effects()'-function?
+  # additional arguments?
 
   add.args <- lapply(match.call(expand.dots = F)$`...`, function(x) x)
   if (""value.size"" %in% names(add.args)) value.size <- add.args[[""value.size""]]

---FILE: R/sjPlotFrequencies.R---
@@ -79,7 +79,7 @@ utils::globalVariables(c(""val"", ""frq"", ""grp"", ""label.pos"", ""upper.ci"", ""lower.ci
 #' # bar plot
 #' sjp.frq(ChickWeight$Diet)
 #'
-#' # you may use sjp.setTheme here to change axis textangle
+#' # you may use set_theme() here to change axis textangle
 #' sjp.frq(efc$e15relat)
 #'
 #' # grouped variable

---FILE: R/sjPlotGLME.R---
@@ -269,7 +269,6 @@ sjp.glmer <- function(fit,
                       y.offset = .1,
                       prnt.plot = TRUE,
                       ...) {
-  .Deprecated(""plot_model"")
   # -------------------------------------
   # check for deprecated argument values
   # -------------------------------------
@@ -571,7 +570,6 @@ sjp.lmer <- function(fit,
                      y.offset = .1,
                      prnt.plot = TRUE,
                      ...) {
-  .Deprecated(""plot_model"")
   # -------------------------------------
   # check for deprecated argument values
   # -------------------------------------
@@ -879,12 +877,6 @@ sjp.lme4  <- function(fit,
                                    type = ""fe"", show.scatter, point.alpha,
                                    point.color, show.loess = F, prnt.plot, ...)))
   }
-  # ------------------------
-  # check if suggested package is available
-  # ------------------------
-  if (!requireNamespace(""arm"", quietly = TRUE)) {
-    stop(""Package `arm` needed for this function to work. Please install it."", call. = FALSE)
-  }
   # ---------------------------------------
   # check geom size
   # ---------------------------------------
@@ -2126,13 +2118,6 @@ sjp.glm.eff <- function(fit,
                         fun,
                         prnt.plot,
                         ...) {
-  # ------------------------
-  # check if suggested package is available
-  # ------------------------
-  if (!requireNamespace(""effects"", quietly = TRUE)) {
-    stop(""Package `effects` needed for this function to work. Please install it."", call. = FALSE)
-  }
-
   # additional arguments for 'effects()'-function?
   add.args <- lapply(match.call(expand.dots = F)$`...`, function(x) x)
   # check whether we have a ""transformation"" argument

---FILE: R/sjPlotInteractions.R---
@@ -818,6 +818,7 @@ sjp.int <- function(fit,
 
 #' @importFrom stats na.omit model.frame
 #' @importFrom dplyr if_else
+#' @importFrom effects effect allEffects
 sjp.eff.int <- function(fit,
                         int.term = NULL,
                         int.plot.index = NULL,

---FILE: R/sjPlotLikert.R---
@@ -68,12 +68,11 @@ utils::globalVariables(c(""offset""))
 #'
 #' @examples
 #' # Data from the EUROFAMCARE sample dataset
-#' library(dplyr)
 #' library(sjmisc)
 #' data(efc)
 #' # find all variables from COPE-Index, which all have a ""cop"" in their
 #' # variable name, and then plot that subset as likert-plot
-#' efc[, find_var(efc, ""cop"")] %>% sjp.likert()
+#' find_var(efc, ""cop"", as.df = TRUE) %>% sjp.likert()
 #'
 #' sjp.likert(
 #'   find_var(efc, ""cop"", as.df = TRUE),

---FILE: R/sjPlotLinreg.R---
@@ -296,7 +296,6 @@ sjp.lm <- function(fit,
                    complete.dgns = FALSE,
                    prnt.plot = TRUE,
                    ...) {
-  .Deprecated(""plot_model"")
   # -----------------------------------------------------------
   # remember length of predictor variables
   # -----------------------------------------------------------
@@ -1062,6 +1061,7 @@ sjp.lm1 <- function(fit,
 }
 
 
+#' @importFrom effects effect
 sjp.lm.poly <- function(fit,
                         poly.term,
                         geom.colors,
@@ -1071,12 +1071,6 @@ sjp.lm.poly <- function(fit,
                         prnt.plot) {
   # check size argument
   if (is.null(geom.size)) geom.size <- .8
-  # ------------------------
-  # check if suggested package is available
-  # ------------------------
-  if (!requireNamespace(""effects"", quietly = TRUE)) {
-    stop(""Package `effects` needed for this function to work. Please install it."", call. = FALSE)
-  }
   # -------------------------------------
   # retrieve model matrix
   # -------------------------------------

---FILE: R/sjPlotOdds.R---
@@ -160,7 +160,6 @@ sjp.glm <- function(fit,
                     facet.grid = TRUE,
                     prnt.plot = TRUE,
                     ...) {
-  .Deprecated(""plot_model"")
   # check args -----
   if (type == ""pc"" || type == ""prob"") type <- ""slope""
 

---FILE: R/sjPlotPropTable.R---
@@ -55,7 +55,7 @@ utils::globalVariables(c(""rowname"", ""total"", ""ges"", ""prc"", ""n"", ""Count"", ""Group""
 #' library(sjmisc)
 #' library(sjlabelled)
 #' data(efc)
-#' sjp.setTheme(geom.label.angle = 90)
+#' set_theme(geom.label.angle = 90)
 #' sjp.xtab(efc$e42dep, efc$e16sex, vjust = ""center"", hjust = ""bottom"")
 #'
 #' # grouped bars with EUROFAMCARE sample dataset

---FILE: R/sjPlotSetTheme.R---
@@ -1,5 +1,5 @@
 #' @title Set global theme options for sjp-functions
-#' @name sjp.setTheme
+#' @name set_theme
 #'
 #' @description Set global theme options for sjp-functions.
 #'
@@ -107,133 +107,128 @@
 #'
 #' @return The customized theme object, or \code{NULL}, if a ggplot-theme was used.
 #'
-#' @details The \code{base} argument is intended to select a ggplot-theme
-#'            as base for further modifications (which can be triggered
-#'            via the various function arguments).
-#'
-#' @seealso \href{http://www.strengejacke.de/sjPlot/custplot/}{sjPlot manual: customize plot appearance}
-#'
-#' @references \itemize{
-#'              \item \href{http://zevross.com/blog/2014/08/04/beautiful-plotting-in-r-a-ggplot2-cheatsheet-3/}{Beautiful plotting in R: A ggplot2 cheatsheet}
-#'              \item \href{http://minimaxir.com/2015/02/ggplot-tutorial/}{An Introduction on How to Make Beautiful Charts With R and ggplot2}
-#'             }
+#' @seealso \code{\link{sjPlot-themes}}
 #'
 #' @examples
 #' \dontrun{
 #' library(sjmisc)
 #' data(efc)
 #' # set sjPlot-defaults, a slightly modification
 #' # of the ggplot base theme
-#' sjp.setTheme()
+#' set_theme()
 #'
 #' # legends of all plots inside
-#' sjp.setTheme(legend.pos = ""top left"",
-#'              legend.inside = TRUE)
+#' set_theme(legend.pos = ""top left"", legend.inside = TRUE)
 #' sjp.xtab(efc$e42dep, efc$e16sex)
 #'
 #' # Use classic-theme. you may need to
 #' # load the ggplot2-library.
 #' library(ggplot2)
-#' sjp.setTheme(base = theme_classic())
+#' set_theme(base = theme_classic())
 #' sjp.frq(efc$e42dep)
 #'
 #' # adjust value labels
-#' sjp.setTheme(geom.label.size = 3.5, geom.label.color = ""#3366cc"",
-#'              geom.label.angle = 90)
+#' set_theme(
+#'   geom.label.size = 3.5,
+#'   geom.label.color = ""#3366cc"",
+#'   geom.label.angle = 90
+#' )
+#'
 #' # hjust-aes needs adjustment for this
 #' update_geom_defaults('text', list(hjust = -0.1))
 #' sjp.xtab(efc$e42dep, efc$e16sex, vjust = ""center"", hjust = ""center"")
 #'
 #' # Create own theme based on classic-theme
-#' sjp.setTheme(base = theme_classic(), axis.linecolor = ""grey50"",
-#'              axis.textcolor = ""#6699cc"")
+#' set_theme(
+#'   base = theme_classic(), axis.linecolor = ""grey50"",
+#'   axis.textcolor = ""#6699cc""
+#' )
 #' sjp.frq(efc$e42dep)}
 #'
 #' @import ggplot2
 #' @importFrom scales brewer_pal grey_pal
 #' @importFrom dplyr case_when
 #' @export
-sjp.setTheme <- function(# base theme
-                         base = theme_grey(),
-                         theme.font = NULL,
-                         # title defaults
-                         title.color = ""black"",
-                         title.size = 1.2,
-                         title.align = ""left"",
-                         title.vjust = NULL,
-                         # geom defaults
-                         # geom.colors=NULL,
-                         geom.outline.color = NULL,
-                         geom.outline.size = 0,
-                         geom.boxoutline.size = 0.5,
-                         geom.boxoutline.color = ""black"",
-                         geom.alpha = 1,
-                         geom.linetype = 1,
-                         geom.errorbar.size = 0.7,
-                         geom.errorbar.linetype = 1,
-                         # value labels
-                         geom.label.color = NULL,
-                         geom.label.size = 4,
-                         geom.label.alpha = 1,
-                         geom.label.angle = 0,
-                         # axis titles
-                         axis.title.color = ""grey30"",
-                         axis.title.size = 1.1,
-                         axis.title.x.vjust = NULL,
-                         axis.title.y.vjust = NULL,
-                         # axis text angle
-                         axis.angle.x = 0,
-                         axis.angle.y = 0,
-                         axis.angle = NULL,
-                         # axis text colors
-                         axis.textcolor.x = ""grey30"",
-                         axis.textcolor.y = ""grey30"",
-                         axis.textcolor = NULL,
-                         # axis line colors
-                         axis.linecolor.x = NULL,
-                         axis.linecolor.y = NULL,
-                         axis.linecolor = NULL,
-                         axis.line.size = 0.5,
-                         # axis text size
-                         axis.textsize.x = 1,
-                         axis.textsize.y = 1,
-                         axis.textsize = NULL,
-                         # axis ticks
-                         axis.tickslen = NULL,
-                         axis.tickscol = NULL,
-                         axis.ticksmar = NULL,
-                         axis.ticksize.x = NULL,
-                         axis.ticksize.y = NULL,
-                         # panel defaults
-                         panel.backcol = NULL,
-                         panel.bordercol = NULL,
-                         panel.col = NULL,
-                         panel.major.gridcol = NULL,
-                         panel.minor.gridcol = NULL,
-                         panel.gridcol = NULL,
-                         panel.gridcol.x = NULL,
-                         panel.gridcol.y = NULL,
-                         panel.major.linetype = 1,
-                         panel.minor.linetype = 1,
-                         # plot background color
-                         plot.backcol = NULL,
-                         plot.bordercol = NULL,
-                         plot.col = NULL,
-                         plot.margins = NULL,
-                         # legend
-                         legend.pos = ""right"",
-                         legend.just = NULL,
-                         legend.inside = FALSE,
-                         legend.size = 1,
-                         legend.color = ""black"",
-                         legend.title.size = 1,
-                         legend.title.color = ""black"",
-                         legend.title.face = ""bold"",
-                         legend.backgroundcol = ""white"",
-                         legend.bordercol = ""white"",
-                         legend.item.size = NULL,
-                         legend.item.backcol = ""grey90"",
-                         legend.item.bordercol = ""white"") {
+set_theme <- function(base = theme_grey(),
+                      theme.font = NULL,
+                     # title defaults
+                     title.color = ""black"",
+                     title.size = 1.2,
+                     title.align = ""left"",
+                     title.vjust = NULL,
+                     # geom defaults
+                     # geom.colors=NULL,
+                     geom.outline.color = NULL,
+                     geom.outline.size = 0,
+                     geom.boxoutline.size = 0.5,
+                     geom.boxoutline.color = ""black"",
+                     geom.alpha = 1,
+                     geom.linetype = 1,
+                     geom.errorbar.size = 0.7,
+                     geom.errorbar.linetype = 1,
+                     # value labels
+                     geom.label.color = NULL,
+                     geom.label.size = 4,
+                     geom.label.alpha = 1,
+                     geom.label.angle = 0,
+                     # axis titles
+                     axis.title.color = ""grey30"",
+                     axis.title.size = 1.1,
+                     axis.title.x.vjust = NULL,
+                     axis.title.y.vjust = NULL,
+                     # axis text angle
+                     axis.angle.x = 0,
+                     axis.angle.y = 0,
+                     axis.angle = NULL,
+                     # axis text colors
+                     axis.textcolor.x = ""grey30"",
+                     axis.textcolor.y = ""grey30"",
+                     axis.textcolor = NULL,
+                     # axis line colors
+                     axis.linecolor.x = NULL,
+                     axis.linecolor.y = NULL,
+                     axis.linecolor = NULL,
+                     axis.line.size = 0.5,
+                     # axis text size
+                     axis.textsize.x = 1,
+                     axis.textsize.y = 1,
+                     axis.textsize = NULL,
+                     # axis ticks
+                     axis.tickslen = NULL,
+                     axis.tickscol = NULL,
+                     axis.ticksmar = NULL,
+                     axis.ticksize.x = NULL,
+                     axis.ticksize.y = NULL,
+                     # panel defaults
+                     panel.backcol = NULL,
+                     panel.bordercol = NULL,
+                     panel.col = NULL,
+                     panel.major.gridcol = NULL,
+                     panel.minor.gridcol = NULL,
+                     panel.gridcol = NULL,
+                     panel.gridcol.x = NULL,
+                     panel.gridcol.y = NULL,
+                     panel.major.linetype = 1,
+                     panel.minor.linetype = 1,
+                     # plot background color
+                     plot.backcol = NULL,
+                     plot.bordercol = NULL,
+                     plot.col = NULL,
+                     plot.margins = NULL,
+                     # legend
+                     legend.pos = ""right"",
+                     legend.just = NULL,
+                     legend.inside = FALSE,
+                     legend.size = 1,
+                     legend.color = ""black"",
+                     legend.title.size = 1,
+                     legend.title.color = ""black"",
+                     legend.title.face = ""bold"",
+                     legend.backgroundcol = ""white"",
+                     legend.bordercol = ""white"",
+                     legend.item.size = NULL,
+                     legend.item.backcol = ""grey90"",
+                     legend.item.bordercol = ""white"") {
   sjtheme <- NULL
   # ----------------------------------------
   # set defaults for geom label colors
@@ -667,110 +662,3 @@ sj.setGeomColors <- function(plot,
 
   plot
 }
-
-
-#' @title Save ggplot-figure for print publication
-#' @name save_plot
-#'
-#' @description Convenient function to save the last ggplot-figure in
-#'                high quality for publication.
-#'
-#' @param filename the name of the output file; filename must end with one
-#'          of the following acceptes file types: "".png"", "".jpg"", "".svg"" or "".tif"".
-#' @param fig the plot that should be saved. By default, the last plot is saved.
-#' @param width the width of the figure, in centimetres
-#' @param height the height of the figure, in centimetres
-#' @param dpi resolution in dpi (dots per inch). Ignored for vector formats, such as "".svg"".
-#' @param label.size fontsize of value labels inside plot area
-#' @param axis.textsize fontsize of axis labels
-#' @param axis.titlesize fontsize of axis titles
-#' @param legend.textsize fontsize of legend labels
-#' @param legend.titlesize fontsize of legend title
-#' @param legend.itemsize size of legend's item (legend key), in centimetres.
-#'
-#' @inheritParams sjp.setTheme
-#' @inheritParams set_theme
-#'
-#' @note This is a convenient function with some default settings that should
-#'         come close to most of the needs for fontsize and scaling in figures
-#'         when saving them for printing or publishing. It uses cairographics
-#'         anti-aliasing (see \code{\link[grDevices]{png}}).
-#'
-#' @import ggplot2
-#' @importFrom grDevices png jpeg tiff dev.off cm svg
-#' @export
-save_plot <- function(filename,
-                      fig = ggplot2::last_plot(),
-                      width = 12,
-                      height = 9,
-                      dpi = 300,
-                      theme = ggplot2::theme_get(),
-                      label.size = 2.4,
-                      axis.textsize = .8,
-                      axis.titlesize = .75,
-                      legend.textsize = .6,
-                      legend.titlesize = .65,
-                      legend.itemsize = .5) {
-  # -------------------------
-  # get file extension
-  # -------------------------
-  ext <- tolower(substring(filename,
-                           regexpr(""\\.[^\\.]*$"", filename) + 1,
-                           nchar(filename)))
-  # -------------------------
-  # valid file ytpe?
-  # -------------------------
-  if (!ext %in% c(""png"", ""jpg"", ""tif"", ""svg"")) {
-    stop(""filetype must be one of `.png`, `.jpg`, '.svg' or `.tif`."", call. = F)
-  }
-  # -------------------------
-  # set printable theme, adjust font sizes.
-  # this is the most critical point...
-  # -------------------------
-  sjp.setTheme(base = theme,
-    geom.label.color = ""black"",
-    axis.title.color = ""black"",
-    axis.textcolor = ""black"",
-    legend.title.color = ""black"",
-    legend.color = ""black"",
-    geom.label.size = label.size,
-    axis.textsize = axis.textsize,
-    axis.title.size = axis.titlesize,
-    legend.size = legend.textsize,
-    legend.title.size = legend.titlesize,
-    legend.item.size = legend.itemsize
-  )
-  # -------------------------
-  # prapare save
-  # -------------------------
-  if (ext == ""png"")
-    grDevices::png(filename = filename,
-        width = width,
-        height = height,
-        units = ""cm"",
-        res = dpi,
-        type = ""cairo"")
-  else if (ext == ""jpg"")
-    grDevices::jpeg(filename = filename,
-         width = width,
-         height = height,
-         units = ""cm"",
-         res = dpi,
-         type = ""cairo"")
-  else if (ext == ""tif"")
-    grDevices::tiff(filename = filename,
-                    width = width,
-                    height = height,
-                    units = ""cm"",
-                    res = dpi,
-                    type = ""cairo"")
-  else if (ext == 'svg')
-    grDevices::svg(filename = filename,
-                   width = width / grDevices::cm(1),
-                   height = height / grDevices::cm(1))
-
-  # print plot to device
-  graphics::plot(fig)
-  # close device
-  grDevices::dev.off()
-}

---FILE: man/plot_model.Rd---
@@ -2,10 +2,11 @@
 % Please edit documentation in R/plot_model.R
 \name{plot_model}
 \alias{plot_model}
+\alias{get_model_data}
 \title{Various plot types for regression models}
 \usage{
 plot_model(model, type = c(""est"", ""re"", ""eff"", ""pred"", ""int"", ""std"", ""std2"",
-  ""slope"", ""resid"", ""diag""), exponentiate, terms = NULL, sort.est = FALSE,
+  ""slope"", ""resid"", ""diag""), exponentiate, terms = NULL, sort.est = NULL,
   rm.terms = NULL, group.terms = NULL, order.terms = NULL,
   pred.type = c(""fe"", ""re""), ri.nr = NULL, title = NULL,
   axis.title = NULL, axis.labels = NULL, axis.lim = NULL,
@@ -14,6 +15,17 @@ plot_model(model, type = c(""est"", ""re"", ""eff"", ""pred"", ""int"", ""std"", ""std2"",
   value.offset = NULL, dot.size = NULL, line.size = NULL,
   colors = ""Set1"", facets, wrap.title = 50, wrap.labels = 25,
   case = ""parsed"", digits = 2, vline.color = NULL, ...)
+
+get_model_data(model, type = c(""est"", ""re"", ""eff"", ""pred"", ""int"", ""std"",
+  ""std2"", ""slope"", ""resid"", ""diag""), exponentiate, terms = NULL,
+  sort.est = NULL, rm.terms = NULL, group.terms = NULL,
+  order.terms = NULL, pred.type = c(""fe"", ""re""), ri.nr = NULL,
+  title = NULL, axis.title = NULL, axis.labels = NULL, axis.lim = NULL,
+  grid.breaks = NULL, ci.lvl = NULL, show.intercept = FALSE,
+  show.values = FALSE, show.p = TRUE, show.data = FALSE,
+  value.offset = NULL, dot.size = NULL, line.size = NULL,
+  colors = ""Set1"", facets, wrap.title = 50, wrap.labels = 25,
+  case = ""parsed"", digits = 2, vline.color = NULL, ...)
 }
 \arguments{
 \item{type}{Type of plot. Use one of following:
@@ -31,6 +43,12 @@ plot_model(model, type = c(""est"", ""re"", ""eff"", ""pred"", ""int"", ""std"", ""std2"",
   \item{\code{""vif""}}{to plot Variance Inflation Factors.}
 }}
 
+\item{exponentiate}{Logical, if \code{TRUE} and models inherit from generalized
+linear models, estimates will be exponentiated (e.g., log-odds will
+be displayed as odds ratios). By default, \code{exponentiate} will
+automatically be set to \code{FALSE} or \code{TRUE}, depending on
+the class of \code{fit}.}
+
 \item{terms}{Character vector with the names of those terms from \code{model}
 that should be plotted. This argument depends on the plot-type:
 \describe{
@@ -51,9 +69,42 @@ that should be plotted. This argument depends on the plot-type:
   }
 }}
 
+\item{sort.est}{Determines in which way estimates are sorted in the plot:
+\itemize{
+  \item If \code{NULL} (default), no sorting is done and estimates are sorted in the same order as they appear in the model formula.
+  \item If \code{TRUE}, estimates are sorted in descending order, with highedt estimate at the top.
+  \item If \code{sort.est = ""sort.all""}, estimates are re-sorted for each coefficient (only applies if \code{type = ""re""} and \code{facets = FALSE}), i.e. the estimates of the random effects for each predictor are sorted and plotted to an own plot.
+  \item If \code{type = ""re""}, specify a predictor's / coefficient's name to sort estimates according to this random effect.
+  }}
+
+\item{rm.terms}{Character vector with names that indicate which terms should
+be removed from the plot. Counterpart to \code{terms}.
+\code{rm.terms = ""t_name""} would remove the term \emph{t_name}.
+Default is \code{NULL}, i.e. all terms are used. Note that this
+argument does not apply to \code{type = ""eff""}, \code{type = ""pred""}
+or \code{type = ""int""}.}
+
+\item{axis.title}{Character vector of length one or two (depending on
+the plot function and type), used as title(s) for the x and y axis.
+If not specified, a default labelling  is chosen. \strong{Note:}
+Some plot types may not support this argument sufficiently. In such
+cases, use the returned ggplot-object and add axis titles manually with
+\code{\link[ggplot2]{labs}}.}
+
+\item{show.intercept}{Logical, if \code{TRUE}, the intercept of the fitted
+model is also plotted. Default is \code{FALSE}. If \code{exponentiate = TRUE},
+please note that due to exponential transformation of estimates, the
+intercept in some cases is non-finite and the plot can not be created.}
+
 \item{...}{Other arguments, passed down to various functions. Here is the
 description of these arguments in detail.
 \describe{
+  \item{\code{auto.label}}{
+    Logical value, if \code{TRUE} (the default), plot-labels are based
+    on value and variable labels, if the data is labelled. See
+    \code{\link[sjlabelled]{get_label}} and
+    \code{\link[sjlabelled]{get_term_labels}} for details.
+  }
   \item{\code{value.size}}{
     Numeric value, which can be used for all plot types where the
     argument \code{show.values} is applicable, e.g.

---FILE: man/plot_models.Rd---
@@ -39,9 +39,11 @@ be used for plotting. Default is no standardization.
 }}
 
 \item{rm.terms}{Character vector with names that indicate which terms should
-be removed from the plot. \code{rm.terms = ""t_name""} would remove the
-term \emph{t_name}. Default is \code{NULL}, i.e. all terms are
-used.}
+be removed from the plot. Counterpart to \code{terms}.
+\code{rm.terms = ""t_name""} would remove the term \emph{t_name}.
+Default is \code{NULL}, i.e. all terms are used. Note that this
+argument does not apply to \code{type = ""eff""}, \code{type = ""pred""}
+or \code{type = ""int""}.}
 
 \item{title}{character vector, used as plot title. Depending on plot type and function,
 will be set automatically. If \code{title = """"}, no title is printed.
@@ -65,14 +67,10 @@ argument, since in most cases, axis labels are set automatically.}
 
 \item{axis.title}{Character vector of length one or two (depending on
 the plot function and type), used as title(s) for the x and y axis.
-If not specified, a default labelling  is chosen. To set multiple
-axis titles (e.g. with \code{type = ""eff""} for many predictors),
-\code{axis.title} must be a character vector of same length of plots
-that are printed. In this case, each plot gets an own axis title
-(applying, for instance, to the y-axis for \code{type = ""eff""}).
-\strong{Note:} Some plot types do not support this argument. In such
-cases, use the return value and add axis titles manually with
-\code{\link[ggplot2]{labs}}, e.g.: \code{$plot.list[[1]] + labs(x = ...)}}
+If not specified, a default labelling  is chosen. \strong{Note:}
+Some plot types may not support this argument sufficiently. In such
+cases, use the returned ggplot-object and add axis titles manually with
+\code{\link[ggplot2]{labs}}.}
 
 \item{axis.lim}{Numeric vector of length 2, defining the range of the plot axis.
 Depending on plot type, may effect either x- or y-axis, or both.

---FILE: man/save_plot.Rd---
@@ -1,45 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/sjPlotSetTheme.R
-\name{save_plot}
-\alias{save_plot}
-\title{Save ggplot-figure for print publication}
-\usage{
-save_plot(filename, fig = ggplot2::last_plot(), width = 12, height = 9,
-  dpi = 300, theme = ggplot2::theme_get(), label.size = 2.4,
-  axis.textsize = 0.8, axis.titlesize = 0.75, legend.textsize = 0.6,
-  legend.titlesize = 0.65, legend.itemsize = 0.5)
-}
-\arguments{
-\item{filename}{the name of the output file; filename must end with one
-of the following acceptes file types: "".png"", "".jpg"", "".svg"" or "".tif"".}
-
-\item{fig}{the plot that should be saved. By default, the last plot is saved.}
-
-\item{width}{the width of the figure, in centimetres}
-
-\item{height}{the height of the figure, in centimetres}
-
-\item{dpi}{resolution in dpi (dots per inch). Ignored for vector formats, such as "".svg"".}
-
-\item{label.size}{fontsize of value labels inside plot area}
-
-\item{axis.textsize}{fontsize of axis labels}
-
-\item{axis.titlesize}{fontsize of axis titles}
-
-\item{legend.textsize}{fontsize of legend labels}
-
-\item{legend.titlesize}{fontsize of legend title}
-
-\item{legend.itemsize}{size of legend's item (legend key), in centimetres.}
-}
-\description{
-Convenient function to save the last ggplot-figure in
-               high quality for publication.
-}
-\note{
-This is a convenient function with some default settings that should
-        come close to most of the needs for fontsize and scaling in figures
-        when saving them for printing or publishing. It uses cairographics
-        anti-aliasing (see \code{\link[grDevices]{png}}).
-}

---FILE: man/set_theme.Rd---
@@ -1,12 +1,12 @@
 % Generated by roxygen2: do not edit by hand
 % Please edit documentation in R/sjPlotSetTheme.R
-\name{sjp.setTheme}
-\alias{sjp.setTheme}
+\name{set_theme}
+\alias{set_theme}
 \title{Set global theme options for sjp-functions}
 \usage{
-sjp.setTheme(base = theme_grey(), theme.font = NULL,
-  title.color = ""black"", title.size = 1.2, title.align = ""left"",
-  title.vjust = NULL, geom.outline.color = NULL, geom.outline.size = 0,
+set_theme(base = theme_grey(), theme.font = NULL, title.color = ""black"",
+  title.size = 1.2, title.align = ""left"", title.vjust = NULL,
+  geom.outline.color = NULL, geom.outline.size = 0,
   geom.boxoutline.size = 0.5, geom.boxoutline.color = ""black"",
   geom.alpha = 1, geom.linetype = 1, geom.errorbar.size = 0.7,
   geom.errorbar.linetype = 1, geom.label.color = NULL,
@@ -206,49 +206,43 @@ The customized theme object, or \code{NULL}, if a ggplot-theme was used.
 \description{
 Set global theme options for sjp-functions.
 }
-\details{
-The \code{base} argument is intended to select a ggplot-theme
-           as base for further modifications (which can be triggered
-           via the various function arguments).
-}
 \examples{
 \dontrun{
 library(sjmisc)
 data(efc)
 # set sjPlot-defaults, a slightly modification
 # of the ggplot base theme
-sjp.setTheme()
+set_theme()
 
 # legends of all plots inside
-sjp.setTheme(legend.pos = ""top left"",
-             legend.inside = TRUE)
+set_theme(legend.pos = ""top left"", legend.inside = TRUE)
 sjp.xtab(efc$e42dep, efc$e16sex)
 
 # Use classic-theme. you may need to
 # load the ggplot2-library.
 library(ggplot2)
-sjp.setTheme(base = theme_classic())
+set_theme(base = theme_classic())
 sjp.frq(efc$e42dep)
 
 # adjust value labels
-sjp.setTheme(geom.label.size = 3.5, geom.label.color = ""#3366cc"",
-             geom.label.angle = 90)
+set_theme(
+  geom.label.size = 3.5,
+  geom.label.color = ""#3366cc"",
+  geom.label.angle = 90
+)
+
 # hjust-aes needs adjustment for this
 update_geom_defaults('text', list(hjust = -0.1))
 sjp.xtab(efc$e42dep, efc$e16sex, vjust = ""center"", hjust = ""center"")
 
 # Create own theme based on classic-theme
-sjp.setTheme(base = theme_classic(), axis.linecolor = ""grey50"",
-             axis.textcolor = ""#6699cc"")
+set_theme(
+  base = theme_classic(), axis.linecolor = ""grey50"",
+  axis.textcolor = ""#6699cc""
+)
 sjp.frq(efc$e42dep)}
 
-}
-\references{
-\itemize{
-             \item \href{http://zevross.com/blog/2014/08/04/beautiful-plotting-in-r-a-ggplot2-cheatsheet-3/}{Beautiful plotting in R: A ggplot2 cheatsheet}
-             \item \href{http://minimaxir.com/2015/02/ggplot-tutorial/}{An Introduction on How to Make Beautiful Charts With R and ggplot2}
-            }
 }
 \seealso{
-\href{http://www.strengejacke.de/sjPlot/custplot/}{sjPlot manual: customize plot appearance}
+\code{\link{sjPlot-themes}}
 }

---FILE: man/sjp.frq.Rd---
@@ -210,7 +210,7 @@ sjp.frq(ChickWeight$weight, type = ""v"")
 # bar plot
 sjp.frq(ChickWeight$Diet)
 
-# you may use sjp.setTheme here to change axis textangle
+# you may use set_theme() here to change axis textangle
 sjp.frq(efc$e15relat)
 
 # grouped variable

---FILE: man/sjp.likert.Rd---
@@ -147,12 +147,11 @@ Note that only even numbers of categories are possible to plot, so the ""positive
 }
 \examples{
 # Data from the EUROFAMCARE sample dataset
-library(dplyr)
 library(sjmisc)
 data(efc)
 # find all variables from COPE-Index, which all have a ""cop"" in their
 # variable name, and then plot that subset as likert-plot
-efc[, find_var(efc, ""cop"")] \%>\% sjp.likert()
+find_var(efc, ""cop"", as.df = TRUE) \%>\% sjp.likert()
 
 sjp.likert(
   find_var(efc, ""cop"", as.df = TRUE),

---FILE: man/sjp.xtab.Rd---
@@ -171,7 +171,7 @@ sjp.xtab(x, grp, margin = ""row"", bar.pos = ""stack"",
 library(sjmisc)
 library(sjlabelled)
 data(efc)
-sjp.setTheme(geom.label.angle = 90)
+set_theme(geom.label.angle = 90)
 sjp.xtab(efc$e42dep, efc$e16sex, vjust = ""center"", hjust = ""bottom"")
 
 # grouped bars with EUROFAMCARE sample dataset

---FILE: vignettes/custplot.Rmd---
@@ -20,7 +20,7 @@ The examples refer to the `sjp.grpfrq` function, but most arguments are similar
 
 Tweaking plot appearance
 ------------------------
-The base function to globally change theme option for all sjp-function is `sjp.setTheme()`, and to use presets of themes, `set_theme()`. Except for geom-colors and geom-sizes, all theme-options can be set via this function. This new theme will be applied to all following plots created with the `sjPlot` package.
+The base function to globally change theme option for all sjp-function is `sjp.setTheme()`. Except for geom-colors and geom-sizes, all theme-options can be set via this function. This new theme will be applied to all following plots created with the `sjPlot` package.
 
 There are various arguments to change colors, sizes, angles etc. of labels. Following example show changes to colors, sizes, angles, geom-outlines and theme.
 ```{r}
@@ -51,12 +51,14 @@ All plotting functions support the usage of the [Colorbrewer](http://colorbrewer
 
 ```{r}
 # blank theme
-set_theme(theme = ""blank"",
-          axis.title.size = .9,
-          axis.textsize = .9,
-          legend.size = .7,
-          legend.title.size = .8,
-          geom.label.size = 3)
+sjp.setTheme(
+  base = theme_blank(),
+  axis.title.size = .9,
+  axis.textsize = .9,
+  legend.size = .7,
+  legend.title.size = .8,
+  geom.label.size = 3
+)
 sjp.grpfrq(efc$e42dep, 
            efc$e15relat, 
            geom.colors = ""PuRd"", 
@@ -113,15 +115,12 @@ sjp.frq(efc$e42dep)
 Pre-defined themes
 ------------------
 
-There is a set of pre-defined themes from the sjPlot-package that can be applied by calling `set_theme()`:
+There is a set of pre-defined themes from the sjPlot-package. See `?""sjPlot-themes""` for a complete list.
 
 ```{r}
-set_theme(""blank"")
-sjp.frq(efc$e42dep)
+sjp.frq(efc$e42dep) + theme_blank()
 
-set_theme(""scatter"")
-sjp.frq(efc$e42dep,
-        geom.colors = ""#2255aa"")
+sjp.frq(efc$e42dep, geom.colors = ""#2255aa"") + theme_sjplot()
 ```
 
 

---FILE: vignettes/plot_model_estimates.Rmd---
@@ -0,0 +1,102 @@
+---
+title: ""Plotting Estimates (Fixed Effects) of Regression Models""
+author: ""Daniel Ldecke""
+date: ""`r Sys.Date()`""
+output: rmarkdown::html_vignette
+vignette: >
+  %\VignetteIndexEntry{Plotting Estimates (Fixed Effects) of Regression Models}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+```{r echo = FALSE}
+knitr::opts_chunk$set(collapse = TRUE, comment = ""#>"", dev = ""png"", fig.width = 7, fig.height = 5, message = FALSE, warning = FALSE)
+```
+
+This document describes how to plot estimates as forest plots (or dot whisker plots) of various regression models, using the `plot_model()` function. `plot_model()` is a generic plot-function, which accepts many model-objects, like `lm`, `glm`, `lme`, `lmerMod` etc.
+
+`plot_model()` allows to create various plot tyes, which can be defined via the `type`-argument. The default is `type = ""fe""`, which means that fixed effects (model coefficients) are plotted. For mixed effects models, only fixed effects are plotted by default as well.
+
+```{r, results='hide'}
+library(sjPlot)
+library(sjmisc)
+library(sjlabelled)
+data(efc)
+```
+
+
+## Fitting a logistic regression model
+
+First, we fit an example model, which will be used in the following examples. The examples work in the same way for any other model as well.
+
+```{r results='hide'}
+# create binary response
+y <- ifelse(efc$neg_c_7 < median(na.omit(efc$neg_c_7)), 0, 1)
+
+# create data frame for fitting model
+df <- data.frame(
+  y = to_factor(y),
+  sex = to_factor(efc$c161sex),
+  dep = to_factor(efc$e42dep),
+  barthel = efc$barthtot,
+  education = to_factor(efc$c172code)
+)
+
+# set variable label for response
+set_label(df$y) <- ""High Negative Impact""
+
+# fit model
+m1 <- glm(y ~., data = df, family = binomial(link = ""logit""))
+
+# set variable label for service usage
+set_label(efc$tot_sc_e) <- ""Total number of services used by carer""
+```
+
+## Plotting estimates of generalized linear models
+
+The simplest function call is just passing the model object as argument. By default, estimates are sorted in descending order, with the highest effect at the top.
+
+```{r}
+plot_model(m1)
+``` 
+
+The ""neutral"" line, i.e. the vertical intercept that indicates no effect (x-axis position 1 for most glm's and position 0 for most linear models), is drawn slightly thicker than the other grid lines. You can change the line color with the `vline.color`-argument.
+
+```{r}
+plot_model(m1, vline.color = ""red"")
+``` 
+
+## Sorting estimates
+
+By default, the odds ratios are sorted from highest to lowest value. You can also keep the order of predictors as they were introduced into the model if you set `sort.est` to `FALSE`.
+```{r}
+plot_model(m1, sort.est = FALSE)
+``` 
+
+Another way to sort estimates is to use the `order.terms`-argument. This is a numeric vector, indicating the order of estimates in the plot. In the summary, we see that ""sex2"" is the first term, followed by the three dependency-categories (position 2-4), the Barthel-Index (5) and two levels for intermediate and high level of education (6 and 7).
+
+```{r}
+summary(m1)
+```
+
+Now we want the educational levels (6 and 7) first, than gender (1), followed by dependency (2-4)and finally the Barthel-Index (5). Use this order as numeric vector for the `order.terms`-argument.
+
+```{r}
+plot_model(m1, order.terms = c(6, 7, 1, 2, 3, 4, 5))
+``` 
+
+## Estimates on the untransformed scale 
+
+By default, `plot_model()` automatically exponentiates coefficients, if appropriate (e.g. for models with log or logit link). You can explicitley (dis-)allow this transformation using the `exponentiate`-argument.
+
+```{r}
+plot_model(m1, exponentiate = FALSE)
+``` 
+
+## Showing value labels
+
+By default, just the dots and error bars are plotted. Use `show.values = TRUE` to show the value labels with the estimates values, and use `show.p = FALSE` to suppress the asterisks that indicate the significance level of the p-values.
+
+```{r}
+plot_model(m1, show.values = TRUE)
+``` 
+

---FILE: vignettes/sjpglm.Rmd---
@@ -20,11 +20,13 @@ library(sjmisc)
 library(sjlabelled)
 data(efc)
 # set basic theme options
-set_theme(""forest"",
-          axis.title.size = .85, 
-          axis.textsize = .85, 
-          legend.size = .8, 
-          geom.label.size = 3.5)
+sjp.setTheme(
+  base = theme_sjplot(),
+  axis.title.size = .85, 
+  axis.textsize = .85, 
+  legend.size = .8, 
+  geom.label.size = 3.5
+)
 ```
 
 
@@ -117,16 +119,6 @@ As you can see in the above examples, multiple plots for `type = ""eff""` are plot
 
 To arrange all predictors of multiple in one plot, as grid, use the `plot_grid()` function _on multiple plot objects_. `plot_grid()` requires multiple plots, so you have to set `facet.grid = FALSE` to get a `plot.list`-value as return value from the function (see `?sjp.lm` on _Return Value_ for more details). This allows you arrange multiple plots as grid in one plot, but with different x-axis-scales.
 
-```{r echo=FALSE, results='hide'}
-# set basic theme options
-set_theme(""forestw"",
-          axis.title.size = .65, 
-          axis.textsize = .7, 
-          legend.size = .6, 
-          geom.label.size = 3,
-          title.size = .7)
-```
-
 ```{r}
 # get list of all plots
 p <- sjp.glm(fit, type = ""eff"", facet.grid = FALSE, 

---FILE: vignettes/sjplmer.Rmd---
@@ -23,10 +23,6 @@ library(sjlabelled)
 
 # load sample data set.
 data(efc)
-set_theme(theme = ""forest"", 
-          geom.label.size = 3, 
-          axis.textsize = .9, 
-          axis.title.size = .9)
 ```
 
 ## Plotting random effects of linear mixed effects models"
strengejacke,sjPlot,eebda7cb5da05cc471f5c26b96b621c4ef607cda,Daniel,mail@danielluedecke.de,2017-10-01T12:06:18Z,Daniel,mail@danielluedecke.de,2017-10-01T12:06:18Z,minor fix,R/plot_point_estimates.R;R/plot_type_eff.R;R/plot_type_ranef.R,False,True,True,False,8,1,9,"---FILE: R/plot_point_estimates.R---
@@ -54,7 +54,12 @@ plot_point_estimates <- function(model,
     size <- major_size * 2
     geom_hline(yintercept = yintercept, color = color, size = size)
   } else {
-    geom_ignore()
+    geom_blank(
+      mapping = NULL,
+      data = NULL,
+      show.legend = FALSE,
+      inherit.aes = FALSE
+    )
   }
 
 

---FILE: R/plot_type_eff.R---
@@ -1,3 +1,4 @@
+#' @importFrom ggeffects ggpredict ggeffect
 plot_type_eff <- function(type,
                           model,
                           terms,

---FILE: R/plot_type_ranef.R---
@@ -38,6 +38,7 @@ plot_type_ranef <- function(type,
 
   ri.cnt <- length(ranef)
 
+
   # how many plots? if we have random effects plots,
   # determine number of random effects and iterate
   # all effects"
strengejacke,sjPlot,f37ebc332344c9495cbfc634bda1b451ecbd929e,Daniel,mail@danielluedecke.de,2017-09-29T16:15:53Z,Daniel,mail@danielluedecke.de,2017-09-29T16:15:53Z,fix issues with mixed models in plot_model(),DESCRIPTION;NAMESPACE;R/plot_model.R;R/plot_model_estimates.R;R/plot_point_estimates.R;R/plot_type_est.R;R/tidiers.R;R/utils.R;man/plot_model.Rd,False,True,True,False,143,75,218,"---FILE: DESCRIPTION---
@@ -45,7 +45,8 @@ Imports:
     scales,
     sjlabelled (>= 1.0.3),
     sjmisc (>= 2.6.1),
-    sjstats (>= 0.11.1),
+    sjstats (>= 0.11.2),
+    tidyselect,
     tibble (>= 1.3.3),
     tidyr (>= 0.7.0)
 Suggests:

---FILE: NAMESPACE---
@@ -271,6 +271,7 @@ importFrom(tidyr,gather)
 importFrom(tidyr,nest)
 importFrom(tidyr,spread)
 importFrom(tidyr,unnest)
+importFrom(tidyselect,starts_with)
 importFrom(utils,browseURL)
 importFrom(utils,setTxtProgressBar)
 importFrom(utils,txtProgressBar)

---FILE: R/plot_model.R---
@@ -6,28 +6,36 @@
 #' @param type Type of plot. Use one of following:
 #'          \describe{
 #'            \item{\code{""est""}}{(default) for forest-plot of estimates. If the fitted model only contains one predictor, slope-line is plotted.}
-#'            \item{\code{""pred""}}{to plot predicted values (marginal effects) for specific model terms. See 'Details'.}
-#'            \item{\code{""eff""}}{to plot marginal effects of all terms in \code{model}. Note that interaction terms are excluded from this plot.}
+#'            \item{\code{""re""}}{for mixed effects models, plots the random effects.}
+#'            \item{\code{""pred""}}{to plot predicted values (marginal effects) for specific model terms. \code{\link[ggeffects]{ggpredict}}.}
+#'            \item{\code{""eff""}}{similar to \code{type = ""pred""}, however, discrete predictors are held constant at their proportions (not reference level). See \code{\link[ggeffects]{ggeffect}} for details.}
 #'            \item{\code{""int""}}{to plot marginal effects of interaction terms in \code{model}.}
 #'            \item{\code{""std""}}{for forest-plot of standardized beta values.}
 #'            \item{\code{""std2""}}{for forest-plot of standardized beta values, however, standardization is done by dividing by two sd (see 'Details').}
 #'            \item{\code{""slope""}}{to plot regression lines for each single predictor of the fitted model, against the response (linear relationship between each model term and response).}
 #'            \item{\code{""resid""}}{to plot regression lines for each single predictor of the fitted model, against the residuals (linear relationship between each model term and residuals). May be used for model diagnostics.}
-#'            \item{\code{""ma""}}{to check model assumptions.}
+#'            \item{\code{""diag""}}{to check model assumptions.}
 #'            \item{\code{""vif""}}{to plot Variance Inflation Factors.}
 #'          }
-#' @param terms Character vector with the names of those from \code{model}, which
-#'          should be used to plot for. This argument depends on the plot-type;
-#'          for \code{type = ""pred""} or \code{type = ""eff""}, \code{terms} indicates
-#'          for which terms marginal effects should be displayed. At least one term
-#'          is required to calculate effects, maximum length is three terms,
-#'          where the second and third term indicate the groups, i.e. predictions
-#'          of first term are grouped by the levels of the second (and third)
-#'          term. Indicating levels in square brackets allows for selecting
-#'          only specific groups. Term name and levels in brackets must be
-#'          separated by a whitespace character, e.g.
-#'          \code{terms = c(""age"", ""education [1,3]"")}. For more details, see
-#'          \code{\link[ggeffects]{ggpredict}}.
+#' @param terms Character vector with the names of those terms from \code{model}
+#'          that should be plotted. This argument depends on the plot-type:
+#'          \describe{
+#'            \item{\code{type = ""est""}}{
+#'              Select terms that should be plotted. All other term are removed
+#'              from the output.
+#'            }
+#'            \item{\code{type = ""pred""} or \code{type = ""eff""}}{
+#'              Here \code{terms} indicates for which terms marginal effects
+#'              should be displayed. At least one term is required to calculate
+#'              effects, maximum length is three terms, where the second and
+#'              third term indicate the groups, i.e. predictions of first term
+#'              are grouped by the levels of the second (and third) term.
+#'              Indicating levels in square brackets allows for selecting only
+#'              specific groups. Term name and levels in brackets must be separated
+#'              by a whitespace character, e.g. \code{terms = c(""age"", ""education [1,3]"")}.
+#'              For more details, see \code{\link[ggeffects]{ggpredict}}.
+#'            }
+#'          }
 #' @param ... Other arguments, passed down to various functions. Here is the
 #'        description of these arguments in detail.
 #'        \describe{
@@ -60,7 +68,6 @@
 #' @importFrom sjstats pred_vars std_beta p_value
 #' @importFrom sjmisc word_wrap str_contains
 #' @importFrom sjlabelled get_dv_labels get_term_labels
-#' @importFrom broom tidy
 #' @importFrom dplyr if_else n_distinct
 #' @importFrom graphics plot
 #' @importFrom ggeffects ggpredict ggeffect
@@ -96,8 +103,7 @@ plot_model <- function(model,
                        wrap.labels = 25,
                        case = NULL,
                        digits = 2,
-                       vline.type = 2,
-                       vline.color = ""grey70"",
+                       vline.color = NULL,
                        ...
                        ) {
 
@@ -172,9 +178,8 @@ plot_model <- function(model,
       geom.colors = colors,
       geom.size = dot.size,
       line.size = line.size,
-      vline.type = vline.type,
-      vline.color = vline.color,
       order.terms = order.terms,
+      vline.color = vline.color,
       ...
     )
   } else if (type == ""re"") {

---FILE: R/plot_model_estimates.R---
@@ -21,10 +21,9 @@ plot_model_estimates <- function(fit,
                                  geom.colors,
                                  geom.size,
                                  line.size,
-                                 vline.type,
-                                 vline.color,
                                  bpe.style,
-                                 term.order) {
+                                 term.order,
+                                 vline.color) {
 
   # remove intercept from output
 
@@ -127,9 +126,8 @@ plot_model_estimates <- function(fit,
     geom.size = geom.size,
     line.size = line.size,
     geom.colors = geom.colors,
-    vline.type = vline.type,
-    vline.color = vline.color,
-    bpe.style = bpe.style
+    bpe.style = bpe.style,
+    vline.color = vline.color
   )
 }
 

---FILE: R/plot_point_estimates.R---
@@ -14,9 +14,8 @@ plot_point_estimates <- function(model,
                                  geom.size,
                                  line.size,
                                  geom.colors,
-                                 vline.type,
-                                 vline.color,
-                                 bpe.style) {
+                                 bpe.style,
+                                 vline.color) {
 
   # need some additional data, for stan-geoms
 
@@ -25,13 +24,49 @@ plot_point_estimates <- function(model,
   dat$xmax <- dat$xpos + (geom.size * .1)
 
 
+  # set default for empty titles/labels
+
+  if (sjmisc::is_empty(title)) title <- NULL
+  if (sjmisc::is_empty(axis.labels)) axis.labels <- dat$term
+  if (sjmisc::is_empty(axis.title)) axis.title <- NULL
+
+
+  # axis limits and tick breaks for y-axis
+
+  axis.scaling <- get_axis_limits_and_ticks(
+    axis.lim = axis.lim,
+    min.val = min(dat$conf.low),
+    max.val = max(dat$conf.high),
+    grid.breaks = grid.breaks,
+    exponentiate = exponentiate
+  )
+
+
+  # based on current ggplot theme, highlights vertical default line
+
+  yintercept = ifelse(exponentiate, 1, 0)
+
+  layer_vertical_line <- if (yintercept > axis.scaling$axis.lim[1] && yintercept < axis.scaling$axis.lim[2]) {
+    t <- theme_get()
+    color <- nulldef(vline.color, t$panel.grid.major$colour, ""grey90"")
+    minor_size <- nulldef(t$panel.grid.minor$size, .125)
+    major_size <- nulldef(t$panel.grid.major$size, minor_size * 2)
+    size <- major_size * 2
+    geom_hline(yintercept = yintercept, color = color, size = size)
+  } else {
+    geom_ignore()
+  }
+
+
   # basis aes mapping
+
   p <- ggplot(dat, aes_string(x = ""term"", y = ""estimate"", colour = ""group"", fill = ""group""))
 
+
   if (is.stan(model)) {
     # special setup for rstan-models
     p <- p +
-      geom_hline(yintercept = ifelse(exponentiate, 1, 0), linetype = vline.type, color = vline.color) +
+      layer_vertical_line +
       geom_errorbar(aes_string(ymin = ""conf.low"", ymax = ""conf.high""), size = line.size, width = .06) +
       geom_rect(aes_string(ymin = ""conf.low50"", ymax = ""conf.high50"", xmin = ""xmin"", xmax = ""xmax""), colour = ""white"", size = .5)
 
@@ -45,7 +80,7 @@ plot_point_estimates <- function(model,
   } else {
     # setup base plot
     p <- p +
-      geom_hline(yintercept = ifelse(exponentiate, 1, 0), linetype = vline.type, color = vline.color) +
+      layer_vertical_line +
       geom_point(size = geom.size) +
       geom_errorbar(aes_string(ymin = ""conf.low"", ymax = ""conf.high""), width = 0, size = line.size)
   }
@@ -78,17 +113,6 @@ plot_point_estimates <- function(model,
   p <- p + scale_x_discrete(labels = axis.labels)
 
 
-  # axis limits and tick breaks for y-axis
-
-  axis.scaling <- get_axis_limits_and_ticks(
-    axis.lim = axis.lim,
-    min.val = min(dat$conf.low),
-    max.val = max(dat$conf.high),
-    grid.breaks = grid.breaks,
-    exponentiate = exponentiate
-  )
-
-
   # we need transformed scale for exponentiated estimates
 
   if (exponentiate) {

---FILE: R/plot_type_est.R---
@@ -1,3 +1,5 @@
+#' @importFrom tibble has_name
+#' @importFrom broom tidy
 plot_type_est <- function(type,
                           ci.lvl,
                           exponentiate,
@@ -19,20 +21,28 @@ plot_type_est <- function(type,
                           geom.colors,
                           geom.size,
                           line.size,
-                          vline.type,
+                          order.terms,
                           vline.color,
-                          order.terms = order.terms,
                           ...) {
 
   # get tidy output of summary ----
 
   if (type == ""est"") {
     ## TODO provide own tidier for not-supported models
 
-    if (is.stan(model))
-      dat <- tidy_stan(model, ci.lvl, exponentiate, ...)
-    else
+    # for stan models, we have our own tidyr. for other models,
+    # we use pkg broom, and may need to tweak the output a bit...
+
+    if (is.stan(model)) {
+      dat <- tidy_stan_model(model, ci.lvl, exponentiate, type, ...)
+    } else {
+      # tidy the model
       dat <- broom::tidy(model, conf.int = TRUE, conf.level = ci.lvl, effects = ""fixed"")
+
+      # see if we have p-values. if not, add them
+      if (!tibble::has_name(dat, ""p.value""))
+        dat$p.value <- sjstats::p_value(model)[[""p.value""]]
+    }
   } else {
     dat <- model %>%
       sjstats::std_beta(type = type, ci.lvl = ci.lvl) %>%
@@ -75,9 +85,8 @@ plot_type_est <- function(type,
     geom.colors = geom.colors,
     geom.size = geom.size,
     line.size = line.size,
-    vline.type = vline.type,
-    vline.color = vline.color,
     bpe.style = bpe.style,
-    term.order = order.terms
+    term.order = order.terms,
+    vline.color = vline.color
   )
 }

---FILE: R/tidiers.R---
@@ -1,10 +1,11 @@
 #' @importFrom sjstats hdi typical_value
-#' @importFrom sjmisc var_rename add_columns
-#' @importFrom dplyr select filter
+#' @importFrom sjmisc var_rename add_columns is_empty
+#' @importFrom dplyr select filter slice
 #' @importFrom tibble add_column
 #' @importFrom purrr map_dbl
 #' @importFrom rlang .data
-tidy_stan <- function(fit, ci.lvl, exponentiate, ...) {
+#' @importFrom tidyselect starts_with
+tidy_stan_model <- function(fit, ci.lvl, exponentiate, type, ...) {
 
   # check if values should be exponentiated
 
@@ -34,8 +35,8 @@ tidy_stan <- function(fit, ci.lvl, exponentiate, ...) {
 
   # get two HDI-intervals
 
-  d1 <- sjstats::hdi(fit, prob = p.outer, trans = funtrans)
-  d2 <- sjstats::hdi(fit, prob = p.inner, trans = funtrans)
+  d1 <- sjstats::hdi(fit, prob = p.outer, trans = funtrans, type = ""all"")
+  d2 <- sjstats::hdi(fit, prob = p.inner, trans = funtrans, type = ""all"")
 
 
   # bind columns, so we have inner and outer hdi interval
@@ -63,11 +64,21 @@ tidy_stan <- function(fit, ci.lvl, exponentiate, ...) {
   if (""lp__"" %in% dat$term) dat <- dplyr::filter(dat, .data$term != ""lp__"")
 
 
+  # check if we need to remove random effects
+
+  if (type == ""est"") {
+    # remove all random effect intercepts
+    re <- tidyselect::starts_with(""b["", vars = dat$term)
+    if (!sjmisc::is_empty(re)) dat <- dplyr::slice(dat, !! -re)
+
+    # and all random effect error terms
+    re.s <- tidyselect::starts_with(""Sigma["", vars = dat$term)
+    if (!sjmisc::is_empty(re.s)) dat <- dplyr::slice(dat, !! -re.s)
+  }
+
+
   # need to transform point estimate as well
   if (exponentiate) dat$estimate <- exp(dat$estimate)
 
   dat
 }
-
-
-

---FILE: R/utils.R---
@@ -178,3 +178,14 @@ get_glm_family <- function(fit) {
     )
   )
 }
+
+
+nulldef <- function(x, y, z = NULL) {
+  if (is.null(x)) {
+    if (is.null(y))
+      z
+    else
+      y
+  } else
+    x
+}

---FILE: man/plot_model.Rd---
@@ -13,35 +13,43 @@ plot_model(model, type = c(""est"", ""re"", ""eff"", ""pred"", ""int"", ""std"", ""std2"",
   show.p = TRUE, show.data = FALSE, value.offset = NULL,
   dot.size = NULL, line.size = NULL, colors = ""Set1"", facets,
   wrap.title = 50, wrap.labels = 25, case = NULL, digits = 2,
-  vline.type = 2, vline.color = ""grey70"", ...)
+  vline.color = NULL, ...)
 }
 \arguments{
 \item{type}{Type of plot. Use one of following:
 \describe{
   \item{\code{""est""}}{(default) for forest-plot of estimates. If the fitted model only contains one predictor, slope-line is plotted.}
-  \item{\code{""pred""}}{to plot predicted values (marginal effects) for specific model terms. See 'Details'.}
-  \item{\code{""eff""}}{to plot marginal effects of all terms in \code{model}. Note that interaction terms are excluded from this plot.}
+  \item{\code{""re""}}{for mixed effects models, plots the random effects.}
+  \item{\code{""pred""}}{to plot predicted values (marginal effects) for specific model terms. \code{\link[ggeffects]{ggpredict}}.}
+  \item{\code{""eff""}}{similar to \code{type = ""pred""}, however, discrete predictors are held constant at their proportions (not reference level). See \code{\link[ggeffects]{ggeffect}} for details.}
   \item{\code{""int""}}{to plot marginal effects of interaction terms in \code{model}.}
   \item{\code{""std""}}{for forest-plot of standardized beta values.}
   \item{\code{""std2""}}{for forest-plot of standardized beta values, however, standardization is done by dividing by two sd (see 'Details').}
   \item{\code{""slope""}}{to plot regression lines for each single predictor of the fitted model, against the response (linear relationship between each model term and response).}
   \item{\code{""resid""}}{to plot regression lines for each single predictor of the fitted model, against the residuals (linear relationship between each model term and residuals). May be used for model diagnostics.}
-  \item{\code{""ma""}}{to check model assumptions.}
+  \item{\code{""diag""}}{to check model assumptions.}
   \item{\code{""vif""}}{to plot Variance Inflation Factors.}
 }}
 
-\item{terms}{Character vector with the names of those from \code{model}, which
-should be used to plot for. This argument depends on the plot-type;
-for \code{type = ""pred""} or \code{type = ""eff""}, \code{terms} indicates
-for which terms marginal effects should be displayed. At least one term
-is required to calculate effects, maximum length is three terms,
-where the second and third term indicate the groups, i.e. predictions
-of first term are grouped by the levels of the second (and third)
-term. Indicating levels in square brackets allows for selecting
-only specific groups. Term name and levels in brackets must be
-separated by a whitespace character, e.g.
-\code{terms = c(""age"", ""education [1,3]"")}. For more details, see
-\code{\link[ggeffects]{ggpredict}}.}
+\item{terms}{Character vector with the names of those terms from \code{model}
+that should be plotted. This argument depends on the plot-type:
+\describe{
+  \item{\code{type = ""est""}}{
+    Select terms that should be plotted. All other term are removed
+    from the output.
+  }
+  \item{\code{type = ""pred""} or \code{type = ""eff""}}{
+    Here \code{terms} indicates for which terms marginal effects
+    should be displayed. At least one term is required to calculate
+    effects, maximum length is three terms, where the second and
+    third term indicate the groups, i.e. predictions of first term
+    are grouped by the levels of the second (and third) term.
+    Indicating levels in square brackets allows for selecting only
+    specific groups. Term name and levels in brackets must be separated
+    by a whitespace character, e.g. \code{terms = c(""age"", ""education [1,3]"")}.
+    For more details, see \code{\link[ggeffects]{ggpredict}}.
+  }
+}}
 
 \item{...}{Other arguments, passed down to various functions. Here is the
 description of these arguments in detail."
strengejacke,sjPlot,2dad805735ec18804acc1ec5cc36a5ab8aebc1e4,Daniel,mail@danielluedecke.de,2017-09-25T15:55:02Z,Daniel,mail@danielluedecke.de,2017-09-25T15:55:02Z,fix issues with automatic axis limits calculation,R/plot_diag_stan.R;R/utils.R,False,True,True,False,7,0,7,"---FILE: R/plot_diag_stan.R---
@@ -30,6 +30,8 @@ plot_diag_stan <- function(model, geom.colors, facets, ...) {
   if (!facets) {
     d1 <- dplyr::select(d1, -.data$`(Intercept)`)
     d2 <- dplyr::select(d2, -.data$`(Intercept)`)
+    d1 <- dplyr::select(d1, -.data$sigma)
+    d2 <- dplyr::select(d2, -.data$sigma)
   }
 
 

---FILE: R/utils.R---
@@ -17,6 +17,11 @@ get_axis_limits_and_ticks <- function(axis.lim, min.val, max.val, grid.breaks, e
   fac.ll <- dplyr::if_else(exponentiate, .3, .95)
   fac.ul <- dplyr::if_else(exponentiate, 3.3, 1.05)
 
+  # for negative signes, need to change multiplier
+  if (min.val < 0) fac.ll <- 1 / fac.ll
+  if (max.val < 0) fac.ul <- 1 / fac.ul
+
+
   # axis limits
   if (is.null(axis.lim)) {
     lower_lim <- min.val * fac.ll"
strengejacke,sjPlot,01201f2355a0353dee6bd3d85dd5e3fb90abd598,Daniel,mail@danielluedecke.de,2017-09-23T07:25:19Z,Daniel,mail@danielluedecke.de,2017-09-23T07:25:19Z,fix pkg dependencies,DESCRIPTION,False,False,False,False,1,1,2,"---FILE: DESCRIPTION---
@@ -45,7 +45,7 @@ Imports:
     scales,
     sjlabelled (>= 1.0.3),
     sjmisc (>= 2.6.1),
-    sjstats (>= 0.11.2),
+    sjstats (>= 0.11.1),
     tibble (>= 1.3.3),
     tidyr (>= 0.7.0)
 Suggests:"
strengejacke,sjPlot,995ae284b1b42426536f253f1d7c0aa104b6d1e4,Daniel,mail@danielluedecke.de,2017-09-16T06:41:41Z,Daniel,mail@danielluedecke.de,2017-09-16T06:41:41Z,fix issues with color handling,R/plot_model.R;R/plot_model_estimates.R;R/plot_point_estimates.R;Rplots.pdf;man/plot_model.Rd,False,True,True,False,35,62,97,"---FILE: R/plot_model.R---
@@ -51,7 +51,7 @@ plot_model <- function(fit,
                        show.values = FALSE,
                        show.p = FALSE,
                        geom.size = .9,
-                       geom.colors = ""Set1"",
+                       geom.colors = NULL,
                        facets,
                        wrap.title = 50,
                        wrap.labels = 25,

---FILE: R/plot_model_estimates.R---
@@ -47,6 +47,9 @@ plot_model_estimates <- function(fit,
 
   if (show.p) dat$p.label <- sprintf(""%s %s"", dat$p.label, dat$p.stars)
 
+  # create dummy grouping
+  dat$group <- as.factor(1)
+
   # group estimates?
   if (!is.null(group.terms)) {
     if (length(group.terms) == nrow(dat)) {
@@ -70,6 +73,15 @@ plot_model_estimates <- function(fit,
     dat$term <- forcats::fct_rev(dat$term)
   }
 
+  # set default colors. for grouped predictors
+  # we need more color values
+  if (is.null(geom.colors)) {
+    if (!is.null(group.terms))
+      geom.colors <- ""Set1""
+    else
+      geom.colors <- ""grey30""
+  }
+
   p <- plot_point_estimates(
     model = fit,
     dat = dat,

---FILE: R/plot_point_estimates.R---
@@ -1,5 +1,6 @@
 #' @importFrom tibble has_name
 #' @importFrom dplyr n_distinct
+#' @importFrom sjmisc to_value
 plot_point_estimates <- function(model,
                                  dat,
                                  exponentiate,
@@ -14,41 +15,36 @@ plot_point_estimates <- function(model,
                                  vline.type,
                                  vline.color) {
 
+  # need some additional data, for stan-geoms
+  dat$xpos <- sjmisc::to_value(dat$term, start.at = 1)
+  dat$xmin <- dat$xpos - (geom.size * .1)
+  dat$xmax <- dat$xpos + (geom.size * .1)
+
+  # basis aes mapping
+  p <- ggplot(dat, aes_string(x = ""term"", y = ""estimate"", colour = ""group"", fill = ""group""))
+
   if (inherits(model, c(""stanreg"", ""stanfit""))) {
     # special setup for rstan-models
-    p <- plot_rstan_estimates(
-      model,
-      dat,
-      exponentiate,
-      geom.size,
-      geom.colors,
-      vline.type,
-      vline.color
-    )
-
-    # only one color
-    col.len <- 1
+    p <- p +
+      geom_hline(yintercept = ifelse(exponentiate, 1, 0), linetype = vline.type, color = vline.color) +
+      geom_errorbar(aes_string(ymin = ""conf.low"", ymax = ""conf.high""), width = .05) +
+      geom_rect(aes_string(ymin = ""conf.low50"", ymax = ""conf.high50"", xmin = ""xmin"", xmax = ""xmax""), colour = ""white"", size = .5) +
+      geom_point(aes_string(y = ""estimate""), fill = ""white"", colour = ""white"", size = geom.size * 1.2)
   } else {
-    # set up base aes, either with or w/o groups
-    if (tibble::has_name(dat, ""group"")) {
-      p <- ggplot(dat, aes_string(x = ""term"", y = ""estimate"", colour = ""group""))
-      col.len <- dplyr::n_distinct(dat$group)
-    } else {
-      p <- ggplot(dat, aes_string(x = ""term"", y = ""estimate""))
-      col.len <- 1
-    }
-
     # setup base plot
     p <- p +
       geom_hline(yintercept = ifelse(exponentiate, 1, 0), linetype = vline.type, color = vline.color) +
       geom_point(size = geom.size) +
       geom_errorbar(aes_string(ymin = ""conf.low"", ymax = ""conf.high""), width = 0)
   }
 
+  # set up base aes, either with or w/o groups
+  col.len <- dplyr::n_distinct(dat$group)
+
   # flip plot, and remove legend
   p <- p +
     coord_flip() +
-    guides(colour = ""none"")
+    guides(colour = ""none"", fill = ""none"")
 
   # add value labels
   if (show.values) p <- p +
@@ -87,7 +83,9 @@ plot_point_estimates <- function(model,
   }
 
   # set colors
-  p <- p + scale_colour_manual(values = col_check2(geom.colors, col.len))
+  p <- p +
+    scale_colour_manual(values = col_check2(geom.colors, col.len)) +
+    scale_fill_manual(values = col_check2(geom.colors, col.len))
 
   # set axis and plot titles
   p <-
@@ -99,40 +97,3 @@ plot_point_estimates <- function(model,
 
   p
 }
-
-
-
-#' @importFrom sjmisc to_value
-plot_rstan_estimates <-
-  function(model,
-           dat,
-           exponentiate,
-           geom.size,
-           geom.colors,
-           vline.type,
-           vline.color) {
-
-  dat$xpos <- sjmisc::to_value(dat$term, start.at = 1)
-  dat$xmin <- dat$xpos - (geom.size * .1)
-  dat$xmax <- dat$xpos + (geom.size * .1)
-
-  p <- ggplot(dat, aes_string(x = ""term"")) +
-    geom_hline(yintercept = ifelse(exponentiate, 1, 0), linetype = vline.type, color = vline.color) +
-    geom_errorbar(
-      aes_string(ymin = ""conf.low"", ymax = ""conf.high""),
-      width = .05
-    ) +
-    geom_rect(
-      aes_string(ymin = ""conf.low50"", ymax = ""conf.high50"", xmin = ""xmin"", xmax = ""xmax""),
-      colour = ""white"",
-      size = .5
-    ) +
-    geom_point(
-      aes_string(y = ""estimate""),
-      fill = ""white"",
-      colour = ""white"",
-      size = geom.size * 1.2
-    )
-
-  p
-}

---FILE: man/plot_model.Rd---
@@ -9,7 +9,7 @@ plot_model(fit, type = ""est"", exponentiate, terms = NULL,
   axis.title = NULL, axis.labels = NULL, axis.lim = NULL,
   grid.breaks = NULL, ci.lvl = 0.95, show.intercept = FALSE,
   show.values = FALSE, show.p = FALSE, geom.size = 0.9,
-  geom.colors = ""Set1"", facets, wrap.title = 50, wrap.labels = 25,
+  geom.colors = NULL, facets, wrap.title = 50, wrap.labels = 25,
   case = NULL, digits = 2, vline.type = 2, vline.color = ""grey70"", ...)
 }
 \arguments{"
strengejacke,sjPlot,6b232e6b52e8b6fa11680ab2084b240a790c7b37,Daniel,mail@danielluedecke.de,2017-09-15T09:02:05Z,Daniel,mail@danielluedecke.de,2017-09-15T09:02:05Z,fix issue with intercept line,R/plot_point_estimates.R,False,True,True,False,1,1,2,"---FILE: R/plot_point_estimates.R---
@@ -26,7 +26,7 @@ plot_point_estimates <- function(model,
 
   # setup base plot
   p <- p +
-    geom_hline(yintercept = 0, linetype = vline.type, color = vline.color) +
+    geom_hline(yintercept = ifelse(exponentiate, 1, 0), linetype = vline.type, color = vline.color) +
     geom_point(size = geom.size) +
     geom_errorbar(aes_string(ymin = ""conf.low"", ymax = ""conf.high""), width = 0) +
     coord_flip() +"
strengejacke,sjPlot,df79a2f8317023783933cbf3d068e637d1371856,Daniel,mail@danielluedecke.de,2017-09-10T06:54:43Z,Daniel,mail@danielluedecke.de,2017-09-10T06:54:43Z,fixes to `plot_model()`,NAMESPACE;R/plot_model.R;R/plot_model_estimates.R;R/utils.R,False,True,True,False,15,5,20,"---FILE: NAMESPACE---
@@ -7,6 +7,7 @@ export(dist_f)
 export(dist_norm)
 export(dist_t)
 export(plot_grid)
+export(plot_model)
 export(plot_models)
 export(save_plot)
 export(set_theme)

---FILE: R/plot_model.R---
@@ -33,6 +33,7 @@
 #' @importFrom sjmisc word_wrap
 #' @importFrom sjlabelled get_dv_labels get_term_labels
 #' @importFrom broom tidy
+#' @export
 plot_model <- function(fit,
                        type = ""est"",
                        exponentiate,
@@ -62,7 +63,7 @@ plot_model <- function(fit,
                        ) {
   # check whether estimates should be exponentiated or not
   if (missing(exponentiate))
-    exponentiate <- inherits(fit, c(""glm"", ""glmerMod"", ""glmmTMB""))
+    exponentiate <- !get_glm_family(fit)[[""is_linear""]]
 
   # get labels of dependent variables, and wrap them if too long
   if (is.null(title)) title <- sjlabelled::get_dv_labels(fit, case = case)
@@ -94,7 +95,7 @@ plot_model <- function(fit,
     if (inherits(fit, c(""stanreg"", ""stanfit"")))
       dat <- tidy_stan(fit, ci.lvl, exponentiate)
     else
-      dat <- broom::tidy(fit, conf.int = TRUE, effects = ""fixed"")
+      dat <- broom::tidy(fit, conf.int = TRUE, conf.level = ci.lvl, effects = ""fixed"")
 
 
     p <- plot_model_estimates(

---FILE: R/plot_model_estimates.R---
@@ -1,5 +1,6 @@
 #' @importFrom dplyr slice filter
 #' @importFrom forcats fct_reorder fct_rev
+#' @importFrom rlang .data
 plot_model_estimates <- function(fit,
                                  dat,
                                  exponentiate,
@@ -33,10 +34,12 @@ plot_model_estimates <- function(fit,
   }
 
   # remove further estimates
-  if (!is.null(rm.terms)) dat <- dplyr::filter(dat$term %in% rm.terms)
+  filter.remove <- !(dat$term %in% terms)
+  if (!is.null(rm.terms)) dat <- dplyr::filter(dat, !! filter.remove)
 
   # or select further estimates
-  if (!is.null(terms)) dat <- dplyr::filter(!(dat$term %in% terms))
+  filter.remove <- dat$term %in% rm.terms
+  if (!is.null(terms)) dat <- dplyr::filter(dat, !! filter.remove)
 
   # add p-asterisks to data
   dat$p.stars <- get_p_stars(dat$p.value)
@@ -59,7 +62,10 @@ plot_model_estimates <- function(fit,
 
   # sort estimates by effect size
   if (sort.est) {
-    dat$term <- forcats::fct_reorder(dat$term, dat$estimate)
+    if (!is.null(group.terms))
+      dat$term <- forcats::fct_reorder(dat$term, dat$group)
+    else
+      dat$term <- forcats::fct_reorder(dat$term, dat$estimate)
   } else {
     dat$term <- forcats::fct_rev(dat$term)
   }

---FILE: R/utils.R---
@@ -140,13 +140,15 @@ get_glm_family <- function(fit) {
   binom_fam <- fitfam %in% c(""binomial"", ""quasibinomial"", ""binomialff"")
   poisson_fam <- fitfam %in% c(""poisson"", ""quasipoisson"")
   neg_bin_fam <- sjmisc::str_contains(fitfam, ""negative binomial"", ignore.case = T)
+  linear_model <- !binom_fam & !poisson_fam & !neg_bin_fam & !logit_link
 
   return(
     list(
       is_bin = binom_fam,
       is_pois = poisson_fam | neg_bin_fam,
       is_negbin = neg_bin_fam,
       is_logit = logit_link,
+      is_linear = linear_model,
       link.fun = link.fun,
       family = fitfam
     )"
strengejacke,sjPlot,e1f54dbf3470623865311aa67c542a53cdb0438d,Daniel,mail@danielluedecke.de,2017-08-04T18:49:02Z,Daniel,mail@danielluedecke.de,2017-08-04T18:49:02Z,"shorten examples, fixes issues with CRAN check",DESCRIPTION;R/sjPlotAncovaLSMeans.R;R/sjPlotGLME.R;R/sjPlotInteractions.R;man/sjp.glmer.Rd;man/sjp.int.Rd;man/sjp.lmer.Rd,False,True,True,False,26,502,528,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 2.3.1.9000
-Date: 2017-06-19
+Version: 2.3.2
+Date: 2017-08-04
 Authors@R: c(
     person(""Daniel"", ""Ldecke"", email = ""d.luedecke@uke.de"", role = c(""aut"", ""cre"")),
     person(""Carsten"", ""Schwemmer"", email = ""carsten.schwemmer@uni-bamberg.de"", role = ""ctb"")
@@ -13,9 +13,10 @@ Description: Collection of plotting and table output functions for data
     visualization. Results of various statistical analyses (that are commonly used
     in social sciences) can be visualized using this package, including simple and
     cross tabulated frequencies, histograms, box plots, (generalized) linear models,
-    mixed effects models, PCA and correlation matrices, cluster analyses, scatter
-    plots, Likert scales, effects plots of regression models (including interaction
-    terms) and much more. This package supports labelled data.
+    mixed effects models, principal component analysis and correlation matrices, 
+    cluster analyses, scatter plots, stacked scales, effects plots of regression 
+    models (including interaction terms) and much more. This package supports
+    labelled data.
 License: GPL-3
 Depends:
     R (>= 3.2),
@@ -55,8 +56,7 @@ Suggests:
     gridExtra,
     ggrepel,
     lmerTest,
-    lmtest,
-    lsmeans
+    lmtest
 URL: https://github.com/strengejacke/sjPlot
 BugReports: https://github.com/strengejacke/sjPlot/issues
 RoxygenNote: 6.0.1

---FILE: R/sjPlotAncovaLSMeans.R---
@@ -1,360 +0,0 @@
-# bind global variables
-utils::globalVariables(c(""xn"", ""vld"", ""conf.low"", ""conf.high""))
-
-#' @importFrom dplyr filter
-#' @importFrom sjstats get_model_pval
-#' @importFrom stats terms
-sjp.emm <- function(fit,
-                    swap.pred = FALSE,
-                    plevel = 0.05,
-                    title = NULL,
-                    geom.colors = ""Set1"",
-                    geom.size = 0.7,
-                    axis.title = NULL,
-                    axis.labels = NULL,
-                    legend.title = NULL,
-                    legend.labels = NULL,
-                    show.values = FALSE,
-                    digits = 2,
-                    show.ci = FALSE,
-                    p.kr = TRUE,
-                    breakTitleAt = 50,
-                    wrap.legend.title = 20,
-                    wrap.legend.labels = 20,
-                    y.offset = 0.07,
-                    ylim = NULL,
-                    grid.breaks = NULL,
-                    facet.grid = FALSE,
-                    prnt.plot = TRUE,
-                    ...) {
-  # --------------------------------------------------------
-  # check default geom.size
-  # --------------------------------------------------------
-  if (is.null(geom.size)) geom.size = .7
-  # ---------------------------------------
-  # get ...-arguments
-  # ---------------------------------------
-  dot.args <- get_dot_args(match.call(expand.dots = FALSE)$`...`)
-  # ------------------------
-  # check if suggested packages are available
-  # ------------------------
-  if (!requireNamespace(""lsmeans"", quietly = TRUE)) {
-    stop(""Package `lsmeans` needed for this function to work. Please install it."", call. = FALSE)
-  }
-  if (inherits(fit, c(""lmerMod"", ""merModLmerTest"")) && !requireNamespace(""lmerTest"", quietly = TRUE)) {
-    stop(""Package `lmerTest` needed for this function to work. Please install it."", call. = FALSE)
-  }
-  # --------------------------------------------------------
-  # unlist labels
-  # --------------------------------------------------------
-  if (!is.null(legend.labels) && is.list(legend.labels)) legend.labels <- unlistlabels(legend.labels)
-  # init vector that saves ggplot objects
-  plotlist <- list()
-  dflist <- list()
-  # -----------------------------------------------------------
-  # parameter check
-  # -----------------------------------------------------------
-  if (is.null(grid.breaks)) gridbreaks.y <- ggplot2::waiver()
-  # -----------------------------------------------------------
-  # is mermod?
-  # -----------------------------------------------------------
-  is_mer_mod <- is_merMod(fit)
-  # -----------------------------------------------------------
-  # find interaction terms
-  # -----------------------------------------------------------
-  # init variable
-  it.names <- c()
-  # get model term names
-  preds <- attr(stats::terms(fit), ""term.labels"")
-  # any predictors with colon?
-  pos <- grep("":"", preds)
-  # if yes, we have our interaction terms
-  if (length(pos) > 0) {
-    it.names <- preds[pos]
-  } else {
-    warning(""No interaction term found in fitted model..."", call. = F)
-    return(invisible(NULL))
-  }
-  # -----------------------------------------------------------
-  # find all significant interactions
-  # we start looking for significant p-values beginning
-  # with the first interaction, not the first single term!
-  # thus, the starting point is first position after all single
-  # predictor variables
-  # -----------------------------------------------------------
-  # get model summary
-  fit.coef <- summary(fit)$coefficients
-  # save coefficients
-  cf <- rownames(fit.coef)
-  # find first interaction terms
-  pos <- grep("":"", cf)
-  # -----------------------------------------------------------
-  # get terms of fitted model
-  # -----------------------------------------------------------
-  # get all p-values
-  pval <- sjstats::get_model_pval(fit, p.kr)[[""p.value""]][pos]
-  # get significant interactions
-  intnames <- cf[pos[which(pval < plevel)]]
-  # check for any signigicant interactions, stop if nothing found
-  if (is.null(intnames) || 0 == length(intnames)) {
-    warning(""No significant interactions found..."", call. = FALSE)
-    return(invisible(NULL))
-  }
-  # -----------------------------------------------------------
-  # get model frame
-  # -----------------------------------------------------------
-  m_f <- stats::model.frame(fit)
-  # -----------------------------------------------------------
-  # Now iterate all interaction terms from model
-  # -----------------------------------------------------------
-  interactionterms <- c()
-  for (i in seq_len(length(it.names))) {
-    # -----------------------------------------------------------
-    # retrieve interaction terms
-    # -----------------------------------------------------------
-    terms <- unlist(strsplit(it.names[i], "":""))
-    # -----------------------------------------------------------
-    # check if both interaction terms are factors
-    # -----------------------------------------------------------
-    if (is.factor(m_f[[terms[1]]]) && is.factor(m_f[[terms[2]]])) {
-      # -----------------------------------------------------------
-      # Iterate all interactions on factor-level-basis from model
-      # -----------------------------------------------------------
-      for (cnt in seq_len(length(intnames))) {
-        # -----------------------------------------------------------
-        # first, retrieve and split interaction term so we know
-        # the two predictor variables, or factor levels of the
-        # interaction term
-        # -----------------------------------------------------------
-        lvls <- unlist(strsplit(intnames[cnt], "":""))
-        # -----------------------------------------------------------
-        # since we may have factors with more levels, the original
-        # term labels differ from what we have as coefficient-
-        # e.g., ""ChickWeight$Diet"", becomes ""Diet1"", ""Diet2"", etc.
-        # to calculate marginal means, we only need ""Diet"". So here
-        # we have to find, which terms match the significant coefficients
-        # found, and use the term labels for ls means...
-        # -----------------------------------------------------------
-        if (grepl(terms[1], lvls[1], fixed = T) && grepl(terms[2], lvls[2], fixed = T)) {
-          # we found a match
-          interactionterms <- rbind(interactionterms, terms)
-          # leave loop
-          break
-        }
-      }
-    } else {
-      warning(sprintf(""Both %s and %s need to be factors! Skipping these interaction terms..."", terms[1], terms[2]), call. = F)
-    }
-  }
-  # -----------------------------------------------------------
-  # check if we have any valid interaction terms
-  # for lsmeans function
-  # -----------------------------------------------------------
-  is.em <- sjmisc::is_empty(interactionterms)
-  if (!is.em && nrow(interactionterms) > 0) {
-    for (cnt in seq_len(nrow(interactionterms))) {
-      # -----------------------------------------------------------
-      # retrieve each pair of interaction terms
-      # -----------------------------------------------------------
-      term.pairs <- interactionterms[cnt, ]
-      # go on here for mermod objects
-      if (is_mer_mod) {
-        # -----------------------------------------------------------
-        # retrieve estimated marginal means for all predictors of
-        # the model, with various statistics in a data frame format
-        # -----------------------------------------------------------
-        emm.df <- lmerTest::lsmeans(fit, paste(term.pairs, collapse = "":""))[[1]]
-        # swap predictors?
-        if (swap.pred) term.pairs <- rev(term.pairs)
-        # -----------------------------------------------------------
-        # get column indices of interaction terms, estimate and
-        # confidence intervals. latter term in interaction is considered
-        # as ""within subject"" (x-pos), first term is considered as
-        # ""between subjects"" (group)
-        # -----------------------------------------------------------
-        emm.col <- c(which(colnames(emm.df) == term.pairs[2]),
-                     which(colnames(emm.df) == ""Estimate""),
-                     which(colnames(emm.df) == term.pairs[1]),
-                     which(colnames(emm.df) == ""Lower CI""),
-                     which(colnames(emm.df) == ""Upper CI""))
-        # -----------------------------------------------------------
-        # create data frame from lsmeans
-        # -----------------------------------------------------------
-        intdf <- data.frame(emm.df[, emm.col],
-                            rep(digits, times = nrow(emm.df)))
-      } else {
-        if (swap.pred) term.pairs <- rev(term.pairs)
-        # -----------------------------------------------------------
-        # retrieve estiamted marginal means
-        # -----------------------------------------------------------
-        emm <- summary(lsmeans::lsmeans.character(fit, term.pairs))
-        # create data frame from lsmeans
-        intdf <- data.frame(emm[2], emm[3], emm[1], emm[6], emm[7],
-                            rep(digits, times = nrow(emm[1])))
-      }
-      colnames(intdf) <- c(""x"", ""y"", ""grp"", ""conf.low"", ""conf.high"", ""vld"")
-      # -----------------------------------------------------------
-      # remove missings
-      # -----------------------------------------------------------
-      if (anyNA(intdf$y)) {
-        # warn user
-        warning(""fitted model had estimates with missing values. Output may be incomplete."", call. = F)
-        # remove missings
-        intdf <- dplyr::filter(intdf, !is.na(y))
-      }
-      # -----------------------------------------------------------
-      # convert df-values to numeric
-      # -----------------------------------------------------------
-      intdf$y <- as.numeric(as.character(intdf$y))
-      # add numeric x for geom_line
-      intdf$xn <- as.numeric(intdf$x)
-      # ci to numeric, y-scale is continuous
-      intdf$conf.low <- as.numeric(intdf$conf.low)
-      intdf$conf.high <- as.numeric(intdf$conf.high)
-      # order data frame
-      intdf <- intdf[order(intdf$grp), ]
-      # -----------------------------------------------------------
-      # retrieve lowest and highest x and y position to determine
-      # the scale limits
-      # -----------------------------------------------------------
-      if (is.null(ylim)) {
-        lowerLim.y <- ifelse(show.ci, floor(min(intdf$conf.low)), floor(min(intdf$y)))
-        upperLim.y <- ifelse(show.ci, ceiling(max(intdf$conf.high)), ceiling(max(intdf$y)))
-      } else {
-        lowerLim.y <- ylim[1]
-        upperLim.y <- ylim[2]
-      }
-      # -----------------------------------------------------------
-      # check whether user defined grid breaks / tick marks are used
-      # -----------------------------------------------------------
-      if (!is.null(grid.breaks)) {
-        gridbreaks.y <- c(seq(lowerLim.y, upperLim.y, by = grid.breaks))
-      }
-      # -----------------------------------------------------------
-      # prepare label and name from dependend variable
-      # -----------------------------------------------------------
-      # get response name, which is variable name
-      response.name <- sjstats::resp_var(fit)
-      # get variable label attribute
-      response.label <- sjlabelled::get_label(m_f[[1]], def.value = response.name)
-      # -----------------------------------------------------------
-      # prepare label for x-axix
-      # -----------------------------------------------------------
-      alx <- sjlabelled::get_labels(m_f[[term.pairs[2]]],
-                                attr.only = F,
-                                include.values = NULL,
-                                include.non.labelled = T)
-      # check if we have any
-      if (is.null(alx)) alx <- term.pairs[2]
-      # -----------------------------------------------------------
-      # prepare plot title and axis titles
-      # -----------------------------------------------------------
-      if (is.null(title)) {
-        labtitle <- paste0(""Estimated marginal means of "", response.name,
-                           "" between "", term.pairs[2],
-                           "" and "", term.pairs[1])
-      } else {
-        labtitle <- title
-      }
-      # -----------------------------------------------------------
-      # legend labels
-      # -----------------------------------------------------------
-      if (is.null(legend.labels)) {
-        # try to get labels
-        lLabels <- sjlabelled::get_labels(m_f[term.pairs[1]][, 1], attr.only = F)
-        # if we still have no labels, get factor levels
-        if (is.null(lLabels)) levels(m_f[term.pairs[1]][, 1])
-      } else {
-        lLabels <- legend.labels
-      }
-      # -----------------------------------------------------------
-      # legend title
-      # -----------------------------------------------------------
-      if (is.null(legend.title)) {
-        lTitle <- sjlabelled::get_label(m_f[[term.pairs[1]]], def.value = term.pairs[1])
-      } else {
-        # set legend title for plot
-        lTitle <- legend.title
-      }
-      # -----------------------------------------------------------
-      # axis labels and titles
-      # -----------------------------------------------------------
-      if (is.null(axis.labels)) axis.labels <- alx
-      if (is.null(axis.title)) {
-        labx <- sjlabelled::get_label(m_f[[term.pairs[2]]], def.value = term.pairs[2])
-      } else {
-        labx <- axis.title
-      }
-      # y-axis label
-      laby <- response.label
-      # -----------------------------------------------------------
-      # prepare annotation labels
-      # -----------------------------------------------------------
-      # wrap title and axis titles
-      labtitle <- sjmisc::word_wrap(labtitle, breakTitleAt)
-      labx <- sjmisc::word_wrap(labx, breakTitleAt)
-      laby <- sjmisc::word_wrap(laby, breakTitleAt)
-      # wrap legend labels
-      lLabels <- sjmisc::word_wrap(lLabels, wrap.legend.labels)
-      # wrap legend title
-      lTitle <- sjmisc::word_wrap(lTitle, wrap.legend.title)
-      # -----------------------------------------------------------
-      # prepare base plot of interactions
-      # -----------------------------------------------------------
-      baseplot <- ggplot(intdf)
-      # -----------------------------------------------------------
-      # Confidence intervals?
-      # -----------------------------------------------------------
-      if (show.ci) baseplot <- baseplot +
-          geom_ribbon(aes_string(x = ""xn"", ymin = ""conf.low"", ymax = ""conf.high"", fill = ""grp""), alpha = dot.args[[""ci.alpha""]])
-      # -----------------------------------------------------------
-      # continue with plot. point and line layers above ribbon
-      # -----------------------------------------------------------
-      baseplot <- baseplot +
-        geom_point(aes_string(x = ""x"", y = ""y"", colour = ""grp"")) +
-        geom_line(aes_string(x = ""xn"", y = ""y"", colour = ""grp""), size = geom.size) +
-        scale_x_discrete(labels = axis.labels)
-      # ------------------------------------------------------------
-      # plot value labels
-      # ------------------------------------------------------------
-      if (show.values) {
-        baseplot <- baseplot +
-          geom_text(aes(label = round(y, vld), x = x, y = y),
-                    nudge_y = y.offset,
-                    show.legend = FALSE)
-      }
-      # ------------------------------------------------------------------------------------
-      # build plot object with theme and labels
-      # ------------------------------------------------------------------------------------
-      baseplot <- baseplot +
-        # set plot and axis titles
-        labs(title = labtitle,
-             x = labx,
-             y = laby,
-             colour = lTitle) +
-        # set axis scale breaks
-        scale_y_continuous(limits = c(lowerLim.y, upperLim.y), breaks = gridbreaks.y)
-      # ---------------------------------------------------------
-      # facet grid?
-      # ---------------------------------------------------------
-      if (facet.grid) baseplot <- baseplot + facet_grid( ~grp)
-      # ---------------------------------------------------------
-      # set geom colors
-      # ---------------------------------------------------------
-      baseplot <- sj.setGeomColors(baseplot, geom.colors, length(lLabels), TRUE, lLabels) + guides(fill = FALSE)
-      # ---------------------------------------------------------
-      # Check whether ggplot object should be returned or plotted
-      # ---------------------------------------------------------
-      if (prnt.plot) graphics::plot(baseplot)
-      # concatenate plot object
-      plotlist[[length(plotlist) + 1]] <- baseplot
-      dflist[[length(dflist) + 1]] <- intdf
-    }
-  }
-  # -------------------------------------
-  # return results
-  # -------------------------------------
-  invisible(structure(class = c(""sjPlot"", ""sjpemmint""),
-                      list(plot.list = plotlist,
-                           data.list = dflist)))
-}

---FILE: R/sjPlotGLME.R---
@@ -195,6 +195,7 @@ utils::globalVariables(c(""estimate"", ""nQQ"", ""ci"", ""fixef"", ""fade"", ""conf.low"", ""
 #' # sort by predictor Days
 #' sjp.glmer(fit, sort.est = ""Days"")
 #'
+#' \dontrun{
 #' data(efc)
 #' # create binary response
 #' efc$hi_qol <- dicho(efc$quol_5)
@@ -208,12 +209,6 @@ utils::globalVariables(c(""estimate"", ""nQQ"", ""ci"", ""fixef"", ""fade"", ""conf.low"", ""
 #'                    c12hour = efc$c12hour,
 #'                    neg_c_7 = efc$neg_c_7,
 #'                    grp = efc$grp)
-#' # fit glmer
-#' fit <- glmer(hi_qol ~ sex + c12hour + neg_c_7 + (1|grp),
-#'              data = mydf, family = binomial(""logit""))
-#'
-#' # plot and sort fixed effects
-#' sjp.glmer(fit, type = ""fe"", sort.est = TRUE)
 #'
 #' # fit glmer, with categorical predictor with more than 2 levels
 #' fit <- glmer(hi_qol ~ sex + education + c12hour + neg_c_7 + (1|grp),
@@ -227,24 +222,13 @@ utils::globalVariables(c(""estimate"", ""nQQ"", ""ci"", ""fixef"", ""fade"", ""conf.low"", ""
 #' # in integrated plots, emphasizing groups 1 and 4
 #' sjp.glmer(fit, type = ""ri.slope"", emph.grp = c(1, 4), facet.grid = FALSE)
 #'
-#' # plot probability curve (predicted probabilities)
-#' # of fixed effect, only for coefficient ""neg_c_7""
-#' sjp.glmer(fit, type = ""fe.slope"", vars = ""neg_c_7"")
-#'
-#' # plot predicted probabilities for response,
-#' # related to model predictor, conditioned on random effects
-#' sjp.glmer(fit, type = ""pred"", vars = ""neg_c_7"")
-#'
 #' # plot predicted probabilities for response,
-#' # related to model predictor, grouped
-#' sjp.glmer(fit, type = ""pred.fe"", vars = c(""neg_c_7"", ""sex""))
-#'
 #' # non faceted, with ci
 #' sjp.glmer(fit, type = ""pred.fe"", vars = c(""neg_c_7"", ""education""),
 #'           show.ci = TRUE, facet.grid = FALSE)
 #'
 #' # predictions by gender and education
-#' sjp.glmer(fit, type = ""pred.fe"", vars = c(""neg_c_7"", ""sex"", ""education""))
+#' sjp.glmer(fit, type = ""pred.fe"", vars = c(""neg_c_7"", ""sex"", ""education""))}
 #'
 #' @import ggplot2
 #' @importFrom dplyr slice sample_n
@@ -493,16 +477,9 @@ sjp.glmer <- function(fit,
 #' # fit lmer
 #' fit <- lmer(neg_c_7 ~ sex + c12hour + barthel + (1|grp), data = mydf)
 #'
-#' # plot fixed effects
-#' sjp.lmer(fit, type = ""fe"")
-#'
 #  # plot and sort standardized fixed effects
 #' sjp.lmer(fit, type = ""fe.std"", sort.est = TRUE)
 #'
-#' # plot fixed effects slopes for each random intercept,
-#' # but only for coefficient ""c12hour""
-#' sjp.lmer(fit, type = ""ri.slope"", vars = ""c12hour"")
-#'
 #' # highlight specific grouping levels, in this case we compare
 #' # spouses, children and children-in-law
 #' sjp.lmer(fit, type = ""ri.slope"", emph.grp = c(1, 2, 4), vars = ""c12hour"")

---FILE: R/sjPlotInteractions.R---
@@ -46,7 +46,6 @@
 #'          \describe{
 #'            \item{\code{type = ""eff""}}{(default) plots the overall moderation effect on the response value. See 'Details'.}
 #'            \item{\code{type = ""cond""}}{plots the mere \emph{change} of the moderating effect on the response value (conditional effect). See 'Details'.}
-#'            \item{\code{type = ""emm""}}{plots the estimated marginal means (least square means). If this type is chosen, not all function arguments are applicable. See 'Details'.}
 #'          }
 #' @param int.term Name of interaction term of \code{fit} (as character), which should be plotted
 #'          when using \code{type = ""eff""}. By default, this argument will be ignored
@@ -90,8 +89,6 @@
 #' @param axis.title Default title used for the x-axis. Should be a character vector
 #'          of same length as interaction plots to be plotted. Default value is \code{NULL},
 #'          which means that each plot's x-axis uses the predictor's name as title.
-#' @param axis.labels Character vector with value labels of the interaction, used
-#'          to label the x-axis. Only applies to \code{type = ""emm""}.
 #' @param legend.title Title of the plot's legend. A character vector of same length as
 #'          amount of interaction plots to be plotted (i.e. one vector element for each
 #'          plot's legend title).
@@ -132,13 +129,6 @@
 #'              \code{type = ""eff""} for effect displays similar to the \code{\link[effects]{effect}}-function
 #'              from the \pkg{effects}-package.
 #'            }
-#'            \item{\code{type = ""emm""}}{plots the estimated marginal means of repeated measures designs,
-#'              like two-way repeated measures AN(C)OVA. In detail, this type plots estimated marginal means
-#'              (also called \emph{least square means} or \emph{marginal means}) of (significant) interaction terms.
-#'              The fitted models may be linear (mixed effects)
-#'              models of class \code{\link{lm}} or \code{\link[lme4]{merMod}}. This function may be used, for example,
-#'              to plot differences in interventions between control and treatment groups over multiple time points.
-#'            }
 #'          }
 #'          The argument \code{int.term} only applies to \code{type = ""eff""} and can be used
 #'          to select a specific interaction term of the model that should be plotted. The function
@@ -151,8 +141,7 @@
 #' @note Note that beside interaction terms, also the single predictors of each interaction (main effects)
 #'        must be included in the fitted model as well. Thus, \code{lm(dep ~ pred1 * pred2)} will work,
 #'        but \code{lm(dep ~ pred1:pred2)} won't! \cr \cr
-#'        For \code{type = ""emm""}, all interaction terms have to be factors.
-#'        Furthermore, for \code{type = ""eff""}, predictors of interactions that are introduced first into the model
+#'        For \code{type = ""eff""}, predictors of interactions that are introduced first into the model
 #'        are used as grouping variable, while the latter predictor is printed along the x-axis
 #'        (i.e. lm(y~a+b+a:b) means that ""a"" is used as grouping variable and ""b"" is plotted along the x-axis).
 #'
@@ -224,17 +213,15 @@
 #' sjp.int(fit, type = ""cond"", legend.labels = get_labels(efc$c161sex), plevel = 0.1)
 #'
 #' \dontrun{
-#' # -------------------------------
-#' # Plot estimated marginal means
-#' # -------------------------------
 #' # load sample data set
 #' library(sjmisc)
 #' data(efc)
 #' # create data frame with variables that should be included
 #' # in the model
 #' mydf <- data.frame(burden = efc$neg_c_7,
 #'                    sex = efc$c161sex,
-#'                    education = efc$c172code)
+#'                    education = efc$c172code,
+#'                    barthel = efc$barthtot)
 #' # convert gender predictor to factor
 #' mydf$sex <- factor(mydf$sex)
 #' mydf$education <- factor(mydf$education)
@@ -244,22 +231,6 @@
 #' mydf$burden <- set_label(mydf$burden, lab = ""care burden"")
 #' # fit ""dummy"" model
 #' fit <- lm(burden ~ .*., data = mydf)
-#' summary(fit)
-#'
-#' # plot marginal means of interactions, no interaction found
-#' sjp.int(fit, type = ""emm"")
-#' # plot marginal means of interactions, including those with p-value up to 1
-#' sjp.int(fit, type = ""emm"", plevel = 1)
-#' # swap predictors
-#' sjp.int(fit, type = ""emm"", plevel = 1, swap.pred = TRUE)
-#'
-#' # -------------------------------
-#' # Plot effects
-#' # -------------------------------
-#' # add continuous variable
-#' mydf$barthel <- efc$barthtot
-#' # re-fit model with continuous variable
-#' fit <- lm(burden ~ .*., data = mydf)
 #'
 #' # plot effects
 #' sjp.int(fit, type = ""eff"", show.ci = TRUE)
@@ -273,7 +244,7 @@
 #' @importFrom effects allEffects effect
 #' @export
 sjp.int <- function(fit,
-                    type = c(""eff"", ""cond"", ""emm""),
+                    type = c(""eff"", ""cond""),
                     int.term = NULL,
                     int.plot.index = NULL,
                     mdrt.values = c(""minmax"", ""meansd"", ""zeromax"", ""quart"", ""all""),
@@ -282,7 +253,6 @@ sjp.int <- function(fit,
                     diff = FALSE,
                     title = NULL,
                     axis.title = NULL,
-                    axis.labels = NULL,
                     legend.title = NULL,
                     legend.labels = NULL,
                     wrap.title = 50,
@@ -373,16 +343,6 @@ sjp.int <- function(fit,
   # --------------------------------------------------------
   binom_fam <- fitfam$is_bin
   # --------------------------------------------------------
-  # plot estimated marginal means?
-  # --------------------------------------------------------
-  if (type == ""emm"") {
-    return(sjp.emm(fit, swap.pred, plevel, title, geom.colors, geom.size,
-                   axis.title, axis.labels, legend.title, legend.labels,
-                   show.values, digits, show.ci, p.kr, wrap.title,
-                   wrap.legend.title, wrap.legend.labels, y.offset, ylim,
-                   grid.breaks, facet.grid, prnt.plot, ...))
-  }
-  # --------------------------------------------------------
   # list labels
   # --------------------------------------------------------
   if (!is.null(legend.labels) && !is.list(legend.labels)) legend.labels <- list(legend.labels)

---FILE: man/sjp.glmer.Rd---
@@ -289,6 +289,7 @@ sjp.glmer(fit)
 # sort by predictor Days
 sjp.glmer(fit, sort.est = ""Days"")
 
+\dontrun{
 data(efc)
 # create binary response
 efc$hi_qol <- dicho(efc$quol_5)
@@ -302,12 +303,6 @@ mydf <- data.frame(hi_qol = to_factor(efc$hi_qol),
                    c12hour = efc$c12hour,
                    neg_c_7 = efc$neg_c_7,
                    grp = efc$grp)
-# fit glmer
-fit <- glmer(hi_qol ~ sex + c12hour + neg_c_7 + (1|grp),
-             data = mydf, family = binomial(""logit""))
-
-# plot and sort fixed effects
-sjp.glmer(fit, type = ""fe"", sort.est = TRUE)
 
 # fit glmer, with categorical predictor with more than 2 levels
 fit <- glmer(hi_qol ~ sex + education + c12hour + neg_c_7 + (1|grp),
@@ -321,24 +316,13 @@ sjp.glmer(fit, type = ""fe"", sort.est = TRUE)
 # in integrated plots, emphasizing groups 1 and 4
 sjp.glmer(fit, type = ""ri.slope"", emph.grp = c(1, 4), facet.grid = FALSE)
 
-# plot probability curve (predicted probabilities)
-# of fixed effect, only for coefficient ""neg_c_7""
-sjp.glmer(fit, type = ""fe.slope"", vars = ""neg_c_7"")
-
 # plot predicted probabilities for response,
-# related to model predictor, conditioned on random effects
-sjp.glmer(fit, type = ""pred"", vars = ""neg_c_7"")
-
-# plot predicted probabilities for response,
-# related to model predictor, grouped
-sjp.glmer(fit, type = ""pred.fe"", vars = c(""neg_c_7"", ""sex""))
-
 # non faceted, with ci
 sjp.glmer(fit, type = ""pred.fe"", vars = c(""neg_c_7"", ""education""),
           show.ci = TRUE, facet.grid = FALSE)
 
 # predictions by gender and education
-sjp.glmer(fit, type = ""pred.fe"", vars = c(""neg_c_7"", ""sex"", ""education""))
+sjp.glmer(fit, type = ""pred.fe"", vars = c(""neg_c_7"", ""sex"", ""education""))}
 
 }
 \seealso{

---FILE: man/sjp.int.Rd---
@@ -4,16 +4,16 @@
 \alias{sjp.int}
 \title{Plot interaction effects of (generalized) linear (mixed) models}
 \usage{
-sjp.int(fit, type = c(""eff"", ""cond"", ""emm""), int.term = NULL,
+sjp.int(fit, type = c(""eff"", ""cond""), int.term = NULL,
   int.plot.index = NULL, mdrt.values = c(""minmax"", ""meansd"", ""zeromax"",
   ""quart"", ""all""), swap.pred = FALSE, plevel = 0.1, diff = FALSE,
-  title = NULL, axis.title = NULL, axis.labels = NULL,
-  legend.title = NULL, legend.labels = NULL, wrap.title = 50,
-  wrap.legend.labels = 20, wrap.legend.title = 20, geom.colors = ""Set1"",
-  geom.size = NULL, fill.color = ""grey"", fill.alpha = 0.3,
-  show.values = FALSE, show.ci = FALSE, jitter.ci = FALSE, p.kr = TRUE,
-  grid.breaks = NULL, xlim = NULL, ylim = NULL, y.offset = 0.07,
-  digits = 2, facet.grid = FALSE, prnt.plot = TRUE, ...)
+  title = NULL, axis.title = NULL, legend.title = NULL,
+  legend.labels = NULL, wrap.title = 50, wrap.legend.labels = 20,
+  wrap.legend.title = 20, geom.colors = ""Set1"", geom.size = NULL,
+  fill.color = ""grey"", fill.alpha = 0.3, show.values = FALSE,
+  show.ci = FALSE, jitter.ci = FALSE, p.kr = TRUE, grid.breaks = NULL,
+  xlim = NULL, ylim = NULL, y.offset = 0.07, digits = 2,
+  facet.grid = FALSE, prnt.plot = TRUE, ...)
 }
 \arguments{
 \item{fit}{A fitted (generalized) linear (mixed) model object, including interaction terms. Accepted model
@@ -33,7 +33,6 @@ classes are
 \describe{
   \item{\code{type = ""eff""}}{(default) plots the overall moderation effect on the response value. See 'Details'.}
   \item{\code{type = ""cond""}}{plots the mere \emph{change} of the moderating effect on the response value (conditional effect). See 'Details'.}
-  \item{\code{type = ""emm""}}{plots the estimated marginal means (least square means). If this type is chosen, not all function arguments are applicable. See 'Details'.}
 }}
 
 \item{int.term}{Name of interaction term of \code{fit} (as character), which should be plotted
@@ -78,9 +77,6 @@ includes the dependent variable as well as the names of the interaction terms.}
 of same length as interaction plots to be plotted. Default value is \code{NULL},
 which means that each plot's x-axis uses the predictor's name as title.}
 
-\item{axis.labels}{Character vector with value labels of the interaction, used
-to label the x-axis. Only applies to \code{type = ""emm""}.}
-
 \item{legend.title}{Title of the plot's legend. A character vector of same length as
 amount of interaction plots to be plotted (i.e. one vector element for each
 plot's legend title).}
@@ -209,13 +205,6 @@ Plot regression (predicted values) or probability lines (predicted probabilities
              \code{type = ""eff""} for effect displays similar to the \code{\link[effects]{effect}}-function
              from the \pkg{effects}-package.
            }
-           \item{\code{type = ""emm""}}{plots the estimated marginal means of repeated measures designs,
-             like two-way repeated measures AN(C)OVA. In detail, this type plots estimated marginal means
-             (also called \emph{least square means} or \emph{marginal means}) of (significant) interaction terms.
-             The fitted models may be linear (mixed effects)
-             models of class \code{\link{lm}} or \code{\link[lme4]{merMod}}. This function may be used, for example,
-             to plot differences in interventions between control and treatment groups over multiple time points.
-           }
          }
          The argument \code{int.term} only applies to \code{type = ""eff""} and can be used
          to select a specific interaction term of the model that should be plotted. The function
@@ -229,8 +218,7 @@ Plot regression (predicted values) or probability lines (predicted probabilities
 Note that beside interaction terms, also the single predictors of each interaction (main effects)
        must be included in the fitted model as well. Thus, \code{lm(dep ~ pred1 * pred2)} will work,
        but \code{lm(dep ~ pred1:pred2)} won't! \cr \cr
-       For \code{type = ""emm""}, all interaction terms have to be factors.
-       Furthermore, for \code{type = ""eff""}, predictors of interactions that are introduced first into the model
+       For \code{type = ""eff""}, predictors of interactions that are introduced first into the model
        are used as grouping variable, while the latter predictor is printed along the x-axis
        (i.e. lm(y~a+b+a:b) means that ""a"" is used as grouping variable and ""b"" is plotted along the x-axis).
 }
@@ -302,17 +290,15 @@ sjp.int(fit, type = ""eff"", legend.labels = get_labels(efc$c161sex), plevel = 0.1
 sjp.int(fit, type = ""cond"", legend.labels = get_labels(efc$c161sex), plevel = 0.1)
 
 \dontrun{
-# -------------------------------
-# Plot estimated marginal means
-# -------------------------------
 # load sample data set
 library(sjmisc)
 data(efc)
 # create data frame with variables that should be included
 # in the model
 mydf <- data.frame(burden = efc$neg_c_7,
                    sex = efc$c161sex,
-                   education = efc$c172code)
+                   education = efc$c172code,
+                   barthel = efc$barthtot)
 # convert gender predictor to factor
 mydf$sex <- factor(mydf$sex)
 mydf$education <- factor(mydf$education)
@@ -322,22 +308,6 @@ levels(mydf$education) <- c(""low"", ""mid"", ""high"")
 mydf$burden <- set_label(mydf$burden, lab = ""care burden"")
 # fit ""dummy"" model
 fit <- lm(burden ~ .*., data = mydf)
-summary(fit)
-
-# plot marginal means of interactions, no interaction found
-sjp.int(fit, type = ""emm"")
-# plot marginal means of interactions, including those with p-value up to 1
-sjp.int(fit, type = ""emm"", plevel = 1)
-# swap predictors
-sjp.int(fit, type = ""emm"", plevel = 1, swap.pred = TRUE)
-
-# -------------------------------
-# Plot effects
-# -------------------------------
-# add continuous variable
-mydf$barthel <- efc$barthtot
-# re-fit model with continuous variable
-fit <- lm(burden ~ .*., data = mydf)
 
 # plot effects
 sjp.int(fit, type = ""eff"", show.ci = TRUE)

---FILE: man/sjp.lmer.Rd---
@@ -326,15 +326,8 @@ mydf <- data.frame(neg_c_7 = as.numeric(efc$neg_c_7),
 # fit lmer
 fit <- lmer(neg_c_7 ~ sex + c12hour + barthel + (1|grp), data = mydf)
 
-# plot fixed effects
-sjp.lmer(fit, type = ""fe"")
-
 sjp.lmer(fit, type = ""fe.std"", sort.est = TRUE)
 
-# plot fixed effects slopes for each random intercept,
-# but only for coefficient ""c12hour""
-sjp.lmer(fit, type = ""ri.slope"", vars = ""c12hour"")
-
 # highlight specific grouping levels, in this case we compare
 # spouses, children and children-in-law
 sjp.lmer(fit, type = ""ri.slope"", emph.grp = c(1, 2, 4), vars = ""c12hour"")"
strengejacke,sjPlot,b2dc2b3b0d033a990362674cdc9ba8aff48e9bce,Daniel,mail@danielluedecke.de,2017-08-04T13:15:27Z,Daniel,mail@danielluedecke.de,2017-08-04T13:15:27Z,"prepare CRAN release, close various issues",NEWS;NEWS.md;R/sjPlotFrequencies.R;R/sjPlotGroupFrequencies.R;R/sjTabFrequencies.R;R/sjTabSPSS.R;man/sjp.frq.Rd,False,True,True,False,76,57,133,"---FILE: NEWS---
@@ -4,11 +4,16 @@ General:
 * Revising package code from scratch. Part of the old functions will be replaced by new ones, making the code base easier to maintain and reduce redundant functions by merging them together. In the course of the next updates, functions will first become deprecated and later defunct.
 * Changed imports to avoid using deprecated functions.
 * Fixed issue with forthcoming tydir-update on CRAN.
+* Use more informative warning- and error-messages for certain functions.
 
 New functions:
 * `plot_models()` as replacement for `sjp.lmm()` and `sjp.glmm()` (which are now deprecated).
 * `sjp.fa()` and `sjt.fa()` to plot or print as table the results of factor analyses.
 
+Bug fixes:
+* The mean and standard deviation in the summary of `sjt.frq()` were not correctly computed, when `auto.group`-argument was specified. This bug was introduced in the last update and is not fixed again.
+* Values of character vectors were not always correctly sorted in `view_df()` (if `show.frq = TRUE`).
+
 Version 2.3.1
 -----------------------------------------------------------------------------
 General:

---FILE: NEWS.md---
@@ -5,12 +5,18 @@
 * Revising package code from scratch. Part of the old functions will be replaced by new ones, making the code base easier to maintain and reduce redundant functions by merging them together. In the course of the next updates, functions will first become deprecated and later defunct.
 * Changed imports to avoid using deprecated functions.
 * Fixed issue with forthcoming tydir-update on CRAN.
+* Use more informative warning- and error-messages for certain functions.
 
 ## New functions
 
 * `plot_models()` as replacement for `sjp.lmm()` and `sjp.glmm()` (which are now deprecated).
 * `sjp.fa()` and `sjt.fa()` to plot or print as table the results of factor analyses.
 
+## Bug fixes
+
+* The mean and standard deviation in the summary of `sjt.frq()` were not correctly computed, when `auto.group`-argument was specified. This bug was introduced in the last update and is not fixed again.
+* Values of character vectors were not always correctly sorted in `view_df()` (if `show.frq = TRUE`).
+
 # sjPlot 2.3.1
 
 ## General

---FILE: R/sjPlotFrequencies.R---
@@ -60,29 +60,28 @@ utils::globalVariables(c(""val"", ""frq"", ""grp"", ""label.pos"", ""upper.ci"", ""lower.ci
 #'           was used for setting up the ggplot-object (\code{data}).
 #'
 #' @examples
+#' # Using EUROFAMCARE sample dataset
+#' # dataset was importet from an SPSS-file, using:
+#' # efc <- sjlabelled::read_spss(""efc.sav"", enc = ""UTF-8"")
+#' library(sjmisc)
+#' library(sjlabelled)
+#' data(efc)
+#'
 #' # boxplot
 #' sjp.frq(ChickWeight$weight, type = ""box"")
 #'
 #' # histogram
-#' sjp.frq(discoveries, type = ""hist"", show.mean = TRUE)
+#' sjp.frq(efc$e17age, type = ""hist"", show.mean = TRUE)
 #'
 #' # violin plot
 #' sjp.frq(ChickWeight$weight, type = ""v"")
 #'
 #' # bar plot
 #' sjp.frq(ChickWeight$Diet)
 #'
-#'
-#' # bar plot with EUROFAMCARE sample dataset
-#' # dataset was importet from an SPSS-file, using:
-#' # efc <- sjlabelled::read_spss(""efc.sav"", enc = ""UTF-8"")
-#' library(sjmisc)
-#' library(sjlabelled)
-#' data(efc)
 #' # you may use sjp.setTheme here to change axis textangle
 #' sjp.frq(efc$e15relat)
 #'
-#' # bar plot with EUROFAMCARE sample dataset
 #' # grouped variable
 #' ageGrp <- group_var(efc$e17age)
 #' ageGrpLab <- group_labels(efc$e17age)
@@ -92,9 +91,10 @@ utils::globalVariables(c(""val"", ""frq"", ""grp"", ""label.pos"", ""upper.ci"", ""lower.ci
 #' sjp.frq(efc$neg_c_7)
 #'
 #' # plotting confidence intervals. expand grid and v/hjust for text labels
-#' sjp.frq(efc$e15relat, type = ""dot"", show.ci = TRUE, sort.frq = ""desc"",
-#'         coord.flip = TRUE, expand.grid = TRUE, vjust = ""bottom"",
-#'         hjust = ""left"")
+#' sjp.frq(
+#'   efc$e15relat, type = ""dot"", show.ci = TRUE, sort.frq = ""desc"",
+#'   coord.flip = TRUE, expand.grid = TRUE, vjust = ""bottom"", hjust = ""left""
+#' )
 #'
 #' # Simulate ggplot-default histogram
 #' sjp.frq(efc$c160age, type = ""h"", geom.size = 3)
@@ -108,7 +108,7 @@ utils::globalVariables(c(""val"", ""frq"", ""grp"", ""label.pos"", ""upper.ci"", ""lower.ci
 #' @importFrom sjstats wtd_sd
 #' @importFrom sjmisc group_labels group_var to_value
 #' @importFrom sjlabelled set_labels
-#' @importFrom stats na.omit sd weighted.mean
+#' @importFrom stats na.omit sd weighted.mean dnorm
 #' @export
 sjp.frq <- function(var.cnt,
                     title = """",
@@ -250,16 +250,16 @@ sjp.frq <- function(var.cnt,
     # group axis labels
     axis.labels <- sjmisc::group_labels(
       sjmisc::to_value(var.cnt, keep.labels = F),
-      size = ""auto"",
-      n = auto.group
+      groupsize = ""auto"",
+      groupcount = auto.group
     )
 
     # group variable
     var.cnt <- sjmisc::group_var(
       sjmisc::to_value(var.cnt, keep.labels = F),
-      size = ""auto"",
+      groupsize = ""auto"",
       as.num = TRUE,
-      n = auto.group
+      groupcount = auto.group
     )
 
     # set label attributes
@@ -354,9 +354,11 @@ sjp.frq <- function(var.cnt,
       # ... or the amount of max. answers per category
       # add 10% margin to upper limit
       upper_lim <- max(pretty(table(
-        sjmisc::group_var(var.cnt,
-                          size = ""auto"",
-                          n = hist.grp.cnt)
+        sjmisc::group_var(
+          var.cnt,
+          groupsize = ""auto"",
+          groupcount = hist.grp.cnt
+        )
       ) * 1.1))
     } else {
       if (show.ci)
@@ -554,7 +556,7 @@ sjp.frq <- function(var.cnt,
       baseplot <- baseplot +
         stat_function(
           fun = function(xx, mean, sd, n) {
-            n * dnorm(x = xx, mean = mean, sd = sd)
+            n * stats::dnorm(x = xx, mean = mean, sd = sd)
           },
           args = with(mydat, c(
             mean = mittelwert,

---FILE: R/sjPlotGroupFrequencies.R---
@@ -305,17 +305,17 @@ sjp.grpfrq <- function(var.cnt,
     axis.labels <-
       sjmisc::group_labels(
         sjmisc::to_value(var.cnt, keep.labels = F),
-        size = ""auto"",
-        n = agcnt
+        groupsize = ""auto"",
+        groupcount = agcnt
       )
 
     # group variable
     grp.var.cnt <-
       sjmisc::group_var(
         sjmisc::to_value(var.cnt, keep.labels = F),
-        size = ""auto"",
+        groupsize = ""auto"",
         as.num = TRUE,
-        n = agcnt
+        groupcount = agcnt
       )
 
     # set value labels

---FILE: R/sjTabFrequencies.R---
@@ -273,12 +273,13 @@ sjt.frq <- function(data,
 
   # check if string vectors should be removed
   if (ignore.strings) {
-    # check if we have data frame with several variables
-    if (is.data.frame(data)) {
-      # remove string variables
-      data <- data[, !sapply(data, is.character)]
-    } else if (is.character(data)) {
-      stop(""`data` is a single string vector, where string vectors should be removed. No data to compute frequency table left. See argument `ignore.strings` for details."", call. = FALSE)
+
+    # # remove string variables from data frame
+    if (is.data.frame(data))
+      data <- data[, !sapply(data, is.character), drop = FALSE]
+
+    if (sjmisc::is_empty(data) || is.character(data)) {
+      stop(""`data` only contains string vectors, where string vectors should be removed. No data to compute frequency table left. See argument `ignore.strings` for details."", call. = FALSE)
     }
   }
 
@@ -373,6 +374,16 @@ sjt.frq <- function(data,
 
   # start iterating all variables
   for (cnt in seq_len(nvar)) {
+    # check if we have a string-vector
+    if (is.character(data[[cnt]])) {
+      # convert string to numeric
+      orivar <- varia <- as.numeric(as.factor(data[[cnt]]))
+      # here we have numeric or factor variables
+    } else {
+      # convert to numeric
+      orivar <- varia <- sjmisc::to_value(data[[cnt]], keep.labels = F)
+    }
+
     # check for length of unique values and skip if too long
     if (!is.null(auto.group) &&
         !is.character(data[[cnt]]) &&
@@ -387,33 +398,23 @@ sjt.frq <- function(data,
       val.lab <-
         sjmisc::group_labels(
           sjmisc::to_value(data[[cnt]], keep.labels = F),
-          size = ""auto"",
-          n = auto.group
+          groupsize = ""auto"",
+          groupcount = auto.group
         )
 
       # group variable
       data[[cnt]] <-
         sjmisc::group_var(
           sjmisc::to_value(data[[cnt]], keep.labels = F),
-          size = ""auto"",
+          groupsize = ""auto"",
           as.num = TRUE,
-          n = auto.group
+          groupcount = auto.group
         )
 
       # set labels
       data[[cnt]] <- sjlabelled::set_labels(data[[cnt]], labels = val.lab)
     }
 
-    # check if we have a string-vector
-    if (is.character(data[[cnt]])) {
-      # convert string to numeric
-      orivar <- varia <- as.numeric(as.factor(data[[cnt]]))
-      # here we have numeric or factor variables
-    } else {
-      # convert to numeric
-      orivar <- varia <- sjmisc::to_value(data[[cnt]], keep.labels = F)
-    }
-
     # retrieve summary
     varsummary <- summary(varia)
 

---FILE: R/sjTabSPSS.R---
@@ -262,6 +262,11 @@ view_df <- function(x,
         # the code here corresponds to the above code
         # for variable values
         vals <- df.val[[index]]
+
+        # sort character vectors
+        if (is.character(x[[index]]) && !is.null(vals) && !sjmisc::is_empty(vals))
+          vals <- sort(vals)
+
         # check if we have any values...
         if (!is.null(vals)) {
           # if yes, add all to a string

---FILE: man/sjp.frq.Rd---
@@ -191,29 +191,28 @@ This function only works with variables with integer values (or numeric
         with decimals may result in unexpected behaviour.
 }
 \examples{
+# Using EUROFAMCARE sample dataset
+# dataset was importet from an SPSS-file, using:
+# efc <- sjlabelled::read_spss(""efc.sav"", enc = ""UTF-8"")
+library(sjmisc)
+library(sjlabelled)
+data(efc)
+
 # boxplot
 sjp.frq(ChickWeight$weight, type = ""box"")
 
 # histogram
-sjp.frq(discoveries, type = ""hist"", show.mean = TRUE)
+sjp.frq(efc$e17age, type = ""hist"", show.mean = TRUE)
 
 # violin plot
 sjp.frq(ChickWeight$weight, type = ""v"")
 
 # bar plot
 sjp.frq(ChickWeight$Diet)
 
-
-# bar plot with EUROFAMCARE sample dataset
-# dataset was importet from an SPSS-file, using:
-# efc <- sjlabelled::read_spss(""efc.sav"", enc = ""UTF-8"")
-library(sjmisc)
-library(sjlabelled)
-data(efc)
 # you may use sjp.setTheme here to change axis textangle
 sjp.frq(efc$e15relat)
 
-# bar plot with EUROFAMCARE sample dataset
 # grouped variable
 ageGrp <- group_var(efc$e17age)
 ageGrpLab <- group_labels(efc$e17age)
@@ -223,9 +222,10 @@ sjp.frq(ageGrp, title = get_label(efc$e17age), axis.labels = ageGrpLab)
 sjp.frq(efc$neg_c_7)
 
 # plotting confidence intervals. expand grid and v/hjust for text labels
-sjp.frq(efc$e15relat, type = ""dot"", show.ci = TRUE, sort.frq = ""desc"",
-        coord.flip = TRUE, expand.grid = TRUE, vjust = ""bottom"",
-        hjust = ""left"")
+sjp.frq(
+  efc$e15relat, type = ""dot"", show.ci = TRUE, sort.frq = ""desc"",
+  coord.flip = TRUE, expand.grid = TRUE, vjust = ""bottom"", hjust = ""left""
+)
 
 # Simulate ggplot-default histogram
 sjp.frq(efc$c160age, type = ""h"", geom.size = 3)"
strengejacke,sjPlot,b94e7ca42e0357e65c907a978ea87e2416b03c00,Daniel,mail@danielluedecke.de,2017-07-24T16:09:32Z,Daniel,mail@danielluedecke.de,2017-07-24T16:09:32Z,fix installation issues,R/font_size.R;R/plot_model.R;R/sjTabGrpmean.R;man/plot_model.Rd;man/sjp.aov1.Rd;man/sjp.glm.Rd;man/sjp.glmer.Rd;man/sjp.gpt.Rd;man/sjp.lm.Rd;man/sjp.lmer.Rd,False,True,True,False,81,29,110,"---FILE: R/font_size.R---
@@ -1,32 +1,32 @@
 #' @importFrom ggplot2 theme_get theme theme_set element_text
 #' @export
-font_size <- function(fs_title, fs_axis_title.x, fs_axis_title.y, fs_labels.x, fs_labels.y) {
+font_size <- function(title, axis_title.x, axis_title.y, labels.x, labels.y) {
   # get current theme
   cur.theme <- ggplot2::theme_get()
 
-  if (!missing(fs_title)) {
+  if (!missing(title)) {
     cur.theme <- cur.theme +
-      ggplot2::theme(title = ggplot2::element_text(size = fs_title))
+      ggplot2::theme(title = ggplot2::element_text(size = title))
   }
 
-  if (!missing(fs_axis_title.x)) {
+  if (!missing(axis_title.x)) {
     cur.theme <- cur.theme +
-      ggplot2::theme(axis.title.x = ggplot2::element_text(size = fs_axis_title.x))
+      ggplot2::theme(axis.title.x = ggplot2::element_text(size = axis_title.x))
   }
 
-  if (!missing(fs_axis_title.y)) {
+  if (!missing(axis_title.y)) {
     cur.theme <- cur.theme +
-      ggplot2::theme(axis.title.y = ggplot2::element_text(size = fs_axis_title.y))
+      ggplot2::theme(axis.title.y = ggplot2::element_text(size = axis_title.y))
   }
 
-  if (!missing(fs_labels.x)) {
+  if (!missing(labels.x)) {
     cur.theme <- cur.theme +
-      ggplot2::theme(axis.text.x =  ggplot2::element_text(size = fs_labels.x))
+      ggplot2::theme(axis.text.x =  ggplot2::element_text(size = labels.x))
   }
 
-  if (!missing(fs_labels.y)) {
+  if (!missing(labels.y)) {
     cur.theme <- cur.theme +
-      ggplot2::theme(axis.text.y =  ggplot2::element_text(size = fs_labels.y))
+      ggplot2::theme(axis.text.y =  ggplot2::element_text(size = labels.y))
   }
 
   ggplot2::theme_set(cur.theme)

---FILE: R/plot_model.R---
@@ -1,3 +1,8 @@
+#' @title Various plot types for regression models
+#' @name plot_model
+#'
+#' @description To Do...
+#'
 #' @param type Type of plot. Use one of following:
 #'          \describe{
 #'            \item{\code{""est""}}{(default) for forest-plot like plot of estimates. If the fitted model only contains one predictor, intercept and slope are plotted.}
@@ -47,7 +52,6 @@ plot_model <- function(fit,
                        sort.est = FALSE,
                        rm.terms = NULL,
                        group.terms = NULL,
-                       rm.terms = NULL,
                        title = NULL,
                        axis.labels = NULL,
                        show.intercept = FALSE,

---FILE: R/sjTabGrpmean.R---
@@ -42,6 +42,7 @@
 #' sjt.grpmean(efc$c12hour, efc$e42dep)}
 #'
 #' @importFrom stats na.omit lm
+#' @importFrom sjstats get_model_pval
 #' @export
 sjt.grpmean <- function(var.cnt,
                         var.grp,
@@ -173,7 +174,7 @@ sjt.grpmean <- function(var.cnt,
   # get F-statistics
   fstat <- sum.fit$fstatistic[1]
   # p-value for F-test
-  pval <- sjstats:::lm_pval_fstat(fit)
+  pval <- sjstats::get_model_pval(fit)
   pvalstring <- ifelse(pval < 0.001,
                        sprintf(""p&lt;%s.001"", p_zero),
                        sub(""0"", p_zero, sprintf(""p=%.*f"", digits.summary, pval)))

---FILE: man/plot_model.Rd---
@@ -0,0 +1,63 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/plot_model.R
+\name{plot_model}
+\alias{plot_model}
+\title{Various plot types for regression models}
+\usage{
+plot_model(fit, type = ""est"", exponentiate, terms = NULL,
+  sort.est = FALSE, rm.terms = NULL, group.terms = NULL, title = NULL,
+  axis.labels = NULL, show.intercept = FALSE, show.p = TRUE,
+  geom.size = NULL, geom.colors = ""Set1"", wrap.title = 50,
+  wrap.labels = 25, digits = 2, vline.type = 2, vline.color = ""grey70"",
+  ...)
+}
+\arguments{
+\item{type}{Type of plot. Use one of following:
+\describe{
+  \item{\code{""est""}}{(default) for forest-plot like plot of estimates. If the fitted model only contains one predictor, intercept and slope are plotted.}
+  \item{\code{""pred""}}{to plot predicted values for the response, related to specific predictors. See 'Details'.}
+  \item{\code{""eff""}}{to plot marginal effects of all terms in \code{fit}. Note that interaction terms are excluded from this plot.}
+  \item{\code{""int""}}{to plot marginal effects of interaction terms in \code{fit}.}
+  \item{\code{""std""}}{for forest-plot like plot of standardized beta values. If the fitted model only contains one predictor, intercept and slope are plotted.}
+  \item{\code{""std2""}}{for forest-plot like plot of standardized beta values, however, standardization is done by dividing by two sd (see 'Details'). If the fitted model only contains one predictor, intercept and slope are plotted.}
+  \item{\code{""slope""}}{to plot regression lines for each single predictor of the fitted model, against the response (linear relationship between each model term and response).}
+  \item{\code{""resid""}}{to plot regression lines for each single predictor of the fitted model, against the residuals (linear relationship between each model term and residuals). May be used for model diagnostics.}
+  \item{\code{""ma""}}{to check model assumptions. Note that only three arguments are relevant for this option \code{fit} and \code{complete.dgns}. All other arguments are ignored.}
+  \item{\code{""vif""}}{to plot Variance Inflation Factors.}
+}}
+
+\item{exponentiate}{Logical, if \code{TRUE} and models inherit from generalized
+linear models, estimates will be exponentiated (e.g., log-odds will
+be displayed as odds ratios). By default, \code{exponentiate} will
+automatically be set to \code{FALSE} or \code{TRUE}, depending on
+the class of \code{fit}.}
+
+\item{terms}{Character vector with the names of those from \code{fit}, which
+should be used to plot for. This argument depends on the plot-type;
+for \code{type = ""pred""} or \code{type = ""eff""}, \code{terms} indicates
+for which terms marginal effects should be displayed. At least one term
+is required to calculate effects, maximum length is three terms,
+where the second and third term indicate the groups, i.e. predictions
+of first term are grouped by the levels of the second (and third)
+term. Indicating levels in square brackets allows for selecting
+only specific groups. Term name and levels in brackets must be
+separated by a whitespace character, e.g.
+\code{terms = c(""age"", ""education [1,3]"")}. For more details, see
+\code{\link[ggeffects]{ggpredict}}.}
+
+\item{rm.terms}{Character vector with names that indicate which terms should
+be removed from the plot. \code{rm.terms = ""t_name""} would remove the
+term \emph{t_name}. Default is \code{NULL}, i.e. all terms are
+used.}
+
+\item{show.intercept}{Logical, if \code{TRUE}, the intercept of the fitted
+model is also plotted. Default is \code{FALSE}. If \code{exponentiate = TRUE},
+please note that due to exponential transformation of estimates, the
+intercept in some cases is non-finite and the plot can not be created.}
+
+\item{show.p}{Logical, adds significance levels to values, or value and
+variable labels.}
+}
+\description{
+To Do...
+}

---FILE: man/sjp.aov1.Rd---
@@ -75,9 +75,6 @@ i.e. at every \code{grid.breaks}'th position a major grid is being printed.}
 \item{y.offset}{numeric, offset for text labels when their alignment is adjusted
 to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
 
-\item{show.p}{Logical, adds significance levels to values, or value and
-variable labels.}
-
 \item{show.summary}{logical, if \code{TRUE} (default), a summary with chi-squared
 statistics (see \code{\link{chisq.test}}), Cramer's V or Phi-value etc.
 is shown. If a cell contains expected values lower than five (or lower than 10

---FILE: man/sjp.glm.Rd---
@@ -109,9 +109,6 @@ function call is interrupted and no plot printed.}
 
 \item{show.values}{logical, whether values should be plotted or not.}
 
-\item{show.p}{Logical, adds significance levels to values, or value and
-variable labels.}
-
 \item{show.ci}{Logical, if \code{TRUE}, depending on \code{type}, a confidence
 interval or region is added to the plot. For frequency plots, the
 confidence interval for the relative frequencies are shown.}

---FILE: man/sjp.glmer.Rd---
@@ -114,9 +114,6 @@ need smaller values than dot sizes.}
 
 \item{show.values}{logical, whether values should be plotted or not.}
 
-\item{show.p}{Logical, adds significance levels to values, or value and
-variable labels.}
-
 \item{show.ci}{Logical, if \code{TRUE}, depending on \code{type}, a confidence
 interval or region is added to the plot. For frequency plots, the
 confidence interval for the relative frequencies are shown.}

---FILE: man/sjp.gpt.Rd---
@@ -79,9 +79,6 @@ i.e. at every \code{grid.breaks}'th position a major grid is being printed.}
 the total-row in the figure will be highlighted with a slightly
 shaded background.}
 
-\item{show.p}{Logical, adds significance levels to values, or value and
-variable labels.}
-
 \item{show.n}{logical, if \code{TRUE}, adds total number of cases for each
 group or category to the labels.}
 

---FILE: man/sjp.lm.Rd---
@@ -30,7 +30,6 @@ sjp.lm(fit, type = ""lm"", vars = NULL, group.estimates = NULL,
   \item{\code{""std2""}}{for forest-plot like plot of standardized beta values, however, standardization is done by dividing by two sd (see 'Details'). If the fitted model only contains one predictor, intercept and slope are plotted.}
   \item{\code{""slope""}}{to plot regression lines for each single predictor of the fitted model, against the response (linear relationship between each model term and response).}
   \item{\code{""resid""}}{to plot regression lines for each single predictor of the fitted model, against the residuals (linear relationship between each model term and residuals). May be used for model diagnostics.}
-  \item{\code{""poly""}}{to plot predicted values (marginal effects) of polynomial terms in \code{fit}. Use \code{poly.term} to specify the polynomial term in the fitted model (see 'Examples').}
   \item{\code{""ma""}}{to check model assumptions. Note that only three arguments are relevant for this option \code{fit} and \code{complete.dgns}. All other arguments are ignored.}
   \item{\code{""vif""}}{to plot Variance Inflation Factors.}
 }}

---FILE: man/sjp.lmer.Rd---
@@ -124,9 +124,6 @@ of same length as groups. See 'Examples'.}
 
 \item{show.values}{logical, whether values should be plotted or not.}
 
-\item{show.p}{Logical, adds significance levels to values, or value and
-variable labels.}
-
 \item{show.ci}{Logical, if \code{TRUE}, depending on \code{type}, a confidence
 interval or region is added to the plot. For frequency plots, the
 confidence interval for the relative frequencies are shown.}"
strengejacke,sjPlot,581a76ea226d36ebeb0fbac439fa31353ce46677,Daniel,mail@danielluedecke.de,2017-07-04T17:02:48Z,Daniel,mail@danielluedecke.de,2017-07-04T17:02:48Z,"read.me, fix namespace",R/sjTabSPSS.R;README.md,False,True,True,False,4,7,11,"---FILE: R/sjTabSPSS.R---
@@ -182,8 +182,8 @@ view_df <- function(x,
              sprintf(""    <td class=\""tdata%s\"">%i</td>\n"", arcstring, index))
 
     # name, and note
-    if (!is.null(sjmisc::get_note(x[[index]])))
-      td.title.tag <- sprintf("" title=\""%s\"""", sjmisc::get_note(x[[index]]))
+    if (!is.null(sjlabelled::get_note(x[[index]])))
+      td.title.tag <- sprintf("" title=\""%s\"""", sjlabelled::get_note(x[[index]]))
     else
       td.title.tag <- """"
 

---FILE: README.md---
@@ -14,12 +14,9 @@ library(devtools)
 devtools::install_github(""strengejacke/sjPlot"")
 ```
 
-Please note that the latest development snapshot most likely depends on the latest builds of the [sjmisc-package](https://github.com/strengejacke/sjmisc) and [sjstats-package](https://github.com/strengejacke/sjstats), so you probably want to install these as well:
+Please note the package dependencies when installing from GitHub. The GitHub version of this package may depend on latest GitHub versions of my other packages, so you may need to install those first, if you encounter any problems. Here's the order for installing packages from GitHub:
 
-```r
-devtools::install_github(""strengejacke/sjmisc"")
-devtools::install_github(""strengejacke/sjstats"")
-```
+[sjlabelled](https://github.com/strengejacke/sjlabelled) &rarr; [sjmisc](https://github.com/strengejacke/sjmisc) &rarr; [sjstats](https://github.com/strengejacke/sjstats) &rarr; [ggeffects](https://github.com/strengejacke/ggeffects) &rarr; [sjPlot](https://github.com/strengejacke/sjPlot)
 
 ### Officiale, stable release
 "
strengejacke,sjPlot,dcda7c4839758b572528c7637d91f0c1358594ec,Daniel Ldecke,d.luedecke@uke.de,2017-03-01T17:59:52Z,Daniel Ldecke,d.luedecke@uke.de,2017-03-01T17:59:52Z,minor fixes,NAMESPACE;NEWS;NEWS.md;R/sjPlotLinreg.R;R/sjTabMannWhitney.R;R/sjTabOdds.R;R/sjTabPropTable.R;man/sjt.glm.Rd;man/sjt.glmer.Rd;man/sjt.mwu.Rd,False,True,True,False,210,49,259,"---FILE: NAMESPACE---
@@ -161,7 +161,6 @@ importFrom(sjstats,table_values)
 importFrom(sjstats,weight)
 importFrom(sjstats,weight2)
 importFrom(sjstats,wtd_sd)
-importFrom(sjstats,xtab_statistics)
 importFrom(stats,AIC)
 importFrom(stats,anova)
 importFrom(stats,aov)

---FILE: NEWS---
@@ -11,14 +11,15 @@ Changes to functions:
 * For effect-plots (`type = ""eff""`), the `axis.title`-argument can now be used to change the title of y-axes.
 * For `sjp.lm()`, `sjp.glm()`, `sjp.lmer()` and `sjp.glmer()`, if color palette has more values than needed, it is silently shortend to the required length.
 * When plotting mixed models, argument `geom.colors` now also applies to plot-type `type = ""ri.slope""`.
-* New default correlation-method for `sjt.corr()` and `sjp.corr()` is now `pearson`.
+* Default correlation-method for `sjt.corr()` and `sjp.corr()` is now `pearson`.
 * Argument `emph.p` for printing tables of regression models now defaults to `FALSE`.
 
 Bug fixes:
 * Fixed bug in `sjt.frq()` for variables with many missign values and labelled values that did not occur on that variable.
 * Argument `value.labels` had no effect for `sjt.frq()`.
 * Automatic label detection in `sjt.grpmean()` sometimes not worked for factors without variable labels.
 * `sjp.glm()` used ""Odds Ratios"" as default title for y-axis when plotting marginal effects. Fixed, now y-axis is correctly labelled.
+* `sjt.glm()` used ""Odds Ratios"" as default column heading for the estimates, even for poisson or other models. Now the string for column headers is selected based on the first model input of the function.
 * Solved issue with warning in prediction-plots (`type = ""pred""`) for categorical variables on the x-axis.
 
 Version 2.3.0

---FILE: NEWS.md---
@@ -13,7 +13,7 @@
 * For effect-plots (`type = ""eff""`), the `axis.title`-argument can now be used to change the title of y-axes.
 * For `sjp.lm()`, `sjp.glm()`, `sjp.lmer()` and `sjp.glmer()`, if color palette has more values than needed, it is silently shortend to the required length.
 * When plotting mixed models, argument `geom.colors` now also applies to plot-type `type = ""ri.slope""`.
-* New default correlation-method for `sjt.corr()` and `sjp.corr()` is now `pearson`.
+* Default correlation-method for `sjt.corr()` and `sjp.corr()` is now `pearson`.
 * Argument `emph.p` for printing tables of regression models now defaults to `FALSE`.
 
 ## Bug fixes
@@ -22,6 +22,7 @@
 * Argument `value.labels` had no effect for `sjt.frq()`.
 * Automatic label detection in `sjt.grpmean()` sometimes not worked for factors without variable labels.
 * `sjp.glm()` used _Odds Ratios_ as default title for y-axis when plotting marginal effects. Fixed, now y-axis is correctly labelled.
+* `sjt.glm()` used ""Odds Ratios"" as default column heading for the estimates, even for poisson or other models. Now the string for column headers is selected based on the first model input of the function.
 * Solved issue with warning in prediction-plots (`type = ""pred""`) for categorical variables on the x-axis.
 
 # sjPlot 2.3.0

---FILE: R/sjPlotLinreg.R---
@@ -908,41 +908,34 @@ sjp.lm.ma <- function(linreg, complete.dgns = FALSE) {
   # ---------------------------------
   # summarize old and new model
   # ---------------------------------
-  if (inherits(linreg, ""lm"")) {
-    p1 <- sjp.lm(linreg, prnt.plot = FALSE)$plot
+  if (inherits(linreg, ""lm"") && complete.dgns) {
+    # ---------------------------------
+    # Plot residuals against predictors
+    # ---------------------------------
+    p1 <- sjp.reglin(linreg,
+                     title = ""Relationship of residuals against predictors"",
+                     subtitle = ""If scatterplots show a pattern, relationship may be nonlinear and model needs to be modified accordingly"",
+                     wrap.title = 60, useResiduals = T, alpha = .15)$plot.list
     # save plot
-    plot.list[[length(plot.list) + 1]] <- p1
-    # print plot
-    graphics::plot(p1)
-    if (complete.dgns) {
-      # ---------------------------------
-      # Plot residuals against predictors
-      # ---------------------------------
-      p1 <- sjp.reglin(linreg,
-                       title = ""Relationship of residuals against predictors"",
-                       subtitle = ""If scatterplots show a pattern, relationship may be nonlinear and model needs to be modified accordingly"",
-                       wrap.title = 60, useResiduals = T, alpha = .15)$plot.list
-      # save plot
-      plot.list <- c(plot.list, p1)
-      # ---------------------------------
-      # Non-linearity
-      # ---------------------------------
-      graphics::plot(car::crPlots(linreg))
-      # ---------------------------------
-      # non-independence of residuals
-      # ---------------------------------
-      print(car::durbinWatsonTest(linreg))
-      # ---------------------------------
-      # Print leverage plots
-      # ---------------------------------
-      graphics::plot(car::leveragePlots(linreg))
-      # ---------------------------------
-      # Non-constant residuals
-      # ---------------------------------
-      print(car::ncvTest(linreg))
-      print(lmtest::bptest(linreg))
-      print(car::spreadLevelPlot(linreg))
-    }
+    plot.list <- c(plot.list, p1)
+    # ---------------------------------
+    # Non-linearity
+    # ---------------------------------
+    graphics::plot(car::crPlots(linreg))
+    # ---------------------------------
+    # non-independence of residuals
+    # ---------------------------------
+    print(car::durbinWatsonTest(linreg))
+    # ---------------------------------
+    # Print leverage plots
+    # ---------------------------------
+    graphics::plot(car::leveragePlots(linreg))
+    # ---------------------------------
+    # Non-constant residuals
+    # ---------------------------------
+    print(car::ncvTest(linreg))
+    print(lmtest::bptest(linreg))
+    print(car::spreadLevelPlot(linreg))
   }
   # return updated model
   invisible(structure(list(class = ""sjp.lm.ma"",

---FILE: R/sjTabMannWhitney.R---
@@ -26,7 +26,7 @@
 #'
 #' @examples
 #' \dontrun{
-#' library(sjmisc)
+#' library(sjstats)
 #' data(efc)
 #' sjt.mwu(mwu(efc$e17age, efc$e42dep))}
 
@@ -43,7 +43,7 @@ sjt.mwu <- function(x,
   # --------------------------------------------------------
   # check correct class
   # --------------------------------------------------------
-  if (class(x) != ""mwu"") {
+  if (!inherits(x, ""mwu"")) {
     stop(""`x` must be of class `mwu`, as returned by the `mwu()`-function of the sjstats-package."", call. = F)
   }
   # --------------------------------------------------------

---FILE: R/sjTabOdds.R---
@@ -119,7 +119,8 @@
 #'             data = efc, family = poisson(link = ""log""))
 #'
 #' # compare models
-#' sjt.glm(fit1, fit2, fit3, show.aic = TRUE, show.family = TRUE)
+#' sjt.glm(fit1, fit2, fit3, string.est = ""Estimate"",
+#'         show.aic = TRUE, show.family = TRUE)
 #'
 #' # --------------------------------------------
 #' # Change style of p-values and CI-appearance
@@ -167,7 +168,7 @@
 #' # print models with different predictors
 #' sjt.glm(fit, fit2, fit3, group.pred = FALSE)}
 #'
-#' @importFrom dplyr full_join slice mutate
+#' @importFrom dplyr full_join slice mutate if_else
 #' @importFrom stats nobs AIC confint coef logLik family deviance
 #' @importFrom sjstats std_beta icc r2 cod chisq_gof hoslem_gof se
 #' @importFrom tibble lst
@@ -203,7 +204,7 @@ sjt.glm <- function(...,
                     string.dv = ""Dependent Variables"",
                     string.interc = ""(Intercept)"",
                     string.obs = ""Observations"",
-                    string.est = ""OR"",
+                    string.est = NULL,
                     string.ci = ""CI"",
                     string.se = ""std. Error"",
                     string.p = ""p"",
@@ -443,6 +444,40 @@ sjt.glm <- function(...,
     # select rows
     joined.df <- dplyr::slice(joined.df, keep.estimates)
   }
+
+
+  # select correct column heading, depending on model family and link function
+  if (is.null(string.est)) {
+    # get family
+    fitfam <- get_glm_family(input_list[[1]])
+    # check if we have a binomial model
+    if (fitfam$is_bin) {
+      # here we gor for logistic regression
+      # estimate is ""Odds Ratio""
+      if (fitfam$is_logit) {
+        string.est <-
+          dplyr::if_else(isTRUE(exp.coef),
+                         true = ""Odds Ratio"",
+                         false = ""Log-Odds"",
+                         missing = ""Estimate"")
+      } else {
+        # estimate is ""Risk Ratio""
+        string.est <-
+          dplyr::if_else(isTRUE(exp.coef),
+                         true = ""Risk Ratio"",
+                         false = ""Log-Risk"",
+                         missing = ""Estimate"")
+      }
+    } else if (fitfam$is_pois) {
+      string.est <- dplyr::if_else(isTRUE(exp.coef),
+                                   true = ""IRR"",
+                                   false = ""Log-Mean"",
+                                   missing = ""Estimate"")
+    } else {
+      string.est <- ""Estimate""
+    }
+  }
+
   # -------------------------------------
   # if confidence interval should be omitted,
   # don't use separate column for CI!
@@ -1207,7 +1242,7 @@ sjt.glmer <- function(...,
                       string.dv = ""Dependent Variables"",
                       string.interc = ""(Intercept)"",
                       string.obs = ""Observations"",
-                      string.est = ""OR"",
+                      string.est = NULL,
                       string.ci = ""CI"",
                       string.se = ""std. Error"",
                       string.p = ""p"",

---FILE: R/sjTabPropTable.R---
@@ -105,7 +105,6 @@
 #' )
 #'
 #' @importFrom stats ftable
-#' @importFrom sjstats xtab_statistics
 #' @export
 sjt.xtab <- function(var.row,
                      var.col,
@@ -428,7 +427,7 @@ sjt.xtab <- function(var.row,
   # table summary
   # -------------------------------------
   if (show.summary) {
-    xt_stat <- sjstats::xtab_statistics(data = data.frame(var.row, var.col), statistics = statistics, ...)
+    xt_stat <- xtab_stats(data = data.frame(var.row, var.col), statistics = statistics, ...)
 
     # fisher's exact test?
     if (xt_stat$fisher)
@@ -566,3 +565,135 @@ sjt.xtab <- function(var.row,
                            show = !no.output,
                            use.viewer = use.viewer))
 }
+
+
+#' @importFrom dplyr case_when
+#' @importFrom sjstats table_values cramer phi
+#' @importFrom stats fisher.test cor.test chisq.test
+xtab_stats <- function(data, x1 = NULL, x2 = NULL, statistics = c(""auto"", ""cramer"", ""phi"", ""spearman"", ""kendall"", ""pearson""), ...) {
+  # match arguments
+  statistics <- match.arg(statistics)
+
+  # name for test statistics in HTML
+  stat.html <- NULL
+
+  # check if data is a table
+  if (!is.table(data)) {
+    # evaluate unquoted names
+    x1 <- deparse(substitute(x1))
+    x2 <- deparse(substitute(x2))
+
+    # if names were quotes, remove quotes
+    x1 <- gsub(""\"""", """", x1, fixed = T)
+    x2 <- gsub(""\"""", """", x2, fixed = T)
+
+    # check for ""NULL"" and get data
+    if (x1 != ""NULL"" && x2 != ""NULL"")
+      data <- data[, c(x1, x2)]
+    else
+      data <- data[, 1:2]
+
+    # make simple table
+    tab <- table(data)
+  } else {
+    # 'data' is a table - copy to table object
+    tab <- data
+    # check if statistics are possible to compute
+    if (statistics %in% c(""spearman"", ""kendall"", ""pearson"")) {
+      stop(
+        sprintf(
+          ""Need arguments `data`, `x1` and `x2` to compute %s-statistics."",
+          statistics
+        ),
+        call. = F
+      )
+    }
+  }
+
+  # get expected values
+  tab.val <- sjstats::table_values(tab)
+
+  # remember whether fisher's exact test was used or not
+  use.fisher <- FALSE
+
+  # select statistics automatically, based on number of rows/columns
+  if (statistics %in% c(""auto"", ""cramer"", ""phi"")) {
+    # get chisq-statistics, for df and p-value
+    chsq <- suppressWarnings(stats::chisq.test(tab, ...))
+    pv <- chsq$p.value
+    test <- chsq$statistic
+
+    # set statistics name
+    names(test) <- ""Chi-squared""
+    stat.html <- ""&chi;<sup>2</sup>""
+
+    # check row/column
+    if ((nrow(tab) > 2 || ncol(tab) > 2 || statistics == ""cramer"") && statistics != ""phi"") {
+      # get cramer's V
+      s <- sjstats::cramer(tab)
+
+      # if minimum expected values below 5, compute fisher's exact test
+      if (min(tab.val$expected) < 5 ||
+          (min(tab.val$expected) < 10 && chsq$parameter == 1)) {
+        pv <- stats::fisher.test(tab, simulate.p.value = TRUE, ...)$p.value
+        use.fisher <- TRUE
+      }
+
+      # set statistics
+      statistics <- ""cramer""
+    } else {
+      # get Phi
+      s <- sjstats::phi(tab)
+
+      # if minimum expected values below 5 and df=1, compute fisher's exact test
+      if (min(tab.val$expected) < 5 ||
+          (min(tab.val$expected) < 10 && chsq$parameter == 1)) {
+        pv <- stats::fisher.test(tab, ...)$p.value
+        use.fisher <- TRUE
+      }
+
+      # set statistics
+      statistics <- ""phi""
+    }
+  } else {
+    # compute correlation coefficient
+    cv <- stats::cor.test(x = data[[1]], y = data[[2]], method = statistics, ...)
+    # get statistics and p-value
+    s <- cv$estimate
+    pv <- cv$p.value
+    test <- cv$statistic
+    stat.html <- names(test)
+  }
+
+  # compute method string
+  method <- dplyr::case_when(
+    statistics == ""kendall"" ~ ""Kendall's tau"",
+    statistics == ""spearman"" ~ ""Spearman's rho"",
+    statistics == ""pearson"" ~ ""Person's r"",
+    statistics == ""cramer"" ~ ""Cramer's V"",
+    statistics == ""phi"" ~ ""Phi""
+  )
+
+  # compute method string
+  method.html <- dplyr::case_when(
+    statistics == ""kendall"" ~ ""Kendall's &tau;"",
+    statistics == ""spearman"" ~ ""Spearman's &rho;"",
+    statistics == ""pearson"" ~ ""Person's r"",
+    statistics == ""cramer"" ~ ""Cramer's V"",
+    statistics == ""phi"" ~ ""&phi;""
+  )
+
+  # return result
+  return(structure(class = ""sj_xtab_stat"", list(
+    estimate = s,
+    p.value = pv,
+    statistic = test,
+    stat.name = names(test),
+    stat.html = stat.html,
+    df = (nrow(tab) - 1) * (ncol(tab) - 1),
+    method = method,
+    method.html = method.html,
+    method.short = statistics,
+    fisher = use.fisher
+  )))
+}

---FILE: man/sjt.glm.Rd---
@@ -14,7 +14,7 @@ sjt.glm(..., pred.labels = NULL, depvar.labels = NULL,
   show.dev = FALSE, show.hoslem = FALSE, show.family = FALSE,
   show.chi2 = FALSE, string.pred = ""Predictors"",
   string.dv = ""Dependent Variables"", string.interc = ""(Intercept)"",
-  string.obs = ""Observations"", string.est = ""OR"", string.ci = ""CI"",
+  string.obs = ""Observations"", string.est = NULL, string.ci = ""CI"",
   string.se = ""std. Error"", string.p = ""p"",
   ci.hyphen = ""&nbsp;&ndash;&nbsp;"", digits.est = 2, digits.p = 3,
   digits.ci = 2, digits.se = 2, digits.summary = 3, cell.spacing = 0.2,
@@ -292,7 +292,8 @@ fit3 <- glm(services ~ neg_c_7 + c161sex + e42dep,
             data = efc, family = poisson(link = ""log""))
 
 # compare models
-sjt.glm(fit1, fit2, fit3, show.aic = TRUE, show.family = TRUE)
+sjt.glm(fit1, fit2, fit3, string.est = ""Estimate"",
+        show.aic = TRUE, show.family = TRUE)
 
 # --------------------------------------------
 # Change style of p-values and CI-appearance

---FILE: man/sjt.glmer.Rd---
@@ -14,7 +14,7 @@ sjt.glmer(..., pred.labels = NULL, depvar.labels = NULL,
   show.dev = TRUE, show.hoslem = FALSE, show.family = FALSE,
   string.pred = ""Predictors"", string.dv = ""Dependent Variables"",
   string.interc = ""(Intercept)"", string.obs = ""Observations"",
-  string.est = ""OR"", string.ci = ""CI"", string.se = ""std. Error"",
+  string.est = NULL, string.ci = ""CI"", string.se = ""std. Error"",
   string.p = ""p"", ci.hyphen = ""&nbsp;&ndash;&nbsp;"", digits.est = 2,
   digits.p = 3, digits.ci = 2, digits.se = 2, digits.summary = 3,
   cell.spacing = 0.2, cell.gpr.indent = 0.6, sep.column = TRUE,

---FILE: man/sjt.mwu.Rd---
@@ -66,7 +66,7 @@ See 'Notes' in \code{\link{sjt.frq}}.
 }
 \examples{
 \dontrun{
-library(sjmisc)
+library(sjstats)
 data(efc)
 sjt.mwu(mwu(efc$e17age, efc$e42dep))}
 }"
strengejacke,sjPlot,84fd654a992db4d73b5deccddcad2f04b15c0f43,Daniel Ldecke,d.luedecke@uke.de,2017-02-20T18:01:24Z,Daniel Ldecke,d.luedecke@uke.de,2017-02-20T18:01:24Z,"names of test statistics, addresses https://github.com/sjPlot/sjstats/issues/4",R/sjTabPropTable.R;man/sjt.corr.Rd;man/sjt.pca.Rd;man/sjt.stackfrq.Rd;man/sjt.xtab.Rd,False,True,True,False,77,55,132,"---FILE: R/sjTabPropTable.R---
@@ -1,24 +1,24 @@
 #' @title Summary of contingency tables as HTML table
 #' @name sjt.xtab
-#' 
+#'
 #' @description Shows contingency tables as HTML file in browser or viewer pane, or saves them as file.
-#' 
+#'
 #' @seealso \itemize{
 #'            \item \href{http://www.strengejacke.de/sjPlot/sjt.xtab}{sjPlot manual: sjt.xtab}
 #'            \item \code{\link{sjp.xtab}}
 #'          }
-#'              
+#'
 #' @param var.row variable that should be displayed in the table rows.
 #' @param var.col variable that should be displayed in the table columns.
-#' @param var.labels character vector with variable names, which will be used 
+#' @param var.labels character vector with variable names, which will be used
 #'          to label variables in the output.
 #' @param string.total label for the total column / row header
 #' @param show.cell.prc logical, if \code{TRUE}, cell percentage values are shown
 #' @param show.row.prc logical, if \code{TRUE}, row percentage values are shown
 #' @param show.col.prc logical, if \code{TRUE}, column percentage values are shown
 #' @param show.obs logical, if \code{TRUE}, observed values are shown
 #' @param show.exp logical, if \code{TRUE}, expected values are also shown
-#' @param show.summary logical, if \code{TRUE}, a summary row with 
+#' @param show.summary logical, if \code{TRUE}, a summary row with
 #'          chi-squared statistics, degrees of freedom and Cramer's V or Phi
 #'          coefficient and p-value for the chi-squared statistics.
 #' @param tdcol.n Color for highlighting count (observed) values in table cells. Default is black.
@@ -40,12 +40,12 @@
 #'          \code{""kendall""} or \code{""pearson""}. See 'Details'.
 #' @param ... Other arguments, currently passed down to the test statistics functions
 #'        \code{chisq.test()} or \code{fisher.test()}.
-#'          
+#'
 #' @inheritParams sjt.frq
 #' @inheritParams sjt.df
 #' @inheritParams sjp.glmer
 #' @inheritParams sjp.grpfrq
-#'          
+#'
 #' @return Invisibly returns
 #'          \itemize{
 #'            \item the web page style sheet (\code{page.style}),
@@ -54,7 +54,7 @@
 #'            \item the html-table with inline-css for use with knitr (\code{knitr})
 #'            }
 #'            for further use.
-#'          
+#'
 #' @details The p-value for Cramer's V and the Phi coefficient are based
 #'          on \code{chisq.test()}. If any expected value of a table cell is
 #'          smaller than 5, or smaller than 10 and the df is 1, then \code{fisher.test()}
@@ -67,32 +67,43 @@
 #'          When \code{statistics = ""auto""}, only Cramer's V or Phi are calculated,
 #'          based on the dimension of the table (i.e. if the table has more than
 #'          two rows or columns, Cramer's V is calculated, else Phi).
-#'         
-#' @examples 
+#'
+#' @examples
 #' # prepare sample data set
 #' library(sjmisc)
 #' data(efc)
-#' efc.labels <- get_labels(efc)
-#' 
+#'
 #' # print simple cross table with labels
 #' \dontrun{
 #' sjt.xtab(efc$e16sex, efc$e42dep)
-#'          
+#'
 #' # print cross table with manually set
 #' # labels and expected values
-#' sjt.xtab(efc$e16sex, efc$e42dep, var.labels = c(""Elder's gender"", 
-#'          ""Elder's dependency""), value.labels = list(efc.labels[['e16sex']], 
+#' sjt.xtab(efc$e16sex, efc$e42dep, var.labels = c(""Elder's gender"",
+#'          ""Elder's dependency""), value.labels = list(efc.labels[['e16sex']],
 #'          efc.labels[['e42dep']]), show.exp = TRUE)
-#' 
+#'
 #' # print minimal cross table with labels, total col/row highlighted
 #' sjt.xtab(efc$e16sex, efc$e42dep, show.cell.prc = FALSE, emph.total = TRUE)
-#' 
+#'
 #' # User defined style sheet
-#' sjt.xtab(efc$e16sex, efc$e42dep, 
+#' sjt.xtab(efc$e16sex, efc$e42dep,
 #'          CSS = list(css.table = ""border: 2px solid;"",
 #'                     css.tdata = ""border: 1px solid;"",
 #'                     css.horline = ""border-bottom: double blue;""))}
 #'
+#' # ordinal data, use Kendall's tau
+#' sjt.xtab(efc$e42dep, efc$quol_5, statistics = ""kendall"")
+#'
+#' # calculate Spearman's rho, with continuity correction
+#' sjt.xtab(
+#'   efc$e42dep,
+#'   efc$quol_5,
+#'   statistics = ""spearman"",
+#'   exact = FALSE,
+#'   continuity = TRUE
+#' )
+#'
 #' @importFrom stats ftable
 #' @importFrom sjstats xtab_statistics
 #' @export
@@ -284,12 +295,12 @@ sjt.xtab <- function(var.row,
   # -------------------------------------
   # set style sheet
   # -------------------------------------
-  page.style <- sprintf(""<style>\n%s { %s }\n%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { color:%s }\n.%s { color:%s }\n.%s { color:%s }\n.%s { color:%s }\n.%s { color:%s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n</style>"", 
-                        tag.table, css.table, tag.caption, css.caption, tag.thead, css.thead, tag.tdata, css.tdata, tag.secondtablerow, css.secondtablerow, 
-                        tag.leftalign, css.leftalign, tag.centeralign, css.centeralign, tag.lasttablerow, css.lasttablerow, 
+  page.style <- sprintf(""<style>\n%s { %s }\n%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n.%s { color:%s }\n.%s { color:%s }\n.%s { color:%s }\n.%s { color:%s }\n.%s { color:%s }\n.%s { %s }\n.%s { %s }\n.%s { %s }\n</style>"",
+                        tag.table, css.table, tag.caption, css.caption, tag.thead, css.thead, tag.tdata, css.tdata, tag.secondtablerow, css.secondtablerow,
+                        tag.leftalign, css.leftalign, tag.centeralign, css.centeralign, tag.lasttablerow, css.lasttablerow,
                         tag.totcol, css.totcol, tag.tothi, css.tothi,
                         tag.td_n, tdcol.n, tag.td_c, tdcol.cell, tag.td_rw, tdcol.row,
-                        tag.td_cl, tdcol.col, tag.td_ex, tdcol.expected, 
+                        tag.td_cl, tdcol.col, tag.td_ex, tdcol.expected,
                         tag.summary, css.summary, tag.horline, css.horline,
                         tag.firstcolborder, css.firstcolborder)
   # start writing content
@@ -358,8 +369,8 @@ sjt.xtab <- function(var.row,
       css_last_row_th <- "" ""
       css_last_row <- """"
     }
-    page.content <- paste(page.content, 
-                          sprintf(""\n    <td class=\""tdata %sleftalign\"">%s</td>"", 
+    page.content <- paste(page.content,
+                          sprintf(""\n    <td class=\""tdata %sleftalign\"">%s</td>"",
                                   css_last_row_th,
                                   labels.var.row[rowlabelcnt[irow]]))
     # -------------------------------------
@@ -406,7 +417,7 @@ sjt.xtab <- function(var.row,
       # -------------------------------------
       # write table cell data
       # -------------------------------------
-      page.content <- paste(page.content, sprintf(""\n    <td class=\""tdata centeralign horline%s\"">%s</td>"", 
+      page.content <- paste(page.content, sprintf(""\n    <td class=\""tdata centeralign horline%s\"">%s</td>"",
                                                   ifelse(css_last_row == """", css_tot_col, css_last_row),
                                                   cellstring), sep = """")
     }
@@ -424,16 +435,16 @@ sjt.xtab <- function(var.row,
       pstring <- ""Fisher's p""
     else
       pstring <- ""p""
-    
+
     page.content <- paste(
       page.content,
       sprintf(
         ""    <td class=\""summary tdata\"" colspan=\""%i\"">%s=%.3f &middot; df=%i &middot; %s=%.3f &middot; %s=%.3f</td>"",
         totalncol + 1,
-        xt_stat$stat.name,
+        xt_stat$stat.html,
         xt_stat$statistic,
         xt_stat$df,
-        xt_stat$method,
+        xt_stat$method.html,
         xt_stat$estimate,
         pstring,
         xt_stat$p.value,
@@ -442,7 +453,7 @@ sjt.xtab <- function(var.row,
     )
     # close table row
     page.content <- paste(page.content, ""\n  </tr>\n"")
-  }  
+  }
   # -------------------------------------
   # finish table
   # -------------------------------------
@@ -469,16 +480,16 @@ sjt.xtab <- function(var.row,
     # show row percentage?
     # -----------------
     if (show.row.prc) {
-      page.content <- paste(page.content, 
-                            sprintf(""<span class=\""td_rw\"">&#37; within %s</span><br>\n"", 
+      page.content <- paste(page.content,
+                            sprintf(""<span class=\""td_rw\"">&#37; within %s</span><br>\n"",
                                     gsub(""<br>"", "" "", s.var.row, fixed = TRUE)))
     }
     # -----------------
     # show row percentage?
     # -----------------
     if (show.col.prc) {
-      page.content <- paste(page.content, 
-                            sprintf(""<span class=\""td_cl\"">&#37; within %s</span><br>\n"", 
+      page.content <- paste(page.content,
+                            sprintf(""<span class=\""td_cl\"">&#37; within %s</span><br>\n"",
                                     gsub(""<br>"", "" "", s.var.col, fixed = TRUE)))
     }
     # -----------------
@@ -519,21 +530,21 @@ sjt.xtab <- function(var.row,
   knitr <- gsub(tag.thead, css.thead, knitr, fixed = TRUE, useBytes = TRUE)
   knitr <- gsub(tag.secondtablerow, css.secondtablerow, knitr, fixed = TRUE, useBytes = TRUE)
   knitr <- gsub(tag.firstcolborder, css.firstcolborder, knitr, fixed = TRUE, useBytes = TRUE)
-  knitr <- gsub(tag.leftalign, css.leftalign, knitr, fixed = TRUE, useBytes = TRUE)  
-  knitr <- gsub(tag.centeralign, css.centeralign, knitr, fixed = TRUE, useBytes = TRUE)  
-  knitr <- gsub(tag.horline, css.horline, knitr, fixed = TRUE, useBytes = TRUE)  
-  knitr <- gsub(tag.lasttablerow, css.lasttablerow, knitr, fixed = TRUE, useBytes = TRUE)  
-  knitr <- gsub(tag.totcol, css.totcol, knitr, fixed = TRUE, useBytes = TRUE)  
-  knitr <- gsub(tag.summary, css.summary, knitr, fixed = TRUE, useBytes = TRUE)  
-  knitr <- gsub(tag.tothi, css.tothi, knitr, fixed = TRUE, useBytes = TRUE)  
+  knitr <- gsub(tag.leftalign, css.leftalign, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.centeralign, css.centeralign, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.horline, css.horline, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.lasttablerow, css.lasttablerow, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.totcol, css.totcol, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.summary, css.summary, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.tothi, css.tothi, knitr, fixed = TRUE, useBytes = TRUE)
   # -------------------------------------
   # replace color-attributes for legend
   # -------------------------------------
-  knitr <- gsub(tag.td_ex, sprintf(""color:%s;"",tdcol.expected), knitr, fixed = TRUE, useBytes = TRUE)  
-  knitr <- gsub(tag.td_cl, sprintf(""color:%s;"",tdcol.col), knitr, fixed = TRUE, useBytes = TRUE)  
-  knitr <- gsub(tag.td_rw, sprintf(""color:%s;"",tdcol.row), knitr, fixed = TRUE, useBytes = TRUE)  
-  knitr <- gsub(tag.td_c, sprintf(""color:%s;"",tdcol.cell), knitr, fixed = TRUE, useBytes = TRUE)  
-  knitr <- gsub(tag.td_n, sprintf(""color:%s;"",tdcol.n), knitr, fixed = TRUE, useBytes = TRUE)  
+  knitr <- gsub(tag.td_ex, sprintf(""color:%s;"",tdcol.expected), knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.td_cl, sprintf(""color:%s;"",tdcol.col), knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.td_rw, sprintf(""color:%s;"",tdcol.row), knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.td_c, sprintf(""color:%s;"",tdcol.cell), knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.td_n, sprintf(""color:%s;"",tdcol.n), knitr, fixed = TRUE, useBytes = TRUE)
   # -------------------------------------
   # remove spaces?
   # -------------------------------------

---FILE: man/sjt.corr.Rd---
@@ -25,7 +25,7 @@ May be abbreviated.}
 
 \item{title}{table caption, as character vector.}
 
-\item{var.labels}{character vector with variable names, which will be used 
+\item{var.labels}{character vector with variable names, which will be used
 to label variables in the output.}
 
 \item{wrap.labels}{numeric, determines how many chars of the value, variable or axis 

---FILE: man/sjt.pca.Rd---
@@ -32,7 +32,7 @@ between the highest and 2nd highest factor should be 0.1}
 
 \item{title}{table caption, as character vector.}
 
-\item{var.labels}{character vector with variable names, which will be used 
+\item{var.labels}{character vector with variable names, which will be used
 to label variables in the output.}
 
 \item{wrap.labels}{numeric, determines how many chars of the value, variable or axis 

---FILE: man/sjt.stackfrq.Rd---
@@ -21,7 +21,7 @@ Must be a vector of same length as the input vector. Default is
 
 \item{title}{table caption, as character vector.}
 
-\item{var.labels}{character vector with variable names, which will be used 
+\item{var.labels}{character vector with variable names, which will be used
 to label variables in the output.}
 
 \item{value.labels}{character vector (or \code{list} of character vectors)

---FILE: man/sjt.xtab.Rd---
@@ -27,7 +27,7 @@ Must be a vector of same length as the input vector. Default is
 
 \item{title}{table caption, as character vector.}
 
-\item{var.labels}{character vector with variable names, which will be used 
+\item{var.labels}{character vector with variable names, which will be used
 to label variables in the output.}
 
 \item{value.labels}{character vector (or \code{list} of character vectors)
@@ -53,7 +53,7 @@ function, a legend is added to the plot.}
 \item{show.na}{logical, if \code{TRUE}, \code{\link{NA}}'s (missing values)
 are added to the output.}
 
-\item{show.summary}{logical, if \code{TRUE}, a summary row with 
+\item{show.summary}{logical, if \code{TRUE}, a summary row with
 chi-squared statistics, degrees of freedom and Cramer's V or Phi
 coefficient and p-value for the chi-squared statistics.}
 
@@ -148,27 +148,38 @@ The p-value for Cramer's V and the Phi coefficient are based
 # prepare sample data set
 library(sjmisc)
 data(efc)
-efc.labels <- get_labels(efc)
 
 # print simple cross table with labels
 \dontrun{
 sjt.xtab(efc$e16sex, efc$e42dep)
-         
+
 # print cross table with manually set
 # labels and expected values
-sjt.xtab(efc$e16sex, efc$e42dep, var.labels = c(""Elder's gender"", 
-         ""Elder's dependency""), value.labels = list(efc.labels[['e16sex']], 
+sjt.xtab(efc$e16sex, efc$e42dep, var.labels = c(""Elder's gender"",
+         ""Elder's dependency""), value.labels = list(efc.labels[['e16sex']],
          efc.labels[['e42dep']]), show.exp = TRUE)
 
 # print minimal cross table with labels, total col/row highlighted
 sjt.xtab(efc$e16sex, efc$e42dep, show.cell.prc = FALSE, emph.total = TRUE)
 
 # User defined style sheet
-sjt.xtab(efc$e16sex, efc$e42dep, 
+sjt.xtab(efc$e16sex, efc$e42dep,
          CSS = list(css.table = ""border: 2px solid;"",
                     css.tdata = ""border: 1px solid;"",
                     css.horline = ""border-bottom: double blue;""))}
 
+# ordinal data, use Kendall's tau
+sjt.xtab(efc$e42dep, efc$quol_5, statistics = ""kendall"")
+
+# calculate Spearman's rho, with continuity correction
+sjt.xtab(
+  efc$e42dep,
+  efc$quol_5,
+  statistics = ""spearman"",
+  exact = FALSE,
+  continuity = TRUE
+)
+
 }
 \seealso{
 \itemize{"
strengejacke,sjPlot,c5bc142bcceabe8d5a9ba52b462662e7b7df3ef6,Daniel Ldecke,d.luedecke@uke.de,2017-02-14T18:43:57Z,Daniel Ldecke,d.luedecke@uke.de,2017-02-14T18:43:57Z,fix examples,R/S3-methods.R;R/sjTabItemAnalysis.R;R/sjTabLinReg.R;man/sjt.itemanalysis.Rd;man/sjt.lm.Rd,False,True,True,False,19,22,41,"---FILE: R/S3-methods.R---
@@ -32,10 +32,8 @@ print.sjTable <- function(x, ...) {
 #' @importFrom knitr asis_output
 #' @export
 knit_print.sjTable <-  function(input, ...) {
-
- if (!requireNamespace(""knitr"", quietly = TRUE)) {
-   stop(""Package `knitr` needed to print tables inside knitr-documents. Please install it."", call. = F)
-
- }
+  if (!requireNamespace(""knitr"", quietly = TRUE)) {
+    stop(""Package `knitr` needed to print tables inside knitr-documents. Please install it."", call. = F)
+  }
   knitr::asis_output(input$knitr)
 }

---FILE: R/sjTabItemAnalysis.R---
@@ -92,11 +92,11 @@
 #'             }
 #' 
 #' @examples
-#' Data from the EUROFAMCARE sample dataset
+#' # Data from the EUROFAMCARE sample dataset
 #' library(sjmisc)
 #' data(efc)
 #' 
-#' retrieve variable and value labels
+#' # retrieve variable and value labels
 #' varlabs <- get_label(efc)
 #' 
 #' # recveive first item of COPE-index scale
@@ -108,7 +108,7 @@
 #' mydf <- data.frame(efc[, c(start:end)])
 #' colnames(mydf) <- varlabs[c(start:end)]
 #' 
-#'  \dontrun{
+#' \dontrun{
 #' sjt.itemanalysis(mydf)
 #' 
 #' # auto-detection of labels
@@ -389,5 +389,4 @@ sjt.itemanalysis <- function(df,
       ideal.item.diff = diff.ideal.list
     )
   )
-
 }

---FILE: R/sjTabLinReg.R---
@@ -143,7 +143,7 @@
 #' \dontrun{
 #' # Now fit the models. Note that both models share the same predictors
 #' # and only differ in their dependent variable. See examples of stepwise
-#' models below at the end.
+#' # models below at the end.
 #' library(sjmisc)
 #' data(efc)
 #' 
@@ -152,12 +152,12 @@
 #' # fit second model
 #' fit2 <- lm(neg_c_7 ~ c160age + c12hour + c161sex + c172code, data = efc)
 #' 
-#' create and open HTML-table in RStudio Viewer Pane or web browser
-#' note that we don't need to specify labels for the predictors,
-#' because these are automatically read
+#' # create and open HTML-table in RStudio Viewer Pane or web browser
+#' # note that we don't need to specify labels for the predictors,
+#' # because these are automatically read
 #' sjt.lm(fit1, fit2)
 #' 
-#' create and open HTML-table in RStudio Viewer Pane or web browser
+#' # create and open HTML-table in RStudio Viewer Pane or web browser
 #' # in the following examples, we set labels via argument
 #' sjt.lm(fit1, fit2, 
 #'        depvar.labels = c(""Barthel-Index"", ""Negative Impact""),

---FILE: man/sjt.itemanalysis.Rd---
@@ -140,11 +140,11 @@ See 'Details' in \code{\link{sjt.frq}}.
 See 'Notes' in \code{\link{sjt.frq}}.
 }
 \examples{
-Data from the EUROFAMCARE sample dataset
+# Data from the EUROFAMCARE sample dataset
 library(sjmisc)
 data(efc)
 
-retrieve variable and value labels
+# retrieve variable and value labels
 varlabs <- get_label(efc)
 
 # recveive first item of COPE-index scale
@@ -156,7 +156,7 @@ end <- which(colnames(efc) == ""c90cop9"")
 mydf <- data.frame(efc[, c(start:end)])
 colnames(mydf) <- varlabs[c(start:end)]
 
- \dontrun{
+\dontrun{
 sjt.itemanalysis(mydf)
 
 # auto-detection of labels

---FILE: man/sjt.lm.Rd---
@@ -237,7 +237,7 @@ See 'Note' in \code{\link{sjt.frq}}.
 \dontrun{
 # Now fit the models. Note that both models share the same predictors
 # and only differ in their dependent variable. See examples of stepwise
-models below at the end.
+# models below at the end.
 library(sjmisc)
 data(efc)
 
@@ -246,12 +246,12 @@ fit1 <- lm(barthtot ~ c160age + c12hour + c161sex + c172code, data = efc)
 # fit second model
 fit2 <- lm(neg_c_7 ~ c160age + c12hour + c161sex + c172code, data = efc)
 
-create and open HTML-table in RStudio Viewer Pane or web browser
-note that we don't need to specify labels for the predictors,
-because these are automatically read
+# create and open HTML-table in RStudio Viewer Pane or web browser
+# note that we don't need to specify labels for the predictors,
+# because these are automatically read
 sjt.lm(fit1, fit2)
 
-create and open HTML-table in RStudio Viewer Pane or web browser
+# create and open HTML-table in RStudio Viewer Pane or web browser
 # in the following examples, we set labels via argument
 sjt.lm(fit1, fit2, 
        depvar.labels = c(""Barthel-Index"", ""Negative Impact""),"
strengejacke,sjPlot,ff772cb6d1584e7a1e1acb48b7362a80336007a9,Daniel Ldecke,d.luedecke@uke.de,2017-02-05T20:21:22Z,Daniel Ldecke,d.luedecke@uke.de,2017-02-05T20:21:22Z,fix broken URLs,DESCRIPTION;NEWS;NEWS.md;R/sjPlotInteractions.R;man/sjp.int.Rd;vignettes/sjpglm.Rmd,True,True,True,False,6,6,12,"---FILE: DESCRIPTION---
@@ -3,7 +3,7 @@ Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
 Version: 2.2.1.9000
-Date: 2017-01-11
+Date: 2017-02-06
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of plotting and table output functions for data

---FILE: NEWS---
@@ -1,4 +1,4 @@
-Version 2.2.2
+Version 2.3.0
 -----------------------------------------------------------------------------
 General:
 * Vignettes were added to this package.

---FILE: NEWS.md---
@@ -1,4 +1,4 @@
-# sjPlot 2.2.1.9000
+# sjPlot 2.3.0
 
 ## General
 

---FILE: R/sjPlotInteractions.R---
@@ -3,7 +3,7 @@
 #'
 #' @references \itemize{
 #'              \item Aiken and West (1991). Multiple Regression: Testing and Interpreting Interactions.
-#'              \item Brambor T, Clark WR and Golder M (2006) Understanding Interaction Models: Improving Empirical Analyses. Political Analysis 14: 63-82. \doi{10.1093/pan/mpi014}
+#'              \item Brambor T, Clark WR and Golder M (2006) Understanding Interaction Models: Improving Empirical Analyses. Political Analysis 14: 63-82. \href{https://academic.oup.com/pan/article/14/1/63/1501303/Understanding-Interaction-Models-Improving}{download}
 #'              \item Esarey J, Sumner JL (2015) Marginal Effects in Interaction Models: Determining and Controlling the False Positive Rate. \href{http://jee3.web.rice.edu/interaction-overconfidence.pdf}{download}
 #'              \item Fox J (2003) Effect displays in R for generalised linear models. Journal of Statistical Software 8:15, 127, \href{http://www.jstatsoft.org/v08/i15/}{<http://www.jstatsoft.org/v08/i15/>}
 #'              \item Hayes AF (2012) PROCESS: A versatile computational tool for observed variable mediation, moderation, and conditional process modeling [White paper] \href{http://imaging.mrc-cbu.cam.ac.uk/statswiki/FAQ/SobelTest?action=AttachFile&do=get&target=process.pdf}{download}

---FILE: man/sjp.int.Rd---
@@ -349,7 +349,7 @@ sjp.int(fit, type = ""eff"", int.plot.index = 3, show.ci = TRUE, facet.grid = TRUE
 \references{
 \itemize{
              \item Aiken and West (1991). Multiple Regression: Testing and Interpreting Interactions.
-             \item Brambor T, Clark WR and Golder M (2006) Understanding Interaction Models: Improving Empirical Analyses. Political Analysis 14: 63-82. \doi{10.1093/pan/mpi014}
+             \item Brambor T, Clark WR and Golder M (2006) Understanding Interaction Models: Improving Empirical Analyses. Political Analysis 14: 63-82. \href{https://academic.oup.com/pan/article/14/1/63/1501303/Understanding-Interaction-Models-Improving}{download}
              \item Esarey J, Sumner JL (2015) Marginal Effects in Interaction Models: Determining and Controlling the False Positive Rate. \href{http://jee3.web.rice.edu/interaction-overconfidence.pdf}{download}
              \item Fox J (2003) Effect displays in R for generalised linear models. Journal of Statistical Software 8:15, 127, \href{http://www.jstatsoft.org/v08/i15/}{<http://www.jstatsoft.org/v08/i15/>}
              \item Hayes AF (2012) PROCESS: A versatile computational tool for observed variable mediation, moderation, and conditional process modeling [White paper] \href{http://imaging.mrc-cbu.cam.ac.uk/statswiki/FAQ/SobelTest?action=AttachFile&do=get&target=process.pdf}{download}

---FILE: vignettes/sjpglm.Rmd---
@@ -67,7 +67,7 @@ sjp.glm(fit)
 
 ## Continuous values at the axis
 
-Due to the log-scaling of the x-axis - which should be done when plotting odds ratios (see [here](http://aje.oxfordjournals.org/content/early/2011/06/29/aje.kwr156.long) and [here](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC1127651/)) - the x-axis values have an exponential growth. However, you can transform the ticks with `trns.ticks` (defaults to `TRUE`) to get proportional distances between the values. The x-axis-tick marks are set accordingly.
+Due to the log-scaling of the x-axis - which should be done when plotting odds ratios (see [here](https://academic.oup.com/aje/article/174/3/376/247288/Should-Graphs-of-Risk-or-Rate-Ratios-be-Plotted-on) and [here](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC1127651/)) - the x-axis values have an exponential growth. However, you can transform the ticks with `trns.ticks` (defaults to `TRUE`) to get proportional distances between the values. The x-axis-tick marks are set accordingly.
 
 ```{r}
 sjp.glm(fit, trns.ticks = FALSE)"
strengejacke,sjPlot,9c6b0d424409fa15c77b64970af6dee33884b716,Daniel Ldecke,d.luedecke@uke.de,2017-01-24T16:34:57Z,Daniel Ldecke,d.luedecke@uke.de,2017-01-24T16:34:57Z,Fix CRAN issues,R/sjPlotPCA.R;R/sjTabOdds.R;man/sjt.glm.Rd,False,True,True,False,32,18,50,"---FILE: R/sjPlotPCA.R---
@@ -382,7 +382,7 @@ sjp.pca <- function(data,
   # return structure with various results
   # --------------------------------------------------------
   invisible(structure(class = ""sjcpca"",
-                      list(varim = pcadata.varim,
+                      list(varim = pcadata.rotate,
                            removed.colindex = removableItems,
                            removed.df = remdf,
                            factor.index = factorindex,

---FILE: R/sjTabOdds.R---
@@ -45,11 +45,13 @@
 #'            }
 #'            for further use.
 #'
-#' @note Standard errors for generalized linear (mixed) models are \emph{not} 
-#'       the regular standard errors on the untransformed scale, as shown in the
-#'       \code{summary()}-method. Rather, \code{sjt.glm()} uses adjustments 
-#'       according to the delta method for approximating standard errors of 
-#'       transformed regression parameters (see \code{\link[sjstats]{se}}).
+#' @note If \code{exp.coef = TRUE} and Odds Ratios are reported, standard errors 
+#'       for generalized linear (mixed) models are \emph{not} on the untransformed 
+#'       scale, as shown in the \code{summary()}-method. Rather, \code{sjt.glm()} 
+#'       uses adjustments according to the delta method for approximating standard 
+#'       errors of transformed regression parameters (see \code{\link[sjstats]{se}}).
+#'       If \code{exp.coef = FALSE} and log-Odds Ratios are reported, the standard
+#'       errors are untransformed.
 #'       \cr \cr Futhermore, see 'Notes' in \code{\link{sjt.frq}}.
 #'
 #' @details See 'Details' in \code{\link{sjt.frq}}.
@@ -313,14 +315,24 @@ sjt.glm <- function(...,
       fit.df <- sjstats::robust(fit, conf.int = T, exponentiate = F) %>% 
         dplyr::select_(""-statistic"")
     } else {
-      fit.df <- broom::tidy(fit, effects = ""fixed"", conf.int = T) %>% 
-        # remove non-transformed standard error
-        dplyr::select_(""-statistic"", ""-std.error"") %>% 
-        # get adjusted standard errors
-        dplyr::mutate(std.error = sjstats::se(fit)[[""std.error""]])
+      # get tidy output
+      fit.df <- broom::tidy(fit, effects = ""fixed"", conf.int = T)
       
-      # reorder df
-      fit.df <- fit.df[, c(1:2, 6, 3:5)]
+      # check if coefficients should be exponentiated - if yes,
+      # also retrieve adjusted standard errors
+      if (exp.coef) {
+        fit.df <- fit.df %>% 
+          # remove non-transformed standard error
+          dplyr::select_(""-statistic"", ""-std.error"") %>% 
+          # and add adjusted standard errors
+          dplyr::mutate(std.error = sjstats::se(fit)[[""std.error""]])
+        
+        # reorder df
+        fit.df <- fit.df[, c(1:2, 6, 3:5)]
+      } else {
+        # just remove test statistics
+        fit.df <- dplyr::select_(fit.df, ""-statistic"")
+      }
     }
     # -------------------------------------
     # write data to data frame. we need names of

---FILE: man/sjt.glm.Rd---
@@ -218,11 +218,13 @@ Summarizes (multiple) fitted generalized linear models (odds ratios, ci, p-value
 See 'Details' in \code{\link{sjt.frq}}.
 }
 \note{
-Standard errors for generalized linear (mixed) models are \emph{not} 
-      the regular standard errors on the untransformed scale, as shown in the
-      \code{summary()}-method. Rather, \code{sjt.glm()} uses adjustments 
-      according to the delta method for approximating standard errors of 
-      transformed regression parameters (see \code{\link[sjstats]{se}}).
+If \code{exp.coef = TRUE} and Odds Ratios are reported, standard errors 
+      for generalized linear (mixed) models are \emph{not} on the untransformed 
+      scale, as shown in the \code{summary()}-method. Rather, \code{sjt.glm()} 
+      uses adjustments according to the delta method for approximating standard 
+      errors of transformed regression parameters (see \code{\link[sjstats]{se}}).
+      If \code{exp.coef = FALSE} and log-Odds Ratios are reported, the standard
+      errors are untransformed.
       \cr \cr Futhermore, see 'Notes' in \code{\link{sjt.frq}}.
 }
 \examples{"
strengejacke,sjPlot,1c1de68b0fb5834473dccf97b884c8a6b17ec92a,Daniel Ldecke,d.luedecke@uke.de,2017-01-23T21:17:36Z,Daniel Ldecke,d.luedecke@uke.de,2017-01-23T21:17:36Z,fix CRAN check issues,R/sjPlotPCA.R,False,True,True,False,1,1,2,"---FILE: R/sjPlotPCA.R---
@@ -292,7 +292,7 @@ sjp.pca <- function(data,
   # convert to long data
   df <- tidyr::gather(df, ""xpos"", ""value"", seq_len(ncol(df)), factor_key = TRUE)  
   # we need new columns for y-positions and point sizes
-  df <- cbind(df, ypos = seq_len(nrow(pcadata.varim$loadings)), psize = exp(abs(df$value)) * geom.size)
+  df <- cbind(df, ypos = seq_len(nrow(pcadata.rotate$loadings)), psize = exp(abs(df$value)) * geom.size)
   if (!show.values) {
     valueLabels <- """"
   } else {"
strengejacke,sjPlot,6fe97ad656fedadf673f4740212918d5eb377a5c,Daniel Ldecke,d.luedecke@uke.de,2017-01-22T23:09:18Z,Daniel Ldecke,d.luedecke@uke.de,2017-01-22T23:09:18Z,`sjp.kfold_cv()` now also supports poisson and negative binomial regression models.,DESCRIPTION;NAMESPACE;NEWS;NEWS.md;R/sjPlotClusterAnalysis.R;R/sjPlotKfoldCV.R;man/sjp.kfold_cv.Rd,False,True,True,False,119,70,189,"---FILE: DESCRIPTION---
@@ -27,6 +27,7 @@ Imports:
     effects,
     ggplot2 (>= 2.2.0),
     lme4 (>= 1.1-10),
+    MASS,
     merTools (>= 0.3.0),
     modelr,
     nlme,
@@ -46,8 +47,7 @@ Suggests:
     ggrepel,
     lmerTest,
     lmtest,
-    lsmeans,
-    MASS
+    lsmeans
 URL: https://github.com/sjPlot/devel
 BugReports: https://github.com/sjPlot/devel/issues
 RoxygenNote: 5.0.1

---FILE: NAMESPACE---
@@ -52,6 +52,8 @@ export(sjt.xtab)
 export(sjtab)
 export(view_df)
 import(ggplot2)
+importFrom(MASS,glm.nb)
+importFrom(MASS,lda)
 importFrom(broom,augment)
 importFrom(broom,tidy)
 importFrom(dplyr,""%>%"")
@@ -191,6 +193,7 @@ importFrom(stats,nobs)
 importFrom(stats,pchisq)
 importFrom(stats,pf)
 importFrom(stats,pnorm)
+importFrom(stats,poisson)
 importFrom(stats,ppoints)
 importFrom(stats,prcomp)
 importFrom(stats,predict)

---FILE: NEWS---
@@ -1,6 +1,7 @@
 Version 2.2.2
 -----------------------------------------------------------------------------
 Changes to functions:
+* `sjp.kfold_cv()` now also supports poisson and negative binomial regression models.
 * `sjp.pca()` and `sjt.pca()` get a `rotation`-argument, to use either varimax- or oblimin-transformation of factor loadings.
 * Argument `show.value` now also applies to bar plots in `sjp.pca()`. 
 * `sjt.glm()`, for generalized linar (mixed) models, now shows adjusted standard errors, using the Taylor serie-based delta method. 

---FILE: NEWS.md---
@@ -2,6 +2,7 @@
 
 ## Changes to functions
 
+* `sjp.kfold_cv()` now also supports poisson and negative binomial regression models.
 * `sjp.pca()` and `sjt.pca()` get a `rotation`-argument, to use either varimax- or oblimin-transformation of factor loadings.
 * Argument `show.value` now also applies to bar plots in `sjp.pca()`. 
 * `sjt.glm()`, for generalized linar (mixed) models, now shows adjusted standard errors, using the Taylor serie-based delta method. 

---FILE: R/sjPlotClusterAnalysis.R---
@@ -258,7 +258,7 @@ sjc.qclus <- function(data,
     gp <- ggplot(df, aes(x = rev(x), y = y, fill = group))
     axis.labels <- rev(axis.labels)
   } else {
-    gp <- ggplot(df, aes(x = x, y = y, fill = group))
+    gp <- ggplot(df, aes_string(x = ""x"", y = ""y"", fill = ""group""))
   }
   gp <- gp +
     geom_bar(stat = ""identity"", 
@@ -537,15 +537,10 @@ sjc.dend <- function(data, groupcount, distance = ""euclidean"", agglomeration = ""
 #' 
 #' @importFrom stats na.omit
 #' @importFrom graphics plot
+#' @importFrom MASS lda
 #' @import ggplot2
 #' @export
 sjc.grpdisc <- function(data, groups, groupcount, clss.fit = TRUE, prnt.plot = TRUE) {
-  # -----------------------------------
-  # check package availability
-  # -----------------------------------
-  if (!requireNamespace(""MASS"", quietly = TRUE)) {
-    stop(""Package `MASS` needed for this function to work. Please install it."", call. = F)
-  }
   # Prepare Data
   # listwise deletion of missing
   data <- stats::na.omit(data)

---FILE: R/sjPlotKfoldCV.R---
@@ -10,25 +10,28 @@ utils::globalVariables(c(""train"", ""model"", ""test"", "".response"", ""sse"", ""sst""))
 #'
 #' @param data A data frame, used to split the data into \code{k} trainig-test-pairs.
 #' @param formula A model formula, used to fit linear models (\code{\link[stats]{lm}})
-#'          over all \code{k} training data sets.
+#'          over all \code{k} training data sets. Use \code{fit} to specify a 
+#'          fitted model (also other models than linear models), which will be used
+#'          to compute cross validation. If \code{fit} is not missing, \code{formula}
+#'          will be ignored.
 #' @param k Number of folds.
+#' @param fit Model object, which will be used to compute cross validation. If 
+#'          \code{fit} is not missing, \code{formula} will be ignored. Currently,
+#'          only linear, poisson and negative binomial regression models are supported.
 #'
 #' @details This function, first, generates \code{k} cross-validated test-training
 #'            pairs (using the \code{\link[modelr]{crossv_kfold}}-function) and
-#'            fits the same linear model, specified in the \code{formula}-argument,
-#'            over all training data sets. \cr \cr
-#'            Then, the quality measures Root Mean Squared Error (\emph{rmse}),
-#'            R-squared and Mean Squared Error (\emph{mse}) for each model are 
-#'            calculated. The average for each of these measures is returned 
-#'            from this function. \cr \cr
-#'            Finally, the test data is used to predict the outcome from all
+#'            fits the same model, specified in the \code{formula}- or \code{fit}-
+#'            argument, over all training data sets. \cr \cr
+#'            Then, the test data is used to predict the outcome from all
 #'            models that have been fit on the training data, and the residuals
 #'            from all test data is plotted against the observed values (outcome)
-#'            from the test data. This plot can be used to validate the model
+#'            from the test data (note: for poisson or negative binomial models, the
+#'            deviance residuals are calculated). This plot can be used to validate the model
 #'            and see, whether it over- (residuals > 0) or underestimates 
 #'            (residuals < 0) the model's outcome.
 #'
-#' @note Currently, only linear models are supported.
+#' @note Currently, only linear, poisson and negative binomial regression models are supported.
 #'
 #' @examples 
 #' library(sjmisc)
@@ -37,6 +40,14 @@ utils::globalVariables(c(""train"", ""model"", ""test"", "".response"", ""sse"", ""sst""))
 #' sjp.kfold_cv(efc, neg_c_7 ~ e42dep + c172code + c12hour)
 #' sjp.kfold_cv(mtcars, mpg ~.)
 #'
+#' # for poisson models. need to fit a model and use 'fit'-argument
+#' fit <- glm(tot_sc_e ~ neg_c_7 + c172code, data = efc, family = poisson)
+#' sjp.kfold_cv(efc, fit = fit)
+#' 
+#' # and for negative binomial models
+#' fit <- MASS::glm.nb(tot_sc_e ~ neg_c_7 + c172code, data = efc)
+#' sjp.kfold_cv(efc, fit = fit)
+#'
 #' @import ggplot2
 #' @importFrom tibble is.tibble as_tibble
 #' @importFrom sjmisc get_label
@@ -46,46 +57,79 @@ utils::globalVariables(c(""train"", ""model"", ""test"", "".response"", ""sse"", ""sst""))
 #' @importFrom broom augment
 #' @importFrom tidyr unnest
 #' @importFrom graphics plot
-#' @importFrom stats as.formula
+#' @importFrom stats as.formula formula family poisson glm lm
+#' @importFrom sjstats resp_val
+#' @importFrom purrr map
+#' @importFrom MASS glm.nb
 #' @export
-sjp.kfold_cv <- function(data, formula, k = 5) {
+sjp.kfold_cv <- function(data, formula, k = 5, fit) {
   # make sure that data is a tibble
   if (!tibble::is.tibble(data)) data <- tibble::as_tibble(data)
   
-  # make sure we have a formula
-  if (!inherits(formula, ""formula"")) formula <- stats::as.formula(formula)
+  # check if a formula was passed as argument...
+  if (!missing(formula)) {
+    # make sure we have a formula
+    if (!inherits(formula, ""formula"")) formula <- stats::as.formula(formula)
+    # reset fam
+    fam <- NULL
+  } else if (!missing(fit)) {
+    # ... or a fitted model
+    formula <- stats::formula(fit)
+    
+    # get model family for glm
+    if (inherits(fit, ""glm""))
+      fam <- stats::family(fit)
+    else
+      fam <- NULL
+  } else {
+    stop(""Either `formula` or `fit` must be supplied."", call. = F)
+  }
   
   # get name of response variable and get variable label, if
   # there is any... used for labelling plot axis
   resp <- formula[[2]]
   resp.name <- sjmisc::get_label(data[[deparse(resp)]], def.value = deparse(resp))
-    
-  # create cross-validated test-training pairs, run linear model on each
-  # pair, get predicted values and quality measures for models fitted on the
-  # train data
-  res <- modelr::crossv_kfold(data, k = k) %>% 
-    dplyr::mutate(model = purrr::map(train, ~ lm(formula, data = .))) %>% 
-    dplyr::mutate(predicted = purrr::map2(model, test, ~ broom::augment(.x, newdata = .y))) %>% 
-    tidyr::unnest(predicted)
 
-  # make sure that response vector has an identifiably name
-  colnames(res)[which(colnames(res) == deparse(resp))] <- "".response""
-
-  # compute residuals for each k-fold model
-  res <- res %>% 
-    dplyr::mutate(residuals = .response - .fitted)
-  
-  # compute model quality measures r2 and rmse
-  gof <- res %>% 
-    dplyr::group_by_("".id"") %>% 
-    dplyr::summarise(
-      sst = sum((.response - mean(.response, na.rm = T)) ^ 2, na.rm = T), # Sum of Squares Total
-      sse = sum(residuals ^ 2, na.rm = T),                                # Sum of Squares Residual/Error
-      rsquared = 1 - sse / sst,                                           # Proportion of variance accounted for
-      rmse = sqrt(mean(residuals ^ 2, na.rm = T))
-    ) %>% 
-    dplyr::ungroup()
-  
+  # check if fit parameter was specified, and we have a model family
+  if (!is.null(fam)) {
+    # for poisson models, show deviance residuals
+    if (fam$family == ""poisson"") {
+      # create cross-validated test-training pairs, run poisson-model on each
+      # pair, get deviance residuals and response value
+      res <- modelr::crossv_kfold(data, k = k) %>% 
+        dplyr::mutate(model = purrr::map(train, ~ stats::glm(formula, data = .x, family = stats::poisson(link = ""log"")))) %>% 
+        dplyr::mutate(residuals = purrr::map(model, ~ stats::residuals(.x, ""deviance""))) %>% 
+        dplyr::mutate(.response = purrr::map(model, ~ sjstats::resp_val(.x)))
+    # for negative binomial models, show deviance residuals
+    } else if (inherits(fit, ""negbin"")) {
+      # create cross-validated test-training pairs, run poisson-model on each
+      # pair, get deviance residuals and response value
+      res <- modelr::crossv_kfold(data, k = k) %>% 
+        dplyr::mutate(model = purrr::map(train, ~ MASS::glm.nb(formula, data = .))) %>% 
+        dplyr::mutate(residuals = purrr::map(model, ~ stats::residuals(.x, ""deviance""))) %>% 
+        dplyr::mutate(.response = purrr::map(model, ~ sjstats::resp_val(.x)))
+    }
+    
+    # unnest residuals and response values
+    res <- res %>% tidyr::unnest(residuals, .response)
+    
+  } else {
+    # create cross-validated test-training pairs, run linear model on each
+    # pair, get predicted values and quality measures for models fitted on the
+    # train data
+    res <- modelr::crossv_kfold(data, k = k) %>% 
+      dplyr::mutate(model = purrr::map(train, ~ stats::lm(formula, data = .))) %>% 
+      dplyr::mutate(predicted = purrr::map2(model, test, ~ broom::augment(.x, newdata = .y))) %>% 
+      tidyr::unnest(predicted)
+    
+    # make sure that response vector has an identifiably name
+    colnames(res)[which(colnames(res) == deparse(resp))] <- "".response""
+    
+    # compute residuals for each k-fold model
+    res <- res %>% 
+      dplyr::mutate(residuals = .response - .fitted)
+  }
+      
   # plot response against residuals, to see where our model over- or
   # underestimates the outcome
   p <- ggplot(data = res, aes_string(x = "".response"", y = ""residuals"")) +
@@ -94,18 +138,11 @@ sjp.kfold_cv <- function(data, formula, k = 5) {
     stat_smooth(method = ""loess"") +
     theme_minimal() +
     labs(y = ""Residuals"", x = resp.name)
+  
   # plot it
-  graphics::plot(p)
-
-  # ouput of quality measures to console  
-  cat(""Quality Measures of k-Fold Cross-Validation\n"")
-  cat(sprintf(""   R-squared: %.3f\n"", mean(gof$rsquared)))
-  cat(sprintf(""        RMSE: %.3f\n"", mean(gof$rmse)))
+  suppressWarnings(graphics::plot(p))
 
   # return plot and quality measures
   invisible(structure(class = ""sjp.kfold_cv"",
-                      list(plot = p,
-                           rsquared = mean(gof$rsquared),
-                           rmse = mean(gof$rmse),
-                           mse = mean(gof$sse))))
+                      list(plot = p)))
 }

---FILE: man/sjp.kfold_cv.Rd---
@@ -4,15 +4,22 @@
 \alias{sjp.kfold_cv}
 \title{Plot model fit from k-fold cross-validation}
 \usage{
-sjp.kfold_cv(data, formula, k = 5)
+sjp.kfold_cv(data, formula, k = 5, fit)
 }
 \arguments{
 \item{data}{A data frame, used to split the data into \code{k} trainig-test-pairs.}
 
 \item{formula}{A model formula, used to fit linear models (\code{\link[stats]{lm}})
-over all \code{k} training data sets.}
+over all \code{k} training data sets. Use \code{fit} to specify a 
+fitted model (also other models than linear models), which will be used
+to compute cross validation. If \code{fit} is not missing, \code{formula}
+will be ignored.}
 
 \item{k}{Number of folds.}
+
+\item{fit}{Model object, which will be used to compute cross validation. If 
+\code{fit} is not missing, \code{formula} will be ignored. Currently,
+only linear, poisson and negative binomial regression models are supported.}
 }
 \description{
 This function plots the aggregated residuals of k-fold cross-validated
@@ -22,21 +29,18 @@ This function plots the aggregated residuals of k-fold cross-validated
 \details{
 This function, first, generates \code{k} cross-validated test-training
            pairs (using the \code{\link[modelr]{crossv_kfold}}-function) and
-           fits the same linear model, specified in the \code{formula}-argument,
-           over all training data sets. \cr \cr
-           Then, the quality measures Root Mean Squared Error (\emph{rmse}),
-           R-squared and Mean Squared Error (\emph{mse}) for each model are 
-           calculated. The average for each of these measures is returned 
-           from this function. \cr \cr
-           Finally, the test data is used to predict the outcome from all
+           fits the same model, specified in the \code{formula}- or \code{fit}-
+           argument, over all training data sets. \cr \cr
+           Then, the test data is used to predict the outcome from all
            models that have been fit on the training data, and the residuals
            from all test data is plotted against the observed values (outcome)
-           from the test data. This plot can be used to validate the model
+           from the test data (note: for poisson or negative binomial models, the
+           deviance residuals are calculated). This plot can be used to validate the model
            and see, whether it over- (residuals > 0) or underestimates 
            (residuals < 0) the model's outcome.
 }
 \note{
-Currently, only linear models are supported.
+Currently, only linear, poisson and negative binomial regression models are supported.
 }
 \examples{
 library(sjmisc)
@@ -45,5 +49,13 @@ data(efc)
 sjp.kfold_cv(efc, neg_c_7 ~ e42dep + c172code + c12hour)
 sjp.kfold_cv(mtcars, mpg ~.)
 
+# for poisson models. need to fit a model and use 'fit'-argument
+fit <- glm(tot_sc_e ~ neg_c_7 + c172code, data = efc, family = poisson)
+sjp.kfold_cv(efc, fit = fit)
+
+# and for negative binomial models
+fit <- MASS::glm.nb(tot_sc_e ~ neg_c_7 + c172code, data = efc)
+sjp.kfold_cv(efc, fit = fit)
+
 }
 "
strengejacke,sjPlot,e6ce301bedb82326d527251acd6041b79db06343,Daniel Ldecke,d.luedecke@uke.de,2017-01-17T21:56:25Z,Daniel Ldecke,d.luedecke@uke.de,2017-01-17T21:56:25Z,"`sjt.glm()`, for generalized linar models, now shows adjusted standard errors, using the Taylor serie-based delta method.",NEWS;NEWS.md;R/sjTabOdds.R;man/sjt.glm.Rd,False,True,True,False,26,6,32,"---FILE: NEWS---
@@ -3,6 +3,7 @@ Version 2.2.2
 Changes to functions:
 * `sjp.pca()` and `sjt.pca()` get a `rotation`-argument, to use either varimax- or oblimin-transformation of factor loadings.
 * Argument `show.value` now also applies to bar plots in `sjp.pca()`. 
+* `sjt.glm()`, for generalized linar models, now shows adjusted standard errors, using the Taylor serie-based delta method. 
 
 Bug fixes:
 * Plotting or table output of regression models did not work with null-models (i.e. with intercept only).

---FILE: NEWS.md---
@@ -4,6 +4,7 @@
 
 * `sjp.pca()` and `sjt.pca()` get a `rotation`-argument, to use either varimax- or oblimin-transformation of factor loadings.
 * Argument `show.value` now also applies to bar plots in `sjp.pca()`. 
+* `sjt.glm()`, for generalized linar models, now shows adjusted standard errors, using the Taylor serie-based delta method. 
 
 ## Bug fixes
 

---FILE: R/sjTabOdds.R---
@@ -45,7 +45,10 @@
 #'            }
 #'            for further use.
 #'
-#' @note See 'Notes' in \code{\link{sjt.frq}}.
+#' @note Standard errors for generalized linear models are adjusted according to
+#'       the delta method for approximating standard error of transformed 
+#'       regression parameters (see \code{\link[sjstats]{se}}).
+#'       \cr \cr Futhermore, see 'Notes' in \code{\link{sjt.frq}}.
 #'
 #' @details See 'Details' in \code{\link{sjt.frq}}.
 #'
@@ -160,10 +163,11 @@
 #' # print models with different predictors
 #' sjt.glm(fit, fit2, fit3, group.pred = FALSE)}
 #'
-#' @importFrom dplyr full_join slice
+#' @importFrom dplyr full_join slice mutate
 #' @importFrom stats nobs AIC confint coef logLik family deviance
-#' @importFrom sjstats std_beta icc r2 cod chisq_gof hoslem_gof
+#' @importFrom sjstats std_beta icc r2 cod chisq_gof hoslem_gof se
 #' @importFrom tibble lst
+#' @importFrom broom tidy
 #' @export
 sjt.glm <- function(...,
                     pred.labels = NULL,
@@ -307,8 +311,19 @@ sjt.glm <- function(...,
       fit.df <- sjstats::robust(fit, conf.int = T, exponentiate = F) %>% 
         dplyr::select_(""-statistic"")
     } else {
-      fit.df <- broom::tidy(fit, effects = ""fixed"", conf.int = T) %>% 
-        dplyr::select_(""-statistic"")
+      if (is_merMod(fit)) {
+        fit.df <- broom::tidy(fit, effects = ""fixed"", conf.int = T) %>% 
+          dplyr::select_(""-statistic"")
+      } else {
+        fit.df <- broom::tidy(fit, effects = ""fixed"", conf.int = T) %>% 
+          # remove non-transformed standard error
+          dplyr::select_(""-statistic"", ""-std.error"") %>% 
+          # get adjusted standard errors
+          dplyr::mutate(std.error = sjstats::se(fit)[[""or.se""]])
+        
+        # reorder df
+        fit.df <- fit.df[, c(1:2, 6, 3:5)]
+      }
     }
     # -------------------------------------
     # write data to data frame. we need names of

---FILE: man/sjt.glm.Rd---
@@ -218,7 +218,10 @@ Summarizes (multiple) fitted generalized linear models (odds ratios, ci, p-value
 See 'Details' in \code{\link{sjt.frq}}.
 }
 \note{
-See 'Notes' in \code{\link{sjt.frq}}.
+Standard errors for generalized linear models are adjusted according to
+      the delta method for approximating standard error of transformed 
+      regression parameters (see \code{\link[sjstats]{se}}).
+      \cr \cr Futhermore, see 'Notes' in \code{\link{sjt.frq}}.
 }
 \examples{
 # prepare dummy variables for binary logistic regression"
strengejacke,sjPlot,5d0cf7cd3a64f18e910314933f996b427816c2b1,Daniel Ldecke,d.luedecke@uke.de,2017-01-13T16:21:50Z,Daniel Ldecke,d.luedecke@uke.de,2017-01-13T16:21:50Z,Plotting or table output of regression models did not work with null-models (i.e. with intercept only).,NEWS;NEWS.md;R/helpfunctions.R;R/sjPlotKfoldCV.R,False,True,True,False,52,38,90,"---FILE: NEWS---
@@ -1,3 +1,8 @@
+Version 2.2.2
+-----------------------------------------------------------------------------
+Bug fixes:
+* Plotting or table output of regression models did not work with null-models (i.e. with intercept only).
+
 Version 2.2.1
 -----------------------------------------------------------------------------
 Changes to functions:

---FILE: NEWS.md---
@@ -1,3 +1,9 @@
+# sjPlot 2.2.2
+
+## Bug fixes
+
+* Plotting or table output of regression models did not work with null-models (i.e. with intercept only).
+
 # sjPlot 2.2.1
 
 ## Changes to functions

---FILE: R/helpfunctions.R---
@@ -547,7 +547,7 @@ retrieveModelGroupIndices <- function(models, rem_rows = NULL) {
     else
       fmodel <- stats::model.frame(fit)
     # retrieve all factors from model
-    for (grp.cnt in 1:ncol(fmodel)) {
+    for (grp.cnt in seq_len(ncol(fmodel))) {
       # get variable
       fit.var <- fmodel[, grp.cnt]
       # is factor? and has more than two levels?
@@ -590,7 +590,7 @@ retrieveModelGroupIndices <- function(models, rem_rows = NULL) {
       # take care, while loop!
       any.found <- FALSE
       # if yes, go through all grouping row indices
-      for (i in 1:length(group.pred.rows)) {
+      for (i in seq_len(length(group.pred.rows))) {
         # if yes, check if removed row was before
         # grouped row indes
         if (length(rem_rows) > 0 && rem_rows[1] <= group.pred.rows[i]) {
@@ -648,43 +648,46 @@ retrieveModelLabels <- function(models, group.pred) {
       # get model frame
       m_f <- stats::model.frame(fit)
     }
-    # iterate coefficients (1 is intercept or response)
-    for (i in 2:ncol(m_f)) {
-      # check bounds
-      if (i <= length(coef_names)) {
-        # get predictor
-        pvar <- m_f[, i]
-        # check if we have a variable label
-        lab <- sjmisc::get_label(pvar, def.value = colnames(m_f)[i])
-        # get model coefficients' names
-        coef_name <- coef_names[i]
-        # is predictor a factor?
-        # if yes, we have this variable multiple
-        # times, so manually set value labels
-        if (is.factor(pvar)) {
-          # get amount of levels
-          pvar.len <- nlevels(pvar)
-          # get value labels, if any
-          pvar.lab <- sjmisc::get_labels(pvar)
-          # have any labels, and have we same amount of labels
-          # as factor levels?
-          if (!is.null(pvar.lab) && length(pvar.lab) == pvar.len) {
-            # create labels
-            if (group.pred && pvar.len > 2) {
-              # if predictor grouping is enabled, don't use variable labels again
-              labels.to.add <- pvar.lab[2:pvar.len]
+    # for NULL-models, we just have one column in model frame
+    if (ncol(m_f) > 1) {
+      # iterate coefficients (1 is intercept or response)
+      for (i in 2:ncol(m_f)) {
+        # check bounds
+        if (i <= length(coef_names)) {
+          # get predictor
+          pvar <- m_f[, i]
+          # check if we have a variable label
+          lab <- sjmisc::get_label(pvar, def.value = colnames(m_f)[i])
+          # get model coefficients' names
+          coef_name <- coef_names[i]
+          # is predictor a factor?
+          # if yes, we have this variable multiple
+          # times, so manually set value labels
+          if (is.factor(pvar)) {
+            # get amount of levels
+            pvar.len <- nlevels(pvar)
+            # get value labels, if any
+            pvar.lab <- sjmisc::get_labels(pvar)
+            # have any labels, and have we same amount of labels
+            # as factor levels?
+            if (!is.null(pvar.lab) && length(pvar.lab) == pvar.len) {
+              # create labels
+              if (group.pred && pvar.len > 2) {
+                # if predictor grouping is enabled, don't use variable labels again
+                labels.to.add <- pvar.lab[2:pvar.len]
+              } else {
+                # else, if we have not grouped predictors, we have no headin
+                # with variable label, hence, factor levels may not be intuitiv.
+                # thus, add variable label so values have a meaning
+                labels.to.add <- sprintf(""%s (%s)"", lab, pvar.lab[2:pvar.len])
+              }
+              fit.labels <- c(fit.labels, labels.to.add)
             } else {
-              # else, if we have not grouped predictors, we have no headin
-              # with variable label, hence, factor levels may not be intuitiv.
-              # thus, add variable label so values have a meaning
-              labels.to.add <- sprintf(""%s (%s)"", lab, pvar.lab[2:pvar.len])
+              fit.labels <- c(fit.labels, coef_name)
             }
-            fit.labels <- c(fit.labels, labels.to.add)
           } else {
-            fit.labels <- c(fit.labels, coef_name)
+            if (!any(fit.labels == lab)) fit.labels <- c(fit.labels, lab)
           }
-        } else {
-          if (!any(fit.labels == lab)) fit.labels <- c(fit.labels, lab)
         }
       }
     }

---FILE: R/sjPlotKfoldCV.R---
@@ -82,7 +82,7 @@ sjp.kfold_cv <- function(data, formula, k = 5) {
       sst = sum((.response - mean(.response, na.rm = T)) ^ 2, na.rm = T), # Sum of Squares Total
       sse = sum(residuals ^ 2, na.rm = T),                                # Sum of Squares Residual/Error
       rsquared = 1 - sse / sst,                                           # Proportion of variance accounted for
-      rmse = sqrt(mean(residuals ^ 2, na.rm = T))                         # Root Mean Squared Error
+      rmse = sqrt(mean(residuals ^ 2, na.rm = T))
     ) %>% 
     dplyr::ungroup()
   
@@ -100,8 +100,8 @@ sjp.kfold_cv <- function(data, formula, k = 5) {
   # ouput of quality measures to console  
   cat(""Quality Measures of k-Fold Cross-Validation\n"")
   cat(sprintf(""   R-squared: %.3f\n"", mean(gof$rsquared)))
-  cat(sprintf(""        RMSE: %.3f\n\n"", mean(gof$rmse)))
-  
+  cat(sprintf(""        RMSE: %.3f\n"", mean(gof$rmse)))
+
   # return plot and quality measures
   invisible(structure(class = ""sjp.kfold_cv"",
                       list(plot = p,"
strengejacke,sjPlot,8050e10eb235e78f7c2d11f0c1cc2e0ecdc0a01b,Daniel Ldecke,d.luedecke@uke.de,2016-12-20T21:05:18Z,Daniel Ldecke,d.luedecke@uke.de,2016-12-20T21:05:18Z,fix docs and examples,R/sjPlotGLME.R;R/sjPlotLinreg.R;R/sjPlotOdds.R;man/sjp.glm.Rd;man/sjp.glmer.Rd;man/sjp.lm.Rd;man/sjp.lmer.Rd,False,True,True,False,22,19,41,"---FILE: R/sjPlotGLME.R---
@@ -33,9 +33,8 @@ utils::globalVariables(c(""estimate"", ""nQQ"", ""ci"", ""fixef"", ""fade"", ""conf.low"", ""
 #'          }
 #' @param vars numeric vector with column indices of selected variables or a character vector with
 #'          variable names of selected variables from the fitted model, which should be used to plot
-#'          estimates, fixed effects slopes (for \code{\link[lme4]{lmer}}) or probability or
-#'          incidents curves
-#'          (for \code{\link[lme4]{glmer}}) of random intercepts.
+#'          - depending on \code{type} - estimates, fixed effects slopes or predicted values 
+#'          (mean, probabilities, incidents rates, ...). See 'Examples'.
 #' @param ri.nr numeric vector. If \code{type = ""re""} or \code{type = ""ri.slope""},
 #'          and fitted model has more than one random intercept, \code{ri.nr} indicates
 #'          which random effects of which random intercept (or: which list elements

---FILE: R/sjPlotLinreg.R---
@@ -203,7 +203,8 @@ utils::globalVariables(c(""fit"", ""vars"", ""stdbeta"", ""x"", ""ydiff"", ""y"", ""grp"", "".s
 #' library(sjmisc)
 #' data(efc)
 #' efc$education <- to_label(to_factor(efc$c172code))
-#' fit <- lm(barthtot ~ c160age + c12hour + e17age+ education,
+#' efc$gender <- to_label(to_factor(efc$c161sex))
+#' fit <- lm(barthtot ~ c160age + c12hour + e17age + gender + education,
 #'           data = efc)
 #'
 #' sjp.lm(fit, type = ""pred"", vars = ""c160age"")
@@ -218,6 +219,9 @@ utils::globalVariables(c(""fit"", ""vars"", ""stdbeta"", ""x"", ""ydiff"", ""y"", ""grp"", "".s
 #' sjp.lm(fit, type = ""pred"", vars = c(""c12hour"", ""education""),
 #'        facet.grid = FALSE)
 #' 
+#' # two groupings
+#' sjp.lm(fit, type = ""pred"", vars = c(""c12hour"", ""gender"", ""education""))
+#' 
 #' # --------------------------
 #' # plotting polynomial terms
 #' # --------------------------

---FILE: R/sjPlotOdds.R---
@@ -109,7 +109,7 @@ utils::globalVariables(c(""OR"", ""lower"", ""upper"", ""p"", ""grp.est"", ""ci.low"", ""ci.h
 #'
 #' # --------------------------
 #' # model predictions, with selected model terms.
-#' # 'vars' needs to be a character vector of length 1 or 2
+#' # 'vars' needs to be a character vector of length 1 to 3
 #' # with names of model terms for x-axis and grouping factor.
 #' # --------------------------
 #' sjp.glm(fit, type = ""pred"", vars = ""barthel"")

---FILE: man/sjp.glm.Rd---
@@ -31,9 +31,8 @@ sjp.glm(fit, type = ""dots"", vars = NULL, group.estimates = NULL,
 
 \item{vars}{numeric vector with column indices of selected variables or a character vector with
 variable names of selected variables from the fitted model, which should be used to plot
-estimates, fixed effects slopes (for \code{\link[lme4]{lmer}}) or probability or
-incidents curves
-(for \code{\link[lme4]{glmer}}) of random intercepts.}
+- depending on \code{type} - estimates, fixed effects slopes or predicted values 
+(mean, probabilities, incidents rates, ...). See 'Examples'.}
 
 \item{group.estimates}{numeric or character vector, indicating a group identifier for
 each estimate. Dots and confidence intervals of estimates are coloured
@@ -239,7 +238,7 @@ sjp.glm(fit,  group.estimates = c(1, 2, 2, 2, 3, 4, 4))
 
 # --------------------------
 # model predictions, with selected model terms.
-# 'vars' needs to be a character vector of length 1 or 2
+# 'vars' needs to be a character vector of length 1 to 3
 # with names of model terms for x-axis and grouping factor.
 # --------------------------
 sjp.glm(fit, type = ""pred"", vars = ""barthel"")

---FILE: man/sjp.glmer.Rd---
@@ -36,9 +36,8 @@ sjp.glmer(fit, type = ""re"", vars = NULL, ri.nr = NULL,
 
 \item{vars}{numeric vector with column indices of selected variables or a character vector with
 variable names of selected variables from the fitted model, which should be used to plot
-estimates, fixed effects slopes (for \code{\link[lme4]{lmer}}) or probability or
-incidents curves
-(for \code{\link[lme4]{glmer}}) of random intercepts.}
+- depending on \code{type} - estimates, fixed effects slopes or predicted values 
+(mean, probabilities, incidents rates, ...). See 'Examples'.}
 
 \item{ri.nr}{numeric vector. If \code{type = ""re""} or \code{type = ""ri.slope""},
 and fitted model has more than one random intercept, \code{ri.nr} indicates

---FILE: man/sjp.lm.Rd---
@@ -36,9 +36,8 @@ sjp.lm(fit, type = ""lm"", vars = NULL, group.estimates = NULL,
 
 \item{vars}{numeric vector with column indices of selected variables or a character vector with
 variable names of selected variables from the fitted model, which should be used to plot
-estimates, fixed effects slopes (for \code{\link[lme4]{lmer}}) or probability or
-incidents curves
-(for \code{\link[lme4]{glmer}}) of random intercepts.}
+- depending on \code{type} - estimates, fixed effects slopes or predicted values 
+(mean, probabilities, incidents rates, ...). See 'Examples'.}
 
 \item{group.estimates}{numeric or character vector, indicating a group identifier for
 each estimate. Dots and confidence intervals of estimates are coloured
@@ -314,7 +313,8 @@ sjp.lm(fit, group.estimates = c(1, 2, 1, 3, 4, 3),
 library(sjmisc)
 data(efc)
 efc$education <- to_label(to_factor(efc$c172code))
-fit <- lm(barthtot ~ c160age + c12hour + e17age+ education,
+efc$gender <- to_label(to_factor(efc$c161sex))
+fit <- lm(barthtot ~ c160age + c12hour + e17age + gender + education,
           data = efc)
 
 sjp.lm(fit, type = ""pred"", vars = ""c160age"")
@@ -329,6 +329,9 @@ sjp.lm(fit, type = ""pred"", vars = c(""c12hour"", ""education""))
 sjp.lm(fit, type = ""pred"", vars = c(""c12hour"", ""education""),
        facet.grid = FALSE)
 
+# two groupings
+sjp.lm(fit, type = ""pred"", vars = c(""c12hour"", ""gender"", ""education""))
+
 # --------------------------
 # plotting polynomial terms
 # --------------------------

---FILE: man/sjp.lmer.Rd---
@@ -42,9 +42,8 @@ sjp.lmer(fit, type = ""re"", vars = NULL, ri.nr = NULL,
 
 \item{vars}{numeric vector with column indices of selected variables or a character vector with
 variable names of selected variables from the fitted model, which should be used to plot
-estimates, fixed effects slopes (for \code{\link[lme4]{lmer}}) or probability or
-incidents curves
-(for \code{\link[lme4]{glmer}}) of random intercepts.}
+- depending on \code{type} - estimates, fixed effects slopes or predicted values 
+(mean, probabilities, incidents rates, ...). See 'Examples'.}
 
 \item{ri.nr}{numeric vector. If \code{type = ""re""} or \code{type = ""ri.slope""},
 and fitted model has more than one random intercept, \code{ri.nr} indicates"
strengejacke,sjPlot,185654212d59a23d1f4cc465f0936859909f1157,Daniel Ldecke,d.luedecke@uke.de,2016-12-18T13:59:16Z,Daniel Ldecke,d.luedecke@uke.de,2016-12-18T13:59:16Z,fix news,NEWS;NEWS.md,False,False,False,False,2,0,2,"---FILE: NEWS---
@@ -5,6 +5,7 @@ New Functions:
 
 Changes to functions:
 * For `sjp.glm()` and `sjp.glmer()`, `type = ""pred""`, `type = ""slope""`, `type = ""pred.fe""` and `type = ""fe.slope""` can now also plot data points when `scatter.plot = TRUE`. Use `point.alpha` to adjust alpha-level of data points.
+* For `sjp.glm()` and `sjp.glmer()`, `type = ""pred""` and `type = ""pred.fe""` now accept three variables for the `vars`-argument, to facet grouped predictions by a third variable.
 * For `sjp.lm()`, `sjp.lmer()`, `sjp.glm()` and `sjp.glmer()`, `type = ""pred""` and `type = ""pred.fe""` now plot error bars for `show.ci = TRUE` and a discrete variable on the x-axis.
 * For `sjp.lm()`, `sjp.lmer()`, `sjp.glm()` and `sjp.glmer()`, the `...`-ellipses argument now is also passed down to all errorbars- and smooth-geoms in prediction- and effect-plots, so you can now use the `width`-argument to show the small stripes at the lower/upper end of the error bars, and the `alpha`-argument to define alpha-level of confidence bands.
 * Effect-plots (`type = ""eff""`) now plot data points for discrete variables on the x-axis.

---FILE: NEWS.md---
@@ -8,6 +8,7 @@
 
 * For `sjp.glm()` and `sjp.glmer()`, `type = ""pred""`, `type = ""slope""`, `type = ""pred.fe""` and `type = ""fe.slope""` can now also plot data points when `scatter.plot = TRUE`. Use `point.alpha` to adjust alpha-level of data points.
 * For `sjp.lm()`, `sjp.lmer()`, `sjp.glm()` and `sjp.glmer()`, `type = ""pred""` and `type = ""pred.fe""` now plot error bars for `show.ci = TRUE` and a discrete variable on the x-axis.
+* For `sjp.glm()` and `sjp.glmer()`, `type = ""pred""` and `type = ""pred.fe""` now accept three variables for the `vars`-argument, to facet grouped predictions by a third variable.
 * For `sjp.lm()`, `sjp.lmer()`, `sjp.glm()` and `sjp.glmer()`, the `...`-ellipses argument now is also passed down to all errorbars- and smooth-geoms in prediction- and effect-plots, so you can now use the `width`-argument to show the small stripes at the lower/upper end of the error bars, and the `alpha`-argument to define alpha-level of confidence bands.
 * Effect-plots (`type = ""eff""`) now plot data points for discrete variables on the x-axis.
 * `sjt.lm()` and `sjt.glm()` get a `robust`-argument to compute robust standard errors and confidence intervals."
strengejacke,sjPlot,6c8be767e93570daf90d2321228e1b540dfd9bf3,Daniel Ldecke,d.luedecke@uke.de,2016-12-16T15:24:47Z,Daniel Ldecke,d.luedecke@uke.de,2016-12-16T15:24:47Z,"close #177

* For `sjp.lm()`, `sjp.lmer()`, `sjp.glm()` and `sjp.glmer()`, `type =
""pred""` and `type = ""pred.fe""` now plot error bars for `show.ci = TRUE`
and a discrete variable on the x-axis.
* For `sjp.lm()`, `sjp.lmer()`, `sjp.glm()` and `sjp.glmer()`, the
`...`-ellipses argument now is also passed down to all errorbars-geoms
in prediction- and effect-plots, so you can now use the
`width`-argument to show the small stripes at the lower/upper end of
the error bars.
* Effect-plots (`type = ""eff""`) now plot data points for discrete
variables on the x-axis.",DESCRIPTION;NAMESPACE;NEWS;NEWS.md;R/sjPlotGLME.R;R/sjPlotInteractions.R;R/sjPlotLinreg.R;R/sjPlotOdds.R;man/sjp.glm.Rd;man/sjp.glmer.Rd;man/sjp.int.Rd;man/sjp.lm.Rd;man/sjp.lmer.Rd,False,True,True,False,241,73,314,"---FILE: DESCRIPTION---
@@ -27,6 +27,7 @@ Imports:
     effects,
     ggplot2 (>= 2.2.0),
     lme4 (>= 1.1-10),
+    merTools (>= 0.3.0),
     modelr,
     nlme,
     psych,

---FILE: NAMESPACE---
@@ -92,6 +92,7 @@ importFrom(lme4,confint.merMod)
 importFrom(lme4,fixef)
 importFrom(lme4,getME)
 importFrom(lme4,ranef)
+importFrom(merTools,predictInterval)
 importFrom(methods,is)
 importFrom(modelr,crossv_kfold)
 importFrom(nlme,getCovariateFormula)

---FILE: NEWS---
@@ -5,6 +5,9 @@ New Functions:
 
 Changes to functions:
 * For `sjp.glm()` and `sjp.glmer()`, `type = ""pred""`, `type = ""slope""`, `type = ""pred.fe""` and `type = ""fe.slope""` can now also plot data points when `scatter.plot = TRUE`. Use `point.alpha` to adjust alpha-level of data points.
+* For `sjp.lm()`, `sjp.lmer()`, `sjp.glm()` and `sjp.glmer()`, `type = ""pred""` and `type = ""pred.fe""` now plot error bars for `show.ci = TRUE` and a discrete variable on the x-axis.
+* For `sjp.lm()`, `sjp.lmer()`, `sjp.glm()` and `sjp.glmer()`, the `...`-ellipses argument now is also passed down to all errorbars-geoms in prediction- and effect-plots, so you can now use the `width`-argument to show the small stripes at the lower/upper end of the error bars.
+* Effect-plots (`type = ""eff""`) now plot data points for discrete variables on the x-axis.
 * `sjt.lm()` and `sjt.glm()` get a `robust`-argument to compute robust standard errors and confidence intervals.
 * `sjp.resid()` now also returns a plot with the residual pattern, `$pattern`.
 * Plot and axis titles from effect-plots can now be changed with `title` or `axis.title` argument. Use a character vector of length > 1 to define (axis) titles for each plot or facet; use `""""` to remove the title.

---FILE: NEWS.md---
@@ -7,6 +7,9 @@
 ## Changes to functions
 
 * For `sjp.glm()` and `sjp.glmer()`, `type = ""pred""`, `type = ""slope""`, `type = ""pred.fe""` and `type = ""fe.slope""` can now also plot data points when `scatter.plot = TRUE`. Use `point.alpha` to adjust alpha-level of data points.
+* For `sjp.lm()`, `sjp.lmer()`, `sjp.glm()` and `sjp.glmer()`, `type = ""pred""` and `type = ""pred.fe""` now plot error bars for `show.ci = TRUE` and a discrete variable on the x-axis.
+* For `sjp.lm()`, `sjp.lmer()`, `sjp.glm()` and `sjp.glmer()`, the `...`-ellipses argument now is also passed down to all errorbars-geoms in prediction- and effect-plots, so you can now use the `width`-argument to show the small stripes at the lower/upper end of the error bars.
+* Effect-plots (`type = ""eff""`) now plot data points for discrete variables on the x-axis.
 * `sjt.lm()` and `sjt.glm()` get a `robust`-argument to compute robust standard errors and confidence intervals.
 * `sjp.resid()` now also returns a plot with the residual pattern, `$pattern`.
 * Plot and axis titles from effect-plots can now be changed with `title` or `axis.title` argument. Use a character vector of length > 1 to define (axis) titles for each plot or facet; use `""""` to remove the titles.

---FILE: R/sjPlotGLME.R---
@@ -83,12 +83,14 @@ utils::globalVariables(c(""estimate"", ""nQQ"", ""ci"", ""fixef"", ""fade"", ""conf.low"", ""
 #'          Use the latter option to always select a fixed, identical set of
 #'          random effects for plotting (useful when ecomparing multiple models).
 #' @param ... other arguments, passed down to the \code{\link[effects]{effect}} resp. 
-#'          \code{\link[effects]{allEffects}} function when \code{type = ""eff""}.
+#'          \code{\link[effects]{allEffects}} function when \code{type = ""eff""},
+#'          or to ggplot-objects.
 #'
 #' @inheritParams sjp.lm
 #' @inheritParams sjp.glm
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjp.gpt
+#' @inheritParams sjp.int
 #'
 #' @return (Insisibily) returns, depending on the plot type
 #'          \itemize{
@@ -246,6 +248,7 @@ sjp.glmer <- function(fit,
                       show.values = TRUE,
                       show.p = TRUE,
                       show.ci = FALSE,
+                      jitter.ci = FALSE,                     
                       show.legend = FALSE,
                       show.intercept = FALSE,
                       string.interc = ""(Intercept)"",
@@ -299,6 +302,7 @@ sjp.glmer <- function(fit,
            free.scale,
            fade.ns,
            show.ci,
+           jitter.ci,
            FALSE,
            prnt.plot,
            fun = ""glm"",
@@ -418,6 +422,7 @@ sjp.glmer <- function(fit,
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjp.lm
 #' @inheritParams sjp.gpt
+#' @inheritParams sjp.int
 #'
 #' @return (Insisibily) returns
 #'          \itemize{
@@ -545,6 +550,7 @@ sjp.lmer <- function(fit,
                      show.values = TRUE,
                      show.p = TRUE,
                      show.ci = FALSE,
+                     jitter.ci = FALSE,                     
                      show.legend = FALSE,
                      show.loess = FALSE,
                      show.loess.ci = FALSE,
@@ -600,6 +606,7 @@ sjp.lmer <- function(fit,
            free.scale,
            fade.ns,
            show.ci,
+           jitter.ci, 
            p.kr,
            prnt.plot,
            fun = ""lm"",
@@ -640,6 +647,7 @@ sjp.lme4  <- function(fit,
                       free.scale,
                       fade.ns,
                       show.ci,
+                      jitter.ci,
                       p.kr,
                       prnt.plot,
                       fun,
@@ -848,8 +856,9 @@ sjp.lme4  <- function(fit,
     # ---------------------------------------
     return(invisible(sjp.glm.predy(fit, vars, t.title = title, l.title = legend.title,
                                    a.title = axis.title,
-                                   geom.colors, show.ci, geom.size, ylim = axis.lim, facet.grid, 
-                                   type = ""re"", scatter.plot, point.alpha, show.loess = F, prnt.plot)))
+                                   geom.colors, show.ci, jitter.ci, geom.size, ylim = axis.lim, facet.grid, 
+                                   type = ""re"", scatter.plot, point.alpha, show.loess = F, 
+                                   prnt.plot, ...)))
   } else if (type == ""pred.fe"") {
     # fix color
     if (geom.colors == ""Set1"" && length(vars) == 1) geom.colors <- ""black""
@@ -859,8 +868,9 @@ sjp.lme4  <- function(fit,
     # ---------------------------------------
     return(invisible(sjp.glm.predy(fit, vars, t.title = title, l.title = legend.title,
                                    a.title = axis.title,
-                                   geom.colors, show.ci, geom.size, ylim = axis.lim, facet.grid, 
-                                   type = ""fe"", scatter.plot, point.alpha, show.loess = F, prnt.plot)))
+                                   geom.colors, show.ci, jitter.ci, geom.size, ylim = axis.lim, facet.grid, 
+                                   type = ""fe"", scatter.plot, point.alpha, show.loess = F, 
+                                   prnt.plot, ...)))
   }
   # ------------------------
   # check if suggested package is available
@@ -2334,8 +2344,15 @@ sjp.glm.eff <- function(fit,
       eff.plot <- ggplot(mydat_sub, aes_string(x = ""x"", y = ""y""))
       # show confidence region?
       if (show.ci) {
+        
+        # get ...-argument, and check if it was ""width""
+        eb.width <- match.call(expand.dots = FALSE)$`...`[[""width""]]
+        if (is.null(eb.width)) eb.width <- 0
+        
         if (x_is_factor)
-          eff.plot <- eff.plot + geom_errorbar(aes_string(ymin = ""lower"", ymax = ""upper""), width = 0)
+          eff.plot <- eff.plot + 
+            geom_errorbar(aes_string(ymin = ""lower"", ymax = ""upper""), width = eb.width) +
+            geom_point()
         else
           eff.plot <- eff.plot + geom_ribbon(aes_string(ymin = ""lower"", ymax = ""upper""), alpha = .15)
       }

---FILE: R/sjPlotInteractions.R---
@@ -462,7 +462,7 @@ sjp.int <- function(fit,
   # the estimates of each term and the associated interaction term,
   # i.e.: y = b0 + (b1 * pred1) + (b2 * pred2) + (b3 * pred1 * pred2)
   # -----------------------------------------------------------
-  for (cnt in 1:length(intnames)) {
+  for (cnt in seq_len(length(intnames))) {
     # -----------------------------------------------------------
     # first, retrieve and split interaction term so we know
     # the two predictor variables of the interaction term
@@ -780,7 +780,7 @@ sjp.int <- function(fit,
     # prepare base plot of interactions
     # -----------------------------------------------------------
     if (diff) {
-      baseplot <- ggplot(intdf, aes(x = x, y = ydiff)) +
+      baseplot <- ggplot(intdf, aes_string(x = ""x"", y = ""ydiff"")) +
         # -----------------------------------------------------------
       # add a shaded region between minimun
       # and maximum curve of interactions
@@ -799,7 +799,7 @@ sjp.int <- function(fit,
                     show.legend = FALSE)
       }
     } else {
-      baseplot <- ggplot(intdf, aes(x = x, y = y, colour = grp))
+      baseplot <- ggplot(intdf, aes_string(x = ""x"", y = ""y"", colour = ""grp""))
       # the shaded area between line only if plots are not faceted
       if (!facet.grid) {
         baseplot <- baseplot +
@@ -1313,6 +1313,9 @@ sjp.eff.int <- function(fit,
     # confidence interval?
     # ------------------------------------------------------------
     if (show.ci) {
+      # get ...-argument, and check if it was ""width""
+      eb.width <- match.call(expand.dots = FALSE)$`...`[[""width""]]
+      if (is.null(eb.width)) eb.width <- 0
       # -------------------------------------------------
       # for factors, we add error bars instead of
       # continuous confidence region
@@ -1324,7 +1327,7 @@ sjp.eff.int <- function(fit,
         if (jitter.ci) {
           baseplot <- baseplot +
             geom_errorbar(aes_string(ymin = ""conf.low"", ymax = ""conf.high"", colour = ""grp""),
-                          width = 0, show.legend = FALSE, position = position_dodge(.2)) +
+                          width = eb.width, show.legend = FALSE, position = position_dodge(.2)) +
             geom_point(position = position_dodge(.2)) +
             geom_line(size = geom.size, position = position_dodge(.2))
           # adjust axis limits, so jittered geoms are within plot boundaries
@@ -1333,7 +1336,7 @@ sjp.eff.int <- function(fit,
         } else {
           baseplot <- baseplot +
             geom_errorbar(aes_string(ymin = ""conf.low"", ymax = ""conf.high"", colour = ""grp""),
-                          width = 0, show.legend = FALSE) +
+                          width = eb.width, show.legend = FALSE) +
             geom_point() +
             geom_line(size = geom.size)
         }

---FILE: R/sjPlotLinreg.R---
@@ -119,6 +119,7 @@ utils::globalVariables(c(""fit"", ""vars"", ""stdbeta"", ""x"", ""ydiff"", ""y"", ""grp"", "".s
 #' @inheritParams sjp.lmer
 #' @inheritParams sjp.aov1
 #' @inheritParams sjp.glmer
+#' @inheritParams sjp.int
 #'
 #' @references Gelman A (2008) ""Scaling regression inputs by dividing by two standard deviations."" \emph{Statistics in Medicine 27: 28652873.} \url{http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf}
 #'             \cr \cr
@@ -275,6 +276,7 @@ sjp.lm <- function(fit,
                    show.values = TRUE,
                    show.p = TRUE,
                    show.ci = TRUE,
+                   jitter.ci = FALSE,
                    show.legend = FALSE,
                    show.loess = FALSE,
                    show.loess.ci = FALSE,
@@ -337,9 +339,9 @@ sjp.lm <- function(fit,
   if (type == ""pred"") {
     return(invisible(sjp.glm.predy(fit, vars, t.title = title, l.title = legend.title,
                                    a.title = axis.title,
-                                   geom.colors, show.ci, geom.size, ylim = axis.lim,
+                                   geom.colors, show.ci, jitter.ci, geom.size, ylim = axis.lim,
                                    facet.grid, type = ""fe"", scatter.plot, point.alpha, 
-                                   show.loess, prnt.plot)))
+                                   show.loess, prnt.plot, ...)))
   }
   if (type == ""poly"") {
     return(invisible(sjp.lm.poly(fit, poly.term, geom.colors, geom.size, axis.title,

---FILE: R/sjPlotOdds.R---
@@ -36,6 +36,7 @@ utils::globalVariables(c(""OR"", ""lower"", ""upper"", ""p"", ""grp.est""))
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjp.aov1
 #' @inheritParams sjp.glmer
+#' @inheritParams sjp.int
 #' 
 #' @return (Insisibily) returns, depending on the plot type
 #'          \itemize{
@@ -141,6 +142,7 @@ sjp.glm <- function(fit,
                     show.values = TRUE,
                     show.p = TRUE,
                     show.ci = FALSE,
+                    jitter.ci = FALSE,
                     show.legend = FALSE,
                     show.summary = FALSE,
                     point.alpha = 0.2,
@@ -185,8 +187,9 @@ sjp.glm <- function(fit,
   if (type == ""pred"") {
     return(invisible(sjp.glm.predy(fit, vars, t.title = title, l.title = legend.title,
                                    a.title = axis.title,
-                                   geom.colors, show.ci, geom.size, ylim = axis.lim,
-                                   facet.grid, type = ""fe"", scatter.plot, point.alpha, show.loess = F, prnt.plot)))
+                                   geom.colors, show.ci, jitter.ci, geom.size, ylim = axis.lim,
+                                   facet.grid, type = ""fe"", scatter.plot, point.alpha, show.loess = F, 
+                                   prnt.plot, ...)))
   }
   if (type == ""ma"") {
     return(invisible(sjp.glm.ma(fit)))
@@ -779,23 +782,26 @@ sjp.glm.slope <- function(fit, title, geom.size, geom.colors, remove.estimates,
 
 
 #' @importFrom stats model.frame predict predict.glm family
-#' @importFrom dplyr select mutate
+#' @importFrom dplyr select mutate group_by_ summarize
 #' @importFrom sjstats resp_val
+#' @importFrom merTools predictInterval
 sjp.glm.predy <- function(fit,
                           vars,
                           t.title,
                           l.title,
                           a.title,
                           geom.colors,
                           show.ci,
+                          jitter.ci,
                           geom.size,
                           ylim,
                           facet.grid,
                           type = ""fe"",
                           scatter.plot,
                           point.alpha,
                           show.loess = FALSE,
-                          prnt.plot) {
+                          prnt.plot,
+                          ...) {
   # -----------------------------------------------------------
   # check class of fitted model
   # -----------------------------------------------------------
@@ -830,20 +836,6 @@ sjp.glm.predy <- function(fit,
     return(NULL)
   }
   # ----------------------------
-  # get predicted values for response
-  # ----------------------------
-  fitfram <- stats::model.frame(fit)
-  if (fun == ""glm"") {
-    fitfram$predicted.values <- stats::predict.glm(fit, newdata = fitfram, type = ""response"")
-  } else if (fun %in% c(""glmer"", ""lmer"", ""nlmer"")) {
-    if (type == ""fe"")
-      fitfram$predicted.values <- stats::predict(fit, newdata = fitfram, type = ""response"", re.form = NA)
-    else
-      fitfram$predicted.values <- stats::predict(fit, newdata = fitfram, type = ""response"", re.form = NULL)
-  } else {
-    fitfram$predicted.values <- stats::predict(fit, newdata = fitfram, type = ""response"")
-  }
-  # ----------------------------
   # check model family, do we have count model?
   # ----------------------------
   faminfo <- get_glm_family(fit)
@@ -859,6 +851,51 @@ sjp.glm.predy <- function(fit,
   binom_fam <- faminfo$is_bin
   poisson_fam <- faminfo$is_pois
   # ----------------------------
+  # get predicted values for response
+  # ----------------------------
+  fitfram <- stats::model.frame(fit)
+  # normal GLM's should work with the predict()-function from stats-package
+  if (fun == ""glm"") {
+    # get predictions with SE
+    prdat <- stats::predict.glm(fit, newdata = fitfram, type = ""response"", se.fit = T)
+    # copy predictions
+    fitfram$predicted.values <- prdat$fit
+    # calculate CI
+    fitfram$conf.low <- prdat$fit - 1.96 * prdat$se.fit
+    fitfram$conf.high <- prdat$fit + 1.96 * prdat$se.fit
+  } else if (show.ci && (fun == ""lmer"" || (fun == ""glmer"" && binom_fam))) {
+    # prediction intervals from merMod-package only work for linear or
+    # binary logistic multilevel models
+    prdat <- merTools::predictInterval(
+      fit, newdata = fitfram, which = ifelse(type == ""fe"", ""fixed"", ""full""),
+      type = ifelse(fit.m == ""lm"", ""linear.prediction"", ""probability""),
+      level = .95
+    )
+    # copy predictions
+    fitfram$predicted.values <- prdat$fit
+    # calculate CI
+    fitfram$conf.low <- prdat$lwr
+    fitfram$conf.high <- prdat$upr
+  } else if (fun %in% c(""lmer"", ""nlmer"", ""glmer"")) {
+    # for all other kinds of glmer or nlmer, we need the predict-function from
+    # lme4, however, without ci-bands
+    if (type == ""fe"")
+      fitfram$predicted.values <- stats::predict(fit, newdata = fitfram, type = ""response"", re.form = NA)
+    else
+      fitfram$predicted.values <- stats::predict(fit, newdata = fitfram, type = ""response"", re.form = NULL)
+    # no CI for lme4-predictions
+    fitfram$conf.low <- NA
+    fitfram$conf.high <- NA
+  } else {
+    # get predictions with SE
+    prdat <- stats::predict(fit, newdata = fitfram, type = ""response"", se.fit = T)
+    # copy predictions
+    fitfram$predicted.values <- prdat$fit
+    # calculate CI
+    fitfram$conf.low <- prdat$fit - 1.96 * prdat$se.fit
+    fitfram$conf.high <- prdat$fit + 1.96 * prdat$se.fit
+  }
+  # ----------------------------
   # check default titles
   # ----------------------------
   if (is.null(t.title)) {
@@ -896,7 +933,7 @@ sjp.glm.predy <- function(fit,
   # now select only relevant variables: the predictors on the x-axis,
   # the predictions and the originial response vector (needed for scatter plot)
   mydf <- fitfram %>% 
-    dplyr::select(match(c(vars, ""predicted.values""), colnames(fitfram))) %>% 
+    dplyr::select(match(c(vars, ""predicted.values"", ""conf.low"", ""conf.high""), colnames(fitfram))) %>% 
     dplyr::mutate(resp.y = sjmisc::to_value(sjstats::resp_val(fit), start.at = 0, keep.labels = F))
   # init legend labels
   legend.labels <- NULL
@@ -907,7 +944,7 @@ sjp.glm.predy <- function(fit,
   # with or w/o grouping factor?
   # ----------------------------
   if (length(vars) == 1) {
-    colnames(mydf) <- c(""x"", ""y"", ""resp.y"")
+    colnames(mydf) <- c(""x"", ""y"", ""ci.low"", ""ci.high"", ""resp.y"")
     # x needs to be numeric
     mydf$x <- sjmisc::to_value(mydf$x)
     # convert to factor for proper legend
@@ -918,7 +955,7 @@ sjp.glm.predy <- function(fit,
     mp <- ggplot(mydf, aes_string(x = ""x"", y = ""y"", colour = ""grp"")) +
       labs(x = x.title, y = y.title, title = t.title, colour = NULL)
   } else {
-    colnames(mydf) <- c(""x"", ""grp"", ""y"", ""resp.y"")
+    colnames(mydf) <- c(""x"", ""grp"", ""y"", ""ci.low"", ""ci.high"", ""resp.y"")
     # x needs to be numeric
     mydf$x <- sjmisc::to_value(mydf$x)
     # convert to factor for proper legend
@@ -943,14 +980,34 @@ sjp.glm.predy <- function(fit,
       if (binom_fam) {
         ylim <- c(0, 1)
       } else {
-        ylim <-
-          c(as.integer(floor(10 * min(mydf$resp.y, na.rm = T) * .9)) / 10,
-            as.integer(ceiling(10 * max(mydf$resp.y, na.rm = T) * 1.1)) / 10)
+        if (show.ci && !any(is.na(mydf$ci.low))) {
+          # first, get lowest value from response and CI
+          lowest.y <- suppressWarnings(
+            c(as.integer(floor(10 * min(mydf$resp.y, na.rm = T) * .9)) / 10,
+              as.integer(floor(10 * min(mydf$ci.low, na.rm = T) * .9)) / 10)
+          )
+          # then, get highest value from response and CI
+          highest.y <- suppressWarnings(
+            c(as.integer(ceiling(10 * max(mydf$resp.y, na.rm = T) * 1.1)) / 10,
+              as.integer(ceiling(10 * max(mydf$ci.high, na.rm = T) * 1.1)) / 10)
+          )
+        } else {
+          lowest.y <- as.integer(floor(10 * min(mydf$resp.y, na.rm = T) * .9)) / 10
+          highest.y <- as.integer(ceiling(10 * max(mydf$resp.y, na.rm = T) * 1.1)) / 10
+        }
+        # now check which is lower/higher: response value or CI
+        ylim <- c(min(lowest.y, na.rm = T), max(highest.y, na.rm = T))
       }
     } else {
-      ylim <-
-        c(as.integer(floor(10 * min(mydf$y, na.rm = T) * .9)) / 10,
-          as.integer(ceiling(10 * max(mydf$y, na.rm = T) * 1.1)) / 10)
+      if (show.ci && !any(is.na(mydf$ci.low))) {
+        ylim <-
+          c(as.integer(floor(10 * min(mydf$ci.low, na.rm = T) * .9)) / 10,
+            as.integer(ceiling(10 * max(mydf$ci.high, na.rm = T) * 1.1)) / 10)
+      } else {
+        ylim <-
+          c(as.integer(floor(10 * min(mydf$y, na.rm = T) * .9)) / 10,
+            as.integer(ceiling(10 * max(mydf$y, na.rm = T) * 1.1)) / 10)
+      }
     }
   }
   # ---------------------------------------------------------
@@ -967,24 +1024,81 @@ sjp.glm.predy <- function(fit,
                            alpha = point.alpha,
                            position = position_jitter(width = .1, height = .1))
   
-  if (fit.m == ""lm"") {
-    mp <- mp +
-      stat_smooth(method = fit.m, 
-                  se = show.ci,
-                  size = geom.size)
-  } else {
-    # special handling for negativ binomial
-    if (sjmisc::str_contains(fitfam$family, ""negative binomial"", ignore.case = T)) {
-      mp <- mp +
-        stat_smooth(method = ""glm.nb"",
-                    se = show.ci,
-                    size = geom.size)
+  # for factors, use error bars. but only if we have predicted CI in our data
+  if (is.factor(fitfram[[vars[1]]]) && !any(is.na(mydf$ci.low))) {
+    
+    # get ...-argument, and check if it was ""width""
+    eb.width <- match.call(expand.dots = FALSE)$`...`[[""width""]]
+    if (is.null(eb.width)) eb.width <- 0
+    
+    # predictions for factor levels slightly vary, so take the mean value
+    # for the predictions at each factor level. This ensures a unique
+    # data point for each level
+    datpoint <- mydf %>% 
+      dplyr::group_by_(""x"", ""grp"") %>% 
+      dplyr::summarize(y = mean(y), ci.low = mean(ci.low), ci.high = mean(ci.high))
+    
+    # no jittering, when we have no CI
+    if (!show.ci) jitter.ci <- F
+    
+    # show confidence intervals?
+    if (show.ci) {
+      if (jitter.ci) {
+        mp <- mp + geom_errorbar(
+          aes_string(ymin = ""ci.low"", ymax = ""ci.high""),
+          data = datpoint,
+          size = geom.size,
+          width = eb.width,
+          position = position_dodge(.2)
+        )
+      } else {
+        mp <- mp + geom_errorbar(
+          aes_string(ymin = ""ci.low"", ymax = ""ci.high""), 
+          data = datpoint,
+          size = geom.size,
+          width = eb.width
+        )
+        
+      }
+    }
+    
+    # plot line and data points. we don't need smoothing for discrete levels
+    if (jitter.ci) {
+      mp <- mp + 
+        geom_line(aes_string(x = ""x"", y = ""y"", colour = ""grp""), 
+                  data = datpoint, 
+                  size = geom.size,
+                  position = position_dodge(.2)) +
+        geom_point(aes_string(x = ""x"", y = ""y"", colour = ""grp""), 
+                   data = datpoint,
+                   position = position_dodge(.2))
     } else {
+      mp <- mp + 
+        geom_line(aes_string(x = ""x"", y = ""y"", colour = ""grp""), data = datpoint, size = geom.size) +
+        geom_point(aes_string(x = ""x"", y = ""y"", colour = ""grp""), data = datpoint)
+    }
+    
+    
+  } else {
+    if (fit.m == ""lm"") {
       mp <- mp +
         stat_smooth(method = fit.m, 
-                    method.args = list(family = fitfam$family), 
                     se = show.ci,
                     size = geom.size)
+    } else {
+      # special handling for negativ binomial
+      if (sjmisc::str_contains(fitfam$family, ""negative binomial"", ignore.case = T)) {
+        mp <- mp +
+          stat_smooth(method = ""glm.nb"",
+                      se = show.ci,
+                      size = geom.size)
+      } else {
+        mp <- mp +
+          stat_smooth(method = fit.m, 
+                      method.args = list(family = fitfam$family), 
+                      se = show.ci,
+                      size = geom.size)
+      }
     }
   }
   # ---------------------------------------------------------

---FILE: man/sjp.glm.Rd---
@@ -10,10 +10,11 @@ sjp.glm(fit, type = ""dots"", vars = NULL, group.estimates = NULL,
   geom.size = NULL, geom.colors = ""Set1"", wrap.title = 50,
   wrap.labels = 25, axis.lim = NULL, grid.breaks = 0.5,
   trns.ticks = TRUE, show.intercept = FALSE, show.values = TRUE,
-  show.p = TRUE, show.ci = FALSE, show.legend = FALSE,
-  show.summary = FALSE, point.alpha = 0.2, scatter.plot = TRUE,
-  digits = 2, vline.type = 2, vline.color = ""grey70"", coord.flip = TRUE,
-  y.offset = 0.15, facet.grid = TRUE, prnt.plot = TRUE, ...)
+  show.p = TRUE, show.ci = FALSE, jitter.ci = FALSE,
+  show.legend = FALSE, show.summary = FALSE, point.alpha = 0.2,
+  scatter.plot = TRUE, digits = 2, vline.type = 2,
+  vline.color = ""grey70"", coord.flip = TRUE, y.offset = 0.15,
+  facet.grid = TRUE, prnt.plot = TRUE, ...)
 }
 \arguments{
 \item{fit}{fitted generalized linear model (\code{\link{glm}}- or \code{logistf}-object).}
@@ -108,6 +109,10 @@ variable labels.}
 \item{show.ci}{logical, if \code{TRUE}, depending on \code{type}, a confidence
 interval or region is added to the plot.}
 
+\item{jitter.ci}{logical, if \code{TRUE} and \code{show.ci = TRUE} and confidence
+bands are displayed as error bars, adds jittering to lines and error bars
+to avoid overlapping.}
+
 \item{show.legend}{logical, if \code{TRUE}, and depending on plot type and
 function, a legend is added to the plot.}
 
@@ -141,7 +146,8 @@ as an arranged grid with \code{\link[gridExtra]{grid.arrange}}.}
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 
 \item{...}{other arguments, passed down to the \code{\link[effects]{effect}} resp. 
-\code{\link[effects]{allEffects}} function when \code{type = ""eff""}.}
+\code{\link[effects]{allEffects}} function when \code{type = ""eff""},
+or to ggplot-objects.}
 }
 \value{
 (Insisibily) returns, depending on the plot type

---FILE: man/sjp.glmer.Rd---
@@ -9,7 +9,7 @@ sjp.glmer(fit, type = ""re"", vars = NULL, ri.nr = NULL,
   sample.n = NULL, sort.est = NULL, title = NULL, legend.title = NULL,
   axis.labels = NULL, axis.title = NULL, geom.colors = ""Set1"",
   geom.size = NULL, show.values = TRUE, show.p = TRUE, show.ci = FALSE,
-  show.legend = FALSE, show.intercept = FALSE,
+  jitter.ci = FALSE, show.legend = FALSE, show.intercept = FALSE,
   string.interc = ""(Intercept)"", point.alpha = 0.2, scatter.plot = TRUE,
   fade.ns = FALSE, axis.lim = NULL, digits = 2, vline.type = 2,
   vline.color = ""grey70"", facet.grid = TRUE, free.scale = FALSE,
@@ -113,6 +113,10 @@ variable labels.}
 \item{show.ci}{logical, if \code{TRUE}, depending on \code{type}, a confidence
 interval or region is added to the plot.}
 
+\item{jitter.ci}{logical, if \code{TRUE} and \code{show.ci = TRUE} and confidence
+bands are displayed as error bars, adds jittering to lines and error bars
+to avoid overlapping.}
+
 \item{show.legend}{logical, if \code{TRUE}, and depending on plot type and
 function, a legend is added to the plot.}
 
@@ -162,7 +166,8 @@ to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 
 \item{...}{other arguments, passed down to the \code{\link[effects]{effect}} resp. 
-\code{\link[effects]{allEffects}} function when \code{type = ""eff""}.}
+\code{\link[effects]{allEffects}} function when \code{type = ""eff""},
+or to ggplot-objects.}
 }
 \value{
 (Insisibily) returns, depending on the plot type

---FILE: man/sjp.int.Rd---
@@ -157,7 +157,8 @@ as an arranged grid with \code{\link[gridExtra]{grid.arrange}}.}
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 
 \item{...}{other arguments, passed down to the \code{\link[effects]{effect}} resp. 
-\code{\link[effects]{allEffects}} function when \code{type = ""eff""}.}
+\code{\link[effects]{allEffects}} function when \code{type = ""eff""},
+or to ggplot-objects.}
 }
 \value{
 (Insisibily) returns the ggplot-objects with the complete plot-list (\code{plot.list})

---FILE: man/sjp.lm.Rd---
@@ -11,10 +11,11 @@ sjp.lm(fit, type = ""lm"", vars = NULL, group.estimates = NULL,
   geom.colors = ""Set1"", point.alpha = 0.2, scatter.plot = TRUE,
   wrap.title = 50, wrap.labels = 25, axis.lim = NULL,
   grid.breaks = NULL, show.values = TRUE, show.p = TRUE, show.ci = TRUE,
-  show.legend = FALSE, show.loess = FALSE, show.loess.ci = FALSE,
-  show.summary = FALSE, digits = 2, vline.type = 2,
-  vline.color = ""grey70"", coord.flip = TRUE, y.offset = 0.15,
-  facet.grid = TRUE, complete.dgns = FALSE, prnt.plot = TRUE, ...)
+  jitter.ci = FALSE, show.legend = FALSE, show.loess = FALSE,
+  show.loess.ci = FALSE, show.summary = FALSE, digits = 2,
+  vline.type = 2, vline.color = ""grey70"", coord.flip = TRUE,
+  y.offset = 0.15, facet.grid = TRUE, complete.dgns = FALSE,
+  prnt.plot = TRUE, ...)
 }
 \arguments{
 \item{fit}{fitted linear regression model (of class \code{\link{lm}}, \code{\link[nlme]{gls}} or \code{plm}).}
@@ -115,6 +116,10 @@ variable labels.}
 \item{show.ci}{logical, if \code{TRUE}, depending on \code{type}, a confidence
 interval or region is added to the plot.}
 
+\item{jitter.ci}{logical, if \code{TRUE} and \code{show.ci = TRUE} and confidence
+bands are displayed as error bars, adds jittering to lines and error bars
+to avoid overlapping.}
+
 \item{show.legend}{logical, if \code{TRUE}, and depending on plot type and
 function, a legend is added to the plot.}
 
@@ -153,7 +158,8 @@ Only applies if \code{type = ""ma""}.}
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 
 \item{...}{other arguments, passed down to the \code{\link[effects]{effect}} resp. 
-\code{\link[effects]{allEffects}} function when \code{type = ""eff""}.}
+\code{\link[effects]{allEffects}} function when \code{type = ""eff""},
+or to ggplot-objects.}
 }
 \value{
 Depending on the \code{type}, in most cases (insisibily)

---FILE: man/sjp.lmer.Rd---
@@ -9,12 +9,13 @@ sjp.lmer(fit, type = ""re"", vars = NULL, ri.nr = NULL,
   sample.n = NULL, poly.term = NULL, sort.est = NULL, title = NULL,
   legend.title = NULL, axis.labels = NULL, axis.title = NULL,
   geom.size = NULL, geom.colors = ""Set1"", show.values = TRUE,
-  show.p = TRUE, show.ci = FALSE, show.legend = FALSE,
-  show.loess = FALSE, show.loess.ci = FALSE, show.intercept = FALSE,
-  string.interc = ""(Intercept)"", p.kr = TRUE, point.alpha = 0.2,
-  scatter.plot = TRUE, fade.ns = FALSE, axis.lim = NULL, digits = 2,
-  vline.type = 2, vline.color = ""grey70"", facet.grid = TRUE,
-  free.scale = FALSE, y.offset = 0.1, prnt.plot = TRUE, ...)
+  show.p = TRUE, show.ci = FALSE, jitter.ci = FALSE,
+  show.legend = FALSE, show.loess = FALSE, show.loess.ci = FALSE,
+  show.intercept = FALSE, string.interc = ""(Intercept)"", p.kr = TRUE,
+  point.alpha = 0.2, scatter.plot = TRUE, fade.ns = FALSE,
+  axis.lim = NULL, digits = 2, vline.type = 2, vline.color = ""grey70"",
+  facet.grid = TRUE, free.scale = FALSE, y.offset = 0.1,
+  prnt.plot = TRUE, ...)
 }
 \arguments{
 \item{fit}{a fitted model as returned by the \code{\link[lme4]{lmer}}-function.}
@@ -123,6 +124,10 @@ variable labels.}
 \item{show.ci}{logical, if \code{TRUE}, depending on \code{type}, a confidence
 interval or region is added to the plot.}
 
+\item{jitter.ci}{logical, if \code{TRUE} and \code{show.ci = TRUE} and confidence
+bands are displayed as error bars, adds jittering to lines and error bars
+to avoid overlapping.}
+
 \item{show.legend}{logical, if \code{TRUE}, and depending on plot type and
 function, a legend is added to the plot.}
 
@@ -184,7 +189,8 @@ to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 
 \item{...}{other arguments, passed down to the \code{\link[effects]{effect}} resp. 
-\code{\link[effects]{allEffects}} function when \code{type = ""eff""}.}
+\code{\link[effects]{allEffects}} function when \code{type = ""eff""},
+or to ggplot-objects.}
 }
 \value{
 (Insisibily) returns"
strengejacke,sjPlot,81871ea262e1be02e5e9c678c2040576b5ced4cc,Daniel Ldecke,d.luedecke@uke.de,2016-12-08T17:32:16Z,Daniel Ldecke,d.luedecke@uke.de,2016-12-08T17:32:16Z,* `sjt.lm()` and `sjt.glm()` get a `robust`-argument to compute robust standard errors and confidence intervals.,DESCRIPTION;NAMESPACE;NEWS;NEWS.md;R/sjPlotGLME.R;R/sjTabLinReg.R;R/sjTabMannWhitney.R;R/sjTabOdds.R;man/sjt.glm.Rd;man/sjt.lm.Rd,False,True,True,False,94,123,217,"---FILE: DESCRIPTION---
@@ -33,7 +33,7 @@ Imports:
     purrr,
     scales,
     sjmisc (>= 2.1.0),
-    sjstats (>= 0.6.0),
+    sjstats (>= 0.7.0),
     tibble (>= 1.2.0),
     tidyr (>= 0.6.0)
 Suggests:

---FILE: NAMESPACE---
@@ -140,6 +140,7 @@ importFrom(sjstats,r2)
 importFrom(sjstats,reliab_test)
 importFrom(sjstats,resp_val)
 importFrom(sjstats,resp_var)
+importFrom(sjstats,robust)
 importFrom(sjstats,se)
 importFrom(sjstats,std)
 importFrom(sjstats,std_beta)

---FILE: NEWS---
@@ -5,6 +5,7 @@ New Functions:
 
 Changes to functions:
 * For `sjp.glm()` and `sjp.glmer()`, `type = ""pred""`, `type = ""slope""`, `type = ""pred.fe""` and `type = ""fe.slope""` can now also plot data points when `scatter.plot = TRUE`. Use `point.alpha` to adjust alpha-level of data points.
+* `sjt.lm()` and `sjt.glm()` get a `robust`-argument to compute robust standard errors and confidence intervals.
 * `sjp.resid()` now also returns a plot with the residual pattern, `$pattern`.
 * Plot and axis titles from effect-plots can now be changed with `title` or `axis.title` argument. Use a character vector of length > 1 to define (axis) titles for each plot or facet; use `""""` to remove the plot.
 * Pick better defaults for `geom.size`-argument for histogram and density plots in `sjp.frq()`.

---FILE: NEWS.md---
@@ -7,6 +7,7 @@
 ## Changes to functions
 
 * For `sjp.glm()` and `sjp.glmer()`, `type = ""pred""`, `type = ""slope""`, `type = ""pred.fe""` and `type = ""fe.slope""` can now also plot data points when `scatter.plot = TRUE`. Use `point.alpha` to adjust alpha-level of data points.
+* `sjt.lm()` and `sjt.glm()` get a `robust`-argument to compute robust standard errors and confidence intervals.
 * `sjp.resid()` now also returns a plot with the residual pattern, `$pattern`.
 * Plot and axis titles from effect-plots can now be changed with `title` or `axis.title` argument. Use a character vector of length > 1 to define (axis) titles for each plot or facet; use `""""` to remove the plot.
 * Pick better defaults for `geom.size`-argument for histogram and density plots in `sjp.frq()`.

---FILE: R/sjPlotGLME.R---
@@ -2457,8 +2457,8 @@ get_cleaned_ciMerMod <- function(fit, fun, ci.only = FALSE) {
   else
     mydf <- data.frame(exp(cbind(estimate, CI)))
   # add rownames
-  mydf <- mydf %>% 
-    tibble::rownames_to_column(var = ""term"") %>% 
+  mydf <- 
+    tibble::rownames_to_column(mydf, var = ""term"") %>% 
     dplyr::rename_(.dots = list(""conf.low"" = ""X2.5.."", ""conf.high"" = ""X97.5..""))
   # only return ci?
   if (ci.only) mydf <- mydf %>% dplyr::select_(""-estimate"")

---FILE: R/sjTabLinReg.R---
@@ -56,6 +56,10 @@
 #' @param p.zero logical, if \code{TRUE}, p-values have a leading 0 before the
 #'          period (e.g. \emph{0.002}), else p-values start with a period and
 #'          without a zero (e.g. \emph{.002}).
+#' @param robust logical, if \code{TRUE}, robust standard errors and confidence 
+#'          intervals will be reported. Computation of robust standard errors is
+#'          based on the \code{\link[sjstats]{robust}}-function in the 
+#'          \pkg{sjstats}-package.
 #' @param separate.ci.col if \code{TRUE}, the CI values are shown in a separate table column.
 #'          Default is \code{FALSE}.
 #' @param newline.ci logical, if \code{TRUE} and \code{separate.ci.col = FALSE}, inserts a line break
@@ -286,7 +290,7 @@
 #' @importFrom dplyr full_join slice bind_cols select_ rename_
 #' @importFrom stats nobs AIC confint coef deviance
 #' @importFrom lme4 VarCorr
-#' @importFrom sjstats std_beta icc r2 cod chisq_gof hoslem_gof get_model_pval
+#' @importFrom sjstats std_beta icc r2 cod chisq_gof hoslem_gof get_model_pval robust
 #' @importFrom tibble lst add_row add_column
 #' @importFrom broom tidy
 #' @export
@@ -299,6 +303,7 @@ sjt.lm <- function(...,
                    emph.p = TRUE,
                    p.zero = FALSE,
                    p.kr = TRUE,
+                   robust = FALSE,
                    separate.ci.col = TRUE,
                    newline.ci = TRUE,
                    show.est = TRUE,
@@ -449,8 +454,13 @@ sjt.lm <- function(...,
     # -------------------------------------
     # get tidy model summary
     # -------------------------------------
-    fit.df <- broom::tidy(input_list[[i]], effects = ""fixed"", conf.int = T) %>% 
-      dplyr::select_(""-statistic"")
+    if (robust) {
+      fit.df <- sjstats::robust(input_list[[i]], conf.int = T) %>% 
+        dplyr::select_(""-statistic"")
+    } else {
+      fit.df <- broom::tidy(input_list[[i]], effects = ""fixed"", conf.int = T) %>% 
+        dplyr::select_(""-statistic"")
+    }
     # -------------------------------------
     # check for p-value colum
     # -------------------------------------
@@ -534,7 +544,7 @@ sjt.lm <- function(...,
     # -------------------------------------
     # add to df list
     # -------------------------------------
-    df.fit[[length(df.fit) + 1]] <- fit.df
+    df.fit[[length(df.fit) + 1]] <- as.data.frame(fit.df)
   }
   # -------------------------------------
   # join all data frame, i.e. ""merge"" all
@@ -584,12 +594,6 @@ sjt.lm <- function(...,
     # select rows
     joined.df <- dplyr::slice(joined.df, keep.estimates)
   }
-  # replace empty values &nbsp;
-  # for (i in seq_len(nrow(joined.df))) {
-  #   for (j in seq_len(ncol(joined.df))) {
-  #     if (sjmisc::is_empty(joined.df[i, j])) joined.df[i, j] <- ""&nbsp;""
-  #   }
-  # }
   # -------------------------------------
   # if confidence interval should be omitted,
   # don't use separate column for CI!
@@ -1444,7 +1448,7 @@ sjt.lmer <- function(...,
                 digits.est = digits.est, digits.p = digits.p, digits.ci = digits.ci,
                 digits.se = digits.se, digits.std = digits.std, digits.summary = digits.summary, 
                 p.numeric = p.numeric, emph.p = emph.p, p.zero = p.zero, p.kr = p.kr,
-                separate.ci.col = separate.ci.col, newline.ci = newline.ci, 
+                robust = FALSE, separate.ci.col = separate.ci.col, newline.ci = newline.ci, 
                 group.pred = group.pred, show.col.header = show.col.header, show.r2 = show.r2, show.icc = show.icc, 
                 show.re.var = show.re.var, show.fstat = FALSE, show.aic = show.aic, show.aicc = show.aicc, show.dev = show.dev,
                 remove.estimates = remove.estimates, cell.spacing = cell.spacing, cell.gpr.indent = cell.gpr.indent,

---FILE: R/sjTabMannWhitney.R---
@@ -1,15 +1,15 @@
 #' @title Summary of Mann-Whitney-Test as HTML table
 #' @name sjt.mwu
-#' 
+#'
 #' @description Shows the results of a Mann-Whitney-U-test as HTML table. The results
 #'                from the Mann-Whitney-test are obtained by the \code{\link[sjstats]{mwu}}
 #'                function from the \pkg{sjstats}-package.
 #'
 #' @param x results of a Mann-Whitney-U test, provided by \code{\link[sjstats]{mwu}}. See 'Examples'.
-#'          
+#'
 #' @inheritParams sjt.frq
 #' @inheritParams sjt.df
-#'  
+#'
 #' @return Invisibly returns a \code{\link{list}} with
 #'          \itemize{
 #'            \item the data frame with the description information (\code{data}),
@@ -21,19 +21,19 @@
 #'            for further use.
 #'
 #' @note See 'Notes' in \code{\link{sjt.frq}}.
-#'  
+#'
 #' @details See 'Details' in \code{\link{sjt.frq}}.
 #'
-#' @examples 
+#' @examples
 #' \dontrun{
 #' library(sjmisc)
 #' data(efc)
 #' sjt.mwu(mwu(efc$e17age, efc$e42dep))}
 #'
 #' @export
-sjt.mwu <- function(x, 
-                    title = NULL, 
-                    altr.row.col = TRUE, 
+sjt.mwu <- function(x,
+                    title = NULL,
+                    altr.row.col = TRUE,
                     CSS = NULL,
                     encoding = NULL,
                     file = NULL,
@@ -44,7 +44,7 @@ sjt.mwu <- function(x,
   # check correct class
   # --------------------------------------------------------
   if (class(x) != ""mwu"") {
-    stop(""'x' must be of class 'mwu', as returned by the 'mwu'-function of the sjmisc-package. See ?sjt.mwu for details."", call. = F)
+    stop(""`x` must be of class `mwu`, as returned by the `mwu()`-function of the sjstats-package."", call. = F)
   }
   # --------------------------------------------------------
   # check p-value-style option
@@ -63,10 +63,10 @@ sjt.mwu <- function(x,
   # --------------------------------------------------------
   # print table and return results
   # --------------------------------------------------------
-  html <- sjt.df(x$tab.df, 
+  html <- sjt.df(x$tab.df,
                  title = title,
-                 describe = F, 
-                 show.rownames = F, 
+                 describe = F,
+                 show.rownames = F,
                  altr.row.col = altr.row.col,
                  CSS = CSS,
                  no.output = T,
@@ -76,9 +76,9 @@ sjt.mwu <- function(x,
   # -------------------------------------
   # check if html-content should be printed
   # -------------------------------------
-  out.html.table(no.output, file, html$knitr, html$output.complete, use.viewer)  
+  out.html.table(no.output, file, html$knitr, html$output.complete, use.viewer)
   invisible(list(class = c(""sjTable"", ""sjtmwu""),
-                 df = x$tab.df, 
+                 df = x$tab.df,
                  page.style = html$page.style,
                  page.content = html$page.content,
                  knitr = html$knitr,

---FILE: R/sjTabOdds.R---
@@ -174,6 +174,7 @@ sjt.glm <- function(...,
                     p.numeric = TRUE,
                     emph.p = TRUE,
                     p.zero = FALSE,
+                    robust = FALSE,
                     separate.ci.col = TRUE,
                     newline.ci = TRUE,
                     show.ci = TRUE,
@@ -300,56 +301,45 @@ sjt.glm <- function(...,
     # -------------------------------------
     fit <- input_list[[i]]
     # -------------------------------------
-    # retrieve ci for model
+    # get tidy model summary
     # -------------------------------------
-    if (lmerob) {
-      # get cleaned CI
-      confis <- get_cleaned_ciMerMod(fit, ""lm"", T) %>% 
-        dplyr::select_(""-term"")
-      coef.fit <- lme4::fixef(fit)
+    if (robust) {
+      fit.df <- sjstats::robust(fit, conf.int = T, exponentiate = F) %>% 
+        dplyr::select_(""-statistic"")
     } else {
-      confis <- stats::confint(fit)
-      coef.fit <- stats::coef(fit)
+      fit.df <- broom::tidy(fit, effects = ""fixed"", conf.int = T) %>% 
+        dplyr::select_(""-statistic"")
     }
     # -------------------------------------
     # write data to data frame. we need names of
     # coefficients, estimated values, ci,
     # std. beta and p-values
     # -------------------------------------
-    fit.df <- data.frame(names(coef.fit))
     if (exp.coef) {
-      fit.df$coeffs <- sprintf(""%.*f"", digits.est, exp(coef.fit))
-      fit.df$confi_lower <- sprintf(""%.*f"", digits.ci, exp(confis[, 1]))
-      fit.df$confi_higher <- sprintf(""%.*f"", digits.ci, exp(confis[, 2]))
-    } else {
-      fit.df$coeffs <- sprintf(""%.*f"", digits.est, coef.fit)
-      fit.df$confi_lower <- sprintf(""%.*f"", digits.ci, confis[, 1])
-      fit.df$confi_higher <- sprintf(""%.*f"", digits.ci, confis[, 2])
+      fit.df$estimate <- exp(fit.df$estimate)
+      fit.df$conf.low <- exp(fit.df$conf.low)
+      fit.df$conf.high <- exp(fit.df$conf.high)
     }
     # -------------------------------------
-    # extracting p-values and se differs between
-    # glmer and glm, and also pglm. Note that
-    # pglm-models do not have the ""pglm""-class-attribute,
-    # differently stated in the help ?pglm
+    # format values
     # -------------------------------------
-    p.tmp <- sjstats::get_model_pval(fit)
-    # p-values
-    fit.df$pv <- round(p.tmp[[""p.value""]], digits.p)
-    # standard error
-    fit.df$se <- sprintf(""%.*f"", digits.se, p.tmp[[""std.error""]])
+    fit.df$estimate <- sprintf(""%.*f"", digits.est, fit.df$estimate)
+    fit.df$conf.low <- sprintf(""%.*f"", digits.ci, fit.df$conf.low)
+    fit.df$conf.high <- sprintf(""%.*f"", digits.ci, fit.df$conf.high)
+    fit.df$std.error <- sprintf(""%.*f"", digits.se, fit.df$std.error)
     # -------------------------------------
     # prepare p-values, either as * or as numbers
     # -------------------------------------
     if (!p.numeric) {
-      fit.df$pv <- sapply(fit.df$pv, function(x) x <- get_p_stars(x))
+      fit.df$p.value <- sapply(fit.df$p.value, function(x) x <- get_p_stars(x))
     } else {
       if (emph.p) {
         sb1 <- ""<b>""
         sb2 <- ""</b>""
       } else {
         sb1 <- sb2 <- """"
       }
-      fit.df$pv <- sapply(fit.df$pv, function(x) {
+      fit.df$p.value <- sapply(fit.df$p.value, function(x) {
         if (x < 0.05) {
           if (x < 0.001 && digits.p <= 3) {
             x <- sprintf(""%s&lt;0.001%s"", sb1, sb2)
@@ -372,14 +362,15 @@ sjt.glm <- function(...,
     # -------------------------------------
     colnames(fit.df) <- c(""coef.name"",
                           sprintf(""estimate%i"", i),
-                          sprintf(""ci.lo%i"", i),
-                          sprintf(""ci.hi%i"", i),
+                          sprintf(""se%i"", i),
                           sprintf(""p-value%i"", i),
-                          sprintf(""se%i"", i))
+                          sprintf(""ci.lo%i"", i),
+                          sprintf(""ci.hi%i"", i))
+    fit.df <- fit.df[, c(1:2, 5:6, 4, 3)]
     # -------------------------------------
     # add to df list
     # -------------------------------------
-    df.fit[[length(df.fit) + 1]] <- fit.df
+    df.fit[[length(df.fit) + 1]] <- as.data.frame(fit.df)
   }
   # -------------------------------------
   # join all data frame
@@ -530,7 +521,7 @@ sjt.glm <- function(...,
   if (show.col.header) {
     page.content <- paste0(page.content, ""\n  <tr>\n    <td class=\""tdata colnames\"">&nbsp;</td>"")
     colnr <- ifelse(is.null(depvar.labels), length(input_list), length(depvar.labels))
-    for (i in 1:colnr) {
+    for (i in seq_len(colnr)) {
       # -------------------------
       # insert ""separator column""
       # -------------------------
@@ -570,7 +561,7 @@ sjt.glm <- function(...,
   # 1. row: intercept
   # -------------------------------------
   page.content <- paste0(page.content, sprintf(""  <tr>\n    <td class=\""tdata %sleftalign\"">%s</td>"", tcb_class, string.interc))
-  for (i in 1:length(input_list)) {
+  for (i in seq_len(length(input_list))) {
     # -------------------------
     # insert ""separator column""
     # -------------------------
@@ -642,7 +633,7 @@ sjt.glm <- function(...,
     # ---------------------------------------
     # go through fitted model's statistics
     # ---------------------------------------
-    for (j in 1:length(input_list)) {
+    for (j in seq_len(length(input_list))) {
       # retieve lower and upper ci
       ci.lo <- joined.df[i + 1, (j - 1) * 5 + 3]
       ci.hi <- joined.df[i + 1, (j - 1) * 5 + 4]
@@ -741,12 +732,12 @@ sjt.glm <- function(...,
       # -------------------------
       # first models indicates grouping levels. we have to assume comparable models
       # with same random intercepts.
-      for (gl in 1:mmcount) {
+      for (gl in seq_len(mmcount)) {
         page.content <- paste0(page.content,
                                sprintf(""\n  <tr>\n    <td class=\""tdata summary leftalign\"">&tau;<sub>00, %s</sub></td>\n"",
                                        names(mmgrps[gl])))
         # iterate models
-        for (i in 1:length(input_list)) {
+        for (i in seq_len(length(input_list))) {
           # -------------------------
           # insert ""separator column""
           # -------------------------
@@ -772,7 +763,7 @@ sjt.glm <- function(...,
         # iterate final models
         page.content <- paste0(page.content, ""\n  <tr>\n    <td class=\""tdata summary leftalign\"">&rho;<sub>01</sub></td>\n"")
         # iterate models
-        for (i in 1:length(input_list)) {
+        for (i in seq_len(length(input_list))) {
           # -------------------------
           # insert ""separator column""
           # -------------------------
@@ -796,10 +787,10 @@ sjt.glm <- function(...,
     # -------------------------------------
     # first models indicates grouping levels. we have to assume comparable models
     # with same random intercepts.
-    for (gl in 1:mmcount) {
+    for (gl in seq_len(mmcount)) {
       page.content <- paste0(page.content, sprintf(""\n  <tr>\n    <td class=\""tdata summary leftalign\"">N<sub>%s</sub></td>"", names(mmgrps[gl])))
       # iterate models
-      for (i in 1:length(input_list)) {
+      for (i in seq_len(length(input_list))) {
         # -------------------------
         # insert ""separator column""
         # -------------------------
@@ -823,10 +814,10 @@ sjt.glm <- function(...,
       # get icc from models
       summary.icc <- sjstats::icc(input_list[[which.max(all_mm_counts)]])
       # iterate icc's
-      for (si in 1:mmcount) {
+      for (si in seq_len(mmcount)) {
         page.content <- paste0(page.content, sprintf(""  <tr>\n    <td class=\""tdata leftalign summary\"">ICC<sub>%s</sub></td>"", names(summary.icc[si])))
         # iterate models
-        for (i in 1:length(input_list)) {
+        for (i in seq_len(length(input_list))) {
           # -------------------------
           # insert ""separator column""
           # -------------------------
@@ -850,7 +841,7 @@ sjt.glm <- function(...,
   # Model-Summary: N
   # -------------------------------------
   page.content <- paste0(page.content, sprintf(""\n  <tr>\n    <td class=\""tdata summary leftalign firstsumrow\"">%s</td>"", string.obs))
-  for (i in 1:length(input_list)) {
+  for (i in seq_len(length(input_list))) {
     # -------------------------
     # insert ""separator column""
     # -------------------------
@@ -869,7 +860,7 @@ sjt.glm <- function(...,
       r2string <- ""Pseudo-R<sup>2</sup>""
 
     page.content <- paste0(page.content, sprintf(""  <tr>\n    <td class=\""tdata leftalign summary\"">%s</td>"", r2string))
-    for (i in 1:length(input_list)) {
+    for (i in seq_len(length(input_list))) {
       # -------------------------
       # insert ""separator column""
       # -------------------------
@@ -915,7 +906,7 @@ sjt.glm <- function(...,
       if (any(models.reml)) warning(""Some models were fit with REML. To get meaningful AIC values for comparison, refit models with ML (`REML = FALSE`)."", call. = F)
     }
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">AIC</td>"")
-    for (i in 1:length(input_list)) {
+    for (i in seq_len(length(input_list))) {
       # -------------------------
       # insert ""separator column""
       # -------------------------
@@ -929,7 +920,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   if (show.aicc) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">AICc</td>"")
-    for (i in 1:length(input_list)) {
+    for (i in seq_len(length(input_list))) {
       # -------------------------
       # insert ""separator column""
       # -------------------------
@@ -943,7 +934,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   if (show.loglik) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">-2 Log-Likelihood</td>"")
-    for (i in 1:length(input_list)) {
+    for (i in seq_len(length(input_list))) {
       # -------------------------
       # insert ""separator column""
       # -------------------------
@@ -957,7 +948,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   if (show.dev) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">Deviance</td>"")
-    for (i in 1:length(input_list)) {
+    for (i in seq_len(length(input_list))) {
       # -------------------------
       # insert ""separator column""
       # -------------------------
@@ -971,7 +962,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   if (show.chi2) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">&Chi;<sup>2</sup><sub>deviance</sub></td>"")
-    for (i in 1:length(input_list)) {
+    for (i in seq_len(length(input_list))) {
       # -------------------------
       # insert ""separator column""
       # -------------------------
@@ -987,48 +978,11 @@ sjt.glm <- function(...,
     page.content <- paste0(page.content, ""\n  </tr>\n"")
   }
   # -------------------------------------
-  # Model-Summary: chi-square-GOF
-  # -------------------------------------
-  #   if (showGoF) {
-  #     # -------------------------
-  #     # not working for glmer
-  #     # -------------------------
-  #     if (lmerob) {
-  #       warning(""Chi-square Goodness-of-Fit-test does not work for 'merMod'-objects."", call. = F)
-  #     } else {
-  #       page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">Pearson's &Chi;<sup>2</sup></td>"")
-  #       for (i in 1:length(input_list)) {
-  #         # -------------------------
-  #         # insert ""separator column""
-  #         # -------------------------
-  #         if (sep.column) page.content <- paste0(page.content, ""<td class=\""separatorcol\"">&nbsp;</td>"")
-  #         # -------------------------
-  #         # compute Pearson's X2 GOF-test
-  #         # -------------------------
-  #         pgof <- sjstats::chisq_gof(input_list[[i]])
-  #         # -------------------------
-  #         # print chisq and p
-  #         # -------------------------
-  #         page.content <- paste0(page.content,
-  #                                gsub(""0."",
-  #                                     paste0(p_zero, "".""),
-  #                                     sprintf(""%s%.*f; p=%.*f</td>"",
-  #                                             colspanstring,
-  #                                             digits.summary,
-  #                                             pgof$X2,
-  #                                             digits.summary,
-  #                                             pgof$p.value),
-  #                                     fixed = T))
-  #       }
-  #       page.content <- paste0(page.content, ""\n  </tr>\n"")
-  #     }
-  #   }
-  # -------------------------------------
   # Model-Summary: Hosmer-Lemeshow-GOF
   # -------------------------------------
   if (show.hoslem) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">Hosmer-Lemeshow-&Chi;<sup>2</sup></td>"")
-    for (i in 1:length(input_list)) {
+    for (i in seq_len(length(input_list))) {
       # -------------------------
       # insert ""separator column""
       # -------------------------
@@ -1058,7 +1012,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   if (show.family) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">Family</td>"")
-    for (i in 1:length(input_list)) {
+    for (i in seq_len(length(input_list))) {
       # -------------------------
       # insert ""separator column""
       # -------------------------
@@ -1247,7 +1201,7 @@ sjt.glmer <- function(...,
                  string.ci = string.ci, string.se = string.se, string.p = string.p,
                  digits.est = digits.est, digits.p = digits.p, digits.ci = digits.ci,
                  digits.se = digits.se, digits.summary = digits.summary, exp.coef = exp.coef,
-                 p.numeric = p.numeric, emph.p = emph.p, p.zero = p.zero,
+                 p.numeric = p.numeric, emph.p = emph.p, p.zero = p.zero, robust = FALSE, 
                  show.ci = show.ci, show.se = show.se,
                  ci.hyphen = ci.hyphen, separate.ci.col = separate.ci.col, newline.ci = newline.ci,
                  group.pred = group.pred, show.col.header = show.col.header, show.r2 = show.r2, show.icc = show.icc,

---FILE: man/sjt.glm.Rd---
@@ -6,7 +6,7 @@
 \usage{
 sjt.glm(..., pred.labels = NULL, depvar.labels = NULL,
   remove.estimates = NULL, group.pred = TRUE, exp.coef = TRUE,
-  p.numeric = TRUE, emph.p = TRUE, p.zero = FALSE,
+  p.numeric = TRUE, emph.p = TRUE, p.zero = FALSE, robust = FALSE,
   separate.ci.col = TRUE, newline.ci = TRUE, show.ci = TRUE,
   show.se = FALSE, show.header = FALSE, show.col.header = TRUE,
   show.r2 = FALSE, show.icc = FALSE, show.re.var = FALSE,
@@ -62,6 +62,11 @@ as numbers. If \code{FALSE} (default), asterisks are used.}
 period (e.g. \emph{0.002}), else p-values start with a period and
 without a zero (e.g. \emph{.002}).}
 
+\item{robust}{logical, if \code{TRUE}, robust standard errors and confidence 
+intervals will be reported. Computation of robust standard errors is
+based on the \code{\link[sjstats]{robust}}-function in the 
+\pkg{sjstats}-package.}
+
 \item{separate.ci.col}{if \code{TRUE}, the CI values are shown in a separate table column.
 Default is \code{FALSE}.}
 

---FILE: man/sjt.lm.Rd---
@@ -6,12 +6,12 @@
 \usage{
 sjt.lm(..., pred.labels = NULL, depvar.labels = NULL,
   remove.estimates = NULL, group.pred = TRUE, p.numeric = TRUE,
-  emph.p = TRUE, p.zero = FALSE, p.kr = TRUE, separate.ci.col = TRUE,
-  newline.ci = TRUE, show.est = TRUE, show.std = NULL, show.ci = TRUE,
-  show.se = FALSE, show.header = FALSE, show.col.header = TRUE,
-  show.r2 = TRUE, show.icc = FALSE, show.re.var = FALSE,
-  show.fstat = FALSE, show.aic = FALSE, show.aicc = FALSE,
-  show.dev = FALSE, string.pred = ""Predictors"",
+  emph.p = TRUE, p.zero = FALSE, p.kr = TRUE, robust = FALSE,
+  separate.ci.col = TRUE, newline.ci = TRUE, show.est = TRUE,
+  show.std = NULL, show.ci = TRUE, show.se = FALSE, show.header = FALSE,
+  show.col.header = TRUE, show.r2 = TRUE, show.icc = FALSE,
+  show.re.var = FALSE, show.fstat = FALSE, show.aic = FALSE,
+  show.aicc = FALSE, show.dev = FALSE, string.pred = ""Predictors"",
   string.dv = ""Dependent Variables"", string.interc = ""(Intercept)"",
   string.obs = ""Observations"", string.est = ""B"", string.std = ""std. Beta"",
   string.ci = ""CI"", string.se = ""std. Error"", string.p = ""p"",
@@ -60,6 +60,11 @@ without a zero (e.g. \emph{.002}).}
 F-tests with Kenward-Roger approximation for the df. Caution: Computation
 may take very long time for large samples!}
 
+\item{robust}{logical, if \code{TRUE}, robust standard errors and confidence 
+intervals will be reported. Computation of robust standard errors is
+based on the \code{\link[sjstats]{robust}}-function in the 
+\pkg{sjstats}-package.}
+
 \item{separate.ci.col}{if \code{TRUE}, the CI values are shown in a separate table column.
 Default is \code{FALSE}.}
 "
strengejacke,sjPlot,852fc5c7d5ec042a010bf14db2eef70bf783ee4e,Daniel Ldecke,d.luedecke@uke.de,2016-12-07T07:39:42Z,Daniel Ldecke,d.luedecke@uke.de,2016-12-07T07:39:42Z,"close https://github.com/sjPlot/sjmisc/issues/30

* Improved automatic label detection for regression models for plot or
table output.",NEWS;NEWS.md;R/helpfunctions.R;R/sjPlotLinregMultiple.R;R/sjPlotOdds.R;R/sjPlotOddsMultiple.R,False,True,True,False,28,20,48,"---FILE: NEWS---
@@ -7,6 +7,7 @@ Changes to functions:
 * `sjp.resid()` now also returns a plot with the residual pattern, `$pattern`.
 * Plot and axis titles from effect-plots can now be changed with `title` or `axis.title` argument. Use a character vector of length > 1 to define (axis) titles for each plot or facet; use `""""` to remove the plot.
 * Pick better defaults for `geom.size`-argument for histogram and density plots in `sjp.frq()`.
+* Improved automatic label detection for regression models for plot or table output.
 
 Bug fixes:
 * Restored order of categories in `sjp.xtab()` and `sjp.grpfrq()` for stacked bars (`position_stack()` reversed order since  last ggplot2-update), so labels are now correclty positioned again.

---FILE: NEWS.md---
@@ -9,6 +9,7 @@
 * `sjp.resid()` now also returns a plot with the residual pattern, `$pattern`.
 * Plot and axis titles from effect-plots can now be changed with `title` or `axis.title` argument. Use a character vector of length > 1 to define (axis) titles for each plot or facet; use `""""` to remove the plot.
 * Pick better defaults for `geom.size`-argument for histogram and density plots in `sjp.frq()`.
+* Improved automatic label detection for regression models for plot or table output.
 
 ## Bug fixes
 

---FILE: R/helpfunctions.R---
@@ -613,7 +613,7 @@ retrieveModelLabels <- function(models, group.pred) {
     # get model
     fit <- models[[k]]
     # any valid model?
-    if (inherits(fit, c(""plm"", ""ppgls"")) return(NULL)
+    if (inherits(fit, c(""plm"", ""ppgls""))) return(NULL)
     # get model coefficients' names
     if (is_merMod(fit)) {
       coef_names <- names(lme4::fixef(fit))
@@ -645,33 +645,27 @@ retrieveModelLabels <- function(models, group.pred) {
           # have any labels, and have we same amount of labels
           # as factor levels?
           if (!is.null(pvar.lab) && length(pvar.lab) == pvar.len) {
-            # add labels
-            if (sjmisc::str_contains(fit.labels, pattern = pvar.lab[2:pvar.len], logic = ""NOT"")) {
-              # create labels
-              if (group.pred && pvar.len > 2) {
-                # if predictor grouping is enabled, don't use variable labels again
-                labels.to.add <- pvar.lab[2:pvar.len]
-              } else {
-                # else, if we have not grouped predictors, we have no headin
-                # with variable label, hence, factor levels may not be intuitiv.
-                # thus, add variable label so values have a meaning
-                labels.to.add <- sprintf(""%s (%s)"", lab, pvar.lab[2:pvar.len])
-              }
-              fit.labels <- c(fit.labels, labels.to.add)
+            # create labels
+            if (group.pred && pvar.len > 2) {
+              # if predictor grouping is enabled, don't use variable labels again
+              labels.to.add <- pvar.lab[2:pvar.len]
+            } else {
+              # else, if we have not grouped predictors, we have no headin
+              # with variable label, hence, factor levels may not be intuitiv.
+              # thus, add variable label so values have a meaning
+              labels.to.add <- sprintf(""%s (%s)"", lab, pvar.lab[2:pvar.len])
             }
+            fit.labels <- c(fit.labels, labels.to.add)
           } else {
-            # add labels
-            if (sjmisc::str_contains(fit.labels, pattern = coef_name, logic = ""NOT"")) {
-              fit.labels <- c(fit.labels, coef_name)
-            }
+            fit.labels <- c(fit.labels, coef_name)
           }
         } else {
           if (!any(fit.labels == lab)) fit.labels <- c(fit.labels, lab)
         }
       }
     }
   }
-  return(fit.labels)
+  return(unique(fit.labels))
 }
 
 

---FILE: R/sjPlotLinregMultiple.R---
@@ -137,6 +137,10 @@ sjp.lmm <- function(...,
   # ----------------------------
   # Prepare length of title and labels
   # ----------------------------
+  # auto-retrieve value labels
+  if (is.null(axis.labels)) {
+    axis.labels <- suppressWarnings(retrieveModelLabels(input_list, group.pred = FALSE))
+  }
   # if we have no labels of dependent variables supplied, use a 
   # default string (Model) for legend
   if (is.null(depvar.labels))
@@ -250,6 +254,8 @@ sjp.lmm <- function(...,
   finalbetas$grp <- as.factor(finalbetas$grp)
   # convert to character
   finalbetas$shape <- as.character(finalbetas$shape)
+  # sort labels
+  axis.labels <- axis.labels[order(unique(finalbetas$xpos))]
   # -------------------------------------------------
   # remove any estimates from the output?
   # -------------------------------------------------

---FILE: R/sjPlotOdds.R---
@@ -154,7 +154,7 @@ sjp.glm <- function(fit,
   # check args -----
   if (type == ""pc"" || type == ""prob"") type <- ""slope""
 
-  if (any(class(fit) == ""logistf"")) {
+  if (inherits(fit, ""logistf"")) {
     # no model summary currently supported for logistf class
     show.summary <- FALSE
     # create ""dummy"" variable, to avoid errors

---FILE: R/sjPlotOddsMultiple.R---
@@ -127,6 +127,10 @@ sjp.glmm <- function(...,
   # ----------------------------
   # Prepare length of title and labels
   # ----------------------------
+  # auto-retrieve value labels
+  if (is.null(axis.labels)) {
+    axis.labels <- suppressWarnings(retrieveModelLabels(input_list, group.pred = FALSE))
+  }
   # if we have no labels of dependent variables supplied, use a 
   # default string (Model) for legend
   if (is.null(depvar.labels))
@@ -227,6 +231,8 @@ sjp.glmm <- function(...,
   finalodds$grp <- as.factor(finalodds$grp)
   # convert to character
   finalodds$shape <- as.character(finalodds$shape)
+  # sort labels
+  axis.labels <- axis.labels[order(unique(finalodds$xpos))]
   # -------------------------------------------------
   # remove any estimates from the output?
   # -------------------------------------------------"
strengejacke,sjPlot,2a2568c119468f10803ff98e8b4d8b87495b63cf,Daniel Ldecke,d.luedecke@uke.de,2016-11-28T18:04:16Z,Daniel Ldecke,d.luedecke@uke.de,2016-11-28T18:04:16Z,"code-style, fix CRAN-check issues",R/sjPlotClusterAnalysis.R;R/sjPlotFrequencies.R;R/sjPlotGLME.R;R/sjPlotLinregMultiple.R;R/sjPlotOddsMultiple.R;R/sjTabItemAnalysis.R;man/sjp.lmer.Rd,False,True,True,False,33,52,85,"---FILE: R/sjPlotClusterAnalysis.R---
@@ -234,7 +234,7 @@ sjc.qclus <- function(data,
   # ---------------------------------------------
   for (cnt in seq_len(colnr)) {
     # retrieve column data
-    coldat <- z[, cnt]
+    coldat <- z[[cnt]]
     # ---------------------------------------------
     # iterate groups
     # ---------------------------------------------
@@ -840,7 +840,7 @@ sjc.kgap <- function(x,
                   colour = ""#3366cc"") +
     geom_line(colour = ""gray50"") +
     geom_point(colour = df$pcol, size = df$psize) +
-    scale_x_discrete(breaks = c(1:nrow(df))) +
+    scale_x_discrete(breaks = seq_len(nrow(df))) +
     labs(x = ""Number of clusters"", 
          y = ""Gap"", 
          title = sprintf(""Estimation of clusters (gap statistics)\n%i-cluster solution found"", nc)) +

---FILE: R/sjPlotFrequencies.R---
@@ -105,7 +105,7 @@ utils::globalVariables(c(""val"", ""frq"", ""grp"", ""label.pos"", ""upper.ci"", ""lower.ci
 #' 
 #' @import ggplot2
 #' @importFrom sjstats wtd_sd
-#' @importFrom sjmisc set_labels group_labels group_var
+#' @importFrom sjmisc set_labels group_labels group_var to_value
 #' @importFrom stats na.omit sd weighted.mean
 #' @export
 sjp.frq <- function(var.cnt,
@@ -207,7 +207,7 @@ sjp.frq <- function(var.cnt,
   }
 
   # for histograms or density plots...
-  xv <- stats::na.omit(var.cnt)
+  xv <- sjmisc::to_value(stats::na.omit(var.cnt))
   # check for nice bin-width defaults
   if (type %in% c(""histogram"", ""density"") && 
       !is.null(geom.size) && 
@@ -221,8 +221,8 @@ sjp.frq <- function(var.cnt,
     geom.size <- dplyr::case_when(
       type == ""bar"" ~ .7,
       type == ""dot"" ~ 2.5,
-      type == ""density"" ~ round(diff(range(xv)) / 40),
-      type == ""histogram"" ~ round(diff(range(xv)) / 40),
+      type == ""density"" ~ ceiling(diff(range(xv)) / 40),
+      type == ""histogram"" ~ ceiling(diff(range(xv)) / 40),
       type == ""line"" ~ .8,
       type == ""boxplot"" ~ .3,
       type == ""violin"" ~ .3,

---FILE: R/sjPlotGLME.R---
@@ -497,7 +497,7 @@ sjp.glmer <- function(fit,
 #'
 #' # lme4 complaints about scale of polynomial term, so
 #' # try centering this predictor
-#' mydf$barthel_s <- scale(mydf$barthel, center = TRUE, scale = TRUE)
+#' mydf$barthel_s <- sjstats::std(mydf$barthel)
 #'
 #' # re-fit model
 #' fit_s <- lmer(neg_c_7 ~ sex + c12hour + barthel_s +

---FILE: R/sjPlotLinregMultiple.R---
@@ -139,13 +139,8 @@ sjp.lmm <- function(...,
   # ----------------------------
   # if we have no labels of dependent variables supplied, use a 
   # default string (Model) for legend
-  if (is.null(depvar.labels)) {
-    depvar.labels <- c()
-    for (i in seq_len(fitlength)) {
-      depvar.labels <- c(depvar.labels, 
-                         get_model_response_label(input_list[[i]]))
-    }
-  }
+  if (is.null(depvar.labels))
+    depvar.labels <- unname(unlist(lapply(input_list, get_model_response_label)))
   # check length of diagram title and split longer string at into new lines
   if (!is.null(title)) title <- sjmisc::word_wrap(title, wrap.title)
   # check length of x-axis title and split longer string at into new lines
@@ -301,7 +296,7 @@ sjp.lmm <- function(...,
   if (is.null(grid.breaks)) {
     ticks <- pretty(c(lower_lim, upper_lim))
   } else {
-    ticks <- c(seq(lower_lim, upper_lim, by = grid.breaks))
+    ticks <- seq(lower_lim, upper_lim, by = grid.breaks)
   }
   # --------------------------------------------------------
   # prepare star and shape values. we just copy those values
@@ -400,7 +395,7 @@ sjp.lmm <- function(...,
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------
-  if (prnt.plot) graphics::plot(plotHeader)
+  if (prnt.plot) suppressWarnings(graphics::plot(plotHeader))
   # -------------------------------------
   # set proper column names
   # -------------------------------------

---FILE: R/sjPlotOddsMultiple.R---
@@ -1,6 +1,3 @@
-# bind global variables
-utils::globalVariables(c(""OR"", ""lower"", ""upper"", ""p"", ""pa"", ""shape""))
-
 #' @title Plot estimates of multiple fitted glm(er)'s
 #' @name sjp.glmm
 #' 
@@ -120,7 +117,8 @@ sjp.glmm <- function(...,
   # check length. if we have a list of fitted model, 
   # we need to ""unlist"" them
   # --------------------------------------------------------
-  if (length(input_list) == 1 && class(input_list[[1]]) == ""list"") input_list <- lapply(input_list[[1]], function(x) x)
+  if (length(input_list) == 1 && class(input_list[[1]]) == ""list"") 
+    input_list <- lapply(input_list[[1]], function(x) x)
   # ----------------------------
   # init final data frame
   # ----------------------------
@@ -131,13 +129,8 @@ sjp.glmm <- function(...,
   # ----------------------------
   # if we have no labels of dependent variables supplied, use a 
   # default string (Model) for legend
-  if (is.null(depvar.labels)) {
-    depvar.labels <- c()
-    for (i in seq_len(fitlength)) {
-      depvar.labels <- c(depvar.labels, 
-                         get_model_response_label(input_list[[i]]))
-    }
-  }
+  if (is.null(depvar.labels))
+    depvar.labels <- unname(unlist(lapply(input_list, get_model_response_label)))
   # check length of diagram title and split longer string at into new lines
   if (!is.null(title)) title <- sjmisc::word_wrap(title, wrap.title)
   # check length of x-axis title and split longer string at into new lines
@@ -187,23 +180,19 @@ sjp.glmm <- function(...,
     # non-significant values can be drawn with a lesser alpha-level
     # (i.e. are more transparent)
     palpha <- NULL
-    for (i in 1:length(pv)) {
+    for (i in seq_len(length(pv))) {
       ps[i] <- """"
       pointshapes[i] <- 1
       palpha[i] <- ""s""
     }
     # ----------------------------
     # copy OR-values into data column
     # ----------------------------
-    if (show.values) {
-      for (i in 1:length(pv)) {
-        ps[i] <- sprintf(""%.*f"", digits, ov[i])
-      }
-    }
+    if (show.values) ps <- sprintf(""%.*f"", digits, ov)
     # ----------------------------
     # copy p-values into data column
     # ----------------------------
-    for (i in 1:length(pv)) {
+    for (i in seq_len(length(pv))) {
       if (pv[i] >= 0.05) {
         pointshapes[i] <- 1
         palpha[i] <- ""ns""
@@ -247,15 +236,15 @@ sjp.glmm <- function(...,
   if (!is.null(remove.estimates)) {
     # get row indices of rows that should be removed
     remrows <- c()
-    for (re in 1:length(remove.estimates)) {
+    for (re in seq_len(length(remove.estimates))) {
       remrows <- c(remrows, which(substr(row.names(finalodds), 
                                          start = 1, 
                                          stop = nchar(remove.estimates[re])) == remove.estimates[re]))
     }
     # remember old rownames
     keepnames <- row.names(finalodds)[-remrows]
     # remove rows
-    finalodds <- dplyr::slice(finalodds, c(1:nrow(finalodds))[-remrows])
+    finalodds <- dplyr::slice(finalodds, seq_len(nrow(finalodds))[-remrows])
     # set back rownames
     row.names(finalodds) <- keepnames
   }
@@ -311,11 +300,8 @@ sjp.glmm <- function(...,
   # The order of aesthetics matters in terms of ordering the error bars!
   # Using alpha-aes before colour would order error-bars according to
   # alpha-level instead of colour-aes.
-  plotHeader <- ggplot(finalodds, aes(y = OR, 
-                                      x = xpos, 
-                                      group = grp,
-                                      colour = grp, 
-                                      alpha = pa))
+  plotHeader <- ggplot(finalodds, aes_string(y = ""OR"", x = ""xpos"", group = ""grp"",
+                                             colour = ""grp"", alpha = ""pa""))
   # --------------------------------------------------------
   # start with dot-plotting here
   # first check, whether user wants different shapes for
@@ -329,7 +315,7 @@ sjp.glmm <- function(...,
       # The order of aesthetics matters in terms of ordering the error bars!
       # Using shape before colour would order points according to shapes instead
       # of colour-aes.
-      geom_point(aes(shape = shape), 
+      geom_point(aes_string(shape = ""shape""), 
                  size = geom.size, 
                  position = position_dodge(-geom.spacing)) +
       # and use a shape scale, in order to have a legend
@@ -349,11 +335,11 @@ sjp.glmm <- function(...,
   # --------------------------------------------------------
   plotHeader <- plotHeader +
     # print confidence intervalls (error bars)
-    geom_errorbar(aes(ymin = lower, ymax = upper), 
+    geom_errorbar(aes_string(ymin = ""lower"", ymax = ""upper""), 
                   width = 0, 
                   position = position_dodge(-geom.spacing)) +
     # print value labels and p-values
-    geom_text(aes(label = p, y = upper), 
+    geom_text(aes_string(label = ""p"", y = ""upper""), 
               position = position_dodge(width = -geom.spacing), 
               hjust = -0.1,
               show.legend = FALSE) +
@@ -406,7 +392,7 @@ sjp.glmm <- function(...,
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------
-  if (prnt.plot) graphics::plot(plotHeader)
+  if (prnt.plot) suppressWarnings(graphics::plot(plotHeader))
   # -------------------------------------
   # set proper column names
   # -------------------------------------

---FILE: R/sjTabItemAnalysis.R---
@@ -121,7 +121,7 @@
 #'  
 #' @importFrom psych describe
 #' @importFrom stats shapiro.test
-#' @importFrom sjstats reliab_test mean_n mic cronb
+#' @importFrom sjstats reliab_test mean_n mic cronb std
 #' @export
 sjt.itemanalysis <- function(df,
                              factor.groups = NULL,
@@ -206,7 +206,7 @@ sjt.itemanalysis <- function(df,
   # -----------------------------------
   # iterate all sub-scales (groups)
   # -----------------------------------
-  for (i in 1:length(findex)) {
+  for (i in seq_len(length(findex))) {
     # -----------------------------------
     # retrieve sub-scale
     # -----------------------------------
@@ -249,7 +249,7 @@ sjt.itemanalysis <- function(df,
     # to compute correlation coefficients between identified components
     # -----------------------------------
     df.subcc <- subset(df, select = which(factor.groups == findex[i]))
-    comcor <- scale(apply(df.subcc, 1, sum), center = TRUE, scale = TRUE)
+    comcor <- sjstats::std(rowSums(df.subcc))
     # -----------------------------------
     # check if we have valid return values from reliability test.
     # In case df had less than 3 columns, NULL is returned
@@ -309,7 +309,7 @@ sjt.itemanalysis <- function(df,
   # create data frame with index scores,
   # including missings
   # -----------------------------------
-  for (i in 1:length(index.scores)) {
+  for (i in seq_len(length(index.scores))) {
     # column names equal row-index-values
     index <- as.numeric(names(index.scores[[i]]))
     # fill df with index-score-values
@@ -323,7 +323,7 @@ sjt.itemanalysis <- function(df,
   # -----------------------------------
   # iterate all data frames etc.
   # -----------------------------------
-  for (i in 1:length(df.ia)) {
+  for (i in seq_len(length(df.ia))) {
     # check if we have titles for each component-table
     if (!is.null(factor.groups.titles)) dftitle <- factor.groups.titles[i]
     # get html-table from data frame
@@ -354,7 +354,7 @@ sjt.itemanalysis <- function(df,
                                  nrow = nrow(df), 
                                  byrow = FALSE))
       # give proper columm names
-      colnames(df.cc) <- sprintf(""Component %i"", c(1:ncol(df.cc)))
+      colnames(df.cc) <- sprintf(""Component %i"", seq_len(ncol(df.cc)))
       # compute correlation table, store html result
       html <- sjt.corr(df.cc,
                        na.deletion = ""listwise"", 

---FILE: man/sjp.lmer.Rd---
@@ -332,7 +332,7 @@ sjp.lmer(fit, type = ""poly"", poly.term = ""barthel"")
 
 # lme4 complaints about scale of polynomial term, so
 # try centering this predictor
-mydf$barthel_s <- scale(mydf$barthel, center = TRUE, scale = TRUE)
+mydf$barthel_s <- sjstats::std(mydf$barthel)
 
 # re-fit model
 fit_s <- lmer(neg_c_7 ~ sex + c12hour + barthel_s +"
strengejacke,sjPlot,b48176ab3c329d2f9af515467b4a8dfb6551cf08,Daniel Ldecke,d.luedecke@uke.de,2016-11-26T18:28:23Z,Daniel Ldecke,d.luedecke@uke.de,2016-11-26T18:28:23Z,also fix sjp.grpfrq,NEWS;NEWS.md;R/sjPlotGroupFrequencies.R,False,True,True,False,3,3,6,"---FILE: NEWS---
@@ -5,7 +5,7 @@ Changes to functions:
 * Plot and axis titles from effect-plots can now be changed with `title` or `axis.title` argument. Use a character vector of length > 1 to define (axis) titles for each plot or facet; use `""""` to remove the plot.
 
 Bug fixes:
-* Restored order of categories in `sjp.xtab()` for stacked bars (`position_stack()` reversed order since  last ggplot2-update), so labels are now incorreclty positioned again.
+* Restored order of categories in `sjp.xtab()` and `sjp.grpfrq()` for stacked bars (`position_stack()` reversed order since  last ggplot2-update), so labels are now incorreclty positioned again.
 
 
 Version 2.1.2

---FILE: NEWS.md---
@@ -7,7 +7,7 @@
 
 ## Bug fixes
 
-* Restored order of categories in `sjp.xtab()` for stacked bars (`position_stack()` reversed order since  last ggplot2-update), so labels are now incorreclty positioned again.
+* Restored order of categories in `sjp.xtab()` and `sjp.grpfrq()` for stacked bars (`position_stack()` reversed order since  last ggplot2-update), so labels are now incorreclty positioned again.
 
 # sjPlot 2.1.2
 

---FILE: R/sjPlotGroupFrequencies.R---
@@ -585,7 +585,7 @@ sjp.grpfrq <- function(var.cnt,
       geob <- geom_bar(stat = ""identity"", width = geom.size,
                        position = position_dodge(posdodge))
     } else {
-      geob <- geom_bar(stat = ""identity"", width = geom.size, position = ""stack"")
+      geob <- geom_bar(stat = ""identity"", width = geom.size, position = position_stack(reverse = TRUE))
     }
   } else if (type == ""line"") {
     if (smooth.lines) {"
strengejacke,sjPlot,b9500953e9e9ff530a345587d8069e6f15e5ada1,Daniel Ldecke,d.luedecke@uke.de,2016-11-12T14:24:10Z,Daniel Ldecke,d.luedecke@uke.de,2016-11-12T14:24:10Z,fixed misspelling of CSS-attribute in sjt-df,R/sjTabDataFrame.R,False,True,True,False,3,3,6,"---FILE: R/sjTabDataFrame.R---
@@ -193,7 +193,7 @@ sjt.df <- function(mydf,
   css.firsttablerow <- ""border-bottom:1px solid black;""
   css.firsttablecol <- """"
   css.leftalign <- ""text-align:left;""
-  css.centertalign <- ""text-align:center;""
+  css.centeralign <- ""text-align:center;""
   css.comment <- ""font-style:italic; border-top:double black; text-align:right;""
   if (show.cmmn.row && repeat.header) css.comment <- ""font-style:italic; text-align:right;""
   # ------------------------
@@ -219,7 +219,7 @@ sjt.df <- function(mydf,
                         tag.table, css.table, tag.caption, css.caption,
                         tag.thead, css.thead, tag.tdata, css.tdata, tag.arc, css.arc,
                         tag.lasttablerow, css.lasttablerow, tag.firsttablerow, css.firsttablerow,
-                        tag.leftalign, css.leftalign, tag.centertalign, css.centertalign,
+                        tag.leftalign, css.leftalign, tag.centertalign, css.centeralign,
                         tag.firsttablecol, css.firsttablecol, tag.comment, css.comment)
   toWrite <- sprintf(""<html>\n<head>\n<meta http-equiv=\""Content-type\"" content=\""text/html;charset=%s\"">\n%s\n</head>\n<body>\n"", encoding, page.style)
   # -------------------------------------
@@ -335,7 +335,7 @@ sjt.df <- function(mydf,
   knitr <- gsub(tag.firsttablerow, css.firsttablerow, knitr, fixed = TRUE, useBytes = TRUE)
   knitr <- gsub(tag.firsttablecol, css.firsttablecol, knitr, fixed = TRUE, useBytes = TRUE)
   knitr <- gsub(tag.leftalign, css.leftalign, knitr, fixed = TRUE, useBytes = TRUE)
-  knitr <- gsub(tag.centertalign, css.centertalign, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.centertalign, css.centeralign, knitr, fixed = TRUE, useBytes = TRUE)
   # -------------------------------------
   # remove spaces?
   # -------------------------------------"
strengejacke,sjPlot,a680c0f480b820efdad94209961c70ebc45423aa,Daniel Ldecke,d.luedecke@uke.de,2016-11-12T13:43:24Z,Daniel Ldecke,d.luedecke@uke.de,2016-11-12T13:43:24Z,"Fixed bug in `sjp.lmm()`, which caused an error for plotting multiple mixed models when `type = ""std""` or `type = ""std2""`.",NEWS;NEWS.md;R/sjPlotLinregMultiple.R;R/sjPlotOdds.R,False,True,True,False,7,5,12,"---FILE: NEWS---
@@ -9,7 +9,7 @@ Changes to functions:
 Bug fixes:
 * Fixed bug in `sjplot()` that caused figures not being plotted in certain situations.
 * Fixed bug in `sjp.lmm()`, which caused an error for plotting multiple mixed models when Intercept was hidden.
-* Fixed bug in `sjp.lmm()`, which caused an error for `type = ""std""` or `type = ""std2""`.
+* Fixed bug in `sjp.lmm()`, which caused an error for plotting multiple mixed models when `type = ""std""` or `type = ""std2""`.
 
 Version 2.1.1
 -----------------------------------------------------------------------------

---FILE: NEWS.md---
@@ -12,7 +12,7 @@
 
 * Fixed bug in `sjplot()` that caused figures not being plotted in certain situations.
 * Fixed bug in `sjp.lmm()`, which caused an error for plotting multiple mixed models when Intercept was hidden.
-* Fixed bug in `sjp.lmm()`, which caused an error for `type = ""std""` or `type = ""std2""`.
+* Fixed bug in `sjp.lmm()`, which caused an error for plotting multiple mixed models when `type = ""std""` or `type = ""std2""`.
 
 # sjPlot 2.1.1
 

---FILE: R/sjPlotLinregMultiple.R---
@@ -170,6 +170,8 @@ sjp.lmm <- function(...,
         dplyr::select_(""-std.error"")
       # no intercept for std
       show.intercept <- FALSE
+      # remove intercept for merMod
+      if (is_merMod(fit)) betas <- betas[-1, ]
       # add ""std."" to title?
       if (axis.title == ""Estimates"") axis.title <- ""Std. Estimates""
     } else {
@@ -194,7 +196,7 @@ sjp.lmm <- function(...,
     # retrieve sigificance level of independent variables (p-values)
     pv <- sjstats::get_model_pval(fit, p.kr = p.kr)$p.value
     # remove intercept from df, if necessary
-    if (type == ""lm"" && !show.intercept) pv <- pv[-1]
+    if (!show.intercept) pv <- pv[-1]
     # for better readability, convert p-values to asterisks
     # with:
     # p < 0.001 = ***

---FILE: R/sjPlotOdds.R---
@@ -638,7 +638,7 @@ sjp.glm.slope <- function(fit, title, geom.size, geom.colors, remove.estimates,
         y.limits <- ylim
       }
       # create single plots for each numeric predictor
-      mp <- ggplot(mydf.metricpred[[i]], aes(x = values, y = y)) +
+      mp <- ggplot(mydf.metricpred[[i]], aes_string(x = ""values"", y = ""y"")) +
         labs(x = axisLabels.mp[i], y = y.title, title = title)
       # special handling for negativ binomial
       if (sjmisc::str_contains(fitfam$family, ""negative binomial"", ignore.case = T)) {
@@ -672,7 +672,7 @@ sjp.glm.slope <- function(fit, title, geom.size, geom.colors, remove.estimates,
       } else {
         y.limits <- ylim
       }
-      mp <- ggplot(mydf.ges, aes(x = values, y = y)) +
+      mp <- ggplot(mydf.ges, aes_string(x = ""values"", y = ""y"")) +
         labs(x = NULL, y = y.title, title = title)
       # special handling for negativ binomial
       if (sjmisc::str_contains(fitfam$family, ""negative binomial"", ignore.case = T)) {"
strengejacke,sjPlot,ebee14e5c513f61cdb3ea461a3c6cee794f6d344,Daniel Ldecke,d.luedecke@uke.de,2016-11-12T09:49:40Z,Daniel Ldecke,d.luedecke@uke.de,2016-11-12T09:49:40Z,"Fixed bug in `sjp.lmm()`, which caused an error for `type = ""std""` or `type = ""std2""`",DESCRIPTION;NEWS;NEWS.md;R/sjPlotLinregMultiple.R,False,True,True,False,8,6,14,"---FILE: DESCRIPTION---
@@ -25,13 +25,13 @@ Imports:
     broom (>= 0.4.1),
     dplyr (>= 0.5.0),
     effects,
-    ggplot2 (>= 2.1.0),
+    ggplot2 (>= 2.2.0),
     lme4 (>= 1.1-10),
     nlme,
     psych,
     scales,
     sjmisc (>= 2.0.1),
-    sjstats (>= 0.5.0),
+    sjstats (>= 0.6.0),
     tibble (>= 1.2.0),
     tidyr (>= 0.6.0)
 Suggests:

---FILE: NEWS---
@@ -9,6 +9,7 @@ Changes to functions:
 Bug fixes:
 * Fixed bug in `sjplot()` that caused figures not being plotted in certain situations.
 * Fixed bug in `sjp.lmm()`, which caused an error for plotting multiple mixed models when Intercept was hidden.
+* Fixed bug in `sjp.lmm()`, which caused an error for `type = ""std""` or `type = ""std2""`.
 
 Version 2.1.1
 -----------------------------------------------------------------------------

---FILE: NEWS.md---
@@ -12,6 +12,7 @@
 
 * Fixed bug in `sjplot()` that caused figures not being plotted in certain situations.
 * Fixed bug in `sjp.lmm()`, which caused an error for plotting multiple mixed models when Intercept was hidden.
+* Fixed bug in `sjp.lmm()`, which caused an error for `type = ""std""` or `type = ""std2""`.
 
 # sjPlot 2.1.1
 

---FILE: R/sjPlotLinregMultiple.R---
@@ -164,7 +164,7 @@ sjp.lmm <- function(...,
     # ----------------------------
     # retrieve beta's (lm)
     # ----------------------------
-    if (type == ""std"" || type == ""std2"") {
+    if (type %in% c(""std"", ""std2"")) {
       # retrieve standardized betas
       betas <- suppressWarnings(sjstats::std_beta(fit, type = type)) %>% 
         dplyr::select_(""-std.error"")
@@ -193,8 +193,8 @@ sjp.lmm <- function(...,
     # ----------------------------
     # retrieve sigificance level of independent variables (p-values)
     pv <- sjstats::get_model_pval(fit, p.kr = p.kr)$p.value
-    #remove intercept from df
-    if (!show.intercept) pv <- pv[-1]
+    # remove intercept from df, if necessary
+    if (type == ""lm"" && !show.intercept) pv <- pv[-1]
     # for better readability, convert p-values to asterisks
     # with:
     # p < 0.001 = ***
@@ -265,7 +265,7 @@ sjp.lmm <- function(...,
                                          stop = nchar(remove.estimates[re])) == remove.estimates[re]))
     }
     # remove rows
-    finalbetas <- dplyr::slice(finalbetas, c(1:nrow(finalbetas))[-remrows])
+    finalbetas <- dplyr::slice(finalbetas, seq_len(nrow(finalbetas))[-remrows])
   }
   # set axis labels
   if (is.null(axis.labels)) {"
strengejacke,sjPlot,f213012eb09ed52ad1001ecd6beb5a2b9db86b04,Daniel Ldecke,d.luedecke@uke.de,2016-11-12T08:31:38Z,Daniel Ldecke,d.luedecke@uke.de,2016-11-12T08:31:38Z,"two fixes

* Fixed bug in `sjp.lmm()`, which caused an error for plotting multiple
mixed models when Intercept was hidden.
* Restored order of categories in `sjp.stackfrq()`, which were reversed
by the last ggplot2-update, where `position_stack()` now sort the
stacking order to match grouping order.",NEWS;NEWS.md;R/sjPlotLinregMultiple.R;R/sjPlotOddsMultiple.R;R/sjPlotStackFrequencies.R;man/sjt.glm.Rd,False,True,True,False,23,14,37,"---FILE: NEWS---
@@ -3,8 +3,12 @@ Version 2.1.2
 General:
 * Effect-plots from `sjp.int()`, `sjp.glm()` and `sjp.glmer()` now support the `transformation`-argument from the 'effects'-package. For example, when calling `sjp.glm(fit, type = ""eff"", transformation = NULL)`, predictions are on their original scale (y-scale) and the title for the y-scale is changed accordingly.
 
+Changes to functions:
+* Restored order of categories in `sjp.stackfrq()`, which were reversed by the last ggplot2-update, where `position_stack()` now sort the stacking order to match grouping order.
+
 Bug fixes:
-* Fixed bug in `sjplot` that caused figures not being plotted in certain situations.
+* Fixed bug in `sjplot()` that caused figures not being plotted in certain situations.
+* Fixed bug in `sjp.lmm()`, which caused an error for plotting multiple mixed models when Intercept was hidden.
 
 Version 2.1.1
 -----------------------------------------------------------------------------

---FILE: NEWS.md---
@@ -4,9 +4,14 @@
 
 * Effect-plots from `sjp.int()`, `sjp.glm()` and `sjp.glmer()` now support the `transformation`-argument from the __effects__-package. For example, when calling `sjp.glm(fit, type = ""eff"", transformation = NULL)`, predictions are on their original scale (y-scale) and the title for the y-scale is changed accordingly.
 
+## Changes to functions
+
+* Restored order of categories in `sjp.stackfrq()`, which were reversed by the last ggplot2-update, where `position_stack()` now sort the stacking order to match grouping order.
+
 ## Bug fixes
 
-* Fixed bug in `sjplot` that caused figures not being plotted in certain situations.
+* Fixed bug in `sjplot()` that caused figures not being plotted in certain situations.
+* Fixed bug in `sjp.lmm()`, which caused an error for plotting multiple mixed models when Intercept was hidden.
 
 # sjPlot 2.1.1
 

---FILE: R/sjPlotLinregMultiple.R---
@@ -180,9 +180,9 @@ sjp.lmm <- function(...,
         # copy estimates to data frame
         betas <- data.frame(stats::coef(fit), stats::confint(fit))
         betas <- tibble::rownames_to_column(betas, var = ""term"")
-        # show intercept?
-        if (!show.intercept) betas <- betas[-1, ]
       }
+      # show intercept?
+      if (!show.intercept) betas <- betas[-1, ]
     }
     # ----------------------------
     # give proper column names

---FILE: R/sjPlotOddsMultiple.R---
@@ -150,7 +150,7 @@ sjp.glmm <- function(...,
   # ----------------------------
   # iterate all fitted models
   # ----------------------------
-  for (fitcnt in 1:fitlength) {
+  for (fitcnt in seq_len(fitlength)) {
     # retrieve fitted model
     fit <- input_list[[fitcnt]]
     # ----------------------------

---FILE: R/sjPlotStackFrequencies.R---
@@ -139,7 +139,7 @@ sjp.stackfrq <- function(items,
   if (is.null(axis.labels)) {
     axis.labels <- c()
     # if yes, iterate each variable
-    for (i in 1:ncol(items)) {
+    for (i in seq_len(ncol(items))) {
       # retrieve variable name attribute
       axis.labels <- c(axis.labels, sjmisc::get_label(items[[i]], def.value = colnames(items)[i]))
     }
@@ -170,7 +170,7 @@ sjp.stackfrq <- function(items,
   # axis labels
   # --------------------------------------------------------
   if (show.n) {
-    for (i in 1:length(axis.labels)) {
+    for (i in seq_len(length(axis.labels))) {
       axis.labels[i] <- paste(axis.labels[i], 
                               sprintf("" (n=%i)"", length(stats::na.omit(items[[i]]))), 
                               sep = """")
@@ -197,7 +197,7 @@ sjp.stackfrq <- function(items,
     diff <- ifelse(min(items, na.rm = TRUE) == 0, 1, 0)
   }
   # iterate item-list
-  for (i in 1:ncol(items)) {
+  for (i in seq_len(ncol(items))) {
     # get each single items
     variable <- items[[i]]
     # -----------------------------------------------
@@ -225,7 +225,7 @@ sjp.stackfrq <- function(items,
     # create new data frame. We now have a data frame with all
     # variable categories abd their related percentages, including
     # zero counts, but no(!) missings!
-    mydf <- data.frame(grp = i, cat = 1:countlen, prc)
+    mydf <- data.frame(grp = i, cat = seq_len(countlen), prc)
     # now, append data frames
     mydat <- data.frame(rbind(mydat, mydf))
   }
@@ -266,7 +266,7 @@ sjp.stackfrq <- function(items,
       facord <- order(mydat$prc[which(mydat$cat == countlen)])
     }
     # create dummy vectors from 1 to itemlength
-    dummy1 <- dummy2 <- c(1:length(facord))
+    dummy1 <- dummy2 <- seq_len(length(facord))
     # facords holds the ordered item indices! we now need to
     # change the original item-index with its ordered position index.
     # example:
@@ -285,7 +285,7 @@ sjp.stackfrq <- function(items,
     # now we have the order of either lowest to highest counts of first
     # or last category of ""items"". We now need to repeat these values as 
     # often as we have answer categories
-    orderedrow <- unlist(tapply(dummy2, 1:length(dummy2), function(x) rep(x, countlen)))
+    orderedrow <- unlist(tapply(dummy2, seq_len(length(dummy2)), function(x) rep(x, countlen)))
     # replace old grp-order by new order
     mydat$grp <- as.factor(orderedrow)
     # reorder axis labels as well
@@ -333,7 +333,7 @@ sjp.stackfrq <- function(items,
   }  
   baseplot <- baseplot +
     # plot bar chart
-    geom_bar(stat = ""identity"", position = ""stack"", width = geom.size)
+    geom_bar(stat = ""identity"", position = position_stack(reverse = TRUE), width = geom.size)
   # -----------------
   # show/hide percentage values on x axis
   # ----------------------------

---FILE: man/sjt.glm.Rd---
@@ -268,7 +268,7 @@ library(sjmisc)
 # load efc sample data
 data(efc)
 # dichtomozize service usage by ""service usage yes/no""
-efc$services <- sjmisc::dicho(efc$tot_sc_e, 0, as.num = TRUE)
+efc$services <- sjmisc::dicho(efc$tot_sc_e, dich.by = 0, as.num = TRUE)
 # fit 3 models with different link-functions
 fit1 <- glm(services ~ neg_c_7 + c161sex + e42dep,
             data = efc, family = binomial(link = ""logit""))
@@ -300,7 +300,7 @@ library(sjmisc)
 # load efc sample data
 data(efc)
 # dichtomozize service usage by ""service usage yes/no""
-efc$services <- sjmisc::dicho(efc$tot_sc_e, 0, as.num = TRUE)
+efc$services <- sjmisc::dicho(efc$tot_sc_e, dich.by = 0, as.num = TRUE)
 # make dependency categorical
 efc$e42dep <- to_factor(efc$e42dep)
 # fit model with ""grouped"" predictor"
strengejacke,sjPlot,a310d2e88ef27cbe3259830925ce142c135740d2,Daniel Ldecke,d.luedecke@uke.de,2016-11-01T18:38:56Z,Daniel Ldecke,d.luedecke@uke.de,2016-11-01T18:38:56Z,"CRAN release 2.1.1, with bugfix for 2.1.2",DESCRIPTION;NEWS;NEWS.md;R/sjPlotFrequencies.R;R/sjPlotOdds.R;R/sjPlotScatter.R;R/sjplot.R;man/sjPlot-package.Rd;man/sjp.frq.Rd;man/sjp.scatter.Rd,False,True,True,False,26,13,39,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 2.1.0
-Date: 2016-09-27
+Version: 2.1.1
+Date: 2016-11-01
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of plotting and table output functions for data

---FILE: NEWS---
@@ -1,3 +1,8 @@
+Version 2.1.2
+-----------------------------------------------------------------------------
+Bug fixes:
+* Fixed bug in `sjplot` that caused figures not being plotted in certain situations.
+
 Version 2.1.1
 -----------------------------------------------------------------------------
 General:

---FILE: NEWS.md---
@@ -1,3 +1,9 @@
+# sjPlot 2.1.2
+
+## Bug fixes
+
+* Fixed bug in `sjplot` that caused figures not being plotted in certain situations.
+
 # sjPlot 2.1.1
 
 ## General

---FILE: R/sjPlotFrequencies.R---
@@ -57,7 +57,7 @@ utils::globalVariables(c(""val"", ""frq"", ""grp"", ""label.pos"", ""upper.ci"", ""lower.ci
 #' @inheritParams sjp.glmer
 #' 
 #' @return (Insisibily) returns the ggplot-object with the complete plot (\code{plot}) as well as the data frame that
-#'           was used for setting up the ggplot-object (\code{mydf}).
+#'           was used for setting up the ggplot-object (\code{data}).
 #' 
 #' @examples
 #' # boxplot
@@ -561,5 +561,5 @@ sjp.frq <- function(var.cnt,
   # -------------------------------------
   invisible(structure(class = ""sjpfrq"",
                       list(plot = baseplot,
-                           mydf = mydat)))
+                           data = mydat)))
 }

---FILE: R/sjPlotOdds.R---
@@ -643,7 +643,8 @@ sjp.glm.slope <- function(fit, title, geom.size, geom.colors, remove.estimates,
       # special handling for negativ binomial
       if (sjmisc::str_contains(fitfam$family, ""negative binomial"", ignore.case = T)) {
         mp <- mp +
-          stat_smooth(method = ""glm.nb"",
+          stat_smooth(method = ""glm"", 
+                      method.args = list(family = ""poisson""), 
                       se = show.ci,
                       size = geom.size,
                       colour = geom.colors)
@@ -676,7 +677,8 @@ sjp.glm.slope <- function(fit, title, geom.size, geom.colors, remove.estimates,
       # special handling for negativ binomial
       if (sjmisc::str_contains(fitfam$family, ""negative binomial"", ignore.case = T)) {
         mp <- mp +
-          stat_smooth(method = ""glm.nb"", 
+          stat_smooth(method = ""glm"", 
+                      method.args = list(family = ""poisson""), 
                       se = show.ci,
                       size = geom.size,
                       colour = geom.colors)

---FILE: R/sjPlotScatter.R---
@@ -47,7 +47,7 @@
 #'          in the graph.
 #'
 #' @return (Insisibily) returns the ggplot-object with the complete plot (\code{plot}) as well as the data frame that
-#'           was used for setting up the ggplot-object (\code{df}).
+#'           was used for setting up the ggplot-object (\code{data}).
 #'
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjp.lm
@@ -362,5 +362,5 @@ sjp.scatter <- function(x = NULL,
   # -------------------------------------
   invisible(structure(class = ""sjpscatter"",
                       list(plot = scatter,
-                           df = df)))
+                           data = df)))
 }

---FILE: R/sjplot.R---
@@ -104,8 +104,8 @@ sjplot <- function(.data, ..., fun = c(""frq"", ""grpfrq"", ""xtab"", ""gpt"", ""scatter""
   
   # choose plottype, and call plot-function with or w/o additional arguments
   if (sjmisc::is_empty(args)) {
-    pl <- list()
     if (fun == ""frq"") {
+      pl <- list()
       for (i in seq_len(ncol(x))) {
         pl[[length(pl) + 1]] <- sjp.frq(x[[i]], prnt.plot = F)$plot
       }

---FILE: man/sjPlot-package.Rd---
@@ -36,8 +36,8 @@ The package supports labelled data, i.e. value and variable labels from labelled
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 2.1.0\cr
-Date: \tab 2016-09-27\cr
+Version: \tab 2.1.1\cr
+Date: \tab 2016-11-01\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjp.frq.Rd---
@@ -169,7 +169,7 @@ want to plot any graphs. In either case, the ggplot-object will be returned as v
 }
 \value{
 (Insisibily) returns the ggplot-object with the complete plot (\code{plot}) as well as the data frame that
-          was used for setting up the ggplot-object (\code{mydf}).
+          was used for setting up the ggplot-object (\code{data}).
 }
 \description{
 Plot frequencies of a variable as bar graph, histogram,

---FILE: man/sjp.scatter.Rd---
@@ -111,7 +111,7 @@ want to plot any graphs. In either case, the ggplot-object will be returned as v
 }
 \value{
 (Insisibily) returns the ggplot-object with the complete plot (\code{plot}) as well as the data frame that
-          was used for setting up the ggplot-object (\code{df}).
+          was used for setting up the ggplot-object (\code{data}).
 }
 \description{
 Display scatter plot of two variables. Adding a grouping variable to"
strengejacke,sjPlot,a3f300b66bddbaef920ccb8a6a1fbeb82145072a,Daniel Ldecke,d.luedecke@uke.de,2016-10-11T19:00:23Z,Daniel Ldecke,d.luedecke@uke.de,2016-10-11T19:00:23Z,"code-style, ggplot-fixes",R/helpfunctions.R;R/sjPlotAnova.R;R/sjPlotCorr.R;R/sjPlotPCA.R;R/sjPlotPropTable.R;R/sjPlotScatter.R;man/sjp.corr.Rd,False,True,True,False,60,103,163,"---FILE: R/helpfunctions.R---
@@ -44,7 +44,7 @@ get_lm_data <- function(fit) {
     depvar.label <- sjstats::resp_var(fit)
   }
   # get variable label label
-  depvar.label <- sjmisc::get_label(resp, depvar.label)
+  depvar.label <- unname(sjmisc::get_label(x = resp, def.value = depvar.label))
   return(list(matrix = fit_x, resp.label = depvar.label, resp = resp))
 }
 
@@ -484,7 +484,7 @@ retrieveModelGroupIndices <- function(models, rem_rows = NULL) {
   # retrieve fitted models
   # ------------------------
   # go through fitted models
-  for (k in 1:length(models)) {
+  for (k in seq_len(length(models))) {
     # get model
     fit <- models[[k]]
     # copy model frame
@@ -716,7 +716,7 @@ unlistlabels <- function(lab) {
 
 get_model_response_label <- function(fit) {
   m_f <- stats::model.frame(fit)
-  sjmisc::get_label(m_f[[1]], def.value = colnames(m_f)[1])
+  unname(sjmisc::get_label(m_f[[1]], def.value = colnames(m_f)[1]))
 }
 
 

---FILE: R/sjPlotAnova.R---
@@ -169,15 +169,15 @@ sjp.aov1 <- function(var.dep,
   # print coefficients and p-values in plot
   # ----------------------------
   # init data column for p-values
-  ps <- c(round(means, digits))
+  ps <- round(means, digits)
   # if no values should be shown, clear
   # vector now
   if (!show.values) ps <- rep("""", length(ps))
   # --------------------------------------------------------
   # copy p-values into data column
   # --------------------------------------------------------
   if (show.p) {
-    for (i in 1:length(means.p)) {
+    for (i in seq_len(length(means.p))) {
       ps[i] <- sjmisc::trim(paste(ps[i], get_p_stars(means.p[i])))
     }  
   }
@@ -186,9 +186,9 @@ sjp.aov1 <- function(var.dep,
   # or not
   # --------------------------------------------------------
   if (rev.order)
-    catorder <- c(length(means):1)
+    catorder <- length(means):1
   else
-    catorder <- c(1:length(means))
+    catorder <- seq_len(length(means))
   # --------------------------------------------------------
   # create new data.frame, since ggplot requires data.frame as parameter
   # The data frame contains means, CI and p-values
@@ -241,7 +241,7 @@ sjp.aov1 <- function(var.dep,
   if (is.null(grid.breaks))
     ticks <- pretty(c(lower_lim, upper_lim))
   else
-    ticks <- c(seq(lower_lim, upper_lim, by = grid.breaks))
+    ticks <- seq(lower_lim, upper_lim, by = grid.breaks)
   # --------------------------------------------------------
   # Set up plot padding (margins inside diagram)
   # --------------------------------------------------------

---FILE: R/sjPlotCorr.R---
@@ -11,8 +11,6 @@ utils::globalVariables(c(""ordx"", ""ordy""))
 #' @param data matrix with correlation coefficients as returned by the 
 #'          \code{\link{cor}}-function, or a \code{data.frame} of variables where
 #'          correlations between columns should be computed.
-#' @param type indicates whether the geoms of correlation values should be plotted
-#'          as \code{""circle""} (default) or as \code{""tile""}.
 #' @param sort.corr logical, if \code{TRUE} (default), the axis labels are sorted
 #'          according to the correlation strength. If \code{FALSE}, axis labels
 #'          appear in order of how variables were included in the cor-computation or
@@ -52,12 +50,9 @@ utils::globalVariables(c(""ordx"", ""ordy""))
 #' mydf <- data.frame(cbind(runif(10), runif(10), runif(10), 
 #'                          runif(10), runif(10)))
 #'
-#' # plot correlation matrix using circles
+#' # plot correlation matrix
 #' sjp.corr(mydf)
 #'
-#' # plot correlation matrix using square tiles without diagram background
-#' sjp.corr(mydf, type = ""tile"")
-#'
 #' # -------------------------------
 #' # Data from the EUROFAMCARE sample dataset
 #' # -------------------------------
@@ -73,7 +68,7 @@ utils::globalVariables(c(""ordx"", ""ordy""))
 #' colnames(mydf) <- varlabs[vars.index]
 #'
 #' # show legend
-#' sjp.corr(mydf, type = ""tile"", show.legend = TRUE)
+#' sjp.corr(mydf, show.legend = TRUE)
 #'
 #' # -------------------------------
 #' # auto-detection of labels
@@ -91,13 +86,11 @@ utils::globalVariables(c(""ordx"", ""ordy""))
 sjp.corr <- function(data,
                      title = NULL,
                      axis.labels = NULL,
-                     type = c(""circle"", ""tile""),
                      sort.corr = TRUE,
                      decimals = 3,
                      na.deletion = c(""listwise"", ""pairwise""),
                      corr.method = c(""spearman"", ""pearson"", ""kendall""),
                      geom.colors = ""RdBu"",
-                     geom.size = 15,
                      wrap.title = 50,
                      wrap.labels = 20,
                      show.legend = FALSE,
@@ -120,12 +113,11 @@ sjp.corr <- function(data,
   # --------------------------------------------------------
   na.deletion <- match.arg(na.deletion)
   corr.method <- match.arg(corr.method)
-  type <- match.arg(type)
   # --------------------------------------------------------
   # try to automatically set labels is not passed as argument
   # --------------------------------------------------------
   if (is.null(axis.labels) && is.data.frame(data)) {
-    axis.labels <- sjmisc::get_label(data, def.value = colnames(data))
+    axis.labels <- unname(sjmisc::get_label(data, def.value = colnames(data)))
   }
   # ----------------------------
   # set color palette
@@ -166,7 +158,7 @@ sjp.corr <- function(data,
           test <- suppressWarnings(stats::cor.test(df[[i]], df[[j]], 
                                                    alternative = ""two.sided"", 
                                                    method = corr.method))
-          pv <- cbind(pv, round(test$p.value, 4))
+          pv <- c(pv, round(test$p.value, 4))
         }
         cp <- rbind(cp, pv)
       }
@@ -223,15 +215,7 @@ sjp.corr <- function(data,
   # if (!is.null(cpvalues)) cpvalues <- melt(cpvalues)
   # bind additional information like order for x- and y-axis
   # as well as the size of plotted points
-  orderedCorr <- cbind(orderedCorr, ordx = seq_len(nrow(corr)), ordy = yo, 
-                       psize = exp(abs(orderedCorr$value)) * geom.size)
-  # diagonal circles should be hidden, set their point size to 0
-  orderedCorr$psize[which(orderedCorr$value >= 0.999)] <- 0
-  # remove lower trianglwe of geoms
-  orderedCorr$psize[which(orderedCorr$ordx > orderedCorr$ordy)]  <- NA
-
-  orderedCorr$ordx <- as.factor(orderedCorr$ordx)
-  orderedCorr$ordy <- as.factor(orderedCorr$ordy)
+  orderedCorr <- cbind(orderedCorr, ordx = seq_len(nrow(corr)), ordy = yo)
   # --------------------------------------------------------
   # add column with significance value
   # --------------------------------------------------------
@@ -254,57 +238,42 @@ sjp.corr <- function(data,
   # set visibility of labels
   # --------------------------------------------------------
   if (!show.values) {
-    correlationValueLabels <- """"
-    correlationPValues <- """"
+    orderedCorr$val.labels <- """"
   } else {
-    correlationValueLabels <- ifelse(is.na(orderedCorr$psize), sprintf(""%.*f"", decimals, orderedCorr$value), """")
     if (show.p) {
-      correlationPValues <- ifelse(is.na(orderedCorr$psize), orderedCorr$ps, """")
+      orderedCorr$val.labels <- sprintf(""%.*f%s"", decimals, orderedCorr$value, orderedCorr$ps)
     } else {
-      correlationPValues <- """"
+      orderedCorr$val.labels <- sprintf(""%.*f"", decimals, orderedCorr$value)
     }
   }
+  orderedCorr$val.labels[orderedCorr$ordx >= orderedCorr$ordy] <- NA
+  
+  orderedCorr$ordx <- as.factor(orderedCorr$ordx)
+  orderedCorr$ordy <- as.factor(orderedCorr$ordy)
   message(sprintf(""Computing correlation using %s-method with %s-deletion..."", corr.method, na.deletion))
   # --------------------------------------------------------
   # start with base plot object here
   # --------------------------------------------------------
-  corrPlot <- ggplot(orderedCorr, aes_string(x = ""ordx"", y = ""ordy"", fill = ""value"", colour = ""value""))
-  # corrPlot <- ggplot(data=orderedCorr, aes(x=ordx, y=ordy, fill=value))
-  # --------------------------------------------------------
-  # determine the geom type, either points when ""type"" is ""circles""
-  # --------------------------------------------------------
-  if (type == ""circle"") {
-    corrPlot <- corrPlot +
-      geom_point(shape = 21, colour = ""black"", size = orderedCorr$size)
-  }
-  # --------------------------------------------------------
-  # or boxes / tiles when ""type"" is ""tile""
-  # --------------------------------------------------------
-  else {
-    corrPlot <- corrPlot + geom_tile()
-  }
+  corrPlot <- ggplot(orderedCorr, aes_string(x = ""ordx"", y = ""ordy"", fill = ""value"", label = ""val.labels"")) +
+    geom_tile(size = 0, colour = ""black"") +
   # fill gradient colour from distinct color brewer palette. negative correlations are dark
   # red, positive corr. are dark blue, and they become lighter the closer they are to a
   # correlation coefficient of zero
-  corrPlot <- corrPlot +
-    scale_x_discrete(labels = axis.labels) +
-    scale_y_discrete(labels = axis.labels) +
+    scale_x_discrete(labels = axis.labels, breaks = seq_len(length(axis.labels))) +
+    scale_y_discrete(labels = axis.labels, breaks = seq_len(length(axis.labels))) +
     # set limits to (-1,1) to make sure the whole color palette is used. this
     # is the colour scale for geoms
     scale_fill_gradientn(colours = geom.colors, limits = c(-1,1)) +
-    # and here we have the colour scale for the text labels
-    scale_colour_gradient2(low = ""#ca0020"", mid = ""grey40"", high = ""#0571b0"", limits = c(-1,1)) +
-    geom_text(label = sprintf(""%s%s"", correlationValueLabels, correlationPValues)) +
-    labs(title = title, x = NULL, y = NULL, fill = legend.title)
-  if (show.legend) {
-    corrPlot <- corrPlot + guides(colour = FALSE)
-  } else {
-    corrPlot <- corrPlot + guides(fill = FALSE, colour = FALSE)
-  }
+    geom_text(size = 3.5, colour = ""black"") +
+    labs(title = title, x = NULL, y = NULL)
+  if (show.legend)  
+    corrPlot <- corrPlot + guides(fill = legend.title)
+  else
+    corrPlot <- corrPlot + guides(fill = ""none"")
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------
-  if (prnt.plot) graphics::plot(corrPlot)
+  if (prnt.plot) suppressWarnings(graphics::plot(corrPlot))
   # -------------------------------------
   # return results
   # -------------------------------------

---FILE: R/sjPlotPCA.R---
@@ -118,11 +118,11 @@ sjp.pca <- function(data,
   # --------------------------------------------------------
   if (is.null(axis.labels) && is.data.frame(data)) {
     # if yes, iterate each variable
-    for (i in 1:ncol(data)) {
+    for (i in seq_len(ncol(data))) {
       # retrieve variable name attribute and
       # if variable has attribute, add to variableLabel list
       axis.labels <- c(axis.labels,
-                       sjmisc::get_label(data[[i]], def.value = colnames(data)[i]))
+                       unname(sjmisc::get_label(data[[i]], def.value = colnames(data)[i])))
     }
   }
   # ----------------------------
@@ -186,7 +186,7 @@ sjp.pca <- function(data,
   pcadata.varim <- varimaxrota(pcadata, pcadata.kaiser)
   # pcadata.varim = varimax(loadings(pcadata))
   # create data frame with factor loadings
-  df <- as.data.frame(pcadata.varim$loadings[, 1:ncol(pcadata.varim$loadings)])
+  df <- as.data.frame(pcadata.varim$loadings[, seq_len(ncol(pcadata.varim$loadings))])
   # df <- as.data.frame(pcadata.varim$rotmat[, 1:pcadata.kaiser])
   # ----------------------------
   # check if user defined labels have been supplied
@@ -210,7 +210,7 @@ sjp.pca <- function(data,
     removers <- c()
     # iterate each row of the data frame. each row represents
     # one item with its factor loadings
-    for (i in 1:nrow(dataframe)) {
+    for (i in seq_len(nrow(dataframe))) {
       # get factor loadings for each item
       rowval <- as.numeric(abs(df[i, ]))
       # retrieve highest loading
@@ -250,7 +250,7 @@ sjp.pca <- function(data,
     # clear vector
     cbv <- c()
     # iterate all highest factor loadings of items
-    for (n in 1:length(unique(itemloadings))) {
+    for (n in seq_len(length(unique(itemloadings)))) {
       # calculate cronbach's alpha for those cases that all have the
       # highest loading on the same factor
       cbv <- as.data.frame(rbind(cbv, cbind(nr = n, sjstats::cronb(stats::na.omit(dataframe[, which(itemloadings == n)])))))
@@ -286,11 +286,11 @@ sjp.pca <- function(data,
   # considered as ""equally"" is defined via fctr.load.tlrn
   removableItems <- getRemovableItems(df)
   # rename columns, so we have numbers on x axis
-  names(df) <- 1:ncol(df)
+  names(df) <- seq_len(ncol(df))
   # convert to long data
-  df <- tidyr::gather(df, ""xpos"", ""value"", 1:ncol(df), factor_key = TRUE)  
+  df <- tidyr::gather(df, ""xpos"", ""value"", seq_len(ncol(df)), factor_key = TRUE)  
   # we need new columns for y-positions and point sizes
-  df <- cbind(df, ypos = 1:nrow(pcadata.varim$loadings), psize = exp(abs(df$value)) * geom.size)
+  df <- cbind(df, ypos = seq_len(nrow(pcadata.varim$loadings)), psize = exp(abs(df$value)) * geom.size)
   if (!show.values) {
     valueLabels <- """"
   } else {

---FILE: R/sjPlotPropTable.R---
@@ -200,7 +200,7 @@ sjp.xtab <- function(x,
   # x-position as numeric factor, added later after
   # tidying
   # --------------------------------------------------------
-  bars.xpos <- 1:nrow(mydat$mydat)
+  bars.xpos <- seq_len(nrow(mydat$mydat))
   # --------------------------------------------------------
   # try to automatically set labels is not passed as argument
   # --------------------------------------------------------
@@ -384,15 +384,15 @@ sjp.xtab <- function(x,
       }
     }
   } else {
-    ggvaluelabels <- geom_text(aes(y = ypos), label = """")
+    ggvaluelabels <- geom_text(aes_string(y = ""ypos""), label = """")
   }
   # --------------------------------------------------------
   # Set up grid breaks
   # --------------------------------------------------------
   if (is.null(grid.breaks)) {
     gridbreaks <- ggplot2::waiver()
   } else {
-    gridbreaks <- c(seq(lower_lim, upper_lim, by = grid.breaks))
+    gridbreaks <- seq(lower_lim, upper_lim, by = grid.breaks)
   }
   # ----------------------------------
   # construct final plot, base constructor
@@ -420,12 +420,12 @@ sjp.xtab <- function(x,
     # for lines, numeric scale
     mydf$xpos <- sjmisc::to_value(mydf$xpos, keep.labels = F)
     line.stat <- ifelse(isTRUE(smooth.lines), ""smooth"", ""identity"")
-    geob <- geom_line(aes(colour = group), size = geom.size,  stat = line.stat)
+    geob <- geom_line(aes_string(colour = ""group""), size = geom.size,  stat = line.stat)
   }
   # --------------------------------------------------------
   # start plot here
   # --------------------------------------------------------
-  baseplot <- ggplot(mydf, aes(x = xpos, y = prc, fill = group)) + geob
+  baseplot <- ggplot(mydf, aes_string(x = ""xpos"", y = ""prc"", fill = ""group"")) + geob
   # if we have line diagram, print lines here
   if (type == ""line"") {
     baseplot <- baseplot + 

---FILE: R/sjPlotScatter.R---
@@ -152,7 +152,7 @@ sjp.scatter <- function(x = NULL,
   } else {
     axisTitle.x <- axis.titles[1]
     if (length(axis.titles) > 1) 
-      axisTitle.y <- axis.titles[2]#
+      axisTitle.y <- axis.titles[2]
     else
       axisTitle.y <- NULL
   }
@@ -243,15 +243,15 @@ sjp.scatter <- function(x = NULL,
       # Tell user that we have too many point labels
       warning(""More point labels than data points. Omitting remaining point labels"", call. = F)
       # shorten vector
-      dot.labels <- dot.labels[1:nrow(df)]
+      dot.labels <- dot.labels[seq_len(nrow(df))]
     } else if (length(dot.labels) < nrow(df)) {
       # Tell user that we have too less point labels
       warning(""Less point labels than data points. Omitting remaining data point"", call. = F)
       # shorten data frame
-      df <- df[1:length(dot.labels), ]
+      df <- df[seq_len(length(dot.labels)), ]
     }
     # append labels
-    df$dot.labels <- as.character(dot.labels)
+    df$dot.lab <- as.character(dot.labels)
   }
   # --------------------------------------------------------
   # Prepare and trim legend labels to appropriate size
@@ -276,7 +276,7 @@ sjp.scatter <- function(x = NULL,
   # --------------------------------------------------------
   # Plot scatter plot
   # --------------------------------------------------------
-  scatter <- ggplot(df,aes(x, y, colour = grp))
+  scatter <- ggplot(df, aes_string(x = ""x"", y = ""y"", colour = ""grp""))
   # --------------------------------------------------------
   # Add marginal rug
   # --------------------------------------------------------
@@ -296,8 +296,7 @@ sjp.scatter <- function(x = NULL,
     # do we have text?
     if (!is.null(dot.labels))
       scatter <- scatter + 
-        ggrepel::geom_text_repel(aes(label = dot.labels), size = label.size,
-                                 position = ""jitter"")
+        ggrepel::geom_text_repel(aes_string(label = ""dot.lab""), size = label.size, position = ""jitter"")
   } else {
     if (emph.dots) {
       # indicate overlapping dots by point size
@@ -309,15 +308,15 @@ sjp.scatter <- function(x = NULL,
     # do we have text?
     if (!is.null(dot.labels)) {
       scatter <- scatter + 
-        ggrepel::geom_text_repel(aes(label = dot.labels), size = label.size)
+        ggrepel::geom_text_repel(aes_string(label = ""dot.lab""), size = label.size)
       
     }
   }
   # --------------------------------------------------------
   # Show fitted lines
   # --------------------------------------------------------
   if (fit.line.grps) scatter <- scatter + 
-    stat_smooth(data = df, aes(colour = grp), method = fitmethod, se = show.ci)
+    stat_smooth(data = df, aes_string(colour = ""grp""), method = fitmethod, se = show.ci)
   if (fit.line) scatter <- scatter + 
     stat_smooth(method = fitmethod, se = show.ci, colour = ""black"")
   # --------------------------------------------------------

---FILE: man/sjp.corr.Rd---
@@ -4,13 +4,12 @@
 \alias{sjp.corr}
 \title{Plot correlation matrix}
 \usage{
-sjp.corr(data, title = NULL, axis.labels = NULL, type = c(""circle"",
-  ""tile""), sort.corr = TRUE, decimals = 3, na.deletion = c(""listwise"",
-  ""pairwise""), corr.method = c(""spearman"", ""pearson"", ""kendall""),
-  geom.colors = ""RdBu"", geom.size = 15, wrap.title = 50,
-  wrap.labels = 20, show.legend = FALSE, legend.title = NULL,
-  show.values = TRUE, show.p = TRUE, p.numeric = FALSE,
-  prnt.plot = TRUE)
+sjp.corr(data, title = NULL, axis.labels = NULL, sort.corr = TRUE,
+  decimals = 3, na.deletion = c(""listwise"", ""pairwise""),
+  corr.method = c(""spearman"", ""pearson"", ""kendall""), geom.colors = ""RdBu"",
+  wrap.title = 50, wrap.labels = 20, show.legend = FALSE,
+  legend.title = NULL, show.values = TRUE, show.p = TRUE,
+  p.numeric = FALSE, prnt.plot = TRUE)
 }
 \arguments{
 \item{data}{matrix with correlation coefficients as returned by the 
@@ -23,9 +22,6 @@ will be set automatically. If \code{title = """"}, no title is printed.}
 \item{axis.labels}{character vector with labels used as axis labels. Optional
 argument, since in most cases, axis labels are set automatically.}
 
-\item{type}{indicates whether the geoms of correlation values should be plotted
-as \code{""circle""} (default) or as \code{""tile""}.}
-
 \item{sort.corr}{logical, if \code{TRUE} (default), the axis labels are sorted
 according to the correlation strength. If \code{FALSE}, axis labels
 appear in order of how variables were included in the cor-computation or
@@ -45,10 +41,6 @@ May be abbreviated.}
 
 \item{geom.colors}{user defined color for geoms. See 'Details' in \code{\link{sjp.grpfrq}}.}
 
-\item{geom.size}{size resp. width of the geoms (bar width, line thickness or point size, 
-depending on plot type and function). Note that bar and bin widths mostly 
-need smaller values than dot sizes.}
-
 \item{wrap.title}{numeric, determines how many chars of the plot title are displayed in
 one line and when a line break is inserted.}
 
@@ -97,12 +89,9 @@ If \code{data} is a matrix with correlation coefficients as returned by
 mydf <- data.frame(cbind(runif(10), runif(10), runif(10), 
                          runif(10), runif(10)))
 
-# plot correlation matrix using circles
+# plot correlation matrix
 sjp.corr(mydf)
 
-# plot correlation matrix using square tiles without diagram background
-sjp.corr(mydf, type = ""tile"")
-
 # -------------------------------
 # Data from the EUROFAMCARE sample dataset
 # -------------------------------
@@ -118,7 +107,7 @@ mydf <- data.frame(efc[, vars.index])
 colnames(mydf) <- varlabs[vars.index]
 
 # show legend
-sjp.corr(mydf, type = ""tile"", show.legend = TRUE)
+sjp.corr(mydf, show.legend = TRUE)
 
 # -------------------------------
 # auto-detection of labels"
strengejacke,sjPlot,47133ec17e775b596b1f2a72882857dec0a67d07,Daniel Ldecke,d.luedecke@uke.de,2016-09-26T14:44:23Z,Daniel Ldecke,d.luedecke@uke.de,2016-09-26T14:44:23Z,fix automatic column adjustment for `plot_grid()`,NEWS;NEWS.md;R/plot_grid.R,False,True,True,False,7,1,8,"---FILE: NEWS---
@@ -6,6 +6,7 @@ New functions:
 
 Changes to functions:
 * For `sjp.glmer` and `sjp.lmer`, argument `show.ci` now also applies for plotting random effects (`type = ""re""`, the default), so confidence intervals may not be calculated. This may be useful in some cases where computation of standard errors for random effects caused an error.
+* Effect plots (`type = ""eff""`) for `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer` should now better handle categorical variables and their labels, including using error bars insted of regions for confidence intervals.
 * `table(*, exclude = NULL)` was changed to `table(*, useNA = ""always"")`, because of planned changes in upcoming R version 3.4.
 * `get_option(""p_zero"")` was removed, and `sjt.lm`, `sjt.glm`, `sjt.lmer` and `sjt.glmer` get a `p.zero` argument.
 

---FILE: NEWS.md---
@@ -7,6 +7,7 @@
 ## Changes to functions
 
 * For `sjp.glmer` and `sjp.lmer`, argument `show.ci` now also applies for plotting random effects (`type = ""re""`, the default), so confidence intervals may not be calculated. This may be useful in some cases where computation of standard errors for random effects caused an error.
+* Effect plots (`type = ""eff""`) for `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer` should now better handle categorical variables and their labels, including using error bars insted of regions for confidence intervals.
 * `table(*, exclude = NULL)` was changed to `table(*, useNA = ""always"")`, because of planned changes in upcoming R version 3.4.
 * `get_option(""p_zero"")` was removed, and `sjt.lm`, `sjt.glm`, `sjt.lmer` and `sjt.glmer` get a `p.zero` argument.
 

---FILE: R/plot_grid.R---
@@ -46,6 +46,10 @@ plot_grid <- function(x, margin = c(1, 1, 1, 1)) {
     pl + theme(plot.margin = unit(margin, ""cm""))
   })
 
+  # compute amount of columns and rows
+  ncol <- round(sqrt(length(x)))
+  nrow <- ceiling(length(x) / ncol)
+  
   f <- eval(bquote(gridExtra::""grid.arrange""))
-  do.call(f, c(x, ncol = floor(sqrt(length(x)))))
+  do.call(f, c(x, nrow = nrow, ncol = ncol))
 }"
strengejacke,sjPlot,06b0e07503d5af20be20973d33d045004d5631c8,Daniel Ldecke,d.luedecke@uke.de,2016-09-24T17:40:11Z,Daniel Ldecke,d.luedecke@uke.de,2016-09-24T17:40:11Z,fix news,NEWS;NEWS.md,False,False,False,False,2,0,2,"---FILE: NEWS---
@@ -2,6 +2,7 @@ Version 2.0.3
 -----------------------------------------------------------------------------
 New functions:
 * `sjp.resid`, an experimental function to plot and analyze residuals from linear models.
+* `plot_grid` to plot a list of ggplot-objects as arranged grid in a single plot.
 
 Changes to functions:
 * For `sjp.glmer` and `sjp.lmer`, argument `show.ci` now also applies for plotting random effects (`type = ""re""`, the default), so confidence intervals may not be calculated. This may be useful in some cases where computation of standard errors for random effects caused an error.

---FILE: NEWS.md---
@@ -2,6 +2,7 @@
 
 ## New functions
 * `sjp.resid`, an experimental function to plot and analyze residuals from linear models.
+* `plot_grid` to plot a list of ggplot-objects as arranged grid in a single plot.
 
 ## Changes to functions
 "
strengejacke,sjPlot,b23cae2cd94858a65ecd06f8d5318846366574c2,Daniel Ldecke,d.luedecke@uke.de,2016-09-24T17:37:50Z,Daniel Ldecke,d.luedecke@uke.de,2016-09-24T17:37:50Z,"fix x-axis-order of values for `type = ""eff""`, add new function `plot_grid`",NAMESPACE;R/plot_grid.R;R/sjPlotGLME.R;man/plot_grid.Rd,False,True,True,False,82,1,83,"---FILE: NAMESPACE---
@@ -5,6 +5,7 @@ export(dist_chisq)
 export(dist_f)
 export(dist_norm)
 export(dist_t)
+export(plot_grid)
 export(save_plot)
 export(sjc.cluster)
 export(sjc.dend)

---FILE: R/plot_grid.R---
@@ -0,0 +1,42 @@
+#' @title Arrange list of plots as grid
+#' @name plot_grid
+#'
+#' @description Plot multiple ggplot-objects as a grid-arranged single plot.
+#'
+#' @param x A list of ggplot-objects. See 'Details'.
+
+#' @details This function takes a \code{list} of ggplot-objects as argument.
+#'          Plotting functions of this package that produce multiple plot
+#'          objects (e.g., when there is an argument \code{facet.grid}) usually
+#'          return multiple plots as list (the return value is named \code{plot.list}).
+#'          To arrange these plots as grid as a single plot, use \code{plot_grid}.
+#'
+#' @examples
+#' library(sjmisc)
+#' data(efc)
+#' # fit model
+#' fit <- lm(tot_sc_e ~ c12hour + e17age + e42dep + neg_c_7, data = efc)
+#' # plot marginal effects for each predictor, each as single plot
+#' p <- sjp.lm(fit, type = ""eff"", facet.grid = FALSE)
+#' 
+#' # plot grid
+#' plot_grid(p$plot.list)
+#' 
+#' # or
+#' plot_grid(p)
+#'
+#' @export
+plot_grid <- function(x) {
+  # check package availability -----
+  if (!requireNamespace(""gridExtra"", quietly = TRUE)) {
+    stop(""Package `gridExtra` needed for this function to work. Please install it."", call. = F)
+  }
+  
+  # if user did not pass plot.list value, but the complete object returned
+  # by sjPlot-functions, get plot-list then
+  if (class(x) != ""list"" || any(class(x) == ""sjPlot""))
+    x <- x[[""plot.list""]]
+  
+  f <- eval(bquote(gridExtra::""grid.arrange""))
+  do.call(f, c(x, ncol = floor(sqrt(length(x)))))
+}

---FILE: R/sjPlotGLME.R---
@@ -2230,7 +2230,8 @@ sjp.glm.eff <- function(fit,
       # -------------------------
       tmp$x <- sjmisc::to_value(tmp$x, keep.labels = F)
       # sort rows. we may need to do this if we have factors
-      tmp <- tmp[order(tmp$x), ]
+      # tmp <- tmp[order(tmp$x), ]
+      tmp$x <- sort(tmp$x)
       # get possible variable labels
       tmp$var.label <- sjmisc::get_label(fitfram[[t]], def.value = t)
       # do we already have data?

---FILE: man/plot_grid.Rd---
@@ -0,0 +1,37 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/plot_grid.R
+\name{plot_grid}
+\alias{plot_grid}
+\title{Arrange list of plots as grid}
+\usage{
+plot_grid(x)
+}
+\arguments{
+\item{x}{A list of ggplot-objects. See 'Details'.}
+}
+\description{
+Plot multiple ggplot-objects as a grid-arranged single plot.
+}
+\details{
+This function takes a \code{list} of ggplot-objects as argument.
+         Plotting functions of this package that produce multiple plot
+         objects (e.g., when there is an argument \code{facet.grid}) usually
+         return multiple plots as list (the return value is named \code{plot.list}).
+         To arrange these plots as grid as a single plot, use \code{plot_grid}.
+}
+\examples{
+library(sjmisc)
+data(efc)
+# fit model
+fit <- lm(tot_sc_e ~ c12hour + e17age + e42dep + neg_c_7, data = efc)
+# plot marginal effects for each predictor, each as single plot
+p <- sjp.lm(fit, type = ""eff"", facet.grid = FALSE)
+
+# plot grid
+plot_grid(p$plot.list)
+
+# or
+plot_grid(p)
+
+}
+"
strengejacke,sjPlot,7da8b039e155081466cacc44e4e2a4b2ac6a1719,Daniel Ldecke,d.luedecke@uke.de,2016-09-21T19:26:19Z,Daniel Ldecke,d.luedecke@uke.de,2016-09-21T19:26:19Z,fix bug with logical,R/sjPlotGLME.R,False,True,True,False,1,1,2,"---FILE: R/sjPlotGLME.R---
@@ -2175,7 +2175,7 @@ sjp.glm.eff <- function(fit,
   # ------------------------
   eff <- effects::allEffects(fit, xlevels = xl, KR = FALSE, ...)
   # select specific terms only
-  eff <- eff[which(names(eff) %in% all.terms) | which(names(eff) %in% all.pred.names)]
+  eff <- eff[which(names(eff) %in% all.terms | names(eff) %in% all.pred.names)]
   # init final df
   mydat <- data.frame()
   # interaction term found?"
strengejacke,sjPlot,43af7d1db9601d5fcfd45ebf072ff6f9180ed433,Daniel Ldecke,d.luedecke@uke.de,2016-09-21T18:49:45Z,Daniel Ldecke,d.luedecke@uke.de,2016-09-21T18:49:45Z,bug fix in sjp.lmm,R/sjPlotLinregMultiple.R,False,True,True,False,3,4,7,"---FILE: R/sjPlotLinregMultiple.R---
@@ -180,6 +180,8 @@ sjp.lmm <- function(...,
         # copy estimates to data frame
         betas <- data.frame(stats::coef(fit), stats::confint(fit))
         betas <- tibble::rownames_to_column(betas, var = ""term"")
+        # show intercept?
+        if (!show.intercept) betas <- betas[-1, ]
       }
     }
     # ----------------------------
@@ -214,10 +216,7 @@ sjp.lmm <- function(...,
       pointshapes[i] <- 1
       palpha[i] <- ""s""
     }
-    # ----------------------------
-    # copy beta-values into data column
-    # ----------------------------
-    ps <- rep("""", length(ov))
+    # print values to p-string
     if (show.values) ps <- sprintf(""%.*f"", digits, ov)
     # ----------------------------
     # copy p-values into data column"
strengejacke,sjPlot,9281089f70945ceacac7d8cdc8225a6a7afe4538,Daniel Ldecke,d.luedecke@uke.de,2016-09-20T17:46:18Z,Daniel Ldecke,d.luedecke@uke.de,2016-09-20T17:46:18Z,minor fixed due to tibble-lization of functions,R/sjPlotGLME.R;R/sjPlotLinregMultiple.R;R/sjTabLinReg.R;R/sjTabOdds.R,False,True,True,False,46,72,118,"---FILE: R/sjPlotGLME.R---
@@ -1030,8 +1030,7 @@ sjp.lme4  <- function(fit,
       } else {
         if (type == ""fe.std"") {
           mydf <- sjstats::std_beta(fit) %>% 
-            tibble::column_to_rownames(var = ""term"") %>% 
-            dplyr::select_(""std.estimate"", ""conf.low"", ""conf.high"")
+            dplyr::select_(""term"", ""std.estimate"", ""conf.low"", ""conf.high"")
         } else {
           # get odds ratios and cleaned CI
           mydf <- get_cleaned_ciMerMod(fit, fun)
@@ -1079,7 +1078,7 @@ sjp.lme4  <- function(fit,
       # ---------------------------------------
       # set proper column names
       # ---------------------------------------
-      colnames(mydf) <- c(""estimate"", ""conf.low"", ""conf.high"", ""p.string"", ""p.value"")
+      colnames(mydf) <- c(""term"", ""estimate"", ""conf.low"", ""conf.high"", ""p.string"", ""p.value"")
       # ---------------------------------------
       # just one group, so no faceting needed
       # ---------------------------------------
@@ -1114,13 +1113,9 @@ sjp.lme4  <- function(fit,
       # -------------------------------------------------
       if (!is.null(remove.estimates)) {
         # get row indices of rows that should be removed
-        remrows <- match(remove.estimates, row.names(mydf))
-        # remember old rownames
-        keepnames <- row.names(mydf)[-remrows]
+        remrows <- match(remove.estimates, mydf$term)
         # remove rows
         mydf <- dplyr::slice(mydf, seq_len(nrow(mydf))[-remrows])
-        # set back rownames
-        row.names(mydf) <- keepnames
         # remove labels?
         if (!empty.axis.labels && length(axis.labels) > nrow(mydf))
           axis.labels <- axis.labels[-remrows]
@@ -1133,7 +1128,7 @@ sjp.lme4  <- function(fit,
         axis.labels <- suppressWarnings(retrieveModelLabels(list(fit), group.pred = FALSE))
         if (show.intercept) axis.labels <- c(string.interc, axis.labels)
         # check for correct length
-        if (length(axis.labels) != nrow(mydf)) axis.labels <- rownames(mydf)
+        if (length(axis.labels) != nrow(mydf)) axis.labels <- mydf$term
       } else {
         # check if intercept should be added, in case
         # axis.labels are passed
@@ -1142,7 +1137,7 @@ sjp.lme4  <- function(fit,
       # ---------------------------------------
       # sort data frame. init order
       # ---------------------------------------
-      reihe <- c(1:nrow(mydf))
+      reihe <- seq_len(nrow(mydf))
       # ---------------------------------------
       # just one sorting option, simply sort estimates
       # ---------------------------------------
@@ -1162,7 +1157,7 @@ sjp.lme4  <- function(fit,
     # ---------------------------------------
     if (!is.null(vars)) {
       # find estimates that should be removed
-      remes <- which(!is.na(match(rownames(mydf), vars)))
+      remes <- which(!is.na(match(mydf$term, vars)))
       # remove data rows for these estimates
       mydf <- mydf[remes, ]
       # also remove predictor labels
@@ -1176,7 +1171,7 @@ sjp.lme4  <- function(fit,
     if (length(axis.labels) != nrow(mydf) &&
         (length(axis.labels) != (nrow(mydf) / length(unique(mydf$grp))))) {
       warning(""`axis.labels` has insufficient length. Using row names."", call. = F)
-      axis.labels <- row.names(mydf)[order(mydf$sorting)]
+      axis.labels <- mydf$term[order(mydf$sorting)]
     }
     # ---------------------------------------
     # discrete x position, needed for ggplot
@@ -1257,7 +1252,7 @@ sjp.lme4  <- function(fit,
       # hide error bars (conf int)?
       # ---------------------------------------
       if (show.ci)  gp <- gp +
-          geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0)
+          geom_errorbar(aes_string(ymin = ""conf.low"", ymax = ""conf.high""), width = 0)
       # ---------------------------------------
       # axis titles
       # ---------------------------------------
@@ -1371,12 +1366,6 @@ sjp.lme4  <- function(fit,
   # me plot contains first of all plots...
   me.plot <- me.plot.list[[1]]
   # -------------------------------------
-  # add term names
-  # -------------------------------------
-  if (type == ""fe"" || type == ""fe.std"") {
-    mydf <- tibble::rownames_to_column(mydf, var = ""term"")
-  }
-  # -------------------------------------
   # return results
   # -------------------------------------
   invisible(structure(class = ifelse(fun == ""glm"", c(""sjPlot"", ""sjpglmer""), c(""sjPlot"", ""sjplmer"")),

---FILE: R/sjPlotLinregMultiple.R---
@@ -1,5 +1,4 @@
 # bind global variables
-utils::globalVariables(c(""beta"", ""lower"", ""upper"", ""p"", ""pa"", ""shape""))
 
 #' @title Plot estimates of multiple fitted lm(er)'s
 #' @name sjp.lmm
@@ -159,24 +158,16 @@ sjp.lmm <- function(...,
   # ----------------------------
   # iterate all fitted models
   # ----------------------------
-  for (fitcnt in 1:fitlength) {
+  for (fitcnt in seq_len(fitlength)) {
     # retrieve fitted model
     fit <- input_list[[fitcnt]]
     # ----------------------------
     # retrieve beta's (lm)
     # ----------------------------
-    if (type == ""std"") {
+    if (type == ""std"" || type == ""std2"") {
       # retrieve standardized betas
-      betas <- data.frame(rbind(data.frame(beta = 0, ci.low = 0, ci.hi = 0),
-                                suppressWarnings(sjstats::std_beta(fit, include.ci = TRUE))))
-      # no intercept for std
-      show.intercept <- FALSE
-      # add ""std."" to title?
-      if (axis.title == ""Estimates"") axis.title <- ""Std. Estimates""
-    } else if (type == ""std2"") {
-      # retrieve standardized betas
-      betas <- data.frame(rbind(data.frame(beta = 0, ci.low = 0, ci.hi = 0),
-                                sjstats::std_beta(fit, include.ci = TRUE, type = ""std2"")))
+      betas <- suppressWarnings(sjstats::std_beta(fit, type = type)) %>% 
+        dplyr::select_(""-std.error"")
       # no intercept for std
       show.intercept <- FALSE
       # add ""std."" to title?
@@ -185,28 +176,29 @@ sjp.lmm <- function(...,
       # do we have mermod object?
       if (sjmisc::str_contains(class(fit), ""merMod"", ignore.case = T))
         betas <- get_cleaned_ciMerMod(fit, ""lm"")
-      else
+      else {
         # copy estimates to data frame
         betas <- data.frame(stats::coef(fit), stats::confint(fit))
+        betas <- tibble::rownames_to_column(betas, var = ""term"")
+      }
     }
     # ----------------------------
     # give proper column names
     # ----------------------------
-    colnames(betas) <- c(""beta"", ""ci.low"", ""ci.hi"")
+    colnames(betas) <- c(""term"", ""beta"", ""ci.low"", ""ci.hi"")
     # ----------------------------
     # print p-values in bar charts
     # ----------------------------
     # retrieve sigificance level of independent variables (p-values)
-    if (sjmisc::str_contains(class(fit), ""merMod"", ignore.case = T))
-      pv <- sjstats::merMod_p(fit, p.kr)
-    else
-      pv <- get_lm_pvalues(fit)$p
+    pv <- sjstats::get_model_pval(fit, p.kr = p.kr)$p.value
+    #remove intercept from df
+    if (!show.intercept) pv <- pv[-1]
     # for better readability, convert p-values to asterisks
     # with:
     # p < 0.001 = ***
     # p < 0.01 = **
     # p < 0.05 = *
-    ov <- betas[, 1]
+    ov <- betas$beta
     # ""ps"" holds the p-value of the coefficients, including asterisks, as
     # string vector
     ps <- NULL
@@ -217,7 +209,7 @@ sjp.lmm <- function(...,
     # non-significant values can be drawn with a lesser alpha-level
     # (i.e. are more transparent)
     palpha <- NULL
-    for (i in 1:length(pv)) {
+    for (i in seq_len(length(pv))) {
       ps[i] <- """"
       pointshapes[i] <- 1
       palpha[i] <- ""s""
@@ -230,7 +222,7 @@ sjp.lmm <- function(...,
     # ----------------------------
     # copy p-values into data column
     # ----------------------------
-    for (i in 1:length(pv)) {
+    for (i in seq_len(length(pv))) {
       if (pv[i] >= 0.05) {
         pointshapes[i] <- 1
         palpha[i] <- ""ns""
@@ -248,13 +240,7 @@ sjp.lmm <- function(...,
     # ----------------------------
     # bind p-values to data frame
     # ----------------------------
-    betas <- data.frame(betas, ps, palpha, pointshapes, fitcnt, pv)
-    # set column names
-    colnames(betas) <- c(""beta"", ""lower"", ""upper"", ""p"", ""pa"", ""shape"", ""grp"", ""p.value"")
-    #remove intercept from df
-    if (!show.intercept) betas <- betas[-1, ]
-    # add rownames
-    betas$term <- row.names(betas)
+    betas <- data.frame(betas, p = ps, pa = palpha, shape = pointshapes, grp = fitcnt, p.value = pv)
     # add data frame to final data frame
     finalbetas <- rbind(finalbetas, betas)
   }
@@ -274,17 +260,13 @@ sjp.lmm <- function(...,
   if (!is.null(remove.estimates)) {
     # get row indices of rows that should be removed
     remrows <- c()
-    for (re in 1:length(remove.estimates)) {
-      remrows <- c(remrows, which(substr(row.names(finalbetas), 
+    for (re in seq_len(length(remove.estimates))) {
+      remrows <- c(remrows, which(substr(finalbetas$term, 
                                          start = 1, 
                                          stop = nchar(remove.estimates[re])) == remove.estimates[re]))
     }
-    # remember old rownames
-    keepnames <- row.names(finalbetas)[-remrows]
     # remove rows
     finalbetas <- dplyr::slice(finalbetas, c(1:nrow(finalbetas))[-remrows])
-    # set back rownames
-    row.names(finalbetas) <- keepnames
   }
   # set axis labels
   if (is.null(axis.labels)) {
@@ -299,8 +281,8 @@ sjp.lmm <- function(...,
     # we have confindence intervals displayed, so
     # the range corresponds to the boundaries given by
     # the CI's
-    upper_lim <- ceiling(10 * max(finalbetas$upper)) / 10
-    lower_lim <- floor(10 * min(finalbetas$lower)) / 10
+    upper_lim <- ceiling(10 * max(finalbetas$ci.hi)) / 10
+    lower_lim <- floor(10 * min(finalbetas$ci.low)) / 10
     # if we show p value labels, increase upper
     # limit of x axis, so labels are plotted inside
     # diagram range
@@ -336,11 +318,8 @@ sjp.lmm <- function(...,
   # The order of aesthetics matters in terms of ordering the error bars!
   # Using alpha-aes before colour would order error-bars according to
   # alpha-level instead of colour-aes.
-  plotHeader <- ggplot(finalbetas, aes(y = beta, 
-                                       x = xpos, 
-                                       group = grp, 
-                                       colour = grp, 
-                                       alpha = pa))
+  plotHeader <- ggplot(finalbetas, aes_string(y = ""beta"", x = ""xpos"", group = ""grp"", 
+                                              colour = ""grp"", alpha = ""pa""))
   # --------------------------------------------------------
   # start with dot-plotting here
   # first check, whether user wants different shapes for
@@ -354,7 +333,7 @@ sjp.lmm <- function(...,
       # The order of aesthetics matters in terms of ordering the error bars!
       # Using shape before colour would order points according to shapes instead
       # of colour-aes.
-      geom_point(aes(shape = shape), 
+      geom_point(aes_string(shape = ""shape""), 
                  size = geom.size, 
                  position = position_dodge(-geom.spacing)) +
       # and use a shape scale, in order to have a legend
@@ -375,13 +354,13 @@ sjp.lmm <- function(...,
     # --------------------------------------------------------
     # print confidence intervalls (error bars)
     # --------------------------------------------------------
-    geom_errorbar(aes(ymin = lower, ymax = upper), 
+    geom_errorbar(aes_string(ymin = ""ci.low"", ymax = ""ci.hi""), 
                   position = position_dodge(-geom.spacing), 
                   width = 0) +
     # --------------------------------------------------------
     # print value labels and p-values
     # --------------------------------------------------------
-    geom_text(aes(label = p, y = upper), 
+    geom_text(aes_string(label = ""p"", y = ""ci.hi""), 
               position = position_dodge(width = -geom.spacing), 
               hjust = -0.1,
               show.legend = FALSE) +

---FILE: R/sjTabLinReg.R---
@@ -638,7 +638,10 @@ sjt.lm <- function(...,
   # -------------------------------------
   if (show.header) {
     page.content <- paste0(page.content, sprintf(""\n  <tr>\n    <td class=\""tdata topborder\"" rowspan=\""2\""><em>%s</em></td>"", string.pred))
-    page.content <- paste0(page.content, sprintf(""\n    <td colspan=\""%i\"" class=\""tdata topborder depvarhead\""><em>%s</em></td>"", headerColSpan, string.dv))
+    page.content <- paste0(page.content, sprintf(""\n    <td colspan=\""%i\"" class=\""tdata topborder depvarhead\""><em>%s</em></td>\n  </tr>\n"", headerColSpan, string.dv))
+  } else {
+    # first column is empty
+    page.content <- paste0(page.content,""\n    <td class=\""tdata topborder\"">&nbsp;</td>"")
   }
   # -------------------------------------
   # If we don't show header strings, a rowspan-attribute is missing,
@@ -801,7 +804,9 @@ sjt.lm <- function(...,
     # show std. beta std. error
     if (showStdBetaValues && show.se) page.content <- table_cell_string(page.content, ""\n    "", tcb_class, 6, ""&nbsp;"")
     # show p-values as numbers in separate column
-    if (p.numeric) page.content <- table_cell_string(page.content, ""\n    "", tcb_class, 7, joined.df[1, (i - 1) * 9 + COL_P])
+    if (p.numeric)
+      # if we don't have estimates, intercept is not available. so don't show p-value here
+      page.content <- table_cell_string(page.content, ""\n    "", tcb_class, 7, ifelse(isTRUE(show.est), joined.df[1, (i - 1) * 9 + COL_P], ""&nbsp;""))
   }
   page.content <- paste0(page.content, ""\n  </tr>"")  
   # -------------------------------------

---FILE: R/sjTabOdds.R---
@@ -294,7 +294,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   # iterate all models
   # -------------------------------------
-  for (i in 1:length(input_list)) {
+  for (i in seq_len(length(input_list))) {
     # -------------------------------------
     # retrieve model
     # -------------------------------------
@@ -304,7 +304,8 @@ sjt.glm <- function(...,
     # -------------------------------------
     if (lmerob) {
       # get cleaned CI
-      confis <- get_cleaned_ciMerMod(fit, ""glm"", T)
+      confis <- get_cleaned_ciMerMod(fit, ""lm"", T) %>% 
+        dplyr::select_(""-term"")
       coef.fit <- lme4::fixef(fit)
     } else {
       confis <- stats::confint(fit)
@@ -403,7 +404,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   # replace NA, created by join, with empty string
   # -------------------------------------
-  for (i in 1:ncol(joined.df)) {
+  for (i in seq_len(ncol(joined.df))) {
     joined.df[, i] <- sapply(joined.df[, i], function(x) if (is.na(x)) x <- """" else x)
   }
   # -------------------------------------
@@ -416,7 +417,7 @@ sjt.glm <- function(...,
       # if so, retrieve index numbers
       tmp_re <- c()
       # iterate all var names
-      for (re in 1:length(remove.estimates)) {
+      for (re in seq_len(length(remove.estimates))) {
         # find row index by name
         tmp_re <- c(tmp_re, which(joined.df$coef.name == remove.estimates[re]))
       }
@@ -432,7 +433,7 @@ sjt.glm <- function(...,
       message(""Intercept cannot be removed from table output. However, you may fake with style sheet, e.g. CSS = list(css.topcontentborder = \""+font-size: 0px;\"")."")
     }
     # create all row indices
-    rowind <- c(1:nrow(joined.df))
+    rowind <- seq_len(nrow(joined.df))
     # ""inverse"" removable inices
     keep.estimates <- rowind[-remove.estimates]
     # select rows
@@ -631,7 +632,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   # subsequent rows: pedictors
   # -------------------------------------
-  for (i in 1:(nrow(joined.df) - 1)) {
+  for (i in seq_len(nrow(joined.df) - 1)) {
     # -------------------------------------
     # do we need to insert a ""factor grouping headline row""?
     # -------------------------------------"
strengejacke,sjPlot,7ae4327c4a740ec455472ea65e74f77acf6fed06,Daniel Ldecke,d.luedecke@uke.de,2016-09-18T19:47:47Z,Daniel Ldecke,d.luedecke@uke.de,2016-09-18T19:47:47Z,minor fixed due to changes in other packages,R/sjPlotGLME.R;R/sjPlotInteractions.R;R/sjPlotLinreg.R;R/sjTabLinReg.R;R/table_functions.R,False,True,True,False,24,27,51,"---FILE: R/sjPlotGLME.R---
@@ -1029,12 +1029,9 @@ sjp.lme4  <- function(fit,
         mydf <- get_cleaned_ciMerMod(fit, fun)
       } else {
         if (type == ""fe.std"") {
-          tmpdf <- sjstats::std_beta(fit)
-          mydf <- data.frame(estimate = tmpdf$stdcoef,
-                             conf.low = tmpdf$stdcoef - (1.96 * tmpdf$stdse),
-                             conf.high = tmpdf$stdcoef + (1.96 * tmpdf$stdse))
-          # set default row names
-          rownames(mydf) <- names(lme4::fixef(fit))
+          mydf <- sjstats::std_beta(fit) %>% 
+            tibble::column_to_rownames(var = ""term"") %>% 
+            dplyr::select_(""std.estimate"", ""conf.low"", ""conf.high"")
         } else {
           # get odds ratios and cleaned CI
           mydf <- get_cleaned_ciMerMod(fit, fun)
@@ -1052,7 +1049,7 @@ sjp.lme4  <- function(fit,
         ov <- exp(lme4::fixef(fit))
       } else {
         if (type == ""fe.std"") {
-          ov <- sjstats::std_beta(fit)$stdcoef
+          ov <- mydf$std.estimate
         } else {
           ov <- lme4::fixef(fit)
         }
@@ -2405,6 +2402,8 @@ sjp.glmer.ma <- function(fit) {
 
 
 #' @importFrom lme4 fixef confint.merMod
+#' @importFrom tibble rownames_to_column
+#' @importFrom dplyr select_ rename_
 get_cleaned_ciMerMod <- function(fit, fun, ci.only = FALSE) {
   # get odds ratios of fixed effects
   estimate <- lme4::fixef(fit)
@@ -2415,10 +2414,12 @@ get_cleaned_ciMerMod <- function(fit, fun, ci.only = FALSE) {
     mydf <- data.frame(cbind(estimate, CI))
   else
     mydf <- data.frame(exp(cbind(estimate, CI)))
+  # add rownames
+  mydf <- mydf %>% 
+    tibble::rownames_to_column(var = ""term"") %>% 
+    dplyr::rename_(.dots = list(""conf.low"" = ""X2.5.."", ""conf.high"" = ""X97.5..""))
   # only return ci?
-  if (ci.only)
-    return(as.data.frame(CI))
-  else
-    # return df
-    return(mydf)
+  if (ci.only) mydf <- mydf %>% dplyr::select_(""-estimate"")
+  # return df
+  return(mydf)
 }

---FILE: R/sjPlotInteractions.R---
@@ -962,7 +962,7 @@ sjp.eff.int <- function(fit,
   # -----------------------------------------------------------
   # iterate all interaction terms
   # -----------------------------------------------------------
-  for (i in 1:length(intpos)) {
+  for (i in seq_len(length(intpos))) {
     # -----------------------------------------------------------
     # copy ""eff"" object, so we don't confuse with effect-return-
     # value from single term and multiple terms

---FILE: R/sjPlotLinreg.R---
@@ -248,8 +248,9 @@ utils::globalVariables(c(""fit"", ""vars"", ""stdbeta"", ""x"", ""ydiff"", ""y"", ""grp"", "".s
 #' @importFrom dplyr slice select_
 #' @importFrom broom tidy
 #' @importFrom sjmisc is_empty
-#' @importFrom tibble as_tibble rownames_to_column
+#' @importFrom tibble as_tibble
 #' @importFrom nlme getData getResponse getCovariateFormula
+#' @importFrom sjstats get_model_pval std_beta
 #' @export
 sjp.lm <- function(fit,
                    type = ""lm"",
@@ -386,7 +387,7 @@ sjp.lm <- function(fit,
   # print beta- and p-values in bar charts
   # ----------------------------
   # retrieve sigificance level of independent variables (p-values)
-  pv <- get_lm_pvalues(fit, include.intercept = F)$p
+  pv <- sjstats::get_model_pval(fit, p.kr = F)[[""p.value""]][-1]
   # -------------------------------------------------
   # for better readability, convert p-values to asterisks
   # with:
@@ -399,8 +400,9 @@ sjp.lm <- function(fit,
   if (type == ""std"" || type == ""std2"") {
     # retrieve standardized betas
     tmp <- suppressWarnings(
-      tibble::rownames_to_column(
-        sjstats::std_beta(fit, include.ci = TRUE, type = type)))
+      sjstats::std_beta(fit, type = type) %>% 
+        dplyr::select_(""-std.error"")
+    )
     # add ""std."" to title?
     if (!is.null(axis.title) && axis.title == ""Estimates"") axis.title <- ""Std. Estimates""
     # give common column names

---FILE: R/sjTabLinReg.R---
@@ -639,21 +639,15 @@ sjt.lm <- function(...,
   if (show.header) {
     page.content <- paste0(page.content, sprintf(""\n  <tr>\n    <td class=\""tdata topborder\"" rowspan=\""2\""><em>%s</em></td>"", string.pred))
     page.content <- paste0(page.content, sprintf(""\n    <td colspan=\""%i\"" class=\""tdata topborder depvarhead\""><em>%s</em></td>"", headerColSpan, string.dv))
-    page.content <- paste0(page.content, ""\n  </tr>"")
   }
   # -------------------------------------
-  # table headline: label for dependent variables (model outcomes)
-  # -------------------------------------
-  page.content <- paste0(page.content, ""\n<tr>"")
-  # -------------------------------------
   # If we don't show header strings, a rowspan-attribute is missing,
   # so we need to insert an empty cell here
   # -------------------------------------
-  tcp <- """"
-  if (!show.header) {
-    page.content <- paste0(page.content, ""\n    <td class=\""tdata labelcellborder topborder\"">&nbsp;</td>"")
+  if (show.header)
+    tcp <- """"
+  else
     tcp <- "" topborder""
-  }
   # -------------------------------------
   # set default dependent var label
   # -------------------------------------

---FILE: R/table_functions.R---
@@ -20,7 +20,7 @@ get_table_response_label <- function(page.content, depvar.labels, input_list, tc
     # variables, in the table column headers
     depvar.labels <- c()
     # iterate models
-    for (i in 1:length(input_list)) {
+    for (i in seq_len(length(input_list))) {
       # get model data
       m_d <- get_lm_data(input_list[[i]])
       # get model response"
strengejacke,sjPlot,843b4977bdf039621db1d027dc09f25a6b69d449,Daniel Ldecke,d.luedecke@uke.de,2016-09-16T06:30:58Z,Daniel Ldecke,d.luedecke@uke.de,2016-09-16T06:30:58Z,"Fixed bug in effect plot types

Effect plots (`type = ""eff""`) for `sjp.lm`, `sjp.glm`, `sjp.lmer` and
`sjp.glmer` did not plot all predictors, when predictor name was not
exactly specified in formula, but transformed inside formula (e.g.
`log(pred + 1)`).",NEWS;NEWS.md;R/helpfunctions.R;R/sjPlotGLME.R,False,True,True,False,36,29,65,"---FILE: NEWS---
@@ -10,6 +10,7 @@ Changes to functions:
 
 Bug fixes:
 * A bug introduced in update 2.0.2 caused an error in `sjp.lm` for `type = ""std""`.
+* Effect plots (`type = ""eff""`) for `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer` did not plot all predictors, when predictor name was not exactly specified in formula, but transformed inside formula (e.g. `log(pred + 1)`).
 
 
 Version 2.0.2

---FILE: NEWS.md---
@@ -12,7 +12,7 @@
 ## Bug fixes
 
 * A bug introduced in update 2.0.2 caused an error in `sjp.lm` for `type = ""std""`.
-
+* Effect plots (`type = ""eff""`) for `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer` did not plot all predictors, when predictor name was not exactly specified in formula, but transformed inside formula (e.g. `log(pred + 1)`).
 
 # sjPlot 2.0.2
 

---FILE: R/helpfunctions.R---
@@ -579,7 +579,7 @@ is_merMod <- function(fit) {
 #' @importFrom stats formula terms
 retrieveModelLabels <- function(models, group.pred) {
   fit.labels <- c()
-  for (k in 1:length(models)) {
+  for (k in seq_len(length(models))) {
     # get model
     fit <- models[[k]]
     # any valid model?

---FILE: R/sjPlotGLME.R---
@@ -1184,7 +1184,7 @@ sjp.lme4  <- function(fit,
     # ---------------------------------------
     # discrete x position, needed for ggplot
     # ---------------------------------------
-    mydf$x <- as.factor(1:length(axis.labels))
+    mydf$x <- as.factor(seq_len(length(axis.labels)))
     # ---------------------------------------
     # set indicator whether or not non significant
     # odds ratios should be faded.
@@ -1219,15 +1219,11 @@ sjp.lme4  <- function(fit,
       # (whether grouped or not)
       # --------------------------------------------------------
       if (!is.null(group.estimates)) {
-        gp <- ggplot(mydf, aes(x = x,
-                               y = estimate,
-                               colour = grp,
-                               alpha = fade))
+        gp <- ggplot(mydf, aes_string(x = ""x"", y = ""estimate"",
+                                      colour = ""grp"", alpha = ""fade""))
       } else {
-        gp <- ggplot(mydf, aes(x = x,
-                               y = estimate,
-                               colour = (estimate > interc),
-                               alpha = fade))
+        gp <- ggplot(mydf, aes(x = x, y = estimate, 
+                               colour = (estimate > interc), alpha = fade))
       }
       gp <- gp +
         # Intercept-line
@@ -1236,7 +1232,7 @@ sjp.lme4  <- function(fit,
                    color = vline.color) +
         geom_point(size = geom.size) +
         # print value labels and p-values
-        geom_text(aes(label = p.string, y = estimate), nudge_x = y.offset) +
+        geom_text(aes_string(label = ""p.string"", y = ""estimate""), nudge_x = y.offset) +
         # ---------------------------------------
       # labels in sorted order
       # ---------------------------------------
@@ -1350,7 +1346,7 @@ sjp.lme4  <- function(fit,
       # ---------------------------------------
       # iterate coefficients
       # ---------------------------------------
-      for (j in 1:length(groups)) {
+      for (j in seq_len(length(groups))) {
         me.plot <- plot.effe(mydf[mydf$grp == groups[j], ],
                              title[j],
                              NULL,
@@ -2088,6 +2084,7 @@ sjp.lme.fecor <- function(fit,
 
 #' @importFrom stats family model.frame na.omit
 #' @importFrom dplyr filter
+#' @importFrom sjstats pred_vars
 sjp.glm.eff <- function(fit,
                         title,
                         geom.size,
@@ -2112,17 +2109,22 @@ sjp.glm.eff <- function(fit,
   # ------------------------
   # Get link family and model frame
   # ------------------------
-  fitfram <- stats::model.frame(fit)
+  if (is_merMod(fit))
+    fitfram <- stats::model.frame(fit, fixed.only = TRUE)
+  else
+    fitfram <- stats::model.frame(fit)
   fitfam <- get_glm_family(fit)
   # --------------------------------------------------------
   # create logical for family
   # --------------------------------------------------------
   poisson_fam <- fitfam$is_pois
   binom_fam <- fitfam$is_bin
   # ------------------------
-  # retrieve all terms excluding intercept
+  # retrieve all terms and term name, excluding intercept,
+  # both as they appear as column name and as real variable name
   # ------------------------
   all.terms <- colnames(fitfram)[-1]
+  all.pred.names <- sjstats::pred_vars(fit)[seq_len(length(all.terms))]
   # ------------------------
   # Retrieve response for automatic title
   # ------------------------
@@ -2151,19 +2153,23 @@ sjp.glm.eff <- function(fit,
   # remove setimates?
   # ------------------------
   if (!is.null(remove.estimates)) {
-    remcols <- match(remove.estimates, all.terms)
+    remcols <- match(remove.estimates, all.pred.names)
     # remember old rownames
-    if (!sjmisc::is_empty(remcols))
+    if (!sjmisc::is_empty(remcols)) {
       all.terms <- all.terms[-remcols]
+      all.pred.names <- all.pred.names[-remcols]
+    }
   }
   # ------------------------
   # select specific setimates?
   # ------------------------
   if (!is.null(vars)) {
-    remcols <- match(vars, all.terms)
+    remcols <- match(vars, all.pred.names)
     # remember old rownames
-    if (!sjmisc::is_empty(remcols))
+    if (!sjmisc::is_empty(remcols)) {
       all.terms <- all.terms[remcols]
+      all.pred.names <- all.pred.names[remcols]
+    }
   }
   # ------------------------
   # prepare getting unique values of predictors,
@@ -2183,13 +2189,13 @@ sjp.glm.eff <- function(fit,
   # ------------------------
   eff <- effects::allEffects(fit, xlevels = xl, KR = FALSE, ...)
   # select specific terms only
-  eff <- eff[which(names(eff) %in% all.terms)]
+  eff <- eff[which(names(eff) %in% all.terms) | which(names(eff) %in% all.pred.names)]
   # init final df
   mydat <- data.frame()
   # interaction term found?
   int.found <- FALSE
   # iterate all effects
-  for (i in 1:length(eff)) {
+  for (i in seq_len(length(eff))) {
     # get term, for which effects were calculated
     t <- eff[[i]]$term
     # check if we have interaction term
@@ -2272,9 +2278,9 @@ sjp.glm.eff <- function(fit,
   # create plot
   # ------------------------
   if (facet.grid) {
-    eff.plot <- ggplot(mydat, aes(x = x, y = y))
+    eff.plot <- ggplot(mydat, aes_string(x = ""x"", y = ""y""))
     # show confidence region?
-    if (show.ci) eff.plot <- eff.plot + geom_ribbon(aes(ymin = lower, ymax = upper), alpha = .15)
+    if (show.ci) eff.plot <- eff.plot + geom_ribbon(aes_string(ymin = ""lower"", ymax = ""upper""), alpha = .15)
     eff.plot <- eff.plot +
       geom_line(size = geom.size) +
       facet_wrap(~var.label, ncol = round(sqrt(grp.cnt)), scales = ""free_x"") +
@@ -2300,9 +2306,9 @@ sjp.glm.eff <- function(fit,
     for (i in unique(mydat$grp)) {
       # select subset
       mydat_sub <- dplyr::filter(mydat, grp == i)
-      eff.plot <- ggplot(mydat_sub, aes(x = x, y = y))
+      eff.plot <- ggplot(mydat_sub, aes_string(x = ""x"", y = ""y""))
       # show confidence region?
-      if (show.ci) eff.plot <- eff.plot + geom_ribbon(aes(ymin = lower, ymax = upper), alpha = .15)
+      if (show.ci) eff.plot <- eff.plot + geom_ribbon(aes_string(ymin = ""lower"", ymax = ""upper""), alpha = .15)
       eff.plot <- eff.plot +
         geom_line(size = geom.size) +
         labs(x = NULL, y = axisTitle.y, title = sprintf(""Marginal effects of %s"", mydat_sub$var.label[1]))
@@ -2371,8 +2377,8 @@ sjp.glmer.ma <- function(fit) {
   gp <- ggplot(data.frame(x = stats::predict(fit),
                           y = stats::residuals(fit),
                           grp = as.factor(lme4::getME(fit, ""y""))),
-               aes(x, y)) +
-    geom_point(aes(colour = grp), show.legend = F) +
+               aes_string(x = ""x"", y = ""y"")) +
+    geom_point(aes_string(colour = ""grp""), show.legend = F) +
     geom_hline(yintercept = 0) +
     stat_smooth(method = ""loess"", se = T) +
     labs(title = ""Residual plot (original model)"",
@@ -2386,8 +2392,8 @@ sjp.glmer.ma <- function(fit) {
       mydat <- data.frame(x = m_f[[pr]],
                           y = stats::residuals(fit),
                           grp = as.factor(lme4::getME(fit, ""y"")))
-      gp <- ggplot(mydat, aes(x, y)) +
-        geom_point(aes(colour = grp), show.legend = F) +
+      gp <- ggplot(mydat, aes_string(x = ""x"", y = ""y"")) +
+        geom_point(aes_string(colour = ""grp""), show.legend = F) +
         geom_hline(yintercept = 0) +
         stat_smooth(method = ""loess"", se = T) +
         labs(x = pr, y = ""Residuals"","
strengejacke,sjPlot,440e5fa0b9609e3a0542c62232d583573063a9a6,Daniel Ldecke,d.luedecke@uke.de,2016-09-07T16:59:49Z,Daniel Ldecke,d.luedecke@uke.de,2016-09-07T16:59:49Z,minor fixes with css-classes in `sjt.lm()`,R/sjTabLinReg.R;R/table_functions.R,False,True,True,False,3,3,6,"---FILE: R/sjTabLinReg.R---
@@ -651,7 +651,7 @@ sjt.lm <- function(...,
   # -------------------------------------
   tcp <- """"
   if (!show.header) {
-    page.content <- paste0(page.content, ""\n    <td class=\""tdata topborder\"">&nbsp;</td>"")
+    page.content <- paste0(page.content, ""\n    <td class=\""tdata labelcellborder topborder\"">&nbsp;</td>"")
     tcp <- "" topborder""
   }
   # -------------------------------------

---FILE: R/table_functions.R---
@@ -35,11 +35,11 @@ get_table_response_label <- function(page.content, depvar.labels, input_list, tc
   # continue with model-labels (dependent variables)
   # which are the heading for each model column
   # -------------------------------------
-  for (i in 1:length(depvar.labels)) {
+  for (i in seq_len(length(depvar.labels))) {
     # -------------------------
     # insert ""separator column""
     # -------------------------
-    if (sep.column) page.content <- paste0(page.content, sprintf(""\n    <td class=\""separatorcol%s\"">&nbsp;</td>"", tcp))
+    if (sep.column) page.content <- paste0(page.content, sprintf(""\n    <td class=\""labelcellborder separatorcol%s\"">&nbsp;</td>"", tcp))
     if (headerColSpanFactor > 1) {
       page.content <- paste0(page.content, 
                              sprintf(""\n    <td class=\""tdata centeralign labelcellborder%s\"" colspan=\""%i\"">%s</td>"", "
strengejacke,sjPlot,b6fcd0bdce28864ad275d7ac766a9820adfa60e0,Daniel Ldecke,d.luedecke@uke.de,2016-08-22T17:51:47Z,Daniel Ldecke,d.luedecke@uke.de,2016-08-22T17:51:47Z,various fixes,DESCRIPTION;NEWS;NEWS.md;R/helpfunctions.R;R/sjPlotLinreg.R;R/sjTabLinReg.R;R/sjTabOdds.R;man/sjPlot-package.Rd;man/sjt.lm.Rd;man/sjt.lmer.Rd,False,True,True,False,71,70,141,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 2.0.2-1
-Date: 2016-08-02
+Version: 2.0.3
+Date: 2016-08-15
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of plotting and table output functions for data
@@ -31,7 +31,7 @@ Imports:
     nlme,
     psych,
     scales,
-    sjmisc (>= 1.8),
+    sjmisc (>= 2.0),
     sjstats (>= 0.3.0),
     tibble (>= 1.1.0),
     tidyr (>= 0.5.0)

---FILE: NEWS---
@@ -1,7 +1,12 @@
-Version 2.0.2-1
+Version 2.0.3
 -----------------------------------------------------------------------------
 Changes to functions:
 * For `sjp.glmer` and `sjp.lmer`, argument `show.ci` now also applies for plotting random effects (`type = ""re""`, the default), so confidence intervals are not calculated. This may be useful in some cases where computation of standard errors for random effects caused an error.
+* `table*, exclude = NULL)` was changed to `table*, useNA = ""always"")`, because of planned changes in upcoming R version 3.4.
+* `get_option(""p_zero"")` was removed, and `sjt.lm`, `sjt.glm`, `sjt.lmer` and `sjt.glmer` get a `p.zero` argument.
+
+Bug fixes:
+* A bug introduced in update 2.0.2 caused an error in `sjp.lm` for `type = ""std""`.
 
 
 Version 2.0.2

---FILE: NEWS.md---
@@ -1,8 +1,14 @@
-# sjPlot 2.0.2-1
+# sjPlot 2.0.3
 
 ## Changes to functions
 
 * For `sjp.glmer` and `sjp.lmer`, argument `show.ci` now also applies for plotting random effects (`type = ""re""`, the default), so confidence intervals are not calculated. This may be useful in some cases where computation of standard errors for random effects caused an error.
+* `table*, exclude = NULL)` was changed to `table*, useNA = ""always"")`, because of planned changes in upcoming R version 3.4.
+* `get_option(""p_zero"")` was removed, and `sjt.lm`, `sjt.glm`, `sjt.lmer` and `sjt.glmer` get a `p.zero` argument.
+
+## Bug fixes
+
+* A bug introduced in update 2.0.2 caused an error in `sjp.lm` for `type = ""std""`.
 
 
 # sjPlot 2.0.2

---FILE: R/helpfunctions.R---
@@ -193,7 +193,7 @@ create.frq.df <- function(x,
     else
       dat$val <- as.numeric(dat$val)
     # create frequency table
-    dat2 <- data.frame(table(x, exclude = NULL))
+    dat2 <- data.frame(table(x, useNA = ""always""))
     colnames(dat2) <- c(""val"", ""frq"")
     dat2$val <- sjmisc::to_value(dat2$val, keep.labels = F)
     # join frq table and label columns
@@ -203,7 +203,7 @@ create.frq.df <- function(x,
     suppressMessages(sjmisc::replace_na(mydat$frq) <- 0)
   } else {
     # if we have no labels, do simple frq table
-    mydat <- data.frame(table(x, exclude = NULL))
+    mydat <- data.frame(table(x, useNA = ""always""))
     colnames(mydat) <- c(""val"", ""frq"")
     # add values as label
     mydat$label <- labels <- as.character(mydat$val)
@@ -250,7 +250,10 @@ create.frq.df <- function(x,
   # -------------------------------------
   # ""rename"" NA values
   # -------------------------------------
-  if (!is.null(mydat$label)) mydat$label[is.na(mydat$label)] <- ""NA""
+  if (!is.null(mydat$label)) {
+    mydat$label[is.na(mydat$label)] <- ""NA""
+    mydat$label[mydat$label == ""<NA>""] <- ""NA""
+  }
   suppressMessages(sjmisc::replace_na(mydat$val) <- max(sjmisc::to_value(mydat$val), na.rm = T) + 1)
   # save original order
   mydat$order <- sjmisc::to_value(mydat$val, keep.labels = F)
@@ -295,7 +298,7 @@ create.xtab.df <- function(x,
     if (na.rm) {
       mydat <- stats::ftable(table(x_full, grp_full))
     } else {
-      mydat <- stats::ftable(table(x_full, grp_full, exclude = NULL))
+      mydat <- stats::ftable(table(x_full, grp_full, useNA = ""always""))
     }
   } else {
     if (na.rm)
@@ -332,6 +335,7 @@ create.xtab.df <- function(x,
   # rename column names
   colnames(mydat)[1] <- ""label""
   colnames(mydat)[is.na(colnames(mydat))] <- ""NA""
+  colnames(mydat)[colnames(mydat) == ""<NA>""] <- ""NA""
   # label must be character
   mydat$label <- as.character(mydat$label)
   mydat$label[is.na(mydat$label)] <- ""NA""

---FILE: R/sjPlotLinreg.R---
@@ -248,7 +248,7 @@ utils::globalVariables(c(""fit"", ""vars"", ""stdbeta"", ""x"", ""ydiff"", ""y"", ""grp"", "".s
 #' @importFrom dplyr slice select_
 #' @importFrom broom tidy
 #' @importFrom sjmisc is_empty
-#' @importFrom tibble as_tibble
+#' @importFrom tibble as_tibble rownames_to_column
 #' @importFrom nlme getData getResponse getCovariateFormula
 #' @export
 sjp.lm <- function(fit,
@@ -398,9 +398,13 @@ sjp.lm <- function(fit,
   # -------------------------------------------------
   if (type == ""std"" || type == ""std2"") {
     # retrieve standardized betas
-    tmp <- suppressWarnings(sjstats::std_beta(fit, include.ci = TRUE, type = type))
+    tmp <- suppressWarnings(
+      tibble::rownames_to_column(
+        sjstats::std_beta(fit, include.ci = TRUE, type = type)))
     # add ""std."" to title?
     if (!is.null(axis.title) && axis.title == ""Estimates"") axis.title <- ""Std. Estimates""
+    # give common column names
+    colnames(tmp) <- c(""term"", ""estimate"", ""conf.low"", ""conf.high"")
   } else {
     tmp <- broom::tidy(fit, conf.int = TRUE) %>%
              dplyr::slice(-1) %>% 
@@ -845,51 +849,28 @@ sjp.lm.ma <- function(linreg, complete.dgns = FALSE) {
   # Print non-normality of residuals and outliers both of original and updated model
   # dots should be plotted along the line, this the dots should follow a linear direction
   # ---------------------------------
-  ggqqp <- function(fit) {
-    # mixed model model?
-    if (any(class(fit) == ""lme"") || any(class(fit) == ""lmerMod"")) {
-      res_ <- sort(stats::residuals(fit), na.last = NA)
-      y_lab <- ""Residuals""
-    } else {
-      # else, normal model
-      res_ <- sort(stats::rstudent(fit), na.last = NA)
-      y_lab <- ""Studentized Residuals""
-    }
-    fitted_ <- sort(stats::fitted(fit), na.last = NA)
-    # create data frame
-    mydf <- na.omit(data.frame(x = fitted_, y = res_))
-    # try to estimate outlier
-    mydf <- cbind(quot = mydf$x / mydf$y, mydf)
-    mydf$case.nr <- names(res_)
-    mydf$ratio <- mydf$y / mydf$quot
-    # something like a ratio of maximum distance from residuals
-    quot.md <- stats::median(mydf$ratio)
-    quot.sd <- stats::sd(mydf$ratio)
-    quot.rng <- c(quot.md - quot.sd, quot.md + quot.sd)
-    # label outliers with case number
-    mydf$label <- NA
-    outl <- which(mydf$ratio < (2 * quot.rng[1]))
-    mydf$label[outl] <- mydf$case.nr[outl]
-    outl <- which(mydf$ratio > (2 * quot.rng[2]))
-    mydf$label[outl] <- mydf$case.nr[outl]
-    # ggrepel installed?
-    if (!requireNamespace(""ggrepel"", quietly = TRUE)) {
-      text_label <- geom_text(hjust = ""bottom"", vjust = ""bottom"")
-    } else {
-      text_label <- ggrepel::geom_label_repel()
-    }
-    # plot it
-    return(ggplot(mydf, aes(x = x, y = y, label = label)) +
-             geom_point() +
-             text_label +
-             stat_smooth(method = ""lm"", se = FALSE) +
-             labs(title = ""Non-normality of residuals and outliers\n(Dots should be plotted along the line)"",
-                  y = y_lab, x = ""Theoretical quantiles""))
-  }
   sjp.setTheme(theme = ""scatterw"")
   # qq-plot of studentized residuals for base model
-  p1 <- ggqqp(linreg)
-  # save plot
+  # mixed model model?
+  if (any(class(linreg) == ""lme"") || any(class(linreg) == ""lmerMod"")) {
+    res_ <- sort(stats::residuals(linreg), na.last = NA)
+    y_lab <- ""Residuals""
+  } else {
+    # else, normal model
+    res_ <- sort(stats::rstudent(linreg), na.last = NA)
+    y_lab <- ""Studentized Residuals""
+  }
+  fitted_ <- sort(stats::fitted(linreg), na.last = NA)
+  # create data frame
+  mydf <- na.omit(data.frame(x = fitted_, y = res_))
+  # plot it
+  p1 <- ggplot(mydf, aes(x = x, y = y)) +
+           geom_point() +
+           scale_colour_manual(values = c(""#0033cc"", ""#993300"")) +
+           stat_smooth(method = ""lm"", se = FALSE) +
+           labs(title = ""Non-normality of residuals and outliers\n(Dots should be plotted along the line)"",
+                y = y_lab, x = ""Theoretical quantiles (predicted values)"")
+  # save plots
   plot.list[[length(plot.list) + 1]] <- p1
   # print plot
   suppressWarnings(graphics::plot(p1))

---FILE: R/sjTabLinReg.R---
@@ -73,7 +73,8 @@
 #'          effects for each model are printed in the model summary. Only applies to mixed models.
 #'          For details output, see 'Note' in \code{\link[sjstats]{icc}}.
 #' @param show.fstat If \code{TRUE}, the F-statistics for each model is printed
-#'          in the model summary. Default is \code{FALSE}.
+#'          in the model summary. Default is \code{FALSE}. This argument does not apply to
+#'          \code{\link{sjt.lmer}}.
 #' @param show.aic logical, if \code{TRUE}, the AIC value for each model is printed
 #'          in the model summary. Default is \code{FALSE}.
 #' @param show.aicc logical, if \code{TRUE}, the second-order AIC value for each model 
@@ -93,6 +94,9 @@
 #'          cell spacing, which would be: \code{CSS = list(css.thead = ""padding:0.2cm;"", css.tdata = ""padding:0.2cm;"")}.
 #' @param cell.gpr.indent indent for table rows with grouped factor predictors. Only applies
 #'          if \code{group.pred = TRUE}.
+#' @param p.zero logical, if \code{TRUE}, p-values have a leading 0 before the
+#'          period (e.g. \emph{0.002}), else p-values start with a period and
+#'          without a zero (e.g. \emph{.002}).
 #' @param sep.column logical, if \code{TRUE}, an empty table column is added after 
 #'          each model column, to add margins between model columns. By default, this
 #'          column will be added to the output; however, when copying tables to 
@@ -326,6 +330,7 @@ sjt.lm <- function(...,
                    digits.summary = 3,
                    cell.spacing = 0.2,
                    cell.gpr.indent = 0.6,
+                   p.zero = FALSE,
                    sep.column = TRUE,
                    CSS = NULL,
                    encoding = NULL,
@@ -336,13 +341,10 @@ sjt.lm <- function(...,
   # --------------------------------------------------------
   # check p-value-style option
   # --------------------------------------------------------
-  opt <- getOption(""p_zero"")
-  if (is.null(opt) || opt == FALSE) {
+  if (!p.zero)
     p_zero <- """"
-  } else {
+  else
     p_zero <- ""0""
-  }
-  
   # -------------------------------------
   # check arguments
   # -------------------------------------
@@ -1423,6 +1425,7 @@ sjt.lmer <- function(...,
                      digits.summary = 3,
                      cell.spacing = 0.2,
                      cell.gpr.indent = 0.6,
+                     p.zero = FALSE,
                      sep.column = TRUE,
                      CSS = NULL,
                      encoding = NULL,
@@ -1446,6 +1449,6 @@ sjt.lmer <- function(...,
                 group.pred = group.pred, show.col.header = show.col.header, show.r2 = show.r2, show.icc = show.icc, 
                 show.re.var = show.re.var, show.fstat = FALSE, show.aic = show.aic, show.aicc = show.aicc, show.dev = show.dev,
                 remove.estimates = remove.estimates, cell.spacing = cell.spacing, cell.gpr.indent = cell.gpr.indent,
-                sep.column = sep.column, encoding = encoding, 
+                p.zero = p.zero, sep.column = sep.column, encoding = encoding, 
                 CSS = CSS, use.viewer = use.viewer, no.output = no.output, remove.spaces = remove.spaces))
 }
\ No newline at end of file

---FILE: R/sjTabOdds.R---
@@ -205,6 +205,7 @@ sjt.glm <- function(...,
                     digits.summary = 3,
                     cell.spacing = 0.2,
                     cell.gpr.indent = 0.6,
+                    p.zero = FALSE,
                     sep.column = TRUE,
                     CSS = NULL,
                     encoding = NULL,
@@ -216,12 +217,10 @@ sjt.glm <- function(...,
   # --------------------------------------------------------
   # check p-value-style option
   # --------------------------------------------------------
-  opt <- getOption(""p_zero"")
-  if (is.null(opt) || opt == FALSE) {
+  if (!p.zero)
     p_zero <- """"
-  } else {
+  else
     p_zero <- ""0""
-  }
   # check hyphen for ci-range
   if (is.null(ci.hyphen)) ci.hyphen <- ""&nbsp;&ndash;&nbsp;""
   # replace space with protected space in ci-hyphen
@@ -1240,6 +1239,7 @@ sjt.glmer <- function(...,
                       digits.summary = 3,
                       cell.spacing = 0.2,
                       cell.gpr.indent = 0.6,
+                      p.zero = FALSE,
                       sep.column = TRUE,
                       CSS = NULL,
                       encoding = NULL,
@@ -1263,6 +1263,6 @@ sjt.glmer <- function(...,
                  group.pred = group.pred, show.col.header = show.col.header, show.r2 = show.r2, show.icc = show.icc,
                  show.re.var = show.re.var, show.loglik = show.loglik, show.aic = show.aic, show.aicc = show.aicc, show.dev = show.dev,
                  show.chi2 = FALSE, show.hoslem = show.hoslem, show.family = show.family, remove.estimates = remove.estimates,
-                 cell.spacing = cell.spacing, cell.gpr.indent = cell.gpr.indent, sep.column = sep.column,
+                 cell.spacing = cell.spacing, cell.gpr.indent = cell.gpr.indent, p.zero = p.zero, sep.column = sep.column,
                  encoding = encoding, CSS = CSS, use.viewer = use.viewer, no.output = no.output, remove.spaces = remove.spaces))
 }
\ No newline at end of file

---FILE: man/sjPlot-package.Rd---
@@ -36,8 +36,8 @@ The package supports labelled data, i.e. value and variable labels from labelled
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 2.0.2-1\cr
-Date: \tab 2016-08-02\cr
+Version: \tab 2.0.3\cr
+Date: \tab 2016-08-15\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjt.lm.Rd---
@@ -93,7 +93,8 @@ effects for each model are printed in the model summary. Only applies to mixed m
 For details output, see 'Note' in \code{\link[sjstats]{icc}}.}
 
 \item{show.fstat}{If \code{TRUE}, the F-statistics for each model is printed
-in the model summary. Default is \code{FALSE}.}
+in the model summary. Default is \code{FALSE}. This argument does not apply to
+\code{\link{sjt.lmer}}.}
 
 \item{show.aic}{logical, if \code{TRUE}, the AIC value for each model is printed
 in the model summary. Default is \code{FALSE}.}

---FILE: man/sjt.lmer.Rd---
@@ -93,7 +93,8 @@ effects for each model are printed in the model summary. Only applies to mixed m
 For details output, see 'Note' in \code{\link[sjstats]{icc}}.}
 
 \item{show.fstat}{If \code{TRUE}, the F-statistics for each model is printed
-in the model summary. Default is \code{FALSE}.}
+in the model summary. Default is \code{FALSE}. This argument does not apply to
+\code{\link{sjt.lmer}}.}
 
 \item{show.aic}{logical, if \code{TRUE}, the AIC value for each model is printed
 in the model summary. Default is \code{FALSE}.}"
strengejacke,sjPlot,a063c81f7bce198250384a848ec14ac61391b6f9,Daniel Ldecke,d.luedecke@uke.de,2016-07-19T18:39:44Z,Daniel Ldecke,d.luedecke@uke.de,2016-07-19T18:39:44Z,fix bug in sjt.glm(er),NEWS;NEWS.md;R/sjTabLinReg.R;R/sjTabOdds.R,False,True,True,False,10,6,16,"---FILE: NEWS---
@@ -10,6 +10,8 @@ Changes to functions:
 
 Bug fixes:
 * In `sjp.corr`, argument `sort.corr = FALSE` caused an error.
+* In `sjt.glm` and `sjt.glmer`, settingargument `sep.column` to `FALSE` still added separator columns at the right end of the table.
+
 
 Version 2.0.1
 -----------------------------------------------------------------------------

---FILE: NEWS.md---
@@ -13,3 +13,4 @@
 ## Bug fixes
 
 * In `sjp.corr`, argument `sort.corr = FALSE` caused an error.
+* In `sjt.glm` and `sjt.glmer`, settingargument `sep.column` to `FALSE` still added separator columns at the right end of the table.

---FILE: R/sjTabLinReg.R---
@@ -620,10 +620,10 @@ sjt.lm <- function(...,
   if (show.se) headerColSpanFactor <- headerColSpanFactor + 1
   # now that we know how many columns each model needs,
   # we multiply columns per model with count of models, so we have
-  # the column span over all models together; furthermore, we add
-  # count of models to the overall column span, because
-  # each model is separated with an empty table column
+  # the column span over all models together
   headerColSpan <- headerColSpanFactor * headerColSpan
+  # furthermore, we add count of models  to the overall column span, if
+  # each model is separated with an empty table column
   if (sep.column) headerColSpan <- headerColSpan + length(input_list)
   linebreakstring <- "" ""
   if (newline.ci) linebreakstring <- ""<br>""

---FILE: R/sjTabOdds.R---
@@ -463,10 +463,11 @@ sjt.glm <- function(...,
   if (show.se) headerColSpanFactor <- headerColSpanFactor + 1
   # now that we know how many columns each model needs,
   # we multiply columns per model with count of models, so we have
-  # the column span over all models together; furthermore, we add
-  # count of models  to the overall column span, because
+  # the column span over all models together
+  headerColSpan <- headerColSpanFactor * headerColSpan
+  # furthermore, we add count of models  to the overall column span, if
   # each model is separated with an empty table column
-  headerColSpan <- headerColSpanFactor * headerColSpan + length(input_list)
+  if (sep.column) headerColSpan <- headerColSpan + length(input_list)
   linebreakstring <- "" ""
   if (newline.ci) linebreakstring <- ""<br>""
   # -------------------------------------"
strengejacke,sjPlot,772ff0c368064148fcaff425041b972423917f90,Daniel Ldecke,d.luedecke@uke.de,2016-07-09T10:13:57Z,Daniel Ldecke,d.luedecke@uke.de,2016-07-09T10:13:57Z,"Fixed bug in `sjp.corr`, where `sort.corr = FALSE` caused an error.",NEWS;NEWS.md;R/sjPlotCorr.R;R/sjPlotOdds.R,False,True,True,False,12,7,19,"---FILE: NEWS---
@@ -5,6 +5,8 @@ General:
 * Improved title labelling for `type = ""pred""` in `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer`.
 * Improved title and facet title labelling for `type = ""eff""` in `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer`.
 
+Bug fixes:
+* In `sjp.corr`, argument `sort.corr = FALSE` caused an error.
 
 Version 2.0.1
 -----------------------------------------------------------------------------

---FILE: NEWS.md---
@@ -5,3 +5,7 @@
 * Replace deprecated `dplyr::add_rownames()` with `tibble::rownames_to_column()`.
 * Improved title labelling for `type = ""pred""` in `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer`.
 * Improved title and facet title labelling for `type = ""eff""` in `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer`.
+
+## Bug fixes
+
+* In `sjp.corr`, argument `sort.corr = FALSE` caused an error.

---FILE: R/sjPlotCorr.R---
@@ -211,21 +211,20 @@ sjp.corr <- function(data,
     orderedCorr <- corr[neword, neword]
     # order variable labels as well
     axis.labels <- axis.labels[neword]
-    if (!is.null(cpvalues)) {
-      cpvalues <- cpvalues[neword, neword]
-    }
+    if (!is.null(cpvalues)) cpvalues <- cpvalues[neword, neword]
   } else {
-    orderedCorr <- rev(corr)
+    cl <- ncol(corr)
+    orderedCorr <- corr[cl:1, cl:1]
     axis.labels <- rev(axis.labels)
-    if (!is.null(cpvalues)) cpvalues <- rev(cpvalues)
+    if (!is.null(cpvalues)) cpvalues <- cpvalues[cl:1, cl:1]
   }
   # --------------------------------------------------------
   # prepare a ordering-index-column needed for the data frame
   # that is passed to the ggplot
   # --------------------------------------------------------
   yo <- c()
   for (i in 1:nrow(corr)) {
-    yo <- c(yo, c(rep(i, nrow(corr))))
+    yo <- c(yo, rep(i, nrow(corr)))
   }
   # --------------------------------------------------------
   # melt correlation matrix and create data frame

---FILE: R/sjPlotOdds.R---
@@ -880,7 +880,7 @@ sjp.glm.predy <- function(fit,
   # init legend labels
   legend.labels <- NULL
   # check if we have a categorical variable with value
-  # labels at the x-axis
+  # labels at the x-axis.
   axis_labels <- sjmisc::get_labels(mydf[[1]])
   # ----------------------------
   # with or w/o grouping factor?"
strengejacke,sjPlot,bdaaedd54aec4e9283cf7653bceb63a967dd433a,Daniel Ldecke,d.luedecke@uke.de,2016-06-21T16:53:24Z,Daniel Ldecke,d.luedecke@uke.de,2016-06-21T16:53:24Z,"using sjstats now, fixing selective imports, prepare for CRAN submit",DESCRIPTION;NAMESPACE;NEWS;NEWS.md;R/helpfunctions.R;R/sjPlotAncovaLSMeans.R;R/sjPlotAnova.R;R/sjPlotClusterAnalysis.R;R/sjPlotCorr.R;R/sjPlotFrequencies.R;R/sjPlotGLME.R;R/sjPlotGroupFrequencies.R;R/sjPlotGroupPropTable.R;R/sjPlotInteractions.R;R/sjPlotLikert.R;R/sjPlotLinreg.R;R/sjPlotLinregMultiple.R;R/sjPlotOdds.R;R/sjPlotOddsMultiple.R;R/sjPlotPCA.R;R/sjPlotPearsonsChi2Test.R;R/sjPlotPropTable.R;R/sjPlotScatter.R;R/sjPlotStackFrequencies.R;R/sjTabCorr.R;R/sjTabFrequencies.R;R/sjTabGrpmean.R;R/sjTabItemAnalysis.R;R/sjTabLinReg.R;R/sjTabOdds.R;R/sjTabPropTable.R;R/sjTabSPSS.R;man/sjPlot-package.Rd;man/sjp.int.Rd;man/sjt.itemanalysis.Rd,False,True,True,False,90,54,144,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 2.0.0-3
-Date: 2016-06-07
+Version: 2.0.1
+Date: 2016-06-21
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of plotting and table output functions for data

---FILE: NAMESPACE---
@@ -47,8 +47,6 @@ export(sjt.stackfrq)
 export(sjt.xtab)
 export(view_df)
 import(ggplot2)
-import(sjmisc)
-import(sjstats)
 importFrom(dplyr,add_rownames)
 importFrom(dplyr,arrange)
 importFrom(dplyr,bind_rows)
@@ -90,6 +88,45 @@ importFrom(psych,describe)
 importFrom(scales,brewer_pal)
 importFrom(scales,grey_pal)
 importFrom(scales,percent)
+importFrom(sjmisc,get_label)
+importFrom(sjmisc,get_labels)
+importFrom(sjmisc,get_note)
+importFrom(sjmisc,get_values)
+importFrom(sjmisc,group_labels)
+importFrom(sjmisc,group_str)
+importFrom(sjmisc,group_var)
+importFrom(sjmisc,is_empty)
+importFrom(sjmisc,is_even)
+importFrom(sjmisc,is_num_fac)
+importFrom(sjmisc,is_odd)
+importFrom(sjmisc,rec)
+importFrom(sjmisc,replace_na)
+importFrom(sjmisc,set_labels)
+importFrom(sjmisc,set_na)
+importFrom(sjmisc,str_contains)
+importFrom(sjmisc,to_factor)
+importFrom(sjmisc,to_label)
+importFrom(sjmisc,to_value)
+importFrom(sjmisc,trim)
+importFrom(sjmisc,word_wrap)
+importFrom(sjstats,chisq_gof)
+importFrom(sjstats,cod)
+importFrom(sjstats,cramer)
+importFrom(sjstats,cronb)
+importFrom(sjstats,hoslem_gof)
+importFrom(sjstats,icc)
+importFrom(sjstats,mean_n)
+importFrom(sjstats,merMod_p)
+importFrom(sjstats,mic)
+importFrom(sjstats,phi)
+importFrom(sjstats,r2)
+importFrom(sjstats,reliab_test)
+importFrom(sjstats,se)
+importFrom(sjstats,std_beta)
+importFrom(sjstats,table_values)
+importFrom(sjstats,weight)
+importFrom(sjstats,weight2)
+importFrom(sjstats,wtd_sd)
 importFrom(stats,AIC)
 importFrom(stats,anova)
 importFrom(stats,aov)

---FILE: NEWS---
@@ -1,4 +1,4 @@
-Version 2.0.0-3
+Version 2.0.1
 -----------------------------------------------------------------------------
 General:
 * `sjt.lmer` and `sjt.glmer` now warn when `show.aic = TRUE` and models were fitted with REML instead of ML.
@@ -7,7 +7,7 @@ General:
 Changes to functions:
 * Added `group.estimate` argument to `sjp.lmer` and `sjp.glmer` (for fixed effetcs only).
 * `sjt.frq`, `sjt.xtab` and `view_df` now show notes (`note`-attribute, see `sjmisc::set_note`) of labelled data as tooltip, when mouse hovers the variable name/label, in the HTML-output.
-* `axis.title` argument for `sjp.glmer` and `sjp.lmer` can now be a vector of length one or two, to be more flexible with axes titles for the various plot types.
+* `axis.title` argument for `sjp.glmer` and `sjp.lmer` can now be a vector of length one or two, to be more flexible with axis titles for the various plot types.
 * `sjt.lm`, `sjt.glm`, `sjt.lmer` and `sjt.glmer` get a `sep.column` argument to add (default) or remove a separator column (i.e. margin) between model columns.
 * `sjp.scatter` now uses value labels from grouping variable as title for plots if `facet.grid = TRUE`.
 * Argument `axis.title` now also applies to `type = ""pred""` for `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer`.

---FILE: NEWS.md---
@@ -1,4 +1,4 @@
-# sjPlot 2.0.0-3
+# sjPlot 2.0.1
 
 ## General
 
@@ -9,7 +9,7 @@
 
 * Added `group.estimate` argument to `sjp.lmer` and `sjp.glmer` (for fixed effetcs only).
 * `sjt.frq`, `sjt.xtab` and `view_df` now show notes (`note`-attribute, see `sjmisc::set_note`) of labelled data as tooltip, when mouse hovers the variable name/label, in the HTML-output.
-* `axis.title` argument for `sjp.glmer` and `sjp.lmer` can now be a vector of length one or two, to be more flexible with axes titles for the various plot types.
+* `axis.title` argument for `sjp.glmer` and `sjp.lmer` can now be a vector of length one or two, to be more flexible with axis titles for the various plot types.
 * `sjt.lm`, `sjt.glm`, `sjt.lmer` and `sjt.glmer` get a `sep.column` argument to add (default) or remove a separator column (i.e. margin) between model columns.
 * `sjp.scatter` now uses value labels from grouping variable as title for plots if `facet.grid = TRUE`.
 * Argument `axis.title` now also applies to `type = ""pred""` for `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer`.

---FILE: R/helpfunctions.R---
@@ -13,6 +13,7 @@ base_breaks <- function(n = 10) {
 }
 
 
+#' @importFrom sjmisc get_label get_labels str_contains to_label to_value replace_na word_wrap
 get_lm_data <- function(fit) {
   if (any(class(fit) == ""plm"")) {
     # plm objects have different structure than (g)lm
@@ -141,7 +142,7 @@ get_var_name <- function(x) {
 
 # Create frequency data frame of a variable
 # for sjp and sjt frq functions
-#' @import sjstats
+#' @importFrom sjstats weight table_values cramer phi
 #' @importFrom stats na.omit
 #' @importFrom dplyr add_rownames full_join
 create.frq.df <- function(x,

---FILE: R/sjPlotAncovaLSMeans.R---
@@ -2,6 +2,7 @@
 utils::globalVariables(c(""xn"", ""vld"", ""conf.low"", ""conf.high""))
 
 #' @importFrom dplyr filter
+#' @importFrom sjstats merMod_p
 sjp.emm <- function(fit,
                     swap.pred = FALSE,
                     plevel = 0.05,

---FILE: R/sjPlotAnova.R---
@@ -40,7 +40,7 @@ utils::globalVariables(""pv"")
 #' 
 #' 
 #' @import ggplot2
-#' @import sjmisc
+#' @importFrom sjmisc get_label get_labels trim word_wrap to_value
 #' @importFrom stats confint aov summary.lm
 #' @importFrom dplyr add_rownames
 #' @export

---FILE: R/sjPlotClusterAnalysis.R---
@@ -98,7 +98,6 @@ utils::globalVariables(c(""xpos"", ""value"", ""Var2"", ""grp"", ""prc"", ""fg"", ""cprc"", ""s
 #' sjc.qclus(airquality, groupcount = 3, groups = airgrp$classification)
 #' 
 #' @import ggplot2
-#' @import sjmisc
 #' @importFrom stats na.omit
 #' @importFrom graphics plot
 #' @export

---FILE: R/sjPlotCorr.R---
@@ -84,7 +84,6 @@ utils::globalVariables(c(""ordx"", ""ordy""))
 #'
 #'
 #' @import ggplot2
-#' @import sjmisc
 #' @importFrom tidyr gather
 #' @importFrom scales brewer_pal grey_pal
 #' @importFrom stats cor cor.test na.omit
@@ -177,8 +176,9 @@ sjp.corr <- function(data,
       for (i in 1:ncol(df)) {
         pv <- c()
         for (j in 1:ncol(df)) {
-          test <- stats::cor.test(df[[i]], df[[j]], alternative = ""two.sided"", 
-                                  method = corr.method)
+          test <- suppressWarnings(stats::cor.test(df[[i]], df[[j]], 
+                                                   alternative = ""two.sided"", 
+                                                   method = corr.method))
           pv <- cbind(pv, round(test$p.value, 4))
         }
         cp <- rbind(cp, pv)

---FILE: R/sjPlotFrequencies.R---
@@ -104,8 +104,8 @@ utils::globalVariables(c(""val"", ""frq"", ""grp"", ""label.pos"", ""upper.ci"", ""lower.ci
 #'         normal.curve.size = 3, ylim = c(0,50))
 #' 
 #' @import ggplot2
-#' @import sjmisc
-#' @import sjstats
+#' @importFrom sjstats wtd_sd
+#' @importFrom sjmisc set_labels group_labels group_var
 #' @importFrom stats na.omit sd weighted.mean
 #' @export
 sjp.frq <- function(var.cnt,

---FILE: R/sjPlotGLME.R---
@@ -224,7 +224,6 @@ utils::globalVariables(c(""estimate"", ""nQQ"", ""ci"", ""fixef"", ""fade"", ""conf.low"", ""
 #'
 #'                      
 #' @import ggplot2
-#' @import sjstats
 #' @importFrom dplyr slice add_rownames sample_n
 #' @importFrom lme4 fixef ranef confint.merMod getME
 #' @export
@@ -514,7 +513,7 @@ sjp.glmer <- function(fit,
 #'          facet.grid = FALSE, show.ci = FALSE)}
 #'
 #' @import ggplot2
-#' @import sjstats
+#' @importFrom sjstats se std_beta merMod_p
 #' @importFrom dplyr sample_n add_rownames slice
 #' @export
 sjp.lmer <- function(fit,
@@ -1555,7 +1554,7 @@ sjp.glmer.ri.slope <- function(fit, show.ci, facet.grid, ri.nr, vars, emph.grp,
           # -------------------------------------
           # check if metric plots should be plotted
           # -------------------------------------
-          if (prnt.plot) graphics::plot(mp)
+          if (prnt.plot) suppressWarnings(graphics::plot(mp))
         }
       }
     }

---FILE: R/sjPlotGroupFrequencies.R---
@@ -154,8 +154,7 @@ utils::globalVariables(c(""."", ""label"", ""prz"", ""frq"", ""ypos"", ""wb"", ""ia"", ""mw"", ""
 #' sjp.grpfrq(efc$neg_c_7, efc$e42dep, type = ""line"")
 #'            
 #' @import ggplot2
-#' @import sjmisc
-#' @import sjstats
+#' @importFrom sjstats weight2
 #' @importFrom tidyr gather
 #' @importFrom dplyr group_by mutate arrange summarise add_rownames
 #' @importFrom stats na.omit xtabs wilcox.test sd

---FILE: R/sjPlotGroupPropTable.R---
@@ -55,10 +55,10 @@ utils::globalVariables(c(""dep"", ""n""))
 #' sjp.gpt(efc$c172code, efc$e42dep, efc$n4pstu)
 #'
 #' @import ggplot2
-#' @import sjmisc
 #' @importFrom magrittr ""%>%""
 #' @importFrom dplyr group_by summarise bind_rows
 #' @importFrom scales percent
+#' @importFrom sjmisc to_factor rec
 #' @importFrom stats na.omit chisq.test
 #' @export
 sjp.gpt <- function(x,

---FILE: R/sjPlotInteractions.R---
@@ -3,7 +3,7 @@
 #'
 #' @references \itemize{
 #'              \item Aiken and West (1991). Multiple Regression: Testing and Interpreting Interactions.
-#'              \item Brambor T, Clark WR and Golder M (2006) Understanding Interaction Models: Improving Empirical Analyses. Political Analysis 14: 63-82 \href{https://files.nyu.edu/mrg217/public/pa_final.pdf}{download}
+#'              \item Brambor T, Clark WR and Golder M (2006) Understanding Interaction Models: Improving Empirical Analyses. Political Analysis 14: 63-82. \doi{10.1093/pan/mpi014}
 #'              \item Esarey J, Sumner JL (2015) Marginal Effects in Interaction Models: Determining and Controlling the False Positive Rate. \href{http://jee3.web.rice.edu/interaction-overconfidence.pdf}{download}
 #'              \item Fox J (2003) Effect displays in R for generalised linear models. Journal of Statistical Software 8:15, 127, \href{http://www.jstatsoft.org/v08/i15/}{<http://www.jstatsoft.org/v08/i15/>}
 #'              \item Hayes AF (2012) PROCESS: A versatile computational tool for observed variable mediation, moderation, and conditional process modeling [White paper] \href{http://imaging.mrc-cbu.cam.ac.uk/statswiki/FAQ/SobelTest?action=AttachFile&do=get&target=process.pdf}{download}
@@ -274,8 +274,8 @@
 #' sjp.int(fit, type = ""eff"", int.plot.index = 3, show.ci = TRUE, facet.grid = TRUE)}
 #'
 #' @import ggplot2
-#' @import sjmisc
 #' @importFrom stats family quantile
+#' @importFrom sjmisc is_num_fac
 #' @importFrom effects allEffects effect
 #' @export
 sjp.int <- function(fit,
@@ -366,7 +366,7 @@ sjp.int <- function(fit,
   if (is.null(grid.breaks)) gridbreaks.x <- gridbreaks.y <- ggplot2::waiver()
   # check matching argument combinations
   if (type == ""cond"" && mdrt.values == ""all"") {
-    message(""`mdrt.values = \""all\""` only applies to `type = \""eff\"". Defaulting `mdrt.values` to `minmax`."")
+    message(""`mdrt.values = \""all\""` only applies to `type = \""eff\""`. Defaulting `mdrt.values` to `minmax`."")
     mdrt.values <- ""minmax""
   }
   # ------------------------

---FILE: R/sjPlotLikert.R---
@@ -125,8 +125,8 @@ utils::globalVariables(c(""offset""))
 #'            values = ""sum.inside"")
 #' 
 #' @import ggplot2
-#' @import sjmisc
 #' @importFrom stats na.omit xtabs
+#' @importFrom sjmisc is_odd set_na
 #' @export
 sjp.likert <- function(items,
                        title = NULL, 
@@ -237,7 +237,12 @@ sjp.likert <- function(items,
       catcount <- unique(c(catcount, unique(stats::na.omit(items[[i]]))))
     }
     # remove neutral category
-    if (!is.null(cat.neutral)) catcount <- catcount[-which(catcount == cat.neutral)]
+    if (!is.null(cat.neutral)) {
+      # find neutral cat value in catcount
+      ncv_pos <- which(catcount == cat.neutral)
+      # if not empty, remove
+      if (!sjmisc::is_empty(ncv_pos)) catcount <- catcount[-ncv_pos]
+    }
     # detect range of valid categories, which
     # then equals catcount
     catcount <- max(catcount) - min(catcount) + 1

---FILE: R/sjPlotLinreg.R---
@@ -244,9 +244,9 @@ utils::globalVariables(c(""fit"", ""vars"", ""Beta"", ""xv"", ""lower"", ""upper"", ""stdbeta
 #' sjp.lm(fit, type = ""poly"", poly.term = ""e17age"")}
 #'
 #' @import ggplot2
-#' @import sjmisc
 #' @importFrom stats model.matrix confint coef residuals sd
 #' @importFrom dplyr slice
+#' @importFrom sjmisc is_empty
 #' @importFrom nlme getData getResponse getCovariateFormula
 #' @export
 sjp.lm <- function(fit,

---FILE: R/sjPlotLinregMultiple.R---
@@ -85,9 +85,9 @@ utils::globalVariables(c(""beta"", ""lower"", ""upper"", ""p"", ""pa"", ""shape""))
 #' sjp.lmm(fit1, fit2, fit3, type = ""std2"")
 #' 
 #' @import ggplot2
-#' @import sjmisc
 #' @importFrom stats coef confint
 #' @importFrom dplyr slice
+#' @importFrom sjstats merMod_p
 #' @export
 sjp.lmm <- function(...,
                     type = ""lm"",

---FILE: R/sjPlotOdds.R---
@@ -118,7 +118,6 @@ utils::globalVariables(c(""OR"", ""lower"", ""upper"", ""p""))
 #' sjp.glm(fit, type = ""pred"", vars = c(""barthel"", ""dep""), facet.grid = FALSE)
 #' 
 #' @import ggplot2
-#' @import sjmisc
 #' @importFrom stats na.omit coef confint logLik
 #' @export
 sjp.glm <- function(fit,
@@ -749,10 +748,10 @@ sjp.glm.slope <- function(fit, title, geom.size, geom.colors, remove.estimates,
   # --------------------------
   if (prnt.plot) {
     if (facet.grid && !is.null(plot.facet)) {
-      graphics::plot(plot.facet)
+      suppressWarnings(graphics::plot(plot.facet))
     } else {
       for (i in 1:length(plot.metricpred)) {
-        graphics::plot(plot.metricpred[[i]])
+        suppressWarnings(graphics::plot(plot.metricpred[[i]]))
       }
     }
   }
@@ -986,7 +985,7 @@ sjp.glm.predy <- function(fit,
   # --------------------------
   # plot plots
   # --------------------------
-  if (prnt.plot) graphics::plot(mp)
+  if (prnt.plot) suppressWarnings(graphics::plot(mp))
   return(structure(class = c(""sjPlot"", ""sjpglm.ppresp""),
                    list(data = mydf, plot = mp)))
 }

---FILE: R/sjPlotOddsMultiple.R---
@@ -81,7 +81,6 @@ utils::globalVariables(c(""OR"", ""lower"", ""upper"", ""p"", ""pa"", ""shape""))
 #' sjp.glmm(fit1, fit2, fit3)
 #' 
 #' @import ggplot2
-#' @import sjmisc
 #' @importFrom stats na.omit coef confint
 #' @export
 sjp.glmm <- function(...,

---FILE: R/sjPlotPCA.R---
@@ -92,6 +92,7 @@
 #' @importFrom tidyr gather
 #' @importFrom scales brewer_pal grey_pal
 #' @importFrom stats na.omit prcomp
+#' @importFrom sjstats cronb
 #' @export
 sjp.pca <- function(data,
                     nmbr.fctr = NULL,

---FILE: R/sjPlotPearsonsChi2Test.R---
@@ -33,7 +33,6 @@ utils::globalVariables(c(""Row"", ""Column"", ""p.value""))
 #' 
 #' @import ggplot2
 #' @importFrom dplyr bind_rows
-#' @import sjmisc
 #' @export
 sjp.chi2 <- function(df,
                      title = ""Pearson's Chi2-Test of Independence"",

---FILE: R/sjPlotPropTable.R---
@@ -83,7 +83,6 @@ utils::globalVariables(c(""rowname"", ""total"", ""ges"", ""prc"", ""n"", ""Count"", ""Group""
 #'          bar.pos = ""stack"", coord.flip = TRUE)
 #'
 #' @import ggplot2
-#' @import sjmisc
 #' @importFrom dplyr group_by mutate arrange add_rownames filter select summarize
 #' @importFrom tidyr gather
 #' @importFrom scales percent

---FILE: R/sjPlotScatter.R---
@@ -258,7 +258,7 @@ sjp.scatter <- function(x = NULL,
   # --------------------------------------------------------
   # Check whether we have any labels passed as parameter
   # if not, use category text of group variable as legend text
-  if (is.null(legend.labels)) legend.labels <- sort(unique(df$grp))
+  if (is.null(legend.labels)) legend.labels <- as.character(sort(unique(df$grp)))
   # wrap legend text lines
   legend.labels <- sjmisc::word_wrap(legend.labels, wrap.legend.labels)
   # check whether we have a title for the legend

---FILE: R/sjPlotStackFrequencies.R---
@@ -62,7 +62,6 @@
 #' 
 #' @import ggplot2
 #' @importFrom dplyr group_by mutate arrange
-#' @import sjmisc
 #' @importFrom scales percent
 #' @importFrom stats na.omit xtabs
 #' @export

---FILE: R/sjTabCorr.R---
@@ -193,10 +193,9 @@ sjt.corr <- function(data,
       for (i in 1:ncol(df)) {
         pv <- c()
         for (j in 1:ncol(df)) {
-          test <- cor.test(df[[i]], 
-                           df[[j]], 
-                           alternative = ""two.sided"", 
-                           method = corr.method)
+          test <- suppressWarnings(stats::cor.test(df[[i]], df[[j]], 
+                                                   alternative = ""two.sided"", 
+                                                   method = corr.method))
           pv <- cbind(pv, round(test$p.value, 5))
         }
         cp <- rbind(cp, pv)

---FILE: R/sjTabFrequencies.R---
@@ -155,7 +155,7 @@
 #' 
 #' @importFrom psych describe
 #' @importFrom stats na.omit weighted.mean
-#' @import sjmisc
+#' @importFrom sjmisc get_note group_str
 #' @export
 sjt.frq <- function(data,
                     weight.by = NULL,

---FILE: R/sjTabGrpmean.R---
@@ -41,7 +41,6 @@
 #' data(efc)
 #' sjt.grpmean(efc$c12hour, efc$e42dep)}
 #'             
-#' @import sjmisc
 #' @importFrom stats na.omit lm
 #' @export
 sjt.grpmean <- function(var.cnt,

---FILE: R/sjTabItemAnalysis.R---
@@ -86,8 +86,8 @@
 #' 
 #' @references \itemize{
 #'              \item Jorion N, Self B, James K, Schroeder L, DiBello L, Pellegrino J (2013) Classical Test Theory Analysis of the Dynamics Concept Inventory. (\href{https://www.academia.edu/4104752/Classical_Test_Theory_Analysis_of_the_Dynamics_Concept_Inventory}{web})
-#'              \item Briggs SR, Cheek JM (1986) The role of factor analysis in the development and evaluation of personality scales. Journal of Personality, 54(1), 106-148 (\doi{10.1111/j.1467-6494.1986.tb00391.x})
-#'              \item McLean S et al. (2013) Stigmatizing attitudes and beliefs about bulimia nervosa: Gender, age, education and income variability in a community sample. International Journal of Eating Disorders, \doi{10.1002/eat.22227}.
+#'              \item Briggs SR, Cheek JM (1986) The role of factor analysis in the development and evaluation of personality scales. Journal of Personality, 54(1), 106-148. \doi{10.1111/j.1467-6494.1986.tb00391.x}
+#'              \item McLean S et al. (2013) Stigmatizing attitudes and beliefs about bulimia nervosa: Gender, age, education and income variability in a community sample. International Journal of Eating Disorders. \doi{10.1002/eat.22227}
 #'              \item Trochim WMK (2008) Types of Reliability. (\href{http://www.socialresearchmethods.net/kb/reltypes.php}{web})
 #'             }
 #' 
@@ -121,7 +121,7 @@
 #'  
 #' @importFrom psych describe
 #' @importFrom stats shapiro.test
-#' @import sjmisc
+#' @importFrom sjstats reliab_test mean_n mic cronb
 #' @export
 sjt.itemanalysis <- function(df,
                              factor.groups = NULL,

---FILE: R/sjTabLinReg.R---
@@ -281,6 +281,7 @@
 #' @importFrom dplyr full_join slice
 #' @importFrom stats nobs AIC confint coef deviance
 #' @importFrom lme4 VarCorr
+#' @importFrom sjstats std_beta icc r2 cod chisq_gof hoslem_gof
 #' @export
 sjt.lm <- function(...,
                    pred.labels = NULL,

---FILE: R/sjTabOdds.R---
@@ -162,6 +162,7 @@
 #'
 #' @importFrom dplyr full_join slice
 #' @importFrom stats nobs AIC confint coef logLik family deviance
+#' @importFrom sjstats std_beta icc r2 cod chisq_gof hoslem_gof
 #' @export
 sjt.glm <- function(...,
                     pred.labels = NULL,

---FILE: R/sjTabPropTable.R---
@@ -74,7 +74,6 @@
 #'                     css.tdata = ""border: 1px solid;"",
 #'                     css.horline = ""border-bottom: double blue;""))}
 #'
-#' @import sjmisc
 #' @importFrom stats xtabs ftable
 #' @export
 sjt.xtab <- function(var.row,

---FILE: R/sjTabSPSS.R---
@@ -72,8 +72,8 @@
 #'                    css.tdata = ""border: 1px solid;"",
 #'                    css.arc = ""color:blue;""))}
 #'
-#' @import sjmisc 
 #' @importFrom utils txtProgressBar setTxtProgressBar
+#' @importFrom sjmisc is_even get_values
 #' @export
 view_df <- function(x,
                     weight.by = NULL,

---FILE: man/sjPlot-package.Rd---
@@ -36,8 +36,8 @@ The package supports labelled data, i.e. value and variable labels from labelled
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 2.0.0-3\cr
-Date: \tab 2016-06-07\cr
+Version: \tab 2.0.1\cr
+Date: \tab 2016-06-21\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjp.int.Rd---
@@ -340,7 +340,7 @@ sjp.int(fit, type = ""eff"", int.plot.index = 3, show.ci = TRUE, facet.grid = TRUE
 \references{
 \itemize{
              \item Aiken and West (1991). Multiple Regression: Testing and Interpreting Interactions.
-             \item Brambor T, Clark WR and Golder M (2006) Understanding Interaction Models: Improving Empirical Analyses. Political Analysis 14: 63-82 \href{https://files.nyu.edu/mrg217/public/pa_final.pdf}{download}
+             \item Brambor T, Clark WR and Golder M (2006) Understanding Interaction Models: Improving Empirical Analyses. Political Analysis 14: 63-82. \doi{10.1093/pan/mpi014}
              \item Esarey J, Sumner JL (2015) Marginal Effects in Interaction Models: Determining and Controlling the False Positive Rate. \href{http://jee3.web.rice.edu/interaction-overconfidence.pdf}{download}
              \item Fox J (2003) Effect displays in R for generalised linear models. Journal of Statistical Software 8:15, 127, \href{http://www.jstatsoft.org/v08/i15/}{<http://www.jstatsoft.org/v08/i15/>}
              \item Hayes AF (2012) PROCESS: A versatile computational tool for observed variable mediation, moderation, and conditional process modeling [White paper] \href{http://imaging.mrc-cbu.cam.ac.uk/statswiki/FAQ/SobelTest?action=AttachFile&do=get&target=process.pdf}{download}

---FILE: man/sjt.itemanalysis.Rd---
@@ -169,8 +169,8 @@ sjt.itemanalysis(mydf, factor.groups)}
 \references{
 \itemize{
              \item Jorion N, Self B, James K, Schroeder L, DiBello L, Pellegrino J (2013) Classical Test Theory Analysis of the Dynamics Concept Inventory. (\href{https://www.academia.edu/4104752/Classical_Test_Theory_Analysis_of_the_Dynamics_Concept_Inventory}{web})
-             \item Briggs SR, Cheek JM (1986) The role of factor analysis in the development and evaluation of personality scales. Journal of Personality, 54(1), 106-148 (\doi{10.1111/j.1467-6494.1986.tb00391.x})
-             \item McLean S et al. (2013) Stigmatizing attitudes and beliefs about bulimia nervosa: Gender, age, education and income variability in a community sample. International Journal of Eating Disorders, \doi{10.1002/eat.22227}.
+             \item Briggs SR, Cheek JM (1986) The role of factor analysis in the development and evaluation of personality scales. Journal of Personality, 54(1), 106-148. \doi{10.1111/j.1467-6494.1986.tb00391.x}
+             \item McLean S et al. (2013) Stigmatizing attitudes and beliefs about bulimia nervosa: Gender, age, education and income variability in a community sample. International Journal of Eating Disorders. \doi{10.1002/eat.22227}
              \item Trochim WMK (2008) Types of Reliability. (\href{http://www.socialresearchmethods.net/kb/reltypes.php}{web})
             }
 }"
strengejacke,sjPlot,8bd7f94cca01d030427e42ad7b9887f4a99d9762,Daniel Ldecke,d.luedecke@uke.de,2016-06-16T16:55:19Z,Daniel Ldecke,d.luedecke@uke.de,2016-06-16T16:55:19Z,"Added argument `jitter.ci` to `sjp.int` to add jittering to confidence bands for error bars, to avoid overlap",NEWS;NEWS.md;R/sjPlotInteractions.R;man/sjp.int.Rd,False,True,True,False,37,12,49,"---FILE: NEWS---
@@ -12,6 +12,7 @@ Changes to functions:
 * Argument `axis.title` now also applies to `type = ""pred""` for `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer`.
 * Argument `geom.colors` now applies to more plot types in `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer`. 
 * Added argument `legend.title` to `sjp.lmer` and `sjp.glmer` to set legend title for those plot types who have legends.
+* Added argument `jitter.ci` to `sjp.int` to add jittering to confidence bands for error bars, to avoid overlap.
 
 Bug fixes:
 * `axis.lim` was not recognized for non-binomial model families and linear models slope- and effect-plot-types.

---FILE: NEWS.md---
@@ -14,6 +14,7 @@
 * Argument `axis.title` now also applies to `type = ""pred""` for `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer`.
 * Argument `geom.colors` now applies to more plot types in `sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer`. 
 * Added argument `legend.title` to `sjp.lmer` and `sjp.glmer` to set legend title for those plot types who have legends.
+* Added argument `jitter.ci` to `sjp.int` to add jittering to confidence bands for error bars, to avoid overlap.
 
 ## Bug fixes
 

---FILE: R/sjPlotInteractions.R---
@@ -105,6 +105,9 @@
 #'          if numeric, must be a number between 0 and 1, indicating the proportion
 #'          for the confidence regeion (e.g. \code{show.ci = 0.9} plots a 90\% CI).
 #'          Only applies to \code{type = ""emm""} or \code{type = ""eff""}.
+#' @param jitter.ci logical, if \code{TRUE} and \code{show.ci = TRUE} and confidence
+#'          bands are displayed as error bars, adds jittering to lines and error bars
+#'          to avoid overlapping.
 #' 
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjp.frq
@@ -297,6 +300,7 @@ sjp.int <- function(fit,
                     fill.alpha = 0.3,
                     show.values = FALSE,
                     show.ci = FALSE,
+                    jitter.ci = FALSE,
                     p.kr = TRUE,
                     grid.breaks = NULL,
                     xlim = NULL,
@@ -406,7 +410,7 @@ sjp.int <- function(fit,
                        title, fill.alpha, geom.colors, geom.size, axis.title,
                        legend.title, legend.labels, show.values, wrap.title, wrap.legend.labels, 
                        wrap.legend.title, xlim, ylim, y.offset, grid.breaks, 
-                       show.ci, p.kr, facet.grid, prnt.plot, fun, ...))
+                       show.ci, jitter.ci, p.kr, facet.grid, prnt.plot, fun, ...))
   }
   # -----------------------------------------------------------
   # set axis title
@@ -890,6 +894,7 @@ sjp.eff.int <- function(fit,
                         y.offset = 0.07,
                         grid.breaks = NULL,
                         show.ci = FALSE,
+                        jitter.ci = FALSE,
                         p.kr = FALSE,
                         facet.grid = FALSE,
                         prnt.plot = TRUE,
@@ -1290,26 +1295,40 @@ sjp.eff.int <- function(fit,
     # confidence interval?
     # ------------------------------------------------------------
     if (show.ci) {
+      # -------------------------------------------------
+      # for factors, we add error bars instead of
+      # continuous confidence region
+      # -------------------------------------------------
       if (x_is_factor) {
         # -------------------------------------------------
-        # for factors, we add error bars instead of
-        # continuous confidence region
+        # check if to add jittering
         # -------------------------------------------------
-        baseplot <- baseplot +
-          geom_errorbar(aes(ymin = conf.low, ymax = conf.high, colour = grp),
-                        width = 0, show.legend = FALSE) +
-          geom_point()
+        if (jitter.ci) {
+          baseplot <- baseplot +
+            geom_errorbar(aes(ymin = conf.low, ymax = conf.high, colour = grp),
+                          width = 0, show.legend = FALSE, position = position_dodge(.2)) +
+            geom_point(position = position_dodge(.2)) +
+            geom_line(size = geom.size, position = position_dodge(.2))
+        } else {
+          baseplot <- baseplot +
+            geom_errorbar(aes(ymin = conf.low, ymax = conf.high, colour = grp),
+                          width = 0, show.legend = FALSE) +
+            geom_point() +
+            geom_line(size = geom.size)
+        }
       } else {
         # -------------------------------------------------
         # for continuous variables, we add  continuous 
         # confidence region instead of error bars 
         # -------------------------------------------------
         baseplot <- baseplot +
           geom_ribbon(aes(ymin = conf.low, ymax = conf.high, colour = NULL, fill = grp),
-                      alpha = fill.alpha, show.legend = FALSE)
+                      alpha = fill.alpha, show.legend = FALSE) +
+          geom_line(size = geom.size)
       }
+    } else {
+      baseplot <- baseplot + geom_line(size = geom.size)
     }
-    baseplot <- baseplot + geom_line(size = geom.size)
     # ------------------------------------------------------------
     # plot value labels
     # ------------------------------------------------------------

---FILE: man/sjp.int.Rd---
@@ -11,9 +11,9 @@ sjp.int(fit, type = c(""eff"", ""cond"", ""emm""), int.term = NULL,
   legend.title = NULL, legend.labels = NULL, wrap.title = 50,
   wrap.legend.labels = 20, wrap.legend.title = 20, geom.colors = ""Set1"",
   geom.size = NULL, fill.color = ""grey"", fill.alpha = 0.3,
-  show.values = FALSE, show.ci = FALSE, p.kr = TRUE, grid.breaks = NULL,
-  xlim = NULL, ylim = NULL, y.offset = 0.07, digits = 2,
-  facet.grid = FALSE, prnt.plot = TRUE, ...)
+  show.values = FALSE, show.ci = FALSE, jitter.ci = FALSE, p.kr = TRUE,
+  grid.breaks = NULL, xlim = NULL, ylim = NULL, y.offset = 0.07,
+  digits = 2, facet.grid = FALSE, prnt.plot = TRUE, ...)
 }
 \arguments{
 \item{fit}{the fitted (generalized) linear (mixed) model object, including interaction terms. Accepted model
@@ -123,6 +123,10 @@ if numeric, must be a number between 0 and 1, indicating the proportion
 for the confidence regeion (e.g. \code{show.ci = 0.9} plots a 90\% CI).
 Only applies to \code{type = ""emm""} or \code{type = ""eff""}.}
 
+\item{jitter.ci}{logical, if \code{TRUE} and \code{show.ci = TRUE} and confidence
+bands are displayed as error bars, adds jittering to lines and error bars
+to avoid overlapping.}
+
 \item{p.kr}{logical, if \code{TRUE}, p-value estimation is based on conditional 
 F-tests with Kenward-Roger approximation for the df. Caution: Computation
 may take very long time for large samples!}"
strengejacke,sjPlot,670a51cddb843477b34edf066b494de4fb6b2905,Daniel Ldecke,d.luedecke@uke.de,2016-06-14T15:25:30Z,Daniel Ldecke,d.luedecke@uke.de,2016-06-14T15:25:30Z,fix sjmisc-compatibility,R/sjTabOdds.R,False,True,True,False,133,133,266,"---FILE: R/sjTabOdds.R---
@@ -1,41 +1,41 @@
 #' @title Summary of generalized linear models as HTML table
 #' @name sjt.glm
-#' 
+#'
 #' @description Summarizes (multiple) fitted generalized linear models (odds ratios, ci, p-values...)
 #'                as HTML table, or saves them as file. The fitted models may have different predictors,
 #'                e.g. when comparing different stepwise fitted models.
-#' 
+#'
 #' @param ... one or more fitted generalized linear (mixed) models.
-#' @param exp.coef logical, if \code{TRUE} (default), regression coefficients and 
-#'          confidence intervals are exponentiated. Use \code{FALSE} for 
-#'          non-exponentiated coefficients (log-odds) as provided by 
+#' @param exp.coef logical, if \code{TRUE} (default), regression coefficients and
+#'          confidence intervals are exponentiated. Use \code{FALSE} for
+#'          non-exponentiated coefficients (log-odds) as provided by
 #'          the \code{\link{summary}} function.
 #' @param show.r2 logical, if \code{TRUE} (default), the pseudo R2 values for each model are printed
-#'          in the model summary. R2cs is the Cox-Snell-pseudo R-squared value, R2n is Nagelkerke's 
+#'          in the model summary. R2cs is the Cox-Snell-pseudo R-squared value, R2n is Nagelkerke's
 #'          pseudo R-squared value and \code{D} is Tjur's Coefficient of Discrimination
 #'          (see \code{\link[sjstats]{cod}}).
 #' @param show.loglik logical, if \code{TRUE}, the Log-Likelihood for each model is printed
 #'          in the model summary. Default is \code{FALSE}.
-#' @param show.chi2 logical, if \code{TRUE}, the p-value of the chi-squared value for each 
+#' @param show.chi2 logical, if \code{TRUE}, the p-value of the chi-squared value for each
 #'          model's residual deviance against the null deviance is printed
 #'          in the model summary. Default is \code{FALSE}. A well-fitting model
 #'          with predictors should significantly differ from the null-model
 #'          (without predictors), thus, a p-value less than 0.05 indicates a
 #'          good model-fit.
 #' @param show.hoslem logical, if \code{TRUE}, a Hosmer-Lemeshow-Goodness-of-fit-test is
-#'          performed. A well-fitting model shows no significant difference between 
+#'          performed. A well-fitting model shows no significant difference between
 #'          the model and the observed data, i.e. the reported p-values should be
 #'          greater than 0.05.
 #' @param show.family logical, if \code{TRUE}, the family object and link function for each fitted model
 #'          are printed. Can be used in case you want to compare models with different link functions
 #'          and same predictors and response, to decide which model fits best. See \code{\link{family}}
 #'          for more details. It is recommended to inspect the model \code{\link{AIC}} (see \code{show.aic}) to get a
 #'          decision help for which model to choose.
-#'          
+#'
 #' @inheritParams sjt.frq
 #' @inheritParams sjt.lm
 #' @inheritParams sjp.corr
-#' 
+#'
 #' @return Invisibly returns
 #'          \itemize{
 #'            \item the web page style sheet (\code{page.style}),
@@ -46,15 +46,15 @@
 #'            for further use.
 #'
 #' @note See 'Notes' in \code{\link{sjt.frq}}.
-#'  
+#'
 #' @details See 'Details' in \code{\link{sjt.frq}}.
-#'          
+#'
 #' @examples
 #' # prepare dummy variables for binary logistic regression
 #' swiss$y1 <- ifelse(swiss$Fertility < median(swiss$Fertility), 0, 1)
 #' swiss$y2 <- ifelse(swiss$Infant.Mortality < median(swiss$Infant.Mortality), 0, 1)
 #' swiss$y3 <- ifelse(swiss$Agriculture < median(swiss$Agriculture), 0, 1)
-#' 
+#'
 #' # Now fit the models. Note that both models share the same predictors
 #' # and only differ in their dependent variable (y1, y2 and y3)
 #' fitOR1 <- glm(y1 ~ Education + Examination + Catholic, data = swiss,
@@ -66,100 +66,100 @@
 #'
 #' \dontrun{
 #' # open HTML-table in RStudio Viewer Pane or web browser
-#' sjt.glm(fitOR1, fitOR2, 
+#' sjt.glm(fitOR1, fitOR2,
 #'         depvar.labels = c(""Fertility"", ""Infant Mortality""),
 #'         pred.labels = c(""Education"", ""Examination"", ""Catholic""),
 #'         ci.hyphen = "" to "")
-#' 
+#'
 #' # open HTML-table in RStudio Viewer Pane or web browser,
 #' # integrate CI in OR column
 #' sjt.glm(fitOR1, fitOR2, fitOR3,
 #'         pred.labels = c(""Education"", ""Examination"", ""Catholic""),
 #'         separate.ci.col = FALSE)
-#' 
+#'
 #' # open HTML-table in RStudio Viewer Pane or web browser,
 #' # indicating p-values as numbers and printing CI in a separate column
 #' sjt.glm(fitOR1, fitOR2, fitOR3,
 #'         depvar.labels = c(""Fertility"", ""Infant Mortality"", ""Agriculture""),
 #'         pred.labels = c(""Education"", ""Examination"", ""Catholic""))
-#' 
-#' # -------------------------------------------- 
+#'
+#' # --------------------------------------------
 #' # User defined style sheet
-#' # -------------------------------------------- 
+#' # --------------------------------------------
 #' sjt.glm(fitOR1, fitOR2, fitOR3,
 #'         depvar.labels = c(""Fertility"", ""Infant Mortality"", ""Agriculture""),
 #'         pred.labels = c(""Education"", ""Examination"", ""Catholic""),
 #'         show.header = TRUE,
 #'         CSS = list(css.table = ""border: 2px solid;"",
 #'                    css.tdata = ""border: 1px solid;"",
 #'                    css.depvarhead = ""color:#003399;""))
-#' 
-#' # -------------------------------------------- 
-#' # Compare models with different link functions, 
+#'
+#' # --------------------------------------------
+#' # Compare models with different link functions,
 #' # but same predictors and response
-#' # -------------------------------------------- 
+#' # --------------------------------------------
 #' library(sjmisc)
 #' # load efc sample data
 #' data(efc)
 #' # dichtomozize service usage by ""service usage yes/no""
-#' efc$services <- sjmisc::dicho(efc$tot_sc_e, ""v"", 0, as.num = TRUE)
+#' efc$services <- sjmisc::dicho(efc$tot_sc_e, 0, as.num = TRUE)
 #' # fit 3 models with different link-functions
-#' fit1 <- glm(services ~ neg_c_7 + c161sex + e42dep, 
+#' fit1 <- glm(services ~ neg_c_7 + c161sex + e42dep,
 #'             data = efc, family = binomial(link = ""logit""))
-#' fit2 <- glm(services ~ neg_c_7 + c161sex + e42dep, 
+#' fit2 <- glm(services ~ neg_c_7 + c161sex + e42dep,
 #'             data = efc, family = binomial(link = ""probit""))
-#' fit3 <- glm(services ~ neg_c_7 + c161sex + e42dep, 
+#' fit3 <- glm(services ~ neg_c_7 + c161sex + e42dep,
 #'             data = efc, family = poisson(link = ""log""))
-#'             
+#'
 #' # compare models
 #' sjt.glm(fit1, fit2, fit3, show.aic = TRUE, show.family = TRUE)
-#' 
+#'
 #' # --------------------------------------------
 #' # Change style of p-values and CI-appearance
 #' # --------------------------------------------
 #' # open HTML-table in RStudio Viewer Pane or web browser,
 #' # table indicating p-values as stars
 #' sjt.glm(fit1, fit2, fit3, p.numeric = FALSE,
 #'         show.aic = TRUE, show.family = TRUE)
-#' 
+#'
 #' # open HTML-table in RStudio Viewer Pane or web browser,
 #' # indicating p-values as stars and integrate CI in OR column
 #' sjt.glm(fit1, fit2, fit3, p.numeric = FALSE, separate.ci.col = FALSE,
 #'         show.aic = TRUE, show.family = TRUE, show.r2 = TRUE)
-#' 
-#' # ---------------------------------- 
+#'
+#' # ----------------------------------
 #' # automatic grouping of predictors
-#' # ---------------------------------- 
+#' # ----------------------------------
 #' library(sjmisc)
 #' # load efc sample data
 #' data(efc)
 #' # dichtomozize service usage by ""service usage yes/no""
-#' efc$services <- sjmisc::dicho(efc$tot_sc_e, ""v"", 0, as.num = TRUE)
+#' efc$services <- sjmisc::dicho(efc$tot_sc_e, 0, as.num = TRUE)
 #' # make dependency categorical
 #' efc$e42dep <- to_factor(efc$e42dep)
 #' # fit model with ""grouped"" predictor
 #' fit <- glm(services ~ neg_c_7 + c161sex + e42dep, data = efc)
-#' 
+#'
 #' # automatic grouping of categorical predictors
 #' sjt.glm(fit)
-#' 
-#' # ---------------------------------- 
+#'
+#' # ----------------------------------
 #' # compare models with different predictors
-#' # ---------------------------------- 
+#' # ----------------------------------
 #' fit2 <- glm(services ~ neg_c_7 + c161sex + e42dep + c12hour, data = efc)
-#' fit3 <- glm(services ~ neg_c_7 + c161sex + e42dep + c12hour + c172code, 
+#' fit3 <- glm(services ~ neg_c_7 + c161sex + e42dep + c12hour + c172code,
 #'             data = efc)
-#' 
+#'
 #' # print models with different predictors
 #' sjt.glm(fit, fit2, fit3)
-#' 
+#'
 #' efc$c172code <- to_factor(efc$c172code)
 #' fit2 <- glm(services ~ neg_c_7 + c161sex + c12hour, data = efc)
 #' fit3 <- glm(services ~ neg_c_7 + c161sex + c172code, data = efc)
-#' 
+#'
 #' # print models with different predictors
 #' sjt.glm(fit, fit2, fit3, group.pred = FALSE)}
-#' 
+#'
 #' @importFrom dplyr full_join slice
 #' @importFrom stats nobs AIC confint coef logLik family deviance
 #' @export
@@ -210,7 +210,7 @@ sjt.glm <- function(...,
                     use.viewer = TRUE,
                     no.output = FALSE,
                     remove.spaces = TRUE) {
-  
+
   # --------------------------------------------------------
   # check p-value-style option
   # --------------------------------------------------------
@@ -237,7 +237,7 @@ sjt.glm <- function(...,
   # ------------------------
   input_list <- list(...)
   # --------------------------------------------------------
-  # check length. if we have a list of fitted model, 
+  # check length. if we have a list of fitted model,
   # we need to ""unlist"" them
   # --------------------------------------------------------
   if (class(input_list[[1]])[1] == ""list"") input_list <- lapply(input_list[[1]], function(x) x)
@@ -359,7 +359,7 @@ sjt.glm <- function(...,
             x <- sprintf(""%s%.*f%s"", sb1, digits.p, x, sb2)
           }
         } else {
-          x <- sprintf(""%.*f"", digits.p, x) 
+          x <- sprintf(""%.*f"", digits.p, x)
         }
         # remove leading zero, APA style for p-value
         x <- sub(""0"", p_zero, x, fixed = TRUE)
@@ -504,7 +504,7 @@ sjt.glm <- function(...,
   }
   # --------------------------------------------------------
   # auto-retrieving variable labels does not work when we
-  # have factors with different levels, which appear as 
+  # have factors with different levels, which appear as
   # ""multiple predictors"", but are only one variable
   # --------------------------------------------------------
   if (is.null(pred.labels) || length(pred.labels) < (nrow(joined.df) - 1)) {
@@ -579,30 +579,30 @@ sjt.glm <- function(...,
     # confidence interval in separate column
     if (separate.ci.col) {
       # open table cell for Beta-coefficient
-      page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign %smodelcolumn1\"">%s"", 
-                                                   tcb_class, 
+      page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign %smodelcolumn1\"">%s"",
+                                                   tcb_class,
                                                    joined.df[1, (i - 1) * 5 + 2]))
       # if p-values are not shown as numbers, insert them after beta-value
       if (!p.numeric) page.content <- paste0(page.content, sprintf(""&nbsp;%s"", joined.df[1, (i - 1) * 5 + 5]))
       # if we have CI, start new table cell (CI in separate column)
       if (show.ci) {
-        page.content <- paste0(page.content, sprintf(""</td><td class=\""tdata centeralign %smodelcolumn2\"">%s%s%s</td>"", 
-                                                     tcb_class, 
-                                                     joined.df[1, (i - 1) * 5 + 3], 
+        page.content <- paste0(page.content, sprintf(""</td><td class=\""tdata centeralign %smodelcolumn2\"">%s%s%s</td>"",
+                                                     tcb_class,
+                                                     joined.df[1, (i - 1) * 5 + 3],
                                                      ci.hyphen,
                                                      joined.df[1, (i - 1) * 5 + 4]))
       } else {
         page.content <- paste0(page.content, ""</td>"")
       }
     } else {
       # open table cell for Beta-coefficient
-      page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign %smodelcolumn1\"">%s"", 
-                                                   tcb_class, 
+      page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign %smodelcolumn1\"">%s"",
+                                                   tcb_class,
                                                    joined.df[1, (i - 1) * 5 + 2]))
       # confidence interval in Beta-column
-      if (show.ci) page.content <- paste0(page.content, sprintf(""%s(%s%s%s)"", 
-                                                                    linebreakstring, 
-                                                                    joined.df[1, (i - 1) * 5 + 3], 
+      if (show.ci) page.content <- paste0(page.content, sprintf(""%s(%s%s%s)"",
+                                                                    linebreakstring,
+                                                                    joined.df[1, (i - 1) * 5 + 3],
                                                                     ci.hyphen,
                                                                     joined.df[1, (i - 1) * 5 + 4]))
       # if p-values are not shown as numbers, insert them after beta-value
@@ -614,11 +614,11 @@ sjt.glm <- function(...,
                                                                    tcb_class,
                                                                    joined.df[1, (i - 1) * 5 + 6]))
     # show p-values as numbers in separate column
-    if (p.numeric) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign %smodelcolumn4\"">%s</td>"", 
+    if (p.numeric) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign %smodelcolumn4\"">%s</td>"",
                                                                        tcb_class,
                                                                        joined.df[1, (i - 1) * 5 + 5]))
   }
-  page.content <- paste0(page.content, ""\n  </tr>"")  
+  page.content <- paste0(page.content, ""\n  </tr>"")
   # -------------------------------------
   # subsequent rows: pedictors
   # -------------------------------------
@@ -627,9 +627,9 @@ sjt.glm <- function(...,
     # do we need to insert a ""factor grouping headline row""?
     # -------------------------------------
     if (!is.null(group.pred.rows) && any(group.pred.rows == i)) {
-      page.content <- paste0(page.content, 
-                             ""\n  <tr>\n"", 
-                             sprintf(""\n    <td class=\""grouprow\"" colspan=\""%i\"">%s</td>"", 
+      page.content <- paste0(page.content,
+                             ""\n  <tr>\n"",
+                             sprintf(""\n    <td class=\""grouprow\"" colspan=\""%i\"">%s</td>"",
                                      headerColSpan + 1,
                                      group.pred.labs[which(group.pred.rows == i)]),
                              ""\n  </tr>"")
@@ -662,41 +662,41 @@ sjt.glm <- function(...,
       # confidence interval in separate column
       if (separate.ci.col) {
         # open table cell for Beta-coefficient
-        page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign modelcolumn1\"">%s"", 
+        page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign modelcolumn1\"">%s"",
                                                      joined.df[i + 1, (j - 1) * 5 + 2]))
         # if p-values are not shown as numbers, insert them after beta-value
-        if (!p.numeric) page.content <- paste0(page.content, sprintf(""&nbsp;%s"", 
+        if (!p.numeric) page.content <- paste0(page.content, sprintf(""&nbsp;%s"",
                                                                             joined.df[i + 1, (j - 1) * 5 + 5]))
         # if we have CI, start new table cell (CI in separate column)
         if (show.ci) {
-          page.content <- paste0(page.content, sprintf(""</td><td class=\""tdata centeralign modelcolumn2\"">%s%s%s</td>"", 
-                                                       ci.lo, 
-                                                       ci.sep.string, 
+          page.content <- paste0(page.content, sprintf(""</td><td class=\""tdata centeralign modelcolumn2\"">%s%s%s</td>"",
+                                                       ci.lo,
+                                                       ci.sep.string,
                                                        ci.hi))
         } else {
           page.content <- paste0(page.content, ""</td>"")
         }
       } else {
         # open table cell for Beta-coefficient
-        page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign modelcolumn1\"">%s"", 
+        page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign modelcolumn1\"">%s"",
                                                      joined.df[i + 1, (j - 1) * 5 + 2]))
         # confidence interval in Beta-column
-        if (show.ci && !sjmisc::is_empty(ci.lo)) page.content <- paste0(page.content, 
-                                                                            sprintf(""%s(%s%s%s)"", 
-                                                                                    linebreakstring, 
-                                                                                    ci.lo, 
-                                                                                    ci.sep.string, 
+        if (show.ci && !sjmisc::is_empty(ci.lo)) page.content <- paste0(page.content,
+                                                                            sprintf(""%s(%s%s%s)"",
+                                                                                    linebreakstring,
+                                                                                    ci.lo,
+                                                                                    ci.sep.string,
                                                                                     ci.hi))
         # if p-values are not shown as numbers, insert them after beta-value
-        if (!p.numeric) page.content <- paste0(page.content, sprintf(""&nbsp;%s"", 
+        if (!p.numeric) page.content <- paste0(page.content, sprintf(""&nbsp;%s"",
                                                                             joined.df[i + 1, (j - 1) * 5 + 5]))
         page.content <- paste0(page.content, ""</td>"")
       }
       # show std. error
-      if (show.se) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign modelcolumn3\"">%s</td>"", 
+      if (show.se) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign modelcolumn3\"">%s</td>"",
                                                                      joined.df[i + 1, (j - 1) * 5 + 6]))
       # show p-values as numbers in separate column
-      if (p.numeric) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign modelcolumn4\"">%s</td>"", 
+      if (p.numeric) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign modelcolumn4\"">%s</td>"",
                                                                          joined.df[i + 1, (j - 1) * 5 + 5]))
     }
     page.content <- paste0(page.content, ""\n  </tr>"")
@@ -740,11 +740,11 @@ sjt.glm <- function(...,
       # -------------------------
       # between-group variance
       # -------------------------
-      # first models indicates grouping levels. we have to assume comparable models 
+      # first models indicates grouping levels. we have to assume comparable models
       # with same random intercepts.
       for (gl in 1:mmcount) {
-        page.content <- paste0(page.content, 
-                               sprintf(""\n  <tr>\n    <td class=\""tdata summary leftalign\"">&tau;<sub>00, %s</sub></td>\n"", 
+        page.content <- paste0(page.content,
+                               sprintf(""\n  <tr>\n    <td class=\""tdata summary leftalign\"">&tau;<sub>00, %s</sub></td>\n"",
                                        names(mmgrps[gl])))
         # iterate models
         for (i in 1:length(input_list)) {
@@ -759,10 +759,10 @@ sjt.glm <- function(...,
           if (length(tau.00) >= gl) {
             rand.int.var <- paste0(sprintf(""%.*f"", digits.summary, tau.00[gl], collapse = """"))
             page.content <- paste0(page.content, colspanstring, rand.int.var, ""</td>\n"")
-            
+
           } else {
             page.content <- paste(page.content, sprintf(""   %s&nbsp;</td>\n"", colspanstring))
-          }            
+          }
         }
         page.content <- paste0(page.content, ""  </tr>\n"")
       }
@@ -795,7 +795,7 @@ sjt.glm <- function(...,
     # -------------------------------------
     # N of grouping levels
     # -------------------------------------
-    # first models indicates grouping levels. we have to assume comparable models 
+    # first models indicates grouping levels. we have to assume comparable models
     # with same random intercepts.
     for (gl in 1:mmcount) {
       page.content <- paste0(page.content, sprintf(""\n  <tr>\n    <td class=\""tdata summary leftalign\"">N<sub>%s</sub></td>"", names(mmgrps[gl])))
@@ -868,7 +868,7 @@ sjt.glm <- function(...,
       r2string <- ""Tjur's D""
     else
       r2string <- ""Pseudo-R<sup>2</sup>""
-    
+
     page.content <- paste0(page.content, sprintf(""  <tr>\n    <td class=\""tdata leftalign summary\"">%s</td>"", r2string))
     for (i in 1:length(input_list)) {
       # -------------------------
@@ -878,23 +878,23 @@ sjt.glm <- function(...,
       psr <- sjstats::r2(input_list[[i]])
       tjur <- sjstats::cod(input_list[[i]])
       if (lmerob) {
-        page.content <- paste0(page.content, gsub(""0."", 
+        page.content <- paste0(page.content, gsub(""0."",
                                                   paste0(p_zero, "".""),
-                                                  sprintf(""%s%.*f"", 
-                                                          colspanstring, 
-                                                          digits.summary, 
+                                                  sprintf(""%s%.*f"",
+                                                          colspanstring,
+                                                          digits.summary,
                                                           tjur),
                                                   fixed = TRUE))
       } else {
-        page.content <- paste0(page.content, gsub(""0."", 
+        page.content <- paste0(page.content, gsub(""0."",
                                                   paste0(p_zero, "".""),
-                                                  sprintf(""%sR<sup>2</sup><sub>CS</sub> = %.*f<br>R<sup>2</sup><sub>N</sub> = %.*f<br>D = %.*f</td>"", 
-                                                          colspanstring, 
-                                                          digits.summary, 
+                                                  sprintf(""%sR<sup>2</sup><sub>CS</sub> = %.*f<br>R<sup>2</sup><sub>N</sub> = %.*f<br>D = %.*f</td>"",
+                                                          colspanstring,
+                                                          digits.summary,
                                                           psr$CoxSnell,
-                                                          digits.summary, 
+                                                          digits.summary,
                                                           psr$Nagelkerke,
-                                                          digits.summary, 
+                                                          digits.summary,
                                                           tjur),
                                                   fixed = TRUE))
       }
@@ -979,9 +979,9 @@ sjt.glm <- function(...,
       if (sep.column) page.content <- paste0(page.content, ""<td class=\""separatorcol\"">&nbsp;</td>"")
       page.content <- paste0(page.content, gsub(""0."",
                                                 paste0(p_zero, "".""),
-                                                sprintf(""%sp=%.*f</td>"", 
-                                                        colspanstring, 
-                                                        digits.summary, 
+                                                sprintf(""%sp=%.*f</td>"",
+                                                        colspanstring,
+                                                        digits.summary,
                                                         Chisquare.glm(input_list[[i]])),
                                                 fixed = TRUE))
     }
@@ -1010,14 +1010,14 @@ sjt.glm <- function(...,
   #         # -------------------------
   #         # print chisq and p
   #         # -------------------------
-  #         page.content <- paste0(page.content, 
+  #         page.content <- paste0(page.content,
   #                                gsub(""0."",
   #                                     paste0(p_zero, "".""),
-  #                                     sprintf(""%s%.*f; p=%.*f</td>"", 
-  #                                             colspanstring, 
-  #                                             digits.summary, 
+  #                                     sprintf(""%s%.*f; p=%.*f</td>"",
+  #                                             colspanstring,
+  #                                             digits.summary,
   #                                             pgof$X2,
-  #                                             digits.summary, 
+  #                                             digits.summary,
   #                                             pgof$p.value),
   #                                     fixed = T))
   #       }
@@ -1041,14 +1041,14 @@ sjt.glm <- function(...,
       # -------------------------
       # print chisq and p
       # -------------------------
-      page.content <- paste0(page.content, 
+      page.content <- paste0(page.content,
                              gsub(""0."",
                                   paste0(p_zero, "".""),
-                                  sprintf(""%s%.*f; p=%.*f</td>"", 
-                                          colspanstring, 
-                                          digits.summary, 
+                                  sprintf(""%s%.*f; p=%.*f</td>"",
+                                          colspanstring,
+                                          digits.summary,
                                           unname(hlgof$chisq),
-                                          digits.summary, 
+                                          digits.summary,
                                           hlgof$p.value),
                                   fixed = T))
     }
@@ -1065,9 +1065,9 @@ sjt.glm <- function(...,
       # -------------------------
       if (sep.column) page.content <- paste0(page.content, ""<td class=\""separatorcol\"">&nbsp;</td>"")
       fam <- stats::family(input_list[[i]])
-      page.content <- paste0(page.content, sprintf(""%s%s (%s)</td>"", 
-                                                   colspanstring, 
-                                                   fam$family, 
+      page.content <- paste0(page.content, sprintf(""%s%s (%s)</td>"",
+                                                   colspanstring,
+                                                   fam$family,
                                                    fam$link))
     }
     page.content <- paste0(page.content, ""\n  </tr>\n"")
@@ -1086,7 +1086,7 @@ sjt.glm <- function(...,
   # replace class attributes with inline style,
   # useful for knitr
   # -------------------------------------
-  knitr <- replace_css_styles(page.content, cell.spacing, cell.gpr.indent, 
+  knitr <- replace_css_styles(page.content, cell.spacing, cell.gpr.indent,
                               p.numeric, show.header, CSS)
   # -------------------------------------
   # remove spaces?
@@ -1119,15 +1119,15 @@ sjt.glm <- function(...,
 
 #' @title Summary of generalized linear mixed models as HTML table
 #' @name sjt.glmer
-#' 
+#'
 #' @description Summarizes (multiple) fitted generalized linear mixed models (odds ratios, ci, p-values...)
 #'                as HTML table, or saves them as file. The fitted models may have different predictors,
 #'                e.g. when comparing different stepwise fitted models.
-#' 
+#'
 #' @inheritParams sjt.glm
 #' @inheritParams sjt.frq
 #' @inheritParams sjp.corr
-#' 
+#'
 #' @return Invisibly returns
 #'          \itemize{
 #'            \item the web page style sheet (\code{page.style}),
@@ -1137,7 +1137,7 @@ sjt.glm <- function(...,
 #'            }
 #'            for further use.
 #'
-#' @note Computation of p-values (if necessary) is based on normal-distribution 
+#' @note Computation of p-values (if necessary) is based on normal-distribution
 #'         assumption, treating the t-statistics as Wald z-statistics.
 #'         \cr \cr
 #'         The variance components of the random parts (see \code{show.re.var}) are
@@ -1146,15 +1146,15 @@ sjt.glm <- function(...,
 #'          \item between-group-variance: tau-zero-zero
 #'          \item random-slope-intercept-correlation: rho-zero-one
 #'          }
-#'  
+#'
 #' @details See 'Details' in \code{\link{sjt.frq}}.
 #'
 #' @examples
 #' \dontrun{
 #' library(lme4)
 #' library(sjmisc)
 #' data(efc)
-#' 
+#'
 #' # create binary response
 #' efc$hi_qol <- dicho(efc$quol_5)
 #' # prepare group variable
@@ -1167,29 +1167,29 @@ sjt.glm <- function(...,
 #'                    neg_c_7 = efc$neg_c_7,
 #'                    education = to_factor(efc$c172code),
 #'                    grp = efc$grp)
-#'                    
+#'
 #' # fit glmer
 #' fit1 <- glmer(hi_qol ~ sex + c12hour + neg_c_7 + (1|grp),
 #'               data = mydf, family = binomial(""logit""))
 #' fit2 <- glmer(hi_qol ~ sex + c12hour + neg_c_7 + education + (1|grp),
 #'               data = mydf, family = binomial(""logit""))
-#'               
+#'
 #' # print summary table
 #' sjt.glmer(fit1, fit2, ci.hyphen = "" to "")
-#' 
+#'
 #' # print summary table, using different table layout
 #' sjt.glmer(fit1, fit2, show.aic = TRUE, show.ci = FALSE,
 #'           show.se = TRUE, p.numeric = FALSE)
-#'           
+#'
 #' # print summary table
 #' sjt.glmer(fit1, fit2, pred.labels = c(""Elder's gender (female)"",
 #'             ""Hours of care per week"", ""Negative Impact"",
 #'             ""Educational level (mid)"", ""Educational level (high)""))
-#' 
+#'
 #' # use vector names as predictor labels
 #' sjt.glmer(fit1, fit2, pred.labels = """")}
-#' 
-#' 
+#'
+#'
 #' @export
 sjt.glmer <- function(...,
                       pred.labels = NULL,
@@ -1237,22 +1237,22 @@ sjt.glmer <- function(...,
                       use.viewer = TRUE,
                       no.output = FALSE,
                       remove.spaces = TRUE) {
-  
+
   input_list <- list(...)
-  return(sjt.glm(input_list, file = file, pred.labels = pred.labels, 
-                 depvar.labels = depvar.labels, string.pred = string.pred, 
-                 string.dv = string.dv, show.header = show.header, 
+  return(sjt.glm(input_list, file = file, pred.labels = pred.labels,
+                 depvar.labels = depvar.labels, string.pred = string.pred,
+                 string.dv = string.dv, show.header = show.header,
                  string.interc = string.interc,
                  string.obs = string.obs, string.est = string.est,
-                 string.ci = string.ci, string.se = string.se, string.p = string.p, 
+                 string.ci = string.ci, string.se = string.se, string.p = string.p,
                  digits.est = digits.est, digits.p = digits.p, digits.ci = digits.ci,
                  digits.se = digits.se, digits.summary = digits.summary, exp.coef = exp.coef,
-                 p.numeric = p.numeric, emph.p = emph.p, 
-                 show.ci = show.ci, show.se = show.se, 
-                 ci.hyphen = ci.hyphen, separate.ci.col = separate.ci.col, newline.ci = newline.ci, 
-                 group.pred = group.pred, show.col.header = show.col.header, show.r2 = show.r2, show.icc = show.icc, 
+                 p.numeric = p.numeric, emph.p = emph.p,
+                 show.ci = show.ci, show.se = show.se,
+                 ci.hyphen = ci.hyphen, separate.ci.col = separate.ci.col, newline.ci = newline.ci,
+                 group.pred = group.pred, show.col.header = show.col.header, show.r2 = show.r2, show.icc = show.icc,
                  show.re.var = show.re.var, show.loglik = show.loglik, show.aic = show.aic, show.aicc = show.aicc, show.dev = show.dev,
-                 show.chi2 = FALSE, show.hoslem = show.hoslem, show.family = show.family, remove.estimates = remove.estimates, 
+                 show.chi2 = FALSE, show.hoslem = show.hoslem, show.family = show.family, remove.estimates = remove.estimates,
                  cell.spacing = cell.spacing, cell.gpr.indent = cell.gpr.indent, sep.column = sep.column,
                  encoding = encoding, CSS = CSS, use.viewer = use.viewer, no.output = no.output, remove.spaces = remove.spaces))
 }
\ No newline at end of file"
strengejacke,sjPlot,ed4cf5156e1085f19436e9f5b57fcdd56bedd6aa,Daniel Ldecke,d.luedecke@uke.de,2016-05-17T14:28:28Z,Daniel Ldecke,d.luedecke@uke.de,2016-05-17T14:28:28Z,minor fixes,R/helpfunctions.R;R/sjPlotFrequencies.R;R/sjTabFrequencies.R;R/sjTabLinReg.R;R/sjTabOdds.R;man/sjt.lm.Rd,False,True,True,False,31,20,51,"---FILE: R/helpfunctions.R---
@@ -248,7 +248,7 @@ create.frq.df <- function(x,
   # ""rename"" NA values
   # -------------------------------------
   if (!is.null(mydat$label)) mydat$label[is.na(mydat$label)] <- ""NA""
-  suppressMessages(sjmisc::replace_na(mydat$val) <- nrow(mydat))
+  suppressMessages(sjmisc::replace_na(mydat$val) <- max(sjmisc::to_value(mydat$val), na.rm = T) + 1)
   # save original order
   mydat$order <- sjmisc::to_value(mydat$val, keep.labels = F)
   # sort for x-axis

---FILE: R/sjPlotFrequencies.R---
@@ -335,18 +335,22 @@ sjp.frq <- function(var.cnt,
       # what is the maximum values after binning for histograms?
       hist.grp.cnt <- ceiling(diff(range(var.cnt, na.rm = T)) / geom.size)
       # ... or the amount of max. answers per category
-      # add 5% margin to upper limit
+      # add 10% margin to upper limit
       upper_lim <- max(pretty(table(sjmisc::group_var(var.cnt, 
                                                       groupsize = ""auto"", 
-                                                      groupcount = hist.grp.cnt)) * 1.05))
+                                                      groupcount = hist.grp.cnt)) * 1.1))
     } else {
       if (show.ci)
-        upper_lim <- max(pretty(mydat$upper.ci * 1.05))
+        upper_lim <- max(pretty(mydat$upper.ci * 1.1))
       else
-        upper_lim <- max(pretty(table(var.cnt) * 1.05))
+        upper_lim <- max(pretty(table(var.cnt) * 1.1))
     }
   }
   # --------------------------------------------------------
+  # If we want to include NA, use raw percentages as valid percentages
+  # --------------------------------------------------------
+  if (show.na) mydat$valid.prc <- mydat$raw.prc
+  # --------------------------------------------------------
   # Set value labels
   # --------------------------------------------------------
   # don't display value labels when we have boxplots or violin plots

---FILE: R/sjTabFrequencies.R---
@@ -439,16 +439,16 @@ sjt.frq <- function(data,
     # check if we have a string-vector
     if (is.character(data[[cnt]])) {
       # convert string to numeric
-      orivar <- var <- as.numeric(as.factor(data[[cnt]]))
+      orivar <- varia <- as.numeric(as.factor(data[[cnt]]))
       # here we have numeric or factor variables
     } else {
       # convert to numeric
-      orivar <- var <- sjmisc::to_value(data[[cnt]], keep.labels = F)
+      orivar <- varia <- sjmisc::to_value(data[[cnt]], keep.labels = F)
     }
     # retrieve summary
-    varsummary <- summary(var)
+    varsummary <- summary(varia)
     # retrieve median
-    var.median <- varsummary[[3]]
+    var.median <- stats::median(varia, na.rm = TRUE)
     # retrieve quartiles
     var.lowerq <- round(varsummary[[2]])
     var.upperq <- round(varsummary[[5]])
@@ -467,9 +467,9 @@ sjt.frq <- function(data,
     #---------------------------------------------------
     if (!is.logical(o.skip.zero)) {
       # retrieve range of values
-      vonbis <- max(var, na.rm = T) - min(var, na.rm = T)
+      vonbis <- max(varia, na.rm = T) - min(varia, na.rm = T)
       # retrieve count of unique values
-      anzval <- stats::na.omit(unique(var))
+      anzval <- stats::na.omit(unique(varia))
       # check proportion of possible values and actual values
       # if we have more than 25% of zero-values, or if we have
       # in general a large variable range, skip zero-rows.
@@ -570,7 +570,7 @@ sjt.frq <- function(data,
     # -------------------------------------
     if (show.summary) {
       # sum of frequencies is total N. Use these numbers
-      # instead of ""length(var)"", because weighted data
+      # instead of ""length(varia)"", because weighted data
       # has different N
       vartot <- sum(df$frq, na.rm = T)
       # last element in df$frq is amount of missings,

---FILE: R/sjTabLinReg.R---
@@ -153,7 +153,7 @@ utils::globalVariables(c(""starts_with""))
 #' sjt.lm(fit1, fit2, 
 #'        depvar.labels = c(""Barthel-Index"", ""Negative Impact""),
 #'        pred.labels = c(""Carer's Age"", ""Hours of Care"", 
-#'                            ""Carer's Sex"", ""Educational Status""))
+#'                        ""Carer's Sex"", ""Educational Status""))
 #' 
 #' # use vector names as labels
 #' sjt.lm(fit1, fit2, pred.labels = """")
@@ -702,13 +702,17 @@ sjt.lm <- function(...,
   # -------------------------------------
   if (is.null(pred.labels)) {
     pred.labels <- suppressWarnings(retrieveModelLabels(input_list, group.pred = group.pred))
+    # remove labels from removed estimates. we need ""-1"" here, because removed
+    # estimates start counting with the intercept, while predictor label counting
+    # starts with first estimate after intercept
+    if (!is.null(keep.estimates)) pred.labels <- pred.labels[keep.estimates - 1]
   }
   # --------------------------------------------------------
   # auto-retrieving variable labels does not work when we
   # have factors with different levels, which appear as 
   # ""multiple predictors"", but are only one variable
   # --------------------------------------------------------
-  if (is.null(pred.labels) || length(pred.labels) < length(joined.df[-1, 1])) {
+  if (is.null(pred.labels) || length(pred.labels) < (nrow(joined.df) - 1)) {
     pred.labels <- joined.df[-1, 1]
   }
   # -------------------------------------
@@ -759,11 +763,10 @@ sjt.lm <- function(...,
       if (separate.ci.col) {
         # open table cell for Beta-coefficient
         page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign %smodelcolumn1\"">%s"", 
-                                                     tcb_class, 
-                                                     joined.df[1, (i - 1) * 8 + 2]))
+                                                     tcb_class, joined.df[1, (i - 1) * 8 + 2]))
         # if p-values are not shown as numbers, insert them after beta-value
-        if (!p.numeric) page.content <- paste0(page.content, sprintf(""&nbsp;%s"", 
-                                                                            joined.df[1, (i - 1) * 8 + 5]))
+        if (!p.numeric) page.content <- paste0(page.content, 
+                                               sprintf(""&nbsp;%s"", joined.df[1, (i - 1) * 8 + 5]))
         # if we have CI, start new table cell (CI in separate column)
         if (show.ci) {
           page.content <- paste0(page.content, sprintf(""</td><td class=\""tdata centeralign %smodelcolumn2\"">%s%s%s</td>"", 

---FILE: R/sjTabOdds.R---
@@ -504,13 +504,17 @@ sjt.glm <- function(...,
   # -------------------------------------
   if (is.null(pred.labels)) {
     pred.labels <- suppressWarnings(retrieveModelLabels(input_list, group.pred = group.pred))
+    # remove labels from removed estimates. we need ""-1"" here, because removed
+    # estimates start counting with the intercept, while predictor label counting
+    # starts with first estimate after intercept
+    if (!is.null(keep.estimates)) pred.labels <- pred.labels[keep.estimates - 1]
   }
   # --------------------------------------------------------
   # auto-retrieving variable labels does not work when we
   # have factors with different levels, which appear as 
   # ""multiple predictors"", but are only one variable
   # --------------------------------------------------------
-  if (is.null(pred.labels) || length(pred.labels) < length(joined.df[-1, 1])) {
+  if (is.null(pred.labels) || length(pred.labels) < (nrow(joined.df) - 1)) {
     pred.labels <- joined.df[-1, 1]
   }
   # -------------------------------------

---FILE: man/sjt.lm.Rd---
@@ -238,7 +238,7 @@ sjt.lm(fit1, fit2)
 sjt.lm(fit1, fit2, 
        depvar.labels = c(""Barthel-Index"", ""Negative Impact""),
        pred.labels = c(""Carer's Age"", ""Hours of Care"", 
-                           ""Carer's Sex"", ""Educational Status""))
+                       ""Carer's Sex"", ""Educational Status""))
 
 # use vector names as labels
 sjt.lm(fit1, fit2, pred.labels = """")"
strengejacke,sjPlot,b829f0f87526225e45e6072f30b3eb7d2fb030ca,Daniel Ldecke,d.luedecke@uke.de,2016-05-13T20:37:58Z,Daniel Ldecke,d.luedecke@uke.de,2016-05-13T20:37:58Z,minor fixes,R/sjPlotFrequencies.R;R/sjPlotPropTable.R,False,True,True,False,10,9,19,"---FILE: R/sjPlotFrequencies.R---
@@ -488,7 +488,7 @@ sjp.frq <- function(var.cnt,
       # transparent density curve above bars
       geom_density(aes(y = ..density..), fill = ""cornsilk"", alpha = 0.3) +
       # remove margins from left and right diagram side
-      scale_x_continuous(expand = expand.grid, breaks = histgridbreaks,limits = xlim)
+      scale_x_continuous(expand = expand.grid, breaks = histgridbreaks, limits = xlim)
     # check whether user wants to overlay the histogram
     # with a normal curve
     if (normal.curve) {
@@ -515,12 +515,11 @@ sjp.frq <- function(var.cnt,
       # original data needed for normal curve
       baseplot <- ggplot(mydat) +
         # second data frame mapped to the histogram geom
-        geom_histogram(data = hist.dat, aes(x = xv), binwidth = geom.size, fill = geom.colors)        
-      
+        geom_histogram(data = hist.dat, aes(x = xv), binwidth = geom.size, fill = geom.colors)
     } else {
       baseplot <- ggplot(mydat, aes(x = val, y = frq)) +
         geom_area(alpha = 0.3) +
-        geom_line(size = geom.size, colour = geom.colors) +
+        geom_line(size = geom.size, colour = geom.colors)
         ggvaluelabels
     }
     # check whether user wants to overlay the histogram
@@ -574,10 +573,9 @@ sjp.frq <- function(var.cnt,
       }
     }
     # show absolute and percentage value of each bar.
-    baseplot <- baseplot + 
-      # remove margins from left and right diagram side
-      scale_x_continuous(limits = xlim, expand = expand.grid, breaks = histgridbreaks) +
-      yscale
+    baseplot <- baseplot + yscale +
+      # continuous x-scale for histograms
+      scale_x_continuous(limits = xlim, expand = expand.grid, breaks = histgridbreaks)
   }
   # set axes text and 
   baseplot <- baseplot + labs(title = title, x = axis.title, y = NULL)

---FILE: R/sjPlotPropTable.R---
@@ -400,7 +400,10 @@ sjp.xtab <- function(x,
   # construct final plot, base constructor
   # first, set x scale
   # ----------------------------------
-  scalex <- scale_x_discrete(labels = axis.labels)
+  if (type == ""line"")
+    scalex <- scale_x_continuous(labels = axis.labels)
+  else
+    scalex <- scale_x_discrete(labels = axis.labels)
   # ----------------------------------
   # check whether bars or lines should be printed
   # ----------------------------------"
strengejacke,sjPlot,74f36cd74ad307884b9c96136761a47a19b8b173,Daniel Ldecke,d.luedecke@uke.de,2016-05-13T14:09:47Z,Daniel Ldecke,d.luedecke@uke.de,2016-05-13T14:09:47Z,fix CHECK issues,R/sjPlotClusterAnalysis.R;R/sjPlotGLME.R;R/sjPlotOddsMultiple.R,False,True,True,False,4,1,5,"---FILE: R/sjPlotClusterAnalysis.R---
@@ -520,6 +520,7 @@ sjc.dend <- function(data, groupcount, distance = ""euclidean"", agglomeration = ""
 #'          whether a certain group is below or above the average classification goodness.
 #'
 #' @inheritParams sjc.cluster
+#' @inheritParams sjp.grpfrq
 #'
 #' @return (Invisibly) returns an object with
 #'           \itemize{

---FILE: R/sjPlotGLME.R---
@@ -86,6 +86,7 @@ utils::globalVariables(c(""estimate"", ""nQQ"", ""ci"", ""fixef"", ""fade"", ""conf.low"", ""
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjp.lm
 #' @inheritParams sjp.glm
+#' @inheritParams sjp.gpt
 #'
 #' @return (Insisibily) returns, depending on the plot type
 #'          \itemize{
@@ -393,6 +394,7 @@ sjp.glmer <- function(fit,
 #' @inheritParams sjp.glmer
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjp.lm
+#' @inheritParams sjp.gpt
 #'
 #' @return (Insisibily) returns
 #'          \itemize{

---FILE: R/sjPlotOddsMultiple.R---
@@ -407,7 +407,7 @@ sjp.glmm <- function(...,
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------
-  if (prnt.plot) grpahics::plot(plotHeader)
+  if (prnt.plot) graphics::plot(plotHeader)
   # -------------------------------------
   # set proper column names
   # -------------------------------------"
strengejacke,sjPlot,6b0285a6247a209a540a1dec9c28c5baefe26a16,Daniel Ldecke,d.luedecke@uke.de,2016-05-13T10:50:48Z,Daniel Ldecke,d.luedecke@uke.de,2016-05-13T10:50:48Z,minor fix,R/sjPlotScatter.R,False,True,True,False,9,5,14,"---FILE: R/sjPlotScatter.R---
@@ -132,14 +132,18 @@ sjp.scatter <- function(x = NULL,
   if (!is.null(dot.labels) && !requireNamespace(""ggrepel"", quietly = TRUE)) {
     stop(""Package `ggrepel` needed to plot labels. Please install it."", call. = FALSE)
   }
-  
   # --------------------------------------------------------
   # get variable name
   # --------------------------------------------------------
   name.x <- get_var_name(deparse(substitute(x)))
   name.y <- get_var_name(deparse(substitute(y)))
   name.grp <- get_var_name(deparse(substitute(grp)))
   # --------------------------------------------------------
+  # any missing names?
+  # --------------------------------------------------------
+  if (is.null(name.x) || name.x == ""NULL"") name.x <- """"
+  if (is.null(name.y) || name.y == ""NULL"") name.y <- """"
+  # --------------------------------------------------------
   # copy titles
   # --------------------------------------------------------
   if (is.null(axis.titles)) {
@@ -169,10 +173,10 @@ sjp.scatter <- function(x = NULL,
   # --------------------------------------------------------
   # try to automatically set labels is not passed as parameter
   # --------------------------------------------------------
-  if (is.null(legend.labels) && !is.null(grp)) legend.labels <- sjmisc::get_labels(grp,
-                                                                                 attr.only = F,
-                                                                                 include.values = NULL,
-                                                                                 include.non.labelled = T)
+  if (is.null(legend.labels) && !is.null(grp)) {
+    legend.labels <- sjmisc::get_labels(grp, attr.only = F, include.values = NULL,
+                                        include.non.labelled = T)
+  }
   if (is.null(legend.title) && !is.null(grp)) legend.title <- sjmisc::get_label(grp, def.value = name.grp)
   if (is.null(axisTitle.x)) axisTitle.x <- sjmisc::get_label(x, def.value = name.x)
   if (is.null(axisTitle.y)) axisTitle.y <- sjmisc::get_label(y, def.value = name.y)"
strengejacke,sjPlot,bfbda1065ffd50ad01b8a0dea32a3d39ea33dfd9,Daniel Ldecke,d.luedecke@uke.de,2016-05-13T10:42:43Z,Daniel Ldecke,d.luedecke@uke.de,2016-05-13T10:42:43Z,minor fixes,R/sjPlotGroupPropTable.R;R/sjPlotLikert.R;R/sjPlotScatter.R;R/sjPlotSetTheme.R;R/sjPlotStackFrequencies.R;man/sjp.setTheme.Rd,False,True,True,False,24,13,37,"---FILE: R/sjPlotGroupPropTable.R---
@@ -93,7 +93,10 @@ sjp.gpt <- function(x,
     axisTitle.y <- NULL
   } else {
     axisTitle.x <- axis.titles[1]
-    if (length(axis.titles) > 1) axisTitle.y <- axis.titles[2]
+    if (length(axis.titles) > 1)
+      axisTitle.y <- axis.titles[2]
+    else
+      axisTitle.y <- NULL
   }
   # --------------------------------------------------------
   # try to automatically set labels if not passed as argument

---FILE: R/sjPlotLikert.R---
@@ -171,7 +171,10 @@ sjp.likert <- function(items,
     axisTitle.y <- NULL
   } else {
     axisTitle.x <- axis.titles[1]
-    if (length(axis.titles) > 1) axisTitle.y <- axis.titles[2]
+    if (length(axis.titles) > 1)
+      axisTitle.y <- axis.titles[2]
+    else
+      axisTitle.y <- NULL
   }
   # --------------------------------------------------------
   # check sorting

---FILE: R/sjPlotScatter.R---
@@ -147,7 +147,10 @@ sjp.scatter <- function(x = NULL,
     axisTitle.y <- NULL
   } else {
     axisTitle.x <- axis.titles[1]
-    if (length(axis.titles) > 1) axisTitle.y <- axis.titles[2]
+    if (length(axis.titles) > 1) 
+      axisTitle.y <- axis.titles[2]#
+    else
+      axisTitle.y <- NULL
   }
   # --------------------------------------------------------
   # check parameters

---FILE: R/sjPlotSetTheme.R---
@@ -193,7 +193,7 @@ sjp.setTheme <- function(# base theme
                          # geom defaults
                          # geom.colors=NULL,
                          geom.outline.color = NULL,
-                         geom.outline.size = 0.1,
+                         geom.outline.size = 0,
                          geom.boxoutline.size = 0.5,
                          geom.boxoutline.color = ""black"",
                          geom.alpha = 1,

---FILE: R/sjPlotStackFrequencies.R---
@@ -103,7 +103,10 @@ sjp.stackfrq <- function(items,
     axisTitle.y <- NULL
   } else {
     axisTitle.x <- axis.titles[1]
-    if (length(axis.titles) > 1) axisTitle.y <- axis.titles[2]
+    if (length(axis.titles) > 1)
+      axisTitle.y <- axis.titles[2]
+    else
+      axisTitle.y <- NULL
   }
   # --------------------------------------------------------
   # check sorting

---FILE: man/sjp.setTheme.Rd---
@@ -5,14 +5,13 @@
 \title{Set global theme options for sjp-functions}
 \usage{
 sjp.setTheme(theme = NULL, title.color = ""black"", title.size = 1.2,
-  title.align = ""left"", geom.outline.color = NULL,
-  geom.outline.size = 0.1, geom.boxoutline.size = 0.5,
-  geom.boxoutline.color = ""black"", geom.alpha = 1, geom.linetype = 1,
-  geom.errorbar.size = 0.7, geom.errorbar.linetype = 1,
-  geom.label.color = NULL, geom.label.size = 4, geom.label.alpha = 1,
-  geom.label.angle = 0, axis.title.color = ""grey30"",
-  axis.title.size = 1.1, axis.angle.x = 0, axis.angle.y = 0,
-  axis.angle = NULL, axis.textcolor.x = ""grey30"",
+  title.align = ""left"", geom.outline.color = NULL, geom.outline.size = 0,
+  geom.boxoutline.size = 0.5, geom.boxoutline.color = ""black"",
+  geom.alpha = 1, geom.linetype = 1, geom.errorbar.size = 0.7,
+  geom.errorbar.linetype = 1, geom.label.color = NULL,
+  geom.label.size = 4, geom.label.alpha = 1, geom.label.angle = 0,
+  axis.title.color = ""grey30"", axis.title.size = 1.1, axis.angle.x = 0,
+  axis.angle.y = 0, axis.angle = NULL, axis.textcolor.x = ""grey30"",
   axis.textcolor.y = ""grey30"", axis.textcolor = NULL,
   axis.linecolor.x = NULL, axis.linecolor.y = NULL, axis.linecolor = NULL,
   axis.line.size = 0.5, axis.textsize.x = 1, axis.textsize.y = 1,"
strengejacke,sjPlot,398a6a1b5b34a2b82258a8a61ad838ac7401a3df,Daniel Ldecke,d.luedecke@uke.de,2016-05-13T09:15:30Z,Daniel Ldecke,d.luedecke@uke.de,2016-05-13T09:15:30Z,minor fixes,R/sjPlotGLME.R;R/sjPlotGroupPropTable.R;man/sjp.aov1.Rd;man/sjp.glm.Rd;man/sjp.glmer.Rd;man/sjp.glmm.Rd;man/sjp.gpt.Rd;man/sjp.lm.Rd;man/sjp.lmer.Rd;man/sjp.lmm.Rd,False,True,True,False,32,30,62,"---FILE: R/sjPlotGLME.R---
@@ -241,7 +241,7 @@ sjp.glmer <- function(fit,
                       show.intercept = TRUE,
                       string.interc = ""(Intercept)"",
                       fade.ns = FALSE,
-                      ylim = NULL,
+                      axis.lim = NULL,
                       digits = 2,
                       vline.type = 2,
                       vline.color = ""grey70"",
@@ -274,7 +274,7 @@ sjp.glmer <- function(fit,
            sort.est,
            axis.labels,
            axis.title,
-           ylim,
+           axis.lim,
            vline.type,
            vline.color,
            remove.estimates,
@@ -526,7 +526,7 @@ sjp.lmer <- function(fit,
                      point.alpha = 0.2,
                      scatter.plot = TRUE,
                      fade.ns = FALSE,
-                     ylim = NULL,
+                     axis.lim = NULL,
                      digits = 2,
                      vline.type = 2,
                      vline.color = ""grey70"",
@@ -558,7 +558,7 @@ sjp.lmer <- function(fit,
            sort.est,
            axis.labels,
            axis.title,
-           ylim,
+           axis.lim,
            vline.type,
            vline.color,
            remove.estimates,
@@ -596,7 +596,7 @@ sjp.lme4  <- function(fit,
                       sort.est,
                       axis.labels,
                       axis.title,
-                      ylim,
+                      axis.lim,
                       vline.type,
                       vline.color,
                       remove.estimates,
@@ -763,10 +763,10 @@ sjp.lme4  <- function(fit,
       return(invisible(sjp.reglin(fit, title, 50, geom.colors, show.ci, point.alpha,
                                   scatter.plot, show.loess, show.loess.ci, 
                                   useResiduals = ifelse(type == ""fe.slope"", FALSE, TRUE),
-                                  remove.estimates, vars, ylim, prnt.plot)))
+                                  remove.estimates, vars, ylim = axis.lim, prnt.plot)))
     } else {
       return(invisible(sjp.glm.slope(fit, title, geom.size, remove.estimates, vars,
-                                     ylim, show.ci, facet.grid, prnt.plot)))
+                                     ylim = axis.lim, show.ci, facet.grid, prnt.plot)))
     }
   } else if (type == ""poly"") {
     # ---------------------------------------
@@ -784,7 +784,7 @@ sjp.lme4  <- function(fit,
     # plot marginal effects of fixed terms
     # ---------------------------------------
     return(invisible(sjp.glm.eff(fit, title, geom.size, remove.estimates, vars, 
-                                 show.ci, ylim = NULL, facet.grid,
+                                 show.ci, ylim = axis.lim, facet.grid,
                                  fun = fun, prnt.plot, ...)))
   } else if (type == ""ri.slope"") {
     # ---------------------------------------
@@ -795,12 +795,12 @@ sjp.lme4  <- function(fit,
       return(invisible(sjp.lmer.ri.slope(fit, ri.nr, vars, emph.grp, geom.size, prnt.plot)))
     } else {
       return(invisible(sjp.glmer.ri.slope(fit, show.ci, facet.grid, ri.nr, vars,
-                                          emph.grp, ylim, prnt.plot)))
+                                          emph.grp, ylim = axis.lim, prnt.plot)))
     }
   } else if (type == ""rs.ri"") {
     return(invisible(sjp.lme.rsri(fit, title, axis.title, ri.nr, emph.grp, 
                                   geom.colors, geom.size, sample.n, show.legend, 
-                                  ylim, prnt.plot, fun)))
+                                  ylim = axis.lim, prnt.plot, fun)))
   } else if (type == ""re.qq"") {
     # ---------------------------------------
     # plot qq-plots for random effects to
@@ -815,15 +815,15 @@ sjp.lme4  <- function(fit,
     # response value
     # ---------------------------------------
     return(invisible(sjp.glm.predy(fit, vars, t.title = title, l.title = NULL,
-                                   geom.colors, show.ci, geom.size, ylim, facet.grid, 
+                                   geom.colors, show.ci, geom.size, ylim = axis.lim, facet.grid, 
                                    type = ""re"", show.loess = F, prnt.plot)))
   } else if (type == ""pred.fe"") {
     # ---------------------------------------
     # plot predicted probabilities / values of
     # response value
     # ---------------------------------------
     return(invisible(sjp.glm.predy(fit, vars, t.title = title, l.title = NULL,
-                                   geom.colors, show.ci, geom.size, ylim, facet.grid, 
+                                   geom.colors, show.ci, geom.size, ylim = axis.lim, facet.grid, 
                                    type = ""fe"", show.loess = F, prnt.plot)))
   }
   # ---------------------------------------
@@ -1165,6 +1165,8 @@ sjp.lme4  <- function(fit,
                                       breaks = base_breaks(ceiling(max(mydf$conf.high, na.rm = T))),
                                       labels = prettyNum)
       }
+      # do we have an axis limit?
+      if (!is.null(axis.lim)) gp <- gp + ylim(axis.lim)
       # ---------------------------------------
       # hide error bars (conf int)?
       # ---------------------------------------

---FILE: R/sjPlotGroupPropTable.R---
@@ -23,6 +23,7 @@ utils::globalVariables(c(""dep"", ""n""))
 #'          the total-row in the figure will be highlighted with a slightly
 #'          shaded background.
 #' @param axis.lim numeric vector of length 2, defining the range of the plot axis.
+#'          Depending on plot type, may effect either x- or y-axis, or both.
 #'
 #' @return (Insisibily) returns the ggplot-object with the complete plot
 #'           (\code{plot}) as well as the data frame that

---FILE: man/sjp.aov1.Rd---
@@ -36,7 +36,8 @@ the value label of the grouping variable. Default is \code{""(Intercept)""}.}
 \item{axis.title}{character vector, used as title for the axis. If not specified, 
 a default labelling depending on the plot function and type is chosen.}
 
-\item{axis.lim}{numeric vector of length 2, defining the range of the plot axis.}
+\item{axis.lim}{numeric vector of length 2, defining the range of the plot axis.
+Depending on plot type, may effect either x- or y-axis, or both.}
 
 \item{geom.colors}{user defined color for geoms. See 'Details' in \code{\link{sjp.grpfrq}}.}
 

---FILE: man/sjp.glm.Rd---
@@ -74,7 +74,8 @@ one line and when a line break is inserted.}
 \item{wrap.labels}{numeric, determines how many chars of the value, variable or axis 
 labels are displayed in one line and when a line break is inserted.}
 
-\item{axis.lim}{numeric vector of length 2, defining the range of the plot axis.}
+\item{axis.lim}{numeric vector of length 2, defining the range of the plot axis.
+Depending on plot type, may effect either x- or y-axis, or both.}
 
 \item{grid.breaks}{numeric; sets the distance between breaks for the axis, 
 i.e. at every \code{grid.breaks}'th position a major grid is being printed.}

---FILE: man/sjp.glmer.Rd---
@@ -10,7 +10,7 @@ sjp.glmer(fit, type = ""re"", vars = NULL, ri.nr = NULL,
   geom.colors = ""Set1"", geom.size = NULL, show.values = TRUE,
   show.p = TRUE, show.ci = FALSE, show.legend = FALSE,
   show.intercept = TRUE, string.interc = ""(Intercept)"", fade.ns = FALSE,
-  ylim = NULL, digits = 2, vline.type = 2, vline.color = ""grey70"",
+  axis.lim = NULL, digits = 2, vline.type = 2, vline.color = ""grey70"",
   facet.grid = TRUE, free.scale = FALSE, y.offset = 0.1,
   prnt.plot = TRUE, ...)
 }
@@ -112,10 +112,6 @@ if \code{show.intercept = TRUE} and \code{axis.labels} is not \code{NULL}.}
 
 \item{fade.ns}{if \code{TRUE}, non significant estimates will be printed in slightly faded colors.}
 
-\item{ylim}{numeric vector of length two, defining lower and upper axis limits
-of the y scale. By default, this argument is set to \code{NULL}, i.e. the 
-y-axis fits to the required range of the data.}
-
 \item{digits}{numeric, amount of digits after decimal point when rounding estimates and values.}
 
 \item{vline.type}{linetype of the vertical ""zero point"" line. Default is \code{2} (dashed line).}

---FILE: man/sjp.glmm.Rd---
@@ -42,7 +42,8 @@ argument, since in most cases, axis labels are set automatically.}
 \item{axis.title}{character vector, used as title for the axis. If not specified, 
 a default labelling depending on the plot function and type is chosen.}
 
-\item{axis.lim}{numeric vector of length 2, defining the range of the plot axis.}
+\item{axis.lim}{numeric vector of length 2, defining the range of the plot axis.
+Depending on plot type, may effect either x- or y-axis, or both.}
 
 \item{wrap.title}{numeric, determines how many chars of the plot title are displayed in
 one line and when a line break is inserted.}

---FILE: man/sjp.gpt.Rd---
@@ -60,7 +60,8 @@ are displayed in one line and when a line break is inserted.}
 \item{wrap.legend.labels}{numeric, determines how many chars of the legend labels are 
 displayed in one line and when a line break is inserted.}
 
-\item{axis.lim}{numeric vector of length 2, defining the range of the plot axis.}
+\item{axis.lim}{numeric vector of length 2, defining the range of the plot axis.
+Depending on plot type, may effect either x- or y-axis, or both.}
 
 \item{grid.breaks}{numeric; sets the distance between breaks for the axis, 
 i.e. at every \code{grid.breaks}'th position a major grid is being printed.}

---FILE: man/sjp.lm.Rd---
@@ -92,7 +92,8 @@ one line and when a line break is inserted.}
 \item{wrap.labels}{numeric, determines how many chars of the value, variable or axis 
 labels are displayed in one line and when a line break is inserted.}
 
-\item{axis.lim}{numeric vector of length 2, defining the range of the plot axis.}
+\item{axis.lim}{numeric vector of length 2, defining the range of the plot axis.
+Depending on plot type, may effect either x- or y-axis, or both.}
 
 \item{grid.breaks}{numeric; sets the distance between breaks for the axis, 
 i.e. at every \code{grid.breaks}'th position a major grid is being printed.}

---FILE: man/sjp.lmer.Rd---
@@ -11,9 +11,10 @@ sjp.lmer(fit, type = ""re"", vars = NULL, ri.nr = NULL,
   show.values = TRUE, show.p = TRUE, show.ci = FALSE,
   show.legend = FALSE, show.loess = FALSE, show.loess.ci = FALSE,
   show.intercept = TRUE, string.interc = ""(Intercept)"", p.kr = TRUE,
-  point.alpha = 0.2, scatter.plot = TRUE, fade.ns = FALSE, ylim = NULL,
-  digits = 2, vline.type = 2, vline.color = ""grey70"", facet.grid = TRUE,
-  free.scale = FALSE, y.offset = 0.1, prnt.plot = TRUE, ...)
+  point.alpha = 0.2, scatter.plot = TRUE, fade.ns = FALSE,
+  axis.lim = NULL, digits = 2, vline.type = 2, vline.color = ""grey70"",
+  facet.grid = TRUE, free.scale = FALSE, y.offset = 0.1,
+  prnt.plot = TRUE, ...)
 }
 \arguments{
 \item{fit}{a fitted model as returned by the \code{\link[lme4]{lmer}}-function.}
@@ -139,10 +140,6 @@ is plotted. Only applies for slope-type plots.}
 
 \item{fade.ns}{if \code{TRUE}, non significant estimates will be printed in slightly faded colors.}
 
-\item{ylim}{numeric vector of length two, defining lower and upper axis limits
-of the y scale. By default, this argument is set to \code{NULL}, i.e. the 
-y-axis fits to the required range of the data.}
-
 \item{digits}{numeric, amount of digits after decimal point when rounding estimates and values.}
 
 \item{vline.type}{linetype of the vertical ""zero point"" line. Default is \code{2} (dashed line).}

---FILE: man/sjp.lmm.Rd---
@@ -49,7 +49,8 @@ argument, since in most cases, axis labels are set automatically.}
 \item{axis.title}{character vector, used as title for the axis. If not specified, 
 a default labelling depending on the plot function and type is chosen.}
 
-\item{axis.lim}{numeric vector of length 2, defining the range of the plot axis.}
+\item{axis.lim}{numeric vector of length 2, defining the range of the plot axis.
+Depending on plot type, may effect either x- or y-axis, or both.}
 
 \item{wrap.title}{numeric, determines how many chars of the plot title are displayed in
 one line and when a line break is inserted.}"
strengejacke,sjPlot,089a91c4f41a8e5d5ffc39b85bb62fba411b94a9,Daniel Ldecke,d.luedecke@uke.de,2016-05-13T08:03:36Z,Daniel Ldecke,d.luedecke@uke.de,2016-05-13T08:03:36Z,"Harmonizing arguments, minor bug fixes",R/helpfunctions.R;R/sjPlotAncovaLSMeans.R;R/sjPlotAnova.R;R/sjPlotClusterAnalysis.R;R/sjPlotCorr.R;R/sjPlotFrequencies.R;R/sjPlotGLME.R;R/sjPlotGroupFrequencies.R;R/sjPlotGroupPropTable.R;R/sjPlotInteractions.R;R/sjPlotLikert.R;R/sjPlotLinreg.R;R/sjPlotLinregMultiple.R;R/sjPlotOdds.R;R/sjPlotOddsMultiple.R;R/sjPlotPCA.R;R/sjPlotPearsonsChi2Test.R;R/sjPlotPolynomials.R;R/sjPlotPropTable.R;R/sjPlotScatter.R;R/sjPlotSetTheme.R;R/sjPlotStackFrequencies.R;man/adjust_plot_range.Rd;man/sjc.grpdisc.Rd;man/sjc.qclus.Rd;man/sjp.aov1.Rd;man/sjp.chi2.Rd;man/sjp.corr.Rd;man/sjp.frq.Rd;man/sjp.glm.Rd;man/sjp.glmer.Rd;man/sjp.glmm.Rd;man/sjp.gpt.Rd;man/sjp.grpfrq.Rd;man/sjp.int.Rd;man/sjp.likert.Rd;man/sjp.lm.Rd;man/sjp.lmer.Rd;man/sjp.lmm.Rd;man/sjp.pca.Rd;man/sjp.poly.Rd;man/sjp.scatter.Rd;man/sjp.setTheme.Rd;man/sjp.stackfrq.Rd;man/sjp.xtab.Rd,False,True,True,False,251,259,510,"---FILE: R/helpfunctions.R---
@@ -747,7 +747,7 @@ get_model_response_label <- function(fit) {
 #' data(efc)
 #' # show frequencies of relationship-variable and
 #' # retrieve plot object
-#' gp <- sjp.frq(efc$e15relat, printPlot = FALSE)
+#' gp <- sjp.frq(efc$e15relat, prnt.plot = FALSE)
 #' # show current plot
 #' plot(gp$plot)
 #' # show adjusted plot
@@ -764,8 +764,7 @@ adjust_plot_range <- function(gp, upperMargin=1.05) {
   ylo <- abs(gy$panel$ranges[[1]]$y.range[1])
   yhi <- abs(gy$panel$ranges[[1]]$y.range[2] * upperMargin)
   # change y scale
-  gp <- gp + scale_y_continuous(expand = c(0, 0),
-                                limits = c(0, ylo + yhi))
+  gp <- gp + scale_y_continuous(expand = c(0, 0), limits = c(0, ylo + yhi))
   # return plot
   return(gp)
 }

---FILE: R/sjPlotAncovaLSMeans.R---
@@ -23,7 +23,7 @@ sjp.emm <- function(fit,
                     ylim = NULL,
                     grid.breaks = NULL,
                     facet.grid = FALSE,
-                    printPlot = TRUE) {
+                    prnt.plot = TRUE) {
   # --------------------------------------------------------
   # check default geom.size
   # --------------------------------------------------------
@@ -347,7 +347,7 @@ sjp.emm <- function(fit,
       # ---------------------------------------------------------
       # Check whether ggplot object should be returned or plotted
       # ---------------------------------------------------------
-      if (printPlot) print(baseplot)
+      if (prnt.plot) graphics::plot(baseplot)
       # concatenate plot object
       plotlist[[length(plotlist) + 1]] <- baseplot
       dflist[[length(dflist) + 1]] <- intdf

---FILE: R/sjPlotAnova.R---
@@ -63,7 +63,7 @@ sjp.aov1 <- function(var.dep,
                      y.offset = .1,
                      show.p = TRUE,
                      show.summary = FALSE,
-                     printPlot = TRUE) {
+                     prnt.plot = TRUE) {
   # --------------------------------------------------------
   # get variable name
   # --------------------------------------------------------
@@ -277,7 +277,7 @@ sjp.aov1 <- function(var.dep,
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------
-  if (printPlot) print(anovaplot)
+  if (prnt.plot) graphics::plot(anovaplot)
   # -------------------------------------
   # set proper column names
   # -------------------------------------

---FILE: R/sjPlotClusterAnalysis.R---
@@ -127,7 +127,7 @@ sjc.qclus <- function(data,
                       legend.labels = NULL,
                       coord.flip = FALSE,
                       reverse.axis = FALSE,
-                      printPlot = TRUE) {
+                      prnt.plot = TRUE) {
   # --------------------------------------------------------
   # match arguments
   # --------------------------------------------------------
@@ -203,7 +203,7 @@ sjc.qclus <- function(data,
   grp.accuracy <- sjc.grpdisc(data, 
                               groups = grp, 
                               groupcount = groupcount, 
-                              printPlot = show.accuracy)
+                              prnt.plot = show.accuracy)
   # ---------------------------------------------
   # Add group count to legend labels
   # ---------------------------------------------
@@ -288,7 +288,7 @@ sjc.qclus <- function(data,
   # --------------------------------------------------------
   # plot
   # --------------------------------------------------------
-  if (printPlot) graphics::plot(gp)
+  if (prnt.plot) graphics::plot(gp)
   # --------------------------------------------------------
   # return values
   # --------------------------------------------------------
@@ -518,8 +518,6 @@ sjc.dend <- function(data, groupcount, distance = ""euclidean"", agglomeration = ""
 #' @param clss.fit logical, if \code{TRUE} (default), a vertical line indicating the
 #'          overall goodness of classification is added to the plot, so one can see
 #'          whether a certain group is below or above the average classification goodness.
-#' @param printPlot logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
-#'          want to plot any graphs. In either case, the ggplot-object will be returned as value.
 #'
 #' @inheritParams sjc.cluster
 #'
@@ -544,7 +542,7 @@ sjc.dend <- function(data, groupcount, distance = ""euclidean"", agglomeration = ""
 #' @importFrom graphics plot
 #' @import ggplot2
 #' @export
-sjc.grpdisc <- function(data, groups, groupcount, clss.fit = TRUE, printPlot = TRUE) {
+sjc.grpdisc <- function(data, groups, groupcount, clss.fit = TRUE, prnt.plot = TRUE) {
   # Prepare Data
   # listwise deletion of missing
   data <- stats::na.omit(data)
@@ -647,7 +645,7 @@ sjc.grpdisc <- function(data, groups, groupcount, clss.fit = TRUE, printPlot = T
   # --------------------------------------------------------
   # plot
   # --------------------------------------------------------
-  if (printPlot) graphics::plot(classplot)
+  if (prnt.plot) graphics::plot(classplot)
   # --------------------------------------------------------
   # return values
   # --------------------------------------------------------

---FILE: R/sjPlotCorr.R---
@@ -106,7 +106,7 @@ sjp.corr <- function(data,
                      show.values = TRUE,
                      show.p = TRUE,
                      p.numeric = FALSE,
-                     printPlot = TRUE) {
+                     prnt.plot = TRUE) {
   # --------------------------------------------------------
   # check p-value-style option
   # --------------------------------------------------------
@@ -324,7 +324,7 @@ sjp.corr <- function(data,
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------
-  if (printPlot) graphics::plot(corrPlot)
+  if (prnt.plot) graphics::plot(corrPlot)
   # -------------------------------------
   # return results
   # -------------------------------------

---FILE: R/sjPlotFrequencies.R---
@@ -146,7 +146,7 @@ sjp.frq <- function(var.cnt,
                     vjust = ""bottom"",
                     hjust = ""center"",
                     y.offset = NULL,
-                    printPlot = TRUE) {
+                    prnt.plot = TRUE) {
   # --------------------------------------------------------
   # get variable name
   # --------------------------------------------------------
@@ -443,8 +443,8 @@ sjp.frq <- function(var.cnt,
     if (show.ci) {
       ebcol <- ifelse(type == ""dot"", geom.colors, errorbar.color)
       # print confidence intervalls (error bars)
-      baseplot <- baseplot + geom_errorbar(aes(ymin = lower.ci, ymax = upper.ci), 
-                                           colour = ebcol, width = 0)
+      baseplot <- baseplot + 
+        geom_errorbar(aes(ymin = lower.ci, ymax = upper.ci), colour = ebcol, width = 0)
     }
     # check whether coordinates should be flipped, i.e.
     # swap x and y axis
@@ -475,13 +475,11 @@ sjp.frq <- function(var.cnt,
       stat_summary(fun.y = ""mean"", geom = ""point"", shape = 21, 
                    size = inner.box.dotsize, fill = fcsp)
     # no additional labels for the x- and y-axis, only diagram title
-    baseplot <- baseplot + 
-      yscale +
-      scalex
+    baseplot <- baseplot + yscale + scalex
   # --------------------------------------------------
   # Start density plot here
   # --------------------------------------------------
-  } else if (type == ""dens"") {
+  } else if (type == ""density"") {
     xv <- stats::na.omit(var.cnt)
     densityDat <- data.frame(xv)
     # First, plot histogram with density curve
@@ -586,7 +584,7 @@ sjp.frq <- function(var.cnt,
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------
-  if (printPlot) graphics::plot(baseplot)
+  if (prnt.plot) graphics::plot(baseplot)
   # -------------------------------------
   # return results
   # -------------------------------------

---FILE: R/sjPlotGLME.R---
@@ -248,7 +248,7 @@ sjp.glmer <- function(fit,
                       facet.grid = TRUE,
                       free.scale = FALSE,
                       y.offset = .1,
-                      printPlot = TRUE,
+                      prnt.plot = TRUE,
                       ...) {
   # -------------------------------------
   # check for deprecated argument values
@@ -287,7 +287,7 @@ sjp.glmer <- function(fit,
            fade.ns,
            show.ci,
            FALSE,
-           printPlot,
+           prnt.plot,
            fun = ""glm"",
            0.2,
            TRUE,
@@ -533,7 +533,7 @@ sjp.lmer <- function(fit,
                      facet.grid = TRUE,
                      free.scale = FALSE,
                      y.offset = .1,
-                     printPlot = TRUE,
+                     prnt.plot = TRUE,
                      ...) {
   # -------------------------------------
   # check for deprecated argument values
@@ -571,7 +571,7 @@ sjp.lmer <- function(fit,
            fade.ns,
            show.ci,
            p.kr,
-           printPlot,
+           prnt.plot,
            fun = ""lm"",
            point.alpha,
            scatter.plot,
@@ -609,7 +609,7 @@ sjp.lme4  <- function(fit,
                       fade.ns,
                       show.ci,
                       p.kr,
-                      printPlot,
+                      prnt.plot,
                       fun,
                       point.alpha = 0.2,
                       scatter.plot = TRUE,
@@ -752,7 +752,7 @@ sjp.lme4  <- function(fit,
     # plot correlation matrix of fixed effects,
     # to inspect multicollinearity
     # ---------------------------------------
-    return(invisible(sjp.lme.fecor(fit, axis.labels, sort.est, fun, printPlot)))
+    return(invisible(sjp.lme.fecor(fit, axis.labels, sort.est, fun, prnt.plot)))
   } else if (type == ""fe.slope"" || type == ""fe.resid"") {
     # ---------------------------------------
     # plot slopes for each fixed coefficient
@@ -763,18 +763,18 @@ sjp.lme4  <- function(fit,
       return(invisible(sjp.reglin(fit, title, 50, geom.colors, show.ci, point.alpha,
                                   scatter.plot, show.loess, show.loess.ci, 
                                   useResiduals = ifelse(type == ""fe.slope"", FALSE, TRUE),
-                                  remove.estimates, vars, ylim, printPlot)))
+                                  remove.estimates, vars, ylim, prnt.plot)))
     } else {
       return(invisible(sjp.glm.slope(fit, title, geom.size, remove.estimates, vars,
-                                     ylim, show.ci, facet.grid, printPlot)))
+                                     ylim, show.ci, facet.grid, prnt.plot)))
     }
   } else if (type == ""poly"") {
     # ---------------------------------------
     # plot marginal effects for polynimial terms
     # ---------------------------------------
     if (fun == ""lm"") {
       return(invisible(sjp.lm.poly(fit, poly.term, geom.colors, geom.size, axis.title,
-                                   show.ci, printPlot)))
+                                   show.ci, prnt.plot)))
     } else {
       warning(""Plotting polynomial terms only works for function `sjp.lmer`."", call. = FALSE)
       return(invisible(NULL))
@@ -785,46 +785,46 @@ sjp.lme4  <- function(fit,
     # ---------------------------------------
     return(invisible(sjp.glm.eff(fit, title, geom.size, remove.estimates, vars, 
                                  show.ci, ylim = NULL, facet.grid,
-                                 fun = fun, printPlot, ...)))
+                                 fun = fun, prnt.plot, ...)))
   } else if (type == ""ri.slope"") {
     # ---------------------------------------
     # plot slopes for each fixex coefficient
     # depending on random intercept levels
     # ---------------------------------------
     if (fun == ""lm"") {
-      return(invisible(sjp.lmer.ri.slope(fit, ri.nr, vars, emph.grp, geom.size, printPlot)))
+      return(invisible(sjp.lmer.ri.slope(fit, ri.nr, vars, emph.grp, geom.size, prnt.plot)))
     } else {
       return(invisible(sjp.glmer.ri.slope(fit, show.ci, facet.grid, ri.nr, vars,
-                                          emph.grp, ylim, printPlot)))
+                                          emph.grp, ylim, prnt.plot)))
     }
   } else if (type == ""rs.ri"") {
     return(invisible(sjp.lme.rsri(fit, title, axis.title, ri.nr, emph.grp, 
                                   geom.colors, geom.size, sample.n, show.legend, 
-                                  ylim, printPlot, fun)))
+                                  ylim, prnt.plot, fun)))
   } else if (type == ""re.qq"") {
     # ---------------------------------------
     # plot qq-plots for random effects to
     # inspect normality
     # ---------------------------------------
     return(invisible(sjp.lme.reqq(fit, geom.colors, geom.size, show.ci,
                                   vline.type, vline.color, fun,
-                                  printPlot)))
+                                  prnt.plot)))
   } else if (type == ""pred"") {
     # ---------------------------------------
     # plot predicted probabilities / values of
     # response value
     # ---------------------------------------
     return(invisible(sjp.glm.predy(fit, vars, t.title = title, l.title = NULL,
                                    geom.colors, show.ci, geom.size, ylim, facet.grid, 
-                                   type = ""re"", show.loess = F, printPlot)))
+                                   type = ""re"", show.loess = F, prnt.plot)))
   } else if (type == ""pred.fe"") {
     # ---------------------------------------
     # plot predicted probabilities / values of
     # response value
     # ---------------------------------------
     return(invisible(sjp.glm.predy(fit, vars, t.title = title, l.title = NULL,
                                    geom.colors, show.ci, geom.size, ylim, facet.grid, 
-                                   type = ""fe"", show.loess = F, printPlot)))
+                                   type = ""fe"", show.loess = F, prnt.plot)))
   }
   # ---------------------------------------
   # check geom size
@@ -1220,7 +1220,7 @@ sjp.lme4  <- function(fit,
       # ---------------------------------------------------------
       # Check whether ggplot object should be returned or plotted
       # ---------------------------------------------------------
-      if (printPlot) print(me.plot)
+      if (prnt.plot) graphics::plot(me.plot)
       me.plot <- NULL
     } else {
       # ---------------------------------------
@@ -1253,7 +1253,7 @@ sjp.lme4  <- function(fit,
         # ---------------------------------------------------------
         # Check whether ggplot object should be returned or plotted
         # ---------------------------------------------------------
-        if (printPlot) print(me.plot)
+        if (prnt.plot) graphics::plot(me.plot)
         me.plot <- NULL
       }
     }
@@ -1278,7 +1278,7 @@ sjp.lme4  <- function(fit,
 
 #' @importFrom stats model.frame family na.omit
 sjp.glmer.ri.slope <- function(fit, show.ci, facet.grid, ri.nr, vars, emph.grp,
-                               ylim, printPlot) {
+                               ylim, prnt.plot) {
   # ----------------------------
   # retrieve data frame of model to check whether
   # we have any numeric terms in fitted model; and
@@ -1451,7 +1451,7 @@ sjp.glmer.ri.slope <- function(fit, show.ci, facet.grid, ri.nr, vars, emph.grp,
           # -------------------------------------
           # check if metric plots should be plotted
           # -------------------------------------
-          if (printPlot) print(mp)
+          if (prnt.plot) graphics::plot(mp)
         }
       }
     }
@@ -1462,7 +1462,7 @@ sjp.glmer.ri.slope <- function(fit, show.ci, facet.grid, ri.nr, vars, emph.grp,
 }
 
 
-sjp.lmer.ri.slope <- function(fit, ri.nr, vars, emph.grp, geom.size, printPlot) {
+sjp.lmer.ri.slope <- function(fit, ri.nr, vars, emph.grp, geom.size, prnt.plot) {
   # check size argument
   if (is.null(geom.size)) geom.size <- .7
   # -----------------------------------------------------------
@@ -1576,7 +1576,7 @@ sjp.lmer.ri.slope <- function(fit, ri.nr, vars, emph.grp, geom.size, printPlot)
       # -------------------------------------
       # check if metric plots should be plotted
       # -------------------------------------
-      if (printPlot) print(gp)
+      if (prnt.plot) graphics::plot(gp)
     }
   }
   invisible(structure(class = ""sjplmer.feri"",
@@ -1595,7 +1595,7 @@ sjp.lme.rsri <- function(fit,
                          sample.n,
                          show.legend,
                          ylim,
-                         printPlot,
+                         prnt.plot,
                          fun) {
   # check size argument
   if (is.null(geom.size)) geom.size <- .7
@@ -1787,7 +1787,7 @@ sjp.lme.rsri <- function(fit,
       # -------------------------------------
       # check if metric plots should be plotted
       # -------------------------------------
-      if (printPlot) print(gp)
+      if (prnt.plot) graphics::plot(gp)
     }
   }
   invisible(structure(class = ""sjplmer.reri"",
@@ -1810,7 +1810,7 @@ sjp.lme.reqq <- function(fit,
                          vline.type,
                          vline.color,
                          fun,
-                         printPlot) {
+                         prnt.plot) {
   re   <- lme4::ranef(fit, condVar = T)[[1]]
   pv   <- attr(re, ""postVar"")
   cols <- 1:(dim(pv)[1])
@@ -1854,9 +1854,9 @@ sjp.lme.reqq <- function(fit,
   # ---------------------------------------------------------
   # print plot?
   # ---------------------------------------------------------
-  if (printPlot) {
+  if (prnt.plot) {
     message(""Testing for normal distribution. Dots should be plotted along the line."")
-    print(gp)
+    graphics::plot(gp)
   }
   # -------------------------------------
   # return results
@@ -1878,7 +1878,7 @@ sjp.lme.fecor <- function(fit,
                           axis.labels,
                           sort.est,
                           fun,
-                          printPlot,
+                          prnt.plot,
                           fcall = ""sjp"",
                           CSS = NULL,
                           use.viewer = TRUE,
@@ -1909,7 +1909,7 @@ sjp.lme.fecor <- function(fit,
   # ---------------------------------------
   if (fcall == ""sjp"") {
     corret <- sjp.corr(as.matrix(mydf), sort.corr = sort.est,
-                       axis.labels = axis.labels, printPlot = printPlot)
+                       axis.labels = axis.labels, prnt.plot = prnt.plot)
   } else {
     corret <- sjt.corr(as.matrix(mydf),
                        triangle = ""l"",
@@ -1968,7 +1968,7 @@ sjp.glm.eff <- function(fit,
                         ylim,
                         facet.grid,
                         fun,
-                        printPlot,
+                        prnt.plot,
                         ...) {
   # ---------------------------------------
   # check axis range
@@ -2168,7 +2168,7 @@ sjp.glm.eff <- function(fit,
     # ------------------------
     # print plot?
     # ------------------------
-    if (printPlot) print(eff.plot)
+    if (prnt.plot) graphics::plot(eff.plot)
   } else {
     # separate plot for each group
     for (i in unique(mydat$grp)) {
@@ -2200,7 +2200,7 @@ sjp.glm.eff <- function(fit,
       # ------------------------
       # print plot?
       # ------------------------
-      if (printPlot) print(eff.plot)
+      if (prnt.plot) graphics::plot(eff.plot)
       # add plot to plot list
       eff.plot.list[[length(eff.plot.list) + 1]] <- eff.plot
     }

---FILE: R/sjPlotGroupFrequencies.R---
@@ -116,7 +116,7 @@ utils::globalVariables(c(""."", ""label"", ""prz"", ""frq"", ""ypos"", ""wb"", ""ia"", ""mw"", ""
 #'          to the top/bottom of the geom (see \code{hjust} and \code{vjust}).
 #' @param show.na logical, if \code{TRUE}, \code{\link{NA}}'s (missing values)
 #'          are added to the output.
-#' @param printPlot logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+#' @param prnt.plot logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 #'          want to plot any graphs. In either case, the ggplot-object will be returned as value.
 #' @return (Insisibily) returns the ggplot-object with the complete plot (\code{plot}) as well as the data frame that
 #'           was used for setting up the ggplot-object (\code{df}).
@@ -201,7 +201,7 @@ sjp.grpfrq <- function(var.cnt,
                        y.offset = NULL,
                        vjust = ""bottom"",
                        hjust = ""center"",
-                       printPlot = TRUE) {
+                       prnt.plot = TRUE) {
   # --------------------------------------------------------
   # get variable name
   # --------------------------------------------------------
@@ -215,7 +215,10 @@ sjp.grpfrq <- function(var.cnt,
     axisTitle.y <- NULL
   } else {
     axisTitle.x <- axis.titles[1]
-    if (length(axis.titles) > 1) axisTitle.y <- axis.titles[2]
+    if (length(axis.titles) > 1) 
+      axisTitle.y <- axis.titles[2]
+    else
+      axisTitle.y <- NULL
   }
   # --------------------------------------------------------
   # match arguments
@@ -764,7 +767,7 @@ sjp.grpfrq <- function(var.cnt,
   # ----------------------------------
   # Plot integrated bar chart here
   # ----------------------------------
-  if (printPlot) graphics::plot(baseplot)
+  if (prnt.plot) graphics::plot(baseplot)
   # -------------------------------------
   # return results
   # -------------------------------------

---FILE: R/sjPlotGroupPropTable.R---
@@ -78,7 +78,7 @@ sjp.gpt <- function(x,
                     annotate.total = TRUE,
                     show.p = TRUE,
                     show.n = TRUE,
-                    printPlot = TRUE) {
+                    prnt.plot = TRUE) {
   # --------------------------------------------------------
   # get variable name
   # --------------------------------------------------------
@@ -250,6 +250,6 @@ sjp.gpt <- function(x,
   # --------------------------------------------------------
   # print plot
   # --------------------------------------------------------
-  if (printPlot) print(p)
+  if (prnt.plot) graphics::plot(p)
   invisible(structure(list(plot = p, df = newdf)))
 }

---FILE: R/sjPlotInteractions.R---
@@ -304,7 +304,7 @@ sjp.int <- function(fit,
                     y.offset = 0.07,
                     digits = 2,
                     facet.grid = FALSE,
-                    printPlot = TRUE,
+                    prnt.plot = TRUE,
                     ...) {
   # -----------------------------------------------------------
   # match arguments
@@ -394,7 +394,7 @@ sjp.int <- function(fit,
                    axis.title, axis.labels, legend.title, legend.labels,
                    show.values, digits, show.ci, p.kr, wrap.title,
                    wrap.legend.title, wrap.legend.labels, y.offset, ylim, 
-                   grid.breaks, facet.grid, printPlot))
+                   grid.breaks, facet.grid, prnt.plot))
   }
   # --------------------------------------------------------
   # list labels
@@ -409,7 +409,7 @@ sjp.int <- function(fit,
                        title, fill.alpha, geom.colors, geom.size, axis.title,
                        legend.title, legend.labels, show.values, wrap.title, wrap.legend.labels, 
                        wrap.legend.title, xlim, ylim, y.offset, grid.breaks, 
-                       show.ci, facet.grid, printPlot, fun, ...))
+                       show.ci, facet.grid, prnt.plot, fun, ...))
   }
   # -----------------------------------------------------------
   # set axis title
@@ -839,7 +839,7 @@ sjp.int <- function(fit,
     # ---------------------------------------------------------
     # Check whether ggplot object should be returned or plotted
     # ---------------------------------------------------------
-    if (printPlot) print(baseplot)
+    if (prnt.plot) graphics::plot(baseplot)
     # concatenate plot object
     plotlist[[length(plotlist) + 1]] <- baseplot
     dflist[[length(dflist) + 1]] <- intdf
@@ -877,7 +877,7 @@ sjp.eff.int <- function(fit,
                         grid.breaks = NULL,
                         show.ci = FALSE,
                         facet.grid = FALSE,
-                        printPlot = TRUE,
+                        prnt.plot = TRUE,
                         fun,
                         ...) {
   # --------------------------------------------------------
@@ -1348,7 +1348,7 @@ sjp.eff.int <- function(fit,
     # ---------------------------------------------------------
     # Check whether ggplot object should be returned or plotted
     # ---------------------------------------------------------
-    if (printPlot) print(baseplot)
+    if (prnt.plot) graphics::plot(baseplot)
     # concatenate plot object
     plotlist[[length(plotlist) + 1]] <- baseplot
     dflist[[length(dflist) + 1]] <- intdf

---FILE: R/sjPlotLikert.R---
@@ -157,7 +157,7 @@ sjp.likert <- function(items,
                        expand.grid = TRUE,
                        digits = 1,
                        coord.flip = TRUE,
-                       printPlot = TRUE) {
+                       prnt.plot = TRUE) {
   # --------------------------------------------------------
   # check param. if we have a single vector instead of
   # a data frame with several items, convert vector to data frame
@@ -600,7 +600,7 @@ sjp.likert <- function(items,
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------
-  if (printPlot) graphics::plot(gp)
+  if (prnt.plot) graphics::plot(gp)
   # -------------------------------------
   # return results
   # -------------------------------------

---FILE: R/sjPlotLinreg.R---
@@ -281,7 +281,7 @@ sjp.lm <- function(fit,
                    y.offset = .15,
                    facet.grid = TRUE,
                    completeDiagnostic = FALSE,
-                   printPlot = TRUE,
+                   prnt.plot = TRUE,
                    ...) {
   # -----------------------------------------------------------
   # remember length of predictor variables
@@ -319,29 +319,29 @@ sjp.lm <- function(fit,
                              wrap.labels, geom.colors, show.ci, point.alpha,
                              scatter.plot, show.loess, show.loess.ci, show.summary,
                              useResiduals = ifelse(type == ""lm"", FALSE, TRUE),
-                             printPlot)))
+                             prnt.plot)))
   }
   if (type == ""slope"" || type == ""resid"") {
     # reset default color setting, does not look that good.
     if (geom.colors == ""Set1"") geom.colors <- NULL
     return(invisible(sjp.reglin(fit, title, wrap.title, geom.colors, show.ci,
                                 point.alpha, scatter.plot, show.loess, show.loess.ci,
                                 useResiduals = ifelse(type == ""slope"", FALSE, TRUE),
-                                remove.estimates, vars, ylim = axis.lim, printPlot)))
+                                remove.estimates, vars, ylim = axis.lim, prnt.plot)))
   }
   if (type == ""pred"") {
     return(invisible(sjp.glm.predy(fit, vars, t.title = title, l.title = legend.title,
                                    geom.colors, show.ci, geom.size, ylim = axis.lim,
-                                   facet.grid, type = ""fe"", show.loess, printPlot)))
+                                   facet.grid, type = ""fe"", show.loess, prnt.plot)))
   }
   if (type == ""poly"") {
     return(invisible(sjp.lm.poly(fit, poly.term, geom.colors, geom.size, axis.title,
-                                 show.ci, printPlot)))
+                                 show.ci, prnt.plot)))
   }
   if (type == ""eff"") {
     return(invisible(sjp.glm.eff(fit, title, geom.size, remove.estimates, vars,
                                  show.ci, ylim = NULL, facet.grid,
-                                 fun = ""lm"", printPlot, ...)))
+                                 fun = ""lm"", prnt.plot, ...)))
   }
   if (type == ""ma"") {
     return(invisible(sjp.lm.ma(fit, completeDiagnostic)))
@@ -569,7 +569,7 @@ sjp.lm <- function(fit,
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------
-  if (printPlot) print(betaplot)
+  if (prnt.plot) graphics::plot(betaplot)
   # -------------------------------------
   # set proper column names
   # -------------------------------------
@@ -598,7 +598,7 @@ sjp.reglin <- function(fit,
                        remove.estimates = NULL,
                        vars = NULL,
                        ylim = NULL,
-                       printPlot = TRUE) {
+                       prnt.plot = TRUE) {
   # -----------------------------------------------------------
   # check argument
   # -----------------------------------------------------------
@@ -707,7 +707,7 @@ sjp.reglin <- function(fit,
     plotlist[[length(plotlist) + 1]] <- reglinplot
     dflist[[length(dflist) + 1]] <- mydat
     # print plot
-    if (printPlot) graphics::plot(reglinplot)
+    if (prnt.plot) graphics::plot(reglinplot)
   }
   # -------------------------------------
   # return results
@@ -906,7 +906,7 @@ sjp.lm.ma <- function(linreg, completeDiagnostic = FALSE) {
   # save plot
   plot.list[[length(plot.list) + 1]] <- p1
   # print plot
-  suppressWarnings(print(p1))
+  suppressWarnings(graphics::plot(p1))
   # ---------------------------------
   # Print non-normality of residuals both of original and updated model
   # Distribution should look like normal curve
@@ -930,7 +930,7 @@ sjp.lm.ma <- function(linreg, completeDiagnostic = FALSE) {
   # save plot
   plot.list[[length(plot.list) + 1]] <- p1
   # print plot
-  print(p1)
+  graphics::plot(p1)
   # ---------------------------------
   # Non-constant residuals
   # ---------------------------------
@@ -962,17 +962,17 @@ sjp.lm.ma <- function(linreg, completeDiagnostic = FALSE) {
   # save plot
   plot.list[[length(plot.list) + 1]] <- p1
   # print plot
-  print(p1)
+  graphics::plot(p1)
   # ---------------------------------
   # summarize old and new model
   # ---------------------------------
   if (any(class(linreg) == ""lm"")) {
     sjp.setTheme(theme = ""forestw"")
-    p1 <- sjp.lm(linreg, printPlot = FALSE)$plot
+    p1 <- sjp.lm(linreg, prnt.plot = FALSE)$plot
     # save plot
     plot.list[[length(plot.list) + 1]] <- p1
     # print plot
-    print(p1)
+    graphics::plot(p1)
     if (completeDiagnostic) {
       # ---------------------------------
       # Plot residuals against predictors
@@ -1025,7 +1025,7 @@ sjp.lm1 <- function(fit,
                    show.loess.ci=FALSE,
                    show.summary=TRUE,
                    useResiduals=FALSE,
-                   printPlot=TRUE) {
+                   prnt.plot=TRUE) {
   # -----------------------------------------------------------
   # check argument
   # -----------------------------------------------------------
@@ -1138,7 +1138,7 @@ sjp.lm1 <- function(fit,
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------
-  if (printPlot) print(reglinplot)
+  if (prnt.plot) graphics::plot(reglinplot)
   # -------------------------------------
   # return results
   # -------------------------------------
@@ -1154,7 +1154,7 @@ sjp.lm.poly <- function(fit,
                         geom.size,
                         axis.title,
                         show.ci,
-                        printPlot) {
+                        prnt.plot) {
   # check size argument
   if (is.null(geom.size)) geom.size <- .8
   # ------------------------
@@ -1248,7 +1248,7 @@ sjp.lm.poly <- function(fit,
     geom_line(colour = geom.colors[1], size = geom.size) +
     labs(x = axis.title, y = resp.name)
   # print plot
-  if (printPlot) print(polyplot)
+  if (prnt.plot) graphics::plot(polyplot)
   # return result
   invisible(structure(class = ""sjplmpoly"",
                       list(plot = polyplot,

---FILE: R/sjPlotLinregMultiple.R---
@@ -118,7 +118,7 @@ sjp.lmm <- function(...,
                     digits = 2,
                     facet.grid = FALSE,
                     coord.flip = TRUE,
-                    printPlot = TRUE) {
+                    prnt.plot = TRUE) {
   # --------------------------------------------------------
   # retrieve list of fitted models
   # --------------------------------------------------------
@@ -419,7 +419,7 @@ sjp.lmm <- function(...,
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------
-  if (printPlot) graphics::plot(plotHeader)
+  if (prnt.plot) graphics::plot(plotHeader)
   # -------------------------------------
   # set proper column names
   # -------------------------------------

---FILE: R/sjPlotOdds.R---
@@ -151,7 +151,7 @@ sjp.glm <- function(fit,
                     coord.flip = TRUE,
                     y.offset = .15,
                     facet.grid = TRUE,
-                    printPlot = TRUE,
+                    prnt.plot = TRUE,
                     ...) {
   # --------------------------------------------------------
   # check arg
@@ -180,17 +180,17 @@ sjp.glm <- function(fit,
   # --------------------------------------------------------
   if (type == ""slope"") {
     return(invisible(sjp.glm.slope(fit, title, geom.size, remove.estimates, vars,
-                                   ylim = axis.lim, show.ci, facet.grid, printPlot)))
+                                   ylim = axis.lim, show.ci, facet.grid, prnt.plot)))
   }
   if (type == ""eff"") {
     return(invisible(sjp.glm.eff(fit, title, geom.size, remove.estimates, vars,
                                  show.ci, ylim = axis.lim, facet.grid, fun = ""glm"", 
-                                 printPlot, ...)))
+                                 prnt.plot, ...)))
   }
   if (type == ""pred"") {
     return(invisible(sjp.glm.predy(fit, vars, t.title = title, l.title = legend.title,
                                    geom.colors, show.ci, geom.size, ylim = axis.lim,
-                                   facet.grid, type = ""fe"", show.loess = F, printPlot)))
+                                   facet.grid, type = ""fe"", show.loess = F, prnt.plot)))
   }
   if (type == ""ma"") {
     return(invisible(sjp.glm.ma(fit)))
@@ -505,7 +505,7 @@ sjp.glm <- function(fit,
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------
-  if (printPlot) print(plotHeader)
+  if (prnt.plot) graphics::plot(plotHeader)
   # -------------------------------------
   # set proper column names
   # -------------------------------------
@@ -523,7 +523,7 @@ sjp.glm <- function(fit,
 
 #' @importFrom stats predict coef formula model.frame
 sjp.glm.slope <- function(fit, title, geom.size, remove.estimates, vars,
-                          ylim, show.ci, facet.grid, printPlot) {
+                          ylim, show.ci, facet.grid, prnt.plot) {
   # check size argument
   if (is.null(geom.size)) geom.size <- .7
   # ----------------------------
@@ -749,12 +749,12 @@ sjp.glm.slope <- function(fit, title, geom.size, remove.estimates, vars,
   # --------------------------
   # plot plots
   # --------------------------
-  if (printPlot) {
+  if (prnt.plot) {
     if (facet.grid && !is.null(plot.facet)) {
-      print(plot.facet)
+      graphics::plot(plot.facet)
     } else {
       for (i in 1:length(plot.metricpred)) {
-        print(plot.metricpred[[i]])
+        graphics::plot(plot.metricpred[[i]])
       }
     }
   }
@@ -780,7 +780,7 @@ sjp.glm.predy <- function(fit,
                           facet.grid,
                           type = ""fe"",
                           show.loess = FALSE,
-                          printPlot) {
+                          prnt.plot) {
   # -----------------------------------------------------------
   # check class of fitted model
   # -----------------------------------------------------------
@@ -961,7 +961,7 @@ sjp.glm.predy <- function(fit,
   # --------------------------
   # plot plots
   # --------------------------
-  if (printPlot) print(mp)
+  if (prnt.plot) graphics::plot(mp)
   return(structure(class = c(""sjPlot"", ""sjpglm.ppresp""),
                    list(data = mydf, plot = mp)))
 }

---FILE: R/sjPlotOddsMultiple.R---
@@ -112,7 +112,7 @@ sjp.glmm <- function(...,
                      digits = 2,
                      facet.grid = FALSE,
                      coord.flip = TRUE,
-                     printPlot = TRUE) {
+                     prnt.plot = TRUE) {
   # --------------------------------------------------------
   # retrieve list of fitted models
   # --------------------------------------------------------
@@ -407,7 +407,7 @@ sjp.glmm <- function(...,
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------
-  if (printPlot) print(plotHeader)
+  if (prnt.plot) grpahics::plot(plotHeader)
   # -------------------------------------
   # set proper column names
   # -------------------------------------

---FILE: R/sjPlotPCA.R---
@@ -18,8 +18,6 @@
 #' @param type Plot type resp. geom type. May be one of following: \code{""circle""} or \code{""tile""} 
 #'          circular or tiled geoms, or \code{""bar""} for a bar plot. You may use initial letter only
 #'          for this argument.
-#' @param printPlot If \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
-#'          want to plot any graphs. In either case, the ggplot-object will be returned as value.
 #' @return (Invisibly) returns a \code{\link{structure}} with
 #'          \itemize{
 #'            \item the varimax-rotated factor loading matrix (\code{varim})
@@ -109,7 +107,7 @@ sjp.pca <- function(data,
                     wrap.labels = 30,
                     show.values = TRUE,
                     show.cronb = TRUE,
-                    printPlot = TRUE) {
+                    prnt.plot = TRUE) {
   # --------------------------------------------------------
   # check arguments
   # --------------------------------------------------------
@@ -358,7 +356,7 @@ sjp.pca <- function(data,
   # --------------------------------------------------------
   # print plot
   # --------------------------------------------------------
-  if (printPlot) graphics::plot(heatmap)
+  if (prnt.plot) graphics::plot(heatmap)
   # --------------------------------------------------------
   # if we have a data frame, all factors which do not clearly
   # load on a specific dimension (see patameter ""fctr.load.tlrn"")

---FILE: R/sjPlotPearsonsChi2Test.R---
@@ -13,8 +13,6 @@ utils::globalVariables(c(""Row"", ""Column"", ""p.value""))
 #'                \href{https://talesofr.wordpress.com/2013/05/05/ridiculously-photogenic-factors-heatmap-with-p-values/}{Tales of R}.
 #' 
 #' @param df data frame with (dichotomous) factor variables.
-#' @param printPlot If \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
-#'          want to plot any graphs. In either case, the ggplot-object will be returned as value.
 #' @return (Insisibily) returns the ggplot-object with the complete plot (\code{plot}) as well as the data frame that
 #'           was used for setting up the ggplot-object (\code{mydf}).
 #' 
@@ -44,7 +42,7 @@ sjp.chi2 <- function(df,
                      wrap.labels = 20,
                      show.legend = FALSE,
                      legend.title = NULL,
-                     printPlot = TRUE) {
+                     prnt.plot = TRUE) {
   # --------------------------------------------------------
   # try to automatically set labels is not passed as parameter
   # --------------------------------------------------------
@@ -125,7 +123,7 @@ sjp.chi2 <- function(df,
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------
-  if (printPlot) graphics::plot(chiPlot)
+  if (prnt.plot) graphics::plot(chiPlot)
   # -------------------------------------
   # return results
   # -------------------------------------

---FILE: R/sjPlotPolynomials.R---
@@ -31,8 +31,6 @@
 #'          printed to the console.
 #' @param loessLineColor color of the loess-smoothed line. Only applies, if \code{show.loess = TRUE}.
 #' @param point.color color of the scatter plot's point. Only applies, if \code{scatter.plot = TRUE}.
-#' @param printPlot If \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
-#'          want to plot any graphs. In either case, the ggplot-object will be returned as value.
 #' @return (insisibily) returns 
 #'           \describe{
 #'            \item{\code{plot}}{the ggplot-object with the complete plot}
@@ -113,7 +111,7 @@ sjp.poly <- function(x,
                      loessLineColor = ""#808080"",
                      point.color = ""#404040"",
                      point.alpha = .2,
-                     printPlot = TRUE) {
+                     prnt.plot = TRUE) {
   # --------------------------------------------
   # check color parameter
   # --------------------------------------------
@@ -225,7 +223,7 @@ sjp.poly <- function(x,
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------
-  if (printPlot) print(polyplot)
+  if (prnt.plot) print(polyplot)
   # -------------------------------------
   # return results
   # -------------------------------------

---FILE: R/sjPlotPropTable.R---
@@ -91,42 +91,42 @@ utils::globalVariables(c(""rowname"", ""total"", ""ges"", ""prc"", ""n"", ""Count"", ""Group""
 #' @export
 sjp.xtab <- function(x,
                      grp,
-                     title = """",
-                     legend.title = NULL,
-                     weight.by = NULL,
-                     title.wtd.suffix = NULL,
                      type = c(""bar"", ""line""),
                      margin = c(""col"", ""cell"", ""row""),
-                     rev.order = FALSE,
-                     ylim = NULL,
+                     bar.pos = c(""dodge"", ""stack""),
+                     title = """",
+                     title.wtd.suffix = NULL,
+                     axis.titles = NULL,
                      axis.labels = NULL,
+                     legend.title = NULL,
                      legend.labels = NULL,
-                     vjust = ""bottom"",
-                     hjust = ""center"",
-                     y.offset = NULL,
+                     weight.by = NULL,
+                     rev.order = FALSE,
+                     show.values = TRUE,
+                     show.n = TRUE,
+                     show.prc = TRUE,
+                     show.total = TRUE,
+                     show.legend = TRUE,
+                     show.summary = FALSE,
+                     summary.pos = ""r"",
                      string.total = ""Total"",
                      wrap.title = 50,
                      wrap.labels = 15,
                      wrap.legend.title = 20,
                      wrap.legend.labels = 20,
-                     grid.breaks = 0.2,
                      geom.size = 0.7,
                      geom.spacing = 0.1,
                      geom.colors = ""Paired"",
-                     bar.pos = c(""dodge"", ""stack""),
                      dot.size = 3,
                      smooth.lines = FALSE,
+                     grid.breaks = 0.2,
                      expand.grid = FALSE,
-                     show.values = TRUE,
-                     show.n = TRUE,
-                     show.prc = TRUE,
-                     show.summary = FALSE,
-                     summary.pos = ""r"",
-                     show.total = TRUE,
-                     show.legend = TRUE,
-                     axis.titles = NULL,
+                     ylim = NULL,
+                     vjust = ""bottom"",
+                     hjust = ""center"",
+                     y.offset = NULL,
                      coord.flip = FALSE,
-                     printPlot = TRUE) {
+                     prnt.plot = TRUE) {
   # --------------------------------------------------------
   # get variable name
   # --------------------------------------------------------
@@ -146,7 +146,10 @@ sjp.xtab <- function(x,
     axisTitle.y <- NULL
   } else {
     axisTitle.x <- axis.titles[1]
-    if (length(axis.titles) > 1) axisTitle.y <- axis.titles[2]
+    if (length(axis.titles) > 1) 
+      axisTitle.y <- axis.titles[2]
+    else
+      axisTitle.y <- NULL
   }
   # --------------------------------------------------------
   # grid-expansion
@@ -461,7 +464,7 @@ sjp.xtab <- function(x,
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------
-  if (printPlot) plot(baseplot)
+  if (prnt.plot) graphics::plot(baseplot)
   # -------------------------------------
   # return results
   # -------------------------------------

---FILE: R/sjPlotScatter.R---
@@ -125,7 +125,7 @@ sjp.scatter <- function(x = NULL,
                         show.rug = FALSE,
                         show.legend = TRUE,
                         facet.grid = FALSE,
-                        printPlot = TRUE) {
+                        prnt.plot = TRUE) {
   # ------------------------
   # check if suggested packages are available
   # ------------------------
@@ -346,7 +346,7 @@ sjp.scatter <- function(x = NULL,
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------
-  if (printPlot) graphics::plot(scatter)
+  if (prnt.plot) graphics::plot(scatter)
   # -------------------------------------
   # return results
   # -------------------------------------

---FILE: R/sjPlotSetTheme.R---
@@ -173,7 +173,7 @@
 #' sjp.setTheme(theme = ""538"", geom.alpha = 0.8)
 #' library(ggplot2) # for custom base-line
 #' sjp.frq(efc$e42dep, geom.color = ""#c0392b"", expand.grid = TRUE,
-#'         printPlot = FALSE)$plot + 
+#'         prnt.plot = FALSE)$plot + 
 #'   geom_hline(yintercept = 0, size = 0.5, colour = ""black"")
 #' 
 #' # mimic R base theme

---FILE: R/sjPlotStackFrequencies.R---
@@ -89,7 +89,7 @@ sjp.stackfrq <- function(items,
                          digits = 1,
                          vjust = ""center"",
                          coord.flip = TRUE,
-                         printPlot = TRUE) {
+                         prnt.plot = TRUE) {
   # --------------------------------------------------------
   # check param. if we have a single vector instead of
   # a data frame with several items, convert vector to data frame
@@ -372,7 +372,7 @@ sjp.stackfrq <- function(items,
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------
-  if (printPlot) graphics::plot(baseplot)
+  if (prnt.plot) graphics::plot(baseplot)
   # -------------------------------------
   # return results
   # -------------------------------------

---FILE: man/adjust_plot_range.Rd---
@@ -35,7 +35,7 @@ library(sjmisc)
 data(efc)
 # show frequencies of relationship-variable and
 # retrieve plot object
-gp <- sjp.frq(efc$e15relat, printPlot = FALSE)
+gp <- sjp.frq(efc$e15relat, prnt.plot = FALSE)
 # show current plot
 plot(gp$plot)
 # show adjusted plot

---FILE: man/sjc.grpdisc.Rd---
@@ -4,7 +4,7 @@
 \alias{sjc.grpdisc}
 \title{Compute a linear discriminant analysis on classified cluster groups}
 \usage{
-sjc.grpdisc(data, groups, groupcount, clss.fit = TRUE, printPlot = TRUE)
+sjc.grpdisc(data, groups, groupcount, clss.fit = TRUE, prnt.plot = TRUE)
 }
 \arguments{
 \item{data}{\code{data.frame} with variables that should be used for the
@@ -20,9 +20,6 @@ on the elbow-criterion.}
 \item{clss.fit}{logical, if \code{TRUE} (default), a vertical line indicating the
 overall goodness of classification is added to the plot, so one can see
 whether a certain group is below or above the average classification goodness.}
-
-\item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
-want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }
 \value{
 (Invisibly) returns an object with

---FILE: man/sjc.qclus.Rd---
@@ -14,7 +14,7 @@ sjc.qclus(data, groupcount = NULL, groups = NULL, method = c(""kmeans"",
   wrap.legend.labels = 20, facet.grid = FALSE, geom.colors = ""Paired"",
   geom.size = 0.5, geom.spacing = 0.1, show.legend = TRUE,
   show.grpcnt = TRUE, legend.title = NULL, legend.labels = NULL,
-  coord.flip = FALSE, reverse.axis = FALSE, printPlot = TRUE)
+  coord.flip = FALSE, reverse.axis = FALSE, prnt.plot = TRUE)
 }
 \arguments{
 \item{data}{\code{data.frame} with variables that should be used for the
@@ -112,7 +112,7 @@ legend labels (e.g. \code{""Group 1 (n=87)""}).}
 
 \item{reverse.axis}{if \code{TRUE}, the values on the x-axis are reversed.}
 
-\item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }
 \value{

---FILE: man/sjp.aov1.Rd---
@@ -9,7 +9,7 @@ sjp.aov1(var.dep, var.grp, meansums = FALSE, title = NULL,
   axis.title = """", axis.lim = NULL, geom.colors = c(""#3366a0"", ""#aa3333""),
   geom.size = 3, wrap.title = 50, wrap.labels = 25, grid.breaks = NULL,
   show.values = TRUE, digits = 2, y.offset = 0.1, show.p = TRUE,
-  show.summary = FALSE, printPlot = TRUE)
+  show.summary = FALSE, prnt.plot = TRUE)
 }
 \arguments{
 \item{var.dep}{dependent variable. Will be used with following formula:
@@ -70,7 +70,7 @@ if df is 1), the Fisher's excact test (see \code{\link{fisher.test}}) is
 computed instead of chi-squared test. If the table's matrix is larger 
 than 2x2, Fisher's excact test with Monte Carlo simulation is computed.}
 
-\item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }
 \value{

---FILE: man/sjp.chi2.Rd---
@@ -6,7 +6,7 @@
 \usage{
 sjp.chi2(df, title = ""Pearson's Chi2-Test of Independence"",
   axis.labels = NULL, wrap.title = 50, wrap.labels = 20,
-  show.legend = FALSE, legend.title = NULL, printPlot = TRUE)
+  show.legend = FALSE, legend.title = NULL, prnt.plot = TRUE)
 }
 \arguments{
 \item{df}{data frame with (dichotomous) factor variables.}
@@ -28,7 +28,7 @@ function, a legend is added to the plot.}
 
 \item{legend.title}{character vector, used as title for the plot legend.}
 
-\item{printPlot}{If \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }
 \value{

---FILE: man/sjp.corr.Rd---
@@ -10,7 +10,7 @@ sjp.corr(data, title = NULL, axis.labels = NULL, type = c(""circle"",
   geom.colors = ""RdBu"", geom.size = 15, wrap.title = 50,
   wrap.labels = 20, show.legend = FALSE, legend.title = NULL,
   show.values = TRUE, show.p = TRUE, p.numeric = FALSE,
-  printPlot = TRUE)
+  prnt.plot = TRUE)
 }
 \arguments{
 \item{data}{matrix with correlation coefficients as returned by the 
@@ -68,7 +68,7 @@ variable labels.}
 \item{p.numeric}{logical, if \code{TRUE}, the p-values are printed 
 as numbers. If \code{FALSE} (default), asterisks are used.}
 
-\item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }
 \value{

---FILE: man/sjp.frq.Rd---
@@ -17,7 +17,7 @@ sjp.frq(var.cnt, title = """", weight.by = NULL, title.wtd.suffix = NULL,
   inner.box.dotsize = 3, normal.curve = FALSE, normal.curve.color = ""red"",
   normal.curve.size = 0.8, normal.curve.alpha = 0.4, auto.group = NULL,
   coord.flip = FALSE, vjust = ""bottom"", hjust = ""center"",
-  y.offset = NULL, printPlot = TRUE)
+  y.offset = NULL, prnt.plot = TRUE)
 }
 \arguments{
 \item{var.cnt}{vector of counts, for which frequencies or means will be plotted or printed.}
@@ -163,7 +163,7 @@ away from the center of the plot respectively.}
 \item{y.offset}{numeric, offset for text labels when their alignment is adjusted 
 to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
 
-\item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }
 \value{

---FILE: man/sjp.glm.Rd---
@@ -13,7 +13,7 @@ sjp.glm(fit, type = ""dots"", vars = NULL, group.estimates = NULL,
   show.p = TRUE, show.ci = FALSE, show.legend = FALSE,
   show.summary = FALSE, digits = 2, vline.type = 2,
   vline.color = ""grey70"", coord.flip = TRUE, y.offset = 0.15,
-  facet.grid = TRUE, printPlot = TRUE, ...)
+  facet.grid = TRUE, prnt.plot = TRUE, ...)
 }
 \arguments{
 \item{fit}{fitted generalized linear model (\code{\link{glm}}- or \code{logistf}-object).}
@@ -118,7 +118,7 @@ to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
 \item{facet.grid}{\code{TRUE} to arrange the lay out of of multiple plots 
 in a grid of an integrated single plot.}
 
-\item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 
 \item{...}{other arguments, passed down to the \code{\link[effects]{effect}} resp. 

---FILE: man/sjp.glmer.Rd---
@@ -12,7 +12,7 @@ sjp.glmer(fit, type = ""re"", vars = NULL, ri.nr = NULL,
   show.intercept = TRUE, string.interc = ""(Intercept)"", fade.ns = FALSE,
   ylim = NULL, digits = 2, vline.type = 2, vline.color = ""grey70"",
   facet.grid = TRUE, free.scale = FALSE, y.offset = 0.1,
-  printPlot = TRUE, ...)
+  prnt.plot = TRUE, ...)
 }
 \arguments{
 \item{fit}{a fitted model as returned by the \code{\link[lme4]{glmer}}-function.}
@@ -132,7 +132,7 @@ the grid has the same scale range.}
 \item{y.offset}{numeric, offset for text labels when their alignment is adjusted 
 to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
 
-\item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 
 \item{...}{other arguments, passed down to the \code{\link[effects]{effect}} resp. 

---FILE: man/sjp.glmm.Rd---
@@ -13,7 +13,7 @@ sjp.glmm(..., remove.estimates = NULL, title = NULL, depvar.labels = NULL,
   show.legend = TRUE, show.intercept = FALSE, show.p = TRUE,
   fade.ns = FALSE, p.shape = FALSE, vline.type = 2,
   vline.color = ""grey70"", digits = 2, facet.grid = FALSE,
-  coord.flip = TRUE, printPlot = TRUE)
+  coord.flip = TRUE, prnt.plot = TRUE)
 }
 \arguments{
 \item{...}{one or more fitted \code{glm}- or \code{glmerMod}-objects. May 
@@ -104,7 +104,7 @@ in a grid of an integrated single plot.}
 
 \item{coord.flip}{logical, if \code{TRUE}, the x and y axis are swapped.}
 
-\item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }
 \value{

---FILE: man/sjp.gpt.Rd---
@@ -11,7 +11,7 @@ sjp.gpt(x, y, groups, geom.colors = ""Set1"", geom.size = 2.5,
   wrap.title = 50, wrap.labels = 15, wrap.legend.title = 20,
   wrap.legend.labels = 20, axis.lim = NULL, grid.breaks = NULL,
   show.total = TRUE, annotate.total = TRUE, show.p = TRUE,
-  show.n = TRUE, printPlot = TRUE)
+  show.n = TRUE, prnt.plot = TRUE)
 }
 \arguments{
 \item{x}{categorical variable, where the proportion of each category in 
@@ -78,7 +78,7 @@ variable labels.}
 \item{show.n}{logical, if \code{TRUE}, adds total number of cases for each
 group or category to the labels.}
 
-\item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }
 \value{

---FILE: man/sjp.grpfrq.Rd---
@@ -17,7 +17,7 @@ sjp.grpfrq(var.cnt, var.grp, type = c(""bar"", ""dot"", ""line"", ""boxplot"",
   grid.breaks = NULL, expand.grid = FALSE, inner.box.width = 0.15,
   inner.box.dotsize = 3, smooth.lines = FALSE, emph.dots = TRUE,
   summary.pos = ""r"", facet.grid = FALSE, coord.flip = FALSE,
-  y.offset = NULL, vjust = ""bottom"", hjust = ""center"", printPlot = TRUE)
+  y.offset = NULL, vjust = ""bottom"", hjust = ""center"", prnt.plot = TRUE)
 }
 \arguments{
 \item{var.cnt}{vector of counts, for which frequencies or means will be plotted or printed.}
@@ -168,7 +168,7 @@ labels. Allowed are same values as for \code{vjust} aesthetics from
 new options like ""inward"" and ""outward"", which align text towards and 
 away from the center of the plot respectively.}
 
-\item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }
 \value{

---FILE: man/sjp.int.Rd---
@@ -13,7 +13,7 @@ sjp.int(fit, type = c(""eff"", ""cond"", ""emm""), int.term = NULL,
   geom.size = NULL, fill.color = ""grey"", fill.alpha = 0.3,
   show.values = FALSE, show.ci = FALSE, p.kr = TRUE, grid.breaks = NULL,
   xlim = NULL, ylim = NULL, y.offset = 0.07, digits = 2,
-  facet.grid = FALSE, printPlot = TRUE, ...)
+  facet.grid = FALSE, prnt.plot = TRUE, ...)
 }
 \arguments{
 \item{fit}{the fitted (generalized) linear (mixed) model object, including interaction terms. Accepted model
@@ -146,7 +146,7 @@ to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
 \item{facet.grid}{\code{TRUE} to arrange the lay out of of multiple plots 
 in a grid of an integrated single plot.}
 
-\item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 
 \item{...}{other arguments, passed down to the \code{\link[effects]{effect}} resp. 

---FILE: man/sjp.likert.Rd---
@@ -13,7 +13,7 @@ sjp.likert(items, title = NULL, legend.title = NULL, legend.labels = NULL,
   intercept.line.color = ""grey50"", reverse.colors = FALSE,
   values = ""show"", show.n = TRUE, show.legend = TRUE,
   show.prc.sign = FALSE, grid.range = 1, grid.breaks = 0.2,
-  expand.grid = TRUE, digits = 1, coord.flip = TRUE, printPlot = TRUE)
+  expand.grid = TRUE, digits = 1, coord.flip = TRUE, prnt.plot = TRUE)
 }
 \arguments{
 \item{items}{\code{data.frame} with each column representing one item.}
@@ -121,7 +121,7 @@ axes and plotting region. Default is \code{FALSE}.}
 
 \item{coord.flip}{logical, if \code{TRUE}, the x and y axis are swapped.}
 
-\item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }
 \value{

---FILE: man/sjp.lm.Rd---
@@ -14,7 +14,7 @@ sjp.lm(fit, type = ""lm"", vars = NULL, group.estimates = NULL,
   show.legend = FALSE, show.loess = FALSE, show.loess.ci = FALSE,
   show.summary = FALSE, digits = 2, vline.type = 2,
   vline.color = ""grey70"", coord.flip = TRUE, y.offset = 0.15,
-  facet.grid = TRUE, completeDiagnostic = FALSE, printPlot = TRUE, ...)
+  facet.grid = TRUE, completeDiagnostic = FALSE, prnt.plot = TRUE, ...)
 }
 \arguments{
 \item{fit}{fitted linear regression model (of class \code{\link{lm}}, \code{\link[nlme]{gls}} or \code{plm}).}
@@ -136,7 +136,7 @@ in a grid of an integrated single plot.}
 \item{completeDiagnostic}{logical, if \code{TRUE}, additional tests are performed. Default is \code{FALSE}
 Only applies if \code{type = ""ma""}.}
 
-\item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 
 \item{...}{other arguments, passed down to the \code{\link[effects]{effect}} resp. 

---FILE: man/sjp.lmer.Rd---
@@ -13,7 +13,7 @@ sjp.lmer(fit, type = ""re"", vars = NULL, ri.nr = NULL,
   show.intercept = TRUE, string.interc = ""(Intercept)"", p.kr = TRUE,
   point.alpha = 0.2, scatter.plot = TRUE, fade.ns = FALSE, ylim = NULL,
   digits = 2, vline.type = 2, vline.color = ""grey70"", facet.grid = TRUE,
-  free.scale = FALSE, y.offset = 0.1, printPlot = TRUE, ...)
+  free.scale = FALSE, y.offset = 0.1, prnt.plot = TRUE, ...)
 }
 \arguments{
 \item{fit}{a fitted model as returned by the \code{\link[lme4]{lmer}}-function.}
@@ -159,7 +159,7 @@ the grid has the same scale range.}
 \item{y.offset}{numeric, offset for text labels when their alignment is adjusted 
 to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
 
-\item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 
 \item{...}{other arguments, passed down to the \code{\link[effects]{effect}} resp. 

---FILE: man/sjp.lmm.Rd---
@@ -13,7 +13,7 @@ sjp.lmm(..., type = ""lm"", remove.estimates = NULL, title = NULL,
   show.values = TRUE, show.legend = TRUE, show.intercept = FALSE,
   show.p = TRUE, fade.ns = FALSE, p.shape = FALSE, p.kr = TRUE,
   vline.type = 2, vline.color = ""grey70"", digits = 2,
-  facet.grid = FALSE, coord.flip = TRUE, printPlot = TRUE)
+  facet.grid = FALSE, coord.flip = TRUE, prnt.plot = TRUE)
 }
 \arguments{
 \item{...}{one or more fitted \code{lm} or \code{lmerMod}-objects. May also 
@@ -109,7 +109,7 @@ in a grid of an integrated single plot.}
 
 \item{coord.flip}{logical, if \code{TRUE}, the x and y axis are swapped.}
 
-\item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }
 \value{

---FILE: man/sjp.pca.Rd---
@@ -8,7 +8,7 @@ sjp.pca(data, nmbr.fctr = NULL, fctr.load.tlrn = 0.1, plot.eigen = FALSE,
   digits = 2, title = NULL, axis.labels = NULL, type = c(""bar"",
   ""circle"", ""tile""), geom.size = 0.6, geom.colors = ""RdBu"",
   wrap.title = 50, wrap.labels = 30, show.values = TRUE,
-  show.cronb = TRUE, printPlot = TRUE)
+  show.cronb = TRUE, prnt.plot = TRUE)
 }
 \arguments{
 \item{data}{\code{data.frame} that should be used to compute a PCA, or a \code{\link{prcomp}} object.}
@@ -58,7 +58,7 @@ i.e. all variables with the highest loading for a factor are taken for the
 reliability test. The result is an alpha value for each factor dimension.
 Only applies when \code{data} is a data frame and no \code{\link{prcomp}} object.}
 
-\item{printPlot}{If \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }
 \value{

---FILE: man/sjp.poly.Rd---
@@ -8,7 +8,7 @@ sjp.poly(x, poly.term, poly.degree, poly.scale = FALSE, fun = NULL,
   axis.title = NULL, scatter.plot = TRUE, show.loess = TRUE,
   show.loess.ci = TRUE, show.p = TRUE, geom.colors = NULL,
   geom.size = 0.8, loessLineColor = ""#808080"", point.color = ""#404040"",
-  point.alpha = 0.2, printPlot = TRUE)
+  point.alpha = 0.2, prnt.plot = TRUE)
 }
 \arguments{
 \item{x}{a vector, representing the response variable of a linear (mixed) model; or
@@ -60,7 +60,7 @@ need smaller values than dot sizes.}
 
 \item{point.alpha}{alpha value of point-geoms in the scatter plots.}
 
-\item{printPlot}{If \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }
 \value{

---FILE: man/sjp.scatter.Rd---
@@ -12,7 +12,7 @@ sjp.scatter(x = NULL, y = NULL, grp = NULL, title = """",
   fit.line = FALSE, show.ci = FALSE, fitmethod = ""lm"",
   jitter.dots = FALSE, emph.dots = FALSE, auto.jitter = TRUE,
   jitter.ratio = 0.15, show.rug = FALSE, show.legend = TRUE,
-  facet.grid = FALSE, printPlot = TRUE)
+  facet.grid = FALSE, prnt.plot = TRUE)
 }
 \arguments{
 \item{x}{vector indicating the x positions. If not specified (i.e. if
@@ -103,7 +103,7 @@ function, a legend is added to the plot.}
 \item{facet.grid}{\code{TRUE} to arrange the lay out of of multiple plots 
 in a grid of an integrated single plot.}
 
-\item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }
 \value{

---FILE: man/sjp.setTheme.Rd---
@@ -259,7 +259,7 @@ sjp.frq(efc$e42dep)
 sjp.setTheme(theme = ""538"", geom.alpha = 0.8)
 library(ggplot2) # for custom base-line
 sjp.frq(efc$e42dep, geom.color = ""#c0392b"", expand.grid = TRUE,
-        printPlot = FALSE)$plot + 
+        prnt.plot = FALSE)$plot + 
   geom_hline(yintercept = 0, size = 0.5, colour = ""black"")
 
 # mimic R base theme

---FILE: man/sjp.stackfrq.Rd---
@@ -11,7 +11,7 @@ sjp.stackfrq(items, title = NULL, legend.title = NULL,
   geom.colors = ""Blues"", show.values = TRUE, show.n = TRUE,
   show.prc = TRUE, show.legend = TRUE, grid.breaks = 0.2,
   expand.grid = FALSE, digits = 1, vjust = ""center"", coord.flip = TRUE,
-  printPlot = TRUE)
+  prnt.plot = TRUE)
 }
 \arguments{
 \item{items}{\code{data.frame} with each column representing one item.}
@@ -87,7 +87,7 @@ away from the center of the plot respectively.}
 
 \item{coord.flip}{logical, if \code{TRUE}, the x and y axis are swapped.}
 
-\item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }
 \value{

---FILE: man/sjp.xtab.Rd---
@@ -4,38 +4,25 @@
 \alias{sjp.xtab}
 \title{Plot contingency tables}
 \usage{
-sjp.xtab(x, grp, title = """", legend.title = NULL, weight.by = NULL,
-  title.wtd.suffix = NULL, type = c(""bar"", ""line""), margin = c(""col"",
-  ""cell"", ""row""), rev.order = FALSE, ylim = NULL, axis.labels = NULL,
-  legend.labels = NULL, vjust = ""bottom"", hjust = ""center"",
-  y.offset = NULL, string.total = ""Total"", wrap.title = 50,
-  wrap.labels = 15, wrap.legend.title = 20, wrap.legend.labels = 20,
-  grid.breaks = 0.2, geom.size = 0.7, geom.spacing = 0.1,
-  geom.colors = ""Paired"", bar.pos = c(""dodge"", ""stack""), dot.size = 3,
-  smooth.lines = FALSE, expand.grid = FALSE, show.values = TRUE,
-  show.n = TRUE, show.prc = TRUE, show.summary = FALSE,
-  summary.pos = ""r"", show.total = TRUE, show.legend = TRUE,
-  axis.titles = NULL, coord.flip = FALSE, printPlot = TRUE)
+sjp.xtab(x, grp, type = c(""bar"", ""line""), margin = c(""col"", ""cell"", ""row""),
+  bar.pos = c(""dodge"", ""stack""), title = """", title.wtd.suffix = NULL,
+  axis.titles = NULL, axis.labels = NULL, legend.title = NULL,
+  legend.labels = NULL, weight.by = NULL, rev.order = FALSE,
+  show.values = TRUE, show.n = TRUE, show.prc = TRUE, show.total = TRUE,
+  show.legend = TRUE, show.summary = FALSE, summary.pos = ""r"",
+  string.total = ""Total"", wrap.title = 50, wrap.labels = 15,
+  wrap.legend.title = 20, wrap.legend.labels = 20, geom.size = 0.7,
+  geom.spacing = 0.1, geom.colors = ""Paired"", dot.size = 3,
+  smooth.lines = FALSE, grid.breaks = 0.2, expand.grid = FALSE,
+  ylim = NULL, vjust = ""bottom"", hjust = ""center"", y.offset = NULL,
+  coord.flip = FALSE, prnt.plot = TRUE)
 }
 \arguments{
 \item{x}{a vector of values (variable) describing the bars which make up the plot.}
 
 \item{grp}{grouping variable of same length as \code{x}, where \code{x} 
 is grouped into the categories represented by \code{grp}.}
 
-\item{title}{character vector, used as plot title. Depending on plot type and function,
-will be set automatically. If \code{title = """"}, no title is printed.}
-
-\item{legend.title}{character vector, used as title for the plot legend.}
-
-\item{weight.by}{weight factor that will be applied to weight all cases.
-Must be a vector of same length as the input vector. Default is 
-\code{NULL}, so no weights are used.}
-
-\item{title.wtd.suffix}{suffix (as string) for the title, if \code{weight.by} is specified,
-e.g. \code{title.wtd.suffix="" (weighted)""}. Default is \code{NULL}, so 
-title will not have a suffix when cases are weighted.}
-
 \item{type}{plot type. may be either \code{""bar""} (default) for bar charts,
 or \code{""line""} for line diagram.}
 
@@ -44,31 +31,57 @@ calculating row percentages, \code{""col""} for column percentages and \code{""cell
 If \code{margin = ""col""}, an additional bar with the total sum of each column
 can be added to the plot (see \code{show.total}).}
 
-\item{rev.order}{logical, if \code{TRUE}, order of categories (groups) is reversed.}
+\item{bar.pos}{indicates whether bars should be positioned side-by-side (default)
+or stacked (use \code{""stack""} as argument).}
 
-\item{ylim}{numeric vector of length two, defining lower and upper axis limits
-of the y scale. By default, this argument is set to \code{NULL}, i.e. the 
-y-axis fits to the required range of the data.}
+\item{title}{character vector, used as plot title. Depending on plot type and function,
+will be set automatically. If \code{title = """"}, no title is printed.}
+
+\item{title.wtd.suffix}{suffix (as string) for the title, if \code{weight.by} is specified,
+e.g. \code{title.wtd.suffix="" (weighted)""}. Default is \code{NULL}, so 
+title will not have a suffix when cases are weighted.}
+
+\item{axis.titles}{character vector of length one or two, defining the title(s)
+for the x-axis and y-axis.}
 
 \item{axis.labels}{character vector with labels used as axis labels. Optional
 argument, since in most cases, axis labels are set automatically.}
 
+\item{legend.title}{character vector, used as title for the plot legend.}
+
 \item{legend.labels}{character vector with labels for the guide/legend.}
 
-\item{vjust}{character vector, indicating the vertical position of value 
-labels. Allowed are same values as for \code{vjust} aesthetics from 
-\code{ggplot2}: ""left"", ""center"", ""right"", ""bottom"", ""middle"", ""top"" and
-new options like ""inward"" and ""outward"", which align text towards and 
-away from the center of the plot respectively.}
+\item{weight.by}{weight factor that will be applied to weight all cases.
+Must be a vector of same length as the input vector. Default is 
+\code{NULL}, so no weights are used.}
 
-\item{hjust}{character vector, indicating the horizontal position of value 
-labels. Allowed are same values as for \code{vjust} aesthetics from 
-\code{ggplot2}: ""left"", ""center"", ""right"", ""bottom"", ""middle"", ""top"" and
-new options like ""inward"" and ""outward"", which align text towards and 
-away from the center of the plot respectively.}
+\item{rev.order}{logical, if \code{TRUE}, order of categories (groups) is reversed.}
 
-\item{y.offset}{numeric, offset for text labels when their alignment is adjusted 
-to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
+\item{show.values}{logical, whether values should be plotted or not.}
+
+\item{show.n}{logical, if \code{TRUE}, adds total number of cases for each
+group or category to the labels.}
+
+\item{show.prc}{logical, if \code{TRUE} (default), percentage values are plotted to each bar
+If \code{FALSE}, percentage values are removed.}
+
+\item{show.total}{when \code{margin = ""col""}, an additional bar 
+with the sum within each category and it's percentages will be added 
+to each category.}
+
+\item{show.legend}{logical, if \code{TRUE}, and depending on plot type and
+function, a legend is added to the plot.}
+
+\item{show.summary}{logical, if \code{TRUE} (default), a summary with chi-squared 
+statistics (see \code{\link{chisq.test}}), Cramer's V or Phi-value etc. 
+is shown. If a cell contains expected values lower than five (or lower than 10 
+if df is 1), the Fisher's excact test (see \code{\link{fisher.test}}) is 
+computed instead of chi-squared test. If the table's matrix is larger 
+than 2x2, Fisher's excact test with Monte Carlo simulation is computed.}
+
+\item{summary.pos}{position of the model summary which is printed when \code{show.summary} 
+is \code{TRUE}. Default is \code{""r""}, i.e. it's printed to the upper right corner. 
+Use \code{""l""} for upper left corner.}
 
 \item{string.total}{string for the legend label when a total-column is added. Only applies
 if \code{show.total = TRUE}. Default is \code{""Total""}.}
@@ -85,9 +98,6 @@ are displayed in one line and when a line break is inserted.}
 \item{wrap.legend.labels}{numeric, determines how many chars of the legend labels are 
 displayed in one line and when a line break is inserted.}
 
-\item{grid.breaks}{numeric; sets the distance between breaks for the axis, 
-i.e. at every \code{grid.breaks}'th position a major grid is being printed.}
-
 \item{geom.size}{size resp. width of the geoms (bar width, line thickness or point size, 
 depending on plot type and function). Note that bar and bin widths mostly 
 need smaller values than dot sizes.}
@@ -96,48 +106,38 @@ need smaller values than dot sizes.}
 
 \item{geom.colors}{user defined color for geoms. See 'Details' in \code{\link{sjp.grpfrq}}.}
 
-\item{bar.pos}{indicates whether bars should be positioned side-by-side (default)
-or stacked (use \code{""stack""} as argument).}
-
 \item{dot.size}{dot size, only applies, when argument \code{type = ""line""}.}
 
 \item{smooth.lines}{prints a smooth line curve. Only applies, when argument \code{type = ""line""}.}
 
+\item{grid.breaks}{numeric; sets the distance between breaks for the axis, 
+i.e. at every \code{grid.breaks}'th position a major grid is being printed.}
+
 \item{expand.grid}{logical, if \code{TRUE}, the plot grid is expanded, i.e. there is a small margin between
 axes and plotting region. Default is \code{FALSE}.}
 
-\item{show.values}{logical, whether values should be plotted or not.}
-
-\item{show.n}{logical, if \code{TRUE}, adds total number of cases for each
-group or category to the labels.}
-
-\item{show.prc}{logical, if \code{TRUE} (default), percentage values are plotted to each bar
-If \code{FALSE}, percentage values are removed.}
-
-\item{show.summary}{logical, if \code{TRUE} (default), a summary with chi-squared 
-statistics (see \code{\link{chisq.test}}), Cramer's V or Phi-value etc. 
-is shown. If a cell contains expected values lower than five (or lower than 10 
-if df is 1), the Fisher's excact test (see \code{\link{fisher.test}}) is 
-computed instead of chi-squared test. If the table's matrix is larger 
-than 2x2, Fisher's excact test with Monte Carlo simulation is computed.}
-
-\item{summary.pos}{position of the model summary which is printed when \code{show.summary} 
-is \code{TRUE}. Default is \code{""r""}, i.e. it's printed to the upper right corner. 
-Use \code{""l""} for upper left corner.}
+\item{ylim}{numeric vector of length two, defining lower and upper axis limits
+of the y scale. By default, this argument is set to \code{NULL}, i.e. the 
+y-axis fits to the required range of the data.}
 
-\item{show.total}{when \code{margin = ""col""}, an additional bar 
-with the sum within each category and it's percentages will be added 
-to each category.}
+\item{vjust}{character vector, indicating the vertical position of value 
+labels. Allowed are same values as for \code{vjust} aesthetics from 
+\code{ggplot2}: ""left"", ""center"", ""right"", ""bottom"", ""middle"", ""top"" and
+new options like ""inward"" and ""outward"", which align text towards and 
+away from the center of the plot respectively.}
 
-\item{show.legend}{logical, if \code{TRUE}, and depending on plot type and
-function, a legend is added to the plot.}
+\item{hjust}{character vector, indicating the horizontal position of value 
+labels. Allowed are same values as for \code{vjust} aesthetics from 
+\code{ggplot2}: ""left"", ""center"", ""right"", ""bottom"", ""middle"", ""top"" and
+new options like ""inward"" and ""outward"", which align text towards and 
+away from the center of the plot respectively.}
 
-\item{axis.titles}{character vector of length one or two, defining the title(s)
-for the x-axis and y-axis.}
+\item{y.offset}{numeric, offset for text labels when their alignment is adjusted 
+to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
 
 \item{coord.flip}{logical, if \code{TRUE}, the x and y axis are swapped.}
 
-\item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
+\item{prnt.plot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }
 \value{"
strengejacke,sjPlot,2667d2266b8e262dde98d35d4118d1642debe77a,Daniel Ldecke,d.luedecke@uke.de,2016-05-12T18:16:37Z,Daniel Ldecke,d.luedecke@uke.de,2016-05-12T18:16:37Z,fix bug in examples,R/sjPlotGLME.R;man/sjp.glmer.Rd,False,True,True,False,4,4,8,"---FILE: R/sjPlotGLME.R---
@@ -189,7 +189,7 @@ utils::globalVariables(c(""estimate"", ""nQQ"", ""ci"", ""fixef"", ""fade"", ""conf.low"", ""
 #' sjp.glmer(fit, type = ""fe"", sort.est = TRUE)
 #'
 #' # fit glmer, with categorical predictor with more than 2 levels
-#' fit <- glmer(hi_qol ~ education + c12hour + neg_c_7 + (1|grp),
+#' fit <- glmer(hi_qol ~ sex + education + c12hour + neg_c_7 + (1|grp),
 #'              data = mydf, family = binomial(""logit""))
 #'
 #' # plot and sort fixed effects, axis labels automatically retrieved
@@ -213,7 +213,7 @@ utils::globalVariables(c(""estimate"", ""nQQ"", ""ci"", ""fixef"", ""fade"", ""conf.low"", ""
 #' sjp.glmer(fit, type = ""pred.fe"", vars = c(""neg_c_7"", ""sex""))
 #'           
 #' # non faceted, with ci           
-#' sjp.glmer(fit, type = ""pred.fe"", vars = c(""neg_c_7"", ""sex""), 
+#' sjp.glmer(fit, type = ""pred.fe"", vars = c(""neg_c_7"", ""education""), 
 #'           show.ci = TRUE, facet.grid = FALSE)
 #'
 #'                      

---FILE: man/sjp.glmer.Rd---
@@ -253,7 +253,7 @@ fit <- glmer(hi_qol ~ sex + c12hour + neg_c_7 + (1|grp),
 sjp.glmer(fit, type = ""fe"", sort.est = TRUE)
 
 # fit glmer, with categorical predictor with more than 2 levels
-fit <- glmer(hi_qol ~ education + c12hour + neg_c_7 + (1|grp),
+fit <- glmer(hi_qol ~ sex + education + c12hour + neg_c_7 + (1|grp),
              data = mydf, family = binomial(""logit""))
 
 # plot and sort fixed effects, axis labels automatically retrieved
@@ -277,7 +277,7 @@ sjp.glmer(fit, type = ""pred"", vars = ""neg_c_7"")
 sjp.glmer(fit, type = ""pred.fe"", vars = c(""neg_c_7"", ""sex""))
           
 # non faceted, with ci           
-sjp.glmer(fit, type = ""pred.fe"", vars = c(""neg_c_7"", ""sex""), 
+sjp.glmer(fit, type = ""pred.fe"", vars = c(""neg_c_7"", ""education""), 
           show.ci = TRUE, facet.grid = FALSE)
 
                      "
strengejacke,sjPlot,c924c70c028ca19f45868cbfca2be993ecd6a52b,Daniel Ldecke,d.luedecke@uke.de,2016-05-09T19:08:39Z,Daniel Ldecke,d.luedecke@uke.de,2016-05-09T19:08:39Z,"Harmonizing arguments, minor fixes",R/helpfunctions.R;R/sjPlotClusterAnalysis.R;R/sjPlotFrequencies.R;R/sjPlotGLME.R;R/sjPlotGroupFrequencies.R;R/sjPlotLikert.R;R/sjPlotLinreg.R;R/sjPlotPolynomials.R;R/sjPlotPropTable.R;R/sjPlotStackFrequencies.R;R/sjTabCorr.R;R/sjTabDataFrame.R;R/sjTabFrequencies.R;R/sjTabGrpmean.R;R/sjTabItemAnalysis.R;R/sjTabLinReg.R;R/sjTabMannWhitney.R;R/sjTabOdds.R;R/sjTabPCA.R;R/sjTabPropTable.R;R/sjTabSPSS.R;R/sjTabStackFrq.R;R/table_functions.R;man/sjc.elbow.Rd;man/sjp.frq.Rd;man/sjp.glm.Rd;man/sjp.glmer.Rd;man/sjp.grpfrq.Rd;man/sjp.likert.Rd;man/sjp.lm.Rd;man/sjp.lmer.Rd;man/sjp.poly.Rd;man/sjp.scatter.Rd;man/sjp.stackfrq.Rd;man/sjp.xtab.Rd;man/sjt.corr.Rd;man/sjt.df.Rd;man/sjt.frq.Rd;man/sjt.glm.Rd;man/sjt.glmer.Rd;man/sjt.grpmean.Rd;man/sjt.itemanalysis.Rd;man/sjt.lm.Rd;man/sjt.lmer.Rd;man/sjt.mwu.Rd;man/sjt.pca.Rd;man/sjt.stackfrq.Rd;man/sjt.xtab.Rd;man/view_df.Rd,False,True,True,False,879,1093,1972,"---FILE: R/helpfunctions.R---
@@ -100,7 +100,7 @@ print.table.summary <- function(baseplot,
 
 # display html-content in viewer pane
 # or write it to file
-out.html.table <- function(no.output, file, knitr, toWrite, useViewer) {
+out.html.table <- function(no.output, file, knitr, toWrite, use.viewer) {
   if (!no.output) {
     # -------------------------------------
     # check if we have filename specified
@@ -117,7 +117,7 @@ out.html.table <- function(no.output, file, knitr, toWrite, useViewer) {
       write(toWrite, file = htmlFile)
       # check whether we have RStudio Viewer
       viewer <- getOption(""viewer"")
-      if (useViewer && !is.null(viewer)) {
+      if (use.viewer && !is.null(viewer)) {
         viewer(htmlFile)
       } else {
         utils::browseURL(htmlFile)
@@ -249,7 +249,10 @@ create.frq.df <- function(x,
   # -------------------------------------
   if (!is.null(mydat$label)) mydat$label[is.na(mydat$label)] <- ""NA""
   suppressMessages(sjmisc::replace_na(mydat$val) <- nrow(mydat))
-  mydat$val <- sjmisc::to_value(mydat$val, keep.labels = F)
+  # save original order
+  mydat$order <- sjmisc::to_value(mydat$val, keep.labels = F)
+  # sort for x-axis
+  mydat$val <- sort(mydat$order)
   # -------------------------------------
   # wrap labels?
   # -------------------------------------

---FILE: R/sjPlotClusterAnalysis.R---
@@ -694,7 +694,6 @@ sjc.grpdisc <- function(data, groups, groupcount, showTotalCorrect = TRUE, print
 #' @param show.diff logical, if \code{TRUE}, an additional plot with the differences between 
 #'          each fusion step of the Elbow criterion calculation is shown. This plot
 #'          may help identifying the ""elbow"". Default for this argument is \code{FALSE}.
-#' @param showDiff Deprecated; use \code{show.diff} instead.
 #'          
 #' @examples
 #' # plot elbow values of mtcars dataset
@@ -706,14 +705,7 @@ sjc.grpdisc <- function(data, groups, groupcount, showTotalCorrect = TRUE, print
 #' @importFrom stats na.omit
 #' @importFrom graphics plot
 #' @export
-sjc.elbow <- function(data, steps = 15, show.diff = FALSE, showDiff = FALSE) {
-  # -----------------------------------
-  # warn, if deprecated param is used
-  # -----------------------------------
-  if (!missing(showDiff)) {
-    warning(""argument 'showDiff' is deprecated; please use 'show.diff' instead."")
-    show.diff <- showDiff
-  }
+sjc.elbow <- function(data, steps = 15, show.diff = FALSE) {
   # Prepare Data
   # listwise deletion of missing
   data <- stats::na.omit(data) 

---FILE: R/sjPlotFrequencies.R---
@@ -1,5 +1,5 @@
 # bind global variables
-utils::globalVariables(c(""val"", ""frq"", ""grp"", ""label.pos"", ""upper.ci"", ""lower.ci"", ""ia"", ""..density..""))
+utils::globalVariables(c(""val"", ""frq"", ""grp"", ""label.pos"", ""upper.ci"", ""lower.ci"", ""..density..""))
 
 
 #' @title Plot frequencies of variables
@@ -17,19 +17,11 @@ utils::globalVariables(c(""val"", ""frq"", ""grp"", ""label.pos"", ""upper.ci"", ""lower.ci
 #'         factor levels), i.e. scales / centred variables
 #'         with decimals may result in unexpected behaviour.
 #' 
-#' @param interactionVar an interaction variable which can be used for box plots. Divides the observations in 
-#'          \code{var.cnt} into sub groups indicated by \code{interactionVar}. Only 
-#'          applies when \code{type = ""boxplot""} or \code{""violin""}.
-#' @param sort.frq Determines whether categories (bars) on x-axis should be sorted 
-#'          according to the frequencies or not.  Default is \code{""none""}, so 
+#' @param sort.frq Determines whether categories should be sorted 
+#'          according to their frequencies or not. Default is \code{""none""}, so 
 #'          categories are not sorted by frequency. Use \code{""asc""} or
 #'          \code{""desc""} for sorting categories ascending or descending order.
 #' @param geom.colors user defined color for geoms, e.g. \code{geom.colors = ""#0080ff""}.
-#' @param interactionVarLabels a character vector with labels for the x-axis breaks 
-#'          when having interaction variables included. These labels replace the 
-#'          \code{axis.labels}. Only applies, when using box or violin plots
-#'          (i.e. \code{type = ""boxplot""} or \code{""violin""}) and \code{interactionVar} 
-#'          is not \code{NULL}.
 #' @param errorbar.color color of confidence interval bars (error bars). 
 #'          Only applies to \code{type = ""bar""}. In case of dot plots, error bars 
 #'          will have same colors as dots (see \code{geom.colors}).
@@ -96,18 +88,6 @@ utils::globalVariables(c(""val"", ""frq"", ""grp"", ""label.pos"", ""upper.ci"", ""lower.ci
 #'         axis.labels = ageGrpLab)
 #' 
 #' 
-#' # box plots with interaction variable
-#' # the following example is equal to the function call
-#' # sjp.grpfrq(efc$e17age, efc$e16sex, type = ""box"")
-#' sjp.frq(efc$e17age,
-#'         title = paste(get_label(efc$e17age), 
-#'                       ""by"", 
-#'                       get_label(efc$e16sex),
-#'         interactionVar = efc$e16sex,
-#'         interactionVarLabels = get_labels(efc$e16sex),
-#'         type = ""box""))
-#' 
-#' 
 #' # negative impact scale, ranging from 7-28
 #' sjp.frq(efc$neg_c_7)
 #' 
@@ -147,13 +127,11 @@ sjp.frq <- function(var.cnt,
                     title = """",
                     weight.by = NULL,
                     title.wtd.suffix = NULL,
-                    interactionVar = NULL,
-                    sort.frq = ""none"",
+                    sort.frq = c(""none"", ""asc"", ""desc""),
                     type = c(""bar"", ""dot"", ""histogram"", ""line"", ""density"", ""boxplot"", ""violin""),
                     geom.size = NULL,
                     geom.colors = ""#336699"",
                     axis.labels = NULL,
-                    interactionVarLabels = NULL,
                     xlim = NULL,
                     ylim = NULL,
                     wrap.title = 50,
@@ -183,7 +161,7 @@ sjp.frq <- function(var.cnt,
                     vjust = ""bottom"",
                     hjust = ""center"",
                     y.offset = NULL,
-                    na.rm = TRUE,
+                    show.na = FALSE,
                     printPlot = TRUE) {
   # --------------------------------------------------------
   # get variable name
@@ -219,20 +197,8 @@ sjp.frq <- function(var.cnt,
   # try to automatically set labels is not passed as argument
   # --------------------------------------------------------
   if (is.null(axis.labels)) {
-    axis.labels <- sjmisc::get_labels(
-      var.cnt,
-      attr.only = F,
-      include.values = NULL,
-      include.non.labelled = T
-    )
-  }
-  if (is.null(interactionVarLabels) && !is.null(interactionVar)) {
-    interactionVarLabels <- sjmisc::get_labels(
-      interactionVar,
-      attr.only = F,
-      include.values = NULL,
-      include.non.labelled = T
-    )
+    axis.labels <- sjmisc::get_labels(var.cnt, attr.only = F, include.values = NULL, 
+                                      include.non.labelled = T)
   }
   if (is.null(axis.title)) axis.title <- sjmisc::get_label(var.cnt, def.value = var.name)
   if (is.null(title)) title <- sjmisc::get_label(var.cnt, def.value = var.name)
@@ -246,10 +212,11 @@ sjp.frq <- function(var.cnt,
   # --------------------------------------------------------
   if (length(geom.colors) > 1) geom.colors <- geom.colors[1]
   # --------------------------------------------------------
-  # We have several options to name the plot type
-  # Here we will reduce it to a unique value
+  # Match arguments
   # --------------------------------------------------------
   type <- match.arg(type)
+  sort.frq <- match.arg(sort.frq)
+  # default grid-expansion
   if (isTRUE(expand.grid) || (missing(expand.grid) && type == ""histogram"")) {
     expand.grid <- ggplot2::waiver()
   } else {
@@ -277,13 +244,6 @@ sjp.frq <- function(var.cnt,
   #---------------------------------------------------
   # check whether variable should be auto-grouped
   #---------------------------------------------------
-  if (!is.null(interactionVar) && type != ""boxplot"" && type != ""violin"") {
-    warning(""`interactionVar` only applies to boxplots and violinplots (see `type`) and will be ignored."", call. = F)
-    interactionVar <- NULL
-  }
-  #---------------------------------------------------
-  # check whether variable should be auto-grouped
-  #---------------------------------------------------
   if (!is.null(auto.group) && length(unique(var.cnt)) >= auto.group) {
     message(sprintf(""`%s` has %i unique values and was grouped..."", 
                     var.name, 
@@ -309,10 +269,15 @@ sjp.frq <- function(var.cnt,
                           wrap.labels = wrap.labels, 
                           order.frq = sort.frq, 
                           round.prz = 2,
-                          na.rm = na.rm, 
+                          na.rm = !show.na, 
                           weight.by = weight.by)
   mydat <- df.frq$mydat
-  if (!is.null(df.frq$labels) && is.null(axis.labels)) axis.labels <- df.frq$labels
+  # any labels detected?
+  if (!is.null(df.frq$labels) && is.null(axis.labels)) 
+    axis.labels <- df.frq$labels
+  else if (!is.null(axis.labels) && sort.frq != ""none"")
+    # sort labels in required order
+    axis.labels <- axis.labels[mydat$order]
   # --------------------------------------------------------
   # define text label position
   # --------------------------------------------------------
@@ -337,18 +302,6 @@ sjp.frq <- function(var.cnt,
   if (!is.null(axis.title)) {
     axis.title <- sjmisc::word_wrap(axis.title, wrap.title)    
   }
-  # check length of x-axis-labels of interaction variable and split 
-  # longer strings into new lines
-  if (!is.null(interactionVar)) {
-    if (!is.null(interactionVarLabels)) {
-      interactionVarLabels <- sjmisc::word_wrap(interactionVarLabels, wrap.labels)    
-    # If interaction-variable-labels were not defined, simply set numbers from 1 to
-    # amount of categories instead
-    } else {
-      iavarLabLength <- length(unique(stats::na.omit(interactionVar)))
-      interactionVarLabels <- c(1:iavarLabLength)
-    }
-  }
   # --------------------------------------------------------
   # count variable may not be a factor!
   # --------------------------------------------------------
@@ -369,17 +322,9 @@ sjp.frq <- function(var.cnt,
   # If we have boxplots, use different data frame structure
   # --------------------------------------------------------
   if (type == ""boxplot"" || type == ""violin"") {
-    if (is.null(interactionVar)) {
-      mydat <- stats::na.omit(data.frame(cbind(grp = 1, 
-                                               frq = var.cnt, 
-                                               val = var.cnt)))
-    } else {
-      mydat <- stats::na.omit(data.frame(cbind(grp = 1, 
-                                               ia = interactionVar, 
-                                               frq = var.cnt, 
-                                               val = var.cnt)))
-      mydat$ia <- as.factor(mydat$ia)
-    }
+    mydat <- stats::na.omit(data.frame(cbind(grp = 1, 
+                                             frq = var.cnt, 
+                                             val = var.cnt)))
     mydat$grp <- as.factor(mydat$grp)
   }  
   # --------------------------------------------------------
@@ -488,11 +433,6 @@ sjp.frq <- function(var.cnt,
   # ----------------------------------
   # Print plot
   # ----------------------------------
-  # calculate mean and sd for non-adjusted normal curve
-  stdmean <- diff(range(var.cnt, na.rm = TRUE)) / 2
-  stdadjust <- min(var.cnt, na.rm = TRUE)
-  stdsd <- stdmean / 4
-  stdlen <- length(stats::na.omit(var.cnt))
   # ----------------------------------
   # bar and dot plot start here!
   # ----------------------------------
@@ -537,13 +477,10 @@ sjp.frq <- function(var.cnt,
   # Start box plot here
   # --------------------------------------------------
   } else if (type == ""boxplot"" || type == ""violin"") {
-    if (is.null(interactionVar)) {
-      baseplot <- ggplot(mydat, aes(x = grp, y = frq))
-      scalex <- scale_x_discrete(labels = """")
-    } else {
-      baseplot <- ggplot(mydat, aes(x = interaction(ia, grp), y = frq))
-      scalex <- scale_x_discrete(labels = interactionVarLabels)
-    }
+    # setup base plot
+    baseplot <- ggplot(mydat, aes(x = grp, y = frq))
+    # and x-axis
+    scalex <- scale_x_discrete(labels = """")
     if (type == ""boxplot"") {
       baseplot <- baseplot + 
         geom_boxplot(width = geom.size, fill = geom.colors)
@@ -684,7 +621,7 @@ sjp.frq <- function(var.cnt,
       yscale
   }
   # set axes text and 
-  baseplot <- baseplot + labs(title = title, x = axis.title)
+  baseplot <- baseplot + labs(title = title, x = axis.title, y = NULL)
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------

---FILE: R/sjPlotGLME.R---
@@ -1,5 +1,5 @@
 # bind global variables
-utils::globalVariables(c(""estimate"", ""nQQ"", ""ci"", ""fixef"", ""fade"", ""conf.low"", ""conf.high"", ""pred"", ""prob"", ""p.string"", ""CSS"", ""useViewer"", ""no.output""))
+utils::globalVariables(c(""estimate"", ""nQQ"", ""ci"", ""fixef"", ""fade"", ""conf.low"", ""conf.high"", ""pred"", ""prob"", ""p.string"", ""CSS"", ""no.output""))
 
 
 #' @title Plot estimates, predictions or effects of generalized linear mixed effects models
@@ -372,8 +372,7 @@ sjp.glmer <- function(fit,
 #'            \item{\code{""poly""}}{to plot predicted values (marginal effects) of polynomial terms in \code{fit}. Use \code{poly.term} to specify the polynomial term in the fitted model (see 'Examples' here and 'Details' of \code{\link{sjp.lm}}).}
 #'            \item{\code{""ma""}}{to check model assumptions. Note that no further arguments except \code{fit} are relevant for this option. All other arguments are ignored.}
 #'          }
-#' @param pointAlpha alpha value of point-geoms in the scatter plots.
-#'          Default is 0.2.
+#' @param point.alpha alpha value of point-geoms in the scatter plots.
 #' @param show.loess logical, if \code{TRUE}, and depending on \code{type}, an 
 #'          additional loess-smoothed line is plotted.
 #' @param show.loess.ci logical, if \code{TRUE}, a confidence region for the loess-smoothed line
@@ -542,7 +541,7 @@ sjp.lmer <- function(fit,
                      fade.ns = FALSE,
                      show.ci = FALSE,
                      p.kr = TRUE,
-                     pointAlpha = 0.2,
+                     point.alpha = 0.2,
                      scatter.plot = TRUE,
                      show.loess = FALSE,
                      show.loess.ci = FALSE,
@@ -588,7 +587,7 @@ sjp.lmer <- function(fit,
            p.kr,
            printPlot,
            fun = ""lm"",
-           pointAlpha,
+           point.alpha,
            scatter.plot,
            show.loess,
            show.loess.ci,
@@ -625,7 +624,7 @@ sjp.lme4  <- function(fit,
                       p.kr,
                       printPlot,
                       fun,
-                      pointAlpha = 0.2,
+                      point.alpha = 0.2,
                       scatter.plot = TRUE,
                       show.loess = FALSE,
                       show.loess.ci = FALSE,
@@ -773,7 +772,7 @@ sjp.lme4  <- function(fit,
     if (fun == ""lm"") {
       # reset default color setting, does not look that good.
       if (geom.colors == ""Set1"") geom.colors <- NULL
-      return(invisible(sjp.reglin(fit, title, 50, geom.colors, show.ci, pointAlpha,
+      return(invisible(sjp.reglin(fit, title, 50, geom.colors, show.ci, point.alpha,
                                   scatter.plot, show.loess, show.loess.ci, 
                                   useResiduals = ifelse(type == ""fe.slope"", FALSE, TRUE),
                                   remove.estimates, vars, printPlot)))
@@ -1896,7 +1895,7 @@ sjp.lme.fecor <- function(fit,
                           printPlot,
                           fcall = ""sjp"",
                           CSS = NULL,
-                          useViewer = TRUE,
+                          use.viewer = TRUE,
                           no.output = TRUE) {
   # ---------------------------------------
   # copy rownames as axis labels, if not set
@@ -1929,7 +1928,7 @@ sjp.lme.fecor <- function(fit,
     corret <- sjt.corr(as.matrix(mydf),
                        triangle = ""l"",
                        CSS = CSS,
-                       useViewer = useViewer,
+                       use.viewer = use.viewer,
                        no.output = no.output)
   }
   return(invisible(structure(class = ifelse(fun == ""glm"", ""sjpglmer.cor"", ""sjplmer.cor""),

---FILE: R/sjPlotGroupFrequencies.R---
@@ -114,7 +114,8 @@ utils::globalVariables(c(""."", ""label"", ""prz"", ""frq"", ""ypos"", ""wb"", ""ia"", ""mw"", ""
 #'          away from the center of the plot respectively.
 #' @param y.offset numeric, offset for text labels when their alignment is adjusted 
 #'          to the top/bottom of the geom (see \code{hjust} and \code{vjust}).
-#' @param na.rm logical, if \code{TRUE}, missings are not included in the frequency plot.
+#' @param show.na logical, if \code{TRUE}, \code{\link{NA}}'s (missing values)
+#'          are added to the output.
 #' @param printPlot logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 #'          want to plot any graphs. In either case, the ggplot-object will be returned as value.
 #' @return (Insisibily) returns the ggplot-object with the complete plot (\code{plot}) as well as the data frame that
@@ -198,7 +199,7 @@ sjp.grpfrq <- function(var.cnt,
                        vjust = ""bottom"",
                        hjust = ""center"",
                        y.offset = NULL,
-                       na.rm = TRUE,
+                       show.na = FALSE,
                        printPlot = TRUE) {
   # --------------------------------------------------------
   # get variable name
@@ -308,7 +309,7 @@ sjp.grpfrq <- function(var.cnt,
   # --------------------------------------------------------
   # create cross table of frequencies and percentages
   # --------------------------------------------------------
-  mydat <- create.xtab.df(grp.var.cnt, var.grp, round.prz = 2, na.rm = na.rm,
+  mydat <- create.xtab.df(grp.var.cnt, var.grp, round.prz = 2, na.rm = !show.na,
                           weight.by = weight.by)
   # --------------------------------------------------------
   # x-position as numeric factor, added later after
@@ -482,7 +483,7 @@ sjp.grpfrq <- function(var.cnt,
   # add group counts to category labels
   # --------------------------------------------------------
   if (showGroupCount) {
-    nas <- ifelse(isTRUE(na.rm), ""ifany"", ""no"")
+    nas <- ifelse(isTRUE(show.na), ""ifany"", ""no"")
     # check whether we have interaction variables or not
     if (!is.null(interactionVarLabels)) {
       # retrieve group counts by converting data column

---FILE: R/sjPlotLikert.R---
@@ -43,21 +43,19 @@ utils::globalVariables(c(""offset""))
 #'          so positive and negative values switch colors.
 #' @param cat.neutral.color color of the neutral category, if plotted (see \code{cat.neutral}).
 #' @param intercept.line.color color of the vertical intercept line that divides positive and negative values.
-#' @param includeN logical, if \code{TRUE} (default), the N of each item will be included in axis labels.
 #' @param value.labels determines style and position of percentage value labels on the bars:
 #'          \describe{
 #'            \item{\code{""show""}}{(default) shows percentage value labels in the middle of each category bar}
 #'            \item{\code{""hide""}}{hides the value labels, so no percentage values on the bars are printed}
 #'            \item{\code{""sum.inside""}}{shows the sums of percentage values for both negative and positive values and prints them inside the end of each bar}
 #'            \item{\code{""sum.outide""}}{shows the sums of percentage values for both negative and positive values and prints them outside the end of each bar}
 #'          }
-#' @param showPercentageSign logical, if \code{TRUE}, \%-signs for value labels are shown.
-#' @param showItemLabels logical, whether x-axis text (category names) should be shown or not
-#' @param gridRange numeric, limits of the x-axis-range, as proportion of 100. 
+#' @param show.prc.sign logical, if \code{TRUE}, \%-signs for value labels are shown.
+#' @param grid.range numeric, limits of the x-axis-range, as proportion of 100. 
 #'          Default is 1, so the x-scale ranges from zero to 100\% on 
 #'          both sides from the center. You can use values beyond 1
 #'          (100\%) in case bar labels are not printed because they exceed the axis range.
-#'          E.g. \code{gridRange = 1.4} will set the axis from -140 to +140\%, however, only
+#'          E.g. \code{grid.range = 1.4} will set the axis from -140 to +140\%, however, only
 #'          (valid) axis labels from -100 to +100\% are printed. Neutral categories are
 #'          adjusted to the most left limit.
 #' 
@@ -127,10 +125,10 @@ utils::globalVariables(c(""offset""))
 #'            cat.neutral = 5,
 #'            legend.labels = levels_4, 
 #'            axis.labels = items,
-#'            gridRange = 1.2,
+#'            grid.range = 1.2,
 #'            expand.grid = FALSE,
 #'            value.labels = ""sum.outside"",
-#'            showPercentageSign = TRUE)
+#'            show.prc.sign = TRUE)
 #' 
 #' # plot 6-category-likert-scale, ordered by positive values,
 #' # in brown color scale
@@ -139,7 +137,7 @@ utils::globalVariables(c(""offset""))
 #'            axis.labels = items, 
 #'            sort.frq = ""pos.asc"", 
 #'            digits = 0,
-#'            showPercentageSign = TRUE,
+#'            show.prc.sign = TRUE,
 #'            value.labels = ""sum.inside"")
 #' 
 #' @import ggplot2
@@ -158,20 +156,19 @@ sjp.likert <- function(items,
                        cat.neutral.color = ""grey70"",
                        intercept.line.color = ""grey50"",
                        value.labels = ""show"",
-                       showPercentageSign = FALSE,
+                       show.prc.sign = FALSE,
                        digits = 1,
                        legend.labels = NULL,
                        show.legend = TRUE,
                        title = NULL, 
                        legend.title = NULL,
-                       includeN = TRUE,
-                       showItemLabels = TRUE,
+                       include.n = TRUE,
                        axis.labels = NULL,
                        wrap.title = 50, 
                        wrap.labels = 30, 
                        breakLegendTitleAt = 30, 
                        breakLegendLabelsAt = 28,
-                       gridRange = 1,
+                       grid.range = 1,
                        grid.breaks = 0.2,
                        expand.grid = TRUE,
                        axis.titles = NULL,
@@ -367,7 +364,7 @@ sjp.likert <- function(items,
   # Check whether N of each item should be included into
   # axis labels
   # --------------------------------------------------------
-  if (includeN && !is.null(axis.labels)) {
+  if (include.n) {
     for (i in 1:length(axis.labels)) {
       axis.labels[i] <- paste(axis.labels[i], 
                                sprintf("" (n=%i)"", length(stats::na.omit(items[[i]]))), 
@@ -450,7 +447,7 @@ sjp.likert <- function(items,
                                             frq = -1 + fr[catcount + adding],
                                             ypos = -1 + (fr[catcount + adding] / 2),
                                             ypos2 = -1 + fr[catcount + adding],
-                                            offset = -1 * gridRange)))
+                                            offset = -1 * grid.range)))
       # cumulative neutral cat
       ypos.sum.dk <- c(ypos.sum.dk, -1 + fr[catcount + adding])
     }
@@ -494,11 +491,13 @@ sjp.likert <- function(items,
     }
     title <- sjmisc::word_wrap(title, wrap.title)
   }
+  # --------------------------------------------------------
   # check length of x-axis-labels and split longer strings at into new lines
   # every 10 chars, so labels don't overlap
-  if (!is.null(axis.labels)) {
-    axis.labels <- sjmisc::word_wrap(axis.labels, wrap.labels)
-  }
+  # --------------------------------------------------------
+  axis.labels <- sjmisc::word_wrap(axis.labels, wrap.labels)
+  # sort labels
+  axis.labels <- axis.labels[sort.freq]
   # --------------------------------------------------------
   # set diagram margins
   # --------------------------------------------------------
@@ -508,17 +507,9 @@ sjp.likert <- function(items,
     expgrid <- c(0, 0)
   }
   # --------------------------------------------------------
-  # Hide or show Category Labels (x axis text) 
-  # --------------------------------------------------------
-  if (!showItemLabels) {
-    axis.labels <- """"
-  } else {
-    axis.labels <- axis.labels[sort.freq]
-  }
-  # --------------------------------------------------------
   # Set up grid breaks
   # --------------------------------------------------------
-  gridbreaks <- round(c(seq(-gridRange, gridRange, by = grid.breaks)), 2)
+  gridbreaks <- round(c(seq(-grid.range, grid.range, by = grid.breaks)), 2)
   gridlabs <- ifelse(abs(gridbreaks) > 1, """", paste0(c(abs(round(100 * gridbreaks))), ""%""))
   # --------------------------------------------------------
   # start plot here
@@ -555,7 +546,7 @@ sjp.likert <- function(items,
   # --------------------------------------------------------
   # should percentage value labels be printed?
   # --------------------------------------------------------
-  percsign <- mydat.pos$percsign <- mydat.neg$percsign <- ifelse(isTRUE(showPercentageSign), ""%"", """")
+  percsign <- mydat.pos$percsign <- mydat.neg$percsign <- ifelse(isTRUE(show.prc.sign), ""%"", """")
   if (nrow(mydat.dk) > 0) mydat.dk$percsign <- percsign
   # --------------------------------------------------------
   # creating value labels for cumulative percentages, so
@@ -593,7 +584,7 @@ sjp.likert <- function(items,
       annotate(""text"", x = xpos.sum.neg, y = ypos.sum.neg, hjust = hort.neg, label = ypos.sum.neg.lab)
     if (!is.null(cat.neutral)) {
       gp <- gp +
-        annotate(""text"", x = xpos.sum.dk, y = ypos.sum.dk + 1 - gridRange, hjust = hort.dk, label = ypos.sum.dk.lab)
+        annotate(""text"", x = xpos.sum.dk, y = ypos.sum.dk + 1 - grid.range, hjust = hort.dk, label = ypos.sum.dk.lab)
     }
   }
   # ---------------------------------------------------------
@@ -606,7 +597,7 @@ sjp.likert <- function(items,
     # for neutral category work...
     # ---------------------------------------------------------
     scale_x_continuous(breaks = c(1:ncol(freq.df)), labels = axis.labels) +
-    scale_y_continuous(breaks = gridbreaks, limits = c(-gridRange, gridRange), expand = expgrid, labels = gridlabs) +
+    scale_y_continuous(breaks = gridbreaks, limits = c(-grid.range, grid.range), expand = expgrid, labels = gridlabs) +
     geom_hline(yintercept = 0, color = intercept.line.color)
   # ---------------------------------------------------------
   # check whether coordinates should be flipped, i.e.

---FILE: R/sjPlotLinreg.R---
@@ -102,7 +102,7 @@ utils::globalVariables(c(""fit"", ""vars"", ""Beta"", ""xv"", ""lower"", ""upper"", ""stdbeta
 #'          variable labels.
 #' @param show.summary logical, if \code{TRUE}, a summary with model statistics 
 #'          is added to the plot.
-#' @param show.ci logical, if \code{TRUE}, depending on \code{type}, a condifence
+#' @param show.ci logical, if \code{TRUE}, depending on \code{type}, a confidence
 #'          interval or region is added to the plot.
 #' @param scatter.plot logical, if \code{TRUE} (default), a scatter plot of
 #'          response and predictor values for each predictor of the model
@@ -285,7 +285,7 @@ sjp.lm <- function(fit,
                    show.p = TRUE,
                    show.summary = FALSE,
                    show.ci = TRUE,
-                   pointAlpha = 0.2,
+                   point.alpha = 0.2,
                    scatter.plot = TRUE,
                    show.loess = FALSE,
                    show.loess.ci = FALSE,
@@ -328,7 +328,7 @@ sjp.lm <- function(fit,
     # reset default color setting, does not look that good.
     if (geom.colors == ""Set1"") geom.colors <- NULL
     return(invisible(sjp.lm1(fit, title, wrap.title, axis.labels, resp.label,
-                             wrap.labels, geom.colors, show.ci, pointAlpha,
+                             wrap.labels, geom.colors, show.ci, point.alpha,
                              scatter.plot, show.loess, show.loess.ci, show.summary,
                              useResiduals = ifelse(type == ""lm"", FALSE, TRUE),
                              printPlot)))
@@ -337,7 +337,7 @@ sjp.lm <- function(fit,
     # reset default color setting, does not look that good.
     if (geom.colors == ""Set1"") geom.colors <- NULL
     return(invisible(sjp.reglin(fit, title, wrap.title, geom.colors, show.ci,
-                                pointAlpha, scatter.plot, show.loess, show.loess.ci,
+                                point.alpha, scatter.plot, show.loess, show.loess.ci,
                                 useResiduals = ifelse(type == ""slope"", FALSE, TRUE),
                                 remove.estimates, vars, printPlot)))
   }
@@ -609,7 +609,7 @@ sjp.reglin <- function(fit,
                        wrap.title = 50, 
                        geom.colors = NULL,
                        show.ci = TRUE,
-                       pointAlpha = 0.2,
+                       point.alpha = 0.2,
                        scatter.plot = TRUE,
                        show.loess = TRUE,
                        show.loess.ci = FALSE,
@@ -698,8 +698,8 @@ sjp.reglin <- function(fit,
     # -----------------------------------------------------------
     # plot jittered values if requested
     # -----------------------------------------------------------
-    if (scatter.plot) reglinplot <- reglinplot + geom_jitter(alpha = pointAlpha,
-                                                                colour = pointColor)
+    if (scatter.plot) reglinplot <- reglinplot + geom_jitter(alpha = point.alpha,
+                                                             colour = pointColor)
     # -----------------------------------------------------------
     # check whether additional loess-line should be plotted
     # -----------------------------------------------------------
@@ -1089,7 +1089,7 @@ sjp.lm1 <- function(fit,
                    wrap.labels=20,
                    geom.colors = NULL,
                    show.ci=TRUE,
-                   pointAlpha=0.2,
+                   point.alpha=0.2,
                    scatter.plot=TRUE,
                    show.loess=FALSE,
                    show.loess.ci=FALSE,
@@ -1183,7 +1183,7 @@ sjp.lm1 <- function(fit,
   # plot jittered values if requested
   # -----------------------------------------------------------
   if (scatter.plot) {
-    reglinplot <- reglinplot + geom_jitter(alpha = pointAlpha,
+    reglinplot <- reglinplot + geom_jitter(alpha = point.alpha,
                                            colour = pointColor)
   }
   # -----------------------------------------------------------

---FILE: R/sjPlotPolynomials.R---
@@ -30,8 +30,7 @@
 #' @param show.p logical, if \code{TRUE} (default), p-values for polynomial terms are
 #'          printed to the console.
 #' @param loessLineColor color of the loess-smoothed line. Only applies, if \code{show.loess = TRUE}.
-#' @param pointColor color of the scatter plot's point. Only applies, if \code{scatter.plot = TRUE}.
-#' @param pointAlpha The alpha values of the scatter plot's point-geoms. Default is 0.2.
+#' @param point.color color of the scatter plot's point. Only applies, if \code{scatter.plot = TRUE}.
 #' @param printPlot If \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 #'          want to plot any graphs. In either case, the ggplot-object will be returned as value.
 #' @return (insisibily) returns 
@@ -116,8 +115,8 @@ sjp.poly <- function(x,
                      geom.colors = NULL,
                      geom.size = .8,
                      loessLineColor = ""#808080"",
-                     pointColor = ""#404040"",
-                     pointAlpha = .2,
+                     point.color = ""#404040"",
+                     point.alpha = .2,
                      printPlot = TRUE) {
   # --------------------------------------------
   # check color parameter
@@ -215,7 +214,7 @@ sjp.poly <- function(x,
   # create plot
   polyplot <- ggplot(plot.df, aes(x, y, colour = grp))
   # show scatter plot as well?
-  if (scatter.plot) polyplot <- polyplot + geom_jitter(colour = pointColor, alpha = pointAlpha)
+  if (scatter.plot) polyplot <- polyplot + geom_jitter(colour = point.color, alpha = point.alpha)
   # show loess curve? this curve indicates the ""perfect"" curve through
   # the data
   if (show.loess) polyplot <- polyplot + stat_smooth(method = ""loess"", 

---FILE: R/sjPlotPropTable.R---
@@ -14,15 +14,15 @@ utils::globalVariables(c(""rowname"", ""total"", ""ges"", ""prc"", ""n"", ""Count"", ""Group""
 #' @param x a vector of values (variable) describing the bars which make up the plot.
 #' @param grp grouping variable of same length as \code{x}, where \code{x} 
 #'          is grouped into the categories represented by \code{grp}.
-#' @param type plot type. may be either \code{""b""}, \code{""bar""}, \code{""bars""} (default) for bar charts,
-#'          or \code{""l""}, \code{""line""}, \code{""lines""} for line diagram.
+#' @param type plot type. may be either \code{""bar""} (default) for bar charts,
+#'          or \code{""line""} for line diagram.
 #' @param tableIndex indicates which data of the proportional table should be plotted. Use \code{""row""} for
 #'          calculating row percentages, \code{""col""} for column percentages and \code{""cell""} for cell percentages.
 #'          If \code{tableIndex = ""col""}, an additional bar with the total sum of each column
 #'          can be added to the plot (see \code{showTotalColumn}).
 #' @param rev.order logical, if \code{TRUE}, order of categories (groups) is reversed.
-#' @param lineDotSize dot size, only applies, when argument \code{type = ""lines""}.
-#' @param smoothLines prints a smooth line curve. Only applies, when argument \code{type = ""lines""}.
+#' @param lineDotSize dot size, only applies, when argument \code{type = ""line""}.
+#' @param smoothLines prints a smooth line curve. Only applies, when argument \code{type = ""line""}.
 #' @param stringTotal string for the legend label when a total-column is added. Only applies
 #'          if \code{showTotalColumn = TRUE}. Default is \code{""Total""}.
 #' @param showCategoryLabels whether x-axis text (category names) should be shown or not.
@@ -114,8 +114,8 @@ sjp.xtab <- function(x,
                      legend.title = NULL,
                      weight.by = NULL,
                      title.wtd.suffix = NULL,
-                     type = ""bars"",
-                     tableIndex = ""col"",
+                     type = c(""bar"", ""line""),
+                     tableIndex = c(""col"", ""cell"", ""row""),
                      rev.order = FALSE,
                      ylim = NULL,
                      axis.labels = NULL,
@@ -156,6 +156,8 @@ sjp.xtab <- function(x,
   # match arguments
   # --------------------------------------------------------
   bar.pos <- match.arg(bar.pos)
+  type <- match.arg(type)
+  tableIndex <- match.arg(tableIndex)
   # --------------------------------------------------------
   # copy titles
   # --------------------------------------------------------
@@ -167,12 +169,9 @@ sjp.xtab <- function(x,
     if (length(axis.titles) > 1) axisTitle.y <- axis.titles[2]
   }
   # --------------------------------------------------------
-  # We have several options to name the diagram type
-  # Here we will reduce it to a unique value
+  # grid-expansion
   # --------------------------------------------------------
-  if (type == ""b"" || type == ""bar"") type <- ""bars""
-  if (type == ""l"" || type == ""line"") type <- ""lines""
-  if (isTRUE(expand.grid)) {
+  if (expand.grid) {
     expand.grid <- ggplot2::waiver()
   } else {
     expand.grid <- c(0, 0)
@@ -382,7 +381,7 @@ sjp.xtab <- function(x,
   # --------------------------------------------------------
   # align dodged position of labels to bar positions
   # --------------------------------------------------------
-  posdodge <- ifelse(type == ""lines"", 0, geom.size + geom.spacing)
+  posdodge <- ifelse(type == ""line"", 0, geom.size + geom.spacing)
   if (!showCategoryLabels) axis.labels <- """"
   # --------------------------------------------------------
   # Set value labels
@@ -441,7 +440,7 @@ sjp.xtab <- function(x,
   # ----------------------------------
   # check whether bars or lines should be printed
   # ----------------------------------
-  if (type == ""bars"") {
+  if (type == ""bar"") {
     if (bar.pos == ""dodge"") {
       geob <- geom_bar(stat = ""identity"", 
                        position = position_dodge(posdodge), 
@@ -452,7 +451,7 @@ sjp.xtab <- function(x,
                        width = geom.size)
     }
   # check if we have lines
-  } else if (type == ""lines"") {
+  } else if (type == ""line"") {
     # for lines, numeric scale
     mydf$xpos <- sjmisc::to_value(mydf$xpos, keep.labels = F)
     line.stat <- ifelse(isTRUE(smoothLines), ""smooth"", ""identity"")
@@ -465,7 +464,7 @@ sjp.xtab <- function(x,
   # --------------------------------------------------------
   baseplot <- ggplot(mydf, aes(x = xpos, y = prc, fill = group)) + geob
   # if we have line diagram, print lines here
-  if (type == ""lines"") {
+  if (type == ""line"") {
     baseplot <- baseplot + 
       geom_point(size = lineDotSize, 
                  shape = 21, 

---FILE: R/sjPlotStackFrequencies.R---
@@ -22,16 +22,12 @@
 #'            \item{\code{""last.desc""}}{to order descending by lowest count of last category,}
 #'            \item{\code{NULL}}{(default) for no sorting.}
 #'          }
-#' @param includeN logical, if \code{TRUE} (default), the N of each item is included into axis labels.
+#' @param include.n logical, if \code{TRUE} (default), the N of each item will be included in axis labels.
 #' @param breakLegendTitleAt determines how many chars of the legend's title 
 #'          are displayed in one line and when a line break is inserted.
 #' @param breakLegendLabelsAt determines how many chars of the legend labels are 
 #'          displayed in one line and when a line break is inserted.
 #' @param showPercentageAxis If \code{TRUE} (default), the percentage values at the x-axis are shown.
-#' @param showItemLabels Whether x axis text (category names) should be shown or not.
-#' @param showSeparatorLine If \code{TRUE}, a line is drawn to visually ""separate"" each bar in the diagram.
-#' @param separatorLineColor The color of the separator line. only applies, if \code{showSeparatorLine} is \code{TRUE}.
-#' @param separatorLineSize The size of the separator line. only applies, if \code{showSeparatorLine} is \code{TRUE}.
 #' @return (Insisibily) returns the ggplot-object with the complete plot (\code{plot}) as well as the data frame that
 #'           was used for setting up the ggplot-object (\code{df}).
 #' 
@@ -93,7 +89,7 @@ sjp.stackfrq <- function(items,
                          show.legend = TRUE,
                          title = NULL,
                          legend.title = NULL,
-                         includeN = TRUE,
+                         include.n = TRUE,
                          axis.labels = NULL,
                          wrap.title = 50,
                          wrap.labels = 30,
@@ -108,10 +104,6 @@ sjp.stackfrq <- function(items,
                          digits = 1,
                          vjust = ""center"",
                          showPercentageAxis = TRUE,
-                         showItemLabels = TRUE,
-                         showSeparatorLine = FALSE,
-                         separatorLineColor = ""grey80"",
-                         separatorLineSize = 0.3,
                          coord.flip = TRUE,
                          printPlot = TRUE) {
   # --------------------------------------------------------
@@ -153,12 +145,11 @@ sjp.stackfrq <- function(items,
     reverseOrder <- FALSE
   }
   # --------------------------------------------------------
-  # try to automatically set labels is not passed as parameter
+  # try to automatically set labels if not passed as parameter
   # --------------------------------------------------------
-  if (is.null(legend.labels)) legend.labels <- sjmisc::get_labels(items[[1]],
-                                                                attr.only = F,
-                                                                include.values = NULL,
-                                                                include.non.labelled = T)
+  if (is.null(legend.labels)) 
+    legend.labels <- sjmisc::get_labels(items[[1]], attr.only = F,
+                                        include.values = NULL, include.non.labelled = T)
   if (is.null(axis.labels)) {
     axis.labels <- c()
     # if yes, iterate each variable
@@ -192,11 +183,11 @@ sjp.stackfrq <- function(items,
   # Check whether N of each item should be included into
   # axis labels
   # --------------------------------------------------------
-  if (includeN && !is.null(axis.labels)) {
+  if (include.n) {
     for (i in 1:length(axis.labels)) {
       axis.labels[i] <- paste(axis.labels[i], 
-                               sprintf("" (n=%i)"", length(stats::na.omit(items[[i]]))), 
-                               sep = """")
+                              sprintf("" (n=%i)"", length(stats::na.omit(items[[i]]))), 
+                              sep = """")
     }
   }
   # -----------------------------------------------
@@ -357,16 +348,6 @@ sjp.stackfrq <- function(items,
   baseplot <- baseplot +
     # plot bar chart
     geom_bar(stat = ""identity"", position = ""stack"", width = geom.size)
-  # --------------------------------------------------------
-  # check whether bars should be visually separated by an 
-  # additional separator line
-  # --------------------------------------------------------
-  if (showSeparatorLine) {
-    baseplot <- baseplot +
-      geom_vline(xintercept = c(seq(1.5, length(items), by = 1)), 
-                 size = separatorLineSize, 
-                 colour = separatorLineColor)
-  }
   # -----------------
   # show/hide percentage values on x axis
   # ----------------------------

---FILE: R/sjTabCorr.R---
@@ -132,7 +132,7 @@ sjt.corr <- function(data,
                      string.diag = NULL,
                      encoding = NULL,
                      CSS = NULL,
-                     useViewer = TRUE,
+                     use.viewer = TRUE,
                      no.output = FALSE,
                      remove.spaces = TRUE) {
   # --------------------------------------------------------
@@ -491,7 +491,7 @@ sjt.corr <- function(data,
   # -------------------------------------
   # check if html-content should be outputted
   # -------------------------------------
-  out.html.table(no.output, file, knitr, toWrite, useViewer)
+  out.html.table(no.output, file, knitr, toWrite, use.viewer)
   # -------------------------------------
   # return results
   # -------------------------------------

---FILE: R/sjTabDataFrame.R---
@@ -40,8 +40,8 @@
 #'          applies, if \code{showCommentRow = TRUE}.
 #' @param big.mark character; if not \code{NULL}, used as mark between every 
 #'          thousands decimals before (hence big) the decimal point
-#' @param hideProgressBar logical, if \code{TRUE}, the progress bar that is displayed when creating the
-#'          table is hidden. Default in \code{FALSE}, hence the bar is visible.
+#' @param hide.progress logical, if \code{TRUE}, the progress bar that is displayed when creating the
+#'          output is hidden. Default in \code{FALSE}, hence the bar is visible.
 #' @param ... other arguments passed down to the \code{\link[psych]{describe}} function.
 #'          
 #' @inheritParams sjt.frq
@@ -123,10 +123,10 @@ sjt.df <- function(mydf,
                    showCommentRow = FALSE,
                    commentString = ""No comment..."",
                    big.mark = NULL,
-                   hideProgressBar = FALSE,
+                   hide.progress = FALSE,
                    encoding = NULL,
                    CSS = NULL,
-                   useViewer = TRUE,
+                   use.viewer = TRUE,
                    no.output = FALSE,
                    remove.spaces = TRUE,
                    ...) {
@@ -275,9 +275,7 @@ sjt.df <- function(mydf,
   # -------------------------------------
   # create progress bar
   # -------------------------------------
-  if (!hideProgressBar) pb <- utils::txtProgressBar(min = 0, 
-                                                    max = rowcnt, 
-                                                    style = 3)
+  if (!hide.progress) pb <- utils::txtProgressBar(min = 0, max = rowcnt, style = 3)
   # -------------------------------------
   # subsequent rows
   # -------------------------------------
@@ -294,11 +292,11 @@ sjt.df <- function(mydf,
       page.content <- paste0(page.content, sprintf(""    <td class=\""tdata centertalign%s\"">%s</td>\n"", arcstring, mydf[rcnt, ccnt]))
     }
     # update progress bar
-    if (!hideProgressBar) utils::setTxtProgressBar(pb, rcnt)
+    if (!hide.progress) utils::setTxtProgressBar(pb, rcnt)
     # close row tag
     page.content <- paste0(page.content, ""</tr>\n"")
   }
-  if (!hideProgressBar) close(pb)
+  if (!hide.progress) close(pb)
   # -------------------------------------
   # repeat header row?
   # -------------------------------------
@@ -366,7 +364,7 @@ sjt.df <- function(mydf,
   # -------------------------------------
   # check if html-content should be outputted
   # -------------------------------------
-  out.html.table(no.output, file, knitr, toWrite, useViewer)
+  out.html.table(no.output, file, knitr, toWrite, use.viewer)
   # -------------------------------------
   # return results
   # -------------------------------------

---FILE: R/sjTabFrequencies.R---
@@ -18,10 +18,6 @@
 #' @param value.labels character vector (or \code{list} of character vectors)
 #'          with value labels of the supplied variables, which will be used 
 #'          to label variable values in the output.
-#' @param sort.frq whether frequencies should be sorted or not. Use \code{""asc""} or \code{""ascending""}
-#'          to sort frequencies ascending, or \code{""desc""} or \code{""descending""} to sort
-#'          frequencies in descending order. By default, \code{sort.frq} is \code{NULL}, i.e.
-#'          frequencies are ordered by values.
 #' @param alternateRowColors logical, if \code{TRUE}, alternating rows are highlighted with a light gray
 #'          background color.
 #' @param string.val label for the very first table column containing the values (see
@@ -71,7 +67,7 @@
 #'          Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).
 #' @param CSS \code{\link{list}}-object with user-defined style-sheet-definitions, according to the 
 #'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
-#' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
+#' @param use.viewer If \code{TRUE}, the HTML table is shown in the IDE's viewer pane. If
 #'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
 #' @param no.output logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
 #'          the viewer pane and not even saved to file. This option is useful when the html output
@@ -91,6 +87,7 @@
 #'          
 #' @inheritParams sjp.glmer
 #' @inheritParams sjp.grpfrq
+#' @inheritParams sjp.frq
 #' 
 #' @note The HTML tables can either be saved as file and manually opened (specify argument \code{file}) or
 #'         they can be saved as temporary files and will be displayed in the RStudio Viewer pane (if working with RStudio)
@@ -130,27 +127,19 @@
 #' sjt.frq(efc$e42dep)
 #' 
 #' # plot and show frequency table of ""e42dep"" with labels
-#' sjt.frq(efc$e42dep,
-#'         var.labels = ""Dependency"",
-#'         value.labels = c(""independent"",
-#'                         ""slightly dependent"",
-#'                         ""moderately dependent"",
-#'                         ""severely dependent""))
+#' sjt.frq(efc$e42dep, var.labels = ""Dependency"",
+#'         value.labels = c(""independent"", ""slightly dependent"",
+#'                          ""moderately dependent"", ""severely dependent""))
 #' 
 #' # plot frequencies of e42dep, e16sex and c172code in one HTML file
 #' # and show table in RStudio Viewer Pane or default web browser
 #' # Note that value.labels of multiple variables have to be
 #' # list-objects
 #' sjt.frq(data.frame(efc$e42dep, efc$e16sex, efc$c172code),
-#'         var.labels = c(""Dependency"", 
-#'                            ""Gender"", 
-#'                            ""Education""),
-#'         value.labels = list(c(""independent"",
-#'                              ""slightly dependent"",
-#'                              ""moderately dependent"",
-#'                              ""severely dependent""),
-#'                            c(""male"", ""female""),
-#'                            c(""low"", ""mid"", ""high"")))
+#'         var.labels = c(""Dependency"", ""Gender"", ""Education""),
+#'         value.labels = list(c(""independent"", ""slightly dependent"",
+#'                               ""moderately dependent"", ""severely dependent""),
+#'                             c(""male"", ""female""), c(""low"", ""mid"", ""high"")))
 #' 
 #' # -------------------------------
 #' # auto-detection of labels
@@ -161,9 +150,7 @@
 #' 
 #' # plot larger scale including zero-counts
 #' # indicating median and quartiles
-#' sjt.frq(efc$neg_c_7,
-#'         emph.md = TRUE,
-#'         emph.quart = TRUE)
+#' sjt.frq(efc$neg_c_7, emph.md = TRUE, emph.quart = TRUE)
 #' 
 #' # -------------------------------
 #' # sort frequencies
@@ -189,7 +176,7 @@ sjt.frq <- function(data,
                     var.labels = NULL,
                     value.labels = NULL,
                     auto.group = NULL,
-                    sort.frq = NULL,
+                    sort.frq = c(""none"", ""asc"", ""desc""),
                     alternateRowColors = FALSE,
                     string.val = ""value"",
                     string.cnt = ""N"",
@@ -211,7 +198,7 @@ sjt.frq <- function(data,
                     maxStringDist = 3,
                     encoding = NULL,
                     CSS = NULL,
-                    useViewer = TRUE,
+                    use.viewer = TRUE,
                     no.output = FALSE,
                     remove.spaces = TRUE) {
   # -------------------------------------
@@ -221,9 +208,13 @@ sjt.frq <- function(data,
   # save original value
   o.skip.zero <- skip.zero
   # -------------------------------------
+  # match arguments
+  # -------------------------------------
+  sort.frq <- match.arg(sort.frq)
+  # -------------------------------------
   # warning
   # -------------------------------------
-  if (!is.null(sort.frq)) message(""Sorting may not work when data contains values with zero-counts."")
+  if (!is.null(sort.frq) && sort.frq != ""none"") message(""Sorting may not work when data contains values with zero-counts."")
   # -------------------------------------
   # table init
   # -------------------------------------
@@ -724,7 +715,7 @@ sjt.frq <- function(data,
   # -------------------------------------
   # check if html-content should be outputted
   # -------------------------------------
-  out.html.table(no.output, file, knitr, toWrite, useViewer)
+  out.html.table(no.output, file, knitr, toWrite, use.viewer)
   # -------------------------------------
   # return results
   # -------------------------------------

---FILE: R/sjTabGrpmean.R---
@@ -57,7 +57,7 @@ sjt.grpmean <- function(var.cnt,
                         file = NULL,
                         encoding = NULL,
                         CSS = NULL,
-                        useViewer = TRUE,
+                        use.viewer = TRUE,
                         no.output = FALSE,
                         remove.spaces = TRUE) {
   # --------------------------------------------------------
@@ -145,9 +145,7 @@ sjt.grpmean <- function(var.cnt,
   # do we have weighted means?
   # --------------------------------------
   if (!is.null(weight.by)) {
-    mw <- weighted.mean(var.cnt, 
-                        w = weight.by,
-                        na.rm = TRUE)
+    mw <- weighted.mean(var.cnt, w = weight.by, na.rm = TRUE)
   } else {
     mw <- mean(var.cnt, na.rm = TRUE)
   }
@@ -192,7 +190,7 @@ sjt.grpmean <- function(var.cnt,
                  no.output = T,
                  CSS = CSS,
                  encoding = encoding,
-                 hideProgressBar = TRUE,
+                 hide.progress = TRUE,
                  commentString = gsub(""=0."", 
                                       paste0(""="", p_zero, "".""), 
                                       sprintf(""<strong>Anova:</strong> R<sup>2</sup>=%.*f &middot; adj. R<sup>2</sup>=%.*f &middot; %s &middot; F=%.*f &middot; %s"",
@@ -202,7 +200,7 @@ sjt.grpmean <- function(var.cnt,
   # -------------------------------------
   # check if html-content should be printed
   # -------------------------------------
-  out.html.table(no.output, file, html$knitr, html$output.complete, useViewer)  
+  out.html.table(no.output, file, html$knitr, html$output.complete, use.viewer)  
   invisible(list(class = c(""sjTable"", ""sjtgrpmean""),
                  df = df, 
                  page.style = html$page.style,

---FILE: R/sjTabItemAnalysis.R---
@@ -145,7 +145,7 @@ sjt.itemanalysis <- function(df,
                              file = NULL,
                              encoding = NULL,
                              CSS = NULL,
-                             useViewer = TRUE,
+                             use.viewer = TRUE,
                              no.output = FALSE,
                              remove.spaces = TRUE) {
   # -------------------------------------
@@ -391,7 +391,7 @@ sjt.itemanalysis <- function(df,
   # -------------------------------------
   # check if html-content should be printed
   # -------------------------------------
-  out.html.table(no.output, file, knitr, complete.page, useViewer)  
+  out.html.table(no.output, file, knitr, complete.page, use.viewer)  
   invisible(list(class = c(""sjTable"", ""sjtitemanalysis""),
                  df.list = df.ia,
                  index.scores = index.scores,

---FILE: R/sjTabLinReg.R---
@@ -15,36 +15,36 @@ utils::globalVariables(c(""starts_with""))
 #' @seealso \href{http://strengejacke.de/sjPlot/sjt.lm/}{sjPlot manual: sjt.lm}
 #' 
 #' @param ... one or more fitted linear (mixed) models.
-#' @param labelPredictors character vector with labels of predictor variables.
-#'          If not \code{NULL}, \code{labelPredictors} will be used in the first
+#' @param pred.labels character vector with labels of predictor variables.
+#'          If not \code{NULL}, \code{pred.labels} will be used in the first
 #'          table column with the predictors' names. If \code{NULL}, variable
 #'          labels are set based on label attributes (see \code{\link[sjmisc]{get_label}}),
-#'          If \code{labelPredictors = """"}, column names (vector names) are used
+#'          If \code{pred.labels = """"}, column names (vector names) are used
 #'          as predictor labels. See 'Examples'.
 #' @param depvar.labels character vector with labels of dependent 
 #'          variables of all fitted models. See 'Examples'.
-#' @param stringPredictors string constant used as headline for the predictor column.
+#' @param string.pred string constant used as headline for the predictor column.
 #'          Default is \code{""Predictors""}.
-#' @param stringDependentVariables string constant used as headline for the 
+#' @param string.dv string constant used as headline for the 
 #'          dependent variable columns. Default is \code{""Dependent Variables""}.
-#' @param showHeaderStrings logical, if \code{TRUE}, the header strings \code{stringPredictors}
-#'          and \code{stringDependentVariables} are shown. By default, they're hidden.
+#' @param show.header logical, if \code{TRUE}, the header strings \code{string.pred}
+#'          and \code{string.dv} are shown. By default, they're hidden.
 #' @param string.interc string constant used as headline for the Intercept row.
 #'          Default is \code{""Intercept""}.
-#' @param stringObservations string constant used in the summary row for the count of observation
+#' @param string.obs string constant used in the summary row for the count of observation
 #'          (cases). Default is \code{""Observations""}.
 #' @param string.est string used for the column heading of estimates.
 #' @param string.std string used for the column heading of standardized beta coefficients. Default is \code{""std. Beta""}.
 #' @param string.ci string used for the column heading of confidence interval values. Default is \code{""CI""}.
 #' @param string.se string used for the column heading of standard error values. Default is \code{""std. Error""}.
-#' @param stringP string used for the column heading of p values. Default is \code{""p""}.
-#' @param showEst logical, if \code{TRUE} (default), the estimates are printed.
-#' @param showConfInt logical, if \code{TRUE} (default), the confidence intervall is also printed to the table. Use
+#' @param string.p string used for the column heading of p values. Default is \code{""p""}.
+#' @param show.est logical, if \code{TRUE} (default), the estimates are printed.
+#' @param show.ci logical, if \code{TRUE} (default), the confidence intervall is also printed to the table. Use
 #'          \code{FALSE} to omit the CI in the table.
-#' @param showStdBeta indicates whether standardized beta-coefficients should 
+#' @param show.std indicates whether standardized beta-coefficients should 
 #'          also printed, and if yes, which type of standardization is done.
 #'          See 'Details'.
-#' @param showStdError logical, if \code{TRUE}, the standard errors are also printed.
+#' @param show.se logical, if \code{TRUE}, the standard errors are also printed.
 #'          Default is \code{FALSE}.
 #' @param ci.hyphen string, indicating the hyphen for confidence interval range.
 #'          May be an HTML entity. See 'Examples'.
@@ -54,35 +54,35 @@ utils::globalVariables(c(""starts_with""))
 #' @param digits.p amount of decimals for p-values
 #' @param digits.ci amount of decimals for confidence intervals
 #' @param digits.se amount of decimals for standard error
-#' @param digits.sb amount of decimals for standardized beta
+#' @param digits.std amount of decimals for standardized beta
 #' @param digits.summary amount of decimals for values in model summary
 #' @param boldpvalues logical, if \code{TRUE} (default), significant p-values are shown bold faced.
-#' @param separateConfColumn if \code{TRUE}, the CI values are shown in a separate table column.
+#' @param separate.ci.col if \code{TRUE}, the CI values are shown in a separate table column.
 #'          Default is \code{FALSE}.
-#' @param newLineConf logical, if \code{TRUE} and \code{separateConfColumn = FALSE}, inserts a line break
-#'          between B and CI values. If \code{FALSE}, CI values are printed in the same
-#'          line as B values.
+#' @param newline.ci logical, if \code{TRUE} and \code{separate.ci.col = FALSE}, inserts a line break
+#'          between estimate and CI values. If \code{FALSE}, CI values are printed in the same
+#'          line as estimate values.
 #' @param group.pred logical, if \code{TRUE} (default), automatically groups table rows with 
 #'          factor levels of same factor, i.e. predictors of type \code{\link{factor}} will
 #'          be grouped, if the factor has more than two levels. Grouping means that a separate headline
 #'          row is inserted to the table just before the predictor values.
-#' @param showAbbrHeadline logical, if \code{TRUE} (default), the table data columns have a headline with 
-#'          abbreviations for estimates and std. beta-values, confidence interval and p-values.
-#' @param showR2 logical, if \code{TRUE} (default), the R2 and adjusted R2 values for each model are printed
+#' @param show.col.header logical, if \code{TRUE} (default), the table data columns have a headline with 
+#'          abbreviations for estimates, std. beta-values, confidence interval and p-values.
+#' @param show.r2 logical, if \code{TRUE} (default), the R2 and adjusted R2 values for each model are printed
 #'          in the model summary. For linear mixed models, the R2 and Omega-squared values are printed
 #'          (see \code{\link[sjmisc]{r2}} for details).
-#' @param showICC logical, if \code{TRUE}, the intra-class-correlation for each 
+#' @param show.icc logical, if \code{TRUE}, the intra-class-correlation for each 
 #'          model is printed in the model summary. Only applies to mixed models.
-#' @param showREvar logical, if \code{TRUE}, the variance parameters for the random
+#' @param show.re.var logical, if \code{TRUE}, the variance parameters for the random
 #'          effects for each model are printed in the model summary. Only applies to mixed models.
 #'          For details output, see 'Note' in \code{\link[sjmisc]{icc}}.
-#' @param showFStat If \code{TRUE}, the F-statistics for each model is printed
+#' @param show.fstat If \code{TRUE}, the F-statistics for each model is printed
 #'          in the model summary. Default is \code{FALSE}.
-#' @param showAIC logical, if \code{TRUE}, the AIC value for each model is printed
+#' @param show.aic logical, if \code{TRUE}, the AIC value for each model is printed
 #'          in the model summary. Default is \code{FALSE}.
-#' @param showAICc logical, if \code{TRUE}, the second-order AIC value for each model 
+#' @param show.aicc logical, if \code{TRUE}, the second-order AIC value for each model 
 #'          is printed in the model summary. Default is \code{FALSE}.
-#' @param showDeviance logical, if \code{TRUE}, the deviance for each model 
+#' @param show.dev logical, if \code{TRUE}, the deviance for each model 
 #'          is printed in the model summary.
 #' @param remove.estimates numeric vector with indices (order equals to row index of \code{coef(fit)}) 
 #'          or character vector with coefficient names that indicate which estimates should be removed
@@ -91,11 +91,11 @@ utils::globalVariables(c(""starts_with""))
 #'          would remove the 2nd to the 4th estimate (1st to 3rd predictor after intercept) from the output. 
 #'          \code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default 
 #'          is \code{NULL}, i.e. all estimates are printed.
-#' @param cellSpacing numeric, inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
+#' @param cell.spacing numeric, inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
 #'          suitable for viewing the table. Decrease this value (0.05 to 0.1) if you want to import the table
 #'          into Office documents. This is a convenient argument for the \code{CSS} argument for changing
 #'          cell spacing, which would be: \code{CSS = list(css.thead = ""padding:0.2cm;"", css.tdata = ""padding:0.2cm;"")}.
-#' @param cellGroupIndent indent for table rows with grouped factor predictors. Only applies
+#' @param cell.gpr.indent indent for table rows with grouped factor predictors. Only applies
 #'          if \code{group.pred = TRUE}.
 #'          
 #' @inheritParams sjt.frq
@@ -113,18 +113,18 @@ utils::globalVariables(c(""starts_with""))
 #'
 #' @note See 'Note' in \code{\link{sjt.frq}}.
 #'  
-#' @details Concerning the \code{showStdBeta} argument, \code{showStdBeta = ""std""}
-#'            will print normal standardized estimates. \code{showStdBeta = ""std2""},
+#' @details Concerning the \code{show.std} argument, \code{show.std = ""std""}
+#'            will print normal standardized estimates. \code{show.std = ""std2""},
 #'            however, standardization of estimates follows 
 #'            \href{http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf}{Gelman's (2008)}
 #'            suggestion, rescaling the estimates by dividing them by two standard 
 #'            deviations instead of just one. Resulting coefficients are then 
 #'            directly comparable for untransformed binary predictors. This type 
 #'            of standardization uses the \code{\link[arm]{standardize}}-function.
-#'            For backward compatibility reasons, \code{showStdBeta} also may be 
+#'            For backward compatibility reasons, \code{show.std} also may be 
 #'            a logical value; if \code{TRUE}, normal standardized estimates are 
-#'            printed (same effect as \code{showStdBeta = ""std""}). Use 
-#'            \code{showStdBeta = NULL} (default) or \code{showStdBeta = FALSE},
+#'            printed (same effect as \code{show.std = ""std""}). Use 
+#'            \code{show.std = NULL} (default) or \code{show.std = FALSE},
 #'            if standardized estimats should not be printed.
 #'            \cr \cr
 #'            Furthermore, see 'Details' in \code{\link{sjt.frq}}.
@@ -152,28 +152,28 @@ utils::globalVariables(c(""starts_with""))
 #' sjt.lm(fit1, 
 #'        fit2, 
 #'        depvar.labels = c(""Barthel-Index"", ""Negative Impact""),
-#'        labelPredictors = c(""Carer's Age"", ""Hours of Care"", 
+#'        pred.labels = c(""Carer's Age"", ""Hours of Care"", 
 #'                            ""Carer's Sex"", ""Educational Status""))
 #' 
 #' # use vector names as labels
-#' sjt.lm(fit1, fit2, labelPredictors = """")
+#' sjt.lm(fit1, fit2, pred.labels = """")
 #' 
 #' # show HTML-table, indicating p-values as asterisks
-#' sjt.lm(fit1, fit2, showStdBeta = TRUE, p.numeric = FALSE)
+#' sjt.lm(fit1, fit2, show.std = TRUE, p.numeric = FALSE)
 #' 
 #' # create and open HTML-table in RStudio Viewer Pane or web browser,
 #' # integrate CI in estimate column
-#' sjt.lm(fit1, fit2, separateConfColumn = FALSE)
+#' sjt.lm(fit1, fit2, separate.ci.col = FALSE)
 #' 
 #' # show HTML-table, indicating p-values as numbers
 #' # and printing CI in a separate column
-#' sjt.lm(fit1, fit2, showStdBeta = TRUE)
+#' sjt.lm(fit1, fit2, show.std = TRUE)
 #' 
 #' # show HTML-table, indicating p-values as stars
 #' # and integrate CI in estimate column
-#' sjt.lm(fit1, fit2, showStdBeta = TRUE, ci.hyphen = "" to "",
+#' sjt.lm(fit1, fit2, show.std = TRUE, ci.hyphen = "" to "",
 #'        minus.sign = ""&minus;"", p.numeric = FALSE, 
-#'        separateConfColumn = FALSE)
+#'        separate.ci.col = FALSE)
 #' 
 #' # ---------------------------------- 
 #' # connecting two html-tables
@@ -257,10 +257,10 @@ utils::globalVariables(c(""starts_with""))
 #' 
 #' # show standardized beta only
 #' sjt.lm(fit1, fit2, fit4, fit3,
-#'        showEst = FALSE,
-#'        showStdBeta = TRUE,
-#'        showAIC = TRUE,
-#'        showFStat = TRUE)
+#'        show.est = FALSE,
+#'        show.std = TRUE,
+#'        show.aic = TRUE,
+#'        show.fstat = TRUE)
 #'
 #' # -----------------------------------------------------------
 #' # color insanity. just to show that each column has an own
@@ -269,10 +269,10 @@ utils::globalVariables(c(""starts_with""))
 #' # visually separate your models in the table
 #' # -----------------------------------------------------------
 #' sjt.lm(fit1, fit2, fit4, fit3,
-#'        showStdBeta = TRUE,
-#'        showAIC = TRUE,
-#'        showFStat = TRUE,
-#'        showStdError = TRUE,
+#'        show.std = TRUE,
+#'        show.aic = TRUE,
+#'        show.fstat = TRUE,
+#'        show.se = TRUE,
 #'        CSS = list(css.modelcolumn1 = 'color:blue;',
 #'                   css.modelcolumn2 = 'color:red;',
 #'                   css.modelcolumn3 = 'color:green;',
@@ -281,8 +281,8 @@ utils::globalVariables(c(""starts_with""))
 #'                   css.modelcolumn6 = 'color:#3399cc;'))
 #'
 #' sjt.lm(fit1, fit2, fit4, fit3,
-#'        showEst = FALSE,
-#'        showStdBeta = TRUE,
+#'        show.est = FALSE,
+#'        show.std = TRUE,
 #'        p.numeric = FALSE,
 #'        group.pred = FALSE,
 #'        CSS = list(css.modelcolumn4 = 'border-left:1px solid black;',
@@ -294,50 +294,50 @@ utils::globalVariables(c(""starts_with""))
 #' @export
 sjt.lm <- function(...,
                    file = NULL,
-                   labelPredictors = NULL,
+                   pred.labels = NULL,
                    depvar.labels = NULL,
-                   stringPredictors = ""Predictors"",
-                   stringDependentVariables = ""Dependent Variables"",
-                   showHeaderStrings = FALSE,
+                   string.pred = ""Predictors"",
+                   string.dv = ""Dependent Variables"",
+                   show.header = FALSE,
                    string.interc = ""(Intercept)"",
-                   stringObservations = ""Observations"",
+                   string.obs = ""Observations"",
                    string.est = ""B"",
                    string.std = ""std. Beta"",
                    string.ci = ""CI"",
                    string.se = ""std. Error"",
-                   stringP = ""p"",
-                   showEst = TRUE,
-                   showConfInt = TRUE,
-                   showStdBeta = NULL,
-                   showStdError = FALSE,
+                   string.p = ""p"",
+                   show.est = TRUE,
+                   show.ci = TRUE,
+                   show.std = NULL,
+                   show.se = FALSE,
                    ci.hyphen = ""&nbsp;&ndash;&nbsp;"",
                    minus.sign = ""&#45;"",
                    digits.est = 2,
                    digits.p = 3,
                    digits.ci = 2,
                    digits.se = 2,
-                   digits.sb = 2,
+                   digits.std = 2,
                    digits.summary = 3,
                    p.numeric = TRUE,
                    boldpvalues = TRUE,
                    p.kr = TRUE,
-                   separateConfColumn = TRUE,
-                   newLineConf = TRUE,
+                   separate.ci.col = TRUE,
+                   newline.ci = TRUE,
                    group.pred = TRUE,
-                   showAbbrHeadline = TRUE,
-                   showR2 = TRUE,
-                   showICC = FALSE,
-                   showREvar = FALSE,
-                   showFStat = FALSE,
-                   showAIC = FALSE,
-                   showAICc = FALSE,
-                   showDeviance = FALSE,
+                   show.col.header = TRUE,
+                   show.r2 = TRUE,
+                   show.icc = FALSE,
+                   show.re.var = FALSE,
+                   show.fstat = FALSE,
+                   show.aic = FALSE,
+                   show.aicc = FALSE,
+                   show.dev = FALSE,
                    remove.estimates = NULL,
-                   cellSpacing = 0.2,
-                   cellGroupIndent = 0.6,
+                   cell.spacing = 0.2,
+                   cell.gpr.indent = 0.6,
                    encoding = NULL,
                    CSS = NULL,
-                   useViewer = TRUE,
+                   use.viewer = TRUE,
                    no.output = FALSE,
                    remove.spaces = TRUE) {
   # --------------------------------------------------------
@@ -354,14 +354,14 @@ sjt.lm <- function(...,
   # check arguments
   # -------------------------------------
   # check default for standardized beta valies
-  if (is.null(showStdBeta) || showStdBeta == FALSE) 
+  if (is.null(show.std) || show.std == FALSE) 
     showStdBetaValues <- FALSE
   else
     showStdBetaValues <- TRUE
   # check if any estimates should be plotted?
-  if (!showEst && !showStdBetaValues) {
-    warning(""Either estimates (`showEst`) or standardized betas (`showStdBeta`) must be shown in table. Setting `showEst` to `TRUE`."", call. = F)
-    showEst <- TRUE
+  if (!show.est && !showStdBetaValues) {
+    warning(""Either estimates (`show.est`) or standardized betas (`show.std`) must be shown in table. Setting `show.est` to `TRUE`."", call. = F)
+    show.est <- TRUE
   }
   # check hyphen for ci-range
   if (is.null(ci.hyphen)) ci.hyphen <- ""&nbsp;&ndash;&nbsp;""
@@ -374,7 +374,7 @@ sjt.lm <- function(...,
   # ------------------------
   # get table header
   # ------------------------
-  toWrite <- get_table_header(encoding, cellSpacing, cellGroupIndent, p.numeric, showHeaderStrings, CSS)
+  toWrite <- get_table_header(encoding, cell.spacing, cell.gpr.indent, p.numeric, show.header, CSS)
   # ------------------------
   # retrieve fitted models
   # ------------------------
@@ -405,9 +405,9 @@ sjt.lm <- function(...,
   # ------------------------
   # should AICc be computed? Check for package
   # ------------------------
-  if (showAICc && !requireNamespace(""AICcmodavg"", quietly = TRUE)) {
-    warning(""Package `AICcmodavg` needed to show AICc. Argument `showAICc` will be ignored."", call. = FALSE)
-    showAICc <- FALSE
+  if (show.aicc && !requireNamespace(""AICcmodavg"", quietly = TRUE)) {
+    warning(""Package `AICcmodavg` needed to show AICc. Argument `show.aicc` will be ignored."", call. = FALSE)
+    show.aicc <- FALSE
   }
   # ------------------------
   # check for stepwise models, when fitted models
@@ -430,7 +430,7 @@ sjt.lm <- function(...,
   # are simple linear models
   # ------------------------
   else {
-    showICC <- FALSE
+    show.icc <- FALSE
     # check if we have different amount of coefficients
     # in fitted models - if yes, we have e.g. stepwise models
     sw.fit <- length(unique(sapply(input_list, function(x) length(stats::coef(x))))) > 1
@@ -469,7 +469,7 @@ sjt.lm <- function(...,
       coef.fit <- lme4::fixef(fit)
     } else {
       confis <- stats::confint(fit)
-      if (!is.null(showStdBeta) && showStdBeta == ""std2"") 
+      if (!is.null(show.std) && show.std == ""std2"") 
         sbvals <- suppressWarnings(sjmisc::std_beta(fit, include.ci = T, type = ""std2""))
       else
         sbvals <- suppressWarnings(sjmisc::std_beta(fit, include.ci = T))
@@ -502,7 +502,7 @@ sjt.lm <- function(...,
       fit.df$se <- sprintf(""%.*f"", digits.se, p_se$se)
     }
     # retrieve standardized betas and CI
-    fit.df$stdbv <- c("""", sprintf(""%.*f"", digits.sb, sbvals[, 1]))
+    fit.df$stdbv <- c("""", sprintf(""%.*f"", digits.std, sbvals[, 1]))
     fit.df$stdbvci_lower <- c("""", sprintf(""%.*f"", digits.ci, sbvals[, 2]))
     fit.df$stdbvci_higher <- c("""", sprintf(""%.*f"", digits.ci, sbvals[, 3]))
     # -------------------------------------
@@ -604,8 +604,8 @@ sjt.lm <- function(...,
   # if confidence interval should be omitted,
   # don't use separate column for CI!
   # -------------------------------------
-  if (!showConfInt) {
-    separateConfColumn <- FALSE
+  if (!show.ci) {
+    separate.ci.col <- FALSE
     showCIString <- string.est
     showCIStringSB <- string.std
   } else {
@@ -622,31 +622,31 @@ sjt.lm <- function(...,
   # i.e. the amount of table columns that are needed for each model
   # (B, p, CI, se...)
   headerColSpanFactor <- 1
-  if (!showEst) headerColSpanFactor <- 0
-  if (!showEst && separateConfColumn) headerColSpanFactor <- -1
+  if (!show.est) headerColSpanFactor <- 0
+  if (!show.est && separate.ci.col) headerColSpanFactor <- -1
   if (p.numeric) headerColSpanFactor <- headerColSpanFactor + 1
-  if (separateConfColumn) headerColSpanFactor <- headerColSpanFactor + 1
+  if (separate.ci.col) headerColSpanFactor <- headerColSpanFactor + 1
   if (showStdBetaValues) headerColSpanFactor <- headerColSpanFactor + 1
-  if (showStdBetaValues && separateConfColumn) headerColSpanFactor <- headerColSpanFactor + 1
-  if (showStdError) headerColSpanFactor <- headerColSpanFactor + 1
+  if (showStdBetaValues && separate.ci.col) headerColSpanFactor <- headerColSpanFactor + 1
+  if (show.se) headerColSpanFactor <- headerColSpanFactor + 1
   # now that we know how many columns each model needs,
   # we multiply columns per model with count of models, so we have
   # the column span over all models together; furthermore, we add
   # count of models to the overall column span, because
   # each model is separated with an empty table column
   headerColSpan <- headerColSpanFactor * headerColSpan + length(input_list)
   linebreakstring <- "" ""
-  if (newLineConf) linebreakstring <- ""<br>""
+  if (newline.ci) linebreakstring <- ""<br>""
   # -------------------------------------
   # start table tag
   # -------------------------------------
   page.content <- ""<table>""
   # -------------------------------------
   # check if we want to see header strings
   # -------------------------------------
-  if (showHeaderStrings) {
-    page.content <- paste0(page.content, sprintf(""\n  <tr>\n    <td class=\""tdata topborder\"" rowspan=\""2\""><em>%s</em></td>"", stringPredictors))
-    page.content <- paste0(page.content, sprintf(""\n    <td colspan=\""%i\"" class=\""tdata topborder depvarhead\""><em>%s</em></td>"", headerColSpan, stringDependentVariables))
+  if (show.header) {
+    page.content <- paste0(page.content, sprintf(""\n  <tr>\n    <td class=\""tdata topborder\"" rowspan=\""2\""><em>%s</em></td>"", string.pred))
+    page.content <- paste0(page.content, sprintf(""\n    <td colspan=\""%i\"" class=\""tdata topborder depvarhead\""><em>%s</em></td>"", headerColSpan, string.dv))
     page.content <- paste0(page.content, ""\n  </tr>\n"")
   }
   # -------------------------------------
@@ -658,7 +658,7 @@ sjt.lm <- function(...,
   # so we need to insert an empty cell here
   # -------------------------------------
   tcp <- """"
-  if (!showHeaderStrings) {
+  if (!show.header) {
     page.content <- paste0(page.content, ""\n    <td class=\""tdata topborder\"">&nbsp;</td>"")
     tcp <- "" topborder""
   }
@@ -672,7 +672,7 @@ sjt.lm <- function(...,
   # -------------------------------------
   # table header: or/ci and p-labels
   # -------------------------------------
-  if (showAbbrHeadline) {
+  if (show.col.header) {
     page.content <- paste0(page.content, ""\n  <tr>\n    <td class=\""tdata colnames\"">&nbsp;</td>"")
     colnr <- ifelse(is.null(depvar.labels), length(input_list), length(depvar.labels))
     for (i in 1:colnr) {
@@ -681,46 +681,46 @@ sjt.lm <- function(...,
       # -------------------------
       page.content <- paste0(page.content, ""<td class=\""separatorcol colnames\"">&nbsp;</td>"")
       # confidence interval in separate column
-      if (showEst) {
-        if (separateConfColumn) {
+      if (show.est) {
+        if (separate.ci.col) {
           page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign colnames modelcolumn1\"">%s</td>"", string.est))
-          if (showConfInt) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign colnames modelcolumn2\"">%s</td>"", string.ci))
+          if (show.ci) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign colnames modelcolumn2\"">%s</td>"", string.ci))
         } else {
           # confidence interval in Beta-column
           page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign colnames modelcolumn1\"">%s</td>"", showCIString))
         }
       }
       # show std. error
-      if (showStdError) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign colnames modelcolumn3\"">%s</td>"", string.se))
+      if (show.se) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign colnames modelcolumn3\"">%s</td>"", string.se))
       # show std. beta
       if (showStdBetaValues) {
         # confidence interval in separate column
-        if (separateConfColumn) {
+        if (separate.ci.col) {
           page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign colnames modelcolumn4\"">%s</td>"", string.std))
-          if (showConfInt) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign colnames modelcolumn5\"">%s</td>"", string.ci))
+          if (show.ci) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign colnames modelcolumn5\"">%s</td>"", string.ci))
         } else {
           # confidence interval in Beta-column
           page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign colnames modelcolumn4\"">%s</td>"", showCIStringSB))
         }
       }
       # show p-values as numbers in separate column
-      if (p.numeric) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign colnames modelcolumn6\"">%s</td>"", stringP))
+      if (p.numeric) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign colnames modelcolumn6\"">%s</td>"", string.p))
     }
     page.content <- paste(page.content, ""\n  </tr>\n"")
   }
   # -------------------------------------
   # set default predictor labels
   # -------------------------------------
-  if (is.null(labelPredictors)) {
-    labelPredictors <- suppressWarnings(retrieveModelLabels(input_list, group.pred = group.pred))
+  if (is.null(pred.labels)) {
+    pred.labels <- suppressWarnings(retrieveModelLabels(input_list, group.pred = group.pred))
   }
   # --------------------------------------------------------
   # auto-retrieving variable labels does not work when we
   # have factors with different levels, which appear as 
   # ""multiple predictors"", but are only one variable
   # --------------------------------------------------------
-  if (is.null(labelPredictors) || length(labelPredictors) < length(joined.df[-1, 1])) {
-    labelPredictors <- joined.df[-1, 1]
+  if (is.null(pred.labels) || length(pred.labels) < length(joined.df[-1, 1])) {
+    pred.labels <- joined.df[-1, 1]
   }
   # -------------------------------------
   # should factor predictors be grouped?
@@ -765,9 +765,9 @@ sjt.lm <- function(...,
     # -------------------------
     page.content <- paste0(page.content, sprintf(""<td class=\""separatorcol %s\"">&nbsp;</td>"", tcb_class))
     # show estimates?
-    if (showEst) {
+    if (show.est) {
       # confidence interval in separate column
-      if (separateConfColumn) {
+      if (separate.ci.col) {
         # open table cell for Beta-coefficient
         page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign %smodelcolumn1\"">%s"", 
                                                      tcb_class, 
@@ -776,7 +776,7 @@ sjt.lm <- function(...,
         if (!p.numeric) page.content <- paste0(page.content, sprintf(""&nbsp;%s"", 
                                                                             joined.df[1, (i - 1) * 8 + 5]))
         # if we have CI, start new table cell (CI in separate column)
-        if (showConfInt) {
+        if (show.ci) {
           page.content <- paste0(page.content, sprintf(""</td><td class=\""tdata centeralign %smodelcolumn2\"">%s%s%s</td>"", 
                                                        tcb_class, 
                                                        joined.df[1, (i - 1) * 8 + 3], 
@@ -791,7 +791,7 @@ sjt.lm <- function(...,
                                                      tcb_class, 
                                                      joined.df[1, (i - 1) * 8 + 2]))
         # confidence interval in Beta-column
-        if (showConfInt) page.content <- paste0(page.content, sprintf(""%s(%s%s%s)"", 
+        if (show.ci) page.content <- paste0(page.content, sprintf(""%s(%s%s%s)"", 
                                                                       linebreakstring, 
                                                                       joined.df[1, (i - 1) * 8 + 3], 
                                                                       ci.hyphen,
@@ -803,15 +803,15 @@ sjt.lm <- function(...,
       }
     }
     # show std. error
-    if (showStdError) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign %smodelcolumn3\"">%s</td>"", 
+    if (show.se) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign %smodelcolumn3\"">%s</td>"", 
                                                                    tcb_class, 
                                                                    joined.df[1, (i - 1) * 8 + 6]))
     # show std. beta
     if (showStdBetaValues) page.content <- paste0(page.content, 
                                             sprintf(""<td class=\""tdata centeralign %smodelcolumn4\"">&nbsp;</td>"", 
                                                     tcb_class))
     # show std. beta
-    if (showStdBetaValues && showConfInt && separateConfColumn) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign %smodelcolumn5\"">&nbsp;</td>"", 
+    if (showStdBetaValues && show.ci && separate.ci.col) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign %smodelcolumn5\"">&nbsp;</td>"", 
                                                                                                        tcb_class))
     # show p-values as numbers in separate column
     if (p.numeric) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign %smodelcolumn6\"">%s</td>"", 
@@ -839,7 +839,7 @@ sjt.lm <- function(...,
     } else {
       indent.tag <- ""tdata""
     }
-    page.content <- paste0(page.content, ""\n  <tr>\n"", sprintf(""    <td class=\""%s leftalign\"">%s</td>"", indent.tag, labelPredictors[i]))
+    page.content <- paste0(page.content, ""\n  <tr>\n"", sprintf(""    <td class=\""%s leftalign\"">%s</td>"", indent.tag, pred.labels[i]))
     # ---------------------------------------
     # go through fitted model's statistics
     # ---------------------------------------
@@ -849,7 +849,7 @@ sjt.lm <- function(...,
       # -------------------------
       page.content <- paste0(page.content, ""<td class=\""separatorcol\"">&nbsp;</td>"")
       # show estimates?
-      if (showEst) {
+      if (show.est) {
         # retieve lower and upper ci
         ci.lo <- joined.df[i + 1, (j - 1) * 8 + 3]
         ci.hi <- joined.df[i + 1, (j - 1) * 8 + 4]
@@ -862,14 +862,14 @@ sjt.lm <- function(...,
         if (sjmisc::is_empty(joined.df[i + 1, (j - 1) * 8 + 5])) joined.df[i + 1, (j - 1) * 8 + 5] <- ""&nbsp;""
         if (sjmisc::is_empty(joined.df[i + 1, (j - 1) * 8 + 6])) joined.df[i + 1, (j - 1) * 8 + 6] <- ""&nbsp;""
         # confidence interval in separate column
-        if (separateConfColumn) {
+        if (separate.ci.col) {
           # open table cell for Beta-coefficient
           page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign modelcolumn1\"">%s"", 
                                                        joined.df[i + 1, (j - 1) * 8 + 2]))
           # if p-values are not shown as numbers, insert them after beta-value
           if (!p.numeric) page.content <- paste0(page.content, sprintf(""&nbsp;%s"", joined.df[i + 1, (j - 1) * 8 + 5]))
           # if we have CI, start new table cell (CI in separate column)
-          if (showConfInt) {
+          if (show.ci) {
             page.content <- paste0(page.content, sprintf(""</td><td class=\""tdata centeralign modelcolumn2\"">%s%s%s</td>"", 
                                                          ci.lo, 
                                                          ci.sep.string, 
@@ -882,7 +882,7 @@ sjt.lm <- function(...,
           page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign modelcolumn1\"">%s"", 
                                                        joined.df[i + 1, (j - 1) * 8 + 2]))
           # confidence interval in Beta-column
-          if (showConfInt && !sjmisc::is_empty(ci.lo)) page.content <- paste0(page.content, 
+          if (show.ci && !sjmisc::is_empty(ci.lo)) page.content <- paste0(page.content, 
                                                                               sprintf(""%s(%s%s%s)"", 
                                                                                       linebreakstring, 
                                                                                       ci.lo, 
@@ -896,7 +896,7 @@ sjt.lm <- function(...,
         }
       }
       # show std. error
-      if (showStdError) page.content <- paste0(page.content, 
+      if (show.se) page.content <- paste0(page.content, 
                                                sprintf(""<td class=\""tdata centeralign modelcolumn3\"">%s</td>"", 
                                                        joined.df[i + 1, (j - 1) * 8 + 6]))
       # show std. beta
@@ -905,13 +905,13 @@ sjt.lm <- function(...,
         ci.lo <- joined.df[i + 1, (j - 1) * 8 + 8]
         ci.hi <- joined.df[i + 1, (j - 1) * 8 + 9]
         ci.sep.string <- ifelse(sjmisc::is_empty(ci.lo), ""&nbsp;"", ci.hyphen)
-        if (separateConfColumn) {
+        if (separate.ci.col) {
           # open table cell for Beta-coefficient
           page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign modelcolumn4\"">%s"", joined.df[i + 1, (j - 1) * 8 + 7]))
           # show pvalue stars, if no estimates are shown
-          if (!p.numeric && !showEst) page.content <- paste0(page.content, sprintf(""&nbsp;%s"", joined.df[1, (i - 1) * 8 + 5]))
+          if (!p.numeric && !show.est) page.content <- paste0(page.content, sprintf(""&nbsp;%s"", joined.df[1, (i - 1) * 8 + 5]))
           # if we have CI, start new table cell (CI in separate column)
-          if (showConfInt) {
+          if (show.ci) {
             page.content <- paste0(page.content, sprintf(""</td><td class=\""tdata centeralign modelcolumn5\"">%s%s%s</td>"",
                                                          ci.lo, 
                                                          ci.sep.string,
@@ -923,9 +923,9 @@ sjt.lm <- function(...,
           # open table cell for Beta-coefficient
           page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign modelcolumn4\"">%s"", joined.df[i + 1, (j - 1) * 8 + 7]))
           # show pvalue stars, if no estimates are shown
-          if (!p.numeric && !showEst) page.content <- paste0(page.content, sprintf(""&nbsp;%s"", joined.df[1, (i - 1) * 8 + 5]))
+          if (!p.numeric && !show.est) page.content <- paste0(page.content, sprintf(""&nbsp;%s"", joined.df[1, (i - 1) * 8 + 5]))
           # confidence interval in Beta-column
-          if (showConfInt && !sjmisc::is_empty(ci.lo)) page.content <- paste0(page.content, sprintf(""%s(%s%s%s)"",
+          if (show.ci && !sjmisc::is_empty(ci.lo)) page.content <- paste0(page.content, sprintf(""%s(%s%s%s)"",
                                                                                                     linebreakstring, 
                                                                                                     ci.lo, 
                                                                                                     ci.sep.string, 
@@ -967,7 +967,7 @@ sjt.lm <- function(...,
     # -------------------------------------
     # show variance components?
     # -------------------------------------
-    if (showREvar) {
+    if (show.re.var) {
       # -------------------------------------
       # lets check which mdoels have random slopes, needed later
       # -------------------------------------
@@ -1075,7 +1075,7 @@ sjt.lm <- function(...,
     # -------------------------------------
     # Model-Summary: icc
     # -------------------------------------
-    if (showICC) {
+    if (show.icc) {
       # get icc from models
       summary.icc <- sjmisc::icc(input_list[[which.max(all_mm_counts)]])
       # iterate icc's
@@ -1105,7 +1105,7 @@ sjt.lm <- function(...,
   # -------------------------------------
   # Model-Summary: N
   # -------------------------------------
-  page.content <- paste0(page.content, sprintf(""\n  <tr>\n    <td class=\""tdata summary leftalign firstsumrow\"">%s</td>\n"", stringObservations))
+  page.content <- paste0(page.content, sprintf(""\n  <tr>\n    <td class=\""tdata summary leftalign firstsumrow\"">%s</td>\n"", string.obs))
   for (i in 1:length(input_list)) {
     # -------------------------
     # insert ""separator column""
@@ -1126,7 +1126,7 @@ sjt.lm <- function(...,
   # -------------------------------------
   # Model-Summary: r2 and sdj. r2
   # -------------------------------------
-  if (showR2) {
+  if (show.r2) {
     # first, we need the correct description for 2nd r2-value
     if (lmerob)
       r2string <- ""&Omega;<sub>0</sub><sup>2</sup>""
@@ -1163,7 +1163,7 @@ sjt.lm <- function(...,
   # -------------------------------------
   # Model-Summary: F-statistics
   # -------------------------------------
-  if (showFStat) {
+  if (show.fstat) {
     page.content <- paste(page.content, ""  <tr>\n     <td class=\""tdata leftalign summary\"">F-statistics</td>\n"")
     for (i in 1:length(input_list)) {
       # -------------------------
@@ -1196,7 +1196,7 @@ sjt.lm <- function(...,
   # -------------------------------------
   # Model-Summary: AIC
   # -------------------------------------
-  if (showAIC) {
+  if (show.aic) {
     page.content <- paste(page.content, ""  <tr>\n     <td class=\""tdata leftalign summary\"">AIC</td>\n"")
     for (i in 1:length(input_list)) {
       # -------------------------
@@ -1210,7 +1210,7 @@ sjt.lm <- function(...,
   # -------------------------------------
   # Model-Summary: AICc
   # -------------------------------------
-  if (showAICc) {
+  if (show.aicc) {
     page.content <- paste(page.content, ""  <tr>\n     <td class=\""tdata leftalign summary\"">AICc</td>\n"")
     for (i in 1:length(input_list)) {
       # -------------------------
@@ -1224,7 +1224,7 @@ sjt.lm <- function(...,
   # -------------------------------------
   # Model-Summary: deviance
   # -------------------------------------
-  if (showDeviance) {
+  if (show.dev) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">Deviance</td>"")
     for (i in 1:length(input_list)) {
       # -------------------------
@@ -1253,8 +1253,8 @@ sjt.lm <- function(...,
   # replace class attributes with inline style,
   # useful for knitr
   # -------------------------------------
-  knitr <- replace_css_styles(page.content, cellSpacing, cellGroupIndent, 
-                              p.numeric, showHeaderStrings, CSS)
+  knitr <- replace_css_styles(page.content, cell.spacing, cell.gpr.indent, 
+                              p.numeric, show.header, CSS)
   # -------------------------------------
   # remove spaces?
   # -------------------------------------
@@ -1266,7 +1266,7 @@ sjt.lm <- function(...,
   # -------------------------------------
   # check if html-content should be outputted
   # -------------------------------------
-  out.html.table(no.output, file, knitr, toWrite, useViewer)  
+  out.html.table(no.output, file, knitr, toWrite, use.viewer)  
   # -------------------------------------
   # replace &nbsp; (former NA), created by join, with empty string
   # -------------------------------------
@@ -1275,8 +1275,8 @@ sjt.lm <- function(...,
   # return results
   # -------------------------------------
   invisible(structure(class = c(""sjTable"", ""sjtlm""),
-                      list(page.style = get_table_css_styles(cellSpacing, cellGroupIndent,
-                                                             p.numeric, showHeaderStrings, CSS),
+                      list(page.style = get_table_css_styles(cell.spacing, cell.gpr.indent,
+                                                             p.numeric, show.header, CSS),
                            page.content = page.content,
                            output.complete = toWrite,
                            knitr = knitr,
@@ -1314,7 +1314,7 @@ sjt.lm <- function(...,
 #'         \code{p.kr = FALSE}, Wald chi-squared tests from the
 #'         \code{Anova}-function of the \pkg{car}-package are computed.
 #'         \cr \cr
-#'         The variance components of the random parts (see \code{showREvar}) are
+#'         The variance components of the random parts (see \code{show.re.var}) are
 #'         denoted like:
 #'         \itemize{
 #'          \item within-group variance: sigma-squared
@@ -1358,23 +1358,23 @@ sjt.lm <- function(...,
 #'          minus.sign = ""&minus;"")
 #' 
 #' # print table, using vector names as labels
-#' sjt.lmer(fit1, fit2, fit3, labelPredictors = """")
+#' sjt.lmer(fit1, fit2, fit3, pred.labels = """")
 #' 
 #' # show other statistics
 #' sjt.lmer(fit1, fit2,
-#'          showAIC = TRUE,
-#'          showConfInt = FALSE,
-#'          showStdError = TRUE,
+#'          show.aic = TRUE,
+#'          show.ci = FALSE,
+#'          show.se = TRUE,
 #'          p.numeric = FALSE)
 #'            
 #' sjt.lmer(fit1, fit2, fit3, 
-#'          showAIC = TRUE,
-#'          separateConfColumn = FALSE,
-#'          newLineConf = FALSE)
+#'          show.aic = TRUE,
+#'          separate.ci.col = FALSE,
+#'          newline.ci = FALSE)
 #'
 #' # user defined predictor labels
 #' sjt.lmer(fit1, fit2, fit3,
-#'          labelPredictors = c(""Elder's gender (female)"",
+#'          pred.labels = c(""Elder's gender (female)"",
 #'                              ""Hours of care per week"",
 #'                              ""Barthel Index"",
 #'                              ""Educational level (mid)"",
@@ -1383,66 +1383,66 @@ sjt.lm <- function(...,
 #' @export
 sjt.lmer <- function(...,
                      file = NULL,
-                     labelPredictors = NULL,
+                     pred.labels = NULL,
                      depvar.labels = NULL,
-                     stringPredictors = ""Predictors"",
-                     stringDependentVariables = ""Dependent Variables"",
-                     showHeaderStrings = FALSE,
+                     string.pred = ""Predictors"",
+                     string.dv = ""Dependent Variables"",
+                     show.header = FALSE,
                      string.interc = ""(Intercept)"",
-                     stringObservations = ""Observations"",
+                     string.obs = ""Observations"",
                      string.est = ""B"",
                      string.std = ""std. Beta"",
                      string.ci = ""CI"",
                      string.se = ""std. Error"",
-                     stringP = ""p"",
-                     showEst = TRUE,
-                     showConfInt = TRUE,
-                     showStdBeta = FALSE,
-                     showStdError = FALSE,
+                     string.p = ""p"",
+                     show.est = TRUE,
+                     show.ci = TRUE,
+                     show.std = FALSE,
+                     show.se = FALSE,
                      ci.hyphen = ""&nbsp;&ndash;&nbsp;"",
                      minus.sign = ""&#45;"",
                      digits.est = 2,
                      digits.p = 3,
                      digits.ci = 2,
                      digits.se = 2,
-                     digits.sb = 2,
+                     digits.std = 2,
                      digits.summary = 3,
                      p.numeric = TRUE,
                      boldpvalues = TRUE,
                      p.kr = TRUE,
-                     separateConfColumn = TRUE,
-                     newLineConf = TRUE,
+                     separate.ci.col = TRUE,
+                     newline.ci = TRUE,
                      group.pred = FALSE,
-                     showAbbrHeadline = TRUE,
-                     showR2 = TRUE,
-                     showICC = TRUE,
-                     showREvar = TRUE,
-                     showAIC = FALSE,
-                     showAICc = FALSE,
-                     showDeviance = TRUE,
+                     show.col.header = TRUE,
+                     show.r2 = TRUE,
+                     show.icc = TRUE,
+                     show.re.var = TRUE,
+                     show.aic = FALSE,
+                     show.aicc = FALSE,
+                     show.dev = TRUE,
                      remove.estimates = NULL,
-                     cellSpacing = 0.2,
-                     cellGroupIndent = 0.6,
+                     cell.spacing = 0.2,
+                     cell.gpr.indent = 0.6,
                      encoding = NULL,
                      CSS = NULL,
-                     useViewer = TRUE,
+                     use.viewer = TRUE,
                      no.output = FALSE,
                      remove.spaces = TRUE) {
   input_list <- list(...)
-  return(sjt.lm(input_list, file = file, labelPredictors = labelPredictors, 
-                depvar.labels = depvar.labels, stringPredictors = stringPredictors, 
-                stringDependentVariables = stringDependentVariables, 
-                showHeaderStrings = showHeaderStrings, string.interc = string.interc,
-                stringObservations = stringObservations, string.est = string.est, string.std = string.std, 
-                string.ci = string.ci, string.se = string.se, stringP = stringP, showEst = showEst,
-                showConfInt = showConfInt, showStdBeta = showStdBeta, showStdError = showStdError, 
+  return(sjt.lm(input_list, file = file, pred.labels = pred.labels, 
+                depvar.labels = depvar.labels, string.pred = string.pred, 
+                string.dv = string.dv, 
+                show.header = show.header, string.interc = string.interc,
+                string.obs = string.obs, string.est = string.est, string.std = string.std, 
+                string.ci = string.ci, string.se = string.se, string.p = string.p, show.est = show.est,
+                show.ci = show.ci, show.std = show.std, show.se = show.se, 
                 ci.hyphen = ci.hyphen, minus.sign = minus.sign,
                 digits.est = digits.est, digits.p = digits.p, digits.ci = digits.ci,
-                digits.se = digits.se, digits.sb = digits.sb, digits.summary = digits.summary, 
+                digits.se = digits.se, digits.std = digits.std, digits.summary = digits.summary, 
                 p.numeric = p.numeric, boldpvalues = boldpvalues, p.kr = p.kr,
-                separateConfColumn = separateConfColumn, newLineConf = newLineConf, 
-                group.pred = group.pred, showAbbrHeadline = showAbbrHeadline, showR2 = showR2, showICC = showICC, 
-                showREvar = showREvar, showFStat = FALSE, showAIC = showAIC, showAICc = showAICc, showDeviance = showDeviance,
-                remove.estimates = remove.estimates, cellSpacing = cellSpacing, cellGroupIndent = cellGroupIndent, encoding = encoding, 
-                CSS = CSS, useViewer = useViewer, no.output = no.output, remove.spaces = remove.spaces))
+                separate.ci.col = separate.ci.col, newline.ci = newline.ci, 
+                group.pred = group.pred, show.col.header = show.col.header, show.r2 = show.r2, show.icc = show.icc, 
+                show.re.var = show.re.var, show.fstat = FALSE, show.aic = show.aic, show.aicc = show.aicc, show.dev = show.dev,
+                remove.estimates = remove.estimates, cell.spacing = cell.spacing, cell.gpr.indent = cell.gpr.indent, encoding = encoding, 
+                CSS = CSS, use.viewer = use.viewer, no.output = no.output, remove.spaces = remove.spaces))
 }
\ No newline at end of file

---FILE: R/sjTabMannWhitney.R---
@@ -37,7 +37,7 @@ sjt.mwu <- function(x,
                     file=NULL,
                     encoding=NULL,
                     CSS=NULL,
-                    useViewer = TRUE, 
+                    use.viewer = TRUE, 
                     no.output = FALSE,
                     remove.spaces = TRUE) {
   # --------------------------------------------------------
@@ -71,12 +71,12 @@ sjt.mwu <- function(x,
                  CSS = CSS,
                  no.output = T,
                  encoding = encoding,
-                 hideProgressBar = T,
+                 hide.progress = T,
                  remove.spaces = remove.spaces)
   # -------------------------------------
   # check if html-content should be printed
   # -------------------------------------
-  out.html.table(no.output, file, html$knitr, html$output.complete, useViewer)  
+  out.html.table(no.output, file, html$knitr, html$output.complete, use.viewer)  
   invisible(list(class = c(""sjTable"", ""sjtmwu""),
                  df = x$tab.df, 
                  page.style = html$page.style,

---FILE: R/sjTabOdds.R---
@@ -14,31 +14,26 @@ utils::globalVariables(c(""starts_with""))
 #'          confidence intervals are exponentiated. Use \code{FALSE} for 
 #'          non-exponentiated coefficients (log-odds) as provided by 
 #'          the \code{\link{summary}} function.
-#' @param newLineConf logical, if \code{TRUE} and \code{separateConfColumn = FALSE}, inserts a line break
-#'          between OR and CI values. If \code{FALSE}, CI values are printed in the same
-#'          line with OR values.
-#' @param showAbbrHeadline logical, if \code{TRUE} (default), the table data columns have a headline with 
-#'          abbreviations for odds ratios, confidence interval and p-values.
 #' @param show.r2 logical, if \code{TRUE} (default), the pseudo R2 values for each model are printed
 #'          in the model summary. R2cs is the Cox-Snell-pseudo R-squared value, R2n is Nagelkerke's 
 #'          pseudo R-squared value and \code{D} is Tjur's Coefficient of Discrimination
 #'          (see \code{\link[sjmisc]{cod}}).
 #' @param show.loglik logical, if \code{TRUE}, the Log-Likelihood for each model is printed
 #'          in the model summary. Default is \code{FALSE}.
-#' @param showChi2 logical, if \code{TRUE}, the p-value of the chi-squared value for each 
+#' @param show.chi2 logical, if \code{TRUE}, the p-value of the chi-squared value for each 
 #'          model's residual deviance against the null deviance is printed
 #'          in the model summary. Default is \code{FALSE}. A well-fitting model
 #'          with predictors should significantly differ from the null-model
 #'          (without predictors), thus, a p-value less than 0.05 indicates a
 #'          good model-fit.
-#' @param showHosLem logical, if \code{TRUE}, a Hosmer-Lemeshow-Goodness-of-fit-test is
+#' @param show.hoslem logical, if \code{TRUE}, a Hosmer-Lemeshow-Goodness-of-fit-test is
 #'          performed. A well-fitting model shows no significant difference between 
 #'          the model and the observed data, i.e. the reported p-values should be
 #'          greater than 0.05.
-#' @param showFamily logical, if \code{TRUE}, the family object and link function for each fitted model
+#' @param show.family logical, if \code{TRUE}, the family object and link function for each fitted model
 #'          are printed. Can be used in case you want to compare models with different link functions
 #'          and same predictors and response, to decide which model fits best. See \code{\link{family}}
-#'          for more details. It is recommended to inspect the model \code{\link{AIC}} (see \code{showAIC}) to get a
+#'          for more details. It is recommended to inspect the model \code{\link{AIC}} (see \code{show.aic}) to get a
 #'          decision help for which model to choose.
 #'          
 #' @inheritParams sjt.frq
@@ -77,29 +72,29 @@ utils::globalVariables(c(""starts_with""))
 #' # open HTML-table in RStudio Viewer Pane or web browser
 #' sjt.glm(fitOR1, fitOR2, 
 #'         depvar.labels = c(""Fertility"", ""Infant Mortality""),
-#'         labelPredictors = c(""Education"", ""Examination"", ""Catholic""),
+#'         pred.labels = c(""Education"", ""Examination"", ""Catholic""),
 #'         ci.hyphen = "" to "")
 #' 
 #' # open HTML-table in RStudio Viewer Pane or web browser,
 #' # integrate CI in OR column
 #' sjt.glm(fitOR1, fitOR2, fitOR3,
-#'         labelPredictors = c(""Education"", ""Examination"", ""Catholic""),
-#'         separateConfColumn = FALSE)
+#'         pred.labels = c(""Education"", ""Examination"", ""Catholic""),
+#'         separate.ci.col = FALSE)
 #' 
 #' # open HTML-table in RStudio Viewer Pane or web browser,
 #' # indicating p-values as numbers and printing CI in a separate column
 #' sjt.glm(fitOR1, fitOR2, fitOR3,
 #'         depvar.labels = c(""Fertility"", ""Infant Mortality"", ""Agriculture""),
-#'         labelPredictors = c(""Education"", ""Examination"", ""Catholic""))
+#'         pred.labels = c(""Education"", ""Examination"", ""Catholic""))
 #' 
 #' 
 #' # -------------------------------------------- 
 #' # User defined style sheet
 #' # -------------------------------------------- 
 #' sjt.glm(fitOR1, fitOR2, fitOR3,
 #'         depvar.labels = c(""Fertility"", ""Infant Mortality"", ""Agriculture""),
-#'         labelPredictors = c(""Education"", ""Examination"", ""Catholic""),
-#'         showHeaderStrings = TRUE,
+#'         pred.labels = c(""Education"", ""Examination"", ""Catholic""),
+#'         show.header = TRUE,
 #'         CSS = list(css.table = ""border: 2px solid;"",
 #'                    css.tdata = ""border: 1px solid;"",
 #'                    css.depvarhead = ""color:#003399;""))
@@ -123,7 +118,7 @@ utils::globalVariables(c(""starts_with""))
 #'             data = efc, family = poisson(link = ""log""))
 #'             
 #' # compare models
-#' sjt.glm(fit1, fit2, fit3, showAIC = TRUE, showFamily = TRUE)
+#' sjt.glm(fit1, fit2, fit3, show.aic = TRUE, show.family = TRUE)
 #' 
 #' 
 #' # --------------------------------------------
@@ -132,15 +127,15 @@ utils::globalVariables(c(""starts_with""))
 #' # open HTML-table in RStudio Viewer Pane or web browser,
 #' # table indicating p-values as stars
 #' sjt.glm(fit1, fit2, fit3, p.numeric = FALSE,
-#'         showAIC = TRUE, showFamily = TRUE)
+#'         show.aic = TRUE, show.family = TRUE)
 #' 
 #' # open HTML-table in RStudio Viewer Pane or web browser,
 #' # indicating p-values as stars and integrate CI in OR column
 #' sjt.glm(fit1, fit2, fit3, 
 #'         p.numeric = FALSE,
-#'         separateConfColumn = FALSE,
-#'         showAIC = TRUE, 
-#'         showFamily = TRUE,
+#'         separate.ci.col = FALSE,
+#'         show.aic = TRUE, 
+#'         show.family = TRUE,
 #'         show.r2 = TRUE)
 #' 
 #' # ---------------------------------- 
@@ -182,17 +177,17 @@ utils::globalVariables(c(""starts_with""))
 #' @export
 sjt.glm <- function(...,
                     file = NULL,
-                    labelPredictors = NULL,
+                    pred.labels = NULL,
                     depvar.labels = NULL,
-                    stringPredictors = ""Predictors"",
-                    stringDependentVariables = ""Dependent Variables"",
-                    showHeaderStrings = FALSE,
+                    string.pred = ""Predictors"",
+                    string.dv = ""Dependent Variables"",
+                    show.header = FALSE,
                     string.interc = ""(Intercept)"",
-                    stringObservations = ""Observations"",
+                    string.obs = ""Observations"",
                     string.est = ""OR"",
                     string.ci = ""CI"",
                     string.se = ""std. Error"",
-                    stringP = ""p"",
+                    string.p = ""p"",
                     digits.est = 2,
                     digits.p = 3,
                     digits.ci = 2,
@@ -201,29 +196,29 @@ sjt.glm <- function(...,
                     exp.coef = TRUE,
                     p.numeric = TRUE,
                     boldpvalues = TRUE,
-                    showConfInt = TRUE,
-                    showStdError = FALSE,
+                    show.ci = TRUE,
+                    show.se = FALSE,
                     ci.hyphen = ""&nbsp;&ndash;&nbsp;"",
-                    separateConfColumn = TRUE,
-                    newLineConf = TRUE,
+                    separate.ci.col = TRUE,
+                    newline.ci = TRUE,
                     group.pred = TRUE,
-                    showAbbrHeadline = TRUE,
+                    show.col.header = TRUE,
                     show.r2 = FALSE,
-                    showICC = FALSE,
-                    showREvar = FALSE,
+                    show.icc = FALSE,
+                    show.re.var = FALSE,
                     show.loglik = FALSE,
-                    showAIC = FALSE,
-                    showAICc = FALSE,
-                    showDeviance = FALSE,
-                    showChi2 = FALSE,
-                    showHosLem = FALSE,
-                    showFamily = FALSE,
+                    show.aic = FALSE,
+                    show.aicc = FALSE,
+                    show.dev = FALSE,
+                    show.chi2 = FALSE,
+                    show.hoslem = FALSE,
+                    show.family = FALSE,
                     remove.estimates = NULL,
-                    cellSpacing = 0.2,
-                    cellGroupIndent = 0.6,
+                    cell.spacing = 0.2,
+                    cell.gpr.indent = 0.6,
                     encoding = NULL,
                     CSS = NULL,
-                    useViewer = TRUE,
+                    use.viewer = TRUE,
                     no.output = FALSE,
                     remove.spaces = TRUE) {
   
@@ -247,7 +242,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   # init header
   # -------------------------------------
-  toWrite <- get_table_header(encoding, cellSpacing, cellGroupIndent, p.numeric, showHeaderStrings, CSS)
+  toWrite <- get_table_header(encoding, cell.spacing, cell.gpr.indent, p.numeric, show.header, CSS)
   # ------------------------
   # retrieve fitted models
   # ------------------------
@@ -267,9 +262,9 @@ sjt.glm <- function(...,
   # ------------------------
   # should AICc be computed? Check for package
   # ------------------------
-  if (showAICc && !requireNamespace(""AICcmodavg"", quietly = TRUE)) {
-    warning(""Package `AICcmodavg` needed to show AICc. Argument `showAICc` will be ignored."", call. = FALSE)
-    showAICc <- FALSE
+  if (show.aicc && !requireNamespace(""AICcmodavg"", quietly = TRUE)) {
+    warning(""Package `AICcmodavg` needed to show AICc. Argument `show.aicc` will be ignored."", call. = FALSE)
+    show.aicc <- FALSE
   }
   # ------------------------
   # check for stepwise models, when fitted models
@@ -292,7 +287,7 @@ sjt.glm <- function(...,
   # are simple linear models
   # ------------------------
   else {
-    showICC <- FALSE
+    show.icc <- FALSE
     # check if we have different amount of coefficients
     # in fitted models - if yes, we have e.g. stepwise models
     sw.fit <- length(unique(sapply(input_list, function(x) length(stats::coef(x))))) > 1
@@ -453,8 +448,8 @@ sjt.glm <- function(...,
   # if confidence interval should be omitted,
   # don't use separate column for CI!
   # -------------------------------------
-  if (!showConfInt) {
-    separateConfColumn <- FALSE
+  if (!show.ci) {
+    separate.ci.col <- FALSE
     showCIString <- string.est
   } else {
     showCIString <- sprintf(""%s (%s)"", string.est, string.ci)
@@ -470,26 +465,26 @@ sjt.glm <- function(...,
   # (B, p, CI, se...)
   headerColSpanFactor <- 1
   if (p.numeric) headerColSpanFactor <- headerColSpanFactor + 1
-  if (separateConfColumn) headerColSpanFactor <- headerColSpanFactor + 1
-  if (showStdError) headerColSpanFactor <- headerColSpanFactor + 1
+  if (separate.ci.col) headerColSpanFactor <- headerColSpanFactor + 1
+  if (show.se) headerColSpanFactor <- headerColSpanFactor + 1
   # now that we know how many columns each model needs,
   # we multiply columns per model with count of models, so we have
   # the column span over all models together; furthermore, we add
   # count of models  to the overall column span, because
   # each model is separated with an empty table column
   headerColSpan <- headerColSpanFactor * headerColSpan + length(input_list)
   linebreakstring <- "" ""
-  if (newLineConf) linebreakstring <- ""<br>""
+  if (newline.ci) linebreakstring <- ""<br>""
   # -------------------------------------
   # start table
   # -------------------------------------
   page.content <- ""<table>""
   # -------------------------------------
   # check if we want to see header strings
   # -------------------------------------
-  if (showHeaderStrings) {
-    page.content <- paste0(page.content, sprintf(""\n  <tr>\n    <td class=\""tdata topborder\"" rowspan=\""2\""><em>%s</em></td>"", stringPredictors))
-    page.content <- paste0(page.content, sprintf(""\n    <td colspan=\""%i\"" class=\""tdata topborder depvarhead\""><em>%s</em></td>"", headerColSpan, stringDependentVariables))
+  if (show.header) {
+    page.content <- paste0(page.content, sprintf(""\n  <tr>\n    <td class=\""tdata topborder\"" rowspan=\""2\""><em>%s</em></td>"", string.pred))
+    page.content <- paste0(page.content, sprintf(""\n    <td colspan=\""%i\"" class=\""tdata topborder depvarhead\""><em>%s</em></td>"", headerColSpan, string.dv))
     page.content <- paste0(page.content, ""\n  </tr>\n"")
   }
   # -------------------------------------
@@ -501,7 +496,7 @@ sjt.glm <- function(...,
   # so we need to insert an empty cell here
   # -------------------------------------
   tcp <- """"
-  if (!showHeaderStrings) {
+  if (!show.header) {
     page.content <- paste0(page.content, ""\n    <td class=\""tdata topborder\"">&nbsp;</td>"")
     tcp <- "" topborder""
   }
@@ -515,16 +510,16 @@ sjt.glm <- function(...,
   # -------------------------------------
   # set default predictor labels
   # -------------------------------------
-  if (is.null(labelPredictors)) {
-    labelPredictors <- suppressWarnings(retrieveModelLabels(input_list, group.pred = group.pred))
+  if (is.null(pred.labels)) {
+    pred.labels <- suppressWarnings(retrieveModelLabels(input_list, group.pred = group.pred))
   }
   # --------------------------------------------------------
   # auto-retrieving variable labels does not work when we
   # have factors with different levels, which appear as 
   # ""multiple predictors"", but are only one variable
   # --------------------------------------------------------
-  if (is.null(labelPredictors) || length(labelPredictors) < length(joined.df[-1, 1])) {
-    labelPredictors <- joined.df[-1, 1]
+  if (is.null(pred.labels) || length(pred.labels) < length(joined.df[-1, 1])) {
+    pred.labels <- joined.df[-1, 1]
   }
   # -------------------------------------
   # should factor predictors be grouped?
@@ -544,7 +539,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   # table header: column labels or/ci and p-labels
   # -------------------------------------
-  if (showAbbrHeadline) {
+  if (show.col.header) {
     page.content <- paste0(page.content, ""\n  <tr>\n    <td class=\""tdata colnames\"">&nbsp;</td>"")
     colnr <- ifelse(is.null(depvar.labels), length(input_list), length(depvar.labels))
     for (i in 1:colnr) {
@@ -553,18 +548,18 @@ sjt.glm <- function(...,
       # -------------------------
       page.content <- paste0(page.content, ""<td class=\""separatorcol colnames\"">&nbsp;</td>"")
       # confidence interval in separate column
-      if (separateConfColumn) {
+      if (separate.ci.col) {
         page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign colnames modelcolumn1\"">%s</td>"", string.est))
-        if (showConfInt) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign colnames modelcolumn2\"">%s</td>"", string.ci))
+        if (show.ci) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign colnames modelcolumn2\"">%s</td>"", string.ci))
       }
       else {
         # confidence interval in Beta-column
         page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign colnames modelcolumn1\"">%s</td>"", showCIString))
       }
       # show std. error
-      if (showStdError) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign colnames modelcolumn3\"">%s</td>"", string.se))
+      if (show.se) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign colnames modelcolumn3\"">%s</td>"", string.se))
       # show p-values as numbers in separate column
-      if (p.numeric) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign colnames modelcolumn4\"">%s</td>"", stringP))
+      if (p.numeric) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign colnames modelcolumn4\"">%s</td>"", string.p))
     }
     page.content <- paste(page.content, ""\n  </tr>\n"")
   }
@@ -593,15 +588,15 @@ sjt.glm <- function(...,
     # -------------------------
     page.content <- paste0(page.content, sprintf(""<td class=\""separatorcol %s\"">&nbsp;</td>"", tcb_class))
     # confidence interval in separate column
-    if (separateConfColumn) {
+    if (separate.ci.col) {
       # open table cell for Beta-coefficient
       page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign %smodelcolumn1\"">%s"", 
                                                    tcb_class, 
                                                    joined.df[1, (i - 1) * 5 + 2]))
       # if p-values are not shown as numbers, insert them after beta-value
       if (!p.numeric) page.content <- paste0(page.content, sprintf(""&nbsp;%s"", joined.df[1, (i - 1) * 5 + 5]))
       # if we have CI, start new table cell (CI in separate column)
-      if (showConfInt) {
+      if (show.ci) {
         page.content <- paste0(page.content, sprintf(""</td><td class=\""tdata centeralign %smodelcolumn2\"">%s%s%s</td>"", 
                                                      tcb_class, 
                                                      joined.df[1, (i - 1) * 5 + 3], 
@@ -616,7 +611,7 @@ sjt.glm <- function(...,
                                                    tcb_class, 
                                                    joined.df[1, (i - 1) * 5 + 2]))
       # confidence interval in Beta-column
-      if (showConfInt) page.content <- paste0(page.content, sprintf(""%s(%s%s%s)"", 
+      if (show.ci) page.content <- paste0(page.content, sprintf(""%s(%s%s%s)"", 
                                                                     linebreakstring, 
                                                                     joined.df[1, (i - 1) * 5 + 3], 
                                                                     ci.hyphen,
@@ -626,7 +621,7 @@ sjt.glm <- function(...,
       page.content <- paste0(page.content, ""</td>"")
     }
     # show std. error
-    if (showStdError) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign %smodelcolumn3\"">%s</td>"",
+    if (show.se) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign %smodelcolumn3\"">%s</td>"",
                                                                    tcb_class,
                                                                    joined.df[1, (i - 1) * 5 + 6]))
     # show p-values as numbers in separate column
@@ -655,7 +650,7 @@ sjt.glm <- function(...,
     } else {
       indent.tag <- ""tdata""
     }
-    page.content <- paste0(page.content, ""\n  <tr>\n"", sprintf(""    <td class=\""%s leftalign\"">%s</td>"", indent.tag, labelPredictors[i]))
+    page.content <- paste0(page.content, ""\n  <tr>\n"", sprintf(""    <td class=\""%s leftalign\"">%s</td>"", indent.tag, pred.labels[i]))
     # ---------------------------------------
     # go through fitted model's statistics
     # ---------------------------------------
@@ -676,15 +671,15 @@ sjt.glm <- function(...,
       # -------------------------
       page.content <- paste0(page.content, ""<td class=\""separatorcol\"">&nbsp;</td>"")
       # confidence interval in separate column
-      if (separateConfColumn) {
+      if (separate.ci.col) {
         # open table cell for Beta-coefficient
         page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign modelcolumn1\"">%s"", 
                                                      joined.df[i + 1, (j - 1) * 5 + 2]))
         # if p-values are not shown as numbers, insert them after beta-value
         if (!p.numeric) page.content <- paste0(page.content, sprintf(""&nbsp;%s"", 
                                                                             joined.df[i + 1, (j - 1) * 5 + 5]))
         # if we have CI, start new table cell (CI in separate column)
-        if (showConfInt) {
+        if (show.ci) {
           page.content <- paste0(page.content, sprintf(""</td><td class=\""tdata centeralign modelcolumn2\"">%s%s%s</td>"", 
                                                        ci.lo, 
                                                        ci.sep.string, 
@@ -697,7 +692,7 @@ sjt.glm <- function(...,
         page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign modelcolumn1\"">%s"", 
                                                      joined.df[i + 1, (j - 1) * 5 + 2]))
         # confidence interval in Beta-column
-        if (showConfInt && !sjmisc::is_empty(ci.lo)) page.content <- paste0(page.content, 
+        if (show.ci && !sjmisc::is_empty(ci.lo)) page.content <- paste0(page.content, 
                                                                             sprintf(""%s(%s%s%s)"", 
                                                                                     linebreakstring, 
                                                                                     ci.lo, 
@@ -709,7 +704,7 @@ sjt.glm <- function(...,
         page.content <- paste0(page.content, ""</td>"")
       }
       # show std. error
-      if (showStdError) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign modelcolumn3\"">%s</td>"", 
+      if (show.se) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign modelcolumn3\"">%s</td>"", 
                                                                      joined.df[i + 1, (j - 1) * 5 + 6]))
       # show p-values as numbers in separate column
       if (p.numeric) page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign modelcolumn4\"">%s</td>"", 
@@ -746,7 +741,7 @@ sjt.glm <- function(...,
     # -------------------------------------
     # show variance components?
     # -------------------------------------
-    if (showREvar) {
+    if (show.re.var) {
       # -------------------------------------
       # lets check which mdoels have random slopes, needed later
       # -------------------------------------
@@ -836,7 +831,7 @@ sjt.glm <- function(...,
     # -------------------------------------
     # Model-Summary: icc
     # -------------------------------------
-    if (showICC) {
+    if (show.icc) {
       # get icc from models
       summary.icc <- sjmisc::icc(input_list[[which.max(all_mm_counts)]])
       # iterate icc's
@@ -866,7 +861,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   # Model-Summary: N
   # -------------------------------------
-  page.content <- paste0(page.content, sprintf(""\n  <tr>\n    <td class=\""tdata summary leftalign firstsumrow\"">%s</td>"", stringObservations))
+  page.content <- paste0(page.content, sprintf(""\n  <tr>\n    <td class=\""tdata summary leftalign firstsumrow\"">%s</td>"", string.obs))
   for (i in 1:length(input_list)) {
     # -------------------------
     # insert ""separator column""
@@ -920,7 +915,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   # Model-Summary: AIC
   # -------------------------------------
-  if (showAIC) {
+  if (show.aic) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">AIC</td>"")
     for (i in 1:length(input_list)) {
       # -------------------------
@@ -934,7 +929,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   # Model-Summary: AICc
   # -------------------------------------
-  if (showAICc) {
+  if (show.aicc) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">AICc</td>"")
     for (i in 1:length(input_list)) {
       # -------------------------
@@ -962,7 +957,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   # Model-Summary: deviance
   # -------------------------------------
-  if (showDeviance) {
+  if (show.dev) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">Deviance</td>"")
     for (i in 1:length(input_list)) {
       # -------------------------
@@ -976,7 +971,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   # Model-Summary: Chi2
   # -------------------------------------
-  if (showChi2) {
+  if (show.chi2) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">&Chi;<sup>2</sup><sub>deviance</sub></td>"")
     for (i in 1:length(input_list)) {
       # -------------------------
@@ -1033,7 +1028,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   # Model-Summary: Hosmer-Lemeshow-GOF
   # -------------------------------------
-  if (showHosLem) {
+  if (show.hoslem) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">Hosmer-Lemeshow-&Chi;<sup>2</sup></td>"")
     for (i in 1:length(input_list)) {
       # -------------------------
@@ -1063,7 +1058,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   # Model-Summary: Family
   # -------------------------------------
-  if (showFamily) {
+  if (show.family) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">Family</td>"")
     for (i in 1:length(input_list)) {
       # -------------------------
@@ -1092,8 +1087,8 @@ sjt.glm <- function(...,
   # replace class attributes with inline style,
   # useful for knitr
   # -------------------------------------
-  knitr <- replace_css_styles(page.content, cellSpacing, cellGroupIndent, 
-                              p.numeric, showHeaderStrings, CSS)
+  knitr <- replace_css_styles(page.content, cell.spacing, cell.gpr.indent, 
+                              p.numeric, show.header, CSS)
   # -------------------------------------
   # remove spaces?
   # -------------------------------------
@@ -1105,7 +1100,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   # check if html-content should be outputted
   # -------------------------------------
-  out.html.table(no.output, file, knitr, toWrite, useViewer)
+  out.html.table(no.output, file, knitr, toWrite, use.viewer)
   # -------------------------------------
   # replace &nbsp; (former NA), created by join, with empty string
   # -------------------------------------
@@ -1114,8 +1109,8 @@ sjt.glm <- function(...,
   # return results
   # -------------------------------------
   invisible(structure(class = c(""sjTable"", ""sjtglm""),
-                      list(page.style = get_table_css_styles(cellSpacing, cellGroupIndent,
-                                                             p.numeric, showHeaderStrings, CSS),
+                      list(page.style = get_table_css_styles(cell.spacing, cell.gpr.indent,
+                                                             p.numeric, show.header, CSS),
                            page.content = page.content,
                            output.complete = toWrite,
                            knitr = knitr,
@@ -1146,7 +1141,7 @@ sjt.glm <- function(...,
 #' @note Computation of p-values (if necessary) are based on Wald chi-squared tests from the 
 #'         \code{Anova}-function of the \pkg{car}-package.
 #'         \cr \cr
-#'         The variance components of the random parts (see \code{showREvar}) are
+#'         The variance components of the random parts (see \code{show.re.var}) are
 #'         denoted like:
 #'         \itemize{
 #'          \item between-group-variance: tau-zero-zero
@@ -1188,37 +1183,37 @@ sjt.glm <- function(...,
 #' 
 #' # print summary table, using different table layout
 #' sjt.glmer(fit1, fit2,
-#'           showAIC = TRUE,
-#'           showConfInt = FALSE,
-#'           showStdError = TRUE,
+#'           show.aic = TRUE,
+#'           show.ci = FALSE,
+#'           show.se = TRUE,
 #'           p.numeric = FALSE)
 #'           
 #' # print summary table
 #' sjt.glmer(fit1, fit2,
-#'           labelPredictors = c(""Elder's gender (female)"",
+#'           pred.labels = c(""Elder's gender (female)"",
 #'                               ""Hours of care per week"",
 #'                               ""Negative Impact"",
 #'                               ""Educational level (mid)"",
 #'                               ""Educational level (high)""))
 #' 
 #' # use vector names as predictor labels
-#' sjt.glmer(fit1, fit2, labelPredictors = """")}
+#' sjt.glmer(fit1, fit2, pred.labels = """")}
 #' 
 #' 
 #' @export
 sjt.glmer <- function(...,
                       file = NULL,
-                      labelPredictors = NULL,
+                      pred.labels = NULL,
                       depvar.labels = NULL,
-                      stringPredictors = ""Predictors"",
-                      stringDependentVariables = ""Dependent Variables"",
-                      showHeaderStrings = FALSE,
+                      string.pred = ""Predictors"",
+                      string.dv = ""Dependent Variables"",
+                      show.header = FALSE,
                       string.interc = ""(Intercept)"",
-                      stringObservations = ""Observations"",
+                      string.obs = ""Observations"",
                       string.est = ""OR"",
                       string.ci = ""CI"",
                       string.se = ""std. Error"",
-                      stringP = ""p"",
+                      string.p = ""p"",
                       digits.est = 2,
                       digits.p = 3,
                       digits.ci = 2,
@@ -1227,46 +1222,46 @@ sjt.glmer <- function(...,
                       exp.coef = TRUE,
                       p.numeric = TRUE,
                       boldpvalues = TRUE,
-                      showConfInt = TRUE,
-                      showStdError = FALSE,
+                      show.ci = TRUE,
+                      show.se = FALSE,
                       ci.hyphen = ""&nbsp;&ndash;&nbsp;"",
-                      separateConfColumn = TRUE,
-                      newLineConf = TRUE,
+                      separate.ci.col = TRUE,
+                      newline.ci = TRUE,
                       group.pred = FALSE,
-                      showAbbrHeadline = TRUE,
+                      show.col.header = TRUE,
                       show.r2 = FALSE,
-                      showICC = TRUE,
-                      showREvar = TRUE,
+                      show.icc = TRUE,
+                      show.re.var = TRUE,
                       show.loglik = FALSE,
-                      showAIC = FALSE,
-                      showAICc = FALSE,
-                      showDeviance = TRUE,
-                      showHosLem = FALSE,
-                      showFamily = FALSE,
+                      show.aic = FALSE,
+                      show.aicc = FALSE,
+                      show.dev = TRUE,
+                      show.hoslem = FALSE,
+                      show.family = FALSE,
                       remove.estimates = NULL,
-                      cellSpacing = 0.2,
-                      cellGroupIndent = 0.6,
+                      cell.spacing = 0.2,
+                      cell.gpr.indent = 0.6,
                       encoding = NULL,
                       CSS = NULL,
-                      useViewer = TRUE,
+                      use.viewer = TRUE,
                       no.output = FALSE,
                       remove.spaces = TRUE) {
   
   input_list <- list(...)
-  return(sjt.glm(input_list, file = file, labelPredictors = labelPredictors, 
-                 depvar.labels = depvar.labels, stringPredictors = stringPredictors, 
-                 stringDependentVariables = stringDependentVariables, showHeaderStrings = showHeaderStrings, 
+  return(sjt.glm(input_list, file = file, pred.labels = pred.labels, 
+                 depvar.labels = depvar.labels, string.pred = string.pred, 
+                 string.dv = string.dv, show.header = show.header, 
                  string.interc = string.interc,
-                 stringObservations = stringObservations, string.est = string.est,
-                 string.ci = string.ci, string.se = string.se, stringP = stringP, 
+                 string.obs = string.obs, string.est = string.est,
+                 string.ci = string.ci, string.se = string.se, string.p = string.p, 
                  digits.est = digits.est, digits.p = digits.p, digits.ci = digits.ci,
                  digits.se = digits.se, digits.summary = digits.summary, exp.coef = exp.coef,
                  p.numeric = p.numeric, boldpvalues = boldpvalues, 
-                 showConfInt = showConfInt, showStdError = showStdError, 
-                 ci.hyphen = ci.hyphen, separateConfColumn = separateConfColumn, newLineConf = newLineConf, 
-                 group.pred = group.pred, showAbbrHeadline = showAbbrHeadline, show.r2 = show.r2, showICC = showICC, 
-                 showREvar = showREvar, show.loglik = show.loglik, showAIC = showAIC, showAICc = showAICc, showDeviance = showDeviance,
-                 showChi2 = FALSE, showHosLem = showHosLem, showFamily = showFamily, remove.estimates = remove.estimates, 
-                 cellSpacing = cellSpacing, cellGroupIndent = cellGroupIndent, encoding = encoding, 
-                 CSS = CSS, useViewer = useViewer, no.output = no.output, remove.spaces = remove.spaces))
+                 show.ci = show.ci, show.se = show.se, 
+                 ci.hyphen = ci.hyphen, separate.ci.col = separate.ci.col, newline.ci = newline.ci, 
+                 group.pred = group.pred, show.col.header = show.col.header, show.r2 = show.r2, show.icc = show.icc, 
+                 show.re.var = show.re.var, show.loglik = show.loglik, show.aic = show.aic, show.aicc = show.aicc, show.dev = show.dev,
+                 show.chi2 = FALSE, show.hoslem = show.hoslem, show.family = show.family, remove.estimates = remove.estimates, 
+                 cell.spacing = cell.spacing, cell.gpr.indent = cell.gpr.indent, encoding = encoding, 
+                 CSS = CSS, use.viewer = use.viewer, no.output = no.output, remove.spaces = remove.spaces))
 }
\ No newline at end of file

---FILE: R/sjTabPCA.R---
@@ -143,7 +143,7 @@ sjt.pca <- function(data,
                     stringCpov = ""Cumulative Proportion"",
                     encoding = NULL,
                     CSS = NULL,
-                    useViewer = TRUE,
+                    use.viewer = TRUE,
                     no.output = FALSE,
                     remove.spaces = TRUE) {
   # -------------------------------------
@@ -580,7 +580,7 @@ sjt.pca <- function(data,
   # -------------------------------------
   # check if html-content should be outputted
   # -------------------------------------
-  out.html.table(no.output, file, knitr, toWrite, useViewer) 
+  out.html.table(no.output, file, knitr, toWrite, use.viewer) 
   # -------------------------------------
   # return results
   # -------------------------------------

---FILE: R/sjTabPropTable.R---
@@ -16,9 +16,6 @@
 #' @param show.col.prc logical, if \code{TRUE}, column percentage values are shown
 #' @param show.obs logical, if \code{TRUE}, observed values are shown
 #' @param show.exp logical, if \code{TRUE}, expected values are also shown
-#' @param showHorizontalLine logical, if \code{TRUE}, data rows are separated with a horizontal line
-#' @param show.na logical, if \code{TRUE}, \code{\link{NA}}'s (missing values) are also printed in the table.
-#' @param labelNA The label for the missing column/row.
 #' @param tdcol.n Color for highlighting count (observed) values in table cells. Default is black.
 #' @param tdcol.expected Color for highlighting expected values in table cells. Default is cyan.
 #' @param tdcol.cell Color for highlighting cell percentage values in table cells. Default is red.
@@ -74,7 +71,6 @@
 #' 
 #' # print minimal cross table with labels, total col/row highlighted
 #' sjt.xtab(efc$e16sex, efc$e42dep, 
-#'          showHorizontalLine = FALSE,
 #'          show.cell.prc = FALSE,
 #'          highlightTotal = TRUE)
 #' 
@@ -104,11 +100,9 @@ sjt.xtab <- function(var.row,
                      show.row.prc = FALSE,
                      show.col.prc = FALSE,
                      show.exp = FALSE,
-                     showHorizontalLine = FALSE,
                      show.summary = TRUE,
                      show.legend = FALSE,
                      show.na = FALSE,
-                     labelNA = ""NA"",
                      tdcol.n = ""black"",
                      tdcol.expected = ""#339999"",
                      tdcol.cell = ""#993333"",
@@ -120,7 +114,7 @@ sjt.xtab <- function(var.row,
                      hundret = ""100.0"",
                      encoding = NULL,
                      CSS = NULL,
-                     useViewer = TRUE,
+                     use.viewer = TRUE,
                      no.output = FALSE,
                      remove.spaces = TRUE) {
   # --------------------------------------------------------
@@ -248,7 +242,7 @@ sjt.xtab <- function(var.row,
   css.totcol <- ifelse(isTRUE(highlightTotal), sprintf("" background-color:%s;"", highlightColor), """")
   css.tothi <- ""font-weight:bolder; font-style:italic;""
   css.summary <- ""text-align:right; font-size:0.9em; font-style:italic;""
-  css.horline <- ifelse(isTRUE(showHorizontalLine), ""border-bottom:1px solid;"", """")
+  css.horline <- """"
   # ------------------------
   # check user defined style sheets
   # ------------------------
@@ -548,7 +542,7 @@ sjt.xtab <- function(var.row,
   # -------------------------------------
   # check if html-content should be printed
   # -------------------------------------
-  out.html.table(no.output, file, knitr, toWrite, useViewer)   
+  out.html.table(no.output, file, knitr, toWrite, use.viewer)   
   # -------------------------------------
   # return results
   # -------------------------------------

---FILE: R/sjTabSPSS.R---
@@ -20,18 +20,16 @@
 #' @param show.id logical, if \code{TRUE} (default), the variable ID is shown in the first column.
 #' @param show.values logical, if \code{TRUE} (default), the variable values are shown as additional column.
 #' @param show.labels logical, if \code{TRUE} (default), the value labels are shown as additional column.
-#' @param showFreq logical, if \code{TRUE}, an additional column with frequencies for each variable is shown.
-#' @param showPerc logical, if \code{TRUE}, an additional column with percentage of frequencies for each variable is shown.
-#' @param showWtdFreq logical, if \code{TRUE}, an additional column with weighted
+#' @param show.frq logical, if \code{TRUE}, an additional column with frequencies for each variable is shown.
+#' @param show.prc logical, if \code{TRUE}, an additional column with percentage of frequencies for each variable is shown.
+#' @param show.wtd.frq logical, if \code{TRUE}, an additional column with weighted
 #'          frequencies for each variable is shown. Weights strem from \code{weight.by}.
-#' @param showWtdPerc logical, if \code{TRUE}, an additional column with weighted
+#' @param show.wtd.prc logical, if \code{TRUE}, an additional column with weighted
 #'          percentage of frequencies for each variable is shown.
 #'          Weights strem from \code{weight.by}.
-#' @param sortByName logical, if \code{TRUE}, rows are sorted according to the variable
+#' @param sort.by.name logical, if \code{TRUE}, rows are sorted according to the variable
 #'          names. By default, rows (variables) are ordered according to their
 #'          order in the data frame.
-#' @param hideProgressBar If \code{TRUE}, the progress bar that is displayed when creating the
-#'          table is hidden. Default in \code{FALSE}, hence the bar is visible.
 #'          
 #' @inheritParams sjt.frq
 #' @inheritParams sjt.df
@@ -64,7 +62,7 @@
 #' view_df(efc, show.values = FALSE, show.labels = FALSE)
 #' 
 #' # view variables including variable typed, orderd by name
-#' view_df(efc, sortByName = TRUE, show.type = TRUE)
+#' view_df(efc, sort.by.name = TRUE, show.type = TRUE)
 #' 
 #' # ---------------------------------------------------------------- 
 #' # User defined style sheet
@@ -85,17 +83,17 @@ view_df <- function(x,
                     show.type = FALSE,
                     show.values = TRUE,
                     show.labels = TRUE,
-                    showFreq = FALSE,
-                    showPerc = FALSE,
-                    showWtdFreq = FALSE,
-                    showWtdPerc = FALSE,
+                    show.frq = FALSE,
+                    show.prc = FALSE,
+                    show.wtd.frq = FALSE,
+                    show.wtd.prc = FALSE,
                     show.na = FALSE,
-                    sortByName = FALSE,
+                    sort.by.name = FALSE,
                     wrap.labels = 50,
                     encoding = NULL,
-                    hideProgressBar = FALSE,
+                    hide.progress = FALSE,
                     CSS = NULL,
-                    useViewer = TRUE,
+                    use.viewer = TRUE,
                     no.output = FALSE,
                     remove.spaces = TRUE) {
 # -------------------------------------
@@ -120,7 +118,7 @@ view_df <- function(x,
   # -------------------------------------
   # Order data set if requested
   # -------------------------------------
-  if (sortByName) id <- id[order(colnames(x))]
+  if (sort.by.name) id <- id[order(colnames(x))]
   # -------------------------------------
   # init style sheet and tags used for css-definitions
   # we can use these variables for string-replacement
@@ -171,17 +169,15 @@ view_df <- function(x,
   if (show.na) page.content <- paste0(page.content, ""<th class=\""thead\"">missings</th>"")
   if (show.values) page.content <- paste0(page.content, ""<th class=\""thead\"">Values</th>"")
   if (show.labels) page.content <- paste0(page.content, ""<th class=\""thead\"">Value Labels</th>"")
-  if (showFreq) page.content <- paste0(page.content, ""<th class=\""thead\"">Freq.</th>"")
-  if (showPerc) page.content <- paste0(page.content, ""<th class=\""thead\"">%</th>"")
-  if (showWtdFreq) page.content <- paste0(page.content, ""<th class=\""thead\"">weighted Freq.</th>"")
-  if (showWtdPerc) page.content <- paste0(page.content, ""<th class=\""thead\"">weighted %</th>"")
+  if (show.frq) page.content <- paste0(page.content, ""<th class=\""thead\"">Freq.</th>"")
+  if (show.prc) page.content <- paste0(page.content, ""<th class=\""thead\"">%</th>"")
+  if (show.wtd.frq) page.content <- paste0(page.content, ""<th class=\""thead\"">weighted Freq.</th>"")
+  if (show.wtd.prc) page.content <- paste0(page.content, ""<th class=\""thead\"">weighted %</th>"")
   page.content <- paste0(page.content, ""\n  </tr>\n"")
   # -------------------------------------
   # create progress bar
   # -------------------------------------
-  if (!hideProgressBar) pb <- utils::txtProgressBar(min = 0, 
-                                                    max = colcnt, 
-                                                    style = 3)
+  if (!hide.progress) pb <- utils::txtProgressBar(min = 0, max = colcnt, style = 3)
   # -------------------------------------
   # subsequent rows
   # -------------------------------------
@@ -275,7 +271,7 @@ view_df <- function(x,
     # ----------------------------
     # frequencies
     # ----------------------------
-    if (showFreq) {
+    if (show.frq) {
       page.content <- paste0(page.content, 
                              sprintf(""    <td class=\""tdata%s\"">%s</td>\n"", 
                                      arcstring, 
@@ -284,7 +280,7 @@ view_df <- function(x,
     # ----------------------------
     # percentage of frequencies
     # ----------------------------
-    if (showPerc) {
+    if (show.prc) {
       page.content <- paste0(page.content, 
                              sprintf(""    <td class=\""tdata%s\"">%s</td>\n"", 
                                      arcstring, 
@@ -293,7 +289,7 @@ view_df <- function(x,
     # ----------------------------
     # frequencies
     # ----------------------------
-    if (showWtdFreq && !is.null(weight.by)) {
+    if (show.wtd.frq && !is.null(weight.by)) {
       page.content <- paste0(page.content, 
                              sprintf(""    <td class=\""tdata%s\"">%s</td>\n"", 
                                      arcstring, 
@@ -302,18 +298,18 @@ view_df <- function(x,
     # ----------------------------
     # percentage of frequencies
     # ----------------------------
-    if (showPerc && !is.null(weight.by)) {
+    if (show.prc && !is.null(weight.by)) {
       page.content <- paste0(page.content, 
                              sprintf(""    <td class=\""tdata%s\"">%s</td>\n"", 
                                      arcstring, 
                                      prc.value(index, x, df.val, weight.by)))
     }
     # update progress bar
-    if (!hideProgressBar) utils::setTxtProgressBar(pb, ccnt)
+    if (!hide.progress) utils::setTxtProgressBar(pb, ccnt)
     # close row tag
     page.content <- paste0(page.content, ""  </tr>\n"")
   }
-  if (!hideProgressBar) close(pb)
+  if (!hide.progress) close(pb)
   # -------------------------------------
   # finish html page
   # -------------------------------------
@@ -348,7 +344,7 @@ view_df <- function(x,
   # -------------------------------------
   # check if html-content should be outputted
   # -------------------------------------
-  out.html.table(no.output, file, knitr, toWrite, useViewer)    
+  out.html.table(no.output, file, knitr, toWrite, use.viewer)    
   # -------------------------------------
   # return results
   # -------------------------------------

---FILE: R/sjTabStackFrq.R---
@@ -24,7 +24,7 @@
 #'            \item or \code{NULL} (default) for no sorting.
 #'          }
 #' @param showTotalN logical, if \code{TRUE}, an additional column with each item's total N is printed.
-#' @param labelNA The label for the missing column/row.
+#' @param string.na The label for the missing column/row.
 #' @param showSkew logical, if \code{TRUE}, an additional column with each item's skewness is printed.
 #'          The skewness is retrieved from the \code{\link[psych]{describe}}-function 
 #'          of the \pkg{psych}-package.
@@ -60,31 +60,19 @@
 #' # random sample
 #' # -------------------------------
 #' # prepare data for 4-category likert scale, 5 items
-#' likert_4 <- data.frame(as.factor(sample(1:4, 
-#'                                         500, 
-#'                                         replace = TRUE, 
+#' likert_4 <- data.frame(as.factor(sample(1:4, 500, replace = TRUE, 
 #'                                         prob = c(0.2, 0.3, 0.1, 0.4))),
-#'                        as.factor(sample(1:4, 
-#'                                         500, 
-#'                                         replace = TRUE, 
+#'                        as.factor(sample(1:4, 500, replace = TRUE, 
 #'                                         prob = c(0.5, 0.25, 0.15, 0.1))),
-#'                        as.factor(sample(1:4, 
-#'                                         500, 
-#'                                         replace = TRUE, 
+#'                        as.factor(sample(1:4, 500, replace = TRUE, 
 #'                                         prob = c(0.25, 0.1, 0.4, 0.25))),
-#'                        as.factor(sample(1:4, 
-#'                                         500, 
-#'                                         replace = TRUE, 
+#'                        as.factor(sample(1:4, 500, replace = TRUE, 
 #'                                         prob = c(0.1, 0.4, 0.4, 0.1))),
-#'                        as.factor(sample(1:4, 
-#'                                         500, 
-#'                                         replace = TRUE, 
+#'                        as.factor(sample(1:4, 500, replace = TRUE, 
 #'                                         prob = c(0.35, 0.25, 0.15, 0.25))))
 #' # create labels
-#' levels_4 <- c(""Independent"", 
-#'               ""Slightly dependent"", 
-#'               ""Dependent"", 
-#'               ""Severely dependent"")
+#' levels_4 <- c(""Independent"", ""Slightly dependent"", 
+#'               ""Dependent"", ""Severely dependent"")
 #' 
 #' # create item labels
 #' items <- c(""Q1"", ""Q2"", ""Q3"", ""Q4"", ""Q5"")
@@ -105,23 +93,17 @@
 #' # recveive first item of COPE-index scale
 #' end <- which(colnames(efc) == ""c90cop9"")
 #' 
-#' sjt.stackfrq(efc[, c(start:end)],
-#'              alternateRowColors = TRUE)
+#' sjt.stackfrq(efc[, c(start:end)], alternateRowColors = TRUE)
 #' 
-#' sjt.stackfrq(efc[, c(start:end)],
-#'              alternateRowColors = TRUE,
-#'              show.n = TRUE,
-#'              show.na = TRUE)
+#' sjt.stackfrq(efc[, c(start:end)], alternateRowColors = TRUE,
+#'              show.n = TRUE, show.na = TRUE)
 #'          
 #'          
 #' # -------------------------------- 
 #' # User defined style sheet
 #' # -------------------------------- 
-#' sjt.stackfrq(efc[, c(start:end)],
-#'              alternateRowColors = TRUE,
-#'              showTotalN = TRUE,
-#'              showSkew = TRUE,
-#'              showKurtosis = TRUE,
+#' sjt.stackfrq(efc[, c(start:end)], alternateRowColors = TRUE, 
+#'              showTotalN = TRUE, showSkew = TRUE, showKurtosis = TRUE,
 #'              CSS = list(css.ncol = ""border-left:1px dotted black;"",
 #'                         css.summary = ""font-style:italic;""))}
 #'              
@@ -140,7 +122,7 @@ sjt.stackfrq <- function(items,
                          show.n = FALSE,
                          showTotalN = FALSE,
                          show.na = FALSE,
-                         labelNA = ""NA"",
+                         string.na = ""NA"",
                          showSkew = FALSE,
                          showKurtosis = FALSE,
                          digits.stats = 2,
@@ -149,7 +131,7 @@ sjt.stackfrq <- function(items,
                          file = NULL, 
                          encoding = NULL,
                          CSS = NULL,
-                         useViewer = TRUE,
+                         use.viewer = TRUE,
                          no.output = FALSE,
                          remove.spaces = TRUE) {
   # --------------------------------------------------------
@@ -205,7 +187,7 @@ sjt.stackfrq <- function(items,
   # ----------------------------
   if (is.null(value.labels)) value.labels <- as.character(minval:maxval)
   # check whether missings should be shown
-  if (show.na) value.labels <- c(value.labels, labelNA)
+  if (show.na) value.labels <- c(value.labels, string.na)
   # save amolunt of values
   catcount <- length(value.labels)
   # check length of x-axis-labels and split longer strings at into new lines
@@ -354,17 +336,17 @@ sjt.stackfrq <- function(items,
   # check user defined style sheets
   # ------------------------
   if (!is.null(CSS)) {
-    if (!is.null(CSS[['css.table']])) css.table <- ifelse(substring(CSS[['css.table']],1,1)=='+', paste0(css.table, substring(CSS[['css.table']],2)), CSS[['css.table']])
-    if (!is.null(CSS[['css.thead']])) css.thead <- ifelse(substring(CSS[['css.thead']],1,1)=='+', paste0(css.thead, substring(CSS[['css.thead']],2)), CSS[['css.thead']])
-    if (!is.null(CSS[['css.caption']])) css.caption <- ifelse(substring(CSS[['css.caption']],1,1)=='+', paste0(css.caption, substring(CSS[['css.caption']],2)), CSS[['css.caption']])
-    if (!is.null(CSS[['css.summary']])) css.summary <- ifelse(substring(CSS[['css.summary']],1,1)=='+', paste0(css.summary, substring(CSS[['css.summary']],2)), CSS[['css.summary']])
-    if (!is.null(CSS[['css.arc']])) css.arc <- ifelse(substring(CSS[['css.arc']],1,1)=='+', paste0(css.arc, substring(CSS[['css.arc']],2)), CSS[['css.arc']])
-    if (!is.null(CSS[['css.tdata']])) css.tdata <- ifelse(substring(CSS[['css.tdata']],1,1)=='+', paste0(css.tdata, substring(CSS[['css.tdata']],2)), CSS[['css.tdata']])
-    if (!is.null(CSS[['css.centeralign']])) css.centeralign <- ifelse(substring(CSS[['css.centeralign']],1,1)=='+', paste0(css.centeralign, substring(CSS[['css.centeralign']],2)), CSS[['css.centeralign']])
-    if (!is.null(CSS[['css.firsttablecol']])) css.firsttablecol <- ifelse(substring(CSS[['css.firsttablecol']],1,1)=='+', paste0(css.firsttablecol, substring(CSS[['css.firsttablecol']],2)), CSS[['css.firsttablecol']])
-    if (!is.null(CSS[['css.ncol']])) css.ncol <- ifelse(substring(CSS[['css.ncol']],1,1)=='+', paste0(css.ncol, substring(CSS[['css.ncol']],2)), CSS[['css.ncol']])
-    if (!is.null(CSS[['css.skewcol']])) css.skewcol <- ifelse(substring(CSS[['css.skewcol']],1,1)=='+', paste0(css.skewcol, substring(CSS[['css.skewcol']],2)), CSS[['css.skewcol']])
-    if (!is.null(CSS[['css.kurtcol']])) css.kurtcol <- ifelse(substring(CSS[['css.kurtcol']],1,1)=='+', paste0(css.kurtcol, substring(CSS[['css.kurtcol']],2)), CSS[['css.kurtcol']])
+    if (!is.null(CSS[['css.table']])) css.table <- ifelse(substring(CSS[['css.table']],1,1) == '+', paste0(css.table, substring(CSS[['css.table']],2)), CSS[['css.table']])
+    if (!is.null(CSS[['css.thead']])) css.thead <- ifelse(substring(CSS[['css.thead']],1,1) == '+', paste0(css.thead, substring(CSS[['css.thead']],2)), CSS[['css.thead']])
+    if (!is.null(CSS[['css.caption']])) css.caption <- ifelse(substring(CSS[['css.caption']],1,1) == '+', paste0(css.caption, substring(CSS[['css.caption']],2)), CSS[['css.caption']])
+    if (!is.null(CSS[['css.summary']])) css.summary <- ifelse(substring(CSS[['css.summary']],1,1) == '+', paste0(css.summary, substring(CSS[['css.summary']],2)), CSS[['css.summary']])
+    if (!is.null(CSS[['css.arc']])) css.arc <- ifelse(substring(CSS[['css.arc']],1,1) == '+', paste0(css.arc, substring(CSS[['css.arc']],2)), CSS[['css.arc']])
+    if (!is.null(CSS[['css.tdata']])) css.tdata <- ifelse(substring(CSS[['css.tdata']],1,1) == '+', paste0(css.tdata, substring(CSS[['css.tdata']],2)), CSS[['css.tdata']])
+    if (!is.null(CSS[['css.centeralign']])) css.centeralign <- ifelse(substring(CSS[['css.centeralign']],1,1) == '+', paste0(css.centeralign, substring(CSS[['css.centeralign']],2)), CSS[['css.centeralign']])
+    if (!is.null(CSS[['css.firsttablecol']])) css.firsttablecol <- ifelse(substring(CSS[['css.firsttablecol']],1,1) == '+', paste0(css.firsttablecol, substring(CSS[['css.firsttablecol']],2)), CSS[['css.firsttablecol']])
+    if (!is.null(CSS[['css.ncol']])) css.ncol <- ifelse(substring(CSS[['css.ncol']],1,1) == '+', paste0(css.ncol, substring(CSS[['css.ncol']],2)), CSS[['css.ncol']])
+    if (!is.null(CSS[['css.skewcol']])) css.skewcol <- ifelse(substring(CSS[['css.skewcol']],1,1) == '+', paste0(css.skewcol, substring(CSS[['css.skewcol']],2)), CSS[['css.skewcol']])
+    if (!is.null(CSS[['css.kurtcol']])) css.kurtcol <- ifelse(substring(CSS[['css.kurtcol']],1,1) == '+', paste0(css.kurtcol, substring(CSS[['css.kurtcol']],2)), CSS[['css.kurtcol']])
   }
   # ------------------------
   # set page style
@@ -485,13 +467,13 @@ sjt.stackfrq <- function(items,
   # -------------------------------------
   # check if html-content should be outputted
   # -------------------------------------
-  out.html.table(no.output, file, knitr, toWrite, useViewer) 
+  out.html.table(no.output, file, knitr, toWrite, use.viewer) 
   # -------------------------------------
   # return results
   # -------------------------------------
-  invisible (structure(class = ""sjtstackfrq"",
-                       list(page.style = page.style,
-                            page.content = page.content,
-                            output.complete = toWrite,
-                            knitr = knitr)))
+  invisible(structure(class = ""sjtstackfrq"",
+                      list(page.style = page.style,
+                           page.content = page.content,
+                           output.complete = toWrite,
+                           knitr = knitr)))
 }

---FILE: R/table_functions.R---
@@ -1,5 +1,5 @@
-get_table_header <- function(encoding, cellSpacing, cellGroupIndent, p.numeric, showHeaderStrings, CSS) {
-  return(table_style_worker(NULL, encoding, cellSpacing, cellGroupIndent, p.numeric, showHeaderStrings, CSS, option = 1))
+get_table_header <- function(encoding, cell.spacing, cell.gpr.indent, p.numeric, show.header, CSS) {
+  return(table_style_worker(NULL, encoding, cell.spacing, cell.gpr.indent, p.numeric, show.header, CSS, option = 1))
 }
 
 
@@ -56,17 +56,17 @@ get_table_response_label <- function(page.content, depvar.labels, input_list, tc
 
 
 
-replace_css_styles <- function(page.content, cellSpacing, cellGroupIndent, p.numeric, showHeaderStrings, CSS) {
-  return(table_style_worker(page.content, NULL, cellSpacing, cellGroupIndent, p.numeric, showHeaderStrings, CSS, option = 2))
+replace_css_styles <- function(page.content, cell.spacing, cell.gpr.indent, p.numeric, show.header, CSS) {
+  return(table_style_worker(page.content, NULL, cell.spacing, cell.gpr.indent, p.numeric, show.header, CSS, option = 2))
 }
 
 
-get_table_css_styles <- function(cellSpacing, cellGroupIndent, p.numeric, showHeaderStrings, CSS) {
-  return(table_style_worker(NULL, NULL, cellSpacing, cellGroupIndent, p.numeric, showHeaderStrings, CSS, option = 3))
+get_table_css_styles <- function(cell.spacing, cell.gpr.indent, p.numeric, show.header, CSS) {
+  return(table_style_worker(NULL, NULL, cell.spacing, cell.gpr.indent, p.numeric, show.header, CSS, option = 3))
 }
 
-table_style_worker <- function(page.content, encoding, cellSpacing, cellGroupIndent, 
-                               p.numeric, showHeaderStrings, CSS, option) {
+table_style_worker <- function(page.content, encoding, cell.spacing, cell.gpr.indent, 
+                               p.numeric, show.header, CSS, option) {
   # -------------------------------------
   # init style sheet and tags used for css-definitions
   # we can use these variables for string-replacement
@@ -100,8 +100,8 @@ table_style_worker <- function(page.content, encoding, cellSpacing, cellGroupInd
   tag.modelcolumn5 <- ""modelcolumn5""
   tag.modelcolumn6 <- ""modelcolumn6""
   css.table <- ""border-collapse:collapse; border:none;""
-  css.thead <- sprintf(""border-bottom: 1px solid; padding:%.1fcm;"", cellSpacing)
-  css.tdata <- sprintf(""padding:%.1fcm;"", cellSpacing)
+  css.thead <- sprintf(""border-bottom: 1px solid; padding:%.1fcm;"", cell.spacing)
+  css.tdata <- sprintf(""padding:%.1fcm;"", cell.spacing)
   css.separatorcol <- ""padding-left:0.5em; padding-right:0.5em;""
   css.summary <- ""padding-top:0.1cm; padding-bottom:0.1cm;""
   css.fixedparts <- ""font-weight:bold; text-align:left;""
@@ -118,8 +118,8 @@ table_style_worker <- function(page.content, encoding, cellSpacing, cellGroupInd
   css.annostyle <- ""text-align:right;""
   css.leftalign <- ""text-align:left;""
   css.centeralign <- ""text-align:center;""
-  css.grouprow <- sprintf(""padding:%.1fcm;"", cellSpacing)
-  css.tgrpdata <- sprintf(""font-style:italic; padding:%.1fcm; padding-left:%.1fcm;"", cellSpacing, cellGroupIndent)
+  css.grouprow <- sprintf(""padding:%.1fcm;"", cell.spacing)
+  css.tgrpdata <- sprintf(""font-style:italic; padding:%.1fcm; padding-left:%.1fcm;"", cell.spacing, cell.gpr.indent)
   css.modelcolumn1 <- """"
   css.modelcolumn2 <- """"
   css.modelcolumn3 <- """"
@@ -128,7 +128,7 @@ table_style_worker <- function(page.content, encoding, cellSpacing, cellGroupInd
   css.modelcolumn6 <- """"
   # change table style if we have pvalues as numbers
   if (p.numeric) css.table <- sprintf(""%s%s"", css.table, css.noannorow)
-  if (showHeaderStrings) css.labelcellborder <- """"
+  if (show.header) css.labelcellborder <- """"
   # ------------------------
   # check user defined style sheets
   # ------------------------

---FILE: man/sjc.elbow.Rd---
@@ -4,7 +4,7 @@
 \alias{sjc.elbow}
 \title{Compute elbow values of a k-means cluster analysis}
 \usage{
-sjc.elbow(data, steps = 15, show.diff = FALSE, showDiff = FALSE)
+sjc.elbow(data, steps = 15, show.diff = FALSE)
 }
 \arguments{
 \item{data}{data frame containing all variables that should be used for 
@@ -16,8 +16,6 @@ which the elbow-criterion should be displayed. Default is \code{15}.}
 \item{show.diff}{logical, if \code{TRUE}, an additional plot with the differences between 
 each fusion step of the Elbow criterion calculation is shown. This plot
 may help identifying the ""elbow"". Default for this argument is \code{FALSE}.}
-
-\item{showDiff}{Deprecated; use \code{show.diff} instead.}
 }
 \description{
 Plot elbow values of a k-means cluster analysis. This function

---FILE: man/sjp.frq.Rd---
@@ -5,10 +5,9 @@
 \title{Plot frequencies of variables}
 \usage{
 sjp.frq(var.cnt, title = """", weight.by = NULL, title.wtd.suffix = NULL,
-  interactionVar = NULL, sort.frq = ""none"", type = c(""bar"", ""dot"",
-  ""histogram"", ""line"", ""density"", ""boxplot"", ""violin""), geom.size = NULL,
-  geom.colors = ""#336699"", axis.labels = NULL,
-  interactionVarLabels = NULL, xlim = NULL, ylim = NULL,
+  sort.frq = c(""none"", ""asc"", ""desc""), type = c(""bar"", ""dot"", ""histogram"",
+  ""line"", ""density"", ""boxplot"", ""violin""), geom.size = NULL,
+  geom.colors = ""#336699"", axis.labels = NULL, xlim = NULL, ylim = NULL,
   wrap.title = 50, wrap.labels = 20, grid.breaks = NULL,
   innerBoxPlotWidth = 0.15, innerBoxPlotDotSize = 3, expand.grid = FALSE,
   show.values = TRUE, show.n = TRUE, show.prc = TRUE,
@@ -18,7 +17,7 @@ sjp.frq(var.cnt, title = """", weight.by = NULL, title.wtd.suffix = NULL,
   normal.curve.color = ""red"", normal.curve.size = 0.8,
   normal.curve.alpha = 0.4, axis.title = NULL, auto.group = NULL,
   coord.flip = FALSE, vjust = ""bottom"", hjust = ""center"",
-  y.offset = NULL, na.rm = TRUE, printPlot = TRUE)
+  y.offset = NULL, show.na = FALSE, printPlot = TRUE)
 }
 \arguments{
 \item{var.cnt}{vector of counts, for which frequencies or means will be plotted or printed.}
@@ -34,12 +33,8 @@ Must be a vector of same length as the input vector. Default is
 e.g. \code{title.wtd.suffix="" (weighted)""}. Default is \code{NULL}, so 
 title will not have a suffix when cases are weighted.}
 
-\item{interactionVar}{an interaction variable which can be used for box plots. Divides the observations in 
-\code{var.cnt} into sub groups indicated by \code{interactionVar}. Only 
-applies when \code{type = ""boxplot""} or \code{""violin""}.}
-
-\item{sort.frq}{Determines whether categories (bars) on x-axis should be sorted 
-according to the frequencies or not.  Default is \code{""none""}, so 
+\item{sort.frq}{Determines whether categories should be sorted 
+according to their frequencies or not. Default is \code{""none""}, so 
 categories are not sorted by frequency. Use \code{""asc""} or
 \code{""desc""} for sorting categories ascending or descending order.}
 
@@ -62,12 +57,6 @@ need smaller values than dot sizes.}
 
 \item{axis.labels}{character vector with labels used as axis labels.}
 
-\item{interactionVarLabels}{a character vector with labels for the x-axis breaks 
-when having interaction variables included. These labels replace the 
-\code{axis.labels}. Only applies, when using box or violin plots
-(i.e. \code{type = ""boxplot""} or \code{""violin""}) and \code{interactionVar} 
-is not \code{NULL}.}
-
 \item{xlim}{numeric vector of length two, defining lower and upper axis limits}
 
 \item{ylim}{numeric vector of length two, defining lower and upper axis limits
@@ -103,7 +92,7 @@ If \code{FALSE}, percentage values are removed.}
 \item{show.axis.values}{logical, whether count or percentage values for the axis
 should be printed or not.}
 
-\item{show.ci}{logical, if \code{TRUE}, depending on \code{type}, a condifence
+\item{show.ci}{logical, if \code{TRUE}, depending on \code{type}, a confidence
 interval or region is added to the plot.}
 
 \item{errorbar.color}{color of confidence interval bars (error bars). 
@@ -168,7 +157,8 @@ away from the center of the plot respectively.}
 \item{y.offset}{numeric, offset for text labels when their alignment is adjusted 
 to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
 
-\item{na.rm}{logical, if \code{TRUE}, missings are not included in the frequency plot.}
+\item{show.na}{logical, if \code{TRUE}, \code{\link{NA}}'s (missing values)
+are added to the output.}
 
 \item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
@@ -217,18 +207,6 @@ sjp.frq(ageGrp,
         axis.labels = ageGrpLab)
 
 
-# box plots with interaction variable
-# the following example is equal to the function call
-# sjp.grpfrq(efc$e17age, efc$e16sex, type = ""box"")
-sjp.frq(efc$e17age,
-        title = paste(get_label(efc$e17age), 
-                      ""by"", 
-                      get_label(efc$e16sex),
-        interactionVar = efc$e16sex,
-        interactionVarLabels = get_labels(efc$e16sex),
-        type = ""box""))
-
-
 # negative impact scale, ranging from 7-28
 sjp.frq(efc$neg_c_7)
 

---FILE: man/sjp.glm.Rd---
@@ -113,7 +113,7 @@ is added to the plot.}
 \item{facet.grid}{\code{TRUE} to arrange the lay out of of multiple plots 
 in a grid of an integrated single plot.}
 
-\item{show.ci}{logical, if \code{TRUE}, depending on \code{type}, a condifence
+\item{show.ci}{logical, if \code{TRUE}, depending on \code{type}, a confidence
 interval or region is added to the plot.}
 
 \item{show.legend}{logical, if \code{TRUE}, and depending on plot type and

---FILE: man/sjp.glmer.Rd---
@@ -115,7 +115,7 @@ variable labels.}
 
 \item{fade.ns}{if \code{TRUE}, non significant estimates will be printed in slightly faded colors.}
 
-\item{show.ci}{logical, if \code{TRUE}, depending on \code{type}, a condifence
+\item{show.ci}{logical, if \code{TRUE}, depending on \code{type}, a confidence
 interval or region is added to the plot.}
 
 \item{sample.n}{numeric vector. only applies, if \code{type = ""rs.ri""}. If

---FILE: man/sjp.grpfrq.Rd---
@@ -18,7 +18,7 @@ sjp.grpfrq(var.cnt, var.grp, weight.by = NULL, title.wtd.suffix = NULL,
   showPlotAnnotation = TRUE, show.summary = FALSE, showGroupCount = FALSE,
   tableSummaryPos = ""r"", axis.titles = NULL, auto.group = NULL,
   coord.flip = FALSE, vjust = ""bottom"", hjust = ""center"",
-  y.offset = NULL, na.rm = TRUE, printPlot = TRUE)
+  y.offset = NULL, show.na = FALSE, printPlot = TRUE)
 }
 \arguments{
 \item{var.cnt}{vector of counts, for which frequencies or means will be plotted or printed.}
@@ -166,7 +166,8 @@ away from the center of the plot respectively.}
 \item{y.offset}{numeric, offset for text labels when their alignment is adjusted 
 to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
 
-\item{na.rm}{logical, if \code{TRUE}, missings are not included in the frequency plot.}
+\item{show.na}{logical, if \code{TRUE}, \code{\link{NA}}'s (missing values)
+are added to the output.}
 
 \item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}

---FILE: man/sjp.likert.Rd---
@@ -8,13 +8,13 @@ sjp.likert(items, catcount = NULL, cat.neutral = NULL, weight.by = NULL,
   title.wtd.suffix = NULL, sort.frq = NULL, geom.size = 0.6,
   geom.colors = ""BrBG"", reverse.colors = FALSE,
   cat.neutral.color = ""grey70"", intercept.line.color = ""grey50"",
-  value.labels = ""show"", showPercentageSign = FALSE, digits = 1,
+  value.labels = ""show"", show.prc.sign = FALSE, digits = 1,
   legend.labels = NULL, show.legend = TRUE, title = NULL,
-  legend.title = NULL, includeN = TRUE, showItemLabels = TRUE,
-  axis.labels = NULL, wrap.title = 50, wrap.labels = 30,
-  breakLegendTitleAt = 30, breakLegendLabelsAt = 28, gridRange = 1,
-  grid.breaks = 0.2, expand.grid = TRUE, axis.titles = NULL,
-  coord.flip = TRUE, printPlot = TRUE)
+  legend.title = NULL, include.n = TRUE, axis.labels = NULL,
+  wrap.title = 50, wrap.labels = 30, breakLegendTitleAt = 30,
+  breakLegendLabelsAt = 28, grid.range = 1, grid.breaks = 0.2,
+  expand.grid = TRUE, axis.titles = NULL, coord.flip = TRUE,
+  printPlot = TRUE)
 }
 \arguments{
 \item{items}{\code{\link{data.frame}} with each column representing one likert-item.}
@@ -71,7 +71,7 @@ so positive and negative values switch colors.}
   \item{\code{""sum.outide""}}{shows the sums of percentage values for both negative and positive values and prints them outside the end of each bar}
 }}
 
-\item{showPercentageSign}{logical, if \code{TRUE}, \%-signs for value labels are shown.}
+\item{show.prc.sign}{logical, if \code{TRUE}, \%-signs for value labels are shown.}
 
 \item{digits}{numeric, amount of digits after decimal point when rounding estimates and values.}
 
@@ -85,9 +85,7 @@ will be set automatically. If \code{title = """"}, no title is printed.}
 
 \item{legend.title}{title of the plot legend, as string.}
 
-\item{includeN}{logical, if \code{TRUE} (default), the N of each item will be included in axis labels.}
-
-\item{showItemLabels}{logical, whether x-axis text (category names) should be shown or not}
+\item{include.n}{logical, if \code{TRUE} (default), the N of each item will be included in axis labels.}
 
 \item{axis.labels}{character vector with labels used as axis labels.}
 
@@ -103,11 +101,11 @@ are displayed in one line and when a line break is inserted.}
 \item{breakLegendLabelsAt}{determines how many chars of the legend labels are 
 displayed in one line and when a line break is inserted.}
 
-\item{gridRange}{numeric, limits of the x-axis-range, as proportion of 100. 
+\item{grid.range}{numeric, limits of the x-axis-range, as proportion of 100. 
 Default is 1, so the x-scale ranges from zero to 100\% on 
 both sides from the center. You can use values beyond 1
 (100\%) in case bar labels are not printed because they exceed the axis range.
-E.g. \code{gridRange = 1.4} will set the axis from -140 to +140\%, however, only
+E.g. \code{grid.range = 1.4} will set the axis from -140 to +140\%, however, only
 (valid) axis labels from -100 to +100\% are printed. Neutral categories are
 adjusted to the most left limit.}
 
@@ -202,10 +200,10 @@ sjp.likert(likert_4,
            cat.neutral = 5,
            legend.labels = levels_4, 
            axis.labels = items,
-           gridRange = 1.2,
+           grid.range = 1.2,
            expand.grid = FALSE,
            value.labels = ""sum.outside"",
-           showPercentageSign = TRUE)
+           show.prc.sign = TRUE)
 
 # plot 6-category-likert-scale, ordered by positive values,
 # in brown color scale
@@ -214,7 +212,7 @@ sjp.likert(likert_6,
            axis.labels = items, 
            sort.frq = ""pos.asc"", 
            digits = 0,
-           showPercentageSign = TRUE,
+           show.prc.sign = TRUE,
            value.labels = ""sum.inside"")
 
 }

---FILE: man/sjp.lm.Rd---
@@ -11,11 +11,11 @@ sjp.lm(fit, type = ""lm"", sort.est = TRUE, title = NULL,
   group.estimates = NULL, remove.estimates = NULL, vars = NULL,
   wrap.title = 50, wrap.labels = 25, grid.breaks = NULL,
   coord.flip = TRUE, facet.grid = TRUE, show.values = TRUE, digits = 2,
-  show.p = TRUE, show.summary = FALSE, show.ci = TRUE, pointAlpha = 0.2,
-  scatter.plot = TRUE, show.loess = FALSE, show.loess.ci = FALSE,
-  show.legend = FALSE, y.offset = 0.15, poly.term = NULL,
-  showOriginalModelOnly = TRUE, completeDiagnostic = FALSE,
-  printPlot = TRUE)
+  show.p = TRUE, show.summary = FALSE, show.ci = TRUE,
+  point.alpha = 0.2, scatter.plot = TRUE, show.loess = FALSE,
+  show.loess.ci = FALSE, show.legend = FALSE, y.offset = 0.15,
+  poly.term = NULL, showOriginalModelOnly = TRUE,
+  completeDiagnostic = FALSE, printPlot = TRUE)
 }
 \arguments{
 \item{fit}{fitted linear regression model (of class \code{\link{lm}}, \code{\link[nlme]{gls}} or \code{plm}).}
@@ -108,11 +108,10 @@ variable labels.}
 \item{show.summary}{logical, if \code{TRUE}, a summary with model statistics 
 is added to the plot.}
 
-\item{show.ci}{logical, if \code{TRUE}, depending on \code{type}, a condifence
+\item{show.ci}{logical, if \code{TRUE}, depending on \code{type}, a confidence
 interval or region is added to the plot.}
 
-\item{pointAlpha}{alpha value of point-geoms in the scatter plots.
-Default is 0.2.}
+\item{point.alpha}{alpha value of point-geoms in the scatter plots.}
 
 \item{scatter.plot}{logical, if \code{TRUE} (default), a scatter plot of
 response and predictor values for each predictor of the model

---FILE: man/sjp.lmer.Rd---
@@ -11,7 +11,7 @@ sjp.lmer(fit, type = ""re"", vars = NULL, ri.nr = NULL, emph.grp = NULL,
   vline.color = ""grey70"", remove.estimates = NULL, show.values = TRUE,
   digits = 2, y.offset = 0.1, show.p = TRUE, facet.grid = TRUE,
   free.scale = FALSE, fade.ns = FALSE, show.ci = FALSE, p.kr = TRUE,
-  pointAlpha = 0.2, scatter.plot = TRUE, show.loess = FALSE,
+  point.alpha = 0.2, scatter.plot = TRUE, show.loess = FALSE,
   show.loess.ci = FALSE, poly.term = NULL, sample.n = NULL,
   show.legend = FALSE, printPlot = TRUE)
 }
@@ -121,15 +121,14 @@ the grid has the same scale range.}
 
 \item{fade.ns}{if \code{TRUE}, non significant estimates will be printed in slightly faded colors.}
 
-\item{show.ci}{logical, if \code{TRUE}, depending on \code{type}, a condifence
+\item{show.ci}{logical, if \code{TRUE}, depending on \code{type}, a confidence
 interval or region is added to the plot.}
 
 \item{p.kr}{logical, if \code{TRUE}, p-value estimation is based on conditional 
 F-tests with Kenward-Roger approximation for the df. Caution: Computation
 may take very long time for large samples!}
 
-\item{pointAlpha}{alpha value of point-geoms in the scatter plots.
-Default is 0.2.}
+\item{point.alpha}{alpha value of point-geoms in the scatter plots.}
 
 \item{scatter.plot}{logical, if \code{TRUE} (default), a scatter plot of
 response and predictor values for each predictor of the model

---FILE: man/sjp.poly.Rd---
@@ -7,8 +7,8 @@
 sjp.poly(x, poly.term, poly.degree, poly.scale = FALSE, fun = NULL,
   axis.title = NULL, scatter.plot = TRUE, show.loess = TRUE,
   show.loess.ci = TRUE, show.p = TRUE, geom.colors = NULL,
-  geom.size = 0.8, loessLineColor = ""#808080"", pointColor = ""#404040"",
-  pointAlpha = 0.2, printPlot = TRUE)
+  geom.size = 0.8, loessLineColor = ""#808080"", point.color = ""#404040"",
+  point.alpha = 0.2, printPlot = TRUE)
 }
 \arguments{
 \item{x}{a vector, representing the response variable of a linear (mixed) model; or
@@ -56,9 +56,9 @@ need smaller values than dot sizes.}
 
 \item{loessLineColor}{color of the loess-smoothed line. Only applies, if \code{show.loess = TRUE}.}
 
-\item{pointColor}{color of the scatter plot's point. Only applies, if \code{scatter.plot = TRUE}.}
+\item{point.color}{color of the scatter plot's point. Only applies, if \code{scatter.plot = TRUE}.}
 
-\item{pointAlpha}{The alpha values of the scatter plot's point-geoms. Default is 0.2.}
+\item{point.alpha}{alpha value of point-geoms in the scatter plots.}
 
 \item{printPlot}{If \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}

---FILE: man/sjp.scatter.Rd---
@@ -72,7 +72,7 @@ is drawn. See \code{fitmethod} to change the fit method of the fitted lines.}
 scatterplot is drawn. See \code{fitmethod} to change the fit method
 of the fitted line.}
 
-\item{show.ci}{logical, if \code{TRUE}, depending on \code{type}, a condifence
+\item{show.ci}{logical, if \code{TRUE}, depending on \code{type}, a confidence
 interval or region is added to the plot.}
 
 \item{fitmethod}{By default, a linear method (\code{""lm""}) is used for fitting

---FILE: man/sjp.stackfrq.Rd---
@@ -6,14 +6,12 @@
 \usage{
 sjp.stackfrq(items, legend.labels = NULL, sort.frq = NULL,
   weight.by = NULL, show.legend = TRUE, title = NULL,
-  legend.title = NULL, includeN = TRUE, axis.labels = NULL,
+  legend.title = NULL, include.n = TRUE, axis.labels = NULL,
   wrap.title = 50, wrap.labels = 30, breakLegendTitleAt = 30,
   breakLegendLabelsAt = 28, grid.breaks = 0.2, expand.grid = FALSE,
   geom.size = 0.5, geom.colors = ""Blues"", axis.titles = NULL,
   show.values = TRUE, digits = 1, vjust = ""center"",
-  showPercentageAxis = TRUE, showItemLabels = TRUE,
-  showSeparatorLine = FALSE, separatorLineColor = ""grey80"",
-  separatorLineSize = 0.3, coord.flip = TRUE, printPlot = TRUE)
+  showPercentageAxis = TRUE, coord.flip = TRUE, printPlot = TRUE)
 }
 \arguments{
 \item{items}{\code{\link{data.frame}} with each column representing one item.}
@@ -42,7 +40,7 @@ will be set automatically. If \code{title = """"}, no title is printed.}
 
 \item{legend.title}{title of the plot legend, as string.}
 
-\item{includeN}{logical, if \code{TRUE} (default), the N of each item is included into axis labels.}
+\item{include.n}{logical, if \code{TRUE} (default), the N of each item will be included in axis labels.}
 
 \item{axis.labels}{character vector with labels used as axis labels.}
 
@@ -85,14 +83,6 @@ away from the center of the plot respectively.}
 
 \item{showPercentageAxis}{If \code{TRUE} (default), the percentage values at the x-axis are shown.}
 
-\item{showItemLabels}{Whether x axis text (category names) should be shown or not.}
-
-\item{showSeparatorLine}{If \code{TRUE}, a line is drawn to visually ""separate"" each bar in the diagram.}
-
-\item{separatorLineColor}{The color of the separator line. only applies, if \code{showSeparatorLine} is \code{TRUE}.}
-
-\item{separatorLineSize}{The size of the separator line. only applies, if \code{showSeparatorLine} is \code{TRUE}.}
-
 \item{coord.flip}{logical, if \code{TRUE}, the x and y axis are swapped.}
 
 \item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't

---FILE: man/sjp.xtab.Rd---
@@ -5,8 +5,8 @@
 \title{Plot contingency tables}
 \usage{
 sjp.xtab(x, grp, title = """", legend.title = NULL, weight.by = NULL,
-  title.wtd.suffix = NULL, type = ""bars"", tableIndex = ""col"",
-  rev.order = FALSE, ylim = NULL, axis.labels = NULL,
+  title.wtd.suffix = NULL, type = c(""bar"", ""line""), tableIndex = c(""col"",
+  ""cell"", ""row""), rev.order = FALSE, ylim = NULL, axis.labels = NULL,
   legend.labels = NULL, vjust = ""bottom"", hjust = ""center"",
   y.offset = NULL, stringTotal = ""Total"", wrap.title = 50,
   wrap.labels = 15, breakLegendTitleAt = 20, breakLegendLabelsAt = 20,
@@ -37,8 +37,8 @@ Must be a vector of same length as the input vector. Default is
 e.g. \code{title.wtd.suffix="" (weighted)""}. Default is \code{NULL}, so 
 title will not have a suffix when cases are weighted.}
 
-\item{type}{plot type. may be either \code{""b""}, \code{""bar""}, \code{""bars""} (default) for bar charts,
-or \code{""l""}, \code{""line""}, \code{""lines""} for line diagram.}
+\item{type}{plot type. may be either \code{""bar""} (default) for bar charts,
+or \code{""line""} for line diagram.}
 
 \item{tableIndex}{indicates which data of the proportional table should be plotted. Use \code{""row""} for
 calculating row percentages, \code{""col""} for column percentages and \code{""cell""} for cell percentages.
@@ -99,9 +99,9 @@ need smaller values than dot sizes.}
 \item{bar.pos}{indicates whether bars should be positioned side-by-side (default)
 or stacked (use \code{""stack""} as argument).}
 
-\item{lineDotSize}{dot size, only applies, when argument \code{type = ""lines""}.}
+\item{lineDotSize}{dot size, only applies, when argument \code{type = ""line""}.}
 
-\item{smoothLines}{prints a smooth line curve. Only applies, when argument \code{type = ""lines""}.}
+\item{smoothLines}{prints a smooth line curve. Only applies, when argument \code{type = ""line""}.}
 
 \item{expand.grid}{logical, if \code{TRUE}, the plot grid is expanded, i.e. there is a small margin between
 axes and plotting region. Default is \code{FALSE}.}

---FILE: man/sjt.corr.Rd---
@@ -9,7 +9,7 @@ sjt.corr(data, na.deletion = c(""listwise"", ""pairwise""),
   show.p = TRUE, p.numeric = FALSE, fade.ns = TRUE, file = NULL,
   var.labels = NULL, wrap.labels = 40, digits = 3, triangle = ""both"",
   val.rm = NULL, string.diag = NULL, encoding = NULL, CSS = NULL,
-  useViewer = TRUE, no.output = FALSE, remove.spaces = TRUE)
+  use.viewer = TRUE, no.output = FALSE, remove.spaces = TRUE)
 }
 \arguments{
 \item{data}{matrix with correlation coefficients as returned by the 
@@ -73,7 +73,7 @@ Windows OS). Change encoding if specific chars are not properly displayed (e.g.
 \item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the 
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
-\item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
+\item{use.viewer}{If \code{TRUE}, the HTML table is shown in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
 \item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in

---FILE: man/sjt.df.Rd---
@@ -8,8 +8,8 @@ sjt.df(mydf, describe = TRUE, file = NULL, alternateRowColors = FALSE,
   sort.col = NULL, sort.asc = TRUE, title = NULL, repeatHeader = FALSE,
   stringVariable = ""Variable"", show.type = FALSE, showRowNames = TRUE,
   showCommentRow = FALSE, commentString = ""No comment..."",
-  big.mark = NULL, hideProgressBar = FALSE, encoding = NULL, CSS = NULL,
-  useViewer = TRUE, no.output = FALSE, remove.spaces = TRUE, ...)
+  big.mark = NULL, hide.progress = FALSE, encoding = NULL, CSS = NULL,
+  use.viewer = TRUE, no.output = FALSE, remove.spaces = TRUE, ...)
 }
 \arguments{
 \item{mydf}{data frame that should be printed as table}
@@ -57,8 +57,8 @@ applies, if \code{showCommentRow = TRUE}.}
 \item{big.mark}{character; if not \code{NULL}, used as mark between every 
 thousands decimals before (hence big) the decimal point}
 
-\item{hideProgressBar}{logical, if \code{TRUE}, the progress bar that is displayed when creating the
-table is hidden. Default in \code{FALSE}, hence the bar is visible.}
+\item{hide.progress}{logical, if \code{TRUE}, the progress bar that is displayed when creating the
+output is hidden. Default in \code{FALSE}, hence the bar is visible.}
 
 \item{encoding}{string, indicating the charset encoding used for variable and 
 value labels. Default is \code{NULL}, so encoding will be auto-detected 
@@ -68,7 +68,7 @@ Windows OS). Change encoding if specific chars are not properly displayed (e.g.
 \item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the 
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
-\item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
+\item{use.viewer}{If \code{TRUE}, the HTML table is shown in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
 \item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in

---FILE: man/sjt.frq.Rd---
@@ -6,15 +6,16 @@
 \usage{
 sjt.frq(data, file = NULL, weight.by = NULL,
   title.wtd.suffix = "" (weighted)"", var.labels = NULL,
-  value.labels = NULL, auto.group = NULL, sort.frq = NULL,
-  alternateRowColors = FALSE, string.val = ""value"", string.cnt = ""N"",
-  string.prc = ""raw \%"", string.vprc = ""valid \%"",
+  value.labels = NULL, auto.group = NULL, sort.frq = c(""none"", ""asc"",
+  ""desc""), alternateRowColors = FALSE, string.val = ""value"",
+  string.cnt = ""N"", string.prc = ""raw \%"", string.vprc = ""valid \%"",
   string.cprc = ""cumulative \%"", string.na = ""missings"", emph.md = FALSE,
   emph.quart = FALSE, skip.zero = ""auto"", show.summary = TRUE,
   show.skew = FALSE, show.kurtosis = FALSE, skewString = ""&gamma;"",
   kurtosisString = ""&omega;"", digits = 2, removeStringVectors = TRUE,
   autoGroupStrings = TRUE, maxStringDist = 3, encoding = NULL,
-  CSS = NULL, useViewer = TRUE, no.output = FALSE, remove.spaces = TRUE)
+  CSS = NULL, use.viewer = TRUE, no.output = FALSE,
+  remove.spaces = TRUE)
 }
 \arguments{
 \item{data}{variables which frequencies should be printed as table. Either use a single variable
@@ -45,10 +46,10 @@ is done (see \code{\link[sjmisc]{group_var}}). Default value for
 \code{auto.group} is \code{NULL}, i.e. auto-grouping is off.
 See \code{\link[sjmisc]{group_var}} for examples on grouping.}
 
-\item{sort.frq}{whether frequencies should be sorted or not. Use \code{""asc""} or \code{""ascending""}
-to sort frequencies ascending, or \code{""desc""} or \code{""descending""} to sort
-frequencies in descending order. By default, \code{sort.frq} is \code{NULL}, i.e.
-frequencies are ordered by values.}
+\item{sort.frq}{Determines whether categories should be sorted 
+according to their frequencies or not. Default is \code{""none""}, so 
+categories are not sorted by frequency. Use \code{""asc""} or
+\code{""desc""} for sorting categories ascending or descending order.}
 
 \item{alternateRowColors}{logical, if \code{TRUE}, alternating rows are highlighted with a light gray
 background color.}
@@ -121,7 +122,7 @@ Windows OS). Change encoding if specific chars are not properly displayed (e.g.
 \item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the 
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
-\item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
+\item{use.viewer}{If \code{TRUE}, the HTML table is shown in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
 \item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -186,27 +187,19 @@ data(efc)
 sjt.frq(efc$e42dep)
 
 # plot and show frequency table of ""e42dep"" with labels
-sjt.frq(efc$e42dep,
-        var.labels = ""Dependency"",
-        value.labels = c(""independent"",
-                        ""slightly dependent"",
-                        ""moderately dependent"",
-                        ""severely dependent""))
+sjt.frq(efc$e42dep, var.labels = ""Dependency"",
+        value.labels = c(""independent"", ""slightly dependent"",
+                         ""moderately dependent"", ""severely dependent""))
 
 # plot frequencies of e42dep, e16sex and c172code in one HTML file
 # and show table in RStudio Viewer Pane or default web browser
 # Note that value.labels of multiple variables have to be
 # list-objects
 sjt.frq(data.frame(efc$e42dep, efc$e16sex, efc$c172code),
-        var.labels = c(""Dependency"", 
-                           ""Gender"", 
-                           ""Education""),
-        value.labels = list(c(""independent"",
-                             ""slightly dependent"",
-                             ""moderately dependent"",
-                             ""severely dependent""),
-                           c(""male"", ""female""),
-                           c(""low"", ""mid"", ""high"")))
+        var.labels = c(""Dependency"", ""Gender"", ""Education""),
+        value.labels = list(c(""independent"", ""slightly dependent"",
+                              ""moderately dependent"", ""severely dependent""),
+                            c(""male"", ""female""), c(""low"", ""mid"", ""high"")))
 
 # -------------------------------
 # auto-detection of labels
@@ -217,9 +210,7 @@ sjt.frq(data.frame(efc$e42dep, efc$e16sex, efc$c172code))
 
 # plot larger scale including zero-counts
 # indicating median and quartiles
-sjt.frq(efc$neg_c_7,
-        emph.md = TRUE,
-        emph.quart = TRUE)
+sjt.frq(efc$neg_c_7, emph.md = TRUE, emph.quart = TRUE)
 
 # -------------------------------
 # sort frequencies

---FILE: man/sjt.glm.Rd---
@@ -4,23 +4,22 @@
 \alias{sjt.glm}
 \title{Summary of generalized linear models as HTML table}
 \usage{
-sjt.glm(..., file = NULL, labelPredictors = NULL, depvar.labels = NULL,
-  stringPredictors = ""Predictors"",
-  stringDependentVariables = ""Dependent Variables"",
-  showHeaderStrings = FALSE, stringIntercept = ""(Intercept)"",
-  stringObservations = ""Observations"", string.est = ""OR"",
-  string.ci = ""CI"", string.se = ""std. Error"", stringP = ""p"",
-  digits.est = 2, digits.p = 3, digits.ci = 2, digits.se = 2,
-  digits.summary = 3, exp.coef = TRUE, p.numeric = TRUE,
-  boldpvalues = TRUE, showConfInt = TRUE, showStdError = FALSE,
-  ci.hyphen = ""&nbsp;&ndash;&nbsp;"", separateConfColumn = TRUE,
-  newLineConf = TRUE, group.pred = TRUE, showAbbrHeadline = TRUE,
-  show.r2 = FALSE, showICC = FALSE, showREvar = FALSE,
-  show.loglik = FALSE, showAIC = FALSE, showAICc = FALSE,
-  showDeviance = FALSE, showChi2 = FALSE, showHosLem = FALSE,
-  showFamily = FALSE, remove.estimates = NULL, cellSpacing = 0.2,
-  cellGroupIndent = 0.6, encoding = NULL, CSS = NULL, useViewer = TRUE,
-  no.output = FALSE, remove.spaces = TRUE)
+sjt.glm(..., file = NULL, pred.labels = NULL, depvar.labels = NULL,
+  string.pred = ""Predictors"", string.dv = ""Dependent Variables"",
+  show.header = FALSE, string.interc = ""(Intercept)"",
+  string.obs = ""Observations"", string.est = ""OR"", string.ci = ""CI"",
+  string.se = ""std. Error"", string.p = ""p"", digits.est = 2,
+  digits.p = 3, digits.ci = 2, digits.se = 2, digits.summary = 3,
+  exp.coef = TRUE, p.numeric = TRUE, boldpvalues = TRUE, show.ci = TRUE,
+  show.se = FALSE, ci.hyphen = ""&nbsp;&ndash;&nbsp;"",
+  separate.ci.col = TRUE, newline.ci = TRUE, group.pred = TRUE,
+  show.col.header = TRUE, show.r2 = FALSE, show.icc = FALSE,
+  show.re.var = FALSE, show.loglik = FALSE, show.aic = FALSE,
+  show.aicc = FALSE, show.dev = FALSE, show.chi2 = FALSE,
+  show.hoslem = FALSE, show.family = FALSE, remove.estimates = NULL,
+  cell.spacing = 0.2, cell.gpr.indent = 0.6, encoding = NULL,
+  CSS = NULL, use.viewer = TRUE, no.output = FALSE,
+  remove.spaces = TRUE)
 }
 \arguments{
 \item{...}{one or more fitted generalized linear (mixed) models.}
@@ -29,29 +28,29 @@ sjt.glm(..., file = NULL, labelPredictors = NULL, depvar.labels = NULL,
 If \code{NULL} (default), the output will be saved as temporary file and 
 openend either in the IDE's viewer pane or the default web browser.}
 
-\item{labelPredictors}{character vector with labels of predictor variables.
-If not \code{NULL}, \code{labelPredictors} will be used in the first
+\item{pred.labels}{character vector with labels of predictor variables.
+If not \code{NULL}, \code{pred.labels} will be used in the first
 table column with the predictors' names. If \code{NULL}, variable
 labels are set based on label attributes (see \code{\link[sjmisc]{get_label}}),
-If \code{labelPredictors = """"}, column names (vector names) are used
+If \code{pred.labels = """"}, column names (vector names) are used
 as predictor labels. See 'Examples'.}
 
 \item{depvar.labels}{character vector with labels of dependent 
 variables of all fitted models. See 'Examples'.}
 
-\item{stringPredictors}{string constant used as headline for the predictor column.
+\item{string.pred}{string constant used as headline for the predictor column.
 Default is \code{""Predictors""}.}
 
-\item{stringDependentVariables}{string constant used as headline for the 
+\item{string.dv}{string constant used as headline for the 
 dependent variable columns. Default is \code{""Dependent Variables""}.}
 
-\item{showHeaderStrings}{logical, if \code{TRUE}, the header strings \code{stringPredictors}
-and \code{stringDependentVariables} are shown. By default, they're hidden.}
+\item{show.header}{logical, if \code{TRUE}, the header strings \code{string.pred}
+and \code{string.dv} are shown. By default, they're hidden.}
 
-\item{stringIntercept}{string constant used as headline for the Intercept row.
+\item{string.interc}{string constant used as headline for the Intercept row.
 Default is \code{""Intercept""}.}
 
-\item{stringObservations}{string constant used in the summary row for the count of observation
+\item{string.obs}{string constant used in the summary row for the count of observation
 (cases). Default is \code{""Observations""}.}
 
 \item{string.est}{string used for the column heading of estimates.}
@@ -60,7 +59,7 @@ Default is \code{""Intercept""}.}
 
 \item{string.se}{string used for the column heading of standard error values. Default is \code{""std. Error""}.}
 
-\item{stringP}{string used for the column heading of p values. Default is \code{""p""}.}
+\item{string.p}{string used for the column heading of p values. Default is \code{""p""}.}
 
 \item{digits.est}{amount of decimals for estimates}
 
@@ -82,70 +81,70 @@ as numbers. If \code{FALSE} (default), asterisks are used.}
 
 \item{boldpvalues}{logical, if \code{TRUE} (default), significant p-values are shown bold faced.}
 
-\item{showConfInt}{logical, if \code{TRUE} (default), the confidence intervall is also printed to the table. Use
+\item{show.ci}{logical, if \code{TRUE} (default), the confidence intervall is also printed to the table. Use
 \code{FALSE} to omit the CI in the table.}
 
-\item{showStdError}{logical, if \code{TRUE}, the standard errors are also printed.
+\item{show.se}{logical, if \code{TRUE}, the standard errors are also printed.
 Default is \code{FALSE}.}
 
 \item{ci.hyphen}{string, indicating the hyphen for confidence interval range.
 May be an HTML entity. See 'Examples'.}
 
-\item{separateConfColumn}{if \code{TRUE}, the CI values are shown in a separate table column.
+\item{separate.ci.col}{if \code{TRUE}, the CI values are shown in a separate table column.
 Default is \code{FALSE}.}
 
-\item{newLineConf}{logical, if \code{TRUE} and \code{separateConfColumn = FALSE}, inserts a line break
-between OR and CI values. If \code{FALSE}, CI values are printed in the same
-line with OR values.}
+\item{newline.ci}{logical, if \code{TRUE} and \code{separate.ci.col = FALSE}, inserts a line break
+between estimate and CI values. If \code{FALSE}, CI values are printed in the same
+line as estimate values.}
 
 \item{group.pred}{logical, if \code{TRUE} (default), automatically groups table rows with 
 factor levels of same factor, i.e. predictors of type \code{\link{factor}} will
 be grouped, if the factor has more than two levels. Grouping means that a separate headline
 row is inserted to the table just before the predictor values.}
 
-\item{showAbbrHeadline}{logical, if \code{TRUE} (default), the table data columns have a headline with 
-abbreviations for odds ratios, confidence interval and p-values.}
+\item{show.col.header}{logical, if \code{TRUE} (default), the table data columns have a headline with 
+abbreviations for estimates, std. beta-values, confidence interval and p-values.}
 
 \item{show.r2}{logical, if \code{TRUE} (default), the pseudo R2 values for each model are printed
 in the model summary. R2cs is the Cox-Snell-pseudo R-squared value, R2n is Nagelkerke's 
 pseudo R-squared value and \code{D} is Tjur's Coefficient of Discrimination
 (see \code{\link[sjmisc]{cod}}).}
 
-\item{showICC}{logical, if \code{TRUE}, the intra-class-correlation for each 
+\item{show.icc}{logical, if \code{TRUE}, the intra-class-correlation for each 
 model is printed in the model summary. Only applies to mixed models.}
 
-\item{showREvar}{logical, if \code{TRUE}, the variance parameters for the random
+\item{show.re.var}{logical, if \code{TRUE}, the variance parameters for the random
 effects for each model are printed in the model summary. Only applies to mixed models.
 For details output, see 'Note' in \code{\link[sjmisc]{icc}}.}
 
 \item{show.loglik}{logical, if \code{TRUE}, the Log-Likelihood for each model is printed
 in the model summary. Default is \code{FALSE}.}
 
-\item{showAIC}{logical, if \code{TRUE}, the AIC value for each model is printed
+\item{show.aic}{logical, if \code{TRUE}, the AIC value for each model is printed
 in the model summary. Default is \code{FALSE}.}
 
-\item{showAICc}{logical, if \code{TRUE}, the second-order AIC value for each model 
+\item{show.aicc}{logical, if \code{TRUE}, the second-order AIC value for each model 
 is printed in the model summary. Default is \code{FALSE}.}
 
-\item{showDeviance}{logical, if \code{TRUE}, the deviance for each model 
+\item{show.dev}{logical, if \code{TRUE}, the deviance for each model 
 is printed in the model summary.}
 
-\item{showChi2}{logical, if \code{TRUE}, the p-value of the chi-squared value for each 
+\item{show.chi2}{logical, if \code{TRUE}, the p-value of the chi-squared value for each 
 model's residual deviance against the null deviance is printed
 in the model summary. Default is \code{FALSE}. A well-fitting model
 with predictors should significantly differ from the null-model
 (without predictors), thus, a p-value less than 0.05 indicates a
 good model-fit.}
 
-\item{showHosLem}{logical, if \code{TRUE}, a Hosmer-Lemeshow-Goodness-of-fit-test is
+\item{show.hoslem}{logical, if \code{TRUE}, a Hosmer-Lemeshow-Goodness-of-fit-test is
 performed. A well-fitting model shows no significant difference between 
 the model and the observed data, i.e. the reported p-values should be
 greater than 0.05.}
 
-\item{showFamily}{logical, if \code{TRUE}, the family object and link function for each fitted model
+\item{show.family}{logical, if \code{TRUE}, the family object and link function for each fitted model
 are printed. Can be used in case you want to compare models with different link functions
 and same predictors and response, to decide which model fits best. See \code{\link{family}}
-for more details. It is recommended to inspect the model \code{\link{AIC}} (see \code{showAIC}) to get a
+for more details. It is recommended to inspect the model \code{\link{AIC}} (see \code{show.aic}) to get a
 decision help for which model to choose.}
 
 \item{remove.estimates}{numeric vector with indices (order equals to row index of \code{coef(fit)}) 
@@ -156,12 +155,12 @@ would remove the 2nd to the 4th estimate (1st to 3rd predictor after intercept)
 \code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default 
 is \code{NULL}, i.e. all estimates are printed.}
 
-\item{cellSpacing}{numeric, inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
+\item{cell.spacing}{numeric, inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
 suitable for viewing the table. Decrease this value (0.05 to 0.1) if you want to import the table
 into Office documents. This is a convenient argument for the \code{CSS} argument for changing
 cell spacing, which would be: \code{CSS = list(css.thead = ""padding:0.2cm;"", css.tdata = ""padding:0.2cm;"")}.}
 
-\item{cellGroupIndent}{indent for table rows with grouped factor predictors. Only applies
+\item{cell.gpr.indent}{indent for table rows with grouped factor predictors. Only applies
 if \code{group.pred = TRUE}.}
 
 \item{encoding}{string, indicating the charset encoding used for variable and 
@@ -172,7 +171,7 @@ Windows OS). Change encoding if specific chars are not properly displayed (e.g.
 \item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the 
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
-\item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
+\item{use.viewer}{If \code{TRUE}, the HTML table is shown in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
 \item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -224,29 +223,29 @@ fitOR3 <- glm(y3 ~ Education + Examination + Catholic, data = swiss,
 # open HTML-table in RStudio Viewer Pane or web browser
 sjt.glm(fitOR1, fitOR2, 
         depvar.labels = c(""Fertility"", ""Infant Mortality""),
-        labelPredictors = c(""Education"", ""Examination"", ""Catholic""),
+        pred.labels = c(""Education"", ""Examination"", ""Catholic""),
         ci.hyphen = "" to "")
 
 # open HTML-table in RStudio Viewer Pane or web browser,
 # integrate CI in OR column
 sjt.glm(fitOR1, fitOR2, fitOR3,
-        labelPredictors = c(""Education"", ""Examination"", ""Catholic""),
-        separateConfColumn = FALSE)
+        pred.labels = c(""Education"", ""Examination"", ""Catholic""),
+        separate.ci.col = FALSE)
 
 # open HTML-table in RStudio Viewer Pane or web browser,
 # indicating p-values as numbers and printing CI in a separate column
 sjt.glm(fitOR1, fitOR2, fitOR3,
         depvar.labels = c(""Fertility"", ""Infant Mortality"", ""Agriculture""),
-        labelPredictors = c(""Education"", ""Examination"", ""Catholic""))
+        pred.labels = c(""Education"", ""Examination"", ""Catholic""))
 
 
 # -------------------------------------------- 
 # User defined style sheet
 # -------------------------------------------- 
 sjt.glm(fitOR1, fitOR2, fitOR3,
         depvar.labels = c(""Fertility"", ""Infant Mortality"", ""Agriculture""),
-        labelPredictors = c(""Education"", ""Examination"", ""Catholic""),
-        showHeaderStrings = TRUE,
+        pred.labels = c(""Education"", ""Examination"", ""Catholic""),
+        show.header = TRUE,
         CSS = list(css.table = ""border: 2px solid;"",
                    css.tdata = ""border: 1px solid;"",
                    css.depvarhead = ""color:#003399;""))
@@ -270,7 +269,7 @@ fit3 <- glm(services ~ neg_c_7 + c161sex + e42dep,
             data = efc, family = poisson(link = ""log""))
             
 # compare models
-sjt.glm(fit1, fit2, fit3, showAIC = TRUE, showFamily = TRUE)
+sjt.glm(fit1, fit2, fit3, show.aic = TRUE, show.family = TRUE)
 
 
 # --------------------------------------------
@@ -279,15 +278,15 @@ sjt.glm(fit1, fit2, fit3, showAIC = TRUE, showFamily = TRUE)
 # open HTML-table in RStudio Viewer Pane or web browser,
 # table indicating p-values as stars
 sjt.glm(fit1, fit2, fit3, p.numeric = FALSE,
-        showAIC = TRUE, showFamily = TRUE)
+        show.aic = TRUE, show.family = TRUE)
 
 # open HTML-table in RStudio Viewer Pane or web browser,
 # indicating p-values as stars and integrate CI in OR column
 sjt.glm(fit1, fit2, fit3, 
         p.numeric = FALSE,
-        separateConfColumn = FALSE,
-        showAIC = TRUE, 
-        showFamily = TRUE,
+        separate.ci.col = FALSE,
+        show.aic = TRUE, 
+        show.family = TRUE,
         show.r2 = TRUE)
 
 # ---------------------------------- 

---FILE: man/sjt.glmer.Rd---
@@ -4,23 +4,21 @@
 \alias{sjt.glmer}
 \title{Summary of generalized linear mixed models as HTML table}
 \usage{
-sjt.glmer(..., file = NULL, labelPredictors = NULL, depvar.labels = NULL,
-  stringPredictors = ""Predictors"",
-  stringDependentVariables = ""Dependent Variables"",
-  showHeaderStrings = FALSE, stringIntercept = ""(Intercept)"",
-  stringObservations = ""Observations"", string.est = ""OR"",
-  string.ci = ""CI"", string.se = ""std. Error"", stringP = ""p"",
-  digits.est = 2, digits.p = 3, digits.ci = 2, digits.se = 2,
-  digits.summary = 3, exp.coef = TRUE, p.numeric = TRUE,
-  boldpvalues = TRUE, showConfInt = TRUE, showStdError = FALSE,
-  ci.hyphen = ""&nbsp;&ndash;&nbsp;"", separateConfColumn = TRUE,
-  newLineConf = TRUE, group.pred = FALSE, showAbbrHeadline = TRUE,
-  show.r2 = FALSE, showICC = TRUE, showREvar = TRUE,
-  show.loglik = FALSE, showAIC = FALSE, showAICc = FALSE,
-  showDeviance = TRUE, showHosLem = FALSE, showFamily = FALSE,
-  remove.estimates = NULL, cellSpacing = 0.2, cellGroupIndent = 0.6,
-  encoding = NULL, CSS = NULL, useViewer = TRUE, no.output = FALSE,
-  remove.spaces = TRUE)
+sjt.glmer(..., file = NULL, pred.labels = NULL, depvar.labels = NULL,
+  string.pred = ""Predictors"", string.dv = ""Dependent Variables"",
+  show.header = FALSE, string.interc = ""(Intercept)"",
+  string.obs = ""Observations"", string.est = ""OR"", string.ci = ""CI"",
+  string.se = ""std. Error"", string.p = ""p"", digits.est = 2,
+  digits.p = 3, digits.ci = 2, digits.se = 2, digits.summary = 3,
+  exp.coef = TRUE, p.numeric = TRUE, boldpvalues = TRUE, show.ci = TRUE,
+  show.se = FALSE, ci.hyphen = ""&nbsp;&ndash;&nbsp;"",
+  separate.ci.col = TRUE, newline.ci = TRUE, group.pred = FALSE,
+  show.col.header = TRUE, show.r2 = FALSE, show.icc = TRUE,
+  show.re.var = TRUE, show.loglik = FALSE, show.aic = FALSE,
+  show.aicc = FALSE, show.dev = TRUE, show.hoslem = FALSE,
+  show.family = FALSE, remove.estimates = NULL, cell.spacing = 0.2,
+  cell.gpr.indent = 0.6, encoding = NULL, CSS = NULL, use.viewer = TRUE,
+  no.output = FALSE, remove.spaces = TRUE)
 }
 \arguments{
 \item{...}{one or more fitted generalized linear (mixed) models.}
@@ -29,29 +27,29 @@ sjt.glmer(..., file = NULL, labelPredictors = NULL, depvar.labels = NULL,
 If \code{NULL} (default), the output will be saved as temporary file and 
 openend either in the IDE's viewer pane or the default web browser.}
 
-\item{labelPredictors}{character vector with labels of predictor variables.
-If not \code{NULL}, \code{labelPredictors} will be used in the first
+\item{pred.labels}{character vector with labels of predictor variables.
+If not \code{NULL}, \code{pred.labels} will be used in the first
 table column with the predictors' names. If \code{NULL}, variable
 labels are set based on label attributes (see \code{\link[sjmisc]{get_label}}),
-If \code{labelPredictors = """"}, column names (vector names) are used
+If \code{pred.labels = """"}, column names (vector names) are used
 as predictor labels. See 'Examples'.}
 
 \item{depvar.labels}{character vector with labels of dependent 
 variables of all fitted models. See 'Examples'.}
 
-\item{stringPredictors}{string constant used as headline for the predictor column.
+\item{string.pred}{string constant used as headline for the predictor column.
 Default is \code{""Predictors""}.}
 
-\item{stringDependentVariables}{string constant used as headline for the 
+\item{string.dv}{string constant used as headline for the 
 dependent variable columns. Default is \code{""Dependent Variables""}.}
 
-\item{showHeaderStrings}{logical, if \code{TRUE}, the header strings \code{stringPredictors}
-and \code{stringDependentVariables} are shown. By default, they're hidden.}
+\item{show.header}{logical, if \code{TRUE}, the header strings \code{string.pred}
+and \code{string.dv} are shown. By default, they're hidden.}
 
-\item{stringIntercept}{string constant used as headline for the Intercept row.
+\item{string.interc}{string constant used as headline for the Intercept row.
 Default is \code{""Intercept""}.}
 
-\item{stringObservations}{string constant used in the summary row for the count of observation
+\item{string.obs}{string constant used in the summary row for the count of observation
 (cases). Default is \code{""Observations""}.}
 
 \item{string.est}{string used for the column heading of estimates.}
@@ -60,7 +58,7 @@ Default is \code{""Intercept""}.}
 
 \item{string.se}{string used for the column heading of standard error values. Default is \code{""std. Error""}.}
 
-\item{stringP}{string used for the column heading of p values. Default is \code{""p""}.}
+\item{string.p}{string used for the column heading of p values. Default is \code{""p""}.}
 
 \item{digits.est}{amount of decimals for estimates}
 
@@ -82,63 +80,63 @@ as numbers. If \code{FALSE} (default), asterisks are used.}
 
 \item{boldpvalues}{logical, if \code{TRUE} (default), significant p-values are shown bold faced.}
 
-\item{showConfInt}{logical, if \code{TRUE} (default), the confidence intervall is also printed to the table. Use
+\item{show.ci}{logical, if \code{TRUE} (default), the confidence intervall is also printed to the table. Use
 \code{FALSE} to omit the CI in the table.}
 
-\item{showStdError}{logical, if \code{TRUE}, the standard errors are also printed.
+\item{show.se}{logical, if \code{TRUE}, the standard errors are also printed.
 Default is \code{FALSE}.}
 
 \item{ci.hyphen}{string, indicating the hyphen for confidence interval range.
 May be an HTML entity. See 'Examples'.}
 
-\item{separateConfColumn}{if \code{TRUE}, the CI values are shown in a separate table column.
+\item{separate.ci.col}{if \code{TRUE}, the CI values are shown in a separate table column.
 Default is \code{FALSE}.}
 
-\item{newLineConf}{logical, if \code{TRUE} and \code{separateConfColumn = FALSE}, inserts a line break
-between OR and CI values. If \code{FALSE}, CI values are printed in the same
-line with OR values.}
+\item{newline.ci}{logical, if \code{TRUE} and \code{separate.ci.col = FALSE}, inserts a line break
+between estimate and CI values. If \code{FALSE}, CI values are printed in the same
+line as estimate values.}
 
 \item{group.pred}{logical, if \code{TRUE} (default), automatically groups table rows with 
 factor levels of same factor, i.e. predictors of type \code{\link{factor}} will
 be grouped, if the factor has more than two levels. Grouping means that a separate headline
 row is inserted to the table just before the predictor values.}
 
-\item{showAbbrHeadline}{logical, if \code{TRUE} (default), the table data columns have a headline with 
-abbreviations for odds ratios, confidence interval and p-values.}
+\item{show.col.header}{logical, if \code{TRUE} (default), the table data columns have a headline with 
+abbreviations for estimates, std. beta-values, confidence interval and p-values.}
 
 \item{show.r2}{logical, if \code{TRUE} (default), the pseudo R2 values for each model are printed
 in the model summary. R2cs is the Cox-Snell-pseudo R-squared value, R2n is Nagelkerke's 
 pseudo R-squared value and \code{D} is Tjur's Coefficient of Discrimination
 (see \code{\link[sjmisc]{cod}}).}
 
-\item{showICC}{logical, if \code{TRUE}, the intra-class-correlation for each 
+\item{show.icc}{logical, if \code{TRUE}, the intra-class-correlation for each 
 model is printed in the model summary. Only applies to mixed models.}
 
-\item{showREvar}{logical, if \code{TRUE}, the variance parameters for the random
+\item{show.re.var}{logical, if \code{TRUE}, the variance parameters for the random
 effects for each model are printed in the model summary. Only applies to mixed models.
 For details output, see 'Note' in \code{\link[sjmisc]{icc}}.}
 
 \item{show.loglik}{logical, if \code{TRUE}, the Log-Likelihood for each model is printed
 in the model summary. Default is \code{FALSE}.}
 
-\item{showAIC}{logical, if \code{TRUE}, the AIC value for each model is printed
+\item{show.aic}{logical, if \code{TRUE}, the AIC value for each model is printed
 in the model summary. Default is \code{FALSE}.}
 
-\item{showAICc}{logical, if \code{TRUE}, the second-order AIC value for each model 
+\item{show.aicc}{logical, if \code{TRUE}, the second-order AIC value for each model 
 is printed in the model summary. Default is \code{FALSE}.}
 
-\item{showDeviance}{logical, if \code{TRUE}, the deviance for each model 
+\item{show.dev}{logical, if \code{TRUE}, the deviance for each model 
 is printed in the model summary.}
 
-\item{showHosLem}{logical, if \code{TRUE}, a Hosmer-Lemeshow-Goodness-of-fit-test is
+\item{show.hoslem}{logical, if \code{TRUE}, a Hosmer-Lemeshow-Goodness-of-fit-test is
 performed. A well-fitting model shows no significant difference between 
 the model and the observed data, i.e. the reported p-values should be
 greater than 0.05.}
 
-\item{showFamily}{logical, if \code{TRUE}, the family object and link function for each fitted model
+\item{show.family}{logical, if \code{TRUE}, the family object and link function for each fitted model
 are printed. Can be used in case you want to compare models with different link functions
 and same predictors and response, to decide which model fits best. See \code{\link{family}}
-for more details. It is recommended to inspect the model \code{\link{AIC}} (see \code{showAIC}) to get a
+for more details. It is recommended to inspect the model \code{\link{AIC}} (see \code{show.aic}) to get a
 decision help for which model to choose.}
 
 \item{remove.estimates}{numeric vector with indices (order equals to row index of \code{coef(fit)}) 
@@ -149,12 +147,12 @@ would remove the 2nd to the 4th estimate (1st to 3rd predictor after intercept)
 \code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default 
 is \code{NULL}, i.e. all estimates are printed.}
 
-\item{cellSpacing}{numeric, inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
+\item{cell.spacing}{numeric, inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
 suitable for viewing the table. Decrease this value (0.05 to 0.1) if you want to import the table
 into Office documents. This is a convenient argument for the \code{CSS} argument for changing
 cell spacing, which would be: \code{CSS = list(css.thead = ""padding:0.2cm;"", css.tdata = ""padding:0.2cm;"")}.}
 
-\item{cellGroupIndent}{indent for table rows with grouped factor predictors. Only applies
+\item{cell.gpr.indent}{indent for table rows with grouped factor predictors. Only applies
 if \code{group.pred = TRUE}.}
 
 \item{encoding}{string, indicating the charset encoding used for variable and 
@@ -165,7 +163,7 @@ Windows OS). Change encoding if specific chars are not properly displayed (e.g.
 \item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the 
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
-\item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
+\item{use.viewer}{If \code{TRUE}, the HTML table is shown in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
 \item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -199,7 +197,7 @@ See 'Details' in \code{\link{sjt.frq}}.
 Computation of p-values (if necessary) are based on Wald chi-squared tests from the 
         \code{Anova}-function of the \pkg{car}-package.
         \cr \cr
-        The variance components of the random parts (see \code{showREvar}) are
+        The variance components of the random parts (see \code{show.re.var}) are
         denoted like:
         \itemize{
          \item between-group-variance: tau-zero-zero
@@ -239,21 +237,21 @@ sjt.glmer(fit1, fit2,
 
 # print summary table, using different table layout
 sjt.glmer(fit1, fit2,
-          showAIC = TRUE,
-          showConfInt = FALSE,
-          showStdError = TRUE,
+          show.aic = TRUE,
+          show.ci = FALSE,
+          show.se = TRUE,
           p.numeric = FALSE)
           
 # print summary table
 sjt.glmer(fit1, fit2,
-          labelPredictors = c(""Elder's gender (female)"",
+          pred.labels = c(""Elder's gender (female)"",
                               ""Hours of care per week"",
                               ""Negative Impact"",
                               ""Educational level (mid)"",
                               ""Educational level (high)""))
 
 # use vector names as predictor labels
-sjt.glmer(fit1, fit2, labelPredictors = """")}
+sjt.glmer(fit1, fit2, pred.labels = """")}
 
 
 }

---FILE: man/sjt.grpmean.Rd---
@@ -6,7 +6,8 @@
 \usage{
 sjt.grpmean(var.cnt, var.grp, weight.by = NULL, rowLabels = NULL,
   digits = 2, digits.summary = 3, file = NULL, encoding = NULL,
-  CSS = NULL, useViewer = TRUE, no.output = FALSE, remove.spaces = TRUE)
+  CSS = NULL, use.viewer = TRUE, no.output = FALSE,
+  remove.spaces = TRUE)
 }
 \arguments{
 \item{var.cnt}{vector of counts, for which frequencies or means will be plotted or printed.}
@@ -38,7 +39,7 @@ Windows OS). Change encoding if specific chars are not properly displayed (e.g.
 \item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the 
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
-\item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
+\item{use.viewer}{If \code{TRUE}, the HTML table is shown in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
 \item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in

---FILE: man/sjt.itemanalysis.Rd---
@@ -8,7 +8,7 @@ sjt.itemanalysis(df, factor.groups = NULL, factor.groups.titles = ""auto"",
   scaleItems = FALSE, minValidRowMeanValue = 2, alternateRowColors = TRUE,
   sort.col = NULL, sort.asc = TRUE, showShapiro = FALSE,
   showKurtosis = FALSE, showCompCorrMat = TRUE, file = NULL,
-  encoding = NULL, CSS = NULL, useViewer = TRUE, no.output = FALSE,
+  encoding = NULL, CSS = NULL, use.viewer = TRUE, no.output = FALSE,
   remove.spaces = TRUE)
 }
 \arguments{
@@ -71,7 +71,7 @@ Windows OS). Change encoding if specific chars are not properly displayed (e.g.
 \item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the 
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
-\item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
+\item{use.viewer}{If \code{TRUE}, the HTML table is shown in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
 \item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in

---FILE: man/sjt.lm.Rd---
@@ -4,22 +4,21 @@
 \alias{sjt.lm}
 \title{Summary of linear regression as HTML table}
 \usage{
-sjt.lm(..., file = NULL, labelPredictors = NULL, depvar.labels = NULL,
-  stringPredictors = ""Predictors"",
-  stringDependentVariables = ""Dependent Variables"",
-  showHeaderStrings = FALSE, stringIntercept = ""(Intercept)"",
-  stringObservations = ""Observations"", string.est = ""B"",
-  string.std = ""std. Beta"", string.ci = ""CI"", string.se = ""std. Error"",
-  stringP = ""p"", showEst = TRUE, showConfInt = TRUE, showStdBeta = NULL,
-  showStdError = FALSE, ci.hyphen = ""&nbsp;&ndash;&nbsp;"",
-  minus.sign = ""&#45;"", digits.est = 2, digits.p = 3, digits.ci = 2,
-  digits.se = 2, digits.sb = 2, digits.summary = 3, p.numeric = TRUE,
-  boldpvalues = TRUE, p.kr = TRUE, separateConfColumn = TRUE,
-  newLineConf = TRUE, group.pred = TRUE, showAbbrHeadline = TRUE,
-  showR2 = TRUE, showICC = FALSE, showREvar = FALSE, showFStat = FALSE,
-  showAIC = FALSE, showAICc = FALSE, showDeviance = FALSE,
-  remove.estimates = NULL, cellSpacing = 0.2, cellGroupIndent = 0.6,
-  encoding = NULL, CSS = NULL, useViewer = TRUE, no.output = FALSE,
+sjt.lm(..., file = NULL, pred.labels = NULL, depvar.labels = NULL,
+  string.pred = ""Predictors"", string.dv = ""Dependent Variables"",
+  show.header = FALSE, string.interc = ""(Intercept)"",
+  string.obs = ""Observations"", string.est = ""B"", string.std = ""std. Beta"",
+  string.ci = ""CI"", string.se = ""std. Error"", string.p = ""p"",
+  show.est = TRUE, show.ci = TRUE, show.std = NULL, show.se = FALSE,
+  ci.hyphen = ""&nbsp;&ndash;&nbsp;"", minus.sign = ""&#45;"", digits.est = 2,
+  digits.p = 3, digits.ci = 2, digits.se = 2, digits.std = 2,
+  digits.summary = 3, p.numeric = TRUE, boldpvalues = TRUE, p.kr = TRUE,
+  separate.ci.col = TRUE, newline.ci = TRUE, group.pred = TRUE,
+  show.col.header = TRUE, show.r2 = TRUE, show.icc = FALSE,
+  show.re.var = FALSE, show.fstat = FALSE, show.aic = FALSE,
+  show.aicc = FALSE, show.dev = FALSE, remove.estimates = NULL,
+  cell.spacing = 0.2, cell.gpr.indent = 0.6, encoding = NULL,
+  CSS = NULL, use.viewer = TRUE, no.output = FALSE,
   remove.spaces = TRUE)
 }
 \arguments{
@@ -29,29 +28,29 @@ sjt.lm(..., file = NULL, labelPredictors = NULL, depvar.labels = NULL,
 If \code{NULL} (default), the output will be saved as temporary file and 
 openend either in the IDE's viewer pane or the default web browser.}
 
-\item{labelPredictors}{character vector with labels of predictor variables.
-If not \code{NULL}, \code{labelPredictors} will be used in the first
+\item{pred.labels}{character vector with labels of predictor variables.
+If not \code{NULL}, \code{pred.labels} will be used in the first
 table column with the predictors' names. If \code{NULL}, variable
 labels are set based on label attributes (see \code{\link[sjmisc]{get_label}}),
-If \code{labelPredictors = """"}, column names (vector names) are used
+If \code{pred.labels = """"}, column names (vector names) are used
 as predictor labels. See 'Examples'.}
 
 \item{depvar.labels}{character vector with labels of dependent 
 variables of all fitted models. See 'Examples'.}
 
-\item{stringPredictors}{string constant used as headline for the predictor column.
+\item{string.pred}{string constant used as headline for the predictor column.
 Default is \code{""Predictors""}.}
 
-\item{stringDependentVariables}{string constant used as headline for the 
+\item{string.dv}{string constant used as headline for the 
 dependent variable columns. Default is \code{""Dependent Variables""}.}
 
-\item{showHeaderStrings}{logical, if \code{TRUE}, the header strings \code{stringPredictors}
-and \code{stringDependentVariables} are shown. By default, they're hidden.}
+\item{show.header}{logical, if \code{TRUE}, the header strings \code{string.pred}
+and \code{string.dv} are shown. By default, they're hidden.}
 
-\item{stringIntercept}{string constant used as headline for the Intercept row.
+\item{string.interc}{string constant used as headline for the Intercept row.
 Default is \code{""Intercept""}.}
 
-\item{stringObservations}{string constant used in the summary row for the count of observation
+\item{string.obs}{string constant used in the summary row for the count of observation
 (cases). Default is \code{""Observations""}.}
 
 \item{string.est}{string used for the column heading of estimates.}
@@ -62,18 +61,18 @@ Default is \code{""Intercept""}.}
 
 \item{string.se}{string used for the column heading of standard error values. Default is \code{""std. Error""}.}
 
-\item{stringP}{string used for the column heading of p values. Default is \code{""p""}.}
+\item{string.p}{string used for the column heading of p values. Default is \code{""p""}.}
 
-\item{showEst}{logical, if \code{TRUE} (default), the estimates are printed.}
+\item{show.est}{logical, if \code{TRUE} (default), the estimates are printed.}
 
-\item{showConfInt}{logical, if \code{TRUE} (default), the confidence intervall is also printed to the table. Use
+\item{show.ci}{logical, if \code{TRUE} (default), the confidence intervall is also printed to the table. Use
 \code{FALSE} to omit the CI in the table.}
 
-\item{showStdBeta}{indicates whether standardized beta-coefficients should 
+\item{show.std}{indicates whether standardized beta-coefficients should 
 also printed, and if yes, which type of standardization is done.
 See 'Details'.}
 
-\item{showStdError}{logical, if \code{TRUE}, the standard errors are also printed.
+\item{show.se}{logical, if \code{TRUE}, the standard errors are also printed.
 Default is \code{FALSE}.}
 
 \item{ci.hyphen}{string, indicating the hyphen for confidence interval range.
@@ -90,7 +89,7 @@ May be an HTML entity. See 'Examples'.}
 
 \item{digits.se}{amount of decimals for standard error}
 
-\item{digits.sb}{amount of decimals for standardized beta}
+\item{digits.std}{amount of decimals for standardized beta}
 
 \item{digits.summary}{amount of decimals for values in model summary}
 
@@ -103,42 +102,42 @@ as numbers. If \code{FALSE} (default), asterisks are used.}
 F-tests with Kenward-Roger approximation for the df. Caution: Computation
 may take very long time for large samples!}
 
-\item{separateConfColumn}{if \code{TRUE}, the CI values are shown in a separate table column.
+\item{separate.ci.col}{if \code{TRUE}, the CI values are shown in a separate table column.
 Default is \code{FALSE}.}
 
-\item{newLineConf}{logical, if \code{TRUE} and \code{separateConfColumn = FALSE}, inserts a line break
-between B and CI values. If \code{FALSE}, CI values are printed in the same
-line as B values.}
+\item{newline.ci}{logical, if \code{TRUE} and \code{separate.ci.col = FALSE}, inserts a line break
+between estimate and CI values. If \code{FALSE}, CI values are printed in the same
+line as estimate values.}
 
 \item{group.pred}{logical, if \code{TRUE} (default), automatically groups table rows with 
 factor levels of same factor, i.e. predictors of type \code{\link{factor}} will
 be grouped, if the factor has more than two levels. Grouping means that a separate headline
 row is inserted to the table just before the predictor values.}
 
-\item{showAbbrHeadline}{logical, if \code{TRUE} (default), the table data columns have a headline with 
-abbreviations for estimates and std. beta-values, confidence interval and p-values.}
+\item{show.col.header}{logical, if \code{TRUE} (default), the table data columns have a headline with 
+abbreviations for estimates, std. beta-values, confidence interval and p-values.}
 
-\item{showR2}{logical, if \code{TRUE} (default), the R2 and adjusted R2 values for each model are printed
+\item{show.r2}{logical, if \code{TRUE} (default), the R2 and adjusted R2 values for each model are printed
 in the model summary. For linear mixed models, the R2 and Omega-squared values are printed
 (see \code{\link[sjmisc]{r2}} for details).}
 
-\item{showICC}{logical, if \code{TRUE}, the intra-class-correlation for each 
+\item{show.icc}{logical, if \code{TRUE}, the intra-class-correlation for each 
 model is printed in the model summary. Only applies to mixed models.}
 
-\item{showREvar}{logical, if \code{TRUE}, the variance parameters for the random
+\item{show.re.var}{logical, if \code{TRUE}, the variance parameters for the random
 effects for each model are printed in the model summary. Only applies to mixed models.
 For details output, see 'Note' in \code{\link[sjmisc]{icc}}.}
 
-\item{showFStat}{If \code{TRUE}, the F-statistics for each model is printed
+\item{show.fstat}{If \code{TRUE}, the F-statistics for each model is printed
 in the model summary. Default is \code{FALSE}.}
 
-\item{showAIC}{logical, if \code{TRUE}, the AIC value for each model is printed
+\item{show.aic}{logical, if \code{TRUE}, the AIC value for each model is printed
 in the model summary. Default is \code{FALSE}.}
 
-\item{showAICc}{logical, if \code{TRUE}, the second-order AIC value for each model 
+\item{show.aicc}{logical, if \code{TRUE}, the second-order AIC value for each model 
 is printed in the model summary. Default is \code{FALSE}.}
 
-\item{showDeviance}{logical, if \code{TRUE}, the deviance for each model 
+\item{show.dev}{logical, if \code{TRUE}, the deviance for each model 
 is printed in the model summary.}
 
 \item{remove.estimates}{numeric vector with indices (order equals to row index of \code{coef(fit)}) 
@@ -149,12 +148,12 @@ would remove the 2nd to the 4th estimate (1st to 3rd predictor after intercept)
 \code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default 
 is \code{NULL}, i.e. all estimates are printed.}
 
-\item{cellSpacing}{numeric, inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
+\item{cell.spacing}{numeric, inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
 suitable for viewing the table. Decrease this value (0.05 to 0.1) if you want to import the table
 into Office documents. This is a convenient argument for the \code{CSS} argument for changing
 cell spacing, which would be: \code{CSS = list(css.thead = ""padding:0.2cm;"", css.tdata = ""padding:0.2cm;"")}.}
 
-\item{cellGroupIndent}{indent for table rows with grouped factor predictors. Only applies
+\item{cell.gpr.indent}{indent for table rows with grouped factor predictors. Only applies
 if \code{group.pred = TRUE}.}
 
 \item{encoding}{string, indicating the charset encoding used for variable and 
@@ -165,7 +164,7 @@ Windows OS). Change encoding if specific chars are not properly displayed (e.g.
 \item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the 
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
-\item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
+\item{use.viewer}{If \code{TRUE}, the HTML table is shown in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
 \item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -196,18 +195,18 @@ Summarizes (multiple) fitted linear models (coefficients, std. beta values etc.)
                the \code{gls}-function from the \pkg{nlme}-package.
 }
 \details{
-Concerning the \code{showStdBeta} argument, \code{showStdBeta = ""std""}
-           will print normal standardized estimates. \code{showStdBeta = ""std2""},
+Concerning the \code{show.std} argument, \code{show.std = ""std""}
+           will print normal standardized estimates. \code{show.std = ""std2""},
            however, standardization of estimates follows 
            \href{http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf}{Gelman's (2008)}
            suggestion, rescaling the estimates by dividing them by two standard 
            deviations instead of just one. Resulting coefficients are then 
            directly comparable for untransformed binary predictors. This type 
            of standardization uses the \code{\link[arm]{standardize}}-function.
-           For backward compatibility reasons, \code{showStdBeta} also may be 
+           For backward compatibility reasons, \code{show.std} also may be 
            a logical value; if \code{TRUE}, normal standardized estimates are 
-           printed (same effect as \code{showStdBeta = ""std""}). Use 
-           \code{showStdBeta = NULL} (default) or \code{showStdBeta = FALSE},
+           printed (same effect as \code{show.std = ""std""}). Use 
+           \code{show.std = NULL} (default) or \code{show.std = FALSE},
            if standardized estimats should not be printed.
            \cr \cr
            Furthermore, see 'Details' in \code{\link{sjt.frq}}.
@@ -238,28 +237,28 @@ sjt.lm(fit1, fit2)
 sjt.lm(fit1, 
        fit2, 
        depvar.labels = c(""Barthel-Index"", ""Negative Impact""),
-       labelPredictors = c(""Carer's Age"", ""Hours of Care"", 
+       pred.labels = c(""Carer's Age"", ""Hours of Care"", 
                            ""Carer's Sex"", ""Educational Status""))
 
 # use vector names as labels
-sjt.lm(fit1, fit2, labelPredictors = """")
+sjt.lm(fit1, fit2, pred.labels = """")
 
 # show HTML-table, indicating p-values as asterisks
-sjt.lm(fit1, fit2, showStdBeta = TRUE, p.numeric = FALSE)
+sjt.lm(fit1, fit2, show.std = TRUE, p.numeric = FALSE)
 
 # create and open HTML-table in RStudio Viewer Pane or web browser,
 # integrate CI in estimate column
-sjt.lm(fit1, fit2, separateConfColumn = FALSE)
+sjt.lm(fit1, fit2, separate.ci.col = FALSE)
 
 # show HTML-table, indicating p-values as numbers
 # and printing CI in a separate column
-sjt.lm(fit1, fit2, showStdBeta = TRUE)
+sjt.lm(fit1, fit2, show.std = TRUE)
 
 # show HTML-table, indicating p-values as stars
 # and integrate CI in estimate column
-sjt.lm(fit1, fit2, showStdBeta = TRUE, ci.hyphen = "" to "",
+sjt.lm(fit1, fit2, show.std = TRUE, ci.hyphen = "" to "",
        minus.sign = ""&minus;"", p.numeric = FALSE, 
-       separateConfColumn = FALSE)
+       separate.ci.col = FALSE)
 
 # ---------------------------------- 
 # connecting two html-tables
@@ -343,10 +342,10 @@ sjt.lm(fit1, fit2, fit4, fit3)
 
 # show standardized beta only
 sjt.lm(fit1, fit2, fit4, fit3,
-       showEst = FALSE,
-       showStdBeta = TRUE,
-       showAIC = TRUE,
-       showFStat = TRUE)
+       show.est = FALSE,
+       show.std = TRUE,
+       show.aic = TRUE,
+       show.fstat = TRUE)
 
 # -----------------------------------------------------------
 # color insanity. just to show that each column has an own
@@ -355,10 +354,10 @@ sjt.lm(fit1, fit2, fit4, fit3,
 # visually separate your models in the table
 # -----------------------------------------------------------
 sjt.lm(fit1, fit2, fit4, fit3,
-       showStdBeta = TRUE,
-       showAIC = TRUE,
-       showFStat = TRUE,
-       showStdError = TRUE,
+       show.std = TRUE,
+       show.aic = TRUE,
+       show.fstat = TRUE,
+       show.se = TRUE,
        CSS = list(css.modelcolumn1 = 'color:blue;',
                   css.modelcolumn2 = 'color:red;',
                   css.modelcolumn3 = 'color:green;',
@@ -367,8 +366,8 @@ sjt.lm(fit1, fit2, fit4, fit3,
                   css.modelcolumn6 = 'color:#3399cc;'))
 
 sjt.lm(fit1, fit2, fit4, fit3,
-       showEst = FALSE,
-       showStdBeta = TRUE,
+       show.est = FALSE,
+       show.std = TRUE,
        p.numeric = FALSE,
        group.pred = FALSE,
        CSS = list(css.modelcolumn4 = 'border-left:1px solid black;',

---FILE: man/sjt.lmer.Rd---
@@ -4,22 +4,20 @@
 \alias{sjt.lmer}
 \title{Summary of linear mixed effects models as HTML table}
 \usage{
-sjt.lmer(..., file = NULL, labelPredictors = NULL, depvar.labels = NULL,
-  stringPredictors = ""Predictors"",
-  stringDependentVariables = ""Dependent Variables"",
-  showHeaderStrings = FALSE, stringIntercept = ""(Intercept)"",
-  stringObservations = ""Observations"", string.est = ""B"",
-  string.std = ""std. Beta"", string.ci = ""CI"", string.se = ""std. Error"",
-  stringP = ""p"", showEst = TRUE, showConfInt = TRUE,
-  showStdBeta = FALSE, showStdError = FALSE,
+sjt.lmer(..., file = NULL, pred.labels = NULL, depvar.labels = NULL,
+  string.pred = ""Predictors"", string.dv = ""Dependent Variables"",
+  show.header = FALSE, string.interc = ""(Intercept)"",
+  string.obs = ""Observations"", string.est = ""B"", string.std = ""std. Beta"",
+  string.ci = ""CI"", string.se = ""std. Error"", string.p = ""p"",
+  show.est = TRUE, show.ci = TRUE, show.std = FALSE, show.se = FALSE,
   ci.hyphen = ""&nbsp;&ndash;&nbsp;"", minus.sign = ""&#45;"", digits.est = 2,
-  digits.p = 3, digits.ci = 2, digits.se = 2, digits.sb = 2,
+  digits.p = 3, digits.ci = 2, digits.se = 2, digits.std = 2,
   digits.summary = 3, p.numeric = TRUE, boldpvalues = TRUE, p.kr = TRUE,
-  separateConfColumn = TRUE, newLineConf = TRUE, group.pred = FALSE,
-  showAbbrHeadline = TRUE, showR2 = TRUE, showICC = TRUE,
-  showREvar = TRUE, showAIC = FALSE, showAICc = FALSE,
-  showDeviance = TRUE, remove.estimates = NULL, cellSpacing = 0.2,
-  cellGroupIndent = 0.6, encoding = NULL, CSS = NULL, useViewer = TRUE,
+  separate.ci.col = TRUE, newline.ci = TRUE, group.pred = FALSE,
+  show.col.header = TRUE, show.r2 = TRUE, show.icc = TRUE,
+  show.re.var = TRUE, show.aic = FALSE, show.aicc = FALSE,
+  show.dev = TRUE, remove.estimates = NULL, cell.spacing = 0.2,
+  cell.gpr.indent = 0.6, encoding = NULL, CSS = NULL, use.viewer = TRUE,
   no.output = FALSE, remove.spaces = TRUE)
 }
 \arguments{
@@ -29,29 +27,29 @@ sjt.lmer(..., file = NULL, labelPredictors = NULL, depvar.labels = NULL,
 If \code{NULL} (default), the output will be saved as temporary file and 
 openend either in the IDE's viewer pane or the default web browser.}
 
-\item{labelPredictors}{character vector with labels of predictor variables.
-If not \code{NULL}, \code{labelPredictors} will be used in the first
+\item{pred.labels}{character vector with labels of predictor variables.
+If not \code{NULL}, \code{pred.labels} will be used in the first
 table column with the predictors' names. If \code{NULL}, variable
 labels are set based on label attributes (see \code{\link[sjmisc]{get_label}}),
-If \code{labelPredictors = """"}, column names (vector names) are used
+If \code{pred.labels = """"}, column names (vector names) are used
 as predictor labels. See 'Examples'.}
 
 \item{depvar.labels}{character vector with labels of dependent 
 variables of all fitted models. See 'Examples'.}
 
-\item{stringPredictors}{string constant used as headline for the predictor column.
+\item{string.pred}{string constant used as headline for the predictor column.
 Default is \code{""Predictors""}.}
 
-\item{stringDependentVariables}{string constant used as headline for the 
+\item{string.dv}{string constant used as headline for the 
 dependent variable columns. Default is \code{""Dependent Variables""}.}
 
-\item{showHeaderStrings}{logical, if \code{TRUE}, the header strings \code{stringPredictors}
-and \code{stringDependentVariables} are shown. By default, they're hidden.}
+\item{show.header}{logical, if \code{TRUE}, the header strings \code{string.pred}
+and \code{string.dv} are shown. By default, they're hidden.}
 
-\item{stringIntercept}{string constant used as headline for the Intercept row.
+\item{string.interc}{string constant used as headline for the Intercept row.
 Default is \code{""Intercept""}.}
 
-\item{stringObservations}{string constant used in the summary row for the count of observation
+\item{string.obs}{string constant used in the summary row for the count of observation
 (cases). Default is \code{""Observations""}.}
 
 \item{string.est}{string used for the column heading of estimates.}
@@ -62,18 +60,18 @@ Default is \code{""Intercept""}.}
 
 \item{string.se}{string used for the column heading of standard error values. Default is \code{""std. Error""}.}
 
-\item{stringP}{string used for the column heading of p values. Default is \code{""p""}.}
+\item{string.p}{string used for the column heading of p values. Default is \code{""p""}.}
 
-\item{showEst}{logical, if \code{TRUE} (default), the estimates are printed.}
+\item{show.est}{logical, if \code{TRUE} (default), the estimates are printed.}
 
-\item{showConfInt}{logical, if \code{TRUE} (default), the confidence intervall is also printed to the table. Use
+\item{show.ci}{logical, if \code{TRUE} (default), the confidence intervall is also printed to the table. Use
 \code{FALSE} to omit the CI in the table.}
 
-\item{showStdBeta}{indicates whether standardized beta-coefficients should 
+\item{show.std}{indicates whether standardized beta-coefficients should 
 also printed, and if yes, which type of standardization is done.
 See 'Details'.}
 
-\item{showStdError}{logical, if \code{TRUE}, the standard errors are also printed.
+\item{show.se}{logical, if \code{TRUE}, the standard errors are also printed.
 Default is \code{FALSE}.}
 
 \item{ci.hyphen}{string, indicating the hyphen for confidence interval range.
@@ -90,7 +88,7 @@ May be an HTML entity. See 'Examples'.}
 
 \item{digits.se}{amount of decimals for standard error}
 
-\item{digits.sb}{amount of decimals for standardized beta}
+\item{digits.std}{amount of decimals for standardized beta}
 
 \item{digits.summary}{amount of decimals for values in model summary}
 
@@ -103,39 +101,39 @@ as numbers. If \code{FALSE} (default), asterisks are used.}
 F-tests with Kenward-Roger approximation for the df. Caution: Computation
 may take very long time for large samples!}
 
-\item{separateConfColumn}{if \code{TRUE}, the CI values are shown in a separate table column.
+\item{separate.ci.col}{if \code{TRUE}, the CI values are shown in a separate table column.
 Default is \code{FALSE}.}
 
-\item{newLineConf}{logical, if \code{TRUE} and \code{separateConfColumn = FALSE}, inserts a line break
-between B and CI values. If \code{FALSE}, CI values are printed in the same
-line as B values.}
+\item{newline.ci}{logical, if \code{TRUE} and \code{separate.ci.col = FALSE}, inserts a line break
+between estimate and CI values. If \code{FALSE}, CI values are printed in the same
+line as estimate values.}
 
 \item{group.pred}{logical, if \code{TRUE} (default), automatically groups table rows with 
 factor levels of same factor, i.e. predictors of type \code{\link{factor}} will
 be grouped, if the factor has more than two levels. Grouping means that a separate headline
 row is inserted to the table just before the predictor values.}
 
-\item{showAbbrHeadline}{logical, if \code{TRUE} (default), the table data columns have a headline with 
-abbreviations for estimates and std. beta-values, confidence interval and p-values.}
+\item{show.col.header}{logical, if \code{TRUE} (default), the table data columns have a headline with 
+abbreviations for estimates, std. beta-values, confidence interval and p-values.}
 
-\item{showR2}{logical, if \code{TRUE} (default), the R2 and adjusted R2 values for each model are printed
+\item{show.r2}{logical, if \code{TRUE} (default), the R2 and adjusted R2 values for each model are printed
 in the model summary. For linear mixed models, the R2 and Omega-squared values are printed
 (see \code{\link[sjmisc]{r2}} for details).}
 
-\item{showICC}{logical, if \code{TRUE}, the intra-class-correlation for each 
+\item{show.icc}{logical, if \code{TRUE}, the intra-class-correlation for each 
 model is printed in the model summary. Only applies to mixed models.}
 
-\item{showREvar}{logical, if \code{TRUE}, the variance parameters for the random
+\item{show.re.var}{logical, if \code{TRUE}, the variance parameters for the random
 effects for each model are printed in the model summary. Only applies to mixed models.
 For details output, see 'Note' in \code{\link[sjmisc]{icc}}.}
 
-\item{showAIC}{logical, if \code{TRUE}, the AIC value for each model is printed
+\item{show.aic}{logical, if \code{TRUE}, the AIC value for each model is printed
 in the model summary. Default is \code{FALSE}.}
 
-\item{showAICc}{logical, if \code{TRUE}, the second-order AIC value for each model 
+\item{show.aicc}{logical, if \code{TRUE}, the second-order AIC value for each model 
 is printed in the model summary. Default is \code{FALSE}.}
 
-\item{showDeviance}{logical, if \code{TRUE}, the deviance for each model 
+\item{show.dev}{logical, if \code{TRUE}, the deviance for each model 
 is printed in the model summary.}
 
 \item{remove.estimates}{numeric vector with indices (order equals to row index of \code{coef(fit)}) 
@@ -146,12 +144,12 @@ would remove the 2nd to the 4th estimate (1st to 3rd predictor after intercept)
 \code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default 
 is \code{NULL}, i.e. all estimates are printed.}
 
-\item{cellSpacing}{numeric, inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
+\item{cell.spacing}{numeric, inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
 suitable for viewing the table. Decrease this value (0.05 to 0.1) if you want to import the table
 into Office documents. This is a convenient argument for the \code{CSS} argument for changing
 cell spacing, which would be: \code{CSS = list(css.thead = ""padding:0.2cm;"", css.tdata = ""padding:0.2cm;"")}.}
 
-\item{cellGroupIndent}{indent for table rows with grouped factor predictors. Only applies
+\item{cell.gpr.indent}{indent for table rows with grouped factor predictors. Only applies
 if \code{group.pred = TRUE}.}
 
 \item{encoding}{string, indicating the charset encoding used for variable and 
@@ -162,7 +160,7 @@ Windows OS). Change encoding if specific chars are not properly displayed (e.g.
 \item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the 
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
-\item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
+\item{use.viewer}{If \code{TRUE}, the HTML table is shown in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
 \item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -200,7 +198,7 @@ Computation of p-values (if necessary and if \code{p.kr = TRUE}) are based
         \code{p.kr = FALSE}, Wald chi-squared tests from the
         \code{Anova}-function of the \pkg{car}-package are computed.
         \cr \cr
-        The variance components of the random parts (see \code{showREvar}) are
+        The variance components of the random parts (see \code{show.re.var}) are
         denoted like:
         \itemize{
          \item within-group variance: sigma-squared
@@ -242,23 +240,23 @@ sjt.lmer(fit1, fit2,
          minus.sign = ""&minus;"")
 
 # print table, using vector names as labels
-sjt.lmer(fit1, fit2, fit3, labelPredictors = """")
+sjt.lmer(fit1, fit2, fit3, pred.labels = """")
 
 # show other statistics
 sjt.lmer(fit1, fit2,
-         showAIC = TRUE,
-         showConfInt = FALSE,
-         showStdError = TRUE,
+         show.aic = TRUE,
+         show.ci = FALSE,
+         show.se = TRUE,
          p.numeric = FALSE)
            
 sjt.lmer(fit1, fit2, fit3, 
-         showAIC = TRUE,
-         separateConfColumn = FALSE,
-         newLineConf = FALSE)
+         show.aic = TRUE,
+         separate.ci.col = FALSE,
+         newline.ci = FALSE)
 
 # user defined predictor labels
 sjt.lmer(fit1, fit2, fit3,
-         labelPredictors = c(""Elder's gender (female)"",
+         pred.labels = c(""Elder's gender (female)"",
                              ""Hours of care per week"",
                              ""Barthel Index"",
                              ""Educational level (mid)"",

---FILE: man/sjt.mwu.Rd---
@@ -5,7 +5,7 @@
 \title{Summary of Mann-Whitney-Test as HTML table}
 \usage{
 sjt.mwu(x, title = NULL, alternateRowColors = TRUE, file = NULL,
-  encoding = NULL, CSS = NULL, useViewer = TRUE, no.output = FALSE,
+  encoding = NULL, CSS = NULL, use.viewer = TRUE, no.output = FALSE,
   remove.spaces = TRUE)
 }
 \arguments{
@@ -28,7 +28,7 @@ Windows OS). Change encoding if specific chars are not properly displayed (e.g.
 \item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the 
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
-\item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
+\item{use.viewer}{If \code{TRUE}, the HTML table is shown in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
 \item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in

---FILE: man/sjt.pca.Rd---
@@ -11,7 +11,7 @@ sjt.pca(data, numberOfFactors = NULL, factorLoadingTolerance = 0.1,
   showMSA = FALSE, showVariance = FALSE, alternateRowColors = FALSE,
   stringPov = ""Proportion of Variance"",
   stringCpov = ""Cumulative Proportion"", encoding = NULL, CSS = NULL,
-  useViewer = TRUE, no.output = FALSE, remove.spaces = TRUE)
+  use.viewer = TRUE, no.output = FALSE, remove.spaces = TRUE)
 }
 \arguments{
 \item{data}{data frame with factors (each columns one variable) that should be used 
@@ -71,7 +71,7 @@ Windows OS). Change encoding if specific chars are not properly displayed (e.g.
 \item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the 
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
-\item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
+\item{use.viewer}{If \code{TRUE}, the HTML table is shown in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
 \item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in

---FILE: man/sjt.stackfrq.Rd---
@@ -7,10 +7,11 @@
 sjt.stackfrq(items, weight.by = NULL, title = NULL, var.labels = NULL,
   value.labels = NULL, wrap.labels = 20, sort.frq = NULL,
   alternateRowColors = FALSE, digits = 2, show.n = FALSE,
-  showTotalN = FALSE, show.na = FALSE, labelNA = ""NA"", showSkew = FALSE,
-  showKurtosis = FALSE, digits.stats = 2, skewString = ""Skew"",
-  kurtosisString = ""Kurtosis"", file = NULL, encoding = NULL, CSS = NULL,
-  useViewer = TRUE, no.output = FALSE, remove.spaces = TRUE)
+  showTotalN = FALSE, show.na = FALSE, string.na = ""NA"",
+  showSkew = FALSE, showKurtosis = FALSE, digits.stats = 2,
+  skewString = ""Skew"", kurtosisString = ""Kurtosis"", file = NULL,
+  encoding = NULL, CSS = NULL, use.viewer = TRUE, no.output = FALSE,
+  remove.spaces = TRUE)
 }
 \arguments{
 \item{items}{\code{\link{data.frame}} with each column representing one (likert- or scale-)item.}
@@ -51,9 +52,10 @@ group or category to the labels.}
 
 \item{showTotalN}{logical, if \code{TRUE}, an additional column with each item's total N is printed.}
 
-\item{show.na}{logical, if \code{TRUE}, \code{\link{NA}}'s (missing values) are also printed in the table.}
+\item{show.na}{logical, if \code{TRUE}, \code{\link{NA}}'s (missing values)
+are added to the output.}
 
-\item{labelNA}{The label for the missing column/row.}
+\item{string.na}{The label for the missing column/row.}
 
 \item{showSkew}{logical, if \code{TRUE}, an additional column with each item's skewness is printed.
 The skewness is retrieved from the \code{\link[psych]{describe}}-function 
@@ -83,7 +85,7 @@ Windows OS). Change encoding if specific chars are not properly displayed (e.g.
 \item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the 
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
-\item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
+\item{use.viewer}{If \code{TRUE}, the HTML table is shown in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
 \item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -122,31 +124,19 @@ See 'Notes' in \code{\link{sjt.frq}}.
 # random sample
 # -------------------------------
 # prepare data for 4-category likert scale, 5 items
-likert_4 <- data.frame(as.factor(sample(1:4, 
-                                        500, 
-                                        replace = TRUE, 
+likert_4 <- data.frame(as.factor(sample(1:4, 500, replace = TRUE, 
                                         prob = c(0.2, 0.3, 0.1, 0.4))),
-                       as.factor(sample(1:4, 
-                                        500, 
-                                        replace = TRUE, 
+                       as.factor(sample(1:4, 500, replace = TRUE, 
                                         prob = c(0.5, 0.25, 0.15, 0.1))),
-                       as.factor(sample(1:4, 
-                                        500, 
-                                        replace = TRUE, 
+                       as.factor(sample(1:4, 500, replace = TRUE, 
                                         prob = c(0.25, 0.1, 0.4, 0.25))),
-                       as.factor(sample(1:4, 
-                                        500, 
-                                        replace = TRUE, 
+                       as.factor(sample(1:4, 500, replace = TRUE, 
                                         prob = c(0.1, 0.4, 0.4, 0.1))),
-                       as.factor(sample(1:4, 
-                                        500, 
-                                        replace = TRUE, 
+                       as.factor(sample(1:4, 500, replace = TRUE, 
                                         prob = c(0.35, 0.25, 0.15, 0.25))))
 # create labels
-levels_4 <- c(""Independent"", 
-              ""Slightly dependent"", 
-              ""Dependent"", 
-              ""Severely dependent"")
+levels_4 <- c(""Independent"", ""Slightly dependent"", 
+              ""Dependent"", ""Severely dependent"")
 
 # create item labels
 items <- c(""Q1"", ""Q2"", ""Q3"", ""Q4"", ""Q5"")
@@ -167,23 +157,17 @@ start <- which(colnames(efc) == ""c82cop1"")
 # recveive first item of COPE-index scale
 end <- which(colnames(efc) == ""c90cop9"")
 
-sjt.stackfrq(efc[, c(start:end)],
-             alternateRowColors = TRUE)
+sjt.stackfrq(efc[, c(start:end)], alternateRowColors = TRUE)
 
-sjt.stackfrq(efc[, c(start:end)],
-             alternateRowColors = TRUE,
-             show.n = TRUE,
-             show.na = TRUE)
+sjt.stackfrq(efc[, c(start:end)], alternateRowColors = TRUE,
+             show.n = TRUE, show.na = TRUE)
          
          
 # -------------------------------- 
 # User defined style sheet
 # -------------------------------- 
-sjt.stackfrq(efc[, c(start:end)],
-             alternateRowColors = TRUE,
-             showTotalN = TRUE,
-             showSkew = TRUE,
-             showKurtosis = TRUE,
+sjt.stackfrq(efc[, c(start:end)], alternateRowColors = TRUE, 
+             showTotalN = TRUE, showSkew = TRUE, showKurtosis = TRUE,
              CSS = list(css.ncol = ""border-left:1px dotted black;"",
                         css.summary = ""font-style:italic;""))}
              

---FILE: man/sjt.xtab.Rd---
@@ -8,12 +8,12 @@ sjt.xtab(var.row, var.col, weight.by = NULL, digits = 1, file = NULL,
   var.labels = NULL, value.labels = NULL, title = NULL,
   wrap.labels = 20, stringTotal = ""Total"", show.obs = TRUE,
   show.cell.prc = FALSE, show.row.prc = FALSE, show.col.prc = FALSE,
-  show.exp = FALSE, showHorizontalLine = FALSE, show.summary = TRUE,
-  show.legend = FALSE, show.na = FALSE, labelNA = ""NA"",
-  tdcol.n = ""black"", tdcol.expected = ""#339999"", tdcol.cell = ""#993333"",
-  tdcol.row = ""#333399"", tdcol.col = ""#339933"", highlightTotal = FALSE,
-  highlightColor = ""#f8f8f8"", prc.sign = ""&nbsp;&#37;"", hundret = ""100.0"",
-  encoding = NULL, CSS = NULL, useViewer = TRUE, no.output = FALSE,
+  show.exp = FALSE, show.summary = TRUE, show.legend = FALSE,
+  show.na = FALSE, tdcol.n = ""black"", tdcol.expected = ""#339999"",
+  tdcol.cell = ""#993333"", tdcol.row = ""#333399"", tdcol.col = ""#339933"",
+  highlightTotal = FALSE, highlightColor = ""#f8f8f8"",
+  prc.sign = ""&nbsp;&#37;"", hundret = ""100.0"", encoding = NULL,
+  CSS = NULL, use.viewer = TRUE, no.output = FALSE,
   remove.spaces = TRUE)
 }
 \arguments{
@@ -55,17 +55,14 @@ labels are displayed in one line and when a line break is inserted.}
 
 \item{show.exp}{logical, if \code{TRUE}, expected values are also shown}
 
-\item{showHorizontalLine}{logical, if \code{TRUE}, data rows are separated with a horizontal line}
-
 \item{show.summary}{If \code{TRUE} (default), a summary row with total and valid N as well as mean and
 standard deviation is shown.}
 
 \item{show.legend}{logical, if \code{TRUE}, and depending on plot type and
 function, a legend is added to the plot.}
 
-\item{show.na}{logical, if \code{TRUE}, \code{\link{NA}}'s (missing values) are also printed in the table.}
-
-\item{labelNA}{The label for the missing column/row.}
+\item{show.na}{logical, if \code{TRUE}, \code{\link{NA}}'s (missing values)
+are added to the output.}
 
 \item{tdcol.n}{Color for highlighting count (observed) values in table cells. Default is black.}
 
@@ -98,7 +95,7 @@ Windows OS). Change encoding if specific chars are not properly displayed (e.g.
 \item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the 
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
-\item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
+\item{use.viewer}{If \code{TRUE}, the HTML table is shown in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
 \item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -151,7 +148,6 @@ sjt.xtab(efc$e16sex,
 
 # print minimal cross table with labels, total col/row highlighted
 sjt.xtab(efc$e16sex, efc$e42dep, 
-         showHorizontalLine = FALSE,
          show.cell.prc = FALSE,
          highlightTotal = TRUE)
 

---FILE: man/view_df.Rd---
@@ -6,10 +6,10 @@
 \usage{
 view_df(x, weight.by = NULL, file = NULL, alternateRowColors = TRUE,
   show.id = TRUE, show.type = FALSE, show.values = TRUE,
-  show.labels = TRUE, showFreq = FALSE, showPerc = FALSE,
-  showWtdFreq = FALSE, showWtdPerc = FALSE, show.na = FALSE,
-  sortByName = FALSE, wrap.labels = 50, encoding = NULL,
-  hideProgressBar = FALSE, CSS = NULL, useViewer = TRUE,
+  show.labels = TRUE, show.frq = FALSE, show.prc = FALSE,
+  show.wtd.frq = FALSE, show.wtd.prc = FALSE, show.na = FALSE,
+  sort.by.name = FALSE, wrap.labels = 50, encoding = NULL,
+  hide.progress = FALSE, CSS = NULL, use.viewer = TRUE,
   no.output = FALSE, remove.spaces = TRUE)
 }
 \arguments{
@@ -38,20 +38,21 @@ row respectively column.}
 
 \item{show.labels}{logical, if \code{TRUE} (default), the value labels are shown as additional column.}
 
-\item{showFreq}{logical, if \code{TRUE}, an additional column with frequencies for each variable is shown.}
+\item{show.frq}{logical, if \code{TRUE}, an additional column with frequencies for each variable is shown.}
 
-\item{showPerc}{logical, if \code{TRUE}, an additional column with percentage of frequencies for each variable is shown.}
+\item{show.prc}{logical, if \code{TRUE}, an additional column with percentage of frequencies for each variable is shown.}
 
-\item{showWtdFreq}{logical, if \code{TRUE}, an additional column with weighted
+\item{show.wtd.frq}{logical, if \code{TRUE}, an additional column with weighted
 frequencies for each variable is shown. Weights strem from \code{weight.by}.}
 
-\item{showWtdPerc}{logical, if \code{TRUE}, an additional column with weighted
+\item{show.wtd.prc}{logical, if \code{TRUE}, an additional column with weighted
 percentage of frequencies for each variable is shown.
 Weights strem from \code{weight.by}.}
 
-\item{show.na}{logical, if \code{TRUE}, \code{\link{NA}}'s (missing values) are also printed in the table.}
+\item{show.na}{logical, if \code{TRUE}, \code{\link{NA}}'s (missing values)
+are added to the output.}
 
-\item{sortByName}{logical, if \code{TRUE}, rows are sorted according to the variable
+\item{sort.by.name}{logical, if \code{TRUE}, rows are sorted according to the variable
 names. By default, rows (variables) are ordered according to their
 order in the data frame.}
 
@@ -63,13 +64,13 @@ value labels. Default is \code{NULL}, so encoding will be auto-detected
 depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
 Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
 
-\item{hideProgressBar}{If \code{TRUE}, the progress bar that is displayed when creating the
-table is hidden. Default in \code{FALSE}, hence the bar is visible.}
+\item{hide.progress}{logical, if \code{TRUE}, the progress bar that is displayed when creating the
+output is hidden. Default in \code{FALSE}, hence the bar is visible.}
 
 \item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the 
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
-\item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
+\item{use.viewer}{If \code{TRUE}, the HTML table is shown in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
 \item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -118,7 +119,7 @@ view_df(efc)
 view_df(efc, show.values = FALSE, show.labels = FALSE)
 
 # view variables including variable typed, orderd by name
-view_df(efc, sortByName = TRUE, show.type = TRUE)
+view_df(efc, sort.by.name = TRUE, show.type = TRUE)
 
 # ---------------------------------------------------------------- 
 # User defined style sheet"
strengejacke,sjPlot,2cd151e96e7c7207acc4de064e8a8eac8edb72cb,Daniel Ldecke,d.luedecke@uke.de,2016-05-03T17:32:50Z,Daniel Ldecke,d.luedecke@uke.de,2016-05-03T17:32:50Z,fix argument,R/sjPlotAnova.R;man/sjp.aov1.Rd,False,True,True,False,9,7,16,"---FILE: R/sjPlotAnova.R---
@@ -61,7 +61,7 @@ sjp.aov1 <- function(depVar,
                      axis.lim = NULL,
                      geom.colors = c(""#3366a0"", ""#aa3333""),
                      geom.size = 3,
-                     breakTitleAt = 50,
+                     wrap.title = 50,
                      wrap.labels = 25,
                      grid.breaks = NULL,
                      expand.grid = FALSE,
@@ -119,10 +119,10 @@ sjp.aov1 <- function(depVar,
   # --------------------------------------------------------
   # check length of diagram title and split longer string at into new lines
   # every 50 chars
-  if (!is.null(title)) title <- sjmisc::word_wrap(title, breakTitleAt)
+  if (!is.null(title)) title <- sjmisc::word_wrap(title, wrap.title)
   # check length of x-axis title and split longer string at into new lines
   # every 50 chars
-  if (!is.null(axis.title)) axis.title <- sjmisc::word_wrap(axis.title, breakTitleAt)
+  if (!is.null(axis.title)) axis.title <- sjmisc::word_wrap(axis.title, wrap.title)
   # check length of x-axis-labels and split longer strings at into new lines
   # every 10 chars, so labels don't overlap
   if (!is.null(axis.labels)) axis.labels <- sjmisc::word_wrap(axis.labels, wrap.labels)

---FILE: man/sjp.aov1.Rd---
@@ -7,10 +7,9 @@
 sjp.aov1(depVar, grpVar, meansums = FALSE, title = NULL,
   axis.labels = NULL, rev.order = FALSE, stringIntercept = ""(Intercept)"",
   axis.title = """", axis.lim = NULL, geom.colors = c(""#3366a0"", ""#aa3333""),
-  geom.size = 3, breakTitleAt = 50, wrap.labels = 25,
-  grid.breaks = NULL, expand.grid = FALSE, show.values = TRUE,
-  digits = 2, y.offset = 0.1, show.p = TRUE, showModelSummary = FALSE,
-  printPlot = TRUE)
+  geom.size = 3, wrap.title = 50, wrap.labels = 25, grid.breaks = NULL,
+  expand.grid = FALSE, show.values = TRUE, digits = 2, y.offset = 0.1,
+  show.p = TRUE, showModelSummary = FALSE, printPlot = TRUE)
 }
 \arguments{
 \item{depVar}{dependent variable. Will be used with following formula:
@@ -46,6 +45,9 @@ highest, so plot has maximum zoom.}
 depending on plot type and function. Note that bar and bin widths mostly 
 need smaller values than dot sizes.}
 
+\item{wrap.title}{numeric, determines how many chars of the plot title are displayed in
+one line and when a line break is inserted.}
+
 \item{wrap.labels}{determines how many chars of the category, variable or axis 
 labels are displayed in one line and when a line break is inserted.}
 "
strengejacke,sjPlot,bf8d1e395d220d0f8dbaaded5d67d5432ab4039d,Daniel Ldecke,d.luedecke@uke.de,2016-05-01T20:11:30Z,Daniel Ldecke,d.luedecke@uke.de,2016-05-01T20:11:30Z,fixed bug with y-axis title in sjp.int,R/helpfunctions.R;R/sjPlotAncovaLSMeans.R;R/sjPlotInteractions.R,False,True,True,False,14,7,21,"---FILE: R/helpfunctions.R---
@@ -475,7 +475,7 @@ retrieveModelGroupIndices <- function(models, rem_rows = NULL) {
   for (k in 1:length(models)) {
     # get model
     fit <- models[[k]]
-    # copy model matrix
+    # copy model frame
     fmodel <- stats::model.frame(fit)
     # get model coefficients' names
     if (is_merMod(fit)) {

---FILE: R/sjPlotAncovaLSMeans.R---
@@ -287,6 +287,7 @@ sjp.emm <- function(fit,
       } else {
         labx <- axis.title
       }
+      # y-axis label
       laby <- response.label
       # -----------------------------------------------------------
       # prepare annotation labels

---FILE: R/sjPlotInteractions.R---
@@ -1146,14 +1146,15 @@ sjp.eff.int <- function(fit,
     }
     # make sure x is numeric
     intdf$x <- sjmisc::to_value(intdf$x, keep.labels = F)
+    # get name of response, for axis title
+    yaxisname <- sjmisc::get_label(stats::model.frame(fit)[[response.name]], 
+                                   def.value = response.name)
     # -----------------------------------------------------------
     # check if we have linear regression
     # -----------------------------------------------------------
-    y_title <- NULL
     if (fun == ""lm"" || fun == ""lmer"" || fun == ""lme"" || fun == ""gls"") {
       # Label on y-axis is name of dependent variable
-      y_title <- sjmisc::get_label(stats::model.frame(fit)[[response.name]], 
-                                       def.value = response.name)
+      y_title <- sprintf(""Predicted values of %s"", yaxisname)
       # -----------------------------------------------------------
       # retrieve lowest and highest x and y position to determine
       # the scale limits
@@ -1186,9 +1187,11 @@ sjp.eff.int <- function(fit,
       # --------------------------------------------------------
       # for logistic reg.
       if (binom_fam)
-        y_title <- ""Predicted Probability""
+        y_title <- sprintf(""Predicted probabilities for %s"", yaxisname)
       else if (poisson_fam)
-        y_title <- ""Predicted Incidents""
+        y_title <- sprintf(""Predicted incidents for %s"", yaxisname)
+      else
+        y_title <- sprintf(""Predicted values for %s"", yaxisname)
       # -----------------------------------------------------------
       # retrieve lowest and highest x and y position to determine
       # the scale limits
@@ -1301,11 +1304,14 @@ sjp.eff.int <- function(fit,
       # set axis title
       labx <- axis.title[l_nr]
     }
-    if (!is.null(y_title)) laby <- y_title
+    # y-axis title.
+    laby <- y_title
     # -----------------------------------------------------------
     # wrap titles
     # -----------------------------------------------------------
     labtitle <- sjmisc::word_wrap(labtitle, breakTitleAt)
+    labx <- sjmisc::word_wrap(labx, breakTitleAt)
+    laby <- sjmisc::word_wrap(laby, breakTitleAt)
     # wrap legend labels
     lLabels <- sjmisc::word_wrap(lLabels, breakLegendLabelsAt)
     # wrap legend title"
strengejacke,sjPlot,07efca7885a91930022b8b8b20f8a1c13b0968c8,Daniel Ldecke,d.luedecke@uke.de,2016-04-27T16:38:54Z,Daniel Ldecke,d.luedecke@uke.de,2016-04-27T16:38:54Z,minor fixes,R/sjPlotGLME.R;R/sjPlotPCA.R;R/sjTabCorr.R;R/sjTabPCA.R;man/sjp.glmer.Rd;man/sjp.lmer.Rd,False,True,True,False,10,9,19,"---FILE: R/sjPlotGLME.R---
@@ -55,7 +55,7 @@ utils::globalVariables(c(""estimate"", ""nQQ"", ""ci"", ""fixef"", ""fade"", ""conf.low"", ""
 #'            \item If \code{NULL} (default), no sorting is done and estimates are sorted in order of model coefficients.
 #'            \item If \code{sort.est = ""sort.all""}, estimates are re-sorted for each coefficient (only applies if \code{type = ""re""} and \code{facet.grid = FALSE}), i.e. the estimates of the random effects for each predictor are sorted and plotted to an own plot.
 #'            \item If \code{type = ""fe""} or \code{type = ""fe.std""}, \code{TRUE} will sort estimates
-#'            \item Else, specify a predictor's / coefficient's name to sort estimates according to this coefficient.
+#'            \item If \code{type = ""re""}, specify a predictor's / coefficient's name to sort estimates according to this coefficient.
 #'            }
 #'            See 'Examples'.
 #' @param fade.ns if \code{TRUE}, non significant estimates will be printed in slightly faded colors.
@@ -1093,10 +1093,11 @@ sjp.lme4  <- function(fit,
       # ---------------------------------------
       reihe <- c(1:nrow(mydf))
       # ---------------------------------------
-      # just one sorting option, simply sort odds ratios
+      # just one sorting option, simply sort estimates
       # ---------------------------------------
       if (!is.null(sort.est)) {
         reihe <- order(mydf$estimate)
+        # sort data frame
         mydf <- mydf[reihe, ]
       }
       mydf$sorting <- reihe
@@ -1120,7 +1121,7 @@ sjp.lme4  <- function(fit,
     if (length(axis.labels) != nrow(mydf) &&
         (length(axis.labels) != (nrow(mydf) / length(unique(mydf$grp))))) {
       warning(""`axis.labels` has insufficient length. Using row names."", call. = F)
-      axis.labels <- row.names(mydf)
+      axis.labels <- row.names(mydf)[order(mydf$sorting)]
     }
     # ---------------------------------------
     # discrete x position, needed for ggplot

---FILE: R/sjPlotPCA.R---
@@ -189,7 +189,7 @@ sjp.pca <- function(data,
   # check if user has passed a data frame
   # or a pca object
   # ----------------------------
-  if (class(data) == ""prcomp"") {
+  if (any(class(data) == ""prcomp"")) {
     pcadata <- data
     dataframeparam <- FALSE
   } else {
@@ -434,7 +434,7 @@ sjp.pca <- function(data,
   # in order to get more clearly factor loadings
   # --------------------------------------------------------
   remdf <- NULL
-  if (class(data) == ""data.frame"") {
+  if (any(class(data) == ""data.frame"")) {
     message(""Following items have no clear factor loading:"")
     if (!is.null(removableItems)) {
       message(colnames(data)[removableItems])

---FILE: R/sjTabCorr.R---
@@ -198,7 +198,7 @@ sjt.corr <- function(data,
   # check if user has passed a data frame
   # or a pca object
   # ----------------------------
-  if (class(data) == ""matrix"") {
+  if (any(class(data) == ""matrix"")) {
     corr <- data
     cpvalues <- NULL
   } else {

---FILE: R/sjTabPCA.R---
@@ -172,7 +172,7 @@ sjt.pca <- function(data,
   # check if user has passed a data frame
   # or a pca object
   # ----------------------------
-  if (class(data) == ""prcomp"") {
+  if (any(class(data) == ""prcomp"")) {
     pcadata <- data
     dataframeparam <- FALSE
     showMSA <- FALSE

---FILE: man/sjp.glmer.Rd---
@@ -71,7 +71,7 @@ if \code{show.intercept = TRUE} and \code{axis.labels} is not \code{NULL}.}
   \item If \code{NULL} (default), no sorting is done and estimates are sorted in order of model coefficients.
   \item If \code{sort.est = ""sort.all""}, estimates are re-sorted for each coefficient (only applies if \code{type = ""re""} and \code{facet.grid = FALSE}), i.e. the estimates of the random effects for each predictor are sorted and plotted to an own plot.
   \item If \code{type = ""fe""} or \code{type = ""fe.std""}, \code{TRUE} will sort estimates
-  \item Else, specify a predictor's / coefficient's name to sort estimates according to this coefficient.
+  \item If \code{type = ""re""}, specify a predictor's / coefficient's name to sort estimates according to this coefficient.
   }
   See 'Examples'.}
 

---FILE: man/sjp.lmer.Rd---
@@ -77,7 +77,7 @@ if \code{show.intercept = TRUE} and \code{axis.labels} is not \code{NULL}.}
   \item If \code{NULL} (default), no sorting is done and estimates are sorted in order of model coefficients.
   \item If \code{sort.est = ""sort.all""}, estimates are re-sorted for each coefficient (only applies if \code{type = ""re""} and \code{facet.grid = FALSE}), i.e. the estimates of the random effects for each predictor are sorted and plotted to an own plot.
   \item If \code{type = ""fe""} or \code{type = ""fe.std""}, \code{TRUE} will sort estimates
-  \item Else, specify a predictor's / coefficient's name to sort estimates according to this coefficient.
+  \item If \code{type = ""re""}, specify a predictor's / coefficient's name to sort estimates according to this coefficient.
   }
   See 'Examples'.}
 "
strengejacke,sjPlot,c71fdbe1fb8d153a6eb4ca676f8db1cddfbd8e21,Daniel Ldecke,d.luedecke@uke.de,2016-04-25T19:35:35Z,Daniel Ldecke,d.luedecke@uke.de,2016-04-25T19:35:35Z,bugfix,R/sjPlotGroupFrequencies.R;man/sjp.frq.Rd;man/sjp.grpfrq.Rd,False,True,True,False,14,5,19,"---FILE: R/sjPlotGroupFrequencies.R---
@@ -82,6 +82,8 @@ utils::globalVariables(c(""."", ""label"", ""prz"", ""frq"", ""ypos"", ""wb"", ""ia"", ""mw"", ""
 #' @param expand.grid logical, if \code{TRUE}, the plot grid is expanded, i.e. there is a small margin between
 #'          axes and plotting region. Default is \code{FALSE}.
 #' @param show.values logical, whether values should be plotted or not.
+#' @param show.axis.values logical, whether count or percentage values for the axis
+#'          should be printed or not.
 #' @param showCountValues logical, if \code{TRUE} (default), count values are plotted to each bar. 
 #'          If \code{FALSE}, count values are removed.
 #' @param showPercentageValues logical, if \code{TRUE} (default), percentage values are plotted to each bar
@@ -218,6 +220,7 @@ sjp.grpfrq <- function(varCount,
                        show.values = TRUE,
                        showCountValues = TRUE,
                        showPercentageValues = TRUE,
+                       show.axis.values = TRUE,
                        showPlotAnnotation = TRUE,
                        showTableSummary = FALSE,
                        showGroupCount = FALSE,

---FILE: man/sjp.frq.Rd---
@@ -111,6 +111,9 @@ If \code{FALSE}, count values are removed.}
 \item{showPercentageValues}{logical, if \code{TRUE} (default), percentage values are plotted to each bar
 If \code{FALSE}, percentage values are removed.}
 
+\item{show.axis.values}{logical, whether count or percentage values for the axis
+should be printed or not.}
+
 \item{show.ci}{logical, whether or not confidence intervals should be plotted. 
 Only applies to \code{type = ""dots""} or \code{type = ""bars""}.}
 

---FILE: man/sjp.grpfrq.Rd---
@@ -14,11 +14,11 @@ sjp.grpfrq(varCount, varGroup, weight.by = NULL, weightByTitleString = NULL,
   barPosition = ""dodge"", innerBoxPlotWidth = 0.15,
   innerBoxPlotDotSize = 3, smoothLines = FALSE, expand.grid = FALSE,
   show.values = TRUE, showCountValues = TRUE, showPercentageValues = TRUE,
-  showPlotAnnotation = TRUE, showTableSummary = FALSE,
-  showGroupCount = FALSE, tableSummaryPos = ""r"", axisTitle.x = """",
-  axisTitle.y = """", autoGroupAt = NULL, coord.flip = FALSE,
-  vjust = ""bottom"", hjust = ""center"", y.offset = NULL, na.rm = TRUE,
-  printPlot = TRUE)
+  show.axis.values = TRUE, showPlotAnnotation = TRUE,
+  showTableSummary = FALSE, showGroupCount = FALSE, tableSummaryPos = ""r"",
+  axisTitle.x = """", axisTitle.y = """", autoGroupAt = NULL,
+  coord.flip = FALSE, vjust = ""bottom"", hjust = ""center"",
+  y.offset = NULL, na.rm = TRUE, printPlot = TRUE)
 }
 \arguments{
 \item{varCount}{a vector of values (variable) describing the bars which make up the plot.}
@@ -127,6 +127,9 @@ If \code{FALSE}, count values are removed.}
 \item{showPercentageValues}{logical, if \code{TRUE} (default), percentage values are plotted to each bar
 If \code{FALSE}, percentage values are removed.}
 
+\item{show.axis.values}{logical, whether count or percentage values for the axis
+should be printed or not.}
+
 \item{showPlotAnnotation}{logical, if \code{TRUE}, the groups of dots in a dot-plot are highlighted 
 with a shaded rectangle.}
 "
strengejacke,sjPlot,0584fec33dbf60eb490cc754ffd5a007ed284168,Daniel Ldecke,d.luedecke@uke.de,2016-04-24T21:22:33Z,Daniel Ldecke,d.luedecke@uke.de,2016-04-24T21:22:33Z,bug fix,R/sjPlotLinreg.R,False,True,True,False,1,1,2,"---FILE: R/sjPlotLinreg.R---
@@ -321,7 +321,7 @@ sjp.lm <- function(fit,
                                 printPlot)))
   }
   if (type == ""pred"") {
-    return(invisible(sjp.glm.predy(fit, vars, , t.title = title, l.title = legendTitle,
+    return(invisible(sjp.glm.predy(fit, vars, t.title = title, l.title = legendTitle,
                                    show.ci = showCI, geom.size, axisLimits.y = axisLimits,
                                    facet.grid, type = ""fe"", show.loess = showLoess, printPlot)))
   }"
strengejacke,sjPlot,cbefe56883726a40f07910e7776ad6c5e0ffc472,Daniel Ldecke,d.luedecke@uke.de,2016-04-20T16:52:16Z,Daniel Ldecke,d.luedecke@uke.de,2016-04-20T16:52:16Z,minor fix,NEWS.md;R/table_functions.R,False,True,True,False,2,2,4,"---FILE: NEWS.md---
@@ -9,7 +9,7 @@
 
 * Effect plots (`type = ""eff""`) for (generalized) linear (mixed) models (`sjp.lm`, `sjp.glm`, `sjp.lmer` and `sjp.glmer`) get a `vars` and `facet.grid` argument.
 * Predicted values for response (`type = ""y.pc""` or `type = ""resp""`) for `sjp.glm`, `sjp.glmer`, `sjp.lm` and `sjp.lmer` get a `vars` argument to specify x-axis and optional grouping variables. Furthermore, models from other model families and link functions now also work with this plot type.
-* Functions `sjp.lmer`, `sjp.glmer`, `sjt.lmer`, `sjt.glmer`, `sjp.lmm` and `sjp.glmm` get a `p.kr` argument, to decide whether computation of p-values should be based on Kenward-Roger approximation or not (for very large data sets, it's recommended to set this argument to `FALSE` because it is very time 
+* Functions `sjp.lmer`, `sjp.glmer`, `sjt.lmer`, `sjt.glmer`, `sjp.lmm` and `sjp.glmm` get a `p.kr` argument, to decide whether computation of p-values should be based on Kenward-Roger approximation or not (for very large data sets, it's recommended to set this argument to `FALSE` because it is very time consuming).
 
 ## Bug fixes
 

---FILE: R/table_functions.R---
@@ -241,7 +241,7 @@ table_style_worker <- function(page.content, encoding, cellSpacing, cellGroupInd
     knitr <- gsub(tag.modelcolumn6, css.modelcolumn6, knitr, fixed = TRUE, useBytes = TRUE)
     
     return(knitr)
-  } else if (option == 1) {
+  } else if (option == 3) {
     # ------------------------
     # set page style
     # ------------------------"
strengejacke,sjPlot,c83fadc014cc5abbaf95c884e9f36c0c04292346,Daniel Ldecke,d.luedecke@uke.de,2016-04-11T15:18:40Z,Daniel Ldecke,d.luedecke@uke.de,2016-04-11T15:18:40Z,fixed bug with NA values as labels for effect-plots in sjp.glm(er),R/sjPlotGLME.R;R/sjPlotLinreg.R,False,True,True,False,2,2,4,"---FILE: R/sjPlotGLME.R---
@@ -2167,7 +2167,7 @@ sjp.glm.eff <- function(fit,
                           grp = t)
       }
       # copy possible labels
-      tmp$label <- suppressWarnings(sjmisc::to_label(tmp$x, add.non.labelled = T))
+      tmp$label <- as.character(suppressWarnings(sjmisc::to_label(tmp$x, add.non.labelled = T)))
       # make sure x is numeric
       tmp$x <- sjmisc::to_value(tmp$x, keep.labels = F)
       # sort rows. we may need to do this if we have factors

---FILE: R/sjPlotLinreg.R---
@@ -280,7 +280,7 @@ sjp.lm <- function(fit,
   # -----------------------------------------------------------
   # remember length of predictor variables
   # -----------------------------------------------------------
-  predvars.length <- length(fit$coefficients)
+  predvars.length <- length(stats::coef(fit))
   # -----------------------------------------------------------
   # check argument. No model-summary supported for plm-objects
   # -----------------------------------------------------------"
strengejacke,sjPlot,a7dc0b07009cc3965b9245d3a67703bc5641a0a9,Daniel Ldecke,d.luedecke@uke.de,2016-04-01T16:59:12Z,Daniel Ldecke,d.luedecke@uke.de,2016-04-01T16:59:12Z,fix bug with argument `group.pred`,DESCRIPTION;NEWS;NEWS.md;R/helpfunctions.R;R/sjPlotGLME.R;R/sjPlotLinreg.R;R/sjTabLinReg.R;man/sjPlot-package.Rd,False,True,True,False,22,29,51,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.9.4
-Date: 2016-03-29
+Version: 1.9.4-1
+Date: 2016-04-01
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of plotting and table output functions for data

---FILE: NEWS---
@@ -1,3 +1,8 @@
+Version 1.9.4-1
+-----------------------------------------------------------------------------
+Bug fixes:
+* During code clean-up, argument `group.pred` did not work for `sjt`-functions in past update.
+
 Version 1.9.4
 -----------------------------------------------------------------------------
 General:

---FILE: NEWS.md---
@@ -1,9 +1,5 @@
-# sjPlot 1.9.4
-
-## General
-
-* Package is now depending on R >= 3.2, because some functions did not work on older R-releases.
+# sjPlot 1.9.4-1
 
 ## Bug fixes
 
-* `type = ""rs.ri""` for `sjp.lmer` and `sjp.glmer` did not work with three-level (or more) mixed models or with mixed models with more than one random part ([#121](https://github.com/sjPlot/devel/issues/121)).
+* During code clean-up, argument `group.pred` did not work for `sjt`-functions in past update.

---FILE: R/helpfunctions.R---
@@ -423,7 +423,7 @@ crosstabsum <- function(x, grp, weightBy) {
 
 # checks at which position in fitted models factors with
 # more than two levels are located.
-#' @importFrom stats model.matrix
+#' @importFrom stats model.frame
 retrieveModelGroupIndices <- function(models, rem_rows = NULL) {
   # init group-row-indices
   group.pred.rows <- c()
@@ -439,7 +439,7 @@ retrieveModelGroupIndices <- function(models, rem_rows = NULL) {
     # get model
     fit <- models[[k]]
     # copy model matrix
-    fmodel <- stats::model.matrix(fit)
+    fmodel <- stats::model.frame(fit)
     # retrieve all factors from model
     for (grp.cnt in 1:ncol(fmodel)) {
       # get variable

---FILE: R/sjPlotGLME.R---
@@ -2370,7 +2370,7 @@ get_lmerMod_pvalues <- function(fitmod) {
 }
 
 
-#' @importFrom stats family model.frame model.matrix na.omit
+#' @importFrom stats family model.frame na.omit
 sjp.glm.eff <- function(fit,
                         title,
                         geom.size,
@@ -2407,11 +2407,9 @@ sjp.glm.eff <- function(fit,
   # which title?
   if (is.null(title)) title <- ""Marginal effects of model predictors""
   # ------------------------
-  # retrieve model matrix and all terms,
-  # excluding intercept
+  # retrieve all terms excluding intercept
   # ------------------------
-  mm <- stats::model.matrix(fit)
-  all.terms <- colnames(stats::model.matrix(fit))[-1]
+  all.terms <- colnames(fitfram)[-1]
   # ------------------------
   # remove setimates?
   # ------------------------
@@ -2428,7 +2426,7 @@ sjp.glm.eff <- function(fit,
   xl <- list()
   for (t in all.terms) {
     # get unique values
-    dummy <- list(x = sort(unique(stats::na.omit(mm[, t]))))
+    dummy <- list(x = sort(unique(stats::na.omit(fitfram[, t]))))
     # name list, needed for effect-function
     names(dummy) <- t
     # create list for ""xlevels"" argument of allEffects fucntion

---FILE: R/sjPlotLinreg.R---
@@ -1282,19 +1282,15 @@ sjp.lm.poly <- function(fit,
   # -------------------------------------
   # retrieve model matrix
   # -------------------------------------
-  mm <- stats::model.matrix(fit)
+  mf <- stats::model.frame(fit)
   # get model data column names
-  cn <- colnames(mm)
+  cn <- colnames(mf)
   xl <- NULL
   # any axis title?
   if (is.null(axisTitle.y)) {
     # find response name
     resp.name <- ""Response""
-    # check if we have mixed model
-    if (sjmisc::str_contains(class(fit), ""merMod"", ignore.case = T))
-      resp.name <- get_var_name(colnames(fit@frame)[1])
-    else
-      resp.name <- get_var_name(colnames(fit$model)[1])
+    resp.name <- get_var_name(cn[1])
   } else {
     resp.name <- axisTitle.y
   }
@@ -1307,7 +1303,7 @@ sjp.lm.poly <- function(fit,
     poly.found <- any(cn == poly.term)
     # found poly? If yes, get range
     if (poly.found) {
-      xl <- list(x = sort(unique(stats::na.omit(mm[, poly.term]))))
+      xl <- list(x = sort(unique(stats::na.omit(mf[, poly.term]))))
     } else {
       # not found? than check for poly term, using poly(x, degree = 3)
       if (!poly.found) {
@@ -1423,7 +1419,7 @@ sjp.lm.eff <- function(fit,
   # retrieve model matrix and all terms,
   # excluding intercept
   # ------------------------
-  mm <- stats::model.matrix(fit)
+  mm <- stats::model.frame(fit)
   all.terms <- colnames(mm)[-1]
   # ------------------------
   # remove setimates?

---FILE: R/sjTabLinReg.R---
@@ -586,8 +586,6 @@ sjt.lm <- function(...,
     warning(""Package `AICcmodavg` needed to show AICc. Argument `showAICc` will be ignored."", call. = FALSE)
     showAICc <- FALSE
   }
-  
-  
   # ------------------------
   # check for stepwise models, when fitted models
   # are mixed effects models

---FILE: man/sjPlot-package.Rd---
@@ -34,8 +34,8 @@
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.9.4\cr
-Date: \tab 2016-03-29\cr
+Version: \tab 1.9.4-1\cr
+Date: \tab 2016-04-01\cr
 License: \tab GPL-3\cr
 }
 }"
strengejacke,sjPlot,f21b1b1ca6c484a06b9ff3c4810eba2e5ab6ca03,Daniel Ldecke,d.luedecke@uke.de,2016-03-17T22:51:02Z,Daniel Ldecke,d.luedecke@uke.de,2016-03-17T22:51:02Z,fixed bug with selecting response vector,R/sjPlotOdds.R,False,True,True,False,8,8,16,"---FILE: R/sjPlotOdds.R---
@@ -972,9 +972,9 @@ sjp.glm.ma <- function(logreg, showOriginalModelOnly=TRUE) {
   # Residual plot two
   # ------------------------------------------------------
   sjp.setTheme(""scatterw"")
-  gp <- ggplot(data.frame(x = predict(logreg), 
-                          y = residuals(logreg),
-                          grp = logreg$model$y),
+  gp <- ggplot(data.frame(x = stats::predict(logreg), 
+                          y = stats::residuals(logreg),
+                          grp = stats::model.frame(logreg)[[1]]),
                aes(x, y)) + 
     geom_point(aes(colour = grp), show.legend = F) + 
     geom_hline(yintercept = 0) +
@@ -984,9 +984,9 @@ sjp.glm.ma <- function(logreg, showOriginalModelOnly=TRUE) {
          y = ""Deviance residuals"")
   graphics::plot(gp)
   if (!showOriginalModelOnly) {
-    gp <- ggplot(data.frame(x = predict(model), 
-                            y = residuals(model),
-                            grp = model$model$y), 
+    gp <- ggplot(data.frame(x = stats::predict(model), 
+                            y = stats::residuals(model),
+                            grp = stats::model.frame(model)[[1]]), 
                  aes(x, y)) + 
       geom_point(aes(colour = grp), show.legend = F) + 
       geom_hline(yintercept = 0) +
@@ -1003,8 +1003,8 @@ sjp.glm.ma <- function(logreg, showOriginalModelOnly=TRUE) {
   for (pr in preds) {
     if (length(unique(logreg$model[[pr]])) > 4) {
       mydat <- data.frame(x = logreg$model[[pr]], 
-                          y = residuals(logreg),
-                          grp = as.factor(logreg$model$y))
+                          y = stats::residuals(logreg),
+                          grp = as.factor(stats::model.frame(logreg)[[1]]))
       gp <- ggplot(mydat, aes(x, y)) + 
         geom_point(aes(colour = grp), show.legend = F) + 
         geom_hline(yintercept = 0) +"
strengejacke,sjPlot,2aa8c1ca419efc6f5b4616febe9860d829f9caee,Daniel Ldecke,d.luedecke@uke.de,2016-03-17T20:43:56Z,Daniel Ldecke,d.luedecke@uke.de,2016-03-17T20:43:56Z,fixed bug in sjt.xtab,NEWS;NEWS.md;R/sjTabPropTable.R,False,True,True,False,7,3,10,"---FILE: NEWS---
@@ -7,11 +7,13 @@ Changes to functions:
 * Better support for different model families in `sjp.glm` and `sjp.glmer`.
 * `sjt.lm`, `sjt.lmer`, `sjt.glm` and `sjt.glmer` get a `showDeviance` argument to display model's deviance in the table summary.
 * `sjt.lmer` and `sjt.glmer` now show R2-values (based on sjmisc::r2 function).
+* `sjt.df` gets a `...` argument to pass down other arguments to `psych::describe`.
 * Plot-type of `sjp.int` now defaults to `type = ""eff""`.
 * Minor improvements to `sjp.int` according to plot labels (legend, axis).
 
 Bug fixes:
 * `sjt.xtab` did not apply `highlightTotal` to total column.
+* `sjt.xtab` showed wrong total percentages for row and column percentages.
 
 
 Version 1.9.2

---FILE: NEWS.md---
@@ -9,9 +9,11 @@
 * Better support for different model families in `sjp.glm` and `sjp.glmer`.
 * `sjt.lm`, `sjt.lmer`, `sjt.glm` and `sjt.glmer` get a `showDeviance` argument to display model's deviance in the table summary.
 * `sjt.lmer` and `sjt.glmer` now show R2-values (based on `sjmisc::r2` function).
+* `sjt.df` gets a `...` argument to pass down other arguments to `psych::describe` ([#118](https://github.com/sjPlot/devel/issues/118)).
 * Plot-type of `sjp.int` now defaults to `type = ""eff""`.
 * Minor improvements to `sjp.int` according to plot labels (legend, axis).
 
 ## Bug fixes
 
-* `sjt.xtab` did not apply `highlightTotal` to total column ([#111](https://github.com/sjPlot/devel/issues/111)).
\ No newline at end of file
+* `sjt.xtab` did not apply `highlightTotal` to total column ([#111](https://github.com/sjPlot/devel/issues/111)).
+* `sjt.xtab` showed wrong total percentages for row and column percentages.

---FILE: R/sjTabPropTable.R---
@@ -222,9 +222,9 @@ sjt.xtab <- function(var.row,
   tab <- rbind(tab, unname(colSums(tab)))
   tab.cell <- mydat$proptab.cell
   tab.row <- mydat$proptab.row
-  tab.row$total <- tab.cell$total
+  tab.row$total <- 100
   tab.col <- mydat$proptab.col
-  tab.col <- rbind(tab.col, tab.cell[nrow(tab.cell), ])
+  tab.col <- rbind(tab.col, rep(100, times = ncol(tab.col)))
   tab.expected <- sjmisc::table_values(stats::ftable(as.matrix(tab)))$expected
   # -------------------------------------
   # determine total number of columns and rows"
strengejacke,sjPlot,5e8a8276ae8b18caadb08a8b2f213ade5c6dda6b,Daniel Ldecke,d.luedecke@uke.de,2016-03-17T20:13:35Z,Daniel Ldecke,d.luedecke@uke.de,2016-03-17T20:13:35Z,fixed bug with p-value computation in sjt.lm,R/sjPlotGLME.R;R/sjPlotLinreg.R;R/sjTabDataFrame.R;man/sjt.df.Rd,False,True,True,False,23,14,37,"---FILE: R/sjPlotGLME.R---
@@ -2297,19 +2297,19 @@ get_lmerMod_pvalues <- function(fitmod) {
     if (length(pvcn) == 0) pvcn <- 4
     pv <- cs[, pvcn]
   } else if (any(class(fitmod) == ""lmerMod"") && requireNamespace(""pbkrtest"", quietly = TRUE)) {
-    # compute Kenward-Roger-DF for p-statistic. Code snippet taken from
+    # compute Kenward-Roger-DF for p-statistic. Code snippet adapted from
     # http://mindingthebrain.blogspot.de/2014/02/three-ways-to-get-parameter-specific-p.html
     message(""Computing p-values via Kenward-Roger approximation..."")
     #first coefficients need to be data frame
     cs <- as.data.frame(cs)
     # get KR DF
-    df.kr <- pbkrtest::get_ddf_Lb(fitmod, lme4::fixef(fitmod))
+    df.kr <- pbkrtest::get_Lb_ddf(fitmod, lme4::fixef(fitmod))
     # compute p-values, assuming an approximate t-dist
     pv <- 2 * (1 - pt(abs(cs$`t value`), df.kr))
   } else {
     # if we don't have p-values in summary, try to get them via anova
     # we use type 3 here to include intercept
-    message(""Computing approximate p-values via Wald chi-square test..."")
+    message(""Computing approximate p-values via Wald chi-squared test..."")
     pia <- suppressMessages(car::Anova(fitmod, type = ""III""))
     # factors may have multiple levels, however, p-value
     # is not calculated for each factor level. Drop these p-values.

---FILE: R/sjPlotLinreg.R---
@@ -380,7 +380,7 @@ sjp.lm <- function(fit,
   # print beta- and p-values in bar charts
   # ----------------------------
   # retrieve sigificance level of independent variables (p-values)
-  pv <- get_lm_pvalues(fit)$p
+  pv <- get_lm_pvalues(fit, include.intercept = F)$p
   # -------------------------------------------------
   # for better readability, convert p-values to asterisks
   # with:
@@ -1524,17 +1524,22 @@ sjp.lm.eff <- function(fit,
 }
 
 
-get_lm_pvalues <- function(fit) {
+get_lm_pvalues <- function(fit, include.intercept = TRUE) {
   # retrieve sigificance level of independent variables (p-values)
   if (any(class(fit) == ""pggls"")) {
-    p <- summary(fit)$CoefTable[-1, 4]
-    se <- summary(fit)$CoefTable[-1, 2]
+    p <- summary(fit)$CoefTable[, 4]
+    se <- summary(fit)$CoefTable[, 2]
   } else if (any(class(fit) == ""gls"")) {
-    p <- summary(fit)$tTable[-1, 4]
-    se <- summary(fit)$tTable[-1, 2]
+    p <- summary(fit)$tTable[, 4]
+    se <- summary(fit)$tTable[, 2]
   } else {
-    p <- stats::coef(summary(fit))[-1, 4]
-    se <- stats::coef(summary(fit))[-1, 2]
+    p <- stats::coef(summary(fit))[, 4]
+    se <- stats::coef(summary(fit))[, 2]
+  }
+  # remove intercept?
+  if (!include.intercept) {
+    p <- p[-1]
+    se <- se[-1]
   }
   return(list(p = p, se = se))
 }
\ No newline at end of file

---FILE: R/sjTabDataFrame.R---
@@ -42,6 +42,7 @@
 #'          thousands decimals before (hence big) the decimal point
 #' @param hideProgressBar logical, if \code{TRUE}, the progress bar that is displayed when creating the
 #'          table is hidden. Default in \code{FALSE}, hence the bar is visible.
+#' @param ... other arguments passed down to the \code{\link[psych]{describe}} function.
 #'          
 #' @inheritParams sjt.frq
 #'          
@@ -127,7 +128,8 @@ sjt.df <- function(mydf,
                    CSS = NULL,
                    useViewer = TRUE,
                    no.output = FALSE,
-                   remove.spaces = TRUE) {
+                   remove.spaces = TRUE,
+                   ...) {
   # check encoding
   encoding <- get.encoding(encoding, mydf)
   # -------------------------------------
@@ -145,7 +147,7 @@ sjt.df <- function(mydf,
     missings <- apply(mydf, 2, function(x) sum(is.na(x)))
     # and proportion of missings
     missings.percentage <- round(100 * missings / nrow(mydf), 2)
-    mydf <- round(psych::describe(mydf), 2)
+    mydf <- round(psych::describe(mydf, ...), 2)
     # insert missing variables in data frame
     mydf <- data.frame(mydf[, 1:2], 
                        missings, 

---FILE: man/sjt.df.Rd---
@@ -10,7 +10,7 @@ sjt.df(mydf, describe = TRUE, file = NULL, alternateRowColors = FALSE,
   showRowNames = TRUE, showCommentRow = FALSE,
   commentString = ""No comment..."", big.mark = NULL,
   hideProgressBar = FALSE, encoding = NULL, CSS = NULL,
-  useViewer = TRUE, no.output = FALSE, remove.spaces = TRUE)
+  useViewer = TRUE, no.output = FALSE, remove.spaces = TRUE, ...)
 }
 \arguments{
 \item{mydf}{data frame that should be printed as table}
@@ -80,6 +80,8 @@ value.}
 \item{remove.spaces}{logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
 that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
 may look less pretty, but it may help when exporting html-tables to office tools.}
+
+\item{...}{other arguments passed down to the \code{\link[psych]{describe}} function.}
 }
 \value{
 Invisibly returns"
strengejacke,sjPlot,f1b1cb8d13ea06bc2779c893e35b75d8d4651a5d,Daniel Ldecke,d.luedecke@uke.de,2016-03-15T22:24:18Z,Daniel Ldecke,d.luedecke@uke.de,2016-03-15T22:24:18Z,fixed bug with labelling in sjp.int,R/sjPlotInteractions.R,False,True,True,False,1,1,2,"---FILE: R/sjPlotInteractions.R---
@@ -1285,7 +1285,7 @@ sjp.eff.int <- function(fit,
     # prepare facet-labels
     # -----------------------------------------------------------
     if (length(unique(intdf$grp)) == length(lLabels) && isTRUE(facet.grid)) {
-      intdf$grp <- lLabels
+      levels(intdf$grp) <- lLabels
     }
     # -----------------------------------------------------------
     # legend titles"
strengejacke,sjPlot,a6ab87f7bbd006c6d51ec8c127642a99a65b1ce4,Daniel Ldecke,d.luedecke@uke.de,2016-03-15T21:16:53Z,Daniel Ldecke,d.luedecke@uke.de,2016-03-15T21:16:53Z,"fixed bug with non-numeric factors and label order in sjp.int, type = ""eff""",DESCRIPTION;NEWS;NEWS.md;R/sjPlotInteractions.R;man/sjPlot-package.Rd;man/sjp.int.Rd,False,True,True,False,40,32,72,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.9.2-2
-Date: 2016-03-08
+Version: 1.9.2-3
+Date: 2016-03-15
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of plotting and table output functions for data

---FILE: NEWS---
@@ -1,4 +1,4 @@
-Version 1.9.2-2
+Version 1.9.2-3
 -----------------------------------------------------------------------------
 General:
 * P-values for linear mixed models are now computed using conditional F tests with Kenward-Roger approximation for the df from the _pbkrtest_ package, if available.
@@ -7,7 +7,8 @@ Changes to functions:
 * Better support for different model families in `sjp.glm` and `sjp.glmer`.
 * `sjt.lm`, `sjt.lmer`, `sjt.glm` and `sjt.glmer` get a `showDeviance` argument to display model's deviance in the table summary.
 * `sjt.lmer` and `sjt.glmer` now show R2-values (based on sjmisc::r2 function).
-* Minor improvments to `sjp.int` according to plot labels (legend, axis).
+* Plot-type of `sjp.int` now defaults to `type = ""eff""`.
+* Minor improvements to `sjp.int` according to plot labels (legend, axis).
 
 Bug fixes:
 * `sjt.xtab` did not apply `highlightTotal` to total column.

---FILE: NEWS.md---
@@ -1,4 +1,4 @@
-# sjPlot 1.9.2-2
+# sjPlot 1.9.2-3
 
 ## General
 
@@ -9,7 +9,8 @@
 * Better support for different model families in `sjp.glm` and `sjp.glmer`.
 * `sjt.lm`, `sjt.lmer`, `sjt.glm` and `sjt.glmer` get a `showDeviance` argument to display model's deviance in the table summary.
 * `sjt.lmer` and `sjt.glmer` now show R2-values (based on `sjmisc::r2` function).
-* Minor improvments to `sjp.int` according to plot labels (legend, axis).
+* Plot-type of `sjp.int` now defaults to `type = ""eff""`.
+* Minor improvements to `sjp.int` according to plot labels (legend, axis).
 
 ## Bug fixes
 

---FILE: R/sjPlotInteractions.R---
@@ -46,8 +46,8 @@
 #'          }
 #' @param type interaction plot type. Use one of following values:
 #'          \describe{
-#'            \item{\code{type = ""cond""}}{(default) plots the mere \emph{change} of the moderating effect on the response value (conditional effect). See 'Details'.}
-#'            \item{\code{type = ""eff""}}{plots the overall moderation effect on the response value. See 'Details'.}
+#'            \item{\code{type = ""eff""}}{(default) plots the overall moderation effect on the response value. See 'Details'.}
+#'            \item{\code{type = ""cond""}}{plots the mere \emph{change} of the moderating effect on the response value (conditional effect). See 'Details'.}
 #'            \item{\code{type = ""emm""}}{plots the estimated marginal means (least square means). If this type is chosen, not all function arguments are applicable. See 'Details'.}
 #'          }
 #' @param int.term select interaction term of \code{fit} (as character), which should be plotted
@@ -67,7 +67,7 @@
 #'            \item{\code{""meansd""}}{uses the mean value of the moderator as well as one standard deviation below and above mean value to plot the effect of the moderator on the independent variable (following the convention suggested by Cohen and Cohen and popularized by Aiken and West, i.e. using the mean, the value one standard deviation above, and the value one standard deviation below the mean as values of the moderator, see \href{http://www.theanalysisfactor.com/3-tips-interpreting-moderation/}{Grace-Martin K: 3 Tips to Make Interpreting Moderation Effects Easier}).}
 #'            \item{\code{""zeromax""}}{is similar to the \code{""minmax""} option, however, \code{0} is always used as minimum value for the moderator. This may be useful for predictors that don't have an empirical zero-value, but absence of moderation should be simulated by using 0 as minimum.}
 #'            \item{\code{""quart""}}{calculates and uses the quartiles (lower, median and upper) of the moderator value.}
-#'            \item{\code{""all""}}{uses all values of the moderator variable. Note that this option only applies to \code{type = ""eff""}.}
+#'            \item{\code{""all""}}{uses all values of the moderator variable. Note that this option only applies to \code{type = ""eff""}, for numeric moderator values.}
 #'          }
 #' @param swapPredictors if \code{TRUE}, the predictor on the x-axis and the moderator value in an interaction are
 #'          swapped. For \code{type = ""eff""}, the first interaction term is used as moderator and the second term
@@ -122,6 +122,11 @@
 #'           as well as the data frames that were used for setting up the ggplot-objects (\code{data.list}).
 #'
 #' @details \describe{
+#'            \item{\code{type = ""eff""}}{plots the overall effects (marginal effects) of the interaction, with all remaining
+#'              covariates set to the mean. Effects are calculated using the \code{\link[effects]{effect}}-
+#'              function from the \pkg{effects}-package. \cr \cr
+#'              Following arguments \emph{do not} apply to this function: \code{diff}, \code{axisLabels.x}.
+#'            }
 #'            \item{\code{type = ""cond""}}{plots the effective \emph{change} or \emph{impact} 
 #'              (conditional effect) on a dependent variable of a moderation effect, as 
 #'              described in \href{http://www.theanalysisfactor.com/clarifications-on-interpreting-interactions-in-regression/}{Grace-Martin},
@@ -135,11 +140,6 @@
 #'              \code{type = ""eff""} for effect displays similar to the \code{\link[effects]{effect}}-function 
 #'              from the \pkg{effects}-package.
 #'            }
-#'            \item{\code{type = ""eff""}}{plots the overall effects (marginal effects) of the interaction, with all remaining
-#'              covariates set to the mean. Effects are calculated using the \code{\link[effects]{effect}}-
-#'              function from the \pkg{effects}-package. \cr \cr
-#'              Following arguments \emph{do not} apply to this function: \code{diff}, \code{axisLabels.x}.
-#'            }
 #'            \item{\code{type = ""emm""}}{plots the estimated marginal means of repeated measures designs,
 #'              like two-way repeated measures AN(C)OVA. In detail, this type plots estimated marginal means 
 #'              (also called \emph{least square means} or \emph{marginal means}) of (significant) interaction terms.
@@ -304,7 +304,7 @@
 #' @importFrom effects allEffects effect
 #' @export
 sjp.int <- function(fit,
-                    type = ""cond"",
+                    type = ""eff"",
                     int.term = NULL,
                     int.plot.index = NULL,
                     diff = FALSE,
@@ -1123,7 +1123,7 @@ sjp.eff.int <- function(fit,
     # -----------------------------------------------------------
     intdf <- droplevels(intdf)
     # group as factor
-    intdf$grp <- as.factor(intdf$grp)
+    intdf$grp <- factor(intdf$grp, levels = unique(as.character(intdf$grp)))
     x_labels <- NULL
     # does model have labels? we want these if x is a factor.
     # first we need to know whether we have a model-data-frame
@@ -1256,7 +1256,7 @@ sjp.eff.int <- function(fit,
       # try to get labels
       lLabels <- sjmisc::get_labels(stats::model.frame(fit)[[moderator.name]], attr.only = F)
       # if we still have no labels, get values from group
-      if (is.null(lLabels)) lLabels <- as.character(unique(intdf$grp))
+      if (is.null(lLabels)) lLabels <- unique(as.character(intdf$grp))
     } else {
       # copy plot counter 
       l_nr <- i
@@ -1266,6 +1266,12 @@ sjp.eff.int <- function(fit,
       lLabels <- legendLabels[[l_nr]]
     }
     # -----------------------------------------------------------
+    # prepare facet-labels
+    # -----------------------------------------------------------
+    if (length(unique(intdf$grp)) == length(lLabels) && isTRUE(facet.grid)) {
+      intdf$grp <- lLabels
+    }
+    # -----------------------------------------------------------
     # legend titles
     # -----------------------------------------------------------
     if (is.null(legendTitle)) {
@@ -1371,8 +1377,8 @@ sjp.eff.int <- function(fit,
     # ---------------------------------------------------------
     baseplot <- sj.setGeomColors(baseplot, 
                                  geom.colors, 
-                                 length(unique(stats::na.omit(intdf$grp))), 
-                                 !is.null(lLabels), 
+                                 pal.len = length(unique(stats::na.omit(intdf$grp))), 
+                                 show.legend = !is.null(lLabels) & !isTRUE(facet.grid), 
                                  lLabels)
     # ---------------------------------------------------------
     # Check whether ggplot object should be returned or plotted

---FILE: man/sjPlot-package.Rd---
@@ -34,8 +34,8 @@
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.9.2-2\cr
-Date: \tab 2016-03-08\cr
+Version: \tab 1.9.2-3\cr
+Date: \tab 2016-03-15\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjp.int.Rd---
@@ -4,7 +4,7 @@
 \alias{sjp.int}
 \title{Plot interaction effects of (generalized) linear (mixed) models}
 \usage{
-sjp.int(fit, type = ""cond"", int.term = NULL, int.plot.index = NULL,
+sjp.int(fit, type = ""eff"", int.term = NULL, int.plot.index = NULL,
   diff = FALSE, moderatorValues = ""minmax"", swapPredictors = FALSE,
   plevel = 0.05, title = NULL, fillColor = ""grey"", fillAlpha = 0.3,
   geom.colors = ""Set1"", geom.size = NULL, axisTitle.x = NULL,
@@ -26,13 +26,13 @@ classes are
   \item non-linear mixed effects models (\code{\link[lme4]{nlmer}})
   \item linear mixed effects models (\code{\link[nlme]{lme}}, but only for \code{type = ""eff""})
   \item generalized least squares models (\code{\link[nlme]{gls}}, but only for \code{type = ""eff""})
-  \item panel data estimators (\code{plm})
+  \item panel data estimators (\code{\link[plm]{plm}})
 }}
 
 \item{type}{interaction plot type. Use one of following values:
 \describe{
-  \item{\code{type = ""cond""}}{(default) plots the mere \emph{change} of the moderating effect on the response value (conditional effect). See 'Details'.}
-  \item{\code{type = ""eff""}}{plots the overall moderation effect on the response value. See 'Details'.}
+  \item{\code{type = ""eff""}}{(default) plots the overall moderation effect on the response value. See 'Details'.}
+  \item{\code{type = ""cond""}}{plots the mere \emph{change} of the moderating effect on the response value (conditional effect). See 'Details'.}
   \item{\code{type = ""emm""}}{plots the estimated marginal means (least square means). If this type is chosen, not all function arguments are applicable. See 'Details'.}
 }}
 
@@ -56,7 +56,7 @@ independent variable on the dependent variable.
   \item{\code{""meansd""}}{uses the mean value of the moderator as well as one standard deviation below and above mean value to plot the effect of the moderator on the independent variable (following the convention suggested by Cohen and Cohen and popularized by Aiken and West, i.e. using the mean, the value one standard deviation above, and the value one standard deviation below the mean as values of the moderator, see \href{http://www.theanalysisfactor.com/3-tips-interpreting-moderation/}{Grace-Martin K: 3 Tips to Make Interpreting Moderation Effects Easier}).}
   \item{\code{""zeromax""}}{is similar to the \code{""minmax""} option, however, \code{0} is always used as minimum value for the moderator. This may be useful for predictors that don't have an empirical zero-value, but absence of moderation should be simulated by using 0 as minimum.}
   \item{\code{""quart""}}{calculates and uses the quartiles (lower, median and upper) of the moderator value.}
-  \item{\code{""all""}}{uses all values of the moderator variable. Note that this option only applies to \code{type = ""eff""}.}
+  \item{\code{""all""}}{uses all values of the moderator variable. Note that this option only applies to \code{type = ""eff""}, for numeric moderator values.}
 }}
 
 \item{swapPredictors}{if \code{TRUE}, the predictor on the x-axis and the moderator value in an interaction are
@@ -164,14 +164,19 @@ Plot regression (predicted values) or probability lines (predicted probabilities
                  \item non-linear mixed effects models (\code{\link[lme4]{nlmer}})
                  \item linear mixed effects models (\code{\link[nlme]{lme}}, but only for \code{type = ""eff""})
                  \item generalized least squares models (\code{\link[nlme]{gls}}, but only for \code{type = ""eff""})
-                 \item panel data estimators (\code{plm})
+                 \item panel data estimators (\code{\link[plm]{plm}})
                }
                Note that beside interaction terms, also the single predictors of each interaction (main effects)
                must be included in the fitted model as well. Thus, \code{lm(dep ~ pred1 * pred2)} will work, 
                but \code{lm(dep ~ pred1:pred2)} won't!
 }
 \details{
 \describe{
+           \item{\code{type = ""eff""}}{plots the overall effects (marginal effects) of the interaction, with all remaining
+             covariates set to the mean. Effects are calculated using the \code{\link[effects]{effect}}-
+             function from the \pkg{effects}-package. \cr \cr
+             Following arguments \emph{do not} apply to this function: \code{diff}, \code{axisLabels.x}.
+           }
            \item{\code{type = ""cond""}}{plots the effective \emph{change} or \emph{impact} 
              (conditional effect) on a dependent variable of a moderation effect, as 
              described in \href{http://www.theanalysisfactor.com/clarifications-on-interpreting-interactions-in-regression/}{Grace-Martin},
@@ -185,11 +190,6 @@ Plot regression (predicted values) or probability lines (predicted probabilities
              \code{type = ""eff""} for effect displays similar to the \code{\link[effects]{effect}}-function 
              from the \pkg{effects}-package.
            }
-           \item{\code{type = ""eff""}}{plots the overall effects (marginal effects) of the interaction, with all remaining
-             covariates set to the mean. Effects are calculated using the \code{\link[effects]{effect}}-
-             function from the \pkg{effects}-package. \cr \cr
-             Following arguments \emph{do not} apply to this function: \code{diff}, \code{axisLabels.x}.
-           }
            \item{\code{type = ""emm""}}{plots the estimated marginal means of repeated measures designs,
              like two-way repeated measures AN(C)OVA. In detail, this type plots estimated marginal means 
              (also called \emph{least square means} or \emph{marginal means}) of (significant) interaction terms."
strengejacke,sjPlot,4a9c027639c4caa3b2516727285afb9c887f5e6f,Daniel Ldecke,d.luedecke@uke.de,2016-03-15T19:53:38Z,Daniel Ldecke,d.luedecke@uke.de,2016-03-15T19:53:38Z,bug fix,R/sjPlotInteractions.R,False,True,True,False,3,1,4,"---FILE: R/sjPlotInteractions.R---
@@ -1143,7 +1143,9 @@ sjp.eff.int <- function(fit,
     # -----------------------------------------------------------
     if (fun == ""lm"" || fun == ""lmer"" || fun == ""lme"" || fun == ""gls"") {
       # Label on y-axis is name of dependent variable
-      laby <- sjmisc::get_label(stats::model.frame(fit)[[response.name]], def.value = response.name)
+      if (is.null(axisTitle.y)) 
+        axisTitle.y <- sjmisc::get_label(stats::model.frame(fit)[[response.name]], 
+                                         def.value = response.name)
       # -----------------------------------------------------------
       # retrieve lowest and highest x and y position to determine
       # the scale limits"
strengejacke,sjPlot,563d8f37132995a63e1a2e41cd7fc5044984ef46,dinRdo,mdinardo@1BQHF12.ceb.com,2016-03-02T21:58:07Z,dinRdo,mdinardo@1BQHF12.ceb.com,2016-03-02T21:58:07Z,Fix #111,R/sjTabPropTable.R,False,True,True,False,6,2,8,"---FILE: R/sjTabPropTable.R---
@@ -324,7 +324,7 @@ sjt.xtab <- function(var.row,
   # -------------------------------------
   # total-column
   # -------------------------------------
-  page.content <- paste(page.content, sprintf(""    <th class=\""thead tothi firstcolborder\"" rowspan=\""2\"">%s</th>\n"", stringTotal))
+  page.content <- paste(page.content, sprintf(""    <th class=\""thead tothi firstcolborder totcol\"" rowspan=\""2\"">%s</th>\n"", stringTotal))
   page.content <- paste(page.content, ""  </tr>\n"")
   # -------------------------------------
   # init second table row
@@ -401,10 +401,14 @@ sjt.xtab <- function(var.row,
         cellstring <- paste(cellstring, sprintf(""<span class=\""td_c\"">%s%s</span>"", tab.cell[irow, icol], percSign), sep = """")
       }
       # -------------------------------------
+      # set column variable label
+      # -------------------------------------
+      css_tot_col <- ifelse(icol == totalncol, "" totcol"", """")
+      # -------------------------------------
       # write table cell data
       # -------------------------------------
       page.content <- paste(page.content, sprintf(""\n    <td class=\""tdata centeralign horline%s\"">%s</td>"", 
-                                                  css_last_row,
+                                                  ifelse(css_last_row == """", css_tot_col, css_last_row),
                                                   cellstring), sep = """")
     }
     # close table row"
strengejacke,sjPlot,788abe339716259f77ac1b012d343a50d2ac9731,Daniel Ldecke,d.luedecke@uke.de,2016-03-01T18:40:44Z,Daniel Ldecke,d.luedecke@uke.de,2016-03-01T18:40:44Z,minor fixes,NEWS;NEWS.md;R/sjPlotGLME.R;R/sjPlotStackFrequencies.R,False,True,True,False,7,3,10,"---FILE: NEWS---
@@ -17,6 +17,7 @@ Bug fixes:
 * Fixed bug in `sjp.likert` that plotted categories in wrong order when neutral category was lower than amount of categories.
 * Fixed bug in `sjp.grpfrq` with argument `autoGroupAt`.
 * Fixed minor bugs in `sjp.lm` with axis range for forest plots.
+* Fixed bug in `sjp.stackfrq`, where the use of argument `showSeparatorLine` caused an error.
 
 
 Version 1.9.1

---FILE: NEWS.md---
@@ -19,4 +19,5 @@
 * Fixed bug with position of value labels in `sjp.xtab` ([#107](https://github.com/sjPlot/devel/issues/107)).
 * Fixed bug in `sjp.likert` that plotted categories in wrong order when neutral category was lower than amount of categories ([#109](https://github.com/sjPlot/devel/issues/109)).
 * Fixed bug in `sjp.grpfrq` with argument `autoGroupAt`.
-* Fixed minor bugs in `sjp.lm` with axis range for forest plots.
\ No newline at end of file
+* Fixed minor bugs in `sjp.lm` with axis range for forest plots.
+* Fixed bug in `sjp.stackfrq`, where the use of argument `showSeparatorLine` caused an error.

---FILE: R/sjPlotGLME.R---
@@ -2261,9 +2261,10 @@ sjp.lme.fecondpred.onlynumeric <- function(fit,
 
 
 #' @importFrom stats coef
+#' @importFrom car Anova
 get_lmerMod_pvalues <- function(fitmod) {
   # retrieve sigificance level of independent variables (p-values)
-  if (any(class(fitmod) == ""merModLmerTest"")) {
+  if (any(class(fitmod) == ""merModLmerTest"") && requireNamespace(""lmerTest"", quietly = TRUE)) {
     cs <- suppressWarnings(stats::coef(lmerTest::summary(fitmod)))
   } else {
     cs <- stats::coef(summary(fitmod))
@@ -2467,6 +2468,7 @@ sjp.glmer.ma <- function(fit) {
 }
 
 
+#' @importFrom lme4 fixef confint.merMod 
 get_cleaned_ciMerMod <- function(fit, fun, ci.only = FALSE) {
   # get odds ratios of fixed effects
   estimate <- lme4::fixef(fit)

---FILE: R/sjPlotStackFrequencies.R---
@@ -414,7 +414,7 @@ sjp.stackfrq <- function(items,
   # --------------------------------------------------------
   if (showSeparatorLine) {
     baseplot <- baseplot +
-      geom_vline(x = c(seq(1.5, length(items), by = 1)), 
+      geom_vline(xintercept = c(seq(1.5, length(items), by = 1)), 
                  size = separatorLineSize, 
                  colour = separatorLineColor)
   }"
strengejacke,sjPlot,2579520e3d7c56fc059853d9e97e24d1bf50348a,Daniel Ldecke,d.luedecke@uke.de,2016-02-29T20:47:09Z,Daniel Ldecke,d.luedecke@uke.de,2016-02-29T20:47:09Z,bug fixes,NEWS;NEWS.md;R/sjPlotGroupFrequencies.R;R/sjPlotLinreg.R;R/sjPlotOdds.R,False,True,True,False,45,29,74,"---FILE: NEWS---
@@ -14,6 +14,8 @@ Bug fixes:
 * `sjt.xtab` ignored value labels when weighting data.
 * Fixed bug with position of value labels in `sjp.xtab`.
 * Fixed bug in `sjp.likert` that plotted categories in wrong order when neutral category was lower than amount of categories.
+* Fixed bug in `sjp.grpfrq` with argument `autoGroupAt`.
+
 
 Version 1.9.1
 -----------------------------------------------------------------------------

---FILE: NEWS.md---
@@ -16,4 +16,5 @@
 * Fixed bug in `sjp.lmer` and `sjp.glmer` with doubled y-axis for faceted random effect plots.
 * `sjt.xtab` ignored value labels when weighting data ([#106](https://github.com/sjPlot/devel/issues/106)).
 * Fixed bug with position of value labels in `sjp.xtab` ([#107](https://github.com/sjPlot/devel/issues/107)).
-* Fixed bug in `sjp.likert` that plotted categories in wrong order when neutral category was lower than amount of categories ([#109](https://github.com/sjPlot/devel/issues/109)).
\ No newline at end of file
+* Fixed bug in `sjp.likert` that plotted categories in wrong order when neutral category was lower than amount of categories ([#109](https://github.com/sjPlot/devel/issues/109)).
+* Fixed bug in `sjp.grpfrq` with argument `autoGroupAt`.
\ No newline at end of file

---FILE: R/sjPlotGroupFrequencies.R---
@@ -316,10 +316,33 @@ sjp.grpfrq <- function(varCount,
   #---------------------------------------------------
   if (missing(title) && (type == ""boxplots"" || type == ""violin""))
     title <- NULL
+  #---------------------------------------------------
+  # check whether variable should be auto-grouped
+  #---------------------------------------------------
+  if (!is.null(autoGroupAt) && length(unique(varCount)) >= autoGroupAt) {
+    message(sprintf(""%s has %i unique values and was grouped..."",
+                    var.name.cnt,
+                    length(unique(varCount))))
+    # check for default auto-group-size or user-defined groups
+    agcnt <- ifelse(autoGroupAt < 30, autoGroupAt, 30)
+    # group axis labels
+    axisLabels.x <- sjmisc::group_labels(sjmisc::to_value(varCount, keep.labels = F),
+                                         groupsize = ""auto"",
+                                         groupcount = agcnt)
+    # group variable
+    grp.varCount <- sjmisc::group_var(sjmisc::to_value(varCount, keep.labels = F),
+                                      groupsize = ""auto"",
+                                      as.num = TRUE,
+                                      groupcount = agcnt)
+    # set value labels
+    sjmisc::set_labels(grp.varCount) <- axisLabels.x
+  } else {
+    grp.varCount <- varCount
+  }
   # --------------------------------------------------------
   # create cross table of frequencies and percentages
   # --------------------------------------------------------
-  mydat <- create.xtab.df(varCount,
+  mydat <- create.xtab.df(grp.varCount,
                           varGroup,
                           round.prz = 2,
                           na.rm = na.rm,
@@ -375,24 +398,6 @@ sjp.grpfrq <- function(varCount,
     varGroup <- sjmisc::to_value(varGroup, keep.labels = F)
   else
     varGroup <- as.numeric(varGroup)
-  #---------------------------------------------------
-  # check whether variable should be auto-grouped
-  #---------------------------------------------------
-  if (!is.null(autoGroupAt) && length(unique(varCount)) >= autoGroupAt) {
-    message(sprintf(""Variable has %i unique values and was grouped..."",
-                    length(unique(varCount))))
-    # check for default auto-group-size or user-defined groups
-    agcnt <- ifelse(autoGroupAt < 30, autoGroupAt, 30)
-    # group axis labels
-    axisLabels.x <- sjmisc::group_labels(varCount,
-                                         groupsize = ""auto"",
-                                         groupcount = agcnt)
-    # group variable
-    varCount <- sjmisc::group_var(varCount,
-                                  groupsize = ""auto"",
-                                  as.num = TRUE,
-                                  groupcount = agcnt)
-  }
   # --------------------------------------------------------
   # Define amount of categories
   # --------------------------------------------------------
@@ -590,14 +595,19 @@ sjp.grpfrq <- function(varCount,
       # else calculate upper y-axis-range depending
       # on the amount of cases...
     } else if (barPosition == ""stack"") {
-      upper_lim <- max(pretty(table(varCount) * 1.05))
+      upper_lim <- max(pretty(table(grp.varCount) * 1.05))
     } else {
       # ... or the amount of max. answers per category
-      upper_lim <- max(pretty(table(varCount, varGroup) * 1.05))
+      upper_lim <- max(pretty(table(grp.varCount, varGroup) * 1.05))
     }
   }
   # align dodged position of labels to bar positions
-  posdodge <- ifelse(type == ""lines"", 0, geom.size + geom.spacing)
+  if (type == ""lines"")
+    posdodge <- 0
+  else if (type == ""dots"")
+    posdodge <- geom.spacing
+  else
+    posdodge <- geom.size + geom.spacing
   # init shaded rectangles for plot
   ganno <- NULL
   # check whether we have dots or bars

---FILE: R/sjPlotLinreg.R---
@@ -454,7 +454,7 @@ sjp.lm <- function(fit,
     if (!is.null(axisLabels.y) && length(axisLabels.y) > nrow(tmp))
       axisLabels.y <- axisLabels.y[-remrows]
     # remove p-values
-    pv <- pv[remrows]
+    pv <- pv[-remrows]
   }
   # -------------------------------------------------
   # init data column for p-values
@@ -509,6 +509,7 @@ sjp.lm <- function(fit,
   # give columns names
   colnames(betas) <- c(""xv"", ""Beta"", ""lower"", ""upper"", ""p"", ""pv"", ""grp.est"")
   betas$p <- as.character(betas$p)
+  betas$xv <- as.factor(betas$xv)
   # --------------------------------------------------------
   # Calculate axis limits. The range is from lowest lower-CI
   # to highest upper-CI, or a user-defined range (if ""axisLimits""
@@ -533,11 +534,11 @@ sjp.lm <- function(fit,
   # (whether grouped or not)
   # --------------------------------------------------------
   if (!is.null(group.estimates)) {
-    betaplot <- ggplot(betas, aes(y = Beta, x = xv, colour = grp.est))
+    betaplot <- ggplot(betas, aes(x = xv, y = Beta, colour = grp.est))
     pal.len <- length(unique(group.estimates))
     legend.labels <- unique(betas$grp.est)
   } else {
-    betaplot <- ggplot(betas, aes(y = Beta, x = xv, colour = (Beta >= 0)))
+    betaplot <- ggplot(betas, aes(x = xv, y = Beta, colour = (Beta >= 0)))
     pal.len <- 2
     legend.labels <- NULL
   }
@@ -548,7 +549,7 @@ sjp.lm <- function(fit,
     # and error bar
     geom_errorbar(aes(ymin = lower, ymax = upper), width = 0) +
     # Print p-values. With vertical adjustment, so they don't overlap with the errorbars
-    geom_text(aes(label = p, y = Beta),
+    geom_text(aes(label = p),
               nudge_x = y.offset,
               show.legend = FALSE) +
     # print point
@@ -563,7 +564,7 @@ sjp.lm <- function(fit,
                        labels = ticks) +
     # set value labels to x-axis
     scale_x_discrete(labels = axisLabels.y,
-                     limits = 1:nrow(betas)) +
+                     limits = 1:length(axisLabels.y)) +
     labs(title = title, x = NULL, y = axisTitle.x, colour = legendTitle)
   # --------------------------------------------------------
   # flip coordinates?

---FILE: R/sjPlotOdds.R---
@@ -760,7 +760,9 @@ sjp.glm.pc <- function(fit,
                                    y = y)) +
           labs(x = NULL,
                y = ""Predicted Probability"",
-               title = ""Predicted probabilities of coefficients"") +
+               title = ifelse(type == ""prob"", 
+                              ""Predicted probabilities of coefficients"",
+                              ""Predicted marginal probabilities of coefficients"")) +
           stat_smooth(method = ""glm"", 
                       method.args = list(family = ""binomial""), 
                       se = show.ci,"
strengejacke,sjPlot,cec95cbb018a234ee26327926d6d6b6936101542,Daniel Ldecke,d.luedecke@uke.de,2016-02-29T18:39:49Z,Daniel Ldecke,d.luedecke@uke.de,2016-02-29T18:39:49Z,fix #109,NEWS;NEWS.md;R/sjPlotLikert.R,False,True,True,False,16,8,24,"---FILE: NEWS---
@@ -13,7 +13,7 @@ Bug fixes:
 * Fixed bug in `sjp.lmer` and `sjp.glmer` with doubled y-axis for faceted random effect plots.
 * `sjt.xtab` ignored value labels when weighting data.
 * Fixed bug with position of value labels in `sjp.xtab`.
-
+* Fixed bug in `sjp.likert` that plotted categories in wrong order when neutral category was lower than amount of categories.
 
 Version 1.9.1
 -----------------------------------------------------------------------------

---FILE: NEWS.md---
@@ -14,5 +14,6 @@
 
 * Fixed bug in `sjp.int`, where automatic y-axis-scaling for binary outcomes cut off parts of confidence region in some cases.
 * Fixed bug in `sjp.lmer` and `sjp.glmer` with doubled y-axis for faceted random effect plots.
-* `sjt.xtab` ignored value labels when weighting data.
-* Fixed bug with position of value labels in `sjp.xtab`.
\ No newline at end of file
+* `sjt.xtab` ignored value labels when weighting data ([#106](https://github.com/sjPlot/devel/issues/106)).
+* Fixed bug with position of value labels in `sjp.xtab` ([#107](https://github.com/sjPlot/devel/issues/107)).
+* Fixed bug in `sjp.likert` that plotted categories in wrong order when neutral category was lower than amount of categories ([#109](https://github.com/sjPlot/devel/issues/109)).
\ No newline at end of file

---FILE: R/sjPlotLikert.R---
@@ -341,11 +341,18 @@ sjp.likert <- function(items,
     # category, recode neutral category to last category
     # --------------------------------------------------------
     if (!is.null(cat.neutral) && cat.neutral <= catcount) {
-      items[[i]] <- sjmisc::rec(items[[i]], sprintf(""%i=%i;%i=%i;else=copy"", 
-                                                    cat.neutral, 
-                                                    catcount + 1, 
-                                                    catcount + 1,
-                                                    cat.neutral))
+      # first, each other category has to be moved down one position
+      # therefore, we create a pattern with values from neutral
+      # category to category count
+      downvote <- seq(cat.neutral, catcount + 1, by = 1)
+      # now we ""shift"" this value pattern and make a
+      # string out of it
+      recode.pattern <- paste0(paste0(sprintf(""%i=%i"",
+                                              c(downvote[-1], downvote[1]),
+                                              downvote),
+                                      collapse = "";""), "";else=copy"")
+      # finally, recode data
+      items[[i]] <- sjmisc::rec(items[[i]], recodes = recode.pattern)
     }
     # --------------------------------------------------------
     # If we don't plot neutral category, but item still contains"
strengejacke,sjPlot,0309df5c4813e5cbbdf504e35bef8fea8d0af4ed,Daniel Ldecke,d.luedecke@uke.de,2016-02-26T12:46:05Z,Daniel Ldecke,d.luedecke@uke.de,2016-02-26T12:46:05Z,fixed cran issues,R/sjPlotLinreg.R;devel.Rproj,False,True,True,False,3,2,5,"---FILE: R/sjPlotLinreg.R---
@@ -1,5 +1,5 @@
 # bind global variables
-utils::globalVariables(c(""vars"", ""Beta"", ""xv"", ""lower"", ""upper"", ""stdbeta"", ""p"", ""x"", ""ydiff"", ""y"", ""grp"", "".stdresid"", "".resid"", "".fitted"", ""V1"", ""V2"", ""grp.est""))
+utils::globalVariables(c(""fit"", ""vars"", ""Beta"", ""xv"", ""lower"", ""upper"", ""stdbeta"", ""p"", ""x"", ""ydiff"", ""y"", ""grp"", "".stdresid"", "".resid"", "".fitted"", ""V1"", ""V2"", ""grp.est""))
 
 
 #' @title Plot estimates or predicted values of linear models

---FILE: devel.Rproj---
@@ -13,6 +13,7 @@ RnwWeave: knitr
 LaTeX: pdfLaTeX
 
 BuildType: Package
+PackageUseDevtools: Yes
 PackageInstallArgs: --no-multiarch --with-keep.source
-PackageCheckArgs: --as-cran
+PackageCheckArgs: --as-cran --no-manual
 PackageRoxygenize: rd,collate,namespace,vignette"
strengejacke,sjPlot,a8681bd41e7a99fda0523ead0f0b5eddeff25f05,Daniel Ldecke,d.luedecke@uke.de,2016-02-26T11:10:05Z,Daniel Ldecke,d.luedecke@uke.de,2016-02-26T11:10:05Z,minor fix,R/sjPlotGroupFrequencies.R,False,True,True,False,2,2,4,"---FILE: R/sjPlotGroupFrequencies.R---
@@ -367,11 +367,11 @@ sjp.grpfrq <- function(varCount,
   # --------------------------------------------------------
   # count variable may not be a factor!
   # --------------------------------------------------------
-  if (anyNA(as.numeric(varCount)))
+  if (anyNA(as.numeric(na.omit(varCount))))
     varCount <- sjmisc::to_value(varCount, keep.labels = F)
   else
     varCount <- as.numeric(varCount)
-  if (anyNA(as.numeric(varGroup)))
+  if (anyNA(as.numeric(na.omit(varGroup))))
     varGroup <- sjmisc::to_value(varGroup, keep.labels = F)
   else
     varGroup <- as.numeric(varGroup)"
strengejacke,sjPlot,0f49e4aa3e5dc2d8b7abcdb3146f182adf998d07,Daniel Ldecke,d.luedecke@uke.de,2016-02-26T08:22:49Z,Daniel Ldecke,d.luedecke@uke.de,2016-02-26T08:22:49Z,"closes #108, fix CRAN-check issues",DESCRIPTION;NEWS;R/helpfunctions.R;R/sjPlotFrequencies.R;R/sjPlotGroupFrequencies.R;R/sjPlotLinreg.R;R/sjPlotPropTable.R;devel.Rproj;man/sjPlot-package.Rd;tests/testthat/test_sjpglmer.R;tests/testthat/test_sjplmer.R,False,True,True,False,30,30,60,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.9.1-2
-Date: 2016-02-22
+Version: 1.9.1-3
+Date: 2016-02-26
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of plotting and table output functions for data

---FILE: NEWS---
@@ -1,4 +1,4 @@
-Version 1.9.1-2
+Version 1.9.1-3
 -----------------------------------------------------------------------------
 Changes to functions:
 * `sjp.lmm` and `sjp.glmm` now also support linear mixed effects models (of class `merMod`).

---FILE: R/helpfunctions.R---
@@ -151,7 +151,7 @@ create.frq.df <- function(x,
   #---------------------------------------------------
   # need numeric
   #---------------------------------------------------
-  if (is.factor(x)) {
+  if (is.factor(x) || is.character(x)) {
     x <- sjmisc::to_value(x, keep.labels = F)
   }
   # valid values are one row less, because last row is NA row

---FILE: R/sjPlotFrequencies.R---
@@ -405,7 +405,7 @@ sjp.frq <- function(varCount,
   # --------------------------------------------------------
   # count variable may not be a factor!
   # --------------------------------------------------------
-  if (is.factor(varCount)) {
+  if (is.factor(varCount) || is.character(varCount)) {
     varCount <- sjmisc::to_value(varCount, keep.labels = F)
   }
   # --------------------------------------------------------

---FILE: R/sjPlotGroupFrequencies.R---
@@ -324,13 +324,11 @@ sjp.grpfrq <- function(varCount,
                           round.prz = 2,
                           na.rm = na.rm,
                           weightBy = weightBy)
-  # add rownames or label as x-position to data frame,
-  # depending on plot type. for lines, we assume continuous
-  # scale.
-  if (type == ""lines"")
-    bars.xpos <- as.numeric(mydat$mydat$label)
-  else
-    bars.xpos <- dplyr::add_rownames(mydat$mydat, var = ""xpos"")$xpos
+  # --------------------------------------------------------
+  # x-position as numeric factor, added later after
+  # tidying
+  # --------------------------------------------------------
+  bars.xpos <- 1:nrow(mydat$mydat)
   # --------------------------------------------------------
   # try to automatically set labels if not passed as argument
   # --------------------------------------------------------
@@ -369,8 +367,14 @@ sjp.grpfrq <- function(varCount,
   # --------------------------------------------------------
   # count variable may not be a factor!
   # --------------------------------------------------------
-  varCount <- as.numeric(varCount)
-  varGroup <- as.numeric(varGroup)
+  if (anyNA(as.numeric(varCount)))
+    varCount <- sjmisc::to_value(varCount, keep.labels = F)
+  else
+    varCount <- as.numeric(varCount)
+  if (anyNA(as.numeric(varGroup)))
+    varGroup <- sjmisc::to_value(varGroup, keep.labels = F)
+  else
+    varGroup <- as.numeric(varGroup)
   #---------------------------------------------------
   # check whether variable should be auto-grouped
   #---------------------------------------------------
@@ -402,13 +406,10 @@ sjp.grpfrq <- function(varCount,
                         ""frq"", 
                         2:(grpcount + 1), 
                         factor_key = TRUE)
-  # -----------------------------------------------
-  # xpos should be numeric factor
-  #---------------------------------------------------
-  if (suppressWarnings(anyNA(as.numeric(bars.xpos))))
-    mydf$xpos <- as.factor(bars.xpos)
-  else
-    mydf$xpos <- as.factor(as.numeric(bars.xpos))
+  # --------------------------------------------------------
+  # add xpos now
+  # --------------------------------------------------------
+  mydf$xpos <- as.factor(as.numeric(bars.xpos))
   # --------------------------------------------------------
   # add half of Percentage values as new y-position for stacked bars
   # mydat <- ddply(mydat, ""count"", transform, ypos = cumsum(frq) - 0.5*frq)

---FILE: R/sjPlotLinreg.R---
@@ -857,7 +857,7 @@ sjp.lm.ma <- function(linreg, showOriginalModelOnly = TRUE, completeDiagnostic =
   # ---------------------------------
   # remove outliers, only non-mixed models
   # ---------------------------------
-  if (any(class(fit) == ""lm"")) {
+  if (any(class(linreg) == ""lm"")) {
     # copy current model
     model <- linreg
     # get r2

---FILE: R/sjPlotPropTable.R---
@@ -1,5 +1,5 @@
 # bind global variables
-utils::globalVariables(c(""rowname"", ""total"", ""prc"", ""n"", ""Count"", ""Group"", ""line.break""))
+utils::globalVariables(c(""rowname"", ""total"", ""ges"", ""prc"", ""n"", ""Count"", ""Group"", ""line.break""))
 
 #' @title Plot contingency tables
 #' @name sjp.xtab

---FILE: devel.Rproj---
@@ -13,7 +13,6 @@ RnwWeave: knitr
 LaTeX: pdfLaTeX
 
 BuildType: Package
-PackageUseDevtools: Yes
 PackageInstallArgs: --no-multiarch --with-keep.source
 PackageCheckArgs: --as-cran
 PackageRoxygenize: rd,collate,namespace,vignette

---FILE: man/sjPlot-package.Rd---
@@ -34,8 +34,8 @@
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.9.1-2\cr
-Date: \tab 2016-02-22\cr
+Version: \tab 1.9.1-3\cr
+Date: \tab 2016-02-26\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: tests/testthat/test_sjpglmer.R---
@@ -92,7 +92,7 @@ test_that(""glmer, ri.pc"", {
   # for each covariate, grouped by random intercepts
   sjp.glmer(fit,
             type = ""ri.pc"",
-            show.se = TRUE)
+            show.ci = TRUE)
 })
 
 test_that(""glmer, ri.pc, facet"", {

---FILE: tests/testthat/test_sjplmer.R---
@@ -232,17 +232,17 @@ fit <- lme4::lmer(extro ~ open + agree + social + (1 + open | school/class),
 
 test_that(""lmer"", {
   skip_on_cran()
-  expect_warning(sjp.lmer(fit))
+  sjp.lmer(fit)
 })
 
 test_that(""lmer"", {
   skip_on_cran()
-  expect_warning(sjp.lmer(fit, ri.nr = 2))
+  sjp.lmer(fit, ri.nr = 2)
 })
 
 test_that(""lmer"", {
   skip_on_cran()
-  expect_warning(sjp.lmer(fit, ri.nr = c(1,5)))
+  sjp.lmer(fit, ri.nr = c(1,5))
 })
 
 test_that(""lmer"", {"
strengejacke,sjPlot,3bb67bf174546072d1fb0f10f367c1e112a8c70c,Daniel Ldecke,d.luedecke@uke.de,2016-02-25T18:34:22Z,Daniel Ldecke,d.luedecke@uke.de,2016-02-25T18:34:22Z,fixed bug with line-type in sjp.xtab,R/sjPlotPropTable.R,False,True,True,False,19,22,41,"---FILE: R/sjPlotPropTable.R---
@@ -220,13 +220,11 @@ sjp.xtab <- function(x,
                           round.prz = 2,
                           na.rm = T,
                           weightBy = weightBy)
-  # add rownames or label as x-position to data frame,
-  # depending on plot type. for lines, we assume continuous
-  # scale.
-  if (type == ""lines"")
-    bars.xpos <- as.numeric(mydat$mydat$label)
-  else
-    bars.xpos <- dplyr::add_rownames(mydat$mydat, var = ""xpos"")$xpos
+  # --------------------------------------------------------
+  # x-position as numeric factor, added later after
+  # tidying
+  # --------------------------------------------------------
+  bars.xpos <- 1:nrow(mydat$mydat)
   # --------------------------------------------------------
   # try to automatically set labels is not passed as argument
   # --------------------------------------------------------
@@ -292,13 +290,10 @@ sjp.xtab <- function(x,
   #---------------------------------------------------
   if (tableIndex != ""col"") mydf <- dplyr::filter(mydf, rowname != ""total"")
   if (tableIndex == ""cell"") mydf <- dplyr::select(mydf, -total)
-  # -----------------------------------------------
-  # xpos should be numeric factor
-  #---------------------------------------------------
-  if (suppressWarnings(anyNA(as.numeric(bars.xpos))))
-    mydf$xpos <- as.factor(bars.xpos)
-  else
-    mydf$xpos <- as.factor(as.numeric(bars.xpos))
+  # --------------------------------------------------------
+  # add xpos now
+  # --------------------------------------------------------
+  mydf$xpos <- as.factor(as.numeric(bars.xpos))
   # --------------------------------------------------------
   # add half of Percentage values as new y-position for stacked bars
   # --------------------------------------------------------
@@ -368,9 +363,14 @@ sjp.xtab <- function(x,
     else
       upper_lim <- 1
   } else {
+    # factor depends on labels
+    if (showValueLabels == TRUE)
+      mlp <- 1.2
+    else
+      mlp <- 1.1
     # else calculate upper y-axis-range depending
     # on the amount of max. answers per category
-    upper_lim <- max(mydf$prc) * 1.1
+    upper_lim <- max(mydf$prc) * mlp
   }
   # --------------------------------------------------------
   # check if category-oder on x-axis should be reversed
@@ -454,20 +454,17 @@ sjp.xtab <- function(x,
     }
   # check if we have lines
   } else if (type == ""lines"") {
+    # for lines, numeric scale
+    mydf$xpos <- sjmisc::to_value(mydf$xpos, keep.labels = F)
     line.stat <- ifelse(smoothLines == TRUE, ""smooth"", ""identity"")
-    geob <- geom_line(aes(x = as.numeric(xpos),
-                          y = prc,
-                          colour = group),
-                      data = mydf,
+    geob <- geom_line(aes(colour = group),
                       size = geom.size, 
                       stat = line.stat)
   }
   # --------------------------------------------------------
   # start plot here
   # --------------------------------------------------------
-  baseplot <- ggplot(mydf, aes(x = xpos, 
-                               y = prc, 
-                               fill = group)) + geob
+  baseplot <- ggplot(mydf, aes(x = xpos, y = prc, fill = group)) + geob
   # if we have line diagram, print lines here
   if (type == ""lines"") {
     baseplot <- baseplot + "
strengejacke,sjPlot,33de5c7c8eede7448edb611cd2c089f4e12ea598,Daniel Ldecke,d.luedecke@uke.de,2016-02-22T16:18:38Z,Daniel Ldecke,d.luedecke@uke.de,2016-02-22T16:18:38Z,minor fix in `sjp.glmer`,R/sjPlotGLME.R,False,True,True,False,22,15,37,"---FILE: R/sjPlotGLME.R---
@@ -1648,10 +1648,6 @@ sjp.lme.response.probcurv <- function(fit,
                                       fun,
                                       printPlot) {
   # ----------------------------
-  # check axis limits
-  # ----------------------------
-  if (is.null(axisLimits.y)) axisLimits.y <- c(0, 1)
-  # ----------------------------
   # get predicted values for response with and
   # without random effects
   # ----------------------------
@@ -1680,6 +1676,13 @@ sjp.lme.response.probcurv <- function(fit,
                     grp = ""Including fixed effects only"")
   # bind rows
   mydf <- rbind(mydf, tmp)
+  # ------------------------------
+  # check axis limits
+  # ------------------------------
+  if (is.null(axisLimits.y)) {
+    axisLimits.y <- c(as.integer(floor(10 * min(mydf$y, na.rm = T) * .9)) / 10,
+                      as.integer(ceiling(10 * max(mydf$y, na.rm = T) * 1.1)) / 10)
+  }
   # ---------------------------------------------------------
   # Prepare plot
   # ---------------------------------------------------------
@@ -1860,8 +1863,6 @@ sjp.lme.reri <- function(fit,
                          fun) {
   # check size argument
   if (is.null(geom.size)) geom.size <- .7
-  # check axis limits
-  if (is.null(axisLimits.y)) axisLimits.y <- c(0, 1)
   # ----------------------------
   # retrieve term names, so we find the estimates in the
   # coefficients list
@@ -1941,11 +1942,18 @@ sjp.lme.reri <- function(fit,
       }
       # convert grouping level to factor
       final.df$grp <- as.factor(final.df$grp)
-      final.df$x <- sjmisc::to_value(final.df$x)
-      final.df$y <- sjmisc::to_value(final.df$y)
+      final.df$x <- sjmisc::to_value(final.df$x, keep.labels = F)
+      final.df$y <- sjmisc::to_value(final.df$y, keep.labels = F)
       # logistic regression?
       if (fun == ""glm"") final.df$y <- plogis(final.df$y)
       # ------------------------------
+      # check axis limits
+      # ------------------------------
+      if (is.null(axisLimits.y)) {
+        axisLimits.y <- c(as.integer(floor(10 * min(final.df$y, na.rm = T) * .9)) / 10,
+                          as.integer(ceiling(10 * max(final.df$y, na.rm = T) * 1.1)) / 10)
+      }
+      # ------------------------------
       # title and axis title
       # ------------------------------
       if (is.null(title)) title <- sprintf(""Random slopes within \""%s\"""", ri.name)
@@ -1956,17 +1964,16 @@ sjp.lme.reri <- function(fit,
       if (fun == ""lm"") {
         if (is.null(axisTitle.y)) axisTitle.y <- colnames(fit@frame)[1]
         gp <- ggplot(final.df, aes(x = x, y = y, colour = grp)) +
-          geom_line(size = geom.size) +
-          labs(title = title, y = axisTitle.y, x = axisTitle.x)
+          geom_line(size = geom.size)
       } else {
         if (is.null(axisTitle.y)) axisTitle.y <- sprintf(""Predicted Probability of %s"", colnames(fit@frame)[1])
         gp <- ggplot(final.df, aes(x = x, y = y, colour = grp)) +
-          stat_smooth(method = ""glm"", method.args = list(family = ""binomial"")) +
-          # cartesian coord still plots range of se, even
-          # when se exceeds plot range.
-          coord_cartesian(ylim = axisLimits.y) +
-          labs(x = axisTitle.x, y = axisTitle.y, title = title)
+          stat_smooth(method = ""glm"", se = F,
+                      method.args = list(family = ""binomial""))
       }
+      gp <- gp +
+        scale_y_continuous(limits = axisLimits.y) +
+        labs(title = title, y = axisTitle.y, x = axisTitle.x)
       # ------------------------------
       # highlight specific groups?
       # ------------------------------"
strengejacke,sjPlot,ac6aee23402f4417070a256d9512d482079aa8c4,Daniel Ldecke,d.luedecke@uke.de,2016-02-21T19:58:32Z,Daniel Ldecke,d.luedecke@uke.de,2016-02-21T19:58:32Z,minor fixes,NEWS;NEWS.md;R/sjPlotGLME.R;R/sjPlotPolynomials.R,False,True,True,False,15,3,18,"---FILE: NEWS---
@@ -4,9 +4,12 @@ Changes to functions:
 * `sjp.lmm` and `sjp.glmm` now also support linear mixed effects models (of class `merMod`).
 * `sjp.int` now uses proper x-axis-tick-labels for `type = ""eff""`, when predictor on x-axis is a factor with non-numeric factor-levels (or has label attributes).
 * `sjp.glm` gets a `group.estimates` argument to group estimates in forest plots and colour them according to group assignment. Use arguments `show.legend` and `legendTitle` to modify group legend.
+* `sjp.poly` now has better variable label detection for automatic axis labelling.
 
 Bug fixes:
 * Fixed bug in `sjp.int`, where automatic y-axis-scaling for binary outcomes cut off parts of confidence region in some cases.
+* Fixed bug in `sjp.lmer` and `sjp.glmer` with doubled y-axis for faceted random effect plots.
+
 
 Version 1.9.1
 -----------------------------------------------------------------------------

---FILE: NEWS.md---
@@ -5,8 +5,10 @@
 * `sjp.lmm`  and `sjp.glmm` now also support linear mixed effects models (of class `merMod`).
 * `sjp.int` now uses proper x-axis-tick-labels for `type = ""eff""`, when predictor on x-axis is a factor with non-numeric factor-levels (or has label attributes).
 * `sjp.glm` gets a `group.estimates` argument to group estimates in forest plots and colour them according to group assignment. Use arguments `show.legend` and `legendTitle` to modify group legend.
+* `sjp.poly` now has better variable label detection for automatic axis labelling.
 
 
 ## Bug fixes
 
 * Fixed bug in `sjp.int`, where automatic y-axis-scaling for binary outcomes cut off parts of confidence region in some cases.
+* Fixed bug in `sjp.lmer` and `sjp.glmer` with doubled y-axis for faceted random effect plots.
\ No newline at end of file

---FILE: R/sjPlotGLME.R---
@@ -1144,7 +1144,8 @@ sjp.lme4  <- function(fit,
     # ---------------------------------------
     # check length labels
     # ---------------------------------------
-    if (length(pred.labels) != nrow(mydf)) {
+    if (length(pred.labels) != nrow(mydf) && 
+        (length(pred.labels) != (nrow(mydf) / length(unique(mydf$grp))))) {
       warning(""`pred.labels` has insufficient length. Using row names."", call. = F)
       pred.labels <- row.names(mydf)
     }

---FILE: R/sjPlotPolynomials.R---
@@ -133,6 +133,13 @@ sjp.poly <- function(x,
   # --------------------------------------------
   geom.colors <- col_check2(geom.colors, length(poly.degree))
   # --------------------------------------------
+  # check poly.term parameter
+  # --------------------------------------------
+  if (is.character(poly.term))
+    defv <- poly.term
+  else
+    defv <- get_var_name(deparse(substitute(poly.term)))
+  # --------------------------------------------
   # parameter check: fitted model or variables?
   # --------------------------------------------
   if ((any(class(x) == ""glmerMod"") || any(class(x) == ""lmerMod"" || any(class(x) == ""merModLmerTest""))) && !requireNamespace(""lme4"", quietly = TRUE)) {
@@ -165,8 +172,7 @@ sjp.poly <- function(x,
   # retrieve labels
   # --------------------------------------------
   if (is.null(axisTitle.x))
-    axisTitle.x <- sjmisc::get_label(poly.term,
-                                     def.value = get_var_name(deparse(substitute(poly.term))))
+    axisTitle.x <- sjmisc::get_label(poly.term, def.value = defv)
   if (is.null(axisTitle.y)) 
     axisTitle.y <- sjmisc::get_label(resp, def.value = ""Response"")
   # no labels found? set default then"
strengejacke,sjPlot,4bb9ab22eb18b456f9c3caa382b6bd17bcef8c91,Daniel Ldecke,d.luedecke@uke.de,2016-02-08T18:18:23Z,Daniel Ldecke,d.luedecke@uke.de,2016-02-08T18:18:23Z,"final tests, minor fixes, release 1.9.1",DESCRIPTION;NEWS;NEWS.md;R/sjPlotInteractions.R;R/zzz.R;man/sjPlot-package.Rd;tests/testthat/test_sjpfrq.R;tests/testthat/test_sjpglmer.R;tests/testthat/test_sjpgrpfrq.R;tests/testthat/test_sjpint.R;tests/testthat/test_sjplikert.R;tests/testthat/test_sjplmer.R;tests/testthat/test_sjtglm.R;tests/testthat/test_sjtlm.R;tests/testthat/test_sjtxtab.R,False,True,True,False,821,318,1139,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.9.0-4
-Date: 2016-02-05
+Version: 1.9.1
+Date: 2016-02-08
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of plotting and table output functions for data

---FILE: NEWS---
@@ -1,4 +1,4 @@
-Version 1.9.0-4
+Version 1.9.1
 -----------------------------------------------------------------------------
 Changes to functions:
 * Improved text label positioning for plotting functions.
@@ -8,16 +8,17 @@ Changes to functions:
 * `sjp.glmer` and `sjp.lmer` get a `axisLimits.y` argument to specify y-axis limits specifically for predicted probability or effect plots.
 * `view_df` now supports showing missings and missing percentages.
 * Harmonized column names of returned data frames to match `broom`s naming convention for `sjp.lm`, `sjp.glm`, `sjp.lmer`, `sjp.glmer`, `sjp.lmm`, `sjp.glmm`, `sjp.aov1` and `sjp.int`.
+* Functions with harmonized data frames as return value now also gain the class attribute `sjPlot`, and all returned data frame values are named `data`.
 * `sjp.scatter` gets a `useCount` argument to indicate overplotting by point size.
 * `sjp.scatter` now also plots data points when using argument `pointLabels`, so exact position of labelled data points is visible. `geom_text_repel` is used to avoid overlapping of points and labels.
 * `sjt.xtab` gets a `title` argument to print a table caption.
 
 Bug fixes:
 * Automatic label detection did not choose column names when no variable labels were present for functions that accepted data frames as data argument, now works again.
-* `sjp.int` did not work with fitted models from class `lme`.
-* `sjt.xtab` did not show `NA` values for `showNA = TRUE`, now works again..
-* `sjt.xtab` did not use arguments `valueLabels`, now works again..
-* Table summary (chi-squared, phi, p) for `sjt.xtab` were wrong, now works again..
+* `sjp.int` did not work with fitted models from class `lme`, now works again.
+* `sjt.xtab` did not show `NA` values for `showNA = TRUE`, now works again.
+* `sjt.xtab` did not use arguments `valueLabels`, now works again.
+* Table summary (chi-squared, phi, p) for `sjt.xtab` were wrong, now works again.
 * Due to rounding, total percentage in `sjt.xtab` could differ from 100%.
 * Minor fixes.
 

---FILE: NEWS.md---
@@ -1,4 +1,4 @@
-# sjPlot 1.9.0-4
+# sjPlot 1.9.1
 
 ## Changes to functions
 * Improved text label positioning for plotting functions.
@@ -8,14 +8,14 @@
 * `sjp.glmer` and `sjp.lmer` get a `axisLimits.y` argument to specify y-axis limits specifically for predicted probability or effect plots.
 * `view_df` now supports showing missings and missing percentages ([#76](https://github.com/sjPlot/devel/issues/76)).
 * Harmonized column names of returned data frames to match [broom's naming convention](https://github.com/dgrtwo/broom#tidy-functions) for `sjp.lm`, `sjp.glm`, `sjp.lmer`, `sjp.glmer`, `sjp.lmm`, `sjp.glmm`, `sjp.aov1` and `sjp.int` ([#94](https://github.com/sjPlot/devel/issues/94)).
-* Functions with harmonized data as return value now also gain the class attribute `sjPlot`, and all returned data frame values are names `data`.
+* Functions with harmonized data frames as return value now also gain the class attribute `sjPlot`, and all returned data frame values are named `data`.
 * `sjp.scatter` gets a `useCount` argument to indicate overplotting by point size.
 * `sjp.scatter` now also plots data points when using argument `pointLabels`, so exact position of labelled data points is visible. `geom_text_repel` is used to avoid overlapping of points and labels.
 * `sjt.xtab` gets a `title` argument to print a table caption.
 
 ## Bug fixes
 * Automatic label detection did not choose column names when no variable labels were present for functions that accepted data frames as data argument ([#96](https://github.com/sjPlot/devel/issues/96)), now works again.
-* `sjp.int` did not work with fitted models from class `lme`.
+* `sjp.int` did not work with fitted models from class `lme`, now works again.
 * `sjt.xtab` did not show `NA` values for `showNA = TRUE`, now works again.
 * `sjt.xtab` did not use arguments `valueLabels` ([#101](https://github.com/sjPlot/devel/issues/101)), now works again.
 * Table summary (chi-squared, phi, p) for `sjt.xtab` were wrong, now works again.

---FILE: R/sjPlotInteractions.R---
@@ -691,8 +691,8 @@ sjp.int <- function(fit,
     # -----------------------------------------------------------
     if (is.null(axisLimits.y)) {
       if (fitfam %in% c(""binomial"", ""quasibinomial"")) {
-        lowerLim.y <- as.integer(10 * min(intdf$y, na.rm = T) * .9) / 10
-        upperLim.y <- as.integer(10 * max(intdf$y, na.rm = T) * 1.1) / 10
+        lowerLim.y <- as.integer(floor(10 * min(intdf$y, na.rm = T) * .9)) / 10
+        upperLim.y <- as.integer(ceiling(10 * max(intdf$y, na.rm = T) * 1.1)) / 10
       } else {
         if (diff) {
           lowerLim.y <- floor(min(intdf$ydiff, na.rm = T))
@@ -1169,8 +1169,8 @@ sjp.eff.int <- function(fit,
       # -----------------------------------------------------------
       if (is.null(axisLimits.y)) {
         if (fitfam %in% c(""binomial"", ""quasibinomial"")) {
-          lowerLim.y <- as.integer(10 * min(intdf$y, na.rm = T) * .9) / 10
-          upperLim.y <- as.integer(10 * max(intdf$y, na.rm = T) * 1.1) / 10
+          lowerLim.y <- as.integer(floor(10 * min(intdf$y, na.rm = T) * .9)) / 10
+          upperLim.y <- as.integer(ceiling(10 * max(intdf$y, na.rm = T) * 1.1)) / 10
         } else {
           if (showCI) {
             lowerLim.y <- floor(min(intdf$conf.low, na.rm = T))

---FILE: R/zzz.R---
@@ -1,5 +1,7 @@
 .onAttach <- function(libname, pkgname) {
   if (stats::runif(1) > .8) {
     packageStartupMessage(""Visit http://strengejacke.de/sjPlot for package-vignettes."")
+  } else if (stats::runif(1) > .9) {
+    packageStartupMessage(""#refugeeswelcome"")
   }
 }
\ No newline at end of file

---FILE: man/sjPlot-package.Rd---
@@ -34,8 +34,8 @@
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.9.0-4\cr
-Date: \tab 2016-02-05\cr
+Version: \tab 1.9.1\cr
+Date: \tab 2016-02-08\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: tests/testthat/test_sjpfrq.R---
@@ -1,11 +1,13 @@
 context(""sjp.frq"")
 
 test_that(""Simple frequencies"", {
+  skip_on_cran()
   sjp.frq(efc$e42dep)
 })
 
 test_that(""Frequencies, sorted"", {
-sjp.frq(efc$e15relat,
+  skip_on_cran()
+  sjp.frq(efc$e15relat,
         title = ""Relationship"",
         sort.frq = ""desc"",
         geom.size = .4,
@@ -14,11 +16,13 @@ sjp.frq(efc$e15relat,
 })
   
 test_that(""Simple frequencies"", {
+  skip_on_cran()
   # Expect Warning
   expect_warning(sjp.frq(efc$e17age, interactionVar = efc$c161sex))
 })
         
 test_that(""Boxplot with interaction"", {
+  skip_on_cran()
   sjp.frq(efc$e17age, 
           interactionVar = efc$c161sex,
           type = ""box"",
@@ -27,13 +31,15 @@ test_that(""Boxplot with interaction"", {
 })
 
 test_that(""Violin plot"", {
+  skip_on_cran()
   sjp.frq(efc$c12hour, 
           type = ""violin"",
           innerBoxPlotWidth = .1,
           innerBoxPlotDotSize = 2)  
 })
 
 test_that(""Histogram with norm curves"", {
+  skip_on_cran()
   sjp.frq(efc$c160age,
           type = ""h"",
           showMeanIntercept = T,
@@ -47,6 +53,7 @@ test_that(""Histogram with norm curves"", {
 })
 
 test_that(""Density with norm curves"", {
+  skip_on_cran()
   sjp.frq(efc$c160age,
           type = ""dens"",
           showMeanIntercept = T,
@@ -59,6 +66,7 @@ test_that(""Density with norm curves"", {
 })
 
 test_that(""Dots, flipped"", {
+  skip_on_cran()
   sjp.frq(efc$e42dep,
           type = ""dots"",
           showCI = T,
@@ -68,32 +76,38 @@ test_that(""Dots, flipped"", {
 })
 
 test_that(""Bars and SE"", {
+  skip_on_cran()
   sjp.frq(efc$e42dep,
           showCI = T,
           error.bar.color = ""blue"")
 })
 
 test_that(""Boxplot"", {
+  skip_on_cran()
   # boxplot
   sjp.frq(ChickWeight$weight, type = ""box"")
 })
 
 test_that(""Histogram"", {
+  skip_on_cran()
   # histogram
   sjp.frq(discoveries, type = ""hist"", showMeanIntercept = TRUE)
 })
 
 test_that(""Violin plot"", {
+  skip_on_cran()
   # violin plot
   sjp.frq(ChickWeight$weight, type = ""v"")
 })
 
 test_that(""Barplot"", {
+  skip_on_cran()
   # bar plot
   sjp.frq(ChickWeight$Diet)
 })
 
 test_that(""Grouped bars"", {
+  skip_on_cran()
   # bar plot with EUROFAMCARE sample dataset
   # grouped variable
   ageGrp <- group_var(efc$e17age)
@@ -104,6 +118,7 @@ test_that(""Grouped bars"", {
 })
 
 test_that(""Interaction"", {
+  skip_on_cran()
   # box plots with interaction variable
   # the following example is equal to the function call
   # sjp.grpfrq(efc$e17age, efc$e16sex, type = ""box"")
@@ -117,6 +132,7 @@ test_that(""Interaction"", {
 })
 
 test_that(""Dotplot"", {
+  skip_on_cran()
   # plotting confidence intervals
   sjp.frq(efc$e15relat,
           type = ""dots"",

---FILE: tests/testthat/test_sjpglmer.R---
@@ -1,4 +1,4 @@
-context(""lme4"")
+context(""sjp.glmer"")
 
 library(lme4)
 # create binary response
@@ -9,16 +9,19 @@ fit <- glmer(Reaction.dicho ~ Days + (Days | Subject),
              family = binomial(""logit""))
 
 test_that(""glmer"", {
+  skip_on_cran()
   # simple plot
   sjp.glmer(fit)
 })
 
 test_that(""glmer, sort.coef"", {
+  skip_on_cran()
   # sort by predictor Days
   sjp.glmer(fit, sort.coef = ""Days"")
 })
 
 test_that(""glmer, facet"", {
+  skip_on_cran()
   # plot each predictor as own plot and sort them
   sjp.glmer(fit,
             facet.grid = FALSE,
@@ -43,82 +46,119 @@ fit <- glmer(hi_qol ~ sex + c12hour + neg_c_7 + (1 | grp),
              family = binomial(""logit""))
 
 test_that(""glmer, efc"", {
+  skip_on_cran()
   # plot random effects
   sjp.glmer(fit)
 })
 
 test_that(""glmer, efc, lables"", {
+  skip_on_cran()
   # plot random effects
   sjp.glmer(fit, pred.labels = c(""spouse"", ""child"", ""sibling"",
                                  ""child in-law"", ""ancle/aunt"",
                                  ""nephiew/niece"", ""cousin""))
 })
 
 test_that(""glmer, efc, lables"", {
+  skip_on_cran()
   # plot fixed effects
   sjp.glmer(fit, type = ""fe"", pred.labels = c(""gender"", ""care hours"",
                                               ""negative impact""))
 })
 
 # plot and sort fixed effects
-sjp.glmer(fit,
-          type = ""fe"",
-          sort.coef = TRUE)
+test_that(""glmer, fe"", {
+  skip_on_cran()
+  sjp.glmer(fit,
+            type = ""fe"",
+            sort.coef = TRUE)
+})
 
 # plot fixed effects correlations
-sjp.glmer(fit, type = ""fe.cor"")
-
-# qq-plot of random effects
-sjp.glmer(fit, type = ""re.qq"")
-
-# plot probability curves (predicted probabilities)
-# for each covariate, grouped by random intercepts
-sjp.glmer(fit,
-          type = ""ri.pc"",
-          show.se = TRUE)
-
-# plot probability curves (predicted probabilities)
-# for each covariate, grouped by random intercepts
-# in integrated plots
-sjp.glmer(fit,
-          type = ""ri.pc"",
-          facet.grid = FALSE)
-
-sjp.glmer(fit,
-          type = ""ri.pc"",
-          emph.grp = c(1, 4),
-          facet.grid = FALSE)
-
-sjp.glmer(fit,
-          type = ""ri.pc"",
-          emph.grp = c(""child"", ""cousin""),
-          facet.grid = FALSE)
+test_that(""glmer, corr"", {
+  skip_on_cran()
+  sjp.glmer(fit, type = ""fe.cor"")
+})
+
+test_that(""glmer, qq"", {
+  # qq-plot of random effects
+  skip_on_cran()
+  sjp.glmer(fit, type = ""re.qq"")
+})
+
+test_that(""glmer, ri.pc"", {
+  skip_on_cran()
+  # plot probability curves (predicted probabilities)
+  # for each covariate, grouped by random intercepts
+  sjp.glmer(fit,
+            type = ""ri.pc"",
+            show.se = TRUE)
+})
+
+test_that(""glmer, ri.pc, facet"", {
+  skip_on_cran()
+  # plot probability curves (predicted probabilities)
+  # for each covariate, grouped by random intercepts
+  # in integrated plots
+  sjp.glmer(fit,
+            type = ""ri.pc"",
+            facet.grid = FALSE)
+})
+
+test_that(""glmer, ri.pc, facet, grp emph"", {
+  skip_on_cran()
+  sjp.glmer(fit,
+            type = ""ri.pc"",
+            emph.grp = c(1, 4),
+            facet.grid = FALSE)
+})
+
+test_that(""glmer, ri.pc, facet, grp emph"", {
+  skip_on_cran()
+  sjp.glmer(fit,
+            type = ""ri.pc"",
+            emph.grp = c(""child"", ""cousin""),
+            facet.grid = FALSE)
+})
 
 test_that(""warn about groups"", {
+  skip_on_cran()
   # expect warning
   expect_warning(sjp.glmer(fit,
     type = ""ri.pc"",
     emph.grp = c(1, 4),
     facet.grid = T))
 })
 
-sjp.glmer(fit,
-          type = ""ri.pc"",
-          emph.grp = c(14, 16),
-          facet.grid = F)
+test_that(""glmer, ri.pc, facet, grp emph"", {
+  skip_on_cran()
+  expect_warning(sjp.glmer(fit,
+            type = ""ri.pc"",
+            emph.grp = c(14, 16),
+            facet.grid = F))
+})
 
-sjp.glmer(fit,
-          type = ""ri.pc"",
-          emph.grp = c(""sparse""),
-          facet.grid = F)
+test_that(""glmer, ri.pc, grp emph"", {
+  skip_on_cran()
+  expect_warning(sjp.glmer(fit,
+            type = ""ri.pc"",
+            emph.grp = c(""sparse""),
+            facet.grid = F))
+})
 
-sjp.glmer(fit,
-          type = ""ri.pc"",
-          emph.grp = c(""sparse"", ""child""),
-          facet.grid = F)
+test_that(""glmer, ri.pc, grp emph"", {
+  skip_on_cran()
+  sjp.glmer(fit,
+            type = ""ri.pc"",
+            emph.grp = c(""sparse"", ""child""),
+            facet.grid = F)
+})
 
-# plot probability curve (predicted probabilities)
-# of fixed effect, only for coefficient ""neg_c_7""
-sjp.glmer(fit,
-          type = ""fe.pc"",
-          vars = ""neg_c_7"")
+test_that(""glmer, fe.pc, single pred"", {
+  skip_on_cran()
+  # plot probability curve (predicted probabilities)
+  # of fixed effect, only for coefficient ""neg_c_7""
+  sjp.glmer(fit,
+            type = ""fe.pc"",
+            vars = ""neg_c_7"")
+})

---FILE: tests/testthat/test_sjpgrpfrq.R---
@@ -1,10 +1,12 @@
 context(""sjp.grpfrq"")
 
 test_that(""Grpd Frq"", {
+  skip_on_cran()
   sjp.grpfrq(efc$e42dep, efc$e16sex)
 })
 
 test_that(""Grpd Violin"", {
+  skip_on_cran()
   sjp.grpfrq(efc$c12hour, 
              efc$e16sex,
              interactionVar = efc$c172code,
@@ -14,6 +16,7 @@ test_that(""Grpd Violin"", {
 })
 
 test_that(""Grpd Lines"", {
+  skip_on_cran()
   sjp.grpfrq(efc$e17age, 
              efc$e16sex,
              type = ""lines"",

---FILE: tests/testthat/test_sjpint.R---
@@ -1,17 +1,22 @@
-library(sjPlot)
-fit <- lm(weight ~ Diet * Time, data = ChickWeight)
+context(""sjp.int"")
 
+fit <- lm(weight ~ Diet * Time, data = ChickWeight)
 # show summary to see significant interactions
 summary(fit)
 
-# plot regression line of interaction terms
-sjp.int(fit, type = ""eff"")
-# plot regression line of interaction terms, including value labels
-sjp.int(fit, type = ""eff"", showValueLabels = TRUE)
+test_that(""effect-plot"", {
+  skip_on_cran()
+  # plot regression line of interaction terms
+  sjp.int(fit, type = ""eff"")
+})
+
+test_that(""effect-plot"", {
+  skip_on_cran()
+  # plot regression line of interaction terms, including value labels
+  sjp.int(fit, type = ""eff"", showValueLabels = TRUE)
+})
 
 
-# load sample data set
-library(sjmisc)
 data(efc)
 # create data frame with variables that should be included
 # in the model
@@ -24,21 +29,56 @@ mydf <- data.frame(usage = efc$tot_sc_e,
 mydf$sex <- relevel(factor(mydf$sex), ref = ""2"")
 # fit ""dummy"" model
 fit <- lm(usage ~ .*., data = mydf)
-summary(fit)
 
-# plot interactions
-sjp.int(fit, type = ""cond"")
+test_that(""cond. effect-plot"", {
+  skip_on_cran()
+  # plot interactions
+  sjp.int(fit, type = ""cond"")
+})
 
-# plot interactions, using mean and sd as moderator
-# values to calculate interaction effect
-sjp.int(fit, type = ""cond"", moderatorValues = ""meansd"")
+test_that(""cond. effect-plot, mean-sd"", {
+  skip_on_cran()
+  # plot interactions, using mean and sd as moderator
+  # values to calculate interaction effect
+  sjp.int(fit, type = ""cond"", moderatorValues = ""meansd"")
+})
 
-# use zero and maximum value of moderation effect
-sjp.int(fit, type = ""cond"", moderatorValues = ""zeromax"")
+test_that(""cond. effect-plot, zeromax"", {
+  skip_on_cran()
+  # use zero and maximum value of moderation effect
+  sjp.int(fit, type = ""cond"", moderatorValues = ""zeromax"")
+})
+
+
+mydf <- data.frame(usage = efc$tot_sc_e,
+                   sex = to_factor(efc$c161sex),
+                   education = to_factor(efc$c172code),
+                   burden = efc$neg_c_7,
+                   dependency = efc$e42dep)
+# convert gender predictor to factor
+mydf$sex <- relevel(factor(mydf$sex), ref = ""2"")
+# fit ""dummy"" model
+fit <- lm(usage ~ sex * education, data = mydf)
+
+test_that(""effect-plot, mean-sd"", {
+  skip_on_cran()
+  # use zero and maximum value of moderation effect
+  sjp.int(fit, type = ""eff"", moderatorValues = ""meansd"")
+})
+
+test_that(""effect-plot, quart"", {
+  skip_on_cran()
+  # use zero and maximum value of moderation effect
+  sjp.int(fit, type = ""eff"", moderatorValues = ""quart"")
+})
+
+test_that(""cond. effect-plot, quart"", {
+  skip_on_cran()
+  # use zero and maximum value of moderation effect
+  sjp.int(fit, type = ""cond"", moderatorValues = ""quart"", plevel = 1)
+})
 
 
-library(sjmisc)
-data(efc)
 # create binary response
 y <- ifelse(efc$neg_c_7 < median(na.omit(efc$neg_c_7)), 0, 1)
 # create data frame for fitted model
@@ -49,16 +89,26 @@ mydf <- data.frame(y = as.factor(y),
 fit <- glm(y ~ sex * barthel,
            data = mydf,
            family = binomial(link = ""logit""))
-# plot interaction, increase p-level sensivity
-sjp.int(fit,
-        type = ""cond"",
-        legendLabels = get_labels(efc$c161sex),
-        plevel = 0.1)
 
-sjp.int(fit, type = ""eff"", showCI = T)
-sjp.int(fit, type = ""eff"", showCI = T, facet.grid = T)  
+test_that(""cond. effect-plot"", {
+  skip_on_cran()
+  # plot interaction, increase p-level sensivity
+  sjp.int(fit,
+          type = ""cond"",
+          legendLabels = get_labels(efc$c161sex),
+          plevel = 0.1)
+})
+
+test_that(""effect-plot, CI"", {
+  skip_on_cran()
+  sjp.int(fit, type = ""eff"", showCI = T)
+})
+
+test_that(""effect-plot, CI, facet"", {
+  skip_on_cran()
+  sjp.int(fit, type = ""eff"", showCI = T, facet.grid = T)  
+})
 
-library(sjmisc)
 data(efc)
 # create data frame with variables that should be included
 # in the model
@@ -74,59 +124,99 @@ levels(mydf$education) <- c(""low"", ""mid"", ""high"")
 mydf$burden <- set_label(mydf$burden, ""care burden"")
 # fit ""dummy"" model
 fit <- lm(burden ~ .*., data = mydf)
-summary(fit)
 
 # plot marginal means of interactions, no interaction found
-sjp.int(fit, type = ""emm"")
-# plot marginal means of interactions, including those with p-value up to 1
-sjp.int(fit, type = ""emm"", plevel = 1)
-# swap predictors
-sjp.int(fit,
-        type = ""emm"",
-        plevel = 1,
-        swapPredictors = TRUE)  
-
-sjp.int(fit,
-        type = ""emm"",
-        plevel = 1,
-        facet.grid = T,
-        showCI = TRUE,
-        swapPredictors = TRUE)  
+test_that(""emm"", {
+  skip_on_cran()
+  expect_warning(sjp.int(fit, type = ""emm""))
+})
+
+test_that(""emm"", {
+  skip_on_cran()
+  # plot marginal means of interactions, including those with p-value up to 1
+  sjp.int(fit, type = ""emm"", plevel = 1)
+})
+
+test_that(""emm"", {
+  skip_on_cran()
+  # swap predictors
+  sjp.int(fit,
+          type = ""emm"",
+          plevel = 1,
+          swapPredictors = TRUE)  
+})
+
+test_that(""emm"", {
+  skip_on_cran()
+  sjp.int(fit,
+          type = ""emm"",
+          plevel = 1,
+          facet.grid = T,
+          showCI = TRUE,
+          swapPredictors = TRUE)  
+})
 
 mydf$barthel <- efc$barthtot
 # re-fit model with continuous variable
 fit <- lm(burden ~ .*., data = mydf)
 
-# plot effects
-sjp.int(fit, type = ""eff"", showCI = TRUE)
+test_that(""eff"", {
+  skip_on_cran()
+  # plot effects
+  sjp.int(fit, type = ""eff"", showCI = TRUE)
+})
 
-# plot effects, faceted
-sjp.int(fit,
-        type = ""eff"",
-        int.plot.index = 3,
-        showCI = TRUE,
-        facet.grid = TRUE)
+test_that(""emm, plot.index"", {
+  skip_on_cran()
+  # plot effects, faceted
+  sjp.int(fit,
+          type = ""eff"",
+          int.plot.index = 3,
+          showCI = TRUE,
+          facet.grid = TRUE)
+})
 
 
-library(sjmisc)
-data(efc)
 fit <- lm(neg_c_7 ~ c12hour + barthtot + c12hour:barthtot, data = efc)
-sjp.int(fit, type = ""eff"")
-sjp.int(fit, type = ""eff"", moderatorValues = ""zeromax"")
-sjp.int(fit, type = ""eff"", moderatorValues = ""meansd"", showCI = T)
-sjp.int(fit, type = ""eff"", moderatorValues = ""meansd"", showCI = T, facet.grid = T)
 
-sjp.int(fit, type = ""eff"", moderatorValues = ""quart"", showCI = T)
-sjp.int(fit, type = ""cond"", moderatorValues = ""quart"", showCI = T)
+test_that(""effect"", {
+  skip_on_cran()
+  sjp.int(fit, type = ""eff"")
+})
+
+test_that(""effect, zeromax"", {
+  skip_on_cran()
+  sjp.int(fit, type = ""eff"", moderatorValues = ""zeromax"")
+})
+
+test_that(""effect, meansd, CI"", {
+  skip_on_cran()
+  sjp.int(fit, type = ""eff"", moderatorValues = ""meansd"", showCI = T)
+})
 
-sjp.int(fit, type = ""cond"", int.plot.index = 3, showCI = TRUE, facet.grid = TRUE)
+test_that(""effect, meansd, CI, facet"", {
+  skip_on_cran()
+  sjp.int(fit, type = ""eff"", moderatorValues = ""meansd"", showCI = T, facet.grid = T)
+})
 
+test_that(""effect, quart"", {
+  skip_on_cran()
+  sjp.int(fit, type = ""eff"", moderatorValues = ""quart"", showCI = T)
+})
+
+test_that(""cond. effect, quart, CI"", {
+  skip_on_cran()
+  sjp.int(fit, type = ""cond"", moderatorValues = ""quart"", showCI = T)
+})
+
+test_that(""cond. effect. plot index"", {
+  skip_on_cran()
+  sjp.int(fit, type = ""cond"", int.plot.index = 3, showCI = TRUE, facet.grid = TRUE)
+})
 
 
 # test mixed models
 library(lme4)
-library(sjmisc)
-data(efc)
 # create data frame with variables that should be included
 # in the model
 mydf <- data.frame(usage = efc$tot_sc_e,
@@ -139,25 +229,57 @@ mydf <- data.frame(usage = efc$tot_sc_e,
 mydf$sexf <- relevel(factor(mydf$sex), ref = ""2"")
 mydf$sexb <- mydf$sex == 2
 # fit ""dummy"" model
-fit <- lme4::lmer(usage ~ sex*burden + (1|randomeff), data = mydf)
-sjp.int(fit, type = ""cond"", plevel = 1)
-sjp.int(fit, type = ""eff"")
-fit <- lme4::lmer(usage ~ sexf*burden + (1|randomeff), data = mydf)
-sjp.int(fit, type = ""cond"", plevel = 1)
-sjp.int(fit, type = ""eff"")
+fit <- lme4::lmer(usage ~ sex*burden + (1 | randomeff), data = mydf)
+
+test_that(""cond. effect, lmer"", {
+  skip_on_cran()
+  sjp.int(fit, type = ""cond"", plevel = 1)
+})
+
+# test_that(""effect, lmer"", {
+#   skip_on_cran()
+#   sjp.int(fit, type = ""eff"")
+# })
+
+fit <- lme4::lmer(usage ~ sexf*burden + (1 | randomeff), data = mydf)
+
+test_that(""cond. effect, lmer, sex factor"", {
+  skip_on_cran()
+  sjp.int(fit, type = ""cond"", plevel = 1)
+})
+
+# test_that(""effect, lmer, sex factor"", {
+#   skip_on_cran()
+#   sjp.int(fit, type = ""eff"")
+# })
+
 # this one breaks
-fit <- lme4::lmer(usage ~ sexb * burden + (1|randomeff), data = mydf)
-sjp.int(fit, type = ""cond"", plevel = 1)
-# message(""Error incoming!"")
-# sjp.int(fit, type = ""eff"")
+fit <- lme4::lmer(usage ~ sexb * burden + (1 | randomeff), data = mydf)
+
+test_that(""cond. effect, lmer, sex boolean"", {
+  skip_on_cran()
+  sjp.int(fit, type = ""cond"", plevel = 1)
+})
+
+test_that(""effect, lmer, sex boolean"", {
+  skip_on_cran()
+  # message(""Error incoming!"")
+  expect_error(sjp.int(fit, type = ""eff""))
+})
+
 fit <- lm(usage ~ sexb * burden * education, data = mydf)
-sjp.int(fit, type = ""cond"", plevel = 1)
-# message(""Error incoming!"")
-# sjp.int(fit, type = ""eff"")
 
+test_that(""cond. effect, sex boolean"", {
+  skip_on_cran()
+  sjp.int(fit, type = ""cond"", plevel = 1)
+})
+
+test_that(""effect, sex boolean"", {
+  skip_on_cran()
+  # message(""Error incoming!"")
+  expect_error(sjp.int(fit, type = ""eff""))
+})
 
-library(sjmisc)
-data(efc)
 # create data frame with variables that should be included
 # in the model
 mydf <- data.frame(burden = efc$neg_c_7,
@@ -173,16 +295,32 @@ levels(mydf$sex) <- c(""female"", ""male"")
 levels(mydf$education) <- c(""low"", ""mid"", ""high"")
 mydf$burden <- set_label(mydf$burden, ""care burden"")
 # fit ""dummy"" model
-fit <- lme4::lmer(burden ~ sex + education + sex:education + (1|groups), data = mydf)
-fit <- lme4::lmer(burden ~ education*sex + (1|groups), data = mydf)
-summary(fit)
+fit <- lme4::lmer(burden ~ education*sex + (1 | groups), data = mydf)
+
+test_that(""emm, lmer"", {
+  skip_on_cran()
+  expect_warning(sjp.int(fit, type = ""emm""))
+})
 
-sjp.int(fit, type = ""emm"")
-sjp.int(fit, type = ""emm"", plevel = 1)
+test_that(""emm, lmer"", {
+  skip_on_cran()
+  sjp.int(fit, type = ""emm"", plevel = 1)
+})
 
 library(lmerTest)
-fit <- lmerTest::lmer(burden ~ sex + education + sex:education + (1|groups), data = mydf)
-sjp.int(fit, type = ""emm"")
-sjp.int(fit, type = ""emm"", plevel = 1)
-sjp.int(fit, type = ""emm"", plevel = 1, showCI = T)
-sjp.int(fit, type = ""emm"", plevel = 1, showCI = T, facet.grid = T)
+fit <- lmerTest::lmer(burden ~ sex + education + sex:education + (1 | groups), data = mydf)
+
+test_that(""emm, lmer"", {
+  skip_on_cran()
+  expect_warning(sjp.int(fit, type = ""emm"", plevel = 1))
+})
+
+test_that(""emm, lmer"", {
+  skip_on_cran()
+  expect_warning(sjp.int(fit, type = ""emm"", plevel = 1, showCI = T))
+})
+
+test_that(""emm, lmer"", {
+  skip_on_cran()
+  expect_warning(sjp.int(fit, type = ""emm"", plevel = 1, showCI = T, facet.grid = T))
+})

---FILE: tests/testthat/test_sjplikert.R---
@@ -1,6 +1,4 @@
-library(sjPlot)
-library(sjmisc)
-data(efc)
+context(""sjp.likert"")
 
 col_1 <- c(2,1,1,2)
 col_2 <- c(2,1,1,2)
@@ -10,8 +8,15 @@ col_5 <- c(2,1,1,2)
 
 df <- as.data.frame(cbind(col_1,col_2,col_3,col_4,col_5))
 
-sjp.likert(df, cat.neutral = 5, catcount = 4)
-sjp.likert(df, cat.neutral = 3, catcount = 4)
+test_that(""likert"", {
+  skip_on_cran()
+  expect_warning(sjp.likert(df, cat.neutral = 5, catcount = 4))
+})
+
+test_that(""likert"", {
+  skip_on_cran()
+  expect_warning(sjp.likert(df, cat.neutral = 3, catcount = 4))
+})
 
 col_1 <- c(2,1,1,2)
 col_2 <- c(2,1,1,2)
@@ -21,8 +26,16 @@ col_5 <- c(2,1,1,2)
 
 df <- as.data.frame(cbind(col_1,col_2,col_3,col_4,col_5))
 
-sjp.likert(df, cat.neutral = 5)
-sjp.likert(df, cat.neutral = 5, catcount = 4)
+test_that(""likert"", {
+  skip_on_cran()
+  expect_error(sjp.likert(df, cat.neutral = 5))
+})
+
+test_that(""likert"", {
+  skip_on_cran()
+  sjp.likert(df, cat.neutral = 5, catcount = 4)
+})
+
 
 col_1 <- c(2,1,1,2)
 col_2 <- c(2,1,1,2)
@@ -32,8 +45,15 @@ col_5 <- c(2,1,1,2)
 
 df <- as.data.frame(cbind(col_1,col_2,col_3,col_4,col_5))
 
-sjp.likert(df)
-sjp.likert(df, catcount = 4)
+test_that(""likert"", {
+  skip_on_cran()
+  expect_warning(sjp.likert(df))
+})
+
+test_that(""likert"", {
+  skip_on_cran()
+  sjp.likert(df, catcount = 4)
+})
 
 col_1 <- c(2,1,1,2)
 col_2 <- c(2,1,3,2)
@@ -43,5 +63,12 @@ col_5 <- c(2,3,1,2)
 
 df <- as.data.frame(cbind(col_1,col_2,col_3,col_4,col_5))
 
-sjp.likert(df)
-sjp.likert(df, catcount = 4)
+test_that(""likert"", {
+  skip_on_cran()
+  expect_warning(sjp.likert(df))
+})
+
+test_that(""likert"", {
+  skip_on_cran()
+  expect_warning(sjp.likert(df, catcount = 4))
+})

---FILE: tests/testthat/test_sjplmer.R---
@@ -1,31 +1,43 @@
-library(sjPlot)
-library(lme4)
-library(sjmisc)
+context(""sjp.lmer"")
+
 fit <- lme4::lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
 
 # simple plot
-sjp.lmer(fit)
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit)
+})
 
 # plot fixed effects
-sjp.lmer(fit, type = ""fe"")
+test_that(""lmer, fe"", {
+  skip_on_cran()
+  sjp.lmer(fit, type = ""fe"")
+})
 
-# sort by predictor Days
-sjp.lmer(fit, sort.coef = ""Days"")
+test_that(""lmer, sort re"", {
+  skip_on_cran()
+  # sort by predictor Days
+  sjp.lmer(fit, sort.coef = ""Days"")
+})
 
 # plot each predictor as own plot
 # sort each plot
-sjp.lmer(fit,
+test_that(""lmer, sort all"", {
+  skip_on_cran()
+  sjp.lmer(fit,
          facet.grid = FALSE,
          sort.coef = ""sort.all"")
+})
 
 # plot and sort fixed effects
-sjp.lmer(fit,
+test_that(""lmer, sort fe"", {
+  skip_on_cran()
+  sjp.lmer(fit,
          type = ""fe"",
          sort.coef = TRUE)
+})
 
 
-library(lme4)
-library(sjmisc)
 data(efc)
 # prepare group variable
 efc$grp = as.factor(efc$e15relat)
@@ -37,88 +49,243 @@ mydf <- data.frame(neg_c_7 = as.numeric(efc$neg_c_7),
                    barthel = as.numeric(efc$barthtot),
                    grp = efc$grp)
 # fit glmer
-fit <- lme4::lmer(neg_c_7 ~ sex + c12hour + barthel + (1|grp),
+fit <- lme4::lmer(neg_c_7 ~ sex + c12hour + barthel + (1 | grp),
             data = mydf)
 
 # plot random effects
-sjp.lmer(fit)
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit)
+})
 
 # plot fixed effects
-sjp.lmer(fit, type = ""fe"")
+test_that(""lmer, fe"", {
+  skip_on_cran()
+  sjp.lmer(fit, type = ""fe"")
+})
 
-sjp.lmer(fit,
+test_that(""lmer, std. fe"", {
+  skip_on_cran()
+  sjp.lmer(fit,
          type = ""fe.std"",
          sort.coef = TRUE)
+})
 
 # plot fixed effects slopes for
 # each random intercept, but only for
 # coefficient ""c12hour""
-sjp.lmer(fit,
+test_that(""lmer, fe.ri, vars"", {
+  skip_on_cran()
+  sjp.lmer(fit,
          type = ""fe.ri"",
          vars = ""c12hour"")
+})
 
-sjp.lmer(fit,
+test_that(""lmer, fe.ri, emph grp, vars"", {
+  skip_on_cran()
+  expect_message(sjp.lmer(fit,
          type = ""fe.ri"",
          emph.grp = c(1, 2, 4),
-         vars = ""c12hour"")
+         vars = ""c12hour""))
+})
+
+test_that(""lmer, fe.ri, emph grp, vars"", {
+  skip_on_cran()
+  sjp.lmer(fit,
+          type = ""fe.ri"",
+          emph.grp = c(1, 2, 4),
+          vars = ""c12hour"",
+          facet.grid = F)
+})
 
 # plot fixed effects correlations
-sjp.lmer(fit, type = ""fe.cor"")
+test_that(""lmer, corr"", {
+  skip_on_cran()
+  expect_warning(sjp.lmer(fit, type = ""fe.cor""))
+})
 
 # qq-plot of random effects
-sjp.lmer(fit, type = ""re.qq"")
+test_that(""lmer, fe.ri, emph grp, vars"", {
+  skip_on_cran()
+  sjp.lmer(fit, type = ""re.qq"")
+})
 
 
 lmm.data <- read.table(""http://www.unt.edu/rss/class/Jon/R_SC/Module9/lmm.data.txt"", 
                        header = TRUE, sep = "","", na.strings = ""NA"", dec = ""."", strip.white = TRUE)
 
 fit <- lme4::lmer(extro ~ open + agree + social + (1 | school), data = lmm.data)
-sjp.lmer(fit)
-sjp.lmer(fit, ri.nr = c(1,5))
-# WARNING!
-sjp.lmer(fit, ri.nr = c(3,5))
-sjp.lmer(fit, type = ""fe"")
-sjp.lmer(fit, type = ""fe.ri"")
-sjp.lmer(fit, type = ""fe.pred"")
+
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit)
+})
+
+test_that(""lmer, ri.nr"", {
+  skip_on_cran()
+  expect_message(sjp.lmer(fit, ri.nr = c(1,5)))
+})
+
+test_that(""lmer, ri.nr"", {
+  skip_on_cran()
+  # WARNING!
+  expect_warning(sjp.lmer(fit, ri.nr = c(3,5)))
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit, type = ""fe"")
+})
+
+test_that(""lmer, fe.ri"", {
+  skip_on_cran()
+  sjp.lmer(fit, type = ""fe.ri"")
+})
+
+test_that(""lmer, fe.pred"", {
+  skip_on_cran()
+  sjp.lmer(fit, type = ""fe.pred"")
+})
 
 
 fit <- lme4::lmer(extro ~ open + agree + social + (1 | school) + (1 | class), 
                   data = lmm.data)
 
-sjp.lmer(fit)
-sjp.lmer(fit, ri.nr = 2)
-sjp.lmer(fit, ri.nr = c(1,5))
-# WARNING!
-sjp.lmer(fit, ri.nr = c(3,5))
-sjp.lmer(fit, type = ""fe.ri"")
-sjp.lmer(fit, type = ""fe.ri"", ri.nr = 2)
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit)
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit, ri.nr = 2)
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  expect_message(sjp.lmer(fit, ri.nr = c(1,5)))
+})
+
+test_that(""lmer, ri.nr"", {
+  skip_on_cran()
+  # WARNING!
+  expect_warning(sjp.lmer(fit, ri.nr = c(3,5)))
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit, type = ""fe.ri"")
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit, type = ""fe.ri"", ri.nr = 2)
+})
 
 fit <- lme4::lmer(extro ~ open + agree + social + (1 | school/class), data = lmm.data)
 
-sjp.lmer(fit)
-sjp.lmer(fit, ri.nr = 2)
-sjp.lmer(fit, ri.nr = c(1,5))
-# WARNING
-sjp.lmer(fit, ri.nr = c(3,5))
-sjp.lmer(fit, type = ""fe"")
-sjp.lmer(fit, type = ""fe.ri"")
-sjp.lmer(fit, type = ""fe.ri"", ri.nr = 2)
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit)
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit, ri.nr = 2)
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  expect_message(sjp.lmer(fit, ri.nr = c(1,5)))
+})
 
-sjp.lmer(fit, type = ""fe.std"")
-sjp.lmer(fit, type = ""re.qq"")
+test_that(""lmer"", {
+  skip_on_cran()
+  # WARNING
+  expect_warning(sjp.lmer(fit, ri.nr = c(3,5)))
+  sjp.lmer(fit, type = ""fe"")
+})
+
+
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit, type = ""fe.ri"")
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit, type = ""fe.ri"", ri.nr = 2)
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit, type = ""fe.std"")
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit, type = ""re.qq"")
+})
 
 fit <- lme4::lmer(extro ~ open + agree + social + (1 + open | school/class), 
                   data = lmm.data)
 
-sjp.lmer(fit)
-sjp.lmer(fit, ri.nr = 2)
-sjp.lmer(fit, ri.nr = c(1,5))
-# WARNING
-sjp.lmer(fit, ri.nr = c(3,5))
-sjp.lmer(fit, type = ""fe"")
-sjp.lmer(fit, type = ""fe.ri"")
-sjp.lmer(fit, type = ""fe.ri"", emph.grp = c(3, 5))
-sjp.lmer(fit, type = ""fe.ri"", ri.nr = 2)
-sjp.lmer(fit, type = ""fe.ri"", ri.nr = 2, emph.grp = c(3, 5))
-
-sjp.lmer(fit, type = ""re.qq"")
+test_that(""lmer"", {
+  skip_on_cran()
+  expect_warning(sjp.lmer(fit))
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  expect_warning(sjp.lmer(fit, ri.nr = 2))
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  expect_warning(sjp.lmer(fit, ri.nr = c(1,5)))
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  expect_warning(sjp.lmer(fit, ri.nr = c(3,5)))
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit, type = ""fe"")
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit, type = ""fe.ri"")
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  expect_message(sjp.lmer(fit, type = ""fe.ri"", emph.grp = c(3, 5)))
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit, type = ""fe.ri"", emph.grp = c(3, 5), facet.grid = F)
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit, type = ""fe.ri"", ri.nr = 2)
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  expect_message(sjp.lmer(fit, type = ""fe.ri"", ri.nr = 2, emph.grp = c(3, 5)))
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit, type = ""fe.ri"", ri.nr = 2, emph.grp = c(3, 5), facet.grid = F)
+})
+
+test_that(""lmer"", {
+  skip_on_cran()
+  sjp.lmer(fit, type = ""re.qq"")
+})

---FILE: tests/testthat/test_sjtglm.R---
@@ -1,4 +1,4 @@
-library(sjPlot)
+context(""sjt.glm"")
 
 CSS = list(css.table = '+border-collapse:separate;',
            css.tdata = 'border: 1px solid red;',
@@ -13,67 +13,68 @@ y3 <- ifelse(swiss$Agriculture < median(swiss$Agriculture), 0, 1)
 
 # Now fit the models. Note that both models share the same predictors
 # and only differ in their dependent variable (y1, y2 and y3)
-fitOR1 <- glm(y1 ~ swiss$Education + swiss$Examination+swiss$Catholic,
+fitOR1 <- glm(y1 ~ swiss$Education + swiss$Examination + swiss$Catholic,
               family = binomial(link = ""logit""))
-fitOR2 <- glm(y2 ~ swiss$Education + swiss$Examination+swiss$Catholic,
+fitOR2 <- glm(y2 ~ swiss$Education + swiss$Examination + swiss$Catholic,
               family = binomial(link = ""logit""))
-fitOR3 <- glm(y3 ~ swiss$Education + swiss$Examination+swiss$Catholic,
+fitOR3 <- glm(y3 ~ swiss$Education + swiss$Examination + swiss$Catholic,
               family = binomial(link = ""logit""))
 
-# open HTML-table in RStudio Viewer Pane or web browser
-## Not run: 
-sjt.glm(fitOR1,
-        fitOR2,
-        CSS = CSS,
-        useViewer = F,
-        labelDependentVariables = c(""Fertility"",
-                                    ""Infant Mortality""),
-        labelPredictors = c(""Education"",
-                            ""Examination"",
-                            ""Catholic""))
-
-# open HTML-table in RStudio Viewer Pane or web browser,
-# integrate CI in OR column
-sjt.glm(fitOR1, fitOR2, fitOR3,
-        useViewer = F,
-        CSS = CSS,
-        labelDependentVariables = c(""Fertility"",
-                                    ""Infant Mortality"",
-                                    ""Agriculture""),
-        labelPredictors = c(""Education"", ""Examination"", ""Catholic""),
-        separateConfColumn = FALSE)
-
-# open HTML-table in RStudio Viewer Pane or web browser,
-# indicating p-values as numbers and printing CI in a separate column
-sjt.glm(fitOR1, fitOR2, fitOR3,
-        CSS = CSS,
-        useViewer = F,
-        labelDependentVariables = c(""Fertility"",
-                                    ""Infant Mortality"",
-                                    ""Agriculture""),
-        labelPredictors = c(""Education"", ""Examination"", ""Catholic""))
+test_that(""sjt.glm"", {
+  skip_on_cran()
+  sjt.glm(fitOR1,
+          fitOR2,
+          CSS = CSS,
+          useViewer = F,
+          labelDependentVariables = c(""Fertility"",
+                                      ""Infant Mortality""),
+          labelPredictors = c(""Education"",
+                              ""Examination"",
+                              ""Catholic""))
+})
+
+test_that(""sjt.glm"", {
+  skip_on_cran()
+  sjt.glm(fitOR1, fitOR2, fitOR3,
+          useViewer = F,
+          CSS = CSS,
+          labelDependentVariables = c(""Fertility"",
+                                      ""Infant Mortality"",
+                                      ""Agriculture""),
+          labelPredictors = c(""Education"", ""Examination"", ""Catholic""),
+          separateConfColumn = FALSE)
+})
+
+test_that(""sjt.glm"", {
+  skip_on_cran()
+  sjt.glm(fitOR1, fitOR2, fitOR3,
+          CSS = CSS,
+          useViewer = F,
+          labelDependentVariables = c(""Fertility"",
+                                      ""Infant Mortality"",
+                                      ""Agriculture""),
+          labelPredictors = c(""Education"", ""Examination"", ""Catholic""))
+})
 
 
 # --------------------------------------------
 # User defined style sheet
 # --------------------------------------------
-sjt.glm(fitOR1, fitOR2, fitOR3,
-        labelDependentVariables = c(""Fertility"",
-                                    ""Infant Mortality"",
-                                    ""Agriculture""),
-        labelPredictors = c(""Education"", ""Examination"", ""Catholic""),
-        showHeaderStrings = TRUE,
-        useViewer = F,
-        CSS = list(css.table = ""border: 2px solid;"",
-                   css.tdata = ""border: 1px solid;"",
-                   css.depvarhead = ""color:#003399;""))
+test_that(""sjt.glm"", {
+  skip_on_cran()
+  sjt.glm(fitOR1, fitOR2, fitOR3,
+          labelDependentVariables = c(""Fertility"",
+                                      ""Infant Mortality"",
+                                      ""Agriculture""),
+          labelPredictors = c(""Education"", ""Examination"", ""Catholic""),
+          showHeaderStrings = TRUE,
+          useViewer = F,
+          CSS = list(css.table = ""border: 2px solid;"",
+                     css.tdata = ""border: 1px solid;"",
+                     css.depvarhead = ""color:#003399;""))
+})
 
 
-# --------------------------------------------
-# Compare models with different link functions,
-# but same predictors and response
-# --------------------------------------------
-library(sjmisc)
 # load efc sample data
 data(efc)
 # dichtomozize service usage by ""service usage yes/no""
@@ -90,45 +91,52 @@ fit3 <- glm(services ~ neg_c_7 + c161sex + e42dep,
             family = poisson(link = ""log""))
 
 # compare models
-sjt.glm(fit1, fit2, fit3,
+test_that(""sjt.glm"", {
+  skip_on_cran()
+  sjt.glm(fit1, fit2, fit3,
         CSS = CSS,
         useViewer = F,
         showAIC = TRUE,
         showFamily = TRUE,
         showPseudoR = FALSE)
+})
 
 
 # --------------------------------------------
 # Change style of p-values and CI-appearance
 # --------------------------------------------
 # open HTML-table in RStudio Viewer Pane or web browser,
 # table indicating p-values as stars
-sjt.glm(fit1, fit2, fit3,
+test_that(""sjt.glm"", {
+  skip_on_cran()
+  sjt.glm(fit1, fit2, fit3,
         CSS = CSS,
         useViewer = F,
         pvaluesAsNumbers = FALSE,
         showAIC = TRUE,
         showFamily = TRUE,
         showPseudoR = FALSE)
+})
 
 # open HTML-table in RStudio Viewer Pane or web browser,
 # indicating p-values as stars and integrate CI in OR column
-sjt.glm(fit1, fit2, fit3,
+test_that(""sjt.glm"", {
+  skip_on_cran()
+  sjt.glm(fit1, fit2, fit3,
         CSS = CSS,
         useViewer = F,
         pvaluesAsNumbers = FALSE,
         separateConfColumn = FALSE,
         showAIC = TRUE,
         showFamily = TRUE,
         showPseudoR = FALSE)
+})
 
 # ----------------------------------
 # automatic grouping of predictors
 # ----------------------------------
 # load efc sample data
 data(efc)
-# set variable labels
-efc <- set_label(efc, get_label(efc))
 # dichtomozize service usage by ""service usage yes/no""
 efc$services <- sjmisc::dicho(efc$tot_sc_e, ""v"", 0, as.num = TRUE)
 # make dependency categorical
@@ -137,10 +145,12 @@ efc$e42dep <- to_factor(efc$e42dep)
 fit <- glm(services ~ neg_c_7 + c161sex + e42dep, data = efc)
 
 # automatic grouping of categorical predictors
-sjt.glm(fit,
+test_that(""sjt.glm"", {
+  skip_on_cran()
+  sjt.glm(fit,
         CSS = CSS,
         useViewer = F)
-
+})
 
 # ----------------------------------
 # compare models with different predictors
@@ -149,15 +159,21 @@ fit2 <- glm(services ~ neg_c_7 + c161sex + e42dep + c12hour, data = efc)
 fit3 <- glm(services ~ neg_c_7 + c161sex + e42dep + c12hour + c172code, data = efc)
 
 # print models with different predictors
-sjt.glm(fit, fit2, fit3,
+test_that(""sjt.glm"", {
+  skip_on_cran()
+  sjt.glm(fit, fit2, fit3,
         CSS = CSS,
         useViewer = F)
+})
 
 efc$c172code <- to_factor(efc$c172code)
 fit2 <- glm(services ~ neg_c_7 + c161sex + c12hour, data = efc)
 fit3 <- glm(services ~ neg_c_7 + c161sex + c172code, data = efc)
 
 # print models with different predictors
-sjt.glm(fit, fit2, fit3, group.pred = FALSE,
+test_that(""sjt.glm"", {
+  skip_on_cran()
+  sjt.glm(fit, fit2, fit3, group.pred = FALSE,
         CSS = CSS,
         useViewer = F)
+})

---FILE: tests/testthat/test_sjtlm.R---
@@ -1,13 +1,10 @@
-library(sjPlot)
-library(sjmisc)
+context(""sjt.lm"")
 # sample data
 data(efc)
-# set variable labels
-efc <- set_label(efc, get_label(efc))
 # fit first model
-fit1 <- lm(barthtot ~ c160age + c12hour + c161sex + c172code, data=efc)
+fit1 <- lm(barthtot ~ c160age + c12hour + c161sex + c172code, data = efc)
 # fit second model
-fit2 <- lm(neg_c_7 ~ c160age + c12hour + c161sex + c172code, data=efc)
+fit2 <- lm(neg_c_7 ~ c160age + c12hour + c161sex + c172code, data = efc)
 # Note that both models share the same predictors and only differ 
 # in their dependent variable. See examples of stepwise models 
 # later...
@@ -18,11 +15,24 @@ CSS = list(css.table = '+border-collapse:separate;',
            css.grouprow = 'border: 1px solid blue;',
            css.separatorcol = 'border: 1px solid green;')
 
-sjt.lm(fit1, fit2, CSS = CSS, useViewer = F)
-sjt.lm(fit1, fit2, showHeaderStrings = T, CSS = CSS, useViewer = F)
-sjt.lm(fit1, fit2, pvaluesAsNumbers = F, CSS = CSS, useViewer = F)
+test_that(""sjt.lm"", {
+  skip_on_cran()
+  sjt.lm(fit1, fit2, CSS = CSS, useViewer = F)
+})
 
-sjt.lm(fit1, fit2, 
+test_that(""sjt.lm"", {
+  skip_on_cran()
+  sjt.lm(fit1, fit2, showHeaderStrings = T, CSS = CSS, useViewer = F)
+})
+
+test_that(""sjt.lm"", {
+  skip_on_cran()
+  sjt.lm(fit1, fit2, pvaluesAsNumbers = F, CSS = CSS, useViewer = F)
+})
+
+test_that(""sjt.lm"", {
+  skip_on_cran()
+  sjt.lm(fit1, fit2, 
        showEst = F,
        showR2 = T,
        showAIC = T,
@@ -32,8 +42,11 @@ sjt.lm(fit1, fit2,
        showHeaderStrings = T, 
        useViewer = F,
        CSS = CSS)
+})
 
-sjt.lm(fit1, fit2, 
+test_that(""sjt.lm"", {
+  skip_on_cran()
+  sjt.lm(fit1, fit2, 
        showEst = F,
        showR2 = T,
        showAIC = T,
@@ -44,8 +57,11 @@ sjt.lm(fit1, fit2,
        pvaluesAsNumbers = F,
        useViewer = F,
        CSS = CSS)
+})
 
-sjt.lm(fit1, fit2, 
+test_that(""sjt.lm"", {
+  skip_on_cran()
+  sjt.lm(fit1, fit2, 
        showEst = F,
        showR2 = T,
        showAIC = T,
@@ -56,8 +72,11 @@ sjt.lm(fit1, fit2,
        pvaluesAsNumbers = F,
        useViewer = F,
        CSS = CSS)
+})
 
-sjt.lm(fit1, fit2, 
+test_that(""sjt.lm"", {
+  skip_on_cran()
+  sjt.lm(fit1, fit2, 
        showEst = F,
        showR2 = T,
        showAIC = T,
@@ -68,8 +87,11 @@ sjt.lm(fit1, fit2,
        pvaluesAsNumbers = F,
        useViewer = F,
        CSS = CSS)
+})
 
-sjt.lm(fit1, fit2, 
+test_that(""sjt.lm"", {
+  skip_on_cran()
+  sjt.lm(fit1, fit2, 
        showEst = F,
        showR2 = T,
        showAIC = T,
@@ -80,15 +102,21 @@ sjt.lm(fit1, fit2,
        pvaluesAsNumbers = F,
        useViewer = F,
        CSS = CSS)
+})
 
-sjt.lm(fit1,
+test_that(""sjt.lm"", {
+  skip_on_cran()
+  sjt.lm(fit1,
        fit2,
        useViewer = F,
        CSS = CSS,
        labelDependentVariables = c(""Barthel-Index"",
                                    ""Negative Impact""))  
+})
 
-sjt.lm(fit1,
+test_that(""sjt.lm"", {
+  skip_on_cran()
+  sjt.lm(fit1,
        fit2,
        showHeaderStrings = TRUE,
        useViewer = F,
@@ -101,72 +129,87 @@ sjt.lm(fit1,
        stringIntercept = ""Konstante"",
        labelDependentVariables = c(""Barthel-Index"",
                                    ""Negative Impact""))  
+})
 
-sjt.lm(fit1, fit2,
+test_that(""sjt.lm"", {
+  skip_on_cran()
+  sjt.lm(fit1, fit2,
        useViewer = F,
        CSS = CSS,
        separateConfColumn = FALSE, # ci in same cell as estimates
        showStdBeta = TRUE,         # also show standardized beta values
        pvaluesAsNumbers = FALSE)   # ""*"" instead of numeric values  
+})
 
-sjt.lm(fit1, fit2,
+test_that(""sjt.lm"", {
+  skip_on_cran()
+  sjt.lm(fit1, fit2,
        useViewer = F,
        CSS = CSS,
        labelPredictors = c(""Carer's Age"",
                            ""Hours of Care"",
                            ""Carer's Sex"",
                            ""Educational Status""))  
+})
 
 # fit first model
-fit1 <- lm(neg_c_7 ~ c160age + c172code + c161sex, data=efc)
+fit1 <- lm(neg_c_7 ~ c160age + c172code + c161sex, data = efc)
 # fit second model
-fit2 <- lm(neg_c_7 ~ c160age + c172code + c161sex + c12hour, data=efc)
+fit2 <- lm(neg_c_7 ~ c160age + c172code + c161sex + c12hour, data = efc)
 # fit second model
-fit3 <- lm(neg_c_7 ~ c160age + c172code + e42dep + tot_sc_e, data=efc)
+fit3 <- lm(neg_c_7 ~ c160age + c172code + e42dep + tot_sc_e, data = efc)
 
-sjt.lm(fit1, fit2, fit3, 
+test_that(""sjt.lm"", {
+  skip_on_cran()
+  sjt.lm(fit1, fit2, fit3, 
        useViewer = F,
        CSS = CSS,
        separateConfColumn = FALSE,
        showAIC = TRUE,
        showFStat = TRUE) 
+})
 
 # make education categorical
 efc$c172code <- to_factor(efc$c172code)
 # make dependency categorical
 efc$e42dep <- to_factor(efc$e42dep)
 # fit first model again (with c172code as factor)
-fit1 <- lm(barthtot ~ c160age + c12hour + c172code + c161sex + e42dep, data=efc)
+fit1 <- lm(barthtot ~ c160age + c12hour + c172code + c161sex + e42dep, data = efc)
 # fit second model again (with c172code as factor)
-fit2 <- lm(neg_c_7 ~ c160age + c12hour + c172code + c161sex + e42dep, data=efc)  
+fit2 <- lm(neg_c_7 ~ c160age + c12hour + c172code + c161sex + e42dep, data = efc)  
 
-sjt.lm(fit1, fit2, 
+test_that(""sjt.lm"", {
+  skip_on_cran()
+  sjt.lm(fit1, fit2, 
        useViewer = F,
        CSS = CSS)
+})
        
 data(efc)
-# attach variable labels to each variable of the data
-# frame - useful for automatic label detection
-efc <- set_label(efc, get_label(efc))
 # make education categorical
-efc$c172code <- to_factor(efc$c172code)
+efc$c172code <- suppressMessages(to_factor(efc$c172code))
 # make education categorical
-efc$e42dep <- to_factor(efc$e42dep)
+efc$e42dep <- suppressMessages(to_factor(efc$e42dep))
 # make prettier variable labels
 efc$c172code <- set_label(efc$c172code, ""Education"")
 efc$e42dep <- set_label(efc$e42dep, ""Dependency"")
 # fit first model
-fit1 <- lm(neg_c_7 ~ c160age + c172code + c161sex, data=efc)
+fit1 <- lm(neg_c_7 ~ c160age + c172code + c161sex, data = efc)
 # fit second model
-fit2 <- lm(neg_c_7 ~ c160age + c172code + c161sex + c12hour, data=efc)
+fit2 <- lm(neg_c_7 ~ c160age + c172code + c161sex + c12hour, data = efc)
 # fit third model
-fit3 <- lm(neg_c_7 ~ c160age + c172code + e42dep + tot_sc_e, data=efc)
+fit3 <- lm(neg_c_7 ~ c160age + c172code + e42dep + tot_sc_e, data = efc)
 
-sjt.lm(fit1, fit2, fit3,
+test_that(""sjt.lm"", {
+  skip_on_cran()
+  sjt.lm(fit1, fit2, fit3,
        useViewer = F,
        CSS = CSS)
+})
 
-sjt.lm(fit1, fit2, fit3,
+test_that(""sjt.lm"", {
+  skip_on_cran()
+  sjt.lm(fit1, fit2, fit3,
        useViewer = F,
        CSS = CSS,
        labelPredictors = c(""mid education"", 
@@ -177,10 +220,14 @@ sjt.lm(fit1, fit2, fit3,
                            ""severe dependency"", 
                            ""Service Usage""),         
        remove.estimates = c(""c160age"", ""c161sex""))  
+})
 
-sjt.lm(fit1, fit2, fit3,
+test_that(""sjt.lm"", {
+  skip_on_cran()
+  sjt.lm(fit1, fit2, fit3,
        showHeaderStrings = T,
        useViewer = F,
        showStdError = T,
        CSS = CSS,
        remove.estimates = c(2,5,6,10))  
+})

---FILE: tests/testthat/test_sjtxtab.R---
@@ -1,10 +1,12 @@
 context(""sjt.xtab"")
 
 test_that(""Simple xtab"", {
+  skip_on_cran()
   sjt.xtab(efc$e42dep, efc$e16sex)
 })
 
 test_that(""xtab"", {
+  skip_on_cran()
   sjt.xtab(efc$e42dep, 
            efc$e16sex,
            digits = 2,
@@ -17,13 +19,16 @@ test_that(""xtab"", {
 })
 
 test_that(""xtab"", {
+  skip_on_cran()
   sjt.xtab(efc$e42dep, 
            efc$e16sex,
            showHorizontalLine = T)
 })
 
+efc.labels <- get_labels(efc)
+
 test_that(""Manual labels"", {
-  efc.labels <- get_labels(efc)
+  skip_on_cran()
   # print cross table with manually set
   # labels and expected values
   sjt.xtab(efc$e16sex, 
@@ -32,23 +37,64 @@ test_that(""Manual labels"", {
                               ""Elder's dependency""),
            valueLabels = list(efc.labels[['e16sex']], 
                               efc.labels[['e42dep']]),
-           showExpected = TRUE)
+           showExpected = TRUE,
+           useViewer = F)
 })
 
 test_that(""xtab"", {
+  skip_on_cran()
+  # print minimal cross table with labels, total col/row highlighted
+  sjt.xtab(efc$e16sex, efc$e42dep, 
+           variableLabels = c(""Gender"", ""Dependency""),
+           valueLabels = list(c(""m"", ""w""),
+                              c(""none"", ""slight"", ""moderate"", ""severe"")),
+           CSS = list(css.table = ""border: 1px solid green"",
+                      css.thead = ""border: 1px solid red"",
+                      css.tdata = ""border: 1px dotted blue"",
+                      css.secondtablerow = ""background-color: #cccccc"",
+                      css.lasttablerow = ""background-color: #ffaaaa""),
+           useViewer = F)
+})
+
+test_that(""xtab"", {
+  skip_on_cran()
+  # print minimal cross table with labels, total col/row highlighted
+  sjt.xtab(efc$e16sex, efc$e42dep, 
+           variableLabels = c(""Gender"", ""Dependency""),
+           valueLabels = list(c(""m"", ""w""),
+                              c(""none"", ""slight"", ""moderate"", ""severe"")),
+           showCellPerc = T,
+           showExpected = T,
+           showColPerc = T,
+           showRowPerc = T,
+           showSummary = T,
+           CSS = list(css.table = ""border: 1px solid green"",
+                      css.thead = ""border: 1px solid red"",
+                      css.tdata = ""border: 1px dotted blue"",
+                      css.secondtablerow = ""background-color: #cccccc"",
+                      css.lasttablerow = ""background-color: #ffaaaa""),
+           useViewer = F)
+})
+
+test_that(""xtab"", {
+  skip_on_cran()
   # print minimal cross table with labels, total col/row highlighted
   sjt.xtab(efc$e16sex, efc$e42dep, 
            showHorizontalLine = FALSE,
            showCellPerc = FALSE,
-           highlightTotal = TRUE)
+           highlightTotal = TRUE,
+           useViewer = F)
 })
 
+
 test_that(""xtab"", {
+  skip_on_cran()
   # ---------------------------------------------------------------- 
   # User defined style sheet
   # ---------------------------------------------------------------- 
   sjt.xtab(efc$e16sex, efc$e42dep, 
            CSS = list(css.table = ""border: 2px solid;"",
                       css.tdata = ""border: 1px solid;"",
-                      css.horline = ""border-bottom: double blue;""))
+                      css.horline = ""border-bottom: double blue;""),
+           useViewer = F)
 })
\ No newline at end of file"
strengejacke,sjPlot,327ce0316428f21a13b4e50e68fd18d850890dcf,Daniel Ldecke,d.luedecke@uke.de,2016-02-03T18:32:41Z,Daniel Ldecke,d.luedecke@uke.de,2016-02-03T18:32:41Z,"minor fixes, more options for `sjp.scatter`",DESCRIPTION;NEWS;R/sjPlotCorr.R;R/sjPlotFrequencies.R;R/sjPlotGroupPropTable.R;R/sjPlotScatter.R;README.md;man/sjPlot-package.Rd;man/sjp.gpt.Rd;man/sjp.scatter.Rd,False,True,True,False,70,36,106,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.9.0-2
-Date: 2016-02-01
+Version: 1.9.0-3
+Date: 2016-02-03
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of plotting and table output functions for data
@@ -38,6 +38,7 @@ Suggests:
     AICcmodavg,
     arm,
     cluster,
+    ggrepel,
     lmerTest,
     lmtest,
     lsmeans

---FILE: NEWS---
@@ -1,4 +1,4 @@
-Version 1.9.0-1
+Version 1.9.0-3
 -----------------------------------------------------------------------------
 Changes to functions:
 * Improved text label positioning for plotting functions.
@@ -8,6 +8,8 @@ Changes to functions:
 * `sjp.glmer` and `sjp.lmer` get a `axisLimits.y` argument to specify y-axis limits specifically for predicted probability or effect plots.
 * `view_df` now supports showing missings and missing percentages.
 * Harmonized column names of returned data frames to match `broom`s naming convention for `sjp.lm`, `sjp.glm`, `sjp.lmer`, `sjp.glmer`, `sjp.lmm`, `sjp.glmm`, `sjp.aov1` and `sjp.int`.
+* `sjp.scatter` gets a `useCount` argument to indicate overplotting by point size.
+* `sjp.scatter` now also plots data points when using argument `pointLabels`, so exact position of labelled data points is visible. `geom_text_repel` is used to avoid overlapping of points and labels.
 
 Bug fixes:
 * Automatic label detection did not choose column names when no variable labels were present for functions that accepted data frames as data argument.

---FILE: R/sjPlotCorr.R---
@@ -318,7 +318,7 @@ sjp.corr <- function(data,
   # --------------------------------------------------------
   if (type == ""circle"") {
     corrPlot <- corrPlot +
-      geom_point(shape = 21, size = orderedCorr$psize, color = ""black"")
+      geom_point(shape = 21, size = orderedCorr$psize, colour = ""black"")
   }
   # --------------------------------------------------------
   # or boxes / tiles when ""type"" is ""tile""

---FILE: R/sjPlotFrequencies.R---
@@ -310,7 +310,7 @@ sjp.frq <- function(varCount,
     if (type == ""bars"") 
       geom.size <- .7
     else if (type == ""dots"") 
-      geom.size <- 3
+      geom.size <- 2.5
     else if (type == ""histogram"") 
       geom.size <- .7
     else if (type == ""line"") 
@@ -562,7 +562,7 @@ sjp.frq <- function(varCount,
                        width = geom.size, 
                        fill = geom.colors)
     } else if (type == ""dots"") {
-      geob <- geom_point(size = geom.size, fill = geom.colors)
+      geob <- geom_point(size = geom.size, colour = geom.colors)
     }
     # -----------------------------------
     # mydat is a data frame that only contains one variable (var).

---FILE: R/sjPlotGroupPropTable.R---
@@ -61,7 +61,7 @@ sjp.gpt <- function(x,
                     y,
                     groups,
                     geom.colors = ""Set1"",
-                    geom.size = 4,
+                    geom.size = 2.5,
                     shape.fill.color = ""#f0f0f0"",
                     shapes = c(15, 16, 17, 18, 21, 22, 23, 24, 25, 7, 8, 9, 10, 12),
                     title = NULL,

---FILE: R/sjPlotScatter.R---
@@ -16,11 +16,12 @@
 #' @param grp grouping variable. If not \code{NULL}, the scatter plot will be grouped. See
 #'          'Examples'. Default is \code{NULL}, i.e. not grouping is done.
 #' @param pointLabels character vector with names for each coordinate pair given
-#'          by \code{x} and \code{y}, so instead of dots, text labels are
-#'          printed to the plot. Must be of same length as \code{x} and \code{y}.
+#'          by \code{x} and \code{y}, so text labels are added to the plot. 
+#'          Must be of same length as \code{x} and \code{y}.
 #'          If \code{pointLabels} has a different length, data points will be trimmed
 #'          to match \code{pointLabels}. If \code{pointLabels = NULL} (default),
-#'          dots instead of labels are printed.
+#'          no labels are printed.
+#' @param label.size Size of text labels if argument \code{pointLabels} is used.
 #' @param axisTitle.x title for the x axis. Use \code{NULL} to automatically
 #'          detect variable names that will be used as title
 #'          (see \code{\link[sjmisc]{set_label}}) for details).
@@ -44,6 +45,8 @@
 #'          the fit lines. Possible values are for instance \code{""lm""}, \code{""glm""},
 #'          \code{""loess""} or \code{""auto""}.
 #' @param useJitter logical, if \code{TRUE}, points will be jittered (to avoid overplotting).
+#' @param useCount logical, if \code{TRUE}, overlapping points at same coordinates
+#'          will be becomme larger, so point size indicates amount of overlapping.
 #' @param autojitter logical, if \code{TRUE}, points will be jittered according
 #'          to an overlap-estimation. A matrix of \code{x} and \code{y} values
 #'          is created and the amount of cells (indicating a unique point position)
@@ -130,7 +133,8 @@ sjp.scatter <- function(x = NULL,
                         breakTitleAt = 50,
                         breakLegendTitleAt = 20,
                         breakLegendLabelsAt = 20,
-                        geom.size = 3,
+                        geom.size = 2,
+                        label.size = 3,
                         geom.colors = NULL,
                         showTickMarkLabels.x = TRUE,
                         showTickMarkLabels.y = TRUE,
@@ -139,6 +143,7 @@ sjp.scatter <- function(x = NULL,
                         show.ci = FALSE,
                         fitmethod = ""lm"",
                         useJitter = FALSE,
+                        useCount = FALSE,
                         autojitter = TRUE,
                         jitterRatio = 0.15,
                         showRug = FALSE,
@@ -153,6 +158,13 @@ sjp.scatter <- function(x = NULL,
     warning(""argument 'show.se' is deprecated; please use 'show.ci' instead."")
     show.ci <- show.se
   }
+  # ------------------------
+  # check if suggested packages are available
+  # ------------------------
+  if (!is.null(pointLabels) && !requireNamespace(""ggrepel"", quietly = TRUE)) {
+    stop(""Package `ggrepel` needed to plot labels. Please install it."", call. = FALSE)
+  }
+  
   # --------------------------------------------------------
   # get variable name
   # --------------------------------------------------------
@@ -165,8 +177,14 @@ sjp.scatter <- function(x = NULL,
   if (is.null(x) && is.null(y)) {
     stop(""At least either 'x' or 'y' must be specified."", call. = FALSE)
   }
+  if (useJitter && useCount) {
+    warning(""Only one of `useJitter` and `useCount` may be `TRUE`. Defaulting `useJitter` to `FALSE`."")
+    useJitter <- FALSE
+  }
   if (is.null(x)) x <- c(1:length(y))
   if (is.null(y)) y <- c(1:length(x))
+  # disable auto-jitter?
+  if (useCount) autojitter <- FALSE
   # --------------------------------------------------------
   # try to automatically set labels is not passed as parameter
   # --------------------------------------------------------
@@ -202,7 +220,7 @@ sjp.scatter <- function(x = NULL,
     # check for valid range of jitter ratio
     if (jitterRatio <= 0 || jitterRatio >= 1) {
       # inform user
-      warning(""jitterRatio out of valid bounds. Using 0.15 for jitterRatio..."")
+      warning(""`jitterRatio` out of valid bounds. Using 0.15 for `jitterRatio`..."")
       jitterRatio <- 0.15
     }
     # retrieve the highest amount of points lying
@@ -288,22 +306,28 @@ sjp.scatter <- function(x = NULL,
   # Use Jitter/Points
   # --------------------------------------------------------
   if (useJitter) {
+    # else plot dots
+    scatter <- scatter + geom_jitter(size = geom.size)
     # do we have text?
     if (!is.null(pointLabels))
-      scatter <- scatter + geom_text(aes(label = pointLabels),
-                                     size = geom.size,
-                                     position = ""jitter"")
-    else
-      # else plot dots
-      scatter <- scatter + geom_jitter(size = geom.size)
+      scatter <- scatter + ggrepel::geom_text_repel(aes(label = pointLabels),
+                                           size = label.size,
+                                           position = ""jitter"")
   } else {
-    # do we have text?
-    if (!is.null(pointLabels))
-      scatter <- scatter + geom_text(aes(label = pointLabels),
-                                     size = geom.size)
-    else
+    if (useCount) {
+      # indicate overlapping dots by point size
+      scatter <- scatter + geom_count(show.legend = F)
+    } else {
       # else plot dots
       scatter <- scatter + geom_point(size = geom.size)
+    }
+    # do we have text?
+    if (!is.null(pointLabels)) {
+      scatter <- scatter + 
+        ggrepel::geom_text_repel(aes(label = pointLabels),
+                                 size = label.size)
+      
+    }
   }
   # --------------------------------------------------------
   # Show fitted lines
@@ -331,7 +355,7 @@ sjp.scatter <- function(x = NULL,
   # --------------------------------------
   # facet plot
   # --------------------------------------
-  if (facet.grid) scatter <- scatter + facet_wrap(~ grp)
+  if (facet.grid) scatter <- scatter + facet_wrap(~grp)
   # --------------------------------------------------------
   # Prepare fill colors
   # --------------------------------------------------------

---FILE: README.md---
@@ -41,7 +41,7 @@ install.packages(""sjPlot"")
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since core functionality of package depends on the [ggplot-package](http://cran.r-project.org/package=ggplot2), consider citing this package as well.
 
 
-### Changelog of current development build 1.9.0-1
+### Changelog of current development build 1.9.0-3
 
 #### Changes to functions
 * Improved text label positioning for plotting functions.
@@ -52,6 +52,8 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 * `view_df` now supports showing missings and missing percentages ([#76](https://github.com/sjPlot/devel/issues/76)).
 * Harmonized column names of returned data frames to match [broom's naming convention](https://github.com/dgrtwo/broom#tidy-functions) for `sjp.lm`, `sjp.glm`, `sjp.lmer`, `sjp.glmer`, `sjp.lmm`, `sjp.glmm`, `sjp.aov1` and `sjp.int` ([#94](https://github.com/sjPlot/devel/issues/94)).
 * Functions with harmonized data as return value now also gain the class attribute `sjPlot`, and all returned data frame values are names `data`.
+* `sjp.scatter` gets a `useCount` argument to indicate overplotting by point size.
+* `sjp.scatter` now also plots data points when using argument `pointLabels`, so exact position of labelled data points is visible. `geom_text_repel` is used to avoid overlapping of points and labels.
 
 #### Bug fixes
 * Automatic label detection did not choose column names when no variable labels were present for functions that accepted data frames as data argument ([#96](https://github.com/sjPlot/devel/issues/96)).

---FILE: man/sjPlot-package.Rd---
@@ -34,8 +34,8 @@
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.9.0-2\cr
-Date: \tab 2016-02-01\cr
+Version: \tab 1.9.0-3\cr
+Date: \tab 2016-02-03\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjp.gpt.Rd---
@@ -4,7 +4,7 @@
 \alias{sjp.gpt}
 \title{Plot grouped proportional tables}
 \usage{
-sjp.gpt(x, y, groups, geom.colors = ""Set1"", geom.size = 4,
+sjp.gpt(x, y, groups, geom.colors = ""Set1"", geom.size = 2.5,
   shape.fill.color = ""#f0f0f0"", shapes = c(15, 16, 17, 18, 21, 22, 23, 24,
   25, 7, 8, 9, 10, 12), title = NULL, axisLabels = NULL,
   axisTitle.x = NULL, axisTitle.y = NULL, legendTitle = NULL,

---FILE: man/sjp.scatter.Rd---
@@ -7,13 +7,13 @@
 sjp.scatter(x = NULL, y = NULL, grp = NULL, title = """",
   legendTitle = NULL, legendLabels = NULL, pointLabels = NULL,
   axisTitle.x = NULL, axisTitle.y = NULL, breakTitleAt = 50,
-  breakLegendTitleAt = 20, breakLegendLabelsAt = 20, geom.size = 3,
-  geom.colors = NULL, showTickMarkLabels.x = TRUE,
+  breakLegendTitleAt = 20, breakLegendLabelsAt = 20, geom.size = 2,
+  label.size = 3, geom.colors = NULL, showTickMarkLabels.x = TRUE,
   showTickMarkLabels.y = TRUE, showGroupFitLine = FALSE,
   showTotalFitLine = FALSE, show.ci = FALSE, fitmethod = ""lm"",
-  useJitter = FALSE, autojitter = TRUE, jitterRatio = 0.15,
-  showRug = FALSE, hideLegend = FALSE, facet.grid = FALSE,
-  printPlot = TRUE, show.se = FALSE)
+  useJitter = FALSE, useCount = FALSE, autojitter = TRUE,
+  jitterRatio = 0.15, showRug = FALSE, hideLegend = FALSE,
+  facet.grid = FALSE, printPlot = TRUE, show.se = FALSE)
 }
 \arguments{
 \item{x}{vector indicating the x positions. If not specified (i.e. if
@@ -37,11 +37,11 @@ no title is printed.}
 \item{legendLabels}{a character vector with labels for the guide/legend.}
 
 \item{pointLabels}{character vector with names for each coordinate pair given
-by \code{x} and \code{y}, so instead of dots, text labels are
-printed to the plot. Must be of same length as \code{x} and \code{y}.
+by \code{x} and \code{y}, so text labels are added to the plot. 
+Must be of same length as \code{x} and \code{y}.
 If \code{pointLabels} has a different length, data points will be trimmed
 to match \code{pointLabels}. If \code{pointLabels = NULL} (default),
-dots instead of labels are printed.}
+no labels are printed.}
 
 \item{axisTitle.x}{title for the x axis. Use \code{NULL} to automatically
 detect variable names that will be used as title
@@ -62,6 +62,8 @@ displayed in one line and when a line break is inserted.}
 
 \item{geom.size}{size of point geoms.}
 
+\item{label.size}{Size of text labels if argument \code{pointLabels} is used.}
+
 \item{geom.colors}{color(s) of point geoms. If \code{grp} is not \code{NULL},
 groups are indicated by different colors, thus a vector with multiple
 color values has to be supplied.}
@@ -86,6 +88,9 @@ the fit lines. Possible values are for instance \code{""lm""}, \code{""glm""},
 
 \item{useJitter}{logical, if \code{TRUE}, points will be jittered (to avoid overplotting).}
 
+\item{useCount}{logical, if \code{TRUE}, overlapping points at same coordinates
+will be becomme larger, so point size indicates amount of overlapping.}
+
 \item{autojitter}{logical, if \code{TRUE}, points will be jittered according
 to an overlap-estimation. A matrix of \code{x} and \code{y} values
 is created and the amount of cells (indicating a unique point position)"
strengejacke,sjPlot,75396808370b5c1a27d58955365de9770d28eec1,Daniel Ldecke,d.luedecke@uke.de,2016-01-27T17:27:03Z,Daniel Ldecke,d.luedecke@uke.de,2016-01-27T17:27:03Z,"better label positioning, minor fixes",NEWS;R/helpfunctions.R;R/sjPlotAncovaLSMeans.R;R/sjPlotAnova.R;R/sjPlotFrequencies.R;R/sjPlotGLME.R;R/sjPlotInteractions.R;R/sjPlotPCA.R;README.md;man/sjp.aov1.Rd;man/sjp.glmer.Rd;man/sjp.int.Rd;man/sjp.lmer.Rd,False,True,True,False,719,790,1509,"---FILE: NEWS---
@@ -4,6 +4,7 @@ Changes to functions:
 * Improved text label positioning for plotting functions.
 * Plotting functions now get an argument `y.offset` to specify an offset for text labels from geoms.
 * `sjp.int` now fits the y-axis to the required range for predicted probabilities for logistic regressions instead of always using a range from 0 to 1, even for smaller effects.
+* `sjp.glmer` and `sjp.lmer` get a `axisLimits.y` argument to specify y-axis limits specifically for predicted probability or effect plots.
 
 Bug fixes:
 * `sjp.int` did not work with fitted models from class `lme`.

---FILE: R/helpfunctions.R---
@@ -22,10 +22,10 @@ print.table.summary <- function(baseplot,
     # add annotations with table summary
     # here we print out total N of cases, chi-square and significance of the table
     if (tableSummaryPos == ""r"") {
-      t.hjust <- 1.05
+      t.hjust <- ""top""
       x.x <- Inf
     } else {
-      t.hjust <- -0.05
+      t.hjust <- ""bottom""
       x.x <- -Inf
     }
     baseplot <- baseplot +
@@ -34,7 +34,7 @@ print.table.summary <- function(baseplot,
                parse = TRUE,
                x = x.x,
                y = Inf,
-               vjust = 1.1,
+               vjust = ""top"",
                hjust = t.hjust)
   }
   return(baseplot)

---FILE: R/sjPlotAncovaLSMeans.R---
@@ -19,6 +19,7 @@ sjp.emm <- function(fit,
                     breakTitleAt = 50,
                     breakLegendTitleAt = 20,
                     breakLegendLabelsAt = 20,
+                    y.offset = 0.07,
                     axisLimits.y = NULL,
                     gridBreaksAt = NULL,
                     facet.grid = FALSE,
@@ -43,7 +44,7 @@ sjp.emm <- function(fit,
     return(sjp.emm.lmer(fit, swapPredictors, plevel, title, geom.colors, geom.size,
                         axisTitle.x, axisTitle.y, axisLabels.x, legendLabels,
                         showValueLabels, valueLabel.digits, showCI, breakTitleAt,
-                        breakLegendLabelsAt, axisLimits.y, gridBreaksAt, 
+                        breakLegendLabelsAt, y.offset, axisLimits.y, gridBreaksAt, 
                         facet.grid, printPlot))
   }
   # init vector that saves ggplot objects
@@ -301,7 +302,7 @@ sjp.emm <- function(fit,
       if (showValueLabels) {
         baseplot <- baseplot +
           geom_text(aes(label = round(y, vld), x = x, y = y),
-                    vjust = 1.5,
+                    nudge_y = y.offset,
                     show.legend = FALSE)
       }
       # ------------------------------------------------------------------------------------
@@ -344,7 +345,7 @@ sjp.emm <- function(fit,
 sjp.emm.lmer <- function(fit, swapPredictors, plevel, title, geom.colors, geom.size, axisTitle.x,
                          axisTitle.y, axisLabels.x, legendLabels, showValueLabels,
                          valueLabel.digits, showCI, breakTitleAt, breakLegendLabelsAt,
-                         axisLimits.y, gridBreaksAt, facet.grid, printPlot) {
+                         y.offset, axisLimits.y, gridBreaksAt, facet.grid, printPlot) {
   if ((any(class(fit) == ""lmerMod"") || any(class(fit) == ""merModLmerTest"")) && !requireNamespace(""lmerTest"", quietly = TRUE)) {
     stop(""Package 'lmerTest' needed for this function to work. Please install it."", call. = FALSE)
   }
@@ -581,7 +582,7 @@ sjp.emm.lmer <- function(fit, swapPredictors, plevel, title, geom.colors, geom.s
       if (showValueLabels) {
         baseplot <- baseplot +
           geom_text(aes(label = round(y, vld), x = x, y = y),
-                    vjust = 1.5,
+                    nudge_y = y.offset,
                     show.legend = FALSE)
       }
       # ------------------------------------------------------------------------------------

---FILE: R/sjPlotAnova.R---
@@ -19,10 +19,6 @@ utils::globalVariables(""pv"")
 #' @param meansums logical, if \code{TRUE}, the values reported are the true group mean values (see also \code{\link{sjt.grpmean}}).
 #'          If \code{FALSE} (default), the values are reported in the standard way, i.e. the values indicate the difference of
 #'          the group mean in relation to the intercept (reference group).
-#' @param type plot type, whether group means should be plotted as \code{""dots""} (aka forest plots, default)
-#'          or as \code{""bars""}
-#' @param hideErrorBars logical, if \code{TRUE}, the error bars that indicate the confidence intervals of the group means are not
-#'          shown. Only applies if argument \code{type} is \code{""bars""}. Default value is \code{FALSE}.
 #' @param axisLabels.y character vector, indicating the value labels of \code{grpVar} that 
 #'          are used for labelling the axis. See 'Examples'.
 #' @param reverseOrder logical, if \code{TRUE}, the order of categories (groups) is reversed.
@@ -32,10 +28,6 @@ utils::globalVariables(""pv"")
 #' @param axisLimits numeric vector of length 2, defining the range of the plot axis.
 #'          By default, the limits range from the lowest confidence interval to the 
 #'          highest, so plot has maximum zoom.
-#' @param errorBarColor The color of the error bars that indicate the confidence intervalls
-#'          of the group means. Default is \code{NULL}, which means that if \code{type = ""dots""},
-#'          the \code{pointColor} value will be used as errorbar color. In case \code{type = ""bars""},
-#'          \code{""black""} will be used as errorbar color.
 #' @param geom.colors vector of length two, indicating the colors of the points resp. 
 #'          bars (depending on \code{type}); first value is for groups with positive 
 #'          means and the second for negative means.
@@ -63,31 +55,20 @@ utils::globalVariables(""pv"")
 #' sjp.aov1(efc$c12hour, efc$e42dep)
 #' 
 #' 
-#' # bar-plot, don't use this!
-#' # however, if you dare to, adjust
-#' # 'geom.size'...
-#' sjp.aov1(efc$c12hour,
-#'          efc$c172code,
-#'          type = ""bars"",
-#'          geom.size = 0.5)
-#'
 #' @import ggplot2
 #' @import sjmisc
 #' @importFrom stats confint aov summary.lm
 #' @export
 sjp.aov1 <- function(depVar,
                      grpVar,
                      meansums = FALSE,
-                     type = ""dots"",
-                     hideErrorBars = FALSE,
                      title = NULL,
                      axisLabels.y = NULL,
                      reverseOrder = FALSE,
                      stringIntercept = ""(Intercept)"",
                      showAxisLabels.y = TRUE,
                      axisTitle.x = """",
                      axisLimits = NULL,
-                     errorBarColor = NULL,
                      geom.colors = c(""#3366a0"", ""#aa3333""),
                      geom.size = 3,
                      breakTitleAt = 50,
@@ -96,6 +77,7 @@ sjp.aov1 <- function(depVar,
                      expand.grid = FALSE,
                      showValueLabels = TRUE,
                      labelDigits = 2,
+                     y.offset = .1,
                      showPValueLabels = TRUE,
                      showModelSummary = FALSE,
                      printPlot = TRUE) {
@@ -139,25 +121,11 @@ sjp.aov1 <- function(depVar,
   # --------------------------------------------------------
   # Check spelling of type-param
   # --------------------------------------------------------
-  if (type == ""dot"" || type == ""d"") type <- ""dots""
-  if (type == ""bar"" || type == ""b"") type <- ""bars""
   if (expand.grid == TRUE) 
     expand.grid <- ggplot2::waiver()
   else
     expand.grid <- c(0, 0)
   # --------------------------------------------------------
-  # check whether we colors for error bars. if not, use point color
-  # in case of dots or ""black"" in case of bars.
-  # --------------------------------------------------------
-  if (is.null(errorBarColor)) {
-    if (type == ""dots"")
-      errorBarColors <- geom.colors
-    else
-      errorBarColors <- c(""black"", ""black"")
-  } else {
-    errorBarColors <- c(errorBarColor, errorBarColor)
-  }
-  # --------------------------------------------------------
   # check whether we have x-axis title. if not, use standard
   # value
   # --------------------------------------------------------
@@ -274,42 +242,18 @@ sjp.aov1 <- function(depVar,
   df$pv <- as.character(df$pv)
   # bind color values to data frame, because we cannot use several
   # different color aesthetics in ggplot
-  df <- cbind(df,
-              geocol = ifelse(df$means >= 0, geom.colors[1], geom.colors[2]), 
-              errcol = ifelse(df$means >= 0, errorBarColors[1], errorBarColors[2]))
+  df <- cbind(df, geocol = ifelse(df$means >= 0, geom.colors[1], geom.colors[2]))
   # --------------------------------------------------------
   # Calculate axis limits. The range is from lowest lower-CI
   # to highest upper-CI, or a user-defined range (if ""axisLimits""
   # is not NULL)
   # --------------------------------------------------------
   if (is.null(axisLimits)) {
-    # check whether we have bar chart and error bars hidden
-    # in this case, the upper limit does not correspond to the
-    # upper CI, but to the highest OR value
-    if (type == ""bars"") {
-      # if errorbars are hidden, the axis range is defined
-      # by the mean values
-      if (hideErrorBars) {
-        maxval <- max(df$means) + 10
-        minval <- min(df$means)
-      }
-      # if errorbars are shown, axis range is defined
-      # by confidence interval
-      else {
-        maxval <- max(df$upper)
-        minval <- min(df$lower)
-      }
-      # if minval is > 0, set it to zero, so we have a proper baseline
-      if (minval > 0) minval <- 0
-      # if maxval is < 0, set it to zero, so we have a proper baseline
-      if (maxval < 0) maxval <- 0
-    } else {
-      # else we have confindence intervals displayed, so
-      # the range corresponds to the boundaries given by
-      # the CI's
-      maxval <- max(df$upper)
-      minval <- min(df$lower)
-    }
+    # we have confindence intervals displayed, so
+    # the range corresponds to the boundaries given by
+    # the CI's
+    maxval <- max(df$upper)
+    minval <- min(df$lower)
     if (maxval > 0)
       limfac <- ifelse(abs(maxval) < 5, 5, 10)
     else 
@@ -330,95 +274,38 @@ sjp.aov1 <- function(depVar,
   # Set up plot padding (margins inside diagram). In case of
   # bars, we don't want margins.
   # --------------------------------------------------------
-  if (type == ""bars"") {
-    scaley <- scale_y_continuous(limits = c(lower_lim, upper_lim), 
-                                 expand = expand.grid, 
-                                 breaks = ticks, 
-                                 labels = ticks)    
-  } else {
-    scaley <- scale_y_continuous(limits = c(lower_lim, upper_lim), 
-                                 breaks = ticks, 
-                                 labels = ticks)    
-  }
+  scaley <- scale_y_continuous(limits = c(lower_lim, upper_lim), 
+                               breaks = ticks, 
+                               labels = ticks)    
   # --------------------------------------------------------
   # Start plot here!
   # --------------------------------------------------------
-  if (type == ""dots"") {
-    anovaplot <- ggplot(df, aes(y = means, x = xv)) +
-      # print point
-      geom_point(size = geom.size, colour = df$geocol) +
-      # and error bar
-      geom_errorbar(aes(ymin = lower, ymax = upper), 
-                    colour = df$errcol, 
-                    width = 0) +
-      # Print p-values. With vertical adjustment, so 
-      # they don't overlap with the errorbars
-      geom_text(aes(label = pv, y = means), 
-                vjust = -0.8, 
-                show.legend = FALSE)
-  # --------------------------------------------------------
-  # start with bar plots here
-  # --------------------------------------------------------
-  } else if (type == ""bars"") {
-    # check whether we have error bars. if yes, adjust horizontal
-    # posizion of labels
-    hlabj <- ifelse(hideErrorBars == FALSE, 1.3, 0.5)
-    anovaplot <- ggplot(df, aes(y = means, x = xv)) +
-      # stat-parameter indicates statistics
-      # stat=""bin"": y-axis relates to count of variable
-      # stat=""identity"": y-axis relates to value of variable
-      geom_bar(fill = df$geocol, 
-               stat = ""identity"", 
-               position = ""identity"", 
-               width = geom.size) +
-      # print value labels and p-values
-      geom_text(aes(label = pv, y = means), 
-                vjust = ifelse(df$means >= 0, -1, 1), 
-                hjust = hlabj, 
-                show.legend = FALSE)
-    if (hideErrorBars == FALSE) {
-      anovaplot <- anovaplot +
-        # print confidence intervalls (error bars)
-        geom_errorbar(aes(ymin = lower, ymax = upper), 
-                      colour = df$errcol, 
-                      width = 0)
-    }
-  }
-  # --------------------------------------------------------
-  # continue with other plot elements
-  # --------------------------------------------------------
-  anovaplot <- anovaplot +
+  anovaplot <- ggplot(df, aes(y = means, x = xv)) +
+    # print point
+    geom_point(size = geom.size, colour = df$geocol) +
+    # and error bar
+    geom_errorbar(aes(ymin = lower, ymax = upper), width = 0) +
+    # Print p-values. With vertical adjustment, so 
+    # they don't overlap with the errorbars
+    geom_text(aes(label = pv, y = means), 
+              nudge_x = y.offset, 
+              show.legend = FALSE) +
     # set y-scale-limits, breaks and tick labels
     scaley +
     # set value labels to x-axis
     scale_x_discrete(labels = axisLabels.y, limits = c(1:nrow(df))) +
     # flip coordinates
-    labs(title = title, x = NULL, y = axisTitle.x)
-  # --------------------------------------------------------
-  # Flip coordinates when we have dots
-  # --------------------------------------------------------
-  if (type == ""dots"") anovaplot <- anovaplot + coord_flip()
+    labs(title = title, x = NULL, y = axisTitle.x) +
+    coord_flip()
   # check whether modelsummary should be printed
   if (showModelSummary) {
     # add annotations with model summary
     # annotations include intercept-value and model's r-square
-    if (type == ""dots"") {
-      anovaplot <- anovaplot + annotate(""text"", 
-                                        label = modsum, 
-                                        parse = TRUE, 
-                                        x = -Inf, 
-                                        y = Inf, 
-                                        vjust = -0.5, 
-                                        hjust = 1.1)
-    } else {
-      anovaplot <- anovaplot + annotate(""text"", 
-                                        label = modsum, 
-                                        parse = TRUE, 
-                                        x = -Inf, 
-                                        y = Inf, 
-                                        vjust = 1.2, 
-                                        hjust = -0.02)
-    }
+    anovaplot <- anovaplot + annotate(""text"", 
+                                      label = modsum, 
+                                      parse = TRUE, 
+                                      x = -Inf, 
+                                      y = Inf)
   }
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted

---FILE: R/sjPlotFrequencies.R---
@@ -260,8 +260,22 @@ sjp.frq <- function(varCount,
   # --------------------------------------------------------
   # try to automatically set labels is not passed as argument
   # --------------------------------------------------------
-  if (is.null(axisLabels.x)) axisLabels.x <- sjmisc::get_labels(varCount, attr.only = F, include.values = NULL, include.non.labelled = T)
-  if (is.null(interactionVarLabels) && !is.null(interactionVar)) interactionVarLabels <- sjmisc::get_labels(interactionVar, attr.only = F, include.values = NULL, include.non.labelled = T)
+  if (is.null(axisLabels.x)) {
+    axisLabels.x <- sjmisc::get_labels(
+      varCount,
+      attr.only = F,
+      include.values = NULL,
+      include.non.labelled = T
+    )
+  }
+  if (is.null(interactionVarLabels) && !is.null(interactionVar)) {
+    interactionVarLabels <- sjmisc::get_labels(
+      interactionVar,
+      attr.only = F,
+      include.values = NULL,
+      include.non.labelled = T
+    )
+  }
   if (is.null(axisTitle.x)) axisTitle.x <- sjmisc::get_label(varCount, def.value = var.name)
   if (is.null(title)) title <- sjmisc::get_label(varCount, def.value = var.name)
   # --------------------------------------------------------
@@ -272,9 +286,7 @@ sjp.frq <- function(varCount,
   # --------------------------------------------------------
   # check color argument
   # --------------------------------------------------------
-  if (length(geom.colors) > 1) {
-    geom.colors <- geom.colors[1]
-  }
+  if (length(geom.colors) > 1) geom.colors <- geom.colors[1]
   # --------------------------------------------------------
   # We have several options to name the plot type
   # Here we will reduce it to a unique value
@@ -314,7 +326,7 @@ sjp.frq <- function(varCount,
   # check whether variable should be auto-grouped
   #---------------------------------------------------
   if (!is.null(interactionVar) && type != ""boxplots"" && type != ""violin"") {
-    warning(""'interactionVar' only applies to boxplots and violinplots (see 'type') and will be ignored."", call. = F)
+    warning(""`interactionVar` only applies to boxplots and violinplots (see `type`) and will be ignored."", call. = F)
     interactionVar <- NULL
   }
   #---------------------------------------------------
@@ -660,7 +672,7 @@ sjp.frq <- function(varCount,
     # -----------------------------------------------------------------
     if (type == ""histogram"") {
       xv <- stats::na.omit(varCount)
-      if (geom.size < round(diff(range(xv)) / 50)) message(""Using very small binwidth. Consider adjusting \""geom.size\"" argument."")
+      if (geom.size < round(diff(range(xv)) / 50)) message(""Using very small binwidth. Consider adjusting `geom.size` argument."")
       hist.dat <- data.frame(xv)
       baseplot <- ggplot(mydat) +
         geom_histogram(data = hist.dat,
@@ -709,9 +721,10 @@ sjp.frq <- function(varCount,
                    x = mittelwert, 
                    y = upper_lim, 
                    parse = TRUE, 
-                   label = paste(""italic(bar(x)) == "", ""'"", c(round(mittelwert, 1)), ""'""), 
-                   hjust = 1.1, 
-                   vjust = 2.2)
+                   label = paste(""italic(bar(x)) == "", round(mittelwert, 1),
+                                 ""~~italic(s) == "", round(stddev, 1)),
+                   vjust = ""top"",
+                   hjust = ""top"")
       }
       # check whether the user wants to plot standard deviation area
       if (showStandardDeviation) {
@@ -733,18 +746,6 @@ sjp.frq <- function(varCount,
                      linetype = 3, 
                      size = meanInterceptLineSize, 
                      alpha = 0.7)
-        # if mean values are plotted, plot standard deviation values as well
-        if (showMeanValue) {
-          baseplot <- baseplot + 
-            # use annotation instead of geomtext, because we need mean value only printed once
-            annotate(""text"", 
-                     x = mittelwert, 
-                     y = upper_lim, 
-                     label = sprintf(""italic(s) == %.2f"", round(stddev, 1)), 
-                     parse = TRUE, 
-                     hjust = 1.15, 
-                     vjust = 4.2)
-        }
       }
     }
     # show absolute and percentage value of each bar.

---FILE: R/sjPlotGLME.R---
@@ -97,6 +97,7 @@ utils::globalVariables(c(""nQQ"", ""ci"", ""fixef"", ""fade"", ""lower.CI"", ""upper.CI"", ""
 #'
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjp.lm
+#' @inheritParams sjp.glm
 #'
 #' @return (Insisibily) returns
 #'          \itemize{
@@ -217,13 +218,15 @@ sjp.glmer <- function(fit,
                       pred.labels = NULL,
                       axisTitle.x = NULL,
                       axisTitle.y = NULL,
+                      axisLimits.y = NULL,
                       facet.grid = TRUE,
                       free.scale = FALSE,
                       interceptLineType = 2,
                       interceptLineColor = ""grey70"",
                       remove.estimates = NULL,
                       showValueLabels = TRUE,
                       labelDigits = 2,
+                      y.offset = .1,
                       showPValueLabels = TRUE,
                       fade.ns = FALSE,
                       show.ci = FALSE,
@@ -258,11 +261,13 @@ sjp.glmer <- function(fit,
            pred.labels,
            axisTitle.x,
            axisTitle.y,
+           axisLimits.y,
            interceptLineType,
            interceptLineColor,
            remove.estimates,
            showValueLabels,
            labelDigits,
+           y.offset,
            showPValueLabels,
            facet.grid,
            free.scale,
@@ -487,11 +492,13 @@ sjp.lmer <- function(fit,
                      pred.labels = NULL,
                      axisTitle.x = NULL,
                      axisTitle.y = NULL,
+                     axisLimits.y = NULL,
                      interceptLineType = 2,
                      interceptLineColor = ""grey70"",
                      remove.estimates = NULL,
                      showValueLabels = TRUE,
                      labelDigits = 2,
+                     y.offset = .1,
                      showPValueLabels = TRUE,
                      facet.grid = TRUE,
                      free.scale = FALSE,
@@ -533,11 +540,13 @@ sjp.lmer <- function(fit,
            pred.labels,
            axisTitle.x,
            axisTitle.y,
+           axisLimits.y,
            interceptLineType,
            interceptLineColor,
            remove.estimates,
            showValueLabels,
            labelDigits,
+           y.offset,
            showPValueLabels,
            facet.grid,
            free.scale,
@@ -569,11 +578,13 @@ sjp.lme4  <- function(fit,
                       pred.labels,
                       axisTitle.x,
                       axisTitle.y,
+                      axisLimits.y,
                       interceptLineType,
                       interceptLineColor,
                       remove.estimates,
                       showValueLabels,
                       labelDigits,
+                      y.offset,
                       showPValueLabels,
                       facet.grid,
                       free.scale,
@@ -773,6 +784,7 @@ sjp.lme4  <- function(fit,
                                    geom.size,
                                    remove.estimates,
                                    showCI = show.ci,
+                                   axisLimits.y,
                                    printPlot)))
     }
   } else if (type == ""fe.ri"") {
@@ -802,6 +814,7 @@ sjp.lme4  <- function(fit,
                                   geom.size,
                                   sample.n,
                                   show.legend,
+                                  axisLimits.y,
                                   printPlot,
                                   fun)))
   } else if (type == ""re.qq"") {
@@ -828,6 +841,7 @@ sjp.lme4  <- function(fit,
                                           facet.grid,
                                           vars,
                                           geom.size,
+                                          axisLimits.y,
                                           printPlot)))
     } else {
       warning(""Probability plots of fixed effects only works for function 'sjp.glmer'."", call. = FALSE)
@@ -840,12 +854,13 @@ sjp.lme4  <- function(fit,
     # ---------------------------------------
     if (fun == ""glm"") {
       return(invisible(sjp.lme.reprobcurve(fit,
-                                            show.ci,
-                                            facet.grid,
-                                            ri.nr,
-                                            vars,
-                                            emph.grp,
-                                            printPlot)))
+                                           show.ci,
+                                           facet.grid,
+                                           ri.nr,
+                                           vars,
+                                           emph.grp,
+                                           axisLimits.y,
+                                           printPlot)))
     } else {
       warning(""Probability plots of random intercept effects only works for function 'sjp.glmer'."", call. = FALSE)
       return(invisible(NULL))
@@ -858,6 +873,7 @@ sjp.lme4  <- function(fit,
     return(invisible(sjp.lme.response.probcurv(fit,
                                                show.ci,
                                                facet.grid,
+                                               axisLimits.y,
                                                fun,
                                                printPlot)))
   }
@@ -1173,7 +1189,7 @@ sjp.lme4  <- function(fit,
                    color = interceptLineColor) +
         geom_point(size = geom.size) +
         # print value labels and p-values
-        geom_text(aes(label = p, y = OR), vjust = -0.7) +
+        geom_text(aes(label = p, y = OR), nudge_x = y.offset) +
         # ---------------------------------------
       # labels in sorted order
       # ---------------------------------------
@@ -1308,9 +1324,12 @@ sjp.lme.feprobcurv <- function(fit,
                                facet.grid,
                                vars,
                                geom.size,
+                               axisLimits.y,
                                printPlot) {
   # check size argument
   if (is.null(geom.size)) geom.size <- .7
+  # check axis limits
+  if (is.null(axisLimits.y)) axisLimits.y <- c(0, 1)
   # ----------------------------
   # prepare additional plots, when metric
   # predictors should also be plotted
@@ -1405,7 +1424,7 @@ sjp.lme.feprobcurv <- function(fit,
                     se = show.ci) +
         # cartesian coord still plots range of se, even
         # when se exceeds plot range.
-        coord_cartesian(ylim = c(0, 1))
+        coord_cartesian(ylim = axisLimits.y)
       # add plot to list
       plot.metricpred[[length(plot.metricpred) + 1]] <- mp
     }
@@ -1424,7 +1443,7 @@ sjp.lme.feprobcurv <- function(fit,
                     se = show.ci) +
         # cartesian coord still plots range of se, even
         # when se exceeds plot range.
-        coord_cartesian(ylim = c(0, 1)) +
+        coord_cartesian(ylim = axisLimits.y) +
         facet_wrap(~grp,
                    ncol = round(sqrt(length(mydf.metricpred))),
                    scales = ""free_x"") +
@@ -1461,8 +1480,13 @@ sjp.lme.reprobcurve <- function(fit,
                                 ri.nr,
                                 vars,
                                 emph.grp,
+                                axisLimits.y,
                                 printPlot) {
   # ----------------------------
+  # check axis limits
+  # ----------------------------
+  if (is.null(axisLimits.y)) axisLimits.y <- c(0, 1)
+  # ----------------------------
   # retrieve data frame of model to check whether
   # we have any numeric terms in fitted model
   # ----------------------------
@@ -1565,7 +1589,7 @@ sjp.lme.reprobcurve <- function(fit,
                         se = show.ci) +
             # cartesian coord still plots range of se, even
             # when se exceeds plot range.
-            coord_cartesian(ylim = c(0, 1)) +
+            coord_cartesian(ylim = axisLimits.y) +
             labs(x = NULL,
                  y = ""Predicted Probability"",
                  title = sprintf(""Predicted Probability of %s on %s"", pred.name, response.name))
@@ -1613,9 +1637,14 @@ sjp.lme.reprobcurve <- function(fit,
 sjp.lme.response.probcurv <- function(fit,
                                       show.ci,
                                       facet.grid,
+                                      axisLimits.y,
                                       fun,
                                       printPlot) {
   # ----------------------------
+  # check axis limits
+  # ----------------------------
+  if (is.null(axisLimits.y)) axisLimits.y <- c(0, 1)
+  # ----------------------------
   # get predicted values for response with and
   # without random effects
   # ----------------------------
@@ -1659,7 +1688,7 @@ sjp.lme.response.probcurv <- function(fit,
                   se = show.ci) +
       # cartesian coord still plots range of se, even
       # when se exceeds plot range.
-      coord_cartesian(ylim = c(0, 1))
+      coord_cartesian(ylim = axisLimits.y)
   } else {
     mp <- mp +
       labs(x = NULL,
@@ -1819,10 +1848,13 @@ sjp.lme.reri <- function(fit,
                          geom.size,
                          sample.n,
                          show.legend,
+                         axisLimits.y,
                          printPlot,
                          fun) {
   # check size argument
   if (is.null(geom.size)) geom.size <- .7
+  # check axis limits
+  if (is.null(axisLimits.y)) axisLimits.y <- c(0, 1)
   # ----------------------------
   # retrieve term names, so we find the estimates in the
   # coefficients list
@@ -1925,7 +1957,7 @@ sjp.lme.reri <- function(fit,
           stat_smooth(method = ""glm"", method.args = list(family = ""binomial"")) +
           # cartesian coord still plots range of se, even
           # when se exceeds plot range.
-          coord_cartesian(ylim = c(0, 1)) +
+          coord_cartesian(ylim = axisLimits.y) +
           labs(x = axisTitle.x, y = axisTitle.y, title = title)
       }
       # ------------------------------
@@ -2260,7 +2292,10 @@ sjp.glm.eff <- function(fit,
                         geom.size,
                         remove.estimates,
                         showCI,
+                        axisLimits.y,
                         printPlot) {
+  # check axis range
+  if (is.null(axisLimits.y)) axisLimits.y <- c(0, 1)
   # ------------------------
   # check if suggested package is available
   # ------------------------
@@ -2379,7 +2414,7 @@ sjp.glm.eff <- function(fit,
     labs(x = NULL, y = axisTitle.y, title = title)
   # for logistic regression, use 0 to 1 scale limits
   if (fitfam %in% c(""binomial"", ""quasibinomial""))
-    eff.plot <- eff.plot + coord_cartesian(ylim = c(0, 1))
+    eff.plot <- eff.plot + coord_cartesian(ylim = axisLimits.y)
   # ------------------------
   # print plot?
   # ------------------------

---FILE: R/sjPlotInteractions.R---
@@ -324,6 +324,7 @@ sjp.int <- function(fit,
                     breakLegendTitleAt = 20,
                     axisLimits.x = NULL,
                     axisLimits.y = NULL,
+                    y.offset = 0.07,
                     gridBreaksAt = NULL,
                     showCI = FALSE,
                     valueLabel.digits = 2,
@@ -424,7 +425,7 @@ sjp.int <- function(fit,
     return(sjp.emm(fit, swapPredictors, plevel, title, geom.colors, geom.size,
                    axisTitle.x, axisTitle.y, axisLabels.x, legendTitle, legendLabels,
                    showValueLabels, valueLabel.digits, showCI, breakTitleAt,
-                   breakLegendTitleAt, breakLegendLabelsAt, axisLimits.y, 
+                   breakLegendTitleAt, breakLegendLabelsAt, y.offset, axisLimits.y, 
                    gridBreaksAt, facet.grid, printPlot))
   }
   # --------------------------------------------------------
@@ -440,8 +441,8 @@ sjp.int <- function(fit,
                        title, fillAlpha, geom.colors, geom.size, axisTitle.x,
                        axisTitle.y, legendTitle, legendLabels,
                        showValueLabels, breakTitleAt, breakLegendLabelsAt, 
-                       breakLegendTitleAt, axisLimits.x,
-                       axisLimits.y, gridBreaksAt, showCI, facet.grid, printPlot, fun))
+                       breakLegendTitleAt, axisLimits.x, axisLimits.y, 
+                       y.offset, gridBreaksAt, showCI, facet.grid, printPlot, fun))
   }
   # -----------------------------------------------------------
   # set axis title
@@ -594,8 +595,6 @@ sjp.int <- function(fit,
       ymin <- qu[2]
       ymax <- qu[4]
     }
-    # intercept of predictor's reference category
-    est_b <- b.pred
     # -----------------------------------------------------------
     # Create data frame for plotting the interactions by
     # manually calculating the linear regression by inserting
@@ -719,8 +718,8 @@ sjp.int <- function(fit,
     # check whether user defined grid breaks / tick marks are used
     # -----------------------------------------------------------
     if (!is.null(gridBreaksAt)) {
-      gridbreaks.x <- c(seq(lowerLim.x, upperLim.x, by = gridBreaksAt))
-      gridbreaks.y <- c(seq(lowerLim.y, upperLim.y, by = gridBreaksAt))
+      gridbreaks.x <- seq(lowerLim.x, upperLim.x, by = gridBreaksAt)
+      gridbreaks.y <- seq(lowerLim.y, upperLim.y, by = gridBreaksAt)
     }
     # -----------------------------------------------------------
     # prepare plot title and axis titles
@@ -813,7 +812,7 @@ sjp.int <- function(fit,
       if (showValueLabels) {
         baseplot <- baseplot +
           geom_text(aes(label = round(ydiff, 1)),
-                    vjust = 1.5,
+                    nudge_y = y.offset,
                     show.legend = FALSE)
       }
     } else {
@@ -836,7 +835,7 @@ sjp.int <- function(fit,
         baseplot <- baseplot +
           geom_point() +
           geom_text(aes(label = round(y, 1)),
-                    vjust = 1.5,
+                    nudge_y = y.offset,
                     show.legend = FALSE)
       }
     }
@@ -889,599 +888,600 @@ sjp.int <- function(fit,
 }
   
   
-  #' @importFrom stats plogis na.omit
-  sjp.eff.int <- function(fit,
-                          int.term = NULL,
-                          int.plot.index = NULL,
-                          moderatorValues = ""minmax"",
-                          swapPredictors = FALSE,
-                          plevel = 0.05,
-                          title = NULL,
-                          fillAlpha = 0.3,
-                          geom.colors = ""Set1"",
-                          geom.size = 0.7,
-                          axisTitle.x = NULL,
-                          axisTitle.y = NULL,
-                          legendTitle = NULL,
-                          legendLabels = NULL,
-                          showValueLabels = FALSE,
-                          breakTitleAt = 50,
-                          breakLegendLabelsAt = 20,
-                          breakLegendTitleAt = 20,
-                          axisLimits.x = NULL,
-                          axisLimits.y = NULL,
-                          gridBreaksAt = NULL,
-                          showCI = FALSE,
-                          facet.grid = FALSE,
-                          printPlot = TRUE,
-                          fun) {
-    # --------------------------------------------------------
-    # check default geom.size
-    # --------------------------------------------------------
-    if (is.null(geom.size)) geom.size = .7
-    # ------------------------
-    # check if suggested package is available
-    # ------------------------
-    if (!requireNamespace(""effects"", quietly = TRUE)) {
-      stop(""Package 'effects' needed for this function to work. Please install it."", call. = FALSE)
-    }
-    # gridbreaks
-    if (is.null(gridBreaksAt)) gridbreaks.x <- gridbreaks.y <- ggplot2::waiver()
-    # ------------------------
-    # multiple purpose of showCI parameter. if logical,
-    # sets default CI to 0.95, else showCI also may be
-    # numeric
-    # ------------------------
-    if (!is.null(showCI) && !is.logical(showCI)) {
-      eci <- showCI
-      showCI = TRUE
-    } else {
-      eci <- 0.95
-    }
-    # ------------------------
-    # calculate effects of higher order terms and
-    # check if fitted model contains any interaction terms
-    # allEffects returns a list, with all interaction effects 
-    # (or higher order terms) as separate list element. each list
-    # element contains the higher-order-term of the fitted model,
-    # where the 'term' attribute of interaction terms have a ""*"". 
-    # So we just need to look at each 'term' attribute of each
-    # list element and see if there is a ""*""...
-    # ------------------------
-    if (is.null(int.term)) {
-      eff <- effects::allEffects(fit, KR = F)
-      int <- unlist(lapply(eff, function(x) grep(""*"", x['term'], fixed = T)))
-    } else {
-      eff <- effects::effect(int.term, fit, KR = F)
-      int <- grep(""*"", eff$term, fixed = T)
-    }
-    if (length(int) == 0) {
-      warning(""No interaction term found in fitted model..."", call. = FALSE)
-      return(invisible(NULL))
-    }
-    # ------------------------
-    # retrieve position of interaction terms in effects-object
-    # ------------------------
+#' @importFrom stats plogis na.omit
+sjp.eff.int <- function(fit,
+                        int.term = NULL,
+                        int.plot.index = NULL,
+                        moderatorValues = ""minmax"",
+                        swapPredictors = FALSE,
+                        plevel = 0.05,
+                        title = NULL,
+                        fillAlpha = 0.3,
+                        geom.colors = ""Set1"",
+                        geom.size = 0.7,
+                        axisTitle.x = NULL,
+                        axisTitle.y = NULL,
+                        legendTitle = NULL,
+                        legendLabels = NULL,
+                        showValueLabels = FALSE,
+                        breakTitleAt = 50,
+                        breakLegendLabelsAt = 20,
+                        breakLegendTitleAt = 20,
+                        axisLimits.x = NULL,
+                        axisLimits.y = NULL,
+                        y.offset = 0.07,
+                        gridBreaksAt = NULL,
+                        showCI = FALSE,
+                        facet.grid = FALSE,
+                        printPlot = TRUE,
+                        fun) {
+  # --------------------------------------------------------
+  # check default geom.size
+  # --------------------------------------------------------
+  if (is.null(geom.size)) geom.size = .7
+  # ------------------------
+  # check if suggested package is available
+  # ------------------------
+  if (!requireNamespace(""effects"", quietly = TRUE)) {
+    stop(""Package 'effects' needed for this function to work. Please install it."", call. = FALSE)
+  }
+  # gridbreaks
+  if (is.null(gridBreaksAt)) gridbreaks.x <- gridbreaks.y <- ggplot2::waiver()
+  # ------------------------
+  # multiple purpose of showCI parameter. if logical,
+  # sets default CI to 0.95, else showCI also may be
+  # numeric
+  # ------------------------
+  if (!is.null(showCI) && !is.logical(showCI)) {
+    eci <- showCI
+    showCI = TRUE
+  } else {
+    eci <- 0.95
+  }
+  # ------------------------
+  # calculate effects of higher order terms and
+  # check if fitted model contains any interaction terms
+  # allEffects returns a list, with all interaction effects 
+  # (or higher order terms) as separate list element. each list
+  # element contains the higher-order-term of the fitted model,
+  # where the 'term' attribute of interaction terms have a ""*"". 
+  # So we just need to look at each 'term' attribute of each
+  # list element and see if there is a ""*""...
+  # ------------------------
+  if (is.null(int.term)) {
+    eff <- effects::allEffects(fit, KR = F)
+    int <- unlist(lapply(eff, function(x) grep(""*"", x['term'], fixed = T)))
+  } else {
+    eff <- effects::effect(int.term, fit, KR = F)
+    int <- grep(""*"", eff$term, fixed = T)
+  }
+  if (length(int) == 0) {
+    warning(""No interaction term found in fitted model..."", call. = FALSE)
+    return(invisible(NULL))
+  }
+  # ------------------------
+  # retrieve position of interaction terms in effects-object
+  # ------------------------
+  if (is.null(int.term)) {
+    intpos <- which(as.vector(sapply(eff, function(x) length(grep(""*"", x['term'], fixed = T)) > 0)) == T)
+  } else {
+    intpos <- 1
+  }
+  # select only specific plots
+  if (!is.null(int.plot.index) && !any(int.plot.index > length(intpos))) intpos <- intpos[int.plot.index]  
+  # init vector that saves ggplot objects
+  plotlist <- list()
+  dflist <- list()
+  # -----------------------------------------------------------
+  # iterate all interaction terms
+  # -----------------------------------------------------------
+  for (i in 1:length(intpos)) {
+    # -----------------------------------------------------------
+    # copy ""eff"" object, so we don't confuse with effect-return-
+    # value from single term and multiple terms
+    # -----------------------------------------------------------
     if (is.null(int.term)) {
-      intpos <- which(as.vector(sapply(eff, function(x) length(grep(""*"", x['term'], fixed = T)) > 0)) == T)
+      dummy.eff <- eff[[intpos[i]]]
     } else {
-      intpos <- 1
+      dummy.eff <- eff
     }
-    # select only specific plots
-    if (!is.null(int.plot.index) && !any(int.plot.index > length(intpos))) intpos <- intpos[int.plot.index]  
-    # init vector that saves ggplot objects
-    plotlist <- list()
-    dflist <- list()
     # -----------------------------------------------------------
-    # iterate all interaction terms
+    # retrieve data frame
     # -----------------------------------------------------------
-    for (i in 1:length(intpos)) {
-      # -----------------------------------------------------------
-      # copy ""eff"" object, so we don't confuse with effect-return-
-      # value from single term and multiple terms
-      # -----------------------------------------------------------
+    intdf <- data.frame(dummy.eff)
+    # -----------------------------------------------------------
+    # save response, predictor and moderator names
+    # -----------------------------------------------------------
+    pred_x.name <- colnames(intdf)[ifelse(swapPredictors == TRUE, 1, 2)]
+    moderator.name <- colnames(intdf)[ifelse(swapPredictors == TRUE, 2, 1)]
+    response.name <- dummy.eff$response
+    # prepare axis titles
+    labx <- pred_x.name
+    # check whether x-axis-predictor is a factor or not
+    x_is_factor <- is.factor(intdf[[pred_x.name]]) || (length(unique(na.omit(intdf[[pred_x.name]]))) < 3)
+    # -----------------------------------------------------------
+    # check for moderator values, but only, if moderator 
+    # is no factor value. In this case, we can choose
+    # the values for continuous moderator intentionally,
+    # e.g. only min/max, or mean and sd. We don't need these
+    # values for categorical moderator values.
+    # -----------------------------------------------------------
+    if (!is.factor(intdf[[moderator.name]])) {
+      # retrieve moderator value
+      modval <- dummy.eff$data[[moderator.name]]
+      # retrieve predictor value
+      predval <- dummy.eff$data[[pred_x.name]]
+      # -----------------------------------------------------------
+      # Check whether moderator value has enough unique values
+      # for quartiles
+      # -----------------------------------------------------------
+      moderatorValues <- mv_check(moderatorValues, modval)
+      # we have more than two values, so re-calculate effects, just using
+      # min and max value of moderator. 
+      if (moderatorValues == ""minmax"" && length(unique(intdf[[moderator.name]])) > 2) {
+        # retrieve min and max values
+        mv.min <- min(modval, na.rm = T)
+        mv.max <- max(modval, na.rm = T)
+        # re-compute effects, prepare xlevels
+        xl1 <- list(x = c(mv.min, mv.max))
+        # we have more than two values, so re-calculate effects, just using
+        # 0 and max value of moderator.
+      } else if (moderatorValues == ""zeromax"" && length(unique(intdf[[moderator.name]])) > 2) {
+        # retrieve max values
+        mv.max <- max(modval, na.rm = T)
+        # re-compute effects, prepare xlevels
+        xl1 <- list(x = c(0, mv.max))
+        # compute mean +/- sd
+      } else if (moderatorValues == ""meansd"") {
+        # retrieve mean and sd
+        mv.mean <- round(mean(modval, na.rm = T), 2)
+        mv.sd <- round(sd(modval, na.rm = T), 2)
+        # re-compute effects, prepare xlevels
+        xl1 <- list(x = c(mv.mean - mv.sd, mv.mean, mv.mean + mv.sd))
+      } else if (moderatorValues == ""quart"") {
+        # re-compute effects, prepare xlevels
+        xl1 <- list(x = as.vector(quantile(modval, na.rm = T)))
+      }
+      # change list name to moderator value name
+      names(xl1) <- moderator.name
+      # add values of interaction term
+      # first, get all unqiue values
+      prvl <- sort(unique(stats::na.omit(predval)))
+      # add them to list as well
+      xl2 <- list(y = prvl)
+      # change list name
+      names(xl2) <- pred_x.name
+      # combine lists
       if (is.null(int.term)) {
-        dummy.eff <- eff[[intpos[i]]]
+        # re-compute effects
+        eff.tmp <- effects::allEffects(fit, 
+                                       xlevels = c(xl1, xl2), 
+                                       KR = F, 
+                                       confidence.level = eci)
+        # reset data frame
+        intdf <- data.frame(eff.tmp[[intpos[i]]])
       } else {
-        dummy.eff <- eff
+        # re-compute effects
+        eff.tmp <- effects::effect(int.term, 
+                                   fit, 
+                                   xlevels = c(xl1, xl2), 
+                                   KR = F,
+                                   confidence.level = eci)
+        # reset data frame
+        intdf <- data.frame(eff.tmp)
       }
       # -----------------------------------------------------------
-      # retrieve data frame
-      # -----------------------------------------------------------
-      intdf <- data.frame(dummy.eff)
-      # -----------------------------------------------------------
-      # save response, predictor and moderator names
-      # -----------------------------------------------------------
-      pred_x.name <- colnames(intdf)[ifelse(swapPredictors == TRUE, 1, 2)]
-      moderator.name <- colnames(intdf)[ifelse(swapPredictors == TRUE, 2, 1)]
-      response.name <- dummy.eff$response
-      # prepare axis titles
-      labx <- pred_x.name
-      # check whether x-axis-predictor is a factor or not
-      x_is_factor <- is.factor(intdf[[pred_x.name]]) || (length(unique(na.omit(intdf[[pred_x.name]]))) < 3)
+      # check for predictor values on x-axis. if it 
+      # is no factor, select whole range of possible
+      # values.
+      # -----------------------------------------------------------
+    } else if (!is.factor(intdf[[pred_x.name]])) {
+      # retrieve predictor value
+      predval <- dummy.eff$data[[pred_x.name]]
+      # add values of interaction term
+      # first, get all unqiue values
+      prvl <- sort(unique(stats::na.omit(predval)))
+      # add them to list as well
+      xl <- list(x = prvl)
+      # change list name
+      names(xl) <- pred_x.name
+      # combine lists
+      if (is.null(int.term)) {
+        # re-compute effects
+        eff.tmp <- effects::allEffects(fit,
+                                       xlevels = xl, 
+                                       KR = F,
+                                       confidence.level = eci)
+        # reset data frame
+        intdf <- data.frame(eff.tmp[[intpos[i]]])
+      } else {
+        # re-compute effects
+        eff.tmp <- effects::effect(int.term, 
+                                   fit, 
+                                   xlevels = xl, 
+                                   KR = F,
+                                   confidence.level = eci)
+        # reset data frame
+        intdf <- data.frame(eff.tmp)
+      }
+    }
+    # -----------------------------------------------------------
+    # change column names
+    # -----------------------------------------------------------
+    if (swapPredictors) {
+      colnames(intdf) <- c(""x"", ""grp"", ""y"", ""se"", ""lower"", ""upper"")
+    } else {
+      colnames(intdf) <- c(""grp"", ""x"", ""y"", ""se"", ""lower"", ""upper"")
+    }
+    # -----------------------------------------------------------
+    # effects-package creates ""NA"" factor levels, which
+    # need to be removed
+    # -----------------------------------------------------------
+    intdf <- droplevels(intdf)
+    # group as factor
+    intdf$grp <- as.factor(intdf$grp)
+    # make sure x is numeric
+    intdf$x <- sjmisc::to_value(intdf$x, keep.labels = F)
+    # -----------------------------------------------------------
+    # check if we have linear regression
+    # -----------------------------------------------------------
+    if (fun == ""lm"" || fun == ""lmer"" || fun == ""lme"" || fun == ""gls"") {
+      # Label on y-axis is name of dependent variable
+      laby <- response.name
       # -----------------------------------------------------------
-      # check for moderator values, but only, if moderator 
-      # is no factor value. In this case, we can choose
-      # the values for continuous moderator intentionally,
-      # e.g. only min/max, or mean and sd. We don't need these
-      # values for categorical moderator values.
+      # retrieve lowest and highest x and y position to determine
+      # the scale limits
       # -----------------------------------------------------------
-      if (!is.factor(intdf[[moderator.name]])) {
-        # retrieve moderator value
-        modval <- dummy.eff$data[[moderator.name]]
-        # retrieve predictor value
-        predval <- dummy.eff$data[[pred_x.name]]
-        # -----------------------------------------------------------
-        # Check whether moderator value has enough unique values
-        # for quartiles
-        # -----------------------------------------------------------
-        moderatorValues <- mv_check(moderatorValues, modval)
-        # we have more than two values, so re-calculate effects, just using
-        # min and max value of moderator. 
-        if (moderatorValues == ""minmax"" && length(unique(intdf[[moderator.name]])) > 2) {
-          # retrieve min and max values
-          mv.min <- min(modval, na.rm = T)
-          mv.max <- max(modval, na.rm = T)
-          # re-compute effects, prepare xlevels
-          xl1 <- list(x = c(mv.min, mv.max))
-          # we have more than two values, so re-calculate effects, just using
-          # 0 and max value of moderator.
-        } else if (moderatorValues == ""zeromax"" && length(unique(intdf[[moderator.name]])) > 2) {
-          # retrieve max values
-          mv.max <- max(modval, na.rm = T)
-          # re-compute effects, prepare xlevels
-          xl1 <- list(x = c(0, mv.max))
-          # compute mean +/- sd
-        } else if (moderatorValues == ""meansd"") {
-          # retrieve mean and sd
-          mv.mean <- round(mean(modval, na.rm = T), 2)
-          mv.sd <- round(sd(modval, na.rm = T), 2)
-          # re-compute effects, prepare xlevels
-          xl1 <- list(x = c(mv.mean - mv.sd, mv.mean, mv.mean + mv.sd))
-        } else if (moderatorValues == ""quart"") {
-          # re-compute effects, prepare xlevels
-          xl1 <- list(x = as.vector(quantile(modval, na.rm = T)))
-        }
-        # change list name to moderator value name
-        names(xl1) <- moderator.name
-        # add values of interaction term
-        # first, get all unqiue values
-        prvl <- sort(unique(stats::na.omit(predval)))
-        # add them to list as well
-        xl2 <- list(y = prvl)
-        # change list name
-        names(xl2) <- pred_x.name
-        # combine lists
-        if (is.null(int.term)) {
-          # re-compute effects
-          eff.tmp <- effects::allEffects(fit, 
-                                         xlevels = c(xl1, xl2), 
-                                         KR = F, 
-                                         confidence.level = eci)
-          # reset data frame
-          intdf <- data.frame(eff.tmp[[intpos[i]]])
-        } else {
-          # re-compute effects
-          eff.tmp <- effects::effect(int.term, 
-                                     fit, 
-                                     xlevels = c(xl1, xl2), 
-                                     KR = F,
-                                     confidence.level = eci)
-          # reset data frame
-          intdf <- data.frame(eff.tmp)
-        }
-        # -----------------------------------------------------------
-        # check for predictor values on x-axis. if it 
-        # is no factor, select whole range of possible
-        # values.
-        # -----------------------------------------------------------
-      } else if (!is.factor(intdf[[pred_x.name]])) {
-        # retrieve predictor value
-        predval <- dummy.eff$data[[pred_x.name]]
-        # add values of interaction term
-        # first, get all unqiue values
-        prvl <- sort(unique(stats::na.omit(predval)))
-        # add them to list as well
-        xl <- list(x = prvl)
-        # change list name
-        names(xl) <- pred_x.name
-        # combine lists
-        if (is.null(int.term)) {
-          # re-compute effects
-          eff.tmp <- effects::allEffects(fit,
-                                         xlevels = xl, 
-                                         KR = F,
-                                         confidence.level = eci)
-          # reset data frame
-          intdf <- data.frame(eff.tmp[[intpos[i]]])
+      if (is.null(axisLimits.y)) {
+        if (showCI) {
+          lowerLim.y <- floor(min(intdf$lower, na.rm = T))
+          upperLim.y <- ceiling(max(intdf$upper, na.rm = T))
         } else {
-          # re-compute effects
-          eff.tmp <- effects::effect(int.term, 
-                                     fit, 
-                                     xlevels = xl, 
-                                     KR = F,
-                                     confidence.level = eci)
-          # reset data frame
-          intdf <- data.frame(eff.tmp)
+          lowerLim.y <- floor(min(intdf$y, na.rm = T))
+          upperLim.y <- ceiling(max(intdf$y, na.rm = T))
         }
-      }
-      # -----------------------------------------------------------
-      # change column names
-      # -----------------------------------------------------------
-      if (swapPredictors) {
-        colnames(intdf) <- c(""x"", ""grp"", ""y"", ""se"", ""lower"", ""upper"")
       } else {
-        colnames(intdf) <- c(""grp"", ""x"", ""y"", ""se"", ""lower"", ""upper"")
+        lowerLim.y <- axisLimits.y[1]
+        upperLim.y <- axisLimits.y[2]
+      }
+    } else {
+      # ------------------------
+      # do we have glm? if so, get link family. make exceptions
+      # for specific models that don't have family function
+      # ------------------------
+      if (any(c.f == ""lme"")) 
+        fitfam <- """"
+      else
+        fitfam <- stats::family(fit)$family
+      # Label on y-axis is fixed
+      if (is.null(axisTitle.y)) {
+        # for logistic reg.
+        if (fitfam %in% c(""binomial"", ""quasibinomial""))
+          axisTitle.y <- ""Predicted Probability""
+        else if (fitfam %in% c(""poisson"", ""quasipoisson""))
+          axisTitle.y <- ""Predicted Incidents""
       }
       # -----------------------------------------------------------
-      # effects-package creates ""NA"" factor levels, which
-      # need to be removed
-      # -----------------------------------------------------------
-      intdf <- droplevels(intdf)
-      # group as factor
-      intdf$grp <- as.factor(intdf$grp)
-      # make sure x is numeric
-      intdf$x <- sjmisc::to_value(intdf$x, keep.labels = F)
-      # -----------------------------------------------------------
-      # check if we have linear regression
+      # retrieve lowest and highest x and y position to determine
+      # the scale limits
       # -----------------------------------------------------------
-      if (fun == ""lm"" || fun == ""lmer"" || fun == ""lme"" || fun == ""gls"") {
-        # Label on y-axis is name of dependent variable
-        laby <- response.name
-        # -----------------------------------------------------------
-        # retrieve lowest and highest x and y position to determine
-        # the scale limits
-        # -----------------------------------------------------------
-        if (is.null(axisLimits.y)) {
+      if (is.null(axisLimits.y)) {
+        if (fitfam %in% c(""binomial"", ""quasibinomial"")) {
+          lowerLim.y <- as.integer(10 * min(intdf$y, na.rm = T) * .9) / 10
+          upperLim.y <- as.integer(10 * max(intdf$y, na.rm = T) * 1.1) / 10
+        } else {
           if (showCI) {
             lowerLim.y <- floor(min(intdf$lower, na.rm = T))
             upperLim.y <- ceiling(max(intdf$upper, na.rm = T))
           } else {
             lowerLim.y <- floor(min(intdf$y, na.rm = T))
             upperLim.y <- ceiling(max(intdf$y, na.rm = T))
           }
-        } else {
-          lowerLim.y <- axisLimits.y[1]
-          upperLim.y <- axisLimits.y[2]
         }
       } else {
-        # ------------------------
-        # do we have glm? if so, get link family. make exceptions
-        # for specific models that don't have family function
-        # ------------------------
-        if (any(c.f == ""lme"")) 
-          fitfam <- """"
-        else
-          fitfam <- stats::family(fit)$family
-        # Label on y-axis is fixed
-        if (is.null(axisTitle.y)) {
-          # for logistic reg.
-          if (fitfam %in% c(""binomial"", ""quasibinomial""))
-            axisTitle.y <- ""Predicted Probability""
-          else if (fitfam %in% c(""poisson"", ""quasipoisson""))
-            axisTitle.y <- ""Predicted Incidents""
-        }
-        # -----------------------------------------------------------
-        # retrieve lowest and highest x and y position to determine
-        # the scale limits
-        # -----------------------------------------------------------
-        if (is.null(axisLimits.y)) {
-          if (fitfam %in% c(""binomial"", ""quasibinomial"")) {
-            lowerLim.y <- as.integer(10 * min(intdf$y, na.rm = T) * .9) / 10
-            upperLim.y <- as.integer(10 * max(intdf$y, na.rm = T) * 1.1) / 10
-          } else {
-            if (showCI) {
-              lowerLim.y <- floor(min(intdf$lower, na.rm = T))
-              upperLim.y <- ceiling(max(intdf$upper, na.rm = T))
-            } else {
-              lowerLim.y <- floor(min(intdf$y, na.rm = T))
-              upperLim.y <- ceiling(max(intdf$y, na.rm = T))
-            }
-          }
-        } else {
-          lowerLim.y <- axisLimits.y[1]
-          upperLim.y <- axisLimits.y[2]
-        }
-      }
-      # -----------------------------------------------------------
-      # check x-axis limits
-      # -----------------------------------------------------------
-      if (!is.null(axisLimits.x)) {
-        lowerLim.x <- axisLimits.x[1]
-        upperLim.x <- axisLimits.x[2]
-      } else {
-        lowerLim.x <- floor(min(intdf$x, na.rm = T))
-        upperLim.x <- ceiling(max(intdf$x, na.rm = T))
-      }
-      # -----------------------------------------------------------
-      # check whether user defined grid breaks / tick marks are used
-      # -----------------------------------------------------------
-      if (!is.null(gridBreaksAt)) {
-        gridbreaks.x <- c(seq(lowerLim.x, upperLim.x, by = gridBreaksAt))
-        gridbreaks.y <- c(seq(lowerLim.y, upperLim.y, by = gridBreaksAt))
-      }
-      # -----------------------------------------------------------
-      # prepare plot title and axis titles
-      # -----------------------------------------------------------
-      if (is.null(title)) {
-        labtitle <- paste0(""Interaction effect of "",
-                           moderator.name,
-                           "" and "",
-                           pred_x.name,
-                           "" on "", 
-                           response.name)
-      } else {
-        # copy plot counter 
-        l_nr <- i
-        # check if we have enough labels. if not, use last labels
-        if (l_nr > length(title)) l_nr <- length(title)
-        # set legend labels for plot
-        labtitle <- title[l_nr]
-      }
-      # -----------------------------------------------------------
-      # legend labels
-      # -----------------------------------------------------------
-      if (is.null(legendLabels)) {
-        lLabels <- levels(intdf$grp)
-      } else {
-        # copy plot counter 
-        l_nr <- i
-        # check if we have enough labels. if not, use last labels
-        if (l_nr > length(legendLabels)) l_nr <- length(legendLabels)
-        # set legend labels for plot
-        lLabels <- legendLabels[[l_nr]]
-      }
-      # -----------------------------------------------------------
-      # legend titles
-      # -----------------------------------------------------------
-      if (is.null(legendTitle)) {
-        lTitle <- moderator.name
-      } else {
-        # copy plot counter 
-        l_nr <- i
-        # check if we have enough legend titles, if not, use last legend title
-        if (l_nr > length(legendTitle)) l_nr <- length(legendTitle)
-        # set legend title for plot
-        lTitle <- legendTitle[l_nr]
-      }
-      # -----------------------------------------------------------
-      # x axis titles
-      # -----------------------------------------------------------
-      if (!is.null(axisTitle.x)) {
-        # copy plot counter 
-        l_nr <- i
-        # check if we have enough axis titles, if not, use last legend title
-        if (l_nr > length(axisTitle.x)) l_nr <- length(axisTitle.x)
-        # set axis title
-        labx <- axisTitle.x[l_nr]
-      }
-      if (!is.null(axisTitle.y)) laby <- axisTitle.y
-      # -----------------------------------------------------------
-      # wrap titles
-      # -----------------------------------------------------------
-      labtitle <- sjmisc::word_wrap(labtitle, breakTitleAt)
-      # wrap legend labels
-      lLabels <- sjmisc::word_wrap(lLabels, breakLegendLabelsAt)
-      # wrap legend title
-      lTitle <- sjmisc::word_wrap(lTitle, breakLegendTitleAt)
-      # ------------------------------------------------------------
-      # start plot
-      # ------------------------------------------------------------
-      baseplot <- ggplot(intdf, aes(x = x, y = y, colour = grp))
-      # ------------------------------------------------------------
-      # confidence interval?
-      # ------------------------------------------------------------
-      if (showCI) {
-        if (x_is_factor) {
-          # -------------------------------------------------
-          # for factors, we add error bars instead of
-          # continuous confidence region
-          # -------------------------------------------------
-          baseplot <- baseplot +
-            geom_errorbar(aes(ymin = lower, ymax = upper, colour = grp),
-                          width = 0,
-                          show.legend = FALSE) +
-            geom_point()
-        } else {
-          # -------------------------------------------------
-          # for continuous variables, we add  continuous 
-          # confidence region instead of error bars 
-          # -------------------------------------------------
-          baseplot <- baseplot +
-            geom_ribbon(aes(ymin = lower, ymax = upper, colour = NULL, fill = grp),
-                        alpha = fillAlpha,
-                        show.legend = FALSE)
-        }
-      }
-      baseplot <- baseplot + geom_line(size = geom.size)
-      # ------------------------------------------------------------
-      # plot value labels
-      # ------------------------------------------------------------
-      if (showValueLabels) {
-        # don't need geom_point, because point-layer already 
-        # added with x_is_factor
-        if (!x_is_factor) baseplot <- baseplot + geom_point()
-        # add value label text
-        baseplot <- baseplot +
-          geom_text(aes(label = round(y, 1)),
-                    vjust = 1.5,
-                    show.legend = FALSE)
+        lowerLim.y <- axisLimits.y[1]
+        upperLim.y <- axisLimits.y[2]
       }
-      # ------------------------------------------------------------------------------------
-      # build plot object with theme and labels
-      # ------------------------------------------------------------------------------------
-      baseplot <- baseplot +
-        # set plot and axis titles
-        labs(title = labtitle, x = labx, y = laby, colour = lTitle) +
-        # set axis scale breaks
-        scale_x_continuous(limits = c(lowerLim.x, upperLim.x), breaks = gridbreaks.x) +
-        scale_y_continuous(limits = c(lowerLim.y, upperLim.y), breaks = gridbreaks.y)
-      # ---------------------------------------------------------
-      # facet grids?
-      # ---------------------------------------------------------
-      if (facet.grid) baseplot <- baseplot + facet_grid(~grp)
-      # ---------------------------------------------------------
-      # set geom colors
-      # ---------------------------------------------------------
-      baseplot <- sj.setGeomColors(baseplot, 
-                                   geom.colors, 
-                                   length(unique(stats::na.omit(intdf$grp))), 
-                                   !is.null(lLabels), 
-                                   lLabels)
-      # ---------------------------------------------------------
-      # Check whether ggplot object should be returned or plotted
-      # ---------------------------------------------------------
-      if (printPlot) print(baseplot)
-      # concatenate plot object
-      plotlist[[length(plotlist) + 1]] <- baseplot
-      dflist[[length(dflist) + 1]] <- intdf
     }
-    # -------------------------------------
-    # return results
-    # -------------------------------------
-    invisible(structure(class = ""sjpint"",
-                        list(plot.list = plotlist,
-                             df.list = dflist)))
-  }
-  
-  
-  #' @importFrom stats quantile
-  mv_check <- function(moderatorValues, x) {
-    mvc <- length(unique(as.vector(stats::quantile(x, na.rm = T))))
-    if (moderatorValues == ""quart"" && mvc < 3) {
-      # tell user that quart won't work
-      message(""Could not compute quartiles, too small range of moderator variable. Defaulting 'moderatorValues' to 'minmax'."")
-      moderatorValues <- ""minmax""
+    # -----------------------------------------------------------
+    # check x-axis limits
+    # -----------------------------------------------------------
+    if (!is.null(axisLimits.x)) {
+      lowerLim.x <- axisLimits.x[1]
+      upperLim.x <- axisLimits.x[2]
+    } else {
+      lowerLim.x <- floor(min(intdf$x, na.rm = T))
+      upperLim.x <- ceiling(max(intdf$x, na.rm = T))
     }
-    return(moderatorValues)
-  }
-  
-  
-  # get all (significant) interaction terms from model
-  # the function ""getInteractionTerms"" checks if a fitted
-  # model contains any interaction terms that are significant
-  # at the level specified by ""plevel"". returns NULL, if model
-  # contains no interaction terms or no significant interaction term.
-  # else, information on model and interaction terms is returned
-  #' @importFrom stats model.matrix
-  getInteractionTerms <- function(fit, fun, plevel) {
     # -----------------------------------------------------------
-    # retrieve coefficients
+    # check whether user defined grid breaks / tick marks are used
     # -----------------------------------------------------------
-    coef.tab <- summary(fit)$coefficients
-    pval <- rep(0, times = nrow(coef.tab) - 1)
+    if (!is.null(gridBreaksAt)) {
+      gridbreaks.x <- seq(lowerLim.x, upperLim.x, by = gridBreaksAt)
+      gridbreaks.y <- seq(lowerLim.y, upperLim.y, by = gridBreaksAt)
+    }
     # -----------------------------------------------------------
-    # Help-function that removes AsIS I from formulas.
-    # If someone know regular expressions better than me,
-    # please provide a one-liner solution for the 3 sub commands.
+    # prepare plot title and axis titles
     # -----------------------------------------------------------
-    remove_I <- function(xnames) {
-      fpos <- grep(""I("", xnames, fixed = T)
-      if (length(fpos) > 0 && fpos > 0) {
-        xnames <- sub(""I("", """", xnames, fixed = T)
-        xnames <- sub("")"", """", xnames, fixed = T)
-        xnames <- sub("" * "", "":"", xnames, fixed = T)
-      }
-      return(xnames)
+    if (is.null(title)) {
+      labtitle <- paste0(""Interaction effect of "",
+                         moderator.name,
+                         "" and "",
+                         pred_x.name,
+                         "" on "", 
+                         response.name)
+    } else {
+      # copy plot counter 
+      l_nr <- i
+      # check if we have enough labels. if not, use last labels
+      if (l_nr > length(title)) l_nr <- length(title)
+      # set legend labels for plot
+      labtitle <- title[l_nr]
     }
     # -----------------------------------------------------------
-    # prepare values for (generalized) linear models
+    # legend labels
     # -----------------------------------------------------------
-    if (fun == ""lm"" || fun == ""glm"" || fun == ""plm"" || fun == ""lme"" || fun == ""gls"") {
-      # -----------------------------------------------------------
-      # retrieve amount and names of predictor variables and
-      # of dependent variable
-      # -----------------------------------------------------------
-      if (fun == ""plm"") {
-        # plm objects have different structure than (g)lm
-        depvar.label <- attr(attr(attr(fit$model, ""terms""), ""dataClasses""), ""names"")[1]
-        # retrieve model matrix
-        fitdat <- data.frame(cbind(as.vector(fit$model[, 1]), stats::model.matrix(fit)))
-      } else {
-        depvar.label <- attr(attr(fit$terms, ""dataClasses""), ""names"")[1]
-        # retrieve model matrix
-        fitdat <- data.frame(stats::model.matrix(fit))
-      }
-      # -----------------------------------------------------------
-      # retrieve p-values, without intercept
-      # -----------------------------------------------------------
-      if (ncol(coef.tab) > 3) pval <- coef.tab[-1, 4]
-      # -----------------------------------------------------------
-      # retrieve estimates, without intercept
-      # -----------------------------------------------------------
-      estimates <- coef.tab[-1, 1]
-      # -----------------------------------------------------------
-      # need to remove ""I(...)""?
-      # -----------------------------------------------------------
-      estimates.names <- names(estimates)
-      estimates.names <- remove_I(estimates.names)
-      it <- estimates.names
-      # -----------------------------------------------------------
-      # retrieve estimate of intercept
-      # -----------------------------------------------------------
-      b0 <- coef.tab[1, 1]
-      # -----------------------------------------------------------
-      # prepare values for (generalized) linear mixed effecrs models
-      # -----------------------------------------------------------
-    } else if (fun == ""lmer"" || fun == ""glmer"" || fun == ""nlmer"") {
-      # -----------------------------------------------------------
-      # retrieve amount and names of predictor variables and
-      # of dependent variable
-      # -----------------------------------------------------------
-      depvar.label <- colnames(fit@frame)[1]
-      # -----------------------------------------------------------
-      # retrieve p-values, without intercept
-      # -----------------------------------------------------------
-      pval <- get_lmerMod_pvalues(fit)[-1]
-      # -----------------------------------------------------------
-      # retrieve estimates, without intercept
-      # -----------------------------------------------------------
-      estimates <- unname(lme4::fixef(fit)[-1])
-      estimates.names <- names(lme4::fixef(fit)[-1])
-      # -----------------------------------------------------------
-      # retrieve model matrix with all relevant predictors
-      # -----------------------------------------------------------
-      fitdat <- stats::model.matrix(fit)
-      # -----------------------------------------------------------
-      # need to remove ""I(...)""?
-      # -----------------------------------------------------------
-      estimates.names <- remove_I(estimates.names)
-      it <- estimates.names
-      # -----------------------------------------------------------
-      # retrieve estimate of intercept
-      # -----------------------------------------------------------
-      b0 <- unname(lme4::fixef(fit)[1])
+    if (is.null(legendLabels)) {
+      lLabels <- levels(intdf$grp)
     } else {
-      stop(""Unsupported model-class. This type of regression is not yet supported by 'sjp.int'."", call. = F)
+      # copy plot counter 
+      l_nr <- i
+      # check if we have enough labels. if not, use last labels
+      if (l_nr > length(legendLabels)) l_nr <- length(legendLabels)
+      # set legend labels for plot
+      lLabels <- legendLabels[[l_nr]]
     }
     # -----------------------------------------------------------
-    # find all significant interactions
-    # we start looking for significant p-values beginning
-    # with the first interaction, not the first single term!
-    # thus, the starting point is first position after all single
-    # predictor variables
-    # -----------------------------------------------------------
-    # find interaction terms, which contains a colon, in row names
-    firstit <- grep("":"", it, fixed = TRUE)[1]
-    # check whether we have any interaction terms included at all
-    if (is.null(firstit) || is.na(firstit) || firstit == 0) {
-      warning(""No interaction term found in fitted model..."", call. = FALSE)
-      return(invisible(NULL))
+    # legend titles
+    # -----------------------------------------------------------
+    if (is.null(legendTitle)) {
+      lTitle <- moderator.name
+    } else {
+      # copy plot counter 
+      l_nr <- i
+      # check if we have enough legend titles, if not, use last legend title
+      if (l_nr > length(legendTitle)) l_nr <- length(legendTitle)
+      # set legend title for plot
+      lTitle <- legendTitle[l_nr]
     }
-    # save names of interaction predictor variables into this object
-    intnames <- c()
-    for (i in firstit:length(pval)) {
-      if (pval[i] < plevel) intnames <- c(intnames, it[i])
+    # -----------------------------------------------------------
+    # x axis titles
+    # -----------------------------------------------------------
+    if (!is.null(axisTitle.x)) {
+      # copy plot counter 
+      l_nr <- i
+      # check if we have enough axis titles, if not, use last legend title
+      if (l_nr > length(axisTitle.x)) l_nr <- length(axisTitle.x)
+      # set axis title
+      labx <- axisTitle.x[l_nr]
     }
-    # check for any signigicant interactions, stop if nothing found
-    if (is.null(intnames)) {
-      warning(""No significant interactions found... Try to adjust 'plevel' argument."", call. = FALSE)
-      return(invisible(NULL))
+    if (!is.null(axisTitle.y)) laby <- axisTitle.y
+    # -----------------------------------------------------------
+    # wrap titles
+    # -----------------------------------------------------------
+    labtitle <- sjmisc::word_wrap(labtitle, breakTitleAt)
+    # wrap legend labels
+    lLabels <- sjmisc::word_wrap(lLabels, breakLegendLabelsAt)
+    # wrap legend title
+    lTitle <- sjmisc::word_wrap(lTitle, breakLegendTitleAt)
+    # ------------------------------------------------------------
+    # start plot
+    # ------------------------------------------------------------
+    baseplot <- ggplot(intdf, aes(x = x, y = y, colour = grp))
+    # ------------------------------------------------------------
+    # confidence interval?
+    # ------------------------------------------------------------
+    if (showCI) {
+      if (x_is_factor) {
+        # -------------------------------------------------
+        # for factors, we add error bars instead of
+        # continuous confidence region
+        # -------------------------------------------------
+        baseplot <- baseplot +
+          geom_errorbar(aes(ymin = lower, ymax = upper, colour = grp),
+                        width = 0,
+                        show.legend = FALSE) +
+          geom_point()
+      } else {
+        # -------------------------------------------------
+        # for continuous variables, we add  continuous 
+        # confidence region instead of error bars 
+        # -------------------------------------------------
+        baseplot <- baseplot +
+          geom_ribbon(aes(ymin = lower, ymax = upper, colour = NULL, fill = grp),
+                      alpha = fillAlpha,
+                      show.legend = FALSE)
+      }
     }
-    return(list(intnames = intnames,
-                estimates = estimates,
-                estimates.names = estimates.names,
-                b0 = b0,
-                fitdat = fitdat,
-                depvar.label = depvar.label))
-  }
\ No newline at end of file
+    baseplot <- baseplot + geom_line(size = geom.size)
+    # ------------------------------------------------------------
+    # plot value labels
+    # ------------------------------------------------------------
+    if (showValueLabels) {
+      # don't need geom_point, because point-layer already 
+      # added with x_is_factor
+      if (!x_is_factor) baseplot <- baseplot + geom_point()
+      # add value label text
+      baseplot <- baseplot +
+        geom_text(aes(label = round(y, 1)),
+                  nudge_y = y.offset,
+                  show.legend = FALSE)
+    }
+    # ------------------------------------------------------------------------------------
+    # build plot object with theme and labels
+    # ------------------------------------------------------------------------------------
+    baseplot <- baseplot +
+      # set plot and axis titles
+      labs(title = labtitle, x = labx, y = laby, colour = lTitle) +
+      # set axis scale breaks
+      scale_x_continuous(limits = c(lowerLim.x, upperLim.x), breaks = gridbreaks.x) +
+      scale_y_continuous(limits = c(lowerLim.y, upperLim.y), breaks = gridbreaks.y)
+    # ---------------------------------------------------------
+    # facet grids?
+    # ---------------------------------------------------------
+    if (facet.grid) baseplot <- baseplot + facet_grid(~grp)
+    # ---------------------------------------------------------
+    # set geom colors
+    # ---------------------------------------------------------
+    baseplot <- sj.setGeomColors(baseplot, 
+                                 geom.colors, 
+                                 length(unique(stats::na.omit(intdf$grp))), 
+                                 !is.null(lLabels), 
+                                 lLabels)
+    # ---------------------------------------------------------
+    # Check whether ggplot object should be returned or plotted
+    # ---------------------------------------------------------
+    if (printPlot) print(baseplot)
+    # concatenate plot object
+    plotlist[[length(plotlist) + 1]] <- baseplot
+    dflist[[length(dflist) + 1]] <- intdf
+  }
+  # -------------------------------------
+  # return results
+  # -------------------------------------
+  invisible(structure(class = ""sjpint"",
+                      list(plot.list = plotlist,
+                           df.list = dflist)))
+}
+
+
+#' @importFrom stats quantile
+mv_check <- function(moderatorValues, x) {
+  mvc <- length(unique(as.vector(stats::quantile(x, na.rm = T))))
+  if (moderatorValues == ""quart"" && mvc < 3) {
+    # tell user that quart won't work
+    message(""Could not compute quartiles, too small range of moderator variable. Defaulting 'moderatorValues' to 'minmax'."")
+    moderatorValues <- ""minmax""
+  }
+  return(moderatorValues)
+}
+
+
+# get all (significant) interaction terms from model
+# the function ""getInteractionTerms"" checks if a fitted
+# model contains any interaction terms that are significant
+# at the level specified by ""plevel"". returns NULL, if model
+# contains no interaction terms or no significant interaction term.
+# else, information on model and interaction terms is returned
+#' @importFrom stats model.matrix
+getInteractionTerms <- function(fit, fun, plevel) {
+  # -----------------------------------------------------------
+  # retrieve coefficients
+  # -----------------------------------------------------------
+  coef.tab <- summary(fit)$coefficients
+  pval <- rep(0, times = nrow(coef.tab) - 1)
+  # -----------------------------------------------------------
+  # Help-function that removes AsIS I from formulas.
+  # If someone know regular expressions better than me,
+  # please provide a one-liner solution for the 3 sub commands.
+  # -----------------------------------------------------------
+  remove_I <- function(xnames) {
+    fpos <- grep(""I("", xnames, fixed = T)
+    if (length(fpos) > 0 && fpos > 0) {
+      xnames <- sub(""I("", """", xnames, fixed = T)
+      xnames <- sub("")"", """", xnames, fixed = T)
+      xnames <- sub("" * "", "":"", xnames, fixed = T)
+    }
+    return(xnames)
+  }
+  # -----------------------------------------------------------
+  # prepare values for (generalized) linear models
+  # -----------------------------------------------------------
+  if (fun == ""lm"" || fun == ""glm"" || fun == ""plm"" || fun == ""lme"" || fun == ""gls"") {
+    # -----------------------------------------------------------
+    # retrieve amount and names of predictor variables and
+    # of dependent variable
+    # -----------------------------------------------------------
+    if (fun == ""plm"") {
+      # plm objects have different structure than (g)lm
+      depvar.label <- attr(attr(attr(fit$model, ""terms""), ""dataClasses""), ""names"")[1]
+      # retrieve model matrix
+      fitdat <- data.frame(cbind(as.vector(fit$model[, 1]), stats::model.matrix(fit)))
+    } else {
+      depvar.label <- attr(attr(fit$terms, ""dataClasses""), ""names"")[1]
+      # retrieve model matrix
+      fitdat <- data.frame(stats::model.matrix(fit))
+    }
+    # -----------------------------------------------------------
+    # retrieve p-values, without intercept
+    # -----------------------------------------------------------
+    if (ncol(coef.tab) > 3) pval <- coef.tab[-1, 4]
+    # -----------------------------------------------------------
+    # retrieve estimates, without intercept
+    # -----------------------------------------------------------
+    estimates <- coef.tab[-1, 1]
+    # -----------------------------------------------------------
+    # need to remove ""I(...)""?
+    # -----------------------------------------------------------
+    estimates.names <- names(estimates)
+    estimates.names <- remove_I(estimates.names)
+    it <- estimates.names
+    # -----------------------------------------------------------
+    # retrieve estimate of intercept
+    # -----------------------------------------------------------
+    b0 <- coef.tab[1, 1]
+    # -----------------------------------------------------------
+    # prepare values for (generalized) linear mixed effecrs models
+    # -----------------------------------------------------------
+  } else if (fun == ""lmer"" || fun == ""glmer"" || fun == ""nlmer"") {
+    # -----------------------------------------------------------
+    # retrieve amount and names of predictor variables and
+    # of dependent variable
+    # -----------------------------------------------------------
+    depvar.label <- colnames(fit@frame)[1]
+    # -----------------------------------------------------------
+    # retrieve p-values, without intercept
+    # -----------------------------------------------------------
+    pval <- get_lmerMod_pvalues(fit)[-1]
+    # -----------------------------------------------------------
+    # retrieve estimates, without intercept
+    # -----------------------------------------------------------
+    estimates <- unname(lme4::fixef(fit)[-1])
+    estimates.names <- names(lme4::fixef(fit)[-1])
+    # -----------------------------------------------------------
+    # retrieve model matrix with all relevant predictors
+    # -----------------------------------------------------------
+    fitdat <- stats::model.matrix(fit)
+    # -----------------------------------------------------------
+    # need to remove ""I(...)""?
+    # -----------------------------------------------------------
+    estimates.names <- remove_I(estimates.names)
+    it <- estimates.names
+    # -----------------------------------------------------------
+    # retrieve estimate of intercept
+    # -----------------------------------------------------------
+    b0 <- unname(lme4::fixef(fit)[1])
+  } else {
+    stop(""Unsupported model-class. This type of regression is not yet supported by 'sjp.int'."", call. = F)
+  }
+  # -----------------------------------------------------------
+  # find all significant interactions
+  # we start looking for significant p-values beginning
+  # with the first interaction, not the first single term!
+  # thus, the starting point is first position after all single
+  # predictor variables
+  # -----------------------------------------------------------
+  # find interaction terms, which contains a colon, in row names
+  firstit <- grep("":"", it, fixed = TRUE)[1]
+  # check whether we have any interaction terms included at all
+  if (is.null(firstit) || is.na(firstit) || firstit == 0) {
+    warning(""No interaction term found in fitted model..."", call. = FALSE)
+    return(invisible(NULL))
+  }
+  # save names of interaction predictor variables into this object
+  intnames <- c()
+  for (i in firstit:length(pval)) {
+    if (pval[i] < plevel) intnames <- c(intnames, it[i])
+  }
+  # check for any signigicant interactions, stop if nothing found
+  if (is.null(intnames)) {
+    warning(""No significant interactions found... Try to adjust 'plevel' argument."", call. = FALSE)
+    return(invisible(NULL))
+  }
+  return(list(intnames = intnames,
+              estimates = estimates,
+              estimates.names = estimates.names,
+              b0 = b0,
+              fitdat = fitdat,
+              depvar.label = depvar.label))
+}
\ No newline at end of file

---FILE: R/sjPlotPCA.R---
@@ -237,8 +237,8 @@ sjp.pca <- function(data,
                  label = sprintf(""Factors: %i"", pcadata.kaiser), 
                  x = Inf, 
                  y = Inf, 
-                 vjust = 2, 
-                 hjust = 1.2) +
+                 vjust = ""top"", 
+                 hjust = ""top"") +
         scale_x_continuous(breaks = c(seq(1, nrow(mydat), by = 2))) +
         labs(title = NULL, y = ""Eigenvalue"", x = ""Number of factors"")
     plot(eigenplot)
@@ -450,7 +450,7 @@ sjp.pca <- function(data,
   # --------------------------------------------------------
   remdf <- NULL
   if (class(data) == ""data.frame"") {
-    message(""Following items have been removed:"")
+    message(""Following items have no clear factor loading:"")
     if (!is.null(removableItems)) {
       message(colnames(data)[removableItems])
       remdf <- data[, c(-removableItems)]

---FILE: README.md---
@@ -47,6 +47,8 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 * Improved text label positioning for plotting functions.
 * Plotting functions now get an argument `y.offset` to specify an offset for text labels from geoms.
 * `sjp.int` now fits the y-axis to the required range for predicted probabilities for logistic regressions instead of always using a range from 0 to 1, even for smaller effects ([#86](https://github.com/sjPlot/devel/issues/86)).
+* `sjp.glmer` and `sjp.lmer` get a `axisLimits.y` argument to specify y-axis limits specifically for predicted probability or effect plots.
+
 
 #### Bug fixes
 * `sjp.int` did not work with fitted models from class `lme`.

---FILE: man/sjp.aov1.Rd---
@@ -4,15 +4,14 @@
 \alias{sjp.aov1}
 \title{Plot One-Way-Anova tables}
 \usage{
-sjp.aov1(depVar, grpVar, meansums = FALSE, type = ""dots"",
-  hideErrorBars = FALSE, title = NULL, axisLabels.y = NULL,
-  reverseOrder = FALSE, stringIntercept = ""(Intercept)"",
-  showAxisLabels.y = TRUE, axisTitle.x = """", axisLimits = NULL,
-  errorBarColor = NULL, geom.colors = c(""#3366a0"", ""#aa3333""),
-  geom.size = 3, breakTitleAt = 50, breakLabelsAt = 25,
+sjp.aov1(depVar, grpVar, meansums = FALSE, title = NULL,
+  axisLabels.y = NULL, reverseOrder = FALSE,
+  stringIntercept = ""(Intercept)"", showAxisLabels.y = TRUE,
+  axisTitle.x = """", axisLimits = NULL, geom.colors = c(""#3366a0"",
+  ""#aa3333""), geom.size = 3, breakTitleAt = 50, breakLabelsAt = 25,
   gridBreaksAt = NULL, expand.grid = FALSE, showValueLabels = TRUE,
-  labelDigits = 2, showPValueLabels = TRUE, showModelSummary = FALSE,
-  printPlot = TRUE)
+  labelDigits = 2, y.offset = 0.1, showPValueLabels = TRUE,
+  showModelSummary = FALSE, printPlot = TRUE)
 }
 \arguments{
 \item{depVar}{dependent variable. Will be used with following formula:
@@ -25,12 +24,6 @@ sjp.aov1(depVar, grpVar, meansums = FALSE, type = ""dots"",
 If \code{FALSE} (default), the values are reported in the standard way, i.e. the values indicate the difference of
 the group mean in relation to the intercept (reference group).}
 
-\item{type}{plot type, whether group means should be plotted as \code{""dots""} (aka forest plots, default)
-or as \code{""bars""}}
-
-\item{hideErrorBars}{logical, if \code{TRUE}, the error bars that indicate the confidence intervals of the group means are not
-shown. Only applies if argument \code{type} is \code{""bars""}. Default value is \code{FALSE}.}
-
 \item{title}{plot title as string. Example: \code{title = ""my title""}.
 Use \code{NULL} to automatically detect variable names that will be used as title
 (see \code{\link[sjmisc]{set_label}}) for details). If \code{title = """"},
@@ -56,11 +49,6 @@ for details).}
 By default, the limits range from the lowest confidence interval to the 
 highest, so plot has maximum zoom.}
 
-\item{errorBarColor}{The color of the error bars that indicate the confidence intervalls
-of the group means. Default is \code{NULL}, which means that if \code{type = ""dots""},
-the \code{pointColor} value will be used as errorbar color. In case \code{type = ""bars""},
-\code{""black""} will be used as errorbar color.}
-
 \item{geom.colors}{vector of length two, indicating the colors of the points resp. 
 bars (depending on \code{type}); first value is for groups with positive 
 means and the second for negative means.}
@@ -87,6 +75,9 @@ to each dot or not.}
 \item{labelDigits}{amount of digits for rounding the estimates (see \code{showValueLabels}).
 Default is 2, i.e. estimates have 2 digits after decimal point.}
 
+\item{y.offset}{numeric, offset for text labels when their alignment is adjusted 
+to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
+
 \item{showPValueLabels}{logical, whether the significance level of each coefficient
 should be appended to values or not.}
 
@@ -116,14 +107,6 @@ data(efc)
 sjp.aov1(efc$c12hour, efc$e42dep)
 
 
-# bar-plot, don't use this!
-# however, if you dare to, adjust
-# 'geom.size'...
-sjp.aov1(efc$c12hour,
-         efc$c172code,
-         type = ""bars"",
-         geom.size = 0.5)
-
 }
 \seealso{
 \code{\link{sjt.grpmean}}

---FILE: man/sjp.glmer.Rd---
@@ -8,12 +8,13 @@ sjp.glmer(fit, type = ""re"", vars = NULL, ri.nr = NULL, emph.grp = NULL,
   title = NULL, geom.size = NULL, geom.colors = ""Set1"",
   hideErrorBars = FALSE, showIntercept = TRUE,
   stringIntercept = ""(Intercept)"", sort.coef = NULL, pred.labels = NULL,
-  axisTitle.x = NULL, axisTitle.y = NULL, facet.grid = TRUE,
-  free.scale = FALSE, interceptLineType = 2,
+  axisTitle.x = NULL, axisTitle.y = NULL, axisLimits.y = NULL,
+  facet.grid = TRUE, free.scale = FALSE, interceptLineType = 2,
   interceptLineColor = ""grey70"", remove.estimates = NULL,
-  showValueLabels = TRUE, labelDigits = 2, showPValueLabels = TRUE,
-  fade.ns = FALSE, show.ci = FALSE, sample.n = NULL,
-  show.legend = FALSE, printPlot = TRUE, show.se = FALSE)
+  showValueLabels = TRUE, labelDigits = 2, y.offset = 0.1,
+  showPValueLabels = TRUE, fade.ns = FALSE, show.ci = FALSE,
+  sample.n = NULL, show.legend = FALSE, printPlot = TRUE,
+  show.se = FALSE)
 }
 \arguments{
 \item{fit}{a fitted model as returned by the \code{\link[lme4]{glmer}}-function.}
@@ -87,6 +88,10 @@ on the plot type is chosen.}
 \item{axisTitle.y}{title for the y axis. If not specified, a default labelling depending
 on the plot type is chosen.}
 
+\item{axisLimits.y}{numeric vector of length two, defining lower and upper axis limits
+of the y scale. By default, this argument is set to \code{NULL}, i.e. the 
+y-axis fits to the required range of the data.}
+
 \item{facet.grid}{\code{TRUE} when each plot should be plotted separately instead of
 an integrated (faceted) single graph.}
 
@@ -108,6 +113,9 @@ is \code{NULL}, i.e. all estimates are printed.}
 \item{labelDigits}{numeric, amount of digits for rounding the estimates (see \code{showValueLabels}).
 Default is 2, i.e. estimates have 2 digits after decimal point.}
 
+\item{y.offset}{numeric, offset for text labels when their alignment is adjusted 
+to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
+
 \item{showPValueLabels}{logical, whether the significance levels of each coefficient should be appended
 to values or not.}
 

---FILE: man/sjp.int.Rd---
@@ -11,8 +11,9 @@ sjp.int(fit, type = ""cond"", int.term = NULL, int.plot.index = NULL,
   axisTitle.y = NULL, axisLabels.x = NULL, legendTitle = NULL,
   legendLabels = NULL, showValueLabels = FALSE, breakTitleAt = 50,
   breakLegendLabelsAt = 20, breakLegendTitleAt = 20, axisLimits.x = NULL,
-  axisLimits.y = NULL, gridBreaksAt = NULL, showCI = FALSE,
-  valueLabel.digits = 2, facet.grid = FALSE, printPlot = TRUE)
+  axisLimits.y = NULL, y.offset = 0.07, gridBreaksAt = NULL,
+  showCI = FALSE, valueLabel.digits = 2, facet.grid = FALSE,
+  printPlot = TRUE)
 }
 \arguments{
 \item{fit}{the fitted (generalized) linear (mixed) model object, including interaction terms. Accepted model
@@ -127,6 +128,9 @@ are displayed in one line and when a line break is inserted.}
 of the y scale. By default, this argument is set to \code{NULL}, i.e. the 
 y-axis fits to the required range of the data.}
 
+\item{y.offset}{numeric, offset for text labels when their alignment is adjusted 
+to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
+
 \item{gridBreaksAt}{set breaks for the axis, i.e. at every \code{gridBreaksAt}'th 
 position a major grid is being printed.}
 

---FILE: man/sjp.lmer.Rd---
@@ -8,14 +8,14 @@ sjp.lmer(fit, type = ""re"", vars = NULL, ri.nr = NULL, emph.grp = NULL,
   title = NULL, geom.size = NULL, geom.colors = ""Set1"",
   hideErrorBars = FALSE, showIntercept = TRUE,
   stringIntercept = ""(Intercept)"", sort.coef = NULL, pred.labels = NULL,
-  axisTitle.x = NULL, axisTitle.y = NULL, interceptLineType = 2,
-  interceptLineColor = ""grey70"", remove.estimates = NULL,
-  showValueLabels = TRUE, labelDigits = 2, showPValueLabels = TRUE,
-  facet.grid = TRUE, free.scale = FALSE, fade.ns = FALSE,
-  show.ci = TRUE, pointAlpha = 0.2, showScatterPlot = TRUE,
-  showLoess = FALSE, showLoessCI = FALSE, poly.term = NULL,
-  sample.n = NULL, show.legend = FALSE, printPlot = TRUE,
-  show.se = TRUE)
+  axisTitle.x = NULL, axisTitle.y = NULL, axisLimits.y = NULL,
+  interceptLineType = 2, interceptLineColor = ""grey70"",
+  remove.estimates = NULL, showValueLabels = TRUE, labelDigits = 2,
+  y.offset = 0.1, showPValueLabels = TRUE, facet.grid = TRUE,
+  free.scale = FALSE, fade.ns = FALSE, show.ci = TRUE, pointAlpha = 0.2,
+  showScatterPlot = TRUE, showLoess = FALSE, showLoessCI = FALSE,
+  poly.term = NULL, sample.n = NULL, show.legend = FALSE,
+  printPlot = TRUE, show.se = TRUE)
 }
 \arguments{
 \item{fit}{a fitted model as returned by the \code{\link[lme4]{lmer}}-function.}
@@ -93,6 +93,10 @@ on the plot type is chosen.}
 \item{axisTitle.y}{title for the y axis. If not specified, a default labelling depending
 on the plot type is chosen.}
 
+\item{axisLimits.y}{numeric vector of length two, defining lower and upper axis limits
+of the y scale. By default, this argument is set to \code{NULL}, i.e. the 
+y-axis fits to the required range of the data.}
+
 \item{interceptLineType}{linetype of the intercept line (zero point). Default is \code{2} (dashed line).}
 
 \item{interceptLineColor}{color of the intercept line. Default value is \code{""grey70""}.}
@@ -107,6 +111,9 @@ is \code{NULL}, i.e. all estimates are printed.}
 \item{labelDigits}{numeric, amount of digits for rounding the estimates (see \code{showValueLabels}).
 Default is 2, i.e. estimates have 2 digits after decimal point.}
 
+\item{y.offset}{numeric, offset for text labels when their alignment is adjusted 
+to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
+
 \item{showPValueLabels}{logical, whether the significance levels of each coefficient should be appended
 to values or not.}
 "
strengejacke,sjPlot,9093321616980b087d335deebe16f13dc9f1b9ba,Daniel Ldecke,d.luedecke@uke.de,2016-01-27T07:52:03Z,Daniel Ldecke,d.luedecke@uke.de,2016-01-27T07:52:03Z,minor fixes,NEWS;R/helpfunctions.R;R/sjTabPropTable.R;README.md;man/sjp.frq.Rd;man/sjp.glm.Rd;man/sjp.grpfrq.Rd;man/sjp.lm.Rd;man/sjp.xtab.Rd,False,True,True,False,75,38,113,"---FILE: NEWS---
@@ -7,6 +7,10 @@ Changes to functions:
 
 Bug fixes:
 * `sjp.int` did not work with fitted models from class `lme`.
+* `sjt.xtab` did not show `NA` values for `showNA = TRUE`.
+* Due to rounding, total percentage in `sjt.xtab` could differ from 100%.
+* Minor fixes.
+
 
 Version 1.9
 -----------------------------------------------------------------------------

---FILE: R/helpfunctions.R---
@@ -229,15 +229,17 @@ create.xtab.df <- function(x,
     if (na.rm) {
       mydat <- stats::ftable(table(x_full, grp_full))
     } else {
-      mydat <- stats::ftable(table(x_full, grp_full), exclude = NULL)
+      mydat <- stats::ftable(table(x_full, grp_full, exclude = NULL))
     }
   } else {
     x <- suppressWarnings(sjmisc::to_value(x, keep.labels = T))
     grp <- suppressWarnings(sjmisc::to_value(grp, keep.labels = T))
     if (na.rm)
       mydat <- stats::ftable(round(stats::xtabs(weightBy ~ x + grp)), 0)
     else
-      mydat <- stats::ftable(round(stats::xtabs(weightBy ~ x + grp, exclude = NULL, na.action = stats::na.pass)), 0)
+      mydat <- stats::ftable(round(stats::xtabs(weightBy ~ x + grp, 
+                                                exclude = NULL, 
+                                                na.action = stats::na.pass)), 0)
   }
   # create proportional tables, cell values
   proptab.cell <- round(100 * prop.table(mydat), round.prz)
@@ -252,6 +254,8 @@ create.xtab.df <- function(x,
   # add total row and column to cell percentages afterwards
   proptab.cell <- rbind(as.data.frame(as.matrix(proptab.cell)), colSums(proptab.cell))
   proptab.cell <- cbind(as.data.frame(as.matrix(proptab.cell)), rowSums(proptab.cell))
+  # due to roundings, total might differ from 100%, so clean this here
+  proptab.cell[nrow(proptab.cell), ncol(proptab.cell)] <- 100
   colnames(proptab.cell)[ncol(proptab.cell)] <- ""total""
   rownames(proptab.cell)[nrow(proptab.cell)] <- ""total""
   # convert to data frame

---FILE: R/sjTabPropTable.R---
@@ -388,21 +388,40 @@ sjt.xtab <- function(var.row,
     if (nrow(tab) > 2 || ncol(tab) > 2) {
       kook <- sprintf(""&Phi;<sub>c</sub>=%.3f"", sjmisc::cramer(tab))
       # if minimum expected values below 5, compute fisher's exact test
-      if (min(tab.expected) < 5 || (min(tab.expected) < 10 && chsq$parameter == 1)) fish <- fisher.test(tab, simulate.p.value = TRUE)
+      if (min(tab.expected) < 5 || (min(tab.expected) < 10 && chsq$parameter == 1)) 
+        fish <- fisher.test(tab, simulate.p.value = TRUE)
     } else {
       kook <- sprintf(""&Phi;=%.3f"", sjmisc::phi(tab))
       # if minimum expected values below 5 and df=1, compute fisher's exact test
-      if (min(tab.expected) < 5 || (min(tab.expected) < 10 && chsq$parameter == 1)) fish <- fisher.test(tab)
+      if (min(tab.expected) < 5 || (min(tab.expected) < 10 && chsq$parameter == 1)) 
+        fish <- fisher.test(tab)
     }
     # make phi-value apa style
     kook <- gsub(""0."", paste0(p_zero, "".""), kook, fixed = TRUE)
     # create summary row
     if (is.null(fish)) {
-      pvalstring <- ifelse(chsq$p.value < 0.001, sprintf(""p&lt;%s.001"", p_zero), sub(""0"", p_zero, sprintf(""p=%.3f"", chsq$p.value)))
-      page.content <- paste(page.content, sprintf(""    <td class=\""summary tdata\"" colspan=\""%i\"">&Chi;<sup>2</sup>=%.3f &middot; df=%i &middot; %s &middot; %s</td>"", totalncol + 1, chsq$statistic, chsq$parameter, kook, pvalstring), sep = """")
+      pvalstring <- ifelse(chsq$p.value < 0.001, 
+                           sprintf(""p&lt;%s.001"", p_zero), 
+                           sub(""0"", p_zero, sprintf(""p=%.3f"", chsq$p.value)))
+      page.content <- paste(page.content, 
+                            sprintf(""    <td class=\""summary tdata\"" colspan=\""%i\"">&Chi;<sup>2</sup>=%.3f &middot; df=%i &middot; %s &middot; %s</td>"", 
+                                    totalncol + 1, 
+                                    chsq$statistic, 
+                                    chsq$parameter, 
+                                    kook, 
+                                    pvalstring), 
+                            sep = """")
     } else {
-      pvalstring <- ifelse(fish$p.value < 0.001, sprintf(""p&lt;%s.001"", p_zero), sub(""0"", p_zero, sprintf(""p=%.3f"", fish$p.value)))
-      page.content <- paste(page.content, sprintf(""    <td class=\""summary tdata\"" colspan=\""%i\"">Fisher's %s &middot; df=%i &middot; %s</td>"", totalncol, pvalstring, chsq$parameter, kook), sep = """")
+      pvalstring <- ifelse(fish$p.value < 0.001, 
+                           sprintf(""p&lt;%s.001"", p_zero), 
+                           sub(""0"", p_zero, sprintf(""p=%.3f"", fish$p.value)))
+      page.content <- paste(page.content, 
+                            sprintf(""    <td class=\""summary tdata\"" colspan=\""%i\"">Fisher's %s &middot; df=%i &middot; %s</td>"", 
+                                    totalncol + 1, 
+                                    pvalstring, 
+                                    chsq$parameter, 
+                                    kook), 
+                            sep = """")
     }
     # close table row
     page.content <- paste(page.content, ""\n  </tr>\n"")

---FILE: README.md---
@@ -50,7 +50,9 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 
 #### Bug fixes
 * `sjp.int` did not work with fitted models from class `lme`.
-
+* `sjt.xtab` did not show `NA` values for `showNA = TRUE`.
+* Due to rounding, total percentage in `sjt.xtab` could differ from 100%.
+* Minor fixes.
 
 ### Changelog of latest stable build 1.9
 

---FILE: man/sjp.frq.Rd---
@@ -19,8 +19,8 @@ sjp.frq(varCount, title = """", weightBy = NULL, weightByTitleString = NULL,
   meanInterceptLineType = 2, meanInterceptLineSize = 0.5,
   normalCurveColor = ""red"", normalCurveSize = 0.8, normalCurveAlpha = 0.4,
   axisTitle.x = NULL, axisTitle.y = NULL, autoGroupAt = NULL,
-  coord.flip = FALSE, vjust = ""bottom"", hjust = ""center"", na.rm = TRUE,
-  printPlot = TRUE)
+  coord.flip = FALSE, vjust = ""bottom"", hjust = ""center"",
+  y.offset = NULL, na.rm = TRUE, printPlot = TRUE)
 }
 \arguments{
 \item{varCount}{a vector of values (variable) describing the bars which make up the plot.}
@@ -195,6 +195,9 @@ labels. Allowed are same values as for \code{vjust} aesthetics from
 new options like ""inward"" and ""outward"", which align text towards and 
 away from the center of the plot respectively.}
 
+\item{y.offset}{numeric, offset for text labels when their alignment is adjusted 
+to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
+
 \item{na.rm}{logical, if \code{TRUE}, missings are not included in the frequency plot.}
 
 \item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't

---FILE: man/sjp.glm.Rd---
@@ -8,20 +8,19 @@ sjp.glm(fit, type = ""dots"", sortOdds = TRUE, title = NULL,
   axisLabels.y = NULL, axisTitle.x = ""Odds Ratios"", axisLimits = NULL,
   breakTitleAt = 50, breakLabelsAt = 25, gridBreaksAt = 0.5,
   transformTicks = TRUE, geom.size = NULL, geom.colors = ""Set1"",
-  hideErrorBars = FALSE, interceptLineType = 2,
-  interceptLineColor = ""grey70"", remove.estimates = NULL,
-  coord.flip = TRUE, showIntercept = FALSE, showAxisLabels.y = TRUE,
-  showValueLabels = TRUE, labelDigits = 2, showPValueLabels = TRUE,
-  showModelSummary = FALSE, facet.grid = TRUE, show.ci = FALSE,
-  showOriginalModelOnly = TRUE, printPlot = TRUE, show.se = FALSE)
+  interceptLineType = 2, interceptLineColor = ""grey70"",
+  remove.estimates = NULL, coord.flip = TRUE, y.offset = 0.1,
+  showIntercept = FALSE, showAxisLabels.y = TRUE, showValueLabels = TRUE,
+  labelDigits = 2, showPValueLabels = TRUE, showModelSummary = FALSE,
+  facet.grid = TRUE, show.ci = FALSE, showOriginalModelOnly = TRUE,
+  printPlot = TRUE, show.se = FALSE)
 }
 \arguments{
 \item{fit}{fitted generalized linear model (\code{\link{glm}}- or \code{logistf}-object).}
 
 \item{type}{type of plot. Use one of following:
 \describe{
   \item{\code{""dots""}}{(or \code{""glm""} or \code{""or""} (default)) for odds ratios (forest plot)}
-  \item{\code{""bars""}}{for odds ratios as bar plot}
   \item{\code{""prob""}}{(or \code{""pc""}) to plot predicted probabilities for each model term, where all remaining co-variates are set to zero (i.e. ignored). Use \code{facet.grid} to decide whether to plot each coefficient as separate plot or as integrated faceted plot.}
   \item{\code{""eff""}}{to plot marginal effects of predicted probabilities for each model term, where all remaining co-variates are set to the mean (see 'Details'). Use \code{facet.grid} to decide whether to plot each coefficient as separate plot or as integrated faceted plot.}
   \item{\code{""y.pc""}}{(or \code{""y.prob""}) to plot predicted probabilities for the response. See 'Details'.}
@@ -67,10 +66,6 @@ higher odds ratio values.}
 \item{geom.colors}{color palette for geoms. Must either be vector with two color values
 or a specific color palette code. See 'Note' in \code{\link{sjp.grpfrq}}.}
 
-\item{hideErrorBars}{logical, if \code{TRUE}, the error bars that indicate the 
-confidence intervals of the odds ratios are not shown. Only applies 
-if argument \code{type = ""bars""}. Default value is \code{FALSE}.}
-
 \item{interceptLineType}{linetype of the intercept line (zero point). Default is \code{2} (dashed line).}
 
 \item{interceptLineColor}{color of the intercept line. Default value is \code{""grey70""}.}
@@ -83,6 +78,9 @@ is \code{NULL}, i.e. all estimates are printed.}
 \item{coord.flip}{logical, if \code{TRUE} (default), predictors are plotted along the y-axis and estimate
 values are plotted on the x-axis.}
 
+\item{y.offset}{numeric, offset for text labels when their alignment is adjusted 
+to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
+
 \item{showIntercept}{logical, if \code{TRUE}, the intercept of the fitted model is also plotted.
 Default is \code{FALSE}. Please note that due to exponential transformation of
 estimates, the intercept in some cases can not be calculated, thus the
@@ -122,7 +120,7 @@ want to plot any graphs. In either case, the ggplot-object will be returned as v
 (Invisibly) returns various objects, depending on 
           the \code{type}-argument:
         \describe{
-         \item{\code{type = ""dots"" or ""bars""}}{
+         \item{\code{type = ""dots""}}{
            \itemize{
              \item \code{df} - data frame used for the plot
              \item \code{plot} - plot as ggplot-object
@@ -188,9 +186,6 @@ fitOR <- glm(y ~ swiss$Education + swiss$Examination + swiss$Infant.Mortality +
 # print Odds Ratios as dots
 sjp.glm(fitOR)
 
-# print Odds Ratios as bars
-sjp.glm(fitOR, type = ""bars"", geom.size = .3)
-
 
 # -------------------------------
 # Predictors for negative impact

---FILE: man/sjp.grpfrq.Rd---
@@ -18,8 +18,8 @@ sjp.grpfrq(varCount, varGroup, weightBy = NULL, weightByTitleString = NULL,
   showAxisLabels.y = TRUE, showPlotAnnotation = TRUE,
   showTableSummary = FALSE, showGroupCount = FALSE, tableSummaryPos = ""r"",
   axisTitle.x = """", axisTitle.y = """", autoGroupAt = NULL,
-  coord.flip = FALSE, vjust = ""bottom"", hjust = ""center"", na.rm = TRUE,
-  printPlot = TRUE)
+  coord.flip = FALSE, vjust = ""bottom"", hjust = ""center"",
+  y.offset = NULL, na.rm = TRUE, printPlot = TRUE)
 }
 \arguments{
 \item{varCount}{a vector of values (variable) describing the bars which make up the plot.}
@@ -184,6 +184,9 @@ labels. Allowed are same values as for \code{vjust} aesthetics from
 new options like ""inward"" and ""outward"", which align text towards and 
 away from the center of the plot respectively.}
 
+\item{y.offset}{numeric, offset for text labels when their alignment is adjusted 
+to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
+
 \item{na.rm}{logical, if \code{TRUE}, missings are not included in the frequency plot.}
 
 \item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't

---FILE: man/sjp.lm.Rd---
@@ -14,7 +14,7 @@ sjp.lm(fit, type = ""lm"", sort.est = TRUE, title = NULL,
   labelDigits = 2, showPValueLabels = TRUE, showModelSummary = FALSE,
   showCI = TRUE, pointAlpha = 0.2, showScatterPlot = TRUE,
   showLoess = FALSE, showLoessCI = FALSE, show.legend = FALSE,
-  poly.term = NULL, showOriginalModelOnly = TRUE,
+  y.offset = 0.1, poly.term = NULL, showOriginalModelOnly = TRUE,
   completeDiagnostic = FALSE, printPlot = TRUE)
 }
 \arguments{
@@ -134,6 +134,9 @@ or \code{type = ""fe.resid""}).}
 the random intercept is shown. For \code{lm} and \code{glm}, 
 a legend for grouped estimates is shown.}
 
+\item{y.offset}{numeric, offset for text labels when their alignment is adjusted 
+to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
+
 \item{poly.term}{name of a polynomial term in \code{fit} as string. Needs to be
 specified, if \code{type = ""poly""}, in order to plot marginal effects
 for polynomial terms. See 'Examples'.}

---FILE: man/sjp.xtab.Rd---
@@ -8,15 +8,16 @@ sjp.xtab(x, grp, title = """", legendTitle = NULL, weightBy = NULL,
   weightByTitleString = NULL, type = ""bars"", tableIndex = ""col"",
   reverseOrder = FALSE, axisLimits.y = NULL, axisLabels.x = NULL,
   legendLabels = NULL, vjust = ""bottom"", hjust = ""center"",
-  stringTotal = ""Total"", breakTitleAt = 50, breakLabelsAt = 15,
-  breakLegendTitleAt = 20, breakLegendLabelsAt = 20, gridBreaksAt = 0.2,
-  geom.size = 0.7, geom.spacing = 0.1, geom.colors = ""Paired"",
-  barPosition = ""dodge"", lineDotSize = 3, smoothLines = FALSE,
-  expand.grid = FALSE, showValueLabels = TRUE, showCountValues = TRUE,
-  showPercentageValues = TRUE, showCategoryLabels = TRUE,
-  showTableSummary = FALSE, tableSummaryPos = ""r"", showTotalColumn = TRUE,
-  hideLegend = FALSE, axisTitle.x = NULL, axisTitle.y = NULL,
-  coord.flip = FALSE, printPlot = TRUE)
+  y.offset = NULL, stringTotal = ""Total"", breakTitleAt = 50,
+  breakLabelsAt = 15, breakLegendTitleAt = 20, breakLegendLabelsAt = 20,
+  gridBreaksAt = 0.2, geom.size = 0.7, geom.spacing = 0.1,
+  geom.colors = ""Paired"", barPosition = ""dodge"", lineDotSize = 3,
+  smoothLines = FALSE, expand.grid = FALSE, showValueLabels = TRUE,
+  showCountValues = TRUE, showPercentageValues = TRUE,
+  showCategoryLabels = TRUE, showTableSummary = FALSE,
+  tableSummaryPos = ""r"", showTotalColumn = TRUE, hideLegend = FALSE,
+  axisTitle.x = NULL, axisTitle.y = NULL, coord.flip = FALSE,
+  printPlot = TRUE)
 }
 \arguments{
 \item{x}{a vector of values (variable) describing the bars which make up the plot.}
@@ -72,6 +73,9 @@ labels. Allowed are same values as for \code{vjust} aesthetics from
 new options like ""inward"" and ""outward"", which align text towards and 
 away from the center of the plot respectively.}
 
+\item{y.offset}{numeric, offset for text labels when their alignment is adjusted 
+to the top/bottom of the geom (see \code{hjust} and \code{vjust}).}
+
 \item{stringTotal}{string for the legend label when a total-column is added. Only applies
 if \code{showTotalColumn = TRUE}. Default is \code{""Total""}.}
 "
strengejacke,sjPlot,5b378716322146e2e0a166cb2fbf7ff582bbb61a,Daniel Ldecke,d.luedecke@uke.de,2016-01-26T06:44:14Z,Daniel Ldecke,d.luedecke@uke.de,2016-01-26T06:44:14Z,further CRAN check issues fixed,R/sjPlotScatter.R;man/sjp.scatter.Rd,False,True,True,False,4,10,14,"---FILE: R/sjPlotScatter.R---
@@ -42,9 +42,7 @@
 #'          confidence interval of the fitted lines will be added.
 #' @param fitmethod By default, a linear method (\code{""lm""}) is used for fitting
 #'          the fit lines. Possible values are for instance \code{""lm""}, \code{""glm""},
-#'          \code{""loess""} or \code{""auto""}
-#'          (see \href{http://docs.ggplot2.org/current/stat_smooth.html}{ggplot-docs}
-#'          for more details).
+#'          \code{""loess""} or \code{""auto""}.
 #' @param useJitter logical, if \code{TRUE}, points will be jittered (to avoid overplotting).
 #' @param autojitter logical, if \code{TRUE}, points will be jittered according
 #'          to an overlap-estimation. A matrix of \code{x} and \code{y} values
@@ -57,8 +55,7 @@
 #'          they are automatically jittered. Default is 0.15. Valid values range
 #'          between 0 and 1.
 #' @param showRug logical, if \code{TRUE}, a marginal rug plot is displayed
-#'          in the graph (see \href{http://docs.ggplot2.org/current/geom_rug.html}{ggplot-docs}
-#'          for more details).
+#'          in the graph.
 #' @param facet.grid \code{TRUE} when each scatter plot group should be plotted as single facet instead of
 #'          an integrated single graph. Only applies if \code{grp} is not \code{NULL}. Each category of
 #'          \code{grp} will be plotted in an own facet.

---FILE: man/sjp.scatter.Rd---
@@ -82,9 +82,7 @@ confidence interval of the fitted lines will be added.}
 
 \item{fitmethod}{By default, a linear method (\code{""lm""}) is used for fitting
 the fit lines. Possible values are for instance \code{""lm""}, \code{""glm""},
-\code{""loess""} or \code{""auto""}
-(see \href{http://docs.ggplot2.org/current/stat_smooth.html}{ggplot-docs}
-for more details).}
+\code{""loess""} or \code{""auto""}.}
 
 \item{useJitter}{logical, if \code{TRUE}, points will be jittered (to avoid overplotting).}
 
@@ -101,8 +99,7 @@ they are automatically jittered. Default is 0.15. Valid values range
 between 0 and 1.}
 
 \item{showRug}{logical, if \code{TRUE}, a marginal rug plot is displayed
-in the graph (see \href{http://docs.ggplot2.org/current/geom_rug.html}{ggplot-docs}
-for more details).}
+in the graph.}
 
 \item{hideLegend}{logical, indicates whether legend (guide) should be shown or not.}
 "
strengejacke,sjPlot,296db8251b13ddb709c567d17637c31d33523b76,Daniel Ldecke,d.luedecke@uke.de,2016-01-25T23:11:35Z,Daniel Ldecke,d.luedecke@uke.de,2016-01-25T23:11:35Z,fixed last issues from CRAN check,NAMESPACE;R/helpfunctions.R;R/sjPlotPropTable.R;R/sjPlotStackFrequencies.R;man/sjp.stackfrq.Rd;man/sjp.xtab.Rd,False,True,True,False,22,10,32,"---FILE: NAMESPACE---
@@ -116,6 +116,7 @@ importFrom(stats,loess)
 importFrom(stats,logLik)
 importFrom(stats,model.matrix)
 importFrom(stats,na.omit)
+importFrom(stats,na.pass)
 importFrom(stats,nobs)
 importFrom(stats,pchisq)
 importFrom(stats,pf)

---FILE: R/helpfunctions.R---
@@ -196,7 +196,10 @@ create.frq.df <- function(x,
   # -------------------------------------
   # wrap labels?
   # -------------------------------------
-  if (!is.infinite(breakLabelsAt) && !is.null(labels)) labels <- sjmisc::word_wrap(labels, breakLabelsAt)
+  if (!is.infinite(breakLabelsAt) && !is.null(labels)) {
+    if (anyNA(labels)) labels <- na.omit(labels)
+    labels <- sjmisc::word_wrap(labels, breakLabelsAt)
+  }
   # -------------------------------------
   # return results
   # -------------------------------------
@@ -209,7 +212,7 @@ create.frq.df <- function(x,
 
 # Create frequency data frame of a variable
 # for sjp and sjt frq functions
-#' @importFrom stats na.omit ftable
+#' @importFrom stats na.omit ftable na.pass
 #' @importFrom tidyr spread
 create.xtab.df <- function(x,
                            grp,
@@ -234,7 +237,7 @@ create.xtab.df <- function(x,
     if (na.rm)
       mydat <- stats::ftable(round(stats::xtabs(weightBy ~ x + grp)), 0)
     else
-      mydat <- stats::ftable(round(stats::xtabs(weightBy ~ x + grp, exclude = NULL, na.action = na.pass)), 0)
+      mydat <- stats::ftable(round(stats::xtabs(weightBy ~ x + grp, exclude = NULL, na.action = stats::na.pass)), 0)
   }
   # create proportional tables, cell values
   proptab.cell <- round(100 * prop.table(mydat), round.prz)

---FILE: R/sjPlotPropTable.R---
@@ -80,7 +80,8 @@ utils::globalVariables(c(""rowname"", ""total"", ""prc"", ""n"", ""Count"", ""Group"", ""line
 #' update_geom_defaults('text', list(hjust = -0.1))
 #' sjp.xtab(efc$e42dep, 
 #'          efc$e16sex,
-#'          labelPos = ""center"")
+#'          vjust = ""center"",
+#'          hjust = ""center"")
 #' 
 #' # grouped bars with EUROFAMCARE sample dataset
 #' # dataset was importet from an SPSS-file,
@@ -114,8 +115,7 @@ utils::globalVariables(c(""rowname"", ""total"", ""prc"", ""n"", ""Count"", ""Group"", ""line
 #'          efc$e42dep,
 #'          tableIndex = ""row"",
 #'          barPosition = ""stack"",
-#'          coord.flip = TRUE,
-#'          jitterValueLabels = TRUE)
+#'          coord.flip = TRUE)
 #'
 #'
 #' @import ggplot2
@@ -258,7 +258,7 @@ sjp.xtab <- function(x,
                            ""n"",
                            2:(grpcount + 1),
                            factor_key = TRUE)
-  mydf$n <- dummydf$n
+  mydf$n <- as.numeric(dummydf$n)
   # -----------------------------------------------
   # remove total for row and column index
   #---------------------------------------------------

---FILE: R/sjPlotStackFrequencies.R---
@@ -103,6 +103,10 @@
 #' # -------------------------------
 #' library(sjmisc)
 #' data(efc)
+#' # recveive first item of COPE-index scale
+#' start <- which(colnames(efc) == ""c82cop1"")
+#' # recveive first item of COPE-index scale
+#' end <- which(colnames(efc) == ""c90cop9"")
 #' # auto-detection of labels
 #' sjp.stackfrq(efc[, c(start:end)])
 #' 

---FILE: man/sjp.stackfrq.Rd---
@@ -150,6 +150,10 @@ sjp.stackfrq(likert_4, legendLabels = levels_4)
 # -------------------------------
 library(sjmisc)
 data(efc)
+# recveive first item of COPE-index scale
+start <- which(colnames(efc) == ""c82cop1"")
+# recveive first item of COPE-index scale
+end <- which(colnames(efc) == ""c90cop9"")
 # auto-detection of labels
 sjp.stackfrq(efc[, c(start:end)])
 

---FILE: man/sjp.xtab.Rd---
@@ -189,7 +189,8 @@ library(ggplot2)
 update_geom_defaults('text', list(hjust = -0.1))
 sjp.xtab(efc$e42dep, 
          efc$e16sex,
-         labelPos = ""center"")
+         vjust = ""center"",
+         hjust = ""center"")
 
 # grouped bars with EUROFAMCARE sample dataset
 # dataset was importet from an SPSS-file,
@@ -223,8 +224,7 @@ sjp.xtab(efc$e16sex,
          efc$e42dep,
          tableIndex = ""row"",
          barPosition = ""stack"",
-         coord.flip = TRUE,
-         jitterValueLabels = TRUE)
+         coord.flip = TRUE)
 
 
 }"
strengejacke,sjPlot,a3aee4da6423f049bf8f665e27a44c5f4d9b6e6c,Daniel Ldecke,d.luedecke@uke.de,2016-01-20T18:11:02Z,Daniel Ldecke,d.luedecke@uke.de,2016-01-20T18:11:02Z,"ggplot2-fixes, new xtab-computation for labelled data",DESCRIPTION;NEWS;R/helpfunctions.R;R/sjPlotClusterAnalysis.R;R/sjPlotCorr.R;R/sjPlotFrequencies.R;R/sjPlotGroupFrequencies.R;R/sjPlotPCA.R;R/sjPlotPropTable.R;R/sjTabDataFrame.R;R/sjTabFrequencies.R;R/sjTabPropTable.R;README.md,False,True,True,False,492,913,1405,"---FILE: DESCRIPTION---
@@ -30,7 +30,7 @@ Imports:
     psych,
     scales,
     sjmisc (>= 1.4),
-    tidyr (>= 0.3.1)
+    tidyr (>= 0.4.0)
 Suggests:
     AICcmodavg,
     arm,

---FILE: NEWS---
@@ -7,6 +7,10 @@ General:
 * Redesign of computation of frequency tables for `sjp.grpfrq` and `sjt.xtab`, being more robust and generally working with labelled, non-labelled, numeric, character vectors and factors.
 * Better automatic handling of variable and value labels that are used for labelling plot axes and titles or table columns.
 
+Changes to functions due to new ggplot2-version:
+* `sjp.grpfrq` no longer has plot type `type = ""histogram""`. Maybe re-implemented in a later update. Due to this change, arguments like `showMeanIntercept` and similar were removed.
+* Plotting functions no longer have argument `labelPosition`. Instead, use arguments `vjust` and `hjust`, which correspond to the same ggplot2-aesthetics according to their possible values.
+
 Changes to functions:
 * `sjp.lm` gets a `group.estimates` argument to group estimates in forest plots and colour them according to group assignment. Use arguments `show.legend` and `legendTitle` to modify group legend.
 * `sjp.lmer` and `sjp.glmer` can now plot random effect parts of random slope-intercept models (with `type = ""rs.ri""`), where regression lines or predicted probabilities of random intercept and slopes are plotted.

---FILE: R/helpfunctions.R---
@@ -37,7 +37,7 @@ print.table.summary <- function(baseplot,
                vjust = 1.1,
                hjust = t.hjust)
   }
-  return (baseplot)
+  return(baseplot)
 }
 
 
@@ -72,6 +72,16 @@ out.html.table <- function(no.output, file, knitr, toWrite, useViewer) {
 }
 
 
+get_var_name <- function(x) {
+  # remove ""data frame name""
+  dollar_pos <- regexpr(""$"", x, fixed = T)[1]
+  if (dollar_pos != -1)
+    x <-
+    substr(x, start = dollar_pos + 1, stop = nchar(x))
+  return(x)
+}
+
+
 # Create frequency data frame of a variable
 # for sjp and sjt frq functions
 #' @importFrom stats na.omit
@@ -211,19 +221,12 @@ create.xtab.df <- function(x,
   # vector to labelled factor first.
   # ------------------------------
   if (is.null(weightBy)) {
+    x_full <- suppressWarnings(sjmisc::to_label(x, add.non.labelled = T))
+    grp_full <- suppressWarnings(sjmisc::to_label(grp, add.non.labelled = T))
     if (na.rm) {
-      mydat <-
-        stats::ftable(table(
-          suppressWarnings(sjmisc::to_label(x, add.non.labelled = T)),
-          suppressWarnings(sjmisc::to_label(grp, add.non.labelled = T))
-        ))
+      mydat <- stats::ftable(table(x_full, grp_full))
     } else {
-      mydat <-
-        stats::ftable(table(
-          suppressWarnings(sjmisc::to_label(x, add.non.labelled = T)),
-          suppressWarnings(sjmisc::to_label(grp, add.non.labelled = T)),
-          exclude = NULL
-        ))
+      mydat <- stats::ftable(table(x_full, grp_full), exclude = NULL)
     }
   } else {
     x <- suppressWarnings(sjmisc::to_value(x, keep.labels = T))
@@ -233,10 +236,21 @@ create.xtab.df <- function(x,
     else
       mydat <- stats::ftable(round(stats::xtabs(weightBy ~ x + grp, exclude = NULL, na.action = na.pass)), 0)
   }
-  # create proportional tables
-  proptab.cell <- round(100 * prop.table(mydat), 2)
-  proptab.row <- round(100 * prop.table(mydat, 1), 2)
-  proptab.col <- round(100 * prop.table(mydat, 2), 2)
+  # create proportional tables, cell values
+  proptab.cell <- round(100 * prop.table(mydat), round.prz)
+  # create proportional tables, row percentages, including total row
+  proptab.row <- rbind(as.data.frame(as.matrix(round(100 * prop.table(mydat, 1), round.prz))), 
+                       colSums(proptab.cell))
+  rownames(proptab.row)[nrow(proptab.row)] <- ""total""
+  # create proportional tables, column  percentages, including total row
+  proptab.col <- cbind(as.data.frame(as.matrix(round(100 * prop.table(mydat, 2), round.prz))), 
+                       rowSums(proptab.cell))
+  colnames(proptab.col)[ncol(proptab.col)] <- ""total""
+  # add total row and column to cell percentages afterwards
+  proptab.cell <- rbind(as.data.frame(as.matrix(proptab.cell)), colSums(proptab.cell))
+  proptab.cell <- cbind(as.data.frame(as.matrix(proptab.cell)), rowSums(proptab.cell))
+  colnames(proptab.cell)[ncol(proptab.cell)] <- ""total""
+  rownames(proptab.cell)[nrow(proptab.cell)] <- ""total""
   # convert to data frame
   mydat <- data.frame(mydat)
   colnames(mydat)[2] <- ""Var2""

---FILE: R/sjPlotClusterAnalysis.R---
@@ -747,7 +747,11 @@ sjc.elbow <- function(data, steps = 15, show.diff = FALSE, showDiff = FALSE) {
   # calculate differences between each step
   diff <- c()
   for (i in 2:steps) diff <- cbind(diff,wssround[i - 1] - wssround[i])
-  dfElbowDiff <- tidyr::gather(as.data.frame(diff), ""Var2"", ""value"", 1:ncol(diff))
+  dfElbowDiff <- tidyr::gather(as.data.frame(diff), 
+                               ""Var2"", 
+                               ""value"", 
+                               1:ncol(diff),
+                               factor_key = TRUE)
   # --------------------------------------------------
   # Plot diagram with sum of squares
   # all pointes are connected with a line

---FILE: R/sjPlotCorr.R---
@@ -251,12 +251,14 @@ sjp.corr <- function(data,
   orderedCorr <- tidyr::gather(data.frame(orderedCorr), 
                                ""var"", 
                                ""value"", 
-                               1:ncol(orderedCorr))
+                               1:ncol(orderedCorr),
+                               factor_key = TRUE)
   # orderedCorr <- melt(orderedCorr)
   if (!is.null(cpvalues)) cpvalues <- tidyr::gather(data.frame(cpvalues), 
                                                     ""var"", 
                                                     ""value"", 
-                                                    1:ncol(cpvalues))
+                                                    1:ncol(cpvalues),
+                                                    factor_key = TRUE)
   # if (!is.null(cpvalues)) cpvalues <- melt(cpvalues)
   # bind additional information like order for x- and y-axis
   # as well as the size of plotted points

---FILE: R/sjPlotFrequencies.R---
@@ -87,13 +87,6 @@ utils::globalVariables(c(""val"", ""frq"", ""grp"", ""upper.ci"", ""lower.ci"", ""ia"", ""..d
 #'          for details).
 #' @param axisTitle.y title for the y-axis. By default, this value is \code{NULL},
 #'          i.e. no title is printed.
-#' @param hist.skipZeros logical, if \code{TRUE}, zero counts (categories with no answer) 
-#'          in \code{varCount} are omitted when drawing histrograms, and the mapping 
-#'          is changed to \code{\link[ggplot2]{stat_bin}}. Only applies to  histograms. 
-#'          Use this argument to get similar results to the default \code{\link[ggplot2]{qplot}} 
-#'          or \code{\link[ggplot2]{geom_histogram}} histogram plots of ggplot. You may need
-#'          to adjust the \code{geom.size} argument for better visual results 
-#'          (which, by ggplot-default, is 1/30 of the x-axis-range).
 #' @param autoGroupAt numeric value, indicating at which length of unique values of \code{varCount}, 
 #'          automatic grouping into smaller units is done (see \code{\link[sjmisc]{group_var}}).
 #'          If \code{varCount} has large numbers of unique values, there may be too many bars 
@@ -102,10 +95,6 @@ utils::globalVariables(c(""val"", ""frq"", ""grp"", ""upper.ci"", ""lower.ci"", ""ia"", ""..d
 #'          it will be grouped (using the \code{\link[sjmisc]{group_var}} function). 
 #'          Default value for \code{autoGroupAt} is \code{NULL}, i.e. auto-grouping is off.
 #'          See \code{\link[sjmisc]{group_var}} for examples on grouping.
-#' @param labelPos string, indicating the position of value labels, when \code{coord.flip = TRUE}.
-#'          Can be either \code{""inside""} or \code{""outside""} (default). You may specify
-#'          initial letter only. If \code{coord.flip = FALSE}, this argument will
-#'          be ignored.
 #'          
 #' @inheritParams sjp.grpfrq
 #' 
@@ -175,12 +164,7 @@ utils::globalVariables(c(""val"", ""frq"", ""grp"", ""upper.ci"", ""lower.ci"", ""ia"", ""..d
 #' # -------------------------------------------------
 #' # auto-detection of value labels and variable names
 #' # -------------------------------------------------
-#' # negative impact scale, ranging from 7-28, assuming that
-#' # variable scale (lowest value) starts with 1
-#' sjp.frq(efc$neg_c_7, startAxisAt = 1)
-#' 
-#' # negative impact scale, ranging from 7-28, using
-#' # automatic detection of start index of x-axis
+#' # negative impact scale, ranging from 7-28
 #' sjp.frq(efc$neg_c_7)
 #' 
 #' # -------------------------------------------------
@@ -190,16 +174,17 @@ utils::globalVariables(c(""val"", ""frq"", ""grp"", ""upper.ci"", ""lower.ci"", ""ia"", ""..d
 #'         type = ""dots"",
 #'         showCI = TRUE,
 #'         sort.frq = ""desc"",
-#'         coord.flip = TRUE)
+#'         coord.flip = TRUE,
+#'         expand.grid = TRUE, # for text labels
+#'         vjust = ""bottom"",   # for text labels
+#'         hjust = ""left"")     # for text labels
 #' 
 #' # -------------------------------------------------
-#' # Simulate ggplot-default histogram, using ""hist.skipZeros""
-#' # and adjusted ""geom.size"".
+#' # Simulate ggplot-default histogram
 #' # -------------------------------------------------
 #' sjp.frq(efc$c160age, 
 #'         type = ""h"", 
-#'         hist.skipZeros = TRUE, 
-#'         geom.size = 1)
+#'         geom.size = 3)
 #' 
 #'   
 #' @import ggplot2
@@ -214,7 +199,7 @@ sjp.frq <- function(varCount,
                     sort.frq = ""none"",
                     type = ""bars"",
                     geom.size = NULL,
-                    geom.colors = NULL,
+                    geom.colors = ""#336699"",
                     axisLabels.x = NULL,
                     interactionVarLabels = NULL,
                     axisLimits.x = NULL,
@@ -245,17 +230,16 @@ sjp.frq <- function(varCount,
                     normalCurveAlpha = 0.4,
                     axisTitle.x = NULL,
                     axisTitle.y = NULL,
-                    startAxisAt = ""auto"",
-                    hist.skipZeros = FALSE,
                     autoGroupAt = NULL,
                     coord.flip = FALSE,
-                    labelPos = ""outside"",
+                    vjust = ""bottom"",
+                    hjust = ""center"",
                     na.rm = TRUE,
                     printPlot = TRUE) {
   # --------------------------------------------------------
   # get variable name
   # --------------------------------------------------------
-  var.name <- deparse(substitute(varCount))
+  var.name <- get_var_name(deparse(substitute(varCount)))
   # --------------------------------------------------------
   # try to automatically set labels is not passed as argument
   # --------------------------------------------------------
@@ -271,9 +255,7 @@ sjp.frq <- function(varCount,
   # --------------------------------------------------------
   # check color argument
   # --------------------------------------------------------
-  if (is.null(geom.colors)) {
-    geom.colors <- ggplot2::waiver()
-  } else if (length(geom.colors) > 1) {
+  if (length(geom.colors) > 1) {
     geom.colors <- geom.colors[1]
   }
   # --------------------------------------------------------
@@ -355,7 +337,6 @@ sjp.frq <- function(varCount,
                           weightBy = weightBy)
   mydat <- df.frq$mydat
   if (!is.null(df.frq$labels)) axisLabels.x <- df.frq$labels
-  catmin <- df.frq$minval
   # --------------------------------------------------------
   # Trim labels and title to appropriate size
   # --------------------------------------------------------
@@ -444,41 +425,22 @@ sjp.frq <- function(varCount,
         lower_lim <- 0
         trimViolin <- TRUE
       }
-    } else {
+    } else if (type == ""histogram"") {
+      # what is the maximum values after binning for histograms?
+      hist.grp.cnt <- ceiling(diff(range(varCount, na.rm = T)) / geom.size)
       # ... or the amount of max. answers per category
       # add 5% margin to upper limit
-      upper_lim <- max(pretty(table(varCount) * 1.05))
-    }
-  }
-  # --------------------------------------------------------
-  # define geom
-  # --------------------------------------------------------
-  if (type == ""bars"") {
-    geob <- geom_bar(stat = ""identity"", 
-                     width = geom.size, 
-                     fill = geom.colors)
-  } else if (type == ""dots"") {
-    geob <- geom_point(size = geom.size, fill = geom.colors)
-  }
-  if (!showAxisLabels.x) axisLabels.x <- c("""")
-  # --------------------------------------------------------
-  # Set value labels
-  # --------------------------------------------------------
-  if (coord.flip) {
-    # adjust vertical position for labels, based on whether percentage values
-    # are shown or not
-    vert <- ggplot2::waiver() # ifelse((showPercentageValues == TRUE && showCountValues == TRUE), 0.5, 0.1)
-    if (labelPos == ""inside"" || labelPos == ""i"") {
-      hort <- 1.1
+      upper_lim <- max(pretty(table(sjmisc::group_var(varCount, 
+                                                      groupsize = ""auto"", 
+                                                      groupcount = hist.grp.cnt)) * 1.05))
     } else {
-      hort <- -0.1
+      if (showCI)
+        upper_lim <- max(pretty(mydat$upper.ci * 1.05))
+      else
+        upper_lim <- max(pretty(table(varCount) * 1.05))
     }
-  } else {
-    # adjust vertical position for labels, based on whether percentage values
-    # are shown or not
-    vert <- ifelse((showPercentageValues == TRUE && showCountValues == TRUE), -0.2, -0.6)
-    hort <- ggplot2::waiver()
   }
+  if (!showAxisLabels.x) axisLabels.x <- c("""")
   # --------------------------------------------------------
   # Set value labels
   # --------------------------------------------------------
@@ -490,59 +452,63 @@ sjp.frq <- function(varCount,
       if (coord.flip) {
         if (showCI) {
           ggvaluelabels <-  geom_text(label = sprintf(""%i (%.01f%%)"", mydat$frq, mydat$valid.prc),
-                                      hjust = hort,
-                                      vjust = vert,
+                                      hjust = hjust,
+                                      vjust = vjust,
                                       aes(y = upper.ci))
         } else {
           ggvaluelabels <-  geom_text(label = sprintf(""%i (%.01f%%)"", mydat$frq, mydat$valid.prc),
-                                      hjust = hort,
-                                      vjust = vert)
+                                      hjust = hjust,
+                                      vjust = vjust,
+                                      aes(y = frq))
         }
       } else {
         if (showCI) {
           ggvaluelabels <-  geom_text(label = sprintf(""%i\n(%.01f%%)"", mydat$frq, mydat$valid.prc),
-                                      hjust = hort,
-                                      vjust = vert,
+                                      hjust = hjust,
+                                      vjust = vjust,
                                       aes(y = upper.ci))
         } else {
           ggvaluelabels <-  geom_text(label = sprintf(""%i\n(%.01f%%)"", mydat$frq, mydat$valid.prc),
-                                      hjust = hort,
-                                      vjust = vert)
+                                      hjust = hjust,
+                                      vjust = vjust,
+                                      aes(y = frq))
         }
       }
     } else if (showCountValues) {
       if (showCI) {
         # here we have counts, without percentages
         ggvaluelabels <-  geom_text(label = sprintf(""%i"", mydat$frq),
-                                    hjust = hort,
-                                    vjust = vert,
+                                    hjust = hjust,
+                                    vjust = vjust,
                                     aes(y = upper.ci))
       } else {
         # here we have counts, without percentages
         ggvaluelabels <-  geom_text(label = sprintf(""%i"", mydat$frq),
-                                    hjust = hort,
-                                    vjust = vert)
+                                    hjust = hjust,
+                                    vjust = vjust,
+                                    aes(y = frq))
       }
     } else if (showPercentageValues) {
       if (showCI) {
         # here we have counts, without percentages
         ggvaluelabels <-  geom_text(label = sprintf(""%.01f%%"", mydat$valid.prc),
-                                    hjust = hort,
-                                    vjust = vert,
+                                    hjust = hjust,
+                                    vjust = vjust,
                                     aes(y = upper.ci))
       } else {
         # here we have counts, without percentages
         ggvaluelabels <-  geom_text(label = sprintf(""%.01f%%"", mydat$valid.prc),
-                                    hjust = hort,
-                                    vjust = vert)
+                                    hjust = hjust,
+                                    vjust = vjust,
+                                    aes(y = frq))
       }
     } else {
       # no labels
-      ggvaluelabels <-  geom_text(label = """")
+      ggvaluelabels <-  geom_text(aes(y = frq), label = """")
     }
   } else {
     # no labels
-    ggvaluelabels <-  geom_text(label = """")
+    ggvaluelabels <-  geom_text(aes(y = frq), label = """")
   }
   # --------------------------------------------------------
   # Set up grid breaks
@@ -558,12 +524,7 @@ sjp.frq <- function(varCount,
   # ----------------------------------
   # set x-axis limits
   # ----------------------------------
-  if (is.null(axisLimits.x)) {
-    if (type == ""histogram"")
-      axisLimits.x <- c(catmin - 1, maxx + 1)
-    else
-      axisLimits.x <- c(catmin, maxx)
-  }
+  # if (is.null(axisLimits.x)) axisLimits.x <- c(catmin, maxx)
   # ----------------------------------
   # set y scaling and label texts
   # ----------------------------------
@@ -589,14 +550,24 @@ sjp.frq <- function(varCount,
   stdsd <- stdmean / 4
   stdlen <- length(stats::na.omit(varCount))
   # ----------------------------------
-  # Check how many categories we have on the x-axis.
-  # If it exceeds the user defined limits, plot
-  # histrogram instead of bar chart
+  # bar and dot plot start here!
   # ----------------------------------
   if (type == ""bars"" || type == ""dots"") {
+    # -----------------------------------
+    # define geom
+    # -----------------------------------
+    if (type == ""bars"") {
+      geob <- geom_bar(stat = ""identity"", 
+                       width = geom.size, 
+                       fill = geom.colors)
+    } else if (type == ""dots"") {
+      geob <- geom_point(size = geom.size, fill = geom.colors)
+    }
+    # -----------------------------------
     # mydat is a data frame that only contains one variable (var).
     # Must be declared as factor, so the bars are central aligned to
     # each x-axis-break. 
+    # -----------------------------------
     baseplot <- ggplot(mydat, aes(x = factor(val), y = frq)) + 
       geob +
       yscale + 
@@ -618,197 +589,182 @@ sjp.frq <- function(varCount,
     # check whether coordinates should be flipped, i.e.
     # swap x and y axis
     if (coord.flip) baseplot <- baseplot + coord_flip()
-  } else {
-    # --------------------------------------------------
-    # Here we start when we have a histogram instead of
-    # bar plot.
-    # --------------------------------------------------
-    # Start density plot here
-    # --------------------------------------------------
-    if (type == ""boxplots"" || type == ""violin"") {
-      if (is.null(interactionVar)) {
-        baseplot <- ggplot(mydat, aes(x = grp, y = frq))
-        scalex <- scale_x_discrete(labels = """")
-      } else {
-        baseplot <- ggplot(mydat, aes(x = interaction(ia, grp), y = frq))
-        scalex <- scale_x_discrete(labels = interactionVarLabels)
-      }
-      if (type == ""boxplots"") {
-        baseplot <- baseplot + 
-          geom_boxplot(width = geom.size, fill = geom.colors)
-      } else {
-        baseplot <- baseplot + 
-          geom_violin(trim = trimViolin, 
-                      width = geom.size, 
-                      fill = geom.colors) +
-          # if we have a violin plot, add an additional boxplot inside to show
-          # more information
-          geom_boxplot(width = innerBoxPlotWidth, 
-                       fill = ""white"")
-      }
-      # if we have boxplots or violon plots, also add a point that indicates
-      # the mean value
-      # different fill colours, because violin boxplots have white background
-      fcsp <- ifelse(type == ""boxplots"", ""white"", ""black"")
-      baseplot <- baseplot +
-        stat_summary(fun.y = ""mean"", 
-                     geom = ""point"", 
-                     shape = 21, 
-                     size = innerBoxPlotDotSize, 
-                     fill = fcsp)
-      # no additional labels for the x- and y-axis, only diagram title
+  # --------------------------------------------------
+  # Start box plot here
+  # --------------------------------------------------
+  } else if (type == ""boxplots"" || type == ""violin"") {
+    if (is.null(interactionVar)) {
+      baseplot <- ggplot(mydat, aes(x = grp, y = frq))
+      scalex <- scale_x_discrete(labels = """")
+    } else {
+      baseplot <- ggplot(mydat, aes(x = interaction(ia, grp), y = frq))
+      scalex <- scale_x_discrete(labels = interactionVarLabels)
+    }
+    if (type == ""boxplots"") {
       baseplot <- baseplot + 
-        yscale +
-        scalex
-    # --------------------------------------------------
-    # Start density plot here
-    # --------------------------------------------------
-    } else if (type == ""dens"") {
+        geom_boxplot(width = geom.size, fill = geom.colors)
+    } else {
+      baseplot <- baseplot + 
+        geom_violin(trim = trimViolin, 
+                    width = geom.size, 
+                    fill = geom.colors) +
+        # if we have a violin plot, add an additional boxplot inside to show
+        # more information
+        geom_boxplot(width = innerBoxPlotWidth, 
+                     fill = ""white"")
+    }
+    # if we have boxplots or violon plots, also add a point that indicates
+    # the mean value
+    # different fill colours, because violin boxplots have white background
+    fcsp <- ifelse(type == ""boxplots"", ""white"", ""black"")
+    baseplot <- baseplot +
+      stat_summary(fun.y = ""mean"", 
+                   geom = ""point"", 
+                   shape = 21, 
+                   size = innerBoxPlotDotSize, 
+                   fill = fcsp)
+    # no additional labels for the x- and y-axis, only diagram title
+    baseplot <- baseplot + 
+      yscale +
+      scalex
+  # --------------------------------------------------
+  # Start density plot here
+  # --------------------------------------------------
+  } else if (type == ""dens"") {
+    xv <- stats::na.omit(varCount)
+    densityDat <- data.frame(xv)
+    # First, plot histogram with density curve
+    baseplot <- ggplot(densityDat, aes(x = xv)) +
+      geom_histogram(aes(y = ..density..), fill = geom.colors) +
+      # transparent density curve above bars
+      geom_density(aes(y = ..density..), 
+                   fill = ""cornsilk"", 
+                   alpha = 0.3) +
+      # remove margins from left and right diagram side
+      scale_x_continuous(expand = expand.grid, 
+                         breaks = histgridbreaks,
+                         limits = axisLimits.x)
+    # check whether user wants to overlay the histogram
+    # with a normal curve
+    if (showNormalCurve) {
+      baseplot <- baseplot +
+        stat_function(fun = dnorm,
+                      args = list(mean = mean(densityDat$xv),
+                                  sd = stats::sd(densityDat$xv)),
+                      colour = normalCurveColor,
+                      size = normalCurveSize,
+                      alpha = normalCurveAlpha)
+    }
+    if (showStandardNormalCurve) {
+      baseplot <- baseplot +
+        stat_function(fun = dnorm,
+                      args = list(mean = stdmean, sd = stdsd),
+                      colour = normalCurveColor,
+                      size = normalCurveSize,
+                      alpha = normalCurveAlpha)
+    }
+  } else {
+    # -----------------------------------------------------------------
+    # Since the density curve shows no absolute numbers (counts) on the
+    # y-axis, have also the opportunity to plot ""real"" histrograms with 
+    # counts on the y-axis
+    # -----------------------------------------------------------------
+    if (type == ""histogram"") {
       xv <- stats::na.omit(varCount)
-      densityDat <- data.frame(xv)
-      # First, plot histogram with density curve
-      baseplot <- ggplot(densityDat, aes(x = xv)) +
-        geom_histogram(aes(y = ..density..), fill = geom.colors) +
-        # transparent density curve above bars
-        geom_density(aes(y = ..density..), 
-                     fill = ""cornsilk"", 
-                     alpha = 0.3) +
-        # remove margins from left and right diagram side
-        scale_x_continuous(expand = expand.grid, 
-                           breaks = histgridbreaks,
-                           limits = axisLimits.x)
-      # check whether user wants to overlay the histogram
-      # with a normal curve
-      if (showNormalCurve) {
-        baseplot <- baseplot +
-          stat_function(fun = dnorm,
-                        args = list(mean = mean(densityDat$xv),
-                                    sd = stats::sd(densityDat$xv)),
-                        colour = normalCurveColor,
-                        size = normalCurveSize,
-                        alpha = normalCurveAlpha)
-      }
-      if (showStandardNormalCurve) {
-        baseplot <- baseplot +
-          stat_function(fun = dnorm,
-                        args = list(mean = stdmean, sd = stdsd),
-                        colour = normalCurveColor,
-                        size = normalCurveSize,
-                        alpha = normalCurveAlpha)
-      }
+      if (geom.size < round(diff(range(xv)) / 50)) message(""Using very small binwidth. Consider adjusting \""geom.size\"" argument."")
+      hist.dat <- data.frame(xv)
+      baseplot <- ggplot(mydat) +
+        geom_histogram(data = hist.dat,
+                       aes(x = xv),
+                       binwidth = geom.size, 
+                       fill = geom.colors)        
+      
     } else {
-      # -----------------------------------------------------------------
-      # Since the density curve shows no absolute numbers (counts) on the
-      # y-axis, have also the opportunity to plot ""real"" histrograms with 
-      # counts on the y-axis
-      # -----------------------------------------------------------------
-      # base constructor
-      if (hist.skipZeros) {
-        xv <- stats::na.omit(varCount)
-        if (geom.size < round(diff(range(xv)) / 50)) message(""Using very small binwidth. Consider adjusting \""geom.size\"" argument."")
-        hist.dat <- data.frame(xv)
-        baseplot <- ggplot(mydat)
-        basehist <- geom_histogram(data = hist.dat, 
-                                   aes(x = xv),
-                                   binwidth = geom.size, 
-                                   fill = geom.colors)
-      } else {
-        baseplot <- ggplot(mydat, aes(x = val, y = frq))
-        basehist <- geom_histogram(stat = ""identity"", 
-                                   binwidth = geom.size, 
-                                   fill = geom.colors)
-      }
-      basehistline <- geom_area(alpha = 0.3)
-      # check whether user wants line or bar histogram
-      if (type == ""line"") {
-        baseplot <- baseplot + basehistline + geom_line(colour = geom.colors)
-      } else {
-        baseplot <- baseplot + basehist
-      }
-      # check whether user wants to overlay the histogram
-      # with a normal curve
-      if (showNormalCurve) {
-        baseplot <- baseplot +
-          stat_function(fun = function(x, mean, sd, n) { n * dnorm(x = x, mean = mean, sd = sd) },
-                        args = with(mydat, c(mean = mittelwert, sd = stddev, n = length(varCount))),
-                        colour = normalCurveColor,
-                        size = normalCurveSize,
-                        alpha = normalCurveAlpha)
+      baseplot <- ggplot(mydat, aes(x = val, y = frq)) +
+        geom_area(alpha = 0.3) +
+        geom_line(size = geom.size, colour = geom.colors) +
+        ggvaluelabels
+    }
+    # check whether user wants to overlay the histogram
+    # with a normal curve
+    if (showNormalCurve) {
+      baseplot <- baseplot +
+        stat_function(fun = function(x, mean, sd, n) { n * dnorm(x = x, mean = mean, sd = sd) },
+                      args = with(mydat, c(mean = mittelwert, sd = stddev, n = length(varCount))),
+                      colour = normalCurveColor,
+                      size = normalCurveSize,
+                      alpha = normalCurveAlpha)
+    }
+    if (showStandardNormalCurve) {
+      baseplot <- baseplot +
+        stat_function(fun = function(x, mean, sd, n) { 
+          if (adjustNormalCurve.x) x <- x - stdadjust
+          n * dnorm(x = x, mean = mean, sd = sd)},
+          args = with(mydat, c(mean = stdmean, sd = stdsd, n = stdlen)),
+          colour = normalCurveColor,
+          size = normalCurveSize,
+          alpha = normalCurveAlpha)
+    }
+    # if we have a histogram, add mean-lines
+    if (showMeanIntercept) {
+      baseplot <- baseplot + 
+        # vertical lines indicating the mean
+        geom_vline(xintercept = mittelwert, 
+                   linetype = meanInterceptLineType, 
+                   size = meanInterceptLineSize)
+      # check whether meanvalue should be shown.
+      if (showMeanValue) {
+        baseplot <- baseplot + 
+          # use annotation instead of geomtext, because we need mean value only printed once
+          annotate(""text"", 
+                   x = mittelwert, 
+                   y = upper_lim, 
+                   parse = TRUE, 
+                   label = paste(""italic(bar(x)) == "", ""'"", c(round(mittelwert, 1)), ""'""), 
+                   hjust = 1.1, 
+                   vjust = 2.2)
       }
-      if (showStandardNormalCurve) {
+      # check whether the user wants to plot standard deviation area
+      if (showStandardDeviation) {
         baseplot <- baseplot +
-          stat_function(fun = function(x, mean, sd, n) { 
-            if (adjustNormalCurve.x) x <- x - stdadjust
-            n * dnorm(x = x, mean = mean, sd = sd)},
-            args = with(mydat, c(mean = stdmean, sd = stdsd, n = stdlen)),
-            colour = normalCurveColor,
-            size = normalCurveSize,
-            alpha = normalCurveAlpha)
-      }
-      # if we have a histogram, add mean-lines
-      if (showMeanIntercept) {
-        baseplot <- baseplot + 
-          # vertical lines indicating the mean
-          geom_vline(xintercept = mittelwert, 
-                     linetype = meanInterceptLineType, 
-                     size = meanInterceptLineSize)
-        # check whether meanvalue should be shown.
+          # first draw shaded rectangle. these are by default in grey colour with very high transparancy
+          annotate(""rect"", 
+                   xmin = mittelwert - stddev, 
+                   xmax = mittelwert + stddev, 
+                   ymin = 0, 
+                   ymax = c(upper_lim), 
+                   fill = ""grey70"", 
+                   alpha = 0.2) +
+          # draw border-lines for shaded rectangle
+          geom_vline(xintercept = mittelwert - stddev, 
+                     linetype = 3, 
+                     size = meanInterceptLineSize, 
+                     alpha = 0.7) +
+          geom_vline(xintercept = mittelwert + stddev, 
+                     linetype = 3, 
+                     size = meanInterceptLineSize, 
+                     alpha = 0.7)
+        # if mean values are plotted, plot standard deviation values as well
         if (showMeanValue) {
           baseplot <- baseplot + 
             # use annotation instead of geomtext, because we need mean value only printed once
             annotate(""text"", 
                      x = mittelwert, 
                      y = upper_lim, 
+                     label = sprintf(""italic(s) == %.2f"", round(stddev, 1)), 
                      parse = TRUE, 
-                     label = paste(""italic(bar(x)) == "", ""'"", c(round(mittelwert, 1)), ""'""), 
-                     hjust = 1.1, 
-                     vjust = 2.2)
+                     hjust = 1.15, 
+                     vjust = 4.2)
         }
-        # check whether the user wants to plot standard deviation area
-        if (showStandardDeviation) {
-          baseplot <- baseplot +
-            # first draw shaded rectangle. these are by default in grey colour with very high transparancy
-            annotate(""rect"", 
-                     xmin = mittelwert - stddev, 
-                     xmax = mittelwert + stddev, 
-                     ymin = 0, 
-                     ymax = c(upper_lim), 
-                     fill = ""grey70"", 
-                     alpha = 0.2) +
-            # draw border-lines for shaded rectangle
-            geom_vline(xintercept = mittelwert - stddev, 
-                       linetype = 3, 
-                       size = meanInterceptLineSize, 
-                       alpha = 0.7) +
-            geom_vline(xintercept = mittelwert + stddev, 
-                       linetype = 3, 
-                       size = meanInterceptLineSize, 
-                       alpha = 0.7)
-          # if mean values are plotted, plot standard deviation values as well
-          if (showMeanValue) {
-            baseplot <- baseplot + 
-              # use annotation instead of geomtext, because we need mean value only printed once
-              annotate(""text"", 
-                       x = mittelwert, 
-                       y = upper_lim, 
-                       label = sprintf(""italic(s) == %.2f"", round(stddev, 1)), 
-                       parse = TRUE, 
-                       hjust = 1.15, 
-                       vjust = 4.2)
-          }
-        }
-      }
-      if (!hist.skipZeros) {
-        # show absolute and percentage value of each bar.
-        baseplot <- baseplot + ggvaluelabels
       }
-      baseplot <- baseplot +
-        # remove margins from left and right diagram side
-        scale_x_continuous(limits = axisLimits.x, 
-                           expand = expand.grid, 
-                           breaks = histgridbreaks) +
-        yscale
     }
+    # show absolute and percentage value of each bar.
+    baseplot <- baseplot + 
+      # remove margins from left and right diagram side
+      scale_x_continuous(limits = axisLimits.x, 
+                         expand = expand.grid, 
+                         breaks = histgridbreaks) +
+      yscale
   }
   # set axes text and 
   baseplot <- baseplot + labs(title = title, x = axisTitle.x, y = axisTitle.y)

---FILE: R/sjPlotGroupFrequencies.R---
@@ -185,6 +185,7 @@ utils::globalVariables(c(""."", ""label"", ""prz"", ""frq"", ""ypos"", ""wb"", ""ia"", ""mw"", ""
 #'            
 #' @import ggplot2
 #' @import sjmisc
+#' @importFrom tidyr gather
 #' @importFrom dplyr group_by mutate arrange summarise add_rownames
 #' @importFrom stats na.omit xtabs wilcox.test sd
 #' @export
@@ -235,8 +236,8 @@ sjp.grpfrq <- function(varCount,
   # --------------------------------------------------------
   # get variable name
   # --------------------------------------------------------
-  var.name.cnt <- deparse(substitute(varCount))
-  var.name.grp <- deparse(substitute(varGroup))
+  var.name.cnt <- get_var_name(deparse(substitute(varCount)))
+  var.name.grp <- get_var_name(deparse(substitute(varGroup)))
   # --------------------------------------------------------
   # We have several options to name the diagram type
   # Here we will reduce it to a unique value
@@ -322,10 +323,8 @@ sjp.grpfrq <- function(varCount,
     hideLegend <- FALSE
     legendLabels <- axisLabels.x
   }
-  if (is.null(axisTitle.x))
-    axisTitle.x <- sjmisc::get_label(varCount, def.value = var.name.cnt)
-  if (is.null(legendTitle))
-    legendTitle <- sjmisc::get_label(varGroup, def.value = var.name.grp)
+  if (is.null(axisTitle.x)) axisTitle.x <- sjmisc::get_label(varCount, def.value = var.name.cnt)
+  if (is.null(legendTitle)) legendTitle <- sjmisc::get_label(varGroup, def.value = var.name.grp)
   if (is.null(title)) {
     t1 <- sjmisc::get_label(varCount, def.value = var.name.cnt)
     t2 <- sjmisc::get_label(varGroup, def.value = var.name.grp)
@@ -334,14 +333,10 @@ sjp.grpfrq <- function(varCount,
   # --------------------------------------------------------
   # remove titles if empty
   # --------------------------------------------------------
-  if (!is.null(legendTitle) && legendTitle == """")
-    legendTitle <- NULL
-  if (!is.null(axisTitle.x) && axisTitle.x == """")
-    axisTitle.x <- NULL
-  if (!is.null(axisTitle.y) && axisTitle.y == """")
-    axisTitle.y <- NULL
-  if (!is.null(title) && title == """")
-    title <- NULL
+  if (!is.null(legendTitle) && legendTitle == """") legendTitle <- NULL
+  if (!is.null(axisTitle.x) && axisTitle.x == """") axisTitle.x <- NULL
+  if (!is.null(axisTitle.y) && axisTitle.y == """") axisTitle.y <- NULL
+  if (!is.null(title) && title == """") title <- NULL
   # --------------------------------------------------------
   # count variable may not be a factor!
   # --------------------------------------------------------
@@ -373,7 +368,11 @@ sjp.grpfrq <- function(varCount,
   # create cross table for stats, summary etc.
   # and weight variable
   #---------------------------------------------------
-  mydf <- tidyr::gather(mydat$mydat, ""group"", ""frq"", 2:(grpcount + 1))
+  mydf <- tidyr::gather(mydat$mydat, 
+                        ""group"", 
+                        ""frq"", 
+                        2:(grpcount + 1), 
+                        factor_key = TRUE)
   # -----------------------------------------------
   # xpos should be numeric factor
   #---------------------------------------------------

---FILE: R/sjPlotPCA.R---
@@ -358,7 +358,11 @@ sjp.pca <- function(data,
   # rename columns, so we have numbers on x axis
   names(df) <- c(1:ncol(df))
   # convert to long data
-  df <- tidyr::gather(df, ""xpos"", ""value"", 1:ncol(df))  
+  df <- tidyr::gather(df, 
+                      ""xpos"", 
+                      ""value"", 
+                      1:ncol(df), 
+                      factor_key = TRUE)  
   # we need new columns for y-positions and point sizes
   df <- cbind(df, ypos = 1:nrow(pcadata.varim$loadings), psize = exp(abs(df$value)) * geom.size)
   if (!showValueLabels) {

---FILE: R/sjPlotPropTable.R---
@@ -1,5 +1,5 @@
 # bind global variables
-utils::globalVariables(c(""Perc"", ""Sum"", ""Count"", ""Group"", ""line.break""))
+utils::globalVariables(c(""prc"", ""n"", ""Count"", ""Group"", ""line.break""))
 
 #' @title Plot contingency tables
 #' @name sjp.xtab
@@ -31,13 +31,6 @@ utils::globalVariables(c(""Perc"", ""Sum"", ""Count"", ""Group"", ""line.break""))
 #' @param geom.size size resp. width of the geoms (bar width).
 #' @param lineDotSize dot size, only applies, when argument \code{type = ""lines""}.
 #' @param smoothLines prints a smooth line curve. Only applies, when argument \code{type = ""lines""}.
-#' @param jitterValueLabels logical, if \code{TRUE}, the value labels on the bars will be ""jittered"", 
-#'          i.e. they have alternating vertical positions to avoid overlapping of labels in case bars are
-#'          very short. Default is \code{FALSE}.
-#' @param labelPos positioning of value labels. If \code{barPosition = ""dodge""} 
-#'          (default), use either \code{""inside""} or \code{""outside""} (default) to put labels in-
-#'          or outside the bars. You may specify initial letter only. Use \code{""center""} 
-#'          to center labels (useful if label angle is changes via \code{\link{sjp.setTheme}}).
 #' @param stringTotal string for the legend label when a total-column is added. Only applies
 #'          if \code{showTotalColumn = TRUE}. Default is \code{""Total""}.
 #' @param showCategoryLabels whether x-axis text (category names) should be shown or not.
@@ -126,8 +119,9 @@ utils::globalVariables(c(""Perc"", ""Sum"", ""Count"", ""Group"", ""line.break""))
 #'
 #'
 #' @import ggplot2
-#' @importFrom dplyr group_by mutate arrange
 #' @import sjmisc
+#' @importFrom dplyr group_by mutate arrange add_rownames filter select
+#' @importFrom tidyr gather
 #' @importFrom scales percent
 #' @importFrom stats na.omit
 #' @export
@@ -143,7 +137,8 @@ sjp.xtab <- function(x,
                      axisLimits.y = NULL,
                      axisLabels.x = NULL,
                      legendLabels = NULL,
-                     labelPos = ""outside"",
+                     vjust = ""bottom"",
+                     hjust = ""center"",
                      stringTotal = ""Total"",
                      breakTitleAt = 50,
                      breakLabelsAt = 15,
@@ -158,7 +153,6 @@ sjp.xtab <- function(x,
                      smoothLines = FALSE,
                      expand.grid = FALSE,
                      showValueLabels = TRUE,
-                     jitterValueLabels = FALSE,
                      showCountValues = TRUE,
                      showPercentageValues = TRUE,
                      showCategoryLabels = TRUE,
@@ -171,15 +165,50 @@ sjp.xtab <- function(x,
                      coord.flip = FALSE,
                      printPlot = TRUE) {
   # --------------------------------------------------------
+  # get variable name
+  # --------------------------------------------------------
+  var.name.cnt <- get_var_name(deparse(substitute(x)))
+  var.name.grp <- get_var_name(deparse(substitute(grp)))
+  # --------------------------------------------------------
+  # We have several options to name the diagram type
+  # Here we will reduce it to a unique value
+  # --------------------------------------------------------
+  if (type == ""b"" || type == ""bar"") type <- ""bars""
+  if (type == ""l"" || type == ""line"") type <- ""lines""
+  if (expand.grid == TRUE) {
+    expand.grid <- ggplot2::waiver()
+  } else {
+    expand.grid <- c(0, 0)
+  }
+  # --------------------------------------------------------
+  # total column only applies to column percentages
+  # --------------------------------------------------------
+  if (tableIndex != ""col"") showTotalColumn <- FALSE
+  # --------------------------------------------------------
+  # create cross table of frequencies and percentages
+  # --------------------------------------------------------
+  mydat <- create.xtab.df(x,
+                          grp,
+                          round.prz = 2,
+                          na.rm = T,
+                          weightBy = weightBy)
+  # add rownames or label as x-position to data frame,
+  # depending on plot type. for lines, we assume continuous
+  # scale.
+  if (type == ""lines"")
+    bars.xpos <- as.numeric(mydat$mydat$label)
+  else
+    bars.xpos <- dplyr::add_rownames(mydat$mydat, var = ""xpos"")$xpos
+  # --------------------------------------------------------
   # try to automatically set labels is not passed as argument
   # --------------------------------------------------------
-  if (is.null(axisLabels.x)) axisLabels.x <- sjmisc:::autoSetValueLabels(x)
-  if (is.null(legendLabels)) legendLabels <- sjmisc:::autoSetValueLabels(grp)
-  if (is.null(axisTitle.x)) axisTitle.x <- sjmisc:::autoSetVariableLabels(x)
-  if (is.null(legendTitle)) legendTitle <- sjmisc:::autoSetVariableLabels(grp)  
+  if (is.null(axisLabels.x)) axisLabels.x <- mydat$labels.cnt
+  if (is.null(legendLabels)) legendLabels <- mydat$labels.grp
+  if (is.null(axisTitle.x)) axisTitle.x <- sjmisc::get_label(x, def.value = var.name.cnt)
+  if (is.null(legendTitle)) legendTitle <- sjmisc::get_label(grp, def.value = var.name.grp)
   if (is.null(title)) {
-    t1 <- sjmisc:::autoSetVariableLabels(x)
-    t2 <- sjmisc:::autoSetVariableLabels(grp)
+    t1 <- sjmisc::get_label(x, def.value = var.name.cnt)
+    t2 <- sjmisc::get_label(grp, def.value = var.name.grp)
     if (!is.null(t1) && !is.null(t2)) title <- paste0(t1, "" by "", t2)
   }
   # --------------------------------------------------------
@@ -189,267 +218,104 @@ sjp.xtab <- function(x,
   if (!is.null(axisTitle.x) && axisTitle.x == """") axisTitle.x <- NULL
   if (!is.null(axisTitle.y) && axisTitle.y == """") axisTitle.y <- NULL  
   if (!is.null(title) && title == """") title <- NULL    
-  # determine table index, i.e. if row-percentages, column-percentages
-  # or cell-percentages should be displayed
-  tindex <- ifelse(tableIndex == ""row"", 1, 2)
   # --------------------------------------------------------
-  # convert factor to numeric
+  # Check if user wants to add total column, and if so,
+  # define amount of categories
   # --------------------------------------------------------
-  if (is.factor(grp)) grp <- sjmisc::to_value(grp, keep.labels = F)
-  if (is.factor(x)) x <- sjmisc::to_value(x, keep.labels = F)
-  # --------------------------------------------------------
-  # We have several options to name the diagram type
-  # Here we will reduce it to a unique value
-  # --------------------------------------------------------
-  if (type == ""b"" || type == ""bar"") type <- c(""bars"")
-  if (type == ""l"" || type == ""line"") type <- c(""lines"")
-  if (expand.grid == TRUE) {
-    expand.grid <- ggplot2::waiver()
-  } else {
-    expand.grid <- c(0, 0)
-  }
-  # --------------------------------------------------------
-  # unlist labels
-  # --------------------------------------------------------
-  if (!is.null(axisLabels.x) && is.list(axisLabels.x)) {
-    axisLabels.x <- unlistlabels(axisLabels.x)
-  }
-  if (!is.null(legendLabels) && is.list(legendLabels)) {
-    legendLabels <- unlistlabels(legendLabels)
-  }
-  # -----------------------------------------------
-  # handle zero-counts
-  # -----------------------------------------------
-  # Determine length of count and group var
-  grplen <- length(unique(stats::na.omit(grp)))
-  countlen <- length(unique(stats::na.omit(x)))
-  # if we have legend labels, we know the exact
-  # amount of groups
-  if (is.null(legendLabels)) {
-    grpcount <- grplen
-  } else {
-    grpcount <- length(legendLabels)
-  }
-  # if we have category labels, we know the exact
-  # amount of categories
-  if (is.null(axisLabels.x)) {
-    catcount <- countlen
-  } else {
-    catcount <- length(axisLabels.x)
-  }
+  if (showTotalColumn) legendLabels <- c(legendLabels, stringTotal)
+  grpcount <- length(legendLabels)
   # -----------------------------------------------
-  # create cross table for stats, summary etc.
-  # and weight variable
+  # check whether row, column or cell percentages are requested
   #---------------------------------------------------
-  ftab <- crosstabsum(x, grp, weightBy)
+  if (tableIndex == ""cell"")
+    myptab <- mydat$proptab.cell
+  else if (tableIndex == ""col"")
+    myptab <- mydat$proptab.col
+  else if (tableIndex == ""row"")
+    myptab <- mydat$proptab.row
+  myptab <- dplyr::add_rownames(data.frame(myptab))
   # -----------------------------------------------
-  # create proportional table so we have the percentage
-  # values that should be used as y-value for the bar charts
-  # We now have a data frame with categories, group-association
-  # and percentage values (i.e. each cell as separate row in the
-  # data frame)
-  # -----------------------------------------------
-  if (tableIndex == ""cell"") {
-    mydf <- as.data.frame(prop.table(ftab))
-  } else {
-    mydf <- as.data.frame(prop.table(ftab, tindex))
-  }
-  # -----------------------------------------------
-  # Bind N-values as extra column to the data frame
-  # -----------------------------------------------
-  mydf <- cbind(mydf, as.data.frame(ftab)[, 3])
-  names(mydf) <- c(""Count"", ""Group"", ""Perc"", ""Sum"")
+  # tidy data
+  #---------------------------------------------------
+  mydf <- tidyr::gather(myptab,
+                        ""group"",
+                        ""prc"",
+                        2:(grpcount + 1),
+                        factor_key = TRUE)
   # -----------------------------------------------
-  # don't show bar with category sum score when we 
-  # have column or cell percentages
+  # add total column and row to n-values
+  #---------------------------------------------------
+  if (tableIndex != ""row"")
+    mydat$mydat$total <- unname(rowSums(mydat$mydat[, -1]))
+  if (tableIndex != ""col"")
+    mydat$mydat <-
+    rbind(mydat$mydat, c(""total"", unname(colSums(mydat$mydat[, -1]))))
   # -----------------------------------------------
-  if (tableIndex == ""row"" || tableIndex == ""cell"") showTotalColumn <- FALSE
+  # add n-values to tidy data frame
+  #---------------------------------------------------
+  dummydf <- tidyr::gather(mydat$mydat,
+                           ""group"",
+                           ""n"",
+                           2:(grpcount + 1),
+                           factor_key = TRUE)
+  mydf$n <- dummydf$n
   # -----------------------------------------------
-  # Sum scores / total percentages for each category
+  # remove total for row and column index
+  #---------------------------------------------------
+  if (tableIndex != ""col"") mydf <- dplyr::filter(mydf, rowname != ""total"")
+  if (tableIndex == ""cell"") mydf <- dplyr::select(mydf, -total)
   # -----------------------------------------------
-  if (showTotalColumn) {
-    # retrieve category counts / percentages, exclude missings of both category and count variable
-    dummy <- as.data.frame(prop.table(table(x[which(!is.na(grp))])))
-    # ""insert"" dummy column
-    dummy <- dummy[, c(1, 1, 2)]
-    # bind sum score
-    dummy <- cbind(dummy, c(apply(ftab, 1, function(y) sum(y))))
-    names(dummy) <- c(""Count"", ""Group"", ""Perc"", ""Sum"")
-    # ""modify"" resp. correct the Group-column
-    dummy$Group <- as.factor(rep(max(grp, na.rm = TRUE) + 1))
-    # bind data to data frame
-    mydf <- rbind(mydf, dummy)
-  }
+  # xpos should be numeric factor
+  #---------------------------------------------------
+  if (suppressWarnings(anyNA(as.numeric(bars.xpos))))
+    mydf$xpos <- as.factor(bars.xpos)
+  else
+    mydf$xpos <- as.factor(as.numeric(bars.xpos))
   # --------------------------------------------------------
-  # Define amount of categories, include zero counts
-  # --------------------------------------------------------
-  # Zero counts of categories are not plotted by default because
-  # these categories don't appear in the data. If we assume a
-  # ""quasi-continuous"" scale (categories from 1 to 4 etc.), we now
-  # identify the zero counts and add / insert them into the data frame.
-  # This enables us to plot zero counts as well.
-  # We guess the maximum amount of categories either by the amount
-  # of supplied category labels. If no category labels were passed
-  # as argument, we assume that the maximum value found in the category
-  # columns represents the highest category number
-  # -----------------------------------------------
-  # Handle zero-counts in group-variable
-  # only possible if we know the exact number of groups,
-  # by passing legend labels
-  # -----------------------------------------------
-  if (grplen != grpcount) {
-    # if the maximum value of the group variable differs from the estimated
-    # group length we probably have missing categories, i.e. one group has no
-    # cases. Then, we insert an empty row here
-    mydf$Group <- sjmisc::to_value(mydf$Group, keep.labels = F)
-    # range of groups from lowest to highest group value
-    allgroups <- factor(c(min(mydf$Group):max(mydf$Group)))
-    # retrieve zero-counts, i.e. which group is missing in the data frame
-    miss <- sjmisc::to_value(allgroups[!allgroups %in% mydf$Group], keep.labels = F)
-    # retrieve subset of all rows where group is from lowest group-value to 
-    # missing group. Column 2 is the group-column
-    dummy1 <- mydf[apply(mydf, 1, function(y) all(y[2] < miss)), ]
-    # retrieve subset of all rows where group is from missing group to
-    # highest group-value. Column 2 is the group-column
-    dummy2 <- mydf[apply(mydf, 1, function(y) all(y[2] > miss)), ]
-    # create dummy-data frame that contains the missing row with zero-values
-    emptyrows <- data.frame(Count = c(1:countlen), 
-                            Group = miss, 
-                            Perc = 0.00, 
-                            Sum = 0)
-    emptyrows$Count <- as.factor(as.character(emptyrows$Count))
-    emptyrows$Group <- as.factor(as.character(emptyrows$Group))
-    # bind all three subsets together to a complete data frame
-    mydf <- rbind(dummy1, emptyrows, dummy2)
-  }
-  # set group-variable as factor
-  mydf$Group <- as.factor(mydf$Group)
-  # -----------------------------------------------
-  # Handle zero-counts in count-variable
-  # only possible if we know the exact number of categories,
-  # by passing category labels
-  # -----------------------------------------------
-  if (countlen != catcount) {
-    # separate data frame for grouping variable. we need this to
-    # determine the number of groups
-    dfgrp <- as.data.frame(table(mydf$Group))
-    # determine the number of groups
-    gcnt <- nrow(dfgrp)
-    mydat <- NULL
-    # fill in possible zero counts in each group
-    for (i in 1:gcnt) {
-      # get subset of data frame with each group
-      subdf <- mydf[mydf$Group == dfgrp$Var1[i], ]
-      # convert factors to numeric (due to calculations they have
-      # to be treated like that)
-      subdf$Count <- sjmisc::to_value(subdf$Count, keep.labels = F)
-      subdf$Group <- sjmisc::to_value(subdf$Group, keep.labels = F)
-      # Create a vector of zeros 
-      frq <- rep(0, catcount)
-      sm <- rep(0, catcount)
-      gp <- rep(dfgrp$Var1[i], catcount)
-      # Replace the values in freq for those indices which equal dummyf$xa
-      # by dummyf$ya so that remaining indices are ones which you 
-      # intended to insert 
-      frq[subdf$Count] <- subdf$Perc
-      sm[subdf$Count] <- subdf$Sum
-      # create new data frame. We now have a data frame with all
-      # variable categories abd their related counts, including
-      # zero counts, but no(!) missings!
-      dummydat <- data.frame(Count = 1:catcount, 
-                             Group = gp, 
-                             Perc = frq, 
-                             Sum = sm)
-      # append dummy data frame to final data frame
-      mydat <- as.data.frame(rbind(mydat, dummydat))
-    }
-    # copy final data frame
-    mydf <- mydat
-  }
-  # ----------------------------
-  # make sure group and count variable 
-  # are factor values
-  # ----------------------------
-  mydf$Count <- as.factor(mydf$Count)
-  mydf$Group <- as.factor(mydf$Group)
   # add half of Percentage values as new y-position for stacked bars
-  mydf <- mydf %>% 
-    dplyr::group_by(Count) %>% 
-    dplyr::mutate(ypos = cumsum(Perc) - 0.5 * Perc) %>% 
-    dplyr::arrange(Count)
+  # --------------------------------------------------------
+  mydf <- mydf %>%
+    dplyr::group_by(group) %>%
+    dplyr::mutate(ypos = cumsum(prc) - 0.5 * prc) %>%
+    dplyr::arrange(group)
   # add line-break char
   if (showPercentageValues && showCountValues) {
     mydf$line.break <- ifelse(coord.flip == TRUE, ' ', '\n')
   } else {
     mydf$line.break <- """"
   }
-  if (barPosition == ""dodge"") mydf$ypos <- mydf$Perc
   # --------------------------------------------------------
-  # Caculate vertical adjustment to avoid overlapping labels
+  # define label position for dodged bars
   # --------------------------------------------------------
-  jvert <- rep(c(1.1, -0.1), length.out = length(unique(mydf$Group)))
-  jvert <- rep(jvert, length.out = nrow(mydf))
-  # ----------------------------
-  # create expression with model summarys. used
-  # for plotting in the diagram later
-  # ----------------------------
-  if (showTableSummary) {
-    modsum <- crosstabsum(ftab)
-  } else {
-    modsum <- NULL
-  }
+  if (barPosition == ""dodge"") mydf$ypos <- mydf$prc
   # --------------------------------------------------------
-  # Prepare and trim legend labels to appropriate size
+  # finally, percentage values need to be between 0 and 1
   # --------------------------------------------------------
-  # Check whether we have any labels passed as argument
-  if (is.null(legendLabels)) {
-    # if not, use category text of group variable as legend text
-    if (!showTotalColumn) {
-      legendLabels <- c(order(unique(mydf$Group)))
-    } else {
-      # in case we have the total column added,
-      # we need to remove the last group-label (which
-      # indicates the total column), because the string for
-      # the total column is added below
-      ll <- c(order(unique(mydf$Group)))
-      legendLabels <- ll[-length(ll)]
-    }
-  }
-  legendLabels <- c(legendLabels, stringTotal)
-  # wrap legend text lines
-  legendLabels <- sjmisc::word_wrap(legendLabels, breakLegendLabelsAt)
-  # check whether we have a title for the legend
-  if (!is.null(legendTitle)) {
-    # if yes, wrap legend title line
-    legendTitle <- sjmisc::word_wrap(legendTitle, breakLegendTitleAt)
-  }
+  mydf$prc <- mydf$prc / 100
+  mydf$ypos <- mydf$ypos / 100
   # --------------------------------------------------------
-  # Trim labels and title to appropriate size
+  # Prepare and trim legend labels to appropriate size
   # --------------------------------------------------------
-  # check length of diagram title and split longer string at into new lines
-  # every 50 chars
+  if (!is.null(legendLabels)) legendLabels <- sjmisc::word_wrap(legendLabels, breakLegendLabelsAt)
+  if (!is.null(legendTitle)) legendTitle <- sjmisc::word_wrap(legendTitle, breakLegendTitleAt)
   if (!is.null(title)) {
     # if we have weighted values, say that in diagram's title
-    if (!is.null(weightByTitleString)) {
-      title <- paste(title, weightByTitleString, sep = """")
-    }
+    if (!is.null(weightByTitleString)) title <- paste(title, weightByTitleString, sep = """")
     title <- sjmisc::word_wrap(title, breakTitleAt)
   }
-  # check length of x-axis-labels and split longer strings at into new lines
-  # every 10 chars, so labels don't overlap
-  if (!is.null(axisLabels.x)) {
-    axisLabels.x <- sjmisc::word_wrap(axisLabels.x, breakLabelsAt)
-  } else  {
-    # If axisLabels.x were not defined, simply set numbers from 1 to
-    # amount of categories (=number of rows) in dataframe instead
-    axisLabels.x <- c(1:catcount)
+  if (!is.null(axisTitle.x)) axisTitle.x <- sjmisc::word_wrap(axisTitle.x, breakTitleAt)
+  if (!is.null(axisTitle.y)) axisTitle.y <- sjmisc::word_wrap(axisTitle.y, breakTitleAt)
+  if (!is.null(axisLabels.x)) axisLabels.x <- sjmisc::word_wrap(axisLabels.x, breakLabelsAt)
+  # ----------------------------
+  # create expression with model summarys. used
+  # for plotting in the diagram later
+  # ----------------------------
+  if (showTableSummary) {
+    modsum <- crosstabsum(x, grp, weightBy)
+  } else {
+    modsum <- NULL
   }
   # --------------------------------------------------------
-  # check if category-oder on x-axis should be reversed
-  # change category label order then
-  # --------------------------------------------------------
-  if (reverseOrder) axisLabels.x <- rev(axisLabels.x)
-  # --------------------------------------------------------
   # Prepare bar charts
   # --------------------------------------------------------
   # calculate upper y-axis-range
@@ -465,36 +331,20 @@ sjp.xtab <- function(x,
   } else {
     # else calculate upper y-axis-range depending
     # on the amount of max. answers per category
-    upper_lim <- max(((100 * mydf$Perc) + 10) / 100)
+    upper_lim <- max(mydf$prc) * 1.1
     if (upper_lim > 1) upper_lim <- 1
   }
   # --------------------------------------------------------
-  # define vertical position for labels
-  # --------------------------------------------------------
-  if (coord.flip) {
-    # if we flip coordinates, we have to use other arguments
-    # than for the default layout
-    vert <- 0.35
-    if (labelPos == ""outside"" || labelPos == ""o"")
-      hpos = -0.2
-    else if (labelPos == ""inside"" || labelPos == ""i"")
-      hpos = 1.2
-    else
-      hpos <- ggplot2::waiver()
-    hort <- ifelse(barPosition == ""dodge"", hpos, ggplot2::waiver())
-  } else {
-    hort <- ggplot2::waiver()
-    if (labelPos == ""outside"" || labelPos == ""o"")
-      vpos = -0.4
-    else if (labelPos == ""inside"" || labelPos == ""i"")
-      vpos = 1.2
-    else
-      vpos <- ggplot2::waiver()
-    vert <- ifelse(barPosition == ""dodge"", vpos, ggplot2::waiver())
+  # check if category-oder on x-axis should be reversed
+  # change category label order then
+  # --------------------------------------------------------
+  if (reverseOrder) {
+    axisLabels.x <- rev(axisLabels.x)
+    mydf$xpos <- rev(mydf$xpos)
   }
-  # check for jitter value labels
-  if (jitterValueLabels) vert <- jvert
+  # --------------------------------------------------------
   # align dodged position of labels to bar positions
+  # --------------------------------------------------------
   posdodge <- ifelse(type == ""lines"", 0, geom.size + geom.spacing)
   if (!showCategoryLabels) axisLabels.x <- c("""")
   # --------------------------------------------------------
@@ -505,57 +355,52 @@ sjp.xtab <- function(x,
     # as well, sofor better reading
     if (barPosition == ""dodge"") {
       if (showPercentageValues && showCountValues) {
-        ggvaluelabels <- geom_text(aes(y = ypos, label = sprintf(""%.01f%%%s(n=%i)"", 100 * Perc, line.break, Sum)),
+        ggvaluelabels <- geom_text(aes(y = ypos, label = sprintf(""%.01f%%%s(n=%i)"", 100 * prc, line.break, n)),
                                    position = position_dodge(posdodge),
-                                   vjust = vert,
-                                   hjust = hort)
+                                   vjust = vjust,
+                                   hjust = hjust)
       } else if (showPercentageValues) {
-        ggvaluelabels <- geom_text(aes(y = ypos, label = sprintf(""%.01f%%"", 100 * Perc)),
+        ggvaluelabels <- geom_text(aes(y = ypos, label = sprintf(""%.01f%%"", 100 * prc)),
                                    position = position_dodge(posdodge),
-                                   vjust = vert,
-                                   hjust = hort)
+                                   vjust = vjust,
+                                   hjust = hjust)
       } else if (showCountValues) {
-        ggvaluelabels <- geom_text(aes(y = ypos, label = sprintf(""n=%i"", Sum)),
+        ggvaluelabels <- geom_text(aes(y = ypos, label = sprintf(""n=%i"", n)),
                                    position = position_dodge(posdodge),
-                                   vjust = vert,
-                                   hjust = hort)
+                                   vjust = vjust,
+                                   hjust = hjust)
       }
     } else {
       if (showPercentageValues && showCountValues) {
-        ggvaluelabels <- geom_text(aes(y = ypos, label = sprintf(""%.01f%%%s(n=%i)"", 100 * Perc, line.break, Sum)),
-                                   vjust = vert,
-                                   hjust = hort)
+        ggvaluelabels <- geom_text(aes(y = ypos, label = sprintf(""%.01f%%%s(n=%i)"", 100 * prc, line.break, n)),
+                                   vjust = vjust,
+                                   hjust = hjust)
       } else if (showPercentageValues) {
-        ggvaluelabels <- geom_text(aes(y = ypos, label = sprintf(""%.01f%%"", 100 * Perc)),
-                                   vjust = vert,
-                                   hjust = hort)
+        ggvaluelabels <- geom_text(aes(y = ypos, label = sprintf(""%.01f%%"", 100 * prc)),
+                                   vjust = vjust,
+                                   hjust = hjust)
       } else if (showCountValues) {
-        ggvaluelabels <- geom_text(aes(y = ypos, label = sprintf(""n=%i"", Sum)),
-                                   vjust = vert,
-                                   hjust = hort)
+        ggvaluelabels <- geom_text(aes(y = ypos, label = sprintf(""n=%i"", n)),
+                                   vjust = vjust,
+                                   hjust = hjust)
       }
     }
   } else {
-    ggvaluelabels <- geom_text(label = """")
+    ggvaluelabels <- geom_text(aes(y = ypos), label = """")
   }
   # --------------------------------------------------------
   # Set up grid breaks
   # --------------------------------------------------------
   if (is.null(gridBreaksAt)) {
     gridbreaks <- ggplot2::waiver()
   } else {
-    gridbreaks <- c(seq(0, upper_lim, by = gridBreaksAt))
+    gridbreaks <- c(seq(lower_lim, upper_lim, by = gridBreaksAt))
   }
   # ----------------------------------
   # construct final plot, base constructor
   # first, set x scale
   # ----------------------------------
   scalex <- scale_x_discrete(labels = axisLabels.x)
-  # --------------------------------------------------------
-  # check if category-oder on x-axis should be reversed
-  # change x axis order then
-  # --------------------------------------------------------
-  if (reverseOrder) mydf$Count <- rev(mydf$Count)
   # ----------------------------------
   # check whether bars or lines should be printed
   # ----------------------------------
@@ -572,19 +417,19 @@ sjp.xtab <- function(x,
   # check if we have lines
   } else if (type == ""lines"") {
     line.stat <- ifelse(smoothLines == TRUE, ""smooth"", ""identity"")
-    geob <- geom_line(aes(x = as.numeric(Count),
-                          y = Perc,
-                          colour = Group),
+    geob <- geom_line(aes(x = as.numeric(xpos),
+                          y = prc,
+                          colour = group),
                       data = mydf,
                       size = geom.size, 
                       stat = line.stat)
   }
   # --------------------------------------------------------
   # start plot here
   # --------------------------------------------------------
-  baseplot <- ggplot(mydf, aes(x = Count, 
-                               y = Perc, 
-                               fill = Group)) + geob
+  baseplot <- ggplot(mydf, aes(x = xpos, 
+                               y = prc, 
+                               fill = group)) + geob
   # if we have line diagram, print lines here
   if (type == ""lines"") {
     baseplot <- baseplot + 
@@ -614,7 +459,7 @@ sjp.xtab <- function(x,
     # It either corresponds to the maximum amount of cases in the data set
     # (length of var) or to the highest count of var's categories.
     scale_y_continuous(breaks = gridbreaks, 
-                       limits = c(0, upper_lim), 
+                       limits = c(lower_lim, upper_lim), 
                        expand = expand.grid, 
                        labels = percent)
   # check whether coordinates should be flipped, i.e.

---FILE: R/sjTabDataFrame.R---
@@ -106,6 +106,7 @@
 #'                   css.arc = ""color:blue;""))}
 #'
 #' @importFrom utils txtProgressBar setTxtProgressBar
+#' @importFrom psych describe
 #' @export
 sjt.df <- function(mydf,
                    describe = TRUE,
@@ -144,7 +145,7 @@ sjt.df <- function(mydf,
     missings <- apply(mydf, 2, function(x) sum(is.na(x)))
     # and proportion of missings
     missings.percentage <- round(100 * missings / nrow(mydf), 2)
-    mydf <- round(describe(mydf), 2)
+    mydf <- round(psych::describe(mydf), 2)
     # insert missing variables in data frame
     mydf <- data.frame(mydf[, 1:2], 
                        missings, 
@@ -158,8 +159,8 @@ sjt.df <- function(mydf,
                                   function(x)
                                     if (max(x, na.rm = T) > 999)
                                       prettyNum(x, big.mark = "","")
-                                  else
-                                    x))
+                                    else
+                                      x))
     }
   }
   # -------------------------------------

---FILE: R/sjTabFrequencies.R---
@@ -528,7 +528,7 @@ sjt.frq <- function(data,
     df.frq <- create.frq.df(data[[cnt]],
                             breakLabelsAt = Inf,
                             order.frq = sort.frq,
-                            2,
+                            round.prz = digits,
                             na.rm = F, 
                             weightBy = weightBy)
     df <- df.frq$mydat

---FILE: R/sjTabPropTable.R---
@@ -10,8 +10,6 @@
 #'              
 #' @param var.row variable that should be displayed in the table rows.
 #' @param var.col variable that should be displayed in the table columns.
-#' @param var.grp optional grouping variable that splits the data into several groups,
-#'          depending on the amount of categories. See 'Examples'.
 #' @param weightBy weight factor that will be applied to weight all cases.
 #'          Must be a vector of same length as \code{var.row}. Default is \code{NULL}, so no weights are used.
 #' @param digits amount of digits used for the percentage values inside table cells.
@@ -142,7 +140,6 @@
 #' @export
 sjt.xtab <- function(var.row,
                      var.col,
-                     var.grp = NULL,
                      weightBy = NULL,
                      digits = 1,
                      file = NULL,
@@ -190,177 +187,56 @@ sjt.xtab <- function(var.row,
   # -------------------------------------
   encoding <- get.encoding(encoding)
   # --------------------------------------------------------
-  # try to automatically set labels is not passed as parameter
+  # get variable name
   # --------------------------------------------------------
-  if (is.null(valueLabels)) {
-    valueLabels <- list()
-    # --------------------------------------------------------
-    # row value labels
-    # --------------------------------------------------------
-    vl <- sjmisc:::autoSetValueLabels(var.row)
-    if (is.null(vl)) vl <- sort(unique(stats::na.omit(var.row)))
-    valueLabels[[1]] <- vl
-    # --------------------------------------------------------
-    # column value labels
-    # --------------------------------------------------------
-    vl <- sjmisc:::autoSetValueLabels(var.col)
-    if (is.null(vl)) vl <- sort(unique(stats::na.omit(var.col)))
-    valueLabels[[2]] <- vl
-    # --------------------------------------------------------
-    # group value labels
-    # --------------------------------------------------------
-    if (!is.null(var.grp)) {
-      vl <- sjmisc:::autoSetValueLabels(var.grp)
-      if (is.null(vl)) vl <- sort(unique(stats::na.omit(var.grp)))
-      valueLabels[[3]] <- vl
-    }
-  }
-  # -------------------------------------
-  # list conversion needed here. in case value labels
-  # of only one variable were detected, ""valueLabels"" is now
-  # of type ""character"", thus length would differ from ""valueLabels""'s
-  # length if it were a list. needed below.
-  # -------------------------------------
-  if (!is.null(valueLabels) && !is.list(valueLabels)) valueLabels <- list(valueLabels)
+  var.name.row <- get_var_name(deparse(substitute(var.row)))
+  var.name.col <- get_var_name(deparse(substitute(var.col)))
+  # --------------------------------------------------------
+  # create cross table of frequencies and percentages
+  # --------------------------------------------------------
+  mydat <- create.xtab.df(var.row,
+                          var.col,
+                          round.prz = digits,
+                          na.rm = !showNA,
+                          weightBy = weightBy)
   # --------------------------------------------------------
   # try to automatically set labels is not passed as parameter
   # --------------------------------------------------------
   if (is.null(variableLabels)) {
-    variableLabels <- c()
-    vn1 <- sjmisc:::autoSetVariableLabels(var.row)
-    vn2 <- sjmisc:::autoSetVariableLabels(var.col)
-    if (!is.null(vn1) && !is.null(vn2)) variableLabels <- c(vn1, vn2)
-    if (!is.null(var.grp)) {
-      vn3 <- sjmisc:::autoSetVariableLabels(var.grp)
-      if (!is.null(vn3)) variableLabels <- c(variableLabels, vn3)
-    }
+    variableLabels <- c(sjmisc::get_label(var.row, def.value = var.name.row),
+                        sjmisc::get_label(var.col, def.value = var.name.col))
   }
+  s.var.row <- variableLabels[1]
+  s.var.col <- variableLabels[2]
   # -------------------------------------
   # init variable labels
   # -------------------------------------
-  s.var.row <- s.var.col <- s.var.grp <- NULL
-  if (!is.null(variableLabels)) {
-    s.var.row <- ifelse(length(variableLabels) > 0, variableLabels[1], ""var.row"")
-    s.var.col <- ifelse(length(variableLabels) > 1, variableLabels[2], ""var.col"")
-    s.var.grp <- ifelse(length(variableLabels) > 2, variableLabels[3], ""var.grp"")
-  } else {
-    s.var.row <- ""var.row""
-    s.var.col <- ""var.col""
-    s.var.grp <- ""var.grp""
+  labels.var.row <- sjmisc::word_wrap(mydat$labels.cnt, breakVariableLabelsAt, ""<br>"")
+  labels.var.col <- sjmisc::word_wrap(mydat$labels.grp, breakVariableLabelsAt, ""<br>"")
+  # add ""total?
+  if (showTotalN) {
+    labels.var.row <- c(labels.var.row, stringTotal)
+    labels.var.col <- c(labels.var.col, stringTotal)
   }
-  # check length of variable labels and split longer strings at into new lines
-  if (!is.null(s.var.row)) s.var.row <- sjmisc::word_wrap(s.var.row, breakVariableLabelsAt, ""<br>"")
-  if (!is.null(s.var.col)) s.var.col <- sjmisc::word_wrap(s.var.col, breakVariableLabelsAt, ""<br>"")
-  if (!is.null(s.var.grp)) s.var.grp <- sjmisc::word_wrap(s.var.grp, breakVariableLabelsAt, ""<br>"")
-  # -------------------------------------
-  # compute xtab
-  # -------------------------------------
-  # check if we have missings or not
-  # -------------------------------------
-  if (showNA) {
-    # check if we have weights or not
-    if (is.null(weightBy)) {
-      # check if we have groupings or not
-      if (is.null(var.grp)) {
-        tab <- stats::ftable(stats::xtabs(~ addNA(as.factor(var.row)) + addNA(as.factor(var.col))))
-        coladd <- 3
-      } else {
-        tab <- stats::ftable(stats::xtabs(~ addNA(var.grp) + addNA(as.factor(var.row)) + addNA(as.factor(var.col))))
-        coladd <- 4
-      }
-    } else {
-      # check if we have groupings or not
-      if (is.null(var.grp)) {
-        tab <- stats::ftable(stats::xtabs(weightBy ~ addNA(as.factor(var.row)) + addNA(as.factor(var.col))))
-        coladd <- 3
-      } else {
-        tab <- stats::ftable(stats::xtabs(weightBy ~ addNA(var.grp) + addNA(as.factor(var.row)) + addNA(as.factor(var.col))))
-        coladd <- 4
-      }
-      # round integer
-      tab <- round(tab)
-    }
   # -------------------------------------
-  # no missings to show here
-  # -------------------------------------
-  } else {
-    # check if we have weights or not
-    if (is.null(weightBy)) {
-      # check if we have groupings or not
-      if (is.null(var.grp)) {
-        tab <- stats::ftable(stats::xtabs(~ as.factor(var.row) + as.factor(var.col)))
-        coladd <- 2
-      } else {
-        tab <- stats::ftable(stats::xtabs(~ var.grp + as.factor(var.row) + as.factor(var.col)))
-        coladd <- 3
-      }
-    } else {
-      # check if we have groupings or not
-      if (is.null(var.grp)) {
-        tab <- stats::ftable(stats::xtabs(weightBy ~ as.factor(var.row) + as.factor(var.col)))
-        coladd <- 2
-      } else {
-        tab <- stats::ftable(stats::xtabs(weightBy ~ var.grp + as.factor(var.row) + as.factor(var.col)))
-        coladd <- 3
-      }
-      # round integer
-      tab <- round(tab)
-    }
-  }
+  # compute table counts and percentages
   # -------------------------------------
-  # compute table percentages
+  tab <- mydat$mydat[, -1]
+  tab$total <- unname(rowSums(tab))
+  tab <- rbind(tab, unname(colSums(tab)))
+  tab.cell <- mydat$proptab.cell
+  tab.row <- mydat$proptab.row
+  tab.row$total <- tab.cell$total
+  tab.col <- mydat$proptab.col
+  tab.col <- rbind(tab.col, tab.cell[nrow(tab.cell), ])
+  tab.expected <- sjmisc::table_values(ftable(as.matrix(tab)))$expected
   # -------------------------------------
-  tab.values <- sjmisc::table_values(tab, digits)
-  tab.cell <- tab.values$cell
-  tab.row <- tab.values$row
-  tab.col <- tab.values$col
-  tab.expected <- tab.values$expected
+  # determine total number of columns and rows
   # -------------------------------------
-  # determine total number of columns
-  # we have an optional column for the grouping variable,
-  # a column for var.row labels and the columns for the
-  # var.col data. Finally, we have a ""total"" column
-  # -------------------------------------
-  totalncol <- ncol(tab) + coladd
-  # -------------------------------------
-  # init value labels
-  # -------------------------------------
-  labels.var.row <- labels.var.grp <- labels.var.col <- NULL
-  # -------------------------------------
-  # check how many value labels have been supplied
-  # and set value labels
-  # -------------------------------------
-  if (length(valueLabels) > 0) {
-    labels.var.row <- valueLabels[[1]]
-  } else {
-    labels.var.row <- seq_along(unique(stats::na.omit(var.row)))
-  }
-  if (length(valueLabels) > 1) {
-    labels.var.col <- valueLabels[[2]]
-  } else {
-    labels.var.col <- seq_along(unique(stats::na.omit(var.col)))
-  }
-  if (length(valueLabels) > 2) {
-    labels.var.grp <- valueLabels[[3]]
-  } else {
-    if (is.null(var.grp)) {
-      labels.var.grp <- NULL
-    } else {
-      labels.var.grp <- seq_along(unique(stats::na.omit(var.grp)))
-    }
-  }
-  # ------------------------------------------
-  # add label for missing colum
-  # ------------------------------------------
-  if (showNA) {
-    labels.var.col <- c(labels.var.col, labelNA)
-    labels.var.row <- c(labels.var.row, labelNA)
-    if (!is.null(labels.var.grp)) labels.var.grp <- c(labels.var.grp, labelNA)
-  }
-  # check length of variable labels and split longer strings at into new lines
-  if (!is.null(labels.var.row)) labels.var.row <- sjmisc::word_wrap(labels.var.row, breakValueLabelsAt, ""<br>"")
-  if (!is.null(labels.var.col)) labels.var.col <- sjmisc::word_wrap(labels.var.col, breakValueLabelsAt, ""<br>"")
-  if (!is.null(labels.var.grp)) labels.var.grp <- sjmisc::word_wrap(labels.var.grp, breakValueLabelsAt, ""<br>"")
+  totalncol <- ncol(tab)
+  if (!showTotalN) totalncol <- totalncol - 1
+  totalnrow <- nrow(tab)
+  if (!showTotalN) totalnrow <- totalnrow - 1
   # -------------------------------------
   # table init
   # -------------------------------------
@@ -437,12 +313,6 @@ sjt.xtab <- function(var.row,
   page.content <- ""<table>\n""
   page.content <- paste(page.content, ""  <tr>\n"")
   # -------------------------------------
-  # check whether we have additional grouping column
-  # -------------------------------------
-  if (!is.null(var.grp)) {
-    page.content <- paste(page.content, sprintf(""    <th class=\""thead firstcolborder\"" rowspan=\""2\"">%s</th>\n"", s.var.grp))
-  }
-  # -------------------------------------
   # column with row-variable-name
   # -------------------------------------
   page.content <- paste(page.content, sprintf(""    <th class=\""thead firstcolborder\"" rowspan=\""2\"">%s</th>\n"", s.var.row))
@@ -469,49 +339,30 @@ sjt.xtab <- function(var.row,
   # -------------------------------------
   # table content
   # -------------------------------------
-  # retrieve index colums of group var, if we have any
-  # if we have a grouping variable, we need to know at
-  # which row a new category of group starts
-  # -------------------------------------
-  if (is.null(var.grp)) {
-    group.var.rows <- NULL
-  } else {
-    group.var.rows <- seq(1, nrow(tab), by = length(labels.var.row))
-  }
-  # -------------------------------------
-  # if we have group vars, we need a repeating counter vor row value labels
-  # -------------------------------------
-  if (!is.null(group.var.rows)) {
-    rowlabelcnt <- rep(1:length(labels.var.row), length(group.var.rows))
-  } else {
-    rowlabelcnt <- 1:length(labels.var.row)
-  }
+  rowlabelcnt <- 1:length(labels.var.row)
   # -------------------------------------
   # iterate all table data rows
   # -------------------------------------
-  for (irow in 1:nrow(tab)) {
+  for (irow in 1:totalnrow) {
     # -------------------------------------
     # start new table row
     # -------------------------------------
     page.content <- paste(page.content, ""\n  <tr>"")
     # -------------------------------------
-    # check for group var label, resp. if group var
-    # starts with current row
-    # -------------------------------------
-    if (any(group.var.rows == irow)) {
-      page.content <- paste(page.content, 
-                            sprintf(""\n    <td class=\""tdata leftalign\"" rowspan=\""%i\"">%s</td>"",
-                                    length(labels.var.row), 
-                                    labels.var.grp[which(group.var.rows == irow)]))
-    }
-    # -------------------------------------
     # set row variable label
     # -------------------------------------
-    page.content <- paste(page.content, sprintf(""\n    <td class=\""tdata leftalign\"">%s</td>"", labels.var.row[rowlabelcnt[irow]]))
+    if (irow == totalnrow) 
+      css_last_row <- ""lasttablerow tothi ""
+    else
+      css_last_row <- "" ""
+    page.content <- paste(page.content, 
+                          sprintf(""\n    <td class=\""tdata %sleftalign\"">%s</td>"", 
+                                  css_last_row,
+                                  labels.var.row[rowlabelcnt[irow]]))
     # -------------------------------------
     # iterate all data columns
     # -------------------------------------
-    for (icol in 1:ncol(tab)) {
+    for (icol in 1:totalncol) {
       cellstring <- """"
       # -------------------------------------
       # first table cell data contains observed values
@@ -529,7 +380,7 @@ sjt.xtab <- function(var.row,
       # -------------------------------------
       if (showRowPerc) {
         if (!sjmisc::is_empty(cellstring)) cellstring <- paste0(cellstring, ""<br>"")
-        cellstring <- paste(cellstring, sprintf(""<span class=\""td_rw\"">%s%s</span>"", tab.row[irow, icol],percSign), sep = """")
+        cellstring <- paste(cellstring, sprintf(""<span class=\""td_rw\"">%s%s</span>"", tab.row[irow, icol], percSign), sep = """")
       }
       # -------------------------------------
       # if we have col-percentage, add percentage value to table cell
@@ -550,115 +401,9 @@ sjt.xtab <- function(var.row,
       # -------------------------------------
       page.content <- paste(page.content, sprintf(""\n    <td class=\""tdata centeralign horline\"">%s</td>"", cellstring), sep = """")
     }
-    # -------------------------------------
-    # after all data columns have been printed,
-    # add a total column
-    # -------------------------------------
-    cellstring <- """"
-    # -------------------------------------
-    # first table cell data contains observed values
-    # -------------------------------------
-    if (showObserved || showTotalN) {
-      cellstring <- sprintf(""<span class=\""td_n\"">%i</span>"", rowSums(tab)[irow])
-    }
-    # if we have expected values, add them to table cell
-    if (showExpected) {
-      if (!sjmisc::is_empty(cellstring)) cellstring <- paste0(cellstring, ""<br>"")
-      cellstring <- paste(cellstring, sprintf(""<span class=\""td_ex\"">%s</span>"", rowSums(tab.expected)[irow]), sep = """")
-    }
-    # if we have row-percentage, add percentage value to table cell
-    if (showRowPerc) {
-      if (!sjmisc::is_empty(cellstring)) cellstring <- paste0(cellstring, ""<br>"")
-      cellstring <- paste(cellstring, sprintf(""<span class=\""td_rw\"">%s%s</span>"", hundret, percSign), sep = """")
-    }
-    # if we have col-percentage, add percentage value to table cell
-    if (showColPerc) {
-      if (!sjmisc::is_empty(cellstring)) cellstring <- paste0(cellstring, ""<br>"")
-      cellstring <- paste(cellstring, sprintf(""<span class=\""td_cl\"">%s%s</span>"", rowSums(tab.cell)[irow], percSign), sep = """")
-    }
-    # if we have cell-percentage, add percentage value to table cell
-    if (showCellPerc) {
-      if (!sjmisc::is_empty(cellstring)) cellstring <- paste0(cellstring, ""<br>"")
-      cellstring <- paste(cellstring, sprintf(""<span class=\""td_c\"">%s%s</span>"", rowSums(tab.cell)[irow], percSign), sep = """")
-    }
-    # write table cell data
-    page.content <- paste(page.content, sprintf(""\n    <td class=\""tdata centeralign totcol horline\"">%s</td>"", cellstring), sep = """")
     # close table row
     page.content <- paste(page.content, ""\n  </tr>\n"")
   }
-  # ------------------------------
-  # start new table row
-  # this row contains the total row with sums for all columns
-  # ------------------------------
-  page.content <- paste(page.content, ""\n  <tr>\n    "", sep = """")
-  # check whether we have group-var, and if not, apply colspan
-  if (!is.null(var.grp)) {
-    page.content <- paste(page.content, sprintf(""<td class=\""tdata lasttablerow leftalign tothi\"" colspan=\""2\"">%s</td>"", stringTotal), sep = """")
-  } else {
-    page.content <- paste(page.content, sprintf(""<td class=\""tdata lasttablerow leftalign tothi\"">%s</td>"", stringTotal), sep = """")
-  }
-  # --------------------------
-  # iterate all data columns
-  # --------------------------
-  for (icol in 1:ncol(tab)) {
-    cellstring <- """"
-    # -------------------------------------
-    # add total row, first table cell data contains observed values
-    # -------------------------------------
-    if (showObserved || showTotalN) cellstring <- sprintf(""<span class=\""td_n\"">%i</span>"", colSums(tab)[icol])
-    # calculate total percentage value
-    cellpercval <- round(100 * colSums(tab)[icol] / sum(tab), digits)
-    # if we have expected values, add them to table cell
-    if (showExpected) {
-      if (!sjmisc::is_empty(cellstring)) cellstring <- paste0(cellstring, ""<br>"")
-      cellstring <- paste(cellstring, sprintf(""<span class=\""td_ex\"">%s</span>"", colSums(tab.expected)[icol]), sep = """")
-    }
-    # if we have row-percentage, add percentage value to table cell
-    if (showRowPerc) {
-      if (!sjmisc::is_empty(cellstring)) cellstring <- paste0(cellstring, ""<br>"")
-      cellstring <- paste(cellstring, sprintf(""<span class=\""td_rw\"">%s%s</span>"", cellpercval, percSign), sep = """")
-    }
-    # if we have col-percentage, add percentage value to table cell
-    if (showColPerc) {
-      if (!sjmisc::is_empty(cellstring)) cellstring <- paste0(cellstring, ""<br>"")
-      cellstring <- paste(cellstring, sprintf(""<span class=\""td_cl\"">%s%s</span>"", hundret, percSign), sep = """")
-    }
-    # if we have cell-percentage, add percentage value to table cell
-    if (showCellPerc) {
-      if (!sjmisc::is_empty(cellstring)) cellstring <- paste0(cellstring, ""<br>"")
-      cellstring <- paste(cellstring, sprintf(""<span class=\""td_c\"">%s%s</span>"", cellpercval, percSign), sep = """")
-    }
-    page.content <- paste(page.content, sprintf(""\n    <td class=\""tdata lasttablerow centeralign\"">%s</td>"", cellstring), sep = """")
-  }
-  # --------------------------
-  # the lower right table cell contains the complete
-  # total values, i.e. all percentages are 100%
-  # --------------------------
-  cellstring <- """"
-  # -------------------------------------
-  # add total row, first table cell data contains observed values
-  # -------------------------------------
-  if (showObserved || showTotalN) cellstring <- sprintf(""%s"", sum(tab))
-  if (showExpected) {
-    if (!sjmisc::is_empty(cellstring)) cellstring <- paste0(cellstring, ""<br>"")
-    cellstring <- paste(cellstring, sprintf(""%s"", sum(tab.expected)), sep = """")
-  }
-  if (showColPerc) {
-    if (!sjmisc::is_empty(cellstring)) cellstring <- paste0(cellstring, ""<br>"")
-    cellstring <- paste(cellstring, sprintf(""%s%s"", hundret, percSign), sep = """")
-  }
-  if (showRowPerc) {
-    if (!sjmisc::is_empty(cellstring)) cellstring <- paste0(cellstring, ""<br>"")
-    cellstring <- paste(cellstring, sprintf(""%s%s"", hundret, percSign), sep = """")
-  }
-  if (showCellPerc) {
-    if (!sjmisc::is_empty(cellstring)) cellstring <- paste0(cellstring, ""<br>"")
-    cellstring <- paste(cellstring, sprintf(""%s%s"", hundret, percSign), sep = """")
-  }
-  # write table cell data
-  page.content <- paste(page.content, sprintf(""\n    <td class=\""tdata lasttablerow centeralign\"">%s</td>"", cellstring), sep = """")
-  # close table row
-  page.content <- paste(page.content, ""\n  </tr>\n"")
   # -------------------------------------
   # table summary
   # -------------------------------------

---FILE: README.md---
@@ -49,6 +49,11 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 * Redesign of computation of frequency tables for `sjp.grpfrq` and `sjt.xtab`, being more robust and generally working with labelled, non-labelled, numeric, character vectors and factors.
 * Better automatic handling of variable and value labels that are used for labelling plot axes and titles or table columns.
 
+#### Changes to functions due to new ggplot2-version
+* `sjp.grpfrq` no longer has plot type `type = ""histogram""`. Maybe re-implemented in a later update. Due to this change, arguments like `showMeanIntercept` and similar were removed.
+* Plotting functions no longer have argument `labelPosition`. Instead, use arguments `vjust` and `hjust`, which correspond to the same ggplot2-aesthetics according to their possible values.
+
+
 #### Changes to functions
 * `sjp.lm` gets a `group.estimates` argument to group estimates in forest plots and colour them according to group assignment. Use arguments `show.legend` and `legendTitle` to modify group legend.
 * `sjp.lmer` and `sjp.glmer` can now plot random effect parts of random slope-intercept models (with `type = ""rs.ri""`), where regression lines or predicted probabilities of random intercept and slopes are plotted."
strengejacke,sjPlot,f160524a4702377adfbcb7431c7f09b9a3fd79a9,Daniel Ldecke,d.luedecke@uke.de,2016-01-13T18:39:43Z,Daniel Ldecke,d.luedecke@uke.de,2016-01-13T18:39:43Z,ggplot2-fix,R/sjPlotGroupFrequencies.R,False,True,True,False,129,306,435,"---FILE: R/sjPlotGroupFrequencies.R---
@@ -24,10 +24,6 @@ utils::globalVariables(c(""."", ""label"", ""prz"", ""frq"", ""ypos"", ""wb"", ""ia"", ""mw"", ""
 #'          is \code{box} or \code{violin} (resp. their alternative strings like \code{""boxplot""}, \code{""boxplots""} or \code{""v""}).
 #' @param barPosition indicates whether bars should be positioned side-by-side (default)
 #'          or stacked (use \code{""stack""} as argument).
-#'          If \code{type = ""histogram""}, you can use either \code{""dodge""} (default value), 
-#'          which displays the bars side-by-side, or \code{""identity""}, which results in 
-#'          overlaying bars. In the latter case, it's recommended to adjust the 
-#'          alpha value (see \code{\link{sjp.setTheme}}).
 #' @param type The plot type. May be one of the following:
 #'          \describe{
 #'            \item{\code{""bars""}}{for simple bars (the default setting)}
@@ -101,15 +97,6 @@ utils::globalVariables(c(""."", ""label"", ""prz"", ""frq"", ""ypos"", ""wb"", ""ia"", ""mw"", ""
 #' @param showAxisLabels.y logical, whether y-axis labels (count values) should be shown or not.
 #' @param showPlotAnnotation logical, if \code{TRUE}, the groups of dots in a dot-plot are highlighted 
 #'          with a shaded rectangle.
-#' @param showMeanIntercept logical, if \code{TRUE}, a vertical line in histograms is drawn 
-#'          to indicate the mean value of the count variables. Only applies to histogram-charts.
-#' @param showMeanValue logical, if \code{TRUE} (default value), the mean value is printed 
-#'          to the vertical line that indicates the mean value
-#'          of the count variables. Only applies to histogram-charts.
-#' @param showStandardDeviation logical, if \code{TRUE}, the standard deviation is annotated 
-#'          as shaded rectangle around the mean intercept line. Only applies to histogram-charts. 
-#'          The shaded rectangles have borders in the group colors, so it's easier to see
-#'          which shaded area belongs to which mean value resp. group.
 #' @param showTableSummary logical, if \code{TRUE}, a summary of the cross tabulation with N, 
 #'          chi-squared, df, Cramer's V or Phi-value and p-value is printed to the upper 
 #'          right corner of the plot (see \code{tableSummaryPos}. If a cell contains expected
@@ -123,10 +110,6 @@ utils::globalVariables(c(""."", ""label"", ""prz"", ""frq"", ""ypos"", ""wb"", ""ia"", ""mw"", ""
 #' @param tableSummaryPos position of the model summary which is printed when \code{showTableSummary} 
 #'          is \code{TRUE}. Default is \code{""r""}, i.e. it's printed to the upper right corner. 
 #'          Use \code{""l""} for upper left corner.
-#' @param meanInterceptLineType linetype of the mean intercept line. Only applies to histogram-charts and when
-#'          \code{showMeanIntercept = TRUE}.
-#' @param meanInterceptLineSize size of the mean intercept line. Only applies to histogram-charts and when
-#'          \code{showMeanIntercept = TRUE}.
 #' @param axisTitle.x title for the x-axis. By default, \code{""""} is used, i.e. no title
 #'          is printed. If \code{axisTitle.x = NULL}, the variable name will be 
 #'          automatically detected and used as title (see \code{\link[sjmisc]{set_label}}) 
@@ -142,15 +125,17 @@ utils::globalVariables(c(""."", ""label"", ""prz"", ""frq"", ""ypos"", ""wb"", ""ia"", ""mw"", ""
 #'          it will be grouped (using the \code{\link[sjmisc]{group_var}} function). 
 #'          Default value for \code{autoGroupAt} is \code{NULL}, i.e. auto-grouping is off.
 #'          See \code{\link[sjmisc]{group_var}} for examples on grouping.
-#' @param startAxisAt numeric, determines the lower limit of the x-axis. By default, this value is set
-#'          to \code{""auto""}, i.e. the value range on the x-axis starts with the lowest value of \code{varCount}.
-#'          If \code{startAxisAt = 1}, plot may have zero counts if the lowest value of \code{varCount}
-#'          is larger than 1 and hence no bars plotted for these values in such cases.
 #' @param coord.flip logical, if \code{TRUE}, the x and y axis are swapped.
-#' @param labelPos string, indicating the position of value labels, when \code{coord.flip = TRUE}.
-#'          Can be either \code{""inside""} or \code{""outside""} (default). You may specify
-#'          initial letter only. If \code{coord.flip = FALSE}, use \code{""center""} 
-#'          to center labels (useful if label angle is changes via \code{\link{sjp.setTheme}}).
+#' @param vjust character vector, indicating the vertical position of value 
+#'          labels. Allowed are same values as for \code{vjust} aesthetics from 
+#'          \code{ggplot2}: ""left"", ""center"", ""right"", ""bottom"", ""middle"", ""top"" and
+#'          new options like ""inward"" and ""outward"", which align text towards and 
+#'          away from the center of the plot respectively.
+#' @param hjust character vector, indicating the horizontal position of value 
+#'          labels. Allowed are same values as for \code{vjust} aesthetics from 
+#'          \code{ggplot2}: ""left"", ""center"", ""right"", ""bottom"", ""middle"", ""top"" and
+#'          new options like ""inward"" and ""outward"", which align text towards and 
+#'          away from the center of the plot respectively.
 #' @param na.rm logical, if \code{TRUE}, missings are not included in the frequency plot.
 #' @param printPlot logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 #'          want to plot any graphs. In either case, the ggplot-object will be returned as value.
@@ -174,8 +159,7 @@ utils::globalVariables(c(""."", ""label"", ""prz"", ""frq"", ""ypos"", ""wb"", ""ia"", ""mw"", ""
 #' sjp.grpfrq(efc$e17age,
 #'            efc$e16sex,
 #'            type = ""hist"",
-#'            showValueLabels = FALSE,
-#'            showMeanIntercept = TRUE)
+#'            showValueLabels = FALSE)
 #' 
 #' # boxplot
 #' sjp.grpfrq(efc$e17age, 
@@ -196,19 +180,14 @@ utils::globalVariables(c(""."", ""label"", ""prz"", ""frq"", ""ypos"", ""wb"", ""ia"", ""mw"", ""
 #'            interactionVar = efc$e16sex,
 #'            type = ""box"")
 #' 
-#' # Grouped bar plot ranging from 1 to 28 (though scale starts with 7)
-#' sjp.grpfrq(efc$neg_c_7, 
-#'            efc$e42dep, 
-#'            showValueLabels = FALSE, 
-#'            startAxisAt = 1)
-#' # Same grouped bar plot ranging from 7 to 28
+#' # Grouped bar plot ranging from 7 to 28
 #' sjp.grpfrq(efc$neg_c_7, 
 #'            efc$e42dep, 
 #'            showValueLabels = FALSE)
 #' 
 #' @import ggplot2
 #' @import sjmisc
-#' @importFrom dplyr group_by mutate arrange summarise
+#' @importFrom dplyr group_by mutate arrange summarise add_rownames
 #' @importFrom stats na.omit xtabs wilcox.test sd
 #' @export
 sjp.grpfrq <- function(varCount,
@@ -245,20 +224,15 @@ sjp.grpfrq <- function(varCount,
                        showAxisLabels.x = TRUE,
                        showAxisLabels.y = TRUE,
                        showPlotAnnotation = TRUE,
-                       showMeanIntercept = FALSE,
-                       showMeanValue = TRUE,
-                       showStandardDeviation = FALSE,
                        showTableSummary = FALSE,
                        showGroupCount = FALSE,
                        tableSummaryPos = ""r"",
-                       meanInterceptLineType = 2,
-                       meanInterceptLineSize = 0.5,
                        axisTitle.x = """",
                        axisTitle.y = """",
                        autoGroupAt = NULL,
-                       startAxisAt = ""auto"",
                        coord.flip = FALSE,
-                       labelPos = ""outside"",
+                       vjust = ""bottom"",
+                       hjust = ""center"",
                        na.rm = TRUE,
                        printPlot = TRUE) {
   # --------------------------------------------------------
@@ -326,15 +300,17 @@ sjp.grpfrq <- function(varCount,
   if (missing(title) && (type == ""boxplots"" || type == ""violin"" || type == ""histogram""))
     title <- NULL
   # --------------------------------------------------------
-  # create xtab
+  # create cross table of frequencies and percentages
   # --------------------------------------------------------
   mydat <- create.xtab.df(varCount,
                           varGroup,
                           round.prz = 2,
                           na.rm = na.rm,
                           weightBy = weightBy)
+  # add rownames as x-position to data frame
+  bars.xpos <- dplyr::add_rownames(mydat$mydat, var = ""xpos"")$xpos
   # --------------------------------------------------------
-  # try to automatically set labels is not passed as argument
+  # try to automatically set labels if not passed as argument
   # --------------------------------------------------------
   if (missing(axisLabels.x) && (type == ""boxplots"" || type == ""violin"")) {
     axisLabels.x <- mydat$labels.grp
@@ -354,8 +330,7 @@ sjp.grpfrq <- function(varCount,
   if (is.null(title)) {
     t1 <- sjmisc::get_label(varCount, def.value = var.name.cnt)
     t2 <- sjmisc::get_label(varGroup, def.value = var.name.grp)
-    if (!is.null(t1) && !is.null(t2))
-      title <- paste0(t1, "" by "", t2)
+    if (!is.null(t1) && !is.null(t2)) title <- paste0(t1, "" by "", t2)
   }
   # --------------------------------------------------------
   # remove titles if empty
@@ -396,30 +371,26 @@ sjp.grpfrq <- function(varCount,
   catcount <- length(axisLabels.x)
   catmin <- min(varCount, na.rm = TRUE)
   grpcount <- length(legendLabels)
-  # ----------------------------------------------
-  # check for axis start, depending on lowest value
-  # ----------------------------------------------
-  if (startAxisAt == ""auto"")
-    startAxisAt <- as.numeric(catmin)
   # -----------------------------------------------
   # define x-axis limits
   # -----------------------------------------------
-  if (is.null(axisLimits.x)) {
-    if (type == ""histogram"")
-      axisLimits.x <- c(catmin - 1, catcount + 1)
-    else
-      axisLimits.x <- c(catmin, catcount)
-  }
+  if (is.null(axisLimits.x)) axisLimits.x <- c(catmin, catcount)
   # -----------------------------------------------
   # create cross table for stats, summary etc.
   # and weight variable
   #---------------------------------------------------
   mydf <- tidyr::gather(mydat$mydat, ""group"", ""frq"", 2:(grpcount + 1))
-  mydf$xpos <- sjmisc::to_value(as.factor(mydf$label),
-                                start.at = catmin,
-                                keep.labels = F)
+  # -----------------------------------------------
+  # xpos should be numeric factor
+  #---------------------------------------------------
+  if (suppressWarnings(anyNA(as.numeric(bars.xpos))))
+    mydf$xpos <- as.factor(bars.xpos)
+  else
+    mydf$xpos <- as.factor(as.numeric(bars.xpos))
+  # --------------------------------------------------------
   # add half of Percentage values as new y-position for stacked bars
   # mydat <- ddply(mydat, ""count"", transform, ypos = cumsum(frq) - 0.5*frq)
+  # --------------------------------------------------------
   mydf <- mydf %>%
     dplyr::group_by(label) %>%
     dplyr::mutate(ypos = cumsum(frq) - 0.5 * frq) %>%
@@ -430,18 +401,18 @@ sjp.grpfrq <- function(varCount,
   # If we have boxplots, use different data frame structure
   # --------------------------------------------------------
   if (type == ""boxplots"" || type == ""violin"") {
+    # weight variable
     w <- ifelse(is.null(weightBy), 1, weightBy)
-    if (is.null(interactionVar)) {
-      mydf <- stats::na.omit(data.frame(cbind(group = varGroup,
-                                              frq = varCount,
-                                              wb = w)))
-    } else {
-      mydf <- stats::na.omit(data.frame(cbind(group = varGroup,
-                                              frq = varCount,
-                                              ia = interactionVar,
-                                              wb = w)))
-      mydf$ia <- as.factor(mydf$ia)
-    }
+    # interaction variable
+    if (is.null(interactionVar)) 
+      iav <- 1
+    else 
+      iav <- interactionVar
+    mydf <- stats::na.omit(data.frame(cbind(group = varGroup,
+                                            frq = varCount,
+                                            ia = iav,
+                                            wb = w)))
+    mydf$ia <- as.factor(mydf$ia)
     mydf$group <- as.factor(mydf$group)
   }
   # ----------------------------
@@ -497,13 +468,14 @@ sjp.grpfrq <- function(varCount,
   # --------------------------------------------------------
   # If we have a histogram, caluclate means of groups
   # --------------------------------------------------------
-  if (type == ""histogram"") {
-    vldat <- mydf %>%
-      dplyr::group_by(group) %>%
-      dplyr::summarise(mw = mean(frq, na.rm = T),
-                       stddev = stats::sd(frq, na.rm = T)) %>%
-      dplyr::mutate(yfactor = 1:nrow(.))
-  }
+  # if (type == ""histogram"") {
+  #   vldat <- na.omit(data.frame(x = oriVarCount, group = varGroup))
+  #   vldat <- vldat %>% 
+  #     dplyr::group_by(group) %>% 
+  #     dplyr::summarize(mw = mean(x, na.rm = T),
+  #                      stddev = stats::sd(x, na.rm = T)) %>%
+  #     dplyr::mutate(yfactor = 1:nrow(.))
+  # }
   # --------------------------------------------------------
   # Prepare and trim legend labels to appropriate size
   # --------------------------------------------------------
@@ -601,33 +573,6 @@ sjp.grpfrq <- function(varCount,
       upper_lim <- max(pretty(table(varCount, varGroup) * 1.05))
     }
   }
-  # --------------------------------------------------------
-  # define bar colors
-  # --------------------------------------------------------
-  # define vertical position for labels
-  if (coord.flip) {
-    # if we flip coordinates, we have to use other arguments
-    # than for the default layout
-    vert <- ifelse(type == ""dots"", 0.45, 0.35)
-    if (labelPos == ""inside"" || labelPos == ""i"") {
-      hort <- 1.1
-    } else {
-      hort <- -0.1
-    }
-  } else {
-    hort <- ggplot2::waiver()
-    if (labelPos == ""inside"" || labelPos == ""i"") {
-      vert <- 1.1
-    } else if (barPosition == ""stack"" || labelPos == ""center"" || labelPos == ""c"") {
-      vert <- ggplot2::waiver()
-    } else if (showPercentageValues && showCountValues) {
-      # value labels need a different vertical adjustement, depending on
-      # whether we plot dots or bars
-      vert <- ifelse(type == ""dots"", -0.5, -0.2)
-    } else {
-      vert <- ifelse(type == ""dots"", -0.9, -0.5)
-    }
-  }
   # align dodged position of labels to bar positions
   posdodge <- ifelse(type == ""lines"", 0, geom.size + geom.spacing)
   # init shaded rectangles for plot
@@ -643,8 +588,8 @@ sjp.grpfrq <- function(varCount,
     # create shaded rectangle, so we know which dots belong to the same category
     if (showPlotAnnotation) {
       ganno <- annotate(""rect"",
-                        xmin = mydf$xpos - 0.4,
-                        xmax = mydf$xpos + 0.4,
+                        xmin = as.numeric(mydf$xpos) - 0.4,
+                        xmax = as.numeric(mydf$xpos) + 0.4,
                         ymin = lower_lim,
                         ymax = upper_lim,
                         fill = ""grey80"",
@@ -673,119 +618,92 @@ sjp.grpfrq <- function(varCount,
   } else if (type == ""violin"") {
     geob <- geom_violin(trim = trimViolin, width = geom.size)
   } else {
-    geob <- geom_histogram(stat = ""identity"",
-                           position = barPosition,
-                           binwidth = geom.size)
+    geob <- geom_bar(stat = ""identity"",
+                     position = barPosition,
+                     width = geom.size)
   }
-  if (!showAxisLabels.x)
-    axisLabels.x <- c("""")
+  if (!showAxisLabels.x) axisLabels.x <- c("""")
   # --------------------------------------------------------
   # Set value labels
   # --------------------------------------------------------
   # don't display value labels when we have boxplots or violin plots
-  if (type == ""boxplots"" || type == ""violin"")
-    showValueLabels <- FALSE
+  if (type == ""boxplots"" || type == ""violin"") showValueLabels <- FALSE
   if (showValueLabels) {
+    # set text positioning
+    if (facet.grid)
+      text.pos <- ""identity""
+    else
+      text.pos <- position_dodge(posdodge)
     # ---------------------------------------------------------
     # if we have facet grids, we have different x and y positions for the value labels
     # so we need to take this into account here
     # ---------------------------------------------------------
-    if (facet.grid) {
-      # ---------------------------------------------------------
-      # if we want percentage values, we have different sprintf-arguments
-      # ---------------------------------------------------------
+    # ---------------------------------------------------------
+    # if we have stacked bars, we need to apply
+    # this stacked y-position to the labels as well
+    # ---------------------------------------------------------
+    if (barPosition == ""stack"") {
       if (showPercentageValues && showCountValues) {
-        ggvaluelabels <-  geom_text(aes(x = xpos, 
-                                        y = frq,
-                                        label = sprintf(""%i\n(%.01f%%)"", frq, prz),
-                                        group = group),
-                                    vjust = vert,
-                                    show.legend = FALSE)
+        ggvaluelabels <-
+          geom_text(aes(y = ypos, 
+                        label = sprintf(""%i\n(%.01f%%)"", frq, prz)),
+                    vjust = vjust,
+                    show.legend = FALSE)
       } else if (showCountValues) {
-        ggvaluelabels <-  geom_text(aes(x = xpos,
-                                        y = frq,
-                                        label = sprintf(""%i"", frq),
-                                        group = group),
-                                    vjust = vert,
-                                    show.legend = FALSE)
+        ggvaluelabels <-
+          geom_text(aes(y = ypos, label = sprintf(""%i"", frq)),
+                    vjust = vjust,
+                    show.legend = FALSE)
       } else if (showPercentageValues) {
-        ggvaluelabels <-  geom_text(aes(x = xpos,
-                                        y = frq,
-                                        label = sprintf(""%.01f%%"", prz),
-                                        group = group),
-                                    vjust = vert,
-                                    show.legend = FALSE)
+        ggvaluelabels <-
+          geom_text(aes(y = ypos, label = sprintf(""%.01f%%"", prz)),
+                    vjust = vjust,
+                    show.legend = FALSE)
       } else {
-        ggvaluelabels <-  geom_text(label = """", show.legend = FALSE)
+        ggvaluelabels <- geom_text(aes(y = frq), label = """", show.legend = FALSE)
       }
     } else {
       # ---------------------------------------------------------
-      # if we have stacked bars, we need to apply
-      # this stacked y-position to the labels as well
+      # if we have dodged bars or dots, we have to use a slightly
+      # dodged position for labels
+      # as well, sofor better reading
       # ---------------------------------------------------------
-      if (barPosition == ""stack"") {
-        if (showPercentageValues && showCountValues) {
-          ggvaluelabels <-
-            geom_text(aes(y = ypos, 
-                          label = sprintf(""%i\n(%.01f%%)"", frq, prz)),
-                      vjust = vert,
-                      show.legend = FALSE)
-        } else if (showCountValues) {
-          ggvaluelabels <-
-            geom_text(aes(y = ypos, label = sprintf(""%i"", frq)),
-                      vjust = vert,
-                      show.legend = FALSE)
-        } else if (showPercentageValues) {
+      if (showPercentageValues && showCountValues) {
+        if (coord.flip) {
           ggvaluelabels <-
-            geom_text(aes(y = ypos, label = sprintf(""%.01f%%"", prz)),
-                      vjust = vert,
+            geom_text(aes(y = frq, label = sprintf(""%i (%.01f%%)"", frq, prz)),
+                      position = text.pos,
+                      vjust = vjust,
+                      hjust = hjust,
                       show.legend = FALSE)
         } else {
-          ggvaluelabels <-  geom_text(label = """", show.legend = FALSE)
-        }
-      } else {
-        # ---------------------------------------------------------
-        # if we have dodged bars or dots, we have to use a slightly
-        # dodged position for labels
-        # as well, sofor better reading
-        # ---------------------------------------------------------
-        if (showPercentageValues && showCountValues) {
-          if (coord.flip) {
-            ggvaluelabels <-
-              geom_text(aes(y = frq, label = sprintf(""%i (%.01f%%)"", frq, prz)),
-                        position = position_dodge(posdodge),
-                        vjust = vert,
-                        hjust = hort,
-                        show.legend = FALSE)
-          } else {
-            ggvaluelabels <-
-              geom_text(aes(y = frq, label = sprintf(""%i\n(%.01f%%)"", frq, prz)),
-                        position = position_dodge(posdodge),
-                        vjust = vert,
-                        hjust = hort,
-                        show.legend = FALSE)
-          }
-        } else if (showCountValues) {
           ggvaluelabels <-
-            geom_text(aes(y = frq, label = sprintf(""%i"", frq)),
-                      position = position_dodge(posdodge),
-                      hjust = hort,
-                      vjust = vert,
+            geom_text(aes(y = frq, label = sprintf(""%i\n(%.01f%%)"", frq, prz)),
+                      position = text.pos,
+                      vjust = vjust,
+                      hjust = hjust,
                       show.legend = FALSE)
-        } else if (showPercentageValues) {
-          ggvaluelabels <-
-            geom_text(aes(y = frq, label = sprintf(""%.01f%%"", prz)),
-                      position = position_dodge(posdodge),
-                      hjust = hort,
-                      vjust = vert,
-                      show.legend = FALSE)
-        } else {
-          ggvaluelabels <- geom_text(label = """", show.legend = FALSE)
         }
+      } else if (showCountValues) {
+        ggvaluelabels <-
+          geom_text(aes(y = frq, label = sprintf(""%i"", frq)),
+                    position = text.pos,
+                    hjust = hjust,
+                    vjust = vjust,
+                    show.legend = FALSE)
+      } else if (showPercentageValues) {
+        ggvaluelabels <-
+          geom_text(aes(y = frq, label = sprintf(""%.01f%%"", prz)),
+                    position = text.pos,
+                    hjust = hjust,
+                    vjust = vjust,
+                    show.legend = FALSE)
+      } else {
+        ggvaluelabels <- geom_text(aes(y = frq), label = """", show.legend = FALSE)
       }
     }
   } else {
-    ggvaluelabels <- geom_text(label = """", show.legend = FALSE)
+    ggvaluelabels <- geom_text(aes(y = frq), label = """", show.legend = FALSE)
   }
   # --------------------------------------------------------
   # Set up grid breaks
@@ -798,102 +716,13 @@ sjp.grpfrq <- function(varCount,
   # ----------------------------------
   # Print plot
   # ----------------------------------
-  # plot object for histogram style
-  # ----------------------------------
-  if (type == ""histogram"" || type == ""lines"") {
-    mydf$xpos <- sjmisc::to_value(mydf$xpos, keep.labels = F)
-    if (type == ""histogram"") {
-      # histrogram need fill aes
-      baseplot <-
-        ggplot(mydf, aes(x = xpos, y = frq, fill = group)) + geob
-    } else {
-      # lines need colour aes
-      baseplot <-
-        ggplot(mydf, aes(x = xpos, y = frq, colour = group)) + geob
-    }
+  if (type == ""lines"") {
+    # line plot need numeric x-scale
+    mydf$xpos <- as.numeric(mydf$xpos)
+    # lines need colour aes
+    baseplot <-
+      ggplot(mydf, aes(x = xpos, y = frq, colour = group)) + geob
     scalex <- scale_x_continuous(limits = axisLimits.x)
-    # -----------------------------------------
-    # show mean line for histograms
-    # -----------------------------------------
-    if (showMeanIntercept) {
-      # -----------------------------------------
-      # vertical lines indicating the mean
-      # -----------------------------------------
-      baseplot <- baseplot +
-        geom_vline(data = vldat,
-                   aes(xintercept = mw, colour = group),
-                   linetype = meanInterceptLineType,
-                   size = meanInterceptLineSize)
-      # -----------------------------------------
-      # check whether meanvalue should be shown.
-      # -----------------------------------------
-      if (showMeanValue) {
-        # -----------------------------------------
-        # use annotation instead of geomtext, because we
-        # need mean value only printed once
-        # -----------------------------------------
-        baseplot <- baseplot +
-          annotate(""text"", 
-                   x = vldat$mw, 
-                   y = upper_lim,
-                   parse = TRUE,
-                   label = sprintf(""italic(bar(x)[%i]) == %.2f"",
-                                   vldat$yfactor,
-                                   vldat$mw),
-                   hjust = 1.05,
-                   vjust = vldat$yfactor * 2)
-      }
-      # -----------------------------------------
-      # check whether the user wants to plot standard deviation area
-      # -----------------------------------------
-      if (showStandardDeviation) {
-        baseplot <- baseplot +
-          # -----------------------------------------
-          # first draw shaded rectangle. these are by default
-          # in grey colour with very high transparancy
-          # -----------------------------------------
-          annotate(""rect"",
-                   xmin = vldat$mw - vldat$stddev,
-                   xmax = vldat$mw + vldat$stddev,
-                   fill = ""grey50"",
-                   ymin = 0,
-                  ymax = upper_lim,alpha = 0.1) +
-          # -----------------------------------------
-          # draw border-lines for shaded rectangles
-          # in the related group colours.
-          # -----------------------------------------
-          geom_vline(data = vldat,
-                     aes(xintercept = mw - stddev, colour = group),
-                     linetype = 3,
-                     size = meanInterceptLineSize,
-                     alpha = 0.7) +
-          geom_vline(data = vldat,
-                     aes(xintercept = mw + stddev, colour = group),
-                     linetype = 3,
-                     size = meanInterceptLineSize,
-                     alpha = 0.7)
-        # -----------------------------------------
-        # if mean values are plotted, plot standard
-        # deviation values as well
-        # -----------------------------------------
-        if (showMeanValue) {
-          baseplot <- baseplot +
-            # -----------------------------------------
-            # use annotation instead of geomtext, because we
-            # need standard deviations only printed once
-            # -----------------------------------------
-            annotate(""text"",
-                     x = vldat$mw + vldat$stddev,
-                     y = upper_lim,
-                     parse = TRUE,
-                     label = sprintf(""italic(s[%i]) == %.2f"",
-                                     vldat$yfactor,
-                                     round(vldat$stddev, 1)),
-                     hjust = 1.1,
-                     vjust = vldat$yfactor * 2)
-        }
-      }
-    }
   } else if (type == ""boxplots"" || type == ""violin"") {
     if (is.null(interactionVar)) {
       baseplot <- ggplot(mydf,aes(x = group,
@@ -930,32 +759,26 @@ sjp.grpfrq <- function(varCount,
                    fill = fcsp)
   } else {
     if (type == ""dots"") {
-      baseplot <- ggplot(mydf, aes(x = factor(xpos),
+      baseplot <- ggplot(mydf, aes(x = xpos,
                                    y = frq,
                                    colour = group))
+      # ---------------------------------------------------------
+      # check whether we have dots plotted, and if so, use annotation
+      # We have to use annotation first, because the diagram's layers are plotted
+      # in the order as they're passed to the ggplot-command. Since we don't want the
+      # shaded rectangles to overlay the dots, we add them first
+      # ---------------------------------------------------------
+      if (!is.null(ganno) && !facet.grid)
+        baseplot <- baseplot + ganno
     } else {
-      baseplot <- ggplot(mydf, aes(x = factor(xpos),
+      baseplot <- ggplot(mydf, aes(x = xpos,
                                    y = frq,
                                    fill = group))
     }
-    # ---------------------------------------------------------
-    # check whether we have dots plotted, and if so, use annotation
-    # We have to use annotation first, because the diagram's layers are plotted
-    # in the order as they're passed to the ggplot-command. Since we don't want the
-    # shaded rectangles to overlay the dots, we add them first
-    # ---------------------------------------------------------
-    if (!is.null(ganno) && !facet.grid)
-      baseplot <- baseplot + ganno
     # add geom
     baseplot <- baseplot + geob
-    if (startAxisAt > 1) {
-      scalex <- scale_x_discrete(labels = axisLabels.x,
-                                 limits = as.factor(seq(from = startAxisAt,
-                                                        to = catcount,
-                                                        by = 1)))
-    } else {
-      scalex <- scale_x_discrete(labels = axisLabels.x)
-    }
+    # define x acis
+    scalex <- scale_x_discrete(labels = axisLabels.x)
   }
   # ------------------------------------------
   # If we have bars or dot plots, we show
@@ -1030,7 +853,7 @@ sjp.grpfrq <- function(varCount,
   # -------------------------------------
   # return results
   # -------------------------------------
-  invisible(structure(class = ""sjpgrpfrq"",
+  invisible(structure(class = c(""sjp"", ""sjpgrpfrq""),
                       list(plot = baseplot,
                            df = mydat)))
 }"
strengejacke,sjPlot,8272cf5f4b68d612ca76e7ebc7918d9ee44e87b6,Daniel Ldecke,d.luedecke@uke.de,2016-01-09T08:58:09Z,Daniel Ldecke,d.luedecke@uke.de,2016-01-09T08:58:09Z,CRAN-Check fixes,DESCRIPTION;R/helpfunctions.R;R/sjPlotFrequencies.R;R/sjPlotGroupFrequencies.R;R/sjPlotInteractions.R,False,True,True,False,24,23,47,"---FILE: DESCRIPTION---
@@ -25,7 +25,6 @@ Imports:
     car,
     dplyr (>= 0.4.3),
     ggplot2 (>= 2.0.0),
-    grid,
     MASS,
     magrittr,
     psych,

---FILE: R/helpfunctions.R---
@@ -1,5 +1,7 @@
-# Help-functions
+# bind global variables
+utils::globalVariables(c(""Freq""))
 
+# Help-functions
 
 # function to create pretty breaks
 # for log-scales
@@ -115,8 +117,8 @@ create.frq.df <- function(x,
     dat <- data.frame(n = names(labels), v = as.character(labels), stringsAsFactors = FALSE)
     colnames(dat) <- c(""val"", ""label"")
     # character vectors need to be converted with to_value
-    # to avoid NAs
-    if (is.character(dat$val))
+    # to avoid NAs, but only if character is non-numeric
+    if (is.character(dat$val) && anyNA(suppressWarnings(as.numeric(dat$val))))
       dat$val <- sjmisc::to_value(dat$val, keep.labels = F)
     else
       dat$val <- as.numeric(dat$val)
@@ -151,7 +153,7 @@ create.frq.df <- function(x,
   mydat$upper.ci <- total_sum * (rel_frq + ci)
   mydat$lower.ci <- total_sum * (rel_frq - ci)
   mydat$rel.upper.ci <- rel_frq + ci
-  mydat$rel.lower.ci <- rel_frq - ci  
+  mydat$rel.lower.ci <- rel_frq - ci
   # --------------------------------------------------------
   # Order categories ascending or descending
   # --------------------------------------------------------
@@ -266,7 +268,7 @@ get.encoding <- function(encoding, data = NULL) {
     if (!is.null(data) && is.data.frame(data)) {
       # get variable label
       labs <- sjmisc::get_label(data[[1]])
-      # check if vectors of data frame have 
+      # check if vectors of data frame have
       # any valid label. else, default to utf-8
       if (!is.null(labs) && is.character(labs))
         encoding <- Encoding(sjmisc::get_label(data[[1]]))
@@ -749,4 +751,4 @@ get_p_stars <- function(pval) {
   else if (pval < 0.05)
     pan <- ""*""
   return(invisible(pan))
-}
\ No newline at end of file
+}

---FILE: R/sjPlotFrequencies.R---
@@ -1,5 +1,5 @@
 # bind global variables
-utils::globalVariables(c(""frq"", ""grp"", ""upper.ci"", ""lower.ci"", ""ia"", ""..density..""))
+utils::globalVariables(c(""val"", ""frq"", ""grp"", ""upper.ci"", ""lower.ci"", ""ia"", ""..density..""))
 
 
 #' @title Plot frequencies of variables

---FILE: R/sjPlotGroupFrequencies.R---
@@ -1,5 +1,5 @@
 # bind global variables
-utils::globalVariables(c(""ypos"", ""wb"", ""ia"", ""mw"", ""stddev"", ""count""))
+utils::globalVariables(c(""."", ""label"", ""prz"", ""frq"", ""ypos"", ""wb"", ""ia"", ""mw"", ""stddev"", ""count""))
 
 
 #' @title Plot grouped or stacked frequencies
@@ -208,8 +208,8 @@ utils::globalVariables(c(""ypos"", ""wb"", ""ia"", ""mw"", ""stddev"", ""count""))
 #' 
 #' @import ggplot2
 #' @import sjmisc
-#' @importFrom dplyr group_by mutate arrange
-#' @importFrom stats na.omit xtabs wilcox.test
+#' @importFrom dplyr group_by mutate arrange summarise
+#' @importFrom stats na.omit xtabs wilcox.test sd
 #' @export
 sjp.grpfrq <- function(varCount,
                        varGroup,
@@ -323,7 +323,7 @@ sjp.grpfrq <- function(varCount,
   #---------------------------------------------------
   # auto-set plot title for box plots?
   #---------------------------------------------------
-  if (missing(title) && (type == ""boxplots"" || type == ""violin"" || histogram))
+  if (missing(title) && (type == ""boxplots"" || type == ""violin"" || type == ""histogram""))
     title <- NULL
   # --------------------------------------------------------
   # create xtab
@@ -499,10 +499,10 @@ sjp.grpfrq <- function(varCount,
   # --------------------------------------------------------
   if (type == ""histogram"") {
     vldat <- mydf %>%
-      group_by(group) %>%
-      summarise(mw = mean(frq, na.rm = T),
-                stddev = sd(frq, na.rm = T)) %>%
-      mutate(yfactor = 1:nrow(.))
+      dplyr::group_by(group) %>%
+      dplyr::summarise(mw = mean(frq, na.rm = T),
+                       stddev = stats::sd(frq, na.rm = T)) %>%
+      dplyr::mutate(yfactor = 1:nrow(.))
   }
   # --------------------------------------------------------
   # Prepare and trim legend labels to appropriate size
@@ -585,8 +585,8 @@ sjp.grpfrq <- function(varCount,
     # the y axis
     if (type == ""boxplots"" || type == ""violin"") {
       # use an extra standard-deviation as limits for the y-axis when we have boxplots
-      lower_lim <- min(varCount, na.rm = TRUE) - floor(sd(varCount, na.rm = TRUE))
-      upper_lim <- max(varCount, na.rm = TRUE) + ceiling(sd(varCount, na.rm = TRUE))
+      lower_lim <- min(varCount, na.rm = TRUE) - floor(stats::sd(varCount, na.rm = TRUE))
+      upper_lim <- max(varCount, na.rm = TRUE) + ceiling(stats::sd(varCount, na.rm = TRUE))
       # make sure that the y-axis is not below zero
       if (lower_lim < 0) {
         lower_lim <- 0
@@ -780,12 +780,12 @@ sjp.grpfrq <- function(varCount,
                       vjust = vert,
                       show.legend = FALSE)
         } else {
-          ggvaluelabels <-  geom_text(label = """", show.legend = FALSE)
+          ggvaluelabels <- geom_text(label = """", show.legend = FALSE)
         }
       }
     }
   } else {
-    ggvaluelabels <-  geom_text(label = """", show.legend = FALSE)
+    ggvaluelabels <- geom_text(label = """", show.legend = FALSE)
   }
   # --------------------------------------------------------
   # Set up grid breaks

---FILE: R/sjPlotInteractions.R---
@@ -665,7 +665,7 @@ sjp.int <- function(fit,
         upperLim.y <- axisLimits.y[2]
       }
     } else {
-      if (fitfam %ini% c(""binomial"", ""quasibinomial"")) {
+      if (fitfam %in% c(""binomial"", ""quasibinomial"")) {
         intdf$x <- sjmisc::to_value(intdf$x, keep.labels = F)
         intdf$y <- plogis(sjmisc::to_value(intdf$y, keep.labels = F))
         intdf$ymin <- plogis(sjmisc::to_value(intdf$ymin, keep.labels = F))
@@ -684,7 +684,7 @@ sjp.int <- function(fit,
     # the scale limits
     # -----------------------------------------------------------
     if (is.null(axisLimits.y)) {
-      if (fitfam %ini% c(""binomial"", ""quasibinomial"")) {
+      if (fitfam %in% c(""binomial"", ""quasibinomial"")) {
         lowerLim.y <- 0
         upperLim.y <- 1
       } else {
@@ -1150,7 +1150,7 @@ sjp.int <- function(fit,
           # for logistic reg.
           if (fitfam %in% c(""binomial"", ""quasibinomial""))
             axisTitle.y <- ""Predicted Probability""
-          else if (fitfam %ini% c(""poisson"", ""quasipoisson""))
+          else if (fitfam %in% c(""poisson"", ""quasipoisson""))
             axisTitle.y <- ""Predicted Incidents""
         }
         # -----------------------------------------------------------"
strengejacke,sjPlot,b3c5d7eef8b0f34afa03ecd97e9bbbe889c43df2,Daniel Ldecke,d.luedecke@uke.de,2016-01-06T18:44:57Z,Daniel Ldecke,d.luedecke@uke.de,2016-01-06T18:44:57Z,Fixing ggplot2 2.0.0-issues,DESCRIPTION;NAMESPACE;NEWS;R/helpfunctions.R;R/sjPlotAncovaLSMeans.R;R/sjPlotAnova.R;R/sjPlotClusterAnalysis.R;R/sjPlotGLME.R;R/sjPlotGroupFrequencies.R;R/sjPlotInteractions.R;R/sjPlotLinreg.R;R/sjPlotLinregMultiple.R;R/sjPlotOdds.R;R/sjPlotOddsMultiple.R;R/sjPlotPropTable.R;R/sjPlotSetTheme.R;README.md;man/sjc.qclus.Rd;man/sjp.aov1.Rd;man/sjp.frq.Rd;man/sjp.glm.Rd;man/sjp.glmer.Rd;man/sjp.glmm.Rd;man/sjp.grpfrq.Rd;man/sjp.lm.Rd;man/sjp.lmer.Rd;man/sjp.lmm.Rd;man/sjp.xtab.Rd,False,True,True,False,1174,1209,2383,"---FILE: DESCRIPTION---
@@ -24,7 +24,7 @@ Depends:
 Imports:
     car,
     dplyr (>= 0.4.3),
-    ggplot2,
+    ggplot2 (>= 2.0.0),
     grid,
     MASS,
     magrittr,

---FILE: NAMESPACE---
@@ -80,7 +80,6 @@ importFrom(graphics,plot)
 importFrom(graphics,points)
 importFrom(graphics,rect)
 importFrom(graphics,text)
-importFrom(grid,unit)
 importFrom(magrittr,""%>%"")
 importFrom(methods,is)
 importFrom(psych,KMO)
@@ -146,5 +145,6 @@ importFrom(stats,weighted.mean)
 importFrom(stats,wilcox.test)
 importFrom(stats,xtabs)
 importFrom(tidyr,gather)
+importFrom(tidyr,spread)
 importFrom(utils,setTxtProgressBar)
 importFrom(utils,txtProgressBar)

---FILE: NEWS---
@@ -1,8 +1,10 @@
 Version 1.8.4-9
 -----------------------------------------------------------------------------
 General:
+* Fixed many issues related to the latest update of ggplot2.
 * Argument `show.se` is now deprecated. Use `show.ci` instead.
 * Redesign of computation of frequency tables for `sjp.frq` and `sjt.frq`, being more robust and generally working with labelled, non-labelled, numeric, character vectors and factors.
+* Redesign of computation of frequency tables for `sjp.grpfrq` and `sjt.xtab`, being more robust and generally working with labelled, non-labelled, numeric, character vectors and factors.
 * Better automatic handling of variable and value labels that are used for labelling plot axes and titles or table columns.
 
 Changes to functions:

---FILE: R/helpfunctions.R---
@@ -114,12 +114,17 @@ create.frq.df <- function(x,
     # add rownames and values as columns
     dat <- data.frame(n = names(labels), v = as.character(labels), stringsAsFactors = FALSE)
     colnames(dat) <- c(""val"", ""label"")
-    dat$val <- as.numeric(dat$val)
+    # character vectors need to be converted with to_value
+    # to avoid NAs
+    if (is.character(dat$val))
+      dat$val <- sjmisc::to_value(dat$val, keep.labels = F)
+    else
+      dat$val <- as.numeric(dat$val)
     # create frequency table
     dat2 <- data.frame(table(x, exclude = NULL))
     colnames(dat2) <- c(""val"", ""frq"")
     dat2$val <- sjmisc::to_value(dat2$val, keep.labels = F)
-    # joun frq table and label columns
+    # join frq table and label columns
     mydat <- suppressMessages(dplyr::full_join(dat, dat2))
     # replace NA with 0, for proper percentages, i.e.
     # missing values don't appear (zero counts)
@@ -192,12 +197,10 @@ create.frq.df <- function(x,
 
 # Create frequency data frame of a variable
 # for sjp and sjt frq functions
-#' @importFrom stats na.omit
-#' @importFrom dplyr add_rownames full_join
+#' @importFrom stats na.omit ftable
+#' @importFrom tidyr spread
 create.xtab.df <- function(x,
                            grp,
-                           breakLabelsAt = Inf,
-                           order.frq = ""none"",
                            round.prz = 2,
                            na.rm = FALSE,
                            weightBy = NULL) {
@@ -206,17 +209,53 @@ create.xtab.df <- function(x,
   # vector to labelled factor first.
   # ------------------------------
   if (is.null(weightBy)) {
-    mydat <-
-      ftable(table(
-        suppressWarnings(sjmisc::to_label(x, add.non.labelled = T)),
-        suppressWarnings(sjmisc::to_label(grp, add.non.labelled = T)),
-        exclude = NULL
-      ))
+    if (na.rm) {
+      mydat <-
+        stats::ftable(table(
+          suppressWarnings(sjmisc::to_label(x, add.non.labelled = T)),
+          suppressWarnings(sjmisc::to_label(grp, add.non.labelled = T))
+        ))
+    } else {
+      mydat <-
+        stats::ftable(table(
+          suppressWarnings(sjmisc::to_label(x, add.non.labelled = T)),
+          suppressWarnings(sjmisc::to_label(grp, add.non.labelled = T)),
+          exclude = NULL
+        ))
+    }
   } else {
     x <- suppressWarnings(sjmisc::to_value(x, keep.labels = T))
     grp <- suppressWarnings(sjmisc::to_value(grp, keep.labels = T))
-    mydat <- ftable(round(xtabs(weightBy ~ x + grp)), 0)
+    if (na.rm)
+      mydat <- stats::ftable(round(stats::xtabs(weightBy ~ x + grp)), 0)
+    else
+      mydat <- stats::ftable(round(stats::xtabs(weightBy ~ x + grp, exclude = NULL, na.action = na.pass)), 0)
   }
+  # create proportional tables
+  proptab.cell <- round(100 * prop.table(mydat), 2)
+  proptab.row <- round(100 * prop.table(mydat, 1), 2)
+  proptab.col <- round(100 * prop.table(mydat, 2), 2)
+  # convert to data frame
+  mydat <- data.frame(mydat)
+  colnames(mydat)[2] <- ""Var2""
+  # spread variables back, so we have a table again
+  mydat <- tidyr::spread(mydat, Var2, Freq)
+  # rename column names
+  colnames(mydat)[1] <- ""label""
+  colnames(mydat)[is.na(colnames(mydat))] <- ""NA""
+  # label must be character
+  mydat$label <- as.character(mydat$label)
+  mydat$label[is.na(mydat$label)] <- ""NA""
+  # save labels to extra vector
+  labels.cnt <- mydat$label
+  labels.grp <- colnames(mydat)[-1]
+  # return result
+  invisible(structure(list(mydat = mydat,
+                           proptab.cell = proptab.cell,
+                           proptab.col = proptab.col,
+                           proptab.row = proptab.row,
+                           labels.cnt = labels.cnt,
+                           labels.grp = labels.grp)))
 }
 
 
@@ -260,8 +299,8 @@ is.brewer.pal <- function(pal) {
 
 
 # Calculate statistics of cross tabs
-#' @importFrom stats chisq.test fisher.test
-crosstabsum <- function(ftab) {
+#' @importFrom stats chisq.test fisher.test xtabs
+crosstabsum <- function(x, grp, weightBy) {
   # --------------------------------------------------------
   # check p-value-style option
   # --------------------------------------------------------
@@ -271,6 +310,11 @@ crosstabsum <- function(ftab) {
   } else {
     p_zero <- ""0""
   }
+  if (is.null(weightBy)) {
+    ftab <- table(x, grp)
+  } else {
+    ftab <- round(stats::xtabs(weightBy ~ x + grp), 0)
+  }
   # calculate chi square value
   chsq <- stats::chisq.test(ftab)
   tab <- sjmisc::table_values(ftab)

---FILE: R/sjPlotAncovaLSMeans.R---
@@ -299,7 +299,7 @@ sjp.emm <- function(fit,
         baseplot <- baseplot +
           geom_text(aes(label = round(y, vld), x = x, y = y),
                     vjust = 1.5,
-                    show_guide = FALSE)
+                    show.legend = FALSE)
       }
       # ------------------------------------------------------------------------------------
       # build plot object with theme and labels
@@ -575,7 +575,7 @@ sjp.emm.lmer <- function(fit, swapPredictors, plevel, title, geom.colors, geom.s
         baseplot <- baseplot +
           geom_text(aes(label = round(y, vld), x = x, y = y),
                     vjust = 1.5,
-                    show_guide = FALSE)
+                    show.legend = FALSE)
       }
       # ------------------------------------------------------------------------------------
       # build plot object with theme and labels

---FILE: R/sjPlotAnova.R---
@@ -364,7 +364,7 @@ sjp.aov1 <- function(depVar,
       # they don't overlap with the errorbars
       geom_text(aes(label = pv, y = means), 
                 vjust = -0.8, 
-                show_guide = FALSE)
+                show.legend = FALSE)
   # --------------------------------------------------------
   # start with bar plots here
   # --------------------------------------------------------
@@ -384,7 +384,7 @@ sjp.aov1 <- function(depVar,
       geom_text(aes(label = pv, y = means), 
                 vjust = ifelse(df$means >= 0, -1, 1), 
                 hjust = hlabj, 
-                show_guide = FALSE)
+                show.legend = FALSE)
     if (hideErrorBars == FALSE) {
       anovaplot <- anovaplot +
         # print confidence intervalls (error bars)

---FILE: R/sjPlotClusterAnalysis.R---
@@ -644,7 +644,7 @@ sjc.grpdisc <- function(data, groups, groupcount, showTotalCorrect = TRUE, print
   classplot <- ggplot(mydat, aes(x = grp, y = prc, fill = fg)) +
     # use stat identity to show value, not count of $prc-variable
     # draw no legend!
-    geom_bar(stat = ""identity"", colour = ""black"", show_guide = FALSE) +
+    geom_bar(stat = ""identity"", colour = ""black"", show.legend = FALSE) +
     # fill bars
     scale_fill_manual(values = c(""#235a80"", ""#80acc8"")) +
     # give chart and X-axis a title

---FILE: R/sjPlotGLME.R---
@@ -764,12 +764,14 @@ sjp.lme4  <- function(fit,
       return(invisible(sjp.lm.eff(fit,
                                   title,
                                   geom.size,
+                                  remove.estimates,
                                   showCI = show.ci,
                                   printPlot)))
     } else {
       return(invisible(sjp.glm.eff(fit,
                                    title,
                                    geom.size,
+                                   remove.estimates,
                                    showCI = show.ci,
                                    printPlot)))
     }
@@ -2256,6 +2258,7 @@ get_lmerMod_pvalues <- function(fitmod) {
 sjp.glm.eff <- function(fit,
                         title,
                         geom.size,
+                        remove.estimates,
                         showCI,
                         printPlot) {
   # ------------------------
@@ -2265,10 +2268,17 @@ sjp.glm.eff <- function(fit,
     stop(""Package 'effects' needed for this function to work. Please install it."", call. = FALSE)
   }
   # ------------------------
+  # Get link family
+  # ------------------------
+  fitfam <- family(fit)$family
+  # ------------------------
   # Retrieve response for automatic title
   # ------------------------
   # retrieve response vector
-  axisTitle.y <- paste(""Predicted probabilities of"", colnames(fit@frame)[1])
+  if (fitfam %in% c(""binomial"", ""quasibinomial""))
+    axisTitle.y <- paste(""Predicted probabilities of"", colnames(fit@frame)[1])
+  else if (fitfam %in% c(""poisson"", ""quasipoisson""))
+    axisTitle.y <- paste(""Predicted incidents of"", colnames(fit@frame)[1])
   # which title?
   if (is.null(title)) title <- ""Marginal effects of model predictors""
   # ------------------------
@@ -2278,6 +2288,15 @@ sjp.glm.eff <- function(fit,
   mm <- stats::model.matrix(fit)
   all.terms <- colnames(stats::model.matrix(fit))[-1]
   # ------------------------
+  # remove setimates?
+  # ------------------------
+  if (!is.null(remove.estimates)) {
+    remcols <- match(remove.estimates, all.terms)
+    # remember old rownames
+    if (!sjmisc::is_empty(remcols))
+      all.terms <- all.terms[-remcols]
+  }
+  # ------------------------
   # prepare getting unique values of predictors,
   # which are passed to the allEffects-function
   # ------------------------
@@ -2307,14 +2326,21 @@ sjp.glm.eff <- function(fit,
     if (length(grep("":"", t, fixed = T)) == 0 && length(grep(""*"", t, fixed = T)) == 0) {
       # ------------------------
       # build data frame, with raw values
-      # from polynomial term, predicted response
-      # and lower/upper ci
+      # predicted response and lower/upper ci
       # ------------------------
-      tmp <- data.frame(x = eff[[i]]$x[[t]],
-                        y = plogis(eff[[i]]$fit),
-                        lower = plogis(eff[[i]]$lower),
-                        upper = plogis(eff[[i]]$upper),
-                        grp = t)
+      if (fitfam %in% c(""binomial"", ""quasibinomial"")) {
+        tmp <- data.frame(x = eff[[i]]$x[[t]],
+                          y = plogis(eff[[i]]$fit),
+                          lower = plogis(eff[[i]]$lower),
+                          upper = plogis(eff[[i]]$upper),
+                          grp = t)
+      } else {
+        tmp <- data.frame(x = eff[[i]]$x[[t]],
+                          y = exp(eff[[i]]$fit),
+                          lower = exp(eff[[i]]$lower),
+                          upper = exp(eff[[i]]$upper),
+                          grp = t)
+      }
       # make sure x is numeric
       tmp$x <- sjmisc::to_value(tmp$x, keep.labels = F)
       # do we already have data?
@@ -2350,8 +2376,10 @@ sjp.glm.eff <- function(fit,
   eff.plot <- eff.plot +
     geom_line(size = geom.size) +
     facet_wrap(~grp, ncol = round(sqrt(grp.cnt)), scales = ""free_x"") +
-    labs(x = NULL, y = axisTitle.y, title = title) +
-    coord_cartesian(ylim = c(0, 1))
+    labs(x = NULL, y = axisTitle.y, title = title)
+  # for logistic regression, use 0 to 1 scale limits
+  if (fitfam %in% c(""binomial"", ""quasibinomial""))
+    eff.plot <- eff.plot + coord_cartesian(ylim = c(0, 1))
   # ------------------------
   # print plot?
   # ------------------------

---FILE: R/sjPlotGroupFrequencies.R---
@@ -61,8 +61,6 @@ utils::globalVariables(c(""ypos"", ""wb"", ""ia"", ""mw"", ""stddev"", ""count""))
 #'          with \code{\link[sjmisc]{read_spss}} or has named factor levels 
 #'          (see 'Examples'). Else, specifiy argument like this:
 #'          \code{axisLabels.x = c(""Label1"", ""Label2"", ""Label3"")}.
-#'          The labels may also be passed as \code{\link{list}} object. They will be coerced
-#'          to character vector automatically.
 #' @param interactionVarLabels a character vector with labels for the x-axis breaks
 #'          when having interaction variables included.
 #'          These labels replace the \code{axisLabels.x}. Only applies, when using box or violin plots
@@ -173,11 +171,8 @@ utils::globalVariables(c(""ypos"", ""wb"", ""ia"", ""mw"", ""stddev"", ""count""))
 #' # histrogram with EUROFAMCARE sample dataset
 #' library(sjmisc)
 #' data(efc)
-#' efc.val <- get_labels(efc)
-#' efc.var <- get_label(efc)
 #' sjp.grpfrq(efc$e17age,
 #'            efc$e16sex,
-#'            title = efc.var['e17age'],
 #'            type = ""hist"",
 #'            showValueLabels = FALSE,
 #'            showMeanIntercept = TRUE)
@@ -199,15 +194,6 @@ utils::globalVariables(c(""ypos"", ""wb"", ""ia"", ""mw"", ""stddev"", ""count""))
 #' sjp.grpfrq(efc$e17age,
 #'            efc$e42dep,
 #'            interactionVar = efc$e16sex,
-#'            title = paste(efc.var['e17age'], 
-#'                          ""by"", 
-#'                          efc.var['e42dep'], 
-#'                          ""and"", 
-#'                          efc.var['e16sex']),
-#'            axisLabels.x = efc.val[['e17age']],
-#'            interactionVarLabels = efc.val[['e16sex']],
-#'            legendTitle = efc.var['e42dep'],
-#'            legendLabels = efc.val[['e42dep']],
 #'            type = ""box"")
 #' 
 #' # Grouped bar plot ranging from 1 to 28 (though scale starts with 7)
@@ -284,18 +270,26 @@ sjp.grpfrq <- function(varCount,
   # We have several options to name the diagram type
   # Here we will reduce it to a unique value
   # --------------------------------------------------------
-  if (type == ""b"" || type == ""bar"") type <- ""bars""
-  if (type == ""l"" || type == ""line"") type <- ""lines""
-  if (type == ""d"" || type == ""dot"") type <- ""dots""
+  if (type == ""b"" || type == ""bar"")
+    type <- ""bars""
+  if (type == ""l"" || type == ""line"")
+    type <- ""lines""
+  if (type == ""d"" || type == ""dot"")
+    type <- ""dots""
   if (type == ""h"" || type == ""hist"") {
-    type <- c(""histogram"")
+    type <- ""histogram""
     # no table summary and no group count for
     # ctageory labels (to avoid overlapping)
     showTableSummary <- FALSE
     showGroupCount <- FALSE
   }
-  if (type == ""box"" || type == ""boxplot"") type <- ""boxplots""
-  if (type == ""v"" || type == ""violins"") type <- ""violin""
+  if (type == ""box"" || type == ""boxplot"")
+    type <- ""boxplots""
+  if (type == ""v"" || type == ""violins"")
+    type <- ""violin""
+  # --------------------------------------------------------
+  # Plot margins
+  # --------------------------------------------------------
   if (expand.grid == TRUE || (missing(expand.grid) && type == ""histogram"")) {
     expand.grid <- ggplot2::waiver()
   } else {
@@ -305,51 +299,75 @@ sjp.grpfrq <- function(varCount,
   # check default geom.size
   # --------------------------------------------------------
   if (is.null(geom.size)) {
-    if (type == ""bars"") 
+    if (type == ""bars"")
       geom.size <- .7
-    else if (type == ""dots"") 
+    else if (type == ""dots"")
       geom.size <- 3
-    else if (type == ""histogram"") 
+    else if (type == ""histogram"")
       geom.size <- .6
-    else if (type == ""lines"") 
+    else if (type == ""lines"")
       geom.size <- .8
-    else if (type == ""boxplots"") 
+    else if (type == ""boxplots"")
       geom.size <- .5
-    else if (type == ""violin"") 
+    else if (type == ""violin"")
       geom.size <- .6
+    else
+      geom.size <- .7
   }
   #---------------------------------------------------
-  # check whether variable should be auto-grouped
+  # Interaction variable defined for invalid plot type?
   #---------------------------------------------------
   if (!is.null(interactionVar) && type != ""boxplots"" && type != ""violin"") {
     warning(""'interactionVar' only applies to boxplots and violinplots (see 'type') and will be ignored."", call. = F)
   }
+  #---------------------------------------------------
+  # auto-set plot title for box plots?
+  #---------------------------------------------------
+  if (missing(title) && (type == ""boxplots"" || type == ""violin"" || histogram))
+    title <- NULL
+  # --------------------------------------------------------
+  # create xtab
+  # --------------------------------------------------------
+  mydat <- create.xtab.df(varCount,
+                          varGroup,
+                          round.prz = 2,
+                          na.rm = na.rm,
+                          weightBy = weightBy)
   # --------------------------------------------------------
   # try to automatically set labels is not passed as argument
   # --------------------------------------------------------
-  if (is.null(axisLabels.x)) {
-    axisLabels.x <- sjmisc::get_labels(varCount, attr.only = F, include.values = F, include.non.labelled = T)
-    # if we have box or violin plots, but no axis labels on x axis (NULL),
-    # we need to hide x-axis, because automatically retrieved labels are
-    # equal to unique values of varCount, and not varGroup.
-    if (type == ""boxplots"" || type == ""violin"") showAxisLabels.x <- FALSE
+  if (missing(axisLabels.x) && (type == ""boxplots"" || type == ""violin"")) {
+    axisLabels.x <- mydat$labels.grp
+    if (missing(hideLegend)) hideLegend <- TRUE
   }
-  if (is.null(legendLabels)) legendLabels <- sjmisc::get_labels(varGroup, attr.only = F, include.values = F, include.non.labelled = T)
-  if (is.null(interactionVarLabels) && !is.null(interactionVar)) interactionVarLabels <- sjmisc::get_labels(interactionVar, attr.only = F, include.values = F, include.non.labelled = T)
-  if (is.null(axisTitle.x)) axisTitle.x <- sjmisc::get_label(varCount, def.value = var.name.cnt)
-  if (is.null(legendTitle)) legendTitle <- sjmisc::get_label(varGroup, def.value = var.name.grp)
+  if (is.null(axisLabels.x)) axisLabels.x <- mydat$labels.cnt
+  if (is.null(legendLabels)) legendLabels <- mydat$labels.grp
+  if (is.null(interactionVarLabels) && !is.null(interactionVar))
+    interactionVarLabels <- sjmisc::get_labels(interactionVar,
+                                               attr.only = F,
+                                               include.values = F,
+                                               include.non.labelled = T)
+  if (is.null(axisTitle.x))
+    axisTitle.x <- sjmisc::get_label(varCount, def.value = var.name.cnt)
+  if (is.null(legendTitle))
+    legendTitle <- sjmisc::get_label(varGroup, def.value = var.name.grp)
   if (is.null(title)) {
     t1 <- sjmisc::get_label(varCount, def.value = var.name.cnt)
     t2 <- sjmisc::get_label(varGroup, def.value = var.name.grp)
-    if (!is.null(t1) && !is.null(t2)) title <- paste0(t1, "" by "", t2)
+    if (!is.null(t1) && !is.null(t2))
+      title <- paste0(t1, "" by "", t2)
   }
   # --------------------------------------------------------
   # remove titles if empty
   # --------------------------------------------------------
-  if (!is.null(legendTitle) && legendTitle == """") legendTitle <- NULL
-  if (!is.null(axisTitle.x) && axisTitle.x == """") axisTitle.x <- NULL
-  if (!is.null(axisTitle.y) && axisTitle.y == """") axisTitle.y <- NULL  
-  if (!is.null(title) && title == """") title <- NULL    
+  if (!is.null(legendTitle) && legendTitle == """")
+    legendTitle <- NULL
+  if (!is.null(axisTitle.x) && axisTitle.x == """")
+    axisTitle.x <- NULL
+  if (!is.null(axisTitle.y) && axisTitle.y == """")
+    axisTitle.y <- NULL
+  if (!is.null(title) && title == """")
+    title <- NULL
   # --------------------------------------------------------
   # count variable may not be a factor!
   # --------------------------------------------------------
@@ -359,75 +377,30 @@ sjp.grpfrq <- function(varCount,
   # check whether variable should be auto-grouped
   #---------------------------------------------------
   if (!is.null(autoGroupAt) && length(unique(varCount)) >= autoGroupAt) {
-    message(sprintf(""Variable has %i unique values and was grouped..."", 
+    message(sprintf(""Variable has %i unique values and was grouped..."",
                     length(unique(varCount))))
     # check for default auto-group-size or user-defined groups
     agcnt <- ifelse(autoGroupAt < 30, autoGroupAt, 30)
     # group axis labels
-    axisLabels.x <- sjmisc::group_labels(varCount, 
-                                         groupsize = ""auto"", 
+    axisLabels.x <- sjmisc::group_labels(varCount,
+                                         groupsize = ""auto"",
                                          groupcount = agcnt)
     # group variable
-    varCount <- sjmisc::group_var(varCount, 
-                                  groupsize = ""auto"", 
-                                  as.num = TRUE, 
+    varCount <- sjmisc::group_var(varCount,
+                                  groupsize = ""auto"",
+                                  as.num = TRUE,
                                   groupcount = agcnt)
   }
   # --------------------------------------------------------
-  # unlist labels
-  # --------------------------------------------------------
-  if (!is.null(legendLabels) && is.list(legendLabels)) legendLabels <- unlistlabels(legendLabels)
-  if (!is.null(axisLabels.x) && is.list(axisLabels.x)) axisLabels.x <- unlistlabels(axisLabels.x)
-  if (!is.null(interactionVarLabels) && is.list(interactionVarLabels)) interactionVarLabels <- unlistlabels(interactionVarLabels)
-  # --------------------------------------------------------
-  # Define amount of categories, include zero counts
-  # --------------------------------------------------------
-  # Zero counts of categories are not plotted by default because
-  # these categories don't appear in the data. If we assume a
-  # ""quasi-continuous"" scale (categories from 1 to 4 etc.), we now
-  # identify the zero counts and add / insert them into the data frame.
-  # This enables us to plot zero counts as well.
-  # We guess the maximum amount of categories either by the amount
-  # of supplied category labels. If no category labels were passed
-  # as argument, we assume that the maximum value found in the category
-  # columns represents the highest category number
-  # -----------------------------------------------
-  # handle zero-counts
-  # -----------------------------------------------
-  # Determine length of count and group var
-  grplen <- length(unique(stats::na.omit(varGroup)))
-  # determine maximum values
-  # first, check the total amount of different factor levels
-  catcount_1 <- length(unique(stats::na.omit(varCount)))
-  # second, check the maximum factor level
-  catcount_2 <- max(varCount, na.rm = TRUE)
-  # if categories start with zero, fix this here
-  if (min(varCount, na.rm = TRUE) == 0) {
-    catcount_2 <- catcount_2 + 1
-  }
-  # catcount should contain the higher values, i.e. the maximum count of
-  # categories (factor levels) corresponds either to the highest factor level
-  # value or to the amount of different factor levels, depending on which one
-  # is larger
-  catcount <- ifelse(catcount_1 > catcount_2, catcount_1, catcount_2)
+  # Define amount of categories
+  catcount <- length(axisLabels.x)
   catmin <- min(varCount, na.rm = TRUE)
+  grpcount <- length(legendLabels)
   # ----------------------------------------------
   # check for axis start, depending on lowest value
   # ----------------------------------------------
-  if (startAxisAt == ""auto"") {
+  if (startAxisAt == ""auto"")
     startAxisAt <- as.numeric(catmin)
-    if (startAxisAt == 0) startAxisAt <- 1
-  }
-  # get the highest answer category of ""variable"", so we know where the
-  # range of the x-axis ends
-  if (!is.null(axisLabels.x)) catcount <- length(axisLabels.x)
-  # if we have legend labels, we know the exact
-  # amount of groups
-  if (is.null(legendLabels)) {
-    grpcount <- grplen
-  } else {
-    grpcount <- length(legendLabels)
-  }
   # -----------------------------------------------
   # define x-axis limits
   # -----------------------------------------------
@@ -441,160 +414,43 @@ sjp.grpfrq <- function(varCount,
   # create cross table for stats, summary etc.
   # and weight variable
   #---------------------------------------------------
-  if (is.null(weightBy)) {
-    ftab <- table(varCount, varGroup)
-  } else {
-    ftab <- round(stats::xtabs(weightBy ~ varCount + varGroup), 0)
-  }
-  # new data frame from variables
-  df <- as.data.frame(ftab)
-  # separate data frame for grouping variable. we need this to
-  # determine the number of groups
-  dfgrp <- as.data.frame(table(df$varGroup))
-  # Factors have to be transformed into numeric values
-  # for continiuos x-axis-scale
-  df$varCount <- sjmisc::to_value(df$varCount, keep.labels = F)
-  # if categories start with zero, fix this here
-  if (min(df$varCount) == 0) df$varCount <- df$varCount + 1
-  # convcert group variables to chars
-  df$varGroup <- as.character(df$varGroup)
-  dfgrp$Var1 <- as.character(dfgrp$Var1)
-  # determine the number of groups
-  grpcnt <- nrow(dfgrp)
-  # init data frame. this data frame will contain the final variables
-  # needed for plotting with ggplot
-  mydat <- NULL
-  # fill in possible zero counts in each group
-  for (i in 1:grpcnt) {
-    # get subset of data frame with each group
-    subdf <- df[df$varGroup == dfgrp$Var1[i], ]
-    # Create a vector of zeros 
-    frq <- rep(0, catcount)
-    # Replace the values in freq for those indices which equal dummyf$xa
-    # by dummyf$ya so that remaining indices are ones which you 
-    # intended to insert 
-    frq[subdf$varCount] <- subdf$Freq
-    # retrieve group variable as character. grouping might be indicated by
-    # ""A"" or ""B"", not just 1 or 2.
-    group <- as.character(dfgrp$Var1[i])
-    # create new data frame. We now have a data frame with all
-    # variable categories abd their related counts, including
-    # zero counts, but no(!) missings!
-    dummydat <- data.frame(cbind(count = 1:catcount, 
-                                 group, 
-                                 frq, 
-                                 layer = 1:catcount))
-    # --------------------------------------------------------
-    # Handle missings
-    # --------------------------------------------------------
-    if (!na.rm) {
-      # get amount of missings
-      frq <- sum(is.na(varCount[which(varGroup == as.numeric(dfgrp$Var1[i]))]))
-      # create data frame
-      tmpdf <- data.frame(cbind(count = catcount + 1, 
-                                group, 
-                                frq, 
-                                layer = catcount + 1))
-      # append dummy data frame to final data frame
-      dummydat <- data.frame(rbind(dummydat, tmpdf))
-    }
-    # append dummy data frame to final data frame
-    mydat <- data.frame(rbind(mydat, dummydat))
-  }
-  # convert grouping variable to character
-  mydat$count <- sjmisc::to_value(mydat$count, keep.labels = F)
-  # convert grouping variable to character
-  mydat$group <- sjmisc::to_value(mydat$group, keep.labels = F)
-  # convert frequencies to numeric
-  mydat$frq <- sjmisc::to_value(mydat$frq, keep.labels = F)
-  # convert layer to numeric
-  mydat$layer <- sjmisc::to_value(mydat$layer, keep.labels = F)
-  # -----------------------------------------------
-  # Handle zero-counts in group-variable
-  # only possible if we know the exact number of groups,
-  # by passing legend labels
-  # -----------------------------------------------
-  if (grplen != grpcount) {
-    # if the maximum value of the group variable differs from the estimated
-    # group length we probably have missing categoriesm, i.e. one group has no
-    # cases. Then, we insert an empty row here
-    # range of groups from lowest to highest group value
-    allgroups <- factor(c(min(mydat$group):max(mydat$group)))
-    # retrieve zero-counts, i.e. which group is missing in the data frame
-    miss <- sjmisc::to_value(allgroups[!allgroups %in% mydat$group], keep.labels = F)
-    # retrieve subset of all rows where group is from lowest group-value to 
-    # missing group
-    dummy1 <- mydat[apply(mydat, MARGIN = 1, function(xy) all(xy[2] < miss)), ]
-    # retrieve subset of all rows where group is from missing group to
-    # highest group-value
-    dummy2 <- mydat[apply(mydat, MARGIN = 1, function(xy) all(xy[2] > miss)), ]
-    # create dummy-data frame that contains the missing row with zero-values
-    emptyrows <- data.frame(cbind(count = c(1:catcount), 
-                                  group = miss, 
-                                  frq = 0, 
-                                  layer = 1:catcount))
-    emptyrows$count <- as.factor(as.character(emptyrows$count))
-    emptyrows$group <- as.factor(as.character(emptyrows$group))
-    # bind all three subsets together to a complete data frame
-    mydat <- rbind(dummy1, emptyrows, dummy2)
-  }
-  # set group-variable as factor
-  mydat$group <- as.factor(mydat$group)
-  # --------------------------------------------------------
-  # calculate percentages
-  # --------------------------------------------------------
-  # init empty vector, with length of data frame's rows
-  prz <- rep(0, nrow(mydat))
-  # iterate all data frame rows
-  for (k in 1:length(prz)) {
-    # if we have facet grids, calculate percentage
-    # within each group
-    if (facet.grid) {
-      # get frequency value of each row and divide it by the sum of frequencies of
-      # all frequencies of the current row's group
-      prz[k] <- c(round(100 * mydat[k, 3] / sum(mydat$frq[mydat$group == mydat[k, 2]]), 2))
-    # if we have dodged/stacked bars or plots, calculate percentage
-    # within each category
-    } else {
-      # get frequency value of each row and divide it by the sum of frequencies of
-      # all frequencies of the current row's category
-      prz[k] <- c(round(100 * mydat[k, 3] / sum(mydat$frq[mydat$count == mydat[k, 1]]), 2))
-    } 
-  }
-  # bind percentage as final column
-  mydat <- as.data.frame(cbind(mydat, prz))
-  # convert prz to numeric
-  mydat$texty <- sjmisc::to_value(mydat$prz, keep.labels = F)
+  mydf <- tidyr::gather(mydat$mydat, ""group"", ""frq"", 2:(grpcount + 1))
+  mydf$xpos <- sjmisc::to_value(as.factor(mydf$label),
+                                start.at = catmin,
+                                keep.labels = F)
   # add half of Percentage values as new y-position for stacked bars
   # mydat <- ddply(mydat, ""count"", transform, ypos = cumsum(frq) - 0.5*frq)
-  mydat <- mydat %>%
-    dplyr::group_by(count) %>%
+  mydf <- mydf %>%
+    dplyr::group_by(label) %>%
     dplyr::mutate(ypos = cumsum(frq) - 0.5 * frq) %>%
-    dplyr::arrange(count)
+    dplyr::arrange(label)
+  # add percentages
+  mydf$prz <- round(100 * mydf$frq / sum(mydf$frq), 2)
   # --------------------------------------------------------
   # If we have boxplots, use different data frame structure
   # --------------------------------------------------------
   if (type == ""boxplots"" || type == ""violin"") {
     w <- ifelse(is.null(weightBy), 1, weightBy)
     if (is.null(interactionVar)) {
-      mydat <- stats::na.omit(data.frame(cbind(group = varGroup, 
-                                               frq = varCount, 
-                                               wb = w)))
+      mydf <- stats::na.omit(data.frame(cbind(group = varGroup,
+                                              frq = varCount,
+                                              wb = w)))
     } else {
-      mydat <- stats::na.omit(data.frame(cbind(group = varGroup, 
-                                               frq = varCount, 
-                                               ia = interactionVar, 
-                                               wb = w)))
-      mydat$ia <- as.factor(mydat$ia)
+      mydf <- stats::na.omit(data.frame(cbind(group = varGroup,
+                                              frq = varCount,
+                                              ia = interactionVar,
+                                              wb = w)))
+      mydf$ia <- as.factor(mydf$ia)
     }
-    mydat$group <- as.factor(mydat$group)
+    mydf$group <- as.factor(mydf$group)
   }
   # ----------------------------
   # create expression with model summarys. used
   # for plotting in the diagram later
   # ----------------------------
   mannwhitneyu <- function(count, grp) {
-    if (min(grp, na.rm = TRUE) == 0) grp <- grp + 1
+    if (min(grp, na.rm = TRUE) == 0)
+      grp <- grp + 1
     completeString <- c("""")
     cnt <- length(unique(stats::na.omit(grp)))
     for (i in 1:cnt) {
@@ -608,110 +464,76 @@ sjp.grpfrq <- function(varCount,
           wt <- stats::wilcox.test(xsub ~ ysub)
           
           if (wt$p.value < 0.001) {
-            modsum <- as.character(as.expression(
-              substitute(p[pgrp] < pval, list(pgrp = sprintf(""(%i|%i)"", i, j),
-                                              pval = 0.001))))
+            modsum <- as.character(as.expression(substitute(
+              p[pgrp] < pval, list(pgrp = sprintf(""(%i|%i)"", i, j),
+                                   pval = 0.001)
+            )))
           } else {
-            modsum <- as.character(as.expression(
-              substitute(p[pgrp] == pval, list(pgrp = sprintf(""(%i|%i)"", i, j),
-                                               pval = sprintf(""%.3f"", wt$p.value)))))
+            modsum <- as.character(as.expression(substitute(
+              p[pgrp] == pval, 
+              list(pgrp = sprintf(""(%i|%i)"", i, j),
+                   pval = sprintf(""%.3f"", wt$p.value)))))
           }
-          completeString <- sprintf(""%s * \"",\"" ~ ~ %s"", 
-                                    completeString, 
+          completeString <- sprintf(""%s * \"",\"" ~ ~ %s"",
+                                    completeString,
                                     modsum)
         }
       }
     }
-    return(paste(""\""Mann-Whitney-U:\"" ~ ~ "", substring(completeString, 12), sep = """"))
-    # return (paste(""Mann-Whitney-U"", completeString, sep=""""))
-    # return (substring(completeString, 12))
+    return(paste(""\""Mann-Whitney-U:\"" ~ ~ "",
+                 substring(completeString, 12),
+                 sep = """"))
   }
   # -----------------------------------------------------------
   # Check whether table summary should be printed
   # -----------------------------------------------------------
   modsum <- NULL
   if (showTableSummary) {
-    if (type == ""boxplots"" || type == ""violin"") {
+    if (type == ""boxplots"" || type == ""violin"")
       modsum <- mannwhitneyu(varCount, varGroup)
-    } else {
-      modsum <- crosstabsum(ftab)
-    }
-  }  
+    else
+      modsum <- crosstabsum(varCount, varGroup, weightBy)
+  }
   # --------------------------------------------------------
   # If we have a histogram, caluclate means of groups
   # --------------------------------------------------------
   if (type == ""histogram"") {
-    # retrieve all unique factor levels
-    faclvl <- unique(stats::na.omit(varGroup))
-    # order factors
-    faclvl <- faclvl[order(faclvl)]
-    # create new data frame for the geom object that prints the
-    # vertical line
-    vldat <- NULL
-    # convert table to df
-    ftabdf <- as.data.frame(apply(ftab, MARGIN = 2, function(x) cbind(x)))
-    colvalues <- as.numeric(attr(ftab, ""dimnames"")[[1]])
-    ftabdf$fac <- colvalues
-    # iterate all unique categories, so we can calculate
-    # mean of ""varCount"" in each group
-    for (f in 1:length(faclvl)) {
-      # get mean from each group
-      m <- sum(ftabdf[, f] * ftabdf$fac) / sum(ftabdf[, f])
-      # get standard deviation from each group
-      stdv <- sd(stats::na.omit(varCount[which(varGroup == faclvl[f])]))
-      # add new row with group and associated mean
-      vldat <- data.frame(rbind(vldat, c(faclvl[f], m, stdv, yfactor = f)))
-    }
-    # add row names
-    names(vldat) <- c(""group"", ""mw"", ""stddev"", ""yfactor"")
-    # convert group to factor
-    vldat$group <- as.factor(vldat$group)
+    vldat <- mydf %>%
+      group_by(group) %>%
+      summarise(mw = mean(frq, na.rm = T),
+                stddev = sd(frq, na.rm = T)) %>%
+      mutate(yfactor = 1:nrow(.))
   }
   # --------------------------------------------------------
   # Prepare and trim legend labels to appropriate size
   # --------------------------------------------------------
-  # Check whether we have any labels passed as argument
-  # if not, use category text of group variable as legend text
-  if (is.null(legendLabels)) legendLabels <- c(dfgrp$Var1)
-  # wrap legend text lines
-  legendLabels <- sjmisc::word_wrap(legendLabels, breakLegendLabelsAt)
-  # check whether we have a title for the legend
-  if (!is.null(legendTitle)) legendTitle <- sjmisc::word_wrap(legendTitle, breakLegendTitleAt)
-  # check length of diagram title and split longer string at into new lines
-  # every 50 chars
+  if (!is.null(legendLabels))
+    legendLabels <- sjmisc::word_wrap(legendLabels, breakLegendLabelsAt)
+  if (!is.null(legendTitle))
+    legendTitle <- sjmisc::word_wrap(legendTitle, breakLegendTitleAt)
   if (!is.null(title)) {
     # if we have weighted values, say that in diagram's title
-    if (!is.null(weightByTitleString)) title <- paste(title, weightByTitleString, sep = """")
+    if (!is.null(weightByTitleString))
+      title <- paste(title, weightByTitleString, sep = """")
     title <- sjmisc::word_wrap(title, breakTitleAt)
   }
-  # check length of x-axis title and split longer string at into new lines
-  # every 50 chars
-  if (!is.null(axisTitle.x)) axisTitle.x <- sjmisc::word_wrap(axisTitle.x, breakTitleAt)
-  # check length of x-axis title and split longer string at into new lines
-  # every 50 chars
-  if (!is.null(axisTitle.y)) axisTitle.y <- sjmisc::word_wrap(axisTitle.y, breakTitleAt)
-  # check length of x-axis-labels and split longer strings at into new lines
-  # every 10 chars, so labels don't overlap
-  if (!is.null(axisLabels.x)) axisLabels.x <- sjmisc::word_wrap(axisLabels.x, breakLabelsAt)
-  # If axisLabels.x were not defined, simply set numbers from 1 to
-  # amount of categories (=number of rows) in dataframe instead
-  else axisLabels.x <- c(startAxisAt:catcount)
-  # check length of x-axis-labels of interaction variable and split 
-  # longer strings into new lines
+  if (!is.null(axisTitle.x))
+    axisTitle.x <- sjmisc::word_wrap(axisTitle.x, breakTitleAt)
+  if (!is.null(axisTitle.y))
+    axisTitle.y <- sjmisc::word_wrap(axisTitle.y, breakTitleAt)
+  if (!is.null(axisLabels.x))
+    axisLabels.x <- sjmisc::word_wrap(axisLabels.x, breakLabelsAt)
   if (!is.null(interactionVar)) {
     if (!is.null(interactionVarLabels)) {
       interactionVarLabels <- sjmisc::word_wrap(interactionVarLabels, breakLabelsAt)
     }
     # If interaction-variable-labels were not defined, simply set numbers from 1 to
     # amount of categories instead
-    else  {
+    else {
       iavarLabLength <- length(unique(stats::na.omit(interactionVar)))
       interactionVarLabels <- c(1:iavarLabLength)
     }
   }
-  # If missings are not removed, add an
-  # ""NA"" to labels and a new row to data frame which contains the missings
-  if (!na.rm) axisLabels.x = c(axisLabels.x, ""NA"")
   # --------------------------------------------------------
   # add group counts to category labels
   # --------------------------------------------------------
@@ -724,7 +546,10 @@ sjp.grpfrq <- function(varCount,
       if (is.null(weightBy)) {
         gc <- table(varGroup, interactionVar, useNA = nas)
       } else {
-        gc <- table(sjmisc::weight2(varGroup, weightBy), interactionVar, useNA = nas)
+        gc <-
+          table(sjmisc::weight2(varGroup, weightBy),
+                interactionVar,
+                useNA = nas)
       }
       # determinte loop-steps
       lst <- length(interactionVarLabels)
@@ -737,10 +562,10 @@ sjp.grpfrq <- function(varCount,
         interactionVarLabels[i + lst] <- paste(ial, "" (n="", gc[2, i], "")"", sep = """")
       }
     } else {
-      sums <- unname(rowSums(ftab))
+      sums <- unname(rowSums(mydat$mydat[, -1]))
       # add group count to each cat. label
       axisLabels.x <- paste(axisLabels.x, "" (n="", sums, "")"", sep = """")
-      sums <- unname(colSums(ftab))
+      sums <- unname(colSums(mydat$mydat[, -1]))
       # add group count to each cat. label
       legendLabels <- paste(legendLabels, "" (n="", sums, "")"", sep = """")
     }
@@ -767,8 +592,8 @@ sjp.grpfrq <- function(varCount,
         lower_lim <- 0
         trimViolin <- TRUE
       }
-    # else calculate upper y-axis-range depending
-    # on the amount of cases...
+      # else calculate upper y-axis-range depending
+      # on the amount of cases...
     } else if (barPosition == ""stack"") {
       upper_lim <- max(pretty(table(varCount) * 1.05))
     } else {
@@ -812,31 +637,33 @@ sjp.grpfrq <- function(varCount,
     # position_dodge displays dots in a dodged position so we avoid overlay here. This may lead
     # to a more difficult distinction of group belongings, since the dots are ""horizontally spread""
     # over the digram. For a better overview, we can add a ""PlotAnnotation"" (see ""showPlotAnnotation) here.
-    geob <- geom_point(position = position_dodge(0.8), size = geom.size, shape = 16)
+    geob <- geom_point(position = position_dodge(0.8),
+                       size = geom.size,
+                       shape = 16)
     # create shaded rectangle, so we know which dots belong to the same category
     if (showPlotAnnotation) {
-      ganno <- annotate(""rect"", 
-                        xmin = mydat$layer - 0.4, 
-                        xmax = mydat$layer + 0.4, 
-                        ymin = lower_lim, 
-                        ymax = upper_lim, 
-                        fill = ""grey80"", 
+      ganno <- annotate(""rect"",
+                        xmin = mydf$xpos - 0.4,
+                        xmax = mydf$xpos + 0.4,
+                        ymin = lower_lim,
+                        ymax = upper_lim,
+                        fill = ""grey80"",
                         alpha = 0.1)
     }
   } else if (type == ""bars"") {
     if (barPosition == ""dodge"") {
-      geob <- geom_bar(stat = ""identity"", 
-                       width = geom.size, 
+      geob <- geom_bar(stat = ""identity"",
+                       width = geom.size,
                        position = position_dodge(geom.size + geom.spacing))
     } else {
-      geob <- geom_bar(stat = ""identity"", 
-                       width = geom.size, 
+      geob <- geom_bar(stat = ""identity"",
+                       width = geom.size,
                        position = ""stack"")
     }
   } else if (type == ""lines"") {
     if (smoothLines) {
-      geob <- geom_line(size = geom.size, 
-                        stat = ""smooth"", 
+      geob <- geom_line(size = geom.size,
+                        stat = ""smooth"",
                         method = ""loess"")
     } else {
       geob <- geom_line(size = geom.size)
@@ -846,16 +673,18 @@ sjp.grpfrq <- function(varCount,
   } else if (type == ""violin"") {
     geob <- geom_violin(trim = trimViolin, width = geom.size)
   } else {
-    geob <- geom_histogram(stat = ""identity"", 
-                           position = barPosition, 
+    geob <- geom_histogram(stat = ""identity"",
+                           position = barPosition,
                            binwidth = geom.size)
   }
-  if (!showAxisLabels.x) axisLabels.x <- c("""")
+  if (!showAxisLabels.x)
+    axisLabels.x <- c("""")
   # --------------------------------------------------------
   # Set value labels
   # --------------------------------------------------------
   # don't display value labels when we have boxplots or violin plots
-  if (type == ""boxplots"" || type == ""violin"") showValueLabels <- FALSE
+  if (type == ""boxplots"" || type == ""violin"")
+    showValueLabels <- FALSE
   if (showValueLabels) {
     # ---------------------------------------------------------
     # if we have facet grids, we have different x and y positions for the value labels
@@ -866,89 +695,97 @@ sjp.grpfrq <- function(varCount,
       # if we want percentage values, we have different sprintf-arguments
       # ---------------------------------------------------------
       if (showPercentageValues && showCountValues) {
-        ggvaluelabels <-  geom_text(aes(x = count, 
-                                        y = frq, 
-                                        label = sprintf(""%i\n(%.01f%%)"", frq, prz), 
+        ggvaluelabels <-  geom_text(aes(x = xpos, 
+                                        y = frq,
+                                        label = sprintf(""%i\n(%.01f%%)"", frq, prz),
                                         group = group),
                                     vjust = vert,
-                                    show_guide = FALSE)
+                                    show.legend = FALSE)
       } else if (showCountValues) {
-        ggvaluelabels <-  geom_text(aes(x = count, 
-                                        y = frq, 
-                                        label = sprintf(""%i"", frq), 
+        ggvaluelabels <-  geom_text(aes(x = xpos,
+                                        y = frq,
+                                        label = sprintf(""%i"", frq),
                                         group = group),
                                     vjust = vert,
-                                    show_guide = FALSE)
+                                    show.legend = FALSE)
       } else if (showPercentageValues) {
-        ggvaluelabels <-  geom_text(aes(x = count, 
-                                        y = frq, 
-                                        label = sprintf(""%.01f%%"", prz), 
+        ggvaluelabels <-  geom_text(aes(x = xpos,
+                                        y = frq,
+                                        label = sprintf(""%.01f%%"", prz),
                                         group = group),
                                     vjust = vert,
-                                    show_guide = FALSE)
+                                    show.legend = FALSE)
       } else {
-        ggvaluelabels <-  geom_text(label = """", show_guide = FALSE)
+        ggvaluelabels <-  geom_text(label = """", show.legend = FALSE)
       }
     } else {
       # ---------------------------------------------------------
-      # if we have stacked bars, we need to apply 
+      # if we have stacked bars, we need to apply
       # this stacked y-position to the labels as well
       # ---------------------------------------------------------
       if (barPosition == ""stack"") {
         if (showPercentageValues && showCountValues) {
-          ggvaluelabels <-  geom_text(aes(y = ypos, label = sprintf(""%i\n(%.01f%%)"", frq, prz)),
-                                      vjust = vert,
-                                      show_guide = FALSE)
+          ggvaluelabels <-
+            geom_text(aes(y = ypos, 
+                          label = sprintf(""%i\n(%.01f%%)"", frq, prz)),
+                      vjust = vert,
+                      show.legend = FALSE)
         } else if (showCountValues) {
-          ggvaluelabels <-  geom_text(aes(y = ypos, label = sprintf(""%i"", frq)),
-                                      vjust = vert,
-                                      show_guide = FALSE)
+          ggvaluelabels <-
+            geom_text(aes(y = ypos, label = sprintf(""%i"", frq)),
+                      vjust = vert,
+                      show.legend = FALSE)
         } else if (showPercentageValues) {
-          ggvaluelabels <-  geom_text(aes(y = ypos, label = sprintf(""%.01f%%"", prz)),
-                                      vjust = vert,
-                                      show_guide = FALSE)
+          ggvaluelabels <-
+            geom_text(aes(y = ypos, label = sprintf(""%.01f%%"", prz)),
+                      vjust = vert,
+                      show.legend = FALSE)
         } else {
-          ggvaluelabels <-  geom_text(label = """", show_guide = FALSE)
+          ggvaluelabels <-  geom_text(label = """", show.legend = FALSE)
         }
       } else {
         # ---------------------------------------------------------
-        # if we have dodged bars or dots, we have to use a slightly 
+        # if we have dodged bars or dots, we have to use a slightly
         # dodged position for labels
         # as well, sofor better reading
         # ---------------------------------------------------------
         if (showPercentageValues && showCountValues) {
           if (coord.flip) {
-            ggvaluelabels <-  geom_text(aes(y = frq, label = sprintf(""%i (%.01f%%)"", frq, prz)),
-                                        position = position_dodge(posdodge),
-                                        vjust = vert,
-                                        hjust = hort,
-                                        show_guide = FALSE)
+            ggvaluelabels <-
+              geom_text(aes(y = frq, label = sprintf(""%i (%.01f%%)"", frq, prz)),
+                        position = position_dodge(posdodge),
+                        vjust = vert,
+                        hjust = hort,
+                        show.legend = FALSE)
           } else {
-            ggvaluelabels <-  geom_text(aes(y = frq, label = sprintf(""%i\n(%.01f%%)"", frq, prz)),
-                                        position = position_dodge(posdodge),
-                                        vjust = vert,
-                                        hjust = hort,
-                                        show_guide = FALSE)
+            ggvaluelabels <-
+              geom_text(aes(y = frq, label = sprintf(""%i\n(%.01f%%)"", frq, prz)),
+                        position = position_dodge(posdodge),
+                        vjust = vert,
+                        hjust = hort,
+                        show.legend = FALSE)
           }
         } else if (showCountValues) {
-          ggvaluelabels <-  geom_text(aes(y = frq, label = sprintf(""%i"", frq)),
-                                      position = position_dodge(posdodge),
-                                      hjust = hort,
-                                      vjust = vert,
-                                      show_guide = FALSE)
+          ggvaluelabels <-
+            geom_text(aes(y = frq, label = sprintf(""%i"", frq)),
+                      position = position_dodge(posdodge),
+                      hjust = hort,
+                      vjust = vert,
+                      show.legend = FALSE)
         } else if (showPercentageValues) {
-          ggvaluelabels <-  geom_text(aes(y = frq, label = sprintf(""%.01f%%"", prz)),
-                                      position = position_dodge(posdodge),
-                                      hjust = hort,
-                                      vjust = vert,
-                                      show_guide = FALSE)
+          ggvaluelabels <-
+            geom_text(aes(y = frq, label = sprintf(""%.01f%%"", prz)),
+                      position = position_dodge(posdodge),
+                      hjust = hort,
+                      vjust = vert,
+                      show.legend = FALSE)
         } else {
-          ggvaluelabels <-  geom_text(label = """", show_guide = FALSE)
+          ggvaluelabels <-  geom_text(label = """", show.legend = FALSE)
         }
       }
     }
   } else {
-    ggvaluelabels <-  geom_text(label = """", show_guide = FALSE)
+    ggvaluelabels <-  geom_text(label = """", show.legend = FALSE)
   }
   # --------------------------------------------------------
   # Set up grid breaks
@@ -964,13 +801,15 @@ sjp.grpfrq <- function(varCount,
   # plot object for histogram style
   # ----------------------------------
   if (type == ""histogram"" || type == ""lines"") {
-    mydat$count <- sjmisc::to_value(mydat$count, keep.labels = F)
+    mydf$xpos <- sjmisc::to_value(mydf$xpos, keep.labels = F)
     if (type == ""histogram"") {
       # histrogram need fill aes
-      baseplot <- ggplot(mydat, aes(x = count, y = frq, fill = group)) + geob
+      baseplot <-
+        ggplot(mydf, aes(x = xpos, y = frq, fill = group)) + geob
     } else {
       # lines need colour aes
-      baseplot <- ggplot(mydat, aes(x = count, y = frq, colour = group)) + geob
+      baseplot <-
+        ggplot(mydf, aes(x = xpos, y = frq, colour = group)) + geob
     }
     scalex <- scale_x_continuous(limits = axisLimits.x)
     # -----------------------------------------
@@ -980,28 +819,28 @@ sjp.grpfrq <- function(varCount,
       # -----------------------------------------
       # vertical lines indicating the mean
       # -----------------------------------------
-      baseplot <- baseplot + 
-        geom_vline(data = vldat, 
-                   aes(xintercept = mw, colour = group), 
-                   linetype = meanInterceptLineType, 
+      baseplot <- baseplot +
+        geom_vline(data = vldat,
+                   aes(xintercept = mw, colour = group),
+                   linetype = meanInterceptLineType,
                    size = meanInterceptLineSize)
       # -----------------------------------------
       # check whether meanvalue should be shown.
       # -----------------------------------------
       if (showMeanValue) {
         # -----------------------------------------
-        # use annotation instead of geomtext, because we 
+        # use annotation instead of geomtext, because we
         # need mean value only printed once
         # -----------------------------------------
-        baseplot <- baseplot + 
+        baseplot <- baseplot +
           annotate(""text"", 
                    x = vldat$mw, 
-                   y = upper_lim, 
-                   parse = TRUE, 
-                   label = sprintf(""italic(bar(x)[%i]) == %.2f"", 
-                                   vldat$yfactor, 
-                                   vldat$mw), 
-                   hjust = 1.05, 
+                   y = upper_lim,
+                   parse = TRUE,
+                   label = sprintf(""italic(bar(x)[%i]) == %.2f"",
+                                   vldat$yfactor,
+                                   vldat$mw),
+                   hjust = 1.05,
                    vjust = vldat$yfactor * 2)
       }
       # -----------------------------------------
@@ -1010,74 +849,71 @@ sjp.grpfrq <- function(varCount,
       if (showStandardDeviation) {
         baseplot <- baseplot +
           # -----------------------------------------
-          # first draw shaded rectangle. these are by default 
+          # first draw shaded rectangle. these are by default
           # in grey colour with very high transparancy
           # -----------------------------------------
-          annotate(""rect"", 
-                   xmin = vldat$mw - vldat$stddev, 
-                   xmax = vldat$mw + vldat$stddev, 
-                   fill = ""grey50"", 
-                   ymin = 0, 
-                   ymax = upper_lim, 
-                   alpha = 0.1) +
+          annotate(""rect"",
+                   xmin = vldat$mw - vldat$stddev,
+                   xmax = vldat$mw + vldat$stddev,
+                   fill = ""grey50"",
+                   ymin = 0,
+                  ymax = upper_lim,alpha = 0.1) +
           # -----------------------------------------
-          # draw border-lines for shaded rectangles 
+          # draw border-lines for shaded rectangles
           # in the related group colours.
           # -----------------------------------------
-          geom_vline(data = vldat, 
-                     aes(xintercept = mw - stddev, colour = group), 
-                     linetype = 3, 
-                     size = meanInterceptLineSize, 
+          geom_vline(data = vldat,
+                     aes(xintercept = mw - stddev, colour = group),
+                     linetype = 3,
+                     size = meanInterceptLineSize,
                      alpha = 0.7) +
-          geom_vline(data = vldat, 
-                     aes(xintercept = mw + stddev, colour = group), 
-                     linetype = 3, 
-                     size = meanInterceptLineSize, 
+          geom_vline(data = vldat,
+                     aes(xintercept = mw + stddev, colour = group),
+                     linetype = 3,
+                     size = meanInterceptLineSize,
                      alpha = 0.7)
         # -----------------------------------------
-        # if mean values are plotted, plot standard 
+        # if mean values are plotted, plot standard
         # deviation values as well
         # -----------------------------------------
         if (showMeanValue) {
-          baseplot <- baseplot + 
+          baseplot <- baseplot +
             # -----------------------------------------
-            # use annotation instead of geomtext, because we 
+            # use annotation instead of geomtext, because we
             # need standard deviations only printed once
             # -----------------------------------------
-            annotate(""text"", 
-                     x = vldat$mw + vldat$stddev, 
-                     y = upper_lim, 
-                     parse = TRUE, 
-                     label = sprintf(""italic(s[%i]) == %.2f"", 
-                                     vldat$yfactor, 
-                                     round(vldat$stddev, 1)), 
-                     hjust = 1.1, 
+            annotate(""text"",
+                     x = vldat$mw + vldat$stddev,
+                     y = upper_lim,
+                     parse = TRUE,
+                     label = sprintf(""italic(s[%i]) == %.2f"",
+                                     vldat$yfactor,
+                                     round(vldat$stddev, 1)),
+                     hjust = 1.1,
                      vjust = vldat$yfactor * 2)
         }
       }
     }
   } else if (type == ""boxplots"" || type == ""violin"") {
     if (is.null(interactionVar)) {
-      baseplot <- ggplot(mydat, 
-                         aes(x = group, 
-                             y = frq, 
-                             fill = group, 
-                             weight = wb)) + geob
+      baseplot <- ggplot(mydf,aes(x = group,
+                                  y = frq,
+                                  fill = group,
+                                  weight = wb)) + geob
       scalex <- scale_x_discrete(labels = axisLabels.x)
     } else {
-      baseplot <- ggplot(mydat, 
-                         aes(x = interaction(ia, group), 
-                             y = frq, 
-                             fill = group, 
-                             weight = wb)) + geob
+      baseplot <- ggplot(mydf, aes(x = interaction(ia, group),
+                                   y = frq,
+                                   fill = group,
+                                   weight = wb)) + geob
       scalex <- scale_x_discrete(labels = interactionVarLabels)
     }
     # if we have a violin plot, add an additional boxplot inside to show
     # more information
     if (type == ""violin"") {
       baseplot <- baseplot +
-        geom_boxplot(width = innerBoxPlotWidth, 
-                     fill = ""white"", 
+        geom_boxplot(width = innerBoxPlotWidth,
+                     fill = ""white"",
                      outlier.colour = NA)
     }
     # ---------------------------------------------------------
@@ -1087,34 +923,33 @@ sjp.grpfrq <- function(varCount,
     # ---------------------------------------------------------
     fcsp <- ifelse(type == ""boxplots"", ""white"", ""black"")
     baseplot <- baseplot +
-      stat_summary(fun.y = ""mean"", 
-                   geom = ""point"", 
-                   shape = 21, 
-                   size = innerBoxPlotDotSize, 
+      stat_summary(fun.y = ""mean"",
+                   geom = ""point"",
+                   shape = 21,
+                   size = innerBoxPlotDotSize,
                    fill = fcsp)
   } else {
     if (type == ""dots"") {
-      baseplot <- ggplot(mydat, 
-                         aes(x = factor(count), 
-                             y = frq, 
-                             colour = group))
+      baseplot <- ggplot(mydf, aes(x = factor(xpos),
+                                   y = frq,
+                                   colour = group))
     } else {
-      baseplot <- ggplot(mydat, 
-                         aes(x = factor(count), 
-                             y = frq, 
-                             fill = group))
+      baseplot <- ggplot(mydf, aes(x = factor(xpos),
+                                   y = frq,
+                                   fill = group))
     }
     # ---------------------------------------------------------
     # check whether we have dots plotted, and if so, use annotation
     # We have to use annotation first, because the diagram's layers are plotted
     # in the order as they're passed to the ggplot-command. Since we don't want the
     # shaded rectangles to overlay the dots, we add them first
     # ---------------------------------------------------------
-    if (!is.null(ganno) && !facet.grid) baseplot <- baseplot + ganno
+    if (!is.null(ganno) && !facet.grid)
+      baseplot <- baseplot + ganno
     # add geom
     baseplot <- baseplot + geob
     if (startAxisAt > 1) {
-      scalex <- scale_x_discrete(labels = axisLabels.x, 
+      scalex <- scale_x_discrete(labels = axisLabels.x,
                                  limits = as.factor(seq(from = startAxisAt,
                                                         to = catcount,
                                                         by = 1)))
@@ -1123,7 +958,7 @@ sjp.grpfrq <- function(varCount,
     }
   }
   # ------------------------------------------
-  # If we have bars or dot plots, we show 
+  # If we have bars or dot plots, we show
   # Pearson's chi-square test results
   # ------------------------------------------
   baseplot <- print.table.summary(baseplot,
@@ -1134,13 +969,13 @@ sjp.grpfrq <- function(varCount,
   # show or hide y-axis-labels
   # ------------------------------
   if (showAxisLabels.y) {
-    y_scale <- scale_y_continuous(breaks = gridbreaks, 
-                                  limits = c(lower_lim, upper_lim), 
+    y_scale <- scale_y_continuous(breaks = gridbreaks,
+                                  limits = c(lower_lim, upper_lim),
                                   expand = expand.grid)
   } else {
-    y_scale <- scale_y_continuous(breaks = gridbreaks, 
-                                  limits = c(lower_lim, upper_lim), 
-                                  expand = expand.grid, 
+    y_scale <- scale_y_continuous(breaks = gridbreaks,
+                                  limits = c(lower_lim, upper_lim),
+                                  expand = expand.grid,
                                   labels = NULL)
   }
   # ------------------------------
@@ -1150,13 +985,13 @@ sjp.grpfrq <- function(varCount,
     # show absolute and percentage value of each bar.
     ggvaluelabels +
     # no additional labels for the x- and y-axis, only diagram title
-    labs(title = title, 
-         x = axisTitle.x, 
-         y = axisTitle.y, 
+    labs(title = title,
+         x = axisTitle.x,
+         y = axisTitle.y,
          fill = legendTitle,
          colour = legendTitle) +
     # print value labels to the x-axis.
-    # If argument ""axisLabels.x"" is NULL, the category numbers (1 to ...) 
+    # If argument ""axisLabels.x"" is NULL, the category numbers (1 to ...)
     # appear on the x-axis
     scalex +
     # set Y-axis, depending on the calculated upper y-range.
@@ -1166,25 +1001,32 @@ sjp.grpfrq <- function(varCount,
     y_scale
   # check whether coordinates should be flipped, i.e.
   # swap x and y axis
-  if (coord.flip) baseplot <- baseplot + coord_flip()
+  if (coord.flip)
+    baseplot <- baseplot + coord_flip()
   # --------------------------------------------------
   # Here we start when we have a faces grid instead of
   # a grouped bar plot.
   # --------------------------------------------------
   if (facet.grid) {
-    baseplot <- baseplot + 
+    baseplot <- baseplot +
       # set font size for axes.
-      theme(strip.text = element_text(face = ""bold"",size = rel(1.2))) +
+      theme(strip.text = element_text(face = ""bold"", size = rel(1.2))) +
       facet_wrap(~group)
   }
   # ---------------------------------------------------------
   # set geom colors
   # ---------------------------------------------------------
-  baseplot <- sj.setGeomColors(baseplot, geom.colors, length(legendLabels), ifelse(hideLegend == TRUE, FALSE, TRUE), legendLabels)
+  baseplot <-
+    sj.setGeomColors(baseplot,
+                     geom.colors,
+                     length(legendLabels),
+                     ifelse(hideLegend == TRUE, FALSE, TRUE),
+                     legendLabels)
   # ----------------------------------
   # Plot integrated bar chart here
   # ----------------------------------
-  if (printPlot) plot(baseplot)
+  if (printPlot)
+    plot(baseplot)
   # -------------------------------------
   # return results
   # -------------------------------------

---FILE: R/sjPlotInteractions.R---
@@ -398,6 +398,11 @@ sjp.int <- function(fit,
     message(""'type' has to be one of 'cond', 'eff' or 'emm'. Defaulting to 'cond'..."")
     type <- ""cond""
   }
+  # ------------------------
+  # do we have glm? if so, 
+  # get link family
+  # ------------------------
+  fitfam <- family(fit)$family
   # --------------------------------------------------------
   # plot estimated marginal means?
   # --------------------------------------------------------
@@ -436,7 +441,12 @@ sjp.int <- function(fit,
   # -----------------------------------------------------------
   # set axis title
   # -----------------------------------------------------------
-  if ((fun == ""glm"" || fun == ""glmer"") && is.null(axisTitle.y)) axisTitle.y <- ""Change in Predicted Probability""
+  if ((fun == ""glm"" || fun == ""glmer"") && is.null(axisTitle.y)) {
+    if (fitfam %in% c(""binomial"", ""quasibinomial""))
+      axisTitle.y <- ""Change in Predicted Probability""
+    else 
+      axisTitle.y <- ""Change in Incidents Rates""
+  }
   # -----------------------------------------------------------
   # get all (significant) interaction terms from model
   # the function ""getInteractionTerms"" checks if a fitted
@@ -655,27 +665,45 @@ sjp.int <- function(fit,
         upperLim.y <- axisLimits.y[2]
       }
     } else {
-      intdf$x <- sjmisc::to_value(intdf$x, keep.labels = F)
-      intdf$y <- plogis(sjmisc::to_value(intdf$y, keep.labels = F))
-      intdf$ymin <- plogis(sjmisc::to_value(intdf$ymin, keep.labels = F))
-      intdf$ymax <- plogis(sjmisc::to_value(intdf$ymax, keep.labels = F))
-      intdf$ydiff <- plogis(intdf$ymax - intdf$ymin)
-      # -----------------------------------------------------------
-      # retrieve lowest and highest x and y position to determine
-      # the scale limits
-      # -----------------------------------------------------------
-      if (is.null(axisLimits.y)) {
+      if (fitfam %ini% c(""binomial"", ""quasibinomial"")) {
+        intdf$x <- sjmisc::to_value(intdf$x, keep.labels = F)
+        intdf$y <- plogis(sjmisc::to_value(intdf$y, keep.labels = F))
+        intdf$ymin <- plogis(sjmisc::to_value(intdf$ymin, keep.labels = F))
+        intdf$ymax <- plogis(sjmisc::to_value(intdf$ymax, keep.labels = F))
+        intdf$ydiff <- plogis(intdf$ymax - intdf$ymin)
+      } else {
+        intdf$x <- sjmisc::to_value(intdf$x, keep.labels = F)
+        intdf$y <- exp(sjmisc::to_value(intdf$y, keep.labels = F))
+        intdf$ymin <- exp(sjmisc::to_value(intdf$ymin, keep.labels = F))
+        intdf$ymax <- exp(sjmisc::to_value(intdf$ymax, keep.labels = F))
+        intdf$ydiff <- exp(intdf$ymax - intdf$ymin)
+      }
+    }
+    # -----------------------------------------------------------
+    # retrieve lowest and highest x and y position to determine
+    # the scale limits
+    # -----------------------------------------------------------
+    if (is.null(axisLimits.y)) {
+      if (fitfam %ini% c(""binomial"", ""quasibinomial"")) {
         lowerLim.y <- 0
         upperLim.y <- 1
       } else {
-        lowerLim.y <- axisLimits.y[1]
-        upperLim.y <- axisLimits.y[2]
-      }
+        if (diff) {
+          lowerLim.y <- floor(min(intdf$ydiff, na.rm = T))
+          upperLim.y <- ceiling(max(intdf$ydiff, na.rm = T))
+        } else {
+          lowerLim.y <- floor(min(intdf$y, na.rm = T))
+          upperLim.y <- ceiling(max(intdf$y, na.rm = T))
+        }
+      } 
+    } else {
+      lowerLim.y <- axisLimits.y[1]
+      upperLim.y <- axisLimits.y[2]
     }
     # -----------------------------------------------------------
     # check x-axis limits
     # -----------------------------------------------------------
-    if (is.null(axisLimits.x)) {
+    if (!is.null(axisLimits.x)) {
       lowerLim.x <- axisLimits.x[1]
       upperLim.x <- axisLimits.x[2]
     } else {
@@ -767,12 +795,12 @@ sjp.int <- function(fit,
     if (diff) {
       baseplot <- ggplot(intdf, aes(x = x, y = ydiff)) +
         # -----------------------------------------------------------
-        # add a shaded region between minimun
-        # and maximum curve of interactions
-        # -----------------------------------------------------------
-        geom_ribbon(aes(ymin = 0, ymax = ydiff),
-                    fill = fillColor,
-                    alpha = fillAlpha) +
+      # add a shaded region between minimun
+      # and maximum curve of interactions
+      # -----------------------------------------------------------
+      geom_ribbon(aes(ymin = 0, ymax = ydiff),
+                  fill = fillColor,
+                  alpha = fillAlpha) +
         geom_line(size = geom.size)
       # -----------------------------------------------------------
       # show value labels
@@ -781,7 +809,7 @@ sjp.int <- function(fit,
         baseplot <- baseplot +
           geom_text(aes(label = round(ydiff, 1)),
                     vjust = 1.5,
-                    show_guide = FALSE)
+                    show.legend = FALSE)
       }
     } else {
       baseplot <- ggplot(intdf, aes(x = x, y = y, colour = grp))
@@ -792,7 +820,7 @@ sjp.int <- function(fit,
           geom_ribbon(aes(ymin = ymin, ymax = ymax, colour = NULL),
                       fill = fillColor,
                       alpha = fillAlpha,
-                      show_guide = FALSE)
+                      show.legend = FALSE)
       }
       # add line
       baseplot <- baseplot + geom_line()
@@ -804,7 +832,7 @@ sjp.int <- function(fit,
           geom_point() +
           geom_text(aes(label = round(y, 1)),
                     vjust = 1.5,
-                    show_guide = FALSE)
+                    show.legend = FALSE)
       }
     }
     # ------------------------------------------------------------------------------------
@@ -854,582 +882,598 @@ sjp.int <- function(fit,
                       list(plot.list = plotlist,
                            df.list = dflist)))
 }
-
-
-#' @importFrom stats plogis na.omit
-sjp.eff.int <- function(fit,
-                        int.term = NULL,
-                        int.plot.index = NULL,
-                        moderatorValues = ""minmax"",
-                        swapPredictors = FALSE,
-                        plevel = 0.05,
-                        title = NULL,
-                        fillAlpha = 0.3,
-                        geom.colors = ""Set1"",
-                        geom.size = 0.7,
-                        axisTitle.x = NULL,
-                        axisTitle.y = NULL,
-                        legendTitle = NULL,
-                        legendLabels = NULL,
-                        showValueLabels = FALSE,
-                        breakTitleAt = 50,
-                        breakLegendLabelsAt = 20,
-                        breakLegendTitleAt = 20,
-                        axisLimits.x = NULL,
-                        axisLimits.y = NULL,
-                        gridBreaksAt = NULL,
-                        showCI = FALSE,
-                        facet.grid = FALSE,
-                        printPlot = TRUE,
-                        fun) {
-  # --------------------------------------------------------
-  # check default geom.size
-  # --------------------------------------------------------
-  if (is.null(geom.size)) geom.size = .7
-  # ------------------------
-  # check if suggested package is available
-  # ------------------------
-  if (!requireNamespace(""effects"", quietly = TRUE)) {
-    stop(""Package 'effects' needed for this function to work. Please install it."", call. = FALSE)
-  }
-  # gridbreaks
-  if (is.null(gridBreaksAt)) gridbreaks.x <- gridbreaks.y <- ggplot2::waiver()
-  # ------------------------
-  # multiple purpose of showCI parameter. if logical,
-  # sets default CI to 0.95, else showCI also may be
-  # numeric
-  # ------------------------
-  if (!is.null(showCI) && !is.logical(showCI)) {
-    eci <- showCI
-    showCI = TRUE
-  } else {
-    eci <- 0.95
-  }
-  # ------------------------
-  # calculate effects of higher order terms and
-  # check if fitted model contains any interaction terms
-  # allEffects returns a list, with all interaction effects 
-  # (or higher order terms) as separate list element. each list
-  # element contains the higher-order-term of the fitted model,
-  # where the 'term' attribute of interaction terms have a ""*"". 
-  # So we just need to look at each 'term' attribute of each
-  # list element and see if there is a ""*""...
-  # ------------------------
-  if (is.null(int.term)) {
-    eff <- effects::allEffects(fit, KR = F)
-    int <- unlist(lapply(eff, function(x) grep(""*"", x['term'], fixed = T)))
-  } else {
-    eff <- effects::effect(int.term, fit, KR = F)
-    int <- grep(""*"", eff$term, fixed = T)
-  }
-  if (length(int) == 0) {
-    warning(""No interaction term found in fitted model..."", call. = FALSE)
-    return(invisible(NULL))
-  }
-  # ------------------------
-  # retrieve position of interaction terms in effects-object
-  # ------------------------
-  if (is.null(int.term)) {
-    intpos <- which(as.vector(sapply(eff, function(x) length(grep(""*"", x['term'], fixed = T)) > 0)) == T)
-  } else {
-    intpos <- 1
-  }
-  # select only specific plots
-  if (!is.null(int.plot.index) && !any(int.plot.index > length(intpos))) intpos <- intpos[int.plot.index]  
-  # init vector that saves ggplot objects
-  plotlist <- list()
-  dflist <- list()
-  # -----------------------------------------------------------
-  # iterate all interaction terms
-  # -----------------------------------------------------------
-  for (i in 1:length(intpos)) {
-    # -----------------------------------------------------------
-    # copy ""eff"" object, so we don't confuse with effect-return-
-    # value from single term and multiple terms
-    # -----------------------------------------------------------
+  
+  
+  #' @importFrom stats plogis na.omit
+  sjp.eff.int <- function(fit,
+                          int.term = NULL,
+                          int.plot.index = NULL,
+                          moderatorValues = ""minmax"",
+                          swapPredictors = FALSE,
+                          plevel = 0.05,
+                          title = NULL,
+                          fillAlpha = 0.3,
+                          geom.colors = ""Set1"",
+                          geom.size = 0.7,
+                          axisTitle.x = NULL,
+                          axisTitle.y = NULL,
+                          legendTitle = NULL,
+                          legendLabels = NULL,
+                          showValueLabels = FALSE,
+                          breakTitleAt = 50,
+                          breakLegendLabelsAt = 20,
+                          breakLegendTitleAt = 20,
+                          axisLimits.x = NULL,
+                          axisLimits.y = NULL,
+                          gridBreaksAt = NULL,
+                          showCI = FALSE,
+                          facet.grid = FALSE,
+                          printPlot = TRUE,
+                          fun) {
+    # --------------------------------------------------------
+    # check default geom.size
+    # --------------------------------------------------------
+    if (is.null(geom.size)) geom.size = .7
+    # ------------------------
+    # check if suggested package is available
+    # ------------------------
+    if (!requireNamespace(""effects"", quietly = TRUE)) {
+      stop(""Package 'effects' needed for this function to work. Please install it."", call. = FALSE)
+    }
+    # gridbreaks
+    if (is.null(gridBreaksAt)) gridbreaks.x <- gridbreaks.y <- ggplot2::waiver()
+    # ------------------------
+    # multiple purpose of showCI parameter. if logical,
+    # sets default CI to 0.95, else showCI also may be
+    # numeric
+    # ------------------------
+    if (!is.null(showCI) && !is.logical(showCI)) {
+      eci <- showCI
+      showCI = TRUE
+    } else {
+      eci <- 0.95
+    }
+    # ------------------------
+    # calculate effects of higher order terms and
+    # check if fitted model contains any interaction terms
+    # allEffects returns a list, with all interaction effects 
+    # (or higher order terms) as separate list element. each list
+    # element contains the higher-order-term of the fitted model,
+    # where the 'term' attribute of interaction terms have a ""*"". 
+    # So we just need to look at each 'term' attribute of each
+    # list element and see if there is a ""*""...
+    # ------------------------
     if (is.null(int.term)) {
-      dummy.eff <- eff[[intpos[i]]]
+      eff <- effects::allEffects(fit, KR = F)
+      int <- unlist(lapply(eff, function(x) grep(""*"", x['term'], fixed = T)))
     } else {
-      dummy.eff <- eff
+      eff <- effects::effect(int.term, fit, KR = F)
+      int <- grep(""*"", eff$term, fixed = T)
     }
+    if (length(int) == 0) {
+      warning(""No interaction term found in fitted model..."", call. = FALSE)
+      return(invisible(NULL))
+    }
+    # ------------------------
+    # retrieve position of interaction terms in effects-object
+    # ------------------------
+    if (is.null(int.term)) {
+      intpos <- which(as.vector(sapply(eff, function(x) length(grep(""*"", x['term'], fixed = T)) > 0)) == T)
+    } else {
+      intpos <- 1
+    }
+    # select only specific plots
+    if (!is.null(int.plot.index) && !any(int.plot.index > length(intpos))) intpos <- intpos[int.plot.index]  
+    # init vector that saves ggplot objects
+    plotlist <- list()
+    dflist <- list()
     # -----------------------------------------------------------
-    # retrieve data frame
-    # -----------------------------------------------------------
-    intdf <- data.frame(dummy.eff)
-    # -----------------------------------------------------------
-    # save response, predictor and moderator names
-    # -----------------------------------------------------------
-    pred_x.name <- colnames(intdf)[ifelse(swapPredictors == TRUE, 1, 2)]
-    moderator.name <- colnames(intdf)[ifelse(swapPredictors == TRUE, 2, 1)]
-    response.name <- dummy.eff$response
-    # prepare axis titles
-    labx <- pred_x.name
-    # check whether x-axis-predictor is a factor or not
-    x_is_factor <- is.factor(intdf[[pred_x.name]]) || (length(unique(na.omit(intdf[[pred_x.name]]))) < 3)
-    # -----------------------------------------------------------
-    # check for moderator values, but only, if moderator 
-    # is no factor value. In this case, we can choose
-    # the values for continuous moderator intentionally,
-    # e.g. only min/max, or mean and sd. We don't need these
-    # values for categorical moderator values.
+    # iterate all interaction terms
     # -----------------------------------------------------------
-    if (!is.factor(intdf[[moderator.name]])) {
-      # retrieve moderator value
-      modval <- dummy.eff$data[[moderator.name]]
-      # retrieve predictor value
-      predval <- dummy.eff$data[[pred_x.name]]
-      # -----------------------------------------------------------
-      # Check whether moderator value has enough unique values
-      # for quartiles
-      # -----------------------------------------------------------
-      moderatorValues <- mv_check(moderatorValues, modval)
-      # we have more than two values, so re-calculate effects, just using
-      # min and max value of moderator. 
-      if (moderatorValues == ""minmax"" && length(unique(intdf[[moderator.name]])) > 2) {
-        # retrieve min and max values
-        mv.min <- min(modval, na.rm = T)
-        mv.max <- max(modval, na.rm = T)
-        # re-compute effects, prepare xlevels
-        xl1 <- list(x = c(mv.min, mv.max))
-      # we have more than two values, so re-calculate effects, just using
-      # 0 and max value of moderator.
-      } else if (moderatorValues == ""zeromax"" && length(unique(intdf[[moderator.name]])) > 2) {
-        # retrieve max values
-        mv.max <- max(modval, na.rm = T)
-        # re-compute effects, prepare xlevels
-        xl1 <- list(x = c(0, mv.max))
-      # compute mean +/- sd
-      } else if (moderatorValues == ""meansd"") {
-        # retrieve mean and sd
-        mv.mean <- round(mean(modval, na.rm = T), 2)
-        mv.sd <- round(sd(modval, na.rm = T), 2)
-        # re-compute effects, prepare xlevels
-        xl1 <- list(x = c(mv.mean - mv.sd, mv.mean, mv.mean + mv.sd))
-      } else if (moderatorValues == ""quart"") {
-        # re-compute effects, prepare xlevels
-        xl1 <- list(x = as.vector(quantile(modval, na.rm = T)))
-      }
-      # change list name to moderator value name
-      names(xl1) <- moderator.name
-      # add values of interaction term
-      # first, get all unqiue values
-      prvl <- sort(unique(stats::na.omit(predval)))
-      # add them to list as well
-      xl2 <- list(y = prvl)
-      # change list name
-      names(xl2) <- pred_x.name
-      # combine lists
+    for (i in 1:length(intpos)) {
+      # -----------------------------------------------------------
+      # copy ""eff"" object, so we don't confuse with effect-return-
+      # value from single term and multiple terms
+      # -----------------------------------------------------------
       if (is.null(int.term)) {
-        # re-compute effects
-        eff.tmp <- effects::allEffects(fit, 
-                                       xlevels = c(xl1, xl2), 
-                                       KR = F, 
-                                       confidence.level = eci)
-        # reset data frame
-        intdf <- data.frame(eff.tmp[[intpos[i]]])
+        dummy.eff <- eff[[intpos[i]]]
       } else {
-        # re-compute effects
-        eff.tmp <- effects::effect(int.term, 
-                                   fit, 
-                                   xlevels = c(xl1, xl2), 
-                                   KR = F,
-                                   confidence.level = eci)
-        # reset data frame
-        intdf <- data.frame(eff.tmp)
+        dummy.eff <- eff
       }
       # -----------------------------------------------------------
-      # check for predictor values on x-axis. if it 
-      # is no factor, select whole range of possible
-      # values.
-      # -----------------------------------------------------------
-    } else if (!is.factor(intdf[[pred_x.name]])) {
-      # retrieve predictor value
-      predval <- dummy.eff$data[[pred_x.name]]
-      # add values of interaction term
-      # first, get all unqiue values
-      prvl <- sort(unique(stats::na.omit(predval)))
-      # add them to list as well
-      xl <- list(x = prvl)
-      # change list name
-      names(xl) <- pred_x.name
-      # combine lists
-      if (is.null(int.term)) {
-        # re-compute effects
-        eff.tmp <- effects::allEffects(fit,
-                                       xlevels = xl, 
-                                       KR = F,
-                                       confidence.level = eci)
-        # reset data frame
-        intdf <- data.frame(eff.tmp[[intpos[i]]])
+      # retrieve data frame
+      # -----------------------------------------------------------
+      intdf <- data.frame(dummy.eff)
+      # -----------------------------------------------------------
+      # save response, predictor and moderator names
+      # -----------------------------------------------------------
+      pred_x.name <- colnames(intdf)[ifelse(swapPredictors == TRUE, 1, 2)]
+      moderator.name <- colnames(intdf)[ifelse(swapPredictors == TRUE, 2, 1)]
+      response.name <- dummy.eff$response
+      # prepare axis titles
+      labx <- pred_x.name
+      # check whether x-axis-predictor is a factor or not
+      x_is_factor <- is.factor(intdf[[pred_x.name]]) || (length(unique(na.omit(intdf[[pred_x.name]]))) < 3)
+      # -----------------------------------------------------------
+      # check for moderator values, but only, if moderator 
+      # is no factor value. In this case, we can choose
+      # the values for continuous moderator intentionally,
+      # e.g. only min/max, or mean and sd. We don't need these
+      # values for categorical moderator values.
+      # -----------------------------------------------------------
+      if (!is.factor(intdf[[moderator.name]])) {
+        # retrieve moderator value
+        modval <- dummy.eff$data[[moderator.name]]
+        # retrieve predictor value
+        predval <- dummy.eff$data[[pred_x.name]]
+        # -----------------------------------------------------------
+        # Check whether moderator value has enough unique values
+        # for quartiles
+        # -----------------------------------------------------------
+        moderatorValues <- mv_check(moderatorValues, modval)
+        # we have more than two values, so re-calculate effects, just using
+        # min and max value of moderator. 
+        if (moderatorValues == ""minmax"" && length(unique(intdf[[moderator.name]])) > 2) {
+          # retrieve min and max values
+          mv.min <- min(modval, na.rm = T)
+          mv.max <- max(modval, na.rm = T)
+          # re-compute effects, prepare xlevels
+          xl1 <- list(x = c(mv.min, mv.max))
+          # we have more than two values, so re-calculate effects, just using
+          # 0 and max value of moderator.
+        } else if (moderatorValues == ""zeromax"" && length(unique(intdf[[moderator.name]])) > 2) {
+          # retrieve max values
+          mv.max <- max(modval, na.rm = T)
+          # re-compute effects, prepare xlevels
+          xl1 <- list(x = c(0, mv.max))
+          # compute mean +/- sd
+        } else if (moderatorValues == ""meansd"") {
+          # retrieve mean and sd
+          mv.mean <- round(mean(modval, na.rm = T), 2)
+          mv.sd <- round(sd(modval, na.rm = T), 2)
+          # re-compute effects, prepare xlevels
+          xl1 <- list(x = c(mv.mean - mv.sd, mv.mean, mv.mean + mv.sd))
+        } else if (moderatorValues == ""quart"") {
+          # re-compute effects, prepare xlevels
+          xl1 <- list(x = as.vector(quantile(modval, na.rm = T)))
+        }
+        # change list name to moderator value name
+        names(xl1) <- moderator.name
+        # add values of interaction term
+        # first, get all unqiue values
+        prvl <- sort(unique(stats::na.omit(predval)))
+        # add them to list as well
+        xl2 <- list(y = prvl)
+        # change list name
+        names(xl2) <- pred_x.name
+        # combine lists
+        if (is.null(int.term)) {
+          # re-compute effects
+          eff.tmp <- effects::allEffects(fit, 
+                                         xlevels = c(xl1, xl2), 
+                                         KR = F, 
+                                         confidence.level = eci)
+          # reset data frame
+          intdf <- data.frame(eff.tmp[[intpos[i]]])
+        } else {
+          # re-compute effects
+          eff.tmp <- effects::effect(int.term, 
+                                     fit, 
+                                     xlevels = c(xl1, xl2), 
+                                     KR = F,
+                                     confidence.level = eci)
+          # reset data frame
+          intdf <- data.frame(eff.tmp)
+        }
+        # -----------------------------------------------------------
+        # check for predictor values on x-axis. if it 
+        # is no factor, select whole range of possible
+        # values.
+        # -----------------------------------------------------------
+      } else if (!is.factor(intdf[[pred_x.name]])) {
+        # retrieve predictor value
+        predval <- dummy.eff$data[[pred_x.name]]
+        # add values of interaction term
+        # first, get all unqiue values
+        prvl <- sort(unique(stats::na.omit(predval)))
+        # add them to list as well
+        xl <- list(x = prvl)
+        # change list name
+        names(xl) <- pred_x.name
+        # combine lists
+        if (is.null(int.term)) {
+          # re-compute effects
+          eff.tmp <- effects::allEffects(fit,
+                                         xlevels = xl, 
+                                         KR = F,
+                                         confidence.level = eci)
+          # reset data frame
+          intdf <- data.frame(eff.tmp[[intpos[i]]])
+        } else {
+          # re-compute effects
+          eff.tmp <- effects::effect(int.term, 
+                                     fit, 
+                                     xlevels = xl, 
+                                     KR = F,
+                                     confidence.level = eci)
+          # reset data frame
+          intdf <- data.frame(eff.tmp)
+        }
+      }
+      # -----------------------------------------------------------
+      # change column names
+      # -----------------------------------------------------------
+      if (swapPredictors) {
+        colnames(intdf) <- c(""x"", ""grp"", ""y"", ""se"", ""lower"", ""upper"")
       } else {
-        # re-compute effects
-        eff.tmp <- effects::effect(int.term, 
-                                   fit, 
-                                   xlevels = xl, 
-                                   KR = F,
-                                   confidence.level = eci)
-        # reset data frame
-        intdf <- data.frame(eff.tmp)
+        colnames(intdf) <- c(""grp"", ""x"", ""y"", ""se"", ""lower"", ""upper"")
       }
-    }
-    # -----------------------------------------------------------
-    # change column names
-    # -----------------------------------------------------------
-    if (swapPredictors) {
-      colnames(intdf) <- c(""x"", ""grp"", ""y"", ""se"", ""lower"", ""upper"")
-    } else {
-      colnames(intdf) <- c(""grp"", ""x"", ""y"", ""se"", ""lower"", ""upper"")
-    }
-    # -----------------------------------------------------------
-    # effects-package creates ""NA"" factor levels, which
-    # need to be removed
-    # -----------------------------------------------------------
-    intdf <- droplevels(intdf)
-    # group as factor
-    intdf$grp <- as.factor(intdf$grp)
-    # make sure x is numeric
-    intdf$x <- sjmisc::to_value(intdf$x, keep.labels = F)
-    # -----------------------------------------------------------
-    # convert df-values to numeric
-    # -----------------------------------------------------------
-    if (fun == ""lm"" || fun == ""lmer"" || fun == ""lme"" || fun == ""gls"") {
-      # Label on y-axis is name of dependent variable
-      laby <- response.name
       # -----------------------------------------------------------
-      # retrieve lowest and highest x and y position to determine
-      # the scale limits
+      # effects-package creates ""NA"" factor levels, which
+      # need to be removed
       # -----------------------------------------------------------
-      if (is.null(axisLimits.y)) {
-        if (showCI) {
-          lowerLim.y <- floor(min(intdf$lower, na.rm = T))
-          upperLim.y <- ceiling(max(intdf$upper, na.rm = T))
+      intdf <- droplevels(intdf)
+      # group as factor
+      intdf$grp <- as.factor(intdf$grp)
+      # make sure x is numeric
+      intdf$x <- sjmisc::to_value(intdf$x, keep.labels = F)
+      # -----------------------------------------------------------
+      # check if we have linear regression
+      # -----------------------------------------------------------
+      if (fun == ""lm"" || fun == ""lmer"" || fun == ""lme"" || fun == ""gls"") {
+        # Label on y-axis is name of dependent variable
+        laby <- response.name
+        # -----------------------------------------------------------
+        # retrieve lowest and highest x and y position to determine
+        # the scale limits
+        # -----------------------------------------------------------
+        if (is.null(axisLimits.y)) {
+          if (showCI) {
+            lowerLim.y <- floor(min(intdf$lower, na.rm = T))
+            upperLim.y <- ceiling(max(intdf$upper, na.rm = T))
+          } else {
+            lowerLim.y <- floor(min(intdf$y, na.rm = T))
+            upperLim.y <- ceiling(max(intdf$y, na.rm = T))
+          }
         } else {
-          lowerLim.y <- floor(min(intdf$y, na.rm = T))
-          upperLim.y <- ceiling(max(intdf$y, na.rm = T))
+          lowerLim.y <- axisLimits.y[1]
+          upperLim.y <- axisLimits.y[2]
         }
       } else {
-        lowerLim.y <- axisLimits.y[1]
-        upperLim.y <- axisLimits.y[2]
+        # ------------------------
+        # do we have glm? if so, 
+        # get link family
+        # ------------------------
+        fitfam <- family(fit)$family
+        # Label on y-axis is fixed
+        if (is.null(axisTitle.y)) {
+          # for logistic reg.
+          if (fitfam %in% c(""binomial"", ""quasibinomial""))
+            axisTitle.y <- ""Predicted Probability""
+          else if (fitfam %ini% c(""poisson"", ""quasipoisson""))
+            axisTitle.y <- ""Predicted Incidents""
+        }
+        # -----------------------------------------------------------
+        # retrieve lowest and highest x and y position to determine
+        # the scale limits
+        # -----------------------------------------------------------
+        if (is.null(axisLimits.y)) {
+          if (fitfam %in% c(""binomial"", ""quasibinomial"")) {
+            lowerLim.y <- 0
+            upperLim.y <- 1
+          } else {
+            if (showCI) {
+              lowerLim.y <- floor(min(intdf$lower, na.rm = T))
+              upperLim.y <- ceiling(max(intdf$upper, na.rm = T))
+            } else {
+              lowerLim.y <- floor(min(intdf$y, na.rm = T))
+              upperLim.y <- ceiling(max(intdf$y, na.rm = T))
+            }
+          }
+        } else {
+          lowerLim.y <- axisLimits.y[1]
+          upperLim.y <- axisLimits.y[2]
+        }
       }
-    } else {
-      # Label on y-axis is fixed
-      if (is.null(axisTitle.y)) axisTitle.y <- ""Predicted Probability""
-      # convert log-odds to probabilities
-      intdf$y <- stats::plogis(intdf$y)
-      intdf$lower <- stats::plogis(intdf$lower)
-      intdf$upper <- stats::plogis(intdf$upper)
-      intdf$se <- stats::plogis(intdf$se)
       # -----------------------------------------------------------
-      # retrieve lowest and highest x and y position to determine
-      # the scale limits
+      # check x-axis limits
       # -----------------------------------------------------------
-      if (is.null(axisLimits.y)) {
-        lowerLim.y <- 0
-        upperLim.y <- 1
+      if (!is.null(axisLimits.x)) {
+        lowerLim.x <- axisLimits.x[1]
+        upperLim.x <- axisLimits.x[2]
       } else {
-        lowerLim.y <- axisLimits.y[1]
-        upperLim.y <- axisLimits.y[2]
+        lowerLim.x <- floor(min(intdf$x, na.rm = T))
+        upperLim.x <- ceiling(max(intdf$x, na.rm = T))
       }
-    }
-    # -----------------------------------------------------------
-    # check x-axis limits
-    # -----------------------------------------------------------
-    if (is.null(axisLimits.x)) {
-      lowerLim.x <- axisLimits.x[1]
-      upperLim.x <- axisLimits.x[2]
-    } else {
-      lowerLim.x <- floor(min(intdf$x, na.rm = T))
-      upperLim.x <- ceiling(max(intdf$x, na.rm = T))
-    }
-    # -----------------------------------------------------------
-    # check whether user defined grid breaks / tick marks are used
-    # -----------------------------------------------------------
-    if (!is.null(gridBreaksAt)) {
-      gridbreaks.x <- c(seq(lowerLim.x, upperLim.x, by = gridBreaksAt))
-      gridbreaks.y <- c(seq(lowerLim.y, upperLim.y, by = gridBreaksAt))
-    }
-    # -----------------------------------------------------------
-    # prepare plot title and axis titles
-    # -----------------------------------------------------------
-    if (is.null(title)) {
-      labtitle <- paste0(""Interaction effect of "",
-                         moderator.name,
-                         "" and "",
-                         pred_x.name,
-                         "" on "", 
-                         response.name)
-    } else {
-      # copy plot counter 
-      l_nr <- i
-      # check if we have enough labels. if not, use last labels
-      if (l_nr > length(title)) l_nr <- length(title)
-      # set legend labels for plot
-      labtitle <- title[l_nr]
-    }
-    # -----------------------------------------------------------
-    # legend labels
-    # -----------------------------------------------------------
-    if (is.null(legendLabels)) {
-      lLabels <- levels(intdf$grp)
-    } else {
-      # copy plot counter 
-      l_nr <- i
-      # check if we have enough labels. if not, use last labels
-      if (l_nr > length(legendLabels)) l_nr <- length(legendLabels)
-      # set legend labels for plot
-      lLabels <- legendLabels[[l_nr]]
-    }
-    # -----------------------------------------------------------
-    # legend titles
-    # -----------------------------------------------------------
-    if (is.null(legendTitle)) {
-      lTitle <- moderator.name
-    } else {
-      # copy plot counter 
-      l_nr <- i
-      # check if we have enough legend titles, if not, use last legend title
-      if (l_nr > length(legendTitle)) l_nr <- length(legendTitle)
-      # set legend title for plot
-      lTitle <- legendTitle[l_nr]
-    }
-    # -----------------------------------------------------------
-    # x axis titles
-    # -----------------------------------------------------------
-    if (!is.null(axisTitle.x)) {
-      # copy plot counter 
-      l_nr <- i
-      # check if we have enough axis titles, if not, use last legend title
-      if (l_nr > length(axisTitle.x)) l_nr <- length(axisTitle.x)
-      # set axis title
-      labx <- axisTitle.x[l_nr]
-    }
-    if (!is.null(axisTitle.y)) laby <- axisTitle.y
-    # -----------------------------------------------------------
-    # wrap titles
-    # -----------------------------------------------------------
-    labtitle <- sjmisc::word_wrap(labtitle, breakTitleAt)
-    # wrap legend labels
-    lLabels <- sjmisc::word_wrap(lLabels, breakLegendLabelsAt)
-    # wrap legend title
-    lTitle <- sjmisc::word_wrap(lTitle, breakLegendTitleAt)
-    # ------------------------------------------------------------
-    # start plot
-    # ------------------------------------------------------------
-    baseplot <- ggplot(intdf, aes(x = x, y = y, colour = grp))
-    # ------------------------------------------------------------
-    # confidence interval?
-    # ------------------------------------------------------------
-    if (showCI) {
-      if (x_is_factor) {
-        # -------------------------------------------------
-        # for factors, we add error bars instead of
-        # continuous confidence region
-        # -------------------------------------------------
-        baseplot <- baseplot +
-          geom_errorbar(aes(ymin = lower, ymax = upper, colour = grp),
-                        width = 0,
-                        show_guide = FALSE) +
-          geom_point()
+      # -----------------------------------------------------------
+      # check whether user defined grid breaks / tick marks are used
+      # -----------------------------------------------------------
+      if (!is.null(gridBreaksAt)) {
+        gridbreaks.x <- c(seq(lowerLim.x, upperLim.x, by = gridBreaksAt))
+        gridbreaks.y <- c(seq(lowerLim.y, upperLim.y, by = gridBreaksAt))
+      }
+      # -----------------------------------------------------------
+      # prepare plot title and axis titles
+      # -----------------------------------------------------------
+      if (is.null(title)) {
+        labtitle <- paste0(""Interaction effect of "",
+                           moderator.name,
+                           "" and "",
+                           pred_x.name,
+                           "" on "", 
+                           response.name)
+      } else {
+        # copy plot counter 
+        l_nr <- i
+        # check if we have enough labels. if not, use last labels
+        if (l_nr > length(title)) l_nr <- length(title)
+        # set legend labels for plot
+        labtitle <- title[l_nr]
+      }
+      # -----------------------------------------------------------
+      # legend labels
+      # -----------------------------------------------------------
+      if (is.null(legendLabels)) {
+        lLabels <- levels(intdf$grp)
       } else {
-        # -------------------------------------------------
-        # for continuous variables, we add  continuous 
-        # confidence region instead of error bars 
-        # -------------------------------------------------
+        # copy plot counter 
+        l_nr <- i
+        # check if we have enough labels. if not, use last labels
+        if (l_nr > length(legendLabels)) l_nr <- length(legendLabels)
+        # set legend labels for plot
+        lLabels <- legendLabels[[l_nr]]
+      }
+      # -----------------------------------------------------------
+      # legend titles
+      # -----------------------------------------------------------
+      if (is.null(legendTitle)) {
+        lTitle <- moderator.name
+      } else {
+        # copy plot counter 
+        l_nr <- i
+        # check if we have enough legend titles, if not, use last legend title
+        if (l_nr > length(legendTitle)) l_nr <- length(legendTitle)
+        # set legend title for plot
+        lTitle <- legendTitle[l_nr]
+      }
+      # -----------------------------------------------------------
+      # x axis titles
+      # -----------------------------------------------------------
+      if (!is.null(axisTitle.x)) {
+        # copy plot counter 
+        l_nr <- i
+        # check if we have enough axis titles, if not, use last legend title
+        if (l_nr > length(axisTitle.x)) l_nr <- length(axisTitle.x)
+        # set axis title
+        labx <- axisTitle.x[l_nr]
+      }
+      if (!is.null(axisTitle.y)) laby <- axisTitle.y
+      # -----------------------------------------------------------
+      # wrap titles
+      # -----------------------------------------------------------
+      labtitle <- sjmisc::word_wrap(labtitle, breakTitleAt)
+      # wrap legend labels
+      lLabels <- sjmisc::word_wrap(lLabels, breakLegendLabelsAt)
+      # wrap legend title
+      lTitle <- sjmisc::word_wrap(lTitle, breakLegendTitleAt)
+      # ------------------------------------------------------------
+      # start plot
+      # ------------------------------------------------------------
+      baseplot <- ggplot(intdf, aes(x = x, y = y, colour = grp))
+      # ------------------------------------------------------------
+      # confidence interval?
+      # ------------------------------------------------------------
+      if (showCI) {
+        if (x_is_factor) {
+          # -------------------------------------------------
+          # for factors, we add error bars instead of
+          # continuous confidence region
+          # -------------------------------------------------
+          baseplot <- baseplot +
+            geom_errorbar(aes(ymin = lower, ymax = upper, colour = grp),
+                          width = 0,
+                          show.legend = FALSE) +
+            geom_point()
+        } else {
+          # -------------------------------------------------
+          # for continuous variables, we add  continuous 
+          # confidence region instead of error bars 
+          # -------------------------------------------------
+          baseplot <- baseplot +
+            geom_ribbon(aes(ymin = lower, ymax = upper, colour = NULL, fill = grp),
+                        alpha = fillAlpha,
+                        show.legend = FALSE)
+        }
+      }
+      baseplot <- baseplot + geom_line(size = geom.size)
+      # ------------------------------------------------------------
+      # plot value labels
+      # ------------------------------------------------------------
+      if (showValueLabels) {
+        # don't need geom_point, because point-layer already 
+        # added with x_is_factor
+        if (!x_is_factor) baseplot <- baseplot + geom_point()
+        # add value label text
         baseplot <- baseplot +
-          geom_ribbon(aes(ymin = lower, ymax = upper, colour = NULL, fill = grp),
-                      alpha = fillAlpha,
-                      show_guide = FALSE)
+          geom_text(aes(label = round(y, 1)),
+                    vjust = 1.5,
+                    show.legend = FALSE)
       }
-    }
-    baseplot <- baseplot + geom_line(size = geom.size)
-    # ------------------------------------------------------------
-    # plot value labels
-    # ------------------------------------------------------------
-    if (showValueLabels) {
-      # don't need geom_point, because point-layer already 
-      # added with x_is_factor
-      if (!x_is_factor) baseplot <- baseplot + geom_point()
-      # add value label text
+      # ------------------------------------------------------------------------------------
+      # build plot object with theme and labels
+      # ------------------------------------------------------------------------------------
       baseplot <- baseplot +
-        geom_text(aes(label = round(y, 1)),
-                  vjust = 1.5,
-                  show_guide = FALSE)
+        # set plot and axis titles
+        labs(title = labtitle, x = labx, y = laby, colour = lTitle) +
+        # set axis scale breaks
+        scale_x_continuous(limits = c(lowerLim.x, upperLim.x), breaks = gridbreaks.x) +
+        scale_y_continuous(limits = c(lowerLim.y, upperLim.y), breaks = gridbreaks.y)
+      # ---------------------------------------------------------
+      # facet grids?
+      # ---------------------------------------------------------
+      if (facet.grid) baseplot <- baseplot + facet_grid(~grp)
+      # ---------------------------------------------------------
+      # set geom colors
+      # ---------------------------------------------------------
+      baseplot <- sj.setGeomColors(baseplot, 
+                                   geom.colors, 
+                                   length(unique(stats::na.omit(intdf$grp))), 
+                                   !is.null(lLabels), 
+                                   lLabels)
+      # ---------------------------------------------------------
+      # Check whether ggplot object should be returned or plotted
+      # ---------------------------------------------------------
+      if (printPlot) print(baseplot)
+      # concatenate plot object
+      plotlist[[length(plotlist) + 1]] <- baseplot
+      dflist[[length(dflist) + 1]] <- intdf
     }
-    # ------------------------------------------------------------------------------------
-    # build plot object with theme and labels
-    # ------------------------------------------------------------------------------------
-    baseplot <- baseplot +
-      # set plot and axis titles
-      labs(title = labtitle, x = labx, y = laby, colour = lTitle) +
-      # set axis scale breaks
-      scale_x_continuous(limits = c(lowerLim.x, upperLim.x), breaks = gridbreaks.x) +
-      scale_y_continuous(limits = c(lowerLim.y, upperLim.y), breaks = gridbreaks.y)
-    # ---------------------------------------------------------
-    # facet grids?
-    # ---------------------------------------------------------
-    if (facet.grid) baseplot <- baseplot + facet_grid(~grp)
-    # ---------------------------------------------------------
-    # set geom colors
-    # ---------------------------------------------------------
-    baseplot <- sj.setGeomColors(baseplot, 
-                                 geom.colors, 
-                                 length(unique(stats::na.omit(intdf$grp))), 
-                                 !is.null(lLabels), 
-                                 lLabels)
-    # ---------------------------------------------------------
-    # Check whether ggplot object should be returned or plotted
-    # ---------------------------------------------------------
-    if (printPlot) print(baseplot)
-    # concatenate plot object
-    plotlist[[length(plotlist) + 1]] <- baseplot
-    dflist[[length(dflist) + 1]] <- intdf
-  }
-  # -------------------------------------
-  # return results
-  # -------------------------------------
-  invisible(structure(class = ""sjpint"",
-                      list(plot.list = plotlist,
-                           df.list = dflist)))
-}
-
-
-#' @importFrom stats quantile
-mv_check <- function(moderatorValues, x) {
-  mvc <- length(unique(as.vector(stats::quantile(x, na.rm = T))))
-  if (moderatorValues == ""quart"" && mvc < 3) {
-    # tell user that quart won't work
-    message(""Could not compute quartiles, too small range of moderator variable. Defaulting 'moderatorValues' to 'minmax'."")
-    moderatorValues <- ""minmax""
+    # -------------------------------------
+    # return results
+    # -------------------------------------
+    invisible(structure(class = ""sjpint"",
+                        list(plot.list = plotlist,
+                             df.list = dflist)))
   }
-  return(moderatorValues)
-}
-
-
-# get all (significant) interaction terms from model
-# the function ""getInteractionTerms"" checks if a fitted
-# model contains any interaction terms that are significant
-# at the level specified by ""plevel"". returns NULL, if model
-# contains no interaction terms or no significant interaction term.
-# else, information on model and interaction terms is returned
-#' @importFrom stats model.matrix
-getInteractionTerms <- function(fit, fun, plevel) {
-  # -----------------------------------------------------------
-  # retrieve coefficients
-  # -----------------------------------------------------------
-  coef.tab <- summary(fit)$coefficients
-  pval <- rep(0, times = nrow(coef.tab) - 1)
-  # -----------------------------------------------------------
-  # Help-function that removes AsIS I from formulas.
-  # If someone know regular expressions better than me,
-  # please provide a one-liner solution for the 3 sub commands.
-  # -----------------------------------------------------------
-  remove_I <- function(xnames) {
-    fpos <- grep(""I("", xnames, fixed = T)
-    if (length(fpos) > 0 && fpos > 0) {
-      xnames <- sub(""I("", """", xnames, fixed = T)
-      xnames <- sub("")"", """", xnames, fixed = T)
-      xnames <- sub("" * "", "":"", xnames, fixed = T)
+  
+  
+  #' @importFrom stats quantile
+  mv_check <- function(moderatorValues, x) {
+    mvc <- length(unique(as.vector(stats::quantile(x, na.rm = T))))
+    if (moderatorValues == ""quart"" && mvc < 3) {
+      # tell user that quart won't work
+      message(""Could not compute quartiles, too small range of moderator variable. Defaulting 'moderatorValues' to 'minmax'."")
+      moderatorValues <- ""minmax""
     }
-    return(xnames)
+    return(moderatorValues)
   }
-  # -----------------------------------------------------------
-  # prepare values for (generalized) linear models
-  # -----------------------------------------------------------
-  if (fun == ""lm"" || fun == ""glm"" || fun == ""plm"" || fun == ""lme"" || fun == ""gls"") {
-    # -----------------------------------------------------------
-    # retrieve amount and names of predictor variables and
-    # of dependent variable
-    # -----------------------------------------------------------
-    if (fun == ""plm"") {
-      # plm objects have different structure than (g)lm
-      depvar.label <- attr(attr(attr(fit$model, ""terms""), ""dataClasses""), ""names"")[1]
-      # retrieve model matrix
-      fitdat <- data.frame(cbind(as.vector(fit$model[, 1]), stats::model.matrix(fit)))
-    } else {
-      depvar.label <- attr(attr(fit$terms, ""dataClasses""), ""names"")[1]
-      # retrieve model matrix
-      fitdat <- data.frame(stats::model.matrix(fit))
-    }
-    # -----------------------------------------------------------
-    # retrieve p-values, without intercept
-    # -----------------------------------------------------------
-    if (ncol(coef.tab) > 3) pval <- coef.tab[-1, 4]
-    # -----------------------------------------------------------
-    # retrieve estimates, without intercept
-    # -----------------------------------------------------------
-    estimates <- coef.tab[-1, 1]
-    # -----------------------------------------------------------
-    # need to remove ""I(...)""?
-    # -----------------------------------------------------------
-    estimates.names <- names(estimates)
-    estimates.names <- remove_I(estimates.names)
-    it <- estimates.names
-    # -----------------------------------------------------------
-    # retrieve estimate of intercept
-    # -----------------------------------------------------------
-    b0 <- coef.tab[1, 1]
-    # -----------------------------------------------------------
-    # prepare values for (generalized) linear mixed effecrs models
-    # -----------------------------------------------------------
-  } else if (fun == ""lmer"" || fun == ""glmer"" || fun == ""nlmer"") {
-    # -----------------------------------------------------------
-    # retrieve amount and names of predictor variables and
-    # of dependent variable
-    # -----------------------------------------------------------
-    depvar.label <- colnames(fit@frame)[1]
-    # -----------------------------------------------------------
-    # retrieve p-values, without intercept
-    # -----------------------------------------------------------
-    pval <- get_lmerMod_pvalues(fit)[-1]
-    # -----------------------------------------------------------
-    # retrieve estimates, without intercept
+  
+  
+  # get all (significant) interaction terms from model
+  # the function ""getInteractionTerms"" checks if a fitted
+  # model contains any interaction terms that are significant
+  # at the level specified by ""plevel"". returns NULL, if model
+  # contains no interaction terms or no significant interaction term.
+  # else, information on model and interaction terms is returned
+  #' @importFrom stats model.matrix
+  getInteractionTerms <- function(fit, fun, plevel) {
     # -----------------------------------------------------------
-    estimates <- unname(lme4::fixef(fit)[-1])
-    estimates.names <- names(lme4::fixef(fit)[-1])
+    # retrieve coefficients
     # -----------------------------------------------------------
-    # retrieve model matrix with all relevant predictors
+    coef.tab <- summary(fit)$coefficients
+    pval <- rep(0, times = nrow(coef.tab) - 1)
     # -----------------------------------------------------------
-    fitdat <- stats::model.matrix(fit)
+    # Help-function that removes AsIS I from formulas.
+    # If someone know regular expressions better than me,
+    # please provide a one-liner solution for the 3 sub commands.
     # -----------------------------------------------------------
-    # need to remove ""I(...)""?
+    remove_I <- function(xnames) {
+      fpos <- grep(""I("", xnames, fixed = T)
+      if (length(fpos) > 0 && fpos > 0) {
+        xnames <- sub(""I("", """", xnames, fixed = T)
+        xnames <- sub("")"", """", xnames, fixed = T)
+        xnames <- sub("" * "", "":"", xnames, fixed = T)
+      }
+      return(xnames)
+    }
     # -----------------------------------------------------------
-    estimates.names <- remove_I(estimates.names)
-    it <- estimates.names
+    # prepare values for (generalized) linear models
     # -----------------------------------------------------------
-    # retrieve estimate of intercept
+    if (fun == ""lm"" || fun == ""glm"" || fun == ""plm"" || fun == ""lme"" || fun == ""gls"") {
+      # -----------------------------------------------------------
+      # retrieve amount and names of predictor variables and
+      # of dependent variable
+      # -----------------------------------------------------------
+      if (fun == ""plm"") {
+        # plm objects have different structure than (g)lm
+        depvar.label <- attr(attr(attr(fit$model, ""terms""), ""dataClasses""), ""names"")[1]
+        # retrieve model matrix
+        fitdat <- data.frame(cbind(as.vector(fit$model[, 1]), stats::model.matrix(fit)))
+      } else {
+        depvar.label <- attr(attr(fit$terms, ""dataClasses""), ""names"")[1]
+        # retrieve model matrix
+        fitdat <- data.frame(stats::model.matrix(fit))
+      }
+      # -----------------------------------------------------------
+      # retrieve p-values, without intercept
+      # -----------------------------------------------------------
+      if (ncol(coef.tab) > 3) pval <- coef.tab[-1, 4]
+      # -----------------------------------------------------------
+      # retrieve estimates, without intercept
+      # -----------------------------------------------------------
+      estimates <- coef.tab[-1, 1]
+      # -----------------------------------------------------------
+      # need to remove ""I(...)""?
+      # -----------------------------------------------------------
+      estimates.names <- names(estimates)
+      estimates.names <- remove_I(estimates.names)
+      it <- estimates.names
+      # -----------------------------------------------------------
+      # retrieve estimate of intercept
+      # -----------------------------------------------------------
+      b0 <- coef.tab[1, 1]
+      # -----------------------------------------------------------
+      # prepare values for (generalized) linear mixed effecrs models
+      # -----------------------------------------------------------
+    } else if (fun == ""lmer"" || fun == ""glmer"" || fun == ""nlmer"") {
+      # -----------------------------------------------------------
+      # retrieve amount and names of predictor variables and
+      # of dependent variable
+      # -----------------------------------------------------------
+      depvar.label <- colnames(fit@frame)[1]
+      # -----------------------------------------------------------
+      # retrieve p-values, without intercept
+      # -----------------------------------------------------------
+      pval <- get_lmerMod_pvalues(fit)[-1]
+      # -----------------------------------------------------------
+      # retrieve estimates, without intercept
+      # -----------------------------------------------------------
+      estimates <- unname(lme4::fixef(fit)[-1])
+      estimates.names <- names(lme4::fixef(fit)[-1])
+      # -----------------------------------------------------------
+      # retrieve model matrix with all relevant predictors
+      # -----------------------------------------------------------
+      fitdat <- stats::model.matrix(fit)
+      # -----------------------------------------------------------
+      # need to remove ""I(...)""?
+      # -----------------------------------------------------------
+      estimates.names <- remove_I(estimates.names)
+      it <- estimates.names
+      # -----------------------------------------------------------
+      # retrieve estimate of intercept
+      # -----------------------------------------------------------
+      b0 <- unname(lme4::fixef(fit)[1])
+    } else {
+      stop(""Unsupported model-class. This type of regression is not yet supported by 'sjp.int'."", call. = F)
+    }
     # -----------------------------------------------------------
-    b0 <- unname(lme4::fixef(fit)[1])
-  } else {
-    stop(""Unsupported model-class. This type of regression is not yet supported by 'sjp.int'."", call. = F)
-  }
-  # -----------------------------------------------------------
-  # find all significant interactions
-  # we start looking for significant p-values beginning
-  # with the first interaction, not the first single term!
-  # thus, the starting point is first position after all single
-  # predictor variables
-  # -----------------------------------------------------------
-  # find interaction terms, which contains a colon, in row names
-  firstit <- grep("":"", it, fixed = TRUE)[1]
-  # check whether we have any interaction terms included at all
-  if (is.null(firstit) || is.na(firstit) || firstit == 0) {
-    warning(""No interaction term found in fitted model..."", call. = FALSE)
-    return(invisible(NULL))
-  }
-  # save names of interaction predictor variables into this object
-  intnames <- c()
-  for (i in firstit:length(pval)) {
-    if (pval[i] < plevel) intnames <- c(intnames, it[i])
-  }
-  # check for any signigicant interactions, stop if nothing found
-  if (is.null(intnames)) {
-    warning(""No significant interactions found... Try to adjust 'plevel' argument."", call. = FALSE)
-    return(invisible(NULL))
-  }
-  return(list(intnames = intnames,
-              estimates = estimates,
-              estimates.names = estimates.names,
-              b0 = b0,
-              fitdat = fitdat,
-              depvar.label = depvar.label))
-}
\ No newline at end of file
+    # find all significant interactions
+    # we start looking for significant p-values beginning
+    # with the first interaction, not the first single term!
+    # thus, the starting point is first position after all single
+    # predictor variables
+    # -----------------------------------------------------------
+    # find interaction terms, which contains a colon, in row names
+    firstit <- grep("":"", it, fixed = TRUE)[1]
+    # check whether we have any interaction terms included at all
+    if (is.null(firstit) || is.na(firstit) || firstit == 0) {
+      warning(""No interaction term found in fitted model..."", call. = FALSE)
+      return(invisible(NULL))
+    }
+    # save names of interaction predictor variables into this object
+    intnames <- c()
+    for (i in firstit:length(pval)) {
+      if (pval[i] < plevel) intnames <- c(intnames, it[i])
+    }
+    # check for any signigicant interactions, stop if nothing found
+    if (is.null(intnames)) {
+      warning(""No significant interactions found... Try to adjust 'plevel' argument."", call. = FALSE)
+      return(invisible(NULL))
+    }
+    return(list(intnames = intnames,
+                estimates = estimates,
+                estimates.names = estimates.names,
+                b0 = b0,
+                fitdat = fitdat,
+                depvar.label = depvar.label))
+  }
\ No newline at end of file

---FILE: R/sjPlotLinreg.R---
@@ -5,7 +5,7 @@ utils::globalVariables(c(""vars"", ""Beta"", ""xv"", ""lower"", ""upper"", ""stdbeta"", ""p"",
 #' @title Plot estimates or predicted values of linear models
 #' @name sjp.lm
 #'
-#' @seealso \href{http://www.strengejacke.de/sjPlot/sjp.lm}{sjPlot manual: sjp.lm} for 
+#' @seealso \href{http://www.strengejacke.de/sjPlot/sjp.lm}{sjPlot manual: sjp.lm} for
 #'            more details and examples of this function; use \code{\link{sjp.poly}}
 #'            to see which polynomial degree fits best for possible polynomial terms.
 #'
@@ -21,7 +21,7 @@ utils::globalVariables(c(""vars"", ""Beta"", ""xv"", ""lower"", ""upper"", ""stdbeta"", ""p"",
 #'            \item{\code{type = ""pred""}}{regression lines (slopes) with confidence intervals for each single predictor of the fitted model are plotted, i.e. all predictors of the fitted model are extracted and for each of them, the linear relationship is plotted against the response variable.}
 #'            \item{\code{type = ""resid""}}{is similar to the \code{type = ""pred""} option, however, each predictor is plotted against the residuals (instead of response).}
 #'            \item{\code{type = ""resp""}}{the predicted values of the response for each observation is plotted, which mostly results in a single linear line.}
-#'            \item{\code{type = ""eff""}}{computes the marginal effects for all predictors, using the \code{\link[effects]{allEffects}} function. I.e. for each predictor, the predicted values towards the response are plotted, with all remaining co-variates set to the mean. Due to possible different scales of predictors, a faceted plot is printed (instead of plotting all lines in one plot). This function accepts following argument: \code{fit}, \code{title}, \code{geom.size}, \code{showCI} and \code{printPlot}.}
+#'            \item{\code{type = ""eff""}}{computes the marginal effects for all predictors, using the \code{\link[effects]{allEffects}} function. I.e. for each predictor, the predicted values towards the response are plotted, with all remaining co-variates set to the mean. Due to possible different scales of predictors, a faceted plot is printed (instead of plotting all lines in one plot). This function accepts following argument: \code{fit}, \code{title}, \code{geom.size}, \code{remove.estimates}, \code{showCI} and \code{printPlot}.}
 #'            \item{\code{type = ""poly""}}{plots the marginal effects of polynomial terms in \code{fit}, using the \code{\link[effects]{effect}} function, but only for a selected polynomial term, which is specified with \code{poly.term}. This function helps undertanding the effect of polynomial terms by plotting the curvilinear relationships of response and quadratic, cubic etc. terms. This function accepts following argument: \code{fit}, \code{poly.term}, \code{geom.colors}, \code{geom.size}, \code{axisTitle.x}, \code{showCI} and \code{printPlot}.}
 #'            \item{\code{type = ""ma""}}{checks model assumptions. Please note that only three arguments are relevant: \code{fit}, \code{completeDiagnostic} and \code{showOriginalModelOnly}. All other arguments are ignored.}
 #'            \item{\code{type = ""vif""}}{Variance Inflation Factors (check for multicollinearity) are plotted. As a rule of thumb, values below 5 are considered as good and indicate no multicollinearity, values between 5 and 10 may be tolerable. Values greater than 10 are not acceptable and indicate multicollinearity between model's predictors.}
@@ -49,13 +49,13 @@ utils::globalVariables(c(""vars"", ""Beta"", ""xv"", ""lower"", ""upper"", ""stdbeta"", ""p"",
 #'            \item Only used if fitted model has only one predictor and \code{type = ""lm""}.
 #'            \item If you use the \code{\link[sjmisc]{read_spss}} and \code{\link[sjmisc]{get_label}} functions, you receive a character vector with variable label strings. You can use it like this: \code{axisLabels.x = get_label(efc)['quol_5']}
 #'          }
-#' @param axisLabels.y labels or names of the predictor variables (independent vars). Must 
-#'          be a character vector of same length as independent variables. The labels 
+#' @param axisLabels.y labels or names of the predictor variables (independent vars). Must
+#'          be a character vector of same length as independent variables. The labels
 #'          may also be passed as list object; they will be coerced to character vector automatically.
 #' @param showAxisLabels.y logical, whether labels of independent variables should be shown or not.
 #' @param axisTitle.x title for the x-axis. Default is \code{""Estimates""}.
 #' @param geom.colors user defined color palette for geoms. If \code{group.estimates}
-#'          is \emph{not} specified, must either be vector with two color values or a specific 
+#'          is \emph{not} specified, must either be vector with two color values or a specific
 #'          color palette code (see 'Note' in \code{\link{sjp.grpfrq}}). Else, if
 #'          \code{group.estimates} is specified, \code{geom.colors} must be a vector
 #'          of same length as groups. See 'Examples'.
@@ -65,40 +65,40 @@ utils::globalVariables(c(""vars"", ""Beta"", ""xv"", ""lower"", ""upper"", ""stdbeta"", ""p"",
 #' @param group.estimates numeric or character vector, indicating a group identifier for
 #'          each estimate. Dots and confidence intervals of estimates are coloured
 #'          according to their group association. See 'Examples'.
-#' @param remove.estimates character vector with coefficient names that indicate 
-#'          which estimates should be removed from the plot. 
-#'          \code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default 
+#' @param remove.estimates character vector with coefficient names that indicate
+#'          which estimates should be removed from the plot.
+#'          \code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default
 #'          is \code{NULL}, i.e. all estimates are printed.
 #' @param coord.flip logical, if \code{TRUE} (default), predictors are plotted along the y-axis and estimate
 #'          values are plotted on the x-axis.
 #' @param showValueLabels logical, whether value labels should be plotted to each dot or not.
 #' @param labelDigits amount of digits for rounding the estimates (see \code{showValueLabels}).
 #'          Default is 2, i.e. estimates have 2 digits after decimal point.
-#' @param showPValueLabels logical, whether the significance level of each coefficient 
+#' @param showPValueLabels logical, whether the significance level of each coefficient
 #'          should be appended to values or not.
 #' @param showModelSummary logical, if \code{TRUE}, a summary of the regression model with
 #'          Intercept, R-squared, F-Test and AIC-value is printed to the lower right corner
 #'          of the plot.
 #' @param showCI logical, if \code{TRUE} (default), a confidence region for the regression line
-#'          will be plotted. Only applies if \code{type = ""lm""} and fitted model has 
+#'          will be plotted. Only applies if \code{type = ""lm""} and fitted model has
 #'          only one predictor, or if \code{type = ""pred""} or \code{type = ""resid""}.
-#' @param showScatterPlot logical, if \code{TRUE} (default), a scatter plot of 
+#' @param showScatterPlot logical, if \code{TRUE} (default), a scatter plot of
 #'          response and predictor values for each predictor of \code{fit} is plotted.
 #'          Only applies if \code{type = ""lm""} and fitted model has only one predictor,
 #'          or if \code{type = ""pred""} or \code{type = ""resid""}.
 #' @param showOriginalModelOnly logical, if \code{TRUE} (default), only model assumptions of
-#'          \code{fit} are plotted. if \code{FALSE}, model assumptions of an updated 
+#'          \code{fit} are plotted. if \code{FALSE}, model assumptions of an updated
 #'          model where outliers are automatically excluded are also plotted.
 #'          Only applies if \code{type = ""ma""}.
 #' @param completeDiagnostic logical, if \code{TRUE}, additional tests are performed. Default is \code{FALSE}
 #'          Only applies if \code{type = ""ma""}.
-#'          
+#'
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjp.lmer
 #' @inheritParams sjp.aov1
-#'          
+#'
 #' @references Gelman A (2008) ""Scaling regression inputs by dividing by two standard deviations."" \emph{Statistics in Medicine 27: 28652873.} \url{http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf}
-#'          
+#'
 #' @return Depending on the \code{type}, in most cases (insisibily)
 #'           returns the ggplot-object with the complete plot (\code{plot})
 #'           as well as the data frame that was used for setting up the
@@ -116,7 +116,7 @@ utils::globalVariables(c(""vars"", ""Beta"", ""xv"", ""lower"", ""upper"", ""stdbeta"", ""p"",
 #' sjp.lm(fit, gridBreaksAt = 2)
 #'
 #' # plot estimates with CI
-#' # and with narrower tick marks 
+#' # and with narrower tick marks
 #' # (because ""gridBreaksAt"" was not specified)
 #' sjp.lm(fit)
 #'
@@ -162,25 +162,25 @@ utils::globalVariables(c(""vars"", ""Beta"", ""xv"", ""lower"", ""upper"", ""stdbeta"", ""p"",
 #' # --------------------------
 #' library(sjmisc)
 #' data(efc)
-#' fit <- lm(barthtot ~ c160age + e17age + c12hour + e16sex + c161sex + c172code, 
+#' fit <- lm(barthtot ~ c160age + e17age + c12hour + e16sex + c161sex + c172code,
 #'           data = efc)
 #'
 #' # order estimates according to coefficient's order
-#' sjp.lm(fit, 
-#'        group.estimates = c(1, 1, 2, 3, 3, 4), 
+#' sjp.lm(fit,
+#'        group.estimates = c(1, 1, 2, 3, 3, 4),
 #'        geom.colors = c(""green"", ""red"", ""blue"", ""grey""),
 #'        sort.est = FALSE)
-#'           
-#' fit <- lm(barthtot ~ c160age + c12hour + e17age+ c161sex + c172code + e16sex, 
+#'
+#' fit <- lm(barthtot ~ c160age + c12hour + e17age+ c161sex + c172code + e16sex,
 #'           data = efc)
 #'
 #' # force order of estimates according to group assignment
-#' sjp.lm(fit, 
-#'        group.estimates = c(1, 2, 1, 3, 4, 3), 
+#' sjp.lm(fit,
+#'        group.estimates = c(1, 2, 1, 3, 4, 3),
 #'        geom.colors = c(""green"", ""red"", ""blue"", ""grey""),
 #'        sort.est = TRUE)
-#' 
-#' 
+#'
+#'
 #' # --------------------------
 #' # plotting polynomial terms
 #' # --------------------------
@@ -199,8 +199,8 @@ utils::globalVariables(c(""vars"", ""Beta"", ""xv"", ""lower"", ""upper"", ""stdbeta"", ""p"",
 #'           data = efc)
 #' # plot marginal effects of polynomial term
 #' sjp.lm(fit, type = ""poly"", poly.term = ""e17age"")
-#' 
-#' 
+#'
+#'
 #' library(splines)
 #' # fit new model with ""splines""-package, ""bs""
 #' fit <- lm(tot_sc_e ~ c12hour + e42dep + bs(e17age, 3), data = efc)
@@ -304,7 +304,7 @@ sjp.lm <- function(fit,
   if (type == ""resp"") {
     return(invisible(sjp.lm.response.pred(fit,
                                           geom.colors,
-                                          showCI, 
+                                          showCI,
                                           showLoess,
                                           showLoessCI,
                                           printPlot)))
@@ -315,13 +315,14 @@ sjp.lm <- function(fit,
                                  geom.colors,
                                  geom.size,
                                  axisTitle.x,
-                                 showCI, 
+                                 showCI,
                                  printPlot)))
   }
   if (type == ""eff"") {
     return(invisible(sjp.lm.eff(fit,
                                 title,
                                 geom.size,
+                                remove.estimates,
                                 showCI,
                                 printPlot)))
   }
@@ -470,7 +471,7 @@ sjp.lm <- function(fit,
   # have factors with different levels, which appear as
   # ""multiple predictors"", but are only one variable
   # --------------------------------------------------------
-  if (is.null(axisLabels.y) || length(axisLabels.y) < length(row.names(betas))) 
+  if (is.null(axisLabels.y) || length(axisLabels.y) < length(row.names(betas)))
     axisLabels.y <- row.names(betas)
   # --------------------------------------------------------
   # define sorting criteria. the values on the x-axis are being sorted
@@ -538,7 +539,7 @@ sjp.lm <- function(fit,
     # Print p-values. With vertical adjustment, so they don't overlap with the errorbars
     geom_text(aes(label = p, y = Beta),
               vjust = -0.8,
-              show_guide = FALSE) +
+              show.legend = FALSE) +
     # print point
     geom_point(size = geom.size) +
     # Intercept-line
@@ -848,27 +849,32 @@ sjp.lm.ma <- function(linreg, showOriginalModelOnly=TRUE, completeDiagnostic=FAL
     # ol <- car::outlierTest(model)
     # vars <- as.numeric(names(ol$p))
     vars <- as.numeric(names(which(car::outlierTest(model, cutoff = Inf, n.max = Inf)$bonf.p < 1)))
-    # retrieve variable numbers of outliers
-    # update model by removing outliers
-    dummymodel <- update(model, subset = -c(vars))
-    # retrieve new r2
-    dummyrs <- summary(dummymodel)$r.squared
-    # decrease maximum loops
-    maxcnt <- maxcnt - 1
-    # check whether r2 of updated model is lower
-    # than previous r2 or if we have already all loop-steps done,
-    # stop loop
-    if (dummyrs < rs || maxcnt < 1) {
+    # do we have any outliers?
+    if (sjmisc::is_empty(vars)) {
       loop <- FALSE
     } else {
-      # else copy new model, which is the better one (according to r2)
-      model <- dummymodel
-      # and get new r2
-      rs <- dummyrs
-      # count removed cases
-      removedcases <- removedcases + length(vars)
-      # add outliers to final return value
-      outlier <- c(outlier, vars)
+      # retrieve variable numbers of outliers
+      # update model by removing outliers
+      dummymodel <- update(model, subset = -c(vars))
+      # retrieve new r2
+      dummyrs <- summary(dummymodel)$r.squared
+      # decrease maximum loops
+      maxcnt <- maxcnt - 1
+      # check whether r2 of updated model is lower
+      # than previous r2 or if we have already all loop-steps done,
+      # stop loop
+      if (dummyrs < rs || maxcnt < 1) {
+        loop <- FALSE
+      } else {
+        # else copy new model, which is the better one (according to r2)
+        model <- dummymodel
+        # and get new r2
+        rs <- dummyrs
+        # count removed cases
+        removedcases <- removedcases + length(vars)
+        # add outliers to final return value
+        outlier <- c(outlier, vars)
+      }
     }
   }
   # ---------------------------------
@@ -919,7 +925,7 @@ sjp.lm.ma <- function(linreg, showOriginalModelOnly=TRUE, completeDiagnostic=FAL
     plot.list[[length(plot.list) + 1]] <- p1
     # print plot
     print(p1)
-  } 
+  }
   # ---------------------------------
   # Print non-normality of residuals both of original and updated model
   # Distribution should look like normal curve
@@ -1018,16 +1024,16 @@ sjp.lm.ma <- function(linreg, showOriginalModelOnly=TRUE, completeDiagnostic=FAL
     # Plot residuals against predictors
     # ---------------------------------
     sjp.setTheme(theme = ""scatterw"")
-    p1 <- sjp.reglin(linreg, 
-                     title = ""Relationship of residuals against predictors (original model) (if scatterplots show a pattern, relationship may be nonlinear and model needs to be modified accordingly"", 
-                     breakTitleAt = 60, 
+    p1 <- sjp.reglin(linreg,
+                     title = ""Relationship of residuals against predictors (original model) (if scatterplots show a pattern, relationship may be nonlinear and model needs to be modified accordingly"",
+                     breakTitleAt = 60,
                      useResiduals = T)$plot.list
     # save plot
     plot.list <- c(plot.list, p1)
     if (modelOptmized) {
-      p1 <- sjp.reglin(model, 
-                       title = ""Relationship of residuals against predictors (updated model) (if scatterplots show a pattern, relationship may be nonlinear and model needs to be modified accordingly"", 
-                       breakTitleAt = 60, 
+      p1 <- sjp.reglin(model,
+                       title = ""Relationship of residuals against predictors (updated model) (if scatterplots show a pattern, relationship may be nonlinear and model needs to be modified accordingly"",
+                       breakTitleAt = 60,
                        useResiduals = T)
       # save plot
       plot.list <- c(plot.list, p1)
@@ -1199,7 +1205,7 @@ sjp.lm.poly <- function(fit,
                         geom.colors,
                         geom.size,
                         axisTitle.x,
-                        showCI, 
+                        showCI,
                         printPlot) {
   # check size argument
   if (is.null(geom.size)) geom.size <- .8
@@ -1279,16 +1285,16 @@ sjp.lm.poly <- function(fit,
   # from polynomial term, predicted response
   # and lower/upper ci
   # ------------------------
-  mydat <- data.frame(x = eff$x[[poly.term]], 
-                      y = eff$fit, 
-                      lower = eff$lower, 
+  mydat <- data.frame(x = eff$x[[poly.term]],
+                      y = eff$fit,
+                      lower = eff$lower,
                       upper = eff$upper)
   # base plot
   polyplot <- ggplot(mydat, aes(x = x, y = y))
   # show confidence region?
   if (showCI) polyplot <- polyplot + geom_ribbon(aes(ymin = lower, ymax = upper), alpha = .15)
   # plot predicted effect of polynomial term
-  polyplot <- polyplot + 
+  polyplot <- polyplot +
     geom_line(colour = geom.colors[1], size = geom.size) +
     labs(x = axisTitle.x, y = ""Response"")
   # print plot
@@ -1303,6 +1309,7 @@ sjp.lm.poly <- function(fit,
 sjp.lm.eff <- function(fit,
                        title,
                        geom.size,
+                       remove.estimates,
                        showCI,
                        printPlot) {
   # ------------------------
@@ -1335,12 +1342,21 @@ sjp.lm.eff <- function(fit,
   # which title?
   if (is.null(title)) title <- ""Marginal effects of model predictors""
   # ------------------------
-  # retrieve model matrix and all terms, 
+  # retrieve model matrix and all terms,
   # excluding intercept
   # ------------------------
   mm <- stats::model.matrix(fit)
   all.terms <- colnames(stats::model.matrix(fit))[-1]
   # ------------------------
+  # remove setimates?
+  # ------------------------
+  if (!is.null(remove.estimates)) {
+    remcols <- match(remove.estimates, all.terms)
+    # remember old rownames
+    if (!sjmisc::is_empty(remcols))
+      all.terms <- all.terms[-remcols]
+  }
+  # ------------------------
   # prepare getting unique values of predictors,
   # which are passed to the allEffects-function
   # ------------------------
@@ -1373,15 +1389,15 @@ sjp.lm.eff <- function(fit,
       # from polynomial term, predicted response
       # and lower/upper ci
       # ------------------------
-      tmp <- data.frame(x = eff[[i]]$x[[t]], 
-                        y = eff[[i]]$fit, 
-                        lower = eff[[i]]$lower, 
+      tmp <- data.frame(x = eff[[i]]$x[[t]],
+                        y = eff[[i]]$fit,
+                        lower = eff[[i]]$lower,
                         upper = eff[[i]]$upper,
                         grp = t)
       # make sure x is numeric
       tmp$x <- sjmisc::to_value(tmp$x, keep.labels = F)
       # do we already have data?
-      if (nrow(mydat) > 0) 
+      if (nrow(mydat) > 0)
         mydat <- rbind(mydat, tmp)
       else
         # else init data frame

---FILE: R/sjPlotLinregMultiple.R---
@@ -408,7 +408,7 @@ sjp.lmm <- function(...,
     geom_text(aes(label = p, y = upper), 
               position = position_dodge(width = -geom.spacing), 
               hjust = -0.1,
-              show_guide = FALSE) +
+              show.legend = FALSE) +
     # --------------------------------------------------------
     # Intercept-line
     # --------------------------------------------------------

---FILE: R/sjPlotOdds.R---
@@ -228,6 +228,7 @@ sjp.glm <- function(fit,
                                 show.ci,
                                 type = ""prob"",
                                 geom.size,
+                                remove.estimates,
                                 facet.grid,
                                 printPlot)))
   }
@@ -236,6 +237,7 @@ sjp.glm <- function(fit,
                                 show.ci,
                                 type = ""eff"",
                                 geom.size,
+                                remove.estimates,
                                 facet.grid,
                                 printPlot)))
   }
@@ -584,6 +586,7 @@ sjp.glm.pc <- function(fit,
                        show.ci,
                        type,
                        geom.size,
+                       remove.estimates,
                        facet.grid,
                        printPlot) {
   # check size argument
@@ -601,6 +604,15 @@ sjp.glm.pc <- function(fit,
   # retrieve term names, so we find the estimates in the
   # coefficients list
   fit.term.names <- names(attr(fit$terms, ""dataClasses""))[-1]
+  # ------------------------
+  # remove estimates?
+  # ------------------------
+  if (!is.null(remove.estimates)) {
+    remcols <- match(remove.estimates, fit.term.names)
+    # remember old rownames
+    if (!sjmisc::is_empty(remcols))
+      fit.term.names <- fit.term.names[-remcols]
+  }
   # ----------------------------
   # loop through all coefficients
   # ----------------------------

---FILE: R/sjPlotOddsMultiple.R---
@@ -370,7 +370,7 @@ sjp.glmm <- function(...,
     geom_text(aes(label = p, y = upper), 
               position = position_dodge(width = -geom.spacing), 
               hjust = -0.1,
-              show_guide = FALSE) +
+              show.legend = FALSE) +
     # Intercept-line
     geom_hline(yintercept = 1, 
                linetype = interceptLineType, 

---FILE: R/sjPlotPropTable.R---
@@ -241,11 +241,7 @@ sjp.xtab <- function(x,
   # create cross table for stats, summary etc.
   # and weight variable
   #---------------------------------------------------
-  if (is.null(weightBy)) {
-    ftab <- table(x, grp)
-  } else {
-    ftab <- round(xtabs(weightBy ~ x + grp), 0)
-  }
+  ftab <- crosstabsum(x, grp, weightBy)
   # -----------------------------------------------
   # create proportional table so we have the percentage
   # values that should be used as y-value for the bar charts
@@ -594,7 +590,7 @@ sjp.xtab <- function(x,
     baseplot <- baseplot + 
       geom_point(size = lineDotSize, 
                  shape = 21, 
-                 show_guide = FALSE)
+                 show.legend = FALSE)
   }
   # ------------------------------------------
   # check whether table summary should be printed

---FILE: R/sjPlotSetTheme.R---
@@ -185,7 +185,6 @@
 #'              colour = ""black"")}
 #' 
 #' @import ggplot2
-#' @importFrom grid unit
 #' @importFrom scales brewer_pal grey_pal
 #' @export
 sjp.setTheme <- function(# base theme
@@ -313,7 +312,7 @@ sjp.setTheme <- function(# base theme
     axis.title.x.vjust <- -1
     axis.title.y.vjust <- 1.5
     title.vjust <- 1.75
-    plot.margins <- grid::unit(c(1, .5, 1, 0.5), ""cm"")
+    plot.margins <- unit(c(1, .5, 1, 0.5), ""cm"")
     message(""Theme '538' looks better with panel margins. You may want to use argument 'expand.grid = TRUE' in sjp-functions."")
   }  
   # ----------------------------------------  
@@ -349,7 +348,7 @@ sjp.setTheme <- function(# base theme
     axis.title.x.vjust <- -1
     axis.title.y.vjust <- 1.5
     title.vjust <- 1.75
-    plot.margins <- grid::unit(c(1, .5, 1, 0.5), ""cm"")
+    plot.margins <- unit(c(1, .5, 1, 0.5), ""cm"")
   }  
   # ----------------------------------------  
   # check for scatter, a theme with crossed
@@ -379,7 +378,7 @@ sjp.setTheme <- function(# base theme
     axis.title.x.vjust <- -1
     axis.title.y.vjust <- 1.5
     title.vjust <- 1.75
-    plot.margins <- grid::unit(c(1, .5, 1, 0.5), ""cm"")
+    plot.margins <- unit(c(1, .5, 1, 0.5), ""cm"")
   }  
   if (!is.null(theme) && theme == ""blues"") {
     base <- theme_bw()
@@ -405,7 +404,7 @@ sjp.setTheme <- function(# base theme
     axis.title.x.vjust <- -1
     axis.title.y.vjust <- 1.5
     title.vjust <- 1.75
-    plot.margins <- grid::unit(c(1, .5, 1, 0.5), ""cm"")
+    plot.margins <- unit(c(1, .5, 1, 0.5), ""cm"")
   }  
   if (!is.null(theme) && theme == ""greens"") {
     base <- theme_bw()
@@ -432,7 +431,7 @@ sjp.setTheme <- function(# base theme
     axis.title.x.vjust <- -1
     axis.title.y.vjust <- 1.5
     title.vjust <- 1.75
-    plot.margins <- grid::unit(c(1, .5, 1, 0.5), ""cm"")
+    plot.margins <- unit(c(1, .5, 1, 0.5), ""cm"")
   }  
   # ----------------------------------------  
   # set defaults for geom label colors
@@ -590,7 +589,7 @@ sjp.setTheme <- function(# base theme
     # ----------------------------------------
     if (!is.null(legend.item.size)) {
       sjtheme <- sjtheme +
-        theme(legend.key.size = grid::unit(legend.item.size, ""cm""))
+        theme(legend.key.size = unit(legend.item.size, ""cm""))
     }
     # ----------------------------------------
     # set axis line colors, if defined
@@ -611,11 +610,11 @@ sjp.setTheme <- function(# base theme
     }
     if (!is.null(axis.tickslen)) {
       sjtheme <- sjtheme +
-        theme(axis.ticks.length = grid::unit(axis.tickslen, ""cm""))
+        theme(axis.ticks.length = unit(axis.tickslen, ""cm""))
     }
     if (!is.null(axis.ticksmar)) {
       sjtheme <- sjtheme +
-        theme(axis.ticks.margin = grid::unit(axis.ticksmar, ""cm""))
+        theme(axis.ticks.margin = unit(axis.ticksmar, ""cm""))
     }
     # ----------------------------------------
     # set plot colors, if defined
@@ -768,7 +767,7 @@ sj.theme_geoms <- function(geom.alpha,
 sj.setGeomColors <- function(plot, 
                              geom.colors, 
                              pal.len, 
-                             show.guide = TRUE, 
+                             show.legend = TRUE, 
                              labels = NULL,
                              reverse.colors = FALSE) {
   # ---------------------------------------------------------
@@ -781,7 +780,7 @@ sj.setGeomColors <- function(plot,
   # dummy function for setting legend labels and geom-colors
   # ---------------------------------------------------------
   usenormalscale <- function(plot, geom.colors, labels) {
-    if (!show.guide) {
+    if (!show.legend) {
       plot <- plot + 
         scale_fill_manual(values = geom.colors, guide = FALSE) +
         scale_colour_manual(values = geom.colors, guide = FALSE) +
@@ -799,7 +798,7 @@ sj.setGeomColors <- function(plot,
   # geom-colors
   # ---------------------------------------------------------
   uselegendscale <- function(plot, labels) {
-    if (!show.guide) {
+    if (!show.legend) {
       plot <- plot + 
         scale_fill_discrete(guide = FALSE) +
         scale_colour_discrete(guide = FALSE) +

---FILE: README.md---
@@ -43,8 +43,10 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 ### Changelog of development build 1.8.4-9
 
 #### General
+* Fixed many issues related to the latest update of [ggplot2](https://cran.r-project.org/package=ggplot2).
 * Argument `show.se` is now deprecated. Use `show.ci` instead.
 * Redesign of computation of frequency tables for `sjp.frq` and `sjt.frq`, being more robust and generally working with labelled, non-labelled, numeric, character vectors and factors.
+* Redesign of computation of frequency tables for `sjp.grpfrq` and `sjt.xtab`, being more robust and generally working with labelled, non-labelled, numeric, character vectors and factors.
 * Better automatic handling of variable and value labels that are used for labelling plot axes and titles or table columns.
 
 #### Changes to functions

---FILE: man/sjc.qclus.Rd---
@@ -78,9 +78,7 @@ no title is printed.}
 Axis labels will be automatically detected, when data was either imported 
 with \code{\link[sjmisc]{read_spss}} or has named factor levels 
 (see 'Examples'). Else, specifiy argument like this:
-\code{axisLabels.x = c(""Label1"", ""Label2"", ""Label3"")}.
-The labels may also be passed as \code{\link{list}} object. They will be coerced
-to character vector automatically.}
+\code{axisLabels.x = c(""Label1"", ""Label2"", ""Label3"")}.}
 
 \item{axisTitle.x}{title for the x-axis.}
 

---FILE: man/sjp.aov1.Rd---
@@ -87,7 +87,7 @@ to each dot or not.}
 \item{labelDigits}{amount of digits for rounding the estimates (see \code{showValueLabels}).
 Default is 2, i.e. estimates have 2 digits after decimal point.}
 
-\item{showPValueLabels}{logical, whether the significance level of each coefficient 
+\item{showPValueLabels}{logical, whether the significance level of each coefficient
 should be appended to values or not.}
 
 \item{showModelSummary}{logical, if \code{TRUE}, a summary of the anova model with 

---FILE: man/sjp.frq.Rd---
@@ -71,9 +71,7 @@ adjusted depending on the plot type.}
 Axis labels will be automatically detected, when data was either imported 
 with \code{\link[sjmisc]{read_spss}} or has named factor levels 
 (see 'Examples'). Else, specifiy argument like this:
-\code{axisLabels.x = c(""Label1"", ""Label2"", ""Label3"")}.
-The labels may also be passed as \code{\link{list}} object. They will be coerced
-to character vector automatically.}
+\code{axisLabels.x = c(""Label1"", ""Label2"", ""Label3"")}.}
 
 \item{interactionVarLabels}{a character vector with labels for the x-axis breaks 
 when having interaction variables included. These labels replace the 

---FILE: man/sjp.glm.Rd---
@@ -37,8 +37,8 @@ Use \code{NULL} to automatically detect variable names that will be used as titl
 (see \code{\link[sjmisc]{set_label}}) for details). If \code{title = """"},
 no title is printed.}
 
-\item{axisLabels.y}{labels or names of the predictor variables (independent vars). Must 
-be a character vector of same length as independent variables. The labels 
+\item{axisLabels.y}{labels or names of the predictor variables (independent vars). Must
+be a character vector of same length as independent variables. The labels
 may also be passed as list object; they will be coerced to character vector automatically.}
 
 \item{axisTitle.x}{string; title for the x-axis.}
@@ -75,9 +75,9 @@ if argument \code{type = ""bars""}. Default value is \code{FALSE}.}
 
 \item{interceptLineColor}{color of the intercept line. Default value is \code{""grey70""}.}
 
-\item{remove.estimates}{character vector with coefficient names that indicate 
-which estimates should be removed from the plot. 
-\code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default 
+\item{remove.estimates}{character vector with coefficient names that indicate
+which estimates should be removed from the plot.
+\code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default
 is \code{NULL}, i.e. all estimates are printed.}
 
 \item{coord.flip}{logical, if \code{TRUE} (default), predictors are plotted along the y-axis and estimate
@@ -95,7 +95,7 @@ function call is interrupted and no plot printed.}
 \item{labelDigits}{amount of digits for rounding the estimates (see \code{showValueLabels}).
 Default is 2, i.e. estimates have 2 digits after decimal point.}
 
-\item{showPValueLabels}{logical, whether the significance level of each coefficient 
+\item{showPValueLabels}{logical, whether the significance level of each coefficient
 should be appended to values or not.}
 
 \item{showModelSummary}{logical, if \code{TRUE}, a summary of the regression model with

---FILE: man/sjp.glmer.Rd---
@@ -98,9 +98,9 @@ the grid has the same scale range.}
 
 \item{interceptLineColor}{color of the intercept line. Default value is \code{""grey70""}.}
 
-\item{remove.estimates}{character vector with coefficient names that indicate 
-which estimates should be removed from the plot. 
-\code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default 
+\item{remove.estimates}{character vector with coefficient names that indicate
+which estimates should be removed from the plot.
+\code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default
 is \code{NULL}, i.e. all estimates are printed.}
 
 \item{showValueLabels}{logical, whether estimate values should be plotted to each dot or not.}

---FILE: man/sjp.glmm.Rd---
@@ -35,8 +35,8 @@ Default is \code{""p-level""}. Only applies if \code{usePShapes = TRUE}.}
 labels for the dependent variables are provided (see \code{labelDependentVariables}).
 Default is \code{""Model""}.}
 
-\item{axisLabels.y}{labels or names of the predictor variables (independent vars). Must 
-be a character vector of same length as independent variables. The labels 
+\item{axisLabels.y}{labels or names of the predictor variables (independent vars). Must
+be a character vector of same length as independent variables. The labels
 may also be passed as list object; they will be coerced to character vector automatically.}
 
 \item{axisTitle.x}{string, title for the x axis.}
@@ -82,9 +82,9 @@ legend is plotted. Default is \code{FALSE}.}
 
 \item{interceptLineColor}{color of the intercept line. Default value is \code{""grey70""}.}
 
-\item{remove.estimates}{character vector with coefficient names that indicate 
-which estimates should be removed from the plot. 
-\code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default 
+\item{remove.estimates}{character vector with coefficient names that indicate
+which estimates should be removed from the plot.
+\code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default
 is \code{NULL}, i.e. all estimates are printed.}
 
 \item{coord.flip}{logical, if \code{TRUE} (default), predictors are plotted along the y-axis and estimate

---FILE: man/sjp.grpfrq.Rd---
@@ -81,9 +81,7 @@ no title is printed.}
 Axis labels will be automatically detected, when data was either imported 
 with \code{\link[sjmisc]{read_spss}} or has named factor levels 
 (see 'Examples'). Else, specifiy argument like this:
-\code{axisLabels.x = c(""Label1"", ""Label2"", ""Label3"")}.
-The labels may also be passed as \code{\link{list}} object. They will be coerced
-to character vector automatically.}
+\code{axisLabels.x = c(""Label1"", ""Label2"", ""Label3"")}.}
 
 \item{interactionVarLabels}{a character vector with labels for the x-axis breaks
 when having interaction variables included.
@@ -244,11 +242,8 @@ Plot grouped or stacked frequencies of variables
 # histrogram with EUROFAMCARE sample dataset
 library(sjmisc)
 data(efc)
-efc.val <- get_labels(efc)
-efc.var <- get_label(efc)
 sjp.grpfrq(efc$e17age,
            efc$e16sex,
-           title = efc.var['e17age'],
            type = ""hist"",
            showValueLabels = FALSE,
            showMeanIntercept = TRUE)
@@ -270,15 +265,6 @@ sjp.grpfrq(efc$e42dep,
 sjp.grpfrq(efc$e17age,
            efc$e42dep,
            interactionVar = efc$e16sex,
-           title = paste(efc.var['e17age'], 
-                         ""by"", 
-                         efc.var['e42dep'], 
-                         ""and"", 
-                         efc.var['e16sex']),
-           axisLabels.x = efc.val[['e17age']],
-           interactionVarLabels = efc.val[['e16sex']],
-           legendTitle = efc.var['e42dep'],
-           legendLabels = efc.val[['e42dep']],
            type = ""box"")
 
 # Grouped bar plot ranging from 1 to 28 (though scale starts with 7)

---FILE: man/sjp.lm.Rd---
@@ -49,8 +49,8 @@ no title is printed.}
   \item If you use the \code{\link[sjmisc]{read_spss}} and \code{\link[sjmisc]{get_label}} functions, you receive a character vector with variable label strings. You can use it like this: \code{axisLabels.x = get_label(efc)['quol_5']}
 }}
 
-\item{axisLabels.y}{labels or names of the predictor variables (independent vars). Must 
-be a character vector of same length as independent variables. The labels 
+\item{axisLabels.y}{labels or names of the predictor variables (independent vars). Must
+be a character vector of same length as independent variables. The labels
 may also be passed as list object; they will be coerced to character vector automatically.}
 
 \item{legendTitle}{title of the plot legend, as string.}
@@ -64,7 +64,7 @@ By default, the limits range from the lowest confidence interval to the
 highest, so plot has maximum zoom.}
 
 \item{geom.colors}{user defined color palette for geoms. If \code{group.estimates}
-is \emph{not} specified, must either be vector with two color values or a specific 
+is \emph{not} specified, must either be vector with two color values or a specific
 color palette code (see 'Note' in \code{\link{sjp.grpfrq}}). Else, if
 \code{group.estimates} is specified, \code{geom.colors} must be a vector
 of same length as groups. See 'Examples'.}
@@ -79,9 +79,9 @@ of same length as groups. See 'Examples'.}
 each estimate. Dots and confidence intervals of estimates are coloured
 according to their group association. See 'Examples'.}
 
-\item{remove.estimates}{character vector with coefficient names that indicate 
-which estimates should be removed from the plot. 
-\code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default 
+\item{remove.estimates}{character vector with coefficient names that indicate
+which estimates should be removed from the plot.
+\code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default
 is \code{NULL}, i.e. all estimates are printed.}
 
 \item{breakTitleAt}{determines how many chars of the plot title are displayed in
@@ -101,21 +101,21 @@ values are plotted on the x-axis.}
 \item{labelDigits}{amount of digits for rounding the estimates (see \code{showValueLabels}).
 Default is 2, i.e. estimates have 2 digits after decimal point.}
 
-\item{showPValueLabels}{logical, whether the significance level of each coefficient 
+\item{showPValueLabels}{logical, whether the significance level of each coefficient
 should be appended to values or not.}
 
 \item{showModelSummary}{logical, if \code{TRUE}, a summary of the regression model with
 Intercept, R-squared, F-Test and AIC-value is printed to the lower right corner
 of the plot.}
 
 \item{showCI}{logical, if \code{TRUE} (default), a confidence region for the regression line
-will be plotted. Only applies if \code{type = ""lm""} and fitted model has 
+will be plotted. Only applies if \code{type = ""lm""} and fitted model has
 only one predictor, or if \code{type = ""pred""} or \code{type = ""resid""}.}
 
 \item{pointAlpha}{alpha value of point-geoms in the scatter plots.
 Default is 0.2.}
 
-\item{showScatterPlot}{logical, if \code{TRUE} (default), a scatter plot of 
+\item{showScatterPlot}{logical, if \code{TRUE} (default), a scatter plot of
 response and predictor values for each predictor of \code{fit} is plotted.
 Only applies if \code{type = ""lm""} and fitted model has only one predictor,
 or if \code{type = ""pred""} or \code{type = ""resid""}.}
@@ -139,7 +139,7 @@ specified, if \code{type = ""poly""}, in order to plot marginal effects
 for polynomial terms. See 'Examples'.}
 
 \item{showOriginalModelOnly}{logical, if \code{TRUE} (default), only model assumptions of
-\code{fit} are plotted. if \code{FALSE}, model assumptions of an updated 
+\code{fit} are plotted. if \code{FALSE}, model assumptions of an updated
 model where outliers are automatically excluded are also plotted.
 Only applies if \code{type = ""ma""}.}
 
@@ -170,7 +170,7 @@ Depending on the \code{type}, this function plots coefficients (estimates)
            \item{\code{type = ""pred""}}{regression lines (slopes) with confidence intervals for each single predictor of the fitted model are plotted, i.e. all predictors of the fitted model are extracted and for each of them, the linear relationship is plotted against the response variable.}
            \item{\code{type = ""resid""}}{is similar to the \code{type = ""pred""} option, however, each predictor is plotted against the residuals (instead of response).}
            \item{\code{type = ""resp""}}{the predicted values of the response for each observation is plotted, which mostly results in a single linear line.}
-           \item{\code{type = ""eff""}}{computes the marginal effects for all predictors, using the \code{\link[effects]{allEffects}} function. I.e. for each predictor, the predicted values towards the response are plotted, with all remaining co-variates set to the mean. Due to possible different scales of predictors, a faceted plot is printed (instead of plotting all lines in one plot). This function accepts following argument: \code{fit}, \code{title}, \code{geom.size}, \code{showCI} and \code{printPlot}.}
+           \item{\code{type = ""eff""}}{computes the marginal effects for all predictors, using the \code{\link[effects]{allEffects}} function. I.e. for each predictor, the predicted values towards the response are plotted, with all remaining co-variates set to the mean. Due to possible different scales of predictors, a faceted plot is printed (instead of plotting all lines in one plot). This function accepts following argument: \code{fit}, \code{title}, \code{geom.size}, \code{remove.estimates}, \code{showCI} and \code{printPlot}.}
            \item{\code{type = ""poly""}}{plots the marginal effects of polynomial terms in \code{fit}, using the \code{\link[effects]{effect}} function, but only for a selected polynomial term, which is specified with \code{poly.term}. This function helps undertanding the effect of polynomial terms by plotting the curvilinear relationships of response and quadratic, cubic etc. terms. This function accepts following argument: \code{fit}, \code{poly.term}, \code{geom.colors}, \code{geom.size}, \code{axisTitle.x}, \code{showCI} and \code{printPlot}.}
            \item{\code{type = ""ma""}}{checks model assumptions. Please note that only three arguments are relevant: \code{fit}, \code{completeDiagnostic} and \code{showOriginalModelOnly}. All other arguments are ignored.}
            \item{\code{type = ""vif""}}{Variance Inflation Factors (check for multicollinearity) are plotted. As a rule of thumb, values below 5 are considered as good and indicate no multicollinearity, values between 5 and 10 may be tolerable. Values greater than 10 are not acceptable and indicate multicollinearity between model's predictors.}
@@ -187,7 +187,7 @@ fit <- lm(airquality$Ozone ~ airquality$Wind + airquality$Temp + airquality$Sola
 sjp.lm(fit, gridBreaksAt = 2)
 
 # plot estimates with CI
-# and with narrower tick marks 
+# and with narrower tick marks
 # (because ""gridBreaksAt"" was not specified)
 sjp.lm(fit)
 
@@ -233,21 +233,21 @@ sjp.lm(fit, type = ""ma"")
 # --------------------------
 library(sjmisc)
 data(efc)
-fit <- lm(barthtot ~ c160age + e17age + c12hour + e16sex + c161sex + c172code, 
+fit <- lm(barthtot ~ c160age + e17age + c12hour + e16sex + c161sex + c172code,
           data = efc)
 
 # order estimates according to coefficient's order
-sjp.lm(fit, 
-       group.estimates = c(1, 1, 2, 3, 3, 4), 
+sjp.lm(fit,
+       group.estimates = c(1, 1, 2, 3, 3, 4),
        geom.colors = c(""green"", ""red"", ""blue"", ""grey""),
        sort.est = FALSE)
-          
-fit <- lm(barthtot ~ c160age + c12hour + e17age+ c161sex + c172code + e16sex, 
+
+fit <- lm(barthtot ~ c160age + c12hour + e17age+ c161sex + c172code + e16sex,
           data = efc)
 
 # force order of estimates according to group assignment
-sjp.lm(fit, 
-       group.estimates = c(1, 2, 1, 3, 4, 3), 
+sjp.lm(fit,
+       group.estimates = c(1, 2, 1, 3, 4, 3),
        geom.colors = c(""green"", ""red"", ""blue"", ""grey""),
        sort.est = TRUE)
 
@@ -283,7 +283,7 @@ sjp.lm(fit, type = ""poly"", poly.term = ""e17age"")}
 Gelman A (2008) ""Scaling regression inputs by dividing by two standard deviations."" \emph{Statistics in Medicine 27: 28652873.} \url{http://www.stat.columbia.edu/~gelman/research/published/standardizing7.pdf}
 }
 \seealso{
-\href{http://www.strengejacke.de/sjPlot/sjp.lm}{sjPlot manual: sjp.lm} for 
+\href{http://www.strengejacke.de/sjPlot/sjp.lm}{sjPlot manual: sjp.lm} for
            more details and examples of this function; use \code{\link{sjp.poly}}
            to see which polynomial degree fits best for possible polynomial terms.
 }

---FILE: man/sjp.lmer.Rd---
@@ -97,9 +97,9 @@ on the plot type is chosen.}
 
 \item{interceptLineColor}{color of the intercept line. Default value is \code{""grey70""}.}
 
-\item{remove.estimates}{character vector with coefficient names that indicate 
-which estimates should be removed from the plot. 
-\code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default 
+\item{remove.estimates}{character vector with coefficient names that indicate
+which estimates should be removed from the plot.
+\code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default
 is \code{NULL}, i.e. all estimates are printed.}
 
 \item{showValueLabels}{logical, whether estimate values should be plotted to each dot or not.}

---FILE: man/sjp.lmm.Rd---
@@ -42,8 +42,8 @@ Default is \code{""p-level""}. Only applies if \code{usePShapes = TRUE}.}
 labels for the dependent variables are provided (see \code{labelDependentVariables}).
 Default is \code{""Model""}.}
 
-\item{axisLabels.y}{labels or names of the predictor variables (independent vars). Must 
-be a character vector of same length as independent variables. The labels 
+\item{axisLabels.y}{labels or names of the predictor variables (independent vars). Must
+be a character vector of same length as independent variables. The labels
 may also be passed as list object; they will be coerced to character vector automatically.}
 
 \item{axisTitle.x}{string, title for the x axis.}
@@ -83,9 +83,9 @@ legend is plotted. Default is \code{FALSE}.}
 
 \item{interceptLineColor}{color of the intercept line. Default value is \code{""grey70""}.}
 
-\item{remove.estimates}{character vector with coefficient names that indicate 
-which estimates should be removed from the plot. 
-\code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default 
+\item{remove.estimates}{character vector with coefficient names that indicate
+which estimates should be removed from the plot.
+\code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default
 is \code{NULL}, i.e. all estimates are printed.}
 
 \item{coord.flip}{logical, if \code{TRUE} (default), predictors are plotted along the y-axis and estimate

---FILE: man/sjp.xtab.Rd---
@@ -57,9 +57,7 @@ y-axis ranges from 0 to required maximum.}
 Axis labels will be automatically detected, when data was either imported 
 with \code{\link[sjmisc]{read_spss}} or has named factor levels 
 (see 'Examples'). Else, specifiy argument like this:
-\code{axisLabels.x = c(""Label1"", ""Label2"", ""Label3"")}.
-The labels may also be passed as \code{\link{list}} object. They will be coerced
-to character vector automatically.}
+\code{axisLabels.x = c(""Label1"", ""Label2"", ""Label3"")}.}
 
 \item{legendLabels}{a character vector with labels for the guide/legend.}
 "
strengejacke,sjPlot,341382512b016cea71d3e94d759af2864fc8f1f7,Daniel Ldecke,d.luedecke@uke.de,2015-11-09T18:08:30Z,Daniel Ldecke,d.luedecke@uke.de,2015-11-09T18:08:30Z,fixed bug with argument `ci.hyphen` in `sjt.lm` and `sjt.lmer`,DESCRIPTION;NEWS;R/sjTabLinReg.R;README.md;man/sjPlot-package.Rd,False,True,True,False,23,9,32,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.8.4-1
-Date: 2015-11-05
+Version: 1.8.4-2
+Date: 2015-11-09
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of plotting and table output functions for data

---FILE: NEWS---
@@ -1,8 +1,12 @@
-Version 1.8.4-1
+Version 1.8.4-2
 -----------------------------------------------------------------------------
 Changes to functions:
 * `sjp.lmer` and `sjp.glmer` can now plot random effect parts of random slope-intercept models (with `type = ""rs.ri""`), where regression lines or predicted probabilities of random intercept and slopes are plotted.
 
+Bug fixes:
+* Argument `ci.hyphen` in function `sjt.lm` and `sjt.lmer` was not correctly applied to confidence intervals of standardized beta values.
+
+
 Version 1.8.4
 -----------------------------------------------------------------------------
 General:

---FILE: R/sjTabLinReg.R---
@@ -1108,15 +1108,18 @@ sjt.lm <- function(...,
         # retieve lower and upper ci
         ci.lo <- joined.df[i + 1, (j - 1) * 8 + 8]
         ci.hi <- joined.df[i + 1, (j - 1) * 8 + 9]
-        ci.sep.string <- ifelse(sjmisc::is_empty(ci.lo), """", ""&nbsp;-&nbsp;"")
+        ci.sep.string <- ifelse(sjmisc::is_empty(ci.lo), ""&nbsp;"", ci.hyphen)
         if (separateConfColumn) {
           # open table cell for Beta-coefficient
           page.content <- paste0(page.content, sprintf(""<td class=\""tdata centeralign modelcolumn4\"">%s"", joined.df[i + 1, (j - 1) * 8 + 7]))
           # show pvalue stars, if no estimates are shown
           if (!pvaluesAsNumbers && !showEst) page.content <- paste0(page.content, sprintf(""&nbsp;%s"", joined.df[1, (i - 1) * 8 + 5]))
           # if we have CI, start new table cell (CI in separate column)
           if (showConfInt) {
-            page.content <- paste0(page.content, sprintf(""</td><td class=\""tdata centeralign modelcolumn5\"">%s%s%s</td>"", ci.lo, ci.sep.string, ci.hi))
+            page.content <- paste0(page.content, sprintf(""</td><td class=\""tdata centeralign modelcolumn5\"">%s%s%s</td>"",
+                                                         ci.lo, 
+                                                         ci.sep.string,
+                                                         ci.hi))
           } else {
             page.content <- paste0(page.content, ""</td>"")
           }
@@ -1126,7 +1129,11 @@ sjt.lm <- function(...,
           # show pvalue stars, if no estimates are shown
           if (!pvaluesAsNumbers && !showEst) page.content <- paste0(page.content, sprintf(""&nbsp;%s"", joined.df[1, (i - 1) * 8 + 5]))
           # confidence interval in Beta-column
-          if (showConfInt && !sjmisc::is_empty(ci.lo)) page.content <- paste0(page.content, sprintf(""%s(%s%s%s)"", linebreakstring, ci.lo, ci.sep.string, ci.hi))
+          if (showConfInt && !sjmisc::is_empty(ci.lo)) page.content <- paste0(page.content, sprintf(""%s(%s%s%s)"",
+                                                                                                    linebreakstring, 
+                                                                                                    ci.lo, 
+                                                                                                    ci.sep.string, 
+                                                                                                    ci.hi))
           # if p-values are not shown as numbers, insert them after beta-value
           page.content <- paste0(page.content, ""</td>"")
         }

---FILE: README.md---
@@ -40,7 +40,10 @@ install.packages(""sjPlot"")
 
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since core functionality of package depends on the [ggplot-package](http://cran.r-project.org/package=ggplot2), consider citing this package as well.
 
-### Changelog of development build 1.8.4-1
+### Changelog of development build 1.8.4-2
 
 #### Changes to functions
 * `sjp.lmer` and `sjp.glmer` can now plot random effect parts of random slope-intercept models (with `type = ""rs.ri""`), where regression lines or predicted probabilities of random intercept and slopes are plotted.
+
+#### Bug fixes
+* Argument `ci.hyphen` in function `sjt.lm` and `sjt.lmer` was not correctly applied to confidence intervals of standardized beta values.
\ No newline at end of file

---FILE: man/sjPlot-package.Rd---
@@ -34,8 +34,8 @@
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.8.4-1\cr
-Date: \tab 2015-11-05\cr
+Version: \tab 1.8.4-2\cr
+Date: \tab 2015-11-9\cr
 License: \tab GPL-3\cr
 }
 }"
strengejacke,sjPlot,2551b0fa16aeab922874c72c0717b3d8bccb9c96,Daniel Ldecke,d.luedecke@uke.de,2015-09-29T16:53:16Z,Daniel Ldecke,d.luedecke@uke.de,2015-09-29T16:53:16Z,fix typo in read.me,NEWS;README.md,False,False,False,False,2,2,4,"---FILE: NEWS---
@@ -6,7 +6,7 @@ General:
 Changes to functions:
 * Predictor grouping with argument `group.pred` now also works for `sjt.lmer` and `sjt.glmer` (in certain cases may be buggy, so `group.pred` defaults to `FALSE`).
 * Argument `vars` in `sjp.lmer` and `sjp.glmer` now also applies when plotting estimates (`type = ""fe""` or `type = ""re""`).
-* `view_df_` gets a `weight_by` argument.
+* `view_df_` gets a `weightBy` argument.
 * Minor improvements to `view_df`, `sjp.lm` and `sjp.lmm`.
 * Improved accuracy of computation of skewness value in `sjt.itemanalysis`.
 

---FILE: README.md---
@@ -48,7 +48,7 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 #### Changes to functions
 * Predictor grouping with argument `group.pred` now also works for `sjt.lmer` and `sjt.glmer` (in certain cases may be buggy, so `group.pred` defaults to `FALSE`).
 * Argument `vars` in `sjp.lmer` and `sjp.glmer` now also applies when plotting estimates (`type = ""fe""` or `type = ""re""`).
-* `view_df_` gets a `weight_by` argument.
+* `view_df_` gets a `weightBy` argument.
 * Minor improvements to `view_df`, `sjp.lm` and `sjp.lmm`.
 * Improved accuracy of computation of skewness value in `sjt.itemanalysis`.
 "
strengejacke,sjPlot,f5c041c771251f0de3fde7e0041490c61e423b42,Daniel Ldecke,d.luedecke@uke.de,2015-09-27T12:12:12Z,Daniel Ldecke,d.luedecke@uke.de,2015-09-27T12:12:12Z,fixed bug with axis label order in sjp.pca,NEWS;R/sjPlotPCA.R;README.md;man/sjp.glmer.Rd;man/sjp.lmer.Rd,False,True,True,False,11,7,18,"---FILE: NEWS---
@@ -8,6 +8,7 @@ Changes to functions:
 
 Bug fixes:
 * Fixed bug where in certain cases, ordered factors were not labelled correctly in `sjp.frq`.
+* Axis labels were reversed in `sjp.pca` for `type = ""bar""`.
 
 Version 1.8.3
 -----------------------------------------------------------------------------

---FILE: R/sjPlotPCA.R---
@@ -410,7 +410,7 @@ sjp.pca <- function(data,
   # --------------------------------------------------------
   if (type == ""b"") {
     heatmap <- heatmap + 
-      scale_x_discrete(labels = axisLabels.y) +
+      scale_x_discrete(labels = rev(axisLabels.y)) +
       scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, .2)) +
       facet_grid(~xpos) +
       coord_flip()

---FILE: README.md---
@@ -50,3 +50,4 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 
 #### Bug fixes
 * Fixed bug where in certain cases, ordered factors were not labelled correctly in `sjp.frq`.
+* Axis labels were reversed in `sjp.pca` for `type = ""bar""`.

---FILE: man/sjp.glmer.Rd---
@@ -31,9 +31,10 @@ sjp.glmer(fit, type = ""re"", vars = NULL, ri.nr = NULL, emph.grp = NULL,
 
 \item{vars}{numeric vector with column indices of selected variables or a character vector with
 variable names of selected variables from the fitted model, which should be used to plot
-fixed effects slopes (for \code{\link[lme4]{lmer}}) or probability curves
-(for \code{\link[lme4]{glmer}}) of random intercepts. This argument only
-applies if \code{type} is \code{""fe.pc""}, \code{""ri.pc""} or \code{""fe.ri""}.
+estimates, fixed effects slopes (for \code{\link[lme4]{lmer}}) or probability curves
+(for \code{\link[lme4]{glmer}}) of random intercepts. This argument
+applies if \code{type} is \code{""fe""}, \code{""fe.std""}, \code{""re""},
+\code{""fe.pc""}, \code{""ri.pc""} or \code{""fe.ri""}.
 In this case, only those terms specified in \code{""vars""} will be plotted.}
 
 \item{ri.nr}{numeric vector. If \code{type = ""re""}, \code{type = ""ri.pc""} or \code{type = ""fe.ri""},

---FILE: man/sjp.lmer.Rd---
@@ -37,9 +37,10 @@ sjp.lmer(fit, type = ""re"", vars = NULL, ri.nr = NULL, emph.grp = NULL,
 
 \item{vars}{numeric vector with column indices of selected variables or a character vector with
 variable names of selected variables from the fitted model, which should be used to plot
-fixed effects slopes (for \code{\link[lme4]{lmer}}) or probability curves
-(for \code{\link[lme4]{glmer}}) of random intercepts. This argument only
-applies if \code{type} is \code{""fe.pc""}, \code{""ri.pc""} or \code{""fe.ri""}.
+estimates, fixed effects slopes (for \code{\link[lme4]{lmer}}) or probability curves
+(for \code{\link[lme4]{glmer}}) of random intercepts. This argument
+applies if \code{type} is \code{""fe""}, \code{""fe.std""}, \code{""re""},
+\code{""fe.pc""}, \code{""ri.pc""} or \code{""fe.ri""}.
 In this case, only those terms specified in \code{""vars""} will be plotted.}
 
 \item{ri.nr}{numeric vector. If \code{type = ""re""}, \code{type = ""ri.pc""} or \code{type = ""fe.ri""},"
strengejacke,sjPlot,cff5da32bb8a7497c1cc11d12c20f3800c308c91,Daniel Ldecke,d.luedecke@uke.de,2015-09-02T17:04:30Z,Daniel Ldecke,d.luedecke@uke.de,2015-09-02T17:04:30Z,"various

* Predictor grouping with argument `group.pred` now also works for
`sjt.lmer` and `sjt.glmer` (in certain cases may be buggy, so
`group.pred` defaults to `FALSE`).
* Minor improvements to `view_df`, `sjp.lm` and `sjp.lmm`.
* minor bug fix in `sjp.frq` with typo",DESCRIPTION;NEWS;R/helpfunctions.R;R/sjPlotFrequencies.R;R/sjPlotLinreg.R;R/sjPlotLinregMultiple.R;R/sjTabLinReg.R;R/sjTabOdds.R;R/sjTabSPSS.R;README.md;man/sjPlot-package.Rd,False,True,True,False,57,50,107,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.8.3
-Date: 2015-08-26
+Version: 1.8.3-3
+Date: 2015-09-02
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of plotting and table output functions for data visualization. Results of various statistical analyses (that are commonly used in social sciences) can be visualized using this package, including simple and cross tabulated frequencies, histograms, box plots, (generalized) linear models, mixed effects models, PCA and correlation matrices, cluster analyses, scatter plots, Likert scales, effects plots of regression models (including interaction terms) and much more.

---FILE: NEWS---
@@ -1,3 +1,9 @@
+Version 1.8.3-2
+-----------------------------------------------------------------------------
+Changes to functions:
+* Predictor grouping with argument `group.pred` now also works for `sjt.lmer` and `sjt.glmer` (in certain cases may be buggy, so `group.pred` defaults to `FALSE`).
+* Minor improvements to `view_df`, `sjp.lm` and `sjp.lmm`.
+
 Version 1.8.3
 -----------------------------------------------------------------------------
 New functions:

---FILE: R/helpfunctions.R---
@@ -398,24 +398,36 @@ retrieveModelGroupIndices <- function(models, rem_rows = NULL) {
   for (k in 1:length(models)) {
     # get model
     fit <- models[[k]]
+    # ------------------------
+    # do we have a merMod object?
+    # ------------------------
+    if (length(grep(""merMod"", class(fit), fixed = T)) > 0) {
+      # if yes, get number of fixed effects
+      no_fixef <- length(attr(attr(fit@frame, ""terms""), ""predvars.fixed"")) - 1
+      # then copy only fixed effects columns
+      fmodel <- fit@frame[, 1:no_fixef]
+    } else {
+      # else copy model matrix
+      fmodel <- fit$model
+    }
     # retrieve all factors from model
-    for (grp.cnt in 1:ncol(fit$model)) {
+    for (grp.cnt in 1:ncol(fmodel)) {
       # get variable
-      fit.var <- fit$model[, grp.cnt]
+      fit.var <- fmodel[, grp.cnt]
       # is factor? and has more than two levels?
       # (otherwise, only one category would appear in
       # coefficients, so no grouping needed anyway)
       if (is.factor(fit.var) && length(levels(fit.var)) > 2) {
         # get factor name
-        fac.name <- colnames(fit$model)[grp.cnt]
+        fac.name <- colnames(fmodel)[grp.cnt]
         # check whether we already have this factor
         if (!any(found.factors == fac.name)) {
           # if not, save found factor variable name
           found.factors <- c(found.factors, fac.name)
           # save factor name
           lab <- unname(sjmisc::get_label(fit.var))
           # any label?
-          if (is.null(lab)) lab <- colnames(fit$model)[grp.cnt]
+          if (is.null(lab)) lab <- colnames(fmodel)[grp.cnt]
           # determins startindex
           index <- grp.cnt + add.index - 1
           index.add <- length(levels(fit.var)) - 2

---FILE: R/sjPlotFrequencies.R---
@@ -301,17 +301,19 @@ sjp.frq <- function(varCount,
   # --------------------------------------------------------
   if (is.null(geom.size)) {
     if (type == ""bars"") 
-      geom.size <- 0.7
+      geom.size <- .7
     else if (type == ""dots"") 
       geom.size <- 3
-    else if (type == ""hist"") 
+    else if (type == ""histogram"") 
       geom.size <- .7
     else if (type == ""line"") 
       geom.size <- .8
-    else if (type == ""box"") 
+    else if (type == ""boxplots"") 
       geom.size <- .3
     else if (type == ""violin"") 
       geom.size <- .3
+    else
+      geom.size <- .7
   }
   #---------------------------------------------------
   # check whether variable should be auto-grouped

---FILE: R/sjPlotLinreg.R---
@@ -344,11 +344,12 @@ sjp.lm <- function(fit,
   # -------------------------------------------------
   # retrieve betas, leave out intercept ([-1])
   # -------------------------------------------------
-  if (type == ""std"") {
+  if (type == ""std"" || type == ""std2"") {
     # retrieve standardized betas
-    tmp <- suppressWarnings(sjmisc::std_beta(fit, include.ci = TRUE))
-  } else if (type == ""std2"") {
-    tmp <- sjmisc::std_beta(fit, include.ci = TRUE, type = ""std2"")
+    tmp <- suppressWarnings(sjmisc::std_beta(fit, include.ci = TRUE, type = type))
+    # add ""std."" to title?
+    if (axisTitle.x == ""Estimates"")
+      axisTitle.x <- ""Std. Estimates""
   } else {
     bv <- stats::coef(fit)[-1]
     if (1 == length(bv)) {

---FILE: R/sjPlotLinregMultiple.R---
@@ -199,12 +199,18 @@ sjp.lmm <- function(...,
                                 suppressWarnings(sjmisc::std_beta(fit, include.ci = TRUE))))
       # no intercept for std
       showIntercept <- FALSE
+      # add ""std."" to title?
+      if (axisTitle.x == ""Estimates"")
+        axisTitle.x <- ""Std. Estimates""
     } else if (type == ""std2"") {
       # retrieve standardized betas
       betas <- data.frame(rbind(data.frame(beta = 0, ci.low = 0, ci.hi = 0),
                                 sjmisc::std_beta(fit, include.ci = TRUE, type = ""std2"")))
       # no intercept for std
       showIntercept <- FALSE
+      # add ""std."" to title?
+      if (axisTitle.x == ""Estimates"")
+        axisTitle.x <- ""Std. Estimates""
     } else {
       # copy estimates to data frame
       betas <- data.frame(stats::coef(fit), stats::confint(fit))

---FILE: R/sjTabLinReg.R---
@@ -929,7 +929,7 @@ sjt.lm <- function(...,
   # -------------------------------------
   # should factor predictors be grouped?
   # -------------------------------------
-  if (group.pred && !lmerob) {
+  if (group.pred) {
     # get indices
     group.pred.list <- retrieveModelGroupIndices(input_list, remove.estimates)
     # append indices
@@ -1500,12 +1500,14 @@ sjt.lmer <- function(...,
                      boldpvalues = TRUE,
                      separateConfColumn = TRUE,
                      newLineConf = TRUE,
+                     group.pred = FALSE,
                      showAbbrHeadline = TRUE,
                      showICC = TRUE,
                      showAIC = FALSE,
                      showAICc = FALSE,
                      remove.estimates = NULL,
                      cellSpacing = 0.2,
+                     cellGroupIndent = 0.6,
                      encoding = NULL,
                      CSS = NULL,
                      useViewer = TRUE,
@@ -1524,8 +1526,8 @@ sjt.lmer <- function(...,
                 digits.se = digits.se, digits.sb = digits.sb, digits.summary = digits.summary, 
                 pvaluesAsNumbers = pvaluesAsNumbers, boldpvalues = boldpvalues, 
                 separateConfColumn = separateConfColumn, newLineConf = newLineConf, 
-                group.pred = FALSE, showAbbrHeadline = showAbbrHeadline, showR2 = showICC, 
+                group.pred = group.pred, showAbbrHeadline = showAbbrHeadline, showR2 = showICC, 
                 showFStat = FALSE, showAIC = showAIC, showAICc = showAICc, remove.estimates = remove.estimates, 
-                cellSpacing = cellSpacing, cellGroupIndent = 0, encoding = encoding, 
+                cellSpacing = cellSpacing, cellGroupIndent = cellGroupIndent, encoding = encoding, 
                 CSS = CSS, useViewer = useViewer, no.output = no.output, remove.spaces = remove.spaces))
 }
\ No newline at end of file

---FILE: R/sjTabOdds.R---
@@ -697,7 +697,7 @@ sjt.glm <- function(...,
   # -------------------------------------
   # should factor predictors be grouped?
   # -------------------------------------
-  if (group.pred && !lmerob) {
+  if (group.pred) {
     # get indices
     group.pred.list <- retrieveModelGroupIndices(input_list, remove.estimates)
     group.pred.rows <- group.pred.list[[1]]
@@ -1325,6 +1325,7 @@ sjt.glmer <- function(...,
                       ci.hyphen = ""&nbsp;&ndash;&nbsp;"",
                       separateConfColumn = TRUE,
                       newLineConf = TRUE,
+                      group.pred = FALSE,
                       showAbbrHeadline = TRUE,
                       showICC = TRUE,
                       showLogLik = FALSE,
@@ -1334,6 +1335,7 @@ sjt.glmer <- function(...,
                       showFamily = FALSE,
                       remove.estimates = NULL,
                       cellSpacing = 0.2,
+                      cellGroupIndent = 0.6,
                       encoding = NULL,
                       CSS = NULL,
                       useViewer = TRUE,
@@ -1352,9 +1354,9 @@ sjt.glmer <- function(...,
                  pvaluesAsNumbers = pvaluesAsNumbers, boldpvalues = boldpvalues, 
                  showConfInt = showConfInt, showStdError = showStdError, 
                  ci.hyphen = ci.hyphen, separateConfColumn = separateConfColumn, newLineConf = newLineConf, 
-                 group.pred = FALSE, showAbbrHeadline = showAbbrHeadline, showPseudoR = showICC, 
+                 group.pred = group.pred, showAbbrHeadline = showAbbrHeadline, showPseudoR = showICC, 
                  showLogLik = showLogLik, showAIC = showAIC, showAICc = showAICc, showChi2 = FALSE, 
                  showHosLem = showHosLem, showFamily = showFamily, remove.estimates = remove.estimates, 
-                 cellSpacing = cellSpacing, cellGroupIndent = 0, encoding = encoding, 
+                 cellSpacing = cellSpacing, cellGroupIndent = cellGroupIndent, encoding = encoding, 
                  CSS = CSS, useViewer = useViewer, no.output = no.output, remove.spaces = remove.spaces))
 }
\ No newline at end of file

---FILE: R/sjTabSPSS.R---
@@ -293,7 +293,7 @@ view_df <- function(x,
                               sjmisc::get_values(x[[index]]),
                               20)$mydat$frq
         # remove last value, which is N for NA
-        if (is.na(ftab)) {
+        if (length(ftab) == 1 && is.na(ftab)) {
           valstring <- ""<NA>""
         } else {
           for (i in 1:(length(ftab) - 1)) {
@@ -319,7 +319,7 @@ view_df <- function(x,
                               sjmisc::get_values(x[[index]]),
                               20)$mydat$valid
         # remove last value, which is a NA dummy
-        if (is.na(ftab)) {
+        if (length(ftab) == 1 && is.na(ftab)) {
           valstring <- ""<NA>""
         } else {
           for (i in 1:(length(ftab) - 1)) {

---FILE: README.md---
@@ -40,32 +40,8 @@ install.packages(""sjPlot"")
 
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since core functionality of package depends on the [ggplot-package](http://cran.r-project.org/package=ggplot2), consider citing this package as well.
 
-### Changelog of stable release 1.8.3
-
-#### New functions
-* `sjp.gpt` to plot grouped proportional tables.
-* `save_plot` as convenient function to save the last ggplot-figure in high quality for publication.
+### Changelog of development build 1.8.3-2
 
 #### Changes to functions
-* `sjp.lmm` can now also plot standardized estimates.
-* `sjp.lm`, `sjp.lmm` and `sjt.lm` can now plot standardized estimates, where standardization is computed following Gelman's approach by dividing estimates by two standard deviations.
-* `sjp.lm`, `sjp.glm`, `sjp.lmm`, `sjp.glmm`, `sjp.lmer` and `sjp.glmer` get a `remove.estimates` argument to remove specific estimates from the plot output.
-* Added parameters `ci.hyphen` and `minus.sign` to `sjt.lm`, `sjt.glm`, `sjt.lmer` and `sjt.glmer` to set specific symbols or HTML entitities for hyphens and minus signs of negative numbers.
-* Added `type = ""coeff""` to `sjp.lmer` to plot joint random and fixed effects coefficients.
-* `type = ""poly""` in `sjp.lm` can now deal with fitted models that either use polynomials with `poly` or splines with `bs` (see examples).
-* `sjt.df` gets a `big.mark` parameter to add thousands-separators if parameter `describe = TRUE`.
-* `sjt.df` and `view_df` now recognize Date and POSIX-classes, if `showType = TRUE`.
-* `sjp.poly` now also returns cutpoints of loess curvature, to get maximum / minimum values of loess curvature.
-* `sjp.lm` with `type = ""ma""` now also returns all plots as list of ggplot-objects.
-* `sjp.setTheme` now allows for custom label and title colors when using pre-set-themes.
-* Improved automatic y-axis-limit detection in `sjp.frq` and `sjp.grpfrq`.
-* Minor improvements to `sjp.lmm` and `sjp.glmm`.
-
-#### Bug fixes
-* Fixed bug in `sjp.lmer`, which misleadingly printed wrong beta coefficients (they were exponentiated as for odds ratios).
-* Fixed bug with computation of predicted probabilities in `sjp.glm` and `sjp.glmer` (only occured when `type = ""y.pc""`).
-* `sjp.grpfrq` did not show correct number of missings (argument `na.rm = FALSE`), if grouping variable startet with zero.
-* Fixed bug with `sjp.frq` and `sjt.frq`, when variable was a labelled factor with lowest factor level smaller than 1.
-* Fixed bug in `view_df` with parameter `showFreq = TRUE`, when variable was a character vector.
-* Minor bug fixes with p-shapes in `sjp.lmm` and `sjp.glmm`.
-* Fixed bug in `sjt`-table functions that occured with invalid multibyte strings.
+* Predictor grouping with argument `group.pred` now also works for `sjt.lmer` and `sjt.glmer` (in certain cases may be buggy, so `group.pred` defaults to `FALSE`).
+* Minor improvements to `view_df`, `sjp.lm` and `sjp.lmm`.

---FILE: man/sjPlot-package.Rd---
@@ -34,8 +34,8 @@
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.8.3\cr
-Date: \tab 2015-08-26\cr
+Version: \tab 1.8.3-2\cr
+Date: \tab 2015-09-02\cr
 License: \tab GPL-3\cr
 }
 }"
strengejacke,sjPlot,2078a6113a678eccfa13d61f7eaa40aaffa33e59,Daniel Ldecke,d.luedecke@uke.de,2015-07-31T16:49:24Z,Daniel Ldecke,d.luedecke@uke.de,2015-07-31T16:49:24Z,fix news and read.me,NEWS;README.md,False,False,False,False,2,2,4,"---FILE: NEWS---
@@ -16,7 +16,7 @@ Changes to functions:
 * Improved automatic y-axis-limit detection in ""sjp.frq"" and ""sjp.grpfrq"".
 
 Bug fixes:
-* Fixed bug with computation of predicted probabilities in ""sjp.glm"" and ""sjp.glmer"", both only for ""type = 'y.pc'"".
+* Fixed bug with computation of predicted probabilities in ""sjp.glm"" and ""sjp.glmer"" (only occured when ""type = 'y.pc'"").
 * ""sjp.grpfrq"" did not show correct number of missings (argument ""na.rm = FALSE""), if grouping variable startet with zero.
 * Fixed bug with ""sjp.frq"" and ""sjt.frq"", when variable was a labelled factor with lowest factor level smaller than 1.
 * Fixed bug in ""view_df"" with parameter ""showFreq = TRUE"", when variable was a character vector.

---FILE: README.md---
@@ -57,7 +57,7 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 * `sjp.setTheme` now allows for custom label and title colors when using pre-set-themes.
 
 #### Bug fixes
-* Fixed bug with computation of predicted probabilities in `sjp.glm` and `sjp.glmer`, both only for `type = ""y.pc""`.
+* Fixed bug with computation of predicted probabilities in `sjp.glm` and `sjp.glmer` (only occured when `type = ""y.pc""`).
 * `sjp.grpfrq` did not show correct number of missings (argument `na.rm = FALSE`), if grouping variable startet with zero.
 * Fixed bug with `sjp.frq` and `sjt.frq`, when variable was a labelled factor with lowest factor level smaller than 1.
 * Fixed bug in `view_df` with parameter `showFreq = TRUE`, when variable was a character vector.
\ No newline at end of file"
strengejacke,sjPlot,9d90eaadf396bd8350e57463d054f2df0e0a0485,Daniel Ldecke,d.luedecke@uke.de,2015-07-30T20:05:20Z,Daniel Ldecke,d.luedecke@uke.de,2015-07-30T20:05:20Z,minor bug fixes,DESCRIPTION;NEWS;R/sjPlotAnova.R;R/sjPlotGLME.R;R/sjPlotLinreg.R;R/sjPlotLinregMultiple.R;R/sjPlotOdds.R;R/sjPlotPolynomials.R;README.md;man/sjPlot-package.Rd;man/sjp.glm.Rd;man/sjp.glmer.Rd,False,True,True,False,31,25,56,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.8.2-4
-Date: 2015-07-24
+Version: 1.8.2-5
+Date: 2015-07-30
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of plotting and table output functions for data visualization. Results of various statistical analyses (that are commonly used in social sciences) can be visualized using this package, including simple and cross tabulated frequencies, histograms, box plots, (generalized) linear models, mixed effects models, PCA and correlation matrices, cluster analyses, scatter plots, Likert scales, effects plots of regression models (including interaction terms) and much more.

---FILE: NEWS---
@@ -1,4 +1,4 @@
-Version 1.8.2-4
+Version 1.8.2-5
 -----------------------------------------------------------------------------
 New functions:
 * ""sjp.gpt"" to plot grouped proportional tables.
@@ -13,6 +13,7 @@ Changes to functions:
 * ""sjp.setTheme"" now allows for custom label and title colors when using pre-set-themes.
 
 Bug fixes:
+* Fixed bug with computation of predicted probabilities in ""sjp.glm"" and ""sjp.glmer"", both only for ""type = 'y.pc'"".
 * ""sjp.grpfrq"" did not show correct number of missings (argument ""na.rm = FALSE""), if grouping variable startet with zero.
 * Fixed bug with ""sjp.frq"" and ""sjt.frq"", when variable was a labelled factor with lowest factor level smaller than 1.
 * Fixed bug in ""view_df"" with parameter ""showFreq = TRUE"", when variable was a character vector.

---FILE: R/sjPlotAnova.R---
@@ -237,7 +237,7 @@ sjp.aov1 <- function(depVar,
   # print coefficients and p-values in plot
   # ----------------------------
   # init data column for p-values
-  ps <- c(round(means,labelDigits))
+  ps <- c(round(means, labelDigits))
   # if no values should be shown, clear
   # vector now
   if (!showValueLabels) ps <- rep(c(""""), length(ps))
@@ -246,7 +246,7 @@ sjp.aov1 <- function(depVar,
   # --------------------------------------------------------
   if (showPValueLabels) {
     for (i in 1:length(means.p)) {
-      ps[i] <- get_p_stars(means.ps[i])
+      ps[i] <- get_p_stars(means.p[i])
     }  
   }
   # --------------------------------------------------------

---FILE: R/sjPlotGLME.R---
@@ -122,7 +122,7 @@ utils::globalVariables(c(""nQQ"", ""ci"", ""fixef"", ""fade"", ""lower.CI"", ""upper.CI"", ""
 #' library(lme4)
 #' library(sjmisc)
 #' # create binary response
-#' sleepstudy$Reaction.dicho <- dicho(sleepstudy$Reaction, dichBy = ""md"")
+#' sleepstudy$Reaction.dicho <- dicho(sleepstudy$Reaction, dich.by = ""md"")
 #' # fit model
 #' fit <- glmer(Reaction.dicho ~ Days + (Days | Subject),
 #'              sleepstudy,
@@ -1468,15 +1468,15 @@ sjp.lme.response.probcurv <- function(fit,
   # get predicted values for response with and
   # without random effects
   # ----------------------------
-  pp.fe <- predict(fit, type = ""response"", re.form = NA)
-  pp.re <- predict(fit, type = ""response"", re.form = NULL)
+  pp.fe <- stats::predict(fit, type = ""response"", re.form = NA)
+  pp.re <- stats::predict(fit, type = ""response"", re.form = NULL)
   # ----------------------------
   # for glm, get probabilities
   # ----------------------------
-  if (fun == ""glm"") {
-    pp.fe <- plogis(pp.fe)
-    pp.re <- plogis(pp.re)
-  }
+  #   if (fun == ""glm"") {
+  #     pp.fe <- plogis(pp.fe)
+  #     pp.re <- plogis(pp.re)
+  #   }
   # ----------------------------
   # get predicted probabilities for 
   # response, including random effects

---FILE: R/sjPlotLinreg.R---
@@ -486,6 +486,7 @@ sjp.lm <- function(fit,
 }
 
 
+#' @importFrom stats predict
 sjp.lm.response.pred <- function(fit,
                                  geom.colors,
                                  show.se,
@@ -504,7 +505,7 @@ sjp.lm.response.pred <- function(fit,
   # ----------------------------
   # get predicted values for response
   # ----------------------------
-  pp <- predict(fit, type = ""response"")
+  pp <- stats::predict(fit, type = ""response"")
   # ----------------------------
   # get predicted probabilities for
   # response, including random effects

---FILE: R/sjPlotLinregMultiple.R---
@@ -56,9 +56,9 @@ utils::globalVariables(c(""beta"", ""lower"", ""upper"", ""p"", ""pa"", ""shape""))
 #' fit3 <- lm(tot_sc_e ~ c160age + c12hour + c161sex + c172code, data = efc)
 #' 
 #' # plot multiple models
-#' sjp.lmm(fit1, fit2, fit3, facet.grid = TRUE, fade.ns = FALSE)
+#' sjp.lmm(fit1, fit2, fit3, facet.grid = TRUE)
 #' 
-#' # plot multiple models with legend labels and point shapes instead of value  labels
+#' # plot multiple models with legend labels and point shapes instead of value labels
 #' sjp.lmm(fit1, fit2, fit3,
 #'          axisLabels.y = c(""Carer's Age"",
 #'                           ""Hours of Care"", 
@@ -69,6 +69,7 @@ utils::globalVariables(c(""beta"", ""lower"", ""upper"", ""p"", ""pa"", ""shape""))
 #'                                      ""Services used""),
 #'          showValueLabels = FALSE,
 #'          showPValueLabels = FALSE,
+#'          fade.ns = TRUE,
 #'          usePShapes = TRUE)
 #' 
 #' # plot multiple models from nested lists argument
@@ -99,7 +100,7 @@ sjp.lmm <- function(...,
                     geom.size = 3,
                     geom.spacing = 0.4,
                     geom.colors = ""Set1"",
-                    fade.ns = TRUE,
+                    fade.ns = FALSE,
                     usePShapes = FALSE,
                     interceptLineType = 2,
                     interceptLineColor = ""grey70"",

---FILE: R/sjPlotOdds.R---
@@ -107,7 +107,7 @@ utils::globalVariables(c(""OR"", ""lower"", ""upper"", ""p""))
 #'            Corresponds to \code{\link{plogis}(\link{predict}(fit, type = ""terms"") + attr(predict, ""constant""))}.}
 #'            \item{\code{type = ""y.pc""}}{(or \code{type = ""y.prob""}), the predicted values
 #'            of the response are computed, based on the \code{\link{predict.glm}}
-#'            method. Corresponds to \code{\link{plogis}(\link{predict}(fit, type = ""response""))}.}
+#'            method. Corresponds to \code{\link{predict}(fit, type = ""response"")}.}
 #'          }
 #'
 #' @examples
@@ -719,7 +719,7 @@ sjp.glm.response.probcurv <- function(fit,
   # ----------------------------
   # get predicted values for response
   # ----------------------------
-  pp <- stats::plogis(stats::predict(fit, type = ""response""))
+  pp <- stats::predict.glm(fit, type = ""response"")
   # ----------------------------
   # get predicted probabilities for 
   # response, including random effects

---FILE: R/sjPlotPolynomials.R---
@@ -109,7 +109,7 @@
 #' 
 #' @import ggplot2
 #' @importFrom scales grey_pal brewer_pal
-#' @importFrom stats lm glm binomial
+#' @importFrom stats lm glm binomial predict
 #' @export
 sjp.poly <- function(x, 
                      poly.term, 
@@ -196,7 +196,9 @@ sjp.poly <- function(x,
     # or a float value
     poly.digit <- ifelse(i %% 1 == 0, 0, 1)
     # create data frame with raw data and the fitted poly-curve
-    plot.df <- rbind(plot.df, cbind(mydat, predict(fit), sprintf(""x^%.*f"", poly.digit, i)))
+    plot.df <- rbind(plot.df, cbind(mydat, 
+                                    stats::predict(fit), 
+                                    sprintf(""x^%.*f"", poly.digit, i)))
     # print p-values?
     if (showPValues) {
       # get p-values

---FILE: README.md---
@@ -40,7 +40,7 @@ install.packages(""sjPlot"")
 
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since core functionality of package depends on the [ggplot-package](http://cran.r-project.org/package=ggplot2), consider citing this package as well.
 
-### Changelog of development build 1.8.2-4
+### Changelog of development build 1.8.2-5
 
 #### New functions
 * `sjp.gpt` to plot grouped proportional tables.
@@ -55,6 +55,7 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 * `sjp.setTheme` now allows for custom label and title colors when using pre-set-themes.
 
 #### Bug fixes
+* Fixed bug with computation of predicted probabilities in `sjp.glm` and `sjp.glmer`, both only for `type = ""y.pc""`.
 * `sjp.grpfrq` did not show correct number of missings (argument `na.rm = FALSE`), if grouping variable startet with zero.
 * Fixed bug with `sjp.frq` and `sjt.frq`, when variable was a labelled factor with lowest factor level smaller than 1.
 * Fixed bug in `view_df` with parameter `showFreq = TRUE`, when variable was a character vector.
\ No newline at end of file

---FILE: man/sjPlot-package.Rd---
@@ -34,8 +34,8 @@
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.8.2-4\cr
-Date: \tab 2015-07-24\cr
+Version: \tab 1.8.2-5\cr
+Date: \tab 2015-07-30\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjp.glm.Rd---
@@ -167,7 +167,7 @@ Plot odds ratios (exponentiated coefficients) with confidence intervalls as bar
            Corresponds to \code{\link{plogis}(\link{predict}(fit, type = ""terms"") + attr(predict, ""constant""))}.}
            \item{\code{type = ""y.pc""}}{(or \code{type = ""y.prob""}), the predicted values
            of the response are computed, based on the \code{\link{predict.glm}}
-           method. Corresponds to \code{\link{plogis}(\link{predict}(fit, type = ""response""))}.}
+           method. Corresponds to \code{\link{predict}(fit, type = ""response"")}.}
          }
 }
 \examples{

---FILE: man/sjp.glmer.Rd---
@@ -158,7 +158,7 @@ Thanks go to Robert Reijntjes from Leiden University Medical Center for sharing
 library(lme4)
 library(sjmisc)
 # create binary response
-sleepstudy$Reaction.dicho <- dicho(sleepstudy$Reaction, dichBy = ""md"")
+sleepstudy$Reaction.dicho <- dicho(sleepstudy$Reaction, dich.by = ""md"")
 # fit model
 fit <- glmer(Reaction.dicho ~ Days + (Days | Subject),
              sleepstudy,"
strengejacke,sjPlot,7fe80c82154537e58eb35bc40d17a69727fac59e,Daniel Ldecke,d.luedecke@uke.de,2015-07-29T07:03:15Z,Daniel Ldecke,d.luedecke@uke.de,2015-07-29T07:03:15Z,fixed UTF-8 encoding bug with view_df,R/helpfunctions.R;R/sjPlotGroupFrequencies.R;R/sjTabSPSS.R;man/sjp.aov1.Rd;man/sjp.frq.Rd;man/sjp.glm.Rd;man/sjp.glmm.Rd;man/sjp.gpt.Rd;man/sjp.grpfrq.Rd;man/sjp.int.Rd;man/sjp.likert.Rd;man/sjp.lm.Rd;man/sjp.lmm.Rd;man/sjp.xtab.Rd,False,True,True,False,20,20,40,"---FILE: R/helpfunctions.R---
@@ -740,9 +740,9 @@ sjs.frqci <- function(x) {
 
 
 sju.rmspc <- function(html.table) {
-  cleaned <- gsub(""      <"", ""<"", html.table, fixed = TRUE)
-  cleaned <- gsub(""    <"", ""<"", cleaned, fixed = TRUE)
-  cleaned <- gsub(""  <"", ""<"", cleaned, fixed = TRUE)
+  cleaned <- gsub(""      <"", ""<"", html.table, fixed = TRUE, useBytes = TRUE)
+  cleaned <- gsub(""    <"", ""<"", cleaned, fixed = TRUE, useBytes = TRUE)
+  cleaned <- gsub(""  <"", ""<"", cleaned, fixed = TRUE, useBytes = TRUE)
   return(cleaned)
 }
 

---FILE: R/sjPlotGroupFrequencies.R---
@@ -77,7 +77,7 @@ utils::globalVariables(c(""ypos"", ""wb"", ""ia"", ""mw"", ""stddev"", ""count""))
 #'          are displayed in one line and when a line break is inserted.
 #' @param breakLegendLabelsAt determines how many chars of the legend labels are 
 #'          displayed in one line and when a line break is inserted.
-#' @param gridBreaksAt set breaks for the y-axis, i.e. at every \code{gridBreaksAt}'th 
+#' @param gridBreaksAt set breaks for the axis, i.e. at every \code{gridBreaksAt}'th 
 #'          position a major grid is being printed.
 #' @param innerBoxPlotWidth width of the inner box plot that is plotted inside of violin plots. Only applies 
 #'          if \code{type = ""violins""}. Default value is 0.15

---FILE: R/sjTabSPSS.R---
@@ -353,14 +353,14 @@ view_df <- function(x,
   # -------------------------------------
   # set style attributes for main table tags
   # -------------------------------------
-  knitr <- gsub(""class="", ""style="", knitr, fixed = TRUE)
-  knitr <- gsub(""<table"", sprintf(""<table style=\""%s\"""", css.table), knitr, fixed = TRUE)
+  knitr <- gsub(""class="", ""style="", knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(""<table"", sprintf(""<table style=\""%s\"""", css.table), knitr, fixed = TRUE, useBytes = TRUE)
   # -------------------------------------
   # replace class-attributes with inline-style-definitions
   # -------------------------------------
-  knitr <- gsub(tag.tdata, css.tdata, knitr, fixed = TRUE)
-  knitr <- gsub(tag.thead, css.thead, knitr, fixed = TRUE)
-  knitr <- gsub(tag.arc, css.arc, knitr, fixed = TRUE)
+  knitr <- gsub(tag.tdata, css.tdata, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.thead, css.thead, knitr, fixed = TRUE, useBytes = TRUE)
+  knitr <- gsub(tag.arc, css.arc, knitr, fixed = TRUE, useBytes = TRUE)
   # -------------------------------------
   # remove spaces?
   # -------------------------------------

---FILE: man/sjp.aov1.Rd---
@@ -75,7 +75,7 @@ one line and when a line break is inserted into the title.}
 \item{breakLabelsAt}{determines how many chars of the category labels are displayed in
 one line and when a line break is inserted.}
 
-\item{gridBreaksAt}{set breaks for the y-axis, i.e. at every \code{gridBreaksAt}'th
+\item{gridBreaksAt}{set breaks for the axis, i.e. at every \code{gridBreaksAt}'th
 position a major grid is being printed.}
 
 \item{expand.grid}{logical, if \code{TRUE}, the plot grid is expanded, i.e. there is a small margin between

---FILE: man/sjp.frq.Rd---
@@ -97,7 +97,7 @@ one line and when a line break is inserted into the title.}
 \item{breakLabelsAt}{determines how many chars of the category labels are displayed in
 one line and when a line break is inserted.}
 
-\item{gridBreaksAt}{set breaks for the y-axis, i.e. at every \code{gridBreaksAt}'th
+\item{gridBreaksAt}{set breaks for the axis, i.e. at every \code{gridBreaksAt}'th
 position a major grid is being printed.}
 
 \item{innerBoxPlotWidth}{width of the inner box plot that is plotted inside of violin plots. Only applies

---FILE: man/sjp.glm.Rd---
@@ -53,7 +53,7 @@ one line and when a line break is inserted into the title.}
 \item{breakLabelsAt}{determines how many chars of the category labels are displayed in
 one line and when a line break is inserted.}
 
-\item{gridBreaksAt}{set breaks for the y-axis, i.e. at every \code{gridBreaksAt}'th
+\item{gridBreaksAt}{set breaks for the axis, i.e. at every \code{gridBreaksAt}'th
 position a major grid is being printed.}
 
 \item{transformTicks}{logical, if \code{TRUE}, the grid lines have exponential

---FILE: man/sjp.glmm.Rd---
@@ -55,7 +55,7 @@ one line and when a line break is inserted.}
 \item{breakLegendTitleAt}{determines how many chars of the legend's title
 are displayed in one line and when a line break is inserted.}
 
-\item{gridBreaksAt}{set breaks for the y-axis, i.e. at every \code{gridBreaksAt}'th
+\item{gridBreaksAt}{set breaks for the axis, i.e. at every \code{gridBreaksAt}'th
 position a major grid is being printed.}
 
 \item{transformTicks}{logical, if \code{TRUE}, the grid lines have exponential

---FILE: man/sjp.gpt.Rd---
@@ -68,7 +68,7 @@ are displayed in one line and when a line break is inserted.}
 \item{breakLegendLabelsAt}{determines how many chars of the legend labels are
 displayed in one line and when a line break is inserted.}
 
-\item{gridBreaksAt}{set breaks for the y-axis, i.e. at every \code{gridBreaksAt}'th
+\item{gridBreaksAt}{set breaks for the axis, i.e. at every \code{gridBreaksAt}'th
 position a major grid is being printed.}
 
 \item{showTotal}{logical, if \code{TRUE}, a total summary line for all aggregated

---FILE: man/sjp.grpfrq.Rd---
@@ -115,7 +115,7 @@ are displayed in one line and when a line break is inserted.}
 \item{breakLegendLabelsAt}{determines how many chars of the legend labels are
 displayed in one line and when a line break is inserted.}
 
-\item{gridBreaksAt}{set breaks for the y-axis, i.e. at every \code{gridBreaksAt}'th
+\item{gridBreaksAt}{set breaks for the axis, i.e. at every \code{gridBreaksAt}'th
 position a major grid is being printed.}
 
 \item{barPosition}{indicates whether bars should be positioned side-by-side (default)

---FILE: man/sjp.int.Rd---
@@ -134,7 +134,7 @@ outside this range that could not be plotted.}
 of the y scale. By default, this argument is set to \code{NULL}, i.e. the
 y-axis ranges from 0 to required maximum.}
 
-\item{gridBreaksAt}{set breaks for the y-axis, i.e. at every \code{gridBreaksAt}'th
+\item{gridBreaksAt}{set breaks for the axis, i.e. at every \code{gridBreaksAt}'th
 position a major grid is being printed.}
 
 \item{showInterceptLines}{If \code{TRUE}, the intercept and the estimate of the predictor

---FILE: man/sjp.likert.Rd---
@@ -117,7 +117,7 @@ E.g. \code{gridRange = 1.4} will set the axis from -140 to +140\%, however, only
 (valid) axis labels from -100 to +100\% are printed. Neutral categories are
 adjusted to the most left limit.}
 
-\item{gridBreaksAt}{set breaks for the y-axis, i.e. at every \code{gridBreaksAt}'th
+\item{gridBreaksAt}{set breaks for the axis, i.e. at every \code{gridBreaksAt}'th
 position a major grid is being printed.}
 
 \item{expand.grid}{logical, if \code{TRUE}, the plot grid is expanded, i.e. there is a small margin between

---FILE: man/sjp.lm.Rd---
@@ -72,7 +72,7 @@ one line and when a line break is inserted into the title.}
 \item{breakLabelsAt}{determines how many chars of the category labels are displayed in
 one line and when a line break is inserted.}
 
-\item{gridBreaksAt}{set breaks for the y-axis, i.e. at every \code{gridBreaksAt}'th
+\item{gridBreaksAt}{set breaks for the axis, i.e. at every \code{gridBreaksAt}'th
 position a major grid is being printed.}
 
 \item{coord.flip}{logical, if \code{TRUE} (default), predictors are plotted along the y-axis and estimate

---FILE: man/sjp.lmm.Rd---
@@ -55,7 +55,7 @@ one line and when a line break is inserted.}
 \item{breakLegendTitleAt}{determines how many chars of the legend's title
 are displayed in one line and when a line break is inserted.}
 
-\item{gridBreaksAt}{set breaks for the y-axis, i.e. at every \code{gridBreaksAt}'th
+\item{gridBreaksAt}{set breaks for the axis, i.e. at every \code{gridBreaksAt}'th
 position a major grid is being printed.}
 
 \item{geom.size}{size of the points that indicate the estimates. Default is 3.}

---FILE: man/sjp.xtab.Rd---
@@ -83,7 +83,7 @@ are displayed in one line and when a line break is inserted.}
 \item{breakLegendLabelsAt}{determines how many chars of the legend labels are
 displayed in one line and when a line break is inserted.}
 
-\item{gridBreaksAt}{set breaks for the y-axis, i.e. at every \code{gridBreaksAt}'th
+\item{gridBreaksAt}{set breaks for the axis, i.e. at every \code{gridBreaksAt}'th
 position a major grid is being printed.}
 
 \item{geom.size}{size resp. width of the geoms (bar width).}"
strengejacke,sjPlot,e136f610422e74d9f05eba01fce35af52607dd2c,Daniel Ldecke,d.luedecke@uke.de,2015-07-19T12:04:26Z,Daniel Ldecke,d.luedecke@uke.de,2015-07-19T12:04:26Z,bug fixes in sjp.gpt,R/sjPlotGroupPropTable.R;man/sjp.gpt.Rd,False,True,True,False,120,79,199,"---FILE: R/sjPlotGroupPropTable.R---
@@ -1,32 +1,47 @@
 #' @title Plot grouped proportional tables
 #' @name sjp.gpt
-#' 
+#'
 #' @description Plot grouped proportional crosstables, where the proportion of
 #'                each level of \code{x} for the highest category in \code{y}
-#'                is plotted, for each subgroup pf \code{groups}.
-#' 
-#' @param x
-#' @param y
-#' @param groups
-#' @param shape.fill.color
-#' @param shapes
-#' @param axisLabels
-#' @param showTotal
-#' @param showP
-#' @param showN
-#' 
-#' @return (Insisibily) returns the ggplot-object with the complete plot (\code{plot}) as well as the data frame that
-#'           was used for setting up the ggplot-object (\code{mydf}).
+#'                is plotted, for each subgroup of \code{groups}.
+#'
+#' @param x categorical variable, where the proportion of each categorie in the
+#'            highest category of \code{y} will be printed along the x-axis.
+#' @param y categorical or numeric variable. If not a binary variable, \code{y}
+#'            will be recoded into a binary variable, dichtomized at the highest
+#'            category and all remaining categories.
+#' @param groups grouping variable, which will define the y-axis
+#' @param shape.fill.color optional color vector, fill-color for non-filled shapes
+#' @param shapes numeric vector with shape styles, used to map the different
+#'          categories of \code{x}.
+#' @param axisLabels character vector with \code{groups} labels for the y-axis.
+#' @param showTotal logical, if \code{TRUE}, a total summary line for all aggregated
+#'          \code{groups} is added.
+#' @param showP logical, if \code{TRUE}, axis labels for groups will also contain
+#'          the results of the \code{\link[stats]{chisq.test}} of \code{x} and
+#'          \code{y} for each \code{groups}.
+#' @param showN logical, if \code{TRUE}, axis labels for groups will also contain
+#'          the total number of cases in each \code{groups}.
+#'
+#' @return (Insisibily) returns the ggplot-object with the complete plot
+#'           (\code{plot}) as well as the data frame that
+#'           was used for setting up the ggplot-object (\code{df}).
 #'
 #' @inheritParams sjp.grpfrq
 #' @inheritParams sjp.xtab
 #'
-#' @examples 
+#' @examples
 #' library(sjmisc)
 #' data(efc)
-#' 
+#'
+#' # the proportion of dependency levels in female
+#' # elderly, for each family carer's relationship
+#' # to elderly
 #' sjp.gpt(efc$e42dep, efc$e16sex, efc$e15relat)
-#' 
+#'
+#' # proportion of educational levels in highest
+#' # dependency category of elderly, for different
+#' # care levels
 #' sjp.gpt(efc$c172code, efc$e42dep, efc$n4pstu)
 #'
 #' @import ggplot2
@@ -35,19 +50,19 @@
 #' @importFrom scales percent
 #' @importFrom stats na.omit chisq.test
 #' @export
-sjp.gpt <- function(x, 
-                    y, 
-                    groups, 
+sjp.gpt <- function(x,
+                    y,
+                    groups,
                     geom.colors = ""Set1"",
                     geom.size = 4,
                     shape.fill.color = ""#f0f0f0"",
                     shapes = c(15, 16, 17, 18, 21, 22, 23, 24, 25, 7, 8, 9, 10, 12),
-                    title = NULL, 
-                    axisLabels = NULL, 
+                    title = NULL,
+                    axisLabels = NULL,
                     axisTitle.x = NULL,
                     axisTitle.y = NULL,
-                    legendTitle = NULL, 
-                    legendLabels = NULL, 
+                    legendTitle = NULL,
+                    legendLabels = NULL,
                     breakTitleAt = 50,
                     breakLabelsAt = 15,
                     breakLegendTitleAt = 20,
@@ -70,8 +85,8 @@ sjp.gpt <- function(x,
     ylabels <- ylabels[length(ylabels)]
   }
   if (is.null(axisLabels)) axisLabels <- sjmisc:::autoSetValueLabels(groups)
-  if (is.null(axisTitle.y)) axisTitle.y <- paste0(""Proportion of "", 
-                                                  sjmisc:::autoSetVariableLabels(x), 
+  if (is.null(axisTitle.y)) axisTitle.y <- paste0(""Proportion of "",
+                                                  sjmisc:::autoSetVariableLabels(x),
                                                   "" in "",
                                                   ylabels)
   if (is.null(legendTitle)) legendTitle <- sjmisc:::autoSetVariableLabels(x)
@@ -101,47 +116,57 @@ sjp.gpt <- function(x,
   mydf <- stats::na.omit(data.frame(grp = sjmisc::to_value(groups, keep.labels = F),
                                     x = sjmisc::to_factor(x),
                                     dep = sjmisc::to_value(y, keep.labels = F)))
-  # recode into all others and max
+  # ------------------------------------
+  # recode dependent variable's categorues
+  # max and all others, so we have proportion
+  # between maximux value and rest
+  # ------------------------------------
   mydf$dep <- sjmisc::rec(mydf$dep, ""max=1;else=0"")
   # ------------------------------------
   # group data by grouping variable, and inside
   # groups, group the x-variable
   # ------------------------------------
-  newdf <- mydf %>% 
-    dplyr::group_by(grp, x) %>% 
+  newdf <- mydf %>%
+    dplyr::group_by(grp, x) %>%
     dplyr::summarise(y = mean(dep))
-  
-  pvals <- mydf %>% 
-    dplyr::group_by(grp) %>% 
+  # ------------------------------------
+  # group data by grouping variable,
+  # and summarize N per group and chisq.test
+  # of grp and x within each group
+  # ------------------------------------
+  pvals <- mydf %>%
+    dplyr::group_by(grp) %>%
     dplyr::summarise(N = n(),
                      p = suppressWarnings(stats::chisq.test(table(x, dep))$p.value))
+  # ------------------------------------
   # copy p values
+  # ------------------------------------
   for (i in 1:length(pvals$grp)) group.p <- c(group.p, get_p_stars(pvals$p[i]))
+  # ------------------------------------
   # copy N
+  # ------------------------------------
   for (i in 1:length(pvals$grp)) group.n <- c(group.n, prettyNum(pvals$N[i],
                                                                  big.mark = "","",
-                                                                 scientific = F))  
+                                                                 scientific = F))
   # --------------------------------
-  # if we want total line, repeat all for 
+  # if we want total line, repeat all for
   # complete data frame
   # --------------------------------
   if (showTotal) {
-    tmp <- mydf %>% 
-      dplyr::group_by(x) %>% 
+    tmp <- mydf %>%
+      dplyr::group_by(x) %>%
       dplyr::summarise(y = mean(dep))
-    
-    pvals <- mydf %>% 
+    # pvalues and N
+    pvals <- mydf %>%
       dplyr::summarise(N = n(),
                        p = suppressWarnings(stats::chisq.test(table(x, dep))$p.value))
-
-    # append to final df
+    # bind total row to final df
     newdf <- dplyr::bind_rows(newdf, tmp)
-    
     # copy p values
     group.p <- c(group.p, get_p_stars(pvals$p))
     # copy N
-    group.n <- c(group.n, prettyNum(pvals$N, big.mark = "","", scientific = F))  
-
+    group.n <- c(group.n, prettyNum(pvals$N, big.mark = "","", scientific = F))
+    # add ""total"" to axis labels
     axisLabels <- c(axisLabels, ""Total"")
   }
   # ------------------------------------
@@ -154,30 +179,25 @@ sjp.gpt <- function(x,
   # ------------------------------------
   newdf$y <- sjmisc::to_value(newdf$y, keep.labels = F)
   # ------------------------------------
+  # add N and p-values to axis labels?
   # ------------------------------------
   if (showN) axisLabels <- paste0(axisLabels, "" (n="", group.n, "")"")
   if (showP) axisLabels <- paste0(axisLabels, "" "", group.p)
-  
-  pal.len <- length(legendLabels)
-  
   # --------------------------------------------------------
   # Set up axis limits
   # --------------------------------------------------------
-  if (is.null(axisLimits)) {
-    gridBreaksAt <- ggplot2::waiver()
-    axisLimits <- c(0, max(pretty(max(newdf$y, na.rm = TRUE), 10)))
-  } else {
-    # --------------------------------------------------------
-    # Set up grid breaks
-    # --------------------------------------------------------
-    if (is.null(gridBreaksAt))
-      gridbreaks <- ggplot2::waiver()
-    else
-      gridbreaks <- c(seq(axisLimits[1], axisLimits[2], by = gridBreaksAt))
-  }
+  if (is.null(axisLimits)) axisLimits <- c(0, max(pretty(max(newdf$y, na.rm = TRUE), 10)))
+  # --------------------------------------------------------
+  # Set up grid breaks
+  # --------------------------------------------------------
+  if (is.null(gridBreaksAt))
+    gridbreaks <- ggplot2::waiver()
+  else
+    gridbreaks <- c(seq(axisLimits[1], axisLimits[2], by = gridBreaksAt))
   # --------------------------------------------------------
   # Set up geom colors
   # --------------------------------------------------------
+  pal.len <- length(legendLabels)
   if (is.brewer.pal(geom.colors[1])) {
     geom.colors <- scales::brewer_pal(palette = geom.colors[1])(pal.len)
   } else if (geom.colors[1] == ""gs"") {
@@ -186,30 +206,36 @@ sjp.gpt <- function(x,
     warning(""More colors provided than needed. Shortening color palette."")
     geom.colors <- geom.colors[1:pal.len]
   }
-  
+  # --------------------------------------------------------
+  # Set up plot
+  # --------------------------------------------------------
   p <- ggplot(newdf, aes(x = rev(grp),
                          y = y,
                          colour = x,
                          shape = x)) +
     geom_point(size = geom.size, fill = shape.fill.color) +
     scale_y_continuous(labels = scales::percent,
-                       breaks = gridBreaksAt,
+                       breaks = gridbreaks,
                        limits = axisLimits) +
     scale_x_discrete(labels = rev(axisLabels)) +
-    scale_shape_manual(name = legendTitle, 
-                       labels = legendLabels, 
+    scale_shape_manual(name = legendTitle,
+                       labels = legendLabels,
                        values = shapes[1:pal.len]) +
-    scale_colour_manual(name = legendTitle, 
-                        labels = legendLabels, 
+    scale_colour_manual(name = legendTitle,
+                        labels = legendLabels,
                         values = geom.colors) +
     labs(x = axisTitle.x,
          y = axisTitle.y,
          title = title) +
     coord_flip()
-
+  # --------------------------------------------------------
+  # Annotate total line?
+  # --------------------------------------------------------
   if (showTotal && annotateTotal)
     p <- p + annotate(""rect"", xmin = 0.5,  xmax = 1.5, ymin = -Inf, ymax = Inf, alpha = 0.15)
-  
+  # --------------------------------------------------------
+  # print plot
+  # --------------------------------------------------------
   if (printPlot) print(p)
   invisible(structure(list(plot = p,
                            df = newdf)))

---FILE: man/sjp.gpt.Rd---
@@ -14,11 +14,14 @@ sjp.gpt(x, y, groups, geom.colors = ""Set1"", geom.size = 4,
   showP = TRUE, showN = TRUE, hideLegend = FALSE, printPlot = TRUE)
 }
 \arguments{
-\item{x}{}
+\item{x}{categorical variable, where the proportion of each categorie in the
+highest category of \code{y} will be printed along the x-axis.}
 
-\item{y}{}
+\item{y}{categorical or numeric variable. If not a binary variable, \code{y}
+will be recoded into a binary variable, dichtomized at the highest
+category and all remaining categories.}
 
-\item{groups}{}
+\item{groups}{grouping variable, which will define the y-axis}
 
 \item{geom.colors}{User defined color palette for geoms. If specified, must either be vector with color values
 of same length as groups defined in \code{varGroup}, or a specific color brewer palette code (see 'Note').}
@@ -28,16 +31,17 @@ Note that  bar and bin widths mostly need smaller values than dot sizes (i.e. if
 By default, \code{geom.size = NULL}, which means that this argument is automatically
 adjusted depending on the plot type.}
 
-\item{shape.fill.color}{}
+\item{shape.fill.color}{optional color vector, fill-color for non-filled shapes}
 
-\item{shapes}{}
+\item{shapes}{numeric vector with shape styles, used to map the different
+categories of \code{x}.}
 
 \item{title}{plot title as string. Example: \code{title = ""my title""}.
 Use \code{NULL} to automatically detect variable names that will be used as title
 (see \code{\link[sjmisc]{set_label}}) for details). If \code{title = """"},
 no title is printed.}
 
-\item{axisLabels}{}
+\item{axisLabels}{character vector with \code{groups} labels for the y-axis.}
 
 \item{axisTitle.x}{title for the x-axis. By default, \code{""""} is used, i.e. no title
 is printed. If \code{axisTitle.x = NULL}, the variable name will be
@@ -67,32 +71,43 @@ displayed in one line and when a line break is inserted.}
 \item{gridBreaksAt}{set breaks for the y-axis, i.e. at every \code{gridBreaksAt}'th
 position a major grid is being printed.}
 
-\item{showTotal}{}
+\item{showTotal}{logical, if \code{TRUE}, a total summary line for all aggregated
+\code{groups} is added.}
 
-\item{showP}{}
+\item{showP}{logical, if \code{TRUE}, axis labels for groups will also contain
+the results of the \code{\link[stats]{chisq.test}} of \code{x} and
+\code{y} for each \code{groups}.}
 
-\item{showN}{}
+\item{showN}{logical, if \code{TRUE}, axis labels for groups will also contain
+         the total number of cases in each \code{groups}.}
 
 \item{hideLegend}{logical, indicates whether legend (guide) should be shown or not.}
 
 \item{printPlot}{logical, if \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }
 \value{
-(Insisibily) returns the ggplot-object with the complete plot (\code{plot}) as well as the data frame that
-          was used for setting up the ggplot-object (\code{mydf}).
+(Insisibily) returns the ggplot-object with the complete plot
+          (\code{plot}) as well as the data frame that
+          was used for setting up the ggplot-object (\code{df}).
 }
 \description{
 Plot grouped proportional crosstables, where the proportion of
                each level of \code{x} for the highest category in \code{y}
-               is plotted, for each subgroup pf \code{groups}.
+               is plotted, for each subgroup of \code{groups}.
 }
 \examples{
 library(sjmisc)
 data(efc)
 
+# the proportion of dependency levels in female
+# elderly, for each family carer's relationship
+# to elderly
 sjp.gpt(efc$e42dep, efc$e16sex, efc$e15relat)
 
+# proportion of educational levels in highest
+# dependency category of elderly, for different
+# care levels
 sjp.gpt(efc$c172code, efc$e42dep, efc$n4pstu)
 }
 "
strengejacke,sjPlot,5d202a9253a3a63fe157d7cfa1bf23df142c889f,Daniel Ldecke,d.luedecke@uke.de,2015-07-17T13:40:37Z,Daniel Ldecke,d.luedecke@uke.de,2015-07-17T13:40:37Z,minor bug fix,NAMESPACE;NEWS;R/helpfunctions.R;R/sjPlotGroupPropTable.R;R/sjTabSPSS.R;README.md;man/sjp.gpt.Rd,False,True,True,False,194,12,206,"---FILE: NAMESPACE---
@@ -18,6 +18,7 @@ export(sjp.frq)
 export(sjp.glm)
 export(sjp.glmer)
 export(sjp.glmm)
+export(sjp.gpt)
 export(sjp.grpfrq)
 export(sjp.int)
 export(sjp.likert)

---FILE: NEWS---
@@ -9,6 +9,7 @@ Changes to functions:
 Bug fixes:
 * ""sjp.grpfrq"" did not show correct number of missings (argument ""na.rm = FALSE""), if grouping variable startet with zero.
 * Fixed bug with ""sjp.frq"" and ""sjt.frq"", when variable was a labelled factor with lowest factor level smaller than 1.
+* Fixed bug in ""view_df"" with parameter ""showFreq = TRUE"", when variable was a character vector.
 
 Version 1.8.2
 ------------------------------------------------------------------------------

---FILE: R/helpfunctions.R---
@@ -83,6 +83,17 @@ create.frq.df <- function(varCount,
                           startAxisAt = ""auto"",
                           weightBy = NULL) {
   #---------------------------------------------------
+  # variable with only mising?
+  #---------------------------------------------------
+  if (length(stats::na.omit(varCount)) == 0) {
+    mydat <- data.frame(var = NA,
+                        frq = NA,
+                        prz = NA,
+                        valid = NA,
+                        cumperc = NA)
+    return(invisible(structure(list(mydat = mydat))))
+  }
+  #---------------------------------------------------
   # weight variable
   #---------------------------------------------------
   if (!is.null(weightBy)) varCount <- sjmisc::weight(varCount, weightBy)
@@ -91,7 +102,7 @@ create.frq.df <- function(varCount,
   #---------------------------------------------------
   df <- as.data.frame(table(varCount))
   # name columns
-  names(df) <- c(""y"", ""Freq"")
+  colnames(df) <- c(""y"", ""Freq"")
   #---------------------------------------------------
   # do we have label values associated with value labels?
   # if yes, we assume that these values are the range
@@ -120,7 +131,7 @@ create.frq.df <- function(varCount,
       # amount of categories (=number of rows) in dataframe instead
       llabels <- as.character(mydat$var)
     }
-  } else {
+  } else if (!is.character(varCount)) {
     # --------------------------------------------------------
     # Define amount of category, include zero counts
     # --------------------------------------------------------
@@ -189,6 +200,11 @@ create.frq.df <- function(varCount,
       # amount of categories (=number of rows) in dataframe instead
       llabels <- c(startAxisAt:(nrow(mydat) + startAxisAt - 1))
     }
+  } else {
+    mydat <- df
+    colnames(mydat) <- c(""var"", ""frq"")
+    catmin <- minval <- min(varCount, na.rm = TRUE)
+    catcount <- length(unique(stats::na.omit(varCount)))
   }
   # caculate missings here
   missingcount <- sum(is.na(varCount))

---FILE: R/sjPlotGroupPropTable.R---
@@ -0,0 +1,140 @@
+#' @title Plot grouped proportional tables
+#' @name sjp.gpt
+#' 
+#' @description Plot proportional crosstables (contingency tables) of two variables as ggplot diagram.
+#' 
+#' 
+#' @return (Insisibily) returns the ggplot-object with the complete plot (\code{plot}) as well as the data frame that
+#'           was used for setting up the ggplot-object (\code{mydf}).
+#'
+#'
+#' @import ggplot2
+#' @import dplyr
+#' @import sjmisc
+#' @importFrom scales percent
+#' @importFrom stats na.omit
+#' @export
+sjp.gpt <- function(x, y, groups, legendTitle, legendLabels) {
+  # ------------------------------------
+  # final data frae for plot
+  # ------------------------------------
+  newdf <- data.frame()
+  group.p <- c()
+  group.n <- c()
+  # ------------------------------------
+  # create data frame
+  # ------------------------------------
+  mydf <- data.frame(grp = sjmisc::to_value(groups, keep.labels = F),
+                     x = sjmisc::to_factor(x),
+                     dep = sjmisc::to_value(y, keep.labels = F))
+  len.x <- length(unique(na.omit(x)))
+  # ------------------------------------
+  # create grouping variable
+  # ------------------------------------
+  groups <- sort(unique(na.omit(sjmisc::to_value(groups))))
+  # ------------------------------------
+  # iterate all groups
+  # ------------------------------------
+  for (cnt in groups) {
+    # ------------------------------------
+    # select cases from groups
+    # ------------------------------------
+    dummy <- dplyr::filter(mydf, grp == cnt)
+    # ------------------------------------
+    # 
+    # ------------------------------------
+    y <- prop.table(table(dummy$x, dummy$dep), margin = 1)[, 2]
+    # -----------------
+    # p-Werte f?r Gruppenunterschiede lo/hi income
+    #---------------------
+    pval <- chisq.test(table(dummy$x, dummy$dep))$p.value
+    stern <- c("""")
+    if (pval < 0.001) {
+      stern <- c(""***"")
+    } else if (pval < 0.01) {
+      stern <- c(""**"")
+    } else if (pval < 0.05) {
+      stern <- c(""*"")
+    }
+    group.p <- c(group.p, stern)
+    group.n <- c(group.n, prettyNum(sum(table(dummy$x, dummy$dep)),
+                                    big.mark = "","",
+                                    scientific = F))
+    newdf <- data.frame(rbind(newdf,
+                              cbind(grp = cnt,
+                                    x = 1:len.x,
+                                    y = y)))
+  }
+  y <- prop.table(table(mydf$x, mydf$dep), margin = 1)[, 2]
+  
+  newdf <- data.frame(rbind(newdf,
+                            cbind(grp = ""Total"",
+                                  x = 1:len.x,
+                                  y = y)))
+
+  pval <- chisq.test(table(mydf$x, mydf$dep))$p.value
+  stern <- c("""")
+  if (pval < 0.001) {
+    stern <- c(""***"")
+  } else if (pval < 0.01) {
+    stern <- c(""**"")
+  } else if (pval < 0.05) {
+    stern <- c(""*"")
+  }
+  group.p <- c(group.p, stern)
+  group.n <- c(group.n, prettyNum(sum(table(mydf$x, mydf$dep)),
+                                  big.mark = "","",
+                                  scientific = F))
+  
+  # ------------------------------------
+  # country und inc sind kategoriale daten. wichtig
+  # fr die Achsendarstellung beim Plot
+  # ------------------------------------
+  newdf$grp <- sjmisc::to_factor(newdf$country)
+  newdf$x <- sjmisc::to_facto(newdf$x)
+  
+  #Einf?gen anderer Labels f?r Legende??!!###############
+  levels(newdf$x) <- legendLabels
+  newdf$x <- set_label(newdf$x, legendTitle)
+  # ------------------------------------
+  # Hier die Gren fr den Plot einstellen!!!
+  # ------------------------------------
+  symbolgroesse <- 4
+  # ------------------------------------
+  # plot starten. mit ""aes"" geben wir allgemeine
+  # Merkmale fr den Plot an, und welche Variablen
+  # in unserem Datensatz diese Merkmale beschreiben.
+  # der x-Achsenabschnitt soll durch die Lndergruppen
+  # dargestellt werden. Auf der Y-Achse werden die Forgone-Anteile
+  # gezeichnet. ""Colour"" und ""shape"" bedeutet, dass die gemalten
+  # ""geoms"" (Objekte wie Punkte, Linien, was auch immer) sich
+  # in ihrer Farbe (colour) und Form (shape) unterscheiden sollen.
+  # Das Unterscheidungsmerkmal ist ""inc"", also die Einkommensgruppen.
+  # Wrde man shape und colour nicht definieren, wren alle
+  # geoms einfarbig.
+  # ------------------------------------
+  sternnamen <- paste0(axisLabels, "" (n="", group.n, "") "",  group.p)
+  p <- ggplot(newdf, aes(x = rev(grp),     # country auf der x-achse abtragen
+                         y = y,     # forgone ist metrisch (prozenanteil), kommt auf die y-achse
+                         colour = x,    # ""inc"" ist gruppierungsvariable. Farben und
+                         shape = x)) +  # Punkt-Form sollen sich nach inc-gruppen unterscheiden
+    # Punkte malen
+    geom_point(size = symbolgroesse, fill = ""#f0f0f0"") +
+    # die Y-Achse soll keine Zahlen-, sondern Prozent
+    # Werte als Labels haben
+    scale_y_continuous(labels = percent, breaks = seq(0,0.35, 0.05)) +
+    # Bei X-Achse Lnder-ID durch Namen ersetzen
+    scale_x_discrete(labels = rev(sternnamen)) +
+    # farben fr die Punkte
+    scale_color_manual(values = c(""#000000"",""#555555"",""#999999""), name = ""Income tertiles"") +
+    scale_shape_manual(name = ""Income tertiles"", values = c(21, 22, 24)) +
+    # Achsenbeschriftungen
+    labs(x = axisTitle.x,
+         y = axisTitle.y,
+         title = title) +
+    # Plot ""drehen"", sodass Lnder links stehen
+    coord_flip() +
+    annotate(""rect"", xmin = 0.5,  xmax = 1.5, ymin = -Inf, ymax = Inf, alpha = 0.15)
+  
+  print(p)
+}

---FILE: R/sjTabSPSS.R---
@@ -283,7 +283,7 @@ view_df <- function(x,
     # frequencies
     # ----------------------------
     if (showFreq) {
-      valstring <- c("""")
+      valstring <- """"
       # check if we have a valid index
       if (index <= ncol(x) && !is.null(df.val[[index]])) {
         # create frequency table. same function as for
@@ -292,11 +292,14 @@ view_df <- function(x,
                               df.val[[index]], 
                               sjmisc::get_values(x[[index]]),
                               20)$mydat$frq
-        # ftab <- as.numeric(table(x[[index]]))
         # remove last value, which is N for NA
-        for (i in 1:(length(ftab) - 1)) {
-          valstring <- paste0(valstring, ftab[i])
-          if (i < length(ftab)) valstring <- paste0(valstring, ""<br>"")
+        if (is.na(ftab)) {
+          valstring <- ""<NA>""
+        } else {
+          for (i in 1:(length(ftab) - 1)) {
+            valstring <- paste0(valstring, ftab[i])
+            if (i < length(ftab)) valstring <- paste0(valstring, ""<br>"")
+          }
         }
       } else {
         valstring <- """"
@@ -307,7 +310,7 @@ view_df <- function(x,
     # percentage of frequencies
     # ----------------------------
     if (showPerc) {
-      valstring <- c("""")
+      valstring <- """"
       # check for valid indices
       if (index <= ncol(x) && !is.null(df.val[[index]])) {
         # create frequency table, but only get valid percentages
@@ -316,9 +319,13 @@ view_df <- function(x,
                               sjmisc::get_values(x[[index]]),
                               20)$mydat$valid
         # remove last value, which is a NA dummy
-        for (i in 1:(length(ftab) - 1)) {
-          valstring <- paste0(valstring, sprintf(""%.2f"", ftab[i]))
-          if (i < length(ftab)) valstring <- paste0(valstring, ""<br>"")
+        if (is.na(ftab)) {
+          valstring <- ""<NA>""
+        } else {
+          for (i in 1:(length(ftab) - 1)) {
+            valstring <- paste0(valstring, sprintf(""%.2f"", ftab[i]))
+            if (i < length(ftab)) valstring <- paste0(valstring, ""<br>"")
+          }
         }
       } else {
         valstring <- """"

---FILE: README.md---
@@ -50,4 +50,5 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 
 #### Bug fixes
 * `sjp.grpfrq` did not show correct number of missings (argument `na.rm = FALSE`), if grouping variable startet with zero.
-* Fixed bug with `sjp.frq` and `sjt.frq`, when variable was a labelled factor with lowest factor level smaller than 1.
\ No newline at end of file
+* Fixed bug with `sjp.frq` and `sjt.frq`, when variable was a labelled factor with lowest factor level smaller than 1.
+* Fixed bug in `view_df` with parameter `showFreq = TRUE`, when variable was a character vector.
\ No newline at end of file

---FILE: man/sjp.gpt.Rd---
@@ -0,0 +1,16 @@
+% Generated by roxygen2 (4.1.1): do not edit by hand
+% Please edit documentation in R/sjPlotGroupPropTable.R
+\name{sjp.gpt}
+\alias{sjp.gpt}
+\title{Plot grouped proportional tables}
+\usage{
+sjp.gpt(x, y, groups, legendTitle, legendLabels)
+}
+\value{
+(Insisibily) returns the ggplot-object with the complete plot (\code{plot}) as well as the data frame that
+          was used for setting up the ggplot-object (\code{mydf}).
+}
+\description{
+Plot proportional crosstables (contingency tables) of two variables as ggplot diagram.
+}
+"
strengejacke,sjPlot,0415168c0c7c73131e7d4359274414a18f448293,Daniel Ldecke,d.luedecke@uke.de,2015-07-08T17:16:17Z,Daniel Ldecke,d.luedecke@uke.de,2015-07-08T17:16:17Z,minor bug fixes,R/sjPlotFrequencies.R;R/sjTabFrequencies.R;man/sjt.xtab.Rd,False,True,True,False,23,12,35,"---FILE: R/sjPlotFrequencies.R---
@@ -267,14 +267,19 @@ sjp.frq <- function(varCount,
   # check color argument
   # --------------------------------------------------------
   if (is.null(geom.colors)) {
-    geom.colors <- waiver()
+    geom.colors <- ggplot2::waiver()
   } else if (length(geom.colors) > 1) {
     geom.colors <- geom.colors[1]
   }
   # --------------------------------------------------------
+  # save label values. needed later to determine correct
+  # amount of categories
+  # --------------------------------------------------------
+  labelvalues <- sjmisc::get_values(varCount)
+  # --------------------------------------------------------
   # count variable may not be a factor!
   # --------------------------------------------------------
-  if (is.factor(varCount)) varCount <- sjmisc::to_value(varCount)
+  if (is.factor(varCount)) varCount <- sjmisc::to_value(varCount, keep.labels = F)
   # --------------------------------------------------------
   # We have several options to name the plot type
   # Here we will reduce it to a unique value
@@ -287,7 +292,7 @@ sjp.frq <- function(varCount,
   if (type == ""box"" || type == ""boxplot"") type <- ""boxplots""
   if (type == ""v"" || type == ""violins"") type <- ""violin""
   if (expand.grid == TRUE) {
-    expand.grid <- waiver()
+    expand.grid <- ggplot2::waiver()
   } else {
     expand.grid <- c(0, 0)
   }
@@ -333,13 +338,13 @@ sjp.frq <- function(varCount,
                                   autoGroupCount = agcnt)
     # set label attributes
     varCount <- sjmisc::set_val_labels(varCount, axisLabels.x)
+    # --------------------------------------------------------
+    # save label values. needed later to determine correct
+    # amount of categories
+    # --------------------------------------------------------
+    labelvalues <- sjmisc::get_values(varCount)
   }
   # --------------------------------------------------------
-  # save label values. needed later to determine correct
-  # amount of categories
-  # --------------------------------------------------------
-  labelvalues <- sjmisc::get_values(varCount)
-  # --------------------------------------------------------
   # unlist labels
   # --------------------------------------------------------
   if (!is.null(axisLabels.x) && is.list(axisLabels.x)) axisLabels.x <- unlistlabels(axisLabels.x)

---FILE: R/sjTabFrequencies.R---
@@ -477,7 +477,12 @@ sjt.frq <- function(data,
       orivar <- var <- as.numeric(as.factor(data[[cnt]]))
     # here we have numeric or factor variables
     } else {
-      orivar <- var <- sjmisc::to_value(data[[cnt]])
+      # save variable values. these values may change when converting
+      # factors to numeric, so save these values before
+      var.values <- sjmisc::get_values(data[[cnt]])
+      # convert to numeric
+      orivar <- var <- sjmisc::to_value(data[[cnt]], 
+                                        keep.labels = F)
     }
     # -----------------------------------------------
     # check for length of unique values and skip if too long
@@ -499,6 +504,7 @@ sjt.frq <- function(data,
                                autoGroupCount = agcnt)
       # set labels
       var <- sjmisc::set_val_labels(var, valueLabels[[cnt]])
+      var.values <- sjmisc::get_values(var)
     }
     # retrieve summary
     varsummary <- summary(var)
@@ -512,7 +518,7 @@ sjt.frq <- function(data,
     #---------------------------------------------------
     df.frq <- create.frq.df(var, 
                             valueLabels[[cnt]], 
-                            sjmisc::get_values(var),
+                            var.values,
                             -1, 
                             sort.frq, 
                             weightBy = weightBy)

---FILE: man/sjt.xtab.Rd---
@@ -10,7 +10,7 @@ sjt.xtab(var.row, var.col, var.grp = NULL, weightBy = NULL, digits = 1,
   stringTotal = ""Total"", showObserved = TRUE, showCellPerc = FALSE,
   showRowPerc = FALSE, showColPerc = FALSE, showExpected = FALSE,
   showTotalN = FALSE, showHorizontalLine = FALSE, showSummary = TRUE,
-  showLegend = TRUE, showNA = FALSE, labelNA = ""NA"", tdcol.n = ""black"",
+  showLegend = FALSE, showNA = FALSE, labelNA = ""NA"", tdcol.n = ""black"",
   tdcol.expected = ""#339999"", tdcol.cell = ""#993333"",
   tdcol.row = ""#333399"", tdcol.col = ""#339933"", highlightTotal = FALSE,
   highlightColor = ""#f8f8f8"", percSign = ""&nbsp;&#37;"", hundret = ""100.0"",
@@ -75,7 +75,7 @@ Cramer's V or Phi-value etc. is shown. If a cell contains expected values lower
 if df is 1), the Fisher's excact test (see \code{\link{fisher.test}}) is computed instead of Chi-square test.
 If the table's matrix is larger than 2x2, Fisher's excact test with Monte Carlo simulation is computed.}
 
-\item{showLegend}{logical, if \code{TRUE} (default), the color legend for coloring observed and expected
+\item{showLegend}{logical, if \code{TRUE}, the color legend for coloring observed and expected
 values as well as cell, row and column percentages is shown. See \code{tdcol.n},
 \code{tdcol.expected}, \code{tdcol.cell}, \code{tdcol.row} and \code{tdcol.col}.}
 "
strengejacke,sjPlot,14ec0aa96bb72b6dcfc1f7372cd467886ba05ea2,Daniel Ldecke,d.luedecke@uke.de,2015-07-07T19:07:27Z,Daniel Ldecke,d.luedecke@uke.de,2015-07-07T19:07:27Z,"fix bug with ""na.rm = F"" in ""sjp.grpfrq""",R/sjPlotGroupFrequencies.R,False,True,True,False,1,1,2,"---FILE: R/sjPlotGroupFrequencies.R---
@@ -479,7 +479,7 @@ sjp.grpfrq <- function(varCount,
     # --------------------------------------------------------
     if (!na.rm) {
       # get amount of missings
-      frq <- length(which(is.na(varCount[which(varGroup == i)])))
+      frq <- sum(is.na(varCount[which(varGroup == as.numeric(dfgrp$Var1[i]))]))
       # create data frame
       tmpdf <- data.frame(cbind(count = catcount + 1, 
                                 group, "
strengejacke,sjPlot,94131701b0558c6fb58eaab11e19304349bc8c25,Daniel Ldecke,d.luedecke@uke.de,2015-07-04T19:23:09Z,Daniel Ldecke,d.luedecke@uke.de,2015-07-04T19:23:09Z,fix read.me,README.md,False,False,False,False,0,3,3,"---FILE: README.md---
@@ -1,6 +1,3 @@
----
-output: pdf_document
----
 sjPlot - Data Visualization for Statistics in Social Science
 ------------------------------------------------------------------------------
 Collection of plotting and table output functions for data visualization. Results of various statistical analyses (that are commonly used in social sciences) can be visualized using this package, including simple and cross tabulated frequencies, histograms, box plots, (generalized) linear models, mixed effects models, PCA and correlation matrices, cluster analyses, scatter plots, Likert scales, effects plots of interaction terms in regression models, constructing index or score variables and much more."
strengejacke,sjPlot,5b2ddf88acd9d22984e3cbbbebba907b4f66194d,Daniel Ldecke,d.luedecke@uke.de,2015-06-30T07:07:50Z,Daniel Ldecke,d.luedecke@uke.de,2015-06-30T07:07:50Z,"revamp docs, prepare CRAN submit, fix new CRAN requirements",DESCRIPTION;NAMESPACE;NEWS;R/helpfunctions.R;R/sjPlotClusterAnalysis.R;R/sjPlotCorr.R;R/sjPlotDist.R;R/sjPlotFrequencies.R;R/sjPlotGLME.R;R/sjPlotGroupFrequencies.R;R/sjPlotInteractions.R;R/sjPlotLikert.R;R/sjPlotLinreg.R;R/sjPlotOdds.R;R/sjPlotOddsMultiple.R;R/sjPlotPCA.R;R/sjPlotPropTable.R;R/sjPlotScatter.R;R/sjPlotSetTheme.R;R/sjPlotStackFrequencies.R;R/sjTabCorr.R;R/sjTabDataFrame.R;R/sjTabFrequencies.R;R/sjTabGrpmean.R;R/sjTabItemAnalysis.R;R/sjTabLinReg.R;R/sjTabMannWhitney.R;R/sjTabOdds.R;R/sjTabPCA.R;R/sjTabPropTable.R;R/sjTabSPSS.R;R/sjTabStackFrq.R;README.md;man/sjPlot-package.Rd;man/sjp.int.Rd;man/sjt.corr.Rd;man/sjt.df.Rd;man/sjt.frq.Rd;man/sjt.glm.Rd;man/sjt.glmer.Rd;man/sjt.grpmean.Rd;man/sjt.itemanalysis.Rd;man/sjt.lm.Rd;man/sjt.lmer.Rd;man/sjt.mwu.Rd;man/sjt.pca.Rd;man/sjt.stackfrq.Rd;man/sjt.xtab.Rd;man/view_df.Rd,False,True,True,False,630,846,1476,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.8.1-8
-Date: 2015-06-25
+Version: 1.8.1-10
+Date: 2015-06-30
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of plotting and table output functions for data visualization. 
@@ -13,7 +13,7 @@ Description: Collection of plotting and table output functions for data visualiz
              correlation matrices, cluster analyses, scatter plots, Likert scales, 
              effects plots of regression models (including interaction terms) and much more.
 License: GPL-3
-Depends: R (>= 3.1), stats
+Depends: R (>= 3.1), stats, grDevices
 Imports: car, dplyr (>= 0.4.1), ggplot2, grid, MASS, psych, scales, sjmisc (>= 1.0.3), tidyr (>= 0.2.0)
 Suggests: AICcmodavg, arm, cluster, effects, lme4, lmerTest, lmtest, lsmeans
 URL: https://github.com/sjPlot/devel

---FILE: NAMESPACE---
@@ -59,9 +59,28 @@ importFrom(car,ncvTest)
 importFrom(car,outlierTest)
 importFrom(car,spreadLevelPlot)
 importFrom(car,vif)
+importFrom(grDevices,axisTicks)
 importFrom(grid,unit)
 importFrom(psych,KMO)
 importFrom(psych,describe)
 importFrom(scales,brewer_pal)
 importFrom(scales,grey_pal)
 importFrom(scales,percent)
+importFrom(stats,chisq.test)
+importFrom(stats,coef)
+importFrom(stats,dchisq)
+importFrom(stats,df)
+importFrom(stats,dnorm)
+importFrom(stats,dt)
+importFrom(stats,fisher.test)
+importFrom(stats,model.matrix)
+importFrom(stats,na.omit)
+importFrom(stats,pchisq)
+importFrom(stats,pf)
+importFrom(stats,pnorm)
+importFrom(stats,pt)
+importFrom(stats,qchisq)
+importFrom(stats,qf)
+importFrom(stats,qnorm)
+importFrom(stats,qt)
+importFrom(stats,sd)

---FILE: NEWS---
@@ -1,4 +1,4 @@
-Version 1.8.1-8
+Version 1.8.1-10
 ------------------------------------------------------------------------------
 General:
 * Package documentation got major revisions.
@@ -15,6 +15,7 @@ Changes to functions:
 * Added parameter ""axisLimits.x"" to ""sjp.int"", ""sjp.frq"" and ""sjp.grpfrq"".
 * Added parameter ""showAICc"" to ""sjt.lm"", ""sjt.glm"", ""sjt.lmer"" and ""sjt.glmer"" to print second-order AIC.
 * Improved automatic y-axis-limit detection in ""sjp.frq"" and ""sjp.grpfrq"".
+* For ""sjt.lm"" and ""sjt.glm"", if ""digits.p"" is greater than 3, p-values less than 0.001 will no longer be abbreviated to ""<0.001"". Instead, the exact value (rounded to digits.p) will be printed.
 * Minor improvements to ""sjp.likert"", ""sjp.int"", ""sjp.glm"", ""sjp.frq"" and ""sjp.grpfrq"".
 
 Bug fixes:

---FILE: R/helpfunctions.R---
@@ -3,9 +3,10 @@
 
 # function to create pretty breaks
 # for log-scales
+#' @importFrom grDevices axisTicks
 base_breaks <- function(n = 10) {
   function(x) {
-    axisTicks(log10(range(x, na.rm = TRUE)), log = TRUE, nint = n)
+    grDevices::axisTicks(log10(range(x, na.rm = TRUE)), log = TRUE, nint = n)
   }
 }
 
@@ -71,6 +72,7 @@ out.html.table <- function(no.output, file, knitr, toWrite, useViewer) {
 
 # Create frequency data frame of a variable
 # for sjp and sjt frq functions
+#' @importFrom stats na.omit
 create.frq.df <- function(varCount,
                           llabels,
                           labelvalues,
@@ -151,14 +153,14 @@ create.frq.df <- function(varCount,
       # check if we have much less labels than values
       # so there might be a labelling mistake with
       # the variable
-      if (length(llabels) < length(unique(na.omit(varCount)))) {
+      if (length(llabels) < length(unique(stats::na.omit(varCount)))) {
         warning(""Variable has less labels than unique values. Output might be incorrect. Please check value labels."", call. = F)
       }
       catcount <- startAxisAt + length(llabels) - 1
     } else {
       # determine maximum values
       # first, check the total amount of different factor levels
-      catcount_1 <- length(unique(na.omit(varCount)))
+      catcount_1 <- length(unique(stats::na.omit(varCount)))
       # second, check the maximum factor level
       catcount_2 <- max(varCount, na.rm = TRUE)
       # if categories start with zero, fix this here
@@ -202,7 +204,7 @@ create.frq.df <- function(varCount,
     mydat <- data.frame(cbind(mydat, prz = c(round(100 * mydat$frq / length(varCount), round.prz))))
   } else {
     # also add a columns with percentage values of count distribution
-    mydat <- data.frame(cbind(mydat, prz = c(round(100 * mydat$frq / length(na.omit(varCount)), round.prz))))
+    mydat <- data.frame(cbind(mydat, prz = c(round(100 * mydat$frq / length(stats::na.omit(varCount)), round.prz))))
   }
   # --------------------------------------------------------
   # Order categories ascending or descending
@@ -216,7 +218,7 @@ create.frq.df <- function(varCount,
   # --------------------------------------------------------
   # add valid and cumulative percentages
   # --------------------------------------------------------
-  mydat$valid <- c(round(100 * mydat$frq / length(na.omit(varCount)), round.prz))
+  mydat$valid <- c(round(100 * mydat$frq / length(stats::na.omit(varCount)), round.prz))
   mydat$cumperc <- cumsum(mydat$valid)
   # --------------------------------------------------------
   # check if all categories are in table. if first category does not
@@ -280,6 +282,7 @@ is.brewer.pal <- function(pal) {
 
 
 # Calculate statistics of cross tabs
+#' @importFrom stats chisq.test fisher.test
 crosstabsum <- function(ftab) {
   # --------------------------------------------------------
   # check p-value-style option
@@ -291,15 +294,15 @@ crosstabsum <- function(ftab) {
     p_zero <- ""0""
   }
   # calculate chi square value
-  chsq <- chisq.test(ftab)
+  chsq <- stats::chisq.test(ftab)
   tab <- sjmisc::table_values(ftab)
   fish <- NULL
   # check whether variables are dichotome or if they have more
   # than two categories. if they have more, use Cramer's V to calculate
   # the contingency coefficient
   if (nrow(ftab) > 2 || ncol(ftab) > 2) {
     # if minimum expected values below 5, compute fisher's exact test
-    if (min(tab$expected) < 5 || (min(tab$expected) < 10 && chsq$parameter == 1)) fish <- fisher.test(ftab, simulate.p.value = TRUE)
+    if (min(tab$expected) < 5 || (min(tab$expected) < 10 && chsq$parameter == 1)) fish <- stats::fisher.test(ftab, simulate.p.value = TRUE)
     # check whether fisher's test or chi-squared should be printed
     if (is.null(fish)) {
       if (chsq$p.value < 0.001) {
@@ -340,7 +343,7 @@ crosstabsum <- function(ftab) {
   # the degree of association
   } else {
     # if minimum expected values below 5, compute fisher's exact test
-    if (min(tab$expected) < 5 || (min(tab$expected) < 10 && chsq$parameter == 1)) fish <- fisher.test(ftab)
+    if (min(tab$expected) < 5 || (min(tab$expected) < 10 && chsq$parameter == 1)) fish <- stats::fisher.test(ftab)
     # check whether fisher's test or chi-squared should be printed
     if (is.null(fish)) {
       modsum <- as.character(as.expression(

---FILE: R/sjPlotClusterAnalysis.R---
@@ -1,5 +1,5 @@
 # bind global variables
-utils::globalVariables(c(""xpos"", ""value"", ""Var2"", ""grp"", ""prc"", ""fg"", ""cprc"", ""se"", ""group""))
+utils::globalVariables(c(""xpos"", ""value"", ""Var2"", ""grp"", ""prc"", ""fg"", ""cprc"", ""se"", ""group"", ""var"", ""kmeans""))
 
 
 #' @title Compute quick cluster analysis
@@ -125,6 +125,7 @@ utils::globalVariables(c(""xpos"", ""value"", ""Var2"", ""grp"", ""prc"", ""fg"", ""cprc"", ""s
 #' 
 #' @import ggplot2
 #' @import sjmisc
+#' @importFrom stats na.omit
 #' @export
 sjc.qclus <- function(data,
                       groupcount = NULL,
@@ -168,7 +169,7 @@ sjc.qclus <- function(data,
   rownames(data) <- c(1:nrow(data))
   data.origin <- data
   # remove missings
-  data <- na.omit(data)
+  data <- stats::na.omit(data)
   if (!is.null(axisLabels.x) && is.list(axisLabels.x)) axisLabels.x <- unlistlabels(axisLabels.x)
   if (!is.null(legendLabels) && is.list(legendLabels)) legendLabels <- unlistlabels(legendLabels)
   # check for valid parameter
@@ -221,7 +222,7 @@ sjc.qclus <- function(data,
     grp.class <- grp <- groups
   }
   # remove missings
-  grp <- na.omit(grp)
+  grp <- stats::na.omit(grp)
   # ---------------------------------------------
   # check whether groupcount was matrix or not
   # ---------------------------------------------
@@ -429,9 +430,9 @@ sjc.cluster <- function(data,
   complete.groups <- rep(NA, times = nrow(data.origin))
   # Prepare Data
   # listwise deletion of missing
-  data <- na.omit(data) 
+  data <- stats::na.omit(data) 
   # remove missings
-  data.origin <- na.omit(data.origin)
+  data.origin <- stats::na.omit(data.origin)
   # --------------------------------------------------
   # Ward Hierarchical Clustering
   # --------------------------------------------------
@@ -507,7 +508,7 @@ sjc.cluster <- function(data,
 sjc.dend <- function(data, groupcount, distance = ""euclidean"", agglomeration = ""ward"") {
   # Prepare Data
   # listwise deletion of missing
-  data <- na.omit(data) 
+  data <- stats::na.omit(data) 
   # --------------------------------------------------
   # Ward Hierarchical Clustering
   # --------------------------------------------------
@@ -595,8 +596,8 @@ sjc.dend <- function(data, groupcount, distance = ""euclidean"", agglomeration = ""
 sjc.grpdisc <- function(data, groups, groupcount, showTotalCorrect = TRUE, printPlot = TRUE) {
   # Prepare Data
   # listwise deletion of missing
-  data <- na.omit(data)
-  groups <- na.omit(groups)
+  data <- stats::na.omit(data)
+  groups <- stats::na.omit(groups)
   # ---------------------------------------------------------------
   # compute discriminant analysis of groups on original data frame
   # ---------------------------------------------------------------
@@ -734,7 +735,7 @@ sjc.grpdisc <- function(data, groups, groupcount, showTotalCorrect = TRUE, print
 sjc.elbow <- function(data, steps = 15, showDiff = FALSE) {
   # Prepare Data
   # listwise deletion of missing
-  data <- na.omit(data) 
+  data <- stats::na.omit(data) 
   # define line linecolor
   lcol <- rgb(128, 172, 200, maxColorValue = 255)
   # calculate elbow values (sum of squares)
@@ -842,7 +843,7 @@ sjc.kgap <- function(x,
   }
   # Prepare Data
   # listwise deletion of missing
-  x <- na.omit(x) 
+  x <- stats::na.omit(x) 
   # Gap Statistic for Estimating the Number of Clusters
   gap <- cluster::clusGap(x, kmeans, max, B)
 

---FILE: R/sjPlotCorr.R---
@@ -181,7 +181,7 @@ sjp.corr <- function(data,
     # missing deletion corresponds to
     # SPSS listwise
     if (missingDeletion == ""listwise"") {
-      data <- na.omit(data)
+      data <- stats::na.omit(data)
       corr <- cor(data, method = corMethod)
     }
     # missing deletion corresponds to

---FILE: R/sjPlotDist.R---
@@ -48,6 +48,7 @@ utils::globalVariables(c(""p.level""))
 #' dist_norm(p = 0.2)
 #' 
 #' @import ggplot2
+#' @importFrom stats qchisq pchisq dchisq qf pf df qnorm pnorm dnorm qt pt dt
 #' @export
 dist_norm <- function(norm = NULL,
                      mean = 0,
@@ -61,7 +62,7 @@ dist_norm <- function(norm = NULL,
   # --------------------------------------
   if (is.null(xmax)) {
     if (is.null(norm)) {
-      n.max <- qnorm(0.00001, mean, sd, lower.tail = F)
+      n.max <- stats::qnorm(0.00001, mean, sd, lower.tail = F)
     }
     # --------------------------------------
     # else, if we have a x-value, take into
@@ -70,7 +71,7 @@ dist_norm <- function(norm = NULL,
     # --------------------------------------
     else {
       n.max <- norm
-      while (pnorm(n.max, mean, sd, lower.tail = F) > 0.00001) {
+      while (stats::pnorm(n.max, mean, sd, lower.tail = F) > 0.00001) {
         n.max <- n.max +1
       }
     }
@@ -83,21 +84,21 @@ dist_norm <- function(norm = NULL,
   # --------------------------------------
   mydat <- data.frame(x = seq(-n.max, n.max, length.out = 20 * n.max))
   # density normal distribution
-  mydat$y <- dnorm(mydat$x, mean, sd)
+  mydat$y <- stats::dnorm(mydat$x, mean, sd)
   # base plot with normal-distribution
   gp <- ggplot(mydat, aes(x, y)) + geom_line()
   sub.df <- NULL
   if (!is.null(p)) {
     # plot area for indicated x-value...
-    sub.df <- mydat[mydat$x > qnorm(p, mean, sd, lower.tail=F), ]
+    sub.df <- mydat[mydat$x > stats::qnorm(p, mean, sd, lower.tail=F), ]
   }
   else if (!is.null(norm)) {
     # resp. for p-value...
     sub.df <- mydat[mydat$x > norm, ]
   }
   if (!is.null(sub.df)) {
-    sub.df$p.level  <- ifelse(sub.df$x > qnorm(0.05, mean, sd, lower.tail=F), ""sig"", ""non-sig"")
-    cs <- qnorm(0.05, mean, sd, lower.tail=F)
+    sub.df$p.level  <- ifelse(sub.df$x > stats::qnorm(0.05, mean, sd, lower.tail=F), ""sig"", ""non-sig"")
+    cs <- stats::qnorm(0.05, mean, sd, lower.tail=F)
     gp <- gp +
       geom_ribbon(data = sub.df,
                   aes(ymax = y, fill = p.level),
@@ -110,7 +111,7 @@ dist_norm <- function(norm = NULL,
                vjust = 1.3)
     # add limit of p-value
     if (!is.null(norm)) {
-      pv <- pnorm(norm, mean, sd, lower.tail = F)
+      pv <- stats::pnorm(norm, mean, sd, lower.tail = F)
       if (pv >= 0.05) {
         gp <- gp +
           annotate(""text"", 
@@ -204,7 +205,7 @@ dist_chisq <- function(chi2 = NULL,
   # --------------------------------------
   if (is.null(xmax)) {
     if (is.null(chi2)) {
-      chisq.max <- qchisq(0.00001, deg.f, lower.tail = F)
+      chisq.max <- stats::qchisq(0.00001, deg.f, lower.tail = F)
     }
     # --------------------------------------
     # else, if we have a chi2-value, take into
@@ -213,7 +214,7 @@ dist_chisq <- function(chi2 = NULL,
     # --------------------------------------
     else {
       chisq.max <- chi2
-      while (pchisq(chisq.max, deg.f, lower.tail = F) > 0.00001) {
+      while (stats::pchisq(chisq.max, deg.f, lower.tail = F) > 0.00001) {
         chisq.max <- chisq.max +1
       }
     }
@@ -226,21 +227,21 @@ dist_chisq <- function(chi2 = NULL,
   # --------------------------------------
   mydat <- data.frame(x = seq(0, chisq.max, length.out = 10 * chisq.max))
   # density distribution of chi2
-  mydat$y <- dchisq(mydat$x, deg.f)
+  mydat$y <- stats::dchisq(mydat$x, deg.f)
   # base plot with chi2-distribution
   gp <- ggplot(mydat, aes(x, y)) + geom_line()
   sub.df <- NULL
   if (!is.null(p)) {
     # plot area for indicated chi2-value...
-    sub.df <- mydat[mydat$x > qchisq(p, deg.f, lower.tail=F), ]
+    sub.df <- mydat[mydat$x > stats::qchisq(p, deg.f, lower.tail=F), ]
   }
   else if (!is.null(chi2)) {
     # resp. for p-value...
     sub.df <- mydat[mydat$x > chi2, ]
   }
   if (!is.null(sub.df)) {
-    sub.df$p.level  <- ifelse(sub.df$x > qchisq(0.05, deg.f, lower.tail=F), ""sig"", ""non-sig"")
-    cs <- qchisq(0.05, deg.f, lower.tail=F)
+    sub.df$p.level  <- ifelse(sub.df$x > stats::qchisq(0.05, deg.f, lower.tail=F), ""sig"", ""non-sig"")
+    cs <- stats::qchisq(0.05, deg.f, lower.tail=F)
     gp <- gp +
       geom_ribbon(data = sub.df,
                   aes(ymax = y, fill = p.level),
@@ -254,7 +255,7 @@ dist_chisq <- function(chi2 = NULL,
                vjust = 1.2)
     # add limit of p-value
     if (!is.null(chi2)) {
-      pv <- pchisq(chi2, deg.f, lower.tail = F)
+      pv <- stats::pchisq(chi2, deg.f, lower.tail = F)
       if (pv >= 0.05) {
         gp <- gp +
           annotate(""text"", 
@@ -343,15 +344,15 @@ dist_f <- function(f = NULL,
   # --------------------------------------
   if (is.null(xmax)) {
     if (is.null(f)) {
-      f.max <- qf(0.00001, deg.f1, deg.f2, lower.tail = F)
+      f.max <- stats::qf(0.00001, deg.f1, deg.f2, lower.tail = F)
     # --------------------------------------
     # else, if we have a f-value, take into
     # account all possible f-values that would lead
     # to a theoretical p-value of 0.00001.
     # --------------------------------------
     } else {
       f.max <- f
-      while (pf(f.max, deg.f1, deg.f2, lower.tail = F) > 0.00001) f.max <- f.max +1
+      while (stats::pf(f.max, deg.f1, deg.f2, lower.tail = F) > 0.00001) f.max <- f.max +1
     }
   } else {
     f.max <- xmax
@@ -361,20 +362,20 @@ dist_f <- function(f = NULL,
   # --------------------------------------
   mydat <- data.frame(x = seq(0, f.max, length.out = 30 * f.max))
   # density distribution of f
-  mydat$y <- df(mydat$x, deg.f1, deg.f2)
+  mydat$y <- stats::df(mydat$x, deg.f1, deg.f2)
   # base plot with f-distribution
   gp <- ggplot(mydat, aes(x, y)) + geom_line()
   sub.df <- NULL
   if (!is.null(p)) {
     # plot area for indicated f-value...
-    sub.df <- mydat[mydat$x > qf(p, deg.f1, deg.f2, lower.tail = F), ]
+    sub.df <- mydat[mydat$x > stats::qf(p, deg.f1, deg.f2, lower.tail = F), ]
   } else if (!is.null(f)) {
     # resp. for p-value...
     sub.df <- mydat[mydat$x > f, ]
   }
   if (!is.null(sub.df)) {
-    sub.df$p.level  <- ifelse(sub.df$x > qf(0.05, deg.f1, deg.f2, lower.tail = F), ""sig"", ""non-sig"")
-    fv <- qf(0.05, deg.f1, deg.f2, lower.tail = F)
+    sub.df$p.level  <- ifelse(sub.df$x > stats::qf(0.05, deg.f1, deg.f2, lower.tail = F), ""sig"", ""non-sig"")
+    fv <- stats::qf(0.05, deg.f1, deg.f2, lower.tail = F)
     gp <- gp +
       geom_ribbon(data = sub.df,
                   aes(ymax = y, fill = p.level),
@@ -387,7 +388,7 @@ dist_f <- function(f = NULL,
                vjust = 1.3)
     # add limit of p-value
     if (!is.null(f)) {
-      pv <- pf(f, deg.f1, deg.f2, lower.tail = F)
+      pv <- stats::pf(f, deg.f1, deg.f2, lower.tail = F)
       if (pv >= 0.05) {
         gp <- gp +
           annotate(""text"", 
@@ -475,7 +476,7 @@ dist_t <- function(t = NULL,
   # --------------------------------------
   if (is.null(xmax)) {
     if (is.null(t)) {
-      t.max <- qt(0.00001, deg.f, lower.tail = F)
+      t.max <- stats::qt(0.00001, deg.f, lower.tail = F)
     }
     # --------------------------------------
     # else, if we have a t-value, take into
@@ -484,7 +485,7 @@ dist_t <- function(t = NULL,
     # --------------------------------------
     else {
       t.max <- t
-      while (pt(t.max, deg.f, lower.tail = F) > 0.00001) {
+      while (stats::pt(t.max, deg.f, lower.tail = F) > 0.00001) {
         t.max <- t.max +1
       }
     }
@@ -497,21 +498,21 @@ dist_t <- function(t = NULL,
   # --------------------------------------
   mydat <- data.frame(x = seq(-t.max, t.max, length.out = 20 * t.max))
   # density distribution of t
-  mydat$y <- dt(mydat$x, deg.f)
+  mydat$y <- stats::dt(mydat$x, deg.f)
   # base plot with t-distribution
   gp <- ggplot(mydat, aes(x, y)) + geom_line()
   sub.df <- NULL
   if (!is.null(p)) {
     # plot area for indicated t-value...
-    sub.df <- mydat[mydat$x > qt(p, deg.f, lower.tail=F), ]
+    sub.df <- mydat[mydat$x > stats::qt(p, deg.f, lower.tail=F), ]
   }
   else if (!is.null(t)) {
     # resp. for p-value...
     sub.df <- mydat[mydat$x > t, ]
   }
   if (!is.null(sub.df)) {
-    sub.df$p.level  <- ifelse(sub.df$x > qt(0.05, deg.f, lower.tail=F), ""sig"", ""non-sig"")
-    tv <- qt(0.05, deg.f, lower.tail=F)
+    sub.df$p.level  <- ifelse(sub.df$x > stats::qt(0.05, deg.f, lower.tail=F), ""sig"", ""non-sig"")
+    tv <- stats::qt(0.05, deg.f, lower.tail=F)
     gp <- gp +
       geom_ribbon(data = sub.df,
                   aes(ymax = y, fill = p.level),
@@ -524,7 +525,7 @@ dist_t <- function(t = NULL,
                vjust = 1.3)
     # add limit of p-value
     if (!is.null(t)) {
-      pv <- pt(t, deg.f, lower.tail = F)
+      pv <- stats::pt(t, deg.f, lower.tail = F)
       if (pv >= 0.05) {
         gp <- gp +
           annotate(""text"", 

---FILE: R/sjPlotFrequencies.R---
@@ -251,6 +251,7 @@ utils::globalVariables(c(""frq"", ""grp"", ""upper.ci"", ""lower.ci"", ""ia"", ""..density.
 #'   
 #' @import ggplot2
 #' @import sjmisc
+#' @importFrom stats na.omit sd
 #' @export
 sjp.frq <- function(varCount,
                     title = """",
@@ -455,7 +456,7 @@ sjp.frq <- function(varCount,
     # If interaction-variable-labels were not defined, simply set numbers from 1 to
     # amount of categories instead
     } else {
-      iavarLabLength <- length(unique(na.omit(interactionVar)))
+      iavarLabLength <- length(unique(stats::na.omit(interactionVar)))
       interactionVarLabels <- c(1:iavarLabLength)
     }
   }
@@ -473,14 +474,14 @@ sjp.frq <- function(varCount,
   # --------------------------------------------------------
   if (type == ""boxplots"" || type == ""violin"") {
     if (is.null(interactionVar)) {
-      mydat <- na.omit(data.frame(cbind(grp = 1, 
-                                        frq = varCount, 
-                                        var = varCount)))
+      mydat <- stats::na.omit(data.frame(cbind(grp = 1, 
+                                               frq = varCount, 
+                                               var = varCount)))
     } else {
-      mydat <- na.omit(data.frame(cbind(grp = 1, 
-                                        ia = interactionVar, 
-                                        frq = varCount, 
-                                        var = varCount)))
+      mydat <- stats::na.omit(data.frame(cbind(grp = 1, 
+                                               ia = interactionVar, 
+                                               frq = varCount, 
+                                               var = varCount)))
       mydat$ia <- as.factor(mydat$ia)
     }
     mydat$grp <- as.factor(mydat$grp)
@@ -500,8 +501,8 @@ sjp.frq <- function(varCount,
     # the y axis
     if (type == ""boxplots"" || type == ""violin"") {
       # use an extra standard-deviation as limits for the y-axis when we have boxplots
-      lower_lim <- min(varCount, na.rm = TRUE) - floor(sd(varCount, na.rm = TRUE))
-      upper_lim <- max(varCount, na.rm = TRUE) + ceiling(sd(varCount, na.rm = TRUE))
+      lower_lim <- min(varCount, na.rm = TRUE) - floor(stats::sd(varCount, na.rm = TRUE))
+      upper_lim <- max(varCount, na.rm = TRUE) + ceiling(stats::sd(varCount, na.rm = TRUE))
       # make sure that the y-axis is not below zero
       if (lower_lim < 0) {
         lower_lim <- 0
@@ -644,7 +645,7 @@ sjp.frq <- function(varCount,
   stdmean <- diff(range(varCount, na.rm = TRUE)) / 2
   stdadjust <- min(varCount, na.rm = TRUE)
   stdsd <- stdmean / 4
-  stdlen <- length(na.omit(varCount))
+  stdlen <- length(stats::na.omit(varCount))
   # ----------------------------------
   # Check how many categories we have on the x-axis.
   # If it exceeds the user defined limits, plot
@@ -721,7 +722,7 @@ sjp.frq <- function(varCount,
     # Start density plot here
     # --------------------------------------------------
     } else if (type == ""dens"") {
-      x <- na.omit(varCount)
+      x <- stats::na.omit(varCount)
       densityDat <- data.frame(x)
       # First, plot histogram with density curve
       baseplot <- ggplot(densityDat, aes(x = x)) +
@@ -740,7 +741,7 @@ sjp.frq <- function(varCount,
         baseplot <- baseplot +
           stat_function(fun = dnorm,
                         args = list(mean = mean(densityDat$x),
-                                    sd = sd(densityDat$x)),
+                                    sd = stats::sd(densityDat$x)),
                         colour = normalCurveColor,
                         size = normalCurveSize,
                         alpha = normalCurveAlpha)
@@ -761,7 +762,7 @@ sjp.frq <- function(varCount,
       # -----------------------------------------------------------------
       # base constructor
       if (hist.skipZeros) {
-        x <- na.omit(varCount)
+        x <- stats::na.omit(varCount)
         if (geom.size < round(diff(range(x)) / 50)) message(""Using very small binwidth. Consider adjusting \""geom.size\""-parameter."")
         hist.dat <- data.frame(x)
         baseplot <- ggplot(mydat)

---FILE: R/sjPlotGLME.R---
@@ -1267,7 +1267,7 @@ sjp.lme.feprobcurv <- function(fit,
   # coefficients list
   # ----------------------------
   fit.term.length <- length(names(lme4::fixef(fit))[-1])
-  fit.term.names <- na.omit(attr(attr(fit.df, ""terms""), ""term.labels"")[1:fit.term.length])
+  fit.term.names <- stats::na.omit(attr(attr(fit.df, ""terms""), ""term.labels"")[1:fit.term.length])
   fi <- unname(lme4::fixef(fit))[1]
   # ----------------------------
   # filter vars?
@@ -1410,7 +1410,7 @@ sjp.lme.reprobcurve <- function(fit,
   plot.prob <- list()
   mydf.prob <- list()
   fit.term.length <- length(names(lme4::fixef(fit))[-1])
-  fit.term.names <- na.omit(attr(attr(fit.df, ""terms""), ""term.labels"")[1:fit.term.length])
+  fit.term.names <- stats::na.omit(attr(attr(fit.df, ""terms""), ""term.labels"")[1:fit.term.length])
   response.name <- attr(attr(attr(fit.df, ""terms""), ""dataClasses""), ""names"")[1]
   fi <- unname(lme4::fixef(fit))[1]
   # ----------------------------
@@ -1825,7 +1825,9 @@ sjp.lme.fecor <- function(fit,
                           fun,
                           printPlot,
                           fcall = ""sjp"",
-                          ...) {
+                          CSS = NULL,
+                          useViewer = TRUE,
+                          no.output = TRUE) {
   # ---------------------------------------
   # copy rownames as axis labels, if not set
   # ---------------------------------------
@@ -1998,12 +2000,14 @@ sjp.lme.fecondpred.onlynumeric <- function(fit,
                         plot.facet = plot.facet)))
 }
 
+
+#' @importFrom stats coef
 get_lmerMod_pvalues <- function(fitmod) {
   # retrieve sigificance level of independent variables (p-values)
   if (any(class(fitmod) == ""merModLmerTest"")) {
-    cs <- coef(lmerTest::summary(fitmod))
+    cs <- suppressWarnings(stats::coef(lmerTest::summary(fitmod)))
   } else {
-    cs <- coef(summary(fitmod))
+    cs <- stats::coef(summary(fitmod))
   }
   # check if we have p-values in summary
   if (ncol(cs) >= 4) {
@@ -2054,16 +2058,16 @@ sjp.glm.eff <- function(fit,
   # retrieve model matrix and all terms, 
   # excluding intercept
   # ------------------------
-  mm <- model.matrix(fit)
-  all.terms <- colnames(model.matrix(fit))[-1]
+  mm <- stats::model.matrix(fit)
+  all.terms <- colnames(stats::model.matrix(fit))[-1]
   # ------------------------
   # prepare getting unique values of predictors,
   # which are passed to the allEffects-function
   # ------------------------
   xl <- list()
   for (t in all.terms) {
     # get unique values
-    dummy <- list(x = sort(unique(na.omit(mm[, t]))))
+    dummy <- list(x = sort(unique(stats::na.omit(mm[, t]))))
     # name list, needed for effect-function
     names(dummy) <- t
     # create list for ""xlevels"" parameter of allEffects fucntion

---FILE: R/sjPlotGroupFrequencies.R---
@@ -223,6 +223,7 @@ utils::globalVariables(c(""ypos"", ""wb"", ""ia"", ""mw"", ""stddev"", ""count""))
 #' @import ggplot2
 #' @import sjmisc
 #' @import dplyr
+#' @importFrom stats na.omit
 #' @export
 sjp.grpfrq <- function(varCount,
                        varGroup,
@@ -389,10 +390,10 @@ sjp.grpfrq <- function(varCount,
   # handle zero-counts
   # -----------------------------------------------
   # Determine length of count and group var
-  grplen <- length(unique(na.omit(varGroup)))
+  grplen <- length(unique(stats::na.omit(varGroup)))
   # determine maximum values
   # first, check the total amount of different factor levels
-  catcount_1 <- length(unique(na.omit(varCount)))
+  catcount_1 <- length(unique(stats::na.omit(varCount)))
   # second, check the maximum factor level
   catcount_2 <- max(varCount, na.rm = TRUE)
   # if categories start with zero, fix this here
@@ -566,14 +567,14 @@ sjp.grpfrq <- function(varCount,
   if (type == ""boxplots"" || type == ""violin"") {
     w <- ifelse(is.null(weightBy), 1, weightBy)
     if (is.null(interactionVar)) {
-      mydat <- na.omit(data.frame(cbind(group = varGroup, 
-                                        frq = varCount, 
-                                        wb = w)))
+      mydat <- stats::na.omit(data.frame(cbind(group = varGroup, 
+                                               frq = varCount, 
+                                               wb = w)))
     } else {
-      mydat <- na.omit(data.frame(cbind(group = varGroup, 
-                                        frq = varCount, 
-                                        ia = interactionVar, 
-                                        wb = w)))
+      mydat <- stats::na.omit(data.frame(cbind(group = varGroup, 
+                                               frq = varCount, 
+                                               ia = interactionVar, 
+                                               wb = w)))
       mydat$ia <- as.factor(mydat$ia)
     }
     mydat$group <- as.factor(mydat$group)
@@ -585,15 +586,15 @@ sjp.grpfrq <- function(varCount,
   mannwhitneyu <- function(count, grp) {
     if (min(grp, na.rm = TRUE) == 0) grp <- grp + 1
     completeString <- c("""")
-    cnt <- length(unique(na.omit(grp)))
+    cnt <- length(unique(stats::na.omit(grp)))
     for (i in 1:cnt) {
       for (j in i:cnt) {
         if (i != j) {
           xsub <- count[which(grp == i | grp == j)]
           ysub <- grp[which(grp == i | grp == j)]
           ysub <- ysub[which(!is.na(xsub))]
-          xsub <- as.numeric(na.omit(xsub))
-          ysub <- as.numeric(na.omit(ysub))
+          xsub <- as.numeric(stats::na.omit(xsub))
+          ysub <- as.numeric(stats::na.omit(ysub))
           wt <- wilcox.test(xsub ~ ysub)
           
           if (wt$p.value < 0.001) {
@@ -631,7 +632,7 @@ sjp.grpfrq <- function(varCount,
   # --------------------------------------------------------
   if (type == ""histogram"") {
     # retrieve all unique factor levels
-    faclvl <- unique(na.omit(varGroup))
+    faclvl <- unique(stats::na.omit(varGroup))
     # order factors
     faclvl <- faclvl[order(faclvl)]
     # create new data frame for the geom object that prints the
@@ -647,7 +648,7 @@ sjp.grpfrq <- function(varCount,
       # get mean from each group
       m <- sum(ftabdf[, f] * ftabdf$fac) / sum(ftabdf[, f])
       # get standard deviation from each group
-      stdv <- sd(na.omit(varCount[which(varGroup == faclvl[f])]))
+      stdv <- sd(stats::na.omit(varCount[which(varGroup == faclvl[f])]))
       # add new row with group and associated mean
       vldat <- data.frame(rbind(vldat, c(faclvl[f], m, stdv, yfactor = f)))
     }
@@ -694,7 +695,7 @@ sjp.grpfrq <- function(varCount,
     # If interaction-variable-labels were not defined, simply set numbers from 1 to
     # amount of categories instead
     else  {
-      iavarLabLength <- length(unique(na.omit(interactionVar)))
+      iavarLabLength <- length(unique(stats::na.omit(interactionVar)))
       interactionVarLabels <- c(1:iavarLabLength)
     }
   }

---FILE: R/sjPlotInteractions.R---
@@ -264,7 +264,7 @@
 #' library(sjmisc)
 #' data(efc)
 #' # create binary response
-#' y <- ifelse(efc$neg_c_7 < median(na.omit(efc$neg_c_7)), 0, 1)
+#' y <- ifelse(efc$neg_c_7 < median(stats::na.omit(efc$neg_c_7)), 0, 1)
 #' # create data frame for fitted model
 #' mydf <- data.frame(y = as.factor(y),
 #'                    sex = as.factor(efc$c161sex),
@@ -545,8 +545,8 @@ sjp.int <- function(fit,
     # number of unique values on the x-axis.
     # -----------------------------------------------------------
     # retrieve values as data frame
-    df_pred1uniquevals <- unique(na.omit(fitdat[, interactionterms[1]]))
-    df_pred2uniquevals <- unique(na.omit(fitdat[, interactionterms[2]]))
+    df_pred1uniquevals <- unique(stats::na.omit(fitdat[, interactionterms[1]]))
+    df_pred2uniquevals <- unique(stats::na.omit(fitdat[, interactionterms[2]]))
     # convert data frame to numeric vector
     pred1uniquevals <- pred2uniquevals <- as.numeric(c())
     pred1uniquevals <- sort(as.numeric(sapply(df_pred1uniquevals, as.numeric)))
@@ -1084,7 +1084,7 @@ sjp.eff.int <- function(fit,
       names(xl1) <- moderator.name
       # add values of interaction term
       # first, get all unqiue values
-      prvl <- sort(unique(na.omit(predval)))
+      prvl <- sort(unique(stats::na.omit(predval)))
       # add them to list as well
       xl2 <- list(y = prvl)
       # change list name
@@ -1111,7 +1111,7 @@ sjp.eff.int <- function(fit,
       predval <- dummy.eff$data[[pred_x.name]]
       # add values of interaction term
       # first, get all unqiue values
-      prvl <- sort(unique(na.omit(predval)))
+      prvl <- sort(unique(stats::na.omit(predval)))
       # add them to list as well
       xl <- list(x = prvl)
       # change list name
@@ -1328,7 +1328,7 @@ sjp.eff.int <- function(fit,
     # ---------------------------------------------------------
     baseplot <- sj.setGeomColors(baseplot, 
                                  geom.colors, 
-                                 length(unique(na.omit(intdf$grp))), 
+                                 length(unique(stats::na.omit(intdf$grp))), 
                                  !is.null(lLabels), 
                                  lLabels)
     # ---------------------------------------------------------
@@ -1365,6 +1365,7 @@ mv_check <- function(moderatorValues, x) {
 # at the level specified by ""plevel"". returns NULL, if model
 # contains no interaction terms or no significant interaction term.
 # else, information on model and interaction terms is returned
+#' @importFrom stats model.matrix
 getInteractionTerms <- function(fit, fun, plevel) {
   # -----------------------------------------------------------
   # retrieve coefficients
@@ -1397,11 +1398,11 @@ getInteractionTerms <- function(fit, fun, plevel) {
       # plm objects have different structure than (g)lm
       depvar.label <- attr(attr(attr(fit$model, ""terms""), ""dataClasses""), ""names"")[1]
       # retrieve model matrix
-      fitdat <- data.frame(cbind(as.vector(fit$model[, 1]), model.matrix(fit)))
+      fitdat <- data.frame(cbind(as.vector(fit$model[, 1]), stats::model.matrix(fit)))
     } else {
       depvar.label <- attr(attr(fit$terms, ""dataClasses""), ""names"")[1]
       # retrieve model matrix
-      fitdat <- data.frame(model.matrix(fit))
+      fitdat <- data.frame(stats::model.matrix(fit))
     }
     # -----------------------------------------------------------
     # retrieve p-values, without intercept
@@ -1442,7 +1443,7 @@ getInteractionTerms <- function(fit, fun, plevel) {
     # -----------------------------------------------------------
     # retrieve model matrix with all relevant predictors
     # -----------------------------------------------------------
-    fitdat <- model.matrix(fit)
+    fitdat <- stats::model.matrix(fit)
     # -----------------------------------------------------------
     # need to remove ""I(...)""?
     # -----------------------------------------------------------

---FILE: R/sjPlotLikert.R---
@@ -291,7 +291,7 @@ sjp.likert <- function(items,
     for (i in 1:ncol(items)) {
       # add new unique item values to catcount, so catcount
       # finally contains all unique values of items
-      catcount <- unique(c(catcount, unique(na.omit(items[[i]]))))
+      catcount <- unique(c(catcount, unique(stats::na.omit(items[[i]]))))
     }
     # remove neutral category
     if (!is.null(cat.neutral)) catcount <- catcount[-which(catcount == cat.neutral)]
@@ -406,7 +406,7 @@ sjp.likert <- function(items,
   if (includeN && !is.null(axisLabels.y)) {
     for (i in 1:length(axisLabels.y)) {
       axisLabels.y[i] <- paste(axisLabels.y[i], 
-                               sprintf("" (n=%i)"", length(na.omit(items[[i]]))), 
+                               sprintf("" (n=%i)"", length(stats::na.omit(items[[i]]))), 
                                sep = """")
     }
   }

---FILE: R/sjPlotLinreg.R---
@@ -187,6 +187,7 @@ utils::globalVariables(c(""vars"", ""Beta"", ""xv"", ""lower"", ""upper"", ""stdbeta"", ""p"",
 #' @import ggplot2
 #' @import sjmisc
 #' @importFrom car outlierTest crPlots durbinWatsonTest leveragePlots ncvTest spreadLevelPlot vif
+#' @importFrom stats model.matrix
 #' @export
 sjp.lm <- function(fit,
                    type = ""lm"",
@@ -588,17 +589,17 @@ sjp.reglin <- function(fit,
   # -----------------------------------------------------------
   if (any(class(fit) == ""plm"")) {
     # plm objects have different structure than (g)lm
-    fit_x <- data.frame(cbind(as.vector(fit$model[, 1]), model.matrix(fit)))
+    fit_x <- data.frame(cbind(as.vector(fit$model[, 1]), stats::model.matrix(fit)))
     depvar.label <- attr(attr(attr(fit$model, ""terms""), ""dataClasses""), ""names"")[1]
     # retrieve response vector
     resp <- as.vector(fit$model[, 1])
   } else if (any(class(fit) == ""lmerMod"") || any(class(fit) == ""merModLmerTest"")) {
-    fit_x <- data.frame(model.matrix(fit))
+    fit_x <- data.frame(stats::model.matrix(fit))
     # retrieve response vector
     resp <- lme4::getME(fit, ""y"")
     depvar.label <- attr(attr(attr(fit@frame, ""terms""), ""dataClasses""), ""names"")[1]
   } else {
-    fit_x <- data.frame(model.matrix(fit))
+    fit_x <- data.frame(stats::model.matrix(fit))
     depvar.label <- attr(attr(fit$terms, ""dataClasses""), ""names"")[1]
     # retrieve response vector
     resp <- as.vector(fit$model[, 1])
@@ -1059,11 +1060,11 @@ sjp.lm.poly <- function(fit,
                         showCI, 
                         printPlot) {
   # check size parameter
-  if (is.null(geom.size)) geom.size <- .7
+  if (is.null(geom.size)) geom.size <- .8
   # -------------------------------------
   # retrieve model matrix
   # -------------------------------------
-  mm <- model.matrix(fit)
+  mm <- stats::model.matrix(fit)
   # -------------------------------------
   # parameter check: poly.term required and
   # polynomial must be found in model
@@ -1092,7 +1093,7 @@ sjp.lm.poly <- function(fit,
   # ------------------------
   # compute marginal effects of polynomial
   # ------------------------
-  xl <- list(x = sort(unique(na.omit(mm[, poly.term]))))
+  xl <- list(x = sort(unique(stats::na.omit(mm[, poly.term]))))
   names(xl) <- poly.term
   eff <- effects::effect(poly.term, fit, xlevels = xl, KR = FALSE)
   # ------------------------
@@ -1159,16 +1160,16 @@ sjp.lm.eff <- function(fit,
   # retrieve model matrix and all terms, 
   # excluding intercept
   # ------------------------
-  mm <- model.matrix(fit)
-  all.terms <- colnames(model.matrix(fit))[-1]
+  mm <- stats::model.matrix(fit)
+  all.terms <- colnames(stats::model.matrix(fit))[-1]
   # ------------------------
   # prepare getting unique values of predictors,
   # which are passed to the allEffects-function
   # ------------------------
   xl <- list()
   for (t in all.terms) {
     # get unique values
-    dummy <- list(x = sort(unique(na.omit(mm[, t]))))
+    dummy <- list(x = sort(unique(stats::na.omit(mm[, t]))))
     # name list, needed for effect-function
     names(dummy) <- t
     # create list for ""xlevels"" parameter of allEffects fucntion
@@ -1224,7 +1225,7 @@ sjp.lm.eff <- function(fit,
   # ------------------------
   grp.cnt <- length(unique(mydat$grp))
   # check size parameter
-  if (is.null(geom.size)) geom.size <- .7
+  if (is.null(geom.size)) geom.size <- .8
   # ------------------------
   # create plot
   # ------------------------

---FILE: R/sjPlotOdds.R---
@@ -191,6 +191,7 @@ utils::globalVariables(c(""OR"", ""lower"", ""upper"", ""p""))
 #' @import ggplot2
 #' @import sjmisc
 #' @importFrom car outlierTest influencePlot crPlots durbinWatsonTest leveragePlots ncvTest spreadLevelPlot vif
+#' @importFrom stats na.omit
 #' @export
 sjp.glm <- function(fit,
                     type = ""dots"",
@@ -421,7 +422,7 @@ sjp.glm <- function(fit,
     upper_lim <- ceiling(10 * maxval) / 10
     lower_lim <- floor(10 * minval) / 10
     # avoid zero or NA axis limit!
-    if (is.na(upper_lim)) upper_lim <- ceiling(10 * max(na.omit(maxval))) / 10
+    if (is.na(upper_lim)) upper_lim <- ceiling(10 * max(stats::na.omit(maxval))) / 10
     if (lower_lim == 0 || is.na(lower_lim)) lower_lim <- 0.01
     # give warnings when auto-limits are very low/high
     if ((minval < 0.1) || (maxval > 100)) {

---FILE: R/sjPlotOddsMultiple.R---
@@ -112,6 +112,7 @@ utils::globalVariables(c(""OR"", ""lower"", ""upper"", ""p"", ""pa"", ""shape""))
 #' 
 #' @import ggplot2
 #' @import sjmisc
+#' @importFrom stats na.omit
 #' @export
 sjp.glmm <- function(...,
                      title = NULL,
@@ -292,7 +293,7 @@ sjp.glmm <- function(...,
     upper_lim <- ceiling(10 * max(finalodds$upper)) / 10
     lower_lim <- floor(10 * min(finalodds$lower)) / 10
     # avoid zero or NA axis limit!
-    if (is.na(upper_lim)) upper_lim <- ceiling(10 * max(na.omit(finalodds$upper))) / 10
+    if (is.na(upper_lim)) upper_lim <- ceiling(10 * max(stats::na.omit(finalodds$upper))) / 10
     if (lower_lim == 0 || is.na(lower_lim)) lower_lim <- 0.01
     # if we show p value labels, increase upper
     # limit of x axis, so labels are plotted inside

---FILE: R/sjPlotPCA.R---
@@ -147,22 +147,23 @@
 #' @import ggplot2
 #' @import tidyr
 #' @importFrom scales brewer_pal grey_pal
+#' @importFrom stats na.omit
 #' @export
 sjp.pca <- function(data,
-                    numberOfFactors=NULL,
-                    factorLoadingTolerance=0.1,
-                    plotEigenvalues=FALSE,
-                    digits=2,
-                    title=NULL,
-                    axisLabels.y=NULL,
-                    type=""b"",
-                    geom.size=.6,
-                    geom.colors=""RdBu"",                    
-                    breakTitleAt=50, 
-                    breakLabelsAt=30, 
-                    showValueLabels=TRUE,
-                    showCronbachsAlpha=TRUE,
-                    printPlot=TRUE) {
+                    numberOfFactors = NULL,
+                    factorLoadingTolerance = 0.1,
+                    plotEigenvalues = FALSE,
+                    digits = 2,
+                    title = NULL,
+                    axisLabels.y = NULL,
+                    type = ""b"",
+                    geom.size = .6,
+                    geom.colors = ""RdBu"",
+                    breakTitleAt = 50,
+                    breakLabelsAt = 30,
+                    showValueLabels = TRUE,
+                    showCronbachsAlpha = TRUE,
+                    printPlot = TRUE) {
   # --------------------------------------------------------
   # check parameters
   # --------------------------------------------------------
@@ -203,7 +204,7 @@ sjp.pca <- function(data,
     pcadata <- data
     dataframeparam <- FALSE
   } else {
-    pcadata <- prcomp(na.omit(data), retx = TRUE, center = TRUE, scale. = TRUE)
+    pcadata <- prcomp(stats::na.omit(data), retx = TRUE, center = TRUE, scale. = TRUE)
     dataframeparam <- TRUE
   }
   # --------------------------------------------------------
@@ -323,7 +324,7 @@ sjp.pca <- function(data,
     for (n in 1:length(unique(itemloadings))) {
       # calculate cronbach's alpha for those cases that all have the
       # highest loading on the same factor
-      cbv <- as.data.frame(rbind(cbv, cbind(nr = n, sjmisc::cronb(na.omit(dataframe[, which(itemloadings == n)])))))
+      cbv <- as.data.frame(rbind(cbv, cbind(nr = n, sjmisc::cronb(stats::na.omit(dataframe[, which(itemloadings == n)])))))
     }
     # just for vertical position adjustment when we print the alpha values
     vpos <- rep(c(-0.25, -1), nrow(cbv))

---FILE: R/sjPlotPropTable.R---
@@ -172,6 +172,7 @@ utils::globalVariables(c(""Perc"", ""Sum"", ""Count"", ""Group"", ""line.break""))
 #' @import dplyr
 #' @import sjmisc
 #' @importFrom scales percent
+#' @importFrom stats na.omit
 #' @export
 sjp.xtab <- function(var,
                      grp,
@@ -263,8 +264,8 @@ sjp.xtab <- function(var,
   # handle zero-counts
   # -----------------------------------------------
   # Determine length of count and group var
-  grplen <- length(unique(na.omit(grp)))
-  countlen <- length(unique(na.omit(var)))
+  grplen <- length(unique(stats::na.omit(grp)))
+  countlen <- length(unique(stats::na.omit(var)))
   # if we have legend labels, we know the exact
   # amount of groups
   if (is.null(legendLabels)) {

---FILE: R/sjPlotScatter.R---
@@ -119,6 +119,7 @@
 #' sjp.scatter(runif(10), runif(10), pointLabels = pl)
 #'   
 #' @importFrom scales brewer_pal
+#' @importFrom stats na.omit
 #' @import ggplot2
 #' @export
 sjp.scatter <- function(x = NULL,
@@ -216,7 +217,7 @@ sjp.scatter <- function(x = NULL,
     hideLegend <- TRUE
   }
   # simple data frame
-  df <- na.omit(data.frame(cbind(x = x, y = y, grp = grp)))
+  df <- stats::na.omit(data.frame(cbind(x = x, y = y, grp = grp)))
   # group as factor
   df$grp <- as.factor(df$grp)
   # do we have point labels?

---FILE: R/sjPlotSetTheme.R---
@@ -443,17 +443,15 @@ sjp.setTheme <- function(# base theme
   # ----------------------------------------  
   if (!is.null(axis.angle)) {
     axis.angle.x <- axis.angle.y <- axis.angle 
-  }
-  else {
+  } else {
     axis.angle <- axis.angle.x
   }
   # ----------------------------------------
   # set defaults for axis text color
   # ----------------------------------------  
   if (!is.null(axis.textcolor)) {
     axis.textcolor.x <- axis.textcolor.y <- axis.textcolor
-  }
-  else {
+  } else {
     if (is.null(axis.textcolor.x)) 
       axis.textcolor <- axis.textcolor.y 
     else 
@@ -464,8 +462,7 @@ sjp.setTheme <- function(# base theme
   # ----------------------------------------  
   if (!is.null(axis.linecolor)) {
     axis.linecolor.x <- axis.linecolor.y <- axis.linecolor
-  }
-  else {
+  } else {
     if (is.null(axis.linecolor.x)) 
       axis.linecolor <- axis.linecolor.y 
     else 
@@ -476,8 +473,7 @@ sjp.setTheme <- function(# base theme
   # ----------------------------------------
   if (!is.null(axis.textsize)) {
     axis.textsize.x <- axis.textsize.y <- axis.textsize
-  }
-  else {
+  } else {
     if (is.null(axis.textsize.x)) 
       axis.textsize <- axis.textsize.y 
     else 
@@ -488,8 +484,7 @@ sjp.setTheme <- function(# base theme
   # ----------------------------------------
   if (!is.null(panel.gridcol)) {
     panel.major.gridcol <- panel.minor.gridcol <- panel.gridcol
-  }
-  else {
+  } else {
     if (is.null(panel.major.gridcol)) 
       panel.gridcol <- panel.minor.gridcol 
     else 
@@ -500,8 +495,7 @@ sjp.setTheme <- function(# base theme
   # ----------------------------------------
   if (!is.null(panel.col)) {
     panel.backcol <- panel.bordercol <- panel.col
-  }
-  else {
+  } else {
     if (is.null(panel.backcol)) 
       panel.col <- panel.bordercol 
     else 
@@ -514,17 +508,15 @@ sjp.setTheme <- function(# base theme
     if (title.align == ""left"" || title.align == ""l"") title.align <- 0
     if (title.align == ""right"" || title.align == ""r"") title.align <- 1
     if (title.align == ""center"" || title.align == ""c"") title.align <- 0.5
-  }
-  else {
+  } else {
     title.align <- 0
   }
   # ----------------------------------------
   # set defaults for plot colors
   # ----------------------------------------
   if (!is.null(plot.col)) {
     plot.backcol <- plot.bordercol <- plot.col
-  }
-  else {
+  } else {
     if (is.null(plot.backcol)) 
       plot.col <- plot.bordercol 
     else 

---FILE: R/sjPlotStackFrequencies.R---
@@ -140,6 +140,7 @@
 #' @import dplyr
 #' @import sjmisc
 #' @importFrom scales percent
+#' @importFrom stats na.omit
 #' @export
 sjp.stackfrq <- function(items,
                          legendLabels = NULL,
@@ -252,9 +253,7 @@ sjp.stackfrq <- function(items,
     # ""compensated"" by looking at all items, so we have the
     # actual values of all items.
     legendLabels <- as.character(sort(unique(unlist(
-      apply(items,
-            2,
-            function(x) unique(na.omit(x)))))))
+      apply(items, 2, function(x) unique(stats::na.omit(x)))))))
   }
   # --------------------------------------------------------
   # Check whether N of each item should be included into
@@ -263,7 +262,7 @@ sjp.stackfrq <- function(items,
   if (includeN && !is.null(axisLabels.y)) {
     for (i in 1:length(axisLabels.y)) {
       axisLabels.y[i] <- paste(axisLabels.y[i], 
-                               sprintf("" (n=%i)"", length(na.omit(items[[i]]))), 
+                               sprintf("" (n=%i)"", length(stats::na.omit(items[[i]]))), 
                                sep = """")
     }
   }

---FILE: R/sjTabCorr.R---
@@ -24,9 +24,6 @@
 #'          if \code{FALSE} (default), asterisks are used. See 'Note'.
 #' @param fadeNS If \code{TRUE} (default), non-significant correlation-values appear faded (by using
 #'          a lighter grey text color). See 'Note'.
-#' @param file destination file, if the output should be saved as file.
-#'          If \code{NULL} (default), the output will be saved as temporary file and 
-#'          openend either in the IDE's viewer pane or the default web browser.
 #' @param varlabels The item labels that are printed along the first column/row. If no item labels are
 #'          provided (default), the data frame's column names are used. Item labels must
 #'          be a string vector, e.g.: \code{varlabels=c(""Var 1"", ""Var 2"", ""Var 3"")}.
@@ -51,20 +48,9 @@
 #'          correlated items) that can be used to display content in the diagonal cells
 #'          where row and column item are identical (i.e. the ""self-correlation""). By defauilt,
 #'          this parameter is \code{NULL} and the diagnal cells are empty.
-#' @param encoding The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-#'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-#'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
-#' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
-#' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
-#'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
-#' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
-#'          the viewer pane and not even saved to file. This option is useful when the html output
-#'          should be used in \code{knitr} documents. The html output can be accessed via the return
-#'          value.
-#' @param remove.spaces logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
-#'          that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
-#'          may look less pretty, but it may help when exporting html-tables to office tools.
+#'          
+#' @inheritParams sjt.frq
+#'          
 #' @return Invisibly returns
 #'          \itemize{
 #'            \item the web page style sheet (\code{page.style}),
@@ -141,6 +127,7 @@
 #'          val.rm = 0.3, 
 #'          CSS = list(css.valueremove = 'color:blue;'))}
 #' 
+#' @importFrom stats na.omit
 #' @export
 sjt.corr <- function(data,
                      missingDeletion = ""pairwise"",
@@ -220,7 +207,7 @@ sjt.corr <- function(data,
     # missing deletion corresponds to
     # SPSS listwise
     if (missingDeletion == ""listwise"") {
-      data <- na.omit(data)
+      data <- stats::na.omit(data)
       corr <- cor(data, method = corMethod)
     } else {
       # missing deletion corresponds to

---FILE: R/sjTabDataFrame.R---
@@ -16,9 +16,6 @@
 #' @param describe If \code{TRUE} (default), a description of the data frame's variables is given.
 #'          The description is retrieved from the \code{\link[psych]{describe}} function of the \code{psych}
 #'          package. If this parameter is \code{FALSE}, the data frame's content (values) is shown.
-#' @param file destination file, if the output should be saved as file.
-#'          If \code{NULL} (default), the output will be saved as temporary file and 
-#'          openend either in the IDE's viewer pane or the default web browser.
 #' @param alternateRowColors If \code{TRUE}, alternating rows are highlighted with a light gray
 #'          background color.
 #' @param orderColumn Indicates a column, either by column name or by column index number,
@@ -42,20 +39,9 @@
 #'          applies, if \code{showCommentRow} is \code{TRUE}.
 #' @param hideProgressBar If \code{TRUE}, the progress bar that is displayed when creating the
 #'          table is hidden. Default in \code{FALSE}, hence the bar is visible.
-#' @param encoding The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-#'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-#'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
-#' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
-#' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
-#'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
-#' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
-#'          the viewer pane and not even saved to file. This option is useful when the html output
-#'          should be used in \code{knitr} documents. The html output can be accessed via the return
-#'          value.
-#' @param remove.spaces logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
-#'          that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
-#'          may look less pretty, but it may help when exporting html-tables to office tools.
+#'          
+#' @inheritParams sjt.frq
+#'          
 #' @return Invisibly returns
 #'          \itemize{
 #'            \item the data frame with the description information (\code{data}),

---FILE: R/sjTabFrequencies.R---
@@ -81,14 +81,15 @@
 #'          applies if \code{removeStringVectors} is \code{FALSE}.
 #' @param maxStringDist the allowed distance of string values in a character vector, which indicates
 #'          when two string values are merged because they are considered as close enough.
-#' @param encoding The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-#'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-#'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
-#' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
+#' @param encoding string, indicating the charset encoding used for variable and 
+#'          value labels. Default is \code{NULL}, so encoding will be auto-detected 
+#'          depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+#'          Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).
+#' @param CSS \code{\link{list}}-object with user-defined style-sheet-definitions, according to the 
 #'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
 #' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 #'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
-#' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
+#' @param no.output logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
 #'          the viewer pane and not even saved to file. This option is useful when the html output
 #'          should be used in \code{knitr} documents. The html output can be accessed via the return
 #'          value.
@@ -107,7 +108,7 @@
 #' @note The HTML tables can either be saved as file and manually opened (specify parameter \code{file}) or
 #'         they can be saved as temporary files and will be displayed in the RStudio Viewer pane (if working with RStudio)
 #'         or opened with the default web browser. Displaying resp. opening a temporary file is the
-#'         default behaviour (i.e. \code{file=NULL}).
+#'         default behaviour (i.e. \code{file = NULL}).
 #' 
 #' @details \bold{How does the \code{CSS}-parameter work?}
 #'            \cr \cr
@@ -191,6 +192,7 @@
 #'                    css.firsttablecol = ""color:#003399; font-weight:bold;""))}
 #' 
 #' @importFrom psych describe
+#' @importFrom stats na.omit
 #' @import sjmisc
 #' @export
 sjt.frq <- function(data,
@@ -335,7 +337,7 @@ sjt.frq <- function(data,
     # iterate all columns
     for (i in 1:ncol(data)) {
       # check type
-      if (length(na.omit(data[[i]])) == 0) NAcolumns <- c(NAcolumns, i)
+      if (length(stats::na.omit(data[[i]])) == 0) NAcolumns <- c(NAcolumns, i)
     }
     # check if any NA-only variables found
     if (length(NAcolumns) > 0) {
@@ -522,7 +524,7 @@ sjt.frq <- function(data,
       # retrieve range of values
       vonbis <- max(var, na.rm = T) - min(var, na.rm = T)
       # retrieve count of unique values
-      anzval <- na.omit(unique(var))
+      anzval <- stats::na.omit(unique(var))
       # check proportion of possible values and actual values
       # if we have more than 25% of zero-values, or if we have
       # in general a large variable range, skip zero-rows.

---FILE: R/sjTabGrpmean.R---
@@ -16,23 +16,9 @@
 #'          are automatically detected if set by \code{\link[sjmisc]{set_val_labels}}.
 #' @param digits amount of digits for table values.
 #' @param digits.summary amount of digits for summary statistics (Anova).
-#' @param file The destination file, which will be in html-format. If no filepath is specified,
-#'          the file will be saved as temporary file and openend either in the RStudio View pane or
-#'          in the default web browser.
-#' @param encoding The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-#'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-#'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
-#' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
-#' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
-#'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
-#' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
-#'          the viewer pane and not even saved to file. This option is useful when the html output
-#'          should be used in \code{knitr} documents. The html output can be accessed via the return
-#'          value.
-#' @param remove.spaces logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
-#'          that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
-#'          may look less pretty, but it may help when exporting html-tables to office tools.
+#' 
+#' @inheritParams sjt.frq
+#' 
 #' @return Invisibly returns a \code{\link{list}} with
 #'          \itemize{
 #'            \item the data frame with the description information (\code{df}),
@@ -64,6 +50,7 @@
 #'             efc$e42dep)}
 #'             
 #' @import sjmisc
+#' @importFrom stats na.omit
 #' @export
 sjt.grpmean <- function(varCount, 
                         varGrp, 
@@ -127,7 +114,7 @@ sjt.grpmean <- function(varCount,
   # --------------------------------------
   # retrieve group indices
   # --------------------------------------
-  indices <- sort(unique(na.omit(varGrp)))
+  indices <- sort(unique(stats::na.omit(varGrp)))
   df <- data.frame()
   # --------------------------------------
   # iterate all groups
@@ -150,7 +137,7 @@ sjt.grpmean <- function(varCount,
     # --------------------------------------
     df <- rbind(df, 
                 cbind(mean = sprintf(""%.*f"", digits, mw),
-                      N = length(na.omit(varCount[varGrp == indices[i]])),
+                      N = length(stats::na.omit(varCount[varGrp == indices[i]])),
                       sd = sprintf(""%.*f"", digits, sd(varCount[varGrp == indices[i]], na.rm = TRUE)),
                       se = sprintf(""%.*f"", digits, sjmisc::std_e(varCount[varGrp == indices[i]])),
                       p = pval[i]))
@@ -170,7 +157,7 @@ sjt.grpmean <- function(varCount,
   # --------------------------------------
   df <- rbind(df, 
               cbind(mean = sprintf(""%.*f"", digits, mw),
-                    N = length(na.omit(varCount)),
+                    N = length(stats::na.omit(varCount)),
                     sd = sprintf(""%.*f"", digits, sd(varCount, na.rm = TRUE)),
                     se = sprintf(""%.*f"", digits, sjmisc::std_e(varCount)),
                     p = """"))

---FILE: R/sjTabItemAnalysis.R---
@@ -65,23 +65,9 @@
 #'          each component (a component is represented by each group of \code{factor.groups}).
 #'          After that, each case (df's row) has a scales sum score for each component.
 #'          Finally, a correlation of these ""scale sum scores"" is computed.
-#' @param file The destination file, which will be in html-format. If no filepath is specified (default),
-#'          the file will be saved as temporary file and openend either in the RStudio View pane or
-#'          in the default web browser.
-#' @param encoding The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-#'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-#'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
-#' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
-#' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
-#'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
-#' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
-#'          the viewer pane and not even saved to file. This option is useful when the html output
-#'          should be used in \code{knitr} documents. The html output can be accessed via the return
-#'          value.
-#' @param remove.spaces logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
-#'          that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
-#'          may look less pretty, but it may help when exporting html-tables to office tools.
+#'          
+#' @inheritParams sjt.frq
+#'          
 #' @return Invisibly returns
 #'         \itemize{
 #'          \item \code{df.list}: List of data frames with the item analysis for each sub.group (or complete, if \code{factor.groups} was \code{NULL})
@@ -253,7 +239,7 @@ sjt.itemanalysis <- function(df,
     # -----------------------------------
     # remove missings
     # -----------------------------------
-    df.sub <- na.omit(df.sub)
+    df.sub <- stats::na.omit(df.sub)
     # -----------------------------------
     # item difficulty
     # -----------------------------------

---FILE: R/sjTabLinReg.R---
@@ -11,59 +11,58 @@ utils::globalVariables(c(""starts_with""))
 #'                
 #' @seealso \href{http://strengejacke.de/sjPlot/sjt.lm/}{sjPlot manual: sjt.lm}
 #' 
-#' @param ... One or more fitted lm-objects.
-#' @param file The destination file, which will be in html-format. If no filepath is specified,
-#'          the file will be saved as temporary file and openend either in the RStudio View pane or
-#'          in the default web browser.
-#' @param labelPredictors Labels of the predictor variables, provided as char vector.
-#' @param labelDependentVariables Labels of the dependent variables of all fitted models
-#'          which have been used as first parameter(s), provided as char vector.
-#' @param stringPredictors String constant used as headline for the predictor column.
+#' @param ... one or more fitted linear (mixed) models.
+#' @param labelPredictors character vector with labels of predictor variables.
+#'          If not \code{NULL}, \code{labelPredictors} will be used in the first
+#'          table column with the predictors' names. See 'Examples'.
+#' @param labelDependentVariables character vector with labels of dependent 
+#'          variables of all fitted models. See 'Examples'.
+#' @param stringPredictors string constant used as headline for the predictor column.
 #'          Default is \code{""Predictors""}.
-#' @param stringDependentVariables String constant used as headline for the 
+#' @param stringDependentVariables string constant used as headline for the 
 #'          dependent variable columns. Default is \code{""Dependent Variables""}.
-#' @param showHeaderStrings If \code{TRUE}, the header strings \code{stringPredictors}
+#' @param showHeaderStrings logical, if \code{TRUE}, the header strings \code{stringPredictors}
 #'          and \code{stringDependentVariables} are shown. By default, they're hidden.
-#' @param stringModel String constant used as headline for the model names in case no 
+#' @param stringModel string constant used as headline for the model names in case no 
 #'          labels for the dependent variables are provided (see labelDependentVariables).
 #'          Default is \code{""Model""}.
-#' @param stringIntercept String constant used as headline for the Intercept row
-#'          default is \code{""Intercept""}.
-#' @param stringObservations String constant used in the summary row for the count of observation
+#' @param stringIntercept string constant used as headline for the Intercept row.
+#'          Default is \code{""Intercept""}.
+#' @param stringObservations string constant used in the summary row for the count of observation
 #'          (cases). Default is \code{""Observations""}.
-#' @param stringB String used for the column heading of beta coefficients. Default is \code{""B""}.
-#' @param stringSB String used for the column heading of standardized beta coefficients. Default is \code{""std. Beta""}.
-#' @param stringCI String used for the column heading of confidence interval values. Default is \code{""CI""}.
-#' @param stringSE String used for the column heading of standard error values. Default is \code{""std. Error""}.
-#' @param stringP String used for the column heading of p values. Default is \code{""p""}.
-#' @param showEst If \code{TRUE} (default), the estimates are printed.
-#' @param showConfInt If \code{TRUE} (default), the confidence intervall is also printed to the table. Use
+#' @param stringB string used for the column heading of beta coefficients. Default is \code{""B""}.
+#' @param stringSB string used for the column heading of standardized beta coefficients. Default is \code{""std. Beta""}.
+#' @param stringCI string used for the column heading of confidence interval values. Default is \code{""CI""}.
+#' @param stringSE string used for the column heading of standard error values. Default is \code{""std. Error""}.
+#' @param stringP string used for the column heading of p values. Default is \code{""p""}.
+#' @param showEst logical, if \code{TRUE} (default), the estimates are printed.
+#' @param showConfInt logical, if \code{TRUE} (default), the confidence intervall is also printed to the table. Use
 #'          \code{FALSE} to omit the CI in the table.
-#' @param showStdBeta If \code{TRUE}, the standardized beta-coefficients are also printed.
+#' @param showStdBeta logical, if \code{TRUE}, the standardized beta-coefficients are also printed.
 #'          Default is \code{FALSE}.
-#' @param showStdError If \code{TRUE}, the standard errors are also printed.
+#' @param showStdError logical, if \code{TRUE}, the standard errors are also printed.
 #'          Default is \code{FALSE}.
-#' @param digits.est Amount of decimals for estimators.
-#' @param digits.p Amount of decimals for p-values.
-#' @param digits.ci Amount of decimals for confidence intervals.
-#' @param digits.se Amount of decimals for standard error.
-#' @param digits.sb Amount of decimals for standardized beta.
-#' @param digits.summary Amount of decimals for values in model summary.
-#' @param pvaluesAsNumbers If \code{TRUE}, p-values are shown as numbers. If \code{FALSE} (default),
+#' @param digits.est amount of decimals for estimators
+#' @param digits.p amount of decimals for p-values
+#' @param digits.ci amount of decimals for confidence intervals
+#' @param digits.se amount of decimals for standard error
+#' @param digits.sb amount of decimals for standardized beta
+#' @param digits.summary amount of decimals for values in model summary
+#' @param pvaluesAsNumbers logical, if \code{TRUE}, p-values are shown as numbers. If \code{FALSE} (default),
 #'          p-values are indicated by asterisks.
-#' @param boldpvalues If \code{TRUE} (default), significant p-values are shown bold faced.
+#' @param boldpvalues logical, if \code{TRUE} (default), significant p-values are shown bold faced.
 #' @param separateConfColumn if \code{TRUE}, the CI values are shown in a separate table column.
 #'          Default is \code{FALSE}.
-#' @param newLineConf If \code{TRUE} and \code{separateConfColumn} is \code{FALSE}, inserts a line break
+#' @param newLineConf logica, if \code{TRUE} and \code{separateConfColumn = FALSE}, inserts a line break
 #'          between B and CI values. If \code{FALSE}, CI values are printed in the same
 #'          line with B values.
 #' @param group.pred logical, if \code{TRUE} (default), automatically groups table rows with 
 #'          factor levels of same factor, i.e. predictors of type \code{\link{factor}} will
 #'          be grouped, if the factor has more than two levels. Grouping means that a separate headline
 #'          row is inserted to the table just before the predictor values.
-#' @param showAbbrHeadline If \code{TRUE} (default), the table data columns have a headline with 
+#' @param showAbbrHeadline logical, if \code{TRUE} (default), the table data columns have a headline with 
 #'          abbreviations for beta- and std. beta-values, confidence interval and p-values.
-#' @param showR2 If \code{TRUE} (default), the R2 and adjusted R2 values for each model are printed
+#' @param showR2 logical, if \code{TRUE} (default), the R2 and adjusted R2 values for each model are printed
 #'          in the model summary.
 #' @param showFStat If \code{TRUE}, the F-statistics for each model is printed
 #'          in the model summary. Default is \code{FALSE}.
@@ -78,26 +77,15 @@ utils::globalVariables(c(""starts_with""))
 #'          would remove the 2nd to the 4th estimate (1st to 3d predictor after intercept) from the output. 
 #'          \code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default 
 #'          is \code{NULL}, i.e. all estimates are printed.
-#' @param cellSpacing The inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
+#' @param cellSpacing numeric, inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
 #'          suitable for viewing the table. Decrease this value (0.05 to 0.1) if you want to import the table
 #'          into Office documents. This is a convenient parameter for the \code{CSS} parameter for changing
-#'          cell spacing, which would be: \code{CSS=list(css.thead=""padding:0.2cm;"", css.tzdata=""padding:0.2cm;"")}.
+#'          cell spacing, which would be: \code{CSS = list(css.thead = ""padding:0.2cm;"", css.tdata = ""padding:0.2cm;"")}.
 #' @param cellGroupIndent Indent for table rows with grouped factor predictors. Only applies
 #'          if \code{group.pred} is \code{TRUE}.
-#' @param encoding The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-#'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-#'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
-#' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
-#' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
-#'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
-#' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
-#'          the viewer pane and not even saved to file. This option is useful when the html output
-#'          should be used in \code{knitr} documents. The html output can be accessed via the return
-#'          value.
-#' @param remove.spaces logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
-#'          that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
-#'          may look less pretty, but it may help when exporting html-tables to office tools.
+#'          
+#' @inheritParams sjt.frq
+#'          
 #' @return Invisibly returns
 #'          \itemize{
 #'            \item the web page style sheet (\code{page.style}),
@@ -677,7 +665,7 @@ sjt.lm <- function(...,
       }
       fit.df$pv <- sapply(fit.df$pv, function(x) {
         if (x < 0.05) {
-          if (x < 0.001) {
+          if (x < 0.001 && digits.p <= 3) {
             x <- sprintf(""%s&lt;0.001%s"", sb1, sb2)
           } else {
             x <- sprintf(""%s%.*f%s"", sb1, digits.p, x, sb2)
@@ -1390,85 +1378,11 @@ sjt.lm <- function(...,
 #' @seealso \href{http://strengejacke.de/sjPlot/sjt.lmer/}{sjPlot manual: sjt.lmer} 
 #'            and \code{\link{sjt.lm}} for further examples.
 #' 
-#' @param ... One or more mixed models fitted with \code{\link[lme4]{lmer}} or \code{\link[lmerTest]{lmer}}.
-#' @param file The destination file, which will be in html-format. If no filepath is specified,
-#'          the file will be saved as temporary file and openend either in the RStudio View pane or
-#'          in the default web browser.
-#' @param labelPredictors Labels of the predictor variables, provided as char vector.
-#' @param labelDependentVariables Labels of the dependent variables of all fitted models
-#'          which have been used as first parameter(s), provided as char vector.
-#' @param stringPredictors String constant used as headline for the predictor column.
-#'          Default is \code{""Predictors""}.
-#' @param stringDependentVariables String constant used as headline for the 
-#'          dependent variable columns. Default is \code{""Dependent Variables""}.
-#' @param showHeaderStrings If \code{TRUE}, the header strings \code{stringPredictors}
-#'          and \code{stringDependentVariables} are shown. By default, they're hidden.
-#' @param stringModel String constant used as headline for the model names in case no 
-#'          labels for the dependent variables are provided (see labelDependentVariables).
-#'          Default is \code{""Model""}.
-#' @param stringIntercept String constant used as headline for the Intercept row
-#'          default is \code{""Intercept""}.
-#' @param stringObservations String constant used in the summary row for the count of observation
-#'          (cases). Default is \code{""Observations""}.
-#' @param stringB String used for the column heading of beta coefficients. Default is \code{""B""}.
-#' @param stringSB String used for the column heading of standardized beta coefficients. Default is \code{""std. Beta""}.
-#' @param stringCI String used for the column heading of confidence interval values. Default is \code{""CI""}.
-#' @param stringSE String used for the column heading of standard error values. Default is \code{""std. Error""}.
-#' @param stringP String used for the column heading of p values. Default is \code{""p""}.
-#' @param showEst If \code{TRUE} (default), the estimates are printed.
-#' @param showConfInt If \code{TRUE} (default), the confidence intervall is also printed to the table. Use
-#'          \code{FALSE} to omit the CI in the table.
-#' @param showStdBeta If \code{TRUE}, the standardized beta-coefficients are also printed.
-#'          Default is \code{FALSE}.
-#' @param showStdError If \code{TRUE}, the standard errors are also printed.
-#'          Default is \code{FALSE}.
-#' @param digits.est Amount of decimals for estimators.
-#' @param digits.p Amount of decimals for p-values.
-#' @param digits.ci Amount of decimals for confidence intervals.
-#' @param digits.se Amount of decimals for standard error.
-#' @param digits.sb Amount of decimals for standardized beta.
-#' @param digits.summary Amount of decimals for values in model summary.
-#' @param pvaluesAsNumbers If \code{TRUE}, p-values are shown as numbers. If \code{FALSE} (default),
-#'          p-values are indicated by asterisks.
-#' @param boldpvalues If \code{TRUE} (default), significant p-values are shown bold faced.
-#' @param separateConfColumn if \code{TRUE}, the CI values are shown in a separate table column.
-#'          Default is \code{FALSE}.
-#' @param newLineConf If \code{TRUE} and \code{separateConfColumn} is \code{FALSE}, inserts a line break
-#'          between B and CI values. If \code{FALSE}, CI values are printed in the same
-#'          line with B values.
-#' @param showAbbrHeadline If \code{TRUE} (default), the table data columns have a headline with 
-#'          abbreviations for beta- and std. beta-values, confidence interval and p-values.
-#' @param showICC If \code{TRUE}, the intra-class-correlation for each model is printed
-#'          in the model summary.
-#' @param showAIC If \code{TRUE}, the AIC value for each model is printed
-#'          in the model summary. Default is \code{FALSE}.
-#' @param showAICc If \code{TRUE}, the second-order AIC value for each model 
-#'          is printed in the model summary. Default is \code{FALSE}.
-#' @param remove.estimates numeric vector with indices (order equals to row index of \code{coef(fit)}) 
-#'          or character vector with coefficient names that indicate which estimates should be removed
-#'          from the table output. The first estimate is the intercept, followed by the model predictors.
-#'          \emph{The intercept cannot be removed from the table output!} \code{remove.estimates = c(2:4)} 
-#'          would remove the 2nd to the 4th estimate (1st to 3d predictor after intercept) from the output. 
-#'          \code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default 
-#'          is \code{NULL}, i.e. all estimates are printed.
-#' @param cellSpacing The inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
-#'          suitable for viewing the table. Decrease this value (0.05 to 0.1) if you want to import the table
-#'          into Office documents. This is a convenient parameter for the \code{CSS} parameter for changing
-#'          cell spacing, which would be: \code{CSS=list(css.thead=""padding:0.2cm;"", css.tzdata=""padding:0.2cm;"")}.
-#' @param encoding The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-#'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-#'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
-#' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
-#' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
-#'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
-#' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
-#'          the viewer pane and not even saved to file. This option is useful when the html output
-#'          should be used in \code{knitr} documents. The html output can be accessed via the return
-#'          value.
-#' @param remove.spaces logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
-#'          that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
-#'          may look less pretty, but it may help when exporting html-tables to office tools.
+#' @inheritParams sjt.lm
+#' @inheritParams sjt.frq
+#' 
+#' @param showICC logical, if \code{TRUE}, the intra-class-correlation for each 
+#'          model is printed in the model summary.
 #' @return Invisibly returns
 #'          \itemize{
 #'            \item the web page style sheet (\code{page.style}),
@@ -1522,7 +1436,14 @@ sjt.lm <- function(...,
 #' sjt.lmer(fit1, fit2, fit3, 
 #'          showAIC = TRUE,
 #'          separateConfColumn = FALSE,
-#'          newLineConf = FALSE)}
+#'          newLineConf = FALSE)
+#'          
+#' sjt.lmer(fit1, fit2, fit3,
+#'          labelPredictors = c(""Elder's gender (female)"",
+#'                              ""Hours of care per week"",
+#'                              ""Barthel Index"",
+#'                              ""Educational level (mid)"",
+#'                              ""Educational level (high)""))}
 #'                   
 #' @export
 sjt.lmer <- function(...,

---FILE: R/sjTabMannWhitney.R---
@@ -9,23 +9,7 @@
 #' @param alternateRowColors If \code{TRUE}, alternating rows are highlighted with a light gray
 #'          background color.
 #' @param title A table caption. By default, \code{title} is \code{NULL}, hence no title will be used.
-#' @param file The destination file, which will be in html-format. If no filepath is specified,
-#'          the file will be saved as temporary file and openend either in the RStudio View pane or
-#'          in the default web browser.
-#' @param encoding The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-#'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-#'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
-#' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
-#' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
-#'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
-#' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
-#'          the viewer pane and not even saved to file. This option is useful when the html output
-#'          should be used in \code{knitr} documents. The html output can be accessed via the return
-#'          value.
-#' @param remove.spaces logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
-#'          that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
-#'          may look less pretty, but it may help when exporting html-tables to office tools.
+#' @inheritParams sjt.frq
 #' @return Invisibly returns a \code{\link{list}} with
 #'          \itemize{
 #'            \item the data frame with the description information (\code{data}),
@@ -93,10 +77,10 @@ sjt.mwu <- function(x,
   # check if html-content should be printed
   # -------------------------------------
   out.html.table(no.output, file, html$knitr, html$output.complete, useViewer)  
-  invisible (list(class = ""sjtmwu"",
-                  df = x$tab.df, 
-                  page.style = html$page.style,
-                  page.content = html$page.content,
-                  knitr = html$knitr,
-                  output.complete = html$output.complete))
+  invisible(list(class = ""sjtmwu"",
+                 df = x$tab.df, 
+                 page.style = html$page.style,
+                 page.content = html$page.content,
+                 knitr = html$knitr,
+                 output.complete = html$output.complete))
 }

---FILE: R/sjTabOdds.R---
@@ -9,38 +9,38 @@ utils::globalVariables(c(""starts_with""))
 #'                as HTML table, or saves them as file. The fitted models may have different predictors,
 #'                e.g. when comparing different stepwise fitted models.
 #' 
-#' @param ... one or more fitted \code{\link{glm}}-objects.
-#' @param file The destination file, which will be in html-format. If no filepath is specified,
-#'          the file will be saved as temporary file and openend either in the RStudio View pane or
-#'          in the default web browser.
-#' @param labelPredictors Labels of the predictor variables, provided as char vector.
-#' @param labelDependentVariables Labels of the dependent variables of all fitted models
-#'          which have been used as first parameter(s), provided as char vector.
-#' @param stringPredictors String constant used as headline for the predictor column.
+#' @param ... one or more fitted generalized linear (mixed) models.
+#' @param labelPredictors character vector with labels of predictor variables.
+#'          If not \code{NULL}, \code{labelPredictors} will be used in the first
+#'          table column with the predictors' names. See 'Examples'.
+#' @param labelDependentVariables character vector with labels of dependent 
+#'          variables of all fitted models. See 'Examples'.
+#' @param stringPredictors string constant used as headline for the predictor column.
 #'          Default is \code{""Predictors""}.
-#' @param stringDependentVariables String constant used as headline for the 
+#' @param stringDependentVariables string constant used as headline for the 
 #'          dependent variable columns. Default is \code{""Dependent Variables""}.
-#' @param showHeaderStrings If \code{TRUE}, the header strings \code{stringPredictors}
+#' @param showHeaderStrings logical, if \code{TRUE}, the header strings \code{stringPredictors}
 #'          and \code{stringDependentVariables} are shown. By default, they're hidden.
-#' @param stringModel String constant used as headline for the model names in case no 
-#'          labels for the dependent variables are provided (see labelDependentVariables).
+#' @param stringModel string constant used as headline for the model names in case no 
+#'          labels for the dependent variables are provided (see \code{labelDependentVariables}).
 #'          Default is \code{""Model""}.
-#' @param stringIntercept String constant used as headline for the Intercept row
-#'          default is \code{""Intercept""}.
-#' @param stringObservations String constant used in the summary row for the count of observation
+#' @param stringIntercept String constant used as headline for the Intercept row.
+#'          Default is \code{""Intercept""}.
+#' @param stringObservations string constant used in the summary row for the count of observation
 #'          (cases). Default is \code{""Observations""}.
-#' @param stringOR String used for the column heading of odds ratio values. Default is \code{""OR""}.
-#' @param stringCI String used for the column heading of confidence interval values. Default is \code{""CI""}.
-#' @param stringSE String used for the column heading of standard error values. Default is \code{""std. Error""}.
-#' @param stringP String used for the column heading of p values. Default is \code{""p""}.
-#' @param digits.est Amount of decimals for estimators.
-#' @param digits.p Amount of decimals for p-values.
-#' @param digits.ci Amount of decimals for confidence intervals.
-#' @param digits.se Amount of decimals for standard error.
-#' @param digits.summary Amount of decimals for values in model summary.
-#' @param exp.coef If \code{TRUE} (default), regression coefficients and confidence intervals are exponentiated
-#'          (odds ratios, \code{\link{exp}(\link{coef}(fit))}. Use \code{FALSE} if you want the non-exponentiated coefficients
-#'          (log-odds) as they are provided by the \code{\link{summary}} function.
+#' @param stringOR string used for the column heading of odds ratio values. Default is \code{""OR""}.
+#' @param stringCI string used for the column heading of confidence interval values. Default is \code{""CI""}.
+#' @param stringSE string used for the column heading of standard error values. Default is \code{""std. Error""}.
+#' @param stringP string used for the column heading of p values. Default is \code{""p""}.
+#' @param digits.est amount of decimals for estimators
+#' @param digits.p amount of decimals for p-values
+#' @param digits.ci amount of decimals for confidence intervals
+#' @param digits.se amount of decimals for standard error
+#' @param digits.summary amount of decimals for values in model summary
+#' @param exp.coef logical, if \code{TRUE} (default), regression coefficients and 
+#'          confidence intervals are exponentiated. Use \code{FALSE} for 
+#'          non-exponentiated coefficients (log-odds) as provided by 
+#'          the \code{\link{summary}} function.
 #' @param pvaluesAsNumbers If \code{TRUE}, p-values are shown as numbers. If \code{FALSE} (default),
 #'          p-values are indicated by asterisks.
 #' @param boldpvalues If \code{TRUE} (default), significant p-values are shown bold faced.
@@ -50,7 +50,7 @@ utils::globalVariables(c(""starts_with""))
 #'          Default is \code{FALSE}.
 #' @param separateConfColumn if \code{TRUE}, the CI values are shown in a separate table column.
 #'          Default is \code{FALSE}.
-#' @param newLineConf If \code{TRUE} and \code{separateConfColumn} is \code{FALSE}, inserts a line break
+#' @param newLineConf If \code{TRUE} and \code{separateConfColumn = FALSE}, inserts a line break
 #'          between OR and CI values. If \code{FALSE}, CI values are printed in the same
 #'          line with OR values.
 #' @param group.pred logical, if \code{TRUE} (default), automatically groups table rows with 
@@ -91,26 +91,15 @@ utils::globalVariables(c(""starts_with""))
 #'          would remove the 2nd to the 4th estimate (1st to 3d predictor after intercept) from the output. 
 #'          \code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default 
 #'          is \code{NULL}, i.e. all estimates are printed.
-#' @param cellSpacing The inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
+#' @param cellSpacing numeric, inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
 #'          suitable for viewing the table. Decrease this value (0.05 to 0.1) if you want to import the table
 #'          into Office documents. This is a convenient parameter for the \code{CSS} parameter for changing
-#'          cell spacing, which would be: \code{CSS=list(css.thead=""padding:0.2cm;"", css.tzdata=""padding:0.2cm;"")}.
+#'          cell spacing, which would be: \code{CSS = list(css.thead = ""padding:0.2cm;"", css.tdata = ""padding:0.2cm;"")}.
 #' @param cellGroupIndent Indent for table rows with grouped factor predictors. Only applies
 #'          if \code{group.pred} is \code{TRUE}.
-#' @param encoding The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-#'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-#'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
-#' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
-#' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
-#'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
-#' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
-#'          the viewer pane and not even saved to file. This option is useful when the html output
-#'          should be used in \code{knitr} documents. The html output can be accessed via the return
-#'          value.
-#' @param remove.spaces logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
-#'          that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
-#'          may look less pretty, but it may help when exporting html-tables to office tools.
+#'          
+#' @inheritParams sjt.frq
+#' 
 #' @return Invisibly returns
 #'          \itemize{
 #'            \item the web page style sheet (\code{page.style}),
@@ -571,7 +560,7 @@ sjt.glm <- function(...,
       }
       fit.df$pv <- sapply(fit.df$pv, function(x) {
         if (x < 0.05) {
-          if (x < 0.001) {
+          if (x < 0.001 && digits.p <= 3) {
             x <- sprintf(""%s&lt;0.001%s"", sb1, sb2)
           } else {
             x <- sprintf(""%s%.*f%s"", sb1, digits.p, x, sb2)
@@ -1296,94 +1285,11 @@ sjt.glm <- function(...,
 #'                as HTML table, or saves them as file. The fitted models may have different predictors,
 #'                e.g. when comparing different stepwise fitted models.
 #' 
-#' @param ... One or more mixed models fitted with \code{\link[lme4]{glmer}}.
-#' @param file The destination file, which will be in html-format. If no filepath is specified,
-#'          the file will be saved as temporary file and openend either in the RStudio View pane or
-#'          in the default web browser.
-#' @param labelPredictors Labels of the predictor variables, provided as char vector.
-#' @param labelDependentVariables Labels of the dependent variables of all fitted models
-#'          which have been used as first parameter(s), provided as char vector.
-#' @param stringPredictors String constant used as headline for the predictor column.
-#'          Default is \code{""Predictors""}.
-#' @param stringDependentVariables String constant used as headline for the 
-#'          dependent variable columns. Default is \code{""Dependent Variables""}.
-#' @param showHeaderStrings If \code{TRUE}, the header strings \code{stringPredictors}
-#'          and \code{stringDependentVariables} are shown. By default, they're hidden.
-#' @param stringModel String constant used as headline for the model names in case no 
-#'          labels for the dependent variables are provided (see labelDependentVariables).
-#'          Default is \code{""Model""}.
-#' @param stringIntercept String constant used as headline for the Intercept row
-#'          default is \code{""Intercept""}.
-#' @param stringObservations String constant used in the summary row for the count of observation
-#'          (cases). Default is \code{""Observations""}.
-#' @param stringOR String used for the column heading of odds ratio values. Default is \code{""OR""}.
-#' @param stringCI String used for the column heading of confidence interval values. Default is \code{""CI""}.
-#' @param stringSE String used for the column heading of standard error values. Default is \code{""std. Error""}.
-#' @param stringP String used for the column heading of p values. Default is \code{""p""}.
-#' @param digits.est Amount of decimals for estimators.
-#' @param digits.p Amount of decimals for p-values.
-#' @param digits.ci Amount of decimals for confidence intervals.
-#' @param digits.se Amount of decimals for standard error.
-#' @param digits.summary Amount of decimals for values in model summary.
-#' @param exp.coef If \code{TRUE} (default), regression coefficients and confidence intervals are exponentiated
-#'          (odds ratios, \code{\link{exp}(\link{coef}(fit))}. Use \code{FALSE} if you want the non-exponentiated coefficients
-#'          (log-odds) as they are provided by the \code{\link{summary}} function.
-#' @param pvaluesAsNumbers If \code{TRUE}, p-values are shown as numbers. If \code{FALSE} (default),
-#'          p-values are indicated by asterisks.
-#' @param boldpvalues If \code{TRUE} (default), significant p-values are shown bold faced.
-#' @param showConfInt If \code{TRUE} (default), the confidence intervall is also printed to the table. Use
-#'          \code{FALSE} to omit the CI in the table.
-#' @param showStdError If \code{TRUE}, the standard errors are also printed.
-#'          Default is \code{FALSE}.
-#' @param separateConfColumn if \code{TRUE}, the CI values are shown in a separate table column.
-#'          Default is \code{FALSE}.
-#' @param newLineConf If \code{TRUE} and \code{separateConfColumn} is \code{FALSE}, inserts a line break
-#'          between OR and CI values. If \code{FALSE}, CI values are printed in the same
-#'          line with OR values.
-#' @param showAbbrHeadline If \code{TRUE} (default), the table data columns have a headline with 
-#'          abbreviations for odds ratios, confidence interval and p-values.
-#' @param showLogLik If \code{TRUE}, the Log-Likelihood for each model is printed
-#'          in the model summary. Default is \code{FALSE}.
-#' @param showICC If \code{TRUE}, the intra-class-correlation for each model is printed
-#'          in the model summary.
-#' @param showAIC If \code{TRUE}, the \code{\link{AIC}} value for each model is printed
-#'          in the model summary. Default is \code{FALSE}.
-#' @param showAICc If \code{TRUE}, the second-order AIC value for each model 
-#'          is printed in the model summary. Default is \code{FALSE}.
-#' @param showHosLem If \code{TRUE}, a Hosmer-Lemeshow-Goodness-of-fit-test is
-#'          performed. A well-fitting model shows no significant difference between 
-#'          the model and the observed data, i.e. the reported p-values should be
-#'          greater than 0.05.
-#' @param showFamily If \code{TRUE}, the family object and link function for each fitted model
-#'          are printed. Can be used in case you want to compare models with different link functions
-#'          and same predictors and response, to decide which model fits best. See \code{\link{family}}
-#'          for more details. It is recommended to inspect the model \code{\link{AIC}} (see \code{showAIC}) to get a
-#'          decision help for which model to choose.
-#' @param remove.estimates numeric vector with indices (order equals to row index of \code{coef(fit)}) 
-#'          or character vector with coefficient names that indicate which estimates should be removed
-#'          from the table output. The first estimate is the intercept, followed by the model predictors.
-#'          \emph{The intercept cannot be removed from the table output!} \code{remove.estimates = c(2:4)} 
-#'          would remove the 2nd to the 4th estimate (1st to 3d predictor after intercept) from the output. 
-#'          \code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default 
-#'          is \code{NULL}, i.e. all estimates are printed.
-#' @param cellSpacing The inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
-#'          suitable for viewing the table. Decrease this value (0.05 to 0.1) if you want to import the table
-#'          into Office documents. This is a convenient parameter for the \code{CSS} parameter for changing
-#'          cell spacing, which would be: \code{CSS=list(css.thead=""padding:0.2cm;"", css.tzdata=""padding:0.2cm;"")}.
-#' @param encoding The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-#'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-#'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
-#' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
-#' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
-#'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
-#' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
-#'          the viewer pane and not even saved to file. This option is useful when the html output
-#'          should be used in \code{knitr} documents. The html output can be accessed via the return
-#'          value.
-#' @param remove.spaces logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
-#'          that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
-#'          may look less pretty, but it may help when exporting html-tables to office tools.
+#' @inheritParams sjt.glm
+#' @inheritParams sjt.frq
+#' 
+#' @param showICC logical, if \code{TRUE}, the intra-class-correlation for each 
+#'          model is printed in the model summary.
 #' @return Invisibly returns
 #'          \itemize{
 #'            \item the web page style sheet (\code{page.style}),
@@ -1426,11 +1332,21 @@ sjt.glm <- function(...,
 #'               
 #' # print summary table
 #' sjt.glmer(fit1, fit2)
+#' 
+#' # print summary table, using different table layout
 #' sjt.glmer(fit1, fit2,
 #'           showAIC = TRUE,
 #'           showConfInt = FALSE,
 #'           showStdError = TRUE,
-#'           pvaluesAsNumbers = FALSE)}
+#'           pvaluesAsNumbers = FALSE)
+#'           
+#' # print summary table
+#' sjt.glmer(fit1, fit2,
+#'           labelPredictors = c(""Elder's gender (female)"",
+#'                               ""Hours of care per week"",
+#'                               ""Negative Impact"",
+#'                               ""Educational level (mid)"",
+#'                               ""Educational level (high)""))}
 #' 
 #' @export
 sjt.glmer <- function(...,

---FILE: R/sjTabPCA.R---
@@ -24,9 +24,6 @@
 #'          on 3 possible factors can not be clearly assigned to just one factor and thus would be removed
 #'          from the principal component analysis. By default, the minimum difference of loading values
 #'          between the highest and 2nd highest factor should be 0.1
-#' @param file The destination file, which will be in html-format. If no filepath is specified,
-#'          the file will be saved as temporary file and openend either in the RStudio View pane or
-#'          in the default web browser.
 #' @param varlabels The item labels that are printed in the first column. If no item labels are
 #'          provided (default), the data frame's column names are used. Item labels must
 #'          be a string vector, e.g.: \code{varlabels=c(""Var 1"", ""Var 2"", ""Var 3"")}.
@@ -50,20 +47,9 @@
 #'          \emph{""Proportion of Variance""} will be used.
 #' @param stringCpov The string for the table row that contains the cumulative variances. By default, 
 #'          \emph{""Cumulative Proportion""} will be used.
-#' @param encoding The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-#'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-#'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
-#' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
-#' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
-#'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
-#' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
-#'          the viewer pane and not even saved to file. This option is useful when the html output
-#'          should be used in \code{knitr} documents. The html output can be accessed via the return
-#'          value.
-#' @param remove.spaces logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
-#'          that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
-#'          may look less pretty, but it may help when exporting html-tables to office tools.
+#'          
+#' @inheritParams sjt.frq
+#'          
 #' @return Invisibly returns
 #'          \itemize{
 #'            \item the web page style sheet (\code{page.style}),
@@ -197,7 +183,7 @@ sjt.pca <- function (data,
     dataframeparam <- FALSE
     showMSA <- FALSE
   } else {
-    pcadata <- prcomp(na.omit(data), 
+    pcadata <- prcomp(stats::na.omit(data), 
                       retx = TRUE, 
                       center = TRUE, 
                       scale. = TRUE)
@@ -374,7 +360,7 @@ sjt.pca <- function (data,
     for (n in 1:length(unique(itemloadings))) {
       # calculate cronbach's alpha for those cases that all have the
       # highest loading on the same factor
-      cbv <- c(cbv, sjmisc::cronb(na.omit(dataframe[, which(itemloadings == n)])))
+      cbv <- c(cbv, sjmisc::cronb(stats::na.omit(dataframe[, which(itemloadings == n)])))
     }
     # cbv now contains the factor numbers and the related alpha values
     # for each ""factor dimension scale""

---FILE: R/sjTabPropTable.R---
@@ -16,9 +16,6 @@
 #'          Must be a vector of same length as \code{var.row}. Default is \code{NULL}, so no weights are used.
 #' @param digits amount of digits used for the percentage values inside table cells.
 #'          Default is 1.
-#' @param file destination file, if the output should be saved as file.
-#'          If \code{NULL} (default), the output will be saved as temporary file and 
-#'          openend either in the IDE's viewer pane or the default web browser.
 #' @param variableLabels character vector of same length as supplied variables, with 
 #'          the associated variable names. Following order is needed: name of \code{var.row},
 #'          name of \code{var.col}, and - if \code{var.grp} is not \code{NULL} - name of \code{var.grp}.
@@ -65,20 +62,9 @@
 #'          the percentage value.
 #' @param hundret Default value that indicates the 100-percent column-sums (since rounding values
 #'          may lead to non-exact results). Default is \code{""100.0""}.
-#' @param encoding The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-#'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-#'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
-#' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Detail'.
-#' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
-#'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
-#' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
-#'          the viewer pane and not even saved to file. This option is useful when the html output
-#'          should be used in \code{knitr} documents. The html output can be accessed via the return
-#'          value.
-#' @param remove.spaces logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
-#'          that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
-#'          may look less pretty, but it may help when exporting html-tables to office tools.
+#'          
+#' @inheritParams sjt.frq
+#'          
 #' @return Invisibly returns
 #'          \itemize{
 #'            \item the web page style sheet (\code{page.style}),
@@ -211,20 +197,20 @@ sjt.xtab <- function(var.row,
     # row value labels
     # --------------------------------------------------------
     vl <- sjmisc:::autoSetValueLabels(var.row)
-    if (is.null(vl)) vl <- sort(unique(na.omit(var.row)))
+    if (is.null(vl)) vl <- sort(unique(stats::na.omit(var.row)))
     valueLabels[[1]] <- vl
     # --------------------------------------------------------
     # column value labels
     # --------------------------------------------------------
     vl <- sjmisc:::autoSetValueLabels(var.col)
-    if (is.null(vl)) vl <- sort(unique(na.omit(var.col)))
+    if (is.null(vl)) vl <- sort(unique(stats::na.omit(var.col)))
     valueLabels[[2]] <- vl
     # --------------------------------------------------------
     # group value labels
     # --------------------------------------------------------
     if (!is.null(var.grp)) {
       vl <- sjmisc:::autoSetValueLabels(var.grp)
-      if (is.null(vl)) vl <- sort(unique(na.omit(var.grp)))
+      if (is.null(vl)) vl <- sort(unique(stats::na.omit(var.grp)))
       valueLabels[[3]] <- vl
     }
   }
@@ -346,20 +332,20 @@ sjt.xtab <- function(var.row,
   if (length(valueLabels) > 0) {
     labels.var.row <- valueLabels[[1]]
   } else {
-    labels.var.row <- seq_along(unique(na.omit(var.row)))
+    labels.var.row <- seq_along(unique(stats::na.omit(var.row)))
   }
   if (length(valueLabels) > 1) {
     labels.var.col <- valueLabels[[2]]
   } else {
-    labels.var.col <- seq_along(unique(na.omit(var.col)))
+    labels.var.col <- seq_along(unique(stats::na.omit(var.col)))
   }
   if (length(valueLabels) > 2) {
     labels.var.grp <- valueLabels[[3]]
   } else {
     if (is.null(var.grp)) {
       labels.var.grp <- NULL
     } else {
-      labels.var.grp <- seq_along(unique(na.omit(var.grp)))
+      labels.var.grp <- seq_along(unique(stats::na.omit(var.grp)))
     }
   }
   # ------------------------------------------

---FILE: R/sjTabSPSS.R---
@@ -46,9 +46,6 @@ view_spss <- function(x,
 #'          \code{\link[sjmisc]{read_sas}} or \code{\link[sjmisc]{read_stata}} function,
 #'          or any similar labelled data frame (see \code{\link[sjmisc]{set_var_labels}}
 #'          and \code{\link[sjmisc]{set_val_labels}}).
-#' @param file The destination file, which will be in html-format. If no filepath is specified,
-#'          the file will be saved as temporary file and openend either in the IDE's viewer pane or
-#'          in the default web browser.
 #' @param alternateRowColors logical, if \code{TRUE}, alternating rows are highlighted with a light gray
 #'          background color.
 #' @param showID logical, if \code{TRUE} (default), the variable ID is shown in the first column.
@@ -67,20 +64,9 @@ view_spss <- function(x,
 #'          Default value is 50, use \code{NULL} to turn off word wrap.
 #' @param hideProgressBar If \code{TRUE}, the progress bar that is displayed when creating the
 #'          table is hidden. Default in \code{FALSE}, hence the bar is visible.
-#' @param encoding The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-#'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-#'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
-#' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
-#' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
-#'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
-#' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
-#'          the viewer pane and not even saved to file. This option is useful when the html output
-#'          should be used in \code{knitr} documents. The html output can be accessed via the return
-#'          value.
-#' @param remove.spaces logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
-#'          that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
-#'          may look less pretty, but it may help when exporting html-tables to office tools.
+#'          
+#' @inheritParams sjt.frq
+#'          
 #' @return Invisibly returns
 #'          \itemize{
 #'            \item the web page style sheet (\code{page.style}),

---FILE: R/sjTabStackFrq.R---
@@ -54,23 +54,9 @@
 #'          Default is \code{""Kurtosis""}.
 #' @param alternateRowColors If \code{TRUE}, alternating rows are highlighted with a light gray
 #'          background color.
-#' @param file The destination file, which will be in html-format. If no filepath is specified,
-#'          the file will be saved as temporary file and openend either in the RStudio View pane or
-#'          in the default web browser.
-#' @param encoding The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-#'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-#'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
-#' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
-#' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
-#'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
-#' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
-#'          the viewer pane and not even saved to file. This option is useful when the html output
-#'          should be used in \code{knitr} documents. The html output can be accessed via the return
-#'          value.
-#' @param remove.spaces logical, if \code{TRUE}, leading spaces are removed from all lines in the final string
-#'          that contains the html-data. Use this, if you want to remove parantheses for html-tags. The html-source
-#'          may look less pretty, but it may help when exporting html-tables to office tools.
+#'          
+#' @inheritParams sjt.frq
+#'          
 #' @return Invisibly returns
 #'          \itemize{
 #'            \item the web page style sheet (\code{page.style}),
@@ -319,7 +305,7 @@ sjt.stackfrq <- function(items,
       # retrieve amount of categories
       tl <- length(names(dummy))
       # retrieve maximum category value, omitting NA
-      maxtl <- max(as.numeric(na.omit(names(dummy))))
+      maxtl <- max(as.numeric(stats::na.omit(names(dummy))))
       # set NA table name to max-value+1, so we have continuous
       # vector-index (needed below)
       names(dummy)[tl] <- maxtl + 1

---FILE: README.md---
@@ -40,7 +40,7 @@ install.packages(""sjPlot"")
 
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since core functionality of package depends on the [ggplot-package](http://cran.r-project.org/package=ggplot2), consider citing this package as well.
 
-### Changelog of development build 1.8.1-8
+### Changelog of development build 1.8.1-10
 
 #### General
 * Package documentation got major revisions.
@@ -57,6 +57,7 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 * Added parameter `axisLimits.x` to `sjp.int`, `sjp.frq` and `sjp.grpfrq`.
 * Added parameter `showAICc` to `sjt.lm`, `sjt.glm`, `sjt.lme` and `sjt.glmer` to print second-order AIC.
 * Improved automatic y-axis-limit detection in `sjp.frq` and `sjp.grpfrq`.
+* For `sjt.lm` and `sjt.glm`, if `digits.p` is greater than 3, p-values less than 0.001 will no longer be abbreviated to **<0.001**. Instead, the exact value (rounded to digits.p) will be printed.
 * Minor improvements to `sjp.likert`, `sjp.int`, `sjp.glm`, `sjp.frq` and `sjp.grpfrq`.
 
 #### Bug fixes

---FILE: man/sjPlot-package.Rd---
@@ -34,8 +34,8 @@
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.8.1-8\cr
-Date: \tab 2015-06-25\cr
+Version: \tab 1.8.1-10\cr
+Date: \tab 2015-06-30\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjp.int.Rd---
@@ -308,7 +308,7 @@ sjp.int(fit,
 library(sjmisc)
 data(efc)
 # create binary response
-y <- ifelse(efc$neg_c_7 < median(na.omit(efc$neg_c_7)), 0, 1)
+y <- ifelse(efc$neg_c_7 < median(stats::na.omit(efc$neg_c_7)), 0, 1)
 # create data frame for fitted model
 mydf <- data.frame(y = as.factor(y),
                    sex = as.factor(efc$c161sex),

---FILE: man/sjt.corr.Rd---
@@ -63,21 +63,22 @@ parameter (\code{""css.valueremove""}) to change color and appearance of those cor
 the limit specified by \code{val.rm}.}
 
 \item{stringDiagonal}{a vector with string values of the same length as \code{ncol(data)} (number of
-correlated items) that can be used to display content in the diagonal cells
-where row and column item are identical (i.e. the ""self-correlation""). By defauilt,
-this parameter is \code{NULL} and the diagnal cells are empty.}
+         correlated items) that can be used to display content in the diagonal cells
+         where row and column item are identical (i.e. the ""self-correlation""). By defauilt,
+         this parameter is \code{NULL} and the diagnal cells are empty.}
 
-\item{encoding}{The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
+\item{encoding}{string, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
 
-\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
+\item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
-\item{no.output}{If \code{TRUE}, the html-output is neither opened in a browser nor shown in
+\item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
 the viewer pane and not even saved to file. This option is useful when the html output
 should be used in \code{knitr} documents. The html output can be accessed via the return
 value.}

---FILE: man/sjt.df.Rd---
@@ -55,19 +55,20 @@ the table. Use \code{commentString} to specify the comment.}
 applies, if \code{showCommentRow} is \code{TRUE}.}
 
 \item{hideProgressBar}{If \code{TRUE}, the progress bar that is displayed when creating the
-table is hidden. Default in \code{FALSE}, hence the bar is visible.}
+         table is hidden. Default in \code{FALSE}, hence the bar is visible.}
 
-\item{encoding}{The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
+\item{encoding}{string, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
 
-\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
+\item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
-\item{no.output}{If \code{TRUE}, the html-output is neither opened in a browser nor shown in
+\item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
 the viewer pane and not even saved to file. This option is useful when the html output
 should be used in \code{knitr} documents. The html output can be accessed via the return
 value.}

---FILE: man/sjt.frq.Rd---
@@ -118,17 +118,18 @@ applies if \code{removeStringVectors} is \code{FALSE}.}
 \item{maxStringDist}{the allowed distance of string values in a character vector, which indicates
 when two string values are merged because they are considered as close enough.}
 
-\item{encoding}{The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
+\item{encoding}{string, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
 
-\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
+\item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
-\item{no.output}{If \code{TRUE}, the html-output is neither opened in a browser nor shown in
+\item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
 the viewer pane and not even saved to file. This option is useful when the html output
 should be used in \code{knitr} documents. The html output can be accessed via the return
 value.}
@@ -177,7 +178,7 @@ Shows (multiple) frequency tables as HTML file, or saves them as file.
 The HTML tables can either be saved as file and manually opened (specify parameter \code{file}) or
         they can be saved as temporary files and will be displayed in the RStudio Viewer pane (if working with RStudio)
         or opened with the default web browser. Displaying resp. opening a temporary file is the
-        default behaviour (i.e. \code{file=NULL}).
+        default behaviour (i.e. \code{file = NULL}).
 }
 \examples{
 \dontrun{

---FILE: man/sjt.glm.Rd---
@@ -22,57 +22,60 @@ sjt.glm(..., file = NULL, labelPredictors = NULL,
   remove.spaces = TRUE)
 }
 \arguments{
-\item{...}{one or more fitted \code{\link{glm}}-objects.}
+\item{...}{one or more fitted generalized linear (mixed) models.}
 
-\item{file}{The destination file, which will be in html-format. If no filepath is specified,
-the file will be saved as temporary file and openend either in the RStudio View pane or
-in the default web browser.}
+\item{file}{destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
 
-\item{labelPredictors}{Labels of the predictor variables, provided as char vector.}
+\item{labelPredictors}{character vector with labels of predictor variables.
+If not \code{NULL}, \code{labelPredictors} will be used in the first
+table column with the predictors' names. See 'Examples'.}
 
-\item{labelDependentVariables}{Labels of the dependent variables of all fitted models
-which have been used as first parameter(s), provided as char vector.}
+\item{labelDependentVariables}{character vector with labels of dependent
+variables of all fitted models. See 'Examples'.}
 
-\item{stringPredictors}{String constant used as headline for the predictor column.
+\item{stringPredictors}{string constant used as headline for the predictor column.
 Default is \code{""Predictors""}.}
 
-\item{stringDependentVariables}{String constant used as headline for the
+\item{stringDependentVariables}{string constant used as headline for the
 dependent variable columns. Default is \code{""Dependent Variables""}.}
 
-\item{showHeaderStrings}{If \code{TRUE}, the header strings \code{stringPredictors}
+\item{showHeaderStrings}{logical, if \code{TRUE}, the header strings \code{stringPredictors}
 and \code{stringDependentVariables} are shown. By default, they're hidden.}
 
-\item{stringModel}{String constant used as headline for the model names in case no
-labels for the dependent variables are provided (see labelDependentVariables).
+\item{stringModel}{string constant used as headline for the model names in case no
+labels for the dependent variables are provided (see \code{labelDependentVariables}).
 Default is \code{""Model""}.}
 
-\item{stringIntercept}{String constant used as headline for the Intercept row
-default is \code{""Intercept""}.}
+\item{stringIntercept}{String constant used as headline for the Intercept row.
+Default is \code{""Intercept""}.}
 
-\item{stringObservations}{String constant used in the summary row for the count of observation
+\item{stringObservations}{string constant used in the summary row for the count of observation
 (cases). Default is \code{""Observations""}.}
 
-\item{stringOR}{String used for the column heading of odds ratio values. Default is \code{""OR""}.}
+\item{stringOR}{string used for the column heading of odds ratio values. Default is \code{""OR""}.}
 
-\item{stringCI}{String used for the column heading of confidence interval values. Default is \code{""CI""}.}
+\item{stringCI}{string used for the column heading of confidence interval values. Default is \code{""CI""}.}
 
-\item{stringSE}{String used for the column heading of standard error values. Default is \code{""std. Error""}.}
+\item{stringSE}{string used for the column heading of standard error values. Default is \code{""std. Error""}.}
 
-\item{stringP}{String used for the column heading of p values. Default is \code{""p""}.}
+\item{stringP}{string used for the column heading of p values. Default is \code{""p""}.}
 
-\item{digits.est}{Amount of decimals for estimators.}
+\item{digits.est}{amount of decimals for estimators}
 
-\item{digits.p}{Amount of decimals for p-values.}
+\item{digits.p}{amount of decimals for p-values}
 
-\item{digits.ci}{Amount of decimals for confidence intervals.}
+\item{digits.ci}{amount of decimals for confidence intervals}
 
-\item{digits.se}{Amount of decimals for standard error.}
+\item{digits.se}{amount of decimals for standard error}
 
-\item{digits.summary}{Amount of decimals for values in model summary.}
+\item{digits.summary}{amount of decimals for values in model summary}
 
-\item{exp.coef}{If \code{TRUE} (default), regression coefficients and confidence intervals are exponentiated
-(odds ratios, \code{\link{exp}(\link{coef}(fit))}. Use \code{FALSE} if you want the non-exponentiated coefficients
-(log-odds) as they are provided by the \code{\link{summary}} function.}
+\item{exp.coef}{logical, if \code{TRUE} (default), regression coefficients and
+confidence intervals are exponentiated. Use \code{FALSE} for
+non-exponentiated coefficients (log-odds) as provided by
+the \code{\link{summary}} function.}
 
 \item{pvaluesAsNumbers}{If \code{TRUE}, p-values are shown as numbers. If \code{FALSE} (default),
 p-values are indicated by asterisks.}
@@ -88,7 +91,7 @@ Default is \code{FALSE}.}
 \item{separateConfColumn}{if \code{TRUE}, the CI values are shown in a separate table column.
 Default is \code{FALSE}.}
 
-\item{newLineConf}{If \code{TRUE} and \code{separateConfColumn} is \code{FALSE}, inserts a line break
+\item{newLineConf}{If \code{TRUE} and \code{separateConfColumn = FALSE}, inserts a line break
 between OR and CI values. If \code{FALSE}, CI values are printed in the same
 line with OR values.}
 
@@ -140,25 +143,26 @@ would remove the 2nd to the 4th estimate (1st to 3d predictor after intercept) f
 \code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default
 is \code{NULL}, i.e. all estimates are printed.}
 
-\item{cellSpacing}{The inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
+\item{cellSpacing}{numeric, inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
 suitable for viewing the table. Decrease this value (0.05 to 0.1) if you want to import the table
 into Office documents. This is a convenient parameter for the \code{CSS} parameter for changing
-cell spacing, which would be: \code{CSS=list(css.thead=""padding:0.2cm;"", css.tzdata=""padding:0.2cm;"")}.}
+cell spacing, which would be: \code{CSS = list(css.thead = ""padding:0.2cm;"", css.tdata = ""padding:0.2cm;"")}.}
 
 \item{cellGroupIndent}{Indent for table rows with grouped factor predictors. Only applies
-if \code{group.pred} is \code{TRUE}.}
+         if \code{group.pred} is \code{TRUE}.}
 
-\item{encoding}{The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
+\item{encoding}{string, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
 
-\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
+\item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
-\item{no.output}{If \code{TRUE}, the html-output is neither opened in a browser nor shown in
+\item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
 the viewer pane and not even saved to file. This option is useful when the html output
 should be used in \code{knitr} documents. The html output can be accessed via the return
 value.}

---FILE: man/sjt.glmer.Rd---
@@ -21,57 +21,60 @@ sjt.glmer(..., file = NULL, labelPredictors = NULL,
   remove.spaces = TRUE)
 }
 \arguments{
-\item{...}{One or more mixed models fitted with \code{\link[lme4]{glmer}}.}
+\item{...}{one or more fitted generalized linear (mixed) models.}
 
-\item{file}{The destination file, which will be in html-format. If no filepath is specified,
-the file will be saved as temporary file and openend either in the RStudio View pane or
-in the default web browser.}
+\item{file}{destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
 
-\item{labelPredictors}{Labels of the predictor variables, provided as char vector.}
+\item{labelPredictors}{character vector with labels of predictor variables.
+If not \code{NULL}, \code{labelPredictors} will be used in the first
+table column with the predictors' names. See 'Examples'.}
 
-\item{labelDependentVariables}{Labels of the dependent variables of all fitted models
-which have been used as first parameter(s), provided as char vector.}
+\item{labelDependentVariables}{character vector with labels of dependent
+variables of all fitted models. See 'Examples'.}
 
-\item{stringPredictors}{String constant used as headline for the predictor column.
+\item{stringPredictors}{string constant used as headline for the predictor column.
 Default is \code{""Predictors""}.}
 
-\item{stringDependentVariables}{String constant used as headline for the
+\item{stringDependentVariables}{string constant used as headline for the
 dependent variable columns. Default is \code{""Dependent Variables""}.}
 
-\item{showHeaderStrings}{If \code{TRUE}, the header strings \code{stringPredictors}
+\item{showHeaderStrings}{logical, if \code{TRUE}, the header strings \code{stringPredictors}
 and \code{stringDependentVariables} are shown. By default, they're hidden.}
 
-\item{stringModel}{String constant used as headline for the model names in case no
-labels for the dependent variables are provided (see labelDependentVariables).
+\item{stringModel}{string constant used as headline for the model names in case no
+labels for the dependent variables are provided (see \code{labelDependentVariables}).
 Default is \code{""Model""}.}
 
-\item{stringIntercept}{String constant used as headline for the Intercept row
-default is \code{""Intercept""}.}
+\item{stringIntercept}{String constant used as headline for the Intercept row.
+Default is \code{""Intercept""}.}
 
-\item{stringObservations}{String constant used in the summary row for the count of observation
+\item{stringObservations}{string constant used in the summary row for the count of observation
 (cases). Default is \code{""Observations""}.}
 
-\item{stringOR}{String used for the column heading of odds ratio values. Default is \code{""OR""}.}
+\item{stringOR}{string used for the column heading of odds ratio values. Default is \code{""OR""}.}
 
-\item{stringCI}{String used for the column heading of confidence interval values. Default is \code{""CI""}.}
+\item{stringCI}{string used for the column heading of confidence interval values. Default is \code{""CI""}.}
 
-\item{stringSE}{String used for the column heading of standard error values. Default is \code{""std. Error""}.}
+\item{stringSE}{string used for the column heading of standard error values. Default is \code{""std. Error""}.}
 
-\item{stringP}{String used for the column heading of p values. Default is \code{""p""}.}
+\item{stringP}{string used for the column heading of p values. Default is \code{""p""}.}
 
-\item{digits.est}{Amount of decimals for estimators.}
+\item{digits.est}{amount of decimals for estimators}
 
-\item{digits.p}{Amount of decimals for p-values.}
+\item{digits.p}{amount of decimals for p-values}
 
-\item{digits.ci}{Amount of decimals for confidence intervals.}
+\item{digits.ci}{amount of decimals for confidence intervals}
 
-\item{digits.se}{Amount of decimals for standard error.}
+\item{digits.se}{amount of decimals for standard error}
 
-\item{digits.summary}{Amount of decimals for values in model summary.}
+\item{digits.summary}{amount of decimals for values in model summary}
 
-\item{exp.coef}{If \code{TRUE} (default), regression coefficients and confidence intervals are exponentiated
-(odds ratios, \code{\link{exp}(\link{coef}(fit))}. Use \code{FALSE} if you want the non-exponentiated coefficients
-(log-odds) as they are provided by the \code{\link{summary}} function.}
+\item{exp.coef}{logical, if \code{TRUE} (default), regression coefficients and
+confidence intervals are exponentiated. Use \code{FALSE} for
+non-exponentiated coefficients (log-odds) as provided by
+the \code{\link{summary}} function.}
 
 \item{pvaluesAsNumbers}{If \code{TRUE}, p-values are shown as numbers. If \code{FALSE} (default),
 p-values are indicated by asterisks.}
@@ -87,15 +90,15 @@ Default is \code{FALSE}.}
 \item{separateConfColumn}{if \code{TRUE}, the CI values are shown in a separate table column.
 Default is \code{FALSE}.}
 
-\item{newLineConf}{If \code{TRUE} and \code{separateConfColumn} is \code{FALSE}, inserts a line break
+\item{newLineConf}{If \code{TRUE} and \code{separateConfColumn = FALSE}, inserts a line break
 between OR and CI values. If \code{FALSE}, CI values are printed in the same
 line with OR values.}
 
 \item{showAbbrHeadline}{If \code{TRUE} (default), the table data columns have a headline with
 abbreviations for odds ratios, confidence interval and p-values.}
 
-\item{showICC}{If \code{TRUE}, the intra-class-correlation for each model is printed
-in the model summary.}
+\item{showICC}{logical, if \code{TRUE}, the intra-class-correlation for each
+model is printed in the model summary.}
 
 \item{showLogLik}{If \code{TRUE}, the Log-Likelihood for each model is printed
 in the model summary. Default is \code{FALSE}.}
@@ -125,22 +128,23 @@ would remove the 2nd to the 4th estimate (1st to 3d predictor after intercept) f
 \code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default
 is \code{NULL}, i.e. all estimates are printed.}
 
-\item{cellSpacing}{The inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
+\item{cellSpacing}{numeric, inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
 suitable for viewing the table. Decrease this value (0.05 to 0.1) if you want to import the table
 into Office documents. This is a convenient parameter for the \code{CSS} parameter for changing
-cell spacing, which would be: \code{CSS=list(css.thead=""padding:0.2cm;"", css.tzdata=""padding:0.2cm;"")}.}
+cell spacing, which would be: \code{CSS = list(css.thead = ""padding:0.2cm;"", css.tdata = ""padding:0.2cm;"")}.}
 
-\item{encoding}{The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
+\item{encoding}{string, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
 
-\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
+\item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
-\item{no.output}{If \code{TRUE}, the html-output is neither opened in a browser nor shown in
+\item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
 the viewer pane and not even saved to file. This option is useful when the html output
 should be used in \code{knitr} documents. The html output can be accessed via the return
 value.}
@@ -199,10 +203,20 @@ fit2 <- glmer(hi_qol ~ sex + c12hour + neg_c_7 + education + (1|grp),
 
 # print summary table
 sjt.glmer(fit1, fit2)
+
+# print summary table, using different table layout
 sjt.glmer(fit1, fit2,
           showAIC = TRUE,
           showConfInt = FALSE,
           showStdError = TRUE,
-          pvaluesAsNumbers = FALSE)}
+          pvaluesAsNumbers = FALSE)
+
+# print summary table
+sjt.glmer(fit1, fit2,
+          labelPredictors = c(""Elder's gender (female)"",
+                              ""Hours of care per week"",
+                              ""Negative Impact"",
+                              ""Educational level (mid)"",
+                              ""Educational level (high)""))}
 }
 

---FILE: man/sjt.grpmean.Rd---
@@ -25,21 +25,22 @@ are automatically detected if set by \code{\link[sjmisc]{set_val_labels}}.}
 
 \item{digits.summary}{amount of digits for summary statistics (Anova).}
 
-\item{file}{The destination file, which will be in html-format. If no filepath is specified,
-the file will be saved as temporary file and openend either in the RStudio View pane or
-in the default web browser.}
+\item{file}{destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
 
-\item{encoding}{The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
+\item{encoding}{string, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
 
-\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
+\item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
-\item{no.output}{If \code{TRUE}, the html-output is neither opened in a browser nor shown in
+\item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
 the viewer pane and not even saved to file. This option is useful when the html output
 should be used in \code{knitr} documents. The html output can be accessed via the return
 value.}

---FILE: man/sjt.itemanalysis.Rd---
@@ -54,28 +54,29 @@ See \code{\link{shapiro.test}} for details.}
 and \code{\link[psych]{describe}} in the \code{psych}-package for more details.}
 
 \item{showCompCorrMat}{If \code{TRUE} (default), a correlation matrix of each component's
-index score is shown. Only applies if \code{factor.groups} is not \code{NULL} and \code{df} has
-more than one group. First, for each case (df's row), the sum of all variables (df's columns) is
-scaled (using the \code{\link{scale}}-function) and represents a ""total score"" for
-each component (a component is represented by each group of \code{factor.groups}).
-After that, each case (df's row) has a scales sum score for each component.
-Finally, a correlation of these ""scale sum scores"" is computed.}
-
-\item{file}{The destination file, which will be in html-format. If no filepath is specified (default),
-the file will be saved as temporary file and openend either in the RStudio View pane or
-in the default web browser.}
-
-\item{encoding}{The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
-
-\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
+         index score is shown. Only applies if \code{factor.groups} is not \code{NULL} and \code{df} has
+         more than one group. First, for each case (df's row), the sum of all variables (df's columns) is
+         scaled (using the \code{\link{scale}}-function) and represents a ""total score"" for
+         each component (a component is represented by each group of \code{factor.groups}).
+         After that, each case (df's row) has a scales sum score for each component.
+         Finally, a correlation of these ""scale sum scores"" is computed.}
+
+\item{file}{destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
+
+\item{encoding}{string, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
+
+\item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
-\item{no.output}{If \code{TRUE}, the html-output is neither opened in a browser nor shown in
+\item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
 the viewer pane and not even saved to file. This option is useful when the html output
 should be used in \code{knitr} documents. The html output can be accessed via the return
 value.}

---FILE: man/sjt.lm.Rd---
@@ -21,78 +21,80 @@ sjt.lm(..., file = NULL, labelPredictors = NULL,
   useViewer = TRUE, no.output = FALSE, remove.spaces = TRUE)
 }
 \arguments{
-\item{...}{One or more fitted lm-objects.}
+\item{...}{one or more fitted linear (mixed) models.}
 
-\item{file}{The destination file, which will be in html-format. If no filepath is specified,
-the file will be saved as temporary file and openend either in the RStudio View pane or
-in the default web browser.}
+\item{file}{destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
 
-\item{labelPredictors}{Labels of the predictor variables, provided as char vector.}
+\item{labelPredictors}{character vector with labels of predictor variables.
+If not \code{NULL}, \code{labelPredictors} will be used in the first
+table column with the predictors' names. See 'Examples'.}
 
-\item{labelDependentVariables}{Labels of the dependent variables of all fitted models
-which have been used as first parameter(s), provided as char vector.}
+\item{labelDependentVariables}{character vector with labels of dependent
+variables of all fitted models. See 'Examples'.}
 
-\item{stringPredictors}{String constant used as headline for the predictor column.
+\item{stringPredictors}{string constant used as headline for the predictor column.
 Default is \code{""Predictors""}.}
 
-\item{stringDependentVariables}{String constant used as headline for the
+\item{stringDependentVariables}{string constant used as headline for the
 dependent variable columns. Default is \code{""Dependent Variables""}.}
 
-\item{stringModel}{String constant used as headline for the model names in case no
+\item{stringModel}{string constant used as headline for the model names in case no
 labels for the dependent variables are provided (see labelDependentVariables).
 Default is \code{""Model""}.}
 
-\item{showHeaderStrings}{If \code{TRUE}, the header strings \code{stringPredictors}
+\item{showHeaderStrings}{logical, if \code{TRUE}, the header strings \code{stringPredictors}
 and \code{stringDependentVariables} are shown. By default, they're hidden.}
 
-\item{stringIntercept}{String constant used as headline for the Intercept row
-default is \code{""Intercept""}.}
+\item{stringIntercept}{string constant used as headline for the Intercept row.
+Default is \code{""Intercept""}.}
 
-\item{stringObservations}{String constant used in the summary row for the count of observation
+\item{stringObservations}{string constant used in the summary row for the count of observation
 (cases). Default is \code{""Observations""}.}
 
-\item{stringB}{String used for the column heading of beta coefficients. Default is \code{""B""}.}
+\item{stringB}{string used for the column heading of beta coefficients. Default is \code{""B""}.}
 
-\item{stringSB}{String used for the column heading of standardized beta coefficients. Default is \code{""std. Beta""}.}
+\item{stringSB}{string used for the column heading of standardized beta coefficients. Default is \code{""std. Beta""}.}
 
-\item{stringCI}{String used for the column heading of confidence interval values. Default is \code{""CI""}.}
+\item{stringCI}{string used for the column heading of confidence interval values. Default is \code{""CI""}.}
 
-\item{stringSE}{String used for the column heading of standard error values. Default is \code{""std. Error""}.}
+\item{stringSE}{string used for the column heading of standard error values. Default is \code{""std. Error""}.}
 
-\item{stringP}{String used for the column heading of p values. Default is \code{""p""}.}
+\item{stringP}{string used for the column heading of p values. Default is \code{""p""}.}
 
-\item{showEst}{If \code{TRUE} (default), the estimates are printed.}
+\item{showEst}{logical, if \code{TRUE} (default), the estimates are printed.}
 
-\item{showConfInt}{If \code{TRUE} (default), the confidence intervall is also printed to the table. Use
+\item{showConfInt}{logical, if \code{TRUE} (default), the confidence intervall is also printed to the table. Use
 \code{FALSE} to omit the CI in the table.}
 
-\item{showStdBeta}{If \code{TRUE}, the standardized beta-coefficients are also printed.
+\item{showStdBeta}{logical, if \code{TRUE}, the standardized beta-coefficients are also printed.
 Default is \code{FALSE}.}
 
-\item{showStdError}{If \code{TRUE}, the standard errors are also printed.
+\item{showStdError}{logical, if \code{TRUE}, the standard errors are also printed.
 Default is \code{FALSE}.}
 
-\item{digits.est}{Amount of decimals for estimators.}
+\item{digits.est}{amount of decimals for estimators}
 
-\item{digits.p}{Amount of decimals for p-values.}
+\item{digits.p}{amount of decimals for p-values}
 
-\item{digits.ci}{Amount of decimals for confidence intervals.}
+\item{digits.ci}{amount of decimals for confidence intervals}
 
-\item{digits.se}{Amount of decimals for standard error.}
+\item{digits.se}{amount of decimals for standard error}
 
-\item{digits.sb}{Amount of decimals for standardized beta.}
+\item{digits.sb}{amount of decimals for standardized beta}
 
-\item{digits.summary}{Amount of decimals for values in model summary.}
+\item{digits.summary}{amount of decimals for values in model summary}
 
-\item{pvaluesAsNumbers}{If \code{TRUE}, p-values are shown as numbers. If \code{FALSE} (default),
+\item{pvaluesAsNumbers}{logical, if \code{TRUE}, p-values are shown as numbers. If \code{FALSE} (default),
 p-values are indicated by asterisks.}
 
-\item{boldpvalues}{If \code{TRUE} (default), significant p-values are shown bold faced.}
+\item{boldpvalues}{logical, if \code{TRUE} (default), significant p-values are shown bold faced.}
 
 \item{separateConfColumn}{if \code{TRUE}, the CI values are shown in a separate table column.
 Default is \code{FALSE}.}
 
-\item{newLineConf}{If \code{TRUE} and \code{separateConfColumn} is \code{FALSE}, inserts a line break
+\item{newLineConf}{logica, if \code{TRUE} and \code{separateConfColumn = FALSE}, inserts a line break
 between B and CI values. If \code{FALSE}, CI values are printed in the same
 line with B values.}
 
@@ -101,10 +103,10 @@ factor levels of same factor, i.e. predictors of type \code{\link{factor}} will
 be grouped, if the factor has more than two levels. Grouping means that a separate headline
 row is inserted to the table just before the predictor values.}
 
-\item{showAbbrHeadline}{If \code{TRUE} (default), the table data columns have a headline with
+\item{showAbbrHeadline}{logical, if \code{TRUE} (default), the table data columns have a headline with
 abbreviations for beta- and std. beta-values, confidence interval and p-values.}
 
-\item{showR2}{If \code{TRUE} (default), the R2 and adjusted R2 values for each model are printed
+\item{showR2}{logical, if \code{TRUE} (default), the R2 and adjusted R2 values for each model are printed
 in the model summary.}
 
 \item{showFStat}{If \code{TRUE}, the F-statistics for each model is printed
@@ -124,25 +126,26 @@ would remove the 2nd to the 4th estimate (1st to 3d predictor after intercept) f
 \code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default
 is \code{NULL}, i.e. all estimates are printed.}
 
-\item{cellSpacing}{The inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
+\item{cellSpacing}{numeric, inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
 suitable for viewing the table. Decrease this value (0.05 to 0.1) if you want to import the table
 into Office documents. This is a convenient parameter for the \code{CSS} parameter for changing
-cell spacing, which would be: \code{CSS=list(css.thead=""padding:0.2cm;"", css.tzdata=""padding:0.2cm;"")}.}
+cell spacing, which would be: \code{CSS = list(css.thead = ""padding:0.2cm;"", css.tdata = ""padding:0.2cm;"")}.}
 
 \item{cellGroupIndent}{Indent for table rows with grouped factor predictors. Only applies
-if \code{group.pred} is \code{TRUE}.}
+         if \code{group.pred} is \code{TRUE}.}
 
-\item{encoding}{The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
+\item{encoding}{string, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
 
-\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
+\item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
-\item{no.output}{If \code{TRUE}, the html-output is neither opened in a browser nor shown in
+\item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
 the viewer pane and not even saved to file. This option is useful when the html output
 should be used in \code{knitr} documents. The html output can be accessed via the return
 value.}

---FILE: man/sjt.lmer.Rd---
@@ -20,86 +20,88 @@ sjt.lmer(..., file = NULL, labelPredictors = NULL,
   CSS = NULL, useViewer = TRUE, no.output = FALSE, remove.spaces = TRUE)
 }
 \arguments{
-\item{...}{One or more mixed models fitted with \code{\link[lme4]{lmer}} or \code{\link[lmerTest]{lmer}}.}
+\item{...}{one or more fitted linear (mixed) models.}
 
-\item{file}{The destination file, which will be in html-format. If no filepath is specified,
-the file will be saved as temporary file and openend either in the RStudio View pane or
-in the default web browser.}
+\item{file}{destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
 
-\item{labelPredictors}{Labels of the predictor variables, provided as char vector.}
+\item{labelPredictors}{character vector with labels of predictor variables.
+If not \code{NULL}, \code{labelPredictors} will be used in the first
+table column with the predictors' names. See 'Examples'.}
 
-\item{labelDependentVariables}{Labels of the dependent variables of all fitted models
-which have been used as first parameter(s), provided as char vector.}
+\item{labelDependentVariables}{character vector with labels of dependent
+variables of all fitted models. See 'Examples'.}
 
-\item{stringPredictors}{String constant used as headline for the predictor column.
+\item{stringPredictors}{string constant used as headline for the predictor column.
 Default is \code{""Predictors""}.}
 
-\item{stringDependentVariables}{String constant used as headline for the
+\item{stringDependentVariables}{string constant used as headline for the
 dependent variable columns. Default is \code{""Dependent Variables""}.}
 
-\item{stringModel}{String constant used as headline for the model names in case no
+\item{stringModel}{string constant used as headline for the model names in case no
 labels for the dependent variables are provided (see labelDependentVariables).
 Default is \code{""Model""}.}
 
-\item{showHeaderStrings}{If \code{TRUE}, the header strings \code{stringPredictors}
+\item{showHeaderStrings}{logical, if \code{TRUE}, the header strings \code{stringPredictors}
 and \code{stringDependentVariables} are shown. By default, they're hidden.}
 
-\item{stringIntercept}{String constant used as headline for the Intercept row
-default is \code{""Intercept""}.}
+\item{stringIntercept}{string constant used as headline for the Intercept row.
+Default is \code{""Intercept""}.}
 
-\item{stringObservations}{String constant used in the summary row for the count of observation
+\item{stringObservations}{string constant used in the summary row for the count of observation
 (cases). Default is \code{""Observations""}.}
 
-\item{stringB}{String used for the column heading of beta coefficients. Default is \code{""B""}.}
+\item{stringB}{string used for the column heading of beta coefficients. Default is \code{""B""}.}
 
-\item{stringSB}{String used for the column heading of standardized beta coefficients. Default is \code{""std. Beta""}.}
+\item{stringSB}{string used for the column heading of standardized beta coefficients. Default is \code{""std. Beta""}.}
 
-\item{stringCI}{String used for the column heading of confidence interval values. Default is \code{""CI""}.}
+\item{stringCI}{string used for the column heading of confidence interval values. Default is \code{""CI""}.}
 
-\item{stringSE}{String used for the column heading of standard error values. Default is \code{""std. Error""}.}
+\item{stringSE}{string used for the column heading of standard error values. Default is \code{""std. Error""}.}
 
-\item{stringP}{String used for the column heading of p values. Default is \code{""p""}.}
+\item{stringP}{string used for the column heading of p values. Default is \code{""p""}.}
 
-\item{showEst}{If \code{TRUE} (default), the estimates are printed.}
+\item{showEst}{logical, if \code{TRUE} (default), the estimates are printed.}
 
-\item{showConfInt}{If \code{TRUE} (default), the confidence intervall is also printed to the table. Use
+\item{showConfInt}{logical, if \code{TRUE} (default), the confidence intervall is also printed to the table. Use
 \code{FALSE} to omit the CI in the table.}
 
-\item{showStdBeta}{If \code{TRUE}, the standardized beta-coefficients are also printed.
+\item{showStdBeta}{logical, if \code{TRUE}, the standardized beta-coefficients are also printed.
 Default is \code{FALSE}.}
 
-\item{showStdError}{If \code{TRUE}, the standard errors are also printed.
+\item{showStdError}{logical, if \code{TRUE}, the standard errors are also printed.
 Default is \code{FALSE}.}
 
-\item{digits.est}{Amount of decimals for estimators.}
+\item{digits.est}{amount of decimals for estimators}
 
-\item{digits.p}{Amount of decimals for p-values.}
+\item{digits.p}{amount of decimals for p-values}
 
-\item{digits.ci}{Amount of decimals for confidence intervals.}
+\item{digits.ci}{amount of decimals for confidence intervals}
 
-\item{digits.se}{Amount of decimals for standard error.}
+\item{digits.se}{amount of decimals for standard error}
 
-\item{digits.sb}{Amount of decimals for standardized beta.}
+\item{digits.sb}{amount of decimals for standardized beta}
 
-\item{digits.summary}{Amount of decimals for values in model summary.}
+\item{digits.summary}{amount of decimals for values in model summary}
 
-\item{pvaluesAsNumbers}{If \code{TRUE}, p-values are shown as numbers. If \code{FALSE} (default),
+\item{pvaluesAsNumbers}{logical, if \code{TRUE}, p-values are shown as numbers. If \code{FALSE} (default),
 p-values are indicated by asterisks.}
 
-\item{boldpvalues}{If \code{TRUE} (default), significant p-values are shown bold faced.}
+\item{boldpvalues}{logical, if \code{TRUE} (default), significant p-values are shown bold faced.}
 
 \item{separateConfColumn}{if \code{TRUE}, the CI values are shown in a separate table column.
 Default is \code{FALSE}.}
 
-\item{newLineConf}{If \code{TRUE} and \code{separateConfColumn} is \code{FALSE}, inserts a line break
+\item{newLineConf}{logica, if \code{TRUE} and \code{separateConfColumn = FALSE}, inserts a line break
 between B and CI values. If \code{FALSE}, CI values are printed in the same
 line with B values.}
 
-\item{showAbbrHeadline}{If \code{TRUE} (default), the table data columns have a headline with
+\item{showAbbrHeadline}{logical, if \code{TRUE} (default), the table data columns have a headline with
 abbreviations for beta- and std. beta-values, confidence interval and p-values.}
 
-\item{showICC}{If \code{TRUE}, the intra-class-correlation for each model is printed
-in the model summary.}
+\item{showICC}{logical, if \code{TRUE}, the intra-class-correlation for each
+model is printed in the model summary.}
 
 \item{showAIC}{If \code{TRUE}, the AIC value for each model is printed
 in the model summary. Default is \code{FALSE}.}
@@ -115,22 +117,23 @@ would remove the 2nd to the 4th estimate (1st to 3d predictor after intercept) f
 \code{remove.estimates = ""est_name""} would remove the estimate \emph{est_name}. Default
 is \code{NULL}, i.e. all estimates are printed.}
 
-\item{cellSpacing}{The inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
+\item{cellSpacing}{numeric, inner padding of table cells. By default, this value is 0.2 (unit is cm), which is
 suitable for viewing the table. Decrease this value (0.05 to 0.1) if you want to import the table
 into Office documents. This is a convenient parameter for the \code{CSS} parameter for changing
-cell spacing, which would be: \code{CSS=list(css.thead=""padding:0.2cm;"", css.tzdata=""padding:0.2cm;"")}.}
+cell spacing, which would be: \code{CSS = list(css.thead = ""padding:0.2cm;"", css.tdata = ""padding:0.2cm;"")}.}
 
-\item{encoding}{The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
+\item{encoding}{string, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
 
-\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
+\item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
-\item{no.output}{If \code{TRUE}, the html-output is neither opened in a browser nor shown in
+\item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
 the viewer pane and not even saved to file. This option is useful when the html output
 should be used in \code{knitr} documents. The html output can be accessed via the return
 value.}
@@ -201,7 +204,14 @@ sjt.lmer(fit1, fit2,
 sjt.lmer(fit1, fit2, fit3,
          showAIC = TRUE,
          separateConfColumn = FALSE,
-         newLineConf = FALSE)}
+         newLineConf = FALSE)
+
+sjt.lmer(fit1, fit2, fit3,
+         labelPredictors = c(""Elder's gender (female)"",
+                             ""Hours of care per week"",
+                             ""Barthel Index"",
+                             ""Educational level (mid)"",
+                             ""Educational level (high)""))}
 }
 \seealso{
 \href{http://strengejacke.de/sjPlot/sjt.lmer/}{sjPlot manual: sjt.lmer}

---FILE: man/sjt.mwu.Rd---
@@ -16,21 +16,22 @@ sjt.mwu(x, title = NULL, alternateRowColors = TRUE, file = NULL,
 \item{alternateRowColors}{If \code{TRUE}, alternating rows are highlighted with a light gray
 background color.}
 
-\item{file}{The destination file, which will be in html-format. If no filepath is specified,
-the file will be saved as temporary file and openend either in the RStudio View pane or
-in the default web browser.}
+\item{file}{destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
 
-\item{encoding}{The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
+\item{encoding}{string, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
 
-\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
+\item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
-\item{no.output}{If \code{TRUE}, the html-output is neither opened in a browser nor shown in
+\item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
 the viewer pane and not even saved to file. This option is useful when the html output
 should be used in \code{knitr} documents. The html output can be accessed via the return
 value.}

---FILE: man/sjt.pca.Rd---
@@ -28,9 +28,9 @@ on 3 possible factors can not be clearly assigned to just one factor and thus wo
 from the principal component analysis. By default, the minimum difference of loading values
 between the highest and 2nd highest factor should be 0.1}
 
-\item{file}{The destination file, which will be in html-format. If no filepath is specified,
-the file will be saved as temporary file and openend either in the RStudio View pane or
-in the default web browser.}
+\item{file}{destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
 
 \item{varlabels}{The item labels that are printed in the first column. If no item labels are
 provided (default), the data frame's column names are used. Item labels must
@@ -63,19 +63,20 @@ background color.}
 \emph{""Proportion of Variance""} will be used.}
 
 \item{stringCpov}{The string for the table row that contains the cumulative variances. By default,
-\emph{""Cumulative Proportion""} will be used.}
+         \emph{""Cumulative Proportion""} will be used.}
 
-\item{encoding}{The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
+\item{encoding}{string, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
 
-\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
+\item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
-\item{no.output}{If \code{TRUE}, the html-output is neither opened in a browser nor shown in
+\item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
 the viewer pane and not even saved to file. This option is useful when the html output
 should be used in \code{knitr} documents. The html output can be accessed via the return
 value.}

---FILE: man/sjt.stackfrq.Rd---
@@ -45,7 +45,7 @@ by highest count of first or last category of \code{items}.
 }}
 
 \item{alternateRowColors}{If \code{TRUE}, alternating rows are highlighted with a light gray
-background color.}
+         background color.}
 
 \item{digits}{The amount of digits for rounding the percentage values.
 Default is 2, i.e. percentage values have 2 digits after decimal point.}
@@ -75,21 +75,22 @@ Default is \code{""Skew""}.}
 \item{kurtosisString}{A character string, which is used as header for the kurtosis column (see \code{showKurtosis})).
 Default is \code{""Kurtosis""}.}
 
-\item{file}{The destination file, which will be in html-format. If no filepath is specified,
-the file will be saved as temporary file and openend either in the RStudio View pane or
-in the default web browser.}
+\item{file}{destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
 
-\item{encoding}{The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
+\item{encoding}{string, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
 
-\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
+\item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
-\item{no.output}{If \code{TRUE}, the html-output is neither opened in a browser nor shown in
+\item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
 the viewer pane and not even saved to file. This option is useful when the html output
 should be used in \code{knitr} documents. The html output can be accessed via the return
 value.}

---FILE: man/sjt.xtab.Rd---
@@ -104,19 +104,20 @@ Default is \code{""&nbsp;\%""}, hence the percentage sign has a non-breaking-space
 the percentage value.}
 
 \item{hundret}{Default value that indicates the 100-percent column-sums (since rounding values
-may lead to non-exact results). Default is \code{""100.0""}.}
+         may lead to non-exact results). Default is \code{""100.0""}.}
 
-\item{encoding}{The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
+\item{encoding}{string, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
 
-\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
-\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Detail'.}
+\item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the
+\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
-\item{no.output}{If \code{TRUE}, the html-output is neither opened in a browser nor shown in
+\item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
 the viewer pane and not even saved to file. This option is useful when the html output
 should be used in \code{knitr} documents. The html output can be accessed via the return
 value.}

---FILE: man/view_df.Rd---
@@ -23,9 +23,9 @@ view_df(x, file = NULL, alternateRowColors = TRUE, showID = TRUE,
 or any similar labelled data frame (see \code{\link[sjmisc]{set_var_labels}}
 and \code{\link[sjmisc]{set_val_labels}}).}
 
-\item{file}{The destination file, which will be in html-format. If no filepath is specified,
-the file will be saved as temporary file and openend either in the IDE's viewer pane or
-in the default web browser.}
+\item{file}{destination file, if the output should be saved as file.
+If \code{NULL} (default), the output will be saved as temporary file and
+openend either in the IDE's viewer pane or the default web browser.}
 
 \item{alternateRowColors}{logical, if \code{TRUE}, alternating rows are highlighted with a light gray
 background color.}
@@ -52,20 +52,21 @@ order in the data frame.}
 a variable name are displayed in one line and when a line break is inserted.
 Default value is 50, use \code{NULL} to turn off word wrap.}
 
-\item{encoding}{The charset encoding used for variable and value labels. Default is \code{NULL}, so encoding
-will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
-Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
+\item{encoding}{string, indicating the charset encoding used for variable and
+value labels. Default is \code{NULL}, so encoding will be auto-detected
+depending on your platform (e.g., \code{""UTF-8""} for Unix and \code{""Windows-1252""} for
+Windows OS). Change encoding if specific chars are not properly displayed (e.g. German umlauts).}
 
 \item{hideProgressBar}{If \code{TRUE}, the progress bar that is displayed when creating the
-table is hidden. Default in \code{FALSE}, hence the bar is visible.}
+         table is hidden. Default in \code{FALSE}, hence the bar is visible.}
 
-\item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
+\item{CSS}{\code{\link{list}}-object with user-defined style-sheet-definitions, according to the
 \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
 
-\item{no.output}{If \code{TRUE}, the html-output is neither opened in a browser nor shown in
+\item{no.output}{logical, if \code{TRUE}, the html-output is neither opened in a browser nor shown in
 the viewer pane and not even saved to file. This option is useful when the html output
 should be used in \code{knitr} documents. The html output can be accessed via the return
 value.}"
strengejacke,sjPlot,5d8d8a7119263f47c719c350563b8531f12e67e0,Daniel Ldecke,d.luedecke@uke.de,2015-06-25T18:34:01Z,Daniel Ldecke,d.luedecke@uke.de,2015-06-25T18:34:01Z,fixed confint-mermod-issue,R/sjPlotGLME.R,False,True,True,False,1,3,4,"---FILE: R/sjPlotGLME.R---
@@ -2146,9 +2146,7 @@ get_cleaned_ciMerMod <- function(fit, ci.only = FALSE) {
   # get odds ratios of fixed effects
   OR <- lme4::fixef(fit)
   # get condifence intervals, cleaned (variance CI removed via NA)
-  CI <- na.omit(lme4::confint.merMod(fit, method = ""Wald""))
-  # check if no of CI match no of terms
-  if (length(OR) < nrow(CI)) CI <- CI[-seq_len(nrow(CI) - length(OR)), ]
+  CI <- lme4::confint.merMod(fit, method = ""Wald"", parm = ""beta_"")
   # create data frame
   mydf <- data.frame(exp(cbind(OR, CI)))
   # only return ci?"
strengejacke,sjPlot,920685c885822adce427af4c73afc55662980a97,Daniel Ldecke,d.luedecke@uke.de,2015-06-25T05:41:21Z,Daniel Ldecke,d.luedecke@uke.de,2015-06-25T05:41:21Z,fixed NA-issue with confint.merMod,NEWS;R/sjPlotGLME.R;R/sjPlotLinreg.R;R/sjPlotOdds.R;R/sjTabLinReg.R;R/sjTabOdds.R;README.md,False,True,True,False,15,13,28,"---FILE: NEWS---
@@ -1,6 +1,7 @@
 Version 1.8.1-7
 ------------------------------------------------------------------------------
 General:
+* Package documentation got major revisions.
 * ""view_spss"" is now deprecated. Use ""view_df"" instead.
 
 New functions:
@@ -9,7 +10,7 @@ New functions:
 Changes to functions:
 * Model and table summaries in plotting functions (like ""sjp.lm"" or ""sjp.grpfrq"") are no longer printed by default. Use ""showTableSummary = TRUE"" or ""showModelSummary = TRUE"" to print summaries in plots.
 * Added more plotting type options (see ""type"" parameter) to ""sjp.glm"", ""sjp.glmer"", ""sjp.lm"" and ""sjp.lmer"": ""eff"" for plotting marginal effects of model terms, and ""poly"" to plot predicted values of polynomial terms (only for linear (mixed) models).
-* Added parameter ""int.term"" to ""sjp.int"", to plot selected interaction terms for ""type = 'eff'"" only. May be used in cases where effect computation takes too long or even crashes due to out-of-memory-problems.
+* Added parameter ""int.term"" to ""sjp.int"", to plot selected interaction terms for ""type = 'eff'"". May be used in cases where effect computation takes too long or even crashes due to out-of-memory-problems.
 * Added parameter ""axisLimits.x"" to ""sjp.int"", ""sjp.frq"" and ""sjp.grpfrq"".
 * Added parameter ""showAICc"" to ""sjt.lm"", ""sjt.glm"", ""sjt.lmer"" and ""sjt.glmer"" to print second-order AIC.
 * Improved automatic y-axis-limit detection in ""sjp.frq"" and ""sjp.grpfrq"".

---FILE: R/sjPlotGLME.R---
@@ -971,7 +971,7 @@ sjp.lme4  <- function(fit,
           warning(""'type = fe.std' only works for linear models."", call. = F)
         }
         mydf <- data.frame(exp(cbind(OR = lme4::fixef(fit),
-                                     lme4::confint.merMod(fit, method = ""Wald""))))
+                                     na.omit(lme4::confint.merMod(fit, method = ""Wald"")))))
       } else {
         if (type == ""fe.std"") {
           tmpdf <- sjmisc::std_beta(fit)
@@ -982,7 +982,7 @@ sjp.lme4  <- function(fit,
           rownames(mydf) <- names(lme4::fixef(fit))
         } else {
           mydf <- data.frame(OR = lme4::fixef(fit),
-                             lme4::confint.merMod(fit, method = ""Wald""))
+                             na.omit(lme4::confint.merMod(fit, method = ""Wald"")))
         }
       }
       # ----------------------------
@@ -1246,7 +1246,7 @@ sjp.lme.feprobcurv <- function(fit,
                                geom.size,
                                printPlot) {
   # check size parameter
-  if (is.null(geom.size)) geom.size <- .8
+  if (is.null(geom.size)) geom.size <- .7
   # ----------------------------
   # prepare additional plots, when metric
   # predictors should also be plotted
@@ -1628,7 +1628,7 @@ sjp.lme.feri <- function(fit,
                          geom.size,
                          printPlot) {
   # check size parameter
-  if (is.null(geom.size)) geom.size <- .8
+  if (is.null(geom.size)) geom.size <- .7
   # ----------------------------
   # retrieve term names, so we find the estimates in the
   # coefficients list
@@ -2119,7 +2119,7 @@ sjp.glm.eff <- function(fit,
   # ------------------------
   grp.cnt <- length(unique(mydat$grp))
   # check size parameter
-  if (is.null(geom.size)) geom.size <- .8
+  if (is.null(geom.size)) geom.size <- .7
   # ------------------------
   # create plot
   # ------------------------

---FILE: R/sjPlotLinreg.R---
@@ -1059,7 +1059,7 @@ sjp.lm.poly <- function(fit,
                         showCI, 
                         printPlot) {
   # check size parameter
-  if (is.null(geom.size)) geom.size <- .8
+  if (is.null(geom.size)) geom.size <- .7
   # -------------------------------------
   # retrieve model matrix
   # -------------------------------------
@@ -1224,7 +1224,7 @@ sjp.lm.eff <- function(fit,
   # ------------------------
   grp.cnt <- length(unique(mydat$grp))
   # check size parameter
-  if (is.null(geom.size)) geom.size <- .8
+  if (is.null(geom.size)) geom.size <- .7
   # ------------------------
   # create plot
   # ------------------------

---FILE: R/sjPlotOdds.R---
@@ -589,7 +589,7 @@ sjp.glm.pc <- function(fit,
                        facet.grid,
                        printPlot) {
   # check size parameter
-  if (is.null(geom.size)) geom.size <- .8
+  if (is.null(geom.size)) geom.size <- .7
   # ----------------------------
   # prepare additional plots, when metric
   # predictors should also be plotted
@@ -740,7 +740,7 @@ sjp.glm.response.probcurv <- function(fit,
                                       geom.size,
                                       printPlot) {
   # check size parameter
-  if (is.null(geom.size)) geom.size <- .8
+  if (is.null(geom.size)) geom.size <- .7
   # ----------------------------
   # get predicted values for response
   # ----------------------------

---FILE: R/sjTabLinReg.R---
@@ -617,7 +617,7 @@ sjt.lm <- function(...,
     # retrieve ci for model
     # -------------------------------------
     if (lmerob) {
-      confis <- lme4::confint.merMod(fit, method = ""Wald"")
+      confis <- na.omit(lme4::confint.merMod(fit, method = ""Wald""))
       sbmer <- suppressWarnings(sjmisc::std_beta(fit)[-1, ])
       sbvals <- data.frame(beta = sbmer[, 1], 
                            ci.low = sbmer[, 1] - 1.96 * sbmer[, 2],

---FILE: R/sjTabOdds.R---
@@ -515,7 +515,7 @@ sjt.glm <- function(...,
     # retrieve ci for model
     # -------------------------------------
     if (lmerob) {
-      confis <- lme4::confint.merMod(fit, method = ""Wald"")
+      confis <- na.omit(lme4::confint.merMod(fit, method = ""Wald""))
       coef.fit <- lme4::fixef(fit)
     } else {
       confis <- confint(fit)

---FILE: README.md---
@@ -43,6 +43,7 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 ### Changelog of development build 1.8.1-7
 
 #### General
+* Package documentation got major revisions.
 * `view_spss` is now deprecated. Use `view_df` instead.
 
 #### New functions
@@ -51,7 +52,7 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 #### Changes to functions
 * Model and table summaries in plotting functions (like `sjp.lm` or `sjp.grpfrq`) are no longer printed by default. Use `showTableSummary = TRUE` or `showModelSummary = TRUE` to print summaries in plots.
 * Added more plotting type options (see `type` parameter) to `sjp.glm`, `sjp.glmer`, `sjp.lm` and `sjp.lmer`: `eff` for plotting marginal effects of model terms, and `poly` to plot predicted values of polynomial terms (only for linear (mixed) models).
-* Added parameter `int.term` to `sjp.int`, to plot selected interaction terms for `type = ""eff""` only. May be used in cases where effect computation takes too long or even crashes due to out-of-memory-problems.
+* Added parameter `int.term` to `sjp.int`, to plot selected interaction terms for `type = ""eff""`. May be used in cases where effect computation takes too long or even crashes due to out-of-memory-problems.
 * Added parameter `axisLimits.x` to `sjp.int`, `sjp.frq` and `sjp.grpfrq`.
 * Added parameter `showAICc` to `sjt.lm`, `sjt.glm`, `sjt.lme` and `sjt.glmer` to print second-order AIC.
 * Improved automatic y-axis-limit detection in `sjp.frq` and `sjp.grpfrq`."
strengejacke,sjPlot,53aaba2b5153052db7e08c728a5d8312891ffa6d,Daniel Ldecke,d.luedecke@uke.de,2015-06-19T07:50:02Z,Daniel Ldecke,d.luedecke@uke.de,2015-06-19T07:50:02Z,fixed non-canonical URLs,DESCRIPTION;NEWS;R/sjPlotClusterAnalysis.R;README.md;man/sjPlot-package.Rd;man/sjc.kgap.Rd;man/sjp.glm.Rd,False,True,True,False,14,12,26,"---FILE: DESCRIPTION---
@@ -2,7 +2,7 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.8.1-6
+Version: 1.8.1-7
 Date: 2015-06-18
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>

---FILE: NEWS---
@@ -1,4 +1,4 @@
-Version 1.8.1-6
+Version 1.8.1-7
 ------------------------------------------------------------------------------
 General:
 * ""view_spss"" is now deprecated. Use ""view_df"" instead.

---FILE: R/sjPlotClusterAnalysis.R---
@@ -778,7 +778,7 @@ sjc.elbow <- function(data, steps=15, showDiff=FALSE) {
 #' @description An implementation of the gap statistic algorithm from Tibshirani, Walther, and Hastie's
 #'                ""Estimating the number of clusters in a data set via the gap statistic"".
 #'                This function calls the \code{clusGap} function of the
-#'                \href{http://cran.r-project.org/web/packages/cluster/index.html}{cluster-package}
+#'                \href{http://cran.r-project.org/package=cluster}{cluster-package}
 #'                to calculate the data for the plot.
 #'                
 #' @seealso \code{\link{sjc.elbow}}
@@ -810,7 +810,7 @@ sjc.elbow <- function(data, steps=15, showDiff=FALSE) {
 #' 
 #' @references \itemize{
 #'              \item Tibshirani R, Walther G, Hastie T (2001) Estimating the number of clusters in a data set via gap statistic. J. R. Statist. Soc. B, 63, Part 2, pp. 411-423
-#'              \item Maechler, M., Rousseeuw, P., Struyf, A., Hubert, M., Hornik, K.(2013). cluster: Cluster Analysis Basics and Extensions. R package version 1.14.4. (\href{http://cran.r-project.org/web/packages/cluster/index.html}{web})
+#'              \item Maechler, M., Rousseeuw, P., Struyf, A., Hubert, M., Hornik, K.(2013). cluster: Cluster Analysis Basics and Extensions. R package version 1.14.4. (\href{http://cran.r-project.org/package=cluster}{web})
 #'             }
 #' 
 #' @examples

---FILE: README.md---
@@ -21,7 +21,7 @@ devtools::install_github(""sjPlot/sjmisc"")
 ```
 
 #### Officiale, stable release
-[![CRAN_Status_Badge](http://www.r-pkg.org/badges/version/sjPlot)](http://cran.r-project.org/web/packages/sjPlot) 
+[![CRAN_Status_Badge](http://www.r-pkg.org/badges/version/sjPlot)](http://cran.r-project.org/package=sjPlot) 
 &#160;&#160;
 [![downloads](http://cranlogs.r-pkg.org/badges/sjPlot)](http://cranlogs.r-pkg.org/)
 
@@ -38,9 +38,9 @@ install.packages(""sjPlot"")
 
 ### Citation
 
-In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since core functionality of package depends on the [ggplot-package](http://cran.r-project.org/web/packages/ggplot2/index.html), consider citing this package as well.
+In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since core functionality of package depends on the [ggplot-package](http://cran.r-project.org/package=ggplot2), consider citing this package as well.
 
-### Changelog of development build 1.8.1-6
+### Changelog of development build 1.8.1-7
 
 #### General
 * `view_spss` is now deprecated. Use `view_df` instead.

---FILE: man/sjPlot-package.Rd---
@@ -34,7 +34,7 @@
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.8.1-6\cr
+Version: \tab 1.8.1-7\cr
 Date: \tab 2015-06-18\cr
 License: \tab GPL-3\cr
 }

---FILE: man/sjc.kgap.Rd---
@@ -43,7 +43,7 @@ An object containing the used data frame for plotting, the ggplot object
 An implementation of the gap statistic algorithm from Tibshirani, Walther, and Hastie's
                ""Estimating the number of clusters in a data set via the gap statistic"".
                This function calls the \code{clusGap} function of the
-               \href{http://cran.r-project.org/web/packages/cluster/index.html}{cluster-package}
+               \href{http://cran.r-project.org/package=cluster}{cluster-package}
                to calculate the data for the plot.
 }
 \examples{
@@ -58,7 +58,7 @@ sjc.kgap(iris[,1:4])}
 \references{
 \itemize{
              \item Tibshirani R, Walther G, Hastie T (2001) Estimating the number of clusters in a data set via gap statistic. J. R. Statist. Soc. B, 63, Part 2, pp. 411-423
-             \item Maechler, M., Rousseeuw, P., Struyf, A., Hubert, M., Hornik, K.(2013). cluster: Cluster Analysis Basics and Extensions. R package version 1.14.4. (\href{http://cran.r-project.org/web/packages/cluster/index.html}{web})
+             \item Maechler, M., Rousseeuw, P., Struyf, A., Hubert, M., Hornik, K.(2013). cluster: Cluster Analysis Basics and Extensions. R package version 1.14.4. (\href{http://cran.r-project.org/package=cluster}{web})
             }
 }
 \seealso{

---FILE: man/sjp.glm.Rd---
@@ -7,7 +7,7 @@
 sjp.glm(fit, type = ""dots"", sortOdds = TRUE, title = NULL,
   axisLabels.y = NULL, axisTitle.x = ""Odds Ratios"", axisLimits = NULL,
   breakTitleAt = 50, breakLabelsAt = 25, gridBreaksAt = 0.5,
-  transformTicks = TRUE, geom.size = 3, geom.colors = ""Set1"",
+  transformTicks = TRUE, geom.size = NULL, geom.colors = ""Set1"",
   hideErrorBars = FALSE, interceptLineType = 2,
   interceptLineColor = ""grey70"", coord.flip = TRUE, showIntercept = FALSE,
   showAxisLabels.y = TRUE, showValueLabels = TRUE, labelDigits = 2,
@@ -59,7 +59,9 @@ visually have the same distance from one panel grid to the next. If \code{FALSE}
 plotted on every \code{gridBreaksAt}'s position, thus the grid bars become narrower with
 higher odds ratio values.}
 
-\item{geom.size}{size resp. width of the geoms (bar width or point size, depending on \code{type} parameter).}
+\item{geom.size}{size resp. width of the geoms (bar width, point size, or line thickness,
+depending on \code{type} parameter). By default, \code{geom.size = NULL},
+which means that this parameter is automatically adjusted depending on the plot type.}
 
 \item{geom.colors}{User defined color palette for geoms. Must either be vector with two color values
 or a specific color palette code (see below)."
strengejacke,sjPlot,e73d4f8667d7cbe95bfa5ca28611f6f040362206,Daniel Ldecke,d.luedecke@uke.de,2015-06-11T17:55:45Z,Daniel Ldecke,d.luedecke@uke.de,2015-06-11T17:55:45Z,fix bug with color-brewer-palette-detection,R/helpfunctions.R;man/sjp.lmer.Rd,False,True,True,False,5,5,10,"---FILE: R/helpfunctions.R---
@@ -270,12 +270,12 @@ is.brewer.pal <- function(pal) {
   bp.seq <- c(""BuGn"", ""BuPu"", ""GnBu"", ""OrRd"", ""PuBu"", ""PuBuGn"", ""PuRd"", ""RdPu"",
               ""YlGn"", ""YlGnBu"", ""YlOrBr"", ""YlOrRd"", ""Blues"", ""Greens"", ""Greys"",
               ""Oranges"", ""Purples"", ""Reds"")
-  bp.div <- c(""BrBG"", ""PiYg"", ""PRGn"", ""PuOr"", ""RdBu"", ""RdGy"", ""RdYlBu"",
+  bp.div <- c(""BrBG"", ""PiYG"", ""PRGn"", ""PuOr"", ""RdBu"", ""RdGy"", ""RdYlBu"",
               ""RdYlGn"", ""Spectral"")
   bp.qul <- c(""Accent"", ""Dark2"", ""Paired"", ""Pastel1"", ""Pastel2"", ""Set1"",
               ""Set2"", ""Set3"")
   bp <- c(bp.seq, bp.div, bp.qul)
-  return (any(bp == pal))
+  return(any(bp == pal))
 }
 
 
@@ -299,7 +299,7 @@ crosstabsum <- function(ftab) {
   # the contingency coefficient
   if (nrow(ftab) > 2 || ncol(ftab) > 2) {
     # if minimum expected values below 5, compute fisher's exact test
-    if(min(tab$expected) < 5 || (min(tab$expected) < 10 && chsq$parameter == 1)) fish <- fisher.test(ftab, simulate.p.value = TRUE)
+    if (min(tab$expected) < 5 || (min(tab$expected) < 10 && chsq$parameter == 1)) fish <- fisher.test(ftab, simulate.p.value = TRUE)
     # check whether fisher's test or chi-squared should be printed
     if (is.null(fish)) {
       if (chsq$p.value < 0.001) {
@@ -340,7 +340,7 @@ crosstabsum <- function(ftab) {
   # the degree of association
   } else {
     # if minimum expected values below 5, compute fisher's exact test
-    if(min(tab$expected) < 5 || (min(tab$expected) < 10 && chsq$parameter == 1)) fish <- fisher.test(ftab)
+    if (min(tab$expected) < 5 || (min(tab$expected) < 10 && chsq$parameter == 1)) fish <- fisher.test(ftab)
     # check whether fisher's test or chi-squared should be printed
     if (is.null(fish)) {
       modsum <- as.character(as.expression(

---FILE: man/sjp.lmer.Rd---
@@ -11,7 +11,7 @@ sjp.lmer(fit, type = ""re"", vars = NULL, ri.nr = NULL, emph.grp = NULL,
   axisTitle.x = NULL, axisTitle.y = NULL, interceptLineType = 2,
   interceptLineColor = ""grey70"", showValueLabels = TRUE, labelDigits = 2,
   showPValueLabels = TRUE, facet.grid = TRUE, free.scale = FALSE,
-  fade.ns = FALSE, show.se = TRUE, printPlot = TRUE, ...)
+  fade.ns = FALSE, show.se = TRUE, printPlot = TRUE)
 }
 \arguments{
 \item{fit}{a fitted \code{lmer} object.}"
strengejacke,sjPlot,c70c967ad5663e789141380f6b163c821cfaa79a,Daniel Ldecke,d.luedecke@uke.de,2015-06-09T18:14:30Z,Daniel Ldecke,d.luedecke@uke.de,2015-06-09T18:14:30Z,bug fixes and improvements to sjp.likert,DESCRIPTION;NEWS;R/sjPlotLikert.R;R/sjPlotSetTheme.R;README.md;man/sjPlot-package.Rd;man/sjp.chi2.Rd;man/sjp.likert.Rd;man/sjp.setTheme.Rd,False,True,True,False,60,34,94,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.8.1-3
-Date: 2015-06-04
+Version: 1.8.1-4
+Date: 2015-06-09
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of several plotting and table output functions for visualizing data.

---FILE: NEWS---
@@ -1,9 +1,10 @@
-Version 1.8.1-3
+Version 1.8.1-4
 ------------------------------------------------------------------------------
 Changes to functions:
 * Model and table summaries in plotting functions (like ""sjp.lm"" or ""sjp.grpfrq"") are no longer printed by default. Use ""showTableSummary = TRUE"" or ""showModelSummary = TRUE"" to print summaries in plots.
 * Added parameter ""int.term"" to ""sjp.int"", to plot selected interaction terms for ""type = 'eff'"" only. May be used in cases where effect computation takes too long or even crashes due to out-of-memory-problems.
 * Added parameter ""axisLimits.x"" to ""sjp.int"", ""sjp.frq"" and ""sjp.grpfrq"".
+* Minor improvement to ""sjp.likert"".
 
 Bug fixes:
 * ""sjp.int"" sometimes crashed with mixed models, due to slow Kenward-Roger-computation of standard errors, provided by the ""effects""-package. Fixed, ""KR""-parameter, when calling ""allEffects"", now defaults to ""FALSE"".

---FILE: R/sjPlotLikert.R---
@@ -10,7 +10,13 @@
 #' 
 #' @note Note that only even numbers of categories are possible to plot, so the ""positive"" 
 #'        and ""negative"" values can be splitted into two halfs. A neutral category (like ""don't know"")
-#'        can be used, but must be indicated by \code{cat.neutral}.
+#'        can be used, but must be indicated by \code{cat.neutral}. \cr \cr
+#'        The \code{catcount}-parameter indicates how many item categories are in the
+#'        Likert scale. Normally, this parameter can be ignored because the amount of 
+#'        valid categories is retrieved automatically. However, sometimes (for instance,
+#'        if a certain category is missing in all items), auto-detection of the amount
+#'        of categories fails. In such cases, specify the amount of categories
+#'        with the \code{catcount}-parameter.
 #' 
 #' @param items A data frame with each column representing one likert-item.
 #' @param catcount optional, the amount of categories of the items (e.g. \emph{""strongly disagree"", 
@@ -19,9 +25,7 @@
 #'          have an additional neutral category (see \code{cat.neutral}) like \emph{""don't know""},
 #'          this won't count for \code{catcount} (e.g. ""strongly disagree"", 
 #'          ""disagree"", ""agree"", ""strongly agree"" and neutral category ""don't know""
-#'          would still mean that \code{catcount=4}). \cr
-#'          \strong{Note:} Normally, this parameter can be ignored because the amount of valid categories
-#'          is retrieved automatically.
+#'          would still mean that \code{catcount=4}). See 'Note'.
 #' @param cat.neutral If there's a neutral category (like ""don't know"" etc.), specify
 #'          the index number for this category. Else, set \code{cat.neutral=NULL} (default).
 #'          The frequencies of neutral categories are plotted as grey bars on the left side of
@@ -282,10 +286,17 @@ sjp.likert <- function(items,
       # finally contains all unique values of items
       catcount <- unique(c(catcount, unique(na.omit(items[, i]))))
     }
-    # length of catcount
-    catcount <- length(catcount)
-    # if catcount odd or even? make catcount even
-    if ((catcount %% 2) == 1) catcount <- catcount - 1
+    # remove neutral category
+    if (!is.null(cat.neutral)) catcount <- catcount[-which(catcount == cat.neutral)]
+    # detect range of valid categories, which
+    # then equals catcount
+    catcount <- max(catcount) - min(catcount) + 1
+    # is catcount odd or even? make catcount even
+    if (sjmisc::is_odd(catcount)) {
+      # warn user about uneven category count
+      warning(""Detected uneven category count in items. Dropping last category."", call. = F)
+      catcount <- catcount - 1
+    }
   }
   # --------------------------------------------------------
   # set legend labels, if we have none yet
@@ -353,8 +364,17 @@ sjp.likert <- function(items,
     # --------------------------------------------------------
     if (ncol(freq.df) == 0) 
       freq.df <- as.data.frame(freq)
-    else
-      freq.df <- as.data.frame(cbind(freq.df, freq))
+    else {
+      # check for valid rows. if we hav missing categories
+      # in all items, parameter ""catcount"" must be set, because
+      # automatic detection of amount of categories does not
+      # work then.
+      if (length(freq) != nrow(freq.df))
+        stop(""Could not determine amount of item categories. Please use parameter 'catcount'."", call. = F)
+      else
+        freq.df <- as.data.frame(cbind(freq.df, freq))
+    }
+      
   }
   # --------------------------------------------------------
   # Check whether N of each item should be included into
@@ -512,7 +532,7 @@ sjp.likert <- function(items,
   # Set up grid breaks
   # --------------------------------------------------------
   gridbreaks <- round(c(seq(-gridRange, gridRange, by = gridBreaksAt)), 2)
-  gridlabs <- ifelse (abs(gridbreaks) > 1, """", paste0(c(abs(round(100 * gridbreaks))), ""%""))
+  gridlabs <- ifelse(abs(gridbreaks) > 1, """", paste0(c(abs(round(100 * gridbreaks))), ""%""))
   # --------------------------------------------------------
   # start plot here
   # --------------------------------------------------------
@@ -548,15 +568,15 @@ sjp.likert <- function(items,
   # --------------------------------------------------------
   # should percentage value labels be printed?
   # --------------------------------------------------------
-  percsign <- mydat.pos$percsign <- mydat.neg$percsign <- ifelse (showPercentageSign == TRUE, ""%"", """")
+  percsign <- mydat.pos$percsign <- mydat.neg$percsign <- ifelse(showPercentageSign == TRUE, ""%"", """")
   if (nrow(mydat.dk) > 0) mydat.dk$percsign <- percsign
   # --------------------------------------------------------
   # creating value labels for cumulative percentages, so
   # zero-percentages are not printed
   # --------------------------------------------------------
-  ypos.sum.pos.lab  <- ifelse (ypos.sum.pos > 0, sprintf(""%.*f%s"", labelDigits, 100 * ypos.sum.pos, percsign), """")
-  ypos.sum.neg.lab  <- ifelse (ypos.sum.neg < 0, sprintf(""%.*f%s"", labelDigits, 100 * abs(ypos.sum.neg), percsign), """")
-  ypos.sum.dk.lab  <- ifelse (ypos.sum.dk > -1, sprintf(""%.*f%s"", labelDigits, 100 * (1 + ypos.sum.dk), percsign), """")
+  ypos.sum.pos.lab  <- ifelse(ypos.sum.pos > 0, sprintf(""%.*f%s"", labelDigits, 100 * ypos.sum.pos, percsign), """")
+  ypos.sum.neg.lab  <- ifelse(ypos.sum.neg < 0, sprintf(""%.*f%s"", labelDigits, 100 * abs(ypos.sum.neg), percsign), """")
+  ypos.sum.dk.lab  <- ifelse(ypos.sum.dk > -1, sprintf(""%.*f%s"", labelDigits, 100 * (1 + ypos.sum.dk), percsign), """")
   
   if (value.labels == ""show"") {
     # show them in middle of bar
@@ -586,7 +606,7 @@ sjp.likert <- function(items,
       annotate(""text"", x = xpos.sum.neg, y = ypos.sum.neg, hjust = hort.neg, label = ypos.sum.neg.lab)
     if (!is.null(cat.neutral)) {
       gp <- gp +
-        annotate(""text"", x = xpos.sum.dk, y = ypos.sum.dk + 1 -gridRange, hjust = hort.dk, label = ypos.sum.dk.lab)
+        annotate(""text"", x = xpos.sum.dk, y = ypos.sum.dk + 1 - gridRange, hjust = hort.dk, label = ypos.sum.dk.lab)
     }
   }
   # ---------------------------------------------------------
@@ -622,9 +642,9 @@ sjp.likert <- function(items,
   # -------------------------------------
   # return results
   # -------------------------------------
-  invisible (structure(class = ""sjplikert"",
-                       list(plot = gp,
-                            df.neg = mydat.neg,
-                            df.pos = mydat.pos,
-                            df.neutral = mydat.dk)))
+  invisible(structure(class = ""sjplikert"",
+                      list(plot = gp,
+                           df.neg = mydat.neg,
+                           df.pos = mydat.pos,
+                           df.neutral = mydat.dk)))
 }

---FILE: R/sjPlotSetTheme.R---
@@ -86,7 +86,7 @@
 #' @param legend.backgroundcol Fill color of the legend's background. Default is \code{""white""}, so no visible background is drawn.
 #' @param legend.item.bordercol Color of the legend's item-border. Default is \code{""white""}.
 #' @param legend.item.backcol Fill color of the legend's item-background. Default is \code{""grey90""}.
-#' @param theme Specify pre-set themes (see 'Details'). Valid parameter for ggplot default-themes are:
+#' @param theme Specify pre-set themes (see 'Details'). Valid parameter for ggplot default-themes are for instance:
 #'        \itemize{
 #'          \item \code{theme_bw}
 #'          \item \code{theme_classic}

---FILE: README.md---
@@ -34,12 +34,13 @@ install.packages(""sjPlot"")
 
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since this package makes heavy use of the [ggplot-package](http://cran.r-project.org/web/packages/ggplot2/index.html), consider citing this package as well.
 
-### Changelog of development build 1.8.1-3
+### Changelog of development build 1.8.1-4
 
 #### Changes to functions:
 * Model and table summaries in plotting functions (like `sjp.lm` or `sjp.grpfrq`) are no longer printed by default. Use `showTableSummary = TRUE` or `showModelSummary = TRUE` to print summaries in plots.
 * Added parameter `int.term` to `sjp.int`, to plot selected interaction terms for `type = ""eff""` only. May be used in cases where effect computation takes too long or even crashes due to out-of-memory-problems.
 * Added parameter `axisLimits.x` to `sjp.int`, `sjp.frq` and `sjp.grpfrq`.
+* Minor improvement to `sjp.likert`.
 
 #### Bug fixes
 * `sjp.int` sometimes crashed with mixed models, due to slow Kenward-Roger-computation of standard errors, provided by the `effects`-package. Fixed, `KR`-parameter, when calling `allEffects`, now defaults to `FALSE`.

---FILE: man/sjPlot-package.Rd---
@@ -34,8 +34,8 @@
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.8.1-3\cr
-Date: \tab 2015-06-04\cr
+Version: \tab 1.8.1-4\cr
+Date: \tab 2015-06-09\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjp.chi2.Rd---
@@ -37,7 +37,7 @@ want to plot any graphs. In either case, the ggplot-object will be returned as v
           was used for setting up the ggplot-object (\code{mydf}).
 }
 \description{
-Plot Pearson's Chi2-Test of multiple contingency tables as ellipses or tiles.
+Plot p-values of Pearson's Chi2-tests for multiple contingency tables as ellipses or tiles.
                Requires a data frame with dichotomous (dummy) variables.
                Calculation of Chi2-matrix taken from
                \href{http://talesofr.wordpress.com/2013/05/05/ridiculously-photogenic-factors-heatmap-with-p-values/}{Tales of R}.

---FILE: man/sjp.likert.Rd---
@@ -25,9 +25,7 @@ Note that this parameter only applies to ""valid"" answers, i.e. if you
 have an additional neutral category (see \code{cat.neutral}) like \emph{""don't know""},
 this won't count for \code{catcount} (e.g. ""strongly disagree"",
 ""disagree"", ""agree"", ""strongly agree"" and neutral category ""don't know""
-would still mean that \code{catcount=4}). \cr
-\strong{Note:} Normally, this parameter can be ignored because the amount of valid categories
-is retrieved automatically.}
+would still mean that \code{catcount=4}). See 'Note'.}
 
 \item{cat.neutral}{If there's a neutral category (like ""don't know"" etc.), specify
 the index number for this category. Else, set \code{cat.neutral=NULL} (default).
@@ -146,7 +144,13 @@ Plot likert scales as centered stacked bars.
 \note{
 Note that only even numbers of categories are possible to plot, so the ""positive""
        and ""negative"" values can be splitted into two halfs. A neutral category (like ""don't know"")
-       can be used, but must be indicated by \code{cat.neutral}.
+       can be used, but must be indicated by \code{cat.neutral}. \cr \cr
+       The \code{catcount}-parameter indicates how many item categories are in the
+       Likert scale. Normally, this parameter can be ignored because the amount of
+       valid categories is retrieved automatically. However, sometimes (for instance,
+       if a certain category is missing in all items), auto-detection of the amount
+       of categories fails. In such cases, specify the amount of categories
+       with the \code{catcount}-parameter.
 }
 \examples{
 # prepare data for dichotomous likert scale, 5 items

---FILE: man/sjp.setTheme.Rd---
@@ -169,7 +169,7 @@ legend justification is set according to legend position.}
 
 \item{legend.item.bordercol}{Color of the legend's item-border. Default is \code{""white""}.}
 
-\item{theme}{Specify pre-set themes (see 'Details'). Valid parameter for ggplot default-themes are:
+\item{theme}{Specify pre-set themes (see 'Details'). Valid parameter for ggplot default-themes are for instance:
 \itemize{
   \item \code{theme_bw}
   \item \code{theme_classic}"
strengejacke,sjPlot,bb23b91f6ef1f87515bb2462567e5b3614efe593,Daniel Ldecke,d.luedecke@uke.de,2015-06-06T12:35:22Z,Daniel Ldecke,d.luedecke@uke.de,2015-06-06T12:35:22Z,bug fixes,R/sjPlotFrequencies.R;R/sjTabFrequencies.R;man/sjp.chi2.Rd,False,True,True,False,10,3,13,"---FILE: R/sjPlotFrequencies.R---
@@ -358,6 +358,11 @@ sjp.frq <- function(varCount,
                                   groupsize = ""auto"", 
                                   asNumeric = TRUE, 
                                   autoGroupCount = agcnt)
+    # set label attributes
+    varCount <- sjmisc::set_val_labels(varCount, axisLabels.x)
+    # save label values. needed later to determine correct
+    # amount of categories
+    labelvalues <- sjmisc::get_values(varCount)
   }
   # --------------------------------------------------------
   # unlist labels

---FILE: R/sjTabFrequencies.R---
@@ -478,7 +478,7 @@ sjt.frq <- function(data,
       orivar <- var <- as.numeric(as.factor(data[[cnt]]))
     # here we have numeric or factor variables
     } else {
-      orivar <- var <- as.numeric(data[[cnt]])
+      orivar <- var <- sjmisc::to_value(data[[cnt]])
     }
     # -----------------------------------------------
     # check for length of unique values and skip if too long
@@ -498,6 +498,8 @@ sjt.frq <- function(data,
                                groupsize = ""auto"", 
                                asNumeric = TRUE, 
                                autoGroupCount = agcnt)
+      # set labels
+      var <- sjmisc::set_val_labels(var, valueLabels[[cnt]])
     }
     # retrieve summary
     varsummary <- summary(var)
@@ -511,7 +513,7 @@ sjt.frq <- function(data,
     #---------------------------------------------------
     df.frq <- create.frq.df(var, 
                             valueLabels[[cnt]], 
-                            sjmisc::get_values(data[[cnt]]),
+                            sjmisc::get_values(var),
                             -1, 
                             sort.frq, 
                             weightBy = weightBy)

---FILE: man/sjp.chi2.Rd---
@@ -37,7 +37,7 @@ want to plot any graphs. In either case, the ggplot-object will be returned as v
           was used for setting up the ggplot-object (\code{mydf}).
 }
 \description{
-Plot p-values of Pearson's Chi2-tests for multiple contingency tables as ellipses or tiles.
+Plot Pearson's Chi2-Test of multiple contingency tables as ellipses or tiles.
                Requires a data frame with dichotomous (dummy) variables.
                Calculation of Chi2-matrix taken from
                \href{http://talesofr.wordpress.com/2013/05/05/ridiculously-photogenic-factors-heatmap-with-p-values/}{Tales of R}."
strengejacke,sjPlot,539e1e0eea1a79731937dbb9c78ebb6d1ad73512,Daniel Ldecke,d.luedecke@uke.de,2015-06-04T06:31:03Z,Daniel Ldecke,d.luedecke@uke.de,2015-06-04T06:31:03Z,minor fixes,R/helpfunctions.R;R/sjPlotFrequencies.R;R/sjTabFrequencies.R,False,True,True,False,22,21,43,"---FILE: R/helpfunctions.R---
@@ -72,7 +72,7 @@ out.html.table <- function(no.output, file, knitr, toWrite, useViewer) {
 # Create frequency data frame of a variable
 # for sjp and sjt frq functions
 create.frq.df <- function(varCount,
-                          labels,
+                          llabels,
                           labelvalues,
                           breakLabelsAt,
                           order.frq = ""none"",
@@ -111,12 +111,12 @@ create.frq.df <- function(varCount,
     # define minimum value
     catmin <- minval <- min(varCount, na.rm = TRUE)
     # wrap labels
-    if (!is.null(labels)) {
-      labels <- sjmisc::word_wrap(labels, breakLabelsAt)
+    if (!is.null(llabels)) {
+      llabels <- sjmisc::word_wrap(llabels, breakLabelsAt)
     } else {
       # If axisLabels.x were not defined, simply set numbers from 1 to
       # amount of categories (=number of rows) in dataframe instead
-      labels <- as.character(mydat$var)
+      llabels <- as.character(mydat$var)
     }
   } else {
     # --------------------------------------------------------
@@ -147,14 +147,14 @@ create.frq.df <- function(varCount,
     if (min(df$y) == 0 && startAxisAt > 0) df$y <- df$y + 1
     # get the highest answer category of ""y"", so we know where the
     # range of the x-axis ends
-    if (!is.null(labels)) {
+    if (!is.null(llabels)) {
       # check if we have much less labels than values
       # so there might be a labelling mistake with
       # the variable
-      if (length(labels) < length(unique(na.omit(varCount)))) {
+      if (length(llabels) < length(unique(na.omit(varCount)))) {
         warning(""Variable has less labels than unique values. Output might be incorrect. Please check value labels."", call. = F)
       }
-      catcount <- startAxisAt + length(labels) - 1
+      catcount <- startAxisAt + length(llabels) - 1
     } else {
       # determine maximum values
       # first, check the total amount of different factor levels
@@ -180,12 +180,12 @@ create.frq.df <- function(varCount,
     # zero counts, but no(!) missings!
     mydat <- as.data.frame(cbind(var = startAxisAt:catcount,
                                  frq = frq[startAxisAt:catcount]))
-    if (!is.null(labels)) {
-      labels <- sjmisc::word_wrap(labels, breakLabelsAt)
+    if (!is.null(llabels)) {
+      llabels <- sjmisc::word_wrap(llabels, breakLabelsAt)
     } else {
       # If axisLabels.x were not defined, simply set numbers from 1 to
       # amount of categories (=number of rows) in dataframe instead
-      labels <- c(startAxisAt:(nrow(mydat) + startAxisAt - 1))
+      llabels <- c(startAxisAt:(nrow(mydat) + startAxisAt - 1))
     }
   }
   # caculate missings here
@@ -196,7 +196,7 @@ create.frq.df <- function(varCount,
   # If missings are not removed, add an
   # ""NA"" to labels and a new row to data frame which contains the missings
   if (!na.rm) {
-    labels  <- c(labels, ""NA"")
+    llabels  <- c(llabels, ""NA"")
     mydat <- rbind(mydat, c(catcount + 1, missingcount))
     # also add a columns with percentage values of count distribution
     mydat <- data.frame(cbind(mydat, prz = c(round(100 * mydat$frq / length(varCount), round.prz))))
@@ -211,7 +211,7 @@ create.frq.df <- function(varCount,
     ord <- order(mydat$frq, decreasing = (order.frq == ""desc""))
     mydat$frq <- mydat$frq[ord]
     mydat$prz <- mydat$prz[ord]
-    labels <- labels[ord]
+    llabels <- llabels[ord]
   }
   # --------------------------------------------------------
   # add valid and cumulative percentages
@@ -224,9 +224,9 @@ create.frq.df <- function(varCount,
   # more value labels than data frame rows (i.e. more categories are expected
   # than appear in the data frame)
   # --------------------------------------------------------
-  if (!is.null(labelvalues)) {
+  if (is.null(labelvalues)) {
     dfc <- 1
-    while (length(labels) > nrow(mydat) && as.numeric(mydat$var[dfc]) > dfc) {
+    while (length(llabels) > nrow(mydat) && as.numeric(mydat$var[dfc]) > dfc) {
       # insert ""first"" row which seems to be missing
       mydat <- rbind(rep(0, ncol(mydat)), mydat)
       # increase counter
@@ -245,7 +245,7 @@ create.frq.df <- function(varCount,
   # return results
   # -------------------------------------
   invisible(structure(list(mydat = mydat,
-                           labels = labels,
+                           labels = llabels,
                            catmin = catmin,
                            minval = minval)))
 }

---FILE: R/sjPlotFrequencies.R---
@@ -312,7 +312,7 @@ sjp.frq <- function(varCount,
   # --------------------------------------------------------
   # count variable may not be a factor!
   # --------------------------------------------------------
-  if (is.factor(varCount)) varCount <- as.numeric(varCount)
+  if (is.factor(varCount)) varCount <- sjmisc::to_value(varCount)
   # --------------------------------------------------------
   # We have several options to name the histrogram type
   # Here we will reduce it to a unique value

---FILE: R/sjTabFrequencies.R---
@@ -325,10 +325,8 @@ sjt.frq <- function(data,
       # check if any strings found
       # remove string variables
       if (length(stringcolumns) > 0) data <- data[, -stringcolumns]
-    } else {
-      if (is.character(data)) {
-        stop(""Parameter 'data' is a single string vector, where string vectors should be removed. No data to compute frequency table left. See parameter 'removeStringVectors' for details."", call. = FALSE)
-      }
+    } else if (is.character(data)) {
+      stop(""Parameter 'data' is a single string vector, where string vectors should be removed. No data to compute frequency table left. See parameter 'removeStringVectors' for details."", call. = FALSE)
     }
   }
   # -------------------------------------
@@ -344,7 +342,10 @@ sjt.frq <- function(data,
     }
     # check if any NA-only variables found
     if (length(NAcolumns) > 0) {
-      message(sprintf(""%i variables have been removed from output, because they contained only NA's: %s"", length(NAcolumns), paste(colnames(data)[NAcolumns], collapse = ""; "")))
+      message(sprintf(""%i variables have been removed from output, because they contained only NA's: %s"", 
+                      length(NAcolumns), 
+                      paste(colnames(data)[NAcolumns], 
+                            collapse = ""; "")))
       data <- data[, -NAcolumns]
     }
   }"
strengejacke,sjPlot,16b7e2cda47c75cbaddf151621d2691234f773ce,Daniel Ldecke,d.luedecke@uke.de,2015-06-03T17:30:18Z,Daniel Ldecke,d.luedecke@uke.de,2015-06-03T17:30:18Z,"closes #44, fixes #33",DESCRIPTION;NEWS;R/helpfunctions.R;R/sjPlotAnova.R;R/sjPlotFrequencies.R;R/sjPlotGLME.R;R/sjPlotGroupFrequencies.R;R/sjPlotInteractions.R;R/sjPlotLinreg.R;R/sjPlotOdds.R;R/sjPlotPropTable.R;R/sjPlotSetTheme.R;R/sjTabFrequencies.R;README.md;man/sjPlot-package.Rd;man/sjp.aov1.Rd;man/sjp.frq.Rd;man/sjp.glm.Rd;man/sjp.glmer.Rd;man/sjp.grpfrq.Rd;man/sjp.int.Rd;man/sjp.lm.Rd;man/sjp.setTheme.Rd;man/sjp.xtab.Rd,False,True,True,False,550,375,925,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.8.1-1
-Date: 2015-05-31
+Version: 1.8.1-2
+Date: 2015-06-03
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of several plotting and table output functions for visualizing data.

---FILE: NEWS---
@@ -1,7 +1,12 @@
-Version 1.8.1-1
+Version 1.8.1-2
 ------------------------------------------------------------------------------
+Changes to functions:
+* Model and table summaries in plotting functions (like ""sjp.lm"" or ""sjp.grpfrq"") are no longer printed by default. Use ""showTableSummary = TRUE"" or ""showModelSummary = TRUE"" to print summaries in plots.
+* Added parameter ""int.term"" to ""sjp.int"", to plot selected interaction terms for ""type = 'eff'"" only. May be used in cases where effect computation takes too long or even crashes due to out-of-memory-problems.
+
 Bug fixes:
 * ""sjp.int"" sometimes crashed with mixed models, due to slow Kenward-Roger-computation of standard errors, provided by the ""effects""-package. Fixed, ""KR""-parameter, when calling ""allEffects"", now defaults to ""FALSE"".
+* Fixed bug in ""sjp.frq"" and ""sjt.frq"", where non-incremental levels in some cases were not displayed correctly.
 
 Version 1.8.1
 ------------------------------------------------------------------------------

---FILE: R/helpfunctions.R---
@@ -73,6 +73,7 @@ out.html.table <- function(no.output, file, knitr, toWrite, useViewer) {
 # for sjp and sjt frq functions
 create.frq.df <- function(varCount,
                           labels,
+                          labelvalues,
                           breakLabelsAt,
                           order.frq = ""none"",
                           round.prz = 4,
@@ -89,76 +90,106 @@ create.frq.df <- function(varCount,
   df <- as.data.frame(table(varCount))
   # name columns
   names(df) <- c(""y"", ""Freq"")
-  # --------------------------------------------------------
-  # Define amount of category, include zero counts
-  # --------------------------------------------------------
-  # Zero counts of categories are not plotted by default just becaus
-  # these categories don't appear in the data. If we assume a
-  # ""quasi-continuous"" scale (categories from 1 to 4 etc.), we now
-  # identify the zero counts and add / insert them into the data frame.
-  # This enables us to plot zero counts as well.
-  # We guess the maximum amount of categories either by the amount
-  # of supplied category labels. If no category labels were passed
-  # as parameter, we assume that the maximum value found in the category
-  # columns represents the highest category number
-  catcount <- 0
-  catmin <- minval <- min(varCount, na.rm = TRUE)
-  # ----------------------------------------------
-  # check for axis start, depending on lowest value
-  # ----------------------------------------------
-  if (startAxisAt == ""auto"") {
-    startAxisAt <- as.numeric(catmin)
-    if (startAxisAt == 0) startAxisAt <- 1
-  }
-  # Factors have to be transformed into numeric values
-  # for continiuos x-axis-scale
-  df$y <- sjmisc::to_value(df$y, keep.labels = F)
-  # if categories start with zero, fix this here
-  if (min(df$y) == 0 && startAxisAt > 0) df$y <- df$y + 1
-  # get the highest answer category of ""y"", so we know where the
-  # range of the x-axis ends
-  if (!is.null(labels)) {
-    # check if we have much less labels than values
-    # so there might be a labelling mistake with
-    # the variable
-    if (length(labels) < length(unique(na.omit(varCount)))) {
-      warning(""Variable has less labels than unique values. Output might be incorrect. Please check value labels."", call. = F)
+  #---------------------------------------------------
+  # do we have label values associated with value labels?
+  # if yes, we assume that these values are the range
+  # of valid values for varCount...
+  #---------------------------------------------------
+  if (!is.null(labelvalues)) {
+    # create column of label values
+    df.lv <- data.frame(labelvalues)
+    # find matching values in varCount for label values
+    df.lv$frq <- df$Freq[match(df.lv$labelvalues, df$y)]
+    # copy df
+    mydat <- df.lv
+    # name columns
+    names(mydat) <- c(""var"", ""frq"")
+    # replace NA with zero
+    mydat$frq[is.na(mydat$frq)] <- 0
+    # create dummy-catcout, for missings. see below
+    catcount <- max(mydat$var, na.rm = T) + 1
+    # define minimum value
+    catmin <- minval <- min(varCount, na.rm = TRUE)
+    # wrap labels
+    if (!is.null(labels)) {
+      labels <- sjmisc::word_wrap(labels, breakLabelsAt)
+    } else {
+      # If axisLabels.x were not defined, simply set numbers from 1 to
+      # amount of categories (=number of rows) in dataframe instead
+      labels <- as.character(mydat$var)
     }
-    catcount <- startAxisAt + length(labels) - 1
   } else {
-    # determine maximum values
-    # first, check the total amount of different factor levels
-    catcount_1 <- length(unique(na.omit(varCount)))
-    # second, check the maximum factor level
-    catcount_2 <- max(varCount, na.rm = TRUE)
+    # --------------------------------------------------------
+    # Define amount of category, include zero counts
+    # --------------------------------------------------------
+    # Zero counts of categories are not plotted by default just becaus
+    # these categories don't appear in the data. If we assume a
+    # ""quasi-continuous"" scale (categories from 1 to 4 etc.), we now
+    # identify the zero counts and add / insert them into the data frame.
+    # This enables us to plot zero counts as well.
+    # We guess the maximum amount of categories either by the amount
+    # of supplied category labels. If no category labels were passed
+    # as parameter, we assume that the maximum value found in the category
+    # columns represents the highest category number
+    catcount <- 0
+    catmin <- minval <- min(varCount, na.rm = TRUE)
+    # ----------------------------------------------
+    # check for axis start, depending on lowest value
+    # ----------------------------------------------
+    if (startAxisAt == ""auto"") {
+      startAxisAt <- as.numeric(catmin)
+      if (startAxisAt == 0) startAxisAt <- 1
+    }
+    # Factors have to be transformed into numeric values
+    # for continuous x-axis-scale
+    df$y <- sjmisc::to_value(df$y, keep.labels = F)
     # if categories start with zero, fix this here
-    if (min(varCount, na.rm = TRUE) == 0) catcount_2 <- catcount_2 + 1
-    # catcount should contain the higher values, i.e. the maximum count of
-    # categories (factor levels) corresponds either to the highest factor level
-    # value or to the amount of different factor levels, depending on which one
-    # is larger
-    catcount <- ifelse(catcount_1 > catcount_2, catcount_1, catcount_2)
+    if (min(df$y) == 0 && startAxisAt > 0) df$y <- df$y + 1
+    # get the highest answer category of ""y"", so we know where the
+    # range of the x-axis ends
+    if (!is.null(labels)) {
+      # check if we have much less labels than values
+      # so there might be a labelling mistake with
+      # the variable
+      if (length(labels) < length(unique(na.omit(varCount)))) {
+        warning(""Variable has less labels than unique values. Output might be incorrect. Please check value labels."", call. = F)
+      }
+      catcount <- startAxisAt + length(labels) - 1
+    } else {
+      # determine maximum values
+      # first, check the total amount of different factor levels
+      catcount_1 <- length(unique(na.omit(varCount)))
+      # second, check the maximum factor level
+      catcount_2 <- max(varCount, na.rm = TRUE)
+      # if categories start with zero, fix this here
+      if (min(varCount, na.rm = TRUE) == 0) catcount_2 <- catcount_2 + 1
+      # catcount should contain the higher values, i.e. the maximum count of
+      # categories (factor levels) corresponds either to the highest factor level
+      # value or to the amount of different factor levels, depending on which one
+      # is larger
+      catcount <- ifelse(catcount_1 > catcount_2, catcount_1, catcount_2)
+    }
+    # Create a vector of zeros
+    frq <- rep(0, catcount)
+    # Replace the values in freq for those indices which equal dummyf$xa
+    # by dummyf$ya so that remaining indices are ones which you
+    # intended to insert
+    frq[df$y] <- df$Freq
+    # create new data frame. We now have a data frame with all
+    # variable categories abd their related counts, including
+    # zero counts, but no(!) missings!
+    mydat <- as.data.frame(cbind(var = startAxisAt:catcount,
+                                 frq = frq[startAxisAt:catcount]))
+    if (!is.null(labels)) {
+      labels <- sjmisc::word_wrap(labels, breakLabelsAt)
+    } else {
+      # If axisLabels.x were not defined, simply set numbers from 1 to
+      # amount of categories (=number of rows) in dataframe instead
+      labels <- c(startAxisAt:(nrow(mydat) + startAxisAt - 1))
+    }
   }
-  # Create a vector of zeros
-  frq <- rep(0, catcount)
-  # Replace the values in freq for those indices which equal dummyf$xa
-  # by dummyf$ya so that remaining indices are ones which you
-  # intended to insert
-  frq[df$y] <- df$Freq
-  # create new data frame. We now have a data frame with all
-  # variable categories abd their related counts, including
-  # zero counts, but no(!) missings!
-  mydat <- as.data.frame(cbind(var = startAxisAt:catcount,
-                               frq = frq[startAxisAt:catcount]))
   # caculate missings here
   missingcount <- length(which(is.na(varCount)))
-  if (!is.null(labels)) {
-    labels <- sjmisc::word_wrap(labels, breakLabelsAt)
-  } else {
-    # If axisLabels.x were not defined, simply set numbers from 1 to
-    # amount of categories (=number of rows) in dataframe instead
-    if (is.null(labels)) labels <- c(startAxisAt:(nrow(mydat) + startAxisAt - 1))
-  }
   # --------------------------------------------------------
   # Handle missings
   # --------------------------------------------------------
@@ -193,19 +224,21 @@ create.frq.df <- function(varCount,
   # more value labels than data frame rows (i.e. more categories are expected
   # than appear in the data frame)
   # --------------------------------------------------------
-  dfc <- 1
-  while (length(labels) > nrow(mydat) && as.numeric(mydat$var[dfc]) > dfc) {
-    # insert ""first"" row which seems to be missing
-    mydat <- rbind(rep(0, ncol(mydat)), mydat)
-    # increase counter
-    dfc <- dfc + 1
-  }
-  # check if we modified mydat
-  if (dfc > 1) {
-    # set var
-    mydat$var <- c(1:nrow(mydat))
-    if (catmin != min(as.numeric(mydat$var), na.rm = T)) {
-      catmin <- min(as.numeric(mydat$var), na.rm = T)
+  if (!is.null(labelvalues)) {
+    dfc <- 1
+    while (length(labels) > nrow(mydat) && as.numeric(mydat$var[dfc]) > dfc) {
+      # insert ""first"" row which seems to be missing
+      mydat <- rbind(rep(0, ncol(mydat)), mydat)
+      # increase counter
+      dfc <- dfc + 1
+    }
+    # check if we modified mydat
+    if (dfc > 1) {
+      # set var
+      mydat$var <- c(1:nrow(mydat))
+      if (catmin != min(as.numeric(mydat$var), na.rm = T)) {
+        catmin <- min(as.numeric(mydat$var), na.rm = T)
+      }
     }
   }
   # -------------------------------------

---FILE: R/sjPlotAnova.R---
@@ -72,7 +72,7 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""pv""))
 #'          Default is 2, i.e. estimators have 2 digits after decimal point.
 #' @param showPValueLabels Whether the significance levels of each category/group should be appended
 #'          to values or not.
-#' @param showModelSummary If \code{TRUE} (default), a summary of the anova model with 
+#' @param showModelSummary If \code{TRUE}, a summary of the anova model with 
 #'          Sum of Squares between groups (ssb), Sum of Squares within groups (ssw), multiple and adjusted 
 #'          R-square and F-Test is printed to the lower right corner
 #'          of the diagram. Default is \code{TRUE}.
@@ -95,7 +95,8 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""pv""))
 #' sjp.aov1(efc$c12hour,
 #'          as.factor(efc$e42dep),
 #'          axisLabels.y = efc.val['e42dep'],
-#'          axisTitle.x = efc.var[['c12hour']])
+#'          axisTitle.x = efc.var[['c12hour']],
+#'          showModelSummary = TRUE)
 #'          
 #' # -------------------------------------------------
 #' # auto-detection of value labels and variable names
@@ -112,8 +113,7 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""pv""))
 #'          axisLabels.y = efc.val['c172code'],
 #'          title = efc.var[['c12hour']],
 #'          type = ""bars"",
-#'          geom.size = 0.5,
-#'          showModelSummary = FALSE)
+#'          geom.size = 0.5)
 #'
 #' @import ggplot2
 #' @import sjmisc
@@ -140,7 +140,7 @@ sjp.aov1 <- function(depVar,
                     showValueLabels=TRUE, 
                     labelDigits=2,
                     showPValueLabels=TRUE,
-                    showModelSummary=TRUE,
+                    showModelSummary=FALSE,
                     printPlot=TRUE) {
   # --------------------------------------------------------
   # try to automatically set labels is not passed as parameter

---FILE: R/sjPlotFrequencies.R---
@@ -18,16 +18,6 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""frq"", ""grp"", ""upper.ci""
 #'         with decimales may result in unexpected behaviour.
 #' 
 #' @param varCount The variable which frequencies should be plotted.
-#' @param type Specifies the type of distribution plot that will be plotted.
-#'          \describe{
-#'            \item{\code{""bar""}}{or \code{""bars""} or \code{""b""} for simple bars (the default setting)}
-#'            \item{\code{""dots""}}{or \code{""dot""} for a dot plot}
-#'            \item{\code{""h""}}{or \code{""hist""} or \code{""histogram""} for a histogram}
-#'            \item{\code{""line""}}{or \code{""lines""} or \code{""l""} for a histogram with filled area with line}
-#'            \item{\code{""dens""}}{or \code{""d""} or \code{""density""} for a density plot}
-#'            \item{\code{""box""}}{or \code{""boxplot""} or \code{""boxplots""} for box plots}
-#'            \item{\code{""v""}}{or \code{""violin""} for violin plots}
-#'            }
 #' @param title Title of diagram as string. Example: \code{title = ""my title""}.
 #'          Use \code{NULL} to automatically detect variable names that will be used as title
 #'          (see \code{\link[sjmisc]{set_var_labels}}) for details).
@@ -42,6 +32,16 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""frq"", ""grp"", ""upper.ci""
 #' @param sort.frq Determines whether categories on x-axis should be sorted according to the frequencies or not. 
 #'          Default is \code{""none""}, so categories are not sorted by frequency. Use \code{""asc""} or
 #'          \code{""desc""} for sorting categories ascending or descending in relation to the frequencies.
+#' @param type Specifies the type of distribution plot that will be plotted.
+#'          \describe{
+#'            \item{\code{""bar""}}{or \code{""bars""} or \code{""b""} for simple bars (the default setting)}
+#'            \item{\code{""dots""}}{or \code{""dot""} for a dot plot}
+#'            \item{\code{""h""}}{or \code{""hist""} or \code{""histogram""} for a histogram}
+#'            \item{\code{""line""}}{or \code{""lines""} or \code{""l""} for a histogram with filled area with line}
+#'            \item{\code{""dens""}}{or \code{""d""} or \code{""density""} for a density plot}
+#'            \item{\code{""box""}}{or \code{""boxplot""} or \code{""boxplots""} for box plots}
+#'            \item{\code{""v""}}{or \code{""violin""} for violin plots}
+#'            }
 #' @param geom.colors user defined color for geoms, e.g. \code{geom.colors = ""#0080ff""}.
 #' @param geom.size size of geoms, depending on the plot \code{type}. Note that 
 #'          bar and bin widths mostly need smaller values than dot sizes (i.e. if \code{type = ""dots""}).
@@ -239,12 +239,12 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""frq"", ""grp"", ""upper.ci""
 #' @import sjmisc
 #' @export
 sjp.frq <- function(varCount, 
-                    type=""bars"",
                     title="""",
                     weightBy=NULL,
                     weightByTitleString=NULL,
                     interactionVar=NULL,
                     sort.frq=""none"",
+                    type=""bars"",
                     geom.size=0.7,
                     geom.colors=NULL,
                     axisLabels.x=NULL, 
@@ -305,6 +305,11 @@ sjp.frq <- function(varCount,
     geom.colors <- geom.colors[1]
   }
   # --------------------------------------------------------
+  # save label values. needed later to determine correct
+  # amount of categories
+  # --------------------------------------------------------
+  labelvalues <- sjmisc::get_values(varCount)
+  # --------------------------------------------------------
   # count variable may not be a factor!
   # --------------------------------------------------------
   if (is.factor(varCount)) varCount <- as.numeric(varCount)
@@ -358,6 +363,7 @@ sjp.frq <- function(varCount,
   #---------------------------------------------------
   df.frq <- create.frq.df(varCount, 
                           axisLabels.x, 
+                          labelvalues,
                           breakLabelsAt, 
                           sort.frq, 
                           2, 

---FILE: R/sjPlotGLME.R---
@@ -19,9 +19,9 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""nQQ"", ""ci"", ""fixef"", ""f
 #'            \item{\code{""fe""}}{for odds ratios of fixed effects}
 #'            \item{\code{""fe.cor""}}{for correlation matrix of fixed effects}
 #'            \item{\code{""re.qq""}}{for a QQ-plot of random effects (random effects quantiles against standard normal quantiles)}
-#'            \item{\code{""fe.pc""}}{or \code{""fe.prob""} to plot probability curves (predicted probabilities) of all fixed effects coefficients. Use \code{facet.grid} to decide whether to plot each coefficient as separate plot or as integrated faceted plot.}
-#'            \item{\code{""ri.pc""}}{or \code{""ri.prob""} to plot probability curves (predicted probabilities) of random intercept variances for all fixed effects coefficients. Use \code{facet.grid} to decide whether to plot each coefficient as separate plot or as integrated faceted plot.}
-#'            \item{\code{""y.pc""}}{or \code{""y.prob""} to plot predicted probabilities for the response, with and without random effects. Use \code{facet.grid} to decide whether to plot with and w/o random effect plots as separate plot or as integrated faceted plot.}
+#'            \item{\code{""fe.pc""}}{or \code{""fe.prob""} to plot probability curves (predicted probabilities) of all fixed effects coefficients. Use \code{facet.grid} to decide whether to plot each coefficient as separate plot or as integrated faceted plot. See 'Details'.}
+#'            \item{\code{""ri.pc""}}{or \code{""ri.prob""} to plot probability curves (predicted probabilities) of random intercept variances for all fixed effects coefficients. Use \code{facet.grid} to decide whether to plot each coefficient as separate plot or as integrated faceted plot. See 'Details'.}
+#'            \item{\code{""y.pc""}}{or \code{""y.prob""} to plot predicted probabilities for the response, with and without random effects. Use \code{facet.grid} to decide whether to plot with and w/o random effect plots as separate plot or as integrated faceted plot. See 'Details'.}
 #'          }
 #' @param vars a numeric vector with column indices of selected variables or a character vector with
 #'          variable names of selected variables from the fitted model, which should be used to plot probability
@@ -95,6 +95,24 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""nQQ"", ""ci"", ""fixef"", ""f
 #'         R code that is used to compute fixed effects correlation matrices and
 #'         qq-plots of random effects.
 #'
+#' @details \describe{
+#'            \item{\code{type = ""fe.pc""}}{(or \code{""fe.prob""}), the predicted probabilities
+#'            are based on the fixed effects intercept's estimate and each specific 
+#'            fixed term's estimate. All other fixed effects are set to zero (i.e. ignored), 
+#'            which corresponds to \code{\link{plogis}(b0 + bx * x)} (where \code{x} 
+#'            is the logit-estimate of fixed effects and \code{b0} is the intercept of
+#'            the fixed effects).}
+#'            \item{\code{type = ""ri.pc""}}{(or \code{""ri.prob""}), the predicted probabilities
+#'            are based on the fixed effects intercept, plus each random intercept and 
+#'            each specific  fixed term's estimate. All other fixed effects are set to zero (i.e. ignored), 
+#'            which corresponds to \code{\link{plogis}(b0 + b0[r1-rn] + bx * x)} (where \code{x} 
+#'            is the logit-estimate of fixed effects, \code{b0} is the intercept of
+#'            the fixed effects and \code{b0[r1-rn]} are all random intercepts).}
+#'            \item{\code{type = ""y.pc""}}{(or \code{type = ""y.prob""}), the predicted values
+#'            of the response are computed, based on the \code{predict.merMod}
+#'            method. Corresponds to \code{\link{plogis}(predict(fit, type = ""response""))}.}
+#'          }
+#'
 #' @examples
 #' \dontrun{
 #' library(lme4)
@@ -745,7 +763,7 @@ sjp.lme4  <- function(fit,
       # ---------------------------------------
       # show intercept?
       # ---------------------------------------
-      startAt <- ifelse (showIntercept == TRUE, 1, 2)
+      startAt <- ifelse(showIntercept == TRUE, 1, 2)
       # ---------------------------------------
       # retrieve standard errors, for ci
       # ---------------------------------------
@@ -967,7 +985,7 @@ sjp.lme4  <- function(fit,
       # ---------------------------------------
       # ggplot-objekt
       # ---------------------------------------
-      interc <- ifelse (fun == ""glm"", 1, 0)
+      interc <- ifelse(fun == ""glm"", 1, 0)
       mydf$interc <- interc
       gp <- ggplot(mydf, aes(x = x,
                              y = OR,
@@ -1024,14 +1042,14 @@ sjp.lme4  <- function(fit,
         gp <- gp + labs(x = axisTitle.x, y = axisTitle.y)
         # check if user wants free scale for each facet
         if (free.scale)
-          gp  <- gp + facet_wrap( ~ grp, scales = ""free_y"")
+          gp  <- gp + facet_wrap(~grp, scales = ""free_y"")
         else
-          gp  <- gp + facet_grid( ~ grp)
+          gp  <- gp + facet_grid(~grp)
       } else {
         gp <- gp +
           labs(x = axisTitle.x, y = axisTitle.y, title = title)
       }
-      return (gp)
+      return(gp)
     }
     # ---------------------------------------
     # facet grid means, just one plot
@@ -1055,7 +1073,7 @@ sjp.lme4  <- function(fit,
       # set geom colors
       # ---------------------------------------------------------
       me.plot <- sj.setGeomColors(me.plot, geom.colors, 2, FALSE, NULL)
-      me.plot.list[[length(me.plot.list)+1]]  <- me.plot
+      me.plot.list[[length(me.plot.list) + 1]]  <- me.plot
       # ---------------------------------------------------------
       # Check whether ggplot object should be returned or plotted
       # ---------------------------------------------------------
@@ -1088,7 +1106,7 @@ sjp.lme4  <- function(fit,
         # set geom colors
         # ---------------------------------------------------------
         me.plot <- sj.setGeomColors(me.plot, geom.colors, 2, FALSE, NULL)
-        me.plot.list[[length(me.plot.list)+1]]  <- me.plot
+        me.plot.list[[length(me.plot.list) + 1]]  <- me.plot
         # ---------------------------------------------------------
         # Check whether ggplot object should be returned or plotted
         # ---------------------------------------------------------
@@ -1102,10 +1120,10 @@ sjp.lme4  <- function(fit,
   # -------------------------------------
   # return results
   # -------------------------------------
-  invisible (structure(class = ifelse (fun == ""glm"", ""sjpglmer"", ""sjplmer""),
-                       list(plot = me.plot,
-                            plot.list = me.plot.list,
-                            mydf = mydf)))
+  invisible(structure(class = ifelse(fun == ""glm"", ""sjpglmer"", ""sjplmer""),
+                      list(plot = me.plot,
+                           plot.list = me.plot.list,
+                           mydf = mydf)))
 }
 
 
@@ -1135,7 +1153,6 @@ sjp.lme.feprobcurv <- function(fit,
   # ----------------------------
   fit.term.length <- length(names(lme4::fixef(fit))[-1])
   fit.term.names <- na.omit(attr(attr(fit.df, ""terms""), ""term.labels"")[1:fit.term.length])
-  response.name <- attr(attr(attr(fit.df, ""terms""), ""dataClasses""), ""names"")[1]
   fi <- unname(lme4::fixef(fit))[1]
   # ----------------------------
   # filter vars?
@@ -1229,7 +1246,7 @@ sjp.lme.feprobcurv <- function(fit,
         # cartesian coord still plots range of se, even
         # when se exceeds plot range.
         coord_cartesian(ylim = c(0, 1)) +
-        facet_wrap(~ grp,
+        facet_wrap(~grp,
                    ncol = round(sqrt(length(mydf.metricpred))),
                    scales = ""free_x"") +
         guides(colour = FALSE)
@@ -1251,11 +1268,11 @@ sjp.lme.feprobcurv <- function(fit,
       }
     }
   }
-  return (structure(class = ""sjpglmer.fecc"",
-          list(mydf.mp = mydf.metricpred,
-               plot.mp = plot.metricpred,
-               mydf.facet = mydf.facet,
-               plot.facet = plot.facet)))
+  return(structure(class = ""sjpglmer.fecc"",
+                   list(mydf.mp = mydf.metricpred,
+                        plot.mp = plot.metricpred,
+                        mydf.facet = mydf.facet,
+                        plot.facet = plot.facet)))
 }
 
 
@@ -1628,15 +1645,15 @@ sjp.lme.reqq <- function(fit,
   pv   <- attr(re, ""postVar"")
   cols <- 1:(dim(pv)[1])
   se   <- unlist(lapply(cols, function(i) sqrt(pv[i, i, ])))
-  ord  <- unlist(lapply(re, order)) + rep((0:(ncol(re) - 1)) * nrow(re), each=nrow(re))
+  ord  <- unlist(lapply(re, order)) + rep((0:(ncol(re) - 1)) * nrow(re), each = nrow(re))
   pDf  <- data.frame(y = unlist(re)[ord],
                      ci = 1.96 * se[ord],
                      nQQ = rep(qnorm(ppoints(nrow(re))), ncol(re)),
                      ID = factor(rep(rownames(re), ncol(re))[ord], levels = rownames(re)[ord]),
                      ind = gl(ncol(re), nrow(re), labels = names(re)),
                      grp = ""1"")
   gp <- ggplot(pDf, aes(nQQ, y, colour = grp)) +
-    facet_wrap(~ ind, scales = ""free"") +
+    facet_wrap(~ind, scales = ""free"") +
     xlab(""Standard normal quantiles"") +
     ylab(""Random effect quantiles"") +
     # Intercept-line
@@ -1670,9 +1687,9 @@ sjp.lme.reqq <- function(fit,
   # -------------------------------------
   # return results
   # -------------------------------------
-  return (invisible(structure(class = ifelse (fun == ""glm"", ""sjpglmer.qq"", ""sjplmer.qq""),
-                              list(plot = gp,
-                                   mydf = pDf))))
+  return(invisible(structure(class = ifelse(fun == ""glm"", ""sjpglmer.qq"", ""sjplmer.qq""),
+                             list(plot = gp,
+                                  mydf = pDf))))
 }
 
 
@@ -1725,10 +1742,10 @@ sjp.lme.fecor <- function(fit,
                        useViewer = useViewer,
                        no.output = no.output)
   }
-  return (invisible(structure(class = ifelse (fun == ""glm"", ""sjpglmer.cor"", ""sjplmer.cor""),
-                              list(plot = corret$plot,
-                                   mydf = corret$df,
-                                   corr.matrix = corret$corr.matrix))))
+  return(invisible(structure(class = ifelse(fun == ""glm"", ""sjpglmer.cor"", ""sjplmer.cor""),
+                             list(plot = corret$plot,
+                                  mydf = corret$df,
+                                  corr.matrix = corret$corr.matrix))))
 }
 
 
@@ -1780,7 +1797,7 @@ sjp.lme.fecondpred.onlynumeric <- function(fit,
       # retrieve names of coefficients
       coef.names <- names(lme4::fixef(fit))
       # find coef-position
-      coef.pos <- which(coef.names==fit.term.names[i])
+      coef.pos <- which(coef.names == fit.term.names[i])
       # calculate x-beta by multiplying original values with estimate of that term
       mydf.vals$xbeta <- mydf.vals$value * (lme4::fixef(fit)[coef.pos])
       # calculate probability (y) via cdf-function
@@ -1797,7 +1814,7 @@ sjp.lme.fecondpred.onlynumeric <- function(fit,
   # ---------------------------------------------------------
   # Prepare metric plots
   # ---------------------------------------------------------
-  if (length(mydf.metricpred)>0) {
+  if (length(mydf.metricpred) > 0) {
     # create mydf for integrated plot
     mydf.ges <- data.frame()
     for (i in 1:length(mydf.metricpred)) {
@@ -1812,7 +1829,7 @@ sjp.lme.fecondpred.onlynumeric <- function(fit,
         # when se exceeds plot range.
         coord_cartesian(ylim = c(0, 1))
       # add plot to list
-      plot.metricpred[[length(plot.metricpred)+1]] <- mp
+      plot.metricpred[[length(plot.metricpred) + 1]] <- mp
     }
     # -------------------------------------
     # if we have more than one numeric var, also create integrated plot
@@ -1831,9 +1848,9 @@ sjp.lme.fecondpred.onlynumeric <- function(fit,
         # cartesian coord still plots range of se, even
         # when se exceeds plot range.
         coord_cartesian(ylim = c(0, 1)) +
-        facet_wrap( ~ grp,
-                    ncol = round(sqrt(length(mydf.metricpred))),
-                    scales = ""free_x"") +
+        facet_wrap(~grp,
+                   ncol = round(sqrt(length(mydf.metricpred))),
+                   scales = ""free_x"") +
         guides(colour = FALSE)
       # add integrated plot to plot list
       plot.facet <- mp
@@ -1854,11 +1871,11 @@ sjp.lme.fecondpred.onlynumeric <- function(fit,
       }
     }
   }
-  return (structure(class = ""sjpglmer.fecc"",
-                    list(mydf.mp = mydf.metricpred,
-                         plot.mp = plot.metricpred,
-                         mydf.facet = mydf.facet,
-                         plot.facet = plot.facet)))
+  return(structure(class = ""sjpglmer.fecc"",
+                   list(mydf.mp = mydf.metricpred,
+                        plot.mp = plot.metricpred,
+                        mydf.facet = mydf.facet,
+                        plot.facet = plot.facet)))
 }
 
 get_lmerMod_pvalues <- function(fitmod) {
@@ -1891,5 +1908,5 @@ get_lmerMod_pvalues <- function(fitmod) {
     # i.e. times to repeat, is indicated by the Df.
     pv <- c(pv, rep(pia$`Pr(>Chisq)`, pia$Df))
   }
-  return (pv)
+  return(pv)
 }
\ No newline at end of file

---FILE: R/sjPlotGroupFrequencies.R---
@@ -106,7 +106,7 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""ypos"", ""wb"", ""ia"", ""mw"",
 #' @param showStandardDeviation If \code{TRUE}, the standard deviation is annotated as shaded rectangle around the mean intercept
 #'          line. Only applies to histogram-charts. The shaded rectangles have borders in the group colors, so it's easier to see
 #'          which shaded area belongs to which mean value resp. group
-#' @param showTableSummary If \code{TRUE} (default), a summary of the cross tabulation with N, Chi-square (see \code{\link{chisq.test}}),
+#' @param showTableSummary If \code{TRUE}, a summary of the cross tabulation with N, Chi-square (see \code{\link{chisq.test}}),
 #'          df, Cramer's V or Phi-value and p-value is printed to the upper right corner of the diagram. If a cell contains expected 
 #'          values lower than five (or lower than 10 if df is 1),
 #'          the Fisher's excact test (see \code{\link{fisher.test}}) is computed instead of Chi-square test. 
@@ -243,7 +243,7 @@ sjp.grpfrq <- function(varCount,
                        showMeanIntercept=FALSE,
                        showMeanValue=TRUE,
                        showStandardDeviation=FALSE,
-                       showTableSummary=TRUE,
+                       showTableSummary=FALSE,
                        showGroupCount=FALSE,
                        tableSummaryPos=""r"",
                        meanInterceptLineType=2,

---FILE: R/sjPlotInteractions.R---
@@ -23,6 +23,7 @@
 #'                  \item generalized linear models (\code{\link{glm}})
 #'                  \item linear mixed effects models (\code{\link[lme4]{lmer}})
 #'                  \item generalized linear mixed effects models (\code{\link[lme4]{glmer}})
+#'                  \item non-linear mixed effects models (\code{\link[lme4]{nlmer}})
 #'                  \item linear mixed effects models (\code{\link[nlme]{lme}}, but only for \code{type = ""eff""})
 #'                  \item generalized least squares models (\code{\link[nlme]{gls}}, but only for \code{type = ""eff""})
 #'                  \item panel data estimators (\code{plm})
@@ -38,6 +39,7 @@
 #'            \item generalized linear models (\code{\link{glm}})
 #'            \item linear mixed effects models (\code{\link[lme4]{lmer}})
 #'            \item generalized linear mixed effects models (\code{\link[lme4]{glmer}})
+#'            \item non-linear mixed effects models (\code{\link[lme4]{nlmer}})
 #'            \item linear mixed effects models (\code{\link[nlme]{lme}}, but only for \code{type = ""eff""})
 #'            \item generalized least squares models (\code{\link[nlme]{gls}}, but only for \code{type = ""eff""})
 #'            \item panel data estimators (\code{plm})
@@ -48,6 +50,9 @@
 #'            \item{\code{type = ""eff""}}{plots the overall moderation effect on the response value. See 'Details'.}
 #'            \item{\code{type = ""emm""}}{plots the estimated marginal means (least square means). If this type is chosen, not all function parameters are applicable. See 'Details'.}
 #'          }
+#' @param int.term select interaction term of \code{fit} (as character), which should be plotted
+#'          when using \code{type = ""eff""}. By default, this parameter can be ignored
+#'          (i.e. \code{int.term = NULL}). See 'Details'.
 #' @param int.plot.index A numeric vector with index numbers that indicate which 
 #'          interaction terms should be plotted in case the \code{fit} has more than
 #'          one interaction. By default, this values is \code{NULL}, hence all interactions
@@ -166,10 +171,17 @@
 #'              to plot differences in interventions between control and treatment groups over multiple time points.
 #'              \itemize{
 #'                \item Following paramters apply to this plot type: \code{showCI}, \code{valueLabel.digits} and \code{axisLabels.x}.
-#'                \item Following parameters \emph{do not} apply to this function: \code{int.plot.index}, \code{diff}, \code{moderatorValues}, \code{fillColor}, \code{fillAlpha}, \code{interceptLineColor}, \code{estLineColor}, \code{lineLabelSize}, \code{lineLabelColor} and \code{lineLabelString}.
+#'                \item Following parameters \emph{do not} apply to this function: \code{int.term}, \code{int.plot.index}, \code{diff}, \code{moderatorValues}, \code{fillColor}, \code{fillAlpha}, \code{interceptLineColor}, \code{estLineColor}, \code{lineLabelSize}, \code{lineLabelColor} and \code{lineLabelString}.
 #'              }
 #'            }
 #'          }
+#'          The parameter \code{int.term} only applies to \code{type = ""eff""} and can be used
+#'          to select a specific interaction term of the model that should be plotted. The function
+#'          then calls \code{effect(int.term, fit)} to compute effects for this specific interaction
+#'          term only. This approach is recommended, when the fitted model contains many observations
+#'          and/or variables, which may slow down the effect-computation dramatically. In such cases,
+#'          consider computing effects for selected interaction terms only with \code{int.terms}.
+#'          See 'Examples'.
 #'
 #' @note Note that beside interaction terms, also the single predictors of each interaction (main effects)
 #'        must be included in the fitted model as well. Thus, \code{lm(dep ~ pred1 * pred2)} will work, 
@@ -221,6 +233,10 @@
 #' # interactions by default. use ""plevel"" to adjust p-level
 #' # sensivity
 #' sjp.int(fit, type = ""cond"")
+#' 
+#' # plot only selected interaction term for
+#' # type = ""eff""
+#' sjp.int(fit, type = ""eff"", int.term = ""sex*education"")
 #'
 #' # plot interactions, using mean and sd as moderator
 #' # values to calculate interaction effect
@@ -327,6 +343,7 @@
 #' @export
 sjp.int <- function(fit,
                     type = ""cond"",
+                    int.term = NULL,
                     int.plot.index=NULL,
                     diff=FALSE,
                     moderatorValues=""minmax"",
@@ -377,6 +394,9 @@ sjp.int <- function(fit,
   } else if (any(c.f == ""glmerMod"")) {
     fun <- ""glmer""
     stat.fun <- ""glm""
+  } else if (any(c.f == ""nlmerMod"")) {
+    fun <- ""nlmer""
+    stat.fun <- ""nlm""
   } else if (any(c.f == ""lmerMod"") || any(c.f == ""merModLmerTest"")) {
     fun <- ""lmer""
     stat.fun <- ""lm""
@@ -398,7 +418,7 @@ sjp.int <- function(fit,
   # ------------------------
   # check if suggested package is available
   # ------------------------
-  if ((fun == ""lmer"" || fun == ""glmer"") && !requireNamespace(""lme4"", quietly = TRUE)) {
+  if ((fun == ""lmer"" || fun == ""glmer"" || fun == ""nlmer"") && !requireNamespace(""lme4"", quietly = TRUE)) {
     stop(""Package 'lme4' needed for this function to work. Please install it."", call. = FALSE)
   }
   if (fun == ""plm"" && !""package:plm"" %in% search()) {
@@ -427,11 +447,11 @@ sjp.int <- function(fit,
   # plot estimated marginal means?
   # --------------------------------------------------------
   if (type == ""emm"") {
-    return (sjp.emm(fit, swapPredictors, plevel, title, geom.colors,
-                    axisTitle.x, axisTitle.y, axisLabels.x, legendTitle, legendLabels,
-                    showValueLabels, valueLabel.digits, showCI, breakTitleAt,
-                    breakLegendTitleAt, breakLegendLabelsAt, axisLimits.y, 
-                    gridBreaksAt, facet.grid, printPlot))
+    return(sjp.emm(fit, swapPredictors, plevel, title, geom.colors,
+                   axisTitle.x, axisTitle.y, axisLabels.x, legendTitle, legendLabels,
+                   showValueLabels, valueLabel.digits, showCI, breakTitleAt,
+                   breakLegendTitleAt, breakLegendLabelsAt, axisLimits.y, 
+                   gridBreaksAt, facet.grid, printPlot))
   }
   # --------------------------------------------------------
   # list labels
@@ -442,137 +462,35 @@ sjp.int <- function(fit,
   # plot moderation effeczs?
   # --------------------------------------------------------
   if (type == ""eff"") {
-    return (sjp.eff.int(fit, int.plot.index, moderatorValues, swapPredictors, plevel,
-                        title, fillAlpha, geom.colors, axisTitle.x,
-                        axisTitle.y, legendTitle, legendLabels,
-                        showValueLabels, breakTitleAt, breakLegendLabelsAt, 
-                        breakLegendTitleAt, breakAnnotationLabelsAt, axisLimits.y,
-                        gridBreaksAt, showCI, facet.grid, printPlot, fun))
+    return(sjp.eff.int(fit, int.term, int.plot.index, moderatorValues, swapPredictors, plevel,
+                       title, fillAlpha, geom.colors, axisTitle.x,
+                       axisTitle.y, legendTitle, legendLabels,
+                       showValueLabels, breakTitleAt, breakLegendLabelsAt, 
+                       breakLegendTitleAt, breakAnnotationLabelsAt, axisLimits.y,
+                       gridBreaksAt, showCI, facet.grid, printPlot, fun))
   }
   # -----------------------------------------------------------
   # set axis title
   # -----------------------------------------------------------
   if ((fun == ""glm"" || fun == ""glmer"") && is.null(axisTitle.y)) axisTitle.y <- ""Change in Predicted Probability""
   # -----------------------------------------------------------
-  # retrieve coefficients
-  # -----------------------------------------------------------
-  coef.tab <- summary(fit)$coefficients
-  pval <- rep(0, times = nrow(coef.tab) - 1)
-  # -----------------------------------------------------------
-  # Help-function that removes AsIS I from formulas.
-  # If someone know regular expressions better than me,
-  # please provide a one-liner solution for the 3 sub commands.
-  # -----------------------------------------------------------
-  remove_I <- function(xnames) {
-    fpos <- grep(""I("", xnames, fixed = T)
-    if (length(fpos) > 0 && fpos > 0) {
-      xnames <- sub(""I("", """", xnames, fixed = T)
-      xnames <- sub("")"", """", xnames, fixed = T)
-      xnames <- sub("" * "", "":"", xnames, fixed = T)
-    }
-    return (xnames)
-  }
-  # -----------------------------------------------------------
-  # prepare values for (generalized) linear models
+  # get all (significant) interaction terms from model
+  # the function ""getInteractionTerms"" checks if a fitted
+  # model contains any interaction terms that are significant
+  # at the level specified by ""plevel"". returns NULL, if model
+  # contains no interaction terms or no significant interaction term.
+  # else, information on model and interaction terms is returned
   # -----------------------------------------------------------
-  if (fun == ""lm"" || fun == ""glm"" || fun == ""plm"" || fun == ""lme"" || fun == ""gls"") {
-    # -----------------------------------------------------------
-    # retrieve amount and names of predictor variables and
-    # of dependent variable
-    # -----------------------------------------------------------
-    if (fun == ""plm"") {
-      # plm objects have different structure than (g)lm
-      predvars <- attr(attr(attr(fit$model, ""terms""), ""dataClasses""), ""names"")[-1]
-      depvar.label <- attr(attr(attr(fit$model, ""terms""), ""dataClasses""), ""names"")[1]
-      # retrieve model matrix
-      fitdat <- data.frame(cbind(as.vector(fit$model[, 1]), model.matrix(fit)))
-    } else {
-      predvars <- attr(attr(fit$terms, ""dataClasses""), ""names"")[-1]
-      depvar.label <- attr(attr(fit$terms, ""dataClasses""), ""names"")[1]
-      # retrieve model matrix
-      fitdat <- data.frame(model.matrix(fit))
-    }
-    # remember length of predictor variables
-    predvars.length <- length(predvars)
-    # -----------------------------------------------------------
-    # retrieve p-values, without intercept
-    # -----------------------------------------------------------
-    if (ncol(coef.tab) > 3) pval <- coef.tab[-1, 4]
-    # -----------------------------------------------------------
-    # retrieve estimates, without intercept
-    # -----------------------------------------------------------
-    estimates <- coef.tab[-1, 1]
-    # -----------------------------------------------------------
-    # need to remove ""I(...)""?
-    # -----------------------------------------------------------
-    predvars <- remove_I(predvars)
-    estimates.names <- names(estimates)
-    estimates.names <- remove_I(estimates.names)
-    it <- estimates.names
-    # -----------------------------------------------------------
-    # retrieve estimate of intercept
-    # -----------------------------------------------------------
-    b0 <- estimates.intercept <- coef.tab[1, 1]
-  # -----------------------------------------------------------
-  # prepare values for (generalized) linear mixed effecrs models
-  # -----------------------------------------------------------
-  } else {
-    # -----------------------------------------------------------
-    # retrieve amount and names of predictor variables and
-    # of dependent variable
-    # -----------------------------------------------------------
-    predvars <- colnames(fit@frame)[-1]
-    depvar.label <- colnames(fit@frame)[1]
-    # remember length of predictor variables
-    predvars.length <- length(predvars)
-    # -----------------------------------------------------------
-    # retrieve p-values, without intercept
-    # -----------------------------------------------------------
-    pval <- get_lmerMod_pvalues(fit)[-1]
-    # -----------------------------------------------------------
-    # retrieve estimates, without intercept
-    # -----------------------------------------------------------
-    estimates <- unname(lme4::fixef(fit)[-1])
-    estimates.names <- names(lme4::fixef(fit)[-1])
-    # -----------------------------------------------------------
-    # retrieve model matrix with all relevant predictors
-    # -----------------------------------------------------------
-    fitdat <- model.matrix(fit)
-    # -----------------------------------------------------------
-    # need to remove ""I(...)""?
-    # -----------------------------------------------------------
-    predvars <- remove_I(predvars)
-    estimates.names <- remove_I(estimates.names)
-    it <- estimates.names
-    # -----------------------------------------------------------
-    # retrieve estimate of intercept
-    # -----------------------------------------------------------
-    b0 <- estimates.intercept <- unname(lme4::fixef(fit)[1])
-  }
+  git <- getInteractionTerms(fit, fun, plevel)
+  # check return value
+  if (is.null(git)) return(invisible(NULL))
   # -----------------------------------------------------------
-  # find all significant interactions
-  # we start looking for significant p-values beginning
-  # with the first interaction, not the first single term!
-  # thus, the starting point is first position after all single
-  # predictor variables
+  # init variables from return values
   # -----------------------------------------------------------
-  # find interaction terms, which contains a colon, in row names
-  firstit <- grep("":"", it, fixed = TRUE)[1]
-  # check whether we have any interaction terms included at all
-  if(is.null(firstit) || is.na(firstit) || firstit == 0) {
-    warning(""No interaction term found in fitted model..."", call. = FALSE)
-    return (invisible (NULL))
-  }
-  # save names of interaction predictor variables into this object
-  intnames <- c()
-  for (i in firstit:length(pval)) {
-    if (pval[i] < plevel) intnames <- c(intnames, it[i])
-  }
-  # check for any signigicant interactions, stop if nothing found
-  if (is.null(intnames)) {
-    warning(""No significant interactions found..."", call. = FALSE)
-    return (invisible (NULL))
-  }
+  b0 <- git[[""b0""]]
+  estimates.names <- git[[""estimates.names""]]
+  estimates <- git[[""estimates""]]
+  fitdat <- git[[""fitdat""]]
   # init vector that saves ggplot objects
   plotlist <- list()
   dflist <- list()
@@ -581,7 +499,7 @@ sjp.int <- function(fit,
   # terms are factors, we may have the same interaction term names
   # multiples times - thus, remove redundant duplicates
   # -----------------------------------------------------------
-  intnames <- unique(intnames)
+  intnames <- unique(git[[""intnames""]])
   # check if we have selected plots only, and remove any plots
   # that should not be plotted. but be careful for out of bound index!
   if (!is.null(int.plot.index) && !any(int.plot.index > length(intnames))) intnames <- intnames[int.plot.index]
@@ -599,7 +517,7 @@ sjp.int <- function(fit,
     interactionterms <- unlist(strsplit(intnames[cnt], "":""))
     labx <- c()
     # Label on y-axis is name of dependent variable
-    laby <- paste0(""Change in "", depvar.label)
+    laby <- paste0(""Change in "", git[[""depvar.label""]])
     # -----------------------------------------------------------
     # find estimates (beta values) for each single predictor of
     # the interaction as well as of the interaction term
@@ -611,7 +529,7 @@ sjp.int <- function(fit,
     # check whether each predictor was included in the model
     # as single term as well
     # -----------------------------------------------------------
-    if(is.na(b1) || is.na(b2) || is.na(b3)) {
+    if (is.na(b1) || is.na(b2) || is.na(b3)) {
       stop(""Predictors of interaction terms (main effects) must be included as single term as well. See Note in ?sjp.int"", call. = FALSE)
     }
     # -----------------------------------------------------------
@@ -698,7 +616,7 @@ sjp.int <- function(fit,
       ymax <- qu[4]
     }
     # intercept of predictor's reference category
-    est_b <- b2 + b0
+    est_b <- b.pred + b0
     # -----------------------------------------------------------
     # Create data frame for plotting the interactions by
     # manually calculating the linear regression by inserting
@@ -719,18 +637,18 @@ sjp.int <- function(fit,
     # ------------------------------
     maxy <- (b0 + (b.pred * pred.value) + (b3 * pred.value * ymax))
     # store in df
-    tmp <- as.data.frame(cbind(x = pred.value, 
-                               y = miny, 
-                               ymin = miny, 
-                               ymax = maxy, 
-                               grp = ""min""))
+    tmp <- data.frame(x = pred.value, 
+                      y = miny, 
+                      ymin = miny, 
+                      ymax = maxy, 
+                      grp = ""min"")
     intdf <- as.data.frame(rbind(intdf, tmp))
     # store in df
-    tmp <- as.data.frame(cbind(x = pred.value, 
-                               y = maxy, 
-                               ymin = miny, 
-                               ymax = maxy, 
-                               grp = ""max""))
+    tmp <- data.frame(x = pred.value, 
+                      y = maxy, 
+                      ymin = miny, 
+                      ymax = maxy, 
+                      grp = ""max"")
     intdf <- as.data.frame(rbind(intdf, tmp))
     # store in df
     if (moderatorValues == ""meansd"" || moderatorValues == ""quart"") {
@@ -740,11 +658,11 @@ sjp.int <- function(fit,
       # predictor 2 only is not needed. see references above
       # ------------------------------
       mittelwert <- (b0 + (b.pred * pred.value) + (b3 * pred.value * mw))
-      tmp <- as.data.frame(cbind(x = pred.value, 
-                                 y = mittelwert, 
-                                 ymin = miny, 
-                                 ymax = maxy, 
-                                 grp = ""mean""))
+      tmp <- data.frame(x = pred.value, 
+                        y = mittelwert, 
+                        ymin = miny, 
+                        ymax = maxy, 
+                        grp = ""mean"")
       intdf <- as.data.frame(rbind(intdf, tmp))
     }
     # -----------------------------------------------------------
@@ -811,8 +729,8 @@ sjp.int <- function(fit,
     # check whether user defined grid breaks / tick marks are used
     # -----------------------------------------------------------
     if (!is.null(gridBreaksAt)) {
-      gridbreaks.x <- c(seq(lowerLim.x, upperLim.x, by=gridBreaksAt))
-      gridbreaks.y <- c(seq(lowerLim.y, upperLim.y, by=gridBreaksAt))
+      gridbreaks.x <- c(seq(lowerLim.x, upperLim.x, by = gridBreaksAt))
+      gridbreaks.y <- c(seq(lowerLim.y, upperLim.y, by = gridBreaksAt))
     }
     # -----------------------------------------------------------
     # prepare plot title and axis titles
@@ -822,7 +740,7 @@ sjp.int <- function(fit,
                          interactionterms[ifelse(useFirstPredOnY == TRUE, 1, 2)],
                          "" (by "",
                          interactionterms[ifelse(useFirstPredOnY == TRUE, 2, 1)],
-                         "") on "", depvar.label)
+                         "") on "", git[[""depvar.label""]])
     } else {
       # copy plot counter 
       l_nr <- cnt
@@ -995,7 +913,7 @@ sjp.int <- function(fit,
     # ---------------------------------------------------------
     # facet grids?
     # ---------------------------------------------------------
-    if (facet.grid && !diff) baseplot <- baseplot + facet_grid( ~ grp)
+    if (facet.grid && !diff) baseplot <- baseplot + facet_grid(~grp)
     # ---------------------------------------------------------
     # set geom colors
     # ---------------------------------------------------------
@@ -1011,13 +929,14 @@ sjp.int <- function(fit,
   # -------------------------------------
   # return results
   # -------------------------------------
-  invisible (structure(class = ""sjpint"",
-                       list(plot.list = plotlist,
-                            df.list = dflist)))
+  invisible(structure(class = ""sjpint"",
+                      list(plot.list = plotlist,
+                           df.list = dflist)))
 }
 
 
 sjp.eff.int <- function(fit,
+                        int.term = NULL,
                         int.plot.index=NULL,
                         moderatorValues=""minmax"",
                         swapPredictors=FALSE,
@@ -1049,10 +968,7 @@ sjp.eff.int <- function(fit,
   # gridbreaks
   if (is.null(gridBreaksAt)) gridbreaks.x <- gridbreaks.y <- waiver()
   # ------------------------
-  # calculate effects of higher order terms
-  # ------------------------
-  eff <- effects::allEffects(fit, KR = F)
-  # ------------------------
+  # calculate effects of higher order terms and
   # check if fitted model contains any interaction terms
   # allEffects returns a list, with all interaction effects 
   # (or higher order terms) as separate list element. each list
@@ -1061,15 +977,25 @@ sjp.eff.int <- function(fit,
   # So we just need to look at each 'term' attribute of each
   # list element and see if there is a ""*""...
   # ------------------------
-  int <- unlist(lapply(eff, function(x) grep(""*"", x['term'], fixed = T)))
+  if (is.null(int.term)) {
+    eff <- effects::allEffects(fit, KR = F)
+    int <- unlist(lapply(eff, function(x) grep(""*"", x['term'], fixed = T)))
+  } else {
+    eff <- effects::effect(int.term, fit, KR = F)
+    int <- grep(""*"", eff$term, fixed = T)
+  }
   if (length(int) == 0) {
     warning(""No interaction term found in fitted model..."", call. = FALSE)
     return(invisible(NULL))
   }
   # ------------------------
   # retrieve position of interaction terms in effects-object
   # ------------------------
-  intpos <- which(as.vector(sapply(eff, function(x) length(grep(""*"", x['term'], fixed = T)) > 0)) == T)
+  if (is.null(int.term)) {
+    intpos <- which(as.vector(sapply(eff, function(x) length(grep(""*"", x['term'], fixed = T)) > 0)) == T)
+  } else {
+    intpos <- 1
+  }
   # select only specific plots
   if (!is.null(int.plot.index) && !any(int.plot.index > length(intpos))) intpos <- intpos[int.plot.index]  
   # init vector that saves ggplot objects
@@ -1079,27 +1005,39 @@ sjp.eff.int <- function(fit,
   # iterate all interaction terms
   # -----------------------------------------------------------
   for (i in 1:length(intpos)) {
+    # -----------------------------------------------------------
+    # copy ""eff"" object, so we don't confuse with effect-return-
+    # value from single term and multiple terms
+    # -----------------------------------------------------------
+    if (is.null(int.term)) {
+      dummy.eff <- eff[[intpos[i]]]
+    } else {
+      dummy.eff <- eff
+    }
     # -----------------------------------------------------------
     # retrieve data frame
     # -----------------------------------------------------------
-    intdf <- data.frame(eff[[intpos[i]]])
+    intdf <- data.frame(dummy.eff)
     # -----------------------------------------------------------
     # save response, predictor and moderator names
     # -----------------------------------------------------------
     pred_x.name <- colnames(intdf)[ifelse(swapPredictors == TRUE, 1, 2)]
     moderator.name <- colnames(intdf)[ifelse(swapPredictors == TRUE, 2, 1)]
-    response.name <- eff[[i]]$response
+    response.name <- dummy.eff$response
     # prepare axis titles
     labx <- pred_x.name
     # check whether x-axis-predictor is a factor or not
     x_is_factor <- is.factor(intdf[[pred_x.name]])
     # -----------------------------------------------------------
     # check for moderator values, but only, if moderator 
-    # is no factor value
+    # is no factor value. In this case, we can choose
+    # the values for continuous moderator intentionally,
+    # e.g. only min/max, or mean and sd. We don't need these
+    # values for categorical moderator values.
     # -----------------------------------------------------------
     if (!is.factor(intdf[[moderator.name]])) {
       # retrieve moderator value
-      modval <- eff[[intpos[i]]]$data[[moderator.name]]
+      modval <- dummy.eff$data[[moderator.name]]
       # -----------------------------------------------------------
       # Check whether moderator value has enough unique values
       # for quartiles
@@ -1133,10 +1071,17 @@ sjp.eff.int <- function(fit,
       }
       # change list name to moderator value name
       names(xl) <- moderator.name
-      # re-compute effects
-      eff.tmp <- effects::allEffects(fit, xlevels = xl, KR = F)
-      # reset data frame
-      intdf <- data.frame(eff.tmp[[intpos[i]]])
+      if (is.null(int.term)) {
+        # re-compute effects
+        eff.tmp <- effects::allEffects(fit, xlevels = xl, KR = F)
+        # reset data frame
+        intdf <- data.frame(eff.tmp[[intpos[i]]])
+      } else {
+        # re-compute effects
+        eff.tmp <- effects::effect(int.term, fit, xlevels = xl, KR = F)
+        # reset data frame
+        intdf <- data.frame(eff.tmp)
+      }
     }
     # -----------------------------------------------------------
     # change column names
@@ -1207,8 +1152,8 @@ sjp.eff.int <- function(fit,
     # check whether user defined grid breaks / tick marks are used
     # -----------------------------------------------------------
     if (!is.null(gridBreaksAt)) {
-      gridbreaks.x <- c(seq(lowerLim.x, upperLim.x, by=gridBreaksAt))
-      gridbreaks.y <- c(seq(lowerLim.y, upperLim.y, by=gridBreaksAt))
+      gridbreaks.x <- c(seq(lowerLim.x, upperLim.x, by = gridBreaksAt))
+      gridbreaks.y <- c(seq(lowerLim.y, upperLim.y, by = gridBreaksAt))
     }
     # -----------------------------------------------------------
     # prepare plot title and axis titles
@@ -1329,7 +1274,7 @@ sjp.eff.int <- function(fit,
     # ---------------------------------------------------------
     # facet grids?
     # ---------------------------------------------------------
-    if (facet.grid) baseplot <- baseplot + facet_grid( ~ grp)
+    if (facet.grid) baseplot <- baseplot + facet_grid(~grp)
     # ---------------------------------------------------------
     # set geom colors
     # ---------------------------------------------------------
@@ -1349,9 +1294,9 @@ sjp.eff.int <- function(fit,
   # -------------------------------------
   # return results
   # -------------------------------------
-  invisible (structure(class = ""sjpint"",
-                       list(plot.list = plotlist,
-                            df.list = dflist)))
+  invisible(structure(class = ""sjpint"",
+                      list(plot.list = plotlist,
+                           df.list = dflist)))
 }
 
 
@@ -1362,5 +1307,134 @@ mv_check <- function(moderatorValues, x) {
     message(""Could not compute quartiles, too small range of moderator variable. Defaulting 'moderatorValues' to 'minmax'."")
     moderatorValues <- ""minmax""
   }
-  return (moderatorValues)
+  return(moderatorValues)
+}
+
+
+# get all (significant) interaction terms from model
+# the function ""getInteractionTerms"" checks if a fitted
+# model contains any interaction terms that are significant
+# at the level specified by ""plevel"". returns NULL, if model
+# contains no interaction terms or no significant interaction term.
+# else, information on model and interaction terms is returned
+getInteractionTerms <- function(fit, fun, plevel) {
+  # -----------------------------------------------------------
+  # retrieve coefficients
+  # -----------------------------------------------------------
+  coef.tab <- summary(fit)$coefficients
+  pval <- rep(0, times = nrow(coef.tab) - 1)
+  # -----------------------------------------------------------
+  # Help-function that removes AsIS I from formulas.
+  # If someone know regular expressions better than me,
+  # please provide a one-liner solution for the 3 sub commands.
+  # -----------------------------------------------------------
+  remove_I <- function(xnames) {
+    fpos <- grep(""I("", xnames, fixed = T)
+    if (length(fpos) > 0 && fpos > 0) {
+      xnames <- sub(""I("", """", xnames, fixed = T)
+      xnames <- sub("")"", """", xnames, fixed = T)
+      xnames <- sub("" * "", "":"", xnames, fixed = T)
+    }
+    return(xnames)
+  }
+  # -----------------------------------------------------------
+  # prepare values for (generalized) linear models
+  # -----------------------------------------------------------
+  if (fun == ""lm"" || fun == ""glm"" || fun == ""plm"" || fun == ""lme"" || fun == ""gls"") {
+    # -----------------------------------------------------------
+    # retrieve amount and names of predictor variables and
+    # of dependent variable
+    # -----------------------------------------------------------
+    if (fun == ""plm"") {
+      # plm objects have different structure than (g)lm
+      depvar.label <- attr(attr(attr(fit$model, ""terms""), ""dataClasses""), ""names"")[1]
+      # retrieve model matrix
+      fitdat <- data.frame(cbind(as.vector(fit$model[, 1]), model.matrix(fit)))
+    } else {
+      depvar.label <- attr(attr(fit$terms, ""dataClasses""), ""names"")[1]
+      # retrieve model matrix
+      fitdat <- data.frame(model.matrix(fit))
+    }
+    # -----------------------------------------------------------
+    # retrieve p-values, without intercept
+    # -----------------------------------------------------------
+    if (ncol(coef.tab) > 3) pval <- coef.tab[-1, 4]
+    # -----------------------------------------------------------
+    # retrieve estimates, without intercept
+    # -----------------------------------------------------------
+    estimates <- coef.tab[-1, 1]
+    # -----------------------------------------------------------
+    # need to remove ""I(...)""?
+    # -----------------------------------------------------------
+    estimates.names <- names(estimates)
+    estimates.names <- remove_I(estimates.names)
+    it <- estimates.names
+    # -----------------------------------------------------------
+    # retrieve estimate of intercept
+    # -----------------------------------------------------------
+    b0 <- coef.tab[1, 1]
+    # -----------------------------------------------------------
+    # prepare values for (generalized) linear mixed effecrs models
+    # -----------------------------------------------------------
+  } else if (fun == ""lmer"" || fun == ""glmer"" || fun == ""nlmer"") {
+    # -----------------------------------------------------------
+    # retrieve amount and names of predictor variables and
+    # of dependent variable
+    # -----------------------------------------------------------
+    depvar.label <- colnames(fit@frame)[1]
+    # -----------------------------------------------------------
+    # retrieve p-values, without intercept
+    # -----------------------------------------------------------
+    pval <- get_lmerMod_pvalues(fit)[-1]
+    # -----------------------------------------------------------
+    # retrieve estimates, without intercept
+    # -----------------------------------------------------------
+    estimates <- unname(lme4::fixef(fit)[-1])
+    estimates.names <- names(lme4::fixef(fit)[-1])
+    # -----------------------------------------------------------
+    # retrieve model matrix with all relevant predictors
+    # -----------------------------------------------------------
+    fitdat <- model.matrix(fit)
+    # -----------------------------------------------------------
+    # need to remove ""I(...)""?
+    # -----------------------------------------------------------
+    estimates.names <- remove_I(estimates.names)
+    it <- estimates.names
+    # -----------------------------------------------------------
+    # retrieve estimate of intercept
+    # -----------------------------------------------------------
+    b0 <- unname(lme4::fixef(fit)[1])
+  } else {
+    stop(""Unsupported model-class. This type of regression is not yet supported by 'sjp.int'."", call. = F)
+  }
+  # -----------------------------------------------------------
+  # find all significant interactions
+  # we start looking for significant p-values beginning
+  # with the first interaction, not the first single term!
+  # thus, the starting point is first position after all single
+  # predictor variables
+  # -----------------------------------------------------------
+  # find interaction terms, which contains a colon, in row names
+  firstit <- grep("":"", it, fixed = TRUE)[1]
+  # check whether we have any interaction terms included at all
+  if (is.null(firstit) || is.na(firstit) || firstit == 0) {
+    warning(""No interaction term found in fitted model..."", call. = FALSE)
+    return(invisible(NULL))
+  }
+  # save names of interaction predictor variables into this object
+  intnames <- c()
+  for (i in firstit:length(pval)) {
+    if (pval[i] < plevel) intnames <- c(intnames, it[i])
+  }
+  # check for any signigicant interactions, stop if nothing found
+  if (is.null(intnames)) {
+    warning(""No significant interactions found... Try to adjust 'plevel'-parameter."", call. = FALSE)
+    return(invisible(NULL))
+  }
+  return(list(intnames = intnames,
+              estimates = estimates,
+              estimates.names = estimates.names,
+              b0 = b0,
+              fitdat = fitdat,
+              depvar.label = depvar.label))
 }
\ No newline at end of file

---FILE: R/sjPlotLinreg.R---
@@ -75,7 +75,7 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""vars"", ""Beta"", ""xv"", ""l
 #'          Default is 2, i.e. estimates have 2 digits after decimal point.
 #' @param showPValueLabels Whether the significance levels of each coefficient should be appended
 #'          to values or not
-#' @param showModelSummary If \code{TRUE} (default), a summary of the regression model with
+#' @param showModelSummary If \code{TRUE}, a summary of the regression model with
 #'          Intercept, R-square, F-Test and AIC-value is printed to the lower right corner
 #'          of the diagram.
 #' @param lineColor The color of the regression line. Default is \code{""blue""}.
@@ -212,7 +212,7 @@ sjp.lm <- function(fit,
                    showValueLabels=TRUE,
                    labelDigits=2,
                    showPValueLabels=TRUE,
-                   showModelSummary=TRUE,
+                   showModelSummary=FALSE,
                    lineColor=""blue"",
                    showCI=TRUE,
                    ciLevel=0.95,

---FILE: R/sjPlotOdds.R---
@@ -73,7 +73,7 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""OR"", ""lower"", ""upper"",
 #'          Default is 2, i.e. estimators have 2 digits after decimal point.
 #' @param showPValueLabels Whether the significance levels of each coefficient should be appended
 #'          to values or not.
-#' @param showModelSummary If \code{TRUE} (default), a summary of the regression model with
+#' @param showModelSummary If \code{TRUE}, a summary of the regression model with
 #'          Intercept, R-square, F-Test and AIC-value is printed to the lower right corner
 #'          of the diagram.
 #' @param show.se Use \code{TRUE} to plot (depending on \code{type}) the standard
@@ -125,14 +125,16 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""OR"", ""lower"", ""upper"",
 #' @details \describe{
 #'            \item{\code{type = ""prob""}}{(or \code{""pc""}), the predicted probabilities
 #'            are based on the intercept's estimate and each specific term's estimate.
-#'            All other co-variates are set to zero (i.e. ignored).}
+#'            All other co-variates are set to zero (i.e. ignored), which corresponds
+#'            to \code{\link{plogis}(b0 + bx * x)} (where \code{x} is the logit-estimate).}
 #'            \item{\code{type = ""probc""}}{(or \code{""pcc""}), the predicted probabilities
 #'            are based on the \code{\link{predict.glm}} method, where predicted values 
 #'            are ""centered""
-#'            (see \href{http://stats.stackexchange.com/questions/35682/contribution-of-each-covariate-to-a-single-prediction-in-a-logistic-regression-m#comment71993_35802}{CrossValidated}).}
+#'            (see \href{http://stats.stackexchange.com/questions/35682/contribution-of-each-covariate-to-a-single-prediction-in-a-logistic-regression-m#comment71993_35802}{CrossValidated}).
+#'            Corresponds to \code{\link{plogis}(\link{predict}(fit, type = ""terms""))}.}
 #'            \item{\code{type = ""y.pc""}}{(or \code{type = ""y.prob""}), the predicted values
 #'            of the response are computed, based on the \code{\link{predict.glm}}
-#'            method.}
+#'            method. Corresponds to \code{\link{plogis}(\link{predict}(fit, type = ""response""))}.}
 #'          }
 #'
 #' @examples
@@ -218,7 +220,7 @@ sjp.glm <- function(fit,
                     showValueLabels=TRUE,
                     labelDigits=2,
                     showPValueLabels=TRUE,
-                    showModelSummary=TRUE,
+                    showModelSummary=FALSE,
                     facet.grid = TRUE,
                     show.se = FALSE,
                     showOriginalModelOnly=TRUE,
@@ -228,7 +230,7 @@ sjp.glm <- function(fit,
   # --------------------------------------------------------
   if (any(class(fit) == ""logistf"")) {
     # no model summary currently supported for logistf class
-    showModelSummary = FALSE
+    showModelSummary <- FALSE
     # create ""dummy"" variable, to avoid errors
     fit$model <- fit$data
     # no probability curves currently supported

---FILE: R/sjPlotPropTable.R---
@@ -83,7 +83,7 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""Perc"", ""Sum"", ""Count"", ""
 #' @param stringTotal The string for the legend label when a total-column is added. Only applies
 #'          if \code{showTotalColumn} is \code{TRUE}. Default is \code{""Total""}.
 #' @param showCategoryLabels Whether x axis text (category names) should be shown or not.
-#' @param showTableSummary If \code{TRUE} (default), a summary of the cross tabulation with N, Chi-square (see \code{\link{chisq.test}}),
+#' @param showTableSummary If \code{TRUE}, a summary of the cross tabulation with N, Chi-square (see \code{\link{chisq.test}}),
 #'          df, Cramer's V or Phi-value and p-value is printed to the upper right corner of the diagram. If a cell contains expected 
 #'          values lower than five (or lower than 10 if df is 1),
 #'          the Fisher's excact test (see \code{\link{fisher.test}}) is computed instead of Chi-square test. 
@@ -124,6 +124,7 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""Perc"", ""Sum"", ""Count"", ""
 #' sjp.xtab(var, grp, 
 #'          tableIndex = ""row"", 
 #'          barPosition = ""stack"", 
+#'          showTableSummary = TRUE,
 #'          coord.flip = TRUE)
 #' 
 #' # example with vertical labels
@@ -135,7 +136,6 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""Perc"", ""Sum"", ""Count"", ""
 #' update_geom_defaults('text', list(hjust = -0.1))
 #' sjp.xtab(efc$e42dep, 
 #'          efc$e16sex,
-#'          showTableSummary = FALSE,
 #'          labelPos = ""center"")
 #' 
 #' # grouped bars with EUROFAMCARE sample dataset
@@ -210,7 +210,7 @@ sjp.xtab <- function(var,
                     showCountValues=TRUE,
                     showPercentageValues=TRUE,
                     showCategoryLabels=TRUE,
-                    showTableSummary=TRUE,
+                    showTableSummary=FALSE,
                     tableSummaryPos=""r"",
                     showTotalColumn=TRUE,
                     hideLegend=FALSE,

---FILE: R/sjPlotSetTheme.R---
@@ -143,9 +143,7 @@
 #' # legends of all plots inside
 #' sjp.setTheme(legend.pos = ""top left"", 
 #'              legend.inside = TRUE)
-#' sjp.xtab(efc$e42dep, 
-#'          efc$e16sex,
-#'          showTableSummary = FALSE)
+#' sjp.xtab(efc$e42dep, efc$e16sex)
 #' 
 #' # Use classic-theme. you may need to
 #' # load the ggplot2-library.
@@ -161,7 +159,6 @@
 #' update_geom_defaults('text', list(hjust = -0.1))
 #' sjp.xtab(efc$e42dep, 
 #'          efc$e16sex,
-#'          showTableSummary = FALSE,
 #'          labelPos = ""center"")
 #' 
 #' # Create own theme based on classic-theme

---FILE: R/sjTabFrequencies.R---
@@ -510,6 +510,7 @@ sjt.frq <- function(data,
     #---------------------------------------------------
     df.frq <- create.frq.df(var, 
                             valueLabels[[cnt]], 
+                            sjmisc::get_values(data[[cnt]]),
                             -1, 
                             sort.frq, 
                             weightBy = weightBy)

---FILE: README.md---
@@ -34,7 +34,12 @@ install.packages(""sjPlot"")
 
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since this package makes heavy use of the [ggplot-package](http://cran.r-project.org/web/packages/ggplot2/index.html), consider citing this package as well.
 
-### Changelog of development build 1.8.1-1
+### Changelog of development build 1.8.1-2
+
+#### Changes to functions:
+* Model and table summaries in plotting functions (like `sjp.lm` or `sjp.grpfrq`) are no longer printed by default. Use `showTableSummary = TRUE` or `showModelSummary = TRUE` to print summaries in plots.
+* Added parameter `int.term` to `sjp.int`, to plot selected interaction terms for `type = ""eff""` only. May be used in cases where effect computation takes too long or even crashes due to out-of-memory-problems.
 
 #### Bug fixes
 * `sjp.int` sometimes crashed with mixed models, due to slow Kenward-Roger-computation of standard errors, provided by the `effects`-package. Fixed, `KR`-parameter, when calling `allEffects`, now defaults to `FALSE`.
+* Fixed bug in `sjp.frq` and `sjt.frq`, where non-incremental levels in some cases were not displayed correctly.

---FILE: man/sjPlot-package.Rd---
@@ -34,8 +34,8 @@
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.8.1-1\cr
-Date: \tab 2015-05-31\cr
+Version: \tab 1.8.1-2\cr
+Date: \tab 2015-06-03\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjp.aov1.Rd---
@@ -11,7 +11,7 @@ sjp.aov1(depVar, grpVar, meansums = FALSE, type = ""dots"",
   errorBarColor = NULL, geom.colors = c(""#3366a0"", ""#aa3333""),
   geom.size = 3, breakTitleAt = 50, breakLabelsAt = 25,
   gridBreaksAt = NULL, expand.grid = FALSE, showValueLabels = TRUE,
-  labelDigits = 2, showPValueLabels = TRUE, showModelSummary = TRUE,
+  labelDigits = 2, showPValueLabels = TRUE, showModelSummary = FALSE,
   printPlot = TRUE)
 }
 \arguments{
@@ -97,7 +97,7 @@ Default is 2, i.e. estimators have 2 digits after decimal point.}
 \item{showPValueLabels}{Whether the significance levels of each category/group should be appended
 to values or not.}
 
-\item{showModelSummary}{If \code{TRUE} (default), a summary of the anova model with
+\item{showModelSummary}{If \code{TRUE}, a summary of the anova model with
 Sum of Squares between groups (ssb), Sum of Squares within groups (ssw), multiple and adjusted
 R-square and F-Test is printed to the lower right corner
 of the diagram. Default is \code{TRUE}.}
@@ -129,7 +129,8 @@ efc.var <- get_var_labels(efc)
 sjp.aov1(efc$c12hour,
          as.factor(efc$e42dep),
          axisLabels.y = efc.val['e42dep'],
-         axisTitle.x = efc.var[['c12hour']])
+         axisTitle.x = efc.var[['c12hour']],
+         showModelSummary = TRUE)
 
 # -------------------------------------------------
 # auto-detection of value labels and variable names
@@ -146,8 +147,7 @@ sjp.aov1(efc$c12hour,
          axisLabels.y = efc.val['c172code'],
          title = efc.var[['c12hour']],
          type = ""bars"",
-         geom.size = 0.5,
-         showModelSummary = FALSE)
+         geom.size = 0.5)
 }
 \seealso{
 \code{\link{sjt.grpmean}}

---FILE: man/sjp.frq.Rd---
@@ -4,8 +4,8 @@
 \alias{sjp.frq}
 \title{Plot frequencies of (count) variables}
 \usage{
-sjp.frq(varCount, type = ""bars"", title = """", weightBy = NULL,
-  weightByTitleString = NULL, interactionVar = NULL, sort.frq = ""none"",
+sjp.frq(varCount, title = """", weightBy = NULL, weightByTitleString = NULL,
+  interactionVar = NULL, sort.frq = ""none"", type = ""bars"",
   geom.size = 0.7, geom.colors = NULL, axisLabels.x = NULL,
   interactionVarLabels = NULL, axisLimits.y = NULL, breakTitleAt = 50,
   breakLabelsAt = 20, gridBreaksAt = NULL, innerBoxPlotWidth = 0.15,
@@ -25,17 +25,6 @@ sjp.frq(varCount, type = ""bars"", title = """", weightBy = NULL,
 \arguments{
 \item{varCount}{The variable which frequencies should be plotted.}
 
-\item{type}{Specifies the type of distribution plot that will be plotted.
-\describe{
-  \item{\code{""bar""}}{or \code{""bars""} or \code{""b""} for simple bars (the default setting)}
-  \item{\code{""dots""}}{or \code{""dot""} for a dot plot}
-  \item{\code{""h""}}{or \code{""hist""} or \code{""histogram""} for a histogram}
-  \item{\code{""line""}}{or \code{""lines""} or \code{""l""} for a histogram with filled area with line}
-  \item{\code{""dens""}}{or \code{""d""} or \code{""density""} for a density plot}
-  \item{\code{""box""}}{or \code{""boxplot""} or \code{""boxplots""} for box plots}
-  \item{\code{""v""}}{or \code{""violin""} for violin plots}
-  }}
-
 \item{title}{Title of diagram as string. Example: \code{title = ""my title""}.
 Use \code{NULL} to automatically detect variable names that will be used as title
 (see \code{\link[sjmisc]{set_var_labels}}) for details).}
@@ -55,6 +44,17 @@ is \code{""box""} or \code{""violin""} (resp. their alternative strings like \code{""
 Default is \code{""none""}, so categories are not sorted by frequency. Use \code{""asc""} or
 \code{""desc""} for sorting categories ascending or descending in relation to the frequencies.}
 
+\item{type}{Specifies the type of distribution plot that will be plotted.
+\describe{
+  \item{\code{""bar""}}{or \code{""bars""} or \code{""b""} for simple bars (the default setting)}
+  \item{\code{""dots""}}{or \code{""dot""} for a dot plot}
+  \item{\code{""h""}}{or \code{""hist""} or \code{""histogram""} for a histogram}
+  \item{\code{""line""}}{or \code{""lines""} or \code{""l""} for a histogram with filled area with line}
+  \item{\code{""dens""}}{or \code{""d""} or \code{""density""} for a density plot}
+  \item{\code{""box""}}{or \code{""boxplot""} or \code{""boxplots""} for box plots}
+  \item{\code{""v""}}{or \code{""violin""} for violin plots}
+  }}
+
 \item{geom.size}{size of geoms, depending on the plot \code{type}. Note that
 bar and bin widths mostly need smaller values than dot sizes (i.e. if \code{type = ""dots""}).}
 

---FILE: man/sjp.glm.Rd---
@@ -11,7 +11,7 @@ sjp.glm(fit, type = ""dots"", sortOdds = TRUE, title = NULL,
   hideErrorBars = FALSE, interceptLineType = 2,
   interceptLineColor = ""grey70"", coord.flip = TRUE, showIntercept = FALSE,
   showAxisLabels.y = TRUE, showValueLabels = TRUE, labelDigits = 2,
-  showPValueLabels = TRUE, showModelSummary = TRUE, facet.grid = TRUE,
+  showPValueLabels = TRUE, showModelSummary = FALSE, facet.grid = TRUE,
   show.se = FALSE, showOriginalModelOnly = TRUE, printPlot = TRUE)
 }
 \arguments{
@@ -95,7 +95,7 @@ Default is 2, i.e. estimators have 2 digits after decimal point.}
 \item{showPValueLabels}{Whether the significance levels of each coefficient should be appended
 to values or not.}
 
-\item{showModelSummary}{If \code{TRUE} (default), a summary of the regression model with
+\item{showModelSummary}{If \code{TRUE}, a summary of the regression model with
 Intercept, R-square, F-Test and AIC-value is printed to the lower right corner
 of the diagram.}
 
@@ -160,14 +160,16 @@ Plot odds ratios (exponentiated coefficients) with confidence intervalls as bar
 \describe{
            \item{\code{type = ""prob""}}{(or \code{""pc""}), the predicted probabilities
            are based on the intercept's estimate and each specific term's estimate.
-           All other co-variates are set to zero (i.e. ignored).}
+           All other co-variates are set to zero (i.e. ignored), which corresponds
+           to \code{\link{plogis}(b0 + bx * x)} (where \code{x} is the logit-estimate).}
            \item{\code{type = ""probc""}}{(or \code{""pcc""}), the predicted probabilities
            are based on the \code{\link{predict.glm}} method, where predicted values
            are ""centered""
-           (see \href{http://stats.stackexchange.com/questions/35682/contribution-of-each-covariate-to-a-single-prediction-in-a-logistic-regression-m#comment71993_35802}{CrossValidated}).}
+           (see \href{http://stats.stackexchange.com/questions/35682/contribution-of-each-covariate-to-a-single-prediction-in-a-logistic-regression-m#comment71993_35802}{CrossValidated}).
+           Corresponds to \code{\link{plogis}(\link{predict}(fit, type = ""terms""))}.}
            \item{\code{type = ""y.pc""}}{(or \code{type = ""y.prob""}), the predicted values
            of the response are computed, based on the \code{\link{predict.glm}}
-           method.}
+           method. Corresponds to \code{\link{plogis}(\link{predict}(fit, type = ""response""))}.}
          }
 }
 \note{

---FILE: man/sjp.glmer.Rd---
@@ -23,9 +23,9 @@ sjp.glmer(fit, type = ""re"", vars = NULL, ri.nr = NULL, emph.grp = NULL,
   \item{\code{""fe""}}{for odds ratios of fixed effects}
   \item{\code{""fe.cor""}}{for correlation matrix of fixed effects}
   \item{\code{""re.qq""}}{for a QQ-plot of random effects (random effects quantiles against standard normal quantiles)}
-  \item{\code{""fe.pc""}}{or \code{""fe.prob""} to plot probability curves (predicted probabilities) of all fixed effects coefficients. Use \code{facet.grid} to decide whether to plot each coefficient as separate plot or as integrated faceted plot.}
-  \item{\code{""ri.pc""}}{or \code{""ri.prob""} to plot probability curves (predicted probabilities) of random intercept variances for all fixed effects coefficients. Use \code{facet.grid} to decide whether to plot each coefficient as separate plot or as integrated faceted plot.}
-  \item{\code{""y.pc""}}{or \code{""y.prob""} to plot predicted probabilities for the response, with and without random effects. Use \code{facet.grid} to decide whether to plot with and w/o random effect plots as separate plot or as integrated faceted plot.}
+  \item{\code{""fe.pc""}}{or \code{""fe.prob""} to plot probability curves (predicted probabilities) of all fixed effects coefficients. Use \code{facet.grid} to decide whether to plot each coefficient as separate plot or as integrated faceted plot. See 'Details'.}
+  \item{\code{""ri.pc""}}{or \code{""ri.prob""} to plot probability curves (predicted probabilities) of random intercept variances for all fixed effects coefficients. Use \code{facet.grid} to decide whether to plot each coefficient as separate plot or as integrated faceted plot. See 'Details'.}
+  \item{\code{""y.pc""}}{or \code{""y.prob""} to plot predicted probabilities for the response, with and without random effects. Use \code{facet.grid} to decide whether to plot with and w/o random effect plots as separate plot or as integrated faceted plot. See 'Details'.}
 }}
 
 \item{vars}{a numeric vector with column indices of selected variables or a character vector with
@@ -126,6 +126,25 @@ Plot odds ratios (exponentiated coefficients) with confidence intervalls of eith
                (that have been fitted with \code{glmer} of the
                \code{lme4} package.
 }
+\details{
+\describe{
+           \item{\code{type = ""fe.pc""}}{(or \code{""fe.prob""}), the predicted probabilities
+           are based on the fixed effects intercept's estimate and each specific
+           fixed term's estimate. All other fixed effects are set to zero (i.e. ignored),
+           which corresponds to \code{\link{plogis}(b0 + bx * x)} (where \code{x}
+           is the logit-estimate of fixed effects and \code{b0} is the intercept of
+           the fixed effects).}
+           \item{\code{type = ""ri.pc""}}{(or \code{""ri.prob""}), the predicted probabilities
+           are based on the fixed effects intercept, plus each random intercept and
+           each specific  fixed term's estimate. All other fixed effects are set to zero (i.e. ignored),
+           which corresponds to \code{\link{plogis}(b0 + b0[r1-rn] + bx * x)} (where \code{x}
+           is the logit-estimate of fixed effects, \code{b0} is the intercept of
+           the fixed effects and \code{b0[r1-rn]} are all random intercepts).}
+           \item{\code{type = ""y.pc""}}{(or \code{type = ""y.prob""}), the predicted values
+           of the response are computed, based on the \code{predict.merMod}
+           method. Corresponds to \code{\link{plogis}(predict(fit, type = ""response""))}.}
+         }
+}
 \note{
 Thanks go to Robert Reijntjes from Leiden University Medical Center for sharing
         R code that is used to compute fixed effects correlation matrices and

---FILE: man/sjp.grpfrq.Rd---
@@ -17,7 +17,7 @@ sjp.grpfrq(varCount, varGroup, weightBy = NULL, weightByTitleString = NULL,
   showPercentageValues = TRUE, showAxisLabels.x = TRUE,
   showAxisLabels.y = TRUE, showPlotAnnotation = TRUE,
   showMeanIntercept = FALSE, showMeanValue = TRUE,
-  showStandardDeviation = FALSE, showTableSummary = TRUE,
+  showStandardDeviation = FALSE, showTableSummary = FALSE,
   showGroupCount = FALSE, tableSummaryPos = ""r"",
   meanInterceptLineType = 2, meanInterceptLineSize = 0.5,
   axisTitle.x = """", axisTitle.y = """", autoGroupAt = NULL,
@@ -156,7 +156,7 @@ of the count variables. Only applies to histogram-charts.}
 line. Only applies to histogram-charts. The shaded rectangles have borders in the group colors, so it's easier to see
 which shaded area belongs to which mean value resp. group}
 
-\item{showTableSummary}{If \code{TRUE} (default), a summary of the cross tabulation with N, Chi-square (see \code{\link{chisq.test}}),
+\item{showTableSummary}{If \code{TRUE}, a summary of the cross tabulation with N, Chi-square (see \code{\link{chisq.test}}),
 df, Cramer's V or Phi-value and p-value is printed to the upper right corner of the diagram. If a cell contains expected
 values lower than five (or lower than 10 if df is 1),
 the Fisher's excact test (see \code{\link{fisher.test}}) is computed instead of Chi-square test.

---FILE: man/sjp.int.Rd---
@@ -4,9 +4,9 @@
 \alias{sjp.int}
 \title{Plot interaction effects of (generalized) linear (mixed) models}
 \usage{
-sjp.int(fit, type = ""cond"", int.plot.index = NULL, diff = FALSE,
-  moderatorValues = ""minmax"", swapPredictors = FALSE, plevel = 0.05,
-  title = NULL, fillColor = ""grey"", fillAlpha = 0.3,
+sjp.int(fit, type = ""cond"", int.term = NULL, int.plot.index = NULL,
+  diff = FALSE, moderatorValues = ""minmax"", swapPredictors = FALSE,
+  plevel = 0.05, title = NULL, fillColor = ""grey"", fillAlpha = 0.3,
   geom.colors = ""Set1"", axisTitle.x = NULL, axisTitle.y = NULL,
   axisLabels.x = NULL, legendTitle = NULL, legendLabels = NULL,
   showValueLabels = FALSE, breakTitleAt = 50, breakLegendLabelsAt = 20,
@@ -26,6 +26,7 @@ classes are
   \item generalized linear models (\code{\link{glm}})
   \item linear mixed effects models (\code{\link[lme4]{lmer}})
   \item generalized linear mixed effects models (\code{\link[lme4]{glmer}})
+  \item non-linear mixed effects models (\code{\link[lme4]{nlmer}})
   \item linear mixed effects models (\code{\link[nlme]{lme}}, but only for \code{type = ""eff""})
   \item generalized least squares models (\code{\link[nlme]{gls}}, but only for \code{type = ""eff""})
   \item panel data estimators (\code{plm})
@@ -38,6 +39,10 @@ classes are
   \item{\code{type = ""emm""}}{plots the estimated marginal means (least square means). If this type is chosen, not all function parameters are applicable. See 'Details'.}
 }}
 
+\item{int.term}{select interaction term of \code{fit} (as character), which should be plotted
+when using \code{type = ""eff""}. By default, this parameter can be ignored
+(i.e. \code{int.term = NULL}). See 'Details'.}
+
 \item{int.plot.index}{A numeric vector with index numbers that indicate which
 interaction terms should be plotted in case the \code{fit} has more than
 one interaction. By default, this values is \code{NULL}, hence all interactions
@@ -170,6 +175,7 @@ Plot regression (predicted values) or probability lines (predicted probabilities
                  \item generalized linear models (\code{\link{glm}})
                  \item linear mixed effects models (\code{\link[lme4]{lmer}})
                  \item generalized linear mixed effects models (\code{\link[lme4]{glmer}})
+                 \item non-linear mixed effects models (\code{\link[lme4]{nlmer}})
                  \item linear mixed effects models (\code{\link[nlme]{lme}}, but only for \code{type = ""eff""})
                  \item generalized least squares models (\code{\link[nlme]{gls}}, but only for \code{type = ""eff""})
                  \item panel data estimators (\code{plm})
@@ -207,10 +213,17 @@ Plot regression (predicted values) or probability lines (predicted probabilities
              to plot differences in interventions between control and treatment groups over multiple time points.
              \itemize{
                \item Following paramters apply to this plot type: \code{showCI}, \code{valueLabel.digits} and \code{axisLabels.x}.
-               \item Following parameters \emph{do not} apply to this function: \code{int.plot.index}, \code{diff}, \code{moderatorValues}, \code{fillColor}, \code{fillAlpha}, \code{interceptLineColor}, \code{estLineColor}, \code{lineLabelSize}, \code{lineLabelColor} and \code{lineLabelString}.
+               \item Following parameters \emph{do not} apply to this function: \code{int.term}, \code{int.plot.index}, \code{diff}, \code{moderatorValues}, \code{fillColor}, \code{fillAlpha}, \code{interceptLineColor}, \code{estLineColor}, \code{lineLabelSize}, \code{lineLabelColor} and \code{lineLabelString}.
              }
            }
          }
+         The parameter \code{int.term} only applies to \code{type = ""eff""} and can be used
+         to select a specific interaction term of the model that should be plotted. The function
+         then calls \code{effect(int.term, fit)} to compute effects for this specific interaction
+         term only. This approach is recommended, when the fitted model contains many observations
+         and/or variables, which may slow down the effect-computation dramatically. In such cases,
+         consider computing effects for selected interaction terms only with \code{int.terms}.
+         See 'Examples'.
 }
 \note{
 Note that beside interaction terms, also the single predictors of each interaction (main effects)
@@ -264,6 +277,10 @@ sjp.int(fit, type = ""eff"")
 # sensivity
 sjp.int(fit, type = ""cond"")
 
+# plot only selected interaction term for
+# type = ""eff""
+sjp.int(fit, type = ""eff"", int.term = ""sex*education"")
+
 # plot interactions, using mean and sd as moderator
 # values to calculate interaction effect
 sjp.int(fit, type = ""eff"", moderatorValues = ""meansd"")

---FILE: man/sjp.lm.Rd---
@@ -10,7 +10,7 @@ sjp.lm(fit, type = ""lm"", sort.est = TRUE, title = NULL,
   geom.size = 3, interceptLineType = 2, interceptLineColor = ""grey70"",
   breakTitleAt = 50, breakLabelsAt = 25, gridBreaksAt = NULL,
   coord.flip = TRUE, showValueLabels = TRUE, labelDigits = 2,
-  showPValueLabels = TRUE, showModelSummary = TRUE, lineColor = ""blue"",
+  showPValueLabels = TRUE, showModelSummary = FALSE, lineColor = ""blue"",
   showCI = TRUE, ciLevel = 0.95, pointAlpha = 0.2, pointColor = ""black"",
   showScatterPlot = TRUE, showLoess = FALSE, loessLineColor = ""red"",
   showLoessCI = FALSE, loessCiLevel = 0.95, useResiduals = FALSE,
@@ -93,7 +93,7 @@ Default is 2, i.e. estimates have 2 digits after decimal point.}
 \item{showPValueLabels}{Whether the significance levels of each coefficient should be appended
 to values or not}
 
-\item{showModelSummary}{If \code{TRUE} (default), a summary of the regression model with
+\item{showModelSummary}{If \code{TRUE}, a summary of the regression model with
 Intercept, R-square, F-Test and AIC-value is printed to the lower right corner
 of the diagram.}
 

---FILE: man/sjp.setTheme.Rd---
@@ -225,9 +225,7 @@ sjp.setTheme()
 # legends of all plots inside
 sjp.setTheme(legend.pos = ""top left"",
              legend.inside = TRUE)
-sjp.xtab(efc$e42dep,
-         efc$e16sex,
-         showTableSummary = FALSE)
+sjp.xtab(efc$e42dep, efc$e16sex)
 
 # Use classic-theme. you may need to
 # load the ggplot2-library.
@@ -243,7 +241,6 @@ sjp.setTheme(geom.label.size = 3.5,
 update_geom_defaults('text', list(hjust = -0.1))
 sjp.xtab(efc$e42dep,
          efc$e16sex,
-         showTableSummary = FALSE,
          labelPos = ""center"")
 
 # Create own theme based on classic-theme

---FILE: man/sjp.xtab.Rd---
@@ -14,7 +14,7 @@ sjp.xtab(var, grp, title = """", legendTitle = NULL, weightBy = NULL,
   lineDotSize = 3, smoothLines = FALSE, expand.grid = FALSE,
   showValueLabels = TRUE, jitterValueLabels = FALSE,
   showCountValues = TRUE, showPercentageValues = TRUE,
-  showCategoryLabels = TRUE, showTableSummary = TRUE,
+  showCategoryLabels = TRUE, showTableSummary = FALSE,
   tableSummaryPos = ""r"", showTotalColumn = TRUE, hideLegend = FALSE,
   axisTitle.x = NULL, axisTitle.y = NULL, coord.flip = FALSE,
   printPlot = TRUE)
@@ -121,7 +121,7 @@ percentage-values are removed.}
 
 \item{showCategoryLabels}{Whether x axis text (category names) should be shown or not.}
 
-\item{showTableSummary}{If \code{TRUE} (default), a summary of the cross tabulation with N, Chi-square (see \code{\link{chisq.test}}),
+\item{showTableSummary}{If \code{TRUE}, a summary of the cross tabulation with N, Chi-square (see \code{\link{chisq.test}}),
 df, Cramer's V or Phi-value and p-value is printed to the upper right corner of the diagram. If a cell contains expected
 values lower than five (or lower than 10 if df is 1),
 the Fisher's excact test (see \code{\link{fisher.test}}) is computed instead of Chi-square test.
@@ -176,6 +176,7 @@ sjp.xtab(var, grp,
 sjp.xtab(var, grp,
          tableIndex = ""row"",
          barPosition = ""stack"",
+         showTableSummary = TRUE,
          coord.flip = TRUE)
 
 # example with vertical labels
@@ -187,7 +188,6 @@ library(ggplot2)
 update_geom_defaults('text', list(hjust = -0.1))
 sjp.xtab(efc$e42dep,
          efc$e16sex,
-         showTableSummary = FALSE,
          labelPos = ""center"")
 
 # grouped bars with EUROFAMCARE sample dataset"
strengejacke,sjPlot,d1bbffa9dc70bde9e5862c7a9e2bec999cca69e7,Daniel Ldecke,d.luedecke@uke.de,2015-05-30T19:13:35Z,Daniel Ldecke,d.luedecke@uke.de,2015-05-30T19:13:35Z,fix sjt.lmer-issue within knitr,R/sjPlotInteractions.R;R/sjTabLinReg.R,False,True,True,False,8,2,10,"---FILE: R/sjPlotInteractions.R---
@@ -1054,11 +1054,17 @@ sjp.eff.int <- function(fit,
   eff <- effects::allEffects(fit)
   # ------------------------
   # check if fitted model contains any interaction terms
+  # allEffects returns a list, with all interaction effects 
+  # (or higher order terms) as separate list element. each list
+  # element contains the higher-order-term of the fitted model,
+  # where the 'term' attribute of interaction terms have a ""*"". 
+  # So we just need to look at each 'term' attribute of each
+  # list element and see if there is a ""*""...
   # ------------------------
   int <- unlist(lapply(eff, function(x) grep(""*"", x['term'], fixed = T)))
   if (length(int) == 0) {
     warning(""No interaction term found in fitted model..."", call. = FALSE)
-    return (invisible (NULL))
+    return(invisible(NULL))
   }
   # ------------------------
   # retrieve position of interaction terms in effects-object

---FILE: R/sjTabLinReg.R---
@@ -1183,7 +1183,7 @@ sjt.lm <- function (...,
           # does model have enough icc values?
           # if yes, print
           if (length(sub.summary.icc) >= si) {
-            sum.icc.str <- paste0(sprintf(""    %.*f"", digits.summary, sub.summary.icc[si]), collapse = """")
+            sum.icc.str <- paste0(sprintf(""%.*f"", digits.summary, sub.summary.icc[si]), collapse = """")
             page.content <- paste0(page.content, colspanstring, sum.icc.str, ""</td>\n"")
           } else {
             page.content <- paste0(page.content, colspanstring, ""&nbsp;</td>\n"")"
strengejacke,sjPlot,30d2b115530e075ff10a7905deb26b77b925e994,Daniel Ldecke,d.luedecke@uke.de,2015-05-19T18:15:30Z,Daniel Ldecke,d.luedecke@uke.de,2015-05-19T18:15:30Z,"fixed bug in sjt.frq, revamped docs in sjt/sjp.corr",DESCRIPTION;NEWS;R/helpfunctions.R;R/sjPlotCorr.R;R/sjPlotLinreg.R;R/sjTabCorr.R;R/sjTabFrequencies.R;R/sjTabLinReg.R;README.md;man/sjPlot-package.Rd;man/sjp.corr.Rd;man/sjp.lm.Rd;man/sjt.corr.Rd;man/sjt.frq.Rd,False,True,True,False,221,139,360,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.8-8
-Date: 2015-05-15
+Version: 1.8-9
+Date: 2015-05-19
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of several plotting and table output functions for visualizing data.

---FILE: NEWS---
@@ -1,4 +1,4 @@
-Version 1.8-8
+Version 1.8-9
 ------------------------------------------------------------------------------
 General:
 * Deprecated function ""sjp.emm.int"" was removed. Use ""sjp.int"" with parameter ""type = 'emm'"" to plot estimated marginal means.
@@ -22,6 +22,7 @@ Bug fixes:
 * Fixed formatting bug for pseudo-R2 in ""sjt.glm"".
 * Fixed bug in ""sjp.likert"" when data frame had only one column.
 * Fixed bug in ""sjt.frq"" when a data frame contained variables with only NA values.
+* Fixed bugs in ""sjt.frq"" with weighted variables.
 
 Version 1.8
 ------------------------------------------------------------------------------

---FILE: R/helpfunctions.R---
@@ -419,15 +419,17 @@ retrieveModelGroupIndices <- function(models, rem_rows = NULL) {
       if (!any.found) break
     }
   }
-  return (list(group.pred.rows,
-               group.pred.span,
-               group.pred.labs))
+  return(list(group.pred.rows,
+              group.pred.span,
+              group.pred.labs))
 }
 
 
 # automatically retrieve predictor labels
 # of fitted (g)lm
 retrieveModelLabels <- function(models) {
+  # check parameter. No labels supported for plm-objects
+  if (any(class(fit) == ""plm"")) return(NULL)
   # do we have global options?
   opt <- getOption(""autoSetVariableLabels"")
   if (is.null(opt) || opt == TRUE) {
@@ -470,9 +472,9 @@ retrieveModelLabels <- function(models) {
         }
       }
     }
-    return (fit.labels)
+    return(fit.labels)
   }
-  return (NULL)
+  return(NULL)
 }
 
 

---FILE: R/sjPlotCorr.R---
@@ -61,18 +61,24 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""ordx"", ""ordy""))
 #'           was used for setting up the ggplot-object (\code{df}) and the original correlation matrix
 #'           (\code{corr.matrix}).
 #'
-#' @note If \code{data} is a \code{\link{cor}}-object, p-values can't be computed.
-#'       Thus, \code{showPValues} only has an effect if \code{data} is a \code{\link{data.frame}}.
+#' @note If \code{data} is a matrix with correlation coefficients as returned by 
+#'       the \code{\link{cor}}-function, p-values can't be computed.
+#'       Thus, \code{showPValues} and \code{pvaluesAsNumbers}
+#'       only have an effect if \code{data} is a \code{\link{data.frame}}.
 #'
 #' @examples
 #' # create data frame with 5 random variables
-#' df <- data.frame(cbind(rnorm(10), rnorm(10), rnorm(10), rnorm(10), rnorm(10)))
+#' mydf <- data.frame(cbind(runif(10), 
+#'                          runif(10), 
+#'                          runif(10), 
+#'                          runif(10), 
+#'                          runif(10)))
 #'
 #' # plot correlation matrix using circles
-#' sjp.corr(df)
+#' sjp.corr(mydf)
 #'
 #' # plot correlation matrix using square tiles without diagram background
-#' sjp.corr(df, type = ""tile"")
+#' sjp.corr(mydf, type = ""tile"")
 #'
 #'
 #' # -------------------------------
@@ -86,11 +92,11 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""ordx"", ""ordy""))
 #'
 #' # create data frame
 #' vars.index <- c(1, 4, 15, 19, 20, 21, 22, 24, 25)
-#' df <- data.frame(efc[, vars.index])
-#' colnames(df) <- varlabs[vars.index]
+#' mydf <- data.frame(efc[, vars.index])
+#' colnames(mydf) <- varlabs[vars.index]
 #'
 #' # show legend
-#' sjp.corr(df, type = ""tile"", hideLegend = FALSE)
+#' sjp.corr(mydf, type = ""tile"", hideLegend = FALSE)
 #'
 #' # -------------------------------
 #' # auto-detection of labels

---FILE: R/sjPlotLinreg.R---
@@ -170,6 +170,8 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""vars"", ""Beta"", ""xv"", ""l
 #' # plotting regression lines of each single predictor
 #' # of a fitted model
 #' # --------------------------------------------------
+#' library(sjmisc)
+#' data(efc)
 #' # fit model
 #' fit <- lm(tot_sc_e ~ c12hour + e17age + e42dep, data=efc)
 #'

---FILE: R/sjTabCorr.R---
@@ -74,8 +74,10 @@
 #'            }
 #'            for further use.
 #'
-#' @note If \code{data} is a \code{\link{cor}}-object, p-values can't be computed.
-#'       Thus, \code{showPValues} only has an effect if \code{data} is a \code{\link{data.frame}}.
+#' @note If \code{data} is a matrix with correlation coefficients as returned by 
+#'       the \code{\link{cor}}-function, p-values can't be computed.
+#'       Thus, \code{showPValues}, \code{pvaluesAsNumbers} and \code{fadeNS}
+#'       only have an effect if \code{data} is a \code{\link{data.frame}}.
 #'       \cr \cr
 #'       Additionally, see 'Note' in \code{\link{sjt.frq}}.
 #'  
@@ -84,14 +86,14 @@
 #' @examples
 #' \dontrun{
 #' # create data frame with 5 random variables
-#' df <- as.data.frame(cbind(rnorm(10), 
-#'                           rnorm(10), 
-#'                           rnorm(10), 
-#'                           rnorm(10), 
-#'                           rnorm(10)))
+#' mydf <- data.frame(cbind(runif(10), 
+#'                          runif(10), 
+#'                          runif(10), 
+#'                          runif(10), 
+#'                          runif(10)))
 #' 
 #' # plot correlation matrix using circles
-#' sjt.corr(df)
+#' sjt.corr(mydf)
 #' 
 #' # -------------------------------
 #' # Data from the EUROFAMCARE sample dataset

---FILE: R/sjTabFrequencies.R---
@@ -15,6 +15,9 @@
 #'          in the default web browser.
 #' @param weightBy A weight factor that will be applied to weight all cases from \code{data}.
 #'          Must be a vector of same length as \code{nrow(data)}. Default is \code{NULL}, so no weights are used.
+#' @param weightByTitleString If a weight factor is supplied via the parameter \code{weightBy}, the table caption
+#'          may indicate this with a remark. Default is \code{"" (weightBy)""}, so table captions
+#'          of weighted data will have an additional title suffix.
 #' @param variableLabels A single character vector or a list of character vectors that indicate
 #'          the variable names of those variables from \code{data} and will be used as variable labels
 #'          in the output. Note that if multiple variables
@@ -144,78 +147,87 @@
 #' 
 #' # plot and show frequency table of ""e42dep"" with labels
 #' sjt.frq(efc$e42dep,
-#'         variableLabels=variables['e42dep'],
-#'         valueLabels=values[['e42dep']])
+#'         variableLabels = variables['e42dep'],
+#'         valueLabels = values[['e42dep']])
 #' 
 #' # plot frequencies of e42dep, e16sex and c172code in one HTML file
 #' # and show table in RStudio Viewer Pane or default web browser
-#' sjt.frq(as.data.frame(cbind(efc$e42dep, efc$e16sex, efc$c172code)),
-#'         variableLabels=list(variables['e42dep'], variables['e16sex'], variables['c172code']),
-#'         valueLabels=list(values[['e42dep']], values[['e16sex']], values[['c172code']]))
+#' # Note that valueLabels of multiple variables have to be
+#' # list-objects
+#' sjt.frq(data.frame(efc$e42dep, efc$e16sex, efc$c172code),
+#'         variableLabels = c(variables['e42dep'], 
+#'                            variables['e16sex'], 
+#'                            variables['c172code']),
+#'         valueLabels = list(values[['e42dep']], 
+#'                            values[['e16sex']], 
+#'                            values[['c172code']]))
 #' 
-#' # plot larger scale including zero-counts
-#' # indicating median and quartiles
-#' sjt.frq(efc$neg_c_7,
-#'         variableLabels=variables['neg_c_7'],
-#'         valueLabels=values[['neg_c_7']],
-#'         highlightMedian=TRUE,
-#'         highlightQuartiles=TRUE)
 #' 
 #' # -------------------------------
 #' # auto-detection of labels
+#' # due to auto-detection of labels, this works as well
 #' # -------------------------------
-#' efc <- set_var_labels(efc, variables)
 #' sjt.frq(data.frame(efc$e42dep, efc$e16sex, efc$c172code))
 #' 
+#' 
+#' # plot larger scale including zero-counts
+#' # indicating median and quartiles
+#' sjt.frq(efc$neg_c_7,
+#'         variableLabels = variables['neg_c_7'],
+#'         valueLabels = values[['neg_c_7']],
+#'         highlightMedian = TRUE,
+#'         highlightQuartiles = TRUE)
+#' 
 #' # -------------------------------
 #' # sort frequencies
 #' # -------------------------------
-#' sjt.frq(efc$e42dep, sort.frq=""desc"")
+#' sjt.frq(efc$e42dep, sort.frq = ""desc"")
 #' 
 #' # -------------------------------- 
 #' # User defined style sheet
 #' # -------------------------------- 
 #' sjt.frq(efc$e42dep,
-#'         variableLabels=variables['e42dep'],
-#'         valueLabels=values[['e42dep']],
-#'         CSS=list(css.table=""border: 2px solid;"",
-#'                  css.tdata=""border: 1px solid;"",
-#'                  css.firsttablecol=""color:#003399; font-weight:bold;""))}
+#'         variableLabels = variables['e42dep'],
+#'         valueLabels = values[['e42dep']],
+#'         CSS = list(css.table = ""border: 2px solid;"",
+#'                    css.tdata = ""border: 1px solid;"",
+#'                    css.firsttablecol = ""color:#003399; font-weight:bold;""))}
 #' 
 #' @importFrom psych describe
 #' @import sjmisc
 #' @export
-sjt.frq <- function (data,
-                     file=NULL,
-                     weightBy=NULL,
-                     variableLabels=NULL,
-                     valueLabels=NULL,
-                     autoGroupAt=NULL,
-                     sort.frq=NULL,
-                     alternateRowColors=FALSE,
-                     stringValue=""value"",
-                     stringCount=""N"",
-                     stringPerc=""raw %"",
-                     stringValidPerc=""valid %"",
-                     stringCumPerc=""cumulative %"",
-                     stringMissingValue=""missings"",
-                     highlightMedian=FALSE,
-                     highlightQuartiles=FALSE,
-                     skipZeroRows=""auto"",
-                     showSummary=TRUE,
-                     showSkew=FALSE,
-                     showKurtosis=FALSE,
-                     skewString=""&gamma;"",
-                     kurtosisString=""&omega;"",
-                     digits=2,
-                     removeStringVectors=TRUE,
-                     autoGroupStrings=TRUE,
-                     maxStringDist=3,
-                     encoding=NULL,
-                     CSS=NULL,
-                     useViewer=TRUE,
-                     no.output=FALSE,
-                     remove.spaces=TRUE) {
+sjt.frq <- function(data,
+                    file=NULL,
+                    weightBy=NULL,
+                    weightByTitleString="" (weighted)"",
+                    variableLabels=NULL,
+                    valueLabels=NULL,
+                    autoGroupAt=NULL,
+                    sort.frq=NULL,
+                    alternateRowColors=FALSE,
+                    stringValue=""value"",
+                    stringCount=""N"",
+                    stringPerc=""raw %"",
+                    stringValidPerc=""valid %"",
+                    stringCumPerc=""cumulative %"",
+                    stringMissingValue=""missings"",
+                    highlightMedian=FALSE,
+                    highlightQuartiles=FALSE,
+                    skipZeroRows=""auto"",
+                    showSummary=TRUE,
+                    showSkew=FALSE,
+                    showKurtosis=FALSE,
+                    skewString=""&gamma;"",
+                    kurtosisString=""&omega;"",
+                    digits=2,
+                    removeStringVectors=TRUE,
+                    autoGroupStrings=TRUE,
+                    maxStringDist=3,
+                    encoding=NULL,
+                    CSS=NULL,
+                    useViewer=TRUE,
+                    no.output=FALSE,
+                    remove.spaces=TRUE) {
   # -------------------------------------
   # check encoding
   # -------------------------------------
@@ -267,20 +279,20 @@ sjt.frq <- function (data,
   # check user defined style sheets
   # ------------------------
   if (!is.null(CSS)) {
-    if (!is.null(CSS[['css.table']])) css.table <- ifelse(substring(CSS[['css.table']],1,1)=='+', paste0(css.table, substring(CSS[['css.table']],2)), CSS[['css.table']])
-    if (!is.null(CSS[['css.thead']])) css.thead <- ifelse(substring(CSS[['css.thead']],1,1)=='+', paste0(css.thead, substring(CSS[['css.thead']],2)), CSS[['css.thead']])
-    if (!is.null(CSS[['css.tdata']])) css.tdata <- ifelse(substring(CSS[['css.tdata']],1,1)=='+', paste0(css.tdata, substring(CSS[['css.tdata']],2)), CSS[['css.tdata']])
-    if (!is.null(CSS[['css.caption']])) css.caption <- ifelse(substring(CSS[['css.caption']],1,1)=='+', paste0(css.caption, substring(CSS[['css.caption']],2)), CSS[['css.caption']])
-    if (!is.null(CSS[['css.summary']])) css.summary <- ifelse(substring(CSS[['css.summary']],1,1)=='+', paste0(css.summary, substring(CSS[['css.summary']],2)), CSS[['css.summary']])
-    if (!is.null(CSS[['css.arc']])) css.arc <- ifelse(substring(CSS[['css.arc']],1,1)=='+', paste0(css.arc, substring(CSS[['css.arc']],2)), CSS[['css.arc']])
-    if (!is.null(CSS[['css.qrow']])) css.qrow <- ifelse(substring(CSS[['css.qrow']],1,1)=='+', paste0(css.qrow, substring(CSS[['css.qrow']],2)), CSS[['css.qrow']])
-    if (!is.null(CSS[['css.mdrow']])) css.mdrow <- ifelse(substring(CSS[['css.mdrow']],1,1)=='+', paste0(css.mdrow, substring(CSS[['css.mdrow']],2)), CSS[['css.mdrow']])
-    if (!is.null(CSS[['css.abstand']])) css.abstand <- ifelse(substring(CSS[['css.abstand']],1,1)=='+', paste0(css.abstand, substring(CSS[['css.abstand']],2)), CSS[['css.abstand']])
-    if (!is.null(CSS[['css.lasttablerow']])) css.lasttablerow <- ifelse(substring(CSS[['css.lasttablerow']],1,1)=='+', paste0(css.lasttablerow, substring(CSS[['css.lasttablerow']],2)), CSS[['css.lasttablerow']])
-    if (!is.null(CSS[['css.firsttablerow']])) css.firsttablerow <- ifelse(substring(CSS[['css.firsttablerow']],1,1)=='+', paste0(css.firsttablerow, substring(CSS[['css.firsttablerow']],2)), CSS[['css.firsttablerow']])
-    if (!is.null(CSS[['css.leftalign']])) css.leftalign <- ifelse(substring(CSS[['css.leftalign']],1,1)=='+', paste0(css.leftalign, substring(CSS[['css.leftalign']],2)), CSS[['css.leftalign']])
-    if (!is.null(CSS[['css.centeralign']])) css.centeralign <- ifelse(substring(CSS[['css.centeralign']],1,1)=='+', paste0(css.centeralign, substring(CSS[['css.centeralign']],2)), CSS[['css.centeralign']])
-    if (!is.null(CSS[['css.firsttablecol']])) css.firsttablecol <- ifelse(substring(CSS[['css.firsttablecol']],1,1)=='+', paste0(css.firsttablecol, substring(CSS[['css.firsttablecol']],2)), CSS[['css.firsttablecol']])
+    if (!is.null(CSS[['css.table']])) css.table <- ifelse(substring(CSS[['css.table']], 1, 1) == '+', paste0(css.table, substring(CSS[['css.table']], 2)), CSS[['css.table']])
+    if (!is.null(CSS[['css.thead']])) css.thead <- ifelse(substring(CSS[['css.thead']], 1, 1) == '+', paste0(css.thead, substring(CSS[['css.thead']], 2)), CSS[['css.thead']])
+    if (!is.null(CSS[['css.tdata']])) css.tdata <- ifelse(substring(CSS[['css.tdata']], 1, 1) == '+', paste0(css.tdata, substring(CSS[['css.tdata']], 2)), CSS[['css.tdata']])
+    if (!is.null(CSS[['css.caption']])) css.caption <- ifelse(substring(CSS[['css.caption']], 1, 1) == '+', paste0(css.caption, substring(CSS[['css.caption']], 2)), CSS[['css.caption']])
+    if (!is.null(CSS[['css.summary']])) css.summary <- ifelse(substring(CSS[['css.summary']], 1, 1) == '+', paste0(css.summary, substring(CSS[['css.summary']], 2)), CSS[['css.summary']])
+    if (!is.null(CSS[['css.arc']])) css.arc <- ifelse(substring(CSS[['css.arc']], 1, 1) == '+', paste0(css.arc, substring(CSS[['css.arc']], 2)), CSS[['css.arc']])
+    if (!is.null(CSS[['css.qrow']])) css.qrow <- ifelse(substring(CSS[['css.qrow']], 1, 1) == '+', paste0(css.qrow, substring(CSS[['css.qrow']], 2)), CSS[['css.qrow']])
+    if (!is.null(CSS[['css.mdrow']])) css.mdrow <- ifelse(substring(CSS[['css.mdrow']], 1, 1) == '+', paste0(css.mdrow, substring(CSS[['css.mdrow']], 2)), CSS[['css.mdrow']])
+    if (!is.null(CSS[['css.abstand']])) css.abstand <- ifelse(substring(CSS[['css.abstand']], 1, 1) == '+', paste0(css.abstand, substring(CSS[['css.abstand']], 2)), CSS[['css.abstand']])
+    if (!is.null(CSS[['css.lasttablerow']])) css.lasttablerow <- ifelse(substring(CSS[['css.lasttablerow']], 1, 1) == '+', paste0(css.lasttablerow, substring(CSS[['css.lasttablerow']], 2)), CSS[['css.lasttablerow']])
+    if (!is.null(CSS[['css.firsttablerow']])) css.firsttablerow <- ifelse(substring(CSS[['css.firsttablerow']], 1, 1) == '+', paste0(css.firsttablerow, substring(CSS[['css.firsttablerow']], 2)), CSS[['css.firsttablerow']])
+    if (!is.null(CSS[['css.leftalign']])) css.leftalign <- ifelse(substring(CSS[['css.leftalign']], 1, 1) == '+', paste0(css.leftalign, substring(CSS[['css.leftalign']], 2)), CSS[['css.leftalign']])
+    if (!is.null(CSS[['css.centeralign']])) css.centeralign <- ifelse(substring(CSS[['css.centeralign']], 1, 1) == '+', paste0(css.centeralign, substring(CSS[['css.centeralign']], 2)), CSS[['css.centeralign']])
+    if (!is.null(CSS[['css.firsttablecol']])) css.firsttablecol <- ifelse(substring(CSS[['css.firsttablecol']], 1, 1) == '+', paste0(css.firsttablecol, substring(CSS[['css.firsttablecol']], 2)), CSS[['css.firsttablecol']])
   }
   # -------------------------------------
   # set style sheet
@@ -347,7 +359,7 @@ sjt.frq <- function (data,
       # if yes, iterate each variable
       for (i in 1:ncol(data)) {
         # retrieve variable name attribute
-        vn <- sjmisc:::autoSetVariableLabels(data[,i])
+        vn <- sjmisc:::autoSetVariableLabels(data[[i]])
         # if variable has attribute, add to variableLabel list
         if (!is.null(vn)) {
           variableLabels <- c(variableLabels, vn)
@@ -426,7 +438,7 @@ sjt.frq <- function (data,
     # iterate all variables
     for (i in 1:nvar) {
       # retrieve variable
-      dummy <- data[, i]
+      dummy <- data[[i]]
       # usually, value labels are NULL if we have string vector. if so
       # set value labels according to values
       if (is.character(dummy)) {
@@ -460,12 +472,12 @@ sjt.frq <- function (data,
     # if requested. put data into a data frame
     #---------------------------------------------------
     # check if we have a string-vector
-    if (is.character(data[,cnt])) {
+    if (is.character(data[[cnt]])) {
       # convert string to numeric
-      orivar <- var <- as.numeric(as.factor(data[,cnt]))
+      orivar <- var <- as.numeric(as.factor(data[[cnt]]))
     # here we have numeric or factor variables
     } else {
-      orivar <- var <- as.numeric(data[,cnt])
+      orivar <- var <- as.numeric(data[[cnt]])
     }
     # -----------------------------------------------
     # check for length of unique values and skip if too long
@@ -529,6 +541,10 @@ sjt.frq <- function (data,
     # retrieve variable label
     # -------------------------------------
     varlab <- variableLabels[[cnt]]
+    # if we have weighted values, say that in diagram's title
+    if (!is.null(weightBy)) {
+      varlab <- paste(varlab, weightByTitleString, sep = """")
+    }
     # -------------------------------------
     # table caption, variable label
     # -------------------------------------
@@ -611,16 +627,23 @@ sjt.frq <- function (data,
     # add info for mean, standard deviation
     # -------------------------------------
     if (showSummary) {
-      vartot <- length(var)
-      varvalid <- vartot - length(var[which(is.na(var))])
+      # sum of frequencies is total N. Use these numbers
+      # instead of ""length(var)"", because weighted data
+      # has different N
+      vartot <- sum(df$frq, na.rm = T)
+      # last element in df$frq is amount of missings,
+      # so substract from total to get valid N
+      varvalid <- vartot - df$frq[nrow(df)]
       if (is.null(weightBy)) {
         mw <- mean(orivar, na.rm = TRUE)
+        sum_var <- orivar
       } else {
         mw <- weighted.mean(orivar, weightBy, na.rm = TRUE)
+        sum_var <- sjmisc::weight(orivar, weightBy)
       }
       descr <- """"
       if (showSkew || showKurtosis) {
-        pstat <- psych::describe(data.frame(orivar))
+        pstat <- psych::describe(data.frame(sum_var))
         if (showSkew) descr <- sprintf("" &middot; %s=%.*f"", 
                                        skewString, 
                                        digits,
@@ -637,7 +660,7 @@ sjt.frq <- function (data,
                                                   digits,
                                                   mw, 
                                                   digits,
-                                                  sd(orivar, na.rm = TRUE), 
+                                                  sd(sum_var, na.rm = TRUE), 
                                                   descr))
     }
     # -------------------------------------

---FILE: R/sjTabLinReg.R---
@@ -387,6 +387,17 @@ sjt.lm <- function (...,
   } else {
     p_zero <- ""0""
   }
+  # -----------------------------------------------------------
+  # check parameter. No model-summary supported for plm-objects
+  # -----------------------------------------------------------
+  if (any(class(fit) == ""plm"")) {
+    # -----------------------------------------------------------
+    # check package availability if fit is plm-object
+    # -----------------------------------------------------------
+    if (!""package:plm"" %in% search()) {
+      stop(""Package 'plm' needs to be loaded for this function to work... Use 'library(plm)' and call this function again."", call. = FALSE)
+    }
+  }
   # -------------------------------------
   # check parameter
   # -------------------------------------
@@ -1186,7 +1197,16 @@ sjt.lm <- function (...,
     # insert ""separator column""
     # -------------------------
     page.content <- paste0(page.content, ""<td class=\""separatorcol firstsumrow\"">&nbsp;</td>"")
-    page.content <- paste(page.content, sprintf(""   %s%i</td>\n"", colspanstringfirstrow, nobs(input_list[[i]])))
+    # -------------------------------------
+    # get number of observations
+    # -------------------------------------
+    if (any(class(fit) == ""plm"")) {
+      # ""plm"" seems not to offer a ""nobs"" function
+      n_of_obs <- nrow(input_list[[i]]$model)
+    } else {
+      n_of_obs <- nobs(input_list[[i]])
+    }
+    page.content <- paste(page.content, sprintf(""   %s%i</td>\n"", colspanstringfirstrow, n_of_obs))
   }
   page.content <- paste0(page.content, ""  </tr>\n"")
   # -------------------------------------

---FILE: README.md---
@@ -34,7 +34,7 @@ install.packages(""sjPlot"")
 
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since this package makes heavy use of the [ggplot-package](http://cran.r-project.org/web/packages/ggplot2/index.html), consider citing this package as well.
 
-### Changelog of current development snapshot 1.8-8
+### Changelog of current development snapshot 1.8-9
 
 #### General
 * Deprecated function `sjp.emm.int` was removed. Use `sjp.int` with parameter `type = 'emm'` to plot estimated marginal means.
@@ -58,3 +58,4 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 * Fixed formatting bug for pseudo-R2 in `sjt.glm`.
 * Fixed bug in `sjp.likert` when data frame had only one column.
 * Fixed bug in `sjt.frq` when a data frame contained variables with only NA values.
+* Fixed bugs in `sjt.frq` with weighted variables.

---FILE: man/sjPlot-package.Rd---
@@ -34,8 +34,8 @@
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.8-8\cr
-Date: \tab 2015-05-15\cr
+Version: \tab 1.8-9\cr
+Date: \tab 2015-05-19\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjp.corr.Rd---
@@ -79,24 +79,31 @@ want to plot any graphs. In either case, the ggplot-object will be returned as v
 }
 \description{
 Plot correlation matrix as ellipses or tiles. Required parameter is either
-               a data frame or a computed \code{\link{cor}}-object. In case of ellipses, the
+               a \code{\link{data.frame}} or a matrix with correlation coefficients
+               as returned by the \code{\link{cor}}-function. In case of ellipses, the
                ellipses size indicates the strength of the correlation. Furthermore,
                blue and red colors indicate positive or negative correlations, where
                stronger correlations are darker.
 }
 \note{
-If \code{data} is a \code{\link{cor}}-object, p-values can't be computed.
-      Thus, \code{showPValues} only has an effect if \code{data} is a \code{\link{data.frame}}.
+If \code{data} is a matrix with correlation coefficients as returned by
+      the \code{\link{cor}}-function, p-values can't be computed.
+      Thus, \code{showPValues} and \code{pvaluesAsNumbers}
+      only have an effect if \code{data} is a \code{\link{data.frame}}.
 }
 \examples{
 # create data frame with 5 random variables
-df <- data.frame(cbind(rnorm(10), rnorm(10), rnorm(10), rnorm(10), rnorm(10)))
+mydf <- data.frame(cbind(runif(10),
+                         runif(10),
+                         runif(10),
+                         runif(10),
+                         runif(10)))
 
 # plot correlation matrix using circles
-sjp.corr(df)
+sjp.corr(mydf)
 
 # plot correlation matrix using square tiles without diagram background
-sjp.corr(df, type = ""tile"")
+sjp.corr(mydf, type = ""tile"")
 
 
 # -------------------------------
@@ -110,11 +117,11 @@ varlabs <- get_var_labels(efc)
 
 # create data frame
 vars.index <- c(1, 4, 15, 19, 20, 21, 22, 24, 25)
-df <- data.frame(efc[, vars.index])
-colnames(df) <- varlabs[vars.index]
+mydf <- data.frame(efc[, vars.index])
+colnames(mydf) <- varlabs[vars.index]
 
 # show legend
-sjp.corr(df, type = ""tile"", hideLegend = FALSE)
+sjp.corr(mydf, type = ""tile"", hideLegend = FALSE)
 
 # -------------------------------
 # auto-detection of labels

---FILE: man/sjp.lm.Rd---
@@ -219,6 +219,8 @@ sjp.lm(fit,
 # plotting regression lines of each single predictor
 # of a fitted model
 # --------------------------------------------------
+library(sjmisc)
+data(efc)
 # fit model
 fit <- lm(tot_sc_e ~ c12hour + e17age + e42dep, data=efc)
 

---FILE: man/sjt.corr.Rd---
@@ -98,28 +98,31 @@ Invisibly returns
 }
 \description{
 Shows the results of a computed correlation as HTML table. Requires either
-               a data frame or a computed \code{\link{cor}}-object.
+               a \code{\link{data.frame}} or a matrix with correlation coefficients
+               as returned by the \code{\link{cor}}-function.
 }
 \details{
 See 'Details' in \code{\link{sjt.frq}}.
 }
 \note{
-If \code{data} is a \code{\link{cor}}-object, p-values can't be computed.
-      Thus, \code{showPValues} only has an effect if \code{data} is a \code{\link{data.frame}}.
+If \code{data} is a matrix with correlation coefficients as returned by
+      the \code{\link{cor}}-function, p-values can't be computed.
+      Thus, \code{showPValues}, \code{pvaluesAsNumbers} and \code{fadeNS}
+      only have an effect if \code{data} is a \code{\link{data.frame}}.
       \cr \cr
       Additionally, see 'Note' in \code{\link{sjt.frq}}.
 }
 \examples{
 \dontrun{
 # create data frame with 5 random variables
-df <- as.data.frame(cbind(rnorm(10),
-                          rnorm(10),
-                          rnorm(10),
-                          rnorm(10),
-                          rnorm(10)))
+mydf <- data.frame(cbind(runif(10),
+                         runif(10),
+                         runif(10),
+                         runif(10),
+                         runif(10)))
 
 # plot correlation matrix using circles
-sjt.corr(df)
+sjt.corr(mydf)
 
 # -------------------------------
 # Data from the EUROFAMCARE sample dataset

---FILE: man/sjt.frq.Rd---
@@ -4,7 +4,8 @@
 \alias{sjt.frq}
 \title{Show frequencies as HTML table}
 \usage{
-sjt.frq(data, file = NULL, weightBy = NULL, variableLabels = NULL,
+sjt.frq(data, file = NULL, weightBy = NULL,
+  weightByTitleString = "" (weighted)"", variableLabels = NULL,
   valueLabels = NULL, autoGroupAt = NULL, sort.frq = NULL,
   alternateRowColors = FALSE, stringValue = ""value"", stringCount = ""N"",
   stringPerc = ""raw \%"", stringValidPerc = ""valid \%"",
@@ -27,6 +28,10 @@ in the default web browser.}
 \item{weightBy}{A weight factor that will be applied to weight all cases from \code{data}.
 Must be a vector of same length as \code{nrow(data)}. Default is \code{NULL}, so no weights are used.}
 
+\item{weightByTitleString}{If a weight factor is supplied via the parameter \code{weightBy}, the table caption
+may indicate this with a remark. Default is \code{"" (weightBy)""}, so table captions
+of weighted data will have an additional title suffix.}
+
 \item{variableLabels}{A single character vector or a list of character vectors that indicate
 the variable names of those variables from \code{data} and will be used as variable labels
 in the output. Note that if multiple variables
@@ -190,43 +195,51 @@ sjt.frq(efc$e42dep)
 
 # plot and show frequency table of ""e42dep"" with labels
 sjt.frq(efc$e42dep,
-        variableLabels=variables['e42dep'],
-        valueLabels=values[['e42dep']])
+        variableLabels = variables['e42dep'],
+        valueLabels = values[['e42dep']])
 
 # plot frequencies of e42dep, e16sex and c172code in one HTML file
 # and show table in RStudio Viewer Pane or default web browser
-sjt.frq(as.data.frame(cbind(efc$e42dep, efc$e16sex, efc$c172code)),
-        variableLabels=list(variables['e42dep'], variables['e16sex'], variables['c172code']),
-        valueLabels=list(values[['e42dep']], values[['e16sex']], values[['c172code']]))
+# Note that valueLabels of multiple variables have to be
+# list-objects
+sjt.frq(data.frame(efc$e42dep, efc$e16sex, efc$c172code),
+        variableLabels = c(variables['e42dep'],
+                           variables['e16sex'],
+                           variables['c172code']),
+        valueLabels = list(values[['e42dep']],
+                           values[['e16sex']],
+                           values[['c172code']]))
 
-# plot larger scale including zero-counts
-# indicating median and quartiles
-sjt.frq(efc$neg_c_7,
-        variableLabels=variables['neg_c_7'],
-        valueLabels=values[['neg_c_7']],
-        highlightMedian=TRUE,
-        highlightQuartiles=TRUE)
 
 # -------------------------------
 # auto-detection of labels
+# due to auto-detection of labels, this works as well
 # -------------------------------
-efc <- set_var_labels(efc, variables)
 sjt.frq(data.frame(efc$e42dep, efc$e16sex, efc$c172code))
 
+
+# plot larger scale including zero-counts
+# indicating median and quartiles
+sjt.frq(efc$neg_c_7,
+        variableLabels = variables['neg_c_7'],
+        valueLabels = values[['neg_c_7']],
+        highlightMedian = TRUE,
+        highlightQuartiles = TRUE)
+
 # -------------------------------
 # sort frequencies
 # -------------------------------
-sjt.frq(efc$e42dep, sort.frq=""desc"")
+sjt.frq(efc$e42dep, sort.frq = ""desc"")
 
 # --------------------------------
 # User defined style sheet
 # --------------------------------
 sjt.frq(efc$e42dep,
-        variableLabels=variables['e42dep'],
-        valueLabels=values[['e42dep']],
-        CSS=list(css.table=""border: 2px solid;"",
-                 css.tdata=""border: 1px solid;"",
-                 css.firsttablecol=""color:#003399; font-weight:bold;""))}
+        variableLabels = variables['e42dep'],
+        valueLabels = values[['e42dep']],
+        CSS = list(css.table = ""border: 2px solid;"",
+                   css.tdata = ""border: 1px solid;"",
+                   css.firsttablecol = ""color:#003399; font-weight:bold;""))}
 }
 \seealso{
 \itemize{"
strengejacke,sjPlot,a73c3e993ecb3891c694d12e2d0f41858fc673bc,Daniel Ldecke,d.luedecke@uke.de,2015-05-15T19:07:26Z,Daniel Ldecke,d.luedecke@uke.de,2015-05-15T19:07:26Z,"minor bug fixed, typo docs",R/sjPlotCorr.R;R/sjPlotInteractions.R;R/sjPlotLinreg.R;man/sjp.chi2.Rd;man/sjp.frq.Rd;man/sjp.grpfrq.Rd;man/sjp.int.Rd;man/sjp.lm.Rd,False,True,True,False,11,11,22,"---FILE: R/sjPlotCorr.R---
@@ -164,7 +164,7 @@ sjp.corr <- function(data,
   # check if user has passed a data frame
   # or a pca object
   # ----------------------------
-  if (any(class(data)) == ""matrix"") {
+  if (any(class(data) == ""matrix"")) {
     corr <- data
     cpvalues <- NULL
   } else {

---FILE: R/sjPlotInteractions.R---
@@ -25,7 +25,7 @@
 #'                  \item generalized linear mixed effects models (\code{\link[lme4]{glmer}})
 #'                  \item linear mixed effects models (\code{\link[nlme]{lme}}, but only for \code{type = ""eff""})
 #'                  \item generalized least squares models (\code{\link[nlme]{gls}}, but only for \code{type = ""eff""})
-#'                  \item panel data estimators (\code{\link[plm]{plm}})
+#'                  \item panel data estimators (\code{plm})
 #'                }
 #'                Note that beside interaction terms, also the single predictors of each interaction (main effects)
 #'                must be included in the fitted model as well. Thus, \code{lm(dep ~ pred1 * pred2)} will work, 
@@ -40,7 +40,7 @@
 #'            \item generalized linear mixed effects models (\code{\link[lme4]{glmer}})
 #'            \item linear mixed effects models (\code{\link[nlme]{lme}}, but only for \code{type = ""eff""})
 #'            \item generalized least squares models (\code{\link[nlme]{gls}}, but only for \code{type = ""eff""})
-#'            \item panel data estimators (\code{\link[plm]{plm}})
+#'            \item panel data estimators (\code{plm})
 #'          }
 #' @param type interaction plot type. Use one of following values:
 #'          \itemize{

---FILE: R/sjPlotLinreg.R---
@@ -20,7 +20,7 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""vars"", ""Beta"", ""xv"", ""l
 #'            \item If \code{type = ""vif""}, the Variance Inflation Factors (check for multicollinearity) are plotted. As a rule of thumb, values below 5 are considered as good and indicate no multicollinearity, values between 5 and 10 may be tolerable. Values greater than 10 are not acceptable and indicate multicollinearity between model's predictors.
 #'            }
 #'
-#' @param fit fitted linear regression model (\code{\link{lm}}- or \code{\link[plm]{plm}}-object).
+#' @param fit fitted linear regression model (\code{\link{lm}}- or \code{plm}-object).
 #' @param type type of plot. Use one of following:
 #'          \describe{
 #'            \item{\code{""lm""}}{(default) for forest-plot like plot of estimates. If the fitted model only contains one predictor, intercept and slope are plotted.}

---FILE: man/sjp.chi2.Rd---
@@ -37,7 +37,7 @@ want to plot any graphs. In either case, the ggplot-object will be returned as v
           was used for setting up the ggplot-object (\code{mydf}).
 }
 \description{
-Plot p-values of Pearson's Chi2-tests for multiple contingency tables as ellipses or tiles.
+Plot Pearson's Chi2-Test of multiple contingency tables as ellipses or tiles.
                Requires a data frame with dichotomous (dummy) variables.
                Calculation of Chi2-matrix taken from
                \href{http://talesofr.wordpress.com/2013/05/05/ridiculously-photogenic-factors-heatmap-with-p-values/}{Tales of R}.

---FILE: man/sjp.frq.Rd---
@@ -61,14 +61,14 @@ bar and bin widths mostly need smaller values than dot sizes (i.e. if \code{type
 \item{geom.colors}{user defined color for geoms, e.g. \code{geom.colors = ""#0080ff""}.}
 
 \item{axisLabels.x}{Labels for the x-axis breaks.
-Example: \code{axisLabels.x = c(""Label1"", ""Label2"", ""Label3"")}.
+Example: \code{axisLabels.x = c(""Label1"", ""Label2"", ""Label3"")}. \cr
 \strong{Note:} If you use the \code{\link[sjmisc]{read_spss}} function and the \code{\link[sjmisc]{get_val_labels}} function, you receive a
 list object with label string. The labels may also be passed as list object. They will be coerced
 to character vector automatically.}
 
 \item{interactionVarLabels}{Labels for the x-axis breaks when having interaction variables included.
 These labels replace the \code{axisLabels.x}. Only applies, when using box or violin plots
-(i.e. \code{""type""} is \code{""box""} or \code{""violin""}) and \code{interactionVar} is not \code{NULL}.
+(i.e. \code{type} is \code{""box""} or \code{""violin""}) and \code{interactionVar} is not \code{NULL}.
 Example: See \code{axisLabels.x}.}
 
 \item{axisLimits.y}{A numeric vector of length two, defining lower and upper axis limits

---FILE: man/sjp.grpfrq.Rd---
@@ -88,7 +88,7 @@ to character vector automatically.}
 
 \item{interactionVarLabels}{Labels for the x-axis breaks when having interaction variables included.
 These labels replace the \code{axisLabels.x}. Only applies, when using box or violin plots
-(i.e. \code{""type""} is \code{""box""} or \code{""violin""}) and \code{interactionVar} is not \code{NULL}.
+(i.e. \code{type} is \code{""box""} or \code{""violin""}) and \code{interactionVar} is not \code{NULL}.
 Example: See \code{axisLabels.x}.}
 
 \item{legendLabels}{Labels for the guide/legend.

---FILE: man/sjp.int.Rd---
@@ -28,7 +28,7 @@ classes are
   \item generalized linear mixed effects models (\code{\link[lme4]{glmer}})
   \item linear mixed effects models (\code{\link[nlme]{lme}}, but only for \code{type = ""eff""})
   \item generalized least squares models (\code{\link[nlme]{gls}}, but only for \code{type = ""eff""})
-  \item panel data estimators (\code{\link[plm]{plm}})
+  \item panel data estimators (\code{plm})
 }}
 
 \item{type}{interaction plot type. Use one of following values:
@@ -172,7 +172,7 @@ Plot regression (predicted values) or probability lines (predicted probabilities
                  \item generalized linear mixed effects models (\code{\link[lme4]{glmer}})
                  \item linear mixed effects models (\code{\link[nlme]{lme}}, but only for \code{type = ""eff""})
                  \item generalized least squares models (\code{\link[nlme]{gls}}, but only for \code{type = ""eff""})
-                 \item panel data estimators (\code{\link[plm]{plm}})
+                 \item panel data estimators (\code{plm})
                }
                Note that beside interaction terms, also the single predictors of each interaction (main effects)
                must be included in the fitted model as well. Thus, \code{lm(dep ~ pred1 * pred2)} will work,

---FILE: man/sjp.lm.Rd---
@@ -18,7 +18,7 @@ sjp.lm(fit, type = ""lm"", sort.est = TRUE, title = NULL,
   printPlot = TRUE)
 }
 \arguments{
-\item{fit}{fitted linear regression model (\code{\link{lm}}- or \code{\link[plm]{plm}}-object).}
+\item{fit}{fitted linear regression model (\code{\link{lm}}- or \code{plm}-object).}
 
 \item{type}{type of plot. Use one of following:
 \describe{"
strengejacke,sjPlot,b2f80f3c4b60ab919363c1af68a9e43042809671,Daniel Ldecke,d.luedecke@uke.de,2015-05-13T11:43:24Z,Daniel Ldecke,d.luedecke@uke.de,2015-05-13T11:43:24Z,fixed URL download-badge,README.md,False,False,False,False,1,1,2,"---FILE: README.md---
@@ -16,7 +16,7 @@ devtools::install_github(""sjPlot/devel"")
 
 #### Officiale, stable release
 [![CRAN_Status_Badge](http://www.r-pkg.org/badges/version/sjPlot)](http://cran.r-project.org/web/packages/sjPlot) 
-[![downloads](http://cranlogs.r-pkg.org/badges/sjPlot)](http://cranlogs.r-pkg.org/badges/sjPlot)
+[![downloads](http://cranlogs.r-pkg.org/badges/sjPlot)](http://cranlogs.r-pkg.org/)
 
 To install the latest stable release from CRAN, type following command into the R console:
 "
strengejacke,sjPlot,0eddbc6f6964bcfbadbc1836b808d579807bbca3,Daniel Ldecke,d.luedecke@uke.de,2015-05-10T18:42:43Z,Daniel Ldecke,d.luedecke@uke.de,2015-05-10T18:42:43Z,"revamped docs, fixed bug sjt.frq with variable with more unique values than labels",R/helpfunctions.R;R/sjTabCorr.R;R/sjTabDataFrame.R;R/sjTabFrequencies.R;R/sjTabGrpmean.R;R/sjTabItemAnalysis.R;R/sjTabLinReg.R;R/sjTabMannWhitney.R;R/sjTabOdds.R;R/sjTabPCA.R;R/sjTabPropTable.R;R/sjTabSPSS.R;R/sjTabStackFrq.R;man/sjt.corr.Rd;man/sjt.df.Rd;man/sjt.frq.Rd;man/sjt.glm.Rd;man/sjt.glmer.Rd;man/sjt.grpmean.Rd;man/sjt.itemanalysis.Rd;man/sjt.lm.Rd;man/sjt.lmer.Rd;man/sjt.mwu.Rd;man/sjt.pca.Rd;man/sjt.stackfrq.Rd;man/sjt.xtab.Rd;man/view_spss.Rd,False,True,True,False,661,418,1079,"---FILE: R/helpfunctions.R---
@@ -118,6 +118,12 @@ create.frq.df <- function(varCount,
   # get the highest answer category of ""y"", so we know where the
   # range of the x-axis ends
   if (!is.null(labels)) {
+    # check if we have much less labels than values
+    # so there might be a labelling mistake with
+    # the variable
+    if (length(labels) < length(unique(na.omit(varCount)))) {
+      warning(""Variable has less labels than unique values. Output might be incorrect. Please check value labels."", call. = F)
+    }
     catcount <- startAxisAt + length(labels) - 1
   } else {
     # determine maximum values

---FILE: R/sjTabCorr.R---
@@ -53,21 +53,7 @@
 #'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
 #'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
 #' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-#'          of all style-sheet-classnames that are used in this function. Parameters for this list need:
-#'          \enumerate{
-#'            \item the class-names with \code{""css.""}-prefix as parameter name and
-#'            \item each style-definition must end with a semicolon
-#'          } 
-#'          You can add style information to the default styles by using a + (plus-sign) as
-#'          initial character for the parameter attributes. Examples:
-#'          \itemize{
-#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-#'            \item \code{css.summary='+color:blue;'} adds blue font color to summary row.
-#'          }
-#'          See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
 #' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 #'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
 #' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -86,6 +72,28 @@
 #'            }
 #'            for further use.
 #'
+#' @details \bold{How does the \code{CSS}-parameter work?}
+#'            \cr \cr
+#'            With the \code{CSS}-paramater, the visual appearance of the tables
+#'            can be modified. To get an overview of all style-sheet-classnames 
+#'            that are used in this function, see return value \code{page.style} for details. 
+#'            Parameters for this list have following syntax:
+#'          \enumerate{
+#'            \item the class-names with \code{""css.""}-prefix as parameter name and
+#'            \item each style-definition must end with a semicolon
+#'          } 
+#'          You can add style information to the default styles by using a + (plus-sign) as
+#'          initial character for the parameter attributes. Examples:
+#'          \itemize{
+#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+#'            \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+#'            \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+#'            \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+#'          }
+#'          See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'
 #' @note The HTML tables can either be saved as file and manually opened (specify parameter \code{file}) or
 #'         they can be saved as temporary files and will be displayed in the RStudio Viewer pane (if working with RStudio)
 #'         or opened with the default web browser. Displaying resp. opening a temporary file is the

---FILE: R/sjTabDataFrame.R---
@@ -46,21 +46,7 @@
 #'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
 #'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
 #' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-#'          of all style-sheet-classnames that are used in this function. Parameters for this list need:
-#'          \enumerate{
-#'            \item the class-names with \code{""css.""}-prefix as parameter name and
-#'            \item each style-definition must end with a semicolon
-#'          } 
-#'          You can add style information to the default styles by using a + (plus-sign) as
-#'          initial character for the parameter attributes. Examples:
-#'          \itemize{
-#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-#'            \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
-#'            \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
-#'          }
-#'          See further examples below and the \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
 #' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 #'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
 #' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -80,6 +66,28 @@
 #'            }
 #'            for further use.
 #'
+#' @details \bold{How does the \code{CSS}-parameter work?}
+#'            \cr \cr
+#'            With the \code{CSS}-paramater, the visual appearance of the tables
+#'            can be modified. To get an overview of all style-sheet-classnames 
+#'            that are used in this function, see return value \code{page.style} for details. 
+#'            Parameters for this list have following syntax:
+#'          \enumerate{
+#'            \item the class-names with \code{""css.""}-prefix as parameter name and
+#'            \item each style-definition must end with a semicolon
+#'          } 
+#'          You can add style information to the default styles by using a + (plus-sign) as
+#'          initial character for the parameter attributes. Examples:
+#'          \itemize{
+#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+#'            \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+#'            \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+#'            \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+#'          }
+#'          See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'
 #' @examples
 #' \dontrun{
 #' # init dataset

---FILE: R/sjTabFrequencies.R---
@@ -81,21 +81,7 @@
 #'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
 #'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
 #' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-#'          of all style-sheet-classnames that are used in this function. Parameters for this list need:
-#'          \enumerate{
-#'            \item the class-names with \code{""css.""}-prefix as parameter name and
-#'            \item each style-definition must end with a semicolon
-#'          } 
-#'          You can add style information to the default styles by using a + (plus-sign) as
-#'          initial character for the parameter attributes. Examples:
-#'          \itemize{
-#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-#'            \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
-#'          }
-#'          See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
 #' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 #'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
 #' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -119,6 +105,28 @@
 #'         or opened with the default web browser. Displaying resp. opening a temporary file is the
 #'         default behaviour (i.e. \code{file=NULL}).
 #' 
+#' @details \bold{How does the \code{CSS}-parameter work?}
+#'            \cr \cr
+#'            With the \code{CSS}-paramater, the visual appearance of the tables
+#'            can be modified. To get an overview of all style-sheet-classnames 
+#'            that are used in this function, see return value \code{page.style} for details. 
+#'            Parameters for this list have following syntax:
+#'          \enumerate{
+#'            \item the class-names with \code{""css.""}-prefix as parameter name and
+#'            \item each style-definition must end with a semicolon
+#'          } 
+#'          You can add style information to the default styles by using a + (plus-sign) as
+#'          initial character for the parameter attributes. Examples:
+#'          \itemize{
+#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+#'            \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+#'            \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+#'            \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+#'          }
+#'          See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'          
 #' @examples
 #' \dontrun{
 #' # load sample data
@@ -636,8 +644,7 @@ sjt.frq <- function (data,
     for (i in 1:length(page.content.list)) {
       knitr <- paste0(knitr, page.content.list[[i]], sprintf(""\n<p style=\""%s\"">&nbsp;</p>\n"", css.abstand))
     }
-  }
-  else {
+  } else {
     knitr <- page.content
   }
   # -------------------------------------

---FILE: R/sjTabGrpmean.R---
@@ -23,19 +23,7 @@
 #'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
 #'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
 #' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-#'          of all style-sheet-classnames that are used in this function. Parameters for this list need:
-#'          \enumerate{
-#'            \item the class-names with \code{""css.""}-prefix as parameter name and
-#'            \item each style-definition must end with a semicolon
-#'          } 
-#'          You can add style information to the default styles by using a + (plus-sign) as
-#'          initial character for the parameter attributes. Examples:
-#'          \itemize{
-#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-#'          }
-#'          See further examples below and the \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
 #' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 #'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
 #' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -55,6 +43,28 @@
 #'            }
 #'            for further use.
 #'
+#' @details \bold{How does the \code{CSS}-parameter work?}
+#'            \cr \cr
+#'            With the \code{CSS}-paramater, the visual appearance of the tables
+#'            can be modified. To get an overview of all style-sheet-classnames 
+#'            that are used in this function, see return value \code{page.style} for details. 
+#'            Parameters for this list have following syntax:
+#'          \enumerate{
+#'            \item the class-names with \code{""css.""}-prefix as parameter name and
+#'            \item each style-definition must end with a semicolon
+#'          } 
+#'          You can add style information to the default styles by using a + (plus-sign) as
+#'          initial character for the parameter attributes. Examples:
+#'          \itemize{
+#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+#'            \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+#'            \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+#'            \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+#'          }
+#'          See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'
 #' @examples
 #' \dontrun{
 #' library(sjmisc)

---FILE: R/sjTabItemAnalysis.R---
@@ -72,21 +72,7 @@
 #'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
 #'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
 #' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-#'          of all style-sheet-classnames that are used in this function. Parameters for this list need:
-#'          \enumerate{
-#'            \item the class-names with \code{""css.""}-prefix as parameter name and
-#'            \item each style-definition must end with a semicolon
-#'          } 
-#'          You can add style information to the default styles by using a + (plus-sign) as
-#'          initial character for the parameter attributes. Examples:
-#'          \itemize{
-#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-#'            \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
-#'            \item \code{css.arc='+font-style:italic;'} to add italic formatting to each 2nd row.
-#'          }
-#'          See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
 #' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 #'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
 #' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -118,6 +104,28 @@
 #'          \item In case the total \emph{Cronbach's Alpha} value is below the acceptable cut-off of 0.7 (mostly if an index has few items), the \emph{mean inter-item-correlation} is an alternative measure to indicate acceptability. Satisfactory range lies between 0.2 and 0.4.
 #'        }
 #' 
+#' @details \bold{How does the \code{CSS}-parameter work?}
+#'            \cr \cr
+#'            With the \code{CSS}-paramater, the visual appearance of the tables
+#'            can be modified. To get an overview of all style-sheet-classnames 
+#'            that are used in this function, see return value \code{page.style} for details. 
+#'            Parameters for this list have following syntax:
+#'          \enumerate{
+#'            \item the class-names with \code{""css.""}-prefix as parameter name and
+#'            \item each style-definition must end with a semicolon
+#'          } 
+#'          You can add style information to the default styles by using a + (plus-sign) as
+#'          initial character for the parameter attributes. Examples:
+#'          \itemize{
+#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+#'            \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+#'            \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+#'            \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+#'          }
+#'          See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#' 
 #' @references \itemize{
 #'              \item Jorion N, Self B, James K, Schroeder L, DiBello L, Pellegrino J (2013) Classical Test Theory Analysis of the Dynamics Concept Inventory. (\href{https://www.academia.edu/4104752/Classical_Test_Theory_Analysis_of_the_Dynamics_Concept_Inventory}{web})
 #'              \item Briggs SR, Cheek JM (1986) The role of factor analysis in the development and evaluation of personality scales. Journal of Personality, 54(1), 106-148 (\href{http://onlinelibrary.wiley.com/doi/10.1111/j.1467-6494.1986.tb00391.x/abstract}{web})

---FILE: R/sjTabLinReg.R---
@@ -86,21 +86,7 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""starts_with""))
 #'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
 #'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
 #' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-#'          of all style-sheet-classnames that are used in this function. Parameters for this list need:
-#'          \enumerate{
-#'            \item the class-names with \code{""css.""}-prefix as parameter name and
-#'            \item each style-definition must end with a semicolon
-#'          } 
-#'          You can add style information to the default styles by using a + (plus-sign) as
-#'          initial character for the parameter attributes. Examples:
-#'          \itemize{
-#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-#'            \item \code{css.colnames='+color:green'} to add green color formatting to column names.
-#'          }
-#'          See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
 #' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 #'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
 #' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -124,6 +110,28 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""starts_with""))
 #'         or opened with the default web browser. Displaying resp. opening a temporary file is the
 #'         default behaviour (i.e. \code{file=NULL}).
 #' 
+#' @details \bold{How does the \code{CSS}-parameter work?}
+#'            \cr \cr
+#'            With the \code{CSS}-paramater, the visual appearance of the tables
+#'            can be modified. To get an overview of all style-sheet-classnames 
+#'            that are used in this function, see return value \code{page.style} for details. 
+#'            Parameters for this list have following syntax:
+#'          \enumerate{
+#'            \item the class-names with \code{""css.""}-prefix as parameter name and
+#'            \item each style-definition must end with a semicolon
+#'          } 
+#'          You can add style information to the default styles by using a + (plus-sign) as
+#'          initial character for the parameter attributes. Examples:
+#'          \itemize{
+#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+#'            \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+#'            \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+#'            \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+#'          }
+#'          See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#' 
 #' @examples
 #' \dontrun{
 #' # Now fit the models. Note that both models share the same predictors
@@ -1447,21 +1455,7 @@ sjt.lm <- function (...,
 #'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
 #'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
 #' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-#'          of all style-sheet-classnames that are used in this function. Parameters for this list need:
-#'          \enumerate{
-#'            \item the class-names with \code{""css.""}-prefix as parameter name and
-#'            \item each style-definition must end with a semicolon
-#'          } 
-#'          You can add style information to the default styles by using a + (plus-sign) as
-#'          initial character for the parameter attributes. Examples:
-#'          \itemize{
-#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-#'            \item \code{css.colnames='+color:green'} to add green color formatting to column names.
-#'          }
-#'          See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
 #' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 #'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
 #' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -1485,6 +1479,28 @@ sjt.lm <- function (...,
 #'         or opened with the default web browser. Displaying resp. opening a temporary file is the
 #'         default behaviour (i.e. \code{file=NULL}).
 #' 
+#' @details \bold{How does the \code{CSS}-parameter work?}
+#'            \cr \cr
+#'            With the \code{CSS}-paramater, the visual appearance of the tables
+#'            can be modified. To get an overview of all style-sheet-classnames 
+#'            that are used in this function, see return value \code{page.style} for details. 
+#'            Parameters for this list have following syntax:
+#'          \enumerate{
+#'            \item the class-names with \code{""css.""}-prefix as parameter name and
+#'            \item each style-definition must end with a semicolon
+#'          } 
+#'          You can add style information to the default styles by using a + (plus-sign) as
+#'          initial character for the parameter attributes. Examples:
+#'          \itemize{
+#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+#'            \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+#'            \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+#'            \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+#'          }
+#'          See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#' 
 #' @examples
 #' \dontrun{
 #' library(lme4)

---FILE: R/sjTabMannWhitney.R---
@@ -16,21 +16,7 @@
 #'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
 #'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
 #' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-#'          of all style-sheet-classnames that are used in this function. Parameters for this list need:
-#'          \enumerate{
-#'            \item the class-names with \code{""css.""}-prefix as parameter name and
-#'            \item each style-definition must end with a semicolon
-#'          } 
-#'          You can add style information to the default styles by using a + (plus-sign) as
-#'          initial character for the parameter attributes. Examples:
-#'          \itemize{
-#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-#'            \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
-#'            \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
-#'          }
-#'          See further examples below and the \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
 #' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 #'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
 #' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -50,6 +36,26 @@
 #'            }
 #'            for further use.
 #'
+#' @details \bold{How does the \code{CSS}-parameter work?}
+#'            \cr \cr
+#'            With the \code{CSS}-paramater, the visual appearance of the tables
+#'            can be modified. To get an overview of all style-sheet-classnames 
+#'            that are used in this function, see return value \code{page.style} for details. 
+#'            Parameters for this list have following syntax:
+#'          \enumerate{
+#'            \item the class-names with \code{""css.""}-prefix as parameter name and
+#'            \item each style-definition must end with a semicolon
+#'          } 
+#'          You can add style information to the default styles by using a + (plus-sign) as
+#'          initial character for the parameter attributes. Examples:
+#'          \itemize{
+#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+#'            \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+#'            \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+#'          }
+#'          See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'
 #' @examples 
 #' \dontrun{
 #' library(sjmisc)

---FILE: R/sjTabOdds.R---
@@ -99,21 +99,7 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""starts_with""))
 #'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
 #'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
 #' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-#'          of all style-sheet-classnames that are used in this function. Parameters for this list need:
-#'          \enumerate{
-#'            \item the class-names with \code{""css.""}-prefix as parameter name and
-#'            \item each style-definition must end with a semicolon
-#'          } 
-#'          You can add style information to the default styles by using a + (plus-sign) as
-#'          initial character for the parameter attributes. Examples:
-#'          \itemize{
-#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-#'            \item \code{css.colnames='+color:green'} to add green color formatting to column names.
-#'          }
-#'          See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
 #' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 #'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
 #' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -137,6 +123,28 @@ if (getRversion() >= ""2.15.1"") utils::globalVariables(c(""starts_with""))
 #'         or opened with the default web browser. Displaying resp. opening a temporary file is the
 #'         default behaviour (i.e. \code{file=NULL}).
 #'         
+#' @details \bold{How does the \code{CSS}-parameter work?}
+#'            \cr \cr
+#'            With the \code{CSS}-paramater, the visual appearance of the tables
+#'            can be modified. To get an overview of all style-sheet-classnames 
+#'            that are used in this function, see return value \code{page.style} for details. 
+#'            Parameters for this list have following syntax:
+#'          \enumerate{
+#'            \item the class-names with \code{""css.""}-prefix as parameter name and
+#'            \item each style-definition must end with a semicolon
+#'          } 
+#'          You can add style information to the default styles by using a + (plus-sign) as
+#'          initial character for the parameter attributes. Examples:
+#'          \itemize{
+#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+#'            \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+#'            \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+#'            \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+#'          }
+#'          See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'          
 #' @examples
 #' # prepare dummy variables for binary logistic regression
 #' y1 <- ifelse(swiss$Fertility < median(swiss$Fertility), 0, 1)
@@ -1364,21 +1372,7 @@ sjt.glm <- function(...,
 #'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
 #'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
 #' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-#'          of all style-sheet-classnames that are used in this function. Parameters for this list need:
-#'          \enumerate{
-#'            \item the class-names with \code{""css.""}-prefix as parameter name and
-#'            \item each style-definition must end with a semicolon
-#'          } 
-#'          You can add style information to the default styles by using a + (plus-sign) as
-#'          initial character for the parameter attributes. Examples:
-#'          \itemize{
-#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-#'            \item \code{css.colnames='+color:green'} to add green color formatting to column names.
-#'          }
-#'          See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
 #' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 #'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
 #' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -1402,6 +1396,28 @@ sjt.glm <- function(...,
 #'         or opened with the default web browser. Displaying resp. opening a temporary file is the
 #'         default behaviour (i.e. \code{file=NULL}).
 #'         
+#' @details \bold{How does the \code{CSS}-parameter work?}
+#'            \cr \cr
+#'            With the \code{CSS}-paramater, the visual appearance of the tables
+#'            can be modified. To get an overview of all style-sheet-classnames 
+#'            that are used in this function, see return value \code{page.style} for details. 
+#'            Parameters for this list have following syntax:
+#'          \enumerate{
+#'            \item the class-names with \code{""css.""}-prefix as parameter name and
+#'            \item each style-definition must end with a semicolon
+#'          } 
+#'          You can add style information to the default styles by using a + (plus-sign) as
+#'          initial character for the parameter attributes. Examples:
+#'          \itemize{
+#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+#'            \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+#'            \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+#'            \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+#'          }
+#'          See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'
 #' @examples
 #' \dontrun{
 #' library(lme4)

---FILE: R/sjTabPCA.R---
@@ -54,21 +54,7 @@
 #'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
 #'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
 #' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-#'          of all style-sheet-classnames that are used in this function. Parameters for this list need:
-#'          \enumerate{
-#'            \item the class-names with \code{""css.""}-prefix as parameter name and
-#'            \item each style-definition must end with a semicolon
-#'          } 
-#'          You can add style information to the default styles by using a + (plus-sign) as
-#'          initial character for the parameter attributes. Examples:
-#'          \itemize{
-#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-#'            \item \code{css.cronbach='+color:green;'} to add green color formatting to the Cronbach's Alpha value.
-#'          }
-#'          See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
 #' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 #'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
 #' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -89,6 +75,28 @@
 #'            }
 #'            for further use.
 #'
+#' @details \bold{How does the \code{CSS}-parameter work?}
+#'            \cr \cr
+#'            With the \code{CSS}-paramater, the visual appearance of the tables
+#'            can be modified. To get an overview of all style-sheet-classnames 
+#'            that are used in this function, see return value \code{page.style} for details. 
+#'            Parameters for this list have following syntax:
+#'          \enumerate{
+#'            \item the class-names with \code{""css.""}-prefix as parameter name and
+#'            \item each style-definition must end with a semicolon
+#'          } 
+#'          You can add style information to the default styles by using a + (plus-sign) as
+#'          initial character for the parameter attributes. Examples:
+#'          \itemize{
+#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+#'            \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+#'            \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+#'            \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+#'          }
+#'          See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'
 #' @note The HTML tables can either be saved as file and manually opened (specify parameter \code{file}) or
 #'         they can be saved as temporary files and will be displayed in the RStudio Viewer pane (if working with RStudio)
 #'         or opened with the default web browser. Displaying resp. opening a temporary file is the

---FILE: R/sjTabPropTable.R---
@@ -69,21 +69,7 @@
 #'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
 #'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
 #' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-#'          of all style-sheet-classnames that are used in this function. Parameters for this list need:
-#'          \enumerate{
-#'            \item the class-names with \code{""css.""}-prefix as parameter name and
-#'            \item each style-definition must end with a semicolon
-#'          } 
-#'          You can add style information to the default styles by using a + (plus-sign) as
-#'          initial character for the parameter attributes. Examples:
-#'          \itemize{
-#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-#'            \item \code{css.summary='+color:blue;'} to add blue font color style to the summary row.
-#'          }
-#'          See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Detail'.
 #' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 #'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
 #' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -113,6 +99,28 @@
 #'         (e.g., see column \code{group} in dataset \code{\link{PlantGrowth}}). However, you still
 #'         can use own parameters variable labels.
 #'         
+#' @details \bold{How does the \code{CSS}-parameter work?}
+#'            \cr \cr
+#'            With the \code{CSS}-paramater, the visual appearance of the tables
+#'            can be modified. To get an overview of all style-sheet-classnames 
+#'            that are used in this function, see return value \code{page.style} for details. 
+#'            Parameters for this list have following syntax:
+#'          \enumerate{
+#'            \item the class-names with \code{""css.""}-prefix as parameter name and
+#'            \item each style-definition must end with a semicolon
+#'          } 
+#'          You can add style information to the default styles by using a + (plus-sign) as
+#'          initial character for the parameter attributes. Examples:
+#'          \itemize{
+#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+#'            \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+#'            \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+#'            \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+#'          }
+#'          See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'         
 #' @examples 
 #' # prepare sample data set
 #' library(sjmisc)

---FILE: R/sjTabSPSS.R---
@@ -38,21 +38,7 @@
 #'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
 #'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
 #' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-#'          of all style-sheet-classnames that are used in this function. Parameters for this list need:
-#'          \enumerate{
-#'            \item the class-names with \code{""css.""}-prefix as parameter name and
-#'            \item each style-definition must end with a semicolon
-#'          } 
-#'          You can add style information to the default styles by using a + (plus-sign) as
-#'          initial character for the parameter attributes. Examples:
-#'          \itemize{
-#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-#'            \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
-#'            \item \code{css.summary='+color:blue;'} to add blue font color style to the summary row.
-#'          }
-#'          See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
 #' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 #'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
 #' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -71,6 +57,28 @@
 #'            }
 #'            for further use.
 #'
+#' @details \bold{How does the \code{CSS}-parameter work?}
+#'            \cr \cr
+#'            With the \code{CSS}-paramater, the visual appearance of the tables
+#'            can be modified. To get an overview of all style-sheet-classnames 
+#'            that are used in this function, see return value \code{page.style} for details. 
+#'            Parameters for this list have following syntax:
+#'          \enumerate{
+#'            \item the class-names with \code{""css.""}-prefix as parameter name and
+#'            \item each style-definition must end with a semicolon
+#'          } 
+#'          You can add style information to the default styles by using a + (plus-sign) as
+#'          initial character for the parameter attributes. Examples:
+#'          \itemize{
+#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+#'            \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+#'            \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+#'            \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+#'          }
+#'          See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'
 #' @examples
 #' \dontrun{
 #' # init dataset

---FILE: R/sjTabStackFrq.R---
@@ -61,21 +61,7 @@
 #'          will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \code{""Windows-1252""} for
 #'          Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).
 #' @param CSS A \code{\link{list}} with user-defined style-sheet-definitions, according to the 
-#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-#'          of all style-sheet-classnames that are used in this function. Parameters for this list need:
-#'          \enumerate{
-#'            \item the class-names with \code{""css.""}-prefix as parameter name and
-#'            \item each style-definition must end with a semicolon
-#'          } 
-#'          You can add style information to the default styles by using a + (plus-sign) as
-#'          initial character for the parameter attributes. Examples:
-#'          \itemize{
-#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-#'            \item \code{css.caption='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-#'            \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
-#'          }
-#'          See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#'          \href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.
 #' @param useViewer If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 #'          \code{FALSE} or no viewer available, the HTML table is opened in a web browser.
 #' @param no.output If \code{TRUE}, the html-output is neither opened in a browser nor shown in
@@ -99,6 +85,28 @@
 #'         or opened with the default web browser. Displaying resp. opening a temporary file is the
 #'         default behaviour (i.e. \code{file=NULL}).
 #' 
+#' @details \bold{How does the \code{CSS}-parameter work?}
+#'            \cr \cr
+#'            With the \code{CSS}-paramater, the visual appearance of the tables
+#'            can be modified. To get an overview of all style-sheet-classnames 
+#'            that are used in this function, see return value \code{page.style} for details. 
+#'            Parameters for this list have following syntax:
+#'          \enumerate{
+#'            \item the class-names with \code{""css.""}-prefix as parameter name and
+#'            \item each style-definition must end with a semicolon
+#'          } 
+#'          You can add style information to the default styles by using a + (plus-sign) as
+#'          initial character for the parameter attributes. Examples:
+#'          \itemize{
+#'            \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+#'            \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+#'            \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+#'            \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+#'            \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+#'            \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+#'          }
+#'          See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+#' 
 #' @examples
 #' # -------------------------------
 #' # random sample

---FILE: man/sjt.corr.Rd---
@@ -71,21 +71,7 @@ will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \c
 Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
-\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-of all style-sheet-classnames that are used in this function. Parameters for this list need:
-\enumerate{
-  \item the class-names with \code{""css.""}-prefix as parameter name and
-  \item each style-definition must end with a semicolon
-}
-You can add style information to the default styles by using a + (plus-sign) as
-initial character for the parameter attributes. Examples:
-\itemize{
-  \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-  \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-  \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-  \item \code{css.summary='+color:blue;'} adds blue font color to summary row.
-}
-See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.}
+\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
@@ -113,6 +99,29 @@ Invisibly returns
 Shows the results of a computed correlation as HTML table. Requires either
                a data frame or a computed \code{\link{cor}}-object.
 }
+\details{
+\bold{How does the \code{CSS}-parameter work?}
+           \cr \cr
+           With the \code{CSS}-paramater, the visual appearance of the tables
+           can be modified. To get an overview of all style-sheet-classnames
+           that are used in this function, see return value \code{page.style} for details.
+           Parameters for this list have following syntax:
+         \enumerate{
+           \item the class-names with \code{""css.""}-prefix as parameter name and
+           \item each style-definition must end with a semicolon
+         }
+         You can add style information to the default styles by using a + (plus-sign) as
+         initial character for the parameter attributes. Examples:
+         \itemize{
+           \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+           \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+           \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+           \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+           \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+           \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+         }
+         See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+}
 \note{
 The HTML tables can either be saved as file and manually opened (specify parameter \code{file}) or
         they can be saved as temporary files and will be displayed in the RStudio Viewer pane (if working with RStudio)

---FILE: man/sjt.df.Rd---
@@ -62,21 +62,7 @@ will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \c
 Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
-\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-of all style-sheet-classnames that are used in this function. Parameters for this list need:
-\enumerate{
-  \item the class-names with \code{""css.""}-prefix as parameter name and
-  \item each style-definition must end with a semicolon
-}
-You can add style information to the default styles by using a + (plus-sign) as
-initial character for the parameter attributes. Examples:
-\itemize{
-  \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-  \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-  \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
-  \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
-}
-See further examples below and the \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.}
+\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
@@ -108,6 +94,29 @@ Shows description or the content of data frame (rows and columns) as HTML table,
                is \code{TRUE} and a description of the data frame is given,
                using the \code{\link[psych]{describe}} function of the \code{psych} package.
 }
+\details{
+\bold{How does the \code{CSS}-parameter work?}
+           \cr \cr
+           With the \code{CSS}-paramater, the visual appearance of the tables
+           can be modified. To get an overview of all style-sheet-classnames
+           that are used in this function, see return value \code{page.style} for details.
+           Parameters for this list have following syntax:
+         \enumerate{
+           \item the class-names with \code{""css.""}-prefix as parameter name and
+           \item each style-definition must end with a semicolon
+         }
+         You can add style information to the default styles by using a + (plus-sign) as
+         initial character for the parameter attributes. Examples:
+         \itemize{
+           \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+           \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+           \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+           \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+           \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+           \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+         }
+         See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+}
 \examples{
 \dontrun{
 # init dataset

---FILE: man/sjt.frq.Rd---
@@ -116,21 +116,7 @@ will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \c
 Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
-\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-of all style-sheet-classnames that are used in this function. Parameters for this list need:
-\enumerate{
-  \item the class-names with \code{""css.""}-prefix as parameter name and
-  \item each style-definition must end with a semicolon
-}
-You can add style information to the default styles by using a + (plus-sign) as
-initial character for the parameter attributes. Examples:
-\itemize{
-  \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-  \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-  \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-  \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
-}
-See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.}
+\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
@@ -157,6 +143,29 @@ Invisibly returns
 \description{
 Shows (multiple) frequency tables as HTML file, or saves them as file.
 }
+\details{
+\bold{How does the \code{CSS}-parameter work?}
+           \cr \cr
+           With the \code{CSS}-paramater, the visual appearance of the tables
+           can be modified. To get an overview of all style-sheet-classnames
+           that are used in this function, see return value \code{page.style} for details.
+           Parameters for this list have following syntax:
+         \enumerate{
+           \item the class-names with \code{""css.""}-prefix as parameter name and
+           \item each style-definition must end with a semicolon
+         }
+         You can add style information to the default styles by using a + (plus-sign) as
+         initial character for the parameter attributes. Examples:
+         \itemize{
+           \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+           \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+           \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+           \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+           \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+           \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+         }
+         See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+}
 \note{
 The HTML tables can either be saved as file and manually opened (specify parameter \code{file}) or
         they can be saved as temporary files and will be displayed in the RStudio Viewer pane (if working with RStudio)

---FILE: man/sjt.glm.Rd---
@@ -149,21 +149,7 @@ will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \c
 Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
-\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-of all style-sheet-classnames that are used in this function. Parameters for this list need:
-\enumerate{
-  \item the class-names with \code{""css.""}-prefix as parameter name and
-  \item each style-definition must end with a semicolon
-}
-You can add style information to the default styles by using a + (plus-sign) as
-initial character for the parameter attributes. Examples:
-\itemize{
-  \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-  \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-  \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-  \item \code{css.colnames='+color:green'} to add green color formatting to column names.
-}
-See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.}
+\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
@@ -192,6 +178,29 @@ Summarizes (multiple) fitted generalized linear models (odds ratios, ci, p-value
                as HTML table, or saves them as file. The fitted models may have different predictors,
                e.g. when comparing different stepwise fitted models.
 }
+\details{
+\bold{How does the \code{CSS}-parameter work?}
+           \cr \cr
+           With the \code{CSS}-paramater, the visual appearance of the tables
+           can be modified. To get an overview of all style-sheet-classnames
+           that are used in this function, see return value \code{page.style} for details.
+           Parameters for this list have following syntax:
+         \enumerate{
+           \item the class-names with \code{""css.""}-prefix as parameter name and
+           \item each style-definition must end with a semicolon
+         }
+         You can add style information to the default styles by using a + (plus-sign) as
+         initial character for the parameter attributes. Examples:
+         \itemize{
+           \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+           \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+           \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+           \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+           \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+           \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+         }
+         See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+}
 \note{
 The HTML tables can either be saved as file and manually opened (specify parameter \code{file}) or
         they can be saved as temporary files and will be displayed in the RStudio Viewer pane (if working with RStudio)

---FILE: man/sjt.glmer.Rd---
@@ -131,21 +131,7 @@ will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \c
 Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
-\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-of all style-sheet-classnames that are used in this function. Parameters for this list need:
-\enumerate{
-  \item the class-names with \code{""css.""}-prefix as parameter name and
-  \item each style-definition must end with a semicolon
-}
-You can add style information to the default styles by using a + (plus-sign) as
-initial character for the parameter attributes. Examples:
-\itemize{
-  \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-  \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-  \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-  \item \code{css.colnames='+color:green'} to add green color formatting to column names.
-}
-See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.}
+\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
@@ -174,6 +160,29 @@ Summarizes (multiple) fitted generalized linear mixed models (odds ratios, ci, p
                as HTML table, or saves them as file. The fitted models may have different predictors,
                e.g. when comparing different stepwise fitted models.
 }
+\details{
+\bold{How does the \code{CSS}-parameter work?}
+           \cr \cr
+           With the \code{CSS}-paramater, the visual appearance of the tables
+           can be modified. To get an overview of all style-sheet-classnames
+           that are used in this function, see return value \code{page.style} for details.
+           Parameters for this list have following syntax:
+         \enumerate{
+           \item the class-names with \code{""css.""}-prefix as parameter name and
+           \item each style-definition must end with a semicolon
+         }
+         You can add style information to the default styles by using a + (plus-sign) as
+         initial character for the parameter attributes. Examples:
+         \itemize{
+           \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+           \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+           \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+           \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+           \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+           \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+         }
+         See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+}
 \note{
 The HTML tables can either be saved as file and manually opened (specify parameter \code{file}) or
         they can be saved as temporary files and will be displayed in the RStudio Viewer pane (if working with RStudio)

---FILE: man/sjt.grpmean.Rd---
@@ -34,19 +34,7 @@ will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \c
 Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
-\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-of all style-sheet-classnames that are used in this function. Parameters for this list need:
-\enumerate{
-  \item the class-names with \code{""css.""}-prefix as parameter name and
-  \item each style-definition must end with a semicolon
-}
-You can add style information to the default styles by using a + (plus-sign) as
-initial character for the parameter attributes. Examples:
-\itemize{
-  \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-  \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-}
-See further examples below and the \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.}
+\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
@@ -75,6 +63,29 @@ Invisibly returns a \code{\link{list}} with
 Computes mean, sd and se for each sub-group (indicated by \code{varGrp})
                of \code{varCount} and prints the result as HTML table.
 }
+\details{
+\bold{How does the \code{CSS}-parameter work?}
+           \cr \cr
+           With the \code{CSS}-paramater, the visual appearance of the tables
+           can be modified. To get an overview of all style-sheet-classnames
+           that are used in this function, see return value \code{page.style} for details.
+           Parameters for this list have following syntax:
+         \enumerate{
+           \item the class-names with \code{""css.""}-prefix as parameter name and
+           \item each style-definition must end with a semicolon
+         }
+         You can add style information to the default styles by using a + (plus-sign) as
+         initial character for the parameter attributes. Examples:
+         \itemize{
+           \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+           \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+           \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+           \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+           \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+           \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+         }
+         See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+}
 \examples{
 \dontrun{
 library(sjmisc)

---FILE: man/sjt.itemanalysis.Rd---
@@ -70,21 +70,7 @@ will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \c
 Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
-\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-of all style-sheet-classnames that are used in this function. Parameters for this list need:
-\enumerate{
-  \item the class-names with \code{""css.""}-prefix as parameter name and
-  \item each style-definition must end with a semicolon
-}
-You can add style information to the default styles by using a + (plus-sign) as
-initial character for the parameter attributes. Examples:
-\itemize{
-  \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-  \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-  \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
-  \item \code{css.arc='+font-style:italic;'} to add italic formatting to each 2nd row.
-}
-See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.}
+\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
@@ -139,6 +125,29 @@ This function performs an item analysis with certain statistics that are
                of the data frame that belong to a certain factor (see return value of function \code{\link{sjt.pca}}
                as example for retrieving factor groups for a scale and see examples for more details).
 }
+\details{
+\bold{How does the \code{CSS}-parameter work?}
+           \cr \cr
+           With the \code{CSS}-paramater, the visual appearance of the tables
+           can be modified. To get an overview of all style-sheet-classnames
+           that are used in this function, see return value \code{page.style} for details.
+           Parameters for this list have following syntax:
+         \enumerate{
+           \item the class-names with \code{""css.""}-prefix as parameter name and
+           \item each style-definition must end with a semicolon
+         }
+         You can add style information to the default styles by using a + (plus-sign) as
+         initial character for the parameter attributes. Examples:
+         \itemize{
+           \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+           \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+           \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+           \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+           \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+           \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+         }
+         See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+}
 \note{
 \itemize{
          \item The \emph{Shapiro-Wilk Normality Test} (see column \code{W(p)}) tests if an item has a distribution that is significantly different from normal.

---FILE: man/sjt.lm.Rd---
@@ -134,21 +134,7 @@ will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \c
 Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
-\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-of all style-sheet-classnames that are used in this function. Parameters for this list need:
-\enumerate{
-  \item the class-names with \code{""css.""}-prefix as parameter name and
-  \item each style-definition must end with a semicolon
-}
-You can add style information to the default styles by using a + (plus-sign) as
-initial character for the parameter attributes. Examples:
-\itemize{
-  \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-  \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-  \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-  \item \code{css.colnames='+color:green'} to add green color formatting to column names.
-}
-See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.}
+\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
@@ -177,6 +163,29 @@ Summarizes (multiple) fitted linear models (beta coefficients, std. beta values
                as HTML table, or saves them as file. The fitted models may have different predictors,
                e.g. when comparing different stepwise fitted models.
 }
+\details{
+\bold{How does the \code{CSS}-parameter work?}
+           \cr \cr
+           With the \code{CSS}-paramater, the visual appearance of the tables
+           can be modified. To get an overview of all style-sheet-classnames
+           that are used in this function, see return value \code{page.style} for details.
+           Parameters for this list have following syntax:
+         \enumerate{
+           \item the class-names with \code{""css.""}-prefix as parameter name and
+           \item each style-definition must end with a semicolon
+         }
+         You can add style information to the default styles by using a + (plus-sign) as
+         initial character for the parameter attributes. Examples:
+         \itemize{
+           \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+           \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+           \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+           \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+           \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+           \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+         }
+         See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+}
 \note{
 The HTML tables can either be saved as file and manually opened (specify parameter \code{file}) or
         they can be saved as temporary files and will be displayed in the RStudio Viewer pane (if working with RStudio)

---FILE: man/sjt.lmer.Rd---
@@ -122,21 +122,7 @@ will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \c
 Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
-\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-of all style-sheet-classnames that are used in this function. Parameters for this list need:
-\enumerate{
-  \item the class-names with \code{""css.""}-prefix as parameter name and
-  \item each style-definition must end with a semicolon
-}
-You can add style information to the default styles by using a + (plus-sign) as
-initial character for the parameter attributes. Examples:
-\itemize{
-  \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-  \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-  \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-  \item \code{css.colnames='+color:green'} to add green color formatting to column names.
-}
-See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.}
+\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
@@ -166,6 +152,29 @@ Summarizes (multiple) fitted linear mixed effects models
                or saves them as file. The fitted models may have different
                predictors, e.g. when comparing different stepwise fitted models.
 }
+\details{
+\bold{How does the \code{CSS}-parameter work?}
+           \cr \cr
+           With the \code{CSS}-paramater, the visual appearance of the tables
+           can be modified. To get an overview of all style-sheet-classnames
+           that are used in this function, see return value \code{page.style} for details.
+           Parameters for this list have following syntax:
+         \enumerate{
+           \item the class-names with \code{""css.""}-prefix as parameter name and
+           \item each style-definition must end with a semicolon
+         }
+         You can add style information to the default styles by using a + (plus-sign) as
+         initial character for the parameter attributes. Examples:
+         \itemize{
+           \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+           \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+           \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+           \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+           \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+           \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+         }
+         See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+}
 \note{
 The HTML tables can either be saved as file and manually opened (specify parameter \code{file}) or
         they can be saved as temporary files and will be displayed in the RStudio Viewer pane (if working with RStudio)

---FILE: man/sjt.mwu.Rd---
@@ -25,21 +25,7 @@ will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \c
 Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
-\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-of all style-sheet-classnames that are used in this function. Parameters for this list need:
-\enumerate{
-  \item the class-names with \code{""css.""}-prefix as parameter name and
-  \item each style-definition must end with a semicolon
-}
-You can add style information to the default styles by using a + (plus-sign) as
-initial character for the parameter attributes. Examples:
-\itemize{
-  \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-  \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-  \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
-  \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
-}
-See further examples below and the \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.}
+\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
@@ -69,6 +55,27 @@ Shows the results of a Mann-Whitney-U-test as HTML table. The results
                from the Mann-Whitney-test are obtained by the \code{\link[sjmisc]{mwu}}
                function from the \code{sjmisc} package.
 }
+\details{
+\bold{How does the \code{CSS}-parameter work?}
+           \cr \cr
+           With the \code{CSS}-paramater, the visual appearance of the tables
+           can be modified. To get an overview of all style-sheet-classnames
+           that are used in this function, see return value \code{page.style} for details.
+           Parameters for this list have following syntax:
+         \enumerate{
+           \item the class-names with \code{""css.""}-prefix as parameter name and
+           \item each style-definition must end with a semicolon
+         }
+         You can add style information to the default styles by using a + (plus-sign) as
+         initial character for the parameter attributes. Examples:
+         \itemize{
+           \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+           \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+           \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+           \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+         }
+         See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+}
 \examples{
 \dontrun{
 library(sjmisc)

---FILE: man/sjt.pca.Rd---
@@ -70,21 +70,7 @@ will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \c
 Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
-\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-of all style-sheet-classnames that are used in this function. Parameters for this list need:
-\enumerate{
-  \item the class-names with \code{""css.""}-prefix as parameter name and
-  \item each style-definition must end with a semicolon
-}
-You can add style information to the default styles by using a + (plus-sign) as
-initial character for the parameter attributes. Examples:
-\itemize{
-  \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-  \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-  \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-  \item \code{css.cronbach='+color:green;'} to add green color formatting to the Cronbach's Alpha value.
-}
-See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.}
+\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
@@ -118,6 +104,29 @@ Performes a principle component analysis on a data frame or matrix
                i.e. all variables with the highest loading for a factor are taken for the
                reliability test. The result is an alpha value for each factor dimension.
 }
+\details{
+\bold{How does the \code{CSS}-parameter work?}
+           \cr \cr
+           With the \code{CSS}-paramater, the visual appearance of the tables
+           can be modified. To get an overview of all style-sheet-classnames
+           that are used in this function, see return value \code{page.style} for details.
+           Parameters for this list have following syntax:
+         \enumerate{
+           \item the class-names with \code{""css.""}-prefix as parameter name and
+           \item each style-definition must end with a semicolon
+         }
+         You can add style information to the default styles by using a + (plus-sign) as
+         initial character for the parameter attributes. Examples:
+         \itemize{
+           \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+           \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+           \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+           \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+           \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+           \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+         }
+         See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+}
 \note{
 The HTML tables can either be saved as file and manually opened (specify parameter \code{file}) or
         they can be saved as temporary files and will be displayed in the RStudio Viewer pane (if working with RStudio)

---FILE: man/sjt.stackfrq.Rd---
@@ -84,21 +84,7 @@ will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \c
 Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
-\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-of all style-sheet-classnames that are used in this function. Parameters for this list need:
-\enumerate{
-  \item the class-names with \code{""css.""}-prefix as parameter name and
-  \item each style-definition must end with a semicolon
-}
-You can add style information to the default styles by using a + (plus-sign) as
-initial character for the parameter attributes. Examples:
-\itemize{
-  \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-  \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-  \item \code{css.caption='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-  \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
-}
-See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.}
+\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
@@ -128,6 +114,29 @@ Shows the results of stacked frequencies (such as likert scales) as HTML table.
                should be printed as table to compare their distributions (e.g.
                when plotting scales like SF, Barthel-Index, Quality-of-Life-scales etc.).
 }
+\details{
+\bold{How does the \code{CSS}-parameter work?}
+           \cr \cr
+           With the \code{CSS}-paramater, the visual appearance of the tables
+           can be modified. To get an overview of all style-sheet-classnames
+           that are used in this function, see return value \code{page.style} for details.
+           Parameters for this list have following syntax:
+         \enumerate{
+           \item the class-names with \code{""css.""}-prefix as parameter name and
+           \item each style-definition must end with a semicolon
+         }
+         You can add style information to the default styles by using a + (plus-sign) as
+         initial character for the parameter attributes. Examples:
+         \itemize{
+           \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+           \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+           \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+           \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+           \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+           \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+         }
+         See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+}
 \note{
 The HTML tables can either be saved as file and manually opened (specify parameter \code{file}) or
         they can be saved as temporary files and will be displayed in the RStudio Viewer pane (if working with RStudio)

---FILE: man/sjt.xtab.Rd---
@@ -111,21 +111,7 @@ will be auto-detected depending on your platform (\code{""UTF-8""} for Unix and \c
 Windows OS). Change encoding if specific chars are not properly displayed (e.g.) German umlauts).}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
-\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-of all style-sheet-classnames that are used in this function. Parameters for this list need:
-\enumerate{
-  \item the class-names with \code{""css.""}-prefix as parameter name and
-  \item each style-definition must end with a semicolon
-}
-You can add style information to the default styles by using a + (plus-sign) as
-initial character for the parameter attributes. Examples:
-\itemize{
-  \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-  \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-  \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
-  \item \code{css.summary='+color:blue;'} to add blue font color style to the summary row.
-}
-See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.}
+\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Detail'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
@@ -152,6 +138,29 @@ Invisibly returns
 \description{
 Shows contingency tables as HTML file in browser or viewer pane, or saves them as file.
 }
+\details{
+\bold{How does the \code{CSS}-parameter work?}
+           \cr \cr
+           With the \code{CSS}-paramater, the visual appearance of the tables
+           can be modified. To get an overview of all style-sheet-classnames
+           that are used in this function, see return value \code{page.style} for details.
+           Parameters for this list have following syntax:
+         \enumerate{
+           \item the class-names with \code{""css.""}-prefix as parameter name and
+           \item each style-definition must end with a semicolon
+         }
+         You can add style information to the default styles by using a + (plus-sign) as
+         initial character for the parameter attributes. Examples:
+         \itemize{
+           \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+           \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+           \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+           \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+           \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+           \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+         }
+         See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+}
 \note{
 The HTML tables can either be saved as file and manually opened (specify parameter \code{file}) or
         they can be saved as temporary files and will be displayed in the RStudio Viewer pane (if working with RStudio)

---FILE: man/view_spss.Rd---
@@ -50,21 +50,7 @@ Windows OS). Change encoding if specific chars are not properly displayed (e.g.)
 table is hidden. Default in \code{FALSE}, hence the bar is visible.}
 
 \item{CSS}{A \code{\link{list}} with user-defined style-sheet-definitions, according to the
-\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See return value \code{page.style} for details
-of all style-sheet-classnames that are used in this function. Parameters for this list need:
-\enumerate{
-  \item the class-names with \code{""css.""}-prefix as parameter name and
-  \item each style-definition must end with a semicolon
-}
-You can add style information to the default styles by using a + (plus-sign) as
-initial character for the parameter attributes. Examples:
-\itemize{
-  \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
-  \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
-  \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
-  \item \code{css.summary='+color:blue;'} to add blue font color style to the summary row.
-}
-See further examples below and \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.}
+\href{http://www.w3.org/Style/CSS/}{official CSS syntax}. See 'Details'.}
 
 \item{useViewer}{If \code{TRUE}, the function tries to show the HTML table in the IDE's viewer pane. If
 \code{FALSE} or no viewer available, the HTML table is opened in a web browser.}
@@ -95,6 +81,29 @@ Save (or show) content of an imported SPSS data file as HTML table.
                value labels. The result can be considered as ""codeplan"" of
                the data frame.
 }
+\details{
+\bold{How does the \code{CSS}-parameter work?}
+           \cr \cr
+           With the \code{CSS}-paramater, the visual appearance of the tables
+           can be modified. To get an overview of all style-sheet-classnames
+           that are used in this function, see return value \code{page.style} for details.
+           Parameters for this list have following syntax:
+         \enumerate{
+           \item the class-names with \code{""css.""}-prefix as parameter name and
+           \item each style-definition must end with a semicolon
+         }
+         You can add style information to the default styles by using a + (plus-sign) as
+         initial character for the parameter attributes. Examples:
+         \itemize{
+           \item \code{css.table='border:2px solid red;'} for a solid 2-pixel table border in red.
+           \item \code{css.summary='font-weight:bold;'} for a bold fontweight in the summary row.
+           \item \code{css.lasttablerow='border-bottom: 1px dotted blue;'} for a blue dotted border of the last table row.
+           \item \code{css.colnames='+color:green'} to add green color formatting to column names.
+           \item \code{css.arc='color:blue;'} for a blue text color each 2nd row.
+           \item \code{css.caption='+color:red;'} to add red font-color to the default table caption style.
+         }
+         See further examples at \href{http://www.strengejacke.de/sjPlot/sjtbasics}{sjPlot manual: sjt-basics}.
+}
 \examples{
 \dontrun{
 # init dataset"
strengejacke,sjPlot,daf2955bfea74c8586bd708f23fdbd1b1929ece8,Daniel Ldecke,d.luedecke@uke.de,2015-05-07T19:34:32Z,Daniel Ldecke,d.luedecke@uke.de,2015-05-07T19:34:32Z,"added more theme-presets to sjp.setTheme, fixed CRAN issue",DESCRIPTION;NEWS;R/sjPlotGLME.R;R/sjPlotSetTheme.R;R/sjTabOdds.R;README.md;man/sjPlot-package.Rd;man/sjp.setTheme.Rd;man/sjt.glmer.Rd,False,True,True,False,90,44,134,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.8-5
-Date: 2015-05-05
+Version: 1.8-6
+Date: 2015-05-07
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of several plotting and table output functions for visualizing data.

---FILE: NEWS---
@@ -1,4 +1,4 @@
-Version 1.8-5
+Version 1.8-6
 ------------------------------------------------------------------------------
 General:
 * Deprecated function ""sjp.emm.int"" was removed. Use ""sjp.int"" with parameter ""type = 'emm'"" to plot estimated marginal means.
@@ -11,6 +11,7 @@ New functions:
 Changes to functions:
 * Added 'type = ""probc""' to ""sjp.glm"" as alternative to 'type = ""prob""'. 'type = ""probc""' calculated predicted probabilities based on the ""predict"" function.
 * ""sjt.grpmean"" gets a ""weightBy"" parameter to compute weighted group-means.
+* Added white-background-alternative-themes of 538, 539 and scatter to ""sjp.setTheme"".
 
 Bug fixes:
 * Fixed bug with ""options(p_zero = TRUE)"", where leading zero was inserted after, instead of before decimal point.

---FILE: R/sjPlotGLME.R---
@@ -1,5 +1,5 @@
 # bind global variables
-if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""nQQ"", ""ci"", ""fixef"", ""fade"", ""lower.CI"", ""upper.CI"", ""pred"", ""prob"", ""p""))
+if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""nQQ"", ""ci"", ""fixef"", ""fade"", ""lower.CI"", ""upper.CI"", ""pred"", ""prob"", ""p"", ""CSS"", ""useViewer"", ""no.output""))
 
 
 #' @title Plot odds ratios (forest plots) of generalized linear mixed effects models

---FILE: R/sjPlotSetTheme.R---
@@ -86,7 +86,7 @@
 #' @param legend.backgroundcol Fill color of the legend's background. Default is \code{""white""}, so no visible background is drawn.
 #' @param legend.item.bordercol Color of the legend's item-border. Default is \code{""white""}.
 #' @param legend.item.backcol Fill color of the legend's item-background. Default is \code{""grey90""}.
-#' @param theme valid parameter for ggplot default-themes are:
+#' @param theme Specify pre-set themes (see 'Details'). Valid parameter for ggplot default-themes are:
 #'        \itemize{
 #'          \item \code{theme_bw}
 #'          \item \code{theme_classic}
@@ -103,15 +103,28 @@
 #'          \item \code{""538""}: a grey-scaled theme inspired by \href{http://fivethirtyeight.com}{538-charts}, adapted from \href{http://minimaxir.com/2015/02/ggplot-tutorial/}{minimaxir.com}.
 #'          \item \code{""539""}: a slight modification of the 538-theme.
 #'          \item \code{""scatter""}: a theme for scatter plots in 539-theme-style.
+#'          \item \code{""538w""}, \code{""539w""} and \code{""scatterw""} for themes as described above, however all with white backgrounds.
 #'          \item \code{""blues""}: a blue-colored scheme based on the Blues color-brewer-palette.
 #'          \item \code{""greens""}: a green-colored scheme.
 #'        }
 #' @param base Base theme where theme is built on. By default, all 
-#'          metrics from \code{theme_gray()} are used.
+#'          metrics from \code{theme_gray()} are used. See 'Details'
 #' 
 #' @return The customized theme object, or \code{NULL}, if a ggplot-theme
 #'           was used.
 #' 
+#' @details If the \code{theme} parameter is one of the valid ggplot-themes, this theme
+#'            will be used and all further parameters will be ignored. If you want to modify
+#'            a ggplot-theme, use \code{base = ""theme_xy""} and then further parameters to
+#'            this function will be applied to the theme as well.
+#'            \cr \cr
+#'            If the \code{theme} parameter is one of sjPlot-pre-set-themes, you
+#'            can use further parameters for specific customization of the theme.
+#'            \emph{sjPlot-pre-set-themes won't work with the \code{base} parameter!}
+#'            The \code{base} parameter is only intended to select a ggplot-theme
+#'            as base for further modifications (which can be triggered via the
+#'            various function parameters).
+#' 
 #' @seealso \href{http://www.strengejacke.de/sjPlot/custplot/}{sjPlot manual: customize plot appearance}
 #' 
 #' @references \itemize{
@@ -134,10 +147,10 @@
 #'          efc$e16sex,
 #'          showTableSummary = FALSE)
 #' 
-#' # Use classic-theme as base. you may need to
+#' # Use classic-theme. you may need to
 #' # load the ggplot2-library.
 #' library(ggplot2)
-#' sjp.setTheme(base = theme_classic())
+#' sjp.setTheme(theme = theme_classic())
 #' sjp.frq(efc$e42dep)
 #' 
 #' # adjust value labels
@@ -256,27 +269,35 @@ sjp.setTheme <- function(title.color=""black"",
   # check for blank theme, i.e. if user requires special
   # theme without any grids or axis lines
   # ----------------------------------------  
-  if (!is.null(theme) && theme==""blank"") {
+  if (!is.null(theme) && theme == ""blank"") {
     base <- theme_classic()
     axis.linecolor <- ""white""
     axis.ticksol <- ""white""
     panel.gridcol <- ""white""
     plot.col <- ""white""
   }
-  if (!is.null(theme) && theme==""forest"") {
+  # ----------------------------------------  
+  # check for forset theme. based on theme_bw,
+  # this theme has no grids
+  # ----------------------------------------  
+  if (!is.null(theme) && theme == ""forest"") {
     base <- theme_bw()
     panel.gridcol <- ""white""
     axis.tickslen <- 0
   }  
-  if (!is.null(theme) && theme==""538"") {
+  # ----------------------------------------  
+  # check for grey-scaled 538 theme.
+  # ----------------------------------------  
+  if (!is.null(theme) && (theme == ""538"" || theme == ""538w"")) {
     base <- theme_bw()
     g.palette <- scales::brewer_pal(palette = ""Greys"")(9)
-    panel.bordercol <- panel.backcol <- panel.col <- g.palette[2]
-    plot.backcol <- plot.bordercol <- plot.col <- g.palette[2]
+    col.ind <- ifelse(theme == ""538"", 2, 1)
+    panel.bordercol <- panel.backcol <- panel.col <- g.palette[col.ind]
+    plot.backcol <- plot.bordercol <- plot.col <- g.palette[col.ind]
+    panel.minor.gridcol <- g.palette[col.ind]
+    axis.linecolor.x  <- axis.linecolor.y <- axis.linecolor <- g.palette[col.ind]
+    legend.item.backcol <- legend.item.bordercol <- legend.backgroundcol <- legend.bordercol <- g.palette[col.ind]
     panel.major.gridcol <- g.palette[4]
-    panel.minor.gridcol <- g.palette[2]
-    axis.linecolor.x  <- axis.linecolor.y <- axis.linecolor <- g.palette[2]
-    legend.item.backcol <- legend.item.bordercol <- legend.backgroundcol <- legend.bordercol <- g.palette[2]
     title.color <- g.palette[9]
     axis.textcolor <- g.palette[6]
     axis.title.color <- g.palette[7]
@@ -292,22 +313,27 @@ sjp.setTheme <- function(title.color=""black"",
     plot.margins <- unit(c(1, .5, 1, 0.5), ""cm"")
     message(""Theme '538' looks better with panel margins. You may want to use parameter 'expand.grid = TRUE' in sjp-functions."")
   }  
-  if (!is.null(theme) && (theme == ""539"" || theme == ""forestgrey"")) {
+  # ----------------------------------------  
+  # check for grey-scaled 539 theme, which are
+  # alternatives to 538
+  # ----------------------------------------  
+  if (!is.null(theme) && (theme == ""539"" || theme == ""539w"" || theme == ""forestgrey"")) {
     base <- theme_bw()
     g.palette <- scales::brewer_pal(palette = ""Greys"")(9)
-    panel.bordercol <- panel.backcol <- panel.col <- g.palette[2]
-    plot.backcol <- plot.bordercol <- plot.col <- g.palette[2]
-    if (theme == ""539"") {
+    col.ind <- ifelse(theme == ""539w"", 1, 2)
+    panel.bordercol <- panel.backcol <- panel.col <- g.palette[col.ind]
+    plot.backcol <- plot.bordercol <- plot.col <- g.palette[col.ind]
+    if (theme == ""539"" || theme == ""539w"") {
       panel.major.gridcol <- g.palette[4]
-      panel.minor.gridcol <- g.palette[2]
-      panel.gridcol.x <- g.palette[2]
+      panel.minor.gridcol <- g.palette[col.ind]
+      panel.gridcol.x <- g.palette[col.ind]
     } else {
-      panel.major.gridcol <- panel.minor.gridcol <- g.palette[2]
+      panel.major.gridcol <- panel.minor.gridcol <- g.palette[col.ind]
     }
     axis.linecolor <- NULL
-    if (is.null(axis.linecolor.y)) axis.linecolor.y <- g.palette[2]
+    if (is.null(axis.linecolor.y)) axis.linecolor.y <- g.palette[col.ind]
     if (is.null(axis.linecolor.x)) axis.linecolor.x <- g.palette[9]
-    legend.item.backcol <- legend.item.bordercol <- legend.backgroundcol <- legend.bordercol <- g.palette[2]
+    legend.item.backcol <- legend.item.bordercol <- legend.backgroundcol <- legend.bordercol <- g.palette[col.ind]
     title.color <- g.palette[9]
     axis.textcolor <- g.palette[6]
     axis.title.color <- g.palette[7]
@@ -322,16 +348,21 @@ sjp.setTheme <- function(title.color=""black"",
     title.vjust <- 1.75
     plot.margins <- unit(c(1, .5, 1, 0.5), ""cm"")
   }  
-  if (!is.null(theme) && theme==""scatter"") {
+  # ----------------------------------------  
+  # check for scatter, a theme with crossed
+  # grids and based on 538
+  # ----------------------------------------  
+  if (!is.null(theme) && (theme == ""scatter"" || theme == ""scatterw"")) {
     base <- theme_bw()
+    col.ind <- ifelse(theme == ""scatterw"", 1, 2)
     g.palette <- scales::brewer_pal(palette = ""Greys"")(9)
-    panel.bordercol <- panel.backcol <- panel.col <- g.palette[2]
-    plot.backcol <- plot.bordercol <- plot.col <- g.palette[2]
+    panel.bordercol <- panel.backcol <- panel.col <- g.palette[col.ind]
+    plot.backcol <- plot.bordercol <- plot.col <- g.palette[col.ind]
     panel.major.gridcol <- panel.minor.gridcol <- g.palette[4]
     axis.linecolor <- g.palette[5]
-    if (is.null(axis.linecolor.y)) axis.linecolor.y <- g.palette[2]
-    if (is.null(axis.linecolor.x)) axis.linecolor.x <- g.palette[2]
-    legend.item.backcol <- legend.item.bordercol <- legend.backgroundcol <- legend.bordercol <- g.palette[2]
+    if (is.null(axis.linecolor.y)) axis.linecolor.y <- g.palette[col.ind]
+    if (is.null(axis.linecolor.x)) axis.linecolor.x <- g.palette[col.ind]
+    legend.item.backcol <- legend.item.bordercol <- legend.backgroundcol <- legend.bordercol <- g.palette[col.ind]
     title.color <- g.palette[9]
     axis.textcolor <- g.palette[6]
     axis.title.color <- g.palette[7]
@@ -655,7 +686,7 @@ sjp.setTheme <- function(title.color=""black"",
     theme_set(sjtheme)
   }
   else {
-    warning(""Either 'theme' or 'base' must be supplied as ggplot-theme-object to set global theme options for sjPlot."")
+    warning(""Either 'theme' or 'base' must be supplied as ggplot-theme-object to set global theme options for sjPlot."", call. = F)
   }
   
   # ----------------------------------------

---FILE: R/sjTabOdds.R---
@@ -1372,7 +1372,6 @@ sjt.glmer <- function(...,
                      showStdError=FALSE,
                      separateConfColumn=TRUE,
                      newLineConf=TRUE,
-                     group.pred=TRUE,
                      showAbbrHeadline=TRUE,
                      showICC=TRUE,
                      showLogLik=FALSE,

---FILE: README.md---
@@ -30,7 +30,7 @@ install.packages(""sjPlot"")
 
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since this package makes heavy use of the [ggplot-package](http://cran.r-project.org/web/packages/ggplot2/index.html), consider citing this package as well.
 
-### Changelog of current development snapshot 1.8-4
+### Changelog of current development snapshot 1.8-6
 
 #### General
 * Deprecated function `sjp.emm.int` was removed. Use `sjp.int` with parameter `type = 'emm'` to plot estimated marginal means.
@@ -43,6 +43,7 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 #### Changes to functions
 * Added `type = ""probc""` to `sjp.glm` as alternative to `type = ""prob""`. `type = ""probc""` calculated predicted probabilities based on the `predict` function.
 * `sjt.grpmean` gets a `weightBy` parameter to compute weighted group-means.
+* Added white-background-alternative-themes of 538, 539 and scatter to `sjp.setTheme`.
 
 #### Bug fixes
 * Fixed bug with `options(p_zero = TRUE)`, where leading zero was inserted after, instead of before decimal point.

---FILE: man/sjPlot-package.Rd---
@@ -34,8 +34,8 @@
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.8-5\cr
-Date: \tab 2015-05-05\cr
+Version: \tab 1.8-6\cr
+Date: \tab 2015-05-07\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjp.setTheme.Rd---
@@ -169,7 +169,7 @@ legend justification is set according to legend position.}
 
 \item{legend.item.bordercol}{Color of the legend's item-border. Default is \code{""white""}.}
 
-\item{theme}{valid parameter for ggplot default-themes are:
+\item{theme}{Specify pre-set themes (see 'Details'). Valid parameter for ggplot default-themes are:
 \itemize{
   \item \code{theme_bw}
   \item \code{theme_classic}
@@ -186,12 +186,13 @@ Furthermore, there are some theme-presets, which can be used:
   \item \code{""538""}: a grey-scaled theme inspired by \href{http://fivethirtyeight.com}{538-charts}, adapted from \href{http://minimaxir.com/2015/02/ggplot-tutorial/}{minimaxir.com}.
   \item \code{""539""}: a slight modification of the 538-theme.
   \item \code{""scatter""}: a theme for scatter plots in 539-theme-style.
+  \item \code{""538w""}, \code{""539w""} and \code{""scatterw""} for themes as described above, however all with white backgrounds.
   \item \code{""blues""}: a blue-colored scheme based on the Blues color-brewer-palette.
   \item \code{""greens""}: a green-colored scheme.
 }}
 
 \item{base}{Base theme where theme is built on. By default, all
-         metrics from \code{theme_gray()} are used.}
+         metrics from \code{theme_gray()} are used. See 'Details'}
 }
 \value{
 The customized theme object, or \code{NULL}, if a ggplot-theme
@@ -200,6 +201,19 @@ The customized theme object, or \code{NULL}, if a ggplot-theme
 \description{
 Set global theme options for sjp-functions.
 }
+\details{
+If the \code{theme} parameter is one of the valid ggplot-themes, this theme
+           will be used and all further parameters will be ignored. If you want to modify
+           a ggplot-theme, use \code{base = ""theme_xy""} and then further parameters to
+           this function will be applied to the theme as well.
+           \cr \cr
+           If the \code{theme} parameter is one of sjPlot-pre-set-themes, you
+           can use further parameters for specific customization of the theme.
+           \emph{sjPlot-pre-set-themes won't work with the \code{base} parameter!}
+           The \code{base} parameter is only intended to select a ggplot-theme
+           as base for further modifications (which can be triggered via the
+           various function parameters).
+}
 \examples{
 \dontrun{
 library(sjmisc)
@@ -215,10 +229,10 @@ sjp.xtab(efc$e42dep,
          efc$e16sex,
          showTableSummary = FALSE)
 
-# Use classic-theme as base. you may need to
+# Use classic-theme. you may need to
 # load the ggplot2-library.
 library(ggplot2)
-sjp.setTheme(base = theme_classic())
+sjp.setTheme(theme = theme_classic())
 sjp.frq(efc$e42dep)
 
 # adjust value labels

---FILE: man/sjt.glmer.Rd---
@@ -14,10 +14,10 @@ sjt.glmer(..., file = NULL, labelPredictors = NULL,
   digits.se = 2, digits.summary = 3, exp.coef = TRUE,
   pvaluesAsNumbers = TRUE, boldpvalues = TRUE, showConfInt = TRUE,
   showStdError = FALSE, separateConfColumn = TRUE, newLineConf = TRUE,
-  group.pred = TRUE, showAbbrHeadline = TRUE, showICC = TRUE,
-  showLogLik = FALSE, showAIC = FALSE, showFamily = FALSE,
-  remove.estimates = NULL, cellSpacing = 0.2, encoding = NULL,
-  CSS = NULL, useViewer = TRUE, no.output = FALSE, remove.spaces = TRUE)
+  showAbbrHeadline = TRUE, showICC = TRUE, showLogLik = FALSE,
+  showAIC = FALSE, showFamily = FALSE, remove.estimates = NULL,
+  cellSpacing = 0.2, encoding = NULL, CSS = NULL, useViewer = TRUE,
+  no.output = FALSE, remove.spaces = TRUE)
 }
 \arguments{
 \item{...}{One or more mixed models fitted with \code{\link[lme4]{glmer}}.}"
strengejacke,sjPlot,c8933860837fc9720c555524a53edd482b440763,Daniel Ldecke,d.luedecke@uke.de,2015-05-07T19:02:50Z,Daniel Ldecke,d.luedecke@uke.de,2015-05-07T19:02:50Z,fixed bug in sjt.(g)lmer,R/sjTabLinReg.R;R/sjTabOdds.R,False,True,True,False,2,52,54,"---FILE: R/sjTabLinReg.R---
@@ -681,22 +681,6 @@ sjt.lm <- function (...,
       })
     }
     # -------------------------------------
-    # retrieve factors and number of levels
-    # -------------------------------------
-    if (lmerob) {
-      # find fixed effects in model frame
-      fe.pos <- which(names(lme4::fixef(fit)) %in% colnames(fit@frame))
-      # copy intercept and fixed effects of model
-      fit.model <- data.frame(cbind(y = lme4::getME(fit, ""y""),
-                                    fit@frame[, fe.pos]))
-    } else {
-      fit.model <- fit$model
-    }
-    for (f in 1:ncol(fit.model)) {
-      fit.df$is_fac[f] <- is.factor(fit.model[[f]])
-      fit.df$fac_lvl[f] <- length(levels(fit.model[[f]]))
-    }
-    # -------------------------------------
     # set column names. we need the same name
     # for first column witrh coefficient names
     # and different column names for all model-statistics.
@@ -711,9 +695,7 @@ sjt.lm <- function (...,
                           sprintf(""se%i"", i),
                           sprintf(""std.beta%i"", i),
                           sprintf(""std.beta.ci.lo%i"", i),
-                          sprintf(""std.beta.ci.hi%i"", i),
-                          sprintf(""categorical%i"", i),
-                          sprintf(""fac.levels%i"", i))
+                          sprintf(""std.beta.ci.hi%i"", i))
     # -------------------------------------
     # add to df list
     # -------------------------------------
@@ -768,13 +750,6 @@ sjt.lm <- function (...,
     joined.df <- dplyr::slice(joined.df, keep.estimates)
   }
   # -------------------------------------
-  # remove all variables with factor status 
-  # and levels from joined.df
-  # -------------------------------------
-  joined.df <- dplyr::select(joined.df, 
-                             -c(starts_with(""categorical""), 
-                               starts_with(""fac.levels"")))
-  # -------------------------------------
   # if confidence interval should be omitted,
   # don't use separate column for CI!
   # -------------------------------------

---FILE: R/sjTabOdds.R---
@@ -579,22 +579,6 @@ sjt.glm <- function(...,
       })
     }
     # -------------------------------------
-    # retrieve factors and number of levels
-    # -------------------------------------
-    if (lmerob) {
-      # find fixed effects in model frame
-      fe.pos <- which(names(lme4::fixef(fit)) %in% colnames(fit@frame))
-      # copy intercept and fixed effects of model
-      fit.model <- data.frame(cbind(y = lme4::getME(fit, ""y""),
-                                    fit@frame[, fe.pos]))
-    } else {
-      fit.model <- fit$model
-    }
-    for (f in 1:ncol(fit.model)) {
-      fit.df$is_fac[f] <- is.factor(fit.model[[f]])
-      fit.df$fac_lvl[f] <- length(levels(fit.model[[f]]))
-    }
-    # -------------------------------------
     # set column names. we need the same name
     # for first column witrh coefficient names
     # and different column names for all model-statistics.
@@ -606,9 +590,7 @@ sjt.glm <- function(...,
                           sprintf(""ci.lo%i"", i),
                           sprintf(""ci.hi%i"", i),
                           sprintf(""p-value%i"", i),
-                          sprintf(""se%i"", i),
-                          sprintf(""categorical%i"", i),
-                          sprintf(""fac.levels%i"", i))
+                          sprintf(""se%i"", i))
     # -------------------------------------
     # add to df list
     # -------------------------------------
@@ -662,13 +644,6 @@ sjt.glm <- function(...,
     joined.df <- dplyr::slice(joined.df, keep.estimates)
   }
   # -------------------------------------
-  # remove all variables with factor status 
-  # and levels from joined.df
-  # -------------------------------------
-  joined.df <- dplyr::select(joined.df, 
-                             -c(starts_with(""categorical""), 
-                                starts_with(""fac.levels"")))
-  # -------------------------------------
   # if confidence interval should be omitted,
   # don't use separate column for CI!
   # -------------------------------------"
strengejacke,sjPlot,c12b8fbae5bb02ef8c40bbce8e3e3248568271e6,Daniel Ldecke,d.luedecke@uke.de,2015-05-07T18:11:16Z,Daniel Ldecke,d.luedecke@uke.de,2015-05-07T18:11:16Z,bug fix option(p_zero = TRUE),NEWS;R/sjTabGrpmean.R;R/sjTabLinReg.R;R/sjTabOdds.R;R/sjTabPropTable.R;README.md;man/sjt.grpmean.Rd,False,True,True,False,65,25,90,"---FILE: NEWS---
@@ -10,10 +10,13 @@ New functions:
 
 Changes to functions:
 * Added 'type = ""probc""' to ""sjp.glm"" as alternative to 'type = ""prob""'. 'type = ""probc""' calculated predicted probabilities based on the ""predict"" function.
+* ""sjt.grpmean"" gets a ""weightBy"" parameter to compute weighted group-means.
 
 Bug fixes:
+* Fixed bug with ""options(p_zero = TRUE)"", where leading zero was inserted after, instead of before decimal point.
 * Fixed formatting bug for pseudo-R2 in ""sjt.glm"".
 * Fixed bug in ""sjp.likert"" when data frame had only one column.
+* Fixed bug in ""sjt.frq"" when a data frame contained variables with only NA values.
 
 Version 1.8
 ------------------------------------------------------------------------------

---FILE: R/sjTabGrpmean.R---
@@ -8,6 +8,9 @@
 #' 
 #' @param varCount a numeric vector / variable. Mean, SD and SE for this variable are calculated.
 #' @param varGrp a (numeric) vector with group indices, used to select sub-groups from \code{varCount}.
+#' @param weightBy A weight factor that will be applied to weight all cases.
+#'          Must be a vector of same length as \code{varCount}. Default is \code{NULL}, 
+#'          so no weights are used.
 #' @param rowLabels a character vector of same length as \code{varGrp} unqiue values. In short: the
 #'          value labels of \code{varGrp}. Used to name table rows. By default, row labels
 #'          are automatically detected if set by \code{\link[sjmisc]{set_val_labels}}.
@@ -63,6 +66,7 @@
 #' @export
 sjt.grpmean <- function(varCount, 
                         varGrp, 
+                        weightBy = NULL,
                         rowLabels=NULL, 
                         digits=2,
                         digits.summary = 3,
@@ -101,9 +105,15 @@ sjt.grpmean <- function(varCount,
   # compute anova statistics for mean table
   # see below
   # --------------------------------------
-  fit <- aov(varCount ~ as.factor(varGrp))
+  if (!is.null(weightBy)) {
+    fit <- lm(varCount ~ as.factor(varGrp), weights = weightBy)
+  } else {
+    fit <- lm(varCount ~ as.factor(varGrp))
+  }
+  # get model summary
+  sum.fit <- summary(fit)
   # p-values of means
-  means.p <- summary.lm(fit)$coefficients[, 4]
+  means.p <- sum.fit$coefficients[, 4]
   pval <- c()
   # convert means to apa style
   for (i in 1:length(means.p)) {
@@ -122,23 +132,43 @@ sjt.grpmean <- function(varCount,
   # iterate all groups
   # --------------------------------------
   for (i in 1:length(indices)) {
+    # --------------------------------------
+    # do we have weighted means?
+    # --------------------------------------
+    if (!is.null(weightBy)) {
+      mw <- weighted.mean(varCount[varGrp == indices[i]], 
+                          w = weightBy[varGrp == indices[i]],
+                          na.rm = TRUE)
+    } else {
+      mw <- mean(varCount[varGrp == indices[i]], na.rm = TRUE)
+    }
     # --------------------------------------
     # add new row to data frame with
     # mean, N, sd and se of varCount for each
     # sub-group (indicated by indices)
     # --------------------------------------
     df <- rbind(df, 
-                cbind(mean = sprintf(""%.*f"", digits, mean(varCount[varGrp == indices[i]], na.rm = TRUE)),
+                cbind(mean = sprintf(""%.*f"", digits, mw),
                       N = length(na.omit(varCount[varGrp == indices[i]])),
                       sd = sprintf(""%.*f"", digits, sd(varCount[varGrp == indices[i]], na.rm = TRUE)),
                       se = sprintf(""%.*f"", digits, sjmisc::std_e(varCount[varGrp == indices[i]])),
                       p = pval[i]))
   }
   # --------------------------------------
+  # do we have weighted means?
+  # --------------------------------------
+  if (!is.null(weightBy)) {
+    mw <- weighted.mean(varCount, 
+                        w = weightBy,
+                        na.rm = TRUE)
+  } else {
+    mw <- mean(varCount, na.rm = TRUE)
+  }
+  # --------------------------------------
   # finally, add total-row
   # --------------------------------------
   df <- rbind(df, 
-              cbind(mean = sprintf(""%.*f"", digits, mean(varCount, na.rm = TRUE)),
+              cbind(mean = sprintf(""%.*f"", digits, mw),
                     N = length(na.omit(varCount)),
                     sd = sprintf(""%.*f"", digits, sd(varCount, na.rm = TRUE)),
                     se = sprintf(""%.*f"", digits, sjmisc::std_e(varCount)),
@@ -152,13 +182,13 @@ sjt.grpmean <- function(varCount,
   # get anova statistics for mean table
   # --------------------------------------
   # multiple r2
-  r2 <- summary.lm(fit)$r.squared
+  r2 <- sum.fit$r.squared
   # adj. r2
-  r2.adj <- summary.lm(fit)$adj.r.squared
+  r2.adj <- sum.fit$adj.r.squared
   # get F-statistics
-  fstat <- summary.lm(fit)$fstatistic[1]
+  fstat <- sum.fit$fstatistic[1]
   # p-value for F-test
-  pval <- summary(fit)[[1]]['Pr(>F)'][1, 1]
+  pval <- sjmisc:::lm_pval_fstat(fit)
   pvalstring <- ifelse(pval < 0.001, 
                        sprintf(""p&lt;%s.001"", p_zero), 
                        sub(""0"", p_zero, sprintf(""p=%.*f"", digits.summary, pval)))
@@ -175,8 +205,8 @@ sjt.grpmean <- function(varCount,
                  CSS = CSS,
                  encoding = encoding,
                  hideProgressBar = TRUE,
-                 commentString = gsub(""0."", 
-                                      paste0(""."", p_zero), 
+                 commentString = gsub(""=0."", 
+                                      paste0(""="", p_zero, "".""), 
                                       sprintf(""<strong>Anova:</strong> R<sup>2</sup>=%.*f &middot; adj. R<sup>2</sup>=%.*f &middot; F=%.*f &middot; %s"",
                                               digits.summary, r2, digits.summary, r2.adj, digits.summary, fstat, pvalstring),
                                       fixed = TRUE),
@@ -185,10 +215,10 @@ sjt.grpmean <- function(varCount,
   # check if html-content should be printed
   # -------------------------------------
   out.html.table(no.output, file, html$knitr, html$output.complete, useViewer)  
-  invisible (list(class = ""sjtgrpmean"",
-                  df = df, 
-                  page.style = html$page.style,
-                  page.content = html$page.content,
-                  knitr = html$knitr,
-                  output.complete = html$output.complete))
+  invisible(list(class = ""sjtgrpmean"",
+                 df = df, 
+                 page.style = html$page.style,
+                 page.content = html$page.content,
+                 knitr = html$knitr,
+                 output.complete = html$output.complete))
 }
\ No newline at end of file

---FILE: R/sjTabLinReg.R---
@@ -1242,7 +1242,7 @@ sjt.lm <- function (...,
       rsqu <- summary(input_list[[i]])$r.squared
       adjrsqu <- summary(input_list[[i]])$adj.r.squared
       page.content <- paste0(page.content, gsub(""0."", 
-                                                paste0(""."", p_zero), 
+                                                paste0(p_zero, "".""), 
                                                 sprintf(""    %s%.*f / %.*f</td>\n"", colspanstring, digits.summary, rsqu, digits.summary, adjrsqu),
                                                 fixed = TRUE))
     }

---FILE: R/sjTabOdds.R---
@@ -1073,7 +1073,7 @@ sjt.glm <- function(...,
       page.content <- paste0(page.content, ""\n    <td class=\""separatorcol\"">&nbsp;</td>"")
       psr <- PseudoR2(input_list[[i]])
       page.content <- paste0(page.content, gsub(""0."", 
-                                                paste0(""."", p_zero),
+                                                paste0(p_zero, "".""),
                                                 sprintf(""%sR<sup>2</sup><sub>CS</sub> = %.*f<br>R<sup>2</sup><sub>N</sub> = %.*f</td>"", colspanstring, digits.summary, psr[2], digits.summary, psr[3]),
                                                 fixed = TRUE))
     }

---FILE: R/sjTabPropTable.R---
@@ -705,14 +705,14 @@ sjt.xtab <- function (var.row,
     if (nrow(tab) > 2 || ncol(tab) > 2) {
       kook <- sprintf(""&Phi;<sub>c</sub>=%.3f"", sjmisc::cramer(tab))
       # if minimum expected values below 5, compute fisher's exact test
-      if(min(tab.expected) < 5 || (min(tab.expected) < 10 && chsq$parameter == 1)) fish <- fisher.test(tab, simulate.p.value = TRUE)
+      if (min(tab.expected) < 5 || (min(tab.expected) < 10 && chsq$parameter == 1)) fish <- fisher.test(tab, simulate.p.value = TRUE)
     } else {
       kook <- sprintf(""&Phi;=%.3f"", sjmisc::phi(tab))
       # if minimum expected values below 5 and df=1, compute fisher's exact test
-      if(min(tab.expected) < 5 || (min(tab.expected) < 10 && chsq$parameter == 1)) fish <- fisher.test(tab)
+      if (min(tab.expected) < 5 || (min(tab.expected) < 10 && chsq$parameter == 1)) fish <- fisher.test(tab)
     }
     # make phi-value apa style
-    kook <- gsub(""0."", paste0(""."", p_zero), kook, fixed = TRUE)
+    kook <- gsub(""0."", paste0(p_zero, "".""), kook, fixed = TRUE)
     # create summary row
     if (is.null(fish)) {
       pvalstring <- ifelse(chsq$p.value < 0.001, sprintf(""p&lt;%s.001"", p_zero), sub(""0"", p_zero, sprintf(""p=%.3f"", chsq$p.value)))

---FILE: README.md---
@@ -42,7 +42,10 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 
 #### Changes to functions
 * Added `type = ""probc""` to `sjp.glm` as alternative to `type = ""prob""`. `type = ""probc""` calculated predicted probabilities based on the `predict` function.
+* `sjt.grpmean` gets a `weightBy` parameter to compute weighted group-means.
 
 #### Bug fixes
+* Fixed bug with `options(p_zero = TRUE)`, where leading zero was inserted after, instead of before decimal point.
 * Fixed formatting bug for pseudo-R2 in `sjt.glm`.
-* Fixed bug in `sjp.likert` when data frame had only one column.
\ No newline at end of file
+* Fixed bug in `sjp.likert` when data frame had only one column.
+* Fixed bug in `sjt.frq` when a data frame contained variables with only NA values.
\ No newline at end of file

---FILE: man/sjt.grpmean.Rd---
@@ -4,15 +4,19 @@
 \alias{sjt.grpmean}
 \title{Show grouped means as HTML table}
 \usage{
-sjt.grpmean(varCount, varGrp, rowLabels = NULL, digits = 2,
-  digits.summary = 3, file = NULL, encoding = NULL, CSS = NULL,
-  useViewer = TRUE, no.output = FALSE, remove.spaces = TRUE)
+sjt.grpmean(varCount, varGrp, weightBy = NULL, rowLabels = NULL,
+  digits = 2, digits.summary = 3, file = NULL, encoding = NULL,
+  CSS = NULL, useViewer = TRUE, no.output = FALSE, remove.spaces = TRUE)
 }
 \arguments{
 \item{varCount}{a numeric vector / variable. Mean, SD and SE for this variable are calculated.}
 
 \item{varGrp}{a (numeric) vector with group indices, used to select sub-groups from \code{varCount}.}
 
+\item{weightBy}{A weight factor that will be applied to weight all cases.
+Must be a vector of same length as \code{varCount}. Default is \code{NULL},
+so no weights are used.}
+
 \item{rowLabels}{a character vector of same length as \code{varGrp} unqiue values. In short: the
 value labels of \code{varGrp}. Used to name table rows. By default, row labels
 are automatically detected if set by \code{\link[sjmisc]{set_val_labels}}.}"
strengejacke,sjPlot,861d2f16d10d0992954e1f25c27e48255114831c,Daniel Ldecke,d.luedecke@uke.de,2015-05-02T15:25:30Z,Daniel Ldecke,d.luedecke@uke.de,2015-05-02T15:25:30Z,minor bug fix in sjt.(g)lmer,R/sjTabLinReg.R;R/sjTabOdds.R;tests/testthat/test_sjtlm.R,False,True,True,False,55,4,59,"---FILE: R/sjTabLinReg.R---
@@ -840,7 +840,9 @@ sjt.lm <- function (...,
   # -------------------------------------
   if (!is.null(labelDependentVariables)) {
     for (i in 1:length(labelDependentVariables)) {
+      # -------------------------
       # insert ""separator column""
+      # -------------------------
       page.content <- paste0(page.content, sprintf(""\n    <td class=\""separatorcol%s\"">&nbsp;</td>"", tcp))
       if (headerColSpanFactor > 1) {
         page.content <- paste0(page.content, 
@@ -858,8 +860,10 @@ sjt.lm <- function (...,
     page.content <- paste0(page.content, ""\n  </tr>"")
   } else {
     for (i in 1:length(input_list)) {
+      # -------------------------
       # insert ""separator column""
-      page.content <- paste0(page.content, sprintf(""\n    <td class=\""separatorcol labelcellborder%s\"">&nbsp;</td>"", tcp))
+      # -------------------------
+      page.content <- paste0(page.content, sprintf(""\n    <td class=\""separatorcol%s\"">&nbsp;</td>"", tcp))
       if (headerColSpanFactor > 1) {
         page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign labelcellborder%s\"" colspan=\""%i\"">%s %i</td>"", 
                                                      tcp, 
@@ -880,7 +884,9 @@ sjt.lm <- function (...,
     page.content <- paste0(page.content, ""\n  <tr>\n    <td class=\""tdata colnames\"">&nbsp;</td>"")
     colnr <- ifelse(is.null(labelDependentVariables), length(input_list), length(labelDependentVariables))
     for (i in 1:colnr) {
+      # -------------------------
       # insert ""separator column""
+      # -------------------------
       page.content <- paste0(page.content, ""<td class=\""separatorcol colnames\"">&nbsp;</td>"")
       # confidence interval in separate column
       if (showEst) {
@@ -962,7 +968,9 @@ sjt.lm <- function (...,
                                                tcb_class, 
                                                stringIntercept))
   for (i in 1:length(input_list)) {
+    # -------------------------
     # insert ""separator column""
+    # -------------------------
     page.content <- paste0(page.content, sprintf(""<td class=\""separatorcol %s\"">&nbsp;</td>"", tcb_class))
     # show estimates?
     if (showEst) {
@@ -1046,7 +1054,9 @@ sjt.lm <- function (...,
     # go through fitted model's statistics
     # ---------------------------------------
     for (j in 1:length(input_list)) {
+      # -------------------------
       # insert ""separator column""
+      # -------------------------
       page.content <- paste0(page.content, ""<td class=\""separatorcol\"">&nbsp;</td>"")
       # show estimates?
       if (showEst) {
@@ -1057,9 +1067,10 @@ sjt.lm <- function (...,
         # we don't print CI-separator strings and we don't print any esitmate
         # values - however, for proper display, we fill these values with ""&nbsp;""
         ci.sep.string <- ifelse(is_empty(ci.lo), ""&nbsp;"", ""&nbsp;-&nbsp;"")
-        # replace empty beta and p-values with &nbsp;
+        # replace empty beta, se and p-values with &nbsp;
         if (is_empty(joined.df[i + 1, (j - 1) * 8 + 2])) joined.df[i + 1, (j - 1) * 8 + 2] <- ""&nbsp;""
         if (is_empty(joined.df[i + 1, (j - 1) * 8 + 5])) joined.df[i + 1, (j - 1) * 8 + 5] <- ""&nbsp;""
+        if (is_empty(joined.df[i + 1, (j - 1) * 8 + 6])) joined.df[i + 1, (j - 1) * 8 + 6] <- ""&nbsp;""
         # confidence interval in separate column
         if (separateConfColumn) {
           # open table cell for Beta-coefficient
@@ -1158,7 +1169,9 @@ sjt.lm <- function (...,
       page.content <- paste0(page.content, sprintf(""\n  <tr>\n    <td class=\""tdata summary leftalign\"">N<sub>%s</sub></td>\n"", names(mmgrps[gl])))
       # iterate models
       for (i in 1:length(input_list)) {
+        # -------------------------
         # insert ""separator column""
+        # -------------------------
         page.content <- paste0(page.content, ""<td class=\""separatorcol\"">&nbsp;</td>"")
         # retrieve random intercepts of each model
         sub.mmgrps <- lme4::getME(input_list[[i]], ""flist"")
@@ -1183,7 +1196,9 @@ sjt.lm <- function (...,
         page.content <- paste0(page.content, sprintf(""  <tr>\n    <td class=\""tdata leftalign summary\"">ICC<sub>%s</sub></td>\n"", names(summary.icc[si])))
         # iterate models
         for (i in 1:length(input_list)) {
+          # -------------------------
           # insert ""separator column""
+          # -------------------------
           page.content <- paste0(page.content, ""<td class=\""separatorcol\"">&nbsp;</td>"")
           # get icc from models
           sub.summary.icc <- sjmisc::icc(input_list[[i]])
@@ -1205,7 +1220,9 @@ sjt.lm <- function (...,
   # -------------------------------------
   page.content <- paste0(page.content, sprintf(""\n  <tr>\n    <td class=\""tdata summary leftalign firstsumrow\"">%s</td>\n"", stringObservations))
   for (i in 1:length(input_list)) {
+    # -------------------------
     # insert ""separator column""
+    # -------------------------
     page.content <- paste0(page.content, ""<td class=\""separatorcol firstsumrow\"">&nbsp;</td>"")
     page.content <- paste(page.content, sprintf(""   %s%i</td>\n"", colspanstringfirstrow, nobs(input_list[[i]])))
   }
@@ -1216,7 +1233,9 @@ sjt.lm <- function (...,
   if (showR2) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">R<sup>2</sup> / adj. R<sup>2</sup></td>\n"")
     for (i in 1:length(input_list)) {
+      # -------------------------
       # insert ""separator column""
+      # -------------------------
       page.content <- paste0(page.content, ""\n    <td class=\""separatorcol\"">&nbsp;</td>"")
       rsqu <- summary(input_list[[i]])$r.squared
       adjrsqu <- summary(input_list[[i]])$adj.r.squared
@@ -1233,7 +1252,9 @@ sjt.lm <- function (...,
   if (showFStat) {
     page.content <- paste(page.content, ""  <tr>\n     <td class=\""tdata leftalign summary\"">F-statistics</td>\n"")
     for (i in 1:length(input_list)) {
+      # -------------------------
       # insert ""separator column""
+      # -------------------------
       page.content <- paste0(page.content, ""\n    <td class=\""separatorcol\"">&nbsp;</td>"")
       fstat <- summary(input_list[[i]])$fstatistic
       # Calculate p-value for F-test
@@ -1260,7 +1281,9 @@ sjt.lm <- function (...,
   if (showAIC) {
     page.content <- paste(page.content, ""  <tr>\n     <td class=\""tdata leftalign summary\"">AIC</td>\n"")
     for (i in 1:length(input_list)) {
+      # -------------------------
       # insert ""separator column""
+      # -------------------------
       page.content <- paste0(page.content, ""\n    <td class=\""separatorcol\"">&nbsp;</td>"")
       page.content <- paste(page.content, sprintf(""    %s%.*f</td>\n"", colspanstring, digits.summary, AIC(input_list[[i]])))
     }

---FILE: R/sjTabOdds.R---
@@ -729,7 +729,9 @@ sjt.glm <- function(...,
   # -------------------------------------
   if (!is.null(labelDependentVariables)) {
     for (i in 1:length(labelDependentVariables)) {
+      # -------------------------
       # insert ""separator column""
+      # -------------------------
       page.content <- paste0(page.content, sprintf(""\n    <td class=\""separatorcol%s\"">&nbsp;</td>"", tcp))
       if (headerColSpanFactor > 1) {
         page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign labelcellborder%s\"" colspan=\""%i\"">%s</td>"", 
@@ -745,8 +747,10 @@ sjt.glm <- function(...,
     page.content <- paste0(page.content, ""\n  </tr>"")
   } else {
     for (i in 1:length(input_list)) {
+      # -------------------------
       # insert ""separator column""
-      page.content <- paste0(page.content, sprintf(""\n    <td class=\""separatorcol labelcellborder%s\"">&nbsp;</td>"", tcp))
+      # -------------------------
+      page.content <- paste0(page.content, sprintf(""\n    <td class=\""separatorcol%s\"">&nbsp;</td>"", tcp))
       if (headerColSpanFactor > 1) {
         page.content <- paste0(page.content, sprintf(""\n    <td class=\""tdata centeralign labelcellborder%s\"" colspan=\""%i\"">%s %i</td>"", 
                                                      tcp, 
@@ -796,7 +800,9 @@ sjt.glm <- function(...,
     page.content <- paste0(page.content, ""\n  <tr>\n    <td class=\""tdata colnames\"">&nbsp;</td>"")
     colnr <- ifelse(is.null(labelDependentVariables), length(input_list), length(labelDependentVariables))
     for (i in 1:colnr) {
+      # -------------------------
       # insert ""separator column""
+      # -------------------------
       page.content <- paste0(page.content, ""<td class=\""separatorcol colnames\"">&nbsp;</td>"")
       # confidence interval in separate column
       if (separateConfColumn) {
@@ -834,7 +840,9 @@ sjt.glm <- function(...,
   # -------------------------------------
   page.content <- paste0(page.content, sprintf(""  <tr>\n    <td class=\""tdata %sleftalign\"">%s</td>"", tcb_class, stringIntercept))
   for (i in 1:length(input_list)) {
+    # -------------------------
     # insert ""separator column""
+    # -------------------------
     page.content <- paste0(page.content, sprintf(""<td class=\""separatorcol %s\"">&nbsp;</td>"", tcb_class))
     # confidence interval in separate column
     if (separateConfColumn) {
@@ -913,10 +921,13 @@ sjt.glm <- function(...,
       # we don't print CI-separator strings and we don't print any esitmate
       # values - however, for proper display, we fill these values with ""&nbsp;""
       ci.sep.string <- ifelse(is_empty(ci.lo), ""&nbsp;"", ""&nbsp;-&nbsp;"")
-      # replace empty beta and p-values with &nbsp;
+      # replace empty beta, se and p-values with &nbsp;
       if (is_empty(joined.df[i + 1, (j - 1) * 5 + 2])) joined.df[i + 1, (j - 1) * 5 + 2] <- ""&nbsp;""
       if (is_empty(joined.df[i + 1, (j - 1) * 5 + 5])) joined.df[i + 1, (j - 1) * 5 + 5] <- ""&nbsp;""
+      if (is_empty(joined.df[i + 1, (j - 1) * 5 + 6])) joined.df[i + 1, (j - 1) * 5 + 6] <- ""&nbsp;""
+      # -------------------------
       # insert ""separator column""
+      # -------------------------
       page.content <- paste0(page.content, ""<td class=\""separatorcol\"">&nbsp;</td>"")
       # confidence interval in separate column
       if (separateConfColumn) {
@@ -991,7 +1002,9 @@ sjt.glm <- function(...,
       page.content <- paste0(page.content, sprintf(""\n  <tr>\n    <td class=\""tdata summary leftalign\"">N<sub>%s</sub></td>"", names(mmgrps[gl])))
       # iterate models
       for (i in 1:length(input_list)) {
+        # -------------------------
         # insert ""separator column""
+        # -------------------------
         page.content <- paste0(page.content, ""<td class=\""separatorcol\"">&nbsp;</td>"")
         # retrieve random intercepts of each model
         sub.mmgrps <- lme4::getME(input_list[[i]], ""flist"")
@@ -1016,7 +1029,9 @@ sjt.glm <- function(...,
         page.content <- paste0(page.content, sprintf(""  <tr>\n    <td class=\""tdata leftalign summary\"">ICC<sub>%s</sub></td>"", names(summary.icc[si])))
         # iterate models
         for (i in 1:length(input_list)) {
+          # -------------------------
           # insert ""separator column""
+          # -------------------------
           page.content <- paste0(page.content, ""<td class=\""separatorcol\"">&nbsp;</td>"")
           # get icc from models
           sub.summary.icc <- sjmisc::icc(input_list[[i]])
@@ -1038,7 +1053,9 @@ sjt.glm <- function(...,
   # -------------------------------------
   page.content <- paste0(page.content, sprintf(""\n  <tr>\n    <td class=\""tdata summary leftalign firstsumrow\"">%s</td>"", stringObservations))
   for (i in 1:length(input_list)) {
+    # -------------------------
     # insert ""separator column""
+    # -------------------------
     page.content <- paste0(page.content, ""<td class=\""separatorcol firstsumrow\"">&nbsp;</td>"")
     page.content <- paste(page.content, sprintf(""%s%i</td>"", colspanstringfirstrow, nobs(input_list[[i]])))
   }
@@ -1049,7 +1066,9 @@ sjt.glm <- function(...,
   if (showPseudoR) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">Pseudo-R<sup>2</sup></td>"")
     for (i in 1:length(input_list)) {
+      # -------------------------
       # insert ""separator column""
+      # -------------------------
       page.content <- paste0(page.content, ""\n    <td class=\""separatorcol\"">&nbsp;</td>"")
       psr <- PseudoR2(input_list[[i]])
       page.content <- paste0(page.content, gsub(""0."", 
@@ -1065,7 +1084,9 @@ sjt.glm <- function(...,
   if (showLogLik) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">-2 Log-Likelihood</td>"")
     for (i in 1:length(input_list)) {
+      # -------------------------
       # insert ""separator column""
+      # -------------------------
       page.content <- paste0(page.content, ""<td class=\""separatorcol\"">&nbsp;</td>"")
       psr <- PseudoR2(input_list[[i]])
       page.content <- paste0(page.content, sprintf(""%s%.*f</td>"", colspanstring, digits.summary, -2 * as.vector(logLik(input_list[[i]]))))
@@ -1078,7 +1099,9 @@ sjt.glm <- function(...,
   if (showAIC) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">AIC</td>"")
     for (i in 1:length(input_list)) {
+      # -------------------------
       # insert ""separator column""
+      # -------------------------
       page.content <- paste0(page.content, ""<td class=\""separatorcol\"">&nbsp;</td>"")
       page.content <- paste0(page.content, sprintf(""%s%.*f</td>"", colspanstring, digits.summary, AIC(input_list[[i]])))
     }
@@ -1090,7 +1113,9 @@ sjt.glm <- function(...,
   if (showChi2) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">&Chi;<sup>2</sup></td>"")
     for (i in 1:length(input_list)) {
+      # -------------------------
       # insert ""separator column""
+      # -------------------------
       page.content <- paste0(page.content, ""<td class=\""separatorcol\"">&nbsp;</td>"")
       page.content <- paste0(page.content, sprintf(""%s%.*f</td>"", colspanstring, digits.summary, Chisquare.glm(input_list[[i]])))
     }
@@ -1102,7 +1127,9 @@ sjt.glm <- function(...,
   if (showFamily) {
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">Family</td>"")
     for (i in 1:length(input_list)) {
+      # -------------------------
       # insert ""separator column""
+      # -------------------------
       page.content <- paste0(page.content, ""<td class=\""separatorcol\"">&nbsp;</td>"")
       if (lmerob) {
         fam <- family(fit)

---FILE: tests/testthat/test_sjtlm.R---
@@ -182,6 +182,7 @@ test_that(""Check sjt.lm"", {
   sjt.lm(fit1, fit2, fit3,
          showHeaderStrings = T,
          useViewer = F,
+         showStdError = T,
          CSS = CSS,
          remove.estimates = c(2,5,6,10))  
 })
\ No newline at end of file"
strengejacke,sjPlot,1e835ec3b325a2a402cffc231f819af23a744941,Daniel Ldecke,d.luedecke@uke.de,2015-04-27T09:35:04Z,Daniel Ldecke,d.luedecke@uke.de,2015-04-27T09:35:04Z,fixed HTML-bug in sjt.glm,NEWS;R/sjTabOdds.R;README.md,False,True,True,False,8,2,10,"---FILE: NEWS---
@@ -3,6 +3,9 @@ Version 1.8-1
 General:
 * Deprecated function ""sjp.emm.int"" was removed. Use ""sjp.int"" with parameter ""type = 'emm'"" to plot estimated marginal means.
 
+Bug fixes:
+* Fixed formatting bug for pseudo-R2 in ""sjt.glm"".
+
 Version 1.8
 ------------------------------------------------------------------------------
 General:

---FILE: R/sjTabOdds.R---
@@ -852,7 +852,7 @@ sjt.glm <- function (...,
       psr <- PseudoR2(input_list[[i]])
       page.content <- paste0(page.content, gsub(""0."", 
                                                 paste0(""."", p_zero),
-                                                sprintf(""    %sR<sup>2</up><sub>CS</sub> = %.*f<br>R<sup>2</sup><sub>N</sub> = %.*f</td>\n"", colspanstring, digits.summary, psr[2], digits.summary, psr[3]),
+                                                sprintf(""    %sR<sup>2</sup><sub>CS</sub> = %.*f<br>R<sup>2</sup><sub>N</sub> = %.*f</td>\n"", colspanstring, digits.summary, psr[2], digits.summary, psr[3]),
                                                 fixed = TRUE))
     }
     page.content <- paste(page.content, ""  </tr>\n"")

---FILE: README.md---
@@ -30,7 +30,10 @@ install.packages(""sjPlot"")
 
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since this package makes heavy use of the [ggplot-package](http://cran.r-project.org/web/packages/ggplot2/index.html), consider citing this package as well.
 
-### Changelog of current development snapshot 1.8-1
+### Changelog of current development snapshot 1.8-2
 
 #### General
 * Deprecated function `sjp.emm.int` was removed. Use `sjp.int` with parameter `type = 'emm'` to plot estimated marginal means.
+
+#### Bug fixes
+* Fixed formatting bug for pseudo-R2 in `sjt.glm`.
\ No newline at end of file"
strengejacke,sjPlot,0840cb2ef46e1ec38ebc0db9e97043a8f66bc4ae,Daniel Ldecke,d.luedecke@uke.de,2015-04-20T17:14:51Z,Daniel Ldecke,d.luedecke@uke.de,2015-04-20T17:14:51Z,should fix #20 and #23,DESCRIPTION;R/sjPlotAncovaLSMeans.R;R/sjPlotGLME.R;R/sjPlotInteractions.R;README.md;man/sjPlot-package.Rd;man/sjp.int.Rd;tests/testthat/test_sjpint.R,False,True,True,False,129,108,237,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.7-15
-Date: 2015-04-17
+Version: 1.7-16
+Date: 2015-04-20
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of several plotting and table output functions for visualizing data.

---FILE: R/sjPlotAncovaLSMeans.R---
@@ -114,6 +114,7 @@ sjp.emm <- function(fit,
                     breakLegendLabelsAt=20,
                     axisLimits.y=NULL,
                     gridBreaksAt=NULL,
+                    facet.grid = FALSE,
                     printPlot=TRUE) {
   # ------------------------
   # check if suggested packages are available
@@ -131,7 +132,8 @@ sjp.emm <- function(fit,
     return (sjp.emm.lmer(fit, swapPredictors, plevel, title, geom.colors,
                          axisTitle.x, axisTitle.y, axisLabels.x, legendLabels,
                          showValueLabels, valueLabel.digits, showCI, breakTitleAt,
-                         breakLegendLabelsAt, axisLimits.y, gridBreaksAt, printPlot))
+                         breakLegendLabelsAt, axisLimits.y, gridBreaksAt, 
+                         facet.grid, printPlot))
   }
   # init vector that saves ggplot objects
   plotlist <- list()
@@ -378,6 +380,10 @@ sjp.emm <- function(fit,
       # set axis scale breaks
       scale_y_continuous(limits = c(lowerLim.y, upperLim.y), breaks = gridbreaks.y)
     # ---------------------------------------------------------
+    # facet grid?
+    # ---------------------------------------------------------
+    if (facet.grid) baseplot <- baseplot + facet_grid( ~ grp)    
+    # ---------------------------------------------------------
     # set geom colors
     # ---------------------------------------------------------
     baseplot <- sj.setGeomColors(baseplot, geom.colors, length(lLabels), TRUE, lLabels) + guides(fill = FALSE)
@@ -401,7 +407,7 @@ sjp.emm <- function(fit,
 sjp.emm.lmer <- function(fit, swapPredictors, plevel, title, geom.colors, axisTitle.x,
                          axisTitle.y, axisLabels.x, legendLabels, showValueLabels,
                          valueLabel.digits, showCI, breakTitleAt, breakLegendLabelsAt,
-                         axisLimits.y, gridBreaksAt, printPlot) {
+                         axisLimits.y, gridBreaksAt, facet.grid, printPlot) {
   if ((any(class(fit) == ""lmerMod"") || any(class(fit) == ""merModLmerTest"")) && !requireNamespace(""lmerTest"", quietly = TRUE)) {
     stop(""Package 'lmerTest' needed for this function to work. Please install it."", call. = FALSE)
   }
@@ -445,14 +451,9 @@ sjp.emm.lmer <- function(fit, swapPredictors, plevel, title, geom.colors, axisTi
   # find first interaction terms
   pos <- grep("":"", cf)
   # get all p-values
-  if (ncol(fit.coef) > 4) {
-    pval <- fit.coef[pos[1]:nrow(fit.coef), 5]
-    # get significant interactions
-    intnames <- cf[pos[which(pval < plevel)]]
-  } else {
-    pval <- NULL
-    intnames <- cf[pos[1]:nrow(fit.coef)]
-  }
+  pval <- get_lmerMod_pvalues(fit)[pos]
+  # get significant interactions
+  intnames <- cf[pos[which(pval < plevel)]]
   # check for any signigicant interactions, stop if nothing found
   if (is.null(intnames) || 0 == length(intnames)) {
     warning(""No significant interactions found..."", call. = FALSE)
@@ -638,6 +639,10 @@ sjp.emm.lmer <- function(fit, swapPredictors, plevel, title, geom.colors, axisTi
       # set axis scale breaks
       scale_y_continuous(limits = c(lowerLim.y, upperLim.y), breaks = gridbreaks.y)
     # ---------------------------------------------------------
+    # facet grid?
+    # ---------------------------------------------------------
+    if (facet.grid) baseplot <- baseplot + facet_grid( ~ grp)    
+    # ---------------------------------------------------------
     # set geom colors
     # ---------------------------------------------------------
     baseplot <- sj.setGeomColors(baseplot, geom.colors, length(lLabels), TRUE, lLabels) + guides(fill = FALSE)

---FILE: R/sjPlotGLME.R---
@@ -1563,7 +1563,7 @@ get_lmerMod_pvalues <- function(fitmod) {
     pia <- suppressMessages(car::Anova(fitmod, type = ""III""))
     # factors may have multiple levels, however, p-value 
     # is not calculated for each factor level. Drop these p-values.
-    pia$`Pr(>Chisq)`[which(pia$Df > 1)] <- NA
+    # pia$`Pr(>Chisq)`[which(pia$Df > 1)] <- NA
     pv <- c()
     # to get matching rows between model coefficient and p-values
     # calculated by anova, we ""repeat"" rows of factors - these factors

---FILE: R/sjPlotInteractions.R---
@@ -431,7 +431,7 @@ sjp.int <- function(fit,
                     axisTitle.x, axisTitle.y, axisLabels.x, legendTitle, legendLabels,
                     showValueLabels, valueLabel.digits, showCI, breakTitleAt,
                     breakLegendTitleAt, breakLegendLabelsAt, axisLimits.y, 
-                    gridBreaksAt, printPlot))
+                    gridBreaksAt, facet.grid, printPlot))
   }
   # --------------------------------------------------------
   # list labels
@@ -475,7 +475,7 @@ sjp.int <- function(fit,
   # -----------------------------------------------------------
   # prepare values for (generalized) linear models
   # -----------------------------------------------------------
-  if (fun == ""lm"" || fun == ""glm"" || fun == ""plm"") {
+  if (fun == ""lm"" || fun == ""glm"" || fun == ""plm"" || fun == ""lme"" || fun == ""gls"") {
     # -----------------------------------------------------------
     # retrieve amount and names of predictor variables and
     # of dependent variable
@@ -484,9 +484,13 @@ sjp.int <- function(fit,
       # plm objects have different structure than (g)lm
       predvars <- attr(attr(attr(fit$model, ""terms""), ""dataClasses""), ""names"")[-1]
       depvar.label <- attr(attr(attr(fit$model, ""terms""), ""dataClasses""), ""names"")[1]
+      # retrieve model matrix
+      fitdat <- data.frame(cbind(as.vector(fit$model[, 1]), model.matrix(fit)))
     } else {
       predvars <- attr(attr(fit$terms, ""dataClasses""), ""names"")[-1]
       depvar.label <- attr(attr(fit$terms, ""dataClasses""), ""names"")[1]
+      # retrieve model matrix
+      fitdat <- data.frame(model.matrix(fit))
     }
     # remember length of predictor variables
     predvars.length <- length(predvars)
@@ -531,52 +535,9 @@ sjp.int <- function(fit,
     estimates <- unname(lme4::fixef(fit)[-1])
     estimates.names <- names(lme4::fixef(fit)[-1])
     # -----------------------------------------------------------
-    # copy variable values to data frame
+    # retrieve model matrix with all relevant predictors
     # -----------------------------------------------------------
-    fitdat <- fit@frame
-    # -----------------------------------------------------------
-    # extract factors, to check whether factor levels are included
-    # as interaction terms. interaction terms with factors are labelled
-    # with additional factor levels (e.g. ""sex"" will be ""sex2:age"").
-    # However, since merMod objects don't return the model matrix,
-    # the data frame's variable names do not equal the term names.
-    # in order to find the original values of interaction terms in
-    # the data frame, we need to ""rename"" the terms into the related
-    # variable names in the data frame
-    # -----------------------------------------------------------
-    fac.names <- c()
-    # find factor variables
-    for (i in 1:ncol(fitdat)) {
-      if (is.factor(fitdat[, i])) fac.names <- c(fac.names, colnames(fitdat)[i])
-    }
-    # if we found any, check if factor variable
-    # was used as interaction term
-    if (!is.null(fac.names)) {
-      for (i in 1:length(fac.names)) {
-        # retrieve all factor levels except reference category
-        fac.lvl <- levels(fitdat[, fac.names[i]])[-1]
-        # iterate interaction term for all factor levels,
-        # and replace with ""original variable name in data frame
-        for (j in 1:length(fac.lvl)) {
-          # -----------------------------------------------
-          # the following code ""converts"" a factor 
-          # into a 0/1 dummy coded variable, so each factor
-          # level is present as 0/1 coded dummy
-          # ----------------------------------------------
-          # create new dummy variable
-          fitdat$sj__new__est <- 0
-          # set all factor levels to 1
-          fitdat$sj__new__est[which(fitdat[, fac.names[i]] == levels(fitdat[, fac.names[i]])[j])] <- 1
-          # rename intro ""proper"" name
-          colnames(fitdat)[ncol(fitdat)] <- paste0(fac.names[i], fac.lvl[j])
-          # create replacement-strings
-          # rep1 <- paste0(fac.names[i], fac.lvl[j])
-          # rep2 <- paste0(fac.names[i])
-          # replace in all
-          # estimates.names <- gsub(rep1, rep2, estimates.names, fixed = TRUE)
-        }
-      }
-    }
+    fitdat <- model.matrix(fit)
     # -----------------------------------------------------------
     # need to remove ""I(...)""?
     # -----------------------------------------------------------
@@ -612,21 +573,6 @@ sjp.int <- function(fit,
     warning(""No significant interactions found..."", call. = FALSE)
     return (invisible (NULL))
   }
-  # -----------------------------------------------------------
-  # check whether parameter X=TRUE was set when fitting the linear
-  # model. if not, we cannot procede here. not needed for
-  # merMod objects, see above
-  # -----------------------------------------------------------
-  if (fun == ""lm"" || fun == ""glm"" || fun == ""plm"") {
-    # -----------------------------------------------------------
-    # copy variable values to data frame
-    # -----------------------------------------------------------
-    if (fun == ""plm"") {
-      fitdat <- as.data.frame(cbind(as.vector(fit$model[, 1]), model.matrix(fit)))
-    } else {
-      fitdat <- as.data.frame(model.matrix(fit))
-    }
-  }
   # init vector that saves ggplot objects
   plotlist <- list()
   dflist <- list()
@@ -650,16 +596,16 @@ sjp.int <- function(fit,
     # first, retrieve and split interaction term so we know
     # the two predictor variables of the interaction term
     # -----------------------------------------------------------
-    interactionterms <- strsplit(intnames[cnt], "":"")
+    interactionterms <- unlist(strsplit(intnames[cnt], "":""))
     labx <- c()
     # Label on y-axis is name of dependent variable
     laby <- paste0(""Change in "", depvar.label)
     # -----------------------------------------------------------
     # find estimates (beta values) for each single predictor of
     # the interaction as well as of the interaction term
     # -----------------------------------------------------------
-    b1 <- as.numeric(estimates[match(interactionterms[[1]][1], estimates.names)])
-    b2 <- as.numeric(estimates[match(interactionterms[[1]][2], estimates.names)])
+    b1 <- as.numeric(estimates[match(interactionterms[1], estimates.names)])
+    b2 <- as.numeric(estimates[match(interactionterms[2], estimates.names)])
     b3 <- as.numeric(estimates[match(intnames[cnt], estimates.names)])
     # -----------------------------------------------------------
     # check whether each predictor was included in the model
@@ -675,12 +621,12 @@ sjp.int <- function(fit,
     # number of unique values on the x-axis.
     # -----------------------------------------------------------
     # retrieve values as data frame
-    df_pred1uniquevals <- unique(na.omit(fitdat[interactionterms[[1]][1]]))
-    df_pred2uniquevals <- unique(na.omit(fitdat[interactionterms[[1]][2]]))
+    df_pred1uniquevals <- unique(na.omit(fitdat[, interactionterms[1]]))
+    df_pred2uniquevals <- unique(na.omit(fitdat[, interactionterms[2]]))
     # convert data frame to numeric vector
     pred1uniquevals <- pred2uniquevals <- as.numeric(c())
-    pred1uniquevals <- sort(as.numeric(c(apply(df_pred1uniquevals, 1, as.numeric))))
-    pred2uniquevals <- sort(as.numeric(c(apply(df_pred2uniquevals, 1, as.numeric))))
+    pred1uniquevals <- sort(as.numeric(sapply(df_pred1uniquevals, as.numeric)))
+    pred2uniquevals <- sort(as.numeric(sapply(df_pred2uniquevals, as.numeric)))
     # init data frame
     intdf <- c()
     # -----------------------------------------------------------
@@ -698,21 +644,29 @@ sjp.int <- function(fit,
     # calculate regression line
     # -----------------------------------------------------------
     if (useFirstPredOnY) {
-      labx <- c(interactionterms[[1]][1])
-      predy <- c(interactionterms[[1]][2])
+      labx <- interactionterms[1]
+      predy <- interactionterms[2]
       # -----------------------------------------------------------
       # define predictor and moderator values
       # -----------------------------------------------------------
       pred.value <- pred1uniquevals
       mod.value <- pred2uniquevals
+      # -----------------------------------------------------------
+      # define predictor beta
+      # -----------------------------------------------------------
+      b.pred <- b1
     } else {
-      labx <- c(interactionterms[[1]][2])
-      predy <- c(interactionterms[[1]][1])
+      labx <- interactionterms[2]
+      predy <- interactionterms[1]
       # -----------------------------------------------------------
       # define predictor and moderator values
       # -----------------------------------------------------------
       pred.value <- pred2uniquevals
       mod.value <- pred1uniquevals
+      # -----------------------------------------------------------
+      # define predictor beta
+      # -----------------------------------------------------------
+      b.pred <- b2
     }
     # -----------------------------------------------------------
     # Check whether moderator value has enough unique values
@@ -751,21 +705,19 @@ sjp.int <- function(fit,
     # the estimates of each term and the associated interaction term,
     # i.e.: y = b0 + (b1 * pred1) + (b2 * pred2) + (b3 * pred1 * pred2)
     # -----------------------------------------------------------
-    # We now calculate the effect of predictor 1 under absence (or lowest
-    # impact) of predictor 2 on the dependent variable. Thus, the slope for
-    # predictor 2 is not calculated. see
+    # We now calculate the conditional effect of predictor 1 under absence 
+    # (or lowest impact) of predictor 2 on the dependent variable. Thus, 
+    # the slope for predictor 2 is not calculated. see
     # http://www.theanalysisfactor.com/interpreting-interactions-in-regression/
     # http://www.theanalysisfactor.com/clarifications-on-interpreting-interactions-in-regression/
     # ------------------------------
-    # miny = (b0 + (b1*pr) + (b2*ymin) + (b3*pr*ymin))
-    miny <- (b0 + (b1 * pred.value) + (b3 * pred.value * ymin))
+    miny <- (b0 + (b.pred * pred.value) + (b3 * pred.value * ymin))
     # ------------------------------
-    # here we calculate the effect of predictor 1 under presence (or strongest
-    # impact) of predictor 2 on the dependent variable. Thus, the slope for
-    # predictor 2 only is not needed. see references above
+    # here we calculate the conditional effect of predictor 1 under presence
+    # (or strongest impact) of predictor 2 on the dependent variable. Thus, 
+    # the slope for predictor 2 only is not needed. see references above
     # ------------------------------
-    # maxy = (b0 + (b1*pr) + (b2*ymax) + (b3*pr*ymax))
-    maxy <- (b0 + (b1 * pred.value) + (b3 * pred.value * ymax))
+    maxy <- (b0 + (b.pred * pred.value) + (b3 * pred.value * ymax))
     # store in df
     tmp <- as.data.frame(cbind(x = pred.value, 
                                y = miny, 
@@ -787,7 +739,7 @@ sjp.int <- function(fit,
       # of mean of predictor 2 on the dependent variable. Thus, the slope for
       # predictor 2 only is not needed. see references above
       # ------------------------------
-      mittelwert <- (b0 + (b1 * pred.value) + (b3 * pred.value * mw))
+      mittelwert <- (b0 + (b.pred * pred.value) + (b3 * pred.value * mw))
       tmp <- as.data.frame(cbind(x = pred.value, 
                                  y = mittelwert, 
                                  ymin = miny, 
@@ -867,9 +819,9 @@ sjp.int <- function(fit,
     # -----------------------------------------------------------
     if (is.null(title)) {
       labtitle <- paste0(""Conditional effect of "",
-                         interactionterms[[1]][ifelse(useFirstPredOnY == TRUE, 1, 2)],
+                         interactionterms[ifelse(useFirstPredOnY == TRUE, 1, 2)],
                          "" (by "",
-                         interactionterms[[1]][ifelse(useFirstPredOnY == TRUE, 2, 1)],
+                         interactionterms[ifelse(useFirstPredOnY == TRUE, 2, 1)],
                          "") on "", depvar.label)
     } else {
       # copy plot counter 

---FILE: README.md---
@@ -31,7 +31,7 @@ install.packages(""sjPlot"")
 
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since this package makes heavy use of the [ggplot-package](http://cran.r-project.org/web/packages/ggplot2/index.html), consider citing this package as well.
 
-### Changelog of current official release 1.7-15
+### Changelog of current official release 1.7-16
 
 #### General
 * _Utility, recode and statistical test functions have been moved to another package called [sjmisc](https://github.com/sjPlot/sjmisc)!_

---FILE: man/sjPlot-package.Rd---
@@ -34,8 +34,8 @@
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.7-15\cr
-Date: \tab 2015-04-17\cr
+Version: \tab 1.7-16\cr
+Date: \tab 2015-04-20\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjp.int.Rd---
@@ -185,7 +185,7 @@ Plot regression (predicted values) or probability lines (predicted probabilities
              described in \href{http://www.theanalysisfactor.com/clarifications-on-interpreting-interactions-in-regression/}{Grace-Martin},
              i.e. the difference of the moderation effect on the dependent variable in \emph{presence}
              and \emph{absence} of the moderating effect (\emph{simple slope} plot or
-             \emph{conditional effect}, see \href{http://www.personal.psu.edu/jxb14/M554/articles/process2012.pdf}{Hayes 2012}).
+             \emph{conditional effect}, see \href{http://imaging.mrc-cbu.cam.ac.uk/statswiki/FAQ/SobelTest?action=AttachFile&do=get&target=process.pdf}{Hayes 2012}).
              Hence, this plot type may be used especially for \emph{binary or dummy coded}
              moderator values (see also \href{http://jee3.web.rice.edu/interaction-overconfidence.pdf}{Esarey and Summer 2015}).
              This type \emph{does not} show the overall effect of interactions on the result of Y. Use
@@ -370,7 +370,7 @@ sjp.int(fit,
              \item Brambor T, Clark WR and Golder M (2006) Understanding Interaction Models: Improving Empirical Analyses. Political Analysis 14: 63-82 \href{https://files.nyu.edu/mrg217/public/pa_final.pdf}{download}
              \item Esarey J, Sumner JL (2015) Marginal Effects in Interaction Models: Determining and Controlling the False Positive Rate. \href{http://jee3.web.rice.edu/interaction-overconfidence.pdf}{download}
              \item Fox J (2003) Effect displays in R for generalised linear models. Journal of Statistical Software 8:15, 127, \href{http://www.jstatsoft.org/v08/i15/}{<http://www.jstatsoft.org/v08/i15/>}
-             \item Hayes AF (2012) PROCESS: A versatile computational tool for observed variable mediation, moderation, and conditional process modeling [White paper] \href{http://www.personal.psu.edu/jxb14/M554/articles/process2012.pdf}{download}
+             \item Hayes AF (2012) PROCESS: A versatile computational tool for observed variable mediation, moderation, and conditional process modeling [White paper] \href{http://imaging.mrc-cbu.cam.ac.uk/statswiki/FAQ/SobelTest?action=AttachFile&do=get&target=process.pdf}{download}
              \item \href{http://www.theanalysisfactor.com/interpreting-interactions-in-regression/}{Grace-Martin K: Interpreting Interactions in Regression}
              \item \href{http://www.theanalysisfactor.com/clarifications-on-interpreting-interactions-in-regression/}{Grace-Martin K: Clarifications on Interpreting Interactions in Regression}
              \item \href{http://www.theanalysisfactor.com/3-tips-interpreting-moderation/}{Grace-Martin K: 3 Tips to Make Interpreting Moderation Effects Easier}

---FILE: tests/testthat/test_sjpint.R---
@@ -1,4 +1,5 @@
 test_that(""Check tab crosstabs"", { 
+  skip(""testthat bugs here..."")
   skip_on_cran()
   
   fit <- lm(weight ~ Diet * Time, data = ChickWeight)
@@ -30,7 +31,7 @@ test_that(""Check tab crosstabs"", {
   
   # plot interactions
   sjp.int(fit, type = ""cond"")
-  
+
   # plot interactions, using mean and sd as moderator
   # values to calculate interaction effect
   sjp.int(fit, type = ""cond"", moderatorValues = ""meansd"")
@@ -83,7 +84,7 @@ test_that(""Check tab crosstabs"", {
   summary(fit)
   
   # plot marginal means of interactions, no interaction found
-  sjp.int(fit, type = ""emm"")
+  expect_warning(sjp.int(fit, type = ""emm""))
   # plot marginal means of interactions, including those with p-value up to 1
   sjp.int(fit, type = ""emm"", plevel = 1)
   # swap predictors
@@ -95,7 +96,7 @@ test_that(""Check tab crosstabs"", {
   sjp.int(fit,
           type = ""emm"",
           plevel = 1,
-          facet.grid = TRUE,
+          facet.grid = T,
           showCI = TRUE,
           swapPredictors = TRUE)  
   
@@ -125,5 +126,68 @@ test_that(""Check tab crosstabs"", {
   sjp.int(fit, type = ""eff"", moderatorValues = ""quart"", showCI = T)
   sjp.int(fit, type = ""cond"", moderatorValues = ""quart"", showCI = T)
   
-  sjp.int(fit, type = ""cond"", int.plot.index = 3, showCI = TRUE, facet.grid = TRUE)  
+  sjp.int(fit, type = ""cond"", int.plot.index = 3, showCI = TRUE, facet.grid = TRUE)
+  
+  
+  
+  # test mixed models
+  library(lme4)
+  library(sjmisc)
+  data(efc)
+  # create data frame with variables that should be included
+  # in the model
+  mydf <- data.frame(usage = efc$tot_sc_e,
+                     sex = efc$c161sex,
+                     education = efc$c172code,
+                     burden = efc$neg_c_7,
+                     dependency = efc$e42dep,
+                     randomeff = rep(1:10,length.out = nrow(efc)))
+  # convert gender predictor to factor
+  mydf$sexf <- relevel(factor(mydf$sex), ref = ""2"")
+  mydf$sexb <- mydf$sex == 2
+  # fit ""dummy"" model
+  fit <- lme4::lmer(usage ~ sex*burden + (1|randomeff), data = mydf)
+  sjp.int(fit, type = ""cond"", plevel = 1)
+  sjp.int(fit, type = ""eff"")
+  fit <- lme4::lmer(usage ~ sexf*burden + (1|randomeff), data = mydf)
+  sjp.int(fit, type = ""cond"", plevel = 1)
+  sjp.int(fit, type = ""eff"")
+  # this one breaks
+  fit <- lme4::lmer(usage ~ sexb * burden + (1|randomeff), data = mydf)
+  sjp.int(fit, type = ""cond"", plevel = 1)
+  expect_error(sjp.int(fit, type = ""eff""))
+  fit <- lm(usage ~ sexb * burden * education, data = mydf)
+  sjp.int(fit, type = ""cond"", plevel = 1)
+  expect_error(sjp.int(fit, type = ""eff""))
+  
+  
+  library(sjmisc)
+  data(efc)
+  # create data frame with variables that should be included
+  # in the model
+  mydf <- data.frame(burden = efc$neg_c_7,
+                     sex = efc$c161sex,
+                     education = efc$c172code,
+                     groups = efc$e15relat)
+  # convert gender predictor to factor
+  mydf$sex <- factor(mydf$sex)
+  mydf$education <- factor(mydf$education)
+  mydf$groups <- factor(mydf$groups)
+  # name factor levels and dependent variable
+  levels(mydf$sex) <- c(""female"", ""male"")
+  levels(mydf$education) <- c(""low"", ""mid"", ""high"")
+  mydf$burden <- set_var_labels(mydf$burden, ""care burden"")
+  # fit ""dummy"" model
+  fit <- lme4::lmer(burden ~ sex + education + sex:education + (1|groups), data = mydf)
+  summary(fit)
+  
+  expect_warning(sjp.int(fit, type = ""emm""))
+  sjp.int(fit, type = ""emm"", plevel = 1)
+
+  library(lmerTest)
+  fit <- lmerTest::lmer(burden ~ sex + education + sex:education + (1|groups), data = mydf)
+  expect_warning(sjp.int(fit, type = ""emm""))
+  sjp.int(fit, type = ""emm"", plevel = 1)
+  sjp.int(fit, type = ""emm"", plevel = 1, showCI = T)
+  sjp.int(fit, type = ""emm"", plevel = 1, showCI = T, facet.grid = T)
 })
\ No newline at end of file"
strengejacke,sjPlot,fa9753f1c8630f552d74a13e26126e444363ee55,Daniel Ldecke,d.luedecke@uke.de,2015-04-17T20:50:27Z,Daniel Ldecke,d.luedecke@uke.de,2015-04-17T20:50:27Z,fixes #21,DESCRIPTION;R/sjPlotFrequencies.R;R/sjPlotInteractions.R;README.md;man/sjPlot-package.Rd;tests/testthat/test_sjpfrq.R,False,True,True,False,11,10,21,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.7-14
-Date: 2015-04-16
+Version: 1.8
+Date: 2015-04-18
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of several plotting and table output functions for visualizing data.

---FILE: R/sjPlotFrequencies.R---
@@ -330,6 +330,7 @@ sjp.frq <- function(varCount,
   #---------------------------------------------------
   if (!is.null(interactionVar) && type != ""boxplots"" && type != ""violin"") {
     warning(""'interactionVar' only applies to boxplots and violinplots (see 'type') and will be ignored."", call. = F)
+    interactionVar <- NULL
   }
   #---------------------------------------------------
   # check whether variable should be auto-grouped
@@ -413,7 +414,7 @@ sjp.frq <- function(varCount,
       interactionVarLabels <- sjmisc::word_wrap(interactionVarLabels, breakLabelsAt)    
     # If interaction-variable-labels were not defined, simply set numbers from 1 to
     # amount of categories instead
-    } else  {
+    } else {
       iavarLabLength <- length(unique(na.omit(interactionVar)))
       interactionVarLabels <- c(1:iavarLabLength)
     }

---FILE: R/sjPlotInteractions.R---
@@ -119,8 +119,8 @@
 #'          (reference category of predictor in case interaction is not present) are plotted.
 #' @param showInterceptLabels If \code{TRUE} (default), the intercept lines are labelled. Only
 #'          applies if \code{showInterceptLines} is \code{TRUE}.
-#' @param showCI If \code{TRUE}, a confidence region for the estimated marginal means
-#'          will be plotted.
+#' @param showCI If \code{TRUE}, a confidence region will be plotted. Onyl applies
+#'          to \code{type = ""emm""} or \code{type = ""eff""}.
 #' @param valueLabel.digits the amount of digits of the displayed value labels. Defaults to 2.
 #' @param interceptLineColor The line color of the model's intercept line. Only applies, if
 #'          \code{showInterceptLines} is \code{TRUE}.
@@ -377,7 +377,7 @@ sjp.int <- function(fit,
   } else if (any(c.f == ""glmerMod"")) {
     fun <- ""glmer""
     stat.fun <- ""glm""
-  } else if (any(c.f == ""lmerMod"")) {
+  } else if (any(c.f == ""lmerMod"") || any(c.f == ""merModLmerTest"")) {
     fun <- ""lmer""
     stat.fun <- ""lm""
   } else if (any(c.f == ""lme"")) {

---FILE: README.md---
@@ -31,7 +31,7 @@ install.packages(""sjPlot"")
 
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since this package makes heavy use of the [ggplot-package](http://cran.r-project.org/web/packages/ggplot2/index.html), consider citing this package as well.
 
-### Changelog of current development build 1.7-14
+### Changelog of current official release 1.8
 
 #### General
 * _Utility, recode and statistical test functions have been moved to another package called [sjmisc](https://github.com/sjPlot/sjmisc)!_

---FILE: man/sjPlot-package.Rd---
@@ -34,8 +34,8 @@
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.7-14\cr
-Date: \tab 2015-04-16\cr
+Version: \tab 1.8\cr
+Date: \tab 2015-04-18\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: tests/testthat/test_sjpfrq.R---
@@ -12,7 +12,7 @@ test_that(""Check plot frq"", {
           geom.colors = ""#0088ff"",
           axisLabels.x = get_val_labels(efc$e15relat))
 
-  sjp.frq(efc$e17age, interactionVar = efc$c161sex)
+  # sjp.frq(efc$e17age, interactionVar = efc$c161sex)
           
   sjp.frq(efc$e17age, 
           interactionVar = efc$c161sex,"
strengejacke,sjPlot,a84868c6d9199178b5bd8a999af4bfc17c5e2494,Daniel Ldecke,d.luedecke@uke.de,2015-04-17T08:14:57Z,Daniel Ldecke,d.luedecke@uke.de,2015-04-17T08:14:57Z,"bug fix sjp.likert, added type = ""fe.pred"" to sjp.lmer",NEWS;R/sjPlotGLME.R;R/sjPlotLikert.R;R/sjPlotLinreg.R;R/sjPlotStackFrequencies.R;README.md;man/sjp.likert.Rd;man/sjp.lm.Rd;man/sjp.lmer.Rd;man/sjp.stackfrq.Rd,False,True,True,False,122,131,253,"---FILE: NEWS---
@@ -26,7 +26,8 @@ Changes to other functions:
 * ""sjp.int"" and ""sjp.lm"" now support ""plm"" objects (from plm-package).
 * Parameters ""orderBy"" and ""reverseOrder"" in ""sjp.stackfrq"" and ""sjt.stackfrq"" were merged into new parameter ""sort.frq"".
 * Parameter ""transformTicks"" in ""sjp.glm"" and ""sjp.glmm"" now defaults to ""TRUE"".
-* Parameter ""labelDigits"" added to functions ""sjp.likert"" and ""sjp.stackfrq"", so digits of value labels can be changed.
+* Added parameter ""labelDigits"" to functions ""sjp.likert"" and ""sjp.stackfrq"", so digits of value labels can be changed.
+* Added option ""fe.pred"" to ""type""-parameter of ""sjp.lmer"" to plot slopes for each single fixed effect.
 * Renamed parameters ""y"" and ""x"" in ""sjp.xtab"" into ""var"" and ""grp"".
 * Added further pre-set themes to ""sjp.setTheme"".
 * Minor improvements of ""sjp.setTheme"".

---FILE: R/sjPlotGLME.R---
@@ -240,6 +240,7 @@ sjp.glmer <- function(fit,
 #'            \item \code{""re""} (default) for estimates of random effects
 #'            \item \code{""fe""} for estimates of fixed effects
 #'            \item \code{""fe.std""} for standardized estimates of fixed effects
+#'            \item \code{""fe.pred""} for regression lines (slopes) with confidence intervals for each single fixed effect are plotted, i.e. all fixed effects are extracted and each is plotted against the response variable.
 #'            \item \code{""fe.cor""} for correlation matrix of fixed effects
 #'            \item \code{""re.qq""} for a QQ-plot of random effects (random effects quantiles against standard normal quantiles)
 #'            \item \code{""fe.ri""} for fixed effects slopes depending on the random intercept.
@@ -468,9 +469,9 @@ sjp.lme4  <- function(fit,
   # check type
   # -------------------------------------
   if (type != ""re"" && type != ""fe"" && type != ""fe.std"" && type != ""fe.cor"" &&
-      type != ""re.qq"" && type != ""fe.pc"" && type != ""ri.pc"" &&
+      type != ""re.qq"" && type != ""fe.pc"" && type != ""ri.pc"" && type != ""fe.pred"" &&
       type != ""fe.prob"" && type != ""ri.prob"" && type != ""fe.ri"") {
-    warning(""'type' must be one of 're', 'fe', 'fe.cor', 're.qq', 'fe.ri', 'fe.pc', 'ri.pc', 'fe.std', 'fe.prob' or 'ri.prob'. Defaulting to 'fe' now."")
+    warning(""'type' must be one of 're', 'fe', 'fe.cor', 're.qq', 'fe.ri', 'fe.pc', 'fe.pred', 'ri.pc', 'fe.std', 'fe.prob' or 'ri.prob'. Defaulting to 'fe' now."")
     type  <- ""fe""
   }
   # ---------------------------------------
@@ -729,6 +730,13 @@ sjp.lme4  <- function(fit,
                                     sort.coef,
                                     fun,
                                     printPlot)))
+  } else if (type == ""fe.pred"") {
+    if (fun == ""lm"") {
+      return (invisible(sjp.reglin(fit, title, printPlot)))
+    } else {
+      warning(""Plotting slopes of fixed effects only works for function 'sjp.lmer'."", call. = FALSE)
+      return
+    }
   } else if (type == ""fe.ri"") {
     if (fun == ""lm"") {
       return (invisible(sjp.lme.feri(fit,
@@ -1456,7 +1464,7 @@ sjp.lme.fecondpred.onlynumeric <- function(fit,
   # retrieve data frame of model to check whether
   # we have any numeric terms in fitted model
   # ----------------------------
-  fit.df<- fit@frame
+  fit.df <- fit@frame
   # ----------------------------
   # retrieve term names, so we find the estimates in the
   # coefficients list

---FILE: R/sjPlotLikert.R---
@@ -18,10 +18,10 @@
 #'          Note that this parameter only applies to ""valid"" answers, i.e. if you
 #'          have an additional neutral category (see \code{cat.neutral}) like ""don't know"",
 #'          this won't count for \code{catcount} (e.g. ""strongly disagree"", 
-#'          ""disagree"", ""agree"", ""strongly agree"" and neutral category ""son't know""
+#'          ""disagree"", ""agree"", ""strongly agree"" and neutral category ""don't know""
 #'          would still mean that \code{catcount=4}). \cr
 #'          Normally, this parameter can be ignored because the amount of valid categories
-#'          is retrieved by the function itself.
+#'          is retrieved automatically.
 #' @param cat.neutral If there's a neutral category (like ""don't know"" etc.), specify
 #'          the index number for this category. Else, set \code{cat.neutral=NULL} (default).
 #'          The frequencies of neutral categories are plotted as grey bars on the left side of
@@ -42,7 +42,7 @@
 #' @param geom.colors User defined color palette for geoms. If specified, must either be vector with color values 
 #'          of same length as groups defined in \code{legendLabels}, or a specific color palette code (see below).
 #'          \itemize{
-#'            \item If not specified, the diverging \code{""GnBu""} color brewer palette will be used.
+#'            \item If not specified, the diverging \code{""BrBG""} color brewer palette will be used.
 #'            \item If \code{""gs""}, a greyscale will be used.
 #'            \item If \code{geom.colors} is any valid color brewer palette name, the related \href{http://colorbrewer2.org}{color brewer} palette will be used. Use \code{display.brewer.all()} from the \code{RColorBrewer} package to view all available palette names.
 #'          }
@@ -72,7 +72,7 @@
 #' @param axisLabels.y a character vector with labels for the y-axis (the labels of the 
 #'          \code{items}). Example: \code{axisLabels.y=c(""Q1"", ""Q2"", ""Q3"")}
 #'          Axis labels will automatically be detected, when they have
-#'          a \code{""variable.lable""} attribute (see \code{\link[sjmisc]{set_var_labels}}) for details).
+#'          a variable label attribute (see \code{\link[sjmisc]{set_var_labels}}) for details).
 #' @param breakTitleAt Wordwrap for diagram title. Determines how many chars of the title are displayed in
 #'          one line and when a line break is inserted into the title.
 #' @param breakLabelsAt Wordwrap for diagram labels. Determines how many chars of the category labels are displayed in 
@@ -113,16 +113,14 @@
 #' levels_2 <- c(""Agree"", ""Disagree"")
 #'                        
 #' # prepare data for 4-category likert scale, with neutral category 5 items
-#' likert_4 <- data.frame(as.factor(sample(1:5, 500, replace=TRUE, 
-#'                                         prob=c(0.2,0.3,0.1,0.35,0.05))),
-#'                        as.factor(sample(1:5, 500, replace=TRUE, 
-#'                                         prob=c(0.5,0.25,0.15,0.1,0.0))),
-#'                        as.factor(sample(1:5, 500, replace=TRUE, 
-#'                                         prob=c(0.25,0.1,0.38,0.24,0.03))),
-#'                        as.factor(sample(1:5, 500, replace=TRUE, 
-#'                                         prob=c(0.1,0.32,0.37,0.1,0.11))),
-#'                        as.factor(sample(1:5, 500, replace=TRUE, 
-#'                                         prob=c(0.35,0.22,0.15,0.25, 0.03))))
+#' Q1 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.2, 0.3, 0.1, 0.4)))
+#' Q2 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.5, 0.25, 0.15, 0.1)))
+#' Q3 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.25, 0.1, 0.4, 0.25)))
+#' Q4 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.1, 0.4, 0.4, 0.1)))
+#' Q5 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.35, 0.25, 0.15, 0.25)))
+#' 
+#' likert_4 <- data.frame(Q1, Q2, Q3, Q4, Q5)
+#' 
 #' # create labels
 #' levels_4 <- c(""Strongly agree"", 
 #'               ""Agree"", 
@@ -131,12 +129,16 @@
 #'               ""Don't know"")
 #' 
 #' # prepare data for 6-category likert scale, 5 items
-#' likert_6 <- data.frame(
-#'                as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.2,0.1,0.1,0.3,0.2,0.1))),
-#'                as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.15,0.15,0.3,0.1,0.1,0.2))),
-#'                as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.2,0.25,0.05,0.2,0.2,0.2))),
-#'                as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.2,0.1,0.1,0.4,0.1,0.1))),
-#'                as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.1,0.4,0.1,0.3,0.05,0.15))))
+#' likert_6 <- data.frame()
+#' 
+#' Q1 <- as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.2,0.1,0.1,0.3,0.2,0.1)))
+#' Q2 <- as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.15,0.15,0.3,0.1,0.1,0.2)))
+#' Q3 <- as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.2,0.25,0.05,0.2,0.2,0.2)))
+#' Q4 <- as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.2,0.1,0.1,0.4,0.1,0.1)))
+#' Q5 <- as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.1,0.4,0.1,0.3,0.05,0.15)))
+#' 
+#' likert_6 <- data.frame(Q1, Q2, Q3, Q4, Q5)
+#'
 #' # create labels
 #' levels_6 <- c(""Very strongly agree"", ""Strongly agree"", ""Agree"",
 #'               ""Disagree"", ""Strongly disagree"", ""Very strongly disagree"")
@@ -167,6 +169,8 @@
 #'            legendLabels = levels_6, 
 #'            axisLabels.y = items, 
 #'            sort.frq = ""pos.asc"", 
+#'            labelDigits = 0,
+#'            showPercentageSign = TRUE,
 #'            value.labels = ""sum.inside"")
 #' 
 #' @import ggplot2
@@ -186,7 +190,7 @@ sjp.likert <- function(items,
                        intercept.line.color = ""grey50"",
                        value.labels = ""show"",
                        showPercentageSign = FALSE,
-                       labelDigits = 0.1,
+                       labelDigits = 1,
                        legendLabels = NULL,
                        hideLegend = FALSE,
                        title = NULL, 
@@ -302,11 +306,7 @@ sjp.likert <- function(items,
       # --------------------------------------------------------
       # convert non-numeric factors to numeric values
       # --------------------------------------------------------
-      isnum <- na.omit(as.numeric(levels(items[, i])))
-      if (length(isnum) == 0) {
-        items[ ,i] <- sjmisc::to_value(items[ ,i], keep.labels = F)
-      }
-      items[ ,i] <- as.numeric(items[ ,i])
+      items[ ,i] <- sjmisc::to_value(items[ ,i], keep.labels = F)
     }
     # --------------------------------------------------------
     # If we have neutral category in between and not as last
@@ -386,8 +386,7 @@ sjp.likert <- function(items,
   # --------------------------------------------------------
   # reverse item order?
   # --------------------------------------------------------
-  if (!reverseOrder)
-    sort.freq <- rev(sort.freq)
+  if (!reverseOrder) sort.freq <- rev(sort.freq)
   # --------------------------------------------------------
   # save summed up y-values, for label positioning and annotation
   # --------------------------------------------------------
@@ -457,8 +456,14 @@ sjp.likert <- function(items,
   if (!is.null(cat.neutral)) {
     mydat.dk$grp <- as.factor(""neutral"")
     mydat.dk$geom.size <- geom.size
+    mydat.dk$labelDigits <- labelDigits
   }
   # --------------------------------------------------------
+  # label digits needed
+  # --------------------------------------------------------
+  mydat.neg$labelDigits <- labelDigits
+  mydat.pos$labelDigits <- labelDigits
+  # --------------------------------------------------------
   # Prepare and trim legend labels to appropriate size
   # --------------------------------------------------------
   # wrap legend text lines
@@ -595,16 +600,14 @@ sjp.likert <- function(items,
   # check whether coordinates should be flipped, i.e.
   # swap x and y axis
   # ---------------------------------------------------------
-  if (coord.flip) {
-    gp <- gp + coord_flip()
-  }
+  if (coord.flip) gp <- gp + coord_flip()
   # ---------------------------------------------------------
   # set geom colors
   # ---------------------------------------------------------
   gp <- sj.setGeomColors(gp, 
                          geom.colors, 
                          (catcount + adding), 
-                         ifelse(hideLegend==TRUE, FALSE, TRUE), 
+                         ifelse(hideLegend == TRUE, FALSE, TRUE), 
                          legendLabels,
                          reverse.colors)
   # ---------------------------------------------------------

---FILE: R/sjPlotLinreg.R---
@@ -15,7 +15,7 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""vars"", ""Beta"", ""xv"", ""lo
 #' 
 #' @details \itemize{
 #'            \item If \code{type = ""lm""} and fitted model only has one predictor, no forest plot is shown. Instead, a regression line with confidence interval (in blue) is plotted by default, and a loess-smoothed line without confidence interval (in red) can be added if parameter \code{showLoess} is \code{TRUE}.
-#'            \item If \code{type = ""pred""}, regression lines with confidence intervals for each single predictor of the fitted model are plotted, i.e. all predictors of the fitted model are extracted and each of them are fitted against the response variable.
+#'            \item If \code{type = ""pred""}, regression lines (slopes) with confidence intervals for each single predictor of the fitted model are plotted, i.e. all predictors of the fitted model are extracted and each of them is plotted against the response variable.
 #'            \item If \code{type = ""ma""} (i.e. checking model assumptions), please note that only three parameters are relevant: \code{fit}, \code{completeDiagnostic} and \code{showOriginalModelOnly}. All other parameters are ignored.
 #'            \item If \code{type = ""vif""}, the Variance Inflation Factors (check for multicollinearity) are plotted. As a rule of thumb, values below 5 are considered as good and indicate no multicollinearity, values between 5 and 10 may be tolerable. Values greater than 10 are not acceptable and indicate multicollinearity between model's predictors.
 #'            }
@@ -336,8 +336,8 @@ sjp.lm <- function(fit,
   # if no values should be shown, clear
   # vector now
   if (!showValueLabels) {
-    ps <- rep(c(""""), length(ps))
-    pstdbv <- rep(c(""""), length(pstdbv))
+    ps <- rep("""", length(ps))
+    pstdbv <- rep("""", length(pstdbv))
   }
   # --------------------------------------------------------
   # copy p-values into data column
@@ -373,15 +373,15 @@ sjp.lm <- function(fit,
         # row (Intercept) will be removed / ignored
         coefficients(fit)[-1],
         # append CI
-        confint(fit, level=0.95)[-1, 1],
-        confint(fit, level=0.95)[-1, 2])
+        confint(fit, level = 0.95)[-1, 1],
+        confint(fit, level = 0.95)[-1, 2])
     } else {
       tmp <- data.frame(cbind(
         # Append beta coefficients, [-1] means that the first
         # row (Intercept) will be removed / ignored
         coefficients(fit)[-1],
         # append CI
-        confint(fit, level=0.95)[-1, ]))
+        confint(fit, level = 0.95)[-1, ]))
     }
   }
   # append p-values and standardized beta coefficients
@@ -442,7 +442,7 @@ sjp.lm <- function(fit,
   # --------------------------------------------------------
   # Start plot here!
   # --------------------------------------------------------
-  betaplot <- ggplot(betas, aes(y = Beta, x = xv, colour = Beta >= 0)) +
+  betaplot <- ggplot(betas, aes(y = Beta, x = xv, colour = (Beta >= 0))) +
     # and error bar
     geom_errorbar(aes(ymin = lower, ymax = upper), width = 0) +
     # Print p-values. With vertical adjustment, so they don't overlap with the errorbars
@@ -512,9 +512,18 @@ sjp.reglin <- function(fit,
     # plm objects have different structure than (g)lm
     fit_x <- data.frame(cbind(as.vector(fit$model[, 1]), model.matrix(fit)))
     depvar.label <- attr(attr(attr(fit$model, ""terms""), ""dataClasses""), ""names"")[1]
+    # retrieve response vector
+    resp <- as.vector(fit$model[, 1])
+  } else if (any(class(fit) == ""lmerMod"")) {
+    fit_x <- data.frame(model.matrix(fit))
+    # retrieve response vector
+    resp <- lme4::getME(fit, ""y"")
+    depvar.label <- attr(attr(attr(fit@frame, ""terms""), ""dataClasses""), ""names"")[1]
   } else {
     fit_x <- data.frame(model.matrix(fit))
     depvar.label <- attr(attr(fit$terms, ""dataClasses""), ""names"")[1]
+    # retrieve response vector
+    resp <- as.vector(fit$model[, 1])
   }
   predvars <- colnames(fit_x)[-1]
   cn <- predvars
@@ -545,16 +554,14 @@ sjp.reglin <- function(fit,
     # as data columns, used for the ggplot
     # -----------------------------------------------------------
     if (useResiduals) {
-      mydat <- as.data.frame(cbind(fit_x[, which(cn == xval) + 1],
-                                   fit$residuals))
+      mydat <- data.frame(x = fit_x[, which(cn == xval) + 1], y = residuals(fit))
     } else {
-      mydat <- as.data.frame(cbind(fit_x[, which(cn == xval) + 1],
-                                   as.vector(fit$model[, 1])))
+      mydat <- data.frame(x = fit_x[, which(cn == xval) + 1], y = resp)
     }
     # -----------------------------------------------------------
     # plot regression line and confidence intervall
     # -----------------------------------------------------------
-    reglinplot <- ggplot(mydat, aes(x = V1, y = V2)) +
+    reglinplot <- ggplot(mydat, aes(x = x, y = y)) +
       stat_smooth(method = ""lm"", 
                   se = showCI, 
                   level = ciLevel, 

---FILE: R/sjPlotStackFrequencies.R---
@@ -84,39 +84,22 @@
 #' # random sample
 #' # -------------------------------
 #' # prepare data for 4-category likert scale, 5 items
-#' likert_4 <- data.frame(as.factor(sample(1:4, 
-#'                                         500, 
-#'                                         replace = TRUE, 
-#'                                         prob = c(0.2, 0.3, 0.1, 0.4))),
-#'                        as.factor(sample(1:4, 
-#'                                         500, 
-#'                                         replace = TRUE, 
-#'                                         prob = c(0.5, 0.25, 0.15, 0.1))),
-#'                        as.factor(sample(1:4, 
-#'                                         500, 
-#'                                         replace = TRUE, 
-#'                                         prob = c(0.25, 0.1, 0.4, 0.25))),
-#'                        as.factor(sample(1:4, 
-#'                                         500, 
-#'                                         replace = TRUE, 
-#'                                         prob = c(0.1, 0.4, 0.4, 0.1))),
-#'                        as.factor(sample(1:4, 
-#'                                         500, 
-#'                                         replace = TRUE, 
-#'                                         prob = c(0.35, 0.25, 0.15, 0.25))))
+#' Q1 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.2, 0.3, 0.1, 0.4)))
+#' Q2 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.5, 0.25, 0.15, 0.1)))
+#' Q3 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.25, 0.1, 0.4, 0.25)))
+#' Q4 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.1, 0.4, 0.4, 0.1)))
+#' Q5 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.35, 0.25, 0.15, 0.25)))
+#' 
+#' likert_4 <- data.frame(Q1, Q2, Q3, Q4, Q5)
+#' 
 #' # create labels
 #' levels_4 <- list(c(""Independent"", 
 #'                    ""Slightly dependent"", 
 #'                    ""Dependent"", 
 #'                    ""Severely dependent""))
 #' 
-#' # create item labels
-#' items <- list(c(""Q1"", ""Q2"", ""Q3"", ""Q4"", ""Q5""))
-#' 
 #' # plot stacked frequencies of 5 (ordered) item-scales
-#' sjp.stackfrq(likert_4, 
-#'              legendLabels = levels_4, 
-#'              axisLabels.y = items)
+#' sjp.stackfrq(likert_4, legendLabels = levels_4)
 #' 
 #' 
 #' # -------------------------------
@@ -181,7 +164,7 @@ sjp.stackfrq <- function(items,
                         axisTitle.x=NULL,
                         axisTitle.y=NULL,
                         showValueLabels=TRUE,
-                        labelDigits = 0.1,
+                        labelDigits = 1,
                         showPercentageAxis=TRUE,
                         jitterValueLabels=FALSE,
                         showItemLabels=TRUE,
@@ -304,11 +287,11 @@ sjp.stackfrq <- function(items,
     # create new data frame. We now have a data frame with all
     # variable categories abd their related percentages, including
     # zero counts, but no(!) missings!
-    mydf <- as.data.frame(cbind(grp = i, 
-                                cat = 1:countlen, 
-                                prc))
+    mydf <- data.frame(grp = i, 
+                       cat = 1:countlen, 
+                       prc)
     # now, append data frames
-    mydat <- as.data.frame(rbind(mydat, mydf))
+    mydat <- data.frame(rbind(mydat, mydf))
   }
   # ----------------------------
   # make sure group and count variable 
@@ -317,7 +300,6 @@ sjp.stackfrq <- function(items,
   mydat$grp <- as.factor(mydat$grp)
   mydat$cat <- as.factor(mydat$cat)
   # add half of Percentage values as new y-position for stacked bars
-  # mydat = ddply(mydat, ""grp"", transform, ypos = cumsum(prc) - 0.5*prc)
   mydat <- mydat %>% 
     dplyr::group_by(grp) %>% 
     dplyr::mutate(ypos = cumsum(prc) - 0.5 * prc) %>% 
@@ -406,8 +388,9 @@ sjp.stackfrq <- function(items,
     expgrid <- c(0, 0)
   }
   # --------------------------------------------------------
-  # Set value labels
+  # Set value labels and label digits
   # --------------------------------------------------------
+  mydat$labelDigits <- labelDigits
   if (showValueLabels) {
     if (jitterValueLabels) {
       ggvaluelabels <-  geom_text(aes(y = ypos, label = sprintf(""%.*f%%"", labelDigits, 100 * prc)),

---FILE: README.md---
@@ -60,7 +60,8 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 * `sjp.int` and `sjp.lm` now support `plm` objects (from plm-package).
 * Parameters `orderBy` and `reverseOrder` in `sjp.stackfrq` and `sjt.stackfrq` were merged into new parameter `sort.frq`.
 * Parameter `transformTicks` in `sjp.glm` and `sjp.glmm` now defaults to `TRUE`.
-* Parameter `labelDigits` added to functions `sjp.likert` and `sjp.stackfrq`, so digits of value labels can be changed.
+* Added parameter `labelDigits` to functions `sjp.likert` and `sjp.stackfrq`, so digits of value labels can be changed.
+* Added option `fe.pred` to `type`-parameter of `sjp.lmer` to plot slopes for each single fixed effect.
 * Renamed parameters `y` and `x` in `sjp.xtab` into `var` and `grp`.
 * Added further pre-set themes to `sjp.setTheme`.
 * Minor improvements of `sjp.setTheme`.

---FILE: man/sjp.likert.Rd---
@@ -8,7 +8,7 @@ sjp.likert(items, catcount = NULL, cat.neutral = NULL, weightBy = NULL,
   weightByTitleString = NULL, sort.frq = NULL, geom.size = 0.6,
   geom.colors = ""BrBG"", reverse.colors = FALSE,
   cat.neutral.color = ""grey70"", intercept.line.color = ""grey50"",
-  value.labels = ""show"", showPercentageSign = FALSE, labelDigits = 0.1,
+  value.labels = ""show"", showPercentageSign = FALSE, labelDigits = 1,
   legendLabels = NULL, hideLegend = FALSE, title = NULL,
   legendTitle = NULL, includeN = TRUE, showItemLabels = TRUE,
   axisLabels.y = NULL, breakTitleAt = 50, breakLabelsAt = 30,
@@ -24,10 +24,10 @@ sjp.likert(items, catcount = NULL, cat.neutral = NULL, weightBy = NULL,
 Note that this parameter only applies to ""valid"" answers, i.e. if you
 have an additional neutral category (see \code{cat.neutral}) like ""don't know"",
 this won't count for \code{catcount} (e.g. ""strongly disagree"",
-""disagree"", ""agree"", ""strongly agree"" and neutral category ""son't know""
+""disagree"", ""agree"", ""strongly agree"" and neutral category ""don't know""
 would still mean that \code{catcount=4}). \cr
 Normally, this parameter can be ignored because the amount of valid categories
-is retrieved by the function itself.}
+is retrieved automatically.}
 
 \item{cat.neutral}{If there's a neutral category (like ""don't know"" etc.), specify
 the index number for this category. Else, set \code{cat.neutral=NULL} (default).
@@ -55,7 +55,7 @@ cases are weighted. Use a string as parameter, e.g.: \code{weightByTitleString=""
 \item{geom.colors}{User defined color palette for geoms. If specified, must either be vector with color values
 of same length as groups defined in \code{legendLabels}, or a specific color palette code (see below).
 \itemize{
-  \item If not specified, the diverging \code{""GnBu""} color brewer palette will be used.
+  \item If not specified, the diverging \code{""BrBG""} color brewer palette will be used.
   \item If \code{""gs""}, a greyscale will be used.
   \item If \code{geom.colors} is any valid color brewer palette name, the related \href{http://colorbrewer2.org}{color brewer} palette will be used. Use \code{display.brewer.all()} from the \code{RColorBrewer} package to view all available palette names.
 }
@@ -97,7 +97,7 @@ appear as legend text.}
 \item{axisLabels.y}{a character vector with labels for the y-axis (the labels of the
 \code{items}). Example: \code{axisLabels.y=c(""Q1"", ""Q2"", ""Q3"")}
 Axis labels will automatically be detected, when they have
-a \code{""variable.lable""} attribute (see \code{\link[sjmisc]{set_var_labels}}) for details).}
+a variable label attribute (see \code{\link[sjmisc]{set_var_labels}}) for details).}
 
 \item{breakTitleAt}{Wordwrap for diagram title. Determines how many chars of the title are displayed in
 one line and when a line break is inserted into the title.}
@@ -159,16 +159,14 @@ likert_2 <- data.frame(as.factor(sample(1:2, 500, replace=TRUE, prob=c(0.3,0.7))
 levels_2 <- c(""Agree"", ""Disagree"")
 
 # prepare data for 4-category likert scale, with neutral category 5 items
-likert_4 <- data.frame(as.factor(sample(1:5, 500, replace=TRUE,
-                                        prob=c(0.2,0.3,0.1,0.35,0.05))),
-                       as.factor(sample(1:5, 500, replace=TRUE,
-                                        prob=c(0.5,0.25,0.15,0.1,0.0))),
-                       as.factor(sample(1:5, 500, replace=TRUE,
-                                        prob=c(0.25,0.1,0.38,0.24,0.03))),
-                       as.factor(sample(1:5, 500, replace=TRUE,
-                                        prob=c(0.1,0.32,0.37,0.1,0.11))),
-                       as.factor(sample(1:5, 500, replace=TRUE,
-                                        prob=c(0.35,0.22,0.15,0.25, 0.03))))
+Q1 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.2, 0.3, 0.1, 0.4)))
+Q2 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.5, 0.25, 0.15, 0.1)))
+Q3 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.25, 0.1, 0.4, 0.25)))
+Q4 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.1, 0.4, 0.4, 0.1)))
+Q5 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.35, 0.25, 0.15, 0.25)))
+
+likert_4 <- data.frame(Q1, Q2, Q3, Q4, Q5)
+
 # create labels
 levels_4 <- c(""Strongly agree"",
               ""Agree"",
@@ -177,12 +175,16 @@ levels_4 <- c(""Strongly agree"",
               ""Don't know"")
 
 # prepare data for 6-category likert scale, 5 items
-likert_6 <- data.frame(
-               as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.2,0.1,0.1,0.3,0.2,0.1))),
-               as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.15,0.15,0.3,0.1,0.1,0.2))),
-               as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.2,0.25,0.05,0.2,0.2,0.2))),
-               as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.2,0.1,0.1,0.4,0.1,0.1))),
-               as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.1,0.4,0.1,0.3,0.05,0.15))))
+likert_6 <- data.frame()
+
+Q1 <- as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.2,0.1,0.1,0.3,0.2,0.1)))
+Q2 <- as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.15,0.15,0.3,0.1,0.1,0.2)))
+Q3 <- as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.2,0.25,0.05,0.2,0.2,0.2)))
+Q4 <- as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.2,0.1,0.1,0.4,0.1,0.1)))
+Q5 <- as.factor(sample(1:6, 500, replace=TRUE, prob=c(0.1,0.4,0.1,0.3,0.05,0.15)))
+
+likert_6 <- data.frame(Q1, Q2, Q3, Q4, Q5)
+
 # create labels
 levels_6 <- c(""Very strongly agree"", ""Strongly agree"", ""Agree"",
               ""Disagree"", ""Strongly disagree"", ""Very strongly disagree"")
@@ -213,6 +215,8 @@ sjp.likert(likert_6,
            legendLabels = levels_6,
            axisLabels.y = items,
            sort.frq = ""pos.asc"",
+           labelDigits = 0,
+           showPercentageSign = TRUE,
            value.labels = ""sum.inside"")
 }
 \seealso{

---FILE: man/sjp.lm.Rd---
@@ -179,7 +179,7 @@ Depending on the \code{type}, this function plots beta coefficients (estimates)
 \details{
 \itemize{
            \item If \code{type = ""lm""} and fitted model only has one predictor, no forest plot is shown. Instead, a regression line with confidence interval (in blue) is plotted by default, and a loess-smoothed line without confidence interval (in red) can be added if parameter \code{showLoess} is \code{TRUE}.
-           \item If \code{type = ""pred""}, regression lines with confidence intervals for each single predictor of the fitted model are plotted, i.e. all predictors of the fitted model are extracted and each of them are fitted against the response variable.
+           \item If \code{type = ""pred""}, regression lines (slopes) with confidence intervals for each single predictor of the fitted model are plotted, i.e. all predictors of the fitted model are extracted and each of them is plotted against the response variable.
            \item If \code{type = ""ma""} (i.e. checking model assumptions), please note that only three parameters are relevant: \code{fit}, \code{completeDiagnostic} and \code{showOriginalModelOnly}. All other parameters are ignored.
            \item If \code{type = ""vif""}, the Variance Inflation Factors (check for multicollinearity) are plotted. As a rule of thumb, values below 5 are considered as good and indicate no multicollinearity, values between 5 and 10 may be tolerable. Values greater than 10 are not acceptable and indicate multicollinearity between model's predictors.
            }

---FILE: man/sjp.lmer.Rd---
@@ -21,6 +21,7 @@ sjp.lmer(fit, type = ""re"", vars = NULL, ri.nr = 1, title = NULL,
   \item \code{""re""} (default) for estimates of random effects
   \item \code{""fe""} for estimates of fixed effects
   \item \code{""fe.std""} for standardized estimates of fixed effects
+  \item \code{""fe.pred""} for regression lines (slopes) with confidence intervals for each single fixed effect are plotted, i.e. all fixed effects are extracted and each is plotted against the response variable.
   \item \code{""fe.cor""} for correlation matrix of fixed effects
   \item \code{""re.qq""} for a QQ-plot of random effects (random effects quantiles against standard normal quantiles)
   \item \code{""fe.ri""} for fixed effects slopes depending on the random intercept.

---FILE: man/sjp.stackfrq.Rd---
@@ -10,7 +10,7 @@ sjp.stackfrq(items, legendLabels = NULL, sort.frq = NULL, weightBy = NULL,
   breakTitleAt = 50, breakLabelsAt = 30, breakLegendTitleAt = 30,
   breakLegendLabelsAt = 28, gridBreaksAt = 0.2, expand.grid = FALSE,
   geom.size = 0.5, geom.colors = ""Blues"", axisTitle.x = NULL,
-  axisTitle.y = NULL, showValueLabels = TRUE, labelDigits = 0.1,
+  axisTitle.y = NULL, showValueLabels = TRUE, labelDigits = 1,
   showPercentageAxis = TRUE, jitterValueLabels = FALSE,
   showItemLabels = TRUE, showSeparatorLine = FALSE,
   separatorLineColor = ""grey80"", separatorLineSize = 0.3,
@@ -128,39 +128,22 @@ Thanks to \href{http://www.clas.ufl.edu/users/forrest/}{Forrest Stevens} for bug
 # random sample
 # -------------------------------
 # prepare data for 4-category likert scale, 5 items
-likert_4 <- data.frame(as.factor(sample(1:4,
-                                        500,
-                                        replace = TRUE,
-                                        prob = c(0.2, 0.3, 0.1, 0.4))),
-                       as.factor(sample(1:4,
-                                        500,
-                                        replace = TRUE,
-                                        prob = c(0.5, 0.25, 0.15, 0.1))),
-                       as.factor(sample(1:4,
-                                        500,
-                                        replace = TRUE,
-                                        prob = c(0.25, 0.1, 0.4, 0.25))),
-                       as.factor(sample(1:4,
-                                        500,
-                                        replace = TRUE,
-                                        prob = c(0.1, 0.4, 0.4, 0.1))),
-                       as.factor(sample(1:4,
-                                        500,
-                                        replace = TRUE,
-                                        prob = c(0.35, 0.25, 0.15, 0.25))))
+Q1 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.2, 0.3, 0.1, 0.4)))
+Q2 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.5, 0.25, 0.15, 0.1)))
+Q3 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.25, 0.1, 0.4, 0.25)))
+Q4 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.1, 0.4, 0.4, 0.1)))
+Q5 <- as.factor(sample(1:4, 500, replace = TRUE, prob = c(0.35, 0.25, 0.15, 0.25)))
+
+likert_4 <- data.frame(Q1, Q2, Q3, Q4, Q5)
+
 # create labels
 levels_4 <- list(c(""Independent"",
                    ""Slightly dependent"",
                    ""Dependent"",
                    ""Severely dependent""))
 
-# create item labels
-items <- list(c(""Q1"", ""Q2"", ""Q3"", ""Q4"", ""Q5""))
-
 # plot stacked frequencies of 5 (ordered) item-scales
-sjp.stackfrq(likert_4,
-             legendLabels = levels_4,
-             axisLabels.y = items)
+sjp.stackfrq(likert_4, legendLabels = levels_4)
 
 
 # -------------------------------"
strengejacke,sjPlot,1967166591c0c11fe06e2bcff60c0a3108b959cf,Daniel Ldecke,d.luedecke@uke.de,2015-04-11T06:33:39Z,Daniel Ldecke,d.luedecke@uke.de,2015-04-11T06:33:39Z,fixed axis title labeling bug,R/sjPlotInteractions.R;tests/testthat/test_sjpint.R,False,True,True,False,115,3,118,"---FILE: R/sjPlotInteractions.R---
@@ -346,7 +346,6 @@ sjp.int <- function(fit,
     fun <- ""lmer""
     stat.fun <- ""lm""
   }
-  if ((fun == ""glm"" || fun == ""glmer"") && is.null(axisTitle.y)) axisTitle.y <- ""Change in Predicted Probability""
   # ------------------------
   # check if suggested package is available
   # ------------------------
@@ -402,6 +401,10 @@ sjp.int <- function(fit,
                         gridBreaksAt, showCI, facet.grid, printPlot, fun))
   }
   # -----------------------------------------------------------
+  # set axis title
+  # -----------------------------------------------------------
+  if ((fun == ""glm"" || fun == ""glmer"") && is.null(axisTitle.y)) axisTitle.y <- ""Change in Predicted Probability""
+  # -----------------------------------------------------------
   # retrieve coefficients
   # -----------------------------------------------------------
   coef.tab <- summary(fit)$coefficients
@@ -1146,6 +1149,8 @@ sjp.eff.int <- function(fit,
     # need to be removed
     # -----------------------------------------------------------
     intdf <- droplevels(intdf)
+    # group as factor
+    intdf$grp <- as.factor(intdf$grp)
     # -----------------------------------------------------------
     # convert df-values to numeric
     # -----------------------------------------------------------
@@ -1154,8 +1159,6 @@ sjp.eff.int <- function(fit,
       laby <- response.name
       # make sure x is numeric
       intdf$x <- sjmisc::to_value(intdf$x, keep.labels = F)
-      # group as factor
-      intdf$grp <- as.factor(intdf$grp)
       # -----------------------------------------------------------
       # retrieve lowest and highest x and y position to determine
       # the scale limits

---FILE: tests/testthat/test_sjpint.R---
@@ -0,0 +1,109 @@
+test_that(""Check tab crosstabs"", { 
+  skip_on_cran()
+  
+  fit <- lm(weight ~ Time * Diet, data = ChickWeight)
+  
+  # show summary to see significant interactions
+  summary(fit)
+  
+  # plot regression line of interaction terms
+  sjp.int(fit)
+  # plot regression line of interaction terms, including value labels
+  sjp.int(fit, showValueLabels = TRUE)
+  
+  
+  # load sample data set
+  library(sjmisc)
+  data(efc)
+  # create data frame with variables that should be included
+  # in the model
+  mydf <- data.frame(usage = efc$tot_sc_e,
+                     sex = efc$c161sex,
+                     education = efc$c172code,
+                     burden = efc$neg_c_7,
+                     dependency = efc$e42dep)
+  # convert gender predictor to factor
+  mydf$sex <- relevel(factor(mydf$sex), ref = ""2"")
+  # fit ""dummy"" model
+  fit <- lm(usage ~ .*., data = mydf)
+  summary(fit)
+  
+  # plot interactions
+  sjp.int(fit)
+  
+  # plot interactions, using mean and sd as moderator
+  # values to calculate interaction effect
+  sjp.int(fit, moderatorValues = ""meansd"")
+  
+  # use zero and maximum value of moderation effect
+  sjp.int(fit, moderatorValues = ""zeromax"")
+  
+  # plot interactions, including those with p-value up to 0.1
+  sjp.int(fit, plevel = 0.1, showInterceptLines = TRUE)
+
+    
+  library(sjmisc)
+  data(efc)
+  # create binary response
+  y <- ifelse(efc$neg_c_7 < median(na.omit(efc$neg_c_7)), 0, 1)
+  # create data frame for fitted model
+  mydf <- data.frame(y = as.factor(y),
+                     sex = as.factor(efc$c161sex),
+                     barthel = as.numeric(efc$barthtot))
+  # fit model
+  fit <- glm(y ~ sex * barthel,
+             data = mydf,
+             family = binomial(link = ""logit""))
+  # plot interaction, increase p-level sensivity
+  sjp.int(fit,
+          legendLabels = get_val_labels(efc$c161sex),
+          plevel = 0.1)
+  
+  sjp.int(fit, type = ""eff"", showCI = T)
+  sjp.int(fit, type = ""eff"", showCI = T, axisLimits.y = c(0.5, 0.75))
+  sjp.int(fit, type = ""eff"", showCI = T, axisLimits.y = c(0.5, 0.75), facet.grid = T)  
+  
+  library(sjmisc)
+  data(efc)
+  # create data frame with variables that should be included
+  # in the model
+  mydf <- data.frame(burden = efc$neg_c_7,
+                     sex = efc$c161sex,
+                     education = efc$c172code)
+  # convert gender predictor to factor
+  mydf$sex <- factor(mydf$sex)
+  mydf$education <- factor(mydf$education)
+  # name factor levels and dependent variable
+  levels(mydf$sex) <- c(""female"", ""male"")
+  levels(mydf$education) <- c(""low"", ""mid"", ""high"")
+  mydf$burden <- set_var_labels(mydf$burden, ""care burden"")
+  # fit ""dummy"" model
+  fit <- lm(burden ~ .*., data = mydf)
+  summary(fit)
+  
+  ## Not run: 
+  # plot marginal means of interactions, no interaction found
+  sjp.int(fit, type = ""emm"")
+  ## End(Not run)
+  # plot marginal means of interactions, including those with p-value up to 1
+  sjp.int(fit, type = ""emm"", plevel = 1)
+  # swap predictors
+  sjp.int(fit,
+          type = ""emm"",
+          plevel = 1,
+          swapPredictors = TRUE)  
+  
+  mydf$barthel <- efc$barthtot
+  # re-fit model with continuous variable
+  fit <- lm(burden ~ .*., data = mydf)
+  
+  # plot effects
+  sjp.int(fit, type = ""eff"", showCI = TRUE)
+  
+  # plot effects, faceted
+  sjp.int(fit,
+          type = ""eff"",
+          int.plot.index = 3,
+          showCI = TRUE,
+          facet.grid = TRUE)
+})
\ No newline at end of file"
strengejacke,sjPlot,5dea55a3908a2465090b54e9d2ea059beb50b473,Daniel Ldecke,d.luedecke@uke.de,2015-04-11T06:11:52Z,Daniel Ldecke,d.luedecke@uke.de,2015-04-11T06:11:52Z,show error bars as CI in sjp.int for factors on x-axis,NEWS;R/sjPlotInteractions.R;README.md;man/sjp.int.Rd,False,True,True,False,35,10,45,"---FILE: NEWS---
@@ -16,7 +16,7 @@ Changes to functions:
 * Added parameter ""type"" to ""sjp.int"" to plot different types of interactions, including estimated marginal means.
 * Added parameter ""legendTitle"" to ""sjp.int"".
 * Added parameter ""int.plot.index"" to ""sjp.int"", so only selected interaction terms may be plotted.
-* Added parameter ""showCI"" to ""sjp.int"" (only for type = ""emm"") to add confidence intervals to estimated marginal means.
+* Added parameter ""showCI"" to ""sjp.int"" (only for type = ""emm"" and ""eff"") to add confidence intervals to estimated marginal means.
 * Added parameter ""facet.grid"" to ""sjp.int"" to plot each effect in a separate plot.
 * Parameter ""legendLabels"" of ""sjp.int"" now accepts a list of character vectors, with one vector of legend labels for each interaction plot plotted.
 * Parameter ""title"" of ""sjp.int"" now accepts a character vector of same length as interaction terms, with one title character string for each interaction plot plotted.

---FILE: R/sjPlotInteractions.R---
@@ -2,11 +2,13 @@
 #' @name sjp.int
 #'
 #' @references \itemize{
+#'              \item Fox J (2003) Effect displays in R for generalised linear models. Journal of Statistical Software 8:15, 127, \href{http://www.jstatsoft.org/v08/i15/}{<http://www.jstatsoft.org/v08/i15/>}.
+#'              \item Brambor T, Clark WR and Golder M (2006) Understanding Interaction Models: Improving Empirical Analyses. Political Analysis 14: 63-82 \href{https://files.nyu.edu/mrg217/public/pa_final.pdf}{download}
+#'              \item Aiken and West (1991). Multiple Regression: Testing and Interpreting Interactions.
 #'              \item \href{http://www.theanalysisfactor.com/interpreting-interactions-in-regression/}{Grace-Martin K: Interpreting Interactions in Regression}
 #'              \item \href{http://www.theanalysisfactor.com/clarifications-on-interpreting-interactions-in-regression/}{Grace-Martin K: Clarifications on Interpreting Interactions in Regression}
 #'              \item \href{http://www.theanalysisfactor.com/3-tips-interpreting-moderation/}{Grace-Martin K: 3 Tips to Make Interpreting Moderation Effects Easier}
 #'              \item \href{http://www.theanalysisfactor.com/using-adjusted-means-to-interpret-moderators-in-analysis-of-covariance/}{Grace-Martin K: Using Adjusted Means to Interpret Moderators in Analysis of Covariance.}
-#'              \item Aiken and West (1991). Multiple Regression: Testing and Interpreting Interactions.
 #'              }
 #'
 #' @seealso \href{http://www.strengejacke.de/sjPlot/sjp.int/}{sjPlot manual: sjp.int}
@@ -1129,6 +1131,8 @@ sjp.eff.int <- function(fit,
     response.name <- eff[[i]]$response
     # prepare axis titles
     labx <- pred_x.name
+    # check whether x-axis-predictor is a factor or not
+    x_is_factor <- is.factor(intdf[[pred_x.name]])
     # -----------------------------------------------------------
     # change column names
     # -----------------------------------------------------------
@@ -1273,18 +1277,37 @@ sjp.eff.int <- function(fit,
     # confidence interval?
     # ------------------------------------------------------------
     if (showCI) {
-      baseplot <- baseplot +
-        geom_ribbon(aes(ymin = lower, ymax = upper, colour = NULL, fill = grp),
-                    alpha = fillAlpha,
-                    show_guide = FALSE)
+      if (x_is_factor) {
+        # -------------------------------------------------
+        # for factors, we add error bars instead of
+        # continuous confidence region
+        # -------------------------------------------------
+        baseplot <- baseplot +
+          geom_errorbar(aes(ymin = lower, ymax = upper, colour = grp),
+                        width = 0,
+                        show_guide = FALSE) +
+          geom_point()
+      } else {
+        # -------------------------------------------------
+        # for continuous variables, we add  continuous 
+        # confidence region instead of error bars 
+        # -------------------------------------------------
+        baseplot <- baseplot +
+          geom_ribbon(aes(ymin = lower, ymax = upper, colour = NULL, fill = grp),
+                      alpha = fillAlpha,
+                      show_guide = FALSE)
+      }
     }
     baseplot <- baseplot + geom_line()
     # ------------------------------------------------------------
     # plot value labels
     # ------------------------------------------------------------
     if (showValueLabels) {
+      # don't need geom_point, because point-layer already 
+      # added with x_is_factor
+      if (!x_is_factor) baseplot <- baseplot + geom_point()
+      # add value label text
       baseplot <- baseplot +
-        geom_point() +
         geom_text(aes(label = round(y, 1)),
                   vjust = 1.5,
                   show_guide = FALSE)

---FILE: README.md---
@@ -43,13 +43,13 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 
 #### Changes to functions
 * `sjp.lmer` now calculates approximate p-values based on Wald chi-squared tests.
-* `sjp.glm` now supports plotting `logistf` objects [(#issue 11)](https://github.com/sjPlot/devel/issues/11).
+* `sjp.glm` now supports plotting `logistf` objects.
 * `sjp.glmm` and `sjp.lmm` now also accept a list of fitted models (see examples in `?sjp.glmm` and `?sjp.lmm`).
 * `sjp.int` and `sjp.lm` now support `plm` objects (from plm-package).
 * Added parameter `type` to `sjp.int` to plot different types of interactions, including estimated marginal means.
 * Added parameter `legendTitle` to `sjp.int`.
 * Added parameter `int.plot.index` to `sjp.int`, so only selected interaction terms may be plotted.
-* Added parameter `showCI` to `sjp.int` (only applies to `type = ""emm""` to add confidence intervals to estimated marginal means.
+* Added parameter `showCI` to `sjp.int` (only applies to `type = ""emm""` and `""eff""`) to add confidence intervals to estimated marginal means.
 * Added parameter `facet.grid` to `sjp.int` to plot each effect in a separate plot.
 * Parameter `moderatorValues` in `sjp.int` now has a new option `zeromax` for chosing the moderator values.
 * Parameter `legendLabels` of `sjp.int` now accepts a list of character vectors, with one vector of legend labels for each interaction plot plotted.

---FILE: man/sjp.int.Rd---
@@ -333,11 +333,13 @@ sjp.int(fit,
 }
 \references{
 \itemize{
+             \item Fox J (2003) Effect displays in R for generalised linear models. Journal of Statistical Software 8:15, 127, \href{http://www.jstatsoft.org/v08/i15/}{<http://www.jstatsoft.org/v08/i15/>}.
+             \item Brambor T, Clark WR and Golder M (2006) Understanding Interaction Models: Improving Empirical Analyses. Political Analysis 14: 63-82 \href{https://files.nyu.edu/mrg217/public/pa_final.pdf}{download}
+             \item Aiken and West (1991). Multiple Regression: Testing and Interpreting Interactions.
              \item \href{http://www.theanalysisfactor.com/interpreting-interactions-in-regression/}{Grace-Martin K: Interpreting Interactions in Regression}
              \item \href{http://www.theanalysisfactor.com/clarifications-on-interpreting-interactions-in-regression/}{Grace-Martin K: Clarifications on Interpreting Interactions in Regression}
              \item \href{http://www.theanalysisfactor.com/3-tips-interpreting-moderation/}{Grace-Martin K: 3 Tips to Make Interpreting Moderation Effects Easier}
              \item \href{http://www.theanalysisfactor.com/using-adjusted-means-to-interpret-moderators-in-analysis-of-covariance/}{Grace-Martin K: Using Adjusted Means to Interpret Moderators in Analysis of Covariance.}
-             \item Aiken and West (1991). Multiple Regression: Testing and Interpreting Interactions.
              }
 }
 \seealso{"
strengejacke,sjPlot,4a746ab7809e903b9981a195028afad64923f5f3,Daniel Ldecke,d.luedecke@uke.de,2015-04-10T22:25:03Z,Daniel Ldecke,d.luedecke@uke.de,2015-04-10T22:25:03Z,bug fix,R/helpfunctions.R;R/sjPlotAnova.R;R/sjPlotGLME.R;R/sjPlotGroupFrequencies.R;R/sjPlotInteractions.R;R/sjPlotLikert.R;R/sjPlotOdds.R;R/sjPlotPropTable.R;R/sjPlotStackFrequencies.R,False,True,True,False,34,34,68,"---FILE: R/helpfunctions.R---
@@ -123,7 +123,7 @@ create.frq.df <- function(varCount,
   }
   # Factors have to be transformed into numeric values
   # for continiuos x-axis-scale
-  df$y <- sjmisc::to_value(df$y)
+  df$y <- sjmisc::to_value(df$y, keep.labels = F)
   # if categories start with zero, fix this here
   if (min(df$y) == 0 && startAxisAt > 0) df$y <- df$y + 1
   # get the highest answer category of ""y"", so we know where the

---FILE: R/sjPlotAnova.R---
@@ -348,10 +348,10 @@ sjp.aov1 <- function(depVar,
   axisLabels.y <- axisLabels.y[catorder]
   # give columns names
   names(df) <- c(""means"", ""lower"", ""upper"", ""p"", ""pv"", ""xv"")
-  df$means <- sjmisc::to_value(df$means)
-  df$lower <- sjmisc::to_value(df$lower)
-  df$upper <- sjmisc::to_value(df$upper)
-  df$p <- sjmisc::to_value(df$p)
+  df$means <- sjmisc::to_value(df$means, keep.labels = F)
+  df$lower <- sjmisc::to_value(df$lower, keep.labels = F)
+  df$upper <- sjmisc::to_value(df$upper, keep.labels = F)
+  df$p <- sjmisc::to_value(df$p, keep.labels = F)
   df$pv <- as.character(df$pv)
   # bind color values to data frame, because we cannot use several
   # different color aesthetics in ggplot

---FILE: R/sjPlotGLME.R---
@@ -1005,7 +1005,7 @@ sjp.lme.feprobcurv <- function(fit,
       # melt variable
       mydf.vals <- data.frame(value = vals.unique)
       # convert factor to numeric
-      if (is.factor(mydf.vals$value)) mydf.vals$value <- sjmisc::to_value(mydf.vals$value, 0)
+      if (is.factor(mydf.vals$value)) mydf.vals$value <- sjmisc::to_value(mydf.vals$value, 0, keep.labels = F)
       # retrieve names of coefficients
       coef.names <- names(lme4::fixef(fit))
       # check if we have a factor, then we may have reference levels
@@ -1158,7 +1158,7 @@ sjp.lme.reprobcurve <- function(fit,
       # melt variable
       mydf.vals <- data.frame(value = vals.unique)
       # convert factor to numeric
-      if (is.factor(mydf.vals$value)) mydf.vals$value <- sjmisc::to_value(mydf.vals$value, 0)
+      if (is.factor(mydf.vals$value)) mydf.vals$value <- sjmisc::to_value(mydf.vals$value, 0, keep.labels = F)
       # retrieve names of coefficients
       coef.names <- names(lme4::fixef(fit))
       # check if we have a factor, then we may have reference levels
@@ -1294,8 +1294,8 @@ sjp.lme.feri <- function(fit,
       # check if we found any values...
       if (!is.null(xpos)) {
         final.df <- rbind(final.df,
-                          cbind(x = sjmisc::to_value(xpos),
-                                y = fi + ri + sjmisc::to_value(xpos) * estimates[j],
+                          cbind(x = sjmisc::to_value(xpos, keep.labels = F),
+                                y = fi + ri + sjmisc::to_value(xpos, keep.labels = F) * estimates[j],
                                 grp = i))
       }
     }

---FILE: R/sjPlotGroupFrequencies.R---
@@ -405,7 +405,7 @@ sjp.grpfrq <- function(varCount,
   dfgrp <- as.data.frame(table(df$varGroup))
   # Factors have to be transformed into numeric values
   # for continiuos x-axis-scale
-  df$varCount <- sjmisc::to_value(df$varCount)
+  df$varCount <- sjmisc::to_value(df$varCount, keep.labels = F)
   # if categories start with zero, fix this here
   if (min(df$varCount) == 0) df$varCount<- df$varCount + 1
   # convcert group variables to chars
@@ -454,13 +454,13 @@ sjp.grpfrq <- function(varCount,
     mydat <- data.frame(rbind(mydat, dummydat))
   }
   # convert grouping variable to character
-  mydat$count <- sjmisc::to_value(mydat$count)
+  mydat$count <- sjmisc::to_value(mydat$count, keep.labels = F)
   # convert grouping variable to character
-  mydat$group <- sjmisc::to_value(mydat$group)
+  mydat$group <- sjmisc::to_value(mydat$group, keep.labels = F)
   # convert frequencies to numeric
-  mydat$frq <- sjmisc::to_value(mydat$frq)
+  mydat$frq <- sjmisc::to_value(mydat$frq, keep.labels = F)
   # convert layer to numeric
-  mydat$layer <- sjmisc::to_value(mydat$layer)
+  mydat$layer <- sjmisc::to_value(mydat$layer, keep.labels = F)
   # -----------------------------------------------
   # Handle zero-counts in group-variable
   # only possible if we know the exact number of groups,
@@ -473,7 +473,7 @@ sjp.grpfrq <- function(varCount,
     # range of groups from lowest to highest group value
     allgroups <- factor(c(min(mydat$group):max(mydat$group)))
     # retrieve zero-counts, i.e. which group is missing in the data frame
-    miss <- sjmisc::to_value(allgroups[!allgroups %in% mydat$group])
+    miss <- sjmisc::to_value(allgroups[!allgroups %in% mydat$group], keep.labels = F)
     # retrieve subset of all rows where group is from lowest group-value to 
     # missing group
     dummy1 <- mydat[apply(mydat, MARGIN = 1, function(xy) all(xy[2] < miss)), ]
@@ -516,7 +516,7 @@ sjp.grpfrq <- function(varCount,
   # bind percentage as final column
   mydat <- as.data.frame(cbind(mydat, prz))
   # convert prz to numeric
-  mydat$texty <- sjmisc::to_value(mydat$prz)
+  mydat$texty <- sjmisc::to_value(mydat$prz, keep.labels = F)
   # add half of Percentage values as new y-position for stacked bars
   # mydat <- ddply(mydat, ""count"", transform, ypos = cumsum(frq) - 0.5*frq)
   mydat <- mydat %>% 
@@ -906,7 +906,7 @@ sjp.grpfrq <- function(varCount,
   # plot object for histogram style
   # ----------------------------------
   if (type == ""histogram"" || type == ""lines"") {
-    mydat$count <- sjmisc::to_value(mydat$count)
+    mydat$count <- sjmisc::to_value(mydat$count, keep.labels = F)
     if (type == ""histogram"") {
       # histrogram need fill aes
       baseplot <- ggplot(mydat, aes(x = count, y = frq, fill = group)) + geob

---FILE: R/sjPlotInteractions.R---
@@ -796,10 +796,10 @@ sjp.int <- function(fit,
     # convert df-values to numeric
     # -----------------------------------------------------------
     if (fun == ""lm"" || fun == ""lmer"") {
-      intdf$x <- sjmisc::to_value(intdf$x)
-      intdf$y <- sjmisc::to_value(intdf$y)
-      intdf$ymin <- sjmisc::to_value(intdf$ymin)
-      intdf$ymax <- sjmisc::to_value(intdf$ymax)
+      intdf$x <- sjmisc::to_value(intdf$x, keep.labels = F)
+      intdf$y <- sjmisc::to_value(intdf$y, keep.labels = F)
+      intdf$ymin <- sjmisc::to_value(intdf$ymin, keep.labels = F)
+      intdf$ymax <- sjmisc::to_value(intdf$ymax, keep.labels = F)
       intdf$ydiff <- intdf$ymax - intdf$ymin
       # -----------------------------------------------------------
       # retrieve lowest and highest x and y position to determine
@@ -820,10 +820,10 @@ sjp.int <- function(fit,
         upperLim.y <- axisLimits.y[2]
       }
     } else {
-      intdf$x <- sjmisc::to_value(intdf$x)
-      intdf$y <- odds.to.prob(sjmisc::to_value(intdf$y))
-      intdf$ymin <- odds.to.prob(sjmisc::to_value(intdf$ymin))
-      intdf$ymax <- odds.to.prob(sjmisc::to_value(intdf$ymax))
+      intdf$x <- sjmisc::to_value(intdf$x, keep.labels = F)
+      intdf$y <- odds.to.prob(sjmisc::to_value(intdf$y, keep.labels = F))
+      intdf$ymin <- odds.to.prob(sjmisc::to_value(intdf$ymin, keep.labels = F))
+      intdf$ymax <- odds.to.prob(sjmisc::to_value(intdf$ymax, keep.labels = F))
       intdf$ydiff <- odds.to.prob(intdf$ymax - intdf$ymin)
       # -----------------------------------------------------------
       # retrieve lowest and highest x and y position to determine
@@ -1149,7 +1149,7 @@ sjp.eff.int <- function(fit,
       # Label on y-axis is name of dependent variable
       laby <- response.name
       # make sure x is numeric
-      intdf$x <- sjmisc::to_value(intdf$x)
+      intdf$x <- sjmisc::to_value(intdf$x, keep.labels = F)
       # group as factor
       intdf$grp <- as.factor(intdf$grp)
       # -----------------------------------------------------------
@@ -1174,7 +1174,7 @@ sjp.eff.int <- function(fit,
       # Label on y-axis is fixed
       if (is.null(axisTitle.y)) axisTitle.y <- ""Predicted Probability""
       # make sure x is numeric
-      intdf$x <- sjmisc::to_value(intdf$x)
+      intdf$x <- sjmisc::to_value(intdf$x, keep.labels = F)
       # convert log-odds to probabilities
       intdf$y <- odds.to.prob(intdf$y)
       intdf$lower <- odds.to.prob(intdf$lower)

---FILE: R/sjPlotLikert.R---
@@ -304,7 +304,7 @@ sjp.likert <- function(items,
       # --------------------------------------------------------
       isnum <- na.omit(as.numeric(levels(items[, i])))
       if (length(isnum) == 0) {
-        items[ ,i] <- sjmisc::to_value(items[ ,i])
+        items[ ,i] <- sjmisc::to_value(items[ ,i], keep.labels = F)
       }
       items[ ,i] <- as.numeric(items[ ,i])
     }

---FILE: R/sjPlotOdds.R---
@@ -548,7 +548,7 @@ sjp.glm.pc <- function(fit,
       # melt variable
       mydf.vals <- data.frame(values = values)
       # convert factor to numeric
-      if (is.factor(mydf.vals$values)) mydf.vals$values <- sjmisc::to_value(mydf.vals$values, 0)
+      if (is.factor(mydf.vals$values)) mydf.vals$values <- sjmisc::to_value(mydf.vals$values, 0, keep.labels = F)
       # retrieve names of coefficients
       coef.names <- names(coef(fit))
       # check if we have a factor, then we may have reference levels

---FILE: R/sjPlotPropTable.R---
@@ -372,11 +372,11 @@ sjp.xtab <- function(y,
     # if the maximum value of the group variable differs from the estimated
     # group length we probably have missing categoriesm, i.e. one group has no
     # cases. Then, we insert an empty row here
-    mydf$Group <- sjmisc::to_value(mydf$Group)
+    mydf$Group <- sjmisc::to_value(mydf$Group, keep.labels = F)
     # range of groups from lowest to highest group value
     allgroups <- factor(c(min(mydf$Group):max(mydf$Group)))
     # retrieve zero-counts, i.e. which group is missing in the data frame
-    miss <- sjmisc::to_value(allgroups[!allgroups %in% mydf$Group])
+    miss <- sjmisc::to_value(allgroups[!allgroups %in% mydf$Group], keep.labels = F)
     # retrieve subset of all rows where group is from lowest group-value to 
     # missing group
     dummy1 <- mydf[apply(mydf, MARGIN=1, function(x) all(x[2]<miss)),]
@@ -410,8 +410,8 @@ sjp.xtab <- function(y,
       subdf <- mydf[mydf$Group == dfgrp$Var1[i],]
       # convert factors to numeric (due to calculations they have
       # to be treated like that)
-      subdf$Count <- sjmisc::to_value(subdf$Count)
-      subdf$Group <- sjmisc::to_value(subdf$Group)
+      subdf$Count <- sjmisc::to_value(subdf$Count, keep.labels = F)
+      subdf$Group <- sjmisc::to_value(subdf$Group, keep.labels = F)
       # Create a vector of zeros 
       frq <- rep(0,catcount)
       sm <- rep(0,catcount)

---FILE: R/sjPlotStackFrequencies.R---
@@ -268,7 +268,7 @@ sjp.stackfrq <- function(items,
     names(df) <- c(""var"", ""prc"")
     # need to be numeric, so percentage values (see below) are
     # correctly assigned, i.e. missing categories are considered
-    df$var <- sjmisc::to_value(df$var) + diff # if categories start with zero, fix this here
+    df$var <- sjmisc::to_value(df$var, keep.labels = F) + diff # if categories start with zero, fix this here
     # Create a vector of zeros 
     prc <- rep(0, countlen)
     # Replace the values in prc for those indices which equal df$var"
strengejacke,sjPlot,84c28d4a186fa8fabc9d6b7a4b232745791322d6,Daniel Ldecke,d.luedecke@uke.de,2015-04-10T22:17:04Z,Daniel Ldecke,d.luedecke@uke.de,2015-04-10T22:17:04Z,bug fix,R/sjPlotInteractions.R,False,True,True,False,1,1,2,"---FILE: R/sjPlotInteractions.R---
@@ -1223,7 +1223,7 @@ sjp.eff.int <- function(fit,
     # legend labels
     # -----------------------------------------------------------
     if (is.null(legendLabels)) {
-      lLabels <- as.vector(unique(intdf$grp))
+      lLabels <- levels(intdf$grp)
     } else {
       # copy plot counter 
       l_nr <- i"
strengejacke,sjPlot,55a892ed991a629a73080b3acf34718466b2b239,Daniel Ldecke,d.luedecke@uke.de,2015-04-10T22:09:45Z,Daniel Ldecke,d.luedecke@uke.de,2015-04-10T22:09:45Z,bug fix,R/sjPlotInteractions.R,False,True,True,False,1,1,2,"---FILE: R/sjPlotInteractions.R---
@@ -1120,7 +1120,7 @@ sjp.eff.int <- function(fit,
     # -----------------------------------------------------------
     # retrieve data frame
     # -----------------------------------------------------------
-    intdf <- data.frame(eff[[intpos[i]])
+    intdf <- data.frame(eff[[intpos[i]]])
     # -----------------------------------------------------------
     # save response, predictor and moderator names
     # -----------------------------------------------------------"
strengejacke,sjPlot,f65846a9d9b70e8c738bf20b8cc0348128f5f821,Daniel Ldecke,d.luedecke@uke.de,2015-04-10T22:08:23Z,Daniel Ldecke,d.luedecke@uke.de,2015-04-10T22:08:23Z,bug fix,R/sjPlotInteractions.R,False,True,True,False,1,1,2,"---FILE: R/sjPlotInteractions.R---
@@ -1120,7 +1120,7 @@ sjp.eff.int <- function(fit,
     # -----------------------------------------------------------
     # retrieve data frame
     # -----------------------------------------------------------
-    intdf <- data.frame(eff[[i]])
+    intdf <- data.frame(eff[[intpos[i]])
     # -----------------------------------------------------------
     # save response, predictor and moderator names
     # -----------------------------------------------------------"
strengejacke,sjPlot,31372d6daad047498c314d19bc3f4643125deefa,Daniel Ldecke,d.luedecke@uke.de,2015-04-10T22:04:44Z,Daniel Ldecke,d.luedecke@uke.de,2015-04-10T22:04:44Z,"bug fixes, code-style",R/helpfunctions.R;R/sjPlotAnova.R;R/sjPlotGLME.R;R/sjPlotGroupFrequencies.R;R/sjPlotInteractions.R;R/sjPlotPropTable.R;R/sjPlotStackFrequencies.R;man/sjp.glm.Rd;man/sjp.int.Rd,False,True,True,False,142,103,245,"---FILE: R/helpfunctions.R---
@@ -123,7 +123,7 @@ create.frq.df <- function(varCount,
   }
   # Factors have to be transformed into numeric values
   # for continiuos x-axis-scale
-  df$y <- as.numeric(as.character(df$y))
+  df$y <- sjmisc::to_value(df$y)
   # if categories start with zero, fix this here
   if (min(df$y) == 0 && startAxisAt > 0) df$y <- df$y + 1
   # get the highest answer category of ""y"", so we know where the

---FILE: R/sjPlotAnova.R---
@@ -348,10 +348,10 @@ sjp.aov1 <- function(depVar,
   axisLabels.y <- axisLabels.y[catorder]
   # give columns names
   names(df) <- c(""means"", ""lower"", ""upper"", ""p"", ""pv"", ""xv"")
-  df$means <- as.numeric(as.character(df$means))
-  df$lower <- as.numeric(as.character(df$lower))
-  df$upper <- as.numeric(as.character(df$upper))
-  df$p <- as.numeric(as.character(df$p))
+  df$means <- sjmisc::to_value(df$means)
+  df$lower <- sjmisc::to_value(df$lower)
+  df$upper <- sjmisc::to_value(df$upper)
+  df$p <- sjmisc::to_value(df$p)
   df$pv <- as.character(df$pv)
   # bind color values to data frame, because we cannot use several
   # different color aesthetics in ggplot

---FILE: R/sjPlotGLME.R---
@@ -1294,8 +1294,8 @@ sjp.lme.feri <- function(fit,
       # check if we found any values...
       if (!is.null(xpos)) {
         final.df <- rbind(final.df,
-                          cbind(x = as.numeric(as.character(xpos)),
-                                y = fi + ri + (as.numeric(as.character(xpos)) * estimates[j]),
+                          cbind(x = sjmisc::to_value(xpos),
+                                y = fi + ri + sjmisc::to_value(xpos) * estimates[j],
                                 grp = i))
       }
     }

---FILE: R/sjPlotGroupFrequencies.R---
@@ -405,7 +405,7 @@ sjp.grpfrq <- function(varCount,
   dfgrp <- as.data.frame(table(df$varGroup))
   # Factors have to be transformed into numeric values
   # for continiuos x-axis-scale
-  df$varCount <- as.numeric(as.character(df$varCount))
+  df$varCount <- sjmisc::to_value(df$varCount)
   # if categories start with zero, fix this here
   if (min(df$varCount) == 0) df$varCount<- df$varCount + 1
   # convcert group variables to chars
@@ -454,13 +454,13 @@ sjp.grpfrq <- function(varCount,
     mydat <- data.frame(rbind(mydat, dummydat))
   }
   # convert grouping variable to character
-  mydat$count <- as.numeric(as.character(mydat$count))
+  mydat$count <- sjmisc::to_value(mydat$count)
   # convert grouping variable to character
-  mydat$group <- as.numeric(as.character(mydat$group))
+  mydat$group <- sjmisc::to_value(mydat$group)
   # convert frequencies to numeric
-  mydat$frq <- as.numeric(as.character(mydat$frq))
+  mydat$frq <- sjmisc::to_value(mydat$frq)
   # convert layer to numeric
-  mydat$layer <- as.numeric(as.character(mydat$layer))
+  mydat$layer <- sjmisc::to_value(mydat$layer)
   # -----------------------------------------------
   # Handle zero-counts in group-variable
   # only possible if we know the exact number of groups,
@@ -473,7 +473,7 @@ sjp.grpfrq <- function(varCount,
     # range of groups from lowest to highest group value
     allgroups <- factor(c(min(mydat$group):max(mydat$group)))
     # retrieve zero-counts, i.e. which group is missing in the data frame
-    miss <- as.numeric(as.character(allgroups[!allgroups %in% mydat$group]))
+    miss <- sjmisc::to_value(allgroups[!allgroups %in% mydat$group])
     # retrieve subset of all rows where group is from lowest group-value to 
     # missing group
     dummy1 <- mydat[apply(mydat, MARGIN = 1, function(xy) all(xy[2] < miss)), ]
@@ -516,7 +516,7 @@ sjp.grpfrq <- function(varCount,
   # bind percentage as final column
   mydat <- as.data.frame(cbind(mydat, prz))
   # convert prz to numeric
-  mydat$texty <- as.numeric(as.character(mydat$prz))
+  mydat$texty <- sjmisc::to_value(mydat$prz)
   # add half of Percentage values as new y-position for stacked bars
   # mydat <- ddply(mydat, ""count"", transform, ypos = cumsum(frq) - 0.5*frq)
   mydat <- mydat %>% 
@@ -906,7 +906,7 @@ sjp.grpfrq <- function(varCount,
   # plot object for histogram style
   # ----------------------------------
   if (type == ""histogram"" || type == ""lines"") {
-    mydat$count <- as.numeric(as.character(mydat$count))
+    mydat$count <- sjmisc::to_value(mydat$count)
     if (type == ""histogram"") {
       # histrogram need fill aes
       baseplot <- ggplot(mydat, aes(x = count, y = frq, fill = group)) + geob

---FILE: R/sjPlotInteractions.R---
@@ -270,7 +270,20 @@
 #' # -------------------------------
 #' # Plot effects
 #' # -------------------------------
-#'  sjp.int(fit, type = ""eff"", showCI = TRUE)
+#' # add continuous variable
+#' mydf$barthel <- efc$barthtot
+#' # re-fit model with continuous variable
+#' fit <- lm(burden ~ .*., data = mydf)
+#' 
+#' # plot effects
+#' sjp.int(fit, type = ""eff"", showCI = TRUE)
+#'
+#' # plot effects, faceted
+#' sjp.int(fit, 
+#'         type = ""eff"", 
+#'         int.plot.index = 3,
+#'         showCI = TRUE,
+#'         facet.grid = TRUE)
 #'
 #' @import ggplot2
 #' @import sjmisc
@@ -783,10 +796,10 @@ sjp.int <- function(fit,
     # convert df-values to numeric
     # -----------------------------------------------------------
     if (fun == ""lm"" || fun == ""lmer"") {
-      intdf$x <- as.numeric(as.character(intdf$x))
-      intdf$y <- as.numeric(as.character(intdf$y))
-      intdf$ymin <- as.numeric(as.character(intdf$ymin))
-      intdf$ymax <- as.numeric(as.character(intdf$ymax))
+      intdf$x <- sjmisc::to_value(intdf$x)
+      intdf$y <- sjmisc::to_value(intdf$y)
+      intdf$ymin <- sjmisc::to_value(intdf$ymin)
+      intdf$ymax <- sjmisc::to_value(intdf$ymax)
       intdf$ydiff <- intdf$ymax - intdf$ymin
       # -----------------------------------------------------------
       # retrieve lowest and highest x and y position to determine
@@ -807,10 +820,10 @@ sjp.int <- function(fit,
         upperLim.y <- axisLimits.y[2]
       }
     } else {
-      intdf$x <- as.numeric(as.character(intdf$x))
-      intdf$y <- odds.to.prob(as.numeric(as.character(intdf$y)))
-      intdf$ymin <- odds.to.prob(as.numeric(as.character(intdf$ymin)))
-      intdf$ymax <- odds.to.prob(as.numeric(as.character(intdf$ymax)))
+      intdf$x <- sjmisc::to_value(intdf$x)
+      intdf$y <- odds.to.prob(sjmisc::to_value(intdf$y))
+      intdf$ymin <- odds.to.prob(sjmisc::to_value(intdf$ymin))
+      intdf$ymax <- odds.to.prob(sjmisc::to_value(intdf$ymax))
       intdf$ydiff <- odds.to.prob(intdf$ymax - intdf$ymin)
       # -----------------------------------------------------------
       # retrieve lowest and highest x and y position to determine
@@ -1095,6 +1108,8 @@ sjp.eff.int <- function(fit,
   # retrieve position of interaction terms in effects-object
   # ------------------------
   intpos <- which(as.vector(sapply(eff, function(x) length(grep(""*"", x['term'], fixed = T)) > 0)) == T)
+  # select only specific plots
+  if (!is.null(int.plot.index)) intpos <- intpos[int.plot.index]  
   # init vector that saves ggplot objects
   plotlist <- list()
   dflist <- list()
@@ -1123,11 +1138,18 @@ sjp.eff.int <- function(fit,
       colnames(intdf) <- c(""grp"", ""x"", ""y"", ""se"", ""lower"", ""upper"")
     }
     # -----------------------------------------------------------
+    # effects-package creates ""NA"" factor levels, which
+    # need to be removed
+    # -----------------------------------------------------------
+    intdf <- droplevels(intdf)
+    # -----------------------------------------------------------
     # convert df-values to numeric
     # -----------------------------------------------------------
     if (fun == ""lm"" || fun == ""lmer"") {
       # Label on y-axis is name of dependent variable
       laby <- response.name
+      # make sure x is numeric
+      intdf$x <- sjmisc::to_value(intdf$x)
       # group as factor
       intdf$grp <- as.factor(intdf$grp)
       # -----------------------------------------------------------
@@ -1151,6 +1173,8 @@ sjp.eff.int <- function(fit,
     } else {
       # Label on y-axis is fixed
       if (is.null(axisTitle.y)) axisTitle.y <- ""Predicted Probability""
+      # make sure x is numeric
+      intdf$x <- sjmisc::to_value(intdf$x)
       # convert log-odds to probabilities
       intdf$y <- odds.to.prob(intdf$y)
       intdf$lower <- odds.to.prob(intdf$lower)
@@ -1199,7 +1223,7 @@ sjp.eff.int <- function(fit,
     # legend labels
     # -----------------------------------------------------------
     if (is.null(legendLabels)) {
-      lLabels <- c(paste0(""lower bound of "", moderator.name), paste0(""upper bound of "", moderator.name))
+      lLabels <- as.vector(unique(intdf$grp))
     } else {
       # copy plot counter 
       l_nr <- i
@@ -1281,7 +1305,11 @@ sjp.eff.int <- function(fit,
     # ---------------------------------------------------------
     # set geom colors
     # ---------------------------------------------------------
-    baseplot <- sj.setGeomColors(baseplot, geom.colors, 2, !is.null(lLabels), lLabels)
+    baseplot <- sj.setGeomColors(baseplot, 
+                                 geom.colors, 
+                                 length(unique(na.omit(intdf$grp))), 
+                                 !is.null(lLabels), 
+                                 lLabels)
     # ---------------------------------------------------------
     # Check whether ggplot object should be returned or plotted
     # ---------------------------------------------------------

---FILE: R/sjPlotPropTable.R---
@@ -372,11 +372,11 @@ sjp.xtab <- function(y,
     # if the maximum value of the group variable differs from the estimated
     # group length we probably have missing categoriesm, i.e. one group has no
     # cases. Then, we insert an empty row here
-    mydf$Group <- as.numeric(as.character(mydf$Group))
+    mydf$Group <- sjmisc::to_value(mydf$Group)
     # range of groups from lowest to highest group value
     allgroups <- factor(c(min(mydf$Group):max(mydf$Group)))
     # retrieve zero-counts, i.e. which group is missing in the data frame
-    miss <- as.numeric(as.character(allgroups[!allgroups %in% mydf$Group]))
+    miss <- sjmisc::to_value(allgroups[!allgroups %in% mydf$Group])
     # retrieve subset of all rows where group is from lowest group-value to 
     # missing group
     dummy1 <- mydf[apply(mydf, MARGIN=1, function(x) all(x[2]<miss)),]
@@ -410,8 +410,8 @@ sjp.xtab <- function(y,
       subdf <- mydf[mydf$Group == dfgrp$Var1[i],]
       # convert factors to numeric (due to calculations they have
       # to be treated like that)
-      subdf$Count <- as.numeric(as.character(subdf$Count))
-      subdf$Group <- as.numeric(as.character(subdf$Group))
+      subdf$Count <- sjmisc::to_value(subdf$Count)
+      subdf$Group <- sjmisc::to_value(subdf$Group)
       # Create a vector of zeros 
       frq <- rep(0,catcount)
       sm <- rep(0,catcount)

---FILE: R/sjPlotStackFrequencies.R---
@@ -222,7 +222,9 @@ sjp.stackfrq <- function(items,
   # --------------------------------------------------------
   if (includeN && !is.null(axisLabels.y)) {
     for (i in 1:length(axisLabels.y)) {
-      axisLabels.y[i] <- paste(axisLabels.y[i], sprintf("" (n=%i)"", length(na.omit(items[, i]))), sep = """")
+      axisLabels.y[i] <- paste(axisLabels.y[i], 
+                               sprintf("" (n=%i)"", length(na.omit(items[, i]))), 
+                               sep = """")
     }
   }
   # -----------------------------------------------
@@ -240,16 +242,15 @@ sjp.stackfrq <- function(items,
   # determine minimum value. if 0, add one, because
   # vector indexing starts with 1
   # ----------------------------
-  if (any(apply(items, c(1,2), is.factor)) || any(apply(items, c(1,2), is.character))) {
-    diff <- ifelse(min(apply(items, c(1,2), as.numeric),na.rm=TRUE)==0, 1, 0)
-  }
-  else {
-    diff <- ifelse(min(items,na.rm=TRUE)==0, 1, 0)
+  if (any(apply(items, c(1, 2), is.factor)) || any(apply(items, c(1, 2), is.character))) {
+    diff <- ifelse(min(apply(items, c(1, 2), as.numeric), na.rm = TRUE) == 0, 1, 0)
+  } else {
+    diff <- ifelse(min(items, na.rm = TRUE) == 0, 1, 0)
   }
   # iterate item-list
   for (i in 1:ncol(items)) {
     # get each single items
-    variable <- items[,i]
+    variable <- items[ ,i]
     # -----------------------------------------------
     # create proportional table so we have the percentage
     # values that should be used as y-value for the bar charts
@@ -260,26 +261,24 @@ sjp.stackfrq <- function(items,
     # check whether counts should be weighted or not
     if (is.null(weightBy)) {
       df <- as.data.frame(prop.table(table(variable)))
-    }
-    else {
-      df <- as.data.frame(prop.table(round(xtabs(weightBy ~ variable),0)))
+    } else {
+      df <- as.data.frame(prop.table(round(xtabs(weightBy ~ variable), 0)))
     }
     # give columns names
     names(df) <- c(""var"", ""prc"")
     # need to be numeric, so percentage values (see below) are
     # correctly assigned, i.e. missing categories are considered
-    df$var <- as.numeric(as.character(df$var))+diff # if categories start with zero, fix this here
-    #     if (min(df$var)==0) {
-    #       df$var <- df$var+1
-    #     }
+    df$var <- sjmisc::to_value(df$var) + diff # if categories start with zero, fix this here
     # Create a vector of zeros 
-    prc <- rep(0,countlen)
+    prc <- rep(0, countlen)
     # Replace the values in prc for those indices which equal df$var
     prc[df$var] <- df$prc
     # create new data frame. We now have a data frame with all
     # variable categories abd their related percentages, including
     # zero counts, but no(!) missings!
-    mydf <- as.data.frame(cbind(grp=i, cat=1:countlen, prc))
+    mydf <- as.data.frame(cbind(grp = i, 
+                                cat = 1:countlen, 
+                                prc))
     # now, append data frames
     mydat <- as.data.frame(rbind(mydat, mydf))
   }
@@ -291,47 +290,43 @@ sjp.stackfrq <- function(items,
   mydat$cat <- as.factor(mydat$cat)
   # add half of Percentage values as new y-position for stacked bars
   # mydat = ddply(mydat, ""grp"", transform, ypos = cumsum(prc) - 0.5*prc)
-  mydat <- mydat %>% dplyr::group_by(grp) %>% dplyr::mutate(ypos = cumsum(prc) - 0.5*prc) %>% dplyr::arrange(grp)
+  mydat <- mydat %>% 
+    dplyr::group_by(grp) %>% 
+    dplyr::mutate(ypos = cumsum(prc) - 0.5 * prc) %>% 
+    dplyr::arrange(grp)
   # --------------------------------------------------------
   # Caculate vertical adjustment to avoid overlapping labels
   # --------------------------------------------------------
-  jvert <- rep(c(1.1,-0.1), length.out=length(unique(mydat$cat)))
-  jvert <- rep(jvert, length.out=nrow(mydat))
+  jvert <- rep(c(1.1, -0.1), length.out = length(unique(mydat$cat)))
+  jvert <- rep(jvert, length.out = nrow(mydat))
   # --------------------------------------------------------
   # Prepare and trim legend labels to appropriate size
   # --------------------------------------------------------
   # wrap legend text lines
   legendLabels <- sjmisc::word_wrap(legendLabels, breakLegendLabelsAt)    
   # check whether we have a title for the legend
-  if (!is.null(legendTitle)) {
-    # if yes, wrap legend title line
-    legendTitle <- sjmisc::word_wrap(legendTitle, breakLegendTitleAt)    
-  }
+  # if yes, wrap legend title line
+  if (!is.null(legendTitle)) legendTitle <- sjmisc::word_wrap(legendTitle, breakLegendTitleAt)
   # check length of diagram title and split longer string at into new lines
   # every 50 chars
   if (!is.null(title)) {
     # if we have weighted values, say that in diagram's title
-    if (!is.null(weightByTitleString)) {
-      title <- paste(title, weightByTitleString, sep="""")
-    }
+    if (!is.null(weightByTitleString)) title <- paste0(title, weightByTitleString)
     title <- sjmisc::word_wrap(title, breakTitleAt)    
   }
   # check length of x-axis-labels and split longer strings at into new lines
   # every 10 chars, so labels don't overlap
-  if (!is.null(axisLabels.y)) {
-    axisLabels.y <- sjmisc::word_wrap(axisLabels.y, breakLabelsAt)    
-  }
+  if (!is.null(axisLabels.y)) axisLabels.y <- sjmisc::word_wrap(axisLabels.y, breakLabelsAt)    
   # ----------------------------
   # Check if ordering was requested
   # ----------------------------
   if (!is.null(orderBy)) {
     # order by first cat
-    if (orderBy==""first"") {
-      facord <- order(mydat$prc[which(mydat$cat==1)])
-    }
-    # order by last cat
-    else {
-      facord <- order(mydat$prc[which(mydat$cat==countlen)])
+    if (orderBy == ""first"") {
+      facord <- order(mydat$prc[which(mydat$cat == 1)])
+    } else {
+      # order by last cat
+      facord <- order(mydat$prc[which(mydat$cat == countlen)])
     }
     # create dummy vectors from 1 to itemlength
     dummy1 <- dummy2 <- c(1:length(facord))
@@ -347,14 +342,13 @@ sjp.stackfrq <- function(items,
     # second pos and item 4 is on third pos in order)
     if (reverseOrder) {
       dummy2[rev(facord)] <- dummy1
-    }
-    else {
+    } else {
       dummy2[facord] <- dummy1
     }
     # now we have the order of either lowest to highest counts of first
     # or last category of ""items"". We now need to repeat these values as 
     # often as we have answer categories
-    orderedrow <- unlist(tapply(dummy2, 1:length(dummy2), function (x) rep(x,countlen)))
+    orderedrow <- unlist(tapply(dummy2, 1:length(dummy2), function (x) rep(x, countlen)))
     # replace old grp-order by new order
     mydat$grp <- as.factor(orderedrow)
     # reorder axis labels as well
@@ -364,74 +358,68 @@ sjp.stackfrq <- function(items,
   # check if category-oder on x-axis should be reversed
   # change category label order then
   # --------------------------------------------------------
-  if (reverseOrder && is.null(orderBy)) {
-    axisLabels.y <- rev(axisLabels.y)
-  }
+  if (reverseOrder && is.null(orderBy)) axisLabels.y <- rev(axisLabels.y)
   # --------------------------------------------------------
   # define vertical position for labels
   # --------------------------------------------------------
   if (coord.flip) {
     # if we flip coordinates, we have to use other parameters
     # than for the default layout
     vert <- 0.35
-  }
-  else {
+  } else {
     vert <- waiver()
   }
   # --------------------------------------------------------
   # set diagram margins
   # --------------------------------------------------------
   if (expand.grid) {
     expgrid <- waiver()
-  }
-  else {
-    expgrid <- c(0,0)
+  } else {
+    expgrid <- c(0, 0)
   }
   # --------------------------------------------------------
   # Set value labels
   # --------------------------------------------------------
   if (showValueLabels) {
     if (jitterValueLabels) {
-      ggvaluelabels <-  geom_text(aes(y=ypos, label=sprintf(""%.01f%%"", 100*prc)),
-                                  vjust=jvert)
+      ggvaluelabels <-  geom_text(aes(y = ypos, label = sprintf(""%.01f%%"", 100 * prc)),
+                                  vjust = jvert)
+    } else {
+      ggvaluelabels <-  geom_text(aes(y = ypos, label = sprintf(""%.01f%%"", 100 * prc)),
+                                  vjust = vert)
     }
-    else {
-      ggvaluelabels <-  geom_text(aes(y=ypos, label=sprintf(""%.01f%%"", 100*prc)),
-                                  vjust=vert)
-    }
-  }
-  else {
-    ggvaluelabels <-  geom_text(label="""")
+  } else {
+    ggvaluelabels <-  geom_text(label = """")
   }
   # --------------------------------------------------------
   # Set up grid breaks
   # --------------------------------------------------------
   if (is.null(gridBreaksAt)) {
     gridbreaks <- waiver()
-  }
-  else {
-    gridbreaks <- c(seq(0, 1, by=gridBreaksAt))
+  } else {
+    gridbreaks <- c(seq(0, 1, by = gridBreaksAt))
   }
   # --------------------------------------------------------
   # check if category-oder on x-axis should be reversed
   # change x axis order then
   # --------------------------------------------------------
   if (reverseOrder && is.null(orderBy)) {
-    baseplot <- ggplot(mydat, aes(x=rev(grp), y=prc, fill=cat))
-  }
-  else {
-    baseplot <- ggplot(mydat, aes(x=grp, y=prc, fill=cat))
+    baseplot <- ggplot(mydat, aes(x = rev(grp), y = prc, fill = cat))
+  } else {
+    baseplot <- ggplot(mydat, aes(x = grp, y = prc, fill = cat))
   }  
   baseplot <- baseplot +
     # plot bar chart
-    geom_bar(stat=""identity"", position=""stack"", width=geom.size)
+    geom_bar(stat = ""identity"", position = ""stack"", width = geom.size)
   # --------------------------------------------------------
   # check whether bars should be visually separated by an 
   # additional separator line
   # --------------------------------------------------------
   if (showSeparatorLine) {
     baseplot <- baseplot +
-      geom_vline(x=c(seq(1.5, length(items), by=1)), size=separatorLineSize, colour=separatorLineColor)
+      geom_vline(x = c(seq(1.5, length(items), by = 1)), 
+                 size = separatorLineSize, 
+                 colour = separatorLineColor)
   }
   # -----------------
   # show/hide percentage values on x axis
@@ -441,24 +429,29 @@ sjp.stackfrq <- function(items,
     # show absolute and percentage value of each bar.
     ggvaluelabels +
     # no additional labels for the x- and y-axis, only diagram title
-    labs(title=title, x=axisTitle.x, y=axisTitle.y, fill=legendTitle) +
+    labs(title = title, x = axisTitle.x, y = axisTitle.y, fill = legendTitle) +
     # print value labels to the x-axis.
     # If parameter ""axisLabels.y"" is NULL, the category numbers (1 to ...) 
     # appear on the x-axis
-    scale_x_discrete(labels=axisLabels.y) +
+    scale_x_discrete(labels = axisLabels.y) +
     # set Y-axis, depending on the calculated upper y-range.
     # It either corresponds to the maximum amount of cases in the data set
     # (length of var) or to the highest count of var's categories.
-    scale_y_continuous(breaks=gridbreaks, limits=c(0, 1), expand=expgrid, labels=percent)
+    scale_y_continuous(breaks = gridbreaks, 
+                       limits = c(0, 1), 
+                       expand = expgrid, 
+                       labels = percent)
   # check whether coordinates should be flipped, i.e.
   # swap x and y axis
-  if (coord.flip) {
-    baseplot <- baseplot + coord_flip()
-  }
+  if (coord.flip) baseplot <- baseplot + coord_flip()
   # ---------------------------------------------------------
   # set geom colors
   # ---------------------------------------------------------
-  baseplot <- sj.setGeomColors(baseplot, geom.colors, length(legendLabels), ifelse(hideLegend==TRUE, FALSE, TRUE), legendLabels)
+  baseplot <- sj.setGeomColors(baseplot, 
+                               geom.colors, 
+                               length(legendLabels), 
+                               ifelse(hideLegend == TRUE, FALSE, TRUE), 
+                               legendLabels)
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------

---FILE: man/sjp.glm.Rd---
@@ -133,11 +133,11 @@ Based on the script from \href{http://www.surefoss.org/dataanalysis/plotting-odd
 }
 \examples{
 # prepare dichotomous dependent variable
-y <- ifelse(swiss$Fertility<median(swiss$Fertility), 0, 1)
+y <- ifelse(swiss$Fertility < median(swiss$Fertility), 0, 1)
 
 # fit model
 fitOR <- glm(y ~ swiss$Education + swiss$Examination + swiss$Infant.Mortality + swiss$Catholic,
-             family=binomial(link=""logit""))
+             family = binomial(link = ""logit""))
 
 # print Odds Ratios as dots
 sjp.glm(fitOR)

---FILE: man/sjp.int.Rd---
@@ -312,6 +312,24 @@ sjp.int(fit,
         type = ""emm"",
         plevel = 1,
         swapPredictors = TRUE)
+
+# -------------------------------
+# Plot effects
+# -------------------------------
+# add continuous variable
+mydf$barthel <- efc$barthtot
+# re-fit model with continuous variable
+fit <- lm(burden ~ .*., data = mydf)
+
+# plot effects
+sjp.int(fit, type = ""eff"", showCI = TRUE)
+
+# plot effects, faceted
+sjp.int(fit,
+        type = ""eff"",
+        int.plot.index = 3,
+        showCI = TRUE,
+        facet.grid = TRUE)
 }
 \references{
 \itemize{"
strengejacke,sjPlot,c5de497fced185162fde48d2ee5332da7ec098cf,Daniel Ldecke,d.luedecke@uke.de,2015-04-10T21:11:19Z,Daniel Ldecke,d.luedecke@uke.de,2015-04-10T21:11:19Z,CRAN-check fixes,R/sjPlotInteractions.R;R/sjPlotOdds.R;man/sjp.glm.Rd;man/sjp.int.Rd,False,True,True,False,21,13,34,"---FILE: R/sjPlotInteractions.R---
@@ -134,7 +134,7 @@
 #'              to the \code{\link[effects]{effect}} function from the effects-package.
 #'            }
 #'            \item{type = ""eff}{plots the overall effects of the interaction, with all remaining
-#'              covariates set to the mean. Effects are calculated using the \code{\link[effects]{effecf}}-
+#'              covariates set to the mean. Effects are calculated using the \code{\link[effects]{effect}}-
 #'              function from the \code{effects}-package.
 #'            }
 #'            \item{type = ""emm""}{plots the estimated marginal means of Two-Way Repeated Measures AN(C)OVA,
@@ -267,6 +267,11 @@
 #'         plevel = 1, 
 #'         swapPredictors = TRUE)
 #'
+#' # -------------------------------
+#' # Plot effects
+#' # -------------------------------
+#'  sjp.int(fit, type = ""eff"", showCI = TRUE)
+#'
 #' @import ggplot2
 #' @import sjmisc
 #' @export
@@ -1122,7 +1127,7 @@ sjp.eff.int <- function(fit,
     # -----------------------------------------------------------
     if (fun == ""lm"" || fun == ""lmer"") {
       # Label on y-axis is name of dependent variable
-      laby <- paste0(""Change in "", response.name)
+      laby <- response.name
       # group as factor
       intdf$grp <- as.factor(intdf$grp)
       # -----------------------------------------------------------
@@ -1144,6 +1149,9 @@ sjp.eff.int <- function(fit,
         upperLim.y <- axisLimits.y[2]
       }
     } else {
+      # Label on y-axis is fixed
+      if (is.null(axisTitle.y)) axisTitle.y <- ""Predicted Probability""
+      # convert log-odds to probabilities
       intdf$y <- odds.to.prob(intdf$y)
       intdf$lower <- odds.to.prob(intdf$lower)
       intdf$upper <- odds.to.prob(intdf$upper)
@@ -1181,7 +1189,7 @@ sjp.eff.int <- function(fit,
                          response.name)
     } else {
       # copy plot counter 
-      l_nr <- cnt
+      l_nr <- i
       # check if we have enough labels. if not, use last labels
       if (l_nr > length(title)) l_nr <- length(title)
       # set legend labels for plot
@@ -1194,7 +1202,7 @@ sjp.eff.int <- function(fit,
       lLabels <- c(paste0(""lower bound of "", moderator.name), paste0(""upper bound of "", moderator.name))
     } else {
       # copy plot counter 
-      l_nr <- cnt
+      l_nr <- i
       # check if we have enough labels. if not, use last labels
       if (l_nr > length(legendLabels)) l_nr <- length(legendLabels)
       # set legend labels for plot
@@ -1207,7 +1215,7 @@ sjp.eff.int <- function(fit,
       lTitle <- moderator.name
     } else {
       # copy plot counter 
-      l_nr <- cnt
+      l_nr <- i
       # check if we have enough legend titles, if not, use last legend title
       if (l_nr > length(legendTitle)) l_nr <- length(legendTitle)
       # set legend title for plot
@@ -1218,7 +1226,7 @@ sjp.eff.int <- function(fit,
     # -----------------------------------------------------------
     if (!is.null(axisTitle.x)) {
       # copy plot counter 
-      l_nr <- cnt
+      l_nr <- i
       # check if we have enough axis titles, if not, use last legend title
       if (l_nr > length(axisTitle.x)) l_nr <- length(axisTitle.x)
       # set axis title

---FILE: R/sjPlotOdds.R---
@@ -96,17 +96,17 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""OR"", ""lower"", ""upper"", ""
 #'
 #' @examples
 #' # prepare dichotomous dependent variable
-#' y <- ifelse(swiss$Fertility<median(swiss$Fertility), 0, 1)
+#' y <- ifelse(swiss$Fertility < median(swiss$Fertility), 0, 1)
 #'
 #' # fit model
 #' fitOR <- glm(y ~ swiss$Education + swiss$Examination + swiss$Infant.Mortality + swiss$Catholic,
-#'              family=binomial(link=""logit""))
+#'              family = binomial(link = ""logit""))
 #'
 #' # print Odds Ratios as dots
 #' sjp.glm(fitOR)
 #'
 #' # print Odds Ratios as bars
-#' sjp.glm(fitOR, type=""bars"")
+#' sjp.glm(fitOR, type = ""bars"", geom.size = .3)
 #'
 #'
 #' # -------------------------------
@@ -583,7 +583,7 @@ sjp.glm.pc <- function(fit,
       # ""melt"" all single mydf's to one
       mydf.ges <- rbind(mydf.ges, mydf.metricpred[[i]])
       # create single plots for each numeric predictor
-      mp <- ggplot(mydf.metricpred[[i]], aes(x = value, y = y)) +
+      mp <- ggplot(mydf.metricpred[[i]], aes(x = values, y = y)) +
         labs(x = axisLabels.mp[i], 
              y = ""Probability"") +
         stat_smooth(method = ""glm"", 
@@ -595,7 +595,7 @@ sjp.glm.pc <- function(fit,
     }
     # if we have more than one numeric var, also create integrated plot
     if (length(mydf.metricpred) > 1) {
-      mp <- ggplot(mydf.ges, aes(x = value,
+      mp <- ggplot(mydf.ges, aes(x = values,
                                  y = y,
                                  colour = grp)) +
         labs(x = NULL,

---FILE: man/sjp.glm.Rd---
@@ -143,7 +143,7 @@ fitOR <- glm(y ~ swiss$Education + swiss$Examination + swiss$Infant.Mortality +
 sjp.glm(fitOR)
 
 # print Odds Ratios as bars
-sjp.glm(fitOR, type=""bars"")
+sjp.glm(fitOR, type = ""bars"", geom.size = .3)
 
 
 # -------------------------------

---FILE: man/sjp.int.Rd---
@@ -179,7 +179,7 @@ Plot regression (predicted values) or probability lines (predicted probabilities
              to the \code{\link[effects]{effect}} function from the effects-package.
            }
            \item{type = ""eff}{plots the overall effects of the interaction, with all remaining
-             covariates set to the mean. Effects are calculated using the \code{\link[effects]{effecf}}-
+             covariates set to the mean. Effects are calculated using the \code{\link[effects]{effect}}-
              function from the \code{effects}-package.
            }
            \item{type = ""emm""}{plots the estimated marginal means of Two-Way Repeated Measures AN(C)OVA,"
strengejacke,sjPlot,2b5f2603700f4af08fbde51b32d8c778041edca0,Daniel Ldecke,d.luedecke@uke.de,2015-04-06T16:06:01Z,Daniel Ldecke,d.luedecke@uke.de,2015-04-06T16:06:01Z,fixes #14,DESCRIPTION;NEWS;R/sjPlotAncovaLSMeans.R;R/sjPlotInteractions.R;README.md;man/sjPlot-package.Rd,False,True,True,False,170,150,320,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.7-10
-Date: 2015-04-01
+Version: 1.7-11
+Date: 2015-04-06
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of several plotting and table output functions for visualizing data.

---FILE: NEWS---
@@ -1,4 +1,4 @@
-Version 1.7-10
+Version 1.7-11
 ------------------------------------------------------------------------------
 General:
 * Utility, recode and statistical test functions have been moved to another package called ""sjmisc""! sjPlot now imports sjmisc.
@@ -28,6 +28,7 @@ Bug fixes:
 * ""sjp.glm"" and ""sjp.glmm"" should catch axis limits, which are out of printable bounds, hence these function should no longer stop in such cases.
 * ""sjp.lmer"" and ""sjp.glmer"" wrongly stated that paramter ""ri.nr"" was out of bound when ""type"" was ""re"", ""fe.ri"" or ""ri.pc"" - fixed.
 * Weights with decimals in ""sjt.xtab"" (e.g. ""weightBy = abs(rnorm(100, 2, 1)"") caused an error - fixed.
+* ""sjp.int"" did not work with interaction terms that used ""AsIs"" conversion (function ""I"") - fixed.
 
 
 Version 1.7

---FILE: R/sjPlotAncovaLSMeans.R---
@@ -3,26 +3,26 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""xn"", ""vld"", ""l.ci"", ""u.c
 
 #' @title Plot estimated marginal means of Two-Way Repeated Measures AN(C)OVA
 #' @name sjp.emm.int
-#' 
+#'
 #' @references \href{http://www.theanalysisfactor.com/using-adjusted-means-to-interpret-moderators-in-analysis-of-covariance/}{Grace-Martin K: Using Adjusted Means to Interpret Moderators in Analysis of Covariance.}
-#'             
-#' @description Plot estimated marginal means (also called \emph{least square means} or 
+#'
+#' @description Plot estimated marginal means (also called \emph{least square means} or
 #'                \emph{marginal means}) of (significant) interaction terms in two-way
-#'                repeated measure ANOVA or ANCOVA. The fitted models may be linear (mixed 
+#'                repeated measure ANOVA or ANCOVA. The fitted models may be linear (mixed
 #'                effects) models of class \code{\link{lm}} or \code{\link[lme4]{merMod}}.
-#'                This function may be used to plot differences in interventions between 
+#'                This function may be used to plot differences in interventions between
 #'                control and treatment groups over multiple time points.
-#' 
+#'
 #' @note Please note that all interaction terms have to be of type \code{\link{factor}}!
 #'         Furthermore, predictors of interactions that are introduced first into the model
 #'         are used as grouping variable, while the latter predictor is printed along the x-axis
 #'         (i.e. lm(y~a+b+a:b) means that ""a"" is used as grouping variable and ""b"" is plotted along the x-axis).
-#' 
+#'
 #' @seealso \itemize{
 #'            \item \href{http://www.strengejacke.de/sjPlot/sjp.emm.int/}{sjPlot manual: sjp.emm.int}
 #'            \item \href{http://strengejacke.wordpress.com/2014/08/19/visualize-pre-post-comparison-of-intervention-rstats/}{Weblog example}
 #'          }
-#' 
+#'
 #' @param fit the fitted linear (mixed effect) model (\code{\link{lm}} or \code{\link[lme4]{lmer}}),
 #'          including interaction terms.
 #' @param swapPredictors if \code{TRUE}, the grouping variable and predictor on
@@ -32,25 +32,25 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""xn"", ""vld"", ""l.ci"", ""u.c
 #' @param title a default title used for the plots. Default value is \code{NULL}, which means that each plot's title
 #'          includes the dependent variable as well as the names of the interaction terms.
 #' @param geom.colors A vector of color values.
-#' @param axisTitle.x a default title used for the x-axis. Default value is \code{NULL}, 
+#' @param axisTitle.x a default title used for the x-axis. Default value is \code{NULL},
 #'          which means that each plot's x-axis uses the predictor's name as title.
-#' @param axisTitle.y a default title used for the y-axis. Default value is \code{NULL}, 
+#' @param axisTitle.y a default title used for the y-axis. Default value is \code{NULL},
 #'          which means that each plot's y-axis uses the dependent variable's name as title.
-#' @param axisLabels.x Character vector with value labels of the repeated measure variable 
+#' @param axisLabels.x Character vector with value labels of the repeated measure variable
 #'          that are used for labelling the x-axis.
-#' @param legendTitle Character vector with title of the diagram's legend. Default is 
+#' @param legendTitle Character vector with title of the diagram's legend. Default is
 #'          \code{NULL}, so the name of the grouping variable is used as legend title.
-#' @param legendLabels Labels for the guide/legend. Default is \code{NULL}, so the levels of 
+#' @param legendLabels Labels for the guide/legend. Default is \code{NULL}, so the levels of
 #'          the grouping variable are used as legend labels.
 #' @param showValueLabels if \code{TRUE}, value labels are plotted along the lines. Default is \code{FALSE}.
 #' @param valueLabel.digits the amount of digits of the displayed value labels. Defaults to 2.
 #' @param showCI If \code{TRUE}, a confidence region for the estimated marginal means
 #'          will be plotted.
-#' @param breakTitleAt Wordwrap for diagram's title. Determines how many chars of the title are 
+#' @param breakTitleAt Wordwrap for diagram's title. Determines how many chars of the title are
 #'          displayed in one line and when a line break is inserted. Default is \code{50}.
-#' @param breakLegendTitleAt Wordwrap for diagram legend title. Determines how many chars of the legend's title 
+#' @param breakLegendTitleAt Wordwrap for diagram legend title. Determines how many chars of the legend's title
 #'          are displayed in one line and when a line break is inserted.
-#' @param breakLegendLabelsAt Wordwrap for diagram legend labels. Determines how many chars of the legend labels are 
+#' @param breakLegendLabelsAt Wordwrap for diagram legend labels. Determines how many chars of the legend labels are
 #'          displayed in one line and when a line break is inserted. Default is \code{20}.
 #' @param axisLimits.y A vector with two values, defining the lower and upper limit from the y-axis.
 #'          By default, this value is \code{NULL}, i.e. axis limits will be calculated upon the
@@ -59,14 +59,14 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""xn"", ""vld"", ""l.ci"", ""u.c
 #'          grid is being printed. Default is \code{NULL}.
 #' @param printPlot If \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 #'          want to plot any graphs. In either case, the ggplot-object will be returned as value.
-#' @return (Insisibily) returns the ggplot-objects with the complete plot-list (\code{plot.list}) 
+#' @return (Insisibily) returns the ggplot-objects with the complete plot-list (\code{plot.list})
 #'           as well as the data frame that were used for setting up the ggplot-objects (\code{df.list}).
-#' 
+#'
 #' @examples
 #' \dontrun{
 #' # Note that the data sets used in this example may not be perfectly suitable for
 #' # fitting linear models. I just used them because they are part of the R-software.
-#' 
+#'
 #' # prepare data frame
 #' df <- data.frame(mpg = mtcars$mpg,
 #'                  vs = factor(mtcars$vs),
@@ -75,24 +75,24 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""xn"", ""vld"", ""l.ci"", ""u.c
 #' fit <- lm(mpg ~ vs + am + vs:am, data = df)
 #' # show summary to see significant interactions
 #' summary(fit)
-#' 
+#'
 #' # plot marginal means of interaction terms
 #' # note we have to adjust plevel, because no interaction
 #' # is significant
 #' sjp.emm.int(fit, plevel = 1)
 #' # plot marginal means of interaction terms, including value labels
 #' sjp.emm.int(fit, plevel = 1, showValueLabels = TRUE)
-#' 
-#' 
+#'
+#'
 #' # load sample data set
 #' library(sjmisc)
 #' data(efc)
 #' # create data frame with variables that should be included
 #' # in the model
 #' mydf <- data.frame(burden = efc$neg_c_7,
-#'                    sex = efc$c161sex, 
+#'                    sex = efc$c161sex,
 #'                    education = efc$c172code)
-#' # convert gender predictor to factor                         
+#' # convert gender predictor to factor
 #' mydf$sex <- factor(mydf$sex)
 #' mydf$education <- factor(mydf$education)
 #' # name factor levels and dependent variable
@@ -102,15 +102,15 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""xn"", ""vld"", ""l.ci"", ""u.c
 #' # fit ""dummy"" model
 #' fit <- lm(burden ~ .*., data = mydf, na.action = na.omit)
 #' summary(fit)
-#' 
+#'
 #' # plot marginal means of interactions, no interaction found
 #' sjp.emm.int(fit)
 #' # plot marginal means of interactions, including those with p-value up to 1
 #' sjp.emm.int(fit, plevel = 1)
 #' # swap predictors
 #' sjp.emm.int(fit, plevel = 1, swapPredictors = TRUE)}
-#' 
-#' 
+#'
+#'
 #' @import ggplot2
 #' @import sjmisc
 #' @export
@@ -147,8 +147,8 @@ sjp.emm.int <- function(fit,
   # -----------------------------------------------------------
   if (any(class(fit) == ""lmerMod"")) {
     return (sjp.emm.lmer(fit, swapPredictors, plevel, title, geom.colors,
-                         axisTitle.x, axisTitle.y, axisLabels.x, legendLabels, 
-                         showValueLabels, valueLabel.digits, showCI, breakTitleAt, 
+                         axisTitle.x, axisTitle.y, axisLabels.x, legendLabels,
+                         showValueLabels, valueLabel.digits, showCI, breakTitleAt,
                          breakLegendLabelsAt, axisLimits.y, gridBreaksAt, printPlot))
   }
   # init vector that saves ggplot objects
@@ -229,8 +229,8 @@ sjp.emm.int <- function(fit,
     # -----------------------------------------------------------
     for (cnt in 1:length(intnames)) {
       # -----------------------------------------------------------
-      # first, retrieve and split interaction term so we know 
-      # the two predictor variables, or factor levels of the 
+      # first, retrieve and split interaction term so we know
+      # the two predictor variables, or factor levels of the
       # interaction term
       # -----------------------------------------------------------
       lvls <- unlist(strsplit(intnames[cnt], "":""))
@@ -243,7 +243,7 @@ sjp.emm.int <- function(fit,
       # found, and use the term labels for ls means...
       # -----------------------------------------------------------
       if (grepl(terms[1], lvls[1], fixed = T) && grepl(terms[2], lvls[2], fixed = T)) {
-        # we found a match        
+        # we found a match
         interactionterms <- rbind(interactionterms, terms)
         # leave loop
         break
@@ -261,11 +261,11 @@ sjp.emm.int <- function(fit,
     # -----------------------------------------------------------
     emm <- summary(lsmeans::lsmeans.character(fit, term.pairs))
     # create data frame from lsmeans
-    intdf <- data.frame(emm[2], 
+    intdf <- data.frame(emm[2],
                         emm[3],
-                        emm[1], 
-                        emm[6], 
-                        emm[7], 
+                        emm[1],
+                        emm[6],
+                        emm[7],
                         rep(valueLabel.digits, times = nrow(emm[1])))
     colnames(intdf) <- c(""x"", ""y"", ""grp"", ""l.ci"", ""u.ci"", ""vld"")
     # -----------------------------------------------------------
@@ -316,7 +316,7 @@ sjp.emm.int <- function(fit,
     # prepare plot title and axis titles
     # -----------------------------------------------------------
     if (is.null(title)) {
-      labtitle <- paste0(""Estimated marginal means of "", response.name, 
+      labtitle <- paste0(""Estimated marginal means of "", response.name,
                          "" between "", term.pairs[2],
                          "" and "", term.pairs[1])
     } else {
@@ -366,12 +366,12 @@ sjp.emm.int <- function(fit,
     # -----------------------------------------------------------
     # Confidence intervals?
     # -----------------------------------------------------------
-    if (showCI) baseplot <- baseplot + 
+    if (showCI) baseplot <- baseplot +
         geom_ribbon(aes(x = xn, ymin = l.ci, ymax = u.ci, fill = grp), alpha = .3)
     # -----------------------------------------------------------
     # continue with plot. point and line layers above ribbon
     # -----------------------------------------------------------
-    baseplot <- baseplot + 
+    baseplot <- baseplot +
       geom_point(aes(x = x, y = y, colour = grp)) +
       geom_line(aes(x = xn, y = y, colour = grp)) +
       scale_x_discrete(labels = axisLabels.x)
@@ -380,18 +380,18 @@ sjp.emm.int <- function(fit,
     # ------------------------------------------------------------
     if (showValueLabels) {
       baseplot <- baseplot +
-        geom_text(aes(label = round(y, vld), x = x, y = y), 
-                  vjust = 1.5, 
+        geom_text(aes(label = round(y, vld), x = x, y = y),
+                  vjust = 1.5,
                   show_guide = FALSE)
     }
     # ------------------------------------------------------------------------------------
     # build plot object with theme and labels
     # ------------------------------------------------------------------------------------
-    baseplot <- baseplot + 
+    baseplot <- baseplot +
       # set plot and axis titles
-      labs(title = labtitle, 
-           x = labx, 
-           y = laby, 
+      labs(title = labtitle,
+           x = labx,
+           y = laby,
            colour = lTitle) +
       # set axis scale breaks
       scale_y_continuous(limits = c(lowerLim.y, upperLim.y), breaks = gridbreaks.y)
@@ -417,8 +417,8 @@ sjp.emm.int <- function(fit,
 
 
 sjp.emm.lmer <- function(fit, swapPredictors, plevel, title, geom.colors, axisTitle.x,
-                         axisTitle.y, axisLabels.x, legendLabels, showValueLabels, 
-                         valueLabel.digits, showCI, breakTitleAt, breakLegendLabelsAt, 
+                         axisTitle.y, axisLabels.x, legendLabels, showValueLabels,
+                         valueLabel.digits, showCI, breakTitleAt, breakLegendLabelsAt,
                          axisLimits.y, gridBreaksAt, printPlot) {
   if (any(class(fit) == ""lmerMod"") && !requireNamespace(""lmerTest"", quietly = TRUE)) {
     stop(""Package 'lmerTest' needed for this function to work. Please install it."", call. = FALSE)
@@ -490,8 +490,8 @@ sjp.emm.lmer <- function(fit, swapPredictors, plevel, title, geom.colors, axisTi
     # -----------------------------------------------------------
     for (cnt in 1:length(intnames)) {
       # -----------------------------------------------------------
-      # first, retrieve and split interaction term so we know 
-      # the two predictor variables, or factor levels of the 
+      # first, retrieve and split interaction term so we know
+      # the two predictor variables, or factor levels of the
       # interaction term
       # -----------------------------------------------------------
       lvls <- unlist(strsplit(intnames[cnt], "":""))
@@ -504,7 +504,7 @@ sjp.emm.lmer <- function(fit, swapPredictors, plevel, title, geom.colors, axisTi
       # found, and use the term labels for ls means...
       # -----------------------------------------------------------
       if (grepl(terms[1], lvls[1], fixed = T) && grepl(terms[2], lvls[2], fixed = T)) {
-        # we found a match        
+        # we found a match
         interactionterms <- rbind(interactionterms, terms)
         # leave loop
         break
@@ -524,7 +524,7 @@ sjp.emm.lmer <- function(fit, swapPredictors, plevel, title, geom.colors, axisTi
     # swap predictors?
     if (swapPredictors) term.pairs <- rev(term.pairs)
     # -----------------------------------------------------------
-    # get column indices of interaction terms, estimate and 
+    # get column indices of interaction terms, estimate and
     # confidence intervals. latter term in interaction is considered
     # as ""within subject"" (x-pos), first term is considered as
     # ""between subjects"" (group)
@@ -588,7 +588,7 @@ sjp.emm.lmer <- function(fit, swapPredictors, plevel, title, geom.colors, axisTi
     # prepare plot title and axis titles
     # -----------------------------------------------------------
     if (is.null(title)) {
-      labtitle <- paste0(""Estimated marginal means of "", response.name, 
+      labtitle <- paste0(""Estimated marginal means of "", response.name,
                          "" between "", term.pairs[2],
                          "" and "", term.pairs[1])
     } else {
@@ -626,12 +626,12 @@ sjp.emm.lmer <- function(fit, swapPredictors, plevel, title, geom.colors, axisTi
     # -----------------------------------------------------------
     # Confidence intervals?
     # -----------------------------------------------------------
-    if (showCI) baseplot <- baseplot + 
+    if (showCI) baseplot <- baseplot +
         geom_ribbon(aes(x = xn, ymin = l.ci, ymax = u.ci, fill = grp), alpha = .3)
     # -----------------------------------------------------------
     # continue with plot. point and line layers above ribbon
     # -----------------------------------------------------------
-    baseplot <- baseplot + 
+    baseplot <- baseplot +
       geom_point(aes(x = x, y = y, colour = grp)) +
       geom_line(aes(x = xn, y = y, colour = grp)) +
       scale_x_discrete(labels = axisLabels.x)
@@ -640,18 +640,18 @@ sjp.emm.lmer <- function(fit, swapPredictors, plevel, title, geom.colors, axisTi
     # ------------------------------------------------------------
     if (showValueLabels) {
       baseplot <- baseplot +
-        geom_text(aes(label = round(y, vld), x = x, y = y), 
-                  vjust = 1.5, 
+        geom_text(aes(label = round(y, vld), x = x, y = y),
+                  vjust = 1.5,
                   show_guide = FALSE)
     }
     # ------------------------------------------------------------------------------------
     # build plot object with theme and labels
     # ------------------------------------------------------------------------------------
-    baseplot <- baseplot + 
+    baseplot <- baseplot +
       # set plot and axis titles
-      labs(title = labtitle, 
-           x = labx, 
-           y = laby, 
+      labs(title = labtitle,
+           x = labx,
+           y = laby,
            colour = term.pairs[1]) +
       # set axis scale breaks
       scale_y_continuous(limits = c(lowerLim.y, upperLim.y), breaks = gridbreaks.y)

---FILE: R/sjPlotInteractions.R---
@@ -265,6 +265,20 @@ sjp.int <- function(fit,
   coef.tab <- summary(fit)$coefficients
   pval <- rep(0, times = nrow(coef.tab) - 1)
   # -----------------------------------------------------------
+  # Help-function that removes AsIS I from formulas.
+  # If someone know regular expressions better than me,
+  # please provide a one-liner solution for the 3 sub commands.
+  # -----------------------------------------------------------
+  remove_I <- function(xnames) {
+    fpos <- grep(""I("", xnames, fixed = T)
+    if (length(fpos) > 0 && fpos > 0) {
+      xnames <- sub(""I("", """", xnames, fixed = T)
+      xnames <- sub("")"", """", xnames, fixed = T)
+      xnames <- sub("" * "", "":"", xnames, fixed = T)
+    }
+    return (xnames)
+  }
+  # -----------------------------------------------------------
   # prepare values for (generalized) linear models
   # -----------------------------------------------------------
   if (fun == ""lm"" || fun == ""glm"" || fun == ""plm"") {
@@ -290,7 +304,13 @@ sjp.int <- function(fit,
     # retrieve estimates, without intercept
     # -----------------------------------------------------------
     estimates <- coef.tab[-1, 1]
-    estimates.names <- it <- names(estimates)
+    # -----------------------------------------------------------
+    # need to remove ""I(...)""?
+    # -----------------------------------------------------------
+    predvars <- remove_I(predvars)
+    estimates.names <- names(estimates)
+    estimates.names <- remove_I(estimates.names)
+    it <- estimates.names
     # -----------------------------------------------------------
     # retrieve estimate of intercept
     # -----------------------------------------------------------
@@ -363,6 +383,11 @@ sjp.int <- function(fit,
         }
       }
     }
+    # -----------------------------------------------------------
+    # need to remove ""I(...)""?
+    # -----------------------------------------------------------
+    predvars <- remove_I(predvars)
+    estimates.names <- remove_I(estimates.names)
     it <- estimates.names
     # -----------------------------------------------------------
     # retrieve estimate of intercept
@@ -460,8 +485,8 @@ sjp.int <- function(fit,
     df_pred2uniquevals <- unique(fitdat[interactionterms[[1]][2]])
     # convert data frame to numeric vector
     pred1uniquevals <- pred2uniquevals <- as.numeric(c())
-    pred1uniquevals <- sort(as.numeric(c(apply(df_pred1uniquevals, c(1), as.numeric ))))
-    pred2uniquevals <- sort(as.numeric(c(apply(df_pred2uniquevals, c(1), as.numeric ))))
+    pred1uniquevals <- sort(as.numeric(c(apply(df_pred1uniquevals, 1, as.numeric))))
+    pred2uniquevals <- sort(as.numeric(c(apply(df_pred2uniquevals, 1, as.numeric))))
     # init data frame
     intdf <- c()
     # -----------------------------------------------------------
@@ -504,54 +529,49 @@ sjp.int <- function(fit,
       # the estimates of each term and the associated interaction term,
       # i.e.: y = b0 + (b1 * pred1) + (b2 * pred2) + (b3 * pred1 * pred2)
       # -----------------------------------------------------------
-      for (j in 1:length(pred1uniquevals)) {
-        # iterate x-values and calculate minimum y
-        pr <- pred1uniquevals[j]
-        # ------------------------------
-        # We now calculate the effect of predictor 1 under absence (or lowest
-        # impact) of predictor 2 on the dependent variable. Thus, the slope for
-        # predictor 2 is not calculated. see
-        # http://www.theanalysisfactor.com/interpreting-interactions-in-regression/
-        # http://www.theanalysisfactor.com/clarifications-on-interpreting-interactions-in-regression/
-        # ------------------------------
-        # miny = (b0 + (b1*pr) + (b2*ymin) + (b3*pr*ymin))
-        miny <- (b0 + (b1 * pr) + (b3 * pr * ymin))
+      # We now calculate the effect of predictor 1 under absence (or lowest
+      # impact) of predictor 2 on the dependent variable. Thus, the slope for
+      # predictor 2 is not calculated. see
+      # http://www.theanalysisfactor.com/interpreting-interactions-in-regression/
+      # http://www.theanalysisfactor.com/clarifications-on-interpreting-interactions-in-regression/
+      # ------------------------------
+      # miny = (b0 + (b1*pr) + (b2*ymin) + (b3*pr*ymin))
+      miny <- (b0 + (b1 * pred1uniquevals) + (b3 * pred1uniquevals * ymin))
+      # ------------------------------
+      # here we calculate the effect of predictor 1 under presence (or strongest
+      # impact) of predictor 2 on the dependent variable. Thus, the slope for
+      # predictor 2 only is not needed. see references above
+      # ------------------------------
+      # maxy = (b0 + (b1*pr) + (b2*ymax) + (b3*pr*ymax))
+      maxy <- (b0 + (b1 * pred1uniquevals) + (b3 * pred1uniquevals * ymax))
+      # store in df
+      tmp <- as.data.frame(cbind(x = pred1uniquevals, 
+                                 y = miny, 
+                                 ymin = miny, 
+                                 ymax = maxy, 
+                                 grp = ""min""))
+      intdf <- as.data.frame(rbind(intdf, tmp))
+      # store in df
+      tmp <- as.data.frame(cbind(x = pred1uniquevals, 
+                                 y = maxy, 
+                                 ymin = miny, 
+                                 ymax = maxy, 
+                                 grp = ""max""))
+      intdf <- as.data.frame(rbind(intdf, tmp))
+      # store in df
+      if (moderatorValues != ""minmax"") {
         # ------------------------------
-        # here we calculate the effect of predictor 1 under presence (or strongest
-        # impact) of predictor 2 on the dependent variable. Thus, the slope for
+        # here we calculate the effect of predictor 1 under presence
+        # of mean of predictor 2 on the dependent variable. Thus, the slope for
         # predictor 2 only is not needed. see references above
         # ------------------------------
-        # maxy = (b0 + (b1*pr) + (b2*ymax) + (b3*pr*ymax))
-        maxy <- (b0 + (b1 * pr) + (b3 * pr * ymax))
-        # store in df
-        tmp <- as.data.frame(cbind(x = pr, 
-                                   y = miny, 
+        mittelwert <- (b0 + (b1 * pred1uniquevals) + (b3 * pred1uniquevals * mw))
+        tmp <- as.data.frame(cbind(x = pred1uniquevals, 
+                                   y = mittelwert, 
                                    ymin = miny, 
                                    ymax = maxy, 
-                                   grp = ""min""))
+                                   grp = ""mean""))
         intdf <- as.data.frame(rbind(intdf, tmp))
-        # store in df
-        tmp <- as.data.frame(cbind(x = pr, 
-                                   y = maxy, 
-                                   ymin = miny, 
-                                   ymax = maxy, 
-                                   grp = ""max""))
-        intdf <- as.data.frame(rbind(intdf, tmp))
-        # store in df
-        if (moderatorValues != ""minmax"") {
-          # ------------------------------
-          # here we calculate the effect of predictor 1 under presence
-          # of mean of predictor 2 on the dependent variable. Thus, the slope for
-          # predictor 2 only is not needed. see references above
-          # ------------------------------
-          mittelwert <- (b0 + (b1 * pr) + (b3 * pr * mw))
-          tmp <- as.data.frame(cbind(x = pr, 
-                                     y = mittelwert, 
-                                     ymin = miny, 
-                                     ymax = maxy, 
-                                     grp = ""mean""))
-          intdf <- as.data.frame(rbind(intdf, tmp))
-        }
       }
     } else {
       labx <- c(interactionterms[[1]][2])
@@ -579,51 +599,49 @@ sjp.int <- function(fit,
       # the estimates of each term and the associated interaction term,
       # i.e.: y = b0 + (b1 * pred1) + (b2 * pred2) + (b3 * pred1 * pred2)
       # -----------------------------------------------------------
-      # compute for minimum value
-      for (j in 1:length(pred2uniquevals)) {
-        # iterate x-values and calculate minimum y
-        pr <- pred2uniquevals[j]
-        # ------------------------------
-        # We now calculate the effect of predictor 2 under absence (or lowest
-        # impact) of predictor 1 on the dependent variable. Thus, the slope for
-        # predictor 1 is not calculated. see
-        # http://www.theanalysisfactor.com/interpreting-interactions-in-regression/
-        # http://www.theanalysisfactor.com/clarifications-on-interpreting-interactions-in-regression/
+      # We now calculate the effect of predictor 2 under absence (or lowest
+      # impact) of predictor 1 on the dependent variable. Thus, the slope for
+      # predictor 1 is not calculated. see
+      # http://www.theanalysisfactor.com/interpreting-interactions-in-regression/
+      # http://www.theanalysisfactor.com/clarifications-on-interpreting-interactions-in-regression/
+      # ------------------------------
+      # miny = (b0 + (b1*ymin) + (b2*pr) + (b3*pr*ymin))
+      miny <- (b0 + (b2 * pred2uniquevals) + (b3 * pred2uniquevals * ymin))
+      # ------------------------------
+      # here we calculate the effect of predictor 2 under presence (or strongest
+      # impact) of predictor 1 on the dependent variable. Thus, the slope for
+      # predictor 1 only is not needed. see references above
+      # ------------------------------
+      # maxy = (b0 + (b1*ymax) + (b2*pr) + (b3*pr*ymax))
+      maxy <- (b0 + (b2 * pred2uniquevals) + (b3 * pred2uniquevals * ymax))
+      # store in df
+      tmp <- as.data.frame(cbind(x = pred2uniquevals, 
+                                 y = miny, 
+                                 ymin = miny, 
+                                 ymax = maxy, 
+                                 grp = ""min""))
+      intdf <- as.data.frame(rbind(intdf, tmp))
+      # store in df
+      tmp <- as.data.frame(cbind(x = pred2uniquevals, 
+                                 y = maxy, 
+                                 ymin = miny, 
+                                 ymax = maxy, 
+                                 grp = ""max""))
+      intdf <- as.data.frame(rbind(intdf, tmp))
+      # store in df
+      if (moderatorValues != ""minmax"") {
         # ------------------------------
-        # miny = (b0 + (b1*ymin) + (b2*pr) + (b3*pr*ymin))
-        miny <- (b0 + (b2 * pr) + (b3 * pr * ymin))
-        # ------------------------------
-        # here we calculate the effect of predictor 2 under presence (or strongest
-        # impact) of predictor 1 on the dependent variable. Thus, the slope for
+        # here we calculate the effect of predictor 2 under presence
+        # of mean of predictor 1 on the dependent variable. Thus, the slope for
         # predictor 1 only is not needed. see references above
         # ------------------------------
-        # maxy = (b0 + (b1*ymax) + (b2*pr) + (b3*pr*ymax))
-        maxy <- (b0 + (b2 * pr) + (b3 * pr * ymax))
-        # store in df
-        tmp <- as.data.frame(cbind(x = pr, 
-                                   y = miny, 
+        mittelwert <- (b0 + (b2 * pred2uniquevals) + (b3 * pred2uniquevals * mw))
+        tmp <- as.data.frame(cbind(x = pred2uniquevals, 
+                                   y = mittelwert, 
                                    ymin = miny, 
                                    ymax = maxy, 
-                                   grp = ""min""))
+                                   grp = ""mean""))
         intdf <- as.data.frame(rbind(intdf, tmp))
-        # store in df
-        tmp <- as.data.frame(cbind(x = pr, 
-                                   y = maxy, 
-                                   ymin = miny, 
-                                   ymax = maxy, 
-                                   grp = ""max""))
-        intdf <- as.data.frame(rbind(intdf, tmp))
-        # store in df
-        if (moderatorValues != ""minmax"") {
-          # ------------------------------
-          # here we calculate the effect of predictor 2 under presence
-          # of mean of predictor 1 on the dependent variable. Thus, the slope for
-          # predictor 1 only is not needed. see references above
-          # ------------------------------
-          mittelwert <- (b0 + (b2 * pr) + (b3 * pr * mw))
-          tmp <- as.data.frame(cbind(x = pr, y = mittelwert, ymin = miny, ymax = maxy, grp = ""mean""))
-          intdf <- as.data.frame(rbind(intdf, tmp))
-        }
       }
     }
     # -----------------------------------------------------------

---FILE: README.md---
@@ -31,7 +31,7 @@ install.packages(""sjPlot"")
 
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since this package makes heavy use of the [ggplot-package](http://cran.r-project.org/web/packages/ggplot2/index.html), consider citing this package as well.
 
-### Changelog of current development build 1.7-10
+### Changelog of current development build 1.7-11
 
 #### General
 * _Utility, recode and statistical test functions have been moved to another package called [sjmisc](https://github.com/sjPlot/sjmisc)!_
@@ -61,3 +61,4 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 * `sjp.glm` and `sjp.glmm` should catch axis limits, which are out of printable bounds, hence these function should no longer stop in such cases.
 * `sjp.lmer` and `sjp.glmer` wrongly stated that paramter `ri.nr` was out of bound when `type` was `re`, `fe.ri` or `ri.pc` - fixed.
 * Weights with decimals in `sjt.xtab` (e.g. `weightBy = abs(rnorm(100, 2, 1)`) caused an error - fixed.
+* `sjp.int` did not work with interaction terms that used `AsIs` conversion (function `I`) - fixed.

---FILE: man/sjPlot-package.Rd---
@@ -34,8 +34,8 @@
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.7-10\cr
-Date: \tab 2015-04-01\cr
+Version: \tab 1.7-11\cr
+Date: \tab 2015-04-06\cr
 License: \tab GPL-3\cr
 }
 }"
strengejacke,sjPlot,3b988d1961ec090b7d9f43f62dab70e05f28ca8a,Daniel Ldecke,d.luedecke@uke.de,2015-04-01T20:37:50Z,Daniel Ldecke,d.luedecke@uke.de,2015-04-01T20:37:50Z,"added tests, fixed warnings from check-as-cran",DESCRIPTION;R/sjPlotAncovaLSMeans.R;R/sjPlotFrequencies.R;R/sjPlotInteractions.R;R/sjPlotLinreg.R;R/sjTabLinReg.R;R/sjTabOdds.R;tests/testthat.R;tests/testthat/test_sjpfrq.R;tests/testthat/test_sjpgrpfrq.R,False,True,True,False,280,222,502,"---FILE: DESCRIPTION---
@@ -10,6 +10,6 @@ Description: Collection of several plotting and table output functions for visua
 License: GPL-3
 Depends: R (>= 3.1)
 Imports: car, dplyr (>= 0.4.1), ggplot2, grid, MASS, psych, scales, sjmisc, tidyr (>= 0.2.0)
-Suggests: arm, cluster, lme4, lmerTest, lmtest, lsmeans
+Suggests: arm, cluster, lme4, lmerTest, lmtest, lsmeans, testthat
 URL: https://github.com/sjPlot/devel
 BugReports: https://github.com/sjPlot/devel/issues

---FILE: R/sjPlotAncovaLSMeans.R---
@@ -1,5 +1,5 @@
 # bind global variables
-if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""xn"", ""vld""))
+if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""xn"", ""vld"", ""l.ci"", ""u.ci""))
 
 #' @title Plot estimated marginal means of Two-Way Repeated Measures AN(C)OVA
 #' @name sjp.emm.int

---FILE: R/sjPlotFrequencies.R---
@@ -294,54 +294,42 @@ sjp.frq <- function(varCount,
   # --------------------------------------------------------
   # remove titles if empty
   # --------------------------------------------------------
-  if (!is.null(axisTitle.x) && axisTitle.x=="""") axisTitle.x <- NULL
-  if (!is.null(axisTitle.y) && axisTitle.y=="""") axisTitle.y <- NULL  
-  if (!is.null(title) && title=="""") title <- NULL    
+  if (!is.null(axisTitle.x) && axisTitle.x == """") axisTitle.x <- NULL
+  if (!is.null(axisTitle.y) && axisTitle.y == """") axisTitle.y <- NULL  
+  if (!is.null(title) && title == """") title <- NULL    
   # --------------------------------------------------------
   # check color parameter
   # --------------------------------------------------------
   if (is.null(geom.colors)) {
     geom.colors <- waiver()
-  }
-  else if (length(geom.colors)>1) {
+  } else if (length(geom.colors) > 1) {
     geom.colors <- geom.colors[1]
   }
   # --------------------------------------------------------
   # count variable may not be a factor!
   # --------------------------------------------------------
-  if (is.factor(varCount)) {
-    varCount <- as.numeric(varCount)
-  }
+  if (is.factor(varCount)) varCount <- as.numeric(varCount)
   # --------------------------------------------------------
   # We have several options to name the histrogram type
   # Here we will reduce it to a unique value
   # --------------------------------------------------------
-  if (type==""b"" || type==""bar"") {
-    type <- c(""bars"")
-  }
-  if (type==""dot"") {
-    type <- c(""dots"")
-  }
-  if (type==""h"" || type==""hist"") {
-    type <- c(""histogram"")
-  }
-  if (type==""d"" || type==""density"") {
-    type <- c(""dens"")
-  }
-  if (type==""l"" || type==""lines"") {
-    type <- c(""line"")
-  }
-  if (type==""box"" || type==""boxplot"") {
-    type <- c(""boxplots"")
-  }
-  if (type==""v"") {
-    type <- c(""violin"")
-  }
-  if (expand.grid==TRUE) {
+  if (type==""b"" || type==""bar"") type <- c(""bars"")
+  if (type==""dot"") type <- c(""dots"")
+  if (type==""h"" || type==""hist"") type <- c(""histogram"")
+  if (type==""d"" || type==""density"") type <- c(""dens"")
+  if (type==""l"" || type==""lines"") type <- c(""line"")
+  if (type==""box"" || type==""boxplot"") type <- c(""boxplots"")
+  if (type==""v"") type <- c(""violin"")
+  if (expand.grid == TRUE) {
     expand.grid <- waiver()
+  } else {
+    expand.grid <- c(0, 0)
   }
-  else {
-    expand.grid <- c(0,0)
+  #---------------------------------------------------
+  # check whether variable should be auto-grouped
+  #---------------------------------------------------
+  if (!is.null(interactionVar) && (type != ""boxplots"" || type != ""violin"")) {
+    warning(""'interactionVar' only applies to boxplots and violinplots (see 'type') and will be ignored."", call. = F)
   }
   #---------------------------------------------------
   # check whether variable should be auto-grouped
@@ -363,12 +351,8 @@ sjp.frq <- function(varCount,
   # --------------------------------------------------------
   # unlist labels
   # --------------------------------------------------------
-  if (!is.null(axisLabels.x) && is.list(axisLabels.x)) {
-    axisLabels.x <- unlistlabels(axisLabels.x)
-  }
-  if (!is.null(interactionVarLabels) && is.list(interactionVarLabels)) {
-    interactionVarLabels <- unlistlabels(interactionVarLabels)
-  }
+  if (!is.null(axisLabels.x) && is.list(axisLabels.x)) axisLabels.x <- unlistlabels(axisLabels.x)
+  if (!is.null(interactionVarLabels) && is.list(interactionVarLabels)) interactionVarLabels <- unlistlabels(interactionVarLabels)
   #---------------------------------------------------
   # create frequency data frame
   #---------------------------------------------------
@@ -427,10 +411,9 @@ sjp.frq <- function(varCount,
   if (!is.null(interactionVar)) {
     if (!is.null(interactionVarLabels)) {
       interactionVarLabels <- sjmisc::word_wrap(interactionVarLabels, breakLabelsAt)    
-    }
     # If interaction-variable-labels were not defined, simply set numbers from 1 to
     # amount of categories instead
-    else  {
+    } else  {
       iavarLabLength <- length(unique(na.omit(interactionVar)))
       interactionVarLabels <- c(1:iavarLabLength)
     }
@@ -440,8 +423,7 @@ sjp.frq <- function(varCount,
   # --------------------------------------------------------
   if (is.null(weightBy)) {
     mittelwert <- mean(varCount, na.rm=TRUE)
-  }
-  else {
+  } else {
     mittelwert <- weighted.mean(varCount, weightBy, na.rm=TRUE)
   }
   stddev <- sd(varCount, na.rm=TRUE)
@@ -450,10 +432,14 @@ sjp.frq <- function(varCount,
   # --------------------------------------------------------
   if (type==""boxplots"" || type==""violin"") {
     if (is.null(interactionVar)) {
-      mydat <- na.omit(data.frame(cbind(grp=1, frq=varCount, var=varCount)))
-    }
-    else {
-      mydat <- na.omit(data.frame(cbind(grp=1, ia=interactionVar, frq=varCount, var=varCount)))
+      mydat <- na.omit(data.frame(cbind(grp = 1, 
+                                        frq = varCount, 
+                                        var = varCount)))
+    } else {
+      mydat <- na.omit(data.frame(cbind(grp = 1, 
+                                        ia = interactionVar, 
+                                        frq = varCount, 
+                                        var = varCount)))
       mydat$ia <- as.factor(mydat$ia)
     }
     mydat$grp <- as.factor(mydat$grp)
@@ -468,29 +454,26 @@ sjp.frq <- function(varCount,
   if (!is.null(axisLimits.y) && length(axisLimits.y) == 2) {
     lower_lim <- axisLimits.y[1]
     upper_lim <- axisLimits.y[2]
-  }
-  else {
+  } else {
     # in case we have a histrogram, calculate
     # max. y lim depending on highest value
-    if (type!=""bars"" && type!=""dots"") {
+    if (type != ""bars"" && type != ""dots"") {
       # if we have boxplots, we have different ranges, so we can adjust
       # the y axis
-      if (type==""boxplots"" || type==""violin"") {
+      if (type == ""boxplots"" || type == ""violin"") {
         # use an extra standard-deviation as limits for the y-axis when we have boxplots
-        lower_lim <- min(varCount, na.rm=TRUE) - floor(sd(varCount, na.rm=TRUE))
-        upper_lim <- max(varCount, na.rm=TRUE) + ceiling(sd(varCount, na.rm=TRUE))
+        lower_lim <- min(varCount, na.rm = TRUE) - floor(sd(varCount, na.rm = TRUE))
+        upper_lim <- max(varCount, na.rm = TRUE) + ceiling(sd(varCount, na.rm = TRUE))
         # make sure that the y-axis is not below zero
         if (lower_lim < 0) {
           lower_lim <- 0
           trimViolin <- TRUE
         }
-      }
-      else {
+      } else {
         # ... or the amount of max. answers per category
         upper_lim <- histYlim(varCount)
       }
-    }
-    else {
+    } else {
       # else calculate upper y-axis-range depending
       # the amount of max. answers per category
       upper_lim <- freqYlim(mydat$frq)
@@ -499,30 +482,27 @@ sjp.frq <- function(varCount,
   # --------------------------------------------------------
   # define geom
   # --------------------------------------------------------
-  if (type==""bars"") {
-    geob <- geom_bar(stat=""identity"", width=geom.size, fill = geom.colors)
-  }
-  else if (type==""dots"") {
-    geob <- geom_point(size=geom.size, fill = geom.colors)
-  }
-  if (!showAxisLabels.x) {
-    axisLabels.x <- c("""")
-  }
+  if (type == ""bars"") {
+    geob <- geom_bar(stat = ""identity"", 
+                     width = geom.size, 
+                     fill = geom.colors)
+  } else if (type==""dots"") {
+    geob <- geom_point(size = geom.size, fill = geom.colors)
+  }
+  if (!showAxisLabels.x) axisLabels.x <- c("""")
   # --------------------------------------------------------
   # Set value labels
   # --------------------------------------------------------
   if (coord.flip) {
     # adjust vertical position for labels, based on whether percentage values
     # are shown or not
     vert <- waiver() # ifelse((showPercentageValues == TRUE && showCountValues == TRUE), 0.5, 0.1)
-    if (labelPos==""inside"" || labelPos==""i"") {
+    if (labelPos == ""inside"" || labelPos == ""i"") {
       hort <- 1.1
-    }
-    else {
+    } else {
       hort <- -0.1
     }
-  }
-  else {
+  } else {
     # adjust vertical position for labels, based on whether percentage values
     # are shown or not
     vert <- ifelse((showPercentageValues == TRUE && showCountValues == TRUE), -0.2, -0.6)
@@ -532,77 +512,66 @@ sjp.frq <- function(varCount,
   # Set value labels
   # --------------------------------------------------------
   # don't display value labels when we have boxplots or violin plots
-  if (type==""boxplots"" || type==""violin"") {
-    showValueLabels <- FALSE
-  }
+  if (type == ""boxplots"" || type == ""violin"") showValueLabels <- FALSE
   if (showValueLabels) {
     # here we have counts and percentages
     if (showPercentageValues && showCountValues) {
       if (coord.flip) {
         if (showCI) {
-          ggvaluelabels <-  geom_text(label=sprintf(""%i (%.01f%%)"", mydat$frq, mydat$prz),
-                                      hjust=hort,
-                                      vjust=vert,
+          ggvaluelabels <-  geom_text(label = sprintf(""%i (%.01f%%)"", mydat$frq, mydat$prz),
+                                      hjust = hort,
+                                      vjust = vert,
                                       aes(y = upper.ci))
+        } else {
+          ggvaluelabels <-  geom_text(label = sprintf(""%i (%.01f%%)"", mydat$frq, mydat$prz),
+                                      hjust = hort,
+                                      vjust = vert)
         }
-        else {
-          ggvaluelabels <-  geom_text(label=sprintf(""%i (%.01f%%)"", mydat$frq, mydat$prz),
-                                      hjust=hort,
-                                      vjust=vert)
-        }
-      }
-      else {
+      } else {
         if (showCI) {
-          ggvaluelabels <-  geom_text(label=sprintf(""%i\n(%.01f%%)"", mydat$frq, mydat$prz),
-                                      hjust=hort,
-                                      vjust=vert,
+          ggvaluelabels <-  geom_text(label = sprintf(""%i\n(%.01f%%)"", mydat$frq, mydat$prz),
+                                      hjust = hort,
+                                      vjust = vert,
                                       aes(y = upper.ci))
-        }
-        else {
-          ggvaluelabels <-  geom_text(label=sprintf(""%i\n(%.01f%%)"", mydat$frq, mydat$prz),
-                                      hjust=hort,
-                                      vjust=vert)
+        } else {
+          ggvaluelabels <-  geom_text(label = sprintf(""%i\n(%.01f%%)"", mydat$frq, mydat$prz),
+                                      hjust = hort,
+                                      vjust = vert)
         }
       }
-    }
-    else if (showCountValues) {
+    } else if (showCountValues) {
       if (showCI) {
         # here we have counts, without percentages
-        ggvaluelabels <-  geom_text(label=sprintf(""%i"", mydat$frq),
-                                    hjust=hort,
-                                    vjust=vert,
+        ggvaluelabels <-  geom_text(label = sprintf(""%i"", mydat$frq),
+                                    hjust = hort,
+                                    vjust = vert,
                                     aes(y = upper.ci))
-      }
-      else {
+      } else {
         # here we have counts, without percentages
-        ggvaluelabels <-  geom_text(label=sprintf(""%i"", mydat$frq),
-                                    hjust=hort,
-                                    vjust=vert)
+        ggvaluelabels <-  geom_text(label = sprintf(""%i"", mydat$frq),
+                                    hjust = hort,
+                                    vjust = vert)
       }
-    }
-    else if (showPercentageValues) {
+    } else if (showPercentageValues) {
       if (showCI) {
         # here we have counts, without percentages
-        ggvaluelabels <-  geom_text(label=sprintf(""%.01f%%"", mydat$prz),
-                                    hjust=hort,
-                                    vjust=vert,
+        ggvaluelabels <-  geom_text(label = sprintf(""%.01f%%"", mydat$prz),
+                                    hjust = hort,
+                                    vjust = vert,
                                     aes(y = upper.ci))
-      }
-      else {
+      } else {
         # here we have counts, without percentages
-        ggvaluelabels <-  geom_text(label=sprintf(""%.01f%%"", mydat$prz),
-                                    hjust=hort,
-                                    vjust=vert)
+        ggvaluelabels <-  geom_text(label = sprintf(""%.01f%%"", mydat$prz),
+                                    hjust = hort,
+                                    vjust = vert)
       }
-    }
-    else {
+    } else {
       # no labels
-      ggvaluelabels <-  geom_text(label="""")
+      ggvaluelabels <-  geom_text(label = """")
     }
-  }
-  else {
+  } else {
     # no labels
-    ggvaluelabels <-  geom_text(label="""")
+    ggvaluelabels <-  geom_text(label = """")
   }
   # --------------------------------------------------------
   # Set up grid breaks
@@ -611,10 +580,9 @@ sjp.frq <- function(varCount,
   if (is.null(gridBreaksAt)) {
     gridbreaks <- waiver()
     histgridbreaks <- waiver()
-  }
-  else {
-    gridbreaks <- c(seq(lower_lim, upper_lim, by=gridBreaksAt))
-    histgridbreaks <- c(seq(lower_lim, maxx, by=gridBreaksAt))
+  } else {
+    gridbreaks <- c(seq(lower_lim, upper_lim, by = gridBreaksAt))
+    histgridbreaks <- c(seq(lower_lim, maxx, by = gridBreaksAt))
   }
   # ----------------------------------
   # set y scaling and label texts
@@ -623,123 +591,130 @@ sjp.frq <- function(varCount,
   # It either corresponds to the maximum amount of cases in the data set
   # (length of var) or to the highest count of var's categories.
   if (showAxisLabels.y) {
-    yscale <- scale_y_continuous(limits=c(lower_lim, upper_lim), expand=expand.grid, breaks=gridbreaks)
-  }
-  else {
-    yscale <- scale_y_continuous(limits=c(lower_lim, upper_lim), expand=expand.grid, breaks=gridbreaks, labels=NULL)
+    yscale <- scale_y_continuous(limits = c(lower_lim, upper_lim), 
+                                 expand = expand.grid, 
+                                 breaks = gridbreaks)
+  } else {
+    yscale <- scale_y_continuous(limits = c(lower_lim, upper_lim), 
+                                 expand = expand.grid, 
+                                 breaks = gridbreaks, 
+                                 labels = NULL)
   }
   # ----------------------------------
   # Print plot
   # ----------------------------------
   # calculate mean and sd for non-adjusted normal curve
-  stdmean <- diff(range(varCount, na.rm=TRUE))/2
-  stdadjust <- min(varCount, na.rm=TRUE)
-  stdsd <- stdmean/4
+  stdmean <- diff(range(varCount, na.rm = TRUE)) / 2
+  stdadjust <- min(varCount, na.rm = TRUE)
+  stdsd <- stdmean / 4
   stdlen <- length(na.omit(varCount))
   # ----------------------------------
   # Check how many categories we have on the x-axis.
   # If it exceeds the user defined limits, plot
   # histrogram instead of bar chart
   # ----------------------------------
-  if (type==""bars"" || type==""dots"") {
+  if (type == ""bars"" || type == ""dots"") {
     # mydat is a data frame that only contains one variable (var).
     # Must be declared as factor, so the bars are central aligned to
     # each x-axis-break. 
-    baseplot <- ggplot(mydat, aes(x=factor(var), y=frq)) + 
+    baseplot <- ggplot(mydat, aes(x = factor(var), y = frq)) + 
       geob +
       yscale + 
       # remove guide / legend
-      guides(fill=FALSE) +
+      guides(fill = FALSE) +
       # show absolute and percentage value of each bar.
       ggvaluelabels +
       # print value labels to the x-axis.
       # If parameter ""axisLabels.x"" is NULL, the category numbers (1 to ...) 
       # appear on the x-axis
-      scale_x_discrete(labels=axisLabels.x)
+      scale_x_discrete(labels = axisLabels.x)
     if (showCI) {
       ebcol <- ifelse(type == ""dots"", geom.colors, error.bar.color)
       # print confidence intervalls (error bars)
-      baseplot <- baseplot + geom_errorbar(aes(ymin=lower.ci, ymax=upper.ci), colour = ebcol, width=0)
+      baseplot <- baseplot + geom_errorbar(aes(ymin = lower.ci, ymax = upper.ci), 
+                                           colour = ebcol, 
+                                           width = 0)
     }
     # check whether coordinates should be flipped, i.e.
     # swap x and y axis
-    if (coord.flip) {
-      baseplot <- baseplot + coord_flip()
-    }
-  }
-  else {
+    if (coord.flip) baseplot <- baseplot + coord_flip()
+  } else {
     # --------------------------------------------------
     # Here we start when we have a histogram instead of
     # bar plot.
     # --------------------------------------------------
     # Start density plot here
     # --------------------------------------------------
-    if (type==""boxplots"" || type==""violin"") {
+    if (type == ""boxplots"" || type == ""violin"") {
       if (is.null(interactionVar)) {
-        baseplot <- ggplot(mydat, aes(x=grp, y=frq))
-        scalex <- scale_x_discrete(labels="""")
-      }
-      else {
-        baseplot <- ggplot(mydat, aes(x=interaction(ia, grp), y=frq))
-        scalex <- scale_x_discrete(labels=interactionVarLabels)
+        baseplot <- ggplot(mydat, aes(x = grp, y = frq))
+        scalex <- scale_x_discrete(labels = """")
+      } else {
+        baseplot <- ggplot(mydat, aes(x = interaction(ia, grp), y = frq))
+        scalex <- scale_x_discrete(labels = interactionVarLabels)
       }
-      if (type==""boxplots"") {
+      if (type == ""boxplots"") {
         baseplot <- baseplot + 
-          geom_boxplot(width=geom.size, fill = geom.colors)
-      }
-      else {
+          geom_boxplot(width = geom.size, fill = geom.colors)
+      } else {
         baseplot <- baseplot + 
-          geom_violin(trim=trimViolin, width=geom.size, fill = geom.colors) +
+          geom_violin(trim = trimViolin, 
+                      width = geom.size, 
+                      fill = geom.colors) +
           # if we have a violin plot, add an additional boxplot inside to show
           # more information
-          geom_boxplot(width=innerBoxPlotWidth, fill=""white"")
+          geom_boxplot(width = innerBoxPlotWidth, 
+                       fill = ""white"")
       }
       # if we have boxplots or violon plots, also add a point that indicates
       # the mean value
       # different fill colours, because violin boxplots have white background
-      fcsp <- ifelse(type==""boxplots"", ""white"", ""black"")
+      fcsp <- ifelse(type == ""boxplots"", ""white"", ""black"")
       baseplot <- baseplot +
-        stat_summary(fun.y=""mean"", geom=""point"", shape=21, size=innerBoxPlotDotSize, fill=fcsp)
+        stat_summary(fun.y = ""mean"", 
+                     geom = ""point"", 
+                     shape = 21, 
+                     size = innerBoxPlotDotSize, 
+                     fill = fcsp)
       # no additional labels for the x- and y-axis, only diagram title
       baseplot <- baseplot + 
         yscale +
         scalex
-    }
     # --------------------------------------------------
     # Start density plot here
     # --------------------------------------------------
-    else if (type==""dens"") {
+    } else if (type == ""dens"") {
       x <- na.omit(varCount)
       densityDat <- data.frame(x)
       # First, plot histogram with density curve
-      baseplot <- ggplot(densityDat, aes(x=x)) +
-        geom_histogram(aes(y=..density..), fill = geom.colors) +
+      baseplot <- ggplot(densityDat, aes(x = x)) +
+        geom_histogram(aes(y = ..density..), fill = geom.colors) +
         # transparent density curve above bars
-        geom_density(aes(y=..density..), fill=""cornsilk"", alpha=0.3) +
+        geom_density(aes(y = ..density..), 
+                     fill = ""cornsilk"", 
+                     alpha = 0.3) +
         # remove margins from left and right diagram side
-        scale_x_continuous(expand=expand.grid, breaks=histgridbreaks)
+        scale_x_continuous(expand = expand.grid, breaks = histgridbreaks)
       # check whether user wants to overlay the histogram
       # with a normal curve
       if (showNormalCurve) {
         baseplot <- baseplot +
-          stat_function(fun=dnorm,
-                        args=list(mean=mean(densityDat$x),
-                                  sd=sd(densityDat$x)),
-                        colour=normalCurveColor,
-                        size=normalCurveSize,
-                        alpha=normalCurveAlpha)
+          stat_function(fun = dnorm,
+                        args = list(mean = mean(densityDat$x),
+                                    sd = sd(densityDat$x)),
+                        colour = normalCurveColor,
+                        size = normalCurveSize,
+                        alpha = normalCurveAlpha)
       }
       if (showStandardNormalCurve) {
         baseplot <- baseplot +
-          stat_function(fun=dnorm,
-                        args=list(mean=stdmean,
-                                  sd=stdsd),
-                        colour=normalCurveColor,
-                        size=normalCurveSize,
-                        alpha=normalCurveAlpha)
+          stat_function(fun = dnorm,
+                        args = list(mean = stdmean, sd = stdsd),
+                        colour = normalCurveColor,
+                        size = normalCurveSize,
+                        alpha = normalCurveAlpha)
       }
-    }
-    else {
+    } else {
       # -----------------------------------------------------------------
       # Since the density curve shows no absolute numbers (counts) on the
       # y-axis, have also the opportunity to plot ""real"" histrograms with 
@@ -748,85 +723,113 @@ sjp.frq <- function(varCount,
       # base constructor
       if (hist.skipZeros) {
         x <- na.omit(varCount)
-        if (geom.size<round(diff(range(x))/50)) message(""Using very small binwidth. Consider adjusting \""geom.size\""-parameter."")
+        if (geom.size<round(diff(range(x)) / 50)) message(""Using very small binwidth. Consider adjusting \""geom.size\""-parameter."")
         hist.dat <- data.frame(x)
         baseplot <- ggplot(mydat)
-        basehist <- geom_histogram(data = hist.dat, aes(x = x), binwidth = geom.size, fill = geom.colors)
-      }
-      else {
+        basehist <- geom_histogram(data = hist.dat, 
+                                   aes(x = x),
+                                   binwidth = geom.size, 
+                                   fill = geom.colors)
+      } else {
         baseplot <- ggplot(mydat, aes(x = var, y = frq))
-        basehist <- geom_histogram(stat = ""identity"", binwidth = geom.size, fill = geom.colors)
+        basehist <- geom_histogram(stat = ""identity"", 
+                                   binwidth = geom.size, 
+                                   fill = geom.colors)
       }
-      basehistline <- geom_area(alpha=0.3)
+      basehistline <- geom_area(alpha = 0.3)
       # check whether user wants line or bar histogram
-      if (type==""line"") {
+      if (type == ""line"") {
         baseplot <- baseplot + basehistline + geom_line(colour = geom.colors)
-      }
-      else {
+      } else {
         baseplot <- baseplot + basehist
       }
       # check whether user wants to overlay the histogram
       # with a normal curve
       if (showNormalCurve) {
         baseplot <- baseplot +
-          stat_function(fun=function(x, mean, sd, n) { n*dnorm(x=x, mean=mean, sd=sd) },
-                        args=with(mydat, c(mean=mittelwert, sd=stddev, n=length(varCount))),
-                        colour=normalCurveColor,
-                        size=normalCurveSize,
-                        alpha=normalCurveAlpha)
+          stat_function(fun = function(x, mean, sd, n) { n * dnorm(x = x, mean = mean, sd = sd) },
+                        args = with(mydat, c(mean = mittelwert, sd = stddev, n = length(varCount))),
+                        colour = normalCurveColor,
+                        size = normalCurveSize,
+                        alpha = normalCurveAlpha)
       }
       if (showStandardNormalCurve) {
         baseplot <- baseplot +
-          stat_function(fun=function(x, mean, sd, n) { 
-              if (adjustNormalCurve.x) x <- x-stdadjust
-              n*dnorm(x=x, mean=mean, sd=sd)
-            },
-                        args=with(mydat, c(mean=stdmean, sd=stdsd, n=stdlen)),
-                        colour=normalCurveColor,
-                        size=normalCurveSize,
-                        alpha=normalCurveAlpha)
+          stat_function(fun = function(x, mean, sd, n) { 
+            if (adjustNormalCurve.x) x <- x - stdadjust
+            n * dnorm(x = x, mean = mean, sd = sd)},
+            args = with(mydat, c(mean = stdmean, sd = stdsd, n = stdlen)),
+            colour = normalCurveColor,
+            size = normalCurveSize,
+            alpha = normalCurveAlpha)
       }
       # if we have a histogram, add mean-lines
       if (showMeanIntercept) {
         baseplot <- baseplot + 
           # vertical lines indicating the mean
-          geom_vline(xintercept=mittelwert, linetype=meanInterceptLineType, size=meanInterceptLineSize)
+          geom_vline(xintercept = mittelwert, 
+                     linetype = meanInterceptLineType, 
+                     size = meanInterceptLineSize)
         # check whether meanvalue should be shown.
         if (showMeanValue) {
           baseplot <- baseplot + 
             # use annotation instead of geomtext, because we need mean value only printed once
-            annotate(""text"", x=mittelwert, y=upper_lim, parse=TRUE, label=paste(""italic(bar(x)) == "", ""'"", c(round(mittelwert,1)), ""'""), hjust=1.1, vjust=2.2)
+            annotate(""text"", 
+                     x = mittelwert, 
+                     y = upper_lim, 
+                     parse = TRUE, 
+                     label = paste(""italic(bar(x)) == "", ""'"", c(round(mittelwert, 1)), ""'""), 
+                     hjust = 1.1, 
+                     vjust = 2.2)
         }
         # check whether the user wants to plot standard deviation area
         if (showStandardDeviation) {
           baseplot <- baseplot +
             # first draw shaded rectangle. these are by default in grey colour with very high transparancy
-            annotate(""rect"", xmin=mittelwert-stddev, xmax=mittelwert+stddev, ymin=0, ymax=c(upper_lim), fill=""grey70"", alpha=0.2) +
+            annotate(""rect"", 
+                     xmin = mittelwert - stddev, 
+                     xmax = mittelwert + stddev, 
+                     ymin = 0, 
+                     ymax = c(upper_lim), 
+                     fill = ""grey70"", 
+                     alpha = 0.2) +
             # draw border-lines for shaded rectangle
-            geom_vline(xintercept=mittelwert-stddev, linetype=3, size=meanInterceptLineSize, alpha=0.7) +
-            geom_vline(xintercept=mittelwert+stddev, linetype=3, size=meanInterceptLineSize, alpha=0.7)
+            geom_vline(xintercept = mittelwert - stddev, 
+                       linetype = 3, 
+                       size = meanInterceptLineSize, 
+                       alpha = 0.7) +
+            geom_vline(xintercept = mittelwert + stddev, 
+                       linetype = 3, 
+                       size = meanInterceptLineSize, 
+                       alpha = 0.7)
           # if mean values are plotted, plot standard deviation values as well
           if (showMeanValue) {
             baseplot <- baseplot + 
               # use annotation instead of geomtext, because we need mean value only printed once
-              annotate(""text"", x=mittelwert, y=upper_lim, label=sprintf(""italic(s) == %.2f"", round(stddev,1)), parse=TRUE, hjust=1.15, vjust=4.2)
+              annotate(""text"", 
+                       x = mittelwert, 
+                       y = upper_lim, 
+                       label = sprintf(""italic(s) == %.2f"", round(stddev, 1)), 
+                       parse = TRUE, 
+                       hjust = 1.15, 
+                       vjust = 4.2)
           }
         }
       }
       if (!hist.skipZeros) {
-        baseplot <- baseplot +
-          # show absolute and percentage value of each bar.
-          ggvaluelabels
+        # show absolute and percentage value of each bar.
+        baseplot <- baseplot + ggvaluelabels
       }
       baseplot <- baseplot +
         # remove margins from left and right diagram side
-        scale_x_continuous(limits=c(catmin,maxx), expand=expand.grid, breaks=histgridbreaks) +
+        scale_x_continuous(limits = c(catmin, maxx), 
+                           expand = expand.grid, 
+                           breaks = histgridbreaks) +
         yscale
     }
   }
   # set axes text and 
-  baseplot <- baseplot + 
-    labs(title=title, x=axisTitle.x, y=axisTitle.y)
+  baseplot <- baseplot + labs(title = title, x = axisTitle.x, y = axisTitle.y)
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------

---FILE: R/sjPlotInteractions.R---
@@ -244,12 +244,7 @@ sjp.int <- function(fit,
     stop(""Package 'lme4' needed for this function to work. Please install it."", call. = FALSE)
   }
   if (fun == ""plm"" && !""package:plm"" %in% search()) {
-    # load needed package, for summary function
-    package_da <- require(""plm"")
-    # if package not available, tell user
-    if (!package_da) {
-      stop(""Package 'plm' needed for this function to work. Please install it."", call. = FALSE)
-    }
+    stop(""Package 'plm' needs to be loaded for this function to work... Use 'library(plm)' and call this function again."", call. = FALSE)
   }
   # -----------------------------------------------------------
   # parameter check

---FILE: R/sjPlotLinreg.R---
@@ -235,13 +235,8 @@ sjp.lm <- function(fit,
   # -----------------------------------------------------------
   # check package availability if fit is plm-object
   # -----------------------------------------------------------
-  if (any(class(fit) == ""plm"") && !""package:plm"" %in% search()) {
-    # load needed package, for summary function
-    package_da <- require(""plm"")
-    # if package not available, tell user
-    if (!package_da) {
-      stop(""Package 'plm' needed for this function to work. Please install it."", call. = FALSE)
-    }
+  if (fun == ""plm"" && !""package:plm"" %in% search()) {
+    stop(""Package 'plm' needs to be loaded for this function to work... Use 'library(plm)' and call this function again."", call. = FALSE)
   }
   # -----------------------------------------------------------
   # this function requires a fitted model with only one predictor,

---FILE: R/sjTabLinReg.R---
@@ -1,3 +1,7 @@
+# bind global variables
+if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""starts_with""))
+
+
 #' @title Show linear regression as HTML table
 #' @name sjt.lm
 #' 

---FILE: R/sjTabOdds.R---
@@ -1,3 +1,7 @@
+# bind global variables
+if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""starts_with""))
+
+
 #' @title Show (and compare) generalized linear models as HTML table
 #' @name sjt.glm
 #' 

---FILE: tests/testthat.R---
@@ -0,0 +1,4 @@
+library(testthat)
+library(sjPlot)
+
+test_check(""sjPlot"")

---FILE: tests/testthat/test_sjpfrq.R---
@@ -0,0 +1,47 @@
+test_that(""Check plot frq"", { 
+  skip_on_cran()
+  library(sjmisc)
+  data(efc)
+  
+  sjp.frq(efc$e42dep)
+  
+  sjp.frq(efc$e15relat,
+          title = ""Relationship"",
+          sort.frq = ""desc"",
+          geom.size = .4,
+          geom.colors = ""#0088ff"",
+          axisLabels.x = get_val_labels(efc$e15relat))
+
+  sjp.frq(efc$e17age, interactionVar = efc$c161sex)
+          
+  sjp.frq(efc$e17age, 
+          interactionVar = efc$c161sex,
+          type = ""box"",
+          axisTitle.x = get_var_labels(efc$e17age),
+          geom.colors = ""yellow"")  
+
+  sjp.frq(efc$c12hour, 
+          type = ""violin"",
+          innerBoxPlotWidth = .1,
+          innerBoxPlotDotSize = 2)  
+  
+  sjp.frq(efc$c160age,
+          type = ""h"",
+          showMeanIntercept = T,
+          showMeanValue = T,
+          showNormalCurve = T,
+          showStandardDeviation = T,
+          showStandardNormalCurve = T,
+          normalCurveColor = ""blue"",
+          normalCurveSize = 3)
+
+  sjp.frq(efc$c160age,
+          type = ""dens"",
+          showMeanIntercept = T,
+          showMeanValue = T,
+          showNormalCurve = T,
+          showStandardDeviation = T,
+          showStandardNormalCurve = T,
+          normalCurveColor = ""blue"",
+          normalCurveSize = 3)
+})
\ No newline at end of file

---FILE: tests/testthat/test_sjpgrpfrq.R---
@@ -0,0 +1,6 @@
+test_that(""Check plot grouped frq"", { 
+  skip_on_cran()
+  library(sjmisc)
+  data(efc)
+  sjp.grpfrq(efc$e42dep, efc$e16sex)
+})
\ No newline at end of file"
strengejacke,sjPlot,f9e957f07965fbf11bb086def1a7f31d35607e47,Daniel Ldecke,d.luedecke@uke.de,2015-03-28T18:41:55Z,Daniel Ldecke,d.luedecke@uke.de,2015-03-28T18:41:55Z,fixed bug in sjp.(g)lmer,DESCRIPTION;NEWS;R/sjPlotGLME.R;README.md;man/sjPlot-package.Rd,False,True,True,False,13,13,26,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.7-8
-Date: 2015-03-26
+Version: 1.7-9
+Date: 2015-03-28
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of several plotting and table output functions for visualizing data.

---FILE: NEWS---
@@ -1,4 +1,4 @@
-Version 1.7-8
+Version 1.7-9
 ------------------------------------------------------------------------------
 General:
 * Utility, recode and statistical test functions have been moved to another package called ""sjmisc""!
@@ -24,6 +24,7 @@ Changes to functions:
 Bug fixes:
 * ""sjp.int"" did not work for interaction terms of factors with more than two levels in mixed effects models (""merMod""-objects) - fixed.
 * ""sjp.glm"" and ""sjp.glmm"" should catch axis limits, which are out of printable bounds, hence these function should no longer stop in such cases.
+* ""sjp.lmer"" and ""sjp.glmer"" wrongly stated that paramter ""ri.nr"" was out of bound when ""type"" was ""re"", ""fe.ri"" or ""ri.pc"" - fixed.
 * Weights with decimals in ""sjt.xtab"" (e.g. ""weightBy = abs(rnorm(100, 2, 1)"") caused an error - fixed.
 
 

---FILE: R/sjPlotGLME.R---
@@ -490,7 +490,7 @@ sjp.lme4  <- function(fit,
     # ---------------------------------------
     # check amounnt of random intercepts
     # ---------------------------------------
-    if (length(lme4::ranef(fit)) > ri.nr) {
+    if (ri.nr > length(lme4::ranef(fit))) {
       message(""Index specified in 'ri.nr' was larger than amount of random intercepts in model. Paramater 'ri.nr' was set to 1."")
       ri.nr <- 1
     }
@@ -1124,7 +1124,7 @@ sjp.lme.reprobcurve <- function(fit,
   # ---------------------------------------
   # check amounnt of random intercepts
   # ---------------------------------------
-  if (length(lme4::ranef(fit)) > ri.nr) {
+  if (ri.nr > length(lme4::ranef(fit))) {
     message(""Index specified in 'ri.nr' was larger than amount of random intercepts in model. Paramater 'ri.nr' was set to 1."")
     ri.nr <- 1
   }
@@ -1136,8 +1136,7 @@ sjp.lme.reprobcurve <- function(fit,
   if (!is.null(vars)) {
     if (is.character(vars)) {
       fit.term.names <- fit.term.names[!is.na(match(fit.term.names, vars))]
-    }
-    else {
+    } else {
       fit.term.names <- fit.term.names[vars]
     }
   }
@@ -1167,8 +1166,7 @@ sjp.lme.reprobcurve <- function(fit,
         # add reference level to coefficient name
         ll <- levels(vals)
         fit.fac.name <- paste0(fit.term.names[i], ll[length(ll)])
-      }
-      else {
+      } else {
         fit.fac.name <- fit.term.names[i]
       }
       # find coef-position
@@ -1251,7 +1249,7 @@ sjp.lme.feri <- function(fit,
   # ---------------------------------------
   # check amounnt of random intercepts
   # ---------------------------------------
-  if (length(lme4::ranef(fit)) > ri.nr) {
+  if (ri.nr > length(lme4::ranef(fit))) {
     message(""Index specified in 'ri.nr' was larger than amount of random intercepts in model. Paramater 'ri.nr' was set to 1."")
     ri.nr <- 1
   }

---FILE: README.md---
@@ -31,7 +31,7 @@ install.packages(""sjPlot"")
 
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since this package makes heavy use of the [ggplot-package](http://cran.r-project.org/web/packages/ggplot2/index.html), consider citing this package as well.
 
-### Changelog of current development build 1.7-8
+### Changelog of current development build 1.7-9
 
 #### General
 * _Utility, recode and statistical test functions have been moved to another package called [sjmisc](https://github.com/sjPlot/sjmisc)!_
@@ -57,4 +57,5 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 #### Bug fixes
 * `sjp.int` did not work for interaction terms of factors with more than two levels in mixed effects models (`merMod`-objects) - fixed.
 * `sjp.glm` and `sjp.glmm` should catch axis limits, which are out of printable bounds, hence these function should no longer stop in such cases.
+* `sjp.lmer` and `sjp.glmer` wrongly stated that paramter `ri.nr` was out of bound when `type` was `re`, `fe.ri` or `ri.pc` - fixed.
 * Weights with decimals in `sjt.xtab` (e.g. `weightBy = abs(rnorm(100, 2, 1)`) caused an error - fixed.

---FILE: man/sjPlot-package.Rd---
@@ -34,8 +34,8 @@
 \tabular{rl}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.7-8\cr
-Date: \tab 2015-03-26\cr
+Version: \tab 1.7-9\cr
+Date: \tab 2015-03-28\cr
 License: \tab GPL-3\cr
 }
 }"
strengejacke,sjPlot,820542fdc80dfc2c474a839604c632f50bf1d96f,Daniel Ldecke,d.luedecke@uke.de,2015-03-23T08:04:08Z,Daniel Ldecke,d.luedecke@uke.de,2015-03-23T08:04:08Z,"Fixed package separation, Rd-bugs and added startup-stuff",DESCRIPTION;R/sjPlotFrequencies.R;R/sjPlotGroupFrequencies.R;R/sjPlotScatter.R;R/sjPlotStackFrequencies.R;R/sjTabCorr.R;R/sjTabDataFrame.R;R/sjTabFrequencies.R;R/sjTabGrpmean.R;R/sjTabItemAnalysis.R;R/sjTabLinReg.R;R/sjTabPropTable.R;R/sjTabStackFrq.R;R/zzz.R;README.md;man/sjPlot-package.Rd;man/sjp.frq.Rd;man/sjp.grpfrq.Rd;man/sjp.scatter.Rd;man/sjp.stackfrq.Rd;man/sjt.corr.Rd;man/sjt.df.Rd;man/sjt.frq.Rd;man/sjt.grpmean.Rd;man/sjt.itemanalysis.Rd;man/sjt.stackfrq.Rd;man/sjt.xtab.Rd,False,True,True,False,107,179,286,"---FILE: DESCRIPTION---
@@ -6,25 +6,10 @@ Version: 1.7-6
 Date: 2015-03-20
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
-Description: Collection of several plotting and table output functions for visualizing data, and utility functions.
+Description: Collection of several plotting and table output functions for visualizing data.
 License: GPL-3
-Depends:
-    R(>= 3.1.0)
-Imports:
-    car,
-    dplyr (>= 0.4.1),
-    ggplot2,
-    grid,
-    MASS,
-    psych,
-    scales,
-    sjmisc,
-    tidyr (>= 0.2.0)
-Suggests:
-    arm,
-    cluster,
-    lme4,
-    lmtest,
-    lsmeans,
+Depends: R (>= 3.1)
+Imports: car, dplyr, ggplot2, grid, MASS, psych, scales, sjmisc, tidyr
+Suggests: arm, cluster, lme4, lmtest, lsmeans
 URL: https://github.com/sjPlot/devel
 BugReports: https://github.com/sjPlot/devel/issues

---FILE: R/sjPlotFrequencies.R---
@@ -128,10 +128,10 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""frq"", ""grp"", ""upper.ci"",
 #'          If you set \code{startAxisAt} to 1, you may have zero counts if the lowest value of \code{varCount}
 #'          is larger than 1 and hence no bars plotted for these values in such cases.
 #' @param autoGroupAt A value indicating at which length of unique values of \code{varCount} the variable
-#'          is automatically grouped into smaller units (see \code{\link[sjmisc]{group_var}}). If \code{varCount} has large 
+#'          is automatically grouped into smaller units (see \code{group_var}). If \code{varCount} has large 
 #'          numbers of unique values, too many bars for the graph have to be plotted. Hence it's recommended 
 #'          to group such variables. For example, if \code{autoGroupAt} is 50, i.e. if \code{varCount} has 50 and more unique values 
-#'          it will be grouped using \code{\link[sjmisc]{group_var}} with \code{groupsize=""auto""} parameter. By default, 
+#'          it will be grouped using \code{group_var} with \code{groupsize=""auto""} parameter. By default, 
 #'          the maximum group count is 30. However, if \code{autoGroupAt} is less than 30, \code{autoGroupAt} 
 #'          groups are built. Default value for \code{autoGroupAt} is \code{NULL}, i.e. auto-grouping is off.
 #' @param coord.flip If \code{TRUE}, the x and y axis are swapped. Default is \code{FALSE}.

---FILE: R/sjPlotGroupFrequencies.R---
@@ -5,9 +5,7 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""ypos"", ""wb"", ""ia"", ""mw"",
 #' @title Plot grouped or stacked frequencies
 #' @name sjp.grpfrq
 #' 
-#' @seealso \itemize{
-#'              \item \href{http://www.strengejacke.de/sjPlot/sjp.grpfrq/}{sjPlot manual: sjp.grpfrq}
-#'              }
+#' @seealso \href{http://www.strengejacke.de/sjPlot/sjp.grpfrq/}{sjPlot manual: sjp.grpfrq}
 #'             
 #' @description Plot grouped or stacked frequencies of variables 
 #'                as bar/dor graphs, box or violin plots, histograms etc.
@@ -133,10 +131,10 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""ypos"", ""wb"", ""ia"", ""mw"",
 #'          Use \code{NULL} to automatically detect variable names that will be used as title
 #'          (see \code{\link[sjmisc]{set_var_labels}}) for details).
 #' @param autoGroupAt A value indicating at which length of unique values of \code{varCount} the variable
-#'          is automatically grouped into smaller units (see \code{\link[sjmisc]{group_var}}). If \code{varCount} has large 
+#'          is automatically grouped into smaller units (see \code{group_var}). If \code{varCount} has large 
 #'          numbers of unique values, too many bars for the graph have to be plotted. Hence it's recommended 
 #'          to group such variables. For example, if \code{autoGroupAt} is 50, i.e. if \code{varCount} has 50 and more unique values 
-#'          it will be grouped using \code{\link[sjmisc]{group_var}} with \code{groupsize=""auto""} parameter. By default, 
+#'          it will be grouped using \code{group_var} with \code{groupsize=""auto""} parameter. By default, 
 #'          the maximum group count is 30. However, if \code{autoGroupAt} is less than 30, \code{autoGroupAt} 
 #'          groups are built. Default value for \code{autoGroupAt} is \code{NULL}, i.e. auto-grouping is off.
 #' @param startAxisAt Determines the first value on the x-axis. By default, this value is set

---FILE: R/sjPlotScatter.R---
@@ -17,15 +17,15 @@
 #'          examples below. Default is \code{NULL}, i.e. not grouping is done.
 #' @param title Title of the diagram, plotted above the whole diagram panel.
 #'          Use \code{NULL} to automatically detect variable names that will be used as title
-#'          (see \code{\link{set_var_labels}}) for details).
+#'          (see \code{\link[sjmisc]{set_var_labels}}) for details).
 #' @param legendTitle Title of the diagram's legend.
 #' @param legendLabels Labels for the guide/legend.
 #' @param axisTitle.x A label (title) for the x axis.
 #'          Use \code{NULL} to automatically detect variable names that will be used as title
-#'          (see \code{\link{set_var_labels}}) for details).
+#'          (see \code{\link[sjmisc]{set_var_labels}}) for details).
 #' @param axisTitle.y A label (title) for the y axis.
 #'          Use \code{NULL} to automatically detect variable names that will be used as title
-#'          (see \code{\link{set_var_labels}}) for details).
+#'          (see \code{\link[sjmisc]{set_var_labels}}) for details).
 #' @param breakTitleAt Wordwrap for diagram title. Determines how many chars of the title are displayed in
 #'          one line and when a line break is inserted into the title.
 #' @param breakLegendTitleAt Wordwrap for diagram legend title. Determines how many chars of the legend's title 
@@ -178,25 +178,25 @@ sjp.scatter <- function(x=NULL,
   # --------------------------------------------------------
   # remove titles if empty
   # --------------------------------------------------------
-  if (!is.null(legendTitle) && legendTitle=="""") legendTitle <- NULL
-  if (!is.null(axisTitle.x) && axisTitle.x=="""") axisTitle.x <- NULL
-  if (!is.null(axisTitle.y) && axisTitle.y=="""") axisTitle.y <- NULL  
-  if (!is.null(title) && title=="""") title <- NULL  
+  if (!is.null(legendTitle) && legendTitle == """") legendTitle <- NULL
+  if (!is.null(axisTitle.x) && axisTitle.x == """") axisTitle.x <- NULL
+  if (!is.null(axisTitle.y) && axisTitle.y == """") axisTitle.y <- NULL  
+  if (!is.null(title) && title == """") title <- NULL  
   # ------------------------------------------
   # check for auto-jittering
   # ------------------------------------------
   if (autojitter && !useJitter) {
     # check for valid range of jitter ratio
-    if (jitterRatio<=0 || jitterRatio>=1) {
+    if (jitterRatio <= 0 || jitterRatio >= 1) {
       # inform user
       warning(""jitterRatio out of valid bounds. Using 0.15 for jitterRatio..."")
       jitterRatio <- 0.15
     }
     # retrieve the highest amount of points lying
     # on the same coordinate
-    overlap <- nrow(table(x,y)) * ncol(table(x,y))
+    overlap <- nrow(table(x, y)) * ncol(table(x, y))
     # check ratio of overlapping points according to total points
-    if (overlap < (length(x)*jitterRatio)) {
+    if (overlap < (length(x) * jitterRatio)) {
       # use jittering now
       useJitter <- TRUE
       message(""auto-jittering values..."")
@@ -205,9 +205,7 @@ sjp.scatter <- function(x=NULL,
   # --------------------------------------------------------
   # unlist labels
   # --------------------------------------------------------
-  if (!is.null(legendLabels) && is.list(legendLabels)) {
-    legendLabels <- unlistlabels(legendLabels)
-  }
+  if (!is.null(legendLabels) && is.list(legendLabels)) legendLabels <- unlistlabels(legendLabels)
   # ------------------------------------------
   # create data frame
   # ------------------------------------------
@@ -219,51 +217,40 @@ sjp.scatter <- function(x=NULL,
     hideLegend <- TRUE
   }
   # simple data frame
-  df <- na.omit(data.frame(cbind(x=x, y=y, grp=grp)))
+  df <- na.omit(data.frame(cbind(x = x, y = y, grp = grp)))
   # group as factor
   df$grp <- as.factor(df$grp)
   # --------------------------------------------------------
   # Prepare and trim legend labels to appropriate size
   # --------------------------------------------------------
   # Check whether we have any labels passed as parameter
-  if (is.null(legendLabels)) {
-    # if not, use category text of group variable as legend text
-    legendLabels <- c(sort(unique(df$grp)))
-  }
+  # if not, use category text of group variable as legend text
+  if (is.null(legendLabels)) legendLabels <- c(sort(unique(df$grp)))
   # wrap legend text lines
   legendLabels <- sjmisc::word_wrap(legendLabels, breakLegendLabelsAt)
   # check whether we have a title for the legend
-  if (!is.null(legendTitle)) {
-    # if yes, wrap legend title line
-    legendTitle <- sjmisc::word_wrap(legendTitle, breakLegendTitleAt)
-  }
+  # if yes, wrap legend title line
+  if (!is.null(legendTitle)) legendTitle <- sjmisc::word_wrap(legendTitle, breakLegendTitleAt)
   # check length of diagram title and split longer string at into new lines
   # every 50 chars
-  if (!is.null(title)) {
-    title <- sjmisc::word_wrap(title, breakTitleAt)
-  }
+  if (!is.null(title)) title <- sjmisc::word_wrap(title, breakTitleAt)
   # check length of x-axis title and split longer string at into new lines
   # every 50 chars
-  if (!is.null(axisTitle.x)) {
-    axisTitle.x <- sjmisc::word_wrap(axisTitle.x, breakTitleAt)
-  }
+  if (!is.null(axisTitle.x)) axisTitle.x <- sjmisc::word_wrap(axisTitle.x, breakTitleAt)
   # check length of x-axis title and split longer string at into new lines
   # every 50 chars
-  if (!is.null(axisTitle.y)) {
-    axisTitle.y <- sjmisc::word_wrap(axisTitle.y, breakTitleAt)
-  }
+  if (!is.null(axisTitle.y)) axisTitle.y <- sjmisc::word_wrap(axisTitle.y, breakTitleAt)
   # --------------------------------------------------------
   # Plot scatter plot
   # --------------------------------------------------------
-  scatter <- ggplot(df,aes(x, y, colour=grp))
+  scatter <- ggplot(df,aes(x, y, colour = grp))
   # --------------------------------------------------------
   # Add marginal rug
   # --------------------------------------------------------
   if (showRug) {
     if (useJitter) {
-      scatter <- scatter + geom_rug(position=""jitter"")
-    }
-    else {
+      scatter <- scatter + geom_rug(position = ""jitter"")
+    } else {
       scatter <- scatter + geom_rug()
     }
   }
@@ -272,55 +259,55 @@ sjp.scatter <- function(x=NULL,
   # --------------------------------------------------------
   if (useJitter) {
     scatter <- scatter + geom_jitter(size = geom.size)
-  }
-  else {
+  } else {
     scatter <- scatter + geom_point(size = geom.size)
   }
   # --------------------------------------------------------
   # Show fitted lines
   # --------------------------------------------------------
-  if (showGroupFitLine) {
-    scatter <- scatter + stat_smooth(data=df, aes(colour=grp), method=fitmethod, se=showSE)
-  }
-  if (showTotalFitLine) {
-    scatter <- scatter + stat_smooth(method=fitmethod, se=showSE, colour=""black"")
-  }
+  if (showGroupFitLine) scatter <- scatter + stat_smooth(data = df, 
+                                                         aes(colour = grp), 
+                                                         method = fitmethod, 
+                                                         se = showSE)
+  if (showTotalFitLine) scatter <- scatter + stat_smooth(method = fitmethod, 
+                                                         se = showSE, 
+                                                         colour = ""black"")
   # --------------------------------------------------------
   # set font size for axes.
   # --------------------------------------------------------
   scatter <- scatter + 
-    labs(title=title, x=axisTitle.x, y=axisTitle.y, colour=legendTitle)
+    labs(title = title, 
+         x = axisTitle.x,
+         y = axisTitle.y,
+         colour = legendTitle)
   # --------------------------------------------------------
   # Hide or show tick marks
   # --------------------------------------------------------
-  if (!showTickMarkLabels.x) {
-    scatter <- scatter + scale_x_continuous(labels=NULL)
-  }
-  if (!showTickMarkLabels.y) {
-    scatter <- scatter + scale_y_continuous(labels=NULL)
-  }
+  if (!showTickMarkLabels.x) scatter <- scatter + scale_x_continuous(labels = NULL)
+  if (!showTickMarkLabels.y) scatter <- scatter + scale_y_continuous(labels = NULL)
   # --------------------------------------
   # facet plot
   # --------------------------------------
-  if (facet.grid){
-    scatter <- scatter + facet_wrap(~ grp)
-  } 
+  if (facet.grid) scatter <- scatter + facet_wrap(~ grp)
   # --------------------------------------------------------
   # Prepare fill colors
   # --------------------------------------------------------
   if (is.null(geom.colors)) {
     colen <- length(unique(na.omit(grp)))
-    if (colen==1) {
+    if (colen == 1) {
       geom.colors <- ""#003399""
-    }
-    else {
+    } else {
       geom.colors <- ""Dark2""
     }
   }
   # ---------------------------------------------------------
   # set geom colors
   # ---------------------------------------------------------
-  scatter <- sj.setGeomColors(scatter, geom.colors, length(legendLabels), ifelse(hideLegend==TRUE, FALSE, TRUE), legendLabels)
+  scatter <- sj.setGeomColors(scatter, 
+                              geom.colors, 
+                              length(legendLabels), 
+                              ifelse(hideLegend == TRUE, FALSE, TRUE), 
+                              legendLabels)
   # ---------------------------------------------------------
   # Check whether ggplot object should be returned or plotted
   # ---------------------------------------------------------

---FILE: R/sjPlotStackFrequencies.R---
@@ -43,7 +43,7 @@
 #' @param axisLabels.y Labels for the y-axis (the labels of the \code{items}). These parameters must
 #'          be passed as list! Example: \code{axisLabels.y=list(c(""Q1"", ""Q2"", ""Q3""))}
 #'          Axis labels will automatically be detected, when they have
-#'          a \code{""variable.lable""} attribute (see \code{\link{set_var_labels}}) for details).
+#'          a variable label attribute (see \code{\link[sjmisc]{set_var_labels}}) for details).
 #' @param breakTitleAt Wordwrap for diagram title. Determines how many chars of the title are displayed in
 #'          one line and when a line break is inserted into the title.
 #' @param breakLabelsAt Wordwrap for diagram labels. Determines how many chars of the category labels are displayed in 

---FILE: R/sjTabCorr.R---
@@ -29,7 +29,7 @@
 #'          provided (default), the data frame's column names are used. Item labels must
 #'          be a string vector, e.g.: \code{varlabels=c(""Var 1"", ""Var 2"", ""Var 3"")}.
 #'          varlabels are detected automatically if \code{data} is a data frame where each variable has
-#'          a \code{""variable.label""} attribute (see \code{\link{set_var_labels}}) for details).
+#'          a variable label attribute (see \code{\link[sjmisc]{set_var_labels}}) for details).
 #' @param breakLabelsAt Wordwrap for diagram labels. Determines how many chars of the variable labels are displayed in 
 #'          one line and when a line break is inserted. Default is 40.
 #' @param digits The amount of digits used the values inside table cells.

---FILE: R/sjTabDataFrame.R---
@@ -4,18 +4,17 @@
 #' @seealso \itemize{
 #'                \item \href{http://www.strengejacke.de/sjPlot/datainit/}{sjPlot manual: data initialization}
 #'                \item \href{http://www.strengejacke.de/sjPlot/view_spss/}{sjPlot manual: inspecting (SPSS imported) data frames}
-#'                \item \code{\link{view_spss}}
 #'              }
 #'              
 #' @description Shows description or the content of data frame (rows and columns) as HTML table,
 #'                or saves it as file. Helpful if you want a quick overview of a data frame's 
 #'                content. See parameter \code{describe} for details. By default, \code{describe} 
 #'                is \code{TRUE} and a description of the data frame is given,
-#'                using the \code{\link{describe}} function of the \code{psych} package.
+#'                using the \code{\link[psych]{describe}} function of the \code{psych} package.
 #'
 #' @param df A data frame that should be printed.
 #' @param describe If \code{TRUE} (default), a description of the data frame's variables is given.
-#'          The description is retrieved from the \code{\link{describe}} function of the \code{\link{psych}}
+#'          The description is retrieved from the \code{\link[psych]{describe}} function of the \code{psych}
 #'          package. If this parameter is \code{FALSE}, the data frame's content (values) is shown.
 #' @param file The destination file, which will be in html-format. If no filepath is specified,
 #'          the file will be saved as temporary file and openend either in the RStudio View pane or

---FILE: R/sjTabFrequencies.R---
@@ -24,10 +24,10 @@
 #'          from \code{data}. Note that if multiple variables are supplied (as data frame), the 
 #'          value labels must be supplied as nested \code{list} object (see examples).
 #' @param autoGroupAt A value indicating at which length of unique values a variable from \code{data}
-#'          is automatically grouped into smaller units (see \code{\link{group_var}}). Variables with large 
+#'          is automatically grouped into smaller units (see \code{group_var}). Variables with large 
 #'          numbers of unique values may be too time consuming when a HTML table is created and R would
 #'          not respond any longer. Hence it's recommended to group such variables. Default value is 50,
-#'          i.e. variables with 50 and more unique values will be grouped using \code{\link{group_var}} with
+#'          i.e. variables with 50 and more unique values will be grouped using \code{group_var} with
 #'          \code{groupsize=""auto""} parameter. By default, the maximum group count is 30. However, if
 #'          \code{autoGroupAt} is less than 30, \code{autoGroupAt} groups are built. Default value is \code{NULL},
 #'          i.e. auto-grouping is turned off.
@@ -60,10 +60,10 @@
 #' @param showSummary If \code{TRUE} (default), a summary row with total and valid N as well as mean and
 #'          standard deviation is shown.
 #' @param showSkew If \code{TRUE}, the variable's skewness is added to the summary.
-#'          The skewness is retrieved from the \code{\link{describe}} function of the \code{\link{psych}}
+#'          The skewness is retrieved from the \code{\link[psych]{describe}} function of the \code{psych}
 #'          package.
 #' @param showKurtosis If \code{TRUE}, the variable's kurtosis is added to the summary.
-#'          The kurtosis is retrieved from the \code{\link{describe}} function of the \code{\link{psych}}
+#'          The kurtosis is retrieved from the \code{\link[psych]{describe}} function of the \code{psych}
 #'          package.
 #' @param skewString A character string, which is used as header for the skew column (see \code{showSkew})).
 #'          Default is lower case Greek gamma.
@@ -171,8 +171,7 @@
 #'         valueLabels=values[['e42dep']],
 #'         CSS=list(css.table=""border: 2px solid;"",
 #'                  css.tdata=""border: 1px solid;"",
-#'                  css.firsttablecol=""color:#003399; font-weight:bold;""))
-#' }
+#'                  css.firsttablecol=""color:#003399; font-weight:bold;""))}
 #' 
 #' @importFrom psych describe
 #' @import sjmisc

---FILE: R/sjTabGrpmean.R---
@@ -10,7 +10,7 @@
 #' @param varGrp a (numeric) vector with group indices, used to select sub-groups from \code{varCount}.
 #' @param rowLabels a character vector of same length as \code{varGrp} unqiue values. In short: the
 #'          value labels of \code{varGrp}. Used to name table rows. By default, row labels
-#'          are automatically detected if set by \code{set_val_labels}.
+#'          are automatically detected if set by \code{\link[sjmisc]{set_val_labels}}.
 #' @param digits amount of digits for table values.
 #' @param digits.summary amount of digits for summary statistics (Anova).
 #' @param file The destination file, which will be in html-format. If no filepath is specified,

---FILE: R/sjTabItemAnalysis.R---
@@ -35,12 +35,12 @@
 #'          Default is \code{""auto""}, which means that each table has a standard caption \emph{Component x}.
 #'          Use \code{NULL} to suppress table captions.
 #' @param scaleItems If \code{TRUE}, the data frame's vectors will be scaled when calculating the
-#'          Cronbach's Alpha value (see \code{\link[sjmisc]{reliab_test}}). Recommended, when 
+#'          Cronbach's Alpha value (see \code{reliab_test}). Recommended, when 
 #'          the variables have different measures / scales.
 #' @param minValidRowMeanValue the minimum amount of valid values to compute row means for index scores.
 #'          Default is 2, i.e. the return values \code{index.scores} and \code{df.index.scores} are
 #'          computed for those items that have at least \code{minValidRowMeanValue} per case (observation, or
-#'          technically, row). See \code{\link[sjmisc]{mean_n}} for details.
+#'          technically, row). See \code{mean_n} for details.
 #' @param alternateRowColors If \code{TRUE}, alternating rows are highlighted with a light gray
 #'          background color.
 #' @param orderColumn Indicates a column, either by column name or by column index number,
@@ -54,8 +54,8 @@
 #'          for further details.
 #' @param showShapiro If \code{TRUE}, a Shapiro-Wilk normality test is computed for each item.
 #'          See \code{\link{shapiro.test}} for details.
-#' @param showKurtosis If \code{TRUE}, the kurtosis for each item will also be shown (see \code{\link{kurtosi}}
-#'          and \code{\link{describe}} in the \code{psych}-package for more details.
+#' @param showKurtosis If \code{TRUE}, the kurtosis for each item will also be shown (see \code{\link[psych]{kurtosi}}
+#'          and \code{\link[psych]{describe}} in the \code{psych}-package for more details.
 #' @param showCompCorrMat If \code{TRUE} (default), a correlation matrix of each component's
 #'          index score is shown. Only applies if \code{factor.groups} is not \code{NULL} and \code{df} has
 #'          more than one group. First, for each case (df's row), the sum of all variables (df's columns) is
@@ -112,7 +112,7 @@
 #' @note \itemize{
 #'          \item The \emph{Shapiro-Wilk Normality Test} (see column \code{W(p)}) tests if an item has a distribution that is significantly different from normal.
 #'          \item \emph{Item difficulty} should range between 0.2 and 0.8. Ideal value is \code{p+(1-p)/2} (which mostly is between 0.5 and 0.8).
-#'          \item For \emph{item discrimination}, acceptable values are 0.20 or higher; the closer to 1.00 the better. See \code{\link[sjmisc]{reliab_test}} for more details.
+#'          \item For \emph{item discrimination}, acceptable values are 0.20 or higher; the closer to 1.00 the better. See \code{reliab_test} for more details.
 #'          \item In case the total \emph{Cronbach's Alpha} value is below the acceptable cut-off of 0.7 (mostly if an index has few items), the \emph{mean inter-item-correlation} is an alternative measure to indicate acceptability. Satisfactory range lies between 0.2 and 0.4.
 #'        }
 #' 

---FILE: R/sjTabLinReg.R---
@@ -598,7 +598,6 @@ sjt.lm <- function (...,
           else {
             x <- sprintf(""%s%.*f%s"", sb1, digits.p, x, sb2)
           }
-          
         }
         else {
           x <- sprintf(""%.*f"", digits.p, x) 

---FILE: R/sjTabPropTable.R---
@@ -24,7 +24,7 @@
 #'          name of \code{var.col}, and - if \code{var.grp} is not \code{NULL} - name of \code{var.grp}.
 #'          See examples for more details.
 #'          variableLabels are detected automatically, if \code{var.row} or \code{var.col}
-#'          have a \code{""variable.label""} attribute (see \code{\link{set_var_labels}}) for details).
+#'          have a variable label attribute (see \code{\link[sjmisc]{set_var_labels}}) for details).
 #' @param valueLabels A list of character vectors that indicate the value labels of the supplied
 #'          variables. Following order is needed: value labels of \code{var.row},
 #'          value labels  of \code{var.col}, and - if \code{var.grp} is not \code{NULL} - 

---FILE: R/sjTabStackFrq.R---
@@ -18,7 +18,7 @@
 #' @param title A table caption.
 #' @param varlabels A list or vector of strings with variable names. If not specified, row names of \code{items}
 #'          will be used, resp. variable labels will automatically be detected, when they have
-#'          a \code{""variable.lable""} attribute (see \code{\link[sjmisc]{set_var_labels}}) for details).
+#'          a variable label attribute (see \code{\link[sjmisc]{set_var_labels}}) for details).
 #' @param breakLabelsAt Wordwrap for variable labels. Determines how many chars of the variable labels are displayed in 
 #'          one line and when a line break is inserted. Default is 40.
 #' @param valuelabels A list or vector of strings that category/value labels, which
@@ -39,10 +39,10 @@
 #' @param showNA If \code{TRUE}, \code{\link{NA}}'s (missing values) are also printed in the table.
 #' @param labelNA The label for the missing column/row.
 #' @param showSkew If \code{TRUE}, an additional column with each item's skewness is printed.
-#'          The skewness is retrieved from the \code{\link{describe}} function of the \code{\link{psych}}
+#'          The skewness is retrieved from the \code{\link[psych]{describe}} function of the \code{psych}
 #'          package.
 #' @param showKurtosis If \code{TRUE}, an additional column with each item's kurtosis is printed.
-#'          The kurtosis is retrieved from the \code{\link{describe}} function of the \code{\link{psych}}
+#'          The kurtosis is retrieved from the \code{\link[psych]{describe}} function of the \code{psych}
 #'          package.
 #' @param digits.stats The amount of digits for rounding the skewness and kurtosis valuess.
 #'          Default is 2, i.e. skewness and kurtosis values have 2 digits after decimal point.

---FILE: R/zzz.R---
@@ -0,0 +1,5 @@
+.onLoad <- function(libname, pkgname) {
+  if (!require(sjmisc)) {
+    warning(""Package 'sjmisc' required to use sjPlot! Please install it..."", call. = F)
+  }
+}

---FILE: README.md---
@@ -49,43 +49,3 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 #### Bug fixes
 * `sjp.int` did not work for interaction terms of factors with more than two levels in mixed effects models (`merMod`-objects) - fixed.
 * Weights with decimals in `sjt.xtab` (e.g. `weightBy = abs(rnorm(100, 2, 1)`) caused an error - fixed.
-
-
-### Changelog of current stable build 1.7
-
-#### General
-* Renamed `sjs`, `sju`, `sjd` and `sji`-functions into more intuitiv and shorter function names.
-* `autoSetValueLabels` and `autoSetVariableLabels` are now a global option. E.g., use `options(autoSetValueLabels = FALSE)` to turn off automatic value label detection in plotting and table functions, or `options(autoSetValueLabels = TRUE)` to turn on automatic label detection.
-* `p_zero` is now a global option. Use `options(p_zero = TRUE)` to show leading zero before period in p-value, r-quared and phi labels.
-* `read_spss` is now a global option. Use `options(read_spss = 'haven')` to set default package for readind spss data to haven, or `options(read_spss = 'foreign')` to make `read_spss` use the foreign package to read spss data.
-* `value_labels` is now a global option. Use `options(value_labels = 'haven')` to set default attribute assignment in haven format (`labels` and `label`), or `options(value_labels = 'foreign')` to to set default attribute assignment in foreign format (`value.labels` and `variable.label`). Affects functions like auto-detection of labels, `set_var_labels` or `set_val_labels` etc.
-* Removed `plyr` import and replaced with `dplyr` functions.
-* Removed `reshape2` import and replaced with `tidyr` functions.
-* Added two more sample datasets (`efc2` and `efc3`) to the package, which slightly differ in their structure.
-
-#### New functions
-* `write_spss` to write data frames to SPSS sav-files, including value and variable labels.
-* `write_stata` to write data frames to STATA files, including value and variable labels.
-* `read_stata` to read STATA files, including value and variable labels.
-* `read_sas` to read SAS files, including value and variable labels.
-* `to_sjPlot` to convert data frames imported with the `haven` package ([see GitHub](https://github.com/hadley/haven)) to a more sjPlot-friendly format.
-* `to_fac` to convert (numeric or atomic) variables to factors, but keeps value and variable labels. Useful alternative to `as.factor`, when data has been imported from SPSS (e.g. with `read_spss`).
-
-#### Changes to functions
-* `read_spss` (former `sji.SPSS`) now supports reading data via `haven`'s read-function (see parameter `option`).
-* `sjt.lm` and `sjt.glm` now also print multiple fitted models with different predictors in each model (e.g. when comparing stepwise regression). See examples in `?sjt.lm` and `?sjt.glm`.
-* Added parameter `remove.estimates` to `sjt.lm` and `sjt.glm`, so specific estimates can be removed from the table output.
-* Added parameter `group.pred` in `sjt.lm` and `sjt.glm` to automatically group table rows with factor levels of same factor.
-* Improved `set_var_labels`, `get_var_labels`, `set_val_labels` and `get_val_labels` to cope with `haven` package data structure.
-* Improved `view_spss` function (former `sji.viewSPSS`).
-* Improved automatic label extraction for `sjp.lm`, `sjt.lm`, `sjp.glm` and `sjt.glm`.
-* Improved pre-set theme `538` in `sjp.setTheme`.
-* Added further pre-set themes to `sjp.setTheme`.
-* Minor improvements in `sjp.lm` with `type=""ma""`.
-
-#### Bug fixes
-* Fixed bug in `sjt.itemanalysis` [(#issue 8)](https://github.com/sjPlot/devel/issues/8).
-* Fixed bug in `sji.setValueLabels`.
-* Fixed bug in `sjt.frq` with string-variables that contained a larger amount of unique values including `NA`-values, when parameter `skipZeroRows` was set to `auto` (default).
-* Minor bug fixes in `sjp.lm` with `type=""ma""`.
-* `weight` should now also include `NA`s.

---FILE: man/sjPlot-package.Rd---
@@ -1,4 +1,4 @@
-\encoding{UTF-8} 
+\encoding{UTF-8}
 \name{sjPlot-package}
 \alias{sjPlot-package}
 \alias{sjPlot}
@@ -19,7 +19,7 @@
   
   One of the more challenging tasks when working with R is to get nicely formatted output of statistical analyses, either in graphical or table format. The sjPlot-package takes over these tasks and makes it very easy to create beautiful figures or tables in a very intuitive way.
 
-  There are many examples for each function in the related help files and a comprehensive \href{http://www.strengejacke.de/sjPlot}{online documentation}.
+  There are many examples for each function in the related help files and a comprehensive online documentation at \url{http://www.strengejacke.de/sjPlot}.
   
   \emph{A note on the package functions}
 
@@ -35,7 +35,7 @@
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
 Version: \tab 1.7-6\cr
-Date: \tab 2015-03-20\cr
+Date: \tab 2015-03-21\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjp.frq.Rd---
@@ -174,10 +174,10 @@ to adjust the \code{geom.size} parameter for better visual results (which, by gg
 1/30 of the x-axis-range).}
 
 \item{autoGroupAt}{A value indicating at which length of unique values of \code{varCount} the variable
-is automatically grouped into smaller units (see \code{\link[sjmisc]{group_var}}). If \code{varCount} has large
+is automatically grouped into smaller units (see \code{group_var}). If \code{varCount} has large
 numbers of unique values, too many bars for the graph have to be plotted. Hence it's recommended
 to group such variables. For example, if \code{autoGroupAt} is 50, i.e. if \code{varCount} has 50 and more unique values
-it will be grouped using \code{\link[sjmisc]{group_var}} with \code{groupsize=""auto""} parameter. By default,
+it will be grouped using \code{group_var} with \code{groupsize=""auto""} parameter. By default,
 the maximum group count is 30. However, if \code{autoGroupAt} is less than 30, \code{autoGroupAt}
 groups are built. Default value for \code{autoGroupAt} is \code{NULL}, i.e. auto-grouping is off.}
 

---FILE: man/sjp.grpfrq.Rd---
@@ -188,10 +188,10 @@ Use \code{NULL} to automatically detect variable names that will be used as titl
 (see \code{\link[sjmisc]{set_var_labels}}) for details).}
 
 \item{autoGroupAt}{A value indicating at which length of unique values of \code{varCount} the variable
-is automatically grouped into smaller units (see \code{\link[sjmisc]{group_var}}). If \code{varCount} has large
+is automatically grouped into smaller units (see \code{group_var}). If \code{varCount} has large
 numbers of unique values, too many bars for the graph have to be plotted. Hence it's recommended
 to group such variables. For example, if \code{autoGroupAt} is 50, i.e. if \code{varCount} has 50 and more unique values
-it will be grouped using \code{\link[sjmisc]{group_var}} with \code{groupsize=""auto""} parameter. By default,
+it will be grouped using \code{group_var} with \code{groupsize=""auto""} parameter. By default,
 the maximum group count is 30. However, if \code{autoGroupAt} is less than 30, \code{autoGroupAt}
 groups are built. Default value for \code{autoGroupAt} is \code{NULL}, i.e. auto-grouping is off.}
 
@@ -276,8 +276,6 @@ sjp.grpfrq(efc$neg_c_7,
            showValueLabels = FALSE)
 }
 \seealso{
-\itemize{
-             \item \href{http://www.strengejacke.de/sjPlot/sjp.grpfrq/}{sjPlot manual: sjp.grpfrq}
-             }
+\href{http://www.strengejacke.de/sjPlot/sjp.grpfrq/}{sjPlot manual: sjp.grpfrq}
 }
 

---FILE: man/sjp.scatter.Rd---
@@ -28,19 +28,19 @@ examples below. Default is \code{NULL}, i.e. not grouping is done.}
 
 \item{title}{Title of the diagram, plotted above the whole diagram panel.
 Use \code{NULL} to automatically detect variable names that will be used as title
-(see \code{\link{set_var_labels}}) for details).}
+(see \code{\link[sjmisc]{set_var_labels}}) for details).}
 
 \item{legendTitle}{Title of the diagram's legend.}
 
 \item{legendLabels}{Labels for the guide/legend.}
 
 \item{axisTitle.x}{A label (title) for the x axis.
 Use \code{NULL} to automatically detect variable names that will be used as title
-(see \code{\link{set_var_labels}}) for details).}
+(see \code{\link[sjmisc]{set_var_labels}}) for details).}
 
 \item{axisTitle.y}{A label (title) for the y axis.
 Use \code{NULL} to automatically detect variable names that will be used as title
-(see \code{\link{set_var_labels}}) for details).}
+(see \code{\link[sjmisc]{set_var_labels}}) for details).}
 
 \item{breakTitleAt}{Wordwrap for diagram title. Determines how many chars of the title are displayed in
 one line and when a line break is inserted into the title.}

---FILE: man/sjp.stackfrq.Rd---
@@ -49,7 +49,7 @@ cases are weighted. Use a string as parameter, e.g.: \code{weightByTitleString=""
 \item{axisLabels.y}{Labels for the y-axis (the labels of the \code{items}). These parameters must
 be passed as list! Example: \code{axisLabels.y=list(c(""Q1"", ""Q2"", ""Q3""))}
 Axis labels will automatically be detected, when they have
-a \code{""variable.lable""} attribute (see \code{\link{set_var_labels}}) for details).}
+a variable label attribute (see \code{\link[sjmisc]{set_var_labels}}) for details).}
 
 \item{breakTitleAt}{Wordwrap for diagram title. Determines how many chars of the title are displayed in
 one line and when a line break is inserted into the title.}

---FILE: man/sjt.corr.Rd---
@@ -40,7 +40,7 @@ in the default web browser.}
 provided (default), the data frame's column names are used. Item labels must
 be a string vector, e.g.: \code{varlabels=c(""Var 1"", ""Var 2"", ""Var 3"")}.
 varlabels are detected automatically if \code{data} is a data frame where each variable has
-a \code{""variable.label""} attribute (see \code{\link{set_var_labels}}) for details).}
+a variable label attribute (see \code{\link[sjmisc]{set_var_labels}}) for details).}
 
 \item{breakLabelsAt}{Wordwrap for diagram labels. Determines how many chars of the variable labels are displayed in
 one line and when a line break is inserted. Default is 40.}

---FILE: man/sjt.df.Rd---
@@ -16,7 +16,7 @@ sjt.df(df, describe = TRUE, file = NULL, alternateRowColors = FALSE,
 \item{df}{A data frame that should be printed.}
 
 \item{describe}{If \code{TRUE} (default), a description of the data frame's variables is given.
-The description is retrieved from the \code{\link{describe}} function of the \code{\link{psych}}
+The description is retrieved from the \code{\link[psych]{describe}} function of the \code{psych}
 package. If this parameter is \code{FALSE}, the data frame's content (values) is shown.}
 
 \item{file}{The destination file, which will be in html-format. If no filepath is specified,
@@ -106,7 +106,7 @@ Shows description or the content of data frame (rows and columns) as HTML table,
                or saves it as file. Helpful if you want a quick overview of a data frame's
                content. See parameter \code{describe} for details. By default, \code{describe}
                is \code{TRUE} and a description of the data frame is given,
-               using the \code{\link{describe}} function of the \code{psych} package.
+               using the \code{\link[psych]{describe}} function of the \code{psych} package.
 }
 \examples{
 \dontrun{
@@ -145,7 +145,6 @@ sjt.df(efc,
 \itemize{
                \item \href{http://www.strengejacke.de/sjPlot/datainit/}{sjPlot manual: data initialization}
                \item \href{http://www.strengejacke.de/sjPlot/view_spss/}{sjPlot manual: inspecting (SPSS imported) data frames}
-               \item \code{\link{view_spss}}
              }
 }
 

---FILE: man/sjt.frq.Rd---
@@ -38,10 +38,10 @@ from \code{data}. Note that if multiple variables are supplied (as data frame),
 value labels must be supplied as nested \code{list} object (see examples).}
 
 \item{autoGroupAt}{A value indicating at which length of unique values a variable from \code{data}
-is automatically grouped into smaller units (see \code{\link{group_var}}). Variables with large
+is automatically grouped into smaller units (see \code{group_var}). Variables with large
 numbers of unique values may be too time consuming when a HTML table is created and R would
 not respond any longer. Hence it's recommended to group such variables. Default value is 50,
-i.e. variables with 50 and more unique values will be grouped using \code{\link{group_var}} with
+i.e. variables with 50 and more unique values will be grouped using \code{group_var} with
 \code{groupsize=""auto""} parameter. By default, the maximum group count is 30. However, if
 \code{autoGroupAt} is less than 30, \code{autoGroupAt} groups are built. Default value is \code{NULL},
 i.e. auto-grouping is turned off.}
@@ -87,11 +87,11 @@ counts, zero-values would be skipped automatically).}
 standard deviation is shown.}
 
 \item{showSkew}{If \code{TRUE}, the variable's skewness is added to the summary.
-The skewness is retrieved from the \code{\link{describe}} function of the \code{\link{psych}}
+The skewness is retrieved from the \code{\link[psych]{describe}} function of the \code{psych}
 package.}
 
 \item{showKurtosis}{If \code{TRUE}, the variable's kurtosis is added to the summary.
-The kurtosis is retrieved from the \code{\link{describe}} function of the \code{\link{psych}}
+The kurtosis is retrieved from the \code{\link[psych]{describe}} function of the \code{psych}
 package.}
 
 \item{skewString}{A character string, which is used as header for the skew column (see \code{showSkew})).
@@ -215,8 +215,7 @@ sjt.frq(efc$e42dep,
         valueLabels=values[['e42dep']],
         CSS=list(css.table=""border: 2px solid;"",
                  css.tdata=""border: 1px solid;"",
-                 css.firsttablecol=""color:#003399; font-weight:bold;""))
-}
+                 css.firsttablecol=""color:#003399; font-weight:bold;""))}
 }
 \seealso{
 \itemize{

---FILE: man/sjt.grpmean.Rd---
@@ -15,7 +15,7 @@ sjt.grpmean(varCount, varGrp, rowLabels = NULL, digits = 2,
 
 \item{rowLabels}{a character vector of same length as \code{varGrp} unqiue values. In short: the
 value labels of \code{varGrp}. Used to name table rows. By default, row labels
-are automatically detected if set by \code{set_val_labels}.}
+are automatically detected if set by \code{\link[sjmisc]{set_val_labels}}.}
 
 \item{digits}{amount of digits for table values.}
 

---FILE: man/sjt.itemanalysis.Rd---
@@ -25,13 +25,13 @@ Default is \code{""auto""}, which means that each table has a standard caption \em
 Use \code{NULL} to suppress table captions.}
 
 \item{scaleItems}{If \code{TRUE}, the data frame's vectors will be scaled when calculating the
-Cronbach's Alpha value (see \code{\link[sjmisc]{reliab_test}}). Recommended, when
+Cronbach's Alpha value (see \code{reliab_test}). Recommended, when
 the variables have different measures / scales.}
 
 \item{minValidRowMeanValue}{the minimum amount of valid values to compute row means for index scores.
 Default is 2, i.e. the return values \code{index.scores} and \code{df.index.scores} are
 computed for those items that have at least \code{minValidRowMeanValue} per case (observation, or
-technically, row). See \code{\link[sjmisc]{mean_n}} for details.}
+technically, row). See \code{mean_n} for details.}
 
 \item{alternateRowColors}{If \code{TRUE}, alternating rows are highlighted with a light gray
 background color.}
@@ -50,8 +50,8 @@ for further details.}
 \item{showShapiro}{If \code{TRUE}, a Shapiro-Wilk normality test is computed for each item.
 See \code{\link{shapiro.test}} for details.}
 
-\item{showKurtosis}{If \code{TRUE}, the kurtosis for each item will also be shown (see \code{\link{kurtosi}}
-and \code{\link{describe}} in the \code{psych}-package for more details.}
+\item{showKurtosis}{If \code{TRUE}, the kurtosis for each item will also be shown (see \code{\link[psych]{kurtosi}}
+and \code{\link[psych]{describe}} in the \code{psych}-package for more details.}
 
 \item{showCompCorrMat}{If \code{TRUE} (default), a correlation matrix of each component's
 index score is shown. Only applies if \code{factor.groups} is not \code{NULL} and \code{df} has
@@ -143,7 +143,7 @@ This function performs an item analysis with certain statistics that are
 \itemize{
          \item The \emph{Shapiro-Wilk Normality Test} (see column \code{W(p)}) tests if an item has a distribution that is significantly different from normal.
          \item \emph{Item difficulty} should range between 0.2 and 0.8. Ideal value is \code{p+(1-p)/2} (which mostly is between 0.5 and 0.8).
-         \item For \emph{item discrimination}, acceptable values are 0.20 or higher; the closer to 1.00 the better. See \code{\link[sjmisc]{reliab_test}} for more details.
+         \item For \emph{item discrimination}, acceptable values are 0.20 or higher; the closer to 1.00 the better. See \code{reliab_test} for more details.
          \item In case the total \emph{Cronbach's Alpha} value is below the acceptable cut-off of 0.7 (mostly if an index has few items), the \emph{mean inter-item-correlation} is an alternative measure to indicate acceptability. Satisfactory range lies between 0.2 and 0.4.
        }
 }

---FILE: man/sjt.stackfrq.Rd---
@@ -23,7 +23,7 @@ Must be a vector of same length as \code{nrow(items)}. Default is \code{NULL}, s
 
 \item{varlabels}{A list or vector of strings with variable names. If not specified, row names of \code{items}
 will be used, resp. variable labels will automatically be detected, when they have
-a \code{""variable.lable""} attribute (see \code{\link[sjmisc]{set_var_labels}}) for details).}
+a variable label attribute (see \code{\link[sjmisc]{set_var_labels}}) for details).}
 
 \item{breakLabelsAt}{Wordwrap for variable labels. Determines how many chars of the variable labels are displayed in
 one line and when a line break is inserted. Default is 40.}
@@ -58,11 +58,11 @@ Default is 2, i.e. percentage values have 2 digits after decimal point.}
 \item{labelNA}{The label for the missing column/row.}
 
 \item{showSkew}{If \code{TRUE}, an additional column with each item's skewness is printed.
-The skewness is retrieved from the \code{\link{describe}} function of the \code{\link{psych}}
+The skewness is retrieved from the \code{\link[psych]{describe}} function of the \code{psych}
 package.}
 
 \item{showKurtosis}{If \code{TRUE}, an additional column with each item's kurtosis is printed.
-The kurtosis is retrieved from the \code{\link{describe}} function of the \code{\link{psych}}
+The kurtosis is retrieved from the \code{\link[psych]{describe}} function of the \code{psych}
 package.}
 
 \item{digits.stats}{The amount of digits for rounding the skewness and kurtosis valuess.

---FILE: man/sjt.xtab.Rd---
@@ -40,7 +40,7 @@ the associated variable names. Following order is needed: name of \code{var.row}
 name of \code{var.col}, and - if \code{var.grp} is not \code{NULL} - name of \code{var.grp}.
 See examples for more details.
 variableLabels are detected automatically, if \code{var.row} or \code{var.col}
-have a \code{""variable.label""} attribute (see \code{\link{set_var_labels}}) for details).}
+have a variable label attribute (see \code{\link[sjmisc]{set_var_labels}}) for details).}
 
 \item{valueLabels}{A list of character vectors that indicate the value labels of the supplied
 variables. Following order is needed: value labels of \code{var.row},"
strengejacke,sjPlot,83ca4c280152ed9ec6371b6dc4c9bee786024280,Daniel Ldecke,d.luedecke@uke.de,2015-03-19T17:54:26Z,Daniel Ldecke,d.luedecke@uke.de,2015-03-19T17:54:26Z,"bugfix in sjp.int, moved lme4 to suggested packages",DESCRIPTION;NAMESPACE;NEWS;R/sjPlotGLME.R;R/sjPlotInteractions.R;R/sjPlotSetTheme.R;R/sjRecode.R;README.md;man/group_str.Rd;man/sjPlot-package.Rd;man/sjp.int.Rd;man/sjp.setTheme.Rd;man/str_pos.Rd,False,True,True,False,190,59,249,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.7-4
-Date: 2015-03-18
+Version: 1.7-5
+Date: 2015-03-19
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of several plotting and table output functions for
@@ -12,20 +12,20 @@ License: GPL-3
 Depends:
     R(>= 3.1.0)
 Imports:
-    arm,
     car,
     dplyr (>= 0.4.1),
     ggplot2,
-    lme4,
     MASS,
     psych,
     scales,
     tidyr (>= 0.2.0)
 Suggests:
+    arm,
     cluster,
     coin,
     foreign,
     haven,
+    lme4,
     lmtest,
     lsmeans,
     stringdist

---FILE: NAMESPACE---
@@ -81,11 +81,9 @@ export(write_spss)
 export(write_stata)
 import(dplyr)
 import(ggplot2)
-import(lme4)
 import(tidyr)
 importFrom(MASS,lda)
 importFrom(MASS,loglm)
-importFrom(arm,se.ranef)
 importFrom(car,crPlots)
 importFrom(car,durbinWatsonTest)
 importFrom(car,influencePlot)

---FILE: NEWS---
@@ -1,18 +1,24 @@
-Version 1.7-4
+Version 1.7-5
 ------------------------------------------------------------------------------
 General:
-* Change R-Version dependency to R >= 3.1, due to import of ""tidyr"" and ""dplyr"" packages.
-* Improved internal management of imported data via ""haven"" and ""foreign"" packages, so users don't need to care of structure and classed of data read with either haven, foreing or sjPlot's read-functions.
+* R-Version dependency changed to R >= 3.1, due to import of ""tidyr"" and ""dplyr"" packages.
+* Improved internal management of imported data via ""haven"" and ""foreign"" packages, so users don't need to care of structure and classed of data read with either haven, foreign or sjPlot's read-functions.
 
 New functions:
 * ""cv"" to compute coefficient of variance.
 * ""rmse"" to compute root-mean-square error.
 
 Changes to functions:
 * ""sjp.glm"" now supports plotting ""logistf"" objects.
+* Added parameter ""legendTitle"" to ""sjp.int"".
+* Added parameter ""int.plot.index"" to ""sjp.int"", so only selected interaction terms may be plotted.
+* Parameter ""legendLabels"" of ""sjp.int"" now accepts a list of character vectors, with one vector of legend labels for each interaction plot plotted.
+* Parameter ""title"" of ""sjp.int"" now accepts a character vector of same length as interaction terms, with one title character string for each interaction plot plotted.
 * Added further pre-set themes to ""sjp.setTheme"".
+* Minor improvements of ""sjp.setTheme"".
 
 Bug fixes:
+* ""sjp.int"" did not work for interaction terms of factors with more than two levels in mixed effects models (""merMod""-objects) - fixed.
 * Weights with decimals in ""sjt.xtab"" (e.g. ""weightBy = abs(rnorm(100, 2, 1)"") caused an error - fixed.
 
 

---FILE: R/sjPlotGLME.R---
@@ -171,8 +171,6 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""nQQ"", ""ci"", ""fixef"", ""fa
 #'           vars = ""neg_c_7"")}
 #'
 #' @import ggplot2
-#' @import lme4
-#' @importFrom arm se.ranef
 #' @export
 sjp.glmer <- function(fit,
                       type = ""re"",
@@ -384,8 +382,6 @@ sjp.glmer <- function(fit,
 #' sjp.lmer(fit, type = ""re.qq"")}
 #'
 #' @import ggplot2
-#' @import lme4
-#' @importFrom arm se.ranef
 #' @export
 sjp.lmer <- function(fit,
                      type = ""re"",
@@ -466,6 +462,15 @@ sjp.lme4  <- function(fit,
                       show.se,
                       printPlot,
                       fun) {
+  # ------------------------
+  # check if suggested package is available
+  # ------------------------
+  if (!requireNamespace(""lme4"", quietly = TRUE)) {
+    stop(""Package 'lme4' needed for this function to work. Please install it."", call. = FALSE)
+  }
+  if (!requireNamespace(""arm"", quietly = TRUE)) {
+    stop(""Package 'lme4' needed for this function to work. Please install it."", call. = FALSE)
+  }
   # -------------------------------------
   # check type
   # -------------------------------------

---FILE: R/sjPlotInteractions.R---
@@ -37,6 +37,10 @@
 #'            \item linear mixed effects models (\code{lme4::lmer})
 #'            \item generalized linear mixed effects models (\code{lme4::glmer})
 #'            }
+#' @param int.plot.index A numeric vector with index numbers that indicate which 
+#'          interaction terms should be plotted in case the \code{fit} has more than
+#'          one interaction. By default, this values is \code{NULL}, hence all interactions
+#'          are plotted.
 #' @param diff if \code{FALSE} (default), the minimum and maximum interaction effects of predictor 2 on predictor 1
 #'          are shown (one line each). if \code{TRUE}, only the difference between minimum and maximum interaction effect
 #'          is shown (single line)
@@ -52,7 +56,8 @@
 #'          \code{FALSE}, so the predictor with more unique values is printed along the x-axis.
 #' @param plevel Indicates at which p-value an interaction term is considered as significant. Default is
 #'          0.05 (5 percent).
-#' @param title a default title used for the plots. Default value is \code{NULL}, which means that each plot's title
+#' @param title a default title used for the plots. Should be a character vector
+#'          of same length as interaction plots to be plotted. Default value is \code{NULL}, which means that each plot's title
 #'          includes the dependent variable as well as the names of the interaction terms.
 #' @param fillColor fill color of the shaded area between the minimum and maximum lines. Default is \code{""grey""}.
 #'          Either set \code{fillColor} to \code{NULL} or use 0 for \code{fillAlpha} if you want to hide the shaded area.
@@ -64,15 +69,24 @@
 #'          mean value of the interaction term (moderator value). Third value is only used when \code{moderatorValues}
 #'          is \code{""meansd""}. Or, if \code{diff} is \code{TRUE}, only one color value for the line indicating the
 #'          upper difference between lower and upper bound of interaction terms.
-#' @param axisTitle.x a default title used for the x-axis. Default value is \code{NULL},
+#' @param axisTitle.x a default title used for the x-axis. Should be a character vector
+#'          of same length as interaction plots to be plotted. Default value is \code{NULL},
 #'          which means that each plot's x-axis uses the predictor's name as title.
 #' @param axisTitle.y a default title used for the y-axis. Default value is \code{NULL},
 #'          which means that each plot's y-axis uses the dependent variable's name as title.
-#' @param legendLabels Labels for the guide/legend. Default is \code{NULL}, so the name of the predictor with
-#'          min/max-effect is used as legend label.
+#' @param legendTitle Title of the diagram's legend. A character vector of same length as 
+#'          amount of interaction plots to be plotted (i.e. one vector element for each
+#'          plot's legend title).
+#' @param legendLabels Labels for the guide/legend. Either a character vector of same length as
+#'          amount of legend labels of the plot, or a \code{list} of character vectors, if more than one
+#'          interaction plot is plotted (i.e. one vector of legend labels for each interaction plot).
+#'          Default is \code{NULL}, so the name of the predictor with min/max-effect is used 
+#'          as legend label.
 #' @param showValueLabels if \code{TRUE}, value labels are plotted along the lines. Default is \code{FALSE}.
 #' @param breakTitleAt Wordwrap for diagram's title. Determines how many chars of the title are
 #'          displayed in one line and when a line break is inserted. Default is \code{50}.
+#' @param breakLegendTitleAt Wordwrap for diagram legend title. Determines how many chars of the legend's title 
+#'          are displayed in one line and when a line break is inserted.
 #' @param breakLegendLabelsAt Wordwrap for diagram legend labels. Determines how many chars of the legend labels are
 #'          displayed in one line and when a line break is inserted. Default is \code{20}.
 #' @param breakAnnotationLabelsAt Wordwrap for diagram annotation labels. Determines how many chars of the legend labels are
@@ -179,6 +193,7 @@
 #' @import ggplot2
 #' @export
 sjp.int <- function(fit,
+                    int.plot.index=NULL,
                     diff=FALSE,
                     moderatorValues=""minmax"",
                     swapPredictors=FALSE,
@@ -189,10 +204,12 @@ sjp.int <- function(fit,
                     geom.colors=""Set1"",
                     axisTitle.x=NULL,
                     axisTitle.y=NULL,
+                    legendTitle=NULL,
                     legendLabels=NULL,
                     showValueLabels=FALSE,
                     breakTitleAt=50,
                     breakLegendLabelsAt=20,
+                    breakLegendTitleAt=20, 
                     breakAnnotationLabelsAt=50,
                     axisLimits.y=NULL,
                     gridBreaksAt=NULL,
@@ -218,6 +235,12 @@ sjp.int <- function(fit,
     fun <- ""glmer""
   }
   if ((fun == ""glm"" || fun == ""glmer"") && is.null(axisTitle.y)) axisTitle.y <- ""Predicted Probability""
+  # ------------------------
+  # check if suggested package is available
+  # ------------------------
+  if ((fun == ""lmer"" || fun == ""glmer"") && !requireNamespace(""lme4"", quietly = TRUE)) {
+    stop(""Package 'lme4' needed for this function to work. Please install it."", call. = FALSE)
+  }
   # -----------------------------------------------------------
   # parameter check
   # -----------------------------------------------------------
@@ -227,11 +250,10 @@ sjp.int <- function(fit,
   }
   if (is.null(gridBreaksAt)) gridbreaks.x <- gridbreaks.y <- waiver()
   # --------------------------------------------------------
-  # unlist labels
+  # list labels
   # --------------------------------------------------------
-  if (!is.null(legendLabels) && is.list(legendLabels)) {
-    legendLabels <- unlistlabels(legendLabels)
-  }
+  if (!is.null(legendLabels) && !is.list(legendLabels)) legendLabels <- list(legendLabels)
+  if (!is.null(legendTitle) && is.list(legendTitle)) legendTitle <- unlist(legendTitle)
   # -----------------------------------------------------------
   # retrieve coefficients
   # -----------------------------------------------------------
@@ -311,11 +333,22 @@ sjp.int <- function(fit,
         # iterate interaction term for all factor levels,
         # and replace with ""original variable name in data frame
         for (j in 1:length(fac.lvl)) {
+          # -----------------------------------------------
+          # the following code ""converts"" a factor 
+          # into a 0/1 dummy coded variable, so each factor
+          # level is present as 0/1 coded dummy
+          # ----------------------------------------------
+          # create new dummy variable
+          fitdat$sj__new__est <- 0
+          # set all factor levels to 1
+          fitdat$sj__new__est[which(fitdat[, fac.names[i]] == levels(fitdat[, fac.names[i]])[j])] <- 1
+          # rename intro ""proper"" name
+          colnames(fitdat)[ncol(fitdat)] <- paste0(fac.names[i], fac.lvl[j])
           # create replacement-strings
-          rep1 <- paste0(fac.names[i], fac.lvl[j])
-          rep2 <- paste0(fac.names[i])
+          # rep1 <- paste0(fac.names[i], fac.lvl[j])
+          # rep2 <- paste0(fac.names[i])
           # replace in all
-          estimates.names <- gsub(rep1, rep2, estimates.names, fixed = TRUE)
+          # estimates.names <- gsub(rep1, rep2, estimates.names, fixed = TRUE)
         }
       }
     }
@@ -372,6 +405,15 @@ sjp.int <- function(fit,
   plotlist <- list()
   dflist <- list()
   # -----------------------------------------------------------
+  # when we have linear mixed effects models and both interaction 
+  # terms are factors, we may have the same interaction term names
+  # multiples times - thus, remove redundant duplicates
+  # -----------------------------------------------------------
+  intnames <- unique(intnames)
+  # check if we have selected plots only, and remove any plots
+  # that should not be plotted.
+  if (!is.null(int.plot.index)) intnames <- intnames[int.plot.index]
+  # -----------------------------------------------------------
   # Now iterate all significant interaction terms
   # and manually calculate the linear regression by inserting
   # the estimates of each term and the associated interaction term,
@@ -652,18 +694,54 @@ sjp.int <- function(fit,
                          interactionterms[[1]][ifelse(useFirstPredOnY == TRUE, 2, 1)],
                          "" on "", depvar.label)
     } else {
-      labtitle <- title
+      # copy plot counter 
+      l_nr <- cnt
+      # check if we have enough labels. if not, use last labels
+      if (l_nr > length(title)) l_nr <- length(title)
+      # set legend labels for plot
+      labtitle <- title[l_nr]
     }
+    # -----------------------------------------------------------
+    # legend labels
+    # -----------------------------------------------------------
     if (is.null(legendLabels)) {
       if (moderatorValues == ""minmax"") {
         lLabels <- c(paste0(""lower bound of "", predy), paste0(""upper bound of "", predy))
       } else {
         lLabels <- c(paste0(""lower sd of "", predy), paste0(""upper sd of "", predy), paste0(""mean of "", predy))
       }
     } else {
-      lLabels <- legendLabels
+      # copy plot counter 
+      l_nr <- cnt
+      # check if we have enough labels. if not, use last labels
+      if (l_nr > length(legendLabels)) l_nr <- length(legendLabels)
+      # set legend labels for plot
+      lLabels <- legendLabels[[l_nr]]
+    }
+    # -----------------------------------------------------------
+    # legend titles
+    # -----------------------------------------------------------
+    if (is.null(legendTitle)) {
+      lTitle <- predy
+    } else {
+      # copy plot counter 
+      l_nr <- cnt
+      # check if we have enough legend titles, if not, use last legend title
+      if (l_nr > length(legendTitle)) l_nr <- length(legendTitle)
+      # set legend title for plot
+      lTitle <- legendTitle[l_nr]
+    }
+    # -----------------------------------------------------------
+    # x axis titles
+    # -----------------------------------------------------------
+    if (!is.null(axisTitle.x)) {
+      # copy plot counter 
+      l_nr <- cnt
+      # check if we have enough axis titles, if not, use last legend title
+      if (l_nr > length(axisTitle.x)) l_nr <- length(axisTitle.x)
+      # set axis title
+      labx <- axisTitle.x[l_nr]
     }
-    if (!is.null(axisTitle.x)) labx <- axisTitle.x
     if (!is.null(axisTitle.y)) laby <- axisTitle.y
     # -----------------------------------------------------------
     # prepare annotation labels
@@ -674,6 +752,8 @@ sjp.int <- function(fit,
     labtitle <- word_wrap(labtitle, breakTitleAt)
     # wrap legend labels
     lLabels <- word_wrap(lLabels, breakLegendLabelsAt)
+    # wrap legend title
+    lTitle <- word_wrap(lTitle, breakLegendTitleAt)
     # wrap annotation labels
     annoLabels <- word_wrap(annoLabels, breakAnnotationLabelsAt)
     # -----------------------------------------------------------
@@ -749,28 +829,29 @@ sjp.int <- function(fit,
       }
     }
     # ------------------------------------------------------------------------------------
-    # build plot object with theme and labels
-    # ------------------------------------------------------------------------------------
-    baseplot <- baseplot +
-      # set plot and axis titles
-      labs(title = labtitle, x = labx, y = laby) +
-      # set axis scale breaks
-      scale_x_continuous(limits = c(lowerLim.x, upperLim.x), breaks = gridbreaks.x) +
-      scale_y_continuous(limits = c(lowerLim.y, upperLim.y), breaks = gridbreaks.y)
-    # ------------------------------------------------------------------------------------
     # check whether only diff-line is shown or upper and lower boundaries. in the latter
     # case, show legend, else hide legend
     # ------------------------------------------------------------------------------------
     if (diff) {
       col.len <- 1
       lLabels <- NULL
+      lTitle <- NULL
     } else {
       if (moderatorValues == ""minmax"") {
         col.len <- 2
       } else {
         col.len <- 3
       }
     }
+    # ------------------------------------------------------------------------------------
+    # build plot object with theme and labels
+    # ------------------------------------------------------------------------------------
+    baseplot <- baseplot +
+      # set plot and axis titles
+      labs(title = labtitle, x = labx, y = laby, colour = lTitle) +
+      # set axis scale breaks
+      scale_x_continuous(limits = c(lowerLim.x, upperLim.x), breaks = gridbreaks.x) +
+      scale_y_continuous(limits = c(lowerLim.y, upperLim.y), breaks = gridbreaks.y)
     # ---------------------------------------------------------
     # set geom colors
     # ---------------------------------------------------------

---FILE: R/sjPlotSetTheme.R---
@@ -83,6 +83,8 @@
 #' @param legend.title.face Font face of the legend title. By default, \code{""bold""} face is used.
 #' @param legend.bordercol Color of the legend's border. Default is \code{""white""}, so no visible border is drawn.
 #' @param legend.backgroundcol Fill color of the legend's background. Default is \code{""white""}, so no visible background is drawn.
+#' @param legend.item.bordercol Color of the legend's item-border. Default is \code{""white""}.
+#' @param legend.item.backcol Fill color of the legend's item-background. Default is \code{""grey90""}.
 #' @param theme valid parameter for ggplot default-themes are:
 #'        \itemize{
 #'          \item \code{theme_bw}
@@ -237,6 +239,8 @@ sjp.setTheme <- function(title.color=""black"",
                          legend.title.face=""bold"",
                          legend.backgroundcol=""white"",
                          legend.bordercol=""white"",
+                         legend.item.backcol=""grey90"",
+                         legend.item.bordercol=""white"",
                          # base theme
                          theme=NULL,
                          base=theme_grey()) {
@@ -271,7 +275,7 @@ sjp.setTheme <- function(title.color=""black"",
     panel.major.gridcol <- g.palette[4]
     panel.minor.gridcol <- g.palette[2]
     axis.linecolor.x  <- axis.linecolor.y <- axis.linecolor <- g.palette[2]
-    legend.backgroundcol <- legend.bordercol <- g.palette[2]
+    legend.item.backcol <- legend.item.bordercol <- legend.backgroundcol <- legend.bordercol <- g.palette[2]
     title.color <- g.palette[9]
     axis.textcolor <- g.palette[6]
     axis.title.color <- g.palette[7]
@@ -298,7 +302,7 @@ sjp.setTheme <- function(title.color=""black"",
     if (is.null(axis.linecolor.y)) axis.linecolor.y <- g.palette[2]
     if (is.null(axis.linecolor.x)) axis.linecolor.x <- g.palette[9]
     panel.gridcol.x <- g.palette[2]
-    legend.backgroundcol <- legend.bordercol <- g.palette[2]
+    legend.item.backcol <- legend.item.bordercol <- legend.backgroundcol <- legend.bordercol <- g.palette[2]
     title.color <- g.palette[9]
     axis.textcolor <- g.palette[6]
     axis.title.color <- g.palette[7]
@@ -322,7 +326,7 @@ sjp.setTheme <- function(title.color=""black"",
     axis.linecolor <- g.palette[5]
     if (is.null(axis.linecolor.y)) axis.linecolor.y <- g.palette[2]
     if (is.null(axis.linecolor.x)) axis.linecolor.x <- g.palette[2]
-    legend.backgroundcol <- legend.bordercol <- g.palette[2]
+    legend.item.backcol <- legend.item.bordercol <- legend.backgroundcol <- legend.bordercol <- g.palette[2]
     title.color <- g.palette[9]
     axis.textcolor <- g.palette[6]
     axis.title.color <- g.palette[7]
@@ -349,7 +353,7 @@ sjp.setTheme <- function(title.color=""black"",
     axis.linecolor.y  <- g.palette[1]
     axis.linecolor.x <- g.palette[9]
     panel.gridcol.x <- g.palette[1]
-    legend.backgroundcol <- legend.bordercol <- g.palette[1]
+    legend.item.backcol <- legend.item.bordercol <- legend.backgroundcol <- legend.bordercol <- g.palette[1]
     title.color <- ""black""
     axis.textcolor <- g.palette[9]
     axis.title.color <- ""black""
@@ -376,7 +380,7 @@ sjp.setTheme <- function(title.color=""black"",
     axis.linecolor.y  <- g.palette[5]
     axis.linecolor.x <- g.palette[9]
     panel.gridcol.x <- g.palette[5]
-    legend.backgroundcol <- legend.bordercol <- g.palette[5]
+    legend.item.backcol <- legend.item.bordercol <- legend.backgroundcol <- legend.bordercol <- g.palette[5]
     title.color <- ""black""
     axis.textcolor <- g.palette[9]
     axis.title.color <- ""black""
@@ -543,6 +547,14 @@ sjp.setTheme <- function(title.color=""black"",
             legend.background = element_rect(colour = legend.bordercol, 
                                              fill = legend.backgroundcol))
     # ----------------------------------------
+    # set legend items background-color
+    # ----------------------------------------
+    if (!is.null(legend.item.backcol)) {
+      sjtheme <- sjtheme +
+        theme(legend.key = element_rect(colour = legend.item.bordercol, 
+                                        fill = legend.item.backcol))
+    }
+    # ----------------------------------------
     # set axis line colors, if defined
     # ----------------------------------------
     if (!is.null(axis.linecolor)) {

---FILE: R/sjRecode.R---
@@ -666,7 +666,7 @@ weight <- function(var, weights) {
 #' sjt.frq(data.frame(oldstring, newstring), removeStringVectors = FALSE, autoGroupStrings = FALSE)}
 #' 
 #' @export
-group_str <- function(strings, maxdist = 3, method = ""lv"", strict = FALSE, trim.whitespace = TRUE, remove.empty = TRUE, showProgressBar = FALSE) {
+group_str <- function(strings, maxdist = 2, method = ""lv"", strict = FALSE, trim.whitespace = TRUE, remove.empty = TRUE, showProgressBar = FALSE) {
   # -------------------------------------
   # check if required package is available
   # -------------------------------------
@@ -884,7 +884,7 @@ group_str <- function(strings, maxdist = 3, method = ""lv"", strict = FALSE, trim.
 #' str_pos(""We are Sex Pistols!"", ""postils"", part.dist.match = 1)}
 #' 
 #' @export
-str_pos <- function(searchString, findTerm, maxdist = 3, part.dist.match = 0, showProgressBar = FALSE) {
+str_pos <- function(searchString, findTerm, maxdist = 2, part.dist.match = 0, showProgressBar = FALSE) {
   # -------------------------------------
   # init return value
   # -------------------------------------

---FILE: README.md---
@@ -33,21 +33,27 @@ install.packages(""sjPlot"")
 
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since this package makes heavy use of the [ggplot-package](http://cran.r-project.org/web/packages/ggplot2/index.html), consider citing this package as well.
 
-### Changelog of current development build 1.7-4
+### Changelog of current development build 1.7-5
 
 #### General
-* Change R-Version dependency to R >= 3.1, due to import of `tidyr` and `dplyr` packages.
-* Improved internal management of imported data via `haven` and `foreign` packages, so users don't need to care of structure and classed of data read with either haven, foreing or sjPlot's read-functions.
+* R-Version dependency changed to R >= 3.1, due to import of `tidyr` and `dplyr` packages.
+* Improved internal management of imported data via `haven` and `foreign` packages, so users don't need to care of structure and classed of data read with either haven, foreign or sjPlot's read-functions.
 
 #### New functions
 * `cv` to compute coefficient of variance.
 * `rmse` to compute root-mean-square error.
 
 #### Changes to functions
 * `sjp.glm` now supports plotting `logistf` objects [(#issue 11)](https://github.com/sjPlot/devel/issues/11).
+* Added parameter `legendTitle` to `sjp.int`.
+* Added parameter `int.plot.index` to `sjp.int`, so only selected interaction terms may be plotted.
+* Parameter `legendLabels` of `sjp.int` now accepts a list of character vectors, with one vector of legend labels for each interaction plot plotted.
+* Parameter `title` of `sjp.int` now accepts a character vector of same length as interaction terms, with one title character string for each interaction plot plotted.
 * Added further pre-set themes to `sjp.setTheme`.
+* Minor improvements of `sjp.setTheme`.
 
 #### Bug fixes
+* `sjp.int` did not work for interaction terms of factors with more than two levels in mixed effects models (`merMod`-objects) - fixed.
 * Weights with decimals in `sjt.xtab` (e.g. `weightBy = abs(rnorm(100, 2, 1)`) caused an error - fixed.
 
 

---FILE: man/group_str.Rd---
@@ -4,7 +4,7 @@
 \alias{group_str}
 \title{Group near elements of string vectors}
 \usage{
-group_str(strings, maxdist = 3, method = ""lv"", strict = FALSE,
+group_str(strings, maxdist = 2, method = ""lv"", strict = FALSE,
   trim.whitespace = TRUE, remove.empty = TRUE, showProgressBar = FALSE)
 }
 \arguments{

---FILE: man/sjPlot-package.Rd---
@@ -38,8 +38,8 @@
 \tabular{ll}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.7-4\cr
-Date: \tab 2015-03-18\cr
+Version: \tab 1.7-5\cr
+Date: \tab 2015-03-19\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjp.int.Rd---
@@ -4,11 +4,12 @@
 \alias{sjp.int}
 \title{Plot interaction effects of (generalized) linear (mixed) models}
 \usage{
-sjp.int(fit, diff = FALSE, moderatorValues = ""minmax"",
-  swapPredictors = FALSE, plevel = 0.05, title = NULL,
-  fillColor = ""grey"", fillAlpha = 0.4, geom.colors = ""Set1"",
-  axisTitle.x = NULL, axisTitle.y = NULL, legendLabels = NULL,
-  showValueLabels = FALSE, breakTitleAt = 50, breakLegendLabelsAt = 20,
+sjp.int(fit, int.plot.index = NULL, diff = FALSE,
+  moderatorValues = ""minmax"", swapPredictors = FALSE, plevel = 0.05,
+  title = NULL, fillColor = ""grey"", fillAlpha = 0.4,
+  geom.colors = ""Set1"", axisTitle.x = NULL, axisTitle.y = NULL,
+  legendTitle = NULL, legendLabels = NULL, showValueLabels = FALSE,
+  breakTitleAt = 50, breakLegendLabelsAt = 20, breakLegendTitleAt = 20,
   breakAnnotationLabelsAt = 50, axisLimits.y = NULL, gridBreaksAt = NULL,
   showInterceptLines = FALSE, showInterceptLabels = TRUE,
   interceptLineColor = ""darkseagreen4"", estLineColor = ""darkslategray4"",
@@ -25,6 +26,11 @@ classes are
   \item generalized linear mixed effects models (\code{lme4::glmer})
   }}
 
+\item{int.plot.index}{A numeric vector with index numbers that indicate which
+interaction terms should be plotted in case the \code{fit} has more than
+one interaction. By default, this values is \code{NULL}, hence all interactions
+are plotted.}
+
 \item{diff}{if \code{FALSE} (default), the minimum and maximum interaction effects of predictor 2 on predictor 1
 are shown (one line each). if \code{TRUE}, only the difference between minimum and maximum interaction effect
 is shown (single line)}
@@ -44,7 +50,8 @@ as values of the moderator, see \href{http://www.theanalysisfactor.com/3-tips-in
 \item{plevel}{Indicates at which p-value an interaction term is considered as significant. Default is
 0.05 (5 percent).}
 
-\item{title}{a default title used for the plots. Default value is \code{NULL}, which means that each plot's title
+\item{title}{a default title used for the plots. Should be a character vector
+of same length as interaction plots to be plotted. Default value is \code{NULL}, which means that each plot's title
 includes the dependent variable as well as the names of the interaction terms.}
 
 \item{fillColor}{fill color of the shaded area between the minimum and maximum lines. Default is \code{""grey""}.
@@ -60,14 +67,22 @@ mean value of the interaction term (moderator value). Third value is only used w
 is \code{""meansd""}. Or, if \code{diff} is \code{TRUE}, only one color value for the line indicating the
 upper difference between lower and upper bound of interaction terms.}
 
-\item{axisTitle.x}{a default title used for the x-axis. Default value is \code{NULL},
+\item{axisTitle.x}{a default title used for the x-axis. Should be a character vector
+of same length as interaction plots to be plotted. Default value is \code{NULL},
 which means that each plot's x-axis uses the predictor's name as title.}
 
 \item{axisTitle.y}{a default title used for the y-axis. Default value is \code{NULL},
 which means that each plot's y-axis uses the dependent variable's name as title.}
 
-\item{legendLabels}{Labels for the guide/legend. Default is \code{NULL}, so the name of the predictor with
-min/max-effect is used as legend label.}
+\item{legendTitle}{Title of the diagram's legend. A character vector of same length as
+amount of interaction plots to be plotted (i.e. one vector element for each
+plot's legend title).}
+
+\item{legendLabels}{Labels for the guide/legend. Either a character vector of same length as
+amount of legend labels of the plot, or a \code{list} of character vectors, if more than one
+interaction plot is plotted (i.e. one vector of legend labels for each interaction plot).
+Default is \code{NULL}, so the name of the predictor with min/max-effect is used
+as legend label.}
 
 \item{showValueLabels}{if \code{TRUE}, value labels are plotted along the lines. Default is \code{FALSE}.}
 
@@ -77,6 +92,9 @@ displayed in one line and when a line break is inserted. Default is \code{50}.}
 \item{breakLegendLabelsAt}{Wordwrap for diagram legend labels. Determines how many chars of the legend labels are
 displayed in one line and when a line break is inserted. Default is \code{20}.}
 
+\item{breakLegendTitleAt}{Wordwrap for diagram legend title. Determines how many chars of the legend's title
+are displayed in one line and when a line break is inserted.}
+
 \item{breakAnnotationLabelsAt}{Wordwrap for diagram annotation labels. Determines how many chars of the legend labels are
 displayed in one line and when a line break is inserted. Default is \code{50}.
 Only applies if \code{showInterceptLine} is \code{TRUE}.}

---FILE: man/sjp.setTheme.Rd---
@@ -26,6 +26,7 @@ sjp.setTheme(title.color = ""black"", title.size = 1.3,
   legend.color = ""black"", legend.title.size = 1,
   legend.title.color = ""black"", legend.title.face = ""bold"",
   legend.backgroundcol = ""white"", legend.bordercol = ""white"",
+  legend.item.backcol = ""grey90"", legend.item.bordercol = ""white"",
   theme = NULL, base = theme_grey())
 }
 \arguments{
@@ -163,6 +164,10 @@ legend justification is set according to legend position.}
 
 \item{legend.bordercol}{Color of the legend's border. Default is \code{""white""}, so no visible border is drawn.}
 
+\item{legend.item.backcol}{Fill color of the legend's item-background. Default is \code{""grey90""}.}
+
+\item{legend.item.bordercol}{Color of the legend's item-border. Default is \code{""white""}.}
+
 \item{theme}{valid parameter for ggplot default-themes are:
 \itemize{
   \item \code{theme_bw}

---FILE: man/str_pos.Rd---
@@ -4,7 +4,7 @@
 \alias{str_pos}
 \title{Find partial matching and close distance elements in strings}
 \usage{
-str_pos(searchString, findTerm, maxdist = 3, part.dist.match = 0,
+str_pos(searchString, findTerm, maxdist = 2, part.dist.match = 0,
   showProgressBar = FALSE)
 }
 \arguments{"
strengejacke,sjPlot,46218c4e54d938c893c731f9724150e9233c3e92,Daniel Ldecke,d.luedecke@uke.de,2015-03-12T18:39:41Z,Daniel Ldecke,d.luedecke@uke.de,2015-03-12T18:39:41Z,"fixed bug in sjt.xtab, added logistf-support to sjp.glm",DESCRIPTION;NAMESPACE;NEWS;R/sjPlotGLME.R;R/sjPlotOdds.R;R/sjPlotSetTheme.R;README.md;man/sjPlot-package.Rd;man/sjp.glm.Rd,False,True,True,False,58,31,89,"---FILE: DESCRIPTION---
@@ -2,31 +2,33 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.7-1
-Date: 2015-03-11
+Version: 1.7-2
+Date: 2015-03-12
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of several plotting and table output functions for
     visualizing data, and utility functions.
 License: GPL-3
+Depends:
+    R(>= 3.1.0)
 Imports:
-    ggplot2,
-    MASS,
+    arm,
     car,
+    dplyr (>= 0.4.1),
     foreign,
+    ggplot2,
+    lme4,
+    MASS,
     psych,
     scales,
-    dplyr (>= 0.4.1),
     tidyr (>= 0.2.0)
 Suggests:
-    arm,
     cluster,
     coin,
-    lme4,
-    lsmeans,
+    haven,
     lmtest,
+    lsmeans,
     Matrix,
-    stringdist,
-    haven
+    stringdist
 URL: https://github.com/sjPlot/devel
 BugReports: https://github.com/sjPlot/devel/issues

---FILE: NAMESPACE---
@@ -79,9 +79,11 @@ export(write_spss)
 export(write_stata)
 import(dplyr)
 import(ggplot2)
+import(lme4)
 import(tidyr)
 importFrom(MASS,lda)
 importFrom(MASS,loglm)
+importFrom(arm,se.ranef)
 importFrom(car,crPlots)
 importFrom(car,durbinWatsonTest)
 importFrom(car,influencePlot)

---FILE: NEWS---
@@ -1,5 +1,11 @@
-Version 1.7-1
+Version 1.7-2
 ------------------------------------------------------------------------------
+General:
+* Change R-Version dependency to R >= 3.1, due to import of ""tidyr"" and ""haven"" packages.
+
+Changes to functions:
+* ""sjp.glm"" now supports plotting ""logistf"" objects.
+
 Bug fixes:
 * Weights with decimals in `sjt.xtab` (e.g. `weightBy = abs(rnorm(100, 2, 1)`) caused an error - fixed.
 

---FILE: R/sjPlotGLME.R---
@@ -171,6 +171,8 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""nQQ"", ""ci"", ""fixef"", ""fa
 #'           vars = ""neg_c_7"")}
 #'
 #' @import ggplot2
+#' @import lme4
+#' @importFrom arm se.ranef
 #' @export
 sjp.glmer <- function(fit,
                       type = ""re"",
@@ -382,6 +384,8 @@ sjp.glmer <- function(fit,
 #' sjp.lmer(fit, type = ""re.qq"")}
 #'
 #' @import ggplot2
+#' @import lme4
+#' @importFrom arm se.ranef
 #' @export
 sjp.lmer <- function(fit,
                      type = ""re"",
@@ -471,18 +475,6 @@ sjp.lme4  <- function(fit,
     warning(""'type' must be one of 're', 'fe', 'fe.cor', 're.qq', 'fe.ri', 'fe.pc', 'ri.pc', 'fe.std', 'fe.prob' or 'ri.prob'. Defaulting to 'fe' now."")
     type  <- ""fe""
   }
-  # -------------------------------------
-  # check if required package is available
-  # -------------------------------------
-  if (!requireNamespace(""lme4"", quietly = TRUE)) {
-    stop(""Package 'lme4' needed for this function to work. Please install it."", call. = FALSE)
-  }
-  if (!requireNamespace(""Matrix"", quietly = TRUE)) {
-    stop(""Package 'Matrix' needed for this function to work. Please install it."", call. = FALSE)
-  }
-  if (!requireNamespace(""arm"", quietly = TRUE)) {
-    stop(""Package 'arm' needed for this function to work. Please install it."", call. = FALSE)
-  }
   # ---------------------------------------
   # for standardized coefficients, intercept
   # is always 0, so no need to be shown

---FILE: R/sjPlotOdds.R---
@@ -19,7 +19,7 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""OR"", ""lower"", ""upper"", ""
 #'
 #' @note Based on the script from \href{http://www.surefoss.org/dataanalysis/plotting-odds-ratios-aka-a-forrestplot-with-ggplot2/}{surefoss}
 #'
-#' @param fit The fitted model of a logistic regression (or any other \code{\link{glm}}-object).
+#' @param fit The fitted model of a logistic regression (or any other \code{\link{glm}}- or \code{logistf}-object).
 #' @param type type of plot. Use one of following:
 #'          \itemize{
 #'            \item \code{""dots""}, \code{""glm""} or \code{""or""} (default) for odds ratios (forest plot)
@@ -185,6 +185,20 @@ sjp.glm <- function(fit,
                     showOriginalModelOnly=TRUE,
                     printPlot=TRUE) {
   # --------------------------------------------------------
+  # check param
+  # --------------------------------------------------------
+  if (class(fit) == ""logistf"") {
+    # no model summary currently supported for logistf class
+    showModelSummary = FALSE
+    # create ""dummy"" variable, to avoid errors
+    fit$model <- fit$data
+    # no probability curves currently supported
+    if (type == ""prob"" || type == ""pc"") {
+      warning(""Predicted probability plots currently not supported for 'logistf' objects."", call. = F)
+      type <- ""dots""
+    }
+  }
+  # --------------------------------------------------------
   # check type
   # --------------------------------------------------------
   if (type == ""prob"" || type == ""pc"") {
@@ -234,7 +248,12 @@ sjp.glm <- function(fit,
   # print p-values in bar charts
   # ----------------------------
   # retrieve sigificance level of independent variables (p-values)
-  pv <- coef(summary(fit))[,4]
+  if (class(fit) == ""logistf"") {
+    pv <- fit$prob
+  }
+  else {
+    pv <- coef(summary(fit))[,4]
+  }
   # for better readability, convert p-values to asterisks
   # with:
   # p < 0.001 = ***

---FILE: R/sjPlotSetTheme.R---
@@ -290,8 +290,8 @@ sjp.setTheme <- function(title.color=""black"",
     panel.major.gridcol <- g.palette[4]
     panel.minor.gridcol <- g.palette[2]
     axis.linecolor <- NULL
-    axis.linecolor.y  <- g.palette[2]
-    axis.linecolor.x <- g.palette[9]
+    if (is.null(axis.linecolor.y)) axis.linecolor.y <- g.palette[2]
+    if (is.null(axis.linecolor.x)) axis.linecolor.x <- g.palette[9]
     panel.gridcol.x <- g.palette[2]
     legend.backgroundcol <- legend.bordercol <- g.palette[2]
     title.color <- g.palette[9]

---FILE: README.md---
@@ -33,7 +33,13 @@ install.packages(""sjPlot"")
 
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since this package makes heavy use of the [ggplot-package](http://cran.r-project.org/web/packages/ggplot2/index.html), consider citing this package as well.
 
-### Changelog of current development build 1.7-1
+### Changelog of current development build 1.7-2
+
+#### General
+* Change R-Version dependency to R >= 3.1, due to import of `tidyr` and `haven` packages.
+
+#### Changes to functions
+* `sjp.glm` now supports plotting `logistf` objects.
 
 #### Bug fixes
 * Weights with decimals in `sjt.xtab` (e.g. `weightBy = abs(rnorm(100, 2, 1)`) caused an error - fixed.

---FILE: man/sjPlot-package.Rd---
@@ -38,8 +38,8 @@
 \tabular{ll}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.7-1\cr
-Date: \tab 2015-03-11\cr
+Version: \tab 1.7-2\cr
+Date: \tab 2015-03-12\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjp.glm.Rd---
@@ -15,7 +15,7 @@ sjp.glm(fit, type = ""dots"", sortOdds = TRUE, title = NULL,
   show.se = FALSE, showOriginalModelOnly = TRUE, printPlot = TRUE)
 }
 \arguments{
-\item{fit}{The fitted model of a logistic regression (or any other \code{\link{glm}}-object).}
+\item{fit}{The fitted model of a logistic regression (or any other \code{\link{glm}}- or \code{logistf}-object).}
 
 \item{type}{type of plot. Use one of following:
 \itemize{"
strengejacke,sjPlot,6bf5201cd546f6ee634c370a0649f186236c093b,Daniel Ldecke,d.luedecke@uke.de,2015-03-09T22:03:50Z,Daniel Ldecke,d.luedecke@uke.de,2015-03-09T22:03:50Z,minor changes / fixes,R/helpfunctions.R;R/sjPlotScatter.R;man/sjp.scatter.Rd;man/to_sjPlot.Rd,False,True,True,False,14,5,19,"---FILE: R/helpfunctions.R---
@@ -351,15 +351,15 @@ crosstabsum <- function(ftab) {
                         c2 = sprintf(""%.2f"", chsq$statistic),
                         dft = c(chsq$parameter),
                         kook = sprintf(""%.2f"", phi(ftab)),
-                        pva = sprintf(""%.3f"", chsq$p.value)))))
+                        pva = sub(""0"", p_zero, sprintf(""%.3f"", chsq$p.value))))))
     }
     else {
       modsum <- as.character(as.expression(
         substitute(""N"" == tn * "","" ~~ ""df"" == dft * "","" ~~ phi == kook * "","" ~~ ""Fisher's p"" == pva,
                    list(tn = summary(ftab)$n.cases,
                         dft = c(chsq$parameter),
                         kook = sprintf(""%.2f"", phi(ftab)),
-                        pva = sprintf(""%.3f"", fish$p.value)))))
+                        pva = sub(""0"", p_zero, sprintf(""%.3f"", fish$p.value))))))
     }
   }  
   return (modsum)

---FILE: R/sjPlotScatter.R---
@@ -112,6 +112,11 @@
 #' # auto-detection of labels
 #' # -------------------------------
 #' efc <- set_var_labels(efc, get_var_labels(efc))
+#' 
+#' # show axis titles
+#' sjp.scatter(efc$c160age,efc$e17age, efc$e42dep)
+#'             
+#' # hide axis titles
 #' sjp.scatter(efc$c160age,efc$e17age, efc$e42dep,
 #'             title="""", axisTitle.x="""", axisTitle.y="""")
 #' 
@@ -152,10 +157,10 @@ sjp.scatter <- function(x=NULL,
     stop(""At least either 'x' or 'y' must be specified."", call. = FALSE)
   }
   if (is.null(x)) {
-    x <- c(1 : length(y))
+    x <- c(1:length(y))
   }
   if (is.null(y)) {
-    y <- c(1 : length(x))
+    y <- c(1:length(x))
   }
   # --------------------------------------------------------
   # try to automatically set labels is not passed as parameter

---FILE: man/sjp.scatter.Rd---
@@ -150,6 +150,11 @@ sjp.scatter(y = fit$residuals, showTotalFitLine = TRUE)
 # auto-detection of labels
 # -------------------------------
 efc <- set_var_labels(efc, get_var_labels(efc))
+
+# show axis titles
+sjp.scatter(efc$c160age,efc$e17age, efc$e42dep)
+
+# hide axis titles
 sjp.scatter(efc$c160age,efc$e17age, efc$e42dep,
             title="""", axisTitle.x="""", axisTitle.y="""")
 }

---FILE: man/to_sjPlot.Rd---
@@ -28,7 +28,6 @@ This function converts
 \seealso{
 \itemize{
            \item \href{http://www.strengejacke.de/sjPlot/datainit/}{sjPlot manual: data initialization}
-           \item \code{\link{to_haven}}
            }
 }
 "
strengejacke,sjPlot,a0165ca295295f426a2b728c84b108782e4b2f40,Daniel Ldecke,d.luedecke@uke.de,2015-03-09T18:11:24Z,Daniel Ldecke,d.luedecke@uke.de,2015-03-09T18:11:24Z,various minor fixes and improvements,DESCRIPTION;NEWS;R/sjImportSPSS.R;R/sjPlotAnova.R;R/sjPlotClusterAnalysis.R;R/sjPlotFrequencies.R;R/sjPlotGroupFrequencies.R;R/sjPlotLinreg.R;R/sjPlotLinregMultiple.R;R/sjPlotOdds.R;R/sjPlotOddsMultiple.R;R/sjRecode.R;R/sjTabLinReg.R;R/sjTabOdds.R;R/sjTabPropTable.R;R/sjTabSPSS.R;README.md;man/dicho.Rd;man/sjPlot-package.Rd;man/sjc.qclus.Rd;man/sjp.aov1.Rd;man/sjp.frq.Rd;man/sjp.glm.Rd;man/sjp.glmm.Rd;man/sjp.grpfrq.Rd;man/sjp.lm.Rd;man/sjp.lmm.Rd;man/to_sjPlot.Rd,False,True,True,False,91,78,169,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.6.9-11
-Date: 2015-03-07
+Version: 1.6.9-12
+Date: 2015-03-09
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of several plotting and table output functions for

---FILE: NEWS---
@@ -2,10 +2,10 @@ Version 1.6.9-12
 ------------------------------------------------------------------------------
 General:
 * Renamed sjs, sju, sjd and sji-functions into more intuitiv and shorter function names.
-* ""autoSetValueLabels"" and ""autoSetVariableLabels"" are now global options. E.g., use ""options(autoSetValueLabels = FALSE)"" to turn off automatic value label detection in plotting and table functions, or ""options(autoSetValueLabels = TRUE)"" to turn on automatic label detection.
-* ""p_zero"" is now global options. Use ""options(p_zero = TRUE)"" to show leading zero before period in p-value, r-quared and phi labels.
-* ""read_spss"" is now global options. Use ""options(read_spss = 'haven')"" to set default package for readind spss data to haven, or ""options(read_spss = 'foreign')"" to make ""read_spss"" use the foreign package to read spss data.
-* ""value_labels"" is now global options. Use ""options(value_labels = 'haven')"" to set default attribute assignment in haven format (""labels"" and ""label""), or ""options(value_labels = 'foreign')"" to to set default attribute assignment in foreign format (""value.labels"" and ""variable.label""). Affects functions like auto-detection of labels, ""set_var_labels""or ""set_val_labels"" etc.
+* ""autoSetValueLabels"" and ""autoSetVariableLabels"" are now a global option. E.g., use ""options(autoSetValueLabels = FALSE)"" to turn off automatic value label detection in plotting and table functions, or ""options(autoSetValueLabels = TRUE)"" to turn on automatic label detection.
+* ""p_zero"" is now a global option. Use ""options(p_zero = TRUE)"" to show leading zero before period in p-value, r-quared and phi labels.
+* ""read_spss"" is now a global option. Use ""options(read_spss = 'haven')"" to set default package for readind spss data to haven, or ""options(read_spss = 'foreign')"" to make ""read_spss"" use the foreign package to read spss data.
+* ""value_labels"" is now a global option. Use ""options(value_labels = 'haven')"" to set default attribute assignment in haven format (""labels"" and ""label""), or ""options(value_labels = 'foreign')"" to to set default attribute assignment in foreign format (""value.labels"" and ""variable.label""). Affects functions like auto-detection of labels, ""set_var_labels""or ""set_val_labels"" etc.
 * Removed ""plyr"" import and replaced with ""dplyr"" functions.
 * Removed ""reshape2"" import and replaced with ""tidyr"" functions.
 

---FILE: R/sjImportSPSS.R---
@@ -319,6 +319,11 @@ write_data <- function(x, path, type = ""spss"") {
 # this function returns TRUE, if a vector is
 # of class ""labelled"" (haven package)
 is_labelled <- function(x) {
+  # check if object has multiple class attributes
+  if (length(class(x)) > 1) {
+    return (any(class(x) == ""labelled""))
+  }
+  # return if labelled
   return (class(x) == ""labelled"")
 }
 
@@ -386,32 +391,27 @@ sji.toSjPlot <- function(x, var.name = NULL) {
     val.lab <- unname(attr(x, ""labels""))
     val.lab.names <- names(attr(x, ""labels""))
     # delete old attributes
-    attr(x, ""label"") <- NULL
-    names(attr(x, ""labels"")) <- NULL
-    attr(x, ""labels"") <- NULL
+    x <- as.vector(x)
     # set back labels
     x <- sji.setValueLabelNameParam(x, val.lab.names, var.name)
     x <- set_var_labels(x, var.lab)
     # remove labelled class attribute
-    class(x) <- NULL
+    x <- unclass(x)
   }
   else {
-    # read current labels
+    # read current variable label
     var.lab <- attr(x, ""label"")
-    # do we have any?
+    # read current value labels
+    val.lab <- unname(attr(x, ""labels""))
+    val.lab.names <- names(attr(x, ""labels""))
+    # delete old attributes
+    x <- as.vector(x)
+    # do we have any attributes?
     if (!is.null(var.lab)) {
-      # delete old attributes
-      attr(x, ""label"") <- NULL
       # set back labels
       x <- set_var_labels(x, var.lab)
     }
-    # read current labels
-    val.lab <- unname(attr(x, ""labels""))
     if (!is.null(val.lab)) {
-      val.lab.names <- names(attr(x, ""labels""))
-      # delete old attributes
-      names(attr(x, ""labels"")) <- NULL
-      attr(x, ""labels"") <- NULL
       # set back labels
       x <- sji.setValueLabelNameParam(x, val.lab.names, var.name)
     }
@@ -1044,16 +1044,28 @@ to_fac <- function(x) {
 #' 
 #' @export
 to_value <- function(x, startAt = 1, keep.labels = TRUE) {
-  # get amount of categories
-  l <- length(levels(x))
-  # determine highest category value
-  end <- startAt+l-1
   # retrieve ""value labels""
   labels <- levels(x)
-  # replace labels with numeric values
-  levels(x) <- c(startAt:end)
-  # convert to numeric
-  new_value <- as.numeric(as.character(x))
+  # check if we have numeric factor levels
+  if (is_num_fac(x)) {
+    # convert to numeric via as.vector
+    new_value <- as.numeric(as.vector((x)))
+    # check if lowest value of variable differs from
+    # requested minimum conversion value
+    val_diff <- startAt - min(new_value, na.rm = T)
+    # adjust new_value
+    new_value <- new_value + val_diff
+  }
+  else {
+    # get amount of categories
+    l <- length(levels(x))
+    # determine highest category value
+    end <- startAt+l-1
+    # replace labels with numeric values
+    levels(x) <- c(startAt:end)
+    # convert to numeric
+    new_value <- as.numeric(as.character(x))
+  }
   # check if we should attach former labels as value labels
   if (keep.labels) new_value <- set_val_labels(new_value, labels)
   return (new_value)

---FILE: R/sjPlotAnova.R---
@@ -34,8 +34,8 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""pv""))
 #'          grouping variable axis. Passed as vector of strings.
 #'          Example: \code{axisLabels.y=c(""Label1"", ""Label2"", ""Label3"")}. \cr
 #'          Note: If you use the \code{\link{read_spss}} function and the \code{\link{get_val_labels}} function, you receive a
-#'          list object with label string. The labels may also be passed as list object. They will be unlisted and
-#'          converted to character vector automatically. See examples below. \cr
+#'          list object with label string. The labels may also be passed as list object. They will be coerced
+#'          to character vector automatically. See examples below. \cr
 #'          Note: In case \code{type} is \code{""bars""}, the \code{grpVar} will be plotted along
 #'          the x-axis.
 #' @param reverseOrder If \code{TRUE}, the order of the factor categories (groups) is reversed.

---FILE: R/sjPlotClusterAnalysis.R---
@@ -65,8 +65,8 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""xpos"", ""value"", ""Var2"",
 #' @param axisLabels.x Labels for the x-axis breaks.
 #'          Example: \code{axisLabels.x=c(""Label1"", ""Label2"", ""Label3"")}.
 #'          Note: If you use the \code{\link{read_spss}} function and the \code{\link{get_val_labels}} function, you receive a
-#'          list object with label string. The labels may also be passed as list object. They will be unlisted and
-#'          converted to character vector automatically.
+#'          list object with label string. The labels may also be passed as list object. They will be coerced
+#'          to character vector automatically.
 #' @param axisTitle.x A label for the x axis. useful when plotting histograms with metric scales where no category labels
 #'          are assigned to the x axis.
 #' @param axisTitle.y A label for the y axis. useful when plotting histograms with metric scales where no category labels

---FILE: R/sjPlotFrequencies.R---
@@ -29,8 +29,8 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""frq"", ""grp"", ""upper.ci"",
 #' @param interactionVar An interaction variable which can be used for box plots. Divides the observations in 
 #'          \code{varCount} into the factors (sub groups) of \code{interactionVar}. Only applies when parameter \code{""type""}
 #'          is \code{""box""} or \code{""violin""} (resp. their alternative strings like \code{""boxplot""}, \code{""boxplots""} or \code{""v""}).
-#' @param sort.frq Determines whether categories on x-axis should be order according to the frequencies or not. 
-#'          Default is \code{""none""}, so categories are not ordered by frequency. Use \code{""asc""} or
+#' @param sort.frq Determines whether categories on x-axis should be sorted according to the frequencies or not. 
+#'          Default is \code{""none""}, so categories are not sorted by frequency. Use \code{""asc""} or
 #'          \code{""desc""} for sorting categories ascending or descending in relation to the frequencies.
 #' @param type Specifies the type of distribution plot that will be plotted.
 #'          \itemize{
@@ -49,8 +49,8 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""frq"", ""grp"", ""upper.ci"",
 #' @param axisLabels.x Labels for the x-axis breaks.
 #'          Example: \code{axisLabels.x=c(""Label1"", ""Label2"", ""Label3"")}.
 #'          Note: If you use the \code{\link{read_spss}} function and the \code{\link{get_val_labels}} function, you receive a
-#'          list object with label string. The labels may also be passed as list object. They will be unlisted and
-#'          converted to character vector automatically.
+#'          list object with label string. The labels may also be passed as list object. They will be coerced
+#'          to character vector automatically.
 #' @param interactionVarLabels Labels for the x-axis breaks when having interaction variables included.
 #'          These labels replace the \code{axisLabels.x}. Only applies, when using box or violin plots
 #'          (i.e. \code{""type""} is \code{""box""} or \code{""violin""}) and \code{interactionVar} is not \code{NULL}.

---FILE: R/sjPlotGroupFrequencies.R---
@@ -56,8 +56,8 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""ypos"", ""wb"", ""ia"", ""mw"",
 #'          (see examples below). Else, specifiy parameter like this:
 #'          \code{axisLabels.x=c(""Label1"", ""Label2"", ""Label3"")}.
 #'          Note: If you use the \code{\link{read_spss}} function and the \code{\link{get_val_labels}} function, you receive a
-#'          list object with label string. The labels may also be passed as list object. They will be unlisted and
-#'          converted to character vector automatically.
+#'          list object with label string. The labels may also be passed as list object. They will be coerced
+#'          to character vector automatically.
 #' @param interactionVarLabels Labels for the x-axis breaks when having interaction variables included.
 #'          These labels replace the \code{axisLabels.x}. Only applies, when using box or violin plots
 #'          (i.e. \code{""type""} is \code{""box""} or \code{""violin""}) and \code{interactionVar} is not \code{NULL}.

---FILE: R/sjPlotLinreg.R---
@@ -46,8 +46,8 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""vars"", ""Beta"", ""xv"", ""lo
 #'          axis. Passed as vector of strings.
 #'          Example: \code{axisLabels.y=c(""Label1"", ""Label2"", ""Label3"")}.
 #'          Note: If you use the \code{\link{read_spss}} function and the \code{\link{get_val_labels}} function, you receive a
-#'          list object with label string. The labels may also be passed as list object. They will be unlisted and
-#'          converted to character vector automatically.
+#'          list object with label string. The labels may also be passed as list object. They will be coerced
+#'          to character vector automatically.
 #' @param showAxisLabels.y Whether x axis text (category names, predictor labels) should be shown (use \code{TRUE})
 #'          or not. Default is \code{TRUE}
 #' @param axisTitle.x A label for the x axis. Default is \code{""Estimates""}.

---FILE: R/sjPlotLinregMultiple.R---
@@ -29,8 +29,8 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""beta"", ""lower"", ""upper"",
 #'          axis. Passed as vector of strings.
 #'          Example: \code{axisLabels.y=c(""Label1"", ""Label2"", ""Label3"")}
 #'          Note: If you use the \code{\link{read_spss}} function and the \code{\link{get_val_labels}} function, you receive a
-#'          \code{list} object with label strings. The labels may also be passed as list object. They will be unlisted and
-#'          converted to character vector automatically.
+#'          \code{list} object with label strings. The labels may also be passed as list object. They will be coerced
+#'          to character vector automatically.
 #' @param showAxisLabels.y Whether beta names (predictor labels) should be shown or not.
 #' @param axisTitle.x A label (""title"") for the x axis.
 #' @param axisLimits Defines the range of the axis where the beta coefficients and their confidence intervalls

---FILE: R/sjPlotOdds.R---
@@ -36,8 +36,8 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""OR"", ""lower"", ""upper"", ""
 #'          axis. Passed as vector of strings.
 #'          Example: \code{axisLabels.y=c(""Label1"", ""Label2"", ""Label3"")}
 #'          Note: If you use the \code{\link{read_spss}} function and the \code{\link{get_val_labels}} function, you receive a
-#'          \code{list} object with label string. The labels may also be passed as list object. They will be unlisted and
-#'          converted to character vector automatically.
+#'          \code{list} object with label string. The labels may also be passed as list object. They will be coerced
+#'          to character vector automatically.
 #' @param showAxisLabels.y Whether odds names (predictor labels) should be shown or not.
 #' @param axisTitle.x A label (""title"") for the x axis.
 #' @param axisLimits Defines the range of the axis where the beta coefficients and their confidence intervalls

---FILE: R/sjPlotOddsMultiple.R---
@@ -28,8 +28,8 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""OR"", ""lower"", ""upper"", ""
 #'          axis. Passed as vector of strings.
 #'          Example: \code{axisLabels.y=c(""Label1"", ""Label2"", ""Label3"")}
 #'          Note: If you use the \code{\link{read_spss}} function and the \code{\link{get_val_labels}} function, you receive a
-#'          \code{list} object with label strings. The labels may also be passed as list object. They will be unlisted and
-#'          converted to character vector automatically.
+#'          \code{list} object with label strings. The labels may also be passed as list object. They will be coerced
+#'          to character vector automatically.
 #' @param showAxisLabels.y Whether odds names (predictor labels) should be shown or not.
 #' @param axisTitle.x A label (""title"") for the x axis.
 #' @param axisLimits Defines the range of the axis where the beta coefficients and their confidence intervalls

---FILE: R/sjRecode.R---
@@ -16,7 +16,7 @@
 #'          into one group with values from lowest to 10 and another group with values greater
 #'          than 10.
 #' @param asNum logical, if \code{TRUE}, return value will be numeric, not a factor.
-#' @return A dichotomized factor (or numeric, if \code{asNum = TRUE} variable (0/1-coded).
+#' @return A dichotomized factor (or numeric, if \code{asNum = TRUE}) variable (0/1-coded).
 #' 
 #' @examples
 #' data(efc)

---FILE: R/sjTabLinReg.R---
@@ -596,7 +596,7 @@ sjt.lm <- function (...,
       fit.df$pv <- sapply(fit.df$pv, function(x) {
         if (x <0.05) {
           if (x < 0.001) {
-            x <- sprintf(""%s&lt;%s.001%s"", p_zero, sb1, sb2)
+            x <- sprintf(""%s&lt;0.001%s"", sb1, sb2)
           }
           else {
             x <- sprintf(""%s%.*f%s"", sb1, digits.p, x, sb2)

---FILE: R/sjTabOdds.R---
@@ -514,7 +514,7 @@ sjt.glm <- function (...,
       fit.df$pv <- sapply(fit.df$pv, function(x) {
         if (x <0.05) {
           if (x < 0.001) {
-            x <- sprintf(""%s&lt;%s.001%s"", p_zero, sb1, sb2)
+            x <- sprintf(""%s&lt;0.001%s"", sb1, sb2)
           }
           else {
             x <- sprintf(""%s%.*f%s"", sb1, digits.p, x, sb2)

---FILE: R/sjTabPropTable.R---
@@ -763,7 +763,7 @@ sjt.xtab <- function (var.row,
     kook <- gsub(""0."", paste0(""."", p_zero), kook, fixed = TRUE)
     # create summary row
     if (is.null(fish)) {
-      pvalstring <- ifelse(chsq$p.value < 0.001, sprintf(""p&lt;%s.001"", p_zero) , sub(""0"", p_zero, sprintf(""p=%.3f"", chsq$p.value)))
+      pvalstring <- ifelse(chsq$p.value < 0.001, sprintf(""p&lt;%s.001"", p_zero), sub(""0"", p_zero, sprintf(""p=%.3f"", chsq$p.value)))
       page.content <- paste(page.content, sprintf(""    <td class=\""summary tdata\"" colspan=\""%i\"">&Chi;<sup>2</sup>=%.3f &middot; df=%i &middot; %s &middot; %s</td>"", totalncol, chsq$statistic, chsq$parameter, kook, pvalstring), sep="""")
     }
     else {

---FILE: R/sjTabSPSS.R---
@@ -228,7 +228,7 @@ view_spss <- function (df,
       page.content <- paste0(page.content, sprintf(""    <td class=\""tdata%s\"">%s</td>\n"", arcstring, vartype))
     }
     # label
-    if (index<=length(df.var)) {
+    if (index <= length(df.var)) {
       varlab <- df.var[index]
       if (!is.null(breakVariableNamesAt)) {
         # wrap long variable labels
@@ -241,12 +241,12 @@ view_spss <- function (df,
     page.content <- paste0(page.content, sprintf(""    <td class=\""tdata%s\"">%s</td>\n"", arcstring, varlab))
     # values
     if (showValues) {
-      if (index<=ncol(df)) {
+      if (index <= ncol(df)) {
         vals <- sji.getValueLabelValues(df[[index]])
         valstring <- c("""")
         for (i in 1:length(vals)) {
           valstring <- paste0(valstring, vals[i])
-          if (i<length(vals)) valstring <- paste0(valstring, ""<br>"")
+          if (i < length(vals)) valstring <- paste0(valstring, ""<br>"")
         }
       }
       else {

---FILE: README.md---
@@ -37,10 +37,10 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 
 #### General
 * Renamed `sjs`, `sju`, `sjd` and `sji`-functions into more intuitiv and shorter function names.
-* `autoSetValueLabels` and `autoSetVariableLabels` are now global options. E.g., use `options(autoSetValueLabels = FALSE)` to turn off automatic value label detection in plotting and table functions, or `options(autoSetValueLabels = TRUE)` to turn on automatic label detection.
-* `p_zero` is now global options. Use `options(p_zero = TRUE)` to show leading zero before period in p-value, r-quared and phi labels.
-* `read_spss` is now global options. Use `options(read_spss = 'haven')` to set default package for readind spss data to haven, or `options(read_spss = 'foreign')` to make `read_spss` use the foreign package to read spss data.
-* `value_labels` is now global options. Use `options(value_labels = 'haven')` to set default attribute assignment in haven format (`labels` and `label`), or `options(value_labels = 'foreign')` to to set default attribute assignment in foreign format (`value.labels` and `variable.label`). Affects functions like auto-detection of labels, `set_var_labels` or `set_val_labels` etc.
+* `autoSetValueLabels` and `autoSetVariableLabels` are now a global option. E.g., use `options(autoSetValueLabels = FALSE)` to turn off automatic value label detection in plotting and table functions, or `options(autoSetValueLabels = TRUE)` to turn on automatic label detection.
+* `p_zero` is now a global option. Use `options(p_zero = TRUE)` to show leading zero before period in p-value, r-quared and phi labels.
+* `read_spss` is now a global option. Use `options(read_spss = 'haven')` to set default package for readind spss data to haven, or `options(read_spss = 'foreign')` to make `read_spss` use the foreign package to read spss data.
+* `value_labels` is now a global option. Use `options(value_labels = 'haven')` to set default attribute assignment in haven format (`labels` and `label`), or `options(value_labels = 'foreign')` to to set default attribute assignment in foreign format (`value.labels` and `variable.label`). Affects functions like auto-detection of labels, `set_var_labels` or `set_val_labels` etc.
 * Removed `plyr` import and replaced with `dplyr` functions.
 * Removed `reshape2` import and replaced with `tidyr` functions.
 

---FILE: man/dicho.Rd---
@@ -24,7 +24,7 @@ than 10.}
 \item{asNum}{logical, if \code{TRUE}, return value will be numeric, not a factor.}
 }
 \value{
-A dichotomized factor (or numeric, if \code{asNum = TRUE} variable (0/1-coded).
+A dichotomized factor (or numeric, if \code{asNum = TRUE}) variable (0/1-coded).
 }
 \description{
 Dichotomizes variables into dummy variables (0/1). Dichotomization is

---FILE: man/sjPlot-package.Rd---
@@ -38,8 +38,8 @@
 \tabular{ll}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.6.9-11\cr
-Date: \tab 2015-03-07\cr
+Version: \tab 1.6.9-12\cr
+Date: \tab 2015-03-09\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjc.qclus.Rd---
@@ -68,8 +68,8 @@ Example: \code{title=c(""my title"")}}
 \item{axisLabels.x}{Labels for the x-axis breaks.
 Example: \code{axisLabels.x=c(""Label1"", ""Label2"", ""Label3"")}.
 Note: If you use the \code{\link{read_spss}} function and the \code{\link{get_val_labels}} function, you receive a
-list object with label string. The labels may also be passed as list object. They will be unlisted and
-converted to character vector automatically.}
+list object with label string. The labels may also be passed as list object. They will be coerced
+to character vector automatically.}
 
 \item{axisTitle.x}{A label for the x axis. useful when plotting histograms with metric scales where no category labels
 are assigned to the x axis.}

---FILE: man/sjp.aov1.Rd---
@@ -40,8 +40,8 @@ Use \code{""NULL""} to automatically detect variable names that will be used as ti
 grouping variable axis. Passed as vector of strings.
 Example: \code{axisLabels.y=c(""Label1"", ""Label2"", ""Label3"")}. \cr
 Note: If you use the \code{\link{read_spss}} function and the \code{\link{get_val_labels}} function, you receive a
-list object with label string. The labels may also be passed as list object. They will be unlisted and
-converted to character vector automatically. See examples below. \cr
+list object with label string. The labels may also be passed as list object. They will be coerced
+to character vector automatically. See examples below. \cr
 Note: In case \code{type} is \code{""bars""}, the \code{grpVar} will be plotted along
 the x-axis.}
 

---FILE: man/sjp.frq.Rd---
@@ -40,8 +40,8 @@ cases are weighted. Use a string as parameter, e.g.: \code{weightByTitleString=""
 \code{varCount} into the factors (sub groups) of \code{interactionVar}. Only applies when parameter \code{""type""}
 is \code{""box""} or \code{""violin""} (resp. their alternative strings like \code{""boxplot""}, \code{""boxplots""} or \code{""v""}).}
 
-\item{sort.frq}{Determines whether categories on x-axis should be order according to the frequencies or not.
-Default is \code{""none""}, so categories are not ordered by frequency. Use \code{""asc""} or
+\item{sort.frq}{Determines whether categories on x-axis should be sorted according to the frequencies or not.
+Default is \code{""none""}, so categories are not sorted by frequency. Use \code{""asc""} or
 \code{""desc""} for sorting categories ascending or descending in relation to the frequencies.}
 
 \item{type}{Specifies the type of distribution plot that will be plotted.
@@ -64,8 +64,8 @@ bar and bin widths mostly need smaller values than dot sizes (i.e. if \code{type
 \item{axisLabels.x}{Labels for the x-axis breaks.
 Example: \code{axisLabels.x=c(""Label1"", ""Label2"", ""Label3"")}.
 Note: If you use the \code{\link{read_spss}} function and the \code{\link{get_val_labels}} function, you receive a
-list object with label string. The labels may also be passed as list object. They will be unlisted and
-converted to character vector automatically.}
+list object with label string. The labels may also be passed as list object. They will be coerced
+to character vector automatically.}
 
 \item{interactionVarLabels}{Labels for the x-axis breaks when having interaction variables included.
 These labels replace the \code{axisLabels.x}. Only applies, when using box or violin plots

---FILE: man/sjp.glm.Rd---
@@ -36,8 +36,8 @@ Example: \code{title=c(""my title"")}}
 axis. Passed as vector of strings.
 Example: \code{axisLabels.y=c(""Label1"", ""Label2"", ""Label3"")}
 Note: If you use the \code{\link{read_spss}} function and the \code{\link{get_val_labels}} function, you receive a
-\code{list} object with label string. The labels may also be passed as list object. They will be unlisted and
-converted to character vector automatically.}
+\code{list} object with label string. The labels may also be passed as list object. They will be coerced
+to character vector automatically.}
 
 \item{axisTitle.x}{A label (""title"") for the x axis.}
 

---FILE: man/sjp.glmm.Rd---
@@ -39,8 +39,8 @@ Default is \code{""Model""}.}
 axis. Passed as vector of strings.
 Example: \code{axisLabels.y=c(""Label1"", ""Label2"", ""Label3"")}
 Note: If you use the \code{\link{read_spss}} function and the \code{\link{get_val_labels}} function, you receive a
-\code{list} object with label strings. The labels may also be passed as list object. They will be unlisted and
-converted to character vector automatically.}
+\code{list} object with label strings. The labels may also be passed as list object. They will be coerced
+to character vector automatically.}
 
 \item{axisTitle.x}{A label (""title"") for the x axis.}
 

---FILE: man/sjp.grpfrq.Rd---
@@ -83,8 +83,8 @@ is not necessary when data was either imported with \code{\link{read_spss}} or h
 (see examples below). Else, specifiy parameter like this:
 \code{axisLabels.x=c(""Label1"", ""Label2"", ""Label3"")}.
 Note: If you use the \code{\link{read_spss}} function and the \code{\link{get_val_labels}} function, you receive a
-list object with label string. The labels may also be passed as list object. They will be unlisted and
-converted to character vector automatically.}
+list object with label string. The labels may also be passed as list object. They will be coerced
+to character vector automatically.}
 
 \item{interactionVarLabels}{Labels for the x-axis breaks when having interaction variables included.
 These labels replace the \code{axisLabels.x}. Only applies, when using box or violin plots

---FILE: man/sjp.lm.Rd---
@@ -45,8 +45,8 @@ character vector with variable label strings. You can use it like so:
 axis. Passed as vector of strings.
 Example: \code{axisLabels.y=c(""Label1"", ""Label2"", ""Label3"")}.
 Note: If you use the \code{\link{read_spss}} function and the \code{\link{get_val_labels}} function, you receive a
-list object with label string. The labels may also be passed as list object. They will be unlisted and
-converted to character vector automatically.}
+list object with label string. The labels may also be passed as list object. They will be coerced
+to character vector automatically.}
 
 \item{showAxisLabels.y}{Whether x axis text (category names, predictor labels) should be shown (use \code{TRUE})
 or not. Default is \code{TRUE}}

---FILE: man/sjp.lmm.Rd---
@@ -39,8 +39,8 @@ Default is \code{""Model""}.}
 axis. Passed as vector of strings.
 Example: \code{axisLabels.y=c(""Label1"", ""Label2"", ""Label3"")}
 Note: If you use the \code{\link{read_spss}} function and the \code{\link{get_val_labels}} function, you receive a
-\code{list} object with label strings. The labels may also be passed as list object. They will be unlisted and
-converted to character vector automatically.}
+\code{list} object with label strings. The labels may also be passed as list object. They will be coerced
+to character vector automatically.}
 
 \item{axisTitle.x}{A label (""title"") for the x axis.}
 

---FILE: man/to_sjPlot.Rd---
@@ -28,6 +28,7 @@ This function converts
 \seealso{
 \itemize{
            \item \href{http://www.strengejacke.de/sjPlot/datainit/}{sjPlot manual: data initialization}
+           \item \code{\link{to_haven}}
            }
 }
 "
strengejacke,sjPlot,aa1a08611003fe2931ec6814c7b543ce57889ffd,Daniel Ldecke,d.luedecke@uke.de,2015-03-08T08:51:17Z,Daniel Ldecke,d.luedecke@uke.de,2015-03-08T08:51:17Z,various minor fixes,DESCRIPTION;R/sjImportSPSS.R;R/sjTabGrpmean.R;R/sjTabLinReg.R;R/sjTabOdds.R;R/sjTabPropTable.R;man/read_sas.Rd;man/read_stata.Rd,False,True,True,False,22,11,33,"---FILE: DESCRIPTION---
@@ -16,8 +16,8 @@ Imports:
     foreign,
     psych,
     scales,
-    dplyr,
-    tidyr
+    dplyr (>= 0.4.1),
+    tidyr (>= 0.2.0)
 Suggests:
     arm,
     cluster,

---FILE: R/sjImportSPSS.R---
@@ -139,7 +139,7 @@ read_spss <- function(path,
 #'            }
 #'          
 #' @param path The file path to the SAS data file.
-#' @param patch.cat optional, the file path to the SAS catalog file.
+#' @param path.cat optional, the file path to the SAS catalog file.
 #' @return A data frame containing the SAS data. Retrieve value labels with \code{\link{get_val_labels}}
 #'   and variable labels with \code{\link{get_var_labels}}.
 #'   
@@ -183,7 +183,7 @@ read_sas <- function(path, path.cat = NULL) {
 #'         into a sjPlot friendly format (see \code{\link{to_sjPlot}}).
 #' 
 #' @export
-read_stata <- function(path, path.cat = NULL) {
+read_stata <- function(path) {
   # ------------------------
   # check if suggested package is available
   # ------------------------

---FILE: R/sjTabGrpmean.R---
@@ -161,7 +161,7 @@ sjt.grpmean <- function(varCount,
   fstat <- summary.lm(fit)$fstatistic[1]
   # p-value for F-test
   pval <- summary(fit)[[1]]['Pr(>F)'][1,1]
-  pvalstring <- ifelse(pval < 0.001, ""p&lt;0.001"", sprintf(""p=%.*f"", digits.summary, pval))  
+  pvalstring <- ifelse(pval < 0.001, sprintf(""p&lt;%s.001"", p_zero), sub(""0"", p_zero, sprintf(""p=%.*f"", digits.summary, pval)))
   # --------------------------------------
   # print data frame to html table
   # --------------------------------------
@@ -175,8 +175,11 @@ sjt.grpmean <- function(varCount,
                  CSS = CSS,
                  encoding = encoding,
                  hideProgressBar = TRUE,
-                 commentString = sprintf(""<strong>Anova:</strong> R<sup>2</sup>=%.*f &middot; adj. R<sup>2</sup>=%.*f &middot; F=%.*f &middot; %s"",
-                                         digits.summary, r2, digits.summary, r2.adj, digits.summary, fstat, pvalstring),
+                 commentString = gsub(""0."", 
+                                      paste0(""."", p_zero), 
+                                      sprintf(""<strong>Anova:</strong> R<sup>2</sup>=%.*f &middot; adj. R<sup>2</sup>=%.*f &middot; F=%.*f &middot; %s"",
+                                              digits.summary, r2, digits.summary, r2.adj, digits.summary, fstat, pvalstring),
+                                      fixed = TRUE),
                  remove.spaces = remove.spaces)
   # -------------------------------------
   # check if html-content should be printed

---FILE: R/sjTabLinReg.R---
@@ -987,7 +987,10 @@ sjt.lm <- function (...,
     for (i in 1:length(input_list)) {
       rsqu <- summary(input_list[[i]])$r.squared
       adjrsqu <- summary(input_list[[i]])$adj.r.squared
-      page.content <- paste0(page.content, sprintf(""    %s%.*f / %.*f</td>\n"", colspanstring, digits.summary, rsqu, digits.summary, adjrsqu))
+      page.content <- paste0(page.content, gsub(""0."", 
+                                                paste0(""."", p_zero), 
+                                                sprintf(""    %s%.*f / %.*f</td>\n"", colspanstring, digits.summary, rsqu, digits.summary, adjrsqu),
+                                                fixed = TRUE))
     }
     page.content <- paste(page.content, ""  </tr>\n"")
   }

---FILE: R/sjTabOdds.R---
@@ -843,7 +843,10 @@ sjt.glm <- function (...,
     page.content <- paste0(page.content, ""  <tr>\n    <td class=\""tdata leftalign summary\"">Pseudo-R<sup>2</sup></td>\n"")
     for (i in 1:length(input_list)) {
       psr <- PseudoR2(input_list[[i]])
-      page.content <- paste0(page.content, sprintf(""    %sR<sup>2</sup><sub>CS</sub> = %.*f<br>R<sup>2</sup><sub>N</sub> = %.*f</td>\n"", colspanstring, digits.summary, psr[2], digits.summary, psr[3]))
+      page.content <- paste0(page.content, gsub(""0."", 
+                                                paste0(""."", p_zero),
+                                                sprintf(""    %sR<sup>2</up><sub>CS</sub> = %.*f<br>R<sup>2</sup><sub>N</sub> = %.*f</td>\n"", colspanstring, digits.summary, psr[2], digits.summary, psr[3]),
+                                                fixed = TRUE))
     }
     page.content <- paste(page.content, ""  </tr>\n"")
   }

---FILE: R/sjTabPropTable.R---
@@ -759,6 +759,8 @@ sjt.xtab <- function (var.row,
       # if minimum expected values below 5 and df=1, compute fisher's exact test
       if(min(tab.expected)<5 || (min(tab.expected)<10 && chsq$parameter==1)) fish <- fisher.test(tab)
     }
+    # make phi-value apa style
+    kook <- gsub(""0."", paste0(""."", p_zero), kook, fixed = TRUE)
     # create summary row
     if (is.null(fish)) {
       pvalstring <- ifelse(chsq$p.value < 0.001, sprintf(""p&lt;%s.001"", p_zero) , sub(""0"", p_zero, sprintf(""p=%.3f"", chsq$p.value)))

---FILE: man/read_sas.Rd---
@@ -9,7 +9,7 @@ read_sas(path, path.cat = NULL)
 \arguments{
 \item{path}{The file path to the SAS data file.}
 
-\item{patch.cat}{optional, the file path to the SAS catalog file.}
+\item{path.cat}{optional, the file path to the SAS catalog file.}
 }
 \value{
 A data frame containing the SAS data. Retrieve value labels with \code{\link{get_val_labels}}

---FILE: man/read_stata.Rd---
@@ -4,7 +4,7 @@
 \alias{read_stata}
 \title{Import STATA dataset as data frame into R}
 \usage{
-read_stata(path, path.cat = NULL)
+read_stata(path)
 }
 \arguments{
 \item{path}{The file path to the STATA data file.}"
strengejacke,sjPlot,3618e3cf7eb6cdd70d4d9b90a238a47436e5bc8f,Daniel Ldecke,d.luedecke@uke.de,2015-03-08T07:53:57Z,Daniel Ldecke,d.luedecke@uke.de,2015-03-08T07:53:57Z,fixed bug with colspan in sit.(g)lm,R/sjPlotLinreg.R;R/sjPlotOdds.R;R/sjTabLinReg.R;R/sjTabOdds.R,False,True,True,False,6,6,12,"---FILE: R/sjPlotLinreg.R---
@@ -290,7 +290,7 @@ sjp.lm <- function(fit,
   # auto-retrieve value labels
   # --------------------------------------------------------
   if (is.null(axisLabels.y)) {
-    axisLabels.y <- retrieveModelLabels(list(fit))
+    axisLabels.y <- suppressWarnings(retrieveModelLabels(list(fit)))
   }
   # check length of diagram title and split longer string at into new lines
   # every 50 chars

---FILE: R/sjPlotOdds.R---
@@ -210,7 +210,7 @@ sjp.glm <- function(fit,
   # auto-retrieve value labels
   # --------------------------------------------------------
   if (is.null(axisLabels.y)) {
-    axisLabels.y <- retrieveModelLabels(list(fit))
+    axisLabels.y <- suppressWarnings(retrieveModelLabels(list(fit)))
   }
   # ----------------------------
   # Prepare length of title and labels

---FILE: R/sjTabLinReg.R---
@@ -802,7 +802,7 @@ sjt.lm <- function (...,
   # set default predictor labels
   # -------------------------------------
   if (is.null(labelPredictors) && !sw.fit) {
-    labelPredictors <- retrieveModelLabels(input_list)
+    labelPredictors <- suppressWarnings(retrieveModelLabels(input_list))
   }
   # --------------------------------------------------------
   # auto-retrieving variable labels does not work when we
@@ -882,7 +882,7 @@ sjt.lm <- function (...,
       page.content <- paste0(page.content, 
                              ""\n  <tr>\n"", 
                              sprintf(""\n    <td class=\""grouprow\"" colspan=\""%i\"">%s</td>"", 
-                                     headerColSpanFactor + 1, 
+                                     (length(input_list) * headerColSpanFactor) + 1, 
                                      group.pred.labs[which(group.pred.rows == i)]),
                              ""\n  </tr>"")
     }

---FILE: R/sjTabOdds.R---
@@ -669,7 +669,7 @@ sjt.glm <- function (...,
   # set default predictor labels
   # -------------------------------------
   if (is.null(labelPredictors)) {
-    labelPredictors <- retrieveModelLabels(input_list)
+    labelPredictors <- suppressWarnings(retrieveModelLabels(input_list))
   }
   # --------------------------------------------------------
   # auto-retrieving variable labels does not work when we
@@ -767,7 +767,7 @@ sjt.glm <- function (...,
       page.content <- paste0(page.content, 
                              ""\n  <tr>\n"", 
                              sprintf(""\n    <td class=\""grouprow\"" colspan=\""%i\"">%s</td>"", 
-                                     headerColSpanFactor + 1, 
+                                     (length(input_list) * headerColSpanFactor) + 1, 
                                      group.pred.labs[which(group.pred.rows == i)]),
                              ""\n  </tr>"")
     }"
strengejacke,sjPlot,64ea22bc0ce5b0c183755000421f4a5d953a7963,Daniel Ldecke,d.luedecke@uke.de,2015-03-02T20:33:44Z,Daniel Ldecke,d.luedecke@uke.de,2015-03-02T20:33:44Z,improvements and bug fixes,NEWS;R/sjImportSPSS.R;README.md;man/read_spss.Rd;man/to_sjPlot.Rd,False,True,True,False,191,108,299,"---FILE: NEWS---
@@ -12,6 +12,7 @@ New functions:
 * ""to_fac"" to convert (numeric or atomic) variables to factors, but keeps value and variable labels. Useful alternative to ""as.factor"", when data has been imported from SPSS (e.g. with ""read_spss"").
 
 Changes to functions:
+* ""read_spss"" (former ""sji.SPSS"") now supports reading data via ""haven""'s read-function (see parameter ""option"").
 * ""sjt.lm"" now also prints multiple fitted models with different predictors in each model (e.g. when comparing stepwise regression). See examples in ""?sjt.lm"".
 * Added parameter ""group.pred"" in ""sjt.lm"" and ""sjt.glm"" to automatically group table rows with factor levels of same factor.
 * Improved ""set_var_labels"", ""get_var_labels"", ""set_val_labels"" and ""get_val_labels"" to cope with ""haven"" package data structure.

---FILE: R/sjImportSPSS.R---
@@ -22,6 +22,11 @@
 #' @param atomic.to.fac Logical, if \code{TRUE}, factor variables imported from
 #'          SPSS (which are imported as \code{\link{atomic}}) will be converted
 #'          to \code{\link{factor}}s.
+#' @param option string, indicating which package will be used to read the SPSS data file.
+#'          By default, \code{option = ""foreign""}, which means, the \code{read.spss} function
+#'          from the \code{foreign} package is used. Use \code{option = ""haven""} to
+#'          use haven's \code{read_spss} function, which is usually faster, however,
+#'          not all string variables may be read properly.
 #' @return A data frame containing the SPSS data. retrieve value labels with \code{\link{get_val_labels}}
 #'   and variable labels with \code{\link{get_var_labels}}.
 #'   
@@ -51,47 +56,72 @@
 read_spss <- function(path, 
                      enc=NA, 
                      autoAttachVarLabels=FALSE,
-                     atomic.to.fac=FALSE) {
-  # import data as data frame
-  data.spss <- suppressWarnings(foreign::read.spss(path, to.data.frame=TRUE, use.value.labels=FALSE, reencode=enc))
-  # convert atomic values to factors
-  if (atomic.to.fac) {
-    # -------------------------------------
-    # create progress bar
-    # -------------------------------------
-    pb <- txtProgressBar(min = 0, 
-                         max = ncol(data.spss), 
-                         style = 3)
-    # tell user...
-    message(""Converting atomic to factors. Please wait...\n"")
-    # iterate all columns
-    for (i in 1:ncol(data.spss)) {
-      # copy column to vector
-      x <- data.spss[, i]
-      # is atomic, which was factor in SPSS?
-      if (is.atomic(x) && !is.null(attr(x, ""value.labels""))) {
-        # so we have value labels (only typical for factors, not
-        # continuous variables) and a variable of type ""atomic"" (SPSS
-        # continuous variables would be imported as numeric) - this
-        # indicates we have a factor variable. now we convert to 
-        # factor, but need to capture labels attribute first
-        labs <- attr(x, ""value.labels"")
-        # to factor
-        x <- as.factor(x)
-        # set back labels attribute
-        attr(x, ""value.labels"") <- labs
-        # copy vector back to data frame
-        data.spss[, i] <- x
+                     atomic.to.fac=FALSE,
+                     option = ""foreign"") {
+  # -------------------------------------
+  # check parameter
+  # -------------------------------------
+  if (option != ""foreign"" && option != ""haven"") {
+    warning(""'option' must be either 'foreign' or 'haven'. Defaulting to 'foreign'."", call. = F)
+    option <- ""foreign""
+  }
+  # -------------------------------------
+  # foreign import
+  # -------------------------------------
+  if (option == ""foreign"") {
+    # import data as data frame
+    data.spss <- suppressWarnings(foreign::read.spss(path, to.data.frame=TRUE, use.value.labels=FALSE, reencode=enc))
+    # convert atomic values to factors
+    if (atomic.to.fac) {
+      # -------------------------------------
+      # create progress bar
+      # -------------------------------------
+      pb <- txtProgressBar(min = 0, 
+                           max = ncol(data.spss), 
+                           style = 3)
+      # tell user...
+      message(""Converting atomic to factors. Please wait...\n"")
+      # iterate all columns
+      for (i in 1:ncol(data.spss)) {
+        # copy column to vector
+        x <- data.spss[, i]
+        # is atomic, which was factor in SPSS?
+        if (is.atomic(x) && !is.null(attr(x, ""value.labels""))) {
+          # so we have value labels (only typical for factors, not
+          # continuous variables) and a variable of type ""atomic"" (SPSS
+          # continuous variables would be imported as numeric) - this
+          # indicates we have a factor variable. now we convert to 
+          # factor, but need to capture labels attribute first
+          labs <- attr(x, ""value.labels"")
+          # to factor
+          x <- as.factor(x)
+          # set back labels attribute
+          attr(x, ""value.labels"") <- labs
+          # copy vector back to data frame
+          data.spss[, i] <- x
+        }
+        # update progress bar
+        setTxtProgressBar(pb, i)
       }
-      # update progress bar
-      setTxtProgressBar(pb, i)
+      close(pb)
+    }
+    # auto attach labels
+    if (autoAttachVarLabels) {
+      message(""Attaching variable labels. Please wait...\n"")
+      data.spss <- set_var_labels(data.spss, get_var_labels(data.spss))
     }
-    close(pb)
   }
-  # auto attach labels
-  if (autoAttachVarLabels) {
-    message(""Attaching variable labels. Please wait...\n"")
-    data.spss <- set_var_labels(data.spss, get_var_labels(data.spss))
+  else {
+    # ------------------------
+    # check if suggested package is available
+    # ------------------------
+    if (!requireNamespace(""haven"", quietly = TRUE)) {
+      stop(""Package 'haven' needed for this function to work. Please install it."", call. = FALSE)
+    }
+    # read data file
+    data.spss <- haven::read_spss(path)
+    # convert to sjPlot
+    data.spss <- to_sjPlot(data.spss)
   }
   # return data frame
   return(data.spss)
@@ -150,11 +180,11 @@ write_data <- function(x, path, type = ""spss"") {
     # haven labelled objects don't need conversion
     if (!is_labelled(x[[i]])) {
       # get variable value
-      var.lab <- get_var_labels(x[[i]], ""label"")
+      var.lab <- get_var_labels(x[[i]])
       # convert variable to labelled factor, so it can be saved
       x[[i]] <- to_label(x[[i]])
       # set back variable label
-      x[[i]] <- set_var_labels(x, var.lab, ""label"")
+      x[[i]] <- set_var_labels(x[[i]], var.lab, ""label"")
     }
     # update progress bar
     setTxtProgressBar(pb, i)
@@ -174,68 +204,87 @@ is_labelled <- function(x) {
 #' @title Convert a haven-imported data frame to sjPlot format
 #' @name to_sjPlot
 #' 
-#' @description This function converts a data frame, which was imported with any of
-#'                \code{haven}'s read functions and contains \code{labelled} class
-#'                vectors, into an sjPlot friendly data frame format.
+#' @description This function converts 
+#'                \itemize{
+#'                  \item a data frame, which was imported with any of \code{haven}'s read functions and contains \code{labelled} class vectors or
+#'                  \item a single vector of type \code{labelled}
+#'                }
+#'                into an sjPlot friendly data frame format.
 #' 
-#' @param x a data frame, which contains \code{labelled} class vectors
-#' @return a data frame with 'sjPlot' friendly vector classes and attached
-#'           label attributes.
+#' @param x a data frame, which contains \code{labelled} class vectors or a single vector
+#'          of class \code{labelled}.
+#' @return a data frame or single vector (depending on \code{x}) with 'sjPlot' friendly 
+#'           vector classes and attached label attributes.
 #' 
 #' @export
 to_sjPlot <- function(x) {
   # -------------------------------------
-  # create progress bar
+  # check if complete data frame or only single
+  # vector should be converted
   # -------------------------------------
-  pb <- txtProgressBar(min = 0, 
-                       max = ncol(x), 
-                       style = 3)
-  # tell user...
-  message(""Cconverting from haven to sjPlot. Please wait...\n"")
-  for (i in 1:ncol(x)) {
-    # haven labelled vector?
-    if (is_labelled(x[[i]])) {
-      # read current labels
-      var.lab <- attr(x[[i]], ""label"")
-      val.lab <- unname(attr(x[[i]], ""labels""))
-      val.lab.names <- names(attr(x[[i]], ""labels""))
+  if (is.data.frame(x) || is.matrix(x)) {
+    # -------------------------------------
+    # create progress bar
+    # -------------------------------------
+    pb <- txtProgressBar(min = 0, 
+                         max = ncol(x), 
+                         style = 3)
+    # tell user...
+    message(""Cconverting from haven to sjPlot. Please wait...\n"")
+    for (i in 1:ncol(x)) {
+      # convert vector
+      x[[i]] <- sji.toSjPlot(x[[i]], colnames(x)[i])
+      # update progress bar
+      setTxtProgressBar(pb, i)
+    }
+    close(pb)
+    # remove redundant class attributes
+    class(x) <- ""data.frame""
+  }
+  else {
+    x <- sji.toSjPlot(x)
+  }
+  return (x)
+}
+
+sji.toSjPlot <- function(x, var.name = NULL) {
+  # haven labelled vector?
+  if (is_labelled(x)) {
+    # read current labels
+    var.lab <- attr(x, ""label"")
+    val.lab <- unname(attr(x, ""labels""))
+    val.lab.names <- names(attr(x, ""labels""))
+    # delete old attributes
+    attr(x, ""label"") <- NULL
+    names(attr(x, ""labels"")) <- NULL
+    attr(x, ""labels"") <- NULL
+    # set back labels
+    x <- sji.setValueLabelNameParam(x, val.lab.names, var.name)
+    x <- set_var_labels(x, var.lab)
+    # remove labelled class attribute
+    class(x) <- NULL
+  }
+  else {
+    # read current labels
+    var.lab <- attr(x, ""label"")
+    # do we have any?
+    if (!is.null(var.lab)) {
       # delete old attributes
-      attr(x[[i]], ""label"") <- NULL
-      names(attr(x[[i]], ""labels"")) <- NULL
-      attr(x[[i]], ""labels"") <- NULL
+      attr(x, ""label"") <- NULL
       # set back labels
-      x[[i]] <- set_val_labels(x[[i]], val.lab.names)
-      x[[i]] <- set_var_labels(x[[i]], var.lab)
-      # remove labelled class attribute
-      class(x[[i]]) <- NULL
+      x <- set_var_labels(x, var.lab)
     }
-    else {
-      # read current labels
-      var.lab <- attr(x[[i]], ""label"")
-      # do we have any?
-      if (!is.null(var.lab)) {
-        # delete old attributes
-        attr(x[[i]], ""label"") <- NULL
-        # set back labels
-        x[[i]] <- set_var_labels(x[[i]], var.lab)
-      }
-      # read current labels
-      val.lab <- unname(attr(x[[i]], ""labels""))
-      if (!is.null(val.lab)) {
-        val.lab.names <- names(attr(x[[i]], ""labels""))
-        # delete old attributes
-        names(attr(x[[i]], ""labels"")) <- NULL
-        attr(x[[i]], ""labels"") <- NULL
-        # set back labels
-        x[[i]] <- set_val_labels(x[[i]], val.lab.names)
-      }
+    # read current labels
+    val.lab <- unname(attr(x, ""labels""))
+    if (!is.null(val.lab)) {
+      val.lab.names <- names(attr(x, ""labels""))
+      # delete old attributes
+      names(attr(x, ""labels"")) <- NULL
+      attr(x, ""labels"") <- NULL
+      # set back labels
+      x <- sji.setValueLabelNameParam(x, val.lab.names, var.name)
     }
-    # update progress bar
-    setTxtProgressBar(pb, i)
   }
-  close(pb)
-  # remove redundant class attributes
-  class(x) <- ""data.frame""
   return (x)
 }
 
@@ -374,16 +423,20 @@ sji.getValueLabelValues <- function(x, attr.string = ""value.labels"") {
 #' 
 #' @export
 set_val_labels <- function(x, labels) {
+  return (sji.setValueLabelNameParam(x, labels, NULL))
+}
+
+sji.setValueLabelNameParam <- function(x, labels, var.name) {
   if (is.vector(x) || is.atomic(x)) {
-    return (sji.setValueLabel.vector(x, labels))
+    return (sji.setValueLabel.vector(x, labels, var.name))
   }
   else if (is.data.frame(x) || is.matrix(x)) {
     for (i in 1:ncol(x)) {
       if (is.list(labels)) {
-        x[,i] <- sji.setValueLabel.vector(x[,i], labels[[i]])
+        x[,i] <- sji.setValueLabel.vector(x[,i], labels[[i]], colnames(x)[i])
       }
       else if (is.vector(labels)) {
-        x[,i] <- sji.setValueLabel.vector(x[,i], labels)
+        x[,i] <- sji.setValueLabel.vector(x[,i], labels, colnames(x)[i])
       }
       else {
         warning(""'labels' must be a list of same length as 'ncol(x)' or a vector."", call. = F)
@@ -392,7 +445,8 @@ set_val_labels <- function(x, labels) {
     return (x)
   }
 }
-sji.setValueLabel.vector <- function(var, labels) {
+
+sji.setValueLabel.vector <- function(var, labels, var.name = NULL) {
   # check for null
   if (!is.null(labels)) {
     if (is.null(var) || is.character(var)) {
@@ -401,9 +455,19 @@ sji.setValueLabel.vector <- function(var, labels) {
     else {
       # check if var is a factor
       if (is.factor(var)) {
-        # retrieve levels
-        minval <- 1
-        maxval <- length(levels(var))
+        # check if we have numeric levels
+        numlev <- suppressWarnings(as.numeric(levels(var)))
+        if (is.na(numlev[1])) {
+          # retrieve levels
+          minval <- 1
+          maxval <- length(levels(var))
+        }
+        else {
+          # retrieve minimum level, as numeric
+          minval <- min(as.numeric(levels(var)), na.rm = T)
+          # check range, add minimum, so we have max
+          maxval <- diff(range(as.numeric(levels(var)))) + minval
+        }
       }
       else {
         # retrieve values
@@ -416,17 +480,24 @@ sji.setValueLabel.vector <- function(var, labels) {
       }
       lablen <- length(labels)
       valrange <- maxval-minval+1
+      # set var name string
+      if (is.null(var.name) || nchar(var.name) < 1) {
+        name.string <- ""var""
+      }
+      else {
+        name.string <- var.name
+      }
       if (is.infinite(valrange)) {
         warning(""Can't set value labels. Infinite value range.\n"")
       }
       # check for valid length of labels
       else if (valrange<lablen) {
-        message(sprintf(""More labels than values of \""var\"". Using first %i labels.\n"", valrange))
+        message(sprintf(""More labels than values of \""%s\"". Using first %i labels.\n"", name.string, valrange))
         attr(var, ""value.labels"") <- c(as.character(c(minval:maxval)))
         names(attr(var, ""value.labels"")) <- labels[1:valrange]
       }
       else if (valrange>lablen) {
-        warning(""Can't set value labels. Value range of \""var\"" is longer than length of \""labels\"".\n"")
+        warning(sprintf(""Can't set value labels. Value range of \""%s\"" is longer than length of \""labels\"".\n"", name.string))
       }
       else {
         attr(var, ""value.labels"") <- c(as.character(c(minval:maxval)))
@@ -617,7 +688,7 @@ set_var_labels <- function(x, lab, attr.string = ""variable.label"") {
   if (!is.null(lab) && !is.null(x)) {
     if (is.data.frame(x)) {
       if (ncol(x)!=length(lab)) {
-        message(""Parameter \""lab\"" must be of same length as numbers of columns in \""x\""."")
+        message(""Parameter \""x\"" must be of same length as numbers of columns in \""x\""."")
       }
       else {
         # -------------------------------------

---FILE: README.md---
@@ -47,6 +47,7 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 * `to_fac` to convert (numeric or atomic) variables to factors, but keeps value and variable labels. Useful alternative to `as.factor`, when data has been imported from SPSS (e.g. with `read_spss`).
 
 #### Changes to functions
+* `read_spss` (former `sji.SPSS`) now supports reading data via `haven`'s read-function (see parameter `option`).
 * `sjt.lm` now also prints multiple fitted models with different predictors in each model (e.g. when comparing stepwise regression). See examples in `?sjt.lm`.
 * Added parameter `group.pred` in `sjt.lm` and `sjt.glm` to automatically group table rows with factor levels of same factor.
 * Improved `set_var_labels`, `get_var_labels`, `set_val_labels` and `get_val_labels` to cope with `haven` package data structure.

---FILE: man/read_spss.Rd---
@@ -5,7 +5,7 @@
 \title{Import SPSS dataset as data frame into R}
 \usage{
 read_spss(path, enc = NA, autoAttachVarLabels = FALSE,
-  atomic.to.fac = FALSE)
+  atomic.to.fac = FALSE, option = ""foreign"")
 }
 \arguments{
 \item{path}{The file path to the SPSS dataset.}
@@ -19,6 +19,12 @@ See \code{\link{set_var_labels}} for details.}
 \item{atomic.to.fac}{Logical, if \code{TRUE}, factor variables imported from
 SPSS (which are imported as \code{\link{atomic}}) will be converted
 to \code{\link{factor}}s.}
+
+\item{option}{string, indicating which package will be used to read the SPSS data file.
+By default, \code{option = ""foreign""}, which means, the \code{read.spss} function
+from the \code{foreign} package is used. Use \code{option = ""haven""} to
+use haven's \code{read_spss} function, which is usually faster, however,
+not all string variables may be read properly.}
 }
 \value{
 A data frame containing the SPSS data. retrieve value labels with \code{\link{get_val_labels}}

---FILE: man/to_sjPlot.Rd---
@@ -7,15 +7,19 @@
 to_sjPlot(x)
 }
 \arguments{
-\item{x}{a data frame, which contains \code{labelled} class vectors}
+\item{x}{a data frame, which contains \code{labelled} class vectors or a single vector
+of class \code{labelled}.}
 }
 \value{
-a data frame with 'sjPlot' friendly vector classes and attached
-          label attributes.
+a data frame or single vector (depending on \code{x}) with 'sjPlot' friendly
+          vector classes and attached label attributes.
 }
 \description{
-This function converts a data frame, which was imported with any of
-               \code{haven}'s read functions and contains \code{labelled} class
-               vectors, into an sjPlot friendly data frame format.
+This function converts
+               \itemize{
+                 \item a data frame, which was imported with any of \code{haven}'s read functions and contains \code{labelled} class vectors or
+                 \item a single vector of type \code{labelled}
+               }
+               into an sjPlot friendly data frame format.
 }
 "
strengejacke,sjPlot,3753649b2819a8f62a5d6c8d7481bca712701b75,Daniel Ldecke,d.luedecke@uke.de,2015-02-17T17:38:55Z,Daniel Ldecke,d.luedecke@uke.de,2015-02-17T17:38:55Z,fix,R/sjTabItemAnalysis.R,False,True,True,False,1,1,2,"---FILE: R/sjTabItemAnalysis.R---
@@ -408,7 +408,7 @@ sjt.itemanalysis <- function(df,
   # -------------------------------------
   if (remove.spaces) {
     knitr <- sju.rmspc(knitr)
-    page.content <- sju.rmspc(page.content)
+    complete.page <- sju.rmspc(complete.page)
   }
   # -------------------------------------
   # check if html-content should be printed"
strengejacke,sjPlot,b2faa458f2d816685f9f41d76f3f83c86a75c26e,Daniel Ldecke,d.luedecke@uke.de,2015-02-17T17:37:47Z,Daniel Ldecke,d.luedecke@uke.de,2015-02-17T17:37:47Z,bug fix in sjt.itemanalysis,DESCRIPTION;NEWS;R/sjPlotSetTheme.R;R/sjTabItemAnalysis.R;README.md;man/sjPlot-package.Rd;man/sjp.setTheme.Rd,False,True,True,False,169,9,178,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.6.9
-Date: 2015-02-15
+Version: 1.6.9-2
+Date: 2015-02-17
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of several plotting and table output functions for

---FILE: NEWS---
@@ -1,3 +1,12 @@
+Version 1.6.9-2
+------------------------------------------------------------------------------
+Changes to functions:
+* Improved pre-set theme ""538"" in ""sjp.setTheme"".
+* Added further pre-set themes to ""sjp.setTheme"".
+
+Bug fixes:
+* Fixed bug in ""sjt.itemanalysis"".
+
 Version 1.6.9
 ------------------------------------------------------------------------------
 New functions:

---FILE: R/sjPlotSetTheme.R---
@@ -93,8 +93,11 @@
 #'        Furthermore, there are some theme-presets, which can be used:
 #'        \itemize{
 #'          \item \code{""blank""}: a theme with no grids and axes.
-#'          \item \code{""538""}: a theme inspired by \href{http://fivethirtyeight.com}{538-charts}, adapted from \href{http://minimaxir.com/2015/02/ggplot-tutorial/}{minimaxir.com}.
 #'          \item \code{""forest""}: a theme for forest plots, with no grids.
+#'          \item \code{""538""}: a grey-scaled theme inspired by \href{http://fivethirtyeight.com}{538-charts}, adapted from \href{http://minimaxir.com/2015/02/ggplot-tutorial/}{minimaxir.com}.
+#'          \item \code{""539""}: a slight modification of the 538-theme.
+#'          \item \code{""blues""}: a blue-colored scheme based on the Blues color-brewer-palette.
+#'          \item \code{""greens""}: a green-colored scheme.
 #'        }
 #' @param base Base theme where theme is built on. By default, all 
 #'          metrics from \code{theme_gray()} are used.
@@ -233,6 +236,12 @@ sjp.setTheme <- function(title.color=""black"",
                          theme=NULL,
                          base=theme_grey()) {
   sjtheme <- NULL
+  title.vjust <- NULL
+  axis.title.x.vjust <- NULL
+  axis.title.y.vjust <- NULL
+  plot.margins <- NULL
+  panel.gridcol.x <- NULL
+  panel.gridcol.y <- NULL
   # ----------------------------------------  
   # check for blank theme, i.e. if user requires special
   # theme without any grids or axis lines
@@ -258,12 +267,100 @@ sjp.setTheme <- function(title.color=""black"",
     panel.minor.gridcol <- g.palette[2]
     axis.linecolor.x  <- axis.linecolor.y <- axis.linecolor <- g.palette[2]
     legend.backgroundcol <- legend.bordercol <- g.palette[2]
-    title.col <- g.palette[9]
-    axis.textcol <- g.palette[6]
+    title.color <- g.palette[9]
+    axis.textcolor <- g.palette[6]
     axis.title.color <- g.palette[7]
+    geom.label.color <- g.palette[6]
+    legend.title.color <- g.palette[7]
+    legend.color <- g.palette[6]
     axis.tickslen <- 0
+    # custom modifications
+    title.align <- ""center""
+    axis.title.x.vjust <- -1
+    axis.title.y.vjust <- 1.5
+    title.vjust <- 1.75
+    plot.margins <- unit(c(1, .5, 1, 0.5), ""cm"")
     message(""Theme '538' looks better with panel margins. You may want to use parameter 'expand.grid = TRUE' in sjp-functions."")
   }  
+  if (!is.null(theme) && theme==""539"") {
+    base <- theme_bw()
+    g.palette <- brewer_pal(palette = ""Greys"")(9)
+    panel.bordercol <- panel.backcol <- panel.col <- g.palette[2]
+    plot.backcol <- plot.bordercol <- plot.col <- g.palette[2]
+    panel.major.gridcol <- g.palette[4]
+    panel.minor.gridcol <- g.palette[2]
+    axis.linecolor <- NULL
+    axis.linecolor.y  <- g.palette[2]
+    axis.linecolor.x <- g.palette[9]
+    panel.gridcol.x <- g.palette[2]
+    legend.backgroundcol <- legend.bordercol <- g.palette[2]
+    title.color <- g.palette[9]
+    axis.textcolor <- g.palette[6]
+    axis.title.color <- g.palette[7]
+    geom.label.color <- g.palette[6]
+    legend.title.color <- g.palette[7]
+    legend.color <- g.palette[6]
+    axis.tickslen <- 0
+    # custom modifications
+    title.align <- ""center""
+    axis.title.x.vjust <- -1
+    axis.title.y.vjust <- 1.5
+    title.vjust <- 1.75
+    plot.margins <- unit(c(1, .5, 1, 0.5), ""cm"")
+  }  
+  if (!is.null(theme) && theme==""blues"") {
+    base <- theme_bw()
+    g.palette <- brewer_pal(palette = ""Blues"")(9)
+    panel.bordercol <- panel.backcol <- panel.col <- g.palette[1]
+    plot.backcol <- plot.bordercol <- plot.col <- g.palette[1]
+    panel.major.gridcol <- g.palette[3]
+    panel.minor.gridcol <- g.palette[1]
+    axis.linecolor <- NULL
+    axis.linecolor.y  <- g.palette[1]
+    axis.linecolor.x <- g.palette[9]
+    panel.gridcol.x <- g.palette[1]
+    legend.backgroundcol <- legend.bordercol <- g.palette[1]
+    title.color <- ""black""
+    axis.textcolor <- g.palette[9]
+    axis.title.color <- ""black""
+    geom.label.color <- g.palette[5]
+    legend.title.color <- g.palette[8]
+    legend.color <- g.palette[6]
+    axis.tickslen <- 0
+    # custom modifications
+    title.align <- ""center""
+    axis.title.x.vjust <- -1
+    axis.title.y.vjust <- 1.5
+    title.vjust <- 1.75
+    plot.margins <- unit(c(1, .5, 1, 0.5), ""cm"")
+  }  
+  if (!is.null(theme) && theme==""greens"") {
+    base <- theme_bw()
+    g.palette <- brewer_pal(palette = ""BrBG"")(9)
+    g.palette[5] <- ""#f5faf5""
+    panel.bordercol <- panel.backcol <- panel.col <- g.palette[5]
+    plot.backcol <- plot.bordercol <- plot.col <- g.palette[5]
+    panel.major.gridcol <- g.palette[6]
+    panel.minor.gridcol <- g.palette[5]
+    axis.linecolor <- NULL
+    axis.linecolor.y  <- g.palette[5]
+    axis.linecolor.x <- g.palette[9]
+    panel.gridcol.x <- g.palette[5]
+    legend.backgroundcol <- legend.bordercol <- g.palette[5]
+    title.color <- ""black""
+    axis.textcolor <- g.palette[9]
+    axis.title.color <- ""black""
+    geom.label.color <- g.palette[8]
+    legend.title.color <- g.palette[9]
+    legend.color <- g.palette[8]
+    axis.tickslen <- 0
+    # custom modifications
+    title.align <- ""center""
+    axis.title.x.vjust <- -1
+    axis.title.y.vjust <- 1.5
+    title.vjust <- 1.75
+    plot.margins <- unit(c(1, .5, 1, 0.5), ""cm"")
+  }  
   # ----------------------------------------  
   # set defaults for axis text angle
   # ----------------------------------------  
@@ -459,6 +556,49 @@ sjp.setTheme <- function(title.color=""black"",
         theme(panel.grid.minor = element_line(colour = panel.minor.gridcol),
               panel.grid.major = element_line(colour = panel.major.gridcol))
     }
+    # ----------------------------------------
+    # set plot margins. onyl applies to pre-set themes
+    # ----------------------------------------
+    if (!is.null(plot.margins)) {
+      sjtheme <- sjtheme +
+        theme(plot.margin = plot.margins)
+    }
+    # ----------------------------------------
+    # set title adjustments. only applies to
+    # pre-set themes
+    # ----------------------------------------
+    if (!is.null(plot.margins)) {
+      sjtheme <- sjtheme +
+        theme(plot.margin = plot.margins)
+    }
+    if (!is.null(title.vjust)) {
+      sjtheme <- sjtheme +
+        theme(plot.title = element_text(vjust = title.vjust))
+    }
+    if (!is.null(axis.title.x.vjust)) {
+      sjtheme <- sjtheme +
+        theme(axis.title.x = element_text(vjust = axis.title.x.vjust))
+    }
+    if (!is.null(axis.title.y.vjust)) {
+      sjtheme <- sjtheme +
+        theme(axis.title.y = element_text(vjust = axis.title.y.vjust))
+    }
+    # ----------------------------------------
+    # panel grid colors
+    # ----------------------------------------
+    if (!is.null(panel.gridcol.x)) {
+      sjtheme <- sjtheme +
+        theme(panel.grid.minor.x = element_line(colour = panel.gridcol.x),
+              panel.grid.major.x = element_line(colour = panel.gridcol.x))
+    }
+    if (!is.null(panel.gridcol.y)) {
+      sjtheme <- sjtheme +
+        theme(panel.grid.minor.y = element_line(colour = panel.gridcol.y),
+              panel.grid.major.y = element_line(colour = panel.gridcol.y))
+    }
+    # ----------------------------------------
+    # finally, set theme
+    # ----------------------------------------
     theme_set(sjtheme)
   }
   else {

---FILE: R/sjTabItemAnalysis.R---
@@ -408,7 +408,6 @@ sjt.itemanalysis <- function(df,
   # -------------------------------------
   if (remove.spaces) {
     knitr <- sju.rmspc(knitr)
-    toWrite <- sju.rmspc(toWrite)
     page.content <- sju.rmspc(page.content)
   }
   # -------------------------------------

---FILE: README.md---
@@ -33,6 +33,15 @@ install.packages(""sjPlot"")
 
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since this package makes heavy use of the [ggplot-package](http://cran.r-project.org/web/packages/ggplot2/index.html), consider citing this package as well.
 
+### Changelog of current development build 1.6.9-2
+
+#### Changes to functions
+* Improved pre-set theme `538` in `sjp.setTheme`.
+* Added further pre-set themes to `sjp.setTheme`.
+
+#### Bug fixes
+* Fixed bug in `sjt.itemanalysis` [#issue 8](https://github.com/sjPlot/devel/issues/8)
+.
 
 ### Changelog of current stable build 1.6.9
 

---FILE: man/sjPlot-package.Rd---
@@ -56,8 +56,8 @@
 \tabular{ll}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.6.9\cr
-Date: \tab 2015-02-15\cr
+Version: \tab 1.6.9-2\cr
+Date: \tab 2015-02-17\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjp.setTheme.Rd---
@@ -170,8 +170,11 @@ legend justification is set according to legend position.}
 Furthermore, there are some theme-presets, which can be used:
 \itemize{
   \item \code{""blank""}: a theme with no grids and axes.
-  \item \code{""538""}: a theme inspired by \href{http://fivethirtyeight.com}{538-charts}, adapted from \href{http://minimaxir.com/2015/02/ggplot-tutorial/}{minimaxir.com}.
   \item \code{""forest""}: a theme for forest plots, with no grids.
+  \item \code{""538""}: a grey-scaled theme inspired by \href{http://fivethirtyeight.com}{538-charts}, adapted from \href{http://minimaxir.com/2015/02/ggplot-tutorial/}{minimaxir.com}.
+  \item \code{""539""}: a slight modification of the 538-theme.
+  \item \code{""blues""}: a blue-colored scheme based on the Blues color-brewer-palette.
+  \item \code{""greens""}: a green-colored scheme.
 }}
 
 \item{base}{Base theme where theme is built on. By default, all"
strengejacke,sjPlot,d862ae24d3b532322c45ae6155fdbe4ab7c8beb3,Daniel Ldecke,d.luedecke@uke.de,2015-02-14T20:34:48Z,Daniel Ldecke,d.luedecke@uke.de,2015-02-14T20:34:48Z,added features + bug fix in sjp.setTheme,DESCRIPTION;NEWS;R/sjPlotSetTheme.R;README.md;man/sjPlot-package.Rd;man/sjp.setTheme.Rd,False,True,True,False,29,7,36,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.6.8-7
-Date: 2015-02-13
+Version: 1.6.8-8
+Date: 2015-02-14
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of several plotting and table output functions for

---FILE: NEWS---
@@ -11,13 +11,15 @@ Changes to functions:
 * Added parameter ""atomic.to.fac"" to ""sji.SPSS"", so variables with nominal or ordinal scale imported from SPSS data sets are imported as ""factors"", not as ""atomic"".
 * ""sjp.scatter"" no longer needs both ""x"" and ""y"" to be specified, but at least one of them.
 * ""sjt.grpmean"" now shows p-values for each group (retrieved from anova table).
+* Added new theme-preset ('theme = ""538""') to ""sjp.setTheme"".
 
 Bug fixes:
 * ""sjt.grpmean"" did not indicate p-values smaller than 0.001 as ""p<0.001"", but still as ""p=0.000"" - fixed.
 * Fixed bug in function ""sjs.stdmm"", which was the cause for a bug with type = ""fe.std"" in ""sjp.lmer"".
 * Fixed bug in ""sjp.int"" when fitted model does not contain p-values (e.g. when passing a merMod object from lme4).
 * ""sji.setValueLabels"" did not set labels properly when paramerer ""labels"" was a list - fixed.
 * Minor bug fix in ""sjp.int"".
+* Minor bug fix in ""sjp.setTheme"".
 
 
 Version 1.6.8

---FILE: R/sjPlotSetTheme.R---
@@ -93,6 +93,7 @@
 #'        Furthermore, there are some theme-presets, which can be used:
 #'        \itemize{
 #'          \item \code{""blank""}: a theme with no grids and axes.
+#'          \item \code{""538""}: a theme inspired by \href{http://fivethirtyeight.com}{538-charts}, adapted from \href{http://minimaxir.com/2015/02/ggplot-tutorial/}{minimaxir.com}.
 #'          \item \code{""forest""}: a theme for forest plots, with no grids.
 #'        }
 #' @param base Base theme where theme is built on. By default, all 
@@ -148,6 +149,7 @@
 #'
 #' @import ggplot2
 #' @importFrom grid unit
+#' @importFrom scales brewer_pal
 #' @export
 sjp.setTheme <- function(title.color=""black"",
                          title.size=1.3,
@@ -225,14 +227,29 @@ sjp.setTheme <- function(title.color=""black"",
     base <- theme_classic()
     axis.linecolor <- ""white""
     axis.ticksol <- ""white""
-    panel.backcol <- ""white""
     panel.gridcol <- ""white""
+    plot.col <- ""white""
   }
   if (!is.null(theme) && theme==""forest"") {
     base <- theme_bw()
     panel.gridcol <- ""white""
     axis.tickslen <- 0
   }  
+  if (!is.null(theme) && theme==""538"") {
+    base <- theme_bw()
+    g.palette <- brewer_pal(pal = ""Greys"")(9)
+    panel.bordercol <- panel.backcol <- panel.col <- g.palette[2]
+    plot.backcol <- plot.bordercol <- plot.col <- g.palette[2]
+    panel.major.gridcol <- g.palette[4]
+    panel.minor.gridcol <- g.palette[2]
+    axis.linecolor.x <- axis.linecolor.y <- axis.linecolor <- g.palette[2]
+    legend.backgroundcol <- legend.bordercol <- g.palette[2]
+    title.col <- g.palette[9]
+    axis.textcol <- g.palette[6]
+    axis.title.color <- g.palette[7]
+    axis.tickslen <- 0
+    message(""Theme '538' looks better with panel margins. You may want to use parameter 'expand.grid = TRUE' in sjp-functions."")
+  }  
   # ----------------------------------------  
   # set defaults for axis text angle
   # ----------------------------------------  
@@ -417,7 +434,8 @@ sjp.setTheme <- function(title.color=""black"",
     if (!is.null(panel.col)) {
       sjtheme <- sjtheme +
         theme(panel.background = element_rect(colour = panel.bordercol, 
-                                              fill = panel.backcol))
+                                              fill = panel.backcol),
+              panel.border = element_rect(colour = panel.bordercol))
     }
     # ----------------------------------------
     # set panel grids, if defined

---FILE: README.md---
@@ -47,14 +47,15 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 * Added parameter `atomic.to.fac` to `sji.SPSS`, so variables with nominal or ordinal scale imported from SPSS data sets are imported as `factors`, not as `atomic`.
 * `sjp.scatter` no longer needs both `x` and `y` to be specified, but at least one of them.
 * `sjt.grpmean` now shows p-values for each group (retrieved from anova table).
-
+* Added new theme-preset (`theme = ""538""`) to `sjp.setTheme`.
 
 #### Bug fixes
 * `sjt.grpmean` did not indicate p-values smaller than 0.001 as _p<0.001_, but still as _p=0.000_ - fixed.
 * Fixed bug in function `sjs.stdmm`, which was the cause for a bug with `type = ""fe.std""` in `sjp.lmer`.
 * Fixed bug in `sjp.int` when fitted model does not contain p-values (e.g. when passing a merMod object from lme4).
 * `sji.setValueLabels` did not set labels properly when paramerer `labels` was a list - fixed.
 * Minor bug fix in `sjp.int`.
+* Minor bug fix in `sjp.setTheme`.
 
 ### Changelog of current stable build 1.6.8
 

---FILE: man/sjPlot-package.Rd---
@@ -56,8 +56,8 @@
 \tabular{ll}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.6.8-7\cr
-Date: \tab 2015-02-13\cr
+Version: \tab 1.6.8-8\cr
+Date: \tab 2015-02-14\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjp.setTheme.Rd---
@@ -170,6 +170,7 @@ legend justification is set according to legend position.}
 Furthermore, there are some theme-presets, which can be used:
 \itemize{
   \item \code{""blank""}: a theme with no grids and axes.
+  \item \code{""538""}: a theme inspired by \href{http://fivethirtyeight.com}{538-charts}, adapted from \href{http://minimaxir.com/2015/02/ggplot-tutorial/}{minimaxir.com}.
   \item \code{""forest""}: a theme for forest plots, with no grids.
 }}
 "
strengejacke,sjPlot,0b54d23155bb082ba5569997475bed7c8b7a925e,Daniel Ldecke,d.luedecke@uke.de,2015-02-11T19:26:01Z,Daniel Ldecke,d.luedecke@uke.de,2015-02-11T19:26:01Z,bug fixes,DESCRIPTION;NEWS;R/helpfunctions.R;R/sjImportSPSS.R;R/sjPlotAnova.R;R/sjTabGrpmean.R;README.md;man/sjPlot-package.Rd;man/sji.setVariableLabels.Rd;man/sjp.aov1.Rd,False,True,True,False,51,28,79,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.6.8-4
-Date: 2015-02-010
+Version: 1.6.8-5
+Date: 2015-02-011
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of several plotting and table output functions for

---FILE: NEWS---
@@ -1,16 +1,18 @@
-Version 1.6.8-4
+Version 1.6.8-5
 ------------------------------------------------------------------------------
 Changes to functions:
 * Plotting single predictors of linear models (type = ""pred"" in function ""sjp.lm"") now also supports plotting interaction terms and factor levels. Needs parameter ""x=TRUE"" in lm-call to work.
 * Added parameter ""remove.spaces"" to all ""sjt""-function to remove leading spaces (parantheses of html-tags), which may make tables less cluttered when importing them into office applications.
 * Added parameters ""digits"" and ""digits.stats"" to ""sjt.stackfrq"", to specifiy digits after decimal point for percentage and statistic values.
 * Added parameter ""atomic.to.fac"" to ""sji.SPSS"", so variables with nominal or ordinal scale imported from SPSS data sets are imported as ""factors"", not as ""atomic"".
 * ""sjp.scatter"" no longer needs both ""x"" and ""y"" to be specified, but at least one of them.
+* ""sjt.grpmean"" now shows p-values for each group (retrieved from anova table).
 
 Bug fixes:
 * ""sjt.grpmean"" did not indicate p-values smaller than 0.001 as ""p<0.001"", but still as ""p=0.000"" - fixed.
 * Fixed bug in function ""sjs.stdmm"", which was the cause for a bug with type = ""fe.std"" in ""sjp.lmer"".
 * Fixed bug in ""sjp.int"" when fitted model does not contain p-values (e.g. when passing a merMod object from lme4).
+* ""sji.setValueLabels"" did not set labels properly when paramerer ""labels"" was a list - fixed.
 * Minor bug fix in ""sjp.int"".
 
 

---FILE: R/helpfunctions.R---
@@ -226,7 +226,7 @@ create.frq.df <- function(varCount,
     # increase counter
     dfc <- dfc+1
   }
-  # check if we modified ,ydat
+  # check if we modified mydat
   if (dfc>1) {
     # set var
     mydat$var <- c(1:nrow(mydat))

---FILE: R/sjImportSPSS.R---
@@ -191,12 +191,12 @@ sji.setValueLabels <- function(x, labels) {
   }
   else if (is.data.frame(x) || is.matrix(x)) {
     for (i in 1:ncol(x)) {
-      if (is.vector(labels)) {
-        x[,i] <- sji.setValueLabels.vector(x[,i], labels)
-      }
-      else if (is.list(labels)) {
+      if (is.list(labels)) {
         x[,i] <- sji.setValueLabels.vector(x[,i], labels[[i]])
       }
+      else if (is.vector(labels)) {
+        x[,i] <- sji.setValueLabels.vector(x[,i], labels)
+      }
       else {
         warning(""'labels' must be a list of same length as 'ncol(x)' or a vector."", call. = F)
       }
@@ -297,7 +297,7 @@ sji.getVariableLabels <- function(x) {
 }
 
 
-#' @title Set variable label(s) to a single variable or data frame
+#' @title Attach variable label(s) to a single variable or data frame
 #' @name sji.setVariableLabels
 #' @description This function sets variable labels to a single variable or to
 #'                a set of variables in a data frame. To each variable, the

---FILE: R/sjPlotAnova.R---
@@ -10,14 +10,17 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""pv""))
 #'                dependent variable (variance within and between groups) is printed to
 #'                the model summary.
 #'                
-#' @seealso \code{\link{sjs.aov1.levene}}
+#' @seealso \itemize{
+#'            \item \code{\link{sjs.aov1.levene}}
+#'            \item \code{\link{sjt.grpmean}}
+#'          }
 #'                
 #' @param depVar The dependent variable. Will be used with following formular:
 #'          \code{aov(depVar ~ grpVar)}
 #' @param grpVar The grouping variable, as unordered factor. Will be used with following formular:
 #'          \code{aov(depVar ~ grpVar)}
-#' @param meansums If \code{TRUE}, the values reported are the true group mean values. If \code{FALSE} (default),
-#'          the values are reported in the standard way, i.e. the values indicate the difference of
+#' @param meansums If \code{TRUE}, the values reported are the true group mean values (see also \code{\link{sjt.grpmean}}).
+#'          If \code{FALSE} (default), the values are reported in the standard way, i.e. the values indicate the difference of
 #'          the group mean in relation to the intercept (reference group).
 #' @param type Indicates Whether the group means should be plotted as \code{""dots""} (aka forest plots, default)
 #'          or as \code{""bars""}.

---FILE: R/sjTabGrpmean.R---
@@ -87,6 +87,23 @@ sjt.grpmean <- function(varCount,
   varCount <- as.numeric(varCount)
   varGrp <- as.numeric(varGrp)
   # --------------------------------------
+  # compute anova statistics for mean table
+  # see below
+  # --------------------------------------
+  fit <- aov(varCount ~ as.factor(varGrp))
+  # p-values of means
+  means.p <- summary.lm(fit)$coefficients[, 4]
+  pval <- c()
+  # convert means to apa style
+  for (i in 1:length(means.p)) {
+    if (means.p[i] < 0.001) {
+      pval <- c(pval, ""&lt;0.001"")
+    }
+    else {
+      pval <- c(pval, sprintf(""%.*f"", digits, means.p[i]))
+    }
+  } 
+  # --------------------------------------
   # retrieve group indices
   # --------------------------------------
   indices <- sort(unique(na.omit(varGrp)))
@@ -104,7 +121,8 @@ sjt.grpmean <- function(varCount,
                 cbind(mean = sprintf(""%.*f"", digits, mean(varCount[varGrp == indices[i]], na.rm = TRUE)),
                       N = length(na.omit(varCount[varGrp == indices[i]])),
                       sd = sprintf(""%.*f"", digits, sd(varCount[varGrp == indices[i]], na.rm = TRUE)),
-                      se = sprintf(""%.*f"", digits, sjs.se(varCount[varGrp == indices[i]]))))
+                      se = sprintf(""%.*f"", digits, sjs.se(varCount[varGrp == indices[i]])),
+                      p = pval[i]))
   }
   # --------------------------------------
   # finally, add total-row
@@ -113,7 +131,8 @@ sjt.grpmean <- function(varCount,
               cbind(mean = sprintf(""%.*f"", digits, mean(varCount, na.rm = TRUE)),
                     N = length(na.omit(varCount)),
                     sd = sprintf(""%.*f"", digits, sd(varCount, na.rm = TRUE)),
-                    se = sprintf(""%.*f"", digits, sjs.se(varCount))))
+                    se = sprintf(""%.*f"", digits, sjs.se(varCount)),
+                    p = """"))
   # --------------------------------------
   # fix row labels, if empty or NULL
   # --------------------------------------
@@ -122,13 +141,8 @@ sjt.grpmean <- function(varCount,
   }
   rownames(df) <- c(rowLabels, ""Total"")
   # --------------------------------------
-  # convert grp to factor for one-way-anova
-  # --------------------------------------
-  varGrp <- as.factor(varGrp)
-  # --------------------------------------
-  # compute anova statistics for mean table
+  # get anova statistics for mean table
   # --------------------------------------
-  fit <- aov(varCount ~ varGrp)
   # multiple r2
   r2 <- summary.lm(fit)$r.squared
   # adj. r2

---FILE: README.md---
@@ -34,23 +34,24 @@ install.packages(""sjPlot"")
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since this package makes heavy use of the [ggplot-package](http://cran.r-project.org/web/packages/ggplot2/index.html), consider citing this package as well.
 
 
-### Changelog of current development build 1.6.8-4
+### Changelog of current development build 1.6.8-5
 
 #### Changes to functions
 * Plotting single predictors of linear models (`type = ""pred""` in function `sjp.lm`) now also supports plotting interaction terms and factor levels. Needs parameter `x=TRUE` in `lm`-call to work.
 * Added parameter `remove.spaces` to all `sjt`-function to remove leading spaces (parantheses of html-tags), which may make tables less cluttered when importing them into office applications.
 * Added parameters `digits` and `digits.stats` to `sjt.stackfrq`, to specifiy digits after decimal point for percentage and statistic values.
 * Added parameter `atomic.to.fac` to `sji.SPSS`, so variables with nominal or ordinal scale imported from SPSS data sets are imported as `factors`, not as `atomic`.
 * `sjp.scatter` no longer needs both `x` and `y` to be specified, but at least one of them.
+* `sjt.grpmean` now shows p-values for each group (retrieved from anova table).
 
 
 #### Bug fixes
 * `sjt.grpmean` did not indicate p-values smaller than 0.001 as _p<0.001_, but still as _p=0.000_ - fixed.
 * Fixed bug in function `sjs.stdmm`, which was the cause for a bug with `type = ""fe.std""` in `sjp.lmer`.
 * Fixed bug in `sjp.int` when fitted model does not contain p-values (e.g. when passing a merMod object from lme4).
+* `sji.setValueLabels` did not set labels properly when paramerer `labels` was a list - fixed.
 * Minor bug fix in `sjp.int`.
 
-
 ### Changelog of current stable build 1.6.8
 
 #### Changes to functions

---FILE: man/sjPlot-package.Rd---
@@ -56,8 +56,8 @@
 \tabular{ll}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.6.8-4\cr
-Date: \tab 2015-02-10\cr
+Version: \tab 1.6.8-5\cr
+Date: \tab 2015-02-11\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sji.setVariableLabels.Rd---
@@ -2,7 +2,7 @@
 % Please edit documentation in R/sjImportSPSS.R
 \name{sji.setVariableLabels}
 \alias{sji.setVariableLabels}
-\title{Set variable label(s) to a single variable or data frame}
+\title{Attach variable label(s) to a single variable or data frame}
 \usage{
 sji.setVariableLabels(x, lab)
 }

---FILE: man/sjp.aov1.Rd---
@@ -21,8 +21,8 @@ sjp.aov1(depVar, grpVar, meansums = FALSE, type = ""dots"",
 \item{grpVar}{The grouping variable, as unordered factor. Will be used with following formular:
 \code{aov(depVar ~ grpVar)}}
 
-\item{meansums}{If \code{TRUE}, the values reported are the true group mean values. If \code{FALSE} (default),
-the values are reported in the standard way, i.e. the values indicate the difference of
+\item{meansums}{If \code{TRUE}, the values reported are the true group mean values (see also \code{\link{sjt.grpmean}}).
+If \code{FALSE} (default), the values are reported in the standard way, i.e. the values indicate the difference of
 the group mean in relation to the intercept (reference group).}
 
 \item{type}{Indicates Whether the group means should be plotted as \code{""dots""} (aka forest plots, default)
@@ -149,6 +149,9 @@ sjp.aov1(efc$c12hour,
          showModelSummary = FALSE)
 }
 \seealso{
-\code{\link{sjs.aov1.levene}}
+\itemize{
+           \item \code{\link{sjs.aov1.levene}}
+           \item \code{\link{sjt.grpmean}}
+         }
 }
 "
strengejacke,sjPlot,30e39c88a6743b956ec52632fe174b467f8c802e,Daniel Ldecke,d.luedecke@uke.de,2015-02-10T13:17:16Z,Daniel Ldecke,d.luedecke@uke.de,2015-02-10T13:17:16Z,bugfix,R/sjPlotLinreg.R,False,True,True,False,2,2,4,"---FILE: R/sjPlotLinreg.R---
@@ -574,11 +574,11 @@ sjp.reglin <- function(fit,
     # -----------------------------------------------------------
     if (fit.x) {
       if (useResiduals) {
-        mydat <- as.data.frame(cbind(fit$x[,which(cn==xval)],
+        mydat <- as.data.frame(cbind(fit$x[,which(cn==xval)+1],
                                      fit$residuals))
       }
       else {
-        mydat <- as.data.frame(cbind(fit$x[,which(cn==xval)],
+        mydat <- as.data.frame(cbind(fit$x[,which(cn==xval)+1],
                                      fit$model[, 1]))
       }
     }"
strengejacke,sjPlot,17ec2e7106b87535ecb496e08d39d24986f7321e,Daniel Ldecke,d.luedecke@uke.de,2015-02-05T19:51:11Z,Daniel Ldecke,d.luedecke@uke.de,2015-02-05T19:51:11Z,bugfix with p-value-style in sjt.grpmean,NEWS;R/sjTabGrpmean.R;README.md,False,True,True,False,5,2,7,"---FILE: NEWS---
@@ -1,6 +1,7 @@
 Version 1.6.8-2
 ------------------------------------------------------------------------------
 Bug fixes:
+* ""sjt.grpmean"" did not indicate p-values smaller than 0.001 as ""p<0.001"", but still as ""p=0.000"" - fixed.
 * Fixed bug in function ""sjs.stdmm"", which was the cause for a bug with type = ""fe.std"" in ""sjp.lmer"".
 * Fixed bug in ""sjp.int"" when fitted model does not contain p-values (e.g. when passing a merMod object from lme4).
 * Minor bug fix in ""sjt.int"".

---FILE: R/sjTabGrpmean.R---
@@ -133,6 +133,7 @@ sjt.grpmean <- function(varCount,
   fstat <- summary.lm(fit)$fstatistic[1]
   # p-value for F-test
   pval <- summary(fit)[[1]]['Pr(>F)'][1,1]
+  pvalstring <- ifelse(pval < 0.001, ""p&lt;0.001"", sprintf(""p=%.*f"", digits.summary, pval))  
   # --------------------------------------
   # print data frame to html table
   # --------------------------------------
@@ -146,8 +147,8 @@ sjt.grpmean <- function(varCount,
                  CSS = CSS,
                  encoding = encoding,
                  hideProgressBar = TRUE,
-                 commentString = sprintf(""<strong>Anova:</strong> R<sup>2</sup>=%.*f &middot; adj. R<sup>2</sup>=%.*f &middot; F=%.*f &middot; p=%.*f"",
-                                         digits.summary, r2, digits.summary, r2.adj, digits.summary, fstat, digits.summary, pval))
+                 commentString = sprintf(""<strong>Anova:</strong> R<sup>2</sup>=%.*f &middot; adj. R<sup>2</sup>=%.*f &middot; F=%.*f &middot; %s"",
+                                         digits.summary, r2, digits.summary, r2.adj, digits.summary, fstat, pvalstring))
   # -------------------------------------
   # check if html-content should be printed
   # -------------------------------------

---FILE: README.md---
@@ -37,6 +37,7 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 ### Changelog of current development build 1.6.8-2
 
 ### Bug fixes
+* `sjt.grpmean` did not indicate p-values smaller than 0.001 as _p<0.001_, but still as _p=0.000_ - fixed.
 * Fixed bug in function `sjs.stdmm`, which was the cause for a bug with `type = ""fe.std""` in `sjp.lmer`.
 * Fixed bug in `sjp.int` when fitted model does not contain p-values (e.g. when passing a merMod object from lme4).
 * Minor bug fix in `sjt.int`."
strengejacke,sjPlot,2d38c0e524b1c1bc8d42e2ca84720d3fb0ab7fa8,Daniel Ldecke,d.luedecke@uke.de,2015-02-05T17:39:11Z,Daniel Ldecke,d.luedecke@uke.de,2015-02-05T17:39:11Z,"Fixed bug in ""sjp.int""

Fixed bug in ""sjp.int"" when fitted model does not contain p-values",DESCRIPTION;NEWS;R/sjPlotInteractions.R;README.md;man/sjPlot-package.Rd,False,True,True,False,19,6,25,"---FILE: DESCRIPTION---
@@ -3,7 +3,7 @@ Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
 Version: 1.6.8-2
-Date: 2015-02-03
+Date: 2015-02-05
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Ldecke <d.luedecke@uke.de>
 Description: Collection of several plotting and table output functions for

---FILE: NEWS---
@@ -2,6 +2,8 @@ Version 1.6.8-2
 ------------------------------------------------------------------------------
 Bug fixes:
 * Fixed bug in function ""sjs.stdmm"", which was the cause for a bug with type = ""fe.std"" in ""sjp.lmer"".
+* Fixed bug in ""sjp.int"" when fitted model does not contain p-values (e.g. when passing a merMod object from lme4).
+* Minor bug fix in ""sjt.int"".
 
 
 Version 1.6.8

---FILE: R/sjPlotInteractions.R---
@@ -240,6 +240,11 @@ sjp.int <- function(fit,
     legendLabels <- unlistlabels(legendLabels)
   }
   # -----------------------------------------------------------
+  # retrieve coefficients
+  # -----------------------------------------------------------
+  coef.tab <- summary(fit)$coefficients
+  pval <- rep(0, times = nrow(coef.tab)-1)
+  # -----------------------------------------------------------
   # prepare values for (generalized) linear models
   # -----------------------------------------------------------
   if (fun == ""lm"" || fun == ""glm"") {
@@ -254,16 +259,18 @@ sjp.int <- function(fit,
     # -----------------------------------------------------------
     # retrieve p-values, without intercept
     # -----------------------------------------------------------
-    pval <- summary(fit)$coefficients[-1, 4]
+    if (ncol(coef.tab) > 3) {
+      pval <- coef.tab[-1, 4]
+    }
     # -----------------------------------------------------------
     # retrieve estimates, without intercept
     # -----------------------------------------------------------
-    estimates <- summary(fit)$coefficients[-1, 1]
+    estimates <- coef.tab[-1, 1]
     estimates.names <- it <- names(estimates)
     # -----------------------------------------------------------
     # retrieve estimate of intercept
     # -----------------------------------------------------------
-    b0 <- estimates.intercept <- summary(fit)$coefficients[1, 1]
+    b0 <- estimates.intercept <- coef.tab[1, 1]
   }
   # -----------------------------------------------------------
   # prepare values for (generalized) linear mixed effecrs models
@@ -280,7 +287,9 @@ sjp.int <- function(fit,
     # -----------------------------------------------------------
     # retrieve p-values, without intercept
     # -----------------------------------------------------------
-    pval <- summary(fit)$coefficients[-1, 4]
+    if (ncol(coef.tab) > 3) {
+      pval <- coef.tab[-1, 4]
+    }
     # -----------------------------------------------------------
     # retrieve estimates, without intercept
     # -----------------------------------------------------------

---FILE: README.md---
@@ -38,6 +38,8 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 
 ### Bug fixes
 * Fixed bug in function `sjs.stdmm`, which was the cause for a bug with `type = ""fe.std""` in `sjp.lmer`.
+* Fixed bug in `sjp.int` when fitted model does not contain p-values (e.g. when passing a merMod object from lme4).
+* Minor bug fix in `sjt.int`.
 
 
 ### Changelog of current stable build 1.6.8

---FILE: man/sjPlot-package.Rd---
@@ -57,7 +57,7 @@
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
 Version: \tab 1.6.8-2\cr
-Date: \tab 2015-02-03\cr
+Date: \tab 2015-02-05\cr
 License: \tab GPL-3\cr
 }
 }"
strengejacke,sjPlot,8e7d34b50f1cb5204d42460850d518630cb1a5e8,Daniel Ldecke,d.luedecke@uke.de,2015-02-04T19:01:49Z,Daniel Ldecke,d.luedecke@uke.de,2015-02-04T19:01:49Z,minor bug fix,R/sjPlotInteractions.R,False,True,True,False,1,1,2,"---FILE: R/sjPlotInteractions.R---
@@ -622,7 +622,7 @@ sjp.int <- function(fit,
     if (showInterceptLines) {
       # retrieve intercept bounds
       ilmin <- min(b0, est_b)
-      ilmax <- min(b0, est_b)
+      ilmax <- max(b0, est_b)
       # adjust lower lim if necessary
       if (ilmin < lowerLim.y) {
         lowerLim.y <- floor(ilmin)"
strengejacke,sjPlot,794a895431fe1235518eb9a6067272f79671074d,Daniel Ldecke,d.luedecke@uke.de,2015-01-06T20:13:35Z,Daniel Ldecke,d.luedecke@uke.de,2015-01-06T20:13:35Z,fixed issue #6,R/sjPlotGLME.R;R/sjTabPropTable.R,False,True,True,False,10,6,16,"---FILE: R/sjPlotGLME.R---
@@ -973,6 +973,7 @@ sjp.lme.feprobcurv <- function(fit,
   fit.term.length <- length(names(lme4::fixef(fit))[-1])
   fit.term.names <- na.omit(attr(attr(fit.df, ""terms""), ""term.labels"")[1 : fit.term.length])
   response.name <- attr(attr(attr(fit.df, ""terms""), ""dataClasses""), ""names"")[1]
+  fi <- unname(lme4::fixef(fit))[1]
   # ----------------------------
   # filter vars?
   # ----------------------------
@@ -1019,7 +1020,7 @@ sjp.lme.feprobcurv <- function(fit,
         # calculate x-beta by multiplying original values with estimate of that term
         mydf.vals$xbeta <- mydf.vals$value * (lme4::fixef(fit)[coef.pos])
         # calculate probability (y) via cdf-function
-        mydf.vals$y <- odds.to.prob(lme4::fixef(fit)[1] + mydf.vals$xbeta)
+        mydf.vals$y <- odds.to.prob(fi + mydf.vals$xbeta)
         # save predictor name
         pred.name <- fit.term.names[i]
         axisLabels.mp <- c(axisLabels.mp, pred.name)
@@ -1120,6 +1121,7 @@ sjp.lme.reprobcurve <- function(fit,
   fit.term.length <- length(names(lme4::fixef(fit))[-1])
   fit.term.names <- na.omit(attr(attr(fit.df, ""terms""), ""term.labels"")[1 : fit.term.length])
   response.name <- attr(attr(attr(fit.df, ""terms""), ""dataClasses""), ""names"")[1]
+  fi <- unname(lme4::fixef(fit))[1]
   # ---------------------------------------
   # check amounnt of random intercepts
   # ---------------------------------------
@@ -1183,7 +1185,7 @@ sjp.lme.reprobcurve <- function(fit,
         # do this for each random intercept group
         for (j in 1 : nrow(rand.ef)) {
           # calculate probability for each random effect group
-          mydf.vals$y <- odds.to.prob(rand.ef[j, 1] + mydf.vals$xbeta)
+          mydf.vals$y <- odds.to.prob(fi + rand.ef[j, 1] + mydf.vals$xbeta)
           # add to final data frame
           final.df <- rbind(final.df, cbind(pred = mydf.vals$value,
                                             prob = mydf.vals$y))
@@ -1207,7 +1209,7 @@ sjp.lme.reprobcurve <- function(fit,
           coord_cartesian(ylim = c(0, 1)) +
           labs(x = NULL,
                y = ""Predicted Probability"",
-               title = sprintf(""Preicted Probability of %s on %s"", pred.name, response.name))
+               title = sprintf(""Predicted Probability of %s on %s"", pred.name, response.name))
         # wrap to facets
         if (facet.grid) {
           mp <- mp + facet_wrap( ~ grp,

---FILE: R/sjTabPropTable.R---
@@ -453,7 +453,7 @@ sjt.xtab <- function (var.row,
   css.tdata <- ""padding:0.2cm;""
   css.firstcolborder <- ""border-bottom:1px solid;""
   css.secondtablerow <- ""border-bottom:1px solid; text-align:center;""
-  css.leftalign <- ""text-align:left; vertical-align:top;""
+  css.leftalign <- ifelse(showObserved & showTotalN, ""text-align:left; vertical-align:top;"", ""text-align:left; vertical-align:middle;"")
   css.centeralign <- ""text-align:center;""
   css.lasttablerow <- ifelse(highlightTotal==TRUE, sprintf("" border-bottom:double; background-color:%s;"", highlightColor), "" border-bottom:double;"")
   css.totcol <- ifelse(highlightTotal==TRUE, sprintf("" background-color:%s;"", highlightColor), """")
@@ -747,10 +747,12 @@ sjt.xtab <- function (var.row,
     }
     # create summary row
     if (is.null(fish)) {
-      page.content <- paste(page.content, sprintf(""    <td class=\""summary tdata\"" colspan=\""%i\"">&Chi;<sup>2</sup>=%.3f &middot; df=%i &middot; %s &middot; p=%.3f</td>"", totalncol, chsq$statistic, chsq$parameter, kook, chsq$p.value), sep="""")
+      pvalstring <- ifelse(chsq$p.value < 0.001, ""p&lt;0.001"", sprintf(""p=%.3f"", chsq$p.value))
+      page.content <- paste(page.content, sprintf(""    <td class=\""summary tdata\"" colspan=\""%i\"">&Chi;<sup>2</sup>=%.3f &middot; df=%i &middot; %s &middot; %s</td>"", totalncol, chsq$statistic, chsq$parameter, kook, pvalstring), sep="""")
     }
     else {
-      page.content <- paste(page.content, sprintf(""    <td class=\""summary tdata\"" colspan=\""%i\"">Fisher's p=%.3f &middot; df=%i &middot; %s</td>"", totalncol, fish$p.value, chsq$parameter, kook), sep="""")
+      pvalstring <- ifelse(fish$p.value < 0.001, ""p&lt;0.001"", sprintf(""p=%.3f"", fish$p.value))
+      page.content <- paste(page.content, sprintf(""    <td class=\""summary tdata\"" colspan=\""%i\"">Fisher's %s &middot; df=%i &middot; %s</td>"", totalncol, pvalstring, chsq$parameter, kook), sep="""")
     }
     # close table row
     page.content <- paste(page.content, ""\n  </tr>\n"")"
strengejacke,sjPlot,6f64a88c31abbc9c071a69cbf78d05307ad1ff3f,Daniel Ldecke,d.luedecke@uke.de,2014-12-30T18:25:43Z,Daniel Ldecke,d.luedecke@uke.de,2014-12-30T18:25:43Z,minor fix,NEWS;R/sjPlotGLME.R;README.md,False,True,True,False,3,9,12,"---FILE: NEWS---
@@ -1,7 +1,7 @@
 Version 1.6.7
 ------------------------------------------------------------------------------
 Changes to functions:
-* Added parameter ""vars"" to ""sjp.glmer"" and ""sjp.lmer"" to plot probability curves only for selected variables.
+* Added parameter ""vars"" to ""sjp.glmer"" to plot probability curves only for selected variables.
 * Added parameter ""pvaluesApaStyle"" to various functions. If this parameter is TRUE, p-values less than 0.001 will be indicates as ""p < 0.001"" instead of being rounded to ""p = 0.000"".
 
 Bug fixes:

---FILE: R/sjPlotGLME.R---
@@ -249,11 +249,6 @@ sjp.glmer <- function(fit,
 #'            \item \code{""fe.cor""} for correlation matrix of fixed effects
 #'            \item \code{""re.qq""} for a QQ-plot of random effects (random effects quantiles against standard normal quantiles)
 #'          }
-#' @param vars a numeric vector with column indices of selected variables or a character vector with
-#'          variable names of selected variables from the fitted model, which should be used to plot probability
-#'          curves. This parameter only applies if \code{type} is either \code{""fe.pc""} (resp. \code{""fe.prob""}
-#'          or \code{""fe.pc""} (resp. \code{""re.pc""}). In this case, only probability curves for the selected
-#'          variables specified in \code{""vars""} will be plotted.
 #' @param ri.nr Numeric value. If \code{type = ""re""} and fitted model has more than one random
 #'          intercept, \code{ri.nr} indicates which random effects of which random intercept (or:
 #'          which list element of \code{lme4::ranef}) will be plotted. Default is \code{1},
@@ -374,7 +369,6 @@ sjp.glmer <- function(fit,
 #' @export
 sjp.lmer <- function(fit,
                      type = ""re"",
-                     vars = NULL,
                      ri.nr = 1,
                      title = NULL,
                      geom.size = 3,
@@ -397,7 +391,7 @@ sjp.lmer <- function(fit,
                      printPlot = TRUE) {
   sjp.lme4(fit,
            type,
-           vars,
+           NULL,
            ri.nr,
            title,
            geom.size,

---FILE: README.md---
@@ -37,7 +37,7 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 ### Changelog of current development build 1.6.7-2
 
 #### Changes to functions
-* Added parameter `vars` to `sjp.glmer` and `sjp.lmer` to plot probability curves only for selected variables.
+* Added parameter `vars` to `sjp.glmer` to plot probability curves only for selected variables.
 * Added parameter `pvaluesApaStyle` to various functions. If this parameter is `TRUE`, p-values less than 0.001 will be indicates as `p < 0.001` instead of being rounded to `p = 0.000`.
 
 #### Bug fixes"
strengejacke,sjPlot,f8561bef439b3ff143d79c4434eaf02f7a35406c,Daniel Ldecke,d.luedecke@uke.de,2014-12-30T18:21:27Z,Daniel Ldecke,d.luedecke@uke.de,2014-12-30T18:21:27Z,fixed release version number,man/sjPlot-package.Rd,False,False,False,False,2,2,4,"---FILE: man/sjPlot-package.Rd---
@@ -56,8 +56,8 @@
 \tabular{ll}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.6.7-1\cr
-Date: \tab 2014-12-17\cr
+Version: \tab 1.6.7-2\cr
+Date: \tab 2014-12-30\cr
 License: \tab GPL-3\cr
 }
 }"
strengejacke,sjPlot,a7638ee1d85d1a825f4a2fda0f6a72cd380101de,Daniel Ldecke,d.luedecke@uke.de,2014-12-30T18:20:52Z,Daniel Ldecke,d.luedecke@uke.de,2014-12-30T18:20:52Z,bugs fixed and features added,DESCRIPTION;NEWS;R/helpfunctions.R;R/sjPlotCorr.R;R/sjPlotGroupFrequencies.R;R/sjStatistics.R;R/sjTabCorr.R;R/sjTabLinReg.R;R/sjTabOdds.R;README.md;man/sjp.corr.Rd;man/sjt.corr.Rd;man/sjt.glm.Rd;man/sjt.lm.Rd,False,True,True,False,173,55,228,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.6.7-1
-Date: 2014-12-17
+Version: 1.6.7-2
+Date: 2014-12-30
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Luedecke <d.luedecke@uke.de>
 Description: Collection of several plotting and table output functions for

---FILE: NEWS---
@@ -2,6 +2,11 @@ Version 1.6.7
 ------------------------------------------------------------------------------
 Changes to functions:
 * Added parameter ""vars"" to ""sjp.glmer"" and ""sjp.lmer"" to plot probability curves only for selected variables.
+* Added parameter ""pvaluesApaStyle"" to various functions. If this parameter is TRUE, p-values less than 0.001 will be indicates as ""p < 0.001"" instead of being rounded to ""p = 0.000"".
+
+Bug fixes:
+* Fixed bug with type = ""dots"" in ""sjp.grpfrq"".
+* Fixex bug with predictor labelling in ""sjp.lm"" and ""sjp.glm"" when parameter ""labelPredictors"" was not used.
 
 
 Version 1.6.5

---FILE: R/helpfunctions.R---
@@ -290,21 +290,42 @@ crosstabsum <- function(ftab) {
     if(min(tab$expected)<5 || (min(tab$expected)<10 && chsq$parameter==1)) fish <- fisher.test(ftab, simulate.p.value=TRUE)
     # check whether fisher's test or chi-squared should be printed
     if (is.null(fish)) {
-      modsum <- as.character(as.expression(
-        substitute(""N"" == tn * "","" ~~ chi^2 == c2 * "","" ~~ ""df"" == dft * "","" ~~ phi[c] == kook * "","" ~~ ""p"" == pva,
-                   list(tn=summary(ftab)$n.cases,
-                        c2=sprintf(""%.2f"", chsq$statistic),
-                        dft=c(chsq$parameter),
-                        kook=sprintf(""%.2f"", sjs.cramer(ftab)),
-                        pva=sprintf(""%.3f"", chsq$p.value)))))
+      if (chsq$p.value < 0.001) {
+        modsum <- as.character(as.expression(
+          substitute(""N"" == tn * "","" ~~ chi^2 == c2 * "","" ~~ ""df"" == dft * "","" ~~ phi[c] == kook * "","" ~~ ""p"" < pva,
+                     list(tn=summary(ftab)$n.cases,
+                          c2=sprintf(""%.2f"", chsq$statistic),
+                          dft=c(chsq$parameter),
+                          kook=sprintf(""%.2f"", sjs.cramer(ftab)),
+                          pva=0.001))))
+      }
+      else {
+        modsum <- as.character(as.expression(
+          substitute(""N"" == tn * "","" ~~ chi^2 == c2 * "","" ~~ ""df"" == dft * "","" ~~ phi[c] == kook * "","" ~~ ""p"" == pva,
+                     list(tn=summary(ftab)$n.cases,
+                          c2=sprintf(""%.2f"", chsq$statistic),
+                          dft=c(chsq$parameter),
+                          kook=sprintf(""%.2f"", sjs.cramer(ftab)),
+                          pva=sprintf(""%.3f"", chsq$p.value)))))
+      }
     }
     else {
-      modsum <- as.character(as.expression(
-        substitute(""N"" == tn * "","" ~~ ""df"" == dft * "","" ~~ phi[c] == kook * "","" ~~ ""Fisher's p"" == pva,
-                   list(tn=summary(ftab)$n.cases,
-                        dft=c(chsq$parameter),
-                        kook=sprintf(""%.2f"", sjs.cramer(ftab)),
-                        pva=sprintf(""%.3f"", fish$p.value)))))
+      if (fish$p.value < 0.001) {
+        modsum <- as.character(as.expression(
+          substitute(""N"" == tn * "","" ~~ ""df"" == dft * "","" ~~ phi[c] == kook * "","" ~~ ""Fisher's p"" < pva,
+                     list(tn=summary(ftab)$n.cases,
+                          dft=c(chsq$parameter),
+                          kook=sprintf(""%.2f"", sjs.cramer(ftab)),
+                          pva=0.001))))
+      }
+      else {
+        modsum <- as.character(as.expression(
+          substitute(""N"" == tn * "","" ~~ ""df"" == dft * "","" ~~ phi[c] == kook * "","" ~~ ""Fisher's p"" == pva,
+                     list(tn=summary(ftab)$n.cases,
+                          dft=c(chsq$parameter),
+                          kook=sprintf(""%.2f"", sjs.cramer(ftab)),
+                          pva=sprintf(""%.3f"", fish$p.value)))))
+      }
     }
   }
   # if variables have two categories (2x2 table), use phi to calculate

---FILE: R/sjPlotCorr.R---
@@ -48,6 +48,8 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""ordx"", ""ordy""))
 #'          be plotted to each geom.
 #' @param pvaluesAsNumbers If \code{TRUE}, the significance levels (p-values) are printed as numbers.
 #'          if \code{FALSE} (default), asterisks are used.
+#' @param pvaluesApaStyle if both \code{pvaluesAsNumbers} and \code{pvaluesApaStyle} are \code{TRUE}, p-values
+#'          smaller than 0.001 are abbreviated as \code{p < 0.001}. Else, the p-value is rounded to \code{0.000}.
 #' @param geom.colors A color palette for fillng the geoms. If not specified, the 5th diverging color palette
 #'          from the color brewer palettes (RdBu) is used, resulting in red colors for negative and blue colors
 #'          for positive correlations, that become lighter the weaker the correlations are. Use any
@@ -115,6 +117,7 @@ sjp.corr <- function(data,
                      showCorrelationValueLabels=TRUE,
                      showCorrelationPValues=TRUE,
                      pvaluesAsNumbers=FALSE,
+                     pvaluesApaStyle=TRUE,
                      printPlot=TRUE) {
   # --------------------------------------------------------
   # try to automatically set labels is not passed as parameter
@@ -272,7 +275,13 @@ sjp.corr <- function(data,
       }
     }
     else {
-      cpv <- sprintf(""\n(%.*f)"", decimals, cpvalues$value)
+      if (pvaluesApaStyle) {
+        cpv <- cpvalues$value
+        cpv <- sapply(cpv, function (x) if (x < 0.001) x <- ""\n(< 0.001)"" else x <- sprintf(""\n(%.*f)"", decimals, x))
+      }
+      else {
+        cpv <- sprintf(""\n(%.*f)"", decimals, cpvalues$value)
+      }
     }
   }
   else {

---FILE: R/sjPlotGroupFrequencies.R---
@@ -481,10 +481,10 @@ sjp.grpfrq <- function(varCount,
     miss <- as.numeric(as.character(allgroups[!allgroups %in% mydat$group]))
     # retrieve subset of all rows where group is from lowest group-value to 
     # missing group
-    dummy1 <- mydat[apply(mydat, MARGIN=1, function(xy) all(xy[2]<miss)),]
+    dummy1 <- mydat[apply(mydat, MARGIN=1, function(xy) all(xy[2] < miss)), ]
     # retrieve subset of all rows where group is from missing group to
     # highest group-value
-    dummy2 <- mydat[apply(mydat, MARGIN=1, function(xy) all(xy[2]>miss)),]
+    dummy2 <- mydat[apply(mydat, MARGIN=1, function(xy) all(xy[2] > miss)), ]
     # create dummy-data frame that contains the missing row with zero-values
     emptyrows <- as.data.frame(cbind(count=c(1:catcount), group=miss, frq=0, layer=1:catcount))
     emptyrows$count <- as.factor(as.character(emptyrows$count))
@@ -555,9 +555,17 @@ sjp.grpfrq <- function(varCount,
           xsub <- as.numeric(na.omit(xsub))
           ysub <- as.numeric(na.omit(ysub))
           wt <- wilcox.test(xsub ~ ysub)
-          modsum <- as.character(as.expression(
-            substitute(p[pgrp] == pval, list(pgrp=sprintf(""(%i|%i)"", i, j),
-                                        pval=sprintf(""%.3f"", wt$p.value)))))
+          
+          if (wt$p.value < 0.001) {
+            modsum <- as.character(as.expression(
+              substitute(p[pgrp] < pval, list(pgrp=sprintf(""(%i|%i)"", i, j),
+                                               pval=0.001))))
+          }
+          else {
+            modsum <- as.character(as.expression(
+              substitute(p[pgrp] == pval, list(pgrp=sprintf(""(%i|%i)"", i, j),
+                                               pval=sprintf(""%.3f"", wt$p.value)))))
+          }
           completeString <- sprintf(""%s * \"",\"" ~ ~ %s"", 
                                     completeString, 
                                     modsum)
@@ -785,16 +793,11 @@ sjp.grpfrq <- function(varCount,
   # init shaded rectangles for plot
   ganno <- NULL
   # check whether we have dots or bars
-  if (type==""dots"" || type==""dotlines"") {
+  if (type==""dots"") {
     # position_dodge displays dots in a dodged position so we avoid overlay here. This may lead
     # to a more difficult distinction of group belongings, since the dots are ""horizontally spread""
     # over the digram. For a better overview, we can add a ""PlotAnnotation"" (see ""showPlotAnnotation) here.
-    geob <- geom_point(position=position_dodge(0.8), size=geom.size, shape=21)
-    # connect dots with lines?
-    if (type==""dotlines"") {
-      geob <- geom_point(position=position_dodge(0.8), size=geom.size, shape=21) + geom_line()
-      type  <- ""dots""
-    }
+    geob <- geom_point(position=position_dodge(0.8), size=geom.size, shape=16)
     # create shaded rectangle, so we know which dots belong to the same category
     if (showPlotAnnotation) {
       ganno <- annotate(""rect"", xmin=mydat$layer-0.4, xmax=mydat$layer+0.4, ymin=lower_lim, ymax=upper_lim, fill=""grey80"", alpha=0.1)
@@ -1086,10 +1089,18 @@ sjp.grpfrq <- function(varCount,
                    fill = fcsp)
   }
   else {
-    baseplot <- ggplot(mydat, 
-                       aes(x = factor(count), 
-                           y = frq, 
-                           fill = group))
+    if (type == ""dots"") {
+      baseplot <- ggplot(mydat, 
+                         aes(x = factor(count), 
+                             y = frq, 
+                             colour = group))
+    }
+    else {
+      baseplot <- ggplot(mydat, 
+                         aes(x = factor(count), 
+                             y = frq, 
+                             fill = group))
+    }
     # ---------------------------------------------------------
     # check whether we have dots plotted, and if so, use annotation
     # We have to use annotation first, because the diagram's layers are plotted

---FILE: R/sjStatistics.R---
@@ -193,7 +193,14 @@ sjs.mwu <- function(var, grp, distribution=""asymptotic"", weights=NULL) {
         else {
           cat(sprintf(""Groups %i = %s (n = %i) | %i = %s (n = %i):\n"", i, labels[i], length(xsub[which(ysub.n==i)]), j, labels[j], length(xsub[which(ysub.n==j)])))
         }
-        cat(sprintf(""  U = %.3f, W = %.3f, p = %.3f, Z = %.3f\n  effect-size r = %.3f\n  rank-mean(%i) = %.2f\n  rank-mean(%i) = %.2f\n\n"", u, w, p, z, r, i, rkm.i, j, rkm.j))
+        if (p < 0.001) {
+          p  <- 0.001
+          p.string <- ""<""
+        }
+        else {
+          p.string <- ""=""
+        }
+        cat(sprintf(""  U = %.3f, W = %.3f, p %s %.3f, Z = %.3f\n  effect-size r = %.3f\n  rank-mean(%i) = %.2f\n  rank-mean(%i) = %.2f\n\n"", u, w, p.string, p, z, r, i, rkm.i, j, rkm.j))
         df <- rbind(df, cbind(grp1=i, grp2=j, u=u, w=w, p=p, z=z, r=r, rank.mean.grp1=rkm.i, rank.mean.grp2=rkm.j))
       }
     }
@@ -203,9 +210,17 @@ sjs.mwu <- function(var, grp, distribution=""asymptotic"", weights=NULL) {
     message(""Performing Kruskal-Wallis-Test..."")
     message(""---------------------------------"")
     kw <- kruskal.test(var, grp)
-    cat(sprintf(""chi-squared = %.3f\n"",kw$statistic ))
-    cat(sprintf(""df = %i\n"",kw$parameter ))
-    cat(sprintf(""p = %.3f\n"",kw$p.value ))
+    cat(sprintf(""chi-squared = %.3f\n"", kw$statistic))
+    cat(sprintf(""df = %i\n"", kw$parameter))
+    if (kw$p.value < 0.001) {
+      p  <- 0.001
+      p.string <- ""<""
+    }
+    else {
+      p <- kw$p.value
+      p.string <- ""=""
+    }
+    cat(sprintf(""p %s %.3f\n"", p.string, p))
   }
   invisible(df)
 }

---FILE: R/sjTabCorr.R---
@@ -20,6 +20,8 @@
 #'          be printed or not.
 #' @param pvaluesAsNumbers If \code{TRUE}, the significance levels (p-values) are printed as numbers.
 #'          if \code{FALSE} (default), asterisks are used.
+#' @param pvaluesApaStyle if both \code{pvaluesAsNumbers} and \code{pvaluesApaStyle} are \code{TRUE}, p-values
+#'          smaller than 0.001 are abbreviated as \code{p < 0.001}. Else, the p-value is rounded to \code{0.000}.
 #' @param fadeNS If \code{TRUE} (default), non-significant correlation-values appear faded (by using
 #'          a lighter grey text color).
 #' @param file The destination file, which will be in html-format. If no filepath is specified,
@@ -151,6 +153,7 @@ sjt.corr <- function (data,
                       title=NULL,
                       showPValues=TRUE,
                       pvaluesAsNumbers=FALSE,
+                      pvaluesApaStyle=TRUE,
                       fadeNS=TRUE,
                       file=NULL, 
                       varlabels=NULL,
@@ -274,6 +277,9 @@ sjt.corr <- function (data,
       }
     }
     cpvalues <- apply(cpvalues, c(1,2), fun.star)
+    if (pvaluesAsNumbers && pvaluesApaStyle) {
+      cpvalues <- apply(cpvalues, c(1,2), function (x) if (x < 0.001) x <- ""&lt;&nbsp;0.001"" else x <- sprintf(""%.*f"", digits, x))
+    }
   }
   else {
     showPValues <- FALSE
@@ -412,7 +418,7 @@ sjt.corr <- function (data,
               # --------------------------------------------------------
               # if we have p-values as number, print them in new row
               # --------------------------------------------------------
-              cellval <- sprintf(""%s<br><span class=\""pval\"">(%.*f)</span>"", cellval, digits, cpvalues[i,j])
+              cellval <- sprintf(""%s<br><span class=\""pval\"">(%s)</span>"", cellval, cpvalues[i,j])
             }
             else {
               # --------------------------------------------------------

---FILE: R/sjTabLinReg.R---
@@ -49,6 +49,8 @@
 #' @param digits.summary Amount of decimals for values in model summary.
 #' @param pvaluesAsNumbers If \code{TRUE}, p-values are shown as numbers. If \code{FALSE} (default),
 #'          p-values are indicated by asterisks.
+#' @param pvaluesApaStyle if both \code{pvaluesAsNumbers} and \code{pvaluesApaStyle} are \code{TRUE}, p-values
+#'          smaller than 0.001 are abbreviated as \code{p < 0.001}. Else, the p-value is rounded to \code{0.000}.
 #' @param boldpvalues If \code{TRUE} (default), significant p-values are shown bold faced.
 #' @param separateConfColumn if \code{TRUE}, the CI values are shown in a separate table column.
 #'          Default is \code{FALSE}.
@@ -240,6 +242,7 @@ sjt.lm <- function (...,
                     digits.sb=2,
                     digits.summary=3,
                     pvaluesAsNumbers=FALSE,
+                    pvaluesApaStyle=TRUE,
                     boldpvalues=TRUE,
                     separateConfColumn=FALSE,
                     newLineConf=TRUE,
@@ -459,7 +462,7 @@ sjt.lm <- function (...,
       lab <- autoSetVariableLabels(fit$model[, i])
       # if not, use coefficient name
       if (is.null(lab)) {
-        lab <- row.names(coeffs)[-1][i]
+        lab <- row.names(coeffs)[i]
       }
       labelPredictors <- c(labelPredictors, lab)
     }
@@ -485,9 +488,23 @@ sjt.lm <- function (...,
     })
   }
   else {
+    if (boldpvalues) {
+      sb1 <- ""<b>""
+      sb2 <- ""</b>""
+    }
+    else {
+      sb1 <- sb2 <- """"
+    }
     pv <- apply(pv, c(1,2), function(x) {
-      if (x <0.05 && boldpvalues) {
-        x <- sprintf(""<b>%.*f</b>"", digits.p, x)      }
+      if (x <0.05) {
+        if (x < 0.001 && pvaluesApaStyle) {
+          x <- sprintf(""%s&lt;&nbsp;0.001%s"", sb1, sb2)
+        }
+        else {
+          x <- sprintf(""%s%.*f%s"", sb1, digits.p, x, sb2)
+        }
+        
+      }
       else {
         x <- sprintf(""%.*f"", digits.p, x) 
       }

---FILE: R/sjTabOdds.R---
@@ -49,6 +49,8 @@
 #'          as they are provided by the \code{\link{summary}} function.
 #' @param pvaluesAsNumbers If \code{TRUE}, p-values are shown as numbers. If \code{FALSE} (default),
 #'          p-values are indicated by asterisks.
+#' @param pvaluesApaStyle if both \code{pvaluesAsNumbers} and \code{pvaluesApaStyle} are \code{TRUE}, p-values
+#'          smaller than 0.001 are abbreviated as \code{p < 0.001}. Else, the p-value is rounded to \code{0.000}.
 #' @param boldpvalues If \code{TRUE} (default), significant p-values are shown bold faced.
 #' @param showConfInt If \code{TRUE} (default), the confidence intervall is also printed to the table. Use
 #'          \code{FALSE} to omit the CI in the table.
@@ -213,6 +215,7 @@ sjt.glm <- function (...,
                      digits.summary=3,
                      exp.coef=TRUE,
                      pvaluesAsNumbers=FALSE,
+                     pvaluesApaStyle=TRUE,
                      boldpvalues=TRUE,
                      showConfInt=TRUE,
                      showStdError=FALSE,
@@ -439,7 +442,7 @@ sjt.glm <- function (...,
       lab <- autoSetVariableLabels(fit$model[, i])
       # if not, use coefficient name
       if (is.null(lab)) {
-        lab <- row.names(coeffs)[-1][i]
+        lab <- row.names(coeffs)[i]
       }
       labelPredictors <- c(labelPredictors, lab)
     }
@@ -465,9 +468,23 @@ sjt.glm <- function (...,
     })
   }
   else {
+    if (boldpvalues) {
+      sb1 <- ""<b>""
+      sb2 <- ""</b>""
+    }
+    else {
+      sb1 <- sb2 <- """"
+    }
     pv <- apply(pv, c(1,2), function(x) {
-      if (x <0.05 && boldpvalues) {
-        x <- sprintf(""<b>%.*f</b>"", digits.p, x)      }
+      if (x <0.05) {
+        if (x < 0.001 && pvaluesApaStyle) {
+          x <- sprintf(""%s&lt;&nbsp;0.001%s"", sb1, sb2)
+        }
+        else {
+          x <- sprintf(""%s%.*f%s"", sb1, digits.p, x, sb2)
+        }
+        
+      }
       else {
         x <- sprintf(""%.*f"", digits.p, x) 
       }

---FILE: README.md---
@@ -34,11 +34,15 @@ install.packages(""sjPlot"")
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since this package makes heavy use of the [ggplot-package](http://cran.r-project.org/web/packages/ggplot2/index.html), consider citing this package as well.
 
 
-### Changelog of current stable build 1.6.7-1
+### Changelog of current development build 1.6.7-2
 
 #### Changes to functions
 * Added parameter `vars` to `sjp.glmer` and `sjp.lmer` to plot probability curves only for selected variables.
+* Added parameter `pvaluesApaStyle` to various functions. If this parameter is `TRUE`, p-values less than 0.001 will be indicates as `p < 0.001` instead of being rounded to `p = 0.000`.
 
+#### Bug fixes
+* Fixed bug with `type = ""dots""` in `sjp.grpfrq`.
+* Fixex bug with predictor labelling in `sjp.lm` and `sjp.glm` when parameter `labelPredictors` was not used.
 
 ### Changelog of current stable build 1.6.5
 

---FILE: man/sjp.corr.Rd---
@@ -10,7 +10,7 @@ sjp.corr(data, title = NULL, axisLabels = NULL, type = ""circle"",
   breakTitleAt = 50, breakLabelsAt = 20, hideLegend = TRUE,
   legendTitle = NULL, showCorrelationValueLabels = TRUE,
   showCorrelationPValues = TRUE, pvaluesAsNumbers = FALSE,
-  printPlot = TRUE)
+  pvaluesApaStyle = TRUE, printPlot = TRUE)
 }
 \arguments{
 \item{data}{A correlation object, built with the R-\code{\link{cor}}-function, or a data frame
@@ -68,6 +68,9 @@ be plotted to each geom.}
 \item{pvaluesAsNumbers}{If \code{TRUE}, the significance levels (p-values) are printed as numbers.
 if \code{FALSE} (default), asterisks are used.}
 
+\item{pvaluesApaStyle}{if both \code{pvaluesAsNumbers} and \code{pvaluesApaStyle} are \code{TRUE}, p-values
+smaller than 0.001 are abbreviated as \code{p < 0.001}. Else, the p-value is rounded to \code{0.000}.}
+
 \item{printPlot}{If \code{TRUE} (default), plots the results as graph. Use \code{FALSE} if you don't
 want to plot any graphs. In either case, the ggplot-object will be returned as value.}
 }

---FILE: man/sjt.corr.Rd---
@@ -6,9 +6,10 @@
 \usage{
 sjt.corr(data, missingDeletion = ""pairwise"", corMethod = ""spearman"",
   title = NULL, showPValues = TRUE, pvaluesAsNumbers = FALSE,
-  fadeNS = TRUE, file = NULL, varlabels = NULL, breakLabelsAt = 40,
-  digits = 3, triangle = ""both"", val.rm = NULL, stringDiagonal = NULL,
-  encoding = NULL, CSS = NULL, useViewer = TRUE, no.output = FALSE)
+  pvaluesApaStyle = TRUE, fadeNS = TRUE, file = NULL, varlabels = NULL,
+  breakLabelsAt = 40, digits = 3, triangle = ""both"", val.rm = NULL,
+  stringDiagonal = NULL, encoding = NULL, CSS = NULL, useViewer = TRUE,
+  no.output = FALSE)
 }
 \arguments{
 \item{data}{A correlation object, built with the R-\code{\link{cor}}-function, or a data frame
@@ -28,6 +29,9 @@ be printed or not.}
 \item{pvaluesAsNumbers}{If \code{TRUE}, the significance levels (p-values) are printed as numbers.
 if \code{FALSE} (default), asterisks are used.}
 
+\item{pvaluesApaStyle}{if both \code{pvaluesAsNumbers} and \code{pvaluesApaStyle} are \code{TRUE}, p-values
+smaller than 0.001 are abbreviated as \code{p < 0.001}. Else, the p-value is rounded to \code{0.000}.}
+
 \item{fadeNS}{If \code{TRUE} (default), non-significant correlation-values appear faded (by using
 a lighter grey text color).}
 

---FILE: man/sjt.glm.Rd---
@@ -12,12 +12,12 @@ sjt.glm(..., file = NULL, labelPredictors = NULL,
   stringOR = ""OR"", stringCI = ""CI"", stringSE = ""std. Error"",
   stringP = ""p"", digits.est = 2, digits.p = 3, digits.ci = 2,
   digits.se = 2, digits.summary = 3, exp.coef = TRUE,
-  pvaluesAsNumbers = FALSE, boldpvalues = TRUE, showConfInt = TRUE,
-  showStdError = FALSE, separateConfColumn = FALSE, newLineConf = TRUE,
-  showAbbrHeadline = TRUE, showPseudoR = TRUE, showLogLik = FALSE,
-  showAIC = FALSE, showChi2 = FALSE, showFamily = FALSE,
-  cellSpacing = 0.2, encoding = NULL, CSS = NULL, useViewer = TRUE,
-  no.output = FALSE)
+  pvaluesAsNumbers = FALSE, pvaluesApaStyle = TRUE, boldpvalues = TRUE,
+  showConfInt = TRUE, showStdError = FALSE, separateConfColumn = FALSE,
+  newLineConf = TRUE, showAbbrHeadline = TRUE, showPseudoR = TRUE,
+  showLogLik = FALSE, showAIC = FALSE, showChi2 = FALSE,
+  showFamily = FALSE, cellSpacing = 0.2, encoding = NULL, CSS = NULL,
+  useViewer = TRUE, no.output = FALSE)
 }
 \arguments{
 \item{...}{One or more fitted \code{\link{glm}}-objects.}
@@ -75,6 +75,9 @@ as they are provided by the \code{\link{summary}} function.}
 \item{pvaluesAsNumbers}{If \code{TRUE}, p-values are shown as numbers. If \code{FALSE} (default),
 p-values are indicated by asterisks.}
 
+\item{pvaluesApaStyle}{if both \code{pvaluesAsNumbers} and \code{pvaluesApaStyle} are \code{TRUE}, p-values
+smaller than 0.001 are abbreviated as \code{p < 0.001}. Else, the p-value is rounded to \code{0.000}.}
+
 \item{boldpvalues}{If \code{TRUE} (default), significant p-values are shown bold faced.}
 
 \item{showConfInt}{If \code{TRUE} (default), the confidence intervall is also printed to the table. Use

---FILE: man/sjt.lm.Rd---
@@ -13,7 +13,7 @@ sjt.lm(..., file = NULL, labelPredictors = NULL,
   stringP = ""p"", showConfInt = TRUE, showStdBeta = FALSE,
   showStdError = FALSE, digits.est = 2, digits.p = 3, digits.ci = 2,
   digits.se = 2, digits.sb = 2, digits.summary = 3,
-  pvaluesAsNumbers = FALSE, boldpvalues = TRUE,
+  pvaluesAsNumbers = FALSE, pvaluesApaStyle = TRUE, boldpvalues = TRUE,
   separateConfColumn = FALSE, newLineConf = TRUE, showAbbrHeadline = TRUE,
   showR2 = TRUE, showFStat = FALSE, showAIC = FALSE, cellSpacing = 0.2,
   encoding = NULL, CSS = NULL, useViewer = TRUE, no.output = FALSE)
@@ -83,6 +83,9 @@ Default is \code{FALSE}.}
 \item{pvaluesAsNumbers}{If \code{TRUE}, p-values are shown as numbers. If \code{FALSE} (default),
 p-values are indicated by asterisks.}
 
+\item{pvaluesApaStyle}{if both \code{pvaluesAsNumbers} and \code{pvaluesApaStyle} are \code{TRUE}, p-values
+smaller than 0.001 are abbreviated as \code{p < 0.001}. Else, the p-value is rounded to \code{0.000}.}
+
 \item{boldpvalues}{If \code{TRUE} (default), significant p-values are shown bold faced.}
 
 \item{separateConfColumn}{if \code{TRUE}, the CI values are shown in a separate table column."
strengejacke,sjPlot,3725056c14ac050bb5aef5837644fce8fd9628ec,Daniel Ldecke,d.luedecke@uke.de,2014-12-14T20:09:25Z,Daniel Ldecke,d.luedecke@uke.de,2014-12-14T20:09:25Z,"added feaures to sjp.(g)lmer, bug fixes",DESCRIPTION;NAMESPACE;NEWS;R/sjPlotGLME.R;R/sjPlotLinreg.R;R/sjPlotOdds.R;R/sjStatistics.R;R/sjTabLinReg.R;README.md;man/efc.Rd;man/sj.setGeomColors.Rd;man/sjPlot-package.Rd;man/sjc.cluster.Rd;man/sjc.dend.Rd;man/sjc.elbow.Rd;man/sjc.grpdisc.Rd;man/sjc.kgap.Rd;man/sjc.qclus.Rd;man/sji.SPSS.Rd;man/sji.convertToLabel.Rd;man/sji.convertToValue.Rd;man/sji.getValueLabels.Rd;man/sji.getVariableLabels.Rd;man/sji.setValueLabels.Rd;man/sji.setVariableLabels.Rd;man/sji.viewSPSS.Rd;man/sjp.aov1.Rd;man/sjp.chi2.Rd;man/sjp.corr.Rd;man/sjp.emm.int.Rd;man/sjp.frq.Rd;man/sjp.glm.Rd;man/sjp.glm.ma.Rd;man/sjp.glmer.Rd;man/sjp.glmm.Rd;man/sjp.grpfrq.Rd;man/sjp.int.Rd;man/sjp.likert.Rd;man/sjp.lm.Rd;man/sjp.lm.ma.Rd;man/sjp.lm1.Rd;man/sjp.lmer.Rd;man/sjp.lmm.Rd;man/sjp.pca.Rd;man/sjp.reglin.Rd;man/sjp.scatter.Rd;man/sjp.setTheme.Rd;man/sjp.stackfrq.Rd;man/sjp.vif.Rd;man/sjp.xtab.Rd;man/sjs.aov1.levene.Rd;man/sjs.chi2.gof.Rd;man/sjs.cramer.Rd;man/sjs.cronbach.Rd;man/sjs.etasq.Rd;man/sjs.mic.Rd;man/sjs.mwu.Rd;man/sjs.phi.Rd;man/sjs.reliability.Rd;man/sjs.se.Rd;man/sjs.stdb.Rd;man/sjs.table.values.Rd;man/sjt.corr.Rd;man/sjt.df.Rd;man/sjt.frq.Rd;man/sjt.glm.Rd;man/sjt.grpmean.Rd;man/sjt.itemanalysis.Rd;man/sjt.lm.Rd;man/sjt.pca.Rd;man/sjt.stackfrq.Rd;man/sjt.xtab.Rd;man/sju.adjustPlotRange.y.Rd;man/sju.dicho.Rd;man/sju.groupString.Rd;man/sju.groupVar.Rd;man/sju.groupVarLabels.Rd;man/sju.mean.n.Rd;man/sju.recode.Rd;man/sju.recodeTo.Rd;man/sju.setNA.Rd;man/sju.strpos.Rd;man/sju.weight.Rd;man/sju.weight2.Rd;man/sju.wordwrap.Rd,False,True,True,False,290,107,397,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.6.1-7
-Date: 2014-12-13
+Version: 1.6.1-8
+Date: 2014-12-14
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Luedecke <d.luedecke@uke.de>
 Description: Collection of several plotting and table output functions for

---FILE: NAMESPACE---
@@ -1,4 +1,4 @@
-# Generated by roxygen2 (4.0.2): do not edit by hand
+# Generated by roxygen2 (4.1.0): do not edit by hand
 
 export(sjc.cluster)
 export(sjc.dend)
@@ -39,7 +39,6 @@ export(sjp.stackfrq)
 export(sjp.vif)
 export(sjp.xtab)
 export(sjs.aov1.levene)
-export(sjs.betaCoef)
 export(sjs.chi2.gof)
 export(sjs.cramer)
 export(sjs.cronbach)
@@ -49,6 +48,7 @@ export(sjs.mwu)
 export(sjs.phi)
 export(sjs.reliability)
 export(sjs.se)
+export(sjs.stdb)
 export(sjs.table.values)
 export(sjt.corr)
 export(sjt.df)

---FILE: NEWS---
@@ -1,11 +1,13 @@
-Version 1.6.1
+Version 1.6.5
 ------------------------------------------------------------------------------
 New functions:
 * New function ""sjp.int"", which can plot regression lines or probability curves of interaction effects in (generalized) linear (mixed effects) models, i.e. fitted models of class ""lm"", ""glm"", ""lmerMod"" and ""glmerMod"" are covered by this function.
 
 Changes to functions:
+* Renamed ""sjs.betaCoef"" to ""sjs.stdb"".
 * ""sjp.lm.int"" was merged with function ""sjp.int"".
 * Added parameter ""ri.nr"" to ""sjp.glmer"" and ""sjp.lmer"" to select which random effects of which random intercept to plot, in case the model has multiple random intercepts.
+* Added parameters ""showValueLabels"", ""labelDigits"" and ""showPValueLabels"" to ""sjp.glmer"" and ""sjp.lmer"" to plot beta or odds ratio values and p-value-stars to fixed effects plots.
 * ""sjt.xtab"" can now show/hide observed values in table cells with ""showObserved"" parameter.
 * ""sjt.df"" now distinguishes more variable / vector types (like ordinal and categorial, instead of factor only, or double, integer and numeric).
 * ""sjp.lm1"" no longer requires the data frame used to fit the model.

---FILE: R/sjPlotGLME.R---
@@ -1,5 +1,5 @@
 # bind global variables
-if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""nQQ"", ""ci"", ""fixef"", ""fade"", ""lower.CI"", ""upper.CI"", ""pred"", ""prob""))
+if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""nQQ"", ""ci"", ""fixef"", ""fade"", ""lower.CI"", ""upper.CI"", ""pred"", ""prob"", ""p""))
 
 
 #' @title Plot odds ratios (forest plots) of generalized linear mixed effects models
@@ -68,6 +68,11 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""nQQ"", ""ci"", ""fixef"", ""fa
 #'          on the plot type is chosen.
 #' @param interceptLineType The linetype of the intercept line (zero point). Default is \code{2} (dashed line).
 #' @param interceptLineColor The color of the intercept line. Default value is \code{""grey70""}.
+#' @param showValueLabels Whether odds ratio values should be plotted to each dot or not.
+#' @param labelDigits The amount of digits for rounding the estimations (see \code{showValueLabels}).
+#'          Default is 2, i.e. estimators have 2 digits after decimal point.
+#' @param showPValueLabels Whether the significance levels of each coefficient should be appended
+#'          to values or not.
 #' @param facet.grid \code{TRUE} when each plot should be plotted separately instead of
 #'          an integrated (faceted) single graph.
 #' @param free.scale If \code{TRUE} and \code{facet.grid=TRUE}, each facet grid gets its own fitted scale. If
@@ -176,6 +181,9 @@ sjp.glmer <- function(fit,
                       free.scale = FALSE,
                       interceptLineType = 2,
                       interceptLineColor = ""grey70"",
+                      showValueLabels = TRUE, 
+                      labelDigits = 2,
+                      showPValueLabels = TRUE,
                       fade.ns = FALSE,
                       show.se = FALSE,
                       printPlot = TRUE) {
@@ -198,6 +206,9 @@ sjp.glmer <- function(fit,
            axisTitle.y,
            interceptLineType,
            interceptLineColor,
+           showValueLabels, 
+           labelDigits,
+           showPValueLabels,
            facet.grid,
            free.scale,
            fade.ns,
@@ -269,6 +280,12 @@ sjp.glmer <- function(fit,
 #'          on the plot type is chosen.
 #' @param interceptLineType The linetype of the intercept line (zero point). Default is \code{2} (dashed line).
 #' @param interceptLineColor The color of the intercept line. Default value is \code{""grey70""}.
+#' @param showValueLabels Whether the beta and standardized beta values should be plotted 
+#'          to each dot or not.
+#' @param labelDigits The amount of digits for rounding the estimations (see \code{showValueLabels}).
+#'          Default is 2, i.e. estimators have 2 digits after decimal point.
+#' @param showPValueLabels Whether the significance levels of each coefficient should be appended
+#'          to values or not
 #' @param facet.grid \code{TRUE} when each plot should be plotted separately instead of
 #'          an integrated (faceted) single graph.
 #' @param free.scale If \code{TRUE} and \code{facet.grid=TRUE}, each facet grid gets its own fitted scale. If
@@ -358,6 +375,9 @@ sjp.lmer <- function(fit,
                      axisTitle.y = NULL,
                      interceptLineType = 2,
                      interceptLineColor = ""grey70"",
+                     showValueLabels=TRUE, 
+                     labelDigits=2,
+                     showPValueLabels=TRUE,
                      facet.grid = TRUE,
                      free.scale = FALSE,
                      fade.ns = FALSE,
@@ -377,6 +397,9 @@ sjp.lmer <- function(fit,
            axisTitle.y,
            interceptLineType,
            interceptLineColor,
+           showValueLabels, 
+           labelDigits,
+           showPValueLabels,
            facet.grid,
            free.scale,
            fade.ns,
@@ -396,10 +419,13 @@ sjp.lme4  <- function(fit,
                       stringIntercept,
                       sort.coef,
                       pred.labels,
-                      axisTitle.x = NULL,
-                      axisTitle.y = NULL,
+                      axisTitle.x,
+                      axisTitle.y,
                       interceptLineType,
                       interceptLineColor,
+                      showValueLabels, 
+                      labelDigits,
+                      showPValueLabels,
                       facet.grid,
                       free.scale,
                       fade.ns,
@@ -511,7 +537,7 @@ sjp.lme4  <- function(fit,
             # (group levels / labels) have to be re-sorted for
             # each coefficient, which is not possible with facet.grids
             # ---------------------------------------
-            message(""Sorting each group of random intercept ('sort.all') is not possible when 'facet.grids = TRUE'."")
+            message(""Sorting each group of random intercept ('sort.all') is not possible when 'facet.grid = TRUE'."")
           }
           else {
             # ---------------------------------------
@@ -538,6 +564,8 @@ sjp.lme4  <- function(fit,
       # axis labels can be sorted accordingly later
       # ---------------------------------------
       tmp$sorting <- reihe
+      # no p-values for random effects
+      tmp$p <- """"
       # ---------------------------------------
       # add to final data frame
       # ---------------------------------------
@@ -560,10 +588,60 @@ sjp.lme4  <- function(fit,
       mydf <- as.data.frame(cbind(OR = lme4::fixef(fit),
                                   lme4::confint.merMod(fit, method = ""Wald"")))
     }
+    # ----------------------------
+    # print p-values in bar charts
+    # ----------------------------
+    # retrieve sigificance level of independent variables (p-values)
+    pv <- coef(summary(fit))[,4]
+    # for better readability, convert p-values to asterisks
+    # with:
+    # p < 0.001 = ***
+    # p < 0.01 = **
+    # p < 0.05 = *
+    # retrieve odds ratios
+    if (fun == ""glm"") {
+      ov <- exp(lme4::fixef(fit))
+    }
+    else {
+      ov <- lme4::fixef(fit)
+    }
+    # init data column for p-values
+    ps <- NULL
+    for (i in 1:length(pv)) {
+      ps[i] <- c("""")
+    }
+    # ----------------------------
+    # copy OR-values into data column
+    # ----------------------------
+    if (showValueLabels) {
+      for (i in 1:length(pv)) {
+        ps[i] <- sprintf(""%.*f"", labelDigits, ov[i])
+      }
+    }
+    # ----------------------------
+    # copy p-values into data column
+    # ----------------------------
+    if (showPValueLabels) {
+      for (i in 1:length(pv)) {
+        if (pv[i] >= 0.05) {
+        }
+        else if (pv[i] >= 0.01 && pv[i] < 0.05) {
+          ps[i] <- paste(ps[i], ""*"")
+        }
+        else if (pv[i] >= 0.001 && pv[i] < 0.01) {
+          ps[i] <- paste(ps[i], ""**"")
+        }
+        else {
+          ps[i] <- paste(ps[i], ""***"")
+        }
+      }
+    }
+    # bind p-values
+    mydf$p <- ps
     # ---------------------------------------
     # set proper column names
     # ---------------------------------------
-    colnames(mydf) <- c(""OR"", ""lower.CI"", ""upper.CI"")
+    colnames(mydf) <- c(""OR"", ""lower.CI"", ""upper.CI"", ""p"")
     # ---------------------------------------
     # just one group, so no faceting needed
     # ---------------------------------------
@@ -648,7 +726,8 @@ sjp.lme4  <- function(fit,
   # odds ratios should be faded.
   # ---------------------------------------
   if (fade.ns == TRUE) {
-    mydf$fade <- (mydf$lower.CI < 1 & mydf$upper.CI > 1)
+    interc <- ifelse (fun == ""glm"", 1, 0)
+    mydf$fade <- (mydf$lower.CI < interc & mydf$upper.CI > interc)
   }
   else {
     mydf$fade <- FALSE
@@ -679,6 +758,9 @@ sjp.lme4  <- function(fit,
                  linetype = interceptLineType,
                  color = interceptLineColor) +
       geom_point(size = geom.size) +
+      # print value labels and p-values
+      geom_text(aes(label = p, y = OR), 
+                vjust = -0.7) +
       # ---------------------------------------
       # labels in sorted order
       # ---------------------------------------
@@ -741,6 +823,11 @@ sjp.lme4  <- function(fit,
   # facet grid means, just one plot
   # ---------------------------------------
   if (facet.grid) {
+    # ---------------------------------------
+    # for random effects, no title is displayed in facet. so
+    # tell user via message that random effects are plotted
+    # ---------------------------------------
+    if (type == ""re"") message(""Plotting random effects..."")
     me.plot <- plot.effe(mydf,
                          title,
                          facet.grid,

---FILE: R/sjPlotLinreg.R---
@@ -11,7 +11,7 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""vars"", ""Beta"", ""xv"", ""lo
 #'              \item \code{\link{sjp.reglin}}
 #'              \item \code{\link{sjp.int}}
 #'              \item \code{\link{sjp.scatter}}
-#'              \item  \code{\link{sjs.betaCoef}}
+#'              \item  \code{\link{sjs.stdb}}
 #'             }
 #' 
 #' @description Plot beta coefficients (estimates) of linear regressions with confidence intervalls as dot plot
@@ -173,7 +173,7 @@ sjp.lm <- function(fit,
   # retrieve betas, leave out intercept ([-1])
   bv <- coef(fit)[-1]
   # retrieve standardized betas
-  stdbv <- sjs.betaCoef(fit)
+  stdbv <- sjs.stdb(fit)
   # init data column for p-values
   ps <- sprintf(""%.*f"", labelDigits, bv)
   pstdbv <- sprintf(""%.*f"", labelDigits, stdbv)
@@ -230,7 +230,7 @@ sjp.lm <- function(fit,
   # case no values are drawn, we simply use an empty string.
   # finally, we need the p-values of the coefficients, because the value
   # labels may have different colours according to their significance level
-  betas <- cbind(tmp, c(ps), sjs.betaCoef(fit), c(pstdbv), pv)
+  betas <- cbind(tmp, c(ps), sjs.stdb(fit), c(pstdbv), pv)
   # --------------------------------------------------------
   # check if user defined labels have been supplied
   # if not, use variable names from data frame

---FILE: R/sjPlotOdds.R---
@@ -68,8 +68,7 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""OR"", ""lower"", ""upper"", ""
 #'          Default is \code{FALSE}. Please note that due to exp-transformation of
 #'          estimates, the intercept in some cases can not be calculated, thus the
 #'          function call is interrupted and no plot printed.
-#' @param showValueLabels Whether the beta and standardized beta values should be plotted
-#'          to each dot or not.
+#' @param showValueLabels Whether odds ratio values should be plotted to each dot or not.
 #' @param labelDigits The amount of digits for rounding the estimations (see \code{showValueLabels}).
 #'          Default is 2, i.e. estimators have 2 digits after decimal point.
 #' @param showPValueLabels Whether the significance levels of each coefficient should be appended

---FILE: R/sjStatistics.R---
@@ -65,7 +65,7 @@ sjs.etasq <- function(...) {
 
 
 #' @title Retrieve std. beta coefficients of lm
-#' @name sjs.betaCoef
+#' @name sjs.stdb
 #' @description Returns the standardized beta coefficients of a fitted linear model.
 #' 
 #' @seealso \itemize{
@@ -89,10 +89,10 @@ sjs.etasq <- function(...) {
 #' # fit linear model
 #' fit <- lm(airquality$Ozone ~ airquality$Wind + airquality$Temp + airquality$Solar.R)
 #' # print std. beta coefficients
-#' sjs.betaCoef(fit)
+#' sjs.stdb(fit)
 #' 
 #' @export
-sjs.betaCoef <- function(fit) {
+sjs.stdb <- function(fit) {
   b <- summary(fit)$coef[-1, 1]
   sx <- sapply(fit$model[-1], sd)
   sy <- sapply(fit$model[1], sd)

---FILE: R/sjTabLinReg.R---
@@ -438,7 +438,7 @@ sjt.lm <- function (...,
     # standard error
     se <- cbind(se, round(summary(fit)$coefficients[,2], digits.se))
     # retrieve standardized betas
-    stdbv <- cbind(stdbv, sprintf(""%.*f"", digits.sb, sjs.betaCoef(fit)))
+    stdbv <- cbind(stdbv, sprintf(""%.*f"", digits.sb, sjs.stdb(fit)))
   }
   # -------------------------------------
   # rotate coefficients

---FILE: README.md---
@@ -34,14 +34,16 @@ install.packages(""sjPlot"")
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since this package makes heavy use of the [ggplot-package](http://cran.r-project.org/web/packages/ggplot2/index.html), consider citing this package as well.
 
 
-### Changelog of development build 1.6.1-6
+### Changelog of development build 1.6.1-8
 
 #### New functions
 * New function `sjp.int`, which can plot regression lines or probability curves of interaction effects in (generalized) linear (mixed effects) models, i.e. fitted models of class `lm`, `glm`, `lmerMod` and `glmerMod` are covered by this function.
 
 #### Changes to functions
+* Renamed `sjs.betaCoef` to `sjs.stdb`.
 * `sjp.lm.int` was merged with function `sjp.int`.
 * Added parameter `ri.nr` to `sjp.glmer` and `sjp.lmer` to select which random effects of which random intercept to plot, in case the model has multiple random intercepts.
+* Added parameters `showValueLabels`, `labelDigits` and `showPValueLabels` to `sjp.glmer` and `sjp.lmer` to plot beta or odds ratio values and p-value-stars to fixed effects plots.
 * `sjt.xtab` can now show/hide observed values in table cells with `showObserved` parameter.
 * `sjt.df` now distinguishes more variable / vector types (like ordinal and categorial, instead of factor only, or double, integer and numeric).
 * `sjp.lm1` no longer requires the data frame used to fit the model.

---FILE: man/efc.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/efc.R
 \docType{data}
 \name{efc}
 \alias{efc}

---FILE: man/sj.setGeomColors.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotSetTheme.R
 \name{sj.setGeomColors}
 \alias{sj.setGeomColors}
 \title{Helper function to set geom colors}

---FILE: man/sjPlot-package.Rd---
@@ -56,8 +56,8 @@
 \tabular{ll}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.6.1-7\cr
-Date: \tab 2014-12-13\cr
+Version: \tab 1.6.1-8\cr
+Date: \tab 2014-12-14\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjc.cluster.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotClusterAnalysis.R
 \name{sjc.cluster}
 \alias{sjc.cluster}
 \title{Compute hierarchical or kmeans cluster analysis}

---FILE: man/sjc.dend.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotClusterAnalysis.R
 \name{sjc.dend}
 \alias{sjc.dend}
 \title{Compute hierarchical cluster analysis and visualize group classification}

---FILE: man/sjc.elbow.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotClusterAnalysis.R
 \name{sjc.elbow}
 \alias{sjc.elbow}
 \title{Compute elbow values of a k-means cluster analysis}

---FILE: man/sjc.grpdisc.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotClusterAnalysis.R
 \name{sjc.grpdisc}
 \alias{sjc.grpdisc}
 \title{Compute a linear discriminant analysis on classified cluster groups}

---FILE: man/sjc.kgap.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotClusterAnalysis.R
 \name{sjc.kgap}
 \alias{sjc.kgap}
 \title{Compute gap statistics for k-means-cluster}

---FILE: man/sjc.qclus.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotClusterAnalysis.R
 \name{sjc.qclus}
 \alias{sjc.qclus}
 \title{Compute quick cluster analysis}

---FILE: man/sji.SPSS.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjImportSPSS.R
 \name{sji.SPSS}
 \alias{sji.SPSS}
 \title{Import SPSS dataset as data frame into R}

---FILE: man/sji.convertToLabel.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjImportSPSS.R
 \name{sji.convertToLabel}
 \alias{sji.convertToLabel}
 \title{Replaces variable values with their associated value labels}

---FILE: man/sji.convertToValue.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjImportSPSS.R
 \name{sji.convertToValue}
 \alias{sji.convertToValue}
 \title{Converts factors to numeric variables}

---FILE: man/sji.getValueLabels.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjImportSPSS.R
 \name{sji.getValueLabels}
 \alias{sji.getValueLabels}
 \title{Retrieve value labels of a variable or an SPSS-imported data frame}

---FILE: man/sji.getVariableLabels.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjImportSPSS.R
 \name{sji.getVariableLabels}
 \alias{sji.getVariableLabels}
 \title{Retrieve variable labels of (an SPSS-imported) data frame or of a specific variable}

---FILE: man/sji.setValueLabels.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjImportSPSS.R
 \name{sji.setValueLabels}
 \alias{sji.setValueLabels}
 \title{Attach value labels to a variable or vector}

---FILE: man/sji.setVariableLabels.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjImportSPSS.R
 \name{sji.setVariableLabels}
 \alias{sji.setVariableLabels}
 \title{Set variable label(s) to a single variable or data frame}

---FILE: man/sji.viewSPSS.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjTabSPSS.R
 \name{sji.viewSPSS}
 \alias{sji.viewSPSS}
 \title{View SPSS data set structure}

---FILE: man/sjp.aov1.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotAnova.R
 \name{sjp.aov1}
 \alias{sjp.aov1}
 \title{Plot One-Way-Anova tables}

---FILE: man/sjp.chi2.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotPearsonsChi2Test.R
 \name{sjp.chi2}
 \alias{sjp.chi2}
 \title{Plot Pearson's Chi2-Test of multiple contingency tables}

---FILE: man/sjp.corr.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotCorr.R
 \name{sjp.corr}
 \alias{sjp.corr}
 \title{Plot correlation matrix}

---FILE: man/sjp.emm.int.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotAncovaLSMeans.R
 \name{sjp.emm.int}
 \alias{sjp.emm.int}
 \title{Plot adjusted (estimated marginal) means of interaction (moderation) in linear models}

---FILE: man/sjp.frq.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotFrequencies.R
 \name{sjp.frq}
 \alias{sjp.frq}
 \title{Plot frequencies of (count) variables}

---FILE: man/sjp.glm.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotOdds.R
 \name{sjp.glm}
 \alias{sjp.glm}
 \title{Plot odds ratios (forest plots)}
@@ -84,8 +85,7 @@ function call is interrupted and no plot printed.}
 
 \item{showAxisLabels.y}{Whether odds names (predictor labels) should be shown or not.}
 
-\item{showValueLabels}{Whether the beta and standardized beta values should be plotted
-to each dot or not.}
+\item{showValueLabels}{Whether odds ratio values should be plotted to each dot or not.}
 
 \item{labelDigits}{The amount of digits for rounding the estimations (see \code{showValueLabels}).
 Default is 2, i.e. estimators have 2 digits after decimal point.}

---FILE: man/sjp.glm.ma.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotOdds.R
 \name{sjp.glm.ma}
 \alias{sjp.glm.ma}
 \title{Plot model assumptions of glm's}

---FILE: man/sjp.glmer.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotGLME.R
 \name{sjp.glmer}
 \alias{sjp.glmer}
 \title{Plot odds ratios (forest plots) of generalized linear mixed effects models}
@@ -8,7 +9,8 @@ sjp.glmer(fit, type = ""re"", ri.nr = 1, title = NULL, geom.size = 3,
   stringIntercept = ""(Intercept)"", sort.coef = NULL, pred.labels = NULL,
   axisTitle.x = NULL, axisTitle.y = NULL, facet.grid = TRUE,
   free.scale = FALSE, interceptLineType = 2,
-  interceptLineColor = ""grey70"", fade.ns = FALSE, show.se = FALSE,
+  interceptLineColor = ""grey70"", showValueLabels = TRUE, labelDigits = 2,
+  showPValueLabels = TRUE, fade.ns = FALSE, show.se = FALSE,
   printPlot = TRUE)
 }
 \arguments{
@@ -80,6 +82,14 @@ an integrated (faceted) single graph.}
 
 \item{interceptLineColor}{The color of the intercept line. Default value is \code{""grey70""}.}
 
+\item{showValueLabels}{Whether odds ratio values should be plotted to each dot or not.}
+
+\item{labelDigits}{The amount of digits for rounding the estimations (see \code{showValueLabels}).
+Default is 2, i.e. estimators have 2 digits after decimal point.}
+
+\item{showPValueLabels}{Whether the significance levels of each coefficient should be appended
+to values or not.}
+
 \item{fade.ns}{if \code{TRUE}, non significant odds ratios will be printed in slightly fading colors.}
 
 \item{show.se}{Use \code{TRUE} to plot (depending on \code{type}) the standard

---FILE: man/sjp.glmm.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotOddsMultiple.R
 \name{sjp.glmm}
 \alias{sjp.glmm}
 \title{Plot odds ratios (forest plots) of multiple fitted glm's}

---FILE: man/sjp.grpfrq.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotGroupFrequencies.R
 \name{sjp.grpfrq}
 \alias{sjp.grpfrq}
 \title{Plot grouped or stacked frequencies}

---FILE: man/sjp.int.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotInteractions.R
 \name{sjp.int}
 \alias{sjp.int}
 \title{Plot interaction effects of (generalized) linear (mixed) models}

---FILE: man/sjp.likert.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotLikert.R
 \name{sjp.likert}
 \alias{sjp.likert}
 \title{Plot likert scales as centered stacked bars}

---FILE: man/sjp.lm.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotLinreg.R
 \name{sjp.lm}
 \alias{sjp.lm}
 \title{Plot beta coefficients of lm}
@@ -120,7 +121,7 @@ sjp.lm(fit, showStandardBeta=FALSE)
              \item \code{\link{sjp.reglin}}
              \item \code{\link{sjp.int}}
              \item \code{\link{sjp.scatter}}
-             \item  \code{\link{sjs.betaCoef}}
+             \item  \code{\link{sjs.stdb}}
             }
 }
 

---FILE: man/sjp.lm.ma.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotLinreg.R
 \name{sjp.lm.ma}
 \alias{sjp.lm.ma}
 \title{Plot model assumptions of lm's}

---FILE: man/sjp.lm1.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotLinreg.R
 \name{sjp.lm1}
 \alias{sjp.lm1}
 \title{Plot regression line of fitted lm}

---FILE: man/sjp.lmer.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotGLME.R
 \name{sjp.lmer}
 \alias{sjp.lmer}
 \title{Plot estimates (forest plots) of linear mixed effects models}
@@ -7,7 +8,8 @@ sjp.lmer(fit, type = ""re"", ri.nr = 1, title = NULL, geom.size = 3,
   geom.colors = ""Set1"", hideErrorBars = FALSE, showIntercept = TRUE,
   stringIntercept = ""(Intercept)"", sort.coef = NULL, pred.labels = NULL,
   axisTitle.x = NULL, axisTitle.y = NULL, interceptLineType = 2,
-  interceptLineColor = ""grey70"", facet.grid = TRUE, free.scale = FALSE,
+  interceptLineColor = ""grey70"", showValueLabels = TRUE, labelDigits = 2,
+  showPValueLabels = TRUE, facet.grid = TRUE, free.scale = FALSE,
   fade.ns = FALSE, printPlot = TRUE)
 }
 \arguments{
@@ -71,6 +73,15 @@ on the plot type is chosen.}
 
 \item{interceptLineColor}{The color of the intercept line. Default value is \code{""grey70""}.}
 
+\item{showValueLabels}{Whether the beta and standardized beta values should be plotted
+to each dot or not.}
+
+\item{labelDigits}{The amount of digits for rounding the estimations (see \code{showValueLabels}).
+Default is 2, i.e. estimators have 2 digits after decimal point.}
+
+\item{showPValueLabels}{Whether the significance levels of each coefficient should be appended
+to values or not}
+
 \item{facet.grid}{\code{TRUE} when each plot should be plotted separately instead of
 an integrated (faceted) single graph.}
 

---FILE: man/sjp.lmm.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotLinregMultiple.R
 \name{sjp.lmm}
 \alias{sjp.lmm}
 \title{Plot beta coefficients of multiple fitted lm's}

---FILE: man/sjp.pca.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotPCA.R
 \name{sjp.pca}
 \alias{sjp.pca}
 \title{Plot PCA results}

---FILE: man/sjp.reglin.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotLinreg.R
 \name{sjp.reglin}
 \alias{sjp.reglin}
 \title{Plot regression lines for each predictor}

---FILE: man/sjp.scatter.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotScatter.R
 \name{sjp.scatter}
 \alias{sjp.scatter}
 \title{Plot (grouped) scatter plots}

---FILE: man/sjp.setTheme.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotSetTheme.R
 \name{sjp.setTheme}
 \alias{sjp.setTheme}
 \title{Set global theme options for sjp-functions}

---FILE: man/sjp.stackfrq.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotStackFrequencies.R
 \name{sjp.stackfrq}
 \alias{sjp.stackfrq}
 \title{Plot stacked proportional bars}

---FILE: man/sjp.vif.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjRecode.R
 \name{sjp.vif}
 \alias{sjp.vif}
 \title{Plot Variance Inflation Factors of linear models}

---FILE: man/sjp.xtab.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotPropTable.R
 \name{sjp.xtab}
 \alias{sjp.xtab}
 \title{Plot contingency tables}

---FILE: man/sjs.aov1.levene.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjPlotAnova.R
 \name{sjs.aov1.levene}
 \alias{sjs.aov1.levene}
 \title{Plot Levene-Test for One-Way-Anova}

---FILE: man/sjs.chi2.gof.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjStatistics.R
 \name{sjs.chi2.gof}
 \alias{sjs.chi2.gof}
 \title{Performs a Chi-square goodness-of-fit-test}

---FILE: man/sjs.cramer.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjStatistics.R
 \name{sjs.cramer}
 \alias{sjs.cramer}
 \title{Cramer's V for a contingency table}

---FILE: man/sjs.cronbach.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjStatistics.R
 \name{sjs.cronbach}
 \alias{sjs.cronbach}
 \title{Calculates Cronbach's Alpha for a matrix}

---FILE: man/sjs.etasq.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjStatistics.R
 \name{sjs.etasq}
 \alias{sjs.etasq}
 \title{Retrieve eta squared of fitted anova}

---FILE: man/sjs.mic.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjStatistics.R
 \name{sjs.mic}
 \alias{sjs.mic}
 \title{Computes a mean inter-item-correlation.}

---FILE: man/sjs.mwu.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjStatistics.R
 \name{sjs.mwu}
 \alias{sjs.mwu}
 \title{Performs a Mann-Whitney-U-Test}

---FILE: man/sjs.phi.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjStatistics.R
 \name{sjs.phi}
 \alias{sjs.phi}
 \title{Phi value for a contingency table}

---FILE: man/sjs.reliability.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjStatistics.R
 \name{sjs.reliability}
 \alias{sjs.reliability}
 \title{Performs a reliability test on an item scale.}

---FILE: man/sjs.se.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjStatistics.R
 \name{sjs.se}
 \alias{sjs.se}
 \title{Compute standard error for variables}

---FILE: man/sjs.stdb.Rd---
@@ -1,9 +1,10 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
-\name{sjs.betaCoef}
-\alias{sjs.betaCoef}
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjStatistics.R
+\name{sjs.stdb}
+\alias{sjs.stdb}
 \title{Retrieve std. beta coefficients of lm}
 \usage{
-sjs.betaCoef(fit)
+sjs.stdb(fit)
 }
 \arguments{
 \item{fit}{A fitted linear model.}
@@ -26,7 +27,7 @@ Returns the standardized beta coefficients of a fitted linear model.
 # fit linear model
 fit <- lm(airquality$Ozone ~ airquality$Wind + airquality$Temp + airquality$Solar.R)
 # print std. beta coefficients
-sjs.betaCoef(fit)
+sjs.stdb(fit)
 }
 \references{
 \href{http://en.wikipedia.org/wiki/Standardized_coefficient}{Wikipedia: Standardized coefficient}

---FILE: man/sjs.table.values.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjStatistics.R
 \name{sjs.table.values}
 \alias{sjs.table.values}
 \title{Compute table's values}

---FILE: man/sjt.corr.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjTabCorr.R
 \name{sjt.corr}
 \alias{sjt.corr}
 \title{Show correlations as HTML table}

---FILE: man/sjt.df.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjTabDataFrame.R
 \name{sjt.df}
 \alias{sjt.df}
 \title{Show (description of) data frame as HTML table}

---FILE: man/sjt.frq.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjTabFrequencies.R
 \name{sjt.frq}
 \alias{sjt.frq}
 \title{Show frequencies as HTML table}

---FILE: man/sjt.glm.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjTabOdds.R
 \name{sjt.glm}
 \alias{sjt.glm}
 \title{Show (and compare) generalized linear models as HTML table}

---FILE: man/sjt.grpmean.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjTabGrpmean.R
 \name{sjt.grpmean}
 \alias{sjt.grpmean}
 \title{Show grouped means as HTML table}

---FILE: man/sjt.itemanalysis.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjTabItemAnalysis.R
 \name{sjt.itemanalysis}
 \alias{sjt.itemanalysis}
 \title{Show item analysis of an item scale as HTML table}

---FILE: man/sjt.lm.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjTabLinReg.R
 \name{sjt.lm}
 \alias{sjt.lm}
 \title{Show linear regression as HTML table}

---FILE: man/sjt.pca.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjTabPCA.R
 \name{sjt.pca}
 \alias{sjt.pca}
 \title{Show principal component analysis as HTML table}

---FILE: man/sjt.stackfrq.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjTabStackFrq.R
 \name{sjt.stackfrq}
 \alias{sjt.stackfrq}
 \title{Show stacked frequencies as HTML table}

---FILE: man/sjt.xtab.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjTabPropTable.R
 \name{sjt.xtab}
 \alias{sjt.xtab}
 \title{Show contingency tables as HTML table}

---FILE: man/sju.adjustPlotRange.y.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjRecode.R
 \name{sju.adjustPlotRange.y}
 \alias{sju.adjustPlotRange.y}
 \title{Adjust y range of ggplot-objects}

---FILE: man/sju.dicho.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjRecode.R
 \name{sju.dicho}
 \alias{sju.dicho}
 \title{Dichotomize variables}

---FILE: man/sju.groupString.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjRecode.R
 \name{sju.groupString}
 \alias{sju.groupString}
 \title{Group near elements of string vectors}

---FILE: man/sju.groupVar.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjRecode.R
 \name{sju.groupVar}
 \alias{sju.groupVar}
 \title{Recode count variables into grouped factors}

---FILE: man/sju.groupVarLabels.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjRecode.R
 \name{sju.groupVarLabels}
 \alias{sju.groupVarLabels}
 \title{Create labels for recoded groups}

---FILE: man/sju.mean.n.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjRecode.R
 \name{sju.mean.n}
 \alias{sju.mean.n}
 \title{Compute row means with min amount of valid values}

---FILE: man/sju.recode.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjRecode.R
 \name{sju.recode}
 \alias{sju.recode}
 \title{Recode variable values.}

---FILE: man/sju.recodeTo.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjRecode.R
 \name{sju.recodeTo}
 \alias{sju.recodeTo}
 \title{Recode variable categories into new values.}

---FILE: man/sju.setNA.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjRecode.R
 \name{sju.setNA}
 \alias{sju.setNA}
 \title{Set NA for specific variable values}

---FILE: man/sju.strpos.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjRecode.R
 \name{sju.strpos}
 \alias{sju.strpos}
 \title{Find partial matching and close distance elements in strings}

---FILE: man/sju.weight.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjRecode.R
 \name{sju.weight}
 \alias{sju.weight}
 \title{Weight a variable}

---FILE: man/sju.weight2.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjRecode.R
 \name{sju.weight2}
 \alias{sju.weight2}
 \title{Weight a variable}

---FILE: man/sju.wordwrap.Rd---
@@ -1,4 +1,5 @@
-% Generated by roxygen2 (4.0.2): do not edit by hand
+% Generated by roxygen2 (4.1.0): do not edit by hand
+% Please edit documentation in R/sjRecode.R
 \name{sju.wordwrap}
 \alias{sju.wordwrap}
 \title{Insert line breaks in long labels}"
strengejacke,sjPlot,0afdd6f3f97de08b4fd5b797aafce14e3830c2bc,Daniel Ldecke,d.luedecke@uke.de,2014-12-13T07:46:03Z,Daniel Ldecke,d.luedecke@uke.de,2014-12-13T07:46:03Z,bug fix and new features for sjp.(g)lmer,DESCRIPTION;NEWS;R/sjPlotGLME.R;README.md;man/sjPlot-package.Rd;man/sjp.glmer.Rd;man/sjp.lmer.Rd,False,True,True,False,178,95,273,"---FILE: DESCRIPTION---
@@ -2,8 +2,8 @@ Package: sjPlot
 Type: Package
 Encoding: UTF-8
 Title: Data Visualization for Statistics in Social Science
-Version: 1.6.1-6
-Date: 2014-12-10
+Version: 1.6.1-7
+Date: 2014-12-13
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Luedecke <d.luedecke@uke.de>
 Description: Collection of several plotting and table output functions for

---FILE: NEWS---
@@ -13,13 +13,15 @@ Changes to functions:
 * Added parameters ""showCountValues"" and ""showPercentageValues"" to function ""sjp.xtab"", so either percentage value labels, count value labels or both can be printed.
 * Removed parameters ""maxYlim"" and ""upperYLim"" from ""sjp.grpfrq"", ""sjp.xtab"" and ""sjp.frq"", and added ""axisLimits.y"" as new option to define y-axis-range.
 * Parameter ""labelPos"" now also works for flipped coordinates in ""sjp.xtab"".
+* Added parameters to define axis titles and intercept label for y axis to ""sjp.glmer"" and ""sjp.lmer"".
 
 General:
 * Console output of various function that used the ""cat"" or ""print"" command were replaced by ""message"" or ""warning"", if more appropriate.
 
 Bug fixes:
 * Parameter ""geom.size"" was not applied to bar charts in ""sjp.grpfrq"" - fixed.
 * Q-Q plot of ""sjp.lm.ma"" used wrong linear q-q line - fixed.
+* Fixed bug in ""sjp.glmer"" with plot type ""ri.pc"".
 
 
 Version 1.6

---FILE: R/sjPlotGLME.R---
@@ -48,6 +48,8 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""nQQ"", ""ci"", ""fixef"", ""fa
 #' @param hideErrorBars If \code{TRUE}, the error bars that indicate the confidence intervals of the odds ratios are not
 #'          shown.
 #' @param showIntercept if \code{TRUE}, the intercept is included when plotting random or fixed effects.
+#' @param stringIntercept string of intercept estimate on the y axis. Only applies, if \code{showIntercept}
+#'          is \code{TRUE} and \code{pred.labels} is not \code{NULL}.
 #' @param sort.coef indicates which coefficient should be used for sorting odds ratios
 #'          \itemize{
 #'            \item If \code{NULL} (default), no sorting is done and odds ratios are sorted in order of model coefficients.
@@ -60,6 +62,10 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""nQQ"", ""ci"", ""fixef"", ""fa
 #' @param pred.labels a character vector with labels for the predictors / covariates / groups. Should either be vector
 #'          of fixed effects variable labels (if \code{type = ""fe""}) or a vector of group (value)
 #'          labels from the random intercept's categories (if \code{type = ""re""}).
+#' @param axisTitle.x A label (title) for the x axis. If not specified, a default labelling depending
+#'          on the plot type is chosen.
+#' @param axisTitle.y A label (title) for the y axis. If not specified, a default labelling depending
+#'          on the plot type is chosen.
 #' @param interceptLineType The linetype of the intercept line (zero point). Default is \code{2} (dashed line).
 #' @param interceptLineColor The color of the intercept line. Default value is \code{""grey70""}.
 #' @param facet.grid \code{TRUE} when each plot should be plotted separately instead of
@@ -75,7 +81,7 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""nQQ"", ""ci"", ""fixef"", ""fa
 #'            \item a data frame \code{mydf} with the data used to build the ggplot-object(s).
 #'            }
 #'
-#' @note Thanks to Robert Reijntjes from Leiden University Medical Center for sharing 
+#' @note Thanks to Robert Reijntjes from Leiden University Medical Center for sharing
 #'         R code that is used to compute fixed effects correlation matrices and
 #'         qq-plots of random effects.
 #'
@@ -117,39 +123,39 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""nQQ"", ""ci"", ""fixef"", ""fa
 #' fit <- glmer(hi_qol ~ sex + c12hour + neg_c_7 + (1|grp),
 #'              data = mydf,
 #'              family = binomial(""logit""))
-#' 
+#'
 #' # plot random effects
 #' sjp.glmer(fit)
-#' 
+#'
 #' # plot fixed effects
 #' sjp.glmer(fit, type = ""fe"")
-#' 
+#'
 #' # plot and sort fixed effects
 #' sjp.glmer(fit,
 #'           type = ""fe"",
 #'           sort.coef = TRUE)
-#' 
+#'
 #' # plot fixed effects correlations
 #' sjp.glmer(fit, type = ""fe.cor"")
-#' 
+#'
 #' # qq-plot of random effects
 #' sjp.glmer(fit, type = ""re.qq"")
-#' 
+#'
 #' # plot probability curves for each covariate
 #' # grouped by random intercepts
-#' sjp.glmer(fit, 
-#'           type = ""ri.pc"", 
+#' sjp.glmer(fit,
+#'           type = ""ri.pc"",
 #'           show.se = TRUE)
-#' 
+#'
 #' # plot probability curves for each covariate
 #' # grouped by random intercepts in integrated plots
-#' sjp.glmer(fit, 
-#'           type = ""ri.pc"", 
+#' sjp.glmer(fit,
+#'           type = ""ri.pc"",
 #'           facet.grid = FALSE)
 #'
 #' # plot probability curve of fixed effects
 #' sjp.glmer(fit, type = ""fe.pc"")}
-#' 
+#'
 #' @import ggplot2
 #' @importFrom reshape2 melt
 #' @export
@@ -161,19 +167,22 @@ sjp.glmer <- function(fit,
                       geom.colors = ""Set1"",
                       hideErrorBars = FALSE,
                       showIntercept = TRUE,
+                      stringIntercept = ""(Intercept)"",
                       sort.coef = NULL,
                       pred.labels = NULL,
+                      axisTitle.x = NULL,
+                      axisTitle.y = NULL,
                       facet.grid = TRUE,
                       free.scale = FALSE,
                       interceptLineType = 2,
                       interceptLineColor = ""grey70"",
                       fade.ns = FALSE,
                       show.se = FALSE,
                       printPlot = TRUE) {
-  
+
   if (type == ""fe.prob"") type <- ""fe.pc""
   if (type == ""ri.prob"") type <- ""ri.pc""
-  
+
   sjp.lme4(fit,
            type,
            ri.nr,
@@ -182,8 +191,11 @@ sjp.glmer <- function(fit,
            geom.colors,
            hideErrorBars,
            showIntercept,
+           stringIntercept,
            sort.coef,
            pred.labels,
+           axisTitle.x,
+           axisTitle.y,
            interceptLineType,
            interceptLineColor,
            facet.grid,
@@ -237,6 +249,8 @@ sjp.glmer <- function(fit,
 #' @param hideErrorBars If \code{TRUE}, the error bars that indicate the confidence intervals of the estimates are not
 #'          shown.
 #' @param showIntercept if \code{TRUE}, the intercept is included when plotting random or fixed effects.
+#' @param stringIntercept string of intercept estimate on the y axis. Only applies, if \code{showIntercept}
+#'          is \code{TRUE} and \code{pred.labels} is not \code{NULL}.
 #' @param sort.coef indicates which coefficient should be used for sorting estimates.
 #'          \itemize{
 #'            \item If \code{NULL} (default), no sorting is done and estimates are sorted in order of model coefficients.
@@ -249,6 +263,10 @@ sjp.glmer <- function(fit,
 #' @param pred.labels a character vector with labels for the predictors / covariates / groups. Should either be vector
 #'          of fixed effects variable labels (if \code{type = ""fe""}) or a vector of group (value)
 #'          labels from the random intercept's categories (if \code{type = ""re""}).
+#' @param axisTitle.x A label (title) for the x axis. If not specified, a default labelling depending
+#'          on the plot type is chosen.
+#' @param axisTitle.y A label (title) for the y axis. If not specified, a default labelling depending
+#'          on the plot type is chosen.
 #' @param interceptLineType The linetype of the intercept line (zero point). Default is \code{2} (dashed line).
 #' @param interceptLineColor The color of the intercept line. Default value is \code{""grey70""}.
 #' @param facet.grid \code{TRUE} when each plot should be plotted separately instead of
@@ -289,8 +307,8 @@ sjp.glmer <- function(fit,
 #' sjp.lmer(fit,
 #'          type = ""fe"",
 #'          sort.coef = TRUE)
-#'          
-#'          
+#'
+#'
 #' library(lme4)
 #' data(efc)
 #' # prepare group variable
@@ -305,21 +323,21 @@ sjp.glmer <- function(fit,
 #' # fit glmer
 #' fit <- lmer(neg_c_7 ~ sex + c12hour + barthel + (1|grp),
 #'             data = mydf)
-#' 
+#'
 #' # plot random effects
 #' sjp.lmer(fit)
-#' 
+#'
 #' # plot fixed effects
 #' sjp.lmer(fit, type = ""fe"")
-#' 
+#'
 # plot and sort fixed effects
 #' sjp.lmer(fit,
 #'          type = ""fe"",
 #'          sort.coef = TRUE)
-#' 
+#'
 #' # plot fixed effects correlations
 #' sjp.lmer(fit, type = ""fe.cor"")
-#' 
+#'
 #' # qq-plot of random effects
 #' sjp.lmer(fit, type = ""re.qq"")}
 #'
@@ -333,8 +351,11 @@ sjp.lmer <- function(fit,
                      geom.colors = ""Set1"",
                      hideErrorBars = FALSE,
                      showIntercept = TRUE,
+                     stringIntercept = ""(Intercept)"",
                      sort.coef = NULL,
                      pred.labels = NULL,
+                     axisTitle.x = NULL,
+                     axisTitle.y = NULL,
                      interceptLineType = 2,
                      interceptLineColor = ""grey70"",
                      facet.grid = TRUE,
@@ -349,8 +370,11 @@ sjp.lmer <- function(fit,
            geom.colors,
            hideErrorBars,
            showIntercept,
+           stringIntercept,
            sort.coef,
            pred.labels,
+           axisTitle.x,
+           axisTitle.y,
            interceptLineType,
            interceptLineColor,
            facet.grid,
@@ -369,8 +393,11 @@ sjp.lme4  <- function(fit,
                       geom.colors,
                       hideErrorBars,
                       showIntercept,
+                      stringIntercept,
                       sort.coef,
                       pred.labels,
+                      axisTitle.x = NULL,
+                      axisTitle.y = NULL,
                       interceptLineType,
                       interceptLineColor,
                       facet.grid,
@@ -411,7 +438,17 @@ sjp.lme4  <- function(fit,
     # ---------------------------------------
     # copy rownames as axis labels, if not set
     # ---------------------------------------
-    if (is.null(pred.labels)) pred.labels <- rownames(mydf.ef)
+    if (is.null(pred.labels)) {
+      # use rownames, if pred.labels not available
+      pred.labels <- rownames(mydf.ef)
+      # check if intercept should be removed?
+      if (!showIntercept) pred.labels <- pred.labels[-1]
+    }
+    else {
+      # check if intercept should be added, in case
+      # pred.labels are passed
+      if (showIntercept) pred.labels <- c(stringIntercept, pred.labels)
+    }
     # ---------------------------------------
     # show intercept?
     # ---------------------------------------
@@ -530,7 +567,14 @@ sjp.lme4  <- function(fit,
     # ---------------------------------------
     # copy rownames as axis labels, if not set
     # ---------------------------------------
-    if (is.null(pred.labels)) pred.labels <- rownames(mydf)
+    if (is.null(pred.labels)) {
+      pred.labels <- rownames(mydf)
+    }
+    else {
+      # check if intercept should be added, in case
+      # pred.labels are passed
+      if (showIntercept) pred.labels <- c(stringIntercept, pred.labels)
+    }
     # ---------------------------------------
     # sort data frame. init order
     # ---------------------------------------
@@ -656,18 +700,20 @@ sjp.lme4  <- function(fit,
     # ---------------------------------------
     # axis titles
     # ---------------------------------------
-    if (type == ""fe"")
-      y.axis.text <- ""Fixed effects""
-    else if (type == ""re"")
-      y.axis.text <- ""Random effects""
-    x.axis.text <- ""Levels""
+    if (type == ""fe"") {
+      if (is.null(axisTitle.y)) axisTitle.y <- ""Fixed effects""
+    }
+    else if (type == ""re"") {
+      if (is.null(axisTitle.y)) axisTitle.y <- ""Random effects""
+    }
+    if (is.null(axisTitle.x)) axisTitle.x <- ""Levels""
     # ---------------------------------------
     # add facet grid here, faceting by group
     # (level) of random intercept
     # ---------------------------------------
     if (facet.grid) {
       gp <- gp +
-        labs(x = x.axis.text, y = y.axis.text)
+        labs(x = axisTitle.x, y = axisTitle.y)
       # check if user wants free scale for each facet
       if (free.scale)
         gp  <- gp + facet_wrap( ~ grp, scales = ""free_y"")
@@ -676,7 +722,7 @@ sjp.lme4  <- function(fit,
     }
     else {
       gp <- gp +
-        labs(x = x.axis.text, y = y.axis.text, title = title)
+        labs(x = axisTitle.x, y = axisTitle.y, title = title)
     }
     return (gp)
   }
@@ -805,17 +851,20 @@ sjp.lme.feprobcurv <- function(fit,
       }
       # find coef-position
       coef.pos <- which(coef.names == fit.fac.name)
-      # calculate x-beta by multiplying original values with estimate of that term
-      mydf.vals$xbeta <- mydf.vals$value * (lme4::fixef(fit)[coef.pos])
-      # calculate probability (y) via cdf-function
-      mydf.vals$y <- odds.to.prob(lme4::fixef(fit)[1] + mydf.vals$xbeta)
-      # save predictor name
-      pred.name <- fit.term.names[i]
-      axisLabels.mp <- c(axisLabels.mp, pred.name)
-      # assign group
-      mydf.vals$grp <- pred.name
-      # add mydf to list
-      mydf.metricpred[[length(mydf.metricpred) + 1]] <- mydf.vals
+      # check if we have found the coefficient
+      if (length(coef.pos) > 0) {
+        # calculate x-beta by multiplying original values with estimate of that term
+        mydf.vals$xbeta <- mydf.vals$value * (lme4::fixef(fit)[coef.pos])
+        # calculate probability (y) via cdf-function
+        mydf.vals$y <- odds.to.prob(lme4::fixef(fit)[1] + mydf.vals$xbeta)
+        # save predictor name
+        pred.name <- fit.term.names[i]
+        axisLabels.mp <- c(axisLabels.mp, pred.name)
+        # assign group
+        mydf.vals$grp <- pred.name
+        # add mydf to list
+        mydf.metricpred[[length(mydf.metricpred) + 1]] <- mydf.vals
+      }
     }
   }
   # ---------------------------------------------------------
@@ -901,6 +950,8 @@ sjp.lme.reprobcurve <- function(fit,
   # retrieve term names, so we find the estimates in the
   # coefficients list
   # ----------------------------
+  plot.prob <- list()
+  mydf.prob <- list()
   fit.term.length <- length(names(lme4::fixef(fit))[-1])
   fit.term.names <- attr(attr(fit.df, ""terms""), ""term.labels"")[1 : fit.term.length]
   response.name <- attr(attr(attr(fit.df, ""terms""), ""dataClasses""), ""names"")[1]
@@ -940,57 +991,65 @@ sjp.lme.reprobcurve <- function(fit,
       }
       # find coef-position
       coef.pos <- which(coef.names == fit.fac.name)
-      # calculate x-beta by multiplying original values with estimate of that term
-      mydf.vals$xbeta <- mydf.vals$value * (lme4::fixef(fit)[coef.pos])
-      # save predictor name
-      pred.name <- fit.term.names[i]
-      # do this for each random intercept group
-      for (j in 1 : nrow(rand.ef)) {
-        # calculate probability for each random effect group
-        mydf.vals$y <- odds.to.prob(rand.ef[j, 1] + mydf.vals$xbeta)
-        # add to final data frame
-        final.df <- rbind(final.df, cbind(pred = mydf.vals$value,
-                                          prob = mydf.vals$y))
-        # need to add grp vector later to data frame,
-        # else ""x"" and ""prob"" would be coerced to factors
-        final.grp <- c(final.grp,
-                       rep(row.names(rand.ef)[j],
-                           times = length(mydf.vals$value)))
-      }
-      # add grp vector
-      final.df$grp <- final.grp
-      # ---------------------------------------------------------
-      # plot
-      # ---------------------------------------------------------
-      mp <- ggplot(final.df, aes(x = pred, y = prob, colour = grp)) +
-        stat_smooth(method = ""glm"",
-                    family = ""binomial"",
-                    se = show.se) +
-        # cartesian coord still plots range of se, even
-        # when se exceeds plot range.
-        coord_cartesian(ylim = c(0, 1)) +
-        labs(x = NULL,
-             y = ""Probability"",
-             title = sprintf(""Probability of %s on %s"", pred.name, response.name))
-      # wrap to facets
-      if (facet.grid) {
-        mp <- mp + facet_wrap( ~ grp,
-                               ncol = round(sqrt(nrow(rand.ef))),
-                               scales = ""free_x"") +
-          # no legend
-          guides(colour = FALSE)
-      }
-      # -------------------------------------
-      # check if metric plots should be plotted
-      # -------------------------------------
-      if (printPlot) {
-        print(mp)
+      # check if we have found the coefficient
+      if (length(coef.pos) > 0) {
+        # calculate x-beta by multiplying original values with estimate of that term
+        mydf.vals$xbeta <- mydf.vals$value * (lme4::fixef(fit)[coef.pos])
+        # save predictor name
+        pred.name <- fit.term.names[i]
+        # do this for each random intercept group
+        for (j in 1 : nrow(rand.ef)) {
+          # calculate probability for each random effect group
+          mydf.vals$y <- odds.to.prob(rand.ef[j, 1] + mydf.vals$xbeta)
+          # add to final data frame
+          final.df <- rbind(final.df, cbind(pred = mydf.vals$value,
+                                            prob = mydf.vals$y))
+          # need to add grp vector later to data frame,
+          # else ""x"" and ""prob"" would be coerced to factors
+          final.grp <- c(final.grp,
+                         rep(row.names(rand.ef)[j],
+                             times = length(mydf.vals$value)))
+        }
+        # add grp vector
+        final.df$grp <- final.grp
+        # ---------------------------------------------------------
+        # plot
+        # ---------------------------------------------------------
+        mp <- ggplot(final.df, aes(x = pred, y = prob, colour = grp)) +
+          stat_smooth(method = ""glm"",
+                      family = ""binomial"",
+                      se = show.se) +
+          # cartesian coord still plots range of se, even
+          # when se exceeds plot range.
+          coord_cartesian(ylim = c(0, 1)) +
+          labs(x = NULL,
+               y = ""Probability"",
+               title = sprintf(""Probability of %s on %s"", pred.name, response.name))
+        # wrap to facets
+        if (facet.grid) {
+          mp <- mp + facet_wrap( ~ grp,
+                                 ncol = round(sqrt(nrow(rand.ef))),
+                                 scales = ""free_x"") +
+            # no legend
+            guides(colour = FALSE)
+        }
+        # -------------------------------------
+        # add to plot and df list
+        # -------------------------------------
+        plot.prob[[length(plot.prob)+1]] <- mp
+        mydf.prob[[length(mydf.prob)+1]] <- final.df
+        # -------------------------------------
+        # check if metric plots should be plotted
+        # -------------------------------------
+        if (printPlot) {
+          print(mp)
+        }
       }
     }
   }
   invisible(structure(class = ""sjpglmer.ripc"",
-                      list(mydf = final.df,
-                           plot = mp)))
+                      list(mydf = mydf.prob,
+                           plot = plot.prob)))
 }
 
 

---FILE: README.md---
@@ -49,13 +49,15 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 * Added parameters `showCountValues` and `showPercentageValues` to function `sjp.xtab`, so either percentage value labels, count value labels or both can be printed.
 * Removed parameters `maxYlim` and `upperYLim` from `sjp.grpfrq`, `sjp.xtab` and `sjp.frq`, and added `axisLimits.y` as new option to define y-axis-range.
 * Parameter `labelPos` now also works for flipped coordinates in `sjp.xtab`.
+* Added parameters to define axis titles and intercept label for y axis to `sjp.glmer` and `sjp.lmer`.
 
 #### General
 * Console output of various function that used the `cat` or `print` command were replaced by `message` or `warning`, if more appropriate.
 
 #### Bug fixes
 * Parameter `geom.size` was not applied to bar charts in `sjp.grpfrq` - fixed.
 * Q-Q plot of `sjp.lm.ma` used wrong linear q-q line - fixed.
+* Fixed bug in `sjp.glmer` with plot type `ri.pc`.
 
 
 ### Changelog of current stable build 1.6

---FILE: man/sjPlot-package.Rd---
@@ -56,8 +56,8 @@
 \tabular{ll}{
 Package: \tab sjPlot\cr
 Type: \tab Package\cr
-Version: \tab 1.6.1-6\cr
-Date: \tab 2014-12-10\cr
+Version: \tab 1.6.1-7\cr
+Date: \tab 2014-12-13\cr
 License: \tab GPL-3\cr
 }
 }

---FILE: man/sjp.glmer.Rd---
@@ -5,7 +5,8 @@
 \usage{
 sjp.glmer(fit, type = ""re"", ri.nr = 1, title = NULL, geom.size = 3,
   geom.colors = ""Set1"", hideErrorBars = FALSE, showIntercept = TRUE,
-  sort.coef = NULL, pred.labels = NULL, facet.grid = TRUE,
+  stringIntercept = ""(Intercept)"", sort.coef = NULL, pred.labels = NULL,
+  axisTitle.x = NULL, axisTitle.y = NULL, facet.grid = TRUE,
   free.scale = FALSE, interceptLineType = 2,
   interceptLineColor = ""grey70"", fade.ns = FALSE, show.se = FALSE,
   printPlot = TRUE)
@@ -47,6 +48,9 @@ shown.}
 
 \item{showIntercept}{if \code{TRUE}, the intercept is included when plotting random or fixed effects.}
 
+\item{stringIntercept}{string of intercept estimate on the y axis. Only applies, if \code{showIntercept}
+is \code{TRUE} and \code{pred.labels} is not \code{NULL}.}
+
 \item{sort.coef}{indicates which coefficient should be used for sorting odds ratios
 \itemize{
   \item If \code{NULL} (default), no sorting is done and odds ratios are sorted in order of model coefficients.
@@ -60,6 +64,12 @@ shown.}
 of fixed effects variable labels (if \code{type = ""fe""}) or a vector of group (value)
 labels from the random intercept's categories (if \code{type = ""re""}).}
 
+\item{axisTitle.x}{A label (title) for the x axis. If not specified, a default labelling depending
+on the plot type is chosen.}
+
+\item{axisTitle.y}{A label (title) for the y axis. If not specified, a default labelling depending
+on the plot type is chosen.}
+
 \item{facet.grid}{\code{TRUE} when each plot should be plotted separately instead of
 an integrated (faceted) single graph.}
 

---FILE: man/sjp.lmer.Rd---
@@ -5,7 +5,8 @@
 \usage{
 sjp.lmer(fit, type = ""re"", ri.nr = 1, title = NULL, geom.size = 3,
   geom.colors = ""Set1"", hideErrorBars = FALSE, showIntercept = TRUE,
-  sort.coef = NULL, pred.labels = NULL, interceptLineType = 2,
+  stringIntercept = ""(Intercept)"", sort.coef = NULL, pred.labels = NULL,
+  axisTitle.x = NULL, axisTitle.y = NULL, interceptLineType = 2,
   interceptLineColor = ""grey70"", facet.grid = TRUE, free.scale = FALSE,
   fade.ns = FALSE, printPlot = TRUE)
 }
@@ -44,6 +45,9 @@ shown.}
 
 \item{showIntercept}{if \code{TRUE}, the intercept is included when plotting random or fixed effects.}
 
+\item{stringIntercept}{string of intercept estimate on the y axis. Only applies, if \code{showIntercept}
+is \code{TRUE} and \code{pred.labels} is not \code{NULL}.}
+
 \item{sort.coef}{indicates which coefficient should be used for sorting estimates.
 \itemize{
   \item If \code{NULL} (default), no sorting is done and estimates are sorted in order of model coefficients.
@@ -57,6 +61,12 @@ shown.}
 of fixed effects variable labels (if \code{type = ""fe""}) or a vector of group (value)
 labels from the random intercept's categories (if \code{type = ""re""}).}
 
+\item{axisTitle.x}{A label (title) for the x axis. If not specified, a default labelling depending
+on the plot type is chosen.}
+
+\item{axisTitle.y}{A label (title) for the y axis. If not specified, a default labelling depending
+on the plot type is chosen.}
+
 \item{interceptLineType}{The linetype of the intercept line (zero point). Default is \code{2} (dashed line).}
 
 \item{interceptLineColor}{The color of the intercept line. Default value is \code{""grey70""}.}"
strengejacke,sjPlot,d447c9954173a4709e37469bfadbcb3d41a59773,Daniel Ldecke,d.luedecke@uke.de,2014-12-11T17:41:13Z,Daniel Ldecke,d.luedecke@uke.de,2014-12-11T17:41:13Z,fixed bug in RD-files,NEWS;R/sjImportSPSS.R;R/sjPlotAncovaLSMeans.R;R/sjPlotAnova.R;R/sjPlotClusterAnalysis.R;R/sjPlotCorr.R;R/sjPlotFrequencies.R;R/sjPlotGLME.R;R/sjPlotGroupFrequencies.R;R/sjPlotLinreg.R;R/sjPlotOdds.R;R/sjPlotPCA.R;R/sjPlotScatter.R;R/sjRecode.R;R/sjStatistics.R;R/sjTabFrequencies.R;R/sjTabPCA.R;README.md;man/sjp.emm.int.Rd;man/sjp.glmer.Rd;man/sjp.lm.Rd;man/sjp.lm.ma.Rd;man/sjp.lmer.Rd;man/sjp.reglin.Rd;man/sju.mean.n.Rd,False,True,True,False,103,91,194,"---FILE: NEWS---
@@ -14,6 +14,9 @@ Changes to functions:
 * Removed parameters ""maxYlim"" and ""upperYLim"" from ""sjp.grpfrq"", ""sjp.xtab"" and ""sjp.frq"", and added ""axisLimits.y"" as new option to define y-axis-range.
 * Parameter ""labelPos"" now also works for flipped coordinates in ""sjp.xtab"".
 
+General:
+* Console output of various function that used the ""cat"" or ""print"" command were replaced by ""message"" or ""warning"", if more appropriate.
+
 Bug fixes:
 * Parameter ""geom.size"" was not applied to bar charts in ""sjp.grpfrq"" - fixed.
 * Q-Q plot of ""sjp.lm.ma"" used wrong linear q-q line - fixed.

---FILE: R/sjImportSPSS.R---
@@ -42,7 +42,7 @@ sji.SPSS <- function(path, enc=NA, autoAttachVarLabels=FALSE) {
   data.spss <- read.spss(path, to.data.frame=TRUE, use.value.labels=FALSE, reencode=enc)
   # auto attach labels
   if (autoAttachVarLabels) {
-    cat(""Attaching variable labels. Please wait...\n"")
+    message(""Attaching variable labels. Please wait...\n"")
     data.spss <- sji.setVariableLabels(data.spss, sji.getVariableLabels(data.spss))
   }
   # return data frame
@@ -150,8 +150,8 @@ sji.setValueLabels <- function(x, labels) {
 sji.setValueLabels.vector <- function(var, labels) {
   # check for null
   if (!is.null(labels)) {
-    if (is.character(var) || is.null(var)) {
-      cat(""Can't attach labels to string or NULL vectors.\n"")
+    if (is.null(var) || is.character(var)) {
+      warning(""Can't attach labels to string or NULL vectors.\n"")
     }
     else {
       # check if var is a factor
@@ -172,16 +172,16 @@ sji.setValueLabels.vector <- function(var, labels) {
       lablen <- length(labels)
       valrange <- maxval-minval+1
       if (is.infinite(valrange)) {
-        cat(""Can't set value labels. Infinite value range.\n"")
+        warning(""Can't set value labels. Infinite value range.\n"")
       }
       # check for valid length of labels
       else if (valrange<lablen) {
-        cat(sprintf(""More labels than values of \""var\"". Using first %i labels.\n"", valrange))
+        message(sprintf(""More labels than values of \""var\"". Using first %i labels.\n"", valrange))
         attr(var, ""value.labels"") <- c(as.character(c(minval:maxval)))
         names(attr(var, ""value.labels"")) <- rev(labels[1:valrange])
       }
       else if (valrange>lablen) {
-        cat(""Can't set value labels. Value range of \""var\"" is longer than length of \""labels\"".\n"")
+        warning(""Can't set value labels. Value range of \""var\"" is longer than length of \""labels\"".\n"")
       }
       else {
         attr(var, ""value.labels"") <- c(as.character(c(minval:maxval)))

---FILE: R/sjPlotAncovaLSMeans.R---
@@ -20,7 +20,7 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""xn"", ""vld""))
 #' @seealso \itemize{
 #'            \item \href{http://www.strengejacke.de/sjPlot/sjp.emm.int/}{sjPlot manual: sjp.emm.int}
 #'            \item \href{http://strengejacke.wordpress.com/2014/08/19/visualize-pre-post-comparison-of-intervention-rstats/}{Weblog example}
-#'            \item \code{\link{sjp.lm.int}}
+#'            \item \code{\link{sjp.int}}
 #'            \item \code{\link{sjp.reglin}}
 #'            \item \code{\link{sjp.aov1}}
 #'            \item \code{\link{sjp.lm.ma}}

---FILE: R/sjPlotAnova.R---
@@ -524,16 +524,16 @@ sjs.aov1.levene <- function(depVar, grpVar) {
   # calculate means
   means <- tapply(df$depVar, df$grpVar, mean)
   depVarNew <- abs(df$depVar - means[df$grpVar])
-  cat(""\nLevene's Test for Homogeneity of Variances\n------------------------------------------\n"")
+  message(""\nLevene's Test for Homogeneity of Variances\n------------------------------------------"")
   fit <- aov(depVarNew ~ df$grpVar)
   print(summary(fit))
   pval <- summary(fit)[[1]]['Pr(>F)'][1,1]
   # print ""summary"" of test
-  cat(""\nConclusion:\n"")
+  message(""\nConclusion:"")
   if (pval>0.05) {
-    cat(""Groups are homogeneous. Everything's fine.\n"")
+    message(""Groups are homogeneous. Everything's fine.\n"")
   }
   else {
-    cat(""Groups are not homogeneous!\n"")
+    message(""Groups are not homogeneous!\n"")
   }
 }

---FILE: R/sjPlotClusterAnalysis.R---
@@ -236,7 +236,7 @@ sjc.qclus <- function(data,
     # check whether method is kmeans. hierarchical clustering
     # requires a specified groupcount
     if (method!=""k"") {
-      cat(""\nCannot compute hierarchical cluster analysis when 'groupcount' is NULL. Using kmeans clustering instead.\n"")
+      message(""\nCannot compute hierarchical cluster analysis when 'groupcount' is NULL. Using kmeans clustering instead.\n"")
       method <- ""k""
     }
     # retrieve optimal group count via gap statistics
@@ -876,9 +876,9 @@ sjc.kgap <- function(x, max=10, B=100, SE.factor=1, method=""Tibs2001SEmax"", plot
   gap <- cluster::clusGap(x, kmeans, max, B)
 
   stopifnot((K <- nrow(T <-gap$Tab)) >= 1, SE.factor >= 0)
-  cat(""Clustering Gap statistic [\""clusGap\""].\n"", sprintf(""B=%d simulated reference sets, k = 1..%d\n"",gap$B, K), sep="""")
+  message(""Clustering Gap statistic [\""clusGap\""].\n"", sprintf(""B=%d simulated reference sets, k = 1..%d\n"",gap$B, K), sep="""")
   nc <- cluster::maxSE(f = T[,""gap""], SE.f = T[,""SE.sim""], method=method, SE.factor=SE.factor)
-  cat(sprintf("" --> Number of clusters (method '%s'%s): %d\n"",
+  message(sprintf("" --> Number of clusters (method '%s'%s): %d\n"",
               method,
               if(grepl(""SE"", method)) sprintf("", SE.factor=%g"",SE.factor) else """", nc))
   # point size for cluster solution

---FILE: R/sjPlotCorr.R---
@@ -295,7 +295,7 @@ sjp.corr <- function(data,
       correlationPValues <- c("""")
     }
   }
-  cat(sprintf(""Computing correlation using %s-method with %s-deletion...\n"", corMethod, missingDeletion))
+  message(sprintf(""Computing correlation using %s-method with %s-deletion..."", corMethod, missingDeletion))
   # --------------------------------------------------------
   # start with base plot object here
   # --------------------------------------------------------

---FILE: R/sjPlotFrequencies.R---
@@ -325,7 +325,7 @@ sjp.frq <- function(varCount,
   # check whether variable should be auto-grouped
   #---------------------------------------------------
   if (!is.null(autoGroupAt) && length(unique(varCount))>=autoGroupAt) {
-    cat(sprintf(""\nVariable has %i unique values and was grouped...\n"", length(unique(varCount))))
+    message(sprintf(""Variable has %i unique values and was grouped..."", length(unique(varCount))))
     agcnt <- ifelse (autoGroupAt<30, autoGroupAt, 30)
     axisLabels.x <- sju.groupVarLabels(varCount, groupsize=""auto"", autoGroupCount=agcnt)
     varCount <- sju.groupVar(varCount, groupsize=""auto"", asNumeric=TRUE, autoGroupCount=agcnt)
@@ -655,7 +655,7 @@ sjp.frq <- function(varCount,
       # base constructor
       if (hist.skipZeros) {
         x <- na.omit(varCount)
-        if (geom.size<round(diff(range(x))/50)) cat(""Using very small binwidth. Consider adjusting \""geom.size\""-parameter.\n"")
+        if (geom.size<round(diff(range(x))/50)) message(""Using very small binwidth. Consider adjusting \""geom.size\""-parameter."")
         hist.dat <- data.frame(x)
         baseplot <- ggplot(mydat)
         basehist <- geom_histogram(data = hist.dat, aes(x = x), binwidth = geom.size, fill = geom.colors)

---FILE: R/sjPlotGLME.R---
@@ -28,7 +28,7 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""nQQ"", ""ci"", ""fixef"", ""fa
 #'            \item \code{""fe.pc""} or \code{""fe.prob""} to plot probability curves of all fixed effects coefficients. Use \code{facet.grid} to decide whether to plot each coefficient as separate plot or as integrated faceted plot.
 #'            \item \code{""ri.pc""} or \code{""ri.prob""} to plot probability curves of random intercept variances for all fixed effects coefficients. Use \code{facet.grid} to decide whether to plot each coefficient as separate plot or as integrated faceted plot.
 #'          }
-#' @param ri.nr Numeric value. If \code{type = ""re} and fitted model has more than one random
+#' @param ri.nr Numeric value. If \code{type = ""re""} and fitted model has more than one random
 #'          intercept, \code{ri.nr} indicates which random effects of which random intercept (or:
 #'          which list element of \code{lme4::ranef}) will be plotted. Default is \code{1},
 #'          so the first (or only) random intercept will be plotted.
@@ -219,7 +219,7 @@ sjp.glmer <- function(fit,
 #'            \item \code{""fe.cor""} for correlation matrix of fixed effects
 #'            \item \code{""re.qq""} for a QQ-plot of random effects (random effects quantiles against standard normal quantiles)
 #'          }
-#' @param ri.nr Numeric value. If \code{type = ""re} and fitted model has more than one random
+#' @param ri.nr Numeric value. If \code{type = ""re""} and fitted model has more than one random
 #'          intercept, \code{ri.nr} indicates which random effects of which random intercept (or:
 #'          which list element of \code{lme4::ranef}) will be plotted. Default is \code{1},
 #'          so the first (or only) random intercept will be plotted.
@@ -464,7 +464,7 @@ sjp.lme4  <- function(fit,
             # (group levels / labels) have to be re-sorted for
             # each coefficient, which is not possible with facet.grids
             # ---------------------------------------
-            cat(""Sorting each group of random intercept ('sort.all') is not possible when 'facet.grids = TRUE'."")
+            message(""Sorting each group of random intercept ('sort.all') is not possible when 'facet.grids = TRUE'."")
           }
           else {
             # ---------------------------------------
@@ -1048,7 +1048,7 @@ sjp.lme.reqq <- function(fit,
   # print plot?
   # ---------------------------------------------------------
   if (printPlot) {
-    print(""Testing for normal distribution. Dots should be plotted along the line."")
+    message(""Testing for normal distribution. Dots should be plotted along the line."")
     print(gp)
   }
   # -------------------------------------

---FILE: R/sjPlotGroupFrequencies.R---
@@ -324,7 +324,7 @@ sjp.grpfrq <- function(varCount,
   # check whether variable should be auto-grouped
   #---------------------------------------------------
   if (!is.null(autoGroupAt) && length(unique(varCount))>=autoGroupAt) {
-    cat(sprintf(""\nVariable has %i unique values and was grouped...\n"", length(unique(varCount))))
+    message(sprintf(""Variable has %i unique values and was grouped..."", length(unique(varCount))))
     agcnt <- ifelse (autoGroupAt<30, autoGroupAt, 30)
     axisLabels.x <- sju.groupVarLabels(varCount, groupsize=""auto"", autoGroupCount=agcnt)
     varCount <- sju.groupVar(varCount, groupsize=""auto"", asNumeric=TRUE, autoGroupCount=agcnt)

---FILE: R/sjPlotLinreg.R---
@@ -9,7 +9,7 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""vars"", ""Beta"", ""xv"", ""lo
 #'              \item \href{http://www.strengejacke.de/sjPlot/sjp.lm}{sjPlot manual: sjp.lm}
 #'              \item \code{\link{sjp.lm.ma}}
 #'              \item \code{\link{sjp.reglin}}
-#'              \item \code{\link{sjp.lm.int}}
+#'              \item \code{\link{sjp.int}}
 #'              \item \code{\link{sjp.scatter}}
 #'              \item  \code{\link{sjs.betaCoef}}
 #'             }
@@ -370,7 +370,7 @@ sjp.lm <- function(fit,
 #'              \item \href{http://www.strengejacke.de/sjPlot/sjp.lm}{sjPlot manual: sjp.lm}
 #'              \item \code{\link{sjp.lm}}
 #'              \item \code{\link{sjp.lm.ma}}
-#'              \item \code{\link{sjp.lm.int}}
+#'              \item \code{\link{sjp.int}}
 #'              \item \code{\link{sjp.scatter}}
 #'             }
 #'          
@@ -535,7 +535,7 @@ sjp.reglin <- function(fit,
 #'              \item \href{http://www.strengejacke.de/sjPlot/sjp.lm}{sjPlot manual: sjp.lm}
 #'              \item \code{\link{sjp.lm}}
 #'              \item \code{\link{sjp.reglin}}
-#'              \item \code{\link{sjp.lm.int}}
+#'              \item \code{\link{sjp.int}}
 #'             }
 #'          
 #' @param linreg a fitted lm-model
@@ -607,7 +607,7 @@ sjp.lm.ma <- function(linreg, showOriginalModelOnly=TRUE, completeDiagnostic=FAL
   # ---------------------------------
   # print steps from original to updated model
   # ---------------------------------
-  cat(sprintf((""\nRemoved %i cases during %i step(s).\nR-square/adj. R-square of original model: %f / %f\nR-square/adj. R-square of updated model: %f / %f\n\n""), 
+  message(sprintf((""Removed %i cases during %i step(s).\nR-square/adj. R-square of original model: %f / %f\nR-square/adj. R-square of updated model: %f / %f\n""), 
               removedcases,
               maxloops-(maxcnt+1), 
               summary(linreg)$r.squared, 

---FILE: R/sjPlotOdds.R---
@@ -381,13 +381,13 @@ sjp.glm <- function(fit,
                       la=sprintf(""%.2f"", -2*logLik(fit)),
                       c2=sprintf(""%.2f"", Chisquare.glm(fit)),
                       aic=sprintf(""%.2f"", fit$aic)))))
-    cat(sprintf(""Intercept = %.2f\nR2[cs] = %.3f\nR2[n] = %.3f\nLambda = %.2f\nChi2 = %.2f\nAIC = %.2f"",
-            exp(coef(fit)[1]),
-            psr[2],
-            psr[3],
-            -2*logLik(fit),
-            Chisquare.glm(fit),
-            fit$aic))
+    cat(sprintf(""Intercept = %.2f\nR2[cs] = %.3f\nR2[n] = %.3f\nLambda = %.2f\nChi2 = %.2f\nAIC = %.2f\n"",
+                exp(coef(fit)[1]),
+                psr[2],
+                psr[3],
+                -2*logLik(fit),
+                Chisquare.glm(fit),
+                fit$aic))
   }
   else {
     modsum <- NULL
@@ -708,12 +708,12 @@ sjp.glm.ma <- function(logreg, showOriginalModelOnly=TRUE) {
   # ---------------------------------
   # print steps from original to updated model
   # ---------------------------------
-  cat(sprintf((""\nRemoved %i cases during %i step(s).\nAIC-value of original model: %.2f\nAIC-value of updated model: %.2f\n\n""),
-              removedcases,
-              maxloops-(maxcnt+1),
-              logreg$aic,
-              model$aic))
-
+  message(sprintf((""Removed %i cases during %i step(s).\nAIC-value of original model: %.2f\nAIC-value of updated model: %.2f\n""),
+                  removedcases,
+                  maxloops-(maxcnt+1),
+                  logreg$aic,
+                  model$aic))
+  
   modelOptmized <- ifelse(removedcases>0, TRUE, FALSE)
   if (showOriginalModelOnly) modelOptmized <- FALSE
   # ---------------------------------
@@ -774,11 +774,11 @@ sjp.glm.ma <- function(logreg, showOriginalModelOnly=TRUE) {
   # We can see that all terms were highly significant when they were
   # introduced into the model.
   # -------------------------------------
-  cat(paste(""\n--------------------\nCheck significance of terms when they entered the model...\n""))
-  cat(paste(""\nAnova original model:\n""))
+  message(paste(""--------------------\nCheck significance of terms when they entered the model...""))
+  message(paste(""Anova original model:""))
   print(anova(logreg,test=""Chisq""))
   if (!showOriginalModelOnly) {
-    cat(paste(""\n\n\nAnova updated model:\n""))
+    message(paste(""\n\nAnova updated model:\n""))
     print(anova(model,test=""Chisq""))
   }
   # -------------------------------------

---FILE: R/sjPlotPCA.R---
@@ -205,11 +205,11 @@ sjp.pca <- function(data,
         labs(title = NULL, y = ""Eigenvalue"", x = ""Number of factors"")
     plot(eigenplot)
     # print statistics
-    cat(""\n--------------------------------------------\n"")
+    message(""--------------------------------------------"")
     print(summary(pcadata))
-    cat(""\nEigenvalues:\n"")
+    message(""Eigenvalues:"")
     print(pcadata.eigenval)
-    cat(""--------------------------------------------\n"")
+    message(""--------------------------------------------"")
   }
   # --------------------------------------------------------
   # varimax rotation, retrieve factor loadings
@@ -323,7 +323,7 @@ sjp.pca <- function(data,
     alphaValues <- getCronbach(data, getItemLoadings(df))
   }
   else {
-    cat(""\nCronbach's Alpha can only be calculated when having a data frame with each component / variable as column\n"")
+    message(""Cronbach's Alpha can only be calculated when having a data frame with each component / variable as column."")
     showCronbachsAlpha <- FALSE
   }
   # retrieve those items that have unclear factor loadings, i.e.
@@ -393,13 +393,13 @@ sjp.pca <- function(data,
   # --------------------------------------------------------
   remdf <- NULL
   if (class(data) == ""data.frame"") {
-    cat(""\nFollowing items have been removed:\n"")
+    message(""Following items have been removed:"")
     if (!is.null(removableItems)) {
-      print(colnames(data)[removableItems])
+      message(colnames(data)[removableItems])
       remdf <- data[,c(-removableItems)]
     }
     else {
-      cat(""none.\n"")
+      message(""none."")
     }
   }
   # --------------------------------------------------------

---FILE: R/sjPlotScatter.R---
@@ -171,7 +171,7 @@ sjp.scatter <- function(x,
     # check for valid range of jitter ratio
     if (jitterRatio<=0 || jitterRatio>=1) {
       # inform user
-      cat(""\njitterRatio out of valid bounds. Using 0.15 for jitterRatio...\n"")
+      warning(""jitterRatio out of valid bounds. Using 0.15 for jitterRatio..."")
       jitterRatio <- 0.15
     }
     # retrieve the highest amount of points lying
@@ -181,7 +181,7 @@ sjp.scatter <- function(x,
     if (overlap < (length(x)*jitterRatio)) {
       # use jittering now
       useJitter <- TRUE
-      cat(""\nauto-jittering values...\n"")
+      message(""auto-jittering values..."")
     }
   }
   # --------------------------------------------------------

---FILE: R/sjRecode.R---
@@ -920,7 +920,7 @@ sju.strpos <- function(searchString, findTerm, maxdist = 3, part.dist.match = 0,
   # check if required package is available
   # -------------------------------------
   if (!requireNamespace(""stringdist"", quietly = TRUE)) {
-    cat(""Package 'stringdist' needed for this function to fully work. Please install it. Only partial matching indices are returned."")
+    warning(""Package 'stringdist' needed for this function to fully work. Please install it. Only partial matching indices are returned."")
     return (indices)
   }
   # -------------------------------------
@@ -1011,7 +1011,7 @@ sju.strpos <- function(searchString, findTerm, maxdist = 3, part.dist.match = 0,
 #'                row means from a \link{data.frame} or \link{matrix} if at least \code{n}
 #'                values of a row a valid (and not \link{NA}).
 #'
-#' @param df a \link{data.frame} with at least two columns, where row means are applied.
+#' @param dat a \link{data.frame} with at least two columns, where row means are applied.
 #' @param n the amount of valid values per row to calculate the row mean. If a row's valid
 #'          values is smaller than \code{n}, \link{NA} will be returned as row mean value.
 #' 
@@ -1024,31 +1024,34 @@ sju.strpos <- function(searchString, findTerm, maxdist = 3, part.dist.match = 0,
 #'              }
 #' 
 #' @examples
-#' df <- data.frame(a=c(1,2,NA,4), b=c(NA,2,NA,5), c=c(NA,4,NA,NA), d=c(2,3,7,8))
-#' sju.mean.n(df, 4) # 1 valid return value
-#' sju.mean.n(df, 3) # 2 valid return values
-#' sju.mean.n(df, 2)
-#' sju.mean.n(df, 1) # all means are shown
+#' dat <- data.frame(c1 = c(1,2,NA,4), 
+#'                   c2 = c(NA,2,NA,5), 
+#'                   c3 = c(NA,4,NA,NA), 
+#'                   c4 = c(2,3,7,8))
+#' sju.mean.n(dat, 4) # 1 valid return value
+#' sju.mean.n(dat, 3) # 2 valid return values
+#' sju.mean.n(dat, 2)
+#' sju.mean.n(dat, 1) # all means are shown
 #' 
 #' @export
-sju.mean.n <- function(df, n) {
+sju.mean.n <- function(dat, n) {
   # ---------------------------------------
   # coerce matrix to data frame
   # ---------------------------------------
-  if (is.matrix(df)) df <- as.data.frame(df)
+  if (is.matrix(dat)) dat <- as.data.frame(dat)
   # ---------------------------------------
   # check if we have a data framme with at least two columns
   # ---------------------------------------
-  if (!is.data.frame(df) || ncol(df) < 2) {
-    warning(""'df' must be a data.frame with at least two columns."")
+  if (!is.data.frame(dat) || ncol(dat) < 2) {
+    warning(""'dat' must be a data.frame with at least two columns."")
     return (NA)
   }
   # ---------------------------------------
   # n may not be larger as df's amount of columns
   # ---------------------------------------
-  if (ncol(df) < n) {
+  if (ncol(dat) < n) {
     warning(""'n' must be smaller or equal to data.frame's amount of columns."")
     return (NA)
   }
-  apply(df, 1, function(x) ifelse(sum(!is.na(x)) >= n, mean(x, na.rm=TRUE), NA))
+  apply(dat, 1, function(x) ifelse(sum(!is.na(x)) >= n, mean(x, na.rm=TRUE), NA))
 }

---FILE: R/sjStatistics.R---
@@ -155,9 +155,9 @@ sjs.mwu <- function(var, grp, distribution=""asymptotic"", weights=NULL) {
   }
   cnt <- length(unique(na.omit(grp)))
   labels <- autoSetValueLabels(grp)
-  cat(""\nPerforming Mann-Whitney-U-Test...\n"")
-  cat(""---------------------------------\n"")
-  cat(""(showing statistics between groups (x|y)\n"")
+  message(""Performing Mann-Whitney-U-Test..."")
+  message(""---------------------------------"")
+  message(""showing statistics between groups (x|y)"")
   df <- data.frame()
   for (i in 1:cnt) {
     for (j in i:cnt) {
@@ -188,24 +188,24 @@ sjs.mwu <- function(var, grp, distribution=""asymptotic"", weights=NULL) {
         rkm.i <- mean(rank(xsub)[which(ysub.n==i)], na.rm=TRUE)
         rkm.j <- mean(rank(xsub)[which(ysub.n==j)], na.rm=TRUE)
         if (is.null(labels)) {
-          cat(sprintf(""Groups (%i|%i), n=%i/%i:\n"", i, j, length(xsub[which(ysub.n==i)]), length(xsub[which(ysub.n==j)])))
+          cat(sprintf(""Groups (%i|%i), n = %i/%i:\n"", i, j, length(xsub[which(ysub.n==i)]), length(xsub[which(ysub.n==j)])))
         }
         else {
-          cat(sprintf(""Groups %i=%s (n=%i) | %i=%s (n=%i):\n"", i, labels[i], length(xsub[which(ysub.n==i)]), j, labels[j], length(xsub[which(ysub.n==j)])))
+          cat(sprintf(""Groups %i = %s (n = %i) | %i = %s (n = %i):\n"", i, labels[i], length(xsub[which(ysub.n==i)]), j, labels[j], length(xsub[which(ysub.n==j)])))
         }
-        cat(sprintf(""  U=%.3f, W=%.3f, p=%.3f, Z=%.3f\n  effect-size r=%.3f\n  rank-mean(%i)=%.2f\n  rank-mean(%i)=%.2f\n\n"", u, w, p, z, r, i, rkm.i, j, rkm.j))
+        cat(sprintf(""  U = %.3f, W = %.3f, p = %.3f, Z = %.3f\n  effect-size r = %.3f\n  rank-mean(%i) = %.2f\n  rank-mean(%i) = %.2f\n\n"", u, w, p, z, r, i, rkm.i, j, rkm.j))
         df <- rbind(df, cbind(grp1=i, grp2=j, u=u, w=w, p=p, z=z, r=r, rank.mean.grp1=rkm.i, rank.mean.grp2=rkm.j))
       }
     }
   }
   # if we have more than 2 groups, also perfom kruskal-wallis-test
   if (cnt>2) {
-    cat(""\nPerforming Kruskal-Wallis-Test...\n"")
-    cat(""---------------------------------\n"")
+    message(""Performing Kruskal-Wallis-Test..."")
+    message(""---------------------------------"")
     kw <- kruskal.test(var, grp)
-    cat(sprintf(""chi-squared=%.3f\n"",kw$statistic ))
-    cat(sprintf(""df=%i\n"",kw$parameter ))
-    cat(sprintf(""p=%.3f\n"",kw$p.value ))
+    cat(sprintf(""chi-squared = %.3f\n"",kw$statistic ))
+    cat(sprintf(""df = %i\n"",kw$parameter ))
+    cat(sprintf(""p = %.3f\n"",kw$p.value ))
   }
   invisible(df)
 }

---FILE: R/sjTabFrequencies.R---
@@ -203,7 +203,7 @@ sjt.frq <- function (data,
   # -------------------------------------
   # warning
   # -------------------------------------
-  if (!is.null(sort.frq)) cat(""Sorting may not work when data contains values with zero-counts."")
+  if (!is.null(sort.frq)) message(""Sorting may not work when data contains values with zero-counts."")
   # -------------------------------------
   # table init
   # -------------------------------------
@@ -441,7 +441,7 @@ sjt.frq <- function (data,
     # check for length of unique values and skip if too long
     # -----------------------------------------------
     if (!is.null(autoGroupAt) && length(unique(var))>=autoGroupAt) {
-      cat(sprintf(""\nVariable %s with %i unique values was grouped...\n"", colnames(data)[cnt], length(unique(var))))
+      message(sprintf(""Variable %s with %i unique values was grouped..."", colnames(data)[cnt], length(unique(var))))
       varsum <- var
       agcnt <- ifelse (autoGroupAt<30, autoGroupAt, 30)
       valueLabels[[cnt]] <- sju.groupVarLabels(var, groupsize=""auto"", autoGroupCount=agcnt)

---FILE: R/sjTabPCA.R---
@@ -385,7 +385,7 @@ sjt.pca <- function (data,
     alphaValues <- getCronbach(data, getItemLoadings(df))
   }
   else {
-    cat(""\nCronbach's Alpha can only be calculated when having a data frame with each component / variable as column\n"")
+    message(""Cronbach's Alpha can only be calculated when having a data frame with each component / variable as column."")
     alphaValues <- NULL
     showCronbachsAlpha <- FALSE
   }

---FILE: README.md---
@@ -50,6 +50,9 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 * Removed parameters `maxYlim` and `upperYLim` from `sjp.grpfrq`, `sjp.xtab` and `sjp.frq`, and added `axisLimits.y` as new option to define y-axis-range.
 * Parameter `labelPos` now also works for flipped coordinates in `sjp.xtab`.
 
+#### General
+* Console output of various function that used the `cat` or `print` command were replaced by `message` or `warning`, if more appropriate.
+
 #### Bug fixes
 * Parameter `geom.size` was not applied to bar charts in `sjp.grpfrq` - fixed.
 * Q-Q plot of `sjp.lm.ma` used wrong linear q-q line - fixed.

---FILE: man/sjp.emm.int.Rd---
@@ -126,7 +126,7 @@ sjp.emm.int(fit, plevel=1, swapPredictors=TRUE)}
 \itemize{
            \item \href{http://www.strengejacke.de/sjPlot/sjp.emm.int/}{sjPlot manual: sjp.emm.int}
            \item \href{http://strengejacke.wordpress.com/2014/08/19/visualize-pre-post-comparison-of-intervention-rstats/}{Weblog example}
-           \item \code{\link{sjp.lm.int}}
+           \item \code{\link{sjp.int}}
            \item \code{\link{sjp.reglin}}
            \item \code{\link{sjp.aov1}}
            \item \code{\link{sjp.lm.ma}}

---FILE: man/sjp.glmer.Rd---
@@ -23,7 +23,7 @@ sjp.glmer(fit, type = ""re"", ri.nr = 1, title = NULL, geom.size = 3,
   \item \code{""ri.pc""} or \code{""ri.prob""} to plot probability curves of random intercept variances for all fixed effects coefficients. Use \code{facet.grid} to decide whether to plot each coefficient as separate plot or as integrated faceted plot.
 }}
 
-\item{ri.nr}{Numeric value. If \code{type = ""re} and fitted model has more than one random
+\item{ri.nr}{Numeric value. If \code{type = ""re""} and fitted model has more than one random
 intercept, \code{ri.nr} indicates which random effects of which random intercept (or:
 which list element of \code{lme4::ranef}) will be plotted. Default is \code{1},
 so the first (or only) random intercept will be plotted.}

---FILE: man/sjp.lm.Rd---
@@ -118,7 +118,7 @@ sjp.lm(fit, showStandardBeta=FALSE)
              \item \href{http://www.strengejacke.de/sjPlot/sjp.lm}{sjPlot manual: sjp.lm}
              \item \code{\link{sjp.lm.ma}}
              \item \code{\link{sjp.reglin}}
-             \item \code{\link{sjp.lm.int}}
+             \item \code{\link{sjp.int}}
              \item \code{\link{sjp.scatter}}
              \item  \code{\link{sjs.betaCoef}}
             }

---FILE: man/sjp.lm.ma.Rd---
@@ -38,7 +38,7 @@ fit.updated <- sjp.lm.ma(fit, completeDiagnostic = TRUE)}
              \item \href{http://www.strengejacke.de/sjPlot/sjp.lm}{sjPlot manual: sjp.lm}
              \item \code{\link{sjp.lm}}
              \item \code{\link{sjp.reglin}}
-             \item \code{\link{sjp.lm.int}}
+             \item \code{\link{sjp.int}}
             }
 }
 

---FILE: man/sjp.lmer.Rd---
@@ -20,7 +20,7 @@ sjp.lmer(fit, type = ""re"", ri.nr = 1, title = NULL, geom.size = 3,
   \item \code{""re.qq""} for a QQ-plot of random effects (random effects quantiles against standard normal quantiles)
 }}
 
-\item{ri.nr}{Numeric value. If \code{type = ""re} and fitted model has more than one random
+\item{ri.nr}{Numeric value. If \code{type = ""re""} and fitted model has more than one random
 intercept, \code{ri.nr} indicates which random effects of which random intercept (or:
 which list element of \code{lme4::ranef}) will be plotted. Default is \code{1},
 so the first (or only) random intercept will be plotted.}

---FILE: man/sjp.reglin.Rd---
@@ -88,7 +88,7 @@ sjp.reglin(fit, showCI=FALSE)
              \item \href{http://www.strengejacke.de/sjPlot/sjp.lm}{sjPlot manual: sjp.lm}
              \item \code{\link{sjp.lm}}
              \item \code{\link{sjp.lm.ma}}
-             \item \code{\link{sjp.lm.int}}
+             \item \code{\link{sjp.int}}
              \item \code{\link{sjp.scatter}}
             }
 }

---FILE: man/sju.mean.n.Rd---
@@ -3,10 +3,10 @@
 \alias{sju.mean.n}
 \title{Compute row means with min amount of valid values}
 \usage{
-sju.mean.n(df, n)
+sju.mean.n(dat, n)
 }
 \arguments{
-\item{df}{a \link{data.frame} with at least two columns, where row means are applied.}
+\item{dat}{a \link{data.frame} with at least two columns, where row means are applied.}
 
 \item{n}{the amount of valid values per row to calculate the row mean. If a row's valid
          values is smaller than \code{n}, \link{NA} will be returned as row mean value.}
@@ -21,11 +21,14 @@ This function is similar to the SPSS \code{MEAN.n} function and computes
                values of a row a valid (and not \link{NA}).
 }
 \examples{
-df <- data.frame(a=c(1,2,NA,4), b=c(NA,2,NA,5), c=c(NA,4,NA,NA), d=c(2,3,7,8))
-sju.mean.n(df, 4) # 1 valid return value
-sju.mean.n(df, 3) # 2 valid return values
-sju.mean.n(df, 2)
-sju.mean.n(df, 1) # all means are shown
+dat <- data.frame(c1 = c(1,2,NA,4),
+                  c2 = c(NA,2,NA,5),
+                  c3 = c(NA,4,NA,NA),
+                  c4 = c(2,3,7,8))
+sju.mean.n(dat, 4) # 1 valid return value
+sju.mean.n(dat, 3) # 2 valid return values
+sju.mean.n(dat, 2)
+sju.mean.n(dat, 1) # all means are shown
 }
 \references{
 \itemize{"
strengejacke,sjPlot,d13b6732c6297420a37e8a91a9741a9529bcc26c,Daniel Ldecke,d.luedecke@uke.de,2014-12-10T19:01:00Z,Daniel Ldecke,d.luedecke@uke.de,2014-12-10T19:01:00Z,fixed version number in read.me,README.md,False,False,False,False,1,1,2,"---FILE: README.md---
@@ -34,7 +34,7 @@ install.packages(""sjPlot"")
 In case you want / have to cite my package, please use `citation('sjPlot')` for citation information. Since this package makes heavy use of the [ggplot-package](http://cran.r-project.org/web/packages/ggplot2/index.html), consider citing this package as well.
 
 
-### Changelog of development build 1.6.1-4
+### Changelog of development build 1.6.1-6
 
 #### New functions
 * New function `sjp.int`, which can plot regression lines or probability curves of interaction effects in (generalized) linear (mixed effects) models, i.e. fitted models of class `lm`, `glm`, `lmerMod` and `glmerMod` are covered by this function."
strengejacke,sjPlot,1fd2a10f17b5eacd73d7ff0f6342748121937374,Daniel Ldecke,d.luedecke@uke.de,2014-12-03T11:09:47Z,Daniel Ldecke,d.luedecke@uke.de,2014-12-03T11:09:47Z,"fixed CRAN check issues

Needed to reset repository due to conflicts",.gitignore;DESCRIPTION;R/sjPlotFrequencies.R;R/sjPlotPropTable.R;R/sjRecode.R;R/sjTabPropTable.R;README.md;man/sjp.frq.Rd;man/sjt.xtab.Rd;man/sju.groupVar.Rd;man/sju.groupVarLabels.Rd,False,True,True,False,53,59,112,"---FILE: .gitignore---
@@ -53,3 +53,4 @@ $RECYCLE.BIN/
 *.msi
 *.msm
 *.msp
+.Rproj.user

---FILE: DESCRIPTION---
@@ -6,8 +6,8 @@ Version: 1.6.1-4
 Date: 2014-12-03
 Author: Daniel Ldecke <d.luedecke@uke.de>
 Maintainer: Daniel Luedecke <d.luedecke@uke.de>
-Description: Collection of several plotting / table output functions for
-    visualizing data and utility functions.
+Description: Collection of several plotting and table output functions for
+    visualizing data, and utility functions.
 License: GPL-3
 Imports:
     ggplot2,

---FILE: R/sjPlotFrequencies.R---
@@ -211,7 +211,10 @@ if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""frq"", ""grp"", ""ia"", ""..de
 #' # Simulate ggplot-default histogram, using ""hist.skipZeros""
 #' # and adjusted ""geom.size"".
 #' # -------------------------------------------------
-#' sjp.frq(efc$c160age, type=""h"", hist.skipZeros=TRUE, geom.size=1)
+#' sjp.frq(efc$c160age, 
+#'         type = ""h"", 
+#'         hist.skipZeros = TRUE, 
+#'         geom.size = 1)
 #' 
 #'   
 #' @import ggplot2
@@ -795,3 +798,5 @@ insertRowToDF<-function(X,index_after,vector_to_insert){
   X<-rbind(X[1:index_after,],vector_to_insert,X[(index_after+1):nrow(X),])
   row.names(X)<-1:nrow(X)
   return (X)
+}
+

---FILE: R/sjPlotPropTable.R---
@@ -1,5 +1,5 @@
 # bind global variables
-if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""Perc"", ""Sum"", ""Count"", ""Group""))
+if(getRversion() >= ""2.15.1"") utils::globalVariables(c(""Perc"", ""Sum"", ""Count"", ""Group"", ""line.break""))
 
 #' @title Plot contingency tables
 #' @name sjp.xtab

---FILE: R/sjRecode.R---
@@ -102,8 +102,7 @@ sju.dicho <- function(var, dichBy=""median"", dichVal=-1, asNum = FALSE) {
 #' ageGrpLab <- sju.groupVarLabels(efc$e17age)
 #' sjp.frq(ageGrp,
 #'         title=efc.var[['e17age']],
-#'         axisLabels.x=ageGrpLab,
-#'         maxYlim=FALSE)
+#'         axisLabels.x=ageGrpLab)
 #'  
 #' @export
 sju.groupVar <- function(var, groupsize=5, asNumeric=TRUE, rightInterval=FALSE, autoGroupCount=30) {
@@ -189,8 +188,7 @@ sju.groupVar <- function(var, groupsize=5, asNumeric=TRUE, rightInterval=FALSE,
 #' ageGrpLab <- sju.groupVarLabels(efc$e17age)
 #' sjp.frq(ageGrp,
 #'         title=efc.var[['e17age']],
-#'         axisLabels.x=ageGrpLab,
-#'         maxYlim=FALSE)
+#'         axisLabels.x=ageGrpLab)
 #' 
 #' @export
 sju.groupVarLabels <- function(var, groupsize=5, rightInterval=FALSE, autoGroupCount=30) {

---FILE: R/sjTabPropTable.R---
@@ -116,49 +116,47 @@
 #' 
 #' # print simple cross table w/o labels
 #' \dontrun{
-#' sjt.xtab(efc$e16sex, efc$e42dep)}
+#' sjt.xtab(efc$e16sex, efc$e42dep)
 #'          
 #' # print cross table with labels and expected values
-#' \dontrun{
-#' sjt.xtab(efc$e16sex, efc$e42dep, 
-#'          variableLabels=c(""Elder's gender"", ""Elder's dependency""),
-#'          valueLabels=list(efc.labels[['e16sex']], efc.labels[['e42dep']]),
-#'          showExpected=TRUE)}
+#' sjt.xtab(efc$e16sex, 
+#'          efc$e42dep, 
+#'          variableLabels = c(""Elder's gender"", 
+#'                             ""Elder's dependency""),
+#'          valueLabels = list(efc.labels[['e16sex']], 
+#'                             efc.labels[['e42dep']]),
+#'          showExpected = TRUE)
 #' 
 #' # print minimal cross table with labels, total col/row highlighted
-#' \dontrun{
 #' sjt.xtab(efc$e16sex, efc$e42dep, 
-#'          variableLabels=c(""Elder's gender"", ""Elder's dependency""),
-#'          valueLabels=list(efc.labels[['e16sex']], efc.labels[['e42dep']]),
-#'          showHorizontalLine=FALSE,
-#'          showCellPerc=FALSE,
-#'          highlightTotal=TRUE)}
+#'          variableLabels = c(""Elder's gender"", ""Elder's dependency""),
+#'          valueLabels = list(efc.labels[['e16sex']], efc.labels[['e42dep']]),
+#'          showHorizontalLine = FALSE,
+#'          showCellPerc = FALSE,
+#'          highlightTotal = TRUE)
 #' 
 #' # -------------------------------
 #' # auto-detection of labels
 #' # -------------------------------
 #' efc <- sji.setVariableLabels(efc, sji.getVariableLabels(efc))
 #' # print cross table with labels and all percentages
-#' \dontrun{
 #' sjt.xtab(efc$e16sex, efc$e42dep,
-#'          showRowPerc=TRUE, showColPerc=TRUE)}
+#'          showRowPerc = TRUE, showColPerc = TRUE)
 #' 
 #' # print cross table with labels and all percentages, including
 #' # grouping variable
-#' \dontrun{
 #' sjt.xtab(efc$e16sex, efc$e42dep, efc$c161sex, 
 #'          variableLabels=c(""Elder's gender"", 
 #'                           ""Elder's dependency"",
 #'                           ""Carer's gender""), 
 #'          valueLabels=list(efc.labels[['e16sex']],
 #'                           efc.labels[['e42dep']],
 #'                           efc.labels[['c161sex']]),
-#'          showRowPerc=TRUE, showColPerc=TRUE)}
+#'          showRowPerc=TRUE, showColPerc=TRUE)
 #'
 #' # ---------------------------------------------------------------- 
 #' # User defined style sheet
 #' # ---------------------------------------------------------------- 
-#' \dontrun{
 #' sjt.xtab(efc$e16sex, efc$e42dep, 
 #'          variableLabels=c(""Elder's gender"", ""Elder's dependency""),
 #'          valueLabels=list(efc.labels[['e16sex']], efc.labels[['e42dep']]),

---FILE: README.md---
@@ -1,6 +1,6 @@
-sjPlot - data visualization
+sjPlot - Data Visualization for Statistics in Social Science
 ------------------------------------------------------------------------------
-Collection of several plotting / table output functions for visualizing data. Results of various statistical analyses (that are commonly used in social sciences) can be visualized using this package, including simple and cross tabulated frequencies, histograms, box plots, (generalized) linear models (forest plots), mixed effects models, PCA, correlations, cluster analyses, scatter plots etc.
+Collection of several plotting and table output functions for visualizing data. Results of various statistical analyses (that are commonly used in social sciences) can be visualized using this package, including simple and cross tabulated frequencies, histograms, box plots, (generalized) linear models (forest plots), mixed effects models, PCA, correlations, cluster analyses, scatter plots etc.
 
 Furthermore, this package contains some tools that are useful when carrying out data analysis or interpreting data (especially intended for people coming from SPSS and/or who are new to R). These tool functions support importing (SPSS) data, variable recoding and weighting, statistical tests, determination of cluster groups, interpretation of interaction terms in regression models etc.
 
@@ -9,20 +9,20 @@ Furthermore, this package contains some tools that are useful when carrying out
 
 #### Latest development build
 
-To install the latest development snapshot (see latest changes below), type following command in the R console:
+To install the latest development snapshot (see latest changes below), type following commands into the R console:
 
 ```r
+library(devtools)
 devtools::install_github(""sjPlot/devel"")
 ```
 
 #### Officiale, stable release
-To install the latest stable release from CRAN, type following command in the R console:
+To install the latest stable release from CRAN, type following command into the R console:
 
 ```r
 install.packages(""sjPlot"")
 ```
 
-<<<<<<< HEAD
 ### References and documentation
 
 - [Documentation](http://www.strengejacke.de/sjPlot/)
@@ -36,10 +36,6 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 
 ### Changelog of development build 1.6.1-4
 
-=======
-### Changelog of development build 1.6.1-3
-
->>>>>>> origin/master
 #### New functions
 * New function `sjp.glm.int` to plot probability curves of interaction terms in generalized linear models.
 
@@ -53,10 +49,7 @@ In case you want / have to cite my package, please use `citation('sjPlot')` for
 
 #### Bug fixes
 * Parameter `geom.size` was not applied to bar charts in `sjp.grpfrq` - fixed.
-<<<<<<< HEAD
 * Q-Q plot of `sjp.lm.ma` used wrong linear q-q line - fixed.
-=======
->>>>>>> origin/master
 
 
 ### Changelog of current stable build 1.6

---FILE: man/sjp.frq.Rd---
@@ -267,7 +267,10 @@ sjp.frq(efc$neg_c_7)
 # Simulate ggplot-default histogram, using ""hist.skipZeros""
 # and adjusted ""geom.size"".
 # -------------------------------------------------
-sjp.frq(efc$c160age, type=""h"", hist.skipZeros=TRUE, geom.size=1)
+sjp.frq(efc$c160age,
+        type = ""h"",
+        hist.skipZeros = TRUE,
+        geom.size = 1)
 }
 \seealso{
 \itemize{

---FILE: man/sjt.xtab.Rd---
@@ -160,49 +160,47 @@ efc.labels <- sji.getValueLabels(efc)
 
 # print simple cross table w/o labels
 \dontrun{
-sjt.xtab(efc$e16sex, efc$e42dep)}
+sjt.xtab(efc$e16sex, efc$e42dep)
 
 # print cross table with labels and expected values
-\dontrun{
-sjt.xtab(efc$e16sex, efc$e42dep,
-         variableLabels=c(""Elder's gender"", ""Elder's dependency""),
-         valueLabels=list(efc.labels[['e16sex']], efc.labels[['e42dep']]),
-         showExpected=TRUE)}
+sjt.xtab(efc$e16sex,
+         efc$e42dep,
+         variableLabels = c(""Elder's gender"",
+                            ""Elder's dependency""),
+         valueLabels = list(efc.labels[['e16sex']],
+                            efc.labels[['e42dep']]),
+         showExpected = TRUE)
 
 # print minimal cross table with labels, total col/row highlighted
-\dontrun{
 sjt.xtab(efc$e16sex, efc$e42dep,
-         variableLabels=c(""Elder's gender"", ""Elder's dependency""),
-         valueLabels=list(efc.labels[['e16sex']], efc.labels[['e42dep']]),
-         showHorizontalLine=FALSE,
-         showCellPerc=FALSE,
-         highlightTotal=TRUE)}
+         variableLabels = c(""Elder's gender"", ""Elder's dependency""),
+         valueLabels = list(efc.labels[['e16sex']], efc.labels[['e42dep']]),
+         showHorizontalLine = FALSE,
+         showCellPerc = FALSE,
+         highlightTotal = TRUE)
 
 # -------------------------------
 # auto-detection of labels
 # -------------------------------
 efc <- sji.setVariableLabels(efc, sji.getVariableLabels(efc))
 # print cross table with labels and all percentages
-\dontrun{
 sjt.xtab(efc$e16sex, efc$e42dep,
-         showRowPerc=TRUE, showColPerc=TRUE)}
+         showRowPerc = TRUE, showColPerc = TRUE)
 
 # print cross table with labels and all percentages, including
 # grouping variable
-\dontrun{
 sjt.xtab(efc$e16sex, efc$e42dep, efc$c161sex,
          variableLabels=c(""Elder's gender"",
                           ""Elder's dependency"",
                           ""Carer's gender""),
          valueLabels=list(efc.labels[['e16sex']],
                           efc.labels[['e42dep']],
                           efc.labels[['c161sex']]),
-         showRowPerc=TRUE, showColPerc=TRUE)}
+         showRowPerc=TRUE, showColPerc=TRUE)
 
 # ----------------------------------------------------------------
 # User defined style sheet
 # ----------------------------------------------------------------
-\dontrun{
 sjt.xtab(efc$e16sex, efc$e42dep,
          variableLabels=c(""Elder's gender"", ""Elder's dependency""),
          valueLabels=list(efc.labels[['e16sex']], efc.labels[['e42dep']]),

---FILE: man/sju.groupVar.Rd---
@@ -57,8 +57,7 @@ ageGrp <- sju.groupVar(efc$e17age)
 ageGrpLab <- sju.groupVarLabels(efc$e17age)
 sjp.frq(ageGrp,
         title=efc.var[['e17age']],
-        axisLabels.x=ageGrpLab,
-        maxYlim=FALSE)
+        axisLabels.x=ageGrpLab)
 }
 \seealso{
 \code{\link{sju.groupVarLabels}}

---FILE: man/sju.groupVarLabels.Rd---
@@ -66,8 +66,7 @@ ageGrp <- sju.groupVar(efc$e17age)
 ageGrpLab <- sju.groupVarLabels(efc$e17age)
 sjp.frq(ageGrp,
         title=efc.var[['e17age']],
-        axisLabels.x=ageGrpLab,
-        maxYlim=FALSE)
+        axisLabels.x=ageGrpLab)
 }
 \seealso{
 \code{\link{sju.groupVar}}"
