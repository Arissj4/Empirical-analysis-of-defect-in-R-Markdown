repo_owner,repo_name,commit_hash,author_name,author_email,author_date,committer_name,committer_email,committer_date,message,filenames,touches_rmd,touches_r,touches_r_or_rmd,is_merge,added,deleted,changed,diff
andrewmarx,samc,cc2f81242fba9ed7b5846c3701aa9ca1a5c8921e,Andrew Marx,andrewjmarx@gmail.com,2024-10-06T15:24:31Z,Andrew Marx,andrewjmarx@gmail.com,2024-10-06T15:24:31Z,Fix check() node count,R/check.R,False,True,True,False,3,1,4,"---FILE: R/check.R---
@@ -209,7 +209,9 @@ setMethod(
 
     if (any(!is.finite(b)) || any(b < 0) || any(is.na(b))) stop(""Input must only contain positive numeric values"", call. = FALSE)
 
-    if (length(b) != nrow(a@data@f)) stop(""Input length does not match number of transient states"", call. = FALSE)
+    # TODO Fix for conv.
+    # UPDATE Fixed? validate
+    if (length(b) != a@nodes) stop(""Input length does not match number of transient states"", call. = FALSE)
 
     if (sum(b) <= 0) stop(""Input must contain at least one positive numeric value"", call. = FALSE)
   })"
andrewmarx,samc,bd632793b955ae402eaf94f425fd86167503ac0e,Andrew Marx,andrewjmarx@gmail.com,2024-07-28T17:22:15Z,Andrew Marx,andrewjmarx@gmail.com,2024-07-28T17:22:15Z,"cleanup C++ code

Various changes for clarity, correctness, and safety. Fixed multiple
interrupt checks to use correct loop variable.",R/RcppExports.R;R/dispersal.R;R/distribution.R;R/mortality.R;R/visitation.R;src/RcppExports.cpp;src/cond_passage.cpp;src/constants.h;src/dispersal.cpp;src/distribution.cpp;src/mortality.cpp;src/solver-cache.cpp;src/solver-cache.h;src/survival.cpp;src/visitation.cpp,False,True,True,False,287,171,458,"---FILE: R/RcppExports.R---
@@ -41,16 +41,16 @@
     .Call('_samc_diagf_par_iter', PACKAGE = 'samc', M, threads)
 }
 
-.qpow_row <- function(M, vec, steps) {
-    .Call('_samc_qpow_row', PACKAGE = 'samc', M, vec, steps)
+.qpow_row <- function(M, vec, t) {
+    .Call('_samc_qpow_row', PACKAGE = 'samc', M, vec, t)
 }
 
-.qpow_col <- function(M, vec, steps) {
-    .Call('_samc_qpow_col', PACKAGE = 'samc', M, vec, steps)
+.qpow_col <- function(M, vec, t) {
+    .Call('_samc_qpow_col', PACKAGE = 'samc', M, vec, t)
 }
 
-.sum_qpowrv <- function(M, rv, steps) {
-    .Call('_samc_sum_qpowrv', PACKAGE = 'samc', M, rv, steps)
+.sum_qpowrv <- function(M, rv, t) {
+    .Call('_samc_sum_qpowrv', PACKAGE = 'samc', M, rv, t)
 }
 
 .solver_cache <- function() {
@@ -65,12 +65,12 @@
     .Call('_samc_f1_iter', PACKAGE = 'samc', M)
 }
 
-.sum_qpow_row <- function(M, vec, steps) {
-    .Call('_samc_sum_qpow_row', PACKAGE = 'samc', M, vec, steps)
+.sum_qpow_row <- function(M, vec, t) {
+    .Call('_samc_sum_qpow_row', PACKAGE = 'samc', M, vec, t)
 }
 
-.sum_qpow_col <- function(M, vec, steps) {
-    .Call('_samc_sum_qpow_col', PACKAGE = 'samc', M, vec, steps)
+.sum_qpow_col <- function(M, vec, t) {
+    .Call('_samc_sum_qpow_col', PACKAGE = 'samc', M, vec, t)
 }
 
 .f_row <- function(M, vec, SC) {

---FILE: R/dispersal.R---
@@ -173,6 +173,7 @@ setMethod(
     } else {
       res = .sum_qn_q(q, q2, qv, time)
     }
+    names(res) <- as.character(time[-1])
 
     res = lapply(res, as.vector)
 

---FILE: R/distribution.R---
@@ -173,6 +173,7 @@ setMethod(
     }
 
     res = .qpow_col(q, vec, time)
+    names(res) = as.character(time[-1])
     res = lapply(res, as.vector)
 
     if (samc@model$name == ""CRW"") {
@@ -224,6 +225,7 @@ setMethod(
       time = c(0, time)
 
       res = .qpow_row(q, pv, time)
+      names(res) = as.character(time[-1])
 
       res = lapply(res, as.vector)
 

---FILE: R/mortality.R---
@@ -237,6 +237,7 @@ setMethod(
     time <- c(1, time)
 
     mort <- .sum_qpowrv(q, rdg, time)
+    names(mort) <- as.character(time[-1])
 
     mort <- lapply(mort, as.vector)
 

---FILE: R/visitation.R---
@@ -229,6 +229,7 @@ setMethod(
     }
 
     ft = .sum_qpow_col(q, vec, time)
+    names(ft) = as.character(time[-1])
 
     ft = lapply(ft, as.vector)
 
@@ -284,6 +285,7 @@ setMethod(
 
       time <- c(1, time)
       ft <- .sum_qpow_row(q, pv, time)
+      names(ft) = as.character(time[-1])
 
       ft = lapply(ft, as.vector)
 

---FILE: src/RcppExports.cpp---
@@ -14,25 +14,25 @@ Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
 #endif
 
 // cond_t
-Rcpp::List cond_t(Eigen::Map<Eigen::SparseMatrix<double> >& IQ, Eigen::VectorXd& qj);
+Rcpp::List cond_t(const Eigen::Map<Eigen::SparseMatrix<double> >& IQ, const Eigen::VectorXd& qj);
 RcppExport SEXP _samc_cond_t(SEXP IQSEXP, SEXP qjSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< Eigen::Map<Eigen::SparseMatrix<double> >& >::type IQ(IQSEXP);
-    Rcpp::traits::input_parameter< Eigen::VectorXd& >::type qj(qjSEXP);
+    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::SparseMatrix<double> >& >::type IQ(IQSEXP);
+    Rcpp::traits::input_parameter< const Eigen::VectorXd& >::type qj(qjSEXP);
     rcpp_result_gen = Rcpp::wrap(cond_t(IQ, qj));
     return rcpp_result_gen;
 END_RCPP
 }
 // cond_t_iter
-Rcpp::List cond_t_iter(Eigen::Map<Eigen::SparseMatrix<double> >& IQ, Eigen::VectorXd& qj);
+Rcpp::List cond_t_iter(const Eigen::Map<Eigen::SparseMatrix<double> >& IQ, const Eigen::VectorXd& qj);
 RcppExport SEXP _samc_cond_t_iter(SEXP IQSEXP, SEXP qjSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< Eigen::Map<Eigen::SparseMatrix<double> >& >::type IQ(IQSEXP);
-    Rcpp::traits::input_parameter< Eigen::VectorXd& >::type qj(qjSEXP);
+    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::SparseMatrix<double> >& >::type IQ(IQSEXP);
+    Rcpp::traits::input_parameter< const Eigen::VectorXd& >::type qj(qjSEXP);
     rcpp_result_gen = Rcpp::wrap(cond_t_iter(IQ, qj));
     return rcpp_result_gen;
 END_RCPP
@@ -92,93 +92,93 @@ BEGIN_RCPP
 END_RCPP
 }
 // sum_qn_q
-Rcpp::List sum_qn_q(const Eigen::Map<Eigen::SparseMatrix<double> >& M, const Eigen::Map<Eigen::SparseMatrix<double> >& M2, const Eigen::VectorXd& q, Rcpp::NumericVector t);
+Rcpp::List sum_qn_q(const Eigen::Map<Eigen::SparseMatrix<double> >& M, const Eigen::Map<Eigen::SparseMatrix<double> >& M2, const Eigen::VectorXd& q, const Rcpp::NumericVector& t);
 RcppExport SEXP _samc_sum_qn_q(SEXP MSEXP, SEXP M2SEXP, SEXP qSEXP, SEXP tSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
     Rcpp::traits::input_parameter< const Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
     Rcpp::traits::input_parameter< const Eigen::Map<Eigen::SparseMatrix<double> >& >::type M2(M2SEXP);
     Rcpp::traits::input_parameter< const Eigen::VectorXd& >::type q(qSEXP);
-    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type t(tSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type t(tSEXP);
     rcpp_result_gen = Rcpp::wrap(sum_qn_q(M, M2, q, t));
     return rcpp_result_gen;
 END_RCPP
 }
 // sum_qn_q_iter
-Rcpp::List sum_qn_q_iter(const Eigen::Map<Eigen::SparseMatrix<double> >& M, const Eigen::Map<Eigen::SparseMatrix<double> >& M2, const Eigen::VectorXd& q, Rcpp::NumericVector t);
+Rcpp::List sum_qn_q_iter(const Eigen::Map<Eigen::SparseMatrix<double> >& M, const Eigen::Map<Eigen::SparseMatrix<double> >& M2, const Eigen::VectorXd& q, const Rcpp::NumericVector& t);
 RcppExport SEXP _samc_sum_qn_q_iter(SEXP MSEXP, SEXP M2SEXP, SEXP qSEXP, SEXP tSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
     Rcpp::traits::input_parameter< const Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
     Rcpp::traits::input_parameter< const Eigen::Map<Eigen::SparseMatrix<double> >& >::type M2(M2SEXP);
     Rcpp::traits::input_parameter< const Eigen::VectorXd& >::type q(qSEXP);
-    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type t(tSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type t(tSEXP);
     rcpp_result_gen = Rcpp::wrap(sum_qn_q_iter(M, M2, q, t));
     return rcpp_result_gen;
 END_RCPP
 }
 // diagf_par
-Rcpp::NumericVector diagf_par(Eigen::Map<Eigen::SparseMatrix<double> >& M, const int threads);
+Rcpp::NumericVector diagf_par(const Eigen::Map<Eigen::SparseMatrix<double> >& M, const int threads);
 RcppExport SEXP _samc_diagf_par(SEXP MSEXP, SEXP threadsSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
+    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
     Rcpp::traits::input_parameter< const int >::type threads(threadsSEXP);
     rcpp_result_gen = Rcpp::wrap(diagf_par(M, threads));
     return rcpp_result_gen;
 END_RCPP
 }
 // diagf_par_iter
-Rcpp::NumericVector diagf_par_iter(Eigen::Map<Eigen::SparseMatrix<double> >& M, const int threads);
+Rcpp::NumericVector diagf_par_iter(const Eigen::Map<Eigen::SparseMatrix<double> >& M, const int threads);
 RcppExport SEXP _samc_diagf_par_iter(SEXP MSEXP, SEXP threadsSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
+    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
     Rcpp::traits::input_parameter< const int >::type threads(threadsSEXP);
     rcpp_result_gen = Rcpp::wrap(diagf_par_iter(M, threads));
     return rcpp_result_gen;
 END_RCPP
 }
 // qpow_row
-Rcpp::List qpow_row(Eigen::Map<Eigen::SparseMatrix<double> >& M, const Eigen::Map<Eigen::VectorXd>& vec, Rcpp::NumericVector steps);
-RcppExport SEXP _samc_qpow_row(SEXP MSEXP, SEXP vecSEXP, SEXP stepsSEXP) {
+Rcpp::List qpow_row(const Eigen::Map<Eigen::SparseMatrix<double> >& M, const Eigen::Map<Eigen::VectorXd>& vec, const Rcpp::NumericVector& t);
+RcppExport SEXP _samc_qpow_row(SEXP MSEXP, SEXP vecSEXP, SEXP tSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
+    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
     Rcpp::traits::input_parameter< const Eigen::Map<Eigen::VectorXd>& >::type vec(vecSEXP);
-    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type steps(stepsSEXP);
-    rcpp_result_gen = Rcpp::wrap(qpow_row(M, vec, steps));
+    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type t(tSEXP);
+    rcpp_result_gen = Rcpp::wrap(qpow_row(M, vec, t));
     return rcpp_result_gen;
 END_RCPP
 }
 // qpow_col
-Rcpp::List qpow_col(Eigen::Map<Eigen::SparseMatrix< double> >& M, const Eigen::Map<Eigen::VectorXd>& vec, Rcpp::NumericVector steps);
-RcppExport SEXP _samc_qpow_col(SEXP MSEXP, SEXP vecSEXP, SEXP stepsSEXP) {
+Rcpp::List qpow_col(const Eigen::Map<Eigen::SparseMatrix< double> >& M, const Eigen::Map<Eigen::VectorXd>& vec, const Rcpp::NumericVector& t);
+RcppExport SEXP _samc_qpow_col(SEXP MSEXP, SEXP vecSEXP, SEXP tSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< Eigen::Map<Eigen::SparseMatrix< double> >& >::type M(MSEXP);
+    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::SparseMatrix< double> >& >::type M(MSEXP);
     Rcpp::traits::input_parameter< const Eigen::Map<Eigen::VectorXd>& >::type vec(vecSEXP);
-    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type steps(stepsSEXP);
-    rcpp_result_gen = Rcpp::wrap(qpow_col(M, vec, steps));
+    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type t(tSEXP);
+    rcpp_result_gen = Rcpp::wrap(qpow_col(M, vec, t));
     return rcpp_result_gen;
 END_RCPP
 }
 // sum_qpowrv
-Rcpp::List sum_qpowrv(Eigen::Map<Eigen::SparseMatrix<double> >& M, const Eigen::Map<Eigen::VectorXd>& rv, Rcpp::NumericVector steps);
-RcppExport SEXP _samc_sum_qpowrv(SEXP MSEXP, SEXP rvSEXP, SEXP stepsSEXP) {
+Rcpp::List sum_qpowrv(const Eigen::Map<Eigen::SparseMatrix<double> >& M, const Eigen::Map<Eigen::VectorXd>& rv, const Rcpp::NumericVector& t);
+RcppExport SEXP _samc_sum_qpowrv(SEXP MSEXP, SEXP rvSEXP, SEXP tSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
+    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
     Rcpp::traits::input_parameter< const Eigen::Map<Eigen::VectorXd>& >::type rv(rvSEXP);
-    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type steps(stepsSEXP);
-    rcpp_result_gen = Rcpp::wrap(sum_qpowrv(M, rv, steps));
+    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type t(tSEXP);
+    rcpp_result_gen = Rcpp::wrap(sum_qpowrv(M, rv, t));
     return rcpp_result_gen;
 END_RCPP
 }
@@ -193,51 +193,51 @@ BEGIN_RCPP
 END_RCPP
 }
 // f1
-Rcpp::NumericVector f1(Eigen::Map<Eigen::SparseMatrix<double> >& M, Rcpp::XPtr<SolverCache>& SC);
+Rcpp::NumericVector f1(const Eigen::Map<Eigen::SparseMatrix<double> >& M, Rcpp::XPtr<SolverCache>& SC);
 RcppExport SEXP _samc_f1(SEXP MSEXP, SEXP SCSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
+    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
     Rcpp::traits::input_parameter< Rcpp::XPtr<SolverCache>& >::type SC(SCSEXP);
     rcpp_result_gen = Rcpp::wrap(f1(M, SC));
     return rcpp_result_gen;
 END_RCPP
 }
 // f1_iter
-Rcpp::NumericVector f1_iter(Eigen::Map<Eigen::SparseMatrix<double> >& M);
+Rcpp::NumericVector f1_iter(const Eigen::Map<Eigen::SparseMatrix<double> >& M);
 RcppExport SEXP _samc_f1_iter(SEXP MSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
+    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
     rcpp_result_gen = Rcpp::wrap(f1_iter(M));
     return rcpp_result_gen;
 END_RCPP
 }
 // sum_qpow_row
-Rcpp::List sum_qpow_row(Eigen::Map<Eigen::SparseMatrix<double> >& M, const Eigen::Map<Eigen::VectorXd>& vec, Rcpp::NumericVector steps);
-RcppExport SEXP _samc_sum_qpow_row(SEXP MSEXP, SEXP vecSEXP, SEXP stepsSEXP) {
+Rcpp::List sum_qpow_row(const Eigen::Map<Eigen::SparseMatrix<double> >& M, const Eigen::Map<Eigen::VectorXd>& vec, const Rcpp::NumericVector& t);
+RcppExport SEXP _samc_sum_qpow_row(SEXP MSEXP, SEXP vecSEXP, SEXP tSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
+    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
     Rcpp::traits::input_parameter< const Eigen::Map<Eigen::VectorXd>& >::type vec(vecSEXP);
-    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type steps(stepsSEXP);
-    rcpp_result_gen = Rcpp::wrap(sum_qpow_row(M, vec, steps));
+    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type t(tSEXP);
+    rcpp_result_gen = Rcpp::wrap(sum_qpow_row(M, vec, t));
     return rcpp_result_gen;
 END_RCPP
 }
 // sum_qpow_col
-Rcpp::List sum_qpow_col(Eigen::Map<Eigen::SparseMatrix<double> >& M, const Eigen::Map<Eigen::VectorXd>& vec, Rcpp::NumericVector steps);
-RcppExport SEXP _samc_sum_qpow_col(SEXP MSEXP, SEXP vecSEXP, SEXP stepsSEXP) {
+Rcpp::List sum_qpow_col(const Eigen::Map<Eigen::SparseMatrix<double> >& M, const Eigen::Map<Eigen::VectorXd>& vec, const Rcpp::NumericVector& t);
+RcppExport SEXP _samc_sum_qpow_col(SEXP MSEXP, SEXP vecSEXP, SEXP tSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
+    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
     Rcpp::traits::input_parameter< const Eigen::Map<Eigen::VectorXd>& >::type vec(vecSEXP);
-    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type steps(stepsSEXP);
-    rcpp_result_gen = Rcpp::wrap(sum_qpow_col(M, vec, steps));
+    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type t(tSEXP);
+    rcpp_result_gen = Rcpp::wrap(sum_qpow_col(M, vec, t));
     return rcpp_result_gen;
 END_RCPP
 }
@@ -255,37 +255,37 @@ BEGIN_RCPP
 END_RCPP
 }
 // f_row_iter
-Rcpp::NumericVector f_row_iter(Eigen::SparseMatrix<double>& M, const Eigen::VectorXd& vec);
+Rcpp::NumericVector f_row_iter(const Eigen::SparseMatrix<double>& M, const Eigen::VectorXd& vec);
 RcppExport SEXP _samc_f_row_iter(SEXP MSEXP, SEXP vecSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< Eigen::SparseMatrix<double>& >::type M(MSEXP);
+    Rcpp::traits::input_parameter< const Eigen::SparseMatrix<double>& >::type M(MSEXP);
     Rcpp::traits::input_parameter< const Eigen::VectorXd& >::type vec(vecSEXP);
     rcpp_result_gen = Rcpp::wrap(f_row_iter(M, vec));
     return rcpp_result_gen;
 END_RCPP
 }
 // f_col
-Rcpp::NumericVector f_col(Eigen::Map<Eigen::SparseMatrix<double> >& M, const Eigen::VectorXd& vec, Rcpp::XPtr<SolverCache>& SC);
+Rcpp::NumericVector f_col(const Eigen::Map<Eigen::SparseMatrix<double> >& M, const Eigen::VectorXd& vec, Rcpp::XPtr<SolverCache>& SC);
 RcppExport SEXP _samc_f_col(SEXP MSEXP, SEXP vecSEXP, SEXP SCSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
+    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
     Rcpp::traits::input_parameter< const Eigen::VectorXd& >::type vec(vecSEXP);
     Rcpp::traits::input_parameter< Rcpp::XPtr<SolverCache>& >::type SC(SCSEXP);
     rcpp_result_gen = Rcpp::wrap(f_col(M, vec, SC));
     return rcpp_result_gen;
 END_RCPP
 }
 // f_col_iter
-Rcpp::NumericVector f_col_iter(Eigen::Map<Eigen::SparseMatrix<double> >& M, const Eigen::VectorXd& vec);
+Rcpp::NumericVector f_col_iter(const Eigen::Map<Eigen::SparseMatrix<double> >& M, const Eigen::VectorXd& vec);
 RcppExport SEXP _samc_f_col_iter(SEXP MSEXP, SEXP vecSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
+    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::SparseMatrix<double> >& >::type M(MSEXP);
     Rcpp::traits::input_parameter< const Eigen::VectorXd& >::type vec(vecSEXP);
     rcpp_result_gen = Rcpp::wrap(f_col_iter(M, vec));
     return rcpp_result_gen;

---FILE: src/cond_passage.cpp---
@@ -4,31 +4,52 @@
 #include <Rcpp.h>
 #include <RcppEigen.h>
 
-
 // [[Rcpp::export("".cond_t"")]]
-Rcpp::List cond_t(Eigen::Map<Eigen::SparseMatrix<double> > &IQ, Eigen::VectorXd &qj)
+Rcpp::List cond_t(const Eigen::Map<Eigen::SparseMatrix<double> > &IQ,
+                  const Eigen::VectorXd &qj)
 {
   Eigen::SparseLU<Eigen::SparseMatrix<double> > solver;
 
   solver.compute(IQ);
+  if(solver.info() != Eigen::Success) {
+    Rcpp::stop(""Decomposition failed in cond_t"");
+  }
 
   Eigen::VectorXd b = solver.solve(qj);
+  if(solver.info() != Eigen::Success) {
+    Rcpp::stop(""Solver failed in cond_t (1)"");
+  }
+
   Eigen::VectorXd fb = solver.solve(b);
+  if(solver.info() != Eigen::Success) {
+    Rcpp::stop(""Solver failed in cond_t (2)"");
+  }
 
   Rcpp::List res = Rcpp::List::create(Rcpp::Named(""b"") = b, Rcpp::Named(""fb"") = fb);
 
   return res;
 }
 
 // [[Rcpp::export("".cond_t_iter"")]]
-Rcpp::List cond_t_iter(Eigen::Map<Eigen::SparseMatrix<double> > &IQ, Eigen::VectorXd &qj)
+Rcpp::List cond_t_iter(const Eigen::Map<Eigen::SparseMatrix<double> > &IQ,
+                       const Eigen::VectorXd &qj)
 {
   Eigen::BiCGSTAB<Eigen::SparseMatrix<double>, Eigen::IncompleteLUT<double> > solver;
 
   solver.compute(IQ);
+  if(solver.info() != Eigen::Success) {
+    Rcpp::stop(""Decomposition failed in cond_t_iter"");
+  }
 
   Eigen::VectorXd b = solver.solve(qj);
+  if(solver.info() != Eigen::Success) {
+    Rcpp::stop(""Solver failed in cond_t_iter (1)"");
+  }
+
   Eigen::VectorXd fb = solver.solve(b);
+  if(solver.info() != Eigen::Success) {
+    Rcpp::stop(""Solver failed in cond_t_iter (2)"");
+  }
 
   Rcpp::List res = Rcpp::List::create(Rcpp::Named(""b"") = b, Rcpp::Named(""fb"") = fb);
 

---FILE: src/constants.h---
@@ -0,0 +1,7 @@
+// constants.h
+#ifndef CONSTANTS_H
+#define CONSTANTS_H
+
+const int INTERRUPT_CHECK_INTERVAL = 1000;
+
+#endif

---FILE: src/dispersal.cpp---
@@ -14,13 +14,13 @@
 #include <iomanip>
 
 #include ""solver-cache.h""
-
+#include ""constants.h""
 
 // [[Rcpp::export("".sum_qn_q"")]]
 Rcpp::List sum_qn_q(const Eigen::Map<Eigen::SparseMatrix<double> > &M,
                     const Eigen::Map<Eigen::SparseMatrix<double> > &M2,
                     const Eigen::VectorXd &q,
-                    Rcpp::NumericVector t)
+                    const Rcpp::NumericVector &t)
 {
   int n = t.size();
 
@@ -29,28 +29,40 @@ Rcpp::List sum_qn_q(const Eigen::Map<Eigen::SparseMatrix<double> > &M,
   Eigen::SparseLU<Eigen::SparseMatrix<double> > solver;
 
   solver.compute(M2);
+  if(solver.info() != Eigen::Success) {
+    Rcpp::stop(""Decomposition failed in sum_qn_q"");
+  }
 
-  Rcpp::List res = Rcpp::List::create();
+  Rcpp::List res(n - 1);
 
   for(int i = 1; i < n; i++) {
-    for(int j = t[i - 1]; j < t[i]; j++) {
-      if(j % 1000 == 0) Rcpp::checkUserInterrupt();
-        q2 = M * q2;
+    int t_start = t[i - 1];
+    int t_end = t[i];
+
+    for(int j = t_start; j < t_end; j++) {
+      if(j % INTERRUPT_CHECK_INTERVAL == 0) {
+        Rcpp::checkUserInterrupt();
       }
 
+      q2 = M * q2;
+    }
+
     Eigen::VectorXd time_res = solver.solve(q - q2);
+    if(solver.info() != Eigen::Success) {
+      Rcpp::stop(""Solver failed in sum_qn_q"");
+    }
 
-    res.push_back(time_res, std::to_string((int)t[i]));
+    res[i - 1] = Rcpp::wrap(time_res);
   }
 
   return res;
 }
 
 // [[Rcpp::export("".sum_qn_q_iter"")]]
 Rcpp::List sum_qn_q_iter(const Eigen::Map<Eigen::SparseMatrix<double> > &M,
-                    const Eigen::Map<Eigen::SparseMatrix<double> > &M2,
-                    const Eigen::VectorXd &q,
-                    Rcpp::NumericVector t)
+                         const Eigen::Map<Eigen::SparseMatrix<double> > &M2,
+                         const Eigen::VectorXd &q,
+                         const Rcpp::NumericVector &t)
 {
   int n = t.size();
 
@@ -59,60 +71,72 @@ Rcpp::List sum_qn_q_iter(const Eigen::Map<Eigen::SparseMatrix<double> > &M,
   Eigen::BiCGSTAB<Eigen::SparseMatrix<double>, Eigen::IncompleteLUT<double> > solver;
 
   solver.compute(M2);
+  if(solver.info() != Eigen::Success) {
+    Rcpp::stop(""Decomposition failed in sum_qn_q_iter"");
+  }
 
-  Rcpp::List res = Rcpp::List::create();
+  Rcpp::List res(n - 1);
 
   for(int i = 1; i < n; i++) {
-    for(int j = t[i - 1]; j < t[i]; j++) {
-      if(j % 1000 == 0) Rcpp::checkUserInterrupt();
+    int t_start = t[i - 1];
+    int t_end = t[i];
+
+    for(int j = t_start; j < t_end; j++) {
+      if(j % INTERRUPT_CHECK_INTERVAL == 0) {
+        Rcpp::checkUserInterrupt();
+      }
+
       q2 = M * q2;
     }
 
     Eigen::VectorXd time_res = solver.solve(q - q2);
+    if(solver.info() != Eigen::Success) {
+      Rcpp::stop(""Solver failed in sum_qn_q_iter"");
+    }
 
-    res.push_back(time_res, std::to_string((int)t[i]));
+    res[i - 1] = Rcpp::wrap(time_res);
   }
 
   return res;
 }
 
-
 // [[Rcpp::export("".diagf_par"")]]
-Rcpp::NumericVector diagf_par(Eigen::Map<Eigen::SparseMatrix<double> > &M, const int threads)
+Rcpp::NumericVector diagf_par(const Eigen::Map<Eigen::SparseMatrix<double> > &M,
+                              const int threads)
 {
   Rcpp::Rcout << ""\nCached diagonal not found.\n"";
-
   Rcpp::Rcout << ""Performing setup. This can take several minutes..."";
 
   Eigen::SparseLU<Eigen::SparseMatrix<double> > solver;
 
-  int sz = M.rows();
+  solver.compute(M);
+  if(solver.info() != Eigen::Success) {
+    Rcpp::stop(""Decomposition failed in diagf_par"");
+  }
 
+  int sz = M.rows();
   Eigen::VectorXd dg(sz);
 
-  solver.compute(M);
-
   Rcpp::Rcout << "" Complete.\n"";
-
   Rcpp::Rcout << ""Calculating matrix inverse diagonal...\n"";
 
   // Parallel run
-  std::vector<Eigen::VectorXd> xs(threads);
-  for (auto &x : xs)
-    x = Eigen::VectorXd::Zero(sz);
-
+  std::vector<Eigen::VectorXd> xs(threads, Eigen::VectorXd::Zero(sz));
   RcppThread::ProgressCounter progress(sz, 10);
 
   auto fun = [&] (unsigned int i){
     RcppThread::checkUserInterrupt();
 
     Eigen::VectorXd& ident = xs[(i * threads) / sz];
-
     ident(i) = 1;
+
     Eigen::VectorXd col = solver.solve(ident);
+    if(solver.info() != Eigen::Success) {
+      Rcpp::stop(""Solver failed in diagf_par"");
+    }
+
     dg(i) = col(i);
     ident(i) = 0;
-
     progress++;
   };
 
@@ -125,41 +149,42 @@ Rcpp::NumericVector diagf_par(Eigen::Map<Eigen::SparseMatrix<double> > &M, const
 }
 
 // [[Rcpp::export("".diagf_par_iter"")]]
-Rcpp::NumericVector diagf_par_iter(Eigen::Map<Eigen::SparseMatrix<double> > &M, const int threads)
+Rcpp::NumericVector diagf_par_iter(const Eigen::Map<Eigen::SparseMatrix<double> > &M,
+                                   const int threads)
 {
   Rcpp::Rcout << ""\nCached diagonal not found.\n"";
-
   Rcpp::Rcout << ""Performing setup. This can take several minutes..."";
 
   Eigen::BiCGSTAB<Eigen::SparseMatrix<double>, Eigen::IncompleteLUT<double> > solver;
 
-  int sz = M.rows();
+  solver.compute(M);
+  if(solver.info() != Eigen::Success) {
+    Rcpp::stop(""Decomposition failed in diagf_par_iter"");
+  }
 
+  int sz = M.rows();
   Eigen::VectorXd dg(sz);
 
-  solver.compute(M);
-
   Rcpp::Rcout << "" Complete.\n"";
-
   Rcpp::Rcout << ""Calculating matrix inverse diagonal...\n"";
 
   // Parallel run
-  std::vector<Eigen::VectorXd> xs(threads);
-  for (auto &x : xs)
-    x = Eigen::VectorXd::Zero(sz);
-
+  std::vector<Eigen::VectorXd> xs(threads, Eigen::VectorXd::Zero(sz));
   RcppThread::ProgressCounter progress(sz, 10);
 
   auto fun = [&] (unsigned int i){
     RcppThread::checkUserInterrupt();
 
     Eigen::VectorXd& ident = xs[(i * threads) / sz];
-
     ident(i) = 1;
+
     Eigen::VectorXd col = solver.solve(ident);
+    if(solver.info() != Eigen::Success) {
+      Rcpp::stop(""Solver failed in diagf_par_iter"");
+    }
+
     dg(i) = col(i);
     ident(i) = 0;
-
     progress++;
   };
 

---FILE: src/distribution.cpp---
@@ -4,43 +4,61 @@
 #include <Rcpp.h>
 #include <RcppEigen.h>
 
+#include ""constants.h""
+
 // [[Rcpp::export("".qpow_row"")]]
-Rcpp::List qpow_row(Eigen::Map<Eigen::SparseMatrix<double> > &M, const Eigen::Map<Eigen::VectorXd> &vec, Rcpp::NumericVector steps)
+Rcpp::List qpow_row(const Eigen::Map<Eigen::SparseMatrix<double> > &M,
+                    const Eigen::Map<Eigen::VectorXd> &vec,
+                    const Rcpp::NumericVector &t)
 {
-  int n = steps.size();
+  int n = t.size();
 
-  Rcpp::List res = Rcpp::List::create();
+  Rcpp::List res(n - 1);
 
   Eigen::RowVectorXd time_res = vec;
 
   for(int i = 1; i < n; i++) {
-    for (int j = steps[i - 1]; j < steps[i]; j++) {
-      if(i % 1000 == 0) Rcpp::checkUserInterrupt();
+    int t_start = t[i - 1];
+    int t_end = t[i];
+
+    for (int j = t_start; j < t_end; j++) {
+      if(j % INTERRUPT_CHECK_INTERVAL == 0) {
+        Rcpp::checkUserInterrupt();
+      }
+
       time_res = time_res * M;
     }
 
-    res.push_back(time_res, std::to_string((int)steps[i]));
+    res[i - 1] = Rcpp::wrap(time_res);
   }
 
   return res;
 }
 
 // [[Rcpp::export("".qpow_col"")]]
-Rcpp::List qpow_col(Eigen::Map<Eigen::SparseMatrix< double> > &M, const Eigen::Map<Eigen::VectorXd> &vec, Rcpp::NumericVector steps)
+Rcpp::List qpow_col(const Eigen::Map<Eigen::SparseMatrix< double> > &M,
+                    const Eigen::Map<Eigen::VectorXd> &vec,
+                    const Rcpp::NumericVector &t)
 {
-  int n = steps.size();
+  int n = t.size();
 
-  Rcpp::List res = Rcpp::List::create();
+  Rcpp::List res(n - 1);
 
   Eigen::VectorXd time_res = M * vec;
 
   for(int i = 1; i < n; i++) {
-    for (int j = steps[i - 1]; j < steps[i]; j++) {
-      if(i % 1000 == 0) Rcpp::checkUserInterrupt();
+    int t_start = t[i - 1];
+    int t_end = t[i];
+
+    for (int j = t_start; j < t_end; j++) {
+      if(j % INTERRUPT_CHECK_INTERVAL == 0) {
+        Rcpp::checkUserInterrupt();
+      }
+
       time_res = M * time_res;
     }
 
-    res.push_back(time_res, std::to_string((int)steps[i]));
+    res[i - 1] = Rcpp::wrap(time_res);
   }
 
   return res;

---FILE: src/mortality.cpp---
@@ -5,26 +5,34 @@
 #include <RcppEigen.h>
 
 #include ""solver-cache.h""
-
+#include ""constants.h""
 
 // [[Rcpp::export("".sum_qpowrv"")]]
-Rcpp::List sum_qpowrv(Eigen::Map<Eigen::SparseMatrix<double> > &M, const Eigen::Map<Eigen::VectorXd> &rv, Rcpp::NumericVector steps)
+Rcpp::List sum_qpowrv(const Eigen::Map<Eigen::SparseMatrix<double> > &M,
+                      const Eigen::Map<Eigen::VectorXd> &rv,
+                      const Rcpp::NumericVector &t)
 {
-  int n = steps.size();
+  int n = t.size();
 
-  Rcpp::List res = Rcpp::List::create();
+  Rcpp::List res(n - 1);
 
   Eigen::VectorXd qrv = rv;
   Eigen::VectorXd time_res = qrv;
 
   for(int i = 1; i < n; i++) {
-    for (int j = steps[i - 1]; j < steps[i]; j++) {
-      if(i % 1000 == 0) Rcpp::checkUserInterrupt();
+    int t_start = t[i - 1];
+    int t_end = t[i];
+
+    for (int j = t_start; j < t_end; j++) {
+      if(j % INTERRUPT_CHECK_INTERVAL == 0) {
+        Rcpp::checkUserInterrupt();
+      }
+
       qrv = M * qrv;
-      time_res = time_res + qrv;
+      time_res += qrv;
     }
 
-    res.push_back(time_res, std::to_string((int)steps[i]));
+    res[i - 1] = Rcpp::wrap(time_res);
   }
 
   return res;

---FILE: src/solver-cache.cpp---
@@ -14,11 +14,15 @@ Rcpp::XPtr<SolverCache> solver_cache()
   return ptr;
 }
 
-void SolverCache::buildSolver(const Eigen::SparseMatrix<double> &M, const std::string &fun)
+void SolverCache::buildSolver(const Eigen::SparseMatrix<double> &M,
+                              const std::string &fun)
 {
-  if (name != fun)
-  {
+  if (name != fun) {
     m_solver.compute(M);
+    if (m_solver.info() != Eigen::Success) {
+      Rcpp::stop(""Solver failed in buildSolver"");
+    }
+
     name = fun;
   }
 }

---FILE: src/solver-cache.h---
@@ -8,17 +8,15 @@
 #include <RcppEigen.h>
 #include <string>
 
-using namespace Eigen;
-
 class SolverCache {
-  typedef SparseLU<SparseMatrix<double> > Solver;
+  typedef Eigen::SparseLU<Eigen::SparseMatrix<double> > Solver;
 
   Solver m_solver;
   std::string name;
 
 public:
-  SolverCache() { name = """"; }
-  void buildSolver(const Eigen::SparseMatrix<double> &M, const std::string& fun);
+  SolverCache() : name("""") { }
+  void buildSolver(const Eigen::SparseMatrix<double> &M, const std::string &fun);
   Solver& solver() { return m_solver; }
 };
 

---FILE: src/survival.cpp---
@@ -6,31 +6,40 @@
 
 #include ""solver-cache.h""
 
-
 // [[Rcpp::export("".f1"")]]
-Rcpp::NumericVector f1(Eigen::Map<Eigen::SparseMatrix<double> > &M, Rcpp::XPtr<SolverCache> &SC)
+Rcpp::NumericVector f1(const Eigen::Map<Eigen::SparseMatrix<double> > &M,
+                       Rcpp::XPtr<SolverCache> &SC)
 {
   Eigen::VectorXd one(M.rows());
   one.fill(1.0);
 
   SC->buildSolver(M, ""m"");
 
   Eigen::VectorXd res = SC->solver().solve(one);
+  if(SC->solver().info() != Eigen::Success) {
+    Rcpp::stop(""Solver failed in f1"");
+  }
 
   return Rcpp::wrap(res);
 }
 
 // [[Rcpp::export("".f1_iter"")]]
-Rcpp::NumericVector f1_iter(Eigen::Map<Eigen::SparseMatrix<double> > &M)
+Rcpp::NumericVector f1_iter(const Eigen::Map<Eigen::SparseMatrix<double> > &M)
 {
   Eigen::VectorXd one(M.rows());
   one.fill(1.0);
 
   Eigen::BiCGSTAB<Eigen::SparseMatrix<double>, Eigen::IncompleteLUT<double> > solver;
 
   solver.compute(M);
+  if(solver.info() != Eigen::Success) {
+    Rcpp::stop(""Decomposition failed in f1_iter"");
+  }
 
   Eigen::VectorXd res = solver.solve(one);
+  if(solver.info() != Eigen::Success) {
+    Rcpp::stop(""Solver failed in f1_iter"");
+  }
 
   return Rcpp::wrap(res);
 }

---FILE: src/visitation.cpp---
@@ -7,118 +7,138 @@
 #include <Rcpp/Benchmark/Timer.h>
 
 #include ""solver-cache.h""
+#include ""constants.h""
 
 // [[Rcpp::export("".sum_qpow_row"")]]
-Rcpp::List sum_qpow_row(Eigen::Map<Eigen::SparseMatrix<double> > &M, const Eigen::Map<Eigen::VectorXd> &vec, Rcpp::NumericVector steps)
+Rcpp::List sum_qpow_row(const Eigen::Map<Eigen::SparseMatrix<double> > &M,
+                        const Eigen::Map<Eigen::VectorXd> &vec,
+                        const Rcpp::NumericVector &t)
 {
-  int n = steps.size();
+  int n = t.size();
 
-  Rcpp::List res = Rcpp::List::create();
+  Rcpp::List res(n - 1);
 
   Eigen::RowVectorXd vecq = vec;
   Eigen::RowVectorXd time_res = vec;
 
   for(int i = 1; i < n; i++) {
-    for (int j = steps[i - 1]; j < steps[i]; j++) {
-      if(i % 1000 == 0) Rcpp::checkUserInterrupt();
+    int t_start = t[i - 1];
+    int t_end = t[i];
+
+    for (int j = t_start; j < t_end; j++) {
+      if(j % INTERRUPT_CHECK_INTERVAL == 0) {
+        Rcpp::checkUserInterrupt();
+      }
+
       vecq = vecq * M;
-      time_res = time_res + vecq;
+      time_res += vecq;
     }
 
-    res.push_back(time_res, std::to_string((int)steps[i]));
+    res[i - 1] = Rcpp::wrap(time_res);
   }
 
   return res;
 }
 
 // [[Rcpp::export("".sum_qpow_col"")]]
-Rcpp::List sum_qpow_col(Eigen::Map<Eigen::SparseMatrix<double> > &M, const Eigen::Map<Eigen::VectorXd> &vec, Rcpp::NumericVector steps)
+Rcpp::List sum_qpow_col(const Eigen::Map<Eigen::SparseMatrix<double> > &M,
+                        const Eigen::Map<Eigen::VectorXd> &vec,
+                        const Rcpp::NumericVector &t)
 {
-  int n = steps.size();
+  int n = t.size();
 
-  Rcpp::List res = Rcpp::List::create();
+  Rcpp::List res(n - 1);
 
   Eigen::VectorXd qc = vec;
   Eigen::VectorXd time_res = vec;
 
   for(int i = 1; i < n; i++) {
-    for (int j = steps[i - 1]; j < steps[i]; j++) {
-      if(i % 1000 == 0) Rcpp::checkUserInterrupt();
+    int t_start = t[i - 1];
+    int t_end = t[i];
+
+    for (int j = t_start; j < t_end; j++) {
+      if(j % INTERRUPT_CHECK_INTERVAL == 0) {
+        Rcpp::checkUserInterrupt();
+      }
+
       qc = M * qc;
-      time_res = time_res + qc;
+      time_res += qc;
     }
 
-    res.push_back(time_res, std::to_string((int)steps[i]));
+    res[i - 1] = Rcpp::wrap(time_res);
   }
 
   return res;
 }
 
-
 // [[Rcpp::export("".f_row"")]]
-Rcpp::NumericVector f_row(const Eigen::SparseMatrix<double> &M, const Eigen::VectorXd &vec, Rcpp::XPtr<SolverCache> &SC)
+Rcpp::NumericVector f_row(const Eigen::SparseMatrix<double> &M,
+                          const Eigen::VectorXd &vec,
+                          Rcpp::XPtr<SolverCache> &SC)
 {
   SC->buildSolver(M.transpose(), ""mt"");
 
   Eigen::VectorXd res = SC->solver().solve(vec);
+  if(SC->solver().info() != Eigen::Success) {
+    Rcpp::stop(""Solver failed in f_row"");
+  }
 
   return Rcpp::wrap(res);
 }
 
 // [[Rcpp::export("".f_row_iter"")]]
-Rcpp::NumericVector f_row_iter(Eigen::SparseMatrix<double> &M, const Eigen::VectorXd &vec)
+Rcpp::NumericVector f_row_iter(const Eigen::SparseMatrix<double> &M,
+                               const Eigen::VectorXd &vec)
 {
   Eigen::BiCGSTAB<Eigen::SparseMatrix<double>, Eigen::IncompleteLUT<double> > solver;
 
   solver.compute(M.transpose());
+  if(solver.info() != Eigen::Success) {
+    Rcpp::stop(""Decomposition failed in f_row_iter"");
+  }
 
   Eigen::VectorXd res = solver.solve(vec);
+  if(solver.info() != Eigen::Success) {
+    Rcpp::stop(""Solver failed in f_row_iter"");
+  }
 
   return Rcpp::wrap(res);
 }
 
 // [[Rcpp::export("".f_col"")]]
-Rcpp::NumericVector f_col(Eigen::Map<Eigen::SparseMatrix<double> > &M, const Eigen::VectorXd &vec, Rcpp::XPtr<SolverCache> &SC)
+Rcpp::NumericVector f_col(const Eigen::Map<Eigen::SparseMatrix<double> > &M,
+                          const Eigen::VectorXd &vec,
+                          Rcpp::XPtr<SolverCache> &SC)
 {
   int sz = M.rows();
 
-  //Rcpp::Timer timer;
-
-  //timer.step(""compute() start"");
   SC->buildSolver(M, ""m"");
-  //timer.step(""compute() end"");
 
-  //timer.step(""solve() start"");
   Eigen::VectorXd res = SC->solver().solve(vec);
-  //timer.step(""solve() end"");
-
-  //Rcpp::NumericVector tr(timer);
-  //Rcpp::Rcout << tr;
+  if(SC->solver().info() != Eigen::Success) {
+    Rcpp::stop(""Solver failed in f_col"");
+  }
 
   return Rcpp::wrap(res);
 }
 
 // [[Rcpp::export("".f_col_iter"")]]
-Rcpp::NumericVector f_col_iter(Eigen::Map<Eigen::SparseMatrix<double> > &M, const Eigen::VectorXd &vec)
+Rcpp::NumericVector f_col_iter(const Eigen::Map<Eigen::SparseMatrix<double> > &M,
+                               const Eigen::VectorXd &vec)
 {
   int sz = M.rows();
 
   Eigen::BiCGSTAB<Eigen::SparseMatrix<double>, Eigen::IncompleteLUT<double> > solver;
 
-  //Rcpp::Timer timer;
-
-  //timer.step(""compute() start"");
   solver.compute(M);
-  //timer.step(""compute() end"");
+  if(solver.info() != Eigen::Success) {
+    Rcpp::stop(""Decomposition failed in f_col_iter"");
+  }
 
-  //timer.step(""solve() start"");
   Eigen::VectorXd res = solver.solve(vec);
-  //timer.step(""solve() end"");
-
-  //Rcpp::NumericVector tr(timer);
-  //Rcpp::Rcout << tr;
+  if(solver.info() != Eigen::Success) {
+    Rcpp::stop(""Solver failed in f_col_iter"");
+  }
 
   return Rcpp::wrap(res);
 }
-
-"
andrewmarx,samc,604e375561b56d7487bd6a483ba405aeed5527d7,Andrew Marx,andrewjmarx@gmail.com,2024-07-04T21:56:56Z,Andrew Marx,andrewjmarx@gmail.com,2024-07-04T21:56:56Z,Fix check() error message,R/check.R,False,True,True,False,1,1,2,"---FILE: R/check.R---
@@ -119,7 +119,7 @@ setMethod(
       data = terra::values(a, row = r, nrows = 1)
 
       if (any(is.infinite(data))) stop(""Data contains Inf or -Inf"", call. = FALSE)
-      if (any(is.nan(data))) stop(""Data contains Inf or -Inf"", call. = FALSE)
+      if (any(is.nan(data))) stop(""Data contains NaN"", call. = FALSE)
 
       data = rowSums(is.finite(data))
       if (any(data > 0 & data < n)) stop(""NA mismatch in input data"", call. = FALSE)"
andrewmarx,samc,9eaac9bf357dba6a71e3a6b2068cb6b804e6657f,Andrew Marx,andrewjmarx@gmail.com,2024-07-04T21:55:48Z,Andrew Marx,andrewjmarx@gmail.com,2024-07-04T21:55:48Z,Fix named origin input,R/internal-functions.R,False,True,True,False,11,3,14,"---FILE: R/internal-functions.R---
@@ -749,9 +749,17 @@ setMethod(
 #' @param x A list
 #' @noRd
 .map_location <- function(samc, x) {
-  df = data.frame(cell = terra::cells(samc@map),
-                  vec = numeric(samc@nodes))
-  df$vec[x] = 1
+  if (samc@source == ""transition"") {
+    vec = numeric(samc@nodes)
+    vec[x] = 1
+    names(vec) = samc@names
+
+    return(vec)
+  } else {
+    df = data.frame(cell = terra::cells(samc@map),
+                    vec = numeric(samc@nodes))
+    df$vec[x] = 1
+  }
 
   return(.build_map(samc, df))
 }"
andrewmarx,samc,206fbed9823e7966f18c57eecd24f3cb53ec496a,Andrew Marx,andrewjmarx@gmail.com,2024-02-20T13:27:41Z,Andrew Marx,andrewjmarx@gmail.com,2024-02-20T13:27:41Z,"Add cond_passage(samc, init, dest)

Old work; may need to follow up and fix",R/cond_passage.R,False,True,True,False,28,0,28,"---FILE: R/cond_passage.R---
@@ -155,3 +155,31 @@ setMethod(
 
     return(result)
   })
+
+# cond_passage(samc, init, dest) ----
+#' @rdname cond_passage
+setMethod(
+  ""cond_passage"",
+  signature(samc = ""samc"", init = ""ANY"", origin = ""missing"", dest = ""location""),
+  function(samc, init, dest) {
+    .disable_conv(samc)
+
+    if(length(origin) != length(dest))
+      stop(""The 'origin' and 'dest' parameters must have the same number of values"", call. = FALSE)
+
+    origin <- .process_locations(samc, origin)
+    dest <- .process_locations(samc, dest)
+
+    result <- vector(mode = ""numeric"", length = length(origin))
+
+    unique_dest <- unique(dest)
+
+    for (d in unique_dest) {
+      t <- cond_passage(samc, dest = d)
+      #      adj_origin <- origin
+      #      adj_origin[origin > d] <- adj_origin[origin > d] - 1
+      result[dest == d] <- t[origin[dest == d]]
+    }
+
+    return(result)
+  })"
andrewmarx,samc,391d99f9d109dc6502a4e718e062ba8e5abcba18,Andrew Marx,andrewjmarx@gmail.com,2023-10-10T00:00:26Z,Andrew Marx,andrewjmarx@gmail.com,2023-10-10T00:00:26Z,Fix CRW for NA in maps,R/internal-functions.R,False,True,True,False,1,1,2,"---FILE: R/internal-functions.R---
@@ -887,7 +887,7 @@ setMethod(
 
 
     if (samc@model$name == ""CRW"") {
-      x = sweep(samc@prob_mat, 2, x, ""*"")
+      x = sweep(samc@prob_mat[, terra::cells(samc@map)], 2, x, ""*"")
       dim(x) = NULL
       x = x[!is.na(x)]
     }"
andrewmarx,samc,fc9d0fdc60192d4febd6ba5599beb04c619a2f7b,Andrew Marx,andrewjmarx@gmail.com,2023-09-28T01:16:33Z,Andrew Marx,andrewjmarx@gmail.com,2023-09-28T01:16:33Z,Fix survival() for CRW,R/survival.R,False,True,True,False,6,27,33,"---FILE: R/survival.R---
@@ -60,11 +60,12 @@ setMethod(
       z = .f1(samc@data@f, samc@.cache$sc)
     }
 
-    z = as.vector(z)
-
     if (samc@model$name == ""CRW"") {
-      z = .summarize_crw(samc, z, sum) # TODO figure out why this produces slightly incorrect results
-      warning(""survival() CRW results can be incorrect by up to 0.5%"") # TODO fix issue and remove warning
+      vec = as.vector(samc@prob_mat)
+      vec = vec[!is.na(vec)]
+
+      z = vec * z
+      z = .summarize_crw(samc, z, sum)
     }
 
     return(z)
@@ -95,27 +96,5 @@ setMethod(
   ""survival"",
   signature(samc = ""samc"", init = ""ANY"", origin = ""missing""),
   function(samc, init) {
-    if (samc@solver %in% c(""direct"", ""iter"")) {
-      check(samc, init)
-
-      pv <- .process_init(samc, init)
-
-      sv <- survival(samc)
-
-      if (samc@model$name == ""CRW"") {
-        pv = .summarize_crw(samc, pv, sum)
-        warning(""survival() CRW results can be incorrect by up to 0.5%"") # TODO fix issue and remove warning
-      }
-
-      surv <- pv %*% sv
-
-      return(as.numeric(surv))
-    } else if (samc@solver == ""conv"") {
-
-      res = visitation(samc, init)
-
-      return(sum(res))
-    } else {
-      stop(""Invalid method attribute in samc object."")
-    }
+    sum(visitation(samc, init))
   })"
andrewmarx,samc,09e410a681e73907a18f4ed7322889b86ba4a62f,Andrew Marx,andrewjmarx@gmail.com,2023-09-14T01:44:06Z,Andrew Marx,andrewjmarx@gmail.com,2023-09-14T01:44:06Z,"SSF Fix

Remove restriction on negative ssc vals

Fix equation for SSF (can't remember why I had the -1 in there)",R/internal-functions.R;R/utils-models.R,False,True,True,False,4,7,11,"---FILE: R/internal-functions.R---
@@ -393,7 +393,7 @@
   result = numeric(nrows * ncols * dir)
   index = 0
 
-  dist = .build_lookup_mat(data, dir)^(ssc - 1)
+  dist = .build_lookup_mat(data, dir)^(ssc)
 
   if (dir == 4) {
     dir = c(2, 4, 6, 8)

---FILE: R/utils-models.R---
@@ -149,16 +149,13 @@
     stop(paste(""Unknown argument in model:"", unknown_args), call. = FALSE)
 
   if (!is(x$ssc, ""numeric""))
-    stop(""ssc must be single positive numeric value."", call. = FALSE)
+    stop(""ssc must be single numeric value."", call. = FALSE)
 
   if (length(x$ssc) != 1)
-    stop(""ssc must be single positive numeric value."", call. = FALSE)
+    stop(""ssc must be single numeric value."", call. = FALSE)
 
   if (!is.finite(x$ssc))
-    stop(""ssc must be single positive numeric value."", call. = FALSE)
-
-  if (x$ssc <= 0)
-    stop(""ssc must be single positive numeric value."", call. = FALSE)
+    stop(""ssc must be single numeric value."", call. = FALSE)
 }
 
 "
andrewmarx,samc,cfd9d70b557c0eb246813440d8f08dd47ab8e2af,Andrew Marx,andrewjmarx@gmail.com,2023-08-31T14:56:35Z,Andrew Marx,andrewjmarx@gmail.com,2023-08-31T14:56:35Z,Fix location check for CRW,R/internal-functions.R,False,True,True,False,1,2,3,"---FILE: R/internal-functions.R---
@@ -657,8 +657,7 @@
   if (any(x < 1))
     stop(""All location values must be positive (greater than 0)"", call. = FALSE)
 
-  # TODO this only works correctly for RW. In CRW, nrow does not correspond to number of locations
-  if (any(x > nrow(samc$q_matrix)))
+  if (any(x > samc@nodes))
     stop(""Location values cannot exceed the number of nodes in the landscape"", call. = FALSE)
 }
 "
andrewmarx,samc,9c7551c32f4e57913e4ab1719d0ed0741d7a84e7,Andrew Marx,andrewjmarx@gmail.com,2023-08-28T19:31:17Z,Andrew Marx,andrewjmarx@gmail.com,2023-08-28T19:31:17Z,Small bug fix,R/samc.R,False,True,True,False,1,1,2,"---FILE: R/samc.R---
@@ -401,7 +401,7 @@ setMethod(
                              model = list(name = ""RW""),
                              crw_map = NULL,
                              source = ""transition"",
-                             nodes = r - 1,
+                             nodes = as.integer(r - 1),
                              map = terra::rast(),
                              names = nm,
                              clumps = -1,"
andrewmarx,samc,d1ed654fb6de1fb398ae6c845fd7e7cfeae9721f,Andrew Marx,andrewjmarx@gmail.com,2023-08-02T17:03:10Z,Andrew Marx,andrewjmarx@gmail.com,2023-08-02T17:03:10Z,Minor map() fixes,R/map.R,False,True,True,False,2,2,4,"---FILE: R/map.R---
@@ -50,7 +50,7 @@ setMethod(
         stop(""The length of the vector does not match the number of non-NA cells in the landscape data"", call. = FALSE)
 
       df = data.frame(samc@crw_map, vec)
-      df = reshape(df, idvar = ""X1"", timevar = ""X2"", direction = ""wide"")
+      df = stats::reshape(df, idvar = ""X1"", timevar = ""X2"", direction = ""wide"")
     } else {
       if (length(vec) != length(terra::cells(samc@map)))
         stop(""The length of the vector does not match the number of non-NA cells in the landscape data"", call. = FALSE)
@@ -68,7 +68,7 @@ setMethod(
       return(ras)
     })
 
-    ras = rast(ras_list)
+    ras = terra::rast(ras_list)
 
     if (samc@source == ""SpatRaster"") {
       return(ras)"
andrewmarx,samc,65162f46a888b53f1435ad7fb5eb980208f6c3a7,Andrew Marx,andrewjmarx@gmail.com,2023-08-01T15:56:38Z,Andrew Marx,andrewjmarx@gmail.com,2023-08-01T15:56:38Z,Fix cond_passage() optimization,R/cond_passage.R,False,True,True,False,8,8,16,"---FILE: R/cond_passage.R---
@@ -88,22 +88,22 @@ setMethod(
 
     dest <- .process_locations(samc, dest)
 
-    Q <- samc$q_matrix
+    Q = samc$q_matrix
 
-    qj <- Q[, dest]
-    qj[dest] = 0
+    qj = Q[, dest]
+    qj[dest] = 1
 
-    Q@x <- -Q@x
-    Matrix::diag(Q) <- Matrix::diag(Q) + 1
     Q[dest, ] = 0
     Q[, dest] = 0
-    Q[dest, dest] = 1
+    Q[dest, dest] = 0
 
+    Q@x <- -Q@x
+    Matrix::diag(Q) <- Matrix::diag(Q) + 1
 
     if (samc@solver == ""iter"") {
-      t <- as.numeric(.cond_t_iter(Qj, qj))
+      t <- as.numeric(.cond_t_iter(Q, qj))
     } else {
-      t <- as.numeric(.cond_t(Qj, qj))
+      t <- as.numeric(.cond_t(Q, qj))
     }
     names(t) <- samc$names
 "
andrewmarx,samc,cd8123aae7cc9f5a726a780082be5cb25c1a2253,Andrew Marx,andrewjmarx@gmail.com,2023-05-08T21:44:37Z,Andrew Marx,andrewjmarx@gmail.com,2023-05-08T21:44:37Z,check() bugfix,R/check.R,False,True,True,False,1,1,2,"---FILE: R/check.R---
@@ -207,7 +207,7 @@ setMethod(
   function(a, b){
     if (a@source != ""transition"") stop(""Numeric vector input only valid for samc objects created from P matrix"", call. = FALSE)
 
-    if (names(b) != a@names) stop(""Names of the vector must match the names of the transient states in the P matrix"", call. = FALSE)
+    if (!isTRUE(all.equal(names(b), a@names))) stop(""Names of the vector must match the names of the transient states in the P matrix"", call. = FALSE)
 
     if (any(!is.finite(b)) || any(b < 0)) stop(""Input must only contain positive numeric values"", call. = FALSE)
 "
andrewmarx,samc,8f7fc54ef45803a0ac478289f6929da55e180567,Andrew Marx,andrewjmarx@gmail.com,2023-05-08T21:00:30Z,Andrew Marx,andrewjmarx@gmail.com,2023-05-08T21:00:30Z,Efficiency fix for obscure situation,R/check.R,False,True,True,False,1,1,2,"---FILE: R/check.R---
@@ -211,5 +211,5 @@ setMethod(
 
     if (any(!is.finite(b)) || any(b < 0)) stop(""Input must only contain positive numeric values"", call. = FALSE)
 
-    if (length(b) != nrow(a$q_matrix)) stop(""Input length does not match number of transient states"", call. = FALSE)
+    if (length(b) != length(a@data@t_abs)) stop(""Input length does not match number of transient states"", call. = FALSE)
   })"
andrewmarx,samc,bb031a0cdd1f8a95970ed6e21f862bf47b17fc8e,Andrew Marx,andrewjmarx@gmail.com,2023-04-07T11:41:41Z,Andrew Marx,andrewjmarx@gmail.com,2023-04-07T11:41:41Z,cpp warning fix for CHECK,src/convolution.cpp,False,False,False,False,1,1,2,"---FILE: src/convolution.cpp---
@@ -286,7 +286,7 @@ Rcpp::List convolution_long(
       pop = Rcpp::sum(pops);
     }
     Rcpp::checkUserInterrupt();
-  } while(pop > EPSILON & count < count_limit);
+  } while((pop > EPSILON) & (count < count_limit));
 
   if (count == count_limit) {
     Rcpp::Rcout << ""\nConvolution iteration limit reached. Results may not have fully converged.\n"";"
andrewmarx,samc,18cfb7179c68e5e264ad7a2f78a8a94ff1196612,Andrew Marx,andrewjmarx@gmail.com,2023-04-06T22:29:58Z,Andrew Marx,andrewjmarx@gmail.com,2023-04-06T22:29:58Z,Fixes for CHECK,NAMESPACE;R/internal-functions.R,False,True,True,False,2,1,3,"---FILE: NAMESPACE---
@@ -6,4 +6,5 @@ importClassesFrom(""terra"", ""SpatRaster"")
 importFrom(""methods"", ""as"")
 importFrom(""methods"", ""new"")
 importFrom(""methods"", ""is"")
+importFrom(""stats"", ""aggregate"")
 exportPattern(""^[[:alpha:]]+"")

---FILE: R/internal-functions.R---
@@ -557,7 +557,7 @@
   dim(abso) = c(nc, nr)
   dim(fid) = c(nc, nr)
 
-  samc:::.build_convolution_cache(kernel, res, fid, abso, sym, threads)
+  .build_convolution_cache(kernel, res, fid, abso, sym, threads)
 }
 
 "
andrewmarx,samc,f2a7666e3ef90d67444a803886eb5a04b68cd788,Andrew Marx,andrewjmarx@gmail.com,2023-04-06T21:35:54Z,Andrew Marx,andrewjmarx@gmail.com,2023-04-06T21:35:54Z,bug fix,R/samc.R,False,True,True,False,1,1,2,"---FILE: R/samc.R---
@@ -424,5 +424,5 @@ setMethod(
   function(data, options = NULL) {
     p <- methods::as(methods::as(data, ""CsparseMatrix""), ""generalMatrix"")
 
-    return(samc(data = p), options = options)
+    return(samc(data = p, options = options))
   })"
andrewmarx,samc,037ef6dcaea2d750d86bb5e55ed5df79b927d3e7,Andrew Marx,andrewjmarx@gmail.com,2023-04-03T20:53:33Z,Andrew Marx,andrewjmarx@gmail.com,2023-04-03T20:53:33Z,crw_map fix,R/internal-functions.R,False,True,True,False,4,2,6,"---FILE: R/internal-functions.R---
@@ -249,6 +249,7 @@
 
 
   cell = 0
+  crw_index = 0
   index = 0
 
   # Loop through cells with values
@@ -259,6 +260,7 @@
       cell = cell + 1
       if (is.finite(vals[c])) {
         p1 = (cell - 1) * dir
+        index = index + 1
 
         # loop through valid edges
         for (d in 1:dir) {
@@ -267,8 +269,8 @@
             p2 = p1 + offsets[d]
             e1_num = edge_nums[e1]
 
-            index = index + 1
-            crw_map[index, ] = c(cell, d)
+            crw_index = crw_index + 1
+            crw_map[crw_index, ] = c(index, d)
 
             rs = 0
             fid_index = NA"
andrewmarx,samc,d5e19a54c1eceaa29997ad55064715c7713a2fb0,Andrew Marx,andrewjmarx@gmail.com,2023-04-02T23:23:11Z,Andrew Marx,andrewjmarx@gmail.com,2023-04-02T23:23:11Z,Fix new .rw() and .crw() implementations,R/internal-functions.R,False,True,True,False,36,28,64,"---FILE: R/internal-functions.R---
@@ -11,33 +11,35 @@
 #'
 #' @noRd
 .rw <- function(x, absorption, fidelity, fun, dir, sym) {
-  if (model$fun == ""res"") {
+  if (is(fun, ""function"")) {
+    tr = .tr_vals(x, fun, dir)
+  } else if (fun == ""res"") {
     tr = .tr_vals_res(x, dir)
   } else {
-    tr = .tr_vals(x, fun, dir)
+    stop(""Invalid transition function defined"", call. = FALSE)
   }
+
   nedges = sum(is.finite(tr))
-  edge_nums = tr
-  edge_nums[is.finite(edge_nums)] = 1:nedges
 
   nrows = terra::nrow(x)
   ncols = terra::ncol(x)
   cell_nums = terra::cells(x)
   ncells = length(cell_nums)
 
-  lonlat = terra::is.lonlat(x)
+  cell_lookup = matrix(0, ncols, nrows) # Intentionally reversed for rast->mat
+  cell_lookup[cell_nums] = 1:length(cell_nums)
 
   # tr offset vars
   if (dir == 4) {
     dir_vec = c(1:2, 0, 3:4)
-    offsets = c(-ncols, -1, 1, ncols) * 4
+    offsets = c(-ncols, -1, 1, ncols)
   } else if (dir == 8) {
     dir_vec = c(1:4, 0, 5:8)
-    offsets = c(-ncols - 1, -ncols, -ncols + 1, -1, 1, ncols - 1, ncols, ncols + 1) * 8
+    offsets = c(-ncols - 1, -ncols, -ncols + 1, -1, 1, ncols - 1, ncols, ncols + 1)
   }
 
   # Fill out mat_p
-  mat_p = integer(nedges + 1)
+  mat_p = integer(ncells + 1)
   mat_p[] = 1 # every column will have a fidelity value
   mat_p[1] = 0 # except first entry of mat_p does not refer to a column
   cell = 0
@@ -47,17 +49,19 @@
     for (c in 1:ncols) {
       cell = cell + 1
       if (is.finite(vals[c])) {
-        p1 = (cell - 1) * dir
-
+        p1 = cell_lookup[cell]
+        p1i = (cell - 1) * dir
 
         # loop through valid edges
-        for (d in 1:dir) {
-          e1 = p1 + d
+        for (d in dir_vec) {
+          if (d) {
+            p2i = p1i + d
 
-          if (!is.na(tr[e1])) {
-            p2 = p1 + offsets[d]
+            if (!is.na(tr[p2i])) {
+              p2 = cell_lookup[cell + offsets[d]]
 
-            mat_p[p2 + 1] = mat_p[p2 + 1] + 1
+              mat_p[p2 + 1] = mat_p[p2 + 1] + 1
+            }
           }
         }
       }
@@ -68,13 +72,14 @@
     mat_p[i] = mat_p[i] + mat_p[i - 1]
   }
 
-  mat_p_count = integer(nedges)
+  mat_p_count = integer(ncells + 1)
 
   mat_x = numeric(nedges + ncells)
   mat_i = integer(nedges + ncells)
 
   cell = 0
 
+  row_indices = numeric(dir)
 
   for (r in 1:nrows) {
     fid = terra::values(fidelity, mat = FALSE, row = r, nrows = 1)
@@ -83,28 +88,28 @@
     for (c in 1:ncols) {
       cell = cell + 1
       if (is.finite(vals[c])) {
-        p1 = (cell - 1) * dir
+        p1 = cell_lookup[cell]
+        p1i = (cell - 1) * dir
 
         # loop through valid edges
         rs = 0
         fid_index = NA
 
-        row_indices = numeric(dir)
         row_indices[] = NA
 
-        for (dv in dir_vec) {
-          if (dv) {
-            e1 = p1 + dv
+        for (d in dir_vec) {
+          if (d) {
+            p2i = p1i + d
 
-            if (!is.na(tr[e1])) {
-              p2 = p1 + offsets[d]
+            if (!is.na(tr[p2i])) {
+              p2 = cell_lookup[cell + offsets[d]]
 
               mat_p_count[p2] = mat_p_count[p2] + 1
 
-              res = tr[p2]
+              res = tr[p2i]
               rs = rs + res
 
-              row_indices[dv] = mat_p[p2] + mat_p_count[p2]
+              row_indices[d] = mat_p[p2] + mat_p_count[p2]
               mat_x[mat_p[p2] + mat_p_count[p2]] = -res * vals[c]
               mat_i[mat_p[p2] + mat_p_count[p2]] = p1
             }
@@ -125,7 +130,7 @@
   mat_i = mat_i - 1
 
   mat = new(""dgCMatrix"")
-  mat@Dim = c(as.integer(sum(edge_counts)), as.integer(sum(edge_counts)))
+  mat@Dim = c(as.integer(ncells), as.integer(ncells))
 
   mat@p = as.integer(mat_p)
   mat@i = as.integer(mat_i)
@@ -140,11 +145,14 @@
 #'
 #' @noRd
 .crw <- function(x, absorption, fidelity, fun, dir, sym = TRUE, model) {
-  if (model$fun == ""res"") {
+  if (is(fun, ""function"")) {
+    tr = .tr_vals(x, fun, dir)
+  } else if (fun == ""res"") {
     tr = .tr_vals_res(x, dir)
   } else {
-    tr = .tr_vals(x, fun, dir)
+    stop(""Invalid transition function defined"", call. = FALSE)
   }
+
   edge_counts = sum(is.finite(tr))
   edge_nums = tr
   edge_nums[is.finite(edge_nums)] = 1:edge_counts"
andrewmarx,samc,1deb57e1568ed2c8174f7a5ccb99513615358cfc,Andrew Marx,andrewjmarx@gmail.com,2023-03-30T18:33:26Z,Andrew Marx,andrewjmarx@gmail.com,2023-03-30T18:33:26Z,Fix small conv long-term bug,src/convolution.cpp,False,False,False,False,0,2,2,"---FILE: src/convolution.cpp---
@@ -201,7 +201,6 @@ Rcpp::List convolution_short(
   std::vector<double> vis(ca->nrow*(ca->ncol+ca->left_extra_cols+ca->right_extra_cols), 0.0);
 
   std::memcpy(&pop_a[ca->nrow*ca->left_extra_cols], &pop_in[0], ca->nrow*ca->ncol*sizeof(double));
-  //std::memcpy(&vis[ca->nrow*ca->left_extra_cols], &pop_in[0], ca->nrow*ca->ncol*sizeof(double));
 
   std::vector<Rcpp::NumericVector> pops{};
   std::vector<Rcpp::NumericVector> visits{};
@@ -252,7 +251,6 @@ Rcpp::List convolution_long(
   std::vector<double> vis(ca->nrow*(ca->ncol+ca->left_extra_cols+ca->right_extra_cols), 0.0);
 
   std::memcpy(&pop_a[ca->nrow*ca->left_extra_cols], &pop_in[0], ca->nrow*ca->ncol*sizeof(double));
-  std::memcpy(&vis[ca->nrow*ca->left_extra_cols], &pop_in[0], ca->nrow*ca->ncol*sizeof(double));
 
   Rcpp::NumericVector pops (int(ca->nrow) * int(ca->ncol));
   Rcpp::NumericVector visits (int(ca->nrow) * int(ca->ncol));"
andrewmarx,samc,86bf062e0aa7a31ce873133da5990106da41244d,Andrew Marx,andrewjmarx@gmail.com,2023-03-29T21:52:22Z,Andrew Marx,andrewjmarx@gmail.com,2023-03-29T21:52:22Z,"Conv long-term fixes

need to fix off-by-one in vis()",R/visitation.R;src/convolution.cpp,False,True,True,False,11,10,21,"---FILE: R/visitation.R---
@@ -384,12 +384,11 @@ setMethod(
   ""visitation"",
   signature(samc = ""samc"", init = ""ANY"", origin = ""missing"", dest = ""missing"", time = ""missing""),
   function(samc, init){
+    check(samc, init)
 
-    if (samc@solver %in% c(""direct"", ""iter"")) {
-      check(samc, init)
-
-      pv <- .process_init(samc, init)
+    pv <- .process_init(samc, init)
 
+    if (samc@solver %in% c(""direct"", ""iter"")) {
       if (samc@solver == ""iter"") {
         r <- .psif_iter(samc@data@f, pv)
       } else {

---FILE: src/convolution.cpp---
@@ -245,7 +245,7 @@ Rcpp::List convolution_long(
     const int threads = 1){
 
   double pop = 1.0;
-  double EPSILON = 0.00001;
+  double EPSILON = 0.0000000001;
 
   std::vector<double> pop_a(ca->nrow*(ca->ncol+ca->left_extra_cols+ca->right_extra_cols), 0.0);
   std::vector<double> pop_b(ca->nrow*(ca->ncol+ca->left_extra_cols+ca->right_extra_cols), 0.0);
@@ -282,19 +282,21 @@ Rcpp::List convolution_long(
     }
 
     if(count % 100 == 0) {
-      std::memcpy(&visits[0], vis_ptr, ca->nrow*ca->ncol*sizeof(double));
 
-      pop = Rcpp::sum(visits);
+      std::memcpy(&pops[0], p_in, ca->nrow*ca->ncol*sizeof(double));
+
+      pop = Rcpp::sum(pops);
     }
     Rcpp::checkUserInterrupt();
   } while(pop > EPSILON & count < count_limit);
 
   if (count == count_limit) {
-    Rcpp::Rcout << ""\nConvolution iteration limit reached. Results may not be accurate.\n"";
+    Rcpp::Rcout << ""\nConvolution iteration limit reached. Results may not have fully converged.\n"";
   }
 
-  std::memcpy(&pops[0], p_in, ca->nrow*ca->ncol*sizeof(double));
+  std::memcpy(&visits[0], vis_ptr, ca->nrow*ca->ncol*sizeof(double));
+
 //  std::memcpy(&visits[0], vis.data(), ca->nrow*ca->ncol*sizeof(double));
 
-  return Rcpp::List::create(Rcpp::Named(""time"") = count, Rcpp::Named(""dist"") = pops, Rcpp::Named(""vis"") = vis);
+  return Rcpp::List::create(Rcpp::Named(""time"") = count, Rcpp::Named(""dist"") = pops, Rcpp::Named(""vis"") = visits);
 }"
andrewmarx,samc,acfe6fd057d76a708afce1d0b902dc0aa64b1e72,Andrew Marx,andrewjmarx@gmail.com,2023-03-28T13:45:55Z,Andrew Marx,andrewjmarx@gmail.com,2023-03-28T13:45:55Z,fixes to last commit,R/internal-functions.R,False,True,True,False,7,8,15,"---FILE: R/internal-functions.R---
@@ -56,7 +56,7 @@
 #'
 #' @noRd
 .crw <- function(x, absorption, fidelity, fun, dir, sym = TRUE, model) {
-  tr = tr_vals_res(x, dir)
+  tr = .tr_vals_res(x, dir)
   edge_counts = sum(is.finite(tr))
   edge_nums = tr
   edge_nums[is.finite(edge_nums)] = 1:edge_counts
@@ -125,7 +125,6 @@
             for (dv in dir_vec) {
               if (dv) {
                 e2 = p2 + dv
-                print(1)
                 if (!is.na(tr[e2])) {
                   mat_p[edge_nums[e2] + 1] = mat_p[edge_nums[e2] + 1] + 1
                 }
@@ -194,7 +193,7 @@
                   rs = rs + res
 
                   row_indices[dv] = mat_p[e2_num] + mat_p_count[e2_num]
-                  mat_x[mat_p[e2_num] + mat_p_count[e2_num]] = res * vals[c]
+                  mat_x[mat_p[e2_num] + mat_p_count[e2_num]] = -res * vals[c]
                   mat_i[mat_p[e2_num] + mat_p_count[e2_num]] = e1_num
                 }
               } else {
@@ -222,7 +221,7 @@
   mat@i = as.integer(mat_i)
   mat@x = mat_x
 
-  temp = round(as.matrix(mat), 3)
+  #View(as.matrix(mat))
 
   return(
     list(tr = mat,
@@ -383,7 +382,7 @@
 }
 
 
-tr_vals = function(data, fun, dir) {
+.tr_vals = function(data, fun, dir) {
 
   nrows = terra::nrow(data)
   ncols = terra::ncol(data)
@@ -417,7 +416,7 @@ tr_vals = function(data, fun, dir) {
 }
 
 
-tr_vals_res = function(data, dir) {
+.tr_vals_res = function(data, dir) {
 
   nrows = terra::nrow(data)
   ncols = terra::ncol(data)
@@ -690,8 +689,8 @@ tr_vals_res = function(data, dir) {
   invalid_names <- x[!(x %in% vec)]
 
   if (length(invalid_names > 0)){
-    print(vec)
-    print(x)
+    #print(vec)
+    #print(x)
     stop(paste(""\nInvalid location name:"", invalid_names), call. = FALSE)
   }
 }"
andrewmarx,samc,f4651b3924d5c124bf714873ae8c220649f2a3aa,Andrew Marx,andrewjmarx@gmail.com,2023-03-14T18:23:40Z,Andrew Marx,andrewjmarx@gmail.com,2023-03-14T18:23:55Z,Rollback optimzation causing crw bug,R/internal-functions.R,False,True,True,False,29,8,37,"---FILE: R/internal-functions.R---
@@ -206,30 +206,51 @@
   tmp = 1 - terra::values(absorption) - fidelity
   rs = Matrix::rowSums(mat)
 
-  crw_lookup = as.vector(crw_map[,1])
+  # TODO figure out where bug is in this optimization
+  # crw_lookup = as.vector(crw_map[,1])
+  #
+  # i_index = 1
+  # for (p in 1:sum(edge_counts)) {
+  #   row_count = mat_p[p+1] - mat_p[p]
+  #   for (i in 1:row_count) {
+  #     row = mat_i[i_index] + 1
+  #     if (p != row) {
+  #       #mat_x[i_index] = i_index # useful for validation
+  #       #mat_x[i_index] = cell_nums[row] # useful for validation
+  #       #print(c(p, row))
+  #       #assign(""ts"", list(mat_p, mat_i), envir = globalenv())
+  #
+  #       mat_x[i_index] = -mat_x[i_index]/rs[row] * tmp[cell_nums[crw_lookup[row]]]
+  #     } else {
+  #       mat_x[i_index] =  1 - fidelity[cell_nums[crw_lookup[row]]]
+  #     }
+  #     i_index = i_index + 1
+  #   }
+  # }
+  #
+  # # For perf reasons
+  # mat@x = mat_x
+
 
   i_index = 1
   for (p in 1:sum(edge_counts)) {
-    row_count = mat_p[p+1] - mat_p[p]
+    row_count = mat@p[p+1] - mat@p[p]
     for (i in 1:row_count) {
-      row = mat_i[i_index] + 1
+      row = mat@i[i_index] + 1
       if (p != row) {
         #mat_x[i_index] = i_index # useful for validation
         #mat_x[i_index] = cell_nums[row] # useful for validation
         #print(c(p, row))
         #assign(""ts"", list(mat_p, mat_i), envir = globalenv())
 
-        mat_x[i_index] = -mat_x[i_index]/rs[row] * tmp[cell_nums[crw_lookup[row]]]
+        mat@x[i_index] = -mat@x[i_index]/rs[row] * tmp[cell_nums[crw_map[,1][row]]]
       } else {
-        mat_x[i_index] =  1 - fidelity[cell_nums[crw_lookup[row]]]
+        mat@x[i_index] =  1 - fidelity[cell_nums[crw_map[,1][row]]]
       }
       i_index = i_index + 1
     }
   }
 
-  # For perf reasons
-  mat@x = mat_x
-
   return(
     list(tr = mat,
          crw = crw_map,"
andrewmarx,samc,cd4833730b0068e6062c94a61ee3a75fb17a3cf1,Andrew Marx,andrewjmarx@gmail.com,2023-03-14T00:30:53Z,Andrew Marx,andrewjmarx@gmail.com,2023-03-14T00:30:53Z,Minor fix and disable iteration limit,R/internal-functions.R,False,True,True,False,13,13,26,"---FILE: R/internal-functions.R---
@@ -476,12 +476,12 @@
 
 .convolution <- function(res, abso, fid, dir, sym, threads) {
 
-  if (directions == 4) {
+  if (dir == 4) {
     kernel = matrix(
       c(0, 1, 0,
         1, 0, 1,
         0, 1, 0), 3)
-  } else if (directions == 8) {
+  } else if (dir == 8) {
     kernel = matrix(
       c(1 / sqrt(2), 1, 1 / sqrt(2),
         1.0000000, 0, 1.0000000,
@@ -536,17 +536,17 @@
   if (sum(duplicated(x) > 0))
     stop(""Duplicate time steps are not allowed in the time argument"", call. = FALSE)
 
-  if (any(x > 10000))
-    stop(""Due to how the short-term metrics are calculated and the way that
-  decimal numbers are handled by computers, numerical issues related to
-  precision arise when a time step value is too high. Currently, a hard
-  limit of 10000 time steps is enforced to encourage users to more
-  seriously consider how many time steps are relevant to their use case.
-  For example, if a single time step represents 1 day, then the current
-  limit represents 24.7 years. There is flexibility to increase the limit
-  if a justification can be made for it, but it's far more likely that
-  users will generally want far fewer time steps for ecologically relevant
-  results and to avoid the cummulative precision issues."", call. = FALSE)
+  # if (any(x > 10000))
+  #   stop(""Due to how the short-term metrics are calculated and the way that
+  # decimal numbers are handled by computers, numerical issues related to
+  # precision arise when a time step value is too high. Currently, a hard
+  # limit of 10000 time steps is enforced to encourage users to more
+  # seriously consider how many time steps are relevant to their use case.
+  # For example, if a single time step represents 1 day, then the current
+  # limit represents 24.7 years. There is flexibility to increase the limit
+  # if a justification can be made for it, but it's far more likely that
+  # users will generally want far fewer time steps for ecologically relevant
+  # results and to avoid the cummulative precision issues."", call. = FALSE)
 }
 
 "
andrewmarx,samc,86de491a8176b42cca09965e10d70e9f58654843,Andrew Marx,andrewjmarx@gmail.com,2023-03-09T04:07:42Z,Andrew Marx,andrewjmarx@gmail.com,2023-03-09T04:07:42Z,"Working convolution implementation

Some small things still needing improvements:
- checks
- latlon correction
- NA support",R/RcppExports.R;R/absorption.R;R/cond_passage.R;R/dispersal.R;R/distribution.R;R/internal-functions.R;R/mortality.R;R/samc-class.R;R/samc.R;R/survival.R;R/visitation.R;src/RcppExports.cpp;src/convolution.cpp;src/convolution.h;src/samc_types.h,False,True,True,False,729,87,816,"---FILE: R/RcppExports.R---
@@ -9,6 +9,22 @@
     .Call('_samc_cond_t_iter', PACKAGE = 'samc', IQ, qj)
 }
 
+.build_convolution_cache <- function(kernel, resistance, fidelity, absorption, symmetric, threads = 1L) {
+    .Call('_samc_build_convolution_cache', PACKAGE = 'samc', kernel, resistance, fidelity, absorption, symmetric, threads)
+}
+
+.get_convolution_list <- function(ca) {
+    .Call('_samc_get_convolution_list', PACKAGE = 'samc', ca)
+}
+
+.convolution_short <- function(steps, ca, pop_in, threads = 1L) {
+    .Call('_samc_convolution_short', PACKAGE = 'samc', steps, ca, pop_in, threads)
+}
+
+.convolution_long <- function(ca, pop_in, threads = 1L) {
+    .Call('_samc_convolution_long', PACKAGE = 'samc', ca, pop_in, threads)
+}
+
 .sum_qn_q <- function(M, M2, q, t) {
     .Call('_samc_sum_qn_q', PACKAGE = 'samc', M, M2, q, t)
 }

---FILE: R/absorption.R---
@@ -64,6 +64,8 @@ setMethod(
   ""absorption"",
   signature(samc = ""samc"", init = ""missing"", origin = ""missing""),
   function(samc) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if (any(dim(samc@data@c_abs) == 0)) stop(""No absorption components defined in the samc object"", call. = FALSE)
 
     # TODO: possibly optimize using C++
@@ -82,6 +84,8 @@ setMethod(
   ""absorption"",
   signature(samc = ""samc"", init = ""missing"", origin = ""location""),
   function(samc, origin) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if (any(dim(samc@data@c_abs) == 0)) stop(""No absorption components defined in the samc object"", call. = FALSE)
 
     vis <- visitation(samc, origin = origin)
@@ -99,16 +103,23 @@ setMethod(
   ""absorption"",
   signature(samc = ""samc"", init = ""ANY"", origin = ""missing""),
   function(samc, init) {
+
     if (any(dim(samc@data@c_abs) == 0)) stop(""No absorption components defined in the samc object"", call. = FALSE)
 
-    check(samc, init)
+    if (samc@solver %in% c(""direct"", ""iter"")) {
+      check(samc, init)
 
-    pv <- .process_init(samc, init)
+      pv = .process_init(samc, init)
 
-    pf <-.psif(samc@data@f, pv, samc@.cache$sc)
+      pf = .psif(samc@data@f, pv, samc@.cache$sc)
+    } else if (samc@solver == ""conv"") {
+      pf = visitation(samc, init)
+    } else {
+      stop(""Invalid method attribute in samc object."")
+    }
 
-    result <- as.vector(pf %*% samc@data@c_abs)
-    names(result) <- colnames(samc@data@c_abs)
+    result = as.vector(pf %*% samc@data@c_abs)
+    names(result) = colnames(samc@data@c_abs)
 
     return(result)
   })

---FILE: R/cond_passage.R---
@@ -74,6 +74,8 @@ setMethod(
   ""cond_passage"",
   signature(samc = ""samc"", init = ""missing"", origin = ""missing"", dest = ""location""),
   function(samc, dest) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if (samc@clumps == -1)
       warning(""Unknown number of clumps in data. If the function crashes, it may be due to the transition matrix being discontinuous."", call. = FALSE)
 
@@ -121,6 +123,8 @@ setMethod(
   ""cond_passage"",
   signature(samc = ""samc"", init = ""missing"", origin = ""location"", dest = ""location""),
   function(samc, origin, dest) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if(length(origin) != length(dest))
       stop(""The 'origin' and 'dest' parameters must have the same number of values"", call. = FALSE)
 

---FILE: R/dispersal.R---
@@ -117,6 +117,8 @@ setMethod(
   ""dispersal"",
   signature(samc = ""samc"", init = ""missing"", origin = ""missing"", dest = ""location"", time = ""numeric""),
   function(samc, dest, time) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if (length(dest) != 1)
       stop(""dest can only contain a single location for this version of the function"", call. = FALSE)
 
@@ -161,6 +163,8 @@ setMethod(
   ""dispersal"",
   signature(samc = ""samc"", init = ""ANY"", origin = ""missing"", dest = ""location"", time = ""numeric""),
   function(samc, init, dest, time) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if (length(dest) != 1)
       stop(""dest can only contain a single location for this version of the function"", call. = FALSE)
 
@@ -188,6 +192,8 @@ setMethod(
   ""dispersal"",
   signature(samc = ""samc"", init = ""missing"", origin = ""missing"", dest = ""missing"", time = ""missing""),
   function(samc) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if (!samc@override)
       stop(""This version of the dispersal() method produces a large dense matrix.\nSee the documentation for details."", call. = FALSE)
 
@@ -212,6 +218,8 @@ setMethod(
   ""dispersal"",
   signature(samc = ""samc"", init = ""missing"", origin = ""location"", dest = ""missing"", time = ""missing""),
   function(samc, origin) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     origin <- .process_locations(samc, origin)
 
     if (!samc@.cache$dgf_exists) {
@@ -240,6 +248,8 @@ setMethod(
   ""dispersal"",
   signature(samc = ""samc"", init = ""missing"", origin = ""missing"", dest = ""location"", time = ""missing""),
   function(samc, dest) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     dest <- .process_locations(samc, dest)
 
     f_col <- visitation(samc, dest = dest)
@@ -258,6 +268,8 @@ setMethod(
   ""dispersal"",
   signature(samc = ""samc"", init = ""missing"", origin = ""location"", dest = ""location"", time = ""missing""),
   function(samc, origin, dest) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     origin <- .process_locations(samc, origin)
     dest <- .process_locations(samc, dest)
 
@@ -281,6 +293,8 @@ setMethod(
   ""dispersal"",
   signature(samc = ""samc"", init = ""ANY"", origin = ""missing"", dest = ""missing"", time = ""missing""),
   function(samc, init) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     check(samc, init)
 
     pv <- .process_init(samc, init)
@@ -312,6 +326,8 @@ setMethod(
   ""dispersal"",
   signature(samc = ""samc"", init = ""ANY"", origin = ""missing"", dest = ""location"", time = ""missing""),
   function(samc, init, dest) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     check(samc, init)
 
     pv <- .process_init(samc, init)

---FILE: R/distribution.R---
@@ -98,6 +98,7 @@ setMethod(
   ""distribution"",
   signature(samc = ""samc"", init = ""missing"", origin = ""missing"", dest = ""missing"", time = ""numeric""),
   function(samc, time) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
 
     if (!samc@override)
       stop(""This version of the distribution() method produces a large dense matrix.\nSee the documentation for details."", call. = FALSE)
@@ -122,6 +123,8 @@ setMethod(
   ""distribution"",
   signature(samc = ""samc"", init = ""missing"", origin = ""location"", dest = ""missing"", time = ""numeric""),
   function(samc, origin, time) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if (length(origin) != 1)
       stop(""origin can only contain a single location for this version of the function"", call. = FALSE)
 
@@ -148,6 +151,8 @@ setMethod(
   ""distribution"",
   signature(samc = ""samc"", init = ""missing"", origin = ""missing"", dest = ""location"", time = ""numeric""),
   function(samc, dest, time) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if (length(dest) != 1)
       stop(""dest can only contain a single location for this version of the function"", call. = FALSE)
 
@@ -174,6 +179,8 @@ setMethod(
   ""distribution"",
   signature(samc = ""samc"", init = ""missing"", origin = ""location"", dest = ""location"", time = ""numeric""),
   function(samc, origin, dest, time) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if (length(dest) != 1)
       stop(""dest can only contain a single location for this version of the function"", call. = FALSE)
 
@@ -202,17 +209,27 @@ setMethod(
 
     .validate_time_steps(time)
 
-    q <- samc$q_matrix
+    if (samc@solver %in% c(""direct"", ""iter"")) {
+      q = samc$q_matrix
 
-    time <- c(0, time)
+      time = c(0, time)
 
-    res <- .psiq(q, pv, time)
+      res = .psiq(q, pv, time)
 
-    res <- lapply(res, as.vector)
+      res = lapply(res, as.vector)
+
+      if (length(res) == 1) {
+        return(res[[1]])
+      } else {
+        return(res)
+      }
+    } else if (samc@solver == ""conv"") {
+      results_list <- samc:::.convolution_short(time, samc@conv_cache, pv, samc@threads)
+
+      res = as.vector(results_list$dist[[1]])
 
-    if (length(res) == 1) {
-      return(res[[1]])
-    } else {
       return(res)
+    } else {
+      stop(""Invalid method attribute in samc object."")
     }
   })

---FILE: R/internal-functions.R---
@@ -466,6 +466,51 @@
 
 }
 
+
+#' Convolution
+#'
+#' TODO description here
+#'
+#' @param x A function
+#' @noRd
+
+.convolution <- function(res, abso, fid, dir, sym, threads) {
+
+  if (directions == 4) {
+    kernel = matrix(
+      c(0, 1, 0,
+        1, 0, 1,
+        0, 1, 0), 3)
+  } else if (directions == 8) {
+    kernel = matrix(
+      c(1 / sqrt(2), 1, 1 / sqrt(2),
+        1.0000000, 0, 1.0000000,
+        1 / sqrt(2), 1, 1 / sqrt(2)
+      ), 3, 3
+    )
+  } else {
+    stop(""'directions' must be equal to either 4 or 8"")
+  }
+
+  nr = nrow(res)
+  nc = ncol(res)
+
+  res = as.matrix(res)
+  abso = as.matrix(abso)
+  fid = as.matrix(fid)
+
+  res[!is.finite(res)] = 0
+  abso[!is.finite(abso)] = 0
+  fid[!is.finite(fid)] = 0
+
+  dim(res) = c(nc, nr)
+  dim(abso) = c(nc, nr)
+  dim(fid) = c(nc, nr)
+
+  samc:::.build_convolution_cache(kernel, res, fid, abso, sym, threads)
+}
+
+
 #' Validate time steps
 #'
 #' Performs several checks to make sure a vector of time steps is valid
@@ -618,7 +663,7 @@ setMethod(
 #'
 #' @param x A list
 #' @noRd
-.validate_model <- function(x) {
+.validate_model <- function(x, method) {
   args <- c(""name"", ""fun"", ""dir"", ""sym"")
   names <- names(x)
 
@@ -631,6 +676,11 @@ setMethod(
     names = c(names, ""name"")
   }
 
+  if (method == ""conv"") {
+    if (x$name != ""RW"") stop(""Convolution only supports RW model."")
+  }
+
+
   if (x$name == ""CRW"") {
     args = c(args, ""dist"")
   }
@@ -692,6 +742,29 @@ setMethod(
 }
 
 
+#' Validate options
+#'
+#' Validates the options args for the samc() function
+#'
+#' @param x A list
+#' @noRd
+.validate_options <- function(x) {
+  if (is.null(x)) {
+    x = list(
+      method = ""direct"",
+      threads = 1,
+      override = FALSE
+    )
+  } else if (is.list(x)) {
+    # TODO finish this
+  } else {
+    stop(""options argument must be a list or left empty for default values"", call. = FALSE)
+  }
+
+  x
+}
+
+
 #' Process absorption inputs
 #'
 #' Process absorption inputs
@@ -798,7 +871,7 @@ setMethod(
   function(samc, x) {
     if (any(!is.finite(x)) || any(x < 0)) stop(""`init` input must only contain positive numeric values"")
 
-    if (length(x) != nrow(samc$q_matrix)) stop(""`init` input length does not match number of transient states"")
+    if (length(x) != length(samc@data@t_abs)) stop(""`init` input length does not match number of transient states"")
 
     return(x)
   })

---FILE: R/mortality.R---
@@ -147,6 +147,8 @@ setMethod(
   ""mortality"",
   signature(samc = ""samc"", init = ""missing"", origin = ""missing"", dest = ""missing"", time = ""numeric""),
   function(samc, time) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if (!samc@override)
       stop(""This version of the mortality() method produces a large dense matrix.\nSee the documentation for details."", call. = FALSE)
 
@@ -178,6 +180,8 @@ setMethod(
   ""mortality"",
   signature(samc = ""samc"", init = ""missing"", origin = ""location"", dest = ""missing"", time = ""numeric""),
   function(samc, origin, time) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     mort = visitation(samc, origin = origin, time = time)
 
     rdg <- samc@data@t_abs
@@ -195,6 +199,8 @@ setMethod(
   ""mortality"",
   signature(samc = ""samc"", init = ""missing"", origin = ""missing"", dest = ""location"", time = ""numeric""),
   function(samc, dest, time) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if (length(dest) != 1)
       stop(""dest can only contain a single location for this version of the function"", call. = FALSE)
 
@@ -226,6 +232,8 @@ setMethod(
   ""mortality"",
   signature(samc = ""samc"", init = ""missing"", origin = ""location"", dest = ""location"", time = ""numeric""),
   function(samc, origin, dest, time) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     dest <- .process_locations(samc, dest)
 
     mort <- mortality(samc, origin = origin, time = time)
@@ -245,15 +253,28 @@ setMethod(
   ""mortality"",
   signature(samc = ""samc"", init = ""ANY"", origin = ""missing"", dest = ""missing"", time = ""numeric""),
   function(samc, init, time) {
+    if (samc@solver %in% c(""direct"", ""iter"")) {
+      mort = visitation(samc, init = init, time = time)
 
-    mort = visitation(samc, init = init, time = time)
+      rdg <- samc@data@t_abs
 
-    rdg <- samc@data@t_abs
+      if (is.list(mort)) {
+        return(lapply(mort, function(x){as.vector(x * rdg)}))
+      } else {
+        return(as.vector(mort * rdg))
+      }
+    } else if (samc@solver == ""conv"") {
+      check(samc, init)
+      pv <- .process_init(samc, init)
+      .validate_time_steps(time)
 
-    if (is.list(mort)) {
-      return(lapply(mort, function(x){as.vector(x * rdg)}))
+      results_list = samc:::.convolution_short(time, samc@conv_cache, pv, samc@threads)
+
+      res = as.vector(results_list$mort[[1]])
+
+      return(res)
     } else {
-      return(as.vector(mort * rdg))
+      stop(""Invalid method attribute in samc object."")
     }
   })
 
@@ -263,6 +284,8 @@ setMethod(
   ""mortality"",
   signature(samc = ""samc"", init = ""missing"", origin = ""missing"", dest = ""missing"", time = ""missing""),
   function(samc) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if (!samc@override)
       stop(""This version of the mortality() method produces a large dense matrix.\nSee the documentation for details."", call. = FALSE)
 
@@ -301,6 +324,8 @@ setMethod(
   ""mortality"",
   signature(samc = ""samc"", init = ""missing"", origin = ""location"", dest = ""missing"", time = ""missing""),
   function(samc, origin) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     vis <- visitation(samc, origin = origin)
     names(vis) <- samc$names
 
@@ -322,6 +347,8 @@ setMethod(
   ""mortality"",
   signature(samc = ""samc"", init = ""missing"", origin = ""missing"", dest = ""location"", time = ""missing""),
   function(samc, dest) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     dest <- .process_locations(samc, dest)
 
     vis <- visitation(samc, dest = dest)
@@ -345,6 +372,8 @@ setMethod(
   ""mortality"",
   signature(samc = ""samc"", init = ""missing"", origin = ""location"", dest = ""location"", time = ""missing""),
   function(samc, origin, dest) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if(length(origin) != length(dest))
       stop(""The 'origin' and 'dest' parameters must have the same number of values"", call. = FALSE)
 
@@ -378,26 +407,38 @@ setMethod(
   ""mortality"",
   signature(samc = ""samc"", init = ""ANY"", origin = ""missing"", dest = ""missing"", time = ""missing""),
   function(samc, init) {
+
     check(samc, init)
 
     pv <- .process_init(samc, init)
 
-    if (samc@solver == ""iter"") {
-      pf <- .psif_iter(samc@data@f, pv)
-    } else {
-      pf <- .psif(samc@data@f, pv, samc@.cache$sc)
-    }
+    if (samc@solver %in% c(""direct"", ""iter"")) {
+      if (samc@solver == ""iter"") {
+        pf <- .psif_iter(samc@data@f, pv)
+      } else {
+        pf <- .psif(samc@data@f, pv, samc@.cache$sc)
+      }
 
-    names(pf) <- samc$names
+      names(pf) <- samc$names
 
-    mort <- pf * samc@data@t_abs
+      mort <- pf * samc@data@t_abs
 
-    if (ncol(samc@data@c_abs) > 0) {
-      mort <- list(total = mort)
-      for (n in colnames(samc@data@c_abs)) {
-        mort[[n]] <- pf * samc@data@c_abs[, n]
+      if (ncol(samc@data@c_abs) > 0) {
+        mort <- list(total = mort)
+        for (n in colnames(samc@data@c_abs)) {
+          mort[[n]] <- pf * samc@data@c_abs[, n]
+        }
       }
-    }
 
-    return(mort)
+      return(mort)
+    } else if (samc@solver == ""conv"") {
+
+      results_list <- samc:::.convolution_long(samc@conv_cache, pv, samc@threads)
+
+      res = results_list$mort
+
+      return(res)
+    } else {
+      stop(""Invalid method attribute in samc object."")
+    }
   })

---FILE: R/samc-class.R---
@@ -78,6 +78,7 @@ NULL
 #' }
 #'
 #' @slot data Data associated with different components of the P matrix
+#' @slot conv_cache Convolution cache
 #' @slot source Information about the data source for the P matrix
 #' @slot map Used to verify landscape inputs and mapping of vector data
 #' @slot names Names of the transient states
@@ -93,6 +94,7 @@ setClass(
 
   # define the slots
   slots = list(data = ""samc_data"",
+               conv_cache = ""ANY"",
                model = ""list"",
                source = ""character"",
                map = ""SpatRaster"",

---FILE: R/samc.R---
@@ -107,6 +107,7 @@ NULL
 #' @param absorption A \code{\link[terra]{SpatRaster-class}} or \code{\link[raster]{RasterLayer-class}} or \code{\link[base]{matrix}}
 #' @param fidelity A \code{\link[terra]{SpatRaster-class}} or \code{\link[raster]{RasterLayer-class}} or \code{\link[base]{matrix}}
 #' @param model A list with args for constructing a transition matrix.
+#' @param method A character string.
 #'
 #' @return A \code{\link{samc-class}} object
 #'
@@ -116,7 +117,7 @@ NULL
 
 setGeneric(
   ""samc"",
-  function(data, absorption, fidelity, model) {
+  function(data, absorption, fidelity, model, options = NULL) {
     standardGeneric(""samc"")
   })
 
@@ -128,8 +129,9 @@ setMethod(
             absorption = ""SpatRaster"",
             fidelity = ""SpatRaster"",
             model = ""list""),
-  function(data, absorption, fidelity, model) {
-    model = .validate_model(model)
+  function(data, absorption, fidelity, model, options = NULL) {
+    options = .validate_options(options)
+    model = .validate_model(model, options$method)
 
     tr_fun <- model$fun
     directions <-model$dir
@@ -180,15 +182,16 @@ setMethod(
                              data = methods::new(""samc_data"",
                                                  f = new(""dgCMatrix""),
                                                  t_abs = numeric(0)),
+                             conv_cache = NULL,
                              model = model,
                              source = ""SpatRaster"",
                              map = data,
                              crw_map = NULL,
                              names = NULL,
                              clumps = -1,
-                             override = FALSE,
-                             solver = ""direct"",
-                             threads = 1,
+                             override = options$override,
+                             solver = options$method,
+                             threads = options$threads,
                              .cache = new.env())
 
     # Check for ""clumps""
@@ -208,29 +211,40 @@ setMethod(
     }
     rm(cl)
     gc()
-
     # Create the transition matrix
-    if (model$name == ""RW"") {
-      samc_obj@data@f = .rw(data, absorption, fidelity, tr_fun, directions, symm)
-      gc()
+    if (options$method %in% c(""direct"", ""iter"")) {
+      if (model$name == ""RW"") {
+        samc_obj@data@f = .rw(data, absorption, fidelity, tr_fun, directions, symm)
+        gc()
 
-      samc_obj@data@t_abs = as.vector(terra::values(absorption))[terra::cells(absorption)]
-    } else if (model$name == ""CRW"") {
+        samc_obj@data@t_abs = as.vector(terra::values(absorption))[terra::cells(absorption)]
+      } else if (model$name == ""CRW"") {
 
-      if (terra::is.lonlat(data)) warning(""CRW does not properly adjust turning angles for lonlat yet."")
+        if (terra::is.lonlat(data)) warning(""CRW does not properly adjust turning angles for lonlat yet."")
 
-      crw_list = .crw(data, absorption, fidelity, tr_fun, directions, symm, model)
-      #assign(""myvar"", crw_list)
-      samc_obj@data@f = crw_list$tr
-      gc()
+        crw_list = .crw(data, absorption, fidelity, tr_fun, directions, symm, model)
+        #assign(""myvar"", crw_list)
+        samc_obj@data@f = crw_list$tr
+        gc()
 
-      samc_obj@data@t_abs = crw_list$abs
-      samc_obj@crw_map = crw_list$crw
+        samc_obj@data@t_abs = crw_list$abs
+        samc_obj@crw_map = crw_list$crw
 
-    } else {
-      stop(""Unexpected error involving model name. Please report with a minimum reproducible example."", call. = FALSE)
+      } else {
+        stop(""Unexpected error involving model name. Please report with a minimum reproducible example."", call. = FALSE)
+      }
+    } else if (options$method == ""conv"") {
+      if (unlist(terra::global(data, ""isNA"")) > 0) stop(""Convolution method does not support rasters with NA data currently."")
+
+      if (terra::is.lonlat(data)) warning(""Convolution method does not properly correct directions for lonlat yet."")
+
+      if (model$name != ""RW"") stop(""Convolution method only supports RW model"", call. = FALSE)
+
+      samc_obj@conv_cache = .convolution(data, absorption, fidelity, directions, symm, options$threads)
+      samc_obj@data@t_abs = as.vector(terra::values(absorption))[terra::cells(absorption)]
     }
 
+
     # TODO Update to terra
     if(is.na(raster::projection(data)) && raster::xres(data) != raster::yres(data)) {
       warning(""Raster cells are not square (number of columns/rows is not propotional to the spatial extents). There is no defined projection to account for this, so the geocorrection may lead to distortion if the intent was for the raster cells to represent a uniformly spaced grid."", call. = FALSE)
@@ -255,13 +269,13 @@ setMethod(
             absorption = ""RasterLayer"",
             fidelity = ""RasterLayer"",
             model = ""list""),
-  function(data, absorption, fidelity, model) {
+  function(data, absorption, fidelity, model, options = NULL) {
 
     data = rasterize(data)
     absorption = rasterize(absorption)
     fidelity = rasterize(fidelity)
 
-    samc_obj = samc(data, absorption, fidelity, model = model)
+    samc_obj = samc(data, absorption, fidelity, model = model, options = options)
     samc_obj@source = ""RasterLayer""
 
     return(samc_obj)
@@ -274,12 +288,12 @@ setMethod(
             absorption = ""SpatRaster"",
             fidelity = ""missing"",
             model = ""list""),
-  function(data, absorption, model) {
+  function(data, absorption, model, options = NULL) {
 
     fidelity <- data
     fidelity[is.finite(fidelity)] <- 0
 
-    return(samc(data, absorption, fidelity, model))
+    return(samc(data, absorption, fidelity, model, options = options))
   })
 
 #' @rdname samc
@@ -289,12 +303,12 @@ setMethod(
             absorption = ""RasterLayer"",
             fidelity = ""missing"",
             model = ""list""),
-  function(data, absorption, model) {
+  function(data, absorption, model,options = NULL) {
 
     data = rasterize(data)
     absorption = rasterize(absorption)
 
-    samc_obj = samc(data, absorption, model = model)
+    samc_obj = samc(data, absorption, model = model, options = options)
     samc_obj@source = ""RasterLayer""
 
     return(samc_obj)
@@ -307,13 +321,13 @@ setMethod(
             absorption = ""matrix"",
             fidelity = ""matrix"",
             model = ""list""),
-  function(data, absorption, fidelity, model) {
+  function(data, absorption, fidelity, model, options = NULL) {
 
     data <- rasterize(data)
     absorption <- rasterize(absorption)
     fidelity <- rasterize(fidelity)
 
-    samc_obj = samc(data, absorption, fidelity, model)
+    samc_obj = samc(data, absorption, fidelity, model, options = options)
     samc_obj@source = ""matrix""
 
     return(samc_obj)
@@ -328,12 +342,12 @@ setMethod(
             absorption = ""matrix"",
             fidelity = ""missing"",
             model = ""list""),
-  function(data, absorption, model) {
+  function(data, absorption, model, options = NULL) {
 
     data <- rasterize(data)
     absorption <- rasterize(absorption)
 
-    samc_obj = samc(data, absorption, model = model)
+    samc_obj = samc(data, absorption, model = model, options = options)
     samc_obj@source = ""matrix""
 
     return(samc_obj)
@@ -351,7 +365,8 @@ setMethod(
             absorption = ""missing"",
             fidelity = ""missing"",
             model = ""missing""),
-  function(data) {
+  function(data, options = NULL) {
+    options = .validate_options(options)
 
     r = nrow(data)
     c = ncol(data)
@@ -396,9 +411,9 @@ setMethod(
                              map = terra::rast(),
                              names = nm,
                              clumps = -1,
-                             threads = 1,
-                             override = FALSE,
-                             solver = ""direct"")
+                             threads = options$threads,
+                             override = options$override,
+                             solver = options$method)
 
     samc_obj@.cache$dgf = numeric(nrow(samc_obj@data@f))
     samc_obj@.cache$dgf_exists = FALSE
@@ -415,8 +430,8 @@ setMethod(
             absorption = ""missing"",
             fidelity = ""missing"",
             model = ""missing""),
-  function(data) {
+  function(data, options = NULL) {
     p <- methods::as(methods::as(data, ""CsparseMatrix""), ""generalMatrix"")
 
-    return(samc(data = p))
+    return(samc(data = p), options = options)
   })

---FILE: R/survival.R---
@@ -52,6 +52,7 @@ setMethod(
   ""survival"",
   signature(samc = ""samc"", init = ""missing""),
   function(samc) {
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
 
     if (samc@solver == ""iter"") {
       z = .f1_iter(samc@data@f)
@@ -68,13 +69,23 @@ setMethod(
   ""survival"",
   signature(samc = ""samc"", init = ""ANY""),
   function(samc, init) {
-    check(samc, init)
 
-    pv <- .process_init(samc, init)
+    if (samc@solver %in% c(""direct"", ""iter"")) {
+      check(samc, init)
 
-    sv <- survival(samc)
+      pv <- .process_init(samc, init)
 
-    surv <- pv %*% sv
+      sv <- survival(samc)
 
-    return(as.numeric(surv))
+      surv <- pv %*% sv
+
+      return(as.numeric(surv))
+    } else if (samc@solver == ""conv"") {
+
+      res = visitation(samc, init)
+
+      return(sum(res))
+    } else {
+      stop(""Invalid method attribute in samc object."")
+    }
   })

---FILE: R/visitation.R---
@@ -151,6 +151,8 @@ setMethod(
   ""visitation"",
   signature(samc = ""samc"", init = ""missing"", origin = ""missing"", dest = ""missing"", time = ""numeric""),
   function(samc, time){
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if (!samc@override)
       stop(""This version of the visitation() method produces a large dense matrix.\nSee the documentation for details."", call. = FALSE)
 
@@ -175,6 +177,8 @@ setMethod(
   ""visitation"",
   signature(samc = ""samc"", init = ""missing"", origin = ""location"", dest = ""missing"", time = ""numeric""),
   function(samc, origin, time){
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if (length(origin) != 1)
       stop(""origin can only contain a single location for this version of the function"", call. = FALSE)
 
@@ -200,6 +204,8 @@ setMethod(
   ""visitation"",
   signature(samc = ""samc"", init = ""missing"", origin = ""missing"", dest = ""location"", time = ""numeric""),
   function(samc, dest, time){
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if (length(dest) != 1)
       stop(""dest can only contain a single location for this version of the function"", call. = FALSE)
 
@@ -225,6 +231,7 @@ setMethod(
   ""visitation"",
   signature(samc = ""samc"", init = ""missing"", origin = ""location"", dest = ""location"", time = ""numeric""),
   function(samc, origin, dest, time){
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
 
     dest = .process_locations(samc, dest)
 
@@ -251,15 +258,25 @@ setMethod(
 
     pv <- .process_init(samc, init)
 
-    q <- samc$q_matrix
 
-    time <- c(1, time)
-    ft <- .sum_psiqpow(q, pv, time)
+    if (samc@solver %in% c(""direct"", ""iter"")) {
+      q <- samc$q_matrix
 
-    if (length(ft) == 1) {
-      return(ft[[1]])
+      time <- c(1, time)
+      ft <- .sum_psiqpow(q, pv, time)
+
+      if (length(ft) == 1) {
+        return(ft[[1]])
+      } else {
+        return(ft)
+      }
+    } else if (samc@solver == ""conv"") {
+
+      res = mortality(samc, init, time = time)
+
+      return(res / samc@data@t_abs)
     } else {
-      return(ft)
+      stop(""Invalid method attribute in samc object."")
     }
   })
 
@@ -270,6 +287,8 @@ setMethod(
   ""visitation"",
   signature(samc = ""samc"", init = ""missing"", origin = ""missing"", dest = ""missing"", time = ""missing""),
   function(samc){
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if (!samc@override)
       stop(""This version of the visitation() method produces a large dense matrix.\nSee the documentation for details."", call. = FALSE)
 
@@ -283,6 +302,8 @@ setMethod(
   ""visitation"",
   signature(samc = ""samc"", init = ""missing"", origin = ""location"", dest = ""missing"", time = ""missing""),
   function(samc, origin){
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if (is.matrix(origin)) {
 
     } else {
@@ -309,6 +330,8 @@ setMethod(
   ""visitation"",
   signature(samc = ""samc"", init = ""missing"", origin = ""missing"", dest = ""location"", time = ""missing""),
   function(samc, dest){
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     if (is.matrix(dest)) {
 
     } else {
@@ -333,6 +356,8 @@ setMethod(
   ""visitation"",
   signature(samc = ""samc"", init = ""missing"", origin = ""location"", dest = ""location"", time = ""missing""),
   function(samc, origin, dest){
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     origin <- .process_locations(samc, origin)
     dest <- .process_locations(samc, dest)
 
@@ -357,17 +382,26 @@ setMethod(
   signature(samc = ""samc"", init = ""ANY"", origin = ""missing"", dest = ""missing"", time = ""missing""),
   function(samc, init){
 
-    check(samc, init)
+    if (samc@solver %in% c(""direct"", ""iter"")) {
+      check(samc, init)
 
-    pv <- .process_init(samc, init)
+      pv <- .process_init(samc, init)
 
-    if (samc@solver == ""iter"") {
-      r <- .psif_iter(samc@data@f, pv)
+      if (samc@solver == ""iter"") {
+        r <- .psif_iter(samc@data@f, pv)
+      } else {
+        r <- .psif(samc@data@f, pv, samc@.cache$sc)
+      }
+
+      return(as.vector(r))
+    } else if (samc@solver == ""conv"") {
+
+      res = mortality(samc, init)
+
+      return(res / samc@data@t_abs)
     } else {
-      r <- .psif(samc@data@f, pv, samc@.cache$sc)
+      stop(""Invalid method attribute in samc object."")
     }
-
-    return(as.vector(r))
   })
 
 
@@ -377,6 +411,8 @@ setMethod(
   ""visitation"",
   signature(samc = ""samc"", init = ""ANY"", origin = ""missing"", dest = ""location"", time = ""missing""),
   function(samc, init, dest){
+    if (samc@solver == ""conv"") stop(""Metric not setup for the convolution method"", call. = FALSE)
+
     check(samc, init)
 
     pv <- .process_init(samc, init)

---FILE: src/RcppExports.cpp---
@@ -37,6 +37,60 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
+// build_convolution_cache
+Rcpp::XPtr<convolution_cache> build_convolution_cache(const Rcpp::NumericMatrix& kernel, const Rcpp::NumericMatrix& resistance, const Rcpp::NumericMatrix& fidelity, const Rcpp::NumericMatrix& absorption, const bool symmetric, const int threads);
+RcppExport SEXP _samc_build_convolution_cache(SEXP kernelSEXP, SEXP resistanceSEXP, SEXP fidelitySEXP, SEXP absorptionSEXP, SEXP symmetricSEXP, SEXP threadsSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const Rcpp::NumericMatrix& >::type kernel(kernelSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::NumericMatrix& >::type resistance(resistanceSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::NumericMatrix& >::type fidelity(fidelitySEXP);
+    Rcpp::traits::input_parameter< const Rcpp::NumericMatrix& >::type absorption(absorptionSEXP);
+    Rcpp::traits::input_parameter< const bool >::type symmetric(symmetricSEXP);
+    Rcpp::traits::input_parameter< const int >::type threads(threadsSEXP);
+    rcpp_result_gen = Rcpp::wrap(build_convolution_cache(kernel, resistance, fidelity, absorption, symmetric, threads));
+    return rcpp_result_gen;
+END_RCPP
+}
+// get_convolution_list
+Rcpp::List get_convolution_list(const Rcpp::XPtr<convolution_cache>& ca);
+RcppExport SEXP _samc_get_convolution_list(SEXP caSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const Rcpp::XPtr<convolution_cache>& >::type ca(caSEXP);
+    rcpp_result_gen = Rcpp::wrap(get_convolution_list(ca));
+    return rcpp_result_gen;
+END_RCPP
+}
+// convolution_short
+Rcpp::List convolution_short(std::vector<long> steps, const Rcpp::XPtr<convolution_cache>& ca, const Rcpp::NumericVector& pop_in, const int threads);
+RcppExport SEXP _samc_convolution_short(SEXP stepsSEXP, SEXP caSEXP, SEXP pop_inSEXP, SEXP threadsSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< std::vector<long> >::type steps(stepsSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::XPtr<convolution_cache>& >::type ca(caSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type pop_in(pop_inSEXP);
+    Rcpp::traits::input_parameter< const int >::type threads(threadsSEXP);
+    rcpp_result_gen = Rcpp::wrap(convolution_short(steps, ca, pop_in, threads));
+    return rcpp_result_gen;
+END_RCPP
+}
+// convolution_long
+Rcpp::List convolution_long(const Rcpp::XPtr<convolution_cache>& ca, const Rcpp::NumericVector& pop_in, const int threads);
+RcppExport SEXP _samc_convolution_long(SEXP caSEXP, SEXP pop_inSEXP, SEXP threadsSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< const Rcpp::XPtr<convolution_cache>& >::type ca(caSEXP);
+    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type pop_in(pop_inSEXP);
+    Rcpp::traits::input_parameter< const int >::type threads(threadsSEXP);
+    rcpp_result_gen = Rcpp::wrap(convolution_long(ca, pop_in, threads));
+    return rcpp_result_gen;
+END_RCPP
+}
 // sum_qn_q
 Rcpp::List sum_qn_q(const Eigen::Map<Eigen::SparseMatrix<double> >& M, const Eigen::Map<Eigen::SparseMatrix<double> >& M2, const Eigen::VectorXd& q, Rcpp::NumericVector t);
 RcppExport SEXP _samc_sum_qn_q(SEXP MSEXP, SEXP M2SEXP, SEXP qSEXP, SEXP tSEXP) {
@@ -319,6 +373,10 @@ END_RCPP
 static const R_CallMethodDef CallEntries[] = {
     {""_samc_cond_t"", (DL_FUNC) &_samc_cond_t, 2},
     {""_samc_cond_t_iter"", (DL_FUNC) &_samc_cond_t_iter, 2},
+    {""_samc_build_convolution_cache"", (DL_FUNC) &_samc_build_convolution_cache, 6},
+    {""_samc_get_convolution_list"", (DL_FUNC) &_samc_get_convolution_list, 1},
+    {""_samc_convolution_short"", (DL_FUNC) &_samc_convolution_short, 4},
+    {""_samc_convolution_long"", (DL_FUNC) &_samc_convolution_long, 3},
     {""_samc_sum_qn_q"", (DL_FUNC) &_samc_sum_qn_q, 4},
     {""_samc_sum_qn_q_iter"", (DL_FUNC) &_samc_sum_qn_q_iter, 4},
     {""_samc_diagf_par"", (DL_FUNC) &_samc_diagf_par, 2},

---FILE: src/convolution.cpp---
@@ -0,0 +1,311 @@
+// Copyright (c) 2023 Andrew Marx where applicable.
+// Licensed under GPLv3.0. See LICENSE file in the project root for details.
+//
+// Derived from https://github.com/LandSciTech/LSTDConnect/blob/8927cac418454bb7910be8f832dffb9b62b34223/src/samc.cpp
+// Which was licensed under GPLv3.0 at the time of use
+
+#include <Rcpp.h>
+#include ""convolution.h""
+
+// [[Rcpp::depends(RcppThread)]]
+#include <RcppThread.h>
+
+#include <cstddef>
+#include <vector>
+#include <iostream>
+#include <algorithm>
+
+template<bool SYMMETRIC>
+inline void construct_cache(
+    convolution_cache& ca,
+    const std::vector<kernel_point_t>& kernel,
+    const Rcpp::NumericMatrix& resistance,
+    const Rcpp::NumericMatrix& fidelity,
+    const Rcpp::NumericMatrix& absorption,
+    const int threads = 1){
+
+  ca.kernel_size = kernel.size();
+  ca.nrow = resistance.nrow();
+  ca.ncol = resistance.ncol();
+
+  ca.movement_rate.clear();
+  ca.movement_rate.resize(ca.kernel_size*ca.nrow*ca.ncol, {0});
+
+  ca.absorption.assign(absorption.begin(),absorption.end());
+
+  std::ptrdiff_t max_offset = 0;
+  std::ptrdiff_t min_offset = 0;
+
+
+  for(const auto& k_point : kernel){
+    const std::ptrdiff_t offset = k_point.y_off + k_point.x_off*ca.nrow;
+    ca.kernel.push_back(-offset);
+    max_offset = std::max(max_offset, offset);
+    min_offset = std::min(min_offset, offset);
+  }
+
+  ca.left_extra_cols  = std::max((ca.nrow-1-min_offset)/ca.nrow, {0});
+  ca.right_extra_cols = std::max((ca.nrow-1+max_offset)/ca.nrow, {0});
+
+  // TODO can be parallelized, but still very fast without it
+  for(std::size_t x = 0; x<ca.ncol; x++){
+    for(std::size_t y = 0; y<ca.nrow; y++){
+      //Rcpp::Rcout << x << "", "" << y << "", "" << ca.death_rate[y+x*ca.nrow] << ""\n"";
+      //bool printing = x==1 && y==1;
+
+      double weighted_sum = 0;
+
+      for(const auto& k_point : kernel){
+
+        const std::size_t k_x = x+k_point.x_off;
+        const std::size_t k_y = y+k_point.y_off;
+
+        if((k_x >= 0 && k_x < ca.ncol) && (k_y >= 0 && k_y < ca.nrow)){
+          weighted_sum += k_point.num/(resistance[k_y + k_x*ca.nrow]+(SYMMETRIC*resistance[y + x*ca.nrow]));
+          //if(printing) Rcpp::Rcout << ""a:"" << x << "", "" << y << "", "" <<  k_x << "", "" <<  k_y << "", "" <<  resistance[k_y + k_x*ca.nrow] << "", "" <<  k_point.num << ""\n"";
+        }
+      }
+      double t_scalar = 0;
+      double t_fidelity = fidelity[y+x*ca.nrow];
+      const double t_absorption = absorption[y+x*ca.nrow];
+      if(weighted_sum == 0){
+        t_scalar = 0;
+        t_fidelity = 1.0-t_absorption;
+      }else{
+        t_scalar = (1.0-(t_fidelity+t_absorption))/weighted_sum;
+      }
+
+      const double l_scalar     = t_scalar;
+      const double l_fidelity   = t_fidelity;
+
+      //if(printing) Rcpp::Rcout << ""b:"" << weighted_sum << "", "" << l_scalar << "", "" << l_fidelity << "", "" << t_absorption << ""\n"";
+
+      //Rcpp::Rcout << ""("" << x << "","" << y << "","" << scalar << "")\n"";
+      //can be simd
+      for(std::size_t k = 0; k < ca.kernel_size; k++){
+        const auto& k_point = kernel[k];
+        const std::size_t k_x = x+k_point.x_off;
+        const std::size_t k_y = y+k_point.y_off;
+
+        if((k_x >= 0 && k_x < ca.ncol) && (k_y >= 0 && k_y < ca.nrow)){
+          ca.movement_rate[k+(k_y+k_x*ca.nrow)*ca.kernel_size] = (l_scalar * k_point.num)/(resistance[k_y + k_x*ca.nrow]+(SYMMETRIC*resistance[y + x*ca.nrow])) + (k_point.x_off == 0 && k_point.y_off == 0)*l_fidelity;
+
+          //if(printing) Rcpp::Rcout << ""c:"" << k_x << "", "" <<  k_y << "", "" <<  ca.movement_rate[k+(k_y+k_x*ca.nrow)*ca.kernel_size] << ""\n"";
+        }
+        //if no, leave it 0, 0 is the default value anyway
+      }
+
+    }
+  }
+}
+
+// [[Rcpp::export(.build_convolution_cache)]]
+Rcpp::XPtr<convolution_cache> build_convolution_cache(
+    const Rcpp::NumericMatrix& kernel,
+    const Rcpp::NumericMatrix& resistance,
+    const Rcpp::NumericMatrix& fidelity,
+    const Rcpp::NumericMatrix& absorption,
+    const bool symmetric, const int threads = 1){
+
+  std::vector<kernel_point_t> kv{};
+
+  const std::ptrdiff_t k_nrow = kernel.nrow();
+  const std::ptrdiff_t k_ncol = kernel.ncol();
+
+  for(std::ptrdiff_t y=0; y<k_nrow; y++){
+    for(std::ptrdiff_t x=0; x<k_ncol; x++){
+      if(kernel[y+x*k_nrow] || (y-k_nrow/2 == 0 && x-k_ncol/2 == 0)){
+        kv.push_back({y-k_nrow/2, x-k_ncol/2, kernel[y+x*k_nrow]});
+        //Rcpp::Rcout << kernel[y+x*k_nrow] << ""\n"";
+      }
+    }
+  }
+
+  if(kv.size() == 0){kv.push_back({0,0,0.0});}
+
+  convolution_cache* ca = new convolution_cache;
+  if(symmetric){
+    construct_cache<true>(*ca, kv, resistance, fidelity, absorption, threads);
+  }else{
+    construct_cache<false>(*ca, kv, resistance, fidelity, absorption, threads);
+  }
+  Rcpp::XPtr<convolution_cache> xp(ca, true);
+
+  return xp;
+}
+
+
+inline void convolution_one_step(
+    const convolution_cache& ca,
+    const double* const pop_in,
+    const double* const dead_in,
+    double* const pop_out,
+    double* const dead_out,
+    const int threads = 1){
+
+  const double* const p_in = pop_in;// + (ca.nrow * ca.left_extra_cols);
+  const double* const d_in = dead_in;
+
+  double* const p_out = pop_out;// + (ca.nrow * ca.left_extra_cols);
+  double* const d_out = dead_out;
+
+  auto fun = [&] (unsigned int i){
+    //RcppThread::checkUserInterrupt(); // Seems to cause 10-20% increase in runtime. The check per timestep has no noticeable cost instead.
+
+    d_out[i] = d_in[i]+ca.absorption[i]*p_in[i];
+    double acc = 0;
+    for(std::size_t con = 0; con < ca.kernel_size; con++){
+      //Rcpp::Rcout << i << "", "" << i%ca.nrow << "", "" << i/ca.nrow << "", "" << con << "", "" << i*ca.kernel_size+con << "", "" << i+ca.kernel[con] << "", "" << ca.movement_rate[i*ca.kernel_size+con] << '\n';
+      acc += ca.movement_rate[i*ca.kernel_size+con]*p_in[i+ca.kernel[con]];
+    }
+    p_out[i] = acc;
+  };
+
+  RcppThread::parallelFor(0, ca.absorption.size(), fun, threads, threads);
+}
+
+
+// [[Rcpp::export("".get_convolution_list"")]]
+Rcpp::List get_convolution_list(const Rcpp::XPtr<convolution_cache>& ca)
+{
+  const convolution_cache& c = *ca;
+
+  Rcpp::List res = Rcpp::List::create(
+    Rcpp::Named(""ncol"") = c.ncol,
+    Rcpp::Named(""nrow"") = c.nrow,
+    Rcpp::Named(""kernel_size"") = c.kernel_size,
+    Rcpp::Named(""left_extra_cols"") = c.left_extra_cols,
+    Rcpp::Named(""right_extra_cols"") = c.right_extra_cols,
+    Rcpp::Named(""movement_rate"") = c.movement_rate,
+    Rcpp::Named(""absorption"") = c.absorption,
+    Rcpp::Named(""kernel"") = c.kernel
+  );
+
+  return res;
+}
+
+
+// [[Rcpp::export(.convolution_short)]]
+Rcpp::List convolution_short(
+    std::vector<long> steps,
+    const Rcpp::XPtr<convolution_cache>& ca,
+    const Rcpp::NumericVector& pop_in,
+    const int threads = 1){
+
+  std::vector<double> pop_a(ca->nrow*(ca->ncol+ca->left_extra_cols+ca->right_extra_cols), 0.0);
+  std::vector<double> pop_b(ca->nrow*(ca->ncol+ca->left_extra_cols+ca->right_extra_cols), 0.0);
+
+  std::memcpy(&pop_a[ca->nrow*ca->left_extra_cols], &pop_in[0], ca->nrow*ca->ncol*sizeof(double));
+
+  Rcpp::NumericVector dead_in(int(ca->nrow) * int(ca->ncol));
+
+  std::vector<double> dead_b(ca->nrow*ca->ncol, 0.0);
+
+  std::vector<Rcpp::NumericVector> pops{};
+  std::vector<Rcpp::NumericVector> deads{};
+
+  double* const p_a = &pop_a[ca->nrow*ca->left_extra_cols];
+  double* const p_b = &pop_b[ca->nrow*ca->left_extra_cols];
+  double* const d_a = &dead_in[0];
+  double* const d_b = &dead_b[0];
+
+  const double* p_in = p_a;
+  const double* d_in = d_a;
+  double* p_out = p_b;
+  double* d_out = d_b;
+
+  long last_i = 0;
+  for(long i : steps){
+    for(long j=0; j<i-last_i; j++){
+      //step once
+      convolution_one_step(*ca, p_in, d_in, p_out, d_out, threads);
+
+      p_in = p_out;
+      d_in = d_out;
+      if(p_out == p_a){
+        p_out = p_b;
+        d_out = d_b;
+      }else{
+        p_out = p_a;
+        d_out = d_a;
+      }
+    }
+    pops.emplace_back(int(ca->nrow) * int(ca->ncol));
+    deads.emplace_back(int(ca->nrow) * int(ca->ncol));
+
+    std::memcpy(&pops.back()[0], p_in, ca->nrow*ca->ncol*sizeof(double));
+    std::memcpy(&deads.back()[0], d_in, ca->nrow*ca->ncol*sizeof(double));
+  }
+
+  return Rcpp::List::create(Rcpp::Named(""time"") = steps, Rcpp::Named(""dist"") = pops, Rcpp::Named(""mort"") = deads);
+}
+
+
+// [[Rcpp::export(.convolution_long)]]
+Rcpp::List convolution_long(
+    const Rcpp::XPtr<convolution_cache>& ca,
+    const Rcpp::NumericVector& pop_in,
+    const int threads = 1){
+
+  const double total_pop = Rcpp::sum(pop_in);
+  double death_total = 0.0;
+  double EPSILON = total_pop/1000000000.0;
+
+  std::vector<double> pop_a(ca->nrow*(ca->ncol+ca->left_extra_cols+ca->right_extra_cols), 0.0);
+  std::vector<double> pop_b(ca->nrow*(ca->ncol+ca->left_extra_cols+ca->right_extra_cols), 0.0);
+
+  std::memcpy(&pop_a[ca->nrow*ca->left_extra_cols], &pop_in[0], ca->nrow*ca->ncol*sizeof(double));
+
+  Rcpp::NumericVector dead_in(int(ca->nrow) * int(ca->ncol));
+
+  std::vector<double> dead_b(ca->nrow*ca->ncol, 0.0);
+
+  Rcpp::NumericVector pops (int(ca->nrow) * int(ca->ncol));
+  Rcpp::NumericVector deads (int(ca->nrow) * int(ca->ncol));
+
+  double* const p_a = &pop_a[ca->nrow*ca->left_extra_cols];
+  double* const p_b = &pop_b[ca->nrow*ca->left_extra_cols];
+  double* const d_a = &dead_in[0];
+  double* const d_b = &dead_b[0];
+
+  const double* p_in = p_a;
+  const double* d_in = d_a;
+  double* p_out = p_b;
+  double* d_out = d_b;
+
+  std::size_t count = 0;
+  std::size_t count_limit = 1000000;
+
+  do {
+    count++;
+
+    convolution_one_step(*ca, p_in, d_in, p_out, d_out, threads);
+
+    p_in = p_out;
+    d_in = d_out;
+    if(p_out == p_a){
+      p_out = p_b;
+      d_out = d_b;
+    }else{
+      p_out = p_a;
+      d_out = d_a;
+    }
+
+
+    if(count % 100 == 0) {
+      std::memcpy(&deads[0], d_in, ca->nrow*ca->ncol*sizeof(double));
+
+      death_total = Rcpp::sum(deads);
+    }
+
+    Rcpp::checkUserInterrupt();
+  } while(total_pop - death_total > EPSILON & count < count_limit);
+
+  if (count == count_limit) {
+    Rcpp::Rcout << ""\nConvolution iteration limit reached. Results may not be accurate.\n"";
+  }
+
+  std::memcpy(&pops[0], p_in, ca->nrow*ca->ncol*sizeof(double));
+
+  return Rcpp::List::create(Rcpp::Named(""time"") = count, Rcpp::Named(""dist"") = pops, Rcpp::Named(""mort"") = deads);
+}

---FILE: src/convolution.h---
@@ -0,0 +1,30 @@
+// Copyright (c) 2023 Andrew Marx where applicable.
+// Licensed under GPLv3.0. See LICENSE file in the project root for details.
+//
+// Derived from https://github.com/LandSciTech/LSTDConnect/blob/8927cac418454bb7910be8f832dffb9b62b34223/inst/include/samc.h
+// Which was licensed under GPLv3.0 at the time of use
+
+#ifndef __CONVOLUTION_H__
+#define __CONVOLUTION_H__
+
+#include <Rcpp.h>
+
+struct kernel_point_t{
+  std::ptrdiff_t x_off;
+  std::ptrdiff_t y_off;
+  double num = 1;
+};
+
+struct convolution_cache{
+  std::size_t ncol;
+  std::size_t nrow;
+  std::size_t kernel_size;
+  std::size_t left_extra_cols;
+  std::size_t right_extra_cols;
+  std::vector<double> movement_rate;  /* size should be ncol*nrow*kernel_size */
+  std::vector<double> absorption;     /* size should be ncol*nrow or empty*/
+  std::vector<std::ptrdiff_t> kernel; /* a list of offsets from a given point to all of the places that it needs to look in the list of points */
+
+};
+
+#endif /* __CONVOLUTION_H__ */

---FILE: src/samc_types.h---
@@ -2,5 +2,6 @@
 #define SAMC_TYPES_H
 
 #include ""solver-cache.h""
+#include ""convolution.h""
 
 #endif"
andrewmarx,samc,6a51a7b9c6c487e3808697bfece88ca7c089680b,Andrew Marx,andrewjmarx@gmail.com,2023-03-06T17:57:23Z,Andrew Marx,andrewjmarx@gmail.com,2023-03-06T17:57:23Z,crw fixes,R/internal-functions.R;R/visitation.R,False,True,True,False,2,1,3,"---FILE: R/internal-functions.R---
@@ -628,6 +628,7 @@ setMethod(
 
   if (!(""name"" %in% names)) {
     x$name = ""RW""
+    names = c(names, ""name"")
   }
 
   if (x$name == ""CRW"") {

---FILE: R/visitation.R---
@@ -309,7 +309,7 @@ setMethod(
   ""visitation"",
   signature(samc = ""samc"", init = ""missing"", origin = ""missing"", dest = ""location"", time = ""missing""),
   function(samc, dest){
-    if (is.matrix(origin)) {
+    if (is.matrix(dest)) {
 
     } else {
       if (length(dest) != 1)"
andrewmarx,samc,cc0dec61bd40bf64629b230e9a35df47a4e41062,Andrew Marx,andrewjmarx@gmail.com,2023-03-04T21:52:08Z,Andrew Marx,andrewjmarx@gmail.com,2023-03-04T21:52:08Z,Fix rw() performance,R/internal-functions.R,False,True,True,False,10,4,14,"---FILE: R/internal-functions.R---
@@ -15,6 +15,10 @@
 
   rs = Matrix::rowSums(tr)
 
+  tr_i = tr@i
+  tr_p = tr@p
+  tr_x = tr@x
+
   tmp = 1 - terra::values(absorption) - terra::values(fidelity)
 
 
@@ -25,22 +29,24 @@
 
   i_index = 1
   for (p in 1:ncells) {
-    row_count = tr@p[p+1] - tr@p[p]
+    row_count = tr_p[p+1] - tr_p[p]
     for (i in 1:row_count) {
-      row = tr@i[i_index] + 1
+      row = tr_i[i_index] + 1
       if (p != row) {
         #mat_x[i_index] = i_index # useful for validation
         #mat_x[i_index] = cell_nums[row] # useful for validation
         #print(c(p, row))
         #assign(""ts"", list(mat_p, mat_i), envir = globalenv())
-        tr@x[i_index] = -tr@x[i_index]/rs[row] * tmp[cell_nums[row]]
+        tr_x[i_index] = -tr_x[i_index]/rs[row] * tmp[cell_nums[row]]
       } else {
-        tr@x[i_index] = 1 - fidelity[cell_nums[row]]
+        tr_x[i_index] = 1 - fidelity[cell_nums[row]]
       }
       i_index = i_index + 1
     }
   }
 
+  tr@x = tr_x
+
   tr
 }
 "
andrewmarx,samc,a55a3ead34725f0a8da660cc138373ae88cf2315,Andrew Marx,andrewjmarx@gmail.com,2023-03-04T20:56:51Z,Andrew Marx,andrewjmarx@gmail.com,2023-03-04T20:56:51Z,Fix and cleanup for last commit,R/internal-functions.R,False,True,True,False,5,8,13,"---FILE: R/internal-functions.R---
@@ -179,7 +179,6 @@
   # mat_x
   # mat_i
 
-  # TODO This matrix is only used for rowSums and is recreated later for perf reasons. Clean up with manual row sum calc.
   mat = new(""dgCMatrix"")
   mat@Dim = c(as.integer(sum(edge_counts)), as.integer(sum(edge_counts)))
 
@@ -196,6 +195,8 @@
   tmp = 1 - terra::values(absorption) - fidelity
   rs = Matrix::rowSums(mat)
 
+  crw_lookup = as.vector(crw_map[,1])
+
   i_index = 1
   for (p in 1:sum(edge_counts)) {
     row_count = mat_p[p+1] - mat_p[p]
@@ -207,19 +208,15 @@
         #print(c(p, row))
         #assign(""ts"", list(mat_p, mat_i), envir = globalenv())
 
-        mat_x[i_index] = 0#-mat@x[i_index]/rs[row] * tmp[cell_nums[crw_map[,1][row]]]
+        mat_x[i_index] = -mat_x[i_index]/rs[row] * tmp[cell_nums[crw_lookup[row]]]
       } else {
-        mat_x[i_index] =  0#1 - fidelity[cell_nums[crw_map[,1][row]]]
+        mat_x[i_index] =  1 - fidelity[cell_nums[crw_lookup[row]]]
       }
       i_index = i_index + 1
     }
   }
 
-  mat = new(""dgCMatrix"")
-  mat@Dim = c(as.integer(sum(edge_counts)), as.integer(sum(edge_counts)))
-
-  mat@p = mat_p
-  mat@i = as.integer(mat_i - 1)
+  # For perf reasons
   mat@x = mat_x
 
   return("
andrewmarx,samc,eceed7bf07cbfc9c2fa8744c417c7344969ba63c,Andrew Marx,andrewjmarx@gmail.com,2023-03-02T02:31:51Z,Andrew Marx,andrewjmarx@gmail.com,2023-03-02T02:31:51Z,fix,R/samc.R,False,True,True,False,1,1,2,"---FILE: R/samc.R---
@@ -223,7 +223,7 @@ setMethod(
       gc()
 
       samc_obj@data@t_abs = crw_list$abs
-      samc_obj@crw_map = crw_list$map
+      samc_obj@crw_map = crw_list$crw
 
     } else {
       stop(""Unexpected error involving model name. Please report with a minimum reproducible example."", call. = FALSE)"
andrewmarx,samc,b424bee1e07feead2a94c4fd0e6d5f2ea2685507,Andrew Marx,andrewjmarx@gmail.com,2023-03-02T02:31:42Z,Andrew Marx,andrewjmarx@gmail.com,2023-03-02T02:31:42Z,fix model validation,R/internal-functions.R,False,True,True,False,1,1,2,"---FILE: R/internal-functions.R---
@@ -560,7 +560,7 @@ setMethod(
 #' @param x A list
 #' @noRd
 .validate_model <- function(x) {
-  args <- c(""fun"", ""dir"", ""sym"")
+  args <- c(""name"", ""fun"", ""dir"", ""sym"")
   names <- names(x)
 
   dup_args <- names[duplicated(names)]"
andrewmarx,samc,66a89ecdd1a8bcacf9f5afa65424d88c9d885076,Andrew Marx,andrewjmarx@gmail.com,2023-03-01T18:21:39Z,Andrew Marx,andrewjmarx@gmail.com,2023-03-01T18:21:39Z,crw fixes and return,R/internal-functions.R,False,True,True,False,6,5,11,"---FILE: R/internal-functions.R---
@@ -138,7 +138,7 @@
 
             e1i = row_offsets[p1] + p2i - 1
 
-            mat_x[index] = tr[p2, p3] * dvonmises(circular(0), mu = circular(0), kappa = model$dist$kappa)
+            mat_x[index] = tr[p2, p3] * circular::dvonmises(circular::circular(0), mu = circular::circular(0), kappa = model$dist$kappa)
             mat_i[index] = e1i
           } else {
             mat_x[index] = 0 #fidelity[cell_nums[p1]]
@@ -157,7 +157,6 @@
   # mat_p
   # mat_x
   # mat_i
-
   {
     mat = new(""dgCMatrix"")
     mat@Dim = c(as.integer(sum(edge_counts)), as.integer(sum(edge_counts)))
@@ -172,6 +171,7 @@
 
   # normalization
 
+  fidelity = terra::values(fidelity)
   tmp = 1 - terra::values(absorption) - fidelity
   rs = Matrix::rowSums(mat)
 
@@ -185,6 +185,7 @@
         #mat_x[i_index] = cell_nums[row] # useful for validation
         #print(c(p, row))
         #assign(""ts"", list(mat_p, mat_i), envir = globalenv())
+
         mat@x[i_index] = -mat@x[i_index]/rs[row] * tmp[cell_nums[crw_map[,1][row]]]
       } else {
         mat@x[i_index] =  1 - fidelity[cell_nums[crw_map[,1][row]]]
@@ -195,9 +196,9 @@
 
 
   return(
-    list(tr = NA,
-         map = NA,
-         abs = NA)
+    list(tr = mat,
+         map = crw_map,
+         abs = terra::values(absorption)[cell_nums[crw_map[,1]]])
   )
 }
 "
andrewmarx,samc,443f3d50c12a543cf64ae20ffb7c8f364142f355,Andrew Marx,andrewjmarx@gmail.com,2023-02-20T15:48:18Z,Andrew Marx,andrewjmarx@gmail.com,2023-02-20T15:48:18Z,Small bug fix,R/internal-functions.R,False,True,True,False,2,2,4,"---FILE: R/internal-functions.R---
@@ -253,8 +253,8 @@
   # TODO Create tests to directly validate results for both directions options for planar and latlon
 
   lonlat = terra::is.lonlat(rast)
-  nrows = terra::nrow(x)
-  ncols = terra::ncol(x)
+  nrows = terra::nrow(rast)
+  ncols = terra::ncol(rast)
 
   if (dir == 4) {
     dist_lookup = c(1, 1, 1, 1)"
andrewmarx,samc,19e3877159204b3afbf47e649972512e171830a8,Andrew Marx,andrewjmarx@gmail.com,2023-02-16T20:26:03Z,Andrew Marx,andrewjmarx@gmail.com,2023-02-16T20:26:03Z,Fix .rw() call,R/internal-functions.R;R/samc.R,False,True,True,False,2,2,4,"---FILE: R/internal-functions.R---
@@ -11,7 +11,7 @@
 #'
 #' @noRd
 .rw <- function(x, absorption, fidelity, fun, dir, sym) {
-  .transition(data, absorption, fidelity, tr_fun, directions, sym)
+  .transition(x, absorption, fidelity, fun, dir, sym)
 }
 
 #' CRW function

---FILE: R/samc.R---
@@ -201,7 +201,7 @@ setMethod(
 
     # Create the transition matrix
     if (model$name == ""RW"") {
-      samc_obj@data@f = rw(data, absorption, fidelity, tr_fun, directions, symm)
+      samc_obj@data@f = .rw(data, absorption, fidelity, tr_fun, directions, symm)
       gc()
 
       samc_obj@data@t_abs = as.vector(terra::values(absorption))[terra::cells(absorption)]"
andrewmarx,samc,66d476f299eb5e7e355ef289394cd4d1e1d56aa9,Andrew Marx,andrewjmarx@gmail.com,2023-01-31T17:15:06Z,Andrew Marx,andrewjmarx@gmail.com,2023-01-31T17:15:06Z,"Fixes for CRAN

Update CITATION file and bump C++ version",DESCRIPTION;inst/CITATION;src/Makevars.win,False,False,False,False,11,10,21,"---FILE: DESCRIPTION---
@@ -1,7 +1,7 @@
 Package: samc
 Type: Package
 Title: Spatial Absorbing Markov Chains
-Version: 3.0.0
+Version: 3.0.1
 Authors@R: c(
     person(""Andrew"", ""Marx"", , ""ajm.rpackages@gmail.com"", role = c(""aut"", ""cre"", ""cph""), 
       comment = c(ORCID = ""0000-0002-7456-1631"")

---FILE: inst/CITATION---
@@ -1,16 +1,17 @@
-citHeader(""To cite samc in publications use:"")
+citation(auto = meta)
 
-citEntry(
-  entry    = ""Article"",
+bibentry(
+  bibtype  = ""Article"",
   title    = ""samc: an R package for connectivity modeling with spatial absorbing Markov chains"",
-  author   = ""Marx, Andrew J. and Wang, Chao and Sefair, Jorge A. and Acevedo, Miguel A. and Fletcher Jr., Robert J."",
+  author   = c(person(c(""Andrew"", ""J.""), ""Marx""),
+               person(c(""Chao""), ""Wang""),
+               person(c(""Jorge"", ""A.""), ""Sefair""),
+               person(c(""Miguel"", ""A.""), ""Acevedo""),
+               person(c(""Robert"", ""J.""), ""Fletcher Jr."")),
   journal  = ""Ecography"",
   year     = ""2020"",
   volume   = ""43"",
   number   = ""4"",
   pages    = ""518-527"",
-  url      = ""https://onlinelibrary.wiley.com/doi/abs/10.1111/ecog.04891"",
-  textVersion = paste(
-
-  )
+  url      = ""https://onlinelibrary.wiley.com/doi/abs/10.1111/ecog.04891""
 )

---FILE: src/Makevars.win---
@@ -4,4 +4,4 @@
 
 ## With R 3.1.0 or later, you can uncomment the following line to tell R to
 ## enable compilation with C++11 (or even C++14) where available
-CXX_STD = CXX14
+CXX_STD = CXX17"
andrewmarx,samc,8a34e0a88ce30e1600fc67e1697097e5990e78f8,Andrew Marx,andrewjmarx@gmail.com,2023-01-31T04:01:34Z,Andrew Marx,andrewjmarx@gmail.com,2023-01-31T04:01:34Z,"visitiation(samc, init) fix",R/visitation.R,False,True,True,False,2,2,4,"---FILE: R/visitation.R---
@@ -353,9 +353,9 @@ setMethod(
     pv <- .process_init(samc, init)
 
     if (samc@solver == ""iter"") {
-      r <- .psif_iter(samc@data@f, origin)
+      r <- .psif_iter(samc@data@f, pv)
     } else {
-      r <- .psif(samc@data@f, origin, samc@.cache$sc)
+      r <- .psif(samc@data@f, pv, samc@.cache$sc)
     }
 
     return(as.vector(r))"
andrewmarx,samc,00c9897b58c4b2a57014dc8b4c79fdb3087ce353,Andrew Marx,andrewjmarx@gmail.com,2023-01-31T04:00:51Z,Andrew Marx,andrewjmarx@gmail.com,2023-01-31T04:01:16Z,fixes for CHECK,R/internal-functions.R;R/visitation.R,False,True,True,False,2,1,3,"---FILE: R/internal-functions.R---
@@ -12,7 +12,7 @@
 #' @param data A SpatRaster
 #' @noRd
 .transition <- function(x, absorption, fidelity, fun, dir, sym = TRUE) {
-  if (class(fun) == ""character"") {
+  if (is(fun, ""character"")) {
     stop(""Named transition functions not supported"", call. = FALSE)
   }
 

---FILE: R/visitation.R---
@@ -130,6 +130,7 @@ NULL
 #' @template param-init
 #' @template param-origin
 #' @template param-dest
+#' @template param-time
 #'
 #' @return See Details
 #'"
andrewmarx,samc,8c58beaa699dae88e99238353ade2a9375f39518,Andrew Marx,andrewjmarx@gmail.com,2023-01-30T17:48:37Z,Andrew Marx,andrewjmarx@gmail.com,2023-01-30T17:48:37Z,Short-term visitation() fixes,R/visitation.R,False,True,True,False,2,2,4,"---FILE: R/visitation.R---
@@ -158,7 +158,7 @@ setMethod(
 
     q <- as.matrix(samc$q_matrix)
     q2 = base::diag(nrow(q))
-    res <- matrix(0, nrow(q), ncol(q))
+    res <- q2
 
     for (i in 1:(time-1)) {
       q2 = q2 %*% q
@@ -209,7 +209,7 @@ setMethod(
 
     time = c(1, time)
 
-    ft = .sum_qpow_row(q, origin, time)
+    ft = .sum_qpow_col(q, dest, time)
 
     if (length(ft) == 1) {
       return(ft[[1]])"
andrewmarx,samc,e55c58c8bc731817c385af3c2a314ce055b21eac,Andrew Marx,andrewjmarx@gmail.com,2023-01-30T13:50:44Z,Andrew Marx,andrewjmarx@gmail.com,2023-01-30T13:50:44Z,index page fix,index.md,False,False,False,False,1,0,1,"---FILE: index.md---
@@ -38,6 +38,7 @@ This is a list of publications where the samc package was applied to a research
 ### **Version 3**
 
 Version 3 of the package made some minor breaking changes:
+
 - The `samc()` function no longer supports `TransitionLayer` inputs. This only had a niche use case, but before v3 wasn't an issue to include because of other dependencies on gdistance. With v3, this became the only dependency left for gdistance, so it was removed to avoid potential future issues should gdistance ever get removed from CRAN (which nearly happened in 2022).
 - With the addition of terra support, the `map()` function was updated so that its output matches the input type to `samc()`. Previously, matrix inputs were matched to RasterLayers, but now they are mapped back to matrices.
 - `cond_passage()` and `visitation()` had an `occ` argument inserted to match the usage of other metrics. These arguments are unused as of v3.0.0 but may be implemented in the future."
andrewmarx,samc,1a370cb4c7e9af65583e73924d9866c443cf5c0e,Andrew Marx,andrewjmarx@gmail.com,2023-01-30T13:50:03Z,Andrew Marx,andrewjmarx@gmail.com,2023-01-30T13:50:03Z,"Update overview vignette

Add and update equations

Minor fixes/tweaks",vignettes/overview.Rmd,True,False,True,False,14,11,25,"---FILE: vignettes/overview.Rmd---
@@ -53,8 +53,8 @@ The `samc-class` is used to manage the $P$ matrix and other information to help
 
 The first option is to use a map of resistance (or conductance) and a map of total absorption with a list of transition arguments to calculate the transition probabilities between cells in the maps. There are certain requirements for these maps:
 
-* They must be 2-dimensional matrices, `RasterLayer`, or `SpatRaster` objects. They have to be the same type.
-* They must have the same dimensions (number of rows and columns).
+* They must be 2-dimensional matrices, `RasterLayer`, or `SpatRaster` objects. These different types cannot be mixed.
+* All inputs must have the same dimensions (number of rows and columns).
 * `NA` is allowed in the cells, but must match between the sets of data. I.e., if cell `[3, 6]` of the *resistance* data has a `NA` value, then cell `[3, 6]` of the *absorption* data must also have a `NA` value and vice versa.
 
 If using `SpatRaster` or `RasterLayer` objects, then additional conditions must be met:
@@ -66,7 +66,7 @@ An optional fidelity map may be provided. This map would represent the probabili
 
 #### Option 2: P Matrix
 
-The Third option for using this package is to directly supply a $P$ matrix. The $P$ matrix can be provided either as a regular matrix or a `dgCmatrix`, which is a sparse matrix object available through the Matrix package. The $R$ portion of the $P$ matrix must be a single column that represents the total absorption probability for each transient state.
+The second option for using this package is to directly supply a $P$ matrix. The $P$ matrix can be provided either as a regular matrix or a `dgCmatrix`, which is a sparse matrix object available through the Matrix package. The $R$ portion of the $P$ matrix must be a single column that represents the total absorption probability for each transient state.
 
 The advantage of this approach is total flexibility. The disadvantage is that the $P$ matrix can be created with certain properties that would lead to crashes, and the package is unable to detect all of them at this time. The other disadvantage is that the package cannot map the results back to anything for visualization purposes.
 
@@ -93,21 +93,24 @@ The package implements functions for the formulas provided in Table 1 of Fletche
 | Function | Equation | Description |
 |:---------|:---------|:------------|
 | `absorption()` | $A = F R$ | Probability of an individual experiencing a specific type of mortality |
-| | $\psi^T A$ | Probability of an individual experiencing a specific type of mortality, regardless of initial location |
+| | $\psi^T A$ | Probability of an individual experiencing a specific type of mortality, given an initial state $\psi$ |
 | `cond_passage()` | $\tilde{t} = \tilde{B}_j^{-1}\tilde{F}\tilde{B}_j{\cdot}1$ | Mean first conditional passage time |
 | `dispersal()` | $\tilde{D}_{jt}=({\sum}_{n=0}^{t-1}\tilde{Q}^n)\tilde{q}_j$ | Probability of an individual visiting a location, if starting at any other location, before or at time *t* |
-| | $\psi^T\tilde{D}_{jt}$ | Probability of an individual visiting a location, before or at time *t*, regardless of initial location |
+| | $\psi^T\tilde{D}_{jt}$ | Probability of an individual visiting a location, before or at time *t*, given an initial state $\psi$ |
 | | $D=(F-I)diag(F)^{-1}$ | Probability of an individual visiting a location |
-| | $\psi^TD$ | Probability of an individual visiting a location, regardless of initial location |
+| | $\psi^TD$ | Probability of an individual visiting a location, given an initial state $\psi$ |
 | `distribution()` | $Q^t$   | Probability of an individual being at a location at time *t* |
-| | $\psi^TQ^t$ | Probability of an individual being at a location at time *t*, regardless of initial location |
+| | $\psi^TQ^t$ | Probability of an individual being at a location at time *t*, given an initial state $\psi$ |
 | `mortality()` | $\tilde{B}_t = (\sum_{n=0}^{t-1} Q^n) \tilde{R}$ | Probability of an individual experiencing mortality at a location before or at time *t* |
-| | $\psi^T \tilde{B}_t$ | Probability of an individual experiencing mortality at a location, before or at time *t*, regardless of initial location |
+| | $\psi^T \tilde{B}_t$ | Probability of an individual experiencing mortality at a location, before or at time *t*, given an initial state $\psi$ |
 | | $B = F \tilde{R}$ | Probability of an individual experiencing mortality at a location |
-| | $\psi^T B$ | Probability of an individual experiencing mortality at a location, regardless of initial location |
+| | $\psi^T B$ | Probability of an individual experiencing mortality at a location, given an initial state $\psi$ |
 | `survival()` | $z=(I-Q)^{-1}{\cdot}1=F{\cdot}1$ | Expected life expectancy of an individual |
-| | ${\psi}^Tz$ | Overall life expectancy, regardless of initial location |
-| `visitation()` | $F = (I-Q)^{-1}$ | Expected number of times an individual visits a location |
+| | ${\psi}^Tz$ | Overall life expectancy, given an initial state $\psi$ |
+| `visitation()` | $\tilde{F}_t = \sum_{n=0}^{t-1} Q^n$ | Expected number of times an individual visits a location before or at time *t* |
+| | ${\psi}^T \tilde{F}_t$ | Expected number of times an individual visits a location before or at time *t*, given an initial state $\psi$ |
+| | $F = (I-Q)^{-1}$ | Expected number of times an individual visits a location |
+| | ${\psi}^T F$ | Expected number of times an individual visits a location, given an initial state $\psi$ |
 
 
 Depending on the combination of inputs used, a function might return a single value, a vector, a matrix, or a list. In some cases, the calculations will be impractical with sufficiently large landscape datasets due to memory and other performance constraints. To work around this, many equations have multiple associated function signatures that allow users to calculate individual portions of the result rather than the entire result. This opens up multiple optimizations that make calculating many of the metrics more practical. More specific details about performance considerations can be found in the [Performance](performance.html) vignette."
andrewmarx,samc,4b757fb94a795ec88089b1020038e6cfe4dd2228,Andrew Marx,andrewjmarx@gmail.com,2023-01-26T05:04:38Z,Andrew Marx,andrewjmarx@gmail.com,2023-01-26T05:04:38Z,Various fixes for CHECK,NAMESPACE;R/internal-functions.R;R/samc-class.R;inst/examples/locate.R,False,True,True,False,9,6,15,"---FILE: NAMESPACE---
@@ -4,4 +4,5 @@ importClassesFrom(""Matrix"", ""dgCMatrix"")
 importClassesFrom(""raster"", ""RasterLayer"")
 importClassesFrom(""terra"", ""SpatRaster"")
 importFrom(""methods"", ""as"")
+importFrom(""methods"", ""new"")
 exportPattern(""^[[:alpha:]]+"")

---FILE: R/internal-functions.R---
@@ -110,13 +110,14 @@
     if (lonlat) {
       cn = (0:(nrow(absorption) - 1))*ncol(absorption) + 1
 
-      adj = adjacent(absorption, cn, directions = 8, pairs = TRUE)
+      adj = terra::adjacent(absorption, cn, directions = 8, pairs = TRUE)
 
-      dist = distance(xyFromCell(absorption, adj[, 1]),
-                      xyFromCell(absorption, adj[, 2]),
-                      lonlat = TRUE, pairwise = TRUE)
+      dist = terra::distance(
+        terra::xyFromCell(absorption, adj[, 1]),
+        terra::xyFromCell(absorption, adj[, 2]),
+        lonlat = TRUE, pairwise = TRUE)
 
-      adj = adjacent(absorption, cn, directions = dir, pairs = FALSE)
+      adj = terra::adjacent(absorption, cn, directions = dir, pairs = FALSE)
       adj = t(adj)
 
       dist_lookup = adj

---FILE: R/samc-class.R---
@@ -80,6 +80,7 @@ NULL
 #' @slot data Data associated with different components of the P matrix
 #' @slot source Information about the data source for the P matrix
 #' @slot map Used to verify landscape inputs and mapping of vector data
+#' @slot names Names of the transient states
 #' @slot clumps Number of discontinuous regions in data
 #' @slot override Used to prevent accidental use of memory intensive functions
 #' @slot solver Controls the linear solver used for relevant metrics

---FILE: inst/examples/locate.R---
@@ -1,5 +1,5 @@
+library(terra)
 library(samc)
-library(raster)
 
 
 # Load example data"
andrewmarx,samc,61a80af198e4e1944ea649f5a1dc85e5e0b5a74a,Andrew Marx,andrewjmarx@gmail.com,2023-01-26T04:43:10Z,Andrew Marx,andrewjmarx@gmail.com,2023-01-26T04:43:10Z,locate() fix (again),R/locate.R,False,True,True,False,2,1,3,"---FILE: R/locate.R---
@@ -74,7 +74,8 @@ setMethod(
   function(samc, xy){
     if (samc@source == ""transition"") stop(""This function cannot be used when the samc-object was created from a transition matrix"", call. = FALSE)
 
-    result <- terra::extract(samc@map, xy)[, 1] # TODO figure out why column of 2 wasn't triggering errors in test
+    result = terra::extract(samc@map, xy)
+    result = result[, ncol(result)] # TODO can it be more robust for different types of inputs (currently handles matrices and data frames for xy having different results)
 
     if (anyNA(result)) stop(""One or more coordinates do not correspond to non-NA cells."", call. = FALSE)
 "
andrewmarx,samc,4615ab3062707431bc4fb0910e9aa85f954ad0cf,Andrew Marx,andrewjmarx@gmail.com,2023-01-26T01:34:28Z,Andrew Marx,andrewjmarx@gmail.com,2023-01-26T01:34:28Z,Vignette fixes and workarounds for CHECK,vignettes/article-circuit-theory.Rmd;vignettes/scripts/example-maze.R;vignettes/scripts/tutorial-ggplot.R;vignettes/tutorial-basic.Rmd;vignettes/tutorial-locations.Rmd;vignettes/tutorial-multiple-absorption.Rmd,True,False,True,False,28,26,54,"---FILE: vignettes/article-circuit-theory.Rmd---
@@ -45,9 +45,10 @@ Both SAMC and circuit theory use Markov chain theory to model movement based on
 This section is for loading the packages and creating objects used in the examples. The resistance data has two low-resistance routes between the source and destinations. The absorption data has no background absorption, but does have a narrow strip of strong absorption that runs across most of the map, but not across the left route. This is the same example data used in the IALE workshop, where the absorption data was used to describe a hypothetical highway with a safe crossing area for the left route.
 
 ```{r}
-library(""samc"")
+library(""terra"")
 library(""raster"")
 library(""gdistance"")
+library(""samc"")
 library(""viridisLite"")
 
 # Create a landscape with two paths around an obstacle
@@ -67,8 +68,8 @@ abs_data = res_data * 0 # Create a baseline mortality or absorption level. To ex
 abs_data[6, c(1, 4:10)] = 0.1 # Create a ""highway"" with high absorption and a safe crossing point
 abs_data[is.na(res_data)] = NA
 
-res_data = raster(res_data, xmn = 0.5, xmx = ncol(res_data) + 0.5, ymn = 0.5, ymx = nrow(res_data) + 0.5)
-abs_data = raster(abs_data, xmn = 0.5, xmx = ncol(abs_data) + 0.5, ymn = 0.5, ymx = nrow(abs_data) + 0.5)
+res_data = samc::rasterize(res_data)
+abs_data = samc::rasterize(abs_data)
 
 plot(res_data, main = ""Example Resistance Data"", xlab = ""x"", ylab = ""y"", col = viridis(256))
 plot(abs_data, main = ""Example Absorption Data"", xlab = ""x"", ylab = ""y"", col = viridis(256))
@@ -83,7 +84,7 @@ dest_coords = matrix(c(9, 9), ncol = 2)
 origin_cell = locate(samc_obj, origin_coords)
 dest_cell = locate(samc_obj, dest_coords)
 
-gdist = transition(res_data, model$fun, model$dir)
+gdist = transition(raster::raster(res_data), rw_model$fun, rw_model$dir)
 gdist = geoCorrection(gdist)
 ```
 
@@ -114,8 +115,8 @@ plot(abs_data_j, main = ""Destination Absorption Map"", col = viridis(256))
 
 ```{r}
 # Create samc objects for each direction
-samc_ij = samc(res_data, abs_data_j, model = model)
-samc_ji = samc(res_data, abs_data_i, model = model)
+samc_ij = samc(res_data, abs_data_j, model = rw_model)
+samc_ji = samc(res_data, abs_data_i, model = rw_model)
 
 # Calculate commute distance with samc
 hitting_ij = survival(samc_ij, abs_data_i) # Reusing the other abs layer as an occupancy input
@@ -138,8 +139,8 @@ The second and more flexible approach in SAMC is the `cond_passage()` function,
 `cond_passage()` can be used in the same way described for the `survival()` metric previously, in which case an equivalent result to commute distance from circuit theory will be obtained. Unlike the `survival()` function, the result of `cond_passage()` does not include the extra absorption time step; it only calculates the time to reach the destination.
 
 ```{r}
-hitting_ij_cp = cond_passage(samc_ij, origin_cell, dest_cell)
-hitting_ji_cp = cond_passage(samc_ji, dest_cell, origin_cell)
+hitting_ij_cp = cond_passage(samc_ij, origin = origin_cell, dest = dest_cell)
+hitting_ji_cp = cond_passage(samc_ji, origin = dest_cell, dest = origin_cell)
 
 hitting_ij_cp
 hitting_ji_cp
@@ -150,8 +151,8 @@ More importantly, this is just a special case where we demonstrate the relations
 
 ```{r}
 # Calculate hitting times and commute distance for the original absorption data
-reg_hitting_ij = cond_passage(samc_obj, origin_cell, dest_cell)
-reg_hitting_ji = cond_passage(samc_obj, dest_cell, origin_cell)
+reg_hitting_ij = cond_passage(samc_obj, origin = origin_cell, dest = dest_cell)
+reg_hitting_ji = cond_passage(samc_obj, origin = dest_cell, dest = origin_cell)
 
 reg_hitting_ij
 reg_hitting_ji
@@ -176,7 +177,7 @@ total_gdist = passage(gdist, origin_coords, dest_coords, theta = 0, totalNet = ""
 plot(total_gdist, main = ""Total Movement Flow (gdistance)"", col = viridis(256))
 
 # Equivalent total movement flow with SAMC
-total_samc = visitation(samc_ij, origin_cell)
+total_samc = visitation(samc_ij, origin = origin_cell)
 total_samc_ras = map(samc_ij, total_samc)
 plot(total_samc_ras, main = ""Total Movement Flow (samc)"", col = viridis(256))
 
@@ -189,6 +190,7 @@ With the total movement result and the $Q$ matrix from SAMC, it is possible to c
 ```{r}
 # Net movement flow with gdistance
 net_gdist = passage(gdist, origin_coords, dest_coords, theta = 0, totalNet = ""net"")
+net_gdist = rast(net_gdist)
 plot(net_gdist, main = ""Net Movement Flow (gdistance)"", col = viridis(256))
 
 
@@ -207,7 +209,7 @@ visitation_net <- function(samc_obj, origin, dest){
 }
 
 # Equivalent net movement flow with SAMC
-net_samc = visitation_net(samc_ij, origin_cell, dest_cell)
+net_samc = visitation_net(samc_ij, origin = origin_cell, dest = dest_cell)
 net_samc_ras = map(samc_obj, net_samc)
 plot(net_samc_ras,  main = ""Net Movement Flow (samc)"", col = viridis(256))
 

---FILE: vignettes/scripts/example-maze.R---
@@ -16,8 +16,8 @@
 ## @knitr 1_library_1
 library(raster)
 library(terra)
-library(samc)
 library(gdistance)
+library(samc)
 library(viridisLite)
 
 
@@ -62,7 +62,7 @@ maze_res = matrix(
   nrow = 20, byrow = TRUE
 )
 
-maze_res <- rasterize(maze_res)
+maze_res <- samc::rasterize(maze_res)
 maze_res[maze_res==0] <- NA # 0 makes the formatting cleaner above, but NA is needed for true barriers
 
 # Get info about the shortest path through the maze using gdistance
@@ -72,7 +72,7 @@ lcd <- (function() {
   tr <- transition(raster(maze_res), function(x) 1/mean(x), 4)
   tr <- geoCorrection(tr)
 
-  list(dist = costDistance(tr, points),
+  list(dist = gdistance::costDistance(tr, points),
        path = shortestPath(tr, points[1, ], points[2, ], output=""SpatialLines""))
 })()
 
@@ -425,7 +425,7 @@ lcd2 <- (function() {
   tr <- transition(raster(short_res), function(x) 1/mean(x), 4)
   tr <- geoCorrection(tr)
 
-  list(dist = costDistance(tr, points),
+  list(dist = gdistance::costDistance(tr, points),
        path = shortestPath(tr, points[1, ], points[2, ], output=""SpatialLines""))
 })()
 

---FILE: vignettes/scripts/tutorial-ggplot.R---
@@ -18,9 +18,9 @@ abs_data <- samc::ex_abs_data
 occ_data <- samc::ex_occ_data
 
 # To make things easier for plotting later, convert the matrices to rasters
-res_data <- rasterize(res_data)
-abs_data <- rasterize(abs_data)
-occ_data <- rasterize(occ_data)
+res_data <- samc::rasterize(res_data)
+abs_data <- samc::rasterize(abs_data)
+occ_data <- samc::rasterize(occ_data)
 
 
 # Setup the details for our transition function

---FILE: vignettes/tutorial-basic.Rmd---
@@ -48,9 +48,9 @@ abs_data <- samc::ex_abs_data
 occ_data <- samc::ex_occ_data
 
 # To make things easier for plotting later, convert the matrices to rasters
-res_data <- rasterize(res_data)
-abs_data <- rasterize(abs_data)
-occ_data <- rasterize(occ_data)
+res_data <- samc::rasterize(res_data)
+abs_data <- samc::rasterize(abs_data)
+occ_data <- samc::rasterize(occ_data)
 
 
 # Plot the data and make sure it looks good. The built-in data is in matrices, 

---FILE: vignettes/tutorial-locations.Rmd---
@@ -88,7 +88,7 @@ mort_dest[7]
 locations_map <- locate(samc_obj)
 
 # Convert to a raster for visualization purposes
-locations_map = rasterize(locations_map)
+locations_map = samc::rasterize(locations_map)
 
 
 # Plot it. since the location values increase incrementally from left to right and

---FILE: vignettes/tutorial-multiple-absorption.Rmd---
@@ -47,9 +47,9 @@ abs_data <- samc::ex_abs_data
 occ_data <- samc::ex_occ_data
 
 # To make things easier for plotting later, convert the matrices to rasters
-res_data <- rasterize(res_data)
-abs_data <- rasterize(abs_data)
-occ_data <- rasterize(occ_data)
+res_data <- samc::rasterize(res_data)
+abs_data <- samc::rasterize(abs_data)
+occ_data <- samc::rasterize(occ_data)
 
 # Generate some random values that will be used as proportions for dividing the
 # absorption data."
andrewmarx,samc,692a4ddeabaa42680e3889975db2420ff8b3f585,Andrew Marx,andrewjmarx@gmail.com,2023-01-26T01:34:00Z,Andrew Marx,andrewjmarx@gmail.com,2023-01-26T01:34:00Z,locate() fix,R/locate.R,False,True,True,False,1,1,2,"---FILE: R/locate.R---
@@ -74,7 +74,7 @@ setMethod(
   function(samc, xy){
     if (samc@source == ""transition"") stop(""This function cannot be used when the samc-object was created from a transition matrix"", call. = FALSE)
 
-    result <- terra::extract(samc@map, xy)[, 2]
+    result <- terra::extract(samc@map, xy)[, 1] # TODO figure out why column of 2 wasn't triggering errors in test
 
     if (anyNA(result)) stop(""One or more coordinates do not correspond to non-NA cells."", call. = FALSE)
 "
andrewmarx,samc,bc24150ca00a11737b357eb9d5dc52c86af50eeb,Andrew Marx,andrewjmarx@gmail.com,2023-01-26T01:25:50Z,Andrew Marx,andrewjmarx@gmail.com,2023-01-26T01:25:50Z,Fix planar geocorrection,R/internal-functions.R,False,True,True,False,1,3,4,"---FILE: R/internal-functions.R---
@@ -98,9 +98,7 @@
   if (dir == 4) {
     dist_lookup = c(1, 1, 1, 1)
   } else if (dir == 8) {
-    dist_lookup = c(sqrt(2), 1, sqrt(2), 1, sqrt(2), 1, sqrt(2), 1)
-  } else {
-    stop(""Bad dir in dist lookup code"", call. = FALSE)
+    dist_lookup = c(sqrt(2), 1, sqrt(2), 1, 1, sqrt(2), 1, sqrt(2))
   }
 
   dist = function(x, dir) {"
andrewmarx,samc,2b39b76357141233128204eebd1e7c141f9d238d,Andrew Marx,andrewjmarx@gmail.com,2023-01-22T19:50:42Z,Andrew Marx,andrewjmarx@gmail.com,2023-01-22T19:50:42Z,"Make test matrices non-square

Potentially capture some row/col count errors",tests/testthat/helper-data.R,False,True,True,False,1,9,10,"---FILE: tests/testthat/helper-data.R---
@@ -9,7 +9,6 @@ baselist <- list(
                   1,  1,  1,  3, 10, 10,  3,  1,  1,
                   1,  1,  1,  1,  1,  1,  1,  1,  1,
                   1,  1,  1,  1,  1,  1,  1,  1,  1,
-                  1,  1,  1,  1,  1,  1,  1,  1,  1,
                   1,  1, 10, 10, 10, 10, 10, 10,  1,
                   1,  1,  1,  1,  1,  1,  1,  1,  1),
                 nrow = 9),
@@ -19,7 +18,6 @@ baselist <- list(
                   1,  1,  1,  1,  1,  1,  1,  1,  1,
                   1,  5,  1,  1,  1,  1,  1,  0,  0,
                   1,  1,  1,  1,  1,  1,  1,  1,  0,
-                  1,  1,  1,  1,  1,  1,  1,  1,  0,
                   1,  1,  1,  2,  1,  1,  1,  7,  7,
                   3,  1,  1,  1,  1,  1,  1,  1,  1),
                 nrow = 9) / 1000,
@@ -30,7 +28,6 @@ baselist <- list(
                  10, 10, 10, 10, 10, 10, 50, 50, 50,
                  10, 10, 10, 10, 10, 10, 50, 50, 50,
                  10, 10, 10, 10, 10, 10, 10, 10, 10,
-                 10, 10, 10, 10, 10, 10, 10, 10, 10,
                  10, 10, 10, 10, 10, 10, 10, 10, 10),
                 nrow = 9) / 100,
   occ = matrix(c( 0,  0,  0,  0,  0,  0,  0,  0,  0,
@@ -39,7 +36,6 @@ baselist <- list(
                   0,  1,  1,  0,  0,  0,  0,  0,  0,
                   0,  1,  1,  0,  0,  0,  0,  0,  0,
                   0,  1,  1,  0,  0,  0,  0,  0,  0,
-                  0,  1,  1,  0,  0,  0,  0,  0,  0,
                   0,  0,  0,  0,  0,  0,  0,  0,  0,
                   0,  0,  0,  0,  0,  0,  0,  0,  0),
                 nrow = 9)
@@ -55,7 +51,6 @@ masklist <- list(
                     1,  1,  1,  1,  1,  1,  1,  1,  1,
                     1,  1,  1,  1,  1,  1,  1,  1,  1,
                     1,  1,  1,  1,  1,  1,  1,  1,  1,
-                    1,  1,  1,  1,  1,  1,  1,  1,  1,
                     1,  1,  1,  1,  1,  1,  1,  1,  1),
                   nrow = 9),
   mask2 = matrix(c( 1,  1,  1,  1,  1,  1,  1,  1,  1,
@@ -65,7 +60,6 @@ masklist <- list(
                     1,  1,  1, NA, NA, NA, NA,  1,  1,
                     1,  1,  1, NA, NA, NA, NA,  1,  1,
                     1,  1,  1, NA, NA, NA, NA,  1,  1,
-                    1,  1,  1,  1,  1,  1,  1,  1,  1,
                     1,  1,  1,  1,  1,  1,  1,  1,  1),
                   nrow = 9),
   mask3 = matrix(c( 1,  1,  1,  1,  1,  1,  1,  1,  1,
@@ -74,7 +68,6 @@ masklist <- list(
                     1,  1,  1,  1,  1,  1,  1,  1,  1,
                     1,  1,  1,  1,  1,  1,  1,  1,  1,
                    NA, NA, NA, NA, NA, NA, NA, NA, NA,
-                    1,  1,  1,  1,  1,  1,  1,  1,  1,
                     1,  1,  1,  1,  1,  1,  1,  1,  1,
                     1,  1,  1,  1,  1,  1,  1,  1,  1),
                   nrow = 9),
@@ -85,12 +78,11 @@ masklist <- list(
                     1, NA, NA, NA,  1,  1,  1,  1,  1,
                     1, NA,  1, NA,  1,  1,  1,  1,  1,
                     1, NA, NA, NA,  1,  1,  1,  1,  1,
-                    1,  1,  1,  1,  1,  1,  1,  1,  1,
                     1,  1,  1,  1,  1,  1,  1,  1,  1),
                   nrow = 9)
 )
 
-p1 <- runif(81, max = 0.4)
+p1 <- runif(72, max = 0.4)
 p2 <- 1 - p1
 
 testlist <- list()"
andrewmarx,samc,15b5d0f8be2b07b77c187f7d4662ca80ea9c0e2a,Andrew Marx,andrewjmarx@gmail.com,2023-01-18T19:43:50Z,Andrew Marx,andrewjmarx@gmail.com,2023-01-18T19:43:50Z,Workaround for arith issue in terra,R/internal-functions.R,False,True,True,False,1,1,2,"---FILE: R/internal-functions.R---
@@ -189,7 +189,7 @@
     mat_p[i+1] = row_count
   }
 
-  tmp = terra::values(1 - absorption) - fidelity
+  tmp = 1 - terra::values(absorption) - fidelity
 
   i_index = 1
   for (p in 1:ncells) {"
andrewmarx,samc,56da87ab9c15cff662167ae1499fe18d115b3440,Andrew Marx,andrewjmarx@gmail.com,2022-12-17T21:56:47Z,Andrew Marx,andrewjmarx@gmail.com,2022-12-17T21:56:47Z,cache class fixes,src/solver-cache.cpp;src/solver-cache.h,False,False,False,False,3,3,6,"---FILE: src/solver-cache.cpp---
@@ -10,11 +10,11 @@
 Rcpp::XPtr<SolverCache> solver_cache()
 {
   SolverCache* sc = new SolverCache();
-  Rcpp::XPtr<SolverCache> ptr(sc);
+  Rcpp::XPtr<SolverCache> ptr(sc, true);
   return ptr;
 }
 
-void SolverCache::buildSolver(Eigen::SparseMatrix<double> &M, const std::string& fun)
+void SolverCache::buildSolver(const Eigen::SparseMatrix<double> &M, const std::string &fun)
 {
   if (name != fun)
   {

---FILE: src/solver-cache.h---
@@ -18,7 +18,7 @@ class SolverCache {
 
 public:
   SolverCache() { name = """"; }
-  void buildSolver(Eigen::SparseMatrix<double> &M, const std::string& fun);
+  void buildSolver(const Eigen::SparseMatrix<double> &M, const std::string& fun);
   Solver& solver() { return m_solver; }
 };
 "
andrewmarx,samc,de8735f107ced51f1afe91a8d589e7fa4e30997d,Andrew Marx,andrewjmarx@gmail.com,2022-12-16T18:46:57Z,Andrew Marx,andrewjmarx@gmail.com,2022-12-16T18:46:57Z,fix param in internal function,R/internal-functions.R,False,True,True,False,1,1,2,"---FILE: R/internal-functions.R---
@@ -496,7 +496,7 @@ setMethod(
 #' @noRd
 setMethod(
   "".process_occ"",
-  signature(samc = ""samc"", x = ""Raster""),
+  signature(samc = ""samc"", x = ""RasterLayer""),
   function(samc, x) {
     return(.process_occ(samc, rasterize(x)))
   })"
andrewmarx,samc,f34b44c16877806b2ee097b59a860160a3362953,Andrew Marx,andrewjmarx@gmail.com,2022-12-16T03:50:39Z,Andrew Marx,andrewjmarx@gmail.com,2022-12-16T03:50:39Z,Remove internal samc_raster class and fix doc for char_null class,R/internal-classes.R;R/internal-functions.R,False,True,True,False,13,6,19,"---FILE: R/internal-classes.R---
@@ -33,12 +33,11 @@ setClass(
 )
 
 
-#' samc raster class
+#' samc char_null class
 #'
-#' Class for grouping different raster types under one parameter
+#' Class for grouping character and NULL data types
 #'
-#' @name samc_raster-class
+#' @name char_null-class
 #' @keywords internal
-
-setClassUnion(""samc_raster"", c(""RasterLayer"", ""SpatRaster""))
+#'
 setClassUnion(""char_null"", c(""character"", ""NULL""))

---FILE: R/internal-functions.R---
@@ -385,7 +385,7 @@ setGeneric(
 #' @noRd
 setMethod(
   "".process_abs_states"",
-  signature(samc = ""samc"", x = ""samc_raster""),
+  signature(samc = ""samc"", x = ""SpatRaster""),
   function(samc, x) {
 
     x = rasterize(x)
@@ -429,6 +429,14 @@ setMethod(
     return(.process_abs_states(samc, terra::rast(x)))
   })
 
+setMethod(
+  "".process_abs_states"",
+  signature(samc = ""samc"", x = ""RasterLayer""),
+  function(samc, x) {
+
+    return(.process_abs_states(samc, terra::rast(x)))
+  })
+
 setMethod(
   "".process_abs_states"",
   signature(samc = ""samc"", x = ""list""),"
andrewmarx,samc,8653270cdcd7e5f51b0a53c7c67ca9a055bc2268,Andrew Marx,andrewjmarx@gmail.com,2022-12-06T17:10:18Z,Andrew Marx,andrewjmarx@gmail.com,2022-12-06T17:10:18Z,Fix missed parameter type,R/samc.R,False,True,True,False,3,3,6,"---FILE: R/samc.R---
@@ -119,9 +119,9 @@ setGeneric(
 #' @rdname samc
 setMethod(
   ""samc"",
-  signature(data = ""samc_raster"",
-            absorption = ""samc_raster"",
-            fidelity = ""samc_raster"",
+  signature(data = ""SpatRaster"",
+            absorption = ""SpatRaster"",
+            fidelity = ""SpatRaster"",
             tr_args = ""list""),
   function(data, absorption, fidelity, tr_args) {
     .validate_tr_args(tr_args)"
andrewmarx,samc,b906c4e86be911d7a46f9d83012c3653885b94ad,Andrew Marx,andrewjmarx@gmail.com,2022-11-30T21:07:11Z,Andrew Marx,andrewjmarx@gmail.com,2022-11-30T21:07:11Z,Fix handling of NA from is.lonlat(),R/internal-functions.R,False,True,True,False,19,9,28,"---FILE: R/internal-functions.R---
@@ -93,15 +93,22 @@
 
   row_count = 0L
 
-  if (lonlat) {
-    warning(""geocorrection for latlon not implemented"", call. = FALSE)
-    dist <- function(x, dir) {
-      1 # TODO update
-
-      # Get raster first column cell numbers
-      # Get adjacent cell numbers
-      # Convert to xy coords
-      # Get dist
+  if(!is.na(lonlat)) {
+    if (lonlat) {
+      warning(""geocorrection for latlon not implemented"", call. = FALSE)
+      dist <- function(x, dir) {
+        1 # TODO update
+
+        # Get raster first column cell numbers
+        # Get adjacent cell numbers
+        # Convert to xy coords
+        # Get dist
+      }
+    } else {
+      dist_lookup = c(sqrt(2), 1, sqrt(2), 1, sqrt(2), 1, sqrt(2), 1)
+      dist = function(x, dir) {
+        dist_lookup[dir]
+      }
     }
   } else {
     dist_lookup = c(sqrt(2), 1, sqrt(2), 1, sqrt(2), 1, sqrt(2), 1)
@@ -110,6 +117,9 @@
     }
   }
 
+
+
+
   nc = nrows
   nr = ncols
 "
andrewmarx,samc,11c325d10491ea140bda932013dc66e67b378103,Andrew Marx,andrewjmarx@gmail.com,2022-11-25T21:58:02Z,Andrew Marx,andrewjmarx@gmail.com,2022-11-25T21:58:02Z,Fix deprecated Matrix package code,R/samc.R,False,True,True,False,4,4,8,"---FILE: R/samc.R---
@@ -204,7 +204,7 @@ setMethod(
     }
 
     # Old approach
-    tr_mat <- methods::as(tr_mat, ""dgTMatrix"") # dgTMatrix is easier to edit directly
+    tr_mat <- methods::as(methods::as(methods::as(tr_mat, ""dMatrix""), ""generalMatrix""), ""TsparseMatrix"") # dgTMatrix is easier to edit directly
     tr_mat@x <- (1 - abs_vec[tr_mat@i + 1] - fid_vec[tr_mat@i + 1]) * tr_mat@x / Matrix::rowSums(tr_mat)[tr_mat@i + 1]
 
     # New approach that causes crash during one of the dispersal() tests
@@ -223,7 +223,7 @@ setMethod(
       abs_vec <- abs_vec[-excl]
     }
 
-    tr_mat <- methods::as(tr_mat, ""dgCMatrix"")
+    tr_mat <- methods::as(methods::as(tr_mat, ""CsparseMatrix""), ""generalMatrix"")
 
     tr_mat@x = -tr_mat@x
     Matrix::diag(tr_mat) <- Matrix::diag(tr_mat) + 1
@@ -449,7 +449,7 @@ setMethod(
     if (!isTRUE(all.equal(Matrix::rowSums(data), rep(1, r), check.names = FALSE))) stop(""All row sums must be equal to 1"", call. = FALSE) # Use all.equal() to avoid numerical precision issues
 
 
-    q_mat <- methods::as(data[-r, -c], ""dgCMatrix"")
+    q_mat <- methods::as(methods::as(data[-r, -c], ""CsparseMatrix""), ""generalMatrix"")
     abs_total <- data[-r, c]
 
     if (!isTRUE(all.equal(Matrix::rowSums(q_mat) + abs_total, rep(1, length(abs_total)), check.names = FALSE))) stop(""All row sums must be equal to 1"", call. = FALSE) # Use all.equal() to avoid numerical precision issues
@@ -496,7 +496,7 @@ setMethod(
             fidelity = ""missing"",
             tr_args = ""missing""),
   function(data) {
-    p <- methods::as(data, ""dgCMatrix"")
+    p <- methods::as(methods::as(data, ""CsparseMatrix""), ""generalMatrix"")
 
     return(samc(data = p))
   })"
andrewmarx,samc,c13a2ad3ff5ee486cc24ce3246e7ad507a7e9671,Andrew Marx,andrewjmarx@gmail.com,2022-10-18T18:02:13Z,Andrew Marx,andrewjmarx@gmail.com,2022-10-18T18:02:13Z,"Update cond_passage test code to fix errors/warnings

Creation of samc object from P matrix under new name system was not
transferring cell names. Copy manually until fixed.",tests/testthat/test-cond_passage.R,False,True,True,False,3,0,3,"---FILE: tests/testthat/test-cond_passage.R---
@@ -41,6 +41,9 @@ for(test in testlist) {
 
   # Create a version from P matrix
   samc_p <- samc(samc_obj$p_matrix)
+  samc_p$names = samc_obj$names # TODO: remove when names code updated for this scenario
+  samc_p@clumps = samc_obj@clumps # TODO: remove when creation of samc object from P matrix calculates clumps
+
 
   # Run the tests
   test_that(paste(""Testing cond_passage(samc, dest):"", test_num), {"
andrewmarx,samc,e7e71d966b82c63cd0136e39f29c1a19f2a70474,Andrew Marx,andrewjmarx@gmail.com,2022-10-18T18:00:11Z,Andrew Marx,andrewjmarx@gmail.com,2022-10-18T18:00:11Z,Add iteration outputs for troubleshooting test errors,tests/testthat/test-cond_passage.R,False,True,True,False,5,2,7,"---FILE: tests/testthat/test-cond_passage.R---
@@ -29,7 +29,10 @@ br_function <- function(samc, col) {
   return(as.numeric(res))
 }
 
+test_num = 0
 for(test in testlist) {
+  test_num = test_num + 1
+
   # TODO cond_passage does not work in all cases yet. Remove this when it does
   if (!(test$id %in% c(1, 2))) next
 
@@ -40,7 +43,7 @@ for(test in testlist) {
   samc_p <- samc(samc_obj$p_matrix)
 
   # Run the tests
-  test_that(""Testing cond_passage(samc, dest)"", {
+  test_that(paste(""Testing cond_passage(samc, dest):"", test_num), {
 
     base_result <- br_function(samc_obj, col_vec[1])
 
@@ -56,7 +59,7 @@ for(test in testlist) {
     expect_equal(r1, r2)
   })
 
-  test_that(""Testing cond_passage(samc, origin, dest)"", {
+  test_that(paste(""Testing cond_passage(samc, origin, dest)"", test_num), {
 
     vector_result <- cond_passage(samc_p, row_vec, col_vec)
     vector_result_char <- cond_passage(samc_p, as.character(row_vec), as.character(col_vec))"
andrewmarx,samc,66e082f26b5298712cdd528856cc55c11841dfd4,Andrew Marx,andrewjmarx@gmail.com,2022-10-18T14:37:34Z,Andrew Marx,andrewjmarx@gmail.com,2022-10-18T14:37:34Z,Fix terra clump calculation,R/samc.R,False,True,True,False,1,1,2,"---FILE: R/samc.R---
@@ -338,7 +338,7 @@ setMethod(
 
 
     # Check for ""clumps""
-    cl = terra::patches(samc_obj@map, directions = directions, allowGaps = FALSE)
+    cl = terra::patches(samc_obj@map, directions = directions, zeroAsNA = TRUE, allowGaps = FALSE)
     samc_obj@clumps = sum(!is.na(terra::unique(cl)[, 1]))
 
     if (samc_obj@clumps > 1) {"
andrewmarx,samc,b37108ca3de399ac2bcfaef0ca9bcc5ee2c220f6,Andrew Marx,andrewjmarx@gmail.com,2022-10-18T02:11:01Z,Andrew Marx,andrewjmarx@gmail.com,2022-10-18T02:11:01Z,Fix: adjust for NAs in samc() for SpatRaster,R/internal-functions.R,False,True,True,False,6,0,6,"---FILE: R/internal-functions.R---
@@ -89,6 +89,12 @@
   j = c(j, cell_nums)
   transition.values = c(transition.values, as.vector(terra::values(fidelity))[cell_nums])
 
+
+  # Adjust for NAs
+  i = match(i, cell_nums)
+  j = match(j, cell_nums)
+
+
   transitionMatrix = Matrix::sparseMatrix(i = i, j = j, x = transition.values)
 
   return(transitionMatrix)"
andrewmarx,samc,786736062eea04653c8d2594396bbc75fc989539,Andrew Marx,andrewjmarx@gmail.com,2022-10-18T00:03:32Z,Andrew Marx,andrewjmarx@gmail.com,2022-10-18T00:03:32Z,Fix absorption check in samc(),R/samc.R,False,True,True,False,1,1,2,"---FILE: R/samc.R---
@@ -318,7 +318,7 @@ setMethod(
 
     if (abs_minmax[""min"", 1] < 0 || abs_minmax[""max"", 1] > 1) {
       stop(""Absorption values must be in range of 0-1"", call. = FALSE)
-    } else if (abs_minmax[""min"", 1] == 0) {
+    } else if (abs_minmax[""max"", 1] == 0) {
       stop(""At least one cell must have an absorption value > 0"", call. = FALSE)
     }
 "
andrewmarx,samc,983b6969eae556e01172b716d21cb696d5f44569,Andrew Marx,andrewjmarx@gmail.com,2022-10-17T23:58:52Z,Andrew Marx,andrewjmarx@gmail.com,2022-10-17T23:58:52Z,Fix check() for SpatRaster,R/check.R,False,True,True,False,5,18,23,"---FILE: R/check.R---
@@ -111,29 +111,16 @@ setMethod(
     inf_counts = numeric(n)
     nan_counts = numeric(n)
 
-    for (r in terra::nrow(a)) {
+    for (r in 1:terra::nrow(a)) {
       data = terra::values(a, row = r, nrows = 1)
-      inf_counts = inf_counts + colSums(is.infinite(data))
-      nan_counts = nan_counts + colSums(is.nan(data))
 
-      data = is.finite(data)
+      if (any(is.infinite(data))) stop(""Data contains Inf or -Inf"", call. = FALSE)
+      if (any(is.nan(data))) stop(""Data contains Inf or -Inf"", call. = FALSE)
 
-      if (length(unique(rowSums(data))) != 1) {
-        break
-      }
-    }
-
-    if (any(inf_counts > 0)) {
-      msg = paste(inf_counts, collapse="", "")
-      stop(paste(""Data contains Inf or -Inf element in layers:"", msg), call. = FALSE)
-    } else if (any(nan_counts > 0)) {
-      msg = paste(inf_counts, collapse="", "")
-      stop(paste(""Data contains NaN elements in layers:"", msg), call. = FALSE)
+      data = rowSums(is.finite(data))
+      if (any(data > 0 & data < n)) stop(""NA mismatch in input data"", call. = FALSE)
     }
 
-    if (length(unique(rowSums(data))) != 1) {
-      stop(""NA mismatch in input data"", call. = FALSE)
-    }
 
     return(TRUE)
   })"
andrewmarx,samc,478f7f4f126fcbaecbae408f2f97a4579d8de14e,Andrew Marx,andrewjmarx@gmail.com,2022-09-24T21:50:40Z,Andrew Marx,andrewjmarx@gmail.com,2022-09-24T21:50:40Z,"Fix/improve .transition() function

Appears to now work in full for 4 directions",R/internal-functions.R,False,True,True,False,35,22,57,"---FILE: R/internal-functions.R---
@@ -24,48 +24,61 @@
 
   cell_nums = terra::cells(resistance)
   adj = terra::adjacent(resistance, cells=cell_nums, pairs=TRUE, directions=dir)
+  adj = adj[adj[, 2] %in% cell_nums, ]
+
+  adj_length = nrow(adj)
 
   if(sym) adj = adj[adj[,1] < adj[,2],]
 
-  adj = adj[adj[, 2] %in% cell_nums, ]
+  i = adj[,1]
+  j = adj[,2]
 
-  cell_nums = unique(adj[, 1])
+  sums = numeric(max(adj))
 
   res = as.vector(terra::values(resistance))
-  fid = as.vector(terra::values(fidelity))
-  abs = as.vector(terra::values(absorption))
 
-  transition.values = numeric(nrow(adj))
+  adj[] = res[adj]
+  rm(res);gc()
 
-  #for (i in 1:nrow(adj)) {
-  #  transition.values[i] = fun(res[as.vector(adj[i, ])])
-  #}
+  transition.values = numeric(adj_length)
 
-  for (i in cell_nums) {
-    indices = which(adj[, 1] == i)
+  if (sym) {
+    adj_length = nrow(adj)
+    for (k in 1:adj_length) {
+      transition.values[c(k, k + adj_length)] = fun(adj[k, ])
 
-    sub_adj = adj[indices, , drop = FALSE]
-    sub_adj[] = res[sub_adj]
+      sums[i[k]] = sums[i[k]] + transition.values[k]
+      sums[j[k]] = sums[j[k]] + transition.values[k]
+    }
 
-    results = apply(sub_adj, 1, fun)
-    results = (1 - abs[i] - fid[i]) * results / sum(results)
+    tmp = i
+    i = c(i, j)
+    j = c(j, tmp)
+  } else {
+    for (k in 1:nrow(adj)) {
+      transition.values[k] = fun(adj[k, ])
 
-    transition.values[indices] = results
+      sums[i[k]] = sums[i[k]] + transition.values[k]
+    }
   }
 
-  rm(res, fid, abs)
-  gc()
+  rm(adj);gc()
+
+  tmp = as.vector(terra::values(1 - absorption - fidelity))
+
+  transition.values = tmp[i] * transition.values / sums[i]
+
+  rm(tmp, sums); gc()
 
   if(!all(transition.values >= 0)){
     warning(""transition function gives negative values"")
   }
 
-  i = adj[,1]
-  j = adj[,2]
-  rm(adj)
-  gc()
+  i = c(i, cell_nums)
+  j = c(j, cell_nums)
+  transition.values = c(transition.values, as.vector(terra::values(fidelity))[cell_nums])
 
-  transitionMatrix = Matrix::sparseMatrix(i = i, j = j, x = transition.values, symmetric = sym)
+  transitionMatrix = Matrix::sparseMatrix(i = i, j = j, x = transition.values)
 
   return(transitionMatrix)
 }"
andrewmarx,samc,43dfdda6af30896d2a03bb2d933e795c43410e24,Andrew Marx,andrewjmarx@gmail.com,2022-09-19T22:20:23Z,Andrew Marx,andrewjmarx@gmail.com,2022-09-19T22:20:23Z,Fix values check for SpatRaster,R/check.R,False,True,True,False,1,1,2,"---FILE: R/check.R---
@@ -140,7 +140,7 @@ setMethod(
           }
         )
 
-        if (!all.equal(values(r1), is.finite(values(r2)))) {
+        if (!all.equal(terra::values(r1, mat = FALSE), terra::values(r2, mat = FALSE))) {
           stop(""NA mismatch in input data"", call. = FALSE)
         }
       }"
andrewmarx,samc,16852aaa48446e9b03163ab3b9c8e962e642a404,Andrew Marx,andrewjmarx@gmail.com,2022-09-12T16:43:57Z,Andrew Marx,andrewjmarx@gmail.com,2022-09-12T16:43:57Z,Minor typo fix,vignettes/tutorial-locations.Rmd,True,False,True,False,2,2,4,"---FILE: vignettes/tutorial-locations.Rmd---
@@ -32,7 +32,7 @@ The second approach is to refer to locations by the row/column names of the *P*
 ## Setup
 
 ```{r, message = FALSE}
-# First step is to load the libraries. Not all of these libraries are stricly
+# First step is to load the libraries. Not all of these libraries are strictly
 # needed; some are used for convenience and visualization for this tutorial.
 library(""samc"")
 library(""raster"")
@@ -52,7 +52,7 @@ tr <- list(fun = function(x) 1/mean(x), # Function for calculating transition pr
            sym = TRUE) # Is the function symmetric?
 
 # Create a samc object using the resistance and absorption data. We use the
-# recipricol of the arithmetic mean for calculating the transition matrix. Note,
+# reciprical of the arithmetic mean for calculating the transition matrix. Note,
 # the input data here are matrices, not RasterLayers.
 samc_obj <- samc(res_data, abs_data, tr_args = tr)
 ```"
andrewmarx,samc,d2e20ddc6954cb4d5f14fb729c090c61ce707d1f,Andrew Marx,andrewjmarx@gmail.com,2022-06-06T20:10:17Z,Andrew Marx,andrewjmarx@gmail.com,2022-06-06T20:10:17Z,Coin flip vignette typo fix,vignettes/example-coinflip.Rmd,True,False,True,False,1,1,2,"---FILE: vignettes/example-coinflip.Rmd---
@@ -89,7 +89,7 @@ For the original question, it's possible to collapse some of these states and si
 Could be simplified even further
 -->
 
-# Metrics
+## Metrics
 
 To answer the original question of how many coin flips it will take, on average, to see $HTH$, all we need to do is calculate the expected time to absorption. With the samc package, that is accomplished using the `survival()` function.
 ```{r}"
andrewmarx,samc,8ccedb2e277f8ed6c6fa3b2a2866313f9523805d,Andrew Marx,andrewjmarx@gmail.com,2022-06-03T18:10:02Z,Andrew Marx,andrewjmarx@gmail.com,2022-06-03T18:10:02Z,Example maze script typo fix,vignettes/scripts/example-maze.R,False,True,True,False,1,1,2,"---FILE: vignettes/scripts/example-maze.R---
@@ -190,7 +190,7 @@ maze_occ3[1, 1] <- 1
 maze_occ3[20, 1] <- 1
 maze_occ3[1, 20] <- 1
 
-plot_maze(maze_occ, ""Occupancy"", vir_col)
+plot_maze(maze_occ3, ""Occupancy"", vir_col)
 
 survival(maze_samc, occ = maze_occ3)
 "
andrewmarx,samc,259b6dc1c389a1c57020717ae1fc5e644b063712,Andrew Marx,andrewjmarx@gmail.com,2021-11-18T18:42:18Z,Andrew Marx,andrewjmarx@gmail.com,2021-11-18T18:42:18Z,"Update maze example part 3 with editorial changes

Also fix a couple missing code chunks",vignettes/example-maze-part3.Rmd,True,False,True,False,26,22,48,"---FILE: vignettes/example-maze-part3.Rmd---
@@ -34,26 +34,28 @@ do.call(knitr::read_chunk, list(path = ""scripts/example-maze.R""))
 <<survive>>
 
 <<maze_ints>>
+<<samc_ints>>
 <<maze_ends>>
+<<samc_ends>>
 <<maze_traps>>
+<<samc_traps>>
 <<mort_traps>>
 ```
 
 
 ## Introduction
 
-In the third part of the series, we take our perfect maze with only a single solution and modify it so that it now has more than one solution. We then take all of the changes introduced in the series and combine them into a single complex example.
+The third part of the series takes the perfect maze with only a single solution and modifies it so that it now has more than one solution. Afterwards, all of the changes introduced in the series are combined into a single complex example.
 
 
 ## Setup
 
-This example reuses the [libraries](example-maze-part1.html#libraries1), [setup](example-maze-part1.html#setup1), and original [samc object](example-maze-part1.html#create-the-samc-object-1) code from Part 1. Later, we will reuse the various modifications introduced in [Part 2](example-maze-part2.html).
+Part 3 reuses the code from [Part 1](example-maze-part2.html) and [Part 2](example-maze-part2.html).
 
 
 ## Shortcut
 
-We will start with modifying our maze so that it has a new cell bridging previously existing cells. The location was chosen so that it effectively acts as a shortcut to the previous solution. To make things interesting, we will model it as a secret passage by giving it a high resistance value so that it is only rarely utilized. This is effectively the same method used to model dead end avoidance in Part 2, but here the interpretation is different because of where the high resistance is located.
-
+To start, the original maze will be modified so that it has a new cell bridging previously existing cells. The location was chosen so that it effectively acts as a shortcut to the previous solution. To make things more interesting, it will be treated as a secret passage by giving it a high resistance value so that it is only rarely utilized. This is effectively the same method used to model dead end avoidance in Part 2, but here the interpretation is different because of where the high resistance is located.
 ```{r, fig.show='hold', fig.width=7, fig.height=5, fig.align='center'}
 # Create a copy and add a shortcut
 maze2 <- maze
@@ -74,36 +76,38 @@ maze_plot(maze2, ""Maze 2"", vir_col)
 lines(lcd2$path, col = vir_col[2], lw = 3)
 ```
 
-Let's quickly verify the change in distance for the shortest solution:
-
+Use `gdistance` to quickly verify the change in distance for the shortest solution:
 ```{r}
 # Let's see what the difference in distance is
 lcd2$dist - lcd$dist
 ```
 
-Create a new samc object:
+Since the structure of the resistance input has changed, the absorption input also has to be changed so that it has the same structure:
 ```{r}
 # Our old absorption layer does not quite match our new resistance layer, so make a new one
 maze2_finish <- maze2 * 0
 maze2_finish[20, 20] <- 1
+```
 
+With new resistance and absorption inputs, the samc object has to be recreated:
+```{r}
 samc_maze2 <- samc(maze2, maze2_finish, tr_args = tr)
 
 # Important: we have to rerun locate()
 start_maze2 <- locate(samc_maze2, data.frame(x = 1, y = 20))
 finish_maze2 <- locate(samc_maze2, data.frame(x = 20, y = 1))
 ```
 
-An important thing to keep in mind: we modified where `NA` and non-`NA` cells are located in the map. This means that previous results from `locate()` are no longer guaranteed to be valid. In this case, `start` is technically the same, but `finish` actually is not and will return incorrect results, or in special cases cause a crash.
+An important thing to keep in mind: modifying where `NA` and non-`NA` cells are located in the map means that previous results from `locate()` are no longer guaranteed to be valid. In this case, `start` is technically the same, but `finish` is not and will return incorrect results, or in special cases even lead to a crash.
 
-With that, we can begin exploring the different metric and compare them to the results from Part 1. Let's start with `survival()`:
+With that, lets begin exploring the different metrics and compare them to the results from Part 1. Starting with `survival()`:
 ```{r, fig.show='hold', fig.width=7, fig.height=5, fig.align='center'}
 surv_maze2 <- survival(samc_maze2)
 
 maze_plot(map(samc_maze2, surv_maze2), ""Expected time to finish (Maze 2)"", viridis(256))
 ```
 
-There are two noticeable changes. First, the expected time to finish is drastically decreased for our starting point:
+There are two noticeable changes. First, the expected time to finish is drastically decreased for the starting point:
 ```{r}
 # Expected time to finish from the start
 surv_maze2[start]
@@ -112,36 +116,35 @@ surv_maze2[start]
 surv_maze2[start] - survive[start]
 ```
 
-The second change is the overall increase in expected time to finish when the individual is in the bottom left region of the maze because the shortcut can actually lead them away from the finish point when they are in this region. If the shortcut was asymmetric (i.e., one way), we would still see a drastic decrease in the time to finish for the starting point, but then the bottom left region would remain unchanged from our original example. This type of model setup is possible with the package, but not without directly providing the P matrix. Graph support in the future will make more complex scenarios like a one-way shortcut easier to setup.
+The second change is the overall increase in expected time to finish when an individual is in the bottom left region of the maze because the shortcut can actually lead them away from the finish point when they are in this region. If the shortcut was asymmetric (i.e., one way), there would still be a drastic decrease in the time to finish for the starting point, but then the bottom left region would remain unchanged from the original maze. This type of model setup is possible with the package, but not without directly providing the P matrix. Graph support in the future will make more complex scenarios like a one-way shortcut easier to setup.
 
-In Part 2, we saw that the inclusion of additional absorbing states changed the relationship between `survival()` and `cond_passage()`. Since we're back to a single absorbing state at the finish point, this relationship is restored:
+Part 2 showed that the inclusion of additional absorbing states changes the relationship between `survival()` and `cond_passage()`. Since this example is back to a single absorbing state at the finish point, this relationship is restored:
 ```{r}
 cond_maze2 <- cond_passage(samc_maze2, dest = finish_maze2)
 cond_maze2[start]
 ```
 
-In Part 2, we also saw that including additional absorbing states affected the probability of cells being visited. Modifying the maze to have multiple routes also has significant ramifications:
+Part 2 also showed that including additional absorbing states affects the probability of cells being visited. Modifying the maze to have multiple routes also has significant ramifications:
 ```{r, fig.show='hold', fig.width=7, fig.height=5, fig.align='center'}
 disp_maze2 <- dispersal(samc_maze2, origin = start_maze2)
 
 maze_plot(map(samc_maze2, disp_maze2), ""Probability of Visit (Maze 2)"", viridis(256))
 ```
 
-Notably, we again can no longer easily discern the optimal route through the maze by looking for cells with a probability of 1. But we can still get a partial path like Part 2:
+Notably, it is again no longer possible to discern the optimal route through the maze by looking for cells with a probability of `1.0`. But, like Part 2, a partial path can still be can still be identified:
 ```{r, fig.show='hold', fig.width=7, fig.height=5, fig.align='center'}
 # Ideally, we would just use `as.numeric(disp == 1)`, but we have floating point precision issues here, so we will approximate it
 disp_maze2_sol <- as.numeric(abs(disp_maze2 - 1) < tolerance)
 
 maze_plot(map(samc_maze2, disp_maze2_sol), ""Partial solution (Maze 2)"", vir_col)
 ```
 
-In this case, we're getting the solution for the regions outside of the loop created by the shortcut.
+In this case, the result contains the solution for the regions before and after the loop created by the shortcut.
 
 
 ## Combined Example
 
-Here we will combine the various changes we've made throughout the series into one final example maze.
-
+So far, a variety of changes to the original maze have been independently explored. Now, many of them will be combined into a more complex model. First, the resistance and absorption inputs need to be updated:
 ```{r, fig.show='hold', fig.width=7, fig.height=5, fig.align='center'}
 # Combine our previous resistance layers
 maze_all <- max(stack(maze2, maze_ints, maze_ends), na.rm = TRUE)
@@ -172,7 +175,7 @@ start_maze_all <- locate(samc_all, data.frame(x = 1, y = 20))
 finish_maze_all <- locate(samc_all, data.frame(x = 20, y = 1))
 ```
 
-As usual, we will start with looking at expected time to absorption:
+Following the previous model changes, start with looking at expected time to absorption:
 ```{r, fig.show='hold', fig.width=7, fig.height=5, fig.align='center'}
 surv_all <- survival(samc_all)
 
@@ -203,18 +206,19 @@ cond_passage(samc_all, start_maze_all, finish_maze_all)
 
 The presence of both the traps and the shortcut have a cumulative effect on both metrics; the time to absorption decreases, as does the time to conditional first passage (the time to finish assuming the individual is not absorbed elsewhere).
 
-We can compare the traps-only version of the maze to our cumulative maze using the `mortality()` metric to see how introducing the shortcut affects the probability of finishing the maze vs being absorbed in the traps:
+Comparing the traps-only version of the maze to the cumulative maze using the `mortality()` metric shows how introducing the shortcut affects the probability of finishing the maze vs being absorbed in the traps:
 ```{r}
 mort_traps[mort_traps > 0]
 
 mort_all <- mortality(samc_all, origin = start_maze_all)
 mort_all[mort_all > 0]
 ```
 
-With the introduction of the shortcut, we see that the probability of absorption into the two top traps is reduced because less time is spent in the top portion of the maze relative to the now more accessible bottom portion. We also see the probability of absorption into the bottom left trap has increased by more than an order of magnitude, accounting for most of the decrease in the top two traps. Finally, we see that the individual is somewhat more likely to survive and finish the maze. Note that the numeric index for the later two points are shifted by one; this is due to changing a `NA` cell to non-`NA` for the shortcut, and it is related to why we have to have to rerun `locate()` when the structure of the input to `samc()` changes.
+With the introduction of the shortcut, the probability of absorption into the two top traps is reduced because less time is spent in the top portion of the maze relative to the now more accessible bottom portion. Also, the probability of absorption into the bottom left trap has increased by more than an order of magnitude, accounting for most of the decrease in the top two traps. Finally, an individual is somewhat more likely to survive and finish the maze. Note that the numeric index for the later two points are shifted by one; this is due to changing a `NA` cell to non-`NA` for the shortcut, and it is related to why the `locate()` should be rerun when the structure of the input(s) to `samc()` changes.
+
+By now, the process of exploring the different metrics for these examples should be clear. This example highlighted a few key metrics and it is left to the user to explore the remaining metrics if they are interested in doing so. Additionally, this combined example left out the occupancy and fidelity changes introduced in previous parts; this is another opportunity for readers to practice making and exploring further modifications to the model.
 
-By now, the process of exploring the different metrics for these examples should be clear. For this example we highlighted a few key metrics leave it to the user to explore the remaining metrics if they are interested in doing so.
 
 ## Future Work
 
-Parts of this series may be rewritten, further expanded on, and/or reorganized in the future. Additionally, when igraph support is added to the package, the series will be expanded with an example illustrating construction of a maze using a graph.
+Parts of this series may be rewritten, further expanded on, and/or reorganized in the future. Additionally, when igraph support is added to the package, the series will be expanded with an example illustrating construction of a maze using a graph rather than a matrix/raster."
andrewmarx,samc,6ff9230332ed5e20f15c7f22c3930732fd973b53,Andrew Marx,andrewjmarx@gmail.com,2021-11-01T15:47:36Z,Andrew Marx,andrewjmarx@gmail.com,2021-11-01T15:47:36Z,"Rename base absorption layer in maze examples

Fix missing parentheses",vignettes/example-maze-part1.Rmd;vignettes/example-maze-part2.Rmd,True,False,True,False,17,17,34,"---FILE: vignettes/example-maze-part1.Rmd---
@@ -106,10 +106,10 @@ points(xyFromCell(maze, c(1, 400)), pch = c('S', 'F'), cex = 1, font = 2)
 Finally, create an absorption map where the finish point is our only source of absorption. It will have an absorption value of `1.0`, which means that once this point is entered, it cannot be left.
 ```{r, fig.show='hold', fig.width=7, fig.height=5, fig.align='center'}
 # End of maze
-maze_end <- maze * 0
-maze_end[20, 20] <- 1
+maze_finish <- maze * 0
+maze_finish[20, 20] <- 1
 
-maze_plot(maze_end, ""Absorption"", vir_col)
+maze_plot(maze_finish, ""Absorption"", vir_col)
 ```
 
 
@@ -118,7 +118,7 @@ maze_plot(maze_end, ""Absorption"", vir_col)
 ```{r}
 tr <- list(fun = function(x) 1/mean(x), dir = 4, sym = TRUE)
 
-samc_obj <- samc(maze, maze_end, tr_args = tr)
+samc_obj <- samc(maze, maze_finish, tr_args = tr)
 
 start <- locate(samc_obj, data.frame(x = 1, y = 20))
 finish <- locate(samc_obj, data.frame(x = 20, y = 1))

---FILE: vignettes/example-maze-part2.Rmd---
@@ -77,12 +77,12 @@ lcd <- (function() {
 vir_col <- viridis(3)[2:3]
 
 # End of maze
-maze_end <- maze * 0
-maze_end[20, 20] <- 1
+maze_finish <- maze * 0
+maze_finish[20, 20] <- 1
 
 tr <- list(fun = function(x) 1/mean(x), dir = 4, sym = TRUE)
 
-samc_obj <- samc(maze, maze_end, tr_args = tr)
+samc_obj <- samc(maze, maze_finish, tr_args = tr)
 
 start <- locate(samc_obj, data.frame(x = 1, y = 20))
 finish <- locate(samc_obj, data.frame(x = 20, y = 1))
@@ -107,12 +107,12 @@ maze_ints <- focal(maze, w = matrix(c(NA, 1, NA, 1, 1, 1, NA, 1, NA), nrow = 3,
 maze_ints[is.na(maze)] <- NA
 maze_ints <- maze_ints * 0.1
 
-maze_plot(maze_ints, ""Intersections"", vir_col
+maze_plot(maze_ints, ""Intersections"", vir_col)
 ```
 
 Fidelity changes the $P$ matrix underlying the samc object, which means we have to create a new samc object:
 ```{r}
-samc_ints <- samc(maze, maze_end, maze_ints, tr_args = tr)
+samc_ints <- samc(maze, maze_finish, maze_ints, tr_args = tr)
 ```
 
 To start, let's see how the new fidelity input affects our expected time to finish:
@@ -157,7 +157,7 @@ With fidelity present, the intersections are seeing a significantly different nu
 tolerance = sqrt(.Machine$double.eps) # Default tolerance in functions like all.equal()
 print(tolerance)
 
-maze_plot(visit_diff > tolerance, ""Visits With Non-Zero Difference"", vir_col
+maze_plot(visit_diff > tolerance, ""Visits With Non-Zero Difference"", vir_col)
 
 # Second, let's see what the percent change is for our non-zero differences.
 visit_perc <- (visit_ints - visit_orig) / visit_orig
@@ -204,12 +204,12 @@ maze_ends[is.na(maze)] <- NA
 maze_ends <- maze_ends * 9 + 1
 maze_ends[20, 20] <- 1
 
-maze_plot(maze_ends, ""Dead Ends"", vir_col
+maze_plot(maze_ends, ""Dead Ends"", vir_col)
 ```
 
 We have given the dead ends a resistance value of 10, which is relatively high and means that dead ends will only rarely be entered. Since we've modified our resistance map, we need to update the samc object. We will not use our fidelity data from the previous section, which will allow us to compare directly against the model created in Part 1.
 ```{r}
-samc_ends <- samc(maze_ends, maze_end, tr_args = tr)
+samc_ends <- samc(maze_ends, maze_finish, tr_args = tr)
 ```
 
 Hypothetically, since an individual can now ""look ahead"", they should be able to get through the maze faster because they are spending less time in dead ends. We can see this easily:
@@ -250,12 +250,12 @@ maze_traps[17, 3] <- 0.2
 maze_traps[1, 6] <- 0.2
 maze_traps[6, 20] <- 0.2
 
-maze_plot(maze_traps, ""Traps"", vir_col
+maze_plot(maze_traps, ""Traps"", vir_col)
 ```
 
 In order to use this, we will have to create a new samc object:
 ```{r}
-abs_total <- maze_end + maze_traps
+abs_total <- maze_finish + maze_traps
 
 samc_traps <- samc(maze, abs_total, tr_args = tr)
 ```
@@ -298,7 +298,7 @@ tolerance = sqrt(.Machine$double.eps) # Default tolerance in functions like all.
 print(tolerance)
 disp_traps_route <- as.numeric(abs(disp_traps - 1) < tolerance)
 
-maze_plot(map(samc_traps, disp_traps_route), ""dispersal() == 1"", vir_col
+maze_plot(map(samc_traps, disp_traps_route), ""dispersal() == 1"", vir_col)
 ```
 
 It shows us part of the solution we saw before, but only up to the first maze intersection that leads to two or more possible sources of absorption.
@@ -322,10 +322,10 @@ There's only a 2.1% chance of our individual finishing the maze! This seems real
 The package allows us to break things down so that we can investigate the role of different types of mortality more easily. Remember, we started with two absorption layers that we summed together; now that the samc object has been created, we can provide it that information:
 ```{r}
 # Naming our rasters will make things easier and less error-prone later
-names(maze_end) <- ""Finish""
+names(maze_finish) <- ""Finish""
 names(maze_traps) <- ""Traps""
 
-samc_traps$abs_states <- raster::stack(maze_end, maze_traps)
+samc_traps$abs_states <- raster::stack(maze_finish, maze_traps)
 ```
 
 By doing so, the `mortality()` metric now returns a list with information about not just the total absorption, but the individual components we specified. This allows us to individually access and visualize the role of different types of absorption:"
andrewmarx,samc,99949fd08cdf0a9d1d16c18b24c9197ffaf515b6,Andrew Marx,andrewjmarx@gmail.com,2021-10-25T14:08:20Z,Andrew Marx,andrewjmarx@gmail.com,2021-10-25T14:21:25Z,"Fix maze example intro

Update title as well",vignettes/example-maze-part1.Rmd,True,False,True,False,2,2,4,"---FILE: vignettes/example-maze-part1.Rmd---
@@ -1,5 +1,5 @@
 ---
-title: ""Maze Example""
+title: ""Maze Part 1""
 author: ""Andrew Marx""
 date: ""`r Sys.Date()`""
 output: rmarkdown::html_vignette
@@ -24,7 +24,7 @@ if (!all(sapply(required, requireNamespace, quietly = TRUE))) {
 
 ## Introduction
 
-This tutorial shows the basics of how to use the package to calculate and visualize several metrics using map based inputs. It utilizes the package's built-in data, which is the same example data used in Fletcher et al. (2019).
+This example shows how to use and interpret different absorbing Markov chain metrics with a perfect maze. A perfect maze is a maze that has no loops, every point is reachable, and there is only a single path between any two points. The advantage of an example like this is that it makes it easier to visually and numerically reason about what the package is doing.
 
 
 ## Libraries"
andrewmarx,samc,78d5f25c9e41fe971a23af1405b17f3e4597c8fc,Andrew Marx,andrewmarx@users.noreply.github.com,2021-10-23T16:21:36Z,GitHub,noreply@github.com,2021-10-23T16:21:36Z,"Update example-maze-part1.html

Fix intro",docs/articles/example-maze-part1.html,False,False,False,False,1,1,2,"---FILE: docs/articles/example-maze-part1.html---
@@ -154,7 +154,7 @@ <h4 class=""date"">2021-10-22</h4>
 <div id=""introduction"" class=""section level2"">
 <h2 class=""hasAnchor"">
 <a href=""#introduction"" class=""anchor""></a>Introduction</h2>
-<p>This tutorial shows the basics of how to use the package to calculate and visualize several metrics using map based inputs. It utilizes the packages built-in data, which is the same example data used in Fletcher et al.(2019).</p>
+<p>This example shows how to use and interpret different absorbing Markov chain metrics with a perfect maze. A perfect maze is a maze that has no loops, every point is reachable, and there is only a single path between any two points. The advantage of an example like this is that it makes it easier to visually and numerically reason about what the package is doing.</p>
 </div>
 <div id=""libraries"" class=""section level2"">
 <h2 class=""hasAnchor"">"
andrewmarx,samc,f56df8a708831b8ad46ce6a4792aa2ab81b141bf,Andrew Marx,andrewjmarx@gmail.com,2021-10-22T21:54:10Z,Andrew Marx,andrewjmarx@gmail.com,2021-10-22T21:54:10Z,Maze vignette minor grammar fix,vignettes/example-maze-part1.Rmd,True,False,True,False,1,1,2,"---FILE: vignettes/example-maze-part1.Rmd---
@@ -166,7 +166,7 @@ points(points, pch = c('S', 'F'), cex = 1, font = 2)
 
 In order to complete the maze, the individual has to visit every cell along the path to the exit, so all of those cells will have a probability of `1.0`. The farther away from this path a cell is located, the lower the probability it will be visited. Additionally, the closer the individual gets to the finish, the less likely they will spend time taking incorrect routes before stumbling upon the finish. There's also the possibility for scenarios like the one where the individual is near the finish and then manages to stumble all the way back to the start. These different aspects contribute to more time spent near the start point, on average, which in turn means that cells near the start have a higher probability of being visited.
 
-If you didn't catch it in the previous paragraph, we can use our results from the `dispersal()` function identify the route through the maze:
+If you didn't catch it in the previous paragraph, we can use our results from the `dispersal()` function to identify the route through the maze:
 ```{r, fig.show='hold', fig.width=7, fig.height=5, fig.align='center'}
 # Ideally, we would just use `as.numeric(disp == 1)`, but float precision means
 # that what we think is `1` isn't always `1` with computers, so it won't always"
andrewmarx,samc,1f59e5533baf7a078c88dc7c3d1c362952b51eb3,Andrew Marx,andrewjmarx@gmail.com,2021-10-22T21:43:51Z,Andrew Marx,andrewjmarx@gmail.com,2021-10-22T21:43:51Z,Fix C++ initializer order,src/dispersal.cpp,False,False,False,False,3,3,6,"---FILE: src/dispersal.cpp---
@@ -18,10 +18,10 @@
 class progressCounter {
 public:
   progressCounter(size_t sz, double f) :
-    lastTime(std::chrono::steady_clock::now()),
-    startTime(std::chrono::steady_clock::now()),
     size(sz),
-    freq(f) {}
+    freq(f),
+    lastTime(std::chrono::steady_clock::now()),
+    startTime(std::chrono::steady_clock::now()) {}
 
   void operator++(int) {
     progress++;"
andrewmarx,samc,ef69f2243a1747ba58505ca91601cd671d6fb363,Andrew Marx,andrewjmarx@gmail.com,2021-10-19T18:04:20Z,Andrew Marx,andrewjmarx@gmail.com,2021-10-19T18:04:20Z,maze vignette title fix,vignettes/example-maze-part1.Rmd,True,False,True,False,1,1,2,"---FILE: vignettes/example-maze-part1.Rmd---
@@ -171,7 +171,7 @@ tolerance = .Machine$double.eps^0.5
 print(tolerance)
 disp_sol <- as.numeric(abs(disp - 1) < tolerance)
 
-plot(map(samc_obj, disp_sol), col = vir_col[c(2, 3)], main = ""Dispersal Solution"", axes = FALSE, box = FALSE, asp = 1)
+plot(map(samc_obj, disp_sol), col = vir_col[c(2, 3)], main = ""Solution Using Dispersal()"", axes = FALSE, box = FALSE, asp = 1)
 plot(rasterToPolygons(maze_end), border = 'black', lwd = 1, add = TRUE)
 points(points, pch = c('S', 'F'), cex = 1, font = 2)
 ```"
andrewmarx,samc,9d601100ed687d7d1b179cc59bc84f632bfdc088,Andrew Marx,andrewjmarx@gmail.com,2021-10-18T18:55:03Z,Andrew Marx,andrewjmarx@gmail.com,2021-10-18T18:55:03Z,Fix distribution test file typo,tests/testthat/test-distribution.R,False,True,True,False,1,1,2,"---FILE: tests/testthat/test-distribution.R---
@@ -1,4 +1,4 @@
-context(""Visitation"")
+context(""Distribution"")
 
 
 for(test in testlist) {"
andrewmarx,samc,d3c0ff89089d098645b3e1b9e89c59cc2e238b80,Andrew Marx,andrewjmarx@gmail.com,2021-10-12T13:18:26Z,Andrew Marx,andrewjmarx@gmail.com,2021-10-12T13:18:26Z,"Incomplete change to parallel disp

Commit to document current state of RcppParallel implementation before
attempting RcppThread alternative, which doesn't depend on external
libraries, but instead only relies on core C++ features. Currently
trying to figure out an approach to reporting progress, but having
issues with the auto_partiotioner default in TBB producing unpredictable
chunk sizes.",R/dispersal.R;src/dispersal.cpp,False,True,True,False,71,8,79,"---FILE: R/dispersal.R---
@@ -216,7 +216,7 @@ setMethod(
         dg <- samc:::.diagf(q)
       } else if (samc@threads > 1) {
         RcppParallel::setThreadOptions(numThreads = samc@threads)
-        dg <- samc:::.diagf_par(q, ceiling(nrow(q) / samc@threads))
+        dg <- samc:::.diagf_par(q)
       } else {
         stop(""Invalid number of threads set in samc object"", call. = FALSE)
       }
@@ -292,7 +292,7 @@ setMethod(
         dg <- samc:::.diagf(q)
       } else if (samc@threads > 1) {
         RcppParallel::setThreadOptions(numThreads = samc@threads)
-        dg <- samc:::.diagf_par(q, ceiling(nrow(q) / samc@threads))
+        dg <- samc:::.diagf_par(q)
       } else {
         stop(""Invalid number of threads set in samc object"", call. = FALSE)
       }

---FILE: src/dispersal.cpp---
@@ -12,9 +12,26 @@
 
 #include <Rcpp/Benchmark/Timer.h>
 
+#include <chrono>
+#include <string>
+
 using namespace RcppParallel;
 
 
+// C++ 11 compliant stopwatch that should be thread safe
+class timer {
+public:
+  std::chrono::time_point<std::chrono::high_resolution_clock> lastTime;
+  timer() : lastTime(std::chrono::high_resolution_clock::now()) {}
+  inline double elapsed() {
+    std::chrono::time_point<std::chrono::high_resolution_clock> thisTime=std::chrono::high_resolution_clock::now();
+    double deltaTime = std::chrono::duration<double>(thisTime - lastTime).count();
+    //lastTime = thisTime;
+    return deltaTime;
+  }
+};
+
+
 
 // [[Rcpp::export("".sum_qn_q"")]]
 Rcpp::List sum_qn_q(const Eigen::Map<Eigen::SparseMatrix<double> > &M,
@@ -66,7 +83,10 @@ Rcpp::NumericVector diagf(Eigen::Map<Eigen::SparseMatrix<double> > &M)
   double t = 0.0;
   Rcpp::String units(""unit"");
 
+  // Limit how freq the time updates
   int ut = std::max(sz/10, 1000);
+
+  // Used to given plenty of time for the first time update to be reasonable
   int utm = (int)std::max(10.0, std::pow(10, (7.0 - std::log10((double)sz))));
 
   solver.compute(M);
@@ -114,29 +134,70 @@ Rcpp::NumericVector diagf(Eigen::Map<Eigen::SparseMatrix<double> > &M)
 
 struct DiagWorker : public Worker
 {
+  // Progress update related stuff
+  tbb::mutex mtx;
+  int total;
+  int current;
+
   // Setup the solver
   Eigen::SparseLU<Eigen::SparseMatrix<double> > solver;
 
   // Output vector
   RVector<double> output;
 
+  // Start time
+  std::chrono::time_point<std::chrono::steady_clock> startTime;
+
   // Initialize
   DiagWorker(Rcpp::NumericVector output)
     : output(output) {}
 
   // Calculate the diagonal
   void operator()(std::size_t begin, std::size_t end) {
 
+    mtx.lock();
+    RcppThread::Rcout << ""Thread "" << (int)begin << "" "" << (int)end << ""\n"";
+    mtx.unlock();
+
     Eigen::VectorXd ident = Eigen::VectorXd::Zero(output.length());
     Eigen::VectorXd col(output.length());
 
     float total_time = float(end-begin);
 
+    timer stopwatch;
+    double t = 0.0;
+
+    std::string units = """";
+    int ut = std::max((int)end/10, 1000);
+
     for(int i = begin; i < end; i++) {
-      // begin == 0 ensures only one thread does the interrupt check and progress output
-      if(i % 10 == 0 && begin == 0) {
+      //if(i % 100 == 0) {
         RcppThread::checkUserInterrupt();
-        RcppThread::Rcout << ""\rCalculating matrix inverse diagonal... "" << (float)(i - begin) / total_time * 100.0f << ""%                            "";
+      //}
+
+      // begin == 0 ensures only one thread does the interrupt check and progress output
+      if(begin == 0) {
+
+
+        if(i % ut == ut - 1) {
+          ut = 100;
+          t = ((double)(stopwatch.elapsed()/ i) * (double)(end - i));
+
+          if (t > 86400) {
+            t = t / 86400;
+            units = "" days"";
+          } else if (t > 3600) {
+            t = t / 3600;
+            units = "" hours"";
+          } else if (t > 60) {
+            t = t / 60;
+            units = "" minutes"";
+          } else {
+            units = "" seconds"";
+          }
+
+          //RcppThread::Rcout << ""\rCalculating matrix inverse diagonal... "" << t << units << "" remaining         "";
+        }
       }
 
       ident(i) = 1;
@@ -150,7 +211,7 @@ struct DiagWorker : public Worker
 
 
 // [[Rcpp::export("".diagf_par"")]]
-Rcpp::NumericVector diagf_par(Eigen::Map<Eigen::SparseMatrix<double> > &M, const int grain)
+Rcpp::NumericVector diagf_par(Eigen::Map<Eigen::SparseMatrix<double> > &M)
 {
   Rcpp::Rcout << ""\nCached diagonal not found.\n"";
 
@@ -166,10 +227,12 @@ Rcpp::NumericVector diagf_par(Eigen::Map<Eigen::SparseMatrix<double> > &M, const
 
   Rcpp::Rcout << "" Complete.\n"";
 
-  Rcpp::Rcout << ""Calculating matrix inverse diagonal..."";
+  diagWorker.startTime = std::chrono::steady_clock::now();
+
+  //Rcpp::Rcout << ""Calculating matrix inverse diagonal..."";
 
   // Parallel run
-  parallelFor(0, sz, diagWorker /*,grain*/);
+  parallelFor(0, sz, diagWorker);
 
   Rcpp::Rcout << ""\rCalculating matrix inverse diagonal... Complete                                           \n"";
   Rcpp::Rcout << ""Diagonal has been cached. Continuing with metric calculation...\n"";"
andrewmarx,samc,e63d34b11eb1ee3b6b09647f17456a13d5769485,Andrew Marx,andrewjmarx@gmail.com,2021-09-13T15:32:30Z,Andrew Marx,andrewjmarx@gmail.com,2021-09-13T15:32:30Z,"Fix thread assignment bug

Prevent users from inputting integers less than one for the number of
threads",R/generics.R,False,True,True,False,1,1,2,"---FILE: R/generics.R---
@@ -74,7 +74,7 @@ setMethod(""$<-"", signature(x = ""samc""), function(x, name, value) {
   } else if (name == ""p_matrix""){
     warning(""Cannot modify the P matrix this way."", call. = FALSE)
   } else if (name == ""threads""){
-    if (is.numeric(value) && length(value) == 1 && value%%1 == 0) {
+    if (is.numeric(value) && length(value) == 1 && value%%1 == 0 && value > 0) {
       if (value <= RcppParallel::defaultNumThreads()) {
         x@threads <- value
       } else {"
andrewmarx,samc,be650507e9d2def41bcb330e454514506398fce4,Andrew Marx,andrewjmarx@gmail.com,2021-09-11T22:12:32Z,Andrew Marx,andrewjmarx@gmail.com,2021-09-11T22:12:32Z,"Update samc class threads checks

Fix bug in verification of input

Add additional warnings",R/generics.R,False,True,True,False,8,3,11,"---FILE: R/generics.R---
@@ -34,6 +34,8 @@ setMethod(""$"", signature(x = ""samc""), function(x, name) {
 
     return(p)
   } else if (name == ""threads""){
+    warning(paste0(""Max threads supported by this device:"", RcppParallel::defaultNumThreads()), call. = FALSE)
+    warning(""Using all of your cores can make your computer unusable for other tasks while an analysis runs."", call. = FALSE)
     return(x@threads)
   } else {
     warning(""Invalid object specified."", call. = FALSE)
@@ -72,9 +74,12 @@ setMethod(""$<-"", signature(x = ""samc""), function(x, name, value) {
   } else if (name == ""p_matrix""){
     warning(""Cannot modify the P matrix this way."", call. = FALSE)
   } else if (name == ""threads""){
-    if (is.numeric(value) && length(value) == 1 && x%%1==0) {
-      x@threads <- value
-      warning(""Make sure you're specifying a reasonable number of threads. Using all of your cores can make your computer unusable for other tasks while the analysis runs. Specifying more threads than your computer has cores may hurt performance."", call. = FALSE)
+    if (is.numeric(value) && length(value) == 1 && value%%1 == 0) {
+      if (value <= RcppParallel::defaultNumThreads()) {
+        x@threads <- value
+      } else {
+        warning(paste0(""Max threads supported by this device:"", RcppParallel::defaultNumThreads()), call. = FALSE)
+      }
     } else {
       warning(""Input must be a single positive integer."", call. = FALSE)
     }"
andrewmarx,samc,5824b008a026d88ea3b3c04c412fae374a37392b,Andrew Marx,andrewjmarx@gmail.com,2021-08-30T00:22:22Z,Andrew Marx,andrewjmarx@gmail.com,2021-08-30T00:22:22Z,Add Rcpp related error to Troubleshooting vignette,vignettes/troubleshooting.Rmd,True,False,True,False,4,0,4,"---FILE: vignettes/troubleshooting.Rmd---
@@ -89,3 +89,7 @@ See the [Disconnected Data](data-disconnected.html) vignette.
 ## Warning: Input contains disconnected regions. This does not work with the cond_passage() metric
 
 See the [Disconnected Data](data-disconnected.html) vignette.
+
+## Error in <...> : function 'Rcpp_precious_remove' not provided by package 'Rcpp'
+
+Update the Rcpp package. Then make sure to unload all of your packages and reload them again. You do not need to load the Rcpp package (i.e, do not `library(Rcpp)`)."
andrewmarx,samc,fea272effa7061bf3dd70ae760bffbd66cf66a01,Andrew Marx,andrewjmarx@gmail.com,2021-08-30T00:02:25Z,Andrew Marx,andrewjmarx@gmail.com,2021-08-30T00:02:25Z,"Add Disconnected Data vignette

Create initial vignette for discussing Disconnected Data based on an
email consversation

Add related error/warning messages to Troubleshooting vignette with link
to Disconnected Data vignette",_pkgdown.yml;vignettes/data-disconnected.Rmd;vignettes/troubleshooting.Rmd,True,False,True,False,59,0,59,"---FILE: _pkgdown.yml---
@@ -12,6 +12,10 @@ navbar:
         href: articles/troubleshooting.html
       - text: ""Code Snippets""
         href: articles/code-snippets.html
+    - text: ""Data""
+      menu:
+      - text: ""Disconnected Data""
+        href: articles/data-disconnected.html
     - text: ""Tutorials""
       menu:
       - text: ""Basic Tutorial""

---FILE: vignettes/data-disconnected.Rmd---
@@ -0,0 +1,47 @@
+---
+title: ""Disconnected Data""
+author: ""Andrew Marx""
+date: ""`r Sys.Date()`""
+output: rmarkdown::html_vignette
+vignette: >
+  %\VignetteIndexEntry{Disconnected Data}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+
+```{r setup, include = FALSE}
+knitr::opts_chunk$set(
+  collapse = TRUE,
+  comment = ""#>""
+)
+
+required <- c(""viridis"")
+if (!all(sapply(required, requireNamespace, quietly = TRUE))) {
+  knitr::opts_chunk$set(eval = FALSE)
+}
+
+library(""raster"")
+library(""samc"")
+library(""viridisLite"")
+```
+
+*Note: this vignette is far from complete and only contains a brief discussion (originally from an email) of the topic in the context of rasters. It will be rewritten and expanded in future releases.*
+
+## Rasters
+
+Imagine you have a raster with 2 islands, and that water separating the islands in the raster is represented with `NA`'s. These two islands would be disconnected and will result in `""Warning: Input contains disconnected regions. This does not work with the cond_passage() metric.""`. The warning isn't an issue if you don't need the `cond_passage()` function.
+
+Now, each island (aka region) must have at least one pixel with a non-zero absorbing value. The math algorithms don't work without that. If a region does not have at least one non-zero absorbing value, then the `samc()` function will result in `Error: All disconnected regions must have at least one non-zero absorption value`
+
+Now the tricky part; an island/region can be as small as a single pixel. So, if you're not careful with your raster, you might have very small, isolated patches as small as a pixel floating around somewhere. If you're using just 4 directions for the transition function, they could even be immediately diagonal to another patch.
+
+The easiest way to spot these is to pick one of your rasters and set all your non-`NA` values to the same value, like 1. Then turn all the `NA`'s to a different value, like 0. Then plot it. Code:
+
+```{r eval = FALSE}
+raster[!is.na(raster[])) <- 1 
+raster[is.na(raster[])) <- 0
+plot(raster)
+```
+
+If your raster is particularly large, then you might need to save it out to a high-res image to spot solo pixels
+

---FILE: vignettes/troubleshooting.Rmd---
@@ -81,3 +81,11 @@ samc_obj <- samc(res_data, 0.01, tr_args = list(fun = function(x) 1/mean(x), dir
 # Solution
 samc_obj <- samc(res_data, abs_data, tr_args = list(fun = function(x) 1/mean(x), dir = 8, sym = TRUE))
 ```
+
+## Error: All disconnected regions must have at least one non-zero absorption value
+
+See the [Disconnected Data](data-disconnected.html) vignette.
+
+## Warning: Input contains disconnected regions. This does not work with the cond_passage() metric
+
+See the [Disconnected Data](data-disconnected.html) vignette."
andrewmarx,samc,9cce3a3d5f6517bf86d77ad2691497fbcd95fb5f,Andrew Marx,andrewjmarx@gmail.com,2021-08-29T21:10:39Z,Andrew Marx,andrewjmarx@gmail.com,2021-08-29T21:10:39Z,"Update crs check in samc()

Fix crs check not accounting for hidden wkt info in CRS objects

Fix error message output

Resolves #15",R/samc.R,False,True,True,False,2,2,4,"---FILE: R/samc.R---
@@ -187,8 +187,8 @@ setMethod(
       stop(""Extent of absorption raster does not match extent of raster used to create TransitionLayer"")
     }
 
-    if (!identical(raster::crs(m), raster::crs(rs))) {
-      stop(""Extent of absorption raster does not match extent of raster used to create TransitionLayer"")
+    if (!raster::compareCRS(m, rs)) {
+      stop(""crs of absorption raster does not match crs of raster used to create TransitionLayer"")
     }
 
 "
andrewmarx,samc,d23227a26a1c99b57437c9935d64adde64ee240e,Andrew Marx,andrewjmarx@gmail.com,2021-06-27T00:37:01Z,Andrew Marx,andrewjmarx@gmail.com,2021-06-27T00:37:01Z,Fix spelling issues,NEWS.md;R/generics.R;R/internal-classes.R;R/locate.R;README.md,False,True,True,False,8,8,16,"---FILE: NEWS.md---
@@ -1,16 +1,16 @@
 # samc 1.4.0
 
-- Due to a ballooning parameter count, the samc() function parameters are being adjusted. The new version is samc(data, absorption, fidelity, tr_args). Code using the previous syntax should continue to work (with one rare edge-case as an exception), but backwards compatability will be remove in version 1.5.0, so old code should be updated. See the samc() function documentation and website tutorials for full details and examples. Package startup output has been added to detail the changes as well.
+- Due to a ballooning parameter count, the samc() function parameters are being adjusted. The new version is samc(data, absorption, fidelity, tr_args). Code using the previous syntax should continue to work (with one rare edge-case as an exception), but backwards compatibility will be remove in version 1.5.0, so old code should be updated. See the samc() function documentation and website tutorials for full details and examples. Package startup output has been added to detail the changes as well.
   - Updated long/lat handling in samc() to use projection info built into the raster. Deprecated latlon parameter (no longer needed). Added warning for when rasters have non-square cells and are missing projection information.
   - The data parameter should be used to pass in the data related to transition probabilities (essentially replaces the resistance and p_mat parameters)
   - The tr_fun and directions parameters have been deprecated. This information is now passed as list to the tr_args.
   - Deprecated override parameter in the samc() function. See samc-class documentation for details on how to set this.
-- Added support for specificing if transition functions are symmetrical or not through the tr_args parameter list.
+- Added support for specifying if transition functions are symmetrical or not through the tr_args parameter list.
 - Added the ability to directly input a custom TransitionLayer to the samc() function. This allows more flexibility than RasterLayer/matrix maps, but is a little safer than directly inputting a P matrix. See samc() documentation and *Overview* vignette for full details.
 - Added the ability to use the $ operator for accessing and modifying components of samc-class objects. See samc-class documentation for details.
 - Updated check() so that multiple rasters can be inputted in the first argument as a RasterStack. This eliminates the need to manually run check() for multiple pairs of rasters.
 - Added initial support for caching intermediate results of some calculations. This currently only benefits dispersal(samc, occ), which now caches the diag(F) calculation. This means that while the first run of this method will still be slow, subsequent runs will be substantially faster. With this feature, dispersal(samc, origin) has been enabled, and will share the same cached information with dispersal(samc, occ). Future versions will expand the cache options to additional metrics.
-- Added support for multiple absorption. The `absorption` parameter in samc() is treated as the total absorption (consistent with previous behavior). After creation of the samc-class object, additional absorpting states can be attached to the samc-class object. See the samc-class documentation and the new *Multiple Absorption* tutorial for more details. 
+- Added support for multiple absorption. The `absorption` parameter in samc() is treated as the total absorption (consistent with previous behavior). After creation of the samc-class object, additional absorbing states can be attached to the samc-class object. See the samc-class documentation and the new *Multiple Absorption* tutorial for more details. 
 - Added a new absorption() metric. This metric is closely related to the mortality() metric. The absorption() metric can be used to determine the overall probability that a particular absorbing state will be reached (the mortality() metric calculates it for individual transient states rather than overall).
 - Fix missing value short-term dispersal
 - Overhauled the *Overview* vignette, including adding more details about the construction of the P matrix.

---FILE: R/generics.R---
@@ -42,7 +42,7 @@ setMethod(""$"", signature(x = ""samc""), function(x, name) {
 
 #' Modify samc-class components
 #'
-#' Allows users to modifu a subset of the samc-class components
+#' Allows users to modify a subset of the samc-class components
 #'
 #' @param x samc-class object
 #' @param name Component of the samc-class to modify

---FILE: R/internal-classes.R---
@@ -8,7 +8,7 @@ NULL
 #'
 #' @slot q Q matrix
 #' @slot t_abs Total absorption
-#' @slot c_abs Component absorptions
+#' @slot c_abs Component absorption states
 #'
 #' @name samc_data-class
 #' @keywords internal

---FILE: R/locate.R---
@@ -37,7 +37,7 @@ NULL
 #' @param samc A \code{\link{samc-class}} object
 #' @param xy Any valid input to the y argument of the \code{\link[raster]{extract}} function in the raster package.
 #
-#' @return A rasterlayer or a vector
+#' @return A RasterLayer or a vector
 #'
 #' @example inst/examples/locate.R
 #'

---FILE: README.md---
@@ -12,7 +12,7 @@ This is an R package that implements functions for working with absorbing Markov
 For more information, and recommended installation instructions, most users should visit the main home page at https://andrewmarx.github.io/samc. The remainder of this document is dedicated to installing the package from source (not recommended).
 
 
-## Installing From Github
+## Installing From GitHub
 
 #### Pre v1.0.0
 
@@ -26,7 +26,7 @@ devtools::install_github(""andrewmarx/samc"", ref = ""0.1.0"")
 
 Version 1.0.0 and newer requires C++ development tools in order to install from source. The steps required to install the appropriate development tools varies by operating system and is beyond the scope of this document. Users will have to locate and follow appropriate external documentation to setup the devtools if they wish to install the newest version of the samc package from source.
 
-If the devtools are installed and setup correctly, then the latest version of the package can be installed directly from github using the following command:
+If the devtools are installed and setup correctly, then the latest version of the package can be installed directly from GitHub using the following command:
 
 ```R
 devtools::install_github(""andrewmarx/samc"")"
andrewmarx,samc,cee539d08f63a792cfd5c28437fdb4f07f1f285f,Andrew Marx,andrewjmarx@gmail.com,2021-06-15T18:18:02Z,Andrew Marx,andrewjmarx@gmail.com,2021-06-15T18:18:02Z,"Overview analytical function table fix

Remove analytical function table from R code block because it is no
longer being generated correctly (possibly due to a rmarkdown update).

The solution will result in columns of equal width (not ideal)",vignettes/overview.Rmd,True,False,True,False,14,17,31,"---FILE: vignettes/overview.Rmd---
@@ -97,29 +97,26 @@ In addition to the `samc()` function, the package has other utility functions th
 
 The package implements functions for the formulas provided in Table 1 of Fletcher et al. ([2019](https://onlinelibrary.wiley.com/doi/full/10.1111/ele.13333)), as well as other new ones since that publication. Many of the formulas are related conceptually, and are grouped together into single functions with multiple parameter signatures to reduce the number of unique function names needed. Note that the descriptions assume $\psi$ contains probabilities (see above). The following descriptions were written in an ecological context; the function reference pages provide mathematically formal descriptions.
 
-```{r table1, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
-tabl <- ""
+
 | Function | Equation | Description |
 |:---------|:---------|:------------|
 | `absorption()` | $A = F R$ | Probability of an individual experiencing a specific type of mortality |
-| | $\\psi^T A$ | Probability of an individual experiencing a specific type of mortality, regardless of initial location |
-| `cond_passage()` | $\\tilde{t} = \\tilde{B}_j^{-1}\\tilde{F}\\tilde{B}_j{\\cdot}1$ | Mean first conditional passage time |
-| `dispersal()` | $\\tilde{D}_{jt}=({\\sum}_{n=0}^{t-1}\\tilde{Q}^n)\\tilde{q}_j$ | Probability of an individual visiting a location, if starting at any other location, before or at time *t* |
-| | $\\psi^T\\tilde{D}_{jt}$ | Probability of an individual visiting a location, before or at time *t*, regardless of initial location |
+| | $\psi^T A$ | Probability of an individual experiencing a specific type of mortality, regardless of initial location |
+| `cond_passage()` | $\tilde{t} = \tilde{B}_j^{-1}\tilde{F}\tilde{B}_j{\cdot}1$ | Mean first conditional passage time |
+| `dispersal()` | $\tilde{D}_{jt}=({\sum}_{n=0}^{t-1}\tilde{Q}^n)\tilde{q}_j$ | Probability of an individual visiting a location, if starting at any other location, before or at time *t* |
+| | $\psi^T\tilde{D}_{jt}$ | Probability of an individual visiting a location, before or at time *t*, regardless of initial location |
 | | $D=(F-I)diag(F)^{-1}$ | Probability of an individual visiting a location |
-| | $\\psi^TD$ | Probability of an individual visiting a location, regardless of initial location |
+| | $\psi^TD$ | Probability of an individual visiting a location, regardless of initial location |
 | `distribution()` | $Q^t$   | Probability of an individual being at a location at time *t* |
-| | $\\psi^TQ^t$ | Probability of an individual being at a location at time *t*, regardless of initial location |
-| `mortality()` | $\\tilde{B}_t = (\\sum_{n=0}^{t-1} Q^n) \\tilde{R}$ | Probability of an individual experiencing mortality at a location before or at time *t* |
-| | $\\psi^T \\tilde{B}_t$ | Probability of an individual experiencing mortality at a location, before or at time *t*, regardless of initial location |
-| | $B = F \\tilde{R}$ | Probability of an individual experiencing mortality at a location |
-| | $\\psi^T B$ | Probability of an individual experiencing mortality at a location, regardless of initial location |
-| `survival()` | $z=(I-Q)^{-1}{\\cdot}1=F{\\cdot}1$ | Expected life expectancy of an individual |
-| | ${\\psi}^Tz$ | Overall life expectancy, regardless of initial location |
+| | $\psi^TQ^t$ | Probability of an individual being at a location at time *t*, regardless of initial location |
+| `mortality()` | $\tilde{B}_t = (\sum_{n=0}^{t-1} Q^n) \tilde{R}$ | Probability of an individual experiencing mortality at a location before or at time *t* |
+| | $\psi^T \tilde{B}_t$ | Probability of an individual experiencing mortality at a location, before or at time *t*, regardless of initial location |
+| | $B = F \tilde{R}$ | Probability of an individual experiencing mortality at a location |
+| | $\psi^T B$ | Probability of an individual experiencing mortality at a location, regardless of initial location |
+| `survival()` | $z=(I-Q)^{-1}{\cdot}1=F{\cdot}1$ | Expected life expectancy of an individual |
+| | ${\psi}^Tz$ | Overall life expectancy, regardless of initial location |
 | `visitation()` | $F = (I-Q)^{-1}$ | Expected number of times an individual visits a location |
-""
-cat(tabl) # output the table in a format good for HTML/PDF/docx conversion
-```
+
 
 Depending on the combination of inputs used, a function might return a single value, a vector, a matrix, or a list. In some cases, the calculations will be impractical with sufficiently large landscape datasets due to memory and other performance constraints. To work around this, many equations have multiple associated function signatures that allow users to calculate individual portions of the result rather than the entire result. This opens up multiple optimizations that makes calculating many of the metrics more practical. More specific details about performance considerations can be found in the [Performance](performance.html) vignette.
 "
andrewmarx,samc,8fbe63f0d72698894f0bf075b0b7eb6f98fa7006,Andrew Marx,andrewjmarx@gmail.com,2021-05-30T02:39:29Z,Andrew Marx,andrewjmarx@gmail.com,2021-05-30T02:39:29Z,"Update TransitionLayer samc() methods

Update and fix checks

Update default number of clumps for when samc() cannot determine

Add warning for cond_passage() for when number of clumps is unknown",R/cond_passage.R;R/samc.R,False,True,True,False,69,29,98,"---FILE: R/cond_passage.R---
@@ -55,6 +55,9 @@ setMethod(
   ""cond_passage"",
   signature(samc = ""samc"", origin = ""missing"", dest = ""location""),
   function(samc, dest) {
+    if (samc@clumps == -1)
+      warning(""Unknown number of clumps in data. If the function crashes, it may be due to the transition matrix being discontinuous."", call. = FALSE)
+
     if (samc@clumps > 1)
       stop(""This function cannot be used with discontinuous data"", call. = FALSE)
 

---FILE: R/samc.R---
@@ -10,7 +10,7 @@ NULL
 #' Create an samc object that contains the absorbing Markov chain data
 #'
 #' This function is used to create a \code{\link{samc-class}} object. There are
-#' two options for creating this object.
+#' multiple options for creating this object.
 #'
 #' \strong{Option 1: Raster and Matrix Inputs}
 #'
@@ -32,7 +32,24 @@ NULL
 #' and if the transition function is symmetric (TRUE or FALSE). Here is the template:
 #' \code{list(fun = `function`, dir = `numeric`, sym = `logical`)}
 #'
-#' \strong{Option 2: P Matrix Input}
+#' \strong{Option 2: TransitionLayer Input}
+#'
+#' The \code{data} parameter can be a \code{\link[gdistance]{TransitionLayer}} object.
+#' In this case the \code{absorption} parameter is mandatory and should be a RasterLayer
+#' that has identical properties to the RasterLayer used to create the TransitionLayer
+#' object. The \code{fidelity} parameter is optional and has the same requirements as
+#' the \code{absorption} parameter. The \code{\link{check}} function can be used to
+#' verify these requirements.
+#'
+#' The advantage of this approach is that it offers slightly more flexibility than
+#' the first option. Namely, it's useful if the TransitionLayer needs additional
+#' modifications before it is normalized with the absorption and fidelity inputs.
+#' The disadvantage compared to the first option is that samc() cannot detect certain
+#' issues when the TransitionLayer is manually created and modified. So if users
+#' do not need to manually modify the TransitionLayer, then the first option for
+#' creating a samc object is recommended.
+#'
+#' \strong{Option 3: P Matrix Input}
 #'
 #' The \code{data} parameter can be used alone to create a \code{\link{samc-class}} object
 #' directly from a preconstructed P matrix. This matrix must be either a base R
@@ -119,69 +136,89 @@ setGeneric(
 setMethod(
   ""samc"",
   signature(data = ""TransitionLayer"",
-            absorption = ""numeric"",
-            fidelity = ""numeric"",
+            absorption = ""RasterLayer"",
+            fidelity = ""RasterLayer"",
             tr_args = ""missing""),
   function(data, absorption, fidelity) {
-    if (any(fidelity < 0, na.rm = TRUE) || any(fidelity > 1, na.rm = TRUE)) {
+    check(absorption, fidelity)
+
+    abs_vec <- as.vector(absorption)
+    fid_vec <- as.vector(fidelity)
+
+    if (any(fid_vec < 0, na.rm = TRUE) || any(fid_vec > 1, na.rm = TRUE)) {
       stop(""Fidelity values must be in range of 0-1"", call. = FALSE)
     }
 
-    if (any(absorption > 1, na.rm = TRUE) || any(absorption < 0, na.rm = TRUE)) {
+    if (any(abs_vec > 1, na.rm = TRUE) || any(abs_vec < 0, na.rm = TRUE)) {
       stop(""Absorption values must be in range of 0-1"", call. = FALSE)
     }
 
-    if (sum(absorption, na.rm = TRUE) == 0) {
+    if (sum(abs_vec, na.rm = TRUE) == 0) {
       stop(""At least one cell must have a total absorption value > 0"", call. = FALSE)
     }
 
-    if (any((fidelity + absorption) > 1, na.rm = TRUE)) {
+    if (any((fid_vec + abs_vec) > 1, na.rm = TRUE)) {
       stop(""No cells can have fidelity + absoprtion > 1"", call. = FALSE)
     }
 
-    tr_mat <- gdistance::transitionMatrix(data)
+    # Create map template
+    m <- absorption
+    m[] <- is.finite(m[])
 
-    if (length(absorption) != nrow(tr_mat)) {
-      stop(""Absorption length does not match number of rows in TransitionLayer"", call. = FALSE)
+    # Get raster
+    rs <- gdistance::raster(data)
+    rs[] <- is.finite(rs[])
+
+    if (!identical(dim(m)[1:2], dim(rs)[1:2])) {
+      stop(""Dimensions of absorption raster does not match dimensions of raster used to create TransitionLayer"")
     }
 
-    if (length(absorption) != length(fidelity)) {
-      stop(""Absorption length does not match Fidelity length"", call. = FALSE)
+    if (!identical(raster::extent(m), raster::extent(rs))) {
+      stop(""Extent of absorption raster does not match extent of raster used to create TransitionLayer"")
     }
 
-    if (!isTRUE(all.equal(is.na(absorption), is.na(fidelity)))) {
-      stop(""NA's in absorption and fidelity do not match"", call. = FALSE)
+    if (!identical(raster::crs(m), raster::crs(rs))) {
+      stop(""Extent of absorption raster does not match extent of raster used to create TransitionLayer"")
+    }
+
+
+    tr_mat <- gdistance::transitionMatrix(data)
+
+    if (length(abs_vec) != nrow(tr_mat)) {
+      stop(""Absorption length does not match number of rows in TransitionLayer"", call. = FALSE)
     }
 
+
     # Normalize the transition Matrix
 
     Matrix::diag(tr_mat) <- 0
 
-    tr_vec_check <- numeric(length(absorption))
-    tr_vec_check[unique(tr_mat@i) + 1] <- NA
+    if (sum(Matrix::rowSums(tr_mat)[which(!m[])]) != 0) {
+       stop(""NA cells in absorption raster correspond to non-zero probabilities in the TransitionLayer"", call. = FALSE)
+    }
 
-    if (isTRUE(all.equal(is.na(absorption), is.na(tr_vec_check)))) {
-      stop(""NA's in absorption do not match with TransitionLayer"", call. = FALSE)
+    if (any(!m[which(Matrix::rowSums(tr_mat) != 0)])) {
+      stop(""Non-zero probabilities in the TransitionLayer correspond to NA cells in absorption raster correspond to "", call. = FALSE)
     }
 
     # Old approach
     tr_mat <- methods::as(tr_mat, ""dgTMatrix"") # dgTMatrix is easier to edit directly
-    tr_mat@x <- (1 - absorption[tr_mat@i + 1] - fidelity[tr_mat@i + 1]) * tr_mat@x / Matrix::rowSums(tr_mat)[tr_mat@i + 1]
+    tr_mat@x <- (1 - abs_vec[tr_mat@i + 1] - fid_vec[tr_mat@i + 1]) * tr_mat@x / Matrix::rowSums(tr_mat)[tr_mat@i + 1]
 
     # New approach that causes crash during one of the dispersal() tests
     #    tr_mat <- (1 - Matrix::rowSums(abs_mat) - fid_vec) * tr_mat / Matrix::rowSums(tr_mat)
 
 
     # Calculate fidelity values rather than assigning directly.
     # This approach ensures that P(abs) + P(fid) = 1 for isolated cells.
-    Matrix::diag(tr_mat) <- 1 - Matrix::rowSums(tr_mat) - absorption
+    Matrix::diag(tr_mat) <- 1 - Matrix::rowSums(tr_mat) - abs_vec
 
     # Remove rows/cols for NA cells
-    excl <- which(is.na(absorption))
+    excl <- which(is.na(abs_vec))
     assign(""raw"", excl, globalenv())
     if (length(excl) > 0) {
       tr_mat = tr_mat[-excl, -excl]
-      absorption <- absorption[-excl]
+      abs_vec <- abs_vec[-excl]
     }
 
     tr_mat <- methods::as(tr_mat, ""dgCMatrix"")
@@ -195,16 +232,16 @@ setMethod(
     if (any(duplicated(colnames(tr_mat))))
       stop(""Column names must be unique"")
 
-    names(absorption) <- rownames(tr_mat)
+    names(abs_vec) <- rownames(tr_mat)
 
     # Assemble final
     samc_mat <- methods::new(""samc"",
                              data = methods::new(""samc_data"",
                                                  q = tr_mat,
-                                                 t_abs = absorption),
+                                                 t_abs = abs_vec),
                              source = ""matrix"",
                              map = raster::raster(matrix()),
-                             clumps = 1,
+                             clumps = -1,
                              override = FALSE,
                              .cache = new.env())
     samc_mat@.cache$dgf = numeric(nrow(tr_mat))
@@ -217,7 +254,7 @@ setMethod(
 setMethod(
   ""samc"",
   signature(data = ""TransitionLayer"",
-            absorption = ""numeric"",
+            absorption = ""RasterLayer"",
             fidelity = ""missing"",
             tr_args = ""missing""),
   function(data, absorption) {
@@ -299,7 +336,7 @@ setMethod(
       warning(""Raster cells are not square (number of columns/rows is not propotional to the spatial extents). There is no defined projection to account for this, so the geocorrection may lead to distortion if the intent was for the raster cells to represent a uniformly spaced grid."", call. = FALSE)
     }
 
-    samc_obj <- samc(tr, abs_vec, fid_vec)
+    samc_obj <- samc(tr, absorption, fidelity)
 
     samc_obj@source = ""map""
     samc_obj@map <- m
@@ -411,7 +448,7 @@ setMethod(
                                                  t_abs = abs_total),
                              source = ""matrix"",
                              map = raster::raster(matrix()),
-                             clumps = 1,
+                             clumps = -1,
                              override = FALSE)
 
     return(samc_obj)"
andrewmarx,samc,90e290107a8c3857a107740af839f2e46df009b0,Andrew Marx,andrewjmarx@gmail.com,2021-05-27T01:40:15Z,Andrew Marx,andrewjmarx@gmail.com,2021-05-27T01:42:10Z,Fix/update TransitionLayer checks,R/samc.R,False,True,True,False,8,1,9,"---FILE: R/samc.R---
@@ -149,14 +149,21 @@ setMethod(
       stop(""Absorption length does not match Fidelity length"", call. = FALSE)
     }
 
-    if (!all.equal(is.na(absorption), is.na(fidelity))) {
+    if (!isTRUE(all.equal(is.na(absorption), is.na(fidelity)))) {
       stop(""NA's in absorption and fidelity do not match"", call. = FALSE)
     }
 
     # Normalize the transition Matrix
 
     Matrix::diag(tr_mat) <- 0
 
+    tr_vec_check <- numeric(length(absorption))
+    tr_vec_check[unique(tr_mat@i) + 1] <- NA
+
+    if (isTRUE(all.equal(is.na(absorption), is.na(tr_vec_check)))) {
+      stop(""NA's in absorption do not match with TransitionLayer"", call. = FALSE)
+    }
+
     # Old approach
     tr_mat <- methods::as(tr_mat, ""dgTMatrix"") # dgTMatrix is easier to edit directly
     tr_mat@x <- (1 - absorption[tr_mat@i + 1] - fidelity[tr_mat@i + 1]) * tr_mat@x / Matrix::rowSums(tr_mat)[tr_mat@i + 1]"
andrewmarx,samc,1c78bb777134043eaf6c18a6b202f3e2061e3bee,Andrew Marx,andrewjmarx@gmail.com,2021-05-01T20:53:08Z,Andrew Marx,andrewjmarx@gmail.com,2021-05-01T20:53:08Z,Fix naming in R matrix,R/samc.R,False,True,True,False,1,2,3,"---FILE: R/samc.R---
@@ -185,7 +185,7 @@ setMethod(
       abs_mat <- matrix(abs_vec, ncol = 1)
     }
 
-    colnames(abs_mat) <- names(abs_mat)
+    colnames(abs_mat) <- names(absorption)
 
     abs_total <- rowSums(abs_mat)
     if (any(abs_total > 1, na.rm = TRUE) || any(abs_total < 0, na.rm = TRUE)) {
@@ -244,7 +244,6 @@ setMethod(
       stop(""Column names must be unique"")
 
     rownames(abs_mat) <- rownames(tr_mat)
-    colnames(abs_mat) <- 1:ncol(abs_mat)
 
     # Assemble final
     samc_mat <- methods::new(""samc"","
andrewmarx,samc,c4e951a08f8bed591bbd81493001bdddcdad6069,Andrew Marx,andrewjmarx@gmail.com,2021-05-01T15:02:05Z,Andrew Marx,andrewjmarx@gmail.com,2021-05-01T15:03:27Z,"mortality(samc, origin, dest) bugfix

Found while updating mortality() tests to check sum of individual
absortption results.",R/mortality.R,False,True,True,False,1,1,2,"---FILE: R/mortality.R---
@@ -405,7 +405,7 @@ setMethod(
     if (ncol(samc$r_matrix) > 1) {
       mort_list <- list()
       for (n in colnames(samc$r_matrix)) {
-        mort_list[[n]] <- mort * samc$r_matrix[dest, n]
+        mort_list[[n]] <- results * samc$r_matrix[dest, n]
       }
       mort_list$total <- mort
       return(mort_list)"
andrewmarx,samc,3d2796d15aed6edb71688747b8022410705c54f4,Andrew Marx,andrewjmarx@gmail.com,2021-04-24T22:45:12Z,Andrew Marx,andrewjmarx@gmail.com,2021-04-24T22:45:12Z,"Commit temporary removal of mult absorption test stuff

Previously commented out to fix bugs. Need to revisit",tests/testthat/helper-data.R;tests/testthat/test-mortality.R,False,True,True,False,13,3,16,"---FILE: tests/testthat/helper-data.R---
@@ -107,8 +107,14 @@ for(i in 1: length(masklist)) {
 
   testlist[[i]]$length <- sum(!is.na(testlist[[i]]$res))
 
+  # Version for mult absorption see mortality(samc, origin)
+  # testlist[[i]]$samc <- samc(testlist[[i]]$res,
+  #                            list(testlist[[i]]$abs * p1, testlist[[i]]$abs * p2),
+  #                            testlist[[i]]$fid,
+  #                            tr_args = list(fun = function(x) 1/mean(x), dir = 8, sym = TRUE))
+
   testlist[[i]]$samc <- samc(testlist[[i]]$res,
-                             list(testlist[[i]]$abs * p1, testlist[[i]]$abs * p2),
+                             testlist[[i]]$abs,
                              testlist[[i]]$fid,
                              tr_args = list(fun = function(x) 1/mean(x), dir = 8, sym = TRUE))
 

---FILE: tests/testthat/test-mortality.R---
@@ -226,8 +226,12 @@ for(test in testlist) {
     result <- mortality(samc_obj, origin = row_vec[1])
     result_char <- mortality(samc_obj, origin = as.character(row_vec[1]))
 
-    expect_equal(result$total, result_char$total)
-    expect_equal(as.vector(result$total), as.vector(base_result[row_vec[1], ]))
+    expect_equal(result, result_char)
+    expect_equal(as.vector(result), as.vector(base_result[row_vec[1], ]))
+
+    # Version for mult absorption
+    # expect_equal(result$total, result_char$total)
+    # expect_equal(as.vector(result$total), as.vector(base_result[row_vec[1], ]))
   })
 
   test_that(""Testing mortality(samc, dest)"", {"
andrewmarx,samc,5a098f43729cc0600a65bbf6036dfdd17705d81b,Andrew Marx,andrewjmarx@gmail.com,2021-04-24T21:48:03Z,Andrew Marx,andrewjmarx@gmail.com,2021-04-24T21:48:03Z,"Update short-term dispersal() metrics

Fix dispersal(samc, dest, time) so that it fills in an NA for i=j. This
is so that the map() function can be used with it.

Update affected metrics and tests",R/dispersal.R;tests/testthat/test-dispersal.R,False,True,True,False,10,4,14,"---FILE: R/dispersal.R---
@@ -120,6 +120,12 @@ setMethod(
 
     res <- lapply(res, as.vector)
 
+    # Element for i=j is missing, so fill in with NA
+    res <- lapply(res, function(x) {
+      lx <- length(x)
+      y <- c(x[0:(dest-1)], NA, x[dest:(lx + 1)])
+      return(y[1:(lx + 1)])})
+
     if (length(res) == 1) {
       return(res[[1]])
     } else {
@@ -147,9 +153,9 @@ setMethod(
     pv <- pv[-dest]
 
     if (is.list(d)) {
-      return(lapply(d, function(x){as.numeric(pv %*% x)}))
+      return(lapply(d, function(x){as.numeric(pv %*% x[-dest])}))
     } else {
-      return(as.numeric(pv %*% d))
+      return(as.numeric(pv %*% d[-dest]))
     }
   })
 

---FILE: tests/testthat/test-dispersal.R---
@@ -46,7 +46,7 @@ for(test in testlist) {
 
     base_result <- base_result %*% qj
 
-    expect_equal(as.vector(result), as.vector(base_result))
+    expect_equal(as.vector(result)[-col_vec[1]], as.vector(base_result))
   })
 
   test_that(""Testing dispersal(samc, dest, time_vec)"", {
@@ -68,7 +68,7 @@ for(test in testlist) {
 
       base_result <- base_result %*% qj
 
-      expect_equal((result[[i]]), as.vector(base_result))
+      expect_equal((result[[i]])[-col_vec[1]], as.vector(base_result))
     }
   })
 "
andrewmarx,samc,bc23f139ee077d068507e82c58b418d6685f69f2,Andrew Marx,andrewjmarx@gmail.com,2021-04-22T20:08:26Z,Andrew Marx,andrewjmarx@gmail.com,2021-04-22T20:08:26Z,"Fix subtle samc() bug when constructing Q

Not sure of exact cause, but this fixes an issue in the Q matrix under
some circumstances",R/samc.R,False,True,True,False,2,2,4,"---FILE: R/samc.R---
@@ -187,7 +187,7 @@ setMethod(
 
     colnames(abs_mat) <- 1:ncol(abs_mat)
 
-    abs_total <- Matrix::rowSums(abs_mat)
+    abs_total <- rowSums(abs_mat)
     if (any(abs_total > 1, na.rm = TRUE) || any(abs_total < 0, na.rm = TRUE)) {
       stop(""Sum of absorption values must be in range of 0-1"", call. = FALSE)
     }
@@ -215,7 +215,7 @@ setMethod(
 
     # Old approach
     tr_mat <- methods::as(tr_mat, ""dgTMatrix"") # dgTMatrix is easier to edit directly
-    tr_mat@x <- (1 - sum(abs_mat[tr_mat@i + 1, ]) - fid_vec[tr_mat@i + 1]) * tr_mat@x / Matrix::rowSums(tr_mat)[tr_mat@i + 1]
+    tr_mat@x <- (1 - abs_total[tr_mat@i + 1] - fid_vec[tr_mat@i + 1]) * tr_mat@x / Matrix::rowSums(tr_mat)[tr_mat@i + 1]
 
     # New approach that causes crash during one of the dispersal() tests
 #    tr_mat <- (1 - Matrix::rowSums(abs_mat) - fid_vec) * tr_mat / Matrix::rowSums(tr_mat)"
andrewmarx,samc,38e75839a26640d80772c6ce7a9b210020760058,Andrew Marx,andrewjmarx@gmail.com,2021-04-22T02:06:02Z,Andrew Marx,andrewjmarx@gmail.com,2021-04-22T02:06:02Z,Doc fixes/updates,R/absorption.R;R/internal-classes.R;R/samc.R,False,True,True,False,16,8,24,"---FILE: R/absorption.R---
@@ -7,9 +7,9 @@ NULL
 
 #' Calculate absorption metrics
 #'
-#' Calculates the total probability of absorption for each absorbing state, rather
+#' Calculates the probability of absorption for absorbing states rather
 #' than individual transient states. This is distint from, yet very closely linked
-#' to the mortality() metric, which calculates the probability of absorption at
+#' to, the mortality() metric, which calculates the probability of absorption at
 #' individual transient states. If the results of the mortality() metric are decomposed
 #' into individual results for each absorbing state, then the sums of the individual
 #' results for every transient state are equivalent to the results of the absorption()

---FILE: R/internal-classes.R---
@@ -1,12 +1,16 @@
-# Copyright (c) 2019 Andrew Marx. All rights reserved.
+# Copyright (c) 2021 Andrew Marx. All rights reserved.
 # Licensed under GPLv3.0. See LICENSE file in the project root for details.
-
+NULL
 
 #' data class
 #'
 #' Contains the data fields used in the samc-class
 #'
-#' @noRd
+#' @slot q Q matrix
+#' @slot r R matrix
+#'
+#' @name samc_data-class
+#' @keywords internal
 
 setClass(
   # set the name of the class

---FILE: R/samc.R---
@@ -37,11 +37,15 @@ NULL
 #' The \code{data} parameter can be used alone to create a \code{\link{samc-class}} object
 #' directly from a preconstructed P matrix. This matrix must be either a base R
 #' matrix, or a sparse matrix (dgCMatrix format) from the Matrix package. It
-#' must meet the requirement of a P matrix described in Fletcher et al. (2019).
-#' This includes:
+#' must meet the following requirements:
 #' \itemize{
 #'   \item The number of rows must equal the number of columns (a square matrix)
-#'   \item The last row must contain all 0's, except the last element, which must be 1
+#'   \item Absorbing states must be a single group located in the right-hand most columns
+#'   \item At the bottom of the matrix, there must be a row for every absorbing state.
+#'   Each of these rows must be filled with 0's except for elements that are part of
+#'   the main diagonal, which must be set to 1
+#'   \item Every disconnected region of the matrix must have at least one non-zero
+#'   absorbing value
 #'   \item Each row must sum to 1
 #'   \item All values must be in the range of 0-1
 #' }"
andrewmarx,samc,ddc85e4e87cf93e63d4519dc7be7a26609af7ebc,Andrew Marx,andrewjmarx@gmail.com,2021-04-21T18:35:19Z,Andrew Marx,andrewjmarx@gmail.com,2021-04-21T18:35:19Z,Fix samc() for P matrix input with multiple absorbing states,R/samc.R,False,True,True,False,14,12,26,"---FILE: R/samc.R---
@@ -181,6 +181,8 @@ setMethod(
       abs_mat <- matrix(abs_vec, ncol = 1)
     }
 
+    colnames(abs_mat) <- 1:ncol(abs_mat)
+
     abs_total <- Matrix::rowSums(abs_mat)
     if (any(abs_total > 1, na.rm = TRUE) || any(abs_total < 0, na.rm = TRUE)) {
       stop(""Sum of absorption values must be in range of 0-1"", call. = FALSE)
@@ -369,18 +371,6 @@ setMethod(
     if (sum(data[r,]) != 1) stop(""Last row must be all zeros with a 1 in the last element"", call. = FALSE)
     if (!isTRUE(all.equal(Matrix::rowSums(data), rep(1, r), check.names = FALSE))) stop(""All row sums must be equal to 1"", call. = FALSE) # Use all.equal() to avoid numerical precision issues
 
-    if (is.null(rownames(data))) rownames(data) <- 1:r
-    if (is.null(colnames(data))) colnames(data) <- 1:c
-
-    rn <- rownames(data)[-r]
-    cn <- colnames(data)[-r]
-
-    if (!isTRUE(all.equal(rn, cn)))
-      stop(""The row and col names of the Q matrix must be identical"", call. = FALSE)
-
-    if (any(duplicated(rn)))
-      stop(""The row and col names of the Q matrix must be unique"", call. = FALSE)
-
     # Figure out number of absorbing states
     p_diag <- Matrix::diag(data)
     r_dim <- 0
@@ -399,6 +389,18 @@ setMethod(
 
     r_start <- r - (r_dim - 1)
 
+    if (is.null(rownames(data))) rownames(data) <- 1:r
+    if (is.null(colnames(data))) colnames(data) <- 1:c
+
+    rn <- rownames(data)[-(r_start:r)]
+    cn <- colnames(data)[-(r_start:r)]
+
+    if (!isTRUE(all.equal(rn, cn)))
+      stop(""The row and col names of the Q matrix must be identical"", call. = FALSE)
+
+    if (any(duplicated(rn)))
+      stop(""The row and col names of the Q matrix must be unique"", call. = FALSE)
+
     print(""Warning: Some checks for manually created P matrices are still missing:"")
     print(""1) Discontinuous data will not work with the cond_passage() function."")
     print(""2) Every disconnected region of the graph must have at least one non-zero absorption value."")"
andrewmarx,samc,2ffa12ca607b62e4206dc3f71f425379b1ddf791,Andrew Marx,andrewjmarx@gmail.com,2021-04-21T18:34:34Z,Andrew Marx,andrewjmarx@gmail.com,2021-04-21T18:34:34Z,fix p_matrix generic accessor,R/generics.R,False,True,True,False,7,2,9,"---FILE: R/generics.R---
@@ -25,8 +25,13 @@ setMethod(""$"", signature(x = ""samc""), function(x, name) {
   } else if (name == ""q_matrix""){
     return(x@data@q)
   } else if (name == ""p_matrix"") {
-    p <- rbind(x@data@q, rep(0, ncol(x@data@q)))
-    p <- cbind(p, c(rowSums(x@data@r), 1))
+    p <- cbind(x@data@q, x@data@r)
+    p <- rbind(p, matrix(0, ncol(x@data@r), ncol(p)))
+    Matrix::diag(p)[(ncol(p) - ncol(x@data@r) + 1):ncol(p)] <- 1
+
+    colnames(p) <- c(colnames(x@data@q), colnames(x@data@r))
+    rownames(p) <- colnames(p)
+
     return(p)
   } else if (name == ""r_matrix""){
     return(x@data@r)"
andrewmarx,samc,ad9f114c7c959f5d6bb4d79c3aa9f0c9e3edc34c,Andrew Marx,andrewjmarx@gmail.com,2021-04-16T12:51:45Z,Andrew Marx,andrewjmarx@gmail.com,2021-04-16T12:51:45Z,Fix survival() doc error,R/survival.R,False,True,True,False,1,1,2,"---FILE: R/survival.R---
@@ -17,7 +17,7 @@ NULL
 #' The result is a vector where each element corresponds to a cell in the
 #' landscape, and can be mapped back to the landscape using the
 #' \code{\link{map}} function. The value of element \emph{i} is the expected
-#' amount of time that individuals survive when starting at location \emph{j}.
+#' amount of time that individuals survive when starting at location \emph{i}.
 #' }
 #'
 #' \eqn{\psi^Tz}"
andrewmarx,samc,0e27c1b405f295a04a48006cb768ff84248180af,Andrew Marx,andrewjmarx@gmail.com,2021-04-15T18:43:45Z,Andrew Marx,andrewjmarx@gmail.com,2021-04-15T18:43:45Z,Fix tests using override,tests/testthat/test-dispersal.R;tests/testthat/test-distribution.R;tests/testthat/test-mortality.R;tests/testthat/test-visitation.R,False,True,True,False,10,10,20,"---FILE: tests/testthat/test-dispersal.R---
@@ -119,9 +119,9 @@ for(test in testlist) {
   })
 
   test_that(""Testing dispersal(samc)"", {
-    override(samc_obj) <- TRUE
+    samc_obj$override <- TRUE
     result <- dispersal(samc_obj)
-    override(samc_obj) <- FALSE
+    samc_obj$override <- FALSE
 
     base_result <- (f - I) %*% fdg
 

---FILE: tests/testthat/test-distribution.R---
@@ -23,9 +23,9 @@ for(test in testlist) {
 
   # Run the tests
   test_that(""Testing distribution(samc, time)"", {
-    override(samc_obj) <- TRUE
+    samc_obj$override <- TRUE
     result <- distribution(samc_obj, time = time)
-    override(samc_obj) <- FALSE
+    samc_obj$override <- FALSE
 
     base_result <- Pt
 

---FILE: tests/testthat/test-mortality.R---
@@ -24,9 +24,9 @@ for(test in testlist) {
 
   # Run the tests
   test_that(""Testing mortality(samc, time)"", {
-    override(samc_obj) <- TRUE
+    samc_obj$override <- TRUE
     result <- mortality(samc_obj, time = time)
-    override(samc_obj) <- FALSE
+    samc_obj$override <- FALSE
 
     base_result <- diag(nrow(Q))
 
@@ -209,9 +209,9 @@ for(test in testlist) {
   })
 
   test_that(""Testing mortality(samc)"", {
-    override(samc_obj) <- TRUE
+    samc_obj$override <- TRUE
     result <- mortality(samc_obj)
-    override(samc_obj) <- FALSE
+    samc_obj$override <- FALSE
 
     base_result <- solve(I - Q) %*% R
 

---FILE: tests/testthat/test-visitation.R---
@@ -16,9 +16,9 @@ for(test in testlist) {
 
   # Run the tests
   test_that(""Testing visitation(samc)"", {
-    override(samc_obj) <- TRUE
+    samc_obj$override <- TRUE
     r <- visitation(samc_obj)
-    override(samc_obj) <- FALSE
+    samc_obj$override <- FALSE
 
     expect_equal(dim(r), dim(base_result))
     expect_equal(as.vector(r), as.vector(base_result))"
andrewmarx,samc,364461382e2387d51949e49df775b0be90c769f5,Andrew Marx,andrewjmarx@gmail.com,2021-04-15T14:38:39Z,Andrew Marx,andrewjmarx@gmail.com,2021-04-15T14:38:39Z,q_matrix bug fix,R/samc-class.R,False,True,True,False,2,2,4,"---FILE: R/samc-class.R---
@@ -44,7 +44,7 @@
 #'   structure of the P and Q matrices in the samc-class, nor should it be assumed
 #'   that they will not change in the future. To safely access the Q matrix, use
 #'   \code{samc_obj$q_matrix}. The Q matrix inside of the samc-class cannot be
-#'   modified
+#'   modified.
 #' }
 #'
 #' @slot p The transition probability matrix \emph{P}.
@@ -80,7 +80,7 @@ setMethod(""$"", signature(x = ""samc""), function(x, name) {
   if(name == ""override""){
     return(x@override)
   } else if (name == ""q_matrix""){
-    return(samc@p[-nrow(samc@p), -nrow(samc@p)])
+    return(x@p[-nrow(x@p), -nrow(x@p)])
   } else {
     warning(""Invalid object specified."", call. = FALSE)
   }"
andrewmarx,samc,1405d363805f7a5dd1cf3de33e22331728e6e62a,Andrew Marx,andrewjmarx@gmail.com,2021-04-14T19:11:14Z,Andrew Marx,andrewjmarx@gmail.com,2021-04-14T19:11:14Z,"Fix raster input handling

Fix check in samc() function

Set crs to NA in rasterize() internal function",R/internal-functions.R;R/samc.R,False,True,True,False,2,3,5,"---FILE: R/internal-functions.R---
@@ -91,7 +91,7 @@
 #' @param x A matrix
 #' @noRd
 .rasterize <- function(x) {
-  return(raster::raster(x, xmn = 0.5, xmx = ncol(x) + 0.5, ymn = 0.5, ymx = nrow(x) + 0.5))
+  return(raster::raster(x, xmn = 0.5, xmx = ncol(x) + 0.5, ymn = 0.5, ymx = nrow(x) + 0.5, crs = NA))
 }
 
 

---FILE: R/samc.R---
@@ -197,8 +197,7 @@ setMethod(
       tr <- gdistance::geoCorrection(tr, type = ""c"")
     }
 
-    if(is.na(raster::projection(resistance)) &&
-       ncol(resistance)/nrow(resistance) != raster::xres(resistance)/raster::yres(resistance)) {
+    if(is.na(raster::projection(resistance)) && raster::xres(resistance) != raster::yres(resistance)) {
       warning(""Raster cells are not square (number of columns/rows is not propotional to the spatial extents). There is no defined projection to account for this, so the geocorrection may lead to distortion if the intent was for the raster cells to represent a uniformly spaced grid."", call. = FALSE)
     }
 "
andrewmarx,samc,6f3af1e45ba455f8e9a8a97e19b977d96dfc3627,Andrew Marx,andrewjmarx@gmail.com,2021-04-03T18:13:36Z,Andrew Marx,andrewjmarx@gmail.com,2021-04-03T18:13:36Z,text fix,NEWS.md,False,False,False,False,1,1,2,"---FILE: NEWS.md---
@@ -3,7 +3,7 @@
 - Fixed an issue with the check() function when data contains NA's.
 - Fixed an issue with the raster returned from locate(samc) having 0 for NA cells.
 - Improved error checking and messaging for the check() and locate() functions.
-- Named rows and columns for the P matrix is now supported. Previously, naming the rows and columns would cause some checks fail. If names are not manually assigned, the names are simply the row/column numbers converted to character strings.
+- Named rows and columns for the P matrix is now supported. Previously, naming the rows and columns would cause some checks to fail. If names are not manually assigned, the names are simply the row/column numbers converted to character strings.
 - Analytical functions updated to support named inputs for the origin and dest location parameters
 - When both the origin and dest parameter is used in a function, the inputs can be paired vectors.
 - Added the pairwise() utility function"
andrewmarx,samc,b1616c49d55aa433b9623f4733e410575d776073,Andrew Marx,andrewjmarx@gmail.com,2021-04-01T19:22:17Z,Andrew Marx,andrewjmarx@gmail.com,2021-04-01T19:22:17Z,spelling fixes,NEWS.md;R/samc.R;vignettes/code-snippets.Rmd;vignettes/overview.Rmd;vignettes/tutorial-locations.Rmd,True,True,True,False,6,6,12,"---FILE: NEWS.md---
@@ -11,7 +11,7 @@
 
 # samc 1.2.1
 
-- Fixed a regression in v1.2.0 where the samc() function would not work corectly unless matrix/raster layers contained at least one NA cell
+- Fixed a regression in v1.2.0 where the samc() function would not work correctly unless matrix/raster layers contained at least one NA cell
 - Revamped the automated test suite with more test scenarios to better catch issues before release
 - Added checks during samc-class creation to prevent potential issues with discontinuous/clumped input data. Currently, this type of data will not work with the cond_passage() function, but will in a future release.
 - Reworked some of the vignettes to produce cleaner pages and remove suggested dependencies (e.g. gifski, gganimate, ggplot2) from the package so that users aren't bugged about installing them if they don't need them.

---FILE: R/samc.R---
@@ -52,7 +52,7 @@ NULL
 #' dimnames(), rowname(), colnames(), etc). When specifying \code{origin} or \code{dest} inputs
 #' to metrics, these names may be used instead of cell numbers. This has the
 #' advantage of making the code for an analysis easier to read and interpret,
-#' which may also help to elimate unintentional mistakes. There are two
+#' which may also help to eliminate unintentional mistakes. There are two
 #' requirements for naming the rows/cols of a P matrix. First, since the P matrix
 #' represents a pairwise matrix, the row and column names must be the same. Second,
 #' there must be no duplicate names. The exception to these rules is the very last

---FILE: vignettes/code-snippets.Rmd---
@@ -18,7 +18,7 @@ knitr::opts_chunk$set(
 
 ## Introduction
 
-This page is home to code that isn't suitable for inclusion in the samc package or dedicated vignettes, but that users may find benificial nonetheless. Some of what is included here may eventually be integrated into the package. Code here is not as thoroughly tested as the package and may not work in all situations or versions of the package.
+This page is home to code that isn't suitable for inclusion in the samc package or dedicated vignettes, but that users may find beneficial nonetheless. Some of what is included here may eventually be integrated into the package. Code here is not as thoroughly tested as the package and may not work in all situations or versions of the package.
 
 
 ## Reshaping output from pairwise()

---FILE: vignettes/overview.Rmd---
@@ -97,7 +97,7 @@ In addition to the extremely important `samc()` function, the package has other
 - The `check()` function is used to check that input landscape data meets the data requirements outlined above. It can be used to compare two `RasterLayer` objects, two `matrix` objects, or check either a `RasterLayer` or a `matrix` against an already created `samc-class` object.
 - The `map()` function is used to simplify mapping vector data back into the landscape and return it as a `RasterLayer`. This is provided because R handles matrices and raster layers somewhat differently when reading and writing vector data, which can cause users to map the data incorrectly if they aren't careful. It also handles mapping to landscapes with NA values, another potential source of error.
 - The `locate()` function is used to get cell numbers for use as origin and dest values in various analytical function arguments. This function should be used instead of `cellFromXY()` in the raster package because `cellFromXY()` cell numbers do not necessarily correspond to cell numbers in the samc package (the samc package does not assign cell numbers to `NA` cells, whereas the raster package does). The `locate()` function can be used to return a `RasterLayer` with the cell numbers encoded as cell values by simply excluding the `xy` argument.
-- The `pairwise()` function is provided to easily and efficiently run specfic metrics for all the pairwise combinations of start and end locations.
+- The `pairwise()` function is provided to easily and efficiently run specific metrics for all the pairwise combinations of start and end locations.
 
 
 ## Analytical Functions

---FILE: vignettes/tutorial-locations.Rmd---
@@ -25,7 +25,7 @@ This tutorial discusses how to perform and retrieve results that are specific to
 
 Most of the analytical functions in this package provide the ability to get results that are specific to particular locations (e.g., cells or transient states). This accomplished through the use of `origin` and `dest` parameters, which correspond to row *i* and column *j* of the P matrix, respectively.
 
-Locations can be specified one of two ways: First, they can be referred to via a positive integer value. These values map directly to the row/columns numbers of the *P* matrix (specifically, the transition matrix portion of *P*, aka *Q*). It's important to not assume that the locations directly correlate to cell numbers in a raster layer or matrix (e.g., location `1` refers to the first cell of a raster). There is a relationship between the two, and in some cases there may be a direct correlation, but if the matrix or raster inputs contain `NA`'s, this will not be the case. This can make the creation and interpretion of location values tricky. The `locate()` function was specifically created to help with this. It can be used to get a raster that shows how the location values map to the raster. It can also be used to map xy coordinates to location values, which is recommended over manually choosing location values since coordinates have a clearer interpretation that makes it easier to catch and fix mistakes in code.
+Locations can be specified one of two ways: First, they can be referred to via a positive integer value. These values map directly to the row/columns numbers of the *P* matrix (specifically, the transition matrix portion of *P*, aka *Q*). It's important to not assume that the locations directly correlate to cell numbers in a raster layer or matrix (e.g., location `1` refers to the first cell of a raster). There is a relationship between the two, and in some cases there may be a direct correlation, but if the matrix or raster inputs contain `NA`'s, this will not be the case. This can make the creation and interpretation of location values tricky. The `locate()` function was specifically created to help with this. It can be used to get a raster that shows how the location values map to the raster. It can also be used to map xy coordinates to location values, which is recommended over manually choosing location values since coordinates have a clearer interpretation that makes it easier to catch and fix mistakes in code.
 
 The second approach is to refer to locations by the row/column names of the *P* matrix. This is more applicable to `samc-class` objects directly created from a P matrix, which can have custom names applied to it via functions such as `dimnames()`, `rownames()`, and/or `colnames()`. It'll be particularly useful via named nodes when graph support is added in a future release. Referring to locations by names has a significant advantage in that it makes it easier to read and interpret the code of an analysis, which in turn can make it easier to catch unintended mistakes (when using integers for location inputs, it may not be obvious that the wrong number was used if it refers to a valid location and returns a result).
 
@@ -131,7 +131,7 @@ data$mort <- mortality(samc_obj, origin = data$origin, dest = data$dest)
 data
 ```
 
-Some users may wish to perform a pairwise analysis of all the combinations of the values in an `origin` vector and a `dest` vector, the results of which can be represented as a pairwise matrix. To accomodate this, the `pairwise()` utility function can be used. Since the input vectors aren't paired, they can be different lengths. The result is in a 'long' format; to convert this result to a pairwise matrix, see the [Code Snippets](code-snippets.html) vignette. 
+Some users may wish to perform a pairwise analysis of all the combinations of the values in an `origin` vector and a `dest` vector, the results of which can be represented as a pairwise matrix. To accommodate this, the `pairwise()` utility function can be used. Since the input vectors aren't paired, they can be different lengths. The result is in a 'long' format; to convert this result to a pairwise matrix, see the [Code Snippets](code-snippets.html) vignette. 
 
 ```{r, fig.show='hold'}
 # Get the result for all the pairwise combinations of two vectors of locations"
andrewmarx,samc,3d2b93969b45c93ccadc56007089e779f6827d21,Andrew Marx,andrewjmarx@gmail.com,2021-03-23T18:12:09Z,Andrew Marx,andrewjmarx@gmail.com,2021-03-23T18:12:09Z,"Update .Rbuildignore

Fix for an issue where building vignettes failed due to some code being
in a subdirectory with a name of ""scripts""",.Rbuildignore,False,False,False,False,0,1,1,"---FILE: .Rbuildignore---
@@ -16,4 +16,3 @@ other
 benchmark
 LICENSE
 index.md
-scripts"
andrewmarx,samc,910ed71750ee93fb32832c69c42bba1a76baf5e5,Andrew Marx,andrewjmarx@gmail.com,2021-03-23T01:21:13Z,Andrew Marx,andrewjmarx@gmail.com,2021-03-23T01:21:13Z,Fix mortality() tests,tests/testthat/test-mortality.R,False,True,True,False,4,4,8,"---FILE: tests/testthat/test-mortality.R---
@@ -44,7 +44,7 @@ for(test in testlist) {
 
   test_that(""Testing mortality(samc, origin, time)"", {
     result <- mortality(samc_obj, origin = row_vec[1], time = time)
-    result_char <- mortality(samc_obj, origin = as.vector(row_vec[1]), time = time)
+    result_char <- mortality(samc_obj, origin = as.character(row_vec[1]), time = time)
     expect_equal(result, result_char)
 
     base_result <- diag(nrow(Q))
@@ -64,7 +64,7 @@ for(test in testlist) {
 
   test_that(""Testing mortality(samc, origin, time_vec)"", {
     result <- mortality(samc_obj, origin = row_vec[1], time = time_vec)
-    result_char <- mortality(samc_obj, origin = as.vector(row_vec[1]), time = time_vec)
+    result_char <- mortality(samc_obj, origin = as.character(row_vec[1]), time = time_vec)
     expect_equal(result, result_char)
 
     for (i in 1:length(time_vec)) {
@@ -86,7 +86,7 @@ for(test in testlist) {
 
   test_that(""Testing mortality(samc, dest, time)"", {
     result <- mortality(samc_obj, dest = col_vec[1], time = time)
-    result_char <- mortality(samc_obj, dest = as.vector(col_vec[1]), time = time)
+    result_char <- mortality(samc_obj, dest = as.character(col_vec[1]), time = time)
     expect_equal(result, result_char)
 
     base_result <- diag(nrow(Q))
@@ -106,7 +106,7 @@ for(test in testlist) {
 
   test_that(""Testing mortality(samc, dest, time_vec)"", {
     result <- mortality(samc_obj, dest = col_vec[1], time = time_vec)
-    result_char <- mortality(samc_obj, dest = as.vector(col_vec[1]), time = time_vec)
+    result_char <- mortality(samc_obj, dest = as.character(col_vec[1]), time = time_vec)
     expect_equal(result, result_char)
 
     for (i in 1:length(time_vec)) {"
andrewmarx,samc,8dab35c5134205f2e7c0136efd868b72778984a7,Andrew Marx,andrewjmarx@gmail.com,2021-03-20T14:47:15Z,Andrew Marx,andrewjmarx@gmail.com,2021-03-20T14:47:15Z,"fix non-critical cond_passage() issue

Technically incorrect, but didn't cause an issue in practice",R/cond_passage.R,False,True,True,False,1,1,2,"---FILE: R/cond_passage.R---
@@ -99,7 +99,7 @@ setMethod(
     if(length(origin) != length(dest))
       stop(""The 'origin' and 'dest' parameters must have the same number of values"", call. = FALSE)
 
-    result <- vector(mode = ""numeric"", length = length(length(origin)))
+    result <- vector(mode = ""numeric"", length = length(origin))
 
     unique_dest <- unique(dest)
 "
andrewmarx,samc,be88c0273b0b9a6dbde428d28751d9b135459c9d,Andrew Marx,andrewjmarx@gmail.com,2021-03-03T00:53:25Z,Andrew Marx,andrewjmarx@gmail.com,2021-03-03T00:53:25Z,"Update locate example

Wrap error producing example code in try() to fix CHECK issue",inst/examples/locate.R,False,True,True,False,1,1,2,"---FILE: inst/examples/locate.R---
@@ -30,4 +30,4 @@ locate(samc_obj, coords)
 coords <- data.frame(x = c(1),
                      y = c(1))
 print(coords)
-locate(samc_obj, coords)
+try(locate(samc_obj, coords))"
andrewmarx,samc,04e8e081c045ec40a34eb2a6fbd1de434a87fc25,Andrew Marx,andrewjmarx@gmail.com,2021-03-03T00:52:31Z,Andrew Marx,andrewjmarx@gmail.com,2021-03-03T00:52:31Z,"Fix cond_passage(samc, origin, dest) bug",R/cond_passage.R,False,True,True,False,1,1,2,"---FILE: R/cond_passage.R---
@@ -107,7 +107,7 @@ setMethod(
       t <- cond_passage(samc, dest = d)
       adj_origin <- origin
       adj_origin[origin > d] <- adj_origin[origin > d] - 1
-      result[dest == d] <- t[origin[dest == d]]
+      result[dest == d] <- t[adj_origin[dest == d]]
     }
 
     result[dest == origin] <- NA"
andrewmarx,samc,127b58c6cb239fafebf0ae9954564b8e0dfe2b38,Andrew Marx,andrewjmarx@gmail.com,2021-03-03T00:33:53Z,Andrew Marx,andrewjmarx@gmail.com,2021-03-03T00:33:53Z,"Fix passed dimnames to validate_names() in cond_passage()

Exclude last row/column names from check since they shouldn't be used by
users",R/cond_passage.R,False,True,True,False,3,3,6,"---FILE: R/cond_passage.R---
@@ -82,7 +82,7 @@ setMethod(
       stop(""dest can only contain a single location for this version of the function"", call. = FALSE)
 
     col_names <- colnames(samc@p)
-    .validate_names(col_names, dest)
+    .validate_names(col_names[-length(col_names)], dest)
 
     return(cond_passage(samc, dest = match(dest, col_names)))
   })
@@ -122,10 +122,10 @@ setMethod(
   function(samc, origin, dest) {
 
     row_names <- rownames(samc@p)
-    .validate_names(row_names, origin)
+    .validate_names(row_names[-length(row_names)], origin)
 
     col_names <- colnames(samc@p)
-    .validate_names(col_names, dest)
+    .validate_names(col_names[-length(col_names)], dest)
 
     return(cond_passage(samc,
                         origin = match(origin, row_names),"
andrewmarx,samc,9e5c66d4b11ae1efc0d1b11051f8b2f688134c54,Andrew Marx,andrewjmarx@gmail.com,2021-03-01T19:34:18Z,Andrew Marx,andrewjmarx@gmail.com,2021-03-01T19:34:18Z,"Fix cond_passage(samc, dest) to enforce a single dest input",R/cond_passage.R,False,True,True,False,2,2,4,"---FILE: R/cond_passage.R---
@@ -58,8 +58,8 @@ setMethod(
     if (samc@clumps > 1)
       stop(""This function cannot be used with discontinuous data"", call. = FALSE)
 
-    if (dest %% 1 != 0 || dest < 1 || dest > (ncol(samc@p) - 1))
-      stop(""dest must be an integer that refers to a cell in the landscape"", call. = FALSE)
+    if (length(dest) != 1 || dest %% 1 != 0 || dest < 1 || dest > (ncol(samc@p) - 1))
+      stop(""dest must be a single integer that refers to a cell in the landscape"", call. = FALSE)
 
     Q <- samc@p[-nrow(samc@p), -nrow(samc@p)]
     qj <- Q[-dest, dest]"
andrewmarx,samc,dbbf90adffaacc12ab5b8b5123a2bda520e9c770,Andrew Marx,andrewjmarx@gmail.com,2020-11-21T14:52:45Z,Andrew Marx,andrewjmarx@gmail.com,2020-11-21T14:52:45Z,Add error for locate() results outside of non-NA cells,R/locate.R,False,True,True,False,2,0,2,"---FILE: R/locate.R---
@@ -73,5 +73,7 @@ setMethod(
 
     result <- raster::extract(ras, xy)
 
+    if (anyNA(result)) stop(""One or more coordinates do not correspond to non-NA cells."", call. = FALSE)
+
     return(result)
   })"
andrewmarx,samc,af31ec893584365ebbfa6abc8196975f49b7c997,Andrew Marx,andrewjmarx@gmail.com,2020-11-21T14:45:02Z,Andrew Marx,andrewjmarx@gmail.com,2020-11-21T14:45:02Z,"Fix locate(samc) NA cells

locate(samc) is returning 0 for cells that should be NA",R/locate.R,False,True,True,False,1,0,1,"---FILE: R/locate.R---
@@ -59,6 +59,7 @@ setMethod(
     ras <- samc@map
     n <- sum(ras[])
     ras[ras] <- 1:n
+    ras[ras[] == 0] <- NA
 
     return(ras)
   })"
andrewmarx,samc,f3301a8fd6525fcf0f558eb1dc2d1f3e76ae6e0f,Andrew Marx,andrewjmarx@gmail.com,2020-11-11T22:02:21Z,Andrew Marx,andrewjmarx@gmail.com,2020-11-11T22:02:21Z,"Implement internal function for converting matrices to rasters

Multiple locations in the package convert a matrix into a RasterLayer.
Every instance of this must be identical. To reduce multiple copies of
identical code and make potential future changes less error prone,
create the internal rasterize() function and implement it throughout the
package",R/check.R;R/dispersal.R;R/distribution.R;R/internal-functions.R;R/mortality.R;R/samc.R;R/survival.R,False,True,True,False,27,16,43,"---FILE: R/check.R---
@@ -60,7 +60,7 @@ setMethod(
   ""check"",
   signature(a = ""matrix"", b = ""missing""),
   function(a){
-    a <- raster::raster(a, xmn = 0.5, xmx = ncol(a) + 0.5, ymn = 0.5, ymx = nrow(a) + 0.5)
+    a <- .rasterize(a)
 
     check(a)
   })
@@ -96,8 +96,8 @@ setMethod(
   ""check"",
   signature(a = ""matrix"", b = ""matrix""),
   function(a, b){
-    a <- raster::raster(a, xmn = 0.5, xmx = ncol(a) + 0.5, ymn = 0.5, ymx = nrow(a) + 0.5)
-    b <- raster::raster(b, xmn = 0.5, xmx = ncol(b) + 0.5, ymn = 0.5, ymx = nrow(b) + 0.5)
+    a <- .rasterize(a)
+    b <- .rasterize(b)
 
     check(a, b)
   })
@@ -120,7 +120,7 @@ setMethod(
   ""check"",
   signature(a = ""samc"", b = ""matrix""),
   function(a, b){
-    b <- raster::raster(b, xmn = 0.5, xmx = ncol(b) + 0.5, ymn = 0.5, ymx = nrow(b) + 0.5)
+    b <- .rasterize(b)
 
     check(a, b)
   })

---FILE: R/dispersal.R---
@@ -153,7 +153,7 @@ setMethod(
   signature(samc = ""samc"", occ = ""matrix"", origin = ""missing"", dest = ""numeric"", time = ""numeric""),
   function(samc, occ, dest, time) {
 
-    occ <- raster::raster(occ, xmn = 0.5, xmx = ncol(occ) + 0.5, ymn = 0.5, ymx = nrow(occ) + 0.5)
+    occ <- .rasterize(occ)
 
     return(dispersal(samc, occ, dest = dest, time = time))
   })
@@ -240,7 +240,7 @@ setMethod(
   signature(samc = ""samc"", occ = ""matrix"", origin = ""missing"", dest = ""missing"", time = ""missing""),
   function(samc, occ) {
 
-    occ <- raster::raster(occ, xmn = 0.5, xmx = ncol(occ) + 0.5, ymn = 0.5, ymx = nrow(occ) + 0.5)
+    occ <- .rasterize(occ)
 
     return(dispersal(samc, occ))
   })
@@ -267,7 +267,7 @@ setMethod(
   signature(samc = ""samc"", occ = ""matrix"", origin = ""missing"", dest = ""numeric"", time = ""missing""),
   function(samc, occ, dest) {
 
-    occ <- raster::raster(occ, xmn = 0.5, xmx = ncol(occ) + 0.5, ymn = 0.5, ymx = nrow(occ) + 0.5)
+    occ <- .rasterize(occ)
 
     return(dispersal(samc, occ, dest = dest))
   })

---FILE: R/distribution.R---
@@ -196,7 +196,7 @@ setMethod(
   signature(samc = ""samc"", occ = ""matrix"", origin = ""missing"", dest = ""missing"", time = ""numeric""),
   function(samc, occ, time) {
 
-    occ <- raster::raster(occ, xmn = 0.5, xmx = ncol(occ) + 0.5, ymn = 0.5, ymx = nrow(occ) + 0.5)
+    occ <- .rasterize(occ)
 
     return(distribution(samc, occ = occ, time = time))
   })

---FILE: R/internal-functions.R---
@@ -67,3 +67,14 @@
   if (any(x > (nrow(samc@p) - 1)))
     stop(""Location values cannot exceed the number of nodes in the landscape"", call. = FALSE)
 }
+
+
+#' Rasterize matrices
+#'
+#' Convert a matrix to a RasterLayer. Ensures consistency of conversion throughout the package
+#'
+#' @param x A matrix
+#' @noRd
+.rasterize <- function(x) {
+  return(raster::raster(x, xmn = 0.5, xmx = ncol(x) + 0.5, ymn = 0.5, ymx = nrow(x) + 0.5))
+}

---FILE: R/mortality.R---
@@ -251,7 +251,7 @@ setMethod(
   signature(samc = ""samc"", occ = ""matrix"", origin = ""missing"", dest = ""missing"", time = ""numeric""),
   function(samc, occ, time) {
 
-    occ <- raster::raster(occ, xmn = 0.5, xmx = ncol(occ) + 0.5, ymn = 0.5, ymx = nrow(occ) + 0.5)
+    occ <- .rasterize(occ)
 
     return(mortality(samc, occ, time = time))
   })
@@ -352,7 +352,7 @@ setMethod(
   signature(samc = ""samc"", occ = ""matrix"", origin = ""missing"", dest = ""missing"", time = ""missing""),
   function(samc, occ) {
 
-    occ <- raster::raster(occ, xmn = 0.5, xmx = ncol(occ) + 0.5, ymn = 0.5, ymx = nrow(occ) + 0.5)
+    occ <- .rasterize(occ)
 
     return(mortality(samc, occ))
   })

---FILE: R/samc.R---
@@ -239,9 +239,9 @@ setMethod(
             p_mat = ""missing""),
   function(resistance, absorption, fidelity, tr_fun, override = FALSE) {
 
-    resistance <- raster::raster(resistance, xmn = 0.5, xmx = ncol(resistance) + 0.5, ymn = 0.5, ymx = nrow(resistance) + 0.5)
-    absorption <- raster::raster(absorption, xmn = 0.5, xmx = ncol(absorption) + 0.5, ymn = 0.5, ymx = nrow(absorption) + 0.5)
-    fidelity <- raster::raster(fidelity, xmn = 0.5, xmx = ncol(fidelity) + 0.5, ymn = 0.5, ymx = nrow(fidelity) + 0.5)
+    resistance <- .rasterize(resistance)
+    absorption <- .rasterize(absorption)
+    fidelity <- .rasterize(fidelity)
 
     #fidelity[is.finite(fidelity)] <- 0
 
@@ -259,8 +259,8 @@ setMethod(
             p_mat = ""missing""),
   function(resistance, absorption, tr_fun, override = FALSE) {
 
-    resistance <- raster::raster(resistance, xmn = 0.5, xmx = ncol(resistance) + 0.5, ymn = 0.5, ymx = nrow(resistance) + 0.5)
-    absorption <- raster::raster(absorption, xmn = 0.5, xmx = ncol(absorption) + 0.5, ymn = 0.5, ymx = nrow(absorption) + 0.5)
+    resistance <- .rasterize(resistance)
+    absorption <- .rasterize(absorption)
 
     return(samc(resistance, absorption, latlon = FALSE, tr_fun = tr_fun, override = override))
   })

---FILE: R/survival.R---
@@ -83,7 +83,7 @@ setMethod(
   signature(samc = ""samc"", occ = ""matrix""),
   function(samc, occ) {
 
-    occ <- raster::raster(occ, xmn = 0.5, xmx = ncol(occ) + 0.5, ymn = 0.5, ymx = nrow(occ) + 0.5)
+    occ <- .rasterize(occ)
 
     return(survival(samc, occ))
   })"
andrewmarx,samc,f0dce5baedc2beb594bb59dbfe7e694b0746abe5,Andrew Marx,andrewjmarx@gmail.com,2020-11-11T21:37:09Z,Andrew Marx,andrewjmarx@gmail.com,2020-11-11T21:37:09Z,"Error message cleanup

Remove function call information from error outputs. This makes the
errors less confusing for users to interpret.

Fix a couple typos",R/cond_passage.R;R/dispersal.R;R/distribution.R;R/internal-functions.R;R/locate.R;R/map.R;R/mortality.R;R/samc.R;R/visitation.R,False,True,True,False,45,45,90,"---FILE: R/cond_passage.R---
@@ -56,10 +56,10 @@ setMethod(
   signature(samc = ""samc"", origin = ""missing"", dest = ""numeric""),
   function(samc, dest) {
     if (samc@clumps > 1)
-      stop(""This function cannot be used with discontinuous data"")
+      stop(""This function cannot be used with discontinuous data"", call. = FALSE)
 
     if (dest %% 1 != 0 || dest < 1 || dest > (ncol(samc@p) - 1))
-      stop(""dest must be an integer that refers to a cell in the landscape"")
+      stop(""dest must be an integer that refers to a cell in the landscape"", call. = FALSE)
 
     Q <- samc@p[-nrow(samc@p), -nrow(samc@p)]
     qj <- Q[-dest, dest]
@@ -83,7 +83,7 @@ setMethod(
     .validate_locations(samc, dest)
 
     if(length(origin) != length(dest))
-      stop(""The 'origin' and 'dest' parameters must have the same number of values"")
+      stop(""The 'origin' and 'dest' parameters must have the same number of values"", call. = FALSE)
 
     result <- vector(mode = ""numeric"", length = length(length(origin)))
 

---FILE: R/dispersal.R---
@@ -103,7 +103,7 @@ setMethod(
     .validate_time_steps(time)
 
     if (dest %% 1 != 0 || dest < 1 || dest > sum(samc@map[], na.rm = TRUE))
-      stop(""dest must be an integer that refers to a cell in the landscape"")
+      stop(""dest must be an integer that refers to a cell in the landscape"", call. = FALSE)
 
     q <- samc@p[-nrow(samc@p), -nrow(samc@p)]
     qv <- q[, dest]
@@ -165,7 +165,7 @@ setMethod(
   function(samc) {
 
     if (!samc@override)
-      stop(""This version of the dispersal() method produces a large dense matrix.\nIn order to run it, create the samc object with the override parameter set to TRUE."")
+      stop(""This version of the dispersal() method produces a large dense matrix.\nIn order to run it, create the samc object with the override parameter set to TRUE."", call. = FALSE)
 
     f <- visitation(samc)
     gc()
@@ -187,7 +187,7 @@ setMethod(
   ""dispersal"",
   signature(samc = ""samc"", occ = ""missing"", origin = ""numeric"", dest = ""missing"", time = ""missing""),
   function(samc, origin) {
-    stop(""A suitably optimized version of this function has not been identified (yet). As a workaround, consider calculation destination columns instead"")
+    stop(""A suitably optimized version of this function has not been identified (yet). As a workaround, consider calculating destination columns instead"", call. = FALSE)
   })
 
 #' @rdname dispersal

---FILE: R/distribution.R---
@@ -81,10 +81,10 @@ setMethod(
   function(samc, time) {
 
     if (!samc@override)
-      stop(""This version of the mortality() method produces a large dense matrix.\nIn order to run it, create the samc object with the override parameter set to TRUE."")
+      stop(""This version of the distribution() method produces a large dense matrix.\nIn order to run it, create the samc object with the override parameter set to TRUE."", call. = FALSE)
 
     if (time %% 1 != 0 || time < 1 || length(time) > 1)
-      stop(""The time argument must be a single positive integer"")
+      stop(""The time argument must be a single positive integer"", call. = FALSE)
 
     q <- as.matrix(samc@p[-nrow(samc@p), -nrow(samc@p)])
 
@@ -153,7 +153,7 @@ setMethod(
     } else if (is.vector(mov)) {
       return(mov[dest])
     } else {
-      stop(""Fatal error: This should not have been possible. Please submit a report with a fully reproducible and simplified example."")
+      stop(""This should not have been possible. Please submit a report with a fully reproducible and simplified example."", call. = FALSE)
     }
   })
 

---FILE: R/internal-functions.R---
@@ -13,22 +13,22 @@
 #' @noRd
 .validate_time_steps <- function(x) {
   if (!is.numeric(x))
-    stop(""The time argument must be a positive integer or a vector of positive integers"")
+    stop(""The time argument must be a positive integer or a vector of positive integers"", call. = FALSE)
 
   if (sum(is.na(x)) > 0)
-    stop(""NA values are not allowed in the time argument"")
+    stop(""NA values are not allowed in the time argument"", call. = FALSE)
 
   if (any(x %% 1 != 0))
-    stop(""Decimal values are not allowed in the time argument"")
+    stop(""Decimal values are not allowed in the time argument"", call. = FALSE)
 
   if (any(x < 1))
-    stop(""All time steps must be positive (greater than 0)"")
+    stop(""All time steps must be positive (greater than 0)"", call. = FALSE)
 
   if (is.unsorted(x))
-    stop(""The provided time steps must be in ascending order."")
+    stop(""The provided time steps must be in ascending order."", call. = FALSE)
 
   if (sum(duplicated(x) > 0))
-    stop(""Duplicate time steps are not allowed in the time argument"")
+    stop(""Duplicate time steps are not allowed in the time argument"", call. = FALSE)
 
   if (any(x > 10000))
     stop(""Due to how the short-term metrics are calculated and the way that
@@ -40,7 +40,7 @@
   limit represents 24.7 years. There is flexibility to increase the limit
   if a justification can be made for it, but it's far more likely that
   users will generally want far fewer time steps for ecologically relevant
-  results and to avoid the cummulative precision issues."")
+  results and to avoid the cummulative precision issues."", call. = FALSE)
 }
 
 
@@ -53,17 +53,17 @@
 #' @noRd
 .validate_locations <- function(samc, x) {
   if (!is.numeric(x))
-    stop(""Locations must be a positive integer or a vector of positive integers"")
+    stop(""Locations must be a positive integer or a vector of positive integers"", call. = FALSE)
 
   if (sum(is.na(x)) > 0)
-    stop(""NA values are not valid locations"")
+    stop(""NA values are not valid locations"", call. = FALSE)
 
   if (any(x %% 1 != 0))
-    stop(""Decimal values are not valid locations"")
+    stop(""Decimal values are not valid locations"", call. = FALSE)
 
   if (any(x < 1))
-    stop(""All location values must be positive (greater than 0)"")
+    stop(""All location values must be positive (greater than 0)"", call. = FALSE)
 
   if (any(x > (nrow(samc@p) - 1)))
-    stop(""Location values cannot exceed the number of nodes in the landscape"")
+    stop(""Location values cannot exceed the number of nodes in the landscape"", call. = FALSE)
 }

---FILE: R/locate.R---
@@ -54,7 +54,7 @@ setMethod(
   ""locate"",
   signature(samc = ""samc"", xy = ""missing""),
   function(samc){
-    if (samc@source != ""map"") stop(""This function can only be used when the samc object was created from raster or matrix inputs for resistance data"")
+    if (samc@source != ""map"") stop(""This function can only be used when the samc object was created from raster or matrix inputs for resistance data"", call. = FALSE)
 
     ras <- samc@map
     n <- sum(ras[])

---FILE: R/map.R---
@@ -42,10 +42,10 @@ setMethod(
   ""map"",
   signature(samc = ""samc"", vec = ""numeric""),
   function(samc, vec){
-    if (samc@source != ""map"") stop(paste(""This function cannot be used with a samc-class object created from a"", samc@source))
+    if (samc@source != ""map"") stop(""This function cannot be used with a samc-class object created from a "", samc@source, call. = FALSE)
 
     if (length(vec) != sum(samc@map[], na.rm = TRUE))
-      stop(""The length of the vector does not match the number of non-NA cells in the landscape data"")
+      stop(""The length of the vector does not match the number of non-NA cells in the landscape data"", call. = FALSE)
 
     ras <- samc@map
 
@@ -60,13 +60,13 @@ setMethod(
   ""map"",
   signature(samc = ""samc"", vec = ""list""),
   function(samc, vec){
-    if (samc@source != ""map"") stop(paste(""This function cannot be used with a samc-class object created from a"", samc@source))
+    if (samc@source != ""map"") stop(""This function cannot be used with a samc-class object created from a "", samc@source, call. = FALSE)
 
     lapply(vec, function(x){
       if (class(x) != ""numeric"")
-        stop(""List contains invalid item(s); all entries must be numeric vectors."")
+        stop(""List contains invalid item(s); all entries must be numeric vectors."", call. = FALSE)
       if (length(x) != sum(samc@map[], na.rm = TRUE))
-        stop(""The length of one or more vectors in the list does not match the number of non-NA cells in the landscape data"")
+        stop(""The length of one or more vectors in the list does not match the number of non-NA cells in the landscape data"", call. = FALSE)
     })
 
     res <- lapply(vec, function(x){

---FILE: R/mortality.R---
@@ -122,10 +122,10 @@ setMethod(
   function(samc, time) {
 
     if (!samc@override)
-      stop(""This version of the mortality() method produces a large dense matrix.\nIn order to run it, create the samc object with the override parameter set to TRUE."")
+      stop(""This version of the mortality() method produces a large dense matrix.\nIn order to run it, create the samc object with the override parameter set to TRUE."", call. = FALSE)
 
     if (time %% 1 != 0 || time < 1 || length(time) > 1)
-      stop(""The time argument must be a single positive integer"")
+      stop(""The time argument must be a single positive integer"", call. = FALSE)
 
     # TODO: remove as.matrix call, which is needed to convert from a sparse to
     # dense matrix for the %^% operator, which means removing expm as a dependency
@@ -213,7 +213,7 @@ setMethod(
     } else if (is.vector(mort)) {
       return(mort[dest])
     } else {
-      stop(""Fatal error: This should not have been possible. Please submit a report with a fully reproducible and simplified example."")
+      stop(""This should not have been possible. Please submit a report with a fully reproducible and simplified example."", call. = FALSE)
     }
   })
 
@@ -263,7 +263,7 @@ setMethod(
   function(samc) {
 
     if (!samc@override)
-      stop(""This version of the mortality() method produces a large dense matrix.\nIn order to run it, create the samc object with the override parameter set to TRUE."")
+      stop(""This version of the mortality() method produces a large dense matrix.\nIn order to run it, create the samc object with the override parameter set to TRUE."", call. = FALSE)
 
     f <- visitation(samc)
     gc()

---FILE: R/samc.R---
@@ -113,38 +113,38 @@ setMethod(
   function(resistance, absorption, fidelity, latlon, tr_fun, override = FALSE) {
 
     if (!is.logical(override))
-      stop(""The override parameter must be set to TRUE or FALSE"")
+      stop(""The override parameter must be set to TRUE or FALSE"", call. = FALSE)
 
     # Make sure the input data all aligns
     check(resistance, absorption)
     check(resistance, fidelity)
 
     if (any(resistance[] <= 0, na.rm = TRUE)) {
-      stop(""The resistance data must not have values <= 0"")
+      stop(""The resistance data must not have values <= 0"", call. = FALSE)
     }
 
     if (any(absorption[] < 0, na.rm = TRUE)) {
-      stop(""The absorption data must not have values <= 0"")
+      stop(""The absorption data must not have values <= 0"", call. = FALSE)
     }
 
     if (any(absorption[] > 1, na.rm = TRUE)) {
-      stop(""The absorption data must not have values > 1"")
+      stop(""The absorption data must not have values > 1"", call. = FALSE)
     }
 
     if (sum(absorption[], na.rm = TRUE) == 0) {
-      stop(""At least one cell must have an absorption value > 0"")
+      stop(""At least one cell must have an absorption value > 0"", call. = FALSE)
     }
 
     if (any(fidelity[] < 0, na.rm = TRUE)) {
-      stop(""The fidelity data must not have values < 0"")
+      stop(""The fidelity data must not have values < 0"", call. = FALSE)
     }
 
     if (any(fidelity[] > 1, na.rm = TRUE)) {
-      stop(""The fidelity data must not have values > 1"")
+      stop(""The fidelity data must not have values > 1"", call. = FALSE)
     }
 
     if (any((fidelity[] + absorption[]) > 1, na.rm = TRUE)) {
-      stop(""No cells can have fidelity + absoprtion > 1"")
+      stop(""No cells can have fidelity + absoprtion > 1"", call. = FALSE)
     }
 
 
@@ -163,7 +163,7 @@ setMethod(
       temp_abs[temp_abs > 0] <- 1
       temp_abs <- temp_abs * cl
 
-      if (!all(1:clumps %in% unique(temp_abs[]))) stop(""All disconnected regions must have at least one non-zero absorption value"")
+      if (!all(1:clumps %in% unique(temp_abs[]))) stop(""All disconnected regions must have at least one non-zero absorption value"", call. = FALSE)
     }
 
 
@@ -278,10 +278,10 @@ setMethod(
     r = nrow(p_mat)
     c = ncol(p_mat)
 
-    if (c != r) stop(""Matrix is not square"")
-    if (p_mat[r, c] != 1) stop(""The last element must be 1"")
-    if (sum(p_mat[r,]) != 1) stop(""Last row must be all zeros with a 1 in the last element"")
-    if (!isTRUE(all.equal(Matrix::rowSums(p_mat), rep(1, r)))) stop(""All row sums must be equal to 1"") # Use all.equal() to avoid numerical precision issues
+    if (c != r) stop(""Matrix is not square"", call. = FALSE)
+    if (p_mat[r, c] != 1) stop(""The last element must be 1"", call. = FALSE)
+    if (sum(p_mat[r,]) != 1) stop(""Last row must be all zeros with a 1 in the last element"", call. = FALSE)
+    if (!isTRUE(all.equal(Matrix::rowSums(p_mat), rep(1, r)))) stop(""All row sums must be equal to 1"", call. = FALSE) # Use all.equal() to avoid numerical precision issues
 
     print(""Warning: Some checks for manually created P matrices are still missing:"")
     print(""1) Discontinuous data will not work with the cond_passage() function."")

---FILE: R/visitation.R---
@@ -68,7 +68,7 @@ setMethod(
   function(samc){
 
     if (!samc@override)
-      stop(""This version of the visitation() method produces a large dense matrix.\nIn order to run it, create the samc object with the override parameter set to TRUE."")
+      stop(""This version of the visitation() method produces a large dense matrix.\nIn order to run it, create the samc object with the override parameter set to TRUE."", call. = FALSE)
 
     q <- samc@p[-nrow(samc@p), -nrow(samc@p)]
     q@x <- -q@x"
andrewmarx,samc,915b800969839e29080cdcdcb252dea31742bb1e,Andrew Marx,andrewjmarx@gmail.com,2020-11-11T17:08:02Z,Andrew Marx,andrewjmarx@gmail.com,2020-11-11T17:08:02Z,"Cleanup additional check() error outputs

Remove function call info from error messages to make error outputs
easier to read and reduce confusion",R/check.R,False,True,True,False,3,3,6,"---FILE: R/check.R---
@@ -47,9 +47,9 @@ setMethod(
   function(a){
 
     if (sum(is.infinite(a[]), na.rm = TRUE) > 0) {
-      stop(""Data contains Inf or -Inf element"")
+      stop(""Data contains Inf or -Inf element"", call. = FALSE)
     } else if (sum(is.nan(a[]), na.rm = TRUE) > 0) {
-      stop(""Data contains NaN elements"")
+      stop(""Data contains NaN elements"", call. = FALSE)
     }
 
     return(TRUE)
@@ -107,7 +107,7 @@ setMethod(
   ""check"",
   signature(a = ""samc"", b = ""RasterLayer""),
   function(a, b){
-    if (a@source != ""map"") stop(paste(""Parameters do not apply to a samc-class object created from a"", a@source))
+    if (a@source != ""map"") stop(""Parameters do not apply to a samc-class object created from a "", a@source, call. = FALSE)
 
     a <- a@map
     a[!a[]] <- NA"
andrewmarx,samc,822ce9446abcd9d705d7307d56691c8d2b68df65,Andrew Marx,andrewjmarx@gmail.com,2020-11-11T15:35:44Z,Andrew Marx,andrewjmarx@gmail.com,2020-11-11T15:35:44Z,"Cleanup check() error messages

Remove function call info from error messages

Rewrite error case for mismatched NA data to be more clear from default
compareRaster() output",R/check.R,False,True,True,False,26,2,28,"---FILE: R/check.R---
@@ -76,7 +76,19 @@ setMethod(
     a[] <- is.finite(a[])
     b[] <- is.finite(b[])
 
-    raster::compareRaster(a, b, values = TRUE)
+    tryCatch(
+      {
+        raster::compareRaster(a, b, values = TRUE)
+      },
+      error = function(e) {
+        if(grepl(""not all objects have the same values"", e$message)) {
+          msg = ""NA mismatch""
+        } else {
+          msg = e$message
+        }
+        stop(msg, "" in input data"", call. = FALSE)
+      }
+    )
   })
 
 #' @rdname check
@@ -101,7 +113,19 @@ setMethod(
 
     b[] <- is.finite(b[])
 
-    raster::compareRaster(a@map, b, values = TRUE)
+    tryCatch(
+      {
+        raster::compareRaster(a@map, b, values = TRUE)
+      },
+      error = function(e) {
+        if(grepl(""not all objects have the same values"", e$message)) {
+          msg = ""NA mismatch""
+        } else {
+          msg = e$message
+        }
+        stop(msg, "" in input data"", call. = FALSE)
+      }
+    )
   })
 
 #' @rdname check"
andrewmarx,samc,a2eff9f689f3c7113630249e5e11da87d5af7305,Andrew Marx,andrewjmarx@gmail.com,2020-11-10T17:54:40Z,Andrew Marx,andrewjmarx@gmail.com,2020-11-10T17:54:40Z,"Fix check() function

Add missing argument to fix NA checks with samc-class objects",R/check.R,False,True,True,False,1,1,2,"---FILE: R/check.R---
@@ -101,7 +101,7 @@ setMethod(
 
     b[] <- is.finite(b[])
 
-    raster::compareRaster(a@map, b)
+    raster::compareRaster(a@map, b, values = TRUE)
   })
 
 #' @rdname check"
andrewmarx,samc,b42c493eabe2c9ef9cd236ccdff290d4ae98205f,Andrew Marx,andrewjmarx@gmail.com,2020-10-31T16:25:37Z,Andrew Marx,andrewjmarx@gmail.com,2020-10-31T16:25:37Z,"Remove conflicting helper variables

Helper variables that have the same name as loaded functions are causing
issues with devtools::test(). To get around this for the col and row
variables, just use the first element of the col_vec and row_vec
variables",tests/testthat/helper-data.R;tests/testthat/test-cond_passage.R;tests/testthat/test-dispersal.R;tests/testthat/test-distribution.R;tests/testthat/test-mortality.R;tests/testthat/test-visitation.R,False,True,True,False,65,67,132,"---FILE: tests/testthat/helper-data.R---
@@ -115,15 +115,13 @@ for(m in masklist) {
 }
 
 for(i in 1: length(testlist)) {
-  print(paste(""Building samc object"", i))
   testlist[[i]]$length <- sum(!is.na(testlist[[i]]$res))
 
   testlist[[i]]$samc <- samc(testlist[[i]]$res, testlist[[i]]$abs, testlist[[i]]$fid, tr_fun = function(x) 1/mean(x), override = TRUE)
 }
 
 
-row = 13
-col = 23
+
 time = 100
 time_vec = c(3, 5, 7, 11, 13)
 row_vec = c(7, 34, 5, 5)

---FILE: tests/testthat/test-cond_passage.R---
@@ -12,13 +12,13 @@ samc_p <- samc(p_mat = samc_obj@p)
 Q <- samc_obj@p[-nrow(samc_obj@p), -ncol(samc_obj@p)]
 Q <- as.matrix(Q)
 
-qj <- Q[-col, col]
-Qj <- Q[-col, -col]
+qj <- Q[-col_vec[1], col_vec[1]]
+Qj <- Q[-col_vec[1], -col_vec[1]]
 
 I <- diag(nrow(Qj))
 
 r <- samc_obj@p[-nrow(samc_obj@p), ncol(samc_obj@p)]
-r <- r[-col]
+r <- r[-col_vec[1]]
 
 R <- cbind(r, qj)
 
@@ -38,7 +38,7 @@ result <- as.numeric(result)
 # Run the tests
 test_that(""Testing cond_passage(samc, dest)"", {
 
-  r1 <- cond_passage(samc_p, dest = col)
+  r1 <- cond_passage(samc_p, dest = col_vec[1])
 
   # Verify
   expect_equal(dim(r1), dim(result))
@@ -47,12 +47,12 @@ test_that(""Testing cond_passage(samc, dest)"", {
 
 test_that(""Testing cond_passage(samc, origin, dest)"", {
 
-  r1 <- cond_passage(samc_p, origin = row, dest = col)
+  r1 <- cond_passage(samc_p, origin = row_vec[1], dest = col_vec[1])
 
   r_vec <- cond_passage(samc_p, row_vec, col_vec)
 
   # Verify
-  expect_equal(as.vector(r1), as.vector(result[row]))
+  expect_equal(as.vector(r1), as.vector(result[row_vec[1]]))
   for (i in 1:length(row_vec)) {
     r1 <- cond_passage(samc_p, row_vec[i], col_vec[i])
     expect_equal(r_vec[i], r1)

---FILE: tests/testthat/test-dispersal.R---
@@ -23,11 +23,11 @@ pv <- pv[is.finite(pv)]
 #Run the tests
 test_that(""Testing dispersal(samc, dest, time)"", {
 
-  r1 <- dispersal(samc_obj, dest = col, time = time)
+  r1 <- dispersal(samc_obj, dest = col_vec[1], time = time)
 
-  qj <- Q[-col, col]
+  qj <- Q[-col_vec[1], col_vec[1]]
 
-  Qj <- Q[-col,-col]
+  Qj <- Q[-col_vec[1],-col_vec[1]]
 
   Qji <- diag(nrow(Qj))
   r2 <- Qji
@@ -46,11 +46,11 @@ test_that(""Testing dispersal(samc, dest, time)"", {
 
 test_that(""Testing dispersal(samc, dest, time_vec)"", {
 
-  r1 <- dispersal(samc_obj, dest = col, time = time_vec)
+  r1 <- dispersal(samc_obj, dest = col_vec[1], time = time_vec)
 
-  qj <- Q[-col, col]
+  qj <- Q[-col_vec[1], col_vec[1]]
 
-  Qj <- Q[-col,-col]
+  Qj <- Q[-col_vec[1],-col_vec[1]]
   for (i in 1:length(time_vec)) {
     Qji <- diag(nrow(Qj))
     r2 <- Qji
@@ -69,11 +69,11 @@ test_that(""Testing dispersal(samc, dest, time_vec)"", {
 
 test_that(""Testing dispersal(samc, occ, dest, time)"", {
 
-  r1 <- dispersal(samc_obj, occ = occ, dest = col, time = time)
+  r1 <- dispersal(samc_obj, occ = occ, dest = col_vec[1], time = time)
 
-  qj <- Q[-col, col]
+  qj <- Q[-col_vec[1], col_vec[1]]
 
-  Qj <- Q[-col,-col]
+  Qj <- Q[-col_vec[1],-col_vec[1]]
 
   Qji <- diag(nrow(Qj))
   r2 <- Qji
@@ -83,20 +83,20 @@ test_that(""Testing dispersal(samc, occ, dest, time)"", {
     r2 <- r2 + Qji
   }
 
-  r2 <- pv[-col] %*% (r2 %*% qj)
+  r2 <- pv[-col_vec[1]] %*% (r2 %*% qj)
 
   # Verify
   expect_equal(r1, as.numeric(r2))
 })
 
 test_that(""Testing dispersal(samc, occ, dest, time_vec)"", {
 
-  r1 <- dispersal(samc_obj, occ = occ, dest = col, time = time_vec)
+  r1 <- dispersal(samc_obj, occ = occ, dest = col_vec[1], time = time_vec)
 
-  qj <- Q[-col, col]
+  qj <- Q[-col_vec[1], col_vec[1]]
 
   for (i in 1:length(time_vec)) {
-    Qj <- Q[-col,-col]
+    Qj <- Q[-col_vec[1],-col_vec[1]]
 
     Qji <- diag(nrow(Qj))
     r2 <- Qji
@@ -106,7 +106,7 @@ test_that(""Testing dispersal(samc, occ, dest, time_vec)"", {
       r2 <- r2 + Qji
     }
 
-    r2 <- pv[-col] %*% (r2 %*% qj)
+    r2 <- pv[-col_vec[1]] %*% (r2 %*% qj)
 
     # Verify
     expect_equal(r1[[i]], as.numeric(r2))
@@ -134,7 +134,7 @@ test_that(""Testing dispersal(samc, origin)"", {
 
   skip(""dispersal(samc, origin) is not implemented"")
 
-  r1 <- dispersal(samc_obj, origin = row)
+  r1 <- dispersal(samc_obj, origin = row_vec[1])
 
   f <- solve(I - Q)
 
@@ -144,12 +144,12 @@ test_that(""Testing dispersal(samc, origin)"", {
   r2 <- (f - I) %*% fdg
 
   # Verify
-  expect_equal(as.vector(r1), as.vector(r2[row, ]))
+  expect_equal(as.vector(r1), as.vector(r2[row_vec[1], ]))
 })
 
 test_that(""Testing dispersal(samc, dest)"", {
 
-  r1 <- dispersal(samc_obj, dest = col)
+  r1 <- dispersal(samc_obj, dest = col_vec[1])
 
   f <- solve(I - Q)
 
@@ -159,12 +159,12 @@ test_that(""Testing dispersal(samc, dest)"", {
   r2 <- (f - I) %*% fdg
 
   # Verify
-  expect_equal(as.vector(r1), as.vector(r2[, col]))
+  expect_equal(as.vector(r1), as.vector(r2[, col_vec[1]]))
 })
 
 test_that(""Testing dispersal(samc, origin, dest)"", {
 
-  r1 <- dispersal(samc_obj, origin = row, dest = col)
+  r1 <- dispersal(samc_obj, origin = row_vec[1], dest = col_vec[1])
 
   f <- solve(I - Q)
 
@@ -174,7 +174,7 @@ test_that(""Testing dispersal(samc, origin, dest)"", {
   r2 <- (f - I) %*% fdg
 
   # Verify
-  expect_equal(as.vector(r1), as.vector(r2[row, col]))
+  expect_equal(as.vector(r1), as.vector(r2[row_vec[1], col_vec[1]]))
 })
 
 test_that(""Testing dispersal(samc, occ)"", {
@@ -195,7 +195,7 @@ test_that(""Testing dispersal(samc, occ)"", {
 
 test_that(""Testing dispersal(samc, occ, dest)"", {
 
-  r1 <- dispersal(samc_obj, occ = occ, dest = col)
+  r1 <- dispersal(samc_obj, occ = occ, dest = col_vec[1])
 
   f <- solve(I - Q)
 
@@ -205,5 +205,5 @@ test_that(""Testing dispersal(samc, occ, dest)"", {
   r2 <- pv %*% (f - I) %*% fdg
 
   # Verify
-  expect_equal(r1, as.vector(r2)[col])
+  expect_equal(r1, as.vector(r2)[col_vec[1]])
 })

---FILE: tests/testthat/test-distribution.R---
@@ -34,24 +34,24 @@ test_that(""Testing distribution(samc, time)"", {
 
 test_that(""Testing distribution(samc, origin, time)"", {
 
-  r1 <- distribution(samc_obj, origin = row, time = time)
+  r1 <- distribution(samc_obj, origin = row_vec[1], time = time)
 
-  r2 <- Pt[row, ]
+  r2 <- Pt[row_vec[1], ]
 
   # Verify
   expect_equal(r1, r2)
 })
 
 test_that(""Testing distribution(samc, origin, time_vec)"", {
 
-  r1 <- distribution(samc_obj, origin = row, time = time_vec)
+  r1 <- distribution(samc_obj, origin = row_vec[1], time = time_vec)
 
   for (i in 1:length(time_vec)) {
     pt <- Q
     for (j in 2:time_vec[i]) {
       pt <- pt %*% Q
     }
-    r2 <- pt[row, ]
+    r2 <- pt[row_vec[1], ]
 
     # Verify
     expect_equal(r1[[i]], r2)
@@ -60,24 +60,24 @@ test_that(""Testing distribution(samc, origin, time_vec)"", {
 
 test_that(""Testing distribution(samc, dest, time)"", {
 
-  r1 <- distribution(samc_obj, dest = col, time = time)
+  r1 <- distribution(samc_obj, dest = col_vec[1], time = time)
 
-  r2 <- Pt[, col]
+  r2 <- Pt[, col_vec[1]]
 
   # Verify
   expect_equal(r1, r2)
 })
 
 test_that(""Testing distribution(samc, dest, time_vec)"", {
 
-  r1 <- distribution(samc_obj, dest = col, time = time_vec)
+  r1 <- distribution(samc_obj, dest = col_vec[1], time = time_vec)
 
   for (i in 1:length(time_vec)) {
     pt <- Q
     for (j in 2:time_vec[i]) {
       pt <- Q %*% pt
     }
-    r2 <- pt[, col]
+    r2 <- pt[, col_vec[1]]
 
     # Verify
     expect_equal(r1[[i]], r2)
@@ -86,24 +86,24 @@ test_that(""Testing distribution(samc, dest, time_vec)"", {
 
 test_that(""Testing distribution(samc, origin, dest, time)"", {
 
-  r1 <- distribution(samc_obj, origin = row, dest = col, time = time)
+  r1 <- distribution(samc_obj, origin = row_vec[1], dest = col_vec[1], time = time)
 
-  r2 <- Pt[row, col]
+  r2 <- Pt[row_vec[1], col_vec[1]]
 
   # Verify
   expect_equal(r1, r2)
 })
 
 test_that(""Testing distribution(samc, origin, dest, time_vec)"", {
 
-  r1 <- distribution(samc_obj, origin = row, dest = col, time = time_vec)
+  r1 <- distribution(samc_obj, origin = row_vec[1], dest = col_vec[1], time = time_vec)
 
   for (i in 1:length(time_vec)) {
     pt <- Q
     for (j in 2:time_vec[i]) {
       pt <- pt %*% Q
     }
-    r2 <- pt[row, col]
+    r2 <- pt[row_vec[1], col_vec[1]]
 
     # Verify
     expect_equal(r1[[i]], r2)

---FILE: tests/testthat/test-mortality.R---
@@ -44,7 +44,7 @@ test_that(""Testing mortality(samc, time)"", {
 
 test_that(""Testing mortality(samc, origin, time)"", {
 
-  r1 <- mortality(samc_obj, origin = row, time = time)
+  r1 <- mortality(samc_obj, origin = row_vec[1], time = time)
 
   r2 <- diag(nrow(Q))
 
@@ -58,12 +58,12 @@ test_that(""Testing mortality(samc, origin, time)"", {
   r2 <- r2 %*% R
 
   # Verify
-  expect_equal(as.vector(r1), as.vector(r2[row, ]))
+  expect_equal(as.vector(r1), as.vector(r2[row_vec[1], ]))
 })
 
 test_that(""Testing mortality(samc, origin, time_vec)"", {
 
-  r1 <- mortality(samc_obj, origin = row, time = time_vec)
+  r1 <- mortality(samc_obj, origin = row_vec[1], time = time_vec)
 
   for (i in 1:length(time_vec)) {
     r2 <- diag(nrow(Q))
@@ -78,13 +78,13 @@ test_that(""Testing mortality(samc, origin, time_vec)"", {
     r2 <- r2 %*% R
 
     # Verify
-    expect_equal(r1[[i]], as.vector(r2[row, ]))
+    expect_equal(r1[[i]], as.vector(r2[row_vec[1], ]))
   }
 })
 
 test_that(""Testing mortality(samc, dest, time)"", {
 
-  r1 <- mortality(samc_obj, dest = col, time = time)
+  r1 <- mortality(samc_obj, dest = col_vec[1], time = time)
 
   r2 <- diag(nrow(Q))
 
@@ -98,12 +98,12 @@ test_that(""Testing mortality(samc, dest, time)"", {
   r2 <- r2 %*% R
 
   # Verify
-  expect_equal(as.vector(r1), as.vector(r2[, col]))
+  expect_equal(as.vector(r1), as.vector(r2[, col_vec[1]]))
 })
 
 test_that(""Testing mortality(samc, dest, time_vec)"", {
 
-  r1 <- mortality(samc_obj, dest = col, time = time_vec)
+  r1 <- mortality(samc_obj, dest = col_vec[1], time = time_vec)
 
   for (i in 1:length(time_vec)) {
     r2 <- diag(nrow(Q))
@@ -118,13 +118,13 @@ test_that(""Testing mortality(samc, dest, time_vec)"", {
     r2 <- r2 %*% R
 
     # Verify
-    expect_equal(r1[[i]], as.vector(r2[, col]))
+    expect_equal(r1[[i]], as.vector(r2[, col_vec[1]]))
   }
 })
 
 test_that(""Testing mortality(samc, origin, dest, time)"", {
 
-  r1 <- mortality(samc_obj, origin = row, dest = col, time = time)
+  r1 <- mortality(samc_obj, origin = row_vec[1], dest = col_vec[1], time = time)
 
   r2 <- diag(nrow(Q))
 
@@ -138,12 +138,12 @@ test_that(""Testing mortality(samc, origin, dest, time)"", {
   r2 <- r2 %*% R
 
   # Verify
-  expect_equal(as.vector(r1), as.vector(r2[row, col]))
+  expect_equal(as.vector(r1), as.vector(r2[row_vec[1], col_vec[1]]))
 })
 
 test_that(""Testing mortality(samc, origin, dest, time_vec)"", {
 
-  r1 <- mortality(samc_obj, origin = row, dest = col, time = time_vec)
+  r1 <- mortality(samc_obj, origin = row_vec[1], dest = col_vec[1], time = time_vec)
 
   for (i in 1:length(time_vec)) {
     r2 <- diag(nrow(Q))
@@ -158,7 +158,7 @@ test_that(""Testing mortality(samc, origin, dest, time_vec)"", {
     r2 <- r2 %*% R
 
     # Verify
-    expect_equal(r1[[i]], as.vector(r2[row, col]))
+    expect_equal(r1[[i]], as.vector(r2[row_vec[1], col_vec[1]]))
   }
 })
 
@@ -215,32 +215,32 @@ test_that(""Testing mortality(samc)"", {
 
 test_that(""Testing mortality(samc, origin)"", {
 
-  r1 <- mortality(samc_obj, origin = row)
+  r1 <- mortality(samc_obj, origin = row_vec[1])
 
   r2 <- solve(I - Q) %*% R
 
   # Verify
-  expect_equal(as.vector(r1), as.vector(r2[row, ]))
+  expect_equal(as.vector(r1), as.vector(r2[row_vec[1], ]))
 })
 
 test_that(""Testing mortality(samc, dest)"", {
 
-  r1 <- mortality(samc_obj, dest = col)
+  r1 <- mortality(samc_obj, dest = col_vec[1])
 
   r2 <- solve(I - Q) %*% R
 
   # Verify
-  expect_equal(as.vector(r1), as.vector(r2[, col]))
+  expect_equal(as.vector(r1), as.vector(r2[, col_vec[1]]))
 })
 
 test_that(""Testing mortality(samc, origin, dest)"", {
 
-  r1 <- mortality(samc_obj, origin = row, dest = col)
+  r1 <- mortality(samc_obj, origin = row_vec[1], dest = col_vec[1])
 
   r2 <- solve(I - Q) %*% R
 
   # Verify
-  expect_equal(as.vector(r1), as.vector(r2[row, col]))
+  expect_equal(as.vector(r1), as.vector(r2[row_vec[1], col_vec[1]]))
 })
 
 test_that(""Testing mortality(samc, occ)"", {

---FILE: tests/testthat/test-visitation.R---
@@ -25,30 +25,30 @@ test_that(""Testing visitation(samc)"", {
 
 test_that(""Testing visitation(samc, origin)"", {
 
-  r1 <- visitation(samc_obj, origin = row)
+  r1 <- visitation(samc_obj, origin = row_vec[1])
 
   r2 <- solve(I - Q)
 
   # Verify equality
-  expect_equal(r1, r2[row, ])
+  expect_equal(r1, r2[row_vec[1], ])
 })
 
 test_that(""Testing visitation(samc, dest)"", {
 
-  r1 <- visitation(samc_obj, dest = col)
+  r1 <- visitation(samc_obj, dest = col_vec[1])
 
   r2 <- solve(I - Q)
 
   # Verify equality
-  expect_equal(r1, r2[, col])
+  expect_equal(r1, r2[, col_vec[1]])
 })
 
 test_that(""Testing visitation(samc, origin, dest)"", {
 
-  r1 <- visitation(samc_obj, origin = row, dest = col)
+  r1 <- visitation(samc_obj, origin = row_vec[1], dest = col_vec[1])
 
   r2 <- solve(I - Q)
 
   # Verify equality
-  expect_equal(r1, r2[row, col])
+  expect_equal(r1, r2[row_vec[1], col_vec[1]])
 })"
andrewmarx,samc,2b2d69526ac8bb72887938f5252a13475bbc8c0e,Andrew Marx,andrewjmarx@gmail.com,2020-10-28T00:23:25Z,Andrew Marx,andrewjmarx@gmail.com,2020-10-28T00:23:25Z,Fix P matrix construction for data without NA values,R/samc.R,False,True,True,False,1,1,2,"---FILE: R/samc.R---
@@ -182,7 +182,7 @@ setMethod(
 
     # Remove rows/cols for NA cells
     excl <- which(is.na(abs_vec))
-    p = p[-excl, -excl]
+    if (length(excl) > 0) p = p[-excl, -excl]
 
     # Assemble final
     m <- resistance"
andrewmarx,samc,16ed3ba24b36a65fe54952b86c6cdb5cec525ba9,Andrew Marx,andrewjmarx@gmail.com,2020-10-14T02:29:32Z,Andrew Marx,andrewjmarx@gmail.com,2020-10-14T02:29:32Z,Fix doc typo,NEWS.md;R/locate.R;docs/news/index.html;docs/pkgdown.yml;docs/reference/locate.html;man/locate.Rd,False,True,True,False,9,9,18,"---FILE: NEWS.md---
@@ -3,7 +3,7 @@
 New Features:
 - Added the ability to create samc-class objects from a custom P matrix using p_mat parameter in samc(). See the samc() documentation for details
 - Added the cond_passage() function, which calculates conditional mean first passage times
-- Added the locate() function, which functions similarly to the cellsFromXY() function in the raster package. It's used to get cell numbers from xy coords, but unlike cellsFromXY(), it properly accounts for how cells are numbered when the P matrix is constructed.
+- Added the locate() function, which functions similarly to the cellFromXY() function in the raster package. It's used to get cell numbers from xy coords, but unlike cellFromXY(), it properly accounts for how cells are numbered when the P matrix is constructed.
 - Adjusted the absorption inputs to support values of 0 (i.e., no absorption). Currently, at least one cell must have a non-zero value
 
 Bug Fixes:

---FILE: R/locate.R---
@@ -18,8 +18,8 @@ NULL
 #' trying to determine the cell numbers that should be used in analyses.
 #'
 #' The \code{\link{locate}} function operates more-or-less like the
-#' \code{\link[raster]{cellsFromXY}} function in the raster package, but unlike
-#' \code{\link[raster]{cellsFromXY}}, locate properly accounts for NA cells
+#' \code{\link[raster]{cellFromXY}} function in the raster package, but unlike
+#' \code{\link[raster]{cellFromXY}}, locate properly accounts for NA cells
 #' in identifying cell numbers from coordinate data.
 #'
 #' This function can also be used if the samc object was created from matrix inputs

---FILE: docs/news/index.html---
@@ -155,7 +155,7 @@ <h1 class=""page-header"" data-toc-text=""1.2.0"">
 <ul>
 <li>Added the ability to create samc-class objects from a custom P matrix using p_mat parameter in samc(). See the samc() documentation for details</li>
 <li>Added the cond_passage() function, which calculates conditional mean first passage times</li>
-<li>Added the locate() function, which functions similarly to the cellsFromXY() function in the raster package. Its used to get cell numbers from xy coords, but unlike cellsFromXY(), it properly accounts for how cells are numbered when the P matrix is constructed.</li>
+<li>Added the locate() function, which functions similarly to the cellFromXY() function in the raster package. Its used to get cell numbers from xy coords, but unlike cellFromXY(), it properly accounts for how cells are numbered when the P matrix is constructed.</li>
 <li>Adjusted the absorption inputs to support values of 0 (i.e., no absorption). Currently, at least one cell must have a non-zero value</li>
 </ul>
 <p>Bug Fixes:</p>

---FILE: docs/pkgdown.yml---
@@ -9,5 +9,5 @@ articles:
   tutorial-basic: tutorial-basic.html
   tutorial-ggplot: tutorial-ggplot.html
   tutorial-temporal: tutorial-temporal.html
-last_built: 2020-10-14T01:45Z
+last_built: 2020-10-14T02:14Z
 

---FILE: docs/reference/locate.html---
@@ -187,8 +187,8 @@ <h2 class=""hasAnchor"" id=""details""><a class=""anchor"" href=""#details""></a>Details
 associated with this data are excluded from the P matrix. This causes issues
 trying to determine the cell numbers that should be used in analyses.</p>
 <p>The <code>locate</code> function operates more-or-less like the
-<code>cellsFromXY</code> function in the raster package, but unlike
-<code>cellsFromXY</code>, locate properly accounts for NA cells
+<code><a href='https://rdrr.io/pkg/raster/man/cellFrom.html'>cellFromXY</a></code> function in the raster package, but unlike
+<code><a href='https://rdrr.io/pkg/raster/man/cellFrom.html'>cellFromXY</a></code>, locate properly accounts for NA cells
 in identifying cell numbers from coordinate data.</p>
 <p>This function can also be used if the samc object was created from matrix inputs
 for the resistance, absorption, and fidelity parameters. In this case, the

---FILE: man/locate.Rd---
@@ -33,8 +33,8 @@ associated with this data are excluded from the P matrix. This causes issues
 trying to determine the cell numbers that should be used in analyses.
 
 The \code{\link{locate}} function operates more-or-less like the
-\code{\link[raster]{cellsFromXY}} function in the raster package, but unlike
-\code{\link[raster]{cellsFromXY}}, locate properly accounts for NA cells
+\code{\link[raster]{cellFromXY}} function in the raster package, but unlike
+\code{\link[raster]{cellFromXY}}, locate properly accounts for NA cells
 in identifying cell numbers from coordinate data.
 
 This function can also be used if the samc object was created from matrix inputs"
andrewmarx,samc,2e82f058cff8c5ca9a06344e3fab10b4134c1a17,Andrew Marx,andrewjmarx@gmail.com,2020-10-07T19:53:15Z,Andrew Marx,andrewjmarx@gmail.com,2020-10-07T19:53:15Z,Doc fix,R/locate.R,False,True,True,False,2,1,3,"---FILE: R/locate.R---
@@ -24,7 +24,8 @@ NULL
 #'
 #' This function can also be used if the samc object was created from matrix inputs
 #' for the resistance, absorption, and fidelity parameters. In this case, the
-#' values in the xy coordinate parameter can be column-row values.
+#' values in the xy coordinate parameter can be column-row values with the caveat
+#' that (1,1) is the bottom left corner.
 #'
 #' The xy parameter can also be excluded. In this case, the function returns a
 #' raster where the values of the cells contains the cell number."
andrewmarx,samc,9452b983947567ad670026d95d51c0aaed7c0933,Andrew Marx,andrewjmarx@gmail.com,2020-09-29T17:22:17Z,Andrew Marx,andrewjmarx@gmail.com,2020-09-29T17:22:17Z,Typo fix,R/cond_passage.R,False,True,True,False,1,1,2,"---FILE: R/cond_passage.R---
@@ -27,7 +27,7 @@ NULL
 #'
 #' \strong{WARNING}: This function will crash when used with data representing
 #' a disconnected graph. This includes, for example, isolated pixels or islands
-#' in raster data. This is a result of the transtion matrix for disconnected
+#' in raster data. This is a result of the transition matrix for disconnected
 #' graphs leading to some equations being unsolvable. Different options
 #' are being explored for how to best identify these situations in data and
 #' handle them accordingly."
andrewmarx,samc,435ed27081ce8e06e3a205e84ae443d6e5378630,Andrew Marx,andrewjmarx@gmail.com,2020-09-08T18:59:37Z,Andrew Marx,andrewjmarx@gmail.com,2020-09-08T18:59:37Z,"Update cond_passage for vector inputs

Also fix index issue for origin values greater than dest values",R/cond_passage.R,False,True,True,False,18,4,22,"---FILE: R/cond_passage.R---
@@ -70,10 +70,24 @@ setMethod(
   signature(samc = ""samc"", origin = ""numeric"", dest = ""numeric""),
   function(samc, origin, dest) {
 
-    if (origin %% 1 != 0 || origin < 1 || origin > (nrow(samc@p) - 1))
-      stop(""origin must be an integer that refers to a cell in the landscape"")
+    .validate_locations(samc, origin)
+    .validate_locations(samc, dest)
 
-    t <- cond_passage(samc, dest = dest)
+    if(length(origin) != length(dest))
+      stop(""The 'origin' and 'dest' parameters must have the same number of values"")
 
-    return(t[origin])
+    result <- vector(mode = ""numeric"", length = length(length(origin)))
+
+    unique_dest <- unique(dest)
+
+    for (d in unique_dest) {
+      t <- cond_passage(samc, dest = d)
+      adj_origin <- origin
+      adj_origin[origin > d] <- adj_origin[origin > d] - 1
+      result[dest == d] <- t[origin[dest == d]]
+    }
+
+    result[dest == origin] <- NA
+
+    return(result)
   })"
andrewmarx,samc,cfb2422e20783c4f8b65b83c64b84c8934fb363d,Andrew Marx,andrewjmarx@gmail.com,2020-06-13T01:20:09Z,Andrew Marx,andrewjmarx@gmail.com,2020-07-15T13:01:27Z,"Optimize cond_passage()

Implement the matrix calculations using C++. Benchmarking showed the
previous commit was incorrect about being memory efficient.",R/RcppExports.R;R/cond_passage.R;src/RcppExports.cpp;src/cond_passage.cpp,False,True,True,False,45,9,54,"---FILE: R/RcppExports.R---
@@ -1,6 +1,10 @@
 # Generated by using Rcpp::compileAttributes() -> do not edit by hand
 # Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393
 
+.cond_t <- function(IQ, qj) {
+    .Call('_samc_cond_t', PACKAGE = 'samc', IQ, qj)
+}
+
 .sum_qn_q <- function(M, M2, q, t) {
     .Call('_samc_sum_qn_q', PACKAGE = 'samc', M, M2, q, t)
 }

---FILE: R/cond_passage.R---
@@ -47,17 +47,12 @@ setMethod(
     qj <- Q[-dest, dest]
     Qj <- Q[-dest, -dest]
 
-    b <- solve(diag(nrow(Qj)) - Qj, qj)
+    Qj@x <- -Qj@x
+    Matrix::diag(Qj) <- Matrix::diag(Qj) + 1
 
-    bdg <- Matrix::sparseMatrix(i = 1:length(b),
-                                j = 1:length(b),
-                                x = b,
-                                index1 = TRUE)
+    t <- .cond_t(Qj, qj)
 
-    t <- solve((diag(nrow(Qj)) - Qj) %*% bdg, as.numeric(bdg %*% rep(1, nrow(bdg))))
-    t <- as.numeric(t)
-
-    return(t)
+    return(as.numeric(t))
   })
 
 #' @rdname cond_passage

---FILE: src/RcppExports.cpp---
@@ -6,6 +6,18 @@
 
 using namespace Rcpp;
 
+// cond_t
+Rcpp::NumericVector cond_t(Eigen::Map<Eigen::SparseMatrix<double> >& IQ, Eigen::VectorXd& qj);
+RcppExport SEXP _samc_cond_t(SEXP IQSEXP, SEXP qjSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< Eigen::Map<Eigen::SparseMatrix<double> >& >::type IQ(IQSEXP);
+    Rcpp::traits::input_parameter< Eigen::VectorXd& >::type qj(qjSEXP);
+    rcpp_result_gen = Rcpp::wrap(cond_t(IQ, qj));
+    return rcpp_result_gen;
+END_RCPP
+}
 // sum_qn_q
 Rcpp::List sum_qn_q(const Eigen::Map<Eigen::SparseMatrix<double> >& M, const Eigen::Map<Eigen::SparseMatrix<double> >& M2, const Eigen::VectorXd& q, Rcpp::NumericVector t);
 RcppExport SEXP _samc_sum_qn_q(SEXP MSEXP, SEXP M2SEXP, SEXP qSEXP, SEXP tSEXP) {
@@ -159,6 +171,7 @@ END_RCPP
 }
 
 static const R_CallMethodDef CallEntries[] = {
+    {""_samc_cond_t"", (DL_FUNC) &_samc_cond_t, 2},
     {""_samc_sum_qn_q"", (DL_FUNC) &_samc_sum_qn_q, 4},
     {""_samc_psid_long"", (DL_FUNC) &_samc_psid_long, 2},
     {""_samc_qpow_row"", (DL_FUNC) &_samc_qpow_row, 3},

---FILE: src/cond_passage.cpp---
@@ -0,0 +1,24 @@
+// Copyright (c) 2020 Andrew Marx. All rights reserved.
+// Licensed under GPLv3.0. See LICENSE file in the project root for details.
+
+#include <Rcpp.h>
+#include <RcppEigen.h>
+
+
+// [[Rcpp::export("".cond_t"")]]
+Rcpp::NumericVector cond_t(Eigen::Map<Eigen::SparseMatrix<double> > &IQ, Eigen::VectorXd &qj)
+{
+  Eigen::SparseLU<Eigen::SparseMatrix<double> > solver;
+
+  solver.compute(IQ);
+
+  Eigen::VectorXd b = solver.solve(qj);
+
+  solver.compute(IQ * b.asDiagonal());
+
+  Eigen::VectorXd res = solver.solve(b);
+
+  return Rcpp::wrap(res);
+}
+
+"
andrewmarx,samc,1e34b7f53df8bbcc0af1227952272fd213987661,Andrew Marx,andrewjmarx@gmail.com,2020-06-12T16:45:56Z,Andrew Marx,andrewjmarx@gmail.com,2020-07-15T13:01:27Z,"Initial implementation of condition mean first passage time

Optimized to avoid memory issues, but need to clean up and probably test
against an Eigen implementation",R/cond_passage.R,False,True,True,False,15,0,15,"---FILE: R/cond_passage.R---
@@ -39,4 +39,19 @@ setMethod(
   signature(samc = ""samc"", origin = ""missing"", dest = ""numeric""),
   function(samc, dest) {
 
+    Q <- samc@p[-nrow(samc@p), -nrow(samc@p)]
+    qj <- Q[-dest, dest]
+    Qj <- Q[-dest, -dest]
+
+    b <- solve(diag(nrow(Qj)) - Qj, qj)
+
+    bdg <- Matrix::sparseMatrix(i = 1:length(b),
+                                j = 1:length(b),
+                                x = b,
+                                index1 = TRUE)
+
+    t <- solve((diag(nrow(Qj)) - Qj) %*% bdg, as.numeric(bdg %*% rep(1, nrow(bdg))))
+    t <- as.numeric(t)
+
+    return(t)
   })"
andrewmarx,samc,b7d8ea6cb0cc5affd720e2e2d083bc35d7f4054f,Andrew Marx,andrewjmarx@gmail.com,2020-07-15T01:45:52Z,Andrew Marx,andrewjmarx@gmail.com,2020-07-15T01:45:52Z,"Update P matrix implementation and checks

Add new 'source' field to samc-class to indicate data source

Fix default map value for non-map samc-class objects by creating a
deault minimal raster

Fix samc(p_mat) implementation for regular matrix inputs

Update check() function

Update map() function",R/check.R;R/map.R;R/samc-class.R;R/samc.R,False,True,True,False,8,3,11,"---FILE: R/check.R---
@@ -95,7 +95,7 @@ setMethod(
   ""check"",
   signature(a = ""samc"", b = ""RasterLayer""),
   function(a, b){
-    if (class(a@map) != ""RasterLayer"") stop(""Parameters do not apply to a samc-object created directly from a P matrix"")
+    if (a@source != ""map"") stop(paste(""Parameters do not apply to a samc-class object created from a"", a@source))
 
     check(b)
 

---FILE: R/map.R---
@@ -42,6 +42,7 @@ setMethod(
   ""map"",
   signature(samc = ""samc"", vec = ""numeric""),
   function(samc, vec){
+    if (samc@source != ""map"") stop(paste(""This function cannot be used with a samc-class object created from a"", samc@source))
 
     if (length(vec) != sum(samc@map[], na.rm = TRUE))
       stop(""The length of the vector does not match the number of non-NA cells in the landscape data"")
@@ -59,6 +60,7 @@ setMethod(
   ""map"",
   signature(samc = ""samc"", vec = ""list""),
   function(samc, vec){
+    if (samc@source != ""map"") stop(paste(""This function cannot be used with a samc-class object created from a"", samc@source))
 
     lapply(vec, function(x){
       if (class(x) != ""numeric"")

---FILE: R/samc-class.R---
@@ -35,6 +35,7 @@ setClass(
 
   # define the slots
   slots = list(p = ""dgCMatrix"",
+               source = ""character"",
                map = ""RasterLayer"",
                override = ""logical"")
 

---FILE: R/samc.R---
@@ -154,6 +154,7 @@ setMethod(
                                              j = samc_df$j,
                                              x = samc_df$x,
                                              index1 = FALSE),
+                    source = ""map"",
                     map = m,
                     override = override)
 
@@ -233,7 +234,8 @@ setMethod(
 
     samc_obj <- methods::new(""samc"",
                              p = p_mat,
-                             map = NA,
+                             source = ""matrix"",
+                             map = raster::raster(matrix()),
                              override = override)
 
     return(samc_obj)
@@ -251,5 +253,5 @@ setMethod(
   function(p_mat, override = FALSE) {
     p <- as(p_mat, ""dgCMatrix"")
 
-    return(samc(p, override))
+    return(samc(p_mat = p, override = override))
   })"
andrewmarx,samc,491975ed8452d73bcbdc33d3dde26baf007861c7,Andrew Marx,andrewjmarx@gmail.com,2020-05-25T13:14:34Z,Andrew Marx,andrewjmarx@gmail.com,2020-05-25T13:14:34Z,Fix release date in NEWS,docs/news/index.html,False,False,False,False,1,1,2,"---FILE: docs/news/index.html---
@@ -149,7 +149,7 @@ <h1 data-toc-skip>Changelog <small></small></h1>
 
     <div id=""samc-1-1-0"" class=""section level1"">
 <h1 class=""page-header"" data-toc-text=""1.1.0"">
-<a href=""#samc-1-1-0"" class=""anchor""></a>samc 1.1.0<small> Unreleased </small>
+<a href=""#samc-1-1-0"" class=""anchor""></a>samc 1.1.0<small> 2020-05-19 </small>
 </h1>
 <ul>
 <li>Added support for the use vectors of time steps in most short-term metrics. It is more computationally efficient and ergonomic to do this rather than calculating short-term metrics for each individual time step. Some key points:"
andrewmarx,samc,3f67c9bc4662ffecca57fa2ca00fd7e52bf7c2d6,Andrew Marx,andrewjmarx@gmail.com,2020-05-17T01:18:03Z,Andrew Marx,andrewjmarx@gmail.com,2020-05-17T01:18:03Z,Fix CITATION file,inst/CITATION,False,False,False,False,8,8,16,"---FILE: inst/CITATION---
@@ -2,14 +2,14 @@ citHeader(""To cite samc in publications use:"")
 
 citEntry(
   entry    = ""Article"",
-  title    = {samc: an R package for connectivity modeling with spatial absorbing Markov chains},
-  author   = {Marx, Andrew J. and Wang, Chao and Sefair, Jorge A. and Acevedo, Miguel A. and Fletcher Jr., Robert J.},
-  journal  = {Ecography},
-  year     = {2020},
-  volume   = {43},
-  number   = {4},
-  pages    = {518-527},
-  url      = {https://onlinelibrary.wiley.com/doi/abs/10.1111/ecog.04891},
+  title    = ""samc: an R package for connectivity modeling with spatial absorbing Markov chains"",
+  author   = ""Marx, Andrew J. and Wang, Chao and Sefair, Jorge A. and Acevedo, Miguel A. and Fletcher Jr., Robert J."",
+  journal  = ""Ecography"",
+  year     = ""2020"",
+  volume   = ""43"",
+  number   = ""4"",
+  pages    = ""518-527"",
+  url      = ""https://onlinelibrary.wiley.com/doi/abs/10.1111/ecog.04891"",
   textVersion = paste(
 
   )"
andrewmarx,samc,2e775f17b09e6ad6d2a9b8c66b0e93acf13a1ff2,Andrew Marx,andrewjmarx@gmail.com,2020-05-16T18:29:34Z,Andrew Marx,andrewjmarx@gmail.com,2020-05-16T18:29:34Z,Fix incorrect test description strings,tests/testthat/test-dispersal.R;tests/testthat/test-mortality.R,False,True,True,False,2,2,4,"---FILE: tests/testthat/test-dispersal.R---
@@ -195,7 +195,7 @@ test_that(""Testing dispersal(samc, occ)"", {
 })
 
 
-test_that(""Testing dispersal(samc, occ)"", {
+test_that(""Testing dispersal(samc, occ, dest)"", {
 
   r1 <- dispersal(samc_obj, occ = occ, dest = col)
 

---FILE: tests/testthat/test-mortality.R---
@@ -124,7 +124,7 @@ test_that(""Testing mortality(samc, dest, time_vec)"", {
   }
 })
 
-test_that(""Testing mortality(samc, dest, time)"", {
+test_that(""Testing mortality(samc, origin, dest, time)"", {
 
   r1 <- mortality(samc_obj, origin = row, dest = col, time = time)
 "
andrewmarx,samc,8efd6cc84568df77940fdc0a968dac5eedb5add4,Andrew Marx,andrewjmarx@gmail.com,2020-05-15T17:29:09Z,Andrew Marx,andrewjmarx@gmail.com,2020-05-15T17:29:09Z,"Update map() function to support lists of vectors

Add support for list of vectors to support new time step vector feature

Fix code around misconception of ""vector"" for a signature member. Lists
in R are technically vectors as well, which causes issues if ""vector"" is
assumed to refer only to atomic vectors.",R/map.R,False,True,True,False,25,1,26,"---FILE: R/map.R---
@@ -40,7 +40,7 @@ setGeneric(
 #' @rdname map
 setMethod(
   ""map"",
-  signature(samc = ""samc"", vec = ""vector""),
+  signature(samc = ""samc"", vec = ""numeric""),
   function(samc, vec){
 
     if (length(vec) != sum(samc@map[], na.rm = TRUE))
@@ -53,3 +53,27 @@ setMethod(
 
     return(ras)
   })
+
+#' @rdname map
+setMethod(
+  ""map"",
+  signature(samc = ""samc"", vec = ""list""),
+  function(samc, vec){
+
+    lapply(vec, function(x){
+      if (class(x) != ""numeric"")
+        stop(""List contains invalid item(s); all entries must be numeric vectors."")
+      if (length(x) != sum(samc@map[], na.rm = TRUE))
+        stop(""The length of one or more vectors in the list does not match the number of non-NA cells in the landscape data"")
+    })
+
+    res <- lapply(vec, function(x){
+      ras <- samc@map
+
+      ras[ras[]] <- x
+      ras[!samc@map[]] <- NA
+      return(ras)
+    })
+
+    return(res)
+  })"
andrewmarx,samc,fd5a02615a624c361cbe8421153169cdb5db3652,Andrew Marx,andrewjmarx@gmail.com,2019-08-13T17:32:57Z,Andrew Marx,andrewjmarx@gmail.com,2019-08-13T17:32:57Z,Fix check() reference,docs/reference/check.html,False,False,False,False,2,2,4,"---FILE: docs/reference/check.html---
@@ -148,10 +148,10 @@ <h1>Check landscape data</h1>
 
     <pre class=""usage""><span class='fu'>check</span>(<span class='no'>a</span>, <span class='no'>b</span>)
 
-<span class='co'># S4 method for RasterLayer,ANY</span>
+<span class='co'># S4 method for RasterLayer,missing</span>
 <span class='fu'>check</span>(<span class='no'>a</span>)
 
-<span class='co'># S4 method for matrix,ANY</span>
+<span class='co'># S4 method for matrix,missing</span>
 <span class='fu'>check</span>(<span class='no'>a</span>)
 
 <span class='co'># S4 method for RasterLayer,RasterLayer</span>"
