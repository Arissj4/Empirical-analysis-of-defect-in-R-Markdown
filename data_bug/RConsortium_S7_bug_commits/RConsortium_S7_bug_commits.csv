repo_owner,repo_name,commit_hash,author_name,author_email,author_date,committer_name,committer_email,committer_date,message,filenames,touches_rmd,touches_r,touches_r_or_rmd,is_merge,added,deleted,changed,diff
RConsortium,S7,d67c0a19a718532e8f60780558a47c4c742cca85,Tomasz Kalinowski,tomasz@posit.co,2025-11-13T23:17:05Z,GitHub,noreply@github.com,2025-11-13T23:17:05Z,"Fix new non-API warnings (#577)

* remove usage of `FORMALS()`

* remove usage of `Rf_allocSExp()`

* update Roxygen version

* oldrel compat

* Rbuildignore `revdep`

* better oldrel compat approach

* update snapshots for testthat v3.3.0

* wrap test `dput()` calls in `capture.output()`

* add NEWS",.Rbuildignore;DESCRIPTION;NEWS.md;src/init.c;src/method-dispatch.c;tests/testthat/_snaps/class.md;tests/testthat/_snaps/method-introspect.md;tests/testthat/_snaps/method-register.md;tests/testthat/_snaps/property.md;tests/testthat/_snaps/super.md;tests/testthat/test-base-r.R,False,True,True,False,67,52,119,"---FILE: .Rbuildignore---
@@ -18,3 +18,4 @@
 ^compile_commands\.json$
 ^\.cache$
 ^\.vscode$
+^revdep$

---FILE: DESCRIPTION---
@@ -47,4 +47,4 @@ Config/testthat/parallel: TRUE
 Config/testthat/start-first: external-generic
 Encoding: UTF-8
 Roxygen: list(markdown = TRUE)
-RoxygenNote: 7.3.2
+RoxygenNote: 7.3.3

---FILE: NEWS.md---
@@ -3,6 +3,8 @@
 * `props<-()` and `set_props()` gain `check`/`.check` arguments, letting you
   set properties without calling `validate()` (#574, #575).
 
+* Internal changes to support R-devel (4.6) (#577).
+
 # S7 0.2.0
 
 ## New features

---FILE: src/init.c---
@@ -54,7 +54,20 @@ SEXP fn_base_missing;
 SEXP ns_S7;
 
 SEXP R_TRUE, R_FALSE;
+SEXP s7_proto_object;
 
+static SEXP make_s7_proto_object(void)
+{
+    SEXP obj = PROTECT(Rf_allocS4Object());
+    SEXP asS3_call = PROTECT(Rf_lang4(
+        Rf_install(""asS3""), obj, /*flag =*/ R_TRUE, /*complete =*/ R_FALSE
+    ));
+    obj = PROTECT(Rf_eval(asS3_call, R_BaseEnv));
+    Rf_classgets(obj, Rf_mkString(""S7_object""));
+
+    UNPROTECT(3);
+    return obj;
+}
 
 void R_init_S7(DllInfo *dll)
 {
@@ -86,4 +99,5 @@ void R_init_S7(DllInfo *dll)
     ns_S7 = Rf_eval(Rf_install(""S7""), R_NamespaceRegistry);
     R_PreserveObject(R_TRUE = Rf_ScalarLogical(1));
     R_PreserveObject(R_FALSE = Rf_ScalarLogical(0));
+    R_PreserveObject(s7_proto_object = make_s7_proto_object());
 }

---FILE: src/method-dispatch.c---
@@ -1,6 +1,13 @@
 #define R_NO_REMAP
 #include <R.h>
 #include <Rinternals.h>
+#include <Rversion.h>
+
+#if (R_VERSION >= R_Version(4, 5, 0))
+#define getClosureFormals R_ClosureFormals
+#else
+#define getClosureFormals FORMALS
+#endif
 
 extern SEXP parent_sym;
 extern SEXP sym_ANY;
@@ -15,6 +22,7 @@ extern SEXP fn_base_quote;
 extern SEXP fn_base_missing;
 
 extern SEXP R_TRUE;
+extern SEXP s7_proto_object;
 
 
 static inline
@@ -91,7 +99,7 @@ SEXP generic_args(SEXP generic, SEXP envir) {
   PROTECT_WITH_INDEX(R_NilValue, &pi);
 
   // Find the value of each argument.
-  SEXP formals = FORMALS(generic);
+  SEXP formals = getClosureFormals(generic);
   for (R_xlen_t i = 0; i < n_dispatch; ++i) {
     SEXP name = TAG(formals);
 
@@ -157,11 +165,7 @@ SEXP S7_obj_dispatch(SEXP object) {
 }
 
 SEXP S7_object_(void) {
-  SEXP obj = PROTECT(Rf_allocSExp(S4SXP));
-  Rf_classgets(obj, Rf_mkString(""S7_object""));
-  UNPROTECT(1);
-
-  return obj;
+  return Rf_duplicate(s7_proto_object);
 }
 
 SEXP method_call_(SEXP call_, SEXP op_, SEXP args_, SEXP env_) {
@@ -170,7 +174,7 @@ SEXP method_call_(SEXP call_, SEXP op_, SEXP args_, SEXP env_) {
   SEXP envir = CAR(args_); args_ = CDR(args_);
 
   // Get the number of arguments to the generic
-  SEXP formals = FORMALS(generic);
+  SEXP formals = getClosureFormals(generic);
   R_xlen_t n_args = Rf_xlength(formals);
   // And how many are used for dispatch
   SEXP dispatch_args = Rf_getAttrib(generic, sym_dispatch_args);

---FILE: tests/testthat/_snaps/class.md---
@@ -1,4 +1,4 @@
-# S7 classes: print nicely
+# S7 classes / print nicely
 
     Code
       foo2
@@ -41,7 +41,7 @@
       List of 1
        $ : <foo2/foo1/S7_object> constructor
 
-# S7 classes: prints @package and @abstract details
+# S7 classes / prints @package and @abstract details
 
     Code
       foo
@@ -52,7 +52,7 @@
       @ validator  : <NULL>
       @ properties :
 
-# S7 classes: checks inputs
+# S7 classes / checks inputs
 
     Code
       new_class(1)
@@ -85,7 +85,7 @@
       Error:
       ! `validator` must be function(self), not function()
 
-# S7 classes: can't inherit from S4 or class unions
+# S7 classes / can't inherit from S4 or class unions
 
     Code
       new_class(""test"", parent = parentS4)
@@ -98,15 +98,15 @@
       Error:
       ! Can't convert `X[[i]]` to a valid class. Class specification must be an S7 class object, the result of `new_S3_class()`, an S4 class object, or a base class, not a <character>.
 
-# S7 classes: can't inherit from an environment
+# S7 classes / can't inherit from an environment
 
     Code
       new_class(""test"", parent = class_environment)
     Condition
       Error:
       ! Can't inherit from an environment.
 
-# abstract classes: can't be instantiated
+# abstract classes / can't be instantiated
 
     Code
       foo <- new_class(""foo"", abstract = TRUE)
@@ -115,7 +115,7 @@
       Error in `S7::new_object()`:
       ! Can't construct an object from abstract class <foo>
 
-# abstract classes: can't inherit from concrete class
+# abstract classes / can't inherit from concrete class
 
     Code
       foo1 <- new_class(""foo1"")
@@ -124,7 +124,7 @@
       Error in `new_class()`:
       ! Abstract classes must have abstract parents
 
-# abstract classes: can use inherited validator from abstract class
+# abstract classes / can use inherited validator from abstract class
 
     Code
       foo2(x = 2)
@@ -133,15 +133,15 @@
       ! <foo2> object is invalid:
       - @x has bad value
 
-# new_object(): gives useful error if called directly
+# new_object() / gives useful error if called directly
 
     Code
       new_object()
     Condition
       Error in `new_object()`:
       ! `new_object()` must be called from within a constructor
 
-# new_object(): validates object
+# new_object() / validates object
 
     Code
       foo(""x"")
@@ -156,7 +156,7 @@
       ! <foo> object is invalid:
       - x must be positive
 
-# new_object(): runs each parent validator exactly once
+# new_object() / runs each parent validator exactly once
 
     Code
       . <- A()
@@ -171,7 +171,7 @@
     Output
       A B C 
 
-# S7 object: displays nicely
+# S7 object / displays nicely
 
     Code
       foo <- new_class(""foo"", properties = list(x = class_double, y = class_double),
@@ -189,7 +189,7 @@
         ..@ x: num(0) 
         ..@ y: num(0) 
 
-# S7 object: displays objects with data nicely
+# S7 object / displays objects with data nicely
 
     Code
       text <- new_class(""text"", class_character, package = NULL)
@@ -202,7 +202,7 @@
       List of 1
        $ : <text> chr ""x""
 
-# S7 object: displays list objects nicely
+# S7 object / displays list objects nicely
 
     Code
       foo1(list(x = 1, y = list(a = 21, b = 22)), x = 3, y = list(a = 41, b = 42))

---FILE: tests/testthat/_snaps/method-introspect.md---
@@ -1,4 +1,4 @@
-# method introspection: errors on invalid inputs
+# method introspection / errors on invalid inputs
 
     Code
       method(print, 1)
@@ -28,7 +28,7 @@
       Error:
       ! `object` must be length 2
 
-# method introspection: errors if no method found
+# method introspection / errors if no method found
 
     Code
       method(foo, class = class_integer)
@@ -55,7 +55,7 @@
       - x: <integer>
       - y: <double>
 
-# method explanation: shows all possible methods along with matches
+# method explanation / shows all possible methods along with matches
 
        add([foo2], [foo2])
     -> add([foo2], [foo1])

---FILE: tests/testthat/_snaps/method-register.md---
@@ -1,24 +1,24 @@
-# method registration: adds messages when overwriting
+# method registration / adds messages when overwriting
 
     Code
       method(foo, class_character) <- (function(x) ""c"")
       method(foo, class_character) <- (function(x) ""c"")
     Message
       Overwriting method foo(<character>)
 
-# method registration: S3 registration requires a S7 class
+# method registration / S3 registration requires a S7 class
 
     Code
       method(sum, new_S3_class(""foo"")) <- (function(x, ...) ""foo"")
     Condition
       Error:
       ! When registering methods for S3 generic sum(), signature must be an S7 class, not an S3 class.
 
-# method registration: can register S7 method for S4 generic
+# method registration / can register S7 method for S4 generic
 
     Class has not been registered with S4; please call S4_register(S4foo)
 
-# method registration: checks argument types
+# method registration / checks argument types
 
     Code
       x <- 10
@@ -32,15 +32,15 @@
       Error:
       ! Can't convert `signature` to a valid class. Class specification must be an S7 class object, the result of `new_S3_class()`, an S4 class object, or a base class, not a <double>.
 
-# as_signature(): forbids list for single dispatch
+# as_signature() / forbids list for single dispatch
 
     Code
       as_signature(list(1), foo)
     Condition
       Error:
       ! Can't convert `signature` to a valid class. Class specification must be an S7 class object, the result of `new_S3_class()`, an S4 class object, or a base class, not a <list>.
 
-# as_signature(): requires a list of the correct length for multiple dispatch
+# as_signature() / requires a list of the correct length for multiple dispatch
 
     Code
       as_signature(class_character, foo)

---FILE: tests/testthat/_snaps/property.md---
@@ -1,20 +1,20 @@
-# property retrieval: retrieves the properties that exist & errors otherwise
+# property retrieval / retrieves the properties that exist & errors otherwise
 
     Can't find property <foo>@x
 
 ---
 
     Can't find property <foo>@x
 
-# prop setting: can't set read-only properties
+# prop setting / can't set read-only properties
 
     Code
       obj@x <- 1
     Condition
       Error:
       ! Can't set read-only property <foo>@x
 
-# prop setting: errors if the property doesn't exist or is wrong class
+# prop setting / errors if the property doesn't exist or is wrong class
 
     Code
       obj <- foo(123)
@@ -28,7 +28,7 @@
       Error:
       ! <foo>@x must be <double>, not <character>
 
-# prop setting: validates all attributes if custom setter
+# prop setting / validates all attributes if custom setter
 
     Code
       obj <- foo(y = 123, x = 123)
@@ -37,7 +37,7 @@
       Error:
       ! <foo>@y must be <double>, not <character>
 
-# props<-: `check = FALSE` skip validation
+# props<- / `check = FALSE` skip validation
 
     Code
       validate(obj)
@@ -46,7 +46,7 @@
       ! <S7::foo> object is invalid:
       - bad
 
-# props<-: set_props() skip validation with `.check = FALSE`
+# props<- / set_props() skip validation with `.check = FALSE`
 
     Code
       validate(obj2)
@@ -55,7 +55,7 @@
       ! <S7::foo> object is invalid:
       - bad
 
-# new_property(): validates getter and settor
+# new_property() / validates getter and settor
 
     Code
       new_property(getter = function(x) { })
@@ -68,15 +68,15 @@
       Error:
       ! `setter` must be function(self, value), not function(x, y, z)
 
-# new_property(): validates default
+# new_property() / validates default
 
     Code
       new_property(class_integer, default = ""x"")
     Condition
       Error in `new_property()`:
       ! `default` must be an instance of <integer>, not a <character>
 
-# new_property(): displays nicely
+# new_property() / displays nicely
 
     Code
       print(x)

---FILE: tests/testthat/_snaps/super.md---
@@ -1,4 +1,4 @@
-# super(): checks to
+# super() / checks to
 
     Code
       foo <- new_class(""foo"", package = NULL)
@@ -7,7 +7,7 @@
       Error in `super()`:
       ! <foo> doesn't inherit from <character>
 
-# super(): displays nicely
+# super() / displays nicely
 
     Code
       f1 <- super(foo2(), foo1)

---FILE: tests/testthat/test-base-r.R---
@@ -1,5 +1,3 @@
-
-
 test_that(""base::inherits() accepts S7 objects"", {
   skip_if(getRversion() < ""4.3"")
 
@@ -8,14 +6,13 @@ test_that(""base::inherits() accepts S7 objects"", {
   ClassX <- new_class(""ClassX"")
 
   expect_no_error(stopifnot(exprs = {
-    isTRUE(inherits(ClassA() , ClassA))
+    isTRUE(inherits(ClassA(), ClassA))
     isTRUE(inherits(ClassBA(), ClassA))
     isTRUE(inherits(ClassBA(), ClassBA))
 
     isFALSE(inherits(ClassX(), ClassA))
     isFALSE(inherits(ClassX(), ClassBA))
   }))
-
 })
 
 
@@ -24,8 +21,7 @@ test_that(""base::`@` accesses S7 properties"", {
 
   range <- new_class(
     ""range"",
-    properties = list(start = class_double,
-                      end = class_double),
+    properties = list(start = class_double, end = class_double),
     validator = function(self) {
       if (length(self@start) != 1) {
         ""@start must be length 1""
@@ -50,14 +46,12 @@ test_that(""base::`@` accesses S7 properties"", {
       identical(obj@start, 3)
       identical(obj@end, 4)
     }))
-
   })
-
 })
 
 test_that(""dput(<S7_object>) works"", {
   skip_if(getRversion() < ""4.4"")
 
-  expect_no_error(dput(new_class(""Foo"")()))
-  expect_no_error(dput(new_class(""Foo"")))
+  expect_no_error(capture.output(dput(new_class(""Foo"")())))
+  expect_no_error(capture.output(dput(new_class(""Foo""))))
 })"
RConsortium,S7,e430c9aab137cc6301d5e06922e4d8cf2c0a8270,Marco Colombo,mar.colombo13@gmail.com,2025-08-27T14:06:54Z,GitHub,noreply@github.com,2025-08-27T14:06:54Z,Fix typo in the S7 vignette. (#563),vignettes/S7.Rmd,True,False,True,False,1,1,2,"---FILE: vignettes/S7.Rmd---
@@ -66,7 +66,7 @@ S7 automatically validates the type of the property using the type supplied in `
 lola@age <- ""twelve""
 ```
 
-Given an object, you can retrieves its class `S7_class()`:
+Given an object, you can retrieve its class `S7_class()`:
 
 ```{r}
 S7_class(lola)"
RConsortium,S7,3a18a5603a6cadf904912c159e16b37a15cf937d,Ryan Chitwood,chitwoodrw@icloud.com,2024-11-19T21:31:48Z,GitHub,noreply@github.com,2024-11-19T21:31:48Z,Fix typos in vignettes/packages.Rmd (#499),vignettes/packages.Rmd,True,False,True,False,2,2,4,"---FILE: vignettes/packages.Rmd---
@@ -44,8 +44,8 @@ That means you will also need to document it, and since the constructor is a fun
 If you export a class, you must also set the `package` argument, ensuring that classes with the same name are disambiguated across packages.
 
 You should document generics like regular functions (since they are!).
-If you expect others to create their own methods for your generic, you may want to include an section describing the the properties that you expect all methods to have.
-We plan to provide a an easy way to all methods for a generic, but have not yet implemented it.
+If you expect others to create their own methods for your generic, you may want to include an section describing the properties that you expect all methods to have.
+We plan to provide an easy way to document all methods for a generic, but have not yet implemented it.
 You can track progress at <https://github.com/RConsortium/S7/issues/167>.
 
 We don't currently have any recommendations on documenting methods."
RConsortium,S7,534f5b79d726d15e776bb74cfed3f946836d6fe5,Matt Heaphy,32379086+mattheaphy@users.noreply.github.com,2024-11-14T17:40:51Z,GitHub,noreply@github.com,2024-11-14T17:40:51Z,Vignette typos fixes (#492),vignettes/classes-objects.Rmd;vignettes/compatibility.Rmd;vignettes/generics-methods.Rmd,True,False,True,False,20,15,35,"---FILE: vignettes/classes-objects.Rmd---
@@ -24,7 +24,7 @@ library(S7)
 ## Validation
 
 S7 classes can have an optional **validator** that checks that the values of the properties are OK.
-A validator is a function that takes the object (called `self`) and returns `NULL` if its valid or returns a character vector listing the problems.
+A validator is a function that takes the object (called `self`) and returns `NULL` if it's valid or returns a character vector listing the problems.
 
 ### Basics
 
@@ -168,7 +168,7 @@ This makes it possible to use the same property definition for multiple properti
 
 ### Default value
 
-The defaults of `new_class()` create an class that can be constructed with no arguments:
+The defaults of `new_class()` create a class that can be constructed with no arguments:
 
 ```{r}
 Empty <- new_class(""Empty"",
@@ -225,7 +225,7 @@ Range <- new_class(""Range"",
     start = class_double,
     end = class_double,
     length = new_property(
-      getter = function(self) self@end - self@start,
+      getter = function(self) self@end - self@start
     )
   )
 )
@@ -257,6 +257,11 @@ Range <- new_class(""Range"",
       class = class_double,
       getter = function(self) self@end - self@start,
       setter = function(self, value) {
+        if (!length(value)) {
+          # Do nothing if called with the constructor default
+          # value for this property, a zero-length double vector.
+          return(self)
+        }
         self@end <- self@start + value
         self
       }
@@ -392,13 +397,13 @@ Range <- new_class(""Range"",
     end = class_numeric
   ),
   constructor = function(x) {
-    new_object(S7_object(), 
-               start = min(x, na.rm = TRUE), 
+    new_object(S7_object(),
+               start = min(x, na.rm = TRUE),
                end = max(x, na.rm = TRUE))
   }
 )
 
-range(c(10, 5, 0, 2, 5, 7))
+Range(c(10, 5, 0, 2, 5, 7))
 ```
 
 A constructor must always end with a call to `new_object()`.

---FILE: vignettes/compatibility.Rmd---
@@ -109,7 +109,7 @@ rle(1:10)
 Alternatively you could convert it to the most natural representation using S7:
 
 ```{r}
-rle <- new_class(""rle"", properties = list(
+new_rle <- new_class(""rle"", properties = list(
   lengths = class_integer,
   values = class_atomic
 ))
@@ -118,7 +118,7 @@ rle <- new_class(""rle"", properties = list(
 To allow existing methods to work you'll need to override `$` to access properties instead of list elements:
 
 ```{r}
-method(`$`, rle) <- prop
+method(`$`, new_rle) <- prop
 rle(1:10)
 ```
 

---FILE: vignettes/generics-methods.Rmd---
@@ -114,7 +114,7 @@ simple_print(list(1, 2, ""x""), diggits = 3)
 
 Occasional it's useful to create a generic without `…` because such functions have a useful property: if a call succeeds for one type of input, it will succeed for any type of input.
 To create such a generic, you'll need to use the third argument to `new_generic()`: an optional function that powers the generic.
-This function has one key property: it must call `call_method()` to actually perform dispatch.
+This function has one key property: it must call `S7_dispatch()` to actually perform dispatch.
 
 In general, this property is only needed for very low-level functions with precisely defined semantics.
 A good example of such a function is `length()`:
@@ -126,7 +126,7 @@ length <- new_generic(""length"", ""x"", function(x) {
 ```
 
 Omitting `…` from the generic signature is a strong restriction as it prevents methods from adding extra arguments.
-For this reason, it's should only be used in special situations.
+For this reason, it should only be used in special situations.
 
 ## Customizing generics
 
@@ -137,7 +137,7 @@ display <- new_generic(""display"", ""x"")
 S7_data(display)
 ```
 
-The most important part of the body is `S7_dispatch()`; this function finds the method the matches the arguments used for dispatch and calls it with the arguments supplied to the generic.
+The most important part of the body is `S7_dispatch()`; this function finds the method that matches the arguments used for dispatch and calls it with the arguments supplied to the generic.
 
 It can be useful to customize this body.
 The previous section showed one case when you might want to supply the body yourself: dropping `…` from the formals of the generic.
@@ -147,7 +147,7 @@ There are three other useful cases:
 -   To add optional arguments.
 -   Perform some standard work.
 
-A custom `fun` must always include a call to `call_method()`, which will usually be the last call.
+A custom `fun` must always include a call to `S7_dispatch()`, which will usually be the last call.
 
 ### Add required arguments
 
@@ -213,7 +213,7 @@ The only downside to performing error checking is that you constraint the interf
 
 ## `super()`
 
-Sometimes it's useful to define a method for in terms of its superclass.
+Sometimes it's useful to define a method for a class that relies on the implementation for its superclass.
 A good example of this is computing the mean of a date --- since dates represent the number of days since 1970-01-01, computing the mean is just a matter of computing the mean of the underlying numeric vector and converting it back to a date.
 
 To demonstrate this idea, I'll first define a mean generic with a method for numbers:
@@ -256,8 +256,8 @@ This explicitness makes the code easier to understand and will eventually enable
 
 ## Multiple dispatch
 
-So far we have focused primarily on single dispatch, i.e. generics where `dispatch_on` is a single string.
-It is also possible to supply a length 2 (or more!) vector `dispatch_on` to create a generic that performs multiple dispatch, i.e. it uses the classes of more than one object to find the appropriate method.
+So far we have focused primarily on single dispatch, i.e. generics where `dispatch_args` is a single string.
+It is also possible to supply a length 2 (or more!) vector `dispatch_args` to create a generic that performs multiple dispatch, i.e. it uses the classes of more than one object to find the appropriate method.
 
 Multiple dispatch is a feature primarily of S4, although S3 includes some limited special cases for arithmetic operators.
 Multiple dispatch is heavily used in S4; we don't expect it to be heavily used in S7, but it is occasionally useful."
RConsortium,S7,bcedb64df4da3ddf55c145b21677d471fcc106b8,Tomasz Kalinowski,tomasz@posit.co,2024-11-05T13:40:04Z,GitHub,noreply@github.com,2024-11-05T13:40:04Z,"Improve `traceback()` for dispatched methods (#486)

* Improve `traceback()` for dispatched methods

* fix typo, malformed test

* Update R/generic.R

Co-authored-by: Hadley Wickham <h.wickham@gmail.com>

* better snapshot tests

* delete unused helper

* whitespace

* `zap_srcref` before printing callstack in snapshot.

* use `utils::removeSource` instead of `rlang::zap_srcref`

* Add NEWS

---------

Co-authored-by: Hadley Wickham <h.wickham@gmail.com>",NEWS.md;R/generic.R;src/init.c;src/method-dispatch.c;tests/testthat/_snaps/method-dispatch.md;tests/testthat/test-method-dispatch.R,False,True,True,False,83,5,88,"---FILE: NEWS.md---
@@ -1,5 +1,11 @@
 # S7 (development version)
 
+* The call context of a dispatched method (as visible in `sys.calls()` and
+  `traceback()`) no longer includes the inlined method and generic, resulting in
+  more compact and readable tracebacks. The dispatched method call now contains
+  only the method name, which serves as a hint for retrieving the method. For
+  example: `method(my_generic, class_double)`(x=10, ...). (#486)
+  
 * `new_class()` now automatically infers the package name when called from 
   within an R package (#459).
 

---FILE: R/generic.R---
@@ -193,6 +193,9 @@ generic_add_method <- function(generic, signature, method) {
   p_tbl <- generic@methods
   chr_signature <- vcapply(signature, class_register)
 
+  if (is.null(attr(method, ""name"", TRUE)))
+    attr(method, ""name"") <- as.name(method_signature(generic, signature))
+
   for (i in seq_along(chr_signature)) {
     class_name <- chr_signature[[i]]
     if (i != length(chr_signature)) {

---FILE: src/init.c---
@@ -45,6 +45,8 @@ SEXP sym_dot_setting_prop;
 SEXP sym_obj_dispatch;
 SEXP sym_dispatch_args;
 SEXP sym_methods;
+SEXP sym_S7_dispatch;
+SEXP sym_name;
 
 SEXP fn_base_quote;
 SEXP fn_base_missing;
@@ -75,6 +77,8 @@ void R_init_S7(DllInfo *dll)
     sym_obj_dispatch = Rf_install(""obj_dispatch"");
     sym_dispatch_args = Rf_install(""dispatch_args"");
     sym_methods = Rf_install(""methods"");
+    sym_S7_dispatch = Rf_install(""S7_dispatch"");
+    sym_name = Rf_install(""name"");
 
     fn_base_quote = Rf_eval(Rf_install(""quote""), R_BaseEnv);
     fn_base_missing = Rf_eval(Rf_install(""missing""), R_BaseEnv);

---FILE: src/method-dispatch.c---
@@ -8,6 +8,9 @@ extern SEXP ns_S7;
 extern SEXP sym_obj_dispatch;
 extern SEXP sym_dispatch_args;
 extern SEXP sym_methods;
+extern SEXP sym_S7_dispatch;
+extern SEXP sym_name;
+
 extern SEXP fn_base_quote;
 extern SEXP fn_base_missing;
 
@@ -181,8 +184,8 @@ SEXP method_call_(SEXP call_, SEXP op_, SEXP args_, SEXP env_) {
   SEXP mcall_tail = mcall;
 
   PROTECT_INDEX arg_pi, val_pi;
-  PROTECT_WITH_INDEX(R_NilValue, &arg_pi);
-  PROTECT_WITH_INDEX(R_NilValue, &val_pi);
+  PROTECT_WITH_INDEX(R_NilValue, &arg_pi); // unnecessary, for rchk only
+  PROTECT_WITH_INDEX(R_NilValue, &val_pi); // unnecessary, for rchk only
 
   // For each of the arguments to the generic
   for (R_xlen_t i = 0; i < n_args; ++i) {
@@ -205,9 +208,9 @@ SEXP method_call_(SEXP call_, SEXP op_, SEXP args_, SEXP env_) {
         // Instead of Rf_eval(arg, R_EmptyEnv), we do Rf_eval(name, envir), so that
         // - if TYPEOF(arg) == LANGSXP or SYMSXP, arg doesn't need to be enquoted and
         // - if TYPEOF(arg) == PROMSXP, arg is updated in place.
-        REPROTECT(arg, arg_pi); // not really necessary, but rchk flags spuriously
+        REPROTECT(arg, arg_pi); // unnecessary, for rchk only
         SEXP val = Rf_eval(name, envir);
-        REPROTECT(val, val_pi);
+        REPROTECT(val, val_pi); // unnecessary, for rchk only
 
         if (Rf_inherits(val, ""S7_super"")) {
 
@@ -250,7 +253,20 @@ SEXP method_call_(SEXP call_, SEXP op_, SEXP args_, SEXP env_) {
 
   // Now that we have all the classes, we can look up what method to call
   SEXP m = method_(generic, dispatch_classes, envir, R_TRUE);
-  SETCAR(mcall, m);
+  REPROTECT(m, val_pi); // unnecessary, for rchk only
+
+  /// Inlining the method closure in the call like `SETCAR(mcall, m);`
+  /// leads to extremely verbose (unreadable) traceback()s. So,
+  /// for nicer tracebacks, we set a SYMSXP at the head.
+  SEXP method_name = Rf_getAttrib(m, sym_name);
+  if (TYPEOF(method_name) != SYMSXP) {
+    // if name is missing, fallback to masking the `S7_dispatch` symbol.
+    // we could alternatively fallback to inlining m: SETCAR(mcall, m)
+    method_name = sym_S7_dispatch;
+  }
+
+  Rf_defineVar(method_name, m, envir);
+  SETCAR(mcall, method_name);
 
   SEXP out = Rf_eval(mcall, envir);
   UNPROTECT(4);

---FILE: tests/testthat/_snaps/method-dispatch.md---
@@ -57,3 +57,34 @@
       Error in `foo_wrapper()`:
       ! argument ""xx"" is missing, with no default
 
+# errors from dispatched methods have reasonable tracebacks
+
+    Code
+      my_generic(10)
+    Output
+      [[1]]
+      my_generic(10)
+      
+      [[2]]
+      S7::S7_dispatch()
+      
+      [[3]]
+      `method(my_generic, class_double)`(x = 10, ...)
+      
+
+---
+
+    Code
+      my_generic(3, 4)
+    Output
+      [[1]]
+      my_generic(3, 4)
+      
+      [[2]]
+      S7::S7_dispatch()
+      
+      [[3]]
+      `method(my_generic, list(class_double, class_double))`(x = 3, 
+          y = 4, ...)
+      
+

---FILE: tests/testthat/test-method-dispatch.R---
@@ -225,5 +225,23 @@ test_that(""method dispatch works for class_missing"", {
     variant = if (getRversion() < ""4.3"") ""R-lt-4-3"",
     foo_wrapper()
   )
+})
+
+test_that(""errors from dispatched methods have reasonable tracebacks"", {
+
+  get_call_stack <- function(n = 3) {
+    x <- sys.calls()
+    x <- x[-length(x)] # remove get_call_stack()
+    x <- tail(x, n)
+    lapply(x, utils::removeSource)
+  }
+
+  my_generic <- new_generic(""my_generic"", ""x"")
+  method(my_generic, class_numeric) <- function(x) get_call_stack()
+  expect_snapshot(my_generic(10))
 
+  my_generic <- new_generic(""my_generic"", c(""x"", ""y""))
+  method(my_generic, list(class_numeric, class_numeric)) <-
+    function(x, y) get_call_stack()
+  expect_snapshot(my_generic(3, 4))
 })"
RConsortium,S7,4ced878212548cae68218fa42ed8eb057b150eda,Tomasz Kalinowski,tomasz@posit.co,2024-11-04T17:21:03Z,GitHub,noreply@github.com,2024-11-04T17:21:03Z,"Don't inline classes in constructor if possible (#481)

* unname `topNamespaceName()` name

* try to use `pkg::cls()` call as constructor default if possible

* add test

* change class constructor parent environment to `new_class()` calling env

* fix non-syntatic class names

* use pkgname instead of env when deciding to not inline constructor calls

* update surrounding code

* Add snapshot test

* Add comment

* update `new_class`: `@param package` doc.

* update snapshot test

* test external classes with actual packages

* use non-syntatic class names in tests",R/aaa.R;R/base.R;R/class-spec.R;R/class.R;R/constructor.R;R/property.R;man/new_class.Rd;tests/testthat/_snaps/class.md;tests/testthat/_snaps/external-generic.md;tests/testthat/t0/NAMESPACE;tests/testthat/t0/R/t0.R;tests/testthat/t2/NAMESPACE;tests/testthat/t2/R/t2.R;tests/testthat/test-class.R;tests/testthat/test-constructor.R;tests/testthat/test-external-generic.R,False,True,True,False,188,51,239,"---FILE: R/aaa.R---
@@ -26,10 +26,10 @@ new_function <- function(args = NULL,
 topNamespaceName <- function(env = parent.frame()) {
   env <- topenv(env)
   if (!isNamespace(env)) {
-    return()
+    return() # print visible
   }
 
-  getNamespaceName(env)
+  as.character(getNamespaceName(env)) # unname
 }
 
 is_string <- function(x) {

---FILE: R/base.R---
@@ -44,7 +44,7 @@ base_default <- function(type) {
     name = quote(quote(x)),
     call = quote(quote({})),
 
-    `function` = quote(function() {}),
+    `function` = quote(function() NULL),
     environment = quote(new.env(parent = emptyenv()))
 )}
 

---FILE: R/class-spec.R---
@@ -81,27 +81,49 @@ class_friendly <- function(x) {
 }
 
 class_construct <- function(.x, ...) {
-  eval(class_construct_expr(.x, ...))
+  class_constructor(.x)(...)
 }
 
 
-class_construct_expr <- function(.x, ...) {
+class_construct_expr <- function(.x, envir = NULL, package = NULL) {
   f <- class_constructor(.x)
+
+  # For S7 class constructors with a non-NULL @package property
+  # Instead of inlining the full class definition, use either
+  # `pkgname::classname()` or `classname()`
+  if (is_class(f) && !is.null(f@package)) {
+    # Check if the class can be resolved as a bare symbol without pkgname::
+    # Note: During package build, using pkg::class for a package's own symbols
+    # will raise an error from `::`.
+    if (identical(package, f@package)) {
+      return(call(f@name))
+    } else {
+      # namespace the pkgname::classname() call
+      cl <- as.call(list(quote(`::`), as.name(f@package), as.name(f@name)))
+
+      # check the call evaluates to f.
+      # This will error if package is not installed or object is not exported.
+      f2 <- eval(cl, baseenv())
+      if (!identical(f, f2)) {
+        msg <- sprintf(
+          ""`%s::%s` is not identical to the class with the same @package and @name properties"",
+          f@package, f@name
+        )
+        stop(msg, call. = FALSE)
+      }
+      return(as.call(list(cl)))
+    }
+  }
+
   # If the constructor is a closure wrapping a simple expression, try
   # to extract the expression
   # (mostly for nicer printing and introspection.)
 
-  ## early return if not safe to unwrap
-  # can't unwrap if we're passing on ...
-  if(...length()) {
-    return(as.call(list(f, ...)))
-  }
-
   # can't unwrap if the closure is potentially important
   # (this can probably be relaxed to allow additional environments)
   fe <- environment(f)
-  if(!identical(fe, baseenv())) {
-    return(as.call(list(f, ...)))
+  if (!identical(fe, baseenv())) {
+    return(as.call(list(f)))
   }
 
   # special case for `class_missing`
@@ -111,8 +133,8 @@ class_construct_expr <- function(.x, ...) {
 
   # `new_object()` must be called from the class constructor, can't
   # be safely unwrapped
-  if(""new_object"" %in% all.names(fb)) {
-    return(as.call(list(f, ...)))
+  if (""new_object"" %in% all.names(fb)) {
+    return(as.call(list(f)))
   }
 
   # maybe unwrap body if it is a single expression wrapped in `{`
@@ -133,7 +155,7 @@ class_construct_expr <- function(.x, ...) {
   }
 
   #else, return a call to the constructor
-  as.call(list(f, ...))
+  as.call(list(f))
 }
 
 class_constructor <- function(.x) {

---FILE: R/class.R---
@@ -16,14 +16,11 @@
 #'   * An S7 class, like [S7_object].
 #'   * An S3 class wrapped by [new_S3_class()].
 #'   * A base type, like [class_logical], [class_integer], etc.
-#' @param package Package name. It is good practice to set the package
-#'   name when exporting an S7 class from a package because it prevents
-#'   clashes if two packages happen to export a class with the same
-#'   name.
+#' @param package Package name. This is automatically resolved if the class is
+#'   defined in a package, and `NULL` otherwise.
 #'
-#'   Setting `package` implies that the class is available for external use,
-#'   so should be accompanied by exporting the constructor. Learn more
-#'   in `vignette(""packages"")`.
+#'   Note, if the class is intended for external use, the constructor should be
+#'   exported. Learn more in `vignette(""packages"")`.
 #' @param abstract Is this an abstract class? An abstract class can not be
 #'   instantiated.
 #' @param constructor The constructor function. In most cases, you can rely
@@ -134,7 +131,9 @@ new_class <- function(
   all_props[names(new_props)] <- new_props
 
   if (is.null(constructor)) {
-    constructor <- new_constructor(parent, all_props)
+    constructor <- new_constructor(parent, all_props,
+                                   envir = parent.frame(),
+                                   package = package)
   }
 
   object <- constructor

---FILE: R/constructor.R---
@@ -1,18 +1,26 @@
-new_constructor <- function(parent, properties) {
+new_constructor <- function(parent, properties,
+                            envir = asNamespace(""S7""), package = NULL) {
   properties <- as_properties(properties)
-  arg_info <- constructor_args(parent, properties)
+  arg_info <- constructor_args(parent, properties, envir, package)
   self_args <- as_names(names(arg_info$self), named = TRUE)
 
   if (identical(parent, S7_object) || (is_class(parent) && parent@abstract)) {
+    new_object_call <-
+      if (has_S7_symbols(envir, ""new_object"", ""S7_object"")) {
+        bquote(new_object(S7_object(), ..(self_args)), splice = TRUE)
+      } else {
+        bquote(S7::new_object(S7::S7_object(), ..(self_args)), splice = TRUE)
+      }
+
     return(new_function(
       args = arg_info$self,
       body = as.call(c(quote(`{`),
         # Force all promises here so that any errors are signaled from
         # the constructor() call instead of the new_object() call.
         unname(self_args),
-        new_call(""new_object"", c(list(quote(S7_object())), self_args))
+        new_object_call
       )),
-      env = asNamespace(""S7"")
+      env = envir
     ))
   }
 
@@ -42,15 +50,19 @@ new_constructor <- function(parent, properties) {
   parent_args <- as_names(names(arg_info$parent), named = TRUE)
   names(parent_args)[names(parent_args) == ""...""] <- """"
   parent_call <- new_call(parent_name, parent_args)
-  body <- new_call(""new_object"", c(parent_call, self_args))
+  body <- new_call(
+    if (has_S7_symbols(envir, ""new_object"")) ""new_object"" else c(""S7"", ""new_object""),
+    c(parent_call, self_args)
+  )
 
-  env <- new.env(parent = asNamespace(""S7""))
+  env <- new.env(parent = envir)
   env[[parent_name]] <- parent_fun
 
   new_function(args, body, env)
 }
 
-constructor_args <- function(parent, properties = list()) {
+constructor_args <- function(parent, properties = list(),
+                             envir = asNamespace(""S7""), package = NULL) {
   parent_args <- formals(class_constructor(parent))
 
   # Remove read-only properties
@@ -66,7 +78,7 @@ constructor_args <- function(parent, properties = list()) {
 
   self_args <- as.pairlist(lapply(
     setNames(, self_arg_nms),
-    function(name) prop_default(properties[[name]]))
+    function(name) prop_default(properties[[name]], envir, package))
   )
 
   list(parent = parent_args,
@@ -81,8 +93,14 @@ is_property_dynamic <- function(x) is.function(x$getter)
 missing_args <- function(names) {
   lapply(setNames(, names), function(i) quote(class_missing))
 }
+
 new_call <- function(call, args) {
-  as.call(c(list(as.name(call)), args))
+  if (is.character(call)) {
+    call <- switch(length(call),
+                   as.name(call),
+                   as.call(c(quote(`::`), lapply(call, as.name))))
+  }
+  as.call(c(list(call), args))
 }
 
 as_names <- function(x, named = FALSE) {
@@ -91,3 +109,14 @@ as_names <- function(x, named = FALSE) {
   }
   lapply(x, as.name)
 }
+
+has_S7_symbols <- function(env, ...) {
+  env <- topenv(env)
+  if (identical(env, asNamespace(""S7"")))
+    return (TRUE)
+  if (!isNamespace(env))
+    return (FALSE)
+  imports <- getNamespaceImports(env)[[""S7""]]
+  symbols <- c(...) %||% getNamespaceExports(""S7"")
+  all(symbols %in% imports)
+}

---FILE: R/property.R---
@@ -155,8 +155,8 @@ str.S7_property <- function(object, ..., nest.lev = 0) {
   print(object, ..., nest.lev = nest.lev)
 }
 
-prop_default <- function(prop) {
-  prop$default %||% class_construct_expr(prop$class)
+prop_default <- function(prop, envir, package) {
+  prop$default %||% class_construct_expr(prop$class, envir, package)
 }
 
 #' Get/set a property

---FILE: man/new_class.Rd---
@@ -30,14 +30,11 @@ There are three options:
 \item A base type, like \link{class_logical}, \link{class_integer}, etc.
 }}
 
-\item{package}{Package name. It is good practice to set the package
-name when exporting an S7 class from a package because it prevents
-clashes if two packages happen to export a class with the same
-name.
-
-Setting \code{package} implies that the class is available for external use,
-so should be accompanied by exporting the constructor. Learn more
-in \code{vignette(""packages"")}.}
+\item{package}{Package name. This is automatically resolved if the class is
+defined in a package, and \code{NULL} otherwise.
+
+Note, if the class is intended for external use, the constructor should be
+exported. Learn more in \code{vignette(""packages"")}.}
 
 \item{properties}{A named list specifying the properties (data) that
 belong to each instance of the class. Each element of the list can

---FILE: tests/testthat/_snaps/class.md---
@@ -112,7 +112,7 @@
       foo <- new_class(""foo"", abstract = TRUE)
       foo()
     Condition
-      Error in `new_object()`:
+      Error in `S7::new_object()`:
       ! Can't construct an object from abstract class <foo>
 
 # abstract classes: can't inherit from concrete class

---FILE: tests/testthat/_snaps/external-generic.md---
@@ -5,3 +5,41 @@
     Output
       <S7_external_generic> foo::bar(x)
 
+# new_method works with both hard and soft dependencies
+
+    Code
+      args(Foo)
+    Output
+      function (bar = t0::`An S7 Class`()) 
+      NULL
+    Code
+      args(t2::`An S7 Class 2`)
+    Output
+      function (bar = t0::`An S7 Class`()) 
+      NULL
+    Code
+      args(t2:::`An Internal Class`)
+    Output
+      function (foo = t0::`An S7 Class`(), bar = `An S7 Class 2`()) 
+      NULL
+
+---
+
+    Code
+      new_class(""Foo"", properties = list(bar = new_class(""Made Up Class"", package = ""t0"")))
+    Condition
+      Error:
+      ! 'Made Up Class' is not an exported object from 'namespace:t0'
+    Code
+      new_class(""Foo"", properties = list(bar = new_class(""Made Up Class"", package = ""Made Up Package"")))
+    Condition
+      Error in `loadNamespace()`:
+      ! there is no package called 'Made Up Package'
+    Code
+      modified_class <- t0::`An S7 Class`
+      attr(modified_class, ""xyz"") <- ""abc""
+      new_class(""Foo"", properties = list(bar = modified_class))
+    Condition
+      Error:
+      ! `t0::An S7 Class` is not identical to the class with the same @package and @name properties
+

---FILE: tests/testthat/t0/NAMESPACE---
@@ -1,4 +1,5 @@
 # Generated by roxygen2: do not edit by hand
 
+export(""An S7 Class"")
 export(an_s3_generic)
 export(an_s7_generic)

---FILE: tests/testthat/t0/R/t0.R---
@@ -3,3 +3,6 @@ an_s7_generic <- S7::new_generic(""an_s7_generic"", ""x"")
 
 #' @export
 an_s3_generic <- function(x) UseMethod(""an_s3_generic"")
+
+#' @export
+`An S7 Class` <- S7::new_class(""An S7 Class"")

---FILE: tests/testthat/t2/NAMESPACE---
@@ -1,5 +1,7 @@
 # Generated by roxygen2: do not edit by hand
 
+export(""An S7 Class 2"")
 export(an_s7_class)
+importFrom(t0, `An S7 Class`)
 importFrom(t0,an_s3_generic)
 importFrom(t0,an_s7_generic)

---FILE: tests/testthat/t2/R/t2.R---
@@ -10,13 +10,25 @@ S7::method(an_s7_generic, an_s7_class) <- function(x) ""foo""
 S7::method(an_s3_generic, an_s7_class) <- function(x) ""foo""
 
 
+#' @rawNamespace importFrom(t0, `An S7 Class`)
+#' @export
+`An S7 Class 2` <- S7::new_class(""An S7 Class 2"", properties = list(bar = `An S7 Class`))
+NULL
+
+`An Internal Class` <- S7::new_class(""An Internal Class"", properties = list(
+  foo = `An S7 Class`,
+  bar = `An S7 Class 2`
+))
+
+
 another_s7_generic <- S7::new_external_generic(""t1"", ""another_s7_generic"", ""x"")
 S7::method(another_s7_generic, S7::class_character) <- function(x) ""foo""
 S7::method(another_s7_generic, an_s7_class) <- function(x) ""foo""
 
 another_s3_generic <- S7::new_external_generic(""t1"", ""another_s3_generic"", ""x"")
 S7::method(another_s3_generic, an_s7_class) <- function(x) ""foo""
 
+
 .onLoad <- function(libname, pkgname) {
   S7::methods_register()
 }

---FILE: tests/testthat/test-class.R---
@@ -232,16 +232,19 @@ test_that(""c(<S7_class>, ...) gives error"", {
 })
 
 test_that(""can round trip to disk and back"", {
-  foo1 <- new_class(""foo1"", properties = list(y = class_integer))
-  foo2 <- new_class(""foo2"", properties = list(x = foo1))
-
-  f <- foo2(x = foo1(y = 1L))
+  eval(quote({
+    foo1 <- new_class(""foo1"", properties = list(y = class_integer))
+    foo2 <- new_class(""foo2"", properties = list(x = foo1))
+    f <- foo2(x = foo1(y = 1L))
+  }), globalenv())
 
+  f <- globalenv()[[""f""]]
   path <- tempfile()
   saveRDS(f, path)
   f2 <- readRDS(path)
 
-  expect_equal(f2, f)
+  expect_equal(f, f2)
+  rm(foo1, foo2, f, envir = globalenv())
 })
 
 

---FILE: tests/testthat/test-constructor.R---
@@ -160,8 +160,6 @@ test_that(""can create constructors with missing or lazy defaults"", {
                ""Can\'t set read-only property Person@birthdate"")
 })
 
-
-
 test_that(""Dynamic settable properties are included in constructor"", {
   Foo <- new_class(
     name = ""Foo"", package = NULL,

---FILE: tests/testthat/test-external-generic.R---
@@ -86,6 +86,39 @@ test_that(""new_method works with both hard and soft dependencies"", {
   expect_equal(an_s3_generic(t2::an_s7_class()), ""foo"")
   expect_equal(an_s7_generic(""x""), ""foo"")
 
+  # test that new_class() will construct a property default as a namespaced call
+  # to t0::AnS7Class() (and not inline the full class object).
+  # As these tests grow, consider splitting this into a separate context like:
+  #   test_that(""package exported classes are not inlined in constructor formals"", {...})
+  Foo <- new_class(""Foo"", properties = list(bar = t0::`An S7 Class`))
+  expect_identical(formals(Foo)                , as.pairlist(alist(bar = t0::`An S7 Class`())))
+  expect_identical(formals(t2::`An S7 Class 2`), as.pairlist(alist(bar = t0::`An S7 Class`())))
+  expect_identical(formals(t2:::`An Internal Class`), as.pairlist(alist(
+    foo = t0::`An S7 Class`(), bar = `An S7 Class 2`()
+  )))
+
+  expect_snapshot({
+    args(Foo)
+    args(t2::`An S7 Class 2`)
+    args(t2:::`An Internal Class`)
+  })
+
+  # test we emit informative error messages if a new_class() call with an
+  # external class dependency is malformed.
+  # https://github.com/RConsortium/S7/issues/477
+  expect_snapshot(error = TRUE, {
+    new_class(""Foo"", properties = list(
+      bar = new_class(""Made Up Class"", package = ""t0"")
+    ))
+    new_class(""Foo"", properties = list(
+      bar = new_class(""Made Up Class"", package = ""Made Up Package"")
+    ))
+
+    modified_class <- t0::`An S7 Class`
+    attr(modified_class, ""xyz"") <- ""abc""
+    new_class(""Foo"", properties = list(bar = modified_class))
+  })
+
   # Now install the soft dependency
   quick_install(test_path(""t1""), tmp_lib)
 "
RConsortium,S7,498cfad96f727b3f90c540e196d3ec16c9d34777,Tomasz Kalinowski,tomasz@posit.co,2024-11-01T19:25:42Z,GitHub,noreply@github.com,2024-11-01T19:25:42Z,"Refactor `method-dispatch.c` (#483)

* Refactor `method-dispatch.c`

* (try to) run rchk in CI

* refactor `method_call_`

* rewrite rchk action

* remove unused `is_missing()` C function.

* print rchk.log in CI

* pass generic dispatch args as named arg to methods

* use `APPEND_NODE` helper

* use `CALLDEF` macro

* remove `PRCODE` and `SET_PRVALUE` usage

* add `class_missing` dispatch tests

* copyedit comment

* avoid unnecessary allocation

* fix/enable commented test case

* add tests

* minor edits

* swap arg order in `APPEND_NODE()` helper

* convert `expect_error()` test to `expect_snapshot()`

* add snapshot varient for R version < 4.3",.github/workflows/rchk.yml;R/method-dispatch.R;src/init.c;src/method-dispatch.c;tests/testthat/_snaps/R-lt-4-3/method-dispatch.md;tests/testthat/_snaps/method-dispatch.md;tests/testthat/test-method-dispatch.R,False,True,True,False,240,71,311,"---FILE: .github/workflows/rchk.yml---
@@ -0,0 +1,38 @@
+name: rchk
+
+on:
+  workflow_dispatch:
+
+
+jobs:
+  rchk:
+    runs-on: ubuntu-latest
+    steps:
+
+    - uses: actions/checkout@v4
+
+    - uses: r-lib/actions/setup-pandoc@v2
+    - uses: r-lib/actions/setup-r@v2
+    - uses: r-lib/actions/setup-r-dependencies@v2
+
+    - run: R CMD build .
+
+    - run: docker pull kalibera/rchk:latest
+
+    - name: run rchk
+      run: |
+          pkgtar=$(ls S7_*.tar.gz)
+          mkdir -p rchk/packages
+          mv $pkgtar rchk/packages/
+          cd rchk
+          docker run -v `pwd`/packages:/rchk/packages kalibera/rchk:latest /rchk/packages/$pkgtar > rchk.log 2>&1
+          cat rchk.log
+
+    - run: cat rchk.log
+      working-directory: rchk
+
+    - name: upload rchk log
+      uses: actions/upload-artifact@v4
+      with:
+        name: rchk-log
+        path: rchk/rchk.log

---FILE: R/method-dispatch.R---
@@ -20,6 +20,5 @@ method_lookup_error_message <- function(name, types) {
 #' @order 2
 #' @export
 S7_dispatch <- function() {
-  S7_dispatched_call <- .Call(method_call_, sys.call(-1), sys.function(-1), sys.frame(-1))
-  eval(S7_dispatched_call, envir = sys.frame(-1))
+  .External2(method_call_, sys.function(-1L), sys.frame(-1L))
 }

---FILE: src/init.c---
@@ -5,18 +5,25 @@
 
 /* .Call calls */
 extern SEXP method_(SEXP, SEXP, SEXP, SEXP);
-extern SEXP method_call_(SEXP, SEXP, SEXP);
+extern SEXP method_call_(SEXP, SEXP, SEXP, SEXP);
+extern SEXP test_call_(SEXP, SEXP, SEXP, SEXP);
 extern SEXP S7_class_(SEXP, SEXP);
 extern SEXP S7_object_(void);
 extern SEXP prop_(SEXP, SEXP);
 extern SEXP prop_set_(SEXP, SEXP, SEXP, SEXP);
 
+#define CALLDEF(name, n)  {#name, (DL_FUNC) &name, n}
+
 static const R_CallMethodDef CallEntries[] = {
-    {""method_"", (DL_FUNC) &method_, 4},
-    {""method_call_"", (DL_FUNC) &method_call_, 3},
-    {""S7_object_"", (DL_FUNC) &S7_object_, 0},
-    {""prop_"", (DL_FUNC) &prop_, 2},
-    {""prop_set_"", (DL_FUNC) &prop_set_, 4},
+    CALLDEF(method_, 4),
+    CALLDEF(S7_object_, 0),
+    CALLDEF(prop_, 2),
+    CALLDEF(prop_set_, 4),
+    {NULL, NULL, 0}
+};
+
+static const R_ExternalMethodDef ExternalEntries[] = {
+    CALLDEF(method_call_, 2),
     {NULL, NULL, 0}
 };
 
@@ -35,19 +42,25 @@ SEXP sym_getter;
 SEXP sym_dot_should_validate;
 SEXP sym_dot_getting_prop;
 SEXP sym_dot_setting_prop;
+SEXP sym_obj_dispatch;
+SEXP sym_dispatch_args;
+SEXP sym_methods;
 
 SEXP fn_base_quote;
+SEXP fn_base_missing;
 
 SEXP ns_S7;
 
+SEXP R_TRUE, R_FALSE;
+
 
 void R_init_S7(DllInfo *dll)
 {
-    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
+    R_registerRoutines(dll, NULL, CallEntries, NULL, ExternalEntries);
     R_useDynamicSymbols(dll, FALSE);
+
     sym_ANY = Rf_install(""ANY"");
     sym_S7_class = Rf_install(""S7_class"");
-
     sym_name = Rf_install(""name"");
     sym_parent = Rf_install(""parent"");
     sym_package = Rf_install(""package"");
@@ -59,8 +72,14 @@ void R_init_S7(DllInfo *dll)
     sym_dot_should_validate = Rf_install("".should_validate"");
     sym_dot_getting_prop = Rf_install("".getting_prop"");
     sym_dot_setting_prop = Rf_install("".setting_prop"");
+    sym_obj_dispatch = Rf_install(""obj_dispatch"");
+    sym_dispatch_args = Rf_install(""dispatch_args"");
+    sym_methods = Rf_install(""methods"");
 
     fn_base_quote = Rf_eval(Rf_install(""quote""), R_BaseEnv);
+    fn_base_missing = Rf_eval(Rf_install(""missing""), R_BaseEnv);
 
-    ns_S7 = Rf_findVarInFrame(R_NamespaceRegistry, Rf_install(""S7""));
+    ns_S7 = Rf_eval(Rf_install(""S7""), R_NamespaceRegistry);
+    R_PreserveObject(R_TRUE = Rf_ScalarLogical(1));
+    R_PreserveObject(R_FALSE = Rf_ScalarLogical(0));
 }

---FILE: src/method-dispatch.c---
@@ -4,6 +4,38 @@
 
 extern SEXP parent_sym;
 extern SEXP sym_ANY;
+extern SEXP ns_S7;
+extern SEXP sym_obj_dispatch;
+extern SEXP sym_dispatch_args;
+extern SEXP sym_methods;
+extern SEXP fn_base_quote;
+extern SEXP fn_base_missing;
+
+extern SEXP R_TRUE;
+
+
+static inline
+void APPEND_NODE(SEXP node, SEXP tag, SEXP val) {
+  SEXP new_node = Rf_cons(val, R_NilValue);
+  SETCDR(node, new_node);
+  SET_TAG(new_node, tag);
+}
+
+// extern Rboolean is_S7_object(SEXP);
+// extern Rboolean is_s7_class(SEXP);
+// extern void check_is_S7(SEXP object);
+
+
+static inline
+SEXP maybe_enquote(SEXP x) {
+  switch (TYPEOF(x)) {
+    case SYMSXP:
+    case LANGSXP:
+      return Rf_lang2(fn_base_quote, x);
+    default:
+      return x;
+  }
+}
 
 // Recursively walk through method table to perform iterated dispatch
 SEXP method_rec(SEXP table, SEXP signature, R_xlen_t signature_itr) {
@@ -17,7 +49,9 @@ SEXP method_rec(SEXP table, SEXP signature, R_xlen_t signature_itr) {
     SEXP klass = Rf_install(CHAR(STRING_ELT(classes, i)));
     SEXP val = Rf_findVarInFrame(table, klass);
     if (TYPEOF(val) == ENVSXP) {
+      PROTECT(val); // no really necessary, but rchk flags spuriously
       val = method_rec(val, signature, signature_itr + 1);
+      UNPROTECT(1);
     }
     if (TYPEOF(val) == CLOSXP) {
       return val;
@@ -27,7 +61,9 @@ SEXP method_rec(SEXP table, SEXP signature, R_xlen_t signature_itr) {
   // ANY fallback
   SEXP val = Rf_findVarInFrame(table, sym_ANY);
   if (TYPEOF(val) == ENVSXP) {
+    PROTECT(val);
     val = method_rec(val, signature, signature_itr + 1);
+    UNPROTECT(1);
   }
   if (TYPEOF(val) == CLOSXP) {
     return val;
@@ -37,48 +73,53 @@ SEXP method_rec(SEXP table, SEXP signature, R_xlen_t signature_itr) {
 }
 
 SEXP generic_args(SEXP generic, SEXP envir) {
+  // This function is only used to generate an informative message when
+  // signalling an S7_method_lookup_error, so it doesn't need to be maximally efficient.
+
   // How many arguments are used for dispatch?
-  SEXP dispatch_args = Rf_getAttrib(generic, Rf_install(""dispatch_args""));
+  SEXP dispatch_args = Rf_getAttrib(generic, sym_dispatch_args);
   R_xlen_t n_dispatch = Rf_xlength(dispatch_args);
 
   // Allocate a list to store the arguments
   SEXP args = PROTECT(Rf_allocVector(VECSXP, n_dispatch));
 
+  SEXP missing_call = PROTECT(Rf_lang2(fn_base_missing, R_NilValue));
+  PROTECT_INDEX pi;
+  PROTECT_WITH_INDEX(R_NilValue, &pi);
+
   // Find the value of each argument.
   SEXP formals = FORMALS(generic);
   for (R_xlen_t i = 0; i < n_dispatch; ++i) {
     SEXP name = TAG(formals);
-    SEXP arg = Rf_findVar(name, envir);
 
-    if (PRCODE(arg) == R_MissingArg) {
+    SETCADR(missing_call, name);
+    SEXP is_missing = Rf_eval(missing_call, envir);
+    REPROTECT(is_missing, pi);
+
+    if (Rf_asLogical(is_missing))  {
       SET_VECTOR_ELT(args, i, R_MissingArg);
     } else {
       // method_call_() has already done the necessary computation
-      SET_VECTOR_ELT(args, i, Rf_eval(arg, R_EmptyEnv));
+      SET_VECTOR_ELT(args, i, Rf_eval(name, envir));
     }
 
     formals = CDR(formals);
   }
   Rf_setAttrib(args, R_NamesSymbol, dispatch_args);
 
-  UNPROTECT(1);
+  UNPROTECT(3);
 
   return args;
 }
 
 __attribute__ ((noreturn))
 void S7_method_lookup_error(SEXP generic, SEXP envir) {
-  SEXP ns = Rf_findVarInFrame(R_NamespaceRegistry, Rf_install(""S7""));
-  static SEXP S7_method_lookup_error_fun = NULL;
-  if (S7_method_lookup_error_fun == NULL) {
-    S7_method_lookup_error_fun = Rf_findVarInFrame(ns, Rf_install(""method_lookup_error""));
-  }
 
   SEXP name = Rf_getAttrib(generic, R_NameSymbol);
   SEXP args = generic_args(generic, envir);
 
-  SEXP S7_method_lookup_error_call = PROTECT(Rf_lang3(S7_method_lookup_error_fun, name, args));
-  Rf_eval(S7_method_lookup_error_call, ns);
+  SEXP S7_method_lookup_error_call = PROTECT(Rf_lang3(Rf_install(""method_lookup_error""), name, args));
+  Rf_eval(S7_method_lookup_error_call, ns_S7);
 
   while(1);
 }
@@ -88,31 +129,25 @@ SEXP method_(SEXP generic, SEXP signature, SEXP envir, SEXP error_) {
     return R_NilValue;
   }
 
-  SEXP table = Rf_getAttrib(generic, Rf_install(""methods""));
+  SEXP table = Rf_getAttrib(generic, sym_methods);
   if (TYPEOF(table) != ENVSXP) {
     Rf_error(""Corrupt S7_generic: @methods isn't an environment"");
   }
 
   SEXP m = method_rec(table, signature, 0);
 
-  int error = Rf_asInteger(error_);
-  if (error && m == R_NilValue) {
+  if (m == R_NilValue && Rf_asLogical(error_)) {
     S7_method_lookup_error(generic, envir);
   }
 
   return m;
 }
 
-SEXP S7_obj_dispatch(SEXP object) {
-  SEXP ns = Rf_findVarInFrame(R_NamespaceRegistry, Rf_install(""S7""));
 
-  static SEXP obj_dispatch_fun = NULL;
-  if (obj_dispatch_fun == NULL) {
-    obj_dispatch_fun = Rf_findVarInFrame(ns, Rf_install(""obj_dispatch""));
-  }
+SEXP S7_obj_dispatch(SEXP object) {
 
-  SEXP obj_dispatch_call = PROTECT(Rf_lang2(obj_dispatch_fun, object));
-  SEXP res = Rf_eval(obj_dispatch_call, ns);
+  SEXP obj_dispatch_call = PROTECT(Rf_lang2(sym_obj_dispatch, maybe_enquote(object)));
+  SEXP res = Rf_eval(obj_dispatch_call, ns_S7);
   UNPROTECT(1);
 
   return res;
@@ -126,77 +161,98 @@ SEXP S7_object_(void) {
   return obj;
 }
 
-SEXP method_call_(SEXP call, SEXP generic, SEXP envir) {
-  int n_protect = 0;
+SEXP method_call_(SEXP call_, SEXP op_, SEXP args_, SEXP env_) {
+  args_ = CDR(args_);
+  SEXP generic = CAR(args_); args_ = CDR(args_);
+  SEXP envir = CAR(args_); args_ = CDR(args_);
 
   // Get the number of arguments to the generic
   SEXP formals = FORMALS(generic);
   R_xlen_t n_args = Rf_xlength(formals);
   // And how many are used for dispatch
-  SEXP dispatch_args = Rf_getAttrib(generic, Rf_install(""dispatch_args""));
+  SEXP dispatch_args = Rf_getAttrib(generic, sym_dispatch_args);
   R_xlen_t n_dispatch = Rf_xlength(dispatch_args);
 
   // Allocate a list to store the classes for the arguments
   SEXP dispatch_classes = PROTECT(Rf_allocVector(VECSXP, n_dispatch));
-  ++n_protect;
 
   // Allocate a pairlist to hold the arguments for when we call the method
   SEXP mcall = PROTECT(Rf_lcons(R_NilValue, R_NilValue));
-  ++n_protect;
   SEXP mcall_tail = mcall;
 
+  PROTECT_INDEX arg_pi, val_pi;
+  PROTECT_WITH_INDEX(R_NilValue, &arg_pi);
+  PROTECT_WITH_INDEX(R_NilValue, &val_pi);
+
   // For each of the arguments to the generic
   for (R_xlen_t i = 0; i < n_args; ++i) {
 
-    // Find its name and look up its value (a promise)
     SEXP name = TAG(formals);
-    SEXP arg = Rf_findVar(name, envir);
 
     if (i < n_dispatch) {
-      if (PRCODE(arg) != R_MissingArg) {
-        // Evaluate the original promise so we can look up its class
-        SEXP val = PROTECT(Rf_eval(arg, R_EmptyEnv));
 
-        if (!Rf_inherits(val, ""S7_super"")) {
+      SEXP arg = Rf_findVarInFrame(envir, name);
+      if (arg == R_MissingArg) {
+
+        APPEND_NODE(mcall_tail, name, arg);
+        SET_VECTOR_ELT(dispatch_classes, i, Rf_mkString(""MISSING""));
+
+      } else { // arg not missing, is a PROMSXP
+
+        // Force the promise so we can look up its class.
+        // However, we preserve and pass along the promise itself so that
+        // methods can still call substitute()
+        // Instead of Rf_eval(arg, R_EmptyEnv), we do Rf_eval(name, envir), so that
+        // - if TYPEOF(arg) == LANGSXP or SYMSXP, arg doesn't need to be enquoted and
+        // - if TYPEOF(arg) == PROMSXP, arg is updated in place.
+        REPROTECT(arg, arg_pi); // not really necessary, but rchk flags spuriously
+        SEXP val = Rf_eval(name, envir);
+        REPROTECT(val, val_pi);
+
+        if (Rf_inherits(val, ""S7_super"")) {
+
 
-          // If it's a promise, update the value of the promise to avoid
-          // evaluating it again in the method body
-          if (TYPEOF(val) == PROMSXP) {
-            SET_PRVALUE(arg, val);
-          }
+          // Put the super() stored value into the method call.
+          // Note: This means we don't pass along the arg PROMSXP, meaning that
+          // substitute() in methods does not retrieve the `super()` call.
+          // If we wanted substitute() to work here too, we could do:
+          //   if (TYPEOF(arg) == PROMSXP) { SET_PRVALUE(arg, true_val); } else { arg = true_val; }
+          SEXP arg = VECTOR_ELT(val, 0); // true_val used for dispatch
+          APPEND_NODE(mcall_tail, name, arg);
 
-          // Then add to arguments of method call
-          SETCDR(mcall_tail, Rf_cons(arg, R_NilValue));
+          // Put the super() stored class dispatch vector into dispatch_classes
+          SET_VECTOR_ELT(dispatch_classes, i, VECTOR_ELT(val, 1));
+
+        } else { // val is not a S7_super, a regular value
+
+          // The PROMSXP arg will have been updated in place by Rf_eval() above.
+          // Add to arguments of method call
+          APPEND_NODE(mcall_tail, name, arg);
 
           // Determine class string to use for method look up
           SET_VECTOR_ELT(dispatch_classes, i, S7_obj_dispatch(val));
-        } else {
-          // If it's a superclass, we get the stored value and dispatch class
-          SEXP true_val = VECTOR_ELT(val, 0);
-          SET_PRVALUE(arg, true_val);
-          SETCDR(mcall_tail, Rf_cons(arg, R_NilValue));
-          SET_VECTOR_ELT(dispatch_classes, i, VECTOR_ELT(val, 1));
         }
-        UNPROTECT(1);
-      } else {
-        SETCDR(mcall_tail, Rf_cons(name, R_NilValue));
-        SET_VECTOR_ELT(dispatch_classes, i, Rf_mkString(""MISSING""));
       }
     } else {
       // other arguments not used for dispatch
-      SEXP arg_wrap = Rf_cons(name, R_NilValue);
-      SET_TAG(arg_wrap, name);
-      SETCDR(mcall_tail, arg_wrap);
+      if (name == R_DotsSymbol) {
+        SETCDR(mcall_tail, Rf_cons(R_DotsSymbol, R_NilValue));
+      } else {
+        // pass along the promise so substitute() works
+        SEXP arg = Rf_findVarInFrame(envir, name);
+        APPEND_NODE(mcall_tail, name, arg);
+      }
     }
 
     mcall_tail = CDR(mcall_tail);
     formals = CDR(formals);
   }
 
   // Now that we have all the classes, we can look up what method to call
-  SEXP m = method_(generic, dispatch_classes, envir, Rf_ScalarLogical(1));
+  SEXP m = method_(generic, dispatch_classes, envir, R_TRUE);
   SETCAR(mcall, m);
 
-  UNPROTECT(n_protect);
-  return mcall;
+  SEXP out = Rf_eval(mcall, envir);
+  UNPROTECT(4);
+  return out;
 }

---FILE: tests/testthat/_snaps/R-lt-4-3/method-dispatch.md---
@@ -0,0 +1,8 @@
+# method dispatch works for class_missing
+
+    Code
+      foo_wrapper()
+    Condition
+      Error in `S7::S7_dispatch()`:
+      ! argument ""xx"" is missing, with no default
+

---FILE: tests/testthat/_snaps/method-dispatch.md---
@@ -49,3 +49,11 @@
       - x: <logical>
       - y: <logical>
 
+# method dispatch works for class_missing
+
+    Code
+      foo_wrapper()
+    Condition
+      Error in `foo_wrapper()`:
+      ! argument ""xx"" is missing, with no default
+

---FILE: tests/testthat/test-method-dispatch.R---
@@ -72,9 +72,32 @@ test_that(""can substitute() args"", {
   )
   expect_equal(foo(""x"", y = letters), quote(letters))
 
-  # Doesn't work currently
-  # method(foo, class_character) <- function(x, ..., z = 1) substitute(z)
-  # expect_equal(foo(""x"", z = letters), quote(letters))
+  suppressMessages(
+    method(foo, class_character) <- function(x, ..., z = 1) substitute(z)
+  )
+  expect_equal(foo(""x"", z = letters), quote(letters))
+
+  suppressMessages(
+    method(foo, class_character) <- function(x, ..., z = 1) substitute(list(...))
+  )
+  expect_equal(foo(""x"", abc = xyz), quote(list(abc = xyz)))
+
+  suppressMessages(
+    method(foo, class_character) <- function(x, ..., z = 1, y) missing(y)
+  )
+  expect_true(foo(""x""), TRUE)
+  expect_true(foo(""x"", y =), TRUE)
+    expect_true(foo(""x"", y =), TRUE)
+
+  suppressMessages(
+    method(foo, class_character) <- function(x, ..., z = 1, y) ...length()
+  )
+
+  expect_equal(foo(""x""), 0)
+  expect_equal(foo(""x"", y =), 0)
+  expect_equal(foo(""x"", y =, abc), 1)
+  expect_equal(foo(""x"", y =, abc = xyz), 1)
+  expect_equal(foo(""x"", y =, abc, xyz), 2)
 })
 
 test_that(""methods get values modified in the generic"", {
@@ -186,3 +209,21 @@ test_that(""can dispatch on evaluated arguments"", {
   method(my_generic, class_numeric) <- function(x) 100
   expect_equal(my_generic(""x""), 100)
 })
+
+
+test_that(""method dispatch works for class_missing"", {
+
+  foo <- new_generic(""foo"", ""x"")
+  method(foo, class_missing) <- function(x) missing(x)
+
+  expect_true(foo())
+
+  # dispatch on class_missing only works directly in the generic call
+  foo_wrapper <- function(xx) foo(xx)
+  expect_snapshot(
+    error = TRUE,
+    variant = if (getRversion() < ""4.3"") ""R-lt-4-3"",
+    foo_wrapper()
+  )
+
+})"
RConsortium,S7,5935df1c38b71eeaabf040dcb88c95f7bcbf56e2,Tomasz Kalinowski,tomasz@posit.co,2024-10-29T12:50:52Z,GitHub,noreply@github.com,2024-10-29T12:50:52Z,"Show generic signature in error message (#482)

* Show generic signature in error message

closes #480

* show method formals in error message

* Update R/method-register.R

Co-authored-by: Hadley Wickham <h.wickham@gmail.com>

* update snapshot

---------

Co-authored-by: Hadley Wickham <h.wickham@gmail.com>",R/method-register.R;tests/testthat/_snaps/method-register.md,False,True,True,False,9,2,11,"---FILE: R/method-register.R---
@@ -181,9 +181,14 @@ check_method <- function(method, generic, name = paste0(generic@name, ""(???)""))
 
   if (!""..."" %in% generic_args && !identical(generic_formals, method_formals)) {
     msg <- sprintf(
-      ""%s() lacks `...` so method formals must match generic formals exactly"",
+      ""%s() generic lacks `...` so method formals must match generic formals exactly."",
       generic@name
     )
+    bullets <- c(
+      sprintf(""- generic formals: %s"", show_args(generic_formals, name = generic@name)),
+      sprintf(""- method formals:  %s"", show_args(method_formals, name = generic@name))
+    )
+    msg <- paste0(c(msg, bullets), collapse = ""\n"")
     stop(msg, call. = FALSE)
   }
 

---FILE: tests/testthat/_snaps/method-register.md---
@@ -81,7 +81,9 @@
       check_method(function(x, y) { }, foo)
     Condition
       Error:
-      ! foo() lacks `...` so method formals must match generic formals exactly
+      ! foo() generic lacks `...` so method formals must match generic formals exactly.
+      - generic formals: foo(x)
+      - method formals:  foo(x, y)
 
 # check_method warn if default arguments don't match
 "
RConsortium,S7,70d1c85dac5fff29c02d69c7581038164dd84b86,Tomasz Kalinowski,tomasz@posit.co,2024-10-25T13:43:43Z,GitHub,noreply@github.com,2024-10-25T13:43:43Z,"Fix custom `getter`s with `class_call` objects (#470)

* print `topNamespaceName()` NULL value

* protect call objects from evaluation when calling custom `getter`

* add test for call `getter()`

* fix custom `getter` on language objects.

* allow subsetting `class_call` objects

* add tests for custom `setter` on `class_call` objects

* tidy; dry; rename helper

* Update R/zzz.R

Co-authored-by: Hadley Wickham <h.wickham@gmail.com>

* Update R/zzz.R

Co-authored-by: Hadley Wickham <h.wickham@gmail.com>

* Use early return in `topNamespaceName()` for readability

---------

Co-authored-by: Hadley Wickham <h.wickham@gmail.com>",R/aaa.R;R/zzz.R;src/init.c;src/prop.c;tests/testthat/_snaps/zzz.md;tests/testthat/helper.R;tests/testthat/test-property.R,False,True,True,False,165,17,182,"---FILE: R/aaa.R---
@@ -25,8 +25,11 @@ new_function <- function(args = NULL,
 
 topNamespaceName <- function(env = parent.frame()) {
   env <- topenv(env)
-  if (isNamespace(env))
-    getNamespaceName(env)
+  if (!isNamespace(env)) {
+    return()
+  }
+
+  getNamespaceName(env)
 }
 
 is_string <- function(x) {

---FILE: R/zzz.R---
@@ -82,9 +82,9 @@ is_S7_type <- function(x) {
 }
 
 check_subsettable <- function(x, allow_env = FALSE) {
-  allowed_types <- c(""list"", if (allow_env) ""environment"")
+  allowed_types <- c(""list"", ""language"", ""pairlist"", if (allow_env) ""environment"")
   if (!typeof(x) %in% allowed_types) {
-    stop(""S7 objects are not subsettable."", call. = FALSE)
+    stop(""S7 objects are not subsettable."")
   }
   invisible(TRUE)
 }

---FILE: src/init.c---
@@ -36,6 +36,8 @@ SEXP sym_dot_should_validate;
 SEXP sym_dot_getting_prop;
 SEXP sym_dot_setting_prop;
 
+SEXP fn_base_quote;
+
 SEXP ns_S7;
 
 
@@ -58,5 +60,7 @@ void R_init_S7(DllInfo *dll)
     sym_dot_getting_prop = Rf_install("".getting_prop"");
     sym_dot_setting_prop = Rf_install("".setting_prop"");
 
+    fn_base_quote = Rf_eval(Rf_install(""quote""), R_BaseEnv);
+
     ns_S7 = Rf_findVarInFrame(R_NamespaceRegistry, Rf_install(""S7""));
 }

---FILE: src/prop.c---
@@ -18,6 +18,8 @@ extern SEXP sym_dot_should_validate;
 extern SEXP sym_dot_getting_prop;
 extern SEXP sym_dot_setting_prop;
 
+extern SEXP fn_base_quote;
+
 static inline
 SEXP eval_here(SEXP lang) {
   PROTECT(lang);
@@ -26,6 +28,51 @@ SEXP eval_here(SEXP lang) {
   return ans;
 }
 
+static inline
+SEXP do_call1(SEXP fn, SEXP arg) {
+  SEXP call, answer;
+  switch (TYPEOF(arg)) {
+  case LANGSXP:
+  case SYMSXP:
+    arg = PROTECT(Rf_lang2(fn_base_quote, arg));
+    call = PROTECT(Rf_lang2(fn, arg));
+    answer = Rf_eval(call, ns_S7);
+    UNPROTECT(2);
+    return answer;
+  default:
+    call = PROTECT(Rf_lang2(fn, arg));
+    answer = Rf_eval(call, ns_S7);
+    UNPROTECT(1);
+    return answer;
+  }
+}
+
+static inline SEXP do_call2(SEXP fn, SEXP arg1, SEXP arg2) {
+  int n_protected = 0;
+  // Protect the arguments from evaluation if they are SYMSXP or LANGSXP
+  switch (TYPEOF(arg1)) {
+  case LANGSXP:
+  case SYMSXP:
+    arg1 = PROTECT(Rf_lang2(fn_base_quote, arg1));
+    ++n_protected;
+  }
+
+  switch (TYPEOF(arg2)) {
+  case LANGSXP:
+  case SYMSXP:
+    arg2 = PROTECT(Rf_lang2(fn_base_quote, arg2));
+    ++n_protected;
+  }
+
+  SEXP call = PROTECT(Rf_lang3(fn, arg1, arg2));
+  ++n_protected;
+
+  SEXP result = Rf_eval(call, ns_S7);
+
+  UNPROTECT(n_protected);
+  return result;
+}
+
 static __attribute__((noreturn))
 void signal_is_not_S7(SEXP object) {
   static SEXP check_is_S7 = NULL;
@@ -207,13 +254,25 @@ void obj_validate(SEXP object) {
   if (validate == NULL)
     validate = Rf_findVarInFrame(ns_S7, Rf_install(""validate""));
 
-  eval_here(Rf_lang4(
-    validate, object,
-    /* recursive = */ Rf_ScalarLogical(TRUE),
-    /* properties = */ Rf_ScalarLogical(FALSE)));
-}
-
+  switch (TYPEOF(object)) {
+  case LANGSXP:
+  case SYMSXP: {
+    // Wrap the call or symbol in quote(), so it doesn't evaluate in Rf_eval()
+    object = PROTECT(Rf_lang2(fn_base_quote, object));
+    eval_here(Rf_lang4(validate, object,
+                       /* recursive = */ Rf_ScalarLogical(TRUE),
+                       /* properties = */ Rf_ScalarLogical(FALSE)));
+    UNPROTECT(1); // object
+    return;
+  }
 
+  default:
+    eval_here(Rf_lang4(
+        validate, object,
+        /* recursive = */ Rf_ScalarLogical(TRUE),
+        /* properties = */ Rf_ScalarLogical(FALSE)));
+  }
+}
 
 static inline
 Rboolean getter_callable_no_recurse(SEXP getter, SEXP object, SEXP name_sym) {
@@ -248,9 +307,10 @@ SEXP prop_(SEXP object, SEXP name) {
   SEXP getter = extract_name(property, ""getter"");
   if (TYPEOF(getter) == CLOSXP &&
       getter_callable_no_recurse(getter, object, name_sym)) {
-    SEXP value = PROTECT(eval_here(Rf_lang2(getter, object)));
+
+    SEXP value = PROTECT(do_call1(getter, object));
     getter_no_recurse_clear(object, name_sym);
-    UNPROTECT(1);
+    UNPROTECT(1); // value
     return value;
   }
 
@@ -316,7 +376,7 @@ SEXP prop_set_(SEXP object, SEXP name, SEXP check_sexp, SEXP value) {
 
   if (setter_callable_no_recurse(setter, object, name_sym, &should_validate_obj)) {
     // use setter()
-    REPROTECT(object = eval_here(Rf_lang3(setter, object, value)), object_pi);
+    REPROTECT(object = do_call2(setter, object, value), object_pi);
     setter_no_recurse_clear(object, name_sym);
   } else {
     // don't use setter()

---FILE: tests/testthat/_snaps/zzz.md---
@@ -22,12 +22,12 @@
       x <- new_class(""foo"")()
       x[1]
     Condition
-      Error:
+      Error in `check_subsettable()`:
       ! S7 objects are not subsettable.
     Code
       x[1] <- 1
     Condition
-      Error:
+      Error in `check_subsettable()`:
       ! S7 objects are not subsettable.
 
 # [[ gives more accurate error
@@ -36,11 +36,11 @@
       x <- new_class(""foo"")()
       x[[1]]
     Condition
-      Error:
+      Error in `check_subsettable()`:
       ! S7 objects are not subsettable.
     Code
       x[[1]] <- 1
     Condition
-      Error:
+      Error in `check_subsettable()`:
       ! S7 objects are not subsettable.
 

---FILE: tests/testthat/helper.R---
@@ -140,3 +140,8 @@ dbg <- function(..., .display = utils::str, .file = NULL) {
 }
 
 `%error%` <- function(x, y) tryCatch(x, error = function(e) y)
+
+drop_attributes <- function(x) {
+  attributes(x) <- NULL
+  x
+}

---FILE: tests/testthat/test-property.R---
@@ -444,3 +444,79 @@ test_that(""custom setters can call custom getters"", {
   expect_equal(x@someprop, ""FOOFOO"")
 
 })
+
+
+test_that(""custom getters don't evaulate call objects"", {
+  QuotedCall :=  new_class(class_call, properties = list(
+    name = new_property(getter = function(self) {
+      stopifnot(is.call(self))
+      as.character(self[[1]])
+    }),
+    args = new_property(getter = function(self) {
+      stopifnot(is.call(self))
+      as.list(self)[-1]
+    })
+  ), constructor = function(x) {
+    new_object(substitute(x))
+  })
+
+  cl <- QuotedCall(stop(""boom""))
+  expect_equal(cl@name, ""stop"")
+  expect_equal(cl@args, list(""boom""))
+
+})
+
+
+test_that(""custom setters don't evaulate call objects"", {
+
+  Call :=  new_class(class_call, properties = list(
+    name = new_property(
+      getter = function(self) {
+        stopifnot(is.call(self))
+        as.character(self[[1]])
+      },
+      setter = function(self, value) {
+        stopifnot(is.call(self), is.name(value))
+        self[[1]] <- value
+        self
+      }
+    ),
+    args = new_property(
+      getter = function(self) {
+        stopifnot(is.call(self))
+        as.list(self)[-1]
+      },
+      setter = function(self, value) {
+        stopifnot(is.call(self), is.list(value) || is.pairlist(value))
+        # self[seq(2, length.out = length(value))] <- value
+        # names(self) <- c("""", names(value))
+        # self
+        out <- as.call(c(self[[1]], value))
+        attributes(out) <- attributes(self)
+        out
+      })
+  ), constructor = function(name, ...) {
+    new_object(as.call(c(as.name(name), ...)))
+  })
+
+  cl <- Call(""stop"", ""boom"")
+  expect_identical(cl@name, ""stop"")
+  expect_identical(cl@args, list(""boom""))
+
+  abort <- stop
+  cl@name <- quote(abort)
+  expect_identical(cl@name, ""abort"")
+  expect_identical(cl[[1]], quote(abort))
+
+  cl@args <- pairlist(""boom2"")
+  expect_identical(cl[[2]], ""boom2"")
+  expect_identical(cl@args, list(""boom2""))
+  expect_identical(drop_attributes(cl), quote(abort(""boom2"")))
+
+  cl@args <- alist(msg = ""boom3"", foo = bar, baz)
+  expect_identical(cl@args, alist(msg = ""boom3"", foo = bar, baz))
+
+  expect_identical(drop_attributes(cl),
+                   quote(abort(msg = ""boom3"", foo = bar, baz)))
+
+})"
RConsortium,S7,5e939fbeff144cfb377abf8bab770008a81847bf,Tomasz Kalinowski,tomasz@posit.co,2024-10-22T13:16:13Z,GitHub,noreply@github.com,2024-10-22T13:16:13Z,"Fix error when constructor formals are empty (#475)

* accept `modify_list(NULL, list())`",R/utils.R,False,True,True,False,3,1,4,"---FILE: R/utils.R---
@@ -138,6 +138,8 @@ modify_list <- function (x, new_vals) {
     nms <- names2(new_vals)
     if (!all(nzchar(nms)))
       stop(""all elements in `new_vals` must be named"")
+    if (is.null(x))
+      x <- list()
     x[nms] <- new_vals
   }
 
@@ -146,7 +148,7 @@ modify_list <- function (x, new_vals) {
 
 deparse_trunc <- function(x, width, collapse = ""\n"") {
   x <- deparse1(x, collapse)
-  if (nchar(x)> width)
+  if (nchar(x) > width)
     x <- sprintf(""%s...."", substr(x, 0, width-4))
   x
 }"
RConsortium,S7,b5cf389d7c6dc676c2d938e2feac6d7ec04d0c50,Tomasz Kalinowski,tomasz@posit.co,2024-10-16T20:10:08Z,GitHub,noreply@github.com,2024-10-16T20:10:08Z,"Automatically detect package name in `new_class(package=)` (#459)

* add `topNamespaceName()`

* fixes to prevent `S7::` class prefix in package code

* fixes to prevent `S7::` class prefix in tests

* add NEWS

* use explicit `package=NULL` in snapshot tests

---------

Co-authored-by: Hadley Wickham <h.wickham@gmail.com>",NEWS.md;R/aaa.R;R/class.R;R/method-register.R;R/super.R;R/zzz.R;man/new_class.Rd;man/super.Rd;tests/testthat/_snaps/class.md;tests/testthat/_snaps/inherits.md;tests/testthat/_snaps/super.md;tests/testthat/_snaps/union.md;tests/testthat/helper.R;tests/testthat/test-S3.R;tests/testthat/test-class-spec.R;tests/testthat/test-class.R;tests/testthat/test-constructor.R;tests/testthat/test-convert.R;tests/testthat/test-generic.R;tests/testthat/test-inherits.R;tests/testthat/test-method-dispatch.R;tests/testthat/test-method-introspect.R;tests/testthat/test-method-register.R;tests/testthat/test-property.R;tests/testthat/test-super.R;tests/testthat/test-union.R;tests/testthat/test-valid.R;tests/testthat/test-zzz.R,False,True,True,False,92,65,157,"---FILE: NEWS.md---
@@ -1,13 +1,16 @@
 # S7 (development version)
 
+* `new_class()` now automatically infers the package name when called from 
+  within an R package (#459).
+
 * Improved error message when custom validators return invalid values (#454, #457).
 
 * New `nameOfClass()` method exported for S7 base classes, to enable usage like
   `inherits(""foo"", S7::class_character)` (#432, #458)
 
 * Added support for more base/S3 classes (#434):
-    `class_POSIXlt`, `class_POSIXt`, `class_matrix`, `class_array`,
-    `class_formula`, `class_call`, `class_language`, `class_name`
+    `class_POSIXlt`, `class_POSIXt`, `class_formula`, 
+    `class_call`, `class_language`, `class_name`
 
 * Fixed S3 methods registration across packages (#422).
 

---FILE: R/aaa.R---
@@ -22,6 +22,13 @@ new_function <- function(args = NULL,
   x
 }
 
+
+topNamespaceName <- function(env = parent.frame()) {
+  env <- topenv(env)
+  if (isNamespace(env))
+    getNamespaceName(env)
+}
+
 is_string <- function(x) {
   identical(class(x), ""character"") && length(x) == 1L && !is.na(x) && x != """"
 }

---FILE: R/class.R---
@@ -100,7 +100,7 @@
 new_class <- function(
     name,
     parent = S7_object,
-    package = NULL,
+    package = topNamespaceName(parent.frame()),
     properties = list(),
     abstract = FALSE,
     constructor = NULL,

---FILE: R/method-register.R---
@@ -107,7 +107,6 @@ register_S3_method <- function(generic, signature, method, envir = parent.frame(
   }
 
   class <- S7_class_name(signature[[1]])
-  # dbg(generic$name, class, method, envir)
   registerS3method(generic$name, class, method, envir)
 }
 

---FILE: R/super.R---
@@ -26,7 +26,7 @@
 #' For example, imagine that you have made a subclass of ""integer"":
 #'
 #' ```{r}
-#' myint <- new_class(""myint"", parent = class_integer)
+#' myint <- new_class(""myint"", parent = class_integer, package = NULL)
 #' ```
 #'
 #' Now you go to write a custom print method:

---FILE: R/zzz.R---
@@ -10,6 +10,7 @@
 #' S7_object
 S7_object <- new_class(
   name = ""S7_object"",
+  package = NULL,
   parent = NULL,
   constructor = function() {
     .Call(S7_object_)
@@ -96,6 +97,7 @@ on_load_define_S7_generic <- function() {
   # errors if `@` is not usable.
   S7_generic <<- new_class(
     name = ""S7_generic"",
+    package = NULL,
     properties = list(
       name = class_character,
       methods = class_environment,
@@ -114,6 +116,7 @@ S7_method <- NULL
 on_load_define_S7_method <- function() {
   S7_method <<- new_class(
     ""S7_method"",
+    package = NULL,
     parent = class_function,
     properties = list(generic = S7_generic, signature = class_list)
   )

---FILE: man/new_class.Rd---
@@ -8,7 +8,7 @@
 new_class(
   name,
   parent = S7_object,
-  package = NULL,
+  package = topNamespaceName(parent.frame()),
   properties = list(),
   abstract = FALSE,
   constructor = NULL,

---FILE: man/super.Rd---
@@ -42,7 +42,7 @@ understand and reason about.
 Note that you can't use \code{super()} in methods for an S3 generic.
 For example, imagine that you have made a subclass of ""integer"":
 
-\if{html}{\out{<div class=""sourceCode r"">}}\preformatted{myint <- new_class(""myint"", parent = class_integer)
+\if{html}{\out{<div class=""sourceCode r"">}}\preformatted{myint <- new_class(""myint"", parent = class_integer, package = NULL)
 }\if{html}{\out{</div>}}
 
 Now you go to write a custom print method:

---FILE: tests/testthat/_snaps/class.md---
@@ -174,7 +174,8 @@
 # S7 object: displays nicely
 
     Code
-      foo <- new_class(""foo"", properties = list(x = class_double, y = class_double))
+      foo <- new_class(""foo"", properties = list(x = class_double, y = class_double),
+      package = NULL)
       foo()
     Output
       <foo>
@@ -191,7 +192,7 @@
 # S7 object: displays objects with data nicely
 
     Code
-      text <- new_class(""text"", class_character)
+      text <- new_class(""text"", class_character, package = NULL)
       text(""x"")
     Output
       <text> chr ""x""

---FILE: tests/testthat/_snaps/inherits.md---
@@ -9,8 +9,8 @@
 # throws informative error
 
     Code
-      foo1 <- new_class(""foo1"")
-      foo2 <- new_class(""foo2"")
+      foo1 <- new_class(""foo1"", package = NULL)
+      foo2 <- new_class(""foo2"", package = NULL)
       check_is_S7(foo1(), foo2)
     Condition
       Error:

---FILE: tests/testthat/_snaps/super.md---
@@ -1,7 +1,7 @@
 # super(): checks to
 
     Code
-      foo <- new_class(""foo"")
+      foo <- new_class(""foo"", package = NULL)
       super(foo(), class_character)
     Condition
       Error in `super()`:

---FILE: tests/testthat/_snaps/union.md---
@@ -1,8 +1,8 @@
 # has useful print method
 
     Code
-      foo1 <- new_class(""foo1"")
-      foo2 <- new_class(""foo2"")
+      foo1 <- new_class(""foo1"", package = NULL)
+      foo2 <- new_class(""foo2"", package = NULL)
       new_union(foo1, foo2)
     Output
       <S7_union>: <foo1> or <foo2>

---FILE: tests/testthat/helper.R---
@@ -80,10 +80,15 @@ named_list <- function(...) {
 
 `add<-` <- `+`
 
-dbg <- function(..., .display = utils::str) {
+dbg <- function(..., .display = utils::str, .file = NULL) {
   out <- NULL
   exprs <- as.list(substitute(list(...)))[-1L]
 
+  if (!is.null(.file)) {
+    sink(.file, append = TRUE)
+    on.exit(sink())
+  }
+
   for (i in seq_len(...length())) {
     ..i <- as.symbol(sprintf(""..%i"", i))
     if (eval(substitute(missing(..i)))) {
@@ -98,7 +103,7 @@ dbg <- function(..., .display = utils::str) {
     } else {
       sprintf(""(%s) `%s`"", name, expr)
     }
-    cat(label, "": "", sep = """")
+    cat(label, if (identical(.display, utils::str)) "": "" else ""\n"", sep = """")
     .display(out <- eval(..i))
   }
 
@@ -127,9 +132,11 @@ dbg <- function(..., .display = utils::str) {
     cat(loc, ""\n"")
   } else {
     cat(sprintf(""(from call: %s (srcfile missing))\n"", trimws(
-      deparse1(sys.call(-2), width.cutoff = 60)
+      deparse1(sys.call(-2) %error% sys.call(-1), width.cutoff = 60)
     )))
   }
 
   invisible(out)
 }
+
+`%error%` <- function(x, y) tryCatch(x, error = function(e) y)

---FILE: tests/testthat/test-S3.R---
@@ -3,7 +3,7 @@ test_that(""new_S3_class has a print method"", {
 })
 
 test_that(""can construct objects that extend S3 classes"", {
-  ordered2 <- new_class(""ordered2"", parent = class_factor)
+  ordered2 <- new_class(""ordered2"", parent = class_factor, package = NULL)
   x <- ordered2(c(1L, 2L, 1L), letters[1:3])
   expect_equal(class(x), c(""ordered2"", ""factor"", ""S7_object""))
   expect_equal(prop_names(x), character())
@@ -15,7 +15,7 @@ test_that(""subclasses inherit validator"", {
     function(.data) structure(.data, class = ""foo""),
     function(x) if (!is.double(x)) ""Underlying data must be a double""
   )
-  foo2 <- new_class(""foo2"", foo)
+  foo2 <- new_class(""foo2"", foo, package = NULL)
 
   expect_snapshot(error = TRUE, foo2(""a""))
 })

---FILE: tests/testthat/test-class-spec.R---
@@ -1,5 +1,5 @@
 test_that(""can work with S7 classes"", {
-  klass <- new_class(""klass"")
+  klass <- new_class(""klass"", package = NULL)
   expect_equal(as_class(klass), klass)
 
   expect_equal(class_type(klass), ""S7"")
@@ -35,8 +35,8 @@ test_that(""can work with S7 classes in packages"", {
 })
 
 test_that(""can work with unions"", {
-  text <- new_class(""text"", class_character)
-  number <- new_class(""number"", class_double)
+  text <- new_class(""text"", class_character, package = NULL)
+  number <- new_class(""number"", class_double, package = NULL)
   klass <- new_union(text, number)
   expect_equal(as_class(klass), klass)
 
@@ -144,7 +144,8 @@ test_that(""can work with S3 classes"", {
 
 test_that(""can work with S7 classes that extend S3 classes"", {
   Date <- new_S3_class(""Date"", constructor = function(.data = numeric()) .Date(.data))
-  Date2 <- new_class(""Date2"", parent = Date, properties = list(x = class_numeric))
+  Date2 <- new_class(""Date2"", parent = Date, properties = list(x = class_numeric),
+                     package = NULL)
 
   expect_equal(class_type(Date2), ""S7"")
   expect_equal(class_dispatch(Date2), c(""Date2"", ""Date"", ""S7_object""))

---FILE: tests/testthat/test-class.R---
@@ -11,8 +11,8 @@ describe(""S7 classes"", {
   })
 
   it(""print nicely"", {
-    foo1 <- new_class(""foo1"", properties = list(x = class_integer, y = class_integer))
-    foo2 <- new_class(""foo2"", foo1)
+    foo1 <- new_class(""foo1"", properties = list(x = class_integer, y = class_integer), package = NULL)
+    foo2 <- new_class(""foo2"", foo1, package = NULL)
 
     expect_snapshot({
       foo2
@@ -85,8 +85,8 @@ describe(""abstract classes"", {
     })
   })
   it(""can construct concrete subclasses"", {
-    foo1 <- new_class(""foo1"", abstract = TRUE)
-    foo2 <- new_class(""foo2"", parent = foo1)
+    foo1 <- new_class(""foo1"", abstract = TRUE, package = NULL)
+    foo2 <- new_class(""foo2"", parent = foo1, package = NULL)
     expect_s3_class(foo2(), ""foo2"")
   })
   it(""can use inherited validator from abstract class"", {
@@ -96,9 +96,10 @@ describe(""abstract classes"", {
       abstract = TRUE,
       validator = function(self) {
         if (self@x == 2) ""@x has bad value""
-      }
+      },
+      package = NULL
     )
-    foo2 <- new_class(""foo2"", parent = foo1)
+    foo2 <- new_class(""foo2"", parent = foo1, package = NULL)
     expect_no_error(foo2(x = 1))
     expect_snapshot(foo2(x = 2), error = TRUE)
   })
@@ -112,7 +113,8 @@ describe(""new_object()"", {
   it(""validates object"", {
     foo <- new_class(""foo"",
       properties = list(x = new_property(class_double)),
-      validator = function(self) if (self@x < 0) ""x must be positive""
+      validator = function(self) if (self@x < 0) ""x must be positive"",
+      package = NULL
     )
 
     expect_snapshot(error = TRUE, {
@@ -136,23 +138,24 @@ describe(""new_object()"", {
 
 describe(""S7 object"", {
   it(""has an S7 and S3 class"", {
-    foo <- new_class(""foo"")
+    foo <- new_class(""foo"", package = NULL)
     x <- foo()
     expect_equal(S7_class(x), foo)
     expect_equal(class(x), c(""foo"", ""S7_object""))
   })
 
   it(""displays nicely"", {
     expect_snapshot({
-      foo <- new_class(""foo"", properties = list(x = class_double, y = class_double))
+      foo <- new_class(""foo"", properties = list(x = class_double, y = class_double),
+                       package = NULL)
       foo()
       str(list(foo()))
     })
   })
 
   it(""displays objects with data nicely"", {
     expect_snapshot({
-      text <- new_class(""text"", class_character)
+      text <- new_class(""text"", class_character, package = NULL)
       text(""x"")
       str(list(text(""x"")))
     })
@@ -162,7 +165,8 @@ describe(""S7 object"", {
     foo1 <- new_class(
       ""foo1"",
       parent = class_list,
-      properties = list(x = class_double, y = class_list)
+      properties = list(x = class_double, y = class_list),
+      package = NULL
     )
     expect_snapshot(
       foo1(
@@ -213,8 +217,8 @@ describe(""default constructor"", {
   })
 
   it(""initializes property with S7 object"", {
-    foo1 <- new_class(""foo1"")
-    foo2 <- new_class(""foo2"", properties = list(x = foo1))
+    foo1 <- new_class(""foo1"", package = NULL)
+    foo2 <- new_class(""foo2"", properties = list(x = foo1), package = NULL)
     x <- foo2()
     expect_s3_class(x@x, ""foo1"")
   })

---FILE: tests/testthat/test-constructor.R---
@@ -164,7 +164,7 @@ test_that(""can create constructors with missing or lazy defaults"", {
 
 test_that(""Dynamic settable properties are included in constructor"", {
   Foo <- new_class(
-    name = ""Foo"",
+    name = ""Foo"", package = NULL,
     properties = list(
       dynamic_settable = new_property(
         class_numeric,

---FILE: tests/testthat/test-convert.R---
@@ -1,6 +1,6 @@
 test_that(""can register convert methods"", {
   local_methods(convert)
-  converttest <- new_class(""converttest"")
+  converttest <- new_class(""converttest"", package = NULL)
   method(convert, list(converttest, class_character)) <- function(from, to, ...) ""c""
   method(convert, list(converttest, class_integer)) <- function(from, to, ...) ""i""
 
@@ -25,17 +25,17 @@ describe(""fallback convert"", {
   local_methods(convert)
 
   it(""can convert to own class"", {
-    foo1 <- new_class(""foo1"")
-    foo2 <- new_class(""foo2"", foo1)
+    foo1 <- new_class(""foo1"", package = NULL)
+    foo2 <- new_class(""foo2"", foo1, package = NULL)
 
     obj <- convert(foo2(), to = foo2)
     expect_equal(class(obj), c(""foo2"", ""foo1"", ""S7_object""))
     expect_equal(S7_class(obj), foo2)
   })
 
   it(""can convert to super class"", {
-    foo1 <- new_class(""foo1"", properties = list(x = class_double))
-    foo2 <- new_class(""foo2"", foo1, properties = list(y = class_double))
+    foo1 <- new_class(""foo1"", properties = list(x = class_double), package = NULL)
+    foo2 <- new_class(""foo2"", foo1, properties = list(y = class_double), package = NULL)
 
     obj <- convert(foo2(1, 2), to = foo1)
     expect_equal(class(obj), c(""foo1"", ""S7_object""))

---FILE: tests/testthat/test-generic.R---
@@ -31,7 +31,7 @@ test_that(""check_dispatch_args() produces informative errors"", {
 
 test_that(""S7_generic printing"", {
   foo1 <- new_generic(""foo1"", ""x"")
-  text <- new_class(""text"")
+  text <- new_class(""text"", package = NULL)
 
   method(foo1, class_character) <- function(x) 1
   method(foo1, text) <- function(x) 2

---FILE: tests/testthat/test-inherits.R---
@@ -15,8 +15,8 @@ test_that(""checks that input is a class"", {
 
 test_that(""throws informative error"", {
   expect_snapshot(error = TRUE, {
-    foo1 <- new_class(""foo1"")
-    foo2 <- new_class(""foo2"")
+    foo1 <- new_class(""foo1"", package = NULL)
+    foo2 <- new_class(""foo2"", package = NULL)
     check_is_S7(foo1(), foo2)
   })
   expect_snapshot(check_is_S7(""a""), error = TRUE)

---FILE: tests/testthat/test-method-dispatch.R---
@@ -133,7 +133,7 @@ test_that(""can dispatch on base 'union' types"", {
 test_that(""single dispatch fails with informative messages"", {
   fail <- new_generic(""fail"", ""x"")
 
-  foo <- new_class(""foo"")
+  foo <- new_class(""foo"", package = NULL)
   Foo <- setClass(""Foo"", slots = list(""x"" = ""numeric""))
   on.exit(S4_remove_classes(""Foo""))
 

---FILE: tests/testthat/test-method-introspect.R---
@@ -39,8 +39,8 @@ describe(""method introspection"", {
 
 describe(""method explanation"", {
   it(""shows all possible methods along with matches"", {
-    foo1 <- new_class(""foo1"")
-    foo2 <- new_class(""foo2"", foo1)
+    foo1 <- new_class(""foo1"", package = NULL)
+    foo2 <- new_class(""foo2"", foo1, package = NULL)
 
     add <- new_generic(""add"", c(""x"", ""y""))
     method(add, list(foo2, foo1)) <- function(x, y) c(2, 1)

---FILE: tests/testthat/test-method-register.R---
@@ -73,7 +73,7 @@ describe(""method registration"", {
 
   it(""can register S7 method for S4 generic"", {
     methods::setGeneric(""bar"", function(x) standardGeneric(""bar""))
-    S4foo <- new_class(""S4foo"")
+    S4foo <- new_class(""S4foo"", package = NULL)
 
     expect_snapshot_error(method(bar, S4foo) <- function(x) ""foo"")
 

---FILE: tests/testthat/test-property.R---
@@ -1,6 +1,6 @@
 describe(""property retrieval"", {
   it(""retrieves the properties that exist & errors otherwise"", {
-    foo <- new_class(""foo"", properties = list(xyz = class_double))
+    foo <- new_class(""foo"", properties = list(xyz = class_double), package = NULL)
     obj <- foo(1)
     expect_equal(prop(obj, ""xyz""), 1)
     expect_equal(obj@xyz, 1)
@@ -48,15 +48,15 @@ describe(""prop setting"", {
   })
 
   it(""can't set read-only properties"", {
-    foo <- new_class(""foo"", properties = list(
+    foo <- new_class(""foo"", package = NULL, properties = list(
       x = new_property(getter = function(self) 1
     )))
     obj <- foo()
     expect_snapshot(obj@x <- 1, error = TRUE)
   })
 
   it(""errors if the property doesn't exist or is wrong class"", {
-    foo <- new_class(""foo"", properties = list(x = class_double))
+    foo <- new_class(""foo"", properties = list(x = class_double), package = NULL)
     expect_snapshot(error = TRUE, {
       obj <- foo(123)
       obj@foo <- 10
@@ -65,7 +65,7 @@ describe(""prop setting"", {
   })
 
   it(""validates all attributes if custom setter"", {
-    foo <- new_class(""foo"", properties = list(
+    foo <- new_class(""foo"", package = NULL, properties = list(
       x = new_property(
         class_double,
         setter = function(self, value) {
@@ -239,10 +239,11 @@ describe(""new_property()"", {
 })
 
 test_that(""properties can be base, S3, S4, S7, or S7 union"", {
-  class_S7 <- new_class(""class_S7"")
+  class_S7 <- new_class(""class_S7"", package = NULL)
   class_S4 <- methods::setClass(""class_S4"", slots = c(x = ""numeric""))
 
   my_class <- new_class(""my_class"",
+    package = NULL,
     properties = list(
       anything = class_any,
       null = NULL,
@@ -322,7 +323,7 @@ test_that(""can validate with custom validator"", {
     }
   }
   prop <- new_property(class_integer, validator = validate_scalar)
-  foo <- new_class(""foo"", properties = list(x = prop))
+  foo <- new_class(""foo"", package = NULL, properties = list(x = prop))
   expect_snapshot(error = TRUE, {
     f <- foo(x = 1L)
     f@x <- 1:2

---FILE: tests/testthat/test-super.R---
@@ -31,14 +31,14 @@ describe(""super()"", {
 
   it(""checks to"", {
     expect_snapshot(error = TRUE, {
-      foo <- new_class(""foo"")
+      foo <- new_class(""foo"", package = NULL)
       super(foo(), class_character)
     })
   })
 
   it(""displays nicely"", {
-    foo1 <- new_class(""foo1"")
-    foo2 <- new_class(""foo2"", foo1)
+    foo1 <- new_class(""foo1"", package = NULL)
+    foo2 <- new_class(""foo2"", foo1, package = NULL)
 
     expect_snapshot({
       f1 <- super(foo2(), foo1)

---FILE: tests/testthat/test-union.R---
@@ -1,7 +1,7 @@
 test_that(""has useful print method"", {
   expect_snapshot({
-    foo1 <- new_class(""foo1"")
-    foo2 <- new_class(""foo2"")
+    foo1 <- new_class(""foo1"", package = NULL)
+    foo2 <- new_class(""foo2"", package = NULL)
     new_union(foo1, foo2)
   })
 })

---FILE: tests/testthat/test-valid.R---
@@ -1,5 +1,5 @@
 test_that(""validate() validates object and type recursively"", {
-  klass <- new_class(""klass"",
+  klass <- new_class(""klass"", package = NULL,
     properties = list(x = class_double, y = class_double),
     validator = function(self) {
       c(
@@ -18,7 +18,8 @@ test_that(""validate() validates object and type recursively"", {
     validate(obj)
   })
 
-  klass2 <- new_class(""klass2"", parent = klass, properties = list(z = class_double))
+  klass2 <- new_class(""klass2"", parent = klass, package = NULL,
+                      properties = list(z = class_double))
   expect_snapshot(error = TRUE, {
     obj <- klass2(1, -1, 1)
     attr(obj, ""x"") <- -1
@@ -31,15 +32,15 @@ test_that(""validate() validates object and type recursively"", {
 })
 
 test_that(""validate checks base type"", {
-  Double <- new_class(""Double"", parent = class_double)
+  Double <- new_class(""Double"", package = NULL, parent = class_double)
   x <- Double(10)
   mode(x) <- ""character""
 
   expect_snapshot(error = TRUE, validate(x))
 })
 
 test_that(""validate checks the type of setters"", {
-  foo <- new_class(""foo"", properties = list(x =
+  foo <- new_class(""foo"", package = NULL, properties = list(x =
     new_property(
       class_double,
       setter = function(self, value) {

---FILE: tests/testthat/test-zzz.R---
@@ -1,5 +1,5 @@
 test_that(""S7_class validates its underlying data"", {
-  x <- new_class(""X"")()
+  x <- new_class(""X"", package = NULL)()
   expect_snapshot_error(S7_data(x) <- 1)
 })
 "
RConsortium,S7,6e2e5822ece716538af4b3705c14d17f6b0e034d,Tomasz Kalinowski,tomasz@posit.co,2024-10-16T18:23:00Z,GitHub,noreply@github.com,2024-10-16T18:23:00Z,"Include value in error message about invalid value from `register_method()` (#460)

* Include value in error message about invalid value from `register_method()`

Closes #447",R/generic-spec.R;R/utils.R;tests/testthat/_snaps/generic-spec.md,False,True,True,False,13,2,15,"---FILE: R/generic-spec.R---
@@ -28,7 +28,8 @@ as_S3_generic <- function(x) {
     }
   }
 
-  stop(""`generic` is a function, but not an S3 generic function"", call. = FALSE)
+  stop(""`generic` is a function, but not an S3 generic function: \n"",
+       deparse_trunc(x, 100), call. = FALSE)
 }
 
 S3_generic <- function(generic, name) {

---FILE: R/utils.R---
@@ -144,6 +144,13 @@ modify_list <- function (x, new_vals) {
   x
 }
 
+deparse_trunc <- function(x, width, collapse = ""\n"") {
+  x <- deparse1(x, collapse)
+  if (nchar(x)> width)
+    x <- sprintf(""%s...."", substr(x, 0, width-4))
+  x
+}
+
 
 # For older versions of R ----------------------------------------------------
 deparse1 <- function(expr, collapse = "" "", width.cutoff = 500L, ...) {

---FILE: tests/testthat/_snaps/generic-spec.md---
@@ -4,7 +4,10 @@
       as_generic(function() { })
     Condition
       Error:
-      ! `generic` is a function, but not an S3 generic function
+      ! `generic` is a function, but not an S3 generic function: 
+      function () 
+      {
+      }
 
 ---
 "
RConsortium,S7,c85d1c599c3d94cd456fb5c28a76554aa3675ccf,Tomasz Kalinowski,kalinowskit@gmail.com,2024-10-11T13:37:34Z,Tomasz Kalinowski,kalinowskit@gmail.com,2024-10-11T13:37:34Z,copyedit error message,R/property.R;R/valid.R,False,True,True,False,2,2,4,"---FILE: R/property.R---
@@ -318,7 +318,7 @@ prop_validate <- function(prop, value, object = NULL) {
   }
 
   stop(sprintf(
-    ""%s validator must return NULL or a character, not <%s>"",
+    ""%s validator must return NULL or a character, not <%s>."",
     prop_label(object, prop$name), typeof(val)
   ))
 }

---FILE: R/valid.R---
@@ -92,7 +92,7 @@ validate <- function(object, recursive = TRUE, properties = TRUE) {
       append(errors) <- error
     } else {
       stop(sprintf(
-        ""%s validator is expected to return NULL or a character, not <%s>"",
+        ""%s validator must return NULL or a character, not <%s>."",
         obj_desc(class), typeof(error)
       ))
     }"
RConsortium,S7,a6bb2762b9605ba2a8f8e2d6966be9814d9c02b6,Tomasz Kalinowski,tomasz@posit.co,2024-10-04T18:40:18Z,Tomasz Kalinowski,tomasz@posit.co,2024-10-04T18:44:32Z,fix external S3 method registration,DESCRIPTION;R/aaa.R;R/external-generic.R;R/method-register.R;tests/testthat/t2/R/t2.R;tests/testthat/test-external-generic.R,False,True,True,False,117,25,142,"---FILE: DESCRIPTION---
@@ -36,6 +36,7 @@ Suggests:
     methods,
     rmarkdown,
     testthat (>= 3.2.0),
+    callr,
     tibble
 VignetteBuilder: 
     knitr

---FILE: R/aaa.R---
@@ -7,3 +7,60 @@ new_function <- function(args = NULL,
                          env = asNamespace(""S7"")) {
   as.function.default(c(args, body) %||% list(NULL), env)
 }
+
+`append1<-` <- function (x, value) {
+  stopifnot(is.list(x) || identical(mode(x), mode(value)))
+  x[[length(x) + 1L]] <- value
+  x
+}
+
+
+dbg <- function(..., .display = utils::str) {
+  out <- NULL
+  exprs <- as.list(substitute(list(...)))[-1L]
+
+  for (i in seq_len(...length())) {
+    arg_i <- as.symbol(sprintf(""..%i"", i))
+    if (eval(substitute(missing(arg_i)))) next
+
+    name <- names(exprs)[[i]]
+    expr <- deparse1(exprs[[i]])
+
+    label <- if (is.null(name)) {
+      sprintf(""`%s`: "", expr)
+    } else {
+      sprintf(""(%s) `%s`: "", name, expr)
+    }
+    cat(label)
+    .display(out <- eval(arg_i))
+  }
+
+  cl <- sys.call()
+  filepath <- utils::getSrcFilename(cl)
+
+  if (length(filepath)) {
+    if (!file.exists(filepath) && file.exists(file.path(""R"", filepath))) {
+      filepath <- file.path(""R"", filepath)
+    }
+
+    lineno <- utils::getSrcLocation(cl)
+
+    if (isNamespaceLoaded(""cli"")) {
+      cli <- asNamespace(""cli"")
+      loc <- cli$col_grey(cli$style_hyperlink(
+        sprintf(""(from %s:%i)"", filepath, lineno),
+        sprintf(""file://%s"", normalizePath(filepath, mustWork = FALSE)),
+        params = c(line = lineno)
+      ))
+    } else {
+      loc <- sprintf(""(from %s:%i)"", filepath, lineno)
+    }
+
+    cat(loc, ""\n"")
+  } else {
+    cat(sprintf(""(from call: %s (srcfile missing))\n"",
+                trimws(deparse1(sys.call(-2), width.cutoff = 60))))
+  }
+
+  invisible(out)
+}

---FILE: R/external-generic.R---
@@ -88,10 +88,13 @@ is_external_generic <- function(x) {
 #' }
 methods_register <- function() {
   package <- packageName(parent.frame())
+  ns <- topenv(parent.frame())
+  # TODO?: check/enforce that methods_register() is being called from .onLoad()
+
   tbl <- S7_methods_table(package)
 
   for (x in tbl) {
-    register <- registrar(x$generic, x$signature, x$method, parent.frame())
+    register <- registrar(x$generic, x$signature, x$method, ns)
 
     if (isNamespaceLoaded(x$generic$package)) {
       register()
@@ -105,7 +108,7 @@ methods_register <- function() {
 
 registrar <- function(generic, signature, method, env) {
   # Force all arguments
-  list(generic, signature, method)
+  generic; signature; method; env;
 
   function(...) {
     ns <- asNamespace(generic$package)
@@ -129,12 +132,11 @@ external_methods_reset <- function(package) {
 external_methods_add <- function(package, generic, signature, method) {
   tbl <- S7_methods_table(package)
 
-  methods <- append(
-    tbl,
-    list(list(generic = generic, signature = signature, method = method))
-  )
+  append1(tbl) <- list(generic = generic,
+                       signature = signature,
+                       method = method)
 
-  S7_methods_table(package) <- methods
+  S7_methods_table(package) <- tbl
   invisible()
 }
 
@@ -144,7 +146,7 @@ external_methods_add <- function(package, generic, signature, method) {
 S7_methods_table <- function(package) {
   ns <- asNamespace(package)
   tbl <- ns[["".__S3MethodsTable__.""]]
-  attr(tbl, ""S7methods"")
+  attr(tbl, ""S7methods"") %||% list()
 }
 `S7_methods_table<-` <- function(package, value) {
   ns <- asNamespace(package)

---FILE: R/method-register.R---
@@ -67,16 +67,15 @@ register_method <- function(generic,
   generic <- as_generic(generic)
   signature <- as_signature(signature, generic)
 
+
+  if (is_external_generic(generic) && isNamespaceLoaded(generic$package)) {
+    generic <- as_generic(getFromNamespace(generic$name, generic$package))
+  }
+
   # Register in current session
   if (is_S7_generic(generic)) {
     check_method(method, generic, name = method_name(generic, signature))
     register_S7_method(generic, signature, method)
-  } else if (is_external_generic(generic)) {
-    # Only register immediately if soft dependency is available
-    if (requireNamespace(generic$package, quietly = TRUE)) {
-      gen <- getFromNamespace(generic$name, asNamespace(generic$package))
-      register_method(gen, signature, method, package = NULL)
-    }
   } else if (is_S3_generic(generic)) {
     register_S3_method(generic, signature, method, env)
   } else if (is_S4_generic(generic)) {
@@ -102,7 +101,13 @@ register_S3_method <- function(generic, signature, method, envir = parent.frame(
     )
     stop(msg, call. = FALSE)
   }
+
+  if (is_external_generic(external_generic <- get0(generic$name, envir = envir))) {
+    envir <- asNamespace(external_generic$package)
+  }
+
   class <- S7_class_name(signature[[1]])
+  # dbg(generic$name, class, method, envir)
   registerS3method(generic$name, class, method, envir)
 }
 

---FILE: tests/testthat/t2/R/t2.R---
@@ -15,7 +15,7 @@ S7::method(another_s7_generic, S7::class_character) <- function(x) ""foo""
 S7::method(another_s7_generic, an_s7_class) <- function(x) ""foo""
 
 another_s3_generic <- S7::new_external_generic(""t1"", ""another_s3_generic"", ""x"")
-# S7::method(another_s3_generic, an_s7_class) <- function(x) ""foo"" ## BROKEN
+S7::method(another_s3_generic, an_s7_class) <- function(x) ""foo""
 
 .onLoad <- function(libname, pkgname) {
   S7::methods_register()

---FILE: tests/testthat/test-external-generic.R---
@@ -59,32 +59,59 @@ test_that(""new_method works with both hard and soft dependencies"", {
   skip_if(getRversion() < ""4.1"" && Sys.info()[[""sysname""]] == ""Windows"")
   skip_if(quick_test())
 
-  tmp_lib <- tempfile()
-  dir.create(tmp_lib)
-  old_libpaths <- .libPaths()
-  .libPaths(c(tmp_lib, old_libpaths))
 
   on.exit({
     .libPaths(old_libpaths)
     try(detach(""package:t2"", unload = TRUE), silent = TRUE)
     try(detach(""package:t1"", unload = TRUE), silent = TRUE)
     try(detach(""package:t0"", unload = TRUE), silent = TRUE)
     unlink(tmp_lib, recursive = TRUE)
+    # remove.packages(c(""t1"", ""t0"", ""t2""))
   })
 
-  quick_install(test_path(c(""t0"", ""t1"")), tmp_lib)
+  tmp_lib <- tempfile()
+  dir.create(tmp_lib)
+  old_libpaths <- .libPaths()
+  .libPaths(c(tmp_lib, old_libpaths))
+
+  # t2 has a hard dependency on t0
+  # t2 has a soft dependency on t1
+
+  # First, ensure that t2 can install and run successfully without t1 installed
+  quick_install(test_path(""t0""), tmp_lib)
   quick_install(test_path(""t2""), tmp_lib)
 
   library(""t2"")
-
   library(""t0"")
-  # t2 has a hard dependency on t0
-  expect_equal(an_s3_generic(""x""), ""foo"")
+  expect_equal(an_s3_generic(t2::an_s7_class()), ""foo"")
   expect_equal(an_s7_generic(""x""), ""foo"")
 
+  # Now install the soft dependency
+  quick_install(test_path(""t1""), tmp_lib)
+
   library(""t1"")
-  # t2 has a soft dependency on t1
-  expect_equal(another_s3_generic(""x""), ""foo"")
+  expect_equal(another_s3_generic(t2::an_s7_class()), ""foo"")
   expect_equal(another_s7_generic(""x""), ""foo"")
 
+
+  ## Check again in a fresh session, with everything installed
+  expect_no_error(callr::r(function() {
+    library(t2)
+
+    stopifnot(exprs = {
+      t0::an_s3_generic(an_s7_class()) == ""foo""
+      t0::an_s7_generic(""x"") == ""foo""
+    })
+
+    if(isNamespaceLoaded(""t1""))
+      stop(""Prematurely loaded {t1}"")
+
+    stopifnot(exprs = {
+      t1::another_s3_generic(an_s7_class()) == ""foo""
+      t1::another_s7_generic(""x"") == ""foo""
+    })
+
+    NULL
+  }))
+
 })"
RConsortium,S7,e205bdaa8b5e1da760da6f752d4efa63eb36405f,Michael Lawrence,lawremi@gmail.com,2024-10-02T00:07:39Z,Michael Lawrence,lawremi@gmail.com,2024-10-02T00:09:05Z,fix check in `new_class()` when `abstract=TRUE` and `parent` is not an `S7_class`,R/class.R,False,True,True,False,1,1,2,"---FILE: R/class.R---
@@ -122,7 +122,7 @@ new_class <- function(
     if (!is.null(validator)) {
       check_function(validator, alist(self = ))
     }
-    if (abstract && !(parent@abstract || parent@name == ""S7_object"")) {
+    if (abstract && (!is_class(parent) || !(parent@abstract || parent@name == ""S7_object""))) {
       stop(""Abstract classes must have abstract parents"")
     }
   }"
RConsortium,S7,934703826c39c599e34dd0c89cf536505d23673d,Tomasz Kalinowski,tomasz@posit.co,2024-09-27T15:37:35Z,Tomasz Kalinowski,tomasz@posit.co,2024-09-27T15:37:35Z,Better error call from default constructor,R/constructor.R;tests/testthat/_snaps/constructor.md,False,True,True,False,21,5,26,"---FILE: R/constructor.R---
@@ -6,7 +6,12 @@ new_constructor <- function(parent, properties) {
   if (identical(parent, S7_object) || (is_class(parent) && parent@abstract)) {
     return(new_function(
       args = arg_info$self,
-      body = new_call(""new_object"", c(list(quote(S7_object())), self_args)),
+      body = as.call(c(quote(`{`),
+        # Force all promises here so that any errors are signaled from
+        # the constructor() call instead of the new_object() call.
+        unname(self_args),
+        new_call(""new_object"", c(list(quote(S7_object())), self_args))
+      )),
       env = asNamespace(""S7"")
     ))
   }

---FILE: tests/testthat/_snaps/constructor.md---
@@ -4,13 +4,19 @@
       new_constructor(S7_object, list())
     Output
       function () 
-      new_object(S7_object())
+      {
+          new_object(S7_object())
+      }
       <environment: namespace:S7>
     Code
       new_constructor(S7_object, as_properties(list(x = class_numeric, y = class_numeric)))
     Output
       function (x = integer(0), y = integer(0)) 
-      new_object(S7_object(), x = x, y = y)
+      {
+          x
+          y
+          new_object(S7_object(), x = x, y = y)
+      }
       <environment: namespace:S7>
     Code
       foo <- new_class(""foo"", parent = class_character)
@@ -51,13 +57,18 @@
       new_constructor(foo1, list())
     Output
       function () 
-      new_object(S7_object())
+      {
+          new_object(S7_object())
+      }
       <environment: namespace:S7>
     Code
       new_constructor(foo1, as_properties(list(y = class_double)))
     Output
       function (y = numeric(0)) 
-      new_object(S7_object(), y = y)
+      {
+          y
+          new_object(S7_object(), y = y)
+      }
       <environment: namespace:S7>
 
 # can use `...` in parent constructor"
RConsortium,S7,208fb4e83e12e090b27c415fb66752db067f7983,Tomasz Kalinowski,tomasz@posit.co,2024-09-08T19:21:55Z,Tomasz Kalinowski,tomasz@posit.co,2024-09-08T19:21:55Z,"fix `prop` name collision

`class@prop` could be called instead of `S7::prop`,
if `class@prop` is a function.",R/valid.R,False,True,True,False,4,4,8,"---FILE: R/valid.R---
@@ -103,14 +103,14 @@ validate <- function(object, recursive = TRUE, properties = TRUE) {
 validate_properties <- function(object, class) {
   errors <- character()
 
-  for (prop in class@properties) {
+  for (prop_obj in class@properties) {
     # Don't validate dynamic properties
-    if (!is.null(prop$getter)) {
+    if (!is.null(prop_obj$getter)) {
       next
     }
 
-    value <- prop(object, prop$name)
-    errors <- c(errors, prop_validate(prop, value))
+    value <- prop(object, prop_obj$name)
+    errors <- c(errors, prop_validate(prop_obj, value))
   }
 
   errors"
RConsortium,S7,e41ddcf2263922f316771447b07c4158ee031192,Tomasz Kalinowski,tomasz@posit.co,2024-02-16T17:01:57Z,Tomasz Kalinowski,tomasz@posit.co,2024-02-16T17:01:57Z,warning -> error,src/prop.c,False,False,False,False,1,1,2,"---FILE: src/prop.c---
@@ -189,7 +189,7 @@ SEXP pairlist_remove(SEXP list, SEXP elem) {
       }
     }
 
-  Rf_warning(""Tried to remove non-existent element from pairlist"");
+  Rf_error(""Tried to remove non-existent element from pairlist"");
   return R_NilValue;
 }
 "
RConsortium,S7,ffb8ca92abeb6a51f0a3ecad88d46ad29e18a7ae,Gustavo Velásquez,gvelasq2github@gmail.com,2024-01-09T17:23:03Z,GitHub,noreply@github.com,2024-01-09T17:23:03Z,Fix minor typo in NEWS.md (#397),NEWS.md,False,False,False,False,1,1,2,"---FILE: NEWS.md---
@@ -19,7 +19,7 @@
 
 * Can create multimethods that dispatch on `NULL`.
 
-* `prop()` optimiazed and rewritten in C (#395).
+* `prop()` optimized and rewritten in C (#395).
 
 # S7 0.1.1
 "
RConsortium,S7,b8f73b3f830c600441b73afdf19e8ef9c7302192,Tomasz Kalinowski,tomasz@posit.co,2023-12-19T15:51:27Z,Tomasz Kalinowski,tomasz@posit.co,2023-12-19T15:51:27Z,fix compiler warning better,src/prop.c,False,False,False,False,4,10,14,"---FILE: src/prop.c---
@@ -47,17 +47,11 @@ void signal_prop_error_unknown(SEXP object, SEXP name) {
 
 static __attribute__((noreturn))
 void signal_error(SEXP errmsg) {
-  /*  Given a STRSXP errmsg, we go back out to an R closure to signal the error.
-   *  We can't use Rf_error() because, from the compilers perspective, `errmsg`
-   *  isn't sanitized for '%'--it could be interpreted as a format string.
-   *  Compiler says:
-   *  warning: format not a string literal and no format arguments [-Wformat-security]
-
-   *  Doing something like this segfaults for reasons I don't understand:
-     Rf_eval(Rf_lang2(Rf_findVarInFrame(Rf_install(""stop""), R_BaseNamespace),
-                      errmsg), frame);
-   */
   PROTECT(errmsg);
+  if(TYPEOF(errmsg) == STRSXP && Rf_length(errmsg) == 1)
+    Rf_errorcall(R_NilValue, ""%s"", CHAR(STRING_ELT(errmsg, 0)));
+
+  // fallback to calling base::stop(errmsg)
   static SEXP signal_error = NULL;
   if (signal_error == NULL)
     signal_error = Rf_findVarInFrame(ns_S7, Rf_install(""signal_error""));"
RConsortium,S7,2cec150c6270ee7abbac0adb4ff6ae14b565f9e1,Hadley Wickham,h.wickham@gmail.com,2023-11-30T13:14:44Z,GitHub,noreply@github.com,2023-11-30T13:14:44Z,"Ensure Ops falls back to base behaviour (#382)

Fixes #320",NEWS.md;R/method-dispatch.R;R/method-ops.R;tests/testthat/test-method-dispatch.R;tests/testthat/test-method-ops.R,False,True,True,False,45,2,47,"---FILE: NEWS.md---
@@ -1,5 +1,12 @@
 # S7 (development version)
 
+* When a method is not found, the error now has class `S7_error_method_not_found`.
+
+* The `Ops` generic now falls back to base Ops behaviour when one of the 
+  arguments is not an S7 object (#320). This means that you get the somewhat 
+  inconsistent base behaviour, but means that S7 doesn't introduce a new axis 
+  of inconsistency. 
+
 * In `new_class()`, properties can either be named by naming the element
   of the list or by supplying the `name` argument to `new_property()` (#371).
 

---FILE: R/method-dispatch.R---
@@ -2,7 +2,8 @@
 method_lookup_error <- function(name, args) {
   types <- vcapply(args, obj_desc)
   msg <- method_lookup_error_message(name, types)
-  stop(msg, call. = FALSE)
+  cnd <- errorCondition(msg, class = c(""S7_error_method_not_found"", ""error""))
+  stop(cnd)
 }
 
 method_lookup_error_message <- function(name, types) {

---FILE: R/method-ops.R---
@@ -16,7 +16,18 @@ on_load_define_ops <- function() {
 
 #' @export
 Ops.S7_object <- function(e1, e2) {
-  base_ops[[.Generic]](e1, e2)
+  cnd <- tryCatch(
+    return(base_ops[[.Generic]](e1, e2)),
+    S7_error_method_not_found = function(cnd) cnd
+  )
+
+  if (S7_inherits(e1) && S7_inherits(e2)) {
+    stop(cnd)
+  } else {
+    # Must call NextMethod() directly in the method, not wrapped in an
+    # anonymous function.
+    NextMethod()
+  }
 }
 
 #' @rawNamespace if (getRversion() >= ""4.3.0"") S3method(chooseOpsMethod, S7_object)

---FILE: tests/testthat/test-method-dispatch.R---
@@ -143,6 +143,8 @@ test_that(""single dispatch fails with informative messages"", {
     fail(foo())
     fail(Foo(x = 1))
   })
+
+  expect_error(fail(TRUE), class = ""S7_error_method_not_found"")
 })
 
 test_that(""multiple dispatch fails with informative messages"", {
@@ -157,6 +159,8 @@ test_that(""multiple dispatch fails with informative messages"", {
     fail(, TRUE)
     fail(TRUE, TRUE)
   })
+
+  expect_error(fail(TRUE, TRUE), class = ""S7_error_method_not_found"")
 })
 
 

---FILE: tests/testthat/test-method-ops.R---
@@ -12,6 +12,8 @@ test_that(""Ops generics dispatch to S7 methods for S7 classes"", {
   expect_equal(foo1() + foo2(), ""foo1-foo2"")
   expect_equal(foo2() + foo1(), ""foo2-foo1"")
   expect_equal(foo2() + foo2(), ""foo2-foo2"")
+
+  expect_error(foo1() + new_class(""foo3"")(), class = ""S7_error_method_not_found"")
 })
 
 test_that(""Ops generics dispatch to S3 methods"", {
@@ -76,6 +78,24 @@ test_that(""Ops generics dispatch to S7 methods for NULL"", {
   expect_equal(NULL + foo(), ""NULL-foo"")
 })
 
+test_that(""Ops generics falls back to base behaviour"", {
+  local_methods(base_ops[[""+""]])
+
+  foo <- new_class(""foo"", parent = class_double)
+  expect_equal(foo(1) + 1, foo(2))
+  expect_equal(foo(1) + 1:2, 2:3)
+  expect_equal(1 + foo(1), foo(2))
+  expect_equal(1:2 + foo(1), 2:3)
+
+  # but can be overridden
+  method(`+`, list(foo, class_numeric)) <- function(e1, e2) ""foo-numeric""
+  method(`+`, list(class_numeric, foo)) <- function(e1, e2) ""numeric-foo""
+  expect_equal(foo(1) + 1, ""foo-numeric"")
+  expect_equal(foo(1) + 1:2, ""foo-numeric"")
+  expect_equal(1 + foo(1), ""numeric-foo"")
+  expect_equal(1:2 + foo(1), ""numeric-foo"")
+})
+
 test_that(""`%*%` dispatches to S7 methods"", {
   skip_if(getRversion() < ""4.3"")
   local_methods(base_ops[[""+""]])"
RConsortium,S7,42536b66ae5f6deb9ea25f7815a4773eb591dc31,Hadley Wickham,h.wickham@gmail.com,2023-11-29T22:47:51Z,GitHub,noreply@github.com,2023-11-29T22:47:51Z,"Take list name from property name (#379)

Fixes #371",NEWS.md;R/property.R;man/new_property.Rd;tests/testthat/_snaps/property.md;tests/testthat/test-property.R,False,True,True,False,37,14,51,"---FILE: NEWS.md---
@@ -1,5 +1,8 @@
 # S7 (development version)
 
+* In `new_class()`, properties can either be named by naming the element
+  of the list or by supplying the `name` argument to `new_property()` (#371).
+
 * `super()` now works with Ops methods (#357).
 
 * `method()` now generates an informative message when dispatch fails (#387).

---FILE: R/property.R---
@@ -33,9 +33,10 @@
 #' @param default When an object is created and the property is not supplied,
 #'   what should it default to? If `NULL`, defaults to the ""empty"" instance
 #'   of `class`.
-#' @param name Property name, primarily used for error messages. Used
-#'   primrarily for testing as it is set automatically when using a list of
-#'   properties.
+#' @param name Property name, primarily used for error messages. Generally
+#'   don't need to set this here, as it's more convenient to supply as a
+#'   the element name when defining a list of properties. If both `name`
+#'   and a list-name are supplied, the list-name will be used.
 #' @returns An S7 property, i.e. a list with class `S7_property`.
 #' @export
 #' @examples
@@ -393,7 +394,7 @@ as_properties <- function(x) {
   }
 
   out <- Map(as_property, x, names2(x), seq_along(x))
-  names(out) <- names2(x)
+  names(out) <- vapply(out, function(x) x$name, FUN.VALUE = character(1))
 
   if (anyDuplicated(names(out))) {
     stop(""`properties` names must be unique"", call. = FALSE)
@@ -403,15 +404,23 @@ as_properties <- function(x) {
 }
 
 as_property <- function(x, name, i) {
-  if (name == """") {
-    msg <- sprintf(""`property[[%i]]` is missing a name"", i)
-    stop(msg, call. = FALSE)
-  }
 
   if (is_property(x)) {
-    x$name <- name
+    if (name == """") {
+      if (is.null(x$name)) {
+        msg <- sprintf(""`properties[[%i]]` must have a name or be named."", i)
+        stop(msg, call. = FALSE)
+      }
+    } else {
+      x$name <- name
+    }
     x
   } else {
+    if (name == """") {
+      msg <- sprintf(""`properties[[%i]]` must be named."", i)
+      stop(msg, call. = FALSE)
+    }
+
     class <- as_class(x, arg = paste0(""property$"", name))
     new_property(x, name = name)
   }

---FILE: man/new_property.Rd---
@@ -43,9 +43,10 @@ your code can assume that \code{value} has known type.}
 what should it default to? If \code{NULL}, defaults to the ""empty"" instance
 of \code{class}.}
 
-\item{name}{Property name, primarily used for error messages. Used
-primrarily for testing as it is set automatically when using a list of
-properties.}
+\item{name}{Property name, primarily used for error messages. Generally
+don't need to set this here, as it's more convenient to supply as a
+the element name when defining a list of properties. If both \code{name}
+and a list-name are supplied, the list-name will be used.}
 }
 \value{
 An S7 property, i.e. a list with class \code{S7_property}.

---FILE: tests/testthat/_snaps/property.md---
@@ -160,12 +160,12 @@
       as_properties(list(1))
     Condition
       Error:
-      ! `property[[1]]` is missing a name
+      ! `properties[[1]]` must be named.
     Code
       as_properties(list(new_property(class_character)))
     Condition
       Error:
-      ! `property[[1]]` is missing a name
+      ! `properties[[1]]` must have a name or be named.
     Code
       as_properties(list(x = 1))
     Condition

---FILE: tests/testthat/test-property.R---
@@ -287,6 +287,16 @@ test_that(""as_properties normalises properties"", {
     as_properties(list(x = new_property(class = class_numeric))),
     list(x = new_property(class_numeric, name = ""x"")
   ))
+  expect_equal(
+    as_properties(list(new_property(name = ""y""))),
+    list(y = new_property(name = ""y"")
+  ))
+
+  # list name wins
+  expect_equal(
+    as_properties(list(x = new_property(name = ""y""))),
+    list(x = new_property(name = ""x"")
+  ))
 })
 
 test_that(""as_properties() gives useful error messages"", {"
RConsortium,S7,e9ebe6f232f0115bab4e75a54a168ef8d382a2af,Hadley Wickham,h.wickham@gmail.com,2023-11-29T22:47:11Z,GitHub,noreply@github.com,2023-11-29T22:47:11Z,"Add missing S7_super method for Ops (#359)

Fixes #357",NAMESPACE;NEWS.md;R/method-ops.R;tests/testthat/test-method-ops.R,False,True,True,False,27,0,27,"---FILE: NAMESPACE---
@@ -9,6 +9,7 @@ S3method(""[["",S7_object)
 S3method(""[[<-"",S7_object)
 S3method(""|"",S7_class)
 S3method(Ops,S7_object)
+S3method(Ops,S7_super)
 S3method(c,S7_class)
 S3method(print,S7_S3_class)
 S3method(print,S7_any)
@@ -86,7 +87,9 @@ if (getRversion() < ""4.3.0"") export(`@`)
 if (getRversion() >= ""4.3.0"" && !is.null(asNamespace(""utils"")$.AtNames)) S3method(utils::.AtNames,S7_object)
 if (getRversion() >= ""4.3.0"") S3method(base::`@`, S7_object)
 if (getRversion() >= ""4.3.0"") S3method(chooseOpsMethod, S7_object)
+if (getRversion() >= ""4.3.0"") S3method(chooseOpsMethod, S7_super)
 if (getRversion() >= ""4.3.0"") S3method(matrixOps, S7_object)
+if (getRversion() >= ""4.3.0"") S3method(matrixOps, S7_super)
 if (getRversion() >= ""4.3.0"") S3method(nameOfClass, S7_class, S7_class_name)
 importFrom(stats,setNames)
 importFrom(utils,getFromNamespace)

---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # S7 (development version)
 
+* `super()` now works with Ops methods (#357).
+
 * `method()` now generates an informative message when dispatch fails (#387).
 
 * S7 provides a new automatic backward compatibility mechanism to provide

---FILE: R/method-ops.R---
@@ -26,3 +26,12 @@ chooseOpsMethod.S7_object <- function(x, y, mx, my, cl, reverse) TRUE
 matrixOps.S7_object <- function(x, y) {
   base_matrix_ops[[.Generic]](x, y)
 }
+
+#' @export
+Ops.S7_super <- Ops.S7_object
+
+#' @rawNamespace if (getRversion() >= ""4.3.0"") S3method(chooseOpsMethod, S7_super)
+chooseOpsMethod.S7_super <- chooseOpsMethod.S7_object
+
+#' @rawNamespace if (getRversion() >= ""4.3.0"") S3method(matrixOps, S7_super)
+matrixOps.S7_super <- matrixOps.S7_object

---FILE: tests/testthat/test-method-ops.R---
@@ -89,3 +89,16 @@ test_that(""`%*%` dispatches to S7 methods"", {
   expect_equal(1 %*% ClassX(), ""class_any %*% ClassX"")
 })
 
+test_that(""Ops methods can use super"", {
+  foo <- new_class(""foo"", class_integer)
+  foo2 <- new_class(""foo2"", foo)
+
+  method(`+`, list(foo, class_double)) <- function(e1, e2) {
+    foo(S7_data(e1) + as.integer(e2))
+  }
+  method(`+`, list(foo2, class_double)) <- function(e1, e2) {
+    foo2(super(e1, foo) + e2)
+  }
+
+  expect_equal(foo2(1L) + 1, foo2(2L))
+})"
RConsortium,S7,687c173fb6f5d3cd42f626f954f8caf9d29b4eac,Hadley Wickham,h.wickham@gmail.com,2023-11-29T18:15:52Z,GitHub,noreply@github.com,2023-11-29T18:15:52Z,"Document super() alternatives for S3 methods (#381)

Fixes #366",R/super.R;man/super.Rd,False,True,True,False,70,0,70,"---FILE: R/super.R---
@@ -20,6 +20,41 @@
 #' This makes `super()` more verbose, but substantially easier to
 #' understand and reason about.
 #'
+#' ## `super()` in S3 generics
+#'
+#' Note that you can't use `super()` in methods for an S3 generic.
+#' For example, imagine that you have made a subclass of ""integer"":
+#'
+#' ```{r}
+#' myint <- new_class(""myint"", parent = class_integer)
+#' ```
+#'
+#' Now you go to write a custom print method:
+#'
+#' ```{r}
+#' method(print, myint) <- function(x, ...) {
+#'    cat(""<myint>"")
+#'    print(super(x, to = class_integer))
+#' }
+#'
+#' myint(10L)
+#' ```
+#'
+#' This doesn't work because `print()` isn't an S7 generic so doesn't
+#' understand how to interpret the special object that `super()` produces.
+#' While you could resolve this problem with [NextMethod()] (because S7 is
+#' implemented on top of S3), we instead recommend using [S7_data()] to extract
+#' the underlying base object:
+#'
+#' ```{r}
+#' method(print, myint) <- function(x, ...) {
+#'    cat(""<myint>"")
+#'    print(S7_data(x))
+#' }
+#'
+#' myint(10L)
+#' ```
+#'
 #' @param from An S7 object to cast.
 #' @param to An S7 class specification, passed to [as_class()]. Must be a
 #'   superclass of `object`.

---FILE: man/super.Rd---
@@ -36,6 +36,41 @@ passed along.
 This makes \code{super()} more verbose, but substantially easier to
 understand and reason about.
 }
+
+\subsection{\code{super()} in S3 generics}{
+
+Note that you can't use \code{super()} in methods for an S3 generic.
+For example, imagine that you have made a subclass of ""integer"":
+
+\if{html}{\out{<div class=""sourceCode r"">}}\preformatted{myint <- new_class(""myint"", parent = class_integer)
+}\if{html}{\out{</div>}}
+
+Now you go to write a custom print method:
+
+\if{html}{\out{<div class=""sourceCode r"">}}\preformatted{method(print, myint) <- function(x, ...) \{
+   cat(""<myint>"")
+   print(super(x, to = class_integer))
+\}
+
+myint(10L)
+#> <myint>super(<myint>, <integer>)
+}\if{html}{\out{</div>}}
+
+This doesn't work because \code{print()} isn't an S7 generic so doesn't
+understand how to interpret the special object that \code{super()} produces.
+While you could resolve this problem with \code{\link[=NextMethod]{NextMethod()}} (because S7 is
+implemented on top of S3), we instead recommend using \code{\link[=S7_data]{S7_data()}} to extract
+the underlying base object:
+
+\if{html}{\out{<div class=""sourceCode r"">}}\preformatted{method(print, myint) <- function(x, ...) \{
+   cat(""<myint>"")
+   print(S7_data(x))
+\}
+
+myint(10L)
+#> <myint>[1] 10
+}\if{html}{\out{</div>}}
+}
 }
 \examples{
 foo1 <- new_class(""foo1"", properties = list(x = class_numeric, y = class_numeric))"
RConsortium,S7,8c0f9be1d984fab409876591cfa9842b7b739197,Hadley Wickham,h.wickham@gmail.com,2023-11-27T19:47:11Z,GitHub,noreply@github.com,2023-11-27T19:47:11Z,"Generate correct error when introspection fails (#391)

Fixes #387",NEWS.md;R/method-dispatch.R;R/method-introspect.R;man/method.Rd;src/method-dispatch.c;tests/testthat/_snaps/method-introspect.md;tests/testthat/test-method-introspect.R,False,True,True,False,84,31,115,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # S7 (development version)
 
+* `method()` now generates an informative message when dispatch fails (#387).
+
 * S7 provides a new automatic backward compatibility mechanism to provide
   a version of `@` that works in R before version 4.3 (#326).
 

---FILE: R/method-dispatch.R---
@@ -1,17 +1,18 @@
 # Called from C
-method_lookup_error <- function(name, args, signatures) {
-  sigs <- vcapply(signatures, paste, collapse = "", "")
+method_lookup_error <- function(name, args) {
   types <- vcapply(args, obj_desc)
+  msg <- method_lookup_error_message(name, types)
+  stop(msg, call. = FALSE)
+}
 
-  if (length(args) == 1) {
-    msg <- sprintf(""Can't find method for `%s(%s)`."", name, types)
+method_lookup_error_message <- function(name, types) {
+  if (length(types) == 1) {
+    sprintf(""Can't find method for `%s(%s)`."", name, types)
   } else {
-    arg_names <- paste0(names(args), collapse = "", "")
-    types <- paste0(""- "", format(names(args)), "": "", types, collapse = ""\n"")
-    msg <- sprintf(""Can't find method for generic `%s(%s)`:\n%s"", name, arg_names, types)
+    arg_names <- paste0(names(types), collapse = "", "")
+    types <- paste0(""- "", format(names(types)), "": "", types, collapse = ""\n"")
+    sprintf(""Can't find method for generic `%s(%s)`:\n%s"", name, arg_names, types)
   }
-
-  stop(msg, call. = FALSE)
 }
 
 #' @rdname new_generic

---FILE: R/method-introspect.R---
@@ -19,7 +19,7 @@
 #' # Create a generic and register some methods
 #' bizarro <- new_generic(""bizarro"", ""x"")
 #' method(bizarro, class_numeric) <- function(x) rev(x)
-#' method(bizarro, new_S3_class(""factor"")) <- function(x) {
+#' method(bizarro, class_factor) <- function(x) {
 #'   levels(x) <- rev(levels(x))
 #'   x
 #' }
@@ -30,11 +30,25 @@
 #' # And you can use method() to inspect specific implementations
 #' method(bizarro, class = class_integer)
 #' method(bizarro, object = 1)
-#' method(bizarro, new_S3_class(""factor""))
+#' method(bizarro, class = class_factor)
+#'
+#' # errors if method not found
+#' try(method(bizarro, class = class_data.frame))
+#' try(method(bizarro, object = ""x""))
 method <- function(generic, class = NULL, object = NULL) {
-  generic <- as_generic(generic)
+  check_is_S7(generic, S7_generic)
   dispatch <- as_dispatch(generic, class = class, object = object)
-  .Call(method_, generic, dispatch, environment(), TRUE)
+
+  method <- .Call(method_, generic, dispatch, environment(), FALSE)
+  if (!is.null(method)) {
+    return(method)
+  }
+
+  # can't rely on usual error mechanism because it involves looking up
+  # argument values in the dispatch environment, which doesn't exist here
+  types <- error_types(generic, class = class, object = object)
+  msg <- method_lookup_error_message(generic@name, types)
+  stop(msg, call. = FALSE)
 }
 
 #' Explain method dispatch
@@ -64,7 +78,7 @@ method <- function(generic, class = NULL, object = NULL) {
 #'
 #' method_explain(add, list(foo2, foo2))
 method_explain <- function(generic, class = NULL, object = NULL) {
-  generic <- as_generic(generic)
+  check_is_S7(generic, S7_generic)
   dispatch <- as_dispatch(generic, class = class, object = object)
   dispatch <- lapply(dispatch, c, ""ANY"")
 
@@ -94,8 +108,6 @@ method_explain <- function(generic, class = NULL, object = NULL) {
 
 
 as_dispatch <- function(generic, class = NULL, object = NULL) {
-  check_is_S7(generic, S7_generic)
-
   if (!is.null(class) && is.null(object)) {
     signature <- as_signature(class, generic)
     is_union <- vlapply(signature, is_union)
@@ -116,3 +128,19 @@ as_dispatch <- function(generic, class = NULL, object = NULL) {
     stop(""Must supply exactly one of `class` and `object`"", call. = FALSE)
   }
 }
+
+error_types <- function(generic, class = NULL, object = NULL) {
+  if (is.null(class)) {
+    n <- generic_n_dispatch(generic)
+    if (n == 1) {
+      types <- list(obj_desc(object))
+    } else {
+      types <- vcapply(object, obj_desc)
+    }
+  } else {
+    signature <- as_signature(class, generic)
+    types <- vcapply(signature, class_desc)
+  }
+  names(types) <- generic@dispatch_args
+  types
+}

---FILE: man/method.Rd---
@@ -31,7 +31,7 @@ the implementation of a specific method.
 # Create a generic and register some methods
 bizarro <- new_generic(""bizarro"", ""x"")
 method(bizarro, class_numeric) <- function(x) rev(x)
-method(bizarro, new_S3_class(""factor"")) <- function(x) {
+method(bizarro, class_factor) <- function(x) {
   levels(x) <- rev(levels(x))
   x
 }
@@ -42,7 +42,11 @@ bizarro
 # And you can use method() to inspect specific implementations
 method(bizarro, class = class_integer)
 method(bizarro, object = 1)
-method(bizarro, new_S3_class(""factor""))
+method(bizarro, class = class_factor)
+
+# errors if method not found
+try(method(bizarro, class = class_data.frame))
+try(method(bizarro, object = ""x""))
 }
 \seealso{
 \code{\link[=method_explain]{method_explain()}} to explain why a specific method was picked.

---FILE: src/method-dispatch.c---
@@ -67,7 +67,7 @@ SEXP generic_args(SEXP generic, SEXP envir) {
 }
 
 __attribute__ ((noreturn))
-void S7_method_lookup_error(SEXP generic, SEXP signature, SEXP envir) {
+void S7_method_lookup_error(SEXP generic, SEXP envir) {
   SEXP ns = Rf_findVarInFrame(R_NamespaceRegistry, Rf_install(""S7""));
   static SEXP S7_method_lookup_error_fun = NULL;
   if (S7_method_lookup_error_fun == NULL) {
@@ -77,7 +77,7 @@ void S7_method_lookup_error(SEXP generic, SEXP signature, SEXP envir) {
   SEXP name = Rf_getAttrib(generic, R_NameSymbol);
   SEXP args = generic_args(generic, envir);
 
-  SEXP S7_method_lookup_error_call = PROTECT(Rf_lang4(S7_method_lookup_error_fun, name, args, signature));
+  SEXP S7_method_lookup_error_call = PROTECT(Rf_lang3(S7_method_lookup_error_fun, name, args));
   Rf_eval(S7_method_lookup_error_call, ns);
 
   while(1);
@@ -97,7 +97,7 @@ SEXP method_(SEXP generic, SEXP signature, SEXP envir, SEXP error_) {
 
   int error = Rf_asInteger(error_);
   if (error && m == R_NilValue) {
-    S7_method_lookup_error(generic, signature, envir);
+    S7_method_lookup_error(generic, envir);
   }
 
   return m;

---FILE: tests/testthat/_snaps/method-introspect.md---
@@ -4,7 +4,7 @@
       method(print, 1)
     Condition
       Error:
-      ! `generic` must be a <S7_generic>, not a S3<S7_S3_generic>
+      ! `generic` must be a <S7_generic>, not a <closure>
     Code
       foo <- new_generic(""foo"", ""x"")
       method(foo)
@@ -28,18 +28,32 @@
       Error:
       ! `object` must be length 2
 
-# errors if no method found
+# method introspection: errors if no method found
 
     Code
-      method(foo, list())
+      method(foo, class = class_integer)
     Condition
       Error:
-      ! Can't convert `signature` to a valid class. Class specification must be an S7 class object, the result of `new_S3_class()`, an S4 class object, or a base class, not a <list>.
+      ! Can't find method for `foo(<integer>)`.
     Code
-      method(foo, list(""blah""))
+      method(foo, object = 1L)
     Condition
       Error:
-      ! Can't convert `signature` to a valid class. Class specification must be an S7 class object, the result of `new_S3_class()`, an S4 class object, or a base class, not a <list>.
+      ! Can't find method for `foo(<integer>)`.
+    Code
+      method(foo2, class = list(class_integer, class_double))
+    Condition
+      Error:
+      ! Can't find method for generic `foo(x, y)`:
+      - x: <integer>
+      - y: <double>
+    Code
+      method(foo2, object = list(1L, 2))
+    Condition
+      Error:
+      ! Can't find method for generic `foo(x, y)`:
+      - x: <integer>
+      - y: <double>
 
 # method explanation: shows all possible methods along with matches
 

---FILE: tests/testthat/test-method-introspect.R---
@@ -1,5 +1,5 @@
 describe(""method introspection"", {
-  test_that(""can dispatch by class or object"", {
+  it(""can dispatch by class or object"", {
     foo <- new_generic(""foo"", ""x"")
     method(foo, class_character) <- function(x) ""c""
 
@@ -23,12 +23,16 @@ describe(""method introspection"", {
     })
   })
 
-  test_that(""errors if no method found"", {
+  it(""errors if no method found"", {
     foo <- new_generic(""foo"", ""x"")
+    foo2 <- new_generic(""foo"", c(""x"", ""y""))
 
     expect_snapshot(error = TRUE, {
-      method(foo, list())
-      method(foo, list(""blah""))
+      method(foo, class = class_integer)
+      method(foo, object = 1L)
+
+      method(foo2, class = list(class_integer, class_double))
+      method(foo2, object = list(1L, 2))
     })
   })
 })"
RConsortium,S7,d0112a1d04f6efc64bd9dc4e88e9100d68927b85,Hadley Wickham,h.wickham@gmail.com,2023-11-23T15:44:59Z,GitHub,noreply@github.com,2023-11-23T15:44:59Z,"Upkeep (#384)

* Fix vignette titles

* Enable parallel testing

* Simplify matrixOps definition",DESCRIPTION;NAMESPACE;R/S7-package.R;R/method-ops.R;vignettes/classes-objects.Rmd;vignettes/generics-methods.Rmd;vignettes/motivation.Rmd;vignettes/packages.Rmd,True,True,True,False,19,22,41,"---FILE: DESCRIPTION---
@@ -42,6 +42,8 @@ VignetteBuilder:
     knitr
 Config/Needs/website: sloop
 Config/testthat/edition: 3
+Config/testthat/parallel: TRUE
+Config/testthat/start-first: external-generic
 Encoding: UTF-8
 Roxygen: list(markdown = TRUE)
 RoxygenNote: 7.2.3

---FILE: NAMESPACE---
@@ -90,6 +90,7 @@ if (getRversion() >= ""4.3.0"") S3method(matrixOps, S7_object)
 if (getRversion() >= ""4.3.0"") S3method(nameOfClass, S7_class, S7_class_name)
 importFrom(stats,setNames)
 importFrom(utils,getFromNamespace)
+importFrom(utils,globalVariables)
 importFrom(utils,hasName)
 importFrom(utils,head)
 importFrom(utils,packageName)

---FILE: R/S7-package.R---
@@ -1,5 +1,6 @@
 ## usethis namespace: start
-#' @useDynLib S7, .registration = TRUE
+#' @importFrom utils globalVariables
 #' @importFrom utils head str hasName
+#' @useDynLib S7, .registration = TRUE
 ## usethis namespace: end
 NULL

---FILE: R/method-ops.R---
@@ -23,16 +23,16 @@ Ops.S7_object <- function(e1, e2) {
 chooseOpsMethod.S7_object <- function(x, y, mx, my, cl, reverse) TRUE
 
 #' @rawNamespace if (getRversion() >= ""4.3.0"") S3method(matrixOps, S7_object)
-matrixOps.S7_object <- NULL
+matrixOps.S7_object <- function(x, y) {
+  base_matrix_ops[[.Generic]](x, y)
+}
+
 
 on_load_define_matrixOps <- function() {
-  if (getRversion() >= ""4.4.0"") {
-    matrixOps.S7_object <<- function(x, y) {
-      base_matrix_ops[[.Generic]](x, y)
-    }
-  } else {
-    matrixOps.S7_object <<- function(e1, e2) {
-      base_matrix_ops[[.Generic]](e1, e2)
-    }
-  }
+  # if (getRversion() >= ""4.3.0"") {
+  # } else {
+  #   matrixOps.S7_object <<- function(e1, e2) {
+  #     base_matrix_ops[[.Generic]](e1, e2)
+  #   }
+  # }
 }

---FILE: vignettes/classes-objects.Rmd---
@@ -283,4 +283,3 @@ The first argument to `new_object()` should be an object of the `parent` class (
 That argument should be followed by one named argument for each property.
 
 There's one drawback of custom constructors that you should be aware of: any subclass will also require a custom constructor.
-

---FILE: vignettes/generics-methods.Rmd---
@@ -2,7 +2,7 @@
 title: ""Generics and methods""
 output: rmarkdown::html_vignette
 vignette: >
-  %\VignetteIndexEntry{S7 generics and method dispatch}
+  %\VignetteIndexEntry{Generics and methods}
   %\VignetteEngine{knitr::rmarkdown}
   %\VignetteEncoding{UTF-8}
 ---

---FILE: vignettes/motivation.Rmd---
@@ -63,12 +63,6 @@ library(S7)
     This made it possible to make radical changes but it made it harder to switch from S3 to S4, leading to a general lack of adoption in the R community.
     S7 is designed to be drop-in compatible with S3, making it possible to convert existing packages to use S7 instead of S3 with only an hour or two of work.
 
-```{=html}
 <!-- -->
-```
--   At least within Bioconductor, slots are generally thought of as implementation detail that should not be directly accessed by the end-user.
-    This leads to two problems.
-    Firstly, implementing an S4 Bioconductor class often also requires a plethora of accessor functions that are a thin wrapper around `@` or `@<-`.
-    Secondly, users know about `@` and use it to access object internals even though they're not supposed to.
-    S7 avoids these problems by accepting the fact that R is a data language, and that there's no way to stop users from pulling the data they need out of an object.
-    To make it possible to change the internal implementation details of an object while preserving existing `@` usage, S7 provides dynamic properties.
+
+-   At least within Bioconductor, slots are generally thought of as implementation detail that should not be directly accessed by the end-user. This leads to two problems. Firstly, implementing an S4 Bioconductor class often also requires a plethora of accessor functions that are a thin wrapper around `@` or `@<-`. Secondly, users know about `@` and use it to access object internals even though they're not supposed to. S7 avoids these problems by accepting the fact that R is a data language, and that there's no way to stop users from pulling the data they need out of an object. To make it possible to change the internal implementation details of an object while preserving existing `@` usage, S7 provides dynamic properties.

---FILE: vignettes/packages.Rmd---
@@ -2,7 +2,7 @@
 title: ""Using S7 in a package""
 output: rmarkdown::html_vignette
 vignette: >
-  %\VignetteIndexEntry{packages}
+  %\VignetteIndexEntry{Using S7 in a package}
   %\VignetteEngine{knitr::rmarkdown}
   %\VignetteEncoding{UTF-8}
 ---"
RConsortium,S7,3d6c6d7525623d6e59d57d7c0aef53712d403779,Hadley Wickham,h.wickham@gmail.com,2023-10-17T21:40:36Z,GitHub,noreply@github.com,2023-10-17T21:40:36Z,"Alternative backward compatibility approach for user code (#349)

Fixes #326",NAMESPACE;NEWS.md;R/compatibility.R;R/property.R;R/zzz.R;man/prop.Rd;vignettes/packages.Rmd,True,True,True,False,36,29,65,"---FILE: NAMESPACE---
@@ -82,8 +82,9 @@ export(super)
 export(valid_eventually)
 export(valid_implicitly)
 export(validate)
+if (getRversion() < ""4.3.0"") export(`@`)
 if (getRversion() >= ""4.3.0"" && !is.null(asNamespace(""utils"")$.AtNames)) S3method(utils::.AtNames,S7_object)
-if (getRversion() >= ""4.3.0"") S3method(base::`@`, S7_object) else export(""@"")
+if (getRversion() >= ""4.3.0"") S3method(base::`@`, S7_object)
 if (getRversion() >= ""4.3.0"") S3method(chooseOpsMethod, S7_object)
 if (getRversion() >= ""4.3.0"") S3method(matrixOps, S7_object)
 if (getRversion() >= ""4.3.0"") S3method(nameOfClass, S7_class, S7_class_name)

---FILE: NEWS.md---
@@ -1,5 +1,8 @@
 # S7 (development version)
 
+* S7 provides a new automatic backward compatibility mechanism to provide
+  a version of `@` that works in R before version 4.3 (#326).
+
 * Can create multimethods that dispatch on `NULL`.
 
 # S7 0.1.1

---FILE: R/compatibility.R---
@@ -0,0 +1,22 @@
+# Where needed, attach an environment containing @ that works with S7
+activate_backward_compatiblility <- function() {
+  if (getRversion() < ""4.3.0"" && !""S7_at"" %in% search()) {
+    args <- list(list(""@"" = `@`), name = ""S7_at"", warn.conflicts = FALSE)
+    do.call(""attach"", args)
+  }
+  invisible()
+}
+
+#' @aliases @
+#' @usage NULL
+#' @rawNamespace if (getRversion() < ""4.3.0"") export(`@`)
+#' @name prop
+`@` <- function(object, name) {
+  if (inherits(object, ""S7_object"")) {
+    name <- as.character(substitute(name))
+    prop(object, name)
+  } else {
+    name <- substitute(name)
+    do.call(base::`@`, list(object, name))
+  }
+}

---FILE: R/property.R---
@@ -260,28 +260,16 @@ prop_label <- function(object, name) {
   sprintf(""%s@%s"", if (!is.null(object)) obj_desc(object) else """", name)
 }
 
-#' @rdname prop
-#' @usage object@name
-#' @aliases @
-#' @rawNamespace if (getRversion() >= ""4.3.0"") S3method(base::`@`, S7_object) else export(""@"")
-`@.S7_object` <- prop
-
 # Note: we need to explicitly refer to base with ""base::`@`"" in the
 # namespace directive to ensure the method is registered in the correct place.
 # Otherwise, loadNamespace()/registerS3method() gets confused by the
 # presence of a closure w/ the name of the generic (`@`) in the R7 namespace,
 # and incorrectly assumes that R7::`@` is the generic and registers the
 # method in the package namespace instead of base::.__S3MethodsTable__.
-
-`@` <- function(object, name) {
-  if (inherits(object, ""S7_object"")) {
-    name <- as.character(substitute(name))
-    prop(object, name)
-  } else {
-    name <- substitute(name)
-    do.call(base::`@`, list(object, name))
-  }
-}
+#' @usage object@name
+#' @rawNamespace if (getRversion() >= ""4.3.0"") S3method(base::`@`, S7_object)
+#' @name prop
+`@.S7_object` <- prop
 
 #' @rawNamespace S3method(""@<-"",S7_object)
 `@<-.S7_object` <- function(object, name, value) {

---FILE: R/zzz.R---
@@ -119,6 +119,8 @@ methods::setOldClass(c(""S7_method"", ""function"", ""S7_object""))
 }
 
 .onLoad <- function(...) {
+  activate_backward_compatiblility()
+
   on_load_make_convert_generic()
   on_load_define_matrixOps()
   on_load_define_ops()

---FILE: man/prop.Rd---
@@ -1,10 +1,10 @@
 % Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/property.R
+% Please edit documentation in R/compatibility.R, R/property.R
 \name{prop}
 \alias{prop}
+\alias{@}
 \alias{prop<-}
 \alias{@.S7_object}
-\alias{@}
 \title{Get/set a property}
 \usage{
 prop(object, name)

---FILE: vignettes/packages.Rmd---
@@ -65,13 +65,4 @@ Otherwise, you can conditionally make an S7-aware `@` available to your package
 NULL
 ```
 
-You can additionally make `@` work for users of your package by attaching the S7 package when your package is attached with this `.onAttach()` code:
-
-```{r}
-.onAttach <- function(libname, pkgname) {
-  if (getRversion() < ""4.3.0"")
-    require(S7)
-}
-```
-
-Use this technique with care as it will attach S7 to the user search path, possibly causing conflicts with other packages/functions.
+`@` will work for users of your package because S7 automatically attaches an environment containing the needed definition when it's loaded."
RConsortium,S7,2d46e2ff47a2a5ecf013c97c8b870415dfbea30a,Hadley Wickham,h.wickham@gmail.com,2023-09-17T12:05:47Z,GitHub,noreply@github.com,2023-09-17T12:05:47Z,"Release S7 0.1.1 (#362)

* Polish news
* Update all GitHub urls
* Fix call. typo
* Update CRAN comments
* Increment version number to 0.1.1",DESCRIPTION;NEWS.md;R/property.R;README.Rmd;README.md;cran-comments.md;tests/testthat/test-base-r.R;vignettes/minutes/2021-05-18.Rmd;vignettes/minutes/2022-02-12.Rmd;vignettes/minutes/2022-03-08.Rmd;vignettes/minutes/2022-08-01.Rmd;vignettes/packages.Rmd;vignettes/spec/requirements.Rmd,True,True,True,False,41,51,92,"---FILE: DESCRIPTION---
@@ -1,7 +1,7 @@
 Package: S7
 Title: 
     An Object Oriented System Meant to Become a Successor to S3 and S4
-Version: 0.1.0.9000
+Version: 0.1.1
 Authors@R: c(
     person(""Object-Oriented Programming Working Group"", role = ""cph""),
     person(""Davis"", ""Vaughan"", role = ""aut""),
@@ -25,7 +25,7 @@ Description: A new object oriented programming system designed to be a successor
 License: MIT + file LICENSE
 URL: https://github.com/rconsortium/S7/,
     https://rconsortium.github.io/S7/
-BugReports: https://github.com/rconsortium/OOP-WG/issues
+BugReports: https://github.com/rconsortium/S7/issues
 Depends: 
     R (>= 3.5.0)
 Imports:

---FILE: NEWS.md---
@@ -1,36 +1,36 @@
-# S7 (development version)
-
-* `S7_inherits()` now accepts `class = NULL` to test if an object is any
-  sort of S7 object (#347).
+# S7 0.1.1
 
 * Classes get a more informative print method (#346).
 
+* Correctly register S3 methods for S7 objects with a package (#333).
+
 * External methods are now registered using an attribute of the S3 methods 
   table rather than an element of that environment. This prevents a warning
   being generated during the ""code/documentation mismatches"" check in
   `R CMD check` (#342).
 
+* `class_missing` and `class_any` can now be unioned with `|` (#337).
+
 * `new_object()` no longer accepts `NULL` as `.parent`.
 
 * `new_object()` now correctly runs the validator from abstract parent classes
   (#329).
 
+* `new_object()` works better when custom property setters modify other 
+  properties.
+
 * `new_property()` gains a `validator` argument that allows you to specify
   a per-property validator (#275).
 
-* `class_missing` and `class_any` can now be unioned with `|` (#337).
-
-* `new_object()` works better when custom property setters modify other 
-  properties.
+* `new_property()` clarifies that it's the user's responsibility to return
+  the correct class; it is _not_ automatically validated.
 
 * Properties with a custom setter are now validated _after_ the setter has
   run and are validated when the object is constructed or when you call 
   `validate()`, not just when you modify them after construction.
 
-* In `new_property()` clarify that it's the user's responsibility to return
-  the correct class; it is _not_ automatically validated.
-
-* Correctly register S3 methods for S7 objects with a package (#333).
+* `S7_inherits()` now accepts `class = NULL` to test if an object is any
+  sort of S7 object (#347).
 
 # S7 0.1.0
 

---FILE: R/property.R---
@@ -218,7 +218,7 @@ prop_obj <- function(object, name) {
       if (isTRUE(check)) {
         error <- prop_validate(prop, value, object)
         if (!is.null(error)) {
-          stop(error, call. = TRUE)
+          stop(error, call. = FALSE)
         }
       }
 

---FILE: README.Rmd---
@@ -17,7 +17,7 @@ knitr::opts_chunk$set(
 
 <!-- badges: start -->
 
-[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental) [![R-CMD-check](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml) [![Codecov test coverage](https://codecov.io/gh/RConsortium/OOP-WG/branch/main/graph/badge.svg)](https://app.codecov.io/gh/RConsortium/OOP-WG?branch=main)
+[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental) [![R-CMD-check](https://github.com/RConsortium/S7/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/RConsortium/S7/actions/workflows/R-CMD-check.yaml) [![Codecov test coverage](https://codecov.io/gh/RConsortium/S7/branch/main/graph/badge.svg)](https://app.codecov.io/gh/RConsortium/S7?branch=main)
 
 <!-- badges: end -->
 

---FILE: README.md---
@@ -7,9 +7,9 @@
 
 [![Lifecycle:
 experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
-[![R-CMD-check](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml)
+[![R-CMD-check](https://github.com/RConsortium/S7/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/RConsortium/S7/actions/workflows/R-CMD-check.yaml)
 [![Codecov test
-coverage](https://codecov.io/gh/RConsortium/OOP-WG/branch/main/graph/badge.svg)](https://app.codecov.io/gh/RConsortium/OOP-WG?branch=main)
+coverage](https://codecov.io/gh/RConsortium/S7/branch/main/graph/badge.svg)](https://app.codecov.io/gh/RConsortium/S7?branch=main)
 
 <!-- badges: end -->
 

---FILE: cran-comments.md---
@@ -1,13 +1,3 @@
-This is a resubmission.
-
-* There are no references to add to the description.
-* I have added the missing `\value{}` documentation.
-* I no longer create S4 classes in the global environment in tests.
-
----
-
 ## R CMD check results
 
-0 errors | 0 warnings | 1 note
-
-* This is a new release.
+0 errors | 0 warnings | 0 notes

---FILE: tests/testthat/test-base-r.R---
@@ -57,7 +57,7 @@ test_that(""base::`@` accesses S7 properties"", {
 
 test_that(""dput(<S7_object>) works"", {
   skip_if(getRversion() < ""4.3"")
-  skip(""dput() not fixed yet; https://github.com/RConsortium/OOP-WG/issues/272"")
+  skip(""dput() not fixed yet; https://github.com/RConsortium/S7/issues/272"")
 
   expect_no_error(dput(new_class(""Foo"")()))
   expect_no_error(dput(new_class(""Foo"")))

---FILE: vignettes/minutes/2021-05-18.Rmd---
@@ -8,7 +8,7 @@ title: ""Minutes 2021-05-18""
 
 ### Process (ML)
 
--   Active discussion in GitHub issues: <https://github.com/RConsortium/OOP-WG>
+-   Active discussion in GitHub issues: <https://github.com/RConsortium/S7>
 
 -   Need a little process to finalise discussion. Proposal: original author reads discussion, summarises, and creates a pull request that closes the issue. Any participants in the discussion should be added as reviewers.
 

---FILE: vignettes/minutes/2022-02-12.Rmd---
@@ -16,7 +16,7 @@ No semantic changes without discussion in issues
     -   Numeric, atomic, and vector ""types"" as S7 unions.
         -   Should we provide some wrappers to base unions and consider if we could get rid of string representation altogether? (e.g. `base_atomic`)
     -   New `s3_class()` to define S3 classes.
-        -   <https://github.com/RConsortium/OOP-WG/pull/148> makes it possible for S7 class to extend an S3 class
+        -   <https://github.com/RConsortium/S7/pull/148> makes it possible for S7 class to extend an S3 class
         -   Should we export the S3 class definitions for common base S3 classes? And then provide with `base_factor` etc.
     -   S4 unions converted to S7 unions
 -   Method registration
@@ -53,9 +53,9 @@ No semantic changes without discussion in issues
 
     -   Next time we meet, we should discuss other ways to advertise
 -   Ok to rename default branch from master to main? \~5 minutes work and unlikely to cause any problems.
--   Ok to eliminate `prop_safely()`? <https://github.com/RConsortium/OOP-WG/issues/156>
--   Convention for displaying class names: <https://github.com/RConsortium/OOP-WG/issues/133> / <https://github.com/RConsortium/OOP-WG/pull/161>
+-   Ok to eliminate `prop_safely()`? <https://github.com/RConsortium/S7/issues/156>
+-   Convention for displaying class names: <https://github.com/RConsortium/S7/issues/133> / <https://github.com/RConsortium/S7/pull/161>
     -   Only show for S3/S4
--   Name of sentinel for missing/any dispatch: <https://github.com/RConsortium/OOP-WG/issues/67>
+-   Name of sentinel for missing/any dispatch: <https://github.com/RConsortium/S7/issues/67>
     -   `_arg` looks good
--   Coercion: <https://github.com/RConsortium/OOP-WG/issues/136>
+-   Coercion: <https://github.com/RConsortium/S7/issues/136>

---FILE: vignettes/minutes/2022-03-08.Rmd---
@@ -5,7 +5,7 @@ title: ""Minutes 2022-03-08""
 ## Changes
 
 -   Website updates (<https://rconsortium.github.io/OOP-WG/>): refreshed readme, minutes as articles.
-    Working on documentation overhaul in <https://github.com/RConsortium/OOP-WG/pull/187>.
+    Working on documentation overhaul in <https://github.com/RConsortium/S7/pull/187>.
 
 -   `new_generic()` now requires `dispatch_args`.
     This means that `new_generic()` will typically be called without names:
@@ -21,17 +21,17 @@ title: ""Minutes 2022-03-08""
 
     -   `new_class(""foo"", properties = list(x = integer, y = double))@constructor`
 
-    -   <https://github.com/RConsortium/OOP-WG/blob/main/R/class.R#L209-L212>
+    -   <https://github.com/RConsortium/S7/blob/main/R/class.R#L209-L212>
 
 -   See other minor changes in\
-    <https://github.com/RConsortium/OOP-WG/blob/main/NEWS.md#feb-2022>
+    <https://github.com/RConsortium/S7/blob/main/NEWS.md#feb-2022>
 
 ## Discussion
 
--   Rename `method_call()`? <https://github.com/RConsortium/OOP-WG/issues/200> --- `S7_dispatch()` sounds good.
--   Abstract classes? <https://github.com/RConsortium/OOP-WG/issues/199>. Easy to implement but is it worth it?
--   What should we call the S7 equivalent of inherits? <https://github.com/RConsortium/OOP-WG/issues/193> --- call it `S7_inherits()` for now; will eventually just be part of inherits. Propose generic extension mechanism for inherits.
--   Explicit S4 registration: <https://github.com/RConsortium/OOP-WG/pull/182>
--   New names for base types? <https://github.com/RConsortium/OOP-WG/issues/170> --- `class_` sounds good.
--   Convert and super: <https://github.com/RConsortium/OOP-WG/pull/181>
--   Should we offer encapsulated OO? <https://github.com/RConsortium/OOP-WG/issues/202>
+-   Rename `method_call()`? <https://github.com/RConsortium/S7/issues/200> --- `S7_dispatch()` sounds good.
+-   Abstract classes? <https://github.com/RConsortium/S7/issues/199>. Easy to implement but is it worth it?
+-   What should we call the S7 equivalent of inherits? <https://github.com/RConsortium/S7/issues/193> --- call it `S7_inherits()` for now; will eventually just be part of inherits. Propose generic extension mechanism for inherits.
+-   Explicit S4 registration: <https://github.com/RConsortium/S7/pull/182>
+-   New names for base types? <https://github.com/RConsortium/S7/issues/170> --- `class_` sounds good.
+-   Convert and super: <https://github.com/RConsortium/S7/pull/181>
+-   Should we offer encapsulated OO? <https://github.com/RConsortium/S7/issues/202>

---FILE: vignettes/minutes/2022-08-01.Rmd---
@@ -14,6 +14,6 @@ title: ""Minutes 2022-08-08""
 
 * R-core meeting in Vienna (Sept). ML to present S7 work and hopefully get some buy-in.
 
-* Base patches? (https://github.com/RConsortium/OOP-WG/issues/222)
+* Base patches? (https://github.com/RConsortium/S7/issues/222)
 
 * Get to CRAN to get more exposure and figure out how to get into base R itself.

---FILE: vignettes/packages.Rmd---
@@ -16,7 +16,7 @@ knitr::opts_chunk$set(
 
 This vignette outlines the most important things you need to know about using S7 in a package.
 S7 is new, so few people have used it in a package yet; this means that this vignette is likely incomplete, and we'd love your help to make it better.
-Please [let us know](https://github.com/RConsortium/OOP-WG/issues/new) if you have questions that this vignette doesn't answer.
+Please [let us know](https://github.com/RConsortium/S7/issues/new) if you have questions that this vignette doesn't answer.
 
 ```{r setup}
 library(S7)
@@ -46,11 +46,11 @@ If you export a class, you must also set the `package` argument, ensuring that c
 You should document generics like regular functions (since they are!).
 If you expect others to create their own methods for your generic, you may want to include an section describing the the properties that you expect all methods to have.
 We plan to provide a an easy way to all methods for a generic, but have not yet implemented it.
-You can track progress at <https://github.com/RConsortium/OOP-WG/issues/167>.
+You can track progress at <https://github.com/RConsortium/S7/issues/167>.
 
 We don't currently have any recommendations on documenting methods.
 There's no need to document them in order to pass `R CMD check`, but obviously there are cases where it's nice to provide additional details for a method, particularly if it takes extra arguments compared to the generic.
-We're tracking that issue at <https://github.com/RConsortium/OOP-WG/issues/315>.
+We're tracking that issue at <https://github.com/RConsortium/S7/issues/315>.
 
 ## Backward compatibility
 

---FILE: vignettes/spec/requirements.Rmd---
@@ -5,7 +5,7 @@ description: >
 ---
 
 
-This page is for brainstorming on the technical requirements for solving our [problem](https://github.com/RConsortium/OOP-WG/wiki/Problem-Statement).
+This page is for brainstorming on the technical requirements for solving our [problem](https://github.com/RConsortium/S7/wiki/Problem-Statement).
 Once we align on the requirements, we can start the design process.
 
 ## List of requirements"
RConsortium,S7,1cfe9f88bbd9db0d8ead2d878fec29839554476b,Hadley Wickham,h.wickham@gmail.com,2023-09-13T15:45:14Z,GitHub,noreply@github.com,2023-09-13T15:45:14Z,"Improve print method (#346)

Fixes #344",NEWS.md;R/class.R;R/utils.R;tests/testthat/_snaps/class.md;tests/testthat/_snaps/property.md;tests/testthat/test-class.R,False,True,True,False,59,12,71,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # S7 (development version)
 
+* Classes get a more informative print method (#346).
+
 * External methods are now registered using an attribute of the S3 methods 
   table rather than an element of that environment. This prevents a warning
   being generated during the ""code/documentation mismatches"" check in

---FILE: R/class.R---
@@ -180,9 +180,19 @@ print.S7_class <- function(x, ...) {
   }
 
   cat(
-    sprintf(""<S7_class>\n@ name  :  %s\n@ parent: %s\n@ properties:\n%s"",
-      x@name,
+    sprintf(
+      paste0(
+        ""%s%s class\n"",
+        ""@ parent     : %s\n"",
+        ""@ constructor: %s\n"",
+        ""@ validator  : %s\n"",
+        ""@ properties :\n%s""
+      ),
+      class_desc(x),
+      if (x@abstract) "" abstract"" else """",
       class_desc(x@parent),
+      show_function(x@constructor, constructor = TRUE),
+      if (!is.null(x@validator)) show_function(x@validator) else ""<NULL>"",
       prop_fmt
     ),
     sep = """"

---FILE: R/utils.R---
@@ -108,15 +108,32 @@ check_function <- function(f, args, arg = deparse(substitute(f))) {
     stop(msg, call. = FALSE)
   }
 }
-show_args <- function(x, name = ""function"") {
+
+show_function <- function(x, constructor = FALSE) {
+  args <- formals(x)
+
+  if (constructor) {
+    args <- lapply(args, function(x) {
+      if (identical(x, quote(class_missing))) {
+        quote(expr = )
+      } else {
+        x
+      }
+    })
+  }
+
+  show_args(args, suffix = "" {...}"")
+}
+
+show_args <- function(x, name = ""function"", suffix = """") {
   if (length(x) == 0) {
     args <- """"
   } else {
     val <- vcapply(x, deparse1)
     args <- paste0(names(x), ifelse(val == """", """", "" = ""), val, collapse = "", "")
   }
 
-  paste0(name, ""("", args, "")"")
+  paste0(name, ""("", args, "")"", suffix)
 }
 
 # For older versions of R ----------------------------------------------------

---FILE: tests/testthat/_snaps/class.md---
@@ -3,10 +3,11 @@
     Code
       foo2
     Output
-      <S7_class>
-      @ name  :  foo2
-      @ parent: <foo1>
-      @ properties:
+      <foo2> class
+      @ parent     : <foo1>
+      @ constructor: function(x, y) {...}
+      @ validator  : <NULL>
+      @ properties :
        $ x: <integer>
        $ y: <integer>
     Code
@@ -40,6 +41,17 @@
       List of 1
        $ : <foo2/foo1/S7_object> constructor
 
+# S7 classes: prints @package and @abstract details
+
+    Code
+      foo
+    Output
+      <S7::foo> abstract class
+      @ parent     : <S7_object>
+      @ constructor: function() {...}
+      @ validator  : <NULL>
+      @ properties :
+
 # S7 classes: checks inputs
 
     Code

---FILE: tests/testthat/_snaps/property.md---
@@ -96,10 +96,11 @@
     Code
       my_class
     Output
-      <S7_class>
-      @ name  :  my_class
-      @ parent: <S7_object>
-      @ properties:
+      <my_class> class
+      @ parent     : <S7_object>
+      @ constructor: function(anything, null, base, S3, S4, S7, S7_union) {...}
+      @ validator  : <NULL>
+      @ properties :
        $ anything: <ANY>                 
        $ null    : <NULL>                
        $ base    : <integer>             

---FILE: tests/testthat/test-class.R---
@@ -23,6 +23,11 @@ describe(""S7 classes"", {
     })
   })
 
+  it(""prints @package and @abstract details"", {
+    foo <- new_class(""foo"", package = ""S7"", abstract = TRUE)
+    expect_snapshot(foo)
+  })
+
   it(""checks inputs"", {
     expect_snapshot(error = TRUE, {
       new_class(1)"
RConsortium,S7,6cbcc8da8d6dbef84a87ab5af9b206da45f44ce4,Hadley Wickham,h.wickham@gmail.com,2023-09-12T13:38:48Z,GitHub,noreply@github.com,2023-09-12T13:38:48Z,"Store the S7 methods table as an attribute of the S3 methods table (#343)

This prevents it from being listed in `functions_in_S3_table` (https://github.com/wch/r-source/blob/16c4fbf48efb4d43ef5dccadc86576100edd85b4/src/library/tools/R/QC.R#L370-L383) and later generating a warning when calling `formals` on each element of that list.

Fixes #342",NEWS.md;R/external-generic.R;tests/testthat/test-external-generic.R,False,True,True,False,25,14,39,"---FILE: NEWS.md---
@@ -1,5 +1,10 @@
 # S7 (development version)
 
+* External methods are now registered using an attribute of the S3 methods 
+  table rather than an element of that environment. This prevents a warning
+  being generated during the ""code/documentation mismatches"" check in
+  `R CMD check` (#342).
+
 * `new_object()` no longer accepts `NULL` as `.parent`.
 
 * `new_object()` now correctly runs the validator from abstract parent classes

---FILE: R/external-generic.R---
@@ -74,7 +74,7 @@ is_external_generic <- function(x) {
 #' }
 methods_register <- function() {
   package <- packageName(parent.frame())
-  tbl <- external_methods_get(package)
+  tbl <- S7_methods_table(package)
 
   for (x in tbl) {
     register <- registrar(x$generic, x$signature, x$method)
@@ -107,28 +107,34 @@ registrar <- function(generic, signature, method) {
   }
 }
 
-external_methods_get <- function(package) {
-  S3_methods_table(package)[["".S7_methods""]] %||% list()
-}
-
 external_methods_reset <- function(package) {
-  tbl <- S3_methods_table(package)
-  tbl[["".S7_methods""]] <- list()
+  S7_methods_table(package) <- list()
   invisible()
 }
 
 external_methods_add <- function(package, generic, signature, method) {
-  tbl <- S3_methods_table(package)
+  tbl <- S7_methods_table(package)
 
   methods <- append(
-    tbl[["".S7_methods""]] %||% list(),
+    tbl,
     list(list(generic = generic, signature = signature, method = method))
   )
 
-  tbl[["".S7_methods""]] <- methods
+  S7_methods_table(package) <- methods
   invisible()
 }
 
-S3_methods_table <- function(package) {
-  asNamespace(package)[["".__S3MethodsTable__.""]]
+# Store external methods in an attribute of the S3 methods table since
+# this mutable object is present in all packages.
+
+S7_methods_table <- function(package) {
+  ns <- asNamespace(package)
+  tbl <- ns[["".__S3MethodsTable__.""]]
+  attr(tbl, ""S7methods"")
+}
+`S7_methods_table<-` <- function(package, value) {
+  ns <- asNamespace(package)
+  tbl <- ns[["".__S3MethodsTable__.""]]
+  attr(tbl, ""S7methods"") <- value
+  invisible()
 }

---FILE: tests/testthat/test-external-generic.R---
@@ -2,12 +2,12 @@ test_that(""can get and append methods"", {
   external_methods_reset(""S7"")
   on.exit(external_methods_reset(""S7""), add = TRUE)
 
-  expect_equal(external_methods_get(""S7""), list())
+  expect_equal(S7_methods_table(""S7""), list())
 
   bar <- new_external_generic(""foo"", ""bar"", ""x"")
   external_methods_add(""S7"", bar, list(), function() {})
   expect_equal(
-    external_methods_get(""S7""),
+    S7_methods_table(""S7""),
     list(
       list(
         generic = bar,"
RConsortium,S7,d3e5eaa9499cbf02e0a479e92bef0790a482b046,Hadley Wickham,h.wickham@gmail.com,2023-09-11T19:21:25Z,GitHub,noreply@github.com,2023-09-11T19:21:25Z,"Run validator of abstract classes (#338)

Fixes #329",NEWS.md;R/class.R;tests/testthat/_snaps/class.md;tests/testthat/test-class.R,False,True,True,False,28,2,30,"---FILE: NEWS.md---
@@ -1,5 +1,8 @@
 # S7 (development version)
 
+* `new_object()` now correctly runs the validator from abstract parent classes 
+  (#329).
+
 * `new_property()` gains a `validator` argument that allows you to specify
   a per-property validator (#275).
 

---FILE: R/class.R---
@@ -261,8 +261,10 @@ new_object <- function(.parent, ...) {
     prop(object, prop, check = FALSE) <- prop_default(class@properties[[prop]])
   }
 
-  # Only needs to validate this object if parent was already an S7 object
-  validate(object, recursive = !inherits(.parent, ""S7_object""))
+  # Don't need to validate if parent class already validated,
+  # i.e. it's a non-abstract S7 class
+  parent_validated <- inherits(class@parent, ""S7_object"") && !class@parent@abstract
+  validate(object, recursive = !parent_validated)
 
   object
 }

---FILE: tests/testthat/_snaps/class.md---
@@ -101,6 +101,14 @@
     Error <simpleError>
       Abstract classes must have abstract parents
 
+# abstract classes: can use inherited validator from abstract class
+
+    Code
+      foo2(x = 2)
+    Error <simpleError>
+      <foo2> object is invalid:
+      - @x has bad value
+
 # new_object(): gives useful error if called directly
 
     Code

---FILE: tests/testthat/test-class.R---
@@ -84,6 +84,19 @@ describe(""abstract classes"", {
     foo2 <- new_class(""foo2"", parent = foo1)
     expect_s3_class(foo2(), ""foo2"")
   })
+  it(""can use inherited validator from abstract class"", {
+    foo1 <- new_class(
+      ""foo1"",
+      properties = list(x = class_double),
+      abstract = TRUE,
+      validator = function(self) {
+        if (self@x == 2) ""@x has bad value""
+      }
+    )
+    foo2 <- new_class(""foo2"", parent = foo1)
+    expect_no_error(foo2(x = 1))
+    expect_snapshot(foo2(x = 2), error = TRUE)
+  })
 })
 
 describe(""new_object()"", {"
RConsortium,S7,4b0afb07eeb552a98e75d93109b7df0efc7cec03,Hadley Wickham,h.wickham@gmail.com,2023-09-11T19:20:51Z,GitHub,noreply@github.com,2023-09-11T19:20:51Z,"Implement per-property validators (#339)

Fixes #275",NEWS.md;R/property.R;man/new_property.Rd;tests/testthat/_snaps/class.md;tests/testthat/_snaps/property.md;tests/testthat/test-property.R,False,True,True,False,106,27,133,"---FILE: NEWS.md---
@@ -1,5 +1,8 @@
 # S7 (development version)
 
+* `new_property()` gains a `validator` argument that allows you to specify
+  a per-property validator (#275).
+
 * `class_missing` and `class_any` can now be unioned with `|` (#337).
 
 * `new_object()` works better when custom property setters modify other 
@@ -9,7 +12,7 @@
   run and are validated when the object is constructed or when you call 
   `validate()`, not just when you modify them after construction.
 
-* In `new_property()` clarify that it's the users responsibility to return
+* In `new_property()` clarify that it's the user's responsibility to return
   the correct class; it is _not_ automatically validated.
 
 * Correctly register S3 methods for S7 objects with a package (#333).

---FILE: R/property.R---
@@ -19,6 +19,17 @@
 #'   If a property has a getter but doesn't have a setter, it is read only.
 #' @param setter An optional function used to set the value. The function
 #'   should take `self` and `value` and return a modified object.
+#' @param validator A function taking a single argument, `value`, the value
+#'   to validate.
+#'
+#'   The job of a validator is to determine whether the property value is valid.
+#'   It should return `NULL` if the object is valid, or if it's not valid,
+#'   a single string describing the problem. The message should not include the
+#'   name of the property as this will be automatically appended to the
+#'   beginning of the message.
+#'
+#'   The validator will be called after the `class` has been verified, so
+#'   your code can assume that `self` has known type.
 #' @param default When an object is created and the property is not supplied,
 #'   what should it default to? If `NULL`, defaults to the ""empty"" instance
 #'   of `class`.
@@ -69,7 +80,12 @@
 #' hadley@firstName
 #' hadley@firstName <- ""John""
 #' hadley@first_name
-new_property <- function(class = class_any, getter = NULL, setter = NULL, default = NULL, name = NULL) {
+new_property <- function(class = class_any,
+                         getter = NULL,
+                         setter = NULL,
+                         validator = NULL,
+                         default = NULL,
+                         name = NULL) {
   class <- as_class(class)
   if (!is.null(default) && !class_inherits(default, class)) {
     msg <- sprintf(""`default` must be an instance of %s, not a %s"", class_desc(class), obj_desc(default))
@@ -82,12 +98,16 @@ new_property <- function(class = class_any, getter = NULL, setter = NULL, defaul
   if (!is.null(setter)) {
     check_function(setter, alist(self = , value = ))
   }
+  if (!is.null(validator)) {
+    check_function(validator, alist(value = ))
+  }
 
   out <- list(
     name = name,
     class = class,
     getter = getter,
     setter = setter,
+    validator = validator,
     default = default
   )
   class(out) <- ""S7_property""
@@ -219,15 +239,25 @@ prop_error_unknown <- function(object, prop_name) {
 
 prop_validate <- function(prop, value, object = NULL) {
   if (!class_inherits(value, prop$class)) {
-    return(sprintf(""%s@%s must be %s, not %s"",
-      if (!is.null(object)) obj_desc(object) else """",
-      prop$name,
+    sprintf(""%s must be %s, not %s"",
+      prop_label(object, prop$name),
       class_desc(prop$class),
       obj_desc(value)
-    ))
+    )
+  } else if (!is.null(prop$validator)) {
+    val <- prop$validator(value)
+    if (is.null(val)) {
+      return(NULL)
+    }
+
+    paste0(prop_label(object, prop$name), "" "", val)
+  } else {
+    NULL
   }
+}
 
-  NULL
+prop_label <- function(object, name) {
+  sprintf(""%s@%s"", if (!is.null(object)) obj_desc(object) else """", name)
 }
 
 #' @rdname prop

---FILE: man/new_property.Rd---
@@ -8,6 +8,7 @@ new_property(
   class = class_any,
   getter = NULL,
   setter = NULL,
+  validator = NULL,
   default = NULL,
   name = NULL
 )
@@ -26,6 +27,18 @@ If a property has a getter but doesn't have a setter, it is read only.}
 \item{setter}{An optional function used to set the value. The function
 should take \code{self} and \code{value} and return a modified object.}
 
+\item{validator}{A function taking a single argument, \code{value}, the value
+to validate.
+
+The job of a validator is to determine whether the property value is valid.
+It should return \code{NULL} if the object is valid, or if it's not valid,
+a single string describing the problem. The message should not include the
+name of the property as this will be automatically appended to the
+beginning of the message.
+
+The validator will be called after the \code{class} has been verified, so
+your code can assume that \code{self} has known type.}
+
 \item{default}{When an object is created and the property is not supplied,
 what should it default to? If \code{NULL}, defaults to the ""empty"" instance
 of \code{class}.}

---FILE: tests/testthat/_snaps/class.md---
@@ -18,17 +18,19 @@
        @ package    : NULL
        @ properties :List of 2
        .. $ x: <S7_property> 
-       ..  ..$ name   : chr ""x""
-       ..  ..$ class  : <S7_base_class>: <integer>
-       ..  ..$ getter : NULL
-       ..  ..$ setter : NULL
-       ..  ..$ default: NULL
+       ..  ..$ name     : chr ""x""
+       ..  ..$ class    : <S7_base_class>: <integer>
+       ..  ..$ getter   : NULL
+       ..  ..$ setter   : NULL
+       ..  ..$ validator: NULL
+       ..  ..$ default  : NULL
        .. $ y: <S7_property> 
-       ..  ..$ name   : chr ""y""
-       ..  ..$ class  : <S7_base_class>: <integer>
-       ..  ..$ getter : NULL
-       ..  ..$ setter : NULL
-       ..  ..$ default: NULL
+       ..  ..$ name     : chr ""y""
+       ..  ..$ class    : <S7_base_class>: <integer>
+       ..  ..$ getter   : NULL
+       ..  ..$ setter   : NULL
+       ..  ..$ validator: NULL
+       ..  ..$ default  : NULL
        @ abstract   : logi FALSE
        @ constructor: function (x = class_missing, y = class_missing)  
        @ validator  : NULL

---FILE: tests/testthat/_snaps/property.md---
@@ -73,21 +73,23 @@
       print(x)
     Output
       <S7_property> 
-       $ name   : chr ""foo""
-       $ class  : <S7_base_class>: <integer>
-       $ getter : NULL
-       $ setter : NULL
-       $ default: NULL
+       $ name     : chr ""foo""
+       $ class    : <S7_base_class>: <integer>
+       $ getter   : NULL
+       $ setter   : NULL
+       $ validator: NULL
+       $ default  : NULL
     Code
       str(list(x))
     Output
       List of 1
        $ : <S7_property> 
-        ..$ name   : chr ""foo""
-        ..$ class  : <S7_base_class>: <integer>
-        ..$ getter : NULL
-        ..$ setter : NULL
-        ..$ default: NULL
+        ..$ name     : chr ""foo""
+        ..$ class    : <S7_base_class>: <integer>
+        ..$ getter   : NULL
+        ..$ setter   : NULL
+        ..$ validator: NULL
+        ..$ default  : NULL
 
 # properties can be base, S3, S4, S7, or S7 union
 
@@ -156,3 +158,16 @@
     Error <simpleError>
       `properties` names must be unique
 
+# can validate with custom validator
+
+    Code
+      f <- foo(x = 1L)
+      f@x <- 1:2
+    Error <simpleError>
+      <foo>@x must be length 1
+    Code
+      foo(x = 1:2)
+    Error <simpleError>
+      <foo> object properties are invalid:
+      - @x must be length 1
+

---FILE: tests/testthat/test-property.R---
@@ -298,3 +298,19 @@ test_that(""as_properties() gives useful error messages"", {
     as_properties(list(x = class_character, x = class_character))
   })
 })
+
+test_that(""can validate with custom validator"", {
+  validate_scalar <- function(value) {
+    if (length(value) != 1) {
+      ""must be length 1""
+    }
+  }
+  prop <- new_property(class_integer, validator = validate_scalar)
+  foo <- new_class(""foo"", properties = list(x = prop))
+  expect_snapshot(error = TRUE, {
+    f <- foo(x = 1L)
+    f@x <- 1:2
+
+    foo(x = 1:2)
+  })
+})"
RConsortium,S7,e37574c6355167c93a8035db37a20fdc4dc9796e,Hadley Wickham,h.wickham@gmail.com,2023-09-10T17:19:38Z,GitHub,noreply@github.com,2023-09-10T17:19:38Z,"Add missing | methods (#340)

Fixes #337",NEWS.md;R/zzz.R;tests/testthat/test-union.R,False,True,True,False,6,0,6,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # S7 (development version)
 
+* `class_missing` and `class_any` can now be unioned with `|` (#337).
+
 * `new_object()` works better when custom property setters modify other 
   properties.
 

---FILE: R/zzz.R---
@@ -148,6 +148,8 @@ chooseOpsMethod.S7_object <- function(x, y, mx, my, cl, reverse) TRUE
   registerS3method(""|"", ""S7_union"", `|.S7_class`)
   registerS3method(""|"", ""S7_base_class"", `|.S7_class`)
   registerS3method(""|"", ""S7_S3_class"", `|.S7_class`)
+  registerS3method(""|"", ""S7_any"", `|.S7_class`)
+  registerS3method(""|"", ""S7_missing"", `|.S7_class`)
   registerS3method(""|"", ""classGeneratorFunction"", `|.S7_class`)
   registerS3method(""|"", ""ClassUnionRepresentation"", `|.S7_class`)
   registerS3method(""|"", ""classRepresentation"", `|.S7_class`)

---FILE: tests/testthat/test-union.R---
@@ -57,6 +57,8 @@ test_that(""can construct with |"", {
   expect_equal(class_integer | getClass(""Foo1""), new_union(class_integer, Foo1))
   expect_equal(class_integer | Foo3, new_union(class_integer, Foo3))
   expect_equal(class_integer | getClass(""Foo3""), new_union(class_integer, Foo3))
+  expect_equal(class_integer | class_missing, new_union(class_integer, class_missing))
+  expect_equal(class_integer | class_any, new_union(class_integer, class_any))
 })
 
 test_that(""can construct optional union with syntactic sugar"", {"
RConsortium,S7,a38a637bfe7aac5200168e5b6580bf22fd462875,Tomasz Kalinowski,tomasz@posit.co,2023-09-08T17:44:47Z,GitHub,noreply@github.com,2023-09-08T17:44:47Z,"Fix Ops signature; move matrixOps out of Ops group (#328)

Closes #321",R/generic-spec.R;R/zzz.R;tests/testthat/test-base-r.R;tests/testthat/test-generic-spec.R;tests/testthat/test-method-register.R,False,True,True,False,20,8,28,"---FILE: R/generic-spec.R---
@@ -17,6 +17,8 @@ as_S3_generic <- function(x) {
     name <- find_base_name(x)
     if (name %in% names(base_ops)) {
       return(base_ops[[name]])
+    } else if (name %in% names(base_matrix_ops)) {
+      return(base_matrix_ops[[name]])
     } else if (!is.na(name) && is_internal_generic(name)) {
       return(S3_generic(x, name))
     }

---FILE: R/zzz.R---
@@ -102,16 +102,26 @@ methods::setOldClass(c(""S7_method"", ""function"", ""S7_object""))
 
 
 # Create generics for double dispatch base Ops
-base_ops <- lapply(setNames(, unlist(group_generics()[c(""Ops"", ""matrixOps"")])),
-                   new_generic, dispatch_args = c(""x"", ""y""))
+base_ops <- lapply(setNames(, group_generics()$Ops),
+                   new_generic, dispatch_args = c(""e1"", ""e2""))
 
 #' @export
 Ops.S7_object <- function(e1, e2) {
   base_ops[[.Generic]](e1, e2)
 }
 
+base_matrix_ops <- lapply(setNames(, group_generics()$matrixOps),
+                          new_generic, dispatch_args = c(""x"", ""y""))
+
 #' @rawNamespace if (getRversion() >= ""4.3.0"") S3method(matrixOps, S7_object)
-matrixOps.S7_object <- Ops.S7_object
+matrixOps.S7_object <- function(x, y) {
+  base_matrix_ops[[.Generic]](x, y)
+}
+
+if(getRversion() < ""4.4.0"")
+matrixOps.S7_object <- function(e1, e2) {
+  base_matrix_ops[[.Generic]](e1, e2)
+}
 
 #' @rawNamespace if (getRversion() >= ""4.3.0"") S3method(chooseOpsMethod, S7_object)
 chooseOpsMethod.S7_object <- function(x, y, mx, my, cl, reverse) TRUE

---FILE: tests/testthat/test-base-r.R---
@@ -61,8 +61,8 @@ test_that(""Ops generics dispatch to S7 methods"", {
 
   ## Test Ops
   ClassX <- new_class(""ClassX"")
-  method(`+`, list(class_any, ClassX))   <- function(x, y) ""class_any + ClassX""
-  method(`+`, list(ClassX, class_any))   <- function(x, y) ""ClassX + class_any""
+  method(`+`, list(class_any, ClassX))   <- function(e1, e2) ""class_any + ClassX""
+  method(`+`, list(ClassX, class_any))   <- function(e1, e2) ""ClassX + class_any""
   method(`%*%`, list(ClassX, class_any)) <- function(x, y) ""ClassX %*% class_any""
   method(`%*%`, list(class_any, ClassX)) <- function(x, y) ""class_any %*% ClassX""
 
@@ -96,7 +96,7 @@ test_that(""Ops generics dispatch to S7 methods"", {
   `+.foo`   <- function(e1, e2) paste(class(e1), ""+""     , class(e2))
   `%*%.foo` <- function(x, y)   paste(class(x) , ""%*%""   , class(y))
   Ops.bar   <- function(e1, e2) paste(class(e1), .Generic, class(e2))
-  matrixOps.bar   <- function(e1, e2) paste(class(e1), .Generic, class(e2))
+  matrixOps.bar   <- function(x, y) paste(class(x), .Generic, class(y))
 
   foo <- structure("""", class = ""foo"")
   bar <- structure("""", class = ""bar"")

---FILE: tests/testthat/test-generic-spec.R---
@@ -15,5 +15,5 @@ test_that(""can standardise generics"", {
 test_that(""base ops use S7 shim"", {
   expect_equal(as_generic(`+`), base_ops[[""+""]])
   if(getRversion() >= ""4.3.0"")
-    expect_equal(as_generic(`%*%`), base_ops[[""%*%""]])
+    expect_equal(as_generic(`%*%`), base_matrix_ops[[""%*%""]])
 })

---FILE: tests/testthat/test-method-register.R---
@@ -55,7 +55,7 @@ describe(""method registration"", {
     foo <- new_class(""foo"")
     bar <- new_class(""bar"")
 
-    method(`+`, list(foo, bar)) <- function(x, y) ""foobar""
+    method(`+`, list(foo, bar)) <- function(e1, e2) ""foobar""
     expect_equal(foo() + bar(), ""foobar"")
 
     if(getRversion() >= ""4.3.0"") {"
RConsortium,S7,facae562958c1a41a524a70bf582894856745bd6,Hadley Wickham,h.wickham@gmail.com,2023-09-08T16:08:25Z,GitHub,noreply@github.com,2023-09-08T16:08:25Z,"Use full class name when registering S3 methods (#334)

Fixes #333",NEWS.md;R/method-register.R;tests/testthat/test-method-register.R,False,True,True,False,10,4,14,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # S7 (development version)
 
+* Correctly register S3 methods for S7 objects with a package (#333).
+
 # S7 0.1.0
 
 ## May-July 2023

---FILE: R/method-register.R---
@@ -113,7 +113,7 @@ register_S3_method <- function(generic, signature, method) {
     )
     stop(msg, call. = FALSE)
   }
-  class <- signature[[1]]@name
+  class <- S7_class_name(signature[[1]])
   registerS3method(generic$name, class, method, envir = parent.frame())
 }
 

---FILE: tests/testthat/test-method-register.R---
@@ -39,9 +39,13 @@ describe(""method registration"", {
   })
 
   it(""can register S7 method for S3 generic"", {
-    foo <- new_class(""foo"")
-    method(sum, foo) <- function(x, ...) ""foo""
-    expect_equal(sum(foo()), ""foo"")
+    foo1 <- new_class(""foo"")
+    method(sum, foo1) <- function(x, ...) ""foo""
+    expect_equal(sum(foo1()), ""foo"")
+
+    foo2 <- new_class(""foo"", package = ""bar"")
+    method(sum, foo2) <- function(x, ...) ""foo""
+    expect_equal(sum(foo2()), ""foo"")
 
     # and doesn't modify generic
     expect_equal(sum, base::sum)"
RConsortium,S7,aaf645c7e41c680f16377f80784de43f07b20787,Jon Harmon,jonthegeek@gmail.com,2023-09-02T19:39:51Z,GitHub,noreply@github.com,2023-09-02T19:39:51Z,"Fix url (#331)

Search doesn't work since it redirects to the old url.",_pkgdown.yml,False,False,False,False,1,1,2,"---FILE: _pkgdown.yml---
@@ -1,4 +1,4 @@
-url: https://RConsortium.github.io/OOP-WG
+url: https://rconsortium.github.io/S7/
 
 template:
   bootstrap: 5"
RConsortium,S7,e1c1edd49098d810b86942bead2151ced418b568,Hugo Gruson,Bisaloo@users.noreply.github.com,2023-08-31T20:19:58Z,GitHub,noreply@github.com,2023-08-31T20:19:58Z,Fix typo (#330),vignettes/packages.Rmd,True,False,True,False,1,1,2,"---FILE: vignettes/packages.Rmd---
@@ -24,7 +24,7 @@ library(S7)
 
 ## Method registration
 
-You should alwys call `methods_register()` in your `.onLoad()`:
+You should always call `methods_register()` in your `.onLoad()`:
 
 ```{r}
 .onLoad <- function(...) {"
RConsortium,S7,1aa094ba726a4d8fa10795ecb1cb091f0508444f,Jim Hester,james.f.hester@gmail.com,2023-08-26T19:10:04Z,GitHub,noreply@github.com,2023-08-26T19:10:04Z,"Fix the codecov badges on the readme (#324)

It seems the badge url should _not_ have an app subdomain, while the
link does.

Co-authored-by: Jim Hester <jimhester@netflix.com>",README.Rmd;README.md,True,False,True,False,2,2,4,"---FILE: README.Rmd---
@@ -17,7 +17,7 @@ knitr::opts_chunk$set(
 
 <!-- badges: start -->
 
-[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental) [![R-CMD-check](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml) [![Codecov test coverage](https://app.codecov.io/gh/RConsortium/OOP-WG/branch/main/graph/badge.svg)](https://app.codecov.io/gh/RConsortium/OOP-WG?branch=main)
+[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental) [![R-CMD-check](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml) [![Codecov test coverage](https://codecov.io/gh/RConsortium/OOP-WG/branch/main/graph/badge.svg)](https://app.codecov.io/gh/RConsortium/OOP-WG?branch=main)
 
 <!-- badges: end -->
 

---FILE: README.md---
@@ -9,7 +9,7 @@
 experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
 [![R-CMD-check](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml)
 [![Codecov test
-coverage](https://app.codecov.io/gh/RConsortium/OOP-WG/branch/main/graph/badge.svg)](https://app.codecov.io/gh/RConsortium/OOP-WG?branch=main)
+coverage](https://codecov.io/gh/RConsortium/OOP-WG/branch/main/graph/badge.svg)](https://app.codecov.io/gh/RConsortium/OOP-WG?branch=main)
 
 <!-- badges: end -->
 "
RConsortium,S7,cf14ac6946ab622300d27e40bea4aca17435c200,Hadley Wickham,h.wickham@gmail.com,2023-08-16T18:03:08Z,Hadley Wickham,h.wickham@gmail.com,2023-08-16T18:03:08Z,"Polish title

Fixes #308",DESCRIPTION,False,False,False,False,1,1,2,"---FILE: DESCRIPTION---
@@ -1,6 +1,6 @@
 Package: S7
 Title: 
-    An Object Oriented System Designed to be a Successor to S3 and S4
+    An Object Oriented System Meant to Become a Successor to S3 and S4
 Version: 0.0.0.9000
 Authors@R: c(
     person(""Object-Oriented Programming Working Group"", role = ""cph""),"
RConsortium,S7,2b5f301e1af5ca64067ed8de8ee90a5f2cb02bc4,Hadley Wickham,h.wickham@gmail.com,2023-07-18T18:57:29Z,GitHub,noreply@github.com,2023-07-18T18:57:29Z,"Start on packages vignette (#312)

Fixes #306. Fixes #302.",_pkgdown.yml;vignettes/compatibility.Rmd;vignettes/packages.Rmd,True,False,True,False,77,27,104,"---FILE: _pkgdown.yml---
@@ -44,6 +44,7 @@ articles:
   - generics-methods
   - classes-objects
   - compatibility
+  - packages
   - motivation
   - performance
 

---FILE: vignettes/compatibility.Rmd---
@@ -154,30 +154,4 @@ foo
 
 S7 unions allow you to restrict the type of a property in the same way that S4 unions allow you to restrict the type of a slot.
 
-## Using S7 in a package
-
-If you are using S7 in a package *and* you want your package to maintain compatibility with R versions prior to 4.3.0, there are a few things to be aware of.
-
-#### `@`
-
-`` base::`@` `` in R versions prior to R 4.3.0 does not resolve R7 properties.
-
-Workarounds:
-
--   Use `S7::prop()` instead of `@`.
-
--   Alternatively, make an S7-aware `@` available to your package with a custom `NAMESPACE` directive and `.onAttach()` like this:
-
-    ``` r
-    # enable usage of <S7_object>@name in package code
-    #' @rawNamespace if (getRversion() < ""4.3.0"") importFrom(""S7"", ""@"")
-    NULL
-
-    # enable usage of <S7_object>@name in user code
-    # e.g. if you also want users to be able to access properties
-    # of objects your package
-    .onAttach <- function(libname, pkgname) {
-      if (getRversion() < ""4.3.0"")
-        require(S7)
-    }
-    ```
+## 

---FILE: vignettes/packages.Rmd---
@@ -0,0 +1,75 @@
+---
+title: ""Using S7 in a package""
+output: rmarkdown::html_vignette
+vignette: >
+  %\VignetteIndexEntry{packages}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+
+```{r, include = FALSE}
+knitr::opts_chunk$set(
+  collapse = TRUE,
+  comment = ""#>""
+)
+```
+
+This vignette outlines the most important things you need to know about using S7 in a package.
+S7 is new, so few people have used it in a package yet; this means that this vignette is likely incomplete, and we'd love your help to make it better.
+Please [let us know](https://github.com/RConsortium/OOP-WG/issues/new) if you have questions that this vignette doesn't answer.
+
+```{r setup}
+library(S7)
+```
+
+## Method registration
+
+You should alwys call `methods_register()` in your `.onLoad()`:
+
+```{r}
+.onLoad <- function(...) {
+  S7::methods_register()
+}
+```
+
+This is S7's way of registering methods, rather than using export directives in your `NAMESPACE` like S3 and S4 do.
+This is only strictly necessary if registering methods for generics in other packages, but there's no harm in adding it and it ensures that you won't forget later.
+(And if you're not importing S7 into your namespace it will quiet an `R CMD check` `NOTE`.`)`
+
+## Documentation and exports
+
+If you want users to create instances of your class, you will need to export the class constructor.
+That means you will also need to document it, and since the constructor is a function, that means you have to document the arguments which will be the properties of the class (unless you have customised the constructor).
+
+You should document generics like regular functions (since they are!).
+If you expect others to create their own methods for your generic, you may want to include an section describing the the properties that you expect all methods to have.
+We plan to provide a an easy way to all methods for a generic, but have not yet implemented it.
+You can track progress at <https://github.com/RConsortium/OOP-WG/issues/167>.
+
+We don't currently have any recommendations on documenting methods.
+There's no need to document them in order to pass `R CMD check`, but obviously there are cases where it's nice to provide additional details for a method, particularly if it takes extra arguments compared to the generic.
+We're tracking that issue at <https://github.com/RConsortium/OOP-WG/issues/315>.
+
+## Backward compatibility
+
+If you are using S7 in a package *and* you want your package to work in versions of R before 4.3.0, you need to know that in these versions of R `@` only works with S4 objects.
+There are two workarounds.
+The easiest and least convenient workaround is to just `prop()` instead of `@`.
+Otherwise, you can conditionally make an S7-aware `@` available to your package with this custom `NAMESPACE` directive:
+
+``` r
+# enable usage of <S7_object>@name in package code
+#' @rawNamespace if (getRversion() < ""4.3.0"") importFrom(""S7"", ""@"")
+NULL
+```
+
+You can additionally make `@` work for users of your package by attaching the S7 package when your package is attached with this `.onAttach()` code:
+
+```{r}
+.onAttach <- function(libname, pkgname) {
+  if (getRversion() < ""4.3.0"")
+    require(S7)
+}
+```
+
+Use this technique with care as it will attach S7 to the user search path, possibly causing conflicts with other packages/functions."
RConsortium,S7,fd477dfdf53adb9840c6f1c50af30087aa89a42c,Hadley Wickham,h.wickham@gmail.com,2023-07-13T16:54:25Z,GitHub,noreply@github.com,2023-07-13T16:54:25Z,"Convey experimental nature in README (#310)

Fixes #226",README.Rmd;README.md,True,False,True,False,17,7,24,"---FILE: README.Rmd---
@@ -17,12 +17,15 @@ knitr::opts_chunk$set(
 
 <!-- badges: start -->
 
-[![R-CMD-check](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml) [![Codecov test coverage](https://app.codecov.io/gh/RConsortium/OOP-WG/branch/master/graph/badge.svg)](https://app.codecov.io/gh/RConsortium/OOP-WG?branch=master)
+[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental) [![R-CMD-check](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml) [![Codecov test coverage](https://app.codecov.io/gh/RConsortium/OOP-WG/branch/main/graph/badge.svg)](https://app.codecov.io/gh/RConsortium/OOP-WG?branch=main)
 
 <!-- badges: end -->
 
 The S7 package is a new OOP system designed to be a successor to S3 and S4.
-It has been designed and implemented collaboratively by the R Consortium Object-Oriented Programming Working Group, which includes representatives from R-Core, BioConductor, RStudio/tidyverse, and the wider R community.
+It has been designed and implemented collaboratively by the R Consortium Object-Oriented Programming Working Group, which includes representatives from R-Core, Bioconductor, the tidyverse/Posit, and the wider R community.
+
+S7 is somewhat experimental; we are confident in the design but it has relatively little usage in the wild currently.
+We hope to avoid any major breaking changes, but reserve the right if we discover major problems.
 
 ## Installation
 
@@ -36,7 +39,7 @@ install.packages(""S7"")
 ## Usage
 
 This section gives a very brief overview of the entirety of S7.
-Learn more of the basics in `vignette(""S7"")`, generics and methods in `vignette(""generics-methods"")`, classes and objects in`vigentte(""classes-objects')`, and compatibility with S3 and S4 in `vignette(""compatibility"")`.
+Learn more of the basics in `vignette(""S7"")`, generics and methods in `vignette(""generics-methods"")`, classes and objects in `vignette(""classes-objects"")`, and compatibility with S3 and S4 in `vignette(""compatibility"")`.
 
 ```{r}
 library(S7)

---FILE: README.md---
@@ -5,18 +5,25 @@
 
 <!-- badges: start -->
 
+[![Lifecycle:
+experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
 [![R-CMD-check](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml)
 [![Codecov test
-coverage](https://app.codecov.io/gh/RConsortium/OOP-WG/branch/master/graph/badge.svg)](https://app.codecov.io/gh/RConsortium/OOP-WG?branch=master)
+coverage](https://app.codecov.io/gh/RConsortium/OOP-WG/branch/main/graph/badge.svg)](https://app.codecov.io/gh/RConsortium/OOP-WG?branch=main)
 
 <!-- badges: end -->
 
 The S7 package is a new OOP system designed to be a successor to S3 and
 S4. It has been designed and implemented collaboratively by the R
 Consortium Object-Oriented Programming Working Group, which includes
-representatives from R-Core, BioConductor, RStudio/tidyverse, and the
+representatives from R-Core, Bioconductor, the tidyverse/Posit, and the
 wider R community.
 
+S7 is somewhat experimental; we are confident in the design but it has
+relatively little usage in the wild currently. We hope to avoid any
+major breaking changes, but reserve the right if we discover major
+problems.
+
 ## Installation
 
 The long-term goal of this project is to merge S7 in to base R. For now,
@@ -30,8 +37,8 @@ install.packages(""S7"")
 
 This section gives a very brief overview of the entirety of S7. Learn
 more of the basics in `vignette(""S7"")`, generics and methods in
-`vignette(""generics-methods"")`, classes and objects
-in`vigentte(""classes-objects')`, and compatibility with S3 and S4 in
+`vignette(""generics-methods"")`, classes and objects in
+`vignette(""classes-objects"")`, and compatibility with S3 and S4 in
 `vignette(""compatibility"")`.
 
 ``` r"
RConsortium,S7,41b73027ffca6b001ecc5cb6b398c5f6e156baed,Hadley Wickham,h.wickham@gmail.com,2023-07-10T14:47:52Z,Hadley Wickham,h.wickham@gmail.com,2023-07-10T14:47:52Z,"Fix typos

Fixes #305",R/S4.R;R/class-spec.R;R/convert.R;R/method-introspect.R;R/property.R;man/convert.Rd;man/new_property.Rd;man/props.Rd;vignettes/minutes/2021-05-18.Rmd;vignettes/spec/design.Rmd;vignettes/spec/dispatch.Rmd;vignettes/spec/proposal.Rmd,True,True,True,False,17,17,34,"---FILE: R/S4.R---
@@ -17,7 +17,7 @@ S4_register <- function(class, env = parent.frame()) {
 is_S4_class <- function(x) inherits(x, ""classRepresentation"")
 
 S4_to_S7_class <- function(x, error_base = """") {
-  # Silence R CMD check false postives
+  # Silence R CMD check false positives
   distance <- subClass <- className <- package <- NULL
 
   # Convert generator function to class

---FILE: R/class-spec.R---
@@ -181,7 +181,7 @@ class_inherits <- function(x, what) {
     S7_union = any(vlapply(what$classes, class_inherits, x = x)),
     # This is slightly too crude as we really want them to be in the same
     # order and contiguous, but it's probably close enough for practical
-    # purposees
+    # purposes
     S7_S3 = !isS4(x) && all(what$class %in% class(x)),
   )
 }

---FILE: R/convert.R---
@@ -28,7 +28,7 @@
 #' convert(foo2(x = 1L, y = 2), to = class_double)
 #' convert(foo2(x = 1L, y = 2), to = foo1)
 #'
-#' # If we define a convert method for interger + foo1:
+#' # If we define a convert method for integer + foo1:
 #' method(convert, list(class_integer, foo1)) <- function(from, to) foo1(x = from)
 #' convert(1L, to = foo1)
 #' # Converting too foo2 still errors

---FILE: R/method-introspect.R---
@@ -73,8 +73,8 @@ method_explain <- function(generic, class = NULL, object = NULL) {
   dim(names) <- dim(grid)
   methods <- apply(names, 1, paste, collapse = "", "")
 
-  has_method <- function(dispatchs, env) {
-    for (x in dispatchs) {
+  has_method <- function(dispatches, env) {
+    for (x in dispatches) {
       env <- env[[x]]
     }
     is.function(env)

---FILE: R/property.R---
@@ -22,7 +22,7 @@
 #'   what should it default to? If `NULL`, defaults to the ""empty"" instance
 #'   of `class`.
 #' @param name Property name, primarily used for error messages. Used
-#'   primrarily for testing as it is set automatically when using a list of
+#'   primarily for testing as it is set automatically when using a list of
 #'   properties.
 #' @export
 #' @examples
@@ -169,7 +169,7 @@ prop_obj <- function(object, name) {
 #'   [validate()] on the object before returning.
 #' @export
 `prop<-` <- local({
-  # This flag is used to avoid infinate loops if you are assigning a property from a setter function
+  # This flag is used to avoid infinite loops if you are assigning a property from a setter function
   setter_property <- NULL
 
   function(object, name, check = TRUE, value) {
@@ -308,7 +308,7 @@ prop_exists <- function(object, name) {
 #' lexington <- horse(colour = ""bay"", height = 15, name = ""Lex"")
 #'
 #' props(lexington)
-#' props(lexington) <- list(height = 14, name = ""Lexigonton"")
+#' props(lexington) <- list(height = 14, name = ""Lexington"")
 #' lexington
 props <- function(object) {
   check_is_S7(object)

---FILE: man/convert.Rd---
@@ -37,7 +37,7 @@ convert(foo2(x = 1L, y = 2), to = class_integer)
 convert(foo2(x = 1L, y = 2), to = class_double)
 convert(foo2(x = 1L, y = 2), to = foo1)
 
-# If we define a convert method for interger + foo1:
+# If we define a convert method for integer + foo1:
 method(convert, list(class_integer, foo1)) <- function(from, to) foo1(x = from)
 convert(1L, to = foo1)
 # Converting too foo2 still errors

---FILE: man/new_property.Rd---
@@ -30,7 +30,7 @@ what should it default to? If \code{NULL}, defaults to the ""empty"" instance
 of \code{class}.}
 
 \item{name}{Property name, primarily used for error messages. Used
-primrarily for testing as it is set automatically when using a list of
+primarily for testing as it is set automatically when using a list of
 properties.}
 }
 \description{

---FILE: man/props.Rd---
@@ -38,6 +38,6 @@ horse <- new_class(""horse"", properties = list(
 lexington <- horse(colour = ""bay"", height = 15, name = ""Lex"")
 
 props(lexington)
-props(lexington) <- list(height = 14, name = ""Lexigonton"")
+props(lexington) <- list(height = 14, name = ""Lexington"")
 lexington
 }

---FILE: vignettes/minutes/2021-05-18.Rmd---
@@ -36,7 +36,7 @@ title: ""Minutes 2021-05-18""
 ### Generic ""interfaces"" (LT)
 
 -   **LT**: need to consider not just generics by themselves, but how they are related.
--   Related to contracts in eiffel, concepts in C++20, \...
+-   Related to contracts in Eiffel, concepts in C++20, \...
 
 ### Message passing OOP (HO)
 

---FILE: vignettes/spec/design.Rmd---
@@ -279,4 +279,4 @@ We would then generate help pages from the index.
 
 The index of installed methods could provide additional benefits, including introspection.
 A generic could prompt the user to load a package if it fails to find an applicable method, while there is an installed, unloaded method available.
-This casd would arise when a method is defined outside of the packages that define the class and generic.
+This case would arise when a method is defined outside of the packages that define the class and generic.

---FILE: vignettes/spec/dispatch.Rmd---
@@ -213,7 +213,7 @@ May also do for `vec_arith()`.
 
 ### S3
 
-When `UseMethod()` recieves an object without a `class` attribute, it uses the **implicit** class, as provided by `.class2()`.
+When `UseMethod()` receives an object without a `class` attribute, it uses the **implicit** class, as provided by `.class2()`.
 This is made up of four rough categories: dimension, type, language, numeric.
 
 ```{r}

---FILE: vignettes/spec/proposal.Rmd---
@@ -56,7 +56,7 @@ contents. The contract extends the contract of the parent class in
 order to add semantics through additional constraints while
 remaining compatible with the parent contract. Code manipulating
 objects will often make assumptions about the structure and content
-of objects. To mitigate risk, such low-level code benfits from a
+of objects. To mitigate risk, such low-level code benefits from a
 validation function, essentially a codification of the class
 contract, to verify its assumptions.
 
@@ -77,7 +77,7 @@ easier to reason about code when we can typically assume that it is
 the receiver being mutated. We exclude from our scope systems with
 mutable objects, because immutable objects are generally preferable
 for interactive data analysis, relegating mutable systems to niche
-applications, such as GUIs and caching mechanims.
+applications, such as GUIs and caching mechanisms.
 
 As appropriate for a statistical computing language, R has
 functional roots, and the most prevalent object-oriented approaches
@@ -96,7 +96,7 @@ object.
 From these considerations, we conclude that a good object-oriented
 system would support:
 * An explicit class hierarchy (represented by reified objects) with
-* Sytematic instance construction and validation;
+* Systematic instance construction and validation;
 * Multiple, at least double, dispatch, and
 * Objects with a transparent, introspectable structure.
 "
RConsortium,S7,3b781a51809092ba03a94fb133738c4c951e941e,Hadley Wickham,h.wickham@gmail.com,2023-07-10T14:40:50Z,GitHub,noreply@github.com,2023-07-10T14:40:50Z,"Add motivation vignette (#293)

Fixes #92",_pkgdown.yml;vignettes/motivation.Rmd,True,False,True,False,75,0,75,"---FILE: _pkgdown.yml---
@@ -43,6 +43,7 @@ articles:
   - generics-methods
   - classes-objects
   - compatibility
+  - motivation
   - performance
 
 - title: Initial design and specification

---FILE: vignettes/motivation.Rmd---
@@ -0,0 +1,74 @@
+---
+title: ""Motivation for S7""
+output: rmarkdown::html_vignette
+vignette: >
+  %\VignetteIndexEntry{Motivation for S7}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+
+```{r, include = FALSE}
+knitr::opts_chunk$set(
+  collapse = TRUE,
+  comment = ""#>""
+)
+```
+
+R already has two OO systems built-in (S3 and S4) and many additional OO systems are available in CRAN packages.
+Why did we decide more work was needed?
+This vignette will discuss some of the motivations behind S7, focussing on the aspects of S3 and S4 that have been found to be particularly challenging in practice.
+
+```{r setup}
+library(S7)
+```
+
+## Challenges with S3
+
+-   S3 is very informal, meaning that there's no formal definition of a class.
+    This makes it impossible to know exactly which properties an object should or could possess, or even what its parent class should be.
+    S7 resolves this problem with a formal definition encoded in a class object produced by `new_class()`.
+    This includes support for validation (and avoiding validation where needed) as inspired by S4.
+
+-   When a new user encounter an S3 generic, they are often confused because the implementation of the function appears to be missing.
+    S7 has a thoughtfully designed print method that makes it clear what methods are available and how to find their source code.
+
+-   Properties of an S3 class are usually stored in attributes, but, by default, `attr()` does partial matching, which can lead to bugs that are hard to diagnose.
+    Additionally, `attr()` returns `NULL` if an attribute doesn't exist, so misspelling an attribute can lead to subtle bugs.
+    `@` fixes both of these problems.
+
+-   S3 method dispatch is complicated for compatibility with S.
+    This complexity affects relatively little code, but when you attempt to dive into the details it makes `UseMethod()` hard to understand.
+    As much as possible, S7 avoids any ""funny"" business with environments or promises, so that there is no distinction between argument values and local values.
+
+-   S3 is primarily designed for single dispatch and double dispatch is only provided for a handful of base generics.
+    It's not possible to reuse the implementation for user generics.
+    S7 provides a standard way of doing multiple dispatch (including double dispatch) that can be used for any generic.
+
+-   `NextMethod()` is unpredictable since you can't tell exactly which method will be called by only reading the code; you instead need to know both the complete class hierarchy and what other methods are currently registered (and loading a package might change those methods).
+    S7 takes a difference approach with `super()`, requiring explicit specification of the superclass to be used.
+
+-   Conversion between S3 classes is only implemented via loose convention: if you implement a class `foo`, then you should also provide generic `as.foo()` to convert other objects to that type.
+    S7 avoids this problem by providing the double-dispatch `convert()` generic so that you only need to provide the appropriate methods.
+
+## Challenges with S4
+
+-   Multiple inheritance seemed like a powerful idea at the time, but in practice it appears to generate more problems than it solves.
+    S7 does not support multiple inheritance.
+
+-   S4's method dispatch uses a principled but complex distance metric to pick the best method in the presence of ambiguity.
+    Time has shown that this approach is hard for people to understand and makes it hard to predict what will happen when new methods are registered.
+    S7 implements a much simpler, greedy, approach that trades some additional work on behalf of the class author for a system that is simpler and easier to understand.
+
+-   S4 is a clean break from S3.
+    This made it possible to make radical changes but it made it harder to switch from S3 to S4, leading to a general lack of adoption in the R community.
+    S7 is designed to be drop-in compatible with S3, making it possible to convert existing packages to use S7 instead of S3 with only an hour or two of work.
+
+```{=html}
+<!-- -->
+```
+-   At least within Bioconductor, slots are generally thought of as implementation detail that should not be directly accessed by the end-user.
+    This leads to two problems.
+    Firstly, implementing an S4 Bioconductor class often also requires a plethora of accessor functions that are a thin wrapper around `@` or `@<-`.
+    Secondly, users know about `@` and use it to access object internals even though they're not supposed to.
+    S7 supports avoids these problems by accepting the fact that R is a data language, and that there's no way to stop users from pulling the data they need out of an object.
+    To make it possible to change the internal implementation details of an object while preserving existing `@` usage, S7 provides dynamic properties."
RConsortium,S7,79557c02028a8db2cf6e6a91d5489e478665529d,Hadley Wickham,h.wickham@gmail.com,2023-05-08T17:16:51Z,GitHub,noreply@github.com,2023-05-08T17:16:51Z,"Subclasses of abstract class can have readonly properties (#288)

Fixes #269",NEWS.md;R/constructor.R;tests/testthat/test-constructor.R,False,True,True,False,10,3,13,"---FILE: NEWS.md---
@@ -2,6 +2,8 @@
 
 ## Jan-May 2023
 
+* Subclasses of abstract class can have readonly properties (#269).
+
 * During construction, validation is now only performed once for each 
   element of the class hierarchy (#248).
 

---FILE: R/constructor.R---
@@ -54,9 +54,9 @@ constructor_args <- function(parent, properties = list()) {
   parent_args <- names2(formals(class_constructor(parent)))
 
   self_args <- names2(properties)
+  # Remove dynamic arguments
+  self_args <- self_args[vlapply(properties, function(x) is.null(x$getter))]
   if (is_class(parent) && !parent@abstract) {
-    # Remove dynamic arguments
-    self_args <- self_args[vlapply(properties, function(x) is.null(x$getter))]
     # Remove any parent properties; can't use parent_args() since the constructor
     # might automatically set some properties.
     self_args <- setdiff(self_args, names2(parent@properties))

---FILE: tests/testthat/test-constructor.R---
@@ -59,7 +59,12 @@ test_that(""can generate constructor for inherited abstract classes"", {
     new_constructor(foo1, as_properties(list(y = class_double)))
   }, transform = scrub_environment)
   child <- new_class(""child"", foo1, properties = list(y = class_double))
-  expect_error(child(y = 0.5), regexp = NA)
+  expect_no_error(child(y = 0.5))
+
+  # even if it has a read-only property
+  prop_readonly <- new_property(getter = function(self) ""test"")
+  child <- new_class(""child"", foo1, properties = list(x = prop_readonly))
+  expect_no_error(child())
 })
 
 test_that(""can use `...` in parent constructor"", {"
RConsortium,S7,076fd6b007b576a8aff0abb88668b5617375c54c,Hadley Wickham,h.wickham@gmail.com,2023-05-08T17:14:36Z,GitHub,noreply@github.com,2023-05-08T17:14:36Z,"Avoid repeated re-validation during construction (#291)

Fixes #248",NEWS.md;R/class.R;R/valid.R;man/validate.Rd;tests/testthat/_snaps/class.md;tests/testthat/test-class.R,False,True,True,False,38,4,42,"---FILE: NEWS.md---
@@ -2,6 +2,9 @@
 
 ## Jan-May 2023
 
+* During construction, validation is now only performed once for each 
+  element of the class hierarchy (#248).
+
 * Implemented a better filtering strategy for the S4 class hierarchy so
   you can now correctly dispatch on virtual classes (#252).
 

---FILE: R/class.R---
@@ -254,7 +254,8 @@ new_object <- function(.parent, ...) {
   for (nme in nms) {
     prop(object, nme, check = FALSE) <- args[[nme]]
   }
-  validate(object)
+  # Only needs to validate this object if parent was already an S7 object
+  validate(object, recursive = !inherits(.parent, ""S7_object""))
 
   object
 }

---FILE: R/valid.R---
@@ -16,6 +16,7 @@
 #' you are certain a sequence of operations cannot produce an invalid object.
 #' @param object An S7 object
 #' @param fun A function to call on the object before validation.
+#' @param recursive If `TRUE`, calls validator of parent classes recursively.
 #' @param properties If `TRUE`, the default, checks property types before
 #'   executing the validator.
 #' @export
@@ -60,7 +61,7 @@
 #'   r
 #' }
 #' rightwards(r, 20)
-validate <- function(object, properties = TRUE) {
+validate <- function(object, recursive = TRUE, properties = TRUE) {
   check_is_S7(object)
 
   if (!is.null(attr(object, "".should_validate""))) {
@@ -84,7 +85,7 @@ validate <- function(object, properties = TRUE) {
   errors <- character()
   repeat({
     errors <- c(errors, class_validate(class, object))
-    if (!is_class(class)) break
+    if (!is_class(class) || !recursive) break
     class <- class@parent
   })
 

---FILE: man/validate.Rd---
@@ -6,7 +6,7 @@
 \alias{valid_implicitly}
 \title{Validate an S7 object}
 \usage{
-validate(object, properties = TRUE)
+validate(object, recursive = TRUE, properties = TRUE)
 
 valid_eventually(object, fun)
 
@@ -15,6 +15,8 @@ valid_implicitly(object, fun)
 \arguments{
 \item{object}{An S7 object}
 
+\item{recursive}{If \code{TRUE}, calls validator of parent classes recursively.}
+
 \item{properties}{If \code{TRUE}, the default, checks property types before
 executing the validator.}
 

---FILE: tests/testthat/_snaps/class.md---
@@ -119,6 +119,21 @@
       <foo> object is invalid:
       - x must be positive
 
+# new_object(): runs each parent validator exactly once
+
+    Code
+      . <- A()
+    Output
+      A 
+    Code
+      . <- B()
+    Output
+      A B 
+    Code
+      . <- C()
+    Output
+      A B C 
+
 # S7 object: displays nicely
 
     Code

---FILE: tests/testthat/test-class.R---
@@ -102,6 +102,18 @@ describe(""new_object()"", {
       foo(-1)
     })
   })
+
+  it(""runs each parent validator exactly once"", {
+    A <- new_class(""A"", validator = function(self) cat(""A ""))
+    B <- new_class(""B"", parent = A, validator = function(self) cat(""B ""))
+    C <- new_class(""C"", parent = B, validator = function(self) cat(""C ""))
+
+    expect_snapshot({
+      . <- A()
+      . <- B()
+      . <- C()
+    })
+  })
 })
 
 describe(""S7 object"", {"
RConsortium,S7,ce9e7bf5444aadda40f1dfbec60a0aa4fcbe7539,Hadley Wickham,h.wickham@gmail.com,2023-05-08T17:12:38Z,GitHub,noreply@github.com,2023-05-08T17:12:38Z,"Better filtering strategy for S4 class hierarchy (#292)

Fixes #252",NEWS.md;R/S4.R;tests/testthat/test-S4.R,False,True,True,False,17,3,20,"---FILE: NEWS.md---
@@ -2,6 +2,9 @@
 
 ## Jan-May 2023
 
+* Implemented a better filtering strategy for the S4 class hierarchy so
+  you can now correctly dispatch on virtual classes (#252).
+
 * New `set_props()` to make a modified copy of an object (#229).
 
 * `R CMD check` now passes on R 3.5 and greater (for tidyverse 

---FILE: R/S4.R---
@@ -78,9 +78,10 @@ S4_class_dispatch <- function(x) {
   extends <- Filter(function(x) methods::is(x, ""SClassExtension""), extends)
   classes <- lapply(extends, function(x) methods::getClass(x@superClass))
 
-  # Remove virtual classes that aren't S3. This removes unions because S7
-  # handles them in method registration, not dispatch.
-  classes <- Filter(function(x) !x@virtual || is_oldClass(x), classes)
+  # Remove unions: S7 handles them in method registration, not dispatch.
+  classes <- Filter(function(x) !methods::is(x, ""ClassUnionRepresentation""), classes)
+  # Remove specially named union base classes
+  classes <- Filter(function(x) !x@className %in% c(""oldClass"", ""vector""), classes)
 
   c(self, vcapply(classes, S4_class_name))
 }

---FILE: tests/testthat/test-S4.R---
@@ -93,6 +93,16 @@ describe(""S4_class_dispatch"", {
     expect_equal(S4_class_dispatch(""Foo2""), ""S4/Foo2"")
   })
 
+  it(""includes virtual classes"", {
+    on.exit(S4_remove_classes(c(""Foo1"", ""Foo2"")))
+
+    setClass(""Foo1"", where = globalenv())
+    setClass(""Foo2"", contains = ""Foo1"", where = globalenv())
+
+    expect_equal(S4_class_dispatch(""Foo1""), ""S4/Foo1"")
+    expect_equal(S4_class_dispatch(""Foo2""), c(""S4/Foo2"", ""S4/Foo1""))
+  })
+
   it(""captures explicit package name"", {
     on.exit(S4_remove_classes(""Foo1""))
     setClass(""Foo1"", package = ""pkg"", where = globalenv())"
RConsortium,S7,cd75f386c9d27ff7f5438e165b78351c444d7db6,Hadley Wickham,h.wickham@gmail.com,2023-05-08T17:09:20Z,GitHub,noreply@github.com,2023-05-08T17:09:20Z,"Implement set_props() (#296)

Fixes #229",NAMESPACE;NEWS.md;R/property.R;man/props.Rd;tests/testthat/test-property.R,False,True,True,False,34,3,37,"---FILE: NAMESPACE---
@@ -77,6 +77,7 @@ export(prop)
 export(prop_exists)
 export(prop_names)
 export(props)
+export(set_props)
 export(super)
 export(valid_eventually)
 export(valid_implicitly)

---FILE: NEWS.md---
@@ -1,6 +1,8 @@
 # S7 0.0.0.9000
 
-## March 2023
+## Jan-May 2023
+
+* New `set_props()` to make a modified copy of an object (#229).
 
 * `R CMD check` now passes on R 3.5 and greater (for tidyverse 
   compatibility).

---FILE: R/property.R---
@@ -291,7 +291,10 @@ prop_exists <- function(object, name) {
 #' Get/set multiple properties
 #'
 #' - `props(x)` returns all properties.
-#' - `props(x) <- list(name1 = val1, name2 = val2)` sets multiple properties.
+#' - `props(x) <- list(name1 = val1, name2 = val2)` modifies an existing object
+#'   by setting multiple properties simultaneously.
+#' - `set_props(x, name1 = val1, name2 = val2)` creates a copy of an existing
+#'   object with new values for the specified properties.
 #'
 #' @importFrom stats setNames
 #' @inheritParams prop
@@ -332,6 +335,14 @@ props <- function(object) {
   object
 }
 
+#' @export
+#' @param ... Name-value pairs given property to modify and new value.
+#' @rdname props
+set_props <- function(object, ...) {
+  props(object) <- list(...)
+  object
+}
+
 as_properties <- function(x) {
   if (length(x) == 0) {
     return(list())

---FILE: man/props.Rd---
@@ -3,22 +3,30 @@
 \name{props}
 \alias{props}
 \alias{props<-}
+\alias{set_props}
 \title{Get/set multiple properties}
 \usage{
 props(object)
 
 props(object) <- value
+
+set_props(object, ...)
 }
 \arguments{
 \item{object}{An object from a S7 class}
 
 \item{value}{A named list of values. The object is checked for validity
 only after all replacements are performed.}
+
+\item{...}{Name-value pairs given property to modify and new value.}
 }
 \description{
 \itemize{
 \item \code{props(x)} returns all properties.
-\item \code{props(x) <- list(name1 = val1, name2 = val2)} sets multiple properties.
+\item \code{props(x) <- list(name1 = val1, name2 = val2)} modifies an existing object
+by setting multiple properties simultaneously.
+\item \code{set_props(x, name1 = val1, name2 = val2)} creates a copy of an existing
+object with new values for the specified properties.
 }
 }
 \examples{

---FILE: tests/testthat/test-property.R---
@@ -100,6 +100,15 @@ describe(""props<-"", {
     expect_equal(obj@x, 5)
     expect_equal(obj@y, 10)
   })
+
+  it(""has ordinary syntax in set_props()"", {
+    foo <- new_class(""foo"", properties = list(x = class_double))
+    obj1 <- foo(1)
+    obj2 <- set_props(obj1, x = 2)
+
+    expect_equal(obj1@x, 1)
+    expect_equal(obj2@x, 2)
+  })
 })
 
 describe(""property access"", {"
RConsortium,S7,6c0460cf410eced12046fa24287415aaefa5de81,Hadley Wickham,h.wickham@gmail.com,2023-05-08T16:47:03Z,GitHub,noreply@github.com,2023-05-08T16:47:03Z,"Reorganise vignettes (#295)

* Tweak overall vignette layout. Pulling out class + object details into a new vignette
* Briefly discuss custom constructors. Fixes #245
* Cross-reference vignettes",R/class.R;R/generic.R;README.Rmd;README.md;_pkgdown.yml;man/new_class.Rd;man/new_generic.Rd;vignettes/S7.Rmd;vignettes/classes-objects.Rmd;vignettes/compatibility.Rmd;vignettes/generics-methods.Rmd,True,True,True,False,298,289,587,"---FILE: R/class.R---
@@ -1,9 +1,12 @@
 #' Define a new S7 class
 #'
+#' @description
 #' A class specifies the properties (data) that each of its objects will
 #' possess. The class, and its parent, determines which method will be used
 #' when an object is passed to a generic.
 #'
+#' Learn more in `vignette(""classes-objects"")`
+#'
 #' @param name The name of the class, as a string. The result of calling
 #'   `new_class()` should always be assigned to a variable with this name,
 #'   i.e. `foo <- new_class(""foo"")`.
@@ -20,11 +23,13 @@
 #'   classes. If you see `package`, you _must_ export the constructor.
 #' @param abstract Is this an abstract class? An abstract class can not be
 #'   instantiated.
-#' @param constructor The constructor function. Advanced use only.
+#' @param constructor The constructor function. In most cases, you can rely
+#'   on the default constructor, which will generate a function with one
+#'   argument for each property.
 #'
 #'   A custom constructor should call `new_object()` to create the S7 object.
-#'   The first argument, `.data`, should be an instance of the parent class. The
-#'   subsequent arguments are used to set the properties.
+#'   The first argument, `.data`, should be an instance of the parent class
+#'   (if used). The subsequent arguments are used to set the properties.
 #' @param validator A function taking a single argument, `self`, the object
 #'   to validate.
 #'

---FILE: R/generic.R---
@@ -9,6 +9,8 @@
 #' included in the body of the generic, but in most cases `new_generic()` will
 #' generate this for you.
 #'
+#' Learn more in `vignette(""generics-methods"")`
+#'
 #' @section Dispatch arguments:
 #' The arguments that are used to pick the method are called the **dispatch
 #' arguments**. In most cases, this will be one argument, in which case the

---FILE: README.Rmd---
@@ -37,7 +37,7 @@ remotes::install_github(""rconsortium/OOP-WG"")
 ## Usage
 
 This section gives a very brief overview of the entirety of S7.
-Learn more of the basics in `vignette(""S7"")`, the details of method dispatch in `vignette(""dispatch"")`, and compatibility with S3 and S4 in `vignette(""compatibility"")`.
+Learn more of the basics in `vignette(""S7"")`, generics and methods in `vignette(""generics-methods"")`, classes and objects in` vigentte(""classes-objects')`, and compatibility with S3 and S4 in `vignette(""compatibility"")`.
 
 ```{r}
 library(S7)
@@ -101,10 +101,7 @@ The third, and optional argument, supplies the body of the generic.
 This is only needed if your generic has additional arguments that aren't used for method dispatch.
 
 ```{r}
-inside <- new_generic(""inside"", ""x"", function(x, y) {
-  # Actually finds and calls the appropriate method
-  S7_dispatch()
-})
+inside <- new_generic(""inside"", ""x"")
 ```
 
 Once you have a generic, you can define a method for a specific class with `method<-`:
@@ -114,29 +111,8 @@ Once you have a generic, you can define a method for a specific class with `meth
 method(inside, range) <- function(x, y) {
   y >= x@start & y <= x@end
 }
-inside
 
 inside(x, c(0, 5, 10, 15))
 ```
 
-You can use `method<-` to register methods for base types on S7 generics:
-
-```{r}
-method(inside, class_numeric) <- function(x, y) {
-  y >= min(x) & y <= max(x)
-}
-```
-
-And register methods for S7 classes on S3 or S4 generics:
-
-```{r}
-method(format, range) <- function(x, ...) {
-  paste0(""["", x@start, "", "", x@end, ""]"")
-}
-format(x)
-
-method(mean, range) <- function(x, ...) {
-  (x@start + x@end) / 2
-}
-mean(x)
-```
+You can use `method<-` to register methods for base types on S7 generics, and S7 classes on S3 or S4 generics. See `vignette(""compatibility"")` for more details.

---FILE: README.md---
@@ -7,7 +7,7 @@
 
 [![R-CMD-check](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/RConsortium/OOP-WG/actions/workflows/R-CMD-check.yaml)
 [![Codecov test
-coverage](https://codecov.io/gh/RConsortium/OOP-WG/branch/master/graph/badge.svg)](https://codecov.io/gh/RConsortium/OOP-WG?branch=master)
+coverage](https://app.codecov.io/gh/RConsortium/OOP-WG/branch/master/graph/badge.svg)](https://app.codecov.io/gh/RConsortium/OOP-WG?branch=master)
 
 <!-- badges: end -->
 
@@ -30,8 +30,9 @@ remotes::install_github(""rconsortium/OOP-WG"")
 ## Usage
 
 This section gives a very brief overview of the entirety of S7. Learn
-more of the basics in `vignette(""S7"")`, the details of method dispatch
-in `vignette(""dispatch"")`, and compatibility with S3 and S4 in
+more of the basics in `vignette(""S7"")`, generics and methods in
+`vignette(""generics-methods"")`, classes and objects
+in`vigentte(""classes-objects')`, and compatibility with S3 and S4 in
 `vignette(""compatibility"")`.
 
 ``` r
@@ -113,10 +114,7 @@ of the generic. This is only needed if your generic has additional
 arguments that aren’t used for method dispatch.
 
 ``` r
-inside <- new_generic(""inside"", ""x"", function(x, y) {
-  # Actually finds and calls the appropriate method
-  S7_dispatch()
-})
+inside <- new_generic(""inside"", ""x"")
 ```
 
 Once you have a generic, you can define a method for a specific class
@@ -127,35 +125,11 @@ with `method<-`:
 method(inside, range) <- function(x, y) {
   y >= x@start & y <= x@end
 }
-inside
-#> <S7_generic> function (x, y)  with 1 methods:
-#> 1: method(inside, range)
 
 inside(x, c(0, 5, 10, 15))
 #> [1] FALSE  TRUE  TRUE  TRUE
 ```
 
 You can use `method<-` to register methods for base types on S7
-generics:
-
-``` r
-method(inside, class_numeric) <- function(x, y) {
-  min(x) <= y & y <= max(x)
-}
-```
-
-And register methods for S7 classes on S3 or S4 generics:
-
-``` r
-method(format, range) <- function(x, ...) {
-  paste0(""["", x@start, "", "", x@end, ""]"")
-}
-format(x)
-#> [1] ""[1, 20]""
-
-method(mean, range) <- function(x, ...) {
-  (x@start + x@end) / 2
-}
-mean(x)
-#> [1] 10.5
-```
+generics, and S7 classes on S3 or S4 generics. See
+`vignette(""compatibility"")` for more details.

---FILE: _pkgdown.yml---
@@ -40,7 +40,8 @@ articles:
   navbar: ~
   contents:
   - S7
-  - dispatch
+  - generics-methods
+  - classes-objects
   - compatibility
   - performance
 

---FILE: man/new_class.Rd---
@@ -44,11 +44,13 @@ full property specification created \code{\link[=new_property]{new_property()}}.
 \item{abstract}{Is this an abstract class? An abstract class can not be
 instantiated.}
 
-\item{constructor}{The constructor function. Advanced use only.
+\item{constructor}{The constructor function. In most cases, you can rely
+on the default constructor, which will generate a function with one
+argument for each property.
 
 A custom constructor should call \code{new_object()} to create the S7 object.
-The first argument, \code{.data}, should be an instance of the parent class. The
-subsequent arguments are used to set the properties.}
+The first argument, \code{.data}, should be an instance of the parent class
+(if used). The subsequent arguments are used to set the properties.}
 
 \item{validator}{A function taking a single argument, \code{self}, the object
 to validate.
@@ -79,6 +81,8 @@ of the given class.
 A class specifies the properties (data) that each of its objects will
 possess. The class, and its parent, determines which method will be used
 when an object is passed to a generic.
+
+Learn more in \code{vignette(""classes-objects"")}
 }
 \examples{
 # Create an class that represents a range using a numeric start and end

---FILE: man/new_generic.Rd---
@@ -33,6 +33,8 @@ with \code{new_generic()} then use \link{method<-} to add methods to it.
 Method dispatch is performed by \code{S7_dispatch()}, which must always be
 included in the body of the generic, but in most cases \code{new_generic()} will
 generate this for you.
+
+Learn more in \code{vignette(""generics-methods"")}
 }
 \section{Dispatch arguments}{
 

---FILE: vignettes/S7.Rmd---
@@ -17,17 +17,13 @@ knitr::opts_chunk$set(
 The S7 package provides a new OOP system designed to be a successor to S3 and S4.
 It has been designed and implemented collaboratively by the RConsortium Object-Oriented Programming Working Group, which includes representatives from R-Core, BioConductor, RStudio/tidyverse, and the wider R community.
 
-This vignette describes how S7 works, starting with an overview of classes, objects, generics, and methods, then going into the details of validation and properties.
+This vignette gives an overview of the most important parts of S7: classes and objects, generics and methods, and the basics of method dispatch and inheritance.
 
 ```{r setup}
 library(S7)
 ```
 
-## Basics
-
-We'll start with an quick overview of the most important parts of S7: classes and objects, generics and methods, and the basics of method dispatch and inheritance.
-
-### Classes and objects
+## Classes and objects
 
 S7 classes have a formal definition that you create with `new_class()`.
 There are two arguments that you'll use with almost every class:
@@ -83,7 +79,9 @@ This is used for compatibility with existing S3 generics and you can learn more
 class(lola)
 ```
 
-### Generics and methods
+If you want to learn more about the details of S7 classes and objects, including validation methods and more details of properties, please see `vignette(""classes-objects"")`.
+
+## Generics and methods
 
 S7, like S3 and S4, is built around the idea of **generic functions,** or **generics** for short.
 A generic defines an interface, which uses a different implementation depending on the class of one or more arguments.
@@ -133,7 +131,7 @@ You get an error if you call the generic with a class that doesn't have a method
 speak(1)
 ```
 
-### Method dispatch and inheritance
+## Method dispatch and inheritance
 
 The `cat` and `dog` classes share the same properties, so we could use a common parent class to extract out the duplicated specification.
 We first define the parent class:
@@ -210,196 +208,4 @@ And you can use `method()` to retrieve the implementation of one of those method
 method(describe, pet)
 ```
 
-Learn more about method dispatch in `vignette(""dispatch"")`.
-
-## Validation
-
-S7 classes can have an optional **validator** that checks that the values of the properties are OK.
-A validator is a function that takes the object (called `self`) and returns `NULL` if its valid or returns a character vector listing the problems.
-
-### Basics
-
-In the following example we create a range class that enforces that `@start` and `@end` are single numbers, and that `@start` is less than `@end`:
-
-```{r}
-range <- new_class(""range"",
-  properties = list(
-    start = class_double,
-    end = class_double
-  ),
-  validator = function(self) {
-    if (length(self@start) != 1) {
-      ""@start must be length 1""
-    } else if (length(self@end) != 1) {
-      ""@end must be length 1""
-    } else if (self@end < self@start) {
-      sprintf(
-        ""@end (%i) must be greater than or equal to @start (%i)"",
-        self@end,
-        self@start
-      )
-    }
-  }
-)
-```
-
-You can typically write a validator as a series of `if`-`else` statements, but note that the order of the statements is important.
-For example, in the code above, we can't check that `self@end < self@start` before we've checked that `@start` and `@end` are length 1.
-
-### When is validation performed?
-
-Objects are validated automatically when constructed and when any property is modified:
-
-```{r, error = TRUE}
-x <- range(1, 2:3)
-x <- range(10, 1)
-
-x <- range(1, 10)
-x@start <- 20
-```
-
-You can also manually `validate()` an object if you use a low-level R function to bypass the usual checks and balances of `@`:
-
-```{r, error = TRUE}
-x <- range(1, 2)
-attr(x, ""start"") <- 3
-validate(x)
-```
-
-### Avoiding validation
-
-Imagine you wanted to write a function that would shift a property to the left or the right:
-
-```{r}
-shift <- function(x, shift) {
-  x@start <- x@start + shift
-  x@end <- x@end + shift
-  x
-}
-shift(range(1, 10), 1)
-```
-
-There's a problem if `shift` is larger than `@end` - `@start`:
-
-```{r, error = TRUE}
-shift(range(1, 10), 10)
-```
-
-While the end result of `shift()` will be valid, an intermediate state is not.
-The easiest way to resolve this problem is to set the properties all at once:
-
-```{r}
-shift <- function(x, shift) {
-  props(x) <- list(
-    start = x@start + shift,
-    end = x@end + shift
-  )
-  x
-}
-shift(range(1, 10), 10)
-```
-
-The object is still validated, but it's only validated once, after all the properties have been modified.
-
-## Properties
-
-So far we've focused on the simplest form of property specification where you use a named list to supply the desired type for each property.
-This is a convenient shorthand for a call to `new_property()`.
-For example, the property definition of range above is shorthand for:
-
-```{r}
-range <- new_class(""range"",
-  properties = list(
-    start = new_property(class_double),
-    end = new_property(class_double)
-  )
-)
-```
-
-Calling `new_property()` explicitly allows you to control aspects of the property other than its type.
-The following sections show you how to provide a default value, compute the property value on demand, or provide a fully dynamic property.
-
-### Default value
-
-The defaults of `new_class()` create an class that can be constructed with no arguments:
-
-```{r}
-empty <- new_class(""empty"",
-  properties = list(
-    x = class_double,
-    y = class_character,
-    z = class_logical
-  ))
-empty()
-```
-
-The default values of the properties will be filled in with ""empty"" instances.
-You can instead provide your own defaults by using the `default` argument:
-
-```{r}
-empty <- new_class(""empty"",
-  properties = list(
-    x = new_property(class_numeric, default = 0),
-    y = new_property(class_character, default = """"),
-    z = new_property(class_logical, default = NA)
-  )
-)
-empty()
-```
-
-### Computed properties
-
-It's sometimes useful to have a property that is computed on demand.
-For example, it'd be convenient to pretend that our range has a length, which is just the distance between `@start` and `@end`.
-You can dynamically compute the value of a property by defining a `getter`:
-
-```{r}
-range <- new_class(""range"",
-  properties = list(
-    start = class_double,
-    end = class_double,
-    length = new_property(
-      getter = function(self) self@end - self@start,
-    )
-  )
-)
-
-x <- range(start = 1, end = 10)
-x
-```
-
-Computed properties are read-only:
-
-```{r, error = TRUE}
-x@length <- 20
-```
-
-### Dynamic properties
-
-You can make a computed property fully dynamic so that it can be read and written by also supplying a `setter`.
-For example, we could extend the previous example to allow the `@length` to be set, by modifying the `@end` of the vector:
-
-```{r}
-range <- new_class(""range"",
-  properties = list(
-    start = class_double,
-    end = class_double,
-    length = new_property(
-      class = class_double,
-      getter = function(self) self@end - self@start,
-      setter = function(self, value) {
-        self@end <- self@start + value
-        self
-      }
-    )
-  )
-)
-
-x <- range(start = 1, end = 10)
-x
-
-x@length <- 5
-x
-```
-
-A `setter` is a function with arguments `self` and `value` that returns a modified object.
+Learn more about method dispatch in `vignette(""generics-methods"")`.

---FILE: vignettes/classes-objects.Rmd---
@@ -0,0 +1,241 @@
+---
+title: ""Classes and objects""
+output: rmarkdown::html_vignette
+vignette: >
+  %\VignetteIndexEntry{Classes and objects}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+
+```{r, include = FALSE}
+knitr::opts_chunk$set(
+  collapse = TRUE,
+  comment = ""#>""
+)
+```
+
+This vignette dives into the details of S7 classes and objects, building on the basics discussed in `vignette(""S7"")`. It will cover validators, the finer details of properties, and finally how to write your own constructors.
+
+```{r setup}
+library(S7)
+```
+
+## Validation
+
+S7 classes can have an optional **validator** that checks that the values of the properties are OK.
+A validator is a function that takes the object (called `self`) and returns `NULL` if its valid or returns a character vector listing the problems.
+
+### Basics
+
+In the following example we create a range class that enforces that `@start` and `@end` are single numbers, and that `@start` is less than `@end`:
+
+```{r}
+range <- new_class(""range"",
+  properties = list(
+    start = class_double,
+    end = class_double
+  ),
+  validator = function(self) {
+    if (length(self@start) != 1) {
+      ""@start must be length 1""
+    } else if (length(self@end) != 1) {
+      ""@end must be length 1""
+    } else if (self@end < self@start) {
+      sprintf(
+        ""@end (%i) must be greater than or equal to @start (%i)"",
+        self@end,
+        self@start
+      )
+    }
+  }
+)
+```
+
+You can typically write a validator as a series of `if`-`else` statements, but note that the order of the statements is important.
+For example, in the code above, we can't check that `self@end < self@start` before we've checked that `@start` and `@end` are length 1.
+
+### When is validation performed?
+
+Objects are validated automatically when constructed and when any property is modified:
+
+```{r, error = TRUE}
+x <- range(1, 2:3)
+x <- range(10, 1)
+
+x <- range(1, 10)
+x@start <- 20
+```
+
+You can also manually `validate()` an object if you use a low-level R function to bypass the usual checks and balances of `@`:
+
+```{r, error = TRUE}
+x <- range(1, 2)
+attr(x, ""start"") <- 3
+validate(x)
+```
+
+### Avoiding validation
+
+Imagine you wanted to write a function that would shift a property to the left or the right:
+
+```{r}
+shift <- function(x, shift) {
+  x@start <- x@start + shift
+  x@end <- x@end + shift
+  x
+}
+shift(range(1, 10), 1)
+```
+
+There's a problem if `shift` is larger than `@end` - `@start`:
+
+```{r, error = TRUE}
+shift(range(1, 10), 10)
+```
+
+While the end result of `shift()` will be valid, an intermediate state is not.
+The easiest way to resolve this problem is to set the properties all at once:
+
+```{r}
+shift <- function(x, shift) {
+  props(x) <- list(
+    start = x@start + shift,
+    end = x@end + shift
+  )
+  x
+}
+shift(range(1, 10), 10)
+```
+
+The object is still validated, but it's only validated once, after all the properties have been modified.
+
+## Properties
+
+So far we've focused on the simplest form of property specification where you use a named list to supply the desired type for each property.
+This is a convenient shorthand for a call to `new_property()`.
+For example, the property definition of range above is shorthand for:
+
+```{r}
+range <- new_class(""range"",
+  properties = list(
+    start = new_property(class_double),
+    end = new_property(class_double)
+  )
+)
+```
+
+Calling `new_property()` explicitly allows you to control aspects of the property other than its type.
+The following sections show you how to provide a default value, compute the property value on demand, or provide a fully dynamic property.
+
+### Default value
+
+The defaults of `new_class()` create an class that can be constructed with no arguments:
+
+```{r}
+empty <- new_class(""empty"",
+  properties = list(
+    x = class_double,
+    y = class_character,
+    z = class_logical
+  ))
+empty()
+```
+
+The default values of the properties will be filled in with ""empty"" instances.
+You can instead provide your own defaults by using the `default` argument:
+
+```{r}
+empty <- new_class(""empty"",
+  properties = list(
+    x = new_property(class_numeric, default = 0),
+    y = new_property(class_character, default = """"),
+    z = new_property(class_logical, default = NA)
+  )
+)
+empty()
+```
+
+### Computed properties
+
+It's sometimes useful to have a property that is computed on demand.
+For example, it'd be convenient to pretend that our range has a length, which is just the distance between `@start` and `@end`.
+You can dynamically compute the value of a property by defining a `getter`:
+
+```{r}
+range <- new_class(""range"",
+  properties = list(
+    start = class_double,
+    end = class_double,
+    length = new_property(
+      getter = function(self) self@end - self@start,
+    )
+  )
+)
+
+x <- range(start = 1, end = 10)
+x
+```
+
+Computed properties are read-only:
+
+```{r, error = TRUE}
+x@length <- 20
+```
+
+### Dynamic properties
+
+You can make a computed property fully dynamic so that it can be read and written by also supplying a `setter`.
+For example, we could extend the previous example to allow the `@length` to be set, by modifying the `@end` of the vector:
+
+```{r}
+range <- new_class(""range"",
+  properties = list(
+    start = class_double,
+    end = class_double,
+    length = new_property(
+      class = class_double,
+      getter = function(self) self@end - self@start,
+      setter = function(self, value) {
+        self@end <- self@start + value
+        self
+      }
+    )
+  )
+)
+
+x <- range(start = 1, end = 10)
+x
+
+x@length <- 5
+x
+```
+
+A `setter` is a function with arguments `self` and `value` that returns a modified object.
+
+## Constructors
+
+You can see the source code for a class's constructor by accessing the `constructor` property:
+
+```{r}
+range@constructor
+```
+
+In most cases, S7's default constructor will all you need. However, in some cases you might want something custom. For example, for our range class, maybe we'd like to construct it from a vector of numeric values, automatically computing the min and the max. To implement this we could do:
+
+```{r}
+range <- new_class(""range"",
+  properties = list(
+    start = class_numeric,
+    end = class_numeric
+  ),
+  constructor = function(x) {
+    new_object(NULL, start = min(x, na.rm = TRUE), end = max(x, na.rm = TRUE))
+  }
+)
+
+range(c(10, 5, 0, 2, 5, 7))
+```
+
+A constructor must always end with a call to `new_object()`. The first argument to `new_object()` should be an object of the `parent` class, or `NULL`, if there's no parent (as here). That argument should be followed by one named argument for each property.
+
+There's one drawback of custom constructors that you should be aware: any subclass will also require a custom constructor.

---FILE: vignettes/compatibility.Rmd---
@@ -154,32 +154,30 @@ foo
 
 S7 unions allow you to restrict the type of a property in the same way that S4 unions allow you to restrict the type of a slot.
 
-
 ## Using S7 in a package
 
-If you are using S7 in a package _and_ you want your package to maintain
-compatibility with R versions prior to 4.3.0, there are a few things to be aware of.
+If you are using S7 in a package *and* you want your package to maintain compatibility with R versions prior to 4.3.0, there are a few things to be aware of.
 
 #### `@`
 
 `` base::`@` `` in R versions prior to R 4.3.0 does not resolve R7 properties.
 
 Workarounds:
 
--  Use `S7::prop()` instead of `@`.
--  Alternatively, make an S7-aware `@` available to your package with 
-   a custom `NAMESPACE` directive and `.onAttach()` like this:
-
-   ``` r
-   # enable usage of <S7_object>@name in package code
-   #' @rawNamespace if (getRversion() < ""4.3.0"") importFrom(""S7"", ""@"")
-   NULL
-
-   # enable usage of <S7_object>@name in user code
-   # e.g. if you also want users to be able to access properties
-   # of objects your package
-   .onAttach <- function(libname, pkgname) {
-     if (getRversion() < ""4.3.0"")
-       require(S7)
-   }
-   ```
+-   Use `S7::prop()` instead of `@`.
+
+-   Alternatively, make an S7-aware `@` available to your package with a custom `NAMESPACE` directive and `.onAttach()` like this:
+
+    ``` r
+    # enable usage of <S7_object>@name in package code
+    #' @rawNamespace if (getRversion() < ""4.3.0"") importFrom(""S7"", ""@"")
+    NULL
+
+    # enable usage of <S7_object>@name in user code
+    # e.g. if you also want users to be able to access properties
+    # of objects your package
+    .onAttach <- function(libname, pkgname) {
+      if (getRversion() < ""4.3.0"")
+        require(S7)
+    }
+    ```

---FILE: vignettes/generics-methods.Rmd---
@@ -1,5 +1,5 @@
 ---
-title: ""S7 generics and method dispatch""
+title: ""Generics and methods""
 output: rmarkdown::html_vignette
 vignette: >
   %\VignetteIndexEntry{S7 generics and method dispatch}"
RConsortium,S7,32746c7fa1a6587d34526bb2ca84ddfddb6ed0c1,Hadley Wickham,h.wickham@gmail.com,2023-04-20T18:28:31Z,GitHub,noreply@github.com,2023-04-20T18:28:31Z,"Check on more versions (#301)

* Update actions
* Check on more versions
* Backport `deparse1()` and `list2DF()`
* Register `|` method dynamically. To avoid pointer comparison issue in R 4.0 and earlier.",.github/workflows/R-CMD-check.yaml;.github/workflows/pkgdown.yaml;.github/workflows/test-coverage.yaml;DESCRIPTION;NAMESPACE;NEWS.md;R/union.R;R/utils.R;R/zzz.R,False,True,True,False,79,28,107,"---FILE: .github/workflows/R-CMD-check.yaml---
@@ -5,7 +5,6 @@
 # check-standard.yaml is likely a better choice.
 # usethis::use_github_action(""check-standard"") will install it.
 on:
-  workflow_dispatch:
   push:
     branches: [main, master]
   pull_request:
@@ -23,18 +22,27 @@ jobs:
       fail-fast: false
       matrix:
         config:
-          - {os: macOS-latest,   r: 'release'}
+          - {os: macos-latest,   r: 'release'}
+
           - {os: windows-latest, r: 'release'}
-          - {os: ubuntu-latest,  r: 'devel', http-user-agent: 'release'}
-          - {os: ubuntu-latest,  r: 'release'}
-          - {os: ubuntu-latest,  r: 'oldrel-1'}
+          # Use 3.6 to trigger usage of RTools35
+          - {os: windows-latest, r: '3.6'}
+          # use 4.1 to check with rtools40's older compiler
+          - {os: windows-latest, r: '4.1'}
+
+          - {os: ubuntu-latest,   r: 'devel', http-user-agent: 'release'}
+          - {os: ubuntu-latest,   r: 'release'}
+          - {os: ubuntu-latest,   r: 'oldrel-1'}
+          - {os: ubuntu-latest,   r: 'oldrel-2'}
+          - {os: ubuntu-latest,   r: 'oldrel-3'}
+          - {os: ubuntu-latest,   r: 'oldrel-4'}
 
     env:
       GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
       R_KEEP_PKG_SOURCE: yes
 
     steps:
-      - uses: actions/checkout@v2
+      - uses: actions/checkout@v3
 
       - uses: r-lib/actions/setup-pandoc@v2
 

---FILE: .github/workflows/pkgdown.yaml---
@@ -20,7 +20,7 @@ jobs:
     env:
       GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
     steps:
-      - uses: actions/checkout@v2
+      - uses: actions/checkout@v3
 
       - uses: r-lib/actions/setup-pandoc@v2
 
@@ -39,7 +39,7 @@ jobs:
 
       - name: Deploy to GitHub pages 🚀
         if: github.event_name != 'pull_request'
-        uses: JamesIves/github-pages-deploy-action@4.1.4
+        uses: JamesIves/github-pages-deploy-action@v4.4.1
         with:
           clean: false
           branch: gh-pages

---FILE: .github/workflows/test-coverage.yaml---
@@ -15,7 +15,7 @@ jobs:
       GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
 
     steps:
-      - uses: actions/checkout@v2
+      - uses: actions/checkout@v3
 
       - uses: r-lib/actions/setup-r@v2
         with:
@@ -27,5 +27,24 @@ jobs:
           needs: coverage
 
       - name: Test coverage
-        run: covr::codecov(quiet = FALSE)
+        run: |
+          covr::codecov(
+            quiet = FALSE,
+            clean = FALSE,
+            install_path = file.path(Sys.getenv(""RUNNER_TEMP""), ""package"")
+          )
         shell: Rscript {0}
+
+      - name: Show testthat output
+        if: always()
+        run: |
+          ## --------------------------------------------------------------------
+          find ${{ runner.temp }}/package -name 'testthat.Rout*' -exec cat '{}' \; || true
+        shell: bash
+
+      - name: Upload test results
+        if: failure()
+        uses: actions/upload-artifact@v3
+        with:
+          name: coverage-test-failures
+          path: ${{ runner.temp }}/package

---FILE: DESCRIPTION---
@@ -35,6 +35,8 @@ Description: Prototype implementation of an extension to S3 that
     Represents the output of the Object-oriented Programming Working
     Group, sponsored by the R Consortium.
 License: MIT + file LICENSE
+Depends: 
+    R (>= 3.5.0)
 Imports:
     utils
 Suggests:

---FILE: NAMESPACE---
@@ -7,13 +7,7 @@ S3method(""["",S7_object)
 S3method(""[<-"",S7_object)
 S3method(""[["",S7_object)
 S3method(""[[<-"",S7_object)
-S3method(""|"",ClassUnionRepresentation)
-S3method(""|"",S7_S3_class)
-S3method(""|"",S7_base_class)
 S3method(""|"",S7_class)
-S3method(""|"",S7_union)
-S3method(""|"",classGeneratorFunction)
-S3method(""|"",classRepresentation)
 S3method(Ops,S7_object)
 S3method(c,S7_class)
 S3method(print,S7_S3_class)

---FILE: NEWS.md---
@@ -2,6 +2,9 @@
 
 ## March 2023
 
+* `R CMD check` now passes on R 3.5 and greater (for tidyverse 
+  compatibility).
+
 * Dispatching on an evaluated argument no longer causes a crash (#254).
 
 * Improve method dispatch failure message (#231).

---FILE: R/union.R---
@@ -52,18 +52,10 @@ new_union <- function(...) {
 `|.S7_class` <- function(e1, e2) {
   new_union(e1, e2)
 }
-#' @export
-`|.S7_union` <- `|.S7_class`
-#' @export
-`|.S7_base_class` <- `|.S7_class`
-#' @export
-`|.S7_S3_class` <- `|.S7_class`
-#' @export
-`|.classGeneratorFunction` <- `|.S7_class`
-#' @export
-`|.ClassUnionRepresentation` <- `|.S7_class`
-#' @export
-`|.classRepresentation` <- `|.S7_class`
+
+# Method registration for the remaining classes happens onLoad so that
+# their pointers are identical, working around a bug that was fixed in
+# R 4.1: https://github.com/wch/r-source/commit/b41344e3d0da7d78fd
 
 is_union <- function(x) inherits(x, ""S7_union"")
 

---FILE: R/utils.R---
@@ -118,3 +118,27 @@ show_args <- function(x, name = ""function"") {
 
   paste0(name, ""("", args, "")"")
 }
+
+# For older versions of R ----------------------------------------------------
+deparse1 <- function(expr, collapse = "" "", width.cutoff = 500L, ...) {
+  paste(deparse(expr, width.cutoff, ...), collapse = collapse)
+}
+
+list2DF <- function(x = list(), nrow = 0L) {
+  stopifnot(is.list(x), is.null(nrow) || nrow >= 0L)
+  if (n <- length(x)) {
+    if (length(nrow <- unique(lengths(x))) > 1L) {
+      stop(""all variables should have the same length"")
+    }
+  } else {
+    if (is.null(nrow)) {
+      nrow <- 0L
+    }
+  }
+  if (is.null(names(x))) {
+    names(x) <- character(n)
+  }
+  class(x) <- ""data.frame""
+  attr(x, ""row.names"") <- .set_row_names(nrow)
+  x
+}

---FILE: R/zzz.R---
@@ -123,4 +123,13 @@ chooseOpsMethod.S7_object <- function(x, y, mx, my, cl, reverse) TRUE
   class_numeric <<- new_union(class_integer, class_double)
   class_atomic <<- new_union(class_logical, class_numeric, class_complex, class_character, class_raw)
   class_vector <<- new_union(class_atomic, class_expression, class_list)
+
+  # Dynamic register so that function pointers are the same, avoiding R 4.0
+  # and earlier bug related to incompatible S3 methods during Ops dispatch
+  registerS3method(""|"", ""S7_union"", `|.S7_class`)
+  registerS3method(""|"", ""S7_base_class"", `|.S7_class`)
+  registerS3method(""|"", ""S7_S3_class"", `|.S7_class`)
+  registerS3method(""|"", ""classGeneratorFunction"", `|.S7_class`)
+  registerS3method(""|"", ""ClassUnionRepresentation"", `|.S7_class`)
+  registerS3method(""|"", ""classRepresentation"", `|.S7_class`)
 }"
RConsortium,S7,b503fe0044ff33c13167b15d898a89cc5115c222,Hadley Wickham,h.wickham@gmail.com,2023-04-18T13:09:09Z,GitHub,noreply@github.com,2023-04-18T13:09:09Z,"Only set PRVALUE of promises (#289)

To allow dispatch on evaluated arguments. Fixed #254",NEWS.md;src/method-dispatch.c;tests/testthat/test-method-dispatch.R,False,True,True,False,17,3,20,"---FILE: NEWS.md---
@@ -2,6 +2,8 @@
 
 ## March 2023
 
+* Dispatching on an evaluated argument no longer causes a crash (#254).
+
 * Improve method dispatch failure message (#231).
 
 * Can use `|` to create unions from S7 classes (#224).

---FILE: src/method-dispatch.c---
@@ -158,9 +158,12 @@ SEXP method_call_(SEXP call, SEXP generic, SEXP envir) {
         SEXP val = PROTECT(Rf_eval(arg, R_EmptyEnv));
 
         if (!Rf_inherits(val, ""S7_super"")) {
-          // Update the value of the promise to avoid evaluating it
-          // again in the method body
-          SET_PRVALUE(arg, val);
+
+          // If it's a promise, update the value of the promise to avoid
+          // evaluating it again in the method body
+          if (TYPEOF(val) == PROMSXP) {
+            SET_PRVALUE(arg, val);
+          }
 
           // Then add to arguments of method call
           SETCDR(mcall_tail, Rf_cons(arg, R_NilValue));

---FILE: tests/testthat/test-method-dispatch.R---
@@ -173,3 +173,12 @@ test_that(""method dispatch preserves method return visibility"", {
   expect_visible(foo(""yep""))
   expect_invisible(foo(""nope""))
 })
+
+test_that(""can dispatch on evaluated arguments"", {
+  my_generic <- new_generic(""my_generic"", ""x"", function(x) {
+    x <- 10
+    S7_dispatch()
+  })
+  method(my_generic, class_numeric) <- function(x) 100
+  expect_equal(my_generic(""x""), 100)
+})"
RConsortium,S7,16df9ac22e1d48dc15163343b76165137505ef26,Hadley Wickham,h.wickham@gmail.com,2023-04-17T22:24:52Z,GitHub,noreply@github.com,2023-04-17T22:24:52Z,"Improve dispatch failure message (#299)

* Different messages for single vs multiple dispatch
* Use `obj_type()`

Fixes #231",NEWS.md;R/class-spec.R;R/convert.R;R/method-dispatch.R;R/method-introspect.R;src/init.c;src/method-dispatch.c;tests/testthat/_snaps/convert.md;tests/testthat/_snaps/method-dispatch.md;tests/testthat/test-method-dispatch.R,False,True,True,False,137,48,185,"---FILE: NEWS.md---
@@ -2,6 +2,8 @@
 
 ## March 2023
 
+* Improve method dispatch failure message (#231).
+
 * Can use `|` to create unions from S7 classes (#224).
 
 * Can no longer subclass an environment via `class_environment` because we

---FILE: R/class-spec.R---
@@ -187,7 +187,9 @@ class_inherits <- function(x, what) {
 }
 
 obj_type <- function(x) {
-  if (inherits(x, ""S7_object"")) {
+  if (identical(x, quote(expr = ))) {
+    ""missing""
+  } else if (inherits(x, ""S7_object"")) {
     ""S7""
   } else if (isS4(x)) {
     ""S4""
@@ -199,14 +201,16 @@ obj_type <- function(x) {
 }
 obj_desc <- function(x) {
   switch(obj_type(x),
-   base = paste0(""<"", typeof(x), "">""),
-   S3 = paste0(""S3<"", paste(class(x), collapse = ""/""), "">""),
-   S4 = paste0(""S4<"", class(x), "">""),
-   S7 = paste0(""<"", class(x)[[1]], "">"")
+    missing = ""MISSING"",
+    base = paste0(""<"", typeof(x), "">""),
+    S3 = paste0(""S3<"", paste(class(x), collapse = ""/""), "">""),
+    S4 = paste0(""S4<"", class(x), "">""),
+    S7 = paste0(""<"", class(x)[[1]], "">"")
   )
 }
 obj_dispatch <- function(x) {
   switch(obj_type(x),
+    missing = ""MISSING"",
     base = base_class(x),
     S3 = class(x),
     S4 = S4_class_dispatch(methods::getClass(class(x))),

---FILE: R/convert.R---
@@ -38,7 +38,7 @@ convert <- function(from, to, ...) {
   check_can_inherit(to)
 
   dispatch <- list(obj_dispatch(from), class_register(to))
-  convert <- .Call(method_, convert, dispatch, FALSE)
+  convert <- .Call(method_, convert, dispatch, environment(), FALSE)
 
   if (!is.null(convert)) {
     convert(from, to, ...)
@@ -64,7 +64,12 @@ convert <- function(from, to, ...) {
     }
     from
   } else {
-    method_lookup_error(""convert"", c(""from"", ""to""), dispatch)
+    msg <- paste0(
+      ""Can't find method for generic `convert()` with dispatch classes:\n"",
+      ""- from: "", obj_desc(from), ""\n"",
+      ""- to  : "", class_desc(to), ""\n""
+    )
+    stop(msg, call. = FALSE)
   }
 }
 # Converted to S7_generic on .onLoad

---FILE: R/method-dispatch.R---
@@ -1,12 +1,16 @@
 # Called from C
 method_lookup_error <- function(name, args, signatures) {
   sigs <- vcapply(signatures, paste, collapse = "", "")
-  types <- paste0(""- "", format(args), "": "", sigs, collapse = ""\n"")
-  msg <- sprintf(
-    ""Can't find method for generic `%s()` with dispatch classes:\n%s"",
-    name,
-    types
-  )
+  types <- vcapply(args, obj_desc)
+
+  if (length(args) == 1) {
+    msg <- sprintf(""Can't find method for `%s(%s)`."", name, types)
+  } else {
+    arg_names <- paste0(names(args), collapse = "", "")
+    types <- paste0(""- "", format(names(args)), "": "", types, collapse = ""\n"")
+    msg <- sprintf(""Can't find method for generic `%s(%s)`:\n%s"", name, arg_names, types)
+  }
+
   stop(msg, call. = FALSE)
 }
 

---FILE: R/method-introspect.R---
@@ -33,7 +33,7 @@
 method <- function(generic, class = NULL, object = NULL) {
   generic <- as_generic(generic)
   dispatch <- as_dispatch(generic, class = class, object = object)
-  .Call(method_, generic, dispatch, TRUE)
+  .Call(method_, generic, dispatch, environment(), TRUE)
 }
 
 #' Explain method dispatch

---FILE: src/init.c---
@@ -4,13 +4,13 @@
 #include <R_ext/Rdynload.h>
 
 /* .Call calls */
-extern SEXP method_(SEXP, SEXP, SEXP);
+extern SEXP method_(SEXP, SEXP, SEXP, SEXP);
 extern SEXP method_call_(SEXP, SEXP, SEXP);
 extern SEXP S7_class_(SEXP, SEXP);
 extern SEXP S7_object_();
 
 static const R_CallMethodDef CallEntries[] = {
-    {""method_"", (DL_FUNC) &method_, 3},
+    {""method_"", (DL_FUNC) &method_, 4},
     {""method_call_"", (DL_FUNC) &method_call_, 3},
     {""S7_object_"", (DL_FUNC) &S7_object_, 0},
     {NULL, NULL, 0}

---FILE: src/method-dispatch.c---
@@ -36,23 +36,54 @@ SEXP method_rec(SEXP table, SEXP signature, R_xlen_t signature_itr) {
   return R_NilValue;
 }
 
+SEXP generic_args(SEXP generic, SEXP envir) {
+  // How many arguments are used for dispatch?
+  SEXP dispatch_args = Rf_getAttrib(generic, Rf_install(""dispatch_args""));
+  R_xlen_t n_dispatch = Rf_xlength(dispatch_args);
+
+  // Allocate a list to store the arguments
+  SEXP args = PROTECT(Rf_allocVector(VECSXP, n_dispatch));
+
+  // Find the value of each argument.
+  SEXP formals = FORMALS(generic);
+  for (R_xlen_t i = 0; i < n_dispatch; ++i) {
+    SEXP name = TAG(formals);
+    SEXP arg = Rf_findVar(name, envir);
+
+    if (PRCODE(arg) == R_MissingArg) {
+      SET_VECTOR_ELT(args, i, R_MissingArg);
+    } else {
+      // method_call_() has already done the necessary computation
+      SET_VECTOR_ELT(args, i, Rf_eval(arg, R_EmptyEnv));
+    }
+
+    formals = CDR(formals);
+  }
+  Rf_setAttrib(args, R_NamesSymbol, dispatch_args);
+
+  UNPROTECT(1);
+
+  return args;
+}
+
 __attribute__ ((noreturn))
-void S7_method_lookup_error(SEXP generic, SEXP signature) {
-  static SEXP S7_method_lookup_error_fun = NULL;
+void S7_method_lookup_error(SEXP generic, SEXP signature, SEXP envir) {
   SEXP ns = Rf_findVarInFrame(R_NamespaceRegistry, Rf_install(""S7""));
-
+  static SEXP S7_method_lookup_error_fun = NULL;
   if (S7_method_lookup_error_fun == NULL) {
     S7_method_lookup_error_fun = Rf_findVarInFrame(ns, Rf_install(""method_lookup_error""));
   }
+
   SEXP name = Rf_getAttrib(generic, R_NameSymbol);
-  SEXP args = Rf_getAttrib(generic, Rf_install(""dispatch_args""));
+  SEXP args = generic_args(generic, envir);
+
   SEXP S7_method_lookup_error_call = PROTECT(Rf_lang4(S7_method_lookup_error_fun, name, args, signature));
   Rf_eval(S7_method_lookup_error_call, ns);
 
   while(1);
 }
 
-SEXP method_(SEXP generic, SEXP signature, SEXP error_) {
+SEXP method_(SEXP generic, SEXP signature, SEXP envir, SEXP error_) {
   if (!Rf_inherits(generic, ""S7_generic"")) {
     return R_NilValue;
   }
@@ -66,7 +97,7 @@ SEXP method_(SEXP generic, SEXP signature, SEXP error_) {
 
   int error = Rf_asInteger(error_);
   if (error && m == R_NilValue) {
-    S7_method_lookup_error(generic, signature);
+    S7_method_lookup_error(generic, signature, envir);
   }
 
   return m;
@@ -160,7 +191,7 @@ SEXP method_call_(SEXP call, SEXP generic, SEXP envir) {
   }
 
   // Now that we have all the classes, we can look up what method to call
-  SEXP m = method_(generic, dispatch_classes, Rf_ScalarLogical(1));
+  SEXP m = method_(generic, dispatch_classes, envir, Rf_ScalarLogical(1));
   SETCAR(mcall, m);
 
   UNPROTECT(n_protect);

---FILE: tests/testthat/_snaps/convert.md---
@@ -4,6 +4,6 @@
       convert(obj, to = class_double)
     Error <simpleError>
       Can't find method for generic `convert()` with dispatch classes:
-      - from: converttest, S7_object
-      - to  : double
+      - from: <converttest>
+      - to  : <double>
 

---FILE: tests/testthat/_snaps/method-dispatch.md---
@@ -2,21 +2,43 @@
 
     unused argument (z = 2)
 
-# method lookup fails with informative messages
-
-    Can't find method for generic `foo()` with dispatch classes:
-    - x: logical
-    - y: MISSING
-
----
-
-    Can't find method for generic `foo()` with dispatch classes:
-    - x: logical
-    - y: list
-
----
-
-    Can't find method for generic `foo()` with dispatch classes:
-    - x: tbl_df, tbl, data.frame
-    - y: POSIXct, POSIXt
+# single dispatch fails with informative messages
+
+    Code
+      fail(TRUE)
+    Error <simpleError>
+      Can't find method for `fail(<logical>)`.
+    Code
+      fail(tibble::tibble())
+    Error <simpleError>
+      Can't find method for `fail(S3<tbl_df/tbl/data.frame>)`.
+    Code
+      fail(foo())
+    Error <simpleError>
+      Can't find method for `fail(<foo>)`.
+    Code
+      fail(Foo(x = 1))
+    Error <simpleError>
+      Can't find method for `fail(S4<Foo>)`.
+
+# multiple dispatch fails with informative messages
+
+    Code
+      fail(TRUE)
+    Error <simpleError>
+      Can't find method for generic `fail(x, y)`:
+      - x: <logical>
+      - y: MISSING
+    Code
+      fail(, TRUE)
+    Error <simpleError>
+      Can't find method for generic `fail(x, y)`:
+      - x: MISSING
+      - y: <logical>
+    Code
+      fail(TRUE, TRUE)
+    Error <simpleError>
+      Can't find method for generic `fail(x, y)`:
+      - x: <logical>
+      - y: <logical>
 

---FILE: tests/testthat/test-method-dispatch.R---
@@ -130,12 +130,33 @@ test_that(""can dispatch on base 'union' types"", {
   expect_equal(foo(integer()), ""i"")
 })
 
-test_that(""method lookup fails with informative messages"", {
-  foo <- new_generic(""foo"", c(""x"", ""y""))
-  method(foo, list(class_character, class_integer)) <- function(x, y) paste0(""bar:"", x, y)
-  expect_snapshot_error(foo(TRUE))
-  expect_snapshot_error(foo(TRUE, list()))
-  expect_snapshot_error(foo(tibble::tibble(), .POSIXct(double())))
+test_that(""single dispatch fails with informative messages"", {
+  fail <- new_generic(""fail"", ""x"")
+
+  foo <- new_class(""foo"")
+  Foo <- setClass(""Foo"", slots = list(""x"" = ""numeric""), where = globalenv())
+  on.exit(S4_remove_classes(""Foo""))
+
+  expect_snapshot(error = TRUE, {
+    fail(TRUE)
+    fail(tibble::tibble())
+    fail(foo())
+    fail(Foo(x = 1))
+  })
+})
+
+test_that(""multiple dispatch fails with informative messages"", {
+  fail <- new_generic(""fail"", c(""x"", ""y""))
+
+  foo <- new_class(""foo"")
+  Foo <- setClass(""Foo"", slots = list(""x"" = ""numeric""), where = globalenv())
+  on.exit(S4_remove_classes(""Foo""))
+
+  expect_snapshot(error = TRUE, {
+    fail(TRUE)
+    fail(, TRUE)
+    fail(TRUE, TRUE)
+  })
 })
 
 "
RConsortium,S7,74f48cedd512f83a57da4ef3766e4db272ffd9a7,Hadley Wickham,h.wickham@gmail.com,2023-04-17T16:39:04Z,GitHub,noreply@github.com,2023-04-17T16:39:04Z,"Syntax sugar for unions (#297)

* Syntax sugar for unions. Fixes #224
* Document how to use union for optional values. Fixes #259",NAMESPACE;NEWS.md;R/union.R;man/new_union.Rd;tests/testthat/test-union.R,False,True,True,False,71,7,78,"---FILE: NAMESPACE---
@@ -7,6 +7,13 @@ S3method(""["",S7_object)
 S3method(""[<-"",S7_object)
 S3method(""[["",S7_object)
 S3method(""[[<-"",S7_object)
+S3method(""|"",ClassUnionRepresentation)
+S3method(""|"",S7_S3_class)
+S3method(""|"",S7_base_class)
+S3method(""|"",S7_class)
+S3method(""|"",S7_union)
+S3method(""|"",classGeneratorFunction)
+S3method(""|"",classRepresentation)
 S3method(Ops,S7_object)
 S3method(c,S7_class)
 S3method(print,S7_S3_class)

---FILE: NEWS.md---
@@ -2,6 +2,8 @@
 
 ## March 2023
 
+* Can use `|` to create unions from S7 classes (#224).
+
 * Can no longer subclass an environment via `class_environment` because we
   need to think the consequences of this behaviour through more fully (#253).
 

---FILE: R/union.R---
@@ -1,14 +1,19 @@
 #' Define a class union
 #'
 #' @description
-#' A class union represents a list of possible classes. It can be used in two
+#' A class union represents a list of possible classes. You can create it
+#' with `new_union(a, b, c)` or `a | b | c`. Unions can be used in two
 #' places:
 #'
 #' * To allow a property to be one of a set of classes,
-#'   `new_property(new_union(""integer"", Range))`.
+#'   `new_property(class_integer | Range)`. The default `default` value for the
+#'   property will be the constructor of the first object in the union.
+#'   This means if you want to create an ""optional"" property (i.e. one that
+#'   can be `NULL` or of a specified type), you'll need to write (e.g.)
+#'   `NULL | class_integer`.
 #'
 #' * As a convenient short-hand to define methods for multiple classes.
-#'   `method(foo, new_union(X, Y)) <- f` is short-hand for
+#'   `method(foo, X | Y) <- f` is short-hand for
 #'   `method(foo, X) <- f; method(foo, Y) <- foo`
 #'
 #' S7 includes built-in unions for ""numeric"" (integer and double vectors),
@@ -21,6 +26,8 @@
 #' @examples
 #' logical_or_character <- new_union(class_logical, class_character)
 #' logical_or_character
+#' # or with shortcut syntax
+#' logical_or_character <- class_logical | class_character
 #'
 #' Foo <- new_class(""Foo"", properties = list(x = logical_or_character))
 #' Foo(x = TRUE)
@@ -41,6 +48,23 @@ new_union <- function(...) {
   out
 }
 
+#' @export
+`|.S7_class` <- function(e1, e2) {
+  new_union(e1, e2)
+}
+#' @export
+`|.S7_union` <- `|.S7_class`
+#' @export
+`|.S7_base_class` <- `|.S7_class`
+#' @export
+`|.S7_S3_class` <- `|.S7_class`
+#' @export
+`|.classGeneratorFunction` <- `|.S7_class`
+#' @export
+`|.ClassUnionRepresentation` <- `|.S7_class`
+#' @export
+`|.classRepresentation` <- `|.S7_class`
+
 is_union <- function(x) inherits(x, ""S7_union"")
 
 #' @export

---FILE: man/new_union.Rd---
@@ -11,13 +11,18 @@ new_union(...)
 details.}
 }
 \description{
-A class union represents a list of possible classes. It can be used in two
+A class union represents a list of possible classes. You can create it
+with \code{new_union(a, b, c)} or \code{a | b | c}. Unions can be used in two
 places:
 \itemize{
 \item To allow a property to be one of a set of classes,
-\code{new_property(new_union(""integer"", Range))}.
+\code{new_property(class_integer | Range)}. The default \code{default} value for the
+property will be the constructor of the first object in the union.
+This means if you want to create an ""optional"" property (i.e. one that
+can be \code{NULL} or of a specified type), you'll need to write (e.g.)
+\code{NULL | class_integer}.
 \item As a convenient short-hand to define methods for multiple classes.
-\code{method(foo, new_union(X, Y)) <- f} is short-hand for
+\code{method(foo, X | Y) <- f} is short-hand for
 \verb{method(foo, X) <- f; method(foo, Y) <- foo}
 }
 
@@ -28,6 +33,8 @@ S7 includes built-in unions for ""numeric"" (integer and double vectors),
 \examples{
 logical_or_character <- new_union(class_logical, class_character)
 logical_or_character
+# or with shortcut syntax
+logical_or_character <- class_logical | class_character
 
 Foo <- new_class(""Foo"", properties = list(x = logical_or_character))
 Foo(x = TRUE)

---FILE: tests/testthat/test-union.R---
@@ -35,7 +35,31 @@ test_that(""base unions display as expected"", {
 })
 
 test_that(""can construct from S3 and S4 classes"", {
-  S4_union <- methods::setClass(""S4_union"")
+  S4_union <- methods::setClass(""S4_union"", where = globalenv())
+  on.exit(S4_remove_classes(""S4_union""))
+
   u <- new_union(class_factor, S4_union)
   expect_equal(u$classes, list(class_factor, getClass(""S4_union"")))
 })
+
+test_that(""can construct with |"", {
+  foo <- new_class(""foo"")
+  Foo1 <- setClass(""Foo1"", slots = list(""x"" = ""numeric""), where = globalenv())
+  Foo2 <- setClass(""Foo2"", slots = list(""x"" = ""numeric""), where = globalenv())
+  Foo3 <- setClassUnion(""Foo3"", c(""Foo1"", ""Foo2""), where = globalenv())
+  on.exit(S4_remove_classes(c(""Foo1"", ""Foo2"", ""Foo3"")))
+
+  expect_equal(class_integer | class_double, class_numeric)
+  expect_equal(class_integer | class_numeric, class_numeric)
+  expect_equal(class_integer | class_factor, new_union(class_integer, class_factor))
+  expect_equal(class_integer | foo, new_union(class_integer, foo))
+  expect_equal(class_integer | Foo1, new_union(class_integer, Foo1))
+  expect_equal(class_integer | getClass(""Foo1""), new_union(class_integer, Foo1))
+  expect_equal(class_integer | Foo3, new_union(class_integer, Foo3))
+  expect_equal(class_integer | getClass(""Foo3""), new_union(class_integer, Foo3))
+})
+
+test_that(""can construct optional union with syntactic sugar"", {
+  expect_equal(class_integer | NULL, new_union(class_integer, NULL))
+  expect_equal(NULL | class_integer, new_union(NULL, class_integer))
+})"
RConsortium,S7,598e684dd203e3f0c66f5250856fcd9ae22f4c3b,Hadley Wickham,h.wickham@gmail.com,2023-04-17T16:37:59Z,Hadley Wickham,h.wickham@gmail.com,2023-04-17T16:37:59Z,"Improve external generic docs

Fixes #184",R/external-generic.R;man/new_external_generic.Rd,False,True,True,False,51,12,63,"---FILE: R/external-generic.R---
@@ -1,12 +1,33 @@
 #' Generics in other packages
 #'
 #' @description
-#' To register a method for a generic in another packages you need to
-#' `new_external_generic()` and `external_methods_register()` together.
-#' `new_external_generic()` defines the ""shape"" of the generic without
-#' requiring the other package be available. You then call
-#' `external_methods_register()` in `.onLoad()` to dynamically register
-#' the methods when the other package is loaded.
+#' An external generic is a generic defined in another package that you want to
+#' register methods for. To create an external generic, first use
+#' `new_external_generic()` to define the name and the dispatch arguments
+#' of the generic:
+#'
+#' ```R
+#' generic <- new_external_generic(""package"", ""generic"", ""x"")
+#' ```
+#'
+#' This allows you to define methods for the generic, even if the other
+#' package is not installed:
+#'
+#' ```R
+#' methods(generic, my_class) <- function(...) {}
+#' ```
+#'
+#' Then call `external_methods_register()` in `.onLoad()`. This ensures that
+#' your methods are added to the generic when the other package is loaded.
+#'
+#' ```R
+#' .onLoad <- function(...) {
+#'   S7::external_methods_register()
+#' }
+#' ```
+#'
+#' In tests, you'll need to explicitly call the generic from the external
+#' package with `pkg::generic()`.
 #'
 #' @param package Package the generic is defined in.
 #' @param name Name of generic, as a string.

---FILE: man/new_external_generic.Rd---
@@ -20,10 +20,28 @@ external_methods_register()
 be registered.}
 }
 \description{
-To register a method for a generic in another packages you need to
-\code{new_external_generic()} and \code{external_methods_register()} together.
-\code{new_external_generic()} defines the ""shape"" of the generic without
-requiring the other package be available. You then call
-\code{external_methods_register()} in \code{.onLoad()} to dynamically register
-the methods when the other package is loaded.
+An external generic is a generic defined in another package that you want to
+register methods for. To create an external generic, first use
+\code{new_external_generic()} to define the name and the dispatch arguments
+of the generic:
+
+\if{html}{\out{<div class=""sourceCode R"">}}\preformatted{generic <- new_external_generic(""package"", ""generic"", ""x"")
+}\if{html}{\out{</div>}}
+
+This allows you to define methods for the generic, even if the other
+package is not installed:
+
+\if{html}{\out{<div class=""sourceCode R"">}}\preformatted{methods(generic, my_class) <- function(...) \{\}
+}\if{html}{\out{</div>}}
+
+Then call \code{external_methods_register()} in \code{.onLoad()}. This ensures that
+your methods are added to the generic when the other package is loaded.
+
+\if{html}{\out{<div class=""sourceCode R"">}}\preformatted{.onLoad <- function(...) \{
+  S7::external_methods_register()
+\}
+}\if{html}{\out{</div>}}
+
+In tests, you'll need to explicitly call the generic from the external
+package with \code{pkg::generic()}.
 }"
RConsortium,S7,4c993128486e067746405627e8de1fe17c393c02,Hadley Wickham,h.wickham@gmail.com,2023-04-17T12:57:06Z,GitHub,noreply@github.com,2023-04-17T12:57:06Z,"Don't allow inheritance from environments (#290)

At least for now. Fixes #253.",NEWS.md;R/base.R;R/class.R;man/base_classes.Rd;tests/testthat/_snaps/base.md;tests/testthat/_snaps/class.md;tests/testthat/test-base.R;tests/testthat/test-class.R;tests/testthat/test-zzz.R,False,True,True,False,27,30,57,"---FILE: NEWS.md---
@@ -1,5 +1,12 @@
 # S7 0.0.0.9000
 
+## March 2023
+
+* Can no longer subclass an environment via `class_environment` because we
+  need to think the consequences of this behaviour through more fully (#253).
+
+## Rest of 2022
+
 * Add `[.S7_object`, `[<-.S7_object`, `[[.S7_object`, and `[[<-.S7_object`
   methods to avoid ""object of type 'S4' is not subsettable"" error
   (@jamieRowen, #236).

---FILE: R/base.R---
@@ -71,7 +71,7 @@ str.S7_base_class <- function(object, ..., nest.lev = 0) {
 #' * `class_list`
 #' * `class_expression`
 #' * `class_function`
-#' * `class_environment`
+#' * `class_environment` (can only be used for properties)
 #'
 #' Union types:
 #'

---FILE: R/class.R---
@@ -210,6 +210,10 @@ check_can_inherit <- function(x, arg = deparse(substitute(x))) {
     )
     stop(msg, call. = FALSE)
   }
+
+  if (is_base_class(x) && x$class == ""environment"") {
+    stop(""Can't inherit from an environment."", call. = FALSE)
+  }
 }
 
 is_class <- function(x) inherits(x, ""S7_class"")

---FILE: man/base_classes.Rd---
@@ -71,7 +71,7 @@ Base types:
 \item \code{class_list}
 \item \code{class_expression}
 \item \code{class_function}
-\item \code{class_environment}
+\item \code{class_environment} (can only be used for properties)
 }
 
 Union types:

---FILE: tests/testthat/_snaps/base.md---
@@ -16,11 +16,3 @@
     Output
       <S7_base_class>: <integer>
 
-# environments: can be printed
-
-    Code
-      env(x = 1)
-    Output
-      <env> <environment: 0x0> 
-       @ x: num 1
-

---FILE: tests/testthat/_snaps/class.md---
@@ -76,6 +76,13 @@
     Error <simpleError>
       Can't convert `X[[i]]` to a valid class. Class specification must be an S7 class object, the result of `new_S3_class()`, an S4 class object, or a base class, not a <character>.
 
+# S7 classes: can't inherit from an environment
+
+    Code
+      new_class(""test"", parent = class_environment)
+    Error <simpleError>
+      Can't inherit from an environment.
+
 # abstract classes: can't be instantiated
 
     Code

---FILE: tests/testthat/test-base.R---
@@ -16,24 +16,10 @@ test_that(""base class display as expected"", {
 })
 
 test_that(""classes can inherit from base types"", {
-  base_classes <- c(class_vector$classes, list(class_function, class_environment))
+  base_classes <- c(class_vector$classes, list(class_function))
 
   for (class in base_classes) {
     foo <- new_class(""foo"", parent = class)
     expect_error(foo(), NA)
   }
 })
-
-describe(""environments"", {
-  it(""has reference semantics"", {
-    env <- new_class(""env"", class_environment, properties = list(x = class_double))
-    x1 <- x2 <- env(x = 1)
-    x1@x <- 2
-    expect_equal(x2@x, 2)
-  })
-
-  it(""can be printed"", {
-    env <- new_class(""env"", class_environment, properties = list(x = class_double))
-    expect_snapshot(env(x = 1), transform = scrub_environment)
-  })
-})

---FILE: tests/testthat/test-class.R---
@@ -44,6 +44,12 @@ describe(""S7 classes"", {
       new_class(""test"", parent = new_union(""character""))
     })
   })
+
+  it(""can't inherit from an environment"", {
+    expect_snapshot(error = TRUE, {
+      new_class(""test"", parent = class_environment)
+    })
+  })
 })
 
 describe(""inheritance"", {

---FILE: tests/testthat/test-zzz.R---
@@ -42,11 +42,6 @@ test_that(""[[ gives more accurate error"", {
   x <- new_class(""foo"", class_list)()
   x[[1]] <- 1
   expect_equal(x[[1]], 1)
-
-  # and ok if inheriting from environment
-  x <- new_class(""foo"", class_environment)()
-  x[[""a""]] <- 1
-  expect_equal(x[[""a""]], 1)
 })
 
 test_that(""register S4 classes for key components"", {"
RConsortium,S7,eef95a7b854504970e8dddd0abc4cc337c3b291a,Tomasz Kalinowski,kalinowskit@gmail.com,2023-04-15T15:25:35Z,GitHub,noreply@github.com,2023-04-15T15:25:35Z,"Base R support (#271)

This is a companion PR to https://github.com/r-devel/r-svn/pull/100, implementing the first three tasks described in https://github.com/RConsortium/OOP-WG/issues/22.",.github/workflows/R-CMD-check.yaml;.gitignore;NAMESPACE;R/class.R;R/generic-spec.R;R/property.R;R/zzz.R;man/prop.Rd;tests/testthat/_snaps/property.md;tests/testthat/test-base-r.R;tests/testthat/test-generic-spec.R;tests/testthat/test-method-register.R;tests/testthat/test-property.R;vignettes/compatibility.Rmd,True,True,True,False,208,21,229,"---FILE: .github/workflows/R-CMD-check.yaml---
@@ -5,6 +5,7 @@
 # check-standard.yaml is likely a better choice.
 # usethis::use_github_action(""check-standard"") will install it.
 on:
+  workflow_dispatch:
   push:
     branches: [main, master]
   pull_request:

---FILE: .gitignore---
@@ -2,3 +2,4 @@
 script.R
 inst/doc
 docs
+.Rhistory

---FILE: NAMESPACE---
@@ -30,7 +30,6 @@ S3method(str,S7_object)
 S3method(str,S7_property)
 S3method(str,S7_super)
 S3method(str,S7_union)
-export(""@"")
 export(""S7_data<-"")
 export(""method<-"")
 export(""prop<-"")
@@ -81,6 +80,11 @@ export(super)
 export(valid_eventually)
 export(valid_implicitly)
 export(validate)
+if (getRversion() >= ""4.3.0"" && !is.null(asNamespace(""utils"")$.AtNames)) S3method(utils::.AtNames,S7_object)
+if (getRversion() >= ""4.3.0"") S3method(base::`@`, S7_object) else export(""@"")
+if (getRversion() >= ""4.3.0"") S3method(chooseOpsMethod, S7_object)
+if (getRversion() >= ""4.3.0"") S3method(matrixOps, S7_object)
+if (getRversion() >= ""4.3.0"") S3method(nameOfClass, S7_class, S7_class_name)
 importFrom(stats,setNames)
 importFrom(utils,getFromNamespace)
 importFrom(utils,hasName)

---FILE: R/class.R---
@@ -144,6 +144,7 @@ new_class <- function(
 }
 globalVariables(c(""name"", ""parent"", ""package"", ""properties"", ""abstract"", ""constructor"", ""validator""))
 
+#' @rawNamespace if (getRversion() >= ""4.3.0"") S3method(nameOfClass, S7_class, S7_class_name)
 S7_class_name <- function(x) {
   paste(c(x@package, x@name), collapse = ""::"")
 }

---FILE: R/generic-spec.R---
@@ -17,7 +17,7 @@ as_S3_generic <- function(x) {
     return(S3_generic(x, as.character(use_method[[2]])))
   } else {
     name <- find_base_name(x)
-    if (name %in% group_generics()$Ops) {
+    if (name %in% names(base_ops)) {
       return(base_ops[[name]])
     } else if (!is.na(name) && is_internal_generic(name)) {
       return(S3_generic(x, name))
@@ -88,5 +88,9 @@ group_generics <- function() {
     Complex = ""Complex""
   )
 
-  lapply(groups, function(x) unlist(lapply(x, methods::getGroupMembers)))
+  out <- lapply(groups, function(x) unlist(lapply(x, methods::getGroupMembers)))
+  if (getRversion() >= ""4.3"") {
+    out$matrixOps <- c(""%*%"")
+  }
+  out
 }

---FILE: R/property.R---
@@ -220,7 +220,17 @@ prop_error_type <- function(object, prop_name, expected, actual, show_type = TRU
 
 #' @rdname prop
 #' @usage object@name
-#' @export
+#' @aliases @
+#' @rawNamespace if (getRversion() >= ""4.3.0"") S3method(base::`@`, S7_object) else export(""@"")
+`@.S7_object` <- prop
+
+# Note: we need to explicitly refer to base with ""base::`@`"" in the
+# namespace directive to ensure the method is registered in the correct place.
+# Otherwise, loadNamespace()/registerS3method() gets confused by the
+# presence of a closure w/ the name of the generic (`@`) in the R7 namespace,
+# and incorrectly assumes that R7::`@` is the generic and registers the
+# method in the package namespace instead of base::.__S3MethodsTable__.
+
 `@` <- function(object, name) {
   if (inherits(object, ""S7_object"")) {
     name <- as.character(substitute(name))
@@ -264,6 +274,13 @@ prop_names <- function(object) {
   }
 }
 
+# .AtNames not exported on r-devel yet, causes installation failure
+#' @rawNamespace if (getRversion() >= ""4.3.0"" && !is.null(asNamespace(""utils"")$.AtNames)) S3method(utils::.AtNames,S7_object)
+.AtNames.S7_object <- function(x, pattern = """") {
+  # utils::findMatches gives `R CMD check` warning on current r-devel
+  asNamespace(""utils"")$findMatches(pattern, prop_names(x))
+}
+
 #' @rdname prop_names
 #' @export
 prop_exists <- function(object, name) {

---FILE: R/zzz.R---
@@ -96,17 +96,25 @@ methods::setOldClass(c(""S7_method"", ""function"", ""S7_object""))
 
 
 # Create generics for double dispatch base Ops
-base_ops <- lapply(setNames(, group_generics()$Ops), new_generic, dispatch_args = c(""x"", ""y""))
+base_ops <- lapply(setNames(, unlist(group_generics()[c(""Ops"", ""matrixOps"")])),
+                   new_generic, dispatch_args = c(""x"", ""y""))
 
 #' @export
 Ops.S7_object <- function(e1, e2) {
   base_ops[[.Generic]](e1, e2)
 }
 
+#' @rawNamespace if (getRversion() >= ""4.3.0"") S3method(matrixOps, S7_object)
+matrixOps.S7_object <- Ops.S7_object
+
+#' @rawNamespace if (getRversion() >= ""4.3.0"") S3method(chooseOpsMethod, S7_object)
+chooseOpsMethod.S7_object <- function(x, y, mx, my, cl, reverse) TRUE
 
 .onAttach <- function(libname, pkgname) {
   env <- as.environment(paste0(""package:"", pkgname))
-  env[["".conflicts.OK""]] <- TRUE
+  if (getRversion() < ""4.3.0"") {
+    env[["".conflicts.OK""]] <- TRUE
+  }
 }
 
 .onLoad <- function(...) {

---FILE: man/prop.Rd---
@@ -3,6 +3,7 @@
 \name{prop}
 \alias{prop}
 \alias{prop<-}
+\alias{@.S7_object}
 \alias{@}
 \title{Get/set a property}
 \usage{

---FILE: tests/testthat/_snaps/property.md---
@@ -6,17 +6,6 @@
 
     Can't find property <foo>@x
 
-# property retrieval: falls back to `base::@` for non-S7 objects
-
-    Code
-      ""foo""@blah
-    Error <simpleError>
-      trying to get slot ""blah"" from an object of a basic class (""character"") with no slots
-    Code
-      NULL@blah
-    Error <simpleError>
-      trying to get slot ""blah"" from an object of a basic class (""NULL"") with no slots
-
 # prop setting: can't set read-only properties
 
     Code

---FILE: tests/testthat/test-base-r.R---
@@ -0,0 +1,126 @@
+
+
+test_that(""base::inherits() accepts S7 objects"", {
+  skip_if(getRversion() < ""4.3"")
+
+  ClassA <- new_class(""ClassA"")
+  ClassBA <- new_class(""ClassBA"", parent = ClassA)
+  ClassX <- new_class(""ClassX"")
+
+  expect_no_error(stopifnot(exprs = {
+    isTRUE(inherits(ClassA() , ClassA))
+    isTRUE(inherits(ClassBA(), ClassA))
+    isTRUE(inherits(ClassBA(), ClassBA))
+
+    isFALSE(inherits(ClassX(), ClassA))
+    isFALSE(inherits(ClassX(), ClassBA))
+  }))
+
+})
+
+
+test_that(""base::`@` accesses S7 properties"", {
+  skip_if(getRversion() < ""4.3"")
+
+  range <- new_class(
+    ""range"",
+    properties = list(start = class_double,
+                      end = class_double),
+    validator = function(self) {
+      if (length(self@start) != 1) {
+        ""@start must be length 1""
+      } else if (length(self@end) != 1) {
+        ""@end must be length 1""
+      } else if (self@end < self@start) {
+        ""@end must be greater than or equal to @start""
+      }
+    }
+  )
+
+  obj <- range(3, 4)
+
+  expect_no_error(stopifnot(exprs = {
+    identical(obj@start, 3)
+    identical(obj@end, 4)
+  }))
+
+  local({
+    `@` <- base::`@`
+    expect_no_error(stopifnot(exprs = {
+      identical(obj@start, 3)
+      identical(obj@end, 4)
+    }))
+
+  })
+
+})
+
+
+test_that(""Ops generics dispatch to S7 methods"", {
+  skip_if(getRversion() < ""4.3"")
+
+  ## Test Ops
+  ClassX <- new_class(""ClassX"")
+  method(`+`, list(class_any, ClassX))   <- function(x, y) ""class_any + ClassX""
+  method(`+`, list(ClassX, class_any))   <- function(x, y) ""ClassX + class_any""
+  method(`%*%`, list(ClassX, class_any)) <- function(x, y) ""ClassX %*% class_any""
+  method(`%*%`, list(class_any, ClassX)) <- function(x, y) ""class_any %*% ClassX""
+
+  on.exit(S4_remove_classes(c(""an_s4_class"")))
+  methods::setClass(""an_s4_class"", contains = ""character"", where = globalenv())
+  an_s4_obj <- methods::new(methods::getClass(""an_s4_class""))
+
+  test_vals <- list(1, NULL, new_class(""ClassA"")(), an_s4_obj,
+                    Sys.time(), structure("""", class = ""foo""))
+
+  val <- 1
+  identical(ClassX() + val,   ""ClassX + class_any"")
+  identical(val + ClassX(),   ""class_any + ClassX"")
+  identical(ClassX() %*% val, ""ClassX %*% class_any"")
+  identical(val %*% ClassX(), ""class_any %*% ClassX"")
+
+  for (val in test_vals)
+    expect_no_error(stopifnot(exprs = {
+      identical(ClassX() + val,   ""ClassX + class_any"")
+      identical(val + ClassX(),   ""class_any + ClassX"")
+      identical(ClassX() %*% val, ""ClassX %*% class_any"")
+      identical(val %*% ClassX(), ""class_any %*% ClassX"")
+    }))
+
+  expect_no_error(stopifnot(exprs = {
+    identical(ClassX()  +  ClassX(), ""ClassX + class_any"")
+    identical(ClassX() %*% ClassX(), ""ClassX %*% class_any"")
+  }))
+
+  # S3 dispatch still works
+  `+.foo`   <- function(e1, e2) paste(class(e1), ""+""     , class(e2))
+  `%*%.foo` <- function(x, y)   paste(class(x) , ""%*%""   , class(y))
+  Ops.bar   <- function(e1, e2) paste(class(e1), .Generic, class(e2))
+  matrixOps.bar   <- function(e1, e2) paste(class(e1), .Generic, class(e2))
+
+  foo <- structure("""", class = ""foo"")
+  bar <- structure("""", class = ""bar"")
+  expect_no_error(stopifnot(exprs = {
+    identical(foo %*% 1, ""foo %*% numeric"")
+    identical(1 %*% foo, ""numeric %*% foo"")
+
+    identical(bar %*% 1, ""bar %*% numeric"")
+    identical(1 %*% bar, ""numeric %*% bar"")
+
+    identical(foo + 1, ""foo + numeric"")
+    identical(1 + foo, ""numeric + foo"")
+
+    identical(bar + 1, ""bar + numeric"")
+    identical(1 + bar, ""numeric + bar"")
+  }))
+
+})
+
+
+test_that(""dput(<S7_object>) works"", {
+  skip_if(getRversion() < ""4.3"")
+  skip(""dput() not fixed yet; https://github.com/RConsortium/OOP-WG/issues/272"")
+
+  expect_no_error(dput(new_class(""Foo"")()))
+  expect_no_error(dput(new_class(""Foo"")))
+})

---FILE: tests/testthat/test-generic-spec.R---
@@ -14,4 +14,6 @@ test_that(""can standardise generics"", {
 
 test_that(""base ops use S7 shim"", {
   expect_equal(as_generic(`+`), base_ops[[""+""]])
+  if(getRversion() >= ""4.3.0"")
+    expect_equal(as_generic(`%*%`), base_ops[[""%*%""]])
 })

---FILE: tests/testthat/test-method-register.R---
@@ -60,6 +60,11 @@ describe(""method registration"", {
 
     method(`+`, list(foo, bar)) <- function(x, y) ""foobar""
     expect_equal(foo() + bar(), ""foobar"")
+
+    if(getRversion() >= ""4.3.0"") {
+      method(`%*%`, list(foo, bar)) <- function(x, y) ""foo.bar""
+      expect_equal(foo() %*% bar(), ""foo.bar"")
+    }
   })
 
   it(""S3 registration requires a S7 class"", {

---FILE: tests/testthat/test-property.R---
@@ -18,10 +18,8 @@ describe(""property retrieval"", {
   })
 
   it(""falls back to `base::@` for non-S7 objects"", {
-    expect_snapshot(error = TRUE, {
-      ""foo""@blah
-      NULL@blah
-    })
+    expect_error(""foo""@blah, 'object of.+class.+""character""')
+    expect_error(NULL@blah, 'object of.+class.+""NULL""')
   })
 })
 

---FILE: vignettes/compatibility.Rmd---
@@ -153,3 +153,33 @@ foo
 ```
 
 S7 unions allow you to restrict the type of a property in the same way that S4 unions allow you to restrict the type of a slot.
+
+
+## Using S7 in a package
+
+If you are using S7 in a package _and_ you want your package to maintain
+compatibility with R versions prior to 4.3.0, there are a few things to be aware of.
+
+#### `@`
+
+`` base::`@` `` in R versions prior to R 4.3.0 does not resolve R7 properties.
+
+Workarounds:
+
+-  Use `S7::prop()` instead of `@`.
+-  Alternatively, make an S7-aware `@` available to your package with 
+   a custom `NAMESPACE` directive and `.onAttach()` like this:
+
+   ``` r
+   # enable usage of <S7_object>@name in package code
+   #' @rawNamespace if (getRversion() < ""4.3.0"") importFrom(""S7"", ""@"")
+   NULL
+
+   # enable usage of <S7_object>@name in user code
+   # e.g. if you also want users to be able to access properties
+   # of objects your package
+   .onAttach <- function(libname, pkgname) {
+     if (getRversion() < ""4.3.0"")
+       require(S7)
+   }
+   ```"
RConsortium,S7,632d36db255e710833ce56a4d32fff561da57d85,Justin Landis,30324172+jtlandis@users.noreply.github.com,2023-04-10T21:09:51Z,GitHub,noreply@github.com,2023-04-10T21:09:51Z,"Correctly set default argument for constructors whose parent uses `...` (#264)

Fixes #256",R/constructor.R;tests/testthat/_snaps/constructor.md;tests/testthat/test-constructor.R,False,True,True,False,33,0,33,"---FILE: R/constructor.R---
@@ -35,6 +35,11 @@ new_constructor <- function(parent, properties) {
     stop(""Unsupported `parent` type"", call. = FALSE)
   }
 
+  # ensure default value for `...` is empty
+  if (""..."" %in% names(args)) {
+    args[names(args) == ""...""] <- list(quote(expr = ))
+  }
+
   parent_args <- as_names(arg_info$parent, named = TRUE)
   parent_call <- new_call(parent_name, parent_args)
   body <- new_call(""new_object"", c(parent_call, self_args))

---FILE: tests/testthat/_snaps/constructor.md---
@@ -60,3 +60,12 @@
       new_object(S7_object(), y = y)
       <environment: namespace:S7>
 
+# can use `...` in parent constructor
+
+    Code
+      new_constructor(foo, list(y = class_double))
+    Output
+      function (..., y = class_missing) 
+      new_object(foo(... = ...), y = y)
+      <environment: 0x0>
+

---FILE: tests/testthat/test-constructor.R---
@@ -61,3 +61,22 @@ test_that(""can generate constructor for inherited abstract classes"", {
   child <- new_class(""child"", foo1, properties = list(y = class_double))
   expect_error(child(y = 0.5), regexp = NA)
 })
+
+test_that(""can use `...` in parent constructor"", {
+  foo <- new_class(
+    ""foo"",
+    properties = list(x = class_list),
+    constructor = function(...) new_object(NULL, x = list(...))
+  )
+
+  expect_snapshot(
+    new_constructor(foo, list(y = class_double)),
+    transform = scrub_environment
+  )
+
+  # And check that arguments matched correctly
+  bar <- new_class(""bar"", foo, properties = list(y = class_double))
+  expect_equal(bar()@x, list())
+  expect_equal(bar(2)@x, list(2))
+  expect_equal(bar(y = 2)@x, list())
+})"
RConsortium,S7,d069e90c9dffb20664c27dd97466d43c3be82cf9,Martin Maechler,maechler@r-project.org,2023-02-24T16:38:29Z,Martin Maechler,maechler@r-project.org,2023-02-24T16:38:29Z,doc: fix def of `atomic`,R/base.R;R/union.R,False,True,True,False,2,2,4,"---FILE: R/base.R---
@@ -77,7 +77,7 @@ str.S7_base_class <- function(object, ..., nest.lev = 0) {
 #'
 #' * `class_numeric` is a union of `class_integer` and `class_double`.
 #' * `class_atomic` is a union of `class_logical`, `class_numeric`,
-#'   `class_complex`, and `class_raw`.
+#'   `class_complex`, `class_character`, and `class_raw`.
 #' * `class_vector` is a union of `class_atomic`, `class_list`, and
 #'   `class_expression`.
 #'

---FILE: R/union.R---
@@ -12,7 +12,7 @@
 #'   `method(foo, X) <- f; method(foo, Y) <- foo`
 #'
 #' S7 includes built-in unions for ""numeric"" (integer and double vectors),
-#' ""atomic"" (logical, numeric, character, and raw vectors) and
+#' ""atomic"" (logical, numeric, complex, character, and raw vectors) and
 #' ""vector"" (atomic vectors, lists, and expressions).
 #'
 #' @param ... The classes to include in the union. See [as_class()] for"
RConsortium,S7,249b8847b6b29f3e442b8e84c8ab552d63368206,Hadley Wickham,h.wickham@gmail.com,2023-02-19T16:38:05Z,GitHub,noreply@github.com,2023-02-19T16:38:05Z,"Don't create a constructor called ""function"" (#280)

Fixes #249. Fixes #279.",R/base.R;R/constructor.R,False,True,True,False,4,3,7,"---FILE: R/base.R---
@@ -1,4 +1,4 @@
-new_base_class <- function(name) {
+new_base_class <- function(name, constructor_name = name) {
   force(name)
 
   constructor <- function(.data = class_missing) {
@@ -16,6 +16,7 @@ new_base_class <- function(name) {
 
   out <- list(
     class = name,
+    constructor_name = constructor_name,
     constructor = constructor,
     validator = validator
   )
@@ -143,7 +144,7 @@ class_expression <- new_base_class(""expression"")
 #' @rdname base_classes
 #' @format NULL
 #' @order 1
-class_function <- new_base_class(""function"")
+class_function <- new_base_class(""function"", ""fun"")
 
 #' @export
 #' @rdname base_classes

---FILE: R/constructor.R---
@@ -22,7 +22,7 @@ new_constructor <- function(parent, properties) {
     parent_fun <- parent
     args <- missing_args(union(arg_info$parent, arg_info$self))
   } else if (is_base_class(parent)) {
-    parent_name <- parent$class
+    parent_name <- parent$constructor_name
     parent_fun <- parent$constructor
     args <- missing_args(union(arg_info$parent, arg_info$self))
   } else if (is_S3_class(parent)) {"
RConsortium,S7,c68b0ee0a38d864f113d633c1579bb196c1a29bc,laresbernardo,laresbernardo@gmail.com,2022-12-21T19:07:53Z,GitHub,noreply@github.com,2022-12-21T19:07:53Z,docs: small redact fix on R7 vignette (#270),vignettes/R7.Rmd,True,False,True,False,1,1,2,"---FILE: vignettes/R7.Rmd---
@@ -14,7 +14,7 @@ knitr::opts_chunk$set(
 )
 ```
 
-The R7 package is provides a new OOP system designed to be a successor to S3 and S4.
+The R7 package provides a new OOP system designed to be a successor to S3 and S4.
 It has been designed and implemented collaboratively by the RConsortium Object-Oriented Programming Working Group, which includes representatives from R-Core, BioConductor, RStudio/tidyverse, and the wider R community.
 
 This vignette describes how R7 works, starting with an overview of classes, objects, generics, and methods, then going into the details of validation and properties."
RConsortium,S7,e9cb35bbf033b283386182664b543a1c3aa3a26a,Justin Landis,30324172+jtlandis@users.noreply.github.com,2022-12-12T19:24:22Z,GitHub,noreply@github.com,2022-12-12T19:24:22Z,"Move parenthesis to correct place (#265)

Fixes #258",R/constructor.R;tests/testthat/_snaps/constructor.md;tests/testthat/test-constructor.R,False,True,True,False,5,3,8,"---FILE: R/constructor.R---
@@ -12,7 +12,7 @@ new_constructor <- function(parent, properties) {
   if (is_class(parent) && parent@abstract) {
     return(new_function(
       args = missing_args(arg_info$self),
-      body = new_call(""new_object"", c(list(quote(R7_object()), self_args))),
+      body = new_call(""new_object"", c(list(quote(R7_object())), self_args)),
       env = asNamespace(""R7"")
     ))
   }

---FILE: tests/testthat/_snaps/constructor.md---
@@ -51,12 +51,12 @@
       new_constructor(foo1, list())
     Output
       function () 
-      new_object(R7_object(), list())
+      new_object(R7_object())
       <environment: namespace:R7>
     Code
       new_constructor(foo1, as_properties(list(y = class_double)))
     Output
       function (y = class_missing) 
-      new_object(R7_object(), list(y = y))
+      new_object(R7_object(), y = y)
       <environment: namespace:R7>
 

---FILE: tests/testthat/test-constructor.R---
@@ -58,4 +58,6 @@ test_that(""can generate constructor for inherited abstract classes"", {
     new_constructor(foo1, list())
     new_constructor(foo1, as_properties(list(y = class_double)))
   }, transform = scrub_environment)
+  child <- new_class(""child"", foo1, properties = list(y = class_double))
+  expect_error(child(y = 0.5), regexp = NA)
 })"
RConsortium,S7,ddc61f0d82587796aefb86a8402d4b729e609d32,Doug Kelkhoff,18220321+dgkf@users.noreply.github.com,2022-07-29T13:19:37Z,GitHub,noreply@github.com,2022-07-29T13:19:37Z,"Preserve visibility of method returns (#243)

Fixes #196",R/method-dispatch.R;src/method-dispatch.c;tests/testthat/test-method-dispatch.R,False,True,True,False,18,5,23,"---FILE: R/method-dispatch.R---
@@ -14,5 +14,6 @@ method_lookup_error <- function(name, args, signatures) {
 #' @order 2
 #' @export
 R7_dispatch <- function() {
-  .Call(method_call_, sys.call(-1), sys.function(-1), sys.frame(-1))
+  R7_dispatched_call <- .Call(method_call_, sys.call(-1), sys.function(-1), sys.frame(-1))
+  eval(R7_dispatched_call, envir = sys.frame(-1))
 }

---FILE: src/method-dispatch.c---
@@ -164,9 +164,6 @@ SEXP method_call_(SEXP call, SEXP generic, SEXP envir) {
   SEXP m = method_(generic, dispatch_classes, Rf_ScalarLogical(1));
   SETCAR(mcall, m);
 
-  // And then call it
-  SEXP res = Rf_eval(mcall, envir);
-
   UNPROTECT(n_protect);
-  return res;
+  return mcall;
 }

---FILE: tests/testthat/test-method-dispatch.R---
@@ -137,3 +137,18 @@ test_that(""method lookup fails with informative messages"", {
   expect_snapshot_error(foo(TRUE, list()))
   expect_snapshot_error(foo(tibble::tibble(), .POSIXct(double())))
 })
+
+
+test_that(""method dispatch preserves method return visibility"", {
+  foo <- new_generic(""foo"", ""x"")
+  method(foo, class_integer) <- function(x) invisible(""bar"")
+  expect_invisible(foo(1L))
+
+  method(foo, class_character) <- function(x) {
+    if (x == ""nope"") return(invisible(""bar""))
+    ""bar""
+  }
+
+  expect_visible(foo(""yep""))
+  expect_invisible(foo(""nope""))
+})"
RConsortium,S7,8b8a70903270084dd4e7807c2fe4d035337b467a,Jamie Owen,jamie@jumpingrivers.com,2022-07-17T14:41:35Z,GitHub,noreply@github.com,2022-07-17T14:41:35Z,"Improve error message when subsetting (#237)

Fixes #236",NAMESPACE;NEWS.md;R/zzz.R;tests/testthat/_snaps/zzz.md;tests/testthat/test-zzz.R,False,True,True,False,91,0,91,"---FILE: NAMESPACE---
@@ -3,6 +3,10 @@
 S3method(""$"",R7_object)
 S3method(""$<-"",R7_object)
 S3method(""@<-"",R7_object)
+S3method(""["",R7_object)
+S3method(""[<-"",R7_object)
+S3method(""[["",R7_object)
+S3method(""[[<-"",R7_object)
 S3method(Ops,R7_object)
 S3method(c,R7_class)
 S3method(print,R7_S3_class)

---FILE: NEWS.md---
@@ -1,5 +1,9 @@
 # R7 0.0.0.9000
 
+* Add `[.R7_object`, `[<-.R7_object`, `[[.R7_object`, and `[[<-.R7_object` 
+  methods to avoid ""object of type 'S4' is not subsettable"" error 
+  (@jamieRowen, #236).
+  
 * Combining R7 classes with `c()` now gives an error (#230)
 
 * Base classes now show as `class_x` instead of `""x""` in method print (#232)

---FILE: R/zzz.R---
@@ -43,7 +43,35 @@ methods::setOldClass(""R7_object"")
   }
 }
 
+#' @export
+`[.R7_object` <- function(x, ..., drop = TRUE) {
+  check_subsettable(x)
+  NextMethod()
+}
+#' @export
+`[<-.R7_object` <- function(x, ..., value) {
+  check_subsettable(x)
+  NextMethod()
+}
 
+#' @export
+`[[.R7_object` <- function(x, ...) {
+  check_subsettable(x, allow_env = TRUE)
+  NextMethod()
+}
+#' @export
+`[[<-.R7_object` <- function(x, ..., value) {
+  check_subsettable(x, allow_env = TRUE)
+  NextMethod()
+}
+
+check_subsettable <- function(x, allow_env = FALSE) {
+  allowed_types <- c(""list"", if (allow_env) ""environment"")
+  if (!typeof(x) %in% allowed_types) {
+    stop(""R7 objects are not subsettable."", call. = FALSE)
+  }
+  invisible(TRUE)
+}
 
 R7_generic <- new_class(
   name = ""R7_generic"",

---FILE: tests/testthat/_snaps/zzz.md---
@@ -14,3 +14,27 @@
     Error <simpleError>
       Can't set R7 properties with `$`. Did you mean `...@y <- 1`?
 
+# [ gives more accurate error
+
+    Code
+      x <- new_class(""foo"")()
+      x[1]
+    Error <simpleError>
+      R7 objects are not subsettable.
+    Code
+      x[1] <- 1
+    Error <simpleError>
+      R7 objects are not subsettable.
+
+# [[ gives more accurate error
+
+    Code
+      x <- new_class(""foo"")()
+      x[[1]]
+    Error <simpleError>
+      R7 objects are not subsettable.
+    Code
+      x[[1]] <- 1
+    Error <simpleError>
+      R7 objects are not subsettable.
+

---FILE: tests/testthat/test-zzz.R---
@@ -18,6 +18,37 @@ test_that(""$ gives useful error"", {
   expect_equal(x$x, 1)
 })
 
+test_that(""[ gives more accurate error"", {
+  expect_snapshot(error = TRUE, {
+    x <- new_class(""foo"")()
+    x[1]
+    x[1] <- 1
+  })
+
+  # but ok if inheriting from list
+  x <- new_class(""foo"", class_list)()
+  x[1] <- 1
+  expect_equal(x[1], list(1))
+})
+
+test_that(""[[ gives more accurate error"", {
+  expect_snapshot(error = TRUE, {
+    x <- new_class(""foo"")()
+    x[[1]]
+    x[[1]] <- 1
+  })
+
+  # but ok if inheriting from list
+  x <- new_class(""foo"", class_list)()
+  x[[1]] <- 1
+  expect_equal(x[[1]], 1)
+
+  # and ok if inheriting from environment
+  x <- new_class(""foo"", class_environment)()
+  x[[""a""]] <- 1
+  expect_equal(x[[""a""]], 1)
+})
+
 test_that(""register S4 classes for key components"", {
   expect_s4_class(getClass(""R7_object""), ""classRepresentation"")
   expect_s4_class(getClass(""R7_method""), ""classRepresentation"")"
RConsortium,S7,3a7d31163742758d622ba1b559a80c1c19aa07bf,Jamie Owen,jamie@jumpingrivers.com,2022-07-15T13:26:09Z,GitHub,noreply@github.com,2022-07-15T13:26:09Z,"Error when attempting to combine R7 classes (#239)

Fixes #230",NAMESPACE;NEWS.md;R/class.R;tests/testthat/_snaps/class.md;tests/testthat/test-class.R,False,True,True,False,23,0,23,"---FILE: NAMESPACE---
@@ -4,6 +4,7 @@ S3method(""$"",R7_object)
 S3method(""$<-"",R7_object)
 S3method(""@<-"",R7_object)
 S3method(Ops,R7_object)
+S3method(c,R7_class)
 S3method(print,R7_S3_class)
 S3method(print,R7_any)
 S3method(print,R7_base_class)

---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # R7 0.0.0.9000
 
+* Combining R7 classes with `c()` now gives an error (#230)
+
 * Base classes now show as `class_x` instead of `""x""` in method print (#232)
 
 ## Mar 2022

---FILE: R/class.R---
@@ -192,6 +192,12 @@ str.R7_class <- function(object, ..., nest.lev = 0) {
   }
 }
 
+#' @export
+c.R7_class <- function(...) {
+  msg <- ""Can not combine R7 class objects""
+  stop(msg, call. = FALSE)
+}
+
 can_inherit <- function(x) is_base_class(x) || is_S3_class(x) || is_class(x)
 
 check_can_inherit <- function(x, arg = deparse(substitute(x))) {

---FILE: tests/testthat/_snaps/class.md---
@@ -157,3 +157,10 @@
        .. $ a: num 41
        .. $ b: num 42
 
+# c(<R7_class>, ...) gives error
+
+    Code
+      c(foo1, foo1)
+    Error <simpleError>
+      Can not combine R7 class objects
+

---FILE: tests/testthat/test-class.R---
@@ -183,3 +183,10 @@ describe(""default constructor"", {
     expect_s3_class(x@x, ""foo1"")
   })
 })
+
+test_that(""c(<R7_class>, ...) gives error"", {
+  foo1 <- new_class(""foo1"")
+  expect_snapshot(error = TRUE, {
+    c(foo1, foo1)
+  })
+})"
RConsortium,S7,3cd831b8a8d385609908d06ba1e1467753403004,Jamie Owen,jamie@jumpingrivers.com,2022-07-13T20:54:42Z,GitHub,noreply@github.com,2022-07-13T20:54:42Z,"Show `class_` when printing method names (#238)

Fixes #232",NEWS.md;R/class-spec.R;man/R7_object.Rd;tests/testthat/_snaps/generic.md;tests/testthat/_snaps/method-register.md;tests/testthat/test-class-spec.R,False,True,True,False,9,7,16,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # R7 0.0.0.9000
 
+* Base classes now show as `class_x` instead of `""x""` in method print (#232)
+
 ## Mar 2022
 
 * Exported `class_factor`, `class_Date`, `class_POSIXct`, and 

---FILE: R/class-spec.R---
@@ -161,7 +161,7 @@ class_deparse <- function(x) {
     any = ""class_any"",
     S4 = as.character(x@className),
     R7 = R7_class_name(x),
-    R7_base = encodeString(x$class, quote = '""'),
+    R7_base = paste0(""class_"", x$class),
     R7_union = {
       classes <- vcapply(x$classes, class_deparse)
       paste0(""new_union("", paste(classes, collapse = "", ""), "")"")

---FILE: tests/testthat/_snaps/generic.md---
@@ -54,15 +54,15 @@
       foo1
     Output
       <R7_generic> foo1(x, ...) with 2 methods:
-      1: method(foo1, ""character"")
+      1: method(foo1, class_character)
       2: method(foo1, text)
     Code
       foo3
     Output
       <R7_generic> foo3(x, y, z, ...) with 3 methods:
-      1: method(foo3, list(""character"", ""integer"", ""character""))
-      2: method(foo3, list(""character"", ""integer"", ""logical""))
-      3: method(foo3, list(""character"", text, ""character""))
+      1: method(foo3, list(class_character, class_integer, class_character))
+      2: method(foo3, list(class_character, class_integer, class_logical))
+      3: method(foo3, list(class_character, text, class_character))
 
 # R7_generic printing with long / many arguments
 

---FILE: tests/testthat/_snaps/method-register.md---
@@ -92,7 +92,7 @@
     Code
       method(foo, list(class_integer, class_integer))
     Output
-      <R7_method> method(foo, list(""integer"", ""integer""))
+      <R7_method> method(foo, list(class_integer, class_integer))
       function (x, y, ...) 
       paste0(""bar:"", x, y)
       <environment: 0x0>

---FILE: tests/testthat/test-class-spec.R---
@@ -79,7 +79,7 @@ test_that(""can work with base types"", {
   expect_equal(class_register(klass), ""character"")
   expect_equal(class_desc(klass), ""<character>"")
   expect_equal(class_construct(klass, ""x""), ""x"")
-  expect_equal(class_deparse(klass), '""character""')
+  expect_equal(class_deparse(klass), 'class_character')
 
   obj <- ""x""
   expect_equal(obj_type(obj), ""base"")"
RConsortium,S7,ff3872addfa7ee341b8c2ed520434e068ab5922a,Jeroen Ooms,jeroenooms@gmail.com,2022-06-22T17:08:37Z,GitHub,noreply@github.com,2022-06-22T17:08:37Z,Fix installation instructions (#227),README.Rmd,True,False,True,False,1,1,2,"---FILE: README.Rmd---
@@ -31,7 +31,7 @@ For now, you can experiment by installing the in-development version from GitHub
 
 ```{r, eval = FALSE}
 # install.packages(""remotes"")
-remotes::install_github(""r-consortium/OOP-WG"")
+remotes::install_github(""rconsortium/OOP-WG"")
 ```
 
 ## Usage"
RConsortium,S7,44faff13301abf8709ea977ead82f469fe950625,Jon Harmon,jonthegeek@gmail.com,2022-05-19T22:43:36Z,GitHub,noreply@github.com,2022-05-19T22:43:36Z,Fix check_is_R7() error message for non-R7 objects. (#228),R/inherits.R;tests/testthat/_snaps/inherits.md;tests/testthat/test-inherits.R,False,True,True,False,9,1,10,"---FILE: R/inherits.R---
@@ -30,7 +30,7 @@ R7_inherits <- function(x, class) {
 check_is_R7 <- function(x, class = NULL, arg = deparse(substitute(x))) {
   if (is.null(class)) {
     if (!inherits(x, ""R7_object"")) {
-      msg <- sprintf(""`%s` must be an <R7_object>, not a %s"", arg, class_desc(class), obj_desc(x))
+      msg <- sprintf(""`%s` must be an <R7_object>, not a %s"", arg, obj_desc(x))
       stop(msg, call. = FALSE)
     }
   } else {

---FILE: tests/testthat/_snaps/inherits.md---
@@ -14,3 +14,10 @@
     Error <simpleError>
       `foo1()` must be a <foo2>, not a <foo1>
 
+---
+
+    Code
+      check_is_R7(""a"")
+    Error <simpleError>
+      `""a""` must be an <R7_object>, not a <character>
+

---FILE: tests/testthat/test-inherits.R---
@@ -17,4 +17,5 @@ test_that(""throws informative error"", {
     foo2 <- new_class(""foo2"")
     check_is_R7(foo1(), foo2)
   })
+  expect_snapshot(check_is_R7(""a""), error = TRUE)
 })"
RConsortium,S7,db1df4d8e1f2a0617c5fc3b92aaeb2bfe2068303,Hadley Wickham,h.wickham@gmail.com,2022-03-26T12:49:39Z,GitHub,noreply@github.com,2022-03-26T12:49:39Z,"Custom dispatch for base Ops (#217)

Fixes #128",NAMESPACE;NEWS.md;R/generic-spec.R;R/method-introspect.R;R/zzz.R;tests/testthat/test-generic-spec.R;tests/testthat/test-method-register.R,False,True,True,False,32,1,33,"---FILE: NAMESPACE---
@@ -3,6 +3,7 @@
 S3method(""$"",R7_object)
 S3method(""$<-"",R7_object)
 S3method(""@<-"",R7_object)
+S3method(Ops,R7_object)
 S3method(print,R7_S3_class)
 S3method(print,R7_any)
 S3method(print,R7_base_class)

---FILE: NEWS.md---
@@ -8,6 +8,10 @@
 
 ## Mar 2022
 
+* Can now register methods for double-dispatch base Ops (currently only
+  works if both classes are R7, or the first argument is R7 and the second
+  doesn't have a method for the Ops generic) (#128).
+
 * All built-in wrappers around base types use `class_`. You can no longer
   refer to a base type with a string or a constructor function (#170).
 

---FILE: R/generic-spec.R---
@@ -17,7 +17,9 @@ as_S3_generic <- function(x) {
     return(S3_generic(x, as.character(use_method[[2]])))
   } else {
     name <- find_base_name(x)
-    if (!is.na(name) && is_internal_generic(name)) {
+    if (name %in% group_generics()$Ops) {
+      return(base_ops[[name]])
+    } else if (!is.na(name) && is_internal_generic(name)) {
       return(S3_generic(x, name))
     }
   }

---FILE: R/method-introspect.R---
@@ -31,6 +31,7 @@
 #' method(bizarro, object = 1)
 #' method(bizarro, new_S3_class(""factor""))
 method <- function(generic, class = NULL, object = NULL) {
+  generic <- as_generic(generic)
   dispatch <- as_dispatch(generic, class = class, object = object)
   .Call(method_, generic, dispatch, TRUE)
 }
@@ -61,6 +62,7 @@ method <- function(generic, class = NULL, object = NULL) {
 #'
 #' method_explain(add, list(foo2, foo2))
 method_explain <- function(generic, class = NULL, object = NULL) {
+  generic <- as_generic(generic)
   dispatch <- as_dispatch(generic, class = class, object = object)
   dispatch <- lapply(dispatch, c, ""ANY"")
 

---FILE: R/zzz.R---
@@ -72,6 +72,16 @@ R7_method <- new_class(""R7_method"",
 )
 methods::setOldClass(c(""R7_method"", ""function"", ""R7_object""))
 
+
+# Create generics for double dispatch base Ops
+base_ops <- lapply(setNames(, group_generics()$Ops), new_generic, dispatch_args = c(""x"", ""y""))
+
+#' @export
+Ops.R7_object <- function(e1, e2) {
+  base_ops[[.Generic]](e1, e2)
+}
+
+
 .onAttach <- function(libname, pkgname) {
   env <- as.environment(paste0(""package:"", pkgname))
   env[["".conflicts.OK""]] <- TRUE

---FILE: tests/testthat/test-generic-spec.R---
@@ -11,3 +11,7 @@ test_that(""can standardise generics"", {
   expect_snapshot(as_generic(function() {}), error = TRUE)
   expect_snapshot(as_generic(1), error = TRUE)
 })
+
+test_that(""base ops use R7 shim"", {
+  expect_equal(as_generic(`+`), base_ops[[""+""]])
+})

---FILE: tests/testthat/test-method-register.R---
@@ -54,6 +54,14 @@ describe(""method registration"", {
     expect_equal(sum, base::sum)
   })
 
+  it(""can register R7 method for S3 Ops generic"", {
+    foo <- new_class(""foo"")
+    bar <- new_class(""bar"")
+
+    method(`+`, list(foo, bar)) <- function(x, y) ""foobar""
+    expect_equal(foo() + bar(), ""foobar"")
+  })
+
   it(""S3 registration requires a R7 class"", {
     foo <- new_class(""foo"")
     expect_snapshot(error = TRUE, {"
RConsortium,S7,596c90902e06a7c77550b1bcedca37b08354834c,Hadley Wickham,h.wickham@gmail.com,2022-03-24T19:18:04Z,GitHub,noreply@github.com,2022-03-24T19:18:04Z,"Move handling of ANY into C (#221)

Rather than including in class_dispatch(). This also ensures that missing arguments also look for ANY methods, fixing #218.",R/class-spec.R;R/class.R;R/convert.R;R/method-introspect.R;src/init.c;src/method-dispatch.c;tests/testthat/_snaps/convert.md;tests/testthat/_snaps/method-dispatch.md;tests/testthat/test-class-spec.R;tests/testthat/test-method-dispatch.R,False,True,True,False,59,44,103,"---FILE: R/class-spec.R---
@@ -124,17 +124,17 @@ class_desc <- function(x) {
 # Vector of class names; used in method introspection
 class_dispatch <- function(x) {
   if (is_class(x) && x@name == ""R7_object"") {
-    return(c(""R7_object"", ""ANY""))
+    return(""R7_object"")
   }
 
   switch(class_type(x),
-    NULL = c(""NULL"", ""ANY""),
+    NULL = ""NULL"",
     missing = ""MISSING"",
-    any = ""ANY"",
-    S4 = c(S4_class_dispatch(methods::extends(x)), ""ANY""),
+    any = character(),
+    S4 = S4_class_dispatch(methods::extends(x)),
     R7 = c(R7_class_name(x), class_dispatch(x@parent)),
-    R7_base = c(x$class, ""R7_object"", ""ANY""),
-    R7_S3 = c(x$class, ""R7_object"", ""ANY""),
+    R7_base = c(x$class, ""R7_object""),
+    R7_S3 = c(x$class, ""R7_object""),
     stop(""Unsupported"")
   )
 }
@@ -207,10 +207,10 @@ obj_desc <- function(x) {
 }
 obj_dispatch <- function(x) {
   switch(obj_type(x),
-    base = c(base_class(x), ""ANY""),
-    S3 = c(class(x), ""ANY""),
-    S4 = c(S4_class_dispatch(methods::getClass(class(x))), ""ANY""),
-    R7 = c(class(x), ""ANY"") # = class_dispatch(R7_class(x))
+    base = base_class(x),
+    S3 = class(x),
+    S4 = S4_class_dispatch(methods::getClass(class(x))),
+    R7 = class(x) # = class_dispatch(R7_class(x))
   )
 }
 

---FILE: R/class.R---
@@ -184,7 +184,7 @@ print.R7_class <- function(x, ...) {
 #' @export
 str.R7_class <- function(object, ..., nest.lev = 0) {
   cat(if (nest.lev > 0) "" "")
-  cat(""<"", paste0(setdiff(class_dispatch(object), ""ANY""), collapse = ""/""), ""> constructor"", sep = """")
+  cat(""<"", paste0(class_dispatch(object), collapse = ""/""), ""> constructor"", sep = """")
   cat(""\n"")
 
   if (nest.lev == 0) {
@@ -233,7 +233,7 @@ new_object <- function(.parent, ...) {
 
   object <- .parent %||% class_construct(class@parent)
   attr(object, ""R7_class"") <- class
-  class(object) <- setdiff(class_dispatch(class), ""ANY"")
+  class(object) <- class_dispatch(class)
 
   for (nme in nms) {
     prop(object, nme, check = FALSE) <- args[[nme]]

---FILE: R/convert.R---
@@ -58,7 +58,7 @@ convert <- function(from, to, ...) {
     } else if (is_class(to)) {
       from <- zap_attr(from, setdiff(from_props, names(to@properties)))
       attr(from, ""R7_class"") <- to
-      class(from) <- setdiff(class_dispatch(to), ""ANY"")
+      class(from) <- class_dispatch(to)
     } else {
       stop(""Unreachable"")
     }

---FILE: R/method-introspect.R---
@@ -62,6 +62,7 @@ method <- function(generic, class = NULL, object = NULL) {
 #' method_explain(add, list(foo2, foo2))
 method_explain <- function(generic, class = NULL, object = NULL) {
   dispatch <- as_dispatch(generic, class = class, object = object)
+  dispatch <- lapply(dispatch, c, ""ANY"")
 
   grid <- as.matrix(rev(do.call(""expand.grid"", rev(dispatch))))
   colnames(grid) <- generic@dispatch_args

---FILE: src/init.c---
@@ -18,11 +18,13 @@ static const R_CallMethodDef CallEntries[] = {
 
 SEXP parent_sym;
 SEXP name_sym;
+SEXP ANY_sym;
 
 void R_init_R7(DllInfo *dll)
 {
     R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
     R_useDynamicSymbols(dll, FALSE);
     parent_sym = Rf_install(""parent"");
     name_sym = Rf_install(""name"");
+    ANY_sym = Rf_install(""ANY"");
 }

---FILE: src/method-dispatch.c---
@@ -4,6 +4,7 @@
 
 extern SEXP parent_sym;
 extern SEXP name_sym;
+extern SEXP ANY_sym;
 
 // Recursively walk through method table to perform iterated dispatch
 SEXP method_rec(SEXP table, SEXP signature, R_xlen_t signature_itr) {
@@ -23,6 +24,16 @@ SEXP method_rec(SEXP table, SEXP signature, R_xlen_t signature_itr) {
       return val;
     }
   }
+
+  // ANY fallback
+  SEXP val = Rf_findVarInFrame(table, ANY_sym);
+  if (TYPEOF(val) == ENVSXP) {
+    val = method_rec(val, signature, signature_itr + 1);
+  }
+  if (TYPEOF(val) == CLOSXP) {
+    return val;
+  }
+
   return R_NilValue;
 }
 

---FILE: tests/testthat/_snaps/convert.md---
@@ -4,6 +4,6 @@
       convert(obj, to = class_double)
     Error <simpleError>
       Can't find method for generic `convert()` with dispatch classes:
-      - from: converttest, R7_object, ANY
+      - from: converttest, R7_object
       - to  : double
 

---FILE: tests/testthat/_snaps/method-dispatch.md---
@@ -5,18 +5,18 @@
 # method lookup fails with informative messages
 
     Can't find method for generic `foo()` with dispatch classes:
-    - x: logical, ANY
+    - x: logical
     - y: MISSING
 
 ---
 
     Can't find method for generic `foo()` with dispatch classes:
-    - x: logical, ANY
-    - y: list, ANY
+    - x: logical
+    - y: list
 
 ---
 
     Can't find method for generic `foo()` with dispatch classes:
-    - x: tbl_df, tbl, data.frame, ANY
-    - y: POSIXct, POSIXt, ANY
+    - x: tbl_df, tbl, data.frame
+    - y: POSIXct, POSIXt
 

---FILE: tests/testthat/test-class-spec.R---
@@ -3,7 +3,7 @@ test_that(""can work with R7 classes"", {
   expect_equal(as_class(klass), klass)
 
   expect_equal(class_type(klass), ""R7"")
-  expect_equal(class_dispatch(klass), c(""klass"", ""R7_object"", ""ANY""))
+  expect_equal(class_dispatch(klass), c(""klass"", ""R7_object""))
   expect_equal(class_register(klass), ""klass"")
   expect_equal(class_construct(klass), klass())
   expect_equal(class_desc(klass), ""<klass>"")
@@ -12,7 +12,7 @@ test_that(""can work with R7 classes"", {
   obj <- klass()
   expect_equal(obj_type(obj), ""R7"")
   expect_equal(obj_desc(obj), ""<klass>"")
-  expect_equal(obj_dispatch(obj), c(""klass"", ""R7_object"", ""ANY""))
+  expect_equal(obj_dispatch(obj), c(""klass"", ""R7_object""))
   expect_equal(class_inherits(obj, klass), TRUE)
 })
 
@@ -21,7 +21,7 @@ test_that(""can work with R7 classes in packages"", {
   expect_equal(as_class(klass), klass)
 
   expect_equal(class_type(klass), ""R7"")
-  expect_equal(class_dispatch(klass), c(""pkg::klass"", ""R7_object"", ""ANY""))
+  expect_equal(class_dispatch(klass), c(""pkg::klass"", ""R7_object""))
   expect_equal(class_register(klass), ""pkg::klass"")
   expect_equal(class_construct(klass), klass())
   expect_equal(class_desc(klass), ""<pkg::klass>"")
@@ -30,7 +30,7 @@ test_that(""can work with R7 classes in packages"", {
   obj <- klass()
   expect_equal(obj_type(obj), ""R7"")
   expect_equal(obj_desc(obj), ""<pkg::klass>"")
-  expect_equal(obj_dispatch(obj), c(""pkg::klass"", ""R7_object"", ""ANY""))
+  expect_equal(obj_dispatch(obj), c(""pkg::klass"", ""R7_object""))
   expect_equal(class_inherits(obj, klass), TRUE)
 })
 
@@ -57,15 +57,15 @@ test_that(""handles NULL"", {
   expect_equal(as_class(NULL), NULL)
 
   expect_equal(class_type(NULL), ""NULL"")
-  expect_equal(class_dispatch(NULL), c(""NULL"", ""ANY""))
+  expect_equal(class_dispatch(NULL), ""NULL"")
   expect_equal(class_register(NULL), ""NULL"")
   expect_equal(class_construct(NULL), NULL)
   expect_equal(class_desc(NULL), ""<NULL>"")
   expect_equal(class_deparse(NULL), ""NULL"")
 
   expect_equal(obj_type(NULL), ""base"")
   expect_equal(obj_desc(NULL), ""<NULL>"")
-  expect_equal(obj_dispatch(NULL), c(""NULL"", ""ANY""))
+  expect_equal(obj_dispatch(NULL), ""NULL"")
   expect_equal(class_inherits(""x"", NULL), FALSE)
   expect_equal(class_inherits(NULL, NULL), TRUE)
 })
@@ -75,7 +75,7 @@ test_that(""handles NULL"", {
 test_that(""can work with base types"", {
   klass <- class_character
   expect_equal(class_type(klass), ""R7_base"")
-  expect_equal(class_dispatch(klass), c(""character"", ""R7_object"", ""ANY""))
+  expect_equal(class_dispatch(klass), c(""character"", ""R7_object""))
   expect_equal(class_register(klass), ""character"")
   expect_equal(class_desc(klass), ""<character>"")
   expect_equal(class_construct(klass, ""x""), ""x"")
@@ -84,7 +84,7 @@ test_that(""can work with base types"", {
   obj <- ""x""
   expect_equal(obj_type(obj), ""base"")
   expect_equal(obj_desc(obj), ""<character>"")
-  expect_equal(obj_dispatch(obj), c(""character"", ""ANY""))
+  expect_equal(obj_dispatch(obj), ""character"")
   expect_equal(class_inherits(obj, klass), TRUE)
 })
 
@@ -103,20 +103,20 @@ test_that(""class_inherits handles variation in class names"", {
 })
 
 test_that(""dispatch for base objects use underlying type"", {
-  expect_equal(obj_dispatch(1), c(""double"", ""ANY""))
-  expect_equal(obj_dispatch(1L), c(""integer"", ""ANY""))
+  expect_equal(obj_dispatch(1), ""double"")
+  expect_equal(obj_dispatch(1L), ""integer"")
 
-  expect_equal(obj_dispatch(matrix(1)), c(""double"", ""ANY""))
-  expect_equal(obj_dispatch(matrix(1L)), c(""integer"", ""ANY""))
+  expect_equal(obj_dispatch(matrix(1)), ""double"")
+  expect_equal(obj_dispatch(matrix(1L)), ""integer"")
 
-  expect_equal(obj_dispatch(array(1)), c(""double"", ""ANY""))
-  expect_equal(obj_dispatch(array(1L)), c(""integer"", ""ANY""))
+  expect_equal(obj_dispatch(array(1)), ""double"")
+  expect_equal(obj_dispatch(array(1L)), ""integer"")
 
-  expect_equal(obj_dispatch(function() {}), c(""function"", ""ANY""))
-  expect_equal(obj_dispatch(sum), c(""function"", ""ANY""))
-  expect_equal(obj_dispatch(`[`), c(""function"", ""ANY""))
+  expect_equal(obj_dispatch(function() {}), ""function"")
+  expect_equal(obj_dispatch(sum), ""function"")
+  expect_equal(obj_dispatch(`[`), ""function"")
 
-  expect_equal(obj_dispatch(quote({})), c(""call"", ""ANY""))
+  expect_equal(obj_dispatch(quote({})), ""call"")
 })
 
 # S3 ----------------------------------------------------------------------
@@ -128,7 +128,7 @@ test_that(""can work with S3 classes"", {
   expect_equal(as_class(klass), klass)
 
   expect_equal(class_type(klass), ""R7_S3"")
-  expect_equal(class_dispatch(klass), c(""ordered"", ""factor"", ""R7_object"", ""ANY""))
+  expect_equal(class_dispatch(klass), c(""ordered"", ""factor"", ""R7_object""))
   expect_equal(class_register(klass), ""ordered"")
   expect_equal(class_desc(klass), ""S3<ordered/factor>"")
   expect_equal(class_construct(klass), ordered(numeric()))
@@ -137,7 +137,7 @@ test_that(""can work with S3 classes"", {
   obj <- ordered(integer())
   expect_equal(obj_type(obj), ""S3"")
   expect_equal(obj_desc(obj), ""S3<ordered/factor>"")
-  expect_equal(obj_dispatch(obj), c(""ordered"", ""factor"", ""ANY""))
+  expect_equal(obj_dispatch(obj), c(""ordered"", ""factor""))
   expect_equal(class_inherits(obj, klass), TRUE)
   expect_equal(class_inherits(factor(), klass), FALSE)
 })
@@ -147,13 +147,13 @@ test_that(""can work with R7 classes that extend S3 classes"", {
   Date2 <- new_class(""Date2"", parent = Date, properties = list(x = class_numeric))
 
   expect_equal(class_type(Date2), ""R7"")
-  expect_equal(class_dispatch(Date2), c(""Date2"", ""Date"", ""R7_object"", ""ANY""))
+  expect_equal(class_dispatch(Date2), c(""Date2"", ""Date"", ""R7_object""))
   expect_equal(class_register(Date2), ""Date2"")
 
   obj <- Date2(x = 1)
   expect_equal(obj_type(obj), ""R7"")
   expect_equal(obj_desc(obj), ""<Date2>"")
-  expect_equal(obj_dispatch(obj), c(""Date2"", ""Date"", ""R7_object"", ""ANY""))
+  expect_equal(obj_dispatch(obj), c(""Date2"", ""Date"", ""R7_object""))
   expect_equal(class_inherits(.Date(1), Date), TRUE)
   expect_equal(class_inherits(obj, Date), TRUE)
   expect_equal(class_inherits(obj, Date2), TRUE)
@@ -172,7 +172,7 @@ test_that(""can work with S4 classes"", {
   klass <- methods::getClass(""Foo4"")
 
   expect_equal(class_type(klass), ""S4"")
-  expect_equal(class_dispatch(klass), c(""S4/Foo4"", ""S4/Foo2"", ""S4/Foo3"", ""S4/Foo1"", ""character"", ""ANY""))
+  expect_equal(class_dispatch(klass), c(""S4/Foo4"", ""S4/Foo2"", ""S4/Foo3"", ""S4/Foo1"", ""character""))
   expect_equal(class_register(klass), ""S4/Foo4"")
   expect_s4_class(class_construct(klass, 1, x = 2), ""Foo4"")
   expect_equal(class_desc(klass), ""S4<Foo4>"")

---FILE: tests/testthat/test-method-dispatch.R---
@@ -2,11 +2,12 @@ describe(""single dispatch"", {
   foo <- new_generic(""foo"", ""x"")
 
   it(""works for specials"", {
-    method(foo, class_missing) <- function(x) ""missing""
     method(foo, class_any) <- function(x) ""fallback""
+    expect_equal(foo(), ""fallback"")
+    expect_equal(foo(1), ""fallback"")
 
+    method(foo, class_missing) <- function(x) ""missing""
     expect_equal(foo(), ""missing"")
-    expect_equal(foo(1), ""fallback"")
   })
 
   it(""works for base types"", {"
RConsortium,S7,3aeff42f2aa1be39404a7b13182c6b6cba05ef0c,Hadley Wickham,h.wickham@gmail.com,2022-03-23T22:57:25Z,Hadley Wickham,h.wickham@gmail.com,2022-03-23T22:57:25Z,"Show generic name in print method

Fixes #216",R/generic.R;R/utils.R;tests/testthat/_snaps/generic.md,False,True,True,False,6,7,13,"---FILE: R/generic.R---
@@ -110,7 +110,7 @@ check_dispatch_args <- function(dispatch_args, fun = NULL) {
 #' @export
 print.R7_generic <- function(x, ...) {
   methods <- methods(x)
-  formals <- paste0(head(format(args(x)), n = -1), collapse = ""\n"")
+  formals <- show_args(formals(x), x@name)
   cat(sprintf(""<R7_generic> %s with %i methods:\n"", formals, length(methods)), sep = """")
 
   if (length(methods) > 0) {

---FILE: R/utils.R---
@@ -108,13 +108,13 @@ check_function <- function(f, args, arg = deparse(substitute(f))) {
     stop(msg, call. = FALSE)
   }
 }
-show_args <- function(x) {
+show_args <- function(x, name = ""function"") {
   if (length(x) == 0) {
     args <- """"
   } else {
     val <- vcapply(x, deparse1)
     args <- paste0(names(x), ifelse(val == """", """", "" = ""), val, collapse = "", "")
   }
 
-  paste0(""function("", args, "")"")
+  paste0(name, ""("", args, "")"")
 }

---FILE: tests/testthat/_snaps/generic.md---
@@ -53,13 +53,13 @@
     Code
       foo1
     Output
-      <R7_generic> function (x, ...)  with 2 methods:
+      <R7_generic> foo1(x, ...) with 2 methods:
       1: method(foo1, ""character"")
       2: method(foo1, text)
     Code
       foo3
     Output
-      <R7_generic> function (x, y, z, ...)  with 3 methods:
+      <R7_generic> foo3(x, y, z, ...) with 3 methods:
       1: method(foo3, list(""character"", ""integer"", ""character""))
       2: method(foo3, list(""character"", ""integer"", ""logical""))
       3: method(foo3, list(""character"", text, ""character""))
@@ -69,8 +69,7 @@
     Code
       foo
     Output
-      <R7_generic> function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, 
-          r, s, t, u, v, w, x, y, z, ...)  with 0 methods:
+      <R7_generic> foo(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, ...) with 0 methods:
 
 # check_generic produces informative errors
 "
RConsortium,S7,7585772b335617541495041f35fbd093e1b4ceeb,Hadley Wickham,h.wickham@gmail.com,2022-03-21T15:50:49Z,GitHub,noreply@github.com,2022-03-21T15:50:49Z,"Implement R7_inherits() and check_R7_inherits() (#213)

Fixes #193",NAMESPACE;NEWS.md;R/inherits.R;_pkgdown.yml;man/R7_inherits.Rd;tests/testthat/_snaps/inherits.md;tests/testthat/test-inherits.R,False,True,True,False,109,0,109,"---FILE: NAMESPACE---
@@ -32,8 +32,10 @@ export(""props<-"")
 export(R7_class)
 export(R7_data)
 export(R7_dispatch)
+export(R7_inherits)
 export(R7_object)
 export(as_class)
+export(check_R7_inherits)
 export(class_any)
 export(class_atomic)
 export(class_character)

---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # R7 0.0.0.9000
 
+* New `R7_inherits()` and `check_R7_inherits()` (#193)
+
 * `new_class()` can create abstract classes (#199).
 
 * `method_call()` is now `R7_dispatch()` (#200).

---FILE: R/inherits.R---
@@ -0,0 +1,34 @@
+#' Does this object inherit from an R7 class?
+#'
+#' * `R7_inherits()` returns `TRUE` or `FALSE`.
+#' * `check_R7_inherits()` throws an error.
+#'
+#' @param x An object
+#' @param class An R7 class
+#' @param arg Argument name used in error message.
+#' @export
+#' @examples
+#' foo1 <- new_class(""foo1"")
+#' foo2 <- new_class(""foo2"")
+#'
+#' R7_inherits(foo1(), foo1)
+#' check_R7_inherits(foo1(), foo1)
+#'
+#' R7_inherits(foo1(), foo2)
+#' try(check_R7_inherits(foo1(), foo2))
+R7_inherits <- function(x, class) {
+  if (!inherits(class, ""R7_class"")) {
+    stop(""`class` is not an <R7_class>"")
+  }
+
+  inherits(x, ""R7_object"") && inherits(x, R7_class_name(class))
+}
+
+#' @export
+#' @rdname R7_inherits
+check_R7_inherits <- function(x, class, arg = deparse(substitute(x))) {
+  if (!R7_inherits(x, class)) {
+    stop(sprintf(""`%s` is not a %s"", arg, class_desc(class)), call. = FALSE)
+  }
+  invisible()
+}

---FILE: _pkgdown.yml---
@@ -10,6 +10,7 @@ reference:
   - new_generic
   - new_union
   - method<-
+  - R7_inherits
   - validate
 
 - title: Properties

---FILE: man/R7_inherits.Rd---
@@ -0,0 +1,34 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/inherits.R
+\name{R7_inherits}
+\alias{R7_inherits}
+\alias{check_R7_inherits}
+\title{Does this object inherit from an R7 class?}
+\usage{
+R7_inherits(x, class)
+
+check_R7_inherits(x, class, arg = deparse(substitute(x)))
+}
+\arguments{
+\item{x}{An object}
+
+\item{class}{An R7 class}
+
+\item{arg}{Argument name used in error message.}
+}
+\description{
+\itemize{
+\item \code{R7_inherits()} returns \code{TRUE} or \code{FALSE}.
+\item \code{check_R7_inherits()} throws an error.
+}
+}
+\examples{
+foo1 <- new_class(""foo1"")
+foo2 <- new_class(""foo2"")
+
+R7_inherits(foo1(), foo1)
+check_R7_inherits(foo1(), foo1)
+
+R7_inherits(foo1(), foo2)
+try(check_R7_inherits(foo1(), foo2))
+}

---FILE: tests/testthat/_snaps/inherits.md---
@@ -0,0 +1,16 @@
+# checks that input is a class
+
+    Code
+      R7_inherits(1:10, ""x"")
+    Error <simpleError>
+      `class` is not an <R7_class>
+
+# throws informative error
+
+    Code
+      foo1 <- new_class(""foo1"")
+      foo2 <- new_class(""foo2"")
+      check_R7_inherits(foo1(), foo2)
+    Error <simpleError>
+      `foo1()` is not a <foo2>
+

---FILE: tests/testthat/test-inherits.R---
@@ -0,0 +1,20 @@
+test_that(""it works"", {
+  foo1 <- new_class(""foo1"")
+  foo2 <- new_class(""foo2"", parent = foo1)
+
+  expect_true(R7_inherits(foo1(), foo1))
+  expect_true(R7_inherits(foo2(), foo1))
+  expect_false(R7_inherits(foo1(), foo2))
+})
+
+test_that(""checks that input is a class"", {
+  expect_snapshot(R7_inherits(1:10, ""x""), error = TRUE)
+})
+
+test_that(""throws informative error"", {
+  expect_snapshot(error = TRUE, {
+    foo1 <- new_class(""foo1"")
+    foo2 <- new_class(""foo2"")
+    check_R7_inherits(foo1(), foo2)
+  })
+})"
RConsortium,S7,1a6045265241035b62d31e01715ebf6fe4ae421f,Hadley Wickham,h.wickham@gmail.com,2022-03-18T18:50:28Z,GitHub,noreply@github.com,2022-03-18T18:50:28Z,"General documentation improvements (#187)

Certainly still lots of work to do, but this gets some coverage of the basics.

Fixes #53. Fixes #7.",R/external-generic.R;README.Rmd;README.md;_pkgdown.yml;man/new_external_generic.Rd;vignettes/R7.Rmd;vignettes/case_studies.Rmd;vignettes/compatibility.Rmd;vignettes/dispatch.Rmd,True,True,True,False,990,349,1339,"---FILE: R/external-generic.R---
@@ -1,19 +1,12 @@
-#' Generics in suggested packages
+#' Generics in other packages
 #'
 #' @description
-#' The easiest way to define a method for a generic in another package is to
-#' add the package to `Imports` and import the generic into the `NAMESPACE`.
-#' This, however, creates a strong dependency on the other package, which is
-#' not always desired. For example, you might want to register a
-#' `knitr::knitr_print` method to customise how your object is printed in Rmd,
-#' but your package doesn't use anything else from knitr.
-#'
-#' Instead, you can add the package to `Suggests` and use
-#' `new_external_generic()` along with `external_methods_register()` to declare
-#' an ""external"" generic. `new_external_generic()` defines the ""shape"" of the
-#' generic without requiring the other package be available. You then call
-#' `external_methods_register()` in `.onLoad()` to dynamically register the
-#' methods when the other package is loaded.
+#' To register a method for a generic in another packages you need to
+#' `new_external_generic()` and `external_methods_register()` together.
+#' `new_external_generic()` defines the ""shape"" of the generic without
+#' requiring the other package be available. You then call
+#' `external_methods_register()` in `.onLoad()` to dynamically register
+#' the methods when the other package is loaded.
 #'
 #' @param package Package the generic is defined in.
 #' @param name Name of generic, as a string.

---FILE: README.Rmd---
@@ -22,12 +22,12 @@ knitr::opts_chunk$set(
 <!-- badges: end -->
 
 The R7 package is a new OOP system designed to be a successor to S3 and S4.
-It it is designed and implemented collaboratively by the RConsortium Object-oriented Programming Working Group, which includes representatives from R-Core, BioConductor, RStudio/tidyverse, and the wider R community.
+It has been designed and implemented collaboratively by the RConsortium Object-Oriented Programming Working Group, which includes representatives from R-Core, BioConductor, RStudio/tidyverse, and the wider R community.
 
 ## Installation
 
 The long-term goal of this project is to merge R7 in to base R.
-For now, you can experiment with the development version from GitHub:
+For now, you can experiment by installing the in-development version from GitHub:
 
 ```{r, eval = FALSE}
 # install.packages(""remotes"")
@@ -36,12 +36,24 @@ remotes::install_github(""r-consortium/OOP-WG"")
 
 ## Usage
 
-```{r error = TRUE}
+This section gives a very brief overview of the entirety of R7.
+Learn more of the basics in `vignettte(""R7"")`, the details of method dispatch in `vignette(""dispatch"")`, and compatibility with S3 and S4 in `vignette(""compatibility"")`.
+
+```{r}
 library(R7)
+```
+
+### Classes and objects
+
+R7 classes have a formal definition, which includes a list of properties and an optional validator.
+Use `new_class()` to define a class:
 
-# Define a class
-Range <- new_class(""Range"",
-  properties = list(start = class_numeric, end = class_numeric),
+```{r}
+range <- new_class(""range"",
+  properties = list(
+    start = class_double, 
+    end = class_double
+  ),
   validator = function(self) {
     if (length(self@start) != 1) {
       ""@start must be length 1""
@@ -52,35 +64,79 @@ Range <- new_class(""Range"",
     }
   }
 )
+```
+
+`new_class()` returns the class object, which is also the constructor you use to create instances of the class:
 
-# Create an object from that class
-x <- Range(start = 1, end = 10)
+```{r}
+x <- range(start = 1, end = 10)
 x
+```
 
-# Get and set properties
+### Properties
+
+The data possessed by an object is called its **properties**.
+Use `@` to get and set properties:
+
+```{r}
 x@start
 x@end <- 20
 x
+```
+
+Properties are automatically validated against the type declared in `new_class()` (`double` in this case), and with the class **validator**:
 
-# Can't set invalid properties
+```{r, error = TRUE}
 x@end <- ""x""
 x@end <- -1
+```
 
-# Define methods for existing S3 generics
-method(format, Range) <- function(x, ...) paste0(""["", x@start, "", "", x@end, ""]"")
-format(x)
+### Generics and methods
 
-method(mean, Range) <- function(x, ...) (x@start + x@end) / 2
-mean(x)
+Like S3 and S4, R7 uses **functional OOP** where methods belong to **generic** functions, and method calls look like all other function calls: `generic(object, arg2, arg3)`.
+This style is called functional because from the outside it looks like a regular function call, and internally the components are also functions.
 
-# Create a new generic
+Use `new_generic()` to create a new generic: the first argument is the generic name (used in error messages) and the second gives the arguments used for dispatch.
+The third, and optional argument, supplies the body of the generic.
+This is only needed if your generic has additional arguments that aren't used for method dispatch.
+
+```{r}
 inside <- new_generic(""inside"", ""x"", function(x, y) {
   # Actually finds and calls the appropriate method
   R7_dispatch()
 })
+```
+
+Once you have a generic, you can define a method for a specific class with `method<-`:
+
+```{r}
 # Add a method for our class
-method(inside, Range) <- function(x, y) y >= x@start & y <= x@end
+method(inside, range) <- function(x, y) {
+  y >= x@start & y <= x@end
+}
 inside
 
 inside(x, c(0, 5, 10, 15))
 ```
+
+You can use `method<-` to register methods for base types on R7 generics:
+
+```{r}
+method(inside, class_numeric) <- function(x, y) {
+  y >= min(x) & y <= max(x)
+}
+```
+
+And register methods for R7 classes on S3 or S4 generics:
+
+```{r}
+method(format, range) <- function(x, ...) {
+  paste0(""["", x@start, "", "", x@end, ""]"")
+}
+format(x)
+
+method(mean, range) <- function(x, ...) {
+  (x@start + x@end) / 2
+}
+mean(x)
+```

---FILE: README.md---
@@ -12,15 +12,15 @@ coverage](https://codecov.io/gh/RConsortium/OOP-WG/branch/master/graph/badge.svg
 <!-- badges: end -->
 
 The R7 package is a new OOP system designed to be a successor to S3 and
-S4. It it is designed and implemented collaboratively by the RConsortium
-Object-oriented Programming Working Group, which includes
+S4. It has been designed and implemented collaboratively by the
+RConsortium Object-Oriented Programming Working Group, which includes
 representatives from R-Core, BioConductor, RStudio/tidyverse, and the
 wider R community.
 
 ## Installation
 
 The long-term goal of this project is to merge R7 in to base R. For now,
-you can experiment with the development version from GitHub:
+you can experiment by installing the in-development version from GitHub:
 
 ``` r
 # install.packages(""remotes"")
@@ -29,12 +29,26 @@ remotes::install_github(""r-consortium/OOP-WG"")
 
 ## Usage
 
+This section gives a very brief overview of the entirety of R7. Learn
+more of the basics in `vignettte(""R7"")`, the details of method dispatch
+in `vignette(""dispatch"")`, and compatibility with S3 and S4 in
+`vignette(""compatibility"")`.
+
 ``` r
 library(R7)
+```
+
+### Classes and objects
 
-# Define a class
-Range <- new_class(""Range"",
-  properties = list(start = class_numeric, end = class_numeric),
+R7 classes have a formal definition, which includes a list of properties
+and an optional validator. Use `new_class()` to define a class:
+
+``` r
+range <- new_class(""range"",
+  properties = list(
+    start = class_double, 
+    end = class_double
+  ),
   validator = function(self) {
     if (length(self@start) != 1) {
       ""@start must be length 1""
@@ -45,50 +59,103 @@ Range <- new_class(""Range"",
     }
   }
 )
+```
+
+`new_class()` returns the class object, which is also the constructor
+you use to create instances of the class:
 
-# Create an object from that class
-x <- Range(start = 1, end = 10)
+``` r
+x <- range(start = 1, end = 10)
 x
-#> <Range>
+#> <range>
 #>  @ start: num 1
 #>  @ end  : num 10
+```
+
+### Properties
 
-# Get and set properties
+The data possessed by an object is called its **properties**. Use `@` to
+get and set properties:
+
+``` r
 x@start
 #> [1] 1
 x@end <- 20
 x
-#> <Range>
+#> <range>
 #>  @ start: num 1
 #>  @ end  : num 20
+```
 
-# Can't set invalid properties
+Properties are automatically validated against the type declared in
+`new_class()` (`double` in this case), and with the class **validator**:
+
+``` r
 x@end <- ""x""
-#> Error: <Range>@end must be <integer> or <double>, not <character>
+#> Error: <range>@end must be <double>, not <character>
 x@end <- -1
-#> Error: <Range> object is invalid:
+#> Error: <range> object is invalid:
 #> - @end must be greater than or equal to @start
+```
 
-# Define methods for existing S3 generics
-method(format, Range) <- function(x, ...) paste0(""["", x@start, "", "", x@end, ""]"")
-format(x)
-#> [1] ""[1, 20]""
+### Generics and methods
 
-method(mean, Range) <- function(x, ...) (x@start + x@end) / 2
-mean(x)
-#> [1] 10.5
+Like S3 and S4, R7 uses **functional OOP** where methods belong to
+**generic** functions, and method calls look like all other function
+calls: `generic(object, arg2, arg3)`. This style is called functional
+because from the outside it looks like a regular function call, and
+internally the components are also functions.
 
-# Create a new generic
+Use `new_generic()` to create a new generic: the first argument is the
+generic name (used in error messages) and the second gives the arguments
+used for dispatch. The third, and optional argument, supplies the body
+of the generic. This is only needed if your generic has additional
+arguments that aren’t used for method dispatch.
+
+``` r
 inside <- new_generic(""inside"", ""x"", function(x, y) {
   # Actually finds and calls the appropriate method
   R7_dispatch()
 })
+```
+
+Once you have a generic, you can define a method for a specific class
+with `method<-`:
+
+``` r
 # Add a method for our class
-method(inside, Range) <- function(x, y) y >= x@start & y <= x@end
+method(inside, range) <- function(x, y) {
+  y >= x@start & y <= x@end
+}
 inside
 #> <R7_generic> function (x, y)  with 1 methods:
-#> 1: method(inside, Range)
+#> 1: method(inside, range)
 
 inside(x, c(0, 5, 10, 15))
 #> [1] FALSE  TRUE  TRUE  TRUE
 ```
+
+You can use `method<-` to register methods for base types on R7
+generics:
+
+``` r
+method(inside, class_numeric) <- function(x, y) {
+  y >= min(x) & y <= max(x)
+}
+```
+
+And register methods for R7 classes on S3 or S4 generics:
+
+``` r
+method(format, range) <- function(x, ...) {
+  paste0(""["", x@start, "", "", x@end, ""]"")
+}
+format(x)
+#> [1] ""[1, 20]""
+
+method(mean, range) <- function(x, ...) {
+  (x@start + x@end) / 2
+}
+mean(x)
+#> [1] 10.5
+```

---FILE: _pkgdown.yml---
@@ -38,7 +38,8 @@ articles:
   navbar: ~
   contents:
   - R7
-  - case_studies
+  - dispatch
+  - compatibility
   - performance
 
 - title: Initial design and specification

---FILE: man/new_external_generic.Rd---
@@ -3,7 +3,7 @@
 \name{new_external_generic}
 \alias{new_external_generic}
 \alias{external_methods_register}
-\title{Generics in suggested packages}
+\title{Generics in other packages}
 \usage{
 new_external_generic(package, name, dispatch_args, version = NULL)
 
@@ -20,17 +20,10 @@ external_methods_register()
 be registered.}
 }
 \description{
-The easiest way to define a method for a generic in another package is to
-add the package to \code{Imports} and import the generic into the \code{NAMESPACE}.
-This, however, creates a strong dependency on the other package, which is
-not always desired. For example, you might want to register a
-\code{knitr::knitr_print} method to customise how your object is printed in Rmd,
-but your package doesn't use anything else from knitr.
-
-Instead, you can add the package to \code{Suggests} and use
-\code{new_external_generic()} along with \code{external_methods_register()} to declare
-an ""external"" generic. \code{new_external_generic()} defines the ""shape"" of the
-generic without requiring the other package be available. You then call
-\code{external_methods_register()} in \code{.onLoad()} to dynamically register the
-methods when the other package is loaded.
+To register a method for a generic in another packages you need to
+\code{new_external_generic()} and \code{external_methods_register()} together.
+\code{new_external_generic()} defines the ""shape"" of the generic without
+requiring the other package be available. You then call
+\code{external_methods_register()} in \code{.onLoad()} to dynamically register
+the methods when the other package is loaded.
 }

---FILE: vignettes/R7.Rmd---
@@ -1,8 +1,8 @@
 ---
-title: ""R7""
+title: ""R7 basics""
 output: rmarkdown::html_vignette
 vignette: >
-  %\VignetteIndexEntry{R7}
+  %\VignetteIndexEntry{R7 basics}
   %\VignetteEngine{knitr::rmarkdown}
   %\VignetteEncoding{UTF-8}
 ---
@@ -14,136 +14,392 @@ knitr::opts_chunk$set(
 )
 ```
 
+The R7 package is provides a new OOP system designed to be a successor to S3 and S4.
+It has been designed and implemented collaboratively by the RConsortium Object-Oriented Programming Working Group, which includes representatives from R-Core, BioConductor, RStudio/tidyverse, and the wider R community.
+
+This vignette describes how R7 works, starting with an overview of classes, objects, generics, and methods, then going into the details of validation and properties.
+
 ```{r setup}
 library(R7)
 ```
 
-## Classes and objects
+## Basics
+
+We'll start with an quick overview of the most important parts of R7: classes and objects, generics and methods, and the basics of method dispatch and inheritance.
+
+### Classes and objects
+
+R7 classes have a formal definition that you create with `new_class()`.
+There are two arguments that you'll use with almost every class:
+
+-   The `name` of the class, supplied in the first argument.
+-   The class `properties`, the data associated with each instance of the class. The easiest way to define properties is to supply a named list where the values define the valid types of the property.
+
+The following code defines a simple `pet` class with two properties: a character `name` and a numeric `age`.
 
 ```{r}
-range <- new_class(""range"",
-  validator = function(self) {
-    if (self@end < self@start) {
-      ""<range>@end must be greater than or equal to <range>@start""
-    }
-  },
-  properties = list(
-    start = class_numeric,
-    end = class_numeric,
-    length = new_property(
-      class = class_numeric,
-      getter = function(self) self@end - self@start,
-      setter = function(self, value) {
-        self@end <- self@start + value
-        self
-      }
-    )
-  )
-)
+dog <- new_class(""dog"", properties = list(
+  name = class_character,
+  age = class_numeric
+))
+dog
+```
 
-x <- range(start = 1, end = 10)
+R7 provides a number of built-in definitions that allow you to refer to existing base types that are not R7 classes.
+You can recognize these definitions because they all start with `class_`.
 
-x@start
+Note that I've assigned the return value of `new_class()` to an object with the same name as the class.
+This is important!
+That object represents the class and is what you use to construct instances of the class:
 
-x@end
+```{r}
+lola <- dog(name = ""Lola"", age = 11)
+lola
+```
 
-x@length
+Once you have an R7 object, you can get and set properties using `@`:
 
-x@length <- 5
+```{r}
+lola@age <- 11
+lola@age
+```
 
-x@length
+R7 automatically validates the type of the property using the type supplied in `new_class()`:
+
+```{r, error = TRUE}
+lola@age <- ""twelve""
 ```
 
-```{r error = TRUE}
-# incorrect properties throws an error
-x@middle
+Given an object, you can retrieves its class `R7_class()`:
 
-# assigning properties verifies the class matches the class of the value
-x@end <- ""foo""
+```{r}
+R7_class(lola)
+```
 
-# assigning properties runs the validator
-x@end <- 0
+R7 objects also have an S3 `class()`.
+This is used for compatibility with existing S3 generics and you can learn more about it in `vignette(""compatibility"")`.
+
+```{r}
+class(lola)
 ```
 
+### Generics and methods
+
+R7, like S3 and S4, is built around the idea of **generic functions,** or **generics** for short.
+A generic defines an interface, which uses a different implementation depending on the class of one or more arguments.
+The implementation for a specific class is called a **method**, and the generic finds that appropriate method by performing **method dispatch**.
+
+Use `new_generic()` to create a R7 generic.
+In its simplest form, it only needs two arguments: the name of the generic (used in error messages) and the name of the argument used for method dispatch:
+
 ```{r}
-# Print methods for both R7_class objects
-range
+speak <- new_generic(""speak"", ""x"")
+```
 
-# As well as normal R7_objects
-x
+Like with `new_class()`, you should always assign the result of `new_generic()` to an variable with the same name as the first argument.
+
+Once you have a generic, you can register methods for specific classes with `method(generic, class) <- implementation`.
+
+```{r}
+method(speak, dog) <- function(x) {
+  ""Woof""
+}
 ```
 
-## Generics and methods
+Once the method is registered, the generic will use it when appropriate:
 
 ```{r}
-text <- new_class(""text"", parent = class_character)
-foo <- new_generic(""foo"", ""x"")
-method(foo, text) <- function(x, ...) paste0(""foo-"", x)
+speak(lola)
+```
 
-foo(text(""hi""))
+Let's define another class, this one for cats, and define another method for `speak()`:
+
+```{r}
+cat <- new_class(""cat"", properties = list(
+  name = class_character,
+  age = class_double
+))
+method(speak, cat) <- function(x) {
+  ""Meow""
+}
+
+fluffy <- cat(name = ""Fluffy"", age = 5)
+speak(fluffy)
 ```
 
-## Multiple dispatch
+You get an error if you call the generic with a class that doesn't have a method:
+
+```{r, error = TRUE}
+speak(1)
+```
 
-Multiple dispatch uses a table stored in the `methods` property of the generic.
-This table is a nested set of hashed environments based on the classes of the methods.
-e.g.
+### Method dispatch and inheritance
 
-For `method(foo, c(""character"", ""numeric""))` the method would be stored at `foo@methods[[""character""]][[""numeric""]]`.
+The `cat` and `dog` classes share the same properties, so we could use a common parent class to extract out the duplicated specification.
+We first define the parent class:
+
+```{r}
+pet <- new_class(""pet"", 
+  properties = list(
+    name = class_character,
+    age = class_numeric
+  )
+) 
+```
 
-At each level the search iteratively searches along objects class vector.
+Then use the `parent` argument to `new_class:`
 
 ```{r}
-bar <- new_generic(""bar"", c(""x"", ""y""))
-method(bar, list(class_character, class_double)) <- function(x, y) paste0(""foo-"", x, "":"", y)
+cat <- new_class(""cat"", parent = pet)
+dog <- new_class(""dog"", parent = pet)
 
-bar(""hi"", 42)
+cat
+dog
 ```
 
-## Calling the method for a parent class
+Because we have created new classes, we need to recreate the existing `lola` and `fluffy` objects:
 
-Sometimes you want to implement a method in terms of behavior already provided by its superclass.
-If you need to access a method for a superclass that your class is overriding, you can use `super()`:
+```{r}
+lola <- dog(name = ""Lola"", age = 11)
+fluffy <- cat(name = ""Fluffy"", age = 5)
+```
+
+Method dispatch takes advantage of the hierarchy of parent classes: if a method is not defined for a class, it will try the method for the parent class, and so on until it finds a method or gives up with an error.
+This inheritance is a powerful mechanism for sharing code across classes.
 
 ```{r}
-method(bar, list(text, class_double)) <- function(x, y, ...) {
-  res <- bar(super(x), y)
-  paste0(""2 "", res)
+describe <- new_generic(""describe"", ""x"")
+method(describe, pet) <- function(x) {
+  paste0(x@name, "" is "", x@age, "" years old"")
+}
+describe(lola)
+describe(fluffy)
+
+method(describe, dog) <- function(x) {
+  paste0(x@name, "" is a "", x@age, "" year old dog"")
 }
+describe(lola)
+describe(fluffy)
 ```
 
-## Non-standard evaluation
+You can define a fallback method for any R7 object by registering a method for `R7_object`:
 
-`method_call()` retains promises for dispatch arguments in basically the same way as `UseMethod()`, so non-standard evaluation works basically the same as S3.
+```{r}
+method(describe, R7_object) <- function(x) {
+  ""An R7 object""
+}
+
+cocktail <- new_class(""cocktail"", 
+  properties = list(
+    ingredients = class_character
+  )
+)
+martini <- cocktail(ingredients = c(""gin"", ""vermouth""))
+describe(martini)
+```
+
+Printing a generic will show you which methods are currently defined:
 
 ```{r}
-subset2 <- new_generic(""subset2"", ""x"")
+describe
+```
 
-method(subset2, new_S3_class(""data.frame"")) <- function(x, subset = NULL, select = NULL, drop = FALSE) {
-  e <- substitute(subset)
-  # Unlike S3, R7 creates a frame for the generic, so we need to
-  # go one extra level up to get to the user's evaluation environment
-  r <- eval(e, x, parent.frame(2))
-  r <- r & !is.na(r)
-  nl <- as.list(seq_along(x))
-  names(nl) <- names(x)
-  vars <- eval(substitute(select), nl, parent.frame())
-  x[r, vars, drop = drop]
-}
+And you can use `method()` to retrieve the implementation of one of those methods:
+
+```{r}
+method(describe, pet)
+```
+
+Learn more about method dispatch in `vignette(""dispatch"")`.
+
+## Validation
 
-subset2(mtcars, hp > 200, c(wt, qsec))
+R7 classes can have an optional **validator** that checks that the values of the properties are OK.
+A validator is a function that takes the object (called `self`) and returns `NULL` if its valid or returns a character vector listing the problems.
+
+### Basics
+
+In the following example we create a range class that enforces that `@start` and `@end` are single numbers, and that `@start` is less than `@end`:
+
+```{r}
+range <- new_class(""range"",
+  properties = list(
+    start = class_double,
+    end = class_double
+  ),
+  validator = function(self) {
+    if (length(self@start) != 1) {
+      ""@start must be length 1""
+    } else if (length(self@end) != 1) {
+      ""@end must be length 1""
+    } else if (self@end < self@start) {
+      sprintf(
+        ""@end (%i) must be greater than or equal to @start (%i)"",
+        self@end,
+        self@start
+      )
+    }
+  }
+)
 ```
 
-### External generics
+You can typically write a validator as a series of `if`-`else` statements, but note that the order of the statements is important.
+For example, in the code above, we can't check that `self@end < self@start` before we've checked that `@start` and `@end` are length 1.
+
+### When is validation performed?
 
-If you want to define methods for R7 generics defined in another package you can use `new_extrenal_generic` to declare the external generic, then add `R7::external_methods_register()` to the `.onLoad` function in your package.
-`external_methods_register()` will automatically setup on-load hooks for 'soft' dependencies in `Suggests` so the method will be added when the dependency is eventually loaded.
+Objects are validated automatically when constructed and when any property is modified:
 
-```{r eval = FALSE}
-.onLoad <- function(libname, pkgname) {
-  R7::external_methods_register()
+```{r, error = TRUE}
+x <- range(1, 2:3)
+x <- range(10, 1)
+
+x <- range(1, 10)
+x@start <- 20
+```
+
+You can also manually `validate()` an object if you use a low-level R function to bypass the usual checks and balances of `@`:
+
+```{r, error = TRUE}
+x <- range(1, 2)
+attr(x, ""start"") <- 3
+validate(x)
+```
+
+### Avoiding validation
+
+Imagine you wanted to write a function that would shift a property to the left or the right:
+
+```{r}
+shift <- function(x, shift) {
+  x@start <- x@start + shift
+  x@end <- x@end + shift
+  x
 }
+shift(range(1, 10), 1)
+```
+
+There's a problem if `shift` is larger than `@end` - `@start`:
+
+```{r, error = TRUE}
+shift(range(1, 10), 10)
+```
+
+While the end result of `shift()` will be valid, an intermediate state is not.
+The easiest way to resolve this problem is to set the properties all at once:
+
+```{r}
+shift <- function(x, shift) {
+  props(x) <- list(
+    start = x@start + shift,
+    end = x@end + shift
+  )
+  x
+}
+shift(range(1, 10), 10)
+```
+
+The object is still validated, but it's only validated once, after all the properties have been modified.
+
+## Properties
+
+So far we've focused on the simplest form of property specification where you use a named list to supply the desired type for each property.
+This is a convenient shorthand for a call to `new_property()`.
+For example, the property definition of range above is shorthand for:
+
+```{r}
+range <- new_class(""range"",
+  properties = list(
+    start = new_property(class_double),
+    end = new_property(class_double)
+  )
+)
+```
+
+Calling `new_property()` explicitly allows you to control aspects of the property other than its type.
+The following sections show you how to provide a default value, compute the property value on demand, or provide a fully dynamic property.
+
+### Default value
+
+The defaults of `new_class()` create an class that can be constructed with no arguments:
+
+```{r}
+empty <- new_class(""empty"", 
+  properties = list(
+    x = class_double,
+    y = class_character,
+    z = class_logical
+  ))
+empty()
+```
+
+The default values of the properties will be filled in with ""empty"" instances.
+You can instead provide your own defaults by using the `default` argument:
+
+```{r}
+empty <- new_class(""empty"", 
+  properties = list(
+    x = new_property(class_numeric, default = 0),
+    y = new_property(class_character, default = """"),
+    z = new_property(class_logical, default = NA)
+  )
+)
+empty()
+```
+
+### Computed properties
 
-foo <- new_external_generic(""pkg1"", ""foo"")
-method(foo, ""integer"") <- function(x) paste0(""foo-"", x)
+It's sometimes useful to have a property that is computed on demand.
+For example, it'd be convenient to pretend that our range has a length, which is just the distance between `@start` and `@end`.
+You can dynamically compute the value of a property by defining a `getter`:
+
+```{r}
+range <- new_class(""range"",
+  properties = list(
+    start = class_double,
+    end = class_double,
+    length = new_property(
+      getter = function(self) self@end - self@start,
+    )
+  )
+)
+
+x <- range(start = 1, end = 10)
+x
+```
+
+Computed properties are read-only:
+
+```{r, error = TRUE}
+x@length <- 20
 ```
+
+### Dynamic properties
+
+You can make a computed property fully dynamic so that it can be read and written by also supplying a `setter`.
+For example, we could extend the previous example to allow the `@length` to be set, by modifying the `@end` of the vector:
+
+```{r}
+range <- new_class(""range"",
+  properties = list(
+    start = class_double,
+    end = class_double,
+    length = new_property(
+      class = class_double,
+      getter = function(self) self@end - self@start,
+      setter = function(self, value) {
+        self@end <- self@start + value
+        self
+      }
+    )
+  )
+)
+
+x <- range(start = 1, end = 10)
+x
+
+x@length <- 5
+x
+```
+
+A `setter` is a function with arguments `self` and `value` that returns a modified object.

---FILE: vignettes/case_studies.Rmd---
@@ -1,197 +0,0 @@
----
-title: ""Case Studies""
-output: rmarkdown::html_vignette
-vignette: >
-  %\VignetteIndexEntry{Case Studies}
-  %\VignetteEngine{knitr::rmarkdown}
-  %\VignetteEncoding{UTF-8}
----
-
-```{r, include = FALSE}
-knitr::opts_chunk$set(
-  collapse = TRUE,
-  comment = ""#>""
-)
-```
-
-```{r setup}
-library(R7)
-```
-
-## Person class
-
-This case study demonstrates creating basic classes with accessors functions, inheritance and composition.
-
-```{r}
-Person <- new_class(""Person"",
-  properties = list(
-    name = class_character,
-    birthdate = new_property(
-      class = new_S3_class(""Date""),
-      setter = function(self, value) {
-        self@birthdate <- as.Date(value)
-        self
-      },
-      default = as.Date(NA)
-    ),
-    age = new_property(
-      class = class_numeric,
-      getter = function(self) {
-        # This is not correct because of leap years,
-        # see https://stackoverflow.com/questions/3611314/calculate-ages-in-r/25450756#25450756 for a correct implementation.
-        as.double(Sys.Date() - self@birthdate) %/% 365
-      }
-    )
-  ),
-  validator = function(self) {
-    if (length(self@name) != length(self@birthdate)) {
-      ""@name and @birthdate must be the same length""
-    }
-  }
-)
-
-jane <- Person(name = ""Jane Doe"")
-
-jane@name
-
-jane@age
-```
-
-We can modify objects after creation by assigning to a property.
-Unlike in S4 the validity is automatically checked on assignment, not just on object creation.
-
-```{r, error = TRUE}
-jane@birthdate <- ""1982-03-04""
-
-jane@age
-
-jane@birthdate <- as.Date(c(""2001-01-01"", ""2002-02-02""))
-```
-
-Classes can inherit from a parent class with `parent` and contain properties that are of complex classes.
-
-```{r}
-Employee <- new_class(""Employee"",
-  parent = Person,
-  properties = list(boss = Person)
-)
-
-x <- Employee(name = ""John Smith"", birthdate = ""1992-10-11"", boss = jane)
-
-x@name
-
-x@age
-
-x@boss
-```
-
-## Annotated Data Frame
-
-This case study implements a very basic imitation of a SummarizedExperiment class used widely in the Bioconductor community.
-
-This `annotated_df` class is a normal R `data.frame` with two additional properties
-- `rows` which holds a `data.frame` containing data about the _rows_ of the data.
-- `columns` which holds a `data.frame` containing data about the _columns_ of the data.
-
-The validator function automatically ensures consistency between the size of the data and the size of the corresponding `rows` and `columns`.
-In particular the number of rows of the `rows` property matches the number of rows of the data, and the number of rows of the `columns` property matches the number of columns of the data.
-
-Here is the definition of the class.
-```{r}
-annotated_df <- new_class(""annotated_df"",
-  properties = list(
-    data = new_S3_class(""tbl_df""),
-    rows = new_S3_class(""tbl_df""),
-    columns = new_S3_class(""tbl_df"")
-  ),
-  validator = function(self) {
-    if (nrow(self@data) != nrow(self@rows)) {
-      ""`nrow(<annotated_df>@rows)` must be equal to `nrow(<annotated_df>)`""
-    } else if (ncol(self@data) != nrow(self@columns)) {
-      ""`nrow(<annotated_df>@columns)` must be equal to `ncol(<annotated_df>)`""
-    }
-  }
-)
-```
-
-The print method tells us this is a R7 class and gives us the types for the properties in the class.
-
-```{r}
-annotated_df
-```
-
-To instantiate an instance of `annotated_df` we first need to get some data to put in it. As an example we will use the mtcars dataset. This requires some manipulation to get the `rows` and `columns` data in the right formats.
-
-```{r}
-mt <- mtcars[seq(1, 32, 4), ]
-
-splits <- strsplit(rownames(mt), "" "")
-
-mt <- tibble::as_tibble(mt)
-
-vcapply <- function(VALUE, FUN, ...) vapply(VALUE, FUN, character(1), ...)
-
-row_info <- tibble::tibble(
-  make = vcapply(splits, head, 1),
-  model = vcapply(splits, function(x) paste0(tail(x, -1), collapse = "" ""))
-)
-
-col_desc <- c(
-  ""mpg"" = ""Miles/(US) gallon"",
-  ""cyl"" = ""Number of cylinders"",
-  ""disp"" = ""Displacement (cu.in.)"",
-  ""hp"" = ""Gross horsepower"",
-  ""drat"" = ""Rear axle ratio"",
-  ""wt"" = ""Weight (1000 lbs)"",
-  ""qsec"" = ""1/4 mile time"",
-  ""vs"" = ""Engine (0 = V-shaped, 1 = straight)"",
-  ""am"" = ""Transmission (0 = automatic, 1 = manual)"",
-  ""gear"" = ""Number of forward gears"",
-  ""carb"" = ""Number of carburetors""
-)
-
-col_info <- tibble::tibble(name = names(col_desc), description = col_desc)
-
-```
-
-We can then create an instance using the constructor function.
-
-```{r}
-obj <- annotated_df(mt, row_info, col_info)
-obj@data
-
-obj@rows
-
-obj@columns
-```
-
-We next define a `R7_subset` generic function, and then a R7 method for that function, taking integer arguments for the rows and columns.
-The subsets the individual components appropriately and then returns a new `annotated_df` object with them.
-
-```{r}
-subset_R7 <- new_generic(""R7_subset"", c(""object"", ""row"", ""column""))
-
-method(subset_R7, list(annotated_df, class_integer, class_integer)) <- function(object, row, column, ...) {
-  data <- object@data[row, column]
-  rows <- object@rows[row, ]
-  columns <-  object@columns[column, ]
-  annotated_df(data, rows, columns)
-}
-```
-
-When we subset using this function we can see the consistency is retained for our data components.
-
-```{r}
-obj2 <- subset_R7(obj, 1:3, 1:5)
-
-obj2@data
-
-obj2@rows
-
-obj2@columns
-```
-
-The validation function is automatically run if you try and change a property, which ensures class integrity.
-```{r, error = TRUE}
-obj2@rows <- obj2@rows[1:2, ]
-```

---FILE: vignettes/compatibility.Rmd---
@@ -0,0 +1,155 @@
+---
+title: ""Compatibility""
+output: rmarkdown::html_vignette
+vignette: >
+  %\VignetteIndexEntry{Compatibility}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+
+```{r, include = FALSE}
+knitr::opts_chunk$set(
+  collapse = TRUE,
+  comment = ""#>""
+)
+```
+
+R7 is designed to be compatible with S3 and S4.
+This vignette discusses the details.
+
+```{r setup}
+library(R7)
+```
+
+## S3
+
+R7 objects *are* S3 objects, because R7 is implemented on top of S3.
+There are two main differences between an R7 object and an S3 object:
+
+-   As well as the `class` attribute possessed by S3 objects, R7 objects have an additional `R7_class` attribute that contains the object that defines the class.
+
+-   R7 objects have properties; S3 objects have attributes.
+    Properties are implemented on top of attributes, so you can access them directly with `attr` and friends.
+    When working inside of R7, you should never use attributes directly, but it does mean that existing code will continue to work.
+
+All up, this means most usage of R7 with S3 will just work.
+
+-   R7 can register methods for:
+
+    -   R7 class and S3 generic
+    -   S3 class and R7 generic
+
+-   R7 classes can extend S3 classes
+
+-   S3 classes can extend R7 classes
+
+### Methods
+
+`method()` is designed to be the single tool for method registration that you need when working with R7 classes.
+You can also register a method for an R7 class and S3 generic without using R7, because all R7 objects have S3 classes, and S3 dispatch will operate on them normally.
+
+```{r}
+foo <- new_class(""foo"")
+class(foo())
+
+mean.foo <- function(x, ...) {
+  ""mean of foo""
+}
+
+mean(foo())
+```
+
+### Classes
+
+It's possible to extend an R7 class with S3.
+This is primarily useful because it many cases it allows you to change a class hierarchy from the inside out: you can provide a formal definition of an S3 class using R7, and its subclasses don't need to change.
+
+### List classes
+
+Many simple S3 classes are implemented as lists, e.g. rle.
+
+```{r}
+rle <- function(x) {
+  if (!is.vector(x) && !is.list(x)) {
+    stop(""'x' must be a vector of an atomic type"")
+  }
+  n <- length(x)
+  if (n == 0L) {
+    new_rle(integer(), x)
+  } else {
+    y <- x[-1L] != x[-n]
+    i <- c(which(y | is.na(y)), n)
+    new_rle(diff(c(0L, i)), x[i])
+  }
+}
+new_rle <- function(lengths, values) {
+  structure(
+    list(
+      lengths = lengths, 
+      values = values
+    ),
+    class = ""rle""
+  )
+}
+```
+
+There are two ways to convert this to R7.
+You could keep the structure exactly the same, using a `list` as the underlying data structure and using a constructor to enforce the structure:
+
+```{r}
+new_rle <- new_class(""rle"", 
+  parent = class_list, 
+  constructor = function(lengths, values) {
+    new_object(list(lengths = lengths, values = values))
+  }
+)
+rle(1:10)
+```
+
+Alternatively you could convert it to the most natural representation using R7:
+
+```{r}
+new_rle <- new_class(""rle"", properties = list(
+  lengths = class_integer,
+  values = class_atomic
+))
+```
+
+To allow existing methods to work you'll need to override `$` to access properties instead of list elements:
+
+```{r}
+method(`$`, new_rle) <- prop
+rle(1:10)
+```
+
+The chief disadvantage of this approach is any subclasses will need to be converted to R7 as well.
+
+## S4
+
+R7 properties are equivalent to S4 slots.
+The chief difference is that they can be dynamic.
+
+-   R7 classes can not extend S4 classes
+-   S4 classes can extend S3 classes
+-   R7 can register methods for:
+    -   R7 class and S4 generic
+    -   S4 class and R7 generic
+
+### Unions
+
+S4 unions are automatically converted to R7 unions.
+There's an important difference in the way that class unions are handled in S4 and R7.
+In S4, they're handled at method dispatch time, so when you create `setUnion(""u1"", c(""class1"", ""class2""))`, `class1` and `class2` now extend `u1`.
+In R7, unions are handled at method registration time so that registering a method for a union is just short-hand for registering a method for each of the classes.
+
+```{r}
+class1 <- new_class(""class1"")
+class2 <- new_class(""class2"")
+union1 <- new_union(class1, class2)
+
+foo <- new_generic(""foo"", ""x"")
+method(foo, union1) <- function(x) """"
+foo
+```
+
+R7 unions allow you to restrict the type of a property in the same way that S4 unions allow you to restrict the type of a slot.

---FILE: vignettes/dispatch.Rmd---
@@ -0,0 +1,317 @@
+---
+title: ""R7 generics and method dispatch""
+output: rmarkdown::html_vignette
+vignette: >
+  %\VignetteIndexEntry{R7 generics and method dispatch}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+
+```{r, include = FALSE}
+knitr::opts_chunk$set(
+  collapse = TRUE,
+  comment = ""#>""
+)
+```
+
+This vignette dives into the details of R7 generics and method dispatch, building on the basics discussed in `vignette(""R7"")`.
+We'll first introduce the concept of generic-method compatibility, then discuss some of the finer details of creating a generic with `new_generic()`.
+This vignette first discusses generic-method compatibility, and you might want to customize the body of the generic, and generics that live in suggested pacages.
+We'll then pivot to talk more details of method dispatch including `super()` and multiple dispatch.
+
+```{r setup}
+library(R7)
+```
+
+## Generic-method compatibility
+
+When you register a method, R7 checks that your method is compatible with the generic.
+
+The formal arguments of the generic and methods must agree.
+This means that:
+
+-   Any arguments that the generic has, the method must have to. In particular, the arguments of the method start with the arguments that the generic dispatches on, and those arguments must not have default arguments.
+-   The method can contain arguments that the generic does not, as long as the generic includes `…` in the argument list.
+
+### Generic with dots; method without dots
+
+The default generic includes `…` but generally the methods should not.
+That ensures that misspelled arguments won't be silently swallowed by the method.
+This is an important difference from S3.
+Take a very simple implementation of `mean()`:
+
+```{r}
+mean <- new_generic(""mean"", ""x"")
+method(mean, class_numeric) <- function(x) sum(x) / length(x)
+```
+
+If we pass an additional argument in, we'll get an error:
+
+```{r, error = TRUE, eval = FALSE}
+mean(100, na.rm = TRUE)
+```
+
+But we can still add additional arguments if we desired:
+
+```{r}
+method(mean, class_numeric) <- function(x, na.rm = TRUE) {
+  if (na.rm) {
+    x <- x[!is.na(x)]
+  }
+
+  sum(x) / length(x)
+}
+mean(c(100, NA), na.rm = TRUE)
+```
+
+(We'll come back to the case of requiring that all methods implement a `na.rm = TRUE` argument shortly.)
+
+### Generic and method with dots
+
+There are cases where you do need to take `…` in a method, which is particularly problematic is you need to re-call the generic recursively.
+For example, imagine a simple print method like this:
+
+```{r}
+simple_print <- new_generic(""simple_print"", ""x"")
+method(simple_print, class_double) <- function(x, digits = 3) {}
+method(simple_print, class_character) <- function(x, max_length = 100) {}
+```
+
+What if you want to print a list?
+
+```{r}
+method(simple_print, class_list) <- function(x, ...) {
+  for (el in x) {
+    simple_print(el, ...)
+  }
+}
+```
+
+It's fine as long as all the elements of the list are numbers, but as soon as we add a character vector, we get an error:
+
+```{r, error = TRUE, eval = FALSE}
+simple_print(list(1, 2, 3), digits = 3)
+simple_print(list(1, 2, ""x""), digits = 3)
+```
+
+To solve this situation, methods generally need to ignore arguments that they haven't been specifically designed to handle, i.e. they need to use `…`:
+
+```{r}
+method(simple_print, class_double) <- function(x, ..., digits = 3) {}
+method(simple_print, class_character) <- function(x, ..., max_length = 100) {}
+
+simple_print(list(1, 2, ""x""), digits = 3)
+```
+
+In this case we really do want to silently ignore unknown arguments because they might apply to other methods.
+There's unfortunately no easy way to avoid this problem without relying on fairly esoteric technology (as done by `rlang::check_dots_used()`).
+
+```{r}
+simple_print(list(1, 2, ""x""), diggits = 3)
+```
+
+### Generic and method without dots
+
+Occasional it's useful to generic a generic without `…` because such functions have a useful property: if a call succeeds for one type of input, it will succeed for any type of input.
+To create such a generic, you'll need to use the third argument to `new_generic()`: an optional function that powers the generic.
+This function has one key property: it must call `call_method()` to actually perform dispatch.
+
+In general, this property is only needed for very low-level functions with precisely defined semantics.
+A good example of such a function is `length()`:
+
+```{r, eval = FALSE}
+length <- new_generic(""length"", ""x"", function(x) {
+  R7_dispatch()
+})
+```
+
+Omitting `…` from the generic signature is a strong restriction as it prevents methods from adding extra arguments.
+For this reason, it's should only be used in special situations.
+
+## Customizing generics
+
+In most cases, you'll supply the first two arguments to `new_generic()` and allow it to automatically generate the body of the generic:
+
+```{r}
+display <- new_generic(""display"", ""x"")
+R7_data(display)
+```
+
+The most important part of the body is `R7_dispatchl()`; this function finds the method the matches the arguments used for dispatch and calls it with the arguments supplied to the generic.
+
+It can be useful to customize this body.
+The previous section showed one case when you might want to supply the body yourself: dropping `…` from the formals of the generic.
+There are three other useful cases:
+
+-   To add required arguments.
+-   To add optional arguments.
+-   Perform some standard work.
+
+A custom `fun` must always include a call to `call_method()`, which will usually be the last call.
+
+### Add required arguments
+
+To add required arguments that aren't dispatched upon, you just need to add additional arguments that lack default values:
+
+```{r}
+foo <- new_generic(""foo"", ""x"", function(x, y, ...) {
+  R7_dispatch()
+})
+```
+
+Now all methods will need to provide that `y` argument.
+If not, you'll get a warning:
+
+```{r}
+method(foo, class_integer) <- function(x, ...) {
+  10
+}
+```
+
+This is a warning, not an error, because the generic might be defined in a different package and is in the process of changing interfaces.
+You'll always want to address this warning when you see it.
+
+### Add optional arguments
+
+Adding an optional argument is similar, but it should generally come after `…`.
+This ensures that the user must supply the full name of the argument when calling the function, which makes it easier to extend your function in the future.
+
+```{r}
+mean <- new_generic(""mean"", ""x"", function(x, ..., na.rm = TRUE) {
+  R7_dispatch()
+})
+method(mean, class_integer) <- function(x, na.rm = TRUE) {
+  if (na.rm) {
+    x <- x[!is.na(x)]
+  }
+  sum(x) / length(x)
+}
+```
+
+Forgetting the argument or using a different default value will again generate a warning.
+
+```{r}
+method(mean, class_double) <- function(x, na.rm = FALSE) {}
+method(mean, class_logical) <- function(x) {}
+```
+
+### Do some work
+
+If you're generic has additional arguments, you might want to do some additional work to verify that they're of the expected type.
+For example, our `mean()` function could verify that `na.rm` was correctly specified:
+
+```{r}
+mean <- new_generic(""mean"", ""x"", function(x, ..., na.rm = TRUE) {
+  if (!identical(na.rm, TRUE) && !identical(na.rm = FALSE)) {
+    stop(""`na.rm` must be either TRUE or FALSE"")
+  }
+  R7_dispatch()
+})
+```
+
+The only downside to performing error checking is that you constraint the interface for all methods; if for some reason a method found it useful to allow `na.rm` to be a number or a string, it would have to provide an alternative argument.
+
+## External generics
+
+If you're defining methods for an R7 generic in another package there are a couple of extra steps you need to take:
+
+-   You need to use `new_external_generic()` to provide a definition of the interface of the generic that lives purely in your package. This definition gives the package name, generic name, and the arguments it uses for dispatch:
+
+    ```{r}
+    foo <- new_external_generic(""pkg1"", ""foo"", ""x"")
+    ```
+
+-   You need call `R7::external_methods_register()` your package is loaded:
+
+    ```{r}
+    .onLoad <- function(libname, pkgname) {
+      R7::external_methods_register()
+    }
+    ```
+
+    This ensures that the methods are registered when your package is used, not when it is built.
+
+In the future, we hope to relax these requirements to make use of external generics easier.
+
+## `super()`
+
+Sometimes it's useful to define a method for in terms of its superclass.
+A good example of this is computing the mean of a date --- since dates represent the number of days since 1970-01-01, computing the mean is just a matter of computing the mean of the underlying numeric vector and converting it back to a date.
+
+To demonstrate this idea, I'll first define a mean generic with a method for numbers:
+
+```{r}
+mean <- new_generic(""mean"", ""x"")
+method(mean, class_numeric) <- function(x) {
+  sum(x) / length(x)
+}
+mean(1:10)
+```
+
+And a Date class:
+
+```{r}
+date <- new_class(""date"", parent = class_double)
+# Cheat by using the existing base .Date class
+method(print, date) <- function(x) print(.Date(x))
+date(c(1, 10, 100))
+```
+
+Now to compute a mean we write:
+
+```{r}
+method(mean, date) <- function(x) {
+  date(mean(super(x, to = class_double)))
+}
+mean(date(c(1, 10, 100)))
+```
+
+Let's unpack this method from the inside out:
+
+1.  First we call `super(x, to = class_double)` --- this will make the call to next generic treat `x` like it's a double, rather than a date.
+2.  Then we call `mean()` which because of `super()` will call the `mean()` method we defined above.
+3.  Finally, we take the number returned by mean and convert it back to a date.
+
+If you're very familiar with S3 or S4 you might recognize that `super()` fills a similar role to `NextMethod()` or `callNextMethod()`.
+However, it's much more explicit: you need to supply the name of the parent class, the generic to use, and all the arguments to the generic.
+This explicitness makes the code easier to understand and will eventually enable certain performance optimizations that would otherwise be very difficult.
+
+## Multiple dispatch
+
+So far we have focused primarily on single dispatch, i.e. generics where `dispatch_on` is a single string.
+It is also possible to supply a length 2 (or more!) vector `dispatch_on` to create a generic that performs multiple dispatch, i.e. it uses the classes of more than one object to find the appropriate method.
+
+Multiple dispatch is a feature primarily of S4, although S3 includes some limited special cases for arithmetic operators.
+Multiple dispatch is heavily used in S4; we don't expect it to be heavily used in R7, but it is occasionally useful.
+
+### A simple example
+
+Inspired by <https://blog.klipse.tech/javascript/2021/10/03/multimethod.html>
+
+Let's take our speak example from `vignette(""R7"")` and extend it to teach our pets how to speak multiple languages:
+
+```{r}
+pet <- new_class(""pet"")
+dog <- new_class(""dog"", pet)
+cat <- new_class(""cat"", pet)
+
+language <- new_class(""language"")
+english <- new_class(""english"", language)
+french <- new_class(""french"", language)
+
+speak <- new_generic(""speak"", c(""x"", ""y""))
+method(speak, list(dog, english)) <- function(x, y) ""Woof""
+method(speak, list(cat, english)) <- function(x, y) ""Meow""
+method(speak, list(dog, french)) <- function(x, y) ""Ouaf Ouaf""
+method(speak, list(cat, french)) <- function(x, y) ""Miaou""
+
+speak(cat(), english())
+speak(dog(), french())
+```
+
+### Special ""classes""
+
+There are two special classes that become particularly useful with multiple dispatch:
+
+-   `class_any()` will match any class
+-   `class_missing()` will match a missing argument (i.e. not `NA`, but an argument that was not supplied)"
RConsortium,S7,87d8b3d6965d9e65419a2d2a050a5e09a53d6578,Hadley Wickham,h.wickham@gmail.com,2022-03-17T16:33:42Z,GitHub,noreply@github.com,2022-03-17T16:33:42Z,"Consistently use `class_` prefix for base wrappers (#207)

Fixes #170",NAMESPACE;NEWS.md;R/S4.R;R/base.R;R/class-spec.R;R/class.R;R/constructor.R;R/convert.R;R/data.R;R/generic.R;R/method-introspect.R;R/method-register.R;R/property.R;R/special.R;R/super.R;R/union.R;R/valid.R;R/zzz.R;README.Rmd;README.md;_pkgdown.yml;man/R7_data.Rd;man/as_class.Rd;man/base_classes.Rd;man/class_missing.Rd;man/convert.Rd;man/method-set.Rd;man/method.Rd;man/method_explain.Rd;man/new_class.Rd;man/new_generic.Rd;man/new_property.Rd;man/new_union.Rd;man/prop.Rd;man/props.Rd;man/super.Rd;man/validate.Rd;tests/testthat/_snaps/base.md;tests/testthat/_snaps/class-spec.md;tests/testthat/_snaps/class.md;tests/testthat/_snaps/constructor.md;tests/testthat/_snaps/convert.md;tests/testthat/_snaps/method-introspect.md;tests/testthat/_snaps/method-register.md;tests/testthat/_snaps/property.md;tests/testthat/_snaps/special.md;tests/testthat/_snaps/super.md;tests/testthat/_snaps/union.md;tests/testthat/t2/R/pkg.R;tests/testthat/test-S4.R;tests/testthat/test-base.R;tests/testthat/test-class-spec.R;tests/testthat/test-class.R;tests/testthat/test-constructor.R;tests/testthat/test-convert.R;tests/testthat/test-data.R;tests/testthat/test-generic.R;tests/testthat/test-method-dispatch.R;tests/testthat/test-method-introspect.R;tests/testthat/test-method-register.R;tests/testthat/test-property.R;tests/testthat/test-special.R;tests/testthat/test-super.R;tests/testthat/test-union.R;tests/testthat/test-valid.R;tests/testthat/test-zzz.R;vignettes/R7.Rmd;vignettes/case_studies.Rmd;vignettes/minutes/2022-03-08.Rmd;vignettes/performance.Rmd,True,True,True,False,570,490,1060,"---FILE: NAMESPACE---
@@ -33,13 +33,26 @@ export(R7_class)
 export(R7_data)
 export(R7_dispatch)
 export(R7_object)
-export(any_class)
 export(as_class)
+export(class_any)
+export(class_atomic)
+export(class_character)
+export(class_complex)
+export(class_double)
+export(class_environment)
+export(class_expression)
+export(class_function)
+export(class_integer)
+export(class_list)
+export(class_logical)
+export(class_missing)
+export(class_numeric)
+export(class_raw)
+export(class_vector)
 export(convert)
 export(external_methods_register)
 export(method)
 export(method_explain)
-export(missing_class)
 export(new_S3_class)
 export(new_class)
 export(new_external_generic)

---FILE: NEWS.md---
@@ -6,13 +6,16 @@
 
 ## Mar 2022
 
+* All built-in wrappers around base types use `class_`. You can no longer
+  refer to a base type with a string or a constructor function (#170).
+
 * `convert()` allows you to convert an object into another class (#136).
 
 * `super()` replaces `next_method()` (#110).
 
 ## Feb 2022
 
-* `any_class` and `missing_any` make it possible to dispatch on absent
+* `class_any` and `class_missing` make it possible to dispatch on absent
   arguments and arguments of any class (#67).
 
 * New `method_explain()` to explain dispatch (#194).
@@ -23,7 +26,7 @@
 
 * When creating an object, unspecified properties are initialized with their 
   default value (#67). DISCUSS: to achieve this, the constructor arguments
-  default to `missing_class`.
+  default to `class_missing`.
 
 * Add `$.R7_object` and `$<-.R7_object` methods to avoid ""object of type 'S4'
   is not subsettable"" error (#204).

---FILE: R/S4.R---
@@ -16,11 +16,13 @@ S4_to_R7_class <- function(x, error_base = """") {
   } else if (methods::is(x, ""classRepresentation"")) {
     if (methods::extends(x, ""oldClass"")) {
       new_S3_class(as.character(x@className))
-    } else if (x@package == ""methods"" && x@className %in% names(base_classes)) {
-      # Convert S4 representation of base types to R7 representation
-      base_classes[[x@className]]
-    } else if (x@package == ""methods"" && x@className == ""NULL"") {
-      NULL
+    } else if (x@package == ""methods"") {
+      base_classes <- S4_base_classes()
+      if (hasName(base_classes, x@className)) {
+        base_classes[[x@className]]
+      } else {
+        x
+      }
     } else {
       x
     }
@@ -33,6 +35,24 @@ S4_to_R7_class <- function(x, error_base = """") {
   }
 }
 
+S4_base_classes <- function() {
+  list(
+    NULL = NULL,
+    logical = class_logical,
+    integer = class_integer,
+    double = class_double,
+    numeric = class_numeric,
+    character = class_character,
+    complex = class_complex,
+    raw = class_raw,
+    list = class_list,
+    expression = class_expression,
+    vector = class_vector,
+    `function` = class_function,
+    environment = class_environment
+  )
+}
+
 S4_class_dispatch <- function(x) {
   x <- methods::getClass(x)
   self <- S4_class_name(x)
@@ -61,7 +81,7 @@ S4_class_name <- function(x) {
   class <- x@className
   package <- x@package %||% attr(class, ""package"")
 
-  if (identical(package, ""methods"") && class %in% names(base_classes)) {
+  if (identical(package, ""methods"") && class %in% names(S4_base_classes())) {
     class
   } else if (is.null(package) || identical(package, "".GlobalEnv"")) {
     paste0(""S4/"", class)

---FILE: R/base.R---
@@ -1,8 +1,8 @@
 new_base_class <- function(name) {
   force(name)
 
-  constructor <- function(.data = missing_class) {
-    if (is_missing_class(.data)) {
+  constructor <- function(.data = class_missing) {
+    if (is_class_missing(.data)) {
       .data <- base_default(name)
     }
     .data
@@ -53,17 +53,85 @@ str.R7_base_class <- function(object, ..., nest.lev = 0) {
   print(object, ..., nest.lev = nest.lev)
 }
 
-base_classes <- list(
-  logical = new_base_class(""logical""),
-  integer = new_base_class(""integer""),
-  double = new_base_class(""double""),
-  complex = new_base_class(""complex""),
-  character = new_base_class(""character""),
-  raw = new_base_class(""raw""),
+#' Base classes
+#'
+#' @description
+#' These classes represent base types allowing them to be used within R7.
+#' Most correspond directly to the obvious base type. There are three
+#' exceptions:
+#'
+#' * `class_numeric` is a union of `class_integer` and `class_double`.
+#' * `class_atomic` is a union of `class_logical`, `class_numeric`,
+#'   `class_complex`, and `class_raw`.
+#' * `class_vector` is a union of `class_atomic`, `class_list`, and
+#'   `class_expression`.
+#'
+#' @name base_classes
+NULL
 
-  list = new_base_class(""list""),
-  expression = new_base_class(""expression""),
+#' @export
+#' @rdname base_classes
+#' @format NULL
+class_logical <- new_base_class(""logical"")
+
+#' @export
+#' @rdname base_classes
+#' @format NULL
+class_integer <- new_base_class(""integer"")
+
+#' @export
+#' @rdname base_classes
+#' @format NULL
+class_double <- new_base_class(""double"")
+
+#' @export
+#' @rdname base_classes
+#' @format NULL
+class_complex <- new_base_class(""complex"")
+
+#' @export
+#' @rdname base_classes
+#' @format NULL
+class_character <- new_base_class(""character"")
+
+#' @export
+#' @rdname base_classes
+#' @format NULL
+class_raw <- new_base_class(""raw"")
+
+#' @export
+#' @rdname base_classes
+#' @format NULL
+class_list <- new_base_class(""list"")
 
-  `function` = new_base_class(""function""),
-  environment = new_base_class(""environment"")
-)
+#' @export
+#' @rdname base_classes
+#' @format NULL
+class_expression <- new_base_class(""expression"")
+
+#' @export
+#' @rdname base_classes
+#' @format NULL
+class_function <- new_base_class(""function"")
+
+#' @export
+#' @rdname base_classes
+#' @format NULL
+class_environment <- new_base_class(""environment"")
+
+# Base unions are created .onLoad
+
+#' @export
+#' @rdname base_classes
+#' @format NULL
+class_numeric <- NULL
+
+#' @export
+#' @rdname base_classes
+#' @format NULL
+class_atomic <- NULL
+
+#' @export
+#' @rdname base_classes
+#' @format NULL
+class_vector <- NULL

---FILE: R/class-spec.R---
@@ -9,43 +9,25 @@
 #'   * An R7 union (created by [new_union()]).
 #'   * An S3 class (created by [new_S3_class()]).
 #'   * An S4 class (created by [methods::getClass()] or [methods::new()]).
-#'   * A base type specified either with its constructor (`logical`, `integer`,
-#'     `double` etc) or its name (`""logical""`, `""integer""`, ""`double`"" etc).
-#'   * A base union type specified by its name: `""numeric""`, `""atomic""`, or
-#'      `""vector""`.
-#'   * A ""special"", either [missing_class] or [any_class].
+#'   * A base class, like [class_logical], [class_integer], or [class_double].
+#'   * A ""special"", either [class_missing] or [class_any].
 #' @param arg Argument name used when generating errors.
 #' @export
 #' @return A standardised class: either `NULL`, an R7 class, an R7 union,
 #'   as [new_S3_class], or a S4 class.
 as_class <- function(x, arg = deparse(substitute(x))) {
   error_base <- sprintf(""Can't convert `%s` to a valid class. "", arg)
 
-  if (is.null(x)) {
+  if (is_foundation_class(x)) {
+    x
+  } else if (is.null(x)) {
     # NULL is handled specially because you can't assign a class to it,
     # so it can't be wrapped in new_base_class
     x
-  } else if (is_foundation_class(x)) {
-    x
   } else if (isS4(x)) {
     S4_to_R7_class(x, error_base)
-  } else if (is.function(x)) {
-    candidate <- find_base_name(x, names(base_classes))
-    if (is.na(candidate)) {
-      stop(paste0(error_base, ""No matching base class.""), call. = FALSE)
-    }
-    base_classes[[candidate]]
-  } else if (is.character(x) && length(x) == 1) {
-    if (x %in% names(base_classes)) {
-      base_classes[[x]]
-    } else if (x %in% names(base_unions)) {
-      base_unions[[x]]
-    } else {
-      msg <- sprintf(""No base classes are called '%s'"", x)
-      stop(paste0(error_base, msg), call. = FALSE)
-    }
   } else {
-    msg <- sprintf(""Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base constructor function, not a %s."", obj_desc(x))
+    msg <- sprintf(""Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base class, not a %s."", obj_desc(x))
     stop(paste0(error_base, msg), call. = FALSE)
   }
 }
@@ -55,16 +37,16 @@ is_foundation_class <- function(x) {
     is_union(x) ||
     is_base_class(x) ||
     is_S3_class(x) ||
-    is_missing_class(x) ||
-    is_any_class(x)
+    is_class_missing(x) ||
+    is_class_any(x)
 }
 
 class_type <- function(x) {
   if (is.null(x)) {
     ""NULL""
-  } else if (is_missing_class(x)) {
+  } else if (is_class_missing(x)) {
     ""missing""
-  } else if (is_any_class(x)) {
+  } else if (is_class_any(x)) {
     ""any""
   } else if (is_base_class(x)) {
     ""R7_base""
@@ -175,8 +157,8 @@ class_register <- function(x) {
 class_deparse <- function(x) {
   switch(class_type(x),
     ""NULL"" = ""NULL"",
-    missing = ""missing_class"",
-    any = ""any_class"",
+    missing = ""class_missing"",
+    any = ""class_any"",
     S4 = as.character(x@className),
     R7 = R7_class_name(x),
     R7_base = encodeString(x$class, quote = '""'),

---FILE: R/class.R---
@@ -4,13 +4,15 @@
 #' possess. The class, and its parent, determines which method will be used
 #' when an object is passed to a generic.
 #'
-#' @param name The name of the class, as a string.
+#' @param name The name of the class, as a string. The result of calling
+#'   `new_class()` should always be assigned to a variable with this name,
+#'   i.e. `foo <- new_class(""foo"")`.
 #' @param parent The parent class to inherit behavior from.
-#'   There are four options:
+#'   There are three options:
 #'
-#'   * The R7 class, like [R7_object].
+#'   * An R7 class, like [R7_object].
 #'   * An S3 class wrapped by [new_S3_class()].
-#'   * A base type, like `logical`, `double`, or `character`.
+#'   * A base type, like [class_logical], [class_integer], etc.
 #' @param package Package name. It is good practice to set the package
 #'   name when exporting an R7 class from a package because it includes
 #'   the package name in the class name when it's used for dispatch. This
@@ -51,8 +53,8 @@
 #' # Create an class that represents a range using a numeric start and end
 #' range <- new_class(""range"",
 #'   properties = list(
-#'     start = ""numeric"",
-#'     end = ""numeric""
+#'     start = class_numeric,
+#'     end = class_numeric
 #'   )
 #' )
 #' r <- range(start = 10, end = 20)
@@ -69,8 +71,8 @@
 #' # are length 1, and that start is < end
 #' range <- new_class(""range"",
 #'   properties = list(
-#'     start = ""numeric"",
-#'     end = ""numeric""
+#'     start = class_numeric,
+#'     end = class_numeric
 #'   ),
 #'   validator = function(self) {
 #'     if (length(self@start) != 1) {
@@ -224,7 +226,7 @@ new_object <- function(.parent, ...) {
   args <- list(...)
   nms <- names(args)
 
-  missing_props <- nms[vlapply(args, is_missing_class)]
+  missing_props <- nms[vlapply(args, is_class_missing)]
   for(prop in missing_props) {
     args[[prop]] <- prop_default(class@properties[[prop]])
   }

---FILE: R/constructor.R---
@@ -75,7 +75,7 @@ new_function <- function(args, body, env) {
   f
 }
 missing_args <- function(names) {
-  lapply(setNames(, names), function(i) quote(missing_class))
+  lapply(setNames(, names), function(i) quote(class_missing))
 }
 new_call <- function(call, args) {
   as.call(c(list(as.name(call)), args))

---FILE: R/convert.R---
@@ -15,21 +15,21 @@
 #' @param ... Other arguments passed to custom `convert()` methods.
 #' @export
 #' @examples
-#' foo1 <- new_class(""foo1"", properties = list(x = integer))
-#' foo2 <- new_class(""foo2"", foo1, properties = list(y = double))
+#' foo1 <- new_class(""foo1"", properties = list(x = class_integer))
+#' foo2 <- new_class(""foo2"", foo1, properties = list(y = class_double))
 #'
-#' method(convert, list(foo1, integer)) <- function(from, to) from@x
-#' method(convert, list(foo2, double)) <- function(from, to) from@y
+#' method(convert, list(foo1, class_integer)) <- function(from, to) from@x
+#' method(convert, list(foo2, class_double)) <- function(from, to) from@y
 #'
-#' convert(foo1(x = 1L), to = integer)
-#' try(convert(foo1(x = 1L), to = double))
+#' convert(foo1(x = 1L), to = class_integer)
+#' try(convert(foo1(x = 1L), to = class_double))
 #'
-#' convert(foo2(x = 1L, y = 2), to = integer)
-#' convert(foo2(x = 1L, y = 2), to = double)
+#' convert(foo2(x = 1L, y = 2), to = class_integer)
+#' convert(foo2(x = 1L, y = 2), to = class_double)
 #' convert(foo2(x = 1L, y = 2), to = foo1)
 #'
 #' # If we define a convert method for interger + foo1:
-#' method(convert, list(integer, foo1)) <- function(from, to) foo1(x = from)
+#' method(convert, list(class_integer, foo1)) <- function(from, to) foo1(x = from)
 #' convert(1L, to = foo1)
 #' # Converting too foo2 still errors
 #' try(convert(1L, to = foo2))

---FILE: R/data.R---
@@ -8,7 +8,7 @@
 #' @param value Object used to replace the underlying data.
 #' @export
 #' @examples
-#' text <- new_class(""text"", parent = ""character"")
+#' text <- new_class(""text"", parent = class_character)
 #' y <- text(c(foo = ""bar""))
 #' y
 #' R7_data(y)

---FILE: R/generic.R---
@@ -38,9 +38,9 @@
 #' @examples
 #' # A simple generic with methods for some base types and S3 classes
 #' type_of <- new_generic(""type_of"", dispatch_args = ""x"")
-#' method(type_of, ""character"") <- function(x, ...) ""A character vector""
+#' method(type_of, class_character) <- function(x, ...) ""A character vector""
 #' method(type_of, new_S3_class(""data.frame"")) <- function(x, ...) ""A data frame""
-#' method(type_of, ""function"") <- function(x, ...) ""A function""
+#' method(type_of, class_function) <- function(x, ...) ""A function""
 #'
 #' type_of(mtcars)
 #' type_of(letters)
@@ -52,15 +52,15 @@
 #'    R7_dispatch()
 #' })
 #'
-#' method(mean2, ""numeric"") <- function(x, ..., na.rm = FALSE) {
+#' method(mean2, class_numeric) <- function(x, ..., na.rm = FALSE) {
 #'   if (na.rm) {
 #'     x <- x[!is.na(x)]
 #'   }
 #'   sum(x) / length(x)
 #' }
 #'
 #' # You'll be warned if you forget the argument:
-#' method(mean2, ""character"") <- function(x, ...) {
+#' method(mean2, class_character) <- function(x, ...) {
 #'   stop(""Not supported"")
 #' }
 new_generic <- function(name, dispatch_args, fun = NULL) {

---FILE: R/method-introspect.R---
@@ -9,16 +9,15 @@
 #' @seealso [method_explain()] to explain why a specific method was picked.
 #' @inheritParams method<-
 #' @returns A function with class <R7_method>.
-#' @param class,object Perform introspection either with `classes`
-#'   (processed with [as_class()]) or a concrete objects.
-#'
-#'   If `generic` does multiple dispatch both `object` and `class` need
-#'   to be wrapped in a list.
+#' @param class,object Perform introspection either with a `class`
+#'   (processed with [as_class()]) or a concrete `object`. If `generic` uses
+#'   multiple dispatch then both `object` and `class` must be a list of
+#'   classes/objects.
 #' @export
 #' @examples
 #' # Create a generic and register some methods
 #' bizarro <- new_generic(""bizarro"", ""x"")
-#' method(bizarro, ""numeric"") <- function(x) rev(x)
+#' method(bizarro, class_numeric) <- function(x) rev(x)
 #' method(bizarro, new_S3_class(""factor"")) <- function(x) {
 #'   levels(x) <- rev(levels(x))
 #'   x
@@ -28,7 +27,7 @@
 #' bizarro
 #'
 #' # And you can use method() to inspect specific implementations
-#' method(bizarro, class = ""integer"")
+#' method(bizarro, class = class_integer)
 #' method(bizarro, object = 1)
 #' method(bizarro, new_S3_class(""factor""))
 method <- function(generic, class = NULL, object = NULL) {

---FILE: R/method-register.R---
@@ -15,17 +15,15 @@
 #' @param generic A generic function, either created by [new_generic()],
 #'   [new_external_generic()], or an existing S3 generic.
 #' @param signature A method signature. For R7 generics that use single
-#'   dispatch, this should be one of the following:
+#'   dispatch, this must be one of the following:
 #'   * An R7 class (created by [new_class()]).
 #'   * An R7 union (created by [new_union()]).
 #'   * An S3 class (created by [new_S3_class()]).
 #'   * An S4 class (created by [methods::getClass()] or [methods::new()]).
-#'   * A base type specified either with its constructor (`logical`, `integer`,
-#'     `double` etc) or its name (`""logical""`, `""integer""`, ""`double`"" etc).
-#'   * A base union type specified by its name: `""numeric""`, `""atomic""`, or
-#'     `""vector""`.
+#'   * A base type like [class_logical], [class_integer], or [class_numeric].
+#'   * A special type like [class_missing] or [class_any].
 #'
-#'   For R7 generics that use multiple dispatch, this can be a list of any of
+#'   For R7 generics that use multiple dispatch, this must be a list of any of
 #'   the above types.
 #'
 #'   For S3 generics, this must be an R7 class.
@@ -36,7 +34,7 @@
 #' # Create a generic
 #' bizarro <- new_generic(""bizarro"", ""x"")
 #' # Register some methods
-#' method(bizarro, ""numeric"") <- function(x) rev(x)
+#' method(bizarro, class_numeric) <- function(x) rev(x)
 #' method(bizarro, new_S3_class(""data.frame"")) <- function(x) {
 #'   x[] <- lapply(x, bizarro)
 #'   rev(x)

---FILE: R/property.R---
@@ -9,8 +9,8 @@
 #' ""dynamic"" so that it's computed when accessed or has some non-standard
 #' behaviour when modified.
 #'
-#' @param class If specified, any values must be one of these classes
-#'   (or [class union][new_union]).
+#' @param class Class that the property must be an instance of.
+#'   See [as_class()] for details.
 #' @param getter An optional function used to get the value. The function
 #'   should take `self`  as its sole argument and return the value. If the
 #'   property has a `class` the class of the value is validated.
@@ -28,7 +28,7 @@
 #' @examples
 #' # Simple properties store data inside an object
 #' pizza <- new_class(""pizza"", properties = list(
-#'   slices = new_property(""numeric"", default = 10)
+#'   slices = new_property(class_numeric, default = 10)
 #' ))
 #' my_pizza <- pizza(slices = 6)
 #' my_pizza@slices
@@ -50,7 +50,7 @@
 #'
 #' # These can be useful if you want to deprecate a property
 #' person <- new_class(""person"", properties = list(
-#'   first_name = ""character"",
+#'   first_name = class_character,
 #'   firstName = new_property(
 #'      getter = function(self) {
 #'        warning(""@firstName is deprecated; please use @first_name instead"", call. = FALSE)
@@ -67,7 +67,7 @@
 #' hadley@firstName
 #' hadley@firstName <- ""John""
 #' hadley@first_name
-new_property <- function(class = any_class, getter = NULL, setter = NULL, default = NULL, name = NULL) {
+new_property <- function(class = class_any, getter = NULL, setter = NULL, default = NULL, name = NULL) {
   class <- as_class(class)
   if (!is.null(default) && !class_inherits(default, class)) {
     msg <- sprintf(""`default` must be an instance of %s, not a %s"", class_desc(class), obj_desc(default))
@@ -126,9 +126,9 @@ prop_default <- function(prop) {
 #' @export
 #' @examples
 #' horse <- new_class(""horse"", properties = list(
-#'   name = ""character"",
-#'   colour = ""character"",
-#'   height = ""numeric""
+#'   name = class_character,
+#'   colour = class_character,
+#'   height = class_numeric
 #' ))
 #' lexington <- horse(colour = ""bay"", height = 15, name = ""Lex"")
 #' lexington@colour
@@ -281,9 +281,9 @@ prop_exists <- function(object, name) {
 #' @export
 #' @examples
 #' horse <- new_class(""horse"", properties = list(
-#'   name = ""character"",
-#'   colour = ""character"",
-#'   height = ""numeric""
+#'   name = class_character,
+#'   colour = class_character,
+#'   height = class_numeric
 #' ))
 #' lexington <- horse(colour = ""bay"", height = 15, name = ""Lex"")
 #'

---FILE: R/special.R---
@@ -1,22 +1,22 @@
 #' Special dispatch types
 #'
-#' * Use `missing_class` when the user has not supplied an argument
-#' * Use `any_class` for a default method that is called only if no other
+#' * Use `class_missing` when the user has not supplied an argument
+#' * Use `class_any` for a default method that is called only if no other
 #'   methods are matched
 #'
 #' @export
 #' @examples
 #' foo <- new_generic(""foo"", ""x"")
-#' method(foo, integer) <- function(x) ""integer""
-#' method(foo, missing_class) <- function(x) ""missing""
-#' method(foo, any_class) <- function(x) ""fallback""
+#' method(foo, class_integer) <- function(x) ""integer""
+#' method(foo, class_missing) <- function(x) ""missing""
+#' method(foo, class_any) <- function(x) ""fallback""
 #'
 #' foo(1)
 #' foo()
 #' foo(""x"")
-missing_class <- structure(list(), class = ""R7_missing"")
+class_missing <- structure(list(), class = ""R7_missing"")
 
-is_missing_class <- function(x) inherits(x, ""R7_missing"")
+is_class_missing <- function(x) inherits(x, ""R7_missing"")
 
 #' @export
 print.R7_missing <- function(x, ...) {
@@ -30,10 +30,10 @@ str.R7_missing <- function(object, ..., nest.lev = 0) {
 }
 
 #' @export
-#' @rdname missing_class
-any_class <- structure(list(), class = ""R7_any"")
+#' @rdname class_missing
+class_any <- structure(list(), class = ""R7_any"")
 
-is_any_class <- function(x) inherits(x, ""R7_any"")
+is_class_any <- function(x) inherits(x, ""R7_any"")
 
 #' @export
 print.R7_any <- function(x, ...) {

---FILE: R/super.R---
@@ -24,8 +24,8 @@
 #'   immediately to a generic. It has no other special behavior.
 #' @export
 #' @examples
-#' foo1 <- new_class(""foo1"", properties = list(x = ""numeric"", y = ""numeric""))
-#' foo2 <- new_class(""foo2"", foo1, properties = list(z = ""numeric""))
+#' foo1 <- new_class(""foo1"", properties = list(x = class_numeric, y = class_numeric))
+#' foo2 <- new_class(""foo2"", foo1, properties = list(z = class_numeric))
 #'
 #' total <- new_generic(""total"", ""x"")
 #' method(total, foo1) <- function(x) x@x + x@y

---FILE: R/union.R---
@@ -16,10 +16,10 @@
 #' ""vector"" (atomic vectors, lists, and expressions).
 #'
 #' @param ... The classes to include in the union. See [as_class()] for
-#'   permitted definitions
+#'   details.
 #' @export
 #' @examples
-#' logical_or_character <- new_union(""logical"", ""character"")
+#' logical_or_character <- new_union(class_logical, class_character)
 #' logical_or_character
 #'
 #' Foo <- new_class(""Foo"", properties = list(x = logical_or_character))
@@ -29,7 +29,7 @@
 #'
 #' bar <- new_generic(""bar"", ""x"")
 #' # Use built-in union
-#' method(bar, ""atomic"") <- function(x) ""Hi!""
+#' method(bar, class_atomic) <- function(x) ""Hi!""
 #' bar
 #' bar(TRUE)
 #' bar(letters)

---FILE: R/valid.R---
@@ -22,7 +22,7 @@
 #' @examples
 #' # A range class might validate that the start is less than the end
 #' Range <- new_class(""Range"",
-#'   properties = list(start = ""double"", end = ""double""),
+#'   properties = list(start = class_double, end = class_double),
 #'   validator = function(self) {
 #'     if (self@start >= self@end) ""start must be smaller than end""
 #'   }

---FILE: R/zzz.R---
@@ -54,20 +54,20 @@ check_R7 <- function(x, arg = deparse(substitute(x))) {
 R7_generic <- new_class(
   name = ""R7_generic"",
   properties = list(
-    name = ""character"",
-    methods = ""environment"",
-    dispatch_args = ""character""
+    name = class_character,
+    methods = class_environment,
+    dispatch_args = class_character
   ),
-  parent = ""function""
+  parent = class_function
 )
 methods::setOldClass(c(""R7_generic"", ""function"", ""R7_object""))
 is_generic <- function(x) inherits(x, ""R7_generic"")
 
 R7_method <- new_class(""R7_method"",
-  parent = ""function"",
+  parent = class_function,
   properties = list(
     generic = R7_generic,
-    signature = ""list""
+    signature = class_list
   )
 )
 methods::setOldClass(c(""R7_method"", ""function"", ""R7_object""))
@@ -80,7 +80,7 @@ methods::setOldClass(c(""R7_method"", ""function"", ""R7_object""))
 .onLoad <- function(...) {
   convert <<- R7_generic(convert, name = ""convert"", dispatch_args = c(""from"", ""to""))
 
-  base_unions$numeric <<- new_union(""integer"", ""double"")
-  base_unions$atomic <<- new_union(""logical"", ""integer"", ""double"", ""complex"", ""character"", ""raw"")
-  base_unions$vector <<- new_union(""logical"", ""integer"", ""double"", ""complex"", ""character"", ""raw"", ""expression"", ""list"")
+  class_numeric <<- new_union(class_integer, class_double)
+  class_atomic <<- new_union(class_logical, class_numeric, class_complex, class_character, class_raw)
+  class_vector <<- new_union(class_atomic, class_expression, class_list)
 }

---FILE: README.Rmd---
@@ -41,7 +41,7 @@ library(R7)
 
 # Define a class
 Range <- new_class(""Range"",
-  properties = list(start = ""numeric"", end = ""numeric""),
+  properties = list(start = class_numeric, end = class_numeric),
   validator = function(self) {
     if (length(self@start) != 1) {
       ""@start must be length 1""

---FILE: README.md---
@@ -34,7 +34,7 @@ library(R7)
 
 # Define a class
 Range <- new_class(""Range"",
-  properties = list(start = ""numeric"", end = ""numeric""),
+  properties = list(start = class_numeric, end = class_numeric),
   validator = function(self) {
     if (length(self@start) != 1) {
       ""@start must be length 1""

---FILE: _pkgdown.yml---
@@ -29,8 +29,9 @@ reference:
   - method_explain
   - new_external_generic
   - new_S3_class
-  - missing_class
   - R7_class
+  - base_classes
+  - class_missing
 
 articles:
 - title: Learn R7

---FILE: man/R7_data.Rd---
@@ -23,7 +23,7 @@ to work with the underlying object, i.e. the R7 object stripped of class
 and all properties.
 }
 \examples{
-text <- new_class(""text"", parent = ""character"")
+text <- new_class(""text"", parent = class_character)
 y <- text(c(foo = ""bar""))
 y
 R7_data(y)

---FILE: man/as_class.Rd---
@@ -13,11 +13,8 @@ as_class(x, arg = deparse(substitute(x)))
 \item An R7 union (created by \code{\link[=new_union]{new_union()}}).
 \item An S3 class (created by \code{\link[=new_S3_class]{new_S3_class()}}).
 \item An S4 class (created by \code{\link[methods:getClass]{methods::getClass()}} or \code{\link[methods:new]{methods::new()}}).
-\item A base type specified either with its constructor (\code{logical}, \code{integer},
-\code{double} etc) or its name (\code{""logical""}, \code{""integer""}, ""\code{double}"" etc).
-\item A base union type specified by its name: \code{""numeric""}, \code{""atomic""}, or
-\code{""vector""}.
-\item A ""special"", either \link{missing_class} or \link{any_class}.
+\item A base class, like \link{class_logical}, \link{class_integer}, or \link{class_double}.
+\item A ""special"", either \link{class_missing} or \link{class_any}.
 }}
 
 \item{arg}{Argument name used when generating errors.}

---FILE: man/base_classes.Rd---
@@ -0,0 +1,59 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/base.R
+\docType{data}
+\name{base_classes}
+\alias{base_classes}
+\alias{class_logical}
+\alias{class_integer}
+\alias{class_double}
+\alias{class_complex}
+\alias{class_character}
+\alias{class_raw}
+\alias{class_list}
+\alias{class_expression}
+\alias{class_function}
+\alias{class_environment}
+\alias{class_numeric}
+\alias{class_atomic}
+\alias{class_vector}
+\title{Base classes}
+\usage{
+class_logical
+
+class_integer
+
+class_double
+
+class_complex
+
+class_character
+
+class_raw
+
+class_list
+
+class_expression
+
+class_function
+
+class_environment
+
+class_numeric
+
+class_atomic
+
+class_vector
+}
+\description{
+These classes represent base types allowing them to be used within R7.
+Most correspond directly to the obvious base type. There are three
+exceptions:
+\itemize{
+\item \code{class_numeric} is a union of \code{class_integer} and \code{class_double}.
+\item \code{class_atomic} is a union of \code{class_logical}, \code{class_numeric},
+\code{class_complex}, and \code{class_raw}.
+\item \code{class_vector} is a union of \code{class_atomic}, \code{class_list}, and
+\code{class_expression}.
+}
+}
+\keyword{datasets}

---FILE: man/class_missing.Rd---
@@ -1,32 +1,32 @@
 % Generated by roxygen2: do not edit by hand
 % Please edit documentation in R/special.R
 \docType{data}
-\name{missing_class}
-\alias{missing_class}
-\alias{any_class}
+\name{class_missing}
+\alias{class_missing}
+\alias{class_any}
 \title{Special dispatch types}
 \format{
 An object of class \code{R7_missing} of length 0.
 
 An object of class \code{R7_any} of length 0.
 }
 \usage{
-missing_class
+class_missing
 
-any_class
+class_any
 }
 \description{
 \itemize{
-\item Use \code{missing_class} when the user has not supplied an argument
-\item Use \code{any_class} for a default method that is called only if no other
+\item Use \code{class_missing} when the user has not supplied an argument
+\item Use \code{class_any} for a default method that is called only if no other
 methods are matched
 }
 }
 \examples{
 foo <- new_generic(""foo"", ""x"")
-method(foo, integer) <- function(x) ""integer""
-method(foo, missing_class) <- function(x) ""missing""
-method(foo, any_class) <- function(x) ""fallback""
+method(foo, class_integer) <- function(x) ""integer""
+method(foo, class_missing) <- function(x) ""missing""
+method(foo, class_any) <- function(x) ""fallback""
 
 foo(1)
 foo()

---FILE: man/convert.Rd---
@@ -24,21 +24,21 @@ This default strips any properties that \code{from} possesses that \code{to} doe
 and resets the class.
 }
 \examples{
-foo1 <- new_class(""foo1"", properties = list(x = integer))
-foo2 <- new_class(""foo2"", foo1, properties = list(y = double))
+foo1 <- new_class(""foo1"", properties = list(x = class_integer))
+foo2 <- new_class(""foo2"", foo1, properties = list(y = class_double))
 
-method(convert, list(foo1, integer)) <- function(from, to) from@x
-method(convert, list(foo2, double)) <- function(from, to) from@y
+method(convert, list(foo1, class_integer)) <- function(from, to) from@x
+method(convert, list(foo2, class_double)) <- function(from, to) from@y
 
-convert(foo1(x = 1L), to = integer)
-try(convert(foo1(x = 1L), to = double))
+convert(foo1(x = 1L), to = class_integer)
+try(convert(foo1(x = 1L), to = class_double))
 
-convert(foo2(x = 1L, y = 2), to = integer)
-convert(foo2(x = 1L, y = 2), to = double)
+convert(foo2(x = 1L, y = 2), to = class_integer)
+convert(foo2(x = 1L, y = 2), to = class_double)
 convert(foo2(x = 1L, y = 2), to = foo1)
 
 # If we define a convert method for interger + foo1:
-method(convert, list(integer, foo1)) <- function(from, to) foo1(x = from)
+method(convert, list(class_integer, foo1)) <- function(from, to) foo1(x = from)
 convert(1L, to = foo1)
 # Converting too foo2 still errors
 try(convert(1L, to = foo2))

---FILE: man/method-set.Rd---
@@ -11,19 +11,17 @@ method(generic, signature) <- value
 \code{\link[=new_external_generic]{new_external_generic()}}, or an existing S3 generic.}
 
 \item{signature}{A method signature. For R7 generics that use single
-dispatch, this should be one of the following:
+dispatch, this must be one of the following:
 \itemize{
 \item An R7 class (created by \code{\link[=new_class]{new_class()}}).
 \item An R7 union (created by \code{\link[=new_union]{new_union()}}).
 \item An S3 class (created by \code{\link[=new_S3_class]{new_S3_class()}}).
 \item An S4 class (created by \code{\link[methods:getClass]{methods::getClass()}} or \code{\link[methods:new]{methods::new()}}).
-\item A base type specified either with its constructor (\code{logical}, \code{integer},
-\code{double} etc) or its name (\code{""logical""}, \code{""integer""}, ""\code{double}"" etc).
-\item A base union type specified by its name: \code{""numeric""}, \code{""atomic""}, or
-\code{""vector""}.
+\item A base type like \link{class_logical}, \link{class_integer}, or \link{class_numeric}.
+\item A special type like \link{class_missing} or \link{class_any}.
 }
 
-For R7 generics that use multiple dispatch, this can be a list of any of
+For R7 generics that use multiple dispatch, this must be a list of any of
 the above types.
 
 For S3 generics, this must be an R7 class.}
@@ -47,7 +45,7 @@ But this is not a general method registration function: at least one of
 # Create a generic
 bizarro <- new_generic(""bizarro"", ""x"")
 # Register some methods
-method(bizarro, ""numeric"") <- function(x) rev(x)
+method(bizarro, class_numeric) <- function(x) rev(x)
 method(bizarro, new_S3_class(""data.frame"")) <- function(x) {
   x[] <- lapply(x, bizarro)
   rev(x)

---FILE: man/method.Rd---
@@ -10,11 +10,10 @@ method(generic, class = NULL, object = NULL)
 \item{generic}{A generic function, either created by \code{\link[=new_generic]{new_generic()}},
 \code{\link[=new_external_generic]{new_external_generic()}}, or an existing S3 generic.}
 
-\item{class, object}{Perform introspection either with \code{classes}
-(processed with \code{\link[=as_class]{as_class()}}) or a concrete objects.
-
-If \code{generic} does multiple dispatch both \code{object} and \code{class} need
-to be wrapped in a list.}
+\item{class, object}{Perform introspection either with a \code{class}
+(processed with \code{\link[=as_class]{as_class()}}) or a concrete \code{object}. If \code{generic} uses
+multiple dispatch then both \code{object} and \code{class} must be a list of
+classes/objects.}
 }
 \value{
 A function with class <R7_method>.
@@ -29,7 +28,7 @@ of a specific method.
 \examples{
 # Create a generic and register some methods
 bizarro <- new_generic(""bizarro"", ""x"")
-method(bizarro, ""numeric"") <- function(x) rev(x)
+method(bizarro, class_numeric) <- function(x) rev(x)
 method(bizarro, new_S3_class(""factor"")) <- function(x) {
   levels(x) <- rev(levels(x))
   x
@@ -39,7 +38,7 @@ method(bizarro, new_S3_class(""factor"")) <- function(x) {
 bizarro
 
 # And you can use method() to inspect specific implementations
-method(bizarro, class = ""integer"")
+method(bizarro, class = class_integer)
 method(bizarro, object = 1)
 method(bizarro, new_S3_class(""factor""))
 }

---FILE: man/method_explain.Rd---
@@ -10,17 +10,15 @@ method_explain(generic, class = NULL, object = NULL)
 \item{generic}{A generic function, either created by \code{\link[=new_generic]{new_generic()}},
 \code{\link[=new_external_generic]{new_external_generic()}}, or an existing S3 generic.}
 
-\item{class}{Perform introspection either with \code{classes}
-(processed with \code{\link[=as_class]{as_class()}}) or a concrete objects.
+\item{class}{Perform introspection either with a \code{class}
+(processed with \code{\link[=as_class]{as_class()}}) or a concrete \code{object}. If \code{generic} uses
+multiple dispatch then both \code{object} and \code{class} must be a list of
+classes/objects.}
 
-If \code{generic} does multiple dispatch both \code{object} and \code{class} need
-to be wrapped in a list.}
-
-\item{object}{Perform introspection either with \code{classes}
-(processed with \code{\link[=as_class]{as_class()}}) or a concrete objects.
-
-If \code{generic} does multiple dispatch both \code{object} and \code{class} need
-to be wrapped in a list.}
+\item{object}{Perform introspection either with a \code{class}
+(processed with \code{\link[=as_class]{as_class()}}) or a concrete \code{object}. If \code{generic} uses
+multiple dispatch then both \code{object} and \code{class} must be a list of
+classes/objects.}
 }
 \description{
 \code{method_explain()} shows all possible methods that a call to a generic

---FILE: man/new_class.Rd---
@@ -18,14 +18,16 @@ new_class(
 new_object(.parent, ...)
 }
 \arguments{
-\item{name}{The name of the class, as a string.}
+\item{name}{The name of the class, as a string. The result of calling
+\code{new_class()} should always be assigned to a variable with this name,
+i.e. \code{foo <- new_class(""foo"")}.}
 
 \item{parent}{The parent class to inherit behavior from.
-There are four options:
+There are three options:
 \itemize{
-\item The R7 class, like \link{R7_object}.
+\item An R7 class, like \link{R7_object}.
 \item An S3 class wrapped by \code{\link[=new_S3_class]{new_S3_class()}}.
-\item A base type, like \code{logical}, \code{double}, or \code{character}.
+\item A base type, like \link{class_logical}, \link{class_integer}, etc.
 }}
 
 \item{package}{Package name. It is good practice to set the package
@@ -82,8 +84,8 @@ when an object is passed to a generic.
 # Create an class that represents a range using a numeric start and end
 range <- new_class(""range"",
   properties = list(
-    start = ""numeric"",
-    end = ""numeric""
+    start = class_numeric,
+    end = class_numeric
   )
 )
 r <- range(start = 10, end = 20)
@@ -100,8 +102,8 @@ try(range(start = ""hello"", end = 20))
 # are length 1, and that start is < end
 range <- new_class(""range"",
   properties = list(
-    start = ""numeric"",
-    end = ""numeric""
+    start = class_numeric,
+    end = class_numeric
   ),
   validator = function(self) {
     if (length(self@start) != 1) {

---FILE: man/new_generic.Rd---
@@ -49,9 +49,9 @@ immediately after the dispatch arguments.
 \examples{
 # A simple generic with methods for some base types and S3 classes
 type_of <- new_generic(""type_of"", dispatch_args = ""x"")
-method(type_of, ""character"") <- function(x, ...) ""A character vector""
+method(type_of, class_character) <- function(x, ...) ""A character vector""
 method(type_of, new_S3_class(""data.frame"")) <- function(x, ...) ""A data frame""
-method(type_of, ""function"") <- function(x, ...) ""A function""
+method(type_of, class_function) <- function(x, ...) ""A function""
 
 type_of(mtcars)
 type_of(letters)
@@ -63,15 +63,15 @@ mean2 <- new_generic(""mean2"", ""x"", function(x, ..., na.rm = FALSE) {
    R7_dispatch()
 })
 
-method(mean2, ""numeric"") <- function(x, ..., na.rm = FALSE) {
+method(mean2, class_numeric) <- function(x, ..., na.rm = FALSE) {
   if (na.rm) {
     x <- x[!is.na(x)]
   }
   sum(x) / length(x)
 }
 
 # You'll be warned if you forget the argument:
-method(mean2, ""character"") <- function(x, ...) {
+method(mean2, class_character) <- function(x, ...) {
   stop(""Not supported"")
 }
 }

---FILE: man/new_property.Rd---
@@ -5,16 +5,16 @@
 \title{Define a new property}
 \usage{
 new_property(
-  class = any_class,
+  class = class_any,
   getter = NULL,
   setter = NULL,
   default = NULL,
   name = NULL
 )
 }
 \arguments{
-\item{class}{If specified, any values must be one of these classes
-(or \link[=new_union]{class union}).}
+\item{class}{Class that the property must be an instance of.
+See \code{\link[=as_class]{as_class()}} for details.}
 
 \item{getter}{An optional function used to get the value. The function
 should take \code{self}  as its sole argument and return the value. If the
@@ -45,7 +45,7 @@ behaviour when modified.
 \examples{
 # Simple properties store data inside an object
 pizza <- new_class(""pizza"", properties = list(
-  slices = new_property(""numeric"", default = 10)
+  slices = new_property(class_numeric, default = 10)
 ))
 my_pizza <- pizza(slices = 6)
 my_pizza@slices
@@ -67,7 +67,7 @@ try(my_clock@now <- 10)
 
 # These can be useful if you want to deprecate a property
 person <- new_class(""person"", properties = list(
-  first_name = ""character"",
+  first_name = class_character,
   firstName = new_property(
      getter = function(self) {
        warning(""@firstName is deprecated; please use @first_name instead"", call. = FALSE)

---FILE: man/new_union.Rd---
@@ -8,7 +8,7 @@ new_union(...)
 }
 \arguments{
 \item{...}{The classes to include in the union. See \code{\link[=as_class]{as_class()}} for
-permitted definitions}
+details.}
 }
 \description{
 A class union represents a list of possible classes. It can be used in two
@@ -26,7 +26,7 @@ R7 includes built-in unions for ""numeric"" (integer and double vectors),
 ""vector"" (atomic vectors, lists, and expressions).
 }
 \examples{
-logical_or_character <- new_union(""logical"", ""character"")
+logical_or_character <- new_union(class_logical, class_character)
 logical_or_character
 
 Foo <- new_class(""Foo"", properties = list(x = logical_or_character))
@@ -36,7 +36,7 @@ try(Foo(1:3))
 
 bar <- new_generic(""bar"", ""x"")
 # Use built-in union
-method(bar, ""atomic"") <- function(x) ""Hi!""
+method(bar, class_atomic) <- function(x) ""Hi!""
 bar
 bar(TRUE)
 bar(letters)

---FILE: man/prop.Rd---
@@ -34,9 +34,9 @@ a property.
 }
 \examples{
 horse <- new_class(""horse"", properties = list(
-  name = ""character"",
-  colour = ""character"",
-  height = ""numeric""
+  name = class_character,
+  colour = class_character,
+  height = class_numeric
 ))
 lexington <- horse(colour = ""bay"", height = 15, name = ""Lex"")
 lexington@colour

---FILE: man/props.Rd---
@@ -23,9 +23,9 @@ only after all replacements are performed.}
 }
 \examples{
 horse <- new_class(""horse"", properties = list(
-  name = ""character"",
-  colour = ""character"",
-  height = ""numeric""
+  name = class_character,
+  colour = class_character,
+  height = class_numeric
 ))
 lexington <- horse(colour = ""bay"", height = 15, name = ""Lex"")
 

---FILE: man/super.Rd---
@@ -36,8 +36,8 @@ understand and reason about.
 }
 
 \examples{
-foo1 <- new_class(""foo1"", properties = list(x = ""numeric"", y = ""numeric""))
-foo2 <- new_class(""foo2"", foo1, properties = list(z = ""numeric""))
+foo1 <- new_class(""foo1"", properties = list(x = class_numeric, y = class_numeric))
+foo2 <- new_class(""foo2"", foo1, properties = list(z = class_numeric))
 
 total <- new_generic(""total"", ""x"")
 method(total, foo1) <- function(x) x@x + x@y

---FILE: man/validate.Rd---
@@ -38,7 +38,7 @@ you are certain a sequence of operations cannot produce an invalid object.
 \examples{
 # A range class might validate that the start is less than the end
 Range <- new_class(""Range"",
-  properties = list(start = ""double"", end = ""double""),
+  properties = list(start = class_double, end = class_double),
   validator = function(self) {
     if (self@start >= self@end) ""start must be smaller than end""
   }

---FILE: tests/testthat/_snaps/base.md---
@@ -1,59 +1,20 @@
 # validation uses typeof
 
     Code
-      base_classes$integer$validator(TRUE)
+      class_integer$validator(TRUE)
     Output
       [1] ""Underlying data must be <integer> not <logical>""
 
 # base class display as expected
 
     Code
-      base_classes
+      class_integer
     Output
-      $logical
-      <R7_base_class>: <logical>
-      
-      $integer
       <R7_base_class>: <integer>
-      
-      $double
-      <R7_base_class>: <double>
-      
-      $complex
-      <R7_base_class>: <complex>
-      
-      $character
-      <R7_base_class>: <character>
-      
-      $raw
-      <R7_base_class>: <raw>
-      
-      $list
-      <R7_base_class>: <list>
-      
-      $expression
-      <R7_base_class>: <expression>
-      
-      $`function`
-      <R7_base_class>: <function>
-      
-      $environment
-      <R7_base_class>: <environment>
-      
     Code
-      str(base_classes)
+      str(class_integer)
     Output
-      List of 10
-       $ logical    : <R7_base_class>: <logical>
-       $ integer    : <R7_base_class>: <integer>
-       $ double     : <R7_base_class>: <double>
-       $ complex    : <R7_base_class>: <complex>
-       $ character  : <R7_base_class>: <character>
-       $ raw        : <R7_base_class>: <raw>
-       $ list       : <R7_base_class>: <list>
-       $ expression : <R7_base_class>: <expression>
-       $ function   : <R7_base_class>: <function>
-       $ environment: <R7_base_class>: <environment>
+      <R7_base_class>: <integer>
 
 # environments: can be printed
 

---FILE: tests/testthat/_snaps/class-spec.md---
@@ -1,15 +1,11 @@
-# can get class from base constructor
-
-    Can't convert `mean` to a valid class. No matching base class.
-
 # as_class gives informative errors
 
     Code
       as_class(""foo"")
     Error <simpleError>
-      Can't convert `""foo""` to a valid class. No base classes are called 'foo'
+      Can't convert `""foo""` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base class, not a <character>.
     Code
       as_class(TRUE)
     Error <simpleError>
-      Can't convert `TRUE` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base constructor function, not a <logical>.
+      Can't convert `TRUE` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base class, not a <logical>.
 

---FILE: tests/testthat/_snaps/class.md---
@@ -30,7 +30,7 @@
        ..  ..$ setter : NULL
        ..  ..$ default: NULL
        @ abstract   : logi FALSE
-       @ constructor: function (x = missing_class, y = missing_class)  
+       @ constructor: function (x = class_missing, y = class_missing)  
        @ validator  : NULL
     Code
       str(list(foo2))
@@ -47,7 +47,7 @@
     Code
       new_class(""foo"", 1)
     Error <simpleError>
-      Can't convert `parent` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base constructor function, not a <double>.
+      Can't convert `parent` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base class, not a <double>.
     Code
       new_class(""foo"", package = 1)
     Error <simpleError>
@@ -74,7 +74,7 @@
     Code
       new_class(""test"", parent = new_union(""character""))
     Error <simpleError>
-      `parent` must be an R7 class, S3 class, or base type, not an R7 union.
+      Can't convert `X[[i]]` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base class, not a <character>.
 
 # abstract classes: can't be instantiated
 
@@ -115,7 +115,7 @@
 # R7 object: displays nicely
 
     Code
-      foo <- new_class(""foo"", properties = list(x = double, y = double))
+      foo <- new_class(""foo"", properties = list(x = class_double, y = class_double))
       foo()
     Output
       <foo>
@@ -132,7 +132,7 @@
 # R7 object: displays objects with data nicely
 
     Code
-      text <- new_class(""text"", character)
+      text <- new_class(""text"", class_character)
       text(""x"")
     Output
       <text> chr ""x""

---FILE: tests/testthat/_snaps/constructor.md---
@@ -7,23 +7,23 @@
       new_object(NULL)
       <environment: namespace:R7>
     Code
-      new_constructor(R7_object, as_properties(list(x = ""numeric"", y = ""numeric"")))
+      new_constructor(R7_object, as_properties(list(x = class_numeric, y = class_numeric)))
     Output
-      function (x = missing_class, y = missing_class) 
+      function (x = class_missing, y = class_missing) 
       new_object(NULL, x = x, y = y)
       <environment: namespace:R7>
     Code
-      foo <- new_class(""foo"", parent = ""character"")
+      foo <- new_class(""foo"", parent = class_character)
       new_constructor(foo, list())
     Output
-      function (.data = missing_class) 
+      function (.data = class_missing) 
       new_object(foo(.data = .data))
       <environment: 0x0>
     Code
       foo2 <- new_class(""foo2"", parent = foo)
       new_constructor(foo2, list())
     Output
-      function (.data = missing_class) 
+      function (.data = class_missing) 
       new_object(foo2(.data = .data))
       <environment: 0x0>
 
@@ -36,27 +36,27 @@
       new_object(new_factor(.data = .data, levels = levels))
       <environment: 0x0>
     Code
-      new_constructor(S3_factor, as_properties(list(x = ""numeric"", y = ""numeric"")))
+      new_constructor(S3_factor, as_properties(list(x = class_numeric, y = class_numeric)))
     Output
-      function (.data = integer(), levels = character(), x = missing_class, 
-          y = missing_class) 
+      function (.data = integer(), levels = character(), x = class_missing, 
+          y = class_missing) 
       new_object(new_factor(.data = .data, levels = levels), x = x, 
           y = y)
       <environment: 0x0>
 
 # can generate constructor for inherited abstract classes
 
     Code
-      foo1 <- new_class(""foo1"", abstract = TRUE, properties = list(x = double))
+      foo1 <- new_class(""foo1"", abstract = TRUE, properties = list(x = class_double))
       new_constructor(foo1, list())
     Output
       function () 
       new_object(R7_object(), list())
       <environment: namespace:R7>
     Code
-      new_constructor(foo1, as_properties(list(y = double)))
+      new_constructor(foo1, as_properties(list(y = class_double)))
     Output
-      function (y = missing_class) 
+      function (y = class_missing) 
       new_object(R7_object(), list(y = y))
       <environment: namespace:R7>
 

---FILE: tests/testthat/_snaps/convert.md---
@@ -1,7 +1,7 @@
 # can register convert methods
 
     Code
-      convert(obj, to = double)
+      convert(obj, to = class_double)
     Error <simpleError>
       Can't find method for generic `convert()` with dispatch classes:
       - from: converttest, R7_object, ANY

---FILE: tests/testthat/_snaps/method-introspect.md---
@@ -12,14 +12,14 @@
     Code
       method(foo, 1)
     Error <simpleError>
-      Can't convert `signature` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base constructor function, not a <double>.
+      Can't convert `signature` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base class, not a <double>.
     Code
-      method(foo, new_union(""integer"", ""double""))
+      method(foo, new_union(class_integer, class_double))
     Error <simpleError>
       Can't dispatch on unions; must be a concrete type
     Code
       foo2 <- new_generic(""foo2"", c(""x"", ""y""))
-      method(foo2, object = list(""character""))
+      method(foo2, object = list(class_character))
     Error <simpleError>
       `object` must be length 2
 
@@ -28,11 +28,11 @@
     Code
       method(foo, list())
     Error <simpleError>
-      Can't convert `signature` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base constructor function, not a <list>.
+      Can't convert `signature` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base class, not a <list>.
     Code
       method(foo, list(""blah""))
     Error <simpleError>
-      Can't convert `signature` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base constructor function, not a <list>.
+      Can't convert `signature` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base class, not a <list>.
 
 # method explanation: shows all possible methods along with matches
 

---FILE: tests/testthat/_snaps/method-register.md---
@@ -1,8 +1,8 @@
 # method registration: adds messages when overwriting
 
     Code
-      method(foo, ""character"") <- (function(x) ""c"")
-      method(foo, ""character"") <- (function(x) ""c"")
+      method(foo, class_character) <- (function(x) ""c"")
+      method(foo, class_character) <- (function(x) ""c"")
     Message <simpleMessage>
       Overwriting method foo(<character>)
 
@@ -17,29 +17,29 @@
 
     Code
       x <- 10
-      method(x, ""character"") <- (function(x) ...)
+      method(x, class_character) <- (function(x) ...)
     Error <simpleError>
       `generic` must be a function, not a <double>
     Code
       method(foo, 1) <- (function(x) ...)
     Error <simpleError>
-      Can't convert `signature` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base constructor function, not a <double>.
+      Can't convert `signature` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base class, not a <double>.
 
 # as_signature(): forbids list for single dispatch
 
     Code
       as_signature(list(1), foo)
     Error <simpleError>
-      Can't convert `signature` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base constructor function, not a <list>.
+      Can't convert `signature` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base class, not a <list>.
 
 # as_signature(): requires a list of the correct length for multiple dispatch
 
     Code
-      as_signature(""character"", foo)
+      as_signature(class_character, foo)
     Error <simpleError>
       `signature` must be a list for multidispatch generics
     Code
-      as_signature(list(""character""), foo)
+      as_signature(list(class_character), foo)
     Error <simpleError>
       `signature` must be length 2
 
@@ -86,7 +86,7 @@
 # R7_method printing
 
     Code
-      method(foo, list(integer, integer))
+      method(foo, list(class_integer, class_integer))
     Output
       <R7_method> method(foo, list(""integer"", ""integer""))
       function (x, y, ...) 

---FILE: tests/testthat/_snaps/property.md---
@@ -40,9 +40,9 @@
 
     Code
       obj <- foo2(123)
-      x@x <- ""x""
+      obj@x <- ""x""
     Error <simpleError>
-      object 'x' not found
+      <foo2>@x must be <double>, not <character>
 
 # new_property(): validates getter and settor
 
@@ -58,7 +58,7 @@
 # new_property(): validates default
 
     Code
-      new_property(class = ""integer"", default = ""x"")
+      new_property(class_integer, default = ""x"")
     Error <simpleError>
       `default` must be an instance of <integer>, not a <character>
 
@@ -139,15 +139,15 @@
     Error <simpleError>
       `property[[1]]` is missing a name
     Code
-      as_properties(list(new_property(""character"")))
+      as_properties(list(new_property(class_character)))
     Error <simpleError>
       `property[[1]]` is missing a name
     Code
       as_properties(list(x = 1))
     Error <simpleError>
-      Can't convert `property$x` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base constructor function, not a <double>.
+      Can't convert `property$x` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base class, not a <double>.
     Code
-      as_properties(list(x = ""character"", x = ""character""))
+      as_properties(list(x = class_character, x = class_character))
     Error <simpleError>
       `properties` names must be unique
 

---FILE: tests/testthat/_snaps/special.md---
@@ -1,15 +1,15 @@
 # can test and print
 
     Code
-      print(missing_class)
+      print(class_missing)
     Output
       <R7_missing>
     Code
-      print(any_class)
+      print(class_any)
     Output
       <R7_any>
     Code
-      str(list(m = missing_class, a = any_class))
+      str(list(m = class_missing, a = class_any))
     Output
       List of 2
        $ m: <R7_missing>

---FILE: tests/testthat/_snaps/super.md---
@@ -2,7 +2,7 @@
 
     Code
       foo <- new_class(""foo"")
-      super(foo(), character)
+      super(foo(), class_character)
     Error <simpleError>
       <foo> doesn't inherit from <character>
 

---FILE: tests/testthat/_snaps/union.md---
@@ -10,22 +10,11 @@
 # base unions display as expected
 
     Code
-      base_unions
+      class_vector
     Output
-      $numeric
-      <R7_union>: <integer> or <double>
-      
-      $atomic
-      <R7_union>: <logical>, <integer>, <double>, <complex>, <character>, or <raw>
-      
-      $vector
       <R7_union>: <logical>, <integer>, <double>, <complex>, <character>, <raw>, <expression>, or <list>
-      
     Code
-      str(base_unions)
+      str(class_vector)
     Output
-      List of 3
-       $ numeric: <R7_union>: <integer> or <double>
-       $ atomic : <R7_union>: <logical>, <integer>, <double>, <complex>, <character>, or <raw>
-       $ vector : <R7_union>: <logical>, <integer>, <double>, <complex>, <character>, <raw>, <expression>, or <list>
+      <R7_union>: <logical>, <integer>, <double>, <complex>, <character>, <raw>, <expression>, or <list>
 

---FILE: tests/testthat/t2/R/pkg.R---
@@ -1,8 +1,8 @@
 foo <- R7::new_external_generic(""t1"", ""foo"", ""x"")
-R7::method(foo, ""character"") <- function(x) ""foo""
+R7::method(foo, R7::class_character) <- function(x) ""foo""
 
 bar <- R7::new_external_generic(""t0"", ""bar"", ""x"")
-R7::method(bar, ""character"") <- function(x) ""bar""
+R7::method(bar, R7::class_character) <- function(x) ""bar""
 
 .onLoad <- function(libname, pkgname) {
   R7::external_methods_register()

---FILE: tests/testthat/test-S4.R---
@@ -5,8 +5,8 @@ test_that(""can work with classGenerators"", {
 })
 
 test_that(""converts S4 base classes to R7 base classes"", {
-  expect_equal(S4_to_R7_class(getClass(""NULL"")), base_classes[[""NULL""]])
-  expect_equal(S4_to_R7_class(getClass(""character"")), base_classes$character)
+  expect_equal(S4_to_R7_class(getClass(""NULL"")), NULL)
+  expect_equal(S4_to_R7_class(getClass(""character"")), class_character)
 })
 
 test_that(""converts S4 unions to R7 unions"", {

---FILE: tests/testthat/test-base.R---
@@ -1,21 +1,23 @@
 test_that(""validation uses typeof"", {
-  expect_equal(base_classes$integer$validator(1L), NULL)
-  expect_equal(base_classes$integer$validator(factor()), NULL)
-  expect_snapshot(base_classes$integer$validator(TRUE))
+  expect_equal(class_integer$validator(1L), NULL)
+  expect_equal(class_integer$validator(factor()), NULL)
+  expect_snapshot(class_integer$validator(TRUE))
 
-  expect_equal(base_classes$`function`$validator(`[`), NULL)
-  expect_equal(base_classes$`function`$validator(sum), NULL)
-  expect_equal(base_classes$`function`$validator(mean), NULL)
+  expect_equal(class_function$validator(`[`), NULL)
+  expect_equal(class_function$validator(sum), NULL)
+  expect_equal(class_function$validator(mean), NULL)
 })
 
 test_that(""base class display as expected"", {
   expect_snapshot({
-    base_classes
-    str(base_classes)
+    class_integer
+    str(class_integer)
   })
 })
 
 test_that(""classes can inherit from base types"", {
+  base_classes <- c(class_vector$classes, list(class_function, class_environment))
+
   for (class in base_classes) {
     foo <- new_class(""foo"", parent = class)
     expect_error(foo(), NA)
@@ -24,14 +26,14 @@ test_that(""classes can inherit from base types"", {
 
 describe(""environments"", {
   it(""has reference semantics"", {
-    env <- new_class(""env"", ""environment"", properties = list(x = double))
+    env <- new_class(""env"", class_environment, properties = list(x = class_double))
     x1 <- x2 <- env(x = 1)
     x1@x <- 2
     expect_equal(x2@x, 2)
   })
 
   it(""can be printed"", {
-    env <- new_class(""env"", ""environment"", properties = list(x = double))
+    env <- new_class(""env"", class_environment, properties = list(x = class_double))
     expect_snapshot(env(x = 1), transform = scrub_environment)
   })
 })

---FILE: tests/testthat/test-class-spec.R---
@@ -35,8 +35,8 @@ test_that(""can work with R7 classes in packages"", {
 })
 
 test_that(""can work with unions"", {
-  text <- new_class(""text"", character)
-  number <- new_class(""number"", double)
+  text <- new_class(""text"", class_character)
+  number <- new_class(""number"", class_double)
   klass <- new_union(text, number)
   expect_equal(as_class(klass), klass)
 
@@ -73,11 +73,7 @@ test_that(""handles NULL"", {
 # base --------------------------------------------------------------------
 
 test_that(""can work with base types"", {
-  expect_equal(as_class(""character""), base_classes$character)
-  expect_equal(as_class(character), base_classes$character)
-  expect_equal(as_class(double), base_classes$double)
-
-  klass <- as_class(""character"")
+  klass <- class_character
   expect_equal(class_type(klass), ""R7_base"")
   expect_equal(class_dispatch(klass), c(""character"", ""R7_object"", ""ANY""))
   expect_equal(class_register(klass), ""character"")
@@ -93,24 +89,17 @@ test_that(""can work with base types"", {
 })
 
 test_that(""class_inherits handles variation in class names"", {
-  expect_true(class_inherits(1, base_classes$double))
-  expect_false(class_inherits(""x"", base_unions$double))
-
-  expect_true(class_inherits(1L, base_unions$numeric))
-  expect_true(class_inherits(1, base_unions$numeric))
-  expect_false(class_inherits(""x"", base_unions$numeric))
-
-  expect_true(class_inherits(function() {}, base_classes$`function`))
-  expect_true(class_inherits(sum, base_classes$`function`))
-  expect_true(class_inherits(`[`, base_classes$`function`))
-  expect_false(class_inherits(""x"", base_classes$`function`))
-})
+  expect_true(class_inherits(1, class_double))
+  expect_false(class_inherits(""x"", class_double))
 
-test_that(""can get class from base constructor"", {
-  expect_equal(as_class(character), base_classes$character)
-  expect_equal(as_class(`function`), base_classes$`function`)
+  expect_true(class_inherits(1L, class_numeric))
+  expect_true(class_inherits(1, class_numeric))
+  expect_false(class_inherits(""x"", class_numeric))
 
-  expect_snapshot_error(as_class(mean))
+  expect_true(class_inherits(function() {}, class_function))
+  expect_true(class_inherits(sum, class_function))
+  expect_true(class_inherits(`[`, class_function))
+  expect_false(class_inherits(""x"", class_function))
 })
 
 test_that(""dispatch for base objects use underlying type"", {
@@ -155,7 +144,7 @@ test_that(""can work with S3 classes"", {
 
 test_that(""can work with R7 classes that extend S3 classes"", {
   Date <- new_S3_class(""Date"", constructor = function(.data = numeric()) .Date(.data))
-  Date2 <- new_class(""Date2"", parent = Date, properties = list(x = ""numeric""))
+  Date2 <- new_class(""Date2"", parent = Date, properties = list(x = class_numeric))
 
   expect_equal(class_type(Date2), ""R7"")
   expect_equal(class_dispatch(Date2), c(""Date2"", ""Date"", ""R7_object"", ""ANY""))

---FILE: tests/testthat/test-class.R---
@@ -11,7 +11,7 @@ describe(""R7 classes"", {
   })
 
   it(""print nicely"", {
-    foo1 <- new_class(""foo1"", properties = list(x = ""integer"", y = ""integer""))
+    foo1 <- new_class(""foo1"", properties = list(x = class_integer, y = class_integer))
     foo2 <- new_class(""foo2"", foo1)
 
     expect_snapshot({
@@ -48,15 +48,15 @@ describe(""R7 classes"", {
 
 describe(""inheritance"", {
   it(""combines properties for parent classes"", {
-    foo1 <- new_class(""foo1"", properties = list(x = double))
-    foo2 <- new_class(""foo2"", foo1, properties = list(y = double))
+    foo1 <- new_class(""foo1"", properties = list(x = class_double))
+    foo2 <- new_class(""foo2"", foo1, properties = list(y = class_double))
     expect_equal(names(foo2@properties), c(""x"", ""y""))
   })
   it(""child properties override parent"", {
-    foo1 <- new_class(""foo1"", properties = list(x = ""numeric""))
-    foo2 <- new_class(""foo2"", foo1, properties = list(x = double))
+    foo1 <- new_class(""foo1"", properties = list(x = class_numeric))
+    foo2 <- new_class(""foo2"", foo1, properties = list(x = class_double))
     expect_equal(names(foo2@properties), ""x"")
-    expect_equal(foo2@properties$x$class, base_classes$double)
+    expect_equal(foo2@properties$x$class, class_double)
   })
 })
 
@@ -87,7 +87,7 @@ describe(""new_object()"", {
 
   it(""validates object"", {
     foo <- new_class(""foo"",
-      properties = list(x = new_property(double)),
+      properties = list(x = new_property(class_double)),
       validator = function(self) if (self@x < 0) ""x must be positive""
     )
 
@@ -108,24 +108,25 @@ describe(""R7 object"", {
 
   it(""displays nicely"", {
     expect_snapshot({
-      foo <- new_class(""foo"", properties = list(x = double, y = double))
+      foo <- new_class(""foo"", properties = list(x = class_double, y = class_double))
       foo()
       str(list(foo()))
     })
   })
 
   it(""displays objects with data nicely"", {
     expect_snapshot({
-      text <- new_class(""text"", character)
+      text <- new_class(""text"", class_character)
       text(""x"")
       str(list(text(""x"")))
     })
   })
 
   it(""displays list objects nicely"", {
     foo1 <- new_class(
-      ""foo1"", ""list"",
-      properties = list(x = ""double"", y = ""list"")
+      ""foo1"",
+      parent = class_list,
+      properties = list(x = class_double, y = class_list)
     )
     expect_snapshot(
       foo1(
@@ -142,16 +143,16 @@ describe(""R7 object"", {
 
 describe(""default constructor"", {
   it(""initializes properties with defaults"", {
-    foo1 <- new_class(""foo1"", properties = list(x = double))
+    foo1 <- new_class(""foo1"", properties = list(x = class_double))
     expect_equal(props(foo1()), list(x = double()))
 
-    foo2 <- new_class(""foo2"", foo1, properties = list(y = double))
+    foo2 <- new_class(""foo2"", foo1, properties = list(y = class_double))
     expect_equal(props(foo2()), list(x = double(), y = double()))
   })
 
   it(""overrides properties with arguments"", {
-    foo1 <- new_class(""foo1"", properties = list(x = double))
-    foo2 <- new_class(""foo2"", foo1, properties = list(y = double))
+    foo1 <- new_class(""foo1"", properties = list(x = class_double))
+    foo2 <- new_class(""foo2"", foo1, properties = list(y = class_double))
     expect_equal(props(foo2(x = 1)), list(x = 1, y = double()))
     expect_equal(props(foo2(x = 1, y = 2)), list(x = 1, y = 2))
   })
@@ -165,13 +166,13 @@ describe(""default constructor"", {
   })
 
   it(""initializes data with defaults"", {
-    text1 <- new_class(""text1"", parent = ""character"")
+    text1 <- new_class(""text1"", parent = class_character)
     obj <- text1()
     expect_equal(R7_data(obj), character())
   })
 
   it(""overrides data with defaults"", {
-    text1 <- new_class(""text1"", parent = ""character"")
+    text1 <- new_class(""text1"", parent = class_character)
     expect_equal(R7_data(text1(""x"")), ""x"")
   })
 

---FILE: tests/testthat/test-constructor.R---
@@ -5,7 +5,7 @@ test_that(""generates correct arguments from parent + properties"",  {
   expect_equal(args$parent, character())
 
   # Includes properties
-  args <- constructor_args(R7_object, as_properties(list(x = ""numeric"")))
+  args <- constructor_args(R7_object, as_properties(list(x = class_numeric)))
   expect_equal(args$self, ""x"")
   expect_equal(args$parent, character())
 
@@ -17,27 +17,27 @@ test_that(""generates correct arguments from parent + properties"",  {
   expect_equal(args$parent, character())
 
   # Includes parent properties
-  foo <- new_class(""foo"", properties = list(x = ""numeric""))
-  args <- constructor_args(foo, as_properties(list(y = ""numeric"")))
+  foo <- new_class(""foo"", properties = list(x = class_numeric))
+  args <- constructor_args(foo, as_properties(list(y = class_numeric)))
   expect_equal(args$self, ""y"")
   expect_equal(args$parent, ""x"")
 
   # But only those in the constructor
   foo <- new_class(""foo"",
-    properties = list(x = ""numeric""),
+    properties = list(x = class_numeric),
     constructor = function() new_object(x = 1)
   )
-  args <- constructor_args(foo, as_properties(list(y = ""numeric"")))
+  args <- constructor_args(foo, as_properties(list(y = class_numeric)))
   expect_equal(args$self, ""y"")
   expect_equal(args$parent, character())
 })
 
 test_that(""generates meaningful constructors"", {
   expect_snapshot({
     new_constructor(R7_object, list())
-    new_constructor(R7_object, as_properties(list(x = ""numeric"", y = ""numeric"")))
+    new_constructor(R7_object, as_properties(list(x = class_numeric, y = class_numeric)))
 
-    foo <- new_class(""foo"", parent = ""character"")
+    foo <- new_class(""foo"", parent = class_character)
     new_constructor(foo, list())
 
     foo2 <- new_class(""foo2"", parent = foo)
@@ -48,14 +48,14 @@ test_that(""generates meaningful constructors"", {
 test_that(""can generate constructors for S3 classes"", {
   expect_snapshot({
     new_constructor(S3_factor, list())
-    new_constructor(S3_factor, as_properties(list(x = ""numeric"", y = ""numeric"")))
+    new_constructor(S3_factor, as_properties(list(x = class_numeric, y = class_numeric)))
   }, transform = scrub_environment)
 })
 
 test_that(""can generate constructor for inherited abstract classes"", {
   expect_snapshot({
-    foo1 <- new_class(""foo1"", abstract = TRUE, properties = list(x = double))
+    foo1 <- new_class(""foo1"", abstract = TRUE, properties = list(x = class_double))
     new_constructor(foo1, list())
-    new_constructor(foo1, as_properties(list(y = double)))
+    new_constructor(foo1, as_properties(list(y = class_double)))
   }, transform = scrub_environment)
 })

---FILE: tests/testthat/test-convert.R---
@@ -1,22 +1,22 @@
 test_that(""can register convert methods"", {
   converttest <- new_class(""converttest"")
-  method(convert, list(converttest, character)) <- function(from, to, ...) ""c""
-  method(convert, list(converttest, integer)) <- function(from, to, ...) ""i""
+  method(convert, list(converttest, class_character)) <- function(from, to, ...) ""c""
+  method(convert, list(converttest, class_integer)) <- function(from, to, ...) ""i""
 
   obj <- converttest()
-  expect_equal(convert(obj, to = character), ""c"")
-  expect_equal(convert(obj, to = integer), ""i"")
+  expect_equal(convert(obj, to = class_character), ""c"")
+  expect_equal(convert(obj, to = class_integer), ""i"")
 
   # Errors if none found
-  expect_snapshot(convert(obj, to = double), error = TRUE)
+  expect_snapshot(convert(obj, to = class_double), error = TRUE)
 })
 
 test_that(""doesn't convert to subclass"", {
   converttest1 <- new_class(""converttest1"")
   converttest2 <- new_class(""converttest2"", converttest1)
 
-  method(convert, list(integer, converttest1)) <- function(from, to, ...) ""i""
-  expect_error(convert(integer, to = converttest2), ""Can't find method"")
+  method(convert, list(class_integer, converttest1)) <- function(from, to, ...) ""i""
+  expect_error(convert(class_integer, to = converttest2), ""Can't find method"")
 })
 
 describe(""fallback convert"", {
@@ -30,8 +30,8 @@ describe(""fallback convert"", {
   })
 
   it(""can convert to super class"", {
-    foo1 <- new_class(""foo1"", properties = list(x = double))
-    foo2 <- new_class(""foo2"", foo1, properties = list(y = double))
+    foo1 <- new_class(""foo1"", properties = list(x = class_double))
+    foo2 <- new_class(""foo2"", foo1, properties = list(y = class_double))
 
     obj <- convert(foo2(1, 2), to = foo1)
     expect_equal(class(obj), c(""foo1"", ""R7_object""))
@@ -41,16 +41,19 @@ describe(""fallback convert"", {
   })
 
   it(""can convert to S3 class"", {
-    factor2 <- new_class(""factor2"", S3_factor, properties = list(x = double))
+    factor2 <- new_class(""factor2"", S3_factor, properties = list(x = class_double))
     obj <- convert(factor2(1, ""x"", x = 1), to = S3_factor)
     expect_equal(class(obj), ""factor"")
     expect_equal(R7_class(obj), NULL)
     expect_equal(attr(obj, ""x""), NULL)
   })
 
   it(""can convert to base type"", {
-    character2 <- new_class(""character2"", ""character"", properties = list(x = double))
-    obj <- convert(character2(""x"", x = 1), to = character)
+    character2 <- new_class(""character2"",
+      parent = class_character,
+      properties = list(x = class_double)
+    )
+    obj <- convert(character2(""x"", x = 1), to = class_character)
     expect_equal(attr(obj, ""class""), NULL)
     expect_equal(R7_class(obj), NULL)
     expect_equal(attr(obj, ""x""), NULL)

---FILE: tests/testthat/test-data.R---
@@ -1,11 +1,11 @@
 describe(""R7_data"", {
-  text <- new_class(""text"", character)
+  text <- new_class(""text"", class_character)
   it(""retrieves .data"", {
     x <- text(""hi"")
     expect_equal(R7_data(x), ""hi"")
   })
   it(""strips properties"", {
-    text <- new_class(""text"", character, properties = list(x = ""integer""))
+    text <- new_class(""text"", class_character, properties = list(x = class_integer))
     x <- text(""hi"", x = 10L)
     expect_equal(attributes(R7_data(x)), NULL)
   })

---FILE: tests/testthat/test-generic.R---
@@ -28,13 +28,13 @@ test_that(""R7_generic printing"", {
   foo1 <- new_generic(""foo1"", ""x"")
   text <- new_class(""text"")
 
-  method(foo1, ""character"") <- function(x) 1
+  method(foo1, class_character) <- function(x) 1
   method(foo1, text) <- function(x) 2
 
   foo3 <- new_generic(""foo3"", c(""x"", ""y"", ""z""))
-  method(foo3, list(""character"", text, ""character"")) <- function(x, y, z, ...) 1
-  method(foo3, list(""character"", ""integer"", ""character"")) <- function(x, y, z, ...) 2
-  method(foo3, list(""character"", ""integer"", ""logical"")) <- function(x, y, z, ...) 3
+  method(foo3, list(class_character, text, class_character)) <- function(x, y, z, ...) 1
+  method(foo3, list(class_character, class_integer, class_character)) <- function(x, y, z, ...) 2
+  method(foo3, list(class_character, class_integer, class_logical)) <- function(x, y, z, ...) 3
 
   expect_snapshot({
     foo1

---FILE: tests/testthat/test-method-dispatch.R---
@@ -2,21 +2,21 @@ describe(""single dispatch"", {
   foo <- new_generic(""foo"", ""x"")
 
   it(""works for specials"", {
-    method(foo, missing_class) <- function(x) ""missing""
-    method(foo, any_class) <- function(x) ""fallback""
+    method(foo, class_missing) <- function(x) ""missing""
+    method(foo, class_any) <- function(x) ""fallback""
 
     expect_equal(foo(), ""missing"")
     expect_equal(foo(1), ""fallback"")
   })
 
   it(""works for base types"", {
-    method(foo, ""character"") <- function(x) ""base""
+    method(foo, class_character) <- function(x) ""base""
 
     expect_equal(foo(""bar""), ""base"")
   })
 
   it(""works for R7 objects"", {
-    text <- new_class(""text"", character)
+    text <- new_class(""text"", class_character)
     method(foo, text) <- function(x) ""R7""
 
     expect_equal(foo(text(""bar"")), ""R7"")
@@ -37,7 +37,7 @@ describe(""single dispatch"", {
   })
 
   it(""works for unions"", {
-    method(foo, new_union(""integer"", ""logical"")) <- function(x) ""union""
+    method(foo, new_union(class_integer, class_logical)) <- function(x) ""union""
 
     expect_equal(foo(TRUE), ""union"")
     expect_equal(foo(1L), ""union"")
@@ -63,16 +63,16 @@ describe(""multiple dispatch"", {
 
 test_that(""can substitute() args"", {
   foo <- new_generic(""foo"", ""x"", function(x, ..., z = 1) R7_dispatch())
-  method(foo, ""character"") <- function(x, ..., z = 1) substitute(x)
+  method(foo, class_character) <- function(x, ..., z = 1) substitute(x)
   expect_equal(foo(letters), quote(letters))
 
   suppressMessages(
-    method(foo, ""character"") <- function(x, ..., z = 1, y) substitute(y)
+    method(foo, class_character) <- function(x, ..., z = 1, y) substitute(y)
   )
   expect_equal(foo(""x"", y = letters), quote(letters))
 
   # Doesn't work currently
-  # method(foo, ""character"") <- function(x, ..., z = 1) substitute(z)
+  # method(foo, class_character) <- function(x, ..., z = 1) substitute(z)
   # expect_equal(foo(""x"", z = letters), quote(letters))
 })
 
@@ -81,7 +81,7 @@ test_that(""methods get values modified in the generic"", {
     y <- 10
     R7_dispatch()
   })
-  method(foo, ""character"") <- function(x, y = 1) y
+  method(foo, class_character) <- function(x, y = 1) y
   expect_equal(foo(""x"", 1), 10)
 })
 
@@ -95,32 +95,32 @@ test_that(""dispatched arguments are evaluated once"", {
   })
 
   f <- new_generic(""f"", ""x"")
-  method(f, ""numeric"") <- function(x) x
+  method(f, class_double) <- function(x) x
   expect_equal(f(counter()), 1)
 })
 
 test_that(""generics pass ... to methods"", {
   foo <- new_generic(""foo"", ""x"")
 
-  method(foo, ""character"") <- function(x, y = 1) y
+  method(foo, class_character) <- function(x, y = 1) y
   expect_equal(foo(""x""), 1)
   expect_equal(foo(""x"", y = 2), 2)
   expect_snapshot_error(foo(""x"", z = 2))
 })
 
 test_that(""generics pass extra args to methods"", {
   foo <- new_generic(""foo"", ""x"", function(x, ..., z = 1) R7_dispatch())
-  method(foo, ""character"") <- function(x, ..., z = 1) z
+  method(foo, class_character) <- function(x, ..., z = 1) z
   expect_equal(foo(""x"", z = 3), 3)
 })
 
 test_that(""can dispatch on base 'union' types"", {
   foo <- new_generic(""foo"", ""x"")
   suppressMessages({
-    method(foo, ""vector"") <- function(x) ""v""
-    method(foo, ""atomic"") <- function(x) ""a""
-    method(foo, ""numeric"") <- function(x) ""n""
-    method(foo, ""integer"") <- function(x) ""i""
+    method(foo, class_vector) <- function(x) ""v""
+    method(foo, class_atomic) <- function(x) ""a""
+    method(foo, class_numeric) <- function(x) ""n""
+    method(foo, class_integer) <- function(x) ""i""
   })
 
   expect_equal(foo(list()), ""v"")
@@ -131,7 +131,7 @@ test_that(""can dispatch on base 'union' types"", {
 
 test_that(""method lookup fails with informative messages"", {
   foo <- new_generic(""foo"", c(""x"", ""y""))
-  method(foo, list(""character"", ""integer"")) <- function(x, y) paste0(""bar:"", x, y)
+  method(foo, list(class_character, class_integer)) <- function(x, y) paste0(""bar:"", x, y)
   expect_snapshot_error(foo(TRUE))
   expect_snapshot_error(foo(TRUE, list()))
   expect_snapshot_error(foo(tibble::tibble(), .POSIXct(double())))

---FILE: tests/testthat/test-method-introspect.R---
@@ -1,10 +1,10 @@
 describe(""method introspection"", {
   test_that(""can dispatch by class or object"", {
     foo <- new_generic(""foo"", ""x"")
-    method(foo, ""character"") <- function(x) ""c""
+    method(foo, class_character) <- function(x) ""c""
 
     expect_equal(
-      method(foo, class = ""character""),
+      method(foo, class = class_character),
       method(foo, object = ""x"")
     )
   })
@@ -16,10 +16,10 @@ describe(""method introspection"", {
       foo <- new_generic(""foo"", ""x"")
       method(foo)
       method(foo, 1)
-      method(foo, new_union(""integer"", ""double""))
+      method(foo, new_union(class_integer, class_double))
 
       foo2 <- new_generic(""foo2"", c(""x"", ""y""))
-      method(foo2, object = list(""character""))
+      method(foo2, object = list(class_character))
     })
   })
 

---FILE: tests/testthat/test-method-register.R---
@@ -1,37 +1,37 @@
 describe(""method registration"", {
   it(""adds methods to the generic"", {
     foo <- new_generic(""foo"", ""x"")
-    method(foo, ""character"") <- function(x) ""c""
-    method(foo, ""integer"") <- function(x) ""i""
+    method(foo, class_character) <- function(x) ""c""
+    method(foo, class_integer) <- function(x) ""i""
     expect_length(methods(foo), 2)
   })
 
   it(""adds messages when overwriting"", {
     foo <- new_generic(""foo"", ""x"")
     expect_snapshot({
-      method(foo, ""character"") <- function(x) ""c""
-      method(foo, ""character"") <- function(x) ""c""
+      method(foo, class_character) <- function(x) ""c""
+      method(foo, class_character) <- function(x) ""c""
     })
     expect_length(methods(foo), 1)
   })
 
   it(""adds method for each element of a union"", {
     foo <- new_generic(""foo"", ""x"")
-    method(foo, ""numeric"") <- function(x) ""x""
+    method(foo, class_numeric) <- function(x) ""x""
 
     # one method for each union component
     expect_length(methods(foo), 2)
 
     # each method has the expected signature
-    expect_equal(method(foo, ""integer"")@signature, list(as_class(""integer"")))
-    expect_equal(method(foo, ""double"")@signature, list(as_class(""double"")))
+    expect_equal(method(foo, class_integer)@signature, list(class_integer))
+    expect_equal(method(foo, class_double)@signature, list(class_double))
   })
 
   it(""can register method for external generic from within package"", {
     on.exit(external_methods_reset(""R7""), add = TRUE)
 
     foo <- new_external_generic(""foo"", ""bar"" ,""x"")
-    register_external_method(foo, ""character"", function(x) ""bar"", package = ""R7"")
+    register_external_method(foo, class_character, function(x) ""bar"", package = ""R7"")
     expect_length(external_methods_get(""R7""), 1)
 
     # and doesn't modify generic
@@ -73,7 +73,7 @@ describe(""method registration"", {
     foo <- new_generic(""foo"", ""x"")
     expect_snapshot(error = TRUE, {
       x <- 10
-      method(x, ""character"") <- function(x) ...
+      method(x, class_character) <- function(x) ...
       method(foo, 1) <- function(x) ...
     })
   })
@@ -82,12 +82,12 @@ describe(""method registration"", {
 describe(""as_signature()"", {
   it(""returns a list that matches length of dispatch args"", {
     foo1 <- new_generic(""foo1"", ""x"")
-    sig1 <- as_signature(""numeric"", foo1)
+    sig1 <- as_signature(class_numeric, foo1)
     expect_s3_class(sig1, ""R7_signature"")
     expect_length(sig1, 1)
 
     foo2 <- new_generic(""foo2"", c(""x"", ""y""))
-    sig2 <- as_signature(list(""numeric"", ""character""), foo2)
+    sig2 <- as_signature(list(class_numeric, class_character), foo2)
     expect_s3_class(sig1, ""R7_signature"")
     expect_length(sig2, 2)
   })
@@ -104,8 +104,8 @@ describe(""as_signature()"", {
   it(""requires a list of the correct length for multiple dispatch"", {
     foo <- new_generic(""foo"", c(""x"", ""y""))
     expect_snapshot(error = TRUE, {
-      as_signature(""character"", foo)
-      as_signature(list(""character""), foo)
+      as_signature(class_character, foo)
+      as_signature(list(class_character), foo)
     })
   })
 })
@@ -145,9 +145,9 @@ test_that(""check_method warn if default arguments don't match"", {
 
 test_that(""R7_method printing"", {
   foo <- new_generic(""foo"", c(""x"", ""y""))
-  method(foo, list(integer, integer)) <- function(x, y, ...) paste0(""bar:"", x, y)
+  method(foo, list(class_integer, class_integer)) <- function(x, y, ...) paste0(""bar:"", x, y)
   expect_snapshot(
-    method(foo, list(integer, integer)),
+    method(foo, list(class_integer, class_integer)),
     transform = scrub_environment
   )
 })

---FILE: tests/testthat/test-property.R---
@@ -1,6 +1,6 @@
 describe(""property retrieval"", {
   it(""retrieves the properties that exist & errors otherwise"", {
-    foo <- new_class(""foo"", properties = list(xyz = double))
+    foo <- new_class(""foo"", properties = list(xyz = class_double))
     obj <- foo(1)
     expect_equal(prop(obj, ""xyz""), 1)
     expect_equal(obj@xyz, 1)
@@ -27,7 +27,7 @@ describe(""property retrieval"", {
 
 describe(""prop setting"", {
   it(""can set a property"", {
-    foo <- new_class(""foo"", properties = list(xyz = double))
+    foo <- new_class(""foo"", properties = list(xyz = class_double))
     obj <- foo(1)
 
     prop(obj, ""xyz"") <- 2
@@ -58,7 +58,7 @@ describe(""prop setting"", {
   })
 
   it(""errors if the property doesn't exist or is wrong class"", {
-    foo <- new_class(""foo"", properties = list(x = double))
+    foo <- new_class(""foo"", properties = list(x = class_double))
     expect_snapshot(error = TRUE, {
       obj <- foo(123)
       obj@foo <- 10
@@ -67,18 +67,18 @@ describe(""prop setting"", {
 
     foo2 <- new_class(""foo2"", properties = list(x =
       new_property(
-        double,
+        class_double,
         setter = function(self, value) self
       )
     ))
     expect_snapshot(error = TRUE, {
       obj <- foo2(123)
-      x@x <- ""x""
+      obj@x <- ""x""
     })
   })
 
   it(""does not run the check or validation functions if check = FALSE"", {
-    foo <- new_class(""foo"", properties = list(x = double))
+    foo <- new_class(""foo"", properties = list(x = class_double))
     obj <- foo(123)
     prop(obj, ""x"", check = FALSE) <- ""foo""
     expect_equal(obj@x, ""foo"")
@@ -93,7 +93,7 @@ describe(""prop setting"", {
 describe(""props<-"", {
   it(""validates after setting all properties"", {
     foo <- new_class(""foo"",
-      properties = list(x = double, y = double),
+      properties = list(x = class_double, y = class_double),
       validator = function(self) if (self@x > self@y) ""bad""
     )
 
@@ -106,7 +106,7 @@ describe(""props<-"", {
 
 describe(""property access"", {
   it(""access en masse"", {
-    foo <- new_class(""foo"", properties = list(x = ""numeric"", y = ""numeric""))
+    foo <- new_class(""foo"", properties = list(x = class_numeric, y = class_numeric))
     x <- foo(x = 1, y = 2)
     expect_equal(prop_names(x), c(""x"", ""y""))
     expect_equal(props(x), list(x = 1, y = 2))
@@ -143,7 +143,7 @@ describe(""property access"", {
 
 
 test_that(""properties can be NULL"", {
-  foo <- new_class(""foo"", properties = list(x = any_class))
+  foo <- new_class(""foo"", properties = list(x = class_any))
   x <- foo(x = NULL)
   expect_equal(x@x, NULL)
   x@x <- 1
@@ -164,12 +164,12 @@ describe(""new_property()"", {
 
   it(""validates default"", {
     expect_snapshot(error = TRUE, {
-      new_property(class = ""integer"", default = ""x"")
+      new_property(class_integer, default = ""x"")
     })
   })
 
   it(""displays nicely"", {
-    x <- new_property(""integer"", name = ""foo"")
+    x <- new_property(class_integer, name = ""foo"")
     expect_snapshot({
       print(x)
       str(list(x))
@@ -183,13 +183,13 @@ test_that(""properties can be base, S3, S4, R7, or R7 union"", {
 
   my_class <- new_class(""my_class"",
     properties = list(
-      anything = any_class,
+      anything = class_any,
       null = NULL,
-      base = ""integer"",
+      base = class_integer,
       S3 = new_S3_class(""factor""),
       S4 = class_S4,
       R7 = class_R7,
-      R7_union = new_union(""integer"", ""logical"")
+      R7_union = new_union(class_integer, class_logical)
     )
   )
   expect_snapshot(my_class)
@@ -225,21 +225,21 @@ test_that(""properties can be base, S3, S4, R7, or R7 union"", {
 test_that(""as_properties normalises properties"", {
   expect_equal(as_properties(NULL), list())
   expect_equal(
-    as_properties(list(x = ""numeric"")),
-    list(x = new_property(""numeric"", name = ""x"")
+    as_properties(list(x = class_numeric)),
+    list(x = new_property(class_numeric, name = ""x"")
   ))
   expect_equal(
-    as_properties(list(x = new_property(class = ""numeric""))),
-    list(x = new_property(""numeric"", name = ""x"")
+    as_properties(list(x = new_property(class = class_numeric))),
+    list(x = new_property(class_numeric, name = ""x"")
   ))
 })
 
 test_that(""as_properties() gives useful error messages"", {
   expect_snapshot(error = TRUE, {
     as_properties(1)
     as_properties(list(1))
-    as_properties(list(new_property(""character"")))
+    as_properties(list(new_property(class_character)))
     as_properties(list(x = 1))
-    as_properties(list(x = ""character"", x = ""character""))
+    as_properties(list(x = class_character, x = class_character))
   })
 })

---FILE: tests/testthat/test-special.R---
@@ -1,13 +1,13 @@
 test_that(""can test and print"", {
-  expect_true(is_missing_class(missing_class))
-  expect_false(is_missing_class(any_class))
-  expect_true(is_any_class(any_class))
-  expect_false(is_any_class(missing_class))
+  expect_true(is_class_missing(class_missing))
+  expect_false(is_class_missing(class_any))
+  expect_true(is_class_any(class_any))
+  expect_false(is_class_any(class_missing))
 
   expect_snapshot({
-    print(missing_class)
-    print(any_class)
+    print(class_missing)
+    print(class_any)
 
-    str(list(m = missing_class, a = any_class))
+    str(list(m = class_missing, a = class_any))
   })
 })

---FILE: tests/testthat/test-super.R---
@@ -32,7 +32,7 @@ describe(""super()"", {
   it(""checks to"", {
     expect_snapshot(error = TRUE, {
       foo <- new_class(""foo"")
-      super(foo(), character)
+      super(foo(), class_character)
     })
   })
 

---FILE: tests/testthat/test-union.R---
@@ -7,30 +7,30 @@ test_that(""has useful print method"", {
 })
 
 test_that(""can construct from base types"", {
-  u1 <- new_union(character)
+  u1 <- new_union(class_character)
   expect_s3_class(u1, ""R7_union"")
-  expect_equal(u1$classes, list(base_classes$character))
+  expect_equal(u1$classes, list(class_character))
 
-  u2 <- new_union(character, integer)
+  u2 <- new_union(class_character, class_integer)
   expect_s3_class(u2, ""R7_union"")
-  expect_equal(u2$classes, list(base_classes$character, base_classes$integer))
+  expect_equal(u2$classes, list(class_character, class_integer))
 })
 
 test_that(""can construct from unions"", {
-  u1 <- new_union(character)
-  u2 <- new_union(integer)
+  u1 <- new_union(class_character)
+  u2 <- new_union(class_integer)
 
   u3 <- new_union(u1, u2)
   expect_s3_class(u3, ""R7_union"")
-  expect_equal(u3$classes, list(base_classes$character, base_classes$integer))
+  expect_equal(u3$classes, list(class_character, class_integer))
 
-  expect_equal(new_union(u1, integer), u3)
+  expect_equal(new_union(u1, class_integer), u3)
 })
 
 test_that(""base unions display as expected"", {
   expect_snapshot({
-    base_unions
-    str(base_unions)
+    class_vector
+    str(class_vector)
   })
 })
 

---FILE: tests/testthat/test-valid.R---
@@ -1,6 +1,6 @@
 test_that(""validate() validates object and type recursively"", {
   klass <- new_class(""klass"",
-    properties = list(x = ""double"", y = ""double""),
+    properties = list(x = class_double, y = class_double),
     validator = function(self) {
       c(
         if (self@x < 0) ""x must be positive"",
@@ -18,7 +18,7 @@ test_that(""validate() validates object and type recursively"", {
     validate(obj)
   })
 
-  klass2 <- new_class(""klass2"", parent = klass, properties = list(z = ""double""))
+  klass2 <- new_class(""klass2"", parent = klass, properties = list(z = class_double))
   expect_snapshot(error = TRUE, {
     obj <- klass2(1, -1, 1)
     attr(obj, ""x"") <- -1
@@ -31,7 +31,7 @@ test_that(""validate() validates object and type recursively"", {
 })
 
 test_that(""validate checks base type"", {
-  Double <- new_class(""Double"", parent = ""double"")
+  Double <- new_class(""Double"", parent = class_double)
   x <- Double(10)
   mode(x) <- ""character""
 
@@ -40,7 +40,7 @@ test_that(""validate checks base type"", {
 
 test_that(""valid eventually calls the validation function only at the end"", {
   foo <- new_class(""foo"",
-    properties = list(x = double),
+    properties = list(x = class_double),
     validator = function(self) if (self@x < 0) ""must be positive""
   )
   obj <- foo(10)
@@ -55,7 +55,7 @@ test_that(""valid eventually calls the validation function only at the end"", {
 
 test_that(""valid implicitly does _not_ call the validation function"", {
   foo <- new_class(""foo"",
-    properties = list(x = double),
+    properties = list(x = class_double),
     validator = function(self) if (self@x < 0) ""must be positive""
   )
   obj <- foo(10)

---FILE: tests/testthat/test-zzz.R---
@@ -12,7 +12,7 @@ test_that(""$ gives useful error"", {
   })
 
   # But works as expected if inheriting from list
-  foo <- new_class(""foo"", list)
+  foo <- new_class(""foo"", class_list)
   x <- foo()
   x$x <- 1
   expect_equal(x$x, 1)

---FILE: vignettes/R7.Rmd---
@@ -28,10 +28,10 @@ range <- new_class(""range"",
     }
   },
   properties = list(
-    start = ""numeric"",
-    end = ""numeric"",
+    start = class_numeric,
+    end = class_numeric,
     length = new_property(
-      class = ""numeric"",
+      class = class_numeric,
       getter = function(self) self@end - self@start,
       setter = function(self, value) {
         self@end <- self@start + value
@@ -76,7 +76,7 @@ x
 ## Generics and methods
 
 ```{r}
-text <- new_class(""text"", parent = ""character"")
+text <- new_class(""text"", parent = class_character)
 foo <- new_generic(""foo"", ""x"")
 method(foo, text) <- function(x, ...) paste0(""foo-"", x)
 
@@ -95,7 +95,7 @@ At each level the search iteratively searches along objects class vector.
 
 ```{r}
 bar <- new_generic(""bar"", c(""x"", ""y""))
-method(bar, list(""character"", ""double"")) <- function(x, y) paste0(""foo-"", x, "":"", y)
+method(bar, list(class_character, class_double)) <- function(x, y) paste0(""foo-"", x, "":"", y)
 
 bar(""hi"", 42)
 ```
@@ -106,7 +106,7 @@ Sometimes you want to implement a method in terms of behavior already provided b
 If you need to access a method for a superclass that your class is overriding, you can use `super()`:
 
 ```{r}
-method(bar, list(text, ""double"")) <- function(x, y, ...) {
+method(bar, list(text, class_double)) <- function(x, y, ...) {
   res <- bar(super(x), y)
   paste0(""2 "", res)
 }

---FILE: vignettes/case_studies.Rmd---
@@ -25,7 +25,7 @@ This case study demonstrates creating basic classes with accessors functions, in
 ```{r}
 Person <- new_class(""Person"",
   properties = list(
-    name = ""character"",
+    name = class_character,
     birthdate = new_property(
       class = new_S3_class(""Date""),
       setter = function(self, value) {
@@ -35,7 +35,7 @@ Person <- new_class(""Person"",
       default = as.Date(NA)
     ),
     age = new_property(
-      class = ""numeric"",
+      class = class_numeric,
       getter = function(self) {
         # This is not correct because of leap years,
         # see https://stackoverflow.com/questions/3611314/calculate-ages-in-r/25450756#25450756 for a correct implementation.
@@ -171,7 +171,7 @@ The subsets the individual components appropriately and then returns a new `anno
 ```{r}
 subset_R7 <- new_generic(""R7_subset"", c(""object"", ""row"", ""column""))
 
-method(subset_R7, list(annotated_df, ""integer"", ""integer"")) <- function(object, row, column, ...) {
+method(subset_R7, list(annotated_df, class_integer, class_integer)) <- function(object, row, column, ...) {
   data <- object@data[row, column]
   rows <- object@rows[row, ]
   columns <-  object@columns[column, ]

---FILE: vignettes/minutes/2022-03-08.Rmd---
@@ -14,10 +14,10 @@ title: ""Minutes 2022-03-08""
 
     -   `new_generic(""foo"", ""x"", function(x, y) call_method())`
 
--   New `any_class` (could already define methods for `R7_object`) and `missing_class` sentinels.
+-   New `class_any` (could already define methods for `R7_object`) and `class_missing` sentinels.
 
 -   When creating an object, unspecified properties are initialized with their default value (#67).
-    To achieve this, the constructor arguments default to `missing_class`, since `NULL` would prevent a default value of `NULL`, and `missing()` requires too many gymnastics.
+    To achieve this, the constructor arguments default to `class_missing`, since `NULL` would prevent a default value of `NULL`, and `missing()` requires too many gymnastics.
 
     -   `new_class(""foo"", properties = list(x = integer, y = double))@constructor`
 

---FILE: vignettes/performance.Rmd---
@@ -21,8 +21,8 @@ library(R7)
 The dispatch performance should be roughly on par with S3 and S4, though as this is implemented in a package there is some overhead due to `.Call` vs `.Primitive`.
 
 ```{r performance, cache = FALSE}
-text <- new_class(""text"", parent = ""character"")
-number <- new_class(""number"", parent = ""double"")
+text <- new_class(""text"", parent = class_character)
+number <- new_class(""number"", parent = class_double)
 
 x <- text(""hi"")
 y <- number(1)
@@ -80,7 +80,7 @@ bench::press(
   class_nchar = c(15, 100),
   {
     # Construct a class hierarchy with that number of classes
-    text <- new_class(""text"", parent = ""character"")
+    text <- new_class(""text"", parent = class_character)
     parent <- text
     classes <- gen_character(num_classes, min = class_nchar, max = class_nchar)
     env <- new.env()
@@ -119,7 +119,7 @@ bench::press(
   class_nchar = c(15, 100),
   {
     # Construct a class hierarchy with that number of classes
-    text <- new_class(""text"", parent = ""character"")
+    text <- new_class(""text"", parent = class_character)
     parent <- text
     classes <- gen_character(num_classes, min = class_nchar, max = class_nchar)
     env <- new.env()"
RConsortium,S7,e8ab1b5945e81f2a33bc2f718f89f9ca7d955cbe,Hadley Wickham,h.wickham@gmail.com,2022-03-17T16:06:27Z,GitHub,noreply@github.com,2022-03-17T16:06:27Z,"Allow abstract classes (#209)

Fixes #199",NEWS.md;R/class.R;R/constructor.R;R/property.R;man/new_class.Rd;tests/testthat/_snaps/class.md;tests/testthat/_snaps/constructor.md;tests/testthat/test-class.R;tests/testthat/test-constructor.R,False,True,True,False,88,3,91,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # R7 0.0.0.9000
 
+* `new_class()` can create abstract classes (#199).
+
 * `method_call()` is now `R7_dispatch()` (#200).
 
 ## Mar 2022

---FILE: R/class.R---
@@ -16,6 +16,8 @@
 #'   the package name in the class name when it's used for dispatch. This
 #'   allows different packages to use the same name to refer to different
 #'   classes. If you see `package`, you _must_ export the constructor.
+#' @param abstract Is this an abstract class? An abstract class can not be
+#'   instantiated.
 #' @param constructor The constructor function. Advanced use only.
 #'
 #'   A custom constructor should call `new_object()` to create the R7 object.
@@ -90,6 +92,7 @@ new_class <- function(
     parent = R7_object,
     package = NULL,
     properties = list(),
+    abstract = FALSE,
     constructor = NULL,
     validator = NULL) {
 
@@ -109,6 +112,9 @@ new_class <- function(
     if (!is.null(validator)) {
       check_function(validator, alist(self = ))
     }
+    if (abstract && !(parent@abstract || parent@name == ""R7_object"")) {
+      stop(""Abstract classes must have abstract parents"")
+    }
   }
 
   # Combine properties from parent, overriding as needed
@@ -126,14 +132,15 @@ new_class <- function(
   attr(object, ""parent"") <- parent
   attr(object, ""package"") <- package
   attr(object, ""properties"") <- all_props
+  attr(object, ""abstract"") <- abstract
   attr(object, ""constructor"") <- constructor
   attr(object, ""validator"") <- validator
   class(object) <- c(""R7_class"", ""R7_object"")
 
   global_variables(names(all_props))
   object
 }
-globalVariables(c(""name"", ""parent"", ""package"", ""properties"", ""constructor"", ""validator""))
+globalVariables(c(""name"", ""parent"", ""package"", ""properties"", ""abstract"", ""constructor"", ""validator""))
 
 R7_class_name <- function(x) {
   paste(c(x@package, x@name), collapse = ""::"")
@@ -209,6 +216,10 @@ new_object <- function(.parent, ...) {
   if (!inherits(class, ""R7_class"")) {
     stop(""`new_object()` must be called from within a constructor"")
   }
+  if (class@abstract) {
+    msg <- sprintf(""Can't construct an object from abstract class <%s>"", class@name)
+    stop(msg)
+  }
 
   args <- list(...)
   nms <- names(args)

---FILE: R/constructor.R---
@@ -9,6 +9,13 @@ new_constructor <- function(parent, properties) {
       env = asNamespace(""R7"")
     ))
   }
+  if (is_class(parent) && parent@abstract) {
+    return(new_function(
+      args = missing_args(arg_info$self),
+      body = new_call(""new_object"", c(list(quote(R7_object()), self_args))),
+      env = asNamespace(""R7"")
+    ))
+  }
 
   if (is_class(parent)) {
     parent_name <- parent@name
@@ -42,7 +49,7 @@ constructor_args <- function(parent, properties = list()) {
   parent_args <- names2(formals(class_constructor(parent)))
 
   self_args <- names2(properties)
-  if (is_class(parent)) {
+  if (is_class(parent) && !parent@abstract) {
     # Remove dynamic arguments
     self_args <- self_args[vlapply(properties, function(x) is.null(x$getter))]
     # Remove any parent properties; can't use parent_args() since the constructor

---FILE: R/property.R---
@@ -252,7 +252,7 @@ prop_names <- function(object) {
 
   if (inherits(object, ""R7_class"")) {
     # R7_class isn't a R7_class (somewhat obviously) so we fake the property names
-    c(""name"", ""parent"", ""package"", ""properties"", ""constructor"", ""validator"")
+    c(""name"", ""parent"", ""package"", ""properties"", ""abstract"", ""constructor"", ""validator"")
   } else {
     class <- R7_class(object)
     props <- attr(class, ""properties"", exact = TRUE)

---FILE: man/new_class.Rd---
@@ -10,6 +10,7 @@ new_class(
   parent = R7_object,
   package = NULL,
   properties = list(),
+  abstract = FALSE,
   constructor = NULL,
   validator = NULL
 )
@@ -38,6 +39,9 @@ belong to each instance of the class. Each element of the list can
 either be a type specification (processed by \code{\link[=as_class]{as_class()}}) or a
 full property specification created \code{\link[=new_property]{new_property()}}.}
 
+\item{abstract}{Is this an abstract class? An abstract class can not be
+instantiated.}
+
 \item{constructor}{The constructor function. Advanced use only.
 
 A custom constructor should call \code{new_object()} to create the R7 object.

---FILE: tests/testthat/_snaps/class.md---
@@ -29,6 +29,7 @@
        ..  ..$ getter : NULL
        ..  ..$ setter : NULL
        ..  ..$ default: NULL
+       @ abstract   : logi FALSE
        @ constructor: function (x = missing_class, y = missing_class)  
        @ validator  : NULL
     Code
@@ -75,6 +76,22 @@
     Error <simpleError>
       `parent` must be an R7 class, S3 class, or base type, not an R7 union.
 
+# abstract classes: can't be instantiated
+
+    Code
+      foo <- new_class(""foo"", abstract = TRUE)
+      foo()
+    Error <simpleError>
+      Can't construct an object from abstract class <foo>
+
+# abstract classes: can't inherit from concrete class
+
+    Code
+      foo1 <- new_class(""foo1"")
+      new_class(""foo2"", parent = foo1, abstract = TRUE)
+    Error <simpleError>
+      Abstract classes must have abstract parents
+
 # new_object(): gives useful error if called directly
 
     Code

---FILE: tests/testthat/_snaps/constructor.md---
@@ -44,3 +44,19 @@
           y = y)
       <environment: 0x0>
 
+# can generate constructor for inherited abstract classes
+
+    Code
+      foo1 <- new_class(""foo1"", abstract = TRUE, properties = list(x = double))
+      new_constructor(foo1, list())
+    Output
+      function () 
+      new_object(R7_object(), list())
+      <environment: namespace:R7>
+    Code
+      new_constructor(foo1, as_properties(list(y = double)))
+    Output
+      function (y = missing_class) 
+      new_object(R7_object(), list(y = y))
+      <environment: namespace:R7>
+

---FILE: tests/testthat/test-class.R---
@@ -60,6 +60,26 @@ describe(""inheritance"", {
   })
 })
 
+describe(""abstract classes"", {
+  it(""can't be instantiated"", {
+    expect_snapshot(error = TRUE, {
+      foo <- new_class(""foo"", abstract = TRUE)
+      foo()
+    })
+  })
+  it(""can't inherit from concrete class"", {
+    expect_snapshot(error = TRUE, {
+      foo1 <- new_class(""foo1"")
+      new_class(""foo2"", parent = foo1, abstract = TRUE)
+    })
+  })
+  it(""can construct concrete subclasses"", {
+    foo1 <- new_class(""foo1"", abstract = TRUE)
+    foo2 <- new_class(""foo2"", parent = foo1)
+    expect_s3_class(foo2(), ""foo2"")
+  })
+})
+
 describe(""new_object()"", {
   it(""gives useful error if called directly"",{
     expect_snapshot(new_object(), error = TRUE)

---FILE: tests/testthat/test-constructor.R---
@@ -51,3 +51,11 @@ test_that(""can generate constructors for S3 classes"", {
     new_constructor(S3_factor, as_properties(list(x = ""numeric"", y = ""numeric"")))
   }, transform = scrub_environment)
 })
+
+test_that(""can generate constructor for inherited abstract classes"", {
+  expect_snapshot({
+    foo1 <- new_class(""foo1"", abstract = TRUE, properties = list(x = double))
+    new_constructor(foo1, list())
+    new_constructor(foo1, as_properties(list(y = double)))
+  }, transform = scrub_environment)
+})"
RConsortium,S7,59ae37083e4a756e4c054e1e2eeba83c92fce250,Hadley Wickham,h.wickham@gmail.com,2022-03-16T15:08:18Z,Hadley Wickham,h.wickham@gmail.com,2022-03-16T15:08:18Z,Including call in @ error doesn't add any useful info,R/property.R,False,True,True,False,1,1,2,"---FILE: R/property.R---
@@ -140,7 +140,7 @@ prop <- function(object, name) {
   check_R7(object)
 
   if (!prop_exists(object, name)) {
-    stop(prop_error_unknown(object, name))
+    stop(prop_error_unknown(object, name), call. = FALSE)
   } else {
     prop_val(object, name)
   }"
RConsortium,S7,3576e97c7f8bbcf37e909f91a8a1a19ea54e4469,Hadley Wickham,h.wickham@gmail.com,2022-03-15T21:56:51Z,GitHub,noreply@github.com,2022-03-15T21:56:51Z,"Rename method_call() to R7_dispatch() (#208)

Fixes #200",NAMESPACE;NEWS.md;R/generic.R;R/method-dispatch.R;R/method-introspect.R;README.Rmd;README.md;man/method.Rd;man/new_generic.Rd;tests/testthat/_snaps/generic.md;tests/testthat/_snaps/method-register.md;tests/testthat/test-method-dispatch.R;tests/testthat/test-method-register.R,True,True,True,False,31,29,60,"---FILE: NAMESPACE---
@@ -31,13 +31,13 @@ export(""prop<-"")
 export(""props<-"")
 export(R7_class)
 export(R7_data)
+export(R7_dispatch)
 export(R7_object)
 export(any_class)
 export(as_class)
 export(convert)
 export(external_methods_register)
 export(method)
-export(method_call)
 export(method_explain)
 export(missing_class)
 export(new_S3_class)

---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # R7 0.0.0.9000
 
+* `method_call()` is now `R7_dispatch()` (#200).
+
 ## Mar 2022
 
 * `convert()` allows you to convert an object into another class (#136).

---FILE: R/generic.R---
@@ -5,7 +5,7 @@
 #' the class of one or more arguments (the _signature_). Create a new generic
 #' with `new_generic()` then use [method<-] to add methods to it.
 #'
-#' Method dispatch is performed by `method_call()`, which must always be
+#' Method dispatch is performed by `R7_dispatch()`, which must always be
 #' included in the body of the generic, but in most cases `new_generic()` will
 #' generate this for you.
 #'
@@ -24,7 +24,7 @@
 #' @param dispatch_args A character vector giving the names of one or more
 #'   arguments used to find the method.
 #' @param fun An optional specification of the generic, which must call
-#'  `method_call()` to dispatch to methods. This is usually generated
+#'  `R7_dispatch()` to dispatch to methods. This is usually generated
 #'  automatically from the `dispatch_args`, but you may want to supply it if
 #'  you want to add additional required arguments, omit `...`, or perform
 #'  some standardised computation in the generic.
@@ -49,7 +49,7 @@
 #' # If you want to require that methods implement additional arguments,
 #' # you can use a custom function:
 #' mean2 <- new_generic(""mean2"", ""x"", function(x, ..., na.rm = FALSE) {
-#'    method_call()
+#'    R7_dispatch()
 #' })
 #'
 #' method(mean2, ""numeric"") <- function(x, ..., na.rm = FALSE) {
@@ -71,7 +71,7 @@ new_generic <- function(name, dispatch_args, fun = NULL) {
   if (is.null(fun)) {
     args <- c(dispatch_args, ""..."")
     args <- setNames(lapply(args, function(i) quote(expr = )), args)
-    fun <- new_function(args, quote(method_call()), topenv(environment()))
+    fun <- new_function(args, quote(R7_dispatch()), topenv(environment()))
   } else {
     check_generic(fun)
   }
@@ -128,9 +128,9 @@ check_generic <- function(fun) {
     stop(""`fun` must be a function"", call. = FALSE)
   }
 
-  method_call <- find_call(body(fun), quote(method_call))
-  if (is.null(method_call)) {
-    stop(""`fun` must contain a call to `method_call()`"", call. = FALSE)
+  dispatch_call <- find_call(body(fun), quote(R7_dispatch))
+  if (is.null(dispatch_call)) {
+    stop(""`fun` must contain a call to `R7_dispatch()`"", call. = FALSE)
   }
 }
 find_call <- function(x, name) {

---FILE: R/method-dispatch.R---
@@ -13,6 +13,6 @@ method_lookup_error <- function(name, args, signatures) {
 #' @rdname new_generic
 #' @order 2
 #' @export
-method_call <- function() {
+R7_dispatch <- function() {
   .Call(method_call_, sys.call(-1), sys.function(-1), sys.frame(-1))
 }

---FILE: R/method-introspect.R---
@@ -2,7 +2,7 @@
 #'
 #' `method()` takes a generic and signature and retrieves the corresponding
 #' method. This is rarely needed because most of the time you'll rely on the
-#' the generic, via [method_call()], to find and call the method for you.
+#' the generic, via [R7_dispatch()], to find and call the method for you.
 #' However, this introspection is useful if you want to see the implementation
 #' of a specific method.
 #'

---FILE: README.Rmd---
@@ -76,7 +76,7 @@ mean(x)
 # Create a new generic
 inside <- new_generic(""inside"", ""x"", function(x, y) {
   # Actually finds and calls the appropriate method
-  method_call()
+  R7_dispatch()
 })
 # Add a method for our class
 method(inside, Range) <- function(x, y) y >= x@start & y <= x@end

---FILE: README.md---
@@ -81,7 +81,7 @@ mean(x)
 # Create a new generic
 inside <- new_generic(""inside"", ""x"", function(x, y) {
   # Actually finds and calls the appropriate method
-  method_call()
+  R7_dispatch()
 })
 # Add a method for our class
 method(inside, Range) <- function(x, y) y >= x@start & y <= x@end

---FILE: man/method.Rd---
@@ -22,7 +22,7 @@ A function with class <R7_method>.
 \description{
 \code{method()} takes a generic and signature and retrieves the corresponding
 method. This is rarely needed because most of the time you'll rely on the
-the generic, via \code{\link[=method_call]{method_call()}}, to find and call the method for you.
+the generic, via \code{\link[=R7_dispatch]{R7_dispatch()}}, to find and call the method for you.
 However, this introspection is useful if you want to see the implementation
 of a specific method.
 }

---FILE: man/new_generic.Rd---
@@ -2,12 +2,12 @@
 % Please edit documentation in R/generic.R, R/method-dispatch.R
 \name{new_generic}
 \alias{new_generic}
-\alias{method_call}
+\alias{R7_dispatch}
 \title{Define a new generic}
 \usage{
 new_generic(name, dispatch_args, fun = NULL)
 
-method_call()
+R7_dispatch()
 }
 \arguments{
 \item{name}{The name of the generic. This should be the same as the object
@@ -17,7 +17,7 @@ that you assign it to.}
 arguments used to find the method.}
 
 \item{fun}{An optional specification of the generic, which must call
-\code{method_call()} to dispatch to methods. This is usually generated
+\code{R7_dispatch()} to dispatch to methods. This is usually generated
 automatically from the \code{dispatch_args}, but you may want to supply it if
 you want to add additional required arguments, omit \code{...}, or perform
 some standardised computation in the generic.
@@ -30,7 +30,7 @@ A generic function uses different implementations (\emph{methods}) depending on
 the class of one or more arguments (the \emph{signature}). Create a new generic
 with \code{new_generic()} then use \link{method<-} to add methods to it.
 
-Method dispatch is performed by \code{method_call()}, which must always be
+Method dispatch is performed by \code{R7_dispatch()}, which must always be
 included in the body of the generic, but in most cases \code{new_generic()} will
 generate this for you.
 }
@@ -60,7 +60,7 @@ type_of(mean)
 # If you want to require that methods implement additional arguments,
 # you can use a custom function:
 mean2 <- new_generic(""mean2"", ""x"", function(x, ..., na.rm = FALSE) {
-   method_call()
+   R7_dispatch()
 })
 
 method(mean2, ""numeric"") <- function(x, ..., na.rm = FALSE) {

---FILE: tests/testthat/_snaps/generic.md---
@@ -15,7 +15,7 @@
     Code
       new_generic(""foo"", ""x"", function(x) { })
     Error <simpleError>
-      `fun` must contain a call to `method_call()`
+      `fun` must contain a call to `R7_dispatch()`
 
 # check_dispatch_args() produces informative errors
 
@@ -81,5 +81,5 @@
     Code
       check_generic(function() { })
     Error <simpleError>
-      `fun` must contain a call to `method_call()`
+      `fun` must contain a call to `R7_dispatch()`
 

---FILE: tests/testthat/_snaps/method-register.md---
@@ -64,15 +64,15 @@
 ---
 
     Code
-      foo <- new_generic(""foo"", ""x"", function(x) method_call())
+      foo <- new_generic(""foo"", ""x"", function(x) R7_dispatch())
       check_method(function(x, y) { }, foo)
     Error <simpleError>
       foo() lacks `...` so method formals must match generic formals exactly
 
 # check_method warn if default arguments don't match
 
     Code
-      foo <- new_generic(""foo"", ""x"", function(x, ..., z = 2, y = 1) method_call())
+      foo <- new_generic(""foo"", ""x"", function(x, ..., z = 2, y = 1) R7_dispatch())
       check_method(function(x, ..., y = 1) { }, foo)
     Warning <simpleWarning>
       foo(???) doesn't have argument `z`

---FILE: tests/testthat/test-method-dispatch.R---
@@ -62,7 +62,7 @@ describe(""multiple dispatch"", {
 
 
 test_that(""can substitute() args"", {
-  foo <- new_generic(""foo"", ""x"", function(x, ..., z = 1) method_call())
+  foo <- new_generic(""foo"", ""x"", function(x, ..., z = 1) R7_dispatch())
   method(foo, ""character"") <- function(x, ..., z = 1) substitute(x)
   expect_equal(foo(letters), quote(letters))
 
@@ -79,7 +79,7 @@ test_that(""can substitute() args"", {
 test_that(""methods get values modified in the generic"", {
   foo <- new_generic(""foo"", ""x"", function(x, y = 1) {
     y <- 10
-    method_call()
+    R7_dispatch()
   })
   method(foo, ""character"") <- function(x, y = 1) y
   expect_equal(foo(""x"", 1), 10)
@@ -109,7 +109,7 @@ test_that(""generics pass ... to methods"", {
 })
 
 test_that(""generics pass extra args to methods"", {
-  foo <- new_generic(""foo"", ""x"", function(x, ..., z = 1) method_call())
+  foo <- new_generic(""foo"", ""x"", function(x, ..., z = 1) R7_dispatch())
   method(foo, ""character"") <- function(x, ..., z = 1) z
   expect_equal(foo(""x"", z = 3), 3)
 })

---FILE: tests/testthat/test-method-register.R---
@@ -111,12 +111,12 @@ describe(""as_signature()"", {
 })
 
 test_that(""check_method returns TRUE if the functions are compatible"", {
-  foo <- new_generic(""foo"", ""x"", function(x, ...) method_call())
+  foo <- new_generic(""foo"", ""x"", function(x, ...) R7_dispatch())
   expect_true(check_method(function(x, ...) x, foo))
   # extra arguments are ignored
   expect_true(check_method(function(x, ..., y) x, foo))
 
-  foo <- new_generic(""foo"", ""x"", function(x) method_call())
+  foo <- new_generic(""foo"", ""x"", function(x) R7_dispatch())
   expect_true(check_method(function(x) x, foo))
 })
 
@@ -130,14 +130,14 @@ test_that(""check_method complains if the functions are not compatible"", {
   })
 
   expect_snapshot(error = TRUE, {
-    foo <- new_generic(""foo"", ""x"", function(x) method_call())
+    foo <- new_generic(""foo"", ""x"", function(x) R7_dispatch())
     check_method(function(x, y) {}, foo)
   })
 })
 
 test_that(""check_method warn if default arguments don't match"", {
   expect_snapshot({
-    foo <- new_generic(""foo"", ""x"", function(x, ..., z = 2, y = 1) method_call())
+    foo <- new_generic(""foo"", ""x"", function(x, ..., z = 2, y = 1) R7_dispatch())
     check_method(function(x, ..., y = 1) {}, foo)
     check_method(function(x, ..., y = 1, z = 1) {}, foo)
   })"
RConsortium,S7,ad6516c3872a1daab4e7df6ac48b02b0ef741724,Hadley Wickham,h.wickham@gmail.com,2022-03-15T14:35:04Z,GitHub,noreply@github.com,2022-03-15T14:35:04Z,"Implement convert() and super() (#181)

Fixes #110. Fixes #136.",NAMESPACE;NEWS.md;R/class-spec.R;R/class.R;R/convert.R;R/method-dispatch.R;R/method-introspect.R;R/super.R;R/zzz.R;_pkgdown.yml;man/R7_data.Rd;man/convert.Rd;man/next_method.Rd;man/super.Rd;src/method-dispatch.c;tests/testthat/_snaps/convert.md;tests/testthat/_snaps/super.md;tests/testthat/test-class-spec.R;tests/testthat/test-convert.R;tests/testthat/test-method-dispatch.R;tests/testthat/test-super.R;vignettes/R7.Rmd,True,True,True,False,488,123,611,"---FILE: NAMESPACE---
@@ -13,6 +13,7 @@ S3method(print,R7_method)
 S3method(print,R7_missing)
 S3method(print,R7_object)
 S3method(print,R7_property)
+S3method(print,R7_super)
 S3method(print,R7_union)
 S3method(str,R7_S3_class)
 S3method(str,R7_any)
@@ -21,6 +22,7 @@ S3method(str,R7_class)
 S3method(str,R7_missing)
 S3method(str,R7_object)
 S3method(str,R7_property)
+S3method(str,R7_super)
 S3method(str,R7_union)
 export(""@"")
 export(""R7_data<-"")
@@ -32,6 +34,7 @@ export(R7_data)
 export(R7_object)
 export(any_class)
 export(as_class)
+export(convert)
 export(external_methods_register)
 export(method)
 export(method_call)
@@ -44,11 +47,11 @@ export(new_generic)
 export(new_object)
 export(new_property)
 export(new_union)
-export(next_method)
 export(prop)
 export(prop_exists)
 export(prop_names)
 export(props)
+export(super)
 export(valid_eventually)
 export(valid_implicitly)
 export(validate)

---FILE: NEWS.md---
@@ -2,6 +2,10 @@
 
 ## Mar 2022
 
+* `convert()` allows you to convert an object into another class (#136).
+
+* `super()` replaces `next_method()` (#110).
+
 ## Feb 2022
 
 * `any_class` and `missing_any` make it possible to dispatch on absent

---FILE: R/class-spec.R---
@@ -197,7 +197,10 @@ class_inherits <- function(x, what) {
     R7 = inherits(x, ""R7_object"") && inherits(x, R7_class_name(what)),
     R7_base = what$class == base_class(x),
     R7_union = any(vlapply(what$classes, class_inherits, x = x)),
-    R7_S3 = !isS4(x) && is_prefix(what$class, class(x)),
+    # This is slightly too crude as we really want them to be in the same
+    # order and contiguous, but it's probably close enough for practical
+    # purposees
+    R7_S3 = !isS4(x) && all(what$class %in% class(x)),
   )
 }
 

---FILE: R/class.R---
@@ -96,23 +96,19 @@ new_class <- function(
   check_name(name)
 
   parent <- as_class(parent)
-  if (!can_inherit(parent)) {
-     stop(
-       sprintf(
-         ""`parent` must be an R7 class, S3 class, or base type, not %s."", class_friendly(parent)),
-       call. = FALSE
-     )
-  }
-
-  if (!is.null(package)) {
-    check_name(package)
-  }
 
-  if (!is.null(constructor) && !is.null(parent)) {
-    check_R7_constructor(constructor)
-  }
-  if (!is.null(validator)) {
-    check_function(validator, alist(self = ))
+  # Don't check arguments for R7_object
+  if (!is.null(parent)) {
+    check_can_inherit(parent)
+    if (!is.null(package)) {
+      check_name(package)
+    }
+    if (!is.null(constructor)) {
+      check_R7_constructor(constructor)
+    }
+    if (!is.null(validator)) {
+      check_function(validator, alist(self = ))
+    }
   }
 
   # Combine properties from parent, overriding as needed
@@ -187,7 +183,18 @@ str.R7_class <- function(object, ..., nest.lev = 0) {
   }
 }
 
-can_inherit <- function(x) is_base_class(x) || is_S3_class(x) || is_class(x) || is.null(x)
+can_inherit <- function(x) is_base_class(x) || is_S3_class(x) || is_class(x)
+
+check_can_inherit <- function(x, arg = deparse(substitute(x))) {
+  if (!can_inherit(x)) {
+    msg <- sprintf(
+      ""`%s` must be an R7 class, S3 class, or base type, not %s."",
+      arg,
+      class_friendly(x)
+    )
+    stop(msg, call. = FALSE)
+  }
+}
 
 is_class <- function(x) inherits(x, ""R7_class"")
 

---FILE: R/convert.R---
@@ -0,0 +1,70 @@
+#' Convert an object from one type to another
+#'
+#' @description
+#' `convert()` uses double-dispatch, because conversion depends on both `from`
+#' and `to`. The dispatch is non-standard, because `to` is a class (not an
+#' object), and it does not take advantage of inheritance (because if you
+#' convert `x` to `superFoo` you shouldn't get an instance of `Foo` back).
+#'
+#' `convert()` provides built-in implementations if `from` inherits from `to`.
+#' This default strips any properties that `from` possesses that `to` does not,
+#' and resets the class.
+#'
+#' @param from An R7 object to convert.
+#' @param to An R7 class specification, passed to [as_class()].
+#' @param ... Other arguments passed to custom `convert()` methods.
+#' @export
+#' @examples
+#' foo1 <- new_class(""foo1"", properties = list(x = integer))
+#' foo2 <- new_class(""foo2"", foo1, properties = list(y = double))
+#'
+#' method(convert, list(foo1, integer)) <- function(from, to) from@x
+#' method(convert, list(foo2, double)) <- function(from, to) from@y
+#'
+#' convert(foo1(x = 1L), to = integer)
+#' try(convert(foo1(x = 1L), to = double))
+#'
+#' convert(foo2(x = 1L, y = 2), to = integer)
+#' convert(foo2(x = 1L, y = 2), to = double)
+#' convert(foo2(x = 1L, y = 2), to = foo1)
+#'
+#' # If we define a convert method for interger + foo1:
+#' method(convert, list(integer, foo1)) <- function(from, to) foo1(x = from)
+#' convert(1L, to = foo1)
+#' # Converting too foo2 still errors
+#' try(convert(1L, to = foo2))
+convert <- function(from, to, ...) {
+  to <- as_class(to)
+  check_can_inherit(to)
+
+  dispatch <- list(obj_dispatch(from), class_register(to))
+  convert <- .Call(method_, convert, dispatch, FALSE)
+
+  if (!is.null(convert)) {
+    convert(from, to, ...)
+  } else if (class_inherits(from, to)) {
+    from_class <- R7_class(from)
+    if (is.null(from_class)) {
+      from_props <- character()
+    } else {
+      from_props <- names(from_class@properties)
+    }
+
+    if (is_base_class(to)) {
+      from <- zap_attr(from, c(from_props, ""R7_class"", ""class""))
+    } else if (is_S3_class(to)) {
+      from <- zap_attr(from, c(from_props, ""R7_class""))
+      class(from) <- to$class
+    } else if (is_class(to)) {
+      from <- zap_attr(from, setdiff(from_props, names(to@properties)))
+      attr(from, ""R7_class"") <- to
+      class(from) <- setdiff(class_dispatch(to), ""ANY"")
+    } else {
+      stop(""Unreachable"")
+    }
+    from
+  } else {
+    method_lookup_error(""convert"", c(""from"", ""to""), dispatch)
+  }
+}
+# Converted to R7_generic on .onLoad

---FILE: R/method-dispatch.R---
@@ -16,27 +16,3 @@ method_lookup_error <- function(name, args, signatures) {
 method_call <- function() {
   .Call(method_call_, sys.call(-1), sys.function(-1), sys.frame(-1))
 }
-
-#' Retrieve the next applicable method after the current one
-#'
-#' @export
-#' @keywords internal
-next_method <- function() {
-  current_method <- sys.function(sys.parent(1))
-
-  # Travel up the call stack, finding all methods that have already been called
-  methods <- list()
-  i <- 1
-  while (!inherits(current_method, ""R7_generic"")) {
-    methods <- c(methods, current_method)
-    i <- i + 1
-    current_method <- sys.function(sys.parent(i))
-  }
-
-  generic <- current_method
-
-  # Find signature
-  vals <- mget(generic@dispatch_args, envir = parent.frame())
-  dispatch <- lapply(vals, obj_dispatch)
-  .Call(method_, generic, dispatch, ignore = methods)
-}

---FILE: R/method-introspect.R---
@@ -33,7 +33,7 @@
 #' method(bizarro, new_S3_class(""factor""))
 method <- function(generic, class = NULL, object = NULL) {
   dispatch <- as_dispatch(generic, class = class, object = object)
-  .Call(method_, generic, dispatch, NULL)
+  .Call(method_, generic, dispatch, TRUE)
 }
 
 #' Explain method dispatch

---FILE: R/super.R---
@@ -0,0 +1,90 @@
+#' Force method dispatch to use a superclass
+#'
+#' @description
+#' `super()` causes the dispatch for the next generic to use the method for
+#' the specified superclass. It is useful when you want to implement a method
+#' in terms of the implementation of its superclass.
+#'
+#' # Compared to S3 and S4
+#' `super()` performs a similar role to [NextMethod()] in S3 or
+#' [methods::callNextMethod()] in S4, but is much more explicit:
+#'
+#' * The class that `super()` will dispatch to is known at the time you
+#'   write `super()`, not only when it's called.
+#' * All arguments to the generic are explicit; they are not automatically
+#'   passed along.
+#'
+#' This makes `super()` more verbose, but substantially easier to
+#' understand and reason about.
+#'
+#' @param from An R7 object to cast.
+#' @param to An R7 class specification, passed to [as_class()]. Must be a
+#'   superclass of `object`.
+#' @returns An `R7_super` object which should always be passed
+#'   immediately to a generic. It has no other special behavior.
+#' @export
+#' @examples
+#' foo1 <- new_class(""foo1"", properties = list(x = ""numeric"", y = ""numeric""))
+#' foo2 <- new_class(""foo2"", foo1, properties = list(z = ""numeric""))
+#'
+#' total <- new_generic(""total"", ""x"")
+#' method(total, foo1) <- function(x) x@x + x@y
+#'
+#' # This doesn't work because it'll be stuck in an infinite loop:
+#' method(total, foo2) <- function(x) total(x) + x@z
+#'
+#' # So instead we use `super()` to call the method for the parent class:
+#' method(total, foo2) <- function(x) total(super(x, to = foo1)) + x@z
+#' total(foo2(1, 2, 3))
+#'
+#' # To see the difference between convert() and super() we need a
+#' # method that calls another generic
+#'
+#' bar1 <- new_generic(""bar1"", ""x"")
+#' method(bar1, foo1) <- function(x) 1
+#' method(bar1, foo2) <- function(x) 2
+#'
+#' bar2 <- new_generic(""bar2"", ""x"")
+#' method(bar2, foo1) <- function(x) c(1, bar1(x))
+#' method(bar2, foo2) <- function(x) c(2, bar1(x))
+#'
+#' obj <- foo2(1, 2, 3)
+#' bar2(obj)
+#' # convert() affects every generic:
+#' bar2(convert(obj, to = foo1))
+#' # super() only affects the _next_ generic:
+#' bar2(super(obj, to = foo1))
+super <- function(from, to) {
+  check_R7(from)
+
+  to <- as_class(to)
+  check_can_inherit(to)
+  if (!class_inherits(from, to)) {
+    msg <- sprintf(
+      ""%s doesn't inherit from %s"",
+      obj_desc(from),
+      class_desc(to)
+    )
+    stop(msg)
+  }
+
+  # Must not change order of these fields as C code indexes by position
+  structure(
+    list(
+      object = from,
+      dispatch = class_dispatch(to)
+    ),
+    class = ""R7_super""
+  )
+}
+
+#' @export
+print.R7_super <- function(x, ...) {
+  str(x, ...)
+  invisible(x)
+}
+#' @export
+str.R7_super <- function(object, ..., nest.lev = 0) {
+  cat(if (nest.lev > 0) "" "")
+  cat(""super("", obj_desc(object$object), "", <"", object$dispatch[[1]], "">)"", sep = """")
+}

---FILE: R/zzz.R---
@@ -78,6 +78,8 @@ methods::setOldClass(c(""R7_method"", ""function"", ""R7_object""))
 }
 
 .onLoad <- function(...) {
+  convert <<- R7_generic(convert, name = ""convert"", dispatch_args = c(""from"", ""to""))
+
   base_unions$numeric <<- new_union(""integer"", ""double"")
   base_unions$atomic <<- new_union(""logical"", ""integer"", ""double"", ""complex"", ""character"", ""raw"")
   base_unions$vector <<- new_union(""logical"", ""integer"", ""double"", ""complex"", ""character"", ""raw"", ""expression"", ""list"")

---FILE: _pkgdown.yml---
@@ -22,6 +22,8 @@ reference:
 
 - title: Method dispatch
   contents:
+  - convert
+  - super
   - as_class
   - method
   - method_explain

---FILE: man/convert.Rd---
@@ -0,0 +1,45 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/convert.R
+\name{convert}
+\alias{convert}
+\title{Convert an object from one type to another}
+\usage{
+convert(from, to, ...)
+}
+\arguments{
+\item{from}{An R7 object to convert.}
+
+\item{to}{An R7 class specification, passed to \code{\link[=as_class]{as_class()}}.}
+
+\item{...}{Other arguments passed to custom \code{convert()} methods.}
+}
+\description{
+\code{convert()} uses double-dispatch, because conversion depends on both \code{from}
+and \code{to}. The dispatch is non-standard, because \code{to} is a class (not an
+object), and it does not take advantage of inheritance (because if you
+convert \code{x} to \code{superFoo} you shouldn't get an instance of \code{Foo} back).
+
+\code{convert()} provides built-in implementations if \code{from} inherits from \code{to}.
+This default strips any properties that \code{from} possesses that \code{to} does not,
+and resets the class.
+}
+\examples{
+foo1 <- new_class(""foo1"", properties = list(x = integer))
+foo2 <- new_class(""foo2"", foo1, properties = list(y = double))
+
+method(convert, list(foo1, integer)) <- function(from, to) from@x
+method(convert, list(foo2, double)) <- function(from, to) from@y
+
+convert(foo1(x = 1L), to = integer)
+try(convert(foo1(x = 1L), to = double))
+
+convert(foo2(x = 1L, y = 2), to = integer)
+convert(foo2(x = 1L, y = 2), to = double)
+convert(foo2(x = 1L, y = 2), to = foo1)
+
+# If we define a convert method for interger + foo1:
+method(convert, list(integer, foo1)) <- function(from, to) foo1(x = from)
+convert(1L, to = foo1)
+# Converting too foo2 still errors
+try(convert(1L, to = foo2))
+}

---FILE: man/next_method.Rd---
@@ -1,12 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/method-dispatch.R
-\name{next_method}
-\alias{next_method}
-\title{Retrieve the next applicable method after the current one}
-\usage{
-next_method()
-}
-\description{
-Retrieve the next applicable method after the current one
-}
-\keyword{internal}

---FILE: man/super.Rd---
@@ -0,0 +1,69 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/super.R
+\name{super}
+\alias{super}
+\title{Force method dispatch to use a superclass}
+\usage{
+super(from, to)
+}
+\arguments{
+\item{from}{An R7 object to cast.}
+
+\item{to}{An R7 class specification, passed to \code{\link[=as_class]{as_class()}}. Must be a
+superclass of \code{object}.}
+}
+\value{
+An \code{R7_super} object which should always be passed
+immediately to a generic. It has no other special behavior.
+}
+\description{
+\code{super()} causes the dispatch for the next generic to use the method for
+the specified superclass. It is useful when you want to implement a method
+in terms of the implementation of its superclass.
+}
+\section{Compared to S3 and S4}{
+\code{super()} performs a similar role to \code{\link[=NextMethod]{NextMethod()}} in S3 or
+\code{\link[methods:NextMethod]{methods::callNextMethod()}} in S4, but is much more explicit:
+\itemize{
+\item The class that \code{super()} will dispatch to is known at the time you
+write \code{super()}, not only when it's called.
+\item All arguments to the generic are explicit; they are not automatically
+passed along.
+}
+
+This makes \code{super()} more verbose, but substantially easier to
+understand and reason about.
+}
+
+\examples{
+foo1 <- new_class(""foo1"", properties = list(x = ""numeric"", y = ""numeric""))
+foo2 <- new_class(""foo2"", foo1, properties = list(z = ""numeric""))
+
+total <- new_generic(""total"", ""x"")
+method(total, foo1) <- function(x) x@x + x@y
+
+# This doesn't work because it'll be stuck in an infinite loop:
+method(total, foo2) <- function(x) total(x) + x@z
+
+# So instead we use `super()` to call the method for the parent class:
+method(total, foo2) <- function(x) total(super(x, to = foo1)) + x@z
+total(foo2(1, 2, 3))
+
+# To see the difference between convert() and super() we need a
+# method that calls another generic
+
+bar1 <- new_generic(""bar1"", ""x"")
+method(bar1, foo1) <- function(x) 1
+method(bar1, foo2) <- function(x) 2
+
+bar2 <- new_generic(""bar2"", ""x"")
+method(bar2, foo1) <- function(x) c(1, bar1(x))
+method(bar2, foo2) <- function(x) c(2, bar1(x))
+
+obj <- foo2(1, 2, 3)
+bar2(obj)
+# convert() affects every generic:
+bar2(convert(obj, to = foo1))
+# super() only affects the _next_ generic:
+bar2(super(obj, to = foo1))
+}

---FILE: src/method-dispatch.c---
@@ -5,17 +5,8 @@
 extern SEXP parent_sym;
 extern SEXP name_sym;
 
-Rboolean should_ignore(SEXP value, SEXP ignore) {
-  for (R_xlen_t i = 0; i < Rf_xlength(ignore); ++i) {
-    if (R_compute_identical(value, VECTOR_ELT(ignore, i), 16) == TRUE) {
-      return TRUE;
-    }
-  }
-  return FALSE;
-}
-
 // Recursively walk through method table to perform iterated dispatch
-SEXP method_rec(SEXP table, SEXP signature, R_xlen_t signature_itr, SEXP ignore) {
+SEXP method_rec(SEXP table, SEXP signature, R_xlen_t signature_itr) {
   if (signature_itr >= Rf_xlength(signature)) {
     return R_NilValue;
   }
@@ -26,9 +17,9 @@ SEXP method_rec(SEXP table, SEXP signature, R_xlen_t signature_itr, SEXP ignore)
     SEXP klass = Rf_install(CHAR(STRING_ELT(classes, i)));
     SEXP val = Rf_findVarInFrame(table, klass);
     if (TYPEOF(val) == ENVSXP) {
-      val = method_rec(val, signature, signature_itr + 1, ignore);
+      val = method_rec(val, signature, signature_itr + 1);
     }
-    if (TYPEOF(val) == CLOSXP && (ignore == R_NilValue || !should_ignore(val, ignore))) {
+    if (TYPEOF(val) == CLOSXP) {
       return val;
     }
   }
@@ -51,7 +42,7 @@ void R7_method_lookup_error(SEXP generic, SEXP signature) {
   while(1);
 }
 
-SEXP method_(SEXP generic, SEXP signature, SEXP ignore) {
+SEXP method_(SEXP generic, SEXP signature, SEXP error_) {
   if (!Rf_inherits(generic, ""R7_generic"")) {
     return R_NilValue;
   }
@@ -61,8 +52,10 @@ SEXP method_(SEXP generic, SEXP signature, SEXP ignore) {
     Rf_error(""Corrupt R7_generic: @methods isn't an environment"");
   }
 
-  SEXP m = method_rec(table, signature, 0, ignore);
-  if (m == R_NilValue) {
+  SEXP m = method_rec(table, signature, 0);
+
+  int error = Rf_asInteger(error_);
+  if (error && m == R_NilValue) {
     R7_method_lookup_error(generic, signature);
   }
 
@@ -121,16 +114,26 @@ SEXP method_call_(SEXP call, SEXP generic, SEXP envir) {
     if (i < n_dispatch) {
       if (PRCODE(arg) != R_MissingArg) {
         // Evaluate the original promise so we can look up its class
-        SEXP val = Rf_eval(arg, R_EmptyEnv);
-        // And update the value of the promise to avoid evaluating it
-        // again in the method body
-        SET_PRVALUE(arg, val);
-
-        // Then add to arguments of method call
-        SETCDR(mcall_tail, Rf_cons(arg, R_NilValue));
-
-        // Determine class string to use for method look up
-        SET_VECTOR_ELT(dispatch_classes, i, R7_obj_dispatch(val));
+        SEXP val = PROTECT(Rf_eval(arg, R_EmptyEnv));
+
+        if (!Rf_inherits(val, ""R7_super"")) {
+          // Update the value of the promise to avoid evaluating it
+          // again in the method body
+          SET_PRVALUE(arg, val);
+
+          // Then add to arguments of method call
+          SETCDR(mcall_tail, Rf_cons(arg, R_NilValue));
+
+          // Determine class string to use for method look up
+          SET_VECTOR_ELT(dispatch_classes, i, R7_obj_dispatch(val));
+        } else {
+          // If it's a superclass, we get the stored value and dispatch class
+          SEXP true_val = VECTOR_ELT(val, 0);
+          SET_PRVALUE(arg, true_val);
+          SETCDR(mcall_tail, Rf_cons(arg, R_NilValue));
+          SET_VECTOR_ELT(dispatch_classes, i, VECTOR_ELT(val, 1));
+        }
+        UNPROTECT(1);
       } else {
         SETCDR(mcall_tail, Rf_cons(name, R_NilValue));
         SET_VECTOR_ELT(dispatch_classes, i, Rf_mkString(""MISSING""));
@@ -147,7 +150,7 @@ SEXP method_call_(SEXP call, SEXP generic, SEXP envir) {
   }
 
   // Now that we have all the classes, we can look up what method to call
-  SEXP m = method_(generic, dispatch_classes, R_NilValue);
+  SEXP m = method_(generic, dispatch_classes, Rf_ScalarLogical(1));
   SETCAR(mcall, m);
 
   // And then call it

---FILE: tests/testthat/_snaps/convert.md---
@@ -0,0 +1,9 @@
+# can register convert methods
+
+    Code
+      convert(obj, to = double)
+    Error <simpleError>
+      Can't find method for generic `convert()` with dispatch classes:
+      - from: converttest, R7_object, ANY
+      - to  : double
+

---FILE: tests/testthat/_snaps/super.md---
@@ -0,0 +1,21 @@
+# super(): checks to
+
+    Code
+      foo <- new_class(""foo"")
+      super(foo(), character)
+    Error <simpleError>
+      <foo> doesn't inherit from <character>
+
+# super(): displays nicely
+
+    Code
+      f1 <- super(foo2(), foo1)
+      f1
+    Output
+      super(<foo2>, <foo1>)
+    Code
+      str(list(f1))
+    Output
+      List of 1
+       $ : super(<foo2>, <foo1>)
+

---FILE: tests/testthat/test-class-spec.R---
@@ -165,6 +165,8 @@ test_that(""can work with R7 classes that extend S3 classes"", {
   expect_equal(obj_type(obj), ""R7"")
   expect_equal(obj_desc(obj), ""<Date2>"")
   expect_equal(obj_dispatch(obj), c(""Date2"", ""Date"", ""R7_object"", ""ANY""))
+  expect_equal(class_inherits(.Date(1), Date), TRUE)
+  expect_equal(class_inherits(obj, Date), TRUE)
   expect_equal(class_inherits(obj, Date2), TRUE)
 })
 

---FILE: tests/testthat/test-convert.R---
@@ -0,0 +1,58 @@
+test_that(""can register convert methods"", {
+  converttest <- new_class(""converttest"")
+  method(convert, list(converttest, character)) <- function(from, to, ...) ""c""
+  method(convert, list(converttest, integer)) <- function(from, to, ...) ""i""
+
+  obj <- converttest()
+  expect_equal(convert(obj, to = character), ""c"")
+  expect_equal(convert(obj, to = integer), ""i"")
+
+  # Errors if none found
+  expect_snapshot(convert(obj, to = double), error = TRUE)
+})
+
+test_that(""doesn't convert to subclass"", {
+  converttest1 <- new_class(""converttest1"")
+  converttest2 <- new_class(""converttest2"", converttest1)
+
+  method(convert, list(integer, converttest1)) <- function(from, to, ...) ""i""
+  expect_error(convert(integer, to = converttest2), ""Can't find method"")
+})
+
+describe(""fallback convert"", {
+  it(""can convert to own class"", {
+    foo1 <- new_class(""foo1"")
+    foo2 <- new_class(""foo2"", foo1)
+
+    obj <- convert(foo2(), to = foo2)
+    expect_equal(class(obj), c(""foo2"", ""foo1"", ""R7_object""))
+    expect_equal(R7_class(obj), foo2)
+  })
+
+  it(""can convert to super class"", {
+    foo1 <- new_class(""foo1"", properties = list(x = double))
+    foo2 <- new_class(""foo2"", foo1, properties = list(y = double))
+
+    obj <- convert(foo2(1, 2), to = foo1)
+    expect_equal(class(obj), c(""foo1"", ""R7_object""))
+    expect_equal(R7_class(obj), foo1)
+    expect_equal(props(obj), list(x = 1))
+    expect_equal(attr(obj, ""y""), NULL)
+  })
+
+  it(""can convert to S3 class"", {
+    factor2 <- new_class(""factor2"", S3_factor, properties = list(x = double))
+    obj <- convert(factor2(1, ""x"", x = 1), to = S3_factor)
+    expect_equal(class(obj), ""factor"")
+    expect_equal(R7_class(obj), NULL)
+    expect_equal(attr(obj, ""x""), NULL)
+  })
+
+  it(""can convert to base type"", {
+    character2 <- new_class(""character2"", ""character"", properties = list(x = double))
+    obj <- convert(character2(""x"", x = 1), to = character)
+    expect_equal(attr(obj, ""class""), NULL)
+    expect_equal(R7_class(obj), NULL)
+    expect_equal(attr(obj, ""x""), NULL)
+  })
+})

---FILE: tests/testthat/test-method-dispatch.R---
@@ -136,37 +136,3 @@ test_that(""method lookup fails with informative messages"", {
   expect_snapshot_error(foo(TRUE, list()))
   expect_snapshot_error(foo(tibble::tibble(), .POSIXct(double())))
 })
-
-test_that(""next_method works for single dispatch"", {
-  foo1 <- new_class(""foo1"")
-  foo2 <- new_class(""foo2"", foo1)
-
-  bar <- new_generic(""bar"", ""x"")
-  method(bar, foo1) <- function(x) 1
-  method(bar, foo2) <- function(x) next_method()(x)
-
-  expect_equal(bar(foo2()), 1)
-})
-
-test_that(""next_method works for double dispatch"", {
-  foo <- new_generic(""foo"", c(""x"", ""y""))
-  text <- new_class(""text"", character)
-  number <- new_class(""number"", double)
-
-  method(foo, list(text, number)) <- function(x, y, ...) {
-    R7_data(x) <- paste0(""foo-"", R7_data(x), ""-"", R7_data(y))
-    next_method()(x, y)
-  }
-
-  method(foo, list(character, number)) <- function(x, y, ...) {
-    R7_data(y) <- y + 1
-    R7_data(x) <- paste0(R7_data(x), ""-"", R7_data(y))
-    next_method()(x, y)
-  }
-
-  method(foo, list(character, double)) <- function(x, y, ...) {
-    as.character(R7_data(x))
-  }
-
-  expect_equal(foo(text(""hi""), number(1)), ""foo-hi-1-2"")
-})

---FILE: tests/testthat/test-super.R---
@@ -0,0 +1,50 @@
+
+describe(""super()"", {
+  it(""overrides dispatch, matching inherited behaviour"", {
+    foo1 <- new_class(""foo1"")
+    foo2 <- new_class(""foo2"", foo1)
+    foo3 <- new_class(""foo3"", foo2)
+
+    bar <- new_generic(""bar"", ""x"")
+    method(bar, foo1) <- function(x) 1
+    method(bar, foo3) <- function(x) 3
+
+    expect_equal(bar(super(foo3(), to = foo2)), 1)
+    expect_equal(bar(super(foo3(), to = foo1)), 1)
+  })
+
+  it(""only affects one dispatch"", {
+    foo1 <- new_class(""foo1"")
+    foo2 <- new_class(""foo2"", foo1)
+
+    bar1 <- new_generic(""bar1"", ""x"")
+    method(bar1, foo1) <- function(x) 1
+    method(bar1, foo2) <- function(x) 2
+
+    bar2 <- new_generic(""bar2"", ""x"")
+    method(bar2, foo1) <- function(x) c(1, bar1(x))
+    method(bar2, foo2) <- function(x) c(2, bar1(x))
+
+    expect_equal(bar2(super(foo2(), to = foo1)), c(1, 2))
+    expect_equal(bar2(convert(foo2(), to = foo1)), c(1, 1))
+  })
+
+  it(""checks to"", {
+    expect_snapshot(error = TRUE, {
+      foo <- new_class(""foo"")
+      super(foo(), character)
+    })
+  })
+
+  it(""displays nicely"", {
+    foo1 <- new_class(""foo1"")
+    foo2 <- new_class(""foo2"", foo1)
+
+    expect_snapshot({
+      f1 <- super(foo2(), foo1)
+      f1
+      str(list(f1))
+    })
+
+  })
+})

---FILE: vignettes/R7.Rmd---
@@ -100,19 +100,16 @@ method(bar, list(""character"", ""double"")) <- function(x, y) paste0(""foo-"", x, "":""
 bar(""hi"", 42)
 ```
 
-## Calling the next method
+## Calling the method for a parent class
 
-`next_method()` is used to call the next method for the arguments.
-This works by looking up the call stack and retrieving R7 methods which have already been called, then doing a method search with those methods excluded.
-This ensures you cannot call the same method twice.
+Sometimes you want to implement a method in terms of behavior already provided by its superclass.
+If you need to access a method for a superclass that your class is overriding, you can use `super()`:
 
 ```{r}
 method(bar, list(text, ""double"")) <- function(x, y, ...) {
-  res <- next_method()(x, y)
+  res <- bar(super(x), y)
   paste0(""2 "", res)
 }
-
-bar(text(""hi""), 42)
 ```
 
 ## Non-standard evaluation"
RConsortium,S7,568b7f48609c8816e4c506eb1206c8583dfbfcbd,Hadley Wickham,h.wickham@gmail.com,2022-03-14T17:29:12Z,Hadley Wickham,h.wickham@gmail.com,2022-03-14T17:29:12Z,Add minutes for this week; fix years,NEWS.md;vignettes/minutes/2021-05-18.Rmd;vignettes/minutes/2022-02-12.Rmd;vignettes/minutes/2022-03-08.Rmd,True,False,True,False,41,2,43,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # R7 0.0.0.9000
 
+## Mar 2022
+
 ## Feb 2022
 
 * `any_class` and `missing_any` make it possible to dispatch on absent

---FILE: vignettes/minutes/2021-05-18.Rmd---
@@ -1,5 +1,5 @@
 ---
-title: ""Minutes 2020-05-18""
+title: ""Minutes 2021-05-18""
 ---
 
 **Present**: Michael Lawrence (chair), Hong Ooi, Luke Tierney, Hadley Wickham, Will Landau, Henrik Bengtsson

---FILE: vignettes/minutes/2022-02-12.Rmd---
@@ -1,5 +1,5 @@
 ---
-title: ""Minutes 2021-02-12""
+title: ""Minutes 2022-02-12""
 ---
 
 ## Process check-in

---FILE: vignettes/minutes/2022-03-08.Rmd---
@@ -0,0 +1,37 @@
+---
+title: ""Minutes 2022-03-08""
+---
+
+## Changes
+
+-   Website updates (<https://rconsortium.github.io/OOP-WG/>): refreshed readme, minutes as articles.
+    Working on documentation overhaul in <https://github.com/RConsortium/OOP-WG/pull/187>.
+
+-   `new_generic()` now requires `dispatch_args`.
+    This means that `new_generic()` will typically be called without names:
+
+    -   `new_generic(""foo"", ""x"")`
+
+    -   `new_generic(""foo"", ""x"", function(x, y) call_method())`
+
+-   New `any_class` (could already define methods for `R7_object`) and `missing_class` sentinels.
+
+-   When creating an object, unspecified properties are initialized with their default value (#67).
+    To achieve this, the constructor arguments default to `missing_class`, since `NULL` would prevent a default value of `NULL`, and `missing()` requires too many gymnastics.
+
+    -   `new_class(""foo"", properties = list(x = integer, y = double))@constructor`
+
+    -   <https://github.com/RConsortium/OOP-WG/blob/main/R/class.R#L209-L212>
+
+-   See other minor changes in\
+    <https://github.com/RConsortium/OOP-WG/blob/main/NEWS.md#feb-2022>
+
+## Discussion
+
+-   Rename `method_call()`? <https://github.com/RConsortium/OOP-WG/issues/200> --- `R7_dispatch()` sounds good.
+-   Abstract classes? <https://github.com/RConsortium/OOP-WG/issues/199>. Easy to implement but is it worth it?
+-   What should we call the R7 equivalent of inherits? <https://github.com/RConsortium/OOP-WG/issues/193> --- call it `R7_inherits()` for now; will eventually just be part of inherits. Propose generic extension mechanism for inherits.
+-   Explicit S4 registration: <https://github.com/RConsortium/OOP-WG/pull/182>
+-   New names for base types? <https://github.com/RConsortium/OOP-WG/issues/170> --- `class_` sounds good.
+-   Convert and super: <https://github.com/RConsortium/OOP-WG/pull/181>
+-   Should we offer encapsulated OO? <https://github.com/RConsortium/OOP-WG/issues/202>"
RConsortium,S7,b3f18cd5e2adff9236032abfa4b75c811e0fbc6e,Hadley Wickham,h.wickham@gmail.com,2022-03-09T19:59:24Z,GitHub,noreply@github.com,2022-03-09T19:59:24Z,"Implement $ and $<- methods (#204)

Fixes #198",NAMESPACE;NEWS.md;R/zzz.R;tests/testthat/_snaps/zzz.md;tests/testthat/test-zzz.R,False,True,True,False,60,0,60,"---FILE: NAMESPACE---
@@ -1,5 +1,7 @@
 # Generated by roxygen2: do not edit by hand
 
+S3method(""$"",R7_object)
+S3method(""$<-"",R7_object)
 S3method(""@<-"",R7_object)
 S3method(print,R7_S3_class)
 S3method(print,R7_any)

---FILE: NEWS.md---
@@ -14,6 +14,9 @@
 * When creating an object, unspecified properties are initialized with their 
   default value (#67). DISCUSS: to achieve this, the constructor arguments
   default to `missing_class`.
+
+* Add `$.R7_object` and `$<-.R7_object` methods to avoid ""object of type 'S4'
+  is not subsettable"" error (#204).
   
 * Dispatch now disambiguates between S4 and S3/R7, and, optionally, between
   R7 classes in different packages (#48, #163).

---FILE: R/zzz.R---
@@ -16,6 +16,35 @@ R7_object <- new_class(
 )
 methods::setOldClass(""R7_object"")
 
+#' @export
+`$.R7_object` <- function(x, name) {
+  if (typeof(x) %in% c(""list"", ""environment"")) {
+    NextMethod()
+  } else {
+    msg <- sprintf(
+      ""Can't get R7 properties with `$`. Did you mean `%s@%s`?"",
+      deparse1(substitute(x)),
+      name
+    )
+    stop(msg, call. = FALSE)
+  }
+}
+#' @export
+`$<-.R7_object` <- function(x, name, value) {
+  if (typeof(x) %in% c(""list"", ""environment"")) {
+    NextMethod()
+  } else {
+    msg <- sprintf(
+      ""Can't set R7 properties with `$`. Did you mean `...@%s <- %s`?"",
+      name,
+      deparse1(substitute(value))
+    )
+    stop(msg, call. = FALSE)
+  }
+}
+
+
+
 check_R7 <- function(x, arg = deparse(substitute(x))) {
   if (!inherits(x, ""R7_object"")) {
     stop(sprintf(""`%s` is not an <R7_object>"", arg), call. = FALSE)

---FILE: tests/testthat/_snaps/zzz.md---
@@ -3,3 +3,14 @@
     <X> object is invalid:
     - Underlying data is corrupt
 
+# $ gives useful error
+
+    Code
+      x$y
+    Error <simpleError>
+      Can't get R7 properties with `$`. Did you mean `x@y`?
+    Code
+      x$y <- 1
+    Error <simpleError>
+      Can't set R7 properties with `$`. Did you mean `...@y <- 1`?
+

---FILE: tests/testthat/test-zzz.R---
@@ -3,6 +3,21 @@ test_that(""R7_class validates its underlying data"", {
   expect_snapshot_error(R7_data(x) <- 1)
 })
 
+test_that(""$ gives useful error"", {
+  foo <- new_class(""foo"")
+  x <- foo()
+  expect_snapshot(error = TRUE, {
+    x$y
+    x$y <- 1
+  })
+
+  # But works as expected if inheriting from list
+  foo <- new_class(""foo"", list)
+  x <- foo()
+  x$x <- 1
+  expect_equal(x$x, 1)
+})
+
 test_that(""register S4 classes for key components"", {
   expect_s4_class(getClass(""R7_object""), ""classRepresentation"")
   expect_s4_class(getClass(""R7_method""), ""classRepresentation"")"
RConsortium,S7,8c2bcb2aea5541a40fa24993d2e90c6bba62e52f,Hadley Wickham,h.wickham@gmail.com,2022-03-09T16:10:11Z,GitHub,noreply@github.com,2022-03-09T16:10:11Z,"Standardise base dispatch (#203)

* New base_class() helper is a thin wrapper around typeof()
* No longer uses numeric in dispatch
* No longer uses matrix or array in dispatch; this hasn't been thought through yet, so better to leave off for now.

Fixes #197",R/base.R;R/class-spec.R;tests/testthat/test-class-spec.R,False,True,True,False,35,7,42,"---FILE: R/base.R---
@@ -1,15 +1,16 @@
-new_base_class <- function(name, type = name) {
+new_base_class <- function(name) {
+  force(name)
+
   constructor <- function(.data = missing_class) {
     if (is_missing_class(.data)) {
       .data <- base_default(name)
     }
     .data
   }
 
-  force(type)
   validator <- function(object) {
-    if (!typeof(object) %in% type) {
-      sprintf(""Underlying data must be <%s> not <%s>"", paste0(type, collapse = ""/""), typeof(object))
+    if (base_class(object) != name) {
+      sprintf(""Underlying data must be <%s> not <%s>"", name, base_class(object))
     }
   }
 
@@ -63,6 +64,6 @@ base_classes <- list(
   list = new_base_class(""list""),
   expression = new_base_class(""expression""),
 
-  `function` = new_base_class(""function"", c(""closure"", ""special"", ""builtin"")),
+  `function` = new_base_class(""function""),
   environment = new_base_class(""environment"")
 )

---FILE: R/class-spec.R---
@@ -195,7 +195,7 @@ class_inherits <- function(x, what) {
     any = TRUE,
     S4 = isS4(x) && methods::is(x, what),
     R7 = inherits(x, ""R7_object"") && inherits(x, R7_class_name(what)),
-    R7_base = what$class %in% .class2(x),
+    R7_base = what$class == base_class(x),
     R7_union = any(vlapply(what$classes, class_inherits, x = x)),
     R7_S3 = !isS4(x) && is_prefix(what$class, class(x)),
   )
@@ -222,13 +222,23 @@ obj_desc <- function(x) {
 }
 obj_dispatch <- function(x) {
   switch(obj_type(x),
-    base = c(.class2(x), ""ANY""),
+    base = c(base_class(x), ""ANY""),
     S3 = c(class(x), ""ANY""),
     S4 = c(S4_class_dispatch(methods::getClass(class(x))), ""ANY""),
     R7 = c(class(x), ""ANY"") # = class_dispatch(R7_class(x))
   )
 }
 
+base_class <- function(x) {
+  switch(typeof(x),
+    closure = ""function"",
+    special = ""function"",
+    builtin = ""function"",
+    language = ""call"",
+    typeof(x)
+  )
+}
+
 # helpers -----------------------------------------------------------------
 
 # Suppress @className false positive

---FILE: tests/testthat/test-class-spec.R---
@@ -113,6 +113,23 @@ test_that(""can get class from base constructor"", {
   expect_snapshot_error(as_class(mean))
 })
 
+test_that(""dispatch for base objects use underlying type"", {
+  expect_equal(obj_dispatch(1), c(""double"", ""ANY""))
+  expect_equal(obj_dispatch(1L), c(""integer"", ""ANY""))
+
+  expect_equal(obj_dispatch(matrix(1)), c(""double"", ""ANY""))
+  expect_equal(obj_dispatch(matrix(1L)), c(""integer"", ""ANY""))
+
+  expect_equal(obj_dispatch(array(1)), c(""double"", ""ANY""))
+  expect_equal(obj_dispatch(array(1L)), c(""integer"", ""ANY""))
+
+  expect_equal(obj_dispatch(function() {}), c(""function"", ""ANY""))
+  expect_equal(obj_dispatch(sum), c(""function"", ""ANY""))
+  expect_equal(obj_dispatch(`[`), c(""function"", ""ANY""))
+
+  expect_equal(obj_dispatch(quote({})), c(""call"", ""ANY""))
+})
+
 # S3 ----------------------------------------------------------------------
 
 test_that(""can work with S3 classes"", {"
RConsortium,S7,edc9ee9e0668cf9b9dc91ea39fae8bb31b395c75,Hadley Wickham,h.wickham@gmail.com,2022-03-08T14:31:31Z,Hadley Wickham,h.wickham@gmail.com,2022-03-08T14:31:31Z,"Allow ... to come anywhere after dispatch_args

Fixes #201",R/generic.R;tests/testthat/_snaps/generic.md;tests/testthat/test-generic.R,False,True,True,False,0,9,9,"---FILE: R/generic.R---
@@ -102,10 +102,6 @@ check_dispatch_args <- function(dispatch_args, fun = NULL) {
     if (!is_prefix(dispatch_args, arg_names)) {
       stop(""`dispatch_args` must be a prefix of the generic arguments"", call. = FALSE)
     }
-
-    if (""..."" %in% arg_names && arg_names[[length(dispatch_args) + 1]] != ""..."") {
-      stop(""If present, ... must immediately follow the `dispatch_args`"", call. = FALSE)
-    }
   }
 
   dispatch_args

---FILE: tests/testthat/_snaps/generic.md---
@@ -43,10 +43,6 @@
       check_dispatch_args(""..."")
     Error <simpleError>
       Can't dispatch on `...`
-    Code
-      check_dispatch_args(""x"", function(x, y, ...) { })
-    Error <simpleError>
-      If present, ... must immediately follow the `dispatch_args`
     Code
       check_dispatch_args(""y"", function(x, ..., y) { })
     Error <simpleError>

---FILE: tests/testthat/test-generic.R---
@@ -20,7 +20,6 @@ test_that(""check_dispatch_args() produces informative errors"", {
     check_dispatch_args(NA_character_)
     check_dispatch_args(c(""x"", ""x""))
     check_dispatch_args(""..."")
-    check_dispatch_args(""x"", function(x, y, ...) {})
     check_dispatch_args(""y"", function(x, ..., y) {})
   })
 })"
RConsortium,S7,63007b9a4fbd6b24637430a473d495fef007fcfd,Hadley Wickham,h.wickham@gmail.com,2022-03-08T14:29:59Z,Hadley Wickham,h.wickham@gmail.com,2022-03-08T14:29:59Z,"Restore usage of check_generic()

And add a test to make sure all checks actually used in new_generic()

Fixes #189",R/generic.R;tests/testthat/_snaps/generic.md;tests/testthat/test-generic.R,False,True,True,False,12,0,12,"---FILE: R/generic.R---
@@ -72,6 +72,8 @@ new_generic <- function(name, dispatch_args, fun = NULL) {
     args <- c(dispatch_args, ""..."")
     args <- setNames(lapply(args, function(i) quote(expr = )), args)
     fun <- new_function(args, quote(method_call()), topenv(environment()))
+  } else {
+    check_generic(fun)
   }
 
   R7_generic(fun, name = name, dispatch_args = dispatch_args)

---FILE: tests/testthat/_snaps/generic.md---
@@ -8,6 +8,14 @@
       new_generic("""")
     Error <simpleError>
       `name` must not be """" or NA
+    Code
+      new_generic(""foo"", 1)
+    Error <simpleError>
+      `dispatch_args` must be a character vector
+    Code
+      new_generic(""foo"", ""x"", function(x) { })
+    Error <simpleError>
+      `fun` must contain a call to `method_call()`
 
 # check_dispatch_args() produces informative errors
 

---FILE: tests/testthat/test-generic.R---
@@ -2,6 +2,8 @@ test_that(""new_generic checks its inputs"", {
   expect_snapshot(error = TRUE, {
     new_generic(1)
     new_generic("""")
+    new_generic(""foo"", 1)
+    new_generic(""foo"", ""x"", function(x) {})
   })
 })
 "
RConsortium,S7,12b800c1e8337712856111f33fe5806dc6e29a7e,Hadley Wickham,h.wickham@gmail.com,2022-03-08T14:01:09Z,GitHub,noreply@github.com,2022-03-08T14:01:09Z,"Implement method_explain() (#195)

Fixes #194",NAMESPACE;NEWS.md;R/class-spec.R;R/method-introspect.R;_pkgdown.yml;man/method.Rd;man/method_explain.Rd;tests/testthat/_snaps/method-introspect.md;tests/testthat/test-method-introspect.R,False,True,True,False,155,10,165,"---FILE: NAMESPACE---
@@ -33,6 +33,7 @@ export(as_class)
 export(external_methods_register)
 export(method)
 export(method_call)
+export(method_explain)
 export(missing_class)
 export(new_S3_class)
 export(new_class)

---FILE: NEWS.md---
@@ -2,6 +2,8 @@
 
 ## Feb 2022
 
+* New `method_explain()` to explain dispatch (#194).
+
 * Minor property improvements: use same syntax for naming short-hand and
   full property specifications; input type automatically validated for 
   custom setters.

---FILE: R/class-spec.R---
@@ -141,7 +141,9 @@ class_desc <- function(x) {
 
 # Vector of class names; used in method introspection
 class_dispatch <- function(x) {
-  if (identical(x, R7_object)) return(c(""R7_object"", ""ANY""))
+  if (is_class(x) && x@name == ""R7_object"") {
+    return(c(""R7_object"", ""ANY""))
+  }
 
   switch(class_type(x),
     NULL = c(""NULL"", ""ANY""),

---FILE: R/method-introspect.R---
@@ -6,6 +6,7 @@
 #' However, this introspection is useful if you want to see the implementation
 #' of a specific method.
 #'
+#' @seealso [method_explain()] to explain why a specific method was picked.
 #' @inheritParams method<-
 #' @returns A function with class <R7_method>.
 #' @param class,object Perform introspection either with `classes`
@@ -31,30 +32,86 @@
 #' method(bizarro, object = 1)
 #' method(bizarro, new_S3_class(""factor""))
 method <- function(generic, class = NULL, object = NULL) {
+  dispatch <- as_dispatch(generic, class = class, object = object)
+  .Call(method_, generic, dispatch, NULL)
+}
+
+#' Explain method dispatch
+#'
+#' @description
+#' `method_explain()` shows all possible methods that a call to a generic
+#' might use, which ones exist, and which one will actually be called.
+#'
+#' Note that method dispatch uses a string representation of each class in
+#' the class hierarchy. Each class system uses a slightly different convention
+#' to avoid ambiguity.
+#'
+#' * R7: `pkg::class` or `class`
+#' * S4: `S4/pkg::class` or `S4/class`
+#' * S3: `class`
+#'
+#' @inheritParams method
+#' @export
+#' @examples
+#' foo1 <- new_class(""foo1"")
+#' foo2 <- new_class(""foo2"", foo1)
+#'
+#' add <- new_generic(""add"", c(""x"", ""y""))
+#' method(add, list(foo2, foo1)) <- function(x, y) c(2, 1)
+#' method(add, list(foo1, foo1)) <- function(x, y) c(1, 1)
+#'
+#' method_explain(add, list(foo2, foo2))
+method_explain <- function(generic, class = NULL, object = NULL) {
+  dispatch <- as_dispatch(generic, class = class, object = object)
+
+  grid <- as.matrix(rev(do.call(""expand.grid"", rev(dispatch))))
+  colnames(grid) <- generic@dispatch_args
+
+  names <- paste0(""["", grid, ""]"")
+  dim(names) <- dim(grid)
+  methods <- apply(names, 1, paste, collapse = "", "")
+
+  has_method <- function(dispatchs, env) {
+    for (x in dispatchs) {
+      env <- env[[x]]
+    }
+    is.function(env)
+  }
+  exists <- apply(grid, 1, has_method, env = generic@methods)
+
+  label <- ifelse(exists, ""* "", ""  "")
+  if (any(exists)) {
+    label[which(exists)[[1]]] <- ""->""
+  }
+
+  cat(paste0(label, "" "", generic@name, ""("", methods, "")\n""), sep = """")
+  invisible()
+}
+
+
+as_dispatch <- function(generic, class = NULL, object = NULL) {
   if (!inherits(generic, ""R7_generic"")) {
     stop(""`generic` must be an <R7_generic>"")
   }
-  if (!xor(is.null(class), is.null(object))) {
-    stop(""Must supply exactly one of `class` and `object`"")
-  }
 
-  if (!is.null(class)) {
+  if (!is.null(class) && is.null(object)) {
     signature <- as_signature(class, generic)
     is_union <- vlapply(signature, is_union)
     if (any(is_union)) {
       stop(""Can't dispatch on unions; must be a concrete type"")
     }
 
-    dispatch <- lapply(signature, class_dispatch)
-  } else {
+    lapply(signature, class_dispatch)
+  } else if (!is.null(object) && is.null(class)) {
     n <- generic_n_dispatch(generic)
     if (n == 1) {
       object <- list(object)
     } else {
       check_signature_list(object, n = n, arg = ""object"")
     }
-    dispatch <- lapply(object, obj_dispatch)
+    lapply(object, obj_dispatch)
+  } else {
+    stop(""Must supply exactly one of `class` and `object`"", call. = FALSE)
   }
-
-  .Call(method_, generic, dispatch, NULL)
 }
+

---FILE: _pkgdown.yml---
@@ -24,6 +24,7 @@ reference:
   contents:
   - as_class
   - method
+  - method_explain
   - new_external_generic
   - new_S3_class
   - missing_class

---FILE: man/method.Rd---
@@ -43,3 +43,6 @@ method(bizarro, class = ""integer"")
 method(bizarro, object = 1)
 method(bizarro, new_S3_class(""factor""))
 }
+\seealso{
+\code{\link[=method_explain]{method_explain()}} to explain why a specific method was picked.
+}

---FILE: man/method_explain.Rd---
@@ -0,0 +1,47 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/method-introspect.R
+\name{method_explain}
+\alias{method_explain}
+\title{Explain method dispatch}
+\usage{
+method_explain(generic, class = NULL, object = NULL)
+}
+\arguments{
+\item{generic}{A generic function, either created by \code{\link[=new_generic]{new_generic()}},
+\code{\link[=new_external_generic]{new_external_generic()}}, or an existing S3 generic.}
+
+\item{class}{Perform introspection either with \code{classes}
+(processed with \code{\link[=as_class]{as_class()}}) or a concrete objects.
+
+If \code{generic} does multiple dispatch both \code{object} and \code{class} need
+to be wrapped in a list.}
+
+\item{object}{Perform introspection either with \code{classes}
+(processed with \code{\link[=as_class]{as_class()}}) or a concrete objects.
+
+If \code{generic} does multiple dispatch both \code{object} and \code{class} need
+to be wrapped in a list.}
+}
+\description{
+\code{method_explain()} shows all possible methods that a call to a generic
+might use, which ones exist, and which one will actually be called.
+
+Note that method dispatch uses a string representation of each class in
+the class hierarchy. Each class system uses a slightly different convention
+to avoid ambiguity.
+\itemize{
+\item R7: \code{pkg::class} or \code{class}
+\item S4: \code{S4/pkg::class} or \code{S4/class}
+\item S3: \code{class}
+}
+}
+\examples{
+foo1 <- new_class(""foo1"")
+foo2 <- new_class(""foo2"", foo1)
+
+add <- new_generic(""add"", c(""x"", ""y""))
+method(add, list(foo2, foo1)) <- function(x, y) c(2, 1)
+method(add, list(foo1, foo1)) <- function(x, y) c(1, 1)
+
+method_explain(add, list(foo2, foo2))
+}

---FILE: tests/testthat/_snaps/method-introspect.md---
@@ -34,3 +34,22 @@
     Error <simpleError>
       Can't convert `signature` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base constructor function, not a <list>.
 
+# method explanation: shows all possible methods along with matches
+
+       add([foo2], [foo2])
+    -> add([foo2], [foo1])
+       add([foo2], [R7_object])
+       add([foo2], [ANY])
+       add([foo1], [foo2])
+    *  add([foo1], [foo1])
+       add([foo1], [R7_object])
+       add([foo1], [ANY])
+       add([R7_object], [foo2])
+       add([R7_object], [foo1])
+       add([R7_object], [R7_object])
+       add([R7_object], [ANY])
+       add([ANY], [foo2])
+       add([ANY], [foo1])
+       add([ANY], [R7_object])
+       add([ANY], [ANY])
+

---FILE: tests/testthat/test-method-introspect.R---
@@ -32,3 +32,16 @@ describe(""method introspection"", {
     })
   })
 })
+
+describe(""method explanation"", {
+  it(""shows all possible methods along with matches"", {
+    foo1 <- new_class(""foo1"")
+    foo2 <- new_class(""foo2"", foo1)
+
+    add <- new_generic(""add"", c(""x"", ""y""))
+    method(add, list(foo2, foo1)) <- function(x, y) c(2, 1)
+    method(add, list(foo1, foo1)) <- function(x, y) c(1, 1)
+
+    expect_snapshot_output(method_explain(add, list(foo2, foo2)))
+  })
+})"
RConsortium,S7,2e61fbc8ae668c6b8e911868dd20cf0ea8cf883f,Hadley Wickham,h.wickham@gmail.com,2022-02-24T16:25:28Z,Hadley Wickham,h.wickham@gmail.com,2022-02-24T16:25:28Z,"Properties with getter but no setter are read-only

Fixes #168",NEWS.md;R/property.R;man/new_property.Rd;tests/testthat/_snaps/property.md;tests/testthat/test-property.R,False,True,True,False,38,6,44,"---FILE: NEWS.md---
@@ -25,6 +25,8 @@
   `vignette(""R7"")`. Initial design docs and minutes are now articles so
   they appear on the website.
 
+* A property with a getter but no setter is read-only (#168).
+
 ## Jan 2022
 
 * New `props<-` for setting multiple properties simultaneously and validating

---FILE: R/property.R---
@@ -15,6 +15,8 @@
 #' @param getter An optional function used to get the value. The function
 #'   should take `self`  as its sole argument and return the value. If the
 #'   property has a `class` the class of the value is validated.
+#'
+#'   If a property has a getter but doesn't have a setter, it is read only.
 #' @param setter An optional function used to set the value. The function
 #'   should take `self` and `value` and return a modified object. The value is
 #'   _not_ automatically checked.
@@ -42,25 +44,28 @@
 #' my_clock <- clock()
 #' my_clock@now; Sys.sleep(1)
 #' my_clock@now
+#' # This property is read only
+#' try(my_clock@now <- 10)
 #'
 #' # These can be useful if you want to deprecate a property
 #' person <- new_class(""person"", properties = list(
 #'   first_name = ""character"",
 #'   new_property(
 #'      ""firstName"",
 #'      getter = function(self) {
-#'        warning(""@firstName is deprecated; please use @first_name instead"")
+#'        warning(""@firstName is deprecated; please use @first_name instead"", call. = FALSE)
 #'        self@first_name
 #'      },
 #'      setter = function(self, value) {
-#'        warning(""@firstName is deprecated; please use @first_name instead"")
+#'        warning(""@firstName is deprecated; please use @first_name instead"", call. = FALSE)
 #'        self@first_name <- value
 #'        self
 #'      }
 #'    )
 #' ))
 #' hadley <- person(first_name = ""Hadley"")
 #' hadley@firstName
+#' hadley@firstName <- ""John""
 #' hadley@first_name
 new_property <- function(name, class = any_class, getter = NULL, setter = NULL, default = NULL) {
   check_name(name)
@@ -185,7 +190,12 @@ prop_obj <- function(object, name) {
 
     prop <- prop_obj(object, name)
     if (is.null(prop)) {
-      stop(prop_error_unknown(object, name))
+      stop(prop_error_unknown(object, name), call. = FALSE)
+    }
+
+    if (!is.null(prop$getter) && is.null(prop$setter)) {
+      msg <- sprintf(""Can't set read-only property %s@%s"", obj_desc(object), name)
+      stop(msg, call. = FALSE)
     }
 
     if (!is.null(prop$setter) && !identical(setter_property, name)) {

---FILE: man/new_property.Rd---
@@ -20,7 +20,9 @@ new_property(
 
 \item{getter}{An optional function used to get the value. The function
 should take \code{self}  as its sole argument and return the value. If the
-property has a \code{class} the class of the value is validated.}
+property has a \code{class} the class of the value is validated.
+
+If a property has a getter but doesn't have a setter, it is read only.}
 
 \item{setter}{An optional function used to set the value. The function
 should take \code{self} and \code{value} and return a modified object. The value is
@@ -59,24 +61,27 @@ clock <- new_class(""clock"", properties = list(
 my_clock <- clock()
 my_clock@now; Sys.sleep(1)
 my_clock@now
+# This property is read only
+try(my_clock@now <- 10)
 
 # These can be useful if you want to deprecate a property
 person <- new_class(""person"", properties = list(
   first_name = ""character"",
   new_property(
      ""firstName"",
      getter = function(self) {
-       warning(""@firstName is deprecated; please use @first_name instead"")
+       warning(""@firstName is deprecated; please use @first_name instead"", call. = FALSE)
        self@first_name
      },
      setter = function(self, value) {
-       warning(""@firstName is deprecated; please use @first_name instead"")
+       warning(""@firstName is deprecated; please use @first_name instead"", call. = FALSE)
        self@first_name <- value
        self
      }
    )
 ))
 hadley <- person(first_name = ""Hadley"")
 hadley@firstName
+hadley@firstName <- ""John""
 hadley@first_name
 }

---FILE: tests/testthat/_snaps/property.md---
@@ -17,6 +17,13 @@
     Error <simpleError>
       trying to get slot ""blah"" from an object of a basic class (""NULL"") with no slots
 
+# prop setting: can't set read-only properties
+
+    Code
+      obj@x <- 1
+    Error <simpleError>
+      Can't set read-only property <foo>@x
+
 # prop setting: errors if the property doesn't exist or is wrong class
 
     Code

---FILE: tests/testthat/test-property.R---
@@ -49,6 +49,14 @@ describe(""prop setting"", {
     expect_equal(obj@x, 2)
   })
 
+  it(""can't set read-only properties"", {
+    foo <- new_class(""foo"", properties = list(
+      new_property(""x"", getter = function(self) 1
+    )))
+    obj <- foo()
+    expect_snapshot(obj@x <- 1, error = TRUE)
+  })
+
   it(""errors if the property doesn't exist or is wrong class"", {
     foo <- new_class(""foo"", properties = list(x = double))
     obj <- foo(123)"
RConsortium,S7,8ba54c71081877db2e2649a30a2a1b587b2b6bd1,Hadley Wickham,h.wickham@gmail.com,2022-02-22T20:28:44Z,GitHub,noreply@github.com,2022-02-22T20:28:44Z,"Disambiguate dispatch (#183)

THe minimal set of changes to disambiguate between:

* S4 vs R7/S3/base cases: `S4/foo` vs `foo`
* S4 classes with same name in different packages: `S4/pkgA::foo` vs `S4/pkgB::foo`
* R7 classes with same name in difference packages: `pkgA::foo` vs `pkgB::foo`

I used `::` as the separator because running `pkg::class` will typically get you the class.

Fixes #48. Fixes #163",NEWS.md;R/S4.R;R/class-spec.R;R/class.R;R/property.R;R/zzz.R;man/new_class.Rd;tests/testthat/_snaps/class.md;tests/testthat/test-S4.R;tests/testthat/test-class-spec.R;tests/testthat/test-class.R,False,True,True,False,204,79,283,"---FILE: NEWS.md---
@@ -2,6 +2,9 @@
 
 ## Feb 2022
 
+* Dispatch now disambiguates between S4 and S3/R7, and, optionally, between
+  R7 classes in different packages (#48, #163).
+
 * `new_generic()` now requires `dispatch_args` (180). This means that 
   `new_generic()` will typically be called without names. Either 
   `new_generic(""foo"", ""x"")` for a ""standard"" generic, or 

---FILE: R/S4.R---
@@ -33,11 +33,47 @@ S4_to_R7_class <- function(x, error_base = """") {
   }
 }
 
-# R7 handles unions at method registration time, where as S4 handles them at
-# dispatch time.
-S4_strip_union <- function(class_names) {
-  classes <- lapply(class_names, methods::getClass)
-  is_union <- vlapply(classes, methods::is, ""ClassUnionRepresentation"")
+S4_class_dispatch <- function(x) {
+  x <- methods::getClass(x)
+  self <- S4_class_name(x)
 
-  setdiff(class_names[!is_union], ""vector"")
+  # Find class objects for super classes
+  extends <- unname(methods::extends(x, fullInfo = TRUE))
+  extends <- Filter(function(x) methods::is(x, ""SClassExtension""), extends)
+  classes <- lapply(extends, function(x) methods::getClass(x@superClass))
+
+  # Remove virtual classes that aren't S3. This removes unions because R7
+  # handles them in method registration, not dispatch.
+  classes <- Filter(function(x) !x@virtual || is_oldClass(x), classes)
+
+  c(self, vcapply(classes, S4_class_name))
+}
+
+is_oldClass <- function(x) {
+  x@virtual && methods::extends(x, ""oldClass"") && x@className != ""oldClass""
 }
+
+S4_class_name <- function(x) {
+  if (is_oldClass(x)) {
+    return(x@className)
+  }
+
+  class <- x@className
+  package <- x@package %||% attr(class, ""package"")
+
+  if (identical(package, ""methods"") && class %in% names(base_classes)) {
+    class
+  } else if (is.null(package) || identical(package, "".GlobalEnv"")) {
+    paste0(""S4/"", class)
+  } else {
+    paste0(""S4/"", package, ""::"", class)
+  }
+}
+
+S4_remove_classes <- function(classes, where = globalenv()) {
+  for (class in classes) {
+    methods::removeClass(class, topenv(where))
+  }
+}
+
+globalVariables(c(""superClass"", ""virtual""))

---FILE: R/class-spec.R---
@@ -132,7 +132,7 @@ class_desc <- function(x) {
     missing = ""<MISSING>"",
     any = ""<ANY>"",
     S4 = paste0(""S4<"", x@className, "">""),
-    R7 = paste0(""<"", x@name, "">""),
+    R7 = paste0(""<"", R7_class_name(x), "">""),
     R7_base = paste0(""<"", x$class, "">""),
     R7_union = oxford_or(unlist(lapply(x$classes, class_desc))),
     R7_S3 = paste0(""S3<"", paste0(x$class, collapse = ""/""), "">""),
@@ -147,8 +147,8 @@ class_dispatch <- function(x) {
     NULL = c(""NULL"", ""ANY""),
     missing = ""MISSING"",
     any = ""ANY"",
-    S4 = c(S4_strip_union(methods::extends(x)), ""ANY""),
-    R7 = c(x@name, class_dispatch(x@parent)),
+    S4 = c(S4_class_dispatch(methods::extends(x)), ""ANY""),
+    R7 = c(R7_class_name(x), class_dispatch(x@parent)),
     R7_base = c(x$class, ""R7_object"", ""ANY""),
     R7_S3 = c(x$class, ""R7_object"", ""ANY""),
     stop(""Unsupported"")
@@ -161,8 +161,8 @@ class_register <- function(x) {
     NULL = ""NULL"",
     missing = ""MISSING"",
     any = ""ANY"",
-    S4 = as.character(x@className),
-    R7 = x@name,
+    S4 = S4_class_name(x),
+    R7 = R7_class_name(x),
     R7_base = x$class,
     R7_S3 = x$class[[1]],
     stop(""Unsupported"")
@@ -176,7 +176,7 @@ class_deparse <- function(x) {
     missing = ""missing_class"",
     any = ""any_class"",
     S4 = as.character(x@className),
-    R7 = x@name,
+    R7 = R7_class_name(x),
     R7_base = encodeString(x$class, quote = '""'),
     R7_union = {
       classes <- vcapply(x$classes, class_deparse)
@@ -192,7 +192,7 @@ class_inherits <- function(x, what) {
     missing = FALSE,
     any = TRUE,
     S4 = isS4(x) && methods::is(x, what),
-    R7 = inherits(x, ""R7_object"") && inherits(x, what@name),
+    R7 = inherits(x, ""R7_object"") && inherits(x, R7_class_name(what)),
     R7_base = what$class %in% .class2(x),
     R7_union = any(vlapply(what$classes, class_inherits, x = x)),
     R7_S3 = !isS4(x) && is_prefix(what$class, class(x)),
@@ -222,7 +222,7 @@ obj_dispatch <- function(x) {
   switch(obj_type(x),
     base = c(.class2(x), ""ANY""),
     S3 = c(class(x), ""ANY""),
-    S4 = c(S4_strip_union(methods::is(x)), ""ANY""),
+    S4 = c(S4_class_dispatch(methods::getClass(class(x))), ""ANY""),
     R7 = c(class(x), ""ANY"") # = class_dispatch(object_class(x))
   )
 }

---FILE: R/class.R---
@@ -11,7 +11,11 @@
 #'   * The R7 class, like [R7_object].
 #'   * An S3 class wrapped by [new_S3_class()].
 #'   * A base type, like `logical`, `double`, or `character`.
-#'
+#' @param package Package name. It is good practice to set the package
+#'   name when exporting an R7 class from a package because it includes
+#'   the package name in the class name when it's used for dispatch. This
+#'   allows different packages to use the same name to refer to different
+#'   classes.
 #' @param constructor The constructor function. Advanced use only.
 #'
 #'   A custom constructor should call `new_object()` to create the R7 object.
@@ -84,6 +88,7 @@
 new_class <- function(
     name,
     parent = R7_object,
+    package = NULL,
     properties = list(),
     constructor = NULL,
     validator = NULL) {
@@ -99,6 +104,10 @@ new_class <- function(
      )
   }
 
+  if (!is.null(package)) {
+    check_name(package)
+  }
+
   if (!is.null(constructor) && !is.null(parent)) {
     check_R7_constructor(constructor)
   }
@@ -119,6 +128,7 @@ new_class <- function(
   # Must synchronise with prop_names
   attr(object, ""name"") <- name
   attr(object, ""parent"") <- parent
+  attr(object, ""package"") <- package
   attr(object, ""properties"") <- all_props
   attr(object, ""constructor"") <- constructor
   attr(object, ""validator"") <- validator
@@ -127,6 +137,11 @@ new_class <- function(
   global_variables(names(all_props))
   object
 }
+globalVariables(c(""name"", ""parent"", ""package"", ""properties"", ""constructor"", ""validator""))
+
+R7_class_name <- function(x) {
+  paste(c(x@package, x@name), collapse = ""::"")
+}
 
 check_R7_constructor <- function(constructor) {
   if (!is.function(constructor)) {

---FILE: R/property.R---
@@ -90,12 +90,14 @@ new_property <- function(name, class = any_class, getter = NULL, setter = NULL,
   out
 }
 
-check_name <- function(name) {
+check_name <- function(name, arg = deparse(substitute(name))) {
   if (length(name) != 1 || !is.character(name)) {
-    stop(""`name` must be a single string"", call. = FALSE)
+    msg <- sprintf(""`%s` must be a single string"", arg)
+    stop(msg, call. = FALSE)
   }
   if (is.na(name) || name == """") {
-    stop(""`name` must not be \""\"" or NA"", call. = FALSE)
+    msg <- sprintf(""`%s` must not be \""\"" or NA"", arg)
+    stop(msg, call. = FALSE)
   }
 }
 
@@ -252,7 +254,7 @@ prop_names <- function(object) {
 
   if (inherits(object, ""R7_class"")) {
     # R7_class isn't a R7_class (somewhat obviously) so we fake the property names
-    c(""name"", ""parent"", ""properties"", ""constructor"", ""validator"")
+    c(""name"", ""parent"", ""package"", ""properties"", ""constructor"", ""validator"")
   } else {
     class <- object_class(object)
     props <- attr(class, ""properties"", exact = TRUE)

---FILE: R/zzz.R---
@@ -1,5 +1,3 @@
-global_variables(c(""name"", ""parent"", ""properties"", ""constructor"", ""validator""))
-
 #' Base R7 class
 #'
 #' @keywords internal

---FILE: man/new_class.Rd---
@@ -8,6 +8,7 @@
 new_class(
   name,
   parent = R7_object,
+  package = NULL,
   properties = list(),
   constructor = NULL,
   validator = NULL
@@ -26,6 +27,12 @@ There are four options:
 \item A base type, like \code{logical}, \code{double}, or \code{character}.
 }}
 
+\item{package}{Package name. It is good practice to set the package
+name when exporting an R7 class from a package because it includes
+the package name in the class name when it's used for dispatch. This
+allows different packages to use the same name to refer to different
+classes.}
+
 \item{properties}{A list specifying the properties (data) that
 every object of the class will possess. Each property can either be
 a named string (specifying the class), or a call to \code{\link[=new_property]{new_property()}},

---FILE: tests/testthat/_snaps/class.md---
@@ -15,6 +15,7 @@
       <foo2/foo1/R7_object> constructor
       @ name       :  chr ""foo2""
       @ parent     :  <foo1/R7_object> constructor
+      @ package    :  NULL
       @ properties : List of 2
        .. $ x: <R7_property> 
        ..  ..$ name   :  chr ""x""
@@ -46,6 +47,10 @@
       new_class(""foo"", 1)
     Error <simpleError>
       Can't convert `parent` to a valid class. Class specification must be an R7 class object, the result of `new_S3_class()`, an S4 class object, or a base constructor function, not a <double>.
+    Code
+      new_class(""foo"", package = 1)
+    Error <simpleError>
+      `package` must be a single string
     Code
       new_class(""foo"", constructor = 1)
     Error <simpleError>

---FILE: tests/testthat/test-S4.R---
@@ -1,5 +1,6 @@
 test_that(""can work with classGenerators"", {
-  Foo <- setClass(""Foo"")
+  on.exit(S4_remove_classes(""Foo""))
+  Foo <- setClass(""Foo"", where = globalenv())
   expect_equal(S4_to_R7_class(Foo), getClass(""Foo""))
 })
 
@@ -9,17 +10,19 @@ test_that(""converts S4 base classes to R7 base classes"", {
 })
 
 test_that(""converts S4 unions to R7 unions"", {
-  setClass(""Foo1"", slots = ""x"")
-  setClass(""Foo2"", slots = ""x"")
+  on.exit(S4_remove_classes(c(""Foo1"", ""Foo2"", ""Foo3"", ""Union1"", ""Union2"")))
 
-  setClassUnion(""Union1"", c(""Foo1"", ""Foo2""))
+  setClass(""Foo1"", slots = ""x"", where = globalenv())
+  setClass(""Foo2"", slots = ""x"", where = globalenv())
+
+  setClassUnion(""Union1"", c(""Foo1"", ""Foo2""), where = globalenv())
   expect_equal(
     S4_to_R7_class(getClass(""Union1"")),
     new_union(getClass(""Foo1""), getClass(""Foo2""))
   )
 
-  setClass(""Foo3"", slots = ""x"")
-  setClassUnion(""Union2"", c(""Union1"", ""Foo3""))
+  setClass(""Foo3"", slots = ""x"", where = globalenv())
+  setClassUnion(""Union2"", c(""Union1"", ""Foo3""), where = globalenv())
   expect_equal(
     S4_to_R7_class(getClass(""Union2"")),
     new_union(getClass(""Foo1""), getClass(""Foo2""), getClass(""Foo3""))
@@ -33,3 +36,75 @@ test_that(""converts S4 representation of S3 classes to R7 representation"", {
 test_that(""errors on non-S4 classes"", {
   expect_snapshot(S4_to_R7_class(1), error = TRUE)
 })
+
+
+describe(""S4_class_dispatch"", {
+  it(""returns name of base class"", {
+    on.exit(S4_remove_classes(""Foo1""))
+    setClass(""Foo1"", slots = list(""x"" = ""numeric""), where = globalenv())
+    expect_equal(S4_class_dispatch(""Foo1""), ""S4/Foo1"")
+  })
+
+  it(""respects single inheritance hierarchy"", {
+    on.exit(S4_remove_classes(c(""Foo1"", ""Foo2"",""Foo3"")))
+
+    setClass(""Foo1"", slots = list(""x"" = ""numeric""), where = globalenv())
+    setClass(""Foo2"", contains = ""Foo1"", where = globalenv())
+    setClass(""Foo3"", contains = ""Foo2"", where = globalenv())
+    expect_equal(S4_class_dispatch(""Foo3""), c(""S4/Foo3"", ""S4/Foo2"", ""S4/Foo1""))
+  })
+
+  it(""performs breadth first search for multiple dispatch"", {
+    on.exit(S4_remove_classes(c(""Foo1a"", ""Foo1b"",""Foo2a"", ""Foo2b"", ""Foo3"")))
+    setClass(""Foo1a"", slots = list(""x"" = ""numeric""), where = globalenv())
+    setClass(""Foo1b"", contains = ""Foo1a"", where = globalenv())
+    setClass(""Foo2a"", slots = list(""x"" = ""numeric""), where = globalenv())
+    setClass(""Foo2b"", contains = ""Foo2a"", where = globalenv())
+    setClass(""Foo3"", contains = c(""Foo1b"", ""Foo2b""), where = globalenv())
+    expect_equal(
+      S4_class_dispatch(""Foo3""),
+      c(""S4/Foo3"", ""S4/Foo1b"", ""S4/Foo2b"", ""S4/Foo1a"", ""S4/Foo2a"")
+    )
+  })
+
+  it(""handles extensions of base classes"", {
+    on.exit(S4_remove_classes(""Foo1""))
+    setClass(""Foo1"", contains = ""character"", where = globalenv())
+    expect_equal(S4_class_dispatch(""Foo1""), c(""S4/Foo1"", ""character""))
+  })
+
+  it(""handles extensions of S3 classes"", {
+    on.exit(S4_remove_classes(c(""Soo1"", ""Foo2"", ""Foo3"")))
+
+    setOldClass(c(""Soo1"", ""Soo""), where = globalenv())
+    setClass(""Foo2"", contains = ""Soo1"", where = globalenv())
+    setClass(""Foo3"", contains = ""Foo2"", where = globalenv())
+    expect_equal(S4_class_dispatch(""Foo3""), c(""S4/Foo3"", ""S4/Foo2"", ""Soo1"", ""Soo""))
+  })
+
+  it(""ignores unions"", {
+    on.exit(S4_remove_classes(c(""Foo1"", ""Foo2"", ""Foo3"")))
+
+    setClass(""Foo1"", slots = list(""x"" = ""numeric""), where = globalenv())
+    setClass(""Foo2"", slots = list(""x"" = ""numeric""), where = globalenv())
+    setClassUnion(""Foo3"", c(""Foo1"", ""Foo2""), where = globalenv())
+
+    expect_equal(S4_class_dispatch(""Foo1""), ""S4/Foo1"")
+    expect_equal(S4_class_dispatch(""Foo2""), ""S4/Foo2"")
+  })
+
+  it(""captures explicit package name"", {
+    on.exit(S4_remove_classes(""Foo1""))
+    setClass(""Foo1"", package = ""pkg"", where = globalenv())
+    expect_equal(S4_class_dispatch(""Foo1""), ""S4/pkg::Foo1"")
+  })
+
+  it(""captures implicit package name"", {
+    on.exit(S4_remove_classes(""Foo1"", env))
+
+    env <- new.env()
+    env$.packageName <- ""mypkg""
+    setClass(""Foo1"", where = env)
+    expect_equal(S4_class_dispatch(""Foo1""), ""S4/mypkg::Foo1"")
+  })
+})

---FILE: tests/testthat/test-class-spec.R---
@@ -16,6 +16,24 @@ test_that(""can work with R7 classes"", {
   expect_equal(class_inherits(obj, klass), TRUE)
 })
 
+test_that(""can work with R7 classes in packages"", {
+  klass <- new_class(""klass"", package = ""pkg"")
+  expect_equal(as_class(klass), klass)
+
+  expect_equal(class_type(klass), ""R7"")
+  expect_equal(class_dispatch(klass), c(""pkg::klass"", ""R7_object"", ""ANY""))
+  expect_equal(class_register(klass), ""pkg::klass"")
+  expect_equal(class_construct(klass), klass())
+  expect_equal(class_desc(klass), ""<pkg::klass>"")
+  expect_equal(class_deparse(klass), ""pkg::klass"")
+
+  obj <- klass()
+  expect_equal(obj_type(obj), ""R7"")
+  expect_equal(obj_desc(obj), ""<pkg::klass>"")
+  expect_equal(obj_dispatch(obj), c(""pkg::klass"", ""R7_object"", ""ANY""))
+  expect_equal(class_inherits(obj, klass), TRUE)
+})
+
 test_that(""can work with unions"", {
   text <- new_class(""text"", character)
   number <- new_class(""number"", double)
@@ -136,62 +154,26 @@ test_that(""can work with R7 classes that extend S3 classes"", {
 # S4 ----------------------------------------------------------------------
 
 test_that(""can work with S4 classes"", {
-  methods::setClass(""Range"", slots = c(start = ""numeric"", end = ""numeric""))
-  klass <- methods::getClass(""Range"")
-
-  expect_equal(class_type(klass), ""S4"")
-  expect_equal(class_dispatch(klass), c(""Range"", ""ANY""))
-  expect_equal(class_register(klass), ""Range"")
-  expect_s4_class(class_construct(klass, start = 1, end = 2), ""Range"")
-  expect_equal(class_desc(klass), ""S4<Range>"")
-  expect_equal(class_deparse(klass), ""Range"")
-
-  obj <- methods::new(klass, start = 1, end = 1)
-  expect_equal(obj_type(obj), ""S4"")
-  expect_equal(obj_desc(obj), ""S4<Range>"")
-  expect_equal(obj_dispatch(obj), c(""Range"", ""ANY""))
-  expect_equal(class_inherits(obj, klass), TRUE)
-})
-
-test_that(""can work with S4 subclasses"", {
-  methods::setClass(""Foo1"", slots = c(start = ""numeric"", end = ""numeric""))
-  methods::setClass(""Foo2"", contains = ""Foo1"")
-  klass <- methods::getClass(""Foo2"")
-
-  expect_equal(class_type(klass), ""S4"")
-  expect_equal(class_dispatch(klass), c(""Foo2"", ""Foo1"", ""ANY""))
-  expect_equal(class_register(klass), ""Foo2"")
-
-  obj <- methods::new(klass, start = 1, end = 1)
-  expect_equal(obj_dispatch(obj), c(""Foo2"", ""Foo1"", ""ANY""))
-  expect_equal(class_inherits(obj, klass), TRUE)
-})
+  on.exit(S4_remove_classes(c(""Foo1"", ""Foo2"", ""Foo3"", ""Foo4"")))
 
-test_that(""can work with S4 subclasses of base classes"", {
-  methods::setClass(""Foo3"", contains = ""character"")
-  klass <- methods::getClass(""Foo3"")
+  methods::setClass(""Foo1"", contains = ""character"", where = globalenv())
+  methods::setClass(""Foo2"", contains = ""Foo1"", where = globalenv())
+  methods::setClass(""Foo3"", slots = list(x = ""numeric""), where = globalenv())
+  methods::setClass(""Foo4"", contains = c(""Foo2"", ""Foo3""), where = globalenv())
 
-  expect_equal(class_type(klass), ""S4"")
-  expect_equal(class_dispatch(klass), c(""Foo3"", ""character"", ""ANY""))
-  expect_equal(class_register(klass), ""Foo3"")
-
-  obj <- methods::new(klass, ""x"")
-  expect_equal(obj_dispatch(obj), c(""Foo3"", ""character"", ""ANY""))
-  expect_equal(class_inherits(obj, klass), TRUE)
-})
-
-test_that(""can work with S4 multiple inheritance"", {
-  methods::setClass(""Foo4"", contains = ""character"")
-  methods::setClass(""Foo5"")
-  methods::setClass(""Foo6"", contains = c(""Foo4"", ""Foo5""))
-  klass <- methods::getClass(""Foo6"")
+  klass <- methods::getClass(""Foo4"")
 
   expect_equal(class_type(klass), ""S4"")
-  expect_equal(class_dispatch(klass), c(""Foo6"", ""Foo4"", ""Foo5"", ""character"", ""ANY""))
-  expect_equal(class_register(klass), ""Foo6"")
+  expect_equal(class_dispatch(klass), c(""S4/Foo4"", ""S4/Foo2"", ""S4/Foo3"", ""S4/Foo1"", ""character"", ""ANY""))
+  expect_equal(class_register(klass), ""S4/Foo4"")
+  expect_s4_class(class_construct(klass, 1, x = 2), ""Foo4"")
+  expect_equal(class_desc(klass), ""S4<Foo4>"")
+  expect_equal(class_deparse(klass), ""Foo4"")
 
-  obj <- methods::new(klass, ""x"")
-  expect_equal(obj_dispatch(obj), c(""Foo6"", ""Foo4"", ""Foo5"", ""character"", ""ANY""))
+  obj <- methods::new(klass, 1, x = 2)
+  expect_equal(obj_type(obj), ""S4"")
+  expect_equal(obj_desc(obj), ""S4<Foo4>"")
+  expect_equal(obj_dispatch(obj), class_dispatch(klass))
   expect_equal(class_inherits(obj, klass), TRUE)
 })
 

---FILE: tests/testthat/test-class.R---
@@ -1,6 +1,6 @@
 describe(""R7 classes"", {
   it(""possess expected properties"", {
-    foo <- new_class(""foo"", validator = function(self) NULL)
+    foo <- new_class(""foo"", package = ""R7"", validator = function(self) NULL)
 
     expect_equal(prop_names(foo), setdiff(names(attributes(foo)), ""class""))
     expect_type(foo@name, ""character"")
@@ -28,6 +28,8 @@ describe(""R7 classes"", {
       new_class(1)
       new_class(""foo"", 1)
 
+      new_class(""foo"", package = 1)
+
       new_class(""foo"", constructor = 1)
       new_class(""foo"", constructor = function() {})
 "
RConsortium,S7,4675283b713e63aabfd7b935673d629bf40ba336,Hadley Wickham,h.wickham@gmail.com,2022-02-21T22:57:08Z,Hadley Wickham,h.wickham@gmail.com,2022-02-21T22:57:08Z,"Correct order of class vector

And re-establish setOldClass() for R7 objects. Fixes #70.",R/class-spec.R;R/zzz.R;tests/testthat/test-S3.R;tests/testthat/test-class-spec.R;tests/testthat/test-zzz.R,False,True,True,False,17,7,24,"---FILE: R/class-spec.R---
@@ -149,8 +149,8 @@ class_dispatch <- function(x) {
     any = ""ANY"",
     S4 = c(S4_strip_union(methods::extends(x)), ""ANY""),
     R7 = c(x@name, class_dispatch(x@parent)),
-    R7_base = c(""R7_object"", x$class, ""ANY""),
-    R7_S3 = c(""R7_object"", x$class, ""ANY""),
+    R7_base = c(x$class, ""R7_object"", ""ANY""),
+    R7_S3 = c(x$class, ""R7_object"", ""ANY""),
     stop(""Unsupported"")
   )
 }

---FILE: R/zzz.R---
@@ -16,6 +16,8 @@ R7_object <- new_class(
     }
   }
 )
+methods::setOldClass(""R7_object"")
+
 check_R7 <- function(x, arg = deparse(substitute(x))) {
   if (!inherits(x, ""R7_object"")) {
     stop(sprintf(""`%s` is not an <R7_object>"", arg), call. = FALSE)
@@ -31,6 +33,7 @@ R7_generic <- new_class(
   ),
   parent = ""function""
 )
+methods::setOldClass(c(""R7_generic"", ""function"", ""R7_object""))
 is_generic <- function(x) inherits(x, ""R7_generic"")
 
 R7_method <- new_class(""R7_method"",
@@ -40,6 +43,7 @@ R7_method <- new_class(""R7_method"",
     signature = ""list""
   )
 )
+methods::setOldClass(c(""R7_method"", ""function"", ""R7_object""))
 
 .onAttach <- function(libname, pkgname) {
   env <- as.environment(paste0(""package:"", pkgname))

---FILE: tests/testthat/test-S3.R---
@@ -5,7 +5,7 @@ test_that(""new_S3_class has a print method"", {
 test_that(""can construct objects that extend S3 classes"", {
   ordered2 <- new_class(""ordered2"", parent = S3_factor)
   x <- ordered2(c(1L, 2L, 1L), letters[1:3])
-  expect_equal(class(x), c(""ordered2"", ""R7_object"", ""factor""))
+  expect_equal(class(x), c(""ordered2"", ""factor"", ""R7_object""))
   expect_equal(prop_names(x), character())
   expect_error(x@levels, ""Can't find property"")
 })

---FILE: tests/testthat/test-class-spec.R---
@@ -61,7 +61,7 @@ test_that(""can work with base types"", {
 
   klass <- as_class(""character"")
   expect_equal(class_type(klass), ""R7_base"")
-  expect_equal(class_dispatch(klass), c(""R7_object"", ""character"", ""ANY""))
+  expect_equal(class_dispatch(klass), c(""character"", ""R7_object"", ""ANY""))
   expect_equal(class_register(klass), ""character"")
   expect_equal(class_desc(klass), ""<character>"")
   expect_equal(class_construct(klass, ""x""), ""x"")
@@ -104,7 +104,7 @@ test_that(""can work with S3 classes"", {
   expect_equal(as_class(klass), klass)
 
   expect_equal(class_type(klass), ""R7_S3"")
-  expect_equal(class_dispatch(klass), c(""R7_object"", ""ordered"", ""factor"", ""ANY""))
+  expect_equal(class_dispatch(klass), c(""ordered"", ""factor"", ""R7_object"", ""ANY""))
   expect_equal(class_register(klass), ""ordered"")
   expect_equal(class_desc(klass), ""S3<ordered/factor>"")
   expect_equal(class_construct(klass), ordered(numeric()))
@@ -123,13 +123,13 @@ test_that(""can work with R7 classes that extend S3 classes"", {
   Date2 <- new_class(""Date2"", parent = Date, properties = list(x = ""numeric""))
 
   expect_equal(class_type(Date2), ""R7"")
-  expect_equal(class_dispatch(Date2), c(""Date2"", ""R7_object"", ""Date"", ""ANY""))
+  expect_equal(class_dispatch(Date2), c(""Date2"", ""Date"", ""R7_object"", ""ANY""))
   expect_equal(class_register(Date2), ""Date2"")
 
   obj <- Date2(x = 1)
   expect_equal(obj_type(obj), ""R7"")
   expect_equal(obj_desc(obj), ""<Date2>"")
-  expect_equal(obj_dispatch(obj), c(""Date2"", ""R7_object"", ""Date"", ""ANY""))
+  expect_equal(obj_dispatch(obj), c(""Date2"", ""Date"", ""R7_object"", ""ANY""))
   expect_equal(class_inherits(obj, Date2), TRUE)
 })
 

---FILE: tests/testthat/test-zzz.R---
@@ -2,3 +2,9 @@ test_that(""R7_class validates its underlying data"", {
   x <- new_class(""X"")()
   expect_snapshot_error(R7_data(x) <- 1)
 })
+
+test_that(""register S4 classes for key components"", {
+  expect_s4_class(getClass(""R7_object""), ""classRepresentation"")
+  expect_s4_class(getClass(""R7_method""), ""classRepresentation"")
+  expect_s4_class(getClass(""R7_generic""), ""classRepresentation"")
+})"
RConsortium,S7,a2a62024dbae5f287ead83e80aaec338a26678dc,Hadley Wickham,h.wickham@gmail.com,2022-02-21T13:11:25Z,GitHub,noreply@github.com,2022-02-21T13:11:25Z,"Add default values to properties (#178)

Fixes #139",NEWS.md;R/S3.R;R/base.R;R/class-spec.R;R/constructor.R;R/object.R;R/property.R;man/new_S3_class.Rd;man/new_class.Rd;man/new_property.Rd;tests/testthat/_snaps/class.md;tests/testthat/_snaps/constructor.md;tests/testthat/_snaps/property.md;tests/testthat/helper.R;tests/testthat/test-class.R;tests/testthat/test-external-generic.R;tests/testthat/test-object.R;tests/testthat/test-property.R;vignettes/case_studies.Rmd;vignettes/performance.Rmd,True,True,True,False,198,82,280,"---FILE: NEWS.md---
@@ -2,6 +2,10 @@
 
 ## Feb 2022
 
+* When creating a class, unspecified properties are initialized with their 
+  default value (#67). DISCUSS: to achieve this, the constructor arguments
+  default to `missing_class`.
+  
 * `any_class` and `missing_any` make it possible to dispatch on absent
   arguments and arguments of any class (#67).
 

---FILE: R/S3.R---
@@ -46,7 +46,7 @@
 #'
 #' ```R
 #' S3_Date <- new_S3_class(""Date"",
-#'   function(.data) {
+#'   function(.data = integer()) {
 #'     .Date(.data)
 #'   },
 #'   function(object) {
@@ -66,6 +66,10 @@
 #'   have an R7 class inherit from an S3 class. It must be specified in the
 #'   same way as a R7 constructor: the first argument should be `.data`
 #'   (the base type whose attributes will be modified).
+#'
+#'   All arguments to the constructor should have default values so that
+#'   when the constructor is called with no arguments, it returns returns
+#'   an ""empty"", but valid, object.
 #' @param validator An optional validator used by [validate()] to check that
 #'   the R7 object adheres to the constraints of the S3 class.
 #'
@@ -124,7 +128,7 @@ is_S3_class <- function(x) {
 # Define a few base examples
 
 S3_factor <- new_S3_class(""factor"",
-  function(.data, levels) {
+  function(.data = integer(), levels = character()) {
     structure(.data, levels = levels, class = ""factor"")
   },
   function(object) {
@@ -138,7 +142,7 @@ S3_factor <- new_S3_class(""factor"",
 )
 
 S3_POSIXct <- new_S3_class(""POSIXct"",
-  function(.data, tz = """") {
+  function(.data = double(), tz = """") {
     .POSIXct(.data, tz = tz)
   },
   function(object) {
@@ -152,7 +156,7 @@ S3_POSIXct <- new_S3_class(""POSIXct"",
 )
 
 S3_data.frame <- new_S3_class(""data.frame"",
-  function(.data, row.names = NULL) {
+  function(.data = list(), row.names = NULL) {
     if (is.null(row.names)) {
       list2DF(.data)
     } else {

---FILE: R/base.R---
@@ -1,7 +1,7 @@
-new_base_class <- function(name, default) {
-  constructor <- function(.data) {
-    if (missing(.data)) {
-      .data <- default
+new_base_class <- function(name) {
+  constructor <- function(.data = missing_class) {
+    if (is_missing_class(.data)) {
+      .data <- base_default(name)
     }
     .data
   }
@@ -23,6 +23,22 @@ new_base_class <- function(name, default) {
   )
 }
 
+base_default <- function(type) {
+  switch(type,
+    logical = logical(),
+    integer = integer(),
+    double = double(),
+    complex = complex(),
+    character = character(),
+    raw = raw(),
+    list = list(),
+    expression = expression(),
+
+    `function` = function() {},
+    environment = new.env(parent = emptyenv())
+)}
+
+
 is_base_class <- function(x) inherits(x, ""R7_base_class"")
 
 #' @export
@@ -38,17 +54,16 @@ str.R7_base_class <- function(object, ..., nest.lev = 0) {
 }
 
 base_classes <- list(
-  logical = new_base_class(""logical"", logical()),
-  integer = new_base_class(""integer"", integer()),
-  double = new_base_class(""double"", double()),
-  complex = new_base_class(""complex"", complex()),
-  character = new_base_class(""character"", character()),
-  raw = new_base_class(""raw"", raw()),
-
-  list = new_base_class(""list"", list()),
-  expression = new_base_class(""expression"", expression()),
-
-  `function` = new_base_class(""function"", function() {}),
-  # TODO: create a new environment in the constructor
-  environment = new_base_class(""environment"", new.env(parent = emptyenv()))
+  logical = new_base_class(""logical""),
+  integer = new_base_class(""integer""),
+  double = new_base_class(""double""),
+  complex = new_base_class(""complex""),
+  character = new_base_class(""character""),
+  raw = new_base_class(""raw""),
+
+  list = new_base_class(""list""),
+  expression = new_base_class(""expression""),
+
+  `function` = new_base_class(""function""),
+  environment = new_base_class(""environment"")
 )

---FILE: R/class-spec.R---
@@ -97,6 +97,7 @@ class_friendly <- function(x) {
 class_constructor <- function(.x, ...) {
   switch(class_type(.x),
     NULL = function() NULL,
+    any = function() NULL,
     S4 = function(...) methods::new(.x, ...),
     R7 = .x,
     R7_base = .x$constructor,

---FILE: R/constructor.R---
@@ -68,7 +68,7 @@ new_function <- function(args, body, env) {
   f
 }
 missing_args <- function(names) {
-  lapply(setNames(, names), function(i) quote(expr = ))
+  lapply(setNames(, names), function(i) quote(missing_class))
 }
 new_call <- function(call, args) {
   as.call(c(list(as.name(call)), args))

---FILE: R/object.R---
@@ -2,7 +2,7 @@
 #'   object.
 #' @rdname new_class
 #' @export
-new_object <- function(.data = NULL, ...) {
+new_object <- function(.data, ...) {
   obj_cls <- sys.function(-1)
   if (!inherits(obj_cls, ""R7_class"")) {
     stop(""`new_object()` must be called from within a constructor"")
@@ -29,6 +29,11 @@ new_object <- function(.data = NULL, ...) {
     )
   }
 
+  missing_props <- nms[vlapply(args, is_missing_class)]
+  for(prop in missing_props) {
+    args[[prop]] <- prop_default(obj_cls@properties[[prop]])
+  }
+
   if (!is.null(.data)) {
     object <- .data
   } else {

---FILE: R/property.R---
@@ -18,17 +18,23 @@
 #' @param setter An optional function used to set the value. The function
 #'   should take the object and new value as its two parameters and return the
 #'   modified object. The value is _not_ automatically checked.
+#' @param default When an object is created and the property is not supplied,
+#'   what should it default to? If `NULL`, defaults to the ""empty"" instance
+#'   of `class`.
 #' @export
 #' @examples
 #' # Simple properties store data inside an object
 #' pizza <- new_class(""pizza"", properties = list(
-#'   new_property(""slices"", ""numeric"")
+#'   new_property(""slices"", ""numeric"", default = 10)
 #' ))
 #' my_pizza <- pizza(slices = 6)
 #' my_pizza@slices
 #' my_pizza@slices <- 5
 #' my_pizza@slices
 #'
+#' your_pizza <- pizza()
+#' your_pizza@slices
+#'
 #' # Dynamic properties can compute on demand
 #' clock <- new_class(""clock"", properties = list(
 #'   new_property(""now"", getter = function(x) Sys.time())
@@ -55,11 +61,22 @@
 #' hadley <- person(first_name = ""Hadley"")
 #' hadley@firstName
 #' hadley@first_name
-new_property <- function(name, class = any_class, getter = NULL, setter = NULL) {
+new_property <- function(name, class = any_class, getter = NULL, setter = NULL, default = NULL) {
   check_name(name)
 
   class <- as_class(class)
-  out <- list(name = name, class = class, getter = getter, setter = setter)
+  if (!is.null(default) && !class_inherits(default, class)) {
+    msg <- sprintf(""`default` must be an instance of %s, not a %s"", class_desc(class), obj_desc(default))
+    stop(msg)
+  }
+
+  out <- list(
+    name = name,
+    class = class,
+    getter = getter,
+    setter = setter,
+    default = default
+  )
   class(out) <- ""R7_property""
 
   out
@@ -88,6 +105,10 @@ str.R7_property <- function(object, ..., nest.lev = 0) {
   print(object, ..., nest.lev = nest.lev)
 }
 
+prop_default <- function(prop) {
+  prop$default %||% class_construct(prop$class)
+}
+
 #' Get/set a property
 #'
 #' - `prop(x, ""name"")` / `prop@name` get the value of the a property,

---FILE: man/new_S3_class.Rd---
@@ -15,7 +15,11 @@ name.}
 objects of the specified class. This is only needed if you wish to
 have an R7 class inherit from an S3 class. It must be specified in the
 same way as a R7 constructor: the first argument should be \code{.data}
-(the base type whose attributes will be modified).}
+(the base type whose attributes will be modified).
+
+All arguments to the constructor should have default values so that
+when the constructor is called with no arguments, it returns returns
+an ""empty"", but valid, object.}
 
 \item{validator}{An optional validator used by \code{\link[=validate]{validate()}} to check that
 the R7 object adheres to the constraints of the S3 class.
@@ -66,7 +70,7 @@ the types of the attributes.
 The following code shows how you might wrap the base Date class.
 A Date is a numeric vector with class \code{Date} that can be constructed with
 \code{.Date()}.\if{html}{\out{<div class=""sourceCode R"">}}\preformatted{S3_Date <- new_S3_class(""Date"",
-  function(.data) \{
+  function(.data = integer()) \{
     .Date(.data)
   \},
   function(object) \{

---FILE: man/new_class.Rd---
@@ -13,7 +13,7 @@ new_class(
   validator = function(x) NULL
 )
 
-new_object(.data = NULL, ...)
+new_object(.data, ...)
 }
 \arguments{
 \item{name}{The name of the class, as a string.}

---FILE: man/new_property.Rd---
@@ -4,7 +4,13 @@
 \alias{new_property}
 \title{Define a new property}
 \usage{
-new_property(name, class = any_class, getter = NULL, setter = NULL)
+new_property(
+  name,
+  class = any_class,
+  getter = NULL,
+  setter = NULL,
+  default = NULL
+)
 }
 \arguments{
 \item{name}{Property name, primarily used for error messages.}
@@ -19,6 +25,10 @@ property has a \code{class} the class of the value is validated.}
 \item{setter}{An optional function used to set the value. The function
 should take the object and new value as its two parameters and return the
 modified object. The value is \emph{not} automatically checked.}
+
+\item{default}{When an object is created and the property is not supplied,
+what should it default to? If \code{NULL}, defaults to the ""empty"" instance
+of \code{class}.}
 }
 \description{
 A property defines a named component of an object. Properties are
@@ -32,13 +42,16 @@ behaviour when modified.
 \examples{
 # Simple properties store data inside an object
 pizza <- new_class(""pizza"", properties = list(
-  new_property(""slices"", ""numeric"")
+  new_property(""slices"", ""numeric"", default = 10)
 ))
 my_pizza <- pizza(slices = 6)
 my_pizza@slices
 my_pizza@slices <- 5
 my_pizza@slices
 
+your_pizza <- pizza()
+your_pizza@slices
+
 # Dynamic properties can compute on demand
 clock <- new_class(""clock"", properties = list(
   new_property(""now"", getter = function(x) Sys.time())

---FILE: tests/testthat/_snaps/class.md---
@@ -27,21 +27,24 @@
       @ parent     :  <R7_object> constructor
       @ properties : List of 3
        .. $ start : <R7_property> 
-       ..  ..$ name  :  chr ""start""
-       ..  ..$ class :  <R7_union>: <integer> or <double>
-       ..  ..$ getter:  NULL
-       ..  ..$ setter:  NULL
+       ..  ..$ name   :  chr ""start""
+       ..  ..$ class  :  <R7_union>: <integer> or <double>
+       ..  ..$ getter :  NULL
+       ..  ..$ setter :  NULL
+       ..  ..$ default:  NULL
        .. $ end   : <R7_property> 
-       ..  ..$ name  :  chr ""end""
-       ..  ..$ class :  <R7_union>: <integer> or <double>
-       ..  ..$ getter:  NULL
-       ..  ..$ setter:  NULL
+       ..  ..$ name   :  chr ""end""
+       ..  ..$ class  :  <R7_union>: <integer> or <double>
+       ..  ..$ getter :  NULL
+       ..  ..$ setter :  NULL
+       ..  ..$ default:  NULL
        .. $ length: <R7_property> 
-       ..  ..$ name  :  chr ""length""
-       ..  ..$ class :  <R7_union>: <integer> or <double>
-       ..  ..$ getter:  function (x)  
-       ..  ..$ setter:  function (x, value)  
-      @ constructor:  function (start, end)  
+       ..  ..$ name   :  chr ""length""
+       ..  ..$ class  :  <R7_union>: <integer> or <double>
+       ..  ..$ getter :  function (x)  
+       ..  ..$ setter :  function (x, value)  
+       ..  ..$ default:  NULL
+      @ constructor:  function (start = missing_class, end = missing_class)  
       @ validator  :  function (x)  
 
 # R7_class: str() summarises when nested

---FILE: tests/testthat/_snaps/constructor.md---
@@ -9,21 +9,21 @@
     Code
       new_constructor(R7_object, as_properties(list(x = ""numeric"", y = ""numeric"")))
     Output
-      function (x, y) 
+      function (x = missing_class, y = missing_class) 
       new_object(NULL, x = x, y = y)
       <environment: namespace:R7>
     Code
       foo <- new_class(""foo"", parent = ""character"")
       new_constructor(foo, list())
     Output
-      function (.data) 
+      function (.data = missing_class) 
       new_object(foo(.data = .data))
       <environment: 0x0>
     Code
       foo2 <- new_class(""foo2"", parent = foo)
       new_constructor(foo2, list())
     Output
-      function (.data) 
+      function (.data = missing_class) 
       new_object(foo2(.data = .data))
       <environment: 0x0>
 
@@ -32,13 +32,14 @@
     Code
       new_constructor(S3_factor, list())
     Output
-      function (.data, levels) 
+      function (.data = integer(), levels = character()) 
       new_object(new_factor(.data = .data, levels = levels))
       <environment: 0x0>
     Code
       new_constructor(S3_factor, as_properties(list(x = ""numeric"", y = ""numeric"")))
     Output
-      function (.data, levels, x, y) 
+      function (.data = integer(), levels = character(), x = missing_class, 
+          y = missing_class) 
       new_object(new_factor(.data = .data, levels = levels), x = x, 
           y = y)
       <environment: 0x0>

---FILE: tests/testthat/_snaps/property.md---
@@ -24,7 +24,7 @@
     Error <simpleError>
       trying to get slot ""blah"" from an object of a basic class (""NULL"") with no slots
 
-# new_property validates name
+# new_property(): validates name
 
     Code
       new_property(1)
@@ -35,25 +35,34 @@
     Error <simpleError>
       `name` must not be """" or NA
 
-# displays nicely
+# new_property(): validates default
+
+    Code
+      new_property(""foo"", class = ""integer"", default = ""x"")
+    Error <simpleError>
+      `default` must be an instance of <integer>, not a <character>
+
+# new_property(): displays nicely
 
     Code
       print(x)
     Output
       <R7_property> 
-      $ name  :  chr ""foo""
-      $ class :  <R7_base_class>: <integer>
-      $ getter:  NULL
-      $ setter:  NULL
+      $ name   :  chr ""foo""
+      $ class  :  <R7_base_class>: <integer>
+      $ getter :  NULL
+      $ setter :  NULL
+      $ default:  NULL
     Code
       str(list(x))
     Output
       List of 1
        $ : <R7_property> 
-        ..$ name  :  chr ""foo""
-        ..$ class :  <R7_base_class>: <integer>
-        ..$ getter:  NULL
-        ..$ setter:  NULL
+        ..$ name   :  chr ""foo""
+        ..$ class  :  <R7_base_class>: <integer>
+        ..$ getter :  NULL
+        ..$ setter :  NULL
+        ..$ default:  NULL
 
 # properties can be base, S3, S4, R7, or R7 union
 

---FILE: tests/testthat/helper.R---
@@ -1,10 +1,7 @@
-text <- new_class(""text"", parent = ""character"", constructor = function(text = character()) new_object(.data = text))
-number <- new_class(""number"", parent = ""double"", constructor = function(x) new_object(.data = x))
+text <- new_class(""text"", parent = ""character"")
+number <- new_class(""number"", parent = ""double"")
 
 range <- new_class(""range"",
-  constructor = function(start, end) {
-    new_object(start = start, end = end)
-  },
   validator = function(x) {
     if (x@end < x@start) {
       ""`end` must be greater than or equal to `start`""

---FILE: tests/testthat/test-class.R---
@@ -54,6 +54,32 @@ test_that(""classes can't inherit from S4 or class unions"", {
   })
 })
 
+describe(""default constructor"", {
+  it(""initializes properties with defaults"", {
+    foo1 <- new_class(""foo1"", properties = list(x = ""integer""))
+    obj <- foo1()
+    expect_equal(obj@x, integer())
+
+    foo2 <- new_class(""foo2"", foo1, properties = list(y = ""integer""))
+    obj <- foo2()
+    expect_equal(obj@x, integer())
+    expect_equal(obj@y, integer())
+  })
+
+  it(""initializes data with defaults"", {
+    text1 <- new_class(""text1"", parent = ""character"")
+    obj <- text1()
+    expect_equal(R7_data(obj), character())
+  })
+
+  it(""initializes property with R7 object"", {
+    foo1 <- new_class(""foo1"")
+    foo2 <- new_class(""foo2"", properties = list(x = foo1))
+    x <- foo2()
+    expect_s3_class(x@x, ""foo1"")
+  })
+})
+
 test_that(""default constructor works"", {
   foo1 <- new_class(""foo1"", properties = list(x = ""numeric""))
   foo2 <- new_class(""foo2"", parent = foo1, properties = list(y = ""numeric""))

---FILE: tests/testthat/test-external-generic.R---
@@ -26,7 +26,7 @@ test_that(""displays nicely"", {
 
 test_that(""new_method works with both hard and soft dependencies"", {
   skip_on_os(""windows"")
-  # skip_if(quick_test())
+  skip_if(quick_test())
 
   tmp_lib <- tempfile()
   dir.create(tmp_lib)

---FILE: tests/testthat/test-object.R---
@@ -41,6 +41,14 @@ describe(""new_object"", {
     })
   })
 
+  it(""can initialise a property to NULL"", {
+    foo <- new_class(""foo"", properties = list(
+      new_property(""x"", default = 10)
+    ))
+    x <- foo(x = NULL)
+    expect_equal(x@x, NULL)
+  })
+
   it(""combines properties for parent classes"", {
     foo1 <- new_class(""foo1"", properties = list(x = ""numeric""))
     foo2 <- new_class(""foo2"", foo1, properties = list(y = ""numeric""))

---FILE: tests/testthat/test-property.R---
@@ -154,18 +154,26 @@ test_that(""properties can be NULL"", {
   expect_equal(props(x), list(x = NULL))
 })
 
-test_that(""new_property validates name"", {
-  expect_snapshot(error = TRUE, {
-    new_property(1)
-    new_property("""")
+describe(""new_property()"", {
+  it(""validates name"", {
+    expect_snapshot(error = TRUE, {
+      new_property(1)
+      new_property("""")
+    })
   })
-})
 
-test_that(""displays nicely"", {
-  x <- new_property(""foo"", ""integer"")
-  expect_snapshot({
-    print(x)
-    str(list(x))
+  it(""validates default"", {
+    expect_snapshot(error = TRUE, {
+      new_property(""foo"", class = ""integer"", default = ""x"")
+    })
+  })
+
+  it(""displays nicely"", {
+    x <- new_property(""foo"", ""integer"")
+    expect_snapshot({
+      print(x)
+      str(list(x))
+    })
   })
 })
 

---FILE: vignettes/case_studies.Rmd---
@@ -32,7 +32,8 @@ Person <- new_class(""Person"",
       setter = function(object, value) {
         object@birthdate <- as.Date(value)
         object
-      }
+      },
+      default = as.Date(NA)
     ),
     new_property(
       name = ""age"",
@@ -48,10 +49,6 @@ Person <- new_class(""Person"",
     if (length(object@name) != length(object@birthdate)) {
       ""@name and @birthdate must be the same length""
     }
-  },
-  constructor = function(name, birthdate = NA) {
-    birthdate <- as.Date(birthdate)
-    new_object(name = name, birthdate = birthdate)
   }
 )
 

---FILE: vignettes/performance.Rmd---
@@ -21,8 +21,8 @@ library(R7)
 The dispatch performance should be roughly on par with S3 and S4, though as this is implemented in a package there is some overhead due to `.Call` vs `.Primitive`.
 
 ```{r performance, cache = FALSE}
-text <- new_class(""text"", parent = ""character"", constructor = function(text) new_object(.data = text))
-number <- new_class(""number"", parent = ""double"", constructor = function(x) new_object(.data = x))
+text <- new_class(""text"", parent = ""character"")
+number <- new_class(""number"", parent = ""double"")
 
 x <- text(""hi"")
 y <- number(1)"
RConsortium,S7,2fa61664324c350bef2671d5b913615f729dc085,Hadley Wickham,h.wickham@gmail.com,2022-02-17T23:52:09Z,GitHub,noreply@github.com,2022-02-17T23:52:09Z,"Implement missing_class and any_class (#177)

Fixes #67",NAMESPACE;NEWS.md;R/class-spec.R;R/class.R;R/method-dispatch.R;R/object.R;R/property.R;R/special.R;_pkgdown.yml;man/as_class.Rd;man/missing_class.Rd;man/new_property.Rd;tests/testthat/_snaps/method-register-dispatch.md;tests/testthat/_snaps/property.md;tests/testthat/_snaps/special.md;tests/testthat/test-class-spec.R;tests/testthat/test-method-register-dispatch.R;tests/testthat/test-property.R;tests/testthat/test-special.R,False,True,True,False,240,73,313,"---FILE: NAMESPACE---
@@ -2,17 +2,21 @@
 
 S3method(""@<-"",R7_object)
 S3method(print,R7_S3_class)
+S3method(print,R7_any)
 S3method(print,R7_base_class)
 S3method(print,R7_class)
 S3method(print,R7_external_generic)
 S3method(print,R7_generic)
 S3method(print,R7_method)
+S3method(print,R7_missing)
 S3method(print,R7_object)
 S3method(print,R7_property)
 S3method(print,R7_union)
 S3method(str,R7_S3_class)
+S3method(str,R7_any)
 S3method(str,R7_base_class)
 S3method(str,R7_class)
+S3method(str,R7_missing)
 S3method(str,R7_object)
 S3method(str,R7_property)
 S3method(str,R7_union)
@@ -23,10 +27,12 @@ export(""prop<-"")
 export(""props<-"")
 export(R7_data)
 export(R7_object)
+export(any_class)
 export(as_class)
 export(external_methods_register)
 export(method)
 export(method_call)
+export(missing_class)
 export(new_S3_class)
 export(new_class)
 export(new_external_generic)

---FILE: NEWS.md---
@@ -2,6 +2,9 @@
 
 ## Feb 2022
 
+* `any_class` and `missing_any` make it possible to dispatch on absent
+  arguments and arguments of any class (#67).
+
 * `new_external_generic()` now requires `dispatch_args` so we can eagerly 
   check the signature.
 

---FILE: R/class-spec.R---
@@ -13,6 +13,7 @@
 #'     `double` etc) or its name (`""logical""`, `""integer""`, ""`double`"" etc).
 #'   * A base union type specified by its name: `""numeric""`, `""atomic""`, or
 #'      `""vector""`.
+#'   * A ""special"", either [missing_class] or [any_class].
 #' @param arg Argument name used when generating errors.
 #' @export
 #' @return A standardised class: either `NULL`, an R7 class, an R7 union,
@@ -21,8 +22,10 @@ as_class <- function(x, arg = deparse(substitute(x))) {
   error_base <- sprintf(""Can't convert `%s` to a valid class. "", arg)
 
   if (is.null(x)) {
+    # NULL is handled specially because you can't assign a class to it,
+    # so it can't be wrapped in new_base_class
     x
-  } else if (is_class(x) || is_base_class(x) || is_S3_class(x) || is_union(x)) {
+  } else if (is_foundation_class(x)) {
     x
   } else if (isS4(x)) {
     S4_to_R7_class(x, error_base)
@@ -47,9 +50,22 @@ as_class <- function(x, arg = deparse(substitute(x))) {
   }
 }
 
+is_foundation_class <- function(x) {
+  is_class(x) ||
+    is_union(x) ||
+    is_base_class(x) ||
+    is_S3_class(x) ||
+    is_missing_class(x) ||
+    is_any_class(x)
+}
+
 class_type <- function(x) {
   if (is.null(x)) {
     ""NULL""
+  } else if (is_missing_class(x)) {
+    ""missing""
+  } else if (is_any_class(x)) {
+    ""any""
   } else if (is_base_class(x)) {
     ""R7_base""
   } else if (is_class(x)) {
@@ -68,6 +84,8 @@ class_type <- function(x) {
 class_friendly <- function(x) {
   switch(class_type(x),
     NULL = ""NULL"",
+    missing = ""a missing argument"",
+    any = ""any type"",
     S4 = ""an S4 class"",
     R7 = ""an R7 class"",
     R7_base = ""a base type"",
@@ -84,6 +102,7 @@ class_constructor <- function(.x, ...) {
     R7_base = .x$constructor,
     R7_union = class_constructor(.x$classes[[1]]),
     R7_S3 = .x$constructor,
+    stop(sprintf(""Can't construct %s"", class_friendly(.x)), call. = FALSE)
   )
 }
 class_construct <- function(.x, ...) {
@@ -92,12 +111,11 @@ class_construct <- function(.x, ...) {
 
 class_validate <- function(class, object) {
   validator <- switch(class_type(class),
-    NULL = NULL,
     S4 = methods::validObject,
     R7 = class@validator,
     R7_base = class$validator,
-    R7_union = NULL,
     R7_S3 = class$validator,
+    NULL
   )
 
   if (is.null(validator)) {
@@ -109,7 +127,9 @@ class_validate <- function(class, object) {
 
 class_desc <- function(x) {
   switch(class_type(x),
-    NULL = ""<ANY>"",
+    NULL = ""<NULL>"",
+    missing = ""<MISSING>"",
+    any = ""<ANY>"",
     S4 = paste0(""S4<"", x@className, "">""),
     R7 = paste0(""<"", x@name, "">""),
     R7_base = paste0(""<"", x$class, "">""),
@@ -120,12 +140,16 @@ class_desc <- function(x) {
 
 # Vector of class names; used in method introspection
 class_dispatch <- function(x) {
+  if (identical(x, R7_object)) return(c(""R7_object"", ""ANY""))
+
   switch(class_type(x),
-    NULL = NULL,
-    S4 = S4_strip_union(methods::extends(x)),
+    NULL = c(""NULL"", ""ANY""),
+    missing = ""MISSING"",
+    any = ""ANY"",
+    S4 = c(S4_strip_union(methods::extends(x)), ""ANY""),
     R7 = c(x@name, class_dispatch(x@parent)),
-    R7_base = c(""R7_object"", x$class),
-    R7_S3 = c(""R7_object"", x$class),
+    R7_base = c(""R7_object"", x$class, ""ANY""),
+    R7_S3 = c(""R7_object"", x$class, ""ANY""),
     stop(""Unsupported"")
   )
 }
@@ -134,6 +158,8 @@ class_dispatch <- function(x) {
 class_register <- function(x) {
   switch(class_type(x),
     NULL = ""NULL"",
+    missing = ""MISSING"",
+    any = ""ANY"",
     S4 = as.character(x@className),
     R7 = x@name,
     R7_base = x$class,
@@ -145,7 +171,9 @@ class_register <- function(x) {
 # Used when printing method signature to generate executable code
 class_deparse <- function(x) {
   switch(class_type(x),
-    NULL = """",
+    ""NULL"" = ""NULL"",
+    missing = ""missing_class"",
+    any = ""any_class"",
     S4 = as.character(x@className),
     R7 = x@name,
     R7_base = encodeString(x$class, quote = '""'),
@@ -159,7 +187,9 @@ class_deparse <- function(x) {
 
 class_inherits <- function(x, what) {
   switch(class_type(what),
-    NULL = TRUE,
+    ""NULL"" = is.null(x),
+    missing = FALSE,
+    any = TRUE,
     S4 = isS4(x) && methods::is(x, what),
     R7 = inherits(x, ""R7_object"") && inherits(x, what@name),
     R7_base = what$class %in% .class2(x),
@@ -169,9 +199,7 @@ class_inherits <- function(x, what) {
 }
 
 obj_type <- function(x) {
-  if (is.null(x)) {
-    ""NULL""
-  } else if (inherits(x, ""R7_object"")) {
+  if (inherits(x, ""R7_object"")) {
     ""R7""
   } else if (isS4(x)) {
     ""S4""
@@ -183,7 +211,6 @@ obj_type <- function(x) {
 }
 obj_desc <- function(x) {
   switch(obj_type(x),
-   NULL = ""NULL"",
    base = paste0(""<"", typeof(x), "">""),
    S3 = paste0(""S3<"", paste(class(x), collapse = ""/""), "">""),
    S4 = paste0(""S4<"", class(x), "">""),
@@ -192,11 +219,10 @@ obj_desc <- function(x) {
 }
 obj_dispatch <- function(x) {
   switch(obj_type(x),
-    NULL = ""NULL"",
-    base = .class2(x),
-    S3 = class(x),
-    S4 = S4_strip_union(methods::is(x)),
-    R7 = class(x) # = class_dispatch(object_class(x))
+    base = c(.class2(x), ""ANY""),
+    S3 = c(class(x), ""ANY""),
+    S4 = c(S4_strip_union(methods::is(x)), ""ANY""),
+    R7 = c(class(x), ""ANY"") # = class_dispatch(object_class(x))
   )
 }
 

---FILE: R/class.R---
@@ -149,7 +149,7 @@ print.R7_class <- function(x, ...) {
 #' @export
 str.R7_class <- function(object, ..., nest.lev = 0) {
   cat(if (nest.lev > 0) "" "")
-  cat(""<"", paste0(class_dispatch(object), collapse = ""/""), ""> constructor"", sep = """")
+  cat(""<"", paste0(setdiff(class_dispatch(object), ""ANY""), collapse = ""/""), ""> constructor"", sep = """")
   cat(""\n"")
 
   if (nest.lev == 0) {

---FILE: R/method-dispatch.R---
@@ -1,12 +1,13 @@
 # Called from C
 method_lookup_error <- function(name, args, signatures) {
-  args <- setdiff(args, ""..."")
-
-  fmt_classes <- function(classes, prefix = NULL) {
-    paste0(prefix, ""<"", classes, "">"", collapse = "", "")
-  }
-  types <- paste0(""- "", args, "": "", vcapply(signatures, fmt_classes), collapse = ""\n"")
-  stop(sprintf(""Can't find method for generic `%s()` with classes:\n%s"", name, types), call. = FALSE)
+  sigs <- vcapply(signatures, paste, collapse = "", "")
+  types <- paste0(""- "", format(args), "": "", sigs, collapse = ""\n"")
+  msg <- sprintf(
+    ""Can't find method for generic `%s()` with dispatch classes:\n%s"",
+    name,
+    types
+  )
+  stop(msg, call. = FALSE)
 }
 
 #' @rdname new_generic

---FILE: R/object.R---
@@ -36,7 +36,7 @@ new_object <- function(.data = NULL, ...) {
   }
 
   attr(object, ""object_class"") <- obj_cls
-  class(object) <- class_dispatch(obj_cls)
+  class(object) <- setdiff(class_dispatch(obj_cls), ""ANY"")
 
   for (nme in nms) {
     prop(object, nme, check = FALSE) <- args[[nme]]

---FILE: R/property.R---
@@ -55,7 +55,7 @@
 #' hadley <- person(first_name = ""Hadley"")
 #' hadley@firstName
 #' hadley@first_name
-new_property <- function(name, class = NULL, getter = NULL, setter = NULL) {
+new_property <- function(name, class = any_class, getter = NULL, setter = NULL) {
   check_name(name)
 
   class <- as_class(class)

---FILE: R/special.R---
@@ -0,0 +1,47 @@
+#' Special dispatch types
+#'
+#' * Use `missing_class` when the user has not supplied an argument
+#' * Use `any_class` for a default method that is called only if no other
+#'   methods are matched
+#'
+#' @export
+#' @examples
+#' foo <- new_generic(""foo"", ""x"")
+#' method(foo, integer) <- function(x) ""integer""
+#' method(foo, missing_class) <- function(x) ""missing""
+#' method(foo, any_class) <- function(x) ""fallback""
+#'
+#' foo(1)
+#' foo()
+#' foo(""x"")
+missing_class <- structure(list(), class = ""R7_missing"")
+
+is_missing_class <- function(x) inherits(x, ""R7_missing"")
+
+#' @export
+print.R7_missing <- function(x, ...) {
+  cat(""<R7_missing>\n"")
+  invisible(x)
+}
+#' @export
+str.R7_missing <- function(object, ..., nest.lev = 0) {
+  cat(if (nest.lev > 0) "" "")
+  print(object)
+}
+
+#' @export
+#' @rdname missing_class
+any_class <- structure(list(), class = ""R7_any"")
+
+is_any_class <- function(x) inherits(x, ""R7_any"")
+
+#' @export
+print.R7_any <- function(x, ...) {
+  cat(""<R7_any>\n"")
+  invisible(x)
+}
+#' @export
+str.R7_any <- function(object, ..., nest.lev = 0) {
+  cat(if (nest.lev > 0) "" "")
+  print(object)
+}

---FILE: _pkgdown.yml---
@@ -19,16 +19,14 @@ reference:
   - prop_names
   - props
 
-- title: Extensions
+- title: Method dispatch
   contents:
+  - as_class
+  - method
   - new_external_generic
   - new_S3_class
-
-- title: Introspection
-  contents:
-  - as_class
+  - missing_class
   - object_class
-  - method
 
 articles:
 - title: Learn R7

---FILE: man/as_class.Rd---
@@ -17,6 +17,7 @@ as_class(x, arg = deparse(substitute(x)))
 \code{double} etc) or its name (\code{""logical""}, \code{""integer""}, ""\code{double}"" etc).
 \item A base union type specified by its name: \code{""numeric""}, \code{""atomic""}, or
 \code{""vector""}.
+\item A ""special"", either \link{missing_class} or \link{any_class}.
 }}
 
 \item{arg}{Argument name used when generating errors.}

---FILE: man/missing_class.Rd---
@@ -0,0 +1,35 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/special.R
+\docType{data}
+\name{missing_class}
+\alias{missing_class}
+\alias{any_class}
+\title{Special dispatch types}
+\format{
+An object of class \code{R7_missing} of length 0.
+
+An object of class \code{R7_any} of length 0.
+}
+\usage{
+missing_class
+
+any_class
+}
+\description{
+\itemize{
+\item Use \code{missing_class} when the user has not supplied an argument
+\item Use \code{any_class} for a default method that is called only if no other
+methods are matched
+}
+}
+\examples{
+foo <- new_generic(""foo"", ""x"")
+method(foo, integer) <- function(x) ""integer""
+method(foo, missing_class) <- function(x) ""missing""
+method(foo, any_class) <- function(x) ""fallback""
+
+foo(1)
+foo()
+foo(""x"")
+}
+\keyword{datasets}

---FILE: man/new_property.Rd---
@@ -4,7 +4,7 @@
 \alias{new_property}
 \title{Define a new property}
 \usage{
-new_property(name, class = NULL, getter = NULL, setter = NULL)
+new_property(name, class = any_class, getter = NULL, setter = NULL)
 }
 \arguments{
 \item{name}{Property name, primarily used for error messages.}

---FILE: tests/testthat/_snaps/method-register-dispatch.md---
@@ -4,19 +4,19 @@
 
 # method lookup fails with informative messages
 
-    Can't find method for generic `foo()` with classes:
-    - x: <logical>
-    - y: <MISSING>
+    Can't find method for generic `foo()` with dispatch classes:
+    - x: logical, ANY
+    - y: MISSING
 
 ---
 
-    Can't find method for generic `foo()` with classes:
-    - x: <logical>
-    - y: <list>
+    Can't find method for generic `foo()` with dispatch classes:
+    - x: logical, ANY
+    - y: list, ANY
 
 ---
 
-    Can't find method for generic `foo()` with classes:
-    - x: <tbl_df>, <tbl>, <data.frame>
-    - y: <POSIXct>, <POSIXt>
+    Can't find method for generic `foo()` with dispatch classes:
+    - x: tbl_df, tbl, data.frame, ANY
+    - y: POSIXct, POSIXt, ANY
 

---FILE: tests/testthat/_snaps/property.md---
@@ -65,6 +65,7 @@
       @ parent: <R7_object>
       @ properties:
        $ anything: <ANY>                 
+       $ null    : <NULL>                
        $ base    : <integer>             
        $ S3      : S3<factor>            
        $ S4      : S4<class_S4>          
@@ -73,6 +74,10 @@
 
 ---
 
+    Code
+      my_obj@null <- ""x""
+    Error <simpleError>
+      <my_class>@null must be <NULL>, not <character>
     Code
       my_obj@base <- ""x""
     Error <simpleError>

---FILE: tests/testthat/_snaps/special.md---
@@ -0,0 +1,17 @@
+# can test and print
+
+    Code
+      print(missing_class)
+    Output
+      <R7_missing>
+    Code
+      print(any_class)
+    Output
+      <R7_any>
+    Code
+      str(list(m = missing_class, a = any_class))
+    Output
+      List of 2
+       $ m: <R7_missing>
+       $ a: <R7_any>
+

---FILE: tests/testthat/test-class-spec.R---
@@ -3,7 +3,7 @@ test_that(""can work with R7 classes"", {
   expect_equal(as_class(klass), klass)
 
   expect_equal(class_type(klass), ""R7"")
-  expect_equal(class_dispatch(klass), c(""klass"", ""R7_object""))
+  expect_equal(class_dispatch(klass), c(""klass"", ""R7_object"", ""ANY""))
   expect_equal(class_register(klass), ""klass"")
   expect_equal(class_construct(klass), klass())
   expect_equal(class_desc(klass), ""<klass>"")
@@ -12,7 +12,7 @@ test_that(""can work with R7 classes"", {
   obj <- klass()
   expect_equal(obj_type(obj), ""R7"")
   expect_equal(obj_desc(obj), ""<klass>"")
-  expect_equal(obj_dispatch(obj), c(""klass"", ""R7_object""))
+  expect_equal(obj_dispatch(obj), c(""klass"", ""R7_object"", ""ANY""))
   expect_equal(class_inherits(obj, klass), TRUE)
 })
 
@@ -37,16 +37,17 @@ test_that(""handles NULL"", {
   expect_equal(as_class(NULL), NULL)
 
   expect_equal(class_type(NULL), ""NULL"")
-  expect_equal(class_dispatch(NULL), NULL)
+  expect_equal(class_dispatch(NULL), c(""NULL"", ""ANY""))
   expect_equal(class_register(NULL), ""NULL"")
   expect_equal(class_construct(NULL), NULL)
-  expect_equal(class_desc(NULL), ""<ANY>"")
-  expect_equal(class_deparse(NULL), """")
-
-  expect_equal(obj_type(NULL), ""NULL"")
-  expect_equal(obj_desc(NULL), ""NULL"")
-  expect_equal(obj_dispatch(NULL), ""NULL"")
-  expect_equal(class_inherits(""x"", NULL), TRUE)
+  expect_equal(class_desc(NULL), ""<NULL>"")
+  expect_equal(class_deparse(NULL), ""NULL"")
+
+  expect_equal(obj_type(NULL), ""base"")
+  expect_equal(obj_desc(NULL), ""<NULL>"")
+  expect_equal(obj_dispatch(NULL), c(""NULL"", ""ANY""))
+  expect_equal(class_inherits(""x"", NULL), FALSE)
+  expect_equal(class_inherits(NULL, NULL), TRUE)
 })
 
 # base --------------------------------------------------------------------
@@ -58,7 +59,7 @@ test_that(""can work with base types"", {
 
   klass <- as_class(""character"")
   expect_equal(class_type(klass), ""R7_base"")
-  expect_equal(class_dispatch(klass), c(""R7_object"", ""character""))
+  expect_equal(class_dispatch(klass), c(""R7_object"", ""character"", ""ANY""))
   expect_equal(class_register(klass), ""character"")
   expect_equal(class_desc(klass), ""<character>"")
   expect_equal(class_construct(klass, ""x""), ""x"")
@@ -67,19 +68,22 @@ test_that(""can work with base types"", {
   obj <- ""x""
   expect_equal(obj_type(obj), ""base"")
   expect_equal(obj_desc(obj), ""<character>"")
-  expect_equal(obj_dispatch(obj), ""character"")
+  expect_equal(obj_dispatch(obj), c(""character"", ""ANY""))
   expect_equal(class_inherits(obj, klass), TRUE)
 })
 
 test_that(""class_inherits handles variation in class names"", {
   expect_true(class_inherits(1, base_classes$double))
+  expect_false(class_inherits(""x"", base_unions$double))
 
-  expect_true(class_inherits(1L, base_classes$numeric))
-  expect_true(class_inherits(1, base_classes$numeric))
+  expect_true(class_inherits(1L, base_unions$numeric))
+  expect_true(class_inherits(1, base_unions$numeric))
+  expect_false(class_inherits(""x"", base_unions$numeric))
 
   expect_true(class_inherits(function() {}, base_classes$`function`))
   expect_true(class_inherits(sum, base_classes$`function`))
   expect_true(class_inherits(`[`, base_classes$`function`))
+  expect_false(class_inherits(""x"", base_classes$`function`))
 })
 
 test_that(""can get class from base constructor"", {
@@ -98,7 +102,7 @@ test_that(""can work with S3 classes"", {
   expect_equal(as_class(klass), klass)
 
   expect_equal(class_type(klass), ""R7_S3"")
-  expect_equal(class_dispatch(klass), c(""R7_object"", ""ordered"", ""factor""))
+  expect_equal(class_dispatch(klass), c(""R7_object"", ""ordered"", ""factor"", ""ANY""))
   expect_equal(class_register(klass), ""ordered"")
   expect_equal(class_desc(klass), ""S3<ordered/factor>"")
   expect_equal(class_construct(klass), ordered(numeric()))
@@ -107,7 +111,7 @@ test_that(""can work with S3 classes"", {
   obj <- ordered(integer())
   expect_equal(obj_type(obj), ""S3"")
   expect_equal(obj_desc(obj), ""S3<ordered/factor>"")
-  expect_equal(obj_dispatch(obj), c(""ordered"", ""factor""))
+  expect_equal(obj_dispatch(obj), c(""ordered"", ""factor"", ""ANY""))
   expect_equal(class_inherits(obj, klass), TRUE)
   expect_equal(class_inherits(factor(), klass), FALSE)
 })
@@ -117,13 +121,13 @@ test_that(""can work with R7 classes that extend S3 classes"", {
   Date2 <- new_class(""Date2"", parent = Date, properties = list(x = ""numeric""))
 
   expect_equal(class_type(Date2), ""R7"")
-  expect_equal(class_dispatch(Date2), c(""Date2"", ""R7_object"", ""Date""))
+  expect_equal(class_dispatch(Date2), c(""Date2"", ""R7_object"", ""Date"", ""ANY""))
   expect_equal(class_register(Date2), ""Date2"")
 
   obj <- Date2(x = 1)
   expect_equal(obj_type(obj), ""R7"")
   expect_equal(obj_desc(obj), ""<Date2>"")
-  expect_equal(obj_dispatch(obj), c(""Date2"", ""R7_object"", ""Date""))
+  expect_equal(obj_dispatch(obj), c(""Date2"", ""R7_object"", ""Date"", ""ANY""))
   expect_equal(class_inherits(obj, Date2), TRUE)
 })
 
@@ -134,7 +138,7 @@ test_that(""can work with S4 classes"", {
   klass <- methods::getClass(""Range"")
 
   expect_equal(class_type(klass), ""S4"")
-  expect_equal(class_dispatch(klass), ""Range"")
+  expect_equal(class_dispatch(klass), c(""Range"", ""ANY""))
   expect_equal(class_register(klass), ""Range"")
   expect_s4_class(class_construct(klass, start = 1, end = 2), ""Range"")
   expect_equal(class_desc(klass), ""S4<Range>"")
@@ -143,7 +147,7 @@ test_that(""can work with S4 classes"", {
   obj <- methods::new(klass, start = 1, end = 1)
   expect_equal(obj_type(obj), ""S4"")
   expect_equal(obj_desc(obj), ""S4<Range>"")
-  expect_equal(obj_dispatch(obj), ""Range"")
+  expect_equal(obj_dispatch(obj), c(""Range"", ""ANY""))
   expect_equal(class_inherits(obj, klass), TRUE)
 })
 
@@ -153,11 +157,11 @@ test_that(""can work with S4 subclasses"", {
   klass <- methods::getClass(""Foo2"")
 
   expect_equal(class_type(klass), ""S4"")
-  expect_equal(class_dispatch(klass), c(""Foo2"", ""Foo1""))
+  expect_equal(class_dispatch(klass), c(""Foo2"", ""Foo1"", ""ANY""))
   expect_equal(class_register(klass), ""Foo2"")
 
   obj <- methods::new(klass, start = 1, end = 1)
-  expect_equal(obj_dispatch(obj), c(""Foo2"", ""Foo1""))
+  expect_equal(obj_dispatch(obj), c(""Foo2"", ""Foo1"", ""ANY""))
   expect_equal(class_inherits(obj, klass), TRUE)
 })
 
@@ -166,11 +170,11 @@ test_that(""can work with S4 subclasses of base classes"", {
   klass <- methods::getClass(""Foo3"")
 
   expect_equal(class_type(klass), ""S4"")
-  expect_equal(class_dispatch(klass), c(""Foo3"", ""character""))
+  expect_equal(class_dispatch(klass), c(""Foo3"", ""character"", ""ANY""))
   expect_equal(class_register(klass), ""Foo3"")
 
   obj <- methods::new(klass, ""x"")
-  expect_equal(obj_dispatch(obj), c(""Foo3"", ""character""))
+  expect_equal(obj_dispatch(obj), c(""Foo3"", ""character"", ""ANY""))
   expect_equal(class_inherits(obj, klass), TRUE)
 })
 
@@ -181,11 +185,11 @@ test_that(""can work with S4 multiple inheritance"", {
   klass <- methods::getClass(""Foo6"")
 
   expect_equal(class_type(klass), ""S4"")
-  expect_equal(class_dispatch(klass), c(""Foo6"", ""Foo4"", ""Foo5"", ""character""))
+  expect_equal(class_dispatch(klass), c(""Foo6"", ""Foo4"", ""Foo5"", ""character"", ""ANY""))
   expect_equal(class_register(klass), ""Foo6"")
 
   obj <- methods::new(klass, ""x"")
-  expect_equal(obj_dispatch(obj), c(""Foo6"", ""Foo4"", ""Foo5"", ""character""))
+  expect_equal(obj_dispatch(obj), c(""Foo6"", ""Foo4"", ""Foo5"", ""character"", ""ANY""))
   expect_equal(class_inherits(obj, klass), TRUE)
 })
 

---FILE: tests/testthat/test-method-register-dispatch.R---
@@ -1,6 +1,14 @@
 describe(""single dispatch"", {
   foo <- new_generic(""foo"", ""x"")
 
+  it(""works for specials"", {
+    method(foo, missing_class) <- function(x) ""missing""
+    method(foo, any_class) <- function(x) ""fallback""
+
+    expect_equal(foo(), ""missing"")
+    expect_equal(foo(1), ""fallback"")
+  })
+
   it(""works for base types"", {
     method(foo, ""character"") <- function(x) ""base""
 

---FILE: tests/testthat/test-property.R---
@@ -143,7 +143,7 @@ test_that(""property setters can set themselves"", {
 })
 
 test_that(""properties can be NULL"", {
-  foo <- new_class(""foo"", properties = list(x = NULL))
+  foo <- new_class(""foo"", properties = list(x = any_class))
   x <- foo(x = NULL)
   expect_equal(x@x, NULL)
   x@x <- 1
@@ -175,7 +175,8 @@ test_that(""properties can be base, S3, S4, R7, or R7 union"", {
 
   my_class <- new_class(""my_class"",
     properties = list(
-      anything = NULL,
+      anything = any_class,
+      null = NULL,
       base = ""integer"",
       S3 = new_S3_class(""factor""),
       S4 = class_S4,
@@ -186,6 +187,7 @@ test_that(""properties can be base, S3, S4, R7, or R7 union"", {
   expect_snapshot(my_class)
   my_obj <- my_class(
     anything = TRUE,
+    null = NULL,
     base = 1L,
     S3 = factor(),
     S4 = class_S4(x = 1),
@@ -203,6 +205,7 @@ test_that(""properties can be base, S3, S4, R7, or R7 union"", {
 
   # Then capture the error messages for human inspection
   expect_snapshot(error = TRUE, {
+    my_obj@null <- ""x""
     my_obj@base <- ""x""
     my_obj@S3 <- ""x""
     my_obj@S4 <- ""x""

---FILE: tests/testthat/test-special.R---
@@ -0,0 +1,13 @@
+test_that(""can test and print"", {
+  expect_true(is_missing_class(missing_class))
+  expect_false(is_missing_class(any_class))
+  expect_true(is_any_class(any_class))
+  expect_false(is_any_class(missing_class))
+
+  expect_snapshot({
+    print(missing_class)
+    print(any_class)
+
+    str(list(m = missing_class, a = any_class))
+  })
+})"
RConsortium,S7,415463b16426f28dbe8dc3dd0e53b4dc4397ffcd,Hadley Wickham,h.wickham@gmail.com,2022-02-17T14:20:17Z,Hadley Wickham,h.wickham@gmail.com,2022-02-17T14:20:17Z,Add more info to S3 registration error,R/method-register.R;tests/testthat/_snaps/method-register.md,False,True,True,False,4,3,7,"---FILE: R/method-register.R---
@@ -82,8 +82,9 @@ register_external_method <- function(generic, signature, method, package = NULL)
 register_S3_method <- function(generic, signature, method) {
   if (class_type(signature[[1]]) != ""R7"") {
     msg <- sprintf(
-      ""When registering methods for S3 generic %s(), signature must be an R7 class"",
-      generic$name
+      ""When registering methods for S3 generic %s(), signature must be an R7 class, not %s."",
+      generic$name,
+      class_friendly(signature[[1]])
     )
     stop(msg, call. = FALSE)
   }

---FILE: tests/testthat/_snaps/method-register.md---
@@ -3,7 +3,7 @@
     Code
       method(sum, new_S3_class(""foo"")) <- (function(x, ...) ""foo"")
     Error <simpleError>
-      When registering methods for S3 generic sum(), signature must be an R7 class
+      When registering methods for S3 generic sum(), signature must be an R7 class, not an S3 class.
 
 # method registration: checks argument types
 "
RConsortium,S7,f8157fd65e752748d2593966b9e82e850a43ee4c,Hadley Wickham,h.wickham@gmail.com,2022-02-16T17:50:51Z,Hadley Wickham,h.wickham@gmail.com,2022-02-16T17:50:51Z,Fix external generics to work with as_signature changes,NEWS.md;R/external-generic.R;R/generic-spec.R;R/method.R;man/new_external_generic.Rd;tests/testthat/_snaps/external-generic.md;tests/testthat/t2/R/pkg.R;tests/testthat/test-external-generic.R;tests/testthat/test-method.R,False,True,True,False,50,15,65,"---FILE: NEWS.md---
@@ -2,6 +2,9 @@
 
 ## Feb 2022
 
+* `new_external_generic()` now requires `dispatch_args` so we can eagerly 
+  check the signature.
+
 * Revamp website. README now shows brief example and more info in 
   `vignette(""R7"")`. Initial design docs and minutes are now articles so
   they appear on the website.

---FILE: R/external-generic.R---
@@ -17,13 +17,15 @@
 #'
 #' @param package Package the generic is defined in.
 #' @param name Name of generic, as a string.
+#' @param dispatch_args Character vector giving arguments used for dispatch.
 #' @param version An optional version the package must meet for the method to
 #'   be registered.
 #' @export
-new_external_generic <- function(package, name, version = NULL) {
+new_external_generic <- function(package, name, dispatch_args, version = NULL) {
   out <- list(
     package = package,
     name = name,
+    dispatch_args = dispatch_args,
     version = version
   )
 
@@ -35,7 +37,7 @@ new_external_generic <- function(package, name, version = NULL) {
 print.R7_external_generic <- function(x, ...) {
   cat(
     ""<R7_external_generic> "",
-    x$package, ""::"", x$name, ""()"",
+    x$package, ""::"", x$name, ""("", paste(x$dispatch_args, collapse = "", ""), "")"",
     if (!is.null(x$version)) paste0("" (>= "", x$version, "")""),
     ""\n"",
     sep = """"

---FILE: R/generic-spec.R---
@@ -37,8 +37,12 @@ generic_n_dispatch <- function(x) {
     1
   } else if (is_generic(x)) {
     length(x@dispatch_args)
-  } else {
+  } else if (is_external_generic(x)) {
+    length(x$dispatch_args)
+  } else if (methods::is(x, ""genericFunction"")) {
     length(x@signature)
+  } else {
+    stop(sprintf(""Invalid input %"", obj_desc(x)), call. = FALSE)
   }
 }
 

---FILE: R/method.R---
@@ -120,9 +120,13 @@ flatten_signature <- function(signature) {
 }
 
 as_signature <- function(signature, generic) {
+  if (inherits(signature, ""R7_signature"")) {
+    return(signature)
+  }
+
   n <- generic_n_dispatch(generic)
   if (n == 1) {
-    signature <- list(as_class(signature, arg = ""signature""))
+    new_signature(list(as_class(signature, arg = ""signature"")))
   } else {
     if (!is.list(signature) || is.object(signature)) {
       stop(""`signature` must be a list for multidispatch generics"", call. = FALSE)
@@ -134,10 +138,12 @@ as_signature <- function(signature, generic) {
     for (i in seq_along(signature)) {
       signature[[i]] <- as_class(signature[[i]], arg = sprintf(""signature[[%i]]"", i))
     }
-    signature
+    new_signature(signature)
   }
 }
 
+new_signature <- function(x) structure(x, class = ""R7_signature"")
+
 check_method <- function(method, generic, name = paste0(generic@name, ""(???)"")) {
   if (!is.function(method)) {
     stop(sprintf(""%s must be a function"", name), call. = FALSE)

---FILE: man/new_external_generic.Rd---
@@ -5,7 +5,7 @@
 \alias{external_methods_register}
 \title{Generics in suggested packages}
 \usage{
-new_external_generic(package, name, version = NULL)
+new_external_generic(package, name, dispatch_args, version = NULL)
 
 external_methods_register()
 }
@@ -14,6 +14,8 @@ external_methods_register()
 
 \item{name}{Name of generic, as a string.}
 
+\item{dispatch_args}{Character vector giving arguments used for dispatch.}
+
 \item{version}{An optional version the package must meet for the method to
 be registered.}
 }

---FILE: tests/testthat/_snaps/external-generic.md---
@@ -0,0 +1,7 @@
+# displays nicely
+
+    Code
+      print(bar)
+    Output
+      <R7_external_generic> foo::bar(x)
+

---FILE: tests/testthat/t2/R/pkg.R---
@@ -1,7 +1,7 @@
-foo <- R7::new_external_generic(""t1"", ""foo"")
+foo <- R7::new_external_generic(""t1"", ""foo"", ""x"")
 R7::method(foo, ""character"") <- function(x) ""foo""
 
-bar <- R7::new_external_generic(""t0"", ""bar"")
+bar <- R7::new_external_generic(""t0"", ""bar"", ""x"")
 R7::method(bar, ""character"") <- function(x) ""bar""
 
 .onLoad <- function(libname, pkgname) {

---FILE: tests/testthat/test-external-generic.R---
@@ -3,7 +3,7 @@ test_that(""can get and append methods"", {
 
   expect_equal(external_methods_get(""R7""), list())
 
-  bar <- new_external_generic(""foo"", ""bar"")
+  bar <- new_external_generic(""foo"", ""bar"", ""x"")
   external_methods_add(""R7"", bar, list(), function() {})
   expect_equal(
     external_methods_get(""R7""),
@@ -17,9 +17,16 @@ test_that(""can get and append methods"", {
   )
 })
 
+test_that(""displays nicely"", {
+  bar <- new_external_generic(""foo"", ""bar"", ""x"")
+  expect_snapshot({
+    print(bar)
+  })
+})
+
 test_that(""new_method works with both hard and soft dependencies"", {
   skip_on_os(""windows"")
-  skip_if(quick_test())
+  # skip_if(quick_test())
 
   tmp_lib <- tempfile()
   dir.create(tmp_lib)

---FILE: tests/testthat/test-method.R---
@@ -21,8 +21,8 @@ describe(""method registration"", {
   it(""can register method for external generic from within package"", {
     on.exit(external_methods_reset(""R7""), add = TRUE)
 
-    foo <- new_external_generic(""foo"", ""bar"")
-    register_external_method(foo, ""character"", function(x, ...) ""bar"", package = ""R7"")
+    foo <- new_external_generic(""foo"", ""bar"" ,""x"")
+    register_external_method(foo, ""character"", function(x) ""bar"", package = ""R7"")
     expect_length(external_methods_get(""R7""), 1)
 
     # and doesn't modify generic
@@ -31,7 +31,7 @@ describe(""method registration"", {
 
   it(""can register method for external generic during development"", {
     bar <- new_class(""bar"")
-    base_sum <- new_external_generic(""base"", ""sum"")
+    base_sum <- new_external_generic(""base"", ""sum"", ""x"")
     register_external_method(base_sum, bar, function(x, ...) ""bar"", package = NULL)
     expect_equal(sum(bar()), ""bar"")
   })
@@ -74,15 +74,19 @@ describe(""as_signature()"", {
   it(""returns a list that matches length of dispatch args"", {
     foo1 <- new_generic(""foo1"", ""x"")
     sig1 <- as_signature(""numeric"", foo1)
-    expect_type(sig1, ""list"")
+    expect_s3_class(sig1, ""R7_signature"")
     expect_length(sig1, 1)
 
     foo2 <- new_generic(""foo2"", c(""x"", ""y""))
     sig2 <- as_signature(list(""numeric"", ""character""), foo2)
-    expect_type(sig2, ""list"")
+    expect_s3_class(sig1, ""R7_signature"")
     expect_length(sig2, 2)
   })
 
+  it(""is idempotent"", {
+    expect_equal(as_signature(new_signature(10)), new_signature(10))
+  })
+
   it(""forbids list for single dispatch"", {
     foo <- new_generic(""foo"", ""x"")
     expect_snapshot(as_signature(list(1), foo), error = TRUE)"
RConsortium,S7,1467562b03e9d085ebb69b0b8997f5139d569ba3,Hadley Wickham,h.wickham@gmail.com,2022-02-15T15:27:06Z,Hadley Wickham,h.wickham@gmail.com,2022-02-15T15:27:06Z,"Check that properties can be NULL

Fixes #158",tests/testthat/test-property.R,False,True,True,False,11,0,11,"---FILE: tests/testthat/test-property.R---
@@ -157,6 +157,17 @@ test_that(""property setters can set themselves"", {
   expect_equal(x@bar, ""foo-bar"")
 })
 
+test_that(""properties can be NULL"", {
+  foo <- new_class(""foo"", properties = list(x = NULL))
+  x <- foo(x = NULL)
+  expect_equal(x@x, NULL)
+  x@x <- 1
+  expect_equal(x@x, 1)
+  x@x <- NULL
+  expect_equal(x@x, NULL)
+  expect_equal(prop_names(x), ""x"")
+  expect_equal(props(x), list(x = NULL))
+})
 
 test_that(""new_property validates name"", {
   expect_snapshot(error = TRUE, {"
RConsortium,S7,6f40123ba85b7c6b797c7a7a1fda69bbd120803f,Hadley Wickham,h.wickham@gmail.com,2022-02-14T23:24:41Z,Hadley Wickham,h.wickham@gmail.com,2022-02-14T23:24:41Z,"Eliminate prop_safely()

Fixes #158",R/class.R;R/property.R;R/valid.R,False,True,True,False,11,12,23,"---FILE: R/class.R---
@@ -131,7 +131,11 @@ print.R7_class <- function(x, ...) {
     prop_fmt <- """"
   }
 
-  parent <- class_desc(prop_safely(x, ""parent""))
+  if (prop_exists(x, ""parent"")) {
+    parent <- class_desc(x@parent)
+  } else {
+    parent <- ""NULL""
+  }
 
   cat(sprintf(""<R7_class>\n@ name  :  %s\n@ parent: %s\n@ properties:\n%s"", x@name, parent, prop_fmt), sep = """")
   invisible(x)

---FILE: R/property.R---
@@ -118,16 +118,6 @@ prop <- function(object, name) {
   }
 }
 
-prop_safely <- function(object, name) {
-  if (!inherits(object, ""R7_object"")) {
-    NULL
-  } else if (!prop_exists(object, name)) {
-    NULL
-  } else {
-    prop_val(object, name)
-  }
-}
-
 # Internal helper that assumes the property exists
 prop_val <- function(object, name) {
   val <- attr(object, name, exact = TRUE)

---FILE: R/valid.R---
@@ -82,7 +82,12 @@ validate <- function(object, properties = TRUE) {
   errors <- character()
   while(!is.null(class)) {
     errors <- c(errors, class_validate(class, object))
-    class <- prop_safely(class, ""parent"")
+
+    if (prop_exists(class, ""parent"")) {
+      class <- class@parent
+    } else {
+      class <- NULL
+    }
   }
 
   # If needed, report errors"
RConsortium,S7,6815be62a20ec3f198154164e471ab3fe49efc3b,Hadley Wickham,h.wickham@gmail.com,2022-02-14T23:22:47Z,GitHub,noreply@github.com,2022-02-14T23:22:47Z,"Add OO type to S3 and S4 class/object descriptions (#161)

Fixes #133",R/class-spec.R;R/class.R;R/object.R;R/property.R;R/valid.R;tests/testthat/_snaps/object.md;tests/testthat/_snaps/property.md;tests/testthat/_snaps/valid.md;tests/testthat/test-class-spec.R;tests/testthat/test-property.R,False,True,True,False,39,41,80,"---FILE: R/class-spec.R---
@@ -132,8 +132,8 @@ class_validate <- function(class, object) {
 class_desc <- function(x) {
   switch(class_type(x),
     NULL = ""<ANY>"",
-    s3 = fmt_classes(x$class[[1]]),
-    s4 = fmt_classes(x@className),
+    s3 = fmt_classes(x$class[[1]], ""S3""),
+    s4 = fmt_classes(x@className, ""S4""),
     r7 = fmt_classes(x@name),
     r7_base = fmt_classes(x@name),
     r7_union = oxford_or(unlist(lapply(x@classes, class_desc))),
@@ -195,16 +195,16 @@ obj_desc <- function(x) {
   switch(obj_type(x),
    NULL = ""NULL"",
    base = fmt_classes(typeof(x)),
-   s3 = fmt_classes(class(x)[[1]]),
-   s4 = fmt_classes(class(x)),
+   s3 = fmt_classes(class(x)[[1]], ""S3""),
+   s4 = fmt_classes(class(x), ""S4""),
    r7 = fmt_classes(object_class(x)@name)
   )
 }
 
 # helpers -----------------------------------------------------------------
 
-fmt_classes <- function(classes, collapse = "", "") {
-  paste0(""<"", classes, "">"", collapse = collapse)
+fmt_classes <- function(classes, prefix = NULL) {
+  paste0(prefix, ""<"", classes, "">"", collapse = "", "")
 }
 
 # Suppress @className false positive

---FILE: R/class.R---
@@ -130,10 +130,10 @@ print.R7_class <- function(x, ...) {
   } else {
     prop_fmt <- """"
   }
-  parent <- prop_safely(x, ""parent"")
-  parent <- prop_safely(parent, ""name"") %||% parent %||% """"
 
-  cat(sprintf(""<R7_class>\n@ name  :  %s\n@ parent: <%s>\n@ properties:\n%s"", x@name, parent, prop_fmt), sep = """")
+  parent <- class_desc(prop_safely(x, ""parent""))
+
+  cat(sprintf(""<R7_class>\n@ name  :  %s\n@ parent: %s\n@ properties:\n%s"", x@name, parent, prop_fmt), sep = """")
   invisible(x)
 }
 

---FILE: R/object.R---
@@ -67,7 +67,7 @@ print.R7_object <- function(x, ...) {
 #' @export
 str.R7_object <- function(object, ..., nest.lev = 0) {
   cat(if (nest.lev > 0) "" "")
-  cat(""<"", paste0(class(object), collapse = ""/""), "">"", sep = """")
+  cat(obj_desc(object))
 
   if (typeof(object) != ""S4"") {
     bare <- object

---FILE: R/property.R---
@@ -183,9 +183,9 @@ prop_error_unknown <- function(object, prop_name) {
   sprintf(""Can't find property %s@%s"", obj_desc(object), prop_name)
 }
 
-prop_error_type <- function(object, prop_name, expected, actual) {
-  sprintf(""%s@%s must be of class %s, not %s"",
-    obj_desc(object),
+prop_error_type <- function(object, prop_name, expected, actual, show_type = TRUE) {
+  sprintf(""%s@%s must be %s, not %s"",
+    if (show_type) obj_desc(object) else """",
     prop_name,
     class_desc(expected),
     obj_desc(actual)

---FILE: R/valid.R---
@@ -106,7 +106,7 @@ validate_properties <- function(object, class) {
 
     value <- prop(object, prop$name)
     if (!class_inherits(value, prop$class)) {
-      errors <- c(errors, prop_error_type(object, prop$name, prop$class, value))
+      errors <- c(errors, prop_error_type(object, prop$name, prop$class, value, show_type = FALSE))
     }
     prop
   }

---FILE: tests/testthat/_snaps/object.md---
@@ -4,8 +4,8 @@
       range(start = ""x"", end = ""y"")
     Error <simpleError>
       <range> object properties are invalid:
-      - <range>@start must be of class <integer> or <double>, not <character>
-      - <range>@end must be of class <integer> or <double>, not <character>
+      - @start must be <integer> or <double>, not <character>
+      - @end must be <integer> or <double>, not <character>
 
 # new_object: checks are arguments are properties
 
@@ -32,25 +32,25 @@
     Code
       str(range(1, 10))
     Output
-      <range/R7_object>
+      <range>
       @ start :  num 1
       @ end   :  num 10
       @ length:  num 9
     Code
       str(list(text(""b""), number(50)))
     Output
       List of 2
-       $ : <text/R7_object/character> chr ""b""
-       $ : <number/R7_object/double> num 50
+       $ : <text> chr ""b""
+       $ : <number> num 50
 
 # print()/str() nests properties correctly
 
     Code
       str(klass(x = 10, y = range(1, 10)))
     Output
-      <klass/R7_object>
+      <klass>
       @ x:  num 10
-      @ y:  <range/R7_object>
+      @ y:  <range>
        .. @ start :  num 1
        .. @ end   :  num 10
        .. @ length:  num 9

---FILE: tests/testthat/_snaps/property.md---
@@ -46,8 +46,8 @@
       @ properties:
        $ anything: <ANY>                 
        $ base    : <integer>             
-       $ s3      : <factor>              
-       $ s4      : <class_s4>            
+       $ s3      : S3<factor>            
+       $ s4      : S4<class_s4>          
        $ r7      : <class_r7>            
        $ r7_union: <integer> or <logical>
 
@@ -56,23 +56,23 @@
     Code
       my_obj@base <- ""x""
     Error <simpleError>
-      <my_class>@base must be of class <integer>, not <character>
+      <my_class>@base must be <integer>, not <character>
     Code
       my_obj@s3 <- ""x""
     Error <simpleError>
-      <my_class>@s3 must be of class <factor>, not <character>
+      <my_class>@s3 must be S3<factor>, not <character>
     Code
       my_obj@s4 <- ""x""
     Error <simpleError>
-      <my_class>@s4 must be of class <class_s4>, not <character>
+      <my_class>@s4 must be S4<class_s4>, not <character>
     Code
       my_obj@r7 <- ""x""
     Error <simpleError>
-      <my_class>@r7 must be of class <class_r7>, not <character>
+      <my_class>@r7 must be <class_r7>, not <character>
     Code
       my_obj@r7_union <- ""x""
     Error <simpleError>
-      <my_class>@r7_union must be of class <integer> or <logical>, not <character>
+      <my_class>@r7_union must be <integer> or <logical>, not <character>
 
 # as_properties() gives useful error messages
 

---FILE: tests/testthat/_snaps/valid.md---
@@ -12,7 +12,7 @@
       validate(obj)
     Error <simpleError>
       <klass> object properties are invalid:
-      - <klass>@x must be of class <double>, not <character>
+      - @x must be <double>, not <character>
 
 ---
 
@@ -29,8 +29,8 @@
       validate(obj)
     Error <simpleError>
       <klass2> object properties are invalid:
-      - <klass2>@x must be of class <double>, not <character>
-      - <klass2>@z must be of class <double>, not <character>
+      - @x must be <double>, not <character>
+      - @z must be <double>, not <character>
 
 # validate checks base type
 

---FILE: tests/testthat/test-class-spec.R---
@@ -47,15 +47,16 @@ test_that(""handles NULL"", {
 test_that(""can work with S4 classes"", {
   methods::setClass(""Range"", slots = c(start = ""numeric"", end = ""numeric""))
   klass <- methods::getClass(""Range"")
+
   expect_equal(class_type(klass), ""s4"")
   expect_equal(class_names(klass), ""Range"")
   expect_s4_class(class_construct(klass, start = 1, end = 2), ""Range"")
-  expect_equal(class_desc(klass), ""<Range>"")
+  expect_equal(class_desc(klass), ""S4<Range>"")
   expect_equal(class_deparse(klass), ""Range"")
 
   obj <- methods::new(klass, start = 1, end = 1)
   expect_equal(obj_type(obj), ""s4"")
-  expect_equal(obj_desc(obj), ""<Range>"")
+  expect_equal(obj_desc(obj), ""S4<Range>"")
   expect_equal(class_inherits(obj, klass), TRUE)
 })
 
@@ -82,13 +83,13 @@ test_that(""can work with simple S3 classes"", {
 
   expect_equal(class_type(klass), ""s3"")
   expect_equal(class_names(klass), c(""R7_object"", ""data.frame""))
+  expect_equal(class_desc(klass), ""S3<data.frame>"")
   expect_equal(class_construct(klass, list(x = 1)), data.frame(x = 1))
-  expect_equal(class_desc(klass), ""<data.frame>"")
   expect_equal(class_deparse(klass), 's3_class(""data.frame"")')
 
   obj <- data.frame()
   expect_equal(obj_type(obj), ""s3"")
-  expect_equal(obj_desc(obj), ""<data.frame>"")
+  expect_equal(obj_desc(obj), ""S3<data.frame>"")
   expect_equal(class_inherits(obj, klass), TRUE)
 })
 
@@ -101,13 +102,13 @@ test_that(""can work with compound s3 classes"", {
 
   expect_equal(class_type(klass), ""s3"")
   expect_equal(class_names(klass), c(""R7_object"", ""ordered"", ""factor""))
-  expect_equal(class_desc(klass), ""<ordered>"")
+  expect_equal(class_desc(klass), ""S3<ordered>"")
   expect_equal(class_construct(klass), ordered(numeric()))
   expect_equal(class_deparse(klass), 's3_class(""ordered"", ""factor"")')
 
   obj <- ordered(integer())
   expect_equal(obj_type(obj), ""s3"")
-  expect_equal(obj_desc(obj), ""<ordered>"")
+  expect_equal(obj_desc(obj), ""S3<ordered>"")
   expect_equal(class_inherits(obj, klass), TRUE)
   expect_equal(class_inherits(factor(), klass), FALSE)
 })

---FILE: tests/testthat/test-property.R---
@@ -42,10 +42,7 @@ describe(""prop<-"", {
   })
   it(""errors if the value does not match the correct class"", {
     x <- range(1, 10)
-    expect_error(
-      prop(x, ""start"") <- ""foo"",
-      ""must be of class""
-    )
+    expect_error(prop(x, ""start"") <- ""foo"", ""must be"")
   })
   it(""does not run the check or validation functions if check = FALSE"", {
     x <- range(1, 10)"
RConsortium,S7,7fbf21b7c2e5abf3726bfbb60d842120e4acf1e5,Hadley Wickham,h.wickham@gmail.com,2022-02-14T23:06:50Z,GitHub,noreply@github.com,2022-02-14T23:06:50Z,"Make dispatch_args second argument of new_generic() (#166)

Since most of the time, it's all you need. Fixes #164",R/dispatch.R;R/generic.R;R/method.R;README.Rmd;README.md;man/method-set.Rd;man/method.Rd;man/new_generic.Rd;tests/testthat/_snaps/method.md;tests/testthat/t0/R/pkg.R;tests/testthat/t1/R/foo.R;tests/testthat/test-dispatch.R;tests/testthat/test-generic-spec.R;tests/testthat/test-generic.R;tests/testthat/test-method.R;vignettes/case_studies.Rmd;vignettes/performance.Rmd,True,True,True,False,60,64,124,"---FILE: R/dispatch.R---
@@ -11,7 +11,7 @@
 #' @export
 #' @examples
 #' # Create a generic and register some methods
-#' bizarro <- new_generic(""bizarro"", dispatch_args = ""x"")
+#' bizarro <- new_generic(""bizarro"", ""x"")
 #' method(bizarro, ""numeric"") <- function(x) rev(x)
 #' method(bizarro, s3_class(""factor"")) <- function(x) {
 #'   levels(x) <- rev(levels(x))

---FILE: R/generic.R---
@@ -49,7 +49,7 @@
 #'
 #' # If you want to require methods implement additional arguments, supply
 #' # them after ... in the call
-#' mean2 <- new_generic(""mean2"", function(x, ..., na.rm = TRUE) {
+#' mean2 <- new_generic(""mean2"", fun = function(x, ..., na.rm = TRUE) {
 #'    method_call()
 #' })
 #' method(mean2, ""numeric"") <- function(x, ..., na.rm = TRUE) {
@@ -62,7 +62,7 @@
 #'   stop(""Not supported"")
 #' }
 #'
-new_generic <- function(name, fun = NULL, dispatch_args = NULL) {
+new_generic <- function(name, dispatch_args = NULL, fun = NULL) {
   check_name(name)
 
   if (is.null(dispatch_args) && is.null(fun)) {

---FILE: R/method.R---
@@ -34,7 +34,7 @@
 #' @export
 #' @examples
 #' # Create a generic
-#' bizarro <- new_generic(""bizarro"", dispatch_args = ""x"")
+#' bizarro <- new_generic(""bizarro"", ""x"")
 #' # Register some methods
 #' method(bizarro, ""numeric"") <- function(x) rev(x)
 #' method(bizarro, s3_class(""data.frame"")) <- function(x) {

---FILE: README.Rmd---
@@ -89,7 +89,7 @@ x
 
 ```{r}
 text <- new_class(""text"", parent = ""character"")
-foo <- new_generic(""foo"", dispatch_args = ""x"")
+foo <- new_generic(""foo"", ""x"")
 method(foo, text) <- function(x, ...) paste0(""foo-"", x)
 
 foo(text(""hi""))
@@ -105,7 +105,7 @@ For `method(foo, c(""character"", ""numeric""))` the method would be stored at `foo@
 At each level the search iteratively searches along objects class vector.
 
 ```{r}
-bar <- new_generic(""bar"", dispatch_args = c(""x"", ""y""))
+bar <- new_generic(""bar"", c(""x"", ""y""))
 method(bar, list(""character"", ""double"")) <- function(x, y) paste0(""foo-"", x, "":"", y)
 
 bar(""hi"", 42)
@@ -131,7 +131,7 @@ bar(text(""hi""), 42)
 `method_call()` retains promises for dispatch arguments in basically the same way as `UseMethod()`, so non-standard evaluation works basically the same as S3.
 
 ```{r}
-subset2 <- new_generic(""subset2"", dispatch_args = ""x"")
+subset2 <- new_generic(""subset2"", ""x"")
 
 method(subset2, s3_class(""data.frame"")) <- function(x, subset = NULL, select = NULL, drop = FALSE) {
   e <- substitute(subset)

---FILE: README.md---
@@ -73,7 +73,7 @@ x@end <- ""foo""
 
 # assigning properties runs the validator
 x@end <- 0
-#> Error: Invalid <range> object:
+#> Error: <range> object is invalid:
 #> - <range>@end must be greater than or equal to <range>@start
 
 # Print methods for both R7_class objects
@@ -98,9 +98,8 @@ x
 
 ``` r
 text <- new_class(""text"", parent = ""character"")
-foo <- new_generic(""foo"", dispatch_args = ""x"")
+foo <- new_generic(""foo"", ""x"")
 method(foo, text) <- function(x, ...) paste0(""foo-"", x)
-#> registered foo(<text>)
 
 foo(text(""hi""))
 #> [1] ""foo-hi""
@@ -119,9 +118,8 @@ At each level the search iteratively searches along objects class
 vector.
 
 ``` r
-bar <- new_generic(""bar"", dispatch_args = c(""x"", ""y""))
+bar <- new_generic(""bar"", c(""x"", ""y""))
 method(bar, list(""character"", ""double"")) <- function(x, y) paste0(""foo-"", x, "":"", y)
-#> registered bar(<character>, <double>)
 
 bar(""hi"", 42)
 #> [1] ""foo-hi:42""
@@ -139,7 +137,6 @@ method(bar, list(text, ""double"")) <- function(x, y, ...) {
   res <- next_method()(x, y)
   paste0(""2 "", res)
 }
-#> registered bar(<text>, <double>)
 
 bar(text(""hi""), 42)
 #> [1] ""2 foo-hi:42""
@@ -152,7 +149,7 @@ same way as `UseMethod()`, so non-standard evaluation works basically
 the same as S3.
 
 ``` r
-subset2 <- new_generic(""subset2"", dispatch_args = ""x"")
+subset2 <- new_generic(""subset2"", ""x"")
 
 method(subset2, s3_class(""data.frame"")) <- function(x, subset = NULL, select = NULL, drop = FALSE) {
   e <- substitute(subset)
@@ -165,7 +162,6 @@ method(subset2, s3_class(""data.frame"")) <- function(x, subset = NULL, select = N
   vars <- eval(substitute(select), nl, parent.frame())
   x[r, vars, drop = drop]
 }
-#> registered subset2(<data.frame>)
 
 subset2(mtcars, hp > 200, c(wt, qsec))
 #>                        wt  qsec

---FILE: man/method-set.Rd---
@@ -45,7 +45,7 @@ But this is not a general method registration function: at least one of
 }
 \examples{
 # Create a generic
-bizarro <- new_generic(""bizarro"", dispatch_args = ""x"")
+bizarro <- new_generic(""bizarro"", ""x"")
 # Register some methods
 method(bizarro, ""numeric"") <- function(x) rev(x)
 method(bizarro, s3_class(""data.frame"")) <- function(x) {

---FILE: man/method.Rd---
@@ -40,7 +40,7 @@ of a specific method.
 }
 \examples{
 # Create a generic and register some methods
-bizarro <- new_generic(""bizarro"", dispatch_args = ""x"")
+bizarro <- new_generic(""bizarro"", ""x"")
 method(bizarro, ""numeric"") <- function(x) rev(x)
 method(bizarro, s3_class(""factor"")) <- function(x) {
   levels(x) <- rev(levels(x))

---FILE: man/new_generic.Rd---
@@ -5,27 +5,27 @@
 \alias{method_call}
 \title{Define a new generic}
 \usage{
-new_generic(name, fun = NULL, dispatch_args = NULL)
+new_generic(name, dispatch_args = NULL, fun = NULL)
 
 method_call()
 }
 \arguments{
 \item{name}{The name of the generic. This should be the same as the object
 that you assign it to.}
 
-\item{fun}{An optional specification of the generic, which must call
-\code{method_call()} to dispatch to methods. This is usually generated
-automatically from the \code{dispatch_args}, but you may want to supply it if
-you want to add additional required arguments, or perform some standardised
-computation in the generic.}
-
 \item{dispatch_args}{A character vector giving the names of the arguments
 that form the signature, i.e. the arguments used for method dispatch.
 
 If \code{dispatch_args} are omitted, but \code{fun} is supplied, will default to the
 arguments that appear before \code{...} in \code{fun}. If there are no dots, it will
 default to the first argument. If both \code{fun} and \code{dispatch_args} are
 supplied, the \code{dispatch_args} must appear at the start of \code{fun}'s formals.}
+
+\item{fun}{An optional specification of the generic, which must call
+\code{method_call()} to dispatch to methods. This is usually generated
+automatically from the \code{dispatch_args}, but you may want to supply it if
+you want to add additional required arguments, or perform some standardised
+computation in the generic.}
 }
 \description{
 A generic function uses different implementations (\emph{methods}) depending on
@@ -59,7 +59,7 @@ type_of(mean)
 
 # If you want to require methods implement additional arguments, supply
 # them after ... in the call
-mean2 <- new_generic(""mean2"", function(x, ..., na.rm = TRUE) {
+mean2 <- new_generic(""mean2"", fun = function(x, ..., na.rm = TRUE) {
    method_call()
 })
 method(mean2, ""numeric"") <- function(x, ..., na.rm = TRUE) {

---FILE: tests/testthat/_snaps/method.md---
@@ -24,7 +24,7 @@
 # check_method errors if the functions are not compatible
 
     Code
-      foo <- new_generic(""foo"", dispatch_args = ""x"")
+      foo <- new_generic(""foo"", ""x"")
       check_method(1, ""character"", foo)
     Error <simpleError>
       foo(<character>) must be a function
@@ -44,7 +44,7 @@
 # check_method warn if default arguments don't match
 
     Code
-      foo <- new_generic(""foo"", function(x, ..., z = 2, y = 1) method_call())
+      foo <- new_generic(""foo"", fun = function(x, ..., z = 2, y = 1) method_call())
       check_method(function(x, ..., y = 1) { }, ""character"", foo)
     Warning <simpleWarning>
       foo(<character>) doesn't have argument `z`

---FILE: tests/testthat/t0/R/pkg.R---
@@ -1,3 +1,3 @@
 #' @importFrom R7 method object_class
 #' @export
-bar <- R7::new_generic(""bar"", dispatch_args = ""x"")
+bar <- R7::new_generic(""bar"", ""x"")

---FILE: tests/testthat/t1/R/foo.R---
@@ -1,3 +1,3 @@
 #' @importFrom R7 method object_class
 #' @export
-foo <- R7::new_generic(""foo"", dispatch_args = ""x"")
+foo <- R7::new_generic(""foo"", ""x"")

---FILE: tests/testthat/test-dispatch.R---
@@ -1,5 +1,5 @@
 describe(""single dispatch"", {
-  foo <- new_generic(""foo"", dispatch_args = ""x"")
+  foo <- new_generic(""foo"", ""x"")
 
   it(""works for base types"", {
     method(foo, ""character"") <- function(x) ""base""
@@ -37,13 +37,13 @@ describe(""single dispatch"", {
 
 describe(""multiple dispatch"", {
   it(""works directly"", {
-    foo <- new_generic(""foo3"", dispatch_args = c(""x"", ""y""))
+    foo <- new_generic(""foo3"", c(""x"", ""y""))
     method(foo, list(text, number)) <- function(x, y) paste0(x, y)
     expect_equal(foo(text(""bar""), number(1)), ""bar1"")
   })
 
   it(""works via inheritance"", {
-    foo <- new_generic(""foo"", dispatch_args = c(""x"", ""y""))
+    foo <- new_generic(""foo"", c(""x"", ""y""))
     method(foo, list(""character"", ""numeric"")) <- function(x, y) paste0(x, "":"", y)
 
     expect_equal(foo(text(""bar""), number(1)), ""bar:1"")
@@ -52,7 +52,7 @@ describe(""multiple dispatch"", {
 
 
 test_that(""can substitute() args"", {
-  foo <- new_generic(""foo"", function(x, ..., z = 1) method_call())
+  foo <- new_generic(""foo"", fun = function(x, ..., z = 1) method_call())
   method(foo, ""character"") <- function(x, ..., z = 1) substitute(x)
   expect_equal(foo(letters), quote(letters))
 
@@ -65,7 +65,7 @@ test_that(""can substitute() args"", {
 })
 
 test_that(""methods get values modified in the generic"", {
-  foo <- new_generic(""foo"", function(x, y = 1) {
+  foo <- new_generic(""foo"", fun = function(x, y = 1) {
     y <- 10
     method_call()
   })
@@ -82,13 +82,13 @@ test_that(""dispatched arguments are evaluated once"", {
     }
   })
 
-  f <- new_generic(""f"", dispatch_args = ""x"")
+  f <- new_generic(""f"", ""x"")
   method(f, ""numeric"") <- function(x) x
   expect_equal(f(counter()), 1)
 })
 
 test_that(""generics pass ... to methods"", {
-  foo <- new_generic(""foo"", dispatch_args = ""x"")
+  foo <- new_generic(""foo"", ""x"")
 
   method(foo, ""character"") <- function(x, y = 1) y
   expect_equal(foo(""x""), 1)
@@ -97,13 +97,13 @@ test_that(""generics pass ... to methods"", {
 })
 
 test_that(""generics pass extra args to methods"", {
-  foo <- new_generic(""foo"", function(x, ..., z = 1) method_call())
+  foo <- new_generic(""foo"", fun = function(x, ..., z = 1) method_call())
   method(foo, ""character"") <- function(x, ..., z = 1) z
   expect_equal(foo(""x"", z = 3), 3)
 })
 
 test_that(""can dispatch on base 'union' types"", {
-  foo <- new_generic(""foo"", dispatch_args = ""x"")
+  foo <- new_generic(""foo"", ""x"")
   method(foo, ""vector"") <- function(x) ""v""
   method(foo, ""atomic"") <- function(x) ""a""
   method(foo, ""numeric"") <- function(x) ""n""
@@ -116,7 +116,7 @@ test_that(""can dispatch on base 'union' types"", {
 })
 
 test_that(""method lookup fails with informative messages"", {
-  foo <- new_generic(""foo"", dispatch_args = c(""x"", ""y""))
+  foo <- new_generic(""foo"", c(""x"", ""y""))
   method(foo, list(""character"", ""integer"")) <- function(x, y) paste0(""bar:"", x, y)
   expect_snapshot_error(foo(TRUE))
   expect_snapshot_error(foo(TRUE, list()))
@@ -136,7 +136,7 @@ describe(""method()"", {
   })
 
   test_that(""errors if no method found"", {
-    foo <- new_generic(""foo"", dispatch_args = ""x"")
+    foo <- new_generic(""foo"", ""x"")
 
     expect_snapshot(error = TRUE, {
       method(foo, list())
@@ -146,7 +146,7 @@ describe(""method()"", {
 })
 
 test_that(""next_method works for single dispatch"", {
-  foo <- new_generic(""foo"", dispatch_args = ""x"")
+  foo <- new_generic(""foo"", ""x"")
 
   method(foo, text) <- function(x, ...) {
     r7_data(x) <- paste0(""foo-"", r7_data(x))
@@ -159,7 +159,7 @@ test_that(""next_method works for single dispatch"", {
 })
 
 test_that(""next_method works for double dispatch"", {
-  foo <- new_generic(""foo"", dispatch_args = c(""x"", ""y""))
+  foo <- new_generic(""foo"", c(""x"", ""y""))
 
   method(foo, list(text, number)) <- function(x, y, ...) {
     r7_data(x) <- paste0(""foo-"", r7_data(x), ""-"", r7_data(y))

---FILE: tests/testthat/test-generic-spec.R---
@@ -1,5 +1,5 @@
 test_that(""can standardise generics"", {
-  foo_R7 <- new_generic(""foo"", dispatch_args = ""x"")
+  foo_R7 <- new_generic(""foo"", ""x"")
   methods::setGeneric(""foo_S4"", function(x) {})
 
   expect_equal(as_generic(foo_R7), foo_R7)

---FILE: tests/testthat/test-generic.R---
@@ -7,15 +7,15 @@ test_that(""new_generic checks its inputs"", {
 })
 
 test_that(""dispatch_args overrules derived"", {
-  g <- new_generic(""g"", function(x, y, ...) method_call())
+  g <- new_generic(""g"", fun = function(x, y, ...) method_call())
   expect_equal(g@dispatch_args, c(""x"", ""y""))
 
-  g <- new_generic(""g"", function(x, ...) method_call(), dispatch_args = ""x"")
+  g <- new_generic(""g"", fun = function(x, ...) method_call(), dispatch_args = ""x"")
   expect_equal(g@dispatch_args, ""x"")
 })
 
 test_that(""derived fun always includes ..."", {
-  g <- new_generic(""g"", dispatch_args = ""x"")
+  g <- new_generic(""g"", ""x"")
   expect_equal(names(formals(g)), c(""x"", ""...""))
 })
 
@@ -43,11 +43,11 @@ test_that(""check_dispatch_args() produces informative errors"", {
 })
 
 test_that(""R7_generic printing"", {
-  foo1 <- new_generic(name = ""foo1"", dispatch_args = c(""x"", ""y"", ""z""))
+  foo1 <- new_generic(""foo1"", c(""x"", ""y"", ""z""))
   method(foo1, list(""character"")) <- function(x, y, z, ...) 1
   method(foo1, list(text)) <- function(x, y, z, ...) 2
 
-  foo3 <- new_generic(name = ""foo3"", dispatch_args = c(""x"", ""y"", ""z""))
+  foo3 <- new_generic(""foo3"", c(""x"", ""y"", ""z""))
   method(foo3, list(""character"", text, ""character"")) <- function(x, y, z, ...) 1
   method(foo3, list(""character"", ""integer"", ""character"")) <- function(x, y, z, ...) 2
   method(foo3, list(""character"", ""integer"", ""logical"")) <- function(x, y, z, ...) 3
@@ -59,7 +59,7 @@ test_that(""R7_generic printing"", {
 })
 
 test_that(""R7_generic printing with long / many arguments"", {
-  foo <- new_generic(name = ""foo"", dispatch_args = letters)
+  foo <- new_generic(""foo"", letters)
   expect_snapshot(
     foo
   )

---FILE: tests/testthat/test-method.R---
@@ -1,13 +1,13 @@
 describe(""method registration"", {
   it(""adds methods to the generic"", {
-    foo <- new_generic(""foo"", dispatch_args = ""x"")
+    foo <- new_generic(""foo"", ""x"")
     method(foo, ""character"") <- function(x) ""c""
     method(foo, ""integer"") <- function(x) ""i""
     expect_length(methods(foo), 2)
   })
 
   it(""adds method for each element of a union"", {
-    foo <- new_generic(""foo"", dispatch_args = ""x"")
+    foo <- new_generic(""foo"", ""x"")
     method(foo, ""numeric"") <- function(x) ""x""
 
     # one method for each union component
@@ -62,7 +62,7 @@ describe(""method registration"", {
   })
 
   it(""checks argument types"", {
-    foo <- new_generic(""foo"", dispatch_args = ""x"")
+    foo <- new_generic(""foo"", ""x"")
     expect_snapshot(error = TRUE, {
       x <- 10
       method(x, ""character"") <- function(x) ...
@@ -73,18 +73,18 @@ describe(""method registration"", {
 
 
 test_that(""check_method returns TRUE if the functions are compatible"", {
-  foo <- new_generic(""foo"", function(x, ...) method_call())
+  foo <- new_generic(""foo"", fun = function(x, ...) method_call())
   expect_true(check_method(function(x, ...) x, ""character"", foo))
   # extra arguments are ignored
   expect_true(check_method(function(x, ..., y) x, ""character"", foo))
 
-  foo <- new_generic(""foo"", function(x) method_call())
+  foo <- new_generic(""foo"", fun = function(x) method_call())
   expect_true(check_method(function(x) x, ""character"", foo))
 })
 
 test_that(""check_method errors if the functions are not compatible"", {
   expect_snapshot(error = TRUE, {
-    foo <- new_generic(""foo"", dispatch_args = ""x"")
+    foo <- new_generic(""foo"", ""x"")
     check_method(1, ""character"", foo)
     check_method(function(y) {}, ""character"", foo)
     check_method(function(x = ""foo"") {}, ""character"", foo)
@@ -94,14 +94,14 @@ test_that(""check_method errors if the functions are not compatible"", {
 
 test_that(""check_method warn if default arguments don't match"", {
   expect_snapshot({
-    foo <- new_generic(""foo"", function(x, ..., z = 2, y = 1) method_call())
+    foo <- new_generic(""foo"", fun = function(x, ..., z = 2, y = 1) method_call())
     check_method(function(x, ..., y = 1) {}, ""character"", foo)
     check_method(function(x, ..., y = 1, z = 1) {}, ""character"", foo)
   })
 })
 
 test_that(""R7_method printing"", {
-  foo <- new_generic(name=""foo"", dispatch_args = c(""x"", ""y""))
+  foo <- new_generic(""foo"", c(""x"", ""y""))
   method(foo, list(text, ""integer"")) <- function(x, y, ...) paste0(""bar:"", x, y)
   expect_snapshot(
     method(foo, list(text, ""integer"")),

---FILE: vignettes/case_studies.Rmd---
@@ -176,7 +176,7 @@ We next define a `R7_subset` generic function, and then a R7 method for that fun
 The subsets the individual components appropriately and then returns a new `annotated_df` object with them.
 
 ```{r}
-subset_R7 <- new_generic(""R7_subset"", dispatch_args = c(""object"", ""row"", ""column""))
+subset_R7 <- new_generic(""R7_subset"", c(""object"", ""row"", ""column""))
 
 method(subset_R7, list(annotated_df, ""integer"", ""integer"")) <- function(object, row, column, ...) {
   data <- object@data[row, column]

---FILE: vignettes/performance.Rmd---
@@ -27,7 +27,7 @@ number <- new_class(""number"", parent = ""double"", constructor = function(x) new_o
 x <- text(""hi"")
 y <- number(1)
 
-foo_R7 <- new_generic(""foo_R7"", dispatch_args = ""x"")
+foo_R7 <- new_generic(""foo_R7"", ""x"")
 method(foo_R7, text) <- function(x, ...) paste0(x, ""-foo"")
 
 foo_s3 <- function(x, ...) {
@@ -48,7 +48,7 @@ setMethod(""foo_s4"", c(""text""), function(x, ...) paste0(x, ""-foo""))
 # Measure performance of single dispatch
 bench::mark(foo_R7(x), foo_s3(x), foo_s4(x))
 
-bar_R7 <- new_generic(""bar_R7"", dispatch_args = c(""x"", ""y""))
+bar_R7 <- new_generic(""bar_R7"", c(""x"", ""y""))
 method(bar_R7, list(text, number)) <- function(x, y, ...) paste0(x, ""-"", y, ""-bar"")
 
 setGeneric(""bar_s4"", function(x, y, ...) standardGeneric(""bar_s4""))
@@ -96,11 +96,11 @@ bench::press(
     x <- do.call(cls, list(""hi""))
 
     # Define a generic and a method for the last class (best case scenario)
-    foo_R7 <- new_generic(""foo_R7"", dispatch_args = ""x"")
+    foo_R7 <- new_generic(""foo_R7"", ""x"")
     method(foo_R7, cls) <- function(x, ...) paste0(x, ""-foo"")
 
     # Define a generic and a method for the first class (worst case scenario)
-    foo2_R7 <- new_generic(""foo2_R7"", dispatch_args = ""x"")
+    foo2_R7 <- new_generic(""foo2_R7"", ""x"")
     method(foo2_R7, R7_object) <- function(x, ...) paste0(x, ""-foo"")
 
     bench::mark(
@@ -136,11 +136,11 @@ bench::press(
     y <- do.call(cls, list(""ho""))
 
     # Define a generic and a method for the last class (best case scenario)
-    foo_R7 <- new_generic(""foo_R7"", dispatch_args = c(""x"", ""y""))
+    foo_R7 <- new_generic(""foo_R7"", c(""x"", ""y""))
     method(foo_R7, list(cls, cls)) <- function(x, y, ...) paste0(x, y, ""-foo"")
 
     # Define a generic and a method for the first class (worst case scenario)
-    foo2_R7 <- new_generic(""foo2_R7"", dispatch_args = c(""x"", ""y""))
+    foo2_R7 <- new_generic(""foo2_R7"", c(""x"", ""y""))
     method(foo2_R7, list(R7_object, R7_object)) <- function(x, y, ...) paste0(x, y, ""-foo"")
 
     bench::mark("
RConsortium,S7,9bca27e288c4de0fd0544f67cf5afc64a039a7cf,Hadley Wickham,h.wickham@gmail.com,2022-02-14T23:06:23Z,GitHub,noreply@github.com,2022-02-14T23:06:23Z,"Allow R7 classes to be parents of S3 classes (#148)

* s3_class() gains `constructor` and `validator` arguments
* Refactor class_names() to use recursive implementation and un-export (at least for now)
* Rewrite the case study example to favour composition ovoer inheritance. This which makes things simpler and avoids having to think through what the constructor for the annotateded db really should be.
* Revert S4 class registration since the class is now (e.g.) `<R7_object/character>` and `<R7_object/integer>` which is inconsistent.

Fixes #140",NAMESPACE;R/S3.R;R/class-spec.R;R/class.R;R/constructor.R;R/method.R;R/object.R;R/valid.R;R/zzz.R;_pkgdown.yml;man/class_names.Rd;man/s3_class.Rd;src/dispatch.c;tests/testthat/_snaps/S3.md;tests/testthat/_snaps/class-spec.md;tests/testthat/_snaps/constructor.md;tests/testthat/_snaps/object.md;tests/testthat/test-S3.R;tests/testthat/test-class-spec.R;tests/testthat/test-constructor.R;tests/testthat/test-object.R;tests/testthat/test-zzz.R;vignettes/case_studies.Rmd,True,True,True,False,510,162,672,"---FILE: NAMESPACE---
@@ -7,6 +7,7 @@ S3method(print,R7_generic)
 S3method(print,R7_method)
 S3method(print,R7_object)
 S3method(print,R7_union)
+S3method(print,r7_s3_class)
 S3method(str,R7_class)
 S3method(str,R7_object)
 S3method(str,R7_property)
@@ -18,7 +19,6 @@ export(""props<-"")
 export(""r7_data<-"")
 export(R7_object)
 export(as_class)
-export(class_names)
 export(external_methods_register)
 export(method)
 export(method_call)

---FILE: R/S3.R---
@@ -0,0 +1,169 @@
+#' Declare an S3 class
+#'
+#' To use an S3 class with R7, you must explicitly declare it using
+#' `s3_class()` because S3 lacks a formal class definition.
+#'
+#' # Method dispatch, properties, and unions
+#' There are three ways of using S3 with R7 that only require the S3 class
+#' vector:
+#'
+#' * Registering a S3 method for an R7 generic.
+#' * Restricting an R7 property to an S3 class.
+#' * Using an S3 class in an R7 union.
+#'
+#' This is easy, and you can usually include the `s3_class()`
+#' call inline:
+#'
+#' ```R
+#' method(my_generic, s3_class(""factor"")) <- function(x) ""A factor""
+#' new_class(""my_class"", properties = list(types = s3_class(""factor"")))
+#' new_union(""character"", s3_class(""factor""))
+#' ```
+#'
+#' # Extending an S3 class
+#'
+#' Creating an R7 class that extends an S3 class requires more work. You'll
+#' also need to provide a constructor for the S3 class that follows R7
+#' conventions. This means the first argument to the constructor should be
+#' `.data`, and it should be followed by one argument for each attribute used
+#' by the class.
+#'
+#' This can be awkward because base S3 classes are usually heavily wrapped for user
+#' convenience and no low level constructor is available. For example, the
+#' factor class is an integer vector with a character vector of `levels`, but
+#' there's no base R function that takes an integer vector of values and
+#' character vector of levels, verifies that they are consistent, then
+#' creates a factor object.
+#'
+#' You may optionally want to also provide a `validator` function which will
+#' ensure that [validate()] confirms the validity of any R7 classes that build
+#' on this class. Unlike an R7 validator, you are responsible for validating
+#' the types of the attributes.
+#'
+#' The following code shows how you might wrap the base Date class.
+#' A Date is a numeric vector with class `Date` that can be constructed with
+#' `.Date()`.
+#'
+#' ```R
+#' S3_Date <- s3_class(""Date"",
+#'   function(.data) {
+#'     .Date(.data)
+#'   },
+#'   function(object) {
+#'     if (!is.numeric(object)) {
+#'       ""Underlying data must be numeric""
+#'     }
+#'   }
+#' )
+#' ```
+#'
+#' @export
+#' @param class Character vector of S3 classes
+#' @param constructor An optional constructor that can be used to create
+#'   objects of the specified class. This is only needed if you wish to
+#'   have an R7 class inherit from an S3 class. It must be specified in the
+#'   same way as a R7 constructor: the first argument should be `.data`
+#'   (the base type whose attributes will be modified).
+#' @param validator An optional validator used by [validate()] to check that
+#'   the R7 object adheres to the constraints of the S3 class.
+#'
+#'   A validator is a single argument function that takes the object to
+#'   validate and returns `NULL` if the object is valid. If the object is
+#'   invalid, it returns a character vector of problems.
+s3_class <- function(class, constructor = NULL, validator = NULL) {
+  if (!is.character(class)) {
+    stop(""`class` must be a character vector"", call. = FALSE)
+  }
+  if (!is.null(constructor)) {
+    check_constructor(constructor)
+  } else {
+    constructor <- function(.data) {
+      stop(sprintf(""S3 class <%s> doesn't have a constructor"", class[[1]]), call. = FALSE)
+    }
+  }
+
+  structure(
+    list(
+      class = class,
+      constructor = constructor,
+      validator = validator
+    ),
+    class = ""r7_s3_class""
+  )
+}
+
+#' @export
+print.r7_s3_class <- function(x, ...) {
+  cat(
+    ""S3 class <"", paste(x$class, collapse = ""/""), "">\n"",
+    sep = """"
+  )
+  invisible(x)
+}
+
+
+check_constructor <- function(constructor) {
+  arg_names <- names(formals(constructor))
+  if (arg_names[[1]] != "".data"") {
+    stop(""First argument to `constructor` must be .data"", call. = FALSE)
+  }
+  if (""..."" %in% arg_names) {
+    stop(""`constructor` can not use `...`"", call. = FALSE)
+  }
+}
+
+is_s3_class <- function(x) {
+  inherits(x, ""r7_s3_class"")
+}
+
+# -------------------------------------------------------------------------
+# Define a few base examples
+
+s3_factor <- s3_class(""factor"",
+  function(.data, levels) {
+    structure(.data, levels = levels, class = ""factor"")
+  },
+  function(object) {
+    c(
+      if (typeof(object) != ""integer"")
+        ""Underlying data must be an <integer>"",
+      if (!is.character(attr(object, ""levels"")))
+        ""attr(, 'levels') must be a character vector""
+    )
+  }
+)
+
+s3_POSIXct <- s3_class(
+  c(""POSIXct"", ""POSIXt""),
+  function(.data, tz = """") {
+    .POSIXct(.data, tz = tz)
+  },
+  function(object) {
+    c(
+      if (!is.numeric(object))
+        ""Underlying data must be numeric"",
+      if (!is.character(tz) || length(tz) != 1)
+        ""attr(, 'tz') must be a single string""
+    )
+  }
+)
+
+s3_data.frame <- s3_class(""data.frame"",
+  function(.data, row.names = NULL) {
+    if (is.null(row.names)) {
+      list2DF(.data)
+    } else {
+      out <- list2DF(.data, length(row.names))
+      attr(out, ""row.names"") <- row.names
+      out
+    }
+  },
+  function(object) {
+    c(
+      if (!is.list(.data))
+        ""Underlying data must be a <list>"",
+      if (!is.character(row.names) || !is.integer(row.names) || !is.null(row.names))
+        ""attr(, 'rownames') must be a character vector, integer vector, or NULL""
+    )
+  }
+)

---FILE: R/class-spec.R---
@@ -61,7 +61,6 @@ as_S4_class <- function(x, error_base) {
   if (methods::is(x, ""ClassUnionRepresentation"")) {
     subclasses <- Filter(function(y) y@distance == 1, x@subclasses)
     subclasses <- lapply(subclasses, function(x) methods::getClass(x@subClass))
-
     do.call(""new_union"", subclasses)
   } else if (methods::is(x, ""classRepresentation"")) {
     if (x@package == ""methods"" && x@className %in% names(base_classes)) {
@@ -99,22 +98,65 @@ class_type <- function(x) {
   }
 }
 
+class_constructor <- function(.x, ...) {
+  switch(class_type(.x),
+    NULL = function() NULL,
+    s3 = .x$constructor,
+    s4 = function(...) methods::new(.x, ...),
+    r7 = .x,
+    r7_base = .x,
+    r7_union = class_constructor(.x@classes[[1]]),
+  )
+}
+class_construct <- function(.x, ...) {
+  class_constructor(.x)(...)
+}
+
+class_validate <- function(class, object) {
+  validator <- switch(class_type(class),
+    NULL = NULL,
+    s3 = class$validator,
+    s4 = methods::validObject,
+    r7 = class@validator,
+    r7_base = class@validator,
+    r7_union = NULL,
+  )
+
+  if (is.null(validator)) {
+    NULL
+  } else {
+    validator(object)
+  }
+}
+
 class_desc <- function(x) {
   switch(class_type(x),
     NULL = ""<ANY>"",
-    s3 = fmt_classes(x[[1]]),
+    s3 = fmt_classes(x$class[[1]]),
     s4 = fmt_classes(x@className),
     r7 = fmt_classes(x@name),
     r7_base = fmt_classes(x@name),
     r7_union = oxford_or(unlist(lapply(x@classes, class_desc))),
   )
 }
 
+# Return complete vector of class names
+class_names <- function(x) {
+  switch(class_type(x),
+    NULL = NULL,
+    s3 = c(""R7_object"", x$class),
+    s4 = as.character(x@className),
+    r7 = c(x@name, if (prop_exists(x, ""parent"")) class_names(x@parent)),
+    r7_base = c(""R7_object"", x@name),
+    r7_union = unique(unlist(lapply(x@classes, class_names)), fromLast = TRUE)
+  )
+}
+
 # Used when printing method signature to generate executable code
 class_deparse <- function(x) {
   switch(class_type(x),
     NULL = """",
-    s3 = paste0(""s3_class("", paste(encodeString(x, quote = '""'), collapse = "", ""), "")""),
+    s3 = paste0(""s3_class("", paste(encodeString(x$class, quote = '""'), collapse = "", ""), "")""),
     s4 = as.character(x@className),
     r7 = x@name,
     r7_base = encodeString(x@name, quote = '""'),
@@ -128,7 +170,7 @@ class_deparse <- function(x) {
 class_inherits <- function(x, what) {
   switch(class_type(what),
     NULL = TRUE,
-    s3 = !isS4(x) && is_prefix(what, class(x)),
+    s3 = !isS4(x) && is_prefix(what$class, class(x)),
     s4 = isS4(x) && methods::is(x, what),
     r7 = inherits(x, ""R7_object"") && inherits(x, what@name),
     r7_base = what@name %in% .class2(x),
@@ -159,24 +201,6 @@ obj_desc <- function(x) {
   )
 }
 
-#' Declare an S3 class vector
-#'
-#' The S3 class system is informal so doesn't have a way to formally register
-#' a class. This helper allows you to use S3 classes within R7.
-#'
-#' @export
-#' @param class Character vector of S3 classes
-s3_class <- function(class) {
-  if (!is.character(class)) {
-    stop(""`class` must be a character vector"", call. = FALSE)
-  }
-  structure(class, class = ""r7_s3_class"")
-}
-
-is_s3_class <- function(x) {
-  inherits(x, ""r7_s3_class"")
-}
-
 # helpers -----------------------------------------------------------------
 
 fmt_classes <- function(classes, collapse = "", "") {

---FILE: R/class.R---
@@ -120,29 +120,6 @@ new_class <- function(
 
 is_class <- function(x) inherits(x, ""R7_class"")
 
-#' Retrieve all of the class names for a class
-#'
-#' @param object The R7 object to query
-#' @return A character vector of all the class names for a given R7 class.
-#' @export
-class_names <- function(object) {
-  parent <- object
-  classes <- character()
-  while(!is.null(parent)) {
-    if (inherits(parent, ""R7_union"")) {
-      for (class in parent@classes) {
-        classes <- c(classes, class_names(class))
-      }
-    } else if (inherits(parent, ""R7_class"")) {
-      classes <- c(classes, parent@name, ""R7_object"")
-    } else {
-      classes <- c(classes, parent)
-    }
-    parent <- prop_safely(parent, ""parent"")
-  }
-  unique(classes, fromLast = TRUE)
-}
-
 #' @export
 print.R7_class <- function(x, ...) {
   props <- x@properties

---FILE: R/constructor.R---
@@ -1,45 +1,71 @@
 new_constructor <- function(parent, properties) {
-  args <- constructor_args(parent, properties)
-
-  self_args <- as_names(args$self, named = TRUE)
+  arg_info <- constructor_args(parent, properties)
+  self_args <- as_names(arg_info$self, named = TRUE)
 
   if (identical(parent, R7_object)) {
-    parent_call <- NULL
-    env <- asNamespace(""R7"")
-  } else {
-    parent_name <- parent@name
-    parent_args <- as_names(args$parent, named = TRUE)
-    parent_call <- as.call(c(list(as.name(parent_name)), parent_args))
+    return(new_function(
+      args = missing_args(arg_info$self),
+      body = new_call(""new_object"", c(list(NULL), self_args)),
+      env = asNamespace(""R7"")
+    ))
+  }
 
-    env <- new.env(parent = asNamespace(""R7""))
-    env[[parent_name]] <- parent
+  if (is_class(parent)) {
+    parent_name <- parent@name
+    parent_fun <- parent
+    args <- missing_args(union(arg_info$parent, arg_info$self))
+  } else if (is_s3_class(parent)) {
+    parent_name <- paste0(""new_"", parent$class[[1]])
+    parent_fun <- parent$constructor
+    args <- formals(parent$constructor)
+    args[arg_info$self] <- missing_args(arg_info$self)
+  } else {
+    # user facing error in R7_class()
+    stop(""Unsupported `parent` type"", call. = FALSE)
   }
-  call <- as.call(c(list(quote(new_object), parent_call), self_args))
 
-  f <- function() {}
-  formals(f) <- lapply(setNames(, args$constructor), function(i) quote(expr = ))
-  body(f) <- call
-  environment(f) <- env
-  attr(f, ""srcref"") <- NULL
+  parent_args <- as_names(arg_info$parent, named = TRUE)
+  parent_call <- new_call(parent_name, parent_args)
+  body <- new_call(""new_object"", c(parent_call, self_args))
 
-  f
+  env <- new.env(parent = asNamespace(""R7""))
+  env[[parent_name]] <- parent_fun
+
+  new_function(args, body, env)
 }
 
 constructor_args <- function(parent, properties = list()) {
-  parent_args <- names2(formals(parent))
+  parent_args <- names2(formals(class_constructor(parent)))
 
   self_args <- names2(properties)
-  # Remove dynamic arguments
-  self_args <- self_args[vlapply(properties, function(x) is.null(x$getter))]
-  # Remove any parent properties; can't use parent_args() since the constructor
-  # might automatically set some properties.
-  self_args <- setdiff(self_args, names2(parent@properties))
-
-  constructor_args <- union(parent_args, self_args)
+  if (is_class(parent)) {
+    # Remove dynamic arguments
+    self_args <- self_args[vlapply(properties, function(x) is.null(x$getter))]
+    # Remove any parent properties; can't use parent_args() since the constructor
+    # might automatically set some properties.
+    self_args <- setdiff(self_args, names2(parent@properties))
+  }
 
   list(
     parent = parent_args,
-    self = self_args,
-    constructor = constructor_args
+    self = self_args
   )
 }
+
+# helpers -----------------------------------------------------------------
+
+new_function <- function(args, body, env) {
+  f <- function() {}
+  formals(f) <- args
+  body(f) <- body
+  environment(f) <- env
+  attr(f, ""srcref"") <- NULL
+
+  f
+}
+missing_args <- function(names) {
+  lapply(setNames(, names), function(i) quote(expr = ))
+}
+new_call <- function(call, args) {
+  as.call(c(list(as.name(call)), args))
+}

---FILE: R/method.R---
@@ -121,7 +121,7 @@ flatten_signature <- function(signature) {
 }
 
 as_signature <- function(signature) {
-  if (!is.list(signature)) {
+  if (!is.list(signature) || is.object(signature)) {
     signature <- list(signature)
   }
 
@@ -201,7 +201,7 @@ check_method <- function(method, signature, generic) {
 # Class name when registering an R7 method
 r7_class_name <- function(x) {
   switch(class_type(x),
-    s3 = x,
+    s3 = x$class,
     s4 = x@className,
     r7 = x@name,
     r7_base = x@name,

---FILE: R/object.R---
@@ -28,7 +28,7 @@ new_object <- function(.data = NULL, ...) {
   if (!is.null(.data)) {
     object <- .data
   } else {
-    object <- obj_cls@parent@constructor()
+    object <- class_construct(obj_cls@parent)
   }
 
   class(object) <- ""R7_object""
@@ -60,7 +60,7 @@ object_class <- function(object) {
 
 #' @export
 print.R7_object <- function(x, ...) {
-  str(x)
+  str.R7_object(x)
   invisible(x)
 }
 

---FILE: R/valid.R---
@@ -80,8 +80,8 @@ validate <- function(object, properties = TRUE) {
 
   # Next, recursively validate the object
   errors <- character()
-  while(!is.null(class) && is_class(class)) {
-    errors <- c(errors, class@validator(object))
+  while(!is.null(class)) {
+    errors <- c(errors, class_validate(class, object))
     class <- prop_safely(class, ""parent"")
   }
 

---FILE: R/zzz.R---
@@ -13,7 +13,6 @@ R7_object <- new_class(
      out
   }
 )
-methods::setOldClass(class_names(R7_object))
 
 new_base_class <- function(name) {
   default <- switch(name,
@@ -70,7 +69,6 @@ R7_generic <- new_class(
     )
   }
 )
-methods::setOldClass(class_names(R7_generic))
 
 R7_method <- new_class(""R7_method"",
   parent = ""function"",
@@ -79,7 +77,6 @@ R7_method <- new_class(""R7_method"",
     signature = ""list""
   )
 )
-methods::setOldClass(class_names(R7_method))
 
 R7_union <- new_class(
   name = ""R7_union"",

---FILE: _pkgdown.yml---
@@ -27,6 +27,5 @@ reference:
 - title: Introspection
   contents:
   - as_class
-  - class_names
   - object_class
   - method

---FILE: man/class_names.Rd---
@@ -1,17 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/class.R
-\name{class_names}
-\alias{class_names}
-\title{Retrieve all of the class names for a class}
-\usage{
-class_names(object)
-}
-\arguments{
-\item{object}{The R7 object to query}
-}
-\value{
-A character vector of all the class names for a given R7 class.
-}
-\description{
-Retrieve all of the class names for a class
-}

---FILE: man/s3_class.Rd---
@@ -1,15 +1,78 @@
 % Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/class-spec.R
+% Please edit documentation in R/S3.R
 \name{s3_class}
 \alias{s3_class}
-\title{Declare an S3 class vector}
+\title{Declare an S3 class}
 \usage{
-s3_class(class)
+s3_class(class, constructor = NULL, validator = NULL)
 }
 \arguments{
 \item{class}{Character vector of S3 classes}
+
+\item{constructor}{An optional constructor that can be used to create
+objects of the specified class. This is only needed if you wish to
+have an R7 class inherit from an S3 class. It must be specified in the
+same way as a R7 constructor: the first argument should be \code{.data}
+(the base type whose attributes will be modified).}
+
+\item{validator}{An optional validator used by \code{\link[=validate]{validate()}} to check that
+the R7 object adheres to the constraints of the S3 class.
+
+A validator is a single argument function that takes the object to
+validate and returns \code{NULL} if the object is valid. If the object is
+invalid, it returns a character vector of problems.}
 }
 \description{
-The S3 class system is informal so doesn't have a way to formally register
-a class. This helper allows you to use S3 classes within R7.
+To use an S3 class with R7, you must explicitly declare it using
+\code{s3_class()} because S3 lacks a formal class definition.
 }
+\section{Method dispatch, properties, and unions}{
+There are three ways of using S3 with R7 that only require the S3 class
+vector:
+\itemize{
+\item Registering a S3 method for an R7 generic.
+\item Restricting an R7 property to an S3 class.
+\item Using an S3 class in an R7 union.
+}
+
+This is easy, and you can usually include the \code{s3_class()}
+call inline:\if{html}{\out{<div class=""sourceCode R"">}}\preformatted{method(my_generic, s3_class(""factor"")) <- function(x) ""A factor""
+new_class(""my_class"", properties = list(types = s3_class(""factor"")))
+new_union(""character"", s3_class(""factor""))
+}\if{html}{\out{</div>}}
+}
+
+\section{Extending an S3 class}{
+Creating an R7 class that extends an S3 class requires more work. You'll
+also need to provide a constructor for the S3 class that follows R7
+conventions. This means the first argument to the constructor should be
+\code{.data}, and it should be followed by one argument for each attribute used
+by the class.
+
+This can be awkward because base S3 classes are usually heavily wrapped for user
+convenience and no low level constructor is available. For example, the
+factor class is an integer vector with a character vector of \code{levels}, but
+there's no base R function that takes an integer vector of values and
+character vector of levels, verifies that they are consistent, then
+creates a factor object.
+
+You may optionally want to also provide a \code{validator} function which will
+ensure that \code{\link[=validate]{validate()}} confirms the validity of any R7 classes that build
+on this class. Unlike an R7 validator, you are responsible for validating
+the types of the attributes.
+
+The following code shows how you might wrap the base Date class.
+A Date is a numeric vector with class \code{Date} that can be constructed with
+\code{.Date()}.\if{html}{\out{<div class=""sourceCode R"">}}\preformatted{S3_Date <- s3_class(""Date"",
+  function(.data) \{
+    .Date(.data)
+  \},
+  function(object) \{
+    if (!is.numeric(object)) \{
+      ""Underlying data must be numeric""
+    \}
+  \}
+)
+}\if{html}{\out{</div>}}
+}
+

---FILE: src/dispatch.c---
@@ -34,6 +34,18 @@ SEXP method_rec(SEXP table, SEXP signature, R_xlen_t signature_itr, SEXP ignore)
       }
       classes = Rf_getAttrib(classes, parent_sym);
     }
+  } else if (Rf_inherits(classes, ""r7_s3_class"")) {
+    SEXP klasses = VECTOR_ELT(classes, 0);
+    for (R_xlen_t i = 0; i < Rf_xlength(klasses); ++i) {
+      SEXP klass = Rf_install(CHAR(STRING_ELT(klasses, i)));
+      SEXP val = Rf_findVarInFrame(table, klass);
+      if (TYPEOF(val) == ENVSXP) {
+        val = method_rec(val, signature, signature_itr + 1, ignore);
+      }
+      if (TYPEOF(val) == CLOSXP && (ignore == R_NilValue || !should_ignore(val, ignore))) {
+        return val;
+      }
+    }
   } else {
     for (R_xlen_t i = 0; i < Rf_xlength(classes); ++i) {
       SEXP klass = Rf_install(CHAR(STRING_ELT(classes, i)));

---FILE: tests/testthat/_snaps/S3.md---
@@ -0,0 +1,40 @@
+# s3_class has a print method
+
+    Code
+      s3_class(c(""ordered"", ""factor""))
+    Output
+      S3 class <ordered/factor>
+
+# subclasses inherit validator
+
+    Code
+      foo2(""a"")
+    Error <simpleError>
+      <foo2> object is invalid:
+      - Underlying data must be a double
+
+# s3_class() checks its inputs
+
+    Code
+      s3_class(1)
+    Error <simpleError>
+      `class` must be a character vector
+
+---
+
+    Code
+      s3_class(""foo"", function(x) { })
+    Error <simpleError>
+      First argument to `constructor` must be .data
+    Code
+      s3_class(""foo"", function(.data, ...) { })
+    Error <simpleError>
+      `constructor` can not use `...`
+
+# default s3_class constructor errors
+
+    Code
+      class_construct(s3_class(""foo""), 1)
+    Error <simpleError>
+      S3 class <foo> doesn't have a constructor
+

---FILE: tests/testthat/_snaps/class-spec.md---
@@ -13,10 +13,3 @@
     Error <simpleError>
       Can't convert `TRUE` to a valid class. Class specification must be an R7 class object, the result of `s3_class()`, an S4 class object, or a base constructor function, not a <logical>.
 
-# s3_class() checks its inputs
-
-    Code
-      s3_class(1)
-    Error <simpleError>
-      `class` must be a character vector
-

---FILE: tests/testthat/_snaps/constructor.md---
@@ -27,3 +27,19 @@
       new_object(foo2(.data = .data))
       <environment: 0x0>
 
+# can generate constructors for S3 classes
+
+    Code
+      new_constructor(s3_factor, list())
+    Output
+      function (.data, levels) 
+      new_object(new_factor(.data = .data, levels = levels))
+      <environment: 0x0>
+    Code
+      new_constructor(s3_factor, as_properties(list(x = ""numeric"", y = ""numeric"")))
+    Output
+      function (.data, levels, x, y) 
+      new_object(new_factor(.data = .data, levels = levels), x = x, 
+          y = y)
+      <environment: 0x0>
+

---FILE: tests/testthat/_snaps/object.md---
@@ -40,8 +40,8 @@
       str(list(text(""b""), number(50)))
     Output
       List of 2
-       $ : <text/character/R7_object> chr ""b""
-       $ : <number/double/R7_object> num 50
+       $ : <text/R7_object/character> chr ""b""
+       $ : <number/R7_object/double> num 50
 
 # print()/str() nests properties correctly
 

---FILE: tests/testthat/test-S3.R---
@@ -0,0 +1,35 @@
+test_that(""s3_class has a print method"", {
+  expect_snapshot(s3_class(c(""ordered"", ""factor"")))
+})
+
+test_that(""can construct objects that extend S3 classes"", {
+  foo <- s3_class(""foo"", function(.data) structure(list(), class = ""foo""))
+  foo2 <- new_class(""foo2"", foo)
+  expect_s3_class(foo2(), ""foo"")
+})
+
+test_that(""subclasses inherit validator"", {
+  foo <- s3_class(""foo"",
+    function(.data) structure(.data, class = ""foo""),
+    function(x) if (!is.double(x)) ""Underlying data must be a double""
+  )
+  foo2 <- new_class(""foo2"", foo)
+
+  expect_snapshot(error = TRUE, foo2(""a""))
+})
+
+
+test_that(""s3_class() checks its inputs"", {
+  expect_snapshot(s3_class(1), error = TRUE)
+
+  expect_snapshot(error = TRUE, {
+    s3_class(""foo"", function(x) {})
+    s3_class(""foo"", function(.data, ...) {})
+  })
+})
+
+
+test_that(""default s3_class constructor errors"", {
+  # constructor errors if needed
+  expect_snapshot(class_construct(s3_class(""foo""), 1), error = TRUE)
+})

---FILE: tests/testthat/test-class-spec.R---
@@ -3,6 +3,8 @@ test_that(""can work with R7 classes"", {
   expect_equal(as_class(klass), klass)
 
   expect_equal(class_type(klass), ""r7"")
+  expect_equal(class_names(klass), c(""klass"", ""R7_object""))
+  expect_equal(class_construct(klass), klass())
   expect_equal(class_desc(klass), ""<klass>"")
   expect_equal(class_deparse(klass), ""klass"")
 
@@ -17,6 +19,8 @@ test_that(""can work with unions"", {
   expect_equal(as_class(klass), klass)
 
   expect_equal(class_type(klass), ""r7_union"")
+  expect_equal(class_names(klass), c(""text"", ""character"", ""number"", ""R7_object"", ""double""))
+  expect_equal(class_construct(klass), text())
   expect_equal(class_desc(klass), ""<text> or <number>"")
   expect_equal(class_deparse(klass), ""new_union(text, number)"")
 
@@ -30,6 +34,8 @@ test_that(""handles NULL"", {
   expect_equal(as_class(NULL), NULL)
 
   expect_equal(class_type(NULL), ""NULL"")
+  expect_equal(class_names(NULL), NULL)
+  expect_equal(class_construct(NULL), NULL)
   expect_equal(class_desc(NULL), ""<ANY>"")
   expect_equal(class_deparse(NULL), """")
 
@@ -42,6 +48,8 @@ test_that(""can work with S4 classes"", {
   methods::setClass(""Range"", slots = c(start = ""numeric"", end = ""numeric""))
   klass <- methods::getClass(""Range"")
   expect_equal(class_type(klass), ""s4"")
+  expect_equal(class_names(klass), ""Range"")
+  expect_s4_class(class_construct(klass, start = 1, end = 2), ""Range"")
   expect_equal(class_desc(klass), ""<Range>"")
   expect_equal(class_deparse(klass), ""Range"")
 
@@ -69,10 +77,12 @@ test_that(""converts S4 unions to R7 unions"", {
 })
 
 test_that(""can work with simple S3 classes"", {
-  klass <- s3_class(""data.frame"")
+  klass <- s3_data.frame
   expect_equal(as_class(klass), klass)
 
   expect_equal(class_type(klass), ""s3"")
+  expect_equal(class_names(klass), c(""R7_object"", ""data.frame""))
+  expect_equal(class_construct(klass, list(x = 1)), data.frame(x = 1))
   expect_equal(class_desc(klass), ""<data.frame>"")
   expect_equal(class_deparse(klass), 's3_class(""data.frame"")')
 
@@ -83,11 +93,16 @@ test_that(""can work with simple S3 classes"", {
 })
 
 test_that(""can work with compound s3 classes"", {
-  klass <- s3_class(c(""ordered"", ""factor""))
+  klass <- s3_class(
+    class = c(""ordered"", ""factor""),
+    constructor = function(.data = numeric(), levels) ordered(.data, levels)
+  )
   expect_equal(as_class(klass), klass)
 
   expect_equal(class_type(klass), ""s3"")
+  expect_equal(class_names(klass), c(""R7_object"", ""ordered"", ""factor""))
   expect_equal(class_desc(klass), ""<ordered>"")
+  expect_equal(class_construct(klass), ordered(numeric()))
   expect_equal(class_deparse(klass), 's3_class(""ordered"", ""factor"")')
 
   obj <- ordered(integer())
@@ -104,7 +119,9 @@ test_that(""can work with base types"", {
 
   klass <- as_class(""character"")
   expect_equal(class_type(klass), ""r7_base"")
+  expect_equal(class_names(klass), c(""R7_object"", ""character""))
   expect_equal(class_desc(klass), ""<character>"")
+  expect_equal(class_construct(klass, ""x""), base_classes$character(""x""))
   expect_equal(class_deparse(klass), '""character""')
 
   obj <- ""x""
@@ -140,8 +157,3 @@ test_that(""as_class gives informative errors"", {
     as_class(TRUE)
   })
 })
-
-
-test_that(""s3_class() checks its inputs"", {
-  expect_snapshot(s3_class(1), error = TRUE)
-})

---FILE: tests/testthat/test-constructor.R---
@@ -1,22 +1,24 @@
 test_that(""generates correct arguments from parent + properties"",  {
   # No arguments
   args <- constructor_args(R7_object)
-  expect_equal(args$constructor, character())
+  expect_equal(args$self, character())
+  expect_equal(args$parent, character())
 
   # Includes properties
   args <- constructor_args(R7_object, as_properties(list(x = ""numeric"")))
-  expect_equal(args$constructor, ""x"")
+  expect_equal(args$self, ""x"")
+  expect_equal(args$parent, character())
 
   # unless they're dynamic
   args <- constructor_args(R7_object,
     as_properties(list(new_property(""x"", getter = function(x) 10)))
   )
-  expect_equal(args$constructor, character())
+  expect_equal(args$self, character())
+  expect_equal(args$parent, character())
 
   # Includes parent properties
   foo <- new_class(""foo"", properties = list(x = ""numeric""))
   args <- constructor_args(foo, as_properties(list(y = ""numeric"")))
-  expect_equal(args$constructor, c(""x"", ""y""))
   expect_equal(args$self, ""y"")
   expect_equal(args$parent, ""x"")
 
@@ -26,7 +28,6 @@ test_that(""generates correct arguments from parent + properties"",  {
     constructor = function() new_object(x = 1)
   )
   args <- constructor_args(foo, as_properties(list(y = ""numeric"")))
-  expect_equal(args$constructor, ""y"")
   expect_equal(args$self, ""y"")
   expect_equal(args$parent, character())
 })
@@ -43,3 +44,10 @@ test_that(""generates meaningful constructors"", {
     new_constructor(foo2, list())
   }, transform = scrub_environment)
 })
+
+test_that(""can generate constructors for S3 classes"", {
+  expect_snapshot({
+    new_constructor(s3_factor, list())
+    new_constructor(s3_factor, as_properties(list(x = ""numeric"", y = ""numeric"")))
+  }, transform = scrub_environment)
+})

---FILE: tests/testthat/test-object.R---
@@ -107,3 +107,11 @@ test_that(""object_class returns the class for S4 types"", {
   obj <- foo2(""hi"")
   expect_equal(object_class(obj), methods::extends(class(obj)))
 })
+
+test_that(""can inherit from an S3 class"", {
+  ordered2 <- new_class(""ordered2"", parent = s3_factor)
+  x <- ordered2(c(1L, 2L, 1L), letters[1:3])
+  expect_equal(class(x), c(""ordered2"", ""R7_object"", ""factor""))
+  expect_equal(prop_names(x), character())
+  expect_error(x@levels, ""Can't find property"")
+})

---FILE: tests/testthat/test-zzz.R---
@@ -7,28 +7,24 @@ test_that(""has useful print method"", {
 })
 
 test_that(""can construct from base types"", {
-  expect_equal(
-    class_names(new_union(character)),
-    c(""character"", ""R7_object"")
-  )
-  expect_equal(
-    class_names(new_union(character, integer)),
-    c(""character"", ""integer"",""R7_object"")
-  )
+  u1 <- new_union(character)
+  expect_s3_class(u1, ""R7_union"")
+  expect_equal(u1@classes, list(base_classes$character))
+
+  u2 <- new_union(character, integer)
+  expect_s3_class(u2, ""R7_union"")
+  expect_equal(u2@classes, list(base_classes$character, base_classes$integer))
 })
 
 test_that(""can construct from unions"", {
   u1 <- new_union(character)
   u2 <- new_union(integer)
 
-  expect_equal(
-    class_names(new_union(u1, u2)),
-    c(""character"", ""integer"", ""R7_object"")
-  )
-  expect_equal(
-    class_names(new_union(u1, integer)),
-    c(""character"", ""integer"", ""R7_object"")
-  )
+  u3 <- new_union(u1, u2)
+  expect_s3_class(u3, ""R7_union"")
+  expect_equal(u3@classes, list(base_classes$character, base_classes$integer))
+
+  expect_equal(new_union(u1, integer), u3)
 })
 
 test_that(""base unions print as expected"", {
@@ -38,20 +34,13 @@ test_that(""base unions print as expected"", {
 })
 
 test_that(""can construct from S3 and S4 classes"", {
-  factor <- s3_class(""factor"")
   s4_union <- methods::setClass(""s4_union"")
-  u <- new_union(factor, s4_union)
-  expect_equal(u@classes, list(factor, getClass(""s4_union"")))
+  u <- new_union(s3_factor, s4_union)
+  expect_equal(u@classes, list(s3_factor, getClass(""s4_union"")))
 })
 
 test_that(""base classes types check their data"", {
   expect_snapshot(error = TRUE, {
     base_classes$integer(TRUE)
   })
 })
-
-test_that(""register S4 classes for key components"", {
-  expect_s4_class(getClass(""R7_object""), ""classRepresentation"")
-  expect_s4_class(getClass(""R7_method""), ""classRepresentation"")
-  expect_s4_class(getClass(""R7_generic""), ""classRepresentation"")
-})

---FILE: vignettes/case_studies.Rmd---
@@ -106,20 +106,17 @@ Here is the definition of the class.
 tbl_df <- s3_class(c(""tbl_df"", ""tbl"", ""data.frame""))
 
 annotated_df <- new_class(""annotated_df"",
-  parent = tbl_df,
   properties = list(
+    data = tbl_df,
     rows = tbl_df,
     columns = tbl_df
-    ),
+  ),
   validator = function(object) {
-    if (nrow(object) != nrow(object@rows)) {
+    if (nrow(object@data) != nrow(object@rows)) {
       ""`nrow(<annotated_df>@rows)` must be equal to `nrow(<annotated_df>)`""
-    } else if (ncol(object) != nrow(object@columns)) {
+    } else if (ncol(object@data) != nrow(object@columns)) {
       ""`nrow(<annotated_df>@columns)` must be equal to `ncol(<annotated_df>)`""
     }
-  },
-  constructor = function(data, rows, columns) {
-    new_object(data, rows = rows, columns = columns)
   }
 )
 ```
@@ -168,7 +165,7 @@ We can then create an instance using the constructor function.
 
 ```{r}
 obj <- annotated_df(mt, row_info, col_info)
-obj
+obj@data
 
 obj@rows
 
@@ -182,7 +179,7 @@ The subsets the individual components appropriately and then returns a new `anno
 subset_R7 <- new_generic(""R7_subset"", dispatch_args = c(""object"", ""row"", ""column""))
 
 method(subset_R7, list(annotated_df, ""integer"", ""integer"")) <- function(object, row, column, ...) {
-  data <- r7_data(object)[row, column]
+  data <- object@data[row, column]
   rows <- object@rows[row, ]
   columns <-  object@columns[column, ]
   annotated_df(data, rows, columns)
@@ -194,7 +191,7 @@ When we subset using this function we can see the consistency is retained for ou
 ```{r}
 obj2 <- subset_R7(obj, 1:3, 1:5)
 
-obj2
+obj2@data
 
 obj2@rows
 "
RConsortium,S7,ee4c8749e1c7f7c8280b588b4056c488bf22aa2c,Hadley Wickham,h.wickham@gmail.com,2022-02-13T14:53:31Z,Hadley Wickham,h.wickham@gmail.com,2022-02-13T14:53:31Z,"Delete TODO vigentte

All undone items moved to issues",vignettes/TODO.Rmd,True,False,True,False,0,88,88,"---FILE: vignettes/TODO.Rmd---
@@ -1,88 +0,0 @@
----
-title: ""TODO""
-output: rmarkdown::html_vignette
-vignette: >
-  %\VignetteIndexEntry{TODO}
-  %\VignetteEngine{knitr::rmarkdown}
-  %\VignetteEncoding{UTF-8}
----
-
-```{r, include = FALSE}
-knitr::opts_chunk$set(
-  collapse = TRUE,
-  comment = ""#>""
-)
-```
-
-- Objects
-  - [x] - A class object attribute, a reference to the class object, and retrieved with `object_class()`.
-  - [x] - For S3 compatibility, a class attribute, a character vector of class names.
-  - [x] - Additional attributes storing properties defined by the class, accessible with `@/property()`.
-- Classes
-  - [x] - R7 classes are first class objects with the following
-    - [x] - `name`, a human-meaningful descriptor for the class.
-    - [x] - `parent`, the class object of the parent class.
-    - [x] - A constructor, an user-facing function used to create new objects of this class. It always ends with a call to `new_object()` to initialize the class.
-    - [x] - A validator, a function that takes the object and returns NULL if the object is valid, otherwise a character vector of error messages.
-    - [x] - properties, a list of property objects
-- Initialization
-  - [x] - The constructor uses `new_object()` to initialize a new object, this
-    - [x] - Inspects the enclosing scope to find the ""current"" class.
-    - [ ] - Creates the prototype, by either by calling the parent constructor or by creating a base type and adding class and `object_class()` attributes to it.
-    - [x] - Validates properties then adds to prototype.
-    - [x] - Validates the complete object.
-- Shortcuts
-  - [ ] - any argument that takes a class object can instead take the name of a class object as a string
-  - [x] - instead of providing a list of property objects, you can instead provide a named character vector.
-- Validation
-  - [x] - valid_eventually
-  - [x] - valid_implicitly
-- Unions
-  - [x] - Used in properties to allow a property to be one of a set of classes
-  - [x] - In method dispatch as a convenience for defining a method for multiple classes
-- Properties
-  - [x] - Accessed using `property()` / `property<-`
-  - [x] - Accessed using `@` / `@<-`
-  - [x] - A name, used to label output
-  - [x] - A optional class or union
-  - [x] - An optional accessor functions, both getter and setters
-  - [x] - Properties are created with `new_property()`
-  - [ ] - If a properties define a getter it should not be writable unless there is an explicit setter.
-- Generics
-  - [x] - It knows its name and the names of the arguments in its signature
-  - [x] - Calling `new_generic()` defines a new generic
-  - [ ] - By convention, any argument that takes a generic function, can instead take the name of a generic function supplied as a string
-- Methods
-  - Registration
-    - [x] - Methods are defined by calling method<-(generic, signature, method):
-    - [x] - generic is a generic function.
-    - [x] - signature is a
-      - [x] - single class object
-      - [x] - a class union
-      - [x] - list of class objects/unions
-      - [x] - a character vector.
-    - [x] - method is a compatible function
-    - [x] - `new_method` is designed to work at run-time
-      - [x] - `new_method` should optionally take a package version, so the method is only registered if the package is newer than the version.
-    - [ ] - Can define methods where one of the arguments is missing
-    - [ ] - Can define methods where one of the arguments has any type
-  - Dispatch
-    - [x] - Dispatch is nested, meaning that if there are multiple arguments in the generic signature, it will dispatch on the first argument, then the second.
-    - [x] - A `plot()` generic dispatching on `x`, e.g. ` plot <- function(x) { method(plot, object_class(x))(x) }`
-    - [x] - A `publish()` that publishes an object `x` to a destination `y`, dispatching on both arguments, e.g. `publish <- function(x, y, ...) { method(publish, list(object_class(x), object_class(y)))(x, y, ...) }`
-    - [x] - `...` is not used for dispatch
-    - [x] - R7 generics can dispatch with base type objects
-    - [x] - R7 generics can dispatch with S3 objects
-    - [x] - R7 generics can dispatch with S4 objects
-    - [x] - `next_method()` can dispatch on multiple arguments, avoiding methods that have already been called.
-    - [x] - Generics forward promises to methods, so methods can use non-standard evaluation.
-- Compatibility
-  - S3
-    - [x] - Since the class attribute has the same semantics as S3, S3 dispatch should be fully compatible.
-    - [x] - The new generics should also be able to handle legacy S3 objects.
-    - [x] - `method()` falls back to single argument S3 dispatch if the R7 dispatch fails.
-    - [ ] - `method()` uses S3 group generics as well
-  - S4
-    - [x] - Since the new generics will fallback to S3 dispatch, they should support S4 objects just as S3 generics support them now.
-- Documentation
-  - [ ] - Generate index pages that list the methods for a generic or the methods with a particular class in their signature"
RConsortium,S7,461e8c32a7ece0a7c5ef02b1b25b069ff18a2397,Hadley Wickham,h.wickham@gmail.com,2022-02-12T21:36:21Z,GitHub,noreply@github.com,2022-02-12T21:36:21Z,"Refactor as_generic() & add full S4 support (#165)

* Specifically handle S4 generics
* Check S3 generics
* Register R7 method with S4 generic

Fixes #160",R/class-spec.R;R/generic-spec.R;R/generic.R;R/method.R;man/method-set.Rd;tests/testthat/_snaps/generic-spec.md;tests/testthat/test-class-spec.R;tests/testthat/test-generic-spec.R;tests/testthat/test-generic.R;tests/testthat/test-method.R;tests/testthat/test-object.R,False,True,True,False,192,93,285,"---FILE: R/class-spec.R---
@@ -77,20 +77,22 @@ as_S4_class <- function(x, error_base) {
   }
 }
 
+is_s4_class <- function(x) inherits(x, ""classRepresentation"")
+is_base_class <- function(x) is_class(x) && utils::hasName(base_classes, x@name)
+
+
 class_type <- function(x) {
-  if (is_class(x)) {
-    if (utils::hasName(base_classes, x@name)) {
-      ""r7_base""
-    } else {
-      ""r7""
-    }
+  if (is.null(x)) {
+    ""NULL""
+  } else if (is_base_class(x)) {
+    ""r7_base""
+  } else if (is_class(x)) {
+    ""r7""
   } else if (is_union(x)) {
     ""r7_union""
-  } else if (is.null(x)) {
-    ""NULL""
   } else if (is_s3_class(x)) {
     ""s3""
-  } else if (isS4(x)) {
+  } else if (is_s4_class(x)) {
     ""s4""
   } else {
     stop(""`x` is not standard R7 class"", call. = FALSE)

---FILE: R/generic-spec.R---
@@ -0,0 +1,73 @@
+as_generic <- function(x) {
+  if (inherits(x, ""R7_generic"") || is_external_generic(x)) {
+    x
+  } else if (inherits(x, ""genericFunction"")) {
+    x
+  } else if (is.function(x)) {
+    as_S3_generic(x)
+  } else {
+    msg <- sprintf(""`generic` must be a function, not a %s"", obj_desc(x))
+    stop(msg, call. = FALSE)
+  }
+}
+
+as_S3_generic <- function(x) {
+  use_method <- find_call(body(x), quote(UseMethod))
+  if (!is.null(use_method)) {
+    return(S3_generic(x, as.character(use_method[[2]])))
+  } else {
+    name <- find_generic_name(x)
+    if (!is.na(name) && is_internal_generic(name)) {
+      return(S3_generic(x, name))
+    }
+  }
+
+  stop(""`generic` is a function, but not an S3 generic function"", call. = FALSE)
+}
+
+S3_generic <- function(generic, name) {
+  structure(list(generic = generic, name = name), class = ""R7_S3_generic"")
+}
+
+is_s3_generic <- function(x) inherits(x, ""R7_S3_generic"")
+
+
+# Internal generics -------------------------------------------------------
+
+find_generic_name <- function(generic) {
+  env <- baseenv()
+  for (nme in names(env)) {
+    if (identical(generic, env[[nme]])) {
+      return(nme)
+    }
+  }
+
+  NA
+}
+
+is_internal_generic <- function(x) {
+  x %in% internal_generics()
+}
+
+internal_generics <- function() {
+  group <- unlist(group_generics(), use.names = FALSE)
+  primitive <- .S3PrimitiveGenerics
+
+  # Extracted from ?""internal generic""
+  internal <- c(""["", ""[["", ""$"", ""[<-"", ""[[<-"", ""$<-"", ""unlist"",
+    ""cbind"", ""rbind"", ""as.vector"")
+
+  c(group, primitive, internal)
+}
+
+group_generics <- function() {
+  # S3 group generics can be defined by combining S4 group generics
+  groups <- list(
+    Ops = c(""Arith"", ""Compare"", ""Logic""),
+    Math = c(""Math"", ""Math2""),
+    Summary = ""Summary"",
+    Complex = ""Complex""
+  )
+
+  lapply(groups, function(x) unlist(lapply(x, methods::getGroupMembers)))
+}

---FILE: R/generic.R---
@@ -153,29 +153,25 @@ check_generic <- function(fun) {
     stop(""`fun` must be a function"", call. = FALSE)
   }
 
-  if (!has_call(body(fun), quote(method_call))) {
+  method_call <- find_call(body(fun), quote(method_call))
+  if (is.null(method_call)) {
     stop(""`fun` must contain a call to `method_call()`"", call. = FALSE)
   }
 }
-has_call <- function(x, name) {
-  if (!is.call(x)) {
-    return(FALSE)
-  }
-
-  if (identical(x[[1]], name)) {
-    return(TRUE)
-  }
-
-  if (length(x) == 1) {
-    return(FALSE)
-  }
-
-  for (i in seq(2, length(x))) {
-    if (has_call(x[[i]], name)) {
-      return(TRUE)
+find_call <- function(x, name) {
+  if (is.call(x)) {
+    if (identical(x[[1]], name)) {
+      return(x)
+    } else if (length(x) > 1) {
+      for (i in seq(2, length(x))) {
+        call <- find_call(x[[i]], name)
+        if (!is.null(call)) {
+          return(call)
+        }
+      }
     }
   }
-  FALSE
+  NULL
 }
 
 

---FILE: R/method.R---
@@ -8,7 +8,7 @@
 #' The goal is for `method<-` to be the single function you need when working
 #' with R7 generics or R7 classes. This means that as well as registering
 #' methods for R7 classes on R7 generics, you can also register methods for
-#' R7 classes on S3 or S4 generics, and S3 or S4 classes for R7 generics.
+#' R7 classes on S3 or S4 generics, and S3 or S4 classes on R7 generics.
 #' But this is not a general method registration function: at least one of
 #' `generic` and `signature` needs to be from R7.
 #'
@@ -45,26 +45,22 @@
 #' # Using a generic calls the methods automatically
 #' bizarro(head(mtcars))
 `method<-` <- function(generic, signature, value) {
-  package <- packageName(parent.frame())
-  register_method(generic, signature, value, package = package)
+
+  register_method(generic, signature, value, env = parent.frame())
   invisible(generic)
 }
 
-register_method <- function(generic, signature, method, package = NULL) {
+register_method <- function(generic, signature, method, env = parent.frame()) {
+  package <- packageName(env)
   signature <- as_signature(signature)
   generic <- as_generic(generic)
 
   if (is_external_generic(generic)) {
-    if (!is.null(package)) {
-      # method registration within package, so add to lazy registry
-      external_methods_add(package, generic, signature, method)
-    } else {
-      # otherwise find the generic and register
-      generic <- getFromNamespace(generic$name, asNamespace(generic$package))
-      register_method(generic, signature, method)
-    }
+    register_external_method(generic, signature, method, package)
   } else if (is_s3_generic(generic)) {
     register_s3_method(generic, signature, method)
+  } else if (inherits(generic, ""genericFunction"")) {
+    register_s4_method(generic, signature, method, env)
   } else {
     check_method(method, signature, generic)
     register_r7_method(generic, signature, method)
@@ -73,18 +69,27 @@ register_method <- function(generic, signature, method, package = NULL) {
   invisible()
 }
 
-register_s3_method <- function(generic, signature, method) {
-  generic_name <- attr(generic, ""name"")
+register_external_method <- function(generic, signature, method, package = NULL) {
+  if (!is.null(package)) {
+    # method registration within package, so add to lazy registry
+    external_methods_add(package, generic, signature, method)
+  } else {
+    # otherwise find the generic and register
+    generic <- getFromNamespace(generic$name, asNamespace(generic$package))
+    register_method(generic, signature, method)
+  }
+}
 
+register_s3_method <- function(generic, signature, method) {
   if (length(signature) != 1 || class_type(signature[[1]]) != ""r7"") {
     msg <- sprintf(
       ""When registering methods for S3 generic %s(), signature be a single R7 class"",
-      generic_name
+      generic$name
     )
     stop(msg, call. = FALSE)
   }
   class <- signature[[1]]@name
-  registerS3method(generic_name, class, method, envir = parent.frame())
+  registerS3method(generic$name, class, method, envir = parent.frame())
 }
 
 register_r7_method <- function(generic, signature, method) {
@@ -115,34 +120,6 @@ flatten_signature <- function(signature) {
   lapply(rows, function(row) Map(""[["", signature, row))
 }
 
-as_generic <- function(x) {
-  if (inherits(x, ""R7_generic"") || is_external_generic(x)) {
-    return(x)
-  }
-
-  if (!is.function(x)) {
-    msg <- sprintf(""`generic` must be a function, not a %s"", obj_desc(x))
-    stop(msg, call. = FALSE)
-  }
-
-  # For now, assume that it's an S3 generic
-  attr(x, ""name"") <- find_generic_name(x)
-  class(x) <- ""R7_S3_generic""
-  x
-}
-is_s3_generic <- function(x) inherits(x, ""R7_S3_generic"")
-
-find_generic_name <- function(generic) {
-  env <- environment(generic) %||% baseenv()
-  for (nme in names(env)) {
-    if (identical(generic, env[[nme]])) {
-      return(nme)
-    }
-  }
-
-  stop(""Can't find name of S3 `generic`"", call. = FALSE)
-}
-
 as_signature <- function(signature) {
   if (!is.list(signature)) {
     signature <- list(signature)
@@ -232,6 +209,34 @@ r7_class_name <- function(x) {
   )
 }
 
+register_s4_method <- function(generic, signature, method, env = parent.frame()) {
+  s4_env <- topenv(env)
+
+  s4_signature <- lapply(signature, s4_class, s4_env = s4_env)
+  methods::setMethod(generic, s4_signature, method, where = s4_env)
+
+}
+
+s4_class <- function(x, s4_env) {
+  if (is_base_class(x)) {
+    x@name
+  } else if (is_s4_class(x)) {
+    x
+  } else if (is_class(x) || is_s3_class(x)) {
+    class <- class_names(x)
+    methods::setOldClass(class, where = s4_env)
+    methods::getClass(class)
+  }
+}
+S4_env <- function() {
+  if (identical(Sys.getenv(""TESTTHAT""), ""true"")) {
+    S4_test_env
+  } else {
+    topenv(parent.frame(2))
+  }
+}
+S4_test_env <- new.env(parent = emptyenv())
+
 #' @export
 print.R7_method <- function(x, ...) {
   signature <- method_signature(x@generic, x@signature)

---FILE: man/method-set.Rd---
@@ -39,7 +39,7 @@ signatures by registering methods with \verb{method<-}
 The goal is for \verb{method<-} to be the single function you need when working
 with R7 generics or R7 classes. This means that as well as registering
 methods for R7 classes on R7 generics, you can also register methods for
-R7 classes on S3 or S4 generics, and S3 or S4 classes for R7 generics.
+R7 classes on S3 or S4 generics, and S3 or S4 classes on R7 generics.
 But this is not a general method registration function: at least one of
 \code{generic} and \code{signature} needs to be from R7.
 }

---FILE: tests/testthat/_snaps/generic-spec.md---
@@ -0,0 +1,14 @@
+# can standardise generics
+
+    Code
+      as_generic(function() { })
+    Error <simpleError>
+      `generic` is a function, but not an S3 generic function
+
+---
+
+    Code
+      as_generic(1)
+    Error <simpleError>
+      `generic` must be a function, not a <double>
+

---FILE: tests/testthat/test-class-spec.R---
@@ -38,18 +38,6 @@ test_that(""handles NULL"", {
   expect_equal(class_inherits(""x"", NULL), TRUE)
 })
 
-test_that(""can work with S4 constructors"", {
-  klass <- methods::setClass(""Range"", slots = c(start = ""numeric"", end = ""numeric""))
-  expect_equal(class_type(klass), ""s4"")
-  expect_equal(class_desc(klass), ""<Range>"")
-  expect_equal(class_deparse(klass), ""Range"")
-
-  obj <- klass(start = 1, end = 1)
-  expect_equal(obj_type(obj), ""s4"")
-  expect_equal(obj_desc(obj), ""<Range>"")
-  expect_equal(class_inherits(obj, klass), TRUE)
-})
-
 test_that(""can work with S4 classes"", {
   methods::setClass(""Range"", slots = c(start = ""numeric"", end = ""numeric""))
   klass <- methods::getClass(""Range"")

---FILE: tests/testthat/test-generic-spec.R---
@@ -0,0 +1,13 @@
+test_that(""can standardise generics"", {
+  foo_R7 <- new_generic(""foo"", dispatch_args = ""x"")
+  methods::setGeneric(""foo_S4"", function(x) {})
+
+  expect_equal(as_generic(foo_R7), foo_R7)
+  expect_equal(as_generic(foo_S4), foo_S4)
+
+  expect_equal(as_generic(sum), S3_generic(sum, ""sum""))
+  expect_equal(as_generic(mean), S3_generic(mean, ""mean""))
+
+  expect_snapshot(as_generic(function() {}), error = TRUE)
+  expect_snapshot(as_generic(1), error = TRUE)
+})

---FILE: tests/testthat/test-generic.R---
@@ -76,10 +76,10 @@ test_that(""check_generic produces informative errors"", {
 })
 
 test_that(""has_fun handles expected cases"", {
-  expect_false(has_call(1, quote(x)))
-  expect_false(has_call(quote(f()), quote(x)))
-  expect_false(has_call(quote(f(a, b, c)), quote(x)))
+  expect_equal(find_call(1, quote(x)), NULL)
+  expect_equal(find_call(quote(f()), quote(x)), NULL)
+  expect_equal(find_call(quote(f(a, b, c)), quote(x)), NULL)
 
-  expect_true(has_call(quote(x()), quote(x)))
-  expect_true(has_call(quote(y(x())), quote(x)))
+  expect_equal(find_call(quote(x(1)), quote(x)), quote(x(1)))
+  expect_equal(find_call(quote(y(x(1))), quote(x)), quote(x(1)))
 })

---FILE: tests/testthat/test-method.R---
@@ -22,7 +22,7 @@ describe(""method registration"", {
     on.exit(external_methods_reset(""R7""), add = TRUE)
 
     foo <- new_external_generic(""foo"", ""bar"")
-    register_method(foo, ""character"", function(x, ...) ""bar"", package = ""R7"")
+    register_external_method(foo, ""character"", function(x, ...) ""bar"", package = ""R7"")
     expect_length(external_methods_get(""R7""), 1)
 
     # and doesn't modify generic
@@ -32,7 +32,7 @@ describe(""method registration"", {
   it(""can register method for external generic during development"", {
     bar <- new_class(""bar"")
     base_sum <- new_external_generic(""base"", ""sum"")
-    register_method(base_sum, bar, function(x, ...) ""bar"", package = NULL)
+    register_external_method(base_sum, bar, function(x, ...) ""bar"", package = NULL)
     expect_equal(sum(bar()), ""bar"")
   })
 
@@ -53,6 +53,14 @@ describe(""method registration"", {
     })
   })
 
+  it(""can register R7 method for S4 generic"", {
+    methods::setGeneric(""bar"", function(x) standardGeneric(""bar""))
+    foo <- new_class(""foo"")
+    method(bar, foo) <- function(x) ""foo""
+
+    expect_equal(bar(foo()), ""foo"")
+  })
+
   it(""checks argument types"", {
     foo <- new_generic(""foo"", dispatch_args = ""x"")
     expect_snapshot(error = TRUE, {

---FILE: tests/testthat/test-object.R---
@@ -103,7 +103,7 @@ test_that(""object_class returns class for S3 types"", {
 })
 
 test_that(""object_class returns the class for S4 types"", {
-  foo <- methods::setClass(""foo"", representation = ""character"")
-  obj <- foo(""hi"")
+  foo2 <- methods::setClass(""foo2"", representation = ""character"")
+  obj <- foo2(""hi"")
   expect_equal(object_class(obj), methods::extends(class(obj)))
 })"
RConsortium,S7,731d81a6e030a008a5c8ea07accea52694d11298,Hadley Wickham,h.wickham@gmail.com,2022-02-11T22:43:52Z,Hadley Wickham,h.wickham@gmail.com,2022-02-11T22:43:52Z,"Register key R7 types with S4

Fixes #70",R/zzz.R;tests/testthat/test-zzz.R,False,True,True,False,9,0,9,"---FILE: R/zzz.R---
@@ -11,6 +11,7 @@ R7_object <- new_class(
      out
   }
 )
+methods::setOldClass(class_names(R7_object))
 
 new_base_class <- function(name) {
   default <- switch(name,
@@ -67,6 +68,7 @@ R7_generic <- new_class(
     )
   }
 )
+methods::setOldClass(class_names(R7_generic))
 
 R7_method <- new_class(""R7_method"",
   parent = ""function"",
@@ -75,6 +77,7 @@ R7_method <- new_class(""R7_method"",
     signature = ""list""
   )
 )
+methods::setOldClass(class_names(R7_method))
 
 R7_union <- new_class(
   name = ""R7_union"",

---FILE: tests/testthat/test-zzz.R---
@@ -49,3 +49,9 @@ test_that(""base classes types check their data"", {
     base_classes$integer(TRUE)
   })
 })
+
+test_that(""register S4 classes for key components"", {
+  expect_s4_class(getClass(""R7_object""), ""classRepresentation"")
+  expect_s4_class(getClass(""R7_method""), ""classRepresentation"")
+  expect_s4_class(getClass(""R7_generic""), ""classRepresentation"")
+})"
RConsortium,S7,7d0b4e7bc69b00a0b45d0e7d297d9161357e74be,Hadley Wickham,h.wickham@gmail.com,2022-02-11T14:05:43Z,Hadley Wickham,h.wickham@gmail.com,2022-02-11T14:05:43Z,"Use check_name() in new_class() and new_generic()

Fixes #155",R/class.R;R/generic.R;tests/testthat/_snaps/class.md;tests/testthat/_snaps/generic.md;tests/testthat/test-class.R;tests/testthat/test-generic.R,False,True,True,False,41,4,45,"---FILE: R/class.R---
@@ -1,6 +1,8 @@
 #' @importFrom utils modifyList
 R7_class <- function(name, parent = R7_object, constructor = NULL, validator = function(x) NULL, properties = list()) {
 
+  check_name(name)
+
   parent <- as_class(parent)
   if (is_union(parent) || isS4(parent)) {
     not <- if (is_union(parent)) ""a class union"" else ""an S4 class""

---FILE: R/generic.R---
@@ -63,6 +63,8 @@
 #' }
 #'
 new_generic <- function(name, fun = NULL, dispatch_args = NULL) {
+  check_name(name)
+
   if (is.null(dispatch_args) && is.null(fun)) {
     stop(
       ""Must call `new_generic()` with at least one of `dispatch_args` or `fun`"",

---FILE: tests/testthat/_snaps/class.md---
@@ -61,6 +61,17 @@
        $ length: <integer> or <double>
       
 
+# new_class() checks its inputs
+
+    Code
+      new_class(1)
+    Error <simpleError>
+      `name` must be a single string
+    Code
+      new_class(""foo"", 1)
+    Error <simpleError>
+      Can't convert `parent` to a valid class. Class specification must be an R7 class object, the result of `s3_class()`, an S4 class object, or a base constructor function, not a <double>.
+
 # classes can't inherit from S4 or class unions
 
     Code

---FILE: tests/testthat/_snaps/generic.md---
@@ -1,6 +1,17 @@
-# new_generic needs fun or dispatch_args
+# new_generic checks its inputs
 
-    Must call `new_generic()` with at least one of `dispatch_args` or `fun`
+    Code
+      new_generic(1)
+    Error <simpleError>
+      `name` must be a single string
+    Code
+      new_generic("""")
+    Error <simpleError>
+      `name` must not be """" or NA
+    Code
+      new_generic(""foo"")
+    Error <simpleError>
+      Must call `new_generic()` with at least one of `dispatch_args` or `fun`
 
 # check_dispatch_args() produces informative errors
 

---FILE: tests/testthat/test-class.R---
@@ -35,6 +35,13 @@ describe(""R7_class"", {
   })
 })
 
+test_that(""new_class() checks its inputs"", {
+  expect_snapshot(error = TRUE, {
+    new_class(1)
+    new_class(""foo"", 1)
+  })
+})
+
 test_that(""classes can inherit from base types"", {
   types <- c(""logical"", ""integer"", ""double"", ""complex"", ""character"", ""raw"", ""list"")
   for (type in types) {

---FILE: tests/testthat/test-generic.R---
@@ -1,5 +1,9 @@
-test_that(""new_generic needs fun or dispatch_args"", {
-  expect_snapshot_error(new_generic())
+test_that(""new_generic checks its inputs"", {
+  expect_snapshot(error = TRUE, {
+    new_generic(1)
+    new_generic("""")
+    new_generic(""foo"")
+  })
 })
 
 test_that(""dispatch_args overrules derived"", {"
RConsortium,S7,e50486952ae6929030d454654a01340a4e9ebb03,Hadley Wickham,h.wickham@gmail.com,2022-02-11T13:33:24Z,GitHub,noreply@github.com,2022-02-11T13:33:24Z,"Refactor method() and method<-() (#154)

* separate tests and documentation for method registration vs. introspection
* Moved `method()` and `next_method() to `dispatch.R`
* `new_method()` is now `register_method()`
* Test all existing forms of method registration
* Add more information to `check_method()` failures
* Update readme

Fixes #137",NAMESPACE;R/class-spec.R;R/dispatch.R;R/external-generic.R;R/generic.R;R/method.R;R/zzz.R;README.Rmd;README.md;man/as_class.Rd;man/method-set.Rd;man/method.Rd;man/method_call.Rd;man/new_external_generic.Rd;man/new_generic.Rd;man/next_method.Rd;src/dispatch.c;tests/testthat/_snaps/dispatch.md;tests/testthat/_snaps/method.md;tests/testthat/t0/R/pkg.R;tests/testthat/t1/R/foo.R;tests/testthat/t2/R/pkg.R;tests/testthat/test-dispatch.R;tests/testthat/test-external-generic.R;tests/testthat/test-method.R,True,True,True,False,804,586,1390,"---FILE: NAMESPACE---
@@ -2,6 +2,7 @@
 
 S3method(""@<-"",R7_object)
 S3method(print,R7_class)
+S3method(print,R7_external_generic)
 S3method(print,R7_generic)
 S3method(print,R7_method)
 S3method(print,R7_object)
@@ -18,9 +19,9 @@ export(""r7_data<-"")
 export(R7_object)
 export(as_class)
 export(class_names)
+export(external_methods_register)
 export(method)
 export(method_call)
-export(method_register)
 export(new_class)
 export(new_external_generic)
 export(new_generic)
@@ -41,7 +42,6 @@ export(valid_implicitly)
 export(validate)
 importFrom(stats,setNames)
 importFrom(utils,getFromNamespace)
-importFrom(utils,getS3method)
 importFrom(utils,hasName)
 importFrom(utils,head)
 importFrom(utils,modifyList)

---FILE: R/class-spec.R---
@@ -4,13 +4,14 @@
 #' you to use R7 classes and methods with base types, informal S3 classes, and
 #' formal S4 classes.
 #'
-#' @param x A class specification.
-#'    * An R7 class object or class union.
-#'    * An S3 class object, created by `s3_class()`.
-#'    * An S4 class object.
-#'    * A base type specified either with its constructor (`logical`, `integer`,
-#'      `double` etc) or its name (`""logical""`, `""integer""`, ""`double`"" etc).
-#'    * A base union type specified by its name: `""numeric""`, `""atomic""`, or
+#' @param x A class specification. One of the following:
+#'   * An R7 class (created by [new_class()]).
+#'   * An R7 union (created by [new_union()]).
+#'   * An S3 class (created by [s3_class()]).
+#'   * An S4 class (created by [methods::getClass()] or [methods::new()]).
+#'   * A base type specified either with its constructor (`logical`, `integer`,
+#'     `double` etc) or its name (`""logical""`, `""integer""`, ""`double`"" etc).
+#'   * A base union type specified by its name: `""numeric""`, `""atomic""`, or
 #'      `""vector""`.
 #' @param arg Argument name used when generating errors.
 #' @export

---FILE: R/dispatch.R---
@@ -1,12 +1,77 @@
+#' Retrieve a method for an R7 generic
+#'
+#' `method()` takes a generic and signature and retrieves the corresponding
+#' method. This is rarely needed because most of the time you'll rely on the
+#' the generic, via [method_call()], to find and call the method for you.
+#' However, this introspection is useful if you want to see the implementation
+#' of a specific method.
+#'
+#' @inheritParams method<-
+#' @returns A function with class <R7_method>.
+#' @export
+#' @examples
+#' # Create a generic and register some methods
+#' bizarro <- new_generic(""bizarro"", dispatch_args = ""x"")
+#' method(bizarro, ""numeric"") <- function(x) rev(x)
+#' method(bizarro, s3_class(""factor"")) <- function(x) {
+#'   levels(x) <- rev(levels(x))
+#'   x
+#' }
+#'
+#' # Printing the generic shows the registered method
+#' bizarro
+#'
+#' # And you can use method() to inspect specific implementations
+#' method(bizarro, ""integer"")
+#' method(bizarro, s3_class(""factor""))
+method <- function(generic, signature) {
+  if (!inherits(generic, ""R7_generic"")) {
+    stop(""`generic` must be an <R7_generic>"")
+  }
+
+  signature <- as_signature(signature)
+  is_union <- vlapply(signature, is_union)
+  if (any(is_union)) {
+    stop(""Can't dispatch on unions; must be a concrete type"")
+  }
+
+  .Call(method_, generic, signature, NULL)
+}
+
+# Called from C
 method_lookup_error <- function(name, args, signatures) {
   args <- setdiff(args, ""..."")
   types <- paste0(""- "", args, "": "", vcapply(signatures, fmt_classes), collapse = ""\n"")
   stop(sprintf(""Can't find method for generic `%s()` with classes:\n%s"", name, types), call. = FALSE)
 }
 
-
-#' Lookup the R7 method for the current generic and call it.
+#' @rdname new_generic
+#' @order 2
 #' @export
 method_call <- function() {
   .Call(method_call_, sys.call(-1), sys.function(-1), sys.frame(-1))
 }
+
+#' Retrieve the next applicable method after the current one
+#'
+#' @export
+next_method <- function() {
+  current_method <- sys.function(sys.parent(1))
+
+  methods <- list()
+  i <- 1
+  while (!inherits(current_method, ""R7_generic"")) {
+    methods <- c(methods, current_method)
+    i <- i + 1
+    current_method <- sys.function(sys.parent(i))
+  }
+
+  generic <- current_method
+
+  # Find signature
+  dispatch_on <- setdiff(generic@dispatch_args, ""..."")
+  vals <- mget(dispatch_on, envir = parent.frame())
+  signature <- lapply(vals, object_class)
+
+  .Call(method_, generic, signature, ignore = methods)
+}

---FILE: R/external-generic.R---
@@ -9,50 +9,97 @@
 #' but your package doesn't use anything else from knitr.
 #'
 #' Instead, you can add the package to `Suggests` and use
-#' `new_external_generic()` along with `method_register()` to declare an
-#' ""external"" generic. `new_external_generic()` defines the ""shape"" of the
+#' `new_external_generic()` along with `external_methods_register()` to declare
+#' an ""external"" generic. `new_external_generic()` defines the ""shape"" of the
 #' generic without requiring the other package be available. You then call
-#' `method_register()` in `.onLoad()` to dynamically register the methods
-#' when the other package is loaded.
+#' `external_methods_register()` in `.onLoad()` to dynamically register the
+#' methods when the other package is loaded.
 #'
 #' @param package Package the generic is defined in.
-#' @param generic Name of generic, as a string.
+#' @param name Name of generic, as a string.
 #' @param version An optional version the package must meet for the method to
 #'   be registered.
 #' @export
-new_external_generic <- function(package, generic, version = NULL) {
+new_external_generic <- function(package, name, version = NULL) {
   out <- list(
     package = package,
-    generic = generic,
+    name = name,
     version = version
   )
 
   class(out) <- ""R7_external_generic""
   out
 }
 
+#' @export
+print.R7_external_generic <- function(x, ...) {
+  cat(
+    ""<R7_external_generic> "",
+    x$package, ""::"", x$name, ""()"",
+    if (!is.null(x$version)) paste0("" (>= "", x$version, "")""),
+    ""\n"",
+    sep = """"
+  )
+  invisible(x)
+}
+
+is_external_generic <- function(x) {
+  inherits(x, ""R7_external_generic"")
+}
+
 #' @importFrom utils getFromNamespace packageName
 #' @rdname new_external_generic
 #' @export
-method_register <- function() {
+external_methods_register <- function() {
   package <- packageName(parent.frame())
-  tbl <- asNamespace(package)[["".__S3MethodsTable__.""]][["".R7_methods""]]
+  tbl <- external_methods_get(package)
+
   for (x in tbl) {
-    if (isNamespaceLoaded(x$package)) {
-      ns <- asNamespace(x$package)
-      new_method(getFromNamespace(x$generic, ns), x$signature, x$method)
+    hook <- registrar(x$generic, x$signature, x$method)
+
+    if (isNamespaceLoaded(x$generic$package)) {
+      hook()
     } else {
-      setHook(packageEvent(x$package, ""onLoad""),
-        local({
-          x <- x
-          function(...) {
-            ns <- asNamespace(x$package)
-            if (is.null(x$version) || getNamespaceVersion(ns) >= x$version) {
-              new_method(getFromNamespace(x$generic, ns), x$signature, x$method)
-            }
-          }
-        })
-      )
+      setHook(packageEvent(x$generic$package, ""onLoad""), hook)
+    }
+  }
+}
+
+registrar <- function(generic, signature, method) {
+  # Force all arguments
+  list(generic, signature, method)
+
+  function(...) {
+    ns <- asNamespace(generic$package)
+    if (is.null(generic$version) || getNamespaceVersion(ns) >= generic$version) {
+      generic_fun <- getFromNamespace(generic$name, ns)
+      register_method(generic_fun, signature, method)
     }
   }
 }
+
+external_methods_get <- function(package) {
+  s3_methods_table(package)[["".R7_methods""]] %||% list()
+}
+
+external_methods_reset <- function(package) {
+  tbl <- s3_methods_table(package)
+  tbl[["".R7_methods""]] <- list()
+  invisible()
+}
+
+external_methods_add <- function(package, generic, signature, method) {
+  tbl <- s3_methods_table(package)
+
+  methods <- append(
+    tbl[["".R7_methods""]] %||% list(),
+    list(list(generic = generic, signature = signature, method = method))
+  )
+
+  tbl[["".R7_methods""]] <- methods
+  invisible()
+}
+
+s3_methods_table <- function(package) {
+  asNamespace(package)[["".__S3MethodsTable__.""]]
+}

---FILE: R/generic.R---
@@ -1,9 +1,11 @@
 #' Define a new generic
 #'
 #' @description
-#' A generic function uses different implementations depending on the class
-#' of one or more arguments (the `signature`). Create a new generic with
-#' `new_generic()` then use [method<-] to add methods to it.
+#' A generic function uses different implementations (_methods_) depending on
+#' the class of one or more arguments (the _signature_). Create a new generic
+#' with `new_generic()` then use [method<-] to add methods to it. The body of
+#' the generic always contains `method_call()`, which takes care of finding and
+#' calling the appropriate method.
 #'
 #' @section Dispatch arguments:
 #' The arguments that are used to pick the method are called the **dispatch
@@ -17,8 +19,8 @@
 #'
 #' @param name The name of the generic. This should be the same as the object
 #'   that you assign it to.
-#' @param dispatch_args A character vector providing the names of arguments to
-#'   dispatch on.
+#' @param dispatch_args A character vector giving the names of the arguments
+#'   that form the signature, i.e. the arguments used for method dispatch.
 #'
 #'   If `dispatch_args` are omitted, but `fun` is supplied, will default to the
 #'   arguments that appear before `...` in `fun`. If there are no dots, it will
@@ -33,6 +35,7 @@
 #' @seealso [new_external_generic()] to define a method for a generic
 #'  in another package without taking a strong dependency on it.
 #' @export
+#' @order 1
 #' @examples
 #' # A simple generic with methods for some base types and S3 classes
 #' type_of <- new_generic(""type_of"", dispatch_args = ""x"")
@@ -172,3 +175,37 @@ has_call <- function(x, name) {
   }
   FALSE
 }
+
+
+methods <- function(generic) {
+  methods_rec(generic@methods, character())
+}
+methods_rec <- function(x, signature) {
+  if (!is.environment(x)) {
+    return(x)
+  }
+
+  # Recursively collapse environments to a list
+  methods <- lapply(names(x), function(class) methods_rec(x[[class]], c(signature, class)))
+  unlist(methods, recursive = FALSE)
+}
+
+generic_add_method <- function(generic, signature, method) {
+  p_tbl <- generic@methods
+  chr_signature <- vcapply(signature, r7_class_name)
+
+  for (i in seq_along(chr_signature)) {
+    class_name <- chr_signature[[i]]
+    if (i != length(chr_signature)) {
+      # Iterated dispatch, so create another nested environment
+      tbl <- p_tbl[[class_name]]
+      if (is.null(tbl)) {
+        tbl <- new.env(hash = TRUE, parent = emptyenv())
+        p_tbl[[class_name]] <- tbl
+      }
+      p_tbl <- tbl
+    } else {
+      p_tbl[[class_name]] <- method
+    }
+  }
+}

---FILE: R/method.R---
@@ -1,145 +1,168 @@
-#' Retrieve or register an R7 method for a generic
+#' Register a R7 method for a generic
 #'
 #' @description
-#' Generics partition a function into interface (a generic) and implementation
-#' (many methods). `method<-` allows you to register a method, an
-#' implementation for a specified class signature, with a generic.
+#' A generic defines the interface of a function. Once you have created a
+#' generic with [new_generic()], you provide implementations for specific
+#' signatures by registering methods with `method<-`
 #'
-#' `method()` retrieves a method for a given signature. You typically shouldn't
-#' need this function while programming, because calling the generic will
-#' automatically dispatch to the correct method, but it's often useful
-#' interactively in order to see the implementation of a specific method.
+#' The goal is for `method<-` to be the single function you need when working
+#' with R7 generics or R7 classes. This means that as well as registering
+#' methods for R7 classes on R7 generics, you can also register methods for
+#' R7 classes on S3 or S4 generics, and S3 or S4 classes for R7 generics.
+#' But this is not a general method registration function: at least one of
+#' `generic` and `signature` needs to be from R7.
 #'
-#' @param generic A generic function.
-#' @param signature A method signature, a list of R7 class constructors
-#'   (produced by [new_class()]) or names of S3 or S4 classes.
+#' @param generic A generic function, either created by [new_generic()],
+#'   [new_external_generic()], or an existing S3 generic.
+#' @param signature A method signature. For R7 generics that use single
+#'   dispatch, this should be one of the following:
+#'   * An R7 class (created by [new_class()]).
+#'   * An R7 union (created by [new_union()]).
+#'   * An S3 class (created by [s3_class()]).
+#'   * An S4 class (created by [methods::getClass()] or [methods::new()]).
+#'   * A base type specified either with its constructor (`logical`, `integer`,
+#'     `double` etc) or its name (`""logical""`, `""integer""`, ""`double`"" etc).
+#'   * A base union type specified by its name: `""numeric""`, `""atomic""`, or
+#'     `""vector""`.
+#'
+#'   For R7 generics that use multiple dispatch, this can be a list of any of
+#'   the above types.
+#'
+#'   For S3 generics, this must be an R7 class.
 #' @param value A function that implements the generic specification for the
-#'   given `signature`. The arguments must be compatible with the generic.
-#' @importFrom utils getS3method
+#'   given `signature`.
 #' @export
 #' @examples
 #' # Create a generic
 #' bizarro <- new_generic(""bizarro"", dispatch_args = ""x"")
 #' # Register some methods
-#' method(bizarro, ""numeric"") <- function(x, ...) rev(x)
-#' method(bizarro, s3_class(""factor"")) <- function(x, ...) {
-#'   levels(x) <- rev(levels(x))
-#'   x
-#' }
-#' method(bizarro, s3_class(""data.frame"")) <- function(x, ...) {
+#' method(bizarro, ""numeric"") <- function(x) rev(x)
+#' method(bizarro, s3_class(""data.frame"")) <- function(x) {
 #'   x[] <- lapply(x, bizarro)
 #'   rev(x)
 #' }
 #'
 #' # Using a generic calls the methods automatically
-#' bizarro(1)
-#'
-#' # But it can be useful to explicitly retrieve a method in order to
-#' # inspect its implementation
-#' method(bizarro, ""double"")
-#' method(bizarro, s3_class(""factor""))
-method <- function(generic, signature) {
-  # TODO: check that signature doesn't contain any unions
-
-  signature <- as_signature(signature)
-  method_impl(generic, signature, ignore = NULL)
+#' bizarro(head(mtcars))
+`method<-` <- function(generic, signature, value) {
+  package <- packageName(parent.frame())
+  register_method(generic, signature, value, package = package)
+  invisible(generic)
 }
 
-methods <- function(generic) {
-  get_all_methods(generic@methods, character())
-}
+register_method <- function(generic, signature, method, package = NULL) {
+  signature <- as_signature(signature)
+  generic <- as_generic(generic)
 
-get_all_methods <- function(x, signature) {
-  if(!is.environment(x)) {
-    return(x)
+  if (is_external_generic(generic)) {
+    if (!is.null(package)) {
+      # method registration within package, so add to lazy registry
+      external_methods_add(package, generic, signature, method)
+    } else {
+      # otherwise find the generic and register
+      generic <- getFromNamespace(generic$name, asNamespace(generic$package))
+      register_method(generic, signature, method)
+    }
+  } else if (is_s3_generic(generic)) {
+    register_s3_method(generic, signature, method)
+  } else {
+    check_method(method, signature, generic)
+    register_r7_method(generic, signature, method)
   }
 
-  unlist(lapply(names(x), function(class) get_all_methods(x[[class]], c(signature, class))), recursive = FALSE)
+  invisible()
 }
 
-as_signature <- function(signature) {
-  if (!is.list(signature)) {
-    signature <- list(signature)
-  }
+register_s3_method <- function(generic, signature, method) {
+  generic_name <- attr(generic, ""name"")
 
-  for (i in seq_along(signature)) {
-    signature[[i]] <- as_class(signature[[i]], arg = sprintf(""signature[[%i]]"", i))
+  if (length(signature) != 1 || class_type(signature[[1]]) != ""r7"") {
+    msg <- sprintf(
+      ""When registering methods for S3 generic %s(), signature be a single R7 class"",
+      generic_name
+    )
+    stop(msg, call. = FALSE)
   }
-  signature
+  class <- signature[[1]]@name
+  registerS3method(generic_name, class, method, envir = parent.frame())
 }
 
-method_impl <- function(generic, signature, ignore) {
-  out <- .Call(method_, generic, signature, ignore)
-  if (!is.null(out)) {
-    return(out)
-  }
+register_r7_method <- function(generic, signature, method) {
+  # Flatten out unions to individual signatures
+  signatures <- flatten_signature(signature)
 
-  # If no R7 method is found, see if there are any S3 methods registered
-  if (inherits(generic, ""R7_generic"")) {
-    args <- generic@dispatch_args
-    generic <- generic@name
-  } else {
-    args <- setdiff(names(formals(generic)), ""..."")
-    generic <- find_function_name(generic, topenv(environment(generic)))
+  # Register each method
+  for (signature in signatures) {
+    method <- R7_method(method, generic = generic, signature = signature)
+    generic_add_method(generic, signature, method)
   }
 
-  if (length(signature) > 1) {
-    out <- getS3method(generic, s3_class_name(signature[[1]]), optional = TRUE)
-    if (!is.null(out)) {
-      return(out)
-    }
+  invisible()
+}
+
+flatten_signature <- function(signature) {
+  # Unpack unions
+  sig_is_union <- vlapply(signature, is_union)
+  signature[sig_is_union] <- lapply(signature[sig_is_union], prop, ""classes"")
+  signature[!sig_is_union] <- lapply(signature[!sig_is_union], list)
+
+  # Create grid of indices
+  indx <- lapply(signature, seq_along)
+  comb <- as.matrix(rev(do.call(""expand.grid"", rev(indx))))
+  colnames(comb) <- NULL
+
+  rows <- lapply(1:nrow(comb), function(i) comb[i, ])
+  lapply(rows, function(row) Map(""[["", signature, row))
+}
+
+as_generic <- function(x) {
+  if (inherits(x, ""R7_generic"") || is_external_generic(x)) {
+    return(x)
   }
 
-  # If no method found check if the generic has a default method
-  out <- getS3method(generic, ""default"", optional = TRUE)
-  if (!is.null(out)) {
-    return(out)
+  if (!is.function(x)) {
+    msg <- sprintf(""`generic` must be a function, not a %s"", obj_desc(x))
+    stop(msg, call. = FALSE)
   }
 
-  method_lookup_error(generic, args, signature)
+  # For now, assume that it's an S3 generic
+  attr(x, ""name"") <- find_generic_name(x)
+  class(x) <- ""R7_S3_generic""
+  x
 }
+is_s3_generic <- function(x) inherits(x, ""R7_S3_generic"")
 
-find_function_name <- function(x, env) {
-  nms <- ls(env, all.names = TRUE, sorted = FALSE)
-  for (name in nms) {
-    if (identical(get0(name, envir = env, mode = ""function"", inherits = FALSE), x)) {
-      return(name)
+find_generic_name <- function(generic) {
+  env <- environment(generic) %||% baseenv()
+  for (nme in names(env)) {
+    if (identical(generic, env[[nme]])) {
+      return(nme)
     }
   }
-  NULL
-}
 
-#' Retrieve the next applicable method after the current one
-#'
-#' @export
-next_method <- function() {
-  current_method <- sys.function(sys.parent(1))
+  stop(""Can't find name of S3 `generic`"", call. = FALSE)
+}
 
-  methods <- list()
-  i <- 1
-  while (!inherits(current_method, ""R7_generic"")) {
-    methods <- c(methods, current_method)
-    i <- i + 1
-    current_method <- sys.function(sys.parent(i))
+as_signature <- function(signature) {
+  if (!is.list(signature)) {
+    signature <- list(signature)
   }
 
-  generic <- current_method
-
-  # Find signature
-  dispatch_on <- setdiff(generic@dispatch_args, ""..."")
-  vals <- mget(dispatch_on, envir = parent.frame())
-  signature <- lapply(vals, object_class)
-
-  method_impl(generic, signature, ignore = methods)
+  for (i in seq_along(signature)) {
+    signature[[i]] <- as_class(signature[[i]], arg = sprintf(""signature[[%i]]"", i))
+  }
+  signature
 }
 
-method_compatible <- function(method, generic) {
-  generic_formals <- suppressWarnings(formals(args(generic)))
-  # This can happen for some primitive functions such as `[`
-  if (length(generic_formals) == 0) {
-    return()
+check_method <- function(method, signature, generic) {
+  signature <- as_signature(signature)
+  method_name <- method_name(generic, signature)
+
+  if (!is.function(method)) {
+    stop(sprintf(""%s must be a function"", method_name), call. = FALSE)
   }
 
+  generic_formals <- formals(args(generic))
   method_formals <- formals(method)
   generic_args <- names(generic_formals)
   method_args <- names(method_formals)
@@ -148,106 +171,56 @@ method_compatible <- function(method, generic) {
   has_dispatch <- length(method_formals) >= n_dispatch &&
     identical(method_args[1:n_dispatch], generic@dispatch_args)
   if (!has_dispatch) {
-    stop(""`method` doesn't match generic dispatch arg"", call. = FALSE)
+    msg <- sprintf(
+      ""%s() dispatches on %s, but %s has arguments %s"",
+      generic@name,
+      arg_names(generic@dispatch_args),
+      method_name,
+      arg_names(method_args)
+    )
+    stop(msg, call. = FALSE)
   }
   if (""..."" %in% method_args && method_args[[n_dispatch + 1]] != ""..."") {
-    stop(""... must immediately follow dispatch args"", call. = FALSE)
+    msg <- sprintf(
+      ""In %s, `...` must come immediately after dispatch args (%s)"",
+      method_name,
+      arg_names(generic@dispatch_args)
+    )
+    stop(msg, call. = FALSE)
   }
   empty_dispatch <- vlapply(method_formals[generic@dispatch_args], identical, quote(expr = ))
   if (any(!empty_dispatch)) {
-    stop(""Dispatch arguments must not have default values"", call. = FALSE)
+    msg <- sprintf(
+      ""In %s, dispatch arguments (%s) must not have default values"",
+      method_name,
+      arg_names(generic@dispatch_args)
+    )
+    stop(msg, call. = FALSE)
   }
 
   extra_args <- setdiff(names(generic_formals), c(generic@dispatch_args, ""...""))
   for (arg in extra_args) {
     if (!arg %in% method_args) {
-      warning(sprintf(""Argument `%s` is missing from method"", arg), call. = FALSE)
+      warning(sprintf(""%s doesn't have argument `%s`"", method_name, arg), call. = FALSE)
     } else if (!identical(generic_formals[[arg]], method_formals[[arg]])) {
-      warning(sprintf(""Default value is not the same as the generic\n- Generic: %s = %s\n- Method:  %s = %s"", arg, deparse1(generic_formals[[arg]]), arg, deparse1(method_formals[[arg]])), call. = FALSE)
+      msg <- sprintf(
+        paste0(
+          ""In %s, default value of `%s` is not the same as the generic\n"",
+          ""- Generic: %s\n"",
+          ""- Method:  %s""
+        ),
+        method_name,
+        arg,
+        deparse1(generic_formals[[arg]]),
+        deparse1(method_formals[[arg]])
+      )
+      warning(msg, call. = FALSE)
     }
   }
 
-  TRUE
+  invisible(TRUE)
 }
 
-new_method <- function(generic, signature, method, package = NULL) {
-  signature <- as_signature(signature)
-
-  if (inherits(generic, ""R7_external_generic"")) {
-    # Get current package, if any
-    if (!is.null(package)) {
-      tbl <- asNamespace(package)[["".__S3MethodsTable__.""]]
-      if (is.null(tbl[["".R7_methods""]])) {
-        tbl[["".R7_methods""]] <- list()
-      }
-      tbl[["".R7_methods""]] <- append(tbl[["".R7_methods""]], list(list(generic = generic$generic, package = generic$package, signature = signature, method = method, version = generic$version)))
-
-      return(invisible())
-    }
-    generic <- getFromNamespace(generic$generic, asNamespace(generic$package))
-  }
-
-  if (!is.character(signature) && !inherits(signature, ""list"")) {
-    signature <- list(signature)
-  }
-
-  generic <- as_generic(generic)
-
-  method_compatible(method, generic)
-
-  if (!inherits(method, ""R7_method"")) {
-    method <- R7_method(generic, signature, method)
-  }
-
-  if (inherits(generic, ""S3_generic"")) {
-    class <- s3_class_name(signature[[1]])
-    registerS3method(attr(generic, ""name""), class, method, envir = parent.frame())
-    return(invisible(generic))
-  }
-
-  generic_name <- generic@name
-
-  p_tbl <- generic@methods
-
-
-  for (i in seq_along(signature)) {
-    # Register one method for each class in union
-    if (inherits(signature[[i]], ""R7_union"")) {
-      this_sig <- signature
-      for (class in signature[[i]]@classes) {
-        this_sig[[i]] <- class
-        method <- R7_method(generic, this_sig, method)
-        new_method(generic, this_sig, method, package = package)
-      }
-      return(invisible(generic))
-    }
-
-    class_name <- r7_class_name(signature[[i]])
-    if (i == length(signature)) {
-      p_tbl[[class_name]] <- method
-    } else {
-      tbl <- p_tbl[[class_name]]
-      if (is.null(tbl)) {
-        tbl <- new.env(hash = TRUE, parent = emptyenv())
-        p_tbl[[class_name]] <- tbl
-      }
-      p_tbl <- tbl
-    }
-  }
-
-  invisible(generic)
-}
-
-# Class name when registering an S3 method
-s3_class_name <- function(x) {
-  switch(class_type(x),
-   s3 = class(x),
-   s4 = class(x),
-   r7 = x@name,
-   r7_base = typeof(x),
-   stop(""Unsupported"")
-  )
-}
 # Class name when registering an R7 method
 r7_class_name <- function(x) {
   switch(class_type(x),
@@ -259,35 +232,6 @@ r7_class_name <- function(x) {
   )
 }
 
-#' @rdname method
-#'
-#' @export
-`method<-` <- function(generic, signature, value) {
-  new_method(generic, signature, value, package = packageName(parent.frame()))
-}
-
-find_generic_name <- function(generic) {
-  env <- environment(generic) %||% baseenv()
-  for (nme in names(env)) {
-    if (identical(generic, env[[nme]])) {
-      return(nme)
-    }
-  }
-}
-
-as_generic <- function(generic) {
-  if (length(generic) == 1 && is.character(generic)) {
-    fun <- match.fun(generic)
-    generic <- fun
-  }
-  if (!inherits(generic, ""R7_generic"")) {
-    attr(generic, ""name"") <- find_generic_name(generic)
-    class(generic) <- ""S3_generic""
-  }
-
-  generic
-}
-
 #' @export
 print.R7_method <- function(x, ...) {
   signature <- method_signature(x@generic, x@signature)
@@ -296,3 +240,12 @@ print.R7_method <- function(x, ...) {
   attributes(x) <- NULL
   print(x)
 }
+
+arg_names <- function(x) {
+  paste0(encodeString(x, quote = ""`""), collapse = "", "")
+}
+
+method_name <- function(generic, signature) {
+  method_args <- paste0(vcapply(signature, class_desc), collapse ="", "")
+  sprintf(""%s(%s)"", generic@name, method_args)
+}

---FILE: R/zzz.R---
@@ -54,16 +54,12 @@ R7_generic <- new_class(
   }
 )
 
-R7_method <- new_class(
-  name = ""R7_method"",
-  properties = list(generic = R7_generic, signature = ""list""),
+R7_method <- new_class(""R7_method"",
   parent = ""function"",
-  constructor = function(generic, signature, fun) {
-    if (is.character(signature)) {
-      signature <- list(signature)
-    }
-    new_object(generic = generic, signature = signature, .data = fun)
-  }
+  properties = list(
+    generic = R7_generic,
+    signature = ""list""
+  )
 )
 
 R7_union <- new_class(

---FILE: README.Rmd---
@@ -88,11 +88,9 @@ x
 ## Generics and methods
 
 ```{r}
-text <- new_class(""text"", parent = ""character"", constructor = function(text) new_object(.data = text))
-
+text <- new_class(""text"", parent = ""character"")
 foo <- new_generic(""foo"", dispatch_args = ""x"")
-
-method(foo, ""text"") <- function(x, ...) paste0(""foo-"", x)
+method(foo, text) <- function(x, ...) paste0(""foo-"", x)
 
 foo(text(""hi""))
 ```
@@ -107,13 +105,10 @@ For `method(foo, c(""character"", ""numeric""))` the method would be stored at `foo@
 At each level the search iteratively searches along objects class vector.
 
 ```{r}
-number <- new_class(""number"", parent = ""numeric"", constructor = function(x) new_object(.data = x))
-
 bar <- new_generic(""bar"", dispatch_args = c(""x"", ""y""))
+method(bar, list(""character"", ""double"")) <- function(x, y) paste0(""foo-"", x, "":"", y)
 
-method(bar, list(""character"", ""numeric"")) <- function(x, y, ...) paste0(""foo-"", x, "":"", y)
-
-bar(text(""hi""), number(42))
+bar(""hi"", 42)
 ```
 
 ## Calling the next method
@@ -123,12 +118,12 @@ This works by looking up the call stack and retrieving R7 methods which have alr
 This ensures you cannot call the same method twice.
 
 ```{r}
-method(bar, list(""text"", ""number"")) <- function(x, y, ...) {
+method(bar, list(text, ""double"")) <- function(x, y, ...) {
   res <- next_method()(x, y)
   paste0(""2 "", res)
 }
 
-bar(text(""hi""), number(42))
+bar(text(""hi""), 42)
 ```
 
 ## Non-standard evaluation
@@ -138,7 +133,7 @@ bar(text(""hi""), number(42))
 ```{r}
 subset2 <- new_generic(""subset2"", dispatch_args = ""x"")
 
-method(subset2, ""data.frame"") <- function(x, subset = NULL, select = NULL, drop = FALSE, ...) {
+method(subset2, s3_class(""data.frame"")) <- function(x, subset = NULL, select = NULL, drop = FALSE) {
   e <- substitute(subset)
   # Unlike S3, R7 creates a frame for the generic, so we need to
   # go one extra level up to get to the user's evaluation environment
@@ -155,17 +150,16 @@ subset2(mtcars, hp > 200, c(wt, qsec))
 
 ### External generics
 
-If you want to define methods for R7 generics defined in another package you can use `new_extrenal_generic` to declare the external generic, then add `R7::method_register()` to the `.onLoad` function in your package.
-`method_register()` will automatically setup on-load hooks for 'soft' dependencies in `Suggests` so the method will be added when the dependency is eventually loaded.
+If you want to define methods for R7 generics defined in another package you can use `new_extrenal_generic` to declare the external generic, then add `R7::external_methods_register()` to the `.onLoad` function in your package.
+`external_methods_register()` will automatically setup on-load hooks for 'soft' dependencies in `Suggests` so the method will be added when the dependency is eventually loaded.
 
 ```{r eval = FALSE}
 .onLoad <- function(libname, pkgname) {
-  R7::method_register()
+  R7::external_methods_register()
 }
 
 foo <- new_external_generic(""pkg1"", ""foo"")
-
-method(foo, list(""text"", ""numeric"")) <- function(x, y, ...) paste0(""foo-"", x, "": "", y)
+method(foo, ""integer"") <- function(x) paste0(""foo-"", x)
 ```
 
 ## Design workflow

---FILE: README.md---
@@ -69,8 +69,7 @@ x@middle
 
 # assigning properties verifies the class matches the class of the value
 x@end <- ""foo""
-#> Error: <range>@end must be of class <numeric>:
-#> - `value` is of class <character>
+#> Error: <range>@end must be of class <integer> or <double>, not <character>
 
 # assigning properties runs the validator
 x@end <- 0
@@ -80,29 +79,28 @@ x@end <- 0
 # Print methods for both R7_class objects
 object_class(x)
 #> <R7_class>
-#> @name range
-#> @parent <R7_object>
-#> @properties
-#>  $start  <numeric>
-#>  $end    <numeric>
-#>  $length <numeric>
+#> @ name  :  range
+#> @ parent: <R7_object>
+#> @ properties:
+#>  $ start : <integer> or <double>
+#>  $ end   : <integer> or <double>
+#>  $ length: <integer> or <double>
 
 # As well as normal R7_objects
 x
-#> <range> <R7_object>
-#> @start  1
-#> @end    6
-#> @length 5
+#> <range/R7_object>
+#> @ start :  num 1
+#> @ end   :  num 6
+#> @ length:  num 5
 ```
 
 ## Generics and methods
 
 ``` r
-text <- new_class(""text"", parent = ""character"", constructor = function(text) new_object(.data = text))
-
+text <- new_class(""text"", parent = ""character"")
 foo <- new_generic(""foo"", dispatch_args = ""x"")
-
-method(foo, ""text"") <- function(x, ...) paste0(""foo-"", x)
+method(foo, text) <- function(x, ...) paste0(""foo-"", x)
+#> registered foo(<text>)
 
 foo(text(""hi""))
 #> [1] ""foo-hi""
@@ -121,13 +119,11 @@ At each level the search iteratively searches along objects class
 vector.
 
 ``` r
-number <- new_class(""number"", parent = ""numeric"", constructor = function(x) new_object(.data = x))
-
 bar <- new_generic(""bar"", dispatch_args = c(""x"", ""y""))
+method(bar, list(""character"", ""double"")) <- function(x, y) paste0(""foo-"", x, "":"", y)
+#> registered bar(<character>, <double>)
 
-method(bar, list(""character"", ""numeric"")) <- function(x, y, ...) paste0(""foo-"", x, "":"", y)
-
-bar(text(""hi""), number(42))
+bar(""hi"", 42)
 #> [1] ""foo-hi:42""
 ```
 
@@ -139,12 +135,13 @@ already been called, then doing a method search with those methods
 excluded. This ensures you cannot call the same method twice.
 
 ``` r
-method(bar, list(""text"", ""number"")) <- function(x, y, ...) {
+method(bar, list(text, ""double"")) <- function(x, y, ...) {
   res <- next_method()(x, y)
   paste0(""2 "", res)
 }
+#> registered bar(<text>, <double>)
 
-bar(text(""hi""), number(42))
+bar(text(""hi""), 42)
 #> [1] ""2 foo-hi:42""
 ```
 
@@ -157,7 +154,7 @@ the same as S3.
 ``` r
 subset2 <- new_generic(""subset2"", dispatch_args = ""x"")
 
-method(subset2, ""data.frame"") <- function(x, subset = NULL, select = NULL, drop = FALSE, ...) {
+method(subset2, s3_class(""data.frame"")) <- function(x, subset = NULL, select = NULL, drop = FALSE) {
   e <- substitute(subset)
   # Unlike S3, R7 creates a frame for the generic, so we need to
   # go one extra level up to get to the user's evaluation environment
@@ -168,6 +165,7 @@ method(subset2, ""data.frame"") <- function(x, subset = NULL, select = NULL, drop
   vars <- eval(substitute(select), nl, parent.frame())
   x[r, vars, drop = drop]
 }
+#> registered subset2(<data.frame>)
 
 subset2(mtcars, hp > 200, c(wt, qsec))
 #>                        wt  qsec
@@ -184,19 +182,18 @@ subset2(mtcars, hp > 200, c(wt, qsec))
 
 If you want to define methods for R7 generics defined in another package
 you can use `new_extrenal_generic` to declare the external generic, then
-add `R7::method_register()` to the `.onLoad` function in your package.
-`method_register()` will automatically setup on-load hooks for ‘soft’
-dependencies in `Suggests` so the method will be added when the
-dependency is eventually loaded.
+add `R7::external_methods_register()` to the `.onLoad` function in your
+package. `external_methods_register()` will automatically setup on-load
+hooks for ‘soft’ dependencies in `Suggests` so the method will be added
+when the dependency is eventually loaded.
 
 ``` r
 .onLoad <- function(libname, pkgname) {
-  R7::method_register()
+  R7::external_methods_register()
 }
 
 foo <- new_external_generic(""pkg1"", ""foo"")
-
-method(foo, list(""text"", ""numeric"")) <- function(x, y, ...) paste0(""foo-"", x, "": "", y)
+method(foo, ""integer"") <- function(x) paste0(""foo-"", x)
 ```
 
 ## Design workflow

---FILE: man/as_class.Rd---
@@ -7,11 +7,12 @@
 as_class(x, arg = deparse(substitute(x)))
 }
 \arguments{
-\item{x}{A class specification.
+\item{x}{A class specification. One of the following:
 \itemize{
-\item An R7 class object or class union.
-\item An S3 class object, created by \code{s3_class()}.
-\item An S4 class object.
+\item An R7 class (created by \code{\link[=new_class]{new_class()}}).
+\item An R7 union (created by \code{\link[=new_union]{new_union()}}).
+\item An S3 class (created by \code{\link[=s3_class]{s3_class()}}).
+\item An S4 class (created by \code{\link[methods:getClass]{methods::getClass()}} or \code{\link[methods:new]{methods::new()}}).
 \item A base type specified either with its constructor (\code{logical}, \code{integer},
 \code{double} etc) or its name (\code{""logical""}, \code{""integer""}, ""\code{double}"" etc).
 \item A base union type specified by its name: \code{""numeric""}, \code{""atomic""}, or

---FILE: man/method-set.Rd---
@@ -0,0 +1,58 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/method.R
+\name{method<-}
+\alias{method<-}
+\title{Register a R7 method for a generic}
+\usage{
+method(generic, signature) <- value
+}
+\arguments{
+\item{generic}{A generic function, either created by \code{\link[=new_generic]{new_generic()}},
+\code{\link[=new_external_generic]{new_external_generic()}}, or an existing S3 generic.}
+
+\item{signature}{A method signature. For R7 generics that use single
+dispatch, this should be one of the following:
+\itemize{
+\item An R7 class (created by \code{\link[=new_class]{new_class()}}).
+\item An R7 union (created by \code{\link[=new_union]{new_union()}}).
+\item An S3 class (created by \code{\link[=s3_class]{s3_class()}}).
+\item An S4 class (created by \code{\link[methods:getClass]{methods::getClass()}} or \code{\link[methods:new]{methods::new()}}).
+\item A base type specified either with its constructor (\code{logical}, \code{integer},
+\code{double} etc) or its name (\code{""logical""}, \code{""integer""}, ""\code{double}"" etc).
+\item A base union type specified by its name: \code{""numeric""}, \code{""atomic""}, or
+\code{""vector""}.
+}
+
+For R7 generics that use multiple dispatch, this can be a list of any of
+the above types.
+
+For S3 generics, this must be an R7 class.}
+
+\item{value}{A function that implements the generic specification for the
+given \code{signature}.}
+}
+\description{
+A generic defines the interface of a function. Once you have created a
+generic with \code{\link[=new_generic]{new_generic()}}, you provide implementations for specific
+signatures by registering methods with \verb{method<-}
+
+The goal is for \verb{method<-} to be the single function you need when working
+with R7 generics or R7 classes. This means that as well as registering
+methods for R7 classes on R7 generics, you can also register methods for
+R7 classes on S3 or S4 generics, and S3 or S4 classes for R7 generics.
+But this is not a general method registration function: at least one of
+\code{generic} and \code{signature} needs to be from R7.
+}
+\examples{
+# Create a generic
+bizarro <- new_generic(""bizarro"", dispatch_args = ""x"")
+# Register some methods
+method(bizarro, ""numeric"") <- function(x) rev(x)
+method(bizarro, s3_class(""data.frame"")) <- function(x) {
+  x[] <- lapply(x, bizarro)
+  rev(x)
+}
+
+# Using a generic calls the methods automatically
+bizarro(head(mtcars))
+}

---FILE: man/method.Rd---
@@ -1,52 +1,56 @@
 % Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/method.R
+% Please edit documentation in R/dispatch.R
 \name{method}
 \alias{method}
-\alias{method<-}
-\title{Retrieve or register an R7 method for a generic}
+\title{Retrieve a method for an R7 generic}
 \usage{
 method(generic, signature)
-
-method(generic, signature) <- value
 }
 \arguments{
-\item{generic}{A generic function.}
+\item{generic}{A generic function, either created by \code{\link[=new_generic]{new_generic()}},
+\code{\link[=new_external_generic]{new_external_generic()}}, or an existing S3 generic.}
+
+\item{signature}{A method signature. For R7 generics that use single
+dispatch, this should be one of the following:
+\itemize{
+\item An R7 class (created by \code{\link[=new_class]{new_class()}}).
+\item An R7 union (created by \code{\link[=new_union]{new_union()}}).
+\item An S3 class (created by \code{\link[=s3_class]{s3_class()}}).
+\item An S4 class (created by \code{\link[methods:getClass]{methods::getClass()}} or \code{\link[methods:new]{methods::new()}}).
+\item A base type specified either with its constructor (\code{logical}, \code{integer},
+\code{double} etc) or its name (\code{""logical""}, \code{""integer""}, ""\code{double}"" etc).
+\item A base union type specified by its name: \code{""numeric""}, \code{""atomic""}, or
+\code{""vector""}.
+}
 
-\item{signature}{A method signature, a list of R7 class constructors
-(produced by \code{\link[=new_class]{new_class()}}) or names of S3 or S4 classes.}
+For R7 generics that use multiple dispatch, this can be a list of any of
+the above types.
 
-\item{value}{A function that implements the generic specification for the
-given \code{signature}. The arguments must be compatible with the generic.}
+For S3 generics, this must be an R7 class.}
+}
+\value{
+A function with class <R7_method>.
 }
 \description{
-Generics partition a function into interface (a generic) and implementation
-(many methods). \verb{method<-} allows you to register a method, an
-implementation for a specified class signature, with a generic.
-
-\code{method()} retrieves a method for a given signature. You typically shouldn't
-need this function while programming, because calling the generic will
-automatically dispatch to the correct method, but it's often useful
-interactively in order to see the implementation of a specific method.
+\code{method()} takes a generic and signature and retrieves the corresponding
+method. This is rarely needed because most of the time you'll rely on the
+the generic, via \code{\link[=method_call]{method_call()}}, to find and call the method for you.
+However, this introspection is useful if you want to see the implementation
+of a specific method.
 }
 \examples{
-# Create a generic
+# Create a generic and register some methods
 bizarro <- new_generic(""bizarro"", dispatch_args = ""x"")
-# Register some methods
-method(bizarro, ""numeric"") <- function(x, ...) rev(x)
-method(bizarro, s3_class(""factor"")) <- function(x, ...) {
+method(bizarro, ""numeric"") <- function(x) rev(x)
+method(bizarro, s3_class(""factor"")) <- function(x) {
   levels(x) <- rev(levels(x))
   x
 }
-method(bizarro, s3_class(""data.frame"")) <- function(x, ...) {
-  x[] <- lapply(x, bizarro)
-  rev(x)
-}
 
-# Using a generic calls the methods automatically
-bizarro(1)
+# Printing the generic shows the registered method
+bizarro
 
-# But it can be useful to explicitly retrieve a method in order to
-# inspect its implementation
-method(bizarro, ""double"")
+# And you can use method() to inspect specific implementations
+method(bizarro, ""integer"")
 method(bizarro, s3_class(""factor""))
 }

---FILE: man/method_call.Rd---
@@ -1,11 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/dispatch.R
-\name{method_call}
-\alias{method_call}
-\title{Lookup the R7 method for the current generic and call it.}
-\usage{
-method_call()
-}
-\description{
-Lookup the R7 method for the current generic and call it.
-}

---FILE: man/new_external_generic.Rd---
@@ -2,17 +2,17 @@
 % Please edit documentation in R/external-generic.R
 \name{new_external_generic}
 \alias{new_external_generic}
-\alias{method_register}
+\alias{external_methods_register}
 \title{Generics in suggested packages}
 \usage{
-new_external_generic(package, generic, version = NULL)
+new_external_generic(package, name, version = NULL)
 
-method_register()
+external_methods_register()
 }
 \arguments{
 \item{package}{Package the generic is defined in.}
 
-\item{generic}{Name of generic, as a string.}
+\item{name}{Name of generic, as a string.}
 
 \item{version}{An optional version the package must meet for the method to
 be registered.}
@@ -26,9 +26,9 @@ not always desired. For example, you might want to register a
 but your package doesn't use anything else from knitr.
 
 Instead, you can add the package to \code{Suggests} and use
-\code{new_external_generic()} along with \code{method_register()} to declare an
-""external"" generic. \code{new_external_generic()} defines the ""shape"" of the
+\code{new_external_generic()} along with \code{external_methods_register()} to declare
+an ""external"" generic. \code{new_external_generic()} defines the ""shape"" of the
 generic without requiring the other package be available. You then call
-\code{method_register()} in \code{.onLoad()} to dynamically register the methods
-when the other package is loaded.
+\code{external_methods_register()} in \code{.onLoad()} to dynamically register the
+methods when the other package is loaded.
 }

---FILE: man/new_generic.Rd---
@@ -1,10 +1,13 @@
 % Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/generic.R
+% Please edit documentation in R/generic.R, R/dispatch.R
 \name{new_generic}
 \alias{new_generic}
+\alias{method_call}
 \title{Define a new generic}
 \usage{
 new_generic(name, fun = NULL, dispatch_args = NULL)
+
+method_call()
 }
 \arguments{
 \item{name}{The name of the generic. This should be the same as the object
@@ -16,18 +19,20 @@ automatically from the \code{dispatch_args}, but you may want to supply it if
 you want to add additional required arguments, or perform some standardised
 computation in the generic.}
 
-\item{dispatch_args}{A character vector providing the names of arguments to
-dispatch on.
+\item{dispatch_args}{A character vector giving the names of the arguments
+that form the signature, i.e. the arguments used for method dispatch.
 
 If \code{dispatch_args} are omitted, but \code{fun} is supplied, will default to the
 arguments that appear before \code{...} in \code{fun}. If there are no dots, it will
 default to the first argument. If both \code{fun} and \code{dispatch_args} are
 supplied, the \code{dispatch_args} must appear at the start of \code{fun}'s formals.}
 }
 \description{
-A generic function uses different implementations depending on the class
-of one or more arguments (the \code{signature}). Create a new generic with
-\code{new_generic()} then use \link{method<-} to add methods to it.
+A generic function uses different implementations (\emph{methods}) depending on
+the class of one or more arguments (the \emph{signature}). Create a new generic
+with \code{new_generic()} then use \link{method<-} to add methods to it. The body of
+the generic always contains \code{method_call()}, which takes care of finding and
+calling the appropriate method.
 }
 \section{Dispatch arguments}{
 

---FILE: man/next_method.Rd---
@@ -1,5 +1,5 @@
 % Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/method.R
+% Please edit documentation in R/dispatch.R
 \name{next_method}
 \alias{next_method}
 \title{Retrieve the next applicable method after the current one}

---FILE: src/dispatch.c---
@@ -14,7 +14,8 @@ Rboolean should_ignore(SEXP value, SEXP ignore) {
   return FALSE;
 }
 
-SEXP method_internal(SEXP table, SEXP signature, R_xlen_t signature_itr, SEXP ignore) {
+// Recursively walk through method table to perform iterated dispatch
+SEXP method_rec(SEXP table, SEXP signature, R_xlen_t signature_itr, SEXP ignore) {
   if (signature_itr >= Rf_xlength(signature)) {
     return R_NilValue;
   }
@@ -26,7 +27,7 @@ SEXP method_internal(SEXP table, SEXP signature, R_xlen_t signature_itr, SEXP ig
       SEXP klass = Rf_install(CHAR(STRING_ELT(Rf_getAttrib(classes, name_sym), 0)));
       SEXP val = Rf_findVarInFrame(table, klass);
       if (TYPEOF(val) == ENVSXP) {
-        val = method_internal(val, signature, signature_itr + 1, ignore);
+        val = method_rec(val, signature, signature_itr + 1, ignore);
       }
       if (TYPEOF(val) == CLOSXP && (ignore == R_NilValue || !should_ignore(val, ignore))) {
         return val;
@@ -38,7 +39,7 @@ SEXP method_internal(SEXP table, SEXP signature, R_xlen_t signature_itr, SEXP ig
       SEXP klass = Rf_install(CHAR(STRING_ELT(classes, i)));
       SEXP val = Rf_findVarInFrame(table, klass);
       if (TYPEOF(val) == ENVSXP) {
-        val = method_internal(val, signature, signature_itr + 1, ignore);
+        val = method_rec(val, signature, signature_itr + 1, ignore);
       }
       if (TYPEOF(val) == CLOSXP && (ignore == R_NilValue || !should_ignore(val, ignore))) {
         return val;
@@ -48,6 +49,37 @@ SEXP method_internal(SEXP table, SEXP signature, R_xlen_t signature_itr, SEXP ig
   return R_NilValue;
 }
 
+__attribute__ ((noreturn))
+void R7_method_lookup_error(SEXP generic, SEXP signature) {
+  static SEXP R7_method_lookup_error_fun = NULL;
+  SEXP ns = Rf_findVarInFrame(R_NamespaceRegistry, Rf_install(""R7""));
+
+  if (R7_method_lookup_error_fun == NULL) {
+    R7_method_lookup_error_fun = Rf_findVarInFrame(ns, Rf_install(""method_lookup_error""));
+  }
+  SEXP name = Rf_getAttrib(generic, Rf_install(""name""));
+  SEXP args = Rf_getAttrib(generic, Rf_install(""dispatch_args""));
+  SEXP R7_method_lookup_error_call = PROTECT(Rf_lang4(R7_method_lookup_error_fun, name, args, signature));
+  Rf_eval(R7_method_lookup_error_call, ns);
+
+  while(1);
+}
+
+SEXP method_(SEXP generic, SEXP signature, SEXP ignore) {
+  if (!Rf_inherits(generic, ""R7_generic"")) {
+    return R_NilValue;
+  }
+
+  SEXP table = Rf_getAttrib(generic, Rf_install(""methods""));
+
+  SEXP m = method_rec(table, signature, 0, ignore);
+  if (m == R_NilValue) {
+    R7_method_lookup_error(generic, signature);
+  }
+
+  return m;
+}
+
 SEXP get_class(SEXP object, SEXP envir) {
     static SEXP fun = NULL;
     if (fun == NULL) {
@@ -86,33 +118,10 @@ SEXP object_class_(SEXP object, SEXP envir) {
   return klass;
 }
 
-/* TODO: handle errors when method is not found */
-SEXP method_(SEXP generic, SEXP signature, SEXP ignore) {
-  if (!Rf_inherits(generic, ""R7_generic"")) {
-    return R_NilValue;
-  }
-
-  SEXP table = Rf_getAttrib(generic, Rf_install(""methods""));
-
-  return method_internal(table, signature, 0, ignore);
-}
-
 SEXP R7_object_() {
   return Rf_allocSExp(S4SXP);
 }
 
-void R7_method_lookup_error(SEXP generic, SEXP signature, SEXP envir) {
-  static SEXP R7_method_lookup_error_fun = NULL;
-  if (R7_method_lookup_error_fun == NULL) {
-    SEXP ns = Rf_findVarInFrame(R_NamespaceRegistry, Rf_install(""R7""));
-    R7_method_lookup_error_fun = Rf_findVarInFrame(ns, Rf_install(""method_lookup_error""));
-  }
-  SEXP name = Rf_getAttrib(generic, Rf_install(""name""));
-  SEXP args = Rf_getAttrib(generic, Rf_install(""dispatch_args""));
-  SEXP R7_method_lookup_error_call = PROTECT(Rf_lang4(R7_method_lookup_error_fun, name, args, signature));
-  Rf_eval(R7_method_lookup_error_call, envir);
-}
-
 SEXP method_call_(SEXP call, SEXP generic, SEXP envir) {
   int n_protect = 0;
 
@@ -169,9 +178,6 @@ SEXP method_call_(SEXP call, SEXP generic, SEXP envir) {
 
   // Now that we have all the classes, we can look up what method to call
   SEXP m = method_(generic, dispatch_classes, R_NilValue);
-  if (m == R_NilValue) {
-    R7_method_lookup_error(generic, dispatch_classes, envir);
-  }
   SETCAR(mcall, m);
 
   // And then call it

---FILE: tests/testthat/_snaps/dispatch.md---
@@ -20,3 +20,31 @@
     - x: <tbl_df>, <tbl>, <data.frame>
     - y: <POSIXct>, <POSIXt>
 
+# method(): errors on invalid inputs
+
+    Code
+      method(print, 1)
+    Error <simpleError>
+      `generic` must be an <R7_generic>
+    Code
+      foo <- (function(x) { })
+      method(foo, 1)
+    Error <simpleError>
+      `generic` must be an <R7_generic>
+    Code
+      method(foo, new_union(""integer"", ""double""))
+    Error <simpleError>
+      `generic` must be an <R7_generic>
+
+# errors if no method found
+
+    Code
+      method(foo, list())
+    Error <simpleError>
+      Can't find method for generic `foo()` with classes:
+      - x: 
+    Code
+      method(foo, list(""blah""))
+    Error <simpleError>
+      Can't convert `signature[[1]]` to a valid class. No base classes are called 'blah'
+

---FILE: tests/testthat/_snaps/method.md---
@@ -1,69 +1,59 @@
-# method errors on invalid inputs
-
-    Can't convert `signature[[1]]` to a valid class. Class specification must be an R7 class object, the result of `s3_class()`, an S4 class object, or a base constructor function, not a <double>.
-
----
-
-    Can't convert `signature[[1]]` to a valid class. Class specification must be an R7 class object, the result of `s3_class()`, an S4 class object, or a base constructor function, not a <double>.
-
----
-
-    Can't convert `signature[[1]]` to a valid class. Class specification must be an R7 class object, the result of `s3_class()`, an S4 class object, or a base constructor function, not a <logical>.
-
-# method errors if no method is defined for that class
+# method registration: S3 registration requires single R7 class
 
     Code
-      method(foo, list())
+      method(sum, list(foo, foo)) <- (function(x, ...) ""foo"")
     Error <simpleError>
-      Can't find method for generic `foo()` with classes:
-      - x: 
+      When registering methods for S3 generic sum(), signature be a single R7 class
     Code
-      method(foo, list(""blah""))
+      method(sum, s3_class(""foo"")) <- (function(x, ...) ""foo"")
     Error <simpleError>
-      Can't convert `signature[[1]]` to a valid class. No base classes are called 'blah'
+      When registering methods for S3 generic sum(), signature be a single R7 class
 
-# new_method works if you pass a bare class union
+# method registration: checks argument types
 
     Code
-      foo7
-    Output
-      <R7_generic> function (x, ...)  with 2 methods:
-      1: method(foo7, number)
-      2: method(foo7, text)
+      x <- 10
+      method(x, ""character"") <- (function(x) ...)
+    Error <simpleError>
+      `generic` must be a function, not a <double>
+    Code
+      method(foo, 1) <- (function(x) ...)
+    Error <simpleError>
+      Can't convert `signature[[1]]` to a valid class. Class specification must be an R7 class object, the result of `s3_class()`, an S4 class object, or a base constructor function, not a <double>.
 
-# method_compatible errors if the functions are not compatible
+# check_method errors if the functions are not compatible
 
     Code
       foo <- new_generic(""foo"", dispatch_args = ""x"")
-      method_compatible(function(y) { }, foo)
+      check_method(1, ""character"", foo)
     Error <simpleError>
-      `method` doesn't match generic dispatch arg
+      foo(<character>) must be a function
     Code
-      method_compatible(function(x = ""foo"") { }, foo)
+      check_method(function(y) { }, ""character"", foo)
     Error <simpleError>
-      Dispatch arguments must not have default values
+      foo() dispatches on `x`, but foo(<character>) has arguments `y`
     Code
-      method_compatible(function(x, y, ...) { }, foo)
+      check_method(function(x = ""foo"") { }, ""character"", foo)
     Error <simpleError>
-      ... must immediately follow dispatch args
+      In foo(<character>), dispatch arguments (`x`) must not have default values
+    Code
+      check_method(function(x, y, ...) { }, ""character"", foo)
+    Error <simpleError>
+      In foo(<character>), `...` must come immediately after dispatch args (`x`)
 
-# method_compatible warn if default arguments don't match
+# check_method warn if default arguments don't match
 
     Code
       foo <- new_generic(""foo"", function(x, ..., z = 2, y = 1) method_call())
-      method_compatible(function(x, ..., y = 1) { }, foo)
+      check_method(function(x, ..., y = 1) { }, ""character"", foo)
     Warning <simpleWarning>
-      Argument `z` is missing from method
-    Output
-      [1] TRUE
+      foo(<character>) doesn't have argument `z`
     Code
-      method_compatible(function(x, ..., y = 1, z = 1) { }, foo)
+      check_method(function(x, ..., y = 1, z = 1) { }, ""character"", foo)
     Warning <simpleWarning>
-      Default value is not the same as the generic
-      - Generic: z = 2
-      - Method:  z = 1
-    Output
-      [1] TRUE
+      In foo(<character>), default value of `z` is not the same as the generic
+      - Generic: 2
+      - Method:  1
 
 # R7_method printing
 

---FILE: tests/testthat/t0/R/pkg.R---
@@ -1,3 +1,3 @@
 #' @importFrom R7 method object_class
 #' @export
-bar <- R7::new_generic(""bar"", dispatch_args = c(""x"", ""y""))
+bar <- R7::new_generic(""bar"", dispatch_args = ""x"")

---FILE: tests/testthat/t1/R/foo.R---
@@ -1,3 +1,3 @@
 #' @importFrom R7 method object_class
 #' @export
-foo <- R7::new_generic(""foo"", dispatch_args = c(""x"", ""y""))
+foo <- R7::new_generic(""foo"", dispatch_args = ""x"")

---FILE: tests/testthat/t2/R/pkg.R---
@@ -1,11 +1,9 @@
 foo <- R7::new_external_generic(""t1"", ""foo"")
-
-R7::method(foo, list(""character"", ""numeric"")) <- function(x, y, ...) paste0(""foo-"", x, ""-"", y)
+R7::method(foo, ""character"") <- function(x) ""foo""
 
 bar <- R7::new_external_generic(""t0"", ""bar"")
-
-R7::method(bar, list(""character"", ""numeric"")) <- function(x, y, ...) paste0(""bar-"", x, ""-"", y)
+R7::method(bar, ""character"") <- function(x) ""bar""
 
 .onLoad <- function(libname, pkgname) {
-  R7::method_register()
+  R7::external_methods_register()
 }

---FILE: tests/testthat/test-dispatch.R---
@@ -1,3 +1,56 @@
+describe(""single dispatch"", {
+  foo <- new_generic(""foo"", dispatch_args = ""x"")
+
+  it(""works for base types"", {
+    method(foo, ""character"") <- function(x) ""base""
+
+    expect_equal(foo(""bar""), ""base"")
+  })
+
+  it(""works for R7 objects"", {
+    method(foo, text) <- function(x) ""R7""
+
+    expect_equal(foo(text(""bar"")), ""R7"")
+  })
+
+  it(""works for S3 objects"", {
+    obj <- structure(""hi"", class = ""my_s3"")
+    method(foo, s3_class(""my_s3"")) <- function(x) ""S3""
+
+    expect_equal(foo(obj), ""S3"")
+  })
+
+  it(""works for S4 objects"", {
+    my_S4 <- setClass(""my_S4"", contains = ""numeric"")
+    method(foo, my_S4) <- function(x) ""S4""
+
+    expect_equal(foo(my_S4(1)), ""S4"")
+  })
+
+  it(""works for unions"", {
+    method(foo, new_union(number, ""integer"")) <- function(x) ""union""
+
+    expect_equal(foo(number(1)), ""union"")
+    expect_equal(foo(1L), ""union"")
+  })
+})
+
+describe(""multiple dispatch"", {
+  it(""works directly"", {
+    foo <- new_generic(""foo3"", dispatch_args = c(""x"", ""y""))
+    method(foo, list(text, number)) <- function(x, y) paste0(x, y)
+    expect_equal(foo(text(""bar""), number(1)), ""bar1"")
+  })
+
+  it(""works via inheritance"", {
+    foo <- new_generic(""foo"", dispatch_args = c(""x"", ""y""))
+    method(foo, list(""character"", ""numeric"")) <- function(x, y) paste0(x, "":"", y)
+
+    expect_equal(foo(text(""bar""), number(1)), ""bar:1"")
+  })
+})
+
+
 test_that(""can substitute() args"", {
   foo <- new_generic(""foo"", function(x, ..., z = 1) method_call())
   method(foo, ""character"") <- function(x, ..., z = 1) substitute(x)
@@ -69,3 +122,59 @@ test_that(""method lookup fails with informative messages"", {
   expect_snapshot_error(foo(TRUE, list()))
   expect_snapshot_error(foo(tibble::tibble(), .POSIXct(double())))
 })
+
+describe(""method()"", {
+  it(""errors on invalid inputs"", {
+
+    expect_snapshot(error = TRUE, {
+      method(print, 1)
+
+      foo <- function(x) {}
+      method(foo, 1)
+      method(foo, new_union(""integer"", ""double""))
+    })
+  })
+
+  test_that(""errors if no method found"", {
+    foo <- new_generic(""foo"", dispatch_args = ""x"")
+
+    expect_snapshot(error = TRUE, {
+      method(foo, list())
+      method(foo, list(""blah""))
+    })
+  })
+})
+
+test_that(""next_method works for single dispatch"", {
+  foo <- new_generic(""foo"", dispatch_args = ""x"")
+
+  method(foo, text) <- function(x, ...) {
+    r7_data(x) <- paste0(""foo-"", r7_data(x))
+  }
+  method(foo, ""character"") <- function(x, ...) {
+    as.character(x)
+  }
+
+  expect_equal(foo(text(""hi"")), ""foo-hi"")
+})
+
+test_that(""next_method works for double dispatch"", {
+  foo <- new_generic(""foo"", dispatch_args = c(""x"", ""y""))
+
+  method(foo, list(text, number)) <- function(x, y, ...) {
+    r7_data(x) <- paste0(""foo-"", r7_data(x), ""-"", r7_data(y))
+    next_method()(x, y)
+  }
+
+  method(foo, list(character, number)) <- function(x, y, ...) {
+    r7_data(y) <- y + 1
+    r7_data(x) <- paste0(r7_data(x), ""-"", r7_data(y))
+    next_method()(x, y)
+  }
+
+  method(foo, list(character, double)) <- function(x, y, ...) {
+    as.character(r7_data(x))
+  }
+
+  expect_equal(foo(text(""hi""), number(1)), ""foo-hi-1-2"")
+})

---FILE: tests/testthat/test-external-generic.R---
@@ -1,3 +1,22 @@
+test_that(""can get and append methods"", {
+  on.exit(external_methods_reset(""R7""), add = TRUE)
+
+  expect_equal(external_methods_get(""R7""), list())
+
+  bar <- new_external_generic(""foo"", ""bar"")
+  external_methods_add(""R7"", bar, list(), function() {})
+  expect_equal(
+    external_methods_get(""R7""),
+    list(
+      list(
+        generic = bar,
+        signature = list(),
+        method = function() {}
+      )
+    )
+  )
+})
+
 test_that(""new_method works with both hard and soft dependencies"", {
   skip_on_os(""windows"")
   skip_if(quick_test())
@@ -15,14 +34,13 @@ test_that(""new_method works with both hard and soft dependencies"", {
   })
 
   quick_install(test_path(c(""t0"", ""t1"", ""t2"")))
-
   library(""t2"")
 
   # t2 has a soft dependency on t1
   library(""t1"")
-  expect_equal(foo(""blah"", 1), ""foo-blah-1"")
+  expect_equal(foo(""x""), ""foo"")
 
   # t2 has a hard dependency on t0
   library(""t0"")
-  expect_equal(bar(""blah"", 1), ""bar-blah-1"")
+  expect_equal(bar(""x""), ""bar"")
 })

---FILE: tests/testthat/test-method.R---
@@ -1,172 +1,94 @@
-test_that(""method will fall back to S3 generics if no R7 generic is defined"", {
-  expect_equal(
-    method(print, list(text)),
-    base::print.default
-  )
-})
-
-test_that(""method will accept a character vector (#71)"", {
-  expect_equal(
-    method(print, ""character""),
-    base::print.default
-  )
-})
-
-test_that(""method errors on invalid inputs"", {
-  expect_snapshot_error(
-    method(print, 1)
-  )
-  expect_snapshot_error(
-    method(print, list(1))
-  )
-
-  expect_snapshot_error(
-    method(print, list(TRUE, FALSE))
-  )
-})
-
-test_that(""method errors if no method is defined for that class"", {
-  foo <- new_generic(""foo"", dispatch_args = ""x"")
-
-  expect_snapshot(error = TRUE, {
-    method(foo, list())
-    method(foo, list(""blah""))
+describe(""method registration"", {
+  it(""adds methods to the generic"", {
+    foo <- new_generic(""foo"", dispatch_args = ""x"")
+    method(foo, ""character"") <- function(x) ""c""
+    method(foo, ""integer"") <- function(x) ""i""
+    expect_length(methods(foo), 2)
   })
-})
-
-test_that(""methods can be registered for a generic and then called"", {
-  foo <- new_generic(""foo"", dispatch_args = ""x"")
-  new_method(foo, text, function(x, ...) paste0(""foo-"", r7_data(x)))
-
-  expect_equal(foo(text(""bar"")), ""foo-bar"")
-})
-
-test_that(""single inheritance works when searching for methods"", {
-  foo2 <- new_generic(""foo2"", dispatch_args = ""x"")
-
-  new_method(foo2, ""character"", function(x, ...) paste0(""foo2-"", x))
-
-  expect_equal(foo2(text(""bar"")), ""foo2-bar"")
-})
-
-test_that(""direct multiple dispatch works"", {
-  foo3 <- new_generic(""foo3"", dispatch_args = c(""x"", ""y""))
-  new_method(foo3, list(text, number), function(x, y, ...) paste0(x, y))
-  expect_equal(foo3(text(""bar""), number(1)), ""bar1"")
-})
 
-test_that(""inherited multiple dispatch works"", {
-  foo4 <- new_generic(""foo4"", dispatch_args = c(""x"", ""y""))
-  new_method(foo4, list(""character"", ""numeric""), function(x, y, ...) paste0(x, "":"", y))
-
-  expect_equal(foo4(text(""bar""), number(1)), ""bar:1"")
-})
-
-test_that(""method dispatch works for S3 objects"", {
-  foo <- new_generic(""foo"", dispatch_args = ""x"")
-  obj <- structure(""hi"", class = ""my_s3"")
-  new_method(foo, s3_class(""my_s3""), function(x, ...) paste0(""foo-"", x))
-
-  expect_equal(foo(obj), ""foo-hi"")
-})
-
-test_that(""method dispatch works for S4 objects"", {
-  skip_if_not(requireNamespace(""methods""))
-
-  foo <- new_generic(""foo"", dispatch_args = ""x"")
-
-  Range <- setClass(""Range"", slots = c(start = ""numeric"", end = ""numeric""))
-  new_method(foo, Range, function(x, ...) paste0(""foo-"", x@start, ""-"", x@end))
-
-  obj <- Range(start = 1, end = 10)
-  expect_equal(foo(obj), ""foo-1-10"")
-})
-
-test_that(""new_method works if you use R7 class objects"", {
-  foo5 <- new_generic(""foo5"", dispatch_args = c(""x"", ""y""))
-  new_method(foo5, list(text, number), function(x, y, ...) paste0(x, "":"", y))
-
-  expect_equal(foo5(text(""bar""), number(1)), ""bar:1"")
-})
-
-test_that(""new_method works if you pass a bare class"", {
-  foo6 <- new_generic(""foo6"", dispatch_args = ""x"")
-  new_method(foo6, text, function(x, ...) paste0(""foo-"", x))
-
-  expect_equal(foo6(text(""bar"")), ""foo-bar"")
-})
+  it(""adds method for each element of a union"", {
+    foo <- new_generic(""foo"", dispatch_args = ""x"")
+    method(foo, ""numeric"") <- function(x) ""x""
 
-test_that(""new_method works if you pass a bare class union"", {
-  foo7 <- new_generic(""foo7"", dispatch_args = ""x"")
-  new_method(foo7, new_union(text, number), function(x, ...) paste0(""foo-"", x))
+    # one method for each union component
+    expect_length(methods(foo), 2)
 
-  expect_equal(foo7(text(""bar"")), ""foo-bar"")
-  expect_equal(foo7(number(1)), ""foo-1"")
+    # each method has the expected signature
+    expect_equal(method(foo, ""integer"")@signature, as_signature(""integer""))
+    expect_equal(method(foo, ""double"")@signature, as_signature(""double""))
+  })
 
-  # one method for each union component
-  expect_length(methods(foo7), 2)
-  # and methods printed nicely
-  expect_snapshot(foo7)
-})
+  it(""can register method for external generic from within package"", {
+    on.exit(external_methods_reset(""R7""), add = TRUE)
 
-test_that(""next_method works for single dispatch"", {
-  foo <- new_generic(""foo"", dispatch_args = ""x"")
+    foo <- new_external_generic(""foo"", ""bar"")
+    register_method(foo, ""character"", function(x, ...) ""bar"", package = ""R7"")
+    expect_length(external_methods_get(""R7""), 1)
 
-  new_method(foo, text, function(x, ...) {
-    r7_data(x) <- paste0(""foo-"", r7_data(x))
-  })
-  new_method(foo, ""character"", function(x, ...) {
-    as.character(x)
+    # and doesn't modify generic
+    expect_s3_class(foo, ""R7_external_generic"")
   })
 
-  expect_equal(foo(text(""hi"")), ""foo-hi"")
-})
+  it(""can register method for external generic during development"", {
+    bar <- new_class(""bar"")
+    base_sum <- new_external_generic(""base"", ""sum"")
+    register_method(base_sum, bar, function(x, ...) ""bar"", package = NULL)
+    expect_equal(sum(bar()), ""bar"")
+  })
 
-test_that(""next_method works for double dispatch"", {
-  foo <- new_generic(""foo"", dispatch_args = c(""x"", ""y""))
+  it(""can register R7 method for S3 generic"", {
+    foo <- new_class(""foo"")
+    method(sum, foo) <- function(x, ...) ""foo""
+    expect_equal(sum(foo()), ""foo"")
 
-  new_method(foo, list(text, number), function(x, y, ...) {
-    r7_data(x) <- paste0(""foo-"", r7_data(x), ""-"", r7_data(y))
-    next_method()(x, y)
+    # and doesn't modify generic
+    expect_equal(sum, base::sum)
   })
 
-  new_method(foo, list(character, number), function(x, y, ...) {
-    r7_data(y) <- y + 1
-    r7_data(x) <- paste0(r7_data(x), ""-"", r7_data(y))
-    next_method()(x, y)
+  it(""S3 registration requires single R7 class"", {
+    foo <- new_class(""foo"")
+    expect_snapshot(error = TRUE, {
+      method(sum, list(foo, foo)) <- function(x, ...) ""foo""
+      method(sum, s3_class(""foo"")) <- function(x, ...) ""foo""
+    })
   })
 
-  new_method(foo, list(character, double), function(x, y, ...) {
-    as.character(r7_data(x))
+  it(""checks argument types"", {
+    foo <- new_generic(""foo"", dispatch_args = ""x"")
+    expect_snapshot(error = TRUE, {
+      x <- 10
+      method(x, ""character"") <- function(x) ...
+      method(foo, 1) <- function(x) ...
+    })
   })
-
-  expect_equal(foo(text(""hi""), number(1)), ""foo-hi-1-2"")
 })
 
-test_that(""method_compatible returns TRUE if the functions are compatible"", {
+
+test_that(""check_method returns TRUE if the functions are compatible"", {
   foo <- new_generic(""foo"", function(x, ...) method_call())
-  expect_true(method_compatible(function(x, ...) x, foo))
+  expect_true(check_method(function(x, ...) x, ""character"", foo))
   # extra arguments are ignored
-  expect_true(method_compatible(function(x, ..., y) x, foo))
+  expect_true(check_method(function(x, ..., y) x, ""character"", foo))
 
   foo <- new_generic(""foo"", function(x) method_call())
-  expect_true(method_compatible(function(x) x, foo))
+  expect_true(check_method(function(x) x, ""character"", foo))
 })
 
-test_that(""method_compatible errors if the functions are not compatible"", {
+test_that(""check_method errors if the functions are not compatible"", {
   expect_snapshot(error = TRUE, {
     foo <- new_generic(""foo"", dispatch_args = ""x"")
-    method_compatible(function(y) {}, foo)
-    method_compatible(function(x = ""foo"") {}, foo)
-    method_compatible(function(x, y, ...) {}, foo)
+    check_method(1, ""character"", foo)
+    check_method(function(y) {}, ""character"", foo)
+    check_method(function(x = ""foo"") {}, ""character"", foo)
+    check_method(function(x, y, ...) {}, ""character"", foo)
   })
 })
 
-test_that(""method_compatible warn if default arguments don't match"", {
+test_that(""check_method warn if default arguments don't match"", {
   expect_snapshot({
     foo <- new_generic(""foo"", function(x, ..., z = 2, y = 1) method_call())
-    method_compatible(function(x, ..., y = 1) {}, foo)
-    method_compatible(function(x, ..., y = 1, z = 1) {}, foo)
+    check_method(function(x, ..., y = 1) {}, ""character"", foo)
+    check_method(function(x, ..., y = 1, z = 1) {}, ""character"", foo)
   })
 })
 "
RConsortium,S7,7adda8926eca086c4185f7ef0b7b6815cbdb8cce,Hadley Wickham,h.wickham@gmail.com,2022-02-10T18:02:36Z,GitHub,noreply@github.com,2022-02-10T18:02:36Z,"Validation improvements (#149)

* `validate()` checks properties types, then recursively checks object
* Error when setting property that doesn't exist
* Property multi-assignment
* Documentation and test improvements",NAMESPACE;NEWS.md;R/class.R;R/data.R;R/object.R;R/property.R;R/valid.R;R/zzz.R;man/new_class.Rd;man/prop.Rd;man/r7_data.Rd;man/validate.Rd;tests/testthat/_snaps/class.md;tests/testthat/_snaps/object.md;tests/testthat/_snaps/property.md;tests/testthat/_snaps/valid.md;tests/testthat/test-class.R;tests/testthat/test-method.R;tests/testthat/test-object.R;tests/testthat/test-property.R;tests/testthat/test-valid.R,False,True,True,False,367,97,464,"---FILE: NAMESPACE---
@@ -13,6 +13,7 @@ S3method(str,R7_union)
 export(""@"")
 export(""method<-"")
 export(""prop<-"")
+export(""props<-"")
 export(""r7_data<-"")
 export(R7_object)
 export(as_class)
@@ -37,6 +38,7 @@ export(r7_data)
 export(s3_class)
 export(valid_eventually)
 export(valid_implicitly)
+export(validate)
 importFrom(stats,setNames)
 importFrom(utils,getFromNamespace)
 importFrom(utils,getS3method)

---FILE: NEWS.md---
@@ -2,6 +2,10 @@
 
 ## Jan 2020
 
+* New `props<-` for setting multiple properties simultaneously and validating
+  afterwards (#149).
+* Validation now happens recursively, and validates types before validating 
+  the object (#149)
 * Classes (base types, S3, S4, and R7) are handled consistently wherever they
   are used. Strings now only refer to base types. New explicit `s3_class()` for 
   referring to S3 classes (#134). S4 unions are converted to R7 unions (#150).

---FILE: R/class.R---
@@ -50,10 +50,20 @@ is_class <- function(x) inherits(x, ""R7_class"")
 #'
 #' @param constructor The constructor function. This is optional, unless
 #'   you want to control which properties can be set on constructor.
-#' @param validator A function used to determine whether or not an object
-#'   is valid. This is called automatically after construction, and
-#'   whenever any property is set. It should return `NULL` if the object is
-#'   valid, and otherwise return a character vector of problems.
+#' @param validator A function taking a single argument, the object to validate.
+#'
+#'   The job of a validator is to determine whether the object is valid,
+#'   i.e. if the current property values form an allowed combination. The
+#'   types of the properties are always automatically validator so the job of
+#'   the validator is to verify that the value of individual properties is
+#'   ok (i.e. maybe a property should have length 1, or should always be
+#'   positive), or that the combination of values of multiple properties is ok.
+#'   It is called after construction and whenever any property is set.
+#'
+#'   The validator should return `NULL` if the object is valid. If not, it
+#'   should return a character vector where each element describes a single
+#'   problem. It's generally helpful to report as many problems at once
+#'   as possible.
 #' @param properties A list specifying the properties (data) that
 #'   every object of the class will possess. Each property can either be
 #'   a named string (specifying the class), or a call to [new_property()],

---FILE: R/data.R---
@@ -5,6 +5,7 @@
 #' and all properties.
 #'
 #' @inheritParams prop
+#' @param value Object used to replace the underlying data.
 #' @export
 #' @examples
 #' text <- new_class(""text"", parent = ""character"")

---FILE: R/object.R---
@@ -26,38 +26,16 @@ new_object <- function(.data = NULL, ...) {
   }
 
   if (!is.null(.data)) {
-    # TODO eliminate this special case
-    if (obj_cls@name %in% names(base_types)) {
-      if (!inherits(.data, obj_cls@name)) {
-        stop(sprintf(
-          ""`.data` must be %s not %s"",
-          class_desc(as_class(obj_cls@name)),
-          obj_desc(.data)
-        ))
-      }
-    } else {
-      if (!class_inherits(.data, obj_cls@parent)) {
-        stop(sprintf(
-          ""`.data` must be %s not %s"",
-          class_desc(obj_cls@parent),
-          obj_desc(.data)
-        ))
-      }
-    }
-
     object <- .data
   } else {
     object <- obj_cls@parent@constructor()
   }
-  attr(object, "".should_validate"") <- FALSE
 
   class(object) <- ""R7_object""
   object_class(object) <- obj_cls
   for (nme in nms) {
-    prop(object, nme) <- args[[nme]]
+    prop(object, nme, check = FALSE) <- args[[nme]]
   }
-
-  attr(object, "".should_validate"") <- NULL
   validate(object)
 
   object

---FILE: R/property.R---
@@ -91,14 +91,16 @@ str.R7_property <- function(object, ..., nest.lev = 0) {
 #'   rather than throwing an error.
 #' - `prop<-` and `@<-` set a new value for the given property.
 #' - `props()` returns a list of all properties
+#' - `props<-` sets multiple properties at once, validating once after all are set.
 #' - `prop_names()` returns the names of the properties
 #' - `prop_exists(x, ""prop"")` returns `TRUE` iif `x` has property `prop`.
 #'
 #' @param object An object from a R7 class
 #' @param name The name of the parameter as a character. Partial matching
 #'   is not performed.
-#' @param value A replacement value for the parameter. The object is
-#'   automatically checked for validity after the replacement is done.
+#' @param value For `prop<-`, a replacement value for the property;
+#'   for `props<-`, a named list of values. The object is automatically
+#'   checked for validity after the replacement is done.
 #' @export
 #' @examples
 #' horse <- new_class(""horse"", properties = list(
@@ -119,7 +121,7 @@ prop <- function(object, name) {
   if (!inherits(object, ""R7_object"")) {
     stop(""`object` is not an <R7_object>"")
   } else if (!prop_exists(object, name)) {
-    stop(sprintf(""Can't find property %s@%s"", obj_desc(object), name))
+    stop(prop_error_unknown(object, name))
   } else {
     prop_val(object, name)
   }
@@ -183,6 +185,19 @@ props <- function(object) {
   }
 }
 
+#' @rdname prop
+#' @export
+`props<-` <- function(object, value) {
+  stopifnot(is.list(value))
+
+  for (name in names(value)) {
+    prop(object, name, check = FALSE) <- value[[name]]
+  }
+  validate(object)
+
+  object
+}
+
 #' @rdname prop
 #' @export
 prop_exists <- function(object, name) {
@@ -199,29 +214,42 @@ prop_exists <- function(object, name) {
 
   function(object, name, check = TRUE, value) {
     prop <- prop_obj(object, name)
+    if (is.null(prop)) {
+      stop(prop_error_unknown(object, name))
+    }
+
     if (!is.null(prop$setter) && !identical(setter_property, name)) {
       setter_property <<- name
       on.exit(setter_property <<- NULL, add = TRUE)
       object <- prop$setter(object, value)
     } else {
       if (isTRUE(check) && !class_inherits(value, prop$class)) {
-        stop(sprintf(""%s@%s must be of class %s, not %s"",
-          obj_desc(object), name,
-          class_desc(prop$class),
-          obj_desc(value)
-        ), call. = FALSE)
+        stop(prop_error_type(object, name, prop$class, value), call. = FALSE)
       }
       attr(object, name) <- value
     }
 
     if (isTRUE(check)) {
-      validate(object)
+      validate(object, properties = FALSE)
     }
 
     invisible(object)
   }
 })
 
+prop_error_unknown <- function(object, prop_name) {
+  sprintf(""Can't find property %s@%s"", obj_desc(object), prop_name)
+}
+
+prop_error_type <- function(object, prop_name, expected, actual) {
+  sprintf(""%s@%s must be of class %s, not %s"",
+    obj_desc(object),
+    prop_name,
+    class_desc(expected),
+    obj_desc(actual)
+  )
+}
+
 #' @rdname prop
 #' @usage object@name
 #' @export

---FILE: R/valid.R---
@@ -1,41 +1,119 @@
-#' Validation of R7 objects
+#' Validate an R7 object
 #'
-#' [validate()] calls the validation of an R7 object. This is done
-#' automatically when creating new objects (at the end of [new_object]) and
-#' when setting any property.
+#' @description
+#' `validate()` ensures that an R7 object is valid by calling the `validator`
+#' provided in [new_class()]. This is done automatically when constructing new
+#' objects and when modifying properties.
 #'
-#' [valid_eventually()] disables validation of properties, runs a function on
-#' the object, then validates the object.
+#' `valid_eventually()` disables validation, modifies the object, then
+#' revalidates. This is useful when a sequence of operations would otherwise
+#' lead an object to be temporarily invalid, or when repeated property
+#' modification causes a performance bottleneck because the validator is
+#' relatively expensive.
 #'
-#' [valid_implicitly()] does the same but does not validate the object at the end.
-#'
-#' [valid_implicitly()] should only be used rarely in performance critical code
-#' where you are certain a sequence of operations cannot produce an invalid
-#' object.
+#' `valid_implicitly()` does the same but does not validate the object at the
+#' end. It should only be used rarely, and in performance critical code where
+#' you are certain a sequence of operations cannot produce an invalid object.
 #' @param object An R7 object
 #' @param fun A function to call on the object before validation.
-validate <- function(object) {
+#' @param properties If `TRUE`, the default, checks property types before
+#'   executing the validator.
+#' @export
+#' @examples
+#' # A range class might validate that the start is less than the end
+#' Range <- new_class(""Range"",
+#'   properties = list(start = ""double"", end = ""double""),
+#'   validator = function(object) {
+#'     if (object@start >= object@end) ""start must be smaller than end""
+#'   }
+#' )
+#' # You can't construct an invalid object:
+#' try(Range(1, 1))
+#'
+#' # And you can't create an invalid object with @<-
+#' r <- Range(1, 2)
+#' try(r@end <- 1)
+#'
+#' # But what if you want to move a range to the right?
+#' rightwards <- function(r, x) {
+#'   r@start <- r@start + x
+#'   r@end <- r@end + x
+#'   r
+#' }
+#' # This function doesn't work because it creates a temporarily invalid state
+#' try(rightwards(r, 10))
+#'
+#' # This is the perfect use case for valid_eventually():
+#' rightwards <- function(r, x) {
+#'   valid_eventually(r, function(object) {
+#'     object@start <- object@start + x
+#'     object@end <- object@end + x
+#'     object
+#'   })
+#' }
+#' rightwards(r, 10)
+#'
+#' # Alternatively, you can set multiple properties at once using props<-,
+#' # which validates once at the end
+#' rightwards <- function(r, x) {
+#'   props(r) <- list(start = r@start + x, end = r@end + x)
+#'   r
+#' }
+#' rightwards(r, 20)
+validate <- function(object, properties = TRUE) {
   if (!is.null(attr(object, "".should_validate""))) {
     return(invisible(object))
   }
 
-  obj_class <- object_class(object)
+  class <- object_class(object)
 
-  validator <- prop_safely(obj_class, ""validator"")
-  if (is.null(validator)) {
-    return(invisible(object))
+  # First, check property types - if these are incorrect, the validator
+  # is likely to return spurious errors
+  if (properties) {
+    errors <- validate_properties(object, class)
+    if (length(errors) > 0) {
+      bullets <- paste0(""- "", errors, collapse = ""\n"")
+      msg <- sprintf(""%s object properties are invalid:\n%s"", obj_desc(object), bullets)
+      stop(msg, call. = FALSE)
+    }
   }
 
-  errors <- validator(object)
+  # Next, recursively validate the object
+  errors <- character()
+  while(!is.null(class) && is_class(class)) {
+    errors <- c(errors, class@validator(object))
+    class <- prop_safely(class, ""parent"")
+  }
 
+  # If needed, report errors
   if (length(errors) > 0) {
-    msg <- sprintf(""Invalid <%s> object:\n%s"", obj_class@name, paste0(""- "", errors, collapse = ""\n""))
+    bullets <- paste0(""- "", errors, collapse = ""\n"")
+    msg <- sprintf(""%s object is invalid:\n%s"", obj_desc(object), bullets)
     stop(msg, call. = FALSE)
   }
 
   invisible(object)
 }
 
+validate_properties <- function(object, class) {
+  errors <- character()
+
+  for (prop in class@properties) {
+    # Only validate static properties
+    if (!is.null(prop$getter) || !is.null(prop$setter)) {
+      next
+    }
+
+    value <- prop(object, prop$name)
+    if (!class_inherits(value, prop$class)) {
+      errors <- c(errors, prop_error_type(object, prop$name, prop$class, value))
+    }
+    prop
+  }
+
+  errors
+}
+
 #' @rdname validate
 #' @export
 valid_eventually <- function(object, fun) {
@@ -44,6 +122,8 @@ valid_eventually <- function(object, fun) {
   out <- fun(object)
   attr(out, "".should_validate"") <- old
   validate(out)
+
+  out
 }
 
 #' @rdname validate
@@ -53,5 +133,6 @@ valid_implicitly <- function(object, fun) {
   attr(object, "".should_validate"") <- FALSE
   out <- fun(object)
   attr(out, "".should_validate"") <- old
-  invisible(out)
+
+  out
 }

---FILE: R/zzz.R---
@@ -13,7 +13,16 @@ R7_object <- new_class(
 )
 
 new_base_class <- function(name) {
-  R7_class(name = name, constructor = function(.data) new_object(.data))
+  new_class(
+    name = name,
+    constructor = function(.data) new_object(.data),
+    validator = function(object) {
+      data <- unclass(object)
+      if (!name %in% .class2(data)) {
+        sprintf(""Underlying data must be <%s> not %s"", name, obj_desc(data))
+      }
+    }
+  )
 }
 
 # Define simple base types with constructors. See .onLoad() for more
@@ -47,7 +56,7 @@ R7_generic <- new_class(
 
 R7_method <- new_class(
   name = ""R7_method"",
-  properties = list(generic = R7_generic, signature = ""list"", fun = ""function""),
+  properties = list(generic = R7_generic, signature = ""list""),
   parent = ""function"",
   constructor = function(generic, signature, fun) {
     if (is.character(signature)) {

---FILE: man/new_class.Rd---
@@ -30,10 +30,20 @@ allowing greater flexibility.}
 \item{constructor}{The constructor function. This is optional, unless
 you want to control which properties can be set on constructor.}
 
-\item{validator}{A function used to determine whether or not an object
-is valid. This is called automatically after construction, and
-whenever any property is set. It should return \code{NULL} if the object is
-valid, and otherwise return a character vector of problems.}
+\item{validator}{A function taking a single argument, the object to validate.
+
+The job of a validator is to determine whether the object is valid,
+i.e. if the current property values form an allowed combination. The
+types of the properties are always automatically validator so the job of
+the validator is to verify that the value of individual properties is
+ok (i.e. maybe a property should have length 1, or should always be
+positive), or that the combination of values of multiple properties is ok.
+It is called after construction and whenever any property is set.
+
+The validator should return \code{NULL} if the object is valid. If not, it
+should return a character vector where each element describes a single
+problem. It's generally helpful to report as many problems at once
+as possible.}
 }
 \value{
 A object constructor, a function that can be used to create objects

---FILE: man/prop.Rd---
@@ -5,6 +5,7 @@
 \alias{prop_safely}
 \alias{prop_names}
 \alias{props}
+\alias{props<-}
 \alias{prop_exists}
 \alias{prop<-}
 \alias{@}
@@ -18,6 +19,8 @@ prop_names(object)
 
 props(object)
 
+props(object) <- value
+
 prop_exists(object, name)
 
 prop(object, name, check = TRUE) <- value
@@ -30,11 +33,12 @@ object@name
 \item{name}{The name of the parameter as a character. Partial matching
 is not performed.}
 
+\item{value}{For \verb{prop<-}, a replacement value for the property;
+for \verb{props<-}, a named list of values. The object is automatically
+checked for validity after the replacement is done.}
+
 \item{check}{If \code{TRUE}, check that \code{value} is of the correct type and run
 \code{\link[=validate]{validate()}} on the object before returning.}
-
-\item{value}{A replacement value for the parameter. The object is
-automatically checked for validity after the replacement is done.}
 }
 \description{
 \itemize{
@@ -44,6 +48,7 @@ error if the property doesn't exist for that object.
 rather than throwing an error.
 \item \verb{prop<-} and \verb{@<-} set a new value for the given property.
 \item \code{props()} returns a list of all properties
+\item \verb{props<-} sets multiple properties at once, validating once after all are set.
 \item \code{prop_names()} returns the names of the properties
 \item \code{prop_exists(x, ""prop"")} returns \code{TRUE} iif \code{x} has property \code{prop}.
 }

---FILE: man/r7_data.Rd---
@@ -15,8 +15,7 @@ r7_data(object, check = TRUE) <- value
 \item{check}{If \code{TRUE}, check that \code{value} is of the correct type and run
 \code{\link[=validate]{validate()}} on the object before returning.}
 
-\item{value}{A replacement value for the parameter. The object is
-automatically checked for validity after the replacement is done.}
+\item{value}{Object used to replace the underlying data.}
 }
 \description{
 When an R7 class inherits from an existing base type, it can be useful

---FILE: man/validate.Rd---
@@ -4,9 +4,9 @@
 \alias{validate}
 \alias{valid_eventually}
 \alias{valid_implicitly}
-\title{Validation of R7 objects}
+\title{Validate an R7 object}
 \usage{
-validate(object)
+validate(object, properties = TRUE)
 
 valid_eventually(object, fun)
 
@@ -15,20 +15,65 @@ valid_implicitly(object, fun)
 \arguments{
 \item{object}{An R7 object}
 
+\item{properties}{If \code{TRUE}, the default, checks property types before
+executing the validator.}
+
 \item{fun}{A function to call on the object before validation.}
 }
 \description{
-\code{\link[=validate]{validate()}} calls the validation of an R7 object. This is done
-automatically when creating new objects (at the end of \link{new_object}) and
-when setting any property.
+\code{validate()} ensures that an R7 object is valid by calling the \code{validator}
+provided in \code{\link[=new_class]{new_class()}}. This is done automatically when constructing new
+objects and when modifying properties.
+
+\code{valid_eventually()} disables validation, modifies the object, then
+revalidates. This is useful when a sequence of operations would otherwise
+lead an object to be temporarily invalid, or when repeated property
+modification causes a performance bottleneck because the validator is
+relatively expensive.
+
+\code{valid_implicitly()} does the same but does not validate the object at the
+end. It should only be used rarely, and in performance critical code where
+you are certain a sequence of operations cannot produce an invalid object.
+}
+\examples{
+# A range class might validate that the start is less than the end
+Range <- new_class(""Range"",
+  properties = list(start = ""double"", end = ""double""),
+  validator = function(object) {
+    if (object@start >= object@end) ""start must be smaller than end""
+  }
+)
+# You can't construct an invalid object:
+try(Range(1, 1))
+
+# And you can't create an invalid object with @<-
+r <- Range(1, 2)
+try(r@end <- 1)
+
+# But what if you want to move a range to the right?
+rightwards <- function(r, x) {
+  r@start <- r@start + x
+  r@end <- r@end + x
+  r
 }
-\details{
-\code{\link[=valid_eventually]{valid_eventually()}} disables validation of properties, runs a function on
-the object, then validates the object.
+# This function doesn't work because it creates a temporarily invalid state
+try(rightwards(r, 10))
 
-\code{\link[=valid_implicitly]{valid_implicitly()}} does the same but does not validate the object at the end.
+# This is the perfect use case for valid_eventually():
+rightwards <- function(r, x) {
+  valid_eventually(r, function(object) {
+    object@start <- object@start + x
+    object@end <- object@end + x
+    object
+  })
+}
+rightwards(r, 10)
 
-\code{\link[=valid_implicitly]{valid_implicitly()}} should only be used rarely in performance critical code
-where you are certain a sequence of operations cannot produce an invalid
-object.
+# Alternatively, you can set multiple properties at once using props<-,
+# which validates once at the end
+rightwards <- function(r, x) {
+  props(r) <- list(start = r@start + x, end = r@end + x)
+  r
+}
+rightwards(r, 20)
 }

---FILE: tests/testthat/_snaps/class.md---
@@ -72,7 +72,8 @@
     Error <simpleError>
       `parent` must be an R7 class, S3 class, or base type, not a class union.
 
-# constructor  types check their values
+# constructor types check their values
 
-    `.data` must be <integer> not <character>
+    <integer> object is invalid:
+    - Underlying data must be <integer> not <character>
 

---FILE: tests/testthat/_snaps/object.md---
@@ -1,3 +1,12 @@
+# new_object: reports all property type errors
+
+    Code
+      range(start = ""x"", end = ""y"")
+    Error <simpleError>
+      <range> object properties are invalid:
+      - <range>@start must be of class <integer> or <double>, not <character>
+      - <range>@end must be of class <integer> or <double>, not <character>
+
 # new_object: checks are arguments are properties
 
     Code

---FILE: tests/testthat/_snaps/property.md---
@@ -2,6 +2,13 @@
 
     Can't find property <range>@st
 
+# prop<-: errors if the property doesn't exist
+
+    Code
+      x@foo <- 10
+    Error <simpleError>
+      Can't find property <range>@foo
+
 # @: does not use partial matching
 
     Can't find property <range>@st

---FILE: tests/testthat/_snaps/valid.md---
@@ -0,0 +1,42 @@
+# validate() validates object and type recursively
+
+    Code
+      obj <- klass(1, -1)
+      attr(obj, ""x"") <- -1
+      validate(obj)
+    Error <simpleError>
+      <klass> object is invalid:
+      - x must be positive
+    Code
+      attr(obj, ""x"") <- ""y""
+      validate(obj)
+    Error <simpleError>
+      <klass> object properties are invalid:
+      - <klass>@x must be of class <double>, not <character>
+
+---
+
+    Code
+      obj <- klass2(1, -1, 1)
+      attr(obj, ""x"") <- -1
+      validate(obj)
+    Error <simpleError>
+      <klass2> object is invalid:
+      - x must be positive
+    Code
+      attr(obj, ""x"") <- ""y""
+      attr(obj, ""z"") <- ""y""
+      validate(obj)
+    Error <simpleError>
+      <klass2> object properties are invalid:
+      - <klass2>@x must be of class <double>, not <character>
+      - <klass2>@z must be of class <double>, not <character>
+
+# validate checks base type
+
+    Code
+      validate(x)
+    Error <simpleError>
+      <Double> object is invalid:
+      - Underlying data must be <double> not <character>
+

---FILE: tests/testthat/test-class.R---
@@ -76,6 +76,6 @@ test_that(""default constructor works"", {
   expect_s3_class(text2(""abc"", y = 1), ""text2"")
 })
 
-test_that(""constructor  types check their values"", {
+test_that(""constructor types check their values"", {
   expect_snapshot_error(new_class(""foo"", parent = integer)(""abc""))
 })

---FILE: tests/testthat/test-method.R---
@@ -113,7 +113,7 @@ test_that(""next_method works for single dispatch"", {
   foo <- new_generic(""foo"", dispatch_args = ""x"")
 
   new_method(foo, text, function(x, ...) {
-    x@.data <- paste0(""foo-"", r7_data(x))
+    r7_data(x) <- paste0(""foo-"", r7_data(x))
   })
   new_method(foo, ""character"", function(x, ...) {
     as.character(x)

---FILE: tests/testthat/test-object.R---
@@ -18,6 +18,10 @@ test_that(""Additional attributes storing properties defined by the class, access
 })
 
 describe(""new_object"", {
+  it(""reports all property type errors"", {
+    expect_snapshot(range(start = ""x"", end = ""y""), error = TRUE)
+  })
+
   it(""checks new objects for validity"", {
     expect_error(range(start = 10, end = 1), ""`end` must be greater than or equal to `start`"")
   })
@@ -27,13 +31,6 @@ describe(""new_object"", {
     expect_equal(r7_data(y), as_class(""character"")(""foo""))
   })
 
-  it(""errors if given an invalid property"", {
-    expect_error(
-      range(1, ""foo""),
-      ""must be of class""
-    )
-  })
-
   it(""checks are arguments are properties"", {
     expect_snapshot(error = TRUE, {
       foo <- new_class(""foo"")

---FILE: tests/testthat/test-property.R---
@@ -36,6 +36,10 @@ describe(""prop<-"", {
     prop(x, ""start"") <- 2
     expect_equal(prop(x, ""start""), 2)
   })
+  it(""errors if the property doesn't exist"", {
+    x <- range(1, 10)
+    expect_snapshot(error = TRUE, x@foo <- 10)
+  })
   it(""errors if the value does not match the correct class"", {
     x <- range(1, 10)
     expect_error(
@@ -50,6 +54,15 @@ describe(""prop<-"", {
   })
 })
 
+describe(""props<-"", {
+  it(""validates after setting all properties"", {
+    x <- range(1, 2)
+    props(x) <- list(start = 5, end = 10)
+    expect_equal(x@start, 5)
+    expect_equal(x@end, 10)
+  })
+})
+
 describe(""@"", {
   it(""retrieves the property"", {
     x <- range(1, 10)

---FILE: tests/testthat/test-valid.R---
@@ -1,12 +1,41 @@
-test_that(""validate calls the validation function"", {
-  obj <- range(1, 10)
-  # Use attr to set the property
-  attr(obj, ""start"") <- 11
-
-  expect_error(
-    validate(obj),
-    ""must be greater than""
+test_that(""validate() validates object and type recursively"", {
+  klass <- new_class(""klass"",
+    properties = list(x = ""double"", y = ""double""),
+    validator = function(object) {
+      c(
+        if (object@x < 0) ""x must be positive"",
+        if (object@y > 0) ""y must be negative""
+      )
+    }
   )
+
+  expect_snapshot(error = TRUE, {
+    obj <- klass(1, -1)
+    attr(obj, ""x"") <- -1
+    validate(obj)
+
+    attr(obj, ""x"") <- ""y""
+    validate(obj)
+  })
+
+  klass2 <- new_class(""klass2"", parent = klass, properties = list(z = ""double""))
+  expect_snapshot(error = TRUE, {
+    obj <- klass2(1, -1, 1)
+    attr(obj, ""x"") <- -1
+    validate(obj)
+
+    attr(obj, ""x"") <- ""y""
+    attr(obj, ""z"") <- ""y""
+    validate(obj)
+  })
+})
+
+test_that(""validate checks base type"", {
+  Double <- new_class(""Double"", parent = ""double"")
+  x <- Double(10)
+  mode(x) <- ""character""
+
+  expect_snapshot(error = TRUE, validate(x))
 })
 
 test_that(""valid eventually calls the validation function only at the end"", {"
RConsortium,S7,76af507c6a9e2272f08a1a8e36e0780efebf75dc,Hadley Wickham,h.wickham@gmail.com,2022-02-08T19:14:03Z,Hadley Wickham,h.wickham@gmail.com,2022-02-08T19:14:03Z,"Don't try S3 method lookup if no arguments

Fixes #16",R/method.R;tests/testthat/_snaps/method.md;tests/testthat/test-method.R,False,True,True,False,17,6,23,"---FILE: R/method.R---
@@ -83,9 +83,11 @@ method_impl <- function(generic, signature, ignore) {
     generic <- find_function_name(generic, topenv(environment(generic)))
   }
 
-  out <- getS3method(generic, s3_class_name(signature[[1]]), optional = TRUE)
-  if (!is.null(out)) {
-    return(out)
+  if (length(signature) > 1) {
+    out <- getS3method(generic, s3_class_name(signature[[1]]), optional = TRUE)
+    if (!is.null(out)) {
+      return(out)
+    }
   }
 
   # If no method found check if the generic has a default method

---FILE: tests/testthat/_snaps/method.md---
@@ -12,7 +12,15 @@
 
 # method errors if no method is defined for that class
 
-    Can't convert `signature[[1]]` to a valid class. No base classes are called 'blah'
+    Code
+      method(foo, list())
+    Error <simpleError>
+      Can't find method for generic `foo()` with classes:
+      - x: 
+    Code
+      method(foo, list(""blah""))
+    Error <simpleError>
+      Can't convert `signature[[1]]` to a valid class. No base classes are called 'blah'
 
 # new_method works if you pass a bare class union
 

---FILE: tests/testthat/test-method.R---
@@ -28,9 +28,10 @@ test_that(""method errors on invalid inputs"", {
 test_that(""method errors if no method is defined for that class"", {
   foo <- new_generic(""foo"", dispatch_args = ""x"")
 
-  expect_snapshot_error(
+  expect_snapshot(error = TRUE, {
+    method(foo, list())
     method(foo, list(""blah""))
-  )
+  })
 })
 
 test_that(""methods can be registered for a generic and then called"", {"
RConsortium,S7,c267949b2a7f115c82ad82da90db2cd46e37ccf3,Hadley Wickham,h.wickham@gmail.com,2022-02-08T19:08:07Z,GitHub,noreply@github.com,2022-02-08T19:08:07Z,"Convert S4 unions to R7 unions (#150)

Fixes #72",NEWS.md;R/class-spec.R;tests/testthat/test-class-spec.R,False,True,True,False,44,5,49,"---FILE: NEWS.md---
@@ -4,7 +4,7 @@
 
 * Classes (base types, S3, S4, and R7) are handled consistently wherever they
   are used. Strings now only refer to base types. New explicit `s3_class()` for 
-  referring to S3 classes (#134).
+  referring to S3 classes (#134). S4 unions are converted to R7 unions (#150).
 * Base numeric, atomic, and vector ""types"" are now represented as class unions
   (#147).
 * Different evaluation mechanism for method dispatch, and greater restrictions 

---FILE: R/class-spec.R---
@@ -27,10 +27,8 @@ as_class <- function(x, arg = deparse(substitute(x))) {
     x
   } else if (is_s3_class(x)) {
     x
-  } else if (isS4(x) && methods::is(x, ""classGeneratorFunction"")) {
-    methods::getClass(as.character(x@className))
-  } else if (isS4(x) && methods::is(x, ""classRepresentation"")) {
-    x
+  } else if (isS4(x)) {
+    as_S4_class(x, error_base)
   } else if (is.function(x)) {
     candidate <- Filter(function(y) identical(x, y), base_constructors)
     if (length(candidate) == 0) {
@@ -48,7 +46,31 @@ as_class <- function(x, arg = deparse(substitute(x))) {
   }
 }
 
+as_S4_class <- function(x, error_base) {
+  # Silence R CMD check false postives
+  distance <- subClass <- className <- package <- NULL
+
+  # Convert generator function to class
+  if (methods::is(x, ""classGeneratorFunction"")) {
+    return(as_S4_class(methods::getClass(as.character(x@className)), error_base))
+  }
+
+  if (methods::is(x, ""ClassUnionRepresentation"")) {
+    subclasses <- Filter(function(y) y@distance == 1, x@subclasses)
+    subclasses <- lapply(subclasses, function(x) methods::getClass(x@subClass))
 
+    do.call(""new_union"", subclasses)
+  } else if (methods::is(x, ""classRepresentation"")) {
+    if (x@package == ""methods"" && x@className %in% names(base_classes)) {
+      # Convert S4 representation of base types to R7 representation
+      base_classes[[x@className]]
+    } else {
+      x
+    }
+  } else {
+    stop(sprintf(""%s. Unsupported S4 object: must be a class generator or a class definition, not a %s."", error_base, obj_desc(x)), call. = FALSE)
+  }
+}
 
 class_type <- function(x) {
   if (is_class(x)) {

---FILE: tests/testthat/test-class-spec.R---
@@ -63,6 +63,23 @@ test_that(""can work with S4 classes"", {
   expect_equal(class_inherits(obj, klass), TRUE)
 })
 
+test_that(""converts S4 base classes to R7 base classes"", {
+  expect_equal(as_class(getClass(""NULL"")), base_classes[[""NULL""]])
+  expect_equal(as_class(getClass(""character"")), base_classes$character)
+})
+
+test_that(""converts S4 unions to R7 unions"", {
+  Foo1 <- setClass(""Foo1"", slots = ""x"")
+  Foo2 <- setClass(""Foo2"", slots = ""x"")
+  Foo3 <- setClass(""Foo3"", slots = ""x"")
+
+  Union1 <- setClassUnion(""Union1"", c(""Foo1"", ""Foo2""))
+  expect_equal(as_class(Union1), new_union(getClass(""Foo1""), getClass(""Foo2"")))
+
+  Union2 <- setClassUnion(""Union2"", c(""Union1"", ""Foo3""))
+  expect_equal(as_class(Union2), new_union(getClass(""Foo1""), getClass(""Foo2""), getClass(""Foo3"")))
+})
+
 test_that(""can work with simple S3 classes"", {
   klass <- s3_class(""data.frame"")
   expect_equal(as_class(klass), klass)"
RConsortium,S7,dcb2ce1b4b219976c8661280242a8a38e1f83eb1,Hadley Wickham,h.wickham@gmail.com,2022-02-08T14:52:57Z,Hadley Wickham,h.wickham@gmail.com,2022-02-08T14:52:57Z,"Fix str.R7_object() nesting

And improve tests",R/object.R;tests/testthat/_snaps/class.md;tests/testthat/_snaps/object.md;tests/testthat/test-class.R;tests/testthat/test-object.R,False,True,True,False,63,75,138,"---FILE: R/object.R---
@@ -94,7 +94,7 @@ str.R7_object <- function(object, ..., nest.lev = 0) {
   if (typeof(object) != ""S4"") {
     bare <- object
     attributes(bare) <- NULL
-    str(bare)
+    str(bare, nest.lev = nest.lev + 1)
   } else {
     cat(""\n"")
   }

---FILE: tests/testthat/_snaps/class.md---
@@ -21,10 +21,45 @@
       @ validator  :  function (x)  
       @ class      :  chr [1:2] ""R7_class"" ""R7_object""
     Code
-      str(list(my_class))
+      str(range)
     Output
-      List of 1
-       $ : <my_class/R7_object> constructor
+      <range/R7_object> constructor
+      @ name       :  chr ""range""
+      @ parent     :  <R7_object> constructor
+      @ properties : List of 3
+       .. $ start : <R7_property> 
+       .. .. $ name  :  chr ""start""
+       .. .. $ class :  <R7_union>: <integer> or <double>
+       .. .. $ getter:  NULL
+       .. .. $ setter:  NULL
+       .. $ end   : <R7_property> 
+       .. .. $ name  :  chr ""end""
+       .. .. $ class :  <R7_union>: <integer> or <double>
+       .. .. $ getter:  NULL
+       .. .. $ setter:  NULL
+       .. $ length: <R7_property> 
+       .. .. $ name  :  chr ""length""
+       .. .. $ class :  <R7_union>: <integer> or <double>
+       .. .. $ getter:  function (x)  
+       .. .. $ setter:  function (x, value)  
+      @ constructor:  function (start, end)  
+      @ validator  :  function (x)  
+      @ class      :  chr [1:2] ""R7_class"" ""R7_object""
+
+# R7_class: str() summarises when nested
+
+    Code
+      list(range)
+    Output
+      [[1]]
+      <R7_class>
+      @ name  :  range
+      @ parent: <R7_object>
+      @ properties:
+       $ start : <integer> or <double>
+       $ end   : <integer> or <double>
+       $ length: <integer> or <double>
+      
 
 # classes can't inherit from S4 or class unions
 

---FILE: tests/testthat/_snaps/object.md---
@@ -18,73 +18,31 @@
     Error <simpleError>
       unused arguments (x = 1, y = 2)
 
-# printing R7 objects work
+# print()/str() gives useful display
 
     Code
-      print(x)
+      str(range(1, 10))
     Output
       <range/R7_object>
       @ start :  num 1
       @ end   :  num 10
       @ length:  num 9
-
-# printing R7 classes work
-
-    Code
-      range
-    Output
-      <R7_class>
-      @ name  :  range
-      @ parent: <R7_object>
-      @ properties:
-       $ start : <integer> or <double>
-       $ end   : <integer> or <double>
-       $ length: <integer> or <double>
-
-# str with simple R7 objects work
-
-    Code
-      str(range(1, 2))
-    Output
-      <range/R7_object>
-      @ start :  num 1
-      @ end   :  num 2
-      @ length:  num 1
-
-# str with R7 objects of base classes work
-
     Code
       str(list(text(""b""), number(50)))
     Output
       List of 2
        $ : <text/character/R7_object> chr ""b""
        $ : <number/double/R7_object> num 50
 
-# str R7 classes work
+# print()/str() nests properties correctly
 
     Code
-      str(range)
+      str(klass(x = 10, y = range(1, 10)))
     Output
-      <range/R7_object> constructor
-      @ name       :  chr ""range""
-      @ parent     :  <R7_object> constructor
-      @ properties : List of 3
-       .. $ start : <R7_property> 
-       .. .. $ name  :  chr ""start""
-       .. .. $ class :  <R7_union>: <integer> or <double>
-       .. .. $ getter:  NULL
-       .. .. $ setter:  NULL
-       .. $ end   : <R7_property> 
-       .. .. $ name  :  chr ""end""
-       .. .. $ class :  <R7_union>: <integer> or <double>
-       .. .. $ getter:  NULL
-       .. .. $ setter:  NULL
-       .. $ length: <R7_property> 
-       .. .. $ name  :  chr ""length""
-       .. .. $ class :  <R7_union>: <integer> or <double>
-       .. .. $ getter:  function (x)  
-       .. .. $ setter:  function (x, value)  
-      @ constructor:  function (start, end)  
-      @ validator  :  function (x)  
-      @ class      :  chr [1:2] ""R7_class"" ""R7_object""
+      <klass/R7_object>
+      @ x:  num 10
+      @ y:  <range/R7_object>
+       .. @ start :  num 1
+       .. @ end   :  num 10
+       .. @ length:  num 9
 

---FILE: tests/testthat/test-class.R---
@@ -27,9 +27,12 @@ describe(""R7_class"", {
   it(""str yields all details when used at top-level"", {
     expect_snapshot({
       str(my_class)
-      str(list(my_class))
+      str(range)
     })
   })
+  it(""str() summarises when nested"", {
+    expect_snapshot(list(range))
+  })
 })
 
 test_that(""classes can inherit from base types"", {

---FILE: tests/testthat/test-object.R---
@@ -68,26 +68,18 @@ describe(""new_object"", {
   })
 })
 
-test_that(""printing R7 objects work"", {
-  x <- range(1, 10)
-
-  expect_snapshot(print(x))
-})
-
-test_that(""printing R7 classes work"", {
-  expect_snapshot(range)
-})
-
-test_that(""str with simple R7 objects work"", {
-  expect_snapshot(str(range(1, 2)))
-})
-
-test_that(""str with R7 objects of base classes work"", {
-  expect_snapshot(str(list(text(""b""), number(50))))
+test_that(""print()/str() gives useful display"", {
+  expect_snapshot({
+    str(range(1, 10))
+    str(list(text(""b""), number(50)))
+  })
 })
+test_that(""print()/str() nests properties correctly"", {
+  klass <- new_class(""klass"", properties = list(x = ""numeric"", y = range))
 
-test_that(""str R7 classes work"", {
-  expect_snapshot(str(range))
+  expect_snapshot({
+    str(klass(x = 10, y = range(1, 10)))
+  })
 })
 
 test_that(""object_class returns itself for R7_class objects"", {"
RConsortium,S7,a6cfc8d0dc093efd408b9178bffdad42c8d47920,Hadley Wickham,h.wickham@gmail.com,2022-02-07T22:49:26Z,GitHub,noreply@github.com,2022-02-07T22:49:26Z,"Unions for base types (#147)

* Adds numeric, atomic, and vector unions
* Adds expression base type
* Adds `str.r7_union()`

Fixes #77. Fixes #94.",NAMESPACE;NEWS.md;R/class-spec.R;R/method.R;R/utils.R;R/zzz.R;man/as_class.Rd;man/method.Rd;src/dispatch.c;tests/testthat/_snaps/object.md;tests/testthat/_snaps/zzz.md;tests/testthat/helper.R;tests/testthat/test-class.R;tests/testthat/test-dispatch.R;tests/testthat/test-zzz.R;vignettes/performance.Rmd,True,True,True,False,83,23,106,"---FILE: NAMESPACE---
@@ -9,6 +9,7 @@ S3method(print,R7_union)
 S3method(str,R7_class)
 S3method(str,R7_object)
 S3method(str,R7_property)
+S3method(str,R7_union)
 export(""@"")
 export(""method<-"")
 export(""prop<-"")

---FILE: NEWS.md---
@@ -5,6 +5,8 @@
 * Classes (base types, S3, S4, and R7) are handled consistently wherever they
   are used. Strings now only refer to base types. New explicit `s3_class()` for 
   referring to S3 classes (#134).
+* Base numeric, atomic, and vector ""types"" are now represented as class unions
+  (#147).
 * Different evaluation mechanism for method dispatch, and greater restrictions 
   on dispatch args (#141)
 * `x@.data` -> `r7_data()`; probably to be replaced by casting.

---FILE: R/class-spec.R---
@@ -10,6 +10,8 @@
 #'    * An S4 class object.
 #'    * A base type specified either with its constructor (`logical`, `integer`,
 #'      `double` etc) or its name (`""logical""`, `""integer""`, ""`double`"" etc).
+#'    * A base union type specified by its name: `""numeric""`, `""atomic""`, or
+#'      `""vector""`.
 #' @param arg Argument name used when generating errors.
 #' @export
 #' @return A standardised class: either `NULL`, an R7 class, an R7 union,

---FILE: R/method.R---
@@ -36,7 +36,7 @@
 #'
 #' # But it can be useful to explicitly retrieve a method in order to
 #' # inspect its implementation
-#' method(bizarro, ""numeric"")
+#' method(bizarro, ""double"")
 #' method(bizarro, s3_class(""factor""))
 method <- function(generic, signature) {
   # TODO: check that signature doesn't contain any unions

---FILE: R/utils.R---
@@ -30,7 +30,7 @@ global_variables <- function(names) {
 
 vlapply <- function(X, FUN, ...) vapply(X = X, FUN = FUN, FUN.VALUE = logical(1), ...)
 vcapply <- function(X, FUN, ...) vapply(X = X, FUN = FUN, FUN.VALUE = character(1), ...)
-`%||%` <- function(x, y) if (length(x) == 0 || (length(x) == 1 && !nzchar(x))) y else x
+`%||%` <- function(x, y) if (length(x) == 0) y else x
 
 collapse <- function(x, by) {
   paste(x, collapse = by)

---FILE: R/zzz.R---
@@ -16,14 +16,15 @@ new_base_class <- function(name) {
   R7_class(name = name, constructor = function(.data) new_object(.data))
 }
 
-base_types <- setNames(, c(""logical"", ""integer"", ""double"", ""numeric"", ""complex"", ""character"", ""raw"", ""function"", ""list"", ""environment""))
-
+# Define simple base types with constructors. See .onLoad() for more
+base_types <- setNames(, c(
+  ""logical"", ""integer"", ""double"", ""complex"", ""character"", ""raw"",
+  ""list"", ""expression"",
+  ""function"", ""environment""
+))
 base_classes <- lapply(base_types, new_base_class)
-base_classes[[""NULL""]] <- new_base_class(""NULL"")
-
 base_constructors <- lapply(base_types, get)
 
-
 R7_generic <- new_class(
   name = ""R7_generic"",
   properties = list(
@@ -72,6 +73,19 @@ R7_union <- new_class(
   }
 )
 
+#' @export
+str.R7_union <- function(object, ..., nest.lev = 0) {
+  cat(if (nest.lev > 0) "" "")
+  cat(""<R7_union>: "", class_desc(object), sep = """")
+  cat(""\n"")
+
+  if (nest.lev == 0) {
+    props <- props(object)
+    str_list(props, ..., prefix = ""@"", nest.lev = nest.lev)
+  }
+}
+
+
 class_flatten <- function(x) {
   x <- lapply(x, as_class)
 
@@ -107,3 +121,10 @@ global_variables(c(""name"", ""parent"", ""properties"", ""constructor"", ""validator""))
   env <- as.environment(paste0(""package:"", pkgname))
   env[["".conflicts.OK""]] <- TRUE
 }
+
+.onLoad <- function(...) {
+  base_classes$`NULL` <<- new_base_class(""NULL"")
+  base_classes$numeric <<- new_union(""integer"", ""double"")
+  base_classes$atomic <<- new_union(""logical"", ""integer"", ""double"", ""complex"", ""character"", ""raw"")
+  base_classes$vector <<- new_union(""logical"", ""integer"", ""double"", ""complex"", ""character"", ""raw"", ""expression"", ""list"")
+}

---FILE: man/as_class.Rd---
@@ -14,6 +14,8 @@ as_class(x, arg = deparse(substitute(x)))
 \item An S4 class object.
 \item A base type specified either with its constructor (\code{logical}, \code{integer},
 \code{double} etc) or its name (\code{""logical""}, \code{""integer""}, ""\code{double}"" etc).
+\item A base union type specified by its name: \code{""numeric""}, \code{""atomic""}, or
+\code{""vector""}.
 }}
 
 \item{arg}{Argument name used when generating errors.}

---FILE: man/method.Rd---
@@ -47,6 +47,6 @@ bizarro(1)
 
 # But it can be useful to explicitly retrieve a method in order to
 # inspect its implementation
-method(bizarro, ""numeric"")
+method(bizarro, ""double"")
 method(bizarro, s3_class(""factor""))
 }

---FILE: src/dispatch.c---
@@ -51,7 +51,7 @@ SEXP method_internal(SEXP table, SEXP signature, R_xlen_t signature_itr, SEXP ig
 SEXP get_class(SEXP object, SEXP envir) {
     static SEXP fun = NULL;
     if (fun == NULL) {
-      fun = Rf_findVarInFrame(R_BaseEnv, Rf_install(""class""));
+      fun = Rf_findVarInFrame(R_BaseEnv, Rf_install("".class2""));
     }
     SEXP call = PROTECT(Rf_lang2(fun, object));
     SEXP res = Rf_eval(call, envir);

---FILE: tests/testthat/_snaps/object.md---
@@ -37,9 +37,9 @@
       @ name  :  range
       @ parent: <R7_object>
       @ properties:
-       $ start : <numeric>
-       $ end   : <numeric>
-       $ length: <numeric>
+       $ start : <integer> or <double>
+       $ end   : <integer> or <double>
+       $ length: <integer> or <double>
 
 # str with simple R7 objects work
 
@@ -58,7 +58,7 @@
     Output
       List of 2
        $ : <text/character/R7_object> chr ""b""
-       $ : <number/numeric/R7_object> num 50
+       $ : <number/double/R7_object> num 50
 
 # str R7 classes work
 
@@ -71,17 +71,17 @@
       @ properties : List of 3
        .. $ start : <R7_property> 
        .. .. $ name  :  chr ""start""
-       .. .. $ class :  <numeric/R7_object> constructor
+       .. .. $ class :  <R7_union>: <integer> or <double>
        .. .. $ getter:  NULL
        .. .. $ setter:  NULL
        .. $ end   : <R7_property> 
        .. .. $ name  :  chr ""end""
-       .. .. $ class :  <numeric/R7_object> constructor
+       .. .. $ class :  <R7_union>: <integer> or <double>
        .. .. $ getter:  NULL
        .. .. $ setter:  NULL
        .. $ length: <R7_property> 
        .. .. $ name  :  chr ""length""
-       .. .. $ class :  <numeric/R7_object> constructor
+       .. .. $ class :  <R7_union>: <integer> or <double>
        .. .. $ getter:  function (x)  
        .. .. $ setter:  function (x, value)  
       @ constructor:  function (start, end)  

---FILE: tests/testthat/_snaps/zzz.md---
@@ -7,3 +7,18 @@
     Output
       <R7_union>: <foo1> or <foo2>
 
+# base unions print as expected
+
+    Code
+      base_classes$numeric
+    Output
+      <R7_union>: <integer> or <double>
+    Code
+      base_classes$atomic
+    Output
+      <R7_union>: <logical>, <integer>, <double>, <complex>, <character>, or <raw>
+    Code
+      base_classes$vector
+    Output
+      <R7_union>: <logical>, <integer>, <double>, <complex>, <character>, <raw>, <expression>, or <list>
+

---FILE: tests/testthat/helper.R---
@@ -1,5 +1,5 @@
 text <- new_class(""text"", parent = ""character"", constructor = function(text = character()) new_object(.data = text))
-number <- new_class(""number"", parent = ""numeric"", constructor = function(x) new_object(.data = x))
+number <- new_class(""number"", parent = ""double"", constructor = function(x) new_object(.data = x))
 
 range <- new_class(""range"",
   constructor = function(start, end) {

---FILE: tests/testthat/test-class.R---
@@ -33,18 +33,14 @@ describe(""R7_class"", {
 })
 
 test_that(""classes can inherit from base types"", {
-  types <- c(""logical"", ""integer"", ""complex"", ""character"", ""raw"", ""list"")
+  types <- c(""logical"", ""integer"", ""double"", ""complex"", ""character"", ""raw"", ""list"")
   for (type in types) {
     f <- match.fun(type)
     foo <- new_class(""foo"", parent = type, constructor = function(x = f()) new_object(x))
     obj <- foo()
     expect_equal(typeof(r7_data(obj)), type)
   }
 
-  foo <- new_class(""foo"", parent = ""numeric"", constructor = function(x = numeric()) new_object(x))
-  obj <- foo()
-  expect_equal(typeof(r7_data(obj)), ""double"")
-
   foo <- new_class(""foo"", parent = ""function"", constructor = function(x = function() NULL, ...) new_object(x))
   obj <- foo()
   expect_equal(typeof(r7_data(obj)), ""closure"")

---FILE: tests/testthat/test-dispatch.R---
@@ -49,6 +49,19 @@ test_that(""generics pass extra args to methods"", {
   expect_equal(foo(""x"", z = 3), 3)
 })
 
+test_that(""can dispatch on base 'union' types"", {
+  foo <- new_generic(""foo"", dispatch_args = ""x"")
+  method(foo, ""vector"") <- function(x) ""v""
+  method(foo, ""atomic"") <- function(x) ""a""
+  method(foo, ""numeric"") <- function(x) ""n""
+  method(foo, ""integer"") <- function(x) ""i""
+
+  expect_equal(foo(list()), ""v"")
+  expect_equal(foo(character()), ""a"")
+  expect_equal(foo(double()), ""n"")
+  expect_equal(foo(integer()), ""i"")
+})
+
 test_that(""method lookup fails with informative messages"", {
   foo <- new_generic(""foo"", dispatch_args = c(""x"", ""y""))
   method(foo, list(""character"", ""integer"")) <- function(x, y) paste0(""bar:"", x, y)

---FILE: tests/testthat/test-zzz.R---
@@ -31,6 +31,14 @@ test_that(""can construct from unions"", {
   )
 })
 
+test_that(""base unions print as expected"", {
+  expect_snapshot({
+    base_classes$numeric
+    base_classes$atomic
+    base_classes$vector
+  })
+})
+
 test_that(""can construct from S3 and S4 classes"", {
   factor <- s3_class(""factor"")
   s4_union <- methods::setClass(""s4_union"")

---FILE: vignettes/performance.Rmd---
@@ -22,7 +22,7 @@ The dispatch performance should be roughly on par with S3 and S4, though as this
 
 ```{r performance, cache = FALSE}
 text <- new_class(""text"", parent = ""character"", constructor = function(text) new_object(.data = text))
-number <- new_class(""number"", parent = ""numeric"", constructor = function(x) new_object(.data = x))
+number <- new_class(""number"", parent = ""double"", constructor = function(x) new_object(.data = x))
 
 x <- text(""hi"")
 y <- number(1)"
RConsortium,S7,1a34dacb17d6cafcd181cf91be24ded94dffab9f,Hadley Wickham,h.wickham@gmail.com,2022-02-04T23:55:51Z,Hadley Wickham,h.wickham@gmail.com,2022-02-04T23:55:51Z,"Match print() methods to str() methods

Fixes #145",NEWS.md;R/class.R;R/object.R;tests/testthat/_snaps/class.md;tests/testthat/_snaps/object.md;tests/testthat/_snaps/property.md,False,True,True,False,29,36,65,"---FILE: NEWS.md---
@@ -9,5 +9,5 @@
   on dispatch args (#141)
 * `x@.data` -> `r7_data()`; probably to be replaced by casting.
 * In generic, `signature` -> `dispatch_args`.
-* Polished `str()` methods
+* Polished `str()` and `print()` methods
 * `new_class()` has properties as 3rd argument (instead of constructor).

---FILE: R/class.R---
@@ -141,15 +141,16 @@ print.R7_class <- function(x, ...) {
   props <- x@properties
   if (length(props) > 0) {
     prop_names <- format(names(props))
-    prop_types <- format(vcapply(props, function(x) class_desc(x$class)), justify = ""right"")
-    prop_fmt <- paste0(paste0("" $"", prop_names, "" "", prop_types, collapse = ""\n""), ""\n"")
+    prop_types <- format(vcapply(props, function(x) class_desc(x$class)))
+    prop_fmt <- paste0("" $ "", prop_names, "": "", prop_types, ""\n"", collapse = """")
   } else {
     prop_fmt <- """"
   }
   parent <- prop_safely(x, ""parent"")
   parent <- prop_safely(parent, ""name"") %||% parent %||% """"
 
-  cat(sprintf(""<R7_class>\n@name %s\n@parent <%s>\n@properties\n%s"", x@name, parent, prop_fmt), sep = """")
+  cat(sprintf(""<R7_class>\n@ name  :  %s\n@ parent: <%s>\n@ properties:\n%s"", x@name, parent, prop_fmt), sep = """")
+  invisible(x)
 }
 
 #' @export

---FILE: R/object.R---
@@ -82,16 +82,8 @@ object_class <- function(object) {
 
 #' @export
 print.R7_object <- function(x, ...) {
-  props <- props(x)
-  if (length(props) > 0) {
-    values <- lapply(names(props), function(xx) prop(x, xx))
-    prop_names <- format(names(props))
-    prop_values <- format(vcapply(names(props), function(name) paste0(format(prop(x, name)), collapse = ""\n"")), justify = ""right"")
-    prop_fmt <- paste0(paste0(""@"", prop_names, "" "", prop_values, collapse = ""\n""), ""\n"")
-  } else {
-    prop_fmt <- """"
-  }
-  cat(sprintf(""%s\n%s"", obj_desc(x), prop_fmt), sep = """")
+  str(x)
+  invisible(x)
 }
 
 #' @export

---FILE: tests/testthat/_snaps/class.md---
@@ -4,9 +4,9 @@
       my_class
     Output
       <R7_class>
-      @name my_class
-      @parent <R7_object>
-      @properties
+      @ name  :  my_class
+      @ parent: <R7_object>
+      @ properties:
 
 # R7_class: str yields all details when used at top-level
 

---FILE: tests/testthat/_snaps/object.md---
@@ -23,23 +23,23 @@
     Code
       print(x)
     Output
-      <range>
-      @start   1
-      @end    10
-      @length  9
+      <range/R7_object>
+      @ start :  num 1
+      @ end   :  num 10
+      @ length:  num 9
 
 # printing R7 classes work
 
     Code
       range
     Output
       <R7_class>
-      @name range
-      @parent <R7_object>
-      @properties
-       $start  <numeric>
-       $end    <numeric>
-       $length <numeric>
+      @ name  :  range
+      @ parent: <R7_object>
+      @ properties:
+       $ start : <numeric>
+       $ end   : <numeric>
+       $ length: <numeric>
 
 # str with simple R7 objects work
 

---FILE: tests/testthat/_snaps/property.md---
@@ -23,15 +23,15 @@
       my_class
     Output
       <R7_class>
-      @name my_class
-      @parent <R7_object>
-      @properties
-       $anything                  <ANY>
-       $base                  <integer>
-       $s3                     <factor>
-       $s4                   <class_s4>
-       $r7                   <class_r7>
-       $r7_union <integer> or <logical>
+      @ name  :  my_class
+      @ parent: <R7_object>
+      @ properties:
+       $ anything: <ANY>                 
+       $ base    : <integer>             
+       $ s3      : <factor>              
+       $ s4      : <class_s4>            
+       $ r7      : <class_r7>            
+       $ r7_union: <integer> or <logical>
 
 ---
 "
RConsortium,S7,6b2cab93e596abdfedca6b19a37a9b5c82e90f3f,Hadley Wickham,h.wickham@gmail.com,2022-02-04T23:03:27Z,GitHub,noreply@github.com,2022-02-04T23:03:27Z,"Refactor class specification (#134)

Refactor class specification (S3, S4, and base types) to common code path that's used in all locations. Includes new explicit specification of S3 classes using `s3_class()`, a string class (e.g. ""character"") now only refers to base types.

Fixes #120.",NAMESPACE;NEWS.md;R/class-spec.R;R/class.R;R/dispatch.R;R/generic.R;R/method.R;R/object.R;R/property.R;R/utils.R;R/zzz.R;_pkgdown.yml;man/as_class.Rd;man/class_get.Rd;man/method.Rd;man/new_generic.Rd;man/s3_class.Rd;tests/testthat/_snaps/class-spec.md;tests/testthat/_snaps/class.md;tests/testthat/_snaps/generic.md;tests/testthat/_snaps/method.md;tests/testthat/_snaps/object.md;tests/testthat/_snaps/property.md;tests/testthat/_snaps/zzz.md;tests/testthat/test-class-spec.R;tests/testthat/test-class.R;tests/testthat/test-data.R;tests/testthat/test-dispatch.R;tests/testthat/test-generic.R;tests/testthat/test-method.R;tests/testthat/test-object.R;tests/testthat/test-property.R;tests/testthat/test-zzz.R;vignettes/case_studies.Rmd;vignettes/performance.Rmd,True,True,True,False,733,284,1017,"---FILE: NAMESPACE---
@@ -14,7 +14,7 @@ export(""method<-"")
 export(""prop<-"")
 export(""r7_data<-"")
 export(R7_object)
-export(class_get)
+export(as_class)
 export(class_names)
 export(method)
 export(method_call)
@@ -33,6 +33,7 @@ export(prop_names)
 export(prop_safely)
 export(props)
 export(r7_data)
+export(s3_class)
 export(valid_eventually)
 export(valid_implicitly)
 importFrom(stats,setNames)

---FILE: NEWS.md---
@@ -2,6 +2,9 @@
 
 ## Jan 2020
 
+* Classes (base types, S3, S4, and R7) are handled consistently wherever they
+  are used. Strings now only refer to base types. New explicit `s3_class()` for 
+  referring to S3 classes (#134).
 * Different evaluation mechanism for method dispatch, and greater restrictions 
   on dispatch args (#141)
 * `x@.data` -> `r7_data()`; probably to be replaced by casting.

---FILE: R/class-spec.R---
@@ -0,0 +1,156 @@
+#' Standard class specifications
+#'
+#' This is used as the interface between R7 and R's other OO systems, allowing
+#' you to use R7 classes and methods with base types, informal S3 classes, and
+#' formal S4 classes.
+#'
+#' @param x A class specification.
+#'    * An R7 class object or class union.
+#'    * An S3 class object, created by `s3_class()`.
+#'    * An S4 class object.
+#'    * A base type specified either with its constructor (`logical`, `integer`,
+#'      `double` etc) or its name (`""logical""`, `""integer""`, ""`double`"" etc).
+#' @param arg Argument name used when generating errors.
+#' @export
+#' @return A standardised class: either `NULL`, an R7 class, an R7 union,
+#'   as [s3_class], or a S4 class.
+as_class <- function(x, arg = deparse(substitute(x))) {
+  error_base <- sprintf(""Can't convert `%s` to a valid class"", arg)
+
+  if (is.null(x)) {
+    x
+  } else if (is_class(x)) {
+    x
+  } else if (is_union(x)) {
+    x
+  } else if (is_s3_class(x)) {
+    x
+  } else if (isS4(x) && methods::is(x, ""classGeneratorFunction"")) {
+    methods::getClass(as.character(x@className))
+  } else if (isS4(x) && methods::is(x, ""classRepresentation"")) {
+    x
+  } else if (is.function(x)) {
+    candidate <- Filter(function(y) identical(x, y), base_constructors)
+    if (length(candidate) == 0) {
+      stop(sprintf(""%s. Could not find base class corresponding to supplied constructor function"", error_base), call. = FALSE)
+    }
+    base_classes[[names(candidate)[[1]]]]
+  } else if (is.character(x) && length(x) == 1) {
+    if (x %in% names(base_classes)) {
+      base_classes[[x]]
+    } else {
+      stop(sprintf(""%s. No base classes are called '%s'"", error_base, x), call. = FALSE)
+    }
+  } else {
+    stop(sprintf(""%s. Class specification must be an R7 class object, the result of `s3_class()`, an S4 class object, or a base constructor function, not a %s."", error_base, obj_desc(x)), call. = FALSE)
+  }
+}
+
+
+
+class_type <- function(x) {
+  if (is_class(x)) {
+    if (utils::hasName(base_classes, x@name)) {
+      ""r7_base""
+    } else {
+      ""r7""
+    }
+  } else if (is_union(x)) {
+    ""r7_union""
+  } else if (is.null(x)) {
+    ""NULL""
+  } else if (is_s3_class(x)) {
+    ""s3""
+  } else if (isS4(x)) {
+    ""s4""
+  } else {
+    stop(""`x` is not standard R7 class"", call. = FALSE)
+  }
+}
+
+class_desc <- function(x) {
+  switch(class_type(x),
+    NULL = ""<ANY>"",
+    s3 = fmt_classes(x[[1]]),
+    s4 = fmt_classes(x@className),
+    r7 = fmt_classes(x@name),
+    r7_base = fmt_classes(x@name),
+    r7_union = oxford_or(unlist(lapply(x@classes, class_desc))),
+  )
+}
+
+# Used when printing method signature to generate executable code
+class_deparse <- function(x) {
+  switch(class_type(x),
+    NULL = """",
+    s3 = paste0(""s3_class("", paste(encodeString(x, quote = '""'), collapse = "", ""), "")""),
+    s4 = as.character(x@className),
+    r7 = x@name,
+    r7_base = encodeString(x@name, quote = '""'),
+    r7_union = {
+      classes <- vcapply(x@classes, class_deparse)
+      paste0(""new_union("", paste(classes, collapse = "", ""), "")"")
+    }
+  )
+}
+
+class_inherits <- function(x, what) {
+  switch(class_type(what),
+    NULL = TRUE,
+    s3 = !isS4(x) && is_prefix(what, class(x)),
+    s4 = isS4(x) && methods::is(x, what),
+    r7 = inherits(x, ""R7_object"") && inherits(x, what@name),
+    r7_base = what@name %in% .class2(x),
+    r7_union = any(vlapply(what@classes, class_inherits, x = x))
+  )
+}
+
+obj_type <- function(x) {
+  if (is.null(x)) {
+    ""NULL""
+  } else if (inherits(x, ""R7_object"")) {
+    ""r7""
+  } else if (isS4(x)) {
+    ""s4""
+  } else if (is.object(x)) {
+    ""s3""
+  } else {
+    ""base""
+  }
+}
+obj_desc <- function(x) {
+  switch(obj_type(x),
+   NULL = ""NULL"",
+   base = fmt_classes(typeof(x)),
+   s3 = fmt_classes(class(x)[[1]]),
+   s4 = fmt_classes(class(x)),
+   r7 = fmt_classes(object_class(x)@name)
+  )
+}
+
+#' Declare an S3 class vector
+#'
+#' The S3 class system is informal so doesn't have a way to formally register
+#' a class. This helper allows you to use S3 classes within R7.
+#'
+#' @export
+#' @param class Character vector of S3 classes
+s3_class <- function(class) {
+  if (!is.character(class)) {
+    stop(""`class` must be a character vector"", call. = FALSE)
+  }
+  structure(class, class = ""r7_s3_class"")
+}
+
+is_s3_class <- function(x) {
+  inherits(x, ""r7_s3_class"")
+}
+
+# helpers -----------------------------------------------------------------
+
+fmt_classes <- function(classes, collapse = "", "") {
+  paste0(""<"", classes, "">"", collapse = collapse)
+}
+
+# Suppress @className false positive
+globalVariables(""className"")

---FILE: R/class.R---
@@ -1,9 +1,14 @@
 #' @importFrom utils modifyList
 R7_class <- function(name, parent = R7_object, constructor = NULL, validator = function(x) NULL, properties = list()) {
 
-  parent_obj <- class_get(parent)
-  if (!is.null(parent_obj) && inherits(parent_obj, ""R7_class"")) {
-    parent <- parent_obj
+  parent <- as_class(parent)
+  if (is_union(parent) || isS4(parent)) {
+    not <- if (is_union(parent)) ""a class union"" else ""an S4 class""
+     stop(
+       sprintf(
+         ""`parent` must be an R7 class, S3 class, or base type, not %s."", not),
+       call. = FALSE
+     )
   }
 
   # Combine properties from parent, overriding as needed
@@ -28,6 +33,8 @@ R7_class <- function(name, parent = R7_object, constructor = NULL, validator = f
   object
 }
 
+is_class <- function(x) inherits(x, ""R7_class"")
+
 #' Create a new R7 class
 #'
 #' A class specifies the properties (data) that each of its objects will
@@ -129,54 +136,12 @@ class_names <- function(object) {
   unique(classes, fromLast = TRUE)
 }
 
-#' Retrieve the R7 class from a class specification
-#'
-#' @param x The name of the R7 class
-#' @param envir The environment to look for the name
-#' @param unions Include unions?
-#' @export
-class_get <- function(x, unions = FALSE, envir = parent.frame()) {
-  if (inherits(x, ""R7_class"")) {
-    x
-  } else if (unions && is_union(x)) {
-    x
-  } else if (is.function(x)) {
-    candidate <- Filter(function(y) identical(x, y), base_constructors)
-    if (length(candidate) != 1) {
-      stop(""Could not find class for constructor function"", call. = FALSE)
-    }
-    base_classes[[names(candidate)]]
-  } else if (is.character(x)) {
-    if (length(x) == 1) {
-      if (x %in% names(base_classes)) {
-        return(base_classes[[x]])
-      }
-
-      obj <- get(x, envir = envir)
-      if (inherits(obj, ""R7_class"")) {
-        return(obj)
-      }
-    }
-
-    # TODO: What do we do about existing S3 / S4 classes?
-    NULL
-  } else if (is.null(x)) {
-    x
-  } else {
-    stop(
-      ""Must specify class as a <R7_class>, a base constructor function, or a string"",
-      call. = FALSE
-    )
-  }
-}
-
-
 #' @export
 print.R7_class <- function(x, ...) {
   props <- x@properties
   if (length(props) > 0) {
     prop_names <- format(names(props))
-    prop_types <- format(paste0(""<"", vcapply(props, function(xx) xx[[""class""]][[1]] %||% """"), "">""), justify = ""right"")
+    prop_types <- format(vcapply(props, function(x) class_desc(x$class)), justify = ""right"")
     prop_fmt <- paste0(paste0("" $"", prop_names, "" "", prop_types, collapse = ""\n""), ""\n"")
   } else {
     prop_fmt <- """"

---FILE: R/dispatch.R---
@@ -4,6 +4,7 @@ method_lookup_error <- function(name, args, signatures) {
   stop(sprintf(""Can't find method for generic `%s()` with classes:\n%s"", name, types), call. = FALSE)
 }
 
+
 #' Lookup the R7 method for the current generic and call it.
 #' @export
 method_call <- function() {

---FILE: R/generic.R---
@@ -37,7 +37,7 @@
 #' # A simple generic with methods for some base types and S3 classes
 #' type_of <- new_generic(""type_of"", dispatch_args = ""x"")
 #' method(type_of, ""character"") <- function(x, ...) ""A character vector""
-#' method(type_of, ""data.frame"") <- function(x, ...) ""A data frame""
+#' method(type_of, s3_class(""data.frame"")) <- function(x, ...) ""A data frame""
 #' method(type_of, ""function"") <- function(x, ...) ""A function""
 #'
 #' type_of(mtcars)
@@ -115,7 +115,7 @@ check_dispatch_args <- function(dispatch_args, fun = NULL) {
   if (!is.null(fun)) {
     arg_names <- names(formals(fun))
 
-    if (!identical(dispatch_args, arg_names[seq_along(dispatch_args)])) {
+    if (!is_prefix(dispatch_args, arg_names)) {
       stop(""`dispatch_args` must be a prefix of the generic arguments"", call. = FALSE)
     }
 
@@ -129,15 +129,18 @@ check_dispatch_args <- function(dispatch_args, fun = NULL) {
 
 #' @export
 print.R7_generic <- function(x, ...) {
-  ms <- methods(x)
-  indexes <- seq_along(ms)
-  method_signatures <- vcapply(ms, function(x) method_signature(x@signature))
-
-  msg <- collapse(sprintf(""%s: method(%s, list(%s))"", indexes, x@name, method_signatures), by = ""\n"")
-
+  methods <- methods(x)
   formals <- collapse(head(format(args(x)), n = -1), by = ""\n"")
+  cat(sprintf(""<R7_generic> %s with %i methods:\n"", formals, length(methods)), sep = """")
+
+  if (length(methods) > 0) {
+    signatures <- lapply(methods, prop, ""signature"")
+    msg <- vcapply(signatures, method_signature, generic = x)
+    msg <- paste0(format(seq_along(signatures)), "": "", msg, ""\n"")
+    cat(msg, sep = """")
+  }
 
-  cat(sprintf(""<R7_generic> %s with %i methods:\n%s"", formals, length(ms), msg), sep = """")
+  invisible(x)
 }
 
 check_generic <- function(fun) {

---FILE: R/method.R---
@@ -22,11 +22,11 @@
 #' bizarro <- new_generic(""bizarro"", dispatch_args = ""x"")
 #' # Register some methods
 #' method(bizarro, ""numeric"") <- function(x, ...) rev(x)
-#' method(bizarro, ""factor"") <- function(x, ...) {
+#' method(bizarro, s3_class(""factor"")) <- function(x, ...) {
 #'   levels(x) <- rev(levels(x))
 #'   x
 #' }
-#' method(bizarro, ""data.frame"") <- function(x, ...) {
+#' method(bizarro, s3_class(""data.frame"")) <- function(x, ...) {
 #'   x[] <- lapply(x, bizarro)
 #'   rev(x)
 #' }
@@ -36,11 +36,12 @@
 #'
 #' # But it can be useful to explicitly retrieve a method in order to
 #' # inspect its implementation
-#' method(bizarro, list(""numeric""))
-#' method(bizarro, list(""factor""))
+#' method(bizarro, ""numeric"")
+#' method(bizarro, s3_class(""factor""))
 method <- function(generic, signature) {
-  signature <- as_signature(signature)
+  # TODO: check that signature doesn't contain any unions
 
+  signature <- as_signature(signature)
   method_impl(generic, signature, ignore = NULL)
 }
 
@@ -60,46 +61,40 @@ as_signature <- function(signature) {
   if (!is.list(signature)) {
     signature <- list(signature)
   }
-  is_valid_signature <- vlapply(signature, function(x) inherits(x, ""R7_class"") | inherits(x, ""character""))
-  if (all(is_valid_signature)) {
-    return(signature)
-  }
 
-  invalid_indexes <- which(!is_valid_signature)
-  invalid_classes <- vcapply(signature[!is_valid_signature], function(x) fmt_classes(class(x)))
-
-  stop(
-    ""`signature` must be a list of <R7_class> or a <character>:\n"",
-    paste0(collapse = ""\n"",
-      sprintf(""- `signature[%s]`: is %s"", invalid_indexes, invalid_classes)
-    ),
-  call. = FALSE)
+  for (i in seq_along(signature)) {
+    signature[[i]] <- as_class(signature[[i]], arg = sprintf(""signature[[%i]]"", i))
+  }
+  signature
 }
 
 method_impl <- function(generic, signature, ignore) {
   out <- .Call(method_, generic, signature, ignore)
-  if (is.null(out)) {
-    # If no R7 method is found, see if there are any S3 methods registered
-    if (inherits(generic, ""R7_generic"")) {
-      args <- generic@dispatch_args
-      generic <- generic@name
-    } else {
-      generic <- find_function_name(generic, topenv(environment(generic)))
-      args <- names(formals(generic))
-    }
-    args <- setdiff(args, ""..."")
+  if (!is.null(out)) {
+    return(out)
+  }
 
-    out <- getS3method(generic, signature[[1]][[1]], optional = TRUE)
+  # If no R7 method is found, see if there are any S3 methods registered
+  if (inherits(generic, ""R7_generic"")) {
+    args <- generic@dispatch_args
+    generic <- generic@name
+  } else {
+    args <- setdiff(names(formals(generic)), ""..."")
+    generic <- find_function_name(generic, topenv(environment(generic)))
+  }
 
-    # If no method found check if the generic has a default method
-    out <- getS3method(generic, ""default"", optional = TRUE)
+  out <- getS3method(generic, s3_class_name(signature[[1]]), optional = TRUE)
+  if (!is.null(out)) {
+    return(out)
   }
 
-  if (is.null(out)) {
-    method_lookup_error(generic, args, signature)
+  # If no method found check if the generic has a default method
+  out <- getS3method(generic, ""default"", optional = TRUE)
+  if (!is.null(out)) {
+    return(out)
   }
 
-  out
+  method_lookup_error(generic, args, signature)
 }
 
 find_function_name <- function(x, env) {
@@ -174,6 +169,8 @@ method_compatible <- function(method, generic) {
 }
 
 new_method <- function(generic, signature, method, package = NULL) {
+  signature <- as_signature(signature)
+
   if (inherits(generic, ""R7_external_generic"")) {
     # Get current package, if any
     if (!is.null(package)) {
@@ -201,10 +198,8 @@ new_method <- function(generic, signature, method, package = NULL) {
   }
 
   if (inherits(generic, ""S3_generic"")) {
-    if (inherits(signature[[1]], ""R7_class"")) {
-      signature[[1]] <- signature[[1]]@name
-    }
-    registerS3method(attr(generic, ""name""), signature[[1]], method, envir = parent.frame())
+    class <- s3_class_name(signature[[1]])
+    registerS3method(attr(generic, ""name""), class, method, envir = parent.frame())
     return(invisible(generic))
   }
 
@@ -214,21 +209,25 @@ new_method <- function(generic, signature, method, package = NULL) {
 
 
   for (i in seq_along(signature)) {
+    # Register one method for each class in union
     if (inherits(signature[[i]], ""R7_union"")) {
+      this_sig <- signature
       for (class in signature[[i]]@classes) {
-        new_method(generic, c(signature[seq_len(i - 1)], class@name), method)
+        this_sig[[i]] <- class
+        method <- R7_method(generic, this_sig, method)
+        new_method(generic, this_sig, method, package = package)
       }
       return(invisible(generic))
-    } else if (inherits(signature[[i]], ""R7_class"")) {
-      signature[[i]] <- signature[[i]]@name
     }
+
+    class_name <- r7_class_name(signature[[i]])
     if (i == length(signature)) {
-      p_tbl[[signature[[i]]]] <- method
+      p_tbl[[class_name]] <- method
     } else {
-      tbl <- p_tbl[[signature[[i]]]]
+      tbl <- p_tbl[[class_name]]
       if (is.null(tbl)) {
         tbl <- new.env(hash = TRUE, parent = emptyenv())
-        p_tbl[[signature[[i]]]] <- tbl
+        p_tbl[[class_name]] <- tbl
       }
       p_tbl <- tbl
     }
@@ -237,6 +236,26 @@ new_method <- function(generic, signature, method, package = NULL) {
   invisible(generic)
 }
 
+# Class name when registering an S3 method
+s3_class_name <- function(x) {
+  switch(class_type(x),
+   s3 = class(x),
+   s4 = class(x),
+   r7 = x@name,
+   r7_base = typeof(x),
+   stop(""Unsupported"")
+  )
+}
+# Class name when registering an R7 method
+r7_class_name <- function(x) {
+  switch(class_type(x),
+    s3 = x,
+    s4 = x@className,
+    r7 = x@name,
+    r7_base = x@name,
+    stop(""Unsupported"")
+  )
+}
 
 #' @rdname method
 #'
@@ -269,12 +288,9 @@ as_generic <- function(generic) {
 
 #' @export
 print.R7_method <- function(x, ...) {
-  method_signature <- method_signature(x@signature)
-
-  msg <- sprintf(""method(%s, list(%s))"", x@generic@name, method_signature)
+  signature <- method_signature(x@generic, x@signature)
+  cat(""<R7_method> "", signature, ""\n"", sep = """")
 
   attributes(x) <- NULL
-
-  cat(""<R7_method> "", msg, ""\n"", sep = """")
   print(x)
 }

---FILE: R/object.R---
@@ -26,18 +26,25 @@ new_object <- function(.data = NULL, ...) {
   }
 
   if (!is.null(.data)) {
-    # Verify .data satisfies the parent class
-    cls_nms <- class_names(obj_cls@parent)
-
-    if (!identical(cls_nms, ""R7_object"") && !inherits(.data, cls_nms)) {
-      stop_bad_type(cls_nms, class(.data))
-    }
-
-    if (identical(cls_nms, ""R7_object"") && hasName(base_classes, obj_cls@name)) {
+    # TODO eliminate this special case
+    if (obj_cls@name %in% names(base_types)) {
       if (!inherits(.data, obj_cls@name)) {
-        stop_bad_type(obj_cls@name, class(.data))
+        stop(sprintf(
+          ""`.data` must be %s not %s"",
+          class_desc(as_class(obj_cls@name)),
+          obj_desc(.data)
+        ))
+      }
+    } else {
+      if (!class_inherits(.data, obj_cls@parent)) {
+        stop(sprintf(
+          ""`.data` must be %s not %s"",
+          class_desc(obj_cls@parent),
+          obj_desc(.data)
+        ))
       }
     }
+
     object <- .data
   } else {
     object <- obj_cls@parent@constructor()
@@ -56,17 +63,6 @@ new_object <- function(.data = NULL, ...) {
   object
 }
 
-stop_bad_type <- function(expected, actual) {
-  stop(
-    sprintf(
-      ""`.data` must be %s not %s"",
-      fmt_classes(expected),
-      fmt_classes(actual[[1]])
-    ),
-    call. = FALSE
-  )
-}
-
 #' Retrieve the R7 class of an object
 #' @param object The R7 object
 #' @export
@@ -95,7 +91,7 @@ print.R7_object <- function(x, ...) {
   } else {
     prop_fmt <- """"
   }
-  cat(sprintf(""<%s>\n%s"", paste(class(x), collapse = ""/""), prop_fmt), sep = """")
+  cat(sprintf(""%s\n%s"", obj_desc(x), prop_fmt), sep = """")
 }
 
 #' @export

---FILE: R/property.R---
@@ -56,12 +56,15 @@
 #' hadley@firstName
 #' hadley@first_name
 new_property <- function(name, class = NULL, getter = NULL, setter = NULL) {
+  class <- as_class(class)
   out <- list(name = name, class = class, getter = getter, setter = setter)
   class(out) <- ""R7_property""
 
   out
 }
 
+is_property <- function(x) inherits(x, ""R7_property"")
+
 #' @export
 str.R7_property <- function(object, ..., nest.lev = 0) {
   cat(if (nest.lev > 0) "" "")
@@ -105,8 +108,7 @@ prop <- function(object, name) {
   if (!inherits(object, ""R7_object"")) {
     stop(""`object` is not an <R7_object>"")
   } else if (!prop_exists(object, name)) {
-    class <- object_class(object)
-    stop(sprintf(""Can't find property %s@%s"", fmt_classes(attr(class, ""name"")), name))
+    stop(sprintf(""Can't find property %s@%s"", obj_desc(object), name))
   } else {
     prop_val(object, name)
   }
@@ -191,12 +193,12 @@ prop_exists <- function(object, name) {
       on.exit(setter_property <<- NULL, add = TRUE)
       object <- prop$setter(object, value)
     } else {
-      if (isTRUE(check) && length(prop[[""class""]]) > 0) {
-        classes <- setdiff(class_names(prop[[""class""]]), ""R7_object"")
-        if (!inherits(value, classes)) {
-          obj_cls <- object_class(object)
-          stop(sprintf(""%s@%s must be of class %s:\n- `value` is of class <%s>"", fmt_classes(obj_cls@name), name, fmt_classes(classes), class(value)[[1]]), call. = FALSE)
-        }
+      if (isTRUE(check) && !class_inherits(value, prop$class)) {
+        stop(sprintf(""%s@%s must be of class %s, not %s"",
+          obj_desc(object), name,
+          class_desc(prop$class),
+          obj_desc(value)
+        ), call. = FALSE)
       }
       attr(object, name) <- value
     }
@@ -235,16 +237,16 @@ as_properties <- function(x) {
     return(list())
   }
 
-  named_chars <- vlapply(x, is.character) & has_names(x)
-  R7_properties <- vlapply(x, inherits, ""R7_property"")
-
-  if (!all(named_chars | R7_properties)) {
-    stop(""`x` must be a list of 'R7_property' objects or named characters"", call. = FALSE)
-  }
+  named_class <- !vlapply(x, is_property) & has_names(x)
 
-  x[named_chars] <- mapply(new_property, name = names(x)[named_chars], class = x[named_chars], USE.NAMES = TRUE, SIMPLIFY = FALSE)
+  x[named_class] <- mapply(new_property,
+    name = names(x)[named_class],
+    class = x[named_class],
+    USE.NAMES = TRUE,
+    SIMPLIFY = FALSE
+  )
 
-  names(x)[!named_chars] <- vcapply(x[!named_chars], function(x) x[[""name""]])
+  names(x)[!named_class] <- vcapply(x[!named_class], function(x) x[[""name""]])
 
   x
 }

---FILE: R/utils.R---
@@ -32,23 +32,20 @@ vlapply <- function(X, FUN, ...) vapply(X = X, FUN = FUN, FUN.VALUE = logical(1)
 vcapply <- function(X, FUN, ...) vapply(X = X, FUN = FUN, FUN.VALUE = character(1), ...)
 `%||%` <- function(x, y) if (length(x) == 0 || (length(x) == 1 && !nzchar(x))) y else x
 
-fmt_classes <- function(classes, collapse = "", "") {
-  paste0(""<"", classes, "">"", collapse = collapse)
-}
-
 collapse <- function(x, by) {
   paste(x, collapse = by)
 }
 
-method_signature <- function(signature) {
-  format_signature <- function(x) {
-    if (inherits(x, ""R7_class"")) {
-      x@name
-    } else {
-      sprintf('""%s""', x)
-    }
+method_signature <- function(generic, signature) {
+  single <- length(generic@dispatch_args) == 1
+  if (single) {
+    signature <- class_deparse(signature[[1]])
+  } else {
+    classes <- vcapply(signature, class_deparse)
+    signature <- paste0(""list("", paste0(classes, collapse = "", ""), "")"")
   }
-  collapse(vcapply(signature, format_signature), by = "", "")
+
+  sprintf(""method(%s, %s)"", generic@name, signature)
 }
 
 as_names <- function(x, named = FALSE) {
@@ -72,3 +69,19 @@ make_function <- function(args, body, env = parent.frame()) {
 
   as.function.default(c(args, body), envir = env)
 }
+
+is_prefix <- function(x, y) {
+  length(x) <= length(y) && identical(unclass(x), unclass(y)[seq_along(x)])
+}
+
+oxford_or <- function (x)  {
+  n <- length(x)
+  if (n == 1) {
+    x
+  } else if (n == 2) {
+    paste0(x[[1]], "" or "", x[[2]])
+  } else if (n >= 2) {
+    x <- c(x[seq(1, n - 2, by = 1)], paste0(x[[n - 1]], "", or "", x[[n]]))
+    paste0(x, collapse = "", "")
+  }
+}

---FILE: R/zzz.R---
@@ -1,3 +1,5 @@
+is_union <- function(x) inherits(x, ""R7_union"")
+
 #' An R7 object
 #' @export
 R7_object <- new_class(
@@ -14,7 +16,7 @@ new_base_class <- function(name) {
   R7_class(name = name, constructor = function(.data) new_object(.data))
 }
 
-base_types <- setNames(, c(""logical"", ""integer"", ""double"", ""numeric"", ""complex"", ""character"", ""factor"", ""raw"", ""function"", ""list"", ""data.frame""))
+base_types <- setNames(, c(""logical"", ""integer"", ""double"", ""numeric"", ""complex"", ""character"", ""raw"", ""function"", ""list"", ""environment""))
 
 base_classes <- lapply(base_types, new_base_class)
 base_classes[[""NULL""]] <- new_base_class(""NULL"")
@@ -44,7 +46,7 @@ R7_generic <- new_class(
 
 R7_method <- new_class(
   name = ""R7_method"",
-  properties = list(generic = ""R7_generic"", signature = ""list"", fun = ""function""),
+  properties = list(generic = R7_generic, signature = ""list"", fun = ""function""),
   parent = ""function"",
   constructor = function(generic, signature, fun) {
     if (is.character(signature)) {
@@ -60,7 +62,7 @@ R7_union <- new_class(
     new_property(
       ""classes"",
       setter = function(x, val) {
-        x@classes <- class_standardise(val)
+        x@classes <- class_flatten(val)
         x
       }
     )
@@ -70,8 +72,8 @@ R7_union <- new_class(
   }
 )
 
-class_standardise <- function(x) {
-  x <- lapply(x, class_get, unions = TRUE)
+class_flatten <- function(x) {
+  x <- lapply(x, as_class)
 
   # Flatten unions
   is_union <- vlapply(x, is_union)
@@ -81,11 +83,9 @@ class_standardise <- function(x) {
   unique(unlist(x, recursive = FALSE, use.names = FALSE))
 }
 
-is_union <- function(x) inherits(x, ""R7_union"")
-
 #' @export
 print.R7_union <- function(x, ...) {
-  cat(sprintf(""<R7_union>: %s"", fmt_classes(class_names(x), "" u "")), ""\n"", sep = """")
+  cat(sprintf(""<R7_union>: %s"", class_desc(x)), ""\n"", sep = """")
   invisible(x)
 }
 

---FILE: _pkgdown.yml---
@@ -10,11 +10,12 @@ reference:
   - new_union
   - new_external_generic
   - r7_data
+  - s3_class
   - R7_object
 
 - title: Introspection
   contents:
-  - class_get
+  - as_class
   - class_names
   - object_class
   - method

---FILE: man/as_class.Rd---
@@ -0,0 +1,29 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/class-spec.R
+\name{as_class}
+\alias{as_class}
+\title{Standard class specifications}
+\usage{
+as_class(x, arg = deparse(substitute(x)))
+}
+\arguments{
+\item{x}{A class specification.
+\itemize{
+\item An R7 class object or class union.
+\item An S3 class object, created by \code{s3_class()}.
+\item An S4 class object.
+\item A base type specified either with its constructor (\code{logical}, \code{integer},
+\code{double} etc) or its name (\code{""logical""}, \code{""integer""}, ""\code{double}"" etc).
+}}
+
+\item{arg}{Argument name used when generating errors.}
+}
+\value{
+A standardised class: either \code{NULL}, an R7 class, an R7 union,
+as \link{s3_class}, or a S4 class.
+}
+\description{
+This is used as the interface between R7 and R's other OO systems, allowing
+you to use R7 classes and methods with base types, informal S3 classes, and
+formal S4 classes.
+}

---FILE: man/class_get.Rd---
@@ -1,18 +0,0 @@
-% Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/class.R
-\name{class_get}
-\alias{class_get}
-\title{Retrieve the R7 class from a class specification}
-\usage{
-class_get(x, unions = FALSE, envir = parent.frame())
-}
-\arguments{
-\item{x}{The name of the R7 class}
-
-\item{unions}{Include unions?}
-
-\item{envir}{The environment to look for the name}
-}
-\description{
-Retrieve the R7 class from a class specification
-}

---FILE: man/method.Rd---
@@ -33,11 +33,11 @@ interactively in order to see the implementation of a specific method.
 bizarro <- new_generic(""bizarro"", dispatch_args = ""x"")
 # Register some methods
 method(bizarro, ""numeric"") <- function(x, ...) rev(x)
-method(bizarro, ""factor"") <- function(x, ...) {
+method(bizarro, s3_class(""factor"")) <- function(x, ...) {
   levels(x) <- rev(levels(x))
   x
 }
-method(bizarro, ""data.frame"") <- function(x, ...) {
+method(bizarro, s3_class(""data.frame"")) <- function(x, ...) {
   x[] <- lapply(x, bizarro)
   rev(x)
 }
@@ -47,6 +47,6 @@ bizarro(1)
 
 # But it can be useful to explicitly retrieve a method in order to
 # inspect its implementation
-method(bizarro, list(""numeric""))
-method(bizarro, list(""factor""))
+method(bizarro, ""numeric"")
+method(bizarro, s3_class(""factor""))
 }

---FILE: man/new_generic.Rd---
@@ -45,7 +45,7 @@ immediately after the dispatch arguments.
 # A simple generic with methods for some base types and S3 classes
 type_of <- new_generic(""type_of"", dispatch_args = ""x"")
 method(type_of, ""character"") <- function(x, ...) ""A character vector""
-method(type_of, ""data.frame"") <- function(x, ...) ""A data frame""
+method(type_of, s3_class(""data.frame"")) <- function(x, ...) ""A data frame""
 method(type_of, ""function"") <- function(x, ...) ""A function""
 
 type_of(mtcars)

---FILE: man/s3_class.Rd---
@@ -0,0 +1,15 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/class-spec.R
+\name{s3_class}
+\alias{s3_class}
+\title{Declare an S3 class vector}
+\usage{
+s3_class(class)
+}
+\arguments{
+\item{class}{Character vector of S3 classes}
+}
+\description{
+The S3 class system is informal so doesn't have a way to formally register
+a class. This helper allows you to use S3 classes within R7.
+}

---FILE: tests/testthat/_snaps/class-spec.md---
@@ -0,0 +1,22 @@
+# can get class from base constructor
+
+    Can't convert `mean` to a valid class. Could not find base class corresponding to supplied constructor function
+
+# as_class gives informative errors
+
+    Code
+      as_class(""foo"")
+    Error <simpleError>
+      Can't convert `""foo""` to a valid class. No base classes are called 'foo'
+    Code
+      as_class(TRUE)
+    Error <simpleError>
+      Can't convert `TRUE` to a valid class. Class specification must be an R7 class object, the result of `s3_class()`, an S4 class object, or a base constructor function, not a <logical>.
+
+# s3_class() checks its inputs
+
+    Code
+      s3_class(1)
+    Error <simpleError>
+      `class` must be a character vector
+

---FILE: tests/testthat/_snaps/class.md---
@@ -26,16 +26,18 @@
       List of 1
        $ : <my_class/R7_object> constructor
 
-# classes can use unions in properties
+# classes can't inherit from S4 or class unions
 
-    <my_class>@name must be of class <character>, <factor>:
-    - `value` is of class <numeric>
+    Code
+      new_class(""test"", parent = parentS4)
+    Error <simpleError>
+      `parent` must be an R7 class, S3 class, or base type, not an S4 class.
+    Code
+      new_class(""test"", parent = new_union(""character""))
+    Error <simpleError>
+      `parent` must be an R7 class, S3 class, or base type, not a class union.
 
 # constructor  types check their values
 
     `.data` must be <integer> not <character>
 
-# can get class from base constructor
-
-    Could not find class for constructor function
-

---FILE: tests/testthat/_snaps/generic.md---
@@ -40,12 +40,18 @@
 # R7_generic printing
 
     Code
-      foo
+      foo1
+    Output
+      <R7_generic> function (x, y, z, ...)  with 2 methods:
+      1: method(foo1, list(""character""))
+      2: method(foo1, list(text))
+    Code
+      foo3
     Output
       <R7_generic> function (x, y, z, ...)  with 3 methods:
-      1: method(foo, list(""character"", ""integer"", ""character""))
-      2: method(foo, list(""character"", ""integer"", ""logical""))
-      3: method(foo, list(""character"", text, ""character""))
+      1: method(foo3, list(""character"", ""integer"", ""character""))
+      2: method(foo3, list(""character"", ""integer"", ""logical""))
+      3: method(foo3, list(""character"", text, ""character""))
 
 # R7_generic printing with long / many arguments
 

---FILE: tests/testthat/_snaps/method.md---
@@ -1,23 +1,27 @@
 # method errors on invalid inputs
 
-    `signature` must be a list of <R7_class> or a <character>:
-    - `signature[1]`: is <numeric>
+    Can't convert `signature[[1]]` to a valid class. Class specification must be an R7 class object, the result of `s3_class()`, an S4 class object, or a base constructor function, not a <double>.
 
 ---
 
-    `signature` must be a list of <R7_class> or a <character>:
-    - `signature[1]`: is <numeric>
+    Can't convert `signature[[1]]` to a valid class. Class specification must be an R7 class object, the result of `s3_class()`, an S4 class object, or a base constructor function, not a <double>.
 
 ---
 
-    `signature` must be a list of <R7_class> or a <character>:
-    - `signature[1]`: is <logical>
-    - `signature[2]`: is <logical>
+    Can't convert `signature[[1]]` to a valid class. Class specification must be an R7 class object, the result of `s3_class()`, an S4 class object, or a base constructor function, not a <logical>.
 
 # method errors if no method is defined for that class
 
-    Can't find method for generic `foo()` with classes:
-    - x: <blah>
+    Can't convert `signature[[1]]` to a valid class. No base classes are called 'blah'
+
+# new_method works if you pass a bare class union
+
+    Code
+      foo7
+    Output
+      <R7_generic> function (x, ...)  with 2 methods:
+      1: method(foo7, number)
+      2: method(foo7, text)
 
 # method_compatible errors if the functions are not compatible
 

---FILE: tests/testthat/_snaps/object.md---
@@ -23,7 +23,7 @@
     Code
       print(x)
     Output
-      <range/R7_object>
+      <range>
       @start   1
       @end    10
       @length  9
@@ -71,17 +71,17 @@
       @ properties : List of 3
        .. $ start : <R7_property> 
        .. .. $ name  :  chr ""start""
-       .. .. $ class :  chr ""numeric""
+       .. .. $ class :  <numeric/R7_object> constructor
        .. .. $ getter:  NULL
        .. .. $ setter:  NULL
        .. $ end   : <R7_property> 
        .. .. $ name  :  chr ""end""
-       .. .. $ class :  chr ""numeric""
+       .. .. $ class :  <numeric/R7_object> constructor
        .. .. $ getter:  NULL
        .. .. $ setter:  NULL
        .. $ length: <R7_property> 
        .. .. $ name  :  chr ""length""
-       .. .. $ class :  chr ""numeric""
+       .. .. $ class :  <numeric/R7_object> constructor
        .. .. $ getter:  function (x)  
        .. .. $ setter:  function (x, value)  
       @ constructor:  function (start, end)  

---FILE: tests/testthat/_snaps/property.md---
@@ -17,3 +17,42 @@
     Error <simpleError>
       trying to get slot ""blah"" from an object of a basic class (""NULL"") with no slots
 
+# properties can be base, S3, S4, R7, or R7 union
+
+    Code
+      my_class
+    Output
+      <R7_class>
+      @name my_class
+      @parent <R7_object>
+      @properties
+       $anything                  <ANY>
+       $base                  <integer>
+       $s3                     <factor>
+       $s4                   <class_s4>
+       $r7                   <class_r7>
+       $r7_union <integer> or <logical>
+
+---
+
+    Code
+      my_obj@base <- ""x""
+    Error <simpleError>
+      <my_class>@base must be of class <integer>, not <character>
+    Code
+      my_obj@s3 <- ""x""
+    Error <simpleError>
+      <my_class>@s3 must be of class <factor>, not <character>
+    Code
+      my_obj@s4 <- ""x""
+    Error <simpleError>
+      <my_class>@s4 must be of class <class_s4>, not <character>
+    Code
+      my_obj@r7 <- ""x""
+    Error <simpleError>
+      <my_class>@r7 must be of class <class_r7>, not <character>
+    Code
+      my_obj@r7_union <- ""x""
+    Error <simpleError>
+      <my_class>@r7_union must be of class <integer> or <logical>, not <character>
+

---FILE: tests/testthat/_snaps/zzz.md---
@@ -5,5 +5,5 @@
       foo2 <- new_class(""foo2"")
       new_union(foo1, foo2)
     Output
-      <R7_union>: <foo1> u <foo2> u <R7_object>
+      <R7_union>: <foo1> or <foo2>
 

---FILE: tests/testthat/test-class-spec.R---
@@ -0,0 +1,142 @@
+test_that(""can work with R7 classes"", {
+  klass <- new_class(""klass"")
+  expect_equal(as_class(klass), klass)
+
+  expect_equal(class_type(klass), ""r7"")
+  expect_equal(class_desc(klass), ""<klass>"")
+  expect_equal(class_deparse(klass), ""klass"")
+
+  obj <- klass()
+  expect_equal(obj_type(obj), ""r7"")
+  expect_equal(obj_desc(obj), ""<klass>"")
+  expect_equal(class_inherits(obj, klass), TRUE)
+})
+
+test_that(""can work with unions"", {
+  klass <- new_union(text, number)
+  expect_equal(as_class(klass), klass)
+
+  expect_equal(class_type(klass), ""r7_union"")
+  expect_equal(class_desc(klass), ""<text> or <number>"")
+  expect_equal(class_deparse(klass), ""new_union(text, number)"")
+
+  # Can't have an instance of a union so no obj_ tests
+
+  expect_equal(class_inherits(text(""x""), klass), TRUE)
+  expect_equal(class_inherits(number(1), klass), TRUE)
+})
+
+test_that(""handles NULL"", {
+  expect_equal(as_class(NULL), NULL)
+
+  expect_equal(class_type(NULL), ""NULL"")
+  expect_equal(class_desc(NULL), ""<ANY>"")
+  expect_equal(class_deparse(NULL), """")
+
+  expect_equal(obj_type(NULL), ""NULL"")
+  expect_equal(obj_desc(NULL), ""NULL"")
+  expect_equal(class_inherits(""x"", NULL), TRUE)
+})
+
+test_that(""can work with S4 constructors"", {
+  klass <- methods::setClass(""Range"", slots = c(start = ""numeric"", end = ""numeric""))
+  expect_equal(class_type(klass), ""s4"")
+  expect_equal(class_desc(klass), ""<Range>"")
+  expect_equal(class_deparse(klass), ""Range"")
+
+  obj <- klass(start = 1, end = 1)
+  expect_equal(obj_type(obj), ""s4"")
+  expect_equal(obj_desc(obj), ""<Range>"")
+  expect_equal(class_inherits(obj, klass), TRUE)
+})
+
+test_that(""can work with S4 classes"", {
+  methods::setClass(""Range"", slots = c(start = ""numeric"", end = ""numeric""))
+  klass <- methods::getClass(""Range"")
+  expect_equal(class_type(klass), ""s4"")
+  expect_equal(class_desc(klass), ""<Range>"")
+  expect_equal(class_deparse(klass), ""Range"")
+
+  obj <- methods::new(klass, start = 1, end = 1)
+  expect_equal(obj_type(obj), ""s4"")
+  expect_equal(obj_desc(obj), ""<Range>"")
+  expect_equal(class_inherits(obj, klass), TRUE)
+})
+
+test_that(""can work with simple S3 classes"", {
+  klass <- s3_class(""data.frame"")
+  expect_equal(as_class(klass), klass)
+
+  expect_equal(class_type(klass), ""s3"")
+  expect_equal(class_desc(klass), ""<data.frame>"")
+  expect_equal(class_deparse(klass), 's3_class(""data.frame"")')
+
+  obj <- data.frame()
+  expect_equal(obj_type(obj), ""s3"")
+  expect_equal(obj_desc(obj), ""<data.frame>"")
+  expect_equal(class_inherits(obj, klass), TRUE)
+})
+
+test_that(""can work with compound s3 classes"", {
+  klass <- s3_class(c(""ordered"", ""factor""))
+  expect_equal(as_class(klass), klass)
+
+  expect_equal(class_type(klass), ""s3"")
+  expect_equal(class_desc(klass), ""<ordered>"")
+  expect_equal(class_deparse(klass), 's3_class(""ordered"", ""factor"")')
+
+  obj <- ordered(integer())
+  expect_equal(obj_type(obj), ""s3"")
+  expect_equal(obj_desc(obj), ""<ordered>"")
+  expect_equal(class_inherits(obj, klass), TRUE)
+  expect_equal(class_inherits(factor(), klass), FALSE)
+})
+
+test_that(""can work with base types"", {
+  expect_equal(as_class(""character""), base_classes$character)
+  expect_equal(as_class(character), base_classes$character)
+  expect_equal(as_class(double), base_classes$double)
+
+  klass <- as_class(""character"")
+  expect_equal(class_type(klass), ""r7_base"")
+  expect_equal(class_desc(klass), ""<character>"")
+  expect_equal(class_deparse(klass), '""character""')
+
+  obj <- ""x""
+  expect_equal(obj_type(obj), ""base"")
+  expect_equal(obj_desc(obj), ""<character>"")
+  expect_equal(class_inherits(obj, klass), TRUE)
+})
+
+test_that(""class_inherits handles variation in class names"", {
+  expect_true(class_inherits(1, base_classes$double))
+
+  expect_true(class_inherits(1L, base_classes$numeric))
+  expect_true(class_inherits(1, base_classes$numeric))
+
+  expect_true(class_inherits(function() {}, base_classes$`function`))
+  expect_true(class_inherits(sum, base_classes$`function`))
+  expect_true(class_inherits(`[`, base_classes$`function`))
+})
+
+test_that(""can get class from base constructor"", {
+  expect_equal(as_class(character), base_classes$character)
+  expect_equal(as_class(`function`), base_classes$`function`)
+
+  expect_snapshot_error(as_class(mean))
+})
+
+
+# input validation -------------------------------------------------------------
+
+test_that(""as_class gives informative errors"", {
+  expect_snapshot(error = TRUE, {
+    as_class(""foo"")
+    as_class(TRUE)
+  })
+})
+
+
+test_that(""s3_class() checks its inputs"", {
+  expect_snapshot(s3_class(1), error = TRUE)
+})

---FILE: tests/testthat/test-class.R---
@@ -50,22 +50,21 @@ test_that(""classes can inherit from base types"", {
   expect_equal(typeof(r7_data(obj)), ""closure"")
 })
 
+test_that(""classes can't inherit from S4 or class unions"", {
+  parentS4 <- methods::setClass(""parentS4"", slots = c(x = ""numeric""))
+  expect_snapshot(error = TRUE, {
+    new_class(""test"", parent = parentS4)
+    new_class(""test"", parent = new_union(""character""))
+  })
+})
+
 test_that(""can supply literal examples of base types"", {
   foo <- new_class(""foo"", parent = integer)
   obj <- foo(1L)
   expect_s3_class(obj, ""integer"")
   expect_type(r7_data(obj), ""integer"")
 })
 
-test_that(""classes can use unions in properties"", {
-  my_class <- new_class(""my_class"", properties = list(new_property(name = ""name"", new_union(""character"", ""factor""))))
-
-  expect_equal(my_class(name = ""foo"")@name, ""foo"")
-  expect_equal(my_class(name = factor(""foo""))@name, factor(""foo""))
-
-  expect_snapshot_error(my_class(name = 1))
-})
-
 test_that(""default constructor works"", {
   foo1 <- new_class(""foo1"", properties = list(x = ""numeric""))
   foo2 <- new_class(""foo2"", parent = foo1, properties = list(y = ""numeric""))
@@ -81,21 +80,3 @@ test_that(""default constructor works"", {
 test_that(""constructor  types check their values"", {
   expect_snapshot_error(new_class(""foo"", parent = integer)(""abc""))
 })
-
-
-
-# class_get ---------------------------------------------------------------
-
-test_that(""can get class from string"", {
-  foo <- new_class(""foo"")
-  expect_equal(class_get(""foo""), foo)
-
-  expect_equal(class_get(""character""), base_classes$character)
-})
-
-test_that(""can get class from base constructor"", {
-  expect_equal(class_get(character), base_classes$character)
-  expect_equal(class_get(`function`), base_classes$`function`)
-
-  expect_snapshot_error(class_get(mean))
-})

---FILE: tests/testthat/test-data.R---
@@ -1,7 +1,7 @@
 describe(""r7_data"", {
   it(""retrieves .data"", {
     x <- text(""hi"")
-    expect_equal(r7_data(x), class_get(""character"")(""hi""))
+    expect_equal(r7_data(x), as_class(""character"")(""hi""))
   })
   it(""strips properties"", {
     text <- new_class(""text"", parent = ""character"", properties = list(x = ""integer""))
@@ -11,12 +11,12 @@ describe(""r7_data"", {
   it(""preserves non-property attributes when retrieving .data"", {
     val <- c(foo = ""hi"", bar = ""ho"")
     x <- text(val)
-    expect_equal(r7_data(x), class_get(""character"")(val))
+    expect_equal(r7_data(x), as_class(""character"")(val))
   })
   it(""lets you set data"", {
     val <- c(foo = ""hi"", bar = ""ho"")
     x <- text(""foo"")
     r7_data(x) <- ""bar""
-    expect_equal(r7_data(x), class_get(""character"")(""bar""))
+    expect_equal(r7_data(x), as_class(""character"")(""bar""))
   })
 })

---FILE: tests/testthat/test-dispatch.R---
@@ -51,7 +51,7 @@ test_that(""generics pass extra args to methods"", {
 
 test_that(""method lookup fails with informative messages"", {
   foo <- new_generic(""foo"", dispatch_args = c(""x"", ""y""))
-  method(foo, c(""character"", ""integer"")) <- function(x, y, ...) paste0(""bar:"", x, y)
+  method(foo, list(""character"", ""integer"")) <- function(x, y) paste0(""bar:"", x, y)
   expect_snapshot_error(foo(TRUE))
   expect_snapshot_error(foo(TRUE, list()))
   expect_snapshot_error(foo(tibble::tibble(), .POSIXct(double())))

---FILE: tests/testthat/test-generic.R---
@@ -39,14 +39,19 @@ test_that(""check_dispatch_args() produces informative errors"", {
 })
 
 test_that(""R7_generic printing"", {
-  foo <- new_generic(name = ""foo"", dispatch_args = c(""x"", ""y"", ""z""))
-  method(foo, list(""character"", text, ""character"")) <- function(x, y, z, ...) 1
-  method(foo, list(""character"", ""integer"", ""character"")) <- function(x, y, z, ...) 2
-  method(foo, list(""character"", ""integer"", ""logical"")) <- function(x, y, z, ...) 3
+  foo1 <- new_generic(name = ""foo1"", dispatch_args = c(""x"", ""y"", ""z""))
+  method(foo1, list(""character"")) <- function(x, y, z, ...) 1
+  method(foo1, list(text)) <- function(x, y, z, ...) 2
 
-  expect_snapshot(
-    foo
-  )
+  foo3 <- new_generic(name = ""foo3"", dispatch_args = c(""x"", ""y"", ""z""))
+  method(foo3, list(""character"", text, ""character"")) <- function(x, y, z, ...) 1
+  method(foo3, list(""character"", ""integer"", ""character"")) <- function(x, y, z, ...) 2
+  method(foo3, list(""character"", ""integer"", ""logical"")) <- function(x, y, z, ...) 3
+
+  expect_snapshot({
+    foo1
+    foo3
+  })
 })
 
 test_that(""R7_generic printing with long / many arguments"", {

---FILE: tests/testthat/test-method.R---
@@ -1,13 +1,13 @@
 test_that(""method will fall back to S3 generics if no R7 generic is defined"", {
   expect_equal(
-    method(print, list(""text"")),
+    method(print, list(text)),
     base::print.default
   )
 })
 
 test_that(""method will accept a character vector (#71)"", {
   expect_equal(
-    method(print, ""text""),
+    method(print, ""character""),
     base::print.default
   )
 })
@@ -35,7 +35,7 @@ test_that(""method errors if no method is defined for that class"", {
 
 test_that(""methods can be registered for a generic and then called"", {
   foo <- new_generic(""foo"", dispatch_args = ""x"")
-  new_method(foo, ""text"", function(x, ...) paste0(""foo-"", r7_data(x)))
+  new_method(foo, text, function(x, ...) paste0(""foo-"", r7_data(x)))
 
   expect_equal(foo(text(""bar"")), ""foo-bar"")
 })
@@ -50,7 +50,7 @@ test_that(""single inheritance works when searching for methods"", {
 
 test_that(""direct multiple dispatch works"", {
   foo3 <- new_generic(""foo3"", dispatch_args = c(""x"", ""y""))
-  new_method(foo3, list(""text"", ""number""), function(x, y, ...) paste0(x, y))
+  new_method(foo3, list(text, number), function(x, y, ...) paste0(x, y))
   expect_equal(foo3(text(""bar""), number(1)), ""bar1"")
 })
 
@@ -63,24 +63,21 @@ test_that(""inherited multiple dispatch works"", {
 
 test_that(""method dispatch works for S3 objects"", {
   foo <- new_generic(""foo"", dispatch_args = ""x"")
-
   obj <- structure(""hi"", class = ""my_s3"")
-
-  new_method(foo, ""my_s3"", function(x, ...) paste0(""foo-"", x))
+  new_method(foo, s3_class(""my_s3""), function(x, ...) paste0(""foo-"", x))
 
   expect_equal(foo(obj), ""foo-hi"")
 })
 
-test_that(""method dispatch works for S3 objects"", {
+test_that(""method dispatch works for S4 objects"", {
   skip_if_not(requireNamespace(""methods""))
 
-  Range <- setClass(""Range"", slots = c(start = ""numeric"", end = ""numeric""))
-  obj <- Range(start = 1, end = 10)
-
   foo <- new_generic(""foo"", dispatch_args = ""x"")
 
-  new_method(foo, ""Range"", function(x, ...) paste0(""foo-"", x@start, ""-"", x@end))
+  Range <- setClass(""Range"", slots = c(start = ""numeric"", end = ""numeric""))
+  new_method(foo, Range, function(x, ...) paste0(""foo-"", x@start, ""-"", x@end))
 
+  obj <- Range(start = 1, end = 10)
   expect_equal(foo(obj), ""foo-1-10"")
 })
 
@@ -104,16 +101,19 @@ test_that(""new_method works if you pass a bare class union"", {
 
   expect_equal(foo7(text(""bar"")), ""foo-bar"")
   expect_equal(foo7(number(1)), ""foo-1"")
+
+  # one method for each union component
+  expect_length(methods(foo7), 2)
+  # and methods printed nicely
+  expect_snapshot(foo7)
 })
 
 test_that(""next_method works for single dispatch"", {
   foo <- new_generic(""foo"", dispatch_args = ""x"")
 
-  new_method(foo, ""text"", function(x, ...) {
-    r7_data(x) <- paste0(""foo-"", r7_data(x))
-    next_method()(x)
+  new_method(foo, text, function(x, ...) {
+    x@.data <- paste0(""foo-"", r7_data(x))
   })
-
   new_method(foo, ""character"", function(x, ...) {
     as.character(x)
   })
@@ -122,27 +122,27 @@ test_that(""next_method works for single dispatch"", {
 })
 
 test_that(""next_method works for double dispatch"", {
+  skip(""Currently broken"")
   foo <- new_generic(""foo"", dispatch_args = c(""x"", ""y""))
 
-  new_method(foo, list(""text"", ""number""), function(x, y, ...) {
+  new_method(foo, list(text, number), function(x, y, ...) {
     r7_data(x) <- paste0(""foo-"", r7_data(x), ""-"", r7_data(y))
-    next_method()(x, y)
+    next_method()(x)
   })
 
-  new_method(foo, list(""character"", ""number""), function(x, y, ...) {
+  new_method(foo, list(character, number), function(x, y, ...) {
     r7_data(y) <- y + 1
     r7_data(x) <- paste0(r7_data(x), ""-"", r7_data(y))
     next_method()(x, y)
   })
 
-  new_method(foo, list(""character"", ""numeric""), function(x, y, ...) {
+  new_method(foo, list(character, double), function(x, y, ...) {
     as.character(r7_data(x))
   })
 
   expect_equal(foo(text(""hi""), number(1)), ""foo-hi-1-2"")
 })
 
-
 test_that(""method_compatible returns TRUE if the functions are compatible"", {
   foo <- new_generic(""foo"", function(x, ...) method_call())
   expect_true(method_compatible(function(x, ...) x, foo))
@@ -170,7 +170,6 @@ test_that(""method_compatible warn if default arguments don't match"", {
   })
 })
 
-
 test_that(""R7_method printing"", {
   foo <- new_generic(name=""foo"", dispatch_args = c(""x"", ""y""))
   method(foo, list(text, ""integer"")) <- function(x, y, ...) paste0(""bar:"", x, y)

---FILE: tests/testthat/test-object.R---
@@ -24,7 +24,7 @@ describe(""new_object"", {
 
   it(""can instantiate a new object that inherits from a basic type"", {
     y <- text(""foo"")
-    expect_equal(r7_data(y), class_get(""character"")(""foo""))
+    expect_equal(r7_data(y), as_class(""character"")(""foo""))
   })
 
   it(""errors if given an invalid property"", {
@@ -53,7 +53,7 @@ describe(""new_object"", {
     foo1 <- new_class(""foo1"", properties = list(x = ""numeric""))
     foo2 <- new_class(""foo2"", foo1, properties = list(x = ""character""))
     expect_equal(names(foo2@properties), ""x"")
-    expect_equal(foo2@properties$x$class, ""character"")
+    expect_equal(foo2@properties$x$class, as_class(""character""))
   })
 
   it(""can use the parent constructor to instantiate objects"", {

---FILE: tests/testthat/test-property.R---
@@ -12,6 +12,21 @@ describe(""prop"", {
     x <- range(1, 10)
     expect_snapshot_error(prop(x, ""st""))
   })
+  it(""retrieves .data"", {
+    x <- text(""hi"")
+    expect_equal(r7_data(x), as_class(""character"")(""hi""))
+  })
+  it(""preserves non-property attributes when retrieving .data"", {
+    val <- c(foo = ""hi"", bar = ""ho"")
+    x <- text(val)
+    expect_equal(r7_data(x), as_class(""character"")(val))
+  })
+  it(""lets you set .data"", {
+    val <- c(foo = ""hi"", bar = ""ho"")
+    x <- text(""foo"")
+    r7_data(x) <- ""bar""
+    expect_equal(r7_data(x), as_class(""character"")(""bar""))
+  })
 })
 
 describe(""prop<-"", {
@@ -131,3 +146,45 @@ test_that(""property setters can set themselves"", {
   x <- foo(bar = ""foo"")
   expect_equal(x@bar, ""foo-bar"")
 })
+
+test_that(""properties can be base, S3, S4, R7, or R7 union"", {
+  class_r7 <- new_class(""class_r7"")
+  class_s4 <- methods::setClass(""class_s4"", slots = c(x = ""numeric""))
+
+  my_class <- new_class(""my_class"",
+    properties = list(
+      anything = NULL,
+      base = ""integer"",
+      s3 = s3_class(""factor""),
+      s4 = class_s4,
+      r7 = class_r7,
+      r7_union = new_union(""integer"", ""logical"")
+    )
+  )
+  expect_snapshot(my_class)
+  my_obj <- my_class(
+    anything = TRUE,
+    base = 1L,
+    s3 = factor(),
+    s4 = class_s4(x = 1),
+    r7 = class_r7(),
+    r7_union = 1L
+  )
+
+  # First check that we can set with out error
+  expect_error(my_obj@base <- 2L, NA)
+  expect_error(my_obj@s3 <- factor(""x""), NA)
+  expect_error(my_obj@s4 <- class_s4(x = 2), NA)
+  expect_error(my_obj@r7 <- class_r7(), NA)
+  expect_error(my_obj@r7_union <- 2L, NA)
+  expect_error(my_obj@r7_union <- TRUE, NA)
+
+  # Then capture the error messages for human inspection
+  expect_snapshot(error = TRUE, {
+    my_obj@base <- ""x""
+    my_obj@s3 <- ""x""
+    my_obj@s4 <- ""x""
+    my_obj@r7 <- ""x""
+    my_obj@r7_union <- ""x""
+  })
+})

---FILE: tests/testthat/test-zzz.R---
@@ -30,3 +30,10 @@ test_that(""can construct from unions"", {
     c(""character"", ""integer"", ""R7_object"")
   )
 })
+
+test_that(""can construct from S3 and S4 classes"", {
+  factor <- s3_class(""factor"")
+  s4_union <- methods::setClass(""s4_union"")
+  u <- new_union(factor, s4_union)
+  expect_equal(u@classes, list(factor, getClass(""s4_union"")))
+})

---FILE: vignettes/case_studies.Rmd---
@@ -28,7 +28,7 @@ Person <- new_class(""Person"",
     name = ""character"",
     new_property(
       name = ""birthdate"",
-      class = ""Date"",
+      class = s3_class(""Date""),
       setter = function(object, value) {
         object@birthdate <- as.Date(value)
         object
@@ -78,7 +78,7 @@ Classes can inherit from a parent class with `parent` and contain properties tha
 ```{r}
 Employee <- new_class(""Employee"",
   parent = Person,
-  properties = list(boss = ""Person"")
+  properties = list(boss = Person)
 )
 
 x <- Employee(name = ""John Smith"", birthdate = ""1992-10-11"", boss = jane)
@@ -103,11 +103,13 @@ In particular the number of rows of the `rows` property matches the number of ro
 
 Here is the definition of the class.
 ```{r}
+tbl_df <- s3_class(c(""tbl_df"", ""tbl"", ""data.frame""))
+
 annotated_df <- new_class(""annotated_df"",
-  parent = c(""tbl_df"", ""tbl"", ""data.frame""),
+  parent = tbl_df,
   properties = list(
-    rows = c(""tbl_df"", ""tbl"", ""data.frame""),
-    columns = c(""tbl_df"", ""tbl"", ""data.frame"")
+    rows = tbl_df,
+    columns = tbl_df
     ),
   validator = function(object) {
     if (nrow(object) != nrow(object@rows)) {

---FILE: vignettes/performance.Rmd---
@@ -28,7 +28,7 @@ x <- text(""hi"")
 y <- number(1)
 
 foo_R7 <- new_generic(""foo_R7"", dispatch_args = ""x"")
-method(foo_R7, ""text"") <- function(x, ...) paste0(x, ""-foo"")
+method(foo_R7, text) <- function(x, ...) paste0(x, ""-foo"")
 
 foo_s3 <- function(x, ...) {
   UseMethod(""foo_s3"")
@@ -49,7 +49,7 @@ setMethod(""foo_s4"", c(""text""), function(x, ...) paste0(x, ""-foo""))
 bench::mark(foo_R7(x), foo_s3(x), foo_s4(x))
 
 bar_R7 <- new_generic(""bar_R7"", dispatch_args = c(""x"", ""y""))
-method(bar_R7, list(""text"", ""number"")) <- function(x, y, ...) paste0(x, ""-"", y, ""-bar"")
+method(bar_R7, list(text, number)) <- function(x, y, ...) paste0(x, ""-"", y, ""-bar"")
 
 setGeneric(""bar_s4"", function(x, y, ...) standardGeneric(""bar_s4""))
 setMethod(""bar_s4"", c(""text"", ""number""), function(x, y, ...) paste0(x, ""-"", y, ""-bar""))
@@ -80,12 +80,12 @@ bench::press(
   class_nchar = c(15, 100),
   {
     # Construct a class hierarchy with that number of classes
-    text <- new_class(""text"", parent = ""character"", constructor = function(text) new_object(.data = text))
+    text <- new_class(""text"", parent = ""character"")
     parent <- text
     classes <- gen_character(num_classes, min = class_nchar, max = class_nchar)
     env <- new.env()
     for (x in classes) {
-      assign(x, new_class(x, parent = parent, constructor = function(text) new_object(.data = text)), env)
+      assign(x, new_class(x, parent = parent), env)
       parent <- get(x, env)
     }
 
@@ -119,12 +119,12 @@ bench::press(
   class_nchar = c(15, 100),
   {
     # Construct a class hierarchy with that number of classes
-    text <- new_class(""text"", parent = ""character"", constructor = function(text) new_object(.data = text))
+    text <- new_class(""text"", parent = ""character"")
     parent <- text
     classes <- gen_character(num_classes, min = class_nchar, max = class_nchar)
     env <- new.env()
     for (x in classes) {
-      assign(x, new_class(x, parent = parent, constructor = function(text) new_object(.data = text)), env)
+      assign(x, new_class(x, parent = parent), env)
       parent <- get(x, env)
     }
 "
RConsortium,S7,d8271295b837139dac2ed53139209fd5f0bcf2ae,Hadley Wickham,h.wickham@gmail.com,2022-02-02T18:20:10Z,Hadley Wickham,h.wickham@gmail.com,2022-02-02T18:20:10Z,"Improve str method for classes

Fixes #144",NAMESPACE;R/class.R;tests/testthat/_snaps/class.md;tests/testthat/_snaps/object.md;tests/testthat/test-class.R;tests/testthat/test-object.R,False,True,True,False,40,7,47,"---FILE: NAMESPACE---
@@ -6,6 +6,7 @@ S3method(print,R7_generic)
 S3method(print,R7_method)
 S3method(print,R7_object)
 S3method(print,R7_union)
+S3method(str,R7_class)
 S3method(str,R7_object)
 export(""@"")
 export(""method<-"")

---FILE: R/class.R---
@@ -186,3 +186,16 @@ print.R7_class <- function(x, ...) {
 
   cat(sprintf(""<R7_class>\n@name %s\n@parent <%s>\n@properties\n%s"", x@name, parent, prop_fmt), sep = """")
 }
+
+#' @export
+str.R7_class <- function(object, ..., nest.lev = 0) {
+  if (nest.lev > 0) cat("" "")
+  cat(""<"", paste0(class_names(object), collapse = ""/""), ""> constructor"", sep = """")
+  if (nest.lev > 0) cat(""\n"") else cat("" "")
+
+  if (nest.lev == 0) {
+    bare <- unclass(object)
+    attr(bare, ""object_class"") <- NULL
+    str(bare, ..., nest.lev = nest.lev + 1)
+  }
+}

---FILE: tests/testthat/_snaps/class.md---
@@ -8,6 +8,23 @@
       @parent <R7_object>
       @properties
 
+# R7_class: str yields all details when used at top-level
+
+    Code
+      str(my_class)
+    Output
+      <my_class/R7_object> constructor function ()  
+       .. - attr(*, ""name"")= chr ""my_class""
+       .. - attr(*, ""parent"")= <R7_object> constructor
+       .. - attr(*, ""properties"")= list()
+       .. - attr(*, ""constructor"")=function ()  
+       .. - attr(*, ""validator"")=function (x)  
+    Code
+      str(list(my_class))
+    Output
+      List of 1
+       $ : <my_class/R7_object> constructor
+
 # classes can use unions in properties
 
     <my_class>@name must be of class <character>, <factor>:

---FILE: tests/testthat/_snaps/object.md---
@@ -64,13 +64,9 @@
     Code
       str(range)
     Output
-       <R7_class/R7_object> function (start, end)  
+      <range/R7_object> constructor function (start, end)  
        .. - attr(*, ""name"")= chr ""range""
-       .. - attr(*, ""parent"")= <R7_class/R7_object> function ()  
-       ..  ..- attr(*, ""name"")= chr ""R7_object""
-       ..  ..- attr(*, ""properties"")= list()
-       ..  ..- attr(*, ""constructor"")=function ()  
-       ..  ..- attr(*, ""validator"")=function (x)  
+       .. - attr(*, ""parent"")= <R7_object> constructor
        .. - attr(*, ""properties"")=List of 3
        ..  ..$ start :List of 4
        ..  .. ..$ name  : chr ""start""

---FILE: tests/testthat/test-class.R---
@@ -24,6 +24,12 @@ describe(""R7_class"", {
   it(""can be printed"", {
     expect_snapshot(my_class)
   })
+  it(""str yields all details when used at top-level"", {
+    expect_snapshot(transform = scrub_src_references, {
+      str(my_class)
+      str(list(my_class))
+    })
+  })
 })
 
 test_that(""classes can inherit from base types"", {

---FILE: tests/testthat/test-object.R---
@@ -79,7 +79,7 @@ test_that(""printing R7 classes work"", {
 })
 
 test_that(""str with simple R7 objects work"", {
-  expect_snapshot(str(range(1, 2)), transform = scrub_src_references)
+  expect_snapshot(str(range(1, 2)))
 })
 
 test_that(""str with R7 objects of base classes work"", {"
RConsortium,S7,d88f7b5c94052adef1e345a0f964422c1d0bcc40,Hadley Wickham,h.wickham@gmail.com,2022-01-26T18:54:36Z,GitHub,noreply@github.com,2022-01-26T18:54:36Z,"Revamp method calling (#141)

Fixes #85. Fixes #88.",NEWS.md;R/dispatch.R;R/generic.R;R/method.R;man/method_call.Rd;man/new_generic.Rd;src/dispatch.c;tests/testthat/_snaps/dispatch.md;tests/testthat/_snaps/generic.md;tests/testthat/_snaps/method.md;tests/testthat/test-dispatch.R;tests/testthat/test-generic.R;tests/testthat/test-method.R,False,True,True,False,329,338,667,"---FILE: NEWS.md---
@@ -2,6 +2,8 @@
 
 ## Jan 2020
 
+* Different evaluation mechanism for method dispatch, and greater restrictions 
+  on dispatch args (#141)
 * `x@.data` -> `r7_data()`; probably to be replaced by casting.
 * In generic, `signature` -> `dispatch_args`.
 * `new_class()` has properties as 3rd argument (instead of constructor).

---FILE: R/dispatch.R---
@@ -0,0 +1,11 @@
+method_lookup_error <- function(name, args, signatures) {
+  args <- setdiff(args, ""..."")
+  types <- paste0(""- "", args, "": "", vcapply(signatures, fmt_classes), collapse = ""\n"")
+  stop(sprintf(""Can't find method for generic `%s()` with classes:\n%s"", name, types), call. = FALSE)
+}
+
+#' Lookup the R7 method for the current generic and call it.
+#' @export
+method_call <- function() {
+  .Call(method_call_, sys.call(-1), sys.function(-1), sys.frame(-1))
+}

---FILE: R/generic.R---
@@ -5,13 +5,29 @@
 #' of one or more arguments (the `signature`). Create a new generic with
 #' `new_generic()` then use [method<-] to add methods to it.
 #'
+#' @section Dispatch arguments:
+#' The arguments that are used to pick the method are called the **dispatch
+#' arguments**. In most cases, this will be one argument, in which case the
+#' generic is said to use **single dispatch**. If it consists of more than
+#' one argument, it's said to use **multiple dispatch**.
+#'
+#' There are two restrictions on the dispatch arguments: they must be the first
+#' arguments to the generic and if the generic uses `...`, it must occur
+#' immediately after the dispatch arguments.
+#'
 #' @param name The name of the generic. This should be the same as the object
 #'   that you assign it to.
 #' @param dispatch_args A character vector providing the names of arguments to
-#'   dispatch on. If omitted, defaults to the required arguments of `fun`.
+#'   dispatch on.
+#'
+#'   If `dispatch_args` are omitted, but `fun` is supplied, will default to the
+#'   arguments that appear before `...` in `fun`. If there are no dots, it will
+#'   default to the first argument. If both `fun` and `dispatch_args` are
+#'   supplied, the `dispatch_args` must appear at the start of `fun`'s formals.
+#'
 #' @param fun An optional specification of the generic, which must call
 #'  `method_call()` to dispatch to methods. This is usually generated
-#'  automatically from the `signature`, but you may want to supply it if
+#'  automatically from the `dispatch_args`, but you may want to supply it if
 #'  you want to add additional required arguments, or perform some standardised
 #'  computation in the generic.
 #' @seealso [new_external_generic()] to define a method for a generic
@@ -39,7 +55,9 @@
 #'   }
 #'   sum(x) / length(x)
 #' }
-#' method(mean2, ""character"") <- function(x, ...) {stop(""Not supported"")}
+#' method(mean2, ""character"") <- function(x, ..., na.rm = TRUE) {
+#'   stop(""Not supported"")
+#' }
 #'
 new_generic <- function(name, fun = NULL, dispatch_args = NULL) {
   if (is.null(dispatch_args) && is.null(fun)) {
@@ -53,12 +71,11 @@ new_generic <- function(name, fun = NULL, dispatch_args = NULL) {
     check_generic(fun)
     dispatch_args <- guess_dispatch_args(fun)
   } else {
-    dispatch_args <- check_dispatch_args(dispatch_args)
-    # For now, ensure all generics have ... in dispatch_args
-    dispatch_args <- union(dispatch_args, ""..."")
+    dispatch_args <- check_dispatch_args(dispatch_args, fun)
 
     if (is.null(fun)) {
-      args <- setNames(lapply(dispatch_args, function(i) quote(expr = )), dispatch_args)
+      args <- c(dispatch_args, ""..."")
+      args <- setNames(lapply(args, function(i) quote(expr = )), args)
       fun <- make_function(args, quote(method_call()), topenv(environment()))
     }
   }
@@ -68,17 +85,45 @@ new_generic <- function(name, fun = NULL, dispatch_args = NULL) {
 
 guess_dispatch_args <- function(fun) {
   formals <- formals(fun)
-  is_required <- vlapply(formals, identical, quote(expr = ))
-  names(formals[is_required])
+  # all arguments before ...
+  if (length(formals) == 0) {
+    character()
+  } else if (""..."" %in% names(formals)) {
+    names(formals)[seq_len(which(names(formals) == ""..."") - 1)]
+  } else {
+    names(formals)[[1]]
+  }
 }
 
-check_dispatch_args <- function(dispatch_args) {
+check_dispatch_args <- function(dispatch_args, fun = NULL) {
   if (!is.character(dispatch_args)) {
     stop(""`dispatch_args` must be a character vector"", call. = FALSE)
   }
   if (length(dispatch_args) == 0) {
     stop(""`dispatch_args` must have at least one component"", call. = FALSE)
   }
+  if (anyDuplicated(dispatch_args)) {
+    stop(""`dispatch_args` must be unique"", call. = FALSE)
+  }
+  if (any(is.na(dispatch_args) | dispatch_args == """")) {
+    stop(""`dispatch_args` must not be missing or the empty string"")
+  }
+  if (""..."" %in% dispatch_args) {
+    stop(""Can't dispatch on `...`"", call. = FALSE)
+  }
+
+  if (!is.null(fun)) {
+    arg_names <- names(formals(fun))
+
+    if (!identical(dispatch_args, arg_names[seq_along(dispatch_args)])) {
+      stop(""`dispatch_args` must be a prefix of the generic arguments"", call. = FALSE)
+    }
+
+    if (""..."" %in% arg_names && arg_names[[length(dispatch_args) + 1]] != ""..."") {
+      stop(""If present, ... must immediately follow the `dispatch_args`"", call. = FALSE)
+    }
+  }
+
   dispatch_args
 }
 

---FILE: R/method.R---
@@ -136,36 +136,40 @@ next_method <- function() {
   method_impl(generic, signature, ignore = methods)
 }
 
-
-arg_to_string <- function(arg) {
-  if (is.na(names(arg)[[1]])) {
-    return(""does not exist"")
-  }
-  sprintf(""is `%s = %s`"", names(arg), deparse(arg[[1]]))
-}
-
 method_compatible <- function(method, generic) {
   generic_formals <- suppressWarnings(formals(args(generic)))
-  method_formals <- formals(method)
-
   # This can happen for some primitive functions such as `[`
   if (length(generic_formals) == 0) {
     return()
   }
 
-  for (i in seq_len(length(generic_formals) - 1)) {
-    if (!identical(generic_formals[i], method_formals[i])) {
-      stop(sprintf(""`method` must be consistent with <R7_generic> %s.\n- Argument %i in generic %s\n- Argument %i in method %s"", generic@name, i, arg_to_string(generic_formals[i]), i, arg_to_string(method_formals[i])), call. = FALSE)
-    }
+  method_formals <- formals(method)
+  generic_args <- names(generic_formals)
+  method_args <- names(method_formals)
+
+  n_dispatch <- length(generic@dispatch_args)
+  has_dispatch <- length(method_formals) >= n_dispatch &&
+    identical(method_args[1:n_dispatch], generic@dispatch_args)
+  if (!has_dispatch) {
+    stop(""`method` doesn't match generic dispatch arg"", call. = FALSE)
   }
-
-  if (""..."" %in% names(generic_formals) && !""..."" %in% names(method_formals)) {
-      stop(sprintf(""`method` must be consistent with <R7_generic> %s.\n- `generic` has `...`\n- `method` does not have `...`"", generic@name), call. = FALSE)
+  if (""..."" %in% method_args && method_args[[n_dispatch + 1]] != ""..."") {
+    stop(""... must immediately follow dispatch args"", call. = FALSE)
+  }
+  empty_dispatch <- vlapply(method_formals[generic@dispatch_args], identical, quote(expr = ))
+  if (any(!empty_dispatch)) {
+    stop(""Dispatch arguments must not have default values"", call. = FALSE)
   }
 
-  if (!""..."" %in% names(generic_formals) && ""..."" %in% names(method_formals)) {
-      stop(sprintf(""`method` must be consistent with <R7_generic> %s.\n- `generic` does not have `...`\n- `method` has `...`"", generic@name), call. = FALSE)
+  extra_args <- setdiff(names(generic_formals), c(generic@dispatch_args, ""...""))
+  for (arg in extra_args) {
+    if (!arg %in% method_args) {
+      warning(sprintf(""Argument `%s` is missing from method"", arg), call. = FALSE)
+    } else if (!identical(generic_formals[[arg]], method_formals[[arg]])) {
+      warning(sprintf(""Default value is not the same as the generic\n- Generic: %s = %s\n- Method:  %s = %s"", arg, deparse1(generic_formals[[arg]]), arg, deparse1(method_formals[[arg]])), call. = FALSE)
+    }
   }
+
   TRUE
 }
 
@@ -263,18 +267,6 @@ as_generic <- function(generic) {
   generic
 }
 
-method_lookup_error <- function(name, args, signatures) {
-  args <- setdiff(args, ""..."")
-  types <- paste0(""- "", args, "": "", vcapply(signatures, fmt_classes), collapse = ""\n"")
-  stop(sprintf(""Can't find method for generic `%s()` with classes:\n%s"", name, types), call. = FALSE)
-}
-
-#' Lookup the R7 method for the current generic and call it.
-#' @export
-method_call <- function() {
-  .Call(method_call_, sys.call(-1), sys.function(-1), sys.frame(-1))
-}
-
 #' @export
 print.R7_method <- function(x, ...) {
   method_signature <- method_signature(x@signature)

---FILE: man/method_call.Rd---
@@ -1,5 +1,5 @@
 % Generated by roxygen2: do not edit by hand
-% Please edit documentation in R/method.R
+% Please edit documentation in R/dispatch.R
 \name{method_call}
 \alias{method_call}
 \title{Lookup the R7 method for the current generic and call it.}

---FILE: man/new_generic.Rd---
@@ -12,18 +12,35 @@ that you assign it to.}
 
 \item{fun}{An optional specification of the generic, which must call
 \code{method_call()} to dispatch to methods. This is usually generated
-automatically from the \code{signature}, but you may want to supply it if
+automatically from the \code{dispatch_args}, but you may want to supply it if
 you want to add additional required arguments, or perform some standardised
 computation in the generic.}
 
 \item{dispatch_args}{A character vector providing the names of arguments to
-dispatch on. If omitted, defaults to the required arguments of \code{fun}.}
+dispatch on.
+
+If \code{dispatch_args} are omitted, but \code{fun} is supplied, will default to the
+arguments that appear before \code{...} in \code{fun}. If there are no dots, it will
+default to the first argument. If both \code{fun} and \code{dispatch_args} are
+supplied, the \code{dispatch_args} must appear at the start of \code{fun}'s formals.}
 }
 \description{
 A generic function uses different implementations depending on the class
 of one or more arguments (the \code{signature}). Create a new generic with
 \code{new_generic()} then use \link{method<-} to add methods to it.
 }
+\section{Dispatch arguments}{
+
+The arguments that are used to pick the method are called the \strong{dispatch
+arguments}. In most cases, this will be one argument, in which case the
+generic is said to use \strong{single dispatch}. If it consists of more than
+one argument, it's said to use \strong{multiple dispatch}.
+
+There are two restrictions on the dispatch arguments: they must be the first
+arguments to the generic and if the generic uses \code{...}, it must occur
+immediately after the dispatch arguments.
+}
+
 \examples{
 # A simple generic with methods for some base types and S3 classes
 type_of <- new_generic(""type_of"", dispatch_args = ""x"")
@@ -46,7 +63,9 @@ method(mean2, ""numeric"") <- function(x, ..., na.rm = TRUE) {
   }
   sum(x) / length(x)
 }
-method(mean2, ""character"") <- function(x, ...) {stop(""Not supported"")}
+method(mean2, ""character"") <- function(x, ..., na.rm = TRUE) {
+  stop(""Not supported"")
+}
 
 }
 \seealso{

---FILE: src/dispatch.c---
@@ -116,95 +116,67 @@ void R7_method_lookup_error(SEXP generic, SEXP signature, SEXP envir) {
 SEXP method_call_(SEXP call, SEXP generic, SEXP envir) {
   int n_protect = 0;
 
-  // Get the signature, the names of arguments to use for dispatch
-  SEXP gen_signature_args = Rf_getAttrib(generic, Rf_install(""dispatch_args""));
-
-  // Every generic signature has `...` as the last arg, which we want to ignore.
-  R_xlen_t gen_signature_len = Rf_xlength(gen_signature_args);
-
-  Rboolean has_dots = strcmp(CHAR(STRING_ELT(gen_signature_args, gen_signature_len - 1)), ""..."") == 0;
-
-  if (has_dots) {
-    --gen_signature_len;
-  }
+  // Get the number of arguments to the generic
+  SEXP formals = FORMALS(generic);
+  R_xlen_t n_args = Rf_xlength(formals);
+  // And how many are used for dispatch
+  SEXP dispatch_args = Rf_getAttrib(generic, Rf_install(""dispatch_args""));
+  R_xlen_t n_dispatch = Rf_xlength(dispatch_args);
 
   // Allocate a list to store the classes for the arguments
-  SEXP signature_classes = PROTECT(Rf_allocVector(VECSXP, gen_signature_len));
+  SEXP dispatch_classes = PROTECT(Rf_allocVector(VECSXP, n_dispatch));
   ++n_protect;
 
-  // Allocate a pairlist to hold the argument promises when we do the call to the method
-  SEXP args = PROTECT(Rf_cons(R_NilValue, R_NilValue));
+  // Allocate a pairlist to hold the arguments for when we call the method
+  SEXP mcall = PROTECT(Rf_lcons(R_NilValue, R_NilValue));
   ++n_protect;
-  SEXP tail = args;
+  SEXP mcall_tail = mcall;
 
-  // For each of the arguments in the signature
-  for (R_xlen_t i = 0; i < gen_signature_len; ++i) {
+  // For each of the arguments to the generic
+  for (R_xlen_t i = 0; i < n_args; ++i) {
 
-    // Lookup the promise for that argument in the environment
-    SEXP name = Rf_install(CHAR(STRING_ELT(gen_signature_args, i)));
+    // Find its name and look up its value (a promise)
+    SEXP name = TAG(formals);
     SEXP arg = Rf_findVar(name, envir);
 
-    // Most of the time this should be a promise
-    if (TYPEOF(arg) == PROMSXP) {
-
-      // We first want to duplicate the existing promise
-      SEXP new_promise = PROTECT(Rf_duplicate(arg));
-
-      // Then evaluate the original promise so we can lookup its class
-      SEXP val = PROTECT(Rf_eval(arg, envir));
-
-      // And set the value of the new promise to that of the evaluated one, so
-      // we don't evaluate it twice in the method body.
-      SET_PRVALUE(new_promise, val);
-
-      // We can then add our new promise to our argument list
-      SETCDR(tail, Rf_cons(new_promise, R_NilValue));
-
-      // We need to call `R7::object_class()`, as not every object has a class
-      // attribute, some are created dynamically.
-      SEXP klass = PROTECT(object_class_(val, envir));
-
-      // Now that we have the classes for the argument we can add them to the signature classes
-      SET_VECTOR_ELT(signature_classes, i, klass);
-
-      UNPROTECT(3);
-    }
-    // but the bytecode compiler sometimes inlines literals, which we handle
-    // here
-    else {
-      SETCDR(tail, Rf_cons(arg, R_NilValue));
+    if (i < n_dispatch) {
+      if (PRCODE(arg) != R_MissingArg) {
+        // Evaluate the original promise so we can look up its class
+        SEXP val = Rf_eval(arg, R_EmptyEnv);
+        // And update the value of the promise to avoid evaluating it
+        // again in the method body
+        SET_PRVALUE(arg, val);
+
+        // Then add to arguments of method call
+        SETCDR(mcall_tail, Rf_cons(arg, R_NilValue));
+
+        // Determine class string to use for method look up
+        SET_VECTOR_ELT(dispatch_classes, i, object_class_(val, envir));
+      } else {
+        SETCDR(mcall_tail, Rf_cons(name, R_NilValue));
+        SET_VECTOR_ELT(dispatch_classes, i, Rf_mkString(""MISSING""));
+      }
+    } else {
+      // other arguments not used for dispatch
+      SEXP arg_wrap = Rf_cons(name, R_NilValue);
+      SET_TAG(arg_wrap, name);
+      SETCDR(mcall_tail, arg_wrap);
     }
 
-    // Move the pointer forward for the next iteration
-    tail = CDR(tail);
-  }
-
-
-  // We only need to add the dots to our arguments if the generic has dots and
-  // something was passed in them. Otherwise they are `R_MissingArg` and we
-  // don't need to.
-  if (has_dots) {
-    SEXP dots = Rf_findVar(R_DotsSymbol, envir);
-    if (dots != R_MissingArg) {
-      SETCDR(tail, dots);
-    }
+    mcall_tail = CDR(mcall_tail);
+    formals = CDR(formals);
   }
 
-  // The head of args is always R_NilValue, so we just want the tail
-  args = CDR(args);
-
-  // Now that we have retrieved all the classes, we can look up what method to call.
-  SEXP m = method_(generic, signature_classes, R_NilValue);
-
-  // If no method found, throw an error
+  // Now that we have all the classes, we can look up what method to call
+  SEXP m = method_(generic, dispatch_classes, R_NilValue);
   if (m == R_NilValue) {
-    R7_method_lookup_error(generic, signature_classes, envir);
+    R7_method_lookup_error(generic, dispatch_classes, envir);
   }
+  SETCAR(mcall, m);
 
-  // And then actually call it.
-  SEXP res = Rf_applyClosure(call, m, args, envir, R_NilValue);
+  // And then call it
+  SEXP res = Rf_eval(mcall, envir);
 
   UNPROTECT(n_protect);
-
   return res;
 }

---FILE: tests/testthat/_snaps/dispatch.md---
@@ -0,0 +1,22 @@
+# generics pass ... to methods
+
+    unused argument (z = 2)
+
+# method lookup fails with informative messages
+
+    Can't find method for generic `foo()` with classes:
+    - x: <logical>
+    - y: <MISSING>
+
+---
+
+    Can't find method for generic `foo()` with classes:
+    - x: <logical>
+    - y: <list>
+
+---
+
+    Can't find method for generic `foo()` with classes:
+    - x: <tbl_df>, <tbl>, <data.frame>
+    - y: <POSIXct>, <POSIXt>
+

---FILE: tests/testthat/_snaps/generic.md---
@@ -12,6 +12,30 @@
       check_dispatch_args(character())
     Error <simpleError>
       `dispatch_args` must have at least one component
+    Code
+      check_dispatch_args("""")
+    Error <simpleError>
+      `dispatch_args` must not be missing or the empty string
+    Code
+      check_dispatch_args(NA_character_)
+    Error <simpleError>
+      `dispatch_args` must not be missing or the empty string
+    Code
+      check_dispatch_args(c(""x"", ""x""))
+    Error <simpleError>
+      `dispatch_args` must be unique
+    Code
+      check_dispatch_args(""..."")
+    Error <simpleError>
+      Can't dispatch on `...`
+    Code
+      check_dispatch_args(""x"", function(x, y, ...) { })
+    Error <simpleError>
+      If present, ... must immediately follow the `dispatch_args`
+    Code
+      check_dispatch_args(""y"", function(x, ..., y) { })
+    Error <simpleError>
+      `dispatch_args` must be a prefix of the generic arguments
 
 # R7_generic printing
 

---FILE: tests/testthat/_snaps/method.md---
@@ -19,65 +19,39 @@
     Can't find method for generic `foo()` with classes:
     - x: <blah>
 
-# method_compatible throws errors if the functions are not compatible
+# method_compatible errors if the functions are not compatible
 
-    `method` must be consistent with <R7_generic> foo.
-    - Argument 1 in generic is `x = `
-    - Argument 1 in method is `y = `
-
----
-
-    `method` must be consistent with <R7_generic> foo.
-    - `generic` has `...`
-    - `method` does not have `...`
-
----
-
-    `method` must be consistent with <R7_generic> foo.
-    - Argument 1 in generic is `x = `
-    - Argument 1 in method is `x = ""foo""`
-
----
-
-    `method` must be consistent with <R7_generic> bar.
-    - Argument 1 in generic is `x = `
-    - Argument 1 in method is `y = `
-
----
-
-    `method` must be consistent with <R7_generic> bar.
-    - `generic` has `...`
-    - `method` does not have `...`
-
----
-
-    `method` must be consistent with <R7_generic> bar.
-    - Argument 2 in generic is `y = `
-    - Argument 2 in method is `y = NULL`
-
-# method compatible verifies that if a generic does not have dots the method should not have dots
-
-    `method` must be consistent with <R7_generic> foo.
-    - `generic` does not have `...`
-    - `method` has `...`
-
-# method lookup fails with an informative message for single classes
-
-    Can't find method for generic `foo()` with classes:
-    - x: <logical>
-    - y: <list>
-
----
-
-    Can't find method for generic `foo()` with classes:
-    - x: <logical>
-    - y: <>
+    Code
+      foo <- new_generic(""foo"", dispatch_args = ""x"")
+      method_compatible(function(y) { }, foo)
+    Error <simpleError>
+      `method` doesn't match generic dispatch arg
+    Code
+      method_compatible(function(x = ""foo"") { }, foo)
+    Error <simpleError>
+      Dispatch arguments must not have default values
+    Code
+      method_compatible(function(x, y, ...) { }, foo)
+    Error <simpleError>
+      ... must immediately follow dispatch args
 
-# method lookup fails with an informative message for multiple classes
+# method_compatible warn if default arguments don't match
 
-    Can't find method for generic `foo()` with classes:
-    - x: <tbl_df>, <tbl>, <data.frame>
-    - y: <POSIXct>, <POSIXt>
+    Code
+      foo <- new_generic(""foo"", function(x, ..., z = 2, y = 1) method_call())
+      method_compatible(function(x, ..., y = 1) { }, foo)
+    Warning <simpleWarning>
+      Argument `z` is missing from method
+    Output
+      [1] TRUE
+    Code
+      method_compatible(function(x, ..., y = 1, z = 1) { }, foo)
+    Warning <simpleWarning>
+      Default value is not the same as the generic
+      - Generic: z = 2
+      - Method:  z = 1
+    Output
+      [1] TRUE
 
 # R7_method printing
 

---FILE: tests/testthat/test-dispatch.R---
@@ -0,0 +1,58 @@
+test_that(""can substitute() args"", {
+  foo <- new_generic(""foo"", function(x, ..., z = 1) method_call())
+  method(foo, ""character"") <- function(x, ..., z = 1) substitute(x)
+  expect_equal(foo(letters), quote(letters))
+
+  method(foo, ""character"") <- function(x, ..., z = 1, y) substitute(y)
+  expect_equal(foo(""x"", y = letters), quote(letters))
+
+  # Doesn't work currently
+  # method(foo, ""character"") <- function(x, ..., z = 1) substitute(z)
+  # expect_equal(foo(""x"", z = letters), quote(letters))
+})
+
+test_that(""methods get values modified in the generic"", {
+  foo <- new_generic(""foo"", function(x, y = 1) {
+    y <- 10
+    method_call()
+  })
+  method(foo, ""character"") <- function(x, y = 1) y
+  expect_equal(foo(""x"", 1), 10)
+})
+
+test_that(""dispatched arguments are evaluated once"", {
+  counter <- local({
+    i <- 0
+    function() {
+      i <<- i + 1
+      i
+    }
+  })
+
+  f <- new_generic(""f"", dispatch_args = ""x"")
+  method(f, ""numeric"") <- function(x) x
+  expect_equal(f(counter()), 1)
+})
+
+test_that(""generics pass ... to methods"", {
+  foo <- new_generic(""foo"", dispatch_args = ""x"")
+
+  method(foo, ""character"") <- function(x, y = 1) y
+  expect_equal(foo(""x""), 1)
+  expect_equal(foo(""x"", y = 2), 2)
+  expect_snapshot_error(foo(""x"", z = 2))
+})
+
+test_that(""generics pass extra args to methods"", {
+  foo <- new_generic(""foo"", function(x, ..., z = 1) method_call())
+  method(foo, ""character"") <- function(x, ..., z = 1) z
+  expect_equal(foo(""x"", z = 3), 3)
+})
+
+test_that(""method lookup fails with informative messages"", {
+  foo <- new_generic(""foo"", dispatch_args = c(""x"", ""y""))
+  method(foo, c(""character"", ""integer"")) <- function(x, y, ...) paste0(""bar:"", x, y)
+  expect_snapshot_error(foo(TRUE))
+  expect_snapshot_error(foo(TRUE, list()))
+  expect_snapshot_error(foo(tibble::tibble(), .POSIXct(double())))
+})

---FILE: tests/testthat/test-generic.R---
@@ -4,40 +4,37 @@ test_that(""new_generic needs fun or dispatch_args"", {
 
 test_that(""dispatch_args overrules derived"", {
   g <- new_generic(""g"", function(x, y, ...) method_call())
-  expect_equal(g@dispatch_args, c(""x"", ""y"", ""...""))
+  expect_equal(g@dispatch_args, c(""x"", ""y""))
 
-  g <- new_generic(""g"", function(x, y, ...) method_call(), dispatch_args = ""x"")
-  expect_equal(g@dispatch_args, c(""x"", ""...""))
+  g <- new_generic(""g"", function(x, ...) method_call(), dispatch_args = ""x"")
+  expect_equal(g@dispatch_args, ""x"")
 })
 
-test_that(""generics pass ... to methods, and methods can define additional arguments on basic types"", {
-  foo <- new_generic(""foo"", dispatch_args = ""x"")
-  new_method(foo, ""character"", function(x, sep = ""-"", ...) paste0(""foo"", sep, x))
-
-  expect_equal(foo(""bar""), ""foo-bar"")
-  expect_equal(foo(""bar"", sep = ""/""), ""foo/bar"")
+test_that(""derived fun always includes ..."", {
+  g <- new_generic(""g"", dispatch_args = ""x"")
+  expect_equal(names(formals(g)), c(""x"", ""...""))
 })
 
-test_that(""generics pass ... to methods, and methods can define additional arguments on R7 objects"", {
-  foo <- new_generic(""foo"", dispatch_args = ""x"")
-  new_method(foo, ""text"", function(x, sep = ""-"", ...) paste0(""foo"", sep, x))
-
-  expect_equal(foo(text(""bar"")), ""foo-bar"")
-  expect_equal(foo(text(""bar""), sep = ""/""), ""foo/bar"")
-})
-
-test_that(""guesses dispatch_args from required arguments"", {
-  expect_equal(guess_dispatch_args(function() {}), NULL)
+test_that(""guesses dispatch_args from args after dots arguments"", {
+  expect_equal(guess_dispatch_args(function() {}), character())
   expect_equal(guess_dispatch_args(function(x) {}), ""x"")
-  expect_equal(guess_dispatch_args(function(x, y) {}), c(""x"", ""y""))
-  expect_equal(guess_dispatch_args(function(x, y, ...) {}), c(""x"", ""y"", ""...""))
-  expect_equal(guess_dispatch_args(function(x, ..., y = 1) {}), c(""x"", ""...""))
+  expect_equal(guess_dispatch_args(function(x, y) {}), ""x"")
+
+  expect_equal(guess_dispatch_args(function(...) {}), character())
+  expect_equal(guess_dispatch_args(function(x, y, ...) {}), c(""x"", ""y""))
+  expect_equal(guess_dispatch_args(function(x, ..., y = 1) {}), ""x"")
 })
 
 test_that(""check_dispatch_args() produces informative errors"", {
   expect_snapshot(error = TRUE, {
     check_dispatch_args(1)
     check_dispatch_args(character())
+    check_dispatch_args("""")
+    check_dispatch_args(NA_character_)
+    check_dispatch_args(c(""x"", ""x""))
+    check_dispatch_args(""..."")
+    check_dispatch_args(""x"", function(x, y, ...) {})
+    check_dispatch_args(""y"", function(x, ..., y) {})
   })
 })
 

---FILE: tests/testthat/test-method.R---
@@ -140,162 +140,37 @@ test_that(""next_method works for double dispatch"", {
   })
 
   expect_equal(foo(text(""hi""), number(1)), ""foo-hi-1-2"")
-
-})
-
-test_that(""substitute() works for single dispatch method calls like S3"", {
-  foo <- new_generic(""foo"", dispatch_args = ""x"")
-
-  new_method(foo, ""character"", function(x, ...) substitute(x))
-
-  bar <- ""blah""
-  expect_equal(foo(bar), as.symbol(""bar""))
 })
 
-test_that(""substitute() works for multiple dispatch method calls like S3"", {
-  foo <- new_generic(""foo"", dispatch_args = c(""x"", ""y""))
-
-  new_method(foo, ""character"", function(x, y, ...) c(substitute(x), substitute(y)))
-
-  bar <- ""blah""
-  baz <- ""bloo""
-  expect_equal(foo(bar, baz), c(as.symbol(""bar""), as.symbol(""baz"")))
-})
 
 test_that(""method_compatible returns TRUE if the functions are compatible"", {
-  foo <- new_generic(""foo"", dispatch_args = ""x"")
-
-  expect_true(
-    method_compatible(
-      function(x, ...) x,
-      foo
-    )
-  )
-
+  foo <- new_generic(""foo"", function(x, ...) method_call())
+  expect_true(method_compatible(function(x, ...) x, foo))
   # extra arguments are ignored
-  expect_true(
-    method_compatible(
-      function(x, y, ...) x,
-      foo
-    )
-  )
-
-  foo <- new_generic(""foo"", function(x = NULL) method_call())
-  expect_true(
-    method_compatible(
-      function(x = NULL) x,
-      foo
-    )
-  )
-
-  bar <- new_generic(""bar"", dispatch_args = c(""x"", ""y""))
-  expect_true(
-    method_compatible(
-      function(x, y, ...) x,
-      bar
-    )
-  )
-
-  bar <- new_generic(""bar"", function(x=NULL, y=1, ...) method_call())
-  expect_true(
-    method_compatible(
-      function(x = NULL, y = 1, ...) x,
-      bar
-    )
-  )
-})
-
-test_that(""method_compatible throws errors if the functions are not compatible"", {
-  foo <- new_generic(""foo"", dispatch_args = ""x"")
-
-  # Different argument names
-  expect_snapshot_error(
-    method_compatible(
-      function(y, ...) y,
-      foo
-    )
-  )
-
-  # No dots in method
-  expect_snapshot_error(
-    method_compatible(
-      function(x) x,
-      foo
-    )
-  )
+  expect_true(method_compatible(function(x, ..., y) x, foo))
 
-  # Different default values
-  expect_snapshot_error(
-    method_compatible(
-      function(x = ""foo"", ...) x,
-      foo
-    )
-  )
-
-  bar <- new_generic(""bar"", dispatch_args = c(""x"", ""y""))
-
-  # Arguments in wrong order
-  expect_snapshot_error(
-    method_compatible(
-      function(y, x, ...) x,
-      bar
-    )
-  )
-
-  # No dots in method
-  expect_snapshot_error(
-    method_compatible(
-      function(x, y) x,
-      bar
-    )
-  )
-
-  # Different default values
-  expect_snapshot_error(
-    method_compatible(
-      function(x, y = NULL) x,
-      bar
-    )
-  )
-})
-
-test_that(""method compatible verifies that if a generic does not have dots the method should not have dots"", {
   foo <- new_generic(""foo"", function(x) method_call())
-
-  expect_true(
-    method_compatible(
-      function(x) x,
-      foo
-    )
-  )
-  expect_snapshot_error(
-    method_compatible(
-      function(x, ...) x,
-      foo
-    )
-  )
+  expect_true(method_compatible(function(x) x, foo))
 })
 
-test_that(""method lookup fails with an informative message for single classes"", {
-  foo <- new_generic(name=""foo"", dispatch_args = c(""x"", ""y""))
-  method(foo, c(""character"", ""integer"")) <- function(x, y, ...) paste0(""bar:"", x, y)
-  expect_snapshot_error(
-    foo(TRUE, list())
-  )
-
-  expect_snapshot_error(
-    foo(TRUE)
-  )
+test_that(""method_compatible errors if the functions are not compatible"", {
+  expect_snapshot(error = TRUE, {
+    foo <- new_generic(""foo"", dispatch_args = ""x"")
+    method_compatible(function(y) {}, foo)
+    method_compatible(function(x = ""foo"") {}, foo)
+    method_compatible(function(x, y, ...) {}, foo)
+  })
 })
 
-test_that(""method lookup fails with an informative message for multiple classes"", {
-  foo <- new_generic(name=""foo"", dispatch_args = c(""x"", ""y""))
-  method(foo, c(""character"", ""integer"")) <- function(x, y, ...) paste0(""bar:"", x, y)
-  expect_snapshot_error(
-    foo(tibble::tibble(), .POSIXct(double()))
-  )
+test_that(""method_compatible warn if default arguments don't match"", {
+  expect_snapshot({
+    foo <- new_generic(""foo"", function(x, ..., z = 2, y = 1) method_call())
+    method_compatible(function(x, ..., y = 1) {}, foo)
+    method_compatible(function(x, ..., y = 1, z = 1) {}, foo)
+  })
 })
 
+
 test_that(""R7_method printing"", {
   foo <- new_generic(name=""foo"", dispatch_args = c(""x"", ""y""))
   method(foo, list(text, ""integer"")) <- function(x, y, ...) paste0(""bar:"", x, y)"
RConsortium,S7,c7c47a8652b107536ca36a748a0e3f9a9b4f2145,Hadley Wickham,h.wickham@gmail.com,2022-01-26T18:29:06Z,GitHub,noreply@github.com,2022-01-26T18:29:06Z,"Rename signature to dispatch_args (#129)

Fixes #116",R/generic.R;R/method.R;R/zzz.R;README.Rmd;README.md;man/method.Rd;man/new_generic.Rd;src/code.c;tests/testthat/_snaps/generic.md;tests/testthat/t0/R/pkg.R;tests/testthat/t1/R/foo.R;tests/testthat/test-generic.R;tests/testthat/test-method.R;vignettes/case_studies.Rmd;vignettes/performance.Rmd,True,True,True,False,103,92,195,"---FILE: R/generic.R---
@@ -7,7 +7,7 @@
 #'
 #' @param name The name of the generic. This should be the same as the object
 #'   that you assign it to.
-#' @param signature A character vector providing the names of arguments to
+#' @param dispatch_args A character vector providing the names of arguments to
 #'   dispatch on. If omitted, defaults to the required arguments of `fun`.
 #' @param fun An optional specification of the generic, which must call
 #'  `method_call()` to dispatch to methods. This is usually generated
@@ -19,7 +19,7 @@
 #' @export
 #' @examples
 #' # A simple generic with methods for some base types and S3 classes
-#' type_of <- new_generic(""type_of"", signature = ""x"")
+#' type_of <- new_generic(""type_of"", dispatch_args = ""x"")
 #' method(type_of, ""character"") <- function(x, ...) ""A character vector""
 #' method(type_of, ""data.frame"") <- function(x, ...) ""A data frame""
 #' method(type_of, ""function"") <- function(x, ...) ""A function""
@@ -41,45 +41,45 @@
 #' }
 #' method(mean2, ""character"") <- function(x, ...) {stop(""Not supported"")}
 #'
-new_generic <- function(name, fun = NULL, signature = NULL) {
-  if (is.null(signature) && is.null(fun)) {
+new_generic <- function(name, fun = NULL, dispatch_args = NULL) {
+  if (is.null(dispatch_args) && is.null(fun)) {
     stop(
-      ""Must call `new_generic()` with at least one of `signature` or `fun`"",
+      ""Must call `new_generic()` with at least one of `dispatch_args` or `fun`"",
       call. = FALSE
     )
   }
 
-  if (is.null(signature)) {
+  if (is.null(dispatch_args)) {
     check_generic(fun)
-    signature <- guess_signature(fun)
+    dispatch_args <- guess_dispatch_args(fun)
   } else {
-    signature <- check_signature(signature)
-    # For now, ensure all generics have ... in signature
-    signature <- union(signature, ""..."")
+    dispatch_args <- check_dispatch_args(dispatch_args)
+    # For now, ensure all generics have ... in dispatch_args
+    dispatch_args <- union(dispatch_args, ""..."")
 
     if (is.null(fun)) {
-      args <- setNames(lapply(signature, function(i) quote(expr = )), signature)
+      args <- setNames(lapply(dispatch_args, function(i) quote(expr = )), dispatch_args)
       fun <- make_function(args, quote(method_call()), topenv(environment()))
     }
   }
 
-  R7_generic(name = name, signature = signature, fun = fun)
+  R7_generic(name = name, dispatch_args = dispatch_args, fun = fun)
 }
 
-guess_signature <- function(fun) {
+guess_dispatch_args <- function(fun) {
   formals <- formals(fun)
   is_required <- vlapply(formals, identical, quote(expr = ))
   names(formals[is_required])
 }
 
-check_signature <- function(signature) {
-  if (!is.character(signature)) {
-    stop(""`signature` must be a character vector"", call. = FALSE)
+check_dispatch_args <- function(dispatch_args) {
+  if (!is.character(dispatch_args)) {
+    stop(""`dispatch_args` must be a character vector"", call. = FALSE)
   }
-  if (length(signature) == 0) {
-    stop(""`signature` must have at least one component"", call. = FALSE)
+  if (length(dispatch_args) == 0) {
+    stop(""`dispatch_args` must have at least one component"", call. = FALSE)
   }
-  signature
+  dispatch_args
 }
 
 #' @export

---FILE: R/method.R---
@@ -19,7 +19,7 @@
 #' @export
 #' @examples
 #' # Create a generic
-#' bizarro <- new_generic(""bizarro"", signature = ""x"")
+#' bizarro <- new_generic(""bizarro"", dispatch_args = ""x"")
 #' # Register some methods
 #' method(bizarro, ""numeric"") <- function(x, ...) rev(x)
 #' method(bizarro, ""factor"") <- function(x, ...) {
@@ -81,7 +81,7 @@ method_impl <- function(generic, signature, ignore) {
   if (is.null(out)) {
     # If no R7 method is found, see if there are any S3 methods registered
     if (inherits(generic, ""R7_generic"")) {
-      args <- generic@signature
+      args <- generic@dispatch_args
       generic <- generic@name
     } else {
       generic <- find_function_name(generic, topenv(environment(generic)))
@@ -129,7 +129,7 @@ next_method <- function() {
   generic <- current_method
 
   # Find signature
-  dispatch_on <- setdiff(generic@signature, ""..."")
+  dispatch_on <- setdiff(generic@dispatch_args, ""..."")
   vals <- mget(dispatch_on, envir = parent.frame())
   signature <- lapply(vals, object_class)
 

---FILE: R/zzz.R---
@@ -24,10 +24,21 @@ base_constructors <- lapply(base_types, get)
 
 R7_generic <- new_class(
   name = ""R7_generic"",
-  properties = list(name = ""character"", methods = ""environment"", signature = new_property(name = ""signature"", getter = function(x) formals(r7_data(x)))),
+  properties = list(
+    name = ""character"",
+    methods = ""environment"",
+    dispatch_args = new_property(
+      name = ""dispatch_args"",
+      getter = function(x) formals(r7_data(x))
+  )),
   parent = ""function"",
-  constructor = function(name, signature, fun) {
-    new_object(name = name, signature = signature, methods = new.env(parent = emptyenv(), hash = TRUE), .data = fun)
+  constructor = function(name, dispatch_args, fun) {
+    new_object(
+      name = name,
+      dispatch_args = dispatch_args,
+      methods = new.env(parent = emptyenv(), hash = TRUE),
+      .data = fun
+    )
   }
 )
 

---FILE: README.Rmd---
@@ -90,7 +90,7 @@ x
 ```{r}
 text <- new_class(""text"", parent = ""character"", constructor = function(text) new_object(.data = text))
 
-foo <- new_generic(""foo"", signature = ""x"")
+foo <- new_generic(""foo"", dispatch_args = ""x"")
 
 method(foo, ""text"") <- function(x, ...) paste0(""foo-"", x)
 
@@ -109,7 +109,7 @@ At each level the search iteratively searches along objects class vector.
 ```{r}
 number <- new_class(""number"", parent = ""numeric"", constructor = function(x) new_object(.data = x))
 
-bar <- new_generic(""bar"", signature = c(""x"", ""y""))
+bar <- new_generic(""bar"", dispatch_args = c(""x"", ""y""))
 
 method(bar, list(""character"", ""numeric"")) <- function(x, y, ...) paste0(""foo-"", x, "":"", y)
 
@@ -136,7 +136,7 @@ bar(text(""hi""), number(42))
 `method_call()` retains promises for dispatch arguments in basically the same way as `UseMethod()`, so non-standard evaluation works basically the same as S3.
 
 ```{r}
-subset2 <- new_generic(""subset2"", signature = ""x"")
+subset2 <- new_generic(""subset2"", dispatch_args = ""x"")
 
 method(subset2, ""data.frame"") <- function(x, subset = NULL, select = NULL, drop = FALSE, ...) {
   e <- substitute(subset)

---FILE: README.md---
@@ -100,7 +100,7 @@ x
 ``` r
 text <- new_class(""text"", parent = ""character"", constructor = function(text) new_object(.data = text))
 
-foo <- new_generic(""foo"", signature = ""x"")
+foo <- new_generic(""foo"", dispatch_args = ""x"")
 
 method(foo, ""text"") <- function(x, ...) paste0(""foo-"", x)
 
@@ -123,7 +123,7 @@ vector.
 ``` r
 number <- new_class(""number"", parent = ""numeric"", constructor = function(x) new_object(.data = x))
 
-bar <- new_generic(""bar"", signature = c(""x"", ""y""))
+bar <- new_generic(""bar"", dispatch_args = c(""x"", ""y""))
 
 method(bar, list(""character"", ""numeric"")) <- function(x, y, ...) paste0(""foo-"", x, "":"", y)
 
@@ -155,7 +155,7 @@ same way as `UseMethod()`, so non-standard evaluation works basically
 the same as S3.
 
 ``` r
-subset2 <- new_generic(""subset2"", signature = ""x"")
+subset2 <- new_generic(""subset2"", dispatch_args = ""x"")
 
 method(subset2, ""data.frame"") <- function(x, subset = NULL, select = NULL, drop = FALSE, ...) {
   e <- substitute(subset)

---FILE: man/method.Rd---
@@ -30,7 +30,7 @@ interactively in order to see the implementation of a specific method.
 }
 \examples{
 # Create a generic
-bizarro <- new_generic(""bizarro"", signature = ""x"")
+bizarro <- new_generic(""bizarro"", dispatch_args = ""x"")
 # Register some methods
 method(bizarro, ""numeric"") <- function(x, ...) rev(x)
 method(bizarro, ""factor"") <- function(x, ...) {

---FILE: man/new_generic.Rd---
@@ -4,7 +4,7 @@
 \alias{new_generic}
 \title{Define a new generic}
 \usage{
-new_generic(name, fun = NULL, signature = NULL)
+new_generic(name, fun = NULL, dispatch_args = NULL)
 }
 \arguments{
 \item{name}{The name of the generic. This should be the same as the object
@@ -16,7 +16,7 @@ automatically from the \code{signature}, but you may want to supply it if
 you want to add additional required arguments, or perform some standardised
 computation in the generic.}
 
-\item{signature}{A character vector providing the names of arguments to
+\item{dispatch_args}{A character vector providing the names of arguments to
 dispatch on. If omitted, defaults to the required arguments of \code{fun}.}
 }
 \description{
@@ -26,7 +26,7 @@ of one or more arguments (the \code{signature}). Create a new generic with
 }
 \examples{
 # A simple generic with methods for some base types and S3 classes
-type_of <- new_generic(""type_of"", signature = ""x"")
+type_of <- new_generic(""type_of"", dispatch_args = ""x"")
 method(type_of, ""character"") <- function(x, ...) ""A character vector""
 method(type_of, ""data.frame"") <- function(x, ...) ""A data frame""
 method(type_of, ""function"") <- function(x, ...) ""A function""

---FILE: src/code.c---
@@ -108,7 +108,7 @@ void R7_method_lookup_error(SEXP generic, SEXP signature, SEXP envir) {
     R7_method_lookup_error_fun = Rf_findVarInFrame(ns, Rf_install(""method_lookup_error""));
   }
   SEXP name = Rf_getAttrib(generic, Rf_install(""name""));
-  SEXP args = Rf_getAttrib(generic, Rf_install(""signature""));
+  SEXP args = Rf_getAttrib(generic, Rf_install(""dispatch_args""));
   SEXP R7_method_lookup_error_call = PROTECT(Rf_lang4(R7_method_lookup_error_fun, name, args, signature));
   Rf_eval(R7_method_lookup_error_call, envir);
 }
@@ -117,7 +117,7 @@ SEXP method_call_(SEXP call, SEXP generic, SEXP envir) {
   int n_protect = 0;
 
   // Get the signature, the names of arguments to use for dispatch
-  SEXP gen_signature_args = Rf_getAttrib(generic, Rf_install(""signature""));
+  SEXP gen_signature_args = Rf_getAttrib(generic, Rf_install(""dispatch_args""));
 
   // Every generic signature has `...` as the last arg, which we want to ignore.
   R_xlen_t gen_signature_len = Rf_xlength(gen_signature_args);

---FILE: tests/testthat/_snaps/generic.md---
@@ -1,17 +1,17 @@
-# new_generic needs fun or signature
+# new_generic needs fun or dispatch_args
 
-    Must call `new_generic()` with at least one of `signature` or `fun`
+    Must call `new_generic()` with at least one of `dispatch_args` or `fun`
 
-# check_signature produces informative errors
+# check_dispatch_args() produces informative errors
 
     Code
-      check_signature(1)
+      check_dispatch_args(1)
     Error <simpleError>
-      `signature` must be a character vector
+      `dispatch_args` must be a character vector
     Code
-      check_signature(character())
+      check_dispatch_args(character())
     Error <simpleError>
-      `signature` must have at least one component
+      `dispatch_args` must have at least one component
 
 # R7_generic printing
 

---FILE: tests/testthat/t0/R/pkg.R---
@@ -1,3 +1,3 @@
 #' @importFrom R7 method object_class
 #' @export
-bar <- R7::new_generic(""bar"", signature = c(""x"", ""y""))
+bar <- R7::new_generic(""bar"", dispatch_args = c(""x"", ""y""))

---FILE: tests/testthat/t1/R/foo.R---
@@ -1,3 +1,3 @@
 #' @importFrom R7 method object_class
 #' @export
-foo <- R7::new_generic(""foo"", signature = c(""x"", ""y""))
+foo <- R7::new_generic(""foo"", dispatch_args = c(""x"", ""y""))

---FILE: tests/testthat/test-generic.R---
@@ -1,48 +1,48 @@
-test_that(""new_generic needs fun or signature"", {
+test_that(""new_generic needs fun or dispatch_args"", {
   expect_snapshot_error(new_generic())
 })
 
-test_that(""signature overrules derived signature"", {
+test_that(""dispatch_args overrules derived"", {
   g <- new_generic(""g"", function(x, y, ...) method_call())
-  expect_equal(g@signature, c(""x"", ""y"", ""...""))
+  expect_equal(g@dispatch_args, c(""x"", ""y"", ""...""))
 
-  g <- new_generic(""g"", function(x, y, ...) method_call(), signature = ""x"")
-  expect_equal(g@signature, c(""x"", ""...""))
+  g <- new_generic(""g"", function(x, y, ...) method_call(), dispatch_args = ""x"")
+  expect_equal(g@dispatch_args, c(""x"", ""...""))
 })
 
 test_that(""generics pass ... to methods, and methods can define additional arguments on basic types"", {
-  foo <- new_generic(""foo"", signature = ""x"")
+  foo <- new_generic(""foo"", dispatch_args = ""x"")
   new_method(foo, ""character"", function(x, sep = ""-"", ...) paste0(""foo"", sep, x))
 
   expect_equal(foo(""bar""), ""foo-bar"")
   expect_equal(foo(""bar"", sep = ""/""), ""foo/bar"")
 })
 
 test_that(""generics pass ... to methods, and methods can define additional arguments on R7 objects"", {
-  foo <- new_generic(""foo"", signature = ""x"")
+  foo <- new_generic(""foo"", dispatch_args = ""x"")
   new_method(foo, ""text"", function(x, sep = ""-"", ...) paste0(""foo"", sep, x))
 
   expect_equal(foo(text(""bar"")), ""foo-bar"")
   expect_equal(foo(text(""bar""), sep = ""/""), ""foo/bar"")
 })
 
-test_that(""guesses signature from required arguments"", {
-  expect_equal(guess_signature(function() {}), NULL)
-  expect_equal(guess_signature(function(x) {}), ""x"")
-  expect_equal(guess_signature(function(x, y) {}), c(""x"", ""y""))
-  expect_equal(guess_signature(function(x, y, ...) {}), c(""x"", ""y"", ""...""))
-  expect_equal(guess_signature(function(x, ..., y = 1) {}), c(""x"", ""...""))
+test_that(""guesses dispatch_args from required arguments"", {
+  expect_equal(guess_dispatch_args(function() {}), NULL)
+  expect_equal(guess_dispatch_args(function(x) {}), ""x"")
+  expect_equal(guess_dispatch_args(function(x, y) {}), c(""x"", ""y""))
+  expect_equal(guess_dispatch_args(function(x, y, ...) {}), c(""x"", ""y"", ""...""))
+  expect_equal(guess_dispatch_args(function(x, ..., y = 1) {}), c(""x"", ""...""))
 })
 
-test_that(""check_signature produces informative errors"", {
+test_that(""check_dispatch_args() produces informative errors"", {
   expect_snapshot(error = TRUE, {
-    check_signature(1)
-    check_signature(character())
+    check_dispatch_args(1)
+    check_dispatch_args(character())
   })
 })
 
 test_that(""R7_generic printing"", {
-  foo <- new_generic(name = ""foo"", signature = c(""x"", ""y"", ""z""))
+  foo <- new_generic(name = ""foo"", dispatch_args = c(""x"", ""y"", ""z""))
   method(foo, list(""character"", text, ""character"")) <- function(x, y, z, ...) 1
   method(foo, list(""character"", ""integer"", ""character"")) <- function(x, y, z, ...) 2
   method(foo, list(""character"", ""integer"", ""logical"")) <- function(x, y, z, ...) 3
@@ -53,7 +53,7 @@ test_that(""R7_generic printing"", {
 })
 
 test_that(""R7_generic printing with long / many arguments"", {
-  foo <- new_generic(name = ""foo"", signature = letters)
+  foo <- new_generic(name = ""foo"", dispatch_args = letters)
   expect_snapshot(
     foo
   )

---FILE: tests/testthat/test-method.R---
@@ -26,43 +26,43 @@ test_that(""method errors on invalid inputs"", {
 })
 
 test_that(""method errors if no method is defined for that class"", {
-  foo <- new_generic(""foo"", signature = ""x"")
+  foo <- new_generic(""foo"", dispatch_args = ""x"")
 
   expect_snapshot_error(
     method(foo, list(""blah""))
   )
 })
 
 test_that(""methods can be registered for a generic and then called"", {
-  foo <- new_generic(""foo"", signature = ""x"")
+  foo <- new_generic(""foo"", dispatch_args = ""x"")
   new_method(foo, ""text"", function(x, ...) paste0(""foo-"", r7_data(x)))
 
   expect_equal(foo(text(""bar"")), ""foo-bar"")
 })
 
 test_that(""single inheritance works when searching for methods"", {
-  foo2 <- new_generic(""foo2"", signature = ""x"")
+  foo2 <- new_generic(""foo2"", dispatch_args = ""x"")
 
   new_method(foo2, ""character"", function(x, ...) paste0(""foo2-"", x))
 
   expect_equal(foo2(text(""bar"")), ""foo2-bar"")
 })
 
 test_that(""direct multiple dispatch works"", {
-  foo3 <- new_generic(""foo3"", signature = c(""x"", ""y""))
+  foo3 <- new_generic(""foo3"", dispatch_args = c(""x"", ""y""))
   new_method(foo3, list(""text"", ""number""), function(x, y, ...) paste0(x, y))
   expect_equal(foo3(text(""bar""), number(1)), ""bar1"")
 })
 
 test_that(""inherited multiple dispatch works"", {
-  foo4 <- new_generic(""foo4"", signature = c(""x"", ""y""))
+  foo4 <- new_generic(""foo4"", dispatch_args = c(""x"", ""y""))
   new_method(foo4, list(""character"", ""numeric""), function(x, y, ...) paste0(x, "":"", y))
 
   expect_equal(foo4(text(""bar""), number(1)), ""bar:1"")
 })
 
 test_that(""method dispatch works for S3 objects"", {
-  foo <- new_generic(""foo"", signature = ""x"")
+  foo <- new_generic(""foo"", dispatch_args = ""x"")
 
   obj <- structure(""hi"", class = ""my_s3"")
 
@@ -77,37 +77,37 @@ test_that(""method dispatch works for S3 objects"", {
   Range <- setClass(""Range"", slots = c(start = ""numeric"", end = ""numeric""))
   obj <- Range(start = 1, end = 10)
 
-  foo <- new_generic(""foo"", signature = ""x"")
+  foo <- new_generic(""foo"", dispatch_args = ""x"")
 
   new_method(foo, ""Range"", function(x, ...) paste0(""foo-"", x@start, ""-"", x@end))
 
   expect_equal(foo(obj), ""foo-1-10"")
 })
 
 test_that(""new_method works if you use R7 class objects"", {
-  foo5 <- new_generic(""foo5"", signature = c(""x"", ""y""))
+  foo5 <- new_generic(""foo5"", dispatch_args = c(""x"", ""y""))
   new_method(foo5, list(text, number), function(x, y, ...) paste0(x, "":"", y))
 
   expect_equal(foo5(text(""bar""), number(1)), ""bar:1"")
 })
 
 test_that(""new_method works if you pass a bare class"", {
-  foo6 <- new_generic(""foo6"", signature = ""x"")
+  foo6 <- new_generic(""foo6"", dispatch_args = ""x"")
   new_method(foo6, text, function(x, ...) paste0(""foo-"", x))
 
   expect_equal(foo6(text(""bar"")), ""foo-bar"")
 })
 
 test_that(""new_method works if you pass a bare class union"", {
-  foo7 <- new_generic(""foo7"", signature = ""x"")
+  foo7 <- new_generic(""foo7"", dispatch_args = ""x"")
   new_method(foo7, new_union(text, number), function(x, ...) paste0(""foo-"", x))
 
   expect_equal(foo7(text(""bar"")), ""foo-bar"")
   expect_equal(foo7(number(1)), ""foo-1"")
 })
 
 test_that(""next_method works for single dispatch"", {
-  foo <- new_generic(""foo"", signature = ""x"")
+  foo <- new_generic(""foo"", dispatch_args = ""x"")
 
   new_method(foo, ""text"", function(x, ...) {
     r7_data(x) <- paste0(""foo-"", r7_data(x))
@@ -122,7 +122,7 @@ test_that(""next_method works for single dispatch"", {
 })
 
 test_that(""next_method works for double dispatch"", {
-  foo <- new_generic(""foo"", signature = c(""x"", ""y""))
+  foo <- new_generic(""foo"", dispatch_args = c(""x"", ""y""))
 
   new_method(foo, list(""text"", ""number""), function(x, y, ...) {
     r7_data(x) <- paste0(""foo-"", r7_data(x), ""-"", r7_data(y))
@@ -144,7 +144,7 @@ test_that(""next_method works for double dispatch"", {
 })
 
 test_that(""substitute() works for single dispatch method calls like S3"", {
-  foo <- new_generic(""foo"", signature = ""x"")
+  foo <- new_generic(""foo"", dispatch_args = ""x"")
 
   new_method(foo, ""character"", function(x, ...) substitute(x))
 
@@ -153,7 +153,7 @@ test_that(""substitute() works for single dispatch method calls like S3"", {
 })
 
 test_that(""substitute() works for multiple dispatch method calls like S3"", {
-  foo <- new_generic(""foo"", signature = c(""x"", ""y""))
+  foo <- new_generic(""foo"", dispatch_args = c(""x"", ""y""))
 
   new_method(foo, ""character"", function(x, y, ...) c(substitute(x), substitute(y)))
 
@@ -163,7 +163,7 @@ test_that(""substitute() works for multiple dispatch method calls like S3"", {
 })
 
 test_that(""method_compatible returns TRUE if the functions are compatible"", {
-  foo <- new_generic(""foo"", signature = ""x"")
+  foo <- new_generic(""foo"", dispatch_args = ""x"")
 
   expect_true(
     method_compatible(
@@ -188,7 +188,7 @@ test_that(""method_compatible returns TRUE if the functions are compatible"", {
     )
   )
 
-  bar <- new_generic(""bar"", signature = c(""x"", ""y""))
+  bar <- new_generic(""bar"", dispatch_args = c(""x"", ""y""))
   expect_true(
     method_compatible(
       function(x, y, ...) x,
@@ -206,7 +206,7 @@ test_that(""method_compatible returns TRUE if the functions are compatible"", {
 })
 
 test_that(""method_compatible throws errors if the functions are not compatible"", {
-  foo <- new_generic(""foo"", signature = ""x"")
+  foo <- new_generic(""foo"", dispatch_args = ""x"")
 
   # Different argument names
   expect_snapshot_error(
@@ -232,7 +232,7 @@ test_that(""method_compatible throws errors if the functions are not compatible"",
     )
   )
 
-  bar <- new_generic(""bar"", signature = c(""x"", ""y""))
+  bar <- new_generic(""bar"", dispatch_args = c(""x"", ""y""))
 
   # Arguments in wrong order
   expect_snapshot_error(
@@ -277,7 +277,7 @@ test_that(""method compatible verifies that if a generic does not have dots the m
 })
 
 test_that(""method lookup fails with an informative message for single classes"", {
-  foo <- new_generic(name=""foo"", signature = c(""x"", ""y""))
+  foo <- new_generic(name=""foo"", dispatch_args = c(""x"", ""y""))
   method(foo, c(""character"", ""integer"")) <- function(x, y, ...) paste0(""bar:"", x, y)
   expect_snapshot_error(
     foo(TRUE, list())
@@ -289,15 +289,15 @@ test_that(""method lookup fails with an informative message for single classes"",
 })
 
 test_that(""method lookup fails with an informative message for multiple classes"", {
-  foo <- new_generic(name=""foo"", signature = c(""x"", ""y""))
+  foo <- new_generic(name=""foo"", dispatch_args = c(""x"", ""y""))
   method(foo, c(""character"", ""integer"")) <- function(x, y, ...) paste0(""bar:"", x, y)
   expect_snapshot_error(
     foo(tibble::tibble(), .POSIXct(double()))
   )
 })
 
 test_that(""R7_method printing"", {
-  foo <- new_generic(name=""foo"", signature = c(""x"", ""y""))
+  foo <- new_generic(name=""foo"", dispatch_args = c(""x"", ""y""))
   method(foo, list(text, ""integer"")) <- function(x, y, ...) paste0(""bar:"", x, y)
   expect_snapshot(
     method(foo, list(text, ""integer"")),

---FILE: vignettes/case_studies.Rmd---
@@ -177,7 +177,7 @@ We next define a `R7_subset` generic function, and then a R7 method for that fun
 The subsets the individual components appropriately and then returns a new `annotated_df` object with them.
 
 ```{r}
-subset_R7 <- new_generic(""R7_subset"", signature = c(""object"", ""row"", ""column""))
+subset_R7 <- new_generic(""R7_subset"", dispatch_args = c(""object"", ""row"", ""column""))
 
 method(subset_R7, list(annotated_df, ""integer"", ""integer"")) <- function(object, row, column, ...) {
   data <- r7_data(object)[row, column]

---FILE: vignettes/performance.Rmd---
@@ -27,7 +27,7 @@ number <- new_class(""number"", parent = ""numeric"", constructor = function(x) new_
 x <- text(""hi"")
 y <- number(1)
 
-foo_R7 <- new_generic(""foo_R7"", signature = ""x"")
+foo_R7 <- new_generic(""foo_R7"", dispatch_args = ""x"")
 method(foo_R7, ""text"") <- function(x, ...) paste0(x, ""-foo"")
 
 foo_s3 <- function(x, ...) {
@@ -48,7 +48,7 @@ setMethod(""foo_s4"", c(""text""), function(x, ...) paste0(x, ""-foo""))
 # Measure performance of single dispatch
 bench::mark(foo_R7(x), foo_s3(x), foo_s4(x))
 
-bar_R7 <- new_generic(""bar_R7"", signature = c(""x"", ""y""))
+bar_R7 <- new_generic(""bar_R7"", dispatch_args = c(""x"", ""y""))
 method(bar_R7, list(""text"", ""number"")) <- function(x, y, ...) paste0(x, ""-"", y, ""-bar"")
 
 setGeneric(""bar_s4"", function(x, y, ...) standardGeneric(""bar_s4""))
@@ -96,11 +96,11 @@ bench::press(
     x <- do.call(cls, list(""hi""))
 
     # Define a generic and a method for the last class (best case scenario)
-    foo_R7 <- new_generic(""foo_R7"", signature = ""x"")
+    foo_R7 <- new_generic(""foo_R7"", dispatch_args = ""x"")
     method(foo_R7, cls) <- function(x, ...) paste0(x, ""-foo"")
 
     # Define a generic and a method for the first class (worst case scenario)
-    foo2_R7 <- new_generic(""foo2_R7"", signature = ""x"")
+    foo2_R7 <- new_generic(""foo2_R7"", dispatch_args = ""x"")
     method(foo2_R7, R7_object) <- function(x, ...) paste0(x, ""-foo"")
 
     bench::mark(
@@ -136,11 +136,11 @@ bench::press(
     y <- do.call(cls, list(""ho""))
 
     # Define a generic and a method for the last class (best case scenario)
-    foo_R7 <- new_generic(""foo_R7"", signature = c(""x"", ""y""))
+    foo_R7 <- new_generic(""foo_R7"", dispatch_args = c(""x"", ""y""))
     method(foo_R7, list(cls, cls)) <- function(x, y, ...) paste0(x, y, ""-foo"")
 
     # Define a generic and a method for the first class (worst case scenario)
-    foo2_R7 <- new_generic(""foo2_R7"", signature = c(""x"", ""y""))
+    foo2_R7 <- new_generic(""foo2_R7"", dispatch_args = c(""x"", ""y""))
     method(foo2_R7, list(R7_object, R7_object)) <- function(x, y, ...) paste0(x, y, ""-foo"")
 
     bench::mark("
RConsortium,S7,8fdfb5f13a472b47a2b2aaa50e161bdddf6cd5c2,Hadley Wickham,h.wickham@gmail.com,2022-01-20T18:28:23Z,GitHub,noreply@github.com,2022-01-20T18:28:23Z,"Replace x@.data with r7_data(x) (#130)

Fixes #114",NAMESPACE;R/data.R;R/property.R;R/zzz.R;README.Rmd;README.md;man/r7_data.Rd;tests/testthat/test-class.R;tests/testthat/test-data.R;tests/testthat/test-method.R;tests/testthat/test-object.R;tests/testthat/test-property.R;vignettes/case_studies.Rmd,True,True,True,False,107,77,184,"---FILE: NAMESPACE---
@@ -10,6 +10,7 @@ S3method(str,R7_object)
 export(""@"")
 export(""method<-"")
 export(""prop<-"")
+export(""r7_data<-"")
 export(R7_object)
 export(class_get)
 export(class_names)
@@ -29,6 +30,7 @@ export(prop_exists)
 export(prop_names)
 export(prop_safely)
 export(props)
+export(r7_data)
 export(valid_eventually)
 export(valid_implicitly)
 importFrom(stats,setNames)

---FILE: R/data.R---
@@ -0,0 +1,36 @@
+#' Get/set underlying ""base"" data
+#'
+#' When an R7 class inherits from an existing base type, it can be useful
+#' to work with the underlying object, i.e. the R7 object stripped of class
+#' and all properties.
+#'
+#' @inheritParams prop
+#' @export
+#' @examples
+#' text <- new_class(""text"", parent = ""character"")
+#' y <- text(c(foo = ""bar""))
+#' str(r7_data(y))
+r7_data <- function(object) {
+  # Remove properties, return the rest
+  for (name in prop_names(object)) {
+    attr(object, name) <- NULL
+  }
+
+  obj_cls <- object_class(object)
+  class(object) <- setdiff(class_names(obj_cls@parent), obj_cls@name)
+  object_class(object) <- object_class(obj_cls@parent)
+
+  object
+}
+
+#' @export
+#' @rdname r7_data
+`r7_data<-` <- function(object, check = TRUE, value) {
+  attrs <- attributes(object)
+  object <- value
+  attributes(object) <- attrs
+  if (isTRUE(check)) {
+    validate(object)
+  }
+  return(invisible(object))
+}

---FILE: R/property.R---
@@ -119,19 +119,6 @@ prop_safely <- function(object, name) {
 
 # Internal helper that assumes the property exists
 prop_val <- function(object, name) {
-  if (identical(name, "".data"")) {
-    # Remove properties, return the rest
-    for (name in prop_names(object)) {
-      attr(object, name) <- NULL
-    }
-
-    obj_cls <- object_class(object)
-    class(object) <- setdiff(class_names(obj_cls@parent), obj_cls@name)
-    object_class(object) <- object_class(obj_cls@parent)
-
-    return(object)
-  }
-
   val <- attr(object, name, exact = TRUE)
   if (is.null(val)) {
     prop <- prop_obj(object, name)
@@ -179,11 +166,7 @@ props <- function(object) {
 #' @rdname prop
 #' @export
 prop_exists <- function(object, name) {
-  if (identical(name, "".data"")) {
-    !identical(object, R7_object)
-  } else {
-    name %in% prop_names(object)
-  }
+  name %in% prop_names(object)
 }
 
 #' @rdname prop
@@ -195,16 +178,6 @@ prop_exists <- function(object, name) {
   setter_property <- NULL
 
   function(object, name, check = TRUE, value) {
-    if (name == "".data"") {
-      attrs <- attributes(object)
-      object <- value
-      attributes(object) <- attrs
-      if (isTRUE(check)) {
-        validate(object)
-      }
-      return(invisible(object))
-    }
-
     prop <- prop_obj(object, name)
     if (!is.null(prop$setter) && !identical(setter_property, name)) {
       setter_property <<- name

---FILE: R/zzz.R---
@@ -24,7 +24,7 @@ base_constructors <- lapply(base_types, get)
 
 R7_generic <- new_class(
   name = ""R7_generic"",
-  properties = list(name = ""character"", methods = ""environment"", signature = new_property(name = ""signature"", getter = function(x) formals(x@.data))),
+  properties = list(name = ""character"", methods = ""environment"", signature = new_property(name = ""signature"", getter = function(x) formals(r7_data(x)))),
   parent = ""function"",
   constructor = function(name, signature, fun) {
     new_object(name = name, signature = signature, methods = new.env(parent = emptyenv(), hash = TRUE), .data = fun)

---FILE: README.Rmd---
@@ -83,15 +83,6 @@ object_class(x)
 
 # As well as normal R7_objects
 x
-
-# Use `.data` to refer to and retrieve the base data type, properties are
-# automatically removed, but non-property attributes (such as names) are retained.
-
-text <- new_class(""text"", parent = ""character"", constructor = function(text) new_object(.data = text))
-
-y <- text(c(foo = ""bar""))
-
-names(y@.data)
 ```
 
 ## Generics and methods

---FILE: README.md---
@@ -65,7 +65,7 @@ x@length
 
 # incorrect properties throws an error
 x@middle
-#> Error: Can't find property <range>@middle
+#> Error in prop(object, name): Can't find property <range>@middle
 
 # assigning properties verifies the class matches the class of the value
 x@end <- ""foo""
@@ -93,16 +93,6 @@ x
 #> @start  1
 #> @end    6
 #> @length 5
-
-# Use `.data` to refer to and retrieve the base data type, properties are
-# automatically removed, but non-property attributes (such as names) are retained.
-
-text <- new_class(""text"", parent = ""character"", constructor = function(text) new_object(.data = text))
-
-y <- text(c(foo = ""bar""))
-
-names(y@.data)
-#> [1] ""foo""
 ```
 
 ## Generics and methods

---FILE: man/r7_data.Rd---
@@ -0,0 +1,30 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/data.R
+\name{r7_data}
+\alias{r7_data}
+\alias{r7_data<-}
+\title{Get/set underlying ""base"" data}
+\usage{
+r7_data(object)
+
+r7_data(object, check = TRUE) <- value
+}
+\arguments{
+\item{object}{An object from a R7 class}
+
+\item{check}{If \code{TRUE}, check that \code{value} is of the correct type and run
+\code{\link[=validate]{validate()}} on the object before returning.}
+
+\item{value}{A replacement value for the parameter. The object is
+automatically checked for validity after the replacement is done.}
+}
+\description{
+When an R7 class inherits from an existing base type, it can be useful
+to work with the underlying object, i.e. the R7 object stripped of class
+and all properties.
+}
+\examples{
+text <- new_class(""text"", parent = ""character"")
+y <- text(c(foo = ""bar""))
+str(r7_data(y))
+}

---FILE: tests/testthat/test-class.R---
@@ -32,23 +32,23 @@ test_that(""classes can inherit from base types"", {
     f <- match.fun(type)
     foo <- new_class(""foo"", parent = type, constructor = function(x = f()) new_object(x))
     obj <- foo()
-    expect_equal(typeof(obj@.data), type)
+    expect_equal(typeof(r7_data(obj)), type)
   }
 
   foo <- new_class(""foo"", parent = ""numeric"", constructor = function(x = numeric()) new_object(x))
   obj <- foo()
-  expect_equal(typeof(obj@.data), ""double"")
+  expect_equal(typeof(r7_data(obj)), ""double"")
 
   foo <- new_class(""foo"", parent = ""function"", constructor = function(x = function() NULL, ...) new_object(x))
   obj <- foo()
-  expect_equal(typeof(obj@.data), ""closure"")
+  expect_equal(typeof(r7_data(obj)), ""closure"")
 })
 
 test_that(""can supply literal examples of base types"", {
   foo <- new_class(""foo"", parent = integer)
   obj <- foo(1L)
   expect_s3_class(obj, ""integer"")
-  expect_type(obj@.data, ""integer"")
+  expect_type(r7_data(obj), ""integer"")
 })
 
 test_that(""classes can use unions in properties"", {

---FILE: tests/testthat/test-data.R---
@@ -0,0 +1,22 @@
+describe(""r7_data"", {
+  it(""retrieves .data"", {
+    x <- text(""hi"")
+    expect_equal(r7_data(x), class_get(""character"")(""hi""))
+  })
+  it(""strips properties"", {
+    text <- new_class(""text"", parent = ""character"", properties = list(x = ""integer""))
+    x <- text(""hi"", x = 10L)
+    expect_equal(prop_names(r7_data(x)), character())
+  })
+  it(""preserves non-property attributes when retrieving .data"", {
+    val <- c(foo = ""hi"", bar = ""ho"")
+    x <- text(val)
+    expect_equal(r7_data(x), class_get(""character"")(val))
+  })
+  it(""lets you set data"", {
+    val <- c(foo = ""hi"", bar = ""ho"")
+    x <- text(""foo"")
+    r7_data(x) <- ""bar""
+    expect_equal(r7_data(x), class_get(""character"")(""bar""))
+  })
+})

---FILE: tests/testthat/test-method.R---
@@ -35,7 +35,7 @@ test_that(""method errors if no method is defined for that class"", {
 
 test_that(""methods can be registered for a generic and then called"", {
   foo <- new_generic(""foo"", signature = ""x"")
-  new_method(foo, ""text"", function(x, ...) paste0(""foo-"", x@.data))
+  new_method(foo, ""text"", function(x, ...) paste0(""foo-"", r7_data(x)))
 
   expect_equal(foo(text(""bar"")), ""foo-bar"")
 })
@@ -110,7 +110,7 @@ test_that(""next_method works for single dispatch"", {
   foo <- new_generic(""foo"", signature = ""x"")
 
   new_method(foo, ""text"", function(x, ...) {
-    x@.data <- paste0(""foo-"", x@.data)
+    r7_data(x) <- paste0(""foo-"", r7_data(x))
     next_method()(x)
   })
 
@@ -125,21 +125,22 @@ test_that(""next_method works for double dispatch"", {
   foo <- new_generic(""foo"", signature = c(""x"", ""y""))
 
   new_method(foo, list(""text"", ""number""), function(x, y, ...) {
-    x@.data <- paste0(""foo-"", x@.data, ""-"", y@.data)
+    r7_data(x) <- paste0(""foo-"", r7_data(x), ""-"", r7_data(y))
     next_method()(x, y)
   })
 
   new_method(foo, list(""character"", ""number""), function(x, y, ...) {
-    y@.data <- y + 1
-    x@.data <- paste0(x@.data, ""-"", y@.data)
+    r7_data(y) <- y + 1
+    r7_data(x) <- paste0(r7_data(x), ""-"", r7_data(y))
     next_method()(x, y)
   })
 
   new_method(foo, list(""character"", ""numeric""), function(x, y, ...) {
-    as.character(x@.data)
+    as.character(r7_data(x))
   })
 
   expect_equal(foo(text(""hi""), number(1)), ""foo-hi-1-2"")
+
 })
 
 test_that(""substitute() works for single dispatch method calls like S3"", {

---FILE: tests/testthat/test-object.R---
@@ -24,7 +24,7 @@ describe(""new_object"", {
 
   it(""can instantiate a new object that inherits from a basic type"", {
     y <- text(""foo"")
-    expect_equal(y@.data, class_get(""character"")(""foo""))
+    expect_equal(r7_data(y), class_get(""character"")(""foo""))
   })
 
   it(""errors if given an invalid property"", {
@@ -64,7 +64,7 @@ describe(""new_object"", {
       constructor = function(x, name) new_object(text2(x), name = name)
     )
     obj <- my_class(""foo"", ""bar"")
-    expect_equal(obj@.data, text2(""foo""))
+    expect_equal(r7_data(obj), text2(""foo""))
   })
 })
 

---FILE: tests/testthat/test-property.R---
@@ -12,21 +12,6 @@ describe(""prop"", {
     x <- range(1, 10)
     expect_snapshot_error(prop(x, ""st""))
   })
-  it(""retrieves .data"", {
-    x <- text(""hi"")
-    expect_equal(x@.data, class_get(""character"")(""hi""))
-  })
-  it(""preserves non-property attributes when retrieving .data"", {
-    val <- c(foo = ""hi"", bar = ""ho"")
-    x <- text(val)
-    expect_equal(x@.data, class_get(""character"")(val))
-  })
-  it(""lets you set .data"", {
-    val <- c(foo = ""hi"", bar = ""ho"")
-    x <- text(""foo"")
-    x@.data <- ""bar""
-    expect_equal(x@.data, class_get(""character"")(""bar""))
-  })
 })
 
 describe(""prop<-"", {

---FILE: vignettes/case_studies.Rmd---
@@ -180,7 +180,7 @@ The subsets the individual components appropriately and then returns a new `anno
 subset_R7 <- new_generic(""R7_subset"", signature = c(""object"", ""row"", ""column""))
 
 method(subset_R7, list(annotated_df, ""integer"", ""integer"")) <- function(object, row, column, ...) {
-  data <- object@.data[row, column]
+  data <- r7_data(object)[row, column]
   rows <- object@rows[row, ]
   columns <-  object@columns[column, ]
   annotated_df(data, rows, columns)"
RConsortium,S7,b0f4e016749e40431d7b8bd3d965b9e02d5e4a4a,Hadley Wickham,h.wickham@gmail.com,2022-01-18T17:42:00Z,GitHub,noreply@github.com,2022-01-18T17:42:00Z,"Make properties 3rd argument of new_class() (#138)

Fixes #97",R/class.R;man/new_class.Rd,False,True,True,False,21,9,30,"---FILE: R/class.R---
@@ -90,8 +90,20 @@ R7_class <- function(name, parent = R7_object, constructor = NULL, validator = f
 #' try(range(start = 20, end = 10))
 #' # Type validation is performed automatically in R7
 #' try(range(start = ""hello"", end = 20))
-new_class <- function(name, parent = R7_object, constructor = NULL, validator = function(x) NULL, properties = list()) {
-  R7_class(name = name, parent = parent, constructor = constructor, validator = validator, properties = properties)
+new_class <- function(
+    name,
+    parent = R7_object,
+    properties = list(),
+    constructor = NULL,
+    validator = function(x) NULL) {
+
+  R7_class(
+    name = name,
+    parent = parent,
+    constructor = constructor,
+    validator = validator,
+    properties = properties
+  )
 }
 
 #' Retrieve all of the class names for a class

---FILE: man/new_class.Rd---
@@ -7,9 +7,9 @@
 new_class(
   name,
   parent = R7_object,
+  properties = list(),
   constructor = NULL,
-  validator = function(x) NULL,
-  properties = list()
+  validator = function(x) NULL
 )
 }
 \arguments{
@@ -22,18 +22,18 @@ new_class(
 to construct the object, e.g. \code{character}, \code{integer}.
 }}
 
+\item{properties}{A list specifying the properties (data) that
+every object of the class will possess. Each property can either be
+a named string (specifying the class), or a call to \code{\link[=new_property]{new_property()}},
+allowing greater flexibility.}
+
 \item{constructor}{The constructor function. This is optional, unless
 you want to control which properties can be set on constructor.}
 
 \item{validator}{A function used to determine whether or not an object
 is valid. This is called automatically after construction, and
 whenever any property is set. It should return \code{NULL} if the object is
 valid, and otherwise return a character vector of problems.}
-
-\item{properties}{A list specifying the properties (data) that
-every object of the class will possess. Each property can either be
-a named string (specifying the class), or a call to \code{\link[=new_property]{new_property()}},
-allowing greater flexibility.}
 }
 \value{
 A object constructor, a function that can be used to create objects"
RConsortium,S7,873e31fbf66b17907ef2ed62cbc239b5839cd326,Hadley Wickham,h.wickham@gmail.com,2021-11-16T04:23:28Z,GitHub,noreply@github.com,2021-11-16T04:23:28Z,"Add more error checking to new_generic() (#124)

Fixes #115",R/generic.R;tests/testthat/_snaps/generic.md;tests/testthat/test-generic.R;tests/testthat/test-method.R,False,True,True,False,63,2,65,"---FILE: R/generic.R---
@@ -50,6 +50,7 @@ new_generic <- function(name, fun = NULL, signature = NULL) {
   }
 
   if (is.null(signature)) {
+    check_generic(fun)
     signature <- guess_signature(fun)
   } else {
     signature <- check_signature(signature)
@@ -93,3 +94,33 @@ print.R7_generic <- function(x, ...) {
 
   cat(sprintf(""<R7_generic> %s with %i methods:\n%s"", formals, length(ms), msg), sep = """")
 }
+
+check_generic <- function(fun) {
+  if (!is.function(fun)) {
+    stop(""`fun` must be a function"", call. = FALSE)
+  }
+
+  if (!has_call(body(fun), quote(method_call))) {
+    stop(""`fun` must contain a call to `method_call()`"", call. = FALSE)
+  }
+}
+has_call <- function(x, name) {
+  if (!is.call(x)) {
+    return(FALSE)
+  }
+
+  if (identical(x[[1]], name)) {
+    return(TRUE)
+  }
+
+  if (length(x) == 1) {
+    return(FALSE)
+  }
+
+  for (i in seq(2, length(x))) {
+    if (has_call(x[[i]], name)) {
+      return(TRUE)
+    }
+  }
+  FALSE
+}

---FILE: tests/testthat/_snaps/generic.md---
@@ -31,3 +31,14 @@
       <R7_generic> function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, 
           r, s, t, u, v, w, x, y, z, ...)  with 0 methods:
 
+# check_generic produces informative errors
+
+    Code
+      check_generic(""x"")
+    Error <simpleError>
+      `fun` must be a function
+    Code
+      check_generic(function() { })
+    Error <simpleError>
+      `fun` must contain a call to `method_call()`
+

---FILE: tests/testthat/test-generic.R---
@@ -58,3 +58,22 @@ test_that(""R7_generic printing with long / many arguments"", {
     foo
   )
 })
+
+
+# check_generic_fun -------------------------------------------------------
+
+test_that(""check_generic produces informative errors"", {
+  expect_snapshot(error = TRUE,{
+    check_generic(""x"")
+    check_generic(function() {})
+  })
+})
+
+test_that(""has_fun handles expected cases"", {
+  expect_false(has_call(1, quote(x)))
+  expect_false(has_call(quote(f()), quote(x)))
+  expect_false(has_call(quote(f(a, b, c)), quote(x)))
+
+  expect_true(has_call(quote(x()), quote(x)))
+  expect_true(has_call(quote(y(x())), quote(x)))
+})

---FILE: tests/testthat/test-method.R---
@@ -179,7 +179,7 @@ test_that(""method_compatible returns TRUE if the functions are compatible"", {
     )
   )
 
-  foo <- new_generic(""foo"", function(x = NULL) {})
+  foo <- new_generic(""foo"", function(x = NULL) method_call())
   expect_true(
     method_compatible(
       function(x = NULL) x,
@@ -195,7 +195,7 @@ test_that(""method_compatible returns TRUE if the functions are compatible"", {
     )
   )
 
-  bar <- new_generic(""bar"", function(x=NULL, y=1, ...) {})
+  bar <- new_generic(""bar"", function(x=NULL, y=1, ...) method_call())
   expect_true(
     method_compatible(
       function(x = NULL, y = 1, ...) x,"
RConsortium,S7,84ed71dd984fcc5359e555c6cda6a17429f4e6b7,Hadley Wickham,h.wickham@gmail.com,2021-11-14T14:06:50Z,Hadley Wickham,h.wickham@gmail.com,2021-11-14T14:06:50Z,Fix import NOTE,NAMESPACE;R/R7-package.R,False,True,True,False,2,1,3,"---FILE: NAMESPACE---
@@ -36,6 +36,7 @@ export(valid_implicitly)
 importFrom(stats,setNames)
 importFrom(utils,getFromNamespace)
 importFrom(utils,getS3method)
+importFrom(utils,hasName)
 importFrom(utils,head)
 importFrom(utils,modifyList)
 importFrom(utils,packageName)

---FILE: R/R7-package.R---
@@ -1,5 +1,5 @@
 ## usethis namespace: start
 #' @useDynLib R7, .registration = TRUE
-#' @importFrom utils head str
+#' @importFrom utils head str hasName
 ## usethis namespace: end
 NULL"
RConsortium,S7,d5f99670a8cd4fcd296e6ca38f3eac257b74832b,Hadley Wickham,h.wickham@gmail.com,2021-11-12T13:35:38Z,GitHub,noreply@github.com,2021-11-12T13:35:38Z,"Fully define constructor function (#112)

Now the default constructor gets one argument for each property, passing the arguments to the parent as appropriate.

Fixes #102. Fixes #103.",R/class.R;R/constructor.R;R/property.R;R/utils.R;R/zzz.R;man/prop.Rd;tests/testthat/_snaps/constructor.md;tests/testthat/_snaps/object.md;tests/testthat/test-class.R;tests/testthat/test-constructor.R;tests/testthat/test-object.R;tests/testthat/test-property.R;vignettes/case_studies.Rmd,True,True,True,False,176,40,216,"---FILE: R/class.R---
@@ -1,5 +1,5 @@
 #' @importFrom utils modifyList
-R7_class <- function(name, parent = R7_object, constructor = function(.data = NULL, ...) new_object(.data, ...), validator = function(x) NULL, properties = list()) {
+R7_class <- function(name, parent = R7_object, constructor = NULL, validator = function(x) NULL, properties = list()) {
   if (is.character(parent)) {
     parent_obj <- class_get(parent)
     if (!is.null(parent_obj) && inherits(parent_obj, ""R7_class"")) {
@@ -13,6 +13,10 @@ R7_class <- function(name, parent = R7_object, constructor = function(.data = NU
     as_properties(properties)
   )
 
+  if (is.null(constructor)) {
+    constructor <- new_constructor(parent, properties)
+  }
+
   object <- constructor
   attr(object, ""name"") <- name
   attr(object, ""parent"") <- parent
@@ -84,16 +88,6 @@ R7_class <- function(name, parent = R7_object, constructor = function(.data = NU
 #' # Type validation is performed automatically in R7
 #' try(range(start = ""hello"", end = 20))
 new_class <- function(name, parent = R7_object, constructor = NULL, validator = function(x) NULL, properties = list()) {
-
-  if (is.null(constructor)) {
-    if (identical(parent, R7_object)) {
-      fun1 <- function(...) new_object(.data = NULL, ...)
-      constructor <- fun1
-    } else {
-      fun2 <- function(.data = NULL, ...) new_object(.data, ...)
-      constructor <- fun2
-    }
-  }
   R7_class(name = name, parent = parent, constructor = constructor, validator = validator, properties = properties)
 }
 

---FILE: R/constructor.R---
@@ -0,0 +1,45 @@
+new_constructor <- function(parent, properties) {
+  args <- constructor_args(parent, properties)
+
+  self_args <- as_names(args$self, named = TRUE)
+
+  if (identical(parent, R7_object)) {
+    parent_call <- NULL
+    env <- asNamespace(""R7"")
+  } else {
+    parent_name <- parent@name
+    parent_args <- as_names(args$parent, named = TRUE)
+    parent_call <- as.call(c(list(as.name(parent_name)), parent_args))
+
+    env <- new.env(parent = asNamespace(""R7""))
+    env[[parent_name]] <- parent
+  }
+  call <- as.call(c(list(quote(new_object), parent_call), self_args))
+
+  f <- function() {}
+  formals(f) <- lapply(setNames(, args$constructor), function(i) quote(expr = ))
+  body(f) <- call
+  environment(f) <- env
+  attr(f, ""srcref"") <- NULL
+
+  f
+}
+
+constructor_args <- function(parent, properties = list()) {
+  parent_args <- names2(formals(parent))
+
+  self_args <- names2(properties)
+  # Remove dynamic arguments
+  self_args <- self_args[vlapply(properties, function(x) is.null(x$getter))]
+  # Remove any parent properties; can't use parent_args() since the constructor
+  # might automatically set some properties.
+  self_args <- setdiff(self_args, names2(parent@properties))
+
+  constructor_args <- union(parent_args, self_args)
+
+  list(
+    parent = parent_args,
+    self = self_args,
+    constructor = constructor_args
+  )
+}

---FILE: R/property.R---
@@ -85,7 +85,7 @@ new_property <- function(name, class = NULL, getter = NULL, setter = NULL) {
 #'   colour = ""character"",
 #'   height = ""numeric""
 #' ))
-#' lexington <- horse(colour = ""bay"", height = 15)
+#' lexington <- horse(colour = ""bay"", height = 15, name = ""Lex"")
 #' lexington@colour
 #' prop(lexington, ""colour"")
 #'

---FILE: R/utils.R---
@@ -50,3 +50,19 @@ method_signature <- function(signature) {
   }
   collapse(vcapply(signature, format_signature), by = "", "")
 }
+
+as_names <- function(x, named = FALSE) {
+  if (named) {
+    names(x) <- x
+  }
+  lapply(x, as.name)
+}
+
+names2 <- function(x) {
+  nms <- names(x)
+  if (is.null(nms)) {
+    rep("""", length(x))
+  } else {
+    nms
+  }
+}

---FILE: R/zzz.R---
@@ -10,19 +10,23 @@ R7_object <- new_class(
   }
 )
 
+new_base_class <- function(name) {
+  R7_class(name = name, constructor = function(.data) new_object(.data))
+}
+
 base_classes <- new.env(parent = emptyenv())
-base_classes[[""logical""]] <- new_class(""logical"", constructor = function(x = logical()) new_object(x))
-base_classes[[""integer""]] <- new_class(""integer"", constructor = function(x = integer()) new_object(x))
-base_classes[[""double""]] <- new_class(""double"", constructor = function(x = double()) new_object(x))
-base_classes[[""numeric""]] <- new_class(""numeric"", constructor = function(x = numeric()) new_object(x))
-base_classes[[""complex""]] <- new_class(""complex"", constructor = function(x = complex()) new_object(x))
-base_classes[[""character""]] <- new_class(""character"", constructor = function(x = character()) new_object(x))
-base_classes[[""factor""]] <- new_class(""factor"", constructor = function(x = factor()) new_object(x))
-base_classes[[""raw""]] <- new_class(""raw"", constructor = function(x = raw()) new_object(x))
-base_classes[[""function""]] <- new_class(""function"", constructor = function(x = function() NULL) new_object(x))
-base_classes[[""list""]] <- new_class(""list"", constructor = function(x = list()) new_object(x))
-base_classes[[""data.frame""]] <- new_class(""data.frame"", constructor = function(x = data.frame()) new_object(x))
-base_classes[[""NULL""]] <- new_class(""NULL"", constructor = function(x = NULL) new_object(x))
+base_classes[[""logical""]] <- new_base_class(""logical"")
+base_classes[[""integer""]] <- new_base_class(""integer"")
+base_classes[[""double""]] <- new_base_class(""double"")
+base_classes[[""numeric""]] <- new_base_class(""numeric"")
+base_classes[[""complex""]] <- new_base_class(""complex"")
+base_classes[[""character""]] <- new_base_class(""character"")
+base_classes[[""factor""]] <- new_base_class(""factor"")
+base_classes[[""raw""]] <- new_base_class(""raw"")
+base_classes[[""function""]] <- new_base_class(""function"")
+base_classes[[""list""]] <- new_base_class(""list"")
+base_classes[[""data.frame""]] <- new_base_class(""data.frame"")
+base_classes[[""NULL""]] <- new_base_class(""NULL"")
 
 #' R7 generics and method objects
 #' @param name,generic The name or generic object of the generic

---FILE: man/prop.Rd---
@@ -54,7 +54,7 @@ horse <- new_class(""horse"", properties = list(
   colour = ""character"",
   height = ""numeric""
 ))
-lexington <- horse(colour = ""bay"", height = 15)
+lexington <- horse(colour = ""bay"", height = 15, name = ""Lex"")
 lexington@colour
 prop(lexington, ""colour"")
 

---FILE: tests/testthat/_snaps/constructor.md---
@@ -0,0 +1,29 @@
+# generates meaningful constructors
+
+    Code
+      new_constructor(R7_object, list())
+    Output
+      function () 
+      new_object(NULL)
+      <environment: namespace:R7>
+    Code
+      new_constructor(R7_object, as_properties(list(x = ""numeric"", y = ""numeric"")))
+    Output
+      function (x, y) 
+      new_object(NULL, x = x, y = y)
+      <environment: namespace:R7>
+    Code
+      foo <- new_class(""foo"", parent = ""character"")
+      new_constructor(foo, list())
+    Output
+      function (.data) 
+      new_object(foo(.data = .data))
+      <environment: 0x0>
+    Code
+      foo2 <- new_class(""foo2"", parent = foo)
+      new_constructor(foo2, list())
+    Output
+      function (.data) 
+      new_object(foo2(.data = .data))
+      <environment: 0x0>
+

---FILE: tests/testthat/_snaps/object.md---
@@ -4,19 +4,19 @@
       foo <- new_class(""foo"")
       foo(1)
     Error <simpleError>
-      All arguments to <foo> constructor must be named
+      unused argument (1)
     Code
       foo(1, 2)
     Error <simpleError>
-      All arguments to <foo> constructor must be named
+      unused arguments (1, 2)
     Code
       foo(x = 1)
     Error <simpleError>
-      All arguments to <foo> constructor must be properties: x
+      unused argument (x = 1)
     Code
       foo(x = 1, y = 2)
     Error <simpleError>
-      All arguments to <foo> constructor must be properties: x, y
+      unused arguments (x = 1, y = 2)
 
 # printing R7 objects work
 

---FILE: tests/testthat/test-class.R---
@@ -52,3 +52,15 @@ test_that(""classes can use unions in properties"", {
 
   expect_snapshot_error(my_class(name = 1))
 })
+
+test_that(""default constructor works"", {
+  foo1 <- new_class(""foo1"", properties = list(x = ""numeric""))
+  foo2 <- new_class(""foo2"", parent = foo1, properties = list(y = ""numeric""))
+  expect_s3_class(foo1(x = 1), ""foo1"")
+  expect_s3_class(foo2(x = 1, y = 2), ""foo2"")
+
+  text1 <- new_class(""text1"", parent = ""character"")
+  text2 <- new_class(""text2"", parent = text1, properties = list(y = ""numeric""))
+  expect_s3_class(text1(""abc""), ""text1"")
+  expect_s3_class(text2(""abc"", y = 1), ""text2"")
+})

---FILE: tests/testthat/test-constructor.R---
@@ -0,0 +1,45 @@
+test_that(""generates correct arguments from parent + properties"",  {
+  # No arguments
+  args <- constructor_args(R7_object)
+  expect_equal(args$constructor, character())
+
+  # Includes properties
+  args <- constructor_args(R7_object, as_properties(list(x = ""numeric"")))
+  expect_equal(args$constructor, ""x"")
+
+  # unless they're dynamic
+  args <- constructor_args(R7_object,
+    as_properties(list(new_property(""x"", getter = function(x) 10)))
+  )
+  expect_equal(args$constructor, character())
+
+  # Includes parent properties
+  foo <- new_class(""foo"", properties = list(x = ""numeric""))
+  args <- constructor_args(foo, as_properties(list(y = ""numeric"")))
+  expect_equal(args$constructor, c(""x"", ""y""))
+  expect_equal(args$self, ""y"")
+  expect_equal(args$parent, ""x"")
+
+  # But only those in the constructor
+  foo <- new_class(""foo"",
+    properties = list(x = ""numeric""),
+    constructor = function() new_object(x = 1)
+  )
+  args <- constructor_args(foo, as_properties(list(y = ""numeric"")))
+  expect_equal(args$constructor, ""y"")
+  expect_equal(args$self, ""y"")
+  expect_equal(args$parent, character())
+})
+
+test_that(""generates meaningful constructors"", {
+  expect_snapshot({
+    new_constructor(R7_object, list())
+    new_constructor(R7_object, as_properties(list(x = ""numeric"", y = ""numeric"")))
+
+    foo <- new_class(""foo"", parent = ""character"")
+    new_constructor(foo, list())
+
+    foo2 <- new_class(""foo2"", parent = foo)
+    new_constructor(foo2, list())
+  }, transform = scrub_environment)
+})

---FILE: tests/testthat/test-object.R---
@@ -23,9 +23,6 @@ describe(""new_object"", {
   })
 
   it(""can instantiate a new object that inherits from a basic type"", {
-    x <- text()
-    expect_equal(x@.data, class_get(""character"")())
-
     y <- text(""foo"")
     expect_equal(y@.data, class_get(""character"")(""foo""))
   })

---FILE: tests/testthat/test-property.R---
@@ -143,9 +143,6 @@ test_that(""property setters can set themselves"", {
     )
   )
 
-  x <- foo()
-
-  x@bar <- ""foo""
-
+  x <- foo(bar = ""foo"")
   expect_equal(x@bar, ""foo-bar"")
 })

---FILE: vignettes/case_studies.Rmd---
@@ -78,10 +78,7 @@ Classes can inherit from a parent class with `parent` and contain properties tha
 ```{r}
 Employee <- new_class(""Employee"",
   parent = Person,
-  properties = list(boss = ""Person""),
-  constructor = function(..., boss) {
-    new_object(Person(...), boss = boss)
-  }
+  properties = list(boss = ""Person"")
 )
 
 x <- Employee(name = ""John Smith"", birthdate = ""1992-10-11"", boss = jane)"
RConsortium,S7,b0faf6fa37bbd41cf1cf35cd3729ce883ebeb478,Hadley Wickham,h.wickham@gmail.com,2021-11-11T16:44:20Z,Hadley Wickham,h.wickham@gmail.com,2021-11-11T16:44:20Z,Fix typo,R/class.R;man/class_names.Rd,False,True,True,False,3,3,6,"---FILE: R/class.R---
@@ -97,7 +97,7 @@ new_class <- function(name, parent = R7_object, constructor = NULL, validator =
   R7_class(name = name, parent = parent, constructor = constructor, validator = validator, properties = properties)
 }
 
-#' Retrive all of the class names for a class
+#' Retrieve all of the class names for a class
 #'
 #' @param object The R7 object to query
 #' @return A character vector of all the class names for a given R7 class.

---FILE: man/class_names.Rd---
@@ -2,7 +2,7 @@
 % Please edit documentation in R/class.R
 \name{class_names}
 \alias{class_names}
-\title{Retrive all of the class names for a class}
+\title{Retrieve all of the class names for a class}
 \usage{
 class_names(object)
 }
@@ -13,5 +13,5 @@ class_names(object)
 A character vector of all the class names for a given R7 class.
 }
 \description{
-Retrive all of the class names for a class
+Retrieve all of the class names for a class
 }"
RConsortium,S7,7113d7ef93d90073d45ae6bfd934b0c0304ecee5,Kirill Müller,krlmlr@users.noreply.github.com,2021-10-31T12:47:56Z,GitHub,noreply@github.com,2021-10-31T12:47:56Z,Fix example (#106),R/class.R;R/property.R;man/new_class.Rd;man/new_property.Rd,False,True,True,False,8,6,14,"---FILE: R/class.R---
@@ -73,7 +73,7 @@ R7_class <- function(name, parent = R7_object, constructor = function(.data = NU
 #' )
 #' try(range(start = c(10, 15), end = 20))
 #' try(range(start = 20, end = 10))
-#' # Type validation is performed automatically R7
+#' # Type validation is performed automatically in R7
 #' try(range(start = ""hello"", end = 20))
 new_class <- function(name, parent = R7_object, constructor = NULL, validator = function(x) NULL, properties = list()) {
 

---FILE: R/property.R---
@@ -43,17 +43,18 @@
 #'   new_property(
 #'      ""firstName"",
 #'      getter = function(x) {
-#'        warning(""@first_name is deprecated; please use @firstName instead"")
+#'        warning(""@firstName is deprecated; please use @first_name instead"")
 #'        x@first_name
 #'      },
 #'      setter = function(x, value) {
-#'        warning(""@first_name is deprecated; please use @firstName instead"")
+#'        warning(""@firstName is deprecated; please use @first_name instead"")
 #'        x@first_name <- value
 #'      }
 #'    )
 #' ))
 #' hadley <- person(first_name = ""Hadley"")
 #' hadley@firstName
+#' hadley@first_name
 new_property <- function(name, class = NULL, getter = NULL, setter = NULL) {
   out <- list(name = name, class = class, getter = getter, setter = setter)
   class(out) <- ""R7_property""

---FILE: man/new_class.Rd---
@@ -74,6 +74,6 @@ range <- new_class(""range"",
 )
 try(range(start = c(10, 15), end = 20))
 try(range(start = 20, end = 10))
-# Type validation is performed automatically R7
+# Type validation is performed automatically in R7
 try(range(start = ""hello"", end = 20))
 }

---FILE: man/new_property.Rd---
@@ -53,15 +53,16 @@ person <- new_class(""person"", properties = list(
   new_property(
      ""firstName"",
      getter = function(x) {
-       warning(""@first_name is deprecated; please use @firstName instead"")
+       warning(""@firstName is deprecated; please use @first_name instead"")
        x@first_name
      },
      setter = function(x, value) {
-       warning(""@first_name is deprecated; please use @firstName instead"")
+       warning(""@firstName is deprecated; please use @first_name instead"")
        x@first_name <- value
      }
    )
 ))
 hadley <- person(first_name = ""Hadley"")
 hadley@firstName
+hadley@first_name
 }"
RConsortium,S7,6bfa5bafc593c12e3ad95d35de2e131d03120487,Hadley Wickham,h.wickham@gmail.com,2021-10-29T14:25:09Z,GitHub,noreply@github.com,2021-10-29T14:25:09Z,"Make default constructor stricter (#101)

Fixes #93",R/class.R;R/object.R;man/new_class.Rd;tests/testthat/_snaps/object.md;tests/testthat/test-object.R,False,True,True,False,60,12,72,"---FILE: R/class.R---
@@ -75,7 +75,15 @@ R7_class <- function(name, parent = R7_object, constructor = function(.data = NU
 #' try(range(start = 20, end = 10))
 #' # Type validation is performed automatically R7
 #' try(range(start = ""hello"", end = 20))
-new_class <- function(name, parent = R7_object, constructor = function(.data = NULL, ...) new_object(.data, ...), validator = function(x) NULL, properties = list()) {
+new_class <- function(name, parent = R7_object, constructor = NULL, validator = function(x) NULL, properties = list()) {
+
+  if (is.null(constructor)) {
+    if (identical(parent, R7_object)) {
+      constructor <- function(...) new_object(.data = NULL, ...)
+    } else {
+      constructor <- function(.data = NULL, ...) new_object(.data, ...)
+    }
+  }
   R7_class(name = name, parent = parent, constructor = constructor, validator = validator, properties = properties)
 }
 

---FILE: R/object.R---
@@ -6,6 +6,24 @@ new_object <- function(.data = NULL, ...) {
 
   args <- list(...)
   nms <- names(args)
+  if (length(args) > 0 && (is.null(nms) || any(nms == """"))) {
+    stop(
+      sprintf(""All arguments to <%s> constructor must be named"", obj_cls@name),
+      call. = FALSE
+    )
+  }
+
+  bad_names <- setdiff(nms, names(obj_cls@properties))
+  if (length(bad_names) > 0) {
+    stop(
+      sprintf(
+        ""All arguments to <%s> constructor must be properties: %s"",
+        obj_cls@name,
+        paste0(bad_names, collapse = "", "")
+      ),
+      call. = FALSE
+    )
+  }
 
 
   if (!is.null(.data)) {
@@ -21,20 +39,12 @@ new_object <- function(.data = NULL, ...) {
   attr(object, "".should_validate"") <- FALSE
 
   class(object) <- ""R7_object""
-
   object_class(object) <- obj_cls
-
-  props <- properties(object)
-
-  to_set <- intersect(nms, names(props))
-  # TODO: error if not all arguments are names of properties, likely a typo
-
-  for (nme in to_set) {
+  for (nme in nms) {
     property(object, nme) <- args[[nme]]
   }
 
   attr(object, "".should_validate"") <- NULL
-
   validate(object)
 
   object

---FILE: man/new_class.Rd---
@@ -7,7 +7,7 @@
 new_class(
   name,
   parent = R7_object,
-  constructor = function(.data = NULL, ...) new_object(.data, ...),
+  constructor = NULL,
   validator = function(x) NULL,
   properties = list()
 )

---FILE: tests/testthat/_snaps/object.md---
@@ -1,3 +1,23 @@
+# new_object: checks are arguments are properties
+
+    Code
+      foo <- new_class(""foo"")
+      foo(1)
+    Error <simpleError>
+      All arguments to <foo> constructor must be named
+    Code
+      foo(1, 2)
+    Error <simpleError>
+      All arguments to <foo> constructor must be named
+    Code
+      foo(x = 1)
+    Error <simpleError>
+      All arguments to <foo> constructor must be properties: x
+    Code
+      foo(x = 1, y = 2)
+    Error <simpleError>
+      All arguments to <foo> constructor must be properties: x, y
+
 # printing R7 objects work
 
     Code

---FILE: tests/testthat/test-object.R---
@@ -22,7 +22,6 @@ describe(""new_object"", {
     expect_error(range(start = 10, end = 1), ""`end` must be greater than or equal to `start`"")
   })
 
-
   it(""can instantiate a new object that inherits from a basic type"", {
     x <- text()
     expect_equal(x@.data, class_get(""character"")())
@@ -38,6 +37,17 @@ describe(""new_object"", {
     )
   })
 
+  it(""checks are arguments are properties"", {
+    expect_snapshot(error = TRUE, {
+      foo <- new_class(""foo"")
+      foo(1)
+      foo(1, 2)
+      foo(x = 1)
+      foo(x = 1, y = 2)
+    })
+  })
+
+
   it(""can use the parent constructor to instantiate objects"", {
     text2 <- new_class(""text2"", parent = ""character"")
     my_class <- new_class(""my_class"", parent = text2, properties = c(""name"" = ""character""), constructor = function(x, name) new_object(text2(x), name = name))"
RConsortium,S7,da2b4cd42fcfd6a39dd4ae22a4e3f91f7ddeb09d,Hadley Wickham,h.wickham@gmail.com,2021-10-29T14:18:20Z,GitHub,noreply@github.com,2021-10-29T14:18:20Z,"Improve methods docs (#95)

And unexport new_method(). Fixes #68.",NAMESPACE;R/method.R;man/method.Rd,False,True,True,False,73,20,93,"---FILE: NAMESPACE---
@@ -21,7 +21,6 @@ export(method_register)
 export(new_class)
 export(new_external_generic)
 export(new_generic)
-export(new_method)
 export(new_object)
 export(new_property)
 export(new_union)

---FILE: R/method.R---
@@ -1,10 +1,43 @@
 #' Retrieve or register an R7 method for a generic
 #'
-#' @param generic The generic to retrieve or register
-#' @param signature The method signature
-#' @param method,value The new function to use as the method.
+#' @description
+#' Generics partition a function into interface (a generic) and implementation
+#' (many methods). `method<-` allows you to register a method, an
+#' implementation for a specified class signature, with a generic.
+#'
+#' `method()` retrieves a method for a given signature. You typically shouldn't
+#' need this function while programming, because calling the generic will
+#' automatically dispatch to the correct method, but it's often useful
+#' interactively in order to see the implementation of a specific method.
+#'
+#' @param generic A generic function.
+#' @param signature A method signature, a list of R7 class constructors
+#'   (produced by [new_class()]) or names of S3 or S4 classes.
+#' @param value A function that implements the generic specification for the
+#'   given `signature`. The arguments must be compatible with the generic.
 #' @importFrom utils getS3method
 #' @export
+#' @examples
+#' # Create a generic
+#' bizarro <- new_generic(""bizarro"", signature = ""x"")
+#' # Register some methods
+#' method(bizarro, ""numeric"") <- function(x, ...) rev(x)
+#' method(bizarro, ""factor"") <- function(x, ...) {
+#'   levels(x) <- rev(levels(x))
+#'   x
+#' }
+#' method(bizarro, ""data.frame"") <- function(x, ...) {
+#'   x[] <- lapply(x, bizarro)
+#'   rev(x)
+#' }
+#'
+#' # Using a generic calls the methods automatically
+#' bizarro(1)
+#'
+#' # But it can be useful to explicitly retrieve a method in order to
+#' # inspect its implementation
+#' method(bizarro, list(""numeric""))
+#' method(bizarro, list(""factor""))
 method <- function(generic, signature) {
   signature <- as_signature(signature)
 
@@ -157,11 +190,6 @@ method_compatible <- function(method, generic) {
   TRUE
 }
 
-#' @rdname method
-#' @param package The package to register the method in, only used for soft
-#'   dependencies. The default `NULL` looks up the package based on the parent
-#'   frame.
-#' @export
 new_method <- function(generic, signature, method, package = NULL) {
   if (inherits(generic, ""R7_external_generic"")) {
     # Get current package, if any
@@ -226,7 +254,9 @@ new_method <- function(generic, signature, method, package = NULL) {
   invisible(generic)
 }
 
+
 #' @rdname method
+#'
 #' @export
 `method<-` <- function(generic, signature, value) {
   new_method(generic, signature, value, package = packageName(parent.frame()))

---FILE: man/method.Rd---
@@ -2,27 +2,51 @@
 % Please edit documentation in R/method.R
 \name{method}
 \alias{method}
-\alias{new_method}
 \alias{method<-}
 \title{Retrieve or register an R7 method for a generic}
 \usage{
 method(generic, signature)
 
-new_method(generic, signature, method, package = NULL)
-
 method(generic, signature) <- value
 }
 \arguments{
-\item{generic}{The generic to retrieve or register}
-
-\item{signature}{The method signature}
+\item{generic}{A generic function.}
 
-\item{method, value}{The new function to use as the method.}
+\item{signature}{A method signature, a list of R7 class constructors
+(produced by \code{\link[=new_class]{new_class()}}) or names of S3 or S4 classes.}
 
-\item{package}{The package to register the method in, only used for soft
-dependencies. The default \code{NULL} looks up the package based on the parent
-frame.}
+\item{value}{A function that implements the generic specification for the
+given \code{signature}. The arguments must be compatible with the generic.}
 }
 \description{
-Retrieve or register an R7 method for a generic
+Generics partition a function into interface (a generic) and implementation
+(many methods). \verb{method<-} allows you to register a method, an
+implementation for a specified class signature, with a generic.
+
+\code{method()} retrieves a method for a given signature. You typically shouldn't
+need this function while programming, because calling the generic will
+automatically dispatch to the correct method, but it's often useful
+interactively in order to see the implementation of a specific method.
+}
+\examples{
+# Create a generic
+bizarro <- new_generic(""bizarro"", signature = ""x"")
+# Register some methods
+method(bizarro, ""numeric"") <- function(x, ...) rev(x)
+method(bizarro, ""factor"") <- function(x, ...) {
+  levels(x) <- rev(levels(x))
+  x
+}
+method(bizarro, ""data.frame"") <- function(x, ...) {
+  x[] <- lapply(x, bizarro)
+  rev(x)
+}
+
+# Using a generic calls the methods automatically
+bizarro(1)
+
+# But it can be useful to explicitly retrieve a method in order to
+# inspect its implementation
+method(bizarro, list(""numeric""))
+method(bizarro, list(""factor""))
 }"
RConsortium,S7,032a32417d5eabde3c3bb9a4e2730ad3de600ade,Jim Hester,james.f.hester@gmail.com,2021-10-28T20:45:45Z,GitHub,noreply@github.com,2021-10-28T20:45:45Z,"Print methods for R7 methods and R7 generics (#90)

* Add print methods for R7 methods and R7 generics

Fixes #62

* Add snapshot tests

* Tweaks based on review feedback

- Handle R7 classes in signature properly
- Put formals in the generic output
- Include the method call on the first line",NAMESPACE;R/generic.R;R/method.R;R/utils.R;tests/testthat/_snaps/generic.md;tests/testthat/_snaps/method.md;tests/testthat/helper.R;tests/testthat/test-generic.R;tests/testthat/test-method.R,False,True,True,False,113,0,113,"---FILE: NAMESPACE---
@@ -2,6 +2,8 @@
 
 S3method(""@<-"",R7_object)
 S3method(print,R7_class)
+S3method(print,R7_generic)
+S3method(print,R7_method)
 S3method(print,R7_object)
 S3method(str,R7_object)
 export(""@"")

---FILE: R/generic.R---
@@ -75,3 +75,16 @@ generic_generate_signature_call <- function(signature) {
   call_args <- names(signature)
   as.call(c(as.symbol(""list""), lapply(class_args, function(x) { bquote(object_class(.(arg)), list(arg = as.symbol(x)))})))
 }
+
+#' @export
+print.R7_generic <- function(x, ...) {
+  ms <- methods(x)
+  indexes <- seq_along(ms)
+  method_signatures <- vcapply(ms, function(x) method_signature(x@signature))
+
+  msg <- collapse(sprintf(""%s: method(%s, list(%s))"", indexes, x@name, method_signatures), by = ""\n"")
+
+  formals <- collapse(head(format(args(x)), n = -1), by = ""\n"")
+
+  cat(sprintf(""<R7_generic> %s with %i methods:\n%s"", formals, length(ms), msg), sep = """")
+}

---FILE: R/method.R---
@@ -11,6 +11,18 @@ method <- function(generic, signature) {
   method_impl(generic, signature, ignore = NULL)
 }
 
+methods <- function(generic) {
+  get_all_methods(generic@methods, character())
+}
+
+get_all_methods <- function(x, signature) {
+  if(!is.environment(x)) {
+    return(x)
+  }
+
+  unlist(lapply(names(x), function(class) get_all_methods(x[[class]], c(signature, class))), recursive = FALSE)
+}
+
 as_signature <- function(signature) {
   if (!is.list(signature)) {
     signature <- list(signature)
@@ -257,3 +269,15 @@ method_lookup_error <- function(name, args, signatures) {
 method_call <- function() {
   .Call(method_call_, sys.call(-1), sys.function(-1), sys.frame(-1))
 }
+
+#' @export
+print.R7_method <- function(x, ...) {
+  method_signature <- method_signature(x@signature)
+
+  msg <- sprintf(""method(%s, list(%s))"", x@generic@name, method_signature)
+
+  attributes(x) <- NULL
+
+  cat(""<R7_method> "", msg, ""\n"", sep = """")
+  print(x)
+}

---FILE: R/utils.R---
@@ -35,3 +35,18 @@ vcapply <- function(X, FUN, ...) vapply(X = X, FUN = FUN, FUN.VALUE = character(
 fmt_classes <- function(classes, collapse = "", "") {
   paste0(""<"", classes, "">"", collapse = collapse)
 }
+
+collapse <- function(x, by) {
+  paste(x, collapse = by)
+}
+
+method_signature <- function(signature) {
+  format_signature <- function(x) {
+    if (inherits(x, ""R7_class"")) {
+      x@name
+    } else {
+      sprintf('""%s""', x)
+    }
+  }
+  collapse(vcapply(signature, format_signature), by = "", "")
+}

---FILE: tests/testthat/_snaps/generic.md---
@@ -0,0 +1,18 @@
+# R7_generic printing
+
+    Code
+      foo
+    Output
+      <R7_generic> function (x, y, z, ...)  with 3 methods:
+      1: method(foo, list(""character"", ""integer"", ""character""))
+      2: method(foo, list(""character"", ""integer"", ""logical""))
+      3: method(foo, list(""character"", text, ""character""))
+
+# R7_generic printing with long / many arguments
+
+    Code
+      foo
+    Output
+      <R7_generic> function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, 
+          r, s, t, u, v, w, x, y, z, ...)  with 0 methods:
+

---FILE: tests/testthat/_snaps/method.md---
@@ -79,3 +79,13 @@
     - x: <tbl_df>, <tbl>, <data.frame>
     - y: <POSIXct>, <POSIXt>
 
+# R7_method printing
+
+    Code
+      method(foo, list(text, ""integer""))
+    Output
+      <R7_method> method(foo, list(text, ""integer""))
+      function (x, y, ...) 
+      paste0(""bar:"", x, y)
+      <environment: 0x0>
+

---FILE: tests/testthat/helper.R---
@@ -63,3 +63,7 @@ quick_test_enable <- function() {
 scrub_src_references <- function(x) {
   grep(""attr[(][*], \""srcref|srcfile\""[)]|..[$] srcref "", x, invert = TRUE, value = TRUE)
 }
+
+scrub_environment <- function(x) {
+  gsub(""environment: 0x[0-9a-f]+"", ""environment: 0x0"", x)
+}

---FILE: tests/testthat/test-generic.R---
@@ -31,3 +31,21 @@ test_that(""guesses signature from required arguments"", {
   expect_equal(guess_signature(function(x, y, ...) {}), c(""x"", ""y""))
   expect_equal(guess_signature(function(x, ..., y = 1) {}), ""x"")
 })
+
+test_that(""R7_generic printing"", {
+  foo <- new_generic(name = ""foo"", signature = c(""x"", ""y"", ""z""))
+  method(foo, list(""character"", text, ""character"")) <- function(x, y, z, ...) 1
+  method(foo, list(""character"", ""integer"", ""character"")) <- function(x, y, z, ...) 2
+  method(foo, list(""character"", ""integer"", ""logical"")) <- function(x, y, z, ...) 3
+
+  expect_snapshot(
+    foo
+  )
+})
+
+test_that(""R7_generic printing with long / many arguments"", {
+  foo <- new_generic(name = ""foo"", signature = letters)
+  expect_snapshot(
+    foo
+  )
+})

---FILE: tests/testthat/test-method.R---
@@ -323,3 +323,12 @@ test_that(""method lookup fails with an informative message for multiple classes""
     foo(tibble::tibble(), .POSIXct(double()))
   )
 })
+
+test_that(""R7_method printing"", {
+  foo <- new_generic(name=""foo"", signature = c(""x"", ""y""))
+  method(foo, list(text, ""integer"")) <- function(x, y, ...) paste0(""bar:"", x, y)
+  expect_snapshot(
+    method(foo, list(text, ""integer"")),
+    transform = scrub_environment
+  )
+})"
RConsortium,S7,b5147d379db454dba98f3c77daf3502944a5341b,Jim Hester,james.f.hester@gmail.com,2021-10-27T14:25:50Z,GitHub,noreply@github.com,2021-10-27T14:25:50Z,"Accept character vectors in calls to `method()` (#84)

* Accept character vectors in calls to `method()`

Fixes #71

* Improve error message from invalid inputs to `method()`",R/method.R;tests/testthat/_snaps/method.md;tests/testthat/test-method.R,False,True,True,False,58,0,58,"---FILE: R/method.R---
@@ -6,9 +6,31 @@
 #' @importFrom utils getS3method
 #' @export
 method <- function(generic, signature) {
+  signature <- as_signature(signature)
+
   method_impl(generic, signature, ignore = NULL)
 }
 
+as_signature <- function(signature) {
+  if (!is.list(signature)) {
+    signature <- list(signature)
+  }
+  is_valid_signature <- vlapply(signature, function(x) inherits(x, ""R7_class"") | inherits(x, ""character""))
+  if (all(is_valid_signature)) {
+    return(signature)
+  }
+
+  invalid_indexes <- which(!is_valid_signature)
+  invalid_classes <- vcapply(signature[!is_valid_signature], function(x) fmt_classes(class(x)))
+
+  stop(
+    ""`signature` must be a list of <R7_class> or a <character>:\n"",
+    paste0(collapse = ""\n"",
+      sprintf(""- `signature[%s]`: is %s"", invalid_indexes, invalid_classes)
+    ),
+  call. = FALSE)
+}
+
 method_impl <- function(generic, signature, ignore) {
   out <- .Call(method_, generic, signature, ignore)
   if (is.null(out)) {

---FILE: tests/testthat/_snaps/method.md---
@@ -1,3 +1,19 @@
+# method errors on invalid inputs
+
+    `signature` must be a list of <R7_class> or a <character>:
+    - `signature[1]`: is <numeric>
+
+---
+
+    `signature` must be a list of <R7_class> or a <character>:
+    - `signature[1]`: is <numeric>
+
+---
+
+    `signature` must be a list of <R7_class> or a <character>:
+    - `signature[1]`: is <logical>
+    - `signature[2]`: is <logical>
+
 # method errors if no method is defined for that class
 
     Can't find method for generic `foo()` with classes:

---FILE: tests/testthat/test-method.R---
@@ -5,6 +5,26 @@ test_that(""method will fall back to S3 generics if no R7 generic is defined"", {
   )
 })
 
+test_that(""method will accept a character vector (#71)"", {
+  expect_equal(
+    method(print, ""text""),
+    base::print.default
+  )
+})
+
+test_that(""method errors on invalid inputs"", {
+  expect_snapshot_error(
+    method(print, 1)
+  )
+  expect_snapshot_error(
+    method(print, list(1))
+  )
+
+  expect_snapshot_error(
+    method(print, list(TRUE, FALSE))
+  )
+})
+
 test_that(""method errors if no method is defined for that class"", {
   foo <- new_generic(""foo"", signature = alist(x=))
 "
RConsortium,S7,ee096a0d8f24534dff408e86e9cd90c156505b9b,Jim Hester,james.f.hester@gmail.com,2021-10-26T19:50:58Z,GitHub,noreply@github.com,2021-10-26T19:50:58Z,"Method error messages (#83)

* More informative error messages when methods are not found

Fixes #69

* Update R/method.R

Co-authored-by: Hadley Wickham <h.wickham@gmail.com>

* Add snapshot tests for method errors

* Rename function to better indicate intent

Co-authored-by: Hadley Wickham <h.wickham@gmail.com>",DESCRIPTION;R/method.R;src/code.c;tests/testthat/_snaps/method.md;tests/testthat/test-method.R,False,True,True,False,66,6,72,"---FILE: DESCRIPTION---
@@ -47,7 +47,7 @@ Config/testthat/edition: 3
 Encoding: UTF-8
 LazyData: true
 Roxygen: list(markdown = TRUE)
-RoxygenNote: 7.1.1
+RoxygenNote: 7.1.2
 VignetteBuilder: knitr
 URL: https://RConsortium.github.io/OOP-WG, https://rconsortium.github.io/OOP-WG
 BugReports: https://github.com/RConsortium/OOP-WG/issues

---FILE: R/method.R---
@@ -29,7 +29,7 @@ method_impl <- function(generic, signature, ignore) {
   }
 
   if (is.null(out)) {
-    stop(sprintf(""Can't find method for generic '%s' with arguments of type:\n%s"", generic, paste0(""- "", names(args), "": "", vcapply(signature, paste0, collapse = "", ""), collapse = ""\n""), call. = FALSE))
+    method_lookup_error(generic, names(args), signature)
   }
 
   out
@@ -224,6 +224,12 @@ as_generic <- function(generic) {
   generic
 }
 
+method_lookup_error <- function(name, args, signatures) {
+  args <- setdiff(args, ""..."")
+  types <- paste0(""- "", args, "": "", vcapply(signatures, fmt_classes), collapse = ""\n"")
+  stop(sprintf(""Can't find method for generic `%s()` with classes:\n%s"", name, types), call. = FALSE)
+}
+
 #' Lookup the R7 method for the current generic and call it.
 #' @export
 method_call <- function() {

---FILE: src/code.c---
@@ -101,6 +101,18 @@ SEXP R7_object_() {
   return Rf_allocSExp(S4SXP);
 }
 
+void R7_method_lookup_error(SEXP generic, SEXP signature, SEXP envir) {
+  static SEXP R7_method_lookup_error_fun = NULL;
+  if (R7_method_lookup_error_fun == NULL) {
+    SEXP ns = Rf_findVarInFrame(R_NamespaceRegistry, Rf_install(""R7""));
+    R7_method_lookup_error_fun = Rf_findVarInFrame(ns, Rf_install(""method_lookup_error""));
+  }
+  SEXP name = Rf_getAttrib(generic, Rf_install(""name""));
+  SEXP args = Rf_getAttrib(Rf_getAttrib(generic, Rf_install(""signature"")), R_NamesSymbol);
+  SEXP R7_method_lookup_error_call = PROTECT(Rf_lang4(R7_method_lookup_error_fun, name, args, signature));
+  Rf_eval(R7_method_lookup_error_call, envir);
+}
+
 SEXP method_call_(SEXP call, SEXP generic, SEXP envir) {
   int n_protect = 0;
 
@@ -186,7 +198,7 @@ SEXP method_call_(SEXP call, SEXP generic, SEXP envir) {
 
   // If no method found, throw an error
   if (m == R_NilValue) {
-    Rf_errorcall(R_NilValue, ""No method found!"");
+    R7_method_lookup_error(generic, signature_classes, envir);
   }
 
   // And then actually call it.

---FILE: tests/testthat/_snaps/method.md---
@@ -1,3 +1,8 @@
+# method errors if no method is defined for that class
+
+    Can't find method for generic `foo()` with classes:
+    - x: <blah>
+
 # method_compatible throws errors if the functions are not compatible
 
     `method` must be consistent with <R7_generic> foo.
@@ -40,3 +45,21 @@
     - `generic` does not have `...`
     - `method` has `...`
 
+# method lookup fails with an informative message for single classes
+
+    Can't find method for generic `foo()` with classes:
+    - x: <logical>
+    - y: <list>
+
+---
+
+    Can't find method for generic `foo()` with classes:
+    - x: <logical>
+    - y: <>
+
+# method lookup fails with an informative message for multiple classes
+
+    Can't find method for generic `foo()` with classes:
+    - x: <tbl_df>, <tbl>, <data.frame>
+    - y: <POSIXct>, <POSIXt>
+

---FILE: tests/testthat/test-method.R---
@@ -8,9 +8,8 @@ test_that(""method will fall back to S3 generics if no R7 generic is defined"", {
 test_that(""method errors if no method is defined for that class"", {
   foo <- new_generic(""foo"", signature = alist(x=))
 
-  expect_error(
-    method(foo, list(""blah"")),
-    ""Can't find method for generic 'foo'""
+  expect_snapshot_error(
+    method(foo, list(""blah""))
   )
 })
 
@@ -284,3 +283,23 @@ test_that(""method compatible verifies that if a generic does not have dots the m
     )
   )
 })
+
+test_that(""method lookup fails with an informative message for single classes"", {
+  foo <- new_generic(name=""foo"", signature = c(""x"", ""y""))
+  method(foo, c(""character"", ""integer"")) <- function(x, y, ...) paste0(""bar:"", x, y)
+  expect_snapshot_error(
+    foo(TRUE, list())
+  )
+
+  expect_snapshot_error(
+    foo(TRUE)
+  )
+})
+
+test_that(""method lookup fails with an informative message for multiple classes"", {
+  foo <- new_generic(name=""foo"", signature = c(""x"", ""y""))
+  method(foo, c(""character"", ""integer"")) <- function(x, y, ...) paste0(""bar:"", x, y)
+  expect_snapshot_error(
+    foo(tibble::tibble(), .POSIXct(double()))
+  )
+})"
RConsortium,S7,a2379687e37f7ff83a02c6570e5690b8e6099f78,Jim Hester,james.f.hester@gmail.com,2021-10-26T13:21:37Z,Jim Hester,james.f.hester@gmail.com,2021-10-26T18:32:33Z,"Add str support for R7 objects

Fixes #64",NAMESPACE;R/method.R,False,True,True,False,7,0,7,"---FILE: NAMESPACE---
@@ -3,6 +3,7 @@
 S3method(""@<-"",R7_object)
 S3method(print,R7_class)
 S3method(print,R7_object)
+S3method(str,R7_object)
 export(""@"")
 export(""method<-"")
 export(""property<-"")

---FILE: R/method.R---
@@ -229,3 +229,9 @@ as_generic <- function(generic) {
 method_call <- function() {
   .Call(method_call_, sys.call(-1), sys.function(-1), sys.frame(-1))
 }
+
+#' @export
+str.R7_object <- function(object, ...) {
+  cat(""R7_object\n"")
+  str(attributes(object), ...)
+}"
RConsortium,S7,4462cb6241570157996d9a23e3b435730973b721,Hadley Wickham,h.wickham@gmail.com,2021-10-26T12:29:31Z,Hadley Wickham,h.wickham@gmail.com,2021-10-26T12:29:31Z,"Build fixes

* Fix broken vignette
* Upgrade build action
* Align vignette title",.github/workflows/R-CMD-check.yaml;R/class.R;vignettes/performance.Rmd,True,True,True,False,22,50,72,"---FILE: .github/workflows/R-CMD-check.yaml---
@@ -1,14 +1,10 @@
-# For help debugging build failures open an issue on the RStudio community with the 'github-actions' tag.
-# https://community.rstudio.com/new-topic?category=Package%20development&tags=github-actions
+# Workflow derived from https://github.com/r-lib/actions/tree/master/examples
+# Need help debugging build failures? Start at https://github.com/r-lib/actions#where-to-find-help
 on:
   push:
-    branches:
-      - main
-      - master
+    branches: [main, master]
   pull_request:
-    branches:
-      - main
-      - master
+    branches: [main, master]
 
 name: R-CMD-check
 
@@ -22,61 +18,37 @@ jobs:
       fail-fast: false
       matrix:
         config:
+          - {os: macOS-latest,   r: 'release'}
           - {os: windows-latest, r: 'release'}
-          - {os: macOS-latest, r: 'release'}
-          - {os: ubuntu-20.04, r: 'release', rspm: ""https://packagemanager.rstudio.com/cran/__linux__/focal/latest""}
-          - {os: ubuntu-20.04, r: 'devel', rspm: ""https://packagemanager.rstudio.com/cran/__linux__/focal/latest""}
+          - {os: ubuntu-latest,   r: 'devel', http-user-agent: 'release'}
+          - {os: ubuntu-latest,   r: 'release'}
+          - {os: ubuntu-latest,   r: 'oldrel-1'}
 
     env:
-      R_REMOTES_NO_ERRORS_FROM_WARNINGS: true
-      RSPM: ${{ matrix.config.rspm }}
       GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
+      R_KEEP_PKG_SOURCE: yes
 
     steps:
       - uses: actions/checkout@v2
 
+      - uses: r-lib/actions/setup-pandoc@v1
+
       - uses: r-lib/actions/setup-r@v1
         with:
           r-version: ${{ matrix.config.r }}
+          http-user-agent: ${{ matrix.config.http-user-agent }}
+          use-public-rspm: true
 
-      - uses: r-lib/actions/setup-pandoc@v1
-
-      - name: Query dependencies
-        run: |
-          install.packages('remotes')
-          saveRDS(remotes::dev_package_deps(dependencies = TRUE), "".github/depends.Rds"", version = 2)
-          writeLines(sprintf(""R-%i.%i"", getRversion()$major, getRversion()$minor), "".github/R-version"")
-        shell: Rscript {0}
-
-      - name: Cache R packages
-        if: runner.os != 'Windows'
-        uses: actions/cache@v2
+      - uses: r-lib/actions/setup-r-dependencies@v1
         with:
-          path: ${{ env.R_LIBS_USER }}
-          key: ${{ runner.os }}-${{ hashFiles('.github/R-version') }}-1-${{ hashFiles('.github/depends.Rds') }}
-          restore-keys: ${{ runner.os }}-${{ hashFiles('.github/R-version') }}-1-
-
-      - name: Install system dependencies
-        if: runner.os == 'Linux'
-        run: |
-          while read -r cmd
-          do
-            eval sudo $cmd
-          done < <(Rscript -e 'writeLines(remotes::system_requirements(""ubuntu"", ""20.04""))')
+          extra-packages: rcmdcheck
 
-      - name: Install dependencies
-        run: |
-          remotes::install_deps(dependencies = TRUE)
-          remotes::install_cran(""rcmdcheck"")
-        shell: Rscript {0}
+      - uses: r-lib/actions/check-r-package@v1
 
-      - name: Check
-        env:
-          _R_CHECK_CRAN_INCOMING_REMOTE_: false
-        run: |
-          options(crayon.enabled = TRUE)
-          rcmdcheck::rcmdcheck(args = c(""--no-manual"", ""--as-cran""), error_on = ""warning"", check_dir = ""check"")
-        shell: Rscript {0}
+      - name: Show testthat output
+        if: always()
+        run: find check -name 'testthat.Rout*' -exec cat '{}' \; || true
+        shell: bash
 
       - name: Upload check results
         if: failure()

---FILE: R/class.R---
@@ -76,7 +76,7 @@ print.R7_class <- function(x, ...) {
   props <- properties(x)
   if (length(props) > 0) {
     prop_names <- format(names(props))
-    prop_types <- format(paste0(""<"", vcapply(props, function(xx) xx[[""class""]] %||% """"), "">""), justify = ""right"")
+    prop_types <- format(paste0(""<"", vcapply(props, function(xx) xx[[""class""]][[1]] %||% """"), "">""), justify = ""right"")
     prop_fmt <- paste0(paste0("" $"", prop_names, "" "", prop_types, collapse = ""\n""), ""\n"")
   } else {
     prop_fmt <- """"

---FILE: vignettes/performance.Rmd---
@@ -2,7 +2,7 @@
 title: ""Performance""
 output: rmarkdown::html_vignette
 vignette: >
-  %\VignetteIndexEntry{performance}
+  %\VignetteIndexEntry{Performance}
   %\VignetteEngine{knitr::rmarkdown}
   %\VignetteEncoding{UTF-8}
 ---"
RConsortium,S7,1fe0611e73d221476a284aff8294dabd20015723,Hadley Wickham,h.wickham@gmail.com,2021-10-26T12:19:17Z,Hadley Wickham,h.wickham@gmail.com,2021-10-26T12:19:17Z,"Tweal NSE example

Fixes #78",README.Rmd;README.md,True,False,True,False,13,9,22,"---FILE: README.Rmd---
@@ -149,7 +149,9 @@ subset2 <- new_generic(name = ""subset2"", signature = ""x"")
 
 method(subset2, ""data.frame"") <- function(x, subset = NULL, select = NULL, drop = FALSE, ...) {
   e <- substitute(subset)
-  r <- eval(e, x, parent.frame())
+  # Unlike S3, R7 creates a frame for the generic, so we need to
+  # go one extra level up to get to the user's evaluation environment
+  r <- eval(e, x, parent.frame(2))
   r <- r & !is.na(r)
   nl <- as.list(seq_along(x))
   names(nl) <- names(x)

---FILE: README.md---
@@ -3,10 +3,10 @@
 
 # Object-oriented Programming Working Group
 
-  - [Initial proposal](proposal/proposal.org)
-  - [Requirements brainstorming](spec/requirements.md)
-  - [Minutes](minutes/)
-  - [Code](R/) (this repository is an R package)
+-   [Initial proposal](proposal/proposal.org)
+-   [Requirements brainstorming](spec/requirements.md)
+-   [Minutes](minutes/)
+-   [Code](R/) (this repository is an R package)
 
 These ideas have been implemented in the R7 package, hosted in this
 repository.
@@ -169,7 +169,9 @@ subset2 <- new_generic(name = ""subset2"", signature = ""x"")
 
 method(subset2, ""data.frame"") <- function(x, subset = NULL, select = NULL, drop = FALSE, ...) {
   e <- substitute(subset)
-  r <- eval(e, x, parent.frame())
+  # Unlike S3, R7 creates a frame for the generic, so we need to
+  # go one extra level up to get to the user's evaluation environment
+  r <- eval(e, x, parent.frame(2))
   r <- r & !is.na(r)
   nl <- as.list(seq_along(x))
   names(nl) <- names(x)
@@ -209,10 +211,10 @@ method(foo, list(""text"", ""numeric"")) <- function(x, y, ...) paste0(""foo-"", x, "":
 
 ## Design workflow
 
-  - File an issue to discuss the topic and build consensus.
-  - Once consensus has been reached, the issue author should create a
+-   File an issue to discuss the topic and build consensus.
+-   Once consensus has been reached, the issue author should create a
     pull request that summarises the discussion in the appropriate `.md`
     file, and request review from all folks who participated the issue
     discussion.
-  - Once all participants have accepted the PR, the original author
+-   Once all participants have accepted the PR, the original author
     merges."
RConsortium,S7,21eab4609d30ea31efb1e50290ecfdcc6eb77f7c,Jim Hester,james.f.hester@gmail.com,2021-03-23T17:03:21Z,Jim Hester,james.f.hester@gmail.com,2021-03-23T19:25:47Z,fix name of subset2 generic,README.Rmd;README.md,True,False,True,False,2,2,4,"---FILE: README.Rmd---
@@ -145,7 +145,7 @@ bar(text(""hi""), number(42))
 `method_call()` retains promises for dispatch arguments in basically the same way as `UseMethod()`, so non-standard evaluation works basically the same as S3.
 
 ```{r}
-subset2 <- new_generic(name = ""subset"", signature = ""x"")
+subset2 <- new_generic(name = ""subset2"", signature = ""x"")
 
 method(subset2, ""data.frame"") <- function(x, subset = NULL, select = NULL, drop = FALSE, ...) {
   e <- substitute(subset)

---FILE: README.md---
@@ -165,7 +165,7 @@ same way as `UseMethod()`, so non-standard evaluation works basically
 the same as S3.
 
 ``` r
-subset2 <- new_generic(name = ""subset"", signature = ""x"")
+subset2 <- new_generic(name = ""subset2"", signature = ""x"")
 
 method(subset2, ""data.frame"") <- function(x, subset = NULL, select = NULL, drop = FALSE, ...) {
   e <- substitute(subset)"
RConsortium,S7,5fcc532d3d49d61bba35ef9351f8f3cf5ab4c6ec,James Laird-Smith,jameslairdsmith@gmail.com,2021-03-21T14:01:12Z,GitHub,noreply@github.com,2021-03-21T14:01:12Z,Fix typo (#60),spec/requirements.md,False,False,False,False,1,1,2,"---FILE: spec/requirements.md---
@@ -114,6 +114,6 @@ This is important for:
 -   Generics and classes in suggested packages, so that method registration can occur when the dependency is loaded.
 
 -   Testing, since you may want to define a method only within a test.
-    This is particularly useful whne used to eliminate the need for mocking.
+    This is particularly useful when used to eliminate the need for mocking.
 
 -   Interface evolution, so you can provide a method for a generic or class that does not yet exist, anticipating a future release of a dependency."
RConsortium,S7,bbdb5e31ba4c6de452c58f4a449c44fc1ef2db62,Jim Hester,james.f.hester@gmail.com,2021-03-17T18:29:50Z,Jim Hester,james.f.hester@gmail.com,2021-03-17T18:29:50Z,Fix code so that the benchmark example works,.Rbuildignore;R/object.R,False,True,True,False,4,3,7,"---FILE: .Rbuildignore---
@@ -10,5 +10,6 @@
 ^script\.R$
 ^README_cache$
 ^_pkgdown\.yml$
+^vignettes/[^/]+_cache$
 ^docs$
 ^pkgdown$

---FILE: R/object.R---
@@ -10,9 +10,9 @@ new_object <- function(.data = NULL, ...) {
 
   if (!is.null(.data)) {
     # Verify .data satisfies the parent class
-    class_name <- class_names(obj_cls@parent)[[1]]
-    if (!identical(class_name, ""R7_object"") && !inherits(.data, class_name)) {
-      stop(sprintf(""`.data` must be a %s\n-`.data` is of type %s"", fmt_classes(class_name), fmt_classes(class(.data)[[1]])), call. = FALSE)
+    cls_nms <- class_names(obj_cls@parent)
+    if (!identical(cls_nms, ""R7_object"") && !inherits(.data, cls_nms)) {
+      stop(sprintf(""`.data` must be a %s\n-`.data` is of type %s"", fmt_classes(cls_nms), fmt_classes(class(.data)[[1]])), call. = FALSE)
     }
     object <- .data
   } else {"
RConsortium,S7,67bf42f7008884994994f480c2e385135982f702,Jim Hester,james.f.hester@gmail.com,2021-03-15T16:08:08Z,Jim Hester,james.f.hester@gmail.com,2021-03-15T16:08:08Z,"Tweak the error messages a bit

Try to use foo@bar syntax in more places",R/property.R;README.Rmd;README.md;tests/testthat/_snaps/property.md;tests/testthat/test-property.R,True,True,True,False,77,69,146,"---FILE: R/property.R---
@@ -30,7 +30,7 @@ property <- function(object, name) {
   val <- property_safely(object, name)
   if (is.null(val)) {
     class <- object_class(object)
-    stop(sprintf(""Can't find property '%s' in <%s>"", name, class@name), call. = FALSE)
+    stop(sprintf(""Can't find property %s@%s"", fmt_classes(class@name), name), call. = FALSE)
   }
 
   val

---FILE: README.Rmd---
@@ -39,7 +39,7 @@ range <- new_class(""range"",
   },
   validator = function(x) {
     if (x@end < x@start) {
-      ""`end` must be greater than or equal to `start`""
+      ""<range>@end must be greater than or equal to <range>@start""
     }
   },
   properties = list(
@@ -147,7 +147,7 @@ method(subset2, ""data.frame"") <- function(x, subset = NULL, select = NULL, drop
 subset2(mtcars, hp > 200, c(wt, qsec))
 ```
 
-### Load time registration
+### External generics
 ```{r eval = FALSE}
 .onLoad <- function(libname, pkgname) {
   R7::method_register()
@@ -227,12 +227,12 @@ gen_character <- function (n, min = 5, max = 25, values = c(letters, LETTERS, 0:
 
 bench::press(
   num_classes = c(3, 5, 10, 50, 100),
-  class_size = c(15, 100),
+  class_nchar = c(15, 100),
   {
     # Construct a class hierarchy with that number of classes
     text <- new_class(""text"", parent = ""character"", constructor = function(text) new_object(.data = text))
     parent <- text
-    classes <- gen_character(num_classes, min = class_size, max = class_size)
+    classes <- gen_character(num_classes, min = class_nchar, max = class_nchar)
     env <- new.env()
     for (x in classes) {
       assign(x, new_class(x, parent = parent, constructor = function(text) new_object(.data = text)), env)
@@ -261,17 +261,17 @@ bench::press(
 )
 ```
 
-And the same benchmark using double-dispatch vs single dispatch
+And the same benchmark using double-dispatch
 
 ```{r performance-3, message = FALSE, R.options = list(width = 120), cache = TRUE}
 bench::press(
   num_classes = c(3, 5, 10, 50, 100),
-  class_size = c(15, 100),
+  class_nchar = c(15, 100),
   {
     # Construct a class hierarchy with that number of classes
     text <- new_class(""text"", parent = ""character"", constructor = function(text) new_object(.data = text))
     parent <- text
-    classes <- gen_character(num_classes, min = class_size, max = class_size)
+    classes <- gen_character(num_classes, min = class_nchar, max = class_nchar)
     env <- new.env()
     for (x in classes) {
       assign(x, new_class(x, parent = parent, constructor = function(text) new_object(.data = text)), env)

---FILE: README.md---
@@ -29,7 +29,7 @@ range <- new_class(""range"",
   },
   validator = function(x) {
     if (x@end < x@start) {
-      ""`end` must be greater than or equal to `start`""
+      ""<range>@end must be greater than or equal to <range>@start""
     }
   },
   properties = list(
@@ -65,17 +65,17 @@ x@length
 
 # incorrect properties throws an error
 x@middle
-#> Error: Can't find property 'middle' in <range>
+#> Error: Can't find property <range>@middle
 
 # assigning properties verifies the class matches the class of the value
 x@end <- ""foo""
-#> Error: `value` must be of class <numeric>:
+#> Error: <range>@end must be of class <numeric>:
 #> - `value` is of class <character>
 
 # assigning properties runs the validator
 x@end <- 0
 #> Error: Invalid <range> object:
-#> - `end` must be greater than or equal to `start`
+#> - <range>@end must be greater than or equal to <range>@start
 
 # Print methods for both R7_class objects
 object_class(x)
@@ -170,7 +170,7 @@ subset2(mtcars, hp > 200, c(wt, qsec))
 #> Maserati Bora       3.570 14.60
 ```
 
-### Load time registration
+### External generics
 
 ``` r
 .onLoad <- function(libname, pkgname) {
@@ -230,9 +230,9 @@ bench::mark(foo_R7(x), foo_s3(x), foo_s4(x))
 #> # A tibble: 3 x 6
 #>   expression      min   median `itr/sec` mem_alloc `gc/sec`
 #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>
-#> 1 foo_R7(x)    8.67µs   9.63µs    84752.        0B     17.0
-#> 2 foo_s3(x)    3.87µs   4.33µs   208784.        0B     20.9
-#> 3 foo_s4(x)    4.32µs   4.74µs   200500.        0B     20.1
+#> 1 foo_R7(x)     8.5µs  10.39µs    84735.        0B     17.0
+#> 2 foo_s3(x)     3.8µs   4.22µs   223028.        0B     22.3
+#> 3 foo_s4(x)    4.26µs   4.72µs   200283.        0B     20.0
 
 bar_R7 <- new_generic(""bar_R7"", c(""x"", ""y""))
 method(bar_R7, list(""text"", ""number"")) <- function(x, y, ...) paste0(x, ""-"", y, ""-bar"")
@@ -246,8 +246,8 @@ bench::mark(bar_R7(x, y), bar_s4(x, y))
 #> # A tibble: 2 x 6
 #>   expression        min   median `itr/sec` mem_alloc `gc/sec`
 #>   <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>
-#> 1 bar_R7(x, y)  14.47µs   16.3µs    57083.        0B     28.6
-#> 2 bar_s4(x, y)   9.73µs   11.5µs    83005.        0B     16.6
+#> 1 bar_R7(x, y)  14.21µs   15.7µs    60508.        0B     30.3
+#> 2 bar_s4(x, y)   9.54µs   10.6µs    89368.        0B     17.9
 ```
 
 A potential optimization is caching based on the class names, but lookup
@@ -275,12 +275,12 @@ gen_character <- function (n, min = 5, max = 25, values = c(letters, LETTERS, 0:
 
 bench::press(
   num_classes = c(3, 5, 10, 50, 100),
-  class_size = c(15, 100),
+  class_nchar = c(15, 100),
   {
     # Construct a class hierarchy with that number of classes
     text <- new_class(""text"", parent = ""character"", constructor = function(text) new_object(.data = text))
     parent <- text
-    classes <- gen_character(num_classes, min = class_size, max = class_size)
+    classes <- gen_character(num_classes, min = class_nchar, max = class_nchar)
     env <- new.env()
     for (x in classes) {
       assign(x, new_class(x, parent = parent, constructor = function(text) new_object(.data = text)), env)
@@ -308,41 +308,41 @@ bench::press(
   }
 )
 #> # A tibble: 20 x 8
-#>    expression num_classes class_size      min   median `itr/sec` mem_alloc `gc/sec`
-#>    <bch:expr>       <dbl>      <dbl> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>
-#>  1 best                 3         15   9.91µs   12.4µs    80813.        0B     24.3
-#>  2 worst                3         15  10.17µs     12µs    80288.        0B     32.1
-#>  3 best                 5         15   9.91µs   12.7µs    76523.        0B     30.6
-#>  4 worst                5         15  10.54µs   12.4µs    78195.        0B     31.3
-#>  5 best                10         15   9.89µs   12.5µs    78052.        0B     31.2
-#>  6 worst               10         15  11.01µs   13.3µs    74023.        0B     29.6
-#>  7 best                50         15  10.03µs   11.8µs    81389.        0B     32.6
-#>  8 worst               50         15  14.29µs   15.6µs    59115.        0B     23.7
-#>  9 best               100         15   10.8µs   12.5µs    77170.        0B     30.9
-#> 10 worst              100         15  18.07µs   20.1µs    47337.        0B     18.9
-#> 11 best                 3        100   9.82µs   11.3µs    84505.        0B     33.8
-#> 12 worst                3        100  10.23µs   12.8µs    76000.        0B     30.4
-#> 13 best                 5        100   10.2µs   11.7µs    80082.        0B     32.0
-#> 14 worst                5        100  10.99µs   13.8µs    72780.        0B     29.1
-#> 15 best                10        100  10.14µs   12.8µs    78083.        0B     31.2
-#> 16 worst               10        100  11.85µs   13.2µs    70176.        0B     28.1
-#> 17 best                50        100  10.42µs   12.5µs    77965.        0B     31.2
-#> 18 worst               50        100  16.82µs   18.5µs    51479.        0B     20.6
-#> 19 best               100        100  10.27µs   12.6µs    77110.        0B     30.9
-#> 20 worst              100        100   24.2µs   26.1µs    36342.        0B     14.5
+#>    expression num_classes class_nchar      min   median `itr/sec` mem_alloc `gc/sec`
+#>    <bch:expr>       <dbl>       <dbl> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>
+#>  1 best                 3          15   8.62µs   10.9µs    91862.        0B     36.8
+#>  2 worst                3          15   9.03µs   11.3µs    88546.        0B     35.4
+#>  3 best                 5          15   8.84µs   10.3µs    91116.        0B     36.5
+#>  4 worst                5          15   9.35µs   10.5µs    90944.        0B     36.4
+#>  5 best                10          15   8.98µs   11.1µs    89742.        0B     35.9
+#>  6 worst               10          15   9.65µs   11.9µs    82342.        0B     24.7
+#>  7 best                50          15   9.15µs   11.4µs    87054.        0B     34.8
+#>  8 worst               50          15  13.01µs   14.7µs    64879.        0B     26.0
+#>  9 best               100          15   9.34µs   11.1µs    86467.        0B     34.6
+#> 10 worst              100          15  17.02µs   18.8µs    50694.        0B     20.3
+#> 11 best                 3         100   8.64µs   10.6µs    93073.        0B     37.2
+#> 12 worst                3         100   9.36µs   11.7µs    85594.        0B     34.3
+#> 13 best                 5         100   8.81µs   11.3µs    87928.        0B     35.2
+#> 14 worst                5         100   9.96µs   11.8µs    82845.        0B     33.2
+#> 15 best                10         100   9.05µs   11.3µs    87958.        0B     35.2
+#> 16 worst               10         100  10.58µs   13.4µs    72944.        0B     21.9
+#> 17 best                50         100   9.19µs   11.4µs    86818.        0B     26.1
+#> 18 worst               50         100  15.89µs   17.9µs    52961.        0B     21.2
+#> 19 best               100         100    9.7µs   12.3µs    81904.        0B     32.8
+#> 20 worst              100         100  24.17µs   26.2µs    35199.        0B     14.1
 ```
 
-And the same benchmark using double-dispatch vs single dispatch
+And the same benchmark using double-dispatch
 
 ``` r
 bench::press(
   num_classes = c(3, 5, 10, 50, 100),
-  class_size = c(15, 100),
+  class_nchar = c(15, 100),
   {
     # Construct a class hierarchy with that number of classes
     text <- new_class(""text"", parent = ""character"", constructor = function(text) new_object(.data = text))
     parent <- text
-    classes <- gen_character(num_classes, min = class_size, max = class_size)
+    classes <- gen_character(num_classes, min = class_nchar, max = class_nchar)
     env <- new.env()
     for (x in classes) {
       assign(x, new_class(x, parent = parent, constructor = function(text) new_object(.data = text)), env)
@@ -371,28 +371,28 @@ bench::press(
   }
 )
 #> # A tibble: 20 x 8
-#>    expression num_classes class_size      min   median `itr/sec` mem_alloc `gc/sec`
-#>    <bch:expr>       <dbl>      <dbl> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>
-#>  1 best                 3         15   10.2µs   11.5µs    80091.        0B     32.0
-#>  2 worst                3         15     11µs   11.7µs    81925.        0B     32.8
-#>  3 best                 5         15   10.3µs   11.5µs    77925.        0B     39.0
-#>  4 worst                5         15   11.1µs   11.9µs    81456.        0B     32.6
-#>  5 best                10         15   10.7µs   11.7µs    79036.        0B     31.6
-#>  6 worst               10         15   12.2µs   13.4µs    70143.        0B     28.1
-#>  7 best                50         15     11µs   11.8µs    80724.        0B     40.4
-#>  8 worst               50         15   18.3µs   19.5µs    47408.        0B     19.0
-#>  9 best               100         15   11.7µs   12.8µs    73903.        0B     29.6
-#> 10 worst              100         15   27.1µs   28.8µs    32861.        0B     16.4
-#> 11 best                 3        100   10.6µs   11.6µs    81519.        0B     32.6
-#> 12 worst                3        100   11.6µs   12.5µs    75169.        0B     30.1
-#> 13 best                 5        100   10.7µs   11.9µs    80362.        0B     40.2
-#> 14 worst                5        100   12.1µs   13.1µs    70882.        0B     28.4
-#> 15 best                10        100   10.6µs     12µs    78126.        0B     31.3
-#> 16 worst               10        100   13.9µs     15µs    63313.        0B     31.7
-#> 17 best                50        100   11.4µs     13µs    72297.        0B     28.9
-#> 18 worst               50        100   23.6µs   25.2µs    37711.        0B     18.9
-#> 19 best               100        100   12.1µs   13.4µs    70365.        0B     28.2
-#> 20 worst              100        100     37µs   39.2µs    23647.        0B     11.8
+#>    expression num_classes class_nchar      min   median `itr/sec` mem_alloc `gc/sec`
+#>    <bch:expr>       <dbl>       <dbl> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>
+#>  1 best                 3          15   9.62µs  11.72µs    81712.        0B    32.7 
+#>  2 worst                3          15    9.6µs  10.32µs    91606.        0B    36.7 
+#>  3 best                 5          15   9.18µs   9.77µs    97699.        0B    39.1 
+#>  4 worst                5          15   9.98µs  10.74µs    90485.        0B    36.2 
+#>  5 best                10          15   9.32µs  10.01µs    92839.        0B    37.2 
+#>  6 worst               10          15  10.75µs   11.8µs    81703.        0B    32.7 
+#>  7 best                50          15  10.21µs   11.1µs    86549.        0B    34.6 
+#>  8 worst               50          15  17.12µs  18.44µs    52067.        0B    20.8 
+#>  9 best               100          15  10.56µs   11.8µs    81407.        0B    32.6 
+#> 10 worst              100          15  24.53µs  26.03µs    36629.        0B    14.7 
+#> 11 best                 3         100   9.27µs  10.43µs    91396.        0B    45.7 
+#> 12 worst                3         100  10.32µs  11.43µs    83567.        0B    33.4 
+#> 13 best                 5         100   9.51µs  10.55µs    90847.        0B    36.4 
+#> 14 worst                5         100  10.56µs  11.86µs    80953.        0B    32.4 
+#> 15 best                10         100   9.54µs  10.64µs    88915.        0B    35.6 
+#> 16 worst               10         100  12.25µs  13.61µs    70435.        0B    28.2 
+#> 17 best                50         100  10.27µs  11.39µs    83964.        0B    33.6 
+#> 18 worst               50         100  23.38µs  25.02µs    38013.        0B    15.2 
+#> 19 best               100         100  10.85µs   11.8µs    80367.        0B    32.2 
+#> 20 worst              100         100  37.28µs  38.79µs    24552.        0B     9.82
 ```
 
 ## Questions

---FILE: tests/testthat/_snaps/property.md---
@@ -0,0 +1,8 @@
+# property: does not use partial matching
+
+    Can't find property <range>@st
+
+# @: does not use partial matching
+
+    Can't find property <range>@st
+

---FILE: tests/testthat/test-property.R---
@@ -6,7 +6,7 @@ describe(""property"", {
   })
   it(""does not use partial matching"", {
     x <- range(1, 10)
-    expect_error(property(x, ""st""), ""Can't find property 'st' in <range>"")
+    expect_snapshot_error(property(x, ""st""))
   })
   it(""retrieves .data"", {
     x <- text(""hi"")
@@ -54,7 +54,7 @@ describe(""@"", {
   })
   it(""does not use partial matching"", {
     x <- range(1, 10)
-    expect_error(x@st, ""Can't find property 'st' in <range>"")
+    expect_snapshot_error(x@st)
   })
   it(""falls back to `base::@` for non-R7 objects"", {
     x <- ""foo"""
RConsortium,S7,0c6419d40896695a2ac99c4f44563545a73ac10a,Jim Hester,james.f.hester@gmail.com,2021-03-15T15:58:53Z,Jim Hester,james.f.hester@gmail.com,2021-03-15T15:58:53Z,Include class and name in the error for property assignments,R/property.R;tests/testthat/_snaps/class.md,False,True,True,False,3,2,5,"---FILE: R/property.R---
@@ -92,7 +92,8 @@ properties <- function(object) {
     if (isTRUE(check) && length(prop[[""class""]]) > 0) {
       classes <- setdiff(class_names(prop[[""class""]]), ""R7_object"")
       if (!inherits(value, classes)) {
-        stop(sprintf(""`value` must be of class %s:\n- `value` is of class <%s>"", fmt_classes(classes), class(value)[[1]]), call. = FALSE)
+        obj_cls <- object_class(object)
+        stop(sprintf(""%s@%s must be of class %s:\n- `value` is of class <%s>"", fmt_classes(obj_cls@name), name, fmt_classes(classes), class(value)[[1]]), call. = FALSE)
       }
     }
     attr(object, name) <- value

---FILE: tests/testthat/_snaps/class.md---
@@ -1,5 +1,5 @@
 # classes can use unions in properties
 
-    `value` must be of class <character>, <factor>:
+    <my_class>@name must be of class <character>, <factor>:
     - `value` is of class <numeric>
 "
RConsortium,S7,61855f68efbf2fce893ab3acef92a316213b4ba3,Jim Hester,james.f.hester@gmail.com,2021-03-15T15:34:27Z,Jim Hester,james.f.hester@gmail.com,2021-03-15T15:41:41Z,Fix external generics in hard and soft dependecies,R/method.R;man/method.Rd;src/code.c;tests/testthat/t2/NAMESPACE;tests/testthat/t2/R/pkg.R,False,True,True,False,30,20,50,"---FILE: R/method.R---
@@ -78,15 +78,15 @@ method_register <- function() {
   for (x in tbl) {
     if (isNamespaceLoaded(x$package)) {
       ns <- asNamespace(x$package)
-      new_method(getFromNamespace(x$generic, ns), x$signature, x$value)
+      new_method(getFromNamespace(x$generic, ns), x$signature, x$method)
     } else {
       setHook(packageEvent(x$package, ""onLoad""),
         local({
           x <- x
           function(...) {
             ns <- asNamespace(x$package)
             if (is.null(x$version) || getNamespaceVersion(ns) >= x$version) {
-              new_method(getFromNamespace(x$generic, ns), x$signature, x$value)
+              new_method(getFromNamespace(x$generic, ns), x$signature, x$method)
             }
           }
         })
@@ -123,33 +123,33 @@ method_compatible <- function(method, generic) {
 }
 
 #' @rdname method
+#' @param package The package to register the method in, only used for soft
+#'   dependencies. The default `NULL` looks up the package based on the parent
+#'   frame.
 #' @export
-new_method <- function(generic, signature, method) {
-  if (!is.character(signature) && !inherits(signature, ""list"")) {
-    signature <- list(signature)
-  }
-
+new_method <- function(generic, signature, method, package = NULL) {
   if (inherits(generic, ""R7_external_generic"")) {
-    package <- generic$package
-    generic <- generic$generic
     # Get current package, if any
-    current_package <- packageName(parent.frame())
-    if (!is.null(current_package)) {
-      tbl <- asNamespace(current_package)[["".__S3MethodsTable__.""]]
+    if (!is.null(package)) {
+      tbl <- asNamespace(package)[["".__S3MethodsTable__.""]]
       if (is.null(tbl[["".R7_methods""]])) {
         tbl[["".R7_methods""]] <- list()
       }
       tbl[["".R7_methods""]] <- append(tbl[["".R7_methods""]], list(list(generic = generic$generic, package = generic$package, signature = signature, method = method, version = generic$version)))
 
       return(invisible())
     }
-    generic <- getFromNamespace(generic, asNamespace(package))
+    generic <- getFromNamespace(generic$generic, asNamespace(generic$package))
   }
 
   generic <- as_generic(generic)
 
   method_compatible(method, generic)
 
+  if (!is.character(signature) && !inherits(signature, ""list"")) {
+    signature <- list(signature)
+  }
+
   if (!inherits(method, ""R7_method"")) {
     method <- R7_method(generic, signature, method)
   }
@@ -158,9 +158,10 @@ new_method <- function(generic, signature, method) {
 
   p_tbl <- generic@methods
 
+
   for (i in seq_along(signature)) {
     if (inherits(signature[[i]], ""R7_union"")) {
-      for (class in signature[[1]]@classes) {
+      for (class in signature[[i]]@classes) {
         new_method(generic, c(signature[seq_len(i - 1)], class@name), method)
       }
       return(invisible(generic))
@@ -185,7 +186,7 @@ new_method <- function(generic, signature, method) {
 #' @rdname method
 #' @export
 `method<-` <- function(generic, signature, value) {
-  new_method(generic, signature, value)
+  new_method(generic, signature, value, package = packageName(parent.frame()))
 }
 
 as_generic <- function(generic) {

---FILE: man/method.Rd---
@@ -8,7 +8,7 @@
 \usage{
 method(generic, signature)
 
-new_method(generic, signature, method)
+new_method(generic, signature, method, package = NULL)
 
 method(generic, signature) <- value
 }
@@ -18,6 +18,10 @@ method(generic, signature) <- value
 \item{signature}{The method signature}
 
 \item{method, value}{The new function to use as the method.}
+
+\item{package}{The package to register the method in, only used for soft
+dependencies. The default \code{NULL} looks up the package based on the parent
+frame.}
 }
 \description{
 Retrieve or register an R7 method for a generic

---FILE: src/code.c---
@@ -184,6 +184,11 @@ SEXP method_call_(SEXP call, SEXP generic, SEXP envir) {
   // Now that we have retrieved all the classes, we can look up what method to call.
   SEXP m = method_(generic, signature_classes, R_NilValue);
 
+  // If no method found, throw an error
+  if (m == R_NilValue) {
+    Rf_errorcall(R_NilValue, ""No method found!"");
+  }
+
   // And then actually call it.
   SEXP res = Rf_applyClosure(call, m, args, envir, R_NilValue);
 

---FILE: tests/testthat/t2/NAMESPACE---
@@ -1,3 +1,2 @@
 # Generated by roxygen2: do not edit by hand
 
-importFrom(t0,bar)

---FILE: tests/testthat/t2/R/pkg.R---
@@ -1,9 +1,10 @@
 foo <- R7::new_external_generic(""t1"", ""foo"", list(""character"", ""numeric""))
 
-R7::method(foo, list(""character"", ""numeric"")) <- function(x, y) paste0(""foo-"", x, ""-"", y)
+R7::method(foo, list(""character"", ""numeric"")) <- function(x, y, ...) paste0(""foo-"", x, ""-"", y)
 
-#' @importFrom t0 bar
-R7::method(bar, list(""character"", ""numeric"")) <- function(x, y) paste0(""bar-"", x, ""-"", y)
+bar <- R7::new_external_generic(""t0"", ""bar"", list(""character"", ""numeric""))
+
+R7::method(bar, list(""character"", ""numeric"")) <- function(x, y, ...) paste0(""bar-"", x, ""-"", y)
 
 .onLoad <- function(libname, pkgname) {
   R7::method_register()"
RConsortium,S7,a6200719128750f8d7673a28d7f10c54a2bd85c6,Jim Hester,james.f.hester@gmail.com,2021-03-11T16:20:12Z,Jim Hester,james.f.hester@gmail.com,2021-03-11T16:22:42Z,"Roughed out support for UseMethod style method calling

Fixes #56",NAMESPACE;R/generic.R;R/method.R;README.md;man/method_call.Rd;src/code.c;src/init.c;tests/testthat/test-generic.R;tests/testthat/test-method.R,False,True,True,False,99,11,110,"---FILE: NAMESPACE---
@@ -10,11 +10,11 @@ export(R7_generic)
 export(R7_method)
 export(R7_object)
 export(R7_union)
-export(call_method)
 export(class_get)
 export(class_names)
 export(generic_generate)
 export(method)
+export(method_call)
 export(method_register)
 export(new_class)
 export(new_generic)

---FILE: R/generic.R---
@@ -12,7 +12,9 @@ new_generic <- function(name, signature = NULL, fun = NULL) {
   signature <- normalize_signature(signature)
 
   if (is.null(fun)) {
-    fun <- generic_generate(name, signature, envir = parent.frame())
+    fun <- function() method_call()
+    formals(fun) <- signature
+    environment(fun) <- topenv(environment())
   }
 
   R7_generic(name = name, signature, fun = fun)

---FILE: R/method.R---
@@ -174,3 +174,9 @@ as_generic <- function(generic) {
 
   generic
 }
+
+#' Lookup the R7 method for the current generic and call it.
+#' @export
+method_call <- function() {
+  .Call(method_call_, sys.function(sys.parent(1)), parent.frame())
+}

---FILE: README.md---
@@ -202,9 +202,9 @@ bench::mark(foo_R7(x), foo_s3(x), foo_s4(x))
 #> # A tibble: 3 x 6
 #>   expression      min   median `itr/sec` mem_alloc `gc/sec`
 #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>
-#> 1 foo_R7(x)    5.71µs   8.26µs   120994.        0B     12.1
-#> 2 foo_s3(x)    3.79µs   4.25µs   223514.        0B     22.4
-#> 3 foo_s4(x)       4µs   4.42µs   218990.        0B     21.9
+#> 1 foo_R7(x)    9.12µs  10.44µs    76916.        0B     15.4
+#> 2 foo_s3(x)    3.73µs   4.08µs   227596.        0B     22.8
+#> 3 foo_s4(x)    4.09µs   4.51µs   207214.        0B     20.7
 
 bar_R7 <- new_generic(""bar_R7"", c(""x"", ""y""))
 method(bar_R7, list(""text"", ""number"")) <- function(x, y) paste0(x, ""-"", y, ""-bar"")
@@ -218,8 +218,8 @@ bench::mark(bar_R7(x, y), bar_s4(x, y))
 #> # A tibble: 2 x 6
 #>   expression        min   median `itr/sec` mem_alloc `gc/sec`
 #>   <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>
-#> 1 bar_R7(x, y)  11.64µs   12.7µs    72906.        0B     21.9
-#> 2 bar_s4(x, y)   9.12µs   10.1µs    91415.        0B     18.3
+#> 1 bar_R7(x, y)  15.42µs   18.1µs    53583.        0B     26.8
+#> 2 bar_s4(x, y)   9.24µs   11.1µs    85691.        0B     17.1
 ```
 
 A potential optimization is caching based on the class names, but lookup

---FILE: man/method_call.Rd---
@@ -1,10 +1,10 @@
 % Generated by roxygen2: do not edit by hand
 % Please edit documentation in R/method.R
-\name{call_method}
-\alias{call_method}
+\name{method_call}
+\alias{method_call}
 \title{Lookup the R7 method for the current generic and call it.}
 \usage{
-call_method()
+method_call()
 }
 \description{
 Lookup the R7 method for the current generic and call it.

---FILE: src/code.c---
@@ -62,3 +62,54 @@ SEXP method_(SEXP generic, SEXP signature, SEXP ignore) {
 SEXP R7_object_() {
   return Rf_allocSExp(DOTSXP);
 }
+
+SEXP method_call_(SEXP generic, SEXP envir) {
+  int n_protect = 0;
+  static SEXP object_class_fun = NULL;
+  if (object_class_fun == NULL) {
+    SEXP ns = Rf_findVarInFrame(R_NamespaceRegistry, Rf_install(""R7""));
+    object_class_fun = Rf_findVarInFrame(ns, Rf_install(""object_class""));
+  }
+
+  SEXP gen_signature_args = Rf_getAttrib(Rf_getAttrib(generic, Rf_install(""signature"")), R_NamesSymbol);
+
+  // Every generic signature has `...` as the last arg, which we want to ignore.
+  R_xlen_t gen_signature_len = Rf_xlength(gen_signature_args) - 1;
+
+  SEXP signature_classes = PROTECT(Rf_allocVector(VECSXP, gen_signature_len));
+  ++n_protect;
+
+  SEXP prom_args = PROTECT(Rf_cons(R_NilValue, R_NilValue));
+  ++n_protect;
+  SEXP tail = prom_args;
+
+  for (R_xlen_t i = 0; i < gen_signature_len; ++i) {
+    SEXP name = Rf_install(CHAR(STRING_ELT(gen_signature_args, i)));
+    SEXP arg = Rf_findVar(name, envir);
+    if (TYPEOF(arg) == PROMSXP) {
+      SEXP new_promise = PROTECT(Rf_duplicate(arg));
+      SEXP val = PROTECT(Rf_eval(arg, envir));
+      SET_PRVALUE(new_promise, val);
+      SEXP object_class_call = PROTECT(Rf_lang2(object_class_fun, val));
+      SEXP klass = PROTECT(Rf_eval(object_class_call, envir));
+      SET_VECTOR_ELT(signature_classes, i, klass);
+      SETCDR(tail, Rf_cons(new_promise, R_NilValue));
+      UNPROTECT(4);
+    } else {
+      SETCDR(tail, Rf_cons(arg, R_NilValue));
+    }
+    tail = CDR(tail);
+  }
+  // We only need to add the dots if they exist
+  SEXP dots = Rf_findVar(R_DotsSymbol, envir);
+  if (dots != R_MissingArg) {
+    SETCDR(tail, dots);
+  }
+
+  SEXP m = method_(generic, signature_classes, R_NilValue);
+
+  SEXP res = Rf_applyClosure(R_NilValue, m, CDR(prom_args), envir, R_NilValue);
+  UNPROTECT(n_protect);
+
+  return res;
+}

---FILE: src/init.c---
@@ -5,10 +5,12 @@
 
 /* .Call calls */
 extern SEXP method_(SEXP, SEXP, SEXP);
+extern SEXP method_call_(SEXP, SEXP);
 extern SEXP R7_object_();
 
 static const R_CallMethodDef CallEntries[] = {
     {""method_"", (DL_FUNC) &method_, 3},
+    {""method_call_"", (DL_FUNC) &method_call_, 2},
     {""R7_object_"", (DL_FUNC) &R7_object_, 0},
     {NULL, NULL, 0}
 };

---FILE: tests/testthat/test-generic.R---
@@ -8,10 +8,18 @@ test_that(""normalize_signature works with unnamed character vectors"", {
   expect_equal(normalize_signature(c(""x"", ""y"")), alist(x=, y=, ...=))
 })
 
-test_that(""generics pass ... to methods, and methods can define additional arguments"", {
+test_that(""generics pass ... to methods, and methods can define additional arguments on basic types"", {
   foo <- new_generic(name = ""foo"", signature = ""x"")
   new_method(foo, ""character"", function(x, sep = ""-"") paste0(""foo"", sep, x))
 
   expect_equal(foo(""bar""), ""foo-bar"")
   expect_equal(foo(""bar"", sep = ""/""), ""foo/bar"")
 })
+
+test_that(""generics pass ... to methods, and methods can define additional arguments on R7 objects"", {
+  foo <- new_generic(name = ""foo"", signature = ""x"")
+  new_method(foo, ""text"", function(x, sep = ""-"") paste0(""foo"", sep, x))
+
+  expect_equal(foo(text(""bar"")), ""foo-bar"")
+  expect_equal(foo(text(""bar""), sep = ""/""), ""foo/bar"")
+})

---FILE: tests/testthat/test-method.R---
@@ -132,6 +132,25 @@ test_that(""new_method errors if given a length > 1 character vector"", {
   )
 })
 
+test_that(""substitute() works for single dispatch method calls like S3"", {
+  foo <- new_generic(""foo"", ""x"")
+
+  new_method(foo, ""character"", function(x) substitute(x))
+
+  bar <- ""blah""
+  expect_equal(foo(bar), as.symbol(""bar""))
+})
+
+test_that(""substitute() works for multiple dispatch method calls like S3"", {
+  foo <- new_generic(""foo"", c(""x"", ""y""))
+
+  new_method(foo, ""character"", function(x, y) c(substitute(x), substitute(y)))
+
+  bar <- ""blah""
+  baz <- ""bloo""
+  expect_equal(foo(bar, baz), c(as.symbol(""bar""), as.symbol(""baz"")))
+})
+
 test_that(""new_method works with both hard and soft dependencies"", {
   skip_on_os(""windows"")
   skip_if(quick_test())"
RConsortium,S7,41c117865e0b7e1a189f63251603090e092daa77,Jim Hester,james.f.hester@gmail.com,2021-03-09T20:11:55Z,Jim Hester,james.f.hester@gmail.com,2021-03-09T20:11:55Z,"Use a DOTSXP as the base type

avoids issues with `is.list()` and subsetting on lists",R/property.R;R/zzz.R;README.Rmd;README.md;src/code.c;src/init.c,True,True,True,False,33,30,63,"---FILE: R/property.R---
@@ -29,16 +29,6 @@ property_new <- function(name, class = NULL, getter = NULL, setter = NULL) {
 property <- function(object, name) {
   val <- property_safely(object, name)
   if (is.null(val)) {
-    prop <- properties(object)[[name]]
-    if (!is.null(prop$getter)) {
-      res <- prop$getter(object)
-      if (!is.null(prop$class) && !inherits(res, prop$class)) {
-        class <- object_class(object)
-        stop(sprintf(""%s@%s must be of type <%s>:\n- %s@%s is of type <%s>"", class@name, prop$class, class@name, prop$class), call. = FALSE)
-      }
-      return(res)
-    }
-
     class <- object_class(object)
     stop(sprintf(""Can't find property '%s' in <%s>"", name, class@name), call. = FALSE)
   }
@@ -55,19 +45,26 @@ property_safely <- function(object, name) {
     for (name in names(props)) {
       attr(object, name) <- NULL
     }
-    class(object) <- setdiff(class_names(property_safely(object_class(object), ""parent"")), ""R7_object"")
+    class(object) <- setdiff(class_names(attr(object_class(object), ""parent"", exact = TRUE)), ""R7_object"")
     object_class(object) <- NULL
     return(object)
   }
-  attr(object, name, exact = TRUE)
+  val <- attr(object, name, exact = TRUE)
+  if (is.null(val)) {
+    prop <- properties(object)[[name]]
+    if (!is.null(prop$getter)) {
+      val <- prop$getter(object)
+    }
+  }
+  val
 }
 
 properties <- function(object) {
   obj_class <- object_class(object)
   prop <- list()
   while(!is.null(obj_class)) {
-    prop <- c(obj_class@properties, prop)
-    obj_class <- property_safely(obj_class, ""parent"")
+    prop <- c(attr(obj_class, ""properties""), prop)
+    obj_class <- attr(obj_class, ""parent"", exact = TRUE)
   }
 
   prop

---FILE: R/zzz.R---
@@ -2,8 +2,12 @@
 #' @export
 R7_object <- class_new(
   name = ""R7_object"",
-  parent = character(),
-  constructor = function() list()
+  parent = NULL,
+  constructor = function() {
+     out <- .Call(R7_object_)
+     class(out) <- ""R7_object""
+     out
+  }
 )
 
 #' R7 generics and method objects

---FILE: README.Rmd---
@@ -194,14 +194,13 @@ bench::mark(bar_R7(x, y), bar_s4(x, y))
 ## Questions
 
 - Best way to support `substitute()` calls in methods? We need to evaluate the argument promises to do the dispatch, but we want to pass the un-evaluated promise to the call?
-- If a type has only properties, what is the base type? R7 currently using VECSXP, S4 uses S4SXP
-- Should we remove `method()<-`, We can't do the following
+- Should we remove `method()<-`, We can't do the following, really want to keep this syntax if possible.
   - can't use `method(""foo"")<-`
   - can't use `method(otherpkg::foo)<-`
   - can't use `method(""otherpkg::foo"")<-`
 - What should happen if you call `method_new()` on a S3 generic?
   1. Should we create a new R7 generic out of the S3 generic?
-  2. Or just register the R7 object using `registerS3method()`?
+  2. Or just register the R7 object using `registerS3method()`? ++
 
 ## Design workflow
 

---FILE: README.md---
@@ -205,9 +205,9 @@ bench::mark(foo_R7(x), foo_s3(x), foo_s4(x))
 #> # A tibble: 3 x 6
 #>   expression      min   median `itr/sec` mem_alloc `gc/sec`
 #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>
-#> 1 foo_R7(x)    6.07µs      8µs   108718.        0B     10.9
-#> 2 foo_s3(x)    4.14µs   5.13µs   188245.        0B     18.8
-#> 3 foo_s4(x)    4.62µs   5.09µs   177001.        0B     17.7
+#> 1 foo_R7(x)    5.74µs   8.62µs   117261.        0B     11.7
+#> 2 foo_s3(x)    3.83µs   4.19µs   217581.        0B     21.8
+#> 3 foo_s4(x)       4µs    4.4µs   216754.        0B     21.7
 
 
 bar_R7 <- generic_new(""bar_R7"", c(""x"", ""y""))
@@ -222,24 +222,23 @@ bench::mark(bar_R7(x, y), bar_s4(x, y))
 #> # A tibble: 2 x 6
 #>   expression        min   median `itr/sec` mem_alloc `gc/sec`
 #>   <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>
-#> 1 bar_R7(x, y)  12.14µs   15.2µs    64897.        0B     19.5
-#> 2 bar_s4(x, y)   9.76µs   11.7µs    81298.        0B     16.3
+#> 1 bar_R7(x, y)  11.62µs   12.7µs    74092.        0B     22.2
+#> 2 bar_s4(x, y)   9.79µs   10.8µs    79660.        0B     15.9
 ```
 
 ## Questions
 
   - Best way to support `substitute()` calls in methods? We need to
     evaluate the argument promises to do the dispatch, but we want to
     pass the un-evaluated promise to the call?
-  - If a type has only properties, what is the base type? R7 currently
-    using VECSXP, S4 uses S4SXP
-  - Should we remove `method()<-`, We can’t do the following
+  - Should we remove `method()<-`, We can’t do the following, really
+    want to keep this syntax if possible.
       - can’t use `method(""foo"")<-`
       - can’t use `method(otherpkg::foo)<-`
       - can’t use `method(""otherpkg::foo"")<-`
   - What should happen if you call `method_new()` on a S3 generic?
     1.  Should we create a new R7 generic out of the S3 generic?
-    2.  Or just register the R7 object using `registerS3method()`?
+    2.  Or just register the R7 object using `registerS3method()`? ++
 
 ## Design workflow
 

---FILE: src/code.c---
@@ -58,3 +58,7 @@ SEXP method_(SEXP generic, SEXP signature, SEXP ignore) {
 
   return method_internal(table, signature, 0, ignore);
 }
+
+SEXP R7_object_() {
+  return Rf_allocSExp(DOTSXP);
+}

---FILE: src/init.c---
@@ -4,12 +4,12 @@
 #include <R_ext/Rdynload.h>
 
 /* .Call calls */
-extern SEXP class_names_(SEXP);
-extern SEXP object_class_(SEXP);
 extern SEXP method_(SEXP, SEXP, SEXP);
+extern SEXP R7_object_();
 
 static const R_CallMethodDef CallEntries[] = {
     {""method_"", (DL_FUNC) &method_, 3},
+    {""R7_object_"", (DL_FUNC) &R7_object_, 0},
     {NULL, NULL, 0}
 };
 "
RConsortium,S7,a0859a5faad58162a562f78af33d5af3f1447b53,Jim Hester,james.f.hester@gmail.com,2021-03-09T13:33:30Z,Jim Hester,james.f.hester@gmail.com,2021-03-09T13:33:30Z,"Harmonize error messages

Convert some errors to use more consistent style, always use <> around
class names.",R/class.R;R/method.R;R/object.R;R/property.R;R/valid.R;R/zzz.R;README.Rmd;README.md;tests/testthat/_snaps/object.md;tests/testthat/test-method.R;tests/testthat/test-property.R,True,True,True,False,46,23,69,"---FILE: R/class.R---
@@ -83,6 +83,6 @@ get_base_class <- function(name) {
     ""closure"" = ,
     ""function"" = class_new(""function"", constructor = function() function() NULL),
     ""NULL"" = class_new(""NULL"", constructor = function() NULL),
-    stop(sprintf(""invalid class '%s'"", name), call. = FALSE)
+    stop(sprintf(""Invalid class <%s>"", name), call. = FALSE)
   )
 }

---FILE: R/method.R---
@@ -32,7 +32,7 @@ method_impl <- function(generic, signature, ignore) {
   }
 
   if (is.null(out)) {
-    stop(sprintf(""No methods found for generic '%s' with classes:\n%s"", generic, paste0(""- "", names(args), "": "", vcapply(signature, paste0, collapse = "", ""), collapse = ""\n""), call. = FALSE))
+    stop(sprintf(""Can't find method for generic '%s' with arguments of type:\n%s"", generic, paste0(""- "", names(args), "": "", vcapply(signature, paste0, collapse = "", ""), collapse = ""\n""), call. = FALSE))
   }
 
   out

---FILE: R/object.R---
@@ -84,5 +84,5 @@ print.r7_class <- function(x, ...) {
   } else {
     prop_fmt <- """"
   }
-  cat(sprintf(""r7: <%s>\n%s"", object_class(x)@name, prop_fmt), sep = """")
+  cat(sprintf(""r7_class: <%s>\n%s"", object_class(x)@name, prop_fmt), sep = """")
 }

---FILE: R/property.R---
@@ -30,11 +30,11 @@ property <- function(object, name) {
     if (!is.null(prop$accessor)) {
       res <- prop$accessor(object)
       if (!is.null(prop$class) && !inherits(res, prop$class)) {
-        stop(sprintf(""%s@%s must be of type %s:\n- %s@%s is of type '%s'"", class@name, prop$class, class@name, prop$class), call. = FALSE)
+        stop(sprintf(""%s@%s must be of type <%s>:\n- %s@%s is of type <%s>"", class@name, prop$class, class@name, prop$class), call. = FALSE)
       }
       return(res)
     }
-    stop(sprintf(""`%s` objects do not have a `%s` property"", class@name, name), call. = FALSE)
+    stop(sprintf(""Can't find property '%s' in <%s>"", name, class@name), call. = FALSE)
   }
 
   val
@@ -81,7 +81,7 @@ properties <- function(object) {
     } else {
       if (length(prop[[""class""]]) > 0 &&
         !inherits(value, prop[[""class""]])) {
-        stop(sprintf(""`value` must be of class '%s':\n- `value` is of class '%s'"", prop[[""class""]][[1]], class(value)[[1]]), call. = FALSE)
+        stop(sprintf(""`value` must be of class <%s>:\n- `value` is of class <%s>"", prop[[""class""]][[1]], class(value)[[1]]), call. = FALSE)
       }
     }
 

---FILE: R/valid.R---
@@ -25,7 +25,7 @@ validate <- function(object) {
   errors <- validator(object)
 
   if (length(errors) > 0) {
-    msg <- sprintf(""invalid '%s' object:\n%s"", property(obj_class, ""name""), paste0(""- "", errors, collapse = ""\n""))
+    msg <- sprintf(""Invalid <%s> object:\n%s"", obj_class@name, paste0(""- "", errors, collapse = ""\n""))
     stop(msg, call. = FALSE)
   }
 

---FILE: R/zzz.R---
@@ -48,7 +48,7 @@ class_union <- class_new(
   validator = function(x) {
     for (val in x@classes) {
       if (!inherits(val, ""r7_class"")) {
-        return(sprintf(""All classes in a `class_union` must be R7 classes:\n - '%s' is not an `r7_class`"", class(val)[[1]]))
+        return(sprintf(""All classes in a <class_union> must be R7 classes:\n - <%s> is not an <r7_class>"", class(val)[[1]]))
       }
     }
   },

---FILE: README.Rmd---
@@ -38,7 +38,7 @@ range <- class_new(""range"",
     object_new(start = start, end = end)
   },
   validator = function(x) {
-    if (property(x, ""end"") < property(x, ""start"")) {
+    if (x@end < x@start) {
       ""`end` must be greater than or equal to `start`""
     }
   },
@@ -61,6 +61,8 @@ x@end
 
 x@length
 
+x@middle
+
 # assigning properties verifies the class matches the class of the value
 x@end <- ""foo""
 
@@ -72,6 +74,13 @@ object_class(x)
 
 # As well as normal r7_objects
 x
+
+# Use `.data` to refer to and retrieve the base data type, properties are
+# automatically removed, but non-property attributes (such as names) are retained.
+
+text <- class_new(""text"", parent = ""character"", constructor = function(text) object_new(.data = text))
+
+str(text(c(foo = ""bar""))@.data)
 ```
 
 ## Generics and methods
@@ -170,6 +179,7 @@ bench::mark(bar_r7(x, y), bar_s4(x, y))
 - R7, r7 - one downside to this is why 7, if people aren't aware of RC and R6. (Though 3 + 4 = 7 is nice as well), should it be capitalized?
 - r4 - R's version of S4, released in R version 4?
 - oo - object oriented
+- oop - object oriented programming
 - moor - method based object oriented R
 - goop - generic function OOP
 - mm - multi-methods

---FILE: README.md---
@@ -28,7 +28,7 @@ range <- class_new(""range"",
     object_new(start = start, end = end)
   },
   validator = function(x) {
-    if (property(x, ""end"") < property(x, ""start"")) {
+    if (x@end < x@start) {
       ""`end` must be greater than or equal to `start`""
     }
   },
@@ -54,19 +54,22 @@ x@end
 x@length
 #> [1] 9
 
+x@middle
+#> Error: Can't find property 'middle' in <range>
+
 # assigning properties verifies the class matches the class of the value
 x@end <- ""foo""
-#> Error: `value` must be of class 'numeric':
-#> - `value` is of class 'character'
+#> Error: `value` must be of class <numeric>:
+#> - `value` is of class <character>
 
 # assigning properties runs the validator
 x@end <- 0
-#> Error: invalid 'range' object:
+#> Error: invalid <range> object:
 #> - `end` must be greater than or equal to `start`
 
 # Print methods for both r7_class objects
 object_class(x)
-#> r7: <range>
+#> r7_class: <range>
 #> | start:  <numeric>
 #> | end:    <numeric>
 #> | length: <numeric>
@@ -77,6 +80,15 @@ x
 #> | start:   1
 #> | end:    10
 #> | length:  9
+
+# Use `.data` to refer to and retrieve the base data type, properties are
+# automatically removed, but non-property attributes (such as names) are retained.
+
+text <- class_new(""text"", parent = ""character"", constructor = function(text) object_new(.data = text))
+
+str(text(c(foo = ""bar""))@.data)
+#>  Named chr ""bar""
+#>  - attr(*, ""names"")= chr ""foo""
 ```
 
 ## Generics and methods
@@ -159,9 +171,9 @@ bench::mark(foo_r7(x), foo_s3(x), foo_s4(x))
 #> # A tibble: 3 x 6
 #>   expression      min   median `itr/sec` mem_alloc `gc/sec`
 #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>
-#> 1 foo_r7(x)    5.89µs    7.6µs   129073.        0B     77.5
-#> 2 foo_s3(x)    3.91µs   4.33µs   176389.        0B     17.6
-#> 3 foo_s4(x)    4.15µs   4.62µs   198141.        0B      0
+#> 1 foo_r7(x)    5.59µs   8.28µs   120901.        0B     12.1
+#> 2 foo_s3(x)    3.85µs   4.25µs   217100.        0B     21.7
+#> 3 foo_s4(x)    3.87µs    4.3µs   213849.        0B      0
 
 
 bar_r7 <- generic_new(""bar_r7"", c(""x"", ""y""))
@@ -176,8 +188,8 @@ bench::mark(bar_r7(x, y), bar_s4(x, y))
 #> # A tibble: 2 x 6
 #>   expression        min   median `itr/sec` mem_alloc `gc/sec`
 #>   <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>
-#> 1 bar_r7(x, y)  11.21µs  12.65µs    75203.        0B    15.0 
-#> 2 bar_s4(x, y)   9.05µs   9.93µs    97095.        0B     9.71
+#> 1 bar_r7(x, y)  11.47µs  12.64µs    72994.        0B     21.9
+#> 2 bar_s4(x, y)   9.13µs   9.95µs    96303.        0B     19.3
 ```
 
 ## Questions
@@ -201,6 +213,7 @@ bench::mark(bar_r7(x, y), bar_s4(x, y))
     capitalized?
   - r4 - R’s version of S4, released in R version 4?
   - oo - object oriented
+  - oop - object oriented programming
   - moor - method based object oriented R
   - goop - generic function OOP
   - mm - multi-methods

---FILE: tests/testthat/_snaps/object.md---
@@ -13,7 +13,7 @@
     Code
       range
     Output
-      r7: <range>
+      r7_class: <range>
       | start:  <numeric>
       | end:    <numeric>
       | length: <numeric>

---FILE: tests/testthat/test-method.R---
@@ -10,7 +10,7 @@ test_that(""method errors if no method is defined for that class"", {
 
   expect_error(
     method(foo, list(""blah"")),
-    ""No methods found for generic 'foo'""
+    ""Can't find method for generic 'foo'""
   )
 })
 

---FILE: tests/testthat/test-property.R---
@@ -6,7 +6,7 @@ describe(""property"", {
   })
   it(""does not use partial matching"", {
     x <- range(1, 10)
-    expect_error(property(x, ""st""), ""`range` objects do not have a `st` property"")
+    expect_error(property(x, ""st""), ""Can't find property 'st' in <range>"")
   })
   it(""retrieves .data"", {
     x <- text(""hi"")
@@ -49,7 +49,7 @@ describe(""@"", {
   })
   it(""does not use partial matching"", {
     x <- range(1, 10)
-    expect_error(x@st, ""`range` objects do not have a `st` property"")
+    expect_error(x@st, ""Can't find property 'st' in <range>"")
   })
   it(""falls back to `base::@` for non-R7 objects"", {
     x <- ""foo"""
RConsortium,S7,308049d0eb1320aa0e4b5ed701a880ba7eaa4240,Jim Hester,james.f.hester@gmail.com,2021-03-08T16:31:34Z,Jim Hester,james.f.hester@gmail.com,2021-03-08T16:31:34Z,Fix accessor properties and printing of objects with properties,R/property.R;R/zzz.R;README.Rmd;README.md;tests/testthat/_snaps/object.md;tests/testthat/helper.R,True,True,True,False,47,29,76,"---FILE: R/property.R---
@@ -5,10 +5,6 @@
 #' @param accessor The accessor use to retrieve the property (if any)
 #' @export
 property_new <- function(name, class = NULL, accessor = NULL) {
-  if (!is.null(accessor) && is.null(class)) {
-    class <- ""function""
-  }
-
   out <- list(name = name, class = class, accessor = accessor)
   class(out) <- ""r7_property""
 
@@ -29,11 +25,16 @@ property <- function(object, name) {
   val <- property_safely(object, name)
   if (is.null(val)) {
     class <- object_class(object)
-    stop(sprintf(""`%s` objects do not have a `%s` property"", class@name, name), call. = FALSE)
-  }
 
-  if (inherits(val, ""r7_accessor"")) {
-    return(val(object))
+    prop <- class@properties[[name]]
+    if (!is.null(prop$accessor)) {
+      res <- prop$accessor(object)
+      if (!is.null(prop$class) && !inherits(res, prop$class)) {
+        stop(sprintf(""%s@%s must be of type %s:\n- %s@%s is of type '%s'"", class@name, prop$class, class@name, prop$class), call. = FALSE)
+      }
+      return(res)
+    }
+    stop(sprintf(""`%s` objects do not have a `%s` property"", class@name, name), call. = FALSE)
   }
 
   val
@@ -52,11 +53,7 @@ property_safely <- function(object, name) {
     object_class(object) <- NULL
     return(object)
   }
-  val <- attr(object, name, exact = TRUE)
-  if (is.null(val)) {
-    return(NULL)
-  }
-  val
+  attr(object, name, exact = TRUE)
 }
 
 properties <- function(object) {
@@ -133,7 +130,7 @@ as_properties <- function(x) {
     stop(""`x` must be a list of 'r7_property' objects or named characters"", call. = FALSE)
   }
 
-  x[named_chars] <- mapply(property_new, name = x[named_chars], class = x[named_chars], USE.NAMES = TRUE, SIMPLIFY = FALSE)
+  x[named_chars] <- mapply(property_new, name = names(x)[named_chars], class = x[named_chars], USE.NAMES = TRUE, SIMPLIFY = FALSE)
 
   names(x)[!named_chars] <- vcapply(x[!named_chars], function(x) x[[""name""]])
 

---FILE: R/zzz.R---
@@ -64,8 +64,6 @@ class_union <- class_new(
   }
 )
 
-accessor <- class_new(""accessor"", parent = ""function"", constructor = function(fun) object_new(.data = fun))
-
 global_variables(c(""name"", ""parent"", ""properties"", ""constructor"", ""validator""))
 
 .onAttach <- function(libname, pkgname) {

---FILE: README.Rmd---
@@ -52,6 +52,7 @@ range <- class_new(""range"",
     end = ""numeric"",
     property_new(
       name = ""length"",
+      class = ""numeric"",
       accessor = function(x) x@end - x@start
     )
   )
@@ -63,13 +64,17 @@ x@start
 
 x@end
 
+x@length
+
 # assigning properties verifies the class
 x@end <- ""foo""
 
 # assigning properties runs the validator
 x@end <- 0
 
 object_class(x)
+
+x
 ```
 
 ## Performance

---FILE: README.md---
@@ -44,6 +44,7 @@ range <- class_new(""range"",
     end = ""numeric"",
     property_new(
       name = ""length"",
+      class = ""numeric"",
       accessor = function(x) x@end - x@start
     )
   )
@@ -57,6 +58,9 @@ x@start
 x@end
 #> [1] 10
 
+x@length
+#> [1] 9
+
 # assigning properties verifies the class
 x@end <- ""foo""
 #> Error: `value` must be of class 'numeric':
@@ -69,9 +73,15 @@ x@end <- 0
 
 object_class(x)
 #> r7: <range>
-#> | start:   <numeric>
-#> | end:     <numeric>
-#> | length: <function>
+#> | start:  <numeric>
+#> | end:    <numeric>
+#> | length: <numeric>
+
+x
+#> r7: <range>
+#> | start:   1
+#> | end:    10
+#> | length:  9
 ```
 
 ## Performance
@@ -126,9 +136,9 @@ bench::mark(foo_r7(x), foo_s3(x), foo_s4(x))
 #> # A tibble: 3 x 6
 #>   expression      min   median `itr/sec` mem_alloc `gc/sec`
 #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>
-#> 1 foo_r7(x)    5.62µs   7.86µs   127777.    43.8KB     76.7
-#> 2 foo_s3(x)     3.8µs   4.21µs   173228.        0B     17.3
-#> 3 foo_s4(x)    4.07µs   4.51µs   211767.        0B      0
+#> 1 foo_r7(x)    5.89µs   7.57µs   132083.    45.6KB     66.1
+#> 2 foo_s3(x)    3.74µs   4.08µs   187342.        0B     18.7
+#> 3 foo_s4(x)    3.94µs   4.36µs   208469.        0B      0
 
 
 bar_r7 <- generic_new(""bar_r7"", c(""x"", ""y""))
@@ -143,8 +153,8 @@ bench::mark(bar_r7(x, y), bar_s4(x, y))
 #> # A tibble: 2 x 6
 #>   expression        min   median `itr/sec` mem_alloc `gc/sec`
 #>   <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>
-#> 1 bar_r7(x, y)  11.59µs   12.5µs    76225.        0B    15.2 
-#> 2 bar_s4(x, y)   9.14µs   10.1µs    92044.        0B     9.21
+#> 1 bar_r7(x, y)  11.52µs  12.63µs    75320.        0B     15.1
+#> 2 bar_s4(x, y)   8.94µs   9.82µs    97063.        0B     19.4
 ```
 
 ## TODO

---FILE: tests/testthat/_snaps/object.md---
@@ -14,7 +14,7 @@
       range
     Output
       r7: <range>
-      | start:   <numeric>
-      | end:     <numeric>
-      | length: <function>
+      | start:  <numeric>
+      | end:    <numeric>
+      | length: <numeric>
 

---FILE: tests/testthat/helper.R---
@@ -3,14 +3,22 @@ number <- class_new(""number"", parent = ""numeric"", constructor = function(x) obje
 
 range <- class_new(""range"",
   constructor = function(start, end) {
-    object_new(start = start, end = end, length = accessor(function(x) x@end - x@start))
+    object_new(start = start, end = end)
   },
   validator = function(x) {
     if (property(x, ""end"") < property(x, ""start"")) {
       ""`end` must be greater than or equal to `start`""
     }
   },
-  properties = list(start = ""numeric"", end = ""numeric"", property_new(name = ""length"", accessor = function(x) x@end - x@start))
+  properties = list(
+    start = ""numeric"",
+    end = ""numeric"",
+    property_new(
+      name = ""length"",
+      class = ""numeric"",
+      accessor = function(x) x@end - x@start
+    )
+  )
 )
 
 quick_install <- function(package) {"
RConsortium,S7,e9108a95642a9dd83d0eab6ba48cb836a2606c97,Jim Hester,james.f.hester@gmail.com,2021-03-04T14:34:33Z,Jim Hester,james.f.hester@gmail.com,2021-03-04T14:36:12Z,Fix check notes,DESCRIPTION;NAMESPACE;R/method.R;man/method_next.Rd,False,True,True,False,17,0,17,"---FILE: DESCRIPTION---
@@ -33,6 +33,8 @@ Description: Prototype implementation of an extension to S3 that
     Represents the output of the Object-oriented Programming Working
     Group, sponsored by the R Consortium.
 License: MIT + file LICENSE
+Imports:
+    utils
 Suggests: 
     methods,
     covr,

---FILE: NAMESPACE---
@@ -13,6 +13,7 @@ export(class_union)
 export(generic_generate)
 export(generic_new)
 export(method)
+export(method_next)
 export(method_register)
 export(object_class)
 export(object_new)
@@ -24,4 +25,5 @@ export(r7_method)
 export(r7_object)
 export(valid_eventually)
 export(valid_implicitly)
+importFrom(utils,getS3method)
 useDynLib(R7, .registration = TRUE)

---FILE: R/method.R---
@@ -3,6 +3,7 @@
 #' @param generic The generic to retrieve or register
 #' @param signature The method signature
 #' @param value The new function to use for the method.
+#' @importFrom utils getS3method
 #' @export
 method <- function(generic, signature) {
   # This slows down the method dispatch too much
@@ -32,6 +33,9 @@ method <- function(generic, signature) {
 
 #' Retrieve the next applicable method after the current one
 #'
+#' @inheritParams method
+#' @param previous_classes The previous method classes as a character
+#' @param previous_methods The previous methods
 #' @export
 method_next <- function(generic, signature, previous_classes = NULL, previous_methods) {
   if (length(signature) > 1) {

---FILE: man/method_next.Rd---
@@ -6,6 +6,15 @@
 \usage{
 method_next(generic, signature, previous_classes = NULL, previous_methods)
 }
+\arguments{
+\item{generic}{The generic to retrieve or register}
+
+\item{signature}{The method signature}
+
+\item{previous_classes}{The previous method classes as a character}
+
+\item{previous_methods}{The previous methods}
+}
 \description{
 Retrieve the next applicable method after the current one
 }"
RConsortium,S7,be64e787ecf9e8b0737b3ec5625a0671b3bc34c1,Jim Hester,james.f.hester@gmail.com,2021-03-02T20:16:24Z,Jim Hester,james.f.hester@gmail.com,2021-03-02T20:16:24Z,"Rename instances of obj to object

Add some error checking when registering methods",.Rbuildignore;NAMESPACE;R/class.R;R/method.R;R/object.R;R/property.R;README.Rmd;README.md;man/class_names.Rd;man/object_class.Rd;man/property.Rd;man/property_new.Rd,True,True,True,False,145,88,233,"---FILE: .Rbuildignore---
@@ -8,3 +8,4 @@
 ^codecov\.yml$
 ^README\.Rmd$
 ^script\.R$
+^README_cache$

---FILE: NAMESPACE---
@@ -17,6 +17,7 @@ export(method_register)
 export(object_class)
 export(object_new)
 export(property)
+export(property_new)
 export(property_safely)
 export(r7_generic)
 export(r7_method)

---FILE: R/class.R---
@@ -2,16 +2,16 @@ r7_class <- function(name, parent = r7_object, constructor = function(...) objec
   if (is.character(parent)) {
     parent <- class_get(parent)
   }
-  obj <- constructor
-  attr(obj, ""name"") <- name
-  attr(obj, ""parent"") <- parent
-  attr(obj, ""properties"") <- as_properties(properties)
-  attr(obj, ""constructor"") <- constructor
-  attr(obj, ""validator"") <- validator
-  class(obj) <- c(""r7_class"", ""r7_object"")
+  object <- constructor
+  attr(object, ""name"") <- name
+  attr(object, ""parent"") <- parent
+  attr(object, ""properties"") <- as_properties(properties)
+  attr(object, ""constructor"") <- constructor
+  attr(object, ""validator"") <- validator
+  class(object) <- c(""r7_class"", ""r7_object"")
 
   global_variables(names(properties))
-  obj
+  object
 }
 
 #' Define a new R7 class
@@ -29,11 +29,11 @@ class_new <- function(name, parent = r7_object, constructor = function(...) obje
 
 #' Retrive all of the class names for a class
 #'
-#' @param obj The R7 object to query
+#' @param object The R7 object to query
 #' @return A character vector of all the class names for a given R7 class.
 #' @export
-class_names <- function(obj) {
-  parent <- obj
+class_names <- function(object) {
+  parent <- object
   classes <- character()
   while(!is.null(parent)) {
     if (inherits(parent, ""class_union"")) {
@@ -49,9 +49,6 @@ class_names <- function(obj) {
   }
   unique(classes, fromLast = TRUE)
 }
-#class_names <- function(obj) {
-  #.Call(class_names_, obj)
-#}
 
 #' Retrieve the r7 class corresponding to a name
 #'

---FILE: R/method.R---
@@ -5,12 +5,17 @@
 #' @param value The new function to use for the method.
 #' @export
 method <- function(generic, signature) {
+  # This slows down the method dispatch too much
+  #generic <- as_generic(generic)
+
   .Call(method_, generic, signature);
 }
 
 #' @rdname method
 #' @export
 method_register <- function(generic, signature, value) {
+  generic <- as_generic(generic)
+
   if (!is.character(signature) && !inherits(signature, ""list"")) {
     signature <- list(signature)
   }
@@ -48,3 +53,15 @@ method_register <- function(generic, signature, value) {
 `method<-` <- function(generic, signature, value) {
   method_register(generic, signature, value)
 }
+
+as_generic <- function(generic) {
+  if (length(generic) == 1 && is.character(generic)) {
+    generic <- match.fun(generic)
+  }
+
+  if (!inherits(generic, ""r7_generic"")) {
+    stop(""`generic` must be a 'r7_generic':\n- `generic` is a '"", class(generic)[[1]], ""'"", call. = FALSE)
+  }
+
+  generic
+}

---FILE: R/object.R---
@@ -8,56 +8,56 @@ object_new <- function(...) {
   nms <- names(args)
 
   if ("".data"" %in% nms) {
-    obj <- args[["".data""]]
+    object <- args[["".data""]]
   } else {
-    obj <- class@parent@constructor()
+    object <- class@parent@constructor()
   }
-  attr(obj, "".should_validate"") <- FALSE
+  attr(object, "".should_validate"") <- FALSE
 
-  class(obj) <- ""r7_object""
+  class(object) <- ""r7_object""
 
-  object_class(obj) <- class
+  object_class(object) <- class
 
-  props <- properties(obj)
+  props <- properties(object)
 
   to_set <- intersect(nms, names(props))
 
   for (nme in to_set) {
-    property(obj, nme) <- args[[nme]]
+    property(object, nme) <- args[[nme]]
   }
 
-  attr(obj, "".should_validate"") <- NULL
+  attr(object, "".should_validate"") <- NULL
 
-  validate(obj)
+  validate(object)
 
-  obj
+  object
 }
 
 #' Retrieve the r7 class of an object
-#' @param obj The r7 object
+#' @param object The r7 object
 #' @export
-object_class <- function(obj) {
-  if (inherits(obj, ""r7_class"")) {
-    return(obj)
+object_class <- function(object) {
+  if (inherits(object, ""r7_class"")) {
+    return(object)
   }
-  if (inherits(obj, ""r7_object"")) {
-    return(attr(obj, ""object_class""))
+  if (inherits(object, ""r7_object"")) {
+    return(attr(object, ""object_class""))
   }
-  if (isS4(obj)) {
-    return(methods::extends(class(obj)))
+  if (isS4(object)) {
+    return(methods::extends(class(object)))
   }
 
-  class(obj)
+  class(object)
 }
 
-`object_class<-` <- function(obj, value) {
-  attr(obj, ""object_class"") <- value
+`object_class<-` <- function(object, value) {
+  attr(object, ""object_class"") <- value
 
-  nms <- class_names(object_class(obj))
+  nms <- class_names(object_class(object))
 
-  class(obj) <- nms
+  class(object) <- nms
 
-  invisible(obj)
+  invisible(object)
 }
 
 #' @export

---FILE: R/property.R---
@@ -1,3 +1,9 @@
+#' Define a new property
+#'
+#' @param name The name of the property
+#' @param class The class of the property
+#' @param accessor The accessor use to retrieve the property (if any)
+#' @export
 property_new <- function(name, class = NULL, accessor = NULL) {
   if (!is.null(accessor) && is.null(class)) {
     class <- ""function""
@@ -14,39 +20,39 @@ property_new <- function(name, class = NULL, accessor = NULL) {
 #' - [property] or the shorthand `@` extracts a given property, throwing an error if the property doesn't exist for that object.
 #' - [property_safely] returns `NULL` if a property doesn't exist, rather than throwing an error.
 #' - [property<-] assigns a new value for a given property.
-#' @param obj An object from a R7 class
+#' @param object An object from a R7 class
 #' @param name The name of the parameter as a character. No partial matching is done.
 #' @param value A replacement value for the parameter. The object is
 #'   automatically checked for validity after the replacement is done.
 #' @export
-property <- function(obj, name) {
-  val <- property_safely(obj, name)
+property <- function(object, name) {
+  val <- property_safely(object, name)
   if (is.null(val)) {
-    class <- object_class(obj)
+    class <- object_class(object)
     stop(sprintf(""`%s` objects do not have a `%s` property"", class@name, name), call. = FALSE)
   }
 
   if (inherits(val, ""r7_accessor"")) {
-    return(val(obj))
+    return(val(object))
   }
 
   val
 }
 
 #' @rdname property
 #' @export
-property_safely <- function(obj, name) {
+property_safely <- function(object, name) {
   if (identical(name, "".data"")) {
     # Remove properties, return the rest
-    props <- properties(obj)
+    props <- properties(object)
     for (name in names(props)) {
-      attr(obj, name) <- NULL
+      attr(object, name) <- NULL
     }
-    class(obj) <- setdiff(class_names(property_safely(object_class(obj), ""parent"")), ""r7_object"")
-    object_class(obj) <- NULL
-    return(obj)
+    class(object) <- setdiff(class_names(property_safely(object_class(object), ""parent"")), ""r7_object"")
+    object_class(object) <- NULL
+    return(object)
   }
-  val <- attr(obj, name, exact = TRUE)
+  val <- attr(object, name, exact = TRUE)
   if (is.null(val)) {
     return(NULL)
   }
@@ -66,13 +72,13 @@ properties <- function(object) {
 
 #' @rdname property
 #' @export
-`property<-` <- function(obj, name, value) {
+`property<-` <- function(object, name, value) {
   if (name == "".data"") {
-    attrs <- attributes(obj)
-    obj <- value
-    attributes(obj) <- attrs
+    attrs <- attributes(object)
+    object <- value
+    attributes(object) <- attrs
   } else {
-    prop <- properties(obj)[[name]]
+    prop <- properties(object)[[name]]
     if (!is.null(prop[[""accessor""]])) {
       class(value) <- union(""r7_accessor"", class(value))
     } else {
@@ -82,37 +88,37 @@ properties <- function(object) {
       }
     }
 
-    attr(obj, name) <- value
+    attr(object, name) <- value
   }
 
-  validate(obj)
+  validate(object)
 
-  invisible(obj)
+  invisible(object)
 }
 
 #' @rdname property
-#' @usage obj@name
+#' @usage object@name
 #' @export
-`@` <- function(obj, name) {
-  if (!inherits(obj, ""r7_object"")) {
+`@` <- function(object, name) {
+  if (!inherits(object, ""r7_object"")) {
     name <- substitute(name)
-    return(do.call(base::`@`, list(obj, name)))
+    return(do.call(base::`@`, list(object, name)))
   }
 
   nme <- as.character(substitute(name))
-  property(obj, nme)
+  property(object, nme)
 }
 
 #' @rawNamespace S3method(""@<-"",r7_object)
-`@<-.r7_object` <- function(obj, name, value) {
-  if (!inherits(obj, ""r7_object"")) {
-    return(base::`@<-`(obj, name))
+`@<-.r7_object` <- function(object, name, value) {
+  if (!inherits(object, ""r7_object"")) {
+    return(base::`@<-`(object, name))
   }
 
   nme <- as.character(substitute(name))
-  property(obj, nme) <- value
+  property(object, nme) <- value
 
-  invisible(obj)
+  invisible(object)
 }
 
 as_properties <- function(x) {

---FILE: README.Rmd---
@@ -193,5 +193,10 @@ bench::mark(bar_r7(x, y), bar_s4(x, y))
   - [ ] - Generate index pages that list the methods for a generic or the methods with a particular class in their signature
 
 ## Questions
+- Best way to support `subsutitue()` calls in methods? We need to evaluate the argument promises to do the dispatch, but we want to pass the un-evaluated promise to the call?
+- on-load method registration
 - how will `method_next()` work with nested multiple dispatch? How do we know which argument you want the next method for?
 - If a type has only properties, what is the base type? R7 currently using VECSXP, S4 uses S4SXP
+- `method_register()` vs `method()<-`, the latter while nice has drawbacks
+  - can't use `method(""foo"")<-`
+  - can't use `method(otherpkg::foo)<-`

---FILE: README.md---
@@ -48,26 +48,30 @@ range <- class_new(""range"",
     )
   )
 )
-#> Error in property_new(name = ""length"", accessor = function(x) x@end - : could not find function ""property_new""
 
 x <- range(start = 1, end = 10)
 
 x@start
-#> Error in do.call(base::`@`, list(obj, name)): trying to get slot ""start"" from an object of a basic class (""numeric"") with no slots
+#> [1] 1
 
 x@end
-#> Error in do.call(base::`@`, list(obj, name)): trying to get slot ""end"" from an object of a basic class (""numeric"") with no slots
+#> [1] 10
 
 # assigning properties verifies the class
 x@end <- ""foo""
-#> Error in (function (cl, name, valueClass) : 'end' is not a slot in class ""numeric""
+#> Error: `value` must be of class 'numeric':
+#> - `value` is of class 'character'
 
 # assigning properties runs the validator
 x@end <- 0
-#> Error in (function (cl, name, valueClass) : 'end' is not a slot in class ""numeric""
+#> Error: invalid 'range' object:
+#> - `end` must be greater than or equal to `start`
 
 object_class(x)
-#> [1] ""numeric""
+#> r7: <range>
+#> | start:   <numeric>
+#> | end:     <numeric>
+#> | length: <function>
 ```
 
 ## Performance
@@ -122,9 +126,9 @@ bench::mark(foo_r7(x), foo_s3(x), foo_s4(x))
 #> # A tibble: 3 x 6
 #>   expression      min   median `itr/sec` mem_alloc `gc/sec`
 #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>
-#> 1 foo_r7(x)    4.87µs   5.95µs   165301.    4.01KB     82.7
-#> 2 foo_s3(x)    3.75µs   4.21µs   185584.        0B     18.6
-#> 3 foo_s4(x)    3.96µs   4.53µs   198679.        0B      0
+#> 1 foo_r7(x)    5.45µs   6.46µs   152420.    4.01KB     76.2
+#> 2 foo_s3(x)    3.64µs   4.14µs   189881.        0B     19.0
+#> 3 foo_s4(x)    4.07µs   4.55µs   196882.        0B      0
 
 
 bar_r7 <- generic_new(""bar_r7"", c(""x"", ""y""))
@@ -139,8 +143,8 @@ bench::mark(bar_r7(x, y), bar_s4(x, y))
 #> # A tibble: 2 x 6
 #>   expression        min   median `itr/sec` mem_alloc `gc/sec`
 #>   <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>
-#> 1 bar_r7(x, y)  11.02µs   11.8µs    78953.        0B    15.8 
-#> 2 bar_s4(x, y)   9.29µs     10µs    91187.        0B     9.12
+#> 1 bar_r7(x, y)  10.72µs   12.1µs    77755.        0B     15.6
+#> 2 bar_s4(x, y)   9.25µs   10.2µs    92116.        0B     18.4
 ```
 
 ## TODO
@@ -242,7 +246,15 @@ bench::mark(bar_r7(x, y), bar_s4(x, y))
 
 ## Questions
 
+  - Best way to support `subsutitue()` calls in methods? We need to
+    evaluate the argument promises to do the dispatch, but we want to
+    pass the un-evaluated promise to the call?
+  - on-load method registration
   - how will `method_next()` work with nested multiple dispatch? How do
     we know which argument you want the next method for?
   - If a type has only properties, what is the base type? R7 currently
     using VECSXP, S4 uses S4SXP
+  - `method_register()` vs `method()<-`, the latter while nice has
+    drawbacks
+      - can’t use `method(""foo"")<-`
+      - can’t use `method(otherpkg::foo)<-`

---FILE: man/class_names.Rd---
@@ -4,10 +4,10 @@
 \alias{class_names}
 \title{Retrive all of the class names for a class}
 \usage{
-class_names(obj)
+class_names(object)
 }
 \arguments{
-\item{obj}{The R7 object to query}
+\item{object}{The R7 object to query}
 }
 \value{
 A character vector of all the class names for a given R7 class.

---FILE: man/object_class.Rd---
@@ -4,10 +4,10 @@
 \alias{object_class}
 \title{Retrieve the r7 class of an object}
 \usage{
-object_class(obj)
+object_class(object)
 }
 \arguments{
-\item{obj}{The r7 object}
+\item{object}{The r7 object}
 }
 \description{
 Retrieve the r7 class of an object

---FILE: man/property.Rd---
@@ -7,16 +7,16 @@
 \alias{@}
 \title{Extract or replace a property}
 \usage{
-property(obj, name)
+property(object, name)
 
-property_safely(obj, name)
+property_safely(object, name)
 
-property(obj, name) <- value
+property(object, name) <- value
 
-obj@name
+object@name
 }
 \arguments{
-\item{obj}{An object from a R7 class}
+\item{object}{An object from a R7 class}
 
 \item{name}{The name of the parameter as a character. No partial matching is done.}
 

---FILE: man/property_new.Rd---
@@ -0,0 +1,18 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/property.R
+\name{property_new}
+\alias{property_new}
+\title{Define a new property}
+\usage{
+property_new(name, class = NULL, accessor = NULL)
+}
+\arguments{
+\item{name}{The name of the property}
+
+\item{class}{The class of the property}
+
+\item{accessor}{The accessor use to retrieve the property (if any)}
+}
+\description{
+Define a new property
+}"
RConsortium,S7,28cf5f197f37611f671bd9e77772e59ac37bebee,Jim Hester,james.f.hester@gmail.com,2021-02-26T13:22:40Z,Jim Hester,james.f.hester@gmail.com,2021-02-26T13:22:40Z,"Avoid R CMD check warnings for property accesses

This will work as long as the class is defined in the package where it
is used. Classes defined in external packages still have the issue

Part of #58",DESCRIPTION;R/class.R;R/utils.R;R/zzz.R,False,True,True,False,19,4,23,"---FILE: DESCRIPTION---
@@ -33,9 +33,6 @@ Description: Prototype implementation of an extension to S3 that
     Represents the output of the Object-oriented Programming Working
     Group, sponsored by the R Consortium.
 License: MIT + file LICENSE
-Imports: 
-    Matrix,
-    utils
 Suggests: 
     covr,
     testthat (>= 3.0.0)

---FILE: R/class.R---
@@ -9,6 +9,8 @@ r7_class <- function(name, parent = r7_object, constructor = function(...) objec
   attr(obj, ""constructor"") <- constructor
   attr(obj, ""validator"") <- validator
   class(obj) <- c(""r7_class"", ""r7_object"")
+
+  global_variables(names(properties))
   obj
 }
 

---FILE: R/utils.R---
@@ -8,3 +8,14 @@ is_named <- function (x) {
   }
   TRUE
 }
+
+global_variables <- function(names) {
+  env <- topenv(parent.frame())
+  if (exists("".__global__"", envir = env) && bindingIsLocked("".__global__"", env = env)) {
+    get(""unlockBinding"", baseenv())("".__global__"", env = env)
+    on.exit(lockBinding("".__global__"", env = env))
+  }
+  current <- get0("".__global__"", envir = env, ifnotfound = character())
+  current <- unique(c(current, names))
+  assign("".__global__"", current, envir = env)
+}

---FILE: R/zzz.R---
@@ -63,4 +63,9 @@ class_union <- class_new(
 
 accessor <- class_new(""accessor"", parent = ""function"", constructor = function(fun) object_new(.data = fun))
 
-utils::globalVariables(c(""parent"", ""constructor"", ""name"", ""classes"", ""methods""))
+global_variables(c(""name"", ""parent"", ""properties"", ""constructor"", ""validator""))
+
+.onAttach <- function(libname, pkgname) {
+  env <- as.environment(paste0(""package:"", pkgname))
+  env[["".conflicts.OK""]] <- TRUE
+}"
RConsortium,S7,15810626bf79bbc45df49bdd0ffbf542a9d8902e,Jim Hester,james.f.hester@gmail.com,2021-02-19T21:48:24Z,Jim Hester,james.f.hester@gmail.com,2021-02-19T21:48:24Z,Fix environment lookup,R/generic.R;R/method.R;R/zzz.R;man/method.Rd;man/r7_generic.Rd,False,True,True,False,13,8,21,"---FILE: R/generic.R---
@@ -2,5 +2,5 @@
 #' @inheritParams r7_generic
 #' @export
 generic_new <- function(name, signature) {
-  r7_generic(name = name, signature)
+  r7_generic(name = name, signature, envir = parent.frame())
 }

---FILE: R/method.R---
@@ -3,6 +3,7 @@
 #' @param generic The generic to retrieve or register
 #' @param signature The method signature
 #' @param value The new function to use for the method.
+#' @param envir The environment to lookup the generic in.
 #' @export
 method <- function(generic, signature, envir = parent.frame()) {
   fun <- get(generic, envir = envir)
@@ -29,6 +30,7 @@ find_method_table <- function(classes, table) {
   #.Call(method_, generic, signature, parent.frame())
 
 #' @rdname method
+#' @param envir The environment to lookup the generic in.
 #' @export
 method_register <- function(generic, signature, value, envir = parent.frame()) {
   fun <- get(generic, envir = envir)

---FILE: R/zzz.R---
@@ -10,18 +10,19 @@ r7_object <- class_new(
 #' @param name,generic The name or generic object of the generic
 #' @param signature The signature of the generic
 #' @param fun The function of the method'
+#' @param envir The environment to lookup the generic in.
 #' @export
 r7_generic <- class_new(
   name = ""r7_generic"",
   properties = list(name = ""character"", signature = ""list""),
   parent = ""function"",
-  constructor = function(name, signature) {
+  constructor = function(name, signature, envir = parent.frame()) {
     fun <- function() NULL
     formals(fun) <- signature
     sig_call <- as.call(c(as.symbol(""list""), lapply(names(signature), function(x) { bquote(object_class(.(arg)), list(arg = as.symbol(x)))})))
     method_call <- as.call(c(as.call(c(as.symbol(""method""), name, sig_call)), lapply(names(signature), as.symbol)))
     body(fun) <- method_call
-    environment(fun) = topenv(parent.frame())
+    environment(fun) <- envir
     object_new(name = name, signature = signature, .data = fun)
   }
 )
@@ -38,5 +39,3 @@ r7_method <- class_new(
 )
 
 utils::globalVariables(c(""parent"", ""constructor"", ""name""))
-
-.r7_methods <- new.env(parent = emptyenv())

---FILE: man/method.Rd---
@@ -5,15 +5,17 @@
 \alias{method_register}
 \title{Retrieve or register an r7 method for a generic}
 \usage{
-method(generic, signature)
+method(generic, signature, envir = parent.frame())
 
-method_register(generic, signature, value)
+method_register(generic, signature, value, envir = parent.frame())
 }
 \arguments{
 \item{generic}{The generic to retrieve or register}
 
 \item{signature}{The method signature}
 
+\item{envir}{The environment to lookup the generic in.}
+
 \item{value}{The new function to use for the method.}
 }
 \description{

---FILE: man/r7_generic.Rd---
@@ -5,7 +5,7 @@
 \alias{r7_method}
 \title{r7 generics and method objects}
 \usage{
-r7_generic(name, signature)
+r7_generic(name, signature, envir = parent.frame())
 
 r7_method(generic, signature, fun)
 }
@@ -14,6 +14,8 @@ r7_method(generic, signature, fun)
 
 \item{signature}{The signature of the generic}
 
+\item{envir}{The environment to lookup the generic in.}
+
 \item{fun}{The function of the method'}
 }
 \description{"
RConsortium,S7,0ba90dba6a1ea7b0d3771dde555de7dfdb8177dc,Jim Hester,james.f.hester@gmail.com,2021-02-19T21:29:05Z,Jim Hester,james.f.hester@gmail.com,2021-02-19T21:29:20Z,"Use an alternative way to register the functions

This is unfortunately not working due to environment issues I frankly
don't understand.",R/method.R;R/zzz.R,False,True,True,False,54,4,58,"---FILE: R/method.R---
@@ -4,12 +4,60 @@
 #' @param signature The method signature
 #' @param value The new function to use for the method.
 #' @export
-method <- function(generic, signature) {
-  .Call(method_, generic, signature, parent.frame())
+method <- function(generic, signature, envir = parent.frame()) {
+  fun <- get(generic, envir = envir)
+  env <- environment(fun)
+  table <- env[["".r7_methods""]]
+  tbl <- table[[generic]]
+  while(length(signature) > 1) {
+    classes <- .Call(class_names_, signature[[1]])
+    tbl <- find_method_table(classes, tbl)
+    signature <- signature[-1]
+  }
+  classes <- .Call(class_names_, signature[[1]])
+  find_method_table(classes, tbl)
 }
 
+find_method_table <- function(classes, table) {
+  for (class in classes) {
+    val <- table[[class]]
+    if (!is.null(val)) {
+      return(val)
+    }
+  }
+}
+  #.Call(method_, generic, signature, parent.frame())
+
 #' @rdname method
 #' @export
-method_register <- function(generic, signature, value) {
-  registerS3method(generic, paste0(signature, collapse = ""-""), value, envir = parent.frame())
+method_register <- function(generic, signature, value, envir = parent.frame()) {
+  fun <- get(generic, envir = envir)
+  env <- environment(fun)
+  table <- env[["".r7_methods""]]
+  if (is.null(table)) {
+    table <- new.env(hash = TRUE, parent = emptyenv())
+    env[["".r7_methods""]] <- table
+  }
+  gen_tbl <- table[[generic]]
+  if (is.null(gen_tbl)) {
+    gen_tbl <- new.env(hash = TRUE, parent = emptyenv())
+    table[[generic]] <- gen_tbl
+  }
+
+  p_tbl <- gen_tbl
+  while (length(signature) > 1) {
+    tbl <- p_tbl[[signature[[1]]]]
+    if (is.null(tbl)) {
+      tbl <- new.env(hash = TRUE, parent = emptyenv())
+      p_tbl[[signature[[1]]]] <- tbl
+    }
+    signature <- signature[-1]
+    p_tbl <- tbl
+  }
+
+  p_tbl[[signature[[1]]]] <- value
+}
+
+blah <- function(generic) {
+  fun <- get(generic, envir = parent.frame())
 }

---FILE: R/zzz.R---
@@ -38,3 +38,5 @@ r7_method <- class_new(
 )
 
 utils::globalVariables(c(""parent"", ""constructor"", ""name""))
+
+.r7_methods <- new.env(parent = emptyenv())"
RConsortium,S7,0d3b6d7b93957eb57db881195f2fa5d4a7013839,Jim Hester,james.f.hester@gmail.com,2021-02-18T15:15:31Z,Jim Hester,james.f.hester@gmail.com,2021-02-18T15:15:31Z,Fix order of S3 classes,R/object.R,False,True,True,False,1,1,2,"---FILE: R/object.R---
@@ -39,7 +39,7 @@ class_names <- function(obj) {
   nms <- prop(obj_class, ""name"")
   parent <- prop(obj_class, ""parent"")
   while(!is.null(parent)) {
-    nms <- c(prop(parent, ""name""), nms)
+    nms <- c(nms, prop(parent, ""name""))
     parent <- prop(parent, ""parent"")
   }
   nms"
RConsortium,S7,99f40535d67288fe99e37f3a9659828e5f2df8ab,Jim Hester,james.f.hester@gmail.com,2021-02-17T21:47:35Z,Jim Hester,james.f.hester@gmail.com,2021-02-17T21:47:35Z,Fix R CMD check warnings,R/properties.R;man/prop.Rd,False,True,True,False,1,6,7,"---FILE: R/properties.R---
@@ -30,9 +30,7 @@ prop <- function(obj, name) {
   prop(obj, nme)
 }
 
-#' @rdname prop
-#' @usage obj@name <- value
-#' @export
+#' @rawNamespace S3method(""@<-"",object)
 `@<-.object` <- function(obj, name, value) {
   if (!inherits(obj, ""object"")) {
     return(base::`@<-`(obj, name))

---FILE: man/prop.Rd---
@@ -4,16 +4,13 @@
 \alias{prop}
 \alias{prop<-}
 \alias{@}
-\alias{@<-.object}
 \title{Extract or replace a property}
 \usage{
 prop(obj, name)
 
 prop(obj, name) <- value
 
 obj@name
-
-obj@name <- value
 }
 \arguments{
 \item{obj}{An object from a R7 class}"
RConsortium,S7,3476a2baa03b856a1cb591ddf0571577350e6635,Jim Hester,james.f.hester@gmail.com,2021-02-17T21:33:47Z,Jim Hester,james.f.hester@gmail.com,2021-02-17T21:33:47Z,Fix usage,R/properties.R;man/prop.Rd,False,True,True,False,4,2,6,"---FILE: R/properties.R---
@@ -19,6 +19,7 @@ prop <- function(obj, name) {
 }
 
 #' @rdname prop
+#' @usage obj@name
 #' @export
 `@` <- function(obj, name) {
   if (!inherits(obj, ""object"")) {
@@ -30,6 +31,7 @@ prop <- function(obj, name) {
 }
 
 #' @rdname prop
+#' @usage obj@name <- value
 #' @export
 `@<-.object` <- function(obj, name, value) {
   if (!inherits(obj, ""object"")) {

---FILE: man/prop.Rd---
@@ -11,9 +11,9 @@ prop(obj, name)
 
 prop(obj, name) <- value
 
-`@`(obj, name)
+obj@name
 
-\method{@}{object}(obj, name) <- value
+obj@name <- value
 }
 \arguments{
 \item{obj}{An object from a R7 class}"
RConsortium,S7,39977634bc260aaebcfb4db01907f1cb614b01d3,Hadley Wickham,h.wickham@gmail.com,2020-11-02T21:35:21Z,GitHub,noreply@github.com,2020-11-02T21:35:21Z,"Use R7 as working name (#51)

Fixes #38",spec/design.md,False,False,False,False,6,5,11,"---FILE: spec/design.md---
@@ -6,19 +6,20 @@ editor_options:
 
 # Design specification
 
-This document presents a broad overview of the system.
+This document presents a broad overview of the R7 object-oriented programming toolkit.
+(Please note that R7 is a working name and may change in the future.)
 
 ## Objects
 
-We define an object in this system as any R object with:
+We define an R7 object as any R object with:
 
 -   A class object attribute, a reference to the **class object**, and retrieved with `classObject()`.
 -   For S3 compatibility, a class attribute, a character vector of class names.
 -   Additional attributes storing **properties** defined by the class, accessible with `@`/`prop()`.
 
 ## Classes
 
-Classes are first class objects (Req2) with the following components:
+R7 classes are first class objects (Req2) with the following components:
 
 -   **Name**, a human-meaningful descriptor for the class.
     This is used for the default print method and in error messages; it does not identify the class.
@@ -90,7 +91,7 @@ For example, `c(name = ""character"", age = ""integer"")` is shorthand for `list(new
 ### Validation
 
 Objects will be validated on initialization and every time a property is modified.
-To temporarily opt-out of validation (e.g. in order to transition through a temporarily invalid state) the system provides `eventuallyValid()`:
+To temporarily opt-out of validation (e.g. in order to transition through a temporarily invalid state), R7 provides `eventuallyValid()`:
 
 ``` r
 eventuallyValid <- function(object, fun) {
@@ -115,7 +116,7 @@ move_right <- function(x, y) {
 
 This ensures that the validation will not trigger if `x@start + y` is greater than `x@end`.
 
-The system also provides `implicitlyValid()` for expert use.
+R7 also provides `implicitlyValid()` for expert use.
 This is similar to `eventuallyValid()` but does not check for validity at the end.
 This can be used in performance critical code where you can ascertain that a sequence of operations can never make an valid object invalid.
 "
RConsortium,S7,c4c0171d5c25e970f4977a8814e9ba8cc85d1041,Michael Lawrence,michafla@gene.com,2020-11-02T13:09:53Z,GitHub,noreply@github.com,2020-11-02T13:09:53Z,"Requirement from #6 (#13)

Let's allow for third party method registration, while acknowledging that it is potentially dangerous. Fixes #6.",spec/requirements.md,False,False,False,False,5,0,5,"---FILE: spec/requirements.md---
@@ -11,6 +11,7 @@ This page is for brainstorming on the technical requirements for solving our [pr
 1. Namespace management should not be any more complicated than S3 currently
 1. Performance should be competitive with existing solutions
 1. The design should be simple to implement
+1. It should be possible for a package to define a method where the generic and classes are defined outside of the package
 1. We should aim to facilitate API evolution, particularly as it relates to inter-package dependencies
 1. Methods must include all formal arguments from their generic (not like Julia)
 1. Generics should support `...` in their formal argument lists and methods can append arguments to those lists
@@ -54,6 +55,10 @@ The entire API should be free of side effects and odd conventions, like making t
 
 The system should support exporting generics and classes. If classes are objects, they can be treated like any other object when exporting and importing symbols. If generics are objects, then it should be simple to export all methods on a generic.  It is not clear whether selective method export is important. One use case would be to hide a method with an internal class in its signature to avoid unnecessary documentation. Perhaps `R CMD check` could ignore methods for unexported classes. There should be no need for explicit method registration.  
 
+## Third party methods
+
+To fully realize the potential of interoperability afforded by functional OOP, with its treating of generics and classes as orthogonal, we should allow packages to extend an externally defined API so that it supports externally defined classes. In most cases, a method should only be defined by either the owner of the generic or the owner of the class, but ""ownership"" is a somewhat nebulous concept. We acknowledge the potential for conflicts arising from multiple packages defining methods on the same generic and with overlapping signatures, as well as the danger of injecting new behaviors that violate the assumptions of existing method definitions.
+
 ## Formal arguments
 
 The formal arguments of a generic must be present in every method for that generic. This is in contrast to Julia, where methods can have completely different sets of arguments. We favor a fixed set of formal arguments for the sake of consistency and to enable calling code to depend on a minimal set of arguments that are always present. If the generic formal argument list includes `...`, then methods can add their own arguments. The extra arguments are useful for controlling specialized behaviors, as long as the calling code can assume that calling the generic will always dispatch to a method that handles them in accordance with the documentation. In accordance with the Liskov Substitution Principle, we could explore enforcing that a method only adds arguments to those of a method dispatching on a parent class. This is easiest to conceptualize and would be most useful in the single dispatch case, but we should also be able to develop a set of rules for nested multiple dispatch."
RConsortium,S7,516441fa5c75f72e8e5e1201b11b3bcf9216f3b6,Hadley Wickham,h.wickham@gmail.com,2020-10-16T13:33:38Z,GitHub,noreply@github.com,2020-10-16T13:33:38Z,"Define class unions (#46)

Fixes #31",spec/design.md,False,False,False,False,21,2,23,"---FILE: spec/design.md---
@@ -122,6 +122,25 @@ This can be used in performance critical areas where you can ascertain that a se
 (This can be quite hard: for example, in the `move_right()` example above, you might think that that if `x@start < x@end` is true at the beginning, then `x@start + y < x@end + y` will still be true at the end, and you don't need to re-validate the object.
 But that's not necessarily true: if `x@start == 1`, `x@end == 2`, and `abs(y) > 2e16` then `x@start + y == x@end + y`!)
 
+### Unions
+
+A class union represents a list of possible classes.
+It is used in properties to allow a property to be one of a set of classes, and in method dispatch as a convenience for defining a method for multiple classes.
+
+``` {.r}
+ClassUnion <- defineClass(""ClassUnion"", 
+  properties = list(classes = ""list""),
+  validator = function(x) {
+    # Checks that all elements of classes are Class object
+  },
+  constructor = function(...) {
+    classes <- list(...)
+    # look up Class object from any class vectors
+    newObject(classes = classes)
+  }
+)
+```
+
 ## Properties
 
 A property is an encapsulated component of the object state that is publicly accessible via a simple syntax.
@@ -135,7 +154,7 @@ There will be built-in support for emitting deprecation messages.
 Every property definition has a:
 
 -   A **name**, used to label output for humans.
--   An optional **class**
+-   An optional **class** (or class union**)**.
 -   An optional **accessor** function that overrides getting and setting, much like an active binding (by default, the value is stored as attribute, like S3/S4).
 
 Property objects are created by `newProperty()`:
@@ -186,7 +205,7 @@ method(generic, signature) <- function(x, ...) {}
 
 -   `generic` is a generic function.
 
--   `signature` is a single class object (single dispatch) or list of class objects (nested dispatch).
+-   `signature` is a single class object, a class union, list of class objects/unions, or a character vector.
 
 `method<-` performs validation ensuring that the method is compatible with the generic (i.e. all arguments before `...` have the same names in the same order; if the generic doesn't have `...` all arguments must be same).
 "
RConsortium,S7,81117b8be6c2c0d69b045bb312d63e8aa404e99c,Hadley Wickham,h.wickham@gmail.com,2020-10-16T13:21:03Z,GitHub,noreply@github.com,2020-10-16T13:21:03Z,"Describe validation and how to opt-out of it (#44)

Fixes #25",spec/design.md,False,False,False,False,34,0,34,"---FILE: spec/design.md---
@@ -89,6 +89,40 @@ For example, `c(name = ""character"", age = ""integer"")` is shorthand for `list(new
 
 ### Validation
 
+Objects will be validated on construction and every time a property is modified.
+To temporarily opt-out of validation (e.g. when you need to transition through a temporarily invalid state) the system will provide `eventuallyValid()`:
+
+``` {.r}
+eventuallyValid <- function(object, fun) {
+  object$internal_validation_flag <- FALSE
+  out <- fun(object)
+  out$internal_validation_flag <- TRUE
+  validate(out)
+}
+```
+
+For example, if you wanted to move a Range object to the right, you could write:
+
+``` {.r}
+move_right <- function(x, y) {
+  eventuallyValid(x, function(x) {
+    x@start <- x@start + y
+    x@end <- x@end + y
+    x
+  })
+}
+```
+
+This ensures that the validation will not trigger if `x@start + y` is greater than `x@end`.
+
+The system also provides `implicitlyValid()` for expert use only.
+This is similar to `eventuallyValid()` but does not check for validity at the end.
+This can be used in performance critical areas where you can ascertain that a sequence of operations can never make an valid object invalid[^1].
+
+[^1]: This is generally hard.
+    For example, in the `move_right()` example above, you might think that that if `x@start < x@end` is true at the beginning, then `x@start + y < x@end + y` will still be true at the end, and you don't technically need to re-validate the object.
+    But that's actually not true: if you assume `x@start == 1` and `x@end == 2`, then `x@start + y == x@end + y` (i.e. they're equal!), as soon as `abs(y) > 2e16`, i.e. for very many values of `y`.
+
 ## Properties
 
 A property is an encapsulated component of the object state that is publicly accessible via a simple syntax."
RConsortium,S7,84e1e101ba4a21578bf507c60c7bfaa58645142b,Hadley Wickham,h.wickham@gmail.com,2020-10-07T16:48:45Z,Hadley Wickham,h.wickham@gmail.com,2020-10-07T16:48:45Z,"Tweak newClass() arguments

Fixes #47",spec/design.md,False,False,False,False,4,4,8,"---FILE: spec/design.md---
@@ -41,9 +41,9 @@ Each component corresponds to an argument in `newClass()`:
 ``` r
 newClass(
   name, 
-  parent = object, 
+  parent = Object, 
   constructor = function(...) newObject(...), 
-  validity = function(object) NULL,
+  validator = function(x) NULL,
   properties = list()
 )
 ```
@@ -57,8 +57,8 @@ Range <- newClass(""Range"",
     stopifnot(is.numeric(start), is.numeric(end), end >= start)
     newObject(start = start, end = end)
   },
-  validity = function(object) {
-    if (end < start) {
+  validator = function(x) {
+    if (x@end < x@start) {
       ""end must be greater than or equal to start""
     }
   }, "
RConsortium,S7,de4e43ea1e5d00498533e31916a2a2a310c1dd0a,Hadley Wickham,h.wickham@gmail.com,2020-10-07T12:05:05Z,Hadley Wickham,h.wickham@gmail.com,2020-10-07T12:05:05Z,"Remove property defaults

Fixes #43",spec/design.md,False,False,False,False,0,2,2,"---FILE: spec/design.md---
@@ -96,7 +96,6 @@ Every property definition has a:
 
 -   A **name**, used to label output for humans.
 -   An optional **class**
--   A **default value** that is (itself defaulting to the value class prototype)
 -   An optional **accessor** function that overrides getting and setting, much like an active binding (by default, the value is stored as attribute, like S3/S4).
 
 Property objects are created by `defineProperty()`:
@@ -105,7 +104,6 @@ Property objects are created by `defineProperty()`:
 newProperty(
   name, 
   class = NULL, 
-  default = NULL, 
   accessor = NULL
 )
 ```"
RConsortium,S7,84119df78471265ced0c8c8d07e875347a68b9c3,Hadley Wickham,h.wickham@gmail.com,2020-10-06T19:43:32Z,GitHub,noreply@github.com,2020-10-06T19:43:32Z,"Update method definition (#35)

* Update method definition. Fixes #29
* Add note about best practices. Fixes #6",spec/design.md,False,False,False,False,19,14,33,"---FILE: spec/design.md---
@@ -250,26 +250,31 @@ MyClass <- Class(slot1 := integer,
 
 ### Methods
 
-Assign the method into the generic, as a member of its dispatch table:
+Methods are defined by calling `method<-(generic, signature, method)`:
 
-```{R}
-generic$Class <- function(x) { }
+```
+method(generic, signature) <- function(x, ...) {} 
 ```
 
-In the above, `Class` would be looked up by name in the parent
-frame. A safer and slightly more verbose syntax, which passes the
-actual class object:
+* `generic` is either a function or a string representing the name of a
+  function which is looked up in the calling frame.
+  
+* `signature` is a single class object, list of class objects, or a 
+  character vector. If a character vector is supplied, class objects
+  are searched for in the calling frame.
 
-```{R}
-generic[[classObject]] <- function(x) { }
-```
+`method<-` will perform method validation ensuring that the method is compatible with the generic (i.e. all arguments before `...` have the same names in the same order; if the generic doesn't have `...` all arguments must be same). 
 
-For multiple (nested) dispatch:
-```{R}
-generic[[classObject1]][[classObject2]] <- function(x) { }
-```
+Documentation will discuss the risks of defining a method when you don't own either the generic or the class.
+
+`method<-` is designed to work at run-time (not just package build-time) so that methods can be defined when suggested packages are loaded later:
 
-Methods are looked up in the same way (incorporating inheritance).
+```
+whenLoaded(""pkg"", {
+  method(mean, pkg::A) <- function() 10
+  method(sum, pkg::A) <- function() 5
+})
+```
 
 # Compatibility
 "
RConsortium,S7,59a9b89d428996e06470bce6d281c929f99c62f6,Hadley Wickham,h.wickham@gmail.com,2020-10-05T14:07:54Z,Hadley Wickham,h.wickham@gmail.com,2020-10-05T14:07:54Z,Fix prop defintion,spec/design.md,False,False,False,False,1,1,2,"---FILE: spec/design.md---
@@ -89,7 +89,7 @@ way that is compatible with S4. The `prop()` function could be
 implemented as:
 ```{R}
      function(x, name) {
-         properties(classObject(x))[[name]](x)
+         properties(classObject(x))[[name]]
      }
 ```
 "
RConsortium,S7,1826f88311bf72bbc72e087ce4aa53845f9cb298,Hadley Wickham,h.wickham@gmail.com,2020-09-22T12:37:01Z,Hadley Wickham,h.wickham@gmail.com,2020-09-22T12:37:01Z,"Use newObject() to construct objects

Fixes #26",spec/design.md,False,False,False,False,6,7,13,"---FILE: spec/design.md---
@@ -19,19 +19,18 @@ with the following components:
 - Property list
 - Validator
 - Constructor
-- Initializer (not user defined, called by constructor)
 
 The class object inherits from function and acts as a constructor of
 instances of the class. The class definer implements the constructor,
-which takes a custom set of arguments and ultimately delegates to
-`Class@new()`, which accepts any parent instance and property values
-and returns an instance of the class so initialized. 
+which takes a custom set of arguments and calls `newObject()` to create
+the object.
 
 For example, a constructor a `Range` class might look like:
+
 ```{R}
 function(start, end) {
     stopifnot(is.numeric(start), is.numeric(end), end >= start)
-    Range@new(start=start, end=end)
+    newObject(start = start, end = end)
 }
 ```
 
@@ -168,7 +167,7 @@ where:
  - `name` is the name of the class
  - `parent` is the class object for the parent class
  - `constructor` is an arbitrary function that typically ends with a
-   call to `Class@new()`
+   call to `newObject()`
  - `validity` a function that takes the object and returns a vector of
    error messages, or `NULL` (like the methods package)
  - `properties` is either:
@@ -186,7 +185,7 @@ Range <- defineClass(""Range"",
   Vector, 
   function(start, end) {
     stopifnot(is.numeric(start), is.numeric(end), end >= start)
-    Range@new(start = start, end = end)
+    newObject(start = start, end = end)
   }, 
   validity = function(object) {
     if (end < start) {"
RConsortium,S7,ab0d7e8a82f2c03e924c9e572d668eedea526449,Michael Lawrence,michafla@gene.com,2020-09-21T12:33:37Z,Michael Lawrence,michafla@gene.com,2020-09-21T12:33:37Z,"clarify the separation of initialization and validation, fixes #17",spec/design.md,False,False,False,False,10,3,13,"---FILE: spec/design.md---
@@ -45,9 +45,16 @@ Initializing an instance of a class will:
 
 The first two steps would be very similar to calling `structure()`,
 except it would initialize property values through the property system
-(see below). We could allow the user to override the first two steps,
-as one would in the methods package by defining a method on
-`initialize()`.
+(see below). 
+
+The second step, merging property values, is also useful for updating
+an object (immutably, so returning a new object). This corresponds to
+the `methods::initialize()`, which also runs the validator. We would
+separate the (re)initialization from validation. This would allow the
+developer to update the object in controlled situations without
+triggering potentially expensive or redundant validation. If we
+implement initialization through a generic, the developer can
+override it for a particular class.
 
 ### Property
 "
RConsortium,S7,fd8eba4adcf14d0d1b0da10eeb46e9c8ffa39542,Michael Lawrence,michafla@gene.com,2020-09-21T12:22:00Z,Michael Lawrence,michafla@gene.com,2020-09-21T12:22:00Z,"add validator to class definition, fixes #18",spec/design.md,False,False,False,False,1,0,1,"---FILE: spec/design.md---
@@ -19,6 +19,7 @@ with the following components:
 - Method list
   - We are able to assign methods to a class, because we assume single
     and nested (requirement #5) dispatch.
+- Validator
 - Constructor
 - Initializer (not user defined, called by constructor)
 "
RConsortium,S7,81ccb60683ea0ba909e2a060972b53bcb5771c41,Michael Lawrence,michafla@gene.com,2020-09-21T11:50:32Z,Michael Lawrence,michafla@gene.com,2020-09-21T11:50:32Z,"clarify definition of constructor and properties, fixes #24",spec/design.md,False,False,False,False,41,8,49,"---FILE: spec/design.md---
@@ -19,7 +19,8 @@ with the following components:
 - Method list
   - We are able to assign methods to a class, because we assume single
     and nested (requirement #5) dispatch.
-- Initializer
+- Constructor
+- Initializer (not user defined, called by constructor)
 
 The class object inherits from function and acts as a constructor of
 instances of the class. The class definer implements the constructor,
@@ -146,22 +147,54 @@ Calling `defineClass()` defines a new class. Its signature:
 ```{R}
 defineClass <- function(name, parent = object, constructor, init = structure,
                         validity = function(object) { },
-                        slots = NULL)
+                        properties = list())
 ```
 
+where:
+ - `name` is the name of the class
+ - `parent` is the class object for the parent class
+ - `constructor` is an arbitrary function that typically ends with a
+   call to `Class@new()`
+ - `validity` a function that takes the object and returns a vector of
+   error messages, or `NULL` (like the methods package)
+ - `properties` is either:
+   - a character vector mapping property names to types 
+     (converted into Property objects that store their values in attributes) 
+   - or a list of Property objects
+
+The return value is `constructor`, except it is an instance of class
+`Class`, which defines properties that describe the rest of the class.
+
 Example:
 ```{R}
-Child <- defineClass(""Child"", Parent, function(object, ...) {
-    structure(object, ...)
+Child <- defineClass(""Range"", Vector, function(start, end) {
+    stopifnot(is.numeric(start), is.numeric(end), end >= start)
+    Range@new(start=start, end=end)
 }, validity = function(object) {
-    if (object@slot2 >= object@slot1)
-        ""slot2 must be less than slot1""
-}, slots = c(slot1 = ""integer"", slot2 = ""integer""))
+    if (end < start)
+        ""end must be greater than or equal to start""
+}, properties = c(start = ""numeric"", end = ""numeric""))
+```
+
+### Properties
+
+Calling `defineProperty()` define a new property. It has the
+signature:
+```{R}
+function(name, class, default, accessor)
 ```
 
+where:
+ - `name` is the name of the property,
+ - `class` is the class object for the property value,
+ - `default` is the default value of the property on new instances,
+ - `accessor` is a function that gets and sets the property value,
+   such as through attributes on the object, and behaves similar to an
+   active binding function.
+
 ### Generics
 
-Calling `defineGeneric()` defines a new generic, with signature:
+Calling `defineGeneric()` defines a new generic. It has the signature:
 ```{R}
 function(name, FUN, signature) { }
 ```"
RConsortium,S7,a3a5655dc71b837fc75ac948ff348fbfb4a2fe3a,Hadley Wickham,h.wickham@gmail.com,2020-07-20T15:31:59Z,Hadley Wickham,h.wickham@gmail.com,2020-07-20T15:31:59Z,"Reflection and dynamism.

Fixes #3. Fixes #5",spec/requirements.md,False,False,False,False,13,0,13,"---FILE: spec/requirements.md---
@@ -10,6 +10,7 @@ This page is for brainstorming on the technical requirements for solving our [pr
 1. Namespace management should not be any more complicated than S3 currently
 1. Performance should be competitive with existing solutions
 1. The design should be simple to implement
+1. The system should support reflection
 
 ## Compatibility
 
@@ -43,3 +44,15 @@ Ideally the entire API could be free of side effects and odd conventions, like m
 
 The system should support exporting generics and classes. If classes are objects, they can be treated like any other object when exporting and importing symbols. If generics are objects, then it should be simple to export all methods on a generic.  It is not clear whether selective method export is important. One use case would be to hide a method with an internal class in its signature to avoid unnecessary documentation. Perhaps `R CMD check` could ignore methods for unexported classes. There should be no need for explicit method registration.  
 
+## Reflection and dynamism
+
+Given a class and a generic, you should be able to find the appropriate method without calling it. This is important for building tooling around the system.
+
+On the flip side, you should also be able to register a method dynamically at run-time. This is important for:
+
+* testing, particularly for doing mocking at the method level. 
+* generics in suggested packages, so method registration can occur when that
+  package is loaded.
+* interface evolution, so you can provide a method for a generic that does not
+  yet exist, in anticipation of a future release.
+"
