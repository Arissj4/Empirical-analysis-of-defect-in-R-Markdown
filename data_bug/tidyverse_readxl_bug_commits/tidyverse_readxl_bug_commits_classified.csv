repo_owner,repo_name,commit_hash,author,author_email,date,committer_name,committer_email,committer_date,message,filenames,touches_rmd,touches_r,touches_r_or_rmd,is_merge,added,deleted,changed,diff,_touch_r,_touch_rmd,bug_category,category_score
tidyverse,readxl,e090951f2b8065e1b82d8dfa0f071ae9e7c9c8c1,Matthew Adams,106356536+twopatek@users.noreply.github.com,2025-09-19T16:17:04Z,GitHub,noreply@github.com,2025-09-19T16:17:04Z,Fixes Tidyverse ReadXl#642 (#780),vignettes/articles/readxl-workflows.Rmd,True,False,True,False,4,4,8,"---FILE: vignettes/articles/readxl-workflows.Rmd---
@@ -56,7 +56,7 @@ mtcars_xl <- readxl_example(""datasets.xlsx"") |>
 delete_on_exit <- c(delete_on_exit, ""mtcars-raw.csv"")
 ```
 
-Why does this work? `readr::write_csv()` is a well-mannered ""write"" function: it does its main job *and returns its input invisibly*. The above command reads the iris sheet from readxl's `datasets.xlsx` example workbook and caches a CSV version of the resulting data frame to file.
+Why does this work? `readr::write_csv()` is a well-mannered ""write"" function: it does its main job *and returns its input invisibly*. The above command reads the mtcars sheet from readxl's `datasets.xlsx` example workbook and caches a CSV version of the resulting data frame to file.
 
 Let's check. Did we still import the data? Did we write the CSV file?
 
@@ -75,7 +75,7 @@ attr(mtcars_alt, ""spec"") <- NULL
 identical(mtcars_xl, mtcars_alt)
 ```
 
-Yes! If we needed to restart or troubleshoot this fictional analysis, `iris-raw.csv` is available as a second, highly accessible alternative to `datasets.xlsx`.
+Yes! If we needed to restart or troubleshoot this fictional analysis, `mtcars-raw.csv` is available as a second, highly accessible alternative to `datasets.xlsx`.
 
 ## Iterate over multiple worksheets in a workbook
 
@@ -194,9 +194,9 @@ Rework examples from above but using base R only, other than readxl.
 
 ```{r eval = FALSE}
 mtcars_xl <- read_excel(readxl_example(""datasets.xlsx""), sheet = ""mtcars"")
-write.csv(iris_xl, ""mtcars-raw.csv"", row.names = FALSE, quote = FALSE)
+write.csv(mtcars_xl, ""mtcars-raw.csv"", row.names = FALSE, quote = FALSE)
 mtcars_alt <- read.csv(""mtcars-raw.csv"", stringsAsFactors = FALSE)
-## coerce iris_xl back to a data.frame
+## coerce mtcars_xl back to a data.frame
 identical(as.data.frame(mtcars_xl), mtcars_alt)
 ```
 ",False,True,Implementation / Logic,6
tidyverse,readxl,9e20981965f51c3d3c7102f361eba74d88970a3c,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2025-03-07T00:10:34Z,GitHub,noreply@github.com,2025-03-07T00:10:34Z,"Fix sanitizer warning (#771)

* Let's try this

* Fix out-of-bounds access in MULRK struct handling

* Take 2

In response to seeing this:

libxls/xls.c:589:23: runtime error: load of misaligned address 0x50700005cbb6 for type 'DWORD', which requires 4 byte alignment

* Move and turn into inline functions

The use of inline functions is in response to this:

Found the following significant warnings:
  libxls/xls.c:121:31: warning: ISO C forbids braced-groups within expressions [-Wpedantic]
  libxls/xls.c:126:34: warning: ISO C forbids braced-groups within expressions [-Wpedantic]

* Apply fix to another MULRK location

* Revert ""Apply fix to another MULRK location""

This reverts commit 738df8a6733f2c96df9e54dc1b762fac5257e215.

* Craft a similar fix for MULBLANK (not MULRK, oops)

* Fix for access inside LABEL

* Adopt patch strategy used in positron

* Revert whitespace changes I did not mean to make earlier

* Moar checks

* Get rid of trailing comma",.github/workflows/rhub.yaml;src/libxls/xls.c;src/libxls/xlsstruct.h,False,False,False,False,42,5,47,"---FILE: .github/workflows/rhub.yaml---
@@ -27,7 +27,7 @@ on:
       config:
         description: 'A comma separated list of R-hub platforms to use. These default choices have been customized for readxl.'
         type: string
-        default: 'gcc-asan,valgrind,rchk,gcc15'
+        default: 'gcc-asan,valgrind,rchk,gcc15,clang-asan,clang-ubsan'
       name:
         description: 'Run name. You can leave this empty now.'
         type: string

---FILE: src/libxls/xls.c---
@@ -478,7 +478,10 @@ int xls_isCellTooSmall(xlsWorkBook* pWB, BOF* bof, BYTE* buf) {
         if (bof->size < offsetof(LABEL, value) + 2)
             return 1;
 
-        size_t label_len = ((LABEL*)buf)->value[0] + (((LABEL*)buf)->value[1] << 8);
+        // --- Start readxl ---
+        BYTE *value = get_LABEL_value((LABEL*)buf);
+        size_t label_len = value[0] + (value[1] << 8);
+        // --- End readxl ---
         if (pWB->is5ver) {
             return (bof->size < offsetof(LABEL, value) + 2 + label_len);
         }
@@ -580,8 +583,10 @@ static struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
             }
             cell=&row->cells.cell[index];
             cell->id=XLS_RECORD_RK;
-            cell->xf=xlsShortVal(((MULRK*)buf)->rk[i].xf);
-            cell->d=NumFromRk(xlsIntVal(((MULRK*)buf)->rk[i].value));
+            // --- Start readxl ---
+            cell->xf=xlsShortVal(get_MULRK_RK_XF((MULRK*)buf, i));
+            cell->d=NumFromRk(xlsIntVal(get_MULRK_RK_VALUE((MULRK*)buf, i)));
+            // --- End readxl ---
             xls_cell_set_str(cell, xls_getfcell(pWS->workbook,cell, NULL));
         }
         break;
@@ -595,7 +600,9 @@ static struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
             }
             cell=&row->cells.cell[index];
             cell->id=XLS_RECORD_BLANK;
-            cell->xf=xlsShortVal(((MULBLANK*)buf)->xf[i]);
+            // --- Start readxl ---
+            cell->xf=xlsShortVal(get_MULBLANK_XF((MULBLANK*)buf, i));
+            // --- End readxl ---
             xls_cell_set_str(cell, xls_getfcell(pWS->workbook,cell, NULL));
         }
         break;

---FILE: src/libxls/xlsstruct.h---
@@ -37,6 +37,9 @@
 #define XLS_STRUCT_INC
 
 #include ""libxls/ole.h""
+// --- Start readxl ---
+#include <string.h>
+// --- End readxl ---
 
 #define XLS_RECORD_EOF          0x000A
 #define XLS_RECORD_DEFINEDNAME  0x0018
@@ -204,6 +207,19 @@ typedef struct MULRK
 }
 MULRK;
 
+// --- Start readxl ---
+static inline WORD get_MULRK_RK_XF(MULRK *mulrk, int i) {
+    WORD xf;
+    memcpy(&xf, (BYTE *)mulrk + offsetof(MULRK, rk) + i * (sizeof(WORD) + sizeof(DWORD)), sizeof(WORD));
+    return xf;
+}
+
+static inline DWORD get_MULRK_RK_VALUE(MULRK *mulrk, int i) {
+    DWORD value;
+    memcpy(&value, (BYTE *)mulrk + offsetof(MULRK, rk) + i * (sizeof(WORD) + sizeof(DWORD)) + sizeof(WORD), sizeof(DWORD));
+    return value;
+}
+// --- End readxl ---
 typedef struct MULBLANK
 {
     WORD	row;
@@ -213,6 +229,14 @@ typedef struct MULBLANK
 }
 MULBLANK;
 
+// --- Start readxl ---
+static inline WORD get_MULBLANK_XF(MULBLANK *mulblank, int i) {
+    WORD xf;
+    memcpy(&xf, (BYTE *)mulblank + offsetof(MULBLANK, xf) + i * sizeof(WORD), sizeof(WORD));
+    return xf;
+}
+// --- End readxl ---
+
 typedef struct BLANK
 {
     WORD	row;
@@ -230,6 +254,12 @@ typedef struct LABEL
 }
 LABEL;
 
+// --- Start readxl ---
+static inline BYTE *get_LABEL_value(LABEL *label) {
+    return (BYTE *)label + offsetof(LABEL, value);
+}
+// --- End readxl ---
+
 typedef struct BOOLERR
 {
     WORD    row;",False,False,Data / Input Handling,4
tidyverse,readxl,98c8ec8aef602c2a946c4a6810c261799646dbf3,Gábor Csárdi,csardi.gabor@gmail.com,2025-02-26T01:27:40Z,GitHub,noreply@github.com,2025-02-26T01:27:40Z,"Fix compilation on NetBSD (#760)

NetBSD has wcstombs_l(), but it does not have
uselocale().

Co-authored-by: Jennifer (Jenny) Bryan <jenny.f.bryan@gmail.com>",src/unix/config-unix.h,False,False,False,False,3,0,3,"---FILE: src/unix/config-unix.h---
@@ -45,6 +45,9 @@
 
 /* Define to 1 if you have the 'wcstombs_l' function. */
 /* #undef HAVE_WCSTOMBS_L */
+#ifdef __NetBSD__
+#define HAVE_WCSTOMBS_L 1
+#endif
 
 /* Define to 1 if you have the <xlocale.h> header file. */
 /* #undef HAVE_XLOCALE_H */",False,False,Rendering / Conversion,0
tidyverse,readxl,9e0284280ff3c1c58750b00cd54350d061d89fd4,Jenny Bryan,jenny.f.bryan@gmail.com,2025-02-25T23:53:57Z,Jenny Bryan,jenny.f.bryan@gmail.com,2025-02-25T23:53:57Z,"Reapply a diff in libxls 1.6.3

I should not have reversed this when I applied our ""usual patches"" to libxls. This was a real and desirable change.

Addresses (I hope) #767

See https://github.com/libxls/libxls/pull/118, https://github.com/libxls/libxls/issues/127, https://github.com/libxls/libxls/issues/125.",src/libxls/xlstypes.h,False,False,False,False,0,4,4,"---FILE: src/libxls/xlstypes.h---
@@ -40,11 +40,7 @@
 /* an analysis of header file includes shows that doing this here covers everything */
 #include ""cran.h""
 
-#ifdef __cplusplus
-#include <cstdint>
-#else
 #include <stdint.h>
-#endif
 #include <sys/types.h>
 
 typedef unsigned char		BYTE;",False,False,Rendering / Conversion,0
tidyverse,readxl,81f63c6565331be57d7216bc0167c471f2f3676f,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2025-02-12T04:31:43Z,GitHub,noreply@github.com,2025-02-12T04:31:43Z,"Update libxls to 1.6.3 (#764)

* Naive vendoring of libxls 1.6.3

* Re-apply our usual tweaks

* Start to update config

* Working on unix config

* Remove solaris config

* More work on unix config

* Add more checks in CI

* Revert the r-hub checks, for now

I will follow up on the valgrind result, but don't want to see CI failure in the meantime.

* Update Windows config

* Update notes",DESCRIPTION;maintenance/01_pull-from-libxls-upstream.R;src/libxls/xls.c;src/libxls/xlstool.c;src/unix/config-macos.h;src/unix/config-solaris.h;src/unix/config-unix.h;src/unix/config.h;src/windows/config.h,False,True,True,False,95,229,324,"---FILE: DESCRIPTION---
@@ -48,6 +48,6 @@ VignetteBuilder:
 Config/Needs/website: tidyverse/tidytemplate, tidyverse
 Config/testthat/edition: 3
 Encoding: UTF-8
-Note: libxls v1.6.2 (patched) 45abe77
+Note: libxls v1.6.3 c199d13
 Roxygen: list(markdown = TRUE)
 RoxygenNote: 7.3.2

---FILE: maintenance/01_pull-from-libxls-upstream.R---
@@ -6,22 +6,22 @@ library(desc)
 
 libxls_path <- ""~/rrr/libxls""
 there <- function(x) path(libxls_path, x)
-target_branch <- ""dev"" # usually this is master, but not today
+target_branch <- ""dev"" # yeah, this really does appear to be the default
 
 if (git_branch(repo = libxls_path) != target_branch) {
   message(""YO! You are not on the target branch in libxls!"")
 }
 
 # relevant when I am embedding an official release
-#target_version <- ""v1.6.2""
-#(tag <- git_tag_list(target_version, repo = libxls_path))
+target_version <- ""v1.6.3""
+(tag <- git_tag_list(target_version, repo = libxls_path))
 
 libxls_SHA <- git_commit_id(repo = libxls_path)
 
 # relevant when I am embedding an official release
-# if (tag$commit != libxls_SHA) {
-#    message(""YO! SHA associated with HEAD isn't associated with target version!"")
-# }
+if (tag$commit != libxls_SHA) {
+    message(""YO! SHA associated with HEAD isn't associated with target version!"")
+}
 
 # the subset of libxls files that we embed
 paths <- c(
@@ -48,26 +48,20 @@ file_copy(
 )
 
 # fixup for the case where I'm embedding a dev version
-target_version <- ""v1.6.2 (patched)""
+# target_version <- ""v1.6.2 (patched)""
 desc::desc_set(Note = paste(""libxls"", target_version, substr(libxls_SHA, 1, 7)))
 
 # as needed, I rerun the configure script to regenerate
 # unix/config.h and windows/config.h
 
+# shortcut from a tip Jim gave long ago:
+# download and unpack a libxls release (for windows or *nix) and just run
+# ./configure
+
 # as of libxls v1.6.2, we've had to adopt different static config files for
 # macOS and other unix (basically motivated by what we see on GHA Ubuntu jobs)
 
 # on windows, you may need to manually & temporarily add the directory
 # containing gcc in Rtools to the PATH
-
-# things I needed to do on a fresh Big Sur system to run ./bootstrap
-# brew install autoconf
-# brew install autoconf-archive
-# brew install automake
-# brew install gettext
-# brew install libtool
-# ./bootstrap
-# ./configure
-
-# I later learned from Jim that I could also download and unpack the libxls
-# release and probably just run ./configure w/o installing so much stuff
+# 2025-02-11 Rtools 4.4 this meant adding:
+# C:\rtools44\x86_64-w64-mingw32.static.posix\bin

---FILE: src/libxls/xls.c---
@@ -800,7 +800,7 @@ static xls_error_t xls_mergedCells(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
     return LIBXLS_OK;
 }
 
-int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1) {
+int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1, const BYTE* buf) {
     switch (bof1->id) {
         case XLS_RECORD_BOF:	// BIFF5-8
             return (bof1->size < 2 * sizeof(WORD));
@@ -822,6 +822,24 @@ int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1) {
             return (bof1->size < offsetof(FONT, name));
         case XLS_RECORD_FORMAT:
             return (bof1->size < offsetof(FORMAT, value));
+        case XLS_RECORD_STYLE:
+            {
+                struct {
+                    unsigned short idx;
+                    unsigned char ident;
+                    unsigned char lvl;
+                } *styl;
+                if(bof1->size < 2) {
+                    return 1;
+                }
+                styl = (void *)buf;
+                if(xlsShortVal(styl->idx) & 0x8000) {
+                    return bof1->size < 4;
+                } else {
+                    if(bof1->size < 3) return 1;
+                    return bof1->size < 3 + styl->ident;
+                }
+            }
 		case XLS_RECORD_1904:
             return (bof1->size < sizeof(BYTE));
         default:
@@ -869,7 +887,7 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
             }
         }
 
-        if (xls_isRecordTooSmall(pWB, &bof1)) {
+        if (xls_isRecordTooSmall(pWB, &bof1, buf)) {
             retval = LIBXLS_ERROR_PARSE;
             goto cleanup;
         }

---FILE: src/libxls/xlstool.c---
@@ -737,7 +737,8 @@ char* xls_getCSS(xlsWorkBook* pWB)
     DWORD i;
 
     char *ret = malloc(65535);
-    char *buf = malloc(4096);
+    size_t buf_len = 4096;
+    char *buf = malloc(buf_len);
 	ret[0] = '\0';
 
     for (i=0;i<pWB->xfs.count;i++)
@@ -780,75 +781,75 @@ char* xls_getCSS(xlsWorkBook* pWB)
         switch (xf->linestyle & 0x0f)
         {
         case 0:
-            snprintf(borderleft, 255, ""%s"", """");
+            snprintf(borderleft, sizeof(borderleft), ""%s"", """");
             break;
         default:
-            snprintf(borderleft, 255, ""border-left: 1px solid black;"");
+            snprintf(borderleft, sizeof(borderleft), ""border-left: 1px solid black;"");
             break;
         }
 
         switch (xf->linestyle & 0x0f0)
         {
         case 0:
-            snprintf(borderright, 255, ""%s"", """");
+            snprintf(borderright, sizeof(borderright), ""%s"", """");
             break;
         default:
-            snprintf(borderright, 255, ""border-right: 1px solid black;"");
+            snprintf(borderright, sizeof(borderright), ""border-right: 1px solid black;"");
             break;
         }
 
         switch (xf->linestyle & 0x0f00)
         {
         case 0:
-            snprintf(bordertop, 255, ""%s"", """");
+            snprintf(bordertop, sizeof(bordertop), ""%s"", """");
             break;
         default:
-            snprintf(bordertop, 255, ""border-top: 1px solid black;"");
+            snprintf(bordertop, sizeof(bordertop), ""border-top: 1px solid black;"");
             break;
         }
 
         switch (xf->linestyle & 0x0f000)
         {
         case 0:
-            snprintf(borderbottom, 255, ""%s"", """");
+            snprintf(borderbottom, sizeof(borderbottom), ""%s"", """");
             break;
         default:
-            snprintf(borderbottom, 255, ""border-bottom: 1px solid Black;"");
+            snprintf(borderbottom, sizeof(borderbottom), ""border-bottom: 1px solid Black;"");
             break;
         }
 
         if (xf->font)
-            snprintf(color, 255, ""color:#%.6X;"",xls_getColor(pWB->fonts.font[xf->font-1].color,0));
+            snprintf(color, sizeof(color), ""color:#%.6X;"",xls_getColor(pWB->fonts.font[xf->font-1].color,0));
         else
-            snprintf(color, 255, ""%s"", """");
+            snprintf(color, sizeof(color), ""%s"", """");
 
         if (xf->font && (pWB->fonts.font[xf->font-1].flag & 2))
-            snprintf(italic, 255, ""font-style: italic;"");
+            snprintf(italic, sizeof(italic), ""font-style: italic;"");
         else
-            snprintf(italic, 255, ""%s"", """");
+            snprintf(italic, sizeof(italic), ""%s"", """");
 
         if (xf->font && (pWB->fonts.font[xf->font-1].bold>400))
-            snprintf(bold, 255, ""font-weight: bold;"");
+            snprintf(bold, sizeof(bold), ""font-weight: bold;"");
         else
-            snprintf(bold, 255, ""%s"", """");
+            snprintf(bold, sizeof(bold), ""%s"", """");
 
         if (xf->font && (pWB->fonts.font[xf->font-1].underline))
-            snprintf(underline, 255, ""text-decoration: underline;"");
+            snprintf(underline, sizeof(underline), ""text-decoration: underline;"");
         else
-            snprintf(underline, 255, ""%s"", """");
+            snprintf(underline, sizeof(underline), ""%s"", """");
 
         if (xf->font)
             size=pWB->fonts.font[xf->font-1].height/20;
         else
             size=10;
 
         if (xf->font)
-            snprintf(fontname, 255,""%s"",pWB->fonts.font[xf->font-1].name);
+            snprintf(fontname, sizeof(fontname),""%s"",pWB->fonts.font[xf->font-1].name);
         else
-            snprintf(fontname, 255,""Arial"");
+            snprintf(fontname, sizeof(fontname),""Arial"");
 
         background=xls_getColor((WORD)(xf->groundcolor & 0x7f),1);
-        snprintf(buf, 4096, "".xf%i{ font-size:%ipt;font-family: \""%s\"";background:#%.6X;text-align:%s;vertical-align:%s;%s%s%s%s%s%s%s%s}\n"",
+        snprintf(buf, buf_len, "".xf%i{ font-size:%ipt;font-family: \""%s\"";background:#%.6X;text-align:%s;vertical-align:%s;%s%s%s%s%s%s%s%s}\n"",
                 i,size,fontname,background,align,valign,borderleft,borderright,bordertop,borderbottom,color,italic,bold,underline);
 
 		strcat(ret,buf);

---FILE: src/unix/config-macos.h---
@@ -13,24 +13,16 @@
 /* Define to 1 if you have the <inttypes.h> header file. */
 #define HAVE_INTTYPES_H 1
 
-/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
-   to 0 otherwise. */
-#define HAVE_MALLOC 1
-
-/* Define to 1 if you have the <memory.h> header file. */
-#define HAVE_MEMORY_H 1
-
-/* Define to 1 if your system has a GNU libc compatible `realloc' function,
-   and to 0 otherwise. */
-#define HAVE_REALLOC 1
-
 /* Define to 1 if you have the <stdint.h> header file. */
 #define HAVE_STDINT_H 1
 
+/* Define to 1 if you have the <stdio.h> header file. */
+#define HAVE_STDIO_H 1
+
 /* Define to 1 if you have the <stdlib.h> header file. */
 #define HAVE_STDLIB_H 1
 
-/* Define to 1 if you have the `strdup' function. */
+/* Define to 1 if you have the 'strdup' function. */
 #define HAVE_STRDUP 1
 
 /* Define to 1 if you have the <strings.h> header file. */
@@ -51,7 +43,7 @@
 /* Define to 1 if you have the <wchar.h> header file. */
 #define HAVE_WCHAR_H 1
 
-/* Define to 1 if you have the `wcstombs_l' function. */
+/* Define to 1 if you have the 'wcstombs_l' function. */
 #define HAVE_WCSTOMBS_L 1
 
 /* Define to 1 if you have the <xlocale.h> header file. */
@@ -64,7 +56,7 @@
 #define LIBXLS_MAJOR_VERSION 1
 
 /* Micro version */
-#define LIBXLS_MICRO_VERSION 2
+#define LIBXLS_MICRO_VERSION 3
 
 /* Minor version */
 #define LIBXLS_MINOR_VERSION 6
@@ -82,7 +74,7 @@
 #define PACKAGE_NAME ""libxls""
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING ""libxls 1.6.2""
+#define PACKAGE_STRING ""libxls 1.6.3""
 
 /* Define to the one symbol short name of this package. */
 #define PACKAGE_TARNAME ""libxls""
@@ -91,19 +83,15 @@
 #define PACKAGE_URL ""https://github.com/libxls/libxls""
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION ""1.6.2""
+#define PACKAGE_VERSION ""1.6.3""
 
-/* Define to 1 if you have the ANSI C header files. */
+/* Define to 1 if all of the C89 standard headers exist (not just the ones
+   required in a freestanding environment). This macro is provided for
+   backward compatibility; new code need not use it. */
 #define STDC_HEADERS 1
 
 /* Version number of package */
-#define VERSION ""1.6.2""
-
-/* Define to rpl_malloc if the replacement function should be used. */
-/* #undef malloc */
-
-/* Define to rpl_realloc if the replacement function should be used. */
-/* #undef realloc */
+#define VERSION ""1.6.3""
 
-/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* Define as 'unsigned int' if <stddef.h> doesn't define. */
 /* #undef size_t */

---FILE: src/unix/config-solaris.h---
@@ -1,109 +0,0 @@
-/* config.h.  Generated from config.h.in by configure.  */
-/* config.h.in.  Generated from configure.ac by autoheader.  */
-
-/* define if the compiler supports basic C++11 syntax */
-#define HAVE_CXX11 1
-
-/* Define to 1 if you have the <dlfcn.h> header file. */
-#define HAVE_DLFCN_H 1
-
-/* Define if you have the iconv() function and it works. */
-#define HAVE_ICONV 1
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#define HAVE_INTTYPES_H 1
-
-/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
-   to 0 otherwise. */
-#define HAVE_MALLOC 1
-
-/* Define to 1 if you have the <memory.h> header file. */
-#define HAVE_MEMORY_H 1
-
-/* Define to 1 if your system has a GNU libc compatible `realloc' function,
-   and to 0 otherwise. */
-#define HAVE_REALLOC 1
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#define HAVE_STDINT_H 1
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#define HAVE_STDLIB_H 1
-
-/* Define to 1 if you have the `strdup' function. */
-#define HAVE_STRDUP 1
-
-/* Define to 1 if you have the <strings.h> header file. */
-#define HAVE_STRINGS_H 1
-
-/* Define to 1 if you have the <string.h> header file. */
-#define HAVE_STRING_H 1
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#define HAVE_SYS_STAT_H 1
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#define HAVE_SYS_TYPES_H 1
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#define HAVE_UNISTD_H 1
-
-/* Define to 1 if you have the <wchar.h> header file. */
-#define HAVE_WCHAR_H 1
-
-/* Define to 1 if you have the `wcstombs_l' function. */
-/* #undef HAVE_WCSTOMBS_L */
-
-/* Define to 1 if you have the <xlocale.h> header file. */
-/* #undef HAVE_XLOCALE_H */
-
-/* Define as const if the declaration of iconv() needs const. */
-#define ICONV_CONST const
-
-/* Major version */
-#define LIBXLS_MAJOR_VERSION 1
-
-/* Micro version */
-#define LIBXLS_MICRO_VERSION 2
-
-/* Minor version */
-#define LIBXLS_MINOR_VERSION 6
-
-/* Define to the sub-directory where libtool stores uninstalled libraries. */
-#define LT_OBJDIR "".libs/""
-
-/* Name of package */
-#define PACKAGE ""libxls""
-
-/* Define to the address where bug reports for this package should be sent. */
-#define PACKAGE_BUGREPORT ""https://github.com/libxls/libxls/issues""
-
-/* Define to the full name of this package. */
-#define PACKAGE_NAME ""libxls""
-
-/* Define to the full name and version of this package. */
-#define PACKAGE_STRING ""libxls 1.6.2""
-
-/* Define to the one symbol short name of this package. */
-#define PACKAGE_TARNAME ""libxls""
-
-/* Define to the home page for this package. */
-#define PACKAGE_URL ""https://github.com/libxls/libxls""
-
-/* Define to the version of this package. */
-#define PACKAGE_VERSION ""1.6.2""
-
-/* Define to 1 if you have the ANSI C header files. */
-#define STDC_HEADERS 1
-
-/* Version number of package */
-#define VERSION ""1.6.2""
-
-/* Define to rpl_malloc if the replacement function should be used. */
-/* #undef malloc */
-
-/* Define to rpl_realloc if the replacement function should be used. */
-/* #undef realloc */
-
-/* Define to `unsigned int' if <sys/types.h> does not define. */
-/* #undef size_t */

---FILE: src/unix/config-unix.h---
@@ -13,24 +13,16 @@
 /* Define to 1 if you have the <inttypes.h> header file. */
 #define HAVE_INTTYPES_H 1
 
-/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
-   to 0 otherwise. */
-#define HAVE_MALLOC 1
-
-/* Define to 1 if you have the <memory.h> header file. */
-#define HAVE_MEMORY_H 1
-
-/* Define to 1 if your system has a GNU libc compatible `realloc' function,
-   and to 0 otherwise. */
-#define HAVE_REALLOC 1
-
 /* Define to 1 if you have the <stdint.h> header file. */
 #define HAVE_STDINT_H 1
 
+/* Define to 1 if you have the <stdio.h> header file. */
+#define HAVE_STDIO_H 1
+
 /* Define to 1 if you have the <stdlib.h> header file. */
 #define HAVE_STDLIB_H 1
 
-/* Define to 1 if you have the `strdup' function. */
+/* Define to 1 if you have the 'strdup' function. */
 #define HAVE_STRDUP 1
 
 /* Define to 1 if you have the <strings.h> header file. */
@@ -51,20 +43,20 @@
 /* Define to 1 if you have the <wchar.h> header file. */
 #define HAVE_WCHAR_H 1
 
-/* Define to 1 if you have the `wcstombs_l' function. */
+/* Define to 1 if you have the 'wcstombs_l' function. */
 /* #undef HAVE_WCSTOMBS_L */
 
 /* Define to 1 if you have the <xlocale.h> header file. */
 /* #undef HAVE_XLOCALE_H */
 
 /* Define as const if the declaration of iconv() needs const. */
-#define ICONV_CONST 
+#define ICONV_CONST
 
 /* Major version */
 #define LIBXLS_MAJOR_VERSION 1
 
 /* Micro version */
-#define LIBXLS_MICRO_VERSION 2
+#define LIBXLS_MICRO_VERSION 3
 
 /* Minor version */
 #define LIBXLS_MINOR_VERSION 6
@@ -82,7 +74,7 @@
 #define PACKAGE_NAME ""libxls""
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING ""libxls 1.6.2""
+#define PACKAGE_STRING ""libxls 1.6.3""
 
 /* Define to the one symbol short name of this package. */
 #define PACKAGE_TARNAME ""libxls""
@@ -91,19 +83,15 @@
 #define PACKAGE_URL ""https://github.com/libxls/libxls""
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION ""1.6.2""
+#define PACKAGE_VERSION ""1.6.3""
 
-/* Define to 1 if you have the ANSI C header files. */
+/* Define to 1 if all of the C89 standard headers exist (not just the ones
+   required in a freestanding environment). This macro is provided for
+   backward compatibility; new code need not use it. */
 #define STDC_HEADERS 1
 
 /* Version number of package */
-#define VERSION ""1.6.2""
-
-/* Define to rpl_malloc if the replacement function should be used. */
-/* #undef malloc */
-
-/* Define to rpl_realloc if the replacement function should be used. */
-/* #undef realloc */
+#define VERSION ""1.6.3""
 
-/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* Define as 'unsigned int' if <stddef.h> doesn't define. */
 /* #undef size_t */

---FILE: src/unix/config.h---
@@ -1,7 +1,5 @@
 #ifdef __APPLE__
 #include ""unix/config-macos.h""
-#elif defined(__sun)
-#include ""unix/config-solaris.h""
 #else
 #include ""unix/config-unix.h""
 #endif

---FILE: src/windows/config.h---
@@ -13,24 +13,16 @@
 /* Define to 1 if you have the <inttypes.h> header file. */
 #define HAVE_INTTYPES_H 1
 
-/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
-   to 0 otherwise. */
-#define HAVE_MALLOC 1
-
-/* Define to 1 if you have the <memory.h> header file. */
-#define HAVE_MEMORY_H 1
-
-/* Define to 1 if your system has a GNU libc compatible `realloc' function,
-   and to 0 otherwise. */
-#define HAVE_REALLOC 1
-
 /* Define to 1 if you have the <stdint.h> header file. */
 #define HAVE_STDINT_H 1
 
+/* Define to 1 if you have the <stdio.h> header file. */
+#define HAVE_STDIO_H 1
+
 /* Define to 1 if you have the <stdlib.h> header file. */
 #define HAVE_STDLIB_H 1
 
-/* Define to 1 if you have the `strdup' function. */
+/* Define to 1 if you have the 'strdup' function. */
 #define HAVE_STRDUP 1
 
 /* Define to 1 if you have the <strings.h> header file. */
@@ -51,7 +43,7 @@
 /* Define to 1 if you have the <wchar.h> header file. */
 #define HAVE_WCHAR_H 1
 
-/* Define to 1 if you have the `wcstombs_l' function. */
+/* Define to 1 if you have the 'wcstombs_l' function. */
 /* #undef HAVE_WCSTOMBS_L */
 
 /* Define to 1 if you have the <xlocale.h> header file. */
@@ -64,7 +56,7 @@
 #define LIBXLS_MAJOR_VERSION 1
 
 /* Micro version */
-#define LIBXLS_MICRO_VERSION 2
+#define LIBXLS_MICRO_VERSION 3
 
 /* Minor version */
 #define LIBXLS_MINOR_VERSION 6
@@ -82,7 +74,7 @@
 #define PACKAGE_NAME ""libxls""
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING ""libxls 1.6.2""
+#define PACKAGE_STRING ""libxls 1.6.3""
 
 /* Define to the one symbol short name of this package. */
 #define PACKAGE_TARNAME ""libxls""
@@ -91,19 +83,15 @@
 #define PACKAGE_URL ""https://github.com/libxls/libxls""
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION ""1.6.2""
+#define PACKAGE_VERSION ""1.6.3""
 
-/* Define to 1 if you have the ANSI C header files. */
+/* Define to 1 if all of the C89 standard headers exist (not just the ones
+   required in a freestanding environment). This macro is provided for
+   backward compatibility; new code need not use it. */
 #define STDC_HEADERS 1
 
 /* Version number of package */
-#define VERSION ""1.6.2""
-
-/* Define to rpl_malloc if the replacement function should be used. */
-/* #undef malloc */
-
-/* Define to rpl_realloc if the replacement function should be used. */
-/* #undef realloc */
+#define VERSION ""1.6.3""
 
-/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* Define as 'unsigned int' if <stddef.h> doesn't define. */
 /* #undef size_t */",True,False,Dependency / Package,7
tidyverse,readxl,c7c68504692fdbd5506e5e41620ba3ee03f1a2c2,olivroy,52606734+olivroy@users.noreply.github.com,2025-02-11T20:29:46Z,GitHub,noreply@github.com,2025-02-11T20:29:46Z,"fix link (#763)

* Add full url

* fix anchored link for R-devel",R/cell-specification.R;R/excel-sheets.R;man/cell-specification.Rd;man/excel_sheets.Rd,False,True,True,False,6,6,12,"---FILE: R/cell-specification.R---
@@ -7,7 +7,7 @@
 #' using helper functions. You can find more examples at the
 #'  [sheet geometry](https://readxl.tidyverse.org/articles/sheet-geometry.html#range)
 #'  vignette. In all cases, cell range processing is handled by the
-#' [cellranger][cellranger] package, where you can find full documentation for
+#' [cellranger][cellranger::cellranger] package, where you can find full documentation for
 #' the functions used in the examples below.
 #'
 #' @examples
@@ -52,7 +52,7 @@
 #' # upper right = D4, everything else unspecified
 #' read_excel(path, range = cell_limits(c(4, NA), c(NA, 4)))
 #'
-#' @seealso The [cellranger][cellranger] package has full documentation on cell
+#' @seealso The [cellranger][cellranger::cellranger] package has full documentation on cell
 #'   specification and offers additional functions for manipulating ""A1:D10""
 #'   style spreadsheet ranges. Here are the most relevant:
 #'   \itemize{

---FILE: R/excel-sheets.R---
@@ -1,7 +1,7 @@
 #' List all sheets in an excel spreadsheet
 #'
 #' The list of sheet names is especially useful when you want to iterate over
-#' all of the sheets in a workbook. The `vignette(""readxl-workflows"")` article
+#' all of the sheets in a workbook. The [readxl Workflows article](https://readxl.tidyverse.org/articles/readxl-workflows.html)
 #' provides several worked examples of this, showing how to combine readxl with
 #' other packages in the tidyverse, such as purrr, or with base R functions like
 #' [lapply()].

---FILE: man/cell-specification.Rd---
@@ -15,7 +15,7 @@ Excel-like cell range, such as \code{range = ""D12:F15""} or
 using helper functions. You can find more examples at the
 \href{https://readxl.tidyverse.org/articles/sheet-geometry.html#range}{sheet geometry}
 vignette. In all cases, cell range processing is handled by the
-\link{cellranger} package, where you can find full documentation for
+\link[cellranger:cellranger]{cellranger} package, where you can find full documentation for
 the functions used in the examples below.
 }
 \examples{
@@ -62,7 +62,7 @@ read_excel(path, range = cell_limits(c(4, NA), c(NA, 4)))
 
 }
 \seealso{
-The \link{cellranger} package has full documentation on cell
+The \link[cellranger:cellranger]{cellranger} package has full documentation on cell
 specification and offers additional functions for manipulating ""A1:D10""
 style spreadsheet ranges. Here are the most relevant:
 \itemize{

---FILE: man/excel_sheets.Rd---
@@ -11,7 +11,7 @@ excel_sheets(path)
 }
 \description{
 The list of sheet names is especially useful when you want to iterate over
-all of the sheets in a workbook. The \code{vignette(""readxl-workflows"")} article
+all of the sheets in a workbook. The \href{https://readxl.tidyverse.org/articles/readxl-workflows.html}{readxl Workflows article}
 provides several worked examples of this, showing how to combine readxl with
 other packages in the tidyverse, such as purrr, or with base R functions like
 \code{\link[=lapply]{lapply()}}.",True,False,Documentation / Formatting,7
tidyverse,readxl,22ded0b23ba475879d46ad9dfa544ad31d5dfc73,Anatoliy Sokolov,ansokolov@dow.com,2024-08-15T22:32:49Z,GitHub,noreply@github.com,2024-08-15T22:32:49Z,"Fix map superseded (#754)

* Updating superceded map_df() to map() %>% list_rbind(). Fixes #746.

* Update readxl-workflows.Rmd

* updating .id argument to go away in favor of names_to in the list_rbind(). Fixes #746.

---------

Co-authored-by: Lionel Henry <lionel.hry@proton.me>",vignettes/articles/readxl-workflows.Rmd,True,False,True,False,2,3,5,"---FILE: vignettes/articles/readxl-workflows.Rmd---
@@ -175,10 +175,9 @@ ranges <- list(""A5:F15"", cell_rows(5:15))
 deaths <- map2(
   sheets,
   ranges,
-  ~ read_excel(path, sheet = .x, range = .y),
-  .id = ""sheet""
+  ~ read_excel(path, sheet = .x, range = .y)
 ) %>%
-  list_rbind() %>%
+  list_rbind(names_to = ""sheet"") %>%
   write_csv(""deaths.csv"")
 print(deaths, n = Inf)
 ```",False,True,Rendering / Conversion,3
tidyverse,readxl,f3eb9e5c53c898122aecbe19e7a2e8b186ec109b,Anatoliy Sokolov,ansokolov@dow.com,2024-08-15T18:06:44Z,GitHub,noreply@github.com,2024-08-15T18:06:44Z,"Updating use of superseded `map_df()` to `map() %>% list_rbind()` (#753)

Fixes #746",vignettes/articles/readxl-workflows.Rmd,True,False,True,False,7,5,12,"---FILE: vignettes/articles/readxl-workflows.Rmd---
@@ -134,17 +134,18 @@ What if the datasets found on different sheets have the same variables? Then you
 
 readxl ships with an example sheet `deaths.xlsx`, containing data on famous people who died in 2016 or 2017. It has two worksheets named ""arts"" and ""other"", but the spreadsheet layout is the same in each and the data tables have the same variables, e.g., name and date of death.
 
-The `map_df()` function from purrr makes it easy to iterate over worksheets and glue together the resulting data frames, all at once.
+The `map()` function from purrr makes it easy to iterate over worksheets. Use `purrr::list_rbind()` to glue together the resulting data frames. 
 
   * Store a self-named vector of worksheet names (critical for the ID variable below).
-  * Use `purrr::map_df()` to import the data, create an ID variable for the source worksheet, and row bind.
+  * Use `purrr::map() %>% purrr::list_rbind()` to import the data, create an ID variable for the source worksheet, and row bind.
 
 ```{r}
 path <- readxl_example(""deaths.xlsx"")
 deaths <- path %>%
   excel_sheets() %>%
   set_names() %>% 
-  map_df(~ read_excel(path = path, sheet = .x, range = ""A5:F15""), .id = ""sheet"")
+  map(~ read_excel(path = path, sheet = .x, range = ""A5:F15"")) %>%
+  list_rbind(names_to = ""sheet"")
 print(deaths, n = Inf)
 ```
 
@@ -162,7 +163,7 @@ Even though the worksheets in `deaths.xlsx` have the same layout, we'll pretend
 
   * Store a self-named vector of worksheet names.
   * Store a vector of cell range specifications.
-  * Use `purrr::map2_df()` to iterate over those two vectors in parallel, importing the data, row binding, and creating an ID variable for the source worksheet.
+  * Use `purrr::map2() %>% purrr::list_rbind()` to iterate over those two vectors in parallel, importing the data, row binding, and creating an ID variable for the source worksheet.
   * Cache the unified data to CSV.
 
 ```{r}
@@ -171,12 +172,13 @@ sheets <- path %>%
   excel_sheets() %>% 
   set_names()
 ranges <- list(""A5:F15"", cell_rows(5:15))
-deaths <- map2_df(
+deaths <- map2(
   sheets,
   ranges,
   ~ read_excel(path, sheet = .x, range = .y),
   .id = ""sheet""
 ) %>%
+  list_rbind() %>%
   write_csv(""deaths.csv"")
 print(deaths, n = Inf)
 ```",False,True,Rendering / Conversion,3
tidyverse,readxl,866eff6e1a73226598fbcd5510607706402fd0ab,Gleb Ebert,5892266+gl-eb@users.noreply.github.com,2023-10-07T00:06:36Z,GitHub,noreply@github.com,2023-10-07T00:06:36Z,Fix link to tidyverse design principles (#738),vignettes/articles/column-names.Rmd,True,False,True,False,1,1,2,"---FILE: vignettes/articles/column-names.Rmd---
@@ -33,7 +33,7 @@ But users have long wanted a way to specify a name repair *strategy*, as opposed
 As of v1.2.0, readxl provides the `.name_repair` argument, which affords control over how column names are checked or repaired.
 
 The `.name_repair` argument in `read_excel()`, `read_xls()`, and `read_xlsx()` works exactly the same way as it does in [`tibble::tibble()`](https://tibble.tidyverse.org/reference/tibble.html) and [`tibble::as_tibble()`](https://tibble.tidyverse.org/reference/as_tibble.html).
-The reasoning behind the name repair strategy is laid out in [principles.tidyverse.org](https://principles.tidyverse.org/names-attribute.html).
+The reasoning behind the name repair strategy is laid out in [design.tidyverse.org](https://design.tidyverse.org/names.html).
 
 readxl's default is `.name_repair = ""unique""`, which ensures each column has a unique name.
 If that is already true of the column names, readxl won't touch them.",False,True,Implementation / Logic,6
tidyverse,readxl,2ab0bc3e2769a52e0e335b4deafa3bd5f9126c02,Jenny Bryan,jenny.f.bryan@gmail.com,2023-07-05T19:57:07Z,Jenny Bryan,jenny.f.bryan@gmail.com,2023-07-05T19:57:07Z,"Update cran comments

I believe the revdep failure (rb3) is a false positive. It did not show up in the first run.

I also checked datplot locally (failed in the first run) and passed R CMD check cleanly, so I also think that is a false positive.",cran-comments.md,False,False,False,False,6,9,15,"---FILE: cran-comments.md---
@@ -1,13 +1,10 @@
-## revdepcheck results
-
-We checked 301 reverse dependencies (299 from CRAN + 2 from Bioconductor), comparing R CMD check results across CRAN and dev versions of this package.
+This is a patch release in response to a 2023-06-28 email from Kurt Hornik about inputs to numeric_version() and package_version().
 
- * We saw 0 new problems
- * We failed to check 2 packages
+In this case, the problematic inputs came from implicit usage via `>` in some tests and these have been removed.
 
-Issues with CRAN packages are summarised below.
+## revdepcheck results
 
-### Failed to check
+We checked 319 reverse dependencies, comparing R CMD check results across CRAN and dev versions of this package.
 
-* OlinkAnalyze (NA)
-* Platypus     (NA)
+ * We saw 0 new problems
+ * We failed to check 0 packages",False,False,Documentation / Formatting,3
tidyverse,readxl,e5654dc46b69ed5246d0636a5df4c06adbe64ade,Jenny Bryan,jenny.f.bryan@gmail.com,2023-02-09T05:01:34Z,Jenny Bryan,jenny.f.bryan@gmail.com,2023-02-09T05:05:25Z,"revdepcheck::cloud_check()

Followed up on 4 locally

covidmx and RcmdrPlugin.EZR pass cleanly locally for me (2 of 4)

OlinkAnalyze
1 snapshot test fails for me locally
Does not look related to readxl

── Failure ('test-pca_plot.R:72'): olink_pca_plot works ────────────────────────
Snapshot of `testcase` to 'pca_plot/pca-plot-with-loadings.svg' has changed
* Locate check directory
* Copy 'tests/testthat/_snaps/pca_plot/pca-plot-with-loadings.new.svg' to local test directory
* Run `testthat::snapshot_review('pca_plot/')` to review changes
Backtrace:
    ▆
 1. └─vdiffr::expect_doppelganger(""PCA plot with loadings"", pca_plot_treatCol_topLoadings[[1]]) at test-pca_plot.R:72:2
 2.   ├─base::withCallingHandlers(...)
 3.   └─testthat::expect_snapshot_file(...)

Platypus

I suspect this is related to dependencies in nonstandard repos

> pak::local_install_dev_deps()
✔ Loading metadata database ... done
Error:
! error in pak subprocess
Caused by error:
! Could not solve package dependencies:
* deps::/Users/jenny/tmp/Platypus:
  * Can't install dependency monocle3
  * Can't install dependency ProjecTILs
  * Can't install dependency SeuratWrappers
* monocle3: Can't find package called monocle3, ProjecTILs, SeuratWrappers.
* ProjecTILs: Can't find package called monocle3, ProjecTILs, SeuratWrappers.
* SeuratWrappers: Can't find package called monocle3, ProjecTILs, SeuratWrappers.",revdep/README.md;revdep/cran.md;revdep/failures.md,False,False,False,False,182,22,204,"---FILE: revdep/README.md---
@@ -1,8 +1,11 @@
 # Revdeps
 
-## Failed to check (1)
+## Failed to check (4)
 
-|package |version |error |warning |note |
-|:-------|:-------|:-----|:-------|:----|
-|SSVS    |?       |      |        |     |
+|package         |version |error |warning |note |
+|:---------------|:-------|:-----|:-------|:----|
+|covidmx         |?       |      |        |     |
+|OlinkAnalyze    |?       |      |        |     |
+|Platypus        |?       |      |        |     |
+|RcmdrPlugin.EZR |?       |      |        |     |
 

---FILE: revdep/cran.md---
@@ -1,12 +1,13 @@
 ## revdepcheck results
 
-We checked 260 reverse dependencies, comparing R CMD check results across CRAN and dev versions of this package.
+We checked 301 reverse dependencies (299 from CRAN + 2 from Bioconductor), comparing R CMD check results across CRAN and dev versions of this package.
 
  * We saw 0 new problems
- * We failed to check 1 packages
+ * We failed to check 2 packages
 
 Issues with CRAN packages are summarised below.
 
 ### Failed to check
 
-* SSVS (NA)
+* OlinkAnalyze (NA)
+* Platypus     (NA)

---FILE: revdep/failures.md---
@@ -1,14 +1,13 @@
-# SSVS
+# covidmx
 
 <details>
 
-* Version: 2.0.0
-* GitHub: https://github.com/sabainter/SSVS
-* Source code: https://github.com/cran/SSVS
-* Date/Publication: 2022-05-29 05:40:09 UTC
-* Number of recursive dependencies: 125
+* Version: NA
+* GitHub: NA
+* Source code: https://github.com/cran/covidmx
+* Number of recursive dependencies: 164
 
-Run `cloud_details(, ""SSVS"")` for more info
+Run `revdepcheck::cloud_details(, ""covidmx"")` for more info
 
 </details>
 
@@ -17,17 +16,134 @@ Run `cloud_details(, ""SSVS"")` for more info
 ### Devel
 
 ```
-* using log directory ‘/tmp/workdir/SSVS/new/SSVS.Rcheck’
+
+
+
+
+
+
+```
+### CRAN
+
+```
+
+
+
+
+
+
+```
+# OlinkAnalyze
+
+<details>
+
+* Version: 3.3.0
+* GitHub: NA
+* Source code: https://github.com/cran/OlinkAnalyze
+* Date/Publication: 2023-01-24 21:50:02 UTC
+* Number of recursive dependencies: 202
+
+Run `revdepcheck::cloud_details(, ""OlinkAnalyze"")` for more info
+
+</details>
+
+## Error before installation
+
+### Devel
+
+```
+* using log directory ‘/tmp/workdir/OlinkAnalyze/new/OlinkAnalyze.Rcheck’
 * using R version 4.1.1 (2021-08-10)
 * using platform: x86_64-pc-linux-gnu (64-bit)
 * using session charset: UTF-8
 * using option ‘--no-manual’
-* checking for file ‘SSVS/DESCRIPTION’ ... OK
-* this is package ‘SSVS’ version ‘2.0.0’
+* checking for file ‘OlinkAnalyze/DESCRIPTION’ ... OK
+* checking extension type ... Package
+* this is package ‘OlinkAnalyze’ version ‘3.3.0’
 * package encoding: UTF-8
 * checking package namespace information ... OK
+...
+* checking for unstated dependencies in ‘tests’ ... OK
+* checking tests ... OK
+  Running ‘testthat.R’
+* checking for unstated dependencies in vignettes ... OK
+* checking package vignettes in ‘inst/doc’ ... OK
+* checking running R code from vignettes ... NONE
+  ‘Vignett.Rmd’ using ‘UTF-8’... OK
+* checking re-building of vignette outputs ... OK
+* DONE
+Status: 1 NOTE
+
+
+
+
+
+```
+### CRAN
+
+```
+* using log directory ‘/tmp/workdir/OlinkAnalyze/old/OlinkAnalyze.Rcheck’
+* using R version 4.1.1 (2021-08-10)
+* using platform: x86_64-pc-linux-gnu (64-bit)
+* using session charset: UTF-8
+* using option ‘--no-manual’
+* checking for file ‘OlinkAnalyze/DESCRIPTION’ ... OK
+* checking extension type ... Package
+* this is package ‘OlinkAnalyze’ version ‘3.3.0’
+* package encoding: UTF-8
+* checking package namespace information ... OK
+...
+* checking for unstated dependencies in ‘tests’ ... OK
+* checking tests ... OK
+  Running ‘testthat.R’
+* checking for unstated dependencies in vignettes ... OK
+* checking package vignettes in ‘inst/doc’ ... OK
+* checking running R code from vignettes ... NONE
+  ‘Vignett.Rmd’ using ‘UTF-8’... OK
+* checking re-building of vignette outputs ... OK
+* DONE
+Status: 1 NOTE
+
+
+
+
+
+```
+# Platypus
+
+<details>
+
+* Version: 3.4.1
+* GitHub: NA
+* Source code: https://github.com/cran/Platypus
+* Date/Publication: 2022-08-15 07:20:20 UTC
+* Number of recursive dependencies: 356
+
+Run `revdepcheck::cloud_details(, ""Platypus"")` for more info
+
+</details>
+
+## Error before installation
+
+### Devel
+
+```
+* using log directory ‘/tmp/workdir/Platypus/new/Platypus.Rcheck’
+* using R version 4.1.1 (2021-08-10)
+* using platform: x86_64-pc-linux-gnu (64-bit)
+* using session charset: UTF-8
+* using option ‘--no-manual’
+* checking for file ‘Platypus/DESCRIPTION’ ... OK
+* checking extension type ... Package
+* this is package ‘Platypus’ version ‘3.4.1’
+* package encoding: UTF-8
+* checking package namespace information ... OK
+...
 * checking package dependencies ... ERROR
-Package required but not available: ‘BoomSpikeSlab’
+Package required but not available: ‘ggtree’
+
+Packages suggested but not available for checking:
+  'Matrix.utils', 'monocle3', 'ProjecTILs', 'SeuratWrappers'
 
 See section ‘The DESCRIPTION file’ in the ‘Writing R Extensions’
 manual.
@@ -42,17 +158,22 @@ Status: 1 ERROR
 ### CRAN
 
 ```
-* using log directory ‘/tmp/workdir/SSVS/old/SSVS.Rcheck’
+* using log directory ‘/tmp/workdir/Platypus/old/Platypus.Rcheck’
 * using R version 4.1.1 (2021-08-10)
 * using platform: x86_64-pc-linux-gnu (64-bit)
 * using session charset: UTF-8
 * using option ‘--no-manual’
-* checking for file ‘SSVS/DESCRIPTION’ ... OK
-* this is package ‘SSVS’ version ‘2.0.0’
+* checking for file ‘Platypus/DESCRIPTION’ ... OK
+* checking extension type ... Package
+* this is package ‘Platypus’ version ‘3.4.1’
 * package encoding: UTF-8
 * checking package namespace information ... OK
+...
 * checking package dependencies ... ERROR
-Package required but not available: ‘BoomSpikeSlab’
+Package required but not available: ‘ggtree’
+
+Packages suggested but not available for checking:
+  'Matrix.utils', 'monocle3', 'ProjecTILs', 'SeuratWrappers'
 
 See section ‘The DESCRIPTION file’ in the ‘Writing R Extensions’
 manual.
@@ -63,4 +184,39 @@ Status: 1 ERROR
 
 
 
+```
+# RcmdrPlugin.EZR
+
+<details>
+
+* Version: NA
+* GitHub: NA
+* Source code: https://github.com/cran/RcmdrPlugin.EZR
+* Number of recursive dependencies: 172
+
+Run `revdepcheck::cloud_details(, ""RcmdrPlugin.EZR"")` for more info
+
+</details>
+
+## Error before installation
+
+### Devel
+
+```
+
+
+
+
+
+
+```
+### CRAN
+
+```
+
+
+
+
+
+
 ```",False,False,Documentation / Formatting,6
tidyverse,readxl,9cc1e8ae5d2c929b2553bc8fb87b9f1f57c46d1d,Jenny Bryan,jenny.f.bryan@gmail.com,2023-02-08T23:41:28Z,Jenny Bryan,jenny.f.bryan@gmail.com,2023-02-08T23:41:28Z,Fix URLs,DESCRIPTION;NEWS.md;README.Rmd;README.md;man/readxl-package.Rd;vignettes/cell-and-column-types.Rmd,True,False,True,False,32,39,71,"---FILE: DESCRIPTION---
@@ -23,7 +23,7 @@ Authors@R: c(
   )
 Description: Import excel files into R. Supports '.xls' via the embedded
     'libxls' C library <https://github.com/libxls/libxls> and '.xlsx' via
-    the embedded 'RapidXML' C++ library <http://rapidxml.sourceforge.net>.
+    the embedded 'RapidXML' C++ library <https://rapidxml.sourceforge.net/>.
     Works on Windows, Mac and Linux without external dependencies.
 License: MIT + file LICENSE
 URL: https://readxl.tidyverse.org, https://github.com/tidyverse/readxl

---FILE: NEWS.md---
@@ -206,7 +206,7 @@ Many 3rd party tools write xls and xlsx that comply with the spec, but that are
 
 * `read_xls()` and `read_xlsx()` are now exposed, such that files without an `.xls` or `.xlsx` extension can be read. (#85, @jirkalewandowski)
 
-* The [Lotus 1-2-3 leap year bug](https://docs.microsoft.com/en-US/office/troubleshoot/excel/wrongly-assumes-1900-is-leap-year) is now accounted for, i.e. date-times prior to March 1, 1900 import correctly. Date-times on the non-existent leap day February 29, 1900 import as NA and throw a warning. (#264, #148, #292)
+* The [Lotus 1-2-3 leap year bug](https://learn.microsoft.com/en-US/office/troubleshoot/excel/wrongly-assumes-1900-is-leap-year) is now accounted for, i.e. date-times prior to March 1, 1900 import correctly. Date-times on the non-existent leap day February 29, 1900 import as NA and throw a warning. (#264, #148, #292)
 
 * The tibble package is now imported (#175, @krlmlr) and `tibble::repair_names()` is used to prevent empty, `NA`, or duplicated column names. (#216, #208, #199 #182, #53, #247).
 

---FILE: README.Rmd---
@@ -25,7 +25,7 @@ knitr::opts_chunk$set(
 
 The readxl package makes it easy to get data out of Excel and into R. Compared to many of the existing packages (e.g. gdata, xlsx, xlsReadWrite) readxl has no external dependencies, so it's easy to install and use on all operating systems.  It is designed to work with _tabular_ data.
 
-readxl supports both the legacy `.xls` format and the modern xml-based `.xlsx` format. The [libxls](https://github.com/libxls/libxls) C library is used to support `.xls`, which abstracts away many of the complexities of the underlying binary format. To parse `.xlsx`, we use the [RapidXML](http://rapidxml.sourceforge.net) C++ library.
+readxl supports both the legacy `.xls` format and the modern xml-based `.xlsx` format. The [libxls](https://github.com/libxls/libxls) C library is used to support `.xls`, which abstracts away many of the complexities of the underlying binary format. To parse `.xlsx`, we use the [RapidXML](https://rapidxml.sourceforge.net/) C++ library.
 
 ## Installation
 

---FILE: README.md---
@@ -24,7 +24,7 @@ readxl supports both the legacy `.xls` format and the modern xml-based
 `.xlsx` format. The [libxls](https://github.com/libxls/libxls) C library
 is used to support `.xls`, which abstracts away many of the complexities
 of the underlying binary format. To parse `.xlsx`, we use the
-[RapidXML](http://rapidxml.sourceforge.net) C++ library.
+[RapidXML](https://rapidxml.sourceforge.net/) C++ library.
 
 ## Installation
 
@@ -75,7 +75,7 @@ readxl_example()
 #>  [5] ""deaths.xls""    ""deaths.xlsx""   ""geometry.xls""  ""geometry.xlsx""
 #>  [9] ""type-me.xls""   ""type-me.xlsx""
 readxl_example(""clippy.xls"")
-#> [1] ""/private/tmp/RtmpG5ZAUG/temp_libpath1374b3dd1a473/readxl/extdata/clippy.xls""
+#> [1] ""/private/tmp/RtmptoRhn8/temp_libpathcb0a467b0652/readxl/extdata/clippy.xls""
 ```
 
 `read_excel()` reads both xls and xlsx files and detects the format from
@@ -91,7 +91,6 @@ read_excel(xlsx_example)
 #> 2          4.9         3            1.4         0.2 setosa 
 #> 3          4.7         3.2          1.3         0.2 setosa 
 #> # … with 147 more rows
-#> # ℹ Use `print(n = ...)` to see more rows
 
 xls_example <- readxl_example(""datasets.xls"")
 read_excel(xls_example)
@@ -102,7 +101,6 @@ read_excel(xls_example)
 #> 2          4.9         3            1.4         0.2 setosa 
 #> 3          4.7         3.2          1.3         0.2 setosa 
 #> # … with 147 more rows
-#> # ℹ Use `print(n = ...)` to see more rows
 ```
 
 List the sheet names with `excel_sheets()`.
@@ -123,7 +121,6 @@ read_excel(xlsx_example, sheet = ""chickwts"")
 #> 2    160 horsebean
 #> 3    136 horsebean
 #> # … with 68 more rows
-#> # ℹ Use `print(n = ...)` to see more rows
 read_excel(xls_example, sheet = 4)
 #> # A tibble: 1,000 × 5
 #>     lat  long depth   mag stations
@@ -132,7 +129,6 @@ read_excel(xls_example, sheet = 4)
 #> 2 -20.6  181.   650   4.2       15
 #> 3 -26    184.    42   5.4       43
 #> # … with 997 more rows
-#> # ℹ Use `print(n = ...)` to see more rows
 ```
 
 There are various ways to control which cells are read. You can even
@@ -168,7 +164,6 @@ read_excel(xlsx_example, range = cell_cols(""B:D""))
 #> 2         3            1.4         0.2
 #> 3         3.2          1.3         0.2
 #> # … with 147 more rows
-#> # ℹ Use `print(n = ...)` to see more rows
 read_excel(xlsx_example, range = ""mtcars!B1:D5"")
 #> # A tibble: 4 × 3
 #>     cyl  disp    hp
@@ -177,7 +172,6 @@ read_excel(xlsx_example, range = ""mtcars!B1:D5"")
 #> 2     6   160   110
 #> 3     4   108    93
 #> # … with 1 more row
-#> # ℹ Use `print(n = ...)` to see more rows
 ```
 
 If `NA`s are represented by something other than blank cells, set the
@@ -192,7 +186,6 @@ read_excel(xlsx_example, na = ""setosa"")
 #> 2          4.9         3            1.4         0.2 <NA>   
 #> 3          4.7         3.2          1.3         0.2 <NA>   
 #> # … with 147 more rows
-#> # ℹ Use `print(n = ...)` to see more rows
 ```
 
 If you are new to the tidyverse conventions for data import, you may
@@ -206,43 +199,43 @@ readxl will become increasingly consistent with other packages, such as
 Broad topics are explained in [these
 articles](https://readxl.tidyverse.org/articles/index.html):
 
--   [Cell and Column
-    Types](https://readxl.tidyverse.org/articles/cell-and-column-types.html)
--   [Sheet
-    Geometry](https://readxl.tidyverse.org/articles/sheet-geometry.html):
-    how to specify which cells to read
--   [readxl
-    Workflows](https://readxl.tidyverse.org/articles/articles/readxl-workflows.html):
-    Iterating over multiple tabs or worksheets, stashing a csv snapshot
+- [Cell and Column
+  Types](https://readxl.tidyverse.org/articles/cell-and-column-types.html)
+- [Sheet
+  Geometry](https://readxl.tidyverse.org/articles/sheet-geometry.html):
+  how to specify which cells to read
+- [readxl
+  Workflows](https://readxl.tidyverse.org/articles/articles/readxl-workflows.html):
+  Iterating over multiple tabs or worksheets, stashing a csv snapshot
 
 We also have some focused articles that address specific aggravations
 presented by the world’s spreadsheets:
 
--   [Column
-    Names](https://readxl.tidyverse.org/articles/articles/column-names.html)
--   [Multiple Header
-    Rows](https://readxl.tidyverse.org/articles/articles/multiple-header-rows.html)
+- [Column
+  Names](https://readxl.tidyverse.org/articles/articles/column-names.html)
+- [Multiple Header
+  Rows](https://readxl.tidyverse.org/articles/articles/multiple-header-rows.html)
 
 ## Features
 
--   No external dependency on, e.g., Java or Perl.
+- No external dependency on, e.g., Java or Perl.
 
--   Re-encodes non-ASCII characters to UTF-8.
+- Re-encodes non-ASCII characters to UTF-8.
 
--   Loads datetimes into POSIXct columns. Both Windows (1900) and
-    Mac (1904) date specifications are processed correctly.
+- Loads datetimes into POSIXct columns. Both Windows (1900) and
+  Mac (1904) date specifications are processed correctly.
 
--   Discovers the minimal data rectangle and returns that, by default.
-    User can exert more control with `range`, `skip`, and `n_max`.
+- Discovers the minimal data rectangle and returns that, by default.
+  User can exert more control with `range`, `skip`, and `n_max`.
 
--   Column names and types are determined from the data in the sheet, by
-    default. User can also supply via `col_names` and `col_types` and
-    control name repair via `.name_repair`.
+- Column names and types are determined from the data in the sheet, by
+  default. User can also supply via `col_names` and `col_types` and
+  control name repair via `.name_repair`.
 
--   Returns a
-    [tibble](https://tibble.tidyverse.org/reference/tibble.html), i.e. a
-    data frame with an additional `tbl_df` class. Among other things,
-    this provide nicer printing.
+- Returns a
+  [tibble](https://tibble.tidyverse.org/reference/tibble.html), i.e. a
+  data frame with an additional `tbl_df` class. Among other things, this
+  provide nicer printing.
 
 ## Other relevant packages
 

---FILE: man/readxl-package.Rd---
@@ -8,7 +8,7 @@
 \description{
 \if{html}{\figure{logo.png}{options: style='float: right' alt='logo' width='120'}}
 
-Import excel files into R. Supports '.xls' via the embedded 'libxls' C library \url{https://github.com/libxls/libxls} and '.xlsx' via the embedded 'RapidXML' C++ library \url{http://rapidxml.sourceforge.net}. Works on Windows, Mac and Linux without external dependencies.
+Import excel files into R. Supports '.xls' via the embedded 'libxls' C library \url{https://github.com/libxls/libxls} and '.xlsx' via the embedded 'RapidXML' C++ library \url{https://rapidxml.sourceforge.net/}. Works on Windows, Mac and Linux without external dependencies.
 }
 \seealso{
 Useful links:

---FILE: vignettes/cell-and-column-types.Rmd---
@@ -150,7 +150,7 @@ knitr::include_graphics(""img/type-me-logical.png"")
 
 ### Numeric column
 
-A boolean cell is coerced to zero if `FALSE` and one if `TRUE`. A datetime comes in as the underlying serial date, which is the number of days, possibly fractional, since the [date origin](https://docs.microsoft.com/en-US/office/troubleshoot/excel/1900-and-1904-date-system). For text, numeric conversion is attempted, to handle the ""number as text"" phenomenon. If unsuccessful, text cells import as `NA`.
+A boolean cell is coerced to zero if `FALSE` and one if `TRUE`. A datetime comes in as the underlying serial date, which is the number of days, possibly fractional, since the [date origin](https://learn.microsoft.com/en-US/office/troubleshoot/excel/1900-and-1904-date-system). For text, numeric conversion is attempted, to handle the ""number as text"" phenomenon. If unsuccessful, text cells import as `NA`.
 
 ```{r}
 df <- read_excel(readxl_example(""type-me.xlsx""), sheet = ""numeric_coercion"",",False,True,Documentation / Formatting,6
tidyverse,readxl,e98cfcd4244d38b069594adc776eed0c414847da,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2023-02-07T20:20:44Z,GitHub,noreply@github.com,2023-02-07T20:20:44Z,"Update libxls (#721)

* Update to dev version of libxls

* git apply maintenance/patches/filepaths.patch

* git apply maintenance/patches/cran.patch

* git apply maintenance/patches/locale.patch

* git apply maintenance/patches/strict-prototypes.patch

* git apply maintenance/patches/snprintf.patch

* Updates notes re: applying patches

* Add NEWS bullets",DESCRIPTION;NEWS.md;maintenance/01_pull-from-libxls-upstream.R;maintenance/02_apply-our-libxls-patches.txt;src/libxls/ole.c;src/libxls/ole.h;src/libxls/xls.c;src/libxls/xls.h;src/libxls/xlsstruct.h,False,True,True,False,56,15,71,"---FILE: DESCRIPTION---
@@ -48,7 +48,7 @@ VignetteBuilder:
 Config/Needs/website: tidyverse/tidytemplate, tidyverse
 Config/testthat/edition: 3
 Encoding: UTF-8
-Note: libxls v1.6.2 4482400
+Note: libxls v1.6.2 (patched) 45abe77
 Roxygen: list(markdown = TRUE)
 RoxygenNote: 7.2.3
 SystemRequirements: C++11

---FILE: NEWS.md---
@@ -1,5 +1,13 @@
 # readxl (development version)
 
+Embeds a development version of libxls, which is based on the most recent released version, v1.6.2.
+The libxls project is hosted at <https://github.com/libxls/libxls>.
+The reason for embedding a development version is to ship a version of libxls that incorporates the fix for this CVE (#679):
+
+  * [CVE-2021-27836](https://nvd.nist.gov/vuln/detail/CVE-2021-27836)
+
+Other small readxl-specific patches have been made to the embedded libxls code to comply with CRAN requests, such as avoiding the use of `sprintf()`.
+
 # readxl 1.4.1
 
 Help files below `man/` have been re-generated, so that they give rise to valid HTML5. (This is the impetus for this release, to keep the package safely on CRAN.)

---FILE: maintenance/01_pull-from-libxls-upstream.R---
@@ -6,19 +6,22 @@ library(desc)
 
 libxls_path <- ""~/rrr/libxls""
 there <- function(x) path(libxls_path, x)
+target_branch <- ""dev"" # usually this is master, but not today
 
-if (git_branch(repo = libxls_path) != ""master"") {
-  message(""YO! You are not on master in libxls! Are you sure about this?"")
+if (git_branch(repo = libxls_path) != target_branch) {
+  message(""YO! You are not on the target branch in libxls!"")
 }
 
-target_version <- ""v1.6.2""
-(tag <- git_tag_list(target_version, repo = libxls_path))
+# relevant when I am embedding an official release
+#target_version <- ""v1.6.2""
+#(tag <- git_tag_list(target_version, repo = libxls_path))
 
 libxls_SHA <- git_commit_id(repo = libxls_path)
 
-if (tag$commit != libxls_SHA) {
-   message(""YO! SHA associated with HEAD isn't associated with target version!"")
-}
+# relevant when I am embedding an official release
+# if (tag$commit != libxls_SHA) {
+#    message(""YO! SHA associated with HEAD isn't associated with target version!"")
+# }
 
 # the subset of libxls files that we embed
 paths <- c(
@@ -44,6 +47,8 @@ file_copy(
   overwrite = TRUE
 )
 
+# fixup for the case where I'm embedding a dev version
+target_version <- ""v1.6.2 (patched)""
 desc::desc_set(Note = paste(""libxls"", target_version, substr(libxls_SHA, 1, 7)))
 
 # as needed, I rerun the configure script to regenerate

---FILE: maintenance/02_apply-our-libxls-patches.txt---
@@ -18,22 +18,23 @@
 # I implemented the filepath changes (and only the filepath changes) and did:
 # git diff ':!maintenance/02_apply-our-libxls-patches.txt' > maintenance/patches/filepaths.patch
 # https://stackoverflow.com/questions/10415100/exclude-file-from-git-diff
-
 # undo those changes
-
-# apply the changes by applying a patch
 # git apply maintenance/patches/filepaths.patch
 
 # Implement the change where we mask functions cran doesn't like in this file:
 # src/libxls/xlstypes.h
 # then make the .patch file
 # git diff ':!maintenance/02_apply-our-libxls-patches.txt' > maintenance/patches/cran.patch
+# undo those changes
+# git apply maintenance/patches/cran.patch
 
 # Implement the locale related changes in
 # src/libxls/locale.c
 # src/libxls/locale.h
 # then make the .patch file
 # git diff ':!maintenance/02_apply-our-libxls-patches.txt' > maintenance/patches/locale.patch
+# undo those changes
+# git apply maintenance/patches/locale.patch
 
 # Implement the fix for this warning:
 # libxls/endian.c:38:21: warning: a function declaration without a prototype is deprecated in all versions of C [-Wstrict-prototypes]

---FILE: src/libxls/ole.c---
@@ -741,6 +741,11 @@ static ssize_t read_MSAT_body(OLE2 *ole2, DWORD sectorOffset, DWORD sectorCount)
                 sectorNum++;
             }
         }
+        if (sid == sector[posInSector]) {
+            if (xls_debug) fprintf(stderr, ""Error: Loop detected in sector #%d\n"", sid);
+            total_bytes_read = -1;
+            goto cleanup;
+        }
         sid = sector[posInSector];
         //printf(""   s[%d]=%d (0x%x)\n"", posInSector, sid, sid);
     }

---FILE: src/libxls/ole.h---
@@ -36,6 +36,11 @@
 #ifndef OLE_INCLUDE
 #define OLE_INCLUDE
 
+#ifdef _MSC_VER
+#include <BaseTsd.h>
+typedef SSIZE_T ssize_t;
+#endif
+
 #ifdef __cplusplus
 #include <cstdio>			// FILE *
 #else

---FILE: src/libxls/xls.c---
@@ -133,7 +133,7 @@ static xls_error_t xls_addSST(xlsWorkBook* pWB,SST* sst,DWORD size)
     pWB->sst.lastrt=0;
     pWB->sst.lastsz=0;
 
-    if (sst->num > (1<<24))
+    if (sst->num > (1<<26)) // 64 MB
         return LIBXLS_ERROR_MALLOC;
 
     if (pWB->sst.string)
@@ -390,8 +390,10 @@ static xls_error_t xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET *bs, DWORD size)
 	}
 
     pWB->sheets.sheet = realloc(pWB->sheets.sheet,(pWB->sheets.count+1)*sizeof (struct st_sheet_data));
-    if (pWB->sheets.sheet == NULL)
+    if (pWB->sheets.sheet == NULL) {
+        free(name);
         return LIBXLS_ERROR_MALLOC;
+    }
 
     pWB->sheets.sheet[pWB->sheets.count].name=name;
     pWB->sheets.sheet[pWB->sheets.count].filepos=filepos;
@@ -830,6 +832,8 @@ int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1) {
 
 xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 {
+    if(!pWB) return LIBXLS_ERROR_NULL_ARGUMENT;
+
     BOF bof1 = { .id = 0, .size = 0 };
     BOF bof2 = { .id = 0, .size = 0 };
     BYTE* buf = NULL;
@@ -1039,6 +1043,10 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 				printf(""   mode: 0x%x\n"", pWB->is1904);
 			}
 			break;
+
+		case XLS_RECORD_FILEPASS:
+			retval = LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION;
+			goto cleanup;
 		
 		case XLS_RECORD_DEFINEDNAME:
 			if(xls_debug) {
@@ -1053,7 +1061,7 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 			if(xls_debug)
 			{
 				//xls_showBOF(&bof1);
-				printf(""    Not Processed in parseWoorkBook():  BOF=0x%4.4X size=%d\n"", bof1.id, bof1.size);
+				printf(""    Not Processed in parseWorkBook():  BOF=0x%4.4X size=%d\n"", bof1.id, bof1.size);
 			}
             break;
         }
@@ -1072,6 +1080,8 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 
 static xls_error_t xls_preparseWorkSheet(xlsWorkSheet* pWS)
 {
+    if(!pWS) return LIBXLS_ERROR_NULL_ARGUMENT;
+
     BOF tmp;
     BYTE* buf = NULL;
     xls_error_t retval = LIBXLS_OK;
@@ -1221,6 +1231,8 @@ static xls_error_t xls_formatColumn(xlsWorkSheet* pWS)
 
 xls_error_t xls_parseWorkSheet(xlsWorkSheet* pWS)
 {
+    if(!pWS) return LIBXLS_ERROR_NULL_ARGUMENT;
+
     BOF tmp;
     BYTE* buf = NULL;
 	long offset = pWS->filepos;
@@ -1653,6 +1665,8 @@ const char* xls_getError(xls_error_t code) {
         return ""Unable to allocate memory"";
     if (code == LIBXLS_ERROR_PARSE)
         return ""Unable to parse file"";
+    if (code == LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION)
+        return ""Unsupported encryption scheme"";
 
     return ""Unknown error"";
 }

---FILE: src/libxls/xls.h---
@@ -49,7 +49,9 @@ typedef enum {
     LIBXLS_ERROR_SEEK,
     LIBXLS_ERROR_READ,
     LIBXLS_ERROR_PARSE,
-    LIBXLS_ERROR_MALLOC
+    LIBXLS_ERROR_MALLOC,
+    LIBXLS_ERROR_UNSUPPORTED_ENCRYPTION,
+    LIBXLS_ERROR_NULL_ARGUMENT
 } xls_error_t;
 
 const char* xls_getVersion(void);

---FILE: src/libxls/xlsstruct.h---
@@ -42,6 +42,7 @@
 #define XLS_RECORD_DEFINEDNAME  0x0018
 #define XLS_RECORD_NOTE         0x001C
 #define XLS_RECORD_1904         0x0022
+#define XLS_RECORD_FILEPASS     0x002F
 #define XLS_RECORD_CONTINUE     0x003C
 #define XLS_RECORD_WINDOW1      0x003D
 #define XLS_RECORD_CODEPAGE     0x0042",True,False,Dependency / Package,7
tidyverse,readxl,5cc61e33f726be9f758206d01c458feb63170b9e,Jenny Bryan,jenny.f.bryan@gmail.com,2023-02-07T17:37:07Z,Jenny Bryan,jenny.f.bryan@gmail.com,2023-02-07T17:37:07Z,"Create and apply patch re: sprintf()

thx @jeroen",maintenance/02_apply-our-libxls-patches.txt;maintenance/patches/snprintf.patch;src/libxls/xlstool.c,False,False,False,False,122,19,141,"---FILE: maintenance/02_apply-our-libxls-patches.txt---
@@ -43,3 +43,7 @@
 # discard changes
 # git apply maintenance/patches/strict-prototypes.patch
 
+# Implement the snprintf() for sprintf() swap:
+# git diff ':!maintenance/02_apply-our-libxls-patches.txt' > maintenance/patches/snprintf.patch
+# discard changes
+# git apply maintenance/patches/snprintf.patch

---FILE: maintenance/patches/snprintf.patch---
@@ -0,0 +1,99 @@
+diff --git a/src/libxls/xlstool.c b/src/libxls/xlstool.c
+index 1bede81..6e3a096 100644
+--- a/src/libxls/xlstool.c
++++ b/src/libxls/xlstool.c
+@@ -780,62 +780,62 @@ char* xls_getCSS(xlsWorkBook* pWB)
+         switch (xf->linestyle & 0x0f)
+         {
+         case 0:
+-            sprintf(borderleft,""%s"", """");
++            snprintf(borderleft, 255, ""%s"", """");
+             break;
+         default:
+-            sprintf(borderleft,""border-left: 1px solid black;"");
++            snprintf(borderleft, 255, ""border-left: 1px solid black;"");
+             break;
+         }
+ 
+         switch (xf->linestyle & 0x0f0)
+         {
+         case 0:
+-            sprintf(borderright,""%s"", """");
++            snprintf(borderright, 255, ""%s"", """");
+             break;
+         default:
+-            sprintf(borderright,""border-right: 1px solid black;"");
++            snprintf(borderright, 255, ""border-right: 1px solid black;"");
+             break;
+         }
+ 
+         switch (xf->linestyle & 0x0f00)
+         {
+         case 0:
+-            sprintf(bordertop,""%s"", """");
++            snprintf(bordertop, 255, ""%s"", """");
+             break;
+         default:
+-            sprintf(bordertop,""border-top: 1px solid black;"");
++            snprintf(bordertop, 255, ""border-top: 1px solid black;"");
+             break;
+         }
+ 
+         switch (xf->linestyle & 0x0f000)
+         {
+         case 0:
+-            sprintf(borderbottom,""%s"", """");
++            snprintf(borderbottom, 255, ""%s"", """");
+             break;
+         default:
+-            sprintf(borderbottom,""border-bottom: 1px solid Black;"");
++            snprintf(borderbottom, 255, ""border-bottom: 1px solid Black;"");
+             break;
+         }
+ 
+         if (xf->font)
+-            sprintf(color,""color:#%.6X;"",xls_getColor(pWB->fonts.font[xf->font-1].color,0));
++            snprintf(color, 255, ""color:#%.6X;"",xls_getColor(pWB->fonts.font[xf->font-1].color,0));
+         else
+-            sprintf(color,""%s"", """");
++            snprintf(color, 255, ""%s"", """");
+ 
+         if (xf->font && (pWB->fonts.font[xf->font-1].flag & 2))
+-            sprintf(italic,""font-style: italic;"");
++            snprintf(italic, 255, ""font-style: italic;"");
+         else
+-            sprintf(italic,""%s"", """");
++            snprintf(italic, 255, ""%s"", """");
+ 
+         if (xf->font && (pWB->fonts.font[xf->font-1].bold>400))
+-            sprintf(bold,""font-weight: bold;"");
++            snprintf(bold, 255, ""font-weight: bold;"");
+         else
+-            sprintf(bold,""%s"", """");
++            snprintf(bold, 255, ""%s"", """");
+ 
+         if (xf->font && (pWB->fonts.font[xf->font-1].underline))
+-            sprintf(underline,""text-decoration: underline;"");
++            snprintf(underline, 255, ""text-decoration: underline;"");
+         else
+-            sprintf(underline,""%s"", """");
++            snprintf(underline, 255, ""%s"", """");
+ 
+         if (xf->font)
+             size=pWB->fonts.font[xf->font-1].height/20;
+@@ -843,12 +843,12 @@ char* xls_getCSS(xlsWorkBook* pWB)
+             size=10;
+ 
+         if (xf->font)
+-            sprintf(fontname,""%s"",pWB->fonts.font[xf->font-1].name);
++            snprintf(fontname, 255,""%s"",pWB->fonts.font[xf->font-1].name);
+         else
+-            sprintf(fontname,""Arial"");
++            snprintf(fontname, 255,""Arial"");
+ 
+         background=xls_getColor((WORD)(xf->groundcolor & 0x7f),1);
+-        sprintf(buf,"".xf%i{ font-size:%ipt;font-family: \""%s\"";background:#%.6X;text-align:%s;vertical-align:%s;%s%s%s%s%s%s%s%s}\n"",
++        snprintf(buf, 4096, "".xf%i{ font-size:%ipt;font-family: \""%s\"";background:#%.6X;text-align:%s;vertical-align:%s;%s%s%s%s%s%s%s%s}\n"",
+                 i,size,fontname,background,align,valign,borderleft,borderright,bordertop,borderbottom,color,italic,bold,underline);
+ 
+ 		strcat(ret,buf);

---FILE: src/libxls/xlstool.c---
@@ -780,75 +780,75 @@ char* xls_getCSS(xlsWorkBook* pWB)
         switch (xf->linestyle & 0x0f)
         {
         case 0:
-            sprintf(borderleft,""%s"", """");
+            snprintf(borderleft, 255, ""%s"", """");
             break;
         default:
-            sprintf(borderleft,""border-left: 1px solid black;"");
+            snprintf(borderleft, 255, ""border-left: 1px solid black;"");
             break;
         }
 
         switch (xf->linestyle & 0x0f0)
         {
         case 0:
-            sprintf(borderright,""%s"", """");
+            snprintf(borderright, 255, ""%s"", """");
             break;
         default:
-            sprintf(borderright,""border-right: 1px solid black;"");
+            snprintf(borderright, 255, ""border-right: 1px solid black;"");
             break;
         }
 
         switch (xf->linestyle & 0x0f00)
         {
         case 0:
-            sprintf(bordertop,""%s"", """");
+            snprintf(bordertop, 255, ""%s"", """");
             break;
         default:
-            sprintf(bordertop,""border-top: 1px solid black;"");
+            snprintf(bordertop, 255, ""border-top: 1px solid black;"");
             break;
         }
 
         switch (xf->linestyle & 0x0f000)
         {
         case 0:
-            sprintf(borderbottom,""%s"", """");
+            snprintf(borderbottom, 255, ""%s"", """");
             break;
         default:
-            sprintf(borderbottom,""border-bottom: 1px solid Black;"");
+            snprintf(borderbottom, 255, ""border-bottom: 1px solid Black;"");
             break;
         }
 
         if (xf->font)
-            sprintf(color,""color:#%.6X;"",xls_getColor(pWB->fonts.font[xf->font-1].color,0));
+            snprintf(color, 255, ""color:#%.6X;"",xls_getColor(pWB->fonts.font[xf->font-1].color,0));
         else
-            sprintf(color,""%s"", """");
+            snprintf(color, 255, ""%s"", """");
 
         if (xf->font && (pWB->fonts.font[xf->font-1].flag & 2))
-            sprintf(italic,""font-style: italic;"");
+            snprintf(italic, 255, ""font-style: italic;"");
         else
-            sprintf(italic,""%s"", """");
+            snprintf(italic, 255, ""%s"", """");
 
         if (xf->font && (pWB->fonts.font[xf->font-1].bold>400))
-            sprintf(bold,""font-weight: bold;"");
+            snprintf(bold, 255, ""font-weight: bold;"");
         else
-            sprintf(bold,""%s"", """");
+            snprintf(bold, 255, ""%s"", """");
 
         if (xf->font && (pWB->fonts.font[xf->font-1].underline))
-            sprintf(underline,""text-decoration: underline;"");
+            snprintf(underline, 255, ""text-decoration: underline;"");
         else
-            sprintf(underline,""%s"", """");
+            snprintf(underline, 255, ""%s"", """");
 
         if (xf->font)
             size=pWB->fonts.font[xf->font-1].height/20;
         else
             size=10;
 
         if (xf->font)
-            sprintf(fontname,""%s"",pWB->fonts.font[xf->font-1].name);
+            snprintf(fontname, 255,""%s"",pWB->fonts.font[xf->font-1].name);
         else
-            sprintf(fontname,""Arial"");
+            snprintf(fontname, 255,""Arial"");
 
         background=xls_getColor((WORD)(xf->groundcolor & 0x7f),1);
-        sprintf(buf,"".xf%i{ font-size:%ipt;font-family: \""%s\"";background:#%.6X;text-align:%s;vertical-align:%s;%s%s%s%s%s%s%s%s}\n"",
+        snprintf(buf, 4096, "".xf%i{ font-size:%ipt;font-family: \""%s\"";background:#%.6X;text-align:%s;vertical-align:%s;%s%s%s%s%s%s%s%s}\n"",
                 i,size,fontname,background,align,valign,borderleft,borderright,bordertop,borderbottom,color,italic,bold,underline);
 
 		strcat(ret,buf);",False,False,Implementation / Logic,3
tidyverse,readxl,afdc9b90cfc2bb1e1c5490c7ba3af5ecfc4a7876,Jenny Bryan,jenny.f.bryan@gmail.com,2023-02-07T17:33:54Z,Jenny Bryan,jenny.f.bryan@gmail.com,2023-02-07T17:33:54Z,"Create and apply patch re: strict-prototypes warning

thx @jeroen",maintenance/02_apply-our-libxls-patches.txt;maintenance/patches/strict-prototypes.patch;src/libxls/endian.c;src/libxls/locale.c,False,False,False,False,37,2,39,"---FILE: maintenance/02_apply-our-libxls-patches.txt---
@@ -34,3 +34,12 @@
 # src/libxls/locale.h
 # then make the .patch file
 # git diff ':!maintenance/02_apply-our-libxls-patches.txt' > maintenance/patches/locale.patch
+
+# Implement the fix for this warning:
+# libxls/endian.c:38:21: warning: a function declaration without a prototype is deprecated in all versions of C [-Wstrict-prototypes]
+# libxls/locale.c:50:30: warning: a function declaration without a prototype is deprecated in all versions of C [-Wstrict-prototypes]
+# then make the .patch file
+# git diff ':!maintenance/02_apply-our-libxls-patches.txt' > maintenance/patches/strict-prototypes.patch
+# discard changes
+# git apply maintenance/patches/strict-prototypes.patch
+

---FILE: maintenance/patches/strict-prototypes.patch---
@@ -0,0 +1,26 @@
+diff --git a/src/libxls/endian.c b/src/libxls/endian.c
+index f126936..3c41050 100644
+--- a/src/libxls/endian.c
++++ b/src/libxls/endian.c
+@@ -35,7 +35,7 @@
+ #include ""libxls/endian.h""
+ #include ""libxls/ole.h""
+ 
+-int xls_is_bigendian()
++int xls_is_bigendian(void)
+ {
+ #if defined (__BIG_ENDIAN__)
+     return 1;
+diff --git a/src/libxls/locale.c b/src/libxls/locale.c
+index 8f8eb35..8dcdcce 100644
+--- a/src/libxls/locale.c
++++ b/src/libxls/locale.c
+@@ -47,7 +47,7 @@
+     static char* old_locale;
+ #endif
+ 
+-xls_locale_t xls_createlocale() {
++xls_locale_t xls_createlocale(void) {
+ #if defined(WINDOWS_BEFORE_RTOOLS_42)
+     old_locale = setlocale(LC_CTYPE, "".65001"");
+     return NULL;

---FILE: src/libxls/endian.c---
@@ -35,7 +35,7 @@
 #include ""libxls/endian.h""
 #include ""libxls/ole.h""
 
-int xls_is_bigendian()
+int xls_is_bigendian(void)
 {
 #if defined (__BIG_ENDIAN__)
     return 1;

---FILE: src/libxls/locale.c---
@@ -47,7 +47,7 @@
     static char* old_locale;
 #endif
 
-xls_locale_t xls_createlocale() {
+xls_locale_t xls_createlocale(void) {
 #if defined(WINDOWS_BEFORE_RTOOLS_42)
     old_locale = setlocale(LC_CTYPE, "".65001"");
     return NULL;",False,False,Implementation / Logic,3
tidyverse,readxl,9104e69b37a7783974582cb6956a26f6932d2a56,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2023-02-07T16:43:41Z,GitHub,noreply@github.com,2023-02-07T16:43:41Z,"Begin the structured tracking and application of patches to vendored code (#720)

* Move existing libxls-ingesting-and-patching script to maintenance/

* Re-vendor libxls files

* Create patch file re: filepath changes

* git apply maintenance/patches/filepaths.patch

* This is not an R file

* Create patch around the masking in cran.h

* git apply maintenance/patches/cran.patch

* Create the patch around locale

* git apply maintenance/patches/locale.patch",.Rbuildignore;maintenance/01_pull-from-libxls-upstream.R;maintenance/02_apply-our-libxls-patches.txt;maintenance/patches/cran.patch;maintenance/patches/filepaths.patch;maintenance/patches/locale.patch;src/libxls/xlstypes.h,False,True,True,False,275,1,276,"---FILE: .Rbuildignore---
@@ -34,3 +34,4 @@
 ^\.vscode$
 ^debug$
 ^CRAN-SUBMISSION$
+^maintenance$

---FILE: maintenance/02_apply-our-libxls-patches.txt---
@@ -0,0 +1,36 @@
+# https://stackoverflow.com/questions/6336440/how-can-i-make-git-am-git-apply-work-fuzzy-like-the-patch-command
+# https://www.thegeekstuff.com/2014/12/patch-command-examples/
+
+# files that need a patch only related to filepaths
+# src/libxls/brdb.h
+# src/libxls/endian.c
+# src/libxls/endian.h
+# src/libxls/ole.c
+# src/libxls/ole.h
+# src/libxls/xls.c
+# src/libxls/xlsstruct.h
+# src/libxls/xlstool.c
+# src/libxls/xlstool.h
+
+# file that has a patch related to filepaths (but also other patches)
+# src/libxls/locale.c
+
+# I implemented the filepath changes (and only the filepath changes) and did:
+# git diff ':!maintenance/02_apply-our-libxls-patches.txt' > maintenance/patches/filepaths.patch
+# https://stackoverflow.com/questions/10415100/exclude-file-from-git-diff
+
+# undo those changes
+
+# apply the changes by applying a patch
+# git apply maintenance/patches/filepaths.patch
+
+# Implement the change where we mask functions cran doesn't like in this file:
+# src/libxls/xlstypes.h
+# then make the .patch file
+# git diff ':!maintenance/02_apply-our-libxls-patches.txt' > maintenance/patches/cran.patch
+
+# Implement the locale related changes in
+# src/libxls/locale.c
+# src/libxls/locale.h
+# then make the .patch file
+# git diff ':!maintenance/02_apply-our-libxls-patches.txt' > maintenance/patches/locale.patch

---FILE: maintenance/patches/cran.patch---
@@ -0,0 +1,15 @@
+diff --git a/src/libxls/xlstypes.h b/src/libxls/xlstypes.h
+index 52da772..fb68147 100644
+--- a/src/libxls/xlstypes.h
++++ b/src/libxls/xlstypes.h
+@@ -36,6 +36,10 @@
+ #ifndef XLS_TYPES_INC
+ #define XLS_TYPES_INC
+ 
++/* Mask illegal functions for CMD check */
++/* an analysis of header file includes shows that doing this here covers everything */
++#include ""cran.h""
++
+ #ifdef __cplusplus
+ #include <cstdint>
+ #else

---FILE: maintenance/patches/filepaths.patch---
@@ -0,0 +1,152 @@
+diff --git a/src/libxls/brdb.h b/src/libxls/brdb.h
+index a84b7d6..08698a2 100644
+--- a/src/libxls/brdb.h
++++ b/src/libxls/brdb.h
+@@ -43,7 +43,7 @@ typedef struct str_brdb record_brdb;
+ 
+ record_brdb brdb[] =
+     {
+-#include ""../libxls/brdb.c.h""
++#include ""libxls/brdb.c.h""
+     };
+ 
+ static int get_brbdnum(int id)
+diff --git a/src/libxls/endian.c b/src/libxls/endian.c
+index 1b5032f..f126936 100644
+--- a/src/libxls/endian.c
++++ b/src/libxls/endian.c
+@@ -31,9 +31,9 @@
+ 
+ #include <stdlib.h>
+ 
+-#include ""../include/libxls/xlstypes.h""
+-#include ""../include/libxls/endian.h""
+-#include ""../include/libxls/ole.h""
++#include ""libxls/xlstypes.h""
++#include ""libxls/endian.h""
++#include ""libxls/ole.h""
+ 
+ int xls_is_bigendian()
+ {
+diff --git a/src/libxls/endian.h b/src/libxls/endian.h
+index 68a7c75..8315da8 100644
+--- a/src/libxls/endian.h
++++ b/src/libxls/endian.h
+@@ -29,7 +29,7 @@
+  *
+  */
+ 
+-#include ""../libxls/xlsstruct.h""
++#include ""libxls/xlsstruct.h""
+ 
+ int xls_is_bigendian(void);
+ DWORD xlsIntVal (DWORD i);
+diff --git a/src/libxls/locale.c b/src/libxls/locale.c
+index 65b5b28..f8fc4a9 100644
+--- a/src/libxls/locale.c
++++ b/src/libxls/locale.c
+@@ -30,7 +30,7 @@
+  */
+ #include ""config.h""
+ #include <stdlib.h>
+-#include ""../include/libxls/locale.h""
++#include ""libxls/locale.h""
+ 
+ xls_locale_t xls_createlocale() {
+ #if defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
+diff --git a/src/libxls/ole.c b/src/libxls/ole.c
+index 082ac2a..90527ee 100644
+--- a/src/libxls/ole.c
++++ b/src/libxls/ole.c
+@@ -40,9 +40,9 @@
+ #include <stdio.h>
+ #include <stdlib.h>
+ 
+-#include ""../include/libxls/ole.h""
+-#include ""../include/libxls/xlstool.h""
+-#include ""../include/libxls/endian.h""
++#include ""libxls/ole.h""
++#include ""libxls/xlstool.h""
++#include ""libxls/endian.h""
+ 
+ extern int xls_debug;
+ 
+diff --git a/src/libxls/ole.h b/src/libxls/ole.h
+index 09e802e..b376299 100644
+--- a/src/libxls/ole.h
++++ b/src/libxls/ole.h
+@@ -42,7 +42,7 @@
+ #include <stdio.h>			// FILE *
+ #endif
+ 
+-#include ""../libxls/xlstypes.h""
++#include ""libxls/xlstypes.h""
+ 
+ #if defined(_AIX) || defined(__sun)
+ #pragma pack(1)
+diff --git a/src/libxls/xls.c b/src/libxls/xls.c
+index fcbcacc..cf17895 100644
+--- a/src/libxls/xls.c
++++ b/src/libxls/xls.c
+@@ -49,9 +49,9 @@
+ #include <string.h>
+ #include <wchar.h>
+ 
+-#include ""../include/libxls/endian.h""
+-#include ""../include/libxls/locale.h""
+-#include ""../include/xls.h""
++#include ""libxls/endian.h""
++#include ""libxls/locale.h""
++#include ""libxls/xls.h""
+ 
+ #ifndef min
+ #define min(a,b) ((a) < (b) ? (a) : (b))
+diff --git a/src/libxls/xlsstruct.h b/src/libxls/xlsstruct.h
+index cfa3a96..9878506 100644
+--- a/src/libxls/xlsstruct.h
++++ b/src/libxls/xlsstruct.h
+@@ -36,7 +36,7 @@
+ #ifndef XLS_STRUCT_INC
+ #define XLS_STRUCT_INC
+ 
+-#include ""../libxls/ole.h""
++#include ""libxls/ole.h""
+ 
+ #define XLS_RECORD_EOF          0x000A
+ #define XLS_RECORD_DEFINEDNAME  0x0018
+diff --git a/src/libxls/xlstool.c b/src/libxls/xlstool.c
+index 14df59a..1bede81 100644
+--- a/src/libxls/xlstool.c
++++ b/src/libxls/xlstool.c
+@@ -50,12 +50,12 @@
+ #include <string.h>
+ 
+ //#include ""xls.h""
+-#include ""../include/libxls/xlstypes.h""
+-#include ""../include/libxls/xlsstruct.h""
+-#include ""../include/libxls/xlstool.h""
+-#include ""../include/libxls/brdb.h""
+-#include ""../include/libxls/endian.h""
+-#include ""../include/libxls/locale.h""
++#include ""libxls/xlstypes.h""
++#include ""libxls/xlsstruct.h""
++#include ""libxls/xlstool.h""
++#include ""libxls/brdb.h""
++#include ""libxls/endian.h""
++#include ""libxls/locale.h""
+ 
+ extern int xls_debug;
+ 
+diff --git a/src/libxls/xlstool.h b/src/libxls/xlstool.h
+index 5c91529..ae1f04c 100644
+--- a/src/libxls/xlstool.h
++++ b/src/libxls/xlstool.h
+@@ -33,7 +33,7 @@
+  *
+  */
+ 
+-#include ""../libxls/xlsstruct.h""
++#include ""libxls/xlsstruct.h""
+ 
+ void verbose(char* str);
+ 

---FILE: maintenance/patches/locale.patch---
@@ -0,0 +1,70 @@
+diff --git a/src/libxls/locale.c b/src/libxls/locale.c
+index f8fc4a9..8f8eb35 100644
+--- a/src/libxls/locale.c
++++ b/src/libxls/locale.c
+@@ -32,8 +32,26 @@
+ #include <stdlib.h>
+ #include ""libxls/locale.h""
+ 
+-xls_locale_t xls_createlocale() {
+ #if defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
++#ifdef __GNUC__
++    // Rtools42 | R 4.2 | GCC 10 | UCRT
++    // Rtools40 | R 4.0.x to 4.1.x | GCC 8.3.0 | MSVCRT
++    // Rtools35 | R 3.3.x to 3.6.x | GCC 4.9.3 | MSVCRT
++    #if __GNUC__ < 10
++      #define WINDOWS_BEFORE_RTOOLS_42
++    #endif
++#endif
++#endif
++
++#ifdef WINDOWS_BEFORE_RTOOLS_42
++    static char* old_locale;
++#endif
++
++xls_locale_t xls_createlocale() {
++#if defined(WINDOWS_BEFORE_RTOOLS_42)
++    old_locale = setlocale(LC_CTYPE, "".65001"");
++    return NULL;
++#elif defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
+     return _create_locale(LC_CTYPE, "".65001"");
+ #else
+     return newlocale(LC_CTYPE_MASK, ""C.UTF-8"", NULL);
+@@ -41,6 +59,11 @@ xls_locale_t xls_createlocale() {
+ }
+ 
+ void xls_freelocale(xls_locale_t locale) {
++#if defined(WINDOWS_BEFORE_RTOOLS_42)
++    setlocale(LC_CTYPE, old_locale);
++    return;
++#endif
++
+     if (!locale)
+         return;
+ #if defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
+@@ -51,7 +74,9 @@ void xls_freelocale(xls_locale_t locale) {
+ }
+ 
+ size_t xls_wcstombs_l(char *restrict s, const wchar_t *restrict pwcs, size_t n, xls_locale_t loc) {
+-#if defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
++#if defined(WINDOWS_BEFORE_RTOOLS_42)
++    return wcstombs(s, pwcs, n);
++#elif defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
+     return _wcstombs_l(s, pwcs, n, loc);
+ #elif defined(HAVE_WCSTOMBS_L)
+     return wcstombs_l(s, pwcs, n, loc);
+diff --git a/src/libxls/locale.h b/src/libxls/locale.h
+index 3ae3911..b047739 100644
+--- a/src/libxls/locale.h
++++ b/src/libxls/locale.h
+@@ -35,6 +35,10 @@
+ 
+ #if defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
+ typedef _locale_t xls_locale_t;
++#elif defined(__sun)
++/* we never actually use the only variable declared with this type on solaris,
++ * so its precise type doesn't really matter */
++typedef void* xls_locale_t;
+ #else
+ typedef locale_t xls_locale_t;
+ #endif

---FILE: src/libxls/xlstypes.h---
@@ -37,7 +37,7 @@
 #define XLS_TYPES_INC
 
 /* Mask illegal functions for CMD check */
-/* an analysis header file includes shows that doing this here covers everything */
+/* an analysis of header file includes shows that doing this here covers everything */
 #include ""cran.h""
 
 #ifdef __cplusplus",True,False,Implementation / Logic,6
tidyverse,readxl,0e677ca9bf52de2d0079def459cfdba8c334c7aa,Stephen Connolly,stephen.alan.connolly@gmail.com,2022-09-15T06:12:42Z,GitHub,noreply@github.com,2022-09-15T06:12:42Z,"Fix compilation on Alpine Linux (redux) (#708)

Reverts the break of the fix from https://github.com/tidyverse/readxl/pull/687 in https://github.com/tidyverse/readxl/pull/687/commits/9884b53341e475ec984ebe2ff1182ff1347d06ad",src/SheetView.h,False,False,False,False,3,2,5,"---FILE: src/SheetView.h---
@@ -1,3 +1,6 @@
+#include <sys/time.h> // alpine linux / musl must be before others
+#include <unistd.h>   // alpine linux / musl must be before others
+
 #include ""CellLimits.h""
 #include ""ColSpec.h""
 #include ""XlsWorkBook.h""
@@ -12,8 +15,6 @@
 
 #include <algorithm>
 #include <string>
-#include <sys/time.h> // alpine linux / musl
-#include <unistd.h>   // alpine linux / musl
 #include <vector>
 
 class Xls {",False,False,Rendering / Conversion,0
tidyverse,readxl,b11916542a76d1ee189245745f46104bbe1df0cb,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2022-03-28T17:23:43Z,GitHub,noreply@github.com,2022-03-28T17:23:43Z,"Rework libxls locale patch (#694)

* Revert to locale.c from libxls v1.6.2

* Infer runtime from g++ / Rtools version

* More comments and whitespace

* Use the original category here

* Draw the line between Rtools40 and Rtools35

instead of between Rtools42 and predecessors

* Revert ""Draw the line between Rtools40 and Rtools35""

This reverts commit f61f3a61f5506ecc95ca76aaddbea95494e766bb.",src/libxls/locale.c,False,False,False,False,15,14,29,"---FILE: src/libxls/locale.c---
@@ -32,53 +32,54 @@
 #include <stdlib.h>
 #include ""libxls/locale.h""
 
-#ifdef __sun
-#include <string.h>
+#if defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
+#ifdef __GNUC__
+    // Rtools42 | R 4.2 | GCC 10 | UCRT
+    // Rtools40 | R 4.0.x to 4.1.x | GCC 8.3.0 | MSVCRT
+    // Rtools35 | R 3.3.x to 3.6.x | GCC 4.9.3 | MSVCRT
+    #if __GNUC__ < 10
+      #define WINDOWS_BEFORE_RTOOLS_42
+    #endif
+#endif
 #endif
 
-#if defined(__MINGW32__)
-  static char* old_locale;
+#ifdef WINDOWS_BEFORE_RTOOLS_42
+    static char* old_locale;
 #endif
 
 xls_locale_t xls_createlocale() {
-#if defined(__MINGW32__)
+#if defined(WINDOWS_BEFORE_RTOOLS_42)
     old_locale = setlocale(LC_CTYPE, "".65001"");
     return NULL;
 #elif defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
     return _create_locale(LC_CTYPE, "".65001"");
-#elif defined(__sun)
-    return NULL;
 #else
     return newlocale(LC_CTYPE_MASK, ""C.UTF-8"", NULL);
 #endif
 }
 
 void xls_freelocale(xls_locale_t locale) {
-#if defined(__MINGW32__)
-    setlocale(LC_ALL, old_locale);
+#if defined(WINDOWS_BEFORE_RTOOLS_42)
+    setlocale(LC_CTYPE, old_locale);
     return;
 #endif
 
     if (!locale)
         return;
 #if defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
     _free_locale(locale);
-#elif defined(__sun)
-   return;
 #else
     freelocale(locale);
 #endif
 }
 
 size_t xls_wcstombs_l(char *restrict s, const wchar_t *restrict pwcs, size_t n, xls_locale_t loc) {
-#if defined(__MINGW32__)
+#if defined(WINDOWS_BEFORE_RTOOLS_42)
     return wcstombs(s, pwcs, n);
 #elif defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
     return _wcstombs_l(s, pwcs, n, loc);
 #elif defined(HAVE_WCSTOMBS_L)
     return wcstombs_l(s, pwcs, n, loc);
-#elif defined(__sun)
-    return wcstombs(s, pwcs, n);
 #else
     locale_t oldlocale = uselocale(loc);
     size_t result = wcstombs(s, pwcs, n);",False,False,Implementation / Logic,3
tidyverse,readxl,a31c83c998d7a453d5cc0e1486f02b5d84108861,Duncan Garmonsway,nacnudus@gmail.com,2022-03-23T23:40:42Z,GitHub,noreply@github.com,2022-03-23T23:40:42Z,"Don't misinterpret colors as dates (#559)

* Don't misinterpret colors as dates (fixes #388)

* Incorporate some updates

* Add a test; tweak some tests

Add a test and test file based on a format where the confusion can come via currency, not colour.

Link to issues.

We generally incorporate `-xls` or `-xlsx` into test file names, so the format is obvious even if the file is open in Excel.

Added the actual implicit number formats in comments.

Co-authored-by: Jenny Bryan <jenny.f.bryan@gmail.com>",NEWS.md;src/ColSpec.h;tests/testthat/sheets/color-date-lowercase-xlsx.xlsx;tests/testthat/sheets/color-date-xls.xls;tests/testthat/sheets/color-date-xlsx.xlsx;tests/testthat/sheets/currency-formats-xlsx.xlsx;tests/testthat/test-dates.R,False,True,True,False,102,24,126,"---FILE: NEWS.md---
@@ -1,5 +1,10 @@
 # readxl (development version)
 
+* ""Date or Not Date"": The classification of number formats as being datetime-ish
+  is more sophisticated and should no longer be so easily fooled by, e.g.,
+  colours or currencies. This affects cell and column type guessing, hopefully
+  for the better (#388, #559, @nacnudus, @reviewher).
+
 * Cell location is determined more robustly in `.xlsx` files, guarding against
   the idiosyncratic way in which certain 3rd party tools include (or, rather,
   do not include) cell location in individual cell nodes (#648, #671).

---FILE: src/ColSpec.h---
@@ -148,35 +148,47 @@ bool inline isDateTime(int id, const std::set<int> custom) {
   return custom.count(id) > 0;
 }
 
+// Adapted from @reviewher https://github.com/tidyverse/readxl/issues/388
+// Similar code has long been used in https://github.com/nacnudus/tidyxl
+// See also ECMA Part 1 page 1785 (actual page 1795) section 18.8.31 ""numFmts
+// (Number Formats)""
+#define CASEI(c) case c: case (c | 0x20)
+#define CMPLC(j,n) if(x[i+j] | (0x20 == n))
 inline bool isDateFormat(std::string x) {
-  // TO FIX? So far no bug reports due to this.
-  // Logic below is too simple. For example, it deems this format string a date:
-  // ""$""#,##0_);[Red]\(""$""#,##0\)
-  // because of the `d` in `[Red]`
-  //
-  // Ideally this can wait until we are using something like
-  // https://github.com/WizardMac/TimeFormatStrings
-  // which presumably offers fancier ways to analyze format codes.
-  for (size_t i = 0; i < x.size(); ++i) {
-    switch (x[i]) {
-    case 'd':
-    case 'D':
-    case 'm': // 'mm' for minutes
-    case 'M':
-    case 'y':
-    case 'Y':
-    case 'h': // 'hh'
-    case 'H':
-    case 's': // 'ss'
-    case 'S':
-      return true;
-    default:
+  char escaped = 0;
+  char bracket = 0;
+  for (size_t i = 0; i < x.size(); ++i) switch (x[i]) {
+    CASEI('D'):
+    // https://github.com/nacnudus/tidyxl/pull/75
+    // CASEI('E'):
+    CASEI('H'):
+    CASEI('M'):
+    CASEI('S'):
+    CASEI('Y'):
+      if(!escaped && !bracket) return true;
       break;
-    }
+    case '""':
+      escaped = 1 - escaped; break;
+    case '\\':
+    case '_':
+      ++i;
+      break;
+    case '[': if(!escaped) bracket = 1; break;
+    case ']': if(!escaped) bracket = 0; break;
+    CASEI('G'):
+      if(i + 6 < x.size())
+      CMPLC(1,'e')
+      CMPLC(2,'n')
+      CMPLC(3,'e')
+      CMPLC(4,'r')
+      CMPLC(5,'a')
+      CMPLC(6,'l')
+        return false;
   }
-
   return false;
 }
+#undef CMPLC
+#undef CASEI
 
 inline std::vector<ColType> recycleTypes(std::vector<ColType> types,
                                          int ncol) {

---FILE: tests/testthat/test-dates.R---
@@ -51,3 +51,64 @@ test_that(""we get correct dates prior to March 1, 1900, in 1900 date system [xls
   expect_identical(df$dttm[!leap_day], dttms[!leap_day])
   expect_true(is.na(df$dttm[leap_day]))
 })
+
+# https://github.com/tidyverse/readxl/issues/388
+test_that(""colors in number formats aren't misinterpreted as dates"", {
+  # <numFmts count=""8"">
+  #   <numFmt numFmtId=""165"" formatCode=""[Red]0""/>
+  #   <numFmt numFmtId=""166"" formatCode=""[Black]0""/>
+  #   <numFmt numFmtId=""167"" formatCode=""[Green]0""/>
+  #   <numFmt numFmtId=""168"" formatCode=""[White]0""/>
+  #   <numFmt numFmtId=""169"" formatCode=""[Blue]0""/>
+  #   <numFmt numFmtId=""170"" formatCode=""[Magenta]0""/>
+  #   <numFmt numFmtId=""171"" formatCode=""[Yellow]0""/>
+  #   <numFmt numFmtId=""172"" formatCode=""[Cyan]0""/>
+  # </numFmts>
+  expect_warning(
+    read_xlsx(
+      test_sheet(""color-date-xlsx.xlsx""),
+      col_names = ""X1"",
+      col_types = ""numeric""
+    ),
+    NA # rather than ""Expecting numeric in A1 / R1C1: got a date"" etc.
+  )
+  expect_warning(
+    read_xls(
+      test_sheet(""color-date-xls.xls""),
+      col_names = ""X1"",
+      col_types = ""numeric""
+    ),
+    NA # rather than ""Expecting numeric in A1 / R1C1: got a date""
+  )
+
+  # <numFmts count=""8"">
+  #   <numFmt numFmtId=""165"" formatCode=""[red]0""/>
+  #   <numFmt numFmtId=""166"" formatCode=""[black]0""/>
+  #   <numFmt numFmtId=""167"" formatCode=""[green]0""/>
+  #   <numFmt numFmtId=""168"" formatCode=""[white]0""/>
+  #   <numFmt numFmtId=""169"" formatCode=""[blue]0""/>
+  #   <numFmt numFmtId=""170"" formatCode=""[magenta]0""/>
+  #   <numFmt numFmtId=""171"" formatCode=""[yellow]0""/>
+  #   <numFmt numFmtId=""172"" formatCode=""[cyan]0""/>
+  # </numFmts>
+  expect_warning(
+    read_xlsx(
+      test_sheet(""color-date-lowercase-xlsx.xlsx""),
+      col_names = ""X1"",
+      col_types = ""numeric""
+    ),
+    NA # rather than ""Expecting numeric in A1 / R1C1: got a date""
+  )
+})
+
+# https://github.com/tidyverse/readxl/issues/633
+test_that(""Swiss Francs (CHF) aren't misinterpreted as dates"", {
+  # <numFmts count=""2"">
+  #   <numFmt numFmtId=""164"" formatCode=""#,##0.00\ [$CHF]""/>
+  #   <numFmt numFmtId=""165"" formatCode=""#,##0.00\ [$EUR]""/>
+  # </numFmts>
+  dat <- read_xlsx(test_sheet(""currency-formats-xlsx.xlsx""))
+  expect_true(is.numeric(dat$cost_EUR))
+  expect_true(is.numeric(dat$cost_CHF))
+  expect_true(is.numeric(dat$cost_mixed))
+})",True,False,Documentation / Formatting,7
tidyverse,readxl,3ab4410e4456f00cda21863627809416782d02d3,Jenny Bryan,jenny.f.bryan@gmail.com,2022-03-22T16:57:17Z,Jenny Bryan,jenny.f.bryan@gmail.com,2022-03-22T16:59:19Z,"Use a row's self-declared number

Fixes #671

The example file is presumably created by a 3rd party tool. Another one of those tool's that (mostly) does not declare each cell's location and we have to (mostly) infer from location within the sheetData.

But the XML does always provide an explicit row number in the row after a completely missing row. We just weren't using this information before.

More detailed looks at the XML are given in the issue, where I originally said I wouldn't fix this. But then I realized it was a pretty easy fix.",NEWS.md;src/XlsxCellSet.h,False,False,False,False,11,2,13,"---FILE: NEWS.md---
@@ -2,7 +2,7 @@
 
 * Cell location is determined more robustly in `.xlsx` files, guarding against
   the idiosyncratic way in which certain 3rd party tools include (or, rather,
-  do not include) cell location in individual cell nodes (#648).
+  do not include) cell location in individual cell nodes (#648, #671).
 
 * Warning messages for impossible dates are more specific.
   Unsupported dates prior to 1900 have their own message now, instead of being

---FILE: src/XlsxCellSet.h---
@@ -14,6 +14,8 @@
 #include ""cpp11/sexp.hpp""
 #include ""cpp11/strings.hpp""
 
+#include <stdlib.h>
+
 // Page and section numbers below refer to
 // ECMA-376 (version, date, and download URL given in XlsxCell.h)
 // 18.3.1.73  row         (Row)        [p1685]
@@ -118,7 +120,14 @@ class XlsxCellSet {
     int i = 0;
     bool nominal_needs_checking = !shim && nominal_.maxRow() >= 0;
     for (; row; row = row->next_sibling(""row"")) {
+      // if row declares its number, take this opportunity to update i
+      // when it exists, this row number is 1-indexed, but i is 0-indexed
+      rapidxml::xml_attribute<>* ref = row->first_attribute(""r"");
+      if (ref) {
+        i = std::atoi(ref->value()) - 1;
+      }
       int j = 0;
+
       for (rapidxml::xml_node<>* cell = row->first_node(""c"");
            cell; cell = cell->next_sibling(""c"")) {
         count++;
@@ -128,7 +137,7 @@ class XlsxCellSet {
         }
 
         // if cell declares its location, take this opportunity to update i and j
-        rapidxml::xml_attribute<>* ref = cell->first_attribute(""r"");
+        ref = cell->first_attribute(""r"");
         if (ref) {
           std::pair<int, int> location = parseRef(ref->value());
           i = location.first;",False,False,Documentation / Formatting,3
tidyverse,readxl,78eb2c832ae45be7367041aeeac0daf3b08531b6,Jenny Bryan,jenny.f.bryan@gmail.com,2022-03-21T23:28:28Z,Jenny Bryan,jenny.f.bryan@gmail.com,2022-03-21T23:37:13Z,"Use a cell's self-declared location, even if it has no content we will use

Fixes #648

The example file is presumably created by a 3rd party tool. Another one of those tool's that (mostly) does not declare each cell's location and we have to (mostly) infer from location within the sheetData.

Here's what the start of the (first) afflicted row looks like in the sheetData node of the XML:

<row>
  [1] <c r=""B18043"" s=""52""/>
  [2] <c s=""33""/>
  [3] <c s=""28"" t=""s"">\n  <v>19594</v>\n</c>
  [4] <c s=""154"" t=""s"">\n  <v>2318</v>\n</c>
  [5] <c s=""101"" t=""s"">\n  <v>19550</v>\n</c>

Previously we were not using the B18043 location information.
So the first content-ful cell in this row was interpreted as belonging to the 3rd column (C), but it's really in the 4th column (D).

Now we take advantage of any cell that declares its location, even if we ultimately won't load this cell.",NEWS.md;debug/debug.R;src/XlsxCellSet.h,False,True,True,False,13,19,32,"---FILE: NEWS.md---
@@ -1,5 +1,9 @@
 # readxl (development version)
 
+* Cell location is determined more robustly in `.xlsx` files, guarding against
+  the idiosyncratic way in which certain 3rd party tools include (or, rather,
+  do not include) cell location in individual cell nodes (#648).
+
 * Warning messages for impossible dates are more specific.
   Unsupported dates prior to 1900 have their own message now, instead of being
   lumped in with dates on the non-existent day of February 29, 1900

---FILE: debug/debug.R---
@@ -1,20 +1,4 @@
 devtools::clean_dll()
 devtools::load_all()
 
-# success <- read_excel(
-#   ""investigations/sample_data/success.xls"",
-#   col_names = FALSE,
-#   range = ""A1""
-# )
-failure <- read_excel(""investigations/sample_data/failure.xls"", col_names=F)
-
-# cell_is_readable
-# cell->id is 214 for the failure
-# 214 in hexadecimal is 0xD6
-# in xlsstruct.h:
-# #define XLS_RECORD_RSTRING      0x00D6
-
-# cell->id is 516 for the success
-# 516 in hexadecimal is 0x204
-# in xlsstruct.h:
-# #define XLS_RECORD_LABEL        0x0204
+read_excel(""investigations/iss648-orig.xlsx"", sheet=2)

---FILE: src/XlsxCellSet.h---
@@ -127,6 +127,14 @@ class XlsxCellSet {
           cpp11::check_user_interrupt();
         }
 
+        // if cell declares its location, take this opportunity to update i and j
+        rapidxml::xml_attribute<>* ref = cell->first_attribute(""r"");
+        if (ref) {
+          std::pair<int, int> location = parseRef(ref->value());
+          i = location.first;
+          j = location.second;
+        }
+
         rapidxml::xml_node<>* first_child = cell->first_node(0);
         // only consider cells that have >= 1 child nodes
         // we require cell to have content, not just, e.g., a format
@@ -136,8 +144,6 @@ class XlsxCellSet {
           // (i, j) is our best guess at location, but if cell declares
           // it's own location, we store that instead
           XlsxCell xcell(cell, i, j);
-          i = xcell.row();
-          j = xcell.col();
 
           if (nominal_needs_checking) {
             if (i > nominal_.minRow()) { // implicit skip happened",True,False,Documentation / Formatting,3
tidyverse,readxl,0cf69c3dae6403b7f1c00946d5612e94ca41c8e0,Jenny Bryan,jenny.f.bryan@gmail.com,2022-03-20T02:32:04Z,Jenny Bryan,jenny.f.bryan@gmail.com,2022-03-20T02:32:04Z,"Work on errors thrown based on libxls error

Closes #567

I reconfirmed that, in some cases, we can't use `cpp::stop()`, as was previously discovered in https://github.com/tidyverse/readxl/pull/659/commits/24a897009bbc2db39d44835deff899b53ccffcd5.

(And yet there are also some `cpp11::stop()` calls from a constructor that *do* work fine, such as the one about being unable to retrieve a sheet from a specific position.)

In any case, I decided to use plain old `Rf_errorcall()` instead of the stringstream workaround.",src/XlsCellSet.h;src/XlsWorkBook.h,False,False,False,False,20,8,28,"---FILE: src/XlsCellSet.h---
@@ -12,6 +12,7 @@
 #include ""cpp11/integers.hpp""
 #include ""cpp11/list.hpp""
 #include ""cpp11/protect.hpp""
+#include ""cpp11/R.hpp""
 #include ""cpp11/sexp.hpp""
 #include ""cpp11/strings.hpp""
 
@@ -43,7 +44,8 @@ class XlsCellSet {
     spinner_.spin();
     pWB_ = xls_open_file(wb.path().c_str(), ""UTF-8"", &error);
     if (!pWB_) {
-      cpp11::stop(
+      Rf_errorcall(
+        R_NilValue,
         ""\n  filepath: %s\n  libxls error: %s"",
         wb.path().c_str(),
         xls::xls_getError(error)
@@ -56,7 +58,16 @@ class XlsCellSet {
       cpp11::stop(""Sheet '%s' (position %d): cannot be opened"",
                   sheetName_.c_str(), sheet_i + 1);
     }
-    xls_parseWorkSheet(pWS_);
+    error = xls::xls_parseWorkSheet(pWS_);
+    if (error != xls::LIBXLS_OK) {
+      Rf_errorcall(
+        R_NilValue,
+        ""\n  filepath: %s\n  sheet: %s\n  libxls error: %s"",
+        wb.path().c_str(),
+        sheetName_.c_str(),
+        xls::xls_getError(error)
+      );
+    }
     spinner_.spin();
 
     // shim = TRUE when user specifies geometry via `range`

---FILE: src/XlsWorkBook.h---
@@ -5,11 +5,10 @@
 #include ""libxls/xls.h""
 #include ""libxls/xlsstruct.h""
 
+#include ""cpp11/R.hpp""
 #include ""cpp11/r_string.hpp""
 #include ""cpp11/strings.hpp""
 
-#include <sstream>
-
 class XlsWorkBook {
 
   // common to Xls[x]WorkBook
@@ -37,10 +36,12 @@ class XlsWorkBook {
     xls::xls_error_t error = xls::LIBXLS_OK;
     xls::xlsWorkBook* pWB_ = xls::xls_open_file(path_.c_str(), ""UTF-8"", &error);
     if (!pWB_) {
-      auto err = xls::xls_getError(error);
-      std::stringstream ss;
-      ss << ""\n filepath: "" << path_ << ""\n libxls error: "" << err;
-      throw std::runtime_error(ss.str());
+      Rf_errorcall(
+        R_NilValue,
+        ""\n  filepath: %s\n  libxls error: %s"",
+        path_.c_str(),
+        xls::xls_getError(error)
+      );
     }
 
     n_sheets_ = pWB_->sheets.count;",False,False,Implementation / Logic,3
tidyverse,readxl,a019b231ba6d91829b9eca2691d1f8a7735a658a,Jenny Bryan,jenny.f.bryan@gmail.com,2022-03-19T22:32:03Z,Jenny Bryan,jenny.f.bryan@gmail.com,2022-03-19T22:34:52Z,"Account for rich text strings in BIFF5 files


Fixes #611

See https://github.com/libxls/libxls/commit/b6d9d872756f69780b743dbaec9cd2ec30c37740",debug/debug.R;src/XlsCell.h;src/XlsCellSet.h;tests/testthat/sheets/biff5-rich-text-string.xls;tests/testthat/test-compatibility.R,False,True,True,False,35,3,38,"---FILE: debug/debug.R---
@@ -1,7 +1,20 @@
 devtools::clean_dll()
 devtools::load_all()
 
-files <- fs::dir_ls(""investigations/Data"", recurse = TRUE, glob = ""*.XLS"")
-#files
-read_xls(files[[1]])
+# success <- read_excel(
+#   ""investigations/sample_data/success.xls"",
+#   col_names = FALSE,
+#   range = ""A1""
+# )
+failure <- read_excel(""investigations/sample_data/failure.xls"", col_names=F)
 
+# cell_is_readable
+# cell->id is 214 for the failure
+# 214 in hexadecimal is 0xD6
+# in xlsstruct.h:
+# #define XLS_RECORD_RSTRING      0x00D6
+
+# cell->id is 516 for the success
+# 516 in hexadecimal is 0x204
+# in xlsstruct.h:
+# #define XLS_RECORD_LABEL        0x0204

---FILE: src/XlsCell.h---
@@ -130,6 +130,7 @@ class XlsCell {
     switch(cell_->id) {
     case XLS_RECORD_LABELSST:
     case XLS_RECORD_LABEL:
+    case XLS_RECORD_RSTRING:
     {
       std::string s = cell_->str == NULL ? """" : cell_->str;
       ct = na.contains(s, trimWs) ? CELL_BLANK : CELL_TEXT;

---FILE: src/XlsCellSet.h---
@@ -152,6 +152,7 @@ class XlsCellSet {
   bool cell_is_readable(const xls::xlsCell* cell) {
     return cell && (
         cell->id == XLS_RECORD_MULRK ||
+        cell->id == XLS_RECORD_RSTRING ||
         cell->id == XLS_RECORD_NUMBER ||
         cell->id == XLS_RECORD_RK ||
         cell->id == XLS_RECORD_LABELSST ||

---FILE: tests/testthat/test-compatibility.R---
@@ -63,3 +63,20 @@ test_that(""we can read LAPD arrest sheets"", {
   expect_match(lapd$ARR_LOC[9], ""HOLLYWOOD"")
   expect_identical(lapd$CHG_DESC[27], ""EX CON W/ A GUN"")
 })
+
+# https://github.com/tidyverse/readxl/issues/611
+# xls file produced by ABBYY FineReader (OCR of PDFs)
+# inspired libxls to add support for rich-text strings in BIFF5
+# https://github.com/libxls/libxls/commit/b6d9d872756f69780b743dbaec9cd2ec30c37740
+test_that(""we can read xls from ABBYY FineReader"", {
+  expect_error_free(
+    abbyy <- read_excel(
+      test_sheet(""biff5-rich-text-string.xls""),
+      col_names = FALSE,
+      n_max = 1
+    )
+  )
+  expect_equal(nrow(abbyy), 1)
+  expect_equal(ncol(abbyy), 1)
+  expect_match(abbyy[[1,1]], ""^ELECTORAL"")
+})",True,False,Implementation / Logic,6
tidyverse,readxl,b43ab60ff7f3beec566d181cc3e10d3115a20814,Jenny Bryan,jenny.f.bryan@gmail.com,2022-03-19T03:27:54Z,Jenny Bryan,jenny.f.bryan@gmail.com,2022-03-19T03:27:54Z,"Don't dereference a null pointer

Fixes #564

I don't actually believe such a file can be created through normal means. I imagine this was created by a 3rd party tool, probably by some instrument manufacturer. But checking for a null pointer here doesn't seem to be actively harmful.",src/XlsWorkBook.h,False,False,False,False,3,0,3,"---FILE: src/XlsWorkBook.h---
@@ -90,6 +90,9 @@ class XlsWorkBook {
     if (n_formats > 0) {
       for (int i = 0; i < n_formats; ++i) {
         const xls::st_format::st_format_data format = pWB->formats.format[i];
+        if (format.value == nullptr) {
+          continue;
+        }
         // format.value = format string
         // in xlsx, this is formatCode
         std::string code((char*) format.value);",False,False,Rendering / Conversion,0
tidyverse,readxl,8cf3d1a3037edd4be51c51c87245efc1da6956c2,Jenny Bryan,jenny.f.bryan@gmail.com,2022-03-18T17:33:24Z,Jenny Bryan,jenny.f.bryan@gmail.com,2022-03-18T17:37:04Z,"Differentiate the warning message for different impossible dates

Closes #551
Closes #554

Thanks @cderv. I just ported over your fix to the modern branch in which we are using cpp11 instead of Rcpp.",NEWS.md;src/utils.h,False,False,False,False,13,3,16,"---FILE: NEWS.md---
@@ -1,5 +1,10 @@
 # readxl (development version)
 
+* Warning messages for impossible dates are more specific.
+  Unsupported dates prior to 1900 have their own message now, instead of being
+  lumped in with dates on the non-existent day of February 29, 1900
+  (#551, #554, @cderv).
+
 * readxl is now licensed as MIT (#632).
 
 * The minimum version of tibble has been bumped to 2.0.1 (released 2019-01-12), completing the transition to an approach to column name repair used across the tidyverse.

---FILE: src/utils.h---
@@ -67,14 +67,19 @@ inline double dateRound(double dttm) {
 // https://support.microsoft.com/en-us/help/214326/excel-incorrectly-assumes-that-the-year-1900-is-a-leap-year
 // How we address this:
 // If date is *prior* to the non-existent leap day: add a day
-// If date is on the non-existent leap day: make negative and, in due course, NA
+// If date is on the non-existent leap day: warn and return NA
 // Otherwise: do nothing
 inline double POSIXctFromSerial(double xlDate, bool is1904) {
   if (!is1904 && xlDate < 61) {
-    xlDate = (xlDate < 60) ? xlDate + 1 : -1;
+    if (xlDate < 60) {
+      xlDate = xlDate + 1;
+    } else {
+      Rf_warning(""NA inserted for impossible 1900-02-29 datetime"");
+      return NA_REAL;
+    }
   }
   if (xlDate < 0) {
-    Rf_warning(""NA inserted for impossible 1900-02-29 datetime"");
+    Rf_warning(""NA inserted for an unsupported date prior to 1900"");
     return NA_REAL;
   } else {
     return dateRound((xlDate - dateOffset(is1904)) * 86400);",False,False,Documentation / Formatting,3
tidyverse,readxl,6420474421d07eeb1ee5b040446d08d6928f6e18,Gábor Csárdi,csardi.gabor@gmail.com,2022-03-15T15:56:33Z,GitHub,noreply@github.com,2022-03-15T15:56:33Z,"Fix compilation on Alpine Linux (#687)

* Fix compilation on Alpine Linux

and other systems that use musl.

The problem is that the internal musl header that defines
uid_t and gid_t only defines it conditionally, if a macro is set.
This macro is set if the header is included from unistd.h,
but not if included from another header.

readxl uses `#pragma once`, so the header will not be included
twice, so `uid_t` might not be defined, if unistd.h is not
included early on.

The same story happens with `struct timeval` and `sys/time.h`.

* Put these with other system headers; add comment

Co-authored-by: Jenny Bryan <jenny.f.bryan@gmail.com>",src/SheetView.h,False,False,False,False,2,0,2,"---FILE: src/SheetView.h---
@@ -12,6 +12,8 @@
 
 #include <algorithm>
 #include <string>
+#include <sys/time.h> // alpine linux / musl
+#include <unistd.h>   // alpine linux / musl
 #include <vector>
 
 class Xls {",False,False,Rendering / Conversion,0
tidyverse,readxl,1430c78a6286851d4b24459cdb9c32f1b12e1bb0,Jim Hester,james.f.hester@gmail.com,2021-08-04T18:44:10Z,GitHub,noreply@github.com,2021-08-04T18:44:10Z,"Support installation and loading on windows and solaris (#663)

* Support installation and loading on windows and solaris

Older versions of the windows C runtime don't have _create_locale, so
instead we use setlocale and the reset it to the previous locale.

On solaris we just do nothing to change the locale.

* Fix compilation on Solaris

* Add explanatory comment about the type of the locale on Solaris",src/libxls/locale.c;src/libxls/locale.h;src/unix/config-solaris.h;src/unix/config.h,False,False,False,False,140,10,150,"---FILE: src/libxls/locale.c---
@@ -32,38 +32,53 @@
 #include <stdlib.h>
 #include ""libxls/locale.h""
 
-#define GCC_VERSION (__GNUC__ * 10000 \
-                     + __GNUC_MINOR__ * 100 \
-                     + __GNUC_PATCHLEVEL__)
+#ifdef __sun
+#include <string.h>
+#endif
+
+#if defined(__MINGW32__)
+  static char* old_locale;
+#endif
 
 xls_locale_t xls_createlocale() {
-#if defined(__MINGW32__) && GCC_VERSION <= 40903
-    xls_locale_t loc = {0};
-    return loc;
+#if defined(__MINGW32__)
+    old_locale = setlocale(LC_CTYPE, "".65001"");
+    return NULL;
 #elif defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
     return _create_locale(LC_CTYPE, "".65001"");
+#elif defined(__sun)
+    return NULL;
 #else
     return newlocale(LC_CTYPE_MASK, ""C.UTF-8"", NULL);
 #endif
 }
 
 void xls_freelocale(xls_locale_t locale) {
-    if (!locale)
-        return;
 #if defined(__MINGW32__)
+    setlocale(LC_ALL, old_locale);
     return;
-#elif defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
+#endif
+
+    if (!locale)
+        return;
+#if defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
     _free_locale(locale);
+#elif defined(__sun)
+   return;
 #else
     freelocale(locale);
 #endif
 }
 
 size_t xls_wcstombs_l(char *restrict s, const wchar_t *restrict pwcs, size_t n, xls_locale_t loc) {
-#if defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
+#if defined(__MINGW32__)
+    return wcstombs(s, pwcs, n);
+#elif defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
     return _wcstombs_l(s, pwcs, n, loc);
 #elif defined(HAVE_WCSTOMBS_L)
     return wcstombs_l(s, pwcs, n, loc);
+#elif defined(__sun)
+    return wcstombs(s, pwcs, n);
 #else
     locale_t oldlocale = uselocale(loc);
     size_t result = wcstombs(s, pwcs, n);

---FILE: src/libxls/locale.h---
@@ -35,6 +35,10 @@
 
 #if defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
 typedef _locale_t xls_locale_t;
+#elif defined(__sun)
+/* we never actually use the only variable declared with this type on solaris,
+ * so its precise type doesn't really matter */
+typedef void* xls_locale_t;
 #else
 typedef locale_t xls_locale_t;
 #endif

---FILE: src/unix/config-solaris.h---
@@ -0,0 +1,109 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* define if the compiler supports basic C++11 syntax */
+#define HAVE_CXX11 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define if you have the iconv() function and it works. */
+#define HAVE_ICONV 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
+   to 0 otherwise. */
+#define HAVE_MALLOC 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if your system has a GNU libc compatible `realloc' function,
+   and to 0 otherwise. */
+#define HAVE_REALLOC 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strdup' function. */
+#define HAVE_STRDUP 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the <wchar.h> header file. */
+#define HAVE_WCHAR_H 1
+
+/* Define to 1 if you have the `wcstombs_l' function. */
+/* #undef HAVE_WCSTOMBS_L */
+
+/* Define to 1 if you have the <xlocale.h> header file. */
+/* #undef HAVE_XLOCALE_H */
+
+/* Define as const if the declaration of iconv() needs const. */
+#define ICONV_CONST const
+
+/* Major version */
+#define LIBXLS_MAJOR_VERSION 1
+
+/* Micro version */
+#define LIBXLS_MICRO_VERSION 2
+
+/* Minor version */
+#define LIBXLS_MINOR_VERSION 6
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define LT_OBJDIR "".libs/""
+
+/* Name of package */
+#define PACKAGE ""libxls""
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""https://github.com/libxls/libxls/issues""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME ""libxls""
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING ""libxls 1.6.2""
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME ""libxls""
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""https://github.com/libxls/libxls""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION ""1.6.2""
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION ""1.6.2""
+
+/* Define to rpl_malloc if the replacement function should be used. */
+/* #undef malloc */
+
+/* Define to rpl_realloc if the replacement function should be used. */
+/* #undef realloc */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */

---FILE: src/unix/config.h---
@@ -1,5 +1,7 @@
 #ifdef __APPLE__
 #include ""unix/config-macos.h""
+#elif defined(__sun)
+#include ""unix/config-solaris.h""
 #else
 #include ""unix/config-unix.h""
 #endif",False,False,Implementation / Logic,3
tidyverse,readxl,2c20f5cfad1143a82fbf51aad4e6a8d450f2f2f2,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2021-07-29T20:21:44Z,GitHub,noreply@github.com,2021-07-29T20:21:44Z,"Update to libxls 1.6.2 (#658)

* Ingest libxls v1.6.2 4482400

Straight up copying files

* Tweak paths; remake unix/config.h

* Experiment re: locale.h

* Revert ""Experiment re: locale.h""

This reverts commit 72eb15b11a07365e17f5446135c5645b222ada64.

* More path tweaks

* Tweak config.h to work on ubuntu and macOS

* Changes to build on Windows

* Initialize the locale

* Separate maintainer and computer generated concerns in unix/config.h

* Use const in declaration of iconv

* Quotes seem more appropriate here

* Mask illegal function for R CMD check

I analyzed which files include which others and determined that inclusion here covers everything we need.

* Include libxls version in DESCRIPTION; update notes

* Add NEWS bullet re: libxls

* Only use the mingw workaround if GCC is <= 4.9.3

As this is the older RTools35 toolchain, and the code works like normal
with the Rtools40 toolchain.

* Specify C++11

Prompted by an r-hub failure on Debian Linux, R-devel, GCC ASAN/UBSAN

#> g++ -fsanitize=undefined,bounds-strict -fno-omit-frame-pointer -std=gnu++98 -I""/usr/local/lib/R/include"" -DNDEBUG -Iunix -I. -Irapidxml -DRCPP_DEFAULT_INCLUDE_CALL=false -I'/home/docker/R/progress/include' -I'/home/docker/R/Rcpp/include' -I/usr/local/include -fvisibility=hidden -fpic -g -O2 -Wall -pedantic -mtune=native -c XlsWorkBook.cpp -o XlsWorkBook.o
#> In file included from /usr/include/c++/10/cstdint:35,
#> from ./libxls/xlstypes.h:44,
#> from libxls/xls.h:42,
#> from XlsWorkBook.h:5,
#> from XlsWorkBook.cpp:3:
#> /usr/include/c++/10/bits/c++0x_warning.h:32:2: error: #error This file requires compiler and library support for the ISO C++ 2011 standard. This support must be enabled with the -std=c++11 or -std=gnu++11 compiler options.
#> 32 | #error This file requires compiler and library support \
#> | ^~~~~
#> make: *** [/usr/local/lib/R/etc/Makeconf:177: XlsWorkBook.o] Error 1
#> ERROR: compilation failed for package ‘readxl’

* Let's go back to where we started!

* Ingest libxls v1.6.2 4482400

Straight up copying files

* Adapt paths to our layout

* Adapt to the new files around locales

* Mask functions that are illegal for R CMD check

* Regenerate windows/config.h

* Regenerate unix/config*

* Workaround locale issues with older Windows toolchain

* Use C++11

* Update NEWS

Co-authored-by: Jim Hester <james.f.hester@gmail.com>",DESCRIPTION;NEWS.md;src/ColSpec.h;src/Makevars;src/Makevars.win;src/XlsCell.h;src/XlsWorkBook.h;src/XlsWorkSheet.cpp;src/XlsWorkSheet.h;src/libxls/brdb.h;src/libxls/endian.c;src/libxls/endian.h;src/libxls/locale.c;src/libxls/locale.h;src/libxls/ole.c;src/libxls/ole.h;src/libxls/xls.c;src/libxls/xlsstruct.h;src/libxls/xlstool.c;src/libxls/xlstool.h;src/libxls/xlstypes.h;src/patch-to-libxls-upstream.R;src/unix/config-macos.h;src/unix/config-unix.h;src/unix/config.h;src/windows/config.h,False,True,True,False,730,349,1079,"---FILE: DESCRIPTION---
@@ -63,6 +63,6 @@ Config/testthat/edition: 3
 Config/Needs/website: tidyverse/tidytemplate, tidyverse, devtools
 Encoding: UTF-8
 LazyData: true
-Note: libxls-SHA cef1393
+Note: libxls v1.6.2 4482400
 Roxygen: list(markdown = TRUE)
 RoxygenNote: 7.1.0

---FILE: NEWS.md---
@@ -2,6 +2,18 @@
 
 * readxl is now licensed as MIT (#632).
 
+## Dependency changes
+
+readxl embeds libxls v1.6.2 (the previous release embedded v1.5.0).
+The libxls project is hosted at <https://github.com/libxls/libxls> and you can learn more about the cumulative changes in its release notes:
+
+* [v1.6.2](https://github.com/libxls/libxls/releases/tag/v1.6.2)
+* [v1.6.1](https://github.com/libxls/libxls/releases/tag/v1.6.1)
+* [v1.6.0](https://github.com/libxls/libxls/releases/tag/v1.6.0)
+* [v1.5.3](https://github.com/libxls/libxls/releases/tag/v1.5.3)
+* [v1.5.2](https://github.com/libxls/libxls/releases/tag/v1.5.2)
+* [v1.5.1](https://github.com/libxls/libxls/releases/tag/v1.5.1)
+
 # readxl 1.3.1
 
 Pragmatic patch release to update some tests in advance of v2.1.0 of the tibble package. That release updates name repair: standard suffix becomes `...j`, instead of `..j`, partially motivated by user experience in readxl.

---FILE: src/ColSpec.h---
@@ -2,7 +2,7 @@
 #define READXL_COLSPEC_
 
 #include <Rcpp.h>
-#include <libxls/xls.h>
+#include ""libxls/xls.h""
 #include ""StringSet.h""
 
 enum CellType {

---FILE: src/Makevars---
@@ -1,9 +1,10 @@
+CXX_STD = CXX11
 PKG_CPPFLAGS = -Iunix -I. -Irapidxml -DRCPP_DEFAULT_INCLUDE_CALL=false
 PKG_CFLAGS = $(C_VISIBILITY)
 PKG_CXXFLAGS = $(CXX_VISIBILITY)
 
 SOURCES = RcppExports.cpp XlsWorkBook.cpp XlsWorkSheet.cpp XlsxWorkBook.cpp XlsxWorkSheet.cpp zip.cpp
-OBJECTS = $(SOURCES:.cpp=.o) cran.o libxls/xlstool.o libxls/endian.o libxls/ole.o libxls/xls.o
+OBJECTS = $(SOURCES:.cpp=.o) cran.o libxls/xlstool.o libxls/endian.o libxls/ole.o libxls/xls.o libxls/locale.o
 
 all: $(SHLIB)
 

---FILE: src/Makevars.win---
@@ -1,10 +1,11 @@
+CXX_STD = CXX11
 PKG_CFLAGS = $(C_VISIBILITY)
 PKG_CXXFLAGS = $(CXX_VISIBILITY)
 PKG_CPPFLAGS=-Iwindows -I. -Irapidxml -D__USE_MINGW_ANSI_STDIO -DRCPP_DEFAULT_INCLUDE_CALL=false
 PKG_LIBS=-lRiconv
 
 SOURCES = RcppExports.cpp XlsWorkBook.cpp XlsWorkSheet.cpp XlsxWorkBook.cpp XlsxWorkSheet.cpp zip.cpp
-OBJECTS = $(SOURCES:.cpp=.o) cran.o libxls/xlstool.o libxls/endian.o libxls/ole.o libxls/xls.o
+OBJECTS = $(SOURCES:.cpp=.o) cran.o libxls/xlstool.o libxls/endian.o libxls/ole.o libxls/xls.o libxls/locale.o
 
 all: $(SHLIB)
 

---FILE: src/XlsCell.h---
@@ -3,9 +3,9 @@
 
 #include <limits.h>
 #include <Rcpp.h>
-#include <libxls/xls.h>
-#include <libxls/xlstypes.h>
-#include <libxls/xlsstruct.h>
+#include ""libxls/xls.h""
+#include ""libxls/xlstypes.h""
+#include ""libxls/xlsstruct.h""
 #include ""ColSpec.h""
 #include ""utils.h""
 

---FILE: src/XlsWorkBook.h---
@@ -2,7 +2,7 @@
 #define READXL_XLSWORKBOOK_
 
 #include <Rcpp.h>
-#include <libxls/xls.h>
+#include ""libxls/xls.h""
 #include ""ColSpec.h""
 #include ""utils.h""
 

---FILE: src/XlsWorkSheet.cpp---
@@ -3,7 +3,7 @@
 #include <Rcpp.h>
 #include ""ColSpec.h""
 #include ""XlsWorkSheet.h""
-#include <libxls/xls.h>
+#include ""libxls/xls.h""
 using namespace Rcpp;
 
 // [[Rcpp::export]]

---FILE: src/XlsWorkSheet.h---
@@ -2,7 +2,7 @@
 #define READXL_XLSWORKSHEET_
 
 #include <Rcpp.h>
-#include <libxls/xls.h>
+#include ""libxls/xls.h""
 #include ""XlsWorkBook.h""
 #include ""Spinner.h""
 #include ""XlsCell.h""

---FILE: src/libxls/brdb.h---
@@ -43,7 +43,7 @@ typedef struct str_brdb record_brdb;
 
 record_brdb brdb[] =
     {
-#include <libxls/brdb.c.h>
+#include ""libxls/brdb.c.h""
     };
 
 static int get_brbdnum(int id)

---FILE: src/libxls/endian.c---
@@ -87,7 +87,7 @@ void xlsConvertDouble(unsigned char *d)
         for (i=0; i<4; i++)
         {
             t = d[7-i];
-            d[8-i] = d[i];
+            d[7-i] = d[i];
             d[i] = t;
         }
     }

---FILE: src/libxls/endian.h---
@@ -29,7 +29,7 @@
  *
  */
 
-#include <libxls/xlsstruct.h>
+#include ""libxls/xlsstruct.h""
 
 int xls_is_bigendian(void);
 DWORD xlsIntVal (DWORD i);

---FILE: src/libxls/locale.c---
@@ -0,0 +1,73 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
+ * Copyright 2020 Evan Miller
+ *
+ * This file is part of libxls -- A multiplatform, C/C++ library for parsing
+ * Excel(TM) files.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *    1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ *    2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS
+ * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include ""config.h""
+#include <stdlib.h>
+#include ""libxls/locale.h""
+
+#define GCC_VERSION (__GNUC__ * 10000 \
+                     + __GNUC_MINOR__ * 100 \
+                     + __GNUC_PATCHLEVEL__)
+
+xls_locale_t xls_createlocale() {
+#if defined(__MINGW32__) && GCC_VERSION <= 40903
+    xls_locale_t loc = {0};
+    return loc;
+#elif defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
+    return _create_locale(LC_CTYPE, "".65001"");
+#else
+    return newlocale(LC_CTYPE_MASK, ""C.UTF-8"", NULL);
+#endif
+}
+
+void xls_freelocale(xls_locale_t locale) {
+    if (!locale)
+        return;
+#if defined(__MINGW32__)
+    return;
+#elif defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
+    _free_locale(locale);
+#else
+    freelocale(locale);
+#endif
+}
+
+size_t xls_wcstombs_l(char *restrict s, const wchar_t *restrict pwcs, size_t n, xls_locale_t loc) {
+#if defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
+    return _wcstombs_l(s, pwcs, n, loc);
+#elif defined(HAVE_WCSTOMBS_L)
+    return wcstombs_l(s, pwcs, n, loc);
+#else
+    locale_t oldlocale = uselocale(loc);
+    size_t result = wcstombs(s, pwcs, n);
+    uselocale(oldlocale);
+    return result;
+#endif
+}

---FILE: src/libxls/locale.h---
@@ -0,0 +1,44 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
+ * Copyright 2020 Evan Miller
+ *
+ * This file is part of libxls -- A multiplatform, C/C++ library for parsing
+ * Excel(TM) files.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *    1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ *    2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS
+ * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifdef HAVE_XLOCALE_H
+#include <xlocale.h>
+#endif
+#include <locale.h>
+
+#if defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || defined(WINDOWS)
+typedef _locale_t xls_locale_t;
+#else
+typedef locale_t xls_locale_t;
+#endif
+
+xls_locale_t xls_createlocale(void);
+void xls_freelocale(xls_locale_t locale);
+size_t xls_wcstombs_l(char *restrict s, const wchar_t *restrict pwcs, size_t n, xls_locale_t loc);

---FILE: src/libxls/ole.c---
@@ -36,16 +36,13 @@
 #include ""config.h"" 
 
 #include <memory.h>
-#include <math.h>
 #include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
 
 #include ""libxls/ole.h""
 #include ""libxls/xlstool.h""
 #include ""libxls/endian.h""
-/* Mask illegal functions for CMD check */
-#include ""cran.h""
 
 extern int xls_debug;
 
@@ -113,6 +110,11 @@ static int ole2_bufread(OLE2Stream* olest)
 {
 	BYTE *ptr;
 
+#ifdef OLE_DEBUG
+    fprintf(stderr, ""----------------------------------------------\n"");
+    fprintf(stderr, ""ole2_bufread (start)\n"");
+#endif
+
     if (olest == NULL || olest->ole == NULL)
         return -1;
 
@@ -155,6 +157,10 @@ static int ole2_bufread(OLE2Stream* olest)
 			olest->cfat++;
 		}
     }
+#ifdef OLE_DEBUG
+    fprintf(stderr, ""----------------------------------------------\n"");
+    fprintf(stderr, ""ole2_bufread (end)\n"");
+#endif
 	// else printf(""ENDOFCHAIN!!!\n"");
     return 0;
 }
@@ -370,16 +376,23 @@ static int ole2_fseek(OLE2 *ole2, size_t pos) {
     return 0;
 }
 
+// Will read up to `size' bytes from the input, and pad the rest of `size' with
+// zeros if the input file or buffer is short.
 static size_t ole2_fread(OLE2 *ole2, void *buffer, size_t buffer_len, size_t size) {
     if (size > buffer_len)
         return 0;
 
+    memset(buffer, 0, size);
+
     if (ole2->file)
-        return fread(buffer, size, 1, ole2->file);
+        return fread(buffer, 1, size, ole2->file) > 0;
 
-    if (ole2->buffer_pos + size > ole2->buffer_len)
+    if (ole2->buffer_pos >= ole2->buffer_len)
         return 0;
 
+    if (ole2->buffer_pos + size > ole2->buffer_len)
+        size = ole2->buffer_len - ole2->buffer_pos;
+
     memcpy(buffer, (const char *)ole2->buffer + ole2->buffer_pos, size);
     ole2->buffer_pos += size;
 
@@ -479,47 +492,53 @@ static ssize_t ole2_read_body(OLE2 *ole) {
             total_bytes_read = -1;
             goto cleanup;
         }
-        name=unicode_decode(pss->name, pss->bsize, 0, ""UTF-8"");
+        name=transcode_utf16_to_utf8(pss->name, pss->bsize);
 #ifdef OLE_DEBUG	
 		fprintf(stderr, ""OLE NAME: %s count=%d\n"", name, (int)ole->files.count);
 #endif
         if (pss->type == PS_USER_ROOT || pss->type == PS_USER_STREAM) // (name!=NULL) // 
         {
 
 #ifdef OLE_DEBUG		
-			fprintf(stderr, ""OLE TYPE: %s file=%d \n"", pss->type == PS_USER_ROOT ? ""root"" : ""user"", (int)ole->files.count);
+			fprintf(stderr, ""OLE TYPE: %s file=%d size=%d\n"",
+                    pss->type == PS_USER_ROOT ? ""root"" : ""user"",
+                    (int)ole->files.count, (int)pss->size);
 #endif		
             ole->files.file = realloc(ole->files.file,(ole->files.count+1)*sizeof(struct st_olefiles_data));
             ole->files.file[ole->files.count].name=name;
             ole->files.file[ole->files.count].start=pss->sstart;
             ole->files.file[ole->files.count].size=pss->size;
             ole->files.count++;
 			
+#ifdef OLE_DEBUG
+            fprintf(stderr, ""----------------------------------------------\n"");
+            fprintf(stderr, ""name: %s (size=%d [c=%c])\n"", name, pss->bsize, name ? name[0]:' ');
+            fprintf(stderr, ""bsize %i\n"",pss->bsize);
+            fprintf(stderr, ""type %i\n"",pss->type);
+            fprintf(stderr, ""flag %i\n"",pss->flag);
+            fprintf(stderr, ""left %X\n"",pss->left);
+            fprintf(stderr, ""right %X\n"",pss->right);
+            fprintf(stderr, ""child %X\n"",pss->child);
+            fprintf(stderr, ""guid %.4X-%.4X-%.4X-%.4X %.4X-%.4X-%.4X-%.4X\n"",
+                    pss->guid[0],pss->guid[1],pss->guid[2],pss->guid[3],
+                    pss->guid[4],pss->guid[5],pss->guid[6],pss->guid[7]);
+            fprintf(stderr, ""user flag %.4X\n"",pss->userflags);
+            fprintf(stderr, ""sstart %.4d\n"",pss->sstart);
+            fprintf(stderr, ""size %.4d\n"",pss->size);
+#endif
 			if(pss->sstart == ENDOFCHAIN) {
 				if (xls_debug) verbose(""END OF CHAIN\n"");
 			} else if(pss->type == PS_USER_STREAM) {
-#ifdef OLE_DEBUG
-					fprintf(stderr, ""----------------------------------------------\n"");
-					fprintf(stderr, ""name: %s (size=%d [c=%c])\n"", name, pss->bsize, name ? name[0]:' ');
-					fprintf(stderr, ""bsize %i\n"",pss->bsize);
-					fprintf(stderr, ""type %i\n"",pss->type);
-					fprintf(stderr, ""flag %i\n"",pss->flag);
-					fprintf(stderr, ""left %X\n"",pss->left);
-					fprintf(stderr, ""right %X\n"",pss->right);
-					fprintf(stderr, ""child %X\n"",pss->child);
-					fprintf(stderr, ""guid %.4X-%.4X-%.4X-%.4X %.4X-%.4X-%.4X-%.4X\n"",
-                            pss->guid[0],pss->guid[1],pss->guid[2],pss->guid[3],
-						pss->guid[4],pss->guid[5],pss->guid[6],pss->guid[7]);
-					fprintf(stderr, ""user flag %.4X\n"",pss->userflags);
-					fprintf(stderr, ""sstart %.4d\n"",pss->sstart);
-					fprintf(stderr, ""size %.4d\n"",pss->size);
-#endif
 			} else if(pss->type == PS_USER_ROOT) {
 				DWORD sector, k, blocks;
 				BYTE *wptr;
                 size_t bytes_left;
 				
 				blocks = (pss->size + (ole->lsector - 1)) / ole->lsector;	// count partial
+#ifdef OLE_DEBUG
+                fprintf(stderr, ""OLE BLOCKS: %d = (%d + (%d - 1))/%d\n"",
+                        (int)blocks, (int)pss->size, (int)ole->lsector, (int)ole->lsector);
+#endif
 				if ((ole->SSAT = ole_realloc(ole->SSAT, blocks*ole->lsector)) == NULL) {
                     total_bytes_read = -1;
                     goto cleanup;
@@ -558,6 +577,11 @@ static ssize_t ole2_read_body(OLE2 *ole) {
     if (pss)
         free(pss);
 
+#ifdef OLE_DEBUG
+    fprintf(stderr, ""----------------------------------------------\n"");
+    fprintf(stderr, ""ole2_read_body: %d bytes\n"", (int)total_bytes_read);
+#endif
+
     return total_bytes_read;
 }
 

---FILE: src/libxls/ole.h---
@@ -36,7 +36,11 @@
 #ifndef OLE_INCLUDE
 #define OLE_INCLUDE
 
+#ifdef __cplusplus
+#include <cstdio>			// FILE *
+#else
 #include <stdio.h>			// FILE *
+#endif
 
 #include ""libxls/xlstypes.h""
 

---FILE: src/libxls/xls.c---
@@ -40,13 +40,17 @@
 #include <stddef.h>
 #include <errno.h>
 
+#ifdef HAVE_ICONV
+#include <iconv.h>
+#endif
+
 #include <memory.h>
-#include <math.h>
 #include <sys/types.h>
 #include <string.h>
 #include <wchar.h>
 
 #include ""libxls/endian.h""
+#include ""libxls/locale.h""
 #include ""libxls/xls.h""
 
 #ifndef min
@@ -62,7 +66,7 @@ static xls_formula_handler formula_handler;
 static xls_error_t xls_addSST(xlsWorkBook* pWB, SST* sst, DWORD size);
 static xls_error_t xls_appendSST(xlsWorkBook* pWB, BYTE* buf, DWORD size);
 static xls_error_t xls_addFormat(xlsWorkBook* pWB, FORMAT* format, DWORD size);
-static char* xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET* bs, DWORD size);
+static xls_error_t xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET* bs, DWORD size);
 static xls_error_t xls_addRow(xlsWorkSheet* pWS,ROW* row);
 static xls_error_t xls_makeTable(xlsWorkSheet* pWS);
 static struct st_cell_data *xls_addCell(xlsWorkSheet* pWS, BOF* bof, BYTE* buf);
@@ -222,27 +226,26 @@ static xls_error_t xls_appendSST(xlsWorkBook* pWB, BYTE* buf, DWORD size)
             if (flag & 0x1) {
                 size_t new_len = 0;
                 ln_toread = min((size-ofs)/2, ln);
-                ret=unicode_decode((char *)buf+ofs,ln_toread*2,&new_len,pWB->charset);
+                ret=unicode_decode((char *)buf+ofs, ln_toread*2, pWB);
 
-                if (ret == NULL)
-                {
+                if (ret == NULL) {
                     ret = strdup(""*failed to decode utf16*"");
-                    new_len = strlen(ret);
                 }
 
-                ret = realloc(ret,new_len+1);
-                ret[new_len]=0;
-
                 ln -= ln_toread;
                 ofs+=ln_toread*2;
 
                 if (xls_debug) {
+                    new_len = strlen(ret);
 	                printf(""String16SST: %s(%lu)\n"", ret, (unsigned long)new_len);
                 }
             } else {
                 ln_toread = min((size-ofs), ln);
 
-				ret = utf8_decode((char *)buf+ofs, ln_toread, pWB->charset);
+                ret = codepage_decode((char *)buf+ofs, ln_toread, pWB);
+                if (ret == NULL) {
+                    ret = strdup(""*failed to decode BIFF5 string*"");
+                }
 
                 ln  -= ln_toread;
                 ofs += ln_toread;
@@ -341,7 +344,7 @@ static double NumFromRk(DWORD drk)
     return ret;
 }
 
-static char * xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET *bs, DWORD size)
+static xls_error_t xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET *bs, DWORD size)
 {
 	char * name;
 	DWORD filepos;
@@ -353,7 +356,7 @@ static char * xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET *bs, DWORD size)
 
 	// printf(""charset=%s uni=%d\n"", pWB->charset, unicode);
 	// printf(""bs name %.*s\n"", bs->name[0], bs->name+1);
-	name = get_string(bs->name, size - offsetof(BOUNDSHEET, name), 0, pWB->is5ver, pWB->charset);
+	name = get_string(bs->name, size - offsetof(BOUNDSHEET, name), 0, pWB);
 	// printf(""name=%s\n"", name);
 
 	if(xls_debug) {
@@ -388,15 +391,15 @@ static char * xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET *bs, DWORD size)
 
     pWB->sheets.sheet = realloc(pWB->sheets.sheet,(pWB->sheets.count+1)*sizeof (struct st_sheet_data));
     if (pWB->sheets.sheet == NULL)
-        return NULL;
+        return LIBXLS_ERROR_MALLOC;
 
     pWB->sheets.sheet[pWB->sheets.count].name=name;
     pWB->sheets.sheet[pWB->sheets.count].filepos=filepos;
     pWB->sheets.sheet[pWB->sheets.count].visibility=visible;
     pWB->sheets.sheet[pWB->sheets.count].type=type;
     pWB->sheets.count++;
 
-	return name;
+	return LIBXLS_OK;
 }
 
 
@@ -469,7 +472,7 @@ int xls_isCellTooSmall(xlsWorkBook* pWB, BOF* bof, BYTE* buf) {
     if (bof->id == XLS_RECORD_LABELSST)
         return (bof->size < offsetof(LABEL, value) + (pWB->is5ver ? 2 : 4));
 
-    if (bof->id == XLS_RECORD_LABEL) {
+    if (bof->id == XLS_RECORD_LABEL || bof->id == XLS_RECORD_RSTRING) {
         if (bof->size < offsetof(LABEL, value) + 2)
             return 1;
 
@@ -596,6 +599,7 @@ static struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
         break;
     case XLS_RECORD_LABELSST:
     case XLS_RECORD_LABEL:
+    case XLS_RECORD_RSTRING:
         xls_cell_set_str(cell, xls_getfcell(pWS->workbook, cell, ((LABEL*)buf)->value));
         if (cell->str) {
             sscanf((char *)cell->str, ""%d"", &cell->l);
@@ -642,7 +646,7 @@ static char *xls_addFont(xlsWorkBook* pWB, FONT* font, DWORD size)
 
     tmp=&pWB->fonts.font[pWB->fonts.count];
 
-    tmp->name = get_string(font->name, size - offsetof(FONT, name), 0, pWB->is5ver, pWB->charset);
+    tmp->name = get_string(font->name, size - offsetof(FONT, name), 0, pWB);
 
     tmp->height=font->height;
     tmp->flag=font->flag;
@@ -670,7 +674,7 @@ static xls_error_t xls_addFormat(xlsWorkBook* pWB, FORMAT* format, DWORD size)
 
     tmp = &pWB->formats.format[pWB->formats.count];
     tmp->index = format->index;
-    tmp->value = get_string(format->value, size - offsetof(FORMAT, value), (BYTE)!pWB->is5ver, (BYTE)pWB->is5ver, pWB->charset);
+    tmp->value = get_string(format->value, size - offsetof(FORMAT, value), (BYTE)!pWB->is5ver, pWB);
     if(xls_debug) xls_showFormat(tmp);
     pWB->formats.count++;
 
@@ -873,7 +877,6 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
         case XLS_RECORD_BOF:	// BIFF5-8
             pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);
             pWB->type = buf[2] + (buf[3] << 8);
-
             if(xls_debug) {
                 printf(""version: %s\n"", pWB->is5ver ? ""BIFF5"" : ""BIFF8"" );
                 printf(""   type: %.2X\n"", pWB->type);
@@ -882,7 +885,7 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 
         case XLS_RECORD_CODEPAGE:
             pWB->codepage = buf[0] + (buf[1] << 8);
-			if(xls_debug) printf(""codepage=%x\n"", pWB->codepage);
+			if(xls_debug) printf(""codepage: %d\n"", pWB->codepage);
             break;
 
         case XLS_RECORD_CONTINUE:
@@ -931,9 +934,10 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 				//printf(""ADD SHEET\n"");
 				BOUNDSHEET *bs = (BOUNDSHEET *)buf;
                 xlsConvertBoundsheet(bs);
-				//char *s;
 				// different for BIFF5 and BIFF8
-				/*s = */ xls_addSheet(pWB, bs, bof1.size);
+                if ((retval = xls_addSheet(pWB, bs, bof1.size)) != LIBXLS_OK) {
+                    goto cleanup;
+                }
 			}
             break;
 
@@ -1009,7 +1013,7 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 					printf(""  ident: 0x%x\n"", styl->ident);
 					printf(""  level: 0x%x\n"", styl->lvl);
 				} else {
-					char *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB->is5ver, pWB->charset);
+					char *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB);
 					printf(""  name=%s\n"", s);
                     free(s);
 				}
@@ -1124,8 +1128,9 @@ static xls_error_t xls_preparseWorkSheet(xlsWorkSheet* pWS)
                 goto cleanup;
             }
             xlsConvertRow((ROW*)buf);
-            if (pWS->rows.lastcol<((ROW*)buf)->lcell)
-                pWS->rows.lastcol=((ROW*)buf)->lcell;
+            /* The lcell field is 1-indexed whereas lastcol is 0-indexed */
+            if (pWS->rows.lastcol+1<((ROW*)buf)->lcell)
+                pWS->rows.lastcol=((ROW*)buf)->lcell-1;
             if (pWS->rows.lastrow<((ROW*)buf)->index)
                 pWS->rows.lastrow=((ROW*)buf)->index;
             break;
@@ -1156,6 +1161,7 @@ static xls_error_t xls_preparseWorkSheet(xlsWorkSheet* pWS)
         case XLS_RECORD_LABELSST:
         case XLS_RECORD_BLANK:
         case XLS_RECORD_LABEL:
+        case XLS_RECORD_RSTRING:
         case XLS_RECORD_FORMULA:
         case XLS_RECORD_FORMULA_ALT:
         case XLS_RECORD_BOOLERR:
@@ -1169,7 +1175,7 @@ static xls_error_t xls_preparseWorkSheet(xlsWorkSheet* pWS)
                 pWS->rows.lastrow=xlsShortVal(((COL*)buf)->row);
             break;
         }
-        if (pWS->rows.lastcol > 256) {
+        if (pWS->rows.lastcol > 255) {
             retval = LIBXLS_ERROR_PARSE;
             goto cleanup;
         }
@@ -1342,6 +1348,7 @@ xls_error_t xls_parseWorkSheet(xlsWorkSheet* pWS)
         case XLS_RECORD_LABELSST:
         case XLS_RECORD_BLANK:
         case XLS_RECORD_LABEL:
+        case XLS_RECORD_RSTRING:
         case XLS_RECORD_FORMULA:
         case XLS_RECORD_FORMULA_ALT:
             if ((cell = xls_addCell(pWS, &tmp, buf)) == NULL) {
@@ -1356,7 +1363,7 @@ xls_error_t xls_parseWorkSheet(xlsWorkSheet* pWS)
 		case XLS_RECORD_STRING:
 			if(cell && (cell->id == XLS_RECORD_FORMULA || cell->id == XLS_RECORD_FORMULA_ALT)) {
                 xls_cell_set_str(cell, get_string((char *)buf, tmp.size,
-                            (BYTE)!pWB->is5ver, pWB->is5ver, pWB->charset));
+                            (BYTE)!pWB->is5ver, pWB));
 				if (xls_debug) xls_showCell(cell);
 			}
 			break;
@@ -1456,12 +1463,7 @@ static xlsWorkBook *xls_open_ole(OLE2 *ole, const char *charset, xls_error_t *ou
     pWB->sheets.count=0;
     pWB->xfs.count=0;
     pWB->fonts.count=0;
-    if (charset) {
-        pWB->charset = malloc(strlen(charset) * sizeof(char)+1);
-        strcpy(pWB->charset, charset);
-    } else {
-        pWB->charset = strdup(""UTF-8"");
-    }
+    pWB->charset = strdup(charset ? charset : ""UTF-8"");
 
     retval = xls_parseWorkBook(pWB);
 
@@ -1596,8 +1598,18 @@ void xls_close_WB(xlsWorkBook* pWB)
 	if(pWB->summary)  free(pWB->summary);
 	if(pWB->docSummary) free(pWB->docSummary);
 
-	// TODO - free other dynamically allocated objects like string table??
-	free(pWB);
+#ifdef HAVE_ICONV
+    if (pWB->converter)
+        iconv_close((iconv_t)pWB->converter);
+    if (pWB->utf16_converter)
+        iconv_close((iconv_t)pWB->utf16_converter);
+#endif
+
+    if (pWB->utf8_locale)
+        xls_freelocale((xls_locale_t)pWB->utf8_locale);
+
+    // TODO - free other dynamically allocated objects like string table??
+    free(pWB);
 }
 
 void xls_close_WS(xlsWorkSheet* pWS)

---FILE: src/libxls/xlsstruct.h---
@@ -53,6 +53,7 @@
 #define XLS_RECORD_PALETTE      0x0092
 #define XLS_RECORD_MULRK        0x00BD
 #define XLS_RECORD_MULBLANK     0x00BE
+#define XLS_RECORD_RSTRING      0x00D6
 #define XLS_RECORD_DBCELL       0x00D7
 #define XLS_RECORD_XF           0x00E0
 #define XLS_RECORD_MSODRAWINGGROUP   0x00EB
@@ -133,8 +134,8 @@ BOUNDSHEET;
 typedef struct ROW
 {
     WORD	index;
-    WORD	fcell;
-    WORD	lcell;
+    WORD	fcell; // first cell, 0-indexed
+    WORD	lcell; // last cell, 1-indexed
     WORD	height;
     WORD	notused;
     WORD	notused2; //used only for BIFF3-4
@@ -227,7 +228,6 @@ typedef struct LABEL
     BYTE	value[1]; // var
 }
 LABEL;
-typedef LABEL LABELSST;
 
 typedef struct BOOLERR
 {
@@ -500,6 +500,10 @@ typedef struct xlsWorkBook
 
 	char		*summary;		// ole file
 	char		*docSummary;	// ole file
+
+    void        *converter;
+    void        *utf16_converter;
+    void        *utf8_locale;
 }
 xlsWorkBook;
 

---FILE: src/libxls/xlstool.c---
@@ -35,24 +35,15 @@
 
 #include ""config.h""
 
-#include <math.h>
 #include <sys/types.h>
 #include <wchar.h>
 #include <stdio.h>
 
 #ifdef HAVE_ICONV
 #include <iconv.h>
-
-#if defined(_AIX) || defined(__sun)
-static const char *from_enc = ""UTF-16le"";
-#else
-static const char *from_enc = ""UTF-16LE"";
-#endif
-
-#else
-#include <locale.h>
 #endif
 
+#include <limits.h>
 #include <stdlib.h>
 #include <errno.h>
 #include <memory.h>
@@ -64,9 +55,27 @@ static const char *from_enc = ""UTF-16LE"";
 #include ""libxls/xlstool.h""
 #include ""libxls/brdb.h""
 #include ""libxls/endian.h""
+#include ""libxls/locale.h""
 
 extern int xls_debug;
 
+/* Not a complete list */
+enum xls_format_e {
+    XLS_FORMAT_GENERAL, // """"
+    XLS_FORMAT_NUMBER1, // ""0""
+    XLS_FORMAT_NUMBER2,  //     ""0.00"",
+    XLS_FORMAT_NUMBER3,  //     ""#,##0"",
+    XLS_FORMAT_NUMBER4,  //     ""#,##0.00"",
+    XLS_FORMAT_CURRENCY1,  //   ""\""$\""#,##0_);(\""$\""#,##0)"",
+    XLS_FORMAT_CURRENCY2,  //   ""\""$\""#,##0_);[Red](\""$\""#,##0)"",
+    XLS_FORMAT_CURRENCY3,  //   ""\""$\""#,##0.00_);(\""$\""#,##0.00)"",
+    XLS_FORMAT_CURRENCY4,  //   ""\""$\""#,##0.00_);[Red](\""$\""#,##0.00)"",
+    XLS_FORMAT_PERCENT1,  //    ""0%"",
+    XLS_FORMAT_PERCENT2,  //    ""0.00%"",
+    XLS_FORMAT_SCIENTIFIC1,  // ""0.00E+00"",
+    XLS_FORMAT_SCIENTIFIC2 = 34 // ""##0.0E+0""
+};
+
 static const DWORD colors[] =
     {
         0x000000,
@@ -135,77 +144,70 @@ void verbose(char* str)
         printf(""libxls : %s\n"",str);
 }
 
-char *utf8_decode(const char *str, DWORD len, char *encoding)
-{
-	int utf8_chars = 0;
-	char *ret = NULL;
-    DWORD i;
-	
-	for(i=0; i<len; ++i) {
-		if(str[i] & (BYTE)0x80) {
-			++utf8_chars;
-		}
-	}
-	
-	if(utf8_chars == 0 || strcmp(encoding, ""UTF-8"")) {
-		ret = malloc(len+1);
-		memcpy(ret, str, len);
-		ret[len] = 0;
-	} else {
-        DWORD i;
-        char *out;
-		// UTF-8 encoding inline
-		ret = malloc(len+utf8_chars+1);
-		out = ret;
-		for(i=0; i<len; ++i) {
-			BYTE c = str[i];
-			if(c & (BYTE)0x80) {
-				*out++ = (BYTE)0xC0 | (c >> 6);
-				*out++ = (BYTE)0x80 | (c & 0x3F);
-			} else {
-				*out++ = c;
-			}
-		}
-		*out = 0;
-	}
+#ifdef HAVE_ICONV
 
-	return ret;
+struct codepage_entry_t {
+    int code;
+    const char *name;
+};
+
+static struct codepage_entry_t _codepage_entries[] = {
+    { .code = 874, .name = ""WINDOWS-874"" },
+    { .code = 932, .name = ""SHIFT-JIS"" },
+    { .code = 936, .name = ""WINDOWS-936"" },
+    { .code = 950, .name = ""BIG-5"" },
+    { .code = 951, .name = ""BIG5-HKSCS"" },
+    { .code = 1250, .name = ""WINDOWS-1250"" },
+    { .code = 1251, .name = ""WINDOWS-1251"" },
+    { .code = 1252, .name = ""WINDOWS-1252"" },
+    { .code = 1253, .name = ""WINDOWS-1253"" },
+    { .code = 1254, .name = ""WINDOWS-1254"" },
+    { .code = 1255, .name = ""WINDOWS-1255"" },
+    { .code = 1256, .name = ""WINDOWS-1256"" },
+    { .code = 1257, .name = ""WINDOWS-1257"" },
+    { .code = 1258, .name = ""WINDOWS-1258"" },
+    { .code = 10000, .name = ""MACROMAN"" },
+    { .code = 10004, .name = ""MACARABIC"" },
+    { .code = 10005, .name = ""MACHEBREW"" },
+    { .code = 10006, .name = ""MACGREEK"" },
+    { .code = 10007, .name = ""MACCYRILLIC"" },
+    { .code = 10010, .name = ""MACROMANIA"" },
+    { .code = 10017, .name = ""MACUKRAINE"" },
+    { .code = 10021, .name = ""MACTHAI"" },
+    { .code = 10029, .name = ""MACCENTRALEUROPE"" },
+    { .code = 10079, .name = ""MACICELAND"" },
+    { .code = 10081, .name = ""MACTURKISH"" },
+    { .code = 10082, .name = ""MACCROATIAN"" },
+};
+
+static int codepage_compare(const void *key, const void *value) {
+    const struct codepage_entry_t *cp1 = key;
+    const struct codepage_entry_t *cp2 = value;
+    return cp1->code - cp2->code;
 }
 
-#ifdef HAVE_ICONV
-static char* unicode_decode_iconv(const char *s, size_t len, size_t *newlen, const char* to_enc) {
+static const char *encoding_for_codepage(WORD codepage) {
+    struct codepage_entry_t key = { .code = codepage };
+    struct codepage_entry_t *result = bsearch(&key, _codepage_entries,
+            sizeof(_codepage_entries)/sizeof(_codepage_entries[0]),
+            sizeof(_codepage_entries[0]), &codepage_compare);
+    if (result) {
+        return result->name;
+    }
+    return ""WINDOWS-1252"";
+}
+
+static char* unicode_decode_iconv(const char *s, size_t len, iconv_t ic) {
     char* outbuf = 0;
 
-    if(s && len && from_enc && to_enc)
+    if(s && len && ic)
     {
         size_t outlenleft = len;
         int outlen = len;
         size_t inlenleft = len;
-        iconv_t ic = iconv_open(to_enc, from_enc);
         const char* src_ptr = s;
         char* out_ptr = 0;
 
-        if(ic == (iconv_t)-1)
-        {
-            // Something went wrong.
-            if (errno == EINVAL)
-            {
-                if (!strcmp(to_enc, ""ASCII""))
-                {
-                    ic = iconv_open(""UTF-8"", from_enc);
-                    if(ic == (iconv_t)-1)
-                    {
-                        printf(""conversion from '%s' to '%s' not available"", from_enc, to_enc);
-                        return outbuf;
-                    }
-                }
-            }
-            else
-            {
-                printf (""iconv_open: error=%d"", errno);
-                return outbuf;
-            }
-        }
         size_t st; 
         outbuf = malloc(outlen + 1);
 
@@ -237,13 +239,8 @@ static char* unicode_decode_iconv(const char *s, size_t len, size_t *newlen, con
                 }
             }
         }
-        iconv_close(ic);
         outlen -= outlenleft;
 
-        if (newlen)
-        {
-            *newlen = outbuf ? outlen : 0;
-        }
         if(outbuf)
         {
             outbuf[outlen] = 0;
@@ -252,18 +249,15 @@ static char* unicode_decode_iconv(const char *s, size_t len, size_t *newlen, con
     return outbuf;
 }
 
-#else
+#endif
 
-static char *unicode_decode_wcstombs(const char *s, size_t len, size_t *newlen) {
+// Convert UTF-16 to UTF-8 without iconv
+static char *unicode_decode_wcstombs(const char *s, size_t len, xls_locale_t locale) {
 	// Do wcstombs conversion
     char *converted = NULL;
     int count, count2;
     size_t i;
-    wchar_t *w;
-    if (setlocale(LC_CTYPE, """") == NULL) {
-        printf(""setlocale failed: %d\n"", errno);
-        return NULL;
-    }
+    wchar_t *w = NULL;
 
     w = malloc((len/2+1)*sizeof(wchar_t));
 
@@ -273,39 +267,119 @@ static char *unicode_decode_wcstombs(const char *s, size_t len, size_t *newlen)
     }
     w[len/2] = '\0';
 
-    count = wcstombs(NULL, w, 0);
+    count = xls_wcstombs_l(NULL, w, INT_MAX, locale);
 
     if (count <= 0) {
-        if (newlen) *newlen = 0;
-        free(w);
-        return NULL;
+        goto cleanup;
     }
 
     converted = calloc(count+1, sizeof(char));
-    count2 = wcstombs(converted, w, count);
-    free(w);
+    count2 = xls_wcstombs_l(converted, w, count, locale);
     if (count2 <= 0) {
         printf(""wcstombs failed (%lu)\n"", (unsigned long)len/2);
-        if (newlen) *newlen = 0;
-        return converted;
+        goto cleanup;
     }
-    if (newlen) *newlen = count2;
+
+cleanup:
+    free(w);
     return converted;
 }
+
+// Converts Latin-1 to UTF-8 the old-fashioned way
+static char *transcode_latin1_to_utf8(const char *str, DWORD len)
+{
+	int utf8_chars = 0;
+	char *ret = NULL;
+    DWORD i;
+	
+    for(i=0; i<len; ++i) {
+        if(str[i] & (BYTE)0x80) {
+            ++utf8_chars;
+        }
+    }
+	
+    char *out = ret = malloc(len+utf8_chars+1);
+    // UTF-8 encoding inline
+    for(i=0; i<len; ++i) {
+        BYTE c = str[i];
+        if(c & (BYTE)0x80) {
+            *out++ = (BYTE)0xC0 | (c >> 6);
+            *out++ = (BYTE)0x80 | (c & 0x3F);
+        } else {
+            *out++ = c;
+        }
+    }
+    *out = 0;
+
+	return ret;
+}
+
+// Convert BIFF5 string or compressed BIFF8 string to the encoding desired
+// by the workbook. Returns a NUL-terminated string
+char* codepage_decode(const char *s, size_t len, xlsWorkBook *pWB) {
+    if (!pWB->is5ver && strcmp(pWB->charset, ""UTF-8"") == 0)
+        return transcode_latin1_to_utf8(s, len);
+
+#ifdef HAVE_ICONV
+    if (!pWB->converter) {
+        const char *from_encoding = pWB->is5ver ? encoding_for_codepage(pWB->codepage) : ""ISO-8859-1"";
+        iconv_t converter = iconv_open(pWB->charset, from_encoding);
+        if (converter == (iconv_t)-1) {
+            printf(""conversion from '%s' to '%s' not available"", from_encoding, pWB->charset);
+            return NULL;
+        }
+        pWB->converter = (void *)converter;
+    }
+    return unicode_decode_iconv(s, len, pWB->converter);
+#else
+    char *ret = malloc(len+1);
+    memcpy(ret, s, len);
+    ret[len] = 0;
+    return ret;
 #endif
+}
+
+// Convert unicode string to UTF-8
+char* transcode_utf16_to_utf8(const char *s, size_t len) {
+    xls_locale_t locale = xls_createlocale();
+    char *result = unicode_decode_wcstombs(s, len, locale);
+    xls_freelocale(locale);
+    return result;
+}
 
-// Convert unicode string to to_enc encoding
-char* unicode_decode(const char *s, size_t len, size_t *newlen, const char* to_enc)
+// Convert unicode string to the encoding desired by the workbook
+char* unicode_decode(const char *s, size_t len, xlsWorkBook *pWB)
 {
 #ifdef HAVE_ICONV
-    return unicode_decode_iconv(s, len, newlen, to_enc);
+#if defined(_AIX) || defined(__sun)
+    const char *from_enc = ""UTF-16le"";
 #else
-    return unicode_decode_wcstombs(s, len, newlen);
+    const char *from_enc = ""UTF-16LE"";
+#endif
+    if (!pWB->utf16_converter) {
+        iconv_t converter = iconv_open(pWB->charset, from_enc);
+        if (converter == (iconv_t)-1) {
+            printf(""conversion from '%s' to '%s' not available\n"", from_enc, pWB->charset);
+            return NULL;
+        }
+        pWB->utf16_converter = (void *)converter;
+    }
+    return unicode_decode_iconv(s, len, pWB->utf16_converter);
+#else
+    if (!pWB->utf8_locale) {
+        xls_locale_t locale = xls_createlocale();
+        if (locale == NULL) {
+            printf(""creation of UTF-8 locale failed\n"");
+            return NULL;
+        }
+        pWB->utf8_locale = (void *)locale;
+    }
+    return unicode_decode_wcstombs(s, len, pWB->utf8_locale);
 #endif
 }
 
 // Read and decode string
-char *get_string(const char *s, size_t len, BYTE is2, BYTE is5ver, char *charset)
+char *get_string(const char *s, size_t len, BYTE is2, xlsWorkBook* pWB)
 {
     WORD ln;
     DWORD ofs = 0;
@@ -329,7 +403,7 @@ char *get_string(const char *s, size_t len, BYTE is2, BYTE is5ver, char *charset
         ofs++;
     }
 
-	if(!is5ver) {
+	if(!pWB->is5ver) {
 		// unicode strings have a format byte before the string
         if (ofs + 1 > len) {
             return NULL;
@@ -351,12 +425,12 @@ char *get_string(const char *s, size_t len, BYTE is2, BYTE is5ver, char *charset
         if (ofs + 2*ln > len) {
             return NULL;
         }
-        ret = unicode_decode(str+ofs, ln*2, NULL, charset);
+        ret = unicode_decode(str+ofs, ln*2, pWB);
     } else {
         if (ofs + ln > len) {
             return NULL;
         }
-		ret = utf8_decode(str+ofs, ln, charset);
+        ret = codepage_decode(str+ofs, ln, pWB);
     }
 
 #if 0	// debugging
@@ -591,19 +665,13 @@ char *xls_getfcell(xlsWorkBook* pWB, struct st_cell_data* cell, BYTE *label)
         ret = strdup("""");
         break;
     case XLS_RECORD_LABEL:
+    case XLS_RECORD_RSTRING:
         len = label[0] + (label[1] << 8);
         label += 2;
-		if(pWB->is5ver) {
-            ret = malloc(len+1);
-            memcpy(ret, label, len);
-            ret[len] = 0;
-			//printf(""Found BIFF5 string of len=%d \""%s\""\n"", len, ret);
-		} else {
-            if ((*(label++) & 0x01) == 0) {
-                ret = utf8_decode((char *)label, len, pWB->charset);
-            } else {
-                ret = unicode_decode((char *)label, len*2, NULL, pWB->charset);
-            }
+        if (pWB->is5ver || (*(label++) & 0x01) == 0) {
+            ret = codepage_decode((char *)label, len, pWB);
+        } else {
+            ret = unicode_decode((char *)label, len*2, pWB);
         }
         break;
     case XLS_RECORD_RK:
@@ -618,30 +686,28 @@ char *xls_getfcell(xlsWorkBook* pWB, struct st_cell_data* cell, BYTE *label)
             ret = malloc(retlen);
             switch (xf->format)
             {
-                case 0:
-                    snprintf(ret, retlen, ""%d"", (int)cell->d);
+                case XLS_FORMAT_GENERAL:
+                case XLS_FORMAT_NUMBER1:
+                case XLS_FORMAT_NUMBER3:
+                    snprintf(ret, retlen, ""%.0lf"", cell->d);
                     break;
-                case 1:
-                    snprintf(ret, retlen, ""%d"", (int)cell->d);
+                case XLS_FORMAT_NUMBER2:
+                case XLS_FORMAT_NUMBER4:
+                    snprintf(ret, retlen, ""%.2f"", cell->d);
                     break;
-                case 2:
-                    snprintf(ret, retlen, ""%.1f"", cell->d);
+                case XLS_FORMAT_PERCENT1:
+                    snprintf(ret, retlen, ""%.0lf%%"", 100 * cell->d);
                     break;
-                case 9:
-                    snprintf(ret, retlen, ""%d"", (int)cell->d);
+                case XLS_FORMAT_PERCENT2:
+                    snprintf(ret, retlen, ""%.2lf%%"", 100 * cell->d);
                     break;
-                case 10:
-                    snprintf(ret, retlen, ""%.2f"", cell->d);
+                case XLS_FORMAT_SCIENTIFIC1:
+                    snprintf(ret, retlen, ""%.2e"", cell->d);
                     break;
-                case 11:
+                case XLS_FORMAT_SCIENTIFIC2:
                     snprintf(ret, retlen, ""%.1e"", cell->d);
                     break;
-                case 14:
-                    //ret=ctime(cell->d);
-                    snprintf(ret, retlen, ""%.0f"", cell->d);
-                    break;
                 default:
-                    // asprintf(&ret,""%.4.2f (%i)"",cell->d,xf->format);break;
                     snprintf(ret, retlen, ""%.2f"", cell->d);
                     break;
             }

---FILE: src/libxls/xlstool.h---
@@ -34,14 +34,13 @@
  */
 
 #include ""libxls/xlsstruct.h""
-/* Mask illegal functions for CMD check */
-#include ""cran.h""
 
 void verbose(char* str);
 
-char *utf8_decode(const char *str, DWORD len, char *encoding);
-char *unicode_decode(const char *s, size_t len, size_t *newlen, const char* encoding);
-char *get_string(const char *s, size_t len, BYTE is2, BYTE isUnicode, char *charset);
+char *codepage_decode(const char *s, size_t len, xlsWorkBook *pWB);
+char *unicode_decode(const char *s, size_t len, xlsWorkBook *pWB);
+char *transcode_utf16_to_utf8(const char *s, size_t len);
+char *get_string(const char *s, size_t len, BYTE is2, xlsWorkBook *pWB);
 DWORD xls_getColor(const WORD color,WORD def);
 
 void xls_showBookInfo(xlsWorkBook* pWB);

---FILE: src/libxls/xlstypes.h---
@@ -36,7 +36,15 @@
 #ifndef XLS_TYPES_INC
 #define XLS_TYPES_INC
 
+/* Mask illegal functions for CMD check */
+/* an analysis header file includes shows that doing this here covers everything */
+#include ""cran.h""
+
+#ifdef __cplusplus
+#include <cstdint>
+#else
 #include <stdint.h>
+#endif
 #include <sys/types.h>
 
 typedef unsigned char		BYTE;

---FILE: src/patch-to-libxls-upstream.R---
@@ -1,57 +1,68 @@
 library(fs)
 library(tidyverse)
 library(here)
-library(git2r)
+library(gert)
 library(desc)
 
-libxls_path <- ""~/rrr/libxls-evanmiller-github""
-libxls_SHA <- sha(last_commit(libxls_path))
+libxls_path <- ""~/rrr/libxls""
 there <- function(x) path(libxls_path, x)
 
-if (repository_head(libxls_path)[[""name""]] != ""master"") {
+if (git_branch(repo = libxls_path) != ""master"") {
   message(""YO! You are not on master in libxls! Are you sure about this?"")
 }
 
-## the subset of libxls files that we embed
+target_version <- ""v1.6.2""
+(tag <- git_tag_list(target_version, repo = libxls_path))
+
+libxls_SHA <- git_commit_id(repo = libxls_path)
+
+if (tag$commit != libxls_SHA) {
+   message(""YO! SHA associated with HEAD isn't associated with target version!"")
+}
+
+# the subset of libxls files that we embed
 paths <- c(
   ""src/endian.c"",
+  ""src/locale.c"",
   ""src/ole.c"",
   ""src/xls.c"",
   ""src/xlstool.c"",
   ""include/xls.h"",
   ""include/libxls/brdb.c.h"",
   ""include/libxls/brdb.h"",
   ""include/libxls/endian.h"",
+  ""include/libxls/locale.h"",
   ""include/libxls/ole.h"",
   ""include/libxls/xlsstruct.h"",
   ""include/libxls/xlstool.h"",
   ""include/libxls/xlstypes.h""
 )
 
-new_paths <- paths
-
-## btw xls.h doesn't live with the other headers in libxls
-## but it needs to do so in readxl
-header_file <- grepl("".h$"", new_paths)
-new_paths[header_file] <-
-  path(""src"", ""libxls"", path_file(new_paths))[header_file]
-
-file_copy(path = there(paths), new_path = here(new_paths), overwrite = TRUE)
-
-desc::desc_set(Note = paste(""libxls-SHA"", substr(libxls_SHA, 1, 7)))
-
-## at this point, you'll have a diff
-## selectively commit the bits we truly want; call this commit X
-## now commit the reversals of our usual patches; call this commit Y
-## revert commit Y; this ADDS our usual patches; call this commit Z
-## rebase and squash X and Y
-## rebase and edit the message for commit Z
-## revel in all the xls issues that are newly resolved
-
-## as needed (less often), I rerun the configure script to regenerate
-## unix/config.h and windows/config.h
-## on windows, you may need to manually & temporarily add the directory
-## containing gcc in Rtools to the PATH
-## we have manually applied patches in config.h as well
-## basically some fixes we have long had around iconv prototypes have moved out
-## of xlstool.c and into config.h, which is probably a good thing
+file_copy(
+  path     = there(paths),
+  new_path = here(path(""src"", ""libxls"", path_file(paths))),
+  overwrite = TRUE
+)
+
+desc::desc_set(Note = paste(""libxls"", target_version, substr(libxls_SHA, 1, 7)))
+
+# as needed, I rerun the configure script to regenerate
+# unix/config.h and windows/config.h
+
+# as of libxls v1.6.2, we've had to adopt different static config files for
+# macOS and other unix (basically motivated by what we see on GHA Ubuntu jobs)
+
+# on windows, you may need to manually & temporarily add the directory
+# containing gcc in Rtools to the PATH
+
+# things I needed to do on a fresh Big Sur system to run ./bootstrap
+# brew install autoconf
+# brew install autoconf-archive
+# brew install automake
+# brew install gettext
+# brew install libtool
+# ./bootstrap
+# ./configure
+
+# I later learned from Jim that I could also download and unpack the libxls
+# release and probably just run ./configure w/o installing so much stuff

---FILE: src/unix/config-macos.h---
@@ -0,0 +1,109 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* define if the compiler supports basic C++11 syntax */
+#define HAVE_CXX11 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define if you have the iconv() function and it works. */
+#define HAVE_ICONV 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
+   to 0 otherwise. */
+#define HAVE_MALLOC 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if your system has a GNU libc compatible `realloc' function,
+   and to 0 otherwise. */
+#define HAVE_REALLOC 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strdup' function. */
+#define HAVE_STRDUP 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the <wchar.h> header file. */
+#define HAVE_WCHAR_H 1
+
+/* Define to 1 if you have the `wcstombs_l' function. */
+#define HAVE_WCSTOMBS_L 1
+
+/* Define to 1 if you have the <xlocale.h> header file. */
+#define HAVE_XLOCALE_H 1
+
+/* Define as const if the declaration of iconv() needs const. */
+#define ICONV_CONST 
+
+/* Major version */
+#define LIBXLS_MAJOR_VERSION 1
+
+/* Micro version */
+#define LIBXLS_MICRO_VERSION 2
+
+/* Minor version */
+#define LIBXLS_MINOR_VERSION 6
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define LT_OBJDIR "".libs/""
+
+/* Name of package */
+#define PACKAGE ""libxls""
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""https://github.com/libxls/libxls/issues""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME ""libxls""
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING ""libxls 1.6.2""
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME ""libxls""
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""https://github.com/libxls/libxls""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION ""1.6.2""
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION ""1.6.2""
+
+/* Define to rpl_malloc if the replacement function should be used. */
+/* #undef malloc */
+
+/* Define to rpl_realloc if the replacement function should be used. */
+/* #undef realloc */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */

---FILE: src/unix/config-unix.h---
@@ -0,0 +1,109 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* define if the compiler supports basic C++11 syntax */
+#define HAVE_CXX11 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define if you have the iconv() function and it works. */
+#define HAVE_ICONV 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
+   to 0 otherwise. */
+#define HAVE_MALLOC 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if your system has a GNU libc compatible `realloc' function,
+   and to 0 otherwise. */
+#define HAVE_REALLOC 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strdup' function. */
+#define HAVE_STRDUP 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the <wchar.h> header file. */
+#define HAVE_WCHAR_H 1
+
+/* Define to 1 if you have the `wcstombs_l' function. */
+/* #undef HAVE_WCSTOMBS_L */
+
+/* Define to 1 if you have the <xlocale.h> header file. */
+/* #undef HAVE_XLOCALE_H */
+
+/* Define as const if the declaration of iconv() needs const. */
+#define ICONV_CONST 
+
+/* Major version */
+#define LIBXLS_MAJOR_VERSION 1
+
+/* Micro version */
+#define LIBXLS_MICRO_VERSION 2
+
+/* Minor version */
+#define LIBXLS_MINOR_VERSION 6
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define LT_OBJDIR "".libs/""
+
+/* Name of package */
+#define PACKAGE ""libxls""
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""https://github.com/libxls/libxls/issues""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME ""libxls""
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING ""libxls 1.6.2""
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME ""libxls""
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""https://github.com/libxls/libxls""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION ""1.6.2""
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION ""1.6.2""
+
+/* Define to rpl_malloc if the replacement function should be used. */
+/* #undef malloc */
+
+/* Define to rpl_realloc if the replacement function should be used. */
+/* #undef realloc */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */

---FILE: src/unix/config.h---
@@ -1,107 +1,5 @@
-/* config.h.  Generated from config.h.in by configure.  */
-/* config.h.in.  Generated from configure.ac by autoheader.  */
-
-/* Define to 1 if you have the <dlfcn.h> header file. */
-#define HAVE_DLFCN_H 1
-
-/* Define if you have the iconv() function and it works. */
-#define HAVE_ICONV 1
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#define HAVE_INTTYPES_H 1
-
-/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
-   to 0 otherwise. */
-#define HAVE_MALLOC 1
-
-/* Define to 1 if you have the <memory.h> header file. */
-#define HAVE_MEMORY_H 1
-
-/* Define to 1 if your system has a GNU libc compatible `realloc' function,
-   and to 0 otherwise. */
-#define HAVE_REALLOC 1
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#define HAVE_STDINT_H 1
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#define HAVE_STDLIB_H 1
-
-/* Define to 1 if you have the `strdup' function. */
-#define HAVE_STRDUP 1
-
-/* Define to 1 if you have the <strings.h> header file. */
-#define HAVE_STRINGS_H 1
-
-/* Define to 1 if you have the <string.h> header file. */
-#define HAVE_STRING_H 1
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#define HAVE_SYS_STAT_H 1
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#define HAVE_SYS_TYPES_H 1
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#define HAVE_UNISTD_H 1
-
-/* Define to 1 if you have the <wchar.h> header file. */
-#define HAVE_WCHAR_H 1
-
-/* Define as const if the declaration of iconv() needs const. */
-#if defined(_AIX) || defined(__sun)
-  #define ICONV_CONST const
+#ifdef __APPLE__
+#include ""unix/config-macos.h""
 #else
-  #define ICONV_CONST
+#include ""unix/config-unix.h""
 #endif
-
-/* Major version */
-#define LIBXLS_MAJOR_VERSION 1
-
-/* Micro version */
-#define LIBXLS_MICRO_VERSION 0
-
-/* Minor version */
-#define LIBXLS_MINOR_VERSION 5
-
-/* Define to the sub-directory where libtool stores uninstalled libraries. */
-#define LT_OBJDIR "".libs/""
-
-/* Name of package */
-#define PACKAGE ""libxls""
-
-/* Define to the address where bug reports for this package should be sent. */
-#define PACKAGE_BUGREPORT ""emmiller@gmail.com""
-
-/* Define to the full name of this package. */
-#define PACKAGE_NAME ""libxls""
-
-/* Define to the full name and version of this package. */
-#define PACKAGE_STRING ""libxls 1.5.0""
-
-/* Define to the one symbol short name of this package. */
-#define PACKAGE_TARNAME ""libxls""
-
-/* Define to the home page for this package. */
-#define PACKAGE_URL ""https://github.com/libxls/libxls""
-
-/* Define to the version of this package. */
-#define PACKAGE_VERSION ""1.5.0""
-
-/* Define to 1 if you have the ANSI C header files. */
-#define STDC_HEADERS 1
-
-/* Version number of package */
-#define VERSION ""1.5.0""
-
-/* Define to empty if `const' does not conform to ANSI C. */
-/* #undef const */
-
-/* Define to rpl_malloc if the replacement function should be used. */
-/* #undef malloc */
-
-/* Define to rpl_realloc if the replacement function should be used. */
-/* #undef realloc */
-
-/* Define to `unsigned int' if <sys/types.h> does not define. */
-/* #undef size_t */

---FILE: src/windows/config.h---
@@ -1,6 +1,9 @@
 /* config.h.  Generated from config.h.in by configure.  */
 /* config.h.in.  Generated from configure.ac by autoheader.  */
 
+/* define if the compiler supports basic C++11 syntax */
+#define HAVE_CXX11 1
+
 /* Define to 1 if you have the <dlfcn.h> header file. */
 /* #undef HAVE_DLFCN_H */
 
@@ -48,17 +51,23 @@
 /* Define to 1 if you have the <wchar.h> header file. */
 #define HAVE_WCHAR_H 1
 
+/* Define to 1 if you have the `wcstombs_l' function. */
+/* #undef HAVE_WCSTOMBS_L */
+
+/* Define to 1 if you have the <xlocale.h> header file. */
+/* #undef HAVE_XLOCALE_H */
+
 /* Define as const if the declaration of iconv() needs const. */
 #define ICONV_CONST const
 
 /* Major version */
 #define LIBXLS_MAJOR_VERSION 1
 
 /* Micro version */
-#define LIBXLS_MICRO_VERSION 0
+#define LIBXLS_MICRO_VERSION 2
 
 /* Minor version */
-#define LIBXLS_MINOR_VERSION 5
+#define LIBXLS_MINOR_VERSION 6
 
 /* Define to the sub-directory where libtool stores uninstalled libraries. */
 #define LT_OBJDIR "".libs/""
@@ -67,13 +76,13 @@
 #define PACKAGE ""libxls""
 
 /* Define to the address where bug reports for this package should be sent. */
-#define PACKAGE_BUGREPORT ""emmiller@gmail.com""
+#define PACKAGE_BUGREPORT ""https://github.com/libxls/libxls/issues""
 
 /* Define to the full name of this package. */
 #define PACKAGE_NAME ""libxls""
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING ""libxls 1.5.0""
+#define PACKAGE_STRING ""libxls 1.6.2""
 
 /* Define to the one symbol short name of this package. */
 #define PACKAGE_TARNAME ""libxls""
@@ -82,16 +91,13 @@
 #define PACKAGE_URL ""https://github.com/libxls/libxls""
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION ""1.5.0""
+#define PACKAGE_VERSION ""1.6.2""
 
 /* Define to 1 if you have the ANSI C header files. */
 #define STDC_HEADERS 1
 
 /* Version number of package */
-#define VERSION ""1.5.0""
-
-/* Define to empty if `const' does not conform to ANSI C. */
-/* #undef const */
+#define VERSION ""1.6.2""
 
 /* Define to rpl_malloc if the replacement function should be used. */
 /* #undef malloc */",True,False,Dependency / Package,7
tidyverse,readxl,fd3b3efb55b757240d5fcc849406bbfbcd38ee73,Jim Hester,james.f.hester@gmail.com,2021-07-27T15:08:23Z,GitHub,noreply@github.com,2021-07-27T15:08:23Z,"Put dependencies into their own subdirectories (#653)

* Put dependencies into their own subdirectories

This should hopefully make it easier to keep straight what is readxl
code and what is dependency code

* Fix R CMD check issues

* Normalize Makevars

* Revert Rcpp changes

* Bump cache",.github/workflows/R-CMD-check.yaml;src/Makevars;src/Makevars.win;src/libxls/endian.c;src/libxls/ole.c;src/libxls/xls.c;src/libxls/xlstool.c;src/rapidxml/rapidxml.h;src/rapidxml/rapidxml_print.h,False,False,False,False,19,7,26,"---FILE: .github/workflows/R-CMD-check.yaml---
@@ -51,8 +51,8 @@ jobs:
         uses: actions/cache@v1
         with:
           path: ${{ env.R_LIBS_USER }}
-          key: ${{ runner.os }}-r-${{ matrix.config.r }}-${{ hashFiles('.github/depends.Rds') }}
-          restore-keys: ${{ runner.os }}-r-${{ matrix.config.r }}-
+          key: ${{ runner.os }}-r-${{ matrix.config.r }}-1-${{ hashFiles('.github/depends.Rds') }}
+          restore-keys: ${{ runner.os }}-r-${{ matrix.config.r }}-1-
 
       - name: Install system dependencies
         if: runner.os == 'Linux'

---FILE: src/Makevars---
@@ -1,3 +1,12 @@
-PKG_CPPFLAGS = -Iunix -I. -DRCPP_DEFAULT_INCLUDE_CALL=false
+PKG_CPPFLAGS = -Iunix -I. -Irapidxml -DRCPP_DEFAULT_INCLUDE_CALL=false
 PKG_CFLAGS = $(C_VISIBILITY)
 PKG_CXXFLAGS = $(CXX_VISIBILITY)
+
+SOURCES = RcppExports.cpp XlsWorkBook.cpp XlsWorkSheet.cpp XlsxWorkBook.cpp XlsxWorkSheet.cpp zip.cpp
+OBJECTS = $(SOURCES:.cpp=.o) cran.o libxls/xlstool.o libxls/endian.o libxls/ole.o libxls/xls.o
+
+all: $(SHLIB)
+
+.PHONY: clean
+clean:
+	rm -f $(SHLIB) $(OBJECTS)

---FILE: src/Makevars.win---
@@ -1,10 +1,13 @@
 PKG_CFLAGS = $(C_VISIBILITY)
 PKG_CXXFLAGS = $(CXX_VISIBILITY)
-PKG_CPPFLAGS=-Iwindows -I. -D__USE_MINGW_ANSI_STDIO -DRCPP_DEFAULT_INCLUDE_CALL=false
+PKG_CPPFLAGS=-Iwindows -I. -Irapidxml -D__USE_MINGW_ANSI_STDIO -DRCPP_DEFAULT_INCLUDE_CALL=false
 PKG_LIBS=-lRiconv
 
-all: clean
+SOURCES = RcppExports.cpp XlsWorkBook.cpp XlsWorkSheet.cpp XlsxWorkBook.cpp XlsxWorkSheet.cpp zip.cpp
+OBJECTS = $(SOURCES:.cpp=.o) cran.o libxls/xlstool.o libxls/endian.o libxls/ole.o libxls/xls.o
 
-clean:
-	rm -Rf $(SHLIB) $(OBJECTS)
+all: $(SHLIB)
 
+.PHONY: clean
+clean:
+	rm -f $(SHLIB) $(OBJECTS)",False,False,Environment / Configuration,6
tidyverse,readxl,3815961a849fa85e6a8a9938b32ad116c682737d,Mara Averick,maraaverick@gmail.com,2020-05-28T15:31:09Z,GitHub,noreply@github.com,2020-05-28T15:31:09Z,Fix broken link for roxygen markdown formatting (#617),.github/CONTRIBUTING.md,False,False,False,False,1,1,2,"---FILE: .github/CONTRIBUTING.md---
@@ -30,7 +30,7 @@ You can use the [styler](https://CRAN.R-project.org/package=styler) package to
 apply these styles, but please don't restyle code that has nothing to do with 
 your PR.  
 *  We use [roxygen2](https://cran.r-project.org/package=roxygen2), with
-[Markdown syntax](https://cran.r-project.org/web/packages/roxygen2/vignettes/markdown.html), 
+[Markdown syntax](https://roxygen2.r-lib.org/articles/rd-formatting.html), 
 for documentation.  
 *  We use [testthat](https://cran.r-project.org/package=testthat). Contributions
 with test cases included are easier to accept.  ",False,False,Documentation / Formatting,4
tidyverse,readxl,c7d1b6c5d6af68b6a479c4358d45aac425be830b,Sam Albers,sam.albers@gmail.com,2020-02-01T00:38:36Z,GitHub,noreply@github.com,2020-02-01T00:38:36Z,"Add actions (#602)

* add bare github actions template

* add tidy template

* render Rmd

* add step to check on tibble 1.4.2

* fix quotation

* use 3.6 for build

* fix quotes

* remove quotes

* remove more quotes

* change runner name

* defining legacy_tibble name

* logic by tibble version

* using github version of 1.4.2

* using text from value",.Rbuildignore;.github/workflows/R-CMD-check.yaml;.github/workflows/pkgdown.yaml;README.Rmd;README.md,True,False,True,False,124,17,141,"---FILE: .Rbuildignore---
@@ -30,3 +30,5 @@
 ^investigations$
 ^src/patch-to-libxls-upstream\.R$
 ^LICENSE\.md$
+^\.github/workflows/R-CMD-check\.yaml$
+^\.github/workflows/pkgdown\.yaml$

---FILE: .github/workflows/R-CMD-check.yaml---
@@ -0,0 +1,84 @@
+on:
+  push:
+    branches:
+      - master
+  pull_request:
+    branches:
+      - master
+
+name: R-CMD-check
+
+jobs:
+  R-CMD-check:
+    runs-on: ${{ matrix.config.os }}
+
+    name: ${{ matrix.config.os }} (${{ matrix.config.r }}) ${{ matrix.config.tibble_version }}
+
+    strategy:
+      fail-fast: false
+      matrix:
+        config:
+        - { os: windows-latest, r: '3.6'}
+        - { os: macOS-latest, r: '3.6'}
+        - { os: macOS-latest, r: '3.6', tibble_version: 'tibble 1.4.2'}
+        - { os: macOS-latest, r: 'devel'}
+        - { os: ubuntu-16.04, r: '3.2', cran: ""https://demo.rstudiopm.com/all/__linux__/xenial/latest""}
+        - { os: ubuntu-16.04, r: '3.3', cran: ""https://demo.rstudiopm.com/all/__linux__/xenial/latest""}
+        - { os: ubuntu-16.04, r: '3.4', cran: ""https://demo.rstudiopm.com/all/__linux__/xenial/latest""}
+        - { os: ubuntu-16.04, r: '3.5', cran: ""https://demo.rstudiopm.com/all/__linux__/xenial/latest""}
+        - { os: ubuntu-16.04, r: '3.6', cran: ""https://demo.rstudiopm.com/all/__linux__/xenial/latest""}
+
+    env:
+      R_REMOTES_NO_ERRORS_FROM_WARNINGS: true
+      CRAN: ${{ matrix.config.cran }}
+
+    steps:
+      - uses: actions/checkout@v1
+
+      - uses: r-lib/actions/setup-r@master
+        with:
+          r-version: ${{ matrix.config.r }}
+
+      - uses: r-lib/actions/setup-pandoc@master
+
+      - name: Query dependencies
+        run: Rscript -e ""install.packages('remotes')"" -e ""saveRDS(remotes::dev_package_deps(dependencies = TRUE), 'depends.Rds', version = 2)""
+
+      - name: Cache R packages
+        if: runner.os != 'Windows'
+        uses: actions/cache@v1
+        with:
+          path: ${{ env.R_LIBS_USER }}
+          key: ${{ runner.os }}-r-${{ matrix.config.r }}-${{ hashFiles('depends.Rds') }}
+          restore-keys: ${{ runner.os }}-r-${{ matrix.config.r }}-
+
+      - name: Install system dependencies
+        if: runner.os == 'Linux'
+        env:
+          RHUB_PLATFORM: linux-x86_64-ubuntu-gcc
+        run: |
+          Rscript -e ""remotes::install_github('r-hub/sysreqs')""
+          sysreqs=$(Rscript -e ""cat(sysreqs::sysreq_commands('DESCRIPTION'))"")
+          sudo -s eval ""$sysreqs""
+
+      - name: Install dependencies
+        run: Rscript -e ""library(remotes)"" -e ""update(readRDS('depends.Rds'))"" -e ""remotes::install_cran('rcmdcheck')""
+
+      - name: Install tibble 1.4.2
+        if: matrix.config.tibble_version == 'tibble 1.4.2'
+        run: Rscript -e ""remotes::install_github('tidyverse/tibble', ref = 'v1.4.2')""
+
+      - name: Check
+        run: Rscript -e ""rcmdcheck::rcmdcheck(args = '--no-manual', error_on = 'warning', check_dir = 'check')""
+
+      - name: Upload check results
+        if: failure()
+        uses: actions/upload-artifact@master
+        with:
+          name: ${{ runner.os }}-r${{ matrix.config.r }}-results
+          path: check
+
+      - name: Test coverage
+        if: matrix.config.os == 'macOS-latest' && matrix.config.r == '3.6'
+        run: |
+          Rscript -e 'covr::codecov(token = ""${{secrets.CODECOV_TOKEN}}"")'

---FILE: .github/workflows/pkgdown.yaml---
@@ -0,0 +1,25 @@
+on:
+  push:
+    branches: master
+
+name: Pkgdown
+
+jobs:
+  pkgdown:
+    runs-on: macOS-latest
+    steps:
+      - uses: actions/checkout@master
+      - uses: r-lib/actions/setup-r@master
+      - uses: r-lib/actions/setup-pandoc@master
+      - name: Install dependencies
+        run: |
+          Rscript -e 'install.packages(""remotes"")' \
+                  -e 'remotes::install_deps(dependencies = TRUE)' \
+                  -e 'remotes::install_github(""jimhester/pkgdown@github-actions-deploy"")' \
+                  -e 'remotes::install_github(""tidyverse/tidytemplate"")'
+      - name: Install package
+        run: R CMD INSTALL .
+      - name: Deploy package
+        run: |
+          pkgdown:::deploy_local(new_process = FALSE, remote_url = 'https://x-access-token:${{secrets.DEPLOY_PAT}}@github.com/${{github.repository}}.git')
+        shell: Rscript {0}

---FILE: README.Rmd---
@@ -14,8 +14,7 @@ knitr::opts_chunk$set(
 
 # readxl <img src='man/figures/logo.png' align=""right"" height=""139"" />
 
-[![Travis-CI Build Status](https://travis-ci.org/tidyverse/readxl.svg?branch=master)](https://travis-ci.org/tidyverse/readxl) [![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/tidyverse/readxl?branch=master&svg=true)](https://ci.appveyor.com/project/tidyverse/readxl) [![Coverage Status](https://img.shields.io/codecov/c/github/tidyverse/readxl/master.svg)](https://codecov.io/github/tidyverse/readxl?branch=master) [![CRAN_Status_Badge](https://www.r-pkg.org/badges/version/readxl)](https://cran.r-project.org/package=readxl)
-[![lifecycle](https://img.shields.io/badge/lifecycle-stable-brightgreen.svg)](https://www.tidyverse.org/lifecycle/#stable)
+ [![CRAN_Status_Badge](https://www.r-pkg.org/badges/version/readxl)](https://cran.r-project.org/package=readxl) [![R build status](https://github.com/tidyverse/readxl/workflows/R-CMD-check/badge.svg)](https://github.com/tidyverse/readxl) [![Coverage Status](https://img.shields.io/codecov/c/github/tidyverse/readxl/master.svg)](https://codecov.io/github/tidyverse/readxl?branch=master) [![lifecycle](https://img.shields.io/badge/lifecycle-stable-brightgreen.svg)](https://www.tidyverse.org/lifecycle/#stable)
 
 ## Overview
 

---FILE: README.md---
@@ -3,13 +3,11 @@
 
 # readxl <img src='man/figures/logo.png' align=""right"" height=""139"" />
 
-[![Travis-CI Build
-Status](https://travis-ci.org/tidyverse/readxl.svg?branch=master)](https://travis-ci.org/tidyverse/readxl)
-[![AppVeyor Build
-Status](https://ci.appveyor.com/api/projects/status/github/tidyverse/readxl?branch=master&svg=true)](https://ci.appveyor.com/project/tidyverse/readxl)
+[![CRAN\_Status\_Badge](https://www.r-pkg.org/badges/version/readxl)](https://cran.r-project.org/package=readxl)
+[![R build
+status](https://github.com/tidyverse/readxl/workflows/R-CMD-check/badge.svg)](https://github.com/tidyverse/readxl)
 [![Coverage
 Status](https://img.shields.io/codecov/c/github/tidyverse/readxl/master.svg)](https://codecov.io/github/tidyverse/readxl?branch=master)
-[![CRAN\_Status\_Badge](https://www.r-pkg.org/badges/version/readxl)](https://cran.r-project.org/package=readxl)
 [![lifecycle](https://img.shields.io/badge/lifecycle-stable-brightgreen.svg)](https://www.tidyverse.org/lifecycle/#stable)
 
 ## Overview
@@ -67,7 +65,7 @@ readxl_example()
 #>  [5] ""deaths.xls""    ""deaths.xlsx""   ""geometry.xls""  ""geometry.xlsx""
 #>  [9] ""type-me.xls""   ""type-me.xlsx""
 readxl_example(""clippy.xls"")
-#> [1] ""/Users/jenny/resources/R/library/readxl/extdata/clippy.xls""
+#> [1] ""C:/Users/salbers/R/win-library/3.6/readxl/extdata/clippy.xls""
 ```
 
 `read_excel()` reads both xls and xlsx files and detects the format from
@@ -82,7 +80,7 @@ read_excel(xlsx_example)
 #> 1          5.1         3.5          1.4         0.2 setosa 
 #> 2          4.9         3            1.4         0.2 setosa 
 #> 3          4.7         3.2          1.3         0.2 setosa 
-#> # … with 147 more rows
+#> # ... with 147 more rows
 
 xls_example <- readxl_example(""datasets.xls"")
 read_excel(xls_example)
@@ -92,7 +90,7 @@ read_excel(xls_example)
 #> 1          5.1         3.5          1.4         0.2 setosa 
 #> 2          4.9         3            1.4         0.2 setosa 
 #> 3          4.7         3.2          1.3         0.2 setosa 
-#> # … with 147 more rows
+#> # ... with 147 more rows
 ```
 
 List the sheet names with `excel_sheets()`.
@@ -112,15 +110,15 @@ read_excel(xlsx_example, sheet = ""chickwts"")
 #> 1    179 horsebean
 #> 2    160 horsebean
 #> 3    136 horsebean
-#> # … with 68 more rows
+#> # ... with 68 more rows
 read_excel(xls_example, sheet = 4)
 #> # A tibble: 1,000 x 5
 #>     lat  long depth   mag stations
 #>   <dbl> <dbl> <dbl> <dbl>    <dbl>
 #> 1 -20.4  182.   562   4.8       41
 #> 2 -20.6  181.   650   4.2       15
 #> 3 -26    184.    42   5.4       43
-#> # … with 997 more rows
+#> # ... with 997 more rows
 ```
 
 There are various ways to control which cells are read. You can even
@@ -155,15 +153,15 @@ read_excel(xlsx_example, range = cell_cols(""B:D""))
 #> 1         3.5          1.4         0.2
 #> 2         3            1.4         0.2
 #> 3         3.2          1.3         0.2
-#> # … with 147 more rows
+#> # ... with 147 more rows
 read_excel(xlsx_example, range = ""mtcars!B1:D5"")
 #> # A tibble: 4 x 3
 #>     cyl  disp    hp
 #>   <dbl> <dbl> <dbl>
 #> 1     6   160   110
 #> 2     6   160   110
 #> 3     4   108    93
-#> # … with 1 more row
+#> # ... with 1 more row
 ```
 
 If `NA`s are represented by something other than blank cells, set the
@@ -177,7 +175,7 @@ read_excel(xlsx_example, na = ""setosa"")
 #> 1          5.1         3.5          1.4         0.2 <NA>   
 #> 2          4.9         3            1.4         0.2 <NA>   
 #> 3          4.7         3.2          1.3         0.2 <NA>   
-#> # … with 147 more rows
+#> # ... with 147 more rows
 ```
 
 If you are new to the tidyverse conventions for data import, you may
@@ -238,8 +236,7 @@ readxl and that also avoid a Java dependency.
 `datasets.xls` were created with the help of
 [openxlsx](https://CRAN.R-project.org/package=openxlsx) (and Excel).
 openxlsx provides “a high level interface to writing, styling and
-editing
-worksheets”.
+editing worksheets”.
 
 ``` r
 l <- list(iris = iris, mtcars = mtcars, chickwts = chickwts, quakes = quakes)",False,True,Rendering / Conversion,7
tidyverse,readxl,3bf39390cee6e93dce37d57d4880bf735c20cd51,Erin Grand,elg2158@columbia.edu,2020-01-31T23:19:00Z,GitHub,noreply@github.com,2020-01-31T23:19:00Z,"Refresh cell specification docs (#603)

* Edits to cell-specification documentation to add link to the vignette

* Update Roxygen to version 7.0.2

* fixed spelling issue

* change to markdown url and remove extra line",DESCRIPTION;R/cell-specification.R;man/cell-specification.Rd,False,True,True,False,23,10,33,"---FILE: DESCRIPTION---
@@ -63,4 +63,4 @@ Encoding: UTF-8
 LazyData: true
 Note: libxls-SHA cef1393
 Roxygen: list(markdown = TRUE)
-RoxygenNote: 6.1.99.9001
+RoxygenNote: 7.0.2

---FILE: R/cell-specification.R---
@@ -2,9 +2,11 @@
 #'
 #' The `range` argument of [read_excel()] provides many ways to limit the read
 #' to a specific rectangle of cells. The simplest usage is to provide an
-#' Excel-like cell range, such as `range = ""D12:F15""` or `range =
-#' ""R1C12:R6C15""`. The cell rectangle can be specified in various other ways,
-#' using helper functions. In all cases, cell range processing is handled by the
+#' Excel-like cell range, such as `range = ""D12:F15""` or
+#' `range =""R1C12:R6C15""`. The cell rectangle can be specified in various other ways,
+#' using helper functions. You can find more examples at the
+#'  [sheet geometry](https://readxl.tidyverse.org/articles/sheet-geometry.html#range)
+#'  vignette. In all cases, cell range processing is handled by the
 #' [cellranger][cellranger] package, where you can find full documentation for
 #' the functions used in the examples below.
 #'
@@ -29,8 +31,12 @@
 #' # Anchor a rectangle of specified size at a particular cell
 #' read_excel(path, range = anchored(""C4"", dim = c(3, 2)), col_names = FALSE)
 #'
-#' # Specify only the rows or only the columns
-#' read_excel(path, range = cell_rows(3:6))
+#' # Specify only the rows
+#' read_excel(path, range = cell_rows(3:5))
+#' ## is equivalent to
+#' read_excel(path, range = cell_rows(c(3, 5)))
+#'
+#' # Specify only the columns by column number or letter
 #' read_excel(path, range = cell_cols(""C:D""))
 #' read_excel(path, range = cell_cols(2))
 #'

---FILE: man/cell-specification.Rd---
@@ -10,8 +10,11 @@
 \description{
 The \code{range} argument of \code{\link[=read_excel]{read_excel()}} provides many ways to limit the read
 to a specific rectangle of cells. The simplest usage is to provide an
-Excel-like cell range, such as \code{range = ""D12:F15""} or \code{range = ""R1C12:R6C15""}. The cell rectangle can be specified in various other ways,
-using helper functions. In all cases, cell range processing is handled by the
+Excel-like cell range, such as \code{range = ""D12:F15""} or
+\code{range =""R1C12:R6C15""}. The cell rectangle can be specified in various other ways,
+using helper functions. You can find more examples at the
+\href{https://readxl.tidyverse.org/articles/sheet-geometry.html#range}{sheet-geometry}
+vignette. In all cases, cell range processing is handled by the
 \link{cellranger} package, where you can find full documentation for
 the functions used in the examples below.
 }
@@ -36,8 +39,12 @@ read_excel(path, range = ""C5:E7"")
 # Anchor a rectangle of specified size at a particular cell
 read_excel(path, range = anchored(""C4"", dim = c(3, 2)), col_names = FALSE)
 
-# Specify only the rows or only the columns
-read_excel(path, range = cell_rows(3:6))
+# Specify only the rows
+read_excel(path, range = cell_rows(3:5))
+## is equivalent to
+read_excel(path, range = cell_rows(c(3, 5)))
+
+# Specify only the columns by column number or letter
 read_excel(path, range = cell_cols(""C:D""))
 read_excel(path, range = cell_cols(2))
 ",True,False,Documentation / Formatting,7
tidyverse,readxl,e8e416f8d37c24db9e35f7a8a3c47f8bae3d11db,Jenny Bryan,jenny.f.bryan@gmail.com,2019-10-30T13:48:29Z,Jenny Bryan,jenny.f.bryan@gmail.com,2019-10-30T13:48:29Z,Handle a classed error,tests/testthat/test-read-excel.R,False,True,True,False,5,1,6,"---FILE: tests/testthat/test-read-excel.R---
@@ -22,7 +22,11 @@ test_that(""xlsx is not read as xls and vice versa"", {
     read_xls(test_sheet(""iris-excel-xlsx.xlsx"")),
     ""libxls error: Unable to open file""
   )
-  expect_error(read_xlsx(test_sheet(""iris-excel-xls.xls"")), ""cannot be opened"")
+  expect_error(
+    read_xlsx(test_sheet(""iris-excel-xls.xls"")),
+    ""cannot be opened"",
+    class = ""error""
+  )
 })
 
 test_that(""non-existent file throws error"", {",True,False,Implementation / Logic,3
tidyverse,readxl,522d64134f7758af3de2aed84468f4863c722014,Mara Averick,maraaverick@gmail.com,2019-10-10T14:23:55Z,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2019-10-10T14:23:55Z,"Add lock bot. (#587)

* Add lock bot.
* Fixes #585.

* Change daysUntilLock to 365 for initial round.",.github/lock.yml,False,False,False,False,34,0,34,"---FILE: .github/lock.yml---
@@ -0,0 +1,34 @@
+# Configuration for lock-threads - https://github.com/dessant/lock-threads
+
+# Number of days of inactivity before a closed issue or pull request is locked
+daysUntilLock: 365
+
+# Issues and pull requests with these labels will not be locked. Set to `[]` to disable
+exemptLabels: []
+
+# Label to add before locking, such as `outdated`. Set to `false` to disable
+lockLabel: false
+
+# Stop lockbot from closing as ""resolved""
+setLockReason: false
+
+# Comment to post before locking. Set to `false` to disable
+lockComment: false
+
+# TODO: after initial round of locking, use comment below
+# lockComment: >
+#   This old issue has been automatically locked. If you believe you
+#   have found a related problem, please file a new issue (with reprex)
+#   and link to this issue. <https://reprex.tidyverse.org/>
+
+# Limit to only `issues` or `pulls`
+only: issues
+
+# Optionally, specify configuration settings just for `issues` or `pulls`
+# issues:
+#   exemptLabels:
+#     - help-wanted
+#   lockLabel: outdated
+
+# pulls:
+#   daysUntilLock: 30",False,False,Data / Input Handling,3
tidyverse,readxl,15fde898887a8941bb3839892bf30fa9866290ee,struckma,stephan.struckmann@uni-rostock.de,2019-04-30T14:45:24Z,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2019-04-30T14:45:24Z,"https://github.com/tidyverse/readxl/issues/562 (#570)

Fixed compilation problems on Alpine Linux.",src/XlsWorkSheet.cpp;src/XlsxWorkSheet.cpp,False,False,False,False,4,0,4,"---FILE: src/XlsWorkSheet.cpp---
@@ -1,3 +1,5 @@
+#include <unistd.h>
+#include <sys/time.h>
 #include <Rcpp.h>
 #include ""ColSpec.h""
 #include ""XlsWorkSheet.h""

---FILE: src/XlsxWorkSheet.cpp---
@@ -1,3 +1,5 @@
+#include <unistd.h>
+#include <sys/time.h>
 #include <Rcpp.h>
 #include ""ColSpec.h""
 #include ""XlsxWorkSheet.h""",False,False,Rendering / Conversion,0
tidyverse,readxl,cc6dd4cbbc1e534560de955ad42be23717bf07e9,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2019-02-13T02:40:45Z,GitHub,noreply@github.com,2019-02-13T02:40:45Z,"Update libxls (#543)

* Update to libxls 0fa718e

* Our usual patches

* Update to libxls a36b7a2

* Our usual patches

* Update to libxls cef1393

* Our usual patches

* Update unix/config.h

* Update windows/config.h

* Restore our previous iconv fix for Windows

* Restore our iconv fix for AIX and sun

* Update NEWS and cran-comments

* Add some libxls notes for myself

[skip ci]",DESCRIPTION;NEWS.md;cran-comments.md;src/endian.c;src/libxls/endian.h;src/libxls/ole.h;src/libxls/xls.h;src/libxls/xlstool.h;src/libxls/xlstypes.h;src/ole.c;src/patch-to-libxls-upstream.R;src/unix/config.h;src/windows/config.h;src/xls.c;src/xlstool.c,False,True,True,False,299,239,538,"---FILE: DESCRIPTION---
@@ -61,6 +61,6 @@ VignetteBuilder:
     knitr
 Encoding: UTF-8
 LazyData: true
-Note: libxls-SHA 53cd37b
+Note: libxls-SHA cef1393
 Roxygen: list(markdown = TRUE)
 RoxygenNote: 6.1.1

---FILE: NEWS.md---
@@ -1,5 +1,12 @@
 # readxl (development version)
 
+## Dependency changes
+
+readxl embeds libxls v1.5.0. This is the first *official* release of libxls in several years, although readxl has been tracking the development version in the interim. The libxls project is now officially hosted at <https://github.com/libxls/libxls>. In particular, libxls v1.5.0 addresses these two CVEs:
+
+  * [CVE-2018-20452](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-20452)
+  * [CVE-2018-20450](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-20450)
+
 # readxl 1.2.0
 
 ## Column name repair

---FILE: cran-comments.md---
@@ -16,9 +16,12 @@
 
 I see no errors, warnings, or notes for readxl.
 
-The current CRAN results for clang-UBSAN and gcc-UBSAN note a misaligned address for type 'DWORD', emanating from the embedded libxls library. I believe I have gotten this fixed upstream and, therefore, in the current submission.
+The current CRAN results for blah blah.
 
-The main reason for this release is to prepare for a coming release of the tibble package, which readxl depends on.
+The main reason for this release is to embed an updated version of libxls. It has recently had its first official release in years (v1.5.0) and this release addresses two recently reported CVEs:
+
+  * CVE-2018-20452 http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-20452
+  * CVE-2018-20450 http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-20450
 
 readxl fails on big-endian platforms due to endian-ness bugs in the wrapped libxls library. This has always been the case and nothing has changed.
 

---FILE: src/endian.c---
@@ -286,21 +286,3 @@ void xlsConvertPss(PSS* pss)
     pss->size  = xlsIntVal(pss->size);
     pss->proptype  = xlsIntVal(pss->proptype);
 }
-
-#if 0 // not used?
-void xlsConvertUnicode(wchar_t *w, char *s, int len)
-{
-    short *x;
-    int i;
-
-    x=(short *)s;
-    w = (wchar_t*)malloc((len+1)*sizeof(wchar_t));
-
-    for(i=0; i<len; i++)
-    {
-        w[i]=xlsShortVal(x[i]);
-    }
-    w[len] = '\0';
-}
-#endif
-

---FILE: src/libxls/endian.h---
@@ -56,9 +56,6 @@ void xlsConvertFormula(FORMULA *f);
 void xlsConvertFormulaArray(FARRAY *f);
 void xlsConvertHeader(OLE2Header *h);
 void xlsConvertPss(PSS* pss);
-#if 0 // unused
-void xlsConvertUnicode(wchar_t *w, char *s, int len);
-#endif
 
 #define W_ENDIAN(a) a=xlsShortVal(a)
 #define D_ENDIAN(a) a=xlsIntVal(a)

---FILE: src/libxls/ole.h---
@@ -174,15 +174,13 @@ PSS;
 
 #pragma pack(pop)
 
-extern ssize_t ole2_read(void* buf,size_t size,size_t count,OLE2Stream* olest);
-extern OLE2Stream* ole2_sopen(OLE2* ole,DWORD start, size_t size);
-extern int ole2_seek(OLE2Stream* olest,DWORD ofs);
-extern OLE2Stream*  ole2_fopen(OLE2* ole, const char *file);
-extern void ole2_fclose(OLE2Stream* ole2st);
-extern OLE2* ole2_open_file(const char *file);
-extern OLE2* ole2_open_buffer(const void *buffer, size_t len);
-extern void ole2_close(OLE2* ole2);
-extern int ole2_bufread(OLE2Stream* olest);
-
+ssize_t ole2_read(void* buf,size_t size,size_t count,OLE2Stream* olest);
+OLE2Stream* ole2_sopen(OLE2* ole,DWORD start, size_t size);
+int ole2_seek(OLE2Stream* olest,DWORD ofs);
+OLE2Stream*  ole2_fopen(OLE2* ole, const char *file);
+void ole2_fclose(OLE2Stream* ole2st);
+OLE2* ole2_open_file(const char *file);
+OLE2* ole2_open_buffer(const void *buffer, size_t len);
+void ole2_close(OLE2* ole2);
 
 #endif

---FILE: src/libxls/xls.h---
@@ -52,31 +52,31 @@ typedef enum {
     LIBXLS_ERROR_MALLOC
 } xls_error_t;
 
-extern const char* xls_getVersion(void);
-extern const char* xls_getError(xls_error_t code);
+const char* xls_getVersion(void);
+const char* xls_getError(xls_error_t code);
 
-extern int xls(int debug);	// Set debug. Force library to load?
-extern void xls_set_formula_hander(xls_formula_handler handler);
+int xls(int debug);	// Set debug. Force library to load?
+void xls_set_formula_hander(xls_formula_handler handler);
 
-extern xls_error_t xls_parseWorkBook(xlsWorkBook* pWB);
-extern xls_error_t xls_parseWorkSheet(xlsWorkSheet* pWS);
+xls_error_t xls_parseWorkBook(xlsWorkBook* pWB);
+xls_error_t xls_parseWorkSheet(xlsWorkSheet* pWS);
 
 // Preferred API
 // charset - convert 16bit strings within the spread sheet to this 8-bit encoding (UTF-8 default)
-extern xlsWorkBook *xls_open_file(const char *file, const char *charset, xls_error_t *outError);
-extern xlsWorkBook *xls_open_buffer(const unsigned char *data, size_t data_len,
+xlsWorkBook *xls_open_file(const char *file, const char *charset, xls_error_t *outError);
+xlsWorkBook *xls_open_buffer(const unsigned char *data, size_t data_len,
         const char *charset, xls_error_t *outError);
-extern void xls_close_WB(xlsWorkBook* pWB);
+void xls_close_WB(xlsWorkBook* pWB);
 
 // Historical API
-extern xlsWorkBook* xls_open(const char *file,const char *charset);
+xlsWorkBook* xls_open(const char *file,const char *charset);
 #define xls_close xls_close_WB
 
-extern xlsWorkSheet * xls_getWorkSheet(xlsWorkBook* pWB,int num);
-extern void xls_close_WS(xlsWorkSheet* pWS);
+xlsWorkSheet * xls_getWorkSheet(xlsWorkBook* pWB,int num);
+void xls_close_WS(xlsWorkSheet* pWS);
 
-extern xlsSummaryInfo *xls_summaryInfo(xlsWorkBook* pWB);
-extern void xls_close_summaryInfo(xlsSummaryInfo *pSI);
+xlsSummaryInfo *xls_summaryInfo(xlsWorkBook* pWB);
+void xls_close_summaryInfo(xlsSummaryInfo *pSI);
 
 // utility function
 xlsRow *xls_row(xlsWorkSheet* pWS, WORD cellRow);

---FILE: src/libxls/xlstool.h---
@@ -37,21 +37,20 @@
 /* Mask illegal functions for CMD check */
 #include ""cran.h""
 
-extern void dumpbuf(BYTE* fname,long size,BYTE* buf);
-extern void verbose(char* str);
+void verbose(char* str);
 
-extern char *utf8_decode(const char *str, DWORD len, char *encoding);
-extern char *unicode_decode(const char *s, size_t len, size_t *newlen, const char* encoding);
-extern char *get_string(const char *s, size_t len, BYTE is2, BYTE isUnicode, char *charset);
-extern DWORD xls_getColor(const WORD color,WORD def);
+char *utf8_decode(const char *str, DWORD len, char *encoding);
+char *unicode_decode(const char *s, size_t len, size_t *newlen, const char* encoding);
+char *get_string(const char *s, size_t len, BYTE is2, BYTE isUnicode, char *charset);
+DWORD xls_getColor(const WORD color,WORD def);
 
-extern void xls_showBookInfo(xlsWorkBook* pWB);
-extern void xls_showROW(struct st_row_data* row);
-extern void xls_showColinfo(struct st_colinfo_data* col);
-extern void xls_showCell(struct st_cell_data* cell);
-extern void xls_showFont(struct st_font_data* font);
-extern void xls_showXF(XF8* xf);
-extern void xls_showFormat(struct st_format_data* format);
-extern char* xls_getfcell(xlsWorkBook* pWB, struct st_cell_data* cell, BYTE *label);
-extern char* xls_getCSS(xlsWorkBook* pWB);
-extern void xls_showBOF(BOF* bof);
+void xls_showBookInfo(xlsWorkBook* pWB);
+void xls_showROW(struct st_row_data* row);
+void xls_showColinfo(struct st_colinfo_data* col);
+void xls_showCell(struct st_cell_data* cell);
+void xls_showFont(struct st_font_data* font);
+void xls_showXF(XF8* xf);
+void xls_showFormat(struct st_format_data* format);
+char* xls_getfcell(xlsWorkBook* pWB, struct st_cell_data* cell, BYTE *label);
+char* xls_getCSS(xlsWorkBook* pWB);
+void xls_showBOF(BOF* bof);

---FILE: src/libxls/xlstypes.h---
@@ -37,6 +37,7 @@
 #define XLS_TYPES_INC
 
 #include <stdint.h>
+#include <sys/types.h>
 
 typedef unsigned char		BYTE;
 typedef uint16_t			WORD;

---FILE: src/ole.c---
@@ -57,9 +57,10 @@ static const DWORD ENDOFCHAIN	= 0xFFFFFFFE;	// -2
 static const DWORD FREESECT		= 0xFFFFFFFF;	// -1
 
 static size_t sector_pos(OLE2* ole2, DWORD sid);
-static ssize_t sector_read(OLE2* ole2, void *buffer, DWORD sid);
+static ssize_t sector_read(OLE2* ole2, void *buffer, size_t buffer_len, DWORD sid);
 static ssize_t read_MSAT(OLE2* ole2, OLE2Header *oleh);
 static void *ole_malloc(size_t len);
+static void *ole_realloc(void *ptr, size_t len);
 
 static void *ole_malloc(size_t len) {
     if (len > (1<<24) || len == 0) {
@@ -68,7 +69,30 @@ static void *ole_malloc(size_t len) {
     return malloc(len);
 }
 
-int ole2_validate_sector(DWORD sector, OLE2 *ole) {
+static void *ole_realloc(void *ptr, size_t len) {
+    if (len > (1<<24) || len == 0) {
+        free(ptr);
+        return NULL;
+    }
+    return realloc(ptr, len);
+}
+
+static int ole2_validate_sector_chain(DWORD *chain, DWORD chain_count, DWORD chain_start) {
+    DWORD count = 0;
+    DWORD sector = chain_start;
+    while (sector != ENDOFCHAIN) {
+        if (sector >= chain_count)
+            return 0;
+        
+        if (++count >= chain_count)
+            return 0;
+
+        sector = xlsIntVal(chain[sector]);
+    }
+    return 1;
+}
+
+static int ole2_validate_sector(DWORD sector, OLE2 *ole) {
     if (sector >= ole->SecIDCount) {
         if (xls_debug) fprintf(stderr, ""Error: fatpos %d out-of-bounds for SecID[%d]\n"",
                 (int)sector, ole->SecIDCount);
@@ -85,7 +109,7 @@ int ole2_validate_sector(DWORD sector, OLE2 *ole) {
 }
 
 // Read next sector of stream
-int ole2_bufread(OLE2Stream* olest) 
+static int ole2_bufread(OLE2Stream* olest)
 {
 	BYTE *ptr;
 
@@ -117,7 +141,7 @@ int ole2_bufread(OLE2Stream* olest)
 			olest->cfat++;
 		} else {
 			if ((int)olest->fatpos < 0 ||
-                sector_read(olest->ole, olest->buf, olest->fatpos) == -1) {
+                sector_read(olest->ole, olest->buf, olest->bufsize, olest->fatpos) == -1) {
                 if (xls_debug) fprintf(stderr, ""Error: Unable to read sector #%d\n"", (int)olest->fatpos);
                 return -1;
             }
@@ -205,27 +229,49 @@ ssize_t ole2_read(void* buf, size_t size, size_t count, OLE2Stream* olest)
 OLE2Stream* ole2_sopen(OLE2* ole,DWORD start, size_t size)
 {
     OLE2Stream* olest=NULL;
+    int success = 1;
 
 #ifdef OLE_DEBUG
     fprintf(stderr, ""----------------------------------------------\n"");
     fprintf(stderr, ""ole2_sopen start=%Xh\n"", start);
 #endif
 
-	olest = calloc(1, sizeof(OLE2Stream));
-	olest->ole=ole;
-	olest->size=size;
-	olest->fatpos=start;
-	olest->start=start;
-	olest->cfat=-1;
-	if((long)size > 0 && size < (size_t)ole->sectorcutoff) {
-		olest->bufsize=ole->lssector;
-		olest->sfat = 1;
-	} else {
-		olest->bufsize=ole->lsector;
-	}
-    olest->buf = ole_malloc(olest->bufsize);
+    olest = calloc(1, sizeof(OLE2Stream));
+    olest->ole=ole;
+    olest->size=size;
+    olest->fatpos=start;
+    olest->start=start;
+    olest->cfat=-1;
+    if((long)size > 0 && size < (size_t)ole->sectorcutoff) {
+        olest->bufsize=ole->lssector;
+        olest->sfat = 1;
+    } else {
+        olest->bufsize=ole->lsector;
+    }
+    if ((olest->buf = ole_malloc(olest->bufsize)) == NULL) {
+        success = 0;
+        goto cleanup;
+    }
+
+    if (olest->sfat) {
+        if (!ole2_validate_sector_chain(ole->SSecID, ole->SSecIDCount, start)) {
+            success = 0;
+            goto cleanup;
+        }
+    } else {
+        if (!ole2_validate_sector_chain(ole->SecID, ole->SecIDCount, start)) {
+            success = 0;
+            goto cleanup;
+        }
+    }
 
     if (ole2_bufread(olest) == -1) {
+        success = 0;
+        goto cleanup;
+    }
+
+cleanup:
+    if (!success) {
         ole2_fclose(olest);
         olest = NULL;
     }
@@ -313,7 +359,7 @@ OLE2Stream*  ole2_fopen(OLE2* ole, const char *file)
     return NULL;
 }
 
-int ole2_fseek(OLE2 *ole2, size_t pos) {
+static int ole2_fseek(OLE2 *ole2, size_t pos) {
     if (ole2->file)
         return fseek(ole2->file, pos, SEEK_SET);
 
@@ -324,31 +370,31 @@ int ole2_fseek(OLE2 *ole2, size_t pos) {
     return 0;
 }
 
-size_t ole2_fread(OLE2 *ole2, void *buffer, size_t size, size_t nitems) {
+static size_t ole2_fread(OLE2 *ole2, void *buffer, size_t buffer_len, size_t size) {
+    if (size > buffer_len)
+        return 0;
+
     if (ole2->file)
-        return fread(buffer, size, nitems, ole2->file);
+        return fread(buffer, size, 1, ole2->file);
 
-    size_t i = 0;
-    for (i=0; i<nitems; i++) {
-        if (ole2->buffer_pos + size > ole2->buffer_len)
-            break;
+    if (ole2->buffer_pos + size > ole2->buffer_len)
+        return 0;
 
-        memcpy(buffer, (const char *)ole2->buffer + ole2->buffer_pos, size);
-        ole2->buffer_pos += size;
-    }
-    return i;
-}
+    memcpy(buffer, (const char *)ole2->buffer + ole2->buffer_pos, size);
+    ole2->buffer_pos += size;
 
+    return 1;
+}
 
 // read header and check magic numbers
 static ssize_t ole2_read_header(OLE2 *ole) {
     ssize_t bytes_read = 0, total_bytes_read = 0;
-    OLE2Header *oleh = malloc(512);
-    if (ole2_fread(ole, oleh, 512, 1) != 1) {
+    OLE2Header *oleh = malloc(sizeof(OLE2Header));
+    if (ole2_fread(ole, oleh, sizeof(OLE2Header), sizeof(OLE2Header)) != 1) {
         total_bytes_read = -1;
         goto cleanup;
     }
-    total_bytes_read += 512;
+    total_bytes_read += sizeof(OLE2Header);
     xlsConvertHeader(oleh);
 
 	// make sure the file looks good. Note: this code only works on Little Endian machines
@@ -471,9 +517,10 @@ static ssize_t ole2_read_body(OLE2 *ole) {
 			} else if(pss->type == PS_USER_ROOT) {
 				DWORD sector, k, blocks;
 				BYTE *wptr;
+                size_t bytes_left;
 				
 				blocks = (pss->size + (ole->lsector - 1)) / ole->lsector;	// count partial
-				if ((ole->SSAT = ole_malloc(blocks*ole->lsector)) == NULL) {
+				if ((ole->SSAT = ole_realloc(ole->SSAT, blocks*ole->lsector)) == NULL) {
                     total_bytes_read = -1;
                     goto cleanup;
                 }
@@ -482,9 +529,10 @@ static ssize_t ole2_read_body(OLE2 *ole) {
 
 				sector = pss->sstart;
 				wptr = (BYTE*)ole->SSAT;
+                bytes_left = blocks*ole->lsector;
 				for(k=0; k<blocks; ++k) {
 					// printf(""block %d sector %d\n"", k, sector);
-                    if (sector == ENDOFCHAIN || sector_read(ole, wptr, sector) == -1) {
+                    if (sector == ENDOFCHAIN || sector_read(ole, wptr, bytes_left, sector) == -1) {
                         if (xls_debug) fprintf(stderr, ""Unable to read sector #%d\n"", sector);
                         total_bytes_read = -1;
                         goto cleanup;
@@ -495,6 +543,7 @@ static ssize_t ole2_read_body(OLE2 *ole) {
                     }
                     total_bytes_read += ole->lsector;
 					wptr += ole->lsector;
+                    bytes_left -= ole->lsector;
 					sector = xlsIntVal(ole->SecID[sector]);
 				}
 			}	
@@ -512,13 +561,7 @@ static ssize_t ole2_read_body(OLE2 *ole) {
     return total_bytes_read;
 }
 
-// Open in-memory buffer
-OLE2 *ole2_open_buffer(const void *buffer, size_t len) {
-    OLE2 *ole=(OLE2*)calloc(1, sizeof(OLE2));
-
-    ole->buffer = buffer;
-    ole->buffer_len = len;
-
+OLE2 *ole2_read_header_and_body(OLE2 *ole) {
     if (ole2_read_header(ole) == -1) {
         ole2_close(ole);
         return NULL;
@@ -532,6 +575,16 @@ OLE2 *ole2_open_buffer(const void *buffer, size_t len) {
     return ole;
 }
 
+// Open in-memory buffer
+OLE2 *ole2_open_buffer(const void *buffer, size_t len) {
+    OLE2 *ole = calloc(1, sizeof(OLE2));
+
+    ole->buffer = buffer;
+    ole->buffer_len = len;
+
+    return ole2_read_header_and_body(ole);
+}
+
 // Open physical file
 OLE2* ole2_open_file(const char *file)
 {
@@ -543,25 +596,15 @@ OLE2* ole2_open_file(const char *file)
 #endif
 
 	if(xls_debug) printf(""ole2_open: %s\n"", file);
-    ole=(OLE2*)calloc(1, sizeof(OLE2));
+    ole = calloc(1, sizeof(OLE2));
 
     if (!(ole->file=fopen(file, ""rb""))) {
         if(xls_debug) fprintf(stderr, ""File not found\n"");
         free(ole);
         return NULL;
     }
 
-    if (ole2_read_header(ole) == -1) {
-        ole2_close(ole);
-        return NULL;
-    }
-
-    if (ole2_read_body(ole) == -1) {
-        ole2_close(ole);
-        return NULL;
-    }
-
-    return ole;
+    return ole2_read_header_and_body(ole);
 }
 
 void ole2_close(OLE2* ole2)
@@ -592,7 +635,7 @@ static size_t sector_pos(OLE2* ole2, DWORD sid)
     return 512 + sid * ole2->lsector;
 }
 // Read one sector from its sid
-static ssize_t sector_read(OLE2* ole2, void *buffer, DWORD sid)
+static ssize_t sector_read(OLE2* ole2, void *buffer, size_t buffer_len, DWORD sid)
 {
 	size_t num;
 	size_t seeked;
@@ -603,7 +646,7 @@ static ssize_t sector_read(OLE2* ole2, void *buffer, DWORD sid)
         return -1;
     }
 
-    if ((num = ole2_fread(ole2, buffer, ole2->lsector, 1)) != 1) {
+    if ((num = ole2_fread(ole2, buffer, buffer_len, ole2->lsector)) != 1) {
         if (xls_debug) fprintf(stderr, ""Error: fread wanted 1 got %lu loc=%u\n"", (unsigned long)num,
                 (unsigned int)sector_pos(ole2, sid));
         return -1;
@@ -616,15 +659,17 @@ static ssize_t sector_read(OLE2* ole2, void *buffer, DWORD sid)
 static ssize_t read_MSAT_header(OLE2* ole2, OLE2Header* oleh, DWORD sectorCount) {
     BYTE *sector = (BYTE*)ole2->SecID;
     ssize_t bytes_read = 0, total_bytes_read = 0;
+    size_t bytes_left = ole2->SecIDCount * sizeof(DWORD);
     DWORD sectorNum;
 
     for (sectorNum = 0; sectorNum < sectorCount && sectorNum < 109; sectorNum++)
     {
-        if ((bytes_read = sector_read(ole2, sector, oleh->MSAT[sectorNum])) == -1) {
+        if ((bytes_read = sector_read(ole2, sector, bytes_left, oleh->MSAT[sectorNum])) == -1) {
             if (xls_debug) fprintf(stderr, ""Error: Unable to read sector #%d\n"", oleh->MSAT[sectorNum]);
             return -1;
         }
         sector += ole2->lsector;
+        bytes_left -= ole2->lsector;
         total_bytes_read += bytes_read;
     }
     return total_bytes_read;
@@ -642,7 +687,7 @@ static ssize_t read_MSAT_body(OLE2 *ole2, DWORD sectorOffset, DWORD sectorCount)
     {
         int posInSector;
         // read MSAT sector
-        if ((bytes_read = sector_read(ole2, sector, sid)) == -1) {
+        if ((bytes_read = sector_read(ole2, sector, ole2->lsector, sid)) == -1) {
             total_bytes_read = -1;
             if (xls_debug) fprintf(stderr, ""Error: Unable to read sector #%d\n"", sid);
             goto cleanup;
@@ -662,7 +707,8 @@ static ssize_t read_MSAT_body(OLE2 *ole2, DWORD sectorOffset, DWORD sectorCount)
                     total_bytes_read = -1;
                     goto cleanup;
                 }
-                if ((bytes_read = sector_read(ole2, (BYTE*)(ole2->SecID)+sectorNum*ole2->lsector, s)) == -1) {
+                if ((bytes_read = sector_read(ole2, (BYTE*)(ole2->SecID)+sectorNum*ole2->lsector,
+                                (ole2->SecIDCount * sizeof(DWORD) - sectorNum*ole2->lsector), s)) == -1) {
                     if (xls_debug) fprintf(stderr, ""Error: Unable to read sector #%d\n"", s);
                     total_bytes_read = -1;
                     goto cleanup;
@@ -695,36 +741,40 @@ static ssize_t read_MSAT_trailer(OLE2 *ole2) {
     ssize_t total_bytes_read = 0;
     DWORD sector, k;
     BYTE *wptr;
+    size_t bytes_left;
 
-	if(ole2->sfatstart != ENDOFCHAIN) {
-		if ((ole2->SSecID = ole_malloc(ole2->csfat*(size_t)ole2->lsector)) == NULL) {
-            return -1;
+    if(ole2->sfatstart == ENDOFCHAIN)
+        return 0;
+
+    if ((ole2->SSecID = ole_malloc(ole2->csfat*(size_t)ole2->lsector)) == NULL) {
+        return -1;
+    }
+    ole2->SSecIDCount = ole2->csfat*(size_t)ole2->lsector/4;
+    sector = ole2->sfatstart;
+    wptr=(BYTE*)ole2->SSecID;
+    bytes_left = ole2->SSecIDCount * sizeof(DWORD);
+    for(k=0; k<ole2->csfat; ++k) {
+        if (sector == ENDOFCHAIN || sector_read(ole2, wptr, bytes_left, sector) == -1) {
+            total_bytes_read = -1;
+            goto cleanup;
         }
-        ole2->SSecIDCount = ole2->csfat*(size_t)ole2->lsector/4;
-		sector = ole2->sfatstart;
-		wptr=(BYTE*)ole2->SSecID;
-		for(k=0; k<ole2->csfat; ++k) {
-			if (sector == ENDOFCHAIN || sector_read(ole2, wptr, sector) == -1) {
-                total_bytes_read = -1;
-                goto cleanup;
-            }
-            if (!ole2_validate_sector(sector, ole2)) {
-                total_bytes_read = -1;
-                goto cleanup;
-            }
-			wptr += ole2->lsector;
-            total_bytes_read += ole2->lsector;
-			sector = ole2->SecID[sector];
-		}
+        if (!ole2_validate_sector(sector, ole2)) {
+            total_bytes_read = -1;
+            goto cleanup;
+        }
+        wptr += ole2->lsector;
+        bytes_left -= ole2->lsector;
+        total_bytes_read += ole2->lsector;
+        sector = xlsIntVal(ole2->SecID[sector]);
+    }
 #ifdef OLE_DEBUG
-		if(xls_debug) {
-			int i;
-			for(i=0; i<ole2->csfat; ++i) {
-				if(ole2->SSecID[i] != FREESECT) fprintf(stderr, ""SSecID[%d]=%d\n"", i, ole2->SSecID[i]);
-			}
-		}
+    if(xls_debug) {
+        int i;
+        for(i=0; i<ole2->csfat; ++i) {
+            if(ole2->SSecID[i] != FREESECT) fprintf(stderr, ""SSecID[%d]=%d\n"", i, ole2->SSecID[i]);
+        }
+    }
 #endif
-	}
 
 cleanup:
     return total_bytes_read;

---FILE: src/patch-to-libxls-upstream.R---
@@ -47,3 +47,11 @@ desc::desc_set(Note = paste(""libxls-SHA"", substr(libxls_SHA, 1, 7)))
 ## rebase and squash X and Y
 ## rebase and edit the message for commit Z
 ## revel in all the xls issues that are newly resolved
+
+## as needed (less often), I rerun the configure script to regenerate
+## unix/config.h and windows/config.h
+## on windows, you may need to manually & temporarily add the directory
+## containing gcc in Rtools to the PATH
+## we have manually applied patches in config.h as well
+## basically some fixes we have long had around iconv prototypes have moved out
+## of xlstool.c and into config.h, which is probably a good thing

---FILE: src/unix/config.h---
@@ -4,7 +4,7 @@
 /* Define to 1 if you have the <dlfcn.h> header file. */
 #define HAVE_DLFCN_H 1
 
-/* Define if you have the iconv() function. */
+/* Define if you have the iconv() function and it works. */
 #define HAVE_ICONV 1
 
 /* Define to 1 if you have the <inttypes.h> header file. */
@@ -48,14 +48,21 @@
 /* Define to 1 if you have the <wchar.h> header file. */
 #define HAVE_WCHAR_H 1
 
+/* Define as const if the declaration of iconv() needs const. */
+#if defined(_AIX) || defined(__sun)
+  #define ICONV_CONST const
+#else
+  #define ICONV_CONST
+#endif
+
 /* Major version */
 #define LIBXLS_MAJOR_VERSION 1
 
 /* Micro version */
 #define LIBXLS_MICRO_VERSION 0
 
 /* Minor version */
-#define LIBXLS_MINOR_VERSION 4
+#define LIBXLS_MINOR_VERSION 5
 
 /* Define to the sub-directory where libtool stores uninstalled libraries. */
 #define LT_OBJDIR "".libs/""
@@ -70,22 +77,22 @@
 #define PACKAGE_NAME ""libxls""
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING ""libxls 1.4.0""
+#define PACKAGE_STRING ""libxls 1.5.0""
 
 /* Define to the one symbol short name of this package. */
 #define PACKAGE_TARNAME ""libxls""
 
 /* Define to the home page for this package. */
-#define PACKAGE_URL """"
+#define PACKAGE_URL ""https://github.com/libxls/libxls""
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION ""1.4.0""
+#define PACKAGE_VERSION ""1.5.0""
 
 /* Define to 1 if you have the ANSI C header files. */
 #define STDC_HEADERS 1
 
 /* Version number of package */
-#define VERSION ""1.4.0""
+#define VERSION ""1.5.0""
 
 /* Define to empty if `const' does not conform to ANSI C. */
 /* #undef const */

---FILE: src/windows/config.h---
@@ -1,10 +1,10 @@
 /* config.h.  Generated from config.h.in by configure.  */
-/* config.h.in.  Generated from configure.in by autoheader.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
 
 /* Define to 1 if you have the <dlfcn.h> header file. */
 /* #undef HAVE_DLFCN_H */
 
-/* Define if you have the iconv() function. */
+/* Define if you have the iconv() function and it works. */
 #define HAVE_ICONV 1
 
 /* Define to 1 if you have the <inttypes.h> header file. */
@@ -48,17 +48,19 @@
 /* Define to 1 if you have the <wchar.h> header file. */
 #define HAVE_WCHAR_H 1
 
+/* Define as const if the declaration of iconv() needs const. */
+#define ICONV_CONST const
+
 /* Major version */
 #define LIBXLS_MAJOR_VERSION 1
 
 /* Micro version */
 #define LIBXLS_MICRO_VERSION 0
 
 /* Minor version */
-#define LIBXLS_MINOR_VERSION 4
+#define LIBXLS_MINOR_VERSION 5
 
-/* Define to the sub-directory in which libtool stores uninstalled libraries.
-   */
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
 #define LT_OBJDIR "".libs/""
 
 /* Name of package */
@@ -71,22 +73,22 @@
 #define PACKAGE_NAME ""libxls""
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING ""libxls 1.4.0""
+#define PACKAGE_STRING ""libxls 1.5.0""
 
 /* Define to the one symbol short name of this package. */
 #define PACKAGE_TARNAME ""libxls""
 
 /* Define to the home page for this package. */
-#define PACKAGE_URL """"
+#define PACKAGE_URL ""https://github.com/libxls/libxls""
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION ""1.4.0""
+#define PACKAGE_VERSION ""1.5.0""
 
 /* Define to 1 if you have the ANSI C header files. */
 #define STDC_HEADERS 1
 
 /* Version number of package */
-#define VERSION ""1.4.0""
+#define VERSION ""1.5.0""
 
 /* Define to empty if `const' does not conform to ANSI C. */
 /* #undef const */

---FILE: src/xls.c---
@@ -59,23 +59,21 @@ int xls_debug = 0;
 static double NumFromRk(DWORD drk);
 static xls_formula_handler formula_handler;
 
-extern xls_error_t xls_addSST(xlsWorkBook* pWB, SST* sst, DWORD size);
-extern xls_error_t xls_appendSST(xlsWorkBook* pWB, BYTE* buf, DWORD size);
-extern xls_error_t xls_addFormat(xlsWorkBook* pWB, FORMAT* format, DWORD size);
-extern char* xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET* bs, DWORD size);
-extern xls_error_t xls_addRow(xlsWorkSheet* pWS,ROW* row);
-extern xls_error_t xls_makeTable(xlsWorkSheet* pWS);
-extern struct st_cell_data *xls_addCell(xlsWorkSheet* pWS, BOF* bof, BYTE* buf);
-extern char *xls_addFont(xlsWorkBook* pWB, FONT* font, DWORD size);
-extern xls_error_t xls_addXF8(xlsWorkBook* pWB, XF8* xf);
-extern xls_error_t xls_addXF5(xlsWorkBook* pWB, XF5* xf);
-extern xls_error_t xls_addColinfo(xlsWorkSheet* pWS, COLINFO* colinfo);
-extern xls_error_t xls_mergedCells(xlsWorkSheet* pWS, BOF* bof, BYTE* buf);
-extern xls_error_t xls_parseWorkBook(xlsWorkBook* pWB);
-extern xls_error_t xls_preparseWorkSheet(xlsWorkSheet* pWS);
-extern xls_error_t xls_formatColumn(xlsWorkSheet* pWS);
-extern xls_error_t xls_parseWorkSheet(xlsWorkSheet* pWS);
-extern void xls_dumpSummary(char *buf, int isSummary, xlsSummaryInfo *pSI);
+static xls_error_t xls_addSST(xlsWorkBook* pWB, SST* sst, DWORD size);
+static xls_error_t xls_appendSST(xlsWorkBook* pWB, BYTE* buf, DWORD size);
+static xls_error_t xls_addFormat(xlsWorkBook* pWB, FORMAT* format, DWORD size);
+static char* xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET* bs, DWORD size);
+static xls_error_t xls_addRow(xlsWorkSheet* pWS,ROW* row);
+static xls_error_t xls_makeTable(xlsWorkSheet* pWS);
+static struct st_cell_data *xls_addCell(xlsWorkSheet* pWS, BOF* bof, BYTE* buf);
+static char *xls_addFont(xlsWorkBook* pWB, FONT* font, DWORD size);
+static xls_error_t xls_addXF8(xlsWorkBook* pWB, XF8* xf);
+static xls_error_t xls_addXF5(xlsWorkBook* pWB, XF5* xf);
+static xls_error_t xls_addColinfo(xlsWorkSheet* pWS, COLINFO* colinfo);
+static xls_error_t xls_mergedCells(xlsWorkSheet* pWS, BOF* bof, BYTE* buf);
+static xls_error_t xls_preparseWorkSheet(xlsWorkSheet* pWS);
+static xls_error_t xls_formatColumn(xlsWorkSheet* pWS);
+static void xls_dumpSummary(char *buf, int isSummary, xlsSummaryInfo *pSI);
 
 #if defined(_AIX) || defined(__sun)
 #pragma pack(1)
@@ -121,7 +119,7 @@ int xls(int debug)
     return 1;
 }
 
-xls_error_t xls_addSST(xlsWorkBook* pWB,SST* sst,DWORD size)
+static xls_error_t xls_addSST(xlsWorkBook* pWB,SST* sst,DWORD size)
 {
     verbose(""xls_addSST"");
 
@@ -134,14 +132,17 @@ xls_error_t xls_addSST(xlsWorkBook* pWB,SST* sst,DWORD size)
     if (sst->num > (1<<24))
         return LIBXLS_ERROR_MALLOC;
 
+    if (pWB->sst.string)
+        return LIBXLS_ERROR_PARSE;
+
     if ((pWB->sst.string = calloc(pWB->sst.count = sst->num,
                     sizeof(struct str_sst_string))) == NULL)
         return LIBXLS_ERROR_MALLOC;
 
     return xls_appendSST(pWB, sst->strings, size - offsetof(SST, strings));
 }
 
-xls_error_t xls_appendSST(xlsWorkBook* pWB, BYTE* buf, DWORD size)
+static xls_error_t xls_appendSST(xlsWorkBook* pWB, BYTE* buf, DWORD size)
 {
     DWORD ln;	// String character count
     DWORD ofs;	// Current offset in SST buffer
@@ -204,7 +205,7 @@ xls_error_t xls_appendSST(xlsWorkBook* pWB, BYTE* buf, DWORD size)
                 if (ofs + sizeof(DWORD) > size) {
                     return LIBXLS_ERROR_PARSE;
                 }
-                sz = buf[ofs+0] + (buf[ofs+1] << 8) + (buf[ofs+2] << 16) + (buf[ofs+3] << 24);
+                sz = buf[ofs+0] + (buf[ofs+1] << 8) + (buf[ofs+2] << 16) + ((DWORD)buf[ofs+3] << 24);
                 ofs+=4;
 
 				if (xls_debug) {
@@ -282,7 +283,9 @@ xls_error_t xls_appendSST(xlsWorkBook* pWB, BYTE* buf, DWORD size)
 			if (xls_debug) {
 	            printf(""String %4u: %s<end>\n"", pWB->sst.lastid-1, pWB->sst.string[pWB->sst.lastid-1].str);
 			}
-        }
+        } else {
+            free(ret);
+	}
 
 		// Jump list of rich text formatting runs
         if (ofs < size && rt > 0) {
@@ -338,7 +341,7 @@ static double NumFromRk(DWORD drk)
     return ret;
 }
 
-char * xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET *bs, DWORD size)
+static char * xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET *bs, DWORD size)
 {
 	char * name;
 	DWORD filepos;
@@ -397,7 +400,7 @@ char * xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET *bs, DWORD size)
 }
 
 
-xls_error_t xls_addRow(xlsWorkSheet* pWS,ROW* row)
+static xls_error_t xls_addRow(xlsWorkSheet* pWS,ROW* row)
 {
     struct st_row_data* tmp;
 
@@ -418,7 +421,7 @@ xls_error_t xls_addRow(xlsWorkSheet* pWS,ROW* row)
     return LIBXLS_OK;
 }
 
-xls_error_t xls_makeTable(xlsWorkSheet* pWS)
+static xls_error_t xls_makeTable(xlsWorkSheet* pWS)
 {
     DWORD i,t;
     struct st_row_data* tmp;
@@ -474,6 +477,10 @@ int xls_isCellTooSmall(xlsWorkBook* pWB, BOF* bof, BYTE* buf) {
         if (pWB->is5ver) {
             return (bof->size < offsetof(LABEL, value) + 2 + label_len);
         }
+
+        if (bof->size < offsetof(LABEL, value) + 3)
+            return 1;
+
         if ((((LABEL*)buf)->value[2] & 0x01) == 0) {
             return (bof->size < offsetof(LABEL, value) + 3 + label_len);
         }
@@ -492,7 +499,14 @@ int xls_isCellTooSmall(xlsWorkBook* pWB, BOF* bof, BYTE* buf) {
     return 0;
 }
 
-struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
+void xls_cell_set_str(struct st_cell_data *cell, char *str) {
+    if (cell->str) {
+        free(cell->str);
+    }
+    cell->str = str;
+}
+
+static struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
 {
     struct st_cell_data*	cell;
     struct st_row_data*		row;
@@ -527,7 +541,9 @@ struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
 			// if a double, then set double and clear l
 			cell->l=0;
 			memcpy(&cell->d, &((FORMULA*)buf)->resid, sizeof(double));	// Required for ARM
-			cell->str=xls_getfcell(pWS->workbook,cell, NULL);
+            cell->id = XLS_RECORD_NUMBER; // hack
+            xls_cell_set_str(cell, xls_getfcell(pWS->workbook,cell, NULL));
+            cell->id = bof->id;
 		} else {
 			double d = ((FORMULA*)buf)->resdata[1];
 			cell->l = 0xFFFF;
@@ -536,14 +552,14 @@ struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
 				break;	// cell is half complete, get the STRING next record
 			case 1:		// Boolean
 				memcpy(&cell->d, &d, sizeof(double)); // Required for ARM
-				sprintf((char *)(cell->str = malloc(sizeof(""bool""))), ""bool"");
+                xls_cell_set_str(cell, strdup(""bool""));
 				break;
 			case 2:		// error
 				memcpy(&cell->d, &d, sizeof(double)); // Required for ARM
-				sprintf((char *)(cell->str = malloc(sizeof(""error""))), ""error"");
+                xls_cell_set_str(cell, strdup(""error""));
 				break;
 			case 3:		// empty string
-				cell->str = calloc(1,1);
+                xls_cell_set_str(cell, strdup(""""));
 				break;
 			}
 		}
@@ -561,7 +577,7 @@ struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
             cell->id=XLS_RECORD_RK;
             cell->xf=xlsShortVal(((MULRK*)buf)->rk[i].xf);
             cell->d=NumFromRk(xlsIntVal(((MULRK*)buf)->rk[i].value));
-            cell->str=xls_getfcell(pWS->workbook,cell, NULL);
+            xls_cell_set_str(cell, xls_getfcell(pWS->workbook,cell, NULL));
         }
         break;
     case XLS_RECORD_MULBLANK:
@@ -575,46 +591,46 @@ struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
             cell=&row->cells.cell[index];
             cell->id=XLS_RECORD_BLANK;
             cell->xf=xlsShortVal(((MULBLANK*)buf)->xf[i]);
-            cell->str=xls_getfcell(pWS->workbook,cell, NULL);
+            xls_cell_set_str(cell, xls_getfcell(pWS->workbook,cell, NULL));
         }
         break;
     case XLS_RECORD_LABELSST:
     case XLS_RECORD_LABEL:
-		cell->str = xls_getfcell(pWS->workbook, cell, ((LABEL*)buf)->value);
+        xls_cell_set_str(cell, xls_getfcell(pWS->workbook, cell, ((LABEL*)buf)->value));
         if (cell->str) {
             sscanf((char *)cell->str, ""%d"", &cell->l);
             sscanf((char *)cell->str, ""%lf"", &cell->d);
         }
 		break;
     case XLS_RECORD_RK:
         cell->d=NumFromRk(xlsIntVal(((RK*)buf)->value));
-        cell->str=xls_getfcell(pWS->workbook,cell, NULL);
+        xls_cell_set_str(cell, xls_getfcell(pWS->workbook,cell, NULL));
         break;
     case XLS_RECORD_BLANK:
         break;
     case XLS_RECORD_NUMBER:
         xlsConvertDouble((BYTE *)&((BR_NUMBER*)buf)->value);
 		memcpy(&cell->d, &((BR_NUMBER*)buf)->value, sizeof(double)); // Required for ARM
-        cell->str=xls_getfcell(pWS->workbook,cell, NULL);
+        xls_cell_set_str(cell, xls_getfcell(pWS->workbook,cell, NULL));
         break;
     case XLS_RECORD_BOOLERR:
         cell->d = ((BOOLERR *)buf)->value;
         if (((BOOLERR *)buf)->iserror) {
-            sprintf((char *)(cell->str = malloc(sizeof(""error""))), ""error"");
+            xls_cell_set_str(cell, strdup(""error""));
         } else {
-            sprintf((char *)(cell->str = malloc(sizeof(""bool""))), ""bool"");
+            xls_cell_set_str(cell, strdup(""bool""));
         }
         break;
     default:
-        cell->str=xls_getfcell(pWS->workbook,cell, NULL);
+        xls_cell_set_str(cell, xls_getfcell(pWS->workbook,cell, NULL));
         break;
     }
     if (xls_debug) xls_showCell(cell);
 
 	return cell;
 }
 
-char *xls_addFont(xlsWorkBook* pWB, FONT* font, DWORD size)
+static char *xls_addFont(xlsWorkBook* pWB, FONT* font, DWORD size)
 {
     struct st_font_data* tmp;
 
@@ -643,7 +659,7 @@ char *xls_addFont(xlsWorkBook* pWB, FONT* font, DWORD size)
 	return tmp->name;
 }
 
-xls_error_t xls_addFormat(xlsWorkBook* pWB, FORMAT* format, DWORD size)
+static xls_error_t xls_addFormat(xlsWorkBook* pWB, FORMAT* format, DWORD size)
 {
     struct st_format_data* tmp;
 
@@ -661,7 +677,7 @@ xls_error_t xls_addFormat(xlsWorkBook* pWB, FORMAT* format, DWORD size)
     return LIBXLS_OK;
 }
 
-xls_error_t xls_addXF8(xlsWorkBook* pWB,XF8* xf)
+static xls_error_t xls_addXF8(xlsWorkBook* pWB,XF8* xf)
 {
     struct st_xf_data* tmp;
 
@@ -689,7 +705,7 @@ xls_error_t xls_addXF8(xlsWorkBook* pWB,XF8* xf)
     return LIBXLS_OK;
 }
 
-xls_error_t xls_addXF5(xlsWorkBook* pWB,XF5* xf)
+static xls_error_t xls_addXF5(xlsWorkBook* pWB,XF5* xf)
 {
     struct st_xf_data* tmp;
 
@@ -718,7 +734,7 @@ xls_error_t xls_addXF5(xlsWorkBook* pWB,XF5* xf)
     return LIBXLS_OK;
 }
 
-xls_error_t xls_addColinfo(xlsWorkSheet* pWS,COLINFO* colinfo)
+static xls_error_t xls_addColinfo(xlsWorkSheet* pWS,COLINFO* colinfo)
 {
     struct st_colinfo_data* tmp;
 
@@ -740,7 +756,7 @@ xls_error_t xls_addColinfo(xlsWorkSheet* pWS,COLINFO* colinfo)
     return LIBXLS_OK;
 }
 
-xls_error_t xls_mergedCells(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
+static xls_error_t xls_mergedCells(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
 {
     if (bof->size < sizeof(WORD))
         return LIBXLS_ERROR_PARSE;
@@ -901,15 +917,13 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 
         case XLS_RECORD_SST:
 			//printf(""ADD SST\n"");
-			//if(xls_debug) dumpbuf((BYTE *)""/tmp/SST"",bof1.size,buf);
             xlsConvertSst((SST *)buf);
             if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {
                 goto cleanup;
             }
             break;
 
         case XLS_RECORD_EXTSST:
-            //if(xls_debug > 1000) dumpbuf((BYTE *)""/tmp/EXTSST"",bof1.size,buf);
             break;
 
         case XLS_RECORD_BOUNDSHEET:
@@ -997,6 +1011,7 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 				} else {
 					char *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB->is5ver, pWB->charset);
 					printf(""  name=%s\n"", s);
+                    free(s);
 				}
 			}
 			break;
@@ -1051,7 +1066,7 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 }
 
 
-xls_error_t xls_preparseWorkSheet(xlsWorkSheet* pWS)
+static xls_error_t xls_preparseWorkSheet(xlsWorkSheet* pWS)
 {
     BOF tmp;
     BYTE* buf = NULL;
@@ -1167,13 +1182,17 @@ xls_error_t xls_preparseWorkSheet(xlsWorkSheet* pWS)
     return retval;
 }
 
-xls_error_t xls_formatColumn(xlsWorkSheet* pWS)
+static xls_error_t xls_formatColumn(xlsWorkSheet* pWS)
 {
     DWORD i,t,ii;
     DWORD fcol,lcol;
+    WORD width;
+    BYTE isHidden;
 
     for (i=0;i<pWS->colinfo.count;i++)
     {
+        width = pWS->colinfo.col[i].width;
+        isHidden = (pWS->colinfo.col[i].flags&1);
         if (pWS->colinfo.col[i].first<=pWS->rows.lastcol)
             fcol=pWS->colinfo.col[i].first;
         else
@@ -1184,12 +1203,10 @@ xls_error_t xls_formatColumn(xlsWorkSheet* pWS)
         else
             lcol=pWS->rows.lastcol;
 
-        for (t=fcol;t<=lcol;t++) {
-            for (ii=0;ii<=pWS->rows.lastrow;ii++)
-            {
-                if (pWS->colinfo.col[i].flags&1)
-                    pWS->rows.row[ii].cells.cell[t].isHidden=1;
-                pWS->rows.row[ii].cells.cell[t].width=pWS->colinfo.col[i].width;
+        for (ii=0;ii<=pWS->rows.lastrow;ii++) {
+            for (t=fcol;t<=lcol;t++) {
+                pWS->rows.row[ii].cells.cell[t].isHidden |= isHidden;
+                pWS->rows.row[ii].cells.cell[t].width = width;
             }
         }
     }
@@ -1338,7 +1355,8 @@ xls_error_t xls_parseWorkSheet(xlsWorkSheet* pWS)
 
 		case XLS_RECORD_STRING:
 			if(cell && (cell->id == XLS_RECORD_FORMULA || cell->id == XLS_RECORD_FORMULA_ALT)) {
-				cell->str = get_string((char *)buf, tmp.size, (BYTE)!pWB->is5ver, pWB->is5ver, pWB->charset);
+                xls_cell_set_str(cell, get_string((char *)buf, tmp.size,
+                            (BYTE)!pWB->is5ver, pWB->is5ver, pWB->charset));
 				if (xls_debug) xls_showCell(cell);
 			}
 			break;
@@ -1661,7 +1679,7 @@ void xls_close_summaryInfo(xlsSummaryInfo *pSI)
 	free(pSI);
 }
 
-void xls_dumpSummary(char *buf,int isSummary,xlsSummaryInfo *pSI) {
+static void xls_dumpSummary(char *buf,int isSummary,xlsSummaryInfo *pSI) {
 	header			*head;
 	sectionList		*secList;
 	propertyList	*plist;

---FILE: src/xlstool.c---
@@ -42,6 +42,13 @@
 
 #ifdef HAVE_ICONV
 #include <iconv.h>
+
+#if defined(_AIX) || defined(__sun)
+static const char *from_enc = ""UTF-16le"";
+#else
+static const char *from_enc = ""UTF-16LE"";
+#endif
+
 #else
 #include <locale.h>
 #endif
@@ -121,14 +128,6 @@ static const DWORD colors[] =
     };
 
 
-void dumpbuf(BYTE* fname,long size,BYTE* buf)
-{
-    FILE *f = fopen((char *)fname, ""wb"");
-    fwrite (buf, 1, size, f);
-    fclose(f);
-
-}
-
 // Display string if in debug mode
 void verbose(char* str)
 {
@@ -175,17 +174,6 @@ char *utf8_decode(const char *str, DWORD len, char *encoding)
 
 #ifdef HAVE_ICONV
 static char* unicode_decode_iconv(const char *s, size_t len, size_t *newlen, const char* to_enc) {
-#if defined(_AIX) || defined(__sun)
-    const char *from_enc = ""UTF-16le"";
-    #define ICONV_CONST const
-#else
-    const char *from_enc = ""UTF-16LE"";
-    #if defined(_WIN32)
-        #define ICONV_CONST const
-    #else
-        #define ICONV_CONST
-    #endif
-#endif
     char* outbuf = 0;
 
     if(s && len && from_enc && to_enc)
@@ -591,8 +579,8 @@ char *xls_getfcell(xlsWorkBook* pWB, struct st_cell_data* cell, BYTE *label)
     case XLS_RECORD_LABELSST:
         offset = label[0] + (label[1] << 8);
         if(!pWB->is5ver) {
-            offset += (label[2] << 16);
-            offset += (label[3] << 24);
+            offset += ((DWORD)label[2] << 16);
+            offset += ((DWORD)label[3] << 24);
         }
         if(offset < pWB->sst.count && pWB->sst.string[offset].str) {
             ret = strdup(pWB->sst.string[offset].str);",True,False,Dependency / Package,7
tidyverse,readxl,a0d4ee29bf40151cf1543faa2b0f2b30c89fd504,Jenny Bryan,jenny.f.bryan@gmail.com,2018-12-15T06:27:44Z,Jenny Bryan,jenny.f.bryan@gmail.com,2018-12-15T06:35:57Z,"Protect against null pointer

Fixes #391

https://github.com/tidyverse/readxl/issues/391

cell_->str for empty cells in this sheet is a null pointer

No prospect for a test sheet. Original sheet is too large and if I
whittle it down in Excel and re-save, the segfault goes away. Must be
due to some specific non-Excel tool.",src/XlsCell.h,False,False,False,False,4,1,5,"---FILE: src/XlsCell.h---
@@ -131,8 +131,11 @@ class XlsCell {
     switch(cell_->id) {
     case XLS_RECORD_LABELSST:
     case XLS_RECORD_LABEL:
-      ct = na.contains((char*) cell_->str, trimWs) ? CELL_BLANK : CELL_TEXT;
+    {
+      std::string s = cell_->str == NULL ? """" : cell_->str;
+      ct = na.contains(s, trimWs) ? CELL_BLANK : CELL_TEXT;
       break;
+    }
 
     case XLS_RECORD_FORMULA:
     case XLS_RECORD_FORMULA_ALT:",False,False,Implementation / Logic,3
tidyverse,readxl,bf642ef7cece9320ab4281dfe6ad3d0a766ca7b7,Jenny Bryan,jenny.f.bryan@gmail.com,2018-12-14T21:21:20Z,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2018-12-14T21:30:50Z,Slightly nicer errors from the C/C++ side,DESCRIPTION;src/Makevars;src/Makevars.win;src/XlsWorkBook.h;src/XlsWorkSheet.h;tests/testthat/test-read-excel.R,False,True,True,False,15,10,25,"---FILE: DESCRIPTION---
@@ -45,7 +45,7 @@ URL: http://readxl.tidyverse.org,
 BugReports: https://github.com/tidyverse/readxl/issues
 Imports:
     cellranger,
-    Rcpp (>= 0.12.12),
+    Rcpp (>= 0.12.18),
     tibble (>= 1.3.1),
     utils
 Suggests:

---FILE: src/Makevars---
@@ -1 +1 @@
-PKG_CPPFLAGS=-Iunix -I. $(C_VISIBILITY)
+PKG_CPPFLAGS=-Iunix -I. $(C_VISIBILITY) -DRCPP_DEFAULT_INCLUDE_CALL=false

---FILE: src/Makevars.win---
@@ -1,4 +1,4 @@
-PKG_CPPFLAGS=-Iwindows -I. -D__USE_MINGW_ANSI_STDIO
+PKG_CPPFLAGS=-Iwindows -I. -D__USE_MINGW_ANSI_STDIO -DRCPP_DEFAULT_INCLUDE_CALL=false
 PKG_LIBS=-lRiconv
 
 all: clean

---FILE: src/XlsWorkBook.h---
@@ -25,7 +25,11 @@ class XlsWorkBook {
     xls::xls_error_t error = xls::LIBXLS_OK;
     xls::xlsWorkBook* pWB_ = xls::xls_open_file(path_.c_str(), ""UTF-8"", &error);
     if (!pWB_) {
-      Rcpp::stop(""Error reading XLS file: %s"", xls::xls_getError(error));
+      Rcpp::stop(
+        ""\n  filepath: %s\n  libxls error: %s"",
+        path_,
+        xls::xls_getError(error)
+      );
     }
 
     n_sheets_ = pWB_->sheets.count;

---FILE: src/XlsWorkSheet.h---
@@ -40,7 +40,11 @@ class XlsWorkSheet {
     std::string path = wb_.path();
     pWB_ = xls_open_file(path.c_str(), ""UTF-8"", &error);
     if (!pWB_) {
-      Rcpp::stop(""Error reading XLS file: %s"", xls::xls_getError(error));
+      Rcpp::stop(
+        ""\n  filepath: %s\n  libxls error: %s"",
+        path,
+        xls::xls_getError(error)
+      );
     }
 
     pWS_ = xls::xls_getWorkSheet(pWB_, sheet_i);

---FILE: tests/testthat/test-read-excel.R---
@@ -19,11 +19,8 @@ test_that(""can read files with and without extension [xls]"", {
 
 test_that(""xlsx is not read as xls and vice versa"", {
   expect_error(
-    expect_output(
-      read_xls(test_sheet(""iris-excel-xlsx.xlsx"")),
-      ""Not an excel file""
-    ),
-    ""Error reading XLS file: Unable to open file"",
+    read_xls(test_sheet(""iris-excel-xlsx.xlsx"")),
+    ""libxls error: Unable to open file""
   )
   expect_error(read_xlsx(test_sheet(""iris-excel-xls.xls"")), ""cannot be opened"")
 })",True,False,Dependency / Package,6
tidyverse,readxl,e9d324f72dde179a503b9ad324d3c2bf6af4644d,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2018-12-12T20:36:26Z,GitHub,noreply@github.com,2018-12-12T20:36:26Z,"PR #505: accept .xlsx that lack a ""styles"" part (#528)

* Accept XLSX files that do not contain a ""styles"" part; fixes #506

An XLSX file that does not contain a ""styles"" part triggers this error:

  > read_excel(""foo.xlsx"", sheet=""Sheet1"")
  Error in sheets_fun(path) :
    Evaluation error: Couldn't find '' in 'foo.xlsx'.

To fix this, check for the presence of the part in cacheDateFormats() in
the same way that cacheStringTable() does.

* Rename test sheet; code style

* Beef up the test a bit

* Add NEWS bullet",NEWS.md;src/XlsxWorkBook.h;tests/testthat/sheets/no-styles-or-sharedStrings-parts.xlsx;tests/testthat/test-read-excel.R,False,True,True,False,14,0,14,"---FILE: NEWS.md---
@@ -14,6 +14,8 @@
   
 ## Other changes
 
+* xlsx files that do not have a ""Styles"" part can now be read (#505, #506 @jt6)
+
 * Path handling:
 
   - All paths are passed through `normalizePath()` (#498, #499, new behaviour for xlsx but not xls) and `enc2native()` (#370).

---FILE: src/XlsxWorkBook.h---
@@ -267,6 +267,10 @@ class XlsxWorkBook {
   }
 
   void cacheDateFormats() {
+    if (!zip_has_file(path_, rel_.part(""styles""))) {
+      return;
+    }
+
     std::string stylesXml = zip_buffer(path_, rel_.part(""styles""));
     rapidxml::xml_document<> styles;
     styles.parse<rapidxml::parse_strip_xml_namespaces>(&stylesXml[0]);

---FILE: tests/testthat/test-read-excel.R---
@@ -115,3 +115,11 @@ test_that(""non-ASCII filenames can be read"", {
   expect_error_free(read_xls(tricky_xls_file))
   expect_error_free(read_xlsx(tricky_xlsx_file))
 })
+
+test_that(""styles and sharedStrings parts can be absent"", {
+  expect_error_free(
+    df <- read_xlsx(test_sheet(""no-styles-or-sharedStrings-parts.xlsx""))
+  )
+  expect_identical(df$Language[1], ""german"")
+  expect_true(all(df$Age > 0))
+ })",True,False,Documentation / Formatting,4
tidyverse,readxl,4b9743958d2bd8f9ef96e616c053cf67031f2056,Jenny Bryan,jenny.f.bryan@gmail.com,2018-12-11T22:38:26Z,Jenny Bryan,jenny.f.bryan@gmail.com,2018-12-11T22:38:26Z,"Oops, copy/paste error from reprex",.travis.yml,False,False,False,False,0,1,1,"---FILE: .travis.yml---
@@ -11,7 +11,6 @@ matrix:
       r_github_packages:
         - tidyverse/tidytemplate
         - r-lib/pkgdown
-      env: DISPLAY=""""
       after_success: Rscript -e 'covr::codecov(line_exclusions = c(""src/xls.c"", ""src/xlstool.c"", ""src/rapidxml.h"", ""src/rapidxml_print.h"", ""src/endian.c"", ""src/ole.c"", ""src/libxls/brdb.h""))'
       deploy:
         provider: script",False,False,Documentation / Formatting,3
tidyverse,readxl,e2b8f70e4f4afb64eac03443942b7fda5a3427a3,Jenny Bryan,jenny.f.bryan@gmail.com,2018-10-30T00:10:31Z,Jenny Bryan,jenny.f.bryan@gmail.com,2018-10-30T00:10:31Z,"Pass `trim_ws` from `read_xls[x]()` into `read_excel_()`

Fixes #514",NEWS.md;R/read_excel.R,False,True,True,False,6,2,8,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # readxl *development version*
 
+* `read_xls()` and `read_xlsx()` pass the `trim_ws` argument along (#514).
+
 * readxl has a new article on reading Excel files with multiple header rows (#486, #492  @apreshill).
 
 ## Breaking change

---FILE: R/read_excel.R---
@@ -110,7 +110,8 @@ read_xls <- function(path, sheet = NULL, range = NULL,
   read_excel_(
     path = path, sheet = sheet, range = range,
     col_names = col_names, col_types = col_types,
-    na = na, skip = skip, n_max = n_max, guess_max = guess_max,
+    na = na, trim_ws = trim_ws, skip = skip,
+    n_max = n_max, guess_max = guess_max,
     format = ""xls""
   )
 }
@@ -125,7 +126,8 @@ read_xlsx <- function(path, sheet = NULL, range = NULL,
   read_excel_(
     path = path, sheet = sheet, range = range,
     col_names = col_names, col_types = col_types,
-    na = na, skip = skip, n_max = n_max, guess_max = guess_max,
+    na = na, trim_ws = trim_ws, skip = skip,
+    n_max = n_max, guess_max = guess_max,
     format = ""xlsx""
   )
 }",True,False,Implementation / Logic,6
tidyverse,readxl,763ca6d42ade5b1ede77d57b41d596b3306ab8a1,Mara Averick,maraaverick@gmail.com,2018-08-30T16:35:25Z,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2018-08-30T16:35:25Z,"Change rapidxml link to regular http (#503)

Fixes #502",DESCRIPTION,False,False,False,False,1,1,2,"---FILE: DESCRIPTION---
@@ -37,7 +37,7 @@ Authors@R:
 Description: Import excel files into R. Supports '.xls' via the
     embedded 'libxls' C library <https://github.com/evanmiller/libxls> and
     '.xlsx' via the embedded 'RapidXML' C++ library
-    <https://rapidxml.sourceforge.net>.  Works on Windows, Mac and Linux
+    <http://rapidxml.sourceforge.net>.  Works on Windows, Mac and Linux
     without external dependencies.
 License: GPL-3
 URL: http://readxl.tidyverse.org,",False,False,Dependency / Package,6
tidyverse,readxl,e6c8fcea0e6e7c937704932cf3ab667211777af2,Jenny Bryan,jenny.f.bryan@gmail.com,2018-08-21T05:19:08Z,Jenny Bryan,jenny.f.bryan@gmail.com,2018-08-21T05:19:08Z,"Fix whitespace in DESCRIPTION

[skip ci]",DESCRIPTION;man/readxl-package.Rd,False,False,False,False,7,7,14,"---FILE: DESCRIPTION---
@@ -14,7 +14,7 @@ Authors@R:
              comment = c(ORCID = ""0000-0002-6983-2759"")),
       person(given = ""RStudio"",
              role = c(""cph"", ""fnd""),
-             comment = ""Copyright holder of\n      all R code and all C/C++ code without explicit copyright attribution""),
+             comment = ""Copyright holder of all R code and all C/C++ code without explicit copyright attribution""),
       person(given = ""Marcin"",
              family = ""Kalicinski"",
              role = c(""ctb"", ""cph""),

---FILE: man/readxl-package.Rd---
@@ -6,10 +6,11 @@
 \alias{readxl-package}
 \title{readxl: Read Excel Files}
 \description{
-Import excel files into R. Supports '.xls' via the embedded
-    'libxls' C library <https://github.com/evanmiller/libxls> and '.xlsx' via
-    the embedded 'RapidXML' C++ library <https://rapidxml.sourceforge.net>.
-    Works on Windows, Mac and Linux without external dependencies.
+Import excel files into R. Supports '.xls' via the
+    embedded 'libxls' C library <https://github.com/evanmiller/libxls> and
+    '.xlsx' via the embedded 'RapidXML' C++ library
+    <https://rapidxml.sourceforge.net>.  Works on Windows, Mac and Linux
+    without external dependencies.
 }
 \seealso{
 Useful links:
@@ -30,8 +31,7 @@ Authors:
 
 Other contributors:
 \itemize{
-  \item RStudio (Copyright holder of
-      all R code and all C/C++ code without explicit copyright attribution) [copyright holder, funder]
+  \item RStudio (Copyright holder of all R code and all C/C++ code without explicit copyright attribution) [copyright holder, funder]
   \item Marcin Kalicinski (Author of included RapidXML code) [contributor, copyright holder]
   \item Komarov Valery (Author of included libxls code) [contributor, copyright holder]
   \item Christophe Leitienne (Author of included libxls code) [contributor, copyright holder]",False,False,Documentation / Formatting,6
tidyverse,readxl,ad57de302942a20f10adccdd191e72041e808419,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2018-08-21T03:46:37Z,GitHub,noreply@github.com,2018-08-21T03:46:37Z,"Normalize all paths, prior conversion to native encoding (#499)

Fixes #498

Prior to b10a1a80fba57e1e7e515b78f64acf62fd75843a,all xls paths were normalized, but we didn't know exactly why. In b10a1a80fba57e1e7e515b78f64acf62fd75843a, I stopped normalizing xls paths, while solving an unrelated path encoding problem presented by R 3.5.

In discussion around #477, @jimhester said:

""I think doing enc2native(normalizePath()) on the R side for both xls and xlsx seems the best option.""

I am now taking this wise advice.",NEWS.md;R/read_excel.R,False,True,True,False,4,5,9,"---FILE: NEWS.md---
@@ -1,4 +1,4 @@
-# readxl 1.1.0.9000
+# readxl *development version*
 
 * readxl has a new vignette on reading excel files with multiple header rows, contributed by @apreshill. (#486, #492)
 
@@ -12,10 +12,9 @@
   
 ## Other changes
 
-* Path handling (#477):
+* Path handling:
 
-  - `.xls` paths are no longer normalized. (#476 xls)
-  - All paths are explicitly converted to the native encoding via `enc2native()`  (#370)
+  - All paths are passed through `normalizePath()` (#498, #499, new behaviour for xlsx but not xls) and `enc2native()` (#370).
 
 # readxl 1.1.0
 

---FILE: R/read_excel.R---
@@ -152,7 +152,7 @@ read_excel_ <- function(path, sheet = NULL, range = NULL,
   tibble::set_tidy_names(
     tibble::as_tibble(
       read_fun(
-        path = enc2native(path), sheet_i = sheet,
+        path = enc2native(normalizePath(path)), sheet_i = sheet,
         limits = limits, shim = shim,
         col_names = col_names, col_types = col_types,
         na = na, trim_ws = trim_ws, guess_max = guess_max",True,False,Implementation / Logic,6
tidyverse,readxl,75cffbf7a66619f9b901aec5027f9d205a270021,Alison Presmanes Hill,apreshill@users.noreply.github.com,2018-07-12T04:58:18Z,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2018-07-12T04:58:18Z,"add mini-vignette on multiple header rows (#494)

* add mini-vignette on multiple header rows

* fix things I didn't mean to touch

* added news bullet

* point to blog post at end of vignette",NEWS.md;vignettes/multiple-header-rows.Rmd,True,False,True,False,64,0,64,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # readxl 1.1.0.9000
 
+* readxl has a new vignette on reading excel files with multiple header rows, contributed by @apreshill. (#486, #492)
+
 ## Breaking change
 
 * Missing or duplicated column names are now repaired with `tibble::set_tidy_names()` in `read_excel()` and friends. `set_tidy_names()` is intended to encourage name repair that is more principled and consistent, across multiple tidyverse packages. Its design is discussed in [tidyverse/tibble#217](https://github.com/tidyverse/tibble/issues/217). (#357, #453)

---FILE: vignettes/multiple-header-rows.Rmd---
@@ -0,0 +1,62 @@
+---
+title: ""Multiple Header Rows""
+output: rmarkdown::html_vignette
+vignette: >
+  %\VignetteIndexEntry{Multiple Header Rows}
+  %\VignetteEngine{knitr::rmarkdown}
+  %\VignetteEncoding{UTF-8}
+---
+
+```{r include = FALSE}
+knitr::opts_chunk$set(
+  collapse = TRUE,
+  comment = ""#>""
+)
+options(tibble.print_min = 4, tibble.print_max = 4)
+```
+
+```{r setup}
+library(magrittr)
+library(readxl)
+```
+
+A common problem when reading data into R is having multiple header rows in the source excel file. Take a look at this messy excel file from sheet 2 in the `clippy.xlsx` example file, which ships with readxl:
+
+```{r}
+readxl_example(""clippy.xlsx"") %>% 
+    read_excel(sheet = 2)
+```
+
+**Problem:** The column names are right, but the first row of data is actually not data- it is additional metadata. This row of metadata is also causing all the columns to import as character. In reality, `death` is a datetime and `weight` is numeric.
+
+**Solution:** We can use the `read_excel()` function to read in the same file twice. In Step 1, we’ll create a character vector of the column names only. In Step 2, we’ll read in the actual data and skip the multiple header rows at the top. When we do this, we lose the column names, so we use the character vector of column names we created in Step 1 instead.
+
+## Step 1
+
+In this step, we read in the first row only (by setting `n_max = 0`), extract the names from that row (using the `names()` function), and assign those to a character vector called `cnames`. This object now contains the correct column names that we’ll need in Step 2.
+
+```{r}
+(cnames <- readxl_example(""clippy.xlsx"") %>% 
+    read_excel(sheet = 2, n_max = 0) %>% 
+    names())
+```
+
+## Step 2
+
+Now we'll read in all the rows except for the first two rows (using `skip = 2`), which contained the variable names and variable descriptions, and set the column names to `cnames`, which we created in Step 1. Now our column types are guessed correctly.
+
+```{r}
+(clippy2 <- readxl_example(""clippy.xlsx"") %>% 
+  read_excel(sheet = 2, skip = 2, col_names = cnames))
+```
+
+
+If you want a way to save that metadata without polluting your actual data, you can do a third read using `n_max = 1`:
+
+```{r}
+(clippy_meta <- readxl_example(""clippy.xlsx"") %>% 
+  read_excel(sheet = 2, n_max = 1))
+```
+
+
+> This vignette has been adapted from a post on [Alison Hill's blog](https://alison.rbind.io/post/read-multiple-header-rows/).",False,True,Documentation / Formatting,7
tidyverse,readxl,66df4b9e65babd7e5b63db2f371fc54d29ef98b8,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2018-04-27T23:11:35Z,GitHub,noreply@github.com,2018-04-27T23:11:35Z,"Patch to https://github.com/evanmiller/libxls/d2726da2e37c7dd95af8dd451e530293a3b90782 (#473)

Fixes the segfault seen in #471, although still does not read sheet",.gitignore;DESCRIPTION;src/ole.c;src/patch-to-libxls-upstream.R;src/xls.c,False,True,True,False,62,15,77,"---FILE: .gitignore---
@@ -10,4 +10,3 @@ scratch.R
 src/fprintf-substitution.R
 fprintf-matches.txt
 investigations
-src/patch-to-libxls-upstream.R

---FILE: DESCRIPTION---
@@ -40,3 +40,4 @@ BugReports: https://github.com/tidyverse/readxl/issues
 VignetteBuilder: knitr
 RoxygenNote: 6.0.1.9000
 Encoding: UTF-8
+Note: libxls-SHA d2726da

---FILE: src/ole.c---
@@ -610,10 +610,10 @@ static ssize_t sector_read(OLE2* ole2, void *buffer, DWORD sid)
 }
 
 // read first 109 sectors of MSAT from header
-static ssize_t read_MSAT_header(OLE2* ole2, OLE2Header* oleh, int sectorCount) {
+static ssize_t read_MSAT_header(OLE2* ole2, OLE2Header* oleh, DWORD sectorCount) {
     BYTE *sector = (BYTE*)ole2->SecID;
     ssize_t bytes_read = 0, total_bytes_read = 0;
-    int sectorNum;
+    DWORD sectorNum;
 
     for (sectorNum = 0; sectorNum < sectorCount && sectorNum < 109; sectorNum++)
     {
@@ -628,7 +628,7 @@ static ssize_t read_MSAT_header(OLE2* ole2, OLE2Header* oleh, int sectorCount) {
 }
 
 // Add additional sectors of the MSAT
-static ssize_t read_MSAT_body(OLE2 *ole2, int sectorOffset, int sectorCount) {
+static ssize_t read_MSAT_body(OLE2 *ole2, DWORD sectorOffset, DWORD sectorCount) {
     DWORD sid = ole2->difstart;
     ssize_t bytes_read = 0, total_bytes_read = 0;
     DWORD sectorNum = sectorOffset;
@@ -732,17 +732,20 @@ static ssize_t read_MSAT_trailer(OLE2 *ole2) {
 static ssize_t read_MSAT(OLE2* ole2, OLE2Header* oleh)
 {
     // reconstitution of the MSAT
-    int count = ole2->cfat;
-    if(count <= 0) {
-        if (xls_debug) fprintf(stderr, ""Error: MSAT count out-of-bounds\n"");
+    DWORD count = ole2->cfat;
+    if(count == 0 || count > (1 << 24)) {
+        if (xls_debug) fprintf(stderr, ""Error: MSAT count %u out-of-bounds\n"", count);
         return -1;
     }
 
     ssize_t total_bytes_read = 0;
     ssize_t bytes_read = 0;
 
-    ole2->SecID = ole_malloc(count*ole2->lsector);
     ole2->SecIDCount = count*ole2->lsector/4;
+    if ((ole2->SecID = ole_malloc(ole2->SecIDCount * sizeof(DWORD))) == NULL) {
+        total_bytes_read = -1;
+        goto cleanup;
+    }
 
     if ((bytes_read = read_MSAT_header(ole2, oleh, count)) == -1) {
         total_bytes_read = -1;

---FILE: src/patch-to-libxls-upstream.R---
@@ -0,0 +1,41 @@
+library(fs)
+library(tidyverse)
+library(here)
+library(git2r)
+library(desc)
+
+libxls_path <- ""~/rrr/libxls-evanmiller-github""
+libxls_SHA <- sha(last_commit(libxls_path))
+there <- function(x) path(libxls_path, x)
+
+if (repository_head(libxls_path)[[""name""]] != ""master"") {
+  message(""YO! You are not on master in libxls! Are you sure about this?"")
+}
+
+## the subset of libxls files that we embed
+paths <- c(
+  ""src/endian.c"",
+  ""src/ole.c"",
+  ""src/xls.c"",
+  ""src/xlstool.c"",
+  ""include/xls.h"",
+  ""include/libxls/brdb.c.h"",
+  ""include/libxls/brdb.h"",
+  ""include/libxls/endian.h"",
+  ""include/libxls/ole.h"",
+  ""include/libxls/xlsstruct.h"",
+  ""include/libxls/xlstool.h"",
+  ""include/libxls/xlstypes.h""
+)
+
+new_paths <- paths
+
+## btw xls.h doesn't live with the other headers in libxls
+## but it needs to do so in readxl
+header_file <- grepl("".h$"", new_paths)
+new_paths[header_file] <-
+  path(""src"", ""libxls"", path_file(new_paths))[header_file]
+
+file_copy(path = there(paths), new_path = here(new_paths), overwrite = TRUE)
+
+desc::desc_set(Note = paste(""libxls-SHA"", substr(libxls_SHA, 1, 7)))

---FILE: src/xls.c---
@@ -1490,21 +1490,24 @@ xlsWorkBook *xls_open_buffer(const unsigned char *buffer, size_t len,
 
 xlsRow *xls_row(xlsWorkSheet* pWS, WORD cellRow)
 {
-    struct st_row_data *row;
+    if(cellRow > pWS->rows.lastrow)
+        return NULL;
 
-    if(cellRow > pWS->rows.lastrow) return NULL;
-    row = &pWS->rows.row[cellRow];
+    if (pWS->rows.row == NULL)
+        return NULL;
 
-    return row;
+    return &pWS->rows.row[cellRow];
 }
 
 xlsCell	*xls_cell(xlsWorkSheet* pWS, WORD cellRow, WORD cellCol)
 {
     struct st_row_data	*row;
 
-    if(cellRow > pWS->rows.lastrow) return NULL;
-    row = &pWS->rows.row[cellRow];
-    if(row == NULL || cellCol >= row->cells.count) return NULL;
+    if ((row = xls_row(pWS, cellRow)) == NULL)
+        return NULL;
+
+    if(cellCol >= row->cells.count)
+        return NULL;
 
     return &row->cells.cell[cellCol];
 }",True,False,Dependency / Package,6
tidyverse,readxl,e72570df78de114a584e8b94d1a1d9743b6cb9ef,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2018-04-26T20:25:16Z,GitHub,noreply@github.com,2018-04-26T20:25:16Z,Patch to https://github.com/evanmiller/libxls/dd658814c97d453f592ea5ec0d6971344d1cc10c (#469),.Rbuildignore;.gitignore;src/endian.c;src/libxls/xlsstruct.h;src/libxls/xlstypes.h;src/ole.c;src/xls.c;src/xlstool.c,False,False,False,False,48,54,102,"---FILE: .Rbuildignore---
@@ -28,3 +28,4 @@
 ^fprintf-matches\.txt$
 ^CRAN-RELEASE$
 ^investigations$
+^src/patch-to-libxls-upstream\.R$

---FILE: .gitignore---
@@ -10,3 +10,4 @@ scratch.R
 src/fprintf-substitution.R
 fprintf-matches.txt
 investigations
+src/patch-to-libxls-upstream.R

---FILE: src/endian.c---
@@ -242,9 +242,9 @@ void xlsConvertFormulaArray(FARRAY *f)
 void xlsConvertHeader(OLE2Header *h)
 {
     int i;
-    for (i=0; i<2; i++)
+    for (i=0; i<sizeof(h->id)/sizeof(h->id[0]); i++)
         h->id[i] = xlsIntVal(h->id[i]);
-    for (i=0; i<4; i++)
+    for (i=0; i<sizeof(h->clid)/sizeof(h->clid[0]); i++)
         h->clid[i] = xlsIntVal(h->clid[i]);
     h->verminor  = xlsShortVal(h->verminor);
     h->verdll    = xlsShortVal(h->verdll);
@@ -265,7 +265,7 @@ void xlsConvertHeader(OLE2Header *h)
     h->csfat = xlsIntVal(h->csfat);
     h->difstart = xlsIntVal(h->difstart);
     h->cdif = xlsIntVal(h->cdif);
-    for (i=0; i<109; i++)
+    for (i=0; i<sizeof(h->MSAT)/sizeof(h->MSAT[0]); i++)
         h->MSAT[i] = xlsIntVal(h->MSAT[i]);
 }
 

---FILE: src/libxls/xlsstruct.h---
@@ -187,7 +187,7 @@ typedef struct RK
     WORD	row;
     WORD	col;
     WORD	xf;
-    DWORD_UA value;
+    DWORD   value;
 }
 RK;
 
@@ -197,7 +197,7 @@ typedef struct MULRK
     WORD	col;
 	struct {
 		WORD	xf;
-		DWORD_UA value;
+		DWORD   value;
 	}		rk[1];
 	//WORD	last_col;
 }

---FILE: src/libxls/xlstypes.h---
@@ -39,14 +39,6 @@ typedef unsigned char		BYTE;
 typedef uint16_t			WORD;
 typedef uint32_t			DWORD;
 
-#ifdef NO_ALIGN
-typedef uint16_t			WORD_UA;
-typedef uint32_t			DWORD_UA;
-#else
-typedef uint16_t			WORD_UA		__attribute__ ((aligned (1)));	// 2 bytes
-typedef uint32_t			DWORD_UA	__attribute__ ((aligned (1)));	// 4 bytes
-#endif
-
 #ifdef _WIN32
 typedef unsigned __int64	unsigned64_t;
 #else

---FILE: src/ole.c---
@@ -30,7 +30,7 @@
  *
  */
 
-#include ""config.h""
+#include ""config.h"" 
 
 #include <memory.h>
 #include <math.h>
@@ -82,7 +82,7 @@ int ole2_validate_sector(DWORD sector, OLE2 *ole) {
 }
 
 // Read next sector of stream
-int ole2_bufread(OLE2Stream* olest)
+int ole2_bufread(OLE2Stream* olest) 
 {
 	BYTE *ptr;
 
@@ -101,7 +101,7 @@ int ole2_bufread(OLE2Stream* olest)
             }
 
 			ptr = olest->ole->SSAT + olest->fatpos*olest->ole->lssector;
-			memcpy(olest->buf, ptr, olest->bufsize);
+			memcpy(olest->buf, ptr, olest->bufsize); 
 
             if (olest->fatpos >= olest->ole->SSecIDCount) {
                 if (xls_debug) fprintf(stderr, ""Error: fatpos %d out-of-bounds for SSecID[%d]\n"",
@@ -146,7 +146,7 @@ ssize_t ole2_read(void* buf, size_t size, size_t count, OLE2Stream* olest)
     if ((long)olest->size>=0 && !olest->sfat)	// directory is -1
     {
 		size_t rem;
-		rem = olest->size - (olest->cfat*olest->ole->lsector+olest->pos);
+		rem = olest->size - (olest->cfat*olest->ole->lsector+olest->pos);		
         totalReadCount = rem<totalReadCount?rem:totalReadCount;
         if (rem<=0) olest->eof=1;
 
@@ -365,7 +365,7 @@ static ssize_t ole2_read_header(OLE2 *ole) {
         total_bytes_read = -1;
         goto cleanup;
     }
-
+	
     ole->cfat=oleh->cfat;
     ole->dirstart=oleh->dirstart;
     ole->sectorcutoff=oleh->sectorcutoff;
@@ -386,7 +386,7 @@ static ssize_t ole2_read_header(OLE2 *ole) {
 		fprintf(stderr, ""mini len:      %X (%i)\n"",ole->lssector,ole->lssector);	// ole
 		fprintf(stderr, ""Fat sect.:     %i \n"",oleh->cfat);
 		fprintf(stderr, ""Dir Start:     %i \n"",oleh->dirstart);
-
+		
 		fprintf(stderr, ""Mini Cutoff:   %i \n"",oleh->sectorcutoff);
 		fprintf(stderr, ""MiniFat Start: %X \n"",oleh->sfatstart);
 		fprintf(stderr, ""Count MFat:    %i \n"",oleh->csfat);
@@ -431,21 +431,21 @@ static ssize_t ole2_read_body(OLE2 *ole) {
             goto cleanup;
         }
         name=unicode_decode(pss->name, pss->bsize, 0, ""UTF-8"");
-#ifdef OLE_DEBUG
+#ifdef OLE_DEBUG	
 		fprintf(stderr, ""OLE NAME: %s count=%d\n"", name, (int)ole->files.count);
 #endif
-        if (pss->type == PS_USER_ROOT || pss->type == PS_USER_STREAM) // (name!=NULL) //
+        if (pss->type == PS_USER_ROOT || pss->type == PS_USER_STREAM) // (name!=NULL) // 
         {
 
-#ifdef OLE_DEBUG
+#ifdef OLE_DEBUG		
 			fprintf(stderr, ""OLE TYPE: %s file=%d \n"", pss->type == PS_USER_ROOT ? ""root"" : ""user"", (int)ole->files.count);
-#endif
+#endif		
             ole->files.file = realloc(ole->files.file,(ole->files.count+1)*sizeof(struct st_olefiles_data));
             ole->files.file[ole->files.count].name=name;
             ole->files.file[ole->files.count].start=pss->sstart;
             ole->files.file[ole->files.count].size=pss->size;
             ole->files.count++;
-
+			
 			if(pss->sstart == ENDOFCHAIN) {
 				if (xls_debug) verbose(""END OF CHAIN\n"");
 			} else if(pss->type == PS_USER_STREAM) {
@@ -468,7 +468,7 @@ static ssize_t ole2_read_body(OLE2 *ole) {
 			} else if(pss->type == PS_USER_ROOT) {
 				DWORD sector, k, blocks;
 				BYTE *wptr;
-
+				
 				blocks = (pss->size + (ole->lsector - 1)) / ole->lsector;	// count partial
 				if ((ole->SSAT = ole_malloc(blocks*ole->lsector)) == NULL) {
                     total_bytes_read = -1;
@@ -494,7 +494,7 @@ static ssize_t ole2_read_body(OLE2 *ole) {
 					wptr += ole->lsector;
 					sector = xlsIntVal(ole->SecID[sector]);
 				}
-			}
+			}	
 		} else {
 			free(name);
 		}
@@ -615,7 +615,7 @@ static ssize_t read_MSAT_header(OLE2* ole2, OLE2Header* oleh, int sectorCount) {
     ssize_t bytes_read = 0, total_bytes_read = 0;
     int sectorNum;
 
-    for (sectorNum = 0; sectorNum < sectorCount; sectorNum++)
+    for (sectorNum = 0; sectorNum < sectorCount && sectorNum < 109; sectorNum++)
     {
         if ((bytes_read = sector_read(ole2, sector, oleh->MSAT[sectorNum])) == -1) {
             if (xls_debug) fprintf(stderr, ""Error: Unable to read sector #%d\n"", oleh->MSAT[sectorNum]);
@@ -633,7 +633,7 @@ static ssize_t read_MSAT_body(OLE2 *ole2, int sectorOffset, int sectorCount) {
     ssize_t bytes_read = 0, total_bytes_read = 0;
     DWORD sectorNum = sectorOffset;
 
-    BYTE *sector = ole_malloc(ole2->lsector);
+    DWORD *sector = ole_malloc(ole2->lsector);
     //printf(""sid=%u (0x%x) sector=%u\n"", sid, sid, ole2->lsector);
     while (sid != ENDOFCHAIN && sid != FREESECT) // FREESECT only here due to an actual file that requires it (old Apple Numbers bug)
     {
@@ -649,7 +649,7 @@ static ssize_t read_MSAT_body(OLE2 *ole2, int sectorOffset, int sectorCount) {
         // read content
         for (posInSector = 0; posInSector < (ole2->lsector-4)/4; posInSector++)
         {
-            DWORD s = *(DWORD_UA *)(sector + posInSector*4);
+            DWORD s = sector[posInSector];
             //printf(""   s[%d]=%d (0x%x)\n"", posInSector, s, s);
 
             if (s != ENDOFCHAIN && s != FREESECT) // see patch in Bug 31. For very large files
@@ -668,7 +668,7 @@ static ssize_t read_MSAT_body(OLE2 *ole2, int sectorOffset, int sectorCount) {
                 sectorNum++;
             }
         }
-        sid = *(DWORD_UA *)(sector + posInSector*4);
+        sid = sector[posInSector];
         //printf(""   s[%d]=%d (0x%x)\n"", posInSector, sid, sid);
     }
 #ifdef OLE_DEBUG
@@ -732,7 +732,7 @@ static ssize_t read_MSAT_trailer(OLE2 *ole2) {
 static ssize_t read_MSAT(OLE2* ole2, OLE2Header* oleh)
 {
     // reconstitution of the MSAT
-    int count = (ole2->cfat < 109) ? ole2->cfat : 109;
+    int count = ole2->cfat;
     if(count <= 0) {
         if (xls_debug) fprintf(stderr, ""Error: MSAT count out-of-bounds\n"");
         return -1;

---FILE: src/xls.c---
@@ -53,7 +53,7 @@
 //#define DEBUG_DRAWINGS
 int xls_debug = 0;
 
-static double NumFromRk(DWORD_UA drk);
+static double NumFromRk(DWORD drk);
 static xls_formula_handler formula_handler;
 
 extern xls_error_t xls_addSST(xlsWorkBook* pWB, SST* sst, DWORD size);
@@ -198,7 +198,7 @@ xls_error_t xls_appendSST(xlsWorkBook* pWB, BYTE* buf, DWORD size)
 
             // Size of asian phonetic settings block
             if (flag & 0x4) {
-                if (ofs + sizeof(DWORD_UA) > size) {
+                if (ofs + sizeof(DWORD) > size) {
                     return LIBXLS_ERROR_PARSE;
                 }
                 sz = buf[ofs+0] + (buf[ofs+1] << 8) + (buf[ofs+2] << 16) + (buf[ofs+3] << 24);
@@ -313,7 +313,7 @@ xls_error_t xls_appendSST(xlsWorkBook* pWB, BYTE* buf, DWORD size)
     return LIBXLS_OK;
 }
 
-static double NumFromRk(DWORD_UA drk)
+static double NumFromRk(DWORD drk)
 {
 	double ret;
 
@@ -493,7 +493,7 @@ struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
 {
     struct st_cell_data*	cell;
     struct st_row_data*		row;
-    WORD_UA                 col;
+    WORD                    col;
     int						i;
 
 	verbose (""xls_addCell"");
@@ -739,7 +739,7 @@ xls_error_t xls_addColinfo(xlsWorkSheet* pWS,COLINFO* colinfo)
 
 xls_error_t xls_mergedCells(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
 {
-    if (bof->size < sizeof(WORD_UA))
+    if (bof->size < sizeof(WORD))
         return LIBXLS_ERROR_PARSE;
 
     int count = buf[0] + (buf[1] << 8);
@@ -1003,7 +1003,7 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 				unsigned char *p = buf + 2;
 				int idx, len;
 
-				len = *(WORD_UA *)buf;
+				len = buf[0] + (buf[1] << 8);
 				for(idx=0; idx<len; ++idx) {
 					printf(""   Index=0x%2.2x %2.2x%2.2x%2.2x\n"", idx+8, p[0], p[1], p[2] );
 					p += 4;
@@ -1017,7 +1017,7 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 				printf(""   mode: 0x%x\n"", pWB->is1904);
 			}
 			break;
-
+		
 		case XLS_RECORD_DEFINEDNAME:
 			if(xls_debug) {
 				int i;
@@ -1026,7 +1026,7 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 				printf(""\n"");
 			}
 			break;
-
+			
         default:
 			if(xls_debug)
 			{
@@ -1085,7 +1085,7 @@ xls_error_t xls_preparseWorkSheet(xlsWorkSheet* pWS)
         switch (tmp.id)
         {
         case XLS_RECORD_DEFCOLWIDTH:
-            if (tmp.size < sizeof(WORD_UA)) {
+            if (tmp.size < sizeof(WORD)) {
                 retval = LIBXLS_ERROR_PARSE;
                 goto cleanup;
             }
@@ -1274,22 +1274,22 @@ xls_error_t xls_parseWorkSheet(xlsWorkSheet* pWS)
             }
             break;
 		case XLS_RECORD_DEFCOLWIDTH:
-            if (tmp.size < sizeof(WORD_UA)) {
+            if (tmp.size < sizeof(WORD)) {
                 retval = LIBXLS_ERROR_PARSE;
                 goto cleanup;
             }
-			if(xls_debug > 10) printf(""DEFAULT COL WIDTH: %d\n"", *(WORD_UA *)buf);
+			if(xls_debug > 10) printf(""DEFAULT COL WIDTH: %d\n"", ((WORD *)buf)[0]);
 			break;
 		case XLS_RECORD_DEFAULTROWHEIGHT:
-            if (tmp.size < 2 * sizeof(WORD_UA)) {
+            if (tmp.size < 2 * sizeof(WORD)) {
                 retval = LIBXLS_ERROR_PARSE;
                 goto cleanup;
             }
-			if(xls_debug > 10) printf(""DEFAULT ROW Height: 0x%x %d\n"", ((WORD_UA *)buf)[0], ((WORD_UA *)buf)[1]);
+			if(xls_debug > 10) printf(""DEFAULT ROW Height: 0x%x %d\n"", ((WORD *)buf)[0], ((WORD *)buf)[1]);
 			break;
 		case XLS_RECORD_DBCELL:
 			if(xls_debug > 10) {
-				DWORD *foo = (DWORD_UA *)buf;
+				DWORD *foo = (DWORD *)buf;
                 WORD *goo;
 				int i;
                 printf(""DBCELL: size %d\n"", tmp.size);
@@ -1301,7 +1301,7 @@ xls_error_t xls_parseWorkSheet(xlsWorkSheet* pWS)
 			break;
         case XLS_RECORD_INDEX:
 			if(xls_debug > 10) {
-				DWORD *foo = (DWORD_UA *)buf;
+				DWORD *foo = (DWORD *)buf;
                 int i;
 				printf(""INDEX: size %d\n"", tmp.size);
 				for(i=0; i<5; ++i) printf(""FOO[%d]=%4.4x %u\n"", i, foo[i], foo[i]);

---FILE: src/xlstool.c---
@@ -138,13 +138,13 @@ char *utf8_decode(const char *str, DWORD len, char *encoding)
 	int utf8_chars = 0;
 	char *ret = NULL;
     DWORD i;
-
+	
 	for(i=0; i<len; ++i) {
 		if(str[i] & (BYTE)0x80) {
 			++utf8_chars;
 		}
 	}
-
+	
 	if(utf8_chars == 0 || strcmp(encoding, ""UTF-8"")) {
 		ret = malloc(len+1);
 		memcpy(ret, str, len);
@@ -218,7 +218,7 @@ char* unicode_decode(const char *s, size_t len, size_t *newlen, const char* to_e
                 return outbuf;
             }
         }
-        size_t st;
+        size_t st; 
         outbuf = malloc(outlen + 1);
 
 		if(outbuf)
@@ -313,13 +313,13 @@ char *get_string(const char *s, size_t len, BYTE is2, BYTE is5ver, char *charset
     BYTE flag = 0;
     const char *str = s;
     char *ret = NULL;
-
+	
     if (is2) {
 		// length is two bytes
         if (ofs + 2 > len) {
             return NULL;
         }
-        ln=xlsShortVal(*(WORD_UA *)str);
+        ln= ((BYTE*)str)[0] + (((BYTE*)str)[1] << 8);
         ofs+=2;
     } else {
 		// single byte length
@@ -367,9 +367,9 @@ char *get_string(const char *s, size_t len, BYTE is2, BYTE is5ver, char *charset
 		printf(""ofs=%d ret[0]=%d\n"", ofs, *ret);
 		{
 			unsigned char *ptr;
-
+			
 			ptr = ret;
-
+			
 			printf(""%x %x %x %x %x %x %x %x\n"", ptr[0], ptr[1], ptr[2], ptr[3], ptr[4], ptr[5], ptr[6], ptr[7] );
 			printf(""%s\n"", ret);
 		}
@@ -550,7 +550,7 @@ void xls_showFormat(struct st_format_data* frmt)
 void xls_showXF(XF8* xf)
 {
 	static int idx;
-
+	
     printf(""      Index: %u\n"",idx++);
     printf(""       Font: %u\n"",xf->font);
     printf(""     Format: %u\n"",xf->format);",False,False,Implementation / Logic,6
tidyverse,readxl,33f2804d0289bea6bea9c38412d356197b6bcfad,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2018-04-25T16:33:45Z,GitHub,noreply@github.com,2018-04-25T16:33:45Z,"Don't push empty string onto shared string table (#465)

* Don't push empty string onto shared string table

Fixes #463

* Delete confusing comment",src/XlsxWorkBook.h,False,False,False,False,3,2,5,"---FILE: src/XlsxWorkBook.h---
@@ -260,8 +260,9 @@ class XlsxWorkBook {
     for (rapidxml::xml_node<>* string = sst->first_node();
          string; string = string->next_sibling()) {
       std::string out;
-      parseString(string, &out);    // missing strings are treated as empty
-      stringTable_.push_back(out);
+      if (parseString(string, &out)) {
+        stringTable_.push_back(out);
+      }
     }
   }
 ",False,False,Rendering / Conversion,0
tidyverse,readxl,a7bfa4c952b2c1e01f303546f55641d34fd841cb,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2018-04-25T00:39:30Z,GitHub,noreply@github.com,2018-04-25T00:39:30Z,"Switch to tibble::set_tidy_names() from tibble::repair_names() (#453)

Resolves #357

Our discussion about name repair is here: https://github.com/tidyverse/tibble/issues/217",DESCRIPTION;NEWS.md;R/read_excel.R;tests/testthat/helper.R;tests/testthat/test-col-names.R;tests/testthat/test-compatibility.R;tests/testthat/test-missing-values.R,False,True,True,False,20,11,31,"---FILE: DESCRIPTION---
@@ -27,7 +27,7 @@ LinkingTo: Rcpp
 Imports:
     cellranger,
     Rcpp (>= 0.12.12),
-    tibble (>= 1.1)
+    tibble (>= 1.3.1)
 Suggests:
     covr,
     knitr,

---FILE: NEWS.md---
@@ -1,5 +1,11 @@
 # readxl 1.1.0.9000
 
+* Missing or duplicated column names are now repaired with `tibble::set_tidy_names()` in `read_excel()` and friends. `set_tidy_names()` is intended to encourage name repair that is more principled and consistent, across multiple tidyverse packages. Its design is discussed in [tidyverse/tibble#217](https://github.com/tidyverse/tibble/issues/217). (#357, #453)
+
+  - Example of change a user will see: consider a spreadsheet with three columns, one unnamed and two named `x`.
+  - Column names in readxl > 1.1.0: `..1`, `x..2`, `x..3`
+  - Column names in readxl <= 1.1.0: `X__1`, `x`, `x__1`
+
 # readxl 1.1.0
 
 * `read_excel()` and `excel_sheets()` associate a larger set of file extensions with xlsx and are better able to guess the format of a file with a nonstandard or missing extension. This is about deciding whether to treat a file as xls or xlsx. (#342, #411, #457)

---FILE: R/read_excel.R---
@@ -149,7 +149,7 @@ read_excel_ <- function(path, sheet = NULL, range = NULL,
   col_types <- check_col_types(col_types)
   guess_max <- check_guess_max(guess_max)
   trim_ws <- check_bool(trim_ws, ""trim_ws"")
-  tibble::repair_names(
+  tibble::set_tidy_names(
     tibble::as_tibble(
       read_fun(
         path = path, sheet_i = sheet,
@@ -158,8 +158,7 @@ read_excel_ <- function(path, sheet = NULL, range = NULL,
         na = na, trim_ws = trim_ws, guess_max = guess_max
       ),
       validate = FALSE
-    ),
-    prefix = ""X"", sep = ""__""
+    )
   )
 }
 

---FILE: tests/testthat/helper.R---
@@ -5,3 +5,7 @@ test_sheet <- function(fname) rprojroot::find_testthat_root_file(""sheets"", fname
 ## once https://github.com/hadley/testthat/commit/c83aba9 is on CRAN
 ## can use testthat::test_path() for this, i.e.,
 # test_sheet <- function(fname) testthat::test_path(""sheets"", fname)
+
+expect_error_free <- function(...) {
+  expect_error(..., regexp = NA)
+}

---FILE: tests/testthat/test-col-names.R---
@@ -46,16 +46,16 @@ test_that(""col_names = FALSE mimics missing column names [xls]"", {
 
 test_that(""missing column names are populated"", {
   df <- read_excel(test_sheet(""unnamed-duplicated-columns.xlsx""))
-  expect_identical(names(df)[c(1, 3)], c(""X__1"", ""X__2""))
+  expect_identical(names(df)[c(1, 3)], c(""..1"", ""..3""))
   df <- read_excel(test_sheet(""unnamed-duplicated-columns.xls""))
-  expect_identical(names(df)[c(1, 3)], c(""X__1"", ""X__2""))
+  expect_identical(names(df)[c(1, 3)], c(""..1"", ""..3""))
 })
 
 test_that(""column names are de-duplicated"", {
   df <- read_excel(test_sheet(""unnamed-duplicated-columns.xlsx""))
-  expect_identical(names(df)[4], ""var2__1"")
+  expect_identical(names(df)[4], ""var2..4"")
   df <- read_excel(test_sheet(""unnamed-duplicated-columns.xls""))
-  expect_identical(names(df)[4], ""var2__1"")
+  expect_identical(names(df)[4], ""var2..4"")
 })
 
 test_that(""wrong length column names are rejected"", {

---FILE: tests/testthat/test-compatibility.R---
@@ -61,7 +61,7 @@ test_that(""formula cell with no v node does not cause crash"", {
 ## LAPD uses a tool to produce xlsx that implements the minimal SpreadsheetML
 ## package structure described on pp65-66 of ECMA 5th edition
 test_that(""we can read LAPD arrest sheets"", {
-  expect_silent(
+  expect_error_free(
     lapd <- read_excel(test_sheet(""los-angeles-arrests-xlsx.xlsx""), skip = 2)
   )
   expect_identical(dim(lapd), c(193L, 36L))

---FILE: tests/testthat/test-missing-values.R---
@@ -120,7 +120,7 @@ test_that(""empty (styled) cells are not loaded, but can survive as NA [xlsx]"", {
     var1 = c(""val1,1"", ""val2,1"", ""val3,1""),
     var2 = NA,
     var3 = c(""aa"", ""bb"", ""cc""),
-    X__1 = NA,
+     ..4 = NA,
     var5 = c(1, 2, 3)
   )
   expect_equal(out, df)
@@ -132,7 +132,7 @@ test_that(""empty (styled) cells are not loaded, but can survive as NA [xls]"", {
     var1 = c(""val1,1"", ""val2,1"", ""val3,1""),
     var2 = NA,
     var3 = c(""aa"", ""bb"", ""cc""),
-    X__1 = NA,
+     ..4 = NA,
     var5 = c(1, 2, 3)
   )
   expect_equal(out, df)",True,False,Dependency / Package,6
tidyverse,readxl,acb0b5d49d2abab4ca064c5d446a92e2cc6c3cf7,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2018-04-20T22:33:16Z,GitHub,noreply@github.com,2018-04-20T22:33:16Z,"Take advantage of improved C++ compatibility in libxls (#461)

* Patch to https://github.com/evanmiller/libxls/811408fa031f2f0c1a2e6612bf58dc64bea6d450

* Try out cpp-compat branch of libxls

https://github.com/evanmiller/libxls/92e2baef2c4e77d2ff045a3ec025714fff5a5171

* Remove the pragmas

* Patch to https://github.com/evanmiller/libxls/e904fbbb1034000c3c523246fa2f74438fc1b107",src/ColSpec.h;src/XlsWorkBook.cpp;src/endian.c;src/libxls/xlsstruct.h;src/ole.c;src/xls.c;src/xlstool.c,False,False,False,False,127,118,245,"---FILE: src/ColSpec.h---
@@ -1,9 +1,6 @@
 #ifndef READXL_COLSPEC_
 #define READXL_COLSPEC_
 
-# pragma GCC diagnostic ignored ""-Wpedantic""
-# pragma clang diagnostic ignored ""-Wc99-extensions""
-
 #include <Rcpp.h>
 #include <libxls/xls.h>
 #include ""StringSet.h""

---FILE: src/XlsWorkBook.cpp---
@@ -1,8 +1,5 @@
 #include <Rcpp.h>
 
-# pragma GCC diagnostic ignored ""-Wpedantic""
-# pragma clang diagnostic ignored ""-Wc99-extensions""
-
 #include ""XlsWorkBook.h""
 using namespace Rcpp;
 

---FILE: src/endian.c---
@@ -211,12 +211,10 @@ void xlsConvertFormula(FORMULA *f)
     W_ENDIAN(f->xf);
 	if(f->res == 0xFFFF) {
 		switch(f->resid) {
-		case 0:
-		case 3:
-			break;
-		case 1:
-		case 2:
-			W_ENDIAN(*(WORD *)&f->resdata[1]);
+		case 0: // string
+		case 1: // bool
+		case 2: // error
+		case 3: // empty string
 			break;
 		default:
 			xlsConvertDouble(&f->resid);

---FILE: src/libxls/xlsstruct.h---
@@ -127,7 +127,7 @@ typedef struct BOUNDSHEET
     DWORD	filepos;
     BYTE	type;
     BYTE	visible;
-    char	name[];
+    char	name[1];
 }
 BOUNDSHEET;
 
@@ -198,7 +198,7 @@ typedef struct MULRK
 	struct {
 		WORD	xf;
 		DWORD_UA value;
-	}		rk[];
+	}		rk[1];
 	//WORD	last_col;
 }
 MULRK;
@@ -207,7 +207,7 @@ typedef struct MULBLANK
 {
     WORD	row;
     WORD	col;
-    WORD	xf[];
+    WORD	xf[1];
 	//WORD	last_col;
 }
 MULBLANK;
@@ -225,7 +225,7 @@ typedef struct LABEL
     WORD	row;
     WORD	col;
     WORD	xf;
-    BYTE	value[]; // var
+    BYTE	value[1]; // var
 }
 LABEL;
 typedef LABEL LABELSST;
@@ -244,7 +244,7 @@ typedef struct SST
 {
     DWORD	num;
     DWORD	numofstr;
-    BYTE	strings[];
+    BYTE	strings[1];
 }
 SST;
 
@@ -316,14 +316,14 @@ typedef struct FONT
     BYTE	family;
     BYTE	charset;
     BYTE	notused;
-    char    name[];
+    char    name[1];
 }
 FONT;
 
 typedef struct FORMAT
 {
     WORD	index;
-    char	value[];
+    char	value[1];
 }
 FORMAT;
 

---FILE: src/ole.c---
@@ -53,8 +53,8 @@ extern int xls_debug;
 static const DWORD ENDOFCHAIN	= 0xFFFFFFFE;	// -2
 static const DWORD FREESECT		= 0xFFFFFFFF;	// -1
 
-static size_t sector_pos(OLE2* ole2, size_t sid);
-static ssize_t sector_read(OLE2* ole2, void *buffer, size_t sid);
+static size_t sector_pos(OLE2* ole2, DWORD sid);
+static ssize_t sector_read(OLE2* ole2, void *buffer, DWORD sid);
 static ssize_t read_MSAT(OLE2* ole2, OLE2Header *oleh);
 static void *ole_malloc(size_t len);
 
@@ -65,6 +65,22 @@ static void *ole_malloc(size_t len) {
     return malloc(len);
 }
 
+int ole2_validate_sector(DWORD sector, OLE2 *ole) {
+    if (sector >= ole->SecIDCount) {
+        if (xls_debug) fprintf4(stderr, ""Error: fatpos %d out-of-bounds for SecID[%d]\n"",
+                (int)sector, ole->SecIDCount);
+        return 0;
+    }
+
+    if (sector == xlsIntVal(ole->SecID[sector])) {
+        if (xls_debug) fprintf4(stderr, ""Error: Sector loop detected, SecID[%d] = %d\n"",
+                (int)sector, (int)sector);
+        return 0;
+    }
+
+    return 1;
+}
+
 // Read next sector of stream
 int ole2_bufread(OLE2Stream* olest)
 {
@@ -103,15 +119,7 @@ int ole2_bufread(OLE2Stream* olest)
                 return -1;
             }
 
-            if (olest->fatpos >= olest->ole->SecIDCount) {
-                if (xls_debug) fprintf4(stderr, ""Error: fatpos %d out-of-bounds for SecID[%d]\n"",
-                        (int)olest->fatpos, olest->ole->SecIDCount);
-                return -1;
-            }
-
-            if (olest->fatpos == xlsIntVal(olest->ole->SecID[olest->fatpos])) {
-                if (xls_debug) fprintf4(stderr, ""Error: Sector loop detected, SecID[%d] = %d\n"",
-                        (int)olest->fatpos, (int)olest->fatpos);
+            if (!ole2_validate_sector(olest->fatpos, olest->ole)) {
                 return -1;
             }
 
@@ -261,7 +269,7 @@ int ole2_seek(OLE2Stream* olest,DWORD ofs)
         if (div_rez.quot!=0)
         {
             for (i=0;i<div_rez.quot;i++) {
-                if (olest->fatpos >= olest->ole->SecIDCount)
+                if (!ole2_validate_sector(olest->fatpos, olest->ole))
                     return -1;
                 olest->fatpos=xlsIntVal(olest->ole->SecID[olest->fatpos]);
             }
@@ -478,6 +486,10 @@ static ssize_t ole2_read_body(OLE2 *ole) {
                         total_bytes_read = -1;
                         goto cleanup;
                     }
+                    if (!ole2_validate_sector(sector, ole)) {
+                        total_bytes_read = -1;
+                        goto cleanup;
+                    }
                     total_bytes_read += ole->lsector;
 					wptr += ole->lsector;
 					sector = xlsIntVal(ole->SecID[sector]);
@@ -555,14 +567,14 @@ void ole2_close(OLE2* ole2)
     if (ole2->file)
         fclose(ole2->file);
 
-	for(i=0; i<ole2->files.count; ++i) {
-		free(ole2->files.file[i].name);
-	}
-	free(ole2->files.file);
-	free(ole2->SecID);
-	free(ole2->SSecID);
-	free(ole2->SSAT);
-	free(ole2);
+    for(i=0; i<ole2->files.count; ++i) {
+        free(ole2->files.file[i].name);
+    }
+    free(ole2->files.file);
+    free(ole2->SecID);
+    free(ole2->SSecID);
+    free(ole2->SSAT);
+    free(ole2);
 }
 
 void ole2_fclose(OLE2Stream* ole2st)
@@ -572,23 +584,25 @@ void ole2_fclose(OLE2Stream* ole2st)
 }
 
 // Return offset in bytes of a sector from its sid
-static size_t sector_pos(OLE2* ole2, size_t sid)
+static size_t sector_pos(OLE2* ole2, DWORD sid)
 {
     return 512 + sid * ole2->lsector;
 }
 // Read one sector from its sid
-static ssize_t sector_read(OLE2* ole2, void *buffer, size_t sid)
+static ssize_t sector_read(OLE2* ole2, void *buffer, DWORD sid)
 {
 	size_t num;
 	size_t seeked;
 
 	if ((seeked = ole2_fseek(ole2, sector_pos(ole2, sid))) != 0) {
-		if (xls_debug) fprintf5(stderr, ""Error: wanted to seek to sector %zu (0x%zx) loc=%zu\n"", sid, sid, sector_pos(ole2, sid));
+		if (xls_debug) fprintf5(stderr, ""Error: wanted to seek to sector %u (0x%x) loc=%u\n"", sid, sid,
+                (unsigned int)sector_pos(ole2, sid));
         return -1;
     }
 
     if ((num = ole2_fread(ole2, buffer, ole2->lsector, 1)) != 1) {
-        if (xls_debug) fprintf4(stderr, ""Error: fread wanted 1 got %zu loc=%zu\n"", num, sector_pos(ole2, sid));
+        if (xls_debug) fprintf4(stderr, ""Error: fread wanted 1 got %lu loc=%u\n"", (unsigned long)num,
+                (unsigned int)sector_pos(ole2, sid));
         return -1;
     }
 
@@ -617,7 +631,7 @@ static ssize_t read_MSAT_header(OLE2* ole2, OLE2Header* oleh, int sectorCount) {
 static ssize_t read_MSAT_body(OLE2 *ole2, int sectorOffset, int sectorCount) {
     DWORD sid = ole2->difstart;
     ssize_t bytes_read = 0, total_bytes_read = 0;
-    int sectorNum = sectorOffset;
+    DWORD sectorNum = sectorOffset;
 
     BYTE *sector = ole_malloc(ole2->lsector);
     //printf(""sid=%u (0x%x) sector=%u\n"", sid, sid, ole2->lsector);
@@ -690,6 +704,10 @@ static ssize_t read_MSAT_trailer(OLE2 *ole2) {
 			if (sector == ENDOFCHAIN || sector_read(ole2, wptr, sector) == -1) {
                 total_bytes_read = -1;
                 goto cleanup;
+            }
+            if (!ole2_validate_sector(sector, ole2)) {
+                total_bytes_read = -1;
+                goto cleanup;
             }
 			wptr += ole2->lsector;
             total_bytes_read += ole2->lsector;

---FILE: src/xls.c---
@@ -34,6 +34,7 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <stddef.h>
 #include <errno.h>
 
 #include <memory.h>
@@ -90,7 +91,7 @@ typedef struct {
 	uint32_t		os;
 	uint32_t		format[4];
 	uint32_t		count;
-	sectionList		secList[];
+	sectionList		secList[1];
 } header;
 
 typedef struct {
@@ -101,12 +102,12 @@ typedef struct {
 typedef struct {
 	uint32_t		length;
 	uint32_t		numProperties;
-	propertyList	properties[];
+	propertyList	properties[1];
 } sectionHeader;
 
 typedef struct {
 	uint32_t		propertyID;
-	uint32_t		data[];
+	uint32_t		data[1];
 } property;
 
 #pragma pack(pop)
@@ -134,7 +135,7 @@ xls_error_t xls_addSST(xlsWorkBook* pWB,SST* sst,DWORD size)
                     sizeof(struct str_sst_string))) == NULL)
         return LIBXLS_ERROR_MALLOC;
 
-    return xls_appendSST(pWB, sst->strings, size - sizeof(SST));
+    return xls_appendSST(pWB, sst->strings, size - offsetof(SST, strings));
 }
 
 xls_error_t xls_appendSST(xlsWorkBook* pWB, BYTE* buf, DWORD size)
@@ -167,7 +168,7 @@ xls_error_t xls_appendSST(xlsWorkBook* pWB, BYTE* buf, DWORD size)
             if (ofs + 2 > size) {
                 return LIBXLS_ERROR_PARSE;
             }
-            ln=xlsShortVal(*(WORD_UA *)(buf+ofs));
+            ln = buf[ofs+0] + (buf[ofs+1] << 8);
             rt = 0;
             sz = 0;
 
@@ -188,10 +189,10 @@ xls_error_t xls_appendSST(xlsWorkBook* pWB, BYTE* buf, DWORD size)
 
             // Count of rich text formatting runs
             if (flag & 0x8) {
-                if (ofs + sizeof(WORD_UA) > size) {
+                if (ofs + sizeof(WORD) > size) {
                     return LIBXLS_ERROR_PARSE;
                 }
-                rt=xlsShortVal(*(WORD_UA *)(buf+ofs));
+                rt = buf[ofs+0] + (buf[ofs+1] << 8);
                 ofs+=2;
             }
 
@@ -200,7 +201,7 @@ xls_error_t xls_appendSST(xlsWorkBook* pWB, BYTE* buf, DWORD size)
                 if (ofs + sizeof(DWORD_UA) > size) {
                     return LIBXLS_ERROR_PARSE;
                 }
-                sz=xlsIntVal(*(DWORD_UA *)(buf+ofs));
+                sz = buf[ofs+0] + (buf[ofs+1] << 8) + (buf[ofs+2] << 16) + (buf[ofs+3] << 24);
                 ofs+=4;
 
 				if (xls_debug) {
@@ -232,7 +233,7 @@ xls_error_t xls_appendSST(xlsWorkBook* pWB, BYTE* buf, DWORD size)
                 ofs+=ln_toread*2;
 
                 if (xls_debug) {
-	                printf(""String16SST: %s(%zd)\n"",ret,new_len);
+	                printf(""String16SST: %s(%lu)\n"", ret, (unsigned long)new_len);
                 }
             } else {
                 ln_toread = min((size-ofs), ln);
@@ -346,7 +347,7 @@ char * xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET *bs, DWORD size)
 
 	// printf(""charset=%s uni=%d\n"", pWB->charset, unicode);
 	// printf(""bs name %.*s\n"", bs->name[0], bs->name+1);
-	name = get_string(bs->name, size - sizeof(BOUNDSHEET), 0, pWB->is5ver, pWB->charset);
+	name = get_string(bs->name, size - offsetof(BOUNDSHEET, name), 0, pWB->is5ver, pWB->charset);
 	// printf(""name=%s\n"", name);
 
 	if(xls_debug) {
@@ -454,24 +455,26 @@ int xls_isCellTooSmall(xlsWorkBook* pWB, BOF* bof, BYTE* buf) {
         return (bof->size < sizeof(FORMULA));
 
     if (bof->id == XLS_RECORD_MULRK)
-        return (bof->size < sizeof(MULRK));
+        return (bof->size < offsetof(MULRK, rk));
 
     if (bof->id == XLS_RECORD_MULBLANK)
-        return (bof->size < sizeof(MULBLANK));
+        return (bof->size < offsetof(MULBLANK, xf));
 
-    if (bof->id == XLS_RECORD_LABELSST) {
-        return (bof->size < sizeof(LABEL) + (pWB->is5ver ? 2 : 4));
-    }
+    if (bof->id == XLS_RECORD_LABELSST)
+        return (bof->size < offsetof(LABEL, value) + (pWB->is5ver ? 2 : 4));
 
     if (bof->id == XLS_RECORD_LABEL) {
-        size_t label_len = xlsShortVal(*(WORD *)((LABEL*)buf)->value);
+        if (bof->size < offsetof(LABEL, value) + 2)
+            return 1;
+
+        size_t label_len = ((LABEL*)buf)->value[0] + (((LABEL*)buf)->value[1] << 8);
         if (pWB->is5ver) {
-            return (bof->size < sizeof(LABEL) + 2 + label_len);
+            return (bof->size < offsetof(LABEL, value) + 2 + label_len);
         }
         if ((((LABEL*)buf)->value[2] & 0x01)) {
-            return (bof->size < sizeof(LABEL) + 3 + label_len);
+            return (bof->size < offsetof(LABEL, value) + 3 + label_len);
         }
-        return (bof->size < sizeof(LABEL) + 3 + 2 * label_len);
+        return (bof->size < offsetof(LABEL, value) + 3 + 2 * label_len);
     }
 
     if (bof->id == XLS_RECORD_RK)
@@ -620,7 +623,7 @@ char *xls_addFont(xlsWorkBook* pWB, FONT* font, DWORD size)
 
     tmp=&pWB->fonts.font[pWB->fonts.count];
 
-    tmp->name = get_string(font->name, size - sizeof(FONT), 0, pWB->is5ver, pWB->charset);
+    tmp->name = get_string(font->name, size - offsetof(FONT, name), 0, pWB->is5ver, pWB->charset);
 
     tmp->height=font->height;
     tmp->flag=font->flag;
@@ -648,7 +651,7 @@ xls_error_t xls_addFormat(xlsWorkBook* pWB, FORMAT* format, DWORD size)
 
     tmp = &pWB->formats.format[pWB->formats.count];
     tmp->index = format->index;
-    tmp->value = get_string(format->value, size - sizeof(FORMAT), (BYTE)!pWB->is5ver, (BYTE)pWB->is5ver, pWB->charset);
+    tmp->value = get_string(format->value, size - offsetof(FORMAT, value), (BYTE)!pWB->is5ver, (BYTE)pWB->is5ver, pWB->charset);
     if(xls_debug) xls_showFormat(tmp);
     pWB->formats.count++;
 
@@ -739,8 +742,8 @@ xls_error_t xls_mergedCells(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
     if (bof->size < sizeof(WORD_UA))
         return LIBXLS_ERROR_PARSE;
 
-    int count=xlsShortVal(*((WORD_UA *)buf));
-    DWORD limit = sizeof(WORD_UA)+count*sizeof(struct MERGEDCELLS);
+    int count = buf[0] + (buf[1] << 8);
+    DWORD limit = sizeof(WORD)+count*sizeof(struct MERGEDCELLS);
     if(limit > (DWORD)bof->size) {
         verbose(""Merged Cells Count out of range"");
         return LIBXLS_ERROR_PARSE;
@@ -772,6 +775,36 @@ xls_error_t xls_mergedCells(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
     return LIBXLS_OK;
 }
 
+int xls_isRecordTooSmall(xlsWorkBook *pWB, BOF *bof1) {
+    switch (bof1->id) {
+        case XLS_RECORD_BOF:	// BIFF5-8
+            return (bof1->size < 2 * sizeof(WORD));
+        case XLS_RECORD_CODEPAGE:
+            return (bof1->size < sizeof(WORD));
+		case XLS_RECORD_WINDOW1:
+            return (bof1->size < sizeof(WIND1));
+        case XLS_RECORD_SST:
+            return (bof1->size < offsetof(SST, strings));
+        case XLS_RECORD_BOUNDSHEET:
+            return (bof1->size < offsetof(BOUNDSHEET, name));
+        case XLS_RECORD_XF:
+			if(pWB->is5ver) {
+                return (bof1->size < sizeof(XF5));
+            }
+            return (bof1->size < sizeof(XF8));
+        case XLS_RECORD_FONT:
+        case XLS_RECORD_FONT_ALT:
+            return (bof1->size < offsetof(FONT, name));
+        case XLS_RECORD_FORMAT:
+            return (bof1->size < offsetof(FORMAT, value));
+		case XLS_RECORD_1904:
+            return (bof1->size < sizeof(BYTE));
+        default:
+            break;
+    }
+    return 0;
+}
+
 xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 {
     BOF bof1 = { 0 };
@@ -784,8 +817,9 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
     do {
 		if(xls_debug > 10) {
 			printf(""READ WORKBOOK filePos=%ld\n"",  (long)pWB->filepos);
-			printf(""  OLE: start=%d pos=%zd size=%zd fatPos=%zu\n"",
-                    pWB->olestr->start, pWB->olestr->pos, pWB->olestr->size, pWB->olestr->fatpos);
+			printf(""  OLE: start=%d pos=%u size=%u fatPos=%u\n"",
+                    pWB->olestr->start, (unsigned int)pWB->olestr->pos,
+                    (unsigned int)pWB->olestr->size, (unsigned int)pWB->olestr->fatpos); 
 		}
 
         if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {
@@ -808,17 +842,18 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
             }
         }
 
+        if (xls_isRecordTooSmall(pWB, &bof1)) {
+            retval = LIBXLS_ERROR_PARSE;
+            goto cleanup;
+        }
+
         switch (bof1.id) {
         case XLS_RECORD_EOF:
             //verbose(""EOF"");
             break;
         case XLS_RECORD_BOF:	// BIFF5-8
-            if (bof1.size < 2 * sizeof(WORD)) {
-                retval = LIBXLS_ERROR_PARSE;
-                goto cleanup;
-            }
-            pWB->is5ver = (xlsShortVal(*(WORD *)&buf[0]) != 0x600);
-            pWB->type = xlsShortVal(*(WORD *)&buf[2]);
+            pWB->is5ver = (buf[0] + (buf[1] << 8) != 0x600);
+            pWB->type = buf[2] + (buf[3] << 8);
 
             if(xls_debug) {
                 printf(""version: %s\n"", pWB->is5ver ? ""BIFF5"" : ""BIFF8"" );
@@ -827,11 +862,7 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
             break;
 
         case XLS_RECORD_CODEPAGE:
-            if (bof1.size < sizeof(WORD_UA)) {
-                retval = LIBXLS_ERROR_PARSE;
-                goto cleanup;
-            }
-            pWB->codepage=xlsShortVal(*(WORD_UA *)buf);
+            pWB->codepage = buf[0] + (buf[1] << 8);
 			if(xls_debug) printf(""codepage=%x\n"", pWB->codepage);
             break;
 
@@ -846,10 +877,6 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
             break;
 
 		case XLS_RECORD_WINDOW1:
-            if (bof1.size < sizeof(WIND1)) {
-                retval = LIBXLS_ERROR_PARSE;
-                goto cleanup;
-            }
 			{
 				WIND1 *w = (WIND1*)buf;
                 xlsConvertWindow(w);
@@ -870,10 +897,6 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 			break;
 
         case XLS_RECORD_SST:
-            if (bof1.size < sizeof(SST)) {
-                retval = LIBXLS_ERROR_PARSE;
-                goto cleanup;
-            }
 			//printf(""ADD SST\n"");
 			//if(xls_debug) dumpbuf((BYTE *)""/tmp/SST"",bof1.size,buf);
             xlsConvertSst((SST *)buf);
@@ -887,10 +910,6 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
             break;
 
         case XLS_RECORD_BOUNDSHEET:
-            if (bof1.size < sizeof(BOUNDSHEET)) {
-                retval = LIBXLS_ERROR_PARSE;
-                goto cleanup;
-            }
 			{
 				//printf(""ADD SHEET\n"");
 				BOUNDSHEET *bs = (BOUNDSHEET *)buf;
@@ -903,10 +922,6 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 
         case XLS_RECORD_XF:
 			if(pWB->is5ver) {
-                if (bof1.size < sizeof(XF5)) {
-                    retval = LIBXLS_ERROR_PARSE;
-                    goto cleanup;
-                }
 				XF5 *xf;
 				xf = (XF5 *)buf;
                 xlsConvertXf5(xf);
@@ -925,10 +940,6 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 					printf(""linesty: %.4x\n"", xf->linestyle);
 				}
 			} else {
-                if (bof1.size < sizeof(XF8)) {
-                    retval = LIBXLS_ERROR_PARSE;
-                    goto cleanup;
-                }
 				XF8 *xf;
 				xf = (XF8 *)buf;
                 xlsConvertXf8(xf);
@@ -945,10 +956,6 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 
         case XLS_RECORD_FONT:
         case XLS_RECORD_FONT_ALT:
-            if (bof1.size < sizeof(FONT)) {
-                retval = LIBXLS_ERROR_PARSE;
-                goto cleanup;
-            }
 			{
 				char *s;
 				FONT *f = (FONT*)buf;
@@ -969,10 +976,6 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 			break;
 
         case XLS_RECORD_FORMAT:
-            if (bof1.size < sizeof(FORMAT)) {
-                retval = LIBXLS_ERROR_PARSE;
-                goto cleanup;
-            }
             xlsConvertFormat((FORMAT *)buf);
             if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {
                 goto cleanup;
@@ -1009,10 +1012,6 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 			break;
 
 		case XLS_RECORD_1904:
-            if (bof1.size < sizeof(BYTE)) {
-                retval = LIBXLS_ERROR_PARSE;
-                goto cleanup;
-            }
 			pWB->is1904 = *(BYTE *)buf;	// the field is a short, but with little endian the first byte is 0 or 1
 			if(xls_debug) {
 				printf(""   mode: 0x%x\n"", pWB->is1904);
@@ -1090,7 +1089,7 @@ xls_error_t xls_preparseWorkSheet(xlsWorkSheet* pWS)
                 retval = LIBXLS_ERROR_PARSE;
                 goto cleanup;
             }
-            pWS->defcolwidth=xlsShortVal(*(WORD_UA *)buf)*256;
+            pWS->defcolwidth = (buf[0] << 8) + (buf[1] << 16);
             break;
         case XLS_RECORD_COLINFO:
             if (tmp.size < sizeof(COLINFO)) {
@@ -1115,7 +1114,7 @@ xls_error_t xls_preparseWorkSheet(xlsWorkSheet* pWS)
         /* If the ROW record is incorrect or missing, infer the information from
          * cell data. */
         case XLS_RECORD_MULRK:
-            if (tmp.size < sizeof(MULRK)) {
+            if (xls_isCellTooSmall(pWS->workbook, &tmp, buf)) {
                 retval = LIBXLS_ERROR_PARSE;
                 goto cleanup;
             }
@@ -1125,7 +1124,7 @@ xls_error_t xls_preparseWorkSheet(xlsWorkSheet* pWS)
                 pWS->rows.lastrow=xlsShortVal(((MULRK*)buf)->row);
             break;
         case XLS_RECORD_MULBLANK:
-            if (tmp.size < sizeof(MULBLANK)) {
+            if (xls_isCellTooSmall(pWS->workbook, &tmp, buf)) {
                 retval = LIBXLS_ERROR_PARSE;
                 goto cleanup;
             }
@@ -1142,7 +1141,7 @@ xls_error_t xls_preparseWorkSheet(xlsWorkSheet* pWS)
         case XLS_RECORD_FORMULA:
         case XLS_RECORD_FORMULA_ALT:
         case XLS_RECORD_BOOLERR:
-            if (tmp.size < sizeof(COL)) {
+            if (xls_isCellTooSmall(pWS->workbook, &tmp, buf)) {
                 retval = LIBXLS_ERROR_PARSE;
                 goto cleanup;
             }
@@ -1229,7 +1228,7 @@ xls_error_t xls_parseWorkSheet(xlsWorkSheet* pWS)
 		long lastPos = offset;
 
 		if(xls_debug > 10) {
-			printf(""LASTPOS=%ld pos=%zd filePos=%d filePos=%d\n"", lastPos, pWB->olestr->pos, pWS->filepos, pWB->filepos);
+			printf(""LASTPOS=%ld pos=%d filePos=%d filePos=%d\n"", lastPos, (int)pWB->olestr->pos, pWS->filepos, pWB->filepos);
 		}
 		if((read = ole2_read(&tmp, 1, 4, pWS->workbook->olestr)) != 4) {
             if (xls_debug) fprintf2(stderr, ""Error: failed to read OLE size\n"");

---FILE: src/xlstool.c---
@@ -295,7 +295,7 @@ char* unicode_decode(const char *s, size_t len, size_t *newlen, const char* to_e
 	count2 = wcstombs(converted, w, count);
     free(w);
 	if (count2 <= 0) {
-		printf(""wcstombs failed (%d)\n"", len/2);
+		printf(""wcstombs failed (%lu)\n"", (unsigned long)len/2);
 		if (newlen) *newlen = 0;
 		return converted;
 	} else {",False,False,Dependency / Package,3
tidyverse,readxl,33d9167f4032ca9197a46e69d131c5b6e1b0c352,Jim Hester,james.f.hester@gmail.com,2018-04-19T17:21:32Z,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2018-04-19T17:21:32Z,"Use a pragma to silence the C99 extensions warnings (#459)

* Use a pragma to silence the C99 extensions warnings

This also reverts changing the flexible array members to single element
arrays.

* Avoid NOTEs on R-devel

* Fix pragmas for GCC

* Only use const char** for iconv on Solaris

* Extend Solaris iconv solution to Windows",src/ColSpec.h;src/XlsWorkBook.cpp;src/XlsWorkSheet.cpp;src/XlsxWorkSheet.cpp;src/libxls/xlsstruct.h;src/xls.c;src/xlstool.c,False,False,False,False,42,21,63,"---FILE: src/ColSpec.h---
@@ -1,6 +1,9 @@
 #ifndef READXL_COLSPEC_
 #define READXL_COLSPEC_
 
+# pragma GCC diagnostic ignored ""-Wpedantic""
+# pragma clang diagnostic ignored ""-Wc99-extensions""
+
 #include <Rcpp.h>
 #include <libxls/xls.h>
 #include ""StringSet.h""

---FILE: src/XlsWorkBook.cpp---
@@ -1,4 +1,8 @@
 #include <Rcpp.h>
+
+# pragma GCC diagnostic ignored ""-Wpedantic""
+# pragma clang diagnostic ignored ""-Wc99-extensions""
+
 #include ""XlsWorkBook.h""
 using namespace Rcpp;
 

---FILE: src/XlsWorkSheet.cpp---
@@ -1,7 +1,7 @@
 #include <Rcpp.h>
 
-#include ""XlsWorkSheet.h""
 #include ""ColSpec.h""
+#include ""XlsWorkSheet.h""
 #include <libxls/xls.h>
 using namespace Rcpp;
 

---FILE: src/XlsxWorkSheet.cpp---
@@ -1,6 +1,6 @@
 #include <Rcpp.h>
-#include ""XlsxWorkSheet.h""
 #include ""ColSpec.h""
+#include ""XlsxWorkSheet.h""
 #include ""utils.h""
 using namespace Rcpp;
 

---FILE: src/libxls/xlsstruct.h---
@@ -33,6 +33,10 @@
 #ifndef XLS_STRUCT_INC
 #define XLS_STRUCT_INC
 
+#ifdef __cplusplus
+extern ""C"" {
+#endif
+
 #include ""libxls/ole.h""
 
 #define XLS_RECORD_EOF          0x000A
@@ -194,7 +198,7 @@ typedef struct MULRK
 	struct {
 		WORD	xf;
 		DWORD_UA value;
-	}		rk[1]; // readxl
+	}		rk[];
 	//WORD	last_col;
 }
 MULRK;
@@ -203,7 +207,7 @@ typedef struct MULBLANK
 {
     WORD	row;
     WORD	col;
-    WORD	xf[1]; // readxl
+    WORD	xf[];
 	//WORD	last_col;
 }
 MULBLANK;
@@ -240,7 +244,7 @@ typedef struct SST
 {
     DWORD	num;
     DWORD	numofstr;
-    BYTE	strings[0];
+    BYTE	strings[];
 }
 SST;
 
@@ -312,7 +316,7 @@ typedef struct FONT
     BYTE	family;
     BYTE	charset;
     BYTE	notused;
-    char    name[1]; // readxl
+    char    name[];
 }
 FONT;
 
@@ -530,4 +534,8 @@ xlsSummaryInfo;
 
 typedef void (*xls_formula_handler)(WORD bof, WORD len, BYTE *formula);
 
+#ifdef __cplusplus
+} // extern c block
+#endif
+
 #endif

---FILE: src/xls.c---
@@ -90,7 +90,7 @@ typedef struct {
 	uint32_t		os;
 	uint32_t		format[4];
 	uint32_t		count;
-	sectionList		secList[1]; // readxl
+	sectionList		secList[];
 } header;
 
 typedef struct {
@@ -101,12 +101,12 @@ typedef struct {
 typedef struct {
 	uint32_t		length;
 	uint32_t		numProperties;
-	propertyList	properties[1];  // readxl
+	propertyList	properties[];
 } sectionHeader;
 
 typedef struct {
 	uint32_t		propertyID;
-	uint32_t		data[1];  // readxl
+	uint32_t		data[];
 } property;
 
 #pragma pack(pop)
@@ -785,7 +785,7 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 		if(xls_debug > 10) {
 			printf(""READ WORKBOOK filePos=%ld\n"",  (long)pWB->filepos);
 			printf(""  OLE: start=%d pos=%zd size=%zd fatPos=%zu\n"",
-                    pWB->olestr->start, pWB->olestr->pos, pWB->olestr->size, pWB->olestr->fatpos); 
+                    pWB->olestr->start, pWB->olestr->pos, pWB->olestr->size, pWB->olestr->fatpos);
 		}
 
         if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {
@@ -1018,7 +1018,7 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 				printf(""   mode: 0x%x\n"", pWB->is1904);
 			}
 			break;
-		
+
 		case XLS_RECORD_DEFINEDNAME:
 			if(xls_debug) {
 				int i;
@@ -1027,7 +1027,7 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 				printf(""\n"");
 			}
 			break;
-			
+
         default:
 			if(xls_debug)
 			{

---FILE: src/xlstool.c---
@@ -138,13 +138,13 @@ char *utf8_decode(const char *str, DWORD len, char *encoding)
 	int utf8_chars = 0;
 	char *ret = NULL;
     DWORD i;
-	
+
 	for(i=0; i<len; ++i) {
 		if(str[i] & (BYTE)0x80) {
 			++utf8_chars;
 		}
 	}
-	
+
 	if(utf8_chars == 0 || strcmp(encoding, ""UTF-8"")) {
 		ret = malloc(len+1);
 		memcpy(ret, str, len);
@@ -174,11 +174,17 @@ char *utf8_decode(const char *str, DWORD len, char *encoding)
 char* unicode_decode(const char *s, size_t len, size_t *newlen, const char* to_enc)
 {
 #ifdef HAVE_ICONV
-	// Do iconv conversion
+    // Do iconv conversion
 #if defined(_AIX) || defined(__sun)
     const char *from_enc = ""UTF-16le"";
+    #define ICONV_CONST const
 #else
     const char *from_enc = ""UTF-16LE"";
+    #if defined(_WIN32)
+        #define ICONV_CONST const
+    #else
+        #define ICONV_CONST
+    #endif
 #endif
     char* outbuf = 0;
 
@@ -212,15 +218,15 @@ char* unicode_decode(const char *s, size_t len, size_t *newlen, const char* to_e
                 return outbuf;
             }
         }
-        size_t st; 
+        size_t st;
         outbuf = malloc(outlen + 1);
 
 		if(outbuf)
         {
             out_ptr = outbuf;
             while(inlenleft)
             {
-                st = iconv(ic, (char **)&src_ptr, &inlenleft, (char **)&out_ptr,(size_t *) &outlenleft);
+                st = iconv(ic, (ICONV_CONST char **)&src_ptr, &inlenleft, (char **)&out_ptr,(size_t *) &outlenleft);
                 if(st == (size_t)(-1))
                 {
                     if(errno == E2BIG)
@@ -307,7 +313,7 @@ char *get_string(const char *s, size_t len, BYTE is2, BYTE is5ver, char *charset
     BYTE flag = 0;
     const char *str = s;
     char *ret = NULL;
-	
+
     if (is2) {
 		// length is two bytes
         if (ofs + 2 > len) {
@@ -361,9 +367,9 @@ char *get_string(const char *s, size_t len, BYTE is2, BYTE is5ver, char *charset
 		printf(""ofs=%d ret[0]=%d\n"", ofs, *ret);
 		{
 			unsigned char *ptr;
-			
+
 			ptr = ret;
-			
+
 			printf(""%x %x %x %x %x %x %x %x\n"", ptr[0], ptr[1], ptr[2], ptr[3], ptr[4], ptr[5], ptr[6], ptr[7] );
 			printf(""%s\n"", ret);
 		}
@@ -544,7 +550,7 @@ void xls_showFormat(struct st_format_data* frmt)
 void xls_showXF(XF8* xf)
 {
 	static int idx;
-	
+
     printf(""      Index: %u\n"",idx++);
     printf(""       Font: %u\n"",xf->font);
     printf(""     Format: %u\n"",xf->format);",False,False,Dependency / Package,3
tidyverse,readxl,b850cd872b4fd2d964035129cca31049ac39c0ca,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-17T00:06:35Z,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2018-04-17T05:38:24Z,"Refactor file format guessing

Fixes #449, fixes #411",NAMESPACE;R/excel-format.R;R/excel-sheets.R;R/read_excel.R;_pkgdown.yml;docs/articles/articles/readxl-workflows.html;docs/news/index.html;docs/reference/excel_format.html;docs/reference/excel_sheets.html;docs/reference/index.html;docs/reference/read_excel.html;docs/reference/readxl-package.html;man/excel_format.Rd;man/excel_sheets.Rd;man/read_excel.Rd;tests/testthat/test-formats.R,False,True,True,False,174,92,266,"---FILE: NAMESPACE---
@@ -6,6 +6,8 @@ export(cell_limits)
 export(cell_rows)
 export(excel_format)
 export(excel_sheets)
+export(format_from_ext)
+export(format_from_signature)
 export(read_excel)
 export(read_xls)
 export(read_xlsx)

---FILE: R/excel-format.R---
@@ -1,14 +1,26 @@
 #' Determine file format
 #'
-#' Determine if files are xlsx or xls. First the file extension is consulted. If
-#' that is unsuccessful and `guess = TRUE` and the file exists, the format is
-#' guessed from the [file
-#' signature](https://en.wikipedia.org/wiki/List_of_file_signatures) or ""magic
-#' number"".
+#' @description Determine if files are xls or xlsx (or from the xlsx family).
+#'
+#' @description `excel_format(guess = TRUE)` is used by `read_excel()` to
+#'   determine format. It draws on logic from two lower level functions:
+#'   * `format_from_ext()` attempts to determine format from the file extension.
+#'   * `format_from_signature()` consults the [file
+#'   signature](https://en.wikipedia.org/wiki/List_of_file_signatures) or ""magic
+#'   number"".
+#'
+#' @description File extensions associated with xlsx vs. xls:
+#'   * xlsx: `.xlsx`, `.xlsm`, `.xltx`, `.xltm`
+#'   * xls: `.xls`
+#'
+#' @description File signatures (in hexadecimal) for xlsx vs xls:
+#'   * xlsx: First 4 bytes are `50 4B 03 04`
+#'   * xls: First 8 bytes are `D0 CF 11 E0 A1 B1 1A E1`
 #'
 #' @inheritParams read_excel
-#' @param guess Logical. Whether to guess format based on the file itself, if
-#'   the extension is neither `""xlsx""` nor `""xls""`.
+#' @param guess Logical. If the file extension is absent or not recognized, this
+#'   controls whether we attempt to guess format based on the file signature or
+#'   ""magic number"".
 #'
 #' @return Character vector with values `""xlsx""`, `""xls""`, or `NA`.
 #' @export
@@ -24,22 +36,34 @@
 #' )
 #' excel_format(files)
 excel_format <- function(path, guess = TRUE) {
-  ext <- tolower(tools::file_ext(path))
-
-  formats <- c(xls = ""xls"", xlsx = ""xlsx"", xlsm = ""xlsx"")
-  format <- unname(formats[ext])
-
-  if (!guess || !anyNA(format)) {
+  format <- format_from_ext(path)
+  if (!isTRUE(guess)) {
     return(format)
   }
-
   guess_me <- is.na(format) & file.exists(path)
-  format[guess_me] <- guess_format(path[guess_me])
+  format[guess_me] <- format_from_signature(path[guess_me])
   format
 }
 
-guess_format <- function(x) {
-  signature <- lapply(x, first_8_bytes)
+#' @rdname excel_format
+#' @export
+format_from_ext <- function(path) {
+  ext <- tolower(tools::file_ext(path))
+
+  formats <- c(
+    xls = ""xls"",
+    xlsx = ""xlsx"",
+    xlsm = ""xlsx"",
+    xltx = ""xlsx"",
+    xltm = ""xlsx""
+  )
+  unname(formats[ext])
+}
+
+#' @rdname excel_format
+#' @export
+format_from_signature <- function(path) {
+  signature <- lapply(path, first_8_bytes)
   vapply(signature, sig_to_fmt, ""xlsx?"")
 }
 
@@ -62,3 +86,11 @@ sig_to_fmt <- function(x) {
     NA_character_
   }
 }
+
+check_format <- function(path) {
+  format <- excel_format(path)
+  if (is.na(format)) {
+    stop(""Can't establish that the input is either xls or xlsx."", call. = FALSE)
+  }
+  format
+}

---FILE: R/excel-sheets.R---
@@ -10,6 +10,7 @@
 #' path <- readxl_example(""datasets.xls"")
 #' lapply(excel_sheets(path), read_excel, path = path)
 excel_sheets <- function(path) {
+  path <- check_file(path)
   format <- check_format(path)
 
   switch(format,

---FILE: R/read_excel.R---
@@ -4,7 +4,7 @@ NULL
 
 #' Read xls and xlsx files
 #'
-#' @param path Path to the xls/xlsx file
+#' @param path Path to the xls/xlsx file.
 #' @param sheet Sheet to read. Either a string (the name of a sheet), or an
 #'   integer (the position of the sheet). Ignored if the sheet is specified via
 #'   `range`. If neither argument specifies the sheet, defaults to the first
@@ -85,6 +85,7 @@ read_excel <- function(path, sheet = NULL, range = NULL,
                        col_names = TRUE, col_types = NULL,
                        na = """", trim_ws = TRUE, skip = 0, n_max = Inf,
                        guess_max = min(1000, n_max)) {
+  path <- check_file(path)
   format <- check_format(path)
   read_excel_(
     path = path, sheet = sheet, range = range,
@@ -95,15 +96,17 @@ read_excel <- function(path, sheet = NULL, range = NULL,
   )
 }
 
-#' `read_excel()` tries to determine format from the file extension and the file
-#' itself, in that order. Use `read_xls()` and `read_xlsx()` directly to
-#' eliminate the guessing.
+#' `read_excel()` calls [excel_format()] to determine if `path` is xls or xlsx,
+#' based on the file extension and the file itself, in that order. Use
+#' `read_xls()` and `read_xlsx()` directly if you know better and want to
+#' prevent such guessing.
 #' @rdname read_excel
 #' @export
 read_xls <- function(path, sheet = NULL, range = NULL,
                      col_names = TRUE, col_types = NULL,
                      na = """", trim_ws = TRUE, skip = 0, n_max = Inf,
                      guess_max = min(1000, n_max)) {
+  path <- check_file(path)
   read_excel_(
     path = path, sheet = sheet, range = range,
     col_names = col_names, col_types = col_types,
@@ -118,6 +121,7 @@ read_xlsx <- function(path, sheet = NULL, range = NULL,
                       col_names = TRUE, col_types = NULL,
                       na = """", trim_ws = TRUE, skip = 0, n_max = Inf,
                       guess_max = min(1000, n_max)) {
+  path <- check_file(path)
   read_excel_(
     path = path, sheet = sheet, range = range,
     col_names = col_names, col_types = col_types,
@@ -130,7 +134,6 @@ read_excel_ <- function(path, sheet = NULL, range = NULL,
                         col_names = TRUE, col_types = NULL,
                         na = """", trim_ws = TRUE, skip = 0, n_max = Inf,
                         guess_max = min(1000, n_max), format) {
-  path <- check_file(path)
   if (format == ""xls"") {
     sheets_fun <- xls_sheets
     read_fun <- read_xls_
@@ -162,28 +165,6 @@ read_excel_ <- function(path, sheet = NULL, range = NULL,
 
 # Helper functions -------------------------------------------------------------
 
-check_format <- function(path) {
-  path <- check_file(path)
-  format <- excel_format(path)
-  if (is.na(format)) {
-    ext <- tolower(tools::file_ext(path))
-    if (nzchar(ext)) {
-      stop(
-        ""Extension is neither 'xlsx' nor 'xls': "",
-        sQuote(ext),
-        call. = FALSE
-      )
-    } else {
-      stop(
-        ""File has no extension and doesn't seem to be xlsx or xls: "",
-        sQuote(path),
-        call. = FALSE
-      )
-    }
-  }
-  format
-}
-
 ## return a zero-indexed sheet number
 standardise_sheet <- function(sheet, range, sheet_names) {
   range_sheet <- cellranger::as.cell_limits(range)[[""sheet""]]

---FILE: _pkgdown.yml---
@@ -46,6 +46,7 @@ reference:
       Functions to learn properties of xls and xlsx files.
     contents:
       - excel_sheets
+      - excel_format
   - title: ""Describe a target rectangle""
     desc: >
       Flexible specification of cell rectangles.

---FILE: docs/articles/articles/readxl-workflows.html---
@@ -117,12 +117,12 @@ <h2 class=""hasAnchor"">
 <p>We load the tidyverse metapackage here because the workflows below show readxl working with readr, purrr, etc. See the last section for solutions using base R only (other than readxl).</p>
 <p>We must load readxl explicitly because it is not part of the core tidyverse.</p>
 <div class=""sourceCode"" id=""cb1""><pre class=""sourceCode r""><code class=""sourceCode r""><a class=""sourceLine"" id=""cb1-1"" data-line-number=""1""><span class=""kw"">library</span>(tidyverse)</a>
-<a class=""sourceLine"" id=""cb1-2"" data-line-number=""2""><span class=""co"">#&gt; ── Attaching packages ─────────────────────────────────────── tidyverse 1.2.1 ──</span></a>
+<a class=""sourceLine"" id=""cb1-2"" data-line-number=""2""><span class=""co"">#&gt; ── Attaching packages ───────────────────────────────────────── tidyverse 1.2.1 ──</span></a>
 <a class=""sourceLine"" id=""cb1-3"" data-line-number=""3""><span class=""co"">#&gt; ✔ ggplot2 2.2.1          ✔ purrr   0.2.4.9000</span></a>
 <a class=""sourceLine"" id=""cb1-4"" data-line-number=""4""><span class=""co"">#&gt; ✔ tibble  1.4.2          ✔ dplyr   0.7.4.9000</span></a>
 <a class=""sourceLine"" id=""cb1-5"" data-line-number=""5""><span class=""co"">#&gt; ✔ tidyr   0.8.0          ✔ stringr 1.3.0     </span></a>
-<a class=""sourceLine"" id=""cb1-6"" data-line-number=""6""><span class=""co"">#&gt; ✔ readr   1.1.1.9000     ✔ forcats 0.3.0</span></a>
-<a class=""sourceLine"" id=""cb1-7"" data-line-number=""7""><span class=""co"">#&gt; ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──</span></a>
+<a class=""sourceLine"" id=""cb1-6"" data-line-number=""6""><span class=""co"">#&gt; ✔ readr   1.2.0          ✔ forcats 0.3.0</span></a>
+<a class=""sourceLine"" id=""cb1-7"" data-line-number=""7""><span class=""co"">#&gt; ── Conflicts ──────────────────────────────────────────── tidyverse_conflicts() ──</span></a>
 <a class=""sourceLine"" id=""cb1-8"" data-line-number=""8""><span class=""co"">#&gt; ✖ dplyr::filter() masks stats::filter()</span></a>
 <a class=""sourceLine"" id=""cb1-9"" data-line-number=""9""><span class=""co"">#&gt; ✖ dplyr::lag()    masks stats::lag()</span></a>
 <a class=""sourceLine"" id=""cb1-10"" data-line-number=""10""><span class=""kw"">library</span>(readxl)</a></code></pre></div>
@@ -389,7 +389,7 @@ <h2 class=""hasAnchor"">
 #>  language (EN)                        
 #>  collate  en_CA.UTF-8                 
 #>  tz       America/Vancouver           
-#>  date     2018-04-15                  
+#>  date     2018-04-16                  
 #> 
 #> ─ Packages ──────────────────────────────────────────────────────────────
 #>  package     * version     date       source                             
@@ -419,7 +419,7 @@ <h2 class=""hasAnchor"">
 #>  glue          1.2.0.9000  2018-04-07 Github (tidyverse/glue@0699687)    
 #>  gtable        0.2.0       2016-02-26 CRAN (R 3.4.0)                     
 #>  haven         1.1.1       2018-01-18 CRAN (R 3.4.3)                     
-#>  hms           0.4.2       2018-03-10 CRAN (R 3.4.3)                     
+#>  hms           0.4.2       2018-04-16 Github (tidyverse/hms@c0cfc01)     
 #>  htmltools     0.3.6       2017-04-28 CRAN (R 3.4.0)                     
 #>  httr          1.3.1       2017-08-20 CRAN (R 3.4.1)                     
 #>  jsonlite      1.5         2017-06-01 CRAN (R 3.4.0)                     
@@ -446,7 +446,7 @@ <h2 class=""hasAnchor"">
 #>  purrr       * 0.2.4.9000  2018-03-29 Github (tidyverse/purrr@84ce1ad)   
 #>  R6            2.2.2       2017-06-17 CRAN (R 3.4.0)                     
 #>  Rcpp          0.12.16     2018-03-13 CRAN (R 3.4.4)                     
-#>  readr       * 1.1.1.9000  2017-12-12 Github (tidyverse/readr@ba7edb5)   
+#>  readr       * 1.2.0       2018-04-16 Github (tidyverse/readr@23eb46d)   
 #>  readxl      * 1.0.0.9000  2018-04-15 local                              
 #>  rematch       1.0.1       2016-04-21 CRAN (R 3.4.0)                     
 #>  reshape2      1.4.3       2017-12-11 CRAN (R 3.4.3)                     

---FILE: docs/news/index.html---
@@ -131,7 +131,7 @@ <h1 class=""page-header"">
 </li>
 <li><p>xlsx structured as a “minimal conformant SpreadsheetML package” can be read. Most obvious feature of such sheets is the lack of an <code>xl/</code> directory in the unzipped form. (xlsx, <a href='https://github.com/tidyverse/readxl/issues/435'>#435</a>, <a href='https://github.com/tidyverse/readxl/issues/437'>#437</a>)</p></li>
 <li><p>Reading xls sheet with exactly 65,536 rows no longer enters an infinite loop. (xls, <a href='https://github.com/tidyverse/readxl/issues/373'>#373</a>, <a href='https://github.com/tidyverse/readxl/issues/416'>#416</a>, <a href='https://github.com/tidyverse/readxl/issues/432'>#432</a> <a href='http://github.com/vkapartzianis'>@vkapartzianis</a>)</p></li>
-<li><p>Datetimes coerced to character from xls have much higher precision, comparable to the xlsx behaviour. (xls, <a href='https://github.com/tidyverse/readxl/issues/430'>#430</a>, <a href='https://github.com/tidyverse/readxl/issues/431'>#431</a>)</p></li>
+<li><p>Doubles, including datetimes, coerced to character from xls now have much higher precision, comparable to the xlsx behaviour. (xls, <a href='https://github.com/tidyverse/readxl/issues/430'>#430</a>, <a href='https://github.com/tidyverse/readxl/issues/431'>#431</a>)</p></li>
 <li><p>Integer-y numbers larger than 2^31 are coerced properly to string (xls, <a href='https://github.com/tidyverse/readxl/issues/346'>#346</a>)</p></li>
 <li><p>Shared strings are only compared to NA strings after lookup, never on the basis of their index. (xlsx, <a href='https://github.com/tidyverse/readxl/issues/401'>#401</a>)</p></li>
 <li><p>Better checks and messaging around nonexistent files. (<a href='https://github.com/tidyverse/readxl/issues/392'>#392</a>)</p></li>

---FILE: docs/reference/excel_format.html---
@@ -117,24 +117,40 @@ <h1>Determine file format</h1>
     <div class=""hidden name""><code>excel_format.Rd</code></div>
     </div>
 
-    <p>Determine if files are xlsx or xls. First the file extension is consulted. If
-that is unsuccessful and <code>guess = TRUE</code> and the file exists, the format is
-guessed from the <a href='https://en.wikipedia.org/wiki/List_of_file_signatures'>file signature</a> or ""magic
-number"".</p>
-
-    <pre class=""usage""><span class='fu'>excel_format</span>(<span class='no'>path</span>, <span class='kw'>guess</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)</pre>
+    <p>Determine if files are xls or xlsx (or from the xlsx family).</p>
+<p><code>excel_format(guess = TRUE)</code> is used by <code><a href='read_excel.html'>read_excel()</a></code> to
+determine format. It draws on logic from two lower level functions:</p><ul>
+<li><p><code>format_from_ext()</code> attempts to determine format from the file extension.</p></li>
+<li><p><code>format_from_signature()</code> consults the <a href='https://en.wikipedia.org/wiki/List_of_file_signatures'>file signature</a> or ""magic
+number"".</p></li>
+</ul>
+    <p>File extensions associated with xlsx vs. xls:</p><ul>
+<li><p>xlsx: <code>.xlsx</code>, <code>.xlsm</code>, <code>.xltx</code>, <code>.xltm</code></p></li>
+<li><p>xls: <code>.xls</code></p></li>
+</ul>
+    <p>File signatures (in hexadecimal) for xlsx vs xls:</p><ul>
+<li><p>xlsx: First 4 bytes are <code>50 4B 03 04</code></p></li>
+<li><p>xls: First 8 bytes are <code>D0 CF 11 E0 A1 B1 1A E1</code></p></li>
+</ul>
+
+    <pre class=""usage""><span class='fu'>excel_format</span>(<span class='no'>path</span>, <span class='kw'>guess</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)
+
+<span class='fu'>format_from_ext</span>(<span class='no'>path</span>)
+
+<span class='fu'>format_from_signature</span>(<span class='no'>path</span>)</pre>
 
     <h2 class=""hasAnchor"" id=""arguments""><a class=""anchor"" href=""#arguments""></a>Arguments</h2>
     <table class=""ref-arguments"">
     <colgroup><col class=""name"" /><col class=""desc"" /></colgroup>
     <tr>
       <th>path</th>
-      <td><p>Path to the xls/xlsx file</p></td>
+      <td><p>Path to the xls/xlsx file.</p></td>
     </tr>
     <tr>
       <th>guess</th>
-      <td><p>Logical. Whether to guess format based on the file itself, if
-the extension is neither <code>""xlsx""</code> nor <code>""xls""</code>.</p></td>
+      <td><p>Logical. If the file extension is absent or not recognized, this
+controls whether we attempt to guess format based on the file signature or
+""magic number"".</p></td>
     </tr>
     </table>
 

---FILE: docs/reference/excel_sheets.html---
@@ -126,7 +126,7 @@ <h2 class=""hasAnchor"" id=""arguments""><a class=""anchor"" href=""#arguments""></a>Arg
     <colgroup><col class=""name"" /><col class=""desc"" /></colgroup>
     <tr>
       <th>path</th>
-      <td><p>Path to the xls/xlsx file</p></td>
+      <td><p>Path to the xls/xlsx file.</p></td>
     </tr>
     </table>
 

---FILE: docs/reference/index.html---
@@ -149,6 +149,12 @@ <h2 id=""section-get-spreadsheet-metadata"" class=""hasAnchor""><a href=""#section-ge
           <p><code><a href=""excel_sheets.html"">excel_sheets()</a></code> </p>
         </td>
         <td><p>List all sheets in an excel spreadsheet</p></td>
+      </tr><tr>
+        <!--  -->
+        <td>
+          <p><code><a href=""excel_format.html"">excel_format()</a></code> <code><a href=""excel_format.html"">format_from_ext()</a></code> <code><a href=""excel_format.html"">format_from_signature()</a></code> </p>
+        </td>
+        <td><p>Determine file format</p></td>
       </tr>
     </tbody><tbody>
       <tr>

---FILE: docs/reference/read_excel.html---
@@ -118,9 +118,10 @@ <h1>Read xls and xlsx files</h1>
     </div>
 
     <p>Read xls and xlsx files</p>
-<p><code>read_excel()</code> tries to determine format from the file extension and the file
-itself, in that order. Use <code>read_xls()</code> and <code>read_xlsx()</code> directly to
-eliminate the guessing.</p>
+<p><code>read_excel()</code> calls <code><a href='excel_format.html'>excel_format()</a></code> to determine if <code>path</code> is xls or xlsx,
+based on the file extension and the file itself, in that order. Use
+<code>read_xls()</code> and <code>read_xlsx()</code> directly if you know better and want to
+prevent such guessing.</p>
 
     <pre class=""usage""><span class='fu'>read_excel</span>(<span class='no'>path</span>, <span class='kw'>sheet</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>col_names</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>,
   <span class='kw'>col_types</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>na</span> <span class='kw'>=</span> <span class='st'>""""</span>, <span class='kw'>trim_ws</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>, <span class='kw'>skip</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>n_max</span> <span class='kw'>=</span> <span class='fl'>Inf</span>,
@@ -139,7 +140,7 @@ <h2 class=""hasAnchor"" id=""arguments""><a class=""anchor"" href=""#arguments""></a>Arg
     <colgroup><col class=""name"" /><col class=""desc"" /></colgroup>
     <tr>
       <th>path</th>
-      <td><p>Path to the xls/xlsx file</p></td>
+      <td><p>Path to the xls/xlsx file.</p></td>
     </tr>
     <tr>
       <th>sheet</th>
@@ -177,8 +178,8 @@ <h2 class=""hasAnchor"" id=""arguments""><a class=""anchor"" href=""#arguments""></a>Arg
     </tr>
     <tr>
       <th>na</th>
-      <td><p>Character vector of strings to interpret as missing values. By default,
-readxl treats blank cells as missing data.</p></td>
+      <td><p>Character vector of strings to interpret as missing values. By
+default, readxl treats blank cells as missing data.</p></td>
     </tr>
     <tr>
       <th>trim_ws</th>

---FILE: docs/reference/readxl-package.html---
@@ -119,8 +119,8 @@ <h1>readxl: Read Excel Files</h1>
 
     <p>Import excel files into R. Supports '.xls' via the embedded
 'libxls' C library &lt;https://github.com/evanmiller/libxls&gt; and '.xlsx' via
-the embedded 'RapidXML' C++ library &lt;https://rapidxml.sourceforge.net&gt;. Works on
-Windows, Mac and Linux without external dependencies.</p>
+the embedded 'RapidXML' C++ library &lt;https://rapidxml.sourceforge.net&gt;.
+Works on Windows, Mac and Linux without external dependencies.</p>
 
 
 

---FILE: man/excel_format.Rd---
@@ -2,25 +2,49 @@
 % Please edit documentation in R/excel-format.R
 \name{excel_format}
 \alias{excel_format}
+\alias{format_from_ext}
+\alias{format_from_signature}
 \title{Determine file format}
 \usage{
 excel_format(path, guess = TRUE)
+
+format_from_ext(path)
+
+format_from_signature(path)
 }
 \arguments{
-\item{path}{Path to the xls/xlsx file}
+\item{path}{Path to the xls/xlsx file.}
 
-\item{guess}{Logical. Whether to guess format based on the file itself, if
-the extension is neither \code{""xlsx""} nor \code{""xls""}.}
+\item{guess}{Logical. If the file extension is absent or not recognized, this
+controls whether we attempt to guess format based on the file signature or
+""magic number"".}
 }
 \value{
 Character vector with values \code{""xlsx""}, \code{""xls""}, or \code{NA}.
 }
 \description{
-Determine if files are xlsx or xls. First the file extension is consulted. If
-that is unsuccessful and \code{guess = TRUE} and the file exists, the format is
-guessed from the \href{https://en.wikipedia.org/wiki/List_of_file_signatures}{file signature} or ""magic
+Determine if files are xls or xlsx (or from the xlsx family).
+
+\code{excel_format(guess = TRUE)} is used by \code{read_excel()} to
+determine format. It draws on logic from two lower level functions:
+\itemize{
+\item \code{format_from_ext()} attempts to determine format from the file extension.
+\item \code{format_from_signature()} consults the \href{https://en.wikipedia.org/wiki/List_of_file_signatures}{file signature} or ""magic
 number"".
 }
+
+File extensions associated with xlsx vs. xls:
+\itemize{
+\item xlsx: \code{.xlsx}, \code{.xlsm}, \code{.xltx}, \code{.xltm}
+\item xls: \code{.xls}
+}
+
+File signatures (in hexadecimal) for xlsx vs xls:
+\itemize{
+\item xlsx: First 4 bytes are \code{50 4B 03 04}
+\item xls: First 8 bytes are \code{D0 CF 11 E0 A1 B1 1A E1}
+}
+}
 \examples{
 files <- c(
   ""a.xlsx"",

---FILE: man/excel_sheets.Rd---
@@ -7,7 +7,7 @@
 excel_sheets(path)
 }
 \arguments{
-\item{path}{Path to the xls/xlsx file}
+\item{path}{Path to the xls/xlsx file.}
 }
 \description{
 List all sheets in an excel spreadsheet

---FILE: man/read_excel.Rd---
@@ -19,7 +19,7 @@ read_xlsx(path, sheet = NULL, range = NULL, col_names = TRUE,
   guess_max = min(1000, n_max))
 }
 \arguments{
-\item{path}{Path to the xls/xlsx file}
+\item{path}{Path to the xls/xlsx file.}
 
 \item{sheet}{Sheet to read. Either a string (the name of a sheet), or an
 integer (the position of the sheet). Ignored if the sheet is specified via
@@ -69,9 +69,10 @@ A \link[tibble:tibble-package]{tibble}
 \description{
 Read xls and xlsx files
 
-\code{read_excel()} tries to determine format from the file extension and the file
-itself, in that order. Use \code{read_xls()} and \code{read_xlsx()} directly to
-eliminate the guessing.
+\code{read_excel()} calls \code{\link[=excel_format]{excel_format()}} to determine if \code{path} is xls or xlsx,
+based on the file extension and the file itself, in that order. Use
+\code{read_xls()} and \code{read_xlsx()} directly if you know better and want to
+prevent such guessing.
 }
 \examples{
 datasets <- readxl_example(""datasets.xlsx"")

---FILE: tests/testthat/test-formats.R---
@@ -1,14 +1,14 @@
 context(""test-formats.R"")
 
-test_that(""excel_format() recognizes extensions 'xls' and 'xlsx'"", {
+test_that(""excel_format() recognizes extensions (or lack thereof)"", {
   files <- c(""a.xlsx"", ""b.xls"", ""c.png"", ""d"")
   expect_identical(
-    excel_format(files, guess = FALSE),
+    format_from_ext(files),
     c(""xlsx"", ""xls"", NA, NA)
   )
 })
 
-test_that(""excel_format() detect file signature"", {
+test_that(""format_from_signature() works for xls and xlsx and not jpg"", {
   orig_files <- c(
     test_sheet(""iris-excel-xlsx.xlsx""),
     test_sheet(""iris-excel-xls.xls""),
@@ -20,15 +20,32 @@ test_that(""excel_format() detect file signature"", {
   )
   file.copy(orig_files, no_ext_copies)
   on.exit(file.remove(no_ext_copies))
-  expect_identical(excel_format(no_ext_copies), c(""xlsx"", ""xls"", NA))
+  expect_identical(
+    format_from_signature(no_ext_copies),
+    c(""xlsx"", ""xls"", NA)
+  )
+})
+
+test_that(""excel_format(guess = FALSE) == format_from_ext()"", {
+  files <- c(""a.xlsx"", ""b.xls"", ""c.png"", ""d"")
+  expect_identical(format_from_ext(files), excel_format(files))
 })
 
-test_that(""can read files with and without extension [xlsx]"", {
-  file.copy(test_sheet(""iris-excel-xlsx.xlsx""), ""iris-xlsx-no-ending"")
-  on.exit(file.remove(""iris-xlsx-no-ending""))
-  iris_xlsx <- read_excel(test_sheet(""iris-excel-xlsx.xlsx""))
-  iris_guess <- read_excel(""iris-xlsx-no-ending"")
-  iris_explicit <- read_xlsx(""iris-xlsx-no-ending"")
-  expect_equal(iris_xlsx, iris_guess)
-  expect_equal(iris_xlsx, iris_explicit)
+test_that(""excel_format(guess = TRUE) == format_from_signature()"", {
+  orig_files <- c(
+    test_sheet(""iris-excel-xlsx.xlsx""),
+    test_sheet(""iris-excel-xls.xls""),
+    file.path(R.home(""doc""), ""html"", ""logo.jpg"")
+  )
+  no_ext_copies <- paste0(
+    tools::file_path_sans_ext(orig_files),
+    ""-no-ending""
+  )
+  file.copy(orig_files, no_ext_copies)
+  on.exit(file.remove(no_ext_copies))
+  expect_identical(
+    ## include one non-existent file, but do not try to remove it
+    excel_format(c(no_ext_copies, ""i_do_not_exist"")),
+    c(""xlsx"", ""xls"", NA, NA)
+  )
 })",True,False,Documentation / Formatting,7
tidyverse,readxl,a546d01b1f94ae432618f435190c07fae17acd91,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-15T19:57:49Z,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-15T19:57:49Z,"Simplify typedefs around 64bit integers

Fixes #450

This is one of our usual manual patches that I neglected to re-apply in my recent pull from upstream libxls. See #344.",src/libxls/xlstypes.h,False,False,False,False,1,15,16,"---FILE: src/libxls/xlstypes.h---
@@ -47,24 +47,10 @@ typedef uint16_t			WORD_UA		__attribute__ ((aligned (1)));	// 2 bytes
 typedef uint32_t			DWORD_UA	__attribute__ ((aligned (1)));	// 4 bytes
 #endif
 
-// Windows
-#if defined(_MSC_VER) && defined(WIN32)
-
+#ifdef _WIN32
 typedef unsigned __int64	unsigned64_t;
-
-// not windows
 #else
-
-#if defined(_UINT64_T)
-
 typedef uint64_t			unsigned64_t;
-
-#else
-
-typedef unsigned long long	unsigned64_t;
-
-// _UINT64_T
-#endif
 #endif
 
 #endif",False,False,Rendering / Conversion,0
tidyverse,readxl,794c124e5a4460392d57752774aa11cd24aed719,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-15T19:01:39Z,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-15T19:01:39Z,Patch to https://github.com/evanmiller/libxls/commit/ee36cb027b6c2d656cd294b7dbb89c6503857532,src/libxls/xls2csv.c,False,False,False,False,2,2,4,"---FILE: src/libxls/xls2csv.c---
@@ -181,9 +181,9 @@ printf(""FILE: %s\n"", argv[1]);
 				}
 
 				// display the value of the cell (either numeric or string)
-				if (cell->id == 0x27e || cell->id == 0x0BD || cell->id == 0x203) {
+				if (cell->id == XLS_RECORD_RK || cell->id == XLS_RECORD_MULRK || cell->id == XLS_RECORD_NUMBER) {
 					OutputNumber(cell->d);
-				} else if (cell->id == 0x06) {
+				} else if (cell->id == XLS_RECORD_FORMULA || cell->id == XLS_RECORD_FORMULA_ALT) {
                     // formula
 					if (cell->l == 0) // its a number
 					{",False,False,Rendering / Conversion,0
tidyverse,readxl,6369dfd73d34ff6873118ff1312b47f9f2a36dc3,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-15T05:54:26Z,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-15T18:59:09Z,Patch to https://github.com/evanmiller/libxls/commit/6218a25dedee65e07f8bb34b1fe1f83c2c4c28ac,.Rbuildignore;.gitignore;src/libxls/xls2csv.c;src/ole.c;src/xls.c,False,False,False,False,299,984,1283,"---FILE: .Rbuildignore---
@@ -25,3 +25,4 @@
 ^scratch\.R$
 ^src/fprintf-substitution\.R$
 ^\.github$
+^fprintf-matches\.txt$

---FILE: .gitignore---
@@ -8,3 +8,4 @@ rsconnect
 inst/doc
 scratch.R
 src/fprintf-substitution.R
+fprintf-matches.txt

---FILE: src/libxls/xls2csv.c---
@@ -63,175 +63,176 @@ static void Usage(char *progName)
 extern int getopt(int nargc, char * const *nargv, const char *ostr);
 
 int main(int argc, char *argv[]) {
-  xlsWorkBook* pWB;
-  xlsWorkSheet* pWS;
-  unsigned int i, j;
-  int justList = 0;
-  char *sheetName = """";
-
-  if(argc < 2) {
-    Usage(argv[0]);
-  }
-
-  //fprintf3(stderr, ""DIR: %s\n\n"", getcwd(NULL, 1024));
-
-  optind = 2; // skip file arg
-
-  int ch;
-  while ((ch = getopt(argc, argv, ""lt:e:q:f:"")) != -1) {
-    switch (ch) {
-    case 'l':
-      justList = 1;
-      break;
-    case 'e':
-      encoding = strdup(optarg);
-      break;
-    case 't':
-      sheetName = strdup(optarg);
-      break;
-    case 'q':
-      stringSeparator = optarg[0];
-      break;
-    case 'f':
-      fieldSeparator = strdup(optarg);
-      break;
-    default:
-      Usage(argv[0]);
-    break;
+	xlsWorkBook* pWB;
+	xlsWorkSheet* pWS;
+    xls_error_t error = LIBXLS_OK;
+	unsigned int i, j;
+    int justList = 0;
+    char *sheetName = """";
+
+    if(argc < 2) {
+        Usage(argv[0]);
     }
-  }
 
-  // open workbook, choose standard conversion
-  pWB = xls_open(argv[1], encoding);
-  if (!pWB) {
-    fprintf2(stderr, ""File not found"");
-    fprintf2(stderr, ""\n"");
-    return EXIT_FAILURE;
-  }
-
-  // check if the requested sheet (if any) exists
-  if (sheetName[0]) {
-    for (i = 0; i < pWB->sheets.count; i++) {
-      if (strcmp(sheetName, (char *)pWB->sheets.sheet[i].name) == 0) {
-        break;
-      }
-    }
-
-    if (i == pWB->sheets.count) {
-      fprintf3(stderr, ""Sheet \""%s\"" not found"", sheetName);
-      fprintf2(stderr, ""\n"");
-      return EXIT_FAILURE;
-    }
-  }
-
-  // process all sheets
-  for (i = 0; i < pWB->sheets.count; i++) {
-    int isFirstLine = 1;
-
-    // just looking for sheet names
-    if (justList) {
-      printf(""%s\n"", pWB->sheets.sheet[i].name);
-      continue;
-    }
-
-    // check if this the sheet we want
-    if (sheetName[0]) {
-      if (strcmp(sheetName, (char *)pWB->sheets.sheet[i].name) != 0) {
-        continue;
-      }
-    }
-
-    // open and parse the sheet
-    pWS = xls_getWorkSheet(pWB, i);
-    xls_parseWorkSheet(pWS);
-
-    // process all rows of the sheet
-    for (j = 0; j <= (unsigned int)pWS->rows.lastrow; ++j) {
-      int isFirstCol = 1;
-      WORD cellRow = (WORD)j;
-      struct st_row_data* row = xls_row(pWS, cellRow);
-
-      // process cells
-      if (!isFirstLine) {
-        printf(""%s"", lineSeparator);
-      } else {
-        isFirstLine = 0;
-      }
-
-      WORD cellCol;
-      for (cellCol = 0; cellCol <= pWS->rows.lastcol; cellCol++) {
-        //printf(""Processing row=%d col=%d\n"", cellRow+1, cellCol+1);
-
-        xlsCell *cell = xls_cell(pWS, cellRow, cellCol);
-
-        if ((!cell) || (cell->isHidden)) {
-          continue;
+	//fprintf3(stderr, ""DIR: %s\n\n"", getcwd(NULL, 1024));
+
+    optind = 2; // skip file arg
+
+    int ch;
+    while ((ch = getopt(argc, argv, ""lt:e:q:f:"")) != -1) {
+        switch (ch) {
+        case 'l':
+            justList = 1;
+            break;
+        case 'e':
+            encoding = strdup(optarg);
+            break;
+        case 't':
+            sheetName = strdup(optarg);
+            break;
+        case 'q':
+            stringSeparator = optarg[0];
+            break;
+        case 'f':
+            fieldSeparator = strdup(optarg);
+            break;
+        default:
+            Usage(argv[0]);
+            break;
         }
-
-        if (!isFirstCol) {
-          printf(""%s"", fieldSeparator);
-        } else {
-          isFirstCol = 0;
+     }
+printf(""FILE: %s\n"", argv[1]);
+
+	// open workbook, choose standard conversion
+	pWB = xls_open_file(argv[1], encoding, &error);
+	if (!pWB) {
+        fprintf3(stderr, ""Error reading XLS file: %s\n"", xls_getError(error));
+		return EXIT_FAILURE;
+	}
+
+	// check if the requested sheet (if any) exists
+	if (sheetName[0]) {
+		for (i = 0; i < pWB->sheets.count; i++) {
+			if (strcmp(sheetName, (char *)pWB->sheets.sheet[i].name) == 0) {
+				break;
+			}
+		}
+
+		if (i == pWB->sheets.count) {
+			fprintf3(stderr, ""Sheet \""%s\"" not found"", sheetName);
+			fprintf2(stderr, ""\n"");
+			return EXIT_FAILURE;
+		}
+	}
+
+	// process all sheets
+	for (i = 0; i < pWB->sheets.count; i++) {
+		int isFirstLine = 1;
+
+        // just looking for sheet names
+        if (justList) {
+            printf(""%s\n"", pWB->sheets.sheet[i].name);
+            continue;
         }
 
-        // display the colspan as only one cell, but reject rowspans (they can't be converted to CSV)
-        if (cell->rowspan > 1) {
-          fprintf5(stderr, ""Warning: %d rows spanned at col=%d row=%d: output will not match the Excel file.\n"", cell->rowspan, cellCol+1, cellRow+1);
-        }
-
-        // display the value of the cell (either numeric or string)
-        if (cell->id == 0x27e || cell->id == 0x0BD || cell->id == 0x203) {
-          OutputNumber(cell->d);
-        } else if (cell->id == 0x06) {
-          // formula
-          if (cell->l == 0) // its a number
-          {
-            OutputNumber(cell->d);
-          } else {
-            if (!strcmp((char *)cell->str, ""bool"")) // its boolean, and test cell->d
-            {
-              OutputString((int) cell->d ? ""true"" : ""false"");
-            } else if (!strcmp((char *)cell->str, ""error"")) // formula is in error
-            {
-              OutputString(""*error*"");
-            } else // ... cell->str is valid as the result of a string formula.
-            {
-              OutputString((char *)cell->str);
-            }
-          }
-        } else if (cell->str != NULL) {
-          OutputString((char *)cell->str);
-        } else {
-          OutputString("""");
-        }
-      }
-    }
-    xls_close_WS(pWS);
-  }
-
-  xls_close(pWB);
-  return EXIT_SUCCESS;
+		// check if this the sheet we want
+		if (sheetName[0]) {
+			if (strcmp(sheetName, (char *)pWB->sheets.sheet[i].name) != 0) {
+				continue;
+			}
+		}
+
+		// open and parse the sheet
+		pWS = xls_getWorkSheet(pWB, i);
+		xls_parseWorkSheet(pWS);
+
+		// process all rows of the sheet
+		for (j = 0; j <= (unsigned int)pWS->rows.lastrow; ++j) {
+			int isFirstCol = 1;
+			WORD cellRow = (WORD)j;
+			//struct st_row_data* row = xls_row(pWS, cellRow);
+
+			// process cells
+			if (!isFirstLine) {
+				printf(""%s"", lineSeparator);
+			} else {
+				isFirstLine = 0;
+			}
+
+			WORD cellCol;
+			for (cellCol = 0; cellCol <= pWS->rows.lastcol; cellCol++) {
+                //printf(""Processing row=%d col=%d\n"", cellRow+1, cellCol+1);
+
+				xlsCell *cell = xls_cell(pWS, cellRow, cellCol);
+
+				if ((!cell) || (cell->isHidden)) {
+					continue;
+				}
+
+				if (!isFirstCol) {
+					printf(""%s"", fieldSeparator);
+				} else {
+					isFirstCol = 0;
+				}
+
+				// display the colspan as only one cell, but reject rowspans (they can't be converted to CSV)
+				if (cell->rowspan > 1) {
+					fprintf5(stderr, ""Warning: %d rows spanned at col=%d row=%d: output will not match the Excel file.\n"", cell->rowspan, cellCol+1, cellRow+1);
+				}
+
+				// display the value of the cell (either numeric or string)
+				if (cell->id == 0x27e || cell->id == 0x0BD || cell->id == 0x203) {
+					OutputNumber(cell->d);
+				} else if (cell->id == 0x06) {
+                    // formula
+					if (cell->l == 0) // its a number
+					{
+						OutputNumber(cell->d);
+					} else {
+						if (!strcmp((char *)cell->str, ""bool"")) // its boolean, and test cell->d
+						{
+							OutputString((int) cell->d ? ""true"" : ""false"");
+						} else if (!strcmp((char *)cell->str, ""error"")) // formula is in error
+						{
+							OutputString(""*error*"");
+						} else // ... cell->str is valid as the result of a string formula.
+						{
+							OutputString((char *)cell->str);
+						}
+					}
+				} else if (cell->str != NULL) {
+					OutputString((char *)cell->str);
+				} else {
+					OutputString("""");
+				}
+			}
+		}
+		xls_close_WS(pWS);
+	}
+
+	xls_close(pWB);
+	return EXIT_SUCCESS;
 }
 
 // Output a CSV String (between double quotes)
 // Escapes (doubles)"" and \ characters
 static void OutputString(const char *string) {
-  const char *str;
-
-  printf(""%c"", stringSeparator);
-  for (str = string; *str; str++) {
-    if (*str == stringSeparator) {
-      printf(""%c%c"", stringSeparator, stringSeparator);
-    } else if (*str == '\\') {
-      printf(""\\\\"");
-    } else {
-      printf(""%c"", *str);
-    }
-  }
-  printf(""%c"", stringSeparator);
+	const char *str;
+
+	printf(""%c"", stringSeparator);
+	for (str = string; *str; str++) {
+		if (*str == stringSeparator) {
+			printf(""%c%c"", stringSeparator, stringSeparator);
+		} else if (*str == '\\') {
+			printf(""\\\\"");
+		} else {
+			printf(""%c"", *str);
+		}
+	}
+	printf(""%c"", stringSeparator);
 }
 
 // Output a CSV Number
 static void OutputNumber(const double number) {
-  printf(""%.15g"", number);
+	printf(""%.15g"", number);
 }

---FILE: src/ole.c---
@@ -30,7 +30,7 @@
  *
  */
 
-#include ""config.h"" 
+#include ""config.h""
 
 #include <memory.h>
 #include <math.h>
@@ -66,7 +66,7 @@ static void *ole_malloc(size_t len) {
 }
 
 // Read next sector of stream
-int ole2_bufread(OLE2Stream* olest) 
+int ole2_bufread(OLE2Stream* olest)
 {
 	BYTE *ptr;
 
@@ -85,7 +85,7 @@ int ole2_bufread(OLE2Stream* olest)
             }
 
 			ptr = olest->ole->SSAT + olest->fatpos*olest->ole->lssector;
-			memcpy(olest->buf, ptr, olest->bufsize); 
+			memcpy(olest->buf, ptr, olest->bufsize);
 
             if (olest->fatpos >= olest->ole->SSecIDCount) {
                 if (xls_debug) fprintf4(stderr, ""Error: fatpos %d out-of-bounds for SSecID[%d]\n"",
@@ -109,7 +109,13 @@ int ole2_bufread(OLE2Stream* olest)
                 return -1;
             }
 
-			olest->fatpos=xlsIntVal(olest->ole->SecID[olest->fatpos]);
+            if (olest->fatpos == xlsIntVal(olest->ole->SecID[olest->fatpos])) {
+                if (xls_debug) fprintf4(stderr, ""Error: Sector loop detected, SecID[%d] = %d\n"",
+                        (int)olest->fatpos, (int)olest->fatpos);
+                return -1;
+            }
+
+            olest->fatpos = xlsIntVal(olest->ole->SecID[olest->fatpos]);
 			olest->pos=0;
 			olest->cfat++;
 		}
@@ -123,7 +129,6 @@ ssize_t ole2_read(void* buf, size_t size, size_t count, OLE2Stream* olest)
 {
     size_t didReadCount=0;
     size_t totalReadCount;
-	size_t needToReadCount;
 
 	totalReadCount=size*count;
 
@@ -133,7 +138,7 @@ ssize_t ole2_read(void* buf, size_t size, size_t count, OLE2Stream* olest)
     if ((long)olest->size>=0 && !olest->sfat)	// directory is -1
     {
 		size_t rem;
-		rem = olest->size - (olest->cfat*olest->ole->lsector+olest->pos);		
+		rem = olest->size - (olest->cfat*olest->ole->lsector+olest->pos);
         totalReadCount = rem<totalReadCount?rem:totalReadCount;
         if (rem<=0) olest->eof=1;
 
@@ -144,32 +149,25 @@ ssize_t ole2_read(void* buf, size_t size, size_t count, OLE2Stream* olest)
 	while ((!olest->eof) && (didReadCount < totalReadCount))
 	{
 		unsigned long remainingBytes;
+        size_t needToReadCount;
 
 		needToReadCount	= totalReadCount - didReadCount;
 		remainingBytes	= olest->bufsize - olest->pos;
-		//printf(""  test: (totalReadCount-didReadCount)=%d (olest->bufsize-olest->pos)=%d\n"", (totalReadCount-didReadCount), (olest->bufsize-olest->pos) );
 
-		if (needToReadCount < remainingBytes)	// does the current sector contain all the data I need?
-		{
-			// printf(""  had %d bytes of memory, copy=%d\n"", (olest->bufsize-olest->pos), needToReadCount);
+		if (needToReadCount < remainingBytes) { // does the current sector contain all the data I need?
 			memcpy((BYTE*)buf + didReadCount, olest->buf + olest->pos, needToReadCount);
 			olest->pos		+= needToReadCount;
 			didReadCount	+= needToReadCount;
 		} else {
-			// printf(""  had %d bytes of memory, copy=%d\n"", remainingBytes, remainingBytes);
 			memcpy((BYTE*)buf + didReadCount, olest->buf + olest->pos, remainingBytes);
 			olest->pos		+= remainingBytes;
 			didReadCount	+= remainingBytes;
 			if (ole2_bufread(olest) == -1)
                 return -1;
 		}
-		//printf(""  if(fatpos=0x%X==EOC=0x%X) && (pos=%d >= bufsize=%d)\n"", olest->fatpos, ENDOFCHAIN, olest->pos, olest->bufsize);
-		if (((DWORD)olest->fatpos == ENDOFCHAIN) && (olest->pos >= olest->bufsize))
-		{
+		if (((DWORD)olest->fatpos == ENDOFCHAIN) && (olest->pos >= olest->bufsize)) {
 			olest->eof=1;
 		}
-
-		//printf(""  eof=%d (didReadCount=%ld != totalReadCount=%ld)\n"", olest->eof, didReadCount, totalReadCount);
 	}
     if (didReadCount > totalReadCount)
         return -1;
@@ -202,22 +200,24 @@ OLE2Stream* ole2_sopen(OLE2* ole,DWORD start, size_t size)
     fprintf3(stderr, ""ole2_sopen start=%Xh\n"", start);
 #endif
 
-	olest=(OLE2Stream*)calloc(1, sizeof(OLE2Stream));
+	olest = calloc(1, sizeof(OLE2Stream));
 	olest->ole=ole;
 	olest->size=size;
 	olest->fatpos=start;
 	olest->start=start;
-	olest->pos=0;
-	olest->eof=0;
 	olest->cfat=-1;
 	if((long)size > 0 && size < (size_t)ole->sectorcutoff) {
 		olest->bufsize=ole->lssector;
 		olest->sfat = 1;
 	} else {
 		olest->bufsize=ole->lsector;
 	}
-	olest->buf = ole_malloc(olest->bufsize);
-	ole2_bufread(olest);
+    olest->buf = ole_malloc(olest->bufsize);
+
+    if (ole2_bufread(olest) == -1) {
+        ole2_fclose(olest);
+        olest = NULL;
+    }
 
 	// if(xls_debug) printf(""sopen: sector=%d next=%d\n"", start, olest->fatpos);
     return olest;
@@ -234,19 +234,21 @@ int ole2_seek(OLE2Stream* olest,DWORD ofs)
 		int i;
 		olest->fatpos=olest->start;
 
-		if (div_rez.quot!=0)
-		{
-			for (i=0;i<div_rez.quot;i++) {
+        if (div_rez.quot!=0)
+        {
+            for (i=0;i<div_rez.quot;i++) {
                 if (olest->fatpos >= olest->ole->SSecIDCount)
                     return -1;
-				olest->fatpos=xlsIntVal(olest->ole->SSecID[olest->fatpos]);
+                olest->fatpos=xlsIntVal(olest->ole->SSecID[olest->fatpos]);
             }
-		}
+        }
 
-		ole2_bufread(olest);
-		olest->pos=div_rez.rem;
-		olest->eof=0;
-		olest->cfat=div_rez.quot;
+        if (ole2_bufread(olest) == -1)
+            return -1;
+
+        olest->pos=div_rez.rem;
+        olest->eof=0;
+        olest->cfat=div_rez.quot;
 		//printf(""%i=%i %i\n"",ofs,div_rez.quot,div_rez.rem);
 	} else {
 		ldiv_t div_rez=ldiv(ofs,olest->ole->lsector);
@@ -256,16 +258,18 @@ int ole2_seek(OLE2Stream* olest,DWORD ofs)
 #endif
 		olest->fatpos=olest->start;
 
-		if (div_rez.quot!=0)
-		{
-			for (i=0;i<div_rez.quot;i++) {
+        if (div_rez.quot!=0)
+        {
+            for (i=0;i<div_rez.quot;i++) {
                 if (olest->fatpos >= olest->ole->SecIDCount)
                     return -1;
                 olest->fatpos=xlsIntVal(olest->ole->SecID[olest->fatpos]);
             }
-		}
+        }
+
+        if (ole2_bufread(olest) == -1)
+            return -1;
 
-		ole2_bufread(olest);
 		olest->pos=div_rez.rem;
 		olest->eof=0;
 		olest->cfat=div_rez.quot;
@@ -353,7 +357,7 @@ static ssize_t ole2_read_header(OLE2 *ole) {
         total_bytes_read = -1;
         goto cleanup;
     }
-	
+
     ole->cfat=oleh->cfat;
     ole->dirstart=oleh->dirstart;
     ole->sectorcutoff=oleh->sectorcutoff;
@@ -374,7 +378,7 @@ static ssize_t ole2_read_header(OLE2 *ole) {
 		fprintf4(stderr, ""mini len:      %X (%i)\n"",ole->lssector,ole->lssector);	// ole
 		fprintf3(stderr, ""Fat sect.:     %i \n"",oleh->cfat);
 		fprintf3(stderr, ""Dir Start:     %i \n"",oleh->dirstart);
-		
+
 		fprintf3(stderr, ""Mini Cutoff:   %i \n"",oleh->sectorcutoff);
 		fprintf3(stderr, ""MiniFat Start: %X \n"",oleh->sfatstart);
 		fprintf3(stderr, ""Count MFat:    %i \n"",oleh->csfat);
@@ -397,11 +401,16 @@ static ssize_t ole2_read_header(OLE2 *ole) {
 
 static ssize_t ole2_read_body(OLE2 *ole) {
 	// reuse this buffer
-    PSS *pss = malloc(512);
-    OLE2Stream *olest=ole2_sopen(ole,ole->dirstart, -1);
+    PSS *pss = NULL;
+    OLE2Stream *olest = NULL;
     char* name = NULL;
     ssize_t bytes_read = 0, total_bytes_read = 0;
 
+    if ((olest = ole2_sopen(ole,ole->dirstart, -1)) == NULL) {
+        total_bytes_read = -1;
+        goto cleanup;
+    }
+    pss = malloc(sizeof(PSS));
     do {
         if ((bytes_read = ole2_read(pss,1,sizeof(PSS),olest)) == -1) {
             total_bytes_read = -1;
@@ -414,21 +423,21 @@ static ssize_t ole2_read_body(OLE2 *ole) {
             goto cleanup;
         }
         name=unicode_decode(pss->name, pss->bsize, 0, ""UTF-8"");
-#ifdef OLE_DEBUG	
+#ifdef OLE_DEBUG
 		fprintf4(stderr, ""OLE NAME: %s count=%d\n"", name, (int)ole->files.count);
 #endif
-        if (pss->type == PS_USER_ROOT || pss->type == PS_USER_STREAM) // (name!=NULL) // 
+        if (pss->type == PS_USER_ROOT || pss->type == PS_USER_STREAM) // (name!=NULL) //
         {
 
-#ifdef OLE_DEBUG		
+#ifdef OLE_DEBUG
 			fprintf3(stderr, ""OLE TYPE: %s file=%d \n"", pss->type == PS_USER_ROOT ? ""root"" : ""user"", (int)ole->files.count);
-#endif		
+#endif
             ole->files.file = realloc(ole->files.file,(ole->files.count+1)*sizeof(struct st_olefiles_data));
             ole->files.file[ole->files.count].name=name;
             ole->files.file[ole->files.count].start=pss->sstart;
             ole->files.file[ole->files.count].size=pss->size;
             ole->files.count++;
-			
+
 			if(pss->sstart == ENDOFCHAIN) {
 				if (xls_debug) verbose(""END OF CHAIN\n"");
 			} else if(pss->type == PS_USER_STREAM) {
@@ -451,7 +460,7 @@ static ssize_t ole2_read_body(OLE2 *ole) {
 			} else if(pss->type == PS_USER_ROOT) {
 				DWORD sector, k, blocks;
 				BYTE *wptr;
-				
+
 				blocks = (pss->size + (ole->lsector - 1)) / ole->lsector;	// count partial
 				if ((ole->SSAT = ole_malloc(blocks*ole->lsector)) == NULL) {
                     total_bytes_read = -1;
@@ -473,16 +482,17 @@ static ssize_t ole2_read_body(OLE2 *ole) {
 					wptr += ole->lsector;
 					sector = xlsIntVal(ole->SecID[sector]);
 				}
-			}	
+			}
 		} else {
 			free(name);
 		}
-    }
-    while (!olest->eof);
+    } while (!olest->eof);
 
 cleanup:
-	ole2_fclose(olest);
-    free(pss);
+    if (olest)
+        ole2_fclose(olest);
+    if (pss)
+        free(pss);
 
     return total_bytes_read;
 }
@@ -495,12 +505,12 @@ OLE2 *ole2_open_buffer(const void *buffer, size_t len) {
     ole->buffer_len = len;
 
     if (ole2_read_header(ole) == -1) {
-        free(ole);
+        ole2_close(ole);
         return NULL;
     }
 
     if (ole2_read_body(ole) == -1) {
-        free(ole);
+        ole2_close(ole);
         return NULL;
     }
 
@@ -527,14 +537,12 @@ OLE2* ole2_open_file(const char *file)
     }
 
     if (ole2_read_header(ole) == -1) {
-		fclose(ole->file);
-        free(ole);
+        ole2_close(ole);
         return NULL;
     }
 
     if (ole2_read_body(ole) == -1) {
-		fclose(ole->file);
-        free(ole);
+        ole2_close(ole);
         return NULL;
     }
 
@@ -574,15 +582,12 @@ static ssize_t sector_read(OLE2* ole2, void *buffer, size_t sid)
 	size_t num;
 	size_t seeked;
 
-	//printf(""sector_read: sid=%zu (0x%zx) lsector=%u sector_pos=%zu\n"", sid, sid, ole2->lsector, sector_pos(ole2, sid) );
-    seeked = ole2_fseek(ole2, sector_pos(ole2, sid));
-	if(seeked != 0) {
+	if ((seeked = ole2_fseek(ole2, sector_pos(ole2, sid))) != 0) {
 		if (xls_debug) fprintf5(stderr, ""Error: wanted to seek to sector %zu (0x%zx) loc=%zu\n"", sid, sid, sector_pos(ole2, sid));
         return -1;
     }
 
-	num = ole2_fread(ole2, buffer, ole2->lsector, 1);
-    if(num != 1) {
+    if ((num = ole2_fread(ole2, buffer, ole2->lsector, 1)) != 1) {
         if (xls_debug) fprintf4(stderr, ""Error: fread wanted 1 got %zu loc=%zu\n"", num, sector_pos(ole2, sid));
         return -1;
     }

---FILE: src/xls.c---
@@ -109,22 +109,6 @@ typedef struct {
 	uint32_t		data[0];
 } property;
 
-#ifdef DEBUG_DRAWINGS
-struct drawHeader {
-	unsigned int rec : 4;
-	unsigned int instance : 12;
-	unsigned int type : 16;
-	unsigned int len : 32;
-};
-
-static char *formData;
-static char *formFunc;
-static struct drawHeader drawProc(uint8_t *buf, uint32_t maxLen, uint32_t *off, int level);
-static void dumpRec(char *comment, struct drawHeader *h, int len, uint8_t *buf);
-static int finder(uint8_t *buf, uint32_t len, uint16_t pattern);
-static uint32_t sheetOffset;
-#endif
-
 #pragma pack(pop)
 
 int xls(int debug)
@@ -143,8 +127,11 @@ xls_error_t xls_addSST(xlsWorkBook* pWB,SST* sst,DWORD size)
     pWB->sst.lastrt=0;
     pWB->sst.lastsz=0;
 
-    pWB->sst.count = sst->num;
-    if ((pWB->sst.string = calloc(pWB->sst.count, sizeof(struct str_sst_string))) == NULL)
+    if (sst->num > (1<<20))
+        return LIBXLS_ERROR_MALLOC;
+
+    if ((pWB->sst.string = calloc(pWB->sst.count = sst->num,
+                    sizeof(struct str_sst_string))) == NULL)
         return LIBXLS_ERROR_MALLOC;
 
     return xls_appendSST(pWB, sst->strings, size - sizeof(SST));
@@ -445,53 +432,89 @@ xls_error_t xls_makeTable(xlsWorkSheet* pWS)
         tmp->lcell=pWS->rows.lastcol;
 
 		tmp->cells.count = pWS->rows.lastcol+1;
-        if ((tmp->cells.cell = calloc(tmp->cells.count,sizeof(struct st_cell_data))) == NULL)
+        if ((tmp->cells.cell = calloc(tmp->cells.count, sizeof(struct st_cell_data))) == NULL)
             return LIBXLS_ERROR_MALLOC;
 
         for (i=0;i<=pWS->rows.lastcol;i++)
         {
-            tmp->cells.cell[i].col=i;
-            tmp->cells.cell[i].row=t;
-            tmp->cells.cell[i].width=pWS->defcolwidth;
-            tmp->cells.cell[i].xf=0;
-            tmp->cells.cell[i].str=NULL;
-            tmp->cells.cell[i].d=0;
-            tmp->cells.cell[i].l=0;
-            tmp->cells.cell[i].isHidden=0;
-            tmp->cells.cell[i].colspan=0;
-            tmp->cells.cell[i].rowspan=0;
-            tmp->cells.cell[i].id=XLS_RECORD_BLANK;
-            tmp->cells.cell[i].str=NULL;
+            tmp->cells.cell[i].col = i;
+            tmp->cells.cell[i].row = t;
+            tmp->cells.cell[i].width = pWS->defcolwidth;
+            tmp->cells.cell[i].id = XLS_RECORD_BLANK;
         }
     }
     return LIBXLS_OK;
 }
 
+int xls_isCellTooSmall(xlsWorkBook* pWB, BOF* bof, BYTE* buf) {
+    if (bof->size < sizeof(COL))
+        return 1;
+
+    if (bof->id == XLS_RECORD_FORMULA || bof->id == XLS_RECORD_FORMULA_ALT)
+        return (bof->size < sizeof(FORMULA));
+
+    if (bof->id == XLS_RECORD_MULRK)
+        return (bof->size < sizeof(MULRK));
+
+    if (bof->id == XLS_RECORD_MULBLANK)
+        return (bof->size < sizeof(MULBLANK));
+
+    if (bof->id == XLS_RECORD_LABELSST) {
+        return (bof->size < sizeof(LABEL) + (pWB->is5ver ? 2 : 4));
+    }
+
+    if (bof->id == XLS_RECORD_LABEL) {
+        size_t label_len = xlsShortVal(*(WORD *)((LABEL*)buf)->value);
+        if (pWB->is5ver) {
+            return (bof->size < sizeof(LABEL) + 2 + label_len);
+        }
+        if ((((LABEL*)buf)->value[2] & 0x01)) {
+            return (bof->size < sizeof(LABEL) + 3 + label_len);
+        }
+        return (bof->size < sizeof(LABEL) + 3 + 2 * label_len);
+    }
+
+    if (bof->id == XLS_RECORD_RK)
+        return (bof->size < sizeof(RK));
+
+    if (bof->id == XLS_RECORD_NUMBER)
+        return (bof->size < sizeof(BR_NUMBER));
+
+    if (bof->id == XLS_RECORD_BOOLERR)
+        return (bof->size < sizeof(BOOLERR));
+
+    return 0;
+}
+
 struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
 {
     struct st_cell_data*	cell;
     struct st_row_data*		row;
+    WORD_UA                 col;
     int						i;
 
 	verbose (""xls_addCell"");
 
-    if (bof->size < sizeof(COL))
+    if (xls_isCellTooSmall(pWS->workbook, bof, buf))
         return NULL;
 
 	// printf(""ROW: %u COL: %u\n"", xlsShortVal(((COL*)buf)->row), xlsShortVal(((COL*)buf)->col));
     row=&pWS->rows.row[xlsShortVal(((COL*)buf)->row)];
-    //cell=&row->cells.cell[((COL*)buf)->col - row->fcell]; DFH - inconsistent
-    cell=&row->cells.cell[xlsShortVal(((COL*)buf)->col)];
+
+    col = xlsShortVal(((COL*)buf)->col);
+    if (col >= row->cells.count) {
+        if (xls_debug) fprintf2(stderr, ""Error: Column index out of bounds\n"");
+        return NULL;
+    }
+    cell = &row->cells.cell[col];
+
     cell->id=bof->id;
     cell->xf=xlsShortVal(((COL*)buf)->xf);
 
     switch (bof->id)
     {
     case XLS_RECORD_FORMULA:
     case XLS_RECORD_FORMULA_ALT:
-        if (bof->size < sizeof(FORMULA))
-            return NULL;
-
 		xlsConvertFormula((FORMULA *)buf);
         cell->id=XLS_RECORD_FORMULA;
         if (((FORMULA*)buf)->res!=0xffff) {
@@ -521,24 +544,24 @@ struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
 		if(formula_handler) formula_handler(bof->id, bof->size, buf);
         break;
     case XLS_RECORD_MULRK:
-        if (bof->size < sizeof(MULRK))
-            return NULL;
         for (i = 0; i < (bof->size - 6)/6; i++)	// 6 == 2 row + 2 col + 2 trailing index
         {
-            cell=&row->cells.cell[xlsShortVal(((MULRK*)buf)->col + i)];
-			// printf(""i=%d col=%d\n"", i, xlsShortVal(((MULRK*)buf)->col + i) );
+            WORD index = col + i;
+            if(index >= row->cells.count) {
+                if (xls_debug) fprintf2(stderr, ""Error: MULTI-RK index out of bounds\n"");
+                return NULL;
+            }
+            cell=&row->cells.cell[index];
             cell->id=XLS_RECORD_RK;
             cell->xf=xlsShortVal(((MULRK*)buf)->rk[i].xf);
             cell->d=NumFromRk(xlsIntVal(((MULRK*)buf)->rk[i].value));
             cell->str=xls_getfcell(pWS->workbook,cell, NULL);
         }
         break;
     case XLS_RECORD_MULBLANK:
-        if (bof->size < sizeof(MULBLANK))
-            return NULL;
         for (i = 0; i < (bof->size - 6)/2; i++)	// 6 == 2 row + 2 col + 2 trailing index
         {
-            WORD index = xlsShortVal(((MULBLANK*)buf)->col) + i;
+            WORD index = col + i;
             if(index >= row->cells.count) {
                 if (xls_debug) fprintf2(stderr, ""Error: MULTI-BLANK index out of bounds\n"");
                 return NULL;
@@ -551,32 +574,24 @@ struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
         break;
     case XLS_RECORD_LABELSST:
     case XLS_RECORD_LABEL:
-        if (bof->size < sizeof(LABEL))
-            return NULL;
 		cell->str = xls_getfcell(pWS->workbook, cell, ((LABEL*)buf)->value);
         if (cell->str) {
             sscanf((char *)cell->str, ""%d"", &cell->l);
             sscanf((char *)cell->str, ""%lf"", &cell->d);
         }
 		break;
     case XLS_RECORD_RK:
-        if (bof->size < sizeof(RK))
-            return NULL;
         cell->d=NumFromRk(xlsIntVal(((RK*)buf)->value));
         cell->str=xls_getfcell(pWS->workbook,cell, NULL);
         break;
     case XLS_RECORD_BLANK:
         break;
     case XLS_RECORD_NUMBER:
-        if (bof->size < sizeof(BR_NUMBER))
-            return NULL;
         xlsConvertDouble((BYTE *)&((BR_NUMBER*)buf)->value);
 		memcpy(&cell->d, &((BR_NUMBER*)buf)->value, sizeof(double)); // Required for ARM
         cell->str=xls_getfcell(pWS->workbook,cell, NULL);
         break;
     case XLS_RECORD_BOOLERR:
-        if (bof->size < sizeof(BOOLERR))
-            return NULL;
         cell->d = ((BOOLERR *)buf)->value;
         if (((BOOLERR *)buf)->iserror) {
             sprintf((char *)(cell->str = malloc(sizeof(""error""))), ""error"");
@@ -1013,26 +1028,6 @@ xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 			}
 			break;
 			
-#ifdef DEBUG_DRAWINGS
-		case XLS_RECORD_MSODRAWINGGROUP:
-		{
-			printf(""DRAWING GROUP size=%d\n"", bof1.size);
-			unsigned int total = bof1.size;
-			unsigned int off = 0;
-
-			while(off < total) {
-				struct drawHeader fooper = drawProc(buf, total, &off, 0);
-				(void)fooper;
-			}
-			printf(""Total=%d off=%d\n"", total, off);
-			
-			if(formData) printf(""%s\n"", formData);
-			if(formFunc) printf(""%s\n"", formFunc);
-			free(formData), formData = NULL;
-			free(formFunc), formFunc = NULL;
-
-		}	break;
-#endif
         default:
 			if(xls_debug)
 			{
@@ -1157,6 +1152,10 @@ xls_error_t xls_preparseWorkSheet(xlsWorkSheet* pWS)
                 pWS->rows.lastrow=xlsShortVal(((COL*)buf)->row);
             break;
         }
+        if (pWS->rows.lastcol > 256) {
+            retval = LIBXLS_ERROR_PARSE;
+            goto cleanup;
+        }
     }
     while ((!pWS->workbook->olestr->eof)&&(tmp.id!=XLS_RECORD_EOF));
 
@@ -1202,9 +1201,6 @@ xls_error_t xls_parseWorkSheet(xlsWorkSheet* pWS)
 	long offset = pWS->filepos;
     size_t read;
     xls_error_t retval = 0;
-#ifdef DEBUG_DRAWINGS
-	int continueRec = 0;
-#endif
 
 	struct st_cell_data *cell = NULL;
 	xlsWorkBook *pWB = pWS->workbook;
@@ -1344,200 +1340,8 @@ xls_error_t xls_parseWorkSheet(xlsWorkSheet* pWS)
 				if (xls_debug) xls_showCell(cell);
 			}
 			break;
-#if 0 // debugging
-		case XLS_RECORD_HYPERREF:
-			if(xls_debug) {
-				printf(""HYPERREF: "");
-				unsigned char xx, *foo = (void *)buf;
-
-				for(xx=0; xx<tmp.size; ++xx, ++foo) {
-					printf(""%2.2x "", *foo);
-				}
-				printf(""\n"");
-			}
-			break;
-		case XLS_RECORD_WINDOW2:
-			if(xls_debug) {
-				printf(""WINDOW2: "");
-				unsigned short xx, *foo = (void *)buf;
-
-				for(xx=0; xx<7; ++xx, ++foo) {
-					printf(""0x%4.4x "", *foo);
-				}
-				printf(""\n"");
-			}
-			break;
-#endif
-
-#ifdef DEBUG_DRAWINGS
-#if defined(_AIX) || defined(__sun)
-#pragma pack(1)
-#else
-#pragma pack(push, 1)
-#endif
-		case XLS_RECORD_MSODRAWING:	// MSDRAWING
-		{
-			printf(""DRAWING size=%d\n"", tmp.size);
-			sheetOffset = 100;
-			unsigned int total = tmp.size;
-			unsigned int off = 0;
-			
-			while(off < total) {
-				struct drawHeader fooper  = drawProc(buf, total, &off, 0);
-				(void)fooper;
-				printf(""---------------Total=%d off=%d\n"", total, off);
-			}
-
-			if(formData) printf(""%s\n"", formData);
-			if(formFunc) printf(""%s\n"", formFunc);
-			free(formData), formData = NULL;
-			free(formFunc), formFunc = NULL;
-			
-		}	break;
-		
-		case XLS_RECORD_TXO:
-		{
-			struct {
-				uint16_t	grbit;
-				uint16_t	rot;
-				char		reserved1[6];
-				uint16_t	cchText;
-				uint16_t	cbRuns;
-				uint16_t	ifntEmpty;
-				uint16_t	reserved2;
-			} foo;
-			memcpy(&foo, buf, 18);
-			printf(""TXO: grbit=0x%4.4X rot=0x%4.4X chText=0x%4.4X cbRuns=0x%4.4X ifntEmpty=0x%X reserved2=0x%X\n"",
-                    foo.grbit, foo.rot, foo.cchText, foo.cbRuns, foo.ifntEmpty, foo.reserved2);
-			
-			printf(""Res1: "");
-			for(int i=0; i<6; ++i) printf(""%2.2x "", foo.reserved1[i]);
-			printf(""\n"");
-			
-			continueRec = 1;
-			goto printBOF;
-		}	break;
-		
-		case XLS_RECORD_CONTINUE:
-		{
-			if(continueRec == 1) {
-				continueRec = 2;
-				
-				printf(""TEXT: "");
-				for(int i=0; i<tmp.size; ++i) printf(""%2.2x "", buf[i]);
-				printf(""\n"");
-				printf(""\""%.*s\""\n"", tmp.size-1, buf+1);
-			} else
-			if(continueRec == 2) {
-				continueRec = 0;
-				int off = 0;
-
-				struct {
-					uint16_t	ichFirst;
-					uint16_t	ifnt;
-					char		reserved[4];
-				} foo;
-				
-				for(int i=0; i<tmp.size/8; ++i) {
-					memcpy(&foo, buf+off, 8);
-					printf(""TXORUN: %d 0x%x\n"", foo.ichFirst, foo.ifnt);
-					off += 8;
-				}
-			}
-			goto printBOF;
-		} break;
-		
-		case XLS_RECORD_OBJ:
-			xls_showBOF(&tmp);
-		{
-			struct  {
-				uint16_t	ft;
-				uint16_t	cb;
-				uint16_t	ot;
-				uint16_t	idx;
-				uint16_t	flags;
-				uint16_t	unused[6];
-			} foo;
-			memcpy(&foo, buf, sizeof(foo));
-			
-			int len = (int)(tmp.size - sizeof(foo));
-			int off = sizeof(foo);
-			
-			printf(""OBJ ft=0x%X cb=0x%X ot=0x%X idx=0x%X flags=0x%X len=%d "",
-                    foo.ft, foo.cb, foo.ot, foo.idx, foo.flags, (int)(tmp.size - sizeof(foo)) );
-			//for(int i=0; i<6; ++i) printf("" 0x%02.2x"", foo.unused[i]);
-			printf(""\n"");
-			
-			if(foo.ot == 0x08) {
-				struct {
-					uint16_t ft;
-					uint16_t cb;
-					uint16_t flags;
-				} ftcf;
-				memcpy(&ftcf, buf+off, sizeof(ftcf));
-				printf("" ft=%x cb=%x flags=%4.4x\n"", ftcf.ft, ftcf.cb, ftcf.flags);
-				off += sizeof(ftcf);
-
-				struct {
-					uint16_t ft;
-					uint16_t cb;
-					uint16_t flags;
-				} FtPioGrbit;
-				memcpy(&FtPioGrbit, buf+off, sizeof(FtPioGrbit));
-				printf("" ft=%x cb=%x flags=%4.4x\n"", FtPioGrbit.ft, FtPioGrbit.cb, FtPioGrbit.flags);
-				off += sizeof(FtPioGrbit);
-			} else {
-				printf(""Extra: "");
-				for(int i=0; i<len; ++i) printf(""%2.2x "", buf[i+off]);
-				printf(""\n"");
-			}
-
-#if 0
-			struct {
-				uint16_t	ft;
-				uint16_t	cb;
-				uint8_t		guid[16];
-				uint16_t	fSharedNote;
-				uint32_t	unused;
-			} FtNts;
-			memcpy(&FtNts, buf+off, sizeof(FtNts));
-			off += sizeof(FtNts);
-			printf(""  ft=%X cb=%X fSharedNote=0x%X guid: "", FtNts.ft, FtNts.cb, FtNts.fSharedNote);
-			for(int i=0; i<16; ++i) printf(""%2.2x "", FtNts.guid[i]);
-			printf(""\n"");
-			
-			uint32_t last;
-			memcpy(&last, buf+off, 4);
-			printf(""  LAST 0x%8.8X off=%d s1=%ld s2=%ld\n"", last, off+4, sizeof(foo), sizeof(FtNts) );
-#endif
-			goto printBOF;
-		}	break;
-		
-		case XLS_RECORD_NOTE:
-		{
-			struct {
-				uint16_t	row;
-				uint16_t	col;
-				uint16_t	flags;
-				uint16_t	idx;
-				uint16_t	strLen;
-				uint8_t		strType;
-			} note;
-			memcpy(&note, buf, sizeof(note));
-			printf(""   NOTE: row=%d col=%d flags=0x%x idx=%d strLen=%d strType=%d :  "",
-                    note.row, note.col, note.flags, note.idx, note.strLen, note.strType);
-			for(int i=0; i<note.strLen; ++i) printf(""%2.2x "", buf[i+sizeof(note)]);
-			printf(""\n  %.*s now at %ld len=%d\n"", note.strLen, buf + sizeof(note), sizeof(note)+note.strLen, tmp.size);
-
-			goto printBOF;
-		}	break;
-#pragma pack(pop)
-#endif
 
         default:
-#ifdef DEBUG_DRAWINGS
-		  printBOF:
-#endif
 			if(xls_debug)
 			{
 				//xls_showBOF(&tmp);
@@ -1701,7 +1505,7 @@ xlsCell	*xls_cell(xlsWorkSheet* pWS, WORD cellRow, WORD cellCol)
 
     if(cellRow > pWS->rows.lastrow) return NULL;
     row = &pWS->rows.row[cellRow];
-    if(cellCol > row->cells.count) return NULL;
+    if(row == NULL || cellCol >= row->cells.count) return NULL;
 
     return &row->cells.cell[cellCol];
 }
@@ -1777,8 +1581,7 @@ void xls_close_WS(xlsWorkSheet* pWS)
 {
 	if(!pWS) return;
 
-    // ROWS
-    {
+    if (pWS->rows.row) {
         DWORD i, j;
         for(j=0; j<=pWS->rows.lastrow; ++j) {
             struct st_row_data *row = &pWS->rows.row[j];
@@ -1788,7 +1591,6 @@ void xls_close_WS(xlsWorkSheet* pWS)
             free(row->cells.cell);
         }
         free(pWS->rows.row);
-
     }
 
     // COLINFO
@@ -1948,498 +1750,3 @@ void xls_set_formula_hander(xls_formula_handler handler)
 {
 	formula_handler = handler;
 }
-
-#ifdef DEBUG_DRAWINGS
-
-#if defined(_AIX) || defined(__sun)
-#pragma pack(1)
-#else
-#pragma pack(push, 1)
-#endif
-
-static char spaces[] = ""                                                                                                                "";
-
-static struct drawHeader drawProc(uint8_t *buf, uint32_t maxLen, uint32_t *off_p, int level)
-{
-	struct drawHeader head = { 0, 0, 0, 0 };
-	uint32_t off = off_p ? *off_p : 0;
-	memcpy(&head, buf+off, sizeof(head));
-#if 0	// rec is the lower 4 bits
-	{
-		uint16_t foo0, foo1;
-		uint32_t foo2;
-		memcpy(&foo0, buf+off, 2);
-		memcpy(&foo1, buf+off+2, 2);
-		memcpy(&foo2, buf+off+4, 4);
-		printf(""-----------------------------[%4.4x %4.4x %x] rec=%x instance=%x type=%x len=%x\n"", foo0, foo1, foo2, head.rec, head.instance,  head.type, head.len);
-	}
-#endif
-	off += sizeof(head);
-
-	printf(""%.*s"", level*3, spaces);
-	printf(""type=%x rec=%x instance=%x len=%d    "", head.type, head.rec, head.instance, head.len);
-	
-	switch(head.type) {
-	case 0xF000:	// OfficeArtDggContainer - F000 - overall header
-	{
-		printf(""OfficeArtDggContainer\n"");
-		dumpRec(""OfficeArtDggContainer"", &head, 0, NULL);
-
-		int startOff = off;
-		while( (off - startOff) < head.len && off < maxLen) {
-			struct drawHeader fooper2 = drawProc(buf, maxLen, &off, level+1);
-			(void)fooper2;
-		}
-		
-		printf(""%.*s"", level*3, spaces);
-		printf(""Total=%d off=%d ObjectSize=%d\n"", maxLen, off, off-startOff);
-		
-	}	break;
-
-#if 0
-	DRAWING 0xf002 208
-	  rec=0 instance=1 type=f008 len=8
-	  csp=4 spidCur=1027
-	rec=f instance=0 type=f003 len=462
-	Total=208 off=486
-	OBJ id=1 ot=0x19 flags=0x4011 check=0x0 len=30
-	  ft=D cb=16 fSharedNote=0x0 guid: 8e 2e 69 ed f2 7d e3 11 99 7f 00 16 cb 93 e7 b5 
-	  LAST 0x00000000
-	type=f00d rec=0 instance=0 len=0    WTF ?!?!?!
-
-#endif
-	case 0xF002:
-	{
-		printf(""OfficeArtDgContainer\n"");
-		dumpRec(""OfficeArtDgContainer"", &head, 0, NULL);
-
-		int startOff = off;
-		while( (off - startOff) < head.len && off < maxLen) {
-			struct drawHeader fooper2 = drawProc(buf, maxLen, &off, level+1);
-			(void)fooper2;
-		}
-		
-		printf(""%.*s"", level*3, spaces);
-		printf(""Total=%d off=%d ObjectSize=%d\n"", maxLen, off, off-startOff);
-
-	}	break;
-
-	case 0xF003:
-	{
-		printf(""OfficeArtSpgrContainer\n"");
-		dumpRec(""OfficeArtSpgrContainer"", &head, 0, NULL);
-
-		int startOff = off;
-		while( (off - startOff) < head.len && off < maxLen) {
-			struct drawHeader fooper2 = drawProc(buf, maxLen, &off, level+1);
-			(void)fooper2;
-		}
-		
-		printf(""%.*s"", level*3, spaces);
-		printf(""Total=%d off=%d ObjectSize=%d  FIXME FIXME FIXME\n"", maxLen, off, off-startOff);
-	}	break;
-
-	case 0xF001:
-	{
-		printf(""OfficeArtBStoreContainer\n"");
-		dumpRec(""OfficeArtBStoreContainer"", &head, 0, NULL);
-
-		int startOff = off;
-		while( (off - startOff) < head.len && off < maxLen) {
-			struct drawHeader fooper2 = drawProc(buf, maxLen, &off, level+1);
-			(void)fooper2;
-		}
-		
-		printf(""%.*s"", level*3, spaces);
-		printf(""Total=%d off=%d ObjectSize=%d\n"", maxLen, off, off-startOff);
-		}	break;
-	case 0xF004:
-	{
-		printf(""OfficeArtSpContainer\n"");
-		dumpRec(""OfficeArtSpContainer"", &head, 0, NULL);
-
-		int startOff = off;
-		while( (off - startOff) < head.len && off < maxLen) {
-			struct drawHeader fooper2 = drawProc(buf, maxLen, &off, level+1);
-			(void)fooper2;
-		}
-		
-		printf(""%.*s"", level*3, spaces);
-		printf(""Total=%d off=%d ObjectSize=%d\n"", maxLen, off, off-startOff);
-		}	break;
-	case 0xF006:
-	{
-		// A value that MUST be 0x00000010 + ((head.cidcl - 1) * 0x00000008)
-		unsigned int count =  (head.len - 0x10) / 0x8;
-		printf(""OfficeArtFDGGBlock count=%d\n"", count);
-		dumpRec(""OfficeArtFDGGBlock - needs to be set"", &head, 0, NULL);
-
-		// OfficeArtFDGG
-		struct {
-			uint32_t spidMax;
-			uint32_t cidcl;
-			uint32_t cspSaved;
-			uint32_t cdgSaved;
-		} fog;
-		memcpy(&fog, buf+off, 16); // OfficeArtRecordHeader F001 - specified BLIP - this is the image
-		off += 16;
-		printf(""%.*s"", level*3, spaces);
-		printf("" spidMax=%d cidcl=%d cspSaved=%d cdgSaved=%d\n"", fog.spidMax, fog.cidcl, fog.cspSaved, fog.cdgSaved);
-#if 0
-		spidMax (4 bytes): An MSOSPID structure, as defined in section 2.1.2, specifying the current maximum shape identifier that is used in any drawing. This value MUST be less than 0x03FFD7FF.
-		cidcl (4 bytes): An unsigned integer that specifies the number of OfficeArtIDCL records, as defined in section 2.2.46, + 1. This value MUST be less than 0x0FFFFFFF.
-		cspSaved (4 bytes): An unsigned integer specifying the total number of shapes that have been saved in all of the drawings.
-		cdgSaved (4 bytes): An unsigned integer specifying the total number of drawings that have been saved in the file.
-#endif
-		// OfficeArtIDCL - clusters
-		for(int i=0; i<count; ++i) {
-			struct {
-				uint32_t dgid;
-				uint32_t cspidCur;
-#if 0
-				dgid (4 bytes): An MSODGID structure, as defined in section 2.1.1, specifying the drawing identifier that owns this identifier cluster.
-				cspidCur (4 bytes): An unsigned integer that, if less than 0x00000400, specifies the largest shape identifier that is currently assigned in this cluster, or that otherwise specifies that no shapes can be added to the drawing.
-#endif
-			} foo1;
-			memcpy(&foo1, buf+off, 8); // OfficeArtIDCL
-			off += 8;
-			
-			printf(""%.*s"", level*3, spaces);
-			printf(""  dgid=%d cspid=%d\n"", foo1.dgid, foo1.cspidCur);
-		}
-		//for(int i=0; i<16; ++i) printf("" %2.2x"", *(BYTE *)(buf+off+i));
-		//printf(""\n"");
-	}	break;
-
-	case 0xF007:
-	{
-		printf(""OfficeArtFBSE\n"");
-		//dumpRec(""OfficeArtFBSE"", &head, 0, NULL);
-		struct {
-			uint8_t		btWin32;
-			uint8_t		btMacOS;
-			uint8_t		rgbUid[16];
-			uint16_t	tag;
-			uint32_t	size;
-			uint32_t	cRef;
-			uint32_t	foDelay;
-			uint8_t		unused1;
-			uint8_t		cbName;
-			uint8_t		unused2;
-			uint8_t		unused3;
-		} fooper1;
-		memcpy(&fooper1, buf+off, sizeof(fooper1));
-		off += sizeof(fooper1);
-		printf(""%.*s"", level*3, spaces);
-		printf("" rgbUid: "");
-		for(int i=0; i<16; ++i) {
-			printf("" %2.2x"", fooper1.rgbUid[i]);
-		}
-		printf(""\n"");
-		
-		printf(""%.*s"", level*3, spaces);
-		printf("" w=%d mac=%d tag=0x%x size=%d cRef=%d foDelay=%x cbName=%x"", fooper1.btWin32, fooper1.btMacOS, fooper1.tag , fooper1.size , fooper1.cRef , fooper1.foDelay, fooper1.cbName);
-		if(fooper1.cbName) printf(""name:"");
-		for(int i=0; i<fooper1.cbName; ++i) {
-			printf("" %2.2x"", *(BYTE *)(buf+off+i));
-		}
-		printf(""\n"");
-		off += fooper1.cbName;
-		
-		printf("" dataLen=%ld\n"", head.len - sizeof(fooper1) - fooper1.cbName);
-		drawProc(buf, maxLen, &off, level+1);
-
-		
-	}	break;
-
-
-#if 0
-	rgbUid (16 bytes): An MD4 message digest, as specified in [RFC1320], that specifies the unique identifier of the pixel data in the BLIP.
-	tag (2 bytes): An unsigned integer that specifies an application-defined internal resource tag. This value MUST be 0xFF for external files.
-	size (4 bytes): An unsigned integer that specifies the size, in bytes, of the BLIP in the stream.
-	cRef (4 bytes): An unsigned integer that specifies the number of references to the BLIP. A value of 0x00000000 specifies an empty slot in the OfficeArtBStoreContainer record, as defined in section 2.2.20.
-	foDelay (4 bytes): An MSOFO structure, as defined in section 2.1.4, that specifies the file offset into the associated OfficeArtBStoreDelay record, as defined in section 2.2.21, (delay stream). A value of 0xFFFFFFFF specifies that the file is not in the delay stream, and in this case, cRef MUST be 0x00000000.
-	unused1 (1 byte): A value that is undefined and MUST be ignored.
-	cbName (1 byte): An unsigned integer that specifies the length, in bytes, of the nameData field, including the terminating NULL character. This value MUST be an even number and less than or equal to 0xFE. If the value is 0x00, nameData will not be written.
-	unused2 (1 byte): A value that is undefined and MUST be ignored.
-	unused3 (1 byte): A value that is undefined and MUST be ignored.
-	nameData (variable): A Unicode null-terminated string that specifies the name of the BLIP.
-	embeddedBlip (variable): An OfficeArtBlip record, as defined in section 2.2.23, specifying the BLIP file data that is embedded in this record. If this value is not 0, foDelay MUST be ignored.
-#endif
-
-	case 0xF008:
-	{
-		printf(""OfficeArtFDG\n"");
-		dumpRec(""OfficeArtFDG - spidCur needs to be set"", &head, 0, NULL);
-		struct {
-			uint32_t	csp;
-			uint32_t	spidCur;
-		} fooper1;
-		memcpy(&fooper1, buf+off, 8);
-		off += 8;
-		printf(""%.*s"", level*3, spaces);
-		printf("" csp=%d spidCur=%d\n"", fooper1.csp, fooper1.spidCur);
-		
-#if 0
-		csp (4 bytes): An unsigned integer that specifies the number of shapes in this drawing.
-		spidCur (4 bytes): An MSOSPID structure, as defined in section 2.1.2, that specifies the shape
-		identifier of the last shape in this drawing.
-#endif
-		
-	}	break;
-
-	case 0xF009:
-	{
-		printf(""OfficeArtFSPGR\n"");
-		dumpRec(""OfficeArtFSPGR"", &head, head.len, buf+off);
-		struct {
-			int32_t	xLeft;
-			int32_t	yTop;
-			int32_t	xRight;
-			int32_t	yBottom;
-		} foo;
-		memcpy(&foo, buf+off, 16);
-		off += 16;
-		printf(""%.*s"", level*3, spaces);
-		printf("" l=%d t=%d r=%d b=%d\n"", foo.xLeft, foo.yTop, foo.xRight, foo.yBottom);
-	}	break;
-
-	case 0xF00A:	// OfficeArtFSP
-	{
-		printf(""OfficeArtFSP\n"");
-		dumpRec(""OfficeArtFSP"", &head, 0, NULL);
-		struct {
-			uint32_t	spid;
-			uint32_t	flags;
-		} foo;
-		memcpy(&foo, buf+off, 8);
-		off += 8;
-		printf(""%.*s"", level*3, spaces);
-		printf("" SPID=%d flags=0x%x\n"", foo.spid, foo.flags);
-	}	break;
-
-	case 0xF00B:
-	{
-		printf(""OfficeArtFOPT\n"");
-		dumpRec(""OfficeArtFOPT"", &head, head.len, buf+off);
-		struct {
-			//uint16_t blip : 1;
-			//uint16_t complex : 1;
-			uint16_t opid; // : 14
-			uint32_t op;
-		} foo;
-		
-		// OfficeArtFOPTE + complex
-		for(int i=0; i<head.instance; ++i) {
-			memcpy(&foo, buf+off, 6);
-			off += 6;
-			printf(""%.*s"", level*3, spaces);
-			printf("" opid=0x%4.4X(%.5d) op=%8.8X\n"", foo.opid, foo.opid, foo.op); // blip=%d complex=%d , foo.blip, foo.complex
-			//printf(""drawDataOPID(data, 0x%4.4X, 0x%8.8X);\n"", foo.opid, foo.op);
-		}
-#if 0
-          opid=80 op=000018AC(6316) Text ID
-          opid=bf op=0000000A(10) fFitTextToShape
-          opid=158 op=00000000(0) // Type of connection sites
-          opid=181 op=00000800(2048) // fillColor
-          opid=183 op=00000800(2048) // fillBackColor
-          opid=1bf op=00000010(16) // hit test
-          opid=23f op=00000003(3) // fshadowObscured
-#endif
-		int complex = head.len - head.instance * 6;
-		if(complex) {
-			printf(""%.*s"", level*3, spaces);
-			printf("" complex:"");
-		
-			for(int i=0; i<complex; ++i) {
-				printf("" %2.2x"", *(BYTE *)(buf+off+i));
-			}
-			printf(""\n"");
-		}
-		off += complex;
-	}	break;
-
-	case 0xF00D:
-		printf(""msofbtClientTextbox\n"");
-		dumpRec(""msofbtClientTextbox"", &head, head.len, buf+off);
-		break;
-
-	case 0xF010:
-		printf(""msofbtClientAnchor: "");
-		dumpRec(""msofbtClientAnchor"", &head, head.len, buf+off);
-		// https://code.google.com/p/excellibrary/source/browse/trunk/src/ExcelLibrary/Office/Excel/EscherRecords/MsofbtClientAnchor.cs?spec=svn18&r=18
-		struct {
-			uint16_t	Flag;
-			uint16_t	Col1;
-			uint16_t	DX1;
-			uint16_t	Row1;
-			uint16_t	DY1;
-			uint16_t	Col2;
-			uint16_t	DX2;
-			uint16_t	Row2;
-			uint16_t	DY2;
-		} foo;
-		memcpy(&foo, buf+off, 18);
-		printf("" Flag=0x%2.2x Col1=0x%2.2x DX1=0x%2.2x Row1=0x%2.2x DY1=0x%2.2x Col2=0x%2.2x DX2=0x%2.2x Row2=0x%2.2x DY2=0x%2.2x \n"",
-			foo.Flag, foo.Col1, foo.DX1, foo.Row1, foo.DY1, foo.Col2, foo.DX2, foo.Row2, foo.DY2);
-		off += head.len;
-		break;
-	case 0xF011:
-		printf(""msofbtClientData\n"");
-		dumpRec(""msofbtClientData"", &head, head.len, buf+off);
-		off += head.len;
-		break;
-
-	case 0xF01E:
-	{	printf(""OfficeArtBlipPNG\n"");
-		dumpRec(""OfficeArtBlipPNG"", &head, head.len, buf+off);
-		struct {
-			uint8_t		rgbUid1[16];
-			uint16_t	tag;
-		} foo;
-		memcpy(&foo, buf+off, sizeof(foo));
-		
-		//off += sizeof(foo);
-		printf(""%.*s"", level*3, spaces);
-		printf("" rgbUid1: "");
-		for(int i=0; i<16; ++i) {
-			printf("" %2.2x"", foo.rgbUid1[i]);
-		}
-		printf(""\n"");
-		off += head.len;
-	}	break;
-
-	case 0xF11E:
-		printf(""OfficeArtSplitMenuColorContainer: Array of colors\n"");
-		dumpRec(""OfficeArtSplitMenuColorContainer"", &head, head.len, buf+off);
-		off += head.len;
-		break;
-
-	case 0xF122:
-	{	printf(""OfficeArtTertiaryFOPT\n"");
-		struct {
-			//uint16_t blip : 1;
-			//uint16_t complex : 1;
-			uint16_t opid; // : 14
-			uint16_t op1;
-			uint16_t op2;
-		} foo;
-		int count = head.len/6;
-		printf(""OfficeArtFOPT count=%d\n"", count);
-		dumpRec(""OfficeArtTertiaryFOPT"", &head, head.len, buf+off);
-
-		// OfficeArtFOPTE + complex
-		for(int i=0; i<head.instance; ++i) {
-			memcpy(&foo, buf+off, 6);
-			off += 6;
-			printf(""%.*s"", level*3, spaces);
-			printf("" opid=0x%4.4X(%.5d) op1=%4.4X op1=%4.4X\n"", foo.opid, foo.opid, foo.op1, foo.op2); // blip=%d complex=%d , foo.blip, foo.complex
-		}
-		//off += head.len;
-	}	break;
-
-	default:
-		printf(""WTF ?!?!?!\n"");
-		//assert(!""Not Possible"");
-		off += head.len;
-		break;
-	}
-
-	*off_p = off;
-	return head;
-}
-
-static void dumpData(char *data);
-static void dumpFunc(char *func);
-
-static void dumpRec(char *comment, struct drawHeader *h, int len, uint8_t *buf)
-{
-	int width = 0;
-	static int num;
-	char *tmp;
-	
-return;
-
-	if(len) {
-		++num;
-		//asprintf(&tmp, ""// %s real len = %d\n"", comment, h->len);
-		asprintf(&tmp, ""static unsigned char draw%03.3d[%d] = { "", num+sheetOffset, len);
-		width = strlen(tmp);
-		dumpData(tmp);
-		
-		for(int i=0; i<len; ++i) {
-			asprintf(&tmp, ""0x%02.2X, "", buf[i]);
-			width += strlen(tmp);
-			dumpData(tmp);
-			
-			if(width >= 79) {
-				dumpData(strdup(""\n    ""));
-				width = 4;
-			}
-		}
-		dumpData(strdup(""\n  };\n""));
-	}
-	
-	char name[32];
-	if(len) {
-		sprintf(name, ""draw%03.3d"", num+sheetOffset);
-	} else {
-		strcpy(name, ""NULL"");
-	}
-
-	asprintf(&tmp, ""dumpDrawData(data,  0x%X, 0x%X, 0x%X, %u,  %d, %s /* len=%d */ ) ;  // %s\n"", h->rec, h->instance, h->type, h->len, len, name, len, comment);
-	dumpFunc(tmp);
-}
-
-
-static void dumpData(char *data)
-{
-	if(!formData) {
-		formData = calloc(1,1);
-	}
-	
-	char *oldStr = formData;
-	asprintf(&formData, ""%s%s"", oldStr, data);
-	free(oldStr);
-	free(data);
-}
-static void dumpFunc(char *func)
-{
-	if(!formFunc) {
-		formFunc = calloc(1,1);
-	}
-	
-	char *oldStr = formFunc;
-	asprintf(&formFunc, ""%s%s"", oldStr, func);
-	free(oldStr);
-}
-
-#if 0
-static int finder(uint8_t *buf, uint32_t len, uint16_t pattern)
-{
-	int ret = 0;
-	uint8_t b1 = pattern & 0xFF;
-	uint8_t b2 = pattern >> 8;
-	
-	for(int i=0; i<(len-1); ++i) {
-		if(buf[i] == b1 && buf[i+1] == b2) {
-			printf(""GOT FINDER HIT OFFSET %d\n"", i);
-			ret = 1;
-		}
-	}
-	return ret;
-}
-
-// MD4 open source: http://openwall.info/wiki/people/solar/software/public-domain-source-code/md4 or
-//                  http://www.opensource.apple.com/source/freeradius/freeradius-11/freeradius/src/lib/md4.c
-// Size of TWIPS:   http://support.microsoft.com/kb/76388
-#endif
-
-#pragma pack(pop)
-
-#endif
-
-
-
-
-",False,False,Implementation / Logic,6
tidyverse,readxl,9eab6eb8de08fc20ee43f1aba3a0f48c9f10aba9,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-15T16:37:57Z,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-15T18:38:50Z,"Re-pkgdown

taking advantage of a few fixes in tidytemplate",docs/CODE_OF_CONDUCT.html;docs/CONTRIBUTING.html;docs/ISSUE_TEMPLATE.html;docs/SUPPORT.html;docs/articles/articles/readxl-workflows.html;docs/articles/cell-and-column-types.html;docs/articles/index.html;docs/articles/releases/readxl-0.1.0.html;docs/articles/releases/readxl-0.1.1.html;docs/articles/releases/readxl-1.0.0.html;docs/articles/sheet-geometry.html;docs/authors.html;docs/index.html;docs/news/index.html;docs/pkgdown.css;docs/reference/cell-specification.html;docs/reference/excel_format.html;docs/reference/excel_sheets.html;docs/reference/index.html;docs/reference/read_excel.html;docs/reference/readxl-package.html;docs/reference/readxl_example.html,False,False,False,False,967,116,1083,"---FILE: docs/CODE_OF_CONDUCT.html---
@@ -0,0 +1,158 @@
+<!-- Generated by pkgdown: do not edit by hand -->
+<!DOCTYPE html>
+<html>
+  <head>
+  <meta charset=""utf-8"">
+<meta http-equiv=""X-UA-Compatible"" content=""IE=edge"">
+<meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
+
+<title>Contributor Code of Conduct • readxl</title>
+
+<!-- jquery -->
+<script src=""https://code.jquery.com/jquery-3.1.0.min.js"" integrity=""sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq"" crossorigin=""anonymous""></script>
+
+<!-- Bootstrap -->
+<link href=""tidyverse.css"" rel=""stylesheet"">
+<script src=""https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"" integrity=""sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"" crossorigin=""anonymous""></script>
+
+<!-- Font Awesome icons -->
+<link href=""https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css"" rel=""stylesheet"" integrity=""sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1"" crossorigin=""anonymous"">
+
+<!-- tidyverse -->
+<link href=""pkgdown.css"" rel=""stylesheet"">
+<script src=""jquery.sticky-kit.min.js""></script>
+<script src=""pkgdown.js""></script>
+
+<!-- mathjax -->
+<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
+
+<!--[if lt IE 9]>
+<script src=""https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js""></script>
+<script src=""https://oss.maxcdn.com/respond/1.4.2/respond.min.js""></script>
+<![endif]-->
+  </head>
+
+  <body>
+    <div class=""container template-title-body"">
+      <header>
+      <div class=""navbar navbar-default navbar-fixed-top"" role=""navigation"">
+  <div class=""container"">
+    <div class=""navbar-header"">
+      <button type=""button"" class=""navbar-toggle collapsed"" data-toggle=""collapse"" data-target=""#navbar"">
+        <span class=""icon-bar""></span>
+        <span class=""icon-bar""></span>
+        <span class=""icon-bar""></span>
+      </button>
+
+      <div class=""navbar-brand-container"">
+        <a class=""navbar-brand"" href=""index.html"">readxl</a>
+        <small class=""tidyverse"">part of the <a href=""http://tidyverse.org"">tidyverse</a></small>
+      </div>
+    </div>
+    <div id=""navbar"" class=""navbar-collapse collapse"">
+      <ul class=""nav navbar-nav navbar-right"">
+        <li>
+  <a href=""reference/index.html"">Reference</a>
+</li>
+<li class=""dropdown"">
+  <a href=""#"" class=""dropdown-toggle"" data-toggle=""dropdown"" role=""button"" aria-expanded=""false"">
+    Articles
+     
+    <span class=""caret""></span>
+  </a>
+  <ul class=""dropdown-menu"" role=""menu"">
+    <li>
+      <a href=""articles/cell-and-column-types.html"">Column Types</a>
+    </li>
+    <li>
+      <a href=""articles/sheet-geometry.html"">Sheet Geometry</a>
+    </li>
+    <li>
+      <a href=""articles/articles/readxl-workflows.html"">Workflows</a>
+    </li>
+  </ul>
+</li>
+<li class=""dropdown"">
+  <a href=""#"" class=""dropdown-toggle"" data-toggle=""dropdown"" role=""button"" aria-expanded=""false"">
+    News
+     
+    <span class=""caret""></span>
+  </a>
+  <ul class=""dropdown-menu"" role=""menu"">
+    <li class=""dropdown-header"">Release notes</li>
+    <li>
+      <a href=""articles/releases/readxl-1.0.0.html"">Version 1.0.0</a>
+    </li>
+    <li>
+      <a href=""articles/releases/readxl-0.1.1.html"">Version 0.1.1</a>
+    </li>
+    <li>
+      <a href=""articles/releases/readxl-0.1.0.html"">Version 0.1.0</a>
+    </li>
+    <li class=""divider""></li>
+    <li>
+      <a href=""news/index.html"">Change log</a>
+    </li>
+  </ul>
+</li>
+        <li>
+  <a href=""https://github.com/tidyverse/readxl"">
+    <span class=""fa fa-github fa-lg""></span>
+     
+  </a>
+</li>
+      </ul>
+    </div><!--/.nav-collapse -->
+  </div><!--/.container -->
+</div><!--/.navbar -->
+
+      
+      </header>
+
+<div class=""row"">
+  <div class=""contents col-md-9"">
+    <div class=""page-header"">
+      <h1>Contributor Code of Conduct</h1>
+    </div>
+
+<div id=""contributor-code-of-conduct"" class=""section level1"">
+
+<p>As contributors and maintainers of this project, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities.</p>
+<p>We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, or religion.</p>
+<p>Examples of unacceptable behavior by participants include the use of sexual language or imagery, derogatory comments or personal attacks, trolling, public or private harassment, insults, or other unprofessional conduct.</p>
+<p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. Project maintainers who do not follow the Code of Conduct may be removed from the project team.</p>
+<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers.</p>
+<p>This Code of Conduct is adapted from the Contributor Covenant (<a href=""http://contributor-covenant.org"" class=""uri"">http://contributor-covenant.org</a>), version 1.0.0, available at <a href=""http://contributor-covenant.org/version/1/0/0/"" class=""uri"">http://contributor-covenant.org/version/1/0/0/</a></p>
+</div>
+
+  </div>
+
+</div>
+
+
+      <footer>
+      <div class=""tidyverse"">
+  <p>readxl is a part of the <strong>tidyverse</strong>, an ecosystem of packages designed with common APIs and a shared philosophy. Learn more at <a href=""http://tidyverse.org"">tidyverse.org</a>.</p>
+</div>
+
+<div class=""author"">
+  <p>Developed by <a href='http://hadley.nz'>Hadley Wickham</a>, Jennifer Bryan, <a href='https://www.rstudio.com'><img src='http://tidyverse.org/rstudio-logo.svg' alt='RStudio' height='24' /></a>.</p>
+  <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
+</div>
+
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script>
+<script>
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
+
+ gtag('config', 'UA-115082821-1');
+</script>
+      </footer>
+   </div>
+
+  
+
+  </body>
+</html>
+

---FILE: docs/CONTRIBUTING.html---
@@ -0,0 +1,193 @@
+<!-- Generated by pkgdown: do not edit by hand -->
+<!DOCTYPE html>
+<html>
+  <head>
+  <meta charset=""utf-8"">
+<meta http-equiv=""X-UA-Compatible"" content=""IE=edge"">
+<meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
+
+<title>Contributing to readxl • readxl</title>
+
+<!-- jquery -->
+<script src=""https://code.jquery.com/jquery-3.1.0.min.js"" integrity=""sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq"" crossorigin=""anonymous""></script>
+
+<!-- Bootstrap -->
+<link href=""tidyverse.css"" rel=""stylesheet"">
+<script src=""https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"" integrity=""sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"" crossorigin=""anonymous""></script>
+
+<!-- Font Awesome icons -->
+<link href=""https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css"" rel=""stylesheet"" integrity=""sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1"" crossorigin=""anonymous"">
+
+<!-- tidyverse -->
+<link href=""pkgdown.css"" rel=""stylesheet"">
+<script src=""jquery.sticky-kit.min.js""></script>
+<script src=""pkgdown.js""></script>
+
+<!-- mathjax -->
+<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
+
+<!--[if lt IE 9]>
+<script src=""https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js""></script>
+<script src=""https://oss.maxcdn.com/respond/1.4.2/respond.min.js""></script>
+<![endif]-->
+  </head>
+
+  <body>
+    <div class=""container template-title-body"">
+      <header>
+      <div class=""navbar navbar-default navbar-fixed-top"" role=""navigation"">
+  <div class=""container"">
+    <div class=""navbar-header"">
+      <button type=""button"" class=""navbar-toggle collapsed"" data-toggle=""collapse"" data-target=""#navbar"">
+        <span class=""icon-bar""></span>
+        <span class=""icon-bar""></span>
+        <span class=""icon-bar""></span>
+      </button>
+
+      <div class=""navbar-brand-container"">
+        <a class=""navbar-brand"" href=""index.html"">readxl</a>
+        <small class=""tidyverse"">part of the <a href=""http://tidyverse.org"">tidyverse</a></small>
+      </div>
+    </div>
+    <div id=""navbar"" class=""navbar-collapse collapse"">
+      <ul class=""nav navbar-nav navbar-right"">
+        <li>
+  <a href=""reference/index.html"">Reference</a>
+</li>
+<li class=""dropdown"">
+  <a href=""#"" class=""dropdown-toggle"" data-toggle=""dropdown"" role=""button"" aria-expanded=""false"">
+    Articles
+     
+    <span class=""caret""></span>
+  </a>
+  <ul class=""dropdown-menu"" role=""menu"">
+    <li>
+      <a href=""articles/cell-and-column-types.html"">Column Types</a>
+    </li>
+    <li>
+      <a href=""articles/sheet-geometry.html"">Sheet Geometry</a>
+    </li>
+    <li>
+      <a href=""articles/articles/readxl-workflows.html"">Workflows</a>
+    </li>
+  </ul>
+</li>
+<li class=""dropdown"">
+  <a href=""#"" class=""dropdown-toggle"" data-toggle=""dropdown"" role=""button"" aria-expanded=""false"">
+    News
+     
+    <span class=""caret""></span>
+  </a>
+  <ul class=""dropdown-menu"" role=""menu"">
+    <li class=""dropdown-header"">Release notes</li>
+    <li>
+      <a href=""articles/releases/readxl-1.0.0.html"">Version 1.0.0</a>
+    </li>
+    <li>
+      <a href=""articles/releases/readxl-0.1.1.html"">Version 0.1.1</a>
+    </li>
+    <li>
+      <a href=""articles/releases/readxl-0.1.0.html"">Version 0.1.0</a>
+    </li>
+    <li class=""divider""></li>
+    <li>
+      <a href=""news/index.html"">Change log</a>
+    </li>
+  </ul>
+</li>
+        <li>
+  <a href=""https://github.com/tidyverse/readxl"">
+    <span class=""fa fa-github fa-lg""></span>
+     
+  </a>
+</li>
+      </ul>
+    </div><!--/.nav-collapse -->
+  </div><!--/.container -->
+</div><!--/.navbar -->
+
+      
+      </header>
+
+<div class=""row"">
+  <div class=""contents col-md-9"">
+    <div class=""page-header"">
+      <h1>Contributing to readxl</h1>
+    </div>
+
+<div id=""contributing-to-readxl"" class=""section level1"">
+
+<p>This outlines how to propose a change to readxl. For more detailed info about contributing to this, and other tidyverse packages, please see the <a href=""https://rstd.io/tidy-contrib""><strong>development contributing guide</strong></a>.</p>
+<div id=""fixing-typos"" class=""section level3"">
+<h3 class=""hasAnchor"">
+<a href=""#fixing-typos"" class=""anchor""></a>Fixing typos</h3>
+<p>Small typos or grammatical errors in documentation may be edited directly using the GitHub web interface, so long as the changes are made in the <em>source</em> file.</p>
+<ul>
+<li>YES: you edit a roxygen comment in a <code>.R</code> file below <code>R/</code>.</li>
+<li>NO: you edit an <code>.Rd</code> file below <code>man/</code>.</li>
+</ul>
+</div>
+<div id=""prerequisites"" class=""section level3"">
+<h3 class=""hasAnchor"">
+<a href=""#prerequisites"" class=""anchor""></a>Prerequisites</h3>
+<p>Before you make a substantial pull request, you should always file an issue and make sure someone from the team agrees that it’s a problem. If you’ve found a bug, create an associated issue and illustrate the bug with a minimal <a href=""https://www.tidyverse.org/help/#reprex"">reprex</a>.</p>
+</div>
+<div id=""pull-request-process"" class=""section level3"">
+<h3 class=""hasAnchor"">
+<a href=""#pull-request-process"" class=""anchor""></a>Pull request process</h3>
+<ul>
+<li>We recommend that you create a Git branch for each pull request (PR).<br>
+</li>
+<li>Look at the Travis and AppVeyor build status before and after making changes. The <code>README</code> should contain badges for any continuous integration services used by the package.<br>
+</li>
+<li>New code should follow the tidyverse <a href=""http://style.tidyverse.org"">style guide</a>. You can use the <a href=""https://CRAN.R-project.org/package=styler"">styler</a> package to apply these styles, but please don’t restyle code that has nothing to do with your PR.<br>
+</li>
+<li>We use <a href=""https://cran.r-project.org/package=roxygen2"">roxygen2</a>, with <a href=""https://cran.r-project.org/web/packages/roxygen2/vignettes/markdown.html"">Markdown syntax</a>, for documentation.<br>
+</li>
+<li>We use <a href=""https://cran.r-project.org/package=testthat"">testthat</a>. Contributions with test cases included are easier to accept.<br>
+</li>
+<li>For user-facing changes, add a bullet to the top of <code>NEWS.md</code> below the current development version header describing the changes made followed by your GitHub username, and links to relevant issue(s)/PR(s).</li>
+</ul>
+</div>
+<div id=""code-of-conduct"" class=""section level3"">
+<h3 class=""hasAnchor"">
+<a href=""#code-of-conduct"" class=""anchor""></a>Code of Conduct</h3>
+<p>Please note that this project is released with a <a href=""CODE_OF_CONDUCT.html"">Contributor Code of Conduct</a>. By participating in this project you agree to abide by its terms.</p>
+</div>
+<div id=""see-tidyverse-development-contributing-guide-for-further-details-"" class=""section level3"">
+<h3 class=""hasAnchor"">
+<a href=""#see-tidyverse-development-contributing-guide-for-further-details-"" class=""anchor""></a>See tidyverse <a href=""https://rstd.io/tidy-contrib"">development contributing guide</a> for further details.</h3>
+</div>
+</div>
+
+  </div>
+
+</div>
+
+
+      <footer>
+      <div class=""tidyverse"">
+  <p>readxl is a part of the <strong>tidyverse</strong>, an ecosystem of packages designed with common APIs and a shared philosophy. Learn more at <a href=""http://tidyverse.org"">tidyverse.org</a>.</p>
+</div>
+
+<div class=""author"">
+  <p>Developed by <a href='http://hadley.nz'>Hadley Wickham</a>, Jennifer Bryan, <a href='https://www.rstudio.com'><img src='http://tidyverse.org/rstudio-logo.svg' alt='RStudio' height='24' /></a>.</p>
+  <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
+</div>
+
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script>
+<script>
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
+
+ gtag('config', 'UA-115082821-1');
+</script>
+      </footer>
+   </div>
+
+  
+
+  </body>
+</html>
+

---FILE: docs/ISSUE_TEMPLATE.html---
@@ -0,0 +1,156 @@
+<!-- Generated by pkgdown: do not edit by hand -->
+<!DOCTYPE html>
+<html>
+  <head>
+  <meta charset=""utf-8"">
+<meta http-equiv=""X-UA-Compatible"" content=""IE=edge"">
+<meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
+
+<title>NA • readxl</title>
+
+<!-- jquery -->
+<script src=""https://code.jquery.com/jquery-3.1.0.min.js"" integrity=""sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq"" crossorigin=""anonymous""></script>
+
+<!-- Bootstrap -->
+<link href=""tidyverse.css"" rel=""stylesheet"">
+<script src=""https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"" integrity=""sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"" crossorigin=""anonymous""></script>
+
+<!-- Font Awesome icons -->
+<link href=""https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css"" rel=""stylesheet"" integrity=""sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1"" crossorigin=""anonymous"">
+
+<!-- tidyverse -->
+<link href=""pkgdown.css"" rel=""stylesheet"">
+<script src=""jquery.sticky-kit.min.js""></script>
+<script src=""pkgdown.js""></script>
+
+<!-- mathjax -->
+<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
+
+<!--[if lt IE 9]>
+<script src=""https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js""></script>
+<script src=""https://oss.maxcdn.com/respond/1.4.2/respond.min.js""></script>
+<![endif]-->
+  </head>
+
+  <body>
+    <div class=""container template-title-body"">
+      <header>
+      <div class=""navbar navbar-default navbar-fixed-top"" role=""navigation"">
+  <div class=""container"">
+    <div class=""navbar-header"">
+      <button type=""button"" class=""navbar-toggle collapsed"" data-toggle=""collapse"" data-target=""#navbar"">
+        <span class=""icon-bar""></span>
+        <span class=""icon-bar""></span>
+        <span class=""icon-bar""></span>
+      </button>
+
+      <div class=""navbar-brand-container"">
+        <a class=""navbar-brand"" href=""index.html"">readxl</a>
+        <small class=""tidyverse"">part of the <a href=""http://tidyverse.org"">tidyverse</a></small>
+      </div>
+    </div>
+    <div id=""navbar"" class=""navbar-collapse collapse"">
+      <ul class=""nav navbar-nav navbar-right"">
+        <li>
+  <a href=""reference/index.html"">Reference</a>
+</li>
+<li class=""dropdown"">
+  <a href=""#"" class=""dropdown-toggle"" data-toggle=""dropdown"" role=""button"" aria-expanded=""false"">
+    Articles
+     
+    <span class=""caret""></span>
+  </a>
+  <ul class=""dropdown-menu"" role=""menu"">
+    <li>
+      <a href=""articles/cell-and-column-types.html"">Column Types</a>
+    </li>
+    <li>
+      <a href=""articles/sheet-geometry.html"">Sheet Geometry</a>
+    </li>
+    <li>
+      <a href=""articles/articles/readxl-workflows.html"">Workflows</a>
+    </li>
+  </ul>
+</li>
+<li class=""dropdown"">
+  <a href=""#"" class=""dropdown-toggle"" data-toggle=""dropdown"" role=""button"" aria-expanded=""false"">
+    News
+     
+    <span class=""caret""></span>
+  </a>
+  <ul class=""dropdown-menu"" role=""menu"">
+    <li class=""dropdown-header"">Release notes</li>
+    <li>
+      <a href=""articles/releases/readxl-1.0.0.html"">Version 1.0.0</a>
+    </li>
+    <li>
+      <a href=""articles/releases/readxl-0.1.1.html"">Version 0.1.1</a>
+    </li>
+    <li>
+      <a href=""articles/releases/readxl-0.1.0.html"">Version 0.1.0</a>
+    </li>
+    <li class=""divider""></li>
+    <li>
+      <a href=""news/index.html"">Change log</a>
+    </li>
+  </ul>
+</li>
+        <li>
+  <a href=""https://github.com/tidyverse/readxl"">
+    <span class=""fa fa-github fa-lg""></span>
+     
+  </a>
+</li>
+      </ul>
+    </div><!--/.nav-collapse -->
+  </div><!--/.container -->
+</div><!--/.navbar -->
+
+      
+      </header>
+
+<div class=""row"">
+  <div class=""contents col-md-9"">
+    <div class=""page-header"">
+      <h1>NA</h1>
+    </div>
+
+
+<p>Please briefly describe your problem and what output you expect. If you have a question, please don’t use this form. Instead, ask on <a href=""https://stackoverflow.com/"" class=""uri"">https://stackoverflow.com/</a> or <a href=""https://community.rstudio.com/"" class=""uri"">https://community.rstudio.com/</a>.</p>
+<p>Please include a minimal reproducible example (AKA a reprex). If you’ve never heard of a <a href=""http://reprex.tidyverse.org/"">reprex</a> before, start by reading <a href=""https://www.tidyverse.org/help/#reprex"" class=""uri"">https://www.tidyverse.org/help/#reprex</a>.</p>
+<hr>
+<p>Brief description of the problem</p>
+<div class=""sourceCode"" id=""cb1""><pre class=""sourceCode r""><code class=""sourceCode r""><a class=""sourceLine"" id=""cb1-1"" data-line-number=""1""><span class=""co""># insert reprex here</span></a></code></pre></div>
+
+
+  </div>
+
+</div>
+
+
+      <footer>
+      <div class=""tidyverse"">
+  <p>readxl is a part of the <strong>tidyverse</strong>, an ecosystem of packages designed with common APIs and a shared philosophy. Learn more at <a href=""http://tidyverse.org"">tidyverse.org</a>.</p>
+</div>
+
+<div class=""author"">
+  <p>Developed by <a href='http://hadley.nz'>Hadley Wickham</a>, Jennifer Bryan, <a href='https://www.rstudio.com'><img src='http://tidyverse.org/rstudio-logo.svg' alt='RStudio' height='24' /></a>.</p>
+  <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
+</div>
+
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script>
+<script>
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
+
+ gtag('config', 'UA-115082821-1');
+</script>
+      </footer>
+   </div>
+
+  
+
+  </body>
+</html>
+

---FILE: docs/SUPPORT.html---
@@ -0,0 +1,165 @@
+<!-- Generated by pkgdown: do not edit by hand -->
+<!DOCTYPE html>
+<html>
+  <head>
+  <meta charset=""utf-8"">
+<meta http-equiv=""X-UA-Compatible"" content=""IE=edge"">
+<meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
+
+<title>Getting help with readxl • readxl</title>
+
+<!-- jquery -->
+<script src=""https://code.jquery.com/jquery-3.1.0.min.js"" integrity=""sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq"" crossorigin=""anonymous""></script>
+
+<!-- Bootstrap -->
+<link href=""tidyverse.css"" rel=""stylesheet"">
+<script src=""https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"" integrity=""sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"" crossorigin=""anonymous""></script>
+
+<!-- Font Awesome icons -->
+<link href=""https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css"" rel=""stylesheet"" integrity=""sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1"" crossorigin=""anonymous"">
+
+<!-- tidyverse -->
+<link href=""pkgdown.css"" rel=""stylesheet"">
+<script src=""jquery.sticky-kit.min.js""></script>
+<script src=""pkgdown.js""></script>
+
+<!-- mathjax -->
+<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
+
+<!--[if lt IE 9]>
+<script src=""https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js""></script>
+<script src=""https://oss.maxcdn.com/respond/1.4.2/respond.min.js""></script>
+<![endif]-->
+  </head>
+
+  <body>
+    <div class=""container template-title-body"">
+      <header>
+      <div class=""navbar navbar-default navbar-fixed-top"" role=""navigation"">
+  <div class=""container"">
+    <div class=""navbar-header"">
+      <button type=""button"" class=""navbar-toggle collapsed"" data-toggle=""collapse"" data-target=""#navbar"">
+        <span class=""icon-bar""></span>
+        <span class=""icon-bar""></span>
+        <span class=""icon-bar""></span>
+      </button>
+
+      <div class=""navbar-brand-container"">
+        <a class=""navbar-brand"" href=""index.html"">readxl</a>
+        <small class=""tidyverse"">part of the <a href=""http://tidyverse.org"">tidyverse</a></small>
+      </div>
+    </div>
+    <div id=""navbar"" class=""navbar-collapse collapse"">
+      <ul class=""nav navbar-nav navbar-right"">
+        <li>
+  <a href=""reference/index.html"">Reference</a>
+</li>
+<li class=""dropdown"">
+  <a href=""#"" class=""dropdown-toggle"" data-toggle=""dropdown"" role=""button"" aria-expanded=""false"">
+    Articles
+     
+    <span class=""caret""></span>
+  </a>
+  <ul class=""dropdown-menu"" role=""menu"">
+    <li>
+      <a href=""articles/cell-and-column-types.html"">Column Types</a>
+    </li>
+    <li>
+      <a href=""articles/sheet-geometry.html"">Sheet Geometry</a>
+    </li>
+    <li>
+      <a href=""articles/articles/readxl-workflows.html"">Workflows</a>
+    </li>
+  </ul>
+</li>
+<li class=""dropdown"">
+  <a href=""#"" class=""dropdown-toggle"" data-toggle=""dropdown"" role=""button"" aria-expanded=""false"">
+    News
+     
+    <span class=""caret""></span>
+  </a>
+  <ul class=""dropdown-menu"" role=""menu"">
+    <li class=""dropdown-header"">Release notes</li>
+    <li>
+      <a href=""articles/releases/readxl-1.0.0.html"">Version 1.0.0</a>
+    </li>
+    <li>
+      <a href=""articles/releases/readxl-0.1.1.html"">Version 0.1.1</a>
+    </li>
+    <li>
+      <a href=""articles/releases/readxl-0.1.0.html"">Version 0.1.0</a>
+    </li>
+    <li class=""divider""></li>
+    <li>
+      <a href=""news/index.html"">Change log</a>
+    </li>
+  </ul>
+</li>
+        <li>
+  <a href=""https://github.com/tidyverse/readxl"">
+    <span class=""fa fa-github fa-lg""></span>
+     
+  </a>
+</li>
+      </ul>
+    </div><!--/.nav-collapse -->
+  </div><!--/.container -->
+</div><!--/.navbar -->
+
+      
+      </header>
+
+<div class=""row"">
+  <div class=""contents col-md-9"">
+    <div class=""page-header"">
+      <h1>Getting help with readxl</h1>
+    </div>
+
+<div id=""getting-help-with-readxl"" class=""section level1"">
+
+<p>Thanks for using readxl. Before filing an issue, there are a few places to explore and pieces to put together to make the process as smooth as possible.</p>
+<p>Start by making a minimal <strong>repr</strong>oducible <strong>ex</strong>ample using the <a href=""http://reprex.tidyverse.org/"">reprex</a> package. If you haven’t heard of or used reprex before, you’re in for a treat! Seriously, reprex will make all of your R-question-asking endeavors easier (which is a pretty insane ROI for the five to ten minutes it’ll take you to learn what it’s all about). For additional reprex pointers, check out the <a href=""https://www.tidyverse.org/help/"">Get help!</a> section of the tidyverse site.</p>
+<p>Armed with your reprex, the next step is to figure out <a href=""https://www.tidyverse.org/help/#where-to-ask"">where to ask</a>.</p>
+<ul>
+<li>If it’s a question: start with <a href=""https://community.rstudio.com/"">community.rstudio.com</a>, and/or StackOverflow. There are more people there to answer questions.<br>
+</li>
+<li>If it’s a bug: you’re in the right place, file an issue.<br>
+</li>
+<li>If you’re not sure: let the community help you figure it out! If your problem <em>is</em> a bug or a feature request, you can easily return here and report it.</li>
+</ul>
+<p>Before opening a new issue, be sure to <a href=""https://github.com/tidyverse/readxl/issues"">search issues and pull requests</a> to make sure the bug hasn’t been reported and/or already fixed in the development version. By default, the search will be pre-populated with <code>is:issue is:open</code>. You can <a href=""https://help.github.com/articles/searching-issues-and-pull-requests/"">edit the qualifiers</a> (e.g. <code>is:pr</code>, <code>is:closed</code>) as needed. For example, you’d simply remove <code>is:open</code> to search <em>all</em> issues in the repo, open or closed.</p>
+<p>If you <em>are</em> in the right place, and need to file an issue, please review the <a href=""https://www.tidyverse.org/contribute/#issues"">“File issues”</a> paragraph from the tidyverse contributing guidelines.</p>
+<p>Thanks for your help!</p>
+</div>
+
+  </div>
+
+</div>
+
+
+      <footer>
+      <div class=""tidyverse"">
+  <p>readxl is a part of the <strong>tidyverse</strong>, an ecosystem of packages designed with common APIs and a shared philosophy. Learn more at <a href=""http://tidyverse.org"">tidyverse.org</a>.</p>
+</div>
+
+<div class=""author"">
+  <p>Developed by <a href='http://hadley.nz'>Hadley Wickham</a>, Jennifer Bryan, <a href='https://www.rstudio.com'><img src='http://tidyverse.org/rstudio-logo.svg' alt='RStudio' height='24' /></a>.</p>
+  <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
+</div>
+
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script>
+<script>
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
+
+ gtag('config', 'UA-115082821-1');
+</script>
+      </footer>
+   </div>
+
+  
+
+  </body>
+</html>
+

---FILE: docs/articles/articles/readxl-workflows.html---
@@ -117,12 +117,12 @@ <h2 class=""hasAnchor"">
 <p>We load the tidyverse metapackage here because the workflows below show readxl working with readr, purrr, etc. See the last section for solutions using base R only (other than readxl).</p>
 <p>We must load readxl explicitly because it is not part of the core tidyverse.</p>
 <div class=""sourceCode"" id=""cb1""><pre class=""sourceCode r""><code class=""sourceCode r""><a class=""sourceLine"" id=""cb1-1"" data-line-number=""1""><span class=""kw"">library</span>(tidyverse)</a>
-<a class=""sourceLine"" id=""cb1-2"" data-line-number=""2""><span class=""co"">#&gt; ── Attaching packages ───────────────────────────────────────── tidyverse 1.2.1 ──</span></a>
+<a class=""sourceLine"" id=""cb1-2"" data-line-number=""2""><span class=""co"">#&gt; ── Attaching packages ─────────────────────────────────────── tidyverse 1.2.1 ──</span></a>
 <a class=""sourceLine"" id=""cb1-3"" data-line-number=""3""><span class=""co"">#&gt; ✔ ggplot2 2.2.1          ✔ purrr   0.2.4.9000</span></a>
 <a class=""sourceLine"" id=""cb1-4"" data-line-number=""4""><span class=""co"">#&gt; ✔ tibble  1.4.2          ✔ dplyr   0.7.4.9000</span></a>
 <a class=""sourceLine"" id=""cb1-5"" data-line-number=""5""><span class=""co"">#&gt; ✔ tidyr   0.8.0          ✔ stringr 1.3.0     </span></a>
 <a class=""sourceLine"" id=""cb1-6"" data-line-number=""6""><span class=""co"">#&gt; ✔ readr   1.1.1.9000     ✔ forcats 0.3.0</span></a>
-<a class=""sourceLine"" id=""cb1-7"" data-line-number=""7""><span class=""co"">#&gt; ── Conflicts ──────────────────────────────────────────── tidyverse_conflicts() ──</span></a>
+<a class=""sourceLine"" id=""cb1-7"" data-line-number=""7""><span class=""co"">#&gt; ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──</span></a>
 <a class=""sourceLine"" id=""cb1-8"" data-line-number=""8""><span class=""co"">#&gt; ✖ dplyr::filter() masks stats::filter()</span></a>
 <a class=""sourceLine"" id=""cb1-9"" data-line-number=""9""><span class=""co"">#&gt; ✖ dplyr::lag()    masks stats::lag()</span></a>
 <a class=""sourceLine"" id=""cb1-10"" data-line-number=""10""><span class=""kw"">library</span>(readxl)</a></code></pre></div>
@@ -389,7 +389,7 @@ <h2 class=""hasAnchor"">
 #>  language (EN)                        
 #>  collate  en_CA.UTF-8                 
 #>  tz       America/Vancouver           
-#>  date     2018-04-14                  
+#>  date     2018-04-15                  
 #> 
 #> ─ Packages ──────────────────────────────────────────────────────────────
 #>  package     * version     date       source                             
@@ -447,7 +447,7 @@ <h2 class=""hasAnchor"">
 #>  R6            2.2.2       2017-06-17 CRAN (R 3.4.0)                     
 #>  Rcpp          0.12.16     2018-03-13 CRAN (R 3.4.4)                     
 #>  readr       * 1.1.1.9000  2017-12-12 Github (tidyverse/readr@ba7edb5)   
-#>  readxl      * 1.0.0.9000  2018-04-14 local                              
+#>  readxl      * 1.0.0.9000  2018-04-15 local                              
 #>  rematch       1.0.1       2016-04-21 CRAN (R 3.4.0)                     
 #>  reshape2      1.4.3       2017-12-11 CRAN (R 3.4.3)                     
 #>  rlang         0.2.0.9001  2018-04-02 Github (tidyverse/rlang@49d7a34)   
@@ -571,14 +571,12 @@ <h2 class=""hasAnchor"">
   <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
 </div>
 
-<script>
-  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
-  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
-  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
-  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script><script>
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
 
-  ga('create', 'UA-67989-18', 'auto');
-  ga('send', 'pageview');
+ gtag('config', 'UA-115082821-1');
 </script></footer>
 </div>
 

---FILE: docs/articles/cell-and-column-types.html---
@@ -26,7 +26,7 @@
       </button>
 
       <div class=""navbar-brand-container"">
-        <a class=""navbar-brand"" href=""../index.html""></a>
+        <a class=""navbar-brand"" href=""../index.html"">readxl</a>
         <small class=""tidyverse"">part of the <a href=""http://tidyverse.org"">tidyverse</a></small>
       </div>
     </div>
@@ -436,14 +436,12 @@ <h2 class=""hasAnchor"">
   <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
 </div>
 
-<script>
-  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
-  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
-  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
-  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script><script>
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
 
-  ga('create', 'UA-67989-18', 'auto');
-  ga('send', 'pageview');
+ gtag('config', 'UA-115082821-1');
 </script></footer>
 </div>
 

---FILE: docs/articles/index.html---
@@ -141,14 +141,13 @@ <h3>All vignettes</h3>
   <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
 </div>
 
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script>
 <script>
-  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
-  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
-  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
-  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
 
-  ga('create', 'UA-67989-18', 'auto');
-  ga('send', 'pageview');
+ gtag('config', 'UA-115082821-1');
 </script>
       </footer>
    </div>

---FILE: docs/articles/releases/readxl-0.1.0.html---
@@ -161,14 +161,12 @@ <h1>readxl v0.1.0</h1>
   <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
 </div>
 
-<script>
-  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
-  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
-  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
-  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script><script>
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
 
-  ga('create', 'UA-67989-18', 'auto');
-  ga('send', 'pageview');
+ gtag('config', 'UA-115082821-1');
 </script></footer>
 </div>
 

---FILE: docs/articles/releases/readxl-0.1.1.html---
@@ -126,14 +126,12 @@ <h1>readxl v0.1.1</h1>
   <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
 </div>
 
-<script>
-  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
-  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
-  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
-  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script><script>
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
 
-  ga('create', 'UA-67989-18', 'auto');
-  ga('send', 'pageview');
+ gtag('config', 'UA-115082821-1');
 </script></footer>
 </div>
 

---FILE: docs/articles/releases/readxl-1.0.0.html---
@@ -235,14 +235,12 @@ <h2 class=""hasAnchor"">
   <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
 </div>
 
-<script>
-  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
-  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
-  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
-  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script><script>
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
 
-  ga('create', 'UA-67989-18', 'auto');
-  ga('send', 'pageview');
+ gtag('config', 'UA-115082821-1');
 </script></footer>
 </div>
 

---FILE: docs/articles/sheet-geometry.html---
@@ -304,14 +304,12 @@ <h2 class=""hasAnchor"">
   <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
 </div>
 
-<script>
-  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
-  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
-  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
-  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script><script>
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
 
-  ga('create', 'UA-67989-18', 'auto');
-  ga('send', 'pageview');
+ gtag('config', 'UA-115082821-1');
 </script></footer>
 </div>
 

---FILE: docs/authors.html---
@@ -170,14 +170,13 @@ <h1>Authors</h1>
   <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
 </div>
 
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script>
 <script>
-  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
-  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
-  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
-  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
 
-  ga('create', 'UA-67989-18', 'auto');
-  ga('send', 'pageview');
+ gtag('config', 'UA-115082821-1');
 </script>
       </footer>
    </div>

---FILE: docs/index.html---
@@ -249,7 +249,9 @@ <h2 class=""hasAnchor"">
 <p><strong>Writing Excel files</strong>: The example files <code>datasets.xlsx</code> and <code>datasets.xls</code> were created with the help of <a href=""https://CRAN.R-project.org/package=openxlsx"">openxlsx</a> (and Excel). openxlsx provides “a high level interface to writing, styling and editing worksheets”.</p>
 <div class=""sourceCode"" id=""cb11""><pre class=""sourceCode r""><code class=""sourceCode r""><a class=""sourceLine"" id=""cb11-1"" data-line-number=""1"">l &lt;-<span class=""st""> </span><span class=""kw"">list</span>(<span class=""dt"">iris =</span> iris, <span class=""dt"">mtcars =</span> mtcars, <span class=""dt"">chickwts =</span> chickwts, <span class=""dt"">quakes =</span> quakes)</a>
 <a class=""sourceLine"" id=""cb11-2"" data-line-number=""2"">openxlsx<span class=""op"">::</span><span class=""kw""><a href=""http://www.rdocumentation.org/packages/openxlsx/topics/write.xlsx"">write.xlsx</a></span>(l, <span class=""dt"">file =</span> <span class=""st"">""inst/extdata/datasets.xlsx""</span>)</a></code></pre></div>
+<p><a href=""https://cran.r-project.org/web/packages/writexl/index.html"">writexl</a> is a new option in this space, first released on CRAN in August 2017. It’s a portable and lightweight way to export a data frame to xlsx, based on <a href=""https://github.com/jmcnamara/libxlsxwriter"">libxlsxwriter</a>. It is much more minimalistic than openxlsx, but on simple examples, appears to be about twice as fast and to write smaller files.</p>
 <p><strong>Non-tabular data and formatting</strong>: <a href=""https://cran.r-project.org/package=tidyxl"">tidyxl</a> is focused on importing awkward and non-tabular data from Excel. It also “exposes cell content, position and formatting in a tidy structure for further manipulation”.</p>
+<p>Please note that this project is released with a <a href="".github/CODE_OF_CONDUCT.html"">Contributor Code of Conduct</a>. By participating in this project you agree to abide by its terms.</p>
 </div>
 </div>
   </div>
@@ -296,6 +298,7 @@ <h2>Dev status</h2>
 <li><a href=""https://ci.appveyor.com/project/tidyverse/readxl""><img src=""https://ci.appveyor.com/api/projects/status/github/tidyverse/readxl?branch=master&amp;svg=true"" alt=""AppVeyor Build Status""></a></li>
 <li><a href=""https://codecov.io/github/tidyverse/readxl?branch=master""><img src=""https://img.shields.io/codecov/c/github/tidyverse/readxl/master.svg"" alt=""Coverage Status""></a></li>
 <li><a href=""https://cran.r-project.org/package=readxl""><img src=""https://www.r-pkg.org/badges/version/readxl"" alt=""CRAN_Status_Badge""></a></li>
+<li><a href=""https://www.tidyverse.org/lifecycle/#stable""><img src=""https://img.shields.io/badge/lifecycle-stable-brightgreen.svg"" alt=""lifecycle""></a></li>
 </ul>
 </div>
 </div>
@@ -312,14 +315,12 @@ <h2>Dev status</h2>
   <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
 </div>
 
-<script>
-  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
-  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
-  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
-  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script><script>
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
 
-  ga('create', 'UA-67989-18', 'auto');
-  ga('send', 'pageview');
+ gtag('config', 'UA-115082821-1');
 </script></footer>
 </div>
 

---FILE: docs/news/index.html---
@@ -247,14 +247,13 @@ <h2>Contents</h2>
   <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
 </div>
 
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script>
 <script>
-  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
-  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
-  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
-  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
 
-  ga('create', 'UA-67989-18', 'auto');
-  ga('send', 'pageview');
+ gtag('config', 'UA-115082821-1');
 </script>
       </footer>
    </div>

---FILE: docs/pkgdown.css---
@@ -234,3 +234,10 @@ a.anchor {
   background-color: transparent;
   text-decoration: underline;
 }
+
+/* orcid ------------------------------------ */
+
+.orcid {
+  height: 16px;
+  vertical-align: middle;
+}

---FILE: docs/reference/cell-specification.html---
@@ -252,14 +252,13 @@ <h2>Contents</h2>
   <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
 </div>
 
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script>
 <script>
-  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
-  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
-  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
-  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
 
-  ga('create', 'UA-67989-18', 'auto');
-  ga('send', 'pageview');
+ gtag('config', 'UA-115082821-1');
 </script>
       </footer>
    </div>

---FILE: docs/reference/excel_format.html---
@@ -0,0 +1,192 @@
+<!-- Generated by pkgdown: do not edit by hand -->
+<!DOCTYPE html>
+<html>
+  <head>
+  <meta charset=""utf-8"">
+<meta http-equiv=""X-UA-Compatible"" content=""IE=edge"">
+<meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
+
+<title>Determine file format — excel_format • readxl</title>
+
+<!-- jquery -->
+<script src=""https://code.jquery.com/jquery-3.1.0.min.js"" integrity=""sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq"" crossorigin=""anonymous""></script>
+
+<!-- Bootstrap -->
+<link href=""../tidyverse.css"" rel=""stylesheet"">
+<script src=""https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"" integrity=""sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"" crossorigin=""anonymous""></script>
+
+<!-- Font Awesome icons -->
+<link href=""https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css"" rel=""stylesheet"" integrity=""sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1"" crossorigin=""anonymous"">
+
+<!-- tidyverse -->
+<link href=""../pkgdown.css"" rel=""stylesheet"">
+<script src=""../jquery.sticky-kit.min.js""></script>
+<script src=""../pkgdown.js""></script>
+
+<!-- mathjax -->
+<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
+
+<!--[if lt IE 9]>
+<script src=""https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js""></script>
+<script src=""https://oss.maxcdn.com/respond/1.4.2/respond.min.js""></script>
+<![endif]-->
+  </head>
+
+  <body>
+    <div class=""container template-reference-topic"">
+      <header>
+      <div class=""navbar navbar-default navbar-fixed-top"" role=""navigation"">
+  <div class=""container"">
+    <div class=""navbar-header"">
+      <button type=""button"" class=""navbar-toggle collapsed"" data-toggle=""collapse"" data-target=""#navbar"">
+        <span class=""icon-bar""></span>
+        <span class=""icon-bar""></span>
+        <span class=""icon-bar""></span>
+      </button>
+
+      <div class=""navbar-brand-container"">
+        <a class=""navbar-brand"" href=""../index.html"">readxl</a>
+        <small class=""tidyverse"">part of the <a href=""http://tidyverse.org"">tidyverse</a></small>
+      </div>
+    </div>
+    <div id=""navbar"" class=""navbar-collapse collapse"">
+      <ul class=""nav navbar-nav navbar-right"">
+        <li>
+  <a href=""../reference/index.html"">Reference</a>
+</li>
+<li class=""dropdown"">
+  <a href=""#"" class=""dropdown-toggle"" data-toggle=""dropdown"" role=""button"" aria-expanded=""false"">
+    Articles
+     
+    <span class=""caret""></span>
+  </a>
+  <ul class=""dropdown-menu"" role=""menu"">
+    <li>
+      <a href=""../articles/cell-and-column-types.html"">Column Types</a>
+    </li>
+    <li>
+      <a href=""../articles/sheet-geometry.html"">Sheet Geometry</a>
+    </li>
+    <li>
+      <a href=""../articles/articles/readxl-workflows.html"">Workflows</a>
+    </li>
+  </ul>
+</li>
+<li class=""dropdown"">
+  <a href=""#"" class=""dropdown-toggle"" data-toggle=""dropdown"" role=""button"" aria-expanded=""false"">
+    News
+     
+    <span class=""caret""></span>
+  </a>
+  <ul class=""dropdown-menu"" role=""menu"">
+    <li class=""dropdown-header"">Release notes</li>
+    <li>
+      <a href=""../articles/releases/readxl-1.0.0.html"">Version 1.0.0</a>
+    </li>
+    <li>
+      <a href=""../articles/releases/readxl-0.1.1.html"">Version 0.1.1</a>
+    </li>
+    <li>
+      <a href=""../articles/releases/readxl-0.1.0.html"">Version 0.1.0</a>
+    </li>
+    <li class=""divider""></li>
+    <li>
+      <a href=""../news/index.html"">Change log</a>
+    </li>
+  </ul>
+</li>
+        <li>
+  <a href=""https://github.com/tidyverse/readxl"">
+    <span class=""fa fa-github fa-lg""></span>
+     
+  </a>
+</li>
+      </ul>
+    </div><!--/.nav-collapse -->
+  </div><!--/.container -->
+</div><!--/.navbar -->
+
+      
+      </header>
+
+<div class=""row"">
+  <div class=""col-md-9 contents"">
+    <div class=""page-header"">
+    <h1>Determine file format</h1>
+    <small>Source: <a href='https://github.com/tidyverse/readxl/blob/master/R/excel-format.R'><code>R/excel-format.R</code></a></small>
+    <div class=""hidden name""><code>excel_format.Rd</code></div>
+    </div>
+
+    <p>Determine if files are xlsx or xls. First the file extension is consulted. If
+that is unsuccessful and <code>guess = TRUE</code> and the file exists, the format is
+guessed from the <a href='https://en.wikipedia.org/wiki/List_of_file_signatures'>file signature</a> or ""magic
+number"".</p>
+
+    <pre class=""usage""><span class='fu'>excel_format</span>(<span class='no'>path</span>, <span class='kw'>guess</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)</pre>
+
+    <h2 class=""hasAnchor"" id=""arguments""><a class=""anchor"" href=""#arguments""></a>Arguments</h2>
+    <table class=""ref-arguments"">
+    <colgroup><col class=""name"" /><col class=""desc"" /></colgroup>
+    <tr>
+      <th>path</th>
+      <td><p>Path to the xls/xlsx file</p></td>
+    </tr>
+    <tr>
+      <th>guess</th>
+      <td><p>Logical. Whether to guess format based on the file itself, if
+the extension is neither <code>""xlsx""</code> nor <code>""xls""</code>.</p></td>
+    </tr>
+    </table>
+
+    <h2 class=""hasAnchor"" id=""value""><a class=""anchor"" href=""#value""></a>Value</h2>
+
+    <p>Character vector with values <code>""xlsx""</code>, <code>""xls""</code>, or <code>NA</code>.</p>
+
+    <h2 class=""hasAnchor"" id=""examples""><a class=""anchor"" href=""#examples""></a>Examples</h2>
+    <pre class=""examples""><div class='input'><span class='no'>files</span> <span class='kw'>&lt;-</span> <span class='fu'>c</span>(
+  <span class='st'>""a.xlsx""</span>,
+  <span class='st'>""b.xls""</span>,
+  <span class='st'>""c.png""</span>,
+  <span class='fu'>file.path</span>(<span class='fu'>R.home</span>(<span class='st'>""doc""</span>), <span class='st'>""html""</span>, <span class='st'>""logo.jpg""</span>),
+  <span class='fu'><a href='readxl_example.html'>readxl_example</a></span>(<span class='st'>""clippy.xlsx""</span>),
+  <span class='fu'><a href='readxl_example.html'>readxl_example</a></span>(<span class='st'>""deaths.xls""</span>)
+)
+<span class='fu'>excel_format</span>(<span class='no'>files</span>)</div><div class='output co'>#&gt; [1] ""xlsx"" ""xls""  NA     NA     ""xlsx"" ""xls"" </div></pre>
+  </div>
+  <div class=""col-md-3 hidden-xs hidden-sm"" id=""sidebar"">
+    <h2>Contents</h2>
+    <ul class=""nav nav-pills nav-stacked"">
+      <li><a href=""#arguments"">Arguments</a></li>
+      <li><a href=""#value"">Value</a></li>
+      <li><a href=""#examples"">Examples</a></li>
+    </ul>
+
+  </div>
+</div>
+
+      <footer>
+      <div class=""tidyverse"">
+  <p>readxl is a part of the <strong>tidyverse</strong>, an ecosystem of packages designed with common APIs and a shared philosophy. Learn more at <a href=""http://tidyverse.org"">tidyverse.org</a>.</p>
+</div>
+
+<div class=""author"">
+  <p>Developed by <a href='http://hadley.nz'>Hadley Wickham</a>, Jennifer Bryan, <a href='https://www.rstudio.com'><img src='http://tidyverse.org/rstudio-logo.svg' alt='RStudio' height='24' /></a>.</p>
+  <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
+</div>
+
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script>
+<script>
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
+
+ gtag('config', 'UA-115082821-1');
+</script>
+      </footer>
+   </div>
+
+  
+
+  </body>
+</html>
+

---FILE: docs/reference/excel_sheets.html---
@@ -6,7 +6,7 @@
 <meta http-equiv=""X-UA-Compatible"" content=""IE=edge"">
 <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
 
-<title>List all sheets in an excel spreadsheet. — excel_sheets • readxl</title>
+<title>List all sheets in an excel spreadsheet — excel_sheets • readxl</title>
 
 <!-- jquery -->
 <script src=""https://code.jquery.com/jquery-3.1.0.min.js"" integrity=""sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq"" crossorigin=""anonymous""></script>
@@ -112,12 +112,12 @@
 <div class=""row"">
   <div class=""col-md-9 contents"">
     <div class=""page-header"">
-    <h1>List all sheets in an excel spreadsheet.</h1>
+    <h1>List all sheets in an excel spreadsheet</h1>
     <small>Source: <a href='https://github.com/tidyverse/readxl/blob/master/R/excel-sheets.R'><code>R/excel-sheets.R</code></a></small>
     <div class=""hidden name""><code>excel_sheets.Rd</code></div>
     </div>
 
-    <p>List all sheets in an excel spreadsheet.</p>
+    <p>List all sheets in an excel spreadsheet</p>
 
     <pre class=""usage""><span class='fu'>excel_sheets</span>(<span class='no'>path</span>)</pre>
 
@@ -220,14 +220,13 @@ <h2>Contents</h2>
   <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
 </div>
 
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script>
 <script>
-  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
-  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
-  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
-  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
 
-  ga('create', 'UA-67989-18', 'auto');
-  ga('send', 'pageview');
+ gtag('config', 'UA-115082821-1');
 </script>
       </footer>
    </div>

---FILE: docs/reference/index.html---
@@ -134,7 +134,7 @@ <h2 id=""section-read-spreadsheets"" class=""hasAnchor""><a href=""#section-read-spre
         <td>
           <p><code><a href=""read_excel.html"">read_excel()</a></code> <code><a href=""read_excel.html"">read_xls()</a></code> <code><a href=""read_excel.html"">read_xlsx()</a></code> </p>
         </td>
-        <td><p>Read xls and xlsx files.</p></td>
+        <td><p>Read xls and xlsx files</p></td>
       </tr>
     </tbody><tbody>
       <tr>
@@ -148,7 +148,7 @@ <h2 id=""section-get-spreadsheet-metadata"" class=""hasAnchor""><a href=""#section-ge
         <td>
           <p><code><a href=""excel_sheets.html"">excel_sheets()</a></code> </p>
         </td>
-        <td><p>List all sheets in an excel spreadsheet.</p></td>
+        <td><p>List all sheets in an excel spreadsheet</p></td>
       </tr>
     </tbody><tbody>
       <tr>
@@ -203,14 +203,13 @@ <h2>Contents</h2>
   <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
 </div>
 
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script>
 <script>
-  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
-  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
-  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
-  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
 
-  ga('create', 'UA-67989-18', 'auto');
-  ga('send', 'pageview');
+ gtag('config', 'UA-115082821-1');
 </script>
       </footer>
    </div>

---FILE: docs/reference/read_excel.html---
@@ -6,7 +6,7 @@
 <meta http-equiv=""X-UA-Compatible"" content=""IE=edge"">
 <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
 
-<title>Read xls and xlsx files. — read_excel • readxl</title>
+<title>Read xls and xlsx files — read_excel • readxl</title>
 
 <!-- jquery -->
 <script src=""https://code.jquery.com/jquery-3.1.0.min.js"" integrity=""sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq"" crossorigin=""anonymous""></script>
@@ -112,12 +112,12 @@
 <div class=""row"">
   <div class=""col-md-9 contents"">
     <div class=""page-header"">
-    <h1>Read xls and xlsx files.</h1>
+    <h1>Read xls and xlsx files</h1>
     <small>Source: <a href='https://github.com/tidyverse/readxl/blob/master/R/read_excel.R'><code>R/read_excel.R</code></a></small>
     <div class=""hidden name""><code>read_excel.Rd</code></div>
     </div>
 
-    <p>Read xls and xlsx files.</p>
+    <p>Read xls and xlsx files</p>
 <p><code>read_excel()</code> tries to determine format from the file extension and the file
 itself, in that order. Use <code>read_xls()</code> and <code>read_xlsx()</code> directly to
 eliminate the guessing.</p>
@@ -404,14 +404,13 @@ <h2>Contents</h2>
   <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
 </div>
 
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script>
 <script>
-  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
-  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
-  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
-  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
 
-  ga('create', 'UA-67989-18', 'auto');
-  ga('send', 'pageview');
+ gtag('config', 'UA-115082821-1');
 </script>
       </footer>
    </div>

---FILE: docs/reference/readxl-package.html---
@@ -174,14 +174,13 @@ <h2>Author</h2>
   <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
 </div>
 
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script>
 <script>
-  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
-  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
-  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
-  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
 
-  ga('create', 'UA-67989-18', 'auto');
-  ga('send', 'pageview');
+ gtag('config', 'UA-115082821-1');
 </script>
       </footer>
    </div>

---FILE: docs/reference/readxl_example.html---
@@ -157,14 +157,13 @@ <h2>Contents</h2>
   <p>Site built by <a href=""http://pkgdown.r-lib.org"">pkgdown</a>.</p>
 </div>
 
+<script async src=""https://www.googletagmanager.com/gtag/js?id=UA-115082821-1""></script>
 <script>
-  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
-  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
-  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
-  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
+ window.dataLayer = window.dataLayer || [];
+ function gtag(){dataLayer.push(arguments);}
+ gtag('js', new Date());
 
-  ga('create', 'UA-67989-18', 'auto');
-  ga('send', 'pageview');
+ gtag('config', 'UA-115082821-1');
 </script>
       </footer>
    </div>",False,False,Documentation / Formatting,4
tidyverse,readxl,928f54335cd696f463a3a71e4974cab9ab05eaf5,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-15T03:07:47Z,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-15T03:07:47Z,"Add writexl to README

Fixes #446",README.Rmd;README.md,True,False,True,False,9,0,9,"---FILE: README.Rmd---
@@ -138,6 +138,8 @@ l <- list(iris = iris, mtcars = mtcars, chickwts = chickwts, quakes = quakes)
 openxlsx::write.xlsx(l, file = ""inst/extdata/datasets.xlsx"")
 ```
 
+[writexl](https://cran.r-project.org/web/packages/writexl/index.html) is a new option in this space, first released on CRAN in August 2017. It's a portable and lightweight way to export a data frame to xlsx, based on [libxlsxwriter](https://github.com/jmcnamara/libxlsxwriter). It is much more minimalistic than openxlsx, but on simple examples, appears to be about twice as fast and to write smaller files.
+
 __Non-tabular data and formatting__: [tidyxl](https://cran.r-project.org/package=tidyxl) is focused on importing awkward and non-tabular data from Excel. It also ""exposes cell content, position and formatting in a tidy structure for further manipulation"".
 
 Please note that this project is released with a [Contributor Code of Conduct](.github/CODE_OF_CONDUCT.md). By participating in this project you agree to abide by its terms.

---FILE: README.md---
@@ -232,6 +232,13 @@ l <- list(iris = iris, mtcars = mtcars, chickwts = chickwts, quakes = quakes)
 openxlsx::write.xlsx(l, file = ""inst/extdata/datasets.xlsx"")
 ```
 
+[writexl](https://cran.r-project.org/web/packages/writexl/index.html) is
+a new option in this space, first released on CRAN in August 2017. It’s
+a portable and lightweight way to export a data frame to xlsx, based on
+[libxlsxwriter](https://github.com/jmcnamara/libxlsxwriter). It is much
+more minimalistic than openxlsx, but on simple examples, appears to be
+about twice as fast and to write smaller files.
+
 **Non-tabular data and formatting**:
 [tidyxl](https://cran.r-project.org/package=tidyxl) is focused on
 importing awkward and non-tabular data from Excel. It also “exposes cell",False,True,Documentation / Formatting,7
tidyverse,readxl,e3c4f94fe095a1ec0679c26207deda933e45cb1f,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-15T02:45:07Z,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-15T02:45:07Z,"use_tidy_github()

Fixes #448",.Rbuildignore;.github/CODE_OF_CONDUCT.md;.github/CONTRIBUTING.md;.github/ISSUE_TEMPLATE.md;.github/SUPPORT.md;README.Rmd;README.md,True,False,True,False,125,0,125,"---FILE: .Rbuildignore---
@@ -24,3 +24,4 @@
 ^talks$
 ^scratch\.R$
 ^src/fprintf-substitution\.R$
+^\.github$

---FILE: .github/CODE_OF_CONDUCT.md---
@@ -0,0 +1,25 @@
+# Contributor Code of Conduct
+
+As contributors and maintainers of this project, we pledge to respect all people who 
+contribute through reporting issues, posting feature requests, updating documentation,
+submitting pull requests or patches, and other activities.
+
+We are committed to making participation in this project a harassment-free experience for
+everyone, regardless of level of experience, gender, gender identity and expression,
+sexual orientation, disability, personal appearance, body size, race, ethnicity, age, or religion.
+
+Examples of unacceptable behavior by participants include the use of sexual language or
+imagery, derogatory comments or personal attacks, trolling, public or private harassment,
+insults, or other unprofessional conduct.
+
+Project maintainers have the right and responsibility to remove, edit, or reject comments,
+commits, code, wiki edits, issues, and other contributions that are not aligned to this 
+Code of Conduct. Project maintainers who do not follow the Code of Conduct may be removed 
+from the project team.
+
+Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by 
+opening an issue or contacting one or more of the project maintainers.
+
+This Code of Conduct is adapted from the Contributor Covenant 
+(http://contributor-covenant.org), version 1.0.0, available at 
+http://contributor-covenant.org/version/1/0/0/

---FILE: .github/CONTRIBUTING.md---
@@ -0,0 +1,47 @@
+# Contributing to readxl
+
+This outlines how to propose a change to readxl. For more detailed
+info about contributing to this, and other tidyverse packages, please see the
+[**development contributing guide**](https://rstd.io/tidy-contrib).
+
+### Fixing typos
+
+Small typos or grammatical errors in documentation may be edited directly using
+the GitHub web interface, so long as the changes are made in the _source_ file.
+
+*  YES: you edit a roxygen comment in a `.R` file below `R/`.
+*  NO: you edit an `.Rd` file below `man/`.
+
+### Prerequisites
+
+Before you make a substantial pull request, you should always file an issue and
+make sure someone from the team agrees that it’s a problem. If you’ve found a
+bug, create an associated issue and illustrate the bug with a minimal 
+[reprex](https://www.tidyverse.org/help/#reprex).
+
+### Pull request process
+
+*  We recommend that you create a Git branch for each pull request (PR).  
+*  Look at the Travis and AppVeyor build status before and after making changes.
+The `README` should contain badges for any continuous integration services used
+by the package.  
+*  New code should follow the tidyverse [style guide](http://style.tidyverse.org).
+You can use the [styler](https://CRAN.R-project.org/package=styler) package to
+apply these styles, but please don't restyle code that has nothing to do with 
+your PR.  
+*  We use [roxygen2](https://cran.r-project.org/package=roxygen2), with
+[Markdown syntax](https://cran.r-project.org/web/packages/roxygen2/vignettes/markdown.html), 
+for documentation.  
+*  We use [testthat](https://cran.r-project.org/package=testthat). Contributions
+with test cases included are easier to accept.  
+*  For user-facing changes, add a bullet to the top of `NEWS.md` below the current
+development version header describing the changes made followed by your GitHub
+username, and links to relevant issue(s)/PR(s).
+
+### Code of Conduct
+
+Please note that this project is released with a [Contributor Code of
+Conduct](CODE_OF_CONDUCT.md). By participating in this project you agree to
+abide by its terms.
+
+### See tidyverse [development contributing guide](https://rstd.io/tidy-contrib) for further details.

---FILE: .github/ISSUE_TEMPLATE.md---
@@ -0,0 +1,11 @@
+Please briefly describe your problem and what output you expect. If you have a question, please don't use this form. Instead, ask on <https://stackoverflow.com/> or <https://community.rstudio.com/>.
+
+Please include a minimal reproducible example (AKA a reprex). If you've never heard of a [reprex](http://reprex.tidyverse.org/) before, start by reading <https://www.tidyverse.org/help/#reprex>.
+
+---
+
+Brief description of the problem
+
+```r
+# insert reprex here
+```

---FILE: .github/SUPPORT.md---
@@ -0,0 +1,35 @@
+# Getting help with readxl
+
+Thanks for using readxl. Before filing an issue, there are a few places
+to explore and pieces to put together to make the process as smooth as possible.
+
+Start by making a minimal **repr**oducible **ex**ample using the 
+[reprex](http://reprex.tidyverse.org/) package. If you haven't heard of or used 
+reprex before, you're in for a treat! Seriously, reprex will make all of your 
+R-question-asking endeavors easier (which is a pretty insane ROI for the five to 
+ten minutes it'll take you to learn what it's all about). For additional reprex
+pointers, check out the [Get help!](https://www.tidyverse.org/help/) section of
+the tidyverse site.
+
+Armed with your reprex, the next step is to figure out [where to ask](https://www.tidyverse.org/help/#where-to-ask). 
+
+  * If it's a question: start with [community.rstudio.com](https://community.rstudio.com/), 
+    and/or StackOverflow. There are more people there to answer questions.  
+  * If it's a bug: you're in the right place, file an issue.  
+  * If you're not sure: let the community help you figure it out! If your 
+    problem _is_ a bug or a feature request, you can easily return here and 
+    report it. 
+
+Before opening a new issue, be sure to [search issues and pull requests](https://github.com/tidyverse/readxl/issues) to make sure the 
+bug hasn't been reported and/or already fixed in the development version. By 
+default, the search will be pre-populated with `is:issue is:open`. You can 
+[edit the qualifiers](https://help.github.com/articles/searching-issues-and-pull-requests/) 
+(e.g. `is:pr`, `is:closed`) as needed. For example, you'd simply
+remove `is:open` to search _all_ issues in the repo, open or closed.
+
+
+If you _are_ in the right place, and need to file an issue, please review the 
+[""File issues""](https://www.tidyverse.org/contribute/#issues) paragraph from 
+the tidyverse contributing guidelines.
+
+Thanks for your help!

---FILE: README.Rmd---
@@ -139,3 +139,5 @@ openxlsx::write.xlsx(l, file = ""inst/extdata/datasets.xlsx"")
 ```
 
 __Non-tabular data and formatting__: [tidyxl](https://cran.r-project.org/package=tidyxl) is focused on importing awkward and non-tabular data from Excel. It also ""exposes cell content, position and formatting in a tidy structure for further manipulation"".
+
+Please note that this project is released with a [Contributor Code of Conduct](.github/CODE_OF_CONDUCT.md). By participating in this project you agree to abide by its terms.

---FILE: README.md---
@@ -237,3 +237,7 @@ openxlsx::write.xlsx(l, file = ""inst/extdata/datasets.xlsx"")
 importing awkward and non-tabular data from Excel. It also “exposes cell
 content, position and formatting in a tidy structure for further
 manipulation”.
+
+Please note that this project is released with a [Contributor Code of
+Conduct](.github/CODE_OF_CONDUCT.md). By participating in this project
+you agree to abide by its terms.",False,True,Documentation / Formatting,6
tidyverse,readxl,04c76419e3793e3173c01bffacc799e6d92b3273,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-15T02:42:26Z,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-15T02:42:26Z,"Add 'stable' lifecycle badge

Fixes #447",README.Rmd;README.md,True,False,True,False,2,0,2,"---FILE: README.Rmd---
@@ -15,6 +15,7 @@ knitr::opts_chunk$set(
 # readxl <img src=""tools/logo.png"" align=""right"" />
 
 [![Travis-CI Build Status](https://travis-ci.org/tidyverse/readxl.svg?branch=master)](https://travis-ci.org/tidyverse/readxl) [![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/tidyverse/readxl?branch=master&svg=true)](https://ci.appveyor.com/project/tidyverse/readxl) [![Coverage Status](https://img.shields.io/codecov/c/github/tidyverse/readxl/master.svg)](https://codecov.io/github/tidyverse/readxl?branch=master) [![CRAN_Status_Badge](https://www.r-pkg.org/badges/version/readxl)](https://cran.r-project.org/package=readxl)
+[![lifecycle](https://img.shields.io/badge/lifecycle-stable-brightgreen.svg)](https://www.tidyverse.org/lifecycle/#stable)
 
 ## Overview
 

---FILE: README.md---
@@ -10,6 +10,7 @@ Status](https://ci.appveyor.com/api/projects/status/github/tidyverse/readxl?bran
 [![Coverage
 Status](https://img.shields.io/codecov/c/github/tidyverse/readxl/master.svg)](https://codecov.io/github/tidyverse/readxl?branch=master)
 [![CRAN\_Status\_Badge](https://www.r-pkg.org/badges/version/readxl)](https://cran.r-project.org/package=readxl)
+[![lifecycle](https://img.shields.io/badge/lifecycle-stable-brightgreen.svg)](https://www.tidyverse.org/lifecycle/#stable)
 
 ## Overview
 ",False,True,Documentation / Formatting,6
tidyverse,readxl,f51e4da3e63354c3785c78b2f5d79e1c452c8c69,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-15T02:22:59Z,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-15T02:22:59Z,"Remove full stops for help titles

Fixes #420",R/excel-sheets.R;R/read_excel.R;man/excel_sheets.Rd;man/read_excel.Rd,False,True,True,False,6,6,12,"---FILE: R/excel-sheets.R---
@@ -1,4 +1,4 @@
-#' List all sheets in an excel spreadsheet.
+#' List all sheets in an excel spreadsheet
 #'
 #' @inheritParams read_excel
 #' @export

---FILE: R/read_excel.R---
@@ -2,7 +2,7 @@
 #' @importFrom Rcpp sourceCpp
 NULL
 
-#' Read xls and xlsx files.
+#' Read xls and xlsx files
 #'
 #' @param path Path to the xls/xlsx file
 #' @param sheet Sheet to read. Either a string (the name of a sheet), or an

---FILE: man/excel_sheets.Rd---
@@ -2,15 +2,15 @@
 % Please edit documentation in R/excel-sheets.R
 \name{excel_sheets}
 \alias{excel_sheets}
-\title{List all sheets in an excel spreadsheet.}
+\title{List all sheets in an excel spreadsheet}
 \usage{
 excel_sheets(path)
 }
 \arguments{
 \item{path}{Path to the xls/xlsx file}
 }
 \description{
-List all sheets in an excel spreadsheet.
+List all sheets in an excel spreadsheet
 }
 \examples{
 excel_sheets(readxl_example(""datasets.xlsx""))

---FILE: man/read_excel.Rd---
@@ -4,7 +4,7 @@
 \alias{read_excel}
 \alias{read_xls}
 \alias{read_xlsx}
-\title{Read xls and xlsx files.}
+\title{Read xls and xlsx files}
 \usage{
 read_excel(path, sheet = NULL, range = NULL, col_names = TRUE,
   col_types = NULL, na = """", trim_ws = TRUE, skip = 0, n_max = Inf,
@@ -67,7 +67,7 @@ types.}
 A \link[tibble:tibble-package]{tibble}
 }
 \description{
-Read xls and xlsx files.
+Read xls and xlsx files
 
 \code{read_excel()} tries to determine format from the file extension and the file
 itself, in that order. Use \code{read_xls()} and \code{read_xlsx()} directly to",True,False,Documentation / Formatting,6
tidyverse,readxl,412453d5b449ad3ed0c0aae210ae0582474cd0f4,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-14T06:01:12Z,Jenny Bryan,jenny.f.bryan@gmail.com,2018-04-14T15:55:41Z,"Update NEWS to describe security fixes

[skip ci]",NEWS.md,False,False,False,False,5,0,5,"---FILE: NEWS.md---
@@ -1,5 +1,10 @@
 # readxl 1.0.0.9000
 
+* Embedded libxls has been updated to address security vulnerabilitities identified in late 2017 (#441, #442).
+
+  - [CVE-2017-12110](https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0462), [CVE-2017-2896](https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0403), and [CVE-2017-2897](https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0404) were demonstrated to affect readxl v1.0.0. These have been addressed in libxls and the embedded version of libxls incorporates those fixes.
+  - Although [CVE-2017-12111](https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0463) and [CVE-2017-2919](https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0426) mention readxl, the notices clarify that these CVEs do not actually affect readxl. Both have been fixed in libxls for quite a while: CVE-2017-12111 since 2014 and CVE-2017-2919 since 2012.
+
 * xlsx structured as a ""minimal conformant SpreadsheetML package"" can be read. Most obvious feature of such sheets is the lack of an `xl/` directory in the unzipped form. (xlsx, #435, #437)
 
 * Reading xls sheet with exactly 65,536 rows no longer enters an infinite loop. (xls, #373, #416, #432 @vkapartzianis)",False,False,Documentation / Formatting,4
tidyverse,readxl,49b4f833447d57788d6ccf5b5fae79535ec87313,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2018-04-14T05:48:23Z,GitHub,noreply@github.com,2018-04-14T05:48:23Z,"Pull upstream changes from libxls (#442)

* Pull state of overlapping files from https://github.com/evanmiller/libxls/commit/3a2acf14173463e40d6f18a8cc63b901db16e233

* Correct path to xls.h

* Reinstate cran.h

* Remove fprintf macro (for now)

* Patch xls.c to read all cols in xls written by some third-party s/w

https://github.com/tidyverse/readxl/commit/92b7b1641d733dde005bda00e4a9712efd51eb1d

* Apply https://github.com/evanmiller/libxls/commit/967fbd76368ae6ef85c3d014879d2de99d00108a

* Apply https://github.com/evanmiller/libxls/commit/a9f823ff51079c686e455fd7e374f0962094eddf

* Apply https://github.com/evanmiller/libxls/commit/7ea6ee3b5783f1da5c49cb327ab138c12dd2b5dd

* Apply https://github.com/evanmiller/libxls/commit/c7e5e49518027c2a8bf65c933b1a7f8804a8f7fb

* Reinstate the fprintf macro ... several of them!

* Exploit the fprintf macros

* Solaris woo",.Rbuildignore;.gitignore;src/cran.h;src/endian.c;src/libxls/endian.h;src/libxls/ole.h;src/libxls/xls.h;src/libxls/xls2csv.c;src/libxls/xlsstruct.h;src/libxls/xlstool.h;src/libxls/xlstypes.h;src/ole.c;src/xls.c;src/xlstool.c,False,False,False,False,1142,706,1848,"---FILE: .Rbuildignore---
@@ -23,3 +23,4 @@
 ^vignettes/releases$
 ^talks$
 ^scratch\.R$
+^src/fprintf-substitution\.R$

---FILE: .gitignore---
@@ -7,3 +7,4 @@ clippy/geometry.key
 rsconnect
 inst/doc
 scratch.R
+src/fprintf-substitution.R

---FILE: src/cran.h---
@@ -6,10 +6,14 @@
 #define printf Rprintf
 
 /* Rather than use variadic macros (which are a C99 feature) we are going to
- * hard code a macro with only two additional arguments, as the only usage of
- * fprintf uses two additional arguments.
+ * hard code macros with different numbers of arguments
  */
-#define fprintf(err, msg, a1, a2) Rprintf(msg, a1, a2)
+#define fprintf2(err, msg) Rprintf(msg)
+#define fprintf3(err, msg, a1) Rprintf(msg, a1)
+#define fprintf4(err, msg, a1, a2) Rprintf(msg, a1, a2)
+#define fprintf5(err, msg, a1, a2, a3) Rprintf(msg, a1, a2, a3)
+#define fprintf10(err, msg, a1, a2, a3, a4, a5, a6, a7, a8) Rprintf(msg, a1, a2, a3, a4, a5, a6, a7, a8)
+
 #undef assert
 #define assert(X) if (X) {}
 #define exit assert

---FILE: src/endian.c---
@@ -37,22 +37,12 @@ int xls_is_bigendian()
 {
 #if defined (__BIG_ENDIAN__)
     return 1;
-#elif defined (_WIN32)
-    return 0;
 #elif defined (__LITTLE_ENDIAN__)
     return 0;
 #else
-// #warning NO ENDIAN
     static int n = 1;
 
-    if (*(char *)&n == 1)
-    {
-        return 0;
-    }
-    else
-    {
-        return 1;
-    }
+    return (*(char *)&n == 0);
 #endif
 }
 
@@ -75,11 +65,11 @@ DWORD xlsIntVal (DWORD i)
 unsigned short xlsShortVal (short s)
 {
     unsigned char c1, c2;
-
+    
     if (xls_is_bigendian()) {
         c1 = s & 255;
         c2 = (s >> 8) & 255;
-
+    
         return (c1 << 8) + c2;
     } else {
         return s;
@@ -113,10 +103,8 @@ void xlsConvertBiff(BIFF *b)
     b->type = xlsShortVal(b->type);
     b->id_make = xlsShortVal(b->id_make);
     b->year = xlsShortVal(b->year);
-    if (b->ver == 0x600) {
-      b->flags = xlsIntVal(b->flags);
-      b->min_ver = xlsIntVal(b->min_ver);
-    }
+    b->flags = xlsIntVal(b->flags);
+    b->min_ver = xlsIntVal(b->min_ver);
 }
 
 void xlsConvertWindow(WIND1 *w)
@@ -134,8 +122,8 @@ void xlsConvertWindow(WIND1 *w)
 
 void xlsConvertSst(SST *s)
 {
-    s->num=xlsIntVal(s->num);
-    s->num=xlsIntVal(s->numofstr);
+    s->num = xlsIntVal(s->num);
+    s->numofstr = xlsIntVal(s->numofstr);
 }
 
 void xlsConvertXf5(XF5 *x)

---FILE: src/libxls/ole.h---
@@ -86,7 +86,7 @@ typedef	struct st_olefiles
     long count;
     struct st_olefiles_data
     {
-        BYTE*	name;
+        char*	name;
         DWORD	start;
         DWORD	size;
    }
@@ -97,6 +97,10 @@ st_olefiles;
 typedef struct OLE2
 {
     FILE*		file;
+    const void *buffer;
+    size_t      buffer_len;
+    size_t      buffer_pos;
+
     WORD		lsector;
     WORD		lssector;
     DWORD		cfat;
@@ -107,9 +111,16 @@ typedef struct OLE2
     DWORD		csfat;
     DWORD		difstart;
     DWORD		cdif;
+
     DWORD*		SecID;	// regular sector data
+    DWORD       SecIDCount;
+
 	DWORD*		SSecID;	// short sector data
+    DWORD       SSecIDCount;
+
 	BYTE*		SSAT;	// directory of short sectors
+    DWORD       SSATCount;
+
     st_olefiles	files;
 }
 OLE2;
@@ -137,7 +148,7 @@ OLE2Stream;
 
 typedef struct PSS
 {
-    BYTE	name[64];
+    char	name[64];
     WORD	bsize;
     BYTE	type;		//STGTY
 #define PS_EMPTY		00
@@ -160,14 +171,15 @@ PSS;
 
 #pragma pack(pop)
 
-extern size_t ole2_read(void* buf,size_t size,size_t count,OLE2Stream* olest);
+extern ssize_t ole2_read(void* buf,size_t size,size_t count,OLE2Stream* olest);
 extern OLE2Stream* ole2_sopen(OLE2* ole,DWORD start, size_t size);
-extern void ole2_seek(OLE2Stream* olest,DWORD ofs);
-extern OLE2Stream*  ole2_fopen(OLE2* ole,BYTE* file);
+extern int ole2_seek(OLE2Stream* olest,DWORD ofs);
+extern OLE2Stream*  ole2_fopen(OLE2* ole, const char *file);
 extern void ole2_fclose(OLE2Stream* ole2st);
-extern OLE2* ole2_open(const BYTE *file);
+extern OLE2* ole2_open_file(const char *file);
+extern OLE2* ole2_open_buffer(const void *buffer, size_t len);
 extern void ole2_close(OLE2* ole2);
-extern void ole2_bufread(OLE2Stream* olest);
+extern int ole2_bufread(OLE2Stream* olest);
 
 
 #endif

---FILE: src/libxls/xls.h---
@@ -41,18 +41,34 @@ extern ""C"" {
 #include ""libxls/xlsstruct.h""
 #include ""libxls/xlstool.h""
 
+typedef enum {
+    LIBXLS_OK,
+    LIBXLS_ERROR_OPEN,
+    LIBXLS_ERROR_SEEK,
+    LIBXLS_ERROR_READ,
+    LIBXLS_ERROR_PARSE,
+    LIBXLS_ERROR_MALLOC
+} xls_error_t;
 
 extern const char* xls_getVersion(void);
+extern const char* xls_getError(xls_error_t code);
 
 extern int xls(int debug);	// Set debug. Force library to load?
 extern void xls_set_formula_hander(xls_formula_handler handler);
 
-extern void xls_parseWorkBook(xlsWorkBook* pWB);
-extern void xls_parseWorkSheet(xlsWorkSheet* pWS);
+extern xls_error_t xls_parseWorkBook(xlsWorkBook* pWB);
+extern xls_error_t xls_parseWorkSheet(xlsWorkSheet* pWS);
 
-extern xlsWorkBook* xls_open(const char *file,const char *charset);	// convert 16bit strings within the spread sheet to this 8-bit encoding (UTF-8 default)
-#define xls_close xls_close_WB                  // historical
-extern void xls_close_WB(xlsWorkBook* pWB);     // preferred name
+// Preferred API
+// charset - convert 16bit strings within the spread sheet to this 8-bit encoding (UTF-8 default)
+extern xlsWorkBook *xls_open_file(const char *file, const char *charset, xls_error_t *outError);
+extern xlsWorkBook *xls_open_buffer(const unsigned char *data, size_t data_len,
+        const char *charset, xls_error_t *outError);
+extern void xls_close_WB(xlsWorkBook* pWB);
+
+// Historical API
+extern xlsWorkBook* xls_open(const char *file,const char *charset);
+#define xls_close xls_close_WB
 
 extern xlsWorkSheet * xls_getWorkSheet(xlsWorkBook* pWB,int num);
 extern void xls_close_WS(xlsWorkSheet* pWS);

---FILE: src/libxls/xls2csv.c---
@@ -48,15 +48,15 @@ static void Usage(char *progName);
 
 static void Usage(char *progName)
 {
-    fprintf(stderr, ""usage: %s <Excel xls file> [-l] [-e encoding] [-t sheet] [-q quote char] [-f field separator]\n"", progName);
-    fprintf(stderr, ""  Output Excel file cells as delimited values (default is comma separated)\n"");
-    fprintf(stderr, ""  Options:\n"");
-    fprintf(stderr, ""    -l            : list the sheets contained in the file but do not output their contents.\n"");
-    fprintf(stderr, ""    -t sheet_name : only process the named sheet\n"");
-    fprintf(stderr, ""    -e encoding   : the iconv encoding (default \""%s\"")\n"", encoding);
-    fprintf(stderr, ""    -q character  : used to quote strings (default '%c')\n"", stringSeparator);
-    fprintf(stderr, ""    -f string     : used to separate fields (default \""%s\"")\n"", fieldSeparator);
-    fprintf(stderr, ""\n"");
+    fprintf3(stderr, ""usage: %s <Excel xls file> [-l] [-e encoding] [-t sheet] [-q quote char] [-f field separator]\n"", progName);
+    fprintf2(stderr, ""  Output Excel file cells as delimited values (default is comma separated)\n"");
+    fprintf2(stderr, ""  Options:\n"");
+    fprintf2(stderr, ""    -l            : list the sheets contained in the file but do not output their contents.\n"");
+    fprintf2(stderr, ""    -t sheet_name : only process the named sheet\n"");
+    fprintf3(stderr, ""    -e encoding   : the iconv encoding (default \""%s\"")\n"", encoding);
+    fprintf3(stderr, ""    -q character  : used to quote strings (default '%c')\n"", stringSeparator);
+    fprintf3(stderr, ""    -f string     : used to separate fields (default \""%s\"")\n"", fieldSeparator);
+    fprintf2(stderr, ""\n"");
     exit(EXIT_FAILURE);
 }
 
@@ -73,7 +73,7 @@ int main(int argc, char *argv[]) {
     Usage(argv[0]);
   }
 
-  //fprintf(stderr, ""DIR: %s\n\n"", getcwd(NULL, 1024));
+  //fprintf3(stderr, ""DIR: %s\n\n"", getcwd(NULL, 1024));
 
   optind = 2; // skip file arg
 
@@ -104,8 +104,8 @@ int main(int argc, char *argv[]) {
   // open workbook, choose standard conversion
   pWB = xls_open(argv[1], encoding);
   if (!pWB) {
-    fprintf(stderr, ""File not found"");
-    fprintf(stderr, ""\n"");
+    fprintf2(stderr, ""File not found"");
+    fprintf2(stderr, ""\n"");
     return EXIT_FAILURE;
   }
 
@@ -118,8 +118,8 @@ int main(int argc, char *argv[]) {
     }
 
     if (i == pWB->sheets.count) {
-      fprintf(stderr, ""Sheet \""%s\"" not found"", sheetName);
-      fprintf(stderr, ""\n"");
+      fprintf3(stderr, ""Sheet \""%s\"" not found"", sheetName);
+      fprintf2(stderr, ""\n"");
       return EXIT_FAILURE;
     }
   }
@@ -176,7 +176,7 @@ int main(int argc, char *argv[]) {
 
         // display the colspan as only one cell, but reject rowspans (they can't be converted to CSV)
         if (cell->rowspan > 1) {
-          fprintf(stderr, ""Warning: %d rows spanned at col=%d row=%d: output will not match the Excel file.\n"", cell->rowspan, cellCol+1, cellRow+1);
+          fprintf5(stderr, ""Warning: %d rows spanned at col=%d row=%d: output will not match the Excel file.\n"", cell->rowspan, cellCol+1, cellRow+1);
         }
 
         // display the value of the cell (either numeric or string)

---FILE: src/libxls/xlsstruct.h---
@@ -101,7 +101,6 @@ typedef struct BIFF
     WORD year;
     DWORD flags;
     DWORD min_ver;
-    BYTE buf[100];
 }
 BIFF;
 
@@ -124,7 +123,7 @@ typedef struct BOUNDSHEET
     DWORD	filepos;
     BYTE	type;
     BYTE	visible;
-    BYTE	name[1];
+    char	name[];
 }
 BOUNDSHEET;
 
@@ -195,7 +194,7 @@ typedef struct MULRK
 	struct {
 		WORD	xf;
 		DWORD_UA value;
-	}		rk[1];
+	}		rk[];
 	//WORD	last_col;
 }
 MULRK;
@@ -204,7 +203,7 @@ typedef struct MULBLANK
 {
     WORD	row;
     WORD	col;
-    WORD	xf[1];
+    WORD	xf[];
 	//WORD	last_col;
 }
 MULBLANK;
@@ -222,7 +221,7 @@ typedef struct LABEL
     WORD	row;
     WORD	col;
     WORD	xf;
-    BYTE	value[1]; // var
+    BYTE	value[]; // var
 }
 LABEL;
 typedef LABEL LABELSST;
@@ -241,7 +240,7 @@ typedef struct SST
 {
     DWORD	num;
     DWORD	numofstr;
-    BYTE	strings;
+    BYTE	strings[0];
 }
 SST;
 
@@ -313,14 +312,14 @@ typedef struct FONT
     BYTE	family;
     BYTE	charset;
     BYTE	notused;
-    BYTE	name;
+    char    name[];
 }
 FONT;
 
 typedef struct FORMAT
 {
     WORD	index;
-    BYTE	value[1];
+    char	value[];
 }
 FORMAT;
 
@@ -336,7 +335,7 @@ typedef	struct st_sheet
         DWORD filepos;
         BYTE visibility;
         BYTE type;
-        BYTE* name;
+        char * name;
     }
     * sheet;
 }
@@ -355,7 +354,7 @@ typedef	struct st_font
         BYTE	underline;
         BYTE	family;
         BYTE	charset;
-        BYTE*	name;
+        char *	name;
     }
     * font;
 }
@@ -367,7 +366,7 @@ typedef struct st_format
     struct st_format_data
     {
          WORD index;
-         BYTE *value;
+         char *value;
     }
     * format;
 }
@@ -405,7 +404,7 @@ typedef	struct st_sst
     DWORD lastsz;
     struct str_sst_string
     {
-        BYTE* str;
+        char * str;
     }
     * string;
 }
@@ -421,7 +420,7 @@ typedef	struct st_cell
         WORD	row;
         WORD	col;
         WORD	xf;
-        BYTE*	str;		// String value;
+        char *	str;		// String value;
         double	d;
         int32_t	l;
         WORD	width;		// Width of col

---FILE: src/libxls/xlstool.h---
@@ -37,9 +37,9 @@
 extern void dumpbuf(BYTE* fname,long size,BYTE* buf);
 extern void verbose(char* str);
 
-extern BYTE *utf8_decode(BYTE *str, DWORD len, char *encoding);
-extern BYTE* unicode_decode(const BYTE *s, int len, size_t *newlen, const char* encoding);
-extern BYTE* get_string(BYTE *s,BYTE is2, BYTE isUnicode, char *charset);
+extern char *utf8_decode(const char *str, DWORD len, char *encoding);
+extern char *unicode_decode(const char *s, size_t len, size_t *newlen, const char* encoding);
+extern char *get_string(const char *s, size_t len, BYTE is2, BYTE isUnicode, char *charset);
 extern DWORD xls_getColor(const WORD color,WORD def);
 
 extern void xls_showBookInfo(xlsWorkBook* pWB);
@@ -49,6 +49,6 @@ extern void xls_showCell(struct st_cell_data* cell);
 extern void xls_showFont(struct st_font_data* font);
 extern void xls_showXF(XF8* xf);
 extern void xls_showFormat(struct st_format_data* format);
-extern BYTE* xls_getfcell(xlsWorkBook* pWB,struct st_cell_data* cell,BYTE *label);
+extern char* xls_getfcell(xlsWorkBook* pWB, struct st_cell_data* cell, BYTE *label);
 extern char* xls_getCSS(xlsWorkBook* pWB);
 extern void xls_showBOF(BOF* bof);

---FILE: src/libxls/xlstypes.h---
@@ -47,10 +47,24 @@ typedef uint16_t			WORD_UA		__attribute__ ((aligned (1)));	// 2 bytes
 typedef uint32_t			DWORD_UA	__attribute__ ((aligned (1)));	// 4 bytes
 #endif
 
-#ifdef _WIN32
+// Windows
+#if defined(_MSC_VER) && defined(WIN32)
+
 typedef unsigned __int64	unsigned64_t;
+
+// not windows
 #else
+
+#if defined(_UINT64_T)
+
 typedef uint64_t			unsigned64_t;
+
+#else
+
+typedef unsigned long long	unsigned64_t;
+
+// _UINT64_T
+#endif
 #endif
 
 #endif

---FILE: src/ole.c---
@@ -38,8 +38,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 
-#include <assert.h>
-
 #include ""libxls/ole.h""
 #include ""libxls/xlstool.h""
 #include ""libxls/endian.h""
@@ -56,55 +54,72 @@ static const DWORD ENDOFCHAIN	= 0xFFFFFFFE;	// -2
 static const DWORD FREESECT		= 0xFFFFFFFF;	// -1
 
 static size_t sector_pos(OLE2* ole2, size_t sid);
-static int sector_read(OLE2* ole2, BYTE *buffer, size_t sid);
-static size_t read_MSAT(OLE2* ole2, OLE2Header *oleh);
+static ssize_t sector_read(OLE2* ole2, void *buffer, size_t sid);
+static ssize_t read_MSAT(OLE2* ole2, OLE2Header *oleh);
+static void *ole_malloc(size_t len);
+
+static void *ole_malloc(size_t len) {
+    if (len > (1<<24) || len == 0) {
+        return NULL;
+    }
+    return malloc(len);
+}
 
 // Read next sector of stream
-void ole2_bufread(OLE2Stream* olest) 
+int ole2_bufread(OLE2Stream* olest) 
 {
 	BYTE *ptr;
 
-	assert(olest);
-	assert(olest->ole);
+    if (olest == NULL || olest->ole == NULL)
+        return -1;
 
     if ((DWORD)olest->fatpos!=ENDOFCHAIN)
     {
 		if(olest->sfat) {
-			assert(olest->ole->SSAT);
-			assert(olest->buf);
-			assert(olest->ole->SSecID);
+            if (olest->ole->SSAT == NULL || olest->buf == NULL || olest->ole->SSecID == NULL)
+                return -1;
+
+            if (olest->fatpos*olest->ole->lssector + olest->bufsize > olest->ole->SSATCount) {
+                if (xls_debug) fprintf3(stderr, ""Error: fatpos %d out-of-bounds for SSAT\n"", (int)olest->fatpos);
+                return -1;
+            }
 
 			ptr = olest->ole->SSAT + olest->fatpos*olest->ole->lssector;
 			memcpy(olest->buf, ptr, olest->bufsize); 
 
+            if (olest->fatpos >= olest->ole->SSecIDCount) {
+                if (xls_debug) fprintf4(stderr, ""Error: fatpos %d out-of-bounds for SSecID[%d]\n"",
+                        (int)olest->fatpos, olest->ole->SSecIDCount);
+                return -1;
+            }
+
 			olest->fatpos=xlsIntVal(olest->ole->SSecID[olest->fatpos]);
 			olest->pos=0;
 			olest->cfat++;
 		} else {
+			if ((int)olest->fatpos < 0 ||
+                sector_read(olest->ole, olest->buf, olest->fatpos) == -1) {
+                if (xls_debug) fprintf3(stderr, ""Error: Unable to read sector #%d\n"", (int)olest->fatpos);
+                return -1;
+            }
 
-			assert(olest->fatpos >= 0);
-
-			//printf(""fatpos: %d max=%u\n"",olest->fatpos, (olest->ole->cfat*olest->ole->lsector)/4);
-			if(olest->fatpos > (olest->ole->cfat*olest->ole->lsector)/4) exit(-1);
+            if (olest->fatpos >= olest->ole->SecIDCount) {
+                if (xls_debug) fprintf4(stderr, ""Error: fatpos %d out-of-bounds for SecID[%d]\n"",
+                        (int)olest->fatpos, olest->ole->SecIDCount);
+                return -1;
+            }
 
-#if 0 // TODO: remove
-			fseek(olest->ole->file,olest->fatpos*olest->ole->lsector+512,0);
-			ret = fread(olest->buf,1,olest->bufsize,olest->ole->file);
-			assert(ret == olest->bufsize);
-#endif
-			assert((int)olest->fatpos >= 0);
-			sector_read(olest->ole, olest->buf, olest->fatpos);
-			//printf(""Fat val: %d[0x%X]\n"",olest->fatpos,olest->ole->SecID[olest->fatpos], olest->ole->SecID[olest->fatpos]);
 			olest->fatpos=xlsIntVal(olest->ole->SecID[olest->fatpos]);
 			olest->pos=0;
 			olest->cfat++;
 		}
     }
 	// else printf(""ENDOFCHAIN!!!\n"");
+    return 0;
 }
 
 // Read part of stream
-size_t ole2_read(void* buf,size_t size,size_t count,OLE2Stream* olest)
+ssize_t ole2_read(void* buf, size_t size, size_t count, OLE2Stream* olest)
 {
     size_t didReadCount=0;
     size_t totalReadCount;
@@ -126,7 +141,7 @@ size_t ole2_read(void* buf,size_t size,size_t count,OLE2Stream* olest)
 		//printf(""  totalReadCount=%d (rem=%d size*count=%ld)\n"", totalReadCount, rem, size*count);
 	}
 
-	while ((!olest->eof) && (didReadCount!=totalReadCount))
+	while ((!olest->eof) && (didReadCount < totalReadCount))
 	{
 		unsigned long remainingBytes;
 
@@ -145,9 +160,9 @@ size_t ole2_read(void* buf,size_t size,size_t count,OLE2Stream* olest)
 			memcpy((BYTE*)buf + didReadCount, olest->buf + olest->pos, remainingBytes);
 			olest->pos		+= remainingBytes;
 			didReadCount	+= remainingBytes;
-			ole2_bufread(olest);
+			if (ole2_bufread(olest) == -1)
+                return -1;
 		}
-		assert(didReadCount <= totalReadCount);
 		//printf(""  if(fatpos=0x%X==EOC=0x%X) && (pos=%d >= bufsize=%d)\n"", olest->fatpos, ENDOFCHAIN, olest->pos, olest->bufsize);
 		if (((DWORD)olest->fatpos == ENDOFCHAIN) && (olest->pos >= olest->bufsize))
 		{
@@ -156,22 +171,25 @@ size_t ole2_read(void* buf,size_t size,size_t count,OLE2Stream* olest)
 
 		//printf(""  eof=%d (didReadCount=%ld != totalReadCount=%ld)\n"", olest->eof, didReadCount, totalReadCount);
 	}
+    if (didReadCount > totalReadCount)
+        return -1;
+
 	// printf(""  didReadCount=%ld EOF=%d\n"", didReadCount, olest->eof);
 	// printf(""=====\n"");
 
 #ifdef OLE_DEBUG
-    printf(""----------------------------------------------\n"");
-    printf(""ole2_read (end)\n"");
-    printf(""start:		%li \n"",olest->start);
-    printf(""pos:		%li \n"",olest->pos);
-    printf(""cfat:		%d \n"",olest->cfat);
-    printf(""size:		%d \n"",olest->size);
-    printf(""fatpos:		%li \n"",olest->fatpos);
-    printf(""bufsize:		%li \n"",olest->bufsize);
-    printf(""eof:		%d \n"",olest->eof);
+    fprintf2(stderr, ""----------------------------------------------\n"");
+    fprintf2(stderr, ""ole2_read (end)\n"");
+    fprintf3(stderr, ""start:		%d \n"",olest->start);
+    fprintf3(stderr, ""pos:		%d \n"",(int)olest->pos);
+    fprintf3(stderr, ""cfat:		%d \n"",(int)olest->cfat);
+    fprintf3(stderr, ""size:		%d \n"",(int)olest->size);
+    fprintf3(stderr, ""fatpos:		%d \n"",(int)olest->fatpos);
+    fprintf3(stderr, ""bufsize:		%d \n"",(int)olest->bufsize);
+    fprintf3(stderr, ""eof:		%d \n"",olest->eof);
 #endif
 
-    return(didReadCount);
+    return didReadCount;
 }
 
 // Open stream in logical ole file
@@ -180,8 +198,8 @@ OLE2Stream* ole2_sopen(OLE2* ole,DWORD start, size_t size)
     OLE2Stream* olest=NULL;
 
 #ifdef OLE_DEBUG
-    printf(""----------------------------------------------\n"");
-    printf(""ole2_sopen start=%lXh\n"", start);
+    fprintf2(stderr, ""----------------------------------------------\n"");
+    fprintf3(stderr, ""ole2_sopen start=%Xh\n"", start);
 #endif
 
 	olest=(OLE2Stream*)calloc(1, sizeof(OLE2Stream));
@@ -198,25 +216,31 @@ OLE2Stream* ole2_sopen(OLE2* ole,DWORD start, size_t size)
 	} else {
 		olest->bufsize=ole->lsector;
 	}
-	olest->buf=malloc(olest->bufsize);
+	olest->buf = ole_malloc(olest->bufsize);
 	ole2_bufread(olest);
 
 	// if(xls_debug) printf(""sopen: sector=%d next=%d\n"", start, olest->fatpos);
     return olest;
 }
 
 // Move in stream
-void ole2_seek(OLE2Stream* olest,DWORD ofs)
+int ole2_seek(OLE2Stream* olest,DWORD ofs)
 {
+#ifdef OLE_DEBUG
+    fprintf3(stderr, ""SEEK %x\n"", ofs);
+#endif
 	if(olest->sfat) {
 		ldiv_t div_rez=ldiv(ofs,olest->ole->lssector);
 		int i;
 		olest->fatpos=olest->start;
 
 		if (div_rez.quot!=0)
 		{
-			for (i=0;i<div_rez.quot;i++)
+			for (i=0;i<div_rez.quot;i++) {
+                if (olest->fatpos >= olest->ole->SSecIDCount)
+                    return -1;
 				olest->fatpos=xlsIntVal(olest->ole->SSecID[olest->fatpos]);
+            }
 		}
 
 		ole2_bufread(olest);
@@ -227,12 +251,18 @@ void ole2_seek(OLE2Stream* olest,DWORD ofs)
 	} else {
 		ldiv_t div_rez=ldiv(ofs,olest->ole->lsector);
 		int i;
+#ifdef OLE_DEBUG
+        fprintf4(stderr, ""seeking fatpos%lu start %u\n"", olest->fatpos, olest->start);
+#endif
 		olest->fatpos=olest->start;
 
 		if (div_rez.quot!=0)
 		{
-			for (i=0;i<div_rez.quot;i++)
-				olest->fatpos=xlsIntVal(olest->ole->SecID[olest->fatpos]);
+			for (i=0;i<div_rez.quot;i++) {
+                if (olest->fatpos >= olest->ole->SecIDCount)
+                    return -1;
+                olest->fatpos=xlsIntVal(olest->ole->SecID[olest->fatpos]);
+            }
 		}
 
 		ole2_bufread(olest);
@@ -241,76 +271,88 @@ void ole2_seek(OLE2Stream* olest,DWORD ofs)
 		olest->cfat=div_rez.quot;
 		//printf(""%i=%i %i\n"",ofs,div_rez.quot,div_rez.rem);
 	}
+    return 0;
 }
 
 // Open logical file contained in physical OLE file
-OLE2Stream*  ole2_fopen(OLE2* ole,BYTE* file)
+OLE2Stream*  ole2_fopen(OLE2* ole, const char *file)
 {
-    OLE2Stream* olest;
     int i;
 
 #ifdef OLE_DEBUG
-    printf(""----------------------------------------------\n"");
-    printf(""ole2_fopen %s\n"", file);
+    fprintf2(stderr, ""----------------------------------------------\n"");
+    fprintf3(stderr, ""ole2_fopen %s\n"", file);
 #endif
 
     for (i=0;i<ole->files.count;i++) {
-		BYTE *str = ole->files.file[i].name;
+		char *str = ole->files.file[i].name;
 #ifdef OLE_DEBUG
-		printf(""----------------------------------------------\n"");
-		printf(""ole2_fopen found %s\n"", str);
+		fprintf2(stderr, ""----------------------------------------------\n"");
+		fprintf3(stderr, ""ole2_fopen found %s\n"", str);
 #endif
-        if (str && strcmp((char *)str,(char *)file)==0)	// newer versions of Excel don't write the ""Root Entry"" string for the first set of data
+        if (str && strcmp(str,file)==0)	// newer versions of Excel don't write the ""Root Entry"" string for the first set of data
         {
-            olest=ole2_sopen(ole,ole->files.file[i].start,ole->files.file[i].size);
-            return(olest);
+            return ole2_sopen(ole,ole->files.file[i].start,ole->files.file[i].size);
         }
 	}
-    return(NULL);
+    return NULL;
 }
 
-// Open physical file
-OLE2* ole2_open(const BYTE *file)
-{
-    //BYTE buf[1024];
-    OLE2Header* oleh;
-    OLE2* ole;
-    OLE2Stream* olest;
-    PSS*	pss;
-    BYTE* name = NULL;
+int ole2_fseek(OLE2 *ole2, size_t pos) {
+    if (ole2->file)
+        return fseek(ole2->file, pos, SEEK_SET);
 
-#ifdef OLE_DEBUG
-    printf(""----------------------------------------------\n"");
-    printf(""ole2_open %s\n"", file);
-#endif
+    if (pos > ole2->buffer_len)
+        return -1;
 
-	if(xls_debug) printf(""ole2_open: %s\n"", file);
-    ole=(OLE2*)calloc(1, sizeof(OLE2));
-    if (!(ole->file=fopen((char *)file,""rb"")))
-    {
-        if(xls_debug) printf(""File not found\n"");
-        free(ole);
-        return(NULL);
+    ole2->buffer_pos = pos;
+    return 0;
+}
+
+size_t ole2_fread(OLE2 *ole2, void *buffer, size_t size, size_t nitems) {
+    if (ole2->file)
+        return fread(buffer, size, nitems, ole2->file);
+
+    size_t i = 0;
+    for (i=0; i<nitems; i++) {
+        if (ole2->buffer_pos + size > ole2->buffer_len)
+            break;
+
+        memcpy(buffer, (const char *)ole2->buffer + ole2->buffer_pos, size);
+        ole2->buffer_pos += size;
+    }
+    return i;
+}
+
+
+// read header and check magic numbers
+static ssize_t ole2_read_header(OLE2 *ole) {
+    ssize_t bytes_read = 0, total_bytes_read = 0;
+    OLE2Header *oleh = malloc(512);
+    if (ole2_fread(ole, oleh, 512, 1) != 1) {
+        total_bytes_read = -1;
+        goto cleanup;
     }
-    // read header and check magic numbers
-    oleh=(OLE2Header*)malloc(512);
-    fread(oleh,1,512,ole->file);
+    total_bytes_read += 512;
     xlsConvertHeader(oleh);
 
 	// make sure the file looks good. Note: this code only works on Little Endian machines
 	if(oleh->id[0] != 0xE011CFD0 || oleh->id[1] != 0xE11AB1A1 || oleh->byteorder != 0xFFFE) {
-		fclose(ole->file);
-        printf(""Not an excel file\n"");
-		free(ole);
-		return NULL;
+        if (xls_debug) fprintf2(stderr, ""Not an excel file\n"");
+        total_bytes_read = -1;
+        goto cleanup;
 	}
 
     //ole->lsector=(WORD)pow(2,oleh->lsector);
     //ole->lssector=(WORD)pow(2,oleh->lssector);
 	ole->lsector=512;
     ole->lssector=64;
-	assert(oleh->lsectorB==9);	// 2**9 == 512
-	assert(oleh->lssectorB==6);	// 2**6 == 64
+
+	if (oleh->lsectorB != 9 || oleh->lssectorB != 6) {	// 2**9 == 512, 2**6 == 64
+        if (xls_debug) fprintf2(stderr, ""Unexpected sector size\n"");
+        total_bytes_read = -1;
+        goto cleanup;
+    }
 	
     ole->cfat=oleh->cfat;
     ole->dirstart=oleh->dirstart;
@@ -322,94 +364,112 @@ OLE2* ole2_open(const BYTE *file)
     ole->files.count=0;
 
 #ifdef OLE_DEBUG
-		printf(""==== OLE HEADER ====\n"");
+		fprintf2(stderr, ""==== OLE HEADER ====\n"");
 		//printf (""Header Size:   %i \n"", sizeof(OLE2Header));
 		//printf (""id[0]-id[1]:   %X-%X \n"", oleh->id[0], oleh->id[1]);
-		printf (""verminor:      %X \n"",oleh->verminor);
-		printf (""verdll:        %X \n"",oleh->verdll);
+		fprintf3(stderr, ""verminor:      %X \n"",oleh->verminor);
+		fprintf3(stderr, ""verdll:        %X \n"",oleh->verdll);
 		//printf (""Byte order:    %X \n"",oleh->byteorder);
-		printf (""sect len:      %X (%i)\n"",ole->lsector,ole->lsector);		// ole
-		printf (""mini len:      %X (%i)\n"",ole->lssector,ole->lssector);	// ole
-		printf (""Fat sect.:     %i \n"",oleh->cfat);
-		printf (""Dir Start:     %i \n"",oleh->dirstart);
+		fprintf4(stderr, ""sect len:      %X (%i)\n"",ole->lsector,ole->lsector);		// ole
+		fprintf4(stderr, ""mini len:      %X (%i)\n"",ole->lssector,ole->lssector);	// ole
+		fprintf3(stderr, ""Fat sect.:     %i \n"",oleh->cfat);
+		fprintf3(stderr, ""Dir Start:     %i \n"",oleh->dirstart);
 		
-		printf (""Mini Cutoff:   %i \n"",oleh->sectorcutoff);
-		printf (""MiniFat Start: %X \n"",oleh->sfatstart);
-		printf (""Count MFat:    %i \n"",oleh->csfat);
-		printf (""Dif start:     %X \n"",oleh->difstart);
-		printf (""Count Dif:     %i \n"",oleh->cdif);
-		printf (""Fat Size:      %u (0x%X) \n"",oleh->cfat*ole->lsector,oleh->cfat*ole->lsector);
+		fprintf3(stderr, ""Mini Cutoff:   %i \n"",oleh->sectorcutoff);
+		fprintf3(stderr, ""MiniFat Start: %X \n"",oleh->sfatstart);
+		fprintf3(stderr, ""Count MFat:    %i \n"",oleh->csfat);
+		fprintf3(stderr, ""Dif start:     %X \n"",oleh->difstart);
+		fprintf3(stderr, ""Count Dif:     %i \n"",oleh->cdif);
+		fprintf4(stderr, ""Fat Size:      %u (0x%X) \n"",oleh->cfat*ole->lsector,oleh->cfat*ole->lsector);
 #endif
     // read directory entries
-    read_MSAT(ole, oleh);
+    if ((bytes_read = read_MSAT(ole, oleh)) == -1) {
+        total_bytes_read = -1;
+        goto cleanup;
+    }
+    total_bytes_read += bytes_read;
+
+cleanup:
+    free(oleh);
+
+    return total_bytes_read;
+}
 
+static ssize_t ole2_read_body(OLE2 *ole) {
 	// reuse this buffer
-    pss = (PSS*)oleh;
-	// oleh = (void *)NULL; // Not needed as oleh not used from here on
-	
-    olest=ole2_sopen(ole,ole->dirstart, -1);
-    do
-    {
-        ole2_read(pss,1,sizeof(PSS),olest);
+    PSS *pss = malloc(512);
+    OLE2Stream *olest=ole2_sopen(ole,ole->dirstart, -1);
+    char* name = NULL;
+    ssize_t bytes_read = 0, total_bytes_read = 0;
+
+    do {
+        if ((bytes_read = ole2_read(pss,1,sizeof(PSS),olest)) == -1) {
+            total_bytes_read = -1;
+            goto cleanup;
+        }
+        total_bytes_read += bytes_read;
         xlsConvertPss(pss);
+        if (pss->bsize > sizeof(pss->name)) {
+            total_bytes_read = -1;
+            goto cleanup;
+        }
         name=unicode_decode(pss->name, pss->bsize, 0, ""UTF-8"");
 #ifdef OLE_DEBUG	
-		printf(""OLE NAME: %s count=%d\n"", name, ole->files.count);
+		fprintf4(stderr, ""OLE NAME: %s count=%d\n"", name, (int)ole->files.count);
 #endif
         if (pss->type == PS_USER_ROOT || pss->type == PS_USER_STREAM) // (name!=NULL) // 
         {
 
 #ifdef OLE_DEBUG		
-			printf(""OLE TYPE: %s file=%d \n"", pss->type == PS_USER_ROOT ? ""root"" : ""user"", ole->files.count);
+			fprintf3(stderr, ""OLE TYPE: %s file=%d \n"", pss->type == PS_USER_ROOT ? ""root"" : ""user"", (int)ole->files.count);
 #endif		
-            if (ole->files.count==0)
-            {
-                ole->files.file=malloc(sizeof(struct st_olefiles_data));
-            } else {
-                ole->files.file=realloc(ole->files.file,(ole->files.count+1)*sizeof(struct st_olefiles_data));
-            }
+            ole->files.file = realloc(ole->files.file,(ole->files.count+1)*sizeof(struct st_olefiles_data));
             ole->files.file[ole->files.count].name=name;
             ole->files.file[ole->files.count].start=pss->sstart;
             ole->files.file[ole->files.count].size=pss->size;
             ole->files.count++;
 			
 			if(pss->sstart == ENDOFCHAIN) {
 				if (xls_debug) verbose(""END OF CHAIN\n"");
-			} else
-			if(pss->type == PS_USER_STREAM) {
+			} else if(pss->type == PS_USER_STREAM) {
 #ifdef OLE_DEBUG
-					printf(""----------------------------------------------\n"");
-					printf(""name: %s (size=%d [c=%c])\n"", name, pss->bsize, name ? name[0]:' ');
-					printf(""bsize %i\n"",pss->bsize);
-					printf(""type %i\n"",pss->type);
-					printf(""flag %i\n"",pss->flag);
-					printf(""left %X\n"",pss->left);
-					printf(""right %X\n"",pss->right);
-					printf(""child %X\n"",pss->child);
-					printf(""guid %.4X-%.4X-%.4X-%.4X %.4X-%.4X-%.4X-%.4X\n"",pss->guid[0],pss->guid[1],pss->guid[2],pss->guid[3],
+					fprintf2(stderr, ""----------------------------------------------\n"");
+					fprintf5(stderr, ""name: %s (size=%d [c=%c])\n"", name, pss->bsize, name ? name[0]:' ');
+					fprintf3(stderr, ""bsize %i\n"",pss->bsize);
+					fprintf3(stderr, ""type %i\n"",pss->type);
+					fprintf3(stderr, ""flag %i\n"",pss->flag);
+					fprintf3(stderr, ""left %X\n"",pss->left);
+					fprintf3(stderr, ""right %X\n"",pss->right);
+					fprintf3(stderr, ""child %X\n"",pss->child);
+					fprintf10(stderr, ""guid %.4X-%.4X-%.4X-%.4X %.4X-%.4X-%.4X-%.4X\n"",
+                            pss->guid[0],pss->guid[1],pss->guid[2],pss->guid[3],
 						pss->guid[4],pss->guid[5],pss->guid[6],pss->guid[7]);
-					printf(""user flag %.4X\n"",pss->userflags);
-					printf(""sstart %.4d\n"",pss->sstart);
-					printf(""size %.4d\n"",pss->size);
+					fprintf3(stderr, ""user flag %.4X\n"",pss->userflags);
+					fprintf3(stderr, ""sstart %.4d\n"",pss->sstart);
+					fprintf3(stderr, ""size %.4d\n"",pss->size);
 #endif
-			} else
-			if(pss->type == PS_USER_ROOT) {
+			} else if(pss->type == PS_USER_ROOT) {
 				DWORD sector, k, blocks;
 				BYTE *wptr;
 				
 				blocks = (pss->size + (ole->lsector - 1)) / ole->lsector;	// count partial
-				ole->SSAT = (BYTE *)malloc(blocks*ole->lsector);
+				if ((ole->SSAT = ole_malloc(blocks*ole->lsector)) == NULL) {
+                    total_bytes_read = -1;
+                    goto cleanup;
+                }
+                ole->SSATCount = blocks*ole->lsector;
 				// printf(""blocks %d\n"", blocks);
 
-				assert(ole->SSecID);
-				
 				sector = pss->sstart;
-				wptr=(BYTE*)ole->SSAT;
+				wptr = (BYTE*)ole->SSAT;
 				for(k=0; k<blocks; ++k) {
 					// printf(""block %d sector %d\n"", k, sector);
-					assert(sector != ENDOFCHAIN);
-					fseek(ole->file,sector*ole->lsector+512,0);
-					fread(wptr,1,ole->lsector,ole->file);
+                    if (sector == ENDOFCHAIN || sector_read(ole, wptr, sector) == -1) {
+                        if (xls_debug) fprintf3(stderr, ""Unable to read sector #%d\n"", sector);
+                        total_bytes_read = -1;
+                        goto cleanup;
+                    }
+                    total_bytes_read += ole->lsector;
 					wptr += ole->lsector;
 					sector = xlsIntVal(ole->SecID[sector]);
 				}
@@ -420,16 +480,72 @@ OLE2* ole2_open(const BYTE *file)
     }
     while (!olest->eof);
 
+cleanup:
 	ole2_fclose(olest);
     free(pss);
 
+    return total_bytes_read;
+}
+
+// Open in-memory buffer
+OLE2 *ole2_open_buffer(const void *buffer, size_t len) {
+    OLE2 *ole=(OLE2*)calloc(1, sizeof(OLE2));
+
+    ole->buffer = buffer;
+    ole->buffer_len = len;
+
+    if (ole2_read_header(ole) == -1) {
+        free(ole);
+        return NULL;
+    }
+
+    if (ole2_read_body(ole) == -1) {
+        free(ole);
+        return NULL;
+    }
+
+    return ole;
+}
+
+// Open physical file
+OLE2* ole2_open_file(const char *file)
+{
+    OLE2* ole = NULL;
+
+#ifdef OLE_DEBUG
+    fprintf2(stderr, ""----------------------------------------------\n"");
+    fprintf3(stderr, ""ole2_open_file %s\n"", file);
+#endif
+
+	if(xls_debug) printf(""ole2_open: %s\n"", file);
+    ole=(OLE2*)calloc(1, sizeof(OLE2));
+
+    if (!(ole->file=fopen(file, ""rb""))) {
+        if(xls_debug) fprintf2(stderr, ""File not found\n"");
+        free(ole);
+        return NULL;
+    }
+
+    if (ole2_read_header(ole) == -1) {
+		fclose(ole->file);
+        free(ole);
+        return NULL;
+    }
+
+    if (ole2_read_body(ole) == -1) {
+		fclose(ole->file);
+        free(ole);
+        return NULL;
+    }
+
     return ole;
 }
 
 void ole2_close(OLE2* ole2)
 {
     int i;
-	fclose(ole2->file);
+    if (ole2->file)
+        fclose(ole2->file);
 
 	for(i=0; i<ole2->files.count; ++i) {
 		free(ole2->files.file[i].name);
@@ -453,112 +569,187 @@ static size_t sector_pos(OLE2* ole2, size_t sid)
     return 512 + sid * ole2->lsector;
 }
 // Read one sector from its sid
-static int sector_read(OLE2* ole2, BYTE *buffer, size_t sid)
+static ssize_t sector_read(OLE2* ole2, void *buffer, size_t sid)
 {
 	size_t num;
 	size_t seeked;
 
 	//printf(""sector_read: sid=%zu (0x%zx) lsector=%u sector_pos=%zu\n"", sid, sid, ole2->lsector, sector_pos(ole2, sid) );
-    seeked = fseek(ole2->file, sector_pos(ole2, sid), SEEK_SET);
+    seeked = ole2_fseek(ole2, sector_pos(ole2, sid));
 	if(seeked != 0) {
-		printf(""seek: wanted to seek to sector %zu (0x%zx) loc=%zu\n"", sid, sid, sector_pos(ole2, sid));
-	}
-	assert(seeked == 0);
-	
-	num = fread(buffer, ole2->lsector, 1, ole2->file);
-	if(num != 1) {
-		fprintf(stderr, ""fread: wanted 1 got %zu loc=%zu\n"", num, sector_pos(ole2, sid));
-	}
-	assert(num == 1);
+		if (xls_debug) fprintf5(stderr, ""Error: wanted to seek to sector %zu (0x%zx) loc=%zu\n"", sid, sid, sector_pos(ole2, sid));
+        return -1;
+    }
 
-    return 0;
+	num = ole2_fread(ole2, buffer, ole2->lsector, 1);
+    if(num != 1) {
+        if (xls_debug) fprintf4(stderr, ""Error: fread wanted 1 got %zu loc=%zu\n"", num, sector_pos(ole2, sid));
+        return -1;
+    }
+
+    return ole2->lsector;
 }
 
-// Read MSAT
-static size_t read_MSAT(OLE2* ole2, OLE2Header* oleh)
-{
+// read first 109 sectors of MSAT from header
+static ssize_t read_MSAT_header(OLE2* ole2, OLE2Header* oleh, int sectorCount) {
+    BYTE *sector = (BYTE*)ole2->SecID;
+    ssize_t bytes_read = 0, total_bytes_read = 0;
     int sectorNum;
 
-    // reconstitution of the MSAT
-    ole2->SecID=malloc(ole2->cfat*ole2->lsector);
-
-    // read first 109 sectors of MSAT from header
+    for (sectorNum = 0; sectorNum < sectorCount; sectorNum++)
     {
-        int count;
-        count = (ole2->cfat < 109) ? ole2->cfat : 109;
-        for (sectorNum = 0; sectorNum < count; sectorNum++)
-        {
-			assert(sectorNum >= 0);
-            sector_read(ole2, (BYTE*)(ole2->SecID)+sectorNum*ole2->lsector, oleh->MSAT[sectorNum]);
+        if ((bytes_read = sector_read(ole2, sector, oleh->MSAT[sectorNum])) == -1) {
+            if (xls_debug) fprintf3(stderr, ""Error: Unable to read sector #%d\n"", oleh->MSAT[sectorNum]);
+            return -1;
         }
+        sector += ole2->lsector;
+        total_bytes_read += bytes_read;
     }
+    return total_bytes_read;
+}
 
-    // Add additionnal sectors of the MSAT
+// Add additional sectors of the MSAT
+static ssize_t read_MSAT_body(OLE2 *ole2, int sectorOffset, int sectorCount) {
+    DWORD sid = ole2->difstart;
+    ssize_t bytes_read = 0, total_bytes_read = 0;
+    int sectorNum = sectorOffset;
+
+    BYTE *sector = ole_malloc(ole2->lsector);
+    //printf(""sid=%u (0x%x) sector=%u\n"", sid, sid, ole2->lsector);
+    while (sid != ENDOFCHAIN && sid != FREESECT) // FREESECT only here due to an actual file that requires it (old Apple Numbers bug)
     {
-        DWORD sid = ole2->difstart;
+        int posInSector;
+        // read MSAT sector
+        if ((bytes_read = sector_read(ole2, sector, sid)) == -1) {
+            total_bytes_read = -1;
+            if (xls_debug) fprintf3(stderr, ""Error: Unable to read sector #%d\n"", sid);
+            goto cleanup;
+        }
+        total_bytes_read += bytes_read;
 
-		BYTE *sector = malloc(ole2->lsector);
-		//printf(""sid=%u (0x%x) sector=%u\n"", sid, sid, ole2->lsector);
-        while (sid != ENDOFCHAIN && sid != FREESECT) // FREESECT only here due to an actual file that requires it (old Apple Numbers bug)
-		{
-           int posInSector;
-           // read MSAT sector
-           sector_read(ole2, sector, sid);
-
-           // read content
-           for (posInSector = 0; posInSector < (ole2->lsector-4)/4; posInSector++)
-		   {
-              DWORD s = *(DWORD_UA *)(sector + posInSector*4);
-              //printf(""   s[%d]=%d (0x%x)\n"", posInSector, s, s);
-
-              if (s != FREESECT)
-                {
-                 sector_read(ole2, (BYTE*)(ole2->SecID)+sectorNum*ole2->lsector, s);
-                 sectorNum++;
+        // read content
+        for (posInSector = 0; posInSector < (ole2->lsector-4)/4; posInSector++)
+        {
+            DWORD s = *(DWORD_UA *)(sector + posInSector*4);
+            //printf(""   s[%d]=%d (0x%x)\n"", posInSector, s, s);
+
+            if (s != ENDOFCHAIN && s != FREESECT) // see patch in Bug 31. For very large files
+            {
+                if (sectorNum == sectorCount) {
+                    if (xls_debug) fprintf3(stderr, ""Error: Unable to seek to sector #%d\n"", s);
+                    total_bytes_read = -1;
+                    goto cleanup;
                 }
-			}
-			sid = *(DWORD_UA *)(sector + posInSector*4);
-			//printf(""   s[%d]=%d (0x%x)\n"", posInSector, sid, sid);
-		}
-		free(sector);
+                if ((bytes_read = sector_read(ole2, (BYTE*)(ole2->SecID)+sectorNum*ole2->lsector, s)) == -1) {
+                    if (xls_debug) fprintf3(stderr, ""Error: Unable to read sector #%d\n"", s);
+                    total_bytes_read = -1;
+                    goto cleanup;
+                }
+                total_bytes_read += bytes_read;
+                sectorNum++;
+            }
+        }
+        sid = *(DWORD_UA *)(sector + posInSector*4);
+        //printf(""   s[%d]=%d (0x%x)\n"", posInSector, sid, sid);
     }
 #ifdef OLE_DEBUG
-	if(xls_debug) {
-		//printf(""==== READ IN SECTORS FOR MSAT TABLE====\n"");
-		int i;
-		for(i=0; i<512/4; ++i) {	// just the first block
-			if(ole2->SecID[i] != FREESECT) printf(""SecID[%d]=%d\n"", i, ole2->SecID[i]);
-		}
-	}
-	//exit(0);
+    if(xls_debug) {
+        //printf(""==== READ IN SECTORS FOR MSAT TABLE====\n"");
+        int i;
+        for(i=0; i<512/4; ++i) {	// just the first block
+            if(ole2->SecID[i] != FREESECT) printf(""SecID[%d]=%d\n"", i, ole2->SecID[i]);
+        }
+    }
+    //exit(0);
 #endif
 
-	// read in short table
+cleanup:
+    free(sector);
+    return total_bytes_read;
+}
+
+// read in short table
+static ssize_t read_MSAT_trailer(OLE2 *ole2) {
+    ssize_t total_bytes_read = 0;
+    DWORD sector, k;
+    BYTE *wptr;
+
 	if(ole2->sfatstart != ENDOFCHAIN) {
-		DWORD sector, k;
-		BYTE *wptr;
-		
-		ole2->SSecID = (DWORD *)malloc(ole2->csfat*ole2->lsector);
+		if ((ole2->SSecID = ole_malloc(ole2->csfat*(size_t)ole2->lsector)) == NULL) {
+            return -1;
+        }
+        ole2->SSecIDCount = ole2->csfat*(size_t)ole2->lsector/4;
 		sector = ole2->sfatstart;
 		wptr=(BYTE*)ole2->SSecID;
 		for(k=0; k<ole2->csfat; ++k) {
-			assert(sector != ENDOFCHAIN);
-			fseek(ole2->file,sector*ole2->lsector+512,0);
-			fread(wptr,1,ole2->lsector,ole2->file);
+			if (sector == ENDOFCHAIN || sector_read(ole2, wptr, sector) == -1) {
+                total_bytes_read = -1;
+                goto cleanup;
+            }
 			wptr += ole2->lsector;
+            total_bytes_read += ole2->lsector;
 			sector = ole2->SecID[sector];
 		}
 #ifdef OLE_DEBUG
 		if(xls_debug) {
 			int i;
-			for(i=0; i<512/4; ++i) {
-				if(ole2->SSecID[i] != FREESECT) printf(""SSecID[%d]=%d\n"", i, ole2->SSecID[i]);
+			for(i=0; i<ole2->csfat; ++i) {
+				if(ole2->SSecID[i] != FREESECT) fprintf4(stderr, ""SSecID[%d]=%d\n"", i, ole2->SSecID[i]);
 			}
 		}
 #endif
 	}
 
-    return 0;
+cleanup:
+    return total_bytes_read;
 }
 
 
+// Read MSAT
+static ssize_t read_MSAT(OLE2* ole2, OLE2Header* oleh)
+{
+    // reconstitution of the MSAT
+    int count = (ole2->cfat < 109) ? ole2->cfat : 109;
+    if(count <= 0) {
+        if (xls_debug) fprintf2(stderr, ""Error: MSAT count out-of-bounds\n"");
+        return -1;
+    }
+
+    ssize_t total_bytes_read = 0;
+    ssize_t bytes_read = 0;
+
+    ole2->SecID = ole_malloc(count*ole2->lsector);
+    ole2->SecIDCount = count*ole2->lsector/4;
+
+    if ((bytes_read = read_MSAT_header(ole2, oleh, count)) == -1) {
+        total_bytes_read = -1;
+        goto cleanup;
+    }
+    total_bytes_read += bytes_read;
+
+    if ((bytes_read = read_MSAT_body(ole2, total_bytes_read / ole2->lsector, count)) == -1) {
+        total_bytes_read = -1;
+        goto cleanup;
+    }
+    total_bytes_read += bytes_read;
+
+    if ((bytes_read = read_MSAT_trailer(ole2)) == -1) {
+        total_bytes_read = -1;
+        goto cleanup;
+    }
+    total_bytes_read += bytes_read;
+
+cleanup:
+    if (total_bytes_read == -1) {
+        if (ole2->SecID) {
+            free(ole2->SecID);
+            ole2->SecID = NULL;
+        }
+        if (ole2->SSecID) {
+            free(ole2->SSecID);
+            ole2->SSecID = NULL;
+        }
+    }
+
+    return total_bytes_read;
+}

---FILE: src/xls.c---
@@ -41,7 +41,6 @@
 #include <sys/types.h>
 #include <string.h>
 #include <wchar.h>
-#include <assert.h>
 
 #include ""libxls/endian.h""
 #include ""libxls/xls.h""
@@ -50,29 +49,29 @@
 #define min(a,b) ((a) < (b) ? (a) : (b))
 #endif
 
-// #define DEBUG_DRAWINGS
+//#define DEBUG_DRAWINGS
 int xls_debug = 0;
 
 static double NumFromRk(DWORD_UA drk);
 static xls_formula_handler formula_handler;
 
-extern void xls_addSST(xlsWorkBook* pWB,SST* sst,DWORD size);
-extern void xls_appendSST(xlsWorkBook* pWB,BYTE* buf,DWORD size);
-extern void xls_addFormat(xlsWorkBook* pWB,FORMAT* format);
-extern BYTE* xls_addSheet(xlsWorkBook* pWB,BOUNDSHEET* bs);
-extern void xls_addRow(xlsWorkSheet* pWS,ROW* row);
-extern void xls_makeTable(xlsWorkSheet* pWS);
-extern struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf);
-extern BYTE *xls_addFont(xlsWorkBook* pWB,FONT* font);
-extern void xls_addXF8(xlsWorkBook* pWB,XF8* xf);
-extern void xls_addXF5(xlsWorkBook* pWB,XF5* xf);
-extern void xls_addColinfo(xlsWorkSheet* pWS,COLINFO* colinfo);
-extern void xls_mergedCells(xlsWorkSheet* pWS,BOF* bof,BYTE* buf);
-extern void xls_parseWorkBook(xlsWorkBook* pWB);
-extern void xls_preparseWorkSheet(xlsWorkSheet* pWS);
-extern void xls_formatColumn(xlsWorkSheet* pWS);
-extern void xls_parseWorkSheet(xlsWorkSheet* pWS);
-extern void xls_dumpSummary(char *buf,int isSummary,xlsSummaryInfo	*pSI);
+extern xls_error_t xls_addSST(xlsWorkBook* pWB, SST* sst, DWORD size);
+extern xls_error_t xls_appendSST(xlsWorkBook* pWB, BYTE* buf, DWORD size);
+extern xls_error_t xls_addFormat(xlsWorkBook* pWB, FORMAT* format, DWORD size);
+extern char* xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET* bs, DWORD size);
+extern xls_error_t xls_addRow(xlsWorkSheet* pWS,ROW* row);
+extern xls_error_t xls_makeTable(xlsWorkSheet* pWS);
+extern struct st_cell_data *xls_addCell(xlsWorkSheet* pWS, BOF* bof, BYTE* buf);
+extern char *xls_addFont(xlsWorkBook* pWB, FONT* font, DWORD size);
+extern xls_error_t xls_addXF8(xlsWorkBook* pWB, XF8* xf);
+extern xls_error_t xls_addXF5(xlsWorkBook* pWB, XF5* xf);
+extern xls_error_t xls_addColinfo(xlsWorkSheet* pWS, COLINFO* colinfo);
+extern xls_error_t xls_mergedCells(xlsWorkSheet* pWS, BOF* bof, BYTE* buf);
+extern xls_error_t xls_parseWorkBook(xlsWorkBook* pWB);
+extern xls_error_t xls_preparseWorkSheet(xlsWorkSheet* pWS);
+extern xls_error_t xls_formatColumn(xlsWorkSheet* pWS);
+extern xls_error_t xls_parseWorkSheet(xlsWorkSheet* pWS);
+extern void xls_dumpSummary(char *buf, int isSummary, xlsSummaryInfo *pSI);
 
 #if defined(_AIX) || defined(__sun)
 #pragma pack(1)
@@ -91,7 +90,7 @@ typedef struct {
 	uint32_t		os;
 	uint32_t		format[4];
 	uint32_t		count;
-	sectionList		secList[1];
+	sectionList		secList[0];
 } header;
 
 typedef struct {
@@ -102,12 +101,12 @@ typedef struct {
 typedef struct {
 	uint32_t		length;
 	uint32_t		numProperties;
-	propertyList	properties[1];
+	propertyList	properties[0];
 } sectionHeader;
 
 typedef struct {
 	uint32_t		propertyID;
-	uint32_t		data[1];
+	uint32_t		data[0];
 } property;
 
 #ifdef DEBUG_DRAWINGS
@@ -134,7 +133,7 @@ int xls(int debug)
     return 1;
 }
 
-void xls_addSST(xlsWorkBook* pWB,SST* sst,DWORD size)
+xls_error_t xls_addSST(xlsWorkBook* pWB,SST* sst,DWORD size)
 {
     verbose(""xls_addSST"");
 
@@ -145,18 +144,20 @@ void xls_addSST(xlsWorkBook* pWB,SST* sst,DWORD size)
     pWB->sst.lastsz=0;
 
     pWB->sst.count = sst->num;
-    pWB->sst.string =(struct str_sst_string *)calloc(pWB->sst.count, sizeof(struct str_sst_string));
-    xls_appendSST(pWB,&sst->strings,size-8);
+    if ((pWB->sst.string = calloc(pWB->sst.count, sizeof(struct str_sst_string))) == NULL)
+        return LIBXLS_ERROR_MALLOC;
+
+    return xls_appendSST(pWB, sst->strings, size - sizeof(SST));
 }
 
-void xls_appendSST(xlsWorkBook* pWB,BYTE* buf,DWORD size)
+xls_error_t xls_appendSST(xlsWorkBook* pWB, BYTE* buf, DWORD size)
 {
     DWORD ln;	// String character count
     DWORD ofs;	// Current offset in SST buffer
     DWORD rt;	// Count of rich text formatting runs
     DWORD sz;	// Size of asian phonetic settings block
     BYTE flag;	// String flags
-    BYTE* ret;
+    char* ret = NULL;
 
     if (xls_debug) {
 	    printf(""xls_appendSST %u\n"", size);
@@ -171,14 +172,14 @@ void xls_appendSST(xlsWorkBook* pWB,BYTE* buf,DWORD size)
 
         // Restore state when we're in a continue record
         // or read string length
-        if (pWB->sst.continued)
-        {
+        if (pWB->sst.continued) {
             ln=pWB->sst.lastln;
             rt=pWB->sst.lastrt;
             sz=pWB->sst.lastsz;
-        }
-        else
-        {
+        } else {
+            if (ofs + 2 > size) {
+                return LIBXLS_ERROR_PARSE;
+            }
             ln=xlsShortVal(*(WORD_UA *)(buf+ofs));
             rt = 0;
             sz = 0;
@@ -191,95 +192,99 @@ void xls_appendSST(xlsWorkBook* pWB,BYTE* buf,DWORD size)
 		}
 
         // Read flags
-        if ( (!pWB->sst.continued) || ( (pWB->sst.continued) && (ln != 0) ) )
-        {
+        if ( !pWB->sst.continued || (pWB->sst.continued && ln != 0) ) {
+            if (ofs + sizeof(BYTE) > size) {
+                return LIBXLS_ERROR_PARSE;
+            }
             flag=*(BYTE *)(buf+ofs);
             ofs++;
 
             // Count of rich text formatting runs
-            if (flag & 0x8)
-            {
+            if (flag & 0x8) {
+                if (ofs + sizeof(WORD_UA) > size) {
+                    return LIBXLS_ERROR_PARSE;
+                }
                 rt=xlsShortVal(*(WORD_UA *)(buf+ofs));
                 ofs+=2;
             }
 
             // Size of asian phonetic settings block
-            if (flag & 0x4)
-            {
+            if (flag & 0x4) {
+                if (ofs + sizeof(DWORD_UA) > size) {
+                    return LIBXLS_ERROR_PARSE;
+                }
                 sz=xlsIntVal(*(DWORD_UA *)(buf+ofs));
                 ofs+=4;
 
 				if (xls_debug) {
 					printf(""sz=%u\n"", sz);
 				}
             }
-        }
-        else
-        {
+        } else {
             flag = 0;
         }
 
 		// Read characters (compressed or not)
         ln_toread = 0;
-        if (ln > 0)
-        {
-            if (flag & 0x1)
-            {
+        if (ln > 0) {
+            if (flag & 0x1) {
                 size_t new_len = 0;
                 ln_toread = min((size-ofs)/2, ln);
-                ret=unicode_decode(buf+ofs,ln_toread*2,&new_len,pWB->charset);
+                ret=unicode_decode((char *)buf+ofs,ln_toread*2,&new_len,pWB->charset);
 
                 if (ret == NULL)
                 {
-                    ret = (BYTE *)strdup(""*failed to decode utf16*"");
-                    new_len = strlen((char *)ret);
+                    ret = strdup(""*failed to decode utf16*"");
+                    new_len = strlen(ret);
                 }
 
-                ret = (BYTE *)realloc(ret,new_len+1);
-                *(BYTE*)(ret+new_len)=0;
+                ret = realloc(ret,new_len+1);
+                ret[new_len]=0;
 
                 ln -= ln_toread;
                 ofs+=ln_toread*2;
 
                 if (xls_debug) {
 	                printf(""String16SST: %s(%zd)\n"",ret,new_len);
                 }
-            }
-            else
-            {
+            } else {
                 ln_toread = min((size-ofs), ln);
 
-				ret = utf8_decode((buf+ofs), ln_toread, pWB->charset);
+				ret = utf8_decode((char *)buf+ofs, ln_toread, pWB->charset);
 
                 ln  -= ln_toread;
-                ofs +=ln_toread;
+                ofs += ln_toread;
 
                 if (xls_debug) {
                 	printf(""String8SST: %s(%u) \n"",ret,ln);
                 }
             }
-        }
-        else
-        {
-         ret = (BYTE *)strdup("""");
+        } else {
+            ret = strdup("""");
         }
 
-        if (  (ln_toread > 0)
-            ||(!pWB->sst.continued) )
-        {
+        if (ln_toread > 0 || !pWB->sst.continued) {
             // Concat string if it's a continue, or add string in table
-            if (!pWB->sst.continued)
-            {
+            if (!pWB->sst.continued) {
+                if (pWB->sst.lastid >= pWB->sst.count) {
+                    free(ret);
+                    return LIBXLS_ERROR_PARSE;
+                }
                 pWB->sst.lastid++;
                 pWB->sst.string[pWB->sst.lastid-1].str=ret;
-            }
-            else
-            {
-                BYTE *tmp;
-                tmp=pWB->sst.string[pWB->sst.lastid-1].str;
-                tmp=(BYTE *)realloc(tmp,strlen((char *)tmp)+strlen((char *)ret)+1);
+            } else {
+                char *tmp = pWB->sst.string[pWB->sst.lastid-1].str;
+                if (tmp == NULL) {
+                    free(ret);
+                    return LIBXLS_ERROR_PARSE;
+                }
+                tmp = realloc(tmp, strlen(tmp)+strlen(ret)+1);
+                if (tmp == NULL)  {
+                    free(ret);
+                    return LIBXLS_ERROR_MALLOC;
+                }
                 pWB->sst.string[pWB->sst.lastid-1].str=tmp;
-                memcpy(tmp+strlen((char *)tmp),ret,strlen((char *)ret)+1);
+                memcpy(tmp+strlen(tmp), ret, strlen(ret)+1);
 				free(ret);
             }
 
@@ -289,22 +294,18 @@ void xls_appendSST(xlsWorkBook* pWB,BYTE* buf,DWORD size)
         }
 
 		// Jump list of rich text formatting runs
-        if (  (ofs < size)
-            &&(rt > 0) )
-          {
-           int rt_toread = min((size-ofs)/4, rt);
-           rt -= rt_toread;
-           ofs += rt_toread*4;
-          }
+        if (ofs < size && rt > 0) {
+            int rt_toread = min((size-ofs)/4, rt);
+            rt -= rt_toread;
+            ofs += rt_toread*4;
+        }
 
 		// Jump asian phonetic settings block
-        if (  (ofs < size)
-            &&(sz > 0) )
-          {
-           int sz_toread = min((size-ofs), sz);
-           sz -= sz_toread;
-           ofs += sz_toread;
-          }
+        if (ofs < size && sz > 0) {
+            int sz_toread = min((size-ofs), sz);
+            sz -= sz_toread;
+            ofs += sz_toread;
+        }
 
         pWB->sst.continued=0;
     }
@@ -320,6 +321,8 @@ void xls_appendSST(xlsWorkBook* pWB,BYTE* buf,DWORD size)
 			printf(""continued: ln=%u, rt=%u, sz=%u\n"", ln, rt, sz);
 		}
 	}
+
+    return LIBXLS_OK;
 }
 
 static double NumFromRk(DWORD_UA drk)
@@ -344,9 +347,9 @@ static double NumFromRk(DWORD_UA drk)
     return ret;
 }
 
-BYTE* xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET *bs)
+char * xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET *bs, DWORD size)
 {
-	BYTE* name;
+	char * name;
 	DWORD filepos;
 	BYTE visible, type;
 
@@ -356,7 +359,7 @@ BYTE* xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET *bs)
 
 	// printf(""charset=%s uni=%d\n"", pWB->charset, unicode);
 	// printf(""bs name %.*s\n"", bs->name[0], bs->name+1);
-	name=get_string(bs->name, 0, pWB->is5ver, pWB->charset);
+	name = get_string(bs->name, size - sizeof(BOUNDSHEET), 0, pWB->is5ver, pWB->charset);
 	// printf(""name=%s\n"", name);
 
 	if(xls_debug) {
@@ -389,14 +392,10 @@ BYTE* xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET *bs)
 		printf(""   name: %s\n"", name);
 	}
 
-    if (pWB->sheets.count==0)
-    {
-        pWB->sheets.sheet=(struct st_sheet_data *) malloc(sizeof (struct st_sheet_data));
-    }
-    else
-    {
-        pWB->sheets.sheet=(struct st_sheet_data *) realloc(pWB->sheets.sheet,(pWB->sheets.count+1)*sizeof (struct st_sheet_data));
-    }
+    pWB->sheets.sheet = realloc(pWB->sheets.sheet,(pWB->sheets.count+1)*sizeof (struct st_sheet_data));
+    if (pWB->sheets.sheet == NULL)
+        return NULL;
+
     pWB->sheets.sheet[pWB->sheets.count].name=name;
     pWB->sheets.sheet[pWB->sheets.count].filepos=filepos;
     pWB->sheets.sheet[pWB->sheets.count].visibility=visible;
@@ -407,12 +406,15 @@ BYTE* xls_addSheet(xlsWorkBook* pWB, BOUNDSHEET *bs)
 }
 
 
-void xls_addRow(xlsWorkSheet* pWS,ROW* row)
+xls_error_t xls_addRow(xlsWorkSheet* pWS,ROW* row)
 {
     struct st_row_data* tmp;
 
     //verbose (""xls_addRow"");
 
+    if (row->index > pWS->rows.lastrow)
+        return LIBXLS_ERROR_PARSE;
+
     tmp=&pWS->rows.row[row->index];
     tmp->height=row->height;
     tmp->fcell=row->fcell;
@@ -421,15 +423,18 @@ void xls_addRow(xlsWorkSheet* pWS,ROW* row)
     tmp->xf=row->xf&0xfff;
     tmp->xfflags=(row->xf >> 8)&0xf0;
     if(xls_debug) xls_showROW(tmp);
+
+    return LIBXLS_OK;
 }
 
-void xls_makeTable(xlsWorkSheet* pWS)
+xls_error_t xls_makeTable(xlsWorkSheet* pWS)
 {
     DWORD i,t;
     struct st_row_data* tmp;
     verbose (""xls_makeTable"");
 
-    pWS->rows.row=(struct st_row_data *)calloc((pWS->rows.lastrow+1),sizeof(struct st_row_data));
+    if ((pWS->rows.row = calloc((pWS->rows.lastrow+1),sizeof(struct st_row_data))) == NULL)
+        return LIBXLS_ERROR_MALLOC;
 
 	// printf(""ALLOC: rows=%d cols=%d\n"", pWS->rows.lastrow, pWS->rows.lastcol);
     for (t=0;t<=pWS->rows.lastrow;t++)
@@ -440,7 +445,8 @@ void xls_makeTable(xlsWorkSheet* pWS)
         tmp->lcell=pWS->rows.lastcol;
 
 		tmp->cells.count = pWS->rows.lastcol+1;
-        tmp->cells.cell=(struct st_cell_data *)calloc(tmp->cells.count,sizeof(struct st_cell_data));
+        if ((tmp->cells.cell = calloc(tmp->cells.count,sizeof(struct st_cell_data))) == NULL)
+            return LIBXLS_ERROR_MALLOC;
 
         for (i=0;i<=pWS->rows.lastcol;i++)
         {
@@ -458,6 +464,7 @@ void xls_makeTable(xlsWorkSheet* pWS)
             tmp->cells.cell[i].str=NULL;
         }
     }
+    return LIBXLS_OK;
 }
 
 struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
@@ -468,6 +475,9 @@ struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
 
 	verbose (""xls_addCell"");
 
+    if (bof->size < sizeof(COL))
+        return NULL;
+
 	// printf(""ROW: %u COL: %u\n"", xlsShortVal(((COL*)buf)->row), xlsShortVal(((COL*)buf)->col));
     row=&pWS->rows.row[xlsShortVal(((COL*)buf)->row)];
     //cell=&row->cells.cell[((COL*)buf)->col - row->fcell]; DFH - inconsistent
@@ -479,7 +489,9 @@ struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
     {
     case XLS_RECORD_FORMULA:
     case XLS_RECORD_FORMULA_ALT:
-		// test for formula, if
+        if (bof->size < sizeof(FORMULA))
+            return NULL;
+
 		xlsConvertFormula((FORMULA *)buf);
         cell->id=XLS_RECORD_FORMULA;
         if (((FORMULA*)buf)->res!=0xffff) {
@@ -488,8 +500,8 @@ struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
 			memcpy(&cell->d, &((FORMULA*)buf)->resid, sizeof(double));	// Required for ARM
 			cell->str=xls_getfcell(pWS->workbook,cell, NULL);
 		} else {
-			cell->l = 0xFFFF;
 			double d = ((FORMULA*)buf)->resdata[1];
+			cell->l = 0xFFFF;
 			switch(((FORMULA*)buf)->resid) {
 			case 0:		// String
 				break;	// cell is half complete, get the STRING next record
@@ -509,7 +521,8 @@ struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
 		if(formula_handler) formula_handler(bof->id, bof->size, buf);
         break;
     case XLS_RECORD_MULRK:
-// printf(""MULRK: %d\n"", bof->size);
+        if (bof->size < sizeof(MULRK))
+            return NULL;
         for (i = 0; i < (bof->size - 6)/6; i++)	// 6 == 2 row + 2 col + 2 trailing index
         {
             cell=&row->cells.cell[xlsShortVal(((MULRK*)buf)->col + i)];
@@ -521,32 +534,49 @@ struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
         }
         break;
     case XLS_RECORD_MULBLANK:
+        if (bof->size < sizeof(MULBLANK))
+            return NULL;
         for (i = 0; i < (bof->size - 6)/2; i++)	// 6 == 2 row + 2 col + 2 trailing index
         {
-            cell=&row->cells.cell[xlsShortVal(((MULBLANK*)buf)->col) + i];
+            WORD index = xlsShortVal(((MULBLANK*)buf)->col) + i;
+            if(index >= row->cells.count) {
+                if (xls_debug) fprintf2(stderr, ""Error: MULTI-BLANK index out of bounds\n"");
+                return NULL;
+            }
+            cell=&row->cells.cell[index];
             cell->id=XLS_RECORD_BLANK;
             cell->xf=xlsShortVal(((MULBLANK*)buf)->xf[i]);
             cell->str=xls_getfcell(pWS->workbook,cell, NULL);
         }
         break;
     case XLS_RECORD_LABELSST:
     case XLS_RECORD_LABEL:
-		cell->str=xls_getfcell(pWS->workbook,cell,(BYTE *)&((LABEL*)buf)->value);
-		sscanf((char *)cell->str, ""%d"", &cell->l);
-		sscanf((char *)cell->str, ""%lf"", &cell->d);
+        if (bof->size < sizeof(LABEL))
+            return NULL;
+		cell->str = xls_getfcell(pWS->workbook, cell, ((LABEL*)buf)->value);
+        if (cell->str) {
+            sscanf((char *)cell->str, ""%d"", &cell->l);
+            sscanf((char *)cell->str, ""%lf"", &cell->d);
+        }
 		break;
     case XLS_RECORD_RK:
+        if (bof->size < sizeof(RK))
+            return NULL;
         cell->d=NumFromRk(xlsIntVal(((RK*)buf)->value));
         cell->str=xls_getfcell(pWS->workbook,cell, NULL);
         break;
     case XLS_RECORD_BLANK:
         break;
     case XLS_RECORD_NUMBER:
+        if (bof->size < sizeof(BR_NUMBER))
+            return NULL;
         xlsConvertDouble((BYTE *)&((BR_NUMBER*)buf)->value);
 		memcpy(&cell->d, &((BR_NUMBER*)buf)->value, sizeof(double)); // Required for ARM
         cell->str=xls_getfcell(pWS->workbook,cell, NULL);
         break;
     case XLS_RECORD_BOOLERR:
+        if (bof->size < sizeof(BOOLERR))
+            return NULL;
         cell->d = ((BOOLERR *)buf)->value;
         if (((BOOLERR *)buf)->iserror) {
             sprintf((char *)(cell->str = malloc(sizeof(""error""))), ""error"");
@@ -563,21 +593,19 @@ struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
 	return cell;
 }
 
-BYTE *xls_addFont(xlsWorkBook* pWB, FONT* font)
+char *xls_addFont(xlsWorkBook* pWB, FONT* font, DWORD size)
 {
     struct st_font_data* tmp;
 
     verbose(""xls_addFont"");
-    if (pWB->fonts.count==0)
-    {
-        pWB->fonts.font=(struct st_font_data *) malloc(sizeof(struct st_font_data));
-    } else {
-        pWB->fonts.font=(struct st_font_data *) realloc(pWB->fonts.font,(pWB->fonts.count+1)*sizeof(struct st_font_data));
-    }
+
+    pWB->fonts.font = realloc(pWB->fonts.font,(pWB->fonts.count+1)*sizeof(struct st_font_data));
+    if (pWB->fonts.font == NULL)
+        return NULL;
 
     tmp=&pWB->fonts.font[pWB->fonts.count];
 
-    tmp->name=get_string((BYTE*)&font->name, 0, pWB->is5ver, pWB->charset);
+    tmp->name = get_string(font->name, size - sizeof(FONT), 0, pWB->is5ver, pWB->charset);
 
     tmp->height=font->height;
     tmp->flag=font->flag;
@@ -594,38 +622,32 @@ BYTE *xls_addFont(xlsWorkBook* pWB, FONT* font)
 	return tmp->name;
 }
 
-void xls_addFormat(xlsWorkBook* pWB, FORMAT* format)
+xls_error_t xls_addFormat(xlsWorkBook* pWB, FORMAT* format, DWORD size)
 {
     struct st_format_data* tmp;
 
     verbose(""xls_addFormat"");
-    if (pWB->formats.count==0)
-    {
-        pWB->formats.format=(struct st_format_data *) malloc(sizeof(struct st_format_data));
-    } else {
-        pWB->formats.format=(struct st_format_data *) realloc(pWB->formats.format,(pWB->formats.count+1)*sizeof(struct st_format_data));
-    }
+    pWB->formats.format = realloc(pWB->formats.format, (pWB->formats.count+1)*sizeof(struct st_format_data));
+    if (pWB->formats.format == NULL)
+        return LIBXLS_ERROR_MALLOC;
 
-    tmp=&pWB->formats.format[pWB->formats.count];
-    tmp->index=format->index;
-    tmp->value=get_string(format->value, (BYTE)!pWB->is5ver, (BYTE)pWB->is5ver, pWB->charset);
+    tmp = &pWB->formats.format[pWB->formats.count];
+    tmp->index = format->index;
+    tmp->value = get_string(format->value, size - sizeof(FORMAT), (BYTE)!pWB->is5ver, (BYTE)pWB->is5ver, pWB->charset);
     if(xls_debug) xls_showFormat(tmp);
     pWB->formats.count++;
+
+    return LIBXLS_OK;
 }
 
-void xls_addXF8(xlsWorkBook* pWB,XF8* xf)
+xls_error_t xls_addXF8(xlsWorkBook* pWB,XF8* xf)
 {
     struct st_xf_data* tmp;
 
     verbose(""xls_addXF"");
-    if (pWB->xfs.count==0)
-    {
-        pWB->xfs.xf=(struct st_xf_data *) malloc(sizeof(struct st_xf_data));
-    }
-    else
-    {
-        pWB->xfs.xf=(struct st_xf_data *) realloc(pWB->xfs.xf,(pWB->xfs.count+1)*sizeof(struct st_xf_data));
-    }
+    pWB->xfs.xf= realloc(pWB->xfs.xf, (pWB->xfs.count+1)*sizeof(struct st_xf_data));
+    if (pWB->xfs.xf == NULL)
+        return LIBXLS_ERROR_MALLOC;
 
     tmp=&pWB->xfs.xf[pWB->xfs.count];
 
@@ -642,20 +664,18 @@ void xls_addXF8(xlsWorkBook* pWB,XF8* xf)
 
     //	xls_showXF(tmp);
     pWB->xfs.count++;
+
+    return LIBXLS_OK;
 }
-void xls_addXF5(xlsWorkBook* pWB,XF5* xf)
+
+xls_error_t xls_addXF5(xlsWorkBook* pWB,XF5* xf)
 {
     struct st_xf_data* tmp;
 
     verbose(""xls_addXF"");
-    if (pWB->xfs.count==0)
-    {
-        pWB->xfs.xf=(struct st_xf_data *) malloc(sizeof(struct st_xf_data));
-    }
-    else
-    {
-        pWB->xfs.xf=(struct st_xf_data *) realloc(pWB->xfs.xf,(pWB->xfs.count+1)*sizeof(struct st_xf_data));
-    }
+    pWB->xfs.xf = realloc(pWB->xfs.xf, (pWB->xfs.count+1)*sizeof(struct st_xf_data));
+    if (pWB->xfs.xf == NULL)
+        return LIBXLS_ERROR_MALLOC;
 
     tmp=&pWB->xfs.xf[pWB->xfs.count];
 
@@ -674,21 +694,17 @@ void xls_addXF5(xlsWorkBook* pWB,XF5* xf)
 
     //	xls_showXF(tmp);
     pWB->xfs.count++;
+    return LIBXLS_OK;
 }
 
-void xls_addColinfo(xlsWorkSheet* pWS,COLINFO* colinfo)
+xls_error_t xls_addColinfo(xlsWorkSheet* pWS,COLINFO* colinfo)
 {
     struct st_colinfo_data* tmp;
 
     verbose(""xls_addColinfo"");
-    if (pWS->colinfo.count==0)
-    {
-        pWS->colinfo.col=(struct st_colinfo_data *) malloc(sizeof(struct st_colinfo_data));
-    }
-    else
-    {
-        pWS->colinfo.col=(struct st_colinfo_data *) realloc(pWS->colinfo.col,(pWS->colinfo.count+1)*sizeof(struct st_colinfo_data));
-    }
+    pWS->colinfo.col =  realloc(pWS->colinfo.col,(pWS->colinfo.count+1)*sizeof(struct st_colinfo_data));
+    if (pWS->colinfo.col == NULL)
+        return LIBXLS_ERROR_MALLOC;
 
     tmp=&pWS->colinfo.col[pWS->colinfo.count];
     tmp->first=colinfo->first;
@@ -699,89 +715,126 @@ void xls_addColinfo(xlsWorkSheet* pWS,COLINFO* colinfo)
 
     if(xls_debug) xls_showColinfo(tmp);
     pWS->colinfo.count++;
+
+    return LIBXLS_OK;
 }
 
-void xls_mergedCells(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
+xls_error_t xls_mergedCells(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
 {
+    if (bof->size < sizeof(WORD_UA))
+        return LIBXLS_ERROR_PARSE;
+
     int count=xlsShortVal(*((WORD_UA *)buf));
+    DWORD limit = sizeof(WORD_UA)+count*sizeof(struct MERGEDCELLS);
+    if(limit > (DWORD)bof->size) {
+        verbose(""Merged Cells Count out of range"");
+        return LIBXLS_ERROR_PARSE;
+    }
     int i,c,r;
-    struct MERGEDCELLS* span;
+    struct MERGEDCELLS *span;
     verbose(""Merged Cells"");
     for (i=0;i<count;i++)
     {
         span=(struct MERGEDCELLS*)(buf+(2+i*sizeof(struct MERGEDCELLS)));
         xlsConvertMergedcells(span);
         //		printf(""Merged Cells: [%i,%i] [%i,%i] \n"",span->colf,span->rowf,span->coll,span->rowl);
+        // Sanity check:
+        if(!(   span->rowf <= span->rowl &&
+                span->rowl <= pWS->rows.lastrow &&
+                span->colf <= span->coll &&
+                span->coll <= pWS->rows.lastcol
+        )) {
+            return LIBXLS_ERROR_PARSE;
+        }
+
         for (r=span->rowf;r<=span->rowl;r++)
             for (c=span->colf;c<=span->coll;c++)
                 pWS->rows.row[r].cells.cell[c].isHidden=1;
         pWS->rows.row[span->rowf].cells.cell[span->colf].colspan=(span->coll-span->colf+1);
         pWS->rows.row[span->rowf].cells.cell[span->colf].rowspan=(span->rowl-span->rowf+1);
         pWS->rows.row[span->rowf].cells.cell[span->colf].isHidden=0;
     }
+    return LIBXLS_OK;
 }
 
-void xls_parseWorkBook(xlsWorkBook* pWB)
+xls_error_t xls_parseWorkBook(xlsWorkBook* pWB)
 {
-    BOF bof1;
-    BOF bof2;
-    BYTE* buf;
-	BYTE once;
-
-	// this to prevent compiler warnings
-	once=0;
-	bof2.size = 0;
-	bof2.id = 0;
+    BOF bof1 = { 0 };
+    BOF bof2 = { 0 };
+    BYTE* buf = NULL;
+	BYTE once = 0;
+    xls_error_t retval = LIBXLS_OK;
+
     verbose (""xls_parseWorkBook"");
-    do
-    {
+    do {
 		if(xls_debug > 10) {
 			printf(""READ WORKBOOK filePos=%ld\n"",  (long)pWB->filepos);
-			printf(""  OLE: start=%d pos=%zd size=%zd fatPos=%zu\n"", pWB->olestr->start, pWB->olestr->pos, pWB->olestr->size, pWB->olestr->fatpos);
+			printf(""  OLE: start=%d pos=%zd size=%zd fatPos=%zu\n"",
+                    pWB->olestr->start, pWB->olestr->pos, pWB->olestr->size, pWB->olestr->fatpos); 
 		}
 
-        ole2_read(&bof1, 1, 4, pWB->olestr);
+        if (ole2_read(&bof1, 1, 4, pWB->olestr) != 4) {
+            retval = LIBXLS_ERROR_READ;
+            goto cleanup;
+        }
         xlsConvertBof(&bof1);
  		if(xls_debug) xls_showBOF(&bof1);
 
-        buf=(BYTE *)malloc(bof1.size);
-        ole2_read(buf, 1, bof1.size, pWB->olestr);
+        if (bof1.size) {
+            if ((buf = realloc(buf, bof1.size)) == NULL) {
+                if (xls_debug) fprintf3(stderr, ""Error: failed to allocate buffer of size %d\n"", (int)bof1.size);
+                retval = LIBXLS_ERROR_MALLOC;
+                goto cleanup;
+            }
+            if (ole2_read(buf, 1, bof1.size, pWB->olestr) != bof1.size) {
+                if (xls_debug) fprintf2(stderr, ""Error: failed to read OLE block\n"");
+                retval = LIBXLS_ERROR_READ;
+                goto  cleanup;
+            }
+        }
 
         switch (bof1.id) {
         case XLS_RECORD_EOF:
             //verbose(""EOF"");
             break;
         case XLS_RECORD_BOF:	// BIFF5-8
-			{
-				BIFF *b = (BIFF*)buf;
-                xlsConvertBiff(b);
-				if (b->ver==0x600)
-					pWB->is5ver=0;
-				else
-					pWB->is5ver=1;
-				pWB->type=b->type;
+            if (bof1.size < 2 * sizeof(WORD)) {
+                retval = LIBXLS_ERROR_PARSE;
+                goto cleanup;
+            }
+            pWB->is5ver = (xlsShortVal(*(WORD *)&buf[0]) != 0x600);
+            pWB->type = xlsShortVal(*(WORD *)&buf[2]);
 
-				if(xls_debug) {
-					printf(""version: %s\n"", pWB->is5ver ? ""BIFF5"" : ""BIFF8"" );
-					printf(""   type: %.2X\n"", pWB->type);
-				}
-			}
+            if(xls_debug) {
+                printf(""version: %s\n"", pWB->is5ver ? ""BIFF5"" : ""BIFF8"" );
+                printf(""   type: %.2X\n"", pWB->type);
+            }
             break;
 
         case XLS_RECORD_CODEPAGE:
+            if (bof1.size < sizeof(WORD_UA)) {
+                retval = LIBXLS_ERROR_PARSE;
+                goto cleanup;
+            }
             pWB->codepage=xlsShortVal(*(WORD_UA *)buf);
 			if(xls_debug) printf(""codepage=%x\n"", pWB->codepage);
             break;
 
         case XLS_RECORD_CONTINUE:
 			if(once) {
-				if (bof2.id==XLS_RECORD_SST)
-					xls_appendSST(pWB,buf,bof1.size);
+				if (bof2.id==XLS_RECORD_SST) {
+					if ((retval = xls_appendSST(pWB,buf,bof1.size)) != LIBXLS_OK)
+                        goto cleanup;
+                }
 				bof1=bof2;
 			}
             break;
 
 		case XLS_RECORD_WINDOW1:
+            if (bof1.size < sizeof(WIND1)) {
+                retval = LIBXLS_ERROR_PARSE;
+                goto cleanup;
+            }
 			{
 				WIND1 *w = (WIND1*)buf;
                 xlsConvertWindow(w);
@@ -802,34 +855,50 @@ void xls_parseWorkBook(xlsWorkBook* pWB)
 			break;
 
         case XLS_RECORD_SST:
+            if (bof1.size < sizeof(SST)) {
+                retval = LIBXLS_ERROR_PARSE;
+                goto cleanup;
+            }
 			//printf(""ADD SST\n"");
 			//if(xls_debug) dumpbuf((BYTE *)""/tmp/SST"",bof1.size,buf);
             xlsConvertSst((SST *)buf);
-            xls_addSST(pWB,(SST*)buf,bof1.size);
+            if ((retval = xls_addSST(pWB,(SST*)buf,bof1.size)) != LIBXLS_OK) {
+                goto cleanup;
+            }
             break;
 
         case XLS_RECORD_EXTSST:
             //if(xls_debug > 1000) dumpbuf((BYTE *)""/tmp/EXTSST"",bof1.size,buf);
             break;
 
         case XLS_RECORD_BOUNDSHEET:
+            if (bof1.size < sizeof(BOUNDSHEET)) {
+                retval = LIBXLS_ERROR_PARSE;
+                goto cleanup;
+            }
 			{
 				//printf(""ADD SHEET\n"");
 				BOUNDSHEET *bs = (BOUNDSHEET *)buf;
                 xlsConvertBoundsheet(bs);
 				//char *s;
 				// different for BIFF5 and BIFF8
-				/*s = */ xls_addSheet(pWB,bs);
+				/*s = */ xls_addSheet(pWB, bs, bof1.size);
 			}
             break;
 
         case XLS_RECORD_XF:
 			if(pWB->is5ver) {
+                if (bof1.size < sizeof(XF5)) {
+                    retval = LIBXLS_ERROR_PARSE;
+                    goto cleanup;
+                }
 				XF5 *xf;
 				xf = (XF5 *)buf;
                 xlsConvertXf5(xf);
 
-				xls_addXF5(pWB,xf);
+				if ((retval = xls_addXF5(pWB,xf)) != LIBXLS_OK) {
+                    goto cleanup;
+                }
 				if(xls_debug) {
 					printf(""   font: %d\n"", xf->font);
 					printf("" format: %d\n"", xf->format);
@@ -841,11 +910,18 @@ void xls_parseWorkBook(xlsWorkBook* pWB)
 					printf(""linesty: %.4x\n"", xf->linestyle);
 				}
 			} else {
+                if (bof1.size < sizeof(XF8)) {
+                    retval = LIBXLS_ERROR_PARSE;
+                    goto cleanup;
+                }
 				XF8 *xf;
 				xf = (XF8 *)buf;
                 xlsConvertXf8(xf);
 
-				xls_addXF8(pWB,xf);
+				if ((retval = xls_addXF8(pWB,xf)) != LIBXLS_OK) {
+                    goto cleanup;
+                }
+
 				if(xls_debug) {
 					xls_showXF(xf);
 				}
@@ -854,11 +930,15 @@ void xls_parseWorkBook(xlsWorkBook* pWB)
 
         case XLS_RECORD_FONT:
         case XLS_RECORD_FONT_ALT:
+            if (bof1.size < sizeof(FONT)) {
+                retval = LIBXLS_ERROR_PARSE;
+                goto cleanup;
+            }
 			{
-				BYTE *s;
+				char *s;
 				FONT *f = (FONT*)buf;
                 xlsConvertFont(f);
-				s = xls_addFont(pWB,f);
+				s = xls_addFont(pWB,f, bof1.size);
 				if(xls_debug) {
 					printf("" height: %d\n"", f->height);
 					printf(""   flag: 0x%x\n"", f->flag);
@@ -874,8 +954,14 @@ void xls_parseWorkBook(xlsWorkBook* pWB)
 			break;
 
         case XLS_RECORD_FORMAT:
+            if (bof1.size < sizeof(FORMAT)) {
+                retval = LIBXLS_ERROR_PARSE;
+                goto cleanup;
+            }
             xlsConvertFormat((FORMAT *)buf);
-            xls_addFormat(pWB,(FORMAT*)buf);
+            if ((retval = xls_addFormat(pWB, (FORMAT*)buf, bof1.size)) != LIBXLS_OK) {
+                goto cleanup;
+            }
             break;
 
 		case XLS_RECORD_STYLE:
@@ -888,7 +974,7 @@ void xls_parseWorkBook(xlsWorkBook* pWB)
 					printf(""  ident: 0x%x\n"", styl->ident);
 					printf(""  level: 0x%x\n"", styl->lvl);
 				} else {
-					BYTE *s = get_string(&buf[2], 1, pWB->is5ver, pWB->charset);
+					char *s = get_string((char *)&buf[2], bof1.size - 2, 1, pWB->is5ver, pWB->charset);
 					printf(""  name=%s\n"", s);
 				}
 			}
@@ -908,6 +994,10 @@ void xls_parseWorkBook(xlsWorkBook* pWB)
 			break;
 
 		case XLS_RECORD_1904:
+            if (bof1.size < sizeof(BYTE)) {
+                retval = LIBXLS_ERROR_PARSE;
+                goto cleanup;
+            }
 			pWB->is1904 = *(BYTE *)buf;	// the field is a short, but with little endian the first byte is 0 or 1
 			if(xls_debug) {
 				printf(""   mode: 0x%x\n"", pWB->is1904);
@@ -916,8 +1006,9 @@ void xls_parseWorkBook(xlsWorkBook* pWB)
 		
 		case XLS_RECORD_DEFINEDNAME:
 			if(xls_debug) {
-				printf(""DEFINEDNAME: "");
-				for(int i=0; i<bof1.size; ++i) printf(""%2.2x "", buf[i]);
+				int i;
+                printf(""   DEFINEDNAME: "");
+				for(i=0; i<bof1.size; ++i) printf(""%2.2x "", buf[i]);
 				printf(""\n"");
 			}
 			break;
@@ -950,42 +1041,76 @@ void xls_parseWorkBook(xlsWorkBook* pWB)
 			}
             break;
         }
-		free(buf);
-
         bof2=bof1;
 		once=1;
     }
     while ((!pWB->olestr->eof)&&(bof1.id!=XLS_RECORD_EOF));
+
+cleanup:
+    if (buf)
+        free(buf);
+
+    return retval;
 }
 
 
-void xls_preparseWorkSheet(xlsWorkSheet* pWS)
+xls_error_t xls_preparseWorkSheet(xlsWorkSheet* pWS)
 {
     BOF tmp;
-    BYTE* buf;
+    BYTE* buf = NULL;
+    xls_error_t retval = LIBXLS_OK;
 
     verbose (""xls_preparseWorkSheet"");
 
-    ole2_seek(pWS->workbook->olestr,pWS->filepos);
+    if (ole2_seek(pWS->workbook->olestr,pWS->filepos) == -1) {
+        retval = LIBXLS_ERROR_SEEK;
+        goto cleanup;
+    }
     do
     {
 		size_t read;
-        read = ole2_read(&tmp, 1,4,pWS->workbook->olestr);
-		assert(read == 4);
+		if((read = ole2_read(&tmp, 1, 4, pWS->workbook->olestr)) != 4) {
+            if (xls_debug) fprintf2(stderr, ""Error: failed to read OLE size\n"");
+            retval = LIBXLS_ERROR_READ;
+            goto cleanup;
+        }
         xlsConvertBof(&tmp);
-        buf=(BYTE *)malloc(tmp.size);
-        read = ole2_read(buf, 1,tmp.size,pWS->workbook->olestr);
-		assert(read == tmp.size);
+        if (tmp.size) {
+            if ((buf = realloc(buf, tmp.size)) == NULL) {
+                if (xls_debug) fprintf3(stderr, ""Error: failed to allocate buffer of size %d\n"", (int)tmp.size);
+                retval = LIBXLS_ERROR_MALLOC;
+                goto cleanup;
+            }
+            if((read = ole2_read(buf, 1, tmp.size, pWS->workbook->olestr)) != tmp.size) {
+                if (xls_debug) fprintf2(stderr, ""Error: failed to read OLE block\n"");
+                retval = LIBXLS_ERROR_READ;
+                goto cleanup;
+            }
+        }
+
         switch (tmp.id)
         {
         case XLS_RECORD_DEFCOLWIDTH:
+            if (tmp.size < sizeof(WORD_UA)) {
+                retval = LIBXLS_ERROR_PARSE;
+                goto cleanup;
+            }
             pWS->defcolwidth=xlsShortVal(*(WORD_UA *)buf)*256;
             break;
         case XLS_RECORD_COLINFO:
+            if (tmp.size < sizeof(COLINFO)) {
+                retval = LIBXLS_ERROR_PARSE;
+                goto cleanup;
+            }
             xlsConvertColinfo((COLINFO*)buf);
-            xls_addColinfo(pWS,(COLINFO*)buf);
+            if ((retval = xls_addColinfo(pWS,(COLINFO*)buf)) != LIBXLS_OK)
+                goto cleanup;
             break;
         case XLS_RECORD_ROW:
+            if (tmp.size < sizeof(ROW)) {
+                retval = LIBXLS_ERROR_PARSE;
+                goto cleanup;
+            }
             xlsConvertRow((ROW*)buf);
             if (pWS->rows.lastcol<((ROW*)buf)->lcell)
                 pWS->rows.lastcol=((ROW*)buf)->lcell;
@@ -995,12 +1120,20 @@ void xls_preparseWorkSheet(xlsWorkSheet* pWS)
         /* If the ROW record is incorrect or missing, infer the information from
          * cell data. */
         case XLS_RECORD_MULRK:
+            if (tmp.size < sizeof(MULRK)) {
+                retval = LIBXLS_ERROR_PARSE;
+                goto cleanup;
+            }
             if (pWS->rows.lastcol<xlsShortVal(((MULRK*)buf)->col) + (tmp.size - 6)/6 - 1)
                 pWS->rows.lastcol=xlsShortVal(((MULRK*)buf)->col) + (tmp.size - 6)/6 - 1;
             if (pWS->rows.lastrow<xlsShortVal(((MULRK*)buf)->row))
                 pWS->rows.lastrow=xlsShortVal(((MULRK*)buf)->row);
             break;
         case XLS_RECORD_MULBLANK:
+            if (tmp.size < sizeof(MULBLANK)) {
+                retval = LIBXLS_ERROR_PARSE;
+                goto cleanup;
+            }
             if (pWS->rows.lastcol<xlsShortVal(((MULBLANK*)buf)->col) + (tmp.size - 6)/2 - 1)
                 pWS->rows.lastcol=xlsShortVal(((MULBLANK*)buf)->col) + (tmp.size - 6)/2 - 1;
             if (pWS->rows.lastrow<xlsShortVal(((MULBLANK*)buf)->row))
@@ -1014,18 +1147,26 @@ void xls_preparseWorkSheet(xlsWorkSheet* pWS)
         case XLS_RECORD_FORMULA:
         case XLS_RECORD_FORMULA_ALT:
         case XLS_RECORD_BOOLERR:
+            if (tmp.size < sizeof(COL)) {
+                retval = LIBXLS_ERROR_PARSE;
+                goto cleanup;
+            }
             if (pWS->rows.lastcol<xlsShortVal(((COL*)buf)->col))
                 pWS->rows.lastcol=xlsShortVal(((COL*)buf)->col);
             if (pWS->rows.lastrow<xlsShortVal(((COL*)buf)->row))
                 pWS->rows.lastrow=xlsShortVal(((COL*)buf)->row);
             break;
         }
-        free(buf);
     }
     while ((!pWS->workbook->olestr->eof)&&(tmp.id!=XLS_RECORD_EOF));
+
+cleanup:
+    if (buf)
+        free(buf);
+    return retval;
 }
 
-void xls_formatColumn(xlsWorkSheet* pWS)
+xls_error_t xls_formatColumn(xlsWorkSheet* pWS)
 {
     DWORD i,t,ii;
     DWORD fcol,lcol;
@@ -1051,39 +1192,67 @@ void xls_formatColumn(xlsWorkSheet* pWS)
             }
         }
     }
+    return LIBXLS_OK;
 }
 
-void xls_parseWorkSheet(xlsWorkSheet* pWS)
+xls_error_t xls_parseWorkSheet(xlsWorkSheet* pWS)
 {
     BOF tmp;
-    BYTE* buf;
+    BYTE* buf = NULL;
 	long offset = pWS->filepos;
-	// int continueRec = 0;
+    size_t read;
+    xls_error_t retval = 0;
+#ifdef DEBUG_DRAWINGS
+	int continueRec = 0;
+#endif
 
-	struct st_cell_data *cell;
+	struct st_cell_data *cell = NULL;
 	xlsWorkBook *pWB = pWS->workbook;
 
     verbose (""xls_parseWorkSheet"");
 
-    xls_preparseWorkSheet(pWS);
+    if ((retval = xls_preparseWorkSheet(pWS)) != LIBXLS_OK) {
+        goto cleanup;
+    }
 	// printf(""size=%d fatpos=%d)\n"", pWS->workbook->olestr->size, pWS->workbook->olestr->fatpos);
 
-    xls_makeTable(pWS);
-    xls_formatColumn(pWS);
+    if ((retval = xls_makeTable(pWS)) != LIBXLS_OK) {
+        goto cleanup;
+    }
+
+    if ((retval = xls_formatColumn(pWS)) != LIBXLS_OK) {
+        goto cleanup;
+    }
 
-	cell = (void *)0;
-    ole2_seek(pWS->workbook->olestr,pWS->filepos);
+    if (ole2_seek(pWS->workbook->olestr,pWS->filepos) == -1) {
+        retval = LIBXLS_ERROR_SEEK;
+        goto cleanup;
+    }
     do
     {
 		long lastPos = offset;
 
 		if(xls_debug > 10) {
 			printf(""LASTPOS=%ld pos=%zd filePos=%d filePos=%d\n"", lastPos, pWB->olestr->pos, pWS->filepos, pWB->filepos);
 		}
-        ole2_read(&tmp, 1,4,pWS->workbook->olestr);
+		if((read = ole2_read(&tmp, 1, 4, pWS->workbook->olestr)) != 4) {
+            if (xls_debug) fprintf2(stderr, ""Error: failed to read OLE size\n"");
+            retval = LIBXLS_ERROR_READ;
+            goto cleanup;
+        }
         xlsConvertBof((BOF *)&tmp);
-        buf=(BYTE *)malloc(tmp.size);
-        ole2_read(buf, 1,tmp.size,pWS->workbook->olestr);
+        if (tmp.size) {
+            if ((buf = realloc(buf, tmp.size)) == NULL) {
+                if (xls_debug) fprintf3(stderr, ""Error: failed to allocate buffer of size %d\n"", (int)tmp.size);
+                retval = LIBXLS_ERROR_MALLOC;
+                goto cleanup;
+            }
+            if((read = ole2_read(buf, 1, tmp.size, pWS->workbook->olestr)) != tmp.size) {
+                if (xls_debug) fprintf2(stderr, ""Error: failed to read OLE block\n"");
+                retval = LIBXLS_ERROR_READ;
+                goto cleanup;
+            }
+        }
 		offset += 4 + tmp.size;
 
 		if(xls_debug)
@@ -1094,17 +1263,33 @@ void xls_parseWorkSheet(xlsWorkSheet* pWS)
         case XLS_RECORD_EOF:
             break;
         case XLS_RECORD_MERGEDCELLS:
-            xls_mergedCells(pWS,&tmp,buf);
+            if ((retval = xls_mergedCells(pWS,&tmp,buf)) != LIBXLS_OK) {
+                goto cleanup;
+            }
             break;
         case XLS_RECORD_ROW:
+            if (tmp.size < sizeof(ROW)) {
+                retval = LIBXLS_ERROR_PARSE;
+                goto cleanup;
+            }
 			if(xls_debug > 10) printf(""ROW: %x at pos=%ld\n"", tmp.id, lastPos);
             xlsConvertRow((ROW *)buf);
-            xls_addRow(pWS,(ROW*)buf);
+            if ((retval = xls_addRow(pWS,(ROW*)buf)) != LIBXLS_OK) {
+                goto cleanup;
+            }
             break;
 		case XLS_RECORD_DEFCOLWIDTH:
+            if (tmp.size < sizeof(WORD_UA)) {
+                retval = LIBXLS_ERROR_PARSE;
+                goto cleanup;
+            }
 			if(xls_debug > 10) printf(""DEFAULT COL WIDTH: %d\n"", *(WORD_UA *)buf);
 			break;
 		case XLS_RECORD_DEFAULTROWHEIGHT:
+            if (tmp.size < 2 * sizeof(WORD_UA)) {
+                retval = LIBXLS_ERROR_PARSE;
+                goto cleanup;
+            }
 			if(xls_debug > 10) printf(""DEFAULT ROW Height: 0x%x %d\n"", ((WORD_UA *)buf)[0], ((WORD_UA *)buf)[1]);
 			break;
 		case XLS_RECORD_DBCELL:
@@ -1144,15 +1329,18 @@ void xls_parseWorkSheet(xlsWorkSheet* pWS)
         case XLS_RECORD_LABEL:
         case XLS_RECORD_FORMULA:
         case XLS_RECORD_FORMULA_ALT:
-            cell = xls_addCell(pWS,&tmp,buf);
+            if ((cell = xls_addCell(pWS, &tmp, buf)) == NULL) {
+                retval = LIBXLS_ERROR_PARSE;
+                goto cleanup;
+            }
             break;
 		case XLS_RECORD_ARRAY:
 			if(formula_handler) formula_handler(tmp.id, tmp.size, buf);
 			break;
 
 		case XLS_RECORD_STRING:
 			if(cell && (cell->id == XLS_RECORD_FORMULA || cell->id == XLS_RECORD_FORMULA_ALT)) {
-				cell->str = get_string(buf, (BYTE)!pWB->is5ver, pWB->is5ver, pWB->charset);
+				cell->str = get_string((char *)buf, tmp.size, (BYTE)!pWB->is5ver, pWB->is5ver, pWB->charset);
 				if (xls_debug) xls_showCell(cell);
 			}
 			break;
@@ -1182,7 +1370,7 @@ void xls_parseWorkSheet(xlsWorkSheet* pWS)
 #endif
 
 #ifdef DEBUG_DRAWINGS
-#ifdef AIX
+#if defined(_AIX) || defined(__sun)
 #pragma pack(1)
 #else
 #pragma pack(push, 1)
@@ -1193,7 +1381,7 @@ void xls_parseWorkSheet(xlsWorkSheet* pWS)
 			sheetOffset = 100;
 			unsigned int total = tmp.size;
 			unsigned int off = 0;
-
+			
 			while(off < total) {
 				struct drawHeader fooper  = drawProc(buf, total, &off, 0);
 				(void)fooper;
@@ -1204,9 +1392,9 @@ void xls_parseWorkSheet(xlsWorkSheet* pWS)
 			if(formFunc) printf(""%s\n"", formFunc);
 			free(formData), formData = NULL;
 			free(formFunc), formFunc = NULL;
-
+			
 		}	break;
-
+		
 		case XLS_RECORD_TXO:
 		{
 			struct {
@@ -1219,7 +1407,8 @@ void xls_parseWorkSheet(xlsWorkSheet* pWS)
 				uint16_t	reserved2;
 			} foo;
 			memcpy(&foo, buf, 18);
-			printf(""TXO: grbit=0x%4.4X rot=0x%4.4X chText=0x%4.4X cbRuns=0x%4.4X ifntEmpty=0x%X reserved2=0x%X\n"", foo.grbit, foo.rot, foo.cchText, foo.cbRuns, foo.ifntEmpty, foo.reserved2);
+			printf(""TXO: grbit=0x%4.4X rot=0x%4.4X chText=0x%4.4X cbRuns=0x%4.4X ifntEmpty=0x%X reserved2=0x%X\n"",
+                    foo.grbit, foo.rot, foo.cchText, foo.cbRuns, foo.ifntEmpty, foo.reserved2);
 			
 			printf(""Res1: "");
 			for(int i=0; i<6; ++i) printf(""%2.2x "", foo.reserved1[i]);
@@ -1274,7 +1463,8 @@ void xls_parseWorkSheet(xlsWorkSheet* pWS)
 			int len = (int)(tmp.size - sizeof(foo));
 			int off = sizeof(foo);
 			
-			printf(""OBJ ft=0x%X cb=0x%X ot=0x%X idx=0x%X flags=0x%X len=%d "", foo.ft, foo.cb, foo.ot, foo.idx, foo.flags, (int)(tmp.size - sizeof(foo)) );
+			printf(""OBJ ft=0x%X cb=0x%X ot=0x%X idx=0x%X flags=0x%X len=%d "",
+                    foo.ft, foo.cb, foo.ot, foo.idx, foo.flags, (int)(tmp.size - sizeof(foo)) );
 			//for(int i=0; i<6; ++i) printf("" 0x%02.2x"", foo.unused[i]);
 			printf(""\n"");
 			
@@ -1334,7 +1524,8 @@ void xls_parseWorkSheet(xlsWorkSheet* pWS)
 				uint8_t		strType;
 			} note;
 			memcpy(&note, buf, sizeof(note));
-			printf(""NOTE: row=%d col=%d flags=0x%x idx=%d strLen=%d strType=%d :  "", note.row, note.col, note.flags, note.idx, note.strLen, note.strType);
+			printf(""   NOTE: row=%d col=%d flags=0x%x idx=%d strLen=%d strType=%d :  "",
+                    note.row, note.col, note.flags, note.idx, note.strLen, note.strType);
 			for(int i=0; i<note.strLen; ++i) printf(""%2.2x "", buf[i+sizeof(note)]);
 			printf(""\n  %.*s now at %ld len=%d\n"", note.strLen, buf + sizeof(note), sizeof(note)+note.strLen, tmp.size);
 
@@ -1344,59 +1535,72 @@ void xls_parseWorkSheet(xlsWorkSheet* pWS)
 #endif
 
         default:
-		  // printBOF:
+#ifdef DEBUG_DRAWINGS
+		  printBOF:
+#endif
 			if(xls_debug)
 			{
 				//xls_showBOF(&tmp);
-				printf(""   [%d:%d]: 0x%X at pos=%lu size=%u\n"", xlsShortVal(((COL*)buf)->row), xlsShortVal(((COL*)buf)->col), tmp.id, lastPos, tmp.size);
+                if (tmp.size >= sizeof(COL)) {
+                    printf(""   [%d:%d]: 0x%X at pos=%lu size=%u\n"", xlsShortVal(((COL*)buf)->row), xlsShortVal(((COL*)buf)->col),
+                            tmp.id, lastPos, tmp.size);
+                } else {
+                    printf(""   0x%X at pos=%lu size=%u\n"", tmp.id, lastPos, tmp.size);
+                }
 			}
             break;
         }
-        free(buf);
     }
     while ((!pWS->workbook->olestr->eof)&&(tmp.id!=XLS_RECORD_EOF));
+
+cleanup:
+    if (buf)
+        free(buf);
+
+    return retval;
 }
 
 xlsWorkSheet * xls_getWorkSheet(xlsWorkBook* pWB,int num)
 {
-    xlsWorkSheet * pWS;
+    xlsWorkSheet * pWS = NULL;
     verbose (""xls_getWorkSheet"");
-    pWS=(xlsWorkSheet *)calloc(1, sizeof(xlsWorkSheet));
-    pWS->filepos=pWB->sheets.sheet[num].filepos;
-    pWS->workbook=pWB;
-    pWS->rows.lastcol=0;
-    pWS->rows.lastrow=0;
-    pWS->colinfo.count=0;
-    return(pWS);
+    if (num >= 0 && num < pWB->sheets.count) {
+        pWS = calloc(1, sizeof(xlsWorkSheet));
+        pWS->filepos=pWB->sheets.sheet[num].filepos;
+        pWS->workbook=pWB;
+        pWS->rows.lastcol=0;
+        pWS->rows.lastrow=0;
+        pWS->colinfo.count=0;
+    }
+    return pWS;
 }
 
-xlsWorkBook* xls_open(const char *file,const char* charset)
-{
+static xlsWorkBook *xls_open_ole(OLE2 *ole, const char *charset, xls_error_t *outError) {
     xlsWorkBook* pWB;
-    OLE2*		ole;
-
-    pWB=(xlsWorkBook*)calloc(1, sizeof(xlsWorkBook));
-    verbose (""xls_open"");
+    xls_error_t retval = LIBXLS_OK;
 
-    // open excel file
-    if (!(ole=ole2_open((BYTE *)file)))
-    {
-        if(xls_debug) printf(""File \""%s\"" not found\n"",file);
-		free(pWB);
-        return(NULL);
-    }
+    pWB = calloc(1, sizeof(xlsWorkBook));
+    verbose (""xls_open_ole"");
 
-    if ((pWB->olestr=ole2_fopen(ole, (BYTE *)""\005SummaryInformation"")))
+    if ((pWB->olestr=ole2_fopen(ole, ""\005SummaryInformation"")))
     {
         pWB->summary = calloc(1,4096);
-		ole2_read(pWB->summary, 4096, 1, pWB->olestr);
+		if (ole2_read(pWB->summary, 4096, 1, pWB->olestr) == -1) {
+            if (xls_debug) fprintf2(stderr, ""SummaryInformation not found\n"");
+            retval = LIBXLS_ERROR_READ;
+            goto cleanup;
+        }
 		ole2_fclose(pWB->olestr);
 	}
 
-    if ((pWB->olestr=ole2_fopen(ole, (BYTE *)""\005DocumentSummaryInformation"")))
+    if ((pWB->olestr=ole2_fopen(ole, ""\005DocumentSummaryInformation"")))
     {
-        pWB->docSummary = calloc(1,4096);
-		ole2_read(pWB->docSummary, 4096, 1, pWB->olestr);
+        pWB->docSummary = calloc(1, 4096);
+		if (ole2_read(pWB->docSummary, 4096, 1, pWB->olestr) == -1) {
+            if (xls_debug) fprintf2(stderr, ""DocumentSummaryInformation not found\n"");
+            retval = LIBXLS_ERROR_READ;
+            goto cleanup;
+        }
 		ole2_fclose(pWB->olestr);
 	}
 
@@ -1418,23 +1622,67 @@ xlsWorkBook* xls_open(const char *file,const char* charset)
 #endif
 
     // open Workbook
-    if (!(pWB->olestr=ole2_fopen(ole,(BYTE *)""Workbook"")) && !(pWB->olestr=ole2_fopen(ole,(BYTE *)""Book"")))
+    if (!(pWB->olestr=ole2_fopen(ole,""Workbook"")) && !(pWB->olestr=ole2_fopen(ole,""Book"")))
     {
-        if(xls_debug) printf(""Workbook not found\n"");
-        ole2_close(ole);
-		free(pWB);
-        return(NULL);
+        if(xls_debug) fprintf2(stderr, ""Workbook not found\n"");
+        retval = LIBXLS_ERROR_PARSE;
+        goto cleanup;
     }
 
-
     pWB->sheets.count=0;
     pWB->xfs.count=0;
     pWB->fonts.count=0;
-    pWB->charset = (char *)malloc(strlen(charset) * sizeof(char)+1);
-    strcpy(pWB->charset, charset);
-    xls_parseWorkBook(pWB);
+    if (charset) {
+        pWB->charset = malloc(strlen(charset) * sizeof(char)+1);
+        strcpy(pWB->charset, charset);
+    } else {
+        pWB->charset = strdup(""UTF-8"");
+    }
+
+    retval = xls_parseWorkBook(pWB);
 
-    return(pWB);
+cleanup:
+    if (retval != LIBXLS_OK) {
+        if (!pWB->olestr)
+            ole2_close(ole);
+        xls_close_WB(pWB);
+        pWB = NULL;
+    }
+    if (outError)
+        *outError = retval;
+
+    return pWB;
+}
+
+xlsWorkBook* xls_open(const char *file, const char* charset)
+{
+    return xls_open_file(file, charset, NULL);
+}
+
+xlsWorkBook* xls_open_file(const char *file, const char* charset, xls_error_t *outError) {
+    OLE2* ole = NULL;
+
+    if (!(ole=ole2_open_file(file)))
+    {
+        if (xls_debug) fprintf3(stderr, ""File \""%s\"" not found\n"",file);
+        if (outError) *outError = LIBXLS_ERROR_OPEN;
+        return NULL;
+    }
+
+    return xls_open_ole(ole, charset, outError);
+}
+
+xlsWorkBook *xls_open_buffer(const unsigned char *buffer, size_t len,
+        const char *charset, xls_error_t *outError) {
+    OLE2* ole = NULL;
+
+    if (!(ole=ole2_open_buffer(buffer, len)))
+    {
+        if (outError) *outError = LIBXLS_ERROR_OPEN;
+        return NULL;
+    }
+
+    return xls_open_ole(ole, charset, outError);
 }
 
 xlsRow *xls_row(xlsWorkSheet* pWS, WORD cellRow)
@@ -1453,7 +1701,7 @@ xlsCell	*xls_cell(xlsWorkSheet* pWS, WORD cellRow, WORD cellCol)
 
     if(cellRow > pWS->rows.lastrow) return NULL;
     row = &pWS->rows.row[cellRow];
-    if(cellCol > row->lcell) return NULL;
+    if(cellCol > row->cells.count) return NULL;
 
     return &row->cells.cell[cellCol];
 }
@@ -1467,11 +1715,11 @@ void xls_close_WB(xlsWorkBook* pWB)
 	if(!pWB) return;
 
     // OLE first
-	ole=pWB->olestr->ole;
-	
-	ole2_fclose(pWB->olestr);
-
-	ole2_close(ole);
+    if (pWB->olestr) {
+        ole=pWB->olestr->ole;
+        ole2_fclose(pWB->olestr);
+        ole2_close(ole);
+    }
 
     // WorkBook
     free(pWB->charset);
@@ -1555,6 +1803,23 @@ const char* xls_getVersion(void)
     return PACKAGE_VERSION;
 }
 
+const char* xls_getError(xls_error_t code) {
+    if (code == LIBXLS_OK)
+        return ""No error"";
+    if (code == LIBXLS_ERROR_READ)
+        return ""Unable to read from file"";
+    if (code == LIBXLS_ERROR_OPEN)
+        return ""Unable to open file"";
+    if (code == LIBXLS_ERROR_SEEK)
+        return ""Unable to seek within file"";
+    if (code == LIBXLS_ERROR_MALLOC)
+        return ""Unable to allocate memory"";
+    if (code == LIBXLS_ERROR_PARSE)
+        return ""Unable to parse file"";
+
+    return ""Unknown error"";
+}
+
 //
 // http://poi.apache.org/hpsf/internals.html
 // or google ""DocumentSummaryInformation and UserDefined Property Sets"" and look for MSDN hits
@@ -1686,7 +1951,7 @@ void xls_set_formula_hander(xls_formula_handler handler)
 
 #ifdef DEBUG_DRAWINGS
 
-#ifdef AIX
+#if defined(_AIX) || defined(__sun)
 #pragma pack(1)
 #else
 #pragma pack(push, 1)

---FILE: src/xlstool.c---
@@ -57,8 +57,6 @@
 
 extern int xls_debug;
 
-// static void xls_showBOUNDSHEET(void* bsheet);
-
 static const DWORD colors[] =
     {
         0x000000,
@@ -119,77 +117,6 @@ static const DWORD colors[] =
         0x333333
     };
 
-#if HAVE_ASPRINTF != 1
-
-#include <stdarg.h>
-
-#ifdef MSDN
-static int asprintf(char **ret, const char *format, ...)
-{
-	int i, size=100;
-    char *p, *np;
-
-	va_list ap;
-
-	if ((p = (char *)malloc(size)) == NULL)
-        return -1;
-
-    while (1) {
-	    va_start(ap, format); 
-
-	    i = _vsnprintf(p, size, format, ap);
-
-	    va_end(ap);
-
-        if (i > -1 && i < size)
-        {
-            i++;
-            break;
-        }
-
-        if (i > -1)     /* glibc 2.1 */
-            size = i+1; /* precisely what is needed */
-        else            /* glibc 2.0 */
-            size *= 2;  /* twice the old size */
-
-        if ((np = realloc (p, size)) == NULL) {
-            free(p);
-            return -1;
-        } else {
-            p = np;
-        }
-    }
-
-	*ret = p;
-	return i > 255 ? 255 : i;
-}
-
-#else
-
-static int asprintf(char **ret, const char *format, ...)
-{
-	int i;
-	char *str;
-
-	va_list ap;
-
-	va_start(ap, format); 
-	i = vsnprintf(NULL, 0, format, ap) + 1;
-	va_end(ap);
-
-	str = (char *)malloc(i);
-
-	va_start(ap, format);
-	i = vsnprintf(str, i, format, ap);
-	va_end(ap);
-
-	*ret = str;
-	return i > 255 ? 255 : i;
-}
-#endif
-
-#endif
-
 
 void dumpbuf(BYTE* fname,long size,BYTE* buf)
 {
@@ -206,10 +133,10 @@ void verbose(char* str)
         printf(""libxls : %s\n"",str);
 }
 
-BYTE *utf8_decode(BYTE *str, DWORD len, char *encoding)
+char *utf8_decode(const char *str, DWORD len, char *encoding)
 {
 	int utf8_chars = 0;
-	BYTE *ret;
+	char *ret = NULL;
     DWORD i;
 	
 	for(i=0; i<len; ++i) {
@@ -219,14 +146,14 @@ BYTE *utf8_decode(BYTE *str, DWORD len, char *encoding)
 	}
 	
 	if(utf8_chars == 0 || strcmp(encoding, ""UTF-8"")) {
-		ret = (BYTE *)malloc(len+1);
+		ret = malloc(len+1);
 		memcpy(ret, str, len);
 		ret[len] = 0;
 	} else {
         DWORD i;
-        BYTE *out;
+        char *out;
 		// UTF-8 encoding inline
-		ret = (BYTE *)malloc(len+utf8_chars+1);
+		ret = malloc(len+utf8_chars+1);
 		out = ret;
 		for(i=0; i<len; ++i) {
 			BYTE c = str[i];
@@ -244,7 +171,7 @@ BYTE *utf8_decode(BYTE *str, DWORD len, char *encoding)
 }
 
 // Convert unicode string to to_enc encoding
-BYTE* unicode_decode(const BYTE *s, int len, size_t *newlen, const char* to_enc)
+char* unicode_decode(const char *s, size_t len, size_t *newlen, const char* to_enc)
 {
 #ifdef HAVE_ICONV
 	// Do iconv conversion
@@ -253,16 +180,16 @@ BYTE* unicode_decode(const BYTE *s, int len, size_t *newlen, const char* to_enc)
 #else
     const char *from_enc = ""UTF-16LE"";
 #endif
-    BYTE* outbuf = 0;
+    char* outbuf = 0;
 
     if(s && len && from_enc && to_enc)
     {
         size_t outlenleft = len;
         int outlen = len;
         size_t inlenleft = len;
         iconv_t ic = iconv_open(to_enc, from_enc);
-        BYTE* src_ptr = (BYTE*) s;
-        BYTE* out_ptr = 0;
+        const char* src_ptr = s;
+        char* out_ptr = 0;
 
         if(ic == (iconv_t)-1)
         {
@@ -286,26 +213,22 @@ BYTE* unicode_decode(const BYTE *s, int len, size_t *newlen, const char* to_enc)
             }
         }
         size_t st; 
-        outbuf = (BYTE*)malloc(outlen + 1);
+        outbuf = malloc(outlen + 1);
 
 		if(outbuf)
         {
-            out_ptr = (BYTE*)outbuf;
+            out_ptr = outbuf;
             while(inlenleft)
             {
-#ifdef _WIN32
-                st = iconv(ic, (const char **)&src_ptr, &inlenleft, (char **)&out_ptr,(size_t *) &outlenleft);
-#else
                 st = iconv(ic, (char **)&src_ptr, &inlenleft, (char **)&out_ptr,(size_t *) &outlenleft);
-#endif
                 if(st == (size_t)(-1))
                 {
                     if(errno == E2BIG)
                     {
                         size_t diff = out_ptr - outbuf;
                         outlen += inlenleft;
                         outlenleft += inlenleft;
-                        outbuf = (BYTE*)realloc(outbuf, outlen + 1);
+                        outbuf = realloc(outbuf, outlen + 1);
                         if(!outbuf)
                         {
                             break;
@@ -346,26 +269,27 @@ BYTE* unicode_decode(const BYTE *s, int len, size_t *newlen, const char* to_enc)
 
     x=(short *)s;
 
-    w = (wchar_t*)malloc((len+1)*sizeof(wchar_t));
+    w = malloc((len/2+1)*sizeof(wchar_t));
 
-    for(i=0; i<len; i++)
+    for(i=0; i<len/2; i++)
     {
         w[i]=xlsShortVal(x[i]);
     }
-    w[len] = '\0';
+    w[len/2] = '\0';
 
     count = wcstombs(NULL, w, 0);
 
 	if (count <= 0) {
 		if (newlen) *newlen = 0;
+		free(w);
 		return NULL;
 	}
 
 	converted = calloc(count+1, sizeof(char));
 	count2 = wcstombs(converted, w, count);
     free(w);
 	if (count2 <= 0) {
-		printf(""wcstombs failed (%d)\n"", len);
+		printf(""wcstombs failed (%d)\n"", len/2);
 		if (newlen) *newlen = 0;
 		return converted;
 	} else {
@@ -376,52 +300,58 @@ BYTE* unicode_decode(const BYTE *s, int len, size_t *newlen, const char* to_enc)
 }
 
 // Read and decode string
-BYTE* get_string(BYTE *s, BYTE is2, BYTE is5ver, char *charset)
+char *get_string(const char *s, size_t len, BYTE is2, BYTE is5ver, char *charset)
 {
     WORD ln;
-    DWORD ofs;
-    BYTE flag;
-    BYTE* str;
-    BYTE* ret;
+    DWORD ofs = 0;
+    BYTE flag = 0;
+    const char *str = s;
+    char *ret = NULL;
 	
-	flag = 0;
-    str=s;
-
-    ofs=0;
-
     if (is2) {
 		// length is two bytes
+        if (ofs + 2 > len) {
+            return NULL;
+        }
         ln=xlsShortVal(*(WORD_UA *)str);
         ofs+=2;
     } else {
 		// single byte length
+        if (ofs + 1 > len) {
+            return NULL;
+        }
         ln=*(BYTE*)str;
         ofs++;
     }
 
 	if(!is5ver) {
 		// unicode strings have a format byte before the string
+        if (ofs + 1 > len) {
+            return NULL;
+        }
 		flag=*(BYTE*)(str+ofs);
 		ofs++;
 	}
-    if (flag&0x8)
-    {
+    if (flag&0x8) {
 		// WORD rt;
         // rt=*(WORD*)(str+ofs); // unused
         ofs+=2;
     }
-    if (flag&0x4)
-    {
+    if (flag&0x4) {
 		// DWORD sz;
         // sz=*(DWORD*)(str+ofs); // unused
         ofs+=4;
     }
-    if(flag & 0x1)
-    {
-		size_t new_len = 0;
-        ret = unicode_decode(str+ofs,ln*2, &new_len,charset);
+    if(flag & 0x1) {
+        if (ofs + 2*ln > len) {
+            return NULL;
+        }
+        ret = unicode_decode(str+ofs, ln*2, NULL, charset);
     } else {
-		ret = utf8_decode((str+ofs), ln, charset);
+        if (ofs + ln > len) {
+            return NULL;
+        }
+		ret = utf8_decode(str+ofs, ln, charset);
     }
 
 #if 0	// debugging
@@ -628,78 +558,93 @@ void xls_showXF(XF8* xf)
     printf(""GroundColor: 0x%x\n"",xf->groundcolor);
 }
 
-BYTE *xls_getfcell(xlsWorkBook* pWB,struct st_cell_data* cell,BYTE *label)
+char *xls_getfcell(xlsWorkBook* pWB, struct st_cell_data* cell, BYTE *label)
 {
-    struct st_xf_data *xf;
-	WORD	len;
+    struct st_xf_data *xf = NULL;
+	WORD	len = 0;
+    DWORD   offset = 0;
     char	*ret = NULL;
+    size_t  retlen = 100;
 
-    xf=&pWB->xfs.xf[cell->xf];
+    if (cell->xf < pWB->xfs.count)
+        xf=&pWB->xfs.xf[cell->xf];
 
     switch (cell->id)
     {
     case XLS_RECORD_LABELSST:
-		//printf(""WORD: %u short: %u str: %s\n"", *(DWORD_UA *)label, xlsIntVal(*(DWORD_UA *)label), pWB->sst.string[xlsIntVal(*(DWORD_UA *)label)].str );
-        asprintf(&ret,""%s"",pWB->sst.string[xlsIntVal(*(DWORD_UA *)label)].str);
+        if(pWB->is5ver) {
+            offset = xlsShortVal(*(WORD *)label);
+        } else {
+            offset = xlsIntVal(*(DWORD *)label);
+        }
+        if(offset < pWB->sst.count && pWB->sst.string[offset].str) {
+            ret = strdup(pWB->sst.string[offset].str);
+        }
         break;
     case XLS_RECORD_BLANK:
     case XLS_RECORD_MULBLANK:
-        asprintf(&ret, ""%s"", """");
+        ret = strdup("""");
         break;
     case XLS_RECORD_LABEL:
-		len = xlsShortVal(*label);
+        len = xlsShortVal(*(WORD *)label);
         label += 2;
 		if(pWB->is5ver) {
-			asprintf(&ret,""%.*s"", len, (char *)label);
+            ret = malloc(len+1);
+            memcpy(ret, label, len);
+            ret[len] = 0;
 			//printf(""Found BIFF5 string of len=%d \""%s\""\n"", len, ret);
-		} else
-		if ((*(BYTE *)label & 0x01) == 0) {
-			ret = (char *)utf8_decode((BYTE *)label + 1, len, pWB->charset);
 		} else {
-			size_t newlen;
-		    ret = (char *)unicode_decode((BYTE *)label + 1, len*2, &newlen, pWB->charset);
-		}
+            if ((*(label++) & 0x01) == 0) {
+                ret = utf8_decode((char *)label, len, pWB->charset);
+            } else {
+                ret = unicode_decode((char *)label, len*2, NULL, pWB->charset);
+            }
+        }
         break;
     case XLS_RECORD_RK:
     case XLS_RECORD_NUMBER:
-        asprintf(&ret,""%lf"", cell->d);
+        ret = malloc(retlen);
+        snprintf(ret, retlen, ""%lf"", cell->d);
 		break;
 		//		if( RK || MULRK || NUMBER || FORMULA)
 		//		if (cell->id==0x27e || cell->id==0x0BD || cell->id==0x203 || 6 (formula))
     default:
-        switch (xf->format)
-        {
-        case 0:
-            asprintf(&ret,""%d"",(int)cell->d);
-            break;
-        case 1:
-            asprintf(&ret,""%d"",(int)cell->d);
-            break;
-        case 2:
-            asprintf(&ret,""%.1f"",cell->d);
-            break;
-        case 9:
-            asprintf(&ret,""%d"",(int)cell->d);
-            break;
-        case 10:
-            asprintf(&ret,""%.2f"",cell->d);
-            break;
-        case 11:
-            asprintf(&ret,""%.1e"",cell->d);
-            break;
-        case 14:
-			//ret=ctime(cell->d);
-			asprintf(&ret,""%.0f"",cell->d);
-            break;
-        default:
-			// asprintf(&ret,""%.4.2f (%i)"",cell->d,xf->format);break;
-            asprintf(&ret,""%.2f"",cell->d);
+        if (xf) {
+            ret = malloc(retlen);
+            switch (xf->format)
+            {
+                case 0:
+                    snprintf(ret, retlen, ""%d"", (int)cell->d);
+                    break;
+                case 1:
+                    snprintf(ret, retlen, ""%d"", (int)cell->d);
+                    break;
+                case 2:
+                    snprintf(ret, retlen, ""%.1f"", cell->d);
+                    break;
+                case 9:
+                    snprintf(ret, retlen, ""%d"", (int)cell->d);
+                    break;
+                case 10:
+                    snprintf(ret, retlen, ""%.2f"", cell->d);
+                    break;
+                case 11:
+                    snprintf(ret, retlen, ""%.1e"", cell->d);
+                    break;
+                case 14:
+                    //ret=ctime(cell->d);
+                    snprintf(ret, retlen, ""%.0f"", cell->d);
+                    break;
+                default:
+                    // asprintf(&ret,""%.4.2f (%i)"",cell->d,xf->format);break;
+                    snprintf(ret, retlen, ""%.2f"", cell->d);
+                    break;
+            }
             break;
         }
-        break;
     }
 
-    return (BYTE *)ret;
+    return ret;
 }
 
 char* xls_getCSS(xlsWorkBook* pWB)",False,False,Implementation / Logic,6
tidyverse,readxl,eeeebf8171540a7cd14b373d20b08efbac7e3cd2,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2018-03-26T20:46:08Z,GitHub,noreply@github.com,2018-03-26T20:46:08Z,"Parse _rels/.rels to get paths to package parts (#437)

Fixes #435 Be able to read sheets produced by the Los Angeles Police Department

* Parse _rels/.rels to get paths to package parts

* Add NEWS bullet

* Rename deSlash() --> removeLeadingSlashes(); address ""all slash"" edge case",NEWS.md;src/XlsxWorkBook.h;src/utils.h;src/zip.cpp;tests/testthat/test-compatibility.R,False,True,True,False,133,19,152,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # readxl 1.0.0.9000
 
+* xlsx structured as a ""minimal conformant SpreadsheetML package"" can be read. Most obvious feature of such sheets is the lack of an `xl/` directory in the unzipped form. (xlsx, #435, #437)
+
 * Reading xls sheet with exactly 65,536 rows no longer enters an infinite loop. (xls, #373, #416, #432 @vkapartzianis)
 
 * Datetimes coerced to character from xls have much higher precision, comparable to the xlsx behaviour. (xls, #430, #431)

---FILE: src/XlsxWorkBook.h---
@@ -10,16 +10,58 @@
 
 class XlsxWorkBook {
 
-  // holds objects related to sheet position, name, Id, and xml target file
-  class SheetRelations {
+  // holds objects related to package parts, such as file paths, but also
+  // worksheet position, name, and id
+  class PackageRelations {
+    // non-worksheet package parts
+    std::map<std::string, std::string> part_;
+
+    // worksheets
     int n_;
     Rcpp::CharacterVector names_;
     Rcpp::CharacterVector id_;
     std::map<std::string, std::string> target_;
 
+    // populate workbook element of part_
+    void parse_package_rels(const std::string& path) {
+      std::string rels_xml_file = zip_buffer(path, ""_rels/.rels"");
+      rapidxml::xml_document<> rels_xml;
+      rels_xml.parse<rapidxml::parse_strip_xml_namespaces>(&rels_xml_file[0]);
+
+      rapidxml::xml_node<>* relationships = rels_xml.first_node(""Relationships"");
+      if (relationships == NULL) {
+        Rcpp::stop(""Spreadsheet has no package-level relationships"");
+      }
+
+      std::map<std::string, std::string> scratch;
+      for (rapidxml::xml_node<>* relationship = relationships->first_node();
+           relationship; relationship = relationship->next_sibling()) {
+
+        rapidxml::xml_attribute<>* type = relationship->first_attribute(""Type"");
+        rapidxml::xml_attribute<>* target = relationship->first_attribute(""Target"");
+
+        if (type != NULL && target != NULL) {
+          // keys are derived by abbreviating Type
+          // in XML: http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument
+          // key is just the last part: officeDocument
+          scratch[baseName(type->value())] = target->value();
+        }
+      }
+
+      // identify and store the workbook part = the main part
+      // ECMA-376 Part 1 section 8.5 SpreadsheetML
+      std::map<std::string, std::string>::iterator m = scratch.find(""officeDocument"");
+      if (m == scratch.end()) {
+        Rcpp::stop(""No workbook part found"");
+      }
+      // store 'xl/workbook.xml', not '/xl/workbook.xml' (rare, but have seen)
+      part_[""officeDocument""] = removeLeadingSlashes(m->second);
+    }
+
     // populates n_, names_, id_
     void parse_workbook(const std::string& path) {
-      std::string workbookXml = zip_buffer(path, ""xl/workbook.xml"");
+      std::string workbookXml = zip_buffer(path, part_[""officeDocument""]);
+
       rapidxml::xml_document<> workbook;
       workbook.parse<rapidxml::parse_strip_xml_namespaces>(&workbookXml[0]);
 
@@ -59,7 +101,13 @@ class XlsxWorkBook {
 
     // populates target_
     void parse_workbook_rels(const std::string& path) {
-      std::string rels_xml_file = zip_buffer(path, ""xl/_rels/workbook.xml.rels"");
+      const std::string workbook_path = part_[""officeDocument""];
+      const std::string workbook_dir = dirName(workbook_path);
+      std::string rels_xml_path =
+        workbook_dir + ""/_rels/"" + baseName(workbook_path) + "".rels"";
+      rels_xml_path = removeLeadingSlashes(rels_xml_path);
+      std::string rels_xml_file = zip_buffer(path, rels_xml_path);
+
       rapidxml::xml_document<> rels_xml;
       rels_xml.parse<rapidxml::parse_strip_xml_namespaces>(&rels_xml_file[0]);
 
@@ -70,25 +118,42 @@ class XlsxWorkBook {
 
       for (rapidxml::xml_node<>* relationship = relationships->first_node();
            relationship; relationship = relationship->next_sibling()) {
+
         rapidxml::xml_attribute<>* id = relationship->first_attribute(""Id"");
+        rapidxml::xml_attribute<>* type = relationship->first_attribute(""Type"");
         rapidxml::xml_attribute<>* target = relationship->first_attribute(""Target"");
-        if (id != NULL && target != NULL) {
-          static const std::string prefix = ""/xl/"";
-          std::string target_value = target->value();
-          if (target_value.substr(0, prefix.size()) == prefix) {
-            target_value = target_value.substr(prefix.size());
+
+        if (id != NULL && type != NULL && target != NULL) {
+          // store 'xl/blah' instead of '/xl/blah' (rare, but we've seen)
+          std::string target_value = removeLeadingSlashes(target->value());
+          // abbreviate Type
+          // in XML: http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings
+          // whereas we only want: sharedStrings
+          std::string type_value = baseName(type->value());
+
+          // prepend workbook_dir iff needed; yes, we've seen both forms
+          // xl/blah --> xl/blah
+          //    blah --> xl/blah
+          if (target_value.substr(0, workbook_dir.size()) != workbook_dir) {
+            target_value = workbook_dir + ""/"" + target_value;
+          }
+
+          if (type_value.compare(""worksheet"") == 0) { // worksheet
+            target_[id->value()] = target_value;
+          } else { // not a worksheet, e.g. styles or sharedStrings
+            part_[type_value] = target_value;
           }
-          target_[id->value()] = target_value;
         }
       }
     }
 
   public:
-    SheetRelations(const std::string& path) :
+    PackageRelations(const std::string& path) :
     n_(100),
     names_(n_),
     id_(n_)
     {
+      parse_package_rels(path);
       parse_workbook(path);
       parse_workbook_rels(path);
     }
@@ -109,15 +174,25 @@ class XlsxWorkBook {
       }
       return it->second;
     }
-  }; // end of class SheetRelations
+
+    std::string part(std::string type) const {
+      std::map<std::string, std::string>::const_iterator it = part_.find(type);
+      if (it == part_.end()) {
+        // e.g., sharedStrings may not be present
+        // downstream functions should handle non-existent path
+        return """";
+      }
+      return it->second;
+    }
+  }; // end of class PackageRelations
 
   // common to Xls[x]WorkBook
   std::string path_;
   bool is1904_;
   std::set<int> dateFormats_;
 
   // specific to XlsxWorkBook
-  SheetRelations rel_;
+  PackageRelations rel_;
   std::vector<std::string> stringTable_;
 
 public:
@@ -152,7 +227,7 @@ class XlsxWorkBook {
   }
 
   std::string sheetPath(int sheet_i) const {
-    return ""xl/"" + rel_.target(sheet_i);
+    return rel_.target(sheet_i);
   }
 
   const std::vector<std::string>& stringTable() const {
@@ -162,11 +237,11 @@ class XlsxWorkBook {
 private:
 
   void cacheStringTable() {
-    if (!zip_has_file(path_, ""xl/sharedStrings.xml"")) {
+    if (!zip_has_file(path_, rel_.part(""sharedStrings""))) {
       return;
     }
 
-    std::string sharedStringsXml = zip_buffer(path_, ""xl/sharedStrings.xml"");
+    std::string sharedStringsXml = zip_buffer(path_, rel_.part(""sharedStrings""));
     rapidxml::xml_document<> sharedStrings;
     sharedStrings.parse<rapidxml::parse_strip_xml_namespaces>(&sharedStringsXml[0]);
 
@@ -191,7 +266,7 @@ class XlsxWorkBook {
   }
 
   void cacheDateFormats() {
-    std::string stylesXml = zip_buffer(path_, ""xl/styles.xml"");
+    std::string stylesXml = zip_buffer(path_, rel_.part(""styles""));
     rapidxml::xml_document<> styles;
     styles.parse<rapidxml::parse_strip_xml_namespaces>(&stylesXml[0]);
 
@@ -246,7 +321,7 @@ class XlsxWorkBook {
   }
 
   bool uses1904() {
-    std::string workbookXml = zip_buffer(path_, ""xl/workbook.xml"");
+    std::string workbookXml = zip_buffer(path_, rel_.part(""officeDocument""));
     rapidxml::xml_document<> workbook;
     workbook.parse<rapidxml::parse_strip_xml_namespaces>(&workbookXml[0]);
 

---FILE: src/utils.h---
@@ -145,4 +145,28 @@ inline std::string trim(const std::string& s) {
   return s.substr(begin, end - begin + 1);
 }
 
+inline std::string dirName(const std::string& path) {
+  std::size_t found = path.find_last_of(""/"");
+  if (found == std::string::npos) {
+    return """";
+  }
+  return path.substr(0, found);
+}
+
+inline std::string baseName(const std::string& path) {
+  std::size_t found = path.find_last_of(""/"");
+  if (found == std::string::npos) {
+    return path;
+  }
+  return path.substr(found + 1);
+}
+
+inline std::string removeLeadingSlashes(const std::string& s) {
+  size_t start = s.find_first_not_of(""/"");
+  if (start == std::string::npos) {
+    return """";
+  }
+  return s.substr(start);
+}
+
 #endif

---FILE: src/zip.cpp---
@@ -48,4 +48,3 @@ void zip_xml(const std::string& zip_path,
   std::string buffer = zip_buffer(zip_path, file_path);
   Rcout << xml_print(buffer);
 }
-

---FILE: tests/testthat/test-compatibility.R---
@@ -44,6 +44,7 @@ test_that(""we can read the BIFF5, LABEL record sheet"", {
   expect_identical(df$Time[c(1, 14)], c(""01:00"", ""14:00""))
 })
 
+
 ## https://github.com/tidyverse/readxl/pull/429
 ## <c r=""C2"" s=""1"" t=""str""><f>A2 + B2</f></c>
 test_that(""formula cell with no v node does not cause crash"", {
@@ -52,3 +53,16 @@ test_that(""formula cell with no v node does not cause crash"", {
   )
   expect_identical(df$`A + B`, NA)
 })
+
+## https://github.com/tidyverse/readxl/issues/435
+## https://source.opennews.org/articles/how-we-found-new-patterns-la-homeless-arrest/
+## LAPD uses a tool to produce xlsx that implements the minimal SpreadsheetML
+## package structure described on pp65-66 of ECMA 5th edition
+test_that(""we can read LAPD arrest sheets"", {
+  expect_silent(
+    lapd <- read_excel(test_sheet(""los-angeles-arrests-xlsx.xlsx""), skip = 2)
+  )
+  expect_identical(dim(lapd), c(193L, 36L))
+  expect_match(lapd$ARR_LOC[9], ""HOLLYWOOD"")
+  expect_identical(lapd$CHG_DESC[27], ""EX CON W/ A GUN"")
+})",True,False,Implementation / Logic,6
tidyverse,readxl,9f9a454f647677b2f1a9f21c97b0e9cfae3b8823,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2018-03-26T16:03:54Z,GitHub,noreply@github.com,2018-03-26T16:03:54Z,"Restore ability to read formula cell with no v node (xlsx) (#438)

* Handle xlsx files with missing v node.

* Update test sheet to work with Excel

* Revert #404

* Improved version of #404 shared string fix

* Integrate ""missing v node"" test and test sheet",src/XlsxCell.h;tests/testthat/sheets/missing-v-node-xlsx.xlsx;tests/testthat/test-compatibility.R,False,True,True,False,18,7,25,"---FILE: src/XlsxCell.h---
@@ -84,9 +84,9 @@ class XlsxCell {
     // CELL_BLANK
     //   inlineStr cell and (string is na or string can't be found)
     //   cell has no v node and is not an inlineStr cell
-    //   shared string cell and string is na
     //   v->value() is na
     //   error cell
+    //   shared string cell and string is na
     //
     // CELL_LOGICAL
     //   Boolean cell and its value (TRUE or FALSE) is not in na
@@ -134,17 +134,13 @@ class XlsxCell {
       return;
     }
 
-    // str (String)               Cell containing a formula string.
-    if (t != NULL && strncmp(t->value(), ""str"", 5) == 0) {
-      type_ = na.contains(v->value(), trimWs) ? CELL_BLANK : CELL_TEXT;
-      return;
-    }
-
     if (v == NULL || na.contains(v->value(), trimWs)) {
       type_ = CELL_BLANK;
       return;
     }
 
+    // from here on, no need for explicit NA check
+
     // n (Number)                 Cell containing a number.
     if (t == NULL || strncmp(t->value(), ""n"", 5) == 0) {
       rapidxml::xml_attribute<>* s = cell_->first_attribute(""s"");
@@ -176,6 +172,12 @@ class XlsxCell {
       return;
     }
 
+    // str (String)               Cell containing a formula string.
+    if (strncmp(t->value(), ""str"", 5) == 0) {
+      type_ = CELL_TEXT;
+      return;
+    }
+
     Rcpp::warning(""Unrecognized cell type at %s: '%s'"",
                   cellPosition(row(), col()), t->value());
   }

---FILE: tests/testthat/test-compatibility.R---
@@ -43,3 +43,12 @@ test_that(""we can read the BIFF5, LABEL record sheet"", {
   expect_identical(df$Date[c(1, 14)], c(""21/01/2017"", ""21/01/2017""))
   expect_identical(df$Time[c(1, 14)], c(""01:00"", ""14:00""))
 })
+
+## https://github.com/tidyverse/readxl/pull/429
+## <c r=""C2"" s=""1"" t=""str""><f>A2 + B2</f></c>
+test_that(""formula cell with no v node does not cause crash"", {
+  expect_silent(
+    df <- read_excel(test_sheet(""missing-v-node-xlsx.xlsx""))
+  )
+  expect_identical(df$`A + B`, NA)
+})",True,False,Implementation / Logic,6
tidyverse,readxl,73a8c3cd9ad6e3a0bd8e59657381bddaafc878a0,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2018-03-17T01:53:30Z,GitHub,noreply@github.com,2018-03-17T01:53:30Z,"Prevent infinite loop reading xls w/ 65536 rows (#432)

* Prevent infinite loop reading xls w/ 65536 rows

Fixes #373

* Add NEWS bullet",NEWS.md;src/XlsWorkSheet.h;tests/testthat/sheets/65536-rows-xls.xls;tests/testthat/test-read-excel.R,False,True,True,False,11,3,14,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # readxl 1.0.0.9000
 
+* Reading xls sheet with exactly 65,536 rows no longer enters an infinite loop. (xls, #373, #416, #432 @vkapartzianis)
+
 * Datetimes coerced to character from xls have much higher precision, comparable to the xlsx behaviour. (xls, #430, #431)
 
 * Integer-y numbers larger than 2^31 are coerced properly to string (xls, #346)

---FILE: src/XlsWorkSheet.h---
@@ -311,7 +311,7 @@ class XlsWorkSheet {
 
     xls::xlsCell *cell;
     bool nominal_needs_checking = !shim && nominal_.maxRow() >= 0;
-    for (xls::WORD i = 0; i <= nominal_nrow; ++i) {
+    for (int i = 0; i <= nominal_nrow; ++i) {
 
       if (i < nominal_.minRow() ||
           (!nominal_needs_checking && !nominal_.contains(i))) {
@@ -321,7 +321,7 @@ class XlsWorkSheet {
       for (xls::WORD j = 0; j <= nominal_ncol; ++j) {
 
         if (nominal_needs_checking) {
-          cell = xls_cell(pWS_, i, j);
+          cell = xls_cell(pWS_, (xls::WORD) i, j);
           if (cell_is_readable(cell)) {
             if (i > nominal_.minRow()) { // implicit skip
               nominal_.update(
@@ -334,7 +334,7 @@ class XlsWorkSheet {
         }
 
         if (nominal_.contains(i, j)) {
-          cell = xls_cell(pWS_, i, j);
+          cell = xls_cell(pWS_, (xls::WORD) i, j);
           if (cell_is_readable(cell)) {
             cells_.push_back(cell);
             actual_.update(i, j);

---FILE: tests/testthat/test-read-excel.R---
@@ -75,3 +75,9 @@ test_that(""read_excel catches invalid n_max"", {
     ""`n_max` must be a positive integer""
   )
 })
+
+## https://github.com/tidyverse/readxl/issues/373
+test_that(""xls with exactly 65536 rows does not enter infinite loop"", {
+  out <- read_excel(test_sheet(""65536-rows-xls.xls""))
+  expect_identical(out, tibble::tibble(HELLO = ""WORLD""))
+})",True,False,Documentation / Formatting,4
tidyverse,readxl,4af8b31491d0bd775a798c84f079c1cbf8ba47d7,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2018-03-16T19:20:20Z,GitHub,noreply@github.com,2018-03-16T19:20:20Z,"Increase precision of xls datetimes when coerced to character (#431)

* Add failing test

* Increase precision of xls datetimes when coerced to text

Fixes #430

* Print with full precision

As per @jimhester's advice:

https://stackoverflow.com/questions/554063/how-do-i-print-a-double-value-with-full-precision-using-cout#comment29144568_554134

* Make test a bit more forgiving

* Add NEWS bullet",NEWS.md;src/XlsCell.h;tests/testthat/sheets/texty-dates-xls.xls;tests/testthat/sheets/texty-dates-xlsx.xlsx;tests/testthat/test-coercion.R,False,True,True,False,22,1,23,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # readxl 1.0.0.9000
 
+* Datetimes coerced to character from xls have much higher precision, comparable to the xlsx behaviour. (xls, #430, #431)
+
 * Integer-y numbers larger than 2^31 are coerced properly to string (xls, #346)
 
 * Shared strings are only compared to NA strings after lookup, never on the basis of their index. (xlsx, #401)

---FILE: src/XlsCell.h---
@@ -1,6 +1,7 @@
 #ifndef READXL_XLSCELL_
 #define READXL_XLSCELL_
 
+#include <limits.h>
 #include <Rcpp.h>
 #include <libxls/xls.h>
 #include <libxls/xlstypes.h>
@@ -247,7 +248,7 @@ class XlsCell {
       if (std::modf(cell_->d, &intpart) == 0.0) {
         strs << std::fixed << (int64_t)cell_->d;
       } else {
-        strs << cell_->d;
+        strs << std::setprecision(std::numeric_limits<double>::digits10 + 2) << cell_->d;
       }
       std::string out_string = strs.str();
       return out_string;

---FILE: tests/testthat/test-coercion.R---
@@ -106,3 +106,21 @@ test_that(""integery-y numbers > 2^31 can be coerced to string"", {
     )
   )
 })
+
+## https://github.com/tidyverse/readxl/issues/430
+## re: precision of datetimes converted to text
+test_that(""datetimes agree up to certain precision when coerced to text"", {
+  xlsx <- read_excel(test_sheet(""texty-dates-xlsx.xlsx""), col_types = ""text"")
+  xls <- read_excel(test_sheet(""texty-dates-xls.xls""), col_types = ""text"")
+
+  xlsx <- sub(""^.*\\.(.*)$"", ""\\1"", xlsx$a)
+  xls <- sub(""^.*\\.(.*)$"", ""\\1"", xls$a)
+  ## it's hard to say how many digits of agreement we expect after the decimal
+  ## we coerce to string for xls, whereas its out of our hands for xlsx,
+  ## where the double comes to us as a string in the XML
+  ## therefore, my choice is somewhat arbitrary
+  xlsx <- substr(xlsx, 1, 8)
+  xls <- substr(xls, 1, 8)
+
+  expect_identical(xlsx, xls)
+})",True,False,Implementation / Logic,6
tidyverse,readxl,ed499fb299934b2c3355e239644d118498edbdab,Jenny Bryan,jenny.f.bryan@gmail.com,2017-10-26T21:25:00Z,Jenny Bryan,jenny.f.bryan@gmail.com,2017-10-26T21:25:00Z,"Yet another way to cast to 64 bit integer

`long long` is causing this on some platforms (namely, mine)

In file included from ./CellLimits.h:5:
./XlsCell.h:248:32: warning: 'long long' is a C++11 extension [-Wc++11-long-long]
        strs << std::fixed << (long long)cell_->d;
                               ^
1 warning generated.",src/XlsCell.h,False,False,False,False,1,1,2,"---FILE: src/XlsCell.h---
@@ -245,7 +245,7 @@ class XlsCell {
       // examples: social security or student number
       double intpart;
       if (std::modf(cell_->d, &intpart) == 0.0) {
-        strs << std::fixed << (long long)cell_->d;
+        strs << std::fixed << (int64_t)cell_->d;
       } else {
         strs << cell_->d;
       }",False,False,Rendering / Conversion,0
tidyverse,readxl,c1d3bd5f62479631fa98e6177ff3a44c89879af0,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-10-25T23:09:45Z,GitHub,noreply@github.com,2017-10-25T23:09:45Z,"Fix coercion of large integer-y numbers to string for xls; fixes #346 (#405)

* Add failing test re: coercing large integer-y numbers to string in xls

* Cast to a longer integer during string coercion; fixes #346

* Trying `long long`",NEWS.md;src/XlsCell.h;tests/testthat/sheets/big-texty-numbers-xls.xls;tests/testthat/sheets/big-texty-numbers-xlsx.xlsx;tests/testthat/test-coercion.R;tests/testthat/test-col-types.R,False,True,True,False,112,97,209,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # readxl 1.0.0.9000
 
+* Integer-y numbers larger than 2^31 are coerced properly to string (xls, #346)
+
 * Shared strings are only compared to NA strings after lookup, never on the basis of their index. (xlsx, #401)
 
 * Better checks and messaging around nonexistent files. (#392)
@@ -8,7 +10,7 @@
 
 * Add `$(C_VISIBILITY)` to compiler flags to hide internal symbols from the dll. (#385 @jeroen)
 
-* Numeric data in a logical column now coerces properly to logical. (#385 @nacnudus)
+* Numeric data in a logical column now coerces properly to logical. (xlsx, #385 @nacnudus)
 
 # readxl 1.0.0
 

---FILE: src/XlsCell.h---
@@ -245,7 +245,7 @@ class XlsCell {
       // examples: social security or student number
       double intpart;
       if (std::modf(cell_->d, &intpart) == 0.0) {
-        strs << std::fixed << (int)cell_->d;
+        strs << std::fixed << (long long)cell_->d;
       } else {
         strs << cell_->d;
       }

---FILE: tests/testthat/test-coercion.R---
@@ -0,0 +1,108 @@
+context(""coercion"")
+
+test_that(""contaminated, explicit logical is read as logical"", {
+  ## xls
+  expect_warning(
+    df <- read_excel(test_sheet(""types.xls""), sheet = ""logical_coercion"",
+                     col_types = c(""logical"", ""text"")),
+    ""Expecting logical"",
+    all = TRUE
+  )
+  expect_is(df$logical, ""logical"")
+  should_be_NA <- df$explanation %in% c(""string not logical"", ""blank"", ""date"")
+  expect_false(anyNA(df$logical[!should_be_NA]))
+
+  ## xlsx
+  expect_warning(
+    df <- read_excel(test_sheet(""types.xlsx""), sheet = ""logical_coercion"",
+                     col_types = c(""logical"", ""text"")),
+    ""Expecting logical"",
+    all = TRUE
+  )
+  expect_is(df$logical, ""logical"")
+  should_be_NA <- df$explanation %in% c(""string not logical"", ""blank"", ""date"")
+  expect_false(anyNA(df$logical[!should_be_NA]))
+})
+
+test_that(""contaminated, explicit date is read as date"", {
+  ## xls
+  expect_warning(
+    df <- read_excel(test_sheet(""types.xls""), sheet = ""date_coercion"",
+                     col_types = ""date""),
+    ""Expecting date|Coercing numeric"",
+    all = TRUE
+  )
+  expect_is(df$date, ""POSIXct"")
+  expect_false(anyNA(df$date[c(1, 5, 6, 7)]))
+  expect_true(all(is.na(df$date[c(2, 3, 4)])))
+  expect_identical(df$date[6], as.POSIXct(""2012-01-02 UTC"", tz = ""UTC""))
+
+  ## xlsx
+  expect_warning(
+    df <- read_excel(test_sheet(""types.xlsx""), sheet = ""date_coercion"",
+                     col_types = ""date""),
+    ""Expecting date|Coercing numeric"",
+    all = TRUE
+  )
+  expect_is(df$date, ""POSIXct"")
+  expect_false(anyNA(df$date[c(1, 5, 6, 7)]))
+  expect_true(all(is.na(df$date[c(2, 3, 4)])))
+  expect_identical(df$date[6], as.POSIXct(""2012-01-02 UTC"", tz = ""UTC""))
+})
+
+test_that(""contaminated, explicit numeric is read as numeric"", {
+  ## xls
+  expect_warning(
+    df <- read_excel(test_sheet(""types.xls""), sheet = ""numeric_coercion"",
+                     col_types = ""numeric""),
+    ""Expecting numeric|Coercing boolean|Coercing text"",
+    all = TRUE
+  )
+  expect_is(df$numeric, ""numeric"")
+  expect_false(anyNA(df$numeric[c(1, 2, 4, 7)]))
+  expect_equal(df$numeric[2], 72) # ""Number stored as text""
+
+  ## xlsx
+  expect_warning(
+    df <- read_excel(test_sheet(""types.xlsx""), sheet = ""numeric_coercion"",
+                     col_types = ""numeric""),
+    ""Expecting numeric|Coercing boolean|Coercing text"",
+    all = TRUE
+  )
+  expect_is(df$numeric, ""numeric"")
+  expect_false(anyNA(df$numeric[c(1, 2, 4, 7)]))
+  expect_equal(df$numeric[2], 72) # ""Number stored as text""
+})
+
+## #75, #110: don't convert numbers to string a la ""printf %lf""
+## i.e. don't right pad to get 6 decimal places
+test_that(""contaminated, explicit text is read as text"", {
+  ## xls
+  df <- read_excel(test_sheet(""types.xls""), sheet = ""text_coercion"",
+                   col_types = c(""text"", ""text""))
+  expect_is(df$text, ""character"")
+  expect_false(anyNA(df$explanation != ""blank""))
+  expect_identical(df$text[df$explanation == ""floating point""], ""1.3"")
+  expect_identical(df$text[df$explanation == ""student number""], ""36436153"")
+
+  ## xlsx
+  df <- read_excel(test_sheet(""types.xlsx""), sheet = ""text_coercion"",
+                   col_types = c(""text"", ""text""))
+  expect_is(df$text, ""character"")
+  expect_false(anyNA(df$explanation != ""blank""))
+  expect_identical(df$text[df$explanation == ""floating point""], ""1.3"")
+  expect_identical(df$text[df$explanation == ""student number""], ""36436153"")
+
+})
+
+test_that(""integery-y numbers > 2^31 can be coerced to string"", {
+  xlsx <- read_excel(test_sheet(""big-texty-numbers-xlsx.xlsx""))
+  xls <- read_excel(test_sheet(""big-texty-numbers-xls.xls""))
+  expect_identical(xlsx, xls)
+  expect_identical(
+    xls[[""number""]][-1],
+    as.character(
+      c(2 ^ 31 - 1, 2 ^ 31, 2 ^ 31 + 1, -1 * (2 ^ 31), -1 * (2 ^ 31 + 1))
+    )
+  )
+})

---FILE: tests/testthat/test-col-types.R---
@@ -146,101 +146,6 @@ test_that(""setting `na` works in list columns [xls]"", {
   expect_equal(na_defined$var1[[3]], NA)
 })
 
-test_that(""contaminated, explicit logical is read as logical"", {
-  ## xls
-  expect_warning(
-    df <- read_excel(test_sheet(""types.xls""), sheet = ""logical_coercion"",
-                     col_types = c(""logical"", ""text"")),
-    ""Expecting logical"",
-    all = TRUE
-  )
-  expect_is(df$logical, ""logical"")
-  should_be_NA <- df$explanation %in% c(""string not logical"", ""blank"", ""date"")
-  expect_false(anyNA(df$logical[!should_be_NA]))
-
-  ## xlsx
-  expect_warning(
-    df <- read_excel(test_sheet(""types.xlsx""), sheet = ""logical_coercion"",
-                     col_types = c(""logical"", ""text"")),
-    ""Expecting logical"",
-    all = TRUE
-  )
-  expect_is(df$logical, ""logical"")
-  should_be_NA <- df$explanation %in% c(""string not logical"", ""blank"", ""date"")
-  expect_false(anyNA(df$logical[!should_be_NA]))
-})
-
-test_that(""contaminated, explicit date is read as date"", {
-  ## xls
-  expect_warning(
-    df <- read_excel(test_sheet(""types.xls""), sheet = ""date_coercion"",
-                     col_types = ""date""),
-    ""Expecting date|Coercing numeric"",
-    all = TRUE
-  )
-  expect_is(df$date, ""POSIXct"")
-  expect_false(anyNA(df$date[c(1, 5, 6, 7)]))
-  expect_true(all(is.na(df$date[c(2, 3, 4)])))
-  expect_identical(df$date[6], as.POSIXct(""2012-01-02 UTC"", tz = ""UTC""))
-
-  ## xlsx
-  expect_warning(
-    df <- read_excel(test_sheet(""types.xlsx""), sheet = ""date_coercion"",
-                     col_types = ""date""),
-    ""Expecting date|Coercing numeric"",
-    all = TRUE
-  )
-  expect_is(df$date, ""POSIXct"")
-  expect_false(anyNA(df$date[c(1, 5, 6, 7)]))
-  expect_true(all(is.na(df$date[c(2, 3, 4)])))
-  expect_identical(df$date[6], as.POSIXct(""2012-01-02 UTC"", tz = ""UTC""))
-})
-
-test_that(""contaminated, explicit numeric is read as numeric"", {
-  ## xls
-  expect_warning(
-    df <- read_excel(test_sheet(""types.xls""), sheet = ""numeric_coercion"",
-                     col_types = ""numeric""),
-    ""Expecting numeric|Coercing boolean|Coercing text"",
-    all = TRUE
-  )
-  expect_is(df$numeric, ""numeric"")
-  expect_false(anyNA(df$numeric[c(1, 2, 4, 7)]))
-  expect_equal(df$numeric[2], 72) # ""Number stored as text""
-
-  ## xlsx
-  expect_warning(
-    df <- read_excel(test_sheet(""types.xlsx""), sheet = ""numeric_coercion"",
-                     col_types = ""numeric""),
-    ""Expecting numeric|Coercing boolean|Coercing text"",
-    all = TRUE
-  )
-  expect_is(df$numeric, ""numeric"")
-  expect_false(anyNA(df$numeric[c(1, 2, 4, 7)]))
-  expect_equal(df$numeric[2], 72) # ""Number stored as text""
-})
-
-## #75, #110: don't convert numbers to string a la ""printf %lf""
-## i.e. don't right pad to get 6 decimal places
-test_that(""contaminated, explicit text is read as text"", {
-  ## xls
-  df <- read_excel(test_sheet(""types.xls""), sheet = ""text_coercion"",
-                   col_types = c(""text"", ""text""))
-  expect_is(df$text, ""character"")
-  expect_false(anyNA(df$explanation != ""blank""))
-  expect_identical(df$text[df$explanation == ""floating point""], ""1.3"")
-  expect_identical(df$text[df$explanation == ""student number""], ""36436153"")
-
-  ## xlsx
-  df <- read_excel(test_sheet(""types.xlsx""), sheet = ""text_coercion"",
-                   col_types = c(""text"", ""text""))
-  expect_is(df$text, ""character"")
-  expect_false(anyNA(df$explanation != ""blank""))
-  expect_identical(df$text[df$explanation == ""floating point""], ""1.3"")
-  expect_identical(df$text[df$explanation == ""student number""], ""36436153"")
-
-})
-
 ## #385: logical-guessed column could end up with multiple pathological `TRUE`
 ## values for subsequent cells holding numeric data
 ## refines fix initiated in #398",True,False,Implementation / Logic,6
tidyverse,readxl,c02f81c3b9f7c6177ed9d13748377450bff9abe1,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-10-23T21:16:21Z,GitHub,noreply@github.com,2017-10-23T21:16:21Z,"Correctly compare shared strings (not their index!) to NA strings; fixes #401 (#404)

* Add failing test: exposes dysfunction re: NA strings and shared string table

* Correctly compare shared strings (not their index!) to NA strings",NEWS.md;src/XlsxCell.h;tests/testthat/sheets/missing-values-xls.xls;tests/testthat/sheets/missing-values-xlsx.xlsx;tests/testthat/sheets/numbers-as-na-and-shared-strings-xls.xls;tests/testthat/sheets/numbers-as-na-and-shared-strings-xlsx.xlsx;tests/testthat/test-missing-values.R,False,True,True,False,51,34,85,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # readxl 1.0.0.9000
 
+* Shared strings are only compared to NA strings after lookup, never on the basis of their index. (xlsx, #401)
+
 * Better checks and messaging around nonexistent files. (#392)
 
 * Extensionless files and files with nonstandard extension are now handled. If the file extension is absent or nonstandard, file format (xlsx vs xls) is guessed from the file's signature (a.k.a. magic number). This is implemented in the newly exported function `excel_format()`, which is used in `read_excel()` and `excel_sheets()`. (#342)

---FILE: src/XlsxCell.h---
@@ -84,9 +84,9 @@ class XlsxCell {
     // CELL_BLANK
     //   inlineStr cell and (string is na or string can't be found)
     //   cell has no v node and is not an inlineStr cell
+    //   shared string cell and string is na
     //   v->value() is na
     //   error cell
-    //   shared string cell and string is na
     //
     // CELL_LOGICAL
     //   Boolean cell and its value (TRUE or FALSE) is not in na
@@ -126,12 +126,24 @@ class XlsxCell {
       return;
     }
 
+    // s (Shared String)          Cell containing a shared string.
+    if (t != NULL && strncmp(t->value(), ""s"", 5) == 0) {
+      int id = atoi(v->value());
+      const std::string& string = stringTable.at(id);
+      type_ = na.contains(string, trimWs) ? CELL_BLANK : CELL_TEXT;
+      return;
+    }
+
+    // str (String)               Cell containing a formula string.
+    if (t != NULL && strncmp(t->value(), ""str"", 5) == 0) {
+      type_ = na.contains(v->value(), trimWs) ? CELL_BLANK : CELL_TEXT;
+      return;
+    }
+
     if (v == NULL || na.contains(v->value(), trimWs)) {
       type_ = CELL_BLANK;
       return;
     }
-    // from here on, the only explicit NA check needed is the case of
-    // a shared string table lookup
 
     // n (Number)                 Cell containing a number.
     if (t == NULL || strncmp(t->value(), ""n"", 5) == 0) {
@@ -164,20 +176,6 @@ class XlsxCell {
       return;
     }
 
-    // s (Shared String)          Cell containing a shared string.
-    if (strncmp(t->value(), ""s"", 5) == 0) {
-      int id = atoi(v->value());
-      const std::string& string = stringTable.at(id);
-      type_ = na.contains(string, trimWs) ? CELL_BLANK : CELL_TEXT;
-      return;
-    }
-
-    // str (String)               Cell containing a formula string.
-    if (strncmp(t->value(), ""str"", 5) == 0) {
-      type_ = na.contains(v->value(), trimWs) ? CELL_BLANK : CELL_TEXT;
-      return;
-    }
-
     Rcpp::warning(""Unrecognized cell type at %s: '%s'"",
                   cellPosition(row(), col()), t->value());
   }

---FILE: tests/testthat/test-missing-values.R---
@@ -38,31 +38,48 @@ test_that(""blanks in same, first row are read as missing [xls]"", {
 
 test_that(""By default, NA read as text"", {
   df <- read_xls(test_sheet(""missing-values-xls.xls""))
-  expect_equal(df$x, c(""NA"", ""1"", ""1""))
+  expect_equal(df$x, c(""NA"", ""1"", ""2""))
 })
 
-test_that(""na arg maps strings to NA [xls]"", {
+test_that(""na arg can be used to map 'NA' to NA [xls]"", {
   df <- read_excel(test_sheet(""missing-values-xls.xls""), na = ""NA"")
-  expect_equal(df$x, c(NA, 1, 1))
-  expect_equal(df$y, c(NA, 1, 1)) # formula column
+  expect_equal(df$x, c(NA, 1, 2))
+  expect_equal(df$y, c(NA, 1, 2)) # formula column
 })
 
-test_that(""na arg allows multiple strings [xls]"", {
-  df <- read_excel(test_sheet(""missing-values-xls.xls""), na = c(""NA"", ""1""))
-  expect_true(all(is.na(df$x)))
-  expect_true(all(is.na(df$y))) # formula column
-})
-
-test_that(""na arg maps strings to to NA [xlsx]"", {
+test_that(""na arg can be used to map 'NA' to NA [xlsx]"", {
   df <- read_excel(test_sheet(""missing-values-xlsx.xlsx""), na = ""NA"")
-  expect_equal(df$x, c(NA, 1, 1))
-  expect_equal(df$y, c(NA, 1, 1)) # formula column
+  expect_equal(df$x, c(NA, 1, 2))
+  expect_equal(df$y, c(NA, 1, 2)) # formula column
 })
 
-test_that(""na arg allows multiple strings [xlsx]"", {
-  df <- read_excel(test_sheet(""missing-values-xlsx.xlsx""), na = c(""NA"", ""1""))
-  expect_true(all(is.na(df$x)))
-  expect_true(all(is.na(df$y))) # formula column
+## #401 make sure check against NA strings is done after shared string table
+## lookup for affected cells vs. on the index into the shared string table
+test_that(""na arg works with multiple strings and for shared strings [xlsx]"", {
+  df <- read_excel(
+    test_sheet(""numbers-as-na-and-shared-strings-xlsx.xlsx""),
+    na = c(""1"", ""d"")
+  )
+  ## shared string table is:
+  ## sst[0] = ""a""
+  ## sst[1] = ""b"" <-- make sure this does not become NA!
+  ## sst[2] = ""c""
+  ## sst[3] = ""d""
+  expect_identical(df, tibble::tribble(
+    ~ a, ~ c,
+    ""b"",  NA
+  ))
+})
+
+test_that(""na arg works with multiple strings and for shared strings [xls]"", {
+  df <- read_excel(
+    test_sheet(""numbers-as-na-and-shared-strings-xls.xls""),
+    na = c(""1"", ""d"")
+  )
+  expect_identical(df, tibble::tribble(
+    ~ a, ~ c,
+    ""b"",  NA
+  ))
 })
 
 test_that(""empty first column gives valid data.frame [xls]"", {",True,False,Implementation / Logic,6
tidyverse,readxl,ff071a4758da3677568362daff52e419c4e0cdfe,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-10-22T06:26:06Z,GitHub,noreply@github.com,2017-10-22T06:26:06Z,"Detect format from file; check for file existence; fixes #342, fixes #392 (#402)",NAMESPACE;NEWS.md;R/excel-format.R;R/excel-sheets.R;R/read_excel.R;R/utils.R;man/excel_format.Rd;man/read_excel.Rd;tests/testthat/sheets/iris-excel-xls.xls;tests/testthat/sheets/iris-excel-xlsx.xlsx;tests/testthat/test-col-names.R;tests/testthat/test-col-types.R;tests/testthat/test-compatibility.R;tests/testthat/test-formats.R;tests/testthat/test-n-max.R;tests/testthat/test-read-excel.R;tests/testthat/test-sheets.R,False,True,True,False,218,84,302,"---FILE: NAMESPACE---
@@ -4,6 +4,7 @@ export(anchored)
 export(cell_cols)
 export(cell_limits)
 export(cell_rows)
+export(excel_format)
 export(excel_sheets)
 export(read_excel)
 export(read_xls)

---FILE: NEWS.md---
@@ -1,6 +1,10 @@
 # readxl 1.0.0.9000
 
-* Add $(C_VISIBILITY) to compiler flags to hide internal symbols from the dll. (#385 @jeroen)
+* Better checks and messaging around nonexistent files. (#392)
+
+* Extensionless files and files with nonstandard extension are now handled. If the file extension is absent or nonstandard, file format (xlsx vs xls) is guessed from the file's signature (a.k.a. magic number). This is implemented in the newly exported function `excel_format()`, which is used in `read_excel()` and `excel_sheets()`. (#342)
+
+* Add `$(C_VISIBILITY)` to compiler flags to hide internal symbols from the dll. (#385 @jeroen)
 
 * Numeric data in a logical column now coerces properly to logical. (#385 @nacnudus)
 

---FILE: R/excel-format.R---
@@ -0,0 +1,64 @@
+#' Determine file format
+#'
+#' Determine if files are xlsx or xls. First the file extension is consulted. If
+#' that is unsuccessful and `guess = TRUE` and the file exists, the format is
+#' guessed from the [file
+#' signature](https://en.wikipedia.org/wiki/List_of_file_signatures) or ""magic
+#' number"".
+#'
+#' @inheritParams read_excel
+#' @param guess Logical. Whether to guess format based on the file itself, if
+#'   the extension is neither `""xlsx""` nor `""xls""`.
+#'
+#' @return Character vector with values `""xlsx""`, `""xls""`, or `NA`.
+#' @export
+#'
+#' @examples
+#' files <- c(
+#'   ""a.xlsx"",
+#'   ""b.xls"",
+#'   ""c.png"",
+#'   file.path(R.home(""doc""), ""html"", ""logo.jpg""),
+#'   readxl_example(""clippy.xlsx""),
+#'   readxl_example(""deaths.xls"")
+#' )
+#' excel_format(files)
+excel_format <- function(path, guess = TRUE) {
+  ext <- tolower(tools::file_ext(path))
+
+  formats <- c(xls = ""xls"", xlsx = ""xlsx"", xlsm = ""xlsx"")
+  format <- unname(formats[ext])
+
+  if (!guess || !anyNA(format)) {
+    return(format)
+  }
+
+  guess_me <- is.na(format) & file.exists(path)
+  format[guess_me] <- guess_format(path[guess_me])
+  format
+}
+
+guess_format <- function(x) {
+  signature <- lapply(x, first_8_bytes)
+  vapply(signature, sig_to_fmt, ""xlsx?"")
+}
+
+first_8_bytes <- function(x) readBin(x, n = 8, what = ""raw"")
+
+sig_to_fmt <- function(x) {
+  ## https://en.wikipedia.org/wiki/List_of_file_signatures
+  xlsx_sig <- as.raw(c(
+    ""0x50"", ""0x4B"", ""0x03"", ""0x04""
+  ))
+  xls_sig <- as.raw(c(
+    ""0xD0"", ""0xCF"", ""0x11"", ""0xE0"", ""0xA1"", ""0xB1"", ""0x1A"", ""0xE1""
+  ))
+
+  if (identical(x[1:4], xlsx_sig)) {
+    ""xlsx""
+  } else if (identical(x, xls_sig)) {
+    ""xls""
+  } else {
+    NA_character_
+  }
+}

---FILE: R/excel-sheets.R---
@@ -10,9 +10,9 @@
 #' path <- readxl_example(""datasets.xls"")
 #' lapply(excel_sheets(path), read_excel, path = path)
 excel_sheets <- function(path) {
-  path <- check_file(path)
+  format <- check_format(path)
 
-  switch(excel_format(path),
+  switch(format,
     xls =  xls_sheets(path),
     xlsx = xlsx_sheets(path)
   )

---FILE: R/read_excel.R---
@@ -85,19 +85,19 @@ read_excel <- function(path, sheet = NULL, range = NULL,
                        col_names = TRUE, col_types = NULL,
                        na = """", trim_ws = TRUE, skip = 0, n_max = Inf,
                        guess_max = min(1000, n_max)) {
+  format <- check_format(path)
   read_excel_(
     path = path, sheet = sheet, range = range,
     col_names = col_names, col_types = col_types,
     na = na, trim_ws = trim_ws, skip = skip,
     n_max = n_max, guess_max = guess_max,
-    excel_format(path)
+    format = format
   )
 }
 
-#' While `read_excel()` auto detects the format from the file
-#' extension, `read_xls()` and `read_xlsx()` can be used to
-#' read files without extension.
-#'
+#' `read_excel()` tries to determine format from the file extension and the file
+#' itself, in that order. Use `read_xls()` and `read_xlsx()` directly to
+#' eliminate the guessing.
 #' @rdname read_excel
 #' @export
 read_xls <- function(path, sheet = NULL, range = NULL,
@@ -130,6 +130,7 @@ read_excel_ <- function(path, sheet = NULL, range = NULL,
                         col_names = TRUE, col_types = NULL,
                         na = """",  trim_ws = TRUE, skip = 0, n_max = Inf,
                         guess_max = min(1000, n_max), format) {
+  path <- check_file(path)
   if (format == ""xls"") {
     sheets_fun <- xls_sheets
     read_fun <- read_xls_
@@ -157,20 +158,26 @@ read_excel_ <- function(path, sheet = NULL, range = NULL,
 
 # Helper functions -------------------------------------------------------------
 
-excel_format <- function(path) {
-  ext <- tolower(tools::file_ext(path))
-
-  switch(
-    ext,
-    xls = ""xls"",
-    xlsx = ""xlsx"",
-    xlsm = ""xlsx"",
+check_format <- function(path) {
+  path <- check_file(path)
+  format <- excel_format(path)
+  if (is.na(format)) {
+    ext <- tolower(tools::file_ext(path))
     if (nzchar(ext)) {
-      stop(""Unknown file extension: "", ext, call. = FALSE)
+      stop(
+        ""Extension is neither 'xlsx' nor 'xls': "",
+        sQuote(ext),
+        call. = FALSE
+      )
     } else {
-      stop(""Missing file extension."", call. = FALSE)
+      stop(
+        ""File has no extension and doesn't seem to be xlsx or xls: "",
+        sQuote(path),
+        call. = FALSE
+      )
     }
-  )
+  }
+  format
 }
 
 ## return a zero-indexed sheet number

---FILE: R/utils.R---
@@ -1,13 +1,8 @@
 check_file <- function(path) {
   if (!file.exists(path)) {
-    stop(""'"", path, ""' does not exist"",
-      if (!is_absolute_path(path))
-        paste0("" in current working directory ('"", getwd(), ""')""),
-      ""."",
-      call. = FALSE)
+    stop(""Path does not exist: "", sQuote(path), call. = FALSE)
   }
-
-  normalizePath(path, ""/"", mustWork = FALSE)
+  path
 }
 
 is_absolute_path <- function(path) {

---FILE: man/excel_format.Rd---
@@ -0,0 +1,34 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/excel-format.R
+\name{excel_format}
+\alias{excel_format}
+\title{Determine file format}
+\usage{
+excel_format(path, guess = TRUE)
+}
+\arguments{
+\item{path}{Path to the xls/xlsx file}
+
+\item{guess}{Logical. Whether to guess format based on the file itself, if
+the extension is neither \code{""xlsx""} nor \code{""xls""}.}
+}
+\value{
+Character vector with values \code{""xlsx""}, \code{""xls""}, or \code{NA}.
+}
+\description{
+Determine if files are xlsx or xls. First the file extension is consulted. If
+that is unsuccessful and \code{guess = TRUE} and the file exists, the format is
+guessed from the \href{https://en.wikipedia.org/wiki/List_of_file_signatures}{filesignature} or ""magic
+number"".
+}
+\examples{
+files <- c(
+  ""a.xlsx"",
+  ""b.xls"",
+  ""c.png"",
+  file.path(R.home(""doc""), ""html"", ""logo.jpg""),
+  readxl_example(""clippy.xlsx""),
+  readxl_example(""deaths.xls"")
+)
+excel_format(files)
+}

---FILE: man/read_excel.Rd---
@@ -69,9 +69,9 @@ A \link[tibble:tibble-package]{tibble}
 \description{
 Read xls and xlsx files.
 
-While \code{read_excel()} auto detects the format from the file
-extension, \code{read_xls()} and \code{read_xlsx()} can be used to
-read files without extension.
+\code{read_excel()} tries to determine format from the file extension and the file
+itself, in that order. Use \code{read_xls()} and \code{read_xlsx()} directly to
+eliminate the guessing.
 }
 \examples{
 datasets <- readxl_example(""datasets.xlsx"")

---FILE: tests/testthat/test-col-names.R---
@@ -61,12 +61,12 @@ test_that(""column names are de-duplicated"", {
 test_that(""wrong length column names are rejected"", {
   err_msg <- ""Sheet 1 has 5 columns (5 unskipped), but `col_names` has length 3.""
   expect_error(
-    read_excel(test_sheet(""iris-excel.xlsx""),col_names = LETTERS[1:3]),
+    read_excel(test_sheet(""iris-excel-xlsx.xlsx""),col_names = LETTERS[1:3]),
     err_msg,
     fixed = TRUE
   )
   expect_error(
-    read_excel(test_sheet(""iris-excel.xls""), col_names = LETTERS[1:3]),
+    read_excel(test_sheet(""iris-excel-xls.xls""), col_names = LETTERS[1:3]),
     err_msg,
     fixed = TRUE
   )
@@ -76,7 +76,7 @@ test_that(""column_names can anticipate skipping"", {
 
   ## xlsx
   expect_silent(
-    df <- read_excel(test_sheet(""iris-excel.xlsx""),
+    df <- read_excel(test_sheet(""iris-excel-xlsx.xlsx""),
                      col_names = c(""one"", ""two"", ""three""), skip = 1,
                      col_types = c(""numeric"", ""numeric"", ""skip"", ""skip"", ""text""))
   )
@@ -85,7 +85,7 @@ test_that(""column_names can anticipate skipping"", {
 
   ## xls
   expect_silent(
-    df <- read_excel(test_sheet(""iris-excel.xls""),
+    df <- read_excel(test_sheet(""iris-excel-xls.xls""),
                      col_names = c(""one"", ""two"", ""three""), skip = 1,
                      col_types = c(""numeric"", ""numeric"", ""skip"", ""skip"", ""text""))
   )

---FILE: tests/testthat/test-col-types.R---
@@ -33,18 +33,18 @@ test_that(""invalid col_types are rejected"", {
 })
 
 test_that(""col_types can be specified"", {
-  df <- read_excel(test_sheet(""iris-excel.xlsx""),
+  df <- read_excel(test_sheet(""iris-excel-xlsx.xlsx""),
                    col_types = c(""numeric"", ""text"", ""numeric"", ""numeric"", ""text""))
   expect_is(df[[2]], ""character"")
-  df <- read_excel(test_sheet(""iris-excel.xls""),
+  df <- read_excel(test_sheet(""iris-excel-xls.xls""),
                    col_types = c(""numeric"", ""text"", ""numeric"", ""numeric"", ""text""))
   expect_is(df[[2]], ""character"")
 })
 
 test_that(""col_types are recycled"", {
-  df <- read_excel(test_sheet(""iris-excel.xlsx""), col_types = ""text"")
+  df <- read_excel(test_sheet(""iris-excel-xlsx.xlsx""), col_types = ""text"")
   expect_match(vapply(df, class, character(1)), ""character"")
-  df <- read_excel(test_sheet(""iris-excel.xls""), col_types = ""text"")
+  df <- read_excel(test_sheet(""iris-excel-xls.xls""), col_types = ""text"")
   expect_match(vapply(df, class, character(1)), ""character"")
 })
 
@@ -107,11 +107,11 @@ test_that(""guess_max is honored for col_types"", {
 test_that(""wrong length col types generates error"", {
   err_msg <- ""Sheet 1 has 5 columns, but `col_types` has length 2.""
   expect_error(
-    read_excel(test_sheet(""iris-excel.xlsx""), col_types = c(""numeric"", ""text"")),
+    read_excel(test_sheet(""iris-excel-xlsx.xlsx""), col_types = c(""numeric"", ""text"")),
     err_msg
   )
   expect_error(
-    read_excel(test_sheet(""iris-excel.xls""), col_types = c(""numeric"", ""text"")),
+    read_excel(test_sheet(""iris-excel-xls.xls""), col_types = c(""numeric"", ""text"")),
     err_msg
   )
 })

---FILE: tests/testthat/test-compatibility.R---
@@ -1,7 +1,7 @@
 context(""Compatibility"")
 
 test_that(""can read document from google doc"", {
-  iris_1 <- read_excel(test_sheet(""iris-excel.xlsx""))
+  iris_1 <- read_excel(test_sheet(""iris-excel-xlsx.xlsx""))
   iris_2 <- read_excel(test_sheet(""iris-google-doc.xlsx""))
 
   expect_equal(iris_1, iris_2)

---FILE: tests/testthat/test-formats.R---
@@ -0,0 +1,34 @@
+context(""test-formats.R"")
+
+test_that(""excel_format() recognizes extensions 'xls' and 'xlsx'"", {
+  files <- c(""a.xlsx"", ""b.xls"", ""c.png"", ""d"")
+  expect_identical(
+    excel_format(files, guess = FALSE),
+    c(""xlsx"", ""xls"", NA, NA)
+  )
+})
+
+test_that(""excel_format() detect file signature"", {
+  orig_files <- c(
+    test_sheet(""iris-excel-xlsx.xlsx""),
+    test_sheet(""iris-excel-xls.xls""),
+    file.path(R.home(""doc""), ""html"", ""logo.jpg"")
+  )
+  no_ext_copies <- paste0(
+    tools::file_path_sans_ext(orig_files),
+    ""-no-ending""
+  )
+  file.copy(orig_files, no_ext_copies)
+  on.exit(file.remove(no_ext_copies))
+  expect_identical(excel_format(no_ext_copies), c(""xlsx"", ""xls"", NA))
+})
+
+test_that(""can read files with and without extension [xlsx]"", {
+  file.copy(test_sheet(""iris-excel-xlsx.xlsx""), ""iris-xlsx-no-ending"")
+  on.exit(file.remove(""iris-xlsx-no-ending""))
+  iris_xlsx <- read_excel(test_sheet(""iris-excel-xlsx.xlsx""))
+  iris_guess <- read_excel(""iris-xlsx-no-ending"")
+  iris_explicit <- read_xlsx(""iris-xlsx-no-ending"")
+  expect_equal(iris_xlsx, iris_guess)
+  expect_equal(iris_xlsx, iris_explicit)
+})

---FILE: tests/testthat/test-n-max.R---
@@ -2,17 +2,17 @@ context(""n_max"")
 
 test_that(""simple use of n_max works and does not affect col name reading"", {
   ## xlsx
-  df <- read_excel(test_sheet(""iris-excel.xlsx""), n_max = 1)
+  df <- read_excel(test_sheet(""iris-excel-xlsx.xlsx""), n_max = 1)
   expect_identical(nrow(df), 1L)
-  df <- read_excel(test_sheet(""iris-excel.xlsx""), n_max = 0)
+  df <- read_excel(test_sheet(""iris-excel-xlsx.xlsx""), n_max = 0)
   expect_identical(nrow(df), 0L)
   expect_identical(ncol(df), 5L)
   expect_identical(names(df), names(iris))
 
   ## xls
-  df <- read_excel(test_sheet(""iris-excel.xls""), n_max = 1)
+  df <- read_excel(test_sheet(""iris-excel-xls.xls""), n_max = 1)
   expect_identical(nrow(df), 1L)
-  df <- read_excel(test_sheet(""iris-excel.xls""), n_max = 0)
+  df <- read_excel(test_sheet(""iris-excel-xls.xls""), n_max = 0)
   expect_identical(nrow(df), 0L)
   expect_identical(ncol(df), 5L)
   expect_identical(names(df), names(iris))
@@ -68,11 +68,11 @@ test_that(""n_max can affect ncols, if prevents read of data in a col [xls]"", {
 
 test_that(""n_max = nrows in dense sheet when col_names = FALSE"", {
   ## xlsx
-  df <- read_excel(test_sheet(""iris-excel.xlsx""), n_max = 18, col_names = FALSE)
+  df <- read_excel(test_sheet(""iris-excel-xlsx.xlsx""), n_max = 18, col_names = FALSE)
   expect_identical(nrow(df), 18L)
 
   ## xls
-  df <- read_excel(test_sheet(""iris-excel.xls""), n_max = 18, col_names = FALSE)
+  df <- read_excel(test_sheet(""iris-excel-xls.xls""), n_max = 18, col_names = FALSE)
   expect_identical(nrow(df), 18L)
 })
 

---FILE: tests/testthat/test-read-excel.R---
@@ -7,76 +7,71 @@ test_that(""can read sheets with inlineStr"", {
   expect_equal(x$ID, ""RQ11610"")
 })
 
-test_that(""can read file without extension"", {
+test_that(""can read files with and without extension [xls]"", {
+  file.copy(test_sheet(""iris-excel-xls.xls""), ""iris-xls-no-ending"")
+  on.exit(file.remove(""iris-xls-no-ending""))
+  iris_xls <- read_excel(test_sheet(""iris-excel-xls.xls""))
+  iris_guess <- read_excel(""iris-xls-no-ending"")
+  iris_explicit <- read_xls(""iris-xls-no-ending"")
+  expect_equal(iris_xls, iris_guess)
+  expect_equal(iris_xls, iris_explicit)
+})
 
-  ## xlsx
-  file.copy(test_sheet(""iris-excel.xlsx""), ""iris-xlsx-no-ending"")
-  on.exit(file.remove(""iris-xlsx-no-ending""))
-  iris_xlsx <- read_xlsx(""iris-xlsx-no-ending"")
-  expect_equal(iris_xlsx, read_excel(test_sheet(""iris-excel.xlsx"")))
-  expect_error(read_excel(""iris-xlsx-no-ending""), ""Missing file extension."")
+test_that(""xlsx is not read as xls and vice versa"", {
   expect_error(
     expect_output(
-      read_xls(""iris-xlsx-no-ending""),
+      read_xls(test_sheet(""iris-excel-xlsx.xlsx"")),
       ""Not an excel file""
     ),
-    ""Failed to open iris-xlsx-no-ending""
+    ""Failed to open""
   )
+  expect_error(read_xlsx(test_sheet(""iris-excel-xls.xls"")), ""cannot be opened"")
+})
 
-  ## xls
-  file.copy(test_sheet(""iris-excel.xls""), ""iris-xls-no-ending"")
-  on.exit(file.remove(""iris-xls-no-ending""), add = TRUE)
-  iris_xls <- read_xls(""iris-xls-no-ending"")
-  expect_equal(iris_xls, read_excel(test_sheet(""iris-excel.xls"")))
-  expect_error(read_excel(""iris-xls-no-ending""), ""Missing file extension."")
-  expect_error(read_xlsx(""iris-xls-no-ending""), ""cannot be opened"")
-
+test_that(""non-existent file throws error"", {
+  expect_error(read_excel(""foo""), ""Path does not exist"")
 })
 
 test_that(""read_excel catches invalid guess_max"", {
 
   expect_error(
-    read_excel(test_sheet(""iris-excel.xlsx""), guess_max = NA),
+    read_excel(test_sheet(""iris-excel-xlsx.xlsx""), guess_max = NA),
     ""`guess_max` must be a positive integer""
   )
   expect_error(
-    read_excel(test_sheet(""iris-excel.xlsx""), guess_max = -1),
+    read_excel(test_sheet(""iris-excel-xlsx.xlsx""), guess_max = -1),
     ""`guess_max` must be a positive integer""
   )
   expect_warning(
-    read_excel(test_sheet(""iris-excel.xlsx""), guess_max = Inf),
+    read_excel(test_sheet(""iris-excel-xlsx.xlsx""), guess_max = Inf),
     ""`guess_max` is a very large value""
   )
   expect_error(
-    read_excel(test_sheet(""iris-excel.xlsx""), guess_max = NULL),
+    read_excel(test_sheet(""iris-excel-xlsx.xlsx""), guess_max = NULL),
     ""`guess_max` must be a positive integer""
   )
   expect_error(
-    read_excel(test_sheet(""iris-excel.xlsx""), guess_max = 1:2),
+    read_excel(test_sheet(""iris-excel-xlsx.xlsx""), guess_max = 1:2),
     ""`guess_max` must be a positive integer""
   )
 })
 
-test_that(""read_excel only accepts file exts xlsx and xls"", {
-  expect_error(read_excel(""foo.txt""), ""Unknown file extension"")
-})
-
 test_that(""read_excel catches invalid n_max"", {
 
   expect_error(
-    read_excel(test_sheet(""iris-excel.xlsx""), n_max = NA),
+    read_excel(test_sheet(""iris-excel-xlsx.xlsx""), n_max = NA),
     ""`n_max` must be a positive integer""
   )
   expect_error(
-    read_excel(test_sheet(""iris-excel.xlsx""), n_max = -1),
+    read_excel(test_sheet(""iris-excel-xlsx.xlsx""), n_max = -1),
     ""`n_max` must be a positive integer""
   )
   expect_error(
-    read_excel(test_sheet(""iris-excel.xlsx""), n_max = NULL),
+    read_excel(test_sheet(""iris-excel-xlsx.xlsx""), n_max = NULL),
     ""`n_max` must be a positive integer""
   )
   expect_error(
-    read_excel(test_sheet(""iris-excel.xlsx""), n_max = 1:2),
+    read_excel(test_sheet(""iris-excel-xlsx.xlsx""), n_max = 1:2),
     ""`n_max` must be a positive integer""
   )
 })

---FILE: tests/testthat/test-sheets.R---
@@ -2,44 +2,44 @@ context(""Sheets"")
 
 test_that(""informative error when requesting non-existent sheet by name"", {
   expect_error(
-    read_excel(test_sheet(""iris-excel.xlsx""), sheet = ""tulip""),
+    read_excel(test_sheet(""iris-excel-xlsx.xlsx""), sheet = ""tulip""),
     ""Sheet 'tulip' not found""
   )
   expect_error(
-    read_excel(test_sheet(""iris-excel.xlsx""), range = ""tulip!A1:A1""),
+    read_excel(test_sheet(""iris-excel-xlsx.xlsx""), range = ""tulip!A1:A1""),
     ""Sheet 'tulip' not found""
   )
 })
 
 test_that(""informative error when requesting non-existent sheet by position"", {
   expect_error(
-    read_excel(test_sheet(""iris-excel.xlsx""), sheet = 2),
+    read_excel(test_sheet(""iris-excel-xlsx.xlsx""), sheet = 2),
     ""Can't retrieve sheet in position 2, only 1 sheet(s) found."",
     fixed = TRUE
   )
   expect_error(
-    read_excel(test_sheet(""iris-excel.xls""), sheet = 2),
+    read_excel(test_sheet(""iris-excel-xls.xls""), sheet = 2),
     ""Can't retrieve sheet in position 2, only 1 sheet(s) found."",
     fixed = TRUE
   )
 })
 
 test_that(""invalid sheet values caught"", {
   expect_error(
-    read_excel(test_sheet(""iris-excel.xlsx""), sheet = 0),
+    read_excel(test_sheet(""iris-excel-xlsx.xlsx""), sheet = 0),
     ""`sheet` must be positive""
   )
   expect_error(
-    read_excel(test_sheet(""iris-excel.xlsx""), sheet = rep(1L, 2)),
+    read_excel(test_sheet(""iris-excel-xlsx.xlsx""), sheet = rep(1L, 2)),
     ""`sheet` must have length 1""
   )
 })
 
 test_that(""sheet can be parsed out of range"", {
   direct <-
-    read_excel(test_sheet(""iris-excel.xlsx""), sheet = ""iris"", range = ""A1:A1"")
+    read_excel(test_sheet(""iris-excel-xlsx.xlsx""), sheet = ""iris"", range = ""A1:A1"")
   indirect <-
-    read_excel(test_sheet(""iris-excel.xlsx""), range = ""iris!A1:A1"")
+    read_excel(test_sheet(""iris-excel-xlsx.xlsx""), range = ""iris!A1:A1"")
   expect_identical(direct, indirect)
 })
 ",True,False,Documentation / Formatting,7
tidyverse,readxl,88311f5f4e70ae43652e894c2c7d6c4b7ea583c8,Duncan Garmonsway,duncan.garmonsway@digital.cabinet-office.gov.uk,2017-10-21T06:00:01Z,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-10-21T06:00:01Z," Add bugfix of #385 to NEWS (#399)

* Transform int to 0/1 before coercion to logical

Fixes #385

Weirdly, the test passes even without this fix when run with `testthat::test()`.  To get the test to fail, checkout the previous commit, install, and do

```r
library(readxl)
library(testthat)
source(""./tests/testthat/helper.R"")
source(""./tests/testthat/test-col-types.R"")
```

from within the project directory.  It will segfault.

* Add bugfix of #385 to NEWS",NEWS.md,False,False,False,False,2,0,2,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # readxl 1.0.0.9000
 
+* Fixes a rare segfault to do with coercing integer columns to logical. (#385 @nacnudus)
+
 # readxl 1.0.0
 
 ## Sheet geometry",False,False,Documentation / Formatting,4
tidyverse,readxl,685dc708d591b5a80e3e49933770a9a8e00959c5,Jenny Bryan,jenny.f.bryan@gmail.com,2017-10-20T22:05:37Z,Jenny Bryan,jenny.f.bryan@gmail.com,2017-10-20T22:05:37Z,Extend test sheet to make it useful for coming fix re: column typing,tests/testthat/sheets/missing-values-xls.xls;tests/testthat/sheets/missing-values-xlsx.xlsx,False,False,False,False,0,0,0,,False,False,Data / Input Handling,3
tidyverse,readxl,aab4ad483bf1975871c86afebf9f6d836bdd5257,Jenny Bryan,jenny.f.bryan@gmail.com,2017-10-20T00:48:39Z,Jenny Bryan,jenny.f.bryan@gmail.com,2017-10-20T05:27:53Z,Fix a case of partial arg matching,R/read_excel.R,False,True,True,False,1,1,2,"---FILE: R/read_excel.R---
@@ -145,7 +145,7 @@ read_excel_ <- function(path, sheet = NULL, range = NULL,
   trim_ws <- check_bool(trim_ws, ""trim_ws"")
   tibble::repair_names(
     tibble::as_tibble(
-      read_fun(path = path, sheet = sheet,
+      read_fun(path = path, sheet_i = sheet,
                limits = limits, shim = shim,
                col_names = col_names, col_types = col_types,
                na = na, trim_ws = trim_ws, guess_max = guess_max),",True,False,Implementation / Logic,6
tidyverse,readxl,411fda781ad5f2ad76289f2d45ee4f16820125b9,Duncan Garmonsway,duncan.garmonsway@digital.cabinet-office.gov.uk,2017-10-20T01:09:29Z,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-10-20T01:09:29Z,"Transform int to 0/1 before coercion to logical (#398)

Fixes #385

Weirdly, the test passes even without this fix when run with `testthat::test()`.  To get the test to fail, checkout the previous commit, install, and do

```r
library(readxl)
library(testthat)
source(""./tests/testthat/helper.R"")
source(""./tests/testthat/test-col-types.R"")
```

from within the project directory.  It will segfault.",src/XlsxCell.h;tests/testthat/sheets/int-to-logical.xlsx;tests/testthat/test-col-types.R,False,True,True,False,10,1,11,"---FILE: src/XlsxCell.h---
@@ -256,7 +256,7 @@ class XlsxCell {
     case CELL_NUMERIC:
     {
       rapidxml::xml_node<>* v = cell_->first_node(""v"");
-      return atoi(v->value());
+      return atoi(v->value()) != 0;
     }
 
     default:

---FILE: tests/testthat/test-col-types.R---
@@ -240,3 +240,12 @@ test_that(""contaminated, explicit text is read as text"", {
   expect_identical(df$text[df$explanation == ""student number""], ""36436153"")
 
 })
+
+## #385: transform non-zero integers to 1 before coercing an integer column to
+## logical so that different 'kinds' of TRUE aren't returned, which cause
+## segfaults in some base R functions.
+test_that(""integers other than 1 are converted to the same kind of TRUE"", {
+  x <- read_xlsx(test_sheet(""int-to-logical.xlsx""), guess_max = 0)
+  expect_equal(x$x, c(NA, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE))
+  expect_error(table(x$x), NA)
+})",True,False,Implementation / Logic,6
tidyverse,readxl,f2b88a1f335fbfe32f77068fb0fad578d5167be2,jennybc,jenny@stat.ubc.ca,2017-05-11T01:05:53Z,jennybc,jenny@stat.ubc.ca,2017-05-11T01:05:53Z,Fix typo on workflows article + pkgdown,docs/articles/articles/readxl-workflows.html;docs/articles/cell-and-column-types.html;docs/articles/index.html;docs/favicon.ico;docs/index.html;docs/news/index.html;docs/reference/excel_sheets.html;docs/reference/index.html;docs/reference/read_excel.html;docs/reference/readxl_example.html,False,False,False,False,234,147,381,"---FILE: docs/articles/articles/readxl-workflows.html---
@@ -114,23 +114,25 @@ <h2 class=""hasAnchor"">
 <p>We load the tidyverse metapackage here because the workflows below show readxl working with readr, purrr, etc. See the last section for solutions using base R only (other than readxl).</p>
 <p>We must load readxl explicitly because it is not part of the core tidyverse.</p>
 <div class=""sourceCode""><pre class=""sourceCode r""><code class=""sourceCode r""><span class=""kw"">library</span>(tidyverse)
-<span class=""co"">#&gt; Loading tidyverse: ggplot2</span>
-<span class=""co"">#&gt; Loading tidyverse: tibble</span>
-<span class=""co"">#&gt; Loading tidyverse: tidyr</span>
-<span class=""co"">#&gt; Loading tidyverse: readr</span>
-<span class=""co"">#&gt; Loading tidyverse: purrr</span>
-<span class=""co"">#&gt; Loading tidyverse: dplyr</span>
-<span class=""co"">#&gt; Conflicts with tidy packages ----------------------------------------------</span>
-<span class=""co"">#&gt; filter(): dplyr, stats</span>
-<span class=""co"">#&gt; lag():    dplyr, stats</span>
+<span class=""co"">#&gt; + ggplot2 2.2.1             Date: 2017-05-10</span>
+<span class=""co"">#&gt; + tibble  1.3.0.9001           R: 3.3.2</span>
+<span class=""co"">#&gt; + tidyr   0.6.2.9000          OS: OS X El Capitan 10.11.6</span>
+<span class=""co"">#&gt; + readr   1.1.0              GUI: X11</span>
+<span class=""co"">#&gt; + purrr   0.2.2.9000      Locale: en_CA.UTF-8</span>
+<span class=""co"">#&gt; + dplyr   0.5.0.9004          TZ: America/Vancouver</span>
+<span class=""co"">#&gt; + stringr 1.2.0           </span>
+<span class=""co"">#&gt; + forcats 0.2.0</span>
+<span class=""co"">#&gt; Conflicts -----------------------------------------------------------------</span>
+<span class=""co"">#&gt; * filter(),  from dplyr, masks stats::filter()</span>
+<span class=""co"">#&gt; * lag(),     from dplyr, masks stats::lag()</span>
 <span class=""kw"">library</span>(readxl)</code></pre></div>
 </div>
 <div id=""cache-a-csv-snapshot"" class=""section level2"">
 <h2 class=""hasAnchor"">
 <a href=""#cache-a-csv-snapshot"" class=""anchor""></a>Cache a CSV snapshot</h2>
 <p>Break analyses into logical steps, via a series of scripts that relate to one theme, such as “clean the data” or “make exploratory and diagnostic plots”.</p>
-<p>This forces you to transmit info from step i to step i + 1 via a set of output files. The cumulative outputs of steps 1, 2, …, i are available as inputs for steps i + 1.</p>
-<p>These outputs constitute an API for your analysis, i.e. they provide clean entry points that can be used (and understood) in isolation, possibly using an entirely different toolkit. Contrast this with the alternative of writing one monolithic script or transmitting entire workspaces via <code>save()</code>, <code>load()</code>, and R-specific <code>.rds</code> files.</p>
+<p>This forces you to transmit info from step i to step i + 1 via a set of output files. The cumulative outputs of steps 1, 2, …, i are available as inputs for steps i + 1 and beyond.</p>
+<p>These outputs constitute <a href=""https://www.quora.com/What-is-an-API-4"">an API</a> for your analysis, i.e. they provide clean entry points that can be used (and understood) in isolation, possibly using an entirely different toolkit. Contrast this with the alternative of writing one monolithic script or transmitting entire workspaces via <code>save()</code>, <code>load()</code>, and R-specific <code>.rds</code> files.</p>
 <p>If raw data is stored <em>only</em> as an Excel spreadsheet, this limits your ability to inspect it when solving the little puzzles that crop up in dowstream work. You’ll need to fire up Excel (or similar) and get busy with your mouse. You certainly can’t poke around it or view diffs on GitHub.</p>
 <p>Solution: cache a CSV snapshot of your raw data tables at the time of export. Even if you use <code><a href=""../../reference/read_excel.html"">read_excel()</a></code> for end-to-end reproducibility, this complementary CSV leaves your analysis in a more accessible state.</p>
 <p>Pipe the output of <code><a href=""../../reference/read_excel.html"">read_excel()</a></code> directly into <code>readr::write_csv()</code> like so:</p>
@@ -294,15 +296,15 @@ <h2 class=""hasAnchor"">
 <span class=""co"">#&gt; # A tibble: 20 × 7</span>
 <span class=""co"">#&gt;    sheet               Name Profession   Age `Has kids` `Date of birth`</span>
 <span class=""co"">#&gt;    &lt;chr&gt;              &lt;chr&gt;      &lt;chr&gt; &lt;dbl&gt;      &lt;lgl&gt;          &lt;dttm&gt;</span>
-<span class=""co"">#&gt; 1   arts        David Bowie   musician    69       TRUE      1947-01-08</span>
-<span class=""co"">#&gt; 2   arts      Carrie Fisher      actor    60       TRUE      1956-10-21</span>
-<span class=""co"">#&gt; 3   arts        Chuck Berry   musician    90       TRUE      1926-10-18</span>
-<span class=""co"">#&gt; 4   arts        Bill Paxton      actor    61       TRUE      1955-05-17</span>
-<span class=""co"">#&gt; 5   arts             Prince   musician    57       TRUE      1958-06-07</span>
-<span class=""co"">#&gt; 6   arts       Alan Rickman      actor    69      FALSE      1946-02-21</span>
-<span class=""co"">#&gt; 7   arts Florence Henderson      actor    82       TRUE      1934-02-14</span>
-<span class=""co"">#&gt; 8   arts         Harper Lee     author    89      FALSE      1926-04-28</span>
-<span class=""co"">#&gt; 9   arts      Zsa Zsa Gábor      actor    99       TRUE      1917-02-06</span>
+<span class=""co"">#&gt;  1  arts        David Bowie   musician    69       TRUE      1947-01-08</span>
+<span class=""co"">#&gt;  2  arts      Carrie Fisher      actor    60       TRUE      1956-10-21</span>
+<span class=""co"">#&gt;  3  arts        Chuck Berry   musician    90       TRUE      1926-10-18</span>
+<span class=""co"">#&gt;  4  arts        Bill Paxton      actor    61       TRUE      1955-05-17</span>
+<span class=""co"">#&gt;  5  arts             Prince   musician    57       TRUE      1958-06-07</span>
+<span class=""co"">#&gt;  6  arts       Alan Rickman      actor    69      FALSE      1946-02-21</span>
+<span class=""co"">#&gt;  7  arts Florence Henderson      actor    82       TRUE      1934-02-14</span>
+<span class=""co"">#&gt;  8  arts         Harper Lee     author    89      FALSE      1926-04-28</span>
+<span class=""co"">#&gt;  9  arts      Zsa Zsa Gábor      actor    99       TRUE      1917-02-06</span>
 <span class=""co"">#&gt; 10  arts     George Michael   musician    53      FALSE      1963-06-25</span>
 <span class=""co"">#&gt; 11 other         Vera Rubin  scientist    88       TRUE      1928-07-23</span>
 <span class=""co"">#&gt; 12 other        Mohamed Ali    athlete    74       TRUE      1942-01-17</span>
@@ -349,15 +351,15 @@ <h2 class=""hasAnchor"">
 <span class=""co"">#&gt; # A tibble: 20 × 7</span>
 <span class=""co"">#&gt;    sheet               Name Profession   Age `Has kids` `Date of birth`</span>
 <span class=""co"">#&gt;    &lt;chr&gt;              &lt;chr&gt;      &lt;chr&gt; &lt;dbl&gt;      &lt;lgl&gt;          &lt;dttm&gt;</span>
-<span class=""co"">#&gt; 1   arts        David Bowie   musician    69       TRUE      1947-01-08</span>
-<span class=""co"">#&gt; 2   arts      Carrie Fisher      actor    60       TRUE      1956-10-21</span>
-<span class=""co"">#&gt; 3   arts        Chuck Berry   musician    90       TRUE      1926-10-18</span>
-<span class=""co"">#&gt; 4   arts        Bill Paxton      actor    61       TRUE      1955-05-17</span>
-<span class=""co"">#&gt; 5   arts             Prince   musician    57       TRUE      1958-06-07</span>
-<span class=""co"">#&gt; 6   arts       Alan Rickman      actor    69      FALSE      1946-02-21</span>
-<span class=""co"">#&gt; 7   arts Florence Henderson      actor    82       TRUE      1934-02-14</span>
-<span class=""co"">#&gt; 8   arts         Harper Lee     author    89      FALSE      1926-04-28</span>
-<span class=""co"">#&gt; 9   arts      Zsa Zsa Gábor      actor    99       TRUE      1917-02-06</span>
+<span class=""co"">#&gt;  1  arts        David Bowie   musician    69       TRUE      1947-01-08</span>
+<span class=""co"">#&gt;  2  arts      Carrie Fisher      actor    60       TRUE      1956-10-21</span>
+<span class=""co"">#&gt;  3  arts        Chuck Berry   musician    90       TRUE      1926-10-18</span>
+<span class=""co"">#&gt;  4  arts        Bill Paxton      actor    61       TRUE      1955-05-17</span>
+<span class=""co"">#&gt;  5  arts             Prince   musician    57       TRUE      1958-06-07</span>
+<span class=""co"">#&gt;  6  arts       Alan Rickman      actor    69      FALSE      1946-02-21</span>
+<span class=""co"">#&gt;  7  arts Florence Henderson      actor    82       TRUE      1934-02-14</span>
+<span class=""co"">#&gt;  8  arts         Harper Lee     author    89      FALSE      1926-04-28</span>
+<span class=""co"">#&gt;  9  arts      Zsa Zsa Gábor      actor    99       TRUE      1917-02-06</span>
 <span class=""co"">#&gt; 10  arts     George Michael   musician    53      FALSE      1963-06-25</span>
 <span class=""co"">#&gt; 11 other         Vera Rubin  scientist    88       TRUE      1928-07-23</span>
 <span class=""co"">#&gt; 12 other        Mohamed Ali    athlete    74       TRUE      1942-01-17</span>
@@ -387,61 +389,62 @@ <h2 class=""hasAnchor"">
 #>  language (EN)                        
 #>  collate  en_CA.UTF-8                 
 #>  tz       America/Vancouver           
-#>  date     2017-04-17
+#>  date     2017-05-10
 #> Packages -----------------------------------------------------------------
 #>  package    * version     date       source                              
 #>  assertthat   0.2.0       2017-04-11 cran (@0.2.0)                       
 #>  backports    1.0.5       2017-01-18 cran (@1.0.5)                       
 #>  broom        0.4.2       2017-02-13 cran (@0.4.2)                       
-#>  cellranger   1.1.0       2016-07-27 CRAN (R 3.3.0)                      
+#>  cellranger   1.1.0.9000  2017-04-27 Github (rsheets/cellranger@024d5ba) 
 #>  colorspace   1.3-2       2016-12-14 CRAN (R 3.3.2)                      
 #>  devtools     1.12.0.9000 2017-04-13 Github (hadley/devtools@ab176e6)    
 #>  digest       0.6.12      2017-01-27 cran (@0.6.12)                      
-#>  dplyr      * 0.5.0.9001  2017-04-13 Github (hadley/dplyr@22504ec)       
+#>  dplyr      * 0.5.0.9004  2017-05-07 Github (tidyverse/dplyr@b2f84d2)    
 #>  evaluate     0.10        2016-10-11 cran (@0.10)                        
-#>  forcats      0.2.0       2017-01-23 cran (@0.2.0)                       
+#>  forcats    * 0.2.0       2017-01-23 cran (@0.2.0)                       
 #>  foreign      0.8-67      2016-09-13 CRAN (R 3.3.2)                      
 #>  ggplot2    * 2.2.1       2016-12-30 CRAN (R 3.3.2)                      
-#>  glue         0.0.0.9000  2017-04-03 Github (tidyverse/glue@6e77c3b)     
+#>  glue         1.0.0       2017-05-05 Github (tidyverse/glue@5d765fe)     
 #>  gtable       0.2.0       2016-02-26 CRAN (R 3.3.0)                      
 #>  haven        1.0.0       2016-09-23 CRAN (R 3.3.0)                      
 #>  hms          0.3         2016-11-22 CRAN (R 3.3.2)                      
-#>  htmltools    0.3.5       2016-03-21 CRAN (R 3.2.4)                      
-#>  httr         1.2.1.9000  2016-11-22 Github (gaborcsardi/httr@30001d4)   
-#>  jsonlite     1.4         2017-04-08 cran (@1.4)                         
+#>  htmltools    0.3.6       2017-04-28 cran (@0.3.6)                       
+#>  httr         1.2.1.9000  2017-04-28 local                               
+#>  jsonlite     1.4         2017-04-27 Github (jeroen/jsonlite@013a348)    
 #>  knitr        1.15.1      2016-11-22 CRAN (R 3.3.2)                      
 #>  lattice      0.20-34     2016-09-06 CRAN (R 3.3.2)                      
 #>  lazyeval     0.2.0.9000  2016-10-24 Github (hadley/lazyeval@c155c3d)    
 #>  lubridate    1.6.0       2016-09-13 cran (@1.6.0)                       
 #>  magrittr     1.5         2014-11-22 CRAN (R 3.2.0)                      
-#>  memoise      1.0.0.9001  2016-12-18 Github (hadley/memoise@884d565)     
+#>  memoise      1.1.0       2017-04-27 Github (hadley/memoise@d4f0864)     
 #>  mnormt       1.5-5       2016-10-15 CRAN (R 3.3.0)                      
 #>  modelr       0.1.0       2016-08-31 CRAN (R 3.3.0)                      
 #>  munsell      0.4.3       2016-02-13 CRAN (R 3.3.0)                      
 #>  nlme         3.1-128     2016-05-10 CRAN (R 3.3.2)                      
-#>  pkgbuild     0.0.0.9000  2017-04-13 Github (r-pkgs/pkgbuild@8aab60b)    
+#>  pkgbuild     0.0.0.9000  2017-04-27 Github (r-pkgs/pkgbuild@8aab60b)    
 #>  pkgload      0.0.0.9000  2017-04-13 Github (r-pkgs/pkgload@9093b96)     
 #>  plyr         1.8.4       2016-06-08 CRAN (R 3.3.0)                      
-#>  psych        1.6.12      2017-01-08 cran (@1.6.12)                      
-#>  purrr      * 0.2.2.9000  2017-04-10 Github (hadley/purrr@b8e3942)       
+#>  psych        1.7.5       2017-05-03 cran (@1.7.5)                       
+#>  purrr      * 0.2.2.9000  2017-05-07 Github (tidyverse/purrr@a1c1f6b)    
 #>  R6           2.2.0       2016-10-05 CRAN (R 3.3.0)                      
-#>  Rcpp         0.12.10     2017-04-13 Github (RcppCore/Rcpp@21d8388)      
-#>  readr      * 1.1.0       2017-03-22 CRAN (R 3.3.2)                      
-#>  readxl     * 1.0.0       2017-04-17 local                               
+#>  Rcpp         0.12.10.4   2017-05-07 Github (RcppCore/Rcpp@ebe67e8)      
+#>  readr      * 1.1.0       2017-05-07 Github (tidyverse/readr@3c69531)    
+#>  readxl     * 1.0.0.9000  2017-05-10 local                               
 #>  rematch      1.0.1       2016-04-21 CRAN (R 3.2.3)                      
 #>  reshape2     1.4.2       2016-10-22 CRAN (R 3.3.0)                      
-#>  rlang        0.0.0.9014  2017-04-13 Github (hadley/rlang@ac7498c)       
-#>  rmarkdown    1.4.0.9001  2017-04-13 Github (rstudio/rmarkdown@f2788b8)  
+#>  rlang        0.0.0.9019  2017-05-07 Github (hadley/rlang@fea1712)       
+#>  rmarkdown    1.5.9000    2017-05-07 Github (rstudio/rmarkdown@ca56f55)  
 #>  rprojroot    1.2         2017-01-16 CRAN (R 3.3.2)                      
+#>  rstudioapi   0.6         2016-06-27 CRAN (R 3.3.1)                      
 #>  rvest        0.3.2       2016-06-17 CRAN (R 3.3.0)                      
 #>  scales       0.4.1       2016-11-09 CRAN (R 3.3.2)                      
 #>  stringi      1.1.5       2017-04-07 cran (@1.1.5)                       
-#>  stringr      1.2.0       2017-02-18 cran (@1.2.0)                       
-#>  tibble     * 1.3.0       2017-04-01 cran (@1.3.0)                       
-#>  tidyr      * 0.6.1.9000  2017-03-07 Github (hadley/tidyr@0f9a5da)       
-#>  tidyverse  * 1.1.1.9000  2017-03-17 Github (tidyverse/tidyverse@2771fd7)
+#>  stringr    * 1.2.0       2017-02-18 cran (@1.2.0)                       
+#>  tibble     * 1.3.0.9001  2017-05-07 Github (tidyverse/tibble@5035804)   
+#>  tidyr      * 0.6.2.9000  2017-05-05 Github (hadley/tidyr@c2c1266)       
+#>  tidyverse  * 1.1.1.9000  2017-05-07 Github (tidyverse/tidyverse@6516a33)
 #>  withr        1.0.2       2016-06-20 cran (@1.0.2)                       
-#>  xml2         1.1.1       2017-03-31 Github (hadley/xml2@268387b)        
+#>  xml2         1.1.1       2017-05-05 Github (hadley/xml2@2dbb567)        
 #>  yaml         2.1.14      2016-11-12 cran (@2.1.14)
 ```
 </details>

---FILE: docs/articles/cell-and-column-types.html---
@@ -258,15 +258,15 @@ <h2 class=""hasAnchor"">
 <span class=""co"">#&gt; # A tibble: 18 × 6</span>
 <span class=""co"">#&gt;                `Lots of people`                     X__1   X__2     X__3</span>
 <span class=""co"">#&gt;                           &lt;chr&gt;                    &lt;chr&gt;  &lt;chr&gt;    &lt;chr&gt;</span>
-<span class=""co"">#&gt; 1  simply cannot resist writing                     &lt;NA&gt;   &lt;NA&gt;     &lt;NA&gt;</span>
-<span class=""co"">#&gt; 2                            at                      the    top     &lt;NA&gt;</span>
-<span class=""co"">#&gt; 3                            or                  merging   &lt;NA&gt;     &lt;NA&gt;</span>
-<span class=""co"">#&gt; 4                          Name               Profession    Age Has kids</span>
-<span class=""co"">#&gt; 5                   David Bowie                 musician     69     TRUE</span>
-<span class=""co"">#&gt; 6                 Carrie Fisher                    actor     60     TRUE</span>
-<span class=""co"">#&gt; 7                   Chuck Berry                 musician     90     TRUE</span>
-<span class=""co"">#&gt; 8                   Bill Paxton                    actor     61     TRUE</span>
-<span class=""co"">#&gt; 9                        Prince                 musician     57     TRUE</span>
+<span class=""co"">#&gt;  1 simply cannot resist writing                     &lt;NA&gt;   &lt;NA&gt;     &lt;NA&gt;</span>
+<span class=""co"">#&gt;  2                           at                      the    top     &lt;NA&gt;</span>
+<span class=""co"">#&gt;  3                           or                  merging   &lt;NA&gt;     &lt;NA&gt;</span>
+<span class=""co"">#&gt;  4                         Name               Profession    Age Has kids</span>
+<span class=""co"">#&gt;  5                  David Bowie                 musician     69     TRUE</span>
+<span class=""co"">#&gt;  6                Carrie Fisher                    actor     60     TRUE</span>
+<span class=""co"">#&gt;  7                  Chuck Berry                 musician     90     TRUE</span>
+<span class=""co"">#&gt;  8                  Bill Paxton                    actor     61     TRUE</span>
+<span class=""co"">#&gt;  9                       Prince                 musician     57     TRUE</span>
 <span class=""co"">#&gt; 10                 Alan Rickman                    actor     69    FALSE</span>
 <span class=""co"">#&gt; 11           Florence Henderson                    actor     82     TRUE</span>
 <span class=""co"">#&gt; 12                   Harper Lee                   author     89    FALSE</span>
@@ -299,15 +299,15 @@ <h3 class=""hasAnchor"">
 <span class=""co"">#&gt; # A tibble: 10 × 2</span>
 <span class=""co"">#&gt;    `maybe boolean?`                      description</span>
 <span class=""co"">#&gt;               &lt;lgl&gt;                            &lt;chr&gt;</span>
-<span class=""co"">#&gt; 1                NA                            empty</span>
-<span class=""co"">#&gt; 2             FALSE                      0 (numeric)</span>
-<span class=""co"">#&gt; 3              TRUE                      1 (numeric)</span>
-<span class=""co"">#&gt; 4                NA                         datetime</span>
-<span class=""co"">#&gt; 5              TRUE                     boolean true</span>
-<span class=""co"">#&gt; 6             FALSE                    boolean false</span>
-<span class=""co"">#&gt; 7                NA                        ""cabbage""</span>
-<span class=""co"">#&gt; 8              TRUE                the string ""true""</span>
-<span class=""co"">#&gt; 9             FALSE                   the letter ""F""</span>
+<span class=""co"">#&gt;  1               NA                            empty</span>
+<span class=""co"">#&gt;  2            FALSE                      0 (numeric)</span>
+<span class=""co"">#&gt;  3             TRUE                      1 (numeric)</span>
+<span class=""co"">#&gt;  4               NA                         datetime</span>
+<span class=""co"">#&gt;  5             TRUE                     boolean true</span>
+<span class=""co"">#&gt;  6            FALSE                    boolean false</span>
+<span class=""co"">#&gt;  7               NA                        ""cabbage""</span>
+<span class=""co"">#&gt;  8             TRUE                the string ""true""</span>
+<span class=""co"">#&gt;  9            FALSE                   the letter ""F""</span>
 <span class=""co"">#&gt; 10            FALSE ""False"" preceded by single quote</span></code></pre></div>
 <p><img src=""type-me-logical.png"" width=""70%""></p>
 </div>
@@ -358,11 +358,11 @@ <h3 class=""hasAnchor"">
 <span class=""co"">#&gt; # A tibble: 7 × 2</span>
 <span class=""co"">#&gt;   `maybe a datetime?`          explanation</span>
 <span class=""co"">#&gt;                &lt;dttm&gt;                &lt;chr&gt;</span>
-<span class=""co"">#&gt; 1                &lt;NA&gt;                empty</span>
+<span class=""co"">#&gt; 1                  NA                empty</span>
 <span class=""co"">#&gt; 2 2016-05-23 00:00:00     date only format</span>
 <span class=""co"">#&gt; 3 2016-04-28 11:30:00 date and time format</span>
-<span class=""co"">#&gt; 4                &lt;NA&gt;         boolean true</span>
-<span class=""co"">#&gt; 5                &lt;NA&gt;            ""cabbage""</span>
+<span class=""co"">#&gt; 4                  NA         boolean true</span>
+<span class=""co"">#&gt; 5                  NA            ""cabbage""</span>
 <span class=""co"">#&gt; 6 1904-01-05 07:12:00        4.3 (numeric)</span>
 <span class=""co"">#&gt; 7 2012-01-02 00:00:00      another numeric</span></code></pre></div>
 <p><img src=""type-me-date.png"" width=""70%""></p>

---FILE: docs/articles/index.html---
@@ -110,7 +110,7 @@
       </header>
 
       <div class=""page-header"">
-  <h1>Vignette reference <small>version&nbsp;1.0.0</small></h1>
+  <h1>Articles <small>version&nbsp;1.0.0.9000</small></h1>
 </div>
 
 <div class=""row"">

---FILE: docs/index.html---
@@ -269,7 +269,7 @@ <h2>Links</h2>
 </li>
 </ul>
 <h2>License</h2>
-<p><a href=""https://www.r-project.org/Licenses/GPL-3"">GPL-3</a> + file <a href=""LICENSE"">LICENSE</a></p>
+<p><a href=""https://www.r-project.org/Licenses/GPL-3"">GPL-3</a></p>
 <h2>Developers</h2>
 <ul class=""list-unstyled"">
 <li>

---FILE: docs/news/index.html---
@@ -117,6 +117,10 @@ <h1>Change log <small>All releases</small></h1>
     </div>
 
     <div class=""contents"">
+    <div id=""readxl-1-0-0-9000"" class=""section level1"">
+<h1 class=""hasAnchor"">
+<a href=""#readxl-1-0-0-9000"" class=""anchor""></a>readxl 1.0.0.9000</h1>
+</div>
     <div id=""readxl-1-0-0"" class=""section level1"">
 <h1 class=""hasAnchor"">
 <a href=""#readxl-1-0-0"" class=""anchor""></a>readxl 1.0.0</h1>
@@ -200,6 +204,7 @@ <h1 class=""hasAnchor"">
     <div id=""tocnav"">
       <h2>Contents</h2>
       <ul class=""nav nav-pills nav-stacked"">
+        <li><a href=""#readxl-1-0-0-9000"">1.0.0.9000</a></li>
         <li><a href=""#readxl-1-0-0"">1.0.0</a></li>
         <li><a href=""#readxl-0-1-1"">0.1.1</a></li>
       </ul>

---FILE: docs/reference/excel_sheets.html---
@@ -119,7 +119,7 @@ <h1>List all sheets in an excel spreadsheet.</h1>
     <p>List all sheets in an excel spreadsheet.</p>
     
 
-    <pre><span class='fu'>excel_sheets</span>(<span class='no'>path</span>)</pre>
+    <pre class=""usage""><span class='fu'>excel_sheets</span>(<span class='no'>path</span>)</pre>
     
     <h2 class=""hasAnchor"" id=""arguments""><a class=""anchor"" href=""#arguments""></a> Arguments</h2>
     <table class=""ref-arguments"">
@@ -137,39 +137,67 @@ <h2 class=""hasAnchor"" id=""examples""><a class=""anchor"" href=""#examples""></a>Examp
 <span class='no'>path</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='readxl_example.html'>readxl_example</a></span>(<span class='st'>""datasets.xls""</span>)
 <span class='fu'>lapply</span>(<span class='fu'>excel_sheets</span>(<span class='no'>path</span>), <span class='no'>read_excel</span>, <span class='kw'>path</span> <span class='kw'>=</span> <span class='no'>path</span>)</div><div class='output co'>#&gt; [[1]]
 #&gt; # A tibble: 150 × 5
-#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
-#&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;
-#&gt; 1          5.1         3.5          1.4         0.2  setosa
-#&gt; 2          4.9         3.0          1.4         0.2  setosa
-#&gt; 3          4.7         3.2          1.3         0.2  setosa
-#&gt; # ... with 147 more rows
+#&gt;    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
+#&gt;           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;
+#&gt;  1          5.1         3.5          1.4         0.2  setosa
+#&gt;  2          4.9         3.0          1.4         0.2  setosa
+#&gt;  3          4.7         3.2          1.3         0.2  setosa
+#&gt;  4          4.6         3.1          1.5         0.2  setosa
+#&gt;  5          5.0         3.6          1.4         0.2  setosa
+#&gt;  6          5.4         3.9          1.7         0.4  setosa
+#&gt;  7          4.6         3.4          1.4         0.3  setosa
+#&gt;  8          5.0         3.4          1.5         0.2  setosa
+#&gt;  9          4.4         2.9          1.4         0.2  setosa
+#&gt; 10          4.9         3.1          1.5         0.1  setosa
+#&gt; # ... with 140 more rows
 #&gt; 
 #&gt; [[2]]
 #&gt; # A tibble: 32 × 11
-#&gt;     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
-#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
-#&gt; 1  21.0     6   160   110  3.90 2.620 16.46     0     1     4     4
-#&gt; 2  21.0     6   160   110  3.90 2.875 17.02     0     1     4     4
-#&gt; 3  22.8     4   108    93  3.85 2.320 18.61     1     1     4     1
-#&gt; # ... with 29 more rows
+#&gt;      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
+#&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
+#&gt;  1  21.0     6 160.0   110  3.90 2.620 16.46     0     1     4     4
+#&gt;  2  21.0     6 160.0   110  3.90 2.875 17.02     0     1     4     4
+#&gt;  3  22.8     4 108.0    93  3.85 2.320 18.61     1     1     4     1
+#&gt;  4  21.4     6 258.0   110  3.08 3.215 19.44     1     0     3     1
+#&gt;  5  18.7     8 360.0   175  3.15 3.440 17.02     0     0     3     2
+#&gt;  6  18.1     6 225.0   105  2.76 3.460 20.22     1     0     3     1
+#&gt;  7  14.3     8 360.0   245  3.21 3.570 15.84     0     0     3     4
+#&gt;  8  24.4     4 146.7    62  3.69 3.190 20.00     1     0     4     2
+#&gt;  9  22.8     4 140.8    95  3.92 3.150 22.90     1     0     4     2
+#&gt; 10  19.2     6 167.6   123  3.92 3.440 18.30     1     0     4     4
+#&gt; # ... with 22 more rows
 #&gt; 
 #&gt; [[3]]
 #&gt; # A tibble: 71 × 2
-#&gt;   weight      feed
-#&gt;    &lt;dbl&gt;     &lt;chr&gt;
-#&gt; 1    179 horsebean
-#&gt; 2    160 horsebean
-#&gt; 3    136 horsebean
-#&gt; # ... with 68 more rows
+#&gt;    weight      feed
+#&gt;     &lt;dbl&gt;     &lt;chr&gt;
+#&gt;  1    179 horsebean
+#&gt;  2    160 horsebean
+#&gt;  3    136 horsebean
+#&gt;  4    227 horsebean
+#&gt;  5    217 horsebean
+#&gt;  6    168 horsebean
+#&gt;  7    108 horsebean
+#&gt;  8    124 horsebean
+#&gt;  9    143 horsebean
+#&gt; 10    140 horsebean
+#&gt; # ... with 61 more rows
 #&gt; 
 #&gt; [[4]]
 #&gt; # A tibble: 1,000 × 5
-#&gt;      lat   long depth   mag stations
-#&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;
-#&gt; 1 -20.42 181.62   562   4.8       41
-#&gt; 2 -20.62 181.03   650   4.2       15
-#&gt; 3 -26.00 184.10    42   5.4       43
-#&gt; # ... with 997 more rows
+#&gt;       lat   long depth   mag stations
+#&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;
+#&gt;  1 -20.42 181.62   562   4.8       41
+#&gt;  2 -20.62 181.03   650   4.2       15
+#&gt;  3 -26.00 184.10    42   5.4       43
+#&gt;  4 -17.97 181.66   626   4.1       19
+#&gt;  5 -20.42 181.96   649   4.0       11
+#&gt;  6 -19.68 184.31   195   4.0       12
+#&gt;  7 -11.70 166.10    82   4.8       43
+#&gt;  8 -28.11 181.93   194   4.4       15
+#&gt;  9 -28.74 181.74   211   4.7       35
+#&gt; 10 -17.47 179.59   622   4.3       19
+#&gt; # ... with 990 more rows
 #&gt; </div></pre>
   </div>
   <div class=""col-md-3 hidden-xs hidden-sm"" id=""sidebar"">

---FILE: docs/reference/index.html---
@@ -114,7 +114,7 @@
     <div class=""page-header"">
       <h1>
         Reference
-        <small>version&nbsp;1.0.0</small>
+        <small>version&nbsp;1.0.0.9000</small>
       </h1>
     </div>
 

---FILE: docs/reference/read_excel.html---
@@ -122,7 +122,7 @@ <h1>Read xls and xlsx files.</h1>
 read files without extension.</p>
     
 
-    <pre><span class='fu'>read_excel</span>(<span class='no'>path</span>, <span class='kw'>sheet</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>col_names</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>,
+    <pre class=""usage""><span class='fu'>read_excel</span>(<span class='no'>path</span>, <span class='kw'>sheet</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>col_names</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>,
   <span class='kw'>col_types</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>na</span> <span class='kw'>=</span> <span class='st'>""""</span>, <span class='kw'>trim_ws</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>, <span class='kw'>skip</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>n_max</span> <span class='kw'>=</span> <span class='fl'>Inf</span>,
   <span class='kw'>guess_max</span> <span class='kw'>=</span> <span class='fu'>min</span>(<span class='fl'>1000</span>, <span class='no'>n_max</span>))
 
@@ -216,26 +216,47 @@ <h2 class=""hasAnchor"" id=""see-also""><a class=""anchor"" href=""#see-also""></a>See a
     <h2 class=""hasAnchor"" id=""examples""><a class=""anchor"" href=""#examples""></a>Examples</h2>
     <pre class=""examples""><div class='input'><span class='no'>datasets</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='readxl_example.html'>readxl_example</a></span>(<span class='st'>""datasets.xlsx""</span>)
 <span class='fu'>read_excel</span>(<span class='no'>datasets</span>)</div><div class='output co'>#&gt; # A tibble: 150 × 5
-#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
-#&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;
-#&gt; 1          5.1         3.5          1.4         0.2  setosa
-#&gt; 2          4.9         3.0          1.4         0.2  setosa
-#&gt; 3          4.7         3.2          1.3         0.2  setosa
-#&gt; # ... with 147 more rows</div><div class='input'>
+#&gt;    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
+#&gt;           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;
+#&gt;  1          5.1         3.5          1.4         0.2  setosa
+#&gt;  2          4.9         3.0          1.4         0.2  setosa
+#&gt;  3          4.7         3.2          1.3         0.2  setosa
+#&gt;  4          4.6         3.1          1.5         0.2  setosa
+#&gt;  5          5.0         3.6          1.4         0.2  setosa
+#&gt;  6          5.4         3.9          1.7         0.4  setosa
+#&gt;  7          4.6         3.4          1.4         0.3  setosa
+#&gt;  8          5.0         3.4          1.5         0.2  setosa
+#&gt;  9          4.4         2.9          1.4         0.2  setosa
+#&gt; 10          4.9         3.1          1.5         0.1  setosa
+#&gt; # ... with 140 more rows</div><div class='input'>
 <span class='co'># Specify sheet either by position or by name</span>
 <span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='fl'>2</span>)</div><div class='output co'>#&gt; # A tibble: 32 × 11
-#&gt;     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
-#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
-#&gt; 1  21.0     6   160   110  3.90 2.620 16.46     0     1     4     4
-#&gt; 2  21.0     6   160   110  3.90 2.875 17.02     0     1     4     4
-#&gt; 3  22.8     4   108    93  3.85 2.320 18.61     1     1     4     1
-#&gt; # ... with 29 more rows</div><div class='input'><span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='st'>""mtcars""</span>)</div><div class='output co'>#&gt; # A tibble: 32 × 11
-#&gt;     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
-#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
-#&gt; 1  21.0     6   160   110  3.90 2.620 16.46     0     1     4     4
-#&gt; 2  21.0     6   160   110  3.90 2.875 17.02     0     1     4     4
-#&gt; 3  22.8     4   108    93  3.85 2.320 18.61     1     1     4     1
-#&gt; # ... with 29 more rows</div><div class='input'>
+#&gt;      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
+#&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
+#&gt;  1  21.0     6 160.0   110  3.90 2.620 16.46     0     1     4     4
+#&gt;  2  21.0     6 160.0   110  3.90 2.875 17.02     0     1     4     4
+#&gt;  3  22.8     4 108.0    93  3.85 2.320 18.61     1     1     4     1
+#&gt;  4  21.4     6 258.0   110  3.08 3.215 19.44     1     0     3     1
+#&gt;  5  18.7     8 360.0   175  3.15 3.440 17.02     0     0     3     2
+#&gt;  6  18.1     6 225.0   105  2.76 3.460 20.22     1     0     3     1
+#&gt;  7  14.3     8 360.0   245  3.21 3.570 15.84     0     0     3     4
+#&gt;  8  24.4     4 146.7    62  3.69 3.190 20.00     1     0     4     2
+#&gt;  9  22.8     4 140.8    95  3.92 3.150 22.90     1     0     4     2
+#&gt; 10  19.2     6 167.6   123  3.92 3.440 18.30     1     0     4     4
+#&gt; # ... with 22 more rows</div><div class='input'><span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='st'>""mtcars""</span>)</div><div class='output co'>#&gt; # A tibble: 32 × 11
+#&gt;      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
+#&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
+#&gt;  1  21.0     6 160.0   110  3.90 2.620 16.46     0     1     4     4
+#&gt;  2  21.0     6 160.0   110  3.90 2.875 17.02     0     1     4     4
+#&gt;  3  22.8     4 108.0    93  3.85 2.320 18.61     1     1     4     1
+#&gt;  4  21.4     6 258.0   110  3.08 3.215 19.44     1     0     3     1
+#&gt;  5  18.7     8 360.0   175  3.15 3.440 17.02     0     0     3     2
+#&gt;  6  18.1     6 225.0   105  2.76 3.460 20.22     1     0     3     1
+#&gt;  7  14.3     8 360.0   245  3.21 3.570 15.84     0     0     3     4
+#&gt;  8  24.4     4 146.7    62  3.69 3.190 20.00     1     0     4     2
+#&gt;  9  22.8     4 140.8    95  3.92 3.150 22.90     1     0     4     2
+#&gt; 10  19.2     6 167.6   123  3.92 3.440 18.30     1     0     4     4
+#&gt; # ... with 22 more rows</div><div class='input'>
 <span class='co'># Skip rows and use default column names</span>
 <span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='kw'>skip</span> <span class='kw'>=</span> <span class='fl'>148</span>, <span class='kw'>col_names</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>)</div><div class='output co'>#&gt; # A tibble: 3 × 5
 #&gt;    X__1  X__2  X__3  X__4      X__5
@@ -245,20 +266,34 @@ <h2 class=""hasAnchor"" id=""examples""><a class=""anchor"" href=""#examples""></a>Examp
 #&gt; 3   5.9   3.0   5.1   1.8 virginica</div><div class='input'>
 <span class='co'># Recycle a single column type</span>
 <span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='kw'>col_types</span> <span class='kw'>=</span> <span class='st'>""text""</span>)</div><div class='output co'>#&gt; # A tibble: 150 × 5
-#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
-#&gt;          &lt;chr&gt;       &lt;chr&gt;        &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt;
-#&gt; 1          5.1         3.5          1.4         0.2  setosa
-#&gt; 2          4.9           3          1.4         0.2  setosa
-#&gt; 3          4.7         3.2          1.3         0.2  setosa
-#&gt; # ... with 147 more rows</div><div class='input'>
+#&gt;    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
+#&gt;           &lt;chr&gt;       &lt;chr&gt;        &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt;
+#&gt;  1          5.1         3.5          1.4         0.2  setosa
+#&gt;  2          4.9           3          1.4         0.2  setosa
+#&gt;  3          4.7         3.2          1.3         0.2  setosa
+#&gt;  4          4.6         3.1          1.5         0.2  setosa
+#&gt;  5            5         3.6          1.4         0.2  setosa
+#&gt;  6          5.4         3.9          1.7         0.4  setosa
+#&gt;  7          4.6         3.4          1.4         0.3  setosa
+#&gt;  8            5         3.4          1.5         0.2  setosa
+#&gt;  9          4.4         2.9          1.4         0.2  setosa
+#&gt; 10          4.9         3.1          1.5         0.1  setosa
+#&gt; # ... with 140 more rows</div><div class='input'>
 <span class='co'># Specify some col_types and guess others</span>
 <span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='kw'>col_types</span> <span class='kw'>=</span> <span class='fu'>c</span>(<span class='st'>""text""</span>, <span class='st'>""guess""</span>, <span class='st'>""numeric""</span>, <span class='st'>""guess""</span>, <span class='st'>""guess""</span>))</div><div class='output co'>#&gt; # A tibble: 150 × 5
-#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
-#&gt;          &lt;chr&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;
-#&gt; 1          5.1         3.5          1.4         0.2  setosa
-#&gt; 2          4.9         3.0          1.4         0.2  setosa
-#&gt; 3          4.7         3.2          1.3         0.2  setosa
-#&gt; # ... with 147 more rows</div><div class='input'>
+#&gt;    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
+#&gt;           &lt;chr&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;
+#&gt;  1          5.1         3.5          1.4         0.2  setosa
+#&gt;  2          4.9         3.0          1.4         0.2  setosa
+#&gt;  3          4.7         3.2          1.3         0.2  setosa
+#&gt;  4          4.6         3.1          1.5         0.2  setosa
+#&gt;  5            5         3.6          1.4         0.2  setosa
+#&gt;  6          5.4         3.9          1.7         0.4  setosa
+#&gt;  7          4.6         3.4          1.4         0.3  setosa
+#&gt;  8            5         3.4          1.5         0.2  setosa
+#&gt;  9          4.4         2.9          1.4         0.2  setosa
+#&gt; 10          4.9         3.1          1.5         0.1  setosa
+#&gt; # ... with 140 more rows</div><div class='input'>
 <span class='co'># Accomodate a column with disparate types via col_type = ""list""</span>
 <span class='no'>df</span> <span class='kw'>&lt;-</span> <span class='fu'>read_excel</span>(<span class='fu'><a href='readxl_example.html'>readxl_example</a></span>(<span class='st'>""clippy.xlsx""</span>), <span class='kw'>col_types</span> <span class='kw'>=</span> <span class='fu'>c</span>(<span class='st'>""text""</span>, <span class='st'>""list""</span>))
 <span class='no'>df</span></div><div class='output co'>#&gt; # A tibble: 4 × 2
@@ -267,7 +302,7 @@ <h2 class=""hasAnchor"" id=""examples""><a class=""anchor"" href=""#examples""></a>Examp
 #&gt; 1                 Name  &lt;chr [1]&gt;
 #&gt; 2              Species  &lt;chr [1]&gt;
 #&gt; 3 Approx date of death &lt;dttm [1]&gt;
-#&gt; # ... with 1 more rows</div><div class='input'><span class='no'>df</span>$<span class='no'>value</span></div><div class='output co'>#&gt; [[1]]
+#&gt; 4      Weight in grams  &lt;dbl [1]&gt;</div><div class='input'><span class='no'>df</span>$<span class='no'>value</span></div><div class='output co'>#&gt; [[1]]
 #&gt; [1] ""Clippy""
 #&gt; 
 #&gt; [[2]]
@@ -304,7 +339,9 @@ <h2 class=""hasAnchor"" id=""examples""><a class=""anchor"" href=""#examples""></a>Examp
 #&gt; 1          1.4         0.2  setosa
 #&gt; 2          1.4         0.2  setosa
 #&gt; 3          1.3         0.2  setosa
-#&gt; # ... with 3 more rows</div><div class='input'><span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='st'>""R1C2:R2C5""</span>)</div><div class='output co'>#&gt; # A tibble: 1 × 4
+#&gt; 4          1.5         0.2  setosa
+#&gt; 5          1.4         0.2  setosa
+#&gt; 6          1.7         0.4  setosa</div><div class='input'><span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='st'>""R1C2:R2C5""</span>)</div><div class='output co'>#&gt; # A tibble: 1 × 4
 #&gt;   Sepal.Width Petal.Length Petal.Width Species
 #&gt;         &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;
 #&gt; 1         3.5          1.4         0.2  setosa</div><div class='input'>
@@ -315,21 +352,35 @@ <h2 class=""hasAnchor"" id=""examples""><a class=""anchor"" href=""#examples""></a>Examp
 #&gt; 1     6   160   110
 #&gt; 2     6   160   110
 #&gt; 3     4   108    93
-#&gt; # ... with 1 more rows</div><div class='input'>
+#&gt; 4     6   258   110</div><div class='input'>
 <span class='co'># Read only specific rows or columns</span>
 <span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='fu'><a href='cell-specification.html'>cell_rows</a></span>(<span class='fl'>102</span>:<span class='fl'>151</span>), <span class='kw'>col_names</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>)</div><div class='output co'>#&gt; # A tibble: 50 × 5
-#&gt;    X__1  X__2  X__3  X__4      X__5
-#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;chr&gt;
-#&gt; 1   6.3   3.3   6.0   2.5 virginica
-#&gt; 2   5.8   2.7   5.1   1.9 virginica
-#&gt; 3   7.1   3.0   5.9   2.1 virginica
-#&gt; # ... with 47 more rows</div><div class='input'><span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='fu'><a href='cell-specification.html'>cell_cols</a></span>(<span class='st'>""B:D""</span>))</div><div class='output co'>#&gt; # A tibble: 150 × 3
-#&gt;   Sepal.Width Petal.Length Petal.Width
-#&gt;         &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;
-#&gt; 1         3.5          1.4         0.2
-#&gt; 2         3.0          1.4         0.2
-#&gt; 3         3.2          1.3         0.2
-#&gt; # ... with 147 more rows</div></pre>
+#&gt;     X__1  X__2  X__3  X__4      X__5
+#&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;chr&gt;
+#&gt;  1   6.3   3.3   6.0   2.5 virginica
+#&gt;  2   5.8   2.7   5.1   1.9 virginica
+#&gt;  3   7.1   3.0   5.9   2.1 virginica
+#&gt;  4   6.3   2.9   5.6   1.8 virginica
+#&gt;  5   6.5   3.0   5.8   2.2 virginica
+#&gt;  6   7.6   3.0   6.6   2.1 virginica
+#&gt;  7   4.9   2.5   4.5   1.7 virginica
+#&gt;  8   7.3   2.9   6.3   1.8 virginica
+#&gt;  9   6.7   2.5   5.8   1.8 virginica
+#&gt; 10   7.2   3.6   6.1   2.5 virginica
+#&gt; # ... with 40 more rows</div><div class='input'><span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='fu'><a href='cell-specification.html'>cell_cols</a></span>(<span class='st'>""B:D""</span>))</div><div class='output co'>#&gt; # A tibble: 150 × 3
+#&gt;    Sepal.Width Petal.Length Petal.Width
+#&gt;          &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;
+#&gt;  1         3.5          1.4         0.2
+#&gt;  2         3.0          1.4         0.2
+#&gt;  3         3.2          1.3         0.2
+#&gt;  4         3.1          1.5         0.2
+#&gt;  5         3.6          1.4         0.2
+#&gt;  6         3.9          1.7         0.4
+#&gt;  7         3.4          1.4         0.3
+#&gt;  8         3.4          1.5         0.2
+#&gt;  9         2.9          1.4         0.2
+#&gt; 10         3.1          1.5         0.1
+#&gt; # ... with 140 more rows</div></pre>
   </div>
   <div class=""col-md-3 hidden-xs hidden-sm"" id=""sidebar"">
     <h2>Contents</h2>

---FILE: docs/reference/readxl_example.html---
@@ -120,7 +120,7 @@ <h1>Get path to readxl example</h1>
 directory. This function make them easy to access.</p>
     
 
-    <pre><span class='fu'>readxl_example</span>(<span class='kw'>path</span> <span class='kw'>=</span> <span class='kw'>NULL</span>)</pre>
+    <pre class=""usage""><span class='fu'>readxl_example</span>(<span class='kw'>path</span> <span class='kw'>=</span> <span class='kw'>NULL</span>)</pre>
     
     <h2 class=""hasAnchor"" id=""arguments""><a class=""anchor"" href=""#arguments""></a> Arguments</h2>
     <table class=""ref-arguments"">",False,False,Documentation / Formatting,4
tidyverse,readxl,e21d97965f54e708ae29c8ccbec1808db1c75417,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-04-17T14:22:22Z,GitHub,noreply@github.com,2017-04-17T14:22:22Z,"Correct shared string table indexing, AGAIN; fixes #333 (#343)",src/xlstool.c;tests/testthat/sheets/more-than-256-unique-strings-xls.xls;tests/testthat/test-shared-string-table.R,False,True,True,False,10,2,12,"---FILE: src/xlstool.c---
@@ -639,8 +639,8 @@ BYTE *xls_getfcell(xlsWorkBook* pWB,struct st_cell_data* cell,BYTE *label)
     switch (cell->id)
     {
     case XLS_RECORD_LABELSST:
-		//printf(""WORD: %u short: %u str: %s\n"", *label, xlsIntVal(*label), pWB->sst.string[xlsIntVal(*label)].str );
-        asprintf(&ret,""%s"",pWB->sst.string[xlsIntVal(*label)].str);
+		//printf(""WORD: %u short: %u str: %s\n"", *(DWORD_UA *)label, xlsIntVal(*(DWORD_UA *)label), pWB->sst.string[xlsIntVal(*(DWORD_UA *)label)].str );
+        asprintf(&ret,""%s"",pWB->sst.string[xlsIntVal(*(DWORD_UA *)label)].str);
         break;
     case XLS_RECORD_BLANK:
     case XLS_RECORD_MULBLANK:

---FILE: tests/testthat/test-shared-string-table.R---
@@ -0,0 +1,8 @@
+context(""Shared string table"")
+
+## #293, #333
+## affects xls only
+test_that(""shared strings are retrieved when there's >256 unique strings"", {
+  df <- read_excel(test_sheet(""more-than-256-unique-strings-xls.xls""))
+  expect_identical(df$var[257], ""x257"")
+})",True,False,Implementation / Logic,3
tidyverse,readxl,8e4a3ace4d0998f6e10ed34717663d8116b3eba1,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-04-15T14:33:34Z,GitHub,noreply@github.com,2017-04-15T14:33:34Z,Registration of native routines; fixes #331 (#337),NAMESPACE;R/read_excel.R;src/init.c,False,True,True,False,40,2,42,"---FILE: NAMESPACE---
@@ -14,4 +14,4 @@ importFrom(cellranger,anchored)
 importFrom(cellranger,cell_cols)
 importFrom(cellranger,cell_limits)
 importFrom(cellranger,cell_rows)
-useDynLib(readxl)
+useDynLib(readxl, .registration = TRUE)

---FILE: R/read_excel.R---
@@ -1,4 +1,4 @@
-#' @useDynLib readxl
+#' @useDynLib readxl, .registration = TRUE
 #' @importFrom Rcpp sourceCpp
 NULL
 

---FILE: src/init.c---
@@ -0,0 +1,38 @@
+#include <R.h>
+#include <Rinternals.h>
+#include <stdlib.h> // for NULL
+#include <R_ext/Rdynload.h>
+
+/* FIXME:
+Check these declarations against the C/Fortran source code.
+*/
+
+/* .Call calls */
+extern SEXP readxl_parse_ref(SEXP);
+extern SEXP readxl_read_xls_(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
+extern SEXP readxl_read_xlsx_(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
+extern SEXP readxl_xls_date_formats(SEXP);
+extern SEXP readxl_xls_sheets(SEXP);
+extern SEXP readxl_xlsx_date_formats(SEXP);
+extern SEXP readxl_xlsx_sheets(SEXP);
+extern SEXP readxl_xlsx_strings(SEXP);
+extern SEXP readxl_zip_xml(SEXP, SEXP);
+
+static const R_CallMethodDef CallEntries[] = {
+  {""readxl_parse_ref"",         (DL_FUNC) &readxl_parse_ref,         1},
+  {""readxl_read_xls_"",         (DL_FUNC) &readxl_read_xls_,         9},
+  {""readxl_read_xlsx_"",        (DL_FUNC) &readxl_read_xlsx_,        9},
+  {""readxl_xls_date_formats"",  (DL_FUNC) &readxl_xls_date_formats,  1},
+  {""readxl_xls_sheets"",        (DL_FUNC) &readxl_xls_sheets,        1},
+  {""readxl_xlsx_date_formats"", (DL_FUNC) &readxl_xlsx_date_formats, 1},
+  {""readxl_xlsx_sheets"",       (DL_FUNC) &readxl_xlsx_sheets,       1},
+  {""readxl_xlsx_strings"",      (DL_FUNC) &readxl_xlsx_strings,      1},
+  {""readxl_zip_xml"",           (DL_FUNC) &readxl_zip_xml,           2},
+  {NULL, NULL, 0}
+};
+
+void R_init_readxl(DllInfo *dll)
+{
+  R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
+  R_useDynamicSymbols(dll, FALSE);
+}",True,False,Dependency / Package,6
tidyverse,readxl,d05d385775822c84da392f8aebd18d987318af9b,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-04-15T14:32:10Z,GitHub,noreply@github.com,2017-04-15T14:32:10Z,"Report problematic cells in A1 notation (#336)

* Correct reported column in coercion warnings

* Utility functions to make A1 refs

* Report problematic cells in A1 / R1C1 notation; fixes #230

* Rename to cellPosition() and do `+ 1` in there

* Format switches() consistently",src/XlsCell.h;src/XlsWorkSheet.h;src/XlsxCell.h;src/XlsxWorkSheet.h;src/utils.h;tests/testthat/sheets/geometry.xls;tests/testthat/sheets/geometry.xlsx;tests/testthat/test-problems.R,False,True,True,False,157,103,260,"---FILE: src/XlsCell.h---
@@ -214,8 +214,8 @@ class XlsCell {
       break;
 
     default:
-      Rcpp::warning(""Unrecognized cell type at [%i, %i]: '%s'"",
-                    row() + 1, col() + 1, cell_->id);
+      Rcpp::warning(""Unrecognized cell type at %s: '%s'"",
+                    cellPosition(row(), col()), cell_->id);
     ct = CELL_UNKNOWN;
     }
 
@@ -259,10 +259,10 @@ class XlsCell {
     }
 
     default:
-      Rcpp::warning(""Unrecognized cell type at [%i, %i]: '%s'"",
-                    row() + 1, col() + 1, cell_->id);
-    return """";
-  }
+      Rcpp::warning(""Unrecognized cell type at %s: '%s'"",
+                    cellPosition(row(), col()), cell_->id);
+      return """";
+    }
   }
 
   Rcpp::RObject asCharSxp(const bool trimWs) const {
@@ -284,8 +284,8 @@ class XlsCell {
       return cell_->d != 0;
 
     default:
-      Rcpp::warning(""Unrecognized cell type at [%i, %i]: '%s'"",
-                    row() + 1, col() + 1, cell_->id);
+      Rcpp::warning(""Unrecognized cell type at %s: '%s'"",
+                    cellPosition(row(), col()), cell_->id);
     return NA_LOGICAL;
     }
   }
@@ -304,8 +304,8 @@ class XlsCell {
       return cell_->d;
 
     default:
-      Rcpp::warning(""Unrecognized cell type at [%i, %i]: '%s'"",
-                    row() + 1, col() + 1, cell_->id);
+      Rcpp::warning(""Unrecognized cell type at %s: '%s'"",
+                    cellPosition(row(), col()), cell_->id);
     return NA_REAL;
     }
   }
@@ -324,8 +324,8 @@ class XlsCell {
       return POSIXctFromSerial(cell_->d, is1904);
 
     default:
-      Rcpp::warning(""Unrecognized cell type at [%i, %i]: '%s'"",
-                    row() + 1, col() + 1, cell_->id);
+      Rcpp::warning(""Unrecognized cell type at %s: '%s'"",
+                    cellPosition(row(), col()), cell_->id);
     return NA_REAL;
     }
   }

---FILE: src/XlsWorkSheet.h---
@@ -7,6 +7,7 @@
 #include ""XlsCell.h""
 #include ""ColSpec.h""
 #include ""CellLimits.h""
+#include ""utils.h""
 
 class XlsWorkSheet {
   // the host workbook
@@ -150,26 +151,28 @@ class XlsWorkSheet {
     while (xcell != cells_.end()) {
 
       int i = xcell->row();
-      int j = xcell->col() - actual_.minCol();
+      int j = xcell->col();
+      // col to write into
+      int col = j - actual_.minCol();
       if ((i + 1) % 1000 == 0) {
         Rcpp::checkUserInterrupt();
       }
-      if (types[j] == COL_SKIP) {
+      if (types[col] == COL_SKIP) {
         xcell++;
         continue;
       }
 
       xcell->inferType(na, trimWs, dateFormats_);
       CellType type = xcell->type();
-      Rcpp::RObject col = cols[j];
+      Rcpp::RObject column = cols[col];
       // row to write into
       int row = i - base;
 
       // Fit cell of type x into a column of type y
       // Conventions:
       //   * process type in same order as enum, unless reason to do otherwise
       //   * access cell contents only via asWhatever() methods
-      switch(types[j]) {
+      switch(types[col]) {
 
       case COL_UNKNOWN:
       case COL_BLANK:
@@ -179,8 +182,8 @@ class XlsWorkSheet {
       case COL_LOGICAL:
         if (type == CELL_DATE) {
           // print date string here, when/if it's possible to do so
-          Rcpp::warning(""Expecting logical in [%i, %i] got a date"",
-                        i + 1, j + 1);
+          Rcpp::warning(""Expecting logical in %s: got a date"",
+                        cellPosition(i, j));
         }
 
         switch(type) {
@@ -189,17 +192,17 @@ class XlsWorkSheet {
         case CELL_LOGICAL:
         case CELL_DATE:
         case CELL_NUMERIC:
-          LOGICAL(col)[row] = xcell->asInteger();
+          LOGICAL(column)[row] = xcell->asInteger();
           break;
         case CELL_TEXT: {
           std::string text_string = xcell->asStdString(trimWs);
           bool text_boolean;
           if (logicalFromString(text_string, &text_boolean)) {
-            LOGICAL(col)[row] = text_boolean;
+            LOGICAL(column)[row] = text_boolean;
           } else {
-            Rcpp::warning(""Expecting logical in [%i, %i] got '%s'"",
-                          i + 1, j + 1, text_string);
-            LOGICAL(col)[row] = NA_LOGICAL;
+            Rcpp::warning(""Expecting logical in %s: got '%s'"",
+                          cellPosition(i, j), text_string);
+            LOGICAL(column)[row] = NA_LOGICAL;
           }
         }
           break;
@@ -208,52 +211,48 @@ class XlsWorkSheet {
 
       case COL_DATE:
         if (type == CELL_LOGICAL) {
-          Rcpp::warning(""Expecting date in [%i, %i]: got boolean"",
-                        i + 1, j + 1);
+          Rcpp::warning(""Expecting date in %s: got boolean"", cellPosition(i, j));
         }
         if (type == CELL_NUMERIC) {
-          Rcpp::warning(""Coercing numeric to date in [%i, %i]"",
-                        i + 1, j + 1);
+          Rcpp::warning(""Coercing numeric to date in %s"",
+                        cellPosition(i, j));
         }
         if (type == CELL_TEXT) {
-          Rcpp::warning(""Expecting date in [%i, %i]: got '%s'"",
-                        i + 1, j + 1,
+          Rcpp::warning(""Expecting date in %s: got '%s'"",
+                        cellPosition(i, j),
                         xcell->asStdString(trimWs));
         }
-        REAL(col)[row] = xcell->asDate(wb_.is1904());
+        REAL(column)[row] = xcell->asDate(wb_.is1904());
         break;
 
       case COL_NUMERIC:
         if (type == CELL_LOGICAL) {
-          Rcpp::warning(""Coercing boolean to numeric in [%i, %i]"",
-                        i + 1, j + 1);
+          Rcpp::warning(""Coercing boolean to numeric in %s"", cellPosition(i, j));
         }
         if (type == CELL_DATE) {
           // print date string here, when/if possible
-          Rcpp::warning(""Expecting numeric in [%i, %i]: got a date"",
-                        i + 1, j + 1);
+          Rcpp::warning(""Expecting numeric in %s: got a date"", cellPosition(i, j));
         }
         switch(type) {
         case CELL_UNKNOWN:
         case CELL_BLANK:
         case CELL_LOGICAL:
         case CELL_DATE:
         case CELL_NUMERIC:
-          REAL(col)[row] = xcell->asDouble();
+          REAL(column)[row] = xcell->asDouble();
           break;
-        case CELL_TEXT:
-        {
+        case CELL_TEXT: {
           std::string num_string = xcell->asStdString(trimWs);
           double num_num;
           bool success = doubleFromString(num_string, num_num);
           if (success) {
-            Rcpp::warning(""Coercing text to numeric in [%i, %i]: '%s'"",
-                          i + 1, j + 1, num_string);
-            REAL(col)[row] = num_num;
+            Rcpp::warning(""Coercing text to numeric in %s: '%s'"",
+                          cellPosition(i, j), num_string);
+            REAL(column)[row] = num_num;
           } else {
-            Rcpp::warning(""Expecting numeric in [%i, %i]: got '%s'"",
-                          i + 1, j + 1, num_string);
-            REAL(col)[row] = NA_REAL;
+            Rcpp::warning(""Expecting numeric in %s: got '%s'"",
+                          cellPosition(i, j), num_string);
+            REAL(column)[row] = NA_REAL;
           }
         }
           break;
@@ -263,34 +262,35 @@ class XlsWorkSheet {
       case COL_TEXT:
         // not issuing warnings for NAs or coercion, because ""text"" is the
         // fallback column type and there are too many warnings to be helpful
-        SET_STRING_ELT(col, row, xcell->asCharSxp(trimWs));
+        SET_STRING_ELT(column, row, xcell->asCharSxp(trimWs));
         break;
 
       case COL_LIST:
         switch(type) {
         case CELL_UNKNOWN:
         case CELL_BLANK:
-          SET_VECTOR_ELT(col, row, Rf_ScalarLogical(NA_LOGICAL));
+          SET_VECTOR_ELT(column, row, Rf_ScalarLogical(NA_LOGICAL));
           break;
         case CELL_LOGICAL:
-          SET_VECTOR_ELT(col, row, Rf_ScalarLogical(xcell->asInteger()));
+          SET_VECTOR_ELT(column, row, Rf_ScalarLogical(xcell->asInteger()));
           break;
         case CELL_DATE: {
           Rcpp::RObject cell_val = Rf_ScalarReal(xcell->asDate(wb_.is1904()));
           cell_val.attr(""class"") = Rcpp::CharacterVector::create(""POSIXct"", ""POSIXt"");
           cell_val.attr(""tzone"") = ""UTC"";
-          SET_VECTOR_ELT(col, row, cell_val);
+          SET_VECTOR_ELT(column, row, cell_val);
           break;
         }
         case CELL_NUMERIC:
-          SET_VECTOR_ELT(col, row, Rf_ScalarReal(xcell->asDouble()));
+          SET_VECTOR_ELT(column, row, Rf_ScalarReal(xcell->asDouble()));
           break;
         case CELL_TEXT: {
           Rcpp::CharacterVector rStringVector = Rcpp::CharacterVector(1, NA_STRING);
           SET_STRING_ELT(rStringVector, 0, xcell->asCharSxp(trimWs));
-          SET_VECTOR_ELT(col, row, rStringVector);
+          SET_VECTOR_ELT(column, row, rStringVector);
+          break;
+        }
         }
-      }
       }
       xcell++;
     }

---FILE: src/XlsxCell.h---
@@ -178,8 +178,8 @@ class XlsxCell {
       return;
     }
 
-    Rcpp::warning(""Unrecognized cell type at [%i, %i]: '%s'"",
-                  row() + 1, col() + 1, t->value());
+    Rcpp::warning(""Unrecognized cell type at %s: '%s'"",
+                  cellPosition(row(), col()), t->value());
   }
 
   std::string asStdString(const std::vector<std::string>& stringTable,
@@ -232,7 +232,7 @@ class XlsxCell {
     }
 
     default:
-      Rcpp::warning(""Unrecognized cell type at [%i, %i]"", row() + 1, col() + 1);
+      Rcpp::warning(""Unrecognized cell type at %s"", cellPosition(row(), col()));
       return """";
   }
   }
@@ -260,7 +260,7 @@ class XlsxCell {
     }
 
     default:
-      Rcpp::warning(""Unrecognized cell type at [%i, %i]"", row() + 1, col() + 1);
+      Rcpp::warning(""Unrecognized cell type at %s"", cellPosition(row(), col()));
       return NA_LOGICAL;
     }
   }
@@ -282,7 +282,7 @@ class XlsxCell {
     }
 
     default:
-      Rcpp::warning(""Unrecognized cell type at [%i, %i]"", row() + 1, col() + 1);
+      Rcpp::warning(""Unrecognized cell type at %s"", cellPosition(row(), col()));
       return NA_REAL;
     }
   }
@@ -304,7 +304,7 @@ class XlsxCell {
     }
 
     default:
-      Rcpp::warning(""Unrecognized cell type at [%i, %i]"", row() + 1, col() + 1);
+      Rcpp::warning(""Unrecognized cell type at %s"", cellPosition(row(), col()));
       return NA_REAL;
     }
   }
@@ -315,8 +315,7 @@ class XlsxCell {
                               const std::vector<std::string>& stringTable) const {
     int id = atoi(val);
     if (id < 0 || id >= (int) stringTable.size()) {
-      Rcpp::warning(""Invalid string id at [%i, %i]:  %i"",
-                    row() + 1, col() + 1, id);
+      Rcpp::warning(""Invalid string id at %s: %i"", cellPosition(row(), col()), id);
       return """";
     }
     const std::string& string = stringTable.at(id);

---FILE: src/XlsxWorkSheet.h---
@@ -164,26 +164,28 @@ class XlsxWorkSheet {
     while (xcell != cells_.end()) {
 
       int i = xcell->row();
-      int j = xcell->col() - actual_.minCol();
+      int j = xcell->col();
+      // col to write into
+      int col = j - actual_.minCol();
       if ((i + 1) % 1000 == 0) {
         Rcpp::checkUserInterrupt();
       }
-      if (types[j] == COL_SKIP) {
+      if (types[col] == COL_SKIP) {
         xcell++;
         continue;
       }
 
       xcell->inferType(na, trimWs, wb_.stringTable(), dateFormats_);
       CellType type = xcell->type();
-      Rcpp::RObject col = cols[j];
+      Rcpp::RObject column = cols[col];
       // row to write into
       int row = i - base;
 
       // Fit cell of type x into a column of type y
       // Conventions:
       //   * process type in same order as enum, unless reason to do otherwise
       //   * access cell contents only via asWhatever() methods
-      switch(types[j]) {
+      switch(types[col]) {
 
       case COL_UNKNOWN:
       case COL_BLANK:
@@ -193,8 +195,8 @@ class XlsxWorkSheet {
       case COL_LOGICAL:
         if (type == CELL_DATE) {
           // print date string here, when/if it's possible to do so
-          Rcpp::warning(""Expecting logical in [%i, %i]: got a date"",
-                        i + 1, j + 1);
+          Rcpp::warning(""Expecting logical in %s: got a date"",
+                        cellPosition(i, j));
         }
 
         switch(type) {
@@ -203,18 +205,17 @@ class XlsxWorkSheet {
         case CELL_LOGICAL:
         case CELL_DATE:
         case CELL_NUMERIC:
-          LOGICAL(col)[row] = xcell->asInteger();
+          LOGICAL(column)[row] = xcell->asInteger();
           break;
-        case CELL_TEXT:
-        {
+        case CELL_TEXT: {
           std::string text_string = xcell->asStdString(wb_.stringTable(), trimWs);
           bool text_boolean;
           if (logicalFromString(text_string, &text_boolean)) {
-            LOGICAL(col)[row] = text_boolean;
+            LOGICAL(column)[row] = text_boolean;
           } else {
-            Rcpp::warning(""Expecting logical in [%i, %i] got '%s'"",
-                          i + 1, j + 1, text_string);
-            LOGICAL(col)[row] = NA_LOGICAL;
+            Rcpp::warning(""Expecting logical in %s: got '%s'"",
+                          cellPosition(i, j), text_string);
+            LOGICAL(column)[row] = NA_LOGICAL;
           }
         }
           break;
@@ -223,51 +224,46 @@ class XlsxWorkSheet {
 
       case COL_DATE:
         if (type == CELL_LOGICAL) {
-          Rcpp::warning(""Expecting date in [%i, %i]: got boolean"",
-                        i + 1, j + 1);
+          Rcpp::warning(""Expecting date in %s: got boolean"", cellPosition(i, j));
         }
         if (type == CELL_NUMERIC) {
-          Rcpp::warning(""Coercing numeric to date in [%i, %i]"",
-                        i + 1, j + 1);
+          Rcpp::warning(""Coercing numeric to date %s"", cellPosition(i, j));
         }
         if (type == CELL_TEXT) {
-          Rcpp::warning(""Expecting date in [%i, %i]: got '%s'"",
-                        i + 1, j + 1, xcell->asStdString(wb_.stringTable(), trimWs));
+          Rcpp::warning(""Expecting date in %s: got '%s'"", cellPosition(i, j),
+                        xcell->asStdString(wb_.stringTable(), trimWs));
         }
-        REAL(col)[row] = xcell->asDate(wb_.is1904());
+        REAL(column)[row] = xcell->asDate(wb_.is1904());
         break;
 
       case COL_NUMERIC:
         if (type == CELL_LOGICAL) {
-          Rcpp::warning(""Coercing boolean to numeric in [%i, %i]"",
-                        i + 1, j + 1);
+          Rcpp::warning(""Coercing boolean to numeric in %s"", cellPosition(i, j));
         }
         if (type == CELL_DATE) {
           // print date string here, when/if possible
-          Rcpp::warning(""Expecting numeric in [%i, %i]: got a date"",
-                        i + 1, j + 1);
+          Rcpp::warning(""Expecting numeric in %s: got a date"", cellPosition(i, j));
         }
         switch(type) {
         case CELL_UNKNOWN:
         case CELL_BLANK:
         case CELL_LOGICAL:
         case CELL_DATE:
         case CELL_NUMERIC:
-          REAL(col)[row] = xcell->asDouble();
+          REAL(column)[row] = xcell->asDouble();
           break;
-        case CELL_TEXT:
-        {
+        case CELL_TEXT: {
           std::string num_string = xcell->asStdString(wb_.stringTable(), trimWs);
           double num_num;
           bool success = doubleFromString(num_string, num_num);
           if (success) {
-            Rcpp::warning(""Coercing text to numeric in [%i, %i]: '%s'"",
-                          i + 1, j + 1, num_string);
-            REAL(col)[row] = num_num;
+            Rcpp::warning(""Coercing text to numeric in %s: '%s'"",
+                          cellPosition(i, j), num_string);
+            REAL(column)[row] = num_num;
           } else {
-            Rcpp::warning(""Expecting numeric in [%i, %i]: got '%s'"",
-                          i + 1, j + 1, num_string);
-            REAL(col)[row] = NA_REAL;
+            Rcpp::warning(""Expecting numeric in %s: got '%s'"",
+                          cellPosition(i, j), num_string);
+            REAL(column)[row] = NA_REAL;
           }
         }
           break;
@@ -277,35 +273,32 @@ class XlsxWorkSheet {
       case COL_TEXT:
         // not issuing warnings for NAs or coercion, because ""text"" is the
         // fallback column type and there are too many warnings to be helpful
-        SET_STRING_ELT(col, row, xcell->asCharSxp(wb_.stringTable(), trimWs));
+        SET_STRING_ELT(column, row, xcell->asCharSxp(wb_.stringTable(), trimWs));
         break;
 
       case COL_LIST:
         switch(type) {
         case CELL_UNKNOWN:
-        case CELL_BLANK: {
-          SET_VECTOR_ELT(col, row, Rf_ScalarLogical(NA_LOGICAL));
+        case CELL_BLANK:
+          SET_VECTOR_ELT(column, row, Rf_ScalarLogical(NA_LOGICAL));
           break;
-        }
-        case CELL_LOGICAL: {
-          SET_VECTOR_ELT(col, row, Rf_ScalarLogical(xcell->asInteger()));
+        case CELL_LOGICAL:
+          SET_VECTOR_ELT(column, row, Rf_ScalarLogical(xcell->asInteger()));
           break;
-        }
         case CELL_DATE: {
           Rcpp::RObject cell_val = Rf_ScalarReal(xcell->asDate(wb_.is1904()));
           cell_val.attr(""class"") = Rcpp::CharacterVector::create(""POSIXct"", ""POSIXt"");
           cell_val.attr(""tzone"") = ""UTC"";
-          SET_VECTOR_ELT(col, row, cell_val);
+          SET_VECTOR_ELT(column, row, cell_val);
           break;
         }
-        case CELL_NUMERIC: {
-          SET_VECTOR_ELT(col, row, Rf_ScalarReal(xcell->asDouble()));
+        case CELL_NUMERIC:
+          SET_VECTOR_ELT(column, row, Rf_ScalarReal(xcell->asDouble()));
           break;
-        }
         case CELL_TEXT: {
           Rcpp::CharacterVector rStringVector = Rcpp::CharacterVector(1, NA_STRING);
           SET_STRING_ELT(rStringVector, 0, xcell->asCharSxp(wb_.stringTable(), trimWs));
-          SET_VECTOR_ELT(col, row, rStringVector);
+          SET_VECTOR_ELT(column, row, rStringVector);
           break;
         }
         }

---FILE: src/utils.h---
@@ -88,6 +88,31 @@ inline std::pair<int, int> parseRef(const char* ref) {
   return std::make_pair(row - 1, col - 1); // zero indexed
 }
 
+// col = 1 --> first column aka column A, so 1-indexed
+inline std::string intToABC(int col) {
+  std::string ret;
+  while (col > 0) {
+    col--;
+    ret = (char)('A' + col % 26) + ret;
+    col /= 26;
+  }
+  return ret;
+}
+
+// row = 1, col = 1 --> upper left cell aka column A1, so 1-indexed
+inline std::string asA1(const int row, const int col) {
+  std::ostringstream ret;
+  ret << intToABC(col) << row;
+  return ret.str();
+}
+
+// expects 0-indexed row and col
+inline std::string cellPosition(const int row, const int col) {
+  std::ostringstream ret;
+  ret << asA1(row + 1, col + 1) << "" / R"" << row + 1 << ""C"" << col + 1;
+  return ret.str();
+}
+
 inline bool logicalFromString(std::string maybe_tf, bool *out) {
   bool matches = false;
   if (Rf_StringTrue(maybe_tf.c_str())) {

---FILE: tests/testthat/test-problems.R---
@@ -0,0 +1,37 @@
+context(""Problems"")
+
+test_that(""coercion warnings report correct address"", {
+  ## xlsx
+  expect_warning(
+    read_excel(test_sheet(""geometry.xlsx""), sheet = ""warning_B6"",
+               col_types = ""numeric""),
+    ""Expecting numeric in B6 / R6C2"",
+    fixed = TRUE
+  )
+  expect_warning(
+    read_excel(test_sheet(""geometry.xlsx""), sheet = ""warning_AT6"",
+               col_types = ""numeric""),
+    ""Expecting numeric in AT6 / R6C46"",
+    fixed = TRUE
+  )
+  expect_warning(
+    read_excel(test_sheet(""geometry.xlsx""), sheet = ""warning_AKE6"",
+               col_types = ""numeric""),
+    ""Expecting numeric in AKE6 / R6C967"",
+    fixed = TRUE
+  )
+  ## xls
+  expect_warning(
+    read_excel(test_sheet(""geometry.xls""), sheet = ""warning_B6"",
+               col_types = ""numeric""),
+    ""Expecting numeric in B6 / R6C2"",
+    fixed = TRUE
+  )
+  expect_warning(
+    read_excel(test_sheet(""geometry.xls""), sheet = ""warning_AT6"",
+               col_types = ""numeric""),
+    ""Expecting numeric in AT6 / R6C46"",
+    fixed = TRUE
+  )
+  ## xls column max is 256, so we're done
+})",True,False,Implementation / Logic,6
tidyverse,readxl,831776a208d061aee97d03ddf43871ea992bed55,jennybc,jenny@stat.ubc.ca,2017-04-14T07:02:36Z,jennybc,jenny@stat.ubc.ca,2017-04-14T07:02:36Z,Fix link to libxls,README.Rmd;README.md;docs/articles/articles/readxl-workflows.html;docs/index.html,True,False,True,False,4,4,8,"---FILE: README.Rmd---
@@ -18,7 +18,7 @@ knitr::opts_chunk$set(
 
 The readxl package makes it easy to get data out of Excel and into R. Compared to many of the existing packages (e.g. gdata, xlsx, xlsReadWrite) readxl has no external dependencies, so it's easy to install and use on all operating systems.  It is designed to work with _tabular_ data stored in a single sheet.
 
-readxl supports both the legacy `.xls` format and the modern xml-based `.xlsx` format. The `.xls` [libxls](http://sourceforge.net/projects/libxls/) C library is used to support `.xls`, which abstracts away many of the complexities of the underlying binary format. To parse `.xlsx`, we use the [RapidXML](http://rapidxml.sourceforge.net) C++ library.
+readxl supports both the legacy `.xls` format and the modern xml-based `.xlsx` format. The [libxls](https://sourceforge.net/projects/libxls/) C library is used to support `.xls`, which abstracts away many of the complexities of the underlying binary format. To parse `.xlsx`, we use the [RapidXML](http://rapidxml.sourceforge.net) C++ library.
 
 ## Installation
 

---FILE: README.md---
@@ -7,7 +7,7 @@ readxl <img src=""logo.png"" align=""right"" />
 
 The readxl package makes it easy to get data out of Excel and into R. Compared to many of the existing packages (e.g. gdata, xlsx, xlsReadWrite) readxl has no external dependencies, so it's easy to install and use on all operating systems. It is designed to work with *tabular* data stored in a single sheet.
 
-readxl supports both the legacy `.xls` format and the modern xml-based `.xlsx` format. The `.xls` [libxls](http://sourceforge.net/projects/libxls/) C library is used to support `.xls`, which abstracts away many of the complexities of the underlying binary format. To parse `.xlsx`, we use the [RapidXML](http://rapidxml.sourceforge.net) C++ library.
+readxl supports both the legacy `.xls` format and the modern xml-based `.xlsx` format. The [libxls](https://sourceforge.net/projects/libxls/) C library is used to support `.xls`, which abstracts away many of the complexities of the underlying binary format. To parse `.xlsx`, we use the [RapidXML](http://rapidxml.sourceforge.net) C++ library.
 
 Installation
 ------------

---FILE: docs/articles/articles/readxl-workflows.html---
@@ -367,7 +367,7 @@ <h2 class=""hasAnchor"">
 #>  language (EN)                        
 #>  collate  en_CA.UTF-8                 
 #>  tz       America/Vancouver           
-#>  date     2017-04-13
+#>  date     2017-04-14
 #> Packages -----------------------------------------------------------------
 #>  package    * version     date       source                              
 #>  assertthat   0.2.0       2017-04-11 cran (@0.2.0)                       

---FILE: docs/index.html---
@@ -83,7 +83,7 @@
 
 
 <p>The readxl package makes it easy to get data out of Excel and into R. Compared to many of the existing packages (e.g. gdata, xlsx, xlsReadWrite) readxl has no external dependencies, so it’s easy to install and use on all operating systems. It is designed to work with <em>tabular</em> data stored in a single sheet.</p>
-<p>readxl supports both the legacy <code>.xls</code> format and the modern xml-based <code>.xlsx</code> format. The <code>.xls</code> <a href=""http://sourceforge.net/projects/libxls/"">libxls</a> C library is used to support <code>.xls</code>, which abstracts away many of the complexities of the underlying binary format. To parse <code>.xlsx</code>, we use the <a href=""http://rapidxml.sourceforge.net"">RapidXML</a> C++ library.</p>
+<p>readxl supports both the legacy <code>.xls</code> format and the modern xml-based <code>.xlsx</code> format. The <a href=""https://sourceforge.net/projects/libxls/"">libxls</a> C library is used to support <code>.xls</code>, which abstracts away many of the complexities of the underlying binary format. To parse <code>.xlsx</code>, we use the <a href=""http://rapidxml.sourceforge.net"">RapidXML</a> C++ library.</p>
 <div id=""installation"" class=""section level2"">
 <h2 class=""hasAnchor"">
 <a href=""#installation"" class=""anchor""></a>Installation</h2>",False,True,Documentation / Formatting,7
tidyverse,readxl,b253a05574958d78bd5dfa55590103eaa5043ded,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-04-12T21:11:35Z,GitHub,noreply@github.com,2017-04-12T21:11:35Z,"Reconcile our ""fork"" of libxls with upstream; closes #319 (#329)

* Overwrite our libxls ""fork"" with current svn ""HEAD""

https://github.com/svn2github/libxls/commit/bb84eb995d035dff845f3eec875f0c468f691b26

* Don't clutter this operation with xls2csv.c

* No, do not define DEBUG_DRAWINGS

* Suppress print debugging re: XLS_RECORD_MULRK in xls_addCell()

* Reinstate the fix made in PR #273

Rescues read of last column in xls written by some 3rd party tools

* Reinstate the fixes made in PR #312

* Replace #ifdef AIX with #if defined(_AIX) || defined(__sun)

* _WIN32 handling, don't warn for check re: endian-ness

* Bring print statement into line with code

* Changes re: ""flexible array members""

* Whitespace the way libxls likes it

* Match va_start() and va_end(); see #195

* Reinstate asprintf() fix from #246

* Re-mask illegal functions for CMD check

* Possible refactor of cran.h

* Undefine assert before redefining

* Quiet more warnings

These are more harmless than they seem on the surface, because there is lots of code in these files that is inside `#ifdef 0 ... `#endif` blocks and the like.",src/cran.h;src/endian.c;src/libxls/xlstool.h;src/ole.c;src/xls.c;src/xlstool.c,False,False,False,False,14,5,19,"---FILE: src/cran.h---
@@ -10,8 +10,8 @@
  * fprintf uses two additional arguments.
  */
 #define fprintf(err, msg, a1, a2) Rprintf(msg, a1, a2)
-#define exit assert
 #undef assert
 #define assert(X) if (X) {}
+#define exit assert
 
 #endif

---FILE: src/endian.c---
@@ -42,6 +42,7 @@ int xls_is_bigendian()
 #elif defined (__LITTLE_ENDIAN__)
     return 0;
 #else
+// #warning NO ENDIAN
     static int n = 1;
 
     if (*(char *)&n == 1)

---FILE: src/libxls/xlstool.h---
@@ -31,6 +31,7 @@
  */
 
 #include ""libxls/xlsstruct.h""
+/* Mask illegal functions for CMD check */
 #include ""cran.h""
 
 extern void dumpbuf(BYTE* fname,long size,BYTE* buf);

---FILE: src/ole.c---
@@ -82,6 +82,8 @@ void ole2_bufread(OLE2Stream* olest)
 			olest->cfat++;
 		} else {
 
+			assert(olest->fatpos >= 0);
+
 			//printf(""fatpos: %d max=%u\n"",olest->fatpos, (olest->ole->cfat*olest->ole->lsector)/4);
 			if(olest->fatpos > (olest->ole->cfat*olest->ole->lsector)/4) exit(-1);
 

---FILE: src/xls.c---
@@ -121,8 +121,8 @@ struct drawHeader {
 static char *formData;
 static char *formFunc;
 static struct drawHeader drawProc(uint8_t *buf, uint32_t maxLen, uint32_t *off, int level);
-// static void dumpRec(char *comment, struct drawHeader *h, int len, uint8_t *buf);
-// static int finder(uint8_t *buf, uint32_t len, uint16_t pattern);
+static void dumpRec(char *comment, struct drawHeader *h, int len, uint8_t *buf);
+static int finder(uint8_t *buf, uint32_t len, uint16_t pattern);
 static uint32_t sheetOffset;
 #endif
 
@@ -509,6 +509,7 @@ struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
 		if(formula_handler) formula_handler(bof->id, bof->size, buf);
         break;
     case XLS_RECORD_MULRK:
+// printf(""MULRK: %d\n"", bof->size);
         for (i = 0; i < (bof->size - 6)/6; i++)	// 6 == 2 row + 2 col + 2 trailing index
         {
             cell=&row->cells.cell[xlsShortVal(((MULRK*)buf)->col + i)];
@@ -1057,6 +1058,7 @@ void xls_parseWorkSheet(xlsWorkSheet* pWS)
     BOF tmp;
     BYTE* buf;
 	long offset = pWS->filepos;
+	// int continueRec = 0;
 
 	struct st_cell_data *cell;
 	xlsWorkBook *pWB = pWS->workbook;
@@ -1342,6 +1344,7 @@ void xls_parseWorkSheet(xlsWorkSheet* pWS)
 #endif
 
         default:
+		  // printBOF:
 			if(xls_debug)
 			{
 				//xls_showBOF(&tmp);
@@ -2081,7 +2084,6 @@ static struct drawHeader drawProc(uint8_t *buf, uint32_t maxLen, uint32_t *off_p
 	return head;
 }
 
-#if 0
 static void dumpData(char *data);
 static void dumpFunc(char *func);
 
@@ -2147,6 +2149,7 @@ static void dumpFunc(char *func)
 	free(oldStr);
 }
 
+#if 0
 static int finder(uint8_t *buf, uint32_t len, uint16_t pattern)
 {
 	int ret = 0;

---FILE: src/xlstool.c---
@@ -57,6 +57,8 @@
 
 extern int xls_debug;
 
+// static void xls_showBOUNDSHEET(void* bsheet);
+
 static const DWORD colors[] =
     {
         0x000000,
@@ -637,7 +639,7 @@ BYTE *xls_getfcell(xlsWorkBook* pWB,struct st_cell_data* cell,BYTE *label)
     switch (cell->id)
     {
     case XLS_RECORD_LABELSST:
-		//printf(""WORD: %u short: %u str: %s\n"", *label, xlsShortVal(*label), pWB->sst.string[xlsShortVal(*label)].str );
+		//printf(""WORD: %u short: %u str: %s\n"", *label, xlsIntVal(*label), pWB->sst.string[xlsIntVal(*label)].str );
         asprintf(&ret,""%s"",pWB->sst.string[xlsIntVal(*label)].str);
         break;
     case XLS_RECORD_BLANK:",False,False,Implementation / Logic,3
tidyverse,readxl,38e3510c8e30b08b001d723dfbfb3ed03b63c6d1,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-04-06T14:16:53Z,GitHub,noreply@github.com,2017-04-06T14:16:53Z,Don't let implicit skipping of empty rows screw up n_max; fixes #316 (#322),src/CellLimits.h;src/XlsWorkSheet.h;src/XlsxWorkSheet.h;tests/testthat/test-n-max.R;tests/testthat/test-skipping.R,False,True,True,False,154,59,213,"---FILE: src/CellLimits.h---
@@ -53,6 +53,14 @@ class CellLimits {
     }
   }
 
+  void update(const int minRow, const int maxRow,
+              const int minCol, const int maxCol) {
+    minRow_ = minRow;
+    maxRow_ = maxRow;
+    minCol_ = minCol;
+    maxCol_ = maxCol;
+  }
+
   bool contains(const XlsCell cell) const {
     return contains(cell.row(), cell.col());
   }

---FILE: src/XlsWorkSheet.h---
@@ -45,10 +45,14 @@ class XlsWorkSheet {
     xls_parseWorkSheet(pWS_);
     dateFormats_ = wb.dateFormats();
 
-                                   // nominal_ holds user's geometry request
-    loadCells();                   // actual_ reports populated cells
-                                   //   inside the nominal_ rectangle
-    if (shim) insertShims();       // insert shims and update actual_
+    // nominal_ holds user's geometry request
+    loadCells(shim);
+    // nominal_ may have been shifted (case of implicit skipping and n_max)
+    // actual_ reports populated cells inside the nominal_ rectangle
+
+    // insert shims and update actual_
+    if (shim) insertShims();
+
     nrow_ = (actual_.minRow() < 0) ? 0 : actual_.maxRow() - actual_.minRow() + 1;
     ncol_ = (actual_.minCol() < 0) ? 0 : actual_.maxCol() - actual_.minCol() + 1;
   }
@@ -295,7 +299,7 @@ class XlsWorkSheet {
 
 private:
 
-  void loadCells() {
+  void loadCells(const bool shim) {
     // by convention, min_row = -2 means 'read no data'
     if (nominal_.minRow() < -1) {
       return;
@@ -305,34 +309,35 @@ class XlsWorkSheet {
     int nominal_nrow = pWS_->rows.lastrow;
 
     xls::xlsCell *cell;
+    bool nominal_needs_checking = !shim && nominal_.maxRow() >= 0;
     for (xls::WORD i = 0; i <= nominal_nrow; ++i) {
-      if (!nominal_.contains(i)) {
+
+      if (i < nominal_.minRow() ||
+          (!nominal_needs_checking && !nominal_.contains(i))) {
         continue;
       }
+
       for (xls::WORD j = 0; j <= nominal_ncol; ++j) {
 
-        if (nominal_.contains(i, j)) {
+        if (nominal_needs_checking) {
           cell = xls_cell(pWS_, i, j);
-        } else {
-          continue;
-        }
-
-        if (!cell) {
-          continue;
+          if (cell_is_readable(cell)) {
+            if (i > nominal_.minRow()) { // implicit skip
+              nominal_.update(
+                i, i + nominal_.maxRow() - nominal_.minRow(),
+                nominal_.minCol(), nominal_.maxCol()
+              );
+            }
+            nominal_needs_checking = false;
+          }
         }
 
-        // Dimensions reported by xls itself include blank cells that have
-        // formatting, therefore we test explicitly for non-blank cell types
-        // and only load those cells.
-        // 2.4.90 Dimensions p273 of [MS-XLS]
-        if (cell->id == XLS_RECORD_MULRK || cell->id == XLS_RECORD_NUMBER ||
-            cell->id == XLS_RECORD_RK ||
-            cell->id == XLS_RECORD_LABELSST || cell->id == XLS_RECORD_LABEL ||
-            cell->id == XLS_RECORD_FORMULA ||  cell->id == XLS_RECORD_FORMULA_ALT ||
-            cell->id == XLS_RECORD_BOOLERR
-        ) {
-          cells_.push_back(cell);
-          actual_.update(i, j);
+        if (nominal_.contains(i, j)) {
+          cell = xls_cell(pWS_, i, j);
+          if (cell_is_readable(cell)) {
+            cells_.push_back(cell);
+            actual_.update(i, j);
+          }
         }
       }
     }
@@ -410,6 +415,23 @@ class XlsWorkSheet {
     return(it);
   }
 
+  // Dimensions reported by xls and cells contained in xls include blank cells
+  // that have formatting, therefore we test explicitly for non-blank cell types
+  // and only load those cells.
+  // 2.4.90 Dimensions p273 of [MS-XLS]
+  bool cell_is_readable(const xls::xlsCell *cell) {
+    return cell && (
+        cell->id == XLS_RECORD_MULRK ||
+        cell->id == XLS_RECORD_NUMBER ||
+        cell->id == XLS_RECORD_RK ||
+        cell->id == XLS_RECORD_LABELSST ||
+        cell->id == XLS_RECORD_LABEL ||
+        cell->id == XLS_RECORD_FORMULA ||
+        cell->id == XLS_RECORD_FORMULA_ALT ||
+        cell->id == XLS_RECORD_BOOLERR
+    );
+  }
+
 };
 
 #endif

---FILE: src/XlsxWorkSheet.h---
@@ -61,10 +61,14 @@ class XlsxWorkSheet {
     }
     dateFormats_ = wb.dateFormats();
 
-                                   // nominal_ holds user's geometry request
-    loadCells();                   // actual_ reports populated cells
-                                   //   inside the nominal_ rectangle
-    if (shim) insertShims();       // insert shims and update actual_
+    // nominal_ holds user's geometry request
+    loadCells(shim);
+    // nominal_ may have been shifted (case of implicit skipping and n_max)
+    // actual_ reports populated cells inside the nominal_ rectangle
+
+    // insert shims and update actual_
+    if (shim) insertShims();
+
     nrow_ = (actual_.minRow() < 0) ? 0 : actual_.maxRow() - actual_.minRow() + 1;
     ncol_ = (actual_.minCol() < 0) ? 0 : actual_.maxCol() - actual_.minCol() + 1;
   }
@@ -312,7 +316,7 @@ class XlsxWorkSheet {
 
 private:
 
-  void loadCells() {
+  void loadCells(const bool shim) {
     // by convention, min_row = -2 means 'read no data'
     if (nominal_.minRow() < -1) {
       return;
@@ -324,6 +328,7 @@ class XlsxWorkSheet {
     }
 
     int i = 0;
+    bool nominal_needs_checking = !shim && nominal_.maxRow() >= 0;
     for (; row; row = row->next_sibling(""row"")) {
       int j = 0;
       for (rapidxml::xml_node<>* cell = row->first_node(""c"");
@@ -332,15 +337,29 @@ class XlsxWorkSheet {
         // only consider cells that have >= 1 child nodes
         // we require cell to have content, not just, e.g., a format
         if (first_child != NULL) {
+          // We have a cell!
+
           // (i, j) is our best guess at location, but if cell declares
           // it's own location, we store that instead
           XlsxCell xcell(cell, i, j);
           i = xcell.row();
           j = xcell.col();
+
+          if (nominal_needs_checking) {
+            if (i > nominal_.minRow()) { // implicit skip happened
+              nominal_.update(
+                i, i + nominal_.maxRow() - nominal_.minRow(),
+                nominal_.minCol(), nominal_.maxCol()
+              );
+            }
+            nominal_needs_checking = false;
+          }
+
           if (nominal_.contains(i, j)) {
             cells_.push_back(xcell);
             actual_.update(i, j);
           }
+
         }
         j++;
       }

---FILE: tests/testthat/test-n-max.R---
@@ -75,3 +75,47 @@ test_that(""n_max = nrows in dense sheet when col_names = FALSE"", {
   df <- read_excel(test_sheet(""iris-excel.xls""), n_max = 18, col_names = FALSE)
   expect_identical(nrow(df), 18L)
 })
+
+test_that(""n_max directive survives implicit skipping of empty rows [xlsx]"", {
+  ## col_names = TRUE
+  explicit <-
+    read_excel(test_sheet(""geometry.xlsx""), skip = 2, n_max = 1)
+  implicit_skip_all <-
+    read_excel(test_sheet(""geometry.xlsx""), n_max = 1)
+  mixed_skip <-
+    read_excel(test_sheet(""geometry.xlsx""), skip = 1, n_max = 1)
+  expect_identical(explicit, implicit_skip_all)
+  expect_identical(explicit, mixed_skip)
+
+  ## col_names = FALSE
+  explicit <-
+    read_excel(test_sheet(""geometry.xlsx""), skip = 2, n_max = 1, col_names = FALSE)
+  implicit_skip_all <-
+    read_excel(test_sheet(""geometry.xlsx""), n_max = 1, col_names = FALSE)
+  mixed_skip <-
+    read_excel(test_sheet(""geometry.xlsx""), skip = 1, n_max = 1, col_names = FALSE)
+  expect_identical(explicit, implicit_skip_all)
+  expect_identical(explicit, mixed_skip)
+})
+
+test_that(""n_max directive survives implicit skipping of empty rows [xls]"", {
+  ## col_names = TRUE
+  explicit <-
+    read_excel(test_sheet(""geometry.xls""), skip = 2, n_max = 1)
+  implicit_skip_all <-
+    read_excel(test_sheet(""geometry.xls""), n_max = 1)
+  mixed_skip <-
+    read_excel(test_sheet(""geometry.xls""), skip = 1, n_max = 1)
+  expect_identical(explicit, implicit_skip_all)
+  expect_identical(explicit, mixed_skip)
+
+  ## col_names = FALSE
+  explicit <-
+    read_excel(test_sheet(""geometry.xls""), skip = 2, n_max = 1, col_names = FALSE)
+  implicit_skip_all <-
+    read_excel(test_sheet(""geometry.xls""), n_max = 1, col_names = FALSE)
+  mixed_skip <-
+    read_excel(test_sheet(""geometry.xls""), skip = 1, n_max = 1, col_names = FALSE)
+  expect_identical(explicit, implicit_skip_all)
+  expect_identical(explicit, mixed_skip)
+})

---FILE: tests/testthat/test-skipping.R---
@@ -2,31 +2,33 @@ context(""Skipping"")
 
 skipping_xlsx <- test_sheet(""skipping.xlsx"")
 skipping_xls <- test_sheet(""skipping.xls"")
-df <- tibble::tribble(~ var1, ~ var2,
-                          NA,     NA,
-                      ""v2,1"", ""v2,2"",
-                          NA,     NA,
-                      ""v4,1"", ""v4,2"")
+ref <- tibble::tribble(
+  ~ var1, ~ var2,
+      NA,     NA,
+  ""v2,1"", ""v2,2"",
+      NA,     NA,
+  ""v4,1"", ""v4,2""
+)
 
 test_that(""leading blank rows are implicitly skipped"", {
-  out <- read_excel(skipping_xlsx, sheet = ""two_blank_rows"")
-  expect_identical(df, out)
-  out <- read_excel(skipping_xls, sheet = ""two_blank_rows"")
-  expect_identical(df, out)
+  xlsx <- read_excel(skipping_xlsx, sheet = ""two_blank_rows"")
+  xls <- read_excel(skipping_xls, sheet = ""two_blank_rows"")
+  expect_identical(xlsx, ref)
+  expect_identical(xls, ref)
 })
 
 test_that(""leading blank rows can be explicitly skipped"", {
-  out <- read_excel(skipping_xlsx, sheet = ""two_blank_rows"", skip = 2)
-  expect_identical(df, out)
-  out <- read_excel(skipping_xls, sheet = ""two_blank_rows"", skip = 2)
-  expect_identical(df, out)
+  xlsx <- read_excel(skipping_xlsx, sheet = ""two_blank_rows"", skip = 2)
+  xls <- read_excel(skipping_xls, sheet = ""two_blank_rows"", skip = 2)
+  expect_identical(xlsx, ref)
+  expect_identical(xls, ref)
 })
 
 test_that(""leading blank rows can be implicitly AND explicitly skipped"", {
-  out <- read_excel(skipping_xlsx, sheet = ""two_blank_rows"", skip = 1)
-  expect_identical(df, out)
-  out <- read_excel(skipping_xls, sheet = ""two_blank_rows"", skip = 1)
-  expect_identical(df, out)
+  xlsx <- read_excel(skipping_xlsx, sheet = ""two_blank_rows"", skip = 1)
+  xls <- read_excel(skipping_xls, sheet = ""two_blank_rows"", skip = 1)
+  expect_identical(xlsx, ref)
+  expect_identical(xls, ref)
 })
 
 test_that(""failure to skip junk leads to garbage df but no error"", {
@@ -56,22 +58,22 @@ test_that(""failure to skip junk leads to garbage df but no error"", {
 })
 
 test_that(""explicit skip of leading junk, implicit skip of blank rows"", {
-  out <- read_excel(skipping_xlsx, sheet = ""occupied_row_and_blank_row"", skip = 1)
-  expect_identical(df, out)
-  out <- read_excel(skipping_xls, sheet = ""occupied_row_and_blank_row"", skip = 1)
-  expect_identical(df, out)
+  xlsx <- read_excel(skipping_xlsx, sheet = ""occupied_row_and_blank_row"", skip = 1)
+  xls <- read_excel(skipping_xls, sheet = ""occupied_row_and_blank_row"", skip = 1)
+  expect_identical(xlsx, ref)
+  expect_identical(xls, ref)
 })
 
 test_that(""explicit skip of leading junk and blank rows"", {
-  out <- read_excel(skipping_xlsx, sheet = ""occupied_row_and_blank_row"", skip = 2)
-  expect_identical(df, out)
-  out <- read_excel(skipping_xls, sheet = ""occupied_row_and_blank_row"", skip = 2)
-  expect_identical(df, out)
+  xlsx <- read_excel(skipping_xlsx, sheet = ""occupied_row_and_blank_row"", skip = 2)
+  xls <- read_excel(skipping_xls, sheet = ""occupied_row_and_blank_row"", skip = 2)
+  expect_identical(xlsx, ref)
+  expect_identical(xls, ref)
 })
 
 test_that(""explicit skip of leading junk"", {
-  out <- read_excel(skipping_xlsx, sheet = ""two_occupied_rows"", skip = 2)
-  expect_identical(out, df)
-  out <- read_excel(skipping_xls, sheet = ""two_occupied_rows"", skip = 2)
-  expect_identical(out, df)
+  xlsx <- read_excel(skipping_xlsx, sheet = ""two_occupied_rows"", skip = 2)
+  xls <- read_excel(skipping_xls, sheet = ""two_occupied_rows"", skip = 2)
+  expect_identical(ref, xlsx)
+  expect_identical(ref, xls)
 })",True,False,Implementation / Logic,6
tidyverse,readxl,b80ac1114a9336fbbd510f76bbf4e79e45761fb3,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-04-04T21:14:51Z,GitHub,noreply@github.com,2017-04-04T21:14:51Z,"Target arbitrary and open rectangles; fixes #8, fixes #313 (#314)

* Rough in for cellranger

* Delete xls[x]_col_[names|types], FINALLY

I imagine these were useful at an earlier stage of development. But I never use them  and I'm tired of keeping them current.

* Prepare the sheet geometry API to handle a cell range

* Introduce shim cells

* ""it works for xls""

* Help, examples, pkgdown

* More pkgdown [skip ci]

* Explain sheet and cell limit standardization on the R side

* Style

* Streamline and comment geometry work

  * Kill firstRow_ and secondRow_
  * Kill empirical_
  * Don't even load cells outside nominal_.
  * Eliminate gratuitous trips through cells_ related to learning or setting geometry.

* funny_*() fxns for more readable inequalities and extrema

* Clear warnings: ""control reaches end of non-void function""

* Coerce in the read_xls[s]_ function definition

* Make minRow, minCol, etc fields

* NEWS, README, pkgdown

* Update the xlsx side

* Entire rows can be skipped on xls side

* Rationalize new geometry tests, extend to xlsx",.gitignore;DESCRIPTION;NAMESPACE;NEWS.md;R/RcppExports.R;R/cell-specification.R;R/read_excel.R;README.Rmd;README.md;_pkgdown.yml;docs/favicon.ico;docs/index.html;docs/news/index.html;docs/reference/cell-specification.html;docs/reference/excel_sheets.html;docs/reference/index.html;docs/reference/read_excel.html;docs/reference/readxl-package.html;docs/reference/readxl_example.html;inst/extdata/geometry.xls;inst/extdata/geometry.xlsx;man/cell-specification.Rd;man/figures/logo.png;man/read_excel.Rd;man/readxl-package.Rd;src/CellLimits.h;src/RcppExports.cpp;src/XlsCell.h;src/XlsWorkSheet.cpp;src/XlsWorkSheet.h;src/XlsxCell.h;src/XlsxWorkSheet.cpp;src/XlsxWorkSheet.h;tests/BIFF5-LABEL-record-string-read-mac-10-11.supp;tests/testthat/sheets/geometry.xls;tests/testthat/sheets/geometry.xlsx;tests/testthat/sheets/skipping.xls;tests/testthat/sheets/types.xls;tests/testthat/sheets/types.xlsx;tests/testthat/test-col-types.R;tests/testthat/test-geometry.R;tests/testthat/test-missing-values.R;tests/testthat/test-n-max.R,True,True,True,False,1597,519,2116,"---FILE: .gitignore---
@@ -3,3 +3,4 @@
 .RData
 ~*
 xldocs
+clippy/geometry.key

---FILE: DESCRIPTION---
@@ -20,6 +20,7 @@ License: GPL-3 + file LICENSE
 LazyData: true
 LinkingTo: Rcpp
 Imports:
+    cellranger,
     Rcpp (>= 0.11.6),
     tibble (>= 1.1)
 Suggests:

---FILE: NAMESPACE---
@@ -1,9 +1,17 @@
 # Generated by roxygen2: do not edit by hand
 
+export(anchored)
+export(cell_cols)
+export(cell_limits)
+export(cell_rows)
 export(excel_sheets)
 export(read_excel)
 export(read_xls)
 export(read_xlsx)
 export(readxl_example)
 importFrom(Rcpp,sourceCpp)
+importFrom(cellranger,anchored)
+importFrom(cellranger,cell_cols)
+importFrom(cellranger,cell_limits)
+importFrom(cellranger,cell_rows)
 useDynLib(readxl)

---FILE: NEWS.md---
@@ -2,13 +2,15 @@
 
 ## Sheet geometry
 
-* `n_max` is a new argument that limits the number of data rows read from the spreadsheet. Control over whether column names will be read from the sheet remains with `col_names`. (#306, #281)
+* `range` is a new argument for reading a rectangular range, possibly open. (#314, #8)
 
-* Empty cells, rows, columns (xlsx #248 and #240, xls #271): Cells with no content are no longer loaded, even if they appear in the file. Affects cells that have no data but that carry explicit formatting, detectable in Excel as seemingly empty cells with a format other than ""General"". Such cells will still exist in the returned tibble, with value `NA`, if there are other non-empty cells in the row or column.
+* `n_max` is a new argument that limits the number of data rows read. (#306, #281)
+
+* Empty cells, rows, columns (xlsx #248 and #240, xls #271): Cells with no content are no longer loaded, even if they appear in the file. Affects cells that have no data but that carry explicit formatting, detectable in Excel as seemingly empty cells with a format other than ""General"". Such cells may still exist in the returned tibble, with value `NA`, depending on the sheet geometry.
   
     * Eliminates a source of trailing rows (#203) and columns (#236, #162, #146) consisting entirely of `NA`.
     * Eliminates a subtle source of disagreement between user-provided column names and guessed column types (#169, #81).
-    * Leading or embedded empty columns are no longer automatically dropped, regardless of whether there is a column name. (#157, #261)
+    * Embedded empty columns are no longer automatically dropped, regardless of whether there is a column name. (#157, #261)
     * Worksheets that are completely empty or that contain only column names no longer error, but return a tibble with zero rows. (#222, #144, #65)
     * Improved handling of leading and embedded blank rows and explicit row skipping. (#224, #194, #178, #156, #101)
 

---FILE: R/RcppExports.R---
@@ -9,16 +9,8 @@ xls_date_formats <- function(path) {
     .Call('readxl_xls_date_formats', PACKAGE = 'readxl', path)
 }
 
-xls_col_names <- function(path, na, sheet_i = 0L, skip = 0L, n_max = 1L) {
-    .Call('readxl_xls_col_names', PACKAGE = 'readxl', path, na, sheet_i, skip, n_max)
-}
-
-xls_col_types <- function(path, na, sheet_i = 0L, skip = 0L, n_max = -1L, guess_max = 1000L, has_col_names = FALSE) {
-    .Call('readxl_xls_col_types', PACKAGE = 'readxl', path, na, sheet_i, skip, n_max, guess_max, has_col_names)
-}
-
-read_xls_ <- function(path, sheet_i, col_names, col_types, na, skip = 0L, n_max = -1L, guess_max = 1000L) {
-    .Call('readxl_read_xls_', PACKAGE = 'readxl', path, sheet_i, col_names, col_types, na, skip, n_max, guess_max)
+read_xls_ <- function(path, sheet_i, limits, shim, col_names, col_types, na, guess_max = 1000L) {
+    .Call('readxl_read_xls_', PACKAGE = 'readxl', path, sheet_i, limits, shim, col_names, col_types, na, guess_max)
 }
 
 xlsx_sheets <- function(path) {
@@ -37,16 +29,8 @@ parse_ref <- function(ref) {
     .Call('readxl_parse_ref', PACKAGE = 'readxl', ref)
 }
 
-xlsx_col_types <- function(path, sheet_i = 0L, na = character(), skip = 0L, n_max = -1L, guess_max = 1000L, has_col_names = FALSE) {
-    .Call('readxl_xlsx_col_types', PACKAGE = 'readxl', path, sheet_i, na, skip, n_max, guess_max, has_col_names)
-}
-
-xlsx_col_names <- function(path, na = character(), sheet_i = 0L, skip = 0L, n_max = 1L) {
-    .Call('readxl_xlsx_col_names', PACKAGE = 'readxl', path, na, sheet_i, skip, n_max)
-}
-
-read_xlsx_ <- function(path, sheet_i, col_names, col_types, na, skip = 0L, n_max = -1L, guess_max = 1000L) {
-    .Call('readxl_read_xlsx_', PACKAGE = 'readxl', path, sheet_i, col_names, col_types, na, skip, n_max, guess_max)
+read_xlsx_ <- function(path, sheet_i, limits, shim, col_names, col_types, na, guess_max = 1000L) {
+    .Call('readxl_read_xlsx_', PACKAGE = 'readxl', path, sheet_i, limits, shim, col_names, col_types, na, guess_max)
 }
 
 zip_xml <- function(zip_path, file_path) {

---FILE: R/cell-specification.R---
@@ -0,0 +1,83 @@
+#' Specify cells for reading
+#'
+#' The `range` argument of [read_excel()] provides many ways to limit the read
+#' to a specific rectangle of cells. The simplest usage is to provide an
+#' Excel-like cell range, such as `range = ""D12:F15""` or `range =
+#' ""R1C12:R6C15""`. The cell rectangle can be specified in various other ways,
+#' using helper functions. In all cases, cell range processing is handled by the
+#' [cellranger][cellranger] package, where you can find full documentation for
+#' the functions used in the examples below.
+#'
+#' @examples
+#' path <- readxl_example(""geometry.xls"")
+#' ## Rows 1 and 2 are empty (as are rows 7 and higher)
+#' ## Column 1 aka ""A"" is empty (as are columns 5 of ""E"" and higher)
+#'
+#' # By default, the populated data cells are ""shrink-wrapped"" into a
+#' # minimal data frame
+#' read_excel(path)
+#'
+#' # Specific rectangle that is subset of populated cells, possibly improper
+#' read_excel(path, range = ""B3:D6"")
+#' read_excel(path, range = ""C3:D5"")
+#'
+#' # Specific rectangle that forces inclusion of unpopulated cells
+#' read_excel(path, range = ""A3:D5"")
+#' read_excel(path, range = ""A4:E5"")
+#' read_excel(path, range = ""C5:E7"")
+#'
+#' # Anchor a rectangle of specified size at a particular cell
+#' read_excel(path, range = anchored(""C4"", dim = c(3, 2)), col_names = FALSE)
+#'
+#' # Specify only the rows or only the columns
+#' read_excel(path, range = cell_rows(3:6))
+#' read_excel(path, range = cell_cols(""C:D""))
+#' read_excel(path, range = cell_cols(2))
+#'
+#' # Specify exactly one row or column bound
+#' read_excel(path, range = cell_rows(c(5, NA)))
+#' read_excel(path, range = cell_rows(c(NA, 4)))
+#' read_excel(path, range = cell_cols(c(""C"", NA)))
+#' read_excel(path, range = cell_cols(c(NA, 2)))
+#'
+#' # General open rectangles
+#' # upper left = C4, everything else unspecified
+#' read_excel(path, range = cell_limits(c(4, 3), c(NA, NA)))
+#' # upper right = D4, everything else unspecified
+#' read_excel(path, range = cell_limits(c(4, NA), c(NA, 4)))
+#'
+#' @seealso The [cellranger][cellranger] package has full documentation on cell
+#'   specification and offers additional functions for manipulating ""A1:D10""
+#'   style spreadsheet ranges. Here are the most relevant:
+#'   \itemize{
+#'     \item [cellranger::cell_limits()]
+#'     \item [cellranger::cell_rows()]
+#'     \item [cellranger::cell_cols()]
+#'     \item [cellranger::anchored()]
+#'   }
+#' @name cell-specification
+NULL
+
+#' @importFrom cellranger cell_limits
+#' @name cell_limits
+#' @export
+#' @rdname cell-specification
+NULL
+
+#' @importFrom cellranger cell_rows
+#' @name cell_rows
+#' @export
+#' @rdname cell-specification
+NULL
+
+#' @importFrom cellranger cell_cols
+#' @name cell_cols
+#' @export
+#' @rdname cell-specification
+NULL
+
+#' @importFrom cellranger anchored
+#' @name anchored
+#' @export
+#' @rdname cell-specification
+NULL

---FILE: R/read_excel.R---
@@ -7,6 +7,10 @@ NULL
 #' @param path Path to the xls/xlsx file
 #' @param sheet Sheet to read. Either a string (the name of a sheet), or an
 #'   integer (the position of the sheet). Defaults to the first sheet.
+#' @param range A cell range to read from, as described in [cell-specification].
+#'   Includes typical Excel ranges like ""B3:D87"" and more. Interpreted strictly,
+#'   even if the range includes leading or trailing empty rows or columns. Takes
+#'   precedence over `skip` and `n_max`.
 #' @param col_names `TRUE` to use the first row as column names, `FALSE` to get
 #'   default names, or a character vector giving a name for each column. If user
 #'   provides `col_types` as a vector, `col_names` can have one entry per
@@ -15,18 +19,24 @@ NULL
 #' @param col_types Either `NULL` to guess all from the spreadsheet or a
 #'   character vector containing one entry per column from these options:
 #'   ""skip"", ""guess"", ""logical"", ""numeric"", ""date"", ""text"" or ""list"". If exactly
-#'   on `col_type` is specified, it will be recycled. The content of a cell in a
-#'   skipped column is never read and that column will not appear in the data
+#'   one `col_type` is specified, it will be recycled. The content of a cell in
+#'   a skipped column is never read and that column will not appear in the data
 #'   frame output. A list cell loads a column as a list of length 1 vectors,
 #'   which are typed using the type guessing logic from `col_types = NULL`, but
 #'   on a cell-by-cell basis.
 #' @param na Character vector of strings to use for missing values. By default,
 #'   readxl treats blank cells as missing data.
-#' @param skip Number of rows to skip before reading anything (column names or
-#'   data). Leading blank rows are automatically skipped.
-#' @param n_max Maximum number of data rows to read.
+#' @param skip Minimum number of rows to skip before reading anything, be it
+#'   column names or data. Leading empty rows are automatically skipped, so this
+#'   is a lower bound. Ignored if `range` is given.
+#' @param n_max Maximum number of data rows to read. Trailing empty rows are
+#'   automatically skipped, so this is an upper bound on the number of rows in
+#'   the returned tibble. Ignored if `range` is given.
 #' @param guess_max Maximum number of data rows to use for guessing column
 #'   types.
+#' @return A [tibble][tibble::tibble-package]
+#' @seealso [cell-specification] for more details on targetting cells with the
+#'   `range` argument
 #' @export
 #' @examples
 #' datasets <- readxl_example(""datasets.xlsx"")
@@ -39,24 +49,34 @@ NULL
 #' # Skip rows and use default column names
 #' read_excel(datasets, skip = 148, col_names = FALSE)
 #'
-#' # Recycle a length-one col_types
+#' # Recycle a single column type
 #' read_excel(datasets, col_types = ""text"")
 #'
 #' # Specify some col_types and guess others
 #' read_excel(datasets, col_types = c(""text"", ""guess"", ""numeric"", ""guess"", ""guess""))
 #'
-#' # ""list"" col_type can handle information of disparate types
+#' # Accomodate a column with disparate types via col_type = ""list""
 #' df <- read_excel(readxl_example(""clippy.xlsx""), col_types = c(""text"", ""list""))
 #' df
 #' df$value
+#' sapply(df$value, class)
 #'
 #' # Limit the number of data rows read
 #' read_excel(datasets, n_max = 3)
-read_excel <- function(path, sheet = 1L, col_names = TRUE, col_types = NULL,
+#'
+#' # Read from an Excel range using A1 or R1C1 notation
+#' read_excel(datasets, range = ""C1:E7"")
+#' read_excel(datasets, range = ""R1C2:R2C5"")
+#'
+#' # Read only specific rows or columns
+#' read_excel(datasets, range = cell_rows(102:151), col_names = FALSE)
+#' read_excel(datasets, range = cell_cols(""B:D""))
+read_excel <- function(path, sheet = 1L, range = NULL,
+                       col_names = TRUE, col_types = NULL,
                        na = """", skip = 0, n_max = Inf,
                        guess_max = min(1000, n_max)) {
   read_excel_(
-    path = path, sheet = sheet,
+    path = path, sheet = sheet, range = range,
     col_names = col_names, col_types = col_types,
     na = na, skip = skip, n_max = n_max, guess_max = guess_max,
     excel_format(path)
@@ -69,11 +89,12 @@ read_excel <- function(path, sheet = 1L, col_names = TRUE, col_types = NULL,
 #'
 #' @rdname read_excel
 #' @export
-read_xls <- function(path, sheet = 1L, col_names = TRUE, col_types = NULL,
+read_xls <- function(path, sheet = 1L, range = NULL,
+                     col_names = TRUE, col_types = NULL,
                      na = """", skip = 0, n_max = Inf,
                      guess_max = min(1000, n_max)) {
   read_excel_(
-    path = path, sheet = sheet,
+    path = path, sheet = sheet, range = range,
     col_names = col_names, col_types = col_types,
     na = na, skip = skip, n_max = n_max, guess_max = guess_max,
     format = ""xls""
@@ -82,18 +103,20 @@ read_xls <- function(path, sheet = 1L, col_names = TRUE, col_types = NULL,
 
 #' @rdname read_excel
 #' @export
-read_xlsx <- function(path, sheet = 1L, col_names = TRUE, col_types = NULL,
+read_xlsx <- function(path, sheet = 1L, range = NULL,
+                      col_names = TRUE, col_types = NULL,
                       na = """", skip = 0, n_max = Inf,
                       guess_max = min(1000, n_max)) {
   read_excel_(
-    path = path, sheet = sheet,
+    path = path, sheet = sheet, range = range,
     col_names = col_names, col_types = col_types,
     na = na, skip = skip, n_max = n_max, guess_max = guess_max,
     format = ""xlsx""
   )
 }
 
-read_excel_ <- function(path, sheet = 1L, col_names = TRUE, col_types = NULL,
+read_excel_ <- function(path, sheet = 1L, range = NULL,
+                        col_names = TRUE, col_types = NULL,
                         na = """", skip = 0, n_max = Inf,
                         guess_max = min(1000, n_max), format) {
   if (format == ""xls"") {
@@ -104,14 +127,16 @@ read_excel_ <- function(path, sheet = 1L, col_names = TRUE, col_types = NULL,
     read_fun <- read_xlsx_
   }
   sheet <- standardise_sheet(sheet, sheets_fun(path))
-  n_max <- check_n_max(n_max)
+  shim <- !is.null(range)
+  limits <- standardise_limits(range, skip, n_max, has_col_names = isTRUE(col_names))
   guess_max <- check_guess_max(guess_max)
   col_types <- check_col_types(col_types)
   tibble::repair_names(
     tibble::as_tibble(
       read_fun(path = path, sheet = sheet,
+               limits = limits, shim = shim,
                col_names = col_names, col_types = col_types,
-               na = na, skip = skip, n_max = n_max, guess_max = guess_max),
+               na = na, guess_max = guess_max),
       validate = FALSE
     ),
     prefix = ""X"", sep = ""__""
@@ -136,6 +161,7 @@ excel_format <- function(path) {
   )
 }
 
+## return a zero-indexed sheet number
 standardise_sheet <- function(sheet, sheet_names) {
   if (length(sheet) != 1) {
     stop(""`sheet` must have length 1"", call. = FALSE)
@@ -156,6 +182,35 @@ standardise_sheet <- function(sheet, sheet_names) {
   }
 }
 
+## return a zero-indexed vector describing the corners of a cell rectangle:
+## min_row, max_row, min_col, max_col
+## NA becomes -1 and means ""unspecified"", by convention
+## if both min and max are -1, for rows or cols, means ""read them all""
+## min_row = -2 is a special flag meaning ""read no rows""
+standardise_limits <- function(range, skip, n_max, has_col_names) {
+  if (is.null(range)) {
+    skip <- check_non_negative_integer(skip, ""skip"")
+    n_max <- check_non_negative_integer(n_max, ""n_max"")
+    n_read <- if (has_col_names) n_max + 1 else n_max
+    limits <- c(
+      min_row = if (n_read > 0) skip else -2,
+      max_row = if (n_read == Inf || n_read == 0) NA else skip + n_read - 1,
+      min_col = NA,
+      max_col = NA
+    )
+  } else {
+    limits <- cellranger::as.cell_limits(range)
+    limits <- c(
+      min_row = limits[[""ul""]][1] - 1,
+      max_row = limits[[""lr""]][1] - 1,
+      min_col = limits[[""ul""]][2] - 1,
+      max_col = limits[[""lr""]][2] - 1
+    )
+  }
+  limits[is.na(limits)] <- -1
+  limits
+}
+
 check_col_types <- function(col_types) {
   if (is.null(col_types)) {
     return(""guess"")
@@ -181,27 +236,17 @@ check_col_types <- function(col_types) {
   col_types
 }
 
-check_n_max <- function(n_max) {
-
-  if (length(n_max) != 1 || !is.numeric(n_max) || !is_integerish(n_max) ||
-      is.na(n_max) || n_max < 0) {
-    stop(""`n_max` must be a positive integer"", call. = FALSE)
-  }
-
-  if (n_max == Inf) {
-    n_max <- -1
+check_non_negative_integer <- function(i, arg_name) {
+  if (length(i) != 1 || !is.numeric(i) || !is_integerish(i) ||
+      is.na(i) || i < 0) {
+    stop(""`"", arg_name, ""` must be a positive integer"", call. = FALSE)
   }
-  n_max
+  i
 }
 
 ## from readr
 check_guess_max <- function(guess_max, max_limit = .Machine$integer.max %/% 100) {
-
-  if (length(guess_max) != 1 || !is.numeric(guess_max) || !is_integerish(guess_max) ||
-      is.na(guess_max) || guess_max < 0) {
-    stop(""`guess_max` must be a positive integer"", call. = FALSE)
-  }
-
+  guess_max <- check_non_negative_integer(guess_max, ""guess_max"")
   if (guess_max > max_limit) {
     warning(""`guess_max` is a very large value, setting to `"", max_limit,
             ""` to avoid exhausting memory"", call. = FALSE)

---FILE: README.Rmd---
@@ -79,6 +79,15 @@ read_excel(xlsx_example, sheet = ""chickwts"")
 read_excel(xls_example, sheet = 4)
 ```
 
+There are various ways to control which cells are read.
+
+```{r}
+read_excel(xlsx_example, n_max = 3)
+read_excel(xls_example, range = ""C1:E4"")
+read_excel(xls_example, range = cell_rows(1:4))
+read_excel(xls_example, range = cell_cols(""B:D""))
+```
+
 If `NA`s are represented by something other than blank cells, set the `na` argument.
 
 ```{r}
@@ -94,7 +103,7 @@ If you are new to the tidyverse conventions for data import, you may want to con
 * Loads datetimes into POSIXct columns. Both Windows (1900) and Mac (1904) 
   date specifications are processed correctly.
 
-* Blank rows that appear before the data are automatically dropped; embedded blank rows are not. User can exert more control of this with `skip`.
+* Blank rows that appear before the data are automatically dropped; embedded blank rows are not. User can exert more control with `range`, `skip`, and `n_max`.
 
 * Column names and types are determined from the data in the sheet, by default, but user can also supply via `col_names` and `col_types`.
 

---FILE: README.md---
@@ -95,6 +95,40 @@ read_excel(xls_example, sheet = 4)
 #> # ... with 997 more rows
 ```
 
+There are various ways to control which cells are read.
+
+``` r
+read_excel(xlsx_example, n_max = 3)
+#> # A tibble: 3 × 5
+#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
+#>          <dbl>       <dbl>        <dbl>       <dbl>   <chr>
+#> 1          5.1         3.5          1.4         0.2  setosa
+#> 2          4.9         3.0          1.4         0.2  setosa
+#> 3          4.7         3.2          1.3         0.2  setosa
+read_excel(xls_example, range = ""C1:E4"")
+#> # A tibble: 3 × 3
+#>   Petal.Length Petal.Width Species
+#>          <dbl>       <dbl>   <chr>
+#> 1          1.4         0.2  setosa
+#> 2          1.4         0.2  setosa
+#> 3          1.3         0.2  setosa
+read_excel(xls_example, range = cell_rows(1:4))
+#> # A tibble: 3 × 5
+#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
+#>          <dbl>       <dbl>        <dbl>       <dbl>   <chr>
+#> 1          5.1         3.5          1.4         0.2  setosa
+#> 2          4.9         3.0          1.4         0.2  setosa
+#> 3          4.7         3.2          1.3         0.2  setosa
+read_excel(xls_example, range = cell_cols(""B:D""))
+#> # A tibble: 150 × 3
+#>   Sepal.Width Petal.Length Petal.Width
+#>         <dbl>        <dbl>       <dbl>
+#> 1         3.5          1.4         0.2
+#> 2         3.0          1.4         0.2
+#> 3         3.2          1.3         0.2
+#> # ... with 147 more rows
+```
+
 If `NA`s are represented by something other than blank cells, set the `na` argument.
 
 ``` r
@@ -117,7 +151,7 @@ Features
 
 -   Loads datetimes into POSIXct columns. Both Windows (1900) and Mac (1904) date specifications are processed correctly.
 
--   Blank rows that appear before the data are automatically dropped; embedded blank rows are not. User can exert more control of this with `skip`.
+-   Blank rows that appear before the data are automatically dropped; embedded blank rows are not. User can exert more control with `range`, `skip`, and `n_max`.
 
 -   Column names and types are determined from the data in the sheet, by default, but user can also supply via `col_names` and `col_types`.
 

---FILE: _pkgdown.yml---
@@ -7,3 +7,31 @@ home:
   links:
   - text: Learn more
     href: http://r4ds.had.co.nz/data-import.html
+
+reference:
+  - title: ""Read spreadsheets""
+    desc: >
+      Functions for reading tabular data out of xls and xlsx files.
+    contents:
+      - read_excel
+      - read_xls
+      - read_xlsx
+  - title: ""Get spreadsheet metadata""
+    desc: >
+      Functions to learn properties of xls and xlsx files.
+    contents:
+      - excel_sheets
+  - title: ""Describe a target rectangle""
+    desc: >
+      Flexible specification of cell rectangles.
+    contents:
+      - ""`cell-specification`""
+      - cell_rows
+      - cell_cols
+      - anchored
+      - cell_limits
+  - title: ""Example files""
+    desc: >
+      List or get the path to xls and xlsx example files in the package.
+    contents:
+      - readxl_example

---FILE: docs/index.html---
@@ -68,7 +68,7 @@
 <p>readxl supports both the legacy <code>.xls</code> format and the modern xml-based <code>.xlsx</code> format. The <code>.xls</code> <a href=""http://sourceforge.net/projects/libxls/"">libxls</a> C library is used to support <code>.xls</code>, which abstracts away many of the complexities of the underlying binary format. To parse <code>.xlsx</code>, we use the <a href=""http://rapidxml.sourceforge.net"">RapidXML</a> C++ library.</p>
 <div id=""installation"" class=""section level2"">
 <h2 class=""hasAnchor"">
-<a href=""#installation"" class=""anchor""> </a>Installation</h2>
+<a href=""#installation"" class=""anchor""></a>Installation</h2>
 <p>The easiest way to install the latest released version from CRAN is to install the whole tidyverse (NOTE: you will still need to load readxl explicitly, i.e. it is not a core tidyverse package loaded via <code>library(tidyverse)</code>.)</p>
 <div class=""sourceCode""><pre class=""sourceCode r""><code class=""sourceCode r""><span class=""kw"">install.packages</span>(<span class=""st"">""tidyverse""</span>)</code></pre></div>
 <p>Alternatively, install just readxl from CRAN:</p>
@@ -79,7 +79,7 @@ <h2 class=""hasAnchor"">
 </div>
 <div id=""usage"" class=""section level2"">
 <h2 class=""hasAnchor"">
-<a href=""#usage"" class=""anchor""> </a>Usage</h2>
+<a href=""#usage"" class=""anchor""></a>Usage</h2>
 <p>readxl includes example files <code>datasets.xlsx</code> and <code>datasets.xls</code>, containing datasets you already know and love. These files were created with the help of openxlsx and Excel. Paths to all example files are available via the helper <code><a href=""reference/readxl_example.html"">readxl_example()</a></code>.</p>
 <div class=""sourceCode""><pre class=""sourceCode r""><code class=""sourceCode r"">l &lt;-<span class=""st""> </span><span class=""kw"">list</span>(<span class=""st"">""iris""</span> =<span class=""st""> </span>iris, <span class=""st"">""mtcars""</span> =<span class=""st""> </span>mtcars, <span class=""dt"">chickwts =</span> chickwts, <span class=""dt"">quakes =</span> quakes)
 openxlsx::<span class=""kw"">write.xlsx</span>(l, <span class=""dt"">file =</span> <span class=""st"">""inst/extdata/datasets.xlsx""</span>)</code></pre></div>
@@ -125,6 +125,36 @@ <h2 class=""hasAnchor"">
 <span class=""co"">#&gt; 2 -20.62 181.03   650   4.2       15</span>
 <span class=""co"">#&gt; 3 -26.00 184.10    42   5.4       43</span>
 <span class=""co"">#&gt; # ... with 997 more rows</span></code></pre></div>
+<p>There are various ways to control which cells are read.</p>
+<div class=""sourceCode""><pre class=""sourceCode r""><code class=""sourceCode r""><span class=""kw""><a href=""reference/read_excel.html"">read_excel</a></span>(xlsx_example, <span class=""dt"">n_max =</span> <span class=""dv"">3</span>)
+<span class=""co"">#&gt; # A tibble: 3 × 5</span>
+<span class=""co"">#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species</span>
+<span class=""co"">#&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;</span>
+<span class=""co"">#&gt; 1          5.1         3.5          1.4         0.2  setosa</span>
+<span class=""co"">#&gt; 2          4.9         3.0          1.4         0.2  setosa</span>
+<span class=""co"">#&gt; 3          4.7         3.2          1.3         0.2  setosa</span>
+<span class=""kw""><a href=""reference/read_excel.html"">read_excel</a></span>(xls_example, <span class=""dt"">range =</span> <span class=""st"">""C1:E4""</span>)
+<span class=""co"">#&gt; # A tibble: 3 × 3</span>
+<span class=""co"">#&gt;   Petal.Length Petal.Width Species</span>
+<span class=""co"">#&gt;          &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;</span>
+<span class=""co"">#&gt; 1          1.4         0.2  setosa</span>
+<span class=""co"">#&gt; 2          1.4         0.2  setosa</span>
+<span class=""co"">#&gt; 3          1.3         0.2  setosa</span>
+<span class=""kw""><a href=""reference/read_excel.html"">read_excel</a></span>(xls_example, <span class=""dt"">range =</span> <span class=""kw""><a href=""reference/cell-specification.html"">cell_rows</a></span>(<span class=""dv"">1</span>:<span class=""dv"">4</span>))
+<span class=""co"">#&gt; # A tibble: 3 × 5</span>
+<span class=""co"">#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species</span>
+<span class=""co"">#&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;</span>
+<span class=""co"">#&gt; 1          5.1         3.5          1.4         0.2  setosa</span>
+<span class=""co"">#&gt; 2          4.9         3.0          1.4         0.2  setosa</span>
+<span class=""co"">#&gt; 3          4.7         3.2          1.3         0.2  setosa</span>
+<span class=""kw""><a href=""reference/read_excel.html"">read_excel</a></span>(xls_example, <span class=""dt"">range =</span> <span class=""kw""><a href=""reference/cell-specification.html"">cell_cols</a></span>(<span class=""st"">""B:D""</span>))
+<span class=""co"">#&gt; # A tibble: 150 × 3</span>
+<span class=""co"">#&gt;   Sepal.Width Petal.Length Petal.Width</span>
+<span class=""co"">#&gt;         &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;</span>
+<span class=""co"">#&gt; 1         3.5          1.4         0.2</span>
+<span class=""co"">#&gt; 2         3.0          1.4         0.2</span>
+<span class=""co"">#&gt; 3         3.2          1.3         0.2</span>
+<span class=""co"">#&gt; # ... with 147 more rows</span></code></pre></div>
 <p>If <code>NA</code>s are represented by something other than blank cells, set the <code>na</code> argument.</p>
 <div class=""sourceCode""><pre class=""sourceCode r""><code class=""sourceCode r""><span class=""kw""><a href=""reference/read_excel.html"">read_excel</a></span>(xlsx_example, <span class=""dt"">na =</span> <span class=""st"">""setosa""</span>)
 <span class=""co"">#&gt; # A tibble: 150 × 5</span>
@@ -138,11 +168,11 @@ <h2 class=""hasAnchor"">
 </div>
 <div id=""features"" class=""section level2"">
 <h2 class=""hasAnchor"">
-<a href=""#features"" class=""anchor""> </a>Features</h2>
+<a href=""#features"" class=""anchor""></a>Features</h2>
 <ul>
 <li><p>Re-encodes non-ASCII characters to UTF-8.</p></li>
 <li><p>Loads datetimes into POSIXct columns. Both Windows (1900) and Mac (1904) date specifications are processed correctly.</p></li>
-<li><p>Blank rows that appear before the data are automatically dropped; embedded blank rows are not. User can exert more control of this with <code>skip</code>.</p></li>
+<li><p>Blank rows that appear before the data are automatically dropped; embedded blank rows are not. User can exert more control with <code>range</code>, <code>skip</code>, and <code>n_max</code>.</p></li>
 <li><p>Column names and types are determined from the data in the sheet, by default, but user can also supply via <code>col_names</code> and <code>col_types</code>.</p></li>
 <li><p>It returns a tibble, i.e. a data frame with an additional <code>tbl_df</code> class. Among other things, this provide nicer printing.</p></li>
 </ul>
@@ -176,15 +206,15 @@ <h2>Developers</h2>
 </li>
 <li><a href=""authors.html"">All authors...</a></li>
 </ul>
-<html><body>
+<div>
 <h2>Dev status</h2>
 <ul class=""list-unstyled"">
 <li><a href=""https://travis-ci.org/tidyverse/readxl""><img src=""https://travis-ci.org/tidyverse/readxl.svg?branch=master"" alt=""Travis-CI Build Status""></a></li>
 <li><a href=""https://ci.appveyor.com/project/tidyverse/readxl""><img src=""https://ci.appveyor.com/api/projects/status/github/tidyverse/readxl?branch=master&amp;svg=true"" alt=""AppVeyor Build Status""></a></li>
 <li><a href=""https://codecov.io/github/tidyverse/readxl?branch=master""><img src=""https://img.shields.io/codecov/c/github/tidyverse/readxl/master.svg"" alt=""Coverage Status""></a></li>
 <li><a href=""https://cran.r-project.org/package=readxl""><img src=""https://www.r-pkg.org/badges/version/readxl"" alt=""CRAN_Status_Badge""></a></li>
 </ul>
-</body></html>
+</div>
 </div>
 
 </div>

---FILE: docs/news/index.html---
@@ -81,18 +81,19 @@ <h1>Change log <small>All releases</small></h1>
     <div class=""contents"">
     <div id=""readxl-0-1-1-9000"" class=""section level1"">
 <h1 class=""hasAnchor"">
-<a href=""#readxl-0-1-1-9000"" class=""anchor""> </a>readxl 0.1.1.9000</h1>
+<a href=""#readxl-0-1-1-9000"" class=""anchor""></a>readxl 0.1.1.9000</h1>
 <div id=""sheet-geometry"" class=""section level2"">
 <h2 class=""hasAnchor"">
-<a href=""#sheet-geometry"" class=""anchor""> </a>Sheet geometry</h2>
+<a href=""#sheet-geometry"" class=""anchor""></a>Sheet geometry</h2>
 <ul>
-<li><p><code>n_max</code> is a new argument that limits the number of data rows read from the spreadsheet. Control over whether column names will be read from the sheet remains with <code>col_names</code>. (#306, #281)</p></li>
+<li><p><code>range</code> is a new argument for reading a rectangular range, possibly open. (#314, #8)</p></li>
+<li><p><code>n_max</code> is a new argument that limits the number of data rows read. (#306, #281)</p></li>
 <li>
-<p>Empty cells, rows, columns (xlsx #248 and #240, xls #271): Cells with no content are no longer loaded, even if they appear in the file. Affects cells that have no data but that carry explicit formatting, detectable in Excel as seemingly empty cells with a format other than “General”. Such cells will still exist in the returned tibble, with value <code>NA</code>, if there are other non-empty cells in the row or column.</p>
+<p>Empty cells, rows, columns (xlsx #248 and #240, xls #271): Cells with no content are no longer loaded, even if they appear in the file. Affects cells that have no data but that carry explicit formatting, detectable in Excel as seemingly empty cells with a format other than “General”. Such cells may still exist in the returned tibble, with value <code>NA</code>, depending on the sheet geometry.</p>
 <ul>
 <li>Eliminates a source of trailing rows (#203) and columns (#236, #162, #146) consisting entirely of <code>NA</code>.</li>
 <li>Eliminates a subtle source of disagreement between user-provided column names and guessed column types (#169, #81).</li>
-<li>Leading or embedded empty columns are no longer automatically dropped, regardless of whether there is a column name. (#157, #261)</li>
+<li>Embedded empty columns are no longer automatically dropped, regardless of whether there is a column name. (#157, #261)</li>
 <li>Worksheets that are completely empty or that contain only column names no longer error, but return a tibble with zero rows. (#222, #144, #65)</li>
 <li>Improved handling of leading and embedded blank rows and explicit row skipping. (#224, #194, #178, #156, #101)</li>
 </ul>
@@ -102,7 +103,7 @@ <h2 class=""hasAnchor"">
 </div>
 <div id=""column-types-and-coercion"" class=""section level2"">
 <h2 class=""hasAnchor"">
-<a href=""#column-types-and-coercion"" class=""anchor""> </a>Column types and coercion</h2>
+<a href=""#column-types-and-coercion"" class=""anchor""></a>Column types and coercion</h2>
 <ul>
 <li><p><code>""list""</code> is a new accepted value for <code>col_types</code>. Loads data as a list of length-1 vectors, that are typed using the logic from <code>col_types = NULL</code>, but on a cell-by-cell basis (#262 @gergness).</p></li>
 <li><p><code>""logical""</code> is a new accepted value for <code>col_types</code>. When <code>col_types = NULL</code>, it is the guessed type for cells Excel advertises as Boolean. When a column has no data, it is now filled with logical <code>NA</code>. (#277, #270)</p></li>
@@ -123,7 +124,7 @@ <h2 class=""hasAnchor"">
 </div>
 <div id=""compatibility"" class=""section level2"">
 <h2 class=""hasAnchor"">
-<a href=""#compatibility"" class=""anchor""> </a>Compatibility</h2>
+<a href=""#compatibility"" class=""anchor""></a>Compatibility</h2>
 <p>Many 3rd party tools write xls and xlsx that comply with the spec, but that are quite different from files produced by Excel.</p>
 <ul>
 <li><p>Namespace prefixes are now stripped from element names and attributes when parsing XML from xlsx. Workaround for the creative approach taken in some other s/w, coupled with rapidxml’s lack of namespace support. (#295, #268, #202, #80)</p></li>
@@ -135,7 +136,7 @@ <h2 class=""hasAnchor"">
 </div>
 <div id=""other"" class=""section level2"">
 <h2 class=""hasAnchor"">
-<a href=""#other"" class=""anchor""> </a>Other</h2>
+<a href=""#other"" class=""anchor""></a>Other</h2>
 <ul>
 <li><p><code><a href=""../reference/read_excel.html"">read_xls()</a></code> and <code><a href=""../reference/read_excel.html"">read_xlsx()</a></code> are now exposed, such that files without an <code>.xls</code> or <code>.xlsx</code> extension can be read. (#85, @jirkalewandowski)</p></li>
 <li><p>The <a href=""https://support.microsoft.com/en-us/help/214326/excel-incorrectly-assumes-that-the-year-1900-is-a-leap-year"">Lotus 1-2-3 leap year bug</a> is now accounted for, i.e. date-times prior to March 1, 1900 import correctly. Date-times on the non-existent leap day February 29, 1900 import as NA and throw a warning. (#264, #148, #292)</p></li>
@@ -148,7 +149,7 @@ <h2 class=""hasAnchor"">
 </div>
     <div id=""readxl-0-1-1"" class=""section level1"">
 <h1 class=""hasAnchor"">
-<a href=""#readxl-0-1-1"" class=""anchor""> </a>readxl 0.1.1</h1>
+<a href=""#readxl-0-1-1"" class=""anchor""></a>readxl 0.1.1</h1>
 <ul>
 <li>Add support for correctly reading strings in .xlsx files containing escaped unicode characters (e.g. <code>_x005F_</code>). (#51, @jmarshallnz)</li>
 </ul>

---FILE: docs/reference/cell-specification.html---
@@ -0,0 +1,222 @@
+<!-- Generated by pkgdown: do not edit by hand -->
+<!DOCTYPE html>
+<html>
+  <head>
+  <meta charset=""utf-8"">
+<meta http-equiv=""X-UA-Compatible"" content=""IE=edge"">
+<meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
+
+<title>Specify cells for reading — cell-specification • readxl</title>
+
+<!-- jquery -->
+<script src=""https://code.jquery.com/jquery-3.1.0.min.js"" integrity=""sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq"" crossorigin=""anonymous""></script>
+
+<!-- Bootstrap -->
+<link href=""../tidyverse.css"" rel=""stylesheet"">
+<script src=""https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"" integrity=""sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"" crossorigin=""anonymous""></script>
+
+<!-- Font Awesome icons -->
+<link href=""https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css"" rel=""stylesheet"" integrity=""sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1"" crossorigin=""anonymous"">
+
+<!-- tidyverse -->
+<link href=""../pkgdown.css"" rel=""stylesheet"">
+<script src=""../jquery.sticky-kit.min.js""></script>
+<script src=""../pkgdown.js""></script>
+
+<!-- mathjax -->
+<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
+
+<!--[if lt IE 9]>
+<script src=""https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js""></script>
+<script src=""https://oss.maxcdn.com/respond/1.4.2/respond.min.js""></script>
+<![endif]-->
+  </head>
+
+  <body>
+    <div class=""container template-reference-topic"">
+      <header>
+      <div class=""navbar navbar-default navbar-fixed-top"" role=""navigation"">
+  <div class=""container"">
+    <div class=""navbar-header"">
+      <button type=""button"" class=""navbar-toggle collapsed"" data-toggle=""collapse"" data-target=""#navbar"">
+        <span class=""icon-bar""></span>
+        <span class=""icon-bar""></span>
+        <span class=""icon-bar""></span>
+      </button>
+
+      <div class=""navbar-brand-container"">
+        <a class=""navbar-brand"" href=""../index.html"">readxl</a>
+        <small class=""tidyverse"">part of the <a href=""http://tidyverse.org"">tidyverse</a></small>
+      </div>
+    </div>
+    <div id=""navbar"" class=""navbar-collapse collapse"">
+      <ul class=""nav navbar-nav navbar-right"">
+        <li>
+  <a href=""../reference/index.html"">Reference</a>
+</li>
+<li>
+  <a href=""../news/index.html"">News</a>
+</li>
+        <li>
+  <a href=""https://github.com/tidyverse/readxl"">
+    <span class=""fa fa-github fa-lg""></span>
+     
+  </a>
+</li>
+      </ul>
+    </div><!--/.nav-collapse -->
+  </div><!--/.container -->
+</div><!--/.navbar -->
+
+      
+      </header>
+
+      <div class=""row"">
+  <div class=""col-md-9 contents"">
+    <div class=""page-header"">
+    <h1>Specify cells for reading</h1>
+    </div>
+
+    
+    <p>The <code>range</code> argument of <code><a href='read_excel.html'>read_excel()</a></code> provides many ways to limit the read
+to a specific rectangle of cells. The simplest usage is to provide an
+Excel-like cell range, such as <code>range = ""D12:F15""</code> or <code>range = ""R1C12:R6C15""</code>. The cell rectangle can be specified in various other ways,
+using helper functions. In all cases, cell range processing is handled by the
+cellranger package, where you can find full documentation for
+the functions used in the examples below.</p>
+    
+
+        
+    <h2 class=""hasAnchor"" id=""see-also""><a class=""anchor"" href=""#see-also""></a>See also</h2>
+
+    <p>The cellranger package has full documentation on cell
+specification and offers additional functions for manipulating ""A1:D10""
+style spreadsheet ranges. Here are the most relevant:</p><ul>
+<li><p><code><a href='http://www.rdocumentation.org/packages/cellranger/topics/cell_limits'>cellranger::cell_limits()</a></code></p></li>
+<li><p><code><a href='http://www.rdocumentation.org/packages/cellranger/topics/cell_rows'>cellranger::cell_rows()</a></code></p></li>
+<li><p><code><a href='http://www.rdocumentation.org/packages/cellranger/topics/cell_cols'>cellranger::cell_cols()</a></code></p></li>
+<li><p><code><a href='http://www.rdocumentation.org/packages/cellranger/topics/anchored'>cellranger::anchored()</a></code></p></li>
+</ul>
+    
+
+    <h2 class=""hasAnchor"" id=""examples""><a class=""anchor"" href=""#examples""></a>Examples</h2>
+    <pre class=""examples""><div class='input'><span class='no'>path</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='readxl_example.html'>readxl_example</a></span>(<span class='st'>""geometry.xls""</span>)
+<span class='co'>## Rows 1 and 2 are empty (as are rows 7 and higher)</span>
+<span class='co'>## Column 1 aka ""A"" is empty (as are columns 5 of ""E"" and higher)</span>
+
+<span class='co'># By default, the populated data cells are ""shrink-wrapped"" into a</span>
+<span class='co'># minimal data frame</span>
+<span class='fu'><a href='read_excel.html'>read_excel</a></span>(<span class='no'>path</span>)</div><div class='output co'>#&gt; # A tibble: 3 × 3
+#&gt;      B3    C3    D3
+#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
+#&gt; 1    B4    C4    D4
+#&gt; 2    B5    C5    D5
+#&gt; 3    B6    C6    D6</div><div class='input'>
+<span class='co'># Specific rectangle that is subset of populated cells, possibly improper</span>
+<span class='fu'><a href='read_excel.html'>read_excel</a></span>(<span class='no'>path</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='st'>""B3:D6""</span>)</div><div class='output co'>#&gt; # A tibble: 3 × 3
+#&gt;      B3    C3    D3
+#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
+#&gt; 1    B4    C4    D4
+#&gt; 2    B5    C5    D5
+#&gt; 3    B6    C6    D6</div><div class='input'><span class='fu'><a href='read_excel.html'>read_excel</a></span>(<span class='no'>path</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='st'>""C3:D5""</span>)</div><div class='output co'>#&gt; # A tibble: 2 × 2
+#&gt;      C3    D3
+#&gt;   &lt;chr&gt; &lt;chr&gt;
+#&gt; 1    C4    D4
+#&gt; 2    C5    D5</div><div class='input'>
+<span class='co'># Specific rectangle that forces inclusion of unpopulated cells</span>
+<span class='fu'><a href='read_excel.html'>read_excel</a></span>(<span class='no'>path</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='st'>""A3:D5""</span>)</div><div class='output co'>#&gt; # A tibble: 2 × 4
+#&gt;    X__1    B3    C3    D3
+#&gt;   &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
+#&gt; 1    NA    B4    C4    D4
+#&gt; 2    NA    B5    C5    D5</div><div class='input'><span class='fu'><a href='read_excel.html'>read_excel</a></span>(<span class='no'>path</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='st'>""A4:E5""</span>)</div><div class='output co'>#&gt; # A tibble: 1 × 5
+#&gt;    X__1    B4    C4    D4  X__2
+#&gt;   &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt;
+#&gt; 1    NA    B5    C5    D5    NA</div><div class='input'><span class='fu'><a href='read_excel.html'>read_excel</a></span>(<span class='no'>path</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='st'>""C5:E7""</span>)</div><div class='output co'>#&gt; # A tibble: 2 × 3
+#&gt;      C5    D5  X__1
+#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt;
+#&gt; 1    C6    D6    NA
+#&gt; 2  &lt;NA&gt;  &lt;NA&gt;    NA</div><div class='input'>
+<span class='co'># Anchor a rectangle of specified size at a particular cell</span>
+<span class='fu'><a href='read_excel.html'>read_excel</a></span>(<span class='no'>path</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='fu'>anchored</span>(<span class='st'>""C4""</span>, <span class='kw'>dim</span> <span class='kw'>=</span> <span class='fu'>c</span>(<span class='fl'>3</span>, <span class='fl'>2</span>)), <span class='kw'>col_names</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>)</div><div class='output co'>#&gt; # A tibble: 3 × 2
+#&gt;    X__1  X__2
+#&gt;   &lt;chr&gt; &lt;chr&gt;
+#&gt; 1    C4    D4
+#&gt; 2    C5    D5
+#&gt; 3    C6    D6</div><div class='input'>
+<span class='co'># Specify only the rows or only the columns</span>
+<span class='fu'><a href='read_excel.html'>read_excel</a></span>(<span class='no'>path</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='fu'>cell_rows</span>(<span class='fl'>3</span>:<span class='fl'>6</span>))</div><div class='output co'>#&gt; # A tibble: 3 × 3
+#&gt;      B3    C3    D3
+#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
+#&gt; 1    B4    C4    D4
+#&gt; 2    B5    C5    D5
+#&gt; 3    B6    C6    D6</div><div class='input'><span class='fu'><a href='read_excel.html'>read_excel</a></span>(<span class='no'>path</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='fu'>cell_cols</span>(<span class='st'>""C:D""</span>))</div><div class='output co'>#&gt; # A tibble: 3 × 2
+#&gt;      C3    D3
+#&gt;   &lt;chr&gt; &lt;chr&gt;
+#&gt; 1    C4    D4
+#&gt; 2    C5    D5
+#&gt; 3    C6    D6</div><div class='input'><span class='fu'><a href='read_excel.html'>read_excel</a></span>(<span class='no'>path</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='fu'>cell_cols</span>(<span class='fl'>2</span>))</div><div class='output co'>#&gt; # A tibble: 3 × 1
+#&gt;      B3
+#&gt;   &lt;chr&gt;
+#&gt; 1    B4
+#&gt; 2    B5
+#&gt; 3    B6</div><div class='input'>
+<span class='co'># Specify exactly one row or column bound</span>
+<span class='fu'><a href='read_excel.html'>read_excel</a></span>(<span class='no'>path</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='fu'>cell_rows</span>(<span class='fu'>c</span>(<span class='fl'>5</span>, <span class='fl'>NA</span>)))</div><div class='output co'>#&gt; # A tibble: 1 × 3
+#&gt;      B5    C5    D5
+#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
+#&gt; 1    B6    C6    D6</div><div class='input'><span class='fu'><a href='read_excel.html'>read_excel</a></span>(<span class='no'>path</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='fu'>cell_rows</span>(<span class='fu'>c</span>(<span class='fl'>NA</span>, <span class='fl'>4</span>)))</div><div class='output co'>#&gt; # A tibble: 3 × 3
+#&gt;    X__1  X__2  X__3
+#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
+#&gt; 1  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;
+#&gt; 2    B3    C3    D3
+#&gt; 3    B4    C4    D4</div><div class='input'><span class='fu'><a href='read_excel.html'>read_excel</a></span>(<span class='no'>path</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='fu'>cell_cols</span>(<span class='fu'>c</span>(<span class='st'>""C""</span>, <span class='fl'>NA</span>)))</div><div class='output co'>#&gt; # A tibble: 3 × 2
+#&gt;      C3    D3
+#&gt;   &lt;chr&gt; &lt;chr&gt;
+#&gt; 1    C4    D4
+#&gt; 2    C5    D5
+#&gt; 3    C6    D6</div><div class='input'><span class='fu'><a href='read_excel.html'>read_excel</a></span>(<span class='no'>path</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='fu'>cell_cols</span>(<span class='fu'>c</span>(<span class='fl'>NA</span>, <span class='fl'>2</span>)))</div><div class='output co'>#&gt; # A tibble: 3 × 2
+#&gt;    X__1    B3
+#&gt;   &lt;lgl&gt; &lt;chr&gt;
+#&gt; 1    NA    B4
+#&gt; 2    NA    B5
+#&gt; 3    NA    B6</div><div class='input'>
+<span class='co'># General open rectangles</span>
+<span class='co'># upper left = C4, everything else unspecified</span>
+<span class='fu'><a href='read_excel.html'>read_excel</a></span>(<span class='no'>path</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='fu'>cell_limits</span>(<span class='fu'>c</span>(<span class='fl'>4</span>, <span class='fl'>3</span>), <span class='fu'>c</span>(<span class='fl'>NA</span>, <span class='fl'>NA</span>)))</div><div class='output co'>#&gt; # A tibble: 2 × 2
+#&gt;      C4    D4
+#&gt;   &lt;chr&gt; &lt;chr&gt;
+#&gt; 1    C5    D5
+#&gt; 2    C6    D6</div><div class='input'><span class='co'># upper right = D4, everything else unspecified</span>
+<span class='fu'><a href='read_excel.html'>read_excel</a></span>(<span class='no'>path</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='fu'>cell_limits</span>(<span class='fu'>c</span>(<span class='fl'>4</span>, <span class='fl'>NA</span>), <span class='fu'>c</span>(<span class='fl'>NA</span>, <span class='fl'>4</span>)))</div><div class='output co'>#&gt; # A tibble: 2 × 4
+#&gt;    X__1    B4    C4    D4
+#&gt;   &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
+#&gt; 1    NA    B5    C5    D5
+#&gt; 2    NA    B6    C6    D6</div><div class='input'>
+</div></pre>
+  </div>
+  <div class=""col-md-3 hidden-xs hidden-sm"" id=""sidebar"">
+    <h2>Contents</h2>
+    <ul class=""nav nav-pills nav-stacked"">
+      
+      <li><a href=""#see-also"">See also</a></li>
+      
+      <li><a href=""#examples"">Examples</a></li>
+    </ul>
+
+  </div>
+</div>
+
+      <footer>
+      <div class=""tidyverse"">
+  <p>readxl is a part of the <strong>tidyverse</strong>, an ecosystem of packages designed with common APIs and a shared philosophy. Learn more at <a href=""http://tidyverse.org"">tidyverse.org</a>.</p>
+</div>
+
+<div class=""author"">
+  <p>Developed by <a href='http://hadley.nz'>Hadley Wickham</a>, Jennifer Bryan, <a href='https://www.rstudio.com'><img src='http://tidyverse.org/rstudio-logo.svg' height='24' /></a>.</p>
+  <p>Site built by <a href=""http://hadley.github.io/pkgdown/"">pkgdown</a>.</p>
+</div>
+      </footer>
+   </div>
+
+  </body>
+</html>

---FILE: docs/reference/excel_sheets.html---
@@ -84,10 +84,13 @@ <h1>List all sheets in an excel spreadsheet.</h1>
     <pre><span class='fu'>excel_sheets</span>(<span class='no'>path</span>)</pre>
     
     <h2 class=""hasAnchor"" id=""arguments""><a class=""anchor"" href=""#arguments""></a> Arguments</h2>
-    <dl class=""dl-horizontal"">
-      <dt>path</dt>
-      <dd><p>Path to the xls/xlsx file</p></dd>
-    </dl>
+    <table class=""ref-arguments"">
+    <colgroup><col class=""name"" /><col class=""desc"" /></colgroup>
+    <tr>
+      <th>path</th>
+      <td><p>Path to the xls/xlsx file</p></td>
+    </tr>
+    </table>
     
 
     <h2 class=""hasAnchor"" id=""examples""><a class=""anchor"" href=""#examples""></a>Examples</h2>
@@ -96,39 +99,67 @@ <h2 class=""hasAnchor"" id=""examples""><a class=""anchor"" href=""#examples""></a>Examp
 <span class='no'>path</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='readxl_example.html'>readxl_example</a></span>(<span class='st'>""datasets.xls""</span>)
 <span class='fu'>lapply</span>(<span class='fu'>excel_sheets</span>(<span class='no'>path</span>), <span class='no'>read_excel</span>, <span class='kw'>path</span> <span class='kw'>=</span> <span class='no'>path</span>)</div><div class='output co'>#&gt; [[1]]
 #&gt; # A tibble: 150 × 5
-#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
-#&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;
-#&gt; 1          5.1         3.5          1.4         0.2  setosa
-#&gt; 2          4.9         3.0          1.4         0.2  setosa
-#&gt; 3          4.7         3.2          1.3         0.2  setosa
-#&gt; # ... with 147 more rows
+#&gt;    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
+#&gt;           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;
+#&gt; 1           5.1         3.5          1.4         0.2  setosa
+#&gt; 2           4.9         3.0          1.4         0.2  setosa
+#&gt; 3           4.7         3.2          1.3         0.2  setosa
+#&gt; 4           4.6         3.1          1.5         0.2  setosa
+#&gt; 5           5.0         3.6          1.4         0.2  setosa
+#&gt; 6           5.4         3.9          1.7         0.4  setosa
+#&gt; 7           4.6         3.4          1.4         0.3  setosa
+#&gt; 8           5.0         3.4          1.5         0.2  setosa
+#&gt; 9           4.4         2.9          1.4         0.2  setosa
+#&gt; 10          4.9         3.1          1.5         0.1  setosa
+#&gt; # ... with 140 more rows
 #&gt; 
 #&gt; [[2]]
 #&gt; # A tibble: 32 × 11
-#&gt;     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
-#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
-#&gt; 1  21.0     6   160   110  3.90 2.620 16.46     0     1     4     4
-#&gt; 2  21.0     6   160   110  3.90 2.875 17.02     0     1     4     4
-#&gt; 3  22.8     4   108    93  3.85 2.320 18.61     1     1     4     1
-#&gt; # ... with 29 more rows
+#&gt;      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
+#&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
+#&gt; 1   21.0     6 160.0   110  3.90 2.620 16.46     0     1     4     4
+#&gt; 2   21.0     6 160.0   110  3.90 2.875 17.02     0     1     4     4
+#&gt; 3   22.8     4 108.0    93  3.85 2.320 18.61     1     1     4     1
+#&gt; 4   21.4     6 258.0   110  3.08 3.215 19.44     1     0     3     1
+#&gt; 5   18.7     8 360.0   175  3.15 3.440 17.02     0     0     3     2
+#&gt; 6   18.1     6 225.0   105  2.76 3.460 20.22     1     0     3     1
+#&gt; 7   14.3     8 360.0   245  3.21 3.570 15.84     0     0     3     4
+#&gt; 8   24.4     4 146.7    62  3.69 3.190 20.00     1     0     4     2
+#&gt; 9   22.8     4 140.8    95  3.92 3.150 22.90     1     0     4     2
+#&gt; 10  19.2     6 167.6   123  3.92 3.440 18.30     1     0     4     4
+#&gt; # ... with 22 more rows
 #&gt; 
 #&gt; [[3]]
 #&gt; # A tibble: 71 × 2
-#&gt;   weight      feed
-#&gt;    &lt;dbl&gt;     &lt;chr&gt;
-#&gt; 1    179 horsebean
-#&gt; 2    160 horsebean
-#&gt; 3    136 horsebean
-#&gt; # ... with 68 more rows
+#&gt;    weight      feed
+#&gt;     &lt;dbl&gt;     &lt;chr&gt;
+#&gt; 1     179 horsebean
+#&gt; 2     160 horsebean
+#&gt; 3     136 horsebean
+#&gt; 4     227 horsebean
+#&gt; 5     217 horsebean
+#&gt; 6     168 horsebean
+#&gt; 7     108 horsebean
+#&gt; 8     124 horsebean
+#&gt; 9     143 horsebean
+#&gt; 10    140 horsebean
+#&gt; # ... with 61 more rows
 #&gt; 
 #&gt; [[4]]
 #&gt; # A tibble: 1,000 × 5
-#&gt;      lat   long depth   mag stations
-#&gt;    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;
-#&gt; 1 -20.42 181.62   562   4.8       41
-#&gt; 2 -20.62 181.03   650   4.2       15
-#&gt; 3 -26.00 184.10    42   5.4       43
-#&gt; # ... with 997 more rows
+#&gt;       lat   long depth   mag stations
+#&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;
+#&gt; 1  -20.42 181.62   562   4.8       41
+#&gt; 2  -20.62 181.03   650   4.2       15
+#&gt; 3  -26.00 184.10    42   5.4       43
+#&gt; 4  -17.97 181.66   626   4.1       19
+#&gt; 5  -20.42 181.96   649   4.0       11
+#&gt; 6  -19.68 184.31   195   4.0       12
+#&gt; 7  -11.70 166.10    82   4.8       43
+#&gt; 8  -28.11 181.93   194   4.4       15
+#&gt; 9  -28.74 181.74   211   4.7       35
+#&gt; 10 -17.47 179.59   622   4.3       19
+#&gt; # ... with 990 more rows
 #&gt; </div></pre>
   </div>
   <div class=""col-md-3 hidden-xs hidden-sm"" id=""sidebar"">

---FILE: docs/reference/index.html---
@@ -79,32 +79,81 @@ <h4>version&nbsp;0.1.1.9000</h4>
     </div>
 
     <div class=""contents"">
-      <h2 id=""section-all-functions"" class=""hasAnchor""><a href=""#section-all-functions"" class=""anchor""></a>All functions</h2>
-      <p class=""section-desc""></p>
-
-      
-      <p><a href=""excel_sheets.html"">List all sheets in an excel spreadsheet.</a></p>
-      <ul>
-        <li><code><a href=""excel_sheets.html"">excel_sheets</a></code></li>
-      </ul>
-      
-      <p><a href=""read_excel.html"">Read xls and xlsx files.</a></p>
-      <ul>
-        <li><code><a href=""read_excel.html"">read_excel</a></code></li><li><code><a href=""read_excel.html"">read_xls</a></code></li><li><code><a href=""read_excel.html"">read_xlsx</a></code></li>
-      </ul>
-      
-      <p><a href=""readxl_example.html"">Get path to readxl example</a></p>
-      <ul>
-        <li><code><a href=""readxl_example.html"">readxl_example</a></code></li>
-      </ul>
-    
+      <table class=""ref-index"">
+
+      <colgroup>
+        <col class=""alias"" />
+        <col class=""title"" />
+      </colgroup>
+
+      <tbody>
+        <tr>
+          <th colspan=""2"">
+            <h2 id=""section-read-spreadsheets"" class=""hasAnchor""><a href=""#section-read-spreadsheets"" class=""anchor""></a>Read spreadsheets</h2>
+            <p class=""section-desc""><p>Functions for reading tabular data out of xls and xlsx files.</p></p>
+          </th>
+        </tr>
+        <tr>
+          <!--  -->
+          <td>
+            <p><code><a href=""read_excel.html"">read_excel</a></code> <code><a href=""read_excel.html"">read_xls</a></code> <code><a href=""read_excel.html"">read_xlsx</a></code> </p>
+          </td>
+          <td><p>Read xls and xlsx files.</p></td>
+        </tr>
+      </tbody><tbody>
+        <tr>
+          <th colspan=""2"">
+            <h2 id=""section-get-spreadsheet-metadata"" class=""hasAnchor""><a href=""#section-get-spreadsheet-metadata"" class=""anchor""></a>Get spreadsheet metadata</h2>
+            <p class=""section-desc""><p>Functions to learn properties of xls and xlsx files.</p></p>
+          </th>
+        </tr>
+        <tr>
+          <!--  -->
+          <td>
+            <p><code><a href=""excel_sheets.html"">excel_sheets</a></code> </p>
+          </td>
+          <td><p>List all sheets in an excel spreadsheet.</p></td>
+        </tr>
+      </tbody><tbody>
+        <tr>
+          <th colspan=""2"">
+            <h2 id=""section-describe-a-target-rectangle"" class=""hasAnchor""><a href=""#section-describe-a-target-rectangle"" class=""anchor""></a>Describe a target rectangle</h2>
+            <p class=""section-desc""><p>Flexible specification of cell rectangles.</p></p>
+          </th>
+        </tr>
+        <tr>
+          <!--  -->
+          <td>
+            <p><code><a href=""cell-specification.html"">cell-specification</a></code> <code><a href=""cell-specification.html"">cell_limits</a></code> <code><a href=""cell-specification.html"">cell_rows</a></code> <code><a href=""cell-specification.html"">cell_cols</a></code> <code><a href=""cell-specification.html"">anchored</a></code> </p>
+          </td>
+          <td><p>Specify cells for reading</p></td>
+        </tr>
+      </tbody><tbody>
+        <tr>
+          <th colspan=""2"">
+            <h2 id=""section-example-files"" class=""hasAnchor""><a href=""#section-example-files"" class=""anchor""></a>Example files</h2>
+            <p class=""section-desc""><p>List or get the path to xls and xlsx example files in the package.</p></p>
+          </th>
+        </tr>
+        <tr>
+          <!--  -->
+          <td>
+            <p><code><a href=""readxl_example.html"">readxl_example</a></code> </p>
+          </td>
+          <td><p>Get path to readxl example</p></td>
+        </tr>
+      </tbody>
+      </table>
     </div>
   </div>
 
   <div class=""col-md-3 hidden-xs hidden-sm"" id=""sidebar"">
     <h2>Contents</h2>
     <ul class=""nav nav-pills nav-stacked"">
-      <li><a href=""#section-all-functions"">All functions</a></li>
+      <li><a href=""#section-read-spreadsheets"">Read spreadsheets</a></li>
+      <li><a href=""#section-get-spreadsheet-metadata"">Get spreadsheet metadata</a></li>
+      <li><a href=""#section-describe-a-target-rectangle"">Describe a target rectangle</a></li>
+      <li><a href=""#section-example-files"">Example files</a></li>
     </ul>
   </div>
 </div>

---FILE: docs/reference/read_excel.html---
@@ -84,106 +84,180 @@ <h1>Read xls and xlsx files.</h1>
 read files without extension.</p>
     
 
-    <pre><span class='fu'>read_excel</span>(<span class='no'>path</span>, <span class='kw'>sheet</span> <span class='kw'>=</span> <span class='fl'>1L</span>, <span class='kw'>col_names</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>, <span class='kw'>col_types</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
-  <span class='kw'>na</span> <span class='kw'>=</span> <span class='st'>""""</span>, <span class='kw'>skip</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>n_max</span> <span class='kw'>=</span> <span class='fl'>Inf</span>, <span class='kw'>guess_max</span> <span class='kw'>=</span> <span class='fu'>min</span>(<span class='fl'>1000</span>, <span class='no'>n_max</span>))
+    <pre><span class='fu'>read_excel</span>(<span class='no'>path</span>, <span class='kw'>sheet</span> <span class='kw'>=</span> <span class='fl'>1L</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>col_names</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>,
+  <span class='kw'>col_types</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>na</span> <span class='kw'>=</span> <span class='st'>""""</span>, <span class='kw'>skip</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>n_max</span> <span class='kw'>=</span> <span class='fl'>Inf</span>,
+  <span class='kw'>guess_max</span> <span class='kw'>=</span> <span class='fu'>min</span>(<span class='fl'>1000</span>, <span class='no'>n_max</span>))
 
-<span class='fu'>read_xls</span>(<span class='no'>path</span>, <span class='kw'>sheet</span> <span class='kw'>=</span> <span class='fl'>1L</span>, <span class='kw'>col_names</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>, <span class='kw'>col_types</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>na</span> <span class='kw'>=</span> <span class='st'>""""</span>,
-  <span class='kw'>skip</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>n_max</span> <span class='kw'>=</span> <span class='fl'>Inf</span>, <span class='kw'>guess_max</span> <span class='kw'>=</span> <span class='fu'>min</span>(<span class='fl'>1000</span>, <span class='no'>n_max</span>))
+<span class='fu'>read_xls</span>(<span class='no'>path</span>, <span class='kw'>sheet</span> <span class='kw'>=</span> <span class='fl'>1L</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>col_names</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>,
+  <span class='kw'>col_types</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>na</span> <span class='kw'>=</span> <span class='st'>""""</span>, <span class='kw'>skip</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>n_max</span> <span class='kw'>=</span> <span class='fl'>Inf</span>,
+  <span class='kw'>guess_max</span> <span class='kw'>=</span> <span class='fu'>min</span>(<span class='fl'>1000</span>, <span class='no'>n_max</span>))
 
-<span class='fu'>read_xlsx</span>(<span class='no'>path</span>, <span class='kw'>sheet</span> <span class='kw'>=</span> <span class='fl'>1L</span>, <span class='kw'>col_names</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>, <span class='kw'>col_types</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>na</span> <span class='kw'>=</span> <span class='st'>""""</span>,
-  <span class='kw'>skip</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>n_max</span> <span class='kw'>=</span> <span class='fl'>Inf</span>, <span class='kw'>guess_max</span> <span class='kw'>=</span> <span class='fu'>min</span>(<span class='fl'>1000</span>, <span class='no'>n_max</span>))</pre>
+<span class='fu'>read_xlsx</span>(<span class='no'>path</span>, <span class='kw'>sheet</span> <span class='kw'>=</span> <span class='fl'>1L</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>col_names</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>,
+  <span class='kw'>col_types</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>na</span> <span class='kw'>=</span> <span class='st'>""""</span>, <span class='kw'>skip</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>n_max</span> <span class='kw'>=</span> <span class='fl'>Inf</span>,
+  <span class='kw'>guess_max</span> <span class='kw'>=</span> <span class='fu'>min</span>(<span class='fl'>1000</span>, <span class='no'>n_max</span>))</pre>
     
     <h2 class=""hasAnchor"" id=""arguments""><a class=""anchor"" href=""#arguments""></a> Arguments</h2>
-    <dl class=""dl-horizontal"">
-      <dt>path</dt>
-      <dd><p>Path to the xls/xlsx file</p></dd>
-      <dt>sheet</dt>
-      <dd><p>Sheet to read. Either a string (the name of a sheet), or an
-integer (the position of the sheet). Defaults to the first sheet.</p></dd>
-      <dt>col_names</dt>
-      <dd><p><code>TRUE</code> to use the first row as column names, <code>FALSE</code> to get
+    <table class=""ref-arguments"">
+    <colgroup><col class=""name"" /><col class=""desc"" /></colgroup>
+    <tr>
+      <th>path</th>
+      <td><p>Path to the xls/xlsx file</p></td>
+    </tr>
+    <tr>
+      <th>sheet</th>
+      <td><p>Sheet to read. Either a string (the name of a sheet), or an
+integer (the position of the sheet). Defaults to the first sheet.</p></td>
+    </tr>
+    <tr>
+      <th>range</th>
+      <td><p>A cell range to read from, as described in <a href='cell-specification.html'>cell-specification</a>.
+Includes typical Excel ranges like ""B3:D87"" and more. Interpreted strictly,
+even if the range includes leading or trailing empty rows or columns. Takes
+precedence over <code>skip</code> and <code>n_max</code>.</p></td>
+    </tr>
+    <tr>
+      <th>col_names</th>
+      <td><p><code>TRUE</code> to use the first row as column names, <code>FALSE</code> to get
 default names, or a character vector giving a name for each column. If user
 provides <code>col_types</code> as a vector, <code>col_names</code> can have one entry per
 column, i.e. have the same length as <code>col_types</code>, or one entry per
-unskipped column.</p></dd>
-      <dt>col_types</dt>
-      <dd><p>Either <code>NULL</code> to guess all from the spreadsheet or a
+unskipped column.</p></td>
+    </tr>
+    <tr>
+      <th>col_types</th>
+      <td><p>Either <code>NULL</code> to guess all from the spreadsheet or a
 character vector containing one entry per column from these options:
 ""skip"", ""guess"", ""logical"", ""numeric"", ""date"", ""text"" or ""list"". If exactly
-on <code>col_type</code> is specified, it will be recycled. The content of a cell in a
-skipped column is never read and that column will not appear in the data
+one <code>col_type</code> is specified, it will be recycled. The content of a cell in
+a skipped column is never read and that column will not appear in the data
 frame output. A list cell loads a column as a list of length 1 vectors,
 which are typed using the type guessing logic from <code>col_types = NULL</code>, but
-on a cell-by-cell basis.</p></dd>
-      <dt>na</dt>
-      <dd><p>Character vector of strings to use for missing values. By default,
-readxl treats blank cells as missing data.</p></dd>
-      <dt>skip</dt>
-      <dd><p>Number of rows to skip before reading anything (column names or
-data). Leading blank rows are automatically skipped.</p></dd>
-      <dt>n_max</dt>
-      <dd><p>Maximum number of data rows to read.</p></dd>
-      <dt>guess_max</dt>
-      <dd><p>Maximum number of data rows to use for guessing column
-types.</p></dd>
-    </dl>
+on a cell-by-cell basis.</p></td>
+    </tr>
+    <tr>
+      <th>na</th>
+      <td><p>Character vector of strings to use for missing values. By default,
+readxl treats blank cells as missing data.</p></td>
+    </tr>
+    <tr>
+      <th>skip</th>
+      <td><p>Minimum number of rows to skip before reading anything, be it
+column names or data. Leading empty rows are automatically skipped, so this
+is a lower bound. Ignored if <code>range</code> is given.</p></td>
+    </tr>
+    <tr>
+      <th>n_max</th>
+      <td><p>Maximum number of data rows to read. Trailing empty rows are
+automatically skipped, so this is an upper bound on the number of rows in
+the returned tibble. Ignored if <code>range</code> is given.</p></td>
+    </tr>
+    <tr>
+      <th>guess_max</th>
+      <td><p>Maximum number of data rows to use for guessing column
+types.</p></td>
+    </tr>
+    </table>
+    
+    <h2 class=""hasAnchor"" id=""value""><a class=""anchor"" href=""#value""></a>Value</h2>
+
+    <p>A <a href='http://www.rdocumentation.org/packages/tibble/topics/tibble-package'>tibble</a></p>
+    
+    <h2 class=""hasAnchor"" id=""see-also""><a class=""anchor"" href=""#see-also""></a>See also</h2>
+
+    <p><a href='cell-specification.html'>cell-specification</a> for more details on targetting cells with the
+<code>range</code> argument</p>
     
 
     <h2 class=""hasAnchor"" id=""examples""><a class=""anchor"" href=""#examples""></a>Examples</h2>
     <pre class=""examples""><div class='input'><span class='no'>datasets</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='readxl_example.html'>readxl_example</a></span>(<span class='st'>""datasets.xlsx""</span>)
 <span class='fu'>read_excel</span>(<span class='no'>datasets</span>)</div><div class='output co'>#&gt; # A tibble: 150 × 5
-#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
-#&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;
-#&gt; 1          5.1         3.5          1.4         0.2  setosa
-#&gt; 2          4.9         3.0          1.4         0.2  setosa
-#&gt; 3          4.7         3.2          1.3         0.2  setosa
-#&gt; # ... with 147 more rows</div><div class='input'>
+#&gt;    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
+#&gt;           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;
+#&gt; 1           5.1         3.5          1.4         0.2  setosa
+#&gt; 2           4.9         3.0          1.4         0.2  setosa
+#&gt; 3           4.7         3.2          1.3         0.2  setosa
+#&gt; 4           4.6         3.1          1.5         0.2  setosa
+#&gt; 5           5.0         3.6          1.4         0.2  setosa
+#&gt; 6           5.4         3.9          1.7         0.4  setosa
+#&gt; 7           4.6         3.4          1.4         0.3  setosa
+#&gt; 8           5.0         3.4          1.5         0.2  setosa
+#&gt; 9           4.4         2.9          1.4         0.2  setosa
+#&gt; 10          4.9         3.1          1.5         0.1  setosa
+#&gt; # ... with 140 more rows</div><div class='input'>
 <span class='co'># Specify sheet either by position or by name</span>
 <span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='fl'>2</span>)</div><div class='output co'>#&gt; # A tibble: 32 × 11
-#&gt;     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
-#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
-#&gt; 1  21.0     6   160   110  3.90 2.620 16.46     0     1     4     4
-#&gt; 2  21.0     6   160   110  3.90 2.875 17.02     0     1     4     4
-#&gt; 3  22.8     4   108    93  3.85 2.320 18.61     1     1     4     1
-#&gt; # ... with 29 more rows</div><div class='input'><span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='st'>""mtcars""</span>)</div><div class='output co'>#&gt; # A tibble: 32 × 11
-#&gt;     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
-#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
-#&gt; 1  21.0     6   160   110  3.90 2.620 16.46     0     1     4     4
-#&gt; 2  21.0     6   160   110  3.90 2.875 17.02     0     1     4     4
-#&gt; 3  22.8     4   108    93  3.85 2.320 18.61     1     1     4     1
-#&gt; # ... with 29 more rows</div><div class='input'>
+#&gt;      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
+#&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
+#&gt; 1   21.0     6 160.0   110  3.90 2.620 16.46     0     1     4     4
+#&gt; 2   21.0     6 160.0   110  3.90 2.875 17.02     0     1     4     4
+#&gt; 3   22.8     4 108.0    93  3.85 2.320 18.61     1     1     4     1
+#&gt; 4   21.4     6 258.0   110  3.08 3.215 19.44     1     0     3     1
+#&gt; 5   18.7     8 360.0   175  3.15 3.440 17.02     0     0     3     2
+#&gt; 6   18.1     6 225.0   105  2.76 3.460 20.22     1     0     3     1
+#&gt; 7   14.3     8 360.0   245  3.21 3.570 15.84     0     0     3     4
+#&gt; 8   24.4     4 146.7    62  3.69 3.190 20.00     1     0     4     2
+#&gt; 9   22.8     4 140.8    95  3.92 3.150 22.90     1     0     4     2
+#&gt; 10  19.2     6 167.6   123  3.92 3.440 18.30     1     0     4     4
+#&gt; # ... with 22 more rows</div><div class='input'><span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='st'>""mtcars""</span>)</div><div class='output co'>#&gt; # A tibble: 32 × 11
+#&gt;      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
+#&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
+#&gt; 1   21.0     6 160.0   110  3.90 2.620 16.46     0     1     4     4
+#&gt; 2   21.0     6 160.0   110  3.90 2.875 17.02     0     1     4     4
+#&gt; 3   22.8     4 108.0    93  3.85 2.320 18.61     1     1     4     1
+#&gt; 4   21.4     6 258.0   110  3.08 3.215 19.44     1     0     3     1
+#&gt; 5   18.7     8 360.0   175  3.15 3.440 17.02     0     0     3     2
+#&gt; 6   18.1     6 225.0   105  2.76 3.460 20.22     1     0     3     1
+#&gt; 7   14.3     8 360.0   245  3.21 3.570 15.84     0     0     3     4
+#&gt; 8   24.4     4 146.7    62  3.69 3.190 20.00     1     0     4     2
+#&gt; 9   22.8     4 140.8    95  3.92 3.150 22.90     1     0     4     2
+#&gt; 10  19.2     6 167.6   123  3.92 3.440 18.30     1     0     4     4
+#&gt; # ... with 22 more rows</div><div class='input'>
 <span class='co'># Skip rows and use default column names</span>
 <span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='kw'>skip</span> <span class='kw'>=</span> <span class='fl'>148</span>, <span class='kw'>col_names</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>)</div><div class='output co'>#&gt; # A tibble: 3 × 5
 #&gt;    X__1  X__2  X__3  X__4      X__5
 #&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;chr&gt;
 #&gt; 1   6.5   3.0   5.2   2.0 virginica
 #&gt; 2   6.2   3.4   5.4   2.3 virginica
 #&gt; 3   5.9   3.0   5.1   1.8 virginica</div><div class='input'>
-<span class='co'># Recycle a length-one col_types</span>
+<span class='co'># Recycle a single column type</span>
 <span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='kw'>col_types</span> <span class='kw'>=</span> <span class='st'>""text""</span>)</div><div class='output co'>#&gt; # A tibble: 150 × 5
-#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
-#&gt;          &lt;chr&gt;       &lt;chr&gt;        &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt;
-#&gt; 1          5.1         3.5          1.4         0.2  setosa
-#&gt; 2          4.9           3          1.4         0.2  setosa
-#&gt; 3          4.7         3.2          1.3         0.2  setosa
-#&gt; # ... with 147 more rows</div><div class='input'>
+#&gt;    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
+#&gt;           &lt;chr&gt;       &lt;chr&gt;        &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt;
+#&gt; 1           5.1         3.5          1.4         0.2  setosa
+#&gt; 2           4.9           3          1.4         0.2  setosa
+#&gt; 3           4.7         3.2          1.3         0.2  setosa
+#&gt; 4           4.6         3.1          1.5         0.2  setosa
+#&gt; 5             5         3.6          1.4         0.2  setosa
+#&gt; 6           5.4         3.9          1.7         0.4  setosa
+#&gt; 7           4.6         3.4          1.4         0.3  setosa
+#&gt; 8             5         3.4          1.5         0.2  setosa
+#&gt; 9           4.4         2.9          1.4         0.2  setosa
+#&gt; 10          4.9         3.1          1.5         0.1  setosa
+#&gt; # ... with 140 more rows</div><div class='input'>
 <span class='co'># Specify some col_types and guess others</span>
 <span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='kw'>col_types</span> <span class='kw'>=</span> <span class='fu'>c</span>(<span class='st'>""text""</span>, <span class='st'>""guess""</span>, <span class='st'>""numeric""</span>, <span class='st'>""guess""</span>, <span class='st'>""guess""</span>))</div><div class='output co'>#&gt; # A tibble: 150 × 5
-#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
-#&gt;          &lt;chr&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;
-#&gt; 1          5.1         3.5          1.4         0.2  setosa
-#&gt; 2          4.9         3.0          1.4         0.2  setosa
-#&gt; 3          4.7         3.2          1.3         0.2  setosa
-#&gt; # ... with 147 more rows</div><div class='input'>
-<span class='co'># ""list"" col_type can handle information of disparate types</span>
+#&gt;    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
+#&gt;           &lt;chr&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;
+#&gt; 1           5.1         3.5          1.4         0.2  setosa
+#&gt; 2           4.9         3.0          1.4         0.2  setosa
+#&gt; 3           4.7         3.2          1.3         0.2  setosa
+#&gt; 4           4.6         3.1          1.5         0.2  setosa
+#&gt; 5             5         3.6          1.4         0.2  setosa
+#&gt; 6           5.4         3.9          1.7         0.4  setosa
+#&gt; 7           4.6         3.4          1.4         0.3  setosa
+#&gt; 8             5         3.4          1.5         0.2  setosa
+#&gt; 9           4.4         2.9          1.4         0.2  setosa
+#&gt; 10          4.9         3.1          1.5         0.1  setosa
+#&gt; # ... with 140 more rows</div><div class='input'>
+<span class='co'># Accomodate a column with disparate types via col_type = ""list""</span>
 <span class='no'>df</span> <span class='kw'>&lt;-</span> <span class='fu'>read_excel</span>(<span class='fu'><a href='readxl_example.html'>readxl_example</a></span>(<span class='st'>""clippy.xlsx""</span>), <span class='kw'>col_types</span> <span class='kw'>=</span> <span class='fu'>c</span>(<span class='st'>""text""</span>, <span class='st'>""list""</span>))
 <span class='no'>df</span></div><div class='output co'>#&gt; # A tibble: 4 × 2
 #&gt;                   name      value
 #&gt;                  &lt;chr&gt;     &lt;list&gt;
 #&gt; 1                 Name  &lt;chr [1]&gt;
 #&gt; 2              Species  &lt;chr [1]&gt;
 #&gt; 3 Approx date of death &lt;dttm [1]&gt;
-#&gt; # ... with 1 more rows</div><div class='input'><span class='no'>df</span>$<span class='no'>value</span></div><div class='output co'>#&gt; [[1]]
+#&gt; 4      Weight in grams  &lt;dbl [1]&gt;</div><div class='input'><span class='no'>df</span>$<span class='no'>value</span></div><div class='output co'>#&gt; [[1]]
 #&gt; [1] ""Clippy""
 #&gt; 
 #&gt; [[2]]
@@ -194,20 +268,76 @@ <h2 class=""hasAnchor"" id=""examples""><a class=""anchor"" href=""#examples""></a>Examp
 #&gt; 
 #&gt; [[4]]
 #&gt; [1] 0.9
+#&gt; </div><div class='input'><span class='fu'>sapply</span>(<span class='no'>df</span>$<span class='no'>value</span>, <span class='no'>class</span>)</div><div class='output co'>#&gt; [[1]]
+#&gt; [1] ""character""
+#&gt; 
+#&gt; [[2]]
+#&gt; [1] ""character""
+#&gt; 
+#&gt; [[3]]
+#&gt; [1] ""POSIXct"" ""POSIXt"" 
+#&gt; 
+#&gt; [[4]]
+#&gt; [1] ""numeric""
 #&gt; </div><div class='input'>
 <span class='co'># Limit the number of data rows read</span>
 <span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='kw'>n_max</span> <span class='kw'>=</span> <span class='fl'>3</span>)</div><div class='output co'>#&gt; # A tibble: 3 × 5
 #&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
 #&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;
 #&gt; 1          5.1         3.5          1.4         0.2  setosa
 #&gt; 2          4.9         3.0          1.4         0.2  setosa
-#&gt; 3          4.7         3.2          1.3         0.2  setosa</div></pre>
+#&gt; 3          4.7         3.2          1.3         0.2  setosa</div><div class='input'>
+<span class='co'># Read from an Excel range using A1 or R1C1 notation</span>
+<span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='st'>""C1:E7""</span>)</div><div class='output co'>#&gt; # A tibble: 6 × 3
+#&gt;   Petal.Length Petal.Width Species
+#&gt;          &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;
+#&gt; 1          1.4         0.2  setosa
+#&gt; 2          1.4         0.2  setosa
+#&gt; 3          1.3         0.2  setosa
+#&gt; 4          1.5         0.2  setosa
+#&gt; 5          1.4         0.2  setosa
+#&gt; 6          1.7         0.4  setosa</div><div class='input'><span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='st'>""R1C2:R2C5""</span>)</div><div class='output co'>#&gt; # A tibble: 1 × 4
+#&gt;   Sepal.Width Petal.Length Petal.Width Species
+#&gt;         &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;   &lt;chr&gt;
+#&gt; 1         3.5          1.4         0.2  setosa</div><div class='input'>
+<span class='co'># Read only specific rows or columns</span>
+<span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='fu'><a href='cell-specification.html'>cell_rows</a></span>(<span class='fl'>102</span>:<span class='fl'>151</span>), <span class='kw'>col_names</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>)</div><div class='output co'>#&gt; # A tibble: 50 × 5
+#&gt;     X__1  X__2  X__3  X__4      X__5
+#&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;chr&gt;
+#&gt; 1    6.3   3.3   6.0   2.5 virginica
+#&gt; 2    5.8   2.7   5.1   1.9 virginica
+#&gt; 3    7.1   3.0   5.9   2.1 virginica
+#&gt; 4    6.3   2.9   5.6   1.8 virginica
+#&gt; 5    6.5   3.0   5.8   2.2 virginica
+#&gt; 6    7.6   3.0   6.6   2.1 virginica
+#&gt; 7    4.9   2.5   4.5   1.7 virginica
+#&gt; 8    7.3   2.9   6.3   1.8 virginica
+#&gt; 9    6.7   2.5   5.8   1.8 virginica
+#&gt; 10   7.2   3.6   6.1   2.5 virginica
+#&gt; # ... with 40 more rows</div><div class='input'><span class='fu'>read_excel</span>(<span class='no'>datasets</span>, <span class='kw'>range</span> <span class='kw'>=</span> <span class='fu'><a href='cell-specification.html'>cell_cols</a></span>(<span class='st'>""B:D""</span>))</div><div class='output co'>#&gt; # A tibble: 150 × 3
+#&gt;    Sepal.Width Petal.Length Petal.Width
+#&gt;          &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;
+#&gt; 1          3.5          1.4         0.2
+#&gt; 2          3.0          1.4         0.2
+#&gt; 3          3.2          1.3         0.2
+#&gt; 4          3.1          1.5         0.2
+#&gt; 5          3.6          1.4         0.2
+#&gt; 6          3.9          1.7         0.4
+#&gt; 7          3.4          1.4         0.3
+#&gt; 8          3.4          1.5         0.2
+#&gt; 9          2.9          1.4         0.2
+#&gt; 10         3.1          1.5         0.1
+#&gt; # ... with 140 more rows</div></pre>
   </div>
   <div class=""col-md-3 hidden-xs hidden-sm"" id=""sidebar"">
     <h2>Contents</h2>
     <ul class=""nav nav-pills nav-stacked"">
       <li><a href=""#arguments"">Arguments</a></li>
-            
+      
+      <li><a href=""#value"">Value</a></li>
+
+      <li><a href=""#see-also"">See also</a></li>
+      
       <li><a href=""#examples"">Examples</a></li>
     </ul>
 

---FILE: docs/reference/readxl-package.html---
@@ -103,7 +103,7 @@ <h2>Contents</h2>
 
     <h2>Author</h2>
     
-<strong>Maintainer</strong>: Jennifer Bryan <a href='mailto:jenny.f.bryan@gmail.com'>jenny.f.bryan@gmail.com</a>
+<strong>Maintainer</strong>: Jennifer Bryan <a href='mailto:jenny@rstudio.com'>jenny@rstudio.com</a>
 
 Authors:
 <ul>

---FILE: docs/reference/readxl_example.html---
@@ -85,14 +85,18 @@ <h1>Get path to readxl example</h1>
     <pre><span class='fu'>readxl_example</span>(<span class='kw'>path</span> <span class='kw'>=</span> <span class='kw'>NULL</span>)</pre>
     
     <h2 class=""hasAnchor"" id=""arguments""><a class=""anchor"" href=""#arguments""></a> Arguments</h2>
-    <dl class=""dl-horizontal"">
-      <dt>path</dt>
-      <dd><p>Name of file. If <code>NULL</code>, the example files will be listed.</p></dd>
-    </dl>
+    <table class=""ref-arguments"">
+    <colgroup><col class=""name"" /><col class=""desc"" /></colgroup>
+    <tr>
+      <th>path</th>
+      <td><p>Name of file. If <code>NULL</code>, the example files will be listed.</p></td>
+    </tr>
+    </table>
     
 
     <h2 class=""hasAnchor"" id=""examples""><a class=""anchor"" href=""#examples""></a>Examples</h2>
-    <pre class=""examples""><div class='input'><span class='fu'>readxl_example</span>()</div><div class='output co'>#&gt; [1] ""clippy.xls""    ""clippy.xlsx""   ""datasets.xls""  ""datasets.xlsx""</div><div class='input'><span class='fu'>readxl_example</span>(<span class='st'>""datasets.xlsx""</span>)</div><div class='output co'>#&gt; [1] ""/Users/jenny/rrr/readxl/inst/extdata/datasets.xlsx""</div></pre>
+    <pre class=""examples""><div class='input'><span class='fu'>readxl_example</span>()</div><div class='output co'>#&gt; [1] ""clippy.xls""    ""clippy.xlsx""   ""datasets.xls""  ""datasets.xlsx""
+#&gt; [5] ""geometry.xls""  ""geometry.xlsx""</div><div class='input'><span class='fu'>readxl_example</span>(<span class='st'>""datasets.xlsx""</span>)</div><div class='output co'>#&gt; [1] ""/Users/jenny/rrr/readxl/inst/extdata/datasets.xlsx""</div></pre>
   </div>
   <div class=""col-md-3 hidden-xs hidden-sm"" id=""sidebar"">
     <h2>Contents</h2>

---FILE: man/cell-specification.Rd---
@@ -0,0 +1,67 @@
+% Generated by roxygen2: do not edit by hand
+% Please edit documentation in R/cell-specification.R
+\name{cell-specification}
+\alias{cell-specification}
+\alias{cell_limits}
+\alias{cell_rows}
+\alias{cell_cols}
+\alias{anchored}
+\title{Specify cells for reading}
+\description{
+The \code{range} argument of \code{\link[=read_excel]{read_excel()}} provides many ways to limit the read
+to a specific rectangle of cells. The simplest usage is to provide an
+Excel-like cell range, such as \code{range = ""D12:F15""} or \code{range = ""R1C12:R6C15""}. The cell rectangle can be specified in various other ways,
+using helper functions. In all cases, cell range processing is handled by the
+\link{cellranger} package, where you can find full documentation for
+the functions used in the examples below.
+}
+\examples{
+path <- readxl_example(""geometry.xls"")
+## Rows 1 and 2 are empty (as are rows 7 and higher)
+## Column 1 aka ""A"" is empty (as are columns 5 of ""E"" and higher)
+
+# By default, the populated data cells are ""shrink-wrapped"" into a
+# minimal data frame
+read_excel(path)
+
+# Specific rectangle that is subset of populated cells, possibly improper
+read_excel(path, range = ""B3:D6"")
+read_excel(path, range = ""C3:D5"")
+
+# Specific rectangle that forces inclusion of unpopulated cells
+read_excel(path, range = ""A3:D5"")
+read_excel(path, range = ""A4:E5"")
+read_excel(path, range = ""C5:E7"")
+
+# Anchor a rectangle of specified size at a particular cell
+read_excel(path, range = anchored(""C4"", dim = c(3, 2)), col_names = FALSE)
+
+# Specify only the rows or only the columns
+read_excel(path, range = cell_rows(3:6))
+read_excel(path, range = cell_cols(""C:D""))
+read_excel(path, range = cell_cols(2))
+
+# Specify exactly one row or column bound
+read_excel(path, range = cell_rows(c(5, NA)))
+read_excel(path, range = cell_rows(c(NA, 4)))
+read_excel(path, range = cell_cols(c(""C"", NA)))
+read_excel(path, range = cell_cols(c(NA, 2)))
+
+# General open rectangles
+# upper left = C4, everything else unspecified
+read_excel(path, range = cell_limits(c(4, 3), c(NA, NA)))
+# upper right = D4, everything else unspecified
+read_excel(path, range = cell_limits(c(4, NA), c(NA, 4)))
+
+}
+\seealso{
+The \link{cellranger} package has full documentation on cell
+specification and offers additional functions for manipulating ""A1:D10""
+style spreadsheet ranges. Here are the most relevant:
+\itemize{
+\item \code{\link[cellranger:cell_limits]{cellranger::cell_limits()}}
+\item \code{\link[cellranger:cell_rows]{cellranger::cell_rows()}}
+\item \code{\link[cellranger:cell_cols]{cellranger::cell_cols()}}
+\item \code{\link[cellranger:anchored]{cellranger::anchored()}}
+}
+}

---FILE: man/read_excel.Rd---
@@ -6,21 +6,29 @@
 \alias{read_xlsx}
 \title{Read xls and xlsx files.}
 \usage{
-read_excel(path, sheet = 1L, col_names = TRUE, col_types = NULL,
-  na = """", skip = 0, n_max = Inf, guess_max = min(1000, n_max))
+read_excel(path, sheet = 1L, range = NULL, col_names = TRUE,
+  col_types = NULL, na = """", skip = 0, n_max = Inf,
+  guess_max = min(1000, n_max))
 
-read_xls(path, sheet = 1L, col_names = TRUE, col_types = NULL, na = """",
-  skip = 0, n_max = Inf, guess_max = min(1000, n_max))
+read_xls(path, sheet = 1L, range = NULL, col_names = TRUE,
+  col_types = NULL, na = """", skip = 0, n_max = Inf,
+  guess_max = min(1000, n_max))
 
-read_xlsx(path, sheet = 1L, col_names = TRUE, col_types = NULL, na = """",
-  skip = 0, n_max = Inf, guess_max = min(1000, n_max))
+read_xlsx(path, sheet = 1L, range = NULL, col_names = TRUE,
+  col_types = NULL, na = """", skip = 0, n_max = Inf,
+  guess_max = min(1000, n_max))
 }
 \arguments{
 \item{path}{Path to the xls/xlsx file}
 
 \item{sheet}{Sheet to read. Either a string (the name of a sheet), or an
 integer (the position of the sheet). Defaults to the first sheet.}
 
+\item{range}{A cell range to read from, as described in \link{cell-specification}.
+Includes typical Excel ranges like ""B3:D87"" and more. Interpreted strictly,
+even if the range includes leading or trailing empty rows or columns. Takes
+precedence over \code{skip} and \code{n_max}.}
+
 \item{col_names}{\code{TRUE} to use the first row as column names, \code{FALSE} to get
 default names, or a character vector giving a name for each column. If user
 provides \code{col_types} as a vector, \code{col_names} can have one entry per
@@ -30,23 +38,29 @@ unskipped column.}
 \item{col_types}{Either \code{NULL} to guess all from the spreadsheet or a
 character vector containing one entry per column from these options:
 ""skip"", ""guess"", ""logical"", ""numeric"", ""date"", ""text"" or ""list"". If exactly
-on \code{col_type} is specified, it will be recycled. The content of a cell in a
-skipped column is never read and that column will not appear in the data
+one \code{col_type} is specified, it will be recycled. The content of a cell in
+a skipped column is never read and that column will not appear in the data
 frame output. A list cell loads a column as a list of length 1 vectors,
 which are typed using the type guessing logic from \code{col_types = NULL}, but
 on a cell-by-cell basis.}
 
 \item{na}{Character vector of strings to use for missing values. By default,
 readxl treats blank cells as missing data.}
 
-\item{skip}{Number of rows to skip before reading anything (column names or
-data). Leading blank rows are automatically skipped.}
+\item{skip}{Minimum number of rows to skip before reading anything, be it
+column names or data. Leading empty rows are automatically skipped, so this
+is a lower bound. Ignored if \code{range} is given.}
 
-\item{n_max}{Maximum number of data rows to read.}
+\item{n_max}{Maximum number of data rows to read. Trailing empty rows are
+automatically skipped, so this is an upper bound on the number of rows in
+the returned tibble. Ignored if \code{range} is given.}
 
 \item{guess_max}{Maximum number of data rows to use for guessing column
 types.}
 }
+\value{
+A \link[tibble:tibble-package]{tibble}
+}
 \description{
 Read xls and xlsx files.
 
@@ -65,17 +79,30 @@ read_excel(datasets, ""mtcars"")
 # Skip rows and use default column names
 read_excel(datasets, skip = 148, col_names = FALSE)
 
-# Recycle a length-one col_types
+# Recycle a single column type
 read_excel(datasets, col_types = ""text"")
 
 # Specify some col_types and guess others
 read_excel(datasets, col_types = c(""text"", ""guess"", ""numeric"", ""guess"", ""guess""))
 
-# ""list"" col_type can handle information of disparate types
+# Accomodate a column with disparate types via col_type = ""list""
 df <- read_excel(readxl_example(""clippy.xlsx""), col_types = c(""text"", ""list""))
 df
 df$value
+sapply(df$value, class)
 
 # Limit the number of data rows read
 read_excel(datasets, n_max = 3)
+
+# Read from an Excel range using A1 or R1C1 notation
+read_excel(datasets, range = ""C1:E7"")
+read_excel(datasets, range = ""R1C2:R2C5"")
+
+# Read only specific rows or columns
+read_excel(datasets, range = cell_rows(102:151), col_names = FALSE)
+read_excel(datasets, range = cell_cols(""B:D""))
+}
+\seealso{
+\link{cell-specification} for more details on targetting cells with the
+\code{range} argument
 }

---FILE: man/readxl-package.Rd---
@@ -20,7 +20,7 @@ Useful links:
 
 }
 \author{
-\strong{Maintainer}: Jennifer Bryan \email{jenny.f.bryan@gmail.com}
+\strong{Maintainer}: Jennifer Bryan \email{jenny@rstudio.com}
 
 Authors:
 \itemize{

---FILE: src/CellLimits.h---
@@ -0,0 +1,99 @@
+#ifndef READXL_CELLLIMITS_
+#define READXL_CELLLIMITS_
+
+#include <Rcpp.h>
+#include ""XlsCell.h""
+
+class CellLimits {
+  int minRow_, maxRow_, minCol_, maxCol_;
+
+public:
+  CellLimits() {
+    minRow_ = -1;
+    maxRow_ = -1;
+    minCol_ = -1;
+    maxCol_ = -1;
+  }
+  CellLimits(Rcpp::IntegerVector limits) {
+    minRow_ = limits[0];
+    maxRow_ = limits[1];
+    minCol_ = limits[2];
+    maxCol_ = limits[3];
+  }
+
+  int minRow() const {
+    return minRow_;
+  }
+  int maxRow() const {
+    return maxRow_;
+  }
+  int minCol() const {
+    return minCol_;
+  }
+  int maxCol() const {
+    return maxCol_;
+  }
+
+  void update(const XlsCell cell) {
+    update(cell.row(), cell.col());
+  }
+
+  void update(const int row, const int col) {
+    if (minRow_ < 0 || row < minRow_) {
+      minRow_ = row;
+    }
+    if (row > maxRow_) {
+      maxRow_ = row;
+    }
+    if (minCol_ < 0 || col < minCol_) {
+      minCol_ = col;
+    }
+    if (col > maxCol_) {
+      maxCol_ = col;
+    }
+  }
+
+  bool contains(const XlsCell cell) const {
+    return contains(cell.row(), cell.col());
+  }
+
+  bool contains(const int i, const int j) const {
+    return contains(minRow_, maxRow_, i) && contains(minCol_, maxCol_, j);
+  }
+
+  bool contains(const int i) const {
+    return contains(minRow_, maxRow_, i);
+  }
+
+  void print() {
+    Rcpp::Rcout << ""row min, max: "" << minRow_ << "", ""
+                << maxRow_ << ""\t""
+                << ""col min, max: "" << minCol_<< "", ""
+                << maxCol_ << std::endl;
+  }
+
+private:
+
+  bool contains(int min, int max, int val) const {
+    if (min < 0) {
+      if (max < 0) {
+        // min = max = -1 is our convention for 'no limits specified'
+        return true;
+      } else {
+        // min < 0, max >= 0 should never happen, because cellranger should
+        // always turn (-inf, max] into [0, max], but it's harmless to handle
+        return val <= max;
+      }
+    } else {
+      if (max < 0) {
+        // min >= 0, max < 0 is our convention for [min, +inf)
+        return val >= min;
+      } else {
+        // min >= 0, max >= 0 is the straightforward case: [min, max]
+        return val >= min && val <= max;
+      }
+    }
+  }
+};
+
+#endif

---FILE: src/RcppExports.cpp---
@@ -27,53 +27,21 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// xls_col_names
-CharacterVector xls_col_names(std::string path, std::vector<std::string> na, int sheet_i, int skip, int n_max);
-RcppExport SEXP readxl_xls_col_names(SEXP pathSEXP, SEXP naSEXP, SEXP sheet_iSEXP, SEXP skipSEXP, SEXP n_maxSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< std::string >::type path(pathSEXP);
-    Rcpp::traits::input_parameter< std::vector<std::string> >::type na(naSEXP);
-    Rcpp::traits::input_parameter< int >::type sheet_i(sheet_iSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type n_max(n_maxSEXP);
-    rcpp_result_gen = Rcpp::wrap(xls_col_names(path, na, sheet_i, skip, n_max));
-    return rcpp_result_gen;
-END_RCPP
-}
-// xls_col_types
-CharacterVector xls_col_types(std::string path, std::vector<std::string> na, int sheet_i, int skip, int n_max, int guess_max, bool has_col_names);
-RcppExport SEXP readxl_xls_col_types(SEXP pathSEXP, SEXP naSEXP, SEXP sheet_iSEXP, SEXP skipSEXP, SEXP n_maxSEXP, SEXP guess_maxSEXP, SEXP has_col_namesSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< std::string >::type path(pathSEXP);
-    Rcpp::traits::input_parameter< std::vector<std::string> >::type na(naSEXP);
-    Rcpp::traits::input_parameter< int >::type sheet_i(sheet_iSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type n_max(n_maxSEXP);
-    Rcpp::traits::input_parameter< int >::type guess_max(guess_maxSEXP);
-    Rcpp::traits::input_parameter< bool >::type has_col_names(has_col_namesSEXP);
-    rcpp_result_gen = Rcpp::wrap(xls_col_types(path, na, sheet_i, skip, n_max, guess_max, has_col_names));
-    return rcpp_result_gen;
-END_RCPP
-}
 // read_xls_
-List read_xls_(std::string path, int sheet_i, RObject col_names, RObject col_types, std::vector<std::string> na, int skip, int n_max, int guess_max);
-RcppExport SEXP readxl_read_xls_(SEXP pathSEXP, SEXP sheet_iSEXP, SEXP col_namesSEXP, SEXP col_typesSEXP, SEXP naSEXP, SEXP skipSEXP, SEXP n_maxSEXP, SEXP guess_maxSEXP) {
+List read_xls_(std::string path, int sheet_i, IntegerVector limits, bool shim, RObject col_names, RObject col_types, std::vector<std::string> na, int guess_max);
+RcppExport SEXP readxl_read_xls_(SEXP pathSEXP, SEXP sheet_iSEXP, SEXP limitsSEXP, SEXP shimSEXP, SEXP col_namesSEXP, SEXP col_typesSEXP, SEXP naSEXP, SEXP guess_maxSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
     Rcpp::traits::input_parameter< std::string >::type path(pathSEXP);
     Rcpp::traits::input_parameter< int >::type sheet_i(sheet_iSEXP);
+    Rcpp::traits::input_parameter< IntegerVector >::type limits(limitsSEXP);
+    Rcpp::traits::input_parameter< bool >::type shim(shimSEXP);
     Rcpp::traits::input_parameter< RObject >::type col_names(col_namesSEXP);
     Rcpp::traits::input_parameter< RObject >::type col_types(col_typesSEXP);
     Rcpp::traits::input_parameter< std::vector<std::string> >::type na(naSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type n_max(n_maxSEXP);
     Rcpp::traits::input_parameter< int >::type guess_max(guess_maxSEXP);
-    rcpp_result_gen = Rcpp::wrap(read_xls_(path, sheet_i, col_names, col_types, na, skip, n_max, guess_max));
+    rcpp_result_gen = Rcpp::wrap(read_xls_(path, sheet_i, limits, shim, col_names, col_types, na, guess_max));
     return rcpp_result_gen;
 END_RCPP
 }
@@ -121,53 +89,21 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// xlsx_col_types
-CharacterVector xlsx_col_types(std::string path, int sheet_i, CharacterVector na, int skip, int n_max, int guess_max, bool has_col_names);
-RcppExport SEXP readxl_xlsx_col_types(SEXP pathSEXP, SEXP sheet_iSEXP, SEXP naSEXP, SEXP skipSEXP, SEXP n_maxSEXP, SEXP guess_maxSEXP, SEXP has_col_namesSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< std::string >::type path(pathSEXP);
-    Rcpp::traits::input_parameter< int >::type sheet_i(sheet_iSEXP);
-    Rcpp::traits::input_parameter< CharacterVector >::type na(naSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type n_max(n_maxSEXP);
-    Rcpp::traits::input_parameter< int >::type guess_max(guess_maxSEXP);
-    Rcpp::traits::input_parameter< bool >::type has_col_names(has_col_namesSEXP);
-    rcpp_result_gen = Rcpp::wrap(xlsx_col_types(path, sheet_i, na, skip, n_max, guess_max, has_col_names));
-    return rcpp_result_gen;
-END_RCPP
-}
-// xlsx_col_names
-CharacterVector xlsx_col_names(std::string path, CharacterVector na, int sheet_i, int skip, int n_max);
-RcppExport SEXP readxl_xlsx_col_names(SEXP pathSEXP, SEXP naSEXP, SEXP sheet_iSEXP, SEXP skipSEXP, SEXP n_maxSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< std::string >::type path(pathSEXP);
-    Rcpp::traits::input_parameter< CharacterVector >::type na(naSEXP);
-    Rcpp::traits::input_parameter< int >::type sheet_i(sheet_iSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type n_max(n_maxSEXP);
-    rcpp_result_gen = Rcpp::wrap(xlsx_col_names(path, na, sheet_i, skip, n_max));
-    return rcpp_result_gen;
-END_RCPP
-}
 // read_xlsx_
-List read_xlsx_(std::string path, int sheet_i, RObject col_names, RObject col_types, std::vector<std::string> na, int skip, int n_max, int guess_max);
-RcppExport SEXP readxl_read_xlsx_(SEXP pathSEXP, SEXP sheet_iSEXP, SEXP col_namesSEXP, SEXP col_typesSEXP, SEXP naSEXP, SEXP skipSEXP, SEXP n_maxSEXP, SEXP guess_maxSEXP) {
+List read_xlsx_(std::string path, int sheet_i, IntegerVector limits, bool shim, RObject col_names, RObject col_types, std::vector<std::string> na, int guess_max);
+RcppExport SEXP readxl_read_xlsx_(SEXP pathSEXP, SEXP sheet_iSEXP, SEXP limitsSEXP, SEXP shimSEXP, SEXP col_namesSEXP, SEXP col_typesSEXP, SEXP naSEXP, SEXP guess_maxSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
     Rcpp::traits::input_parameter< std::string >::type path(pathSEXP);
     Rcpp::traits::input_parameter< int >::type sheet_i(sheet_iSEXP);
+    Rcpp::traits::input_parameter< IntegerVector >::type limits(limitsSEXP);
+    Rcpp::traits::input_parameter< bool >::type shim(shimSEXP);
     Rcpp::traits::input_parameter< RObject >::type col_names(col_namesSEXP);
     Rcpp::traits::input_parameter< RObject >::type col_types(col_typesSEXP);
     Rcpp::traits::input_parameter< std::vector<std::string> >::type na(naSEXP);
-    Rcpp::traits::input_parameter< int >::type skip(skipSEXP);
-    Rcpp::traits::input_parameter< int >::type n_max(n_maxSEXP);
     Rcpp::traits::input_parameter< int >::type guess_max(guess_maxSEXP);
-    rcpp_result_gen = Rcpp::wrap(read_xlsx_(path, sheet_i, col_names, col_types, na, skip, n_max, guess_max));
+    rcpp_result_gen = Rcpp::wrap(read_xlsx_(path, sheet_i, limits, shim, col_names, col_types, na, guess_max));
     return rcpp_result_gen;
 END_RCPP
 }

---FILE: src/XlsCell.h---
@@ -29,6 +29,12 @@ class XlsCell {
     type_ = CELL_UNKNOWN;
   }
 
+  XlsCell(std::pair<int,int> loc)
+  {
+    location_ = loc;
+    type_ = CELL_BLANK;
+  }
+
   int row() const {
     return location_.first;
   }
@@ -247,6 +253,11 @@ class XlsCell {
 
     case CELL_TEXT:
       return std::string((char*) cell_->str);
+
+    default:
+      Rcpp::warning(""Unrecognized cell type at [%i, %i]: '%s'"",
+                    row() + 1, col() + 1, cell_->id);
+    return """";
   }
   }
 
@@ -267,6 +278,11 @@ class XlsCell {
     case CELL_LOGICAL:
     case CELL_NUMERIC:
       return cell_->d != 0;
+
+    default:
+      Rcpp::warning(""Unrecognized cell type at [%i, %i]: '%s'"",
+                    row() + 1, col() + 1, cell_->id);
+    return NA_LOGICAL;
     }
   }
 
@@ -282,6 +298,11 @@ class XlsCell {
     case CELL_DATE:
     case CELL_NUMERIC:
       return cell_->d;
+
+    default:
+      Rcpp::warning(""Unrecognized cell type at [%i, %i]: '%s'"",
+                    row() + 1, col() + 1, cell_->id);
+    return NA_REAL;
     }
   }
 
@@ -297,6 +318,11 @@ class XlsCell {
     case CELL_DATE:
     case CELL_NUMERIC:
       return POSIXctFromSerial(cell_->d, is1904);
+
+    default:
+      Rcpp::warning(""Unrecognized cell type at [%i, %i]: '%s'"",
+                    row() + 1, col() + 1, cell_->id);
+    return NA_REAL;
     }
   }
 

---FILE: src/XlsWorkSheet.cpp---
@@ -6,30 +6,20 @@
 using namespace Rcpp;
 
 // [[Rcpp::export]]
-CharacterVector xls_col_names(std::string path,
-                              std::vector<std::string> na,
-                              int sheet_i = 0, int skip = 0, int n_max = 1) {
-  return XlsWorkSheet(path, sheet_i, skip, n_max).colNames(na);
-}
+List read_xls_(std::string path, int sheet_i,
+               IntegerVector limits, bool shim,
+               RObject col_names, RObject col_types,
+               std::vector<std::string> na, int guess_max = 1000) {
 
-// [[Rcpp::export]]
-CharacterVector xls_col_types(std::string path,
-                              std::vector<std::string> na,
-                              int sheet_i = 0, int skip = 0, int n_max = -1,
-                              int guess_max = 1000, bool has_col_names = false) {
-  XlsWorkSheet ws(path, sheet_i, skip, n_max);
-  std::vector<ColType> types(ws.ncol());
-  std::fill(types.begin(), types.end(), COL_UNKNOWN);
-  types = ws.colTypes(types, na, guess_max, has_col_names);
-  return colTypeDescs(types);
-}
+  // Construct worksheet ----------------------------------------------
+  XlsWorkSheet ws(path, sheet_i, limits, shim);
 
-// [[Rcpp::export]]
-List read_xls_(std::string path, int sheet_i, RObject col_names,
-                RObject col_types, std::vector<std::string> na,
-                int skip = 0, int n_max = -1, int guess_max = 1000) {
+  // catches empty sheets and sheets where requested rectangle contains no data
+  if (ws.nrow() == 0 && ws.ncol() == 0) {
+    return Rcpp::List(0);
+  }
 
-  // has_col_names = TRUE iff we will read col names from sheet -------
+  // Get column names -------------------------------------------------
   CharacterVector colNames;
   bool has_col_names = false;
   switch(TYPEOF(col_names)) {
@@ -38,29 +28,12 @@ List read_xls_(std::string path, int sheet_i, RObject col_names,
     break;
   case LGLSXP:
     has_col_names = as<bool>(col_names);
+    colNames = has_col_names ? ws.colNames(na) : CharacterVector(ws.ncol(), """");
     break;
   default:
     Rcpp::stop(""`col_names` must be a logical or character vector"");
   }
 
-  // Adjust n_max -----------------------------------------------------
-  if (n_max >= 0 && has_col_names) {
-    n_max++;
-  }
-
-  // Construct worksheet ----------------------------------------------
-  XlsWorkSheet ws(path, sheet_i, skip, n_max);
-
-  // catches empty sheets and sheets where we skip past all data
-  if (ws.nrow() == 0 && ws.ncol() == 0) {
-   return Rcpp::List(0);
-  }
-
-  // Populate column names, if necessary ------------------------------
-  if (TYPEOF(col_names) == LGLSXP) {
-    colNames = has_col_names ? ws.colNames(na) : CharacterVector(ws.ncol(), """");
-  }
-
   // Get column types --------------------------------------------------
   if (TYPEOF(col_types) != STRSXP) {
     Rcpp::stop(""`col_types` must be a character vector"");

---FILE: src/XlsWorkSheet.h---
@@ -6,6 +6,7 @@
 #include ""XlsWorkBook.h""
 #include ""XlsCell.h""
 #include ""ColSpec.h""
+#include ""CellLimits.h""
 
 class XlsWorkSheet {
   // the host workbook
@@ -19,13 +20,14 @@ class XlsWorkSheet {
   std::set<int> dateFormats_;
   std::vector<XlsCell> cells_;
   std::string sheetName_;
+  CellLimits nominal_, actual_;
   int ncol_, nrow_;
-  std::vector<XlsCell>::iterator firstRow_, secondRow_;
 
 public:
 
-  XlsWorkSheet(const XlsWorkBook wb, int sheet_i, int skip, int n_max):
-  wb_(wb)
+  XlsWorkSheet(const XlsWorkBook wb, int sheet_i,
+               Rcpp::IntegerVector limits, bool shim):
+  wb_(wb), nominal_(limits)
   {
     if (sheet_i >= wb.n_sheets()) {
       Rcpp::stop(""Can't retrieve sheet in position %d, only %d sheet(s) found."",
@@ -43,8 +45,12 @@ class XlsWorkSheet {
     xls_parseWorkSheet(pWS_);
     dateFormats_ = wb.dateFormats();
 
-    loadCells();
-    parseGeometry(skip, n_max);
+                                   // nominal_ holds user's geometry request
+    loadCells();                   // actual_ reports populated cells
+                                   //   inside the nominal_ rectangle
+    if (shim) insertShims();       // insert shims and update actual_
+    nrow_ = (actual_.minRow() < 0) ? 0 : actual_.maxRow() - actual_.minRow() + 1;
+    ncol_ = (actual_.minCol() < 0) ? 0 : actual_.maxCol() - actual_.minCol() + 1;
   }
 
   ~XlsWorkSheet() {
@@ -64,15 +70,12 @@ class XlsWorkSheet {
 
   Rcpp::CharacterVector colNames(const StringSet &na) {
     Rcpp::CharacterVector out(ncol_);
-    std::vector<XlsCell>::iterator xcell = firstRow_;
+    std::vector<XlsCell>::iterator xcell = cells_.begin();
     int base = xcell->row();
 
     while(xcell != cells_.end() && xcell->row() == base) {
-      if (xcell->col() >= ncol_) {
-        break;
-      }
       xcell->inferType(na, dateFormats_);
-      out[xcell->col()] = xcell->asCharSxp();
+      out[xcell->col() - actual_.minCol()] = xcell->asCharSxp();
       xcell++;
     }
     return out;
@@ -83,7 +86,7 @@ class XlsWorkSheet {
                                 int guess_max = 1000,
                                 bool has_col_names = false) {
     std::vector<XlsCell>::iterator xcell;
-    xcell = has_col_names ? secondRow_ : firstRow_;
+    xcell = has_col_names ? advance_row(cells_) : cells_.begin();
 
     // no cell data to consult re: types
     if (xcell == cells_.end()) {
@@ -97,13 +100,13 @@ class XlsWorkSheet {
     }
 
     // base is row the data starts on **in the spreadsheet**
-    int base = firstRow_->row() + has_col_names;
+    int base = cells_.begin()->row() + has_col_names;
     while (xcell != cells_.end() && xcell->row() - base < guess_max) {
       if ((xcell->row() - base + 1) % 1000 == 0) {
         Rcpp::checkUserInterrupt();
       }
-      int j = xcell->col();
-      if (type_known[j] || j >= ncol_) {
+      int j = xcell->col() - actual_.minCol();
+      if (type_known[j]) {
         xcell++;
         continue;
       }
@@ -124,11 +127,11 @@ class XlsWorkSheet {
                       bool has_col_names = false) {
 
     std::vector<XlsCell>::iterator xcell;
-    xcell = has_col_names ? secondRow_: firstRow_;
+    xcell = has_col_names ? advance_row(cells_) : cells_.begin();
 
     // base is row the data starts on **in the spreadsheet**
-    int base = firstRow_->row() + has_col_names;
-    int n = (xcell == cells_.end()) ? 0 : nrow_ - base;
+    int base = cells_.begin()->row() + has_col_names;
+    int n = (xcell == cells_.end()) ? 0 : actual_.maxRow() - base + 1;
     Rcpp::List cols(ncol_);
     cols.attr(""names"") = names;
     for (int j = 0; j < ncol_; ++j) {
@@ -142,11 +145,11 @@ class XlsWorkSheet {
     while (xcell != cells_.end()) {
 
       int i = xcell->row();
-      int j = xcell->col();
+      int j = xcell->col() - actual_.minCol();
       if ((i + 1) % 1000 == 0) {
         Rcpp::checkUserInterrupt();
       }
-      if (types[j] == COL_SKIP || j >= ncol_) {
+      if (types[j] == COL_SKIP) {
         xcell++;
         continue;
       }
@@ -293,86 +296,118 @@ class XlsWorkSheet {
 private:
 
   void loadCells() {
+    // by convention, min_row = -2 means 'read no data'
+    if (nominal_.minRow() < -1) {
+      return;
+    }
+
     int nominal_ncol = pWS_->rows.lastcol;
     int nominal_nrow = pWS_->rows.lastrow;
 
+    xls::xlsCell *cell;
     for (xls::WORD i = 0; i <= nominal_nrow; ++i) {
+      if (!nominal_.contains(i)) {
+        continue;
+      }
       for (xls::WORD j = 0; j <= nominal_ncol; ++j) {
 
-        xls::xlsCell *cell = xls_cell(pWS_, i, j);
+        if (nominal_.contains(i, j)) {
+          cell = xls_cell(pWS_, i, j);
+        } else {
+          continue;
+        }
 
         if (!cell) {
           continue;
         }
 
-        // Dimensions reported by xls itself include empty cells that have
+        // Dimensions reported by xls itself include blank cells that have
         // formatting, therefore we test explicitly for non-blank cell types
         // and only load those cells.
         // 2.4.90 Dimensions p273 of [MS-XLS]
-
         if (cell->id == XLS_RECORD_MULRK || cell->id == XLS_RECORD_NUMBER ||
             cell->id == XLS_RECORD_RK ||
             cell->id == XLS_RECORD_LABELSST || cell->id == XLS_RECORD_LABEL ||
             cell->id == XLS_RECORD_FORMULA ||  cell->id == XLS_RECORD_FORMULA_ALT ||
             cell->id == XLS_RECORD_BOOLERR
         ) {
           cells_.push_back(cell);
+          actual_.update(i, j);
         }
       }
     }
   }
 
-  // Compute sheet extent (= lower right corner) directly from loaded cells.
-  //   recorded in nrow_ and ncol_
-  // Return early if there is no data. Otherwise ...
-  // Position iterators at two landmarks for reading:
-  //   firstRow_ = first cell for which declared row >= skip
-  //   secondRow_ = first cell for which declared row > that of firstRow_
-  //   fallback to cells_.end() if the above not possible
-  // Assumes loaded cells are arranged s.t. row is non-decreasing
-  void parseGeometry(int skip, int n_max) {
-    ncol_ = 0;
-    nrow_ = 0;
-
-    // empty sheet or 'read no data' case
-    if (cells_.empty() || n_max == 0) {
+  // shim = TRUE when user specifies geometry via `range`
+  // shim = FALSE when user specifies no geometry or uses `skip` and `n_max`
+  //
+  // nominal_ reflects user's geometry request
+  // actual_ reports populated cells inside the nominal_ rectangle
+  //
+  // When shim = FALSE, we shrink-wrap the data that falls inside
+  // the nominal_ rectangle.
+  //
+  // When shim = TRUE, we may need to insert dummy cells to fill out
+  // the nominal_rectangle.
+  //
+  // actual_ is updated to reflect the insertions
+  void insertShims() {
+
+    // no cells were loaded
+    if (cells_.empty()) {
       return;
     }
 
-    firstRow_ = cells_.end();
-    secondRow_ = cells_.end();
-    std::vector<XlsCell>::iterator it = cells_.begin();
-
-    // advance past skip rows
-    while (it != cells_.end() && it->row() < skip) {
-      it++;
+    // Recall cell limits are -1 by convention if the limit is unspecified.
+    // funny_*() functions account for that.
+
+    // if nominal min row or col is less than actual,
+    // add a shim cell to the front of cells_
+    bool   shim_up = funny_lt(nominal_.minRow(), actual_.minRow());
+    bool shim_left = funny_lt(nominal_.minCol(), actual_.minCol());
+    if (shim_up || shim_left) {
+      int ul_row = funny_min(nominal_.minRow(), actual_.minRow());
+      int ul_col = funny_min(nominal_.minCol(), actual_.minCol());
+      XlsCell ul_shim(std::make_pair(ul_row, ul_col));
+      cells_.insert(cells_.begin(), ul_shim);
+      actual_.update(ul_row, ul_col);
     }
-    // 'skipped past all the data' case
-    if (it == cells_.end()) {
-      return;
+
+    // if nominal max row or col is greater than actual,
+    // add a shim cell to the back of cells_
+    bool  shim_down = funny_gt(nominal_.maxRow(), actual_.maxRow());
+    bool shim_right = funny_gt(nominal_.maxCol(), actual_.maxCol());
+    if (shim_down || shim_right) {
+      int lr_row = funny_max(nominal_.maxRow(), actual_.maxRow());
+      int lr_col = funny_max(nominal_.maxCol(), actual_.maxCol());
+      XlsCell lr_shim(std::make_pair(lr_row, lr_col));
+      cells_.push_back(lr_shim);
+      actual_.update(lr_row, lr_col);
     }
+  }
 
-    firstRow_ = it;
-    while (it != cells_.end() &&
-           (n_max < 0 || it->row() - firstRow_->row() < n_max)) {
+  bool funny_lt(const int funny, const int val) {
+    return (funny >= 0) && (funny < val);
+  }
 
-      if (ncol_ < it->col()) {
-        ncol_ = it->col();
-      }
+  bool funny_gt(const int funny, const int val) {
+    return (funny >= 0) && (funny > val);
+  }
 
-      if (secondRow_ == cells_.end() && it->row() > firstRow_->row()) {
-        secondRow_ = it;
-      }
+  int funny_min(const int funny, const int val) {
+    return funny_lt(funny, val) ? funny : val;
+  }
 
-      ++it;
-    }
+  int funny_max(const int funny, const int val) {
+    return funny_gt(funny, val) ? funny : val;
+  }
 
-    ncol_++;
-    if (secondRow_ > it) {
-      secondRow_ = it;
+  std::vector<XlsCell>::iterator advance_row(std::vector<XlsCell>& x) {
+    std::vector<XlsCell>::iterator it = x.begin();
+    while (it != x.end() && it->row() == x.begin()->row()) {
+      ++it;
     }
-    cells_.erase(it, cells_.end());
-    nrow_ = cells_.back().row() + 1;
+    return(it);
   }
 
 };

---FILE: src/XlsxCell.h---
@@ -34,6 +34,13 @@ class XlsxCell {
     type_ = CELL_UNKNOWN;
   }
 
+  XlsxCell(std::pair<int,int> loc)
+  {
+    cell_ = NULL;
+    location_ = loc;
+    type_ = CELL_BLANK;
+  }
+
   int row() const {
     return location_.first;
   }
@@ -175,6 +182,10 @@ class XlsxCell {
   }
 
   std::string asStdString(const std::vector<std::string>& stringTable) const {
+    if (cell_ == NULL) {
+      return """";
+    }
+
     rapidxml::xml_node<>* v = cell_->first_node(""v"");
     rapidxml::xml_attribute<>* t = cell_->first_attribute(""t"");
 
@@ -211,6 +222,10 @@ class XlsxCell {
       //   the mythical ISO 8601 date cell
       return(v->value());
     }
+
+    default:
+      Rcpp::warning(""Unrecognized cell type at [%i, %i]"", row() + 1, col() + 1);
+      return """";
   }
   }
 
@@ -234,6 +249,10 @@ class XlsxCell {
       rapidxml::xml_node<>* v = cell_->first_node(""v"");
       return atoi(v->value());
     }
+
+    default:
+      Rcpp::warning(""Unrecognized cell type at [%i, %i]"", row() + 1, col() + 1);
+      return NA_LOGICAL;
     }
   }
 
@@ -252,6 +271,10 @@ class XlsxCell {
       rapidxml::xml_node<>* v = cell_->first_node(""v"");
       return atof(v->value());
     }
+
+    default:
+      Rcpp::warning(""Unrecognized cell type at [%i, %i]"", row() + 1, col() + 1);
+      return NA_REAL;
     }
   }
 
@@ -270,6 +293,10 @@ class XlsxCell {
       rapidxml::xml_node<>* v = cell_->first_node(""v"");
       return POSIXctFromSerial(atof(v->value()), is1904);
     }
+
+    default:
+      Rcpp::warning(""Unrecognized cell type at [%i, %i]"", row() + 1, col() + 1);
+      return NA_REAL;
     }
   }
 

---FILE: src/XlsxWorkSheet.cpp---
@@ -12,32 +12,20 @@ IntegerVector parse_ref(std::string ref) {
 }
 
 // [[Rcpp::export]]
-CharacterVector xlsx_col_types(std::string path, int sheet_i = 0,
-                               CharacterVector na = CharacterVector(),
-                               int skip = 0, int n_max = -1,
-                               int guess_max = 1000,
-                               bool has_col_names = false) {
+List read_xlsx_(std::string path, int sheet_i,
+                IntegerVector limits, bool shim,
+                RObject col_names, RObject col_types,
+                std::vector<std::string> na, int guess_max = 1000) {
 
-  XlsxWorkSheet ws(path, sheet_i, skip, n_max);
-  std::vector<ColType> types(ws.ncol());
-  std::fill(types.begin(), types.end(), COL_UNKNOWN);
-  types = ws.colTypes(types, na, guess_max, has_col_names);
-  return colTypeDescs(types);
-}
-
-// [[Rcpp::export]]
-CharacterVector xlsx_col_names(std::string path,
-                               CharacterVector na = CharacterVector(),
-                               int sheet_i = 0, int skip = 0, int n_max = 1) {
-  return XlsxWorkSheet(path, sheet_i, skip, n_max).colNames(na);
-}
+  // Construct worksheet ----------------------------------------------
+  XlsxWorkSheet ws(path, sheet_i, limits, shim);
 
-// [[Rcpp::export]]
-List read_xlsx_(std::string path, int sheet_i, RObject col_names,
-                RObject col_types, std::vector<std::string> na,
-                int skip = 0, int n_max = -1, int guess_max = 1000) {
+  // catches empty sheets and sheets where requested rectangle contains no data
+  if (ws.nrow() == 0 && ws.ncol() == 0) {
+    return Rcpp::List(0);
+  }
 
-  // has_col_names = TRUE iff we will read col names from sheet -------
+  // Get column names -------------------------------------------------
   CharacterVector colNames;
   bool has_col_names = false;
   switch(TYPEOF(col_names)) {
@@ -46,29 +34,12 @@ List read_xlsx_(std::string path, int sheet_i, RObject col_names,
     break;
   case LGLSXP:
     has_col_names = as<bool>(col_names);
+    colNames = has_col_names ? ws.colNames(na) : CharacterVector(ws.ncol(), """");
     break;
   default:
     Rcpp::stop(""`col_names` must be a logical or character vector"");
   }
 
-  // Adjust n_max -----------------------------------------------------
-  if (n_max >= 0 && has_col_names) {
-    n_max++;
-  }
-
-  // Construct worksheet ----------------------------------------------
-  XlsxWorkSheet ws(path, sheet_i, skip, n_max);
-
-  // catches empty sheets and sheets where we skip past all data
-  if (ws.nrow() == 0 && ws.ncol() == 0) {
-    return Rcpp::List(0);
-  }
-
-  // Populate column names, if necessary ------------------------------
-  if (TYPEOF(col_names) == LGLSXP) {
-    colNames = has_col_names ? ws.colNames(na) : CharacterVector(ws.ncol(), """");
-  }
-
   // Get column types --------------------------------------------------
   if (TYPEOF(col_types) != STRSXP) {
     Rcpp::stop(""`col_types` must be a character vector"");

---FILE: src/XlsxWorkSheet.h---
@@ -6,6 +6,7 @@
 #include ""XlsxWorkBook.h""
 #include ""XlsxCell.h""
 #include ""ColSpec.h""
+#include ""CellLimits.h""
 
 // Page and section numbers below refer to
 // ECMA-376 (version, date, and download URL given in XlsxCell.h)
@@ -27,13 +28,14 @@ class XlsxWorkSheet {
   std::set<int> dateFormats_;
   std::vector<XlsxCell> cells_;
   std::string sheetName_;
+  CellLimits nominal_, actual_;
   int ncol_, nrow_;
-  std::vector<XlsxCell>::iterator firstRow_, secondRow_;
 
 public:
 
-  XlsxWorkSheet(const XlsxWorkBook wb, int sheet_i, int skip, int n_max):
-  wb_(wb)
+  XlsxWorkSheet(const XlsxWorkBook wb, int sheet_i,
+                Rcpp::IntegerVector limits, bool shim):
+  wb_(wb), nominal_(limits)
   {
     rapidxml::xml_node<>* rootNode;
 
@@ -59,8 +61,12 @@ class XlsxWorkSheet {
     }
     dateFormats_ = wb.dateFormats();
 
-    loadCells();
-    parseGeometry(skip, n_max);
+                                   // nominal_ holds user's geometry request
+    loadCells();                   // actual_ reports populated cells
+                                   //   inside the nominal_ rectangle
+    if (shim) insertShims();       // insert shims and update actual_
+    nrow_ = (actual_.minRow() < 0) ? 0 : actual_.maxRow() - actual_.minRow() + 1;
+    ncol_ = (actual_.minCol() < 0) ? 0 : actual_.maxCol() - actual_.minCol() + 1;
   }
 
   int ncol() const {
@@ -77,15 +83,12 @@ class XlsxWorkSheet {
 
   Rcpp::CharacterVector colNames(const StringSet &na) {
     Rcpp::CharacterVector out(ncol_);
-    std::vector<XlsxCell>::iterator xcell = firstRow_;
+    std::vector<XlsxCell>::iterator xcell = cells_.begin();
     int base = xcell->row();
 
     while(xcell != cells_.end() && xcell->row() == base) {
-      if (xcell->col() >= ncol_) {
-        break;
-      }
       xcell->inferType(na, wb_.stringTable(), dateFormats_);
-      out[xcell->col()] = xcell->asCharSxp(wb_.stringTable());
+      out[xcell->col() - actual_.minCol()] = xcell->asCharSxp(wb_.stringTable());
       xcell++;
     }
     return out;
@@ -96,7 +99,7 @@ class XlsxWorkSheet {
                                 int guess_max = 1000,
                                 bool has_col_names = false) {
     std::vector<XlsxCell>::iterator xcell;
-    xcell = has_col_names ? secondRow_ : firstRow_;
+    xcell = has_col_names ? advance_row(cells_) : cells_.begin();
 
     // no cell data to consult re: types
     if (xcell == cells_.end()) {
@@ -110,13 +113,13 @@ class XlsxWorkSheet {
     }
 
     // base is row the data starts on **in the spreadsheet**
-    int base = firstRow_->row() + has_col_names;
+    int base = cells_.begin()->row() + has_col_names;
     while (xcell != cells_.end() && xcell->row() - base < guess_max) {
       if ((xcell->row() - base + 1) % 1000 == 0) {
         Rcpp::checkUserInterrupt();
       }
-      int j = xcell->col();
-      if (type_known[j] || j >= ncol_) {
+      int j = xcell->col() - actual_.minCol();
+      if (type_known[j]) {
         xcell++;
         continue;
       }
@@ -137,11 +140,11 @@ class XlsxWorkSheet {
                       bool has_col_names = false) {
 
     std::vector<XlsxCell>::iterator xcell;
-    xcell = has_col_names ? secondRow_: firstRow_;
+    xcell = has_col_names ? advance_row(cells_): cells_.begin();
 
     // base is row the data starts on **in the spreadsheet**
-    int base = firstRow_->row() + has_col_names;
-    int n = (xcell == cells_.end()) ? 0 : nrow_ - base;
+    int base = cells_.begin()->row() + has_col_names;
+    int n = (xcell == cells_.end()) ? 0 : actual_.maxRow() - base + 1;
     Rcpp::List cols(ncol_);
     cols.attr(""names"") = names;
     for (int j = 0; j < ncol_; ++j) {
@@ -155,11 +158,11 @@ class XlsxWorkSheet {
     while (xcell != cells_.end()) {
 
       int i = xcell->row();
-      int j = xcell->col();
+      int j = xcell->col() - actual_.minCol();
       if ((i + 1) % 1000 == 0) {
         Rcpp::checkUserInterrupt();
       }
-      if (types[j] == COL_SKIP || j >= ncol_) {
+      if (types[j] == COL_SKIP) {
         xcell++;
         continue;
       }
@@ -310,6 +313,11 @@ class XlsxWorkSheet {
 private:
 
   void loadCells() {
+    // by convention, min_row = -2 means 'read no data'
+    if (nominal_.minRow() < -1) {
+      return;
+    }
+
     rapidxml::xml_node<>* row = sheetData_->first_node(""row"");
     if (row == NULL) {
       return;
@@ -321,69 +329,95 @@ class XlsxWorkSheet {
       for (rapidxml::xml_node<>* cell = row->first_node(""c"");
            cell; cell = cell->next_sibling(""c"")) {
         rapidxml::xml_node<>* first_child = cell->first_node(0);
-        // only load cells that have >= 1 child nodes
-        // we require cell to have content, not just, e.g., a style
+        // only consider cells that have >= 1 child nodes
+        // we require cell to have content, not just, e.g., a format
         if (first_child != NULL) {
+          // (i, j) is our best guess at location, but if cell declares
+          // it's own location, we store that instead
           XlsxCell xcell(cell, i, j);
-          cells_.push_back(xcell);
+          i = xcell.row();
+          j = xcell.col();
+          if (nominal_.contains(i, j)) {
+            cells_.push_back(xcell);
+            actual_.update(i, j);
+          }
         }
         j++;
       }
       i++;
     }
-
   }
 
-  // Compute sheet extent (= lower right corner) directly from loaded cells.
-  //   recorded in nrow_ and ncol_
-  // Return early if there is no data. Otherwise ...
-  // Position iterators at two landmarks for reading:
-  //   firstRow_ = first cell for which declared row >= skip
-  //   secondRow_ = first cell for which declared row > that of firstRow_
-  //   fallback to cells_.end() if the above not possible
-  // Assumes loaded cells are arranged s.t. row is non-decreasing
-  void parseGeometry(int skip, int n_max) {
-    nrow_ = 0;
-    ncol_ = 0;
-
-    // empty sheet or 'read no data' case
-    if (cells_.empty() || n_max == 0) {
+  // shim = TRUE when user specifies geometry via `range`
+  // shim = FALSE when user specifies no geometry or uses `skip` and `n_max`
+  //
+  // nominal_ reflects user's geometry request
+  // actual_ reports populated cells inside the nominal_ rectangle
+  //
+  // When shim = FALSE, we shrink-wrap the data that falls inside
+  // the nominal_ rectangle.
+  //
+  // When shim = TRUE, we may need to insert dummy cells to fill out
+  // the nominal_rectangle.
+  //
+  // actual_ is updated to reflect the insertions
+  void insertShims() {
+
+    // no cells were loaded
+    if (cells_.empty()) {
       return;
     }
 
-    firstRow_ = cells_.end();
-    secondRow_ = cells_.end();
-    std::vector<XlsxCell>::iterator it = cells_.begin();
-
-    // advance past skip rows
-    while (it != cells_.end() && it->row() < skip) {
-      it++;
+    // Recall cell limits are -1 by convention if the limit is unspecified.
+    // funny_*() functions account for that.
+
+    // if nominal min row or col is less than actual,
+    // add a shim cell to the front of cells_
+    bool   shim_up = funny_lt(nominal_.minRow(), actual_.minRow());
+    bool shim_left = funny_lt(nominal_.minCol(), actual_.minCol());
+    if (shim_up || shim_left) {
+      int ul_row = funny_min(nominal_.minRow(), actual_.minRow());
+      int ul_col = funny_min(nominal_.minCol(), actual_.minCol());
+      XlsxCell ul_shim(std::make_pair(ul_row, ul_col));
+      cells_.insert(cells_.begin(), ul_shim);
+      actual_.update(ul_row, ul_col);
     }
-    // 'skipped past all the data' case
-    if (it == cells_.end()) {
-      return;
+
+    // if nominal max row or col is greater than actual,
+    // add a shim cell to the back of cells_
+    bool  shim_down = funny_gt(nominal_.maxRow(), actual_.maxRow());
+    bool shim_right = funny_gt(nominal_.maxCol(), actual_.maxCol());
+    if (shim_down || shim_right) {
+      int lr_row = funny_max(nominal_.maxRow(), actual_.maxRow());
+      int lr_col = funny_max(nominal_.maxCol(), actual_.maxCol());
+      XlsxCell lr_shim(std::make_pair(lr_row, lr_col));
+      cells_.push_back(lr_shim);
+      actual_.update(lr_row, lr_col);
     }
+  }
 
-    firstRow_ = it;
-    while (it != cells_.end() &&
-           (n_max < 0 || it->row() - firstRow_->row() < n_max)) {
+  bool funny_lt(const int funny, const int val) {
+    return (funny >= 0) && (funny < val);
+  }
 
-      if (ncol_ < it->col()) {
-        ncol_ = it->col();
-      }
+  bool funny_gt(const int funny, const int val) {
+    return (funny >= 0) && (funny > val);
+  }
 
-      if (secondRow_ == cells_.end() && it->row() > firstRow_->row()) {
-        secondRow_ = it;
-      }
+  int funny_min(const int funny, const int val) {
+    return funny_lt(funny, val) ? funny : val;
+  }
+
+  int funny_max(const int funny, const int val) {
+    return funny_gt(funny, val) ? funny : val;
+  }
 
+  std::vector<XlsxCell>::iterator advance_row(std::vector<XlsxCell>& x) {
+    std::vector<XlsxCell>::iterator it = x.begin();
+    while (it != x.end() && it->row() == x.begin()->row()) {
       ++it;
     }
-    ncol_++;
-    if (secondRow_ > it) {
-      secondRow_ = it;
-    }
-    cells_.erase(it, cells_.end());
-    nrow_ = cells_.back().row() + 1;
+    return(it);
   }
 
 };

---FILE: tests/BIFF5-LABEL-record-string-read-mac-10-11.supp---
@@ -57,9 +57,9 @@
    fun:xls_getfcell
    fun:xls_addCell
    fun:xls_parseWorkSheet
-   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiii
-   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiii
-   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_NS_6vectorIS5_NS3_IS5_EEEEiii
+   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiN4Rcpp6VectorILi13ENS1_15PreserveStorageEEEb
+   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiN4Rcpp6VectorILi13ENS1_15PreserveStorageEEEb
+   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_S9_S9_NS_6vectorIS5_NS3_IS5_EEEEi
    fun:readxl_read_xls_
 }
 {
@@ -72,9 +72,9 @@
    fun:xls_getfcell
    fun:xls_addCell
    fun:xls_parseWorkSheet
-   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiii
-   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiii
-   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_NS_6vectorIS5_NS3_IS5_EEEEiii
+   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiN4Rcpp6VectorILi13ENS1_15PreserveStorageEEEb
+   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiN4Rcpp6VectorILi13ENS1_15PreserveStorageEEEb
+   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_S9_S9_NS_6vectorIS5_NS3_IS5_EEEEi
    fun:readxl_read_xls_
    fun:R_doDotCall
 }
@@ -89,9 +89,9 @@
    fun:xls_getfcell
    fun:xls_addCell
    fun:xls_parseWorkSheet
-   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiii
-   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiii
-   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_NS_6vectorIS5_NS3_IS5_EEEEiii
+   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiN4Rcpp6VectorILi13ENS1_15PreserveStorageEEEb
+   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiN4Rcpp6VectorILi13ENS1_15PreserveStorageEEEb
+   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_S9_S9_NS_6vectorIS5_NS3_IS5_EEEEi
    fun:readxl_read_xls_
 }
 {
@@ -106,9 +106,9 @@
    fun:xls_getfcell
    fun:xls_addCell
    fun:xls_parseWorkSheet
-   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiii
-   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiii
-   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_NS_6vectorIS5_NS3_IS5_EEEEiii
+   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiN4Rcpp6VectorILi13ENS1_15PreserveStorageEEEb
+   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiN4Rcpp6VectorILi13ENS1_15PreserveStorageEEEb
+   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_S9_S9_NS_6vectorIS5_NS3_IS5_EEEEi
 }
 {
    <readxl-05-haswell-value8>
@@ -122,9 +122,9 @@
    fun:xls_getfcell
    fun:xls_addCell
    fun:xls_parseWorkSheet
-   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiii
-   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiii
-   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_NS_6vectorIS5_NS3_IS5_EEEEiii
+   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiN4Rcpp6VectorILi13ENS1_15PreserveStorageEEEb
+   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiN4Rcpp6VectorILi13ENS1_15PreserveStorageEEEb
+   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_S9_S9_NS_6vectorIS5_NS3_IS5_EEEEi
 }
 {
    <readxl-06-vasprintf-cond>
@@ -134,9 +134,9 @@
    fun:xls_getfcell
    fun:xls_addCell
    fun:xls_parseWorkSheet
-   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiii
-   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiii
-   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_NS_6vectorIS5_NS3_IS5_EEEEiii
+fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiN4Rcpp6VectorILi13ENS1_15PreserveStorageEEEb
+   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiN4Rcpp6VectorILi13ENS1_15PreserveStorageEEEb
+   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_S9_S9_NS_6vectorIS5_NS3_IS5_EEEEi
    fun:readxl_read_xls_
    fun:R_doDotCall
    fun:do_dotcall
@@ -150,9 +150,9 @@
    fun:xls_getfcell
    fun:xls_addCell
    fun:xls_parseWorkSheet
-   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiii
-   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiii
-   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_NS_6vectorIS5_NS3_IS5_EEEEiii
+   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiN4Rcpp6VectorILi13ENS1_15PreserveStorageEEEb
+   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiN4Rcpp6VectorILi13ENS1_15PreserveStorageEEEb
+   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_S9_S9_NS_6vectorIS5_NS3_IS5_EEEEi
    fun:readxl_read_xls_
    fun:R_doDotCall
    fun:do_dotcall

---FILE: tests/testthat/test-col-types.R---
@@ -11,7 +11,7 @@ test_that(""illegal col_types are rejected"", {
 test_that(""request for 'blank' col type gets deprecation message and fix"", {
   expect_message(
     read_excel(test_sheet(""types.xlsx""),
-               col_types = rep_len(c(""blank"", ""text""), length.out = 6)),
+               col_types = rep_len(c(""blank"", ""text""), length.out = 5)),
     ""`col_type = \""blank\""` deprecated. Use \""skip\"" instead."",
     fixed = TRUE
   )
@@ -50,7 +50,6 @@ test_that(""col_types are recycled"", {
 
 test_that(""types guessed correctly [xlsx]"", {
   types <- read_excel(test_sheet(""types.xlsx""), sheet = ""guess_me"")
-  expect_is(types$X__1, ""logical"")
   expect_is(types$blank, ""logical"")
   expect_is(types$boolean, ""logical"")
   expect_is(types$date, ""POSIXct"")
@@ -61,7 +60,6 @@ test_that(""types guessed correctly [xlsx]"", {
 
 test_that(""types guessed correctly [xls]"", {
   types <- read_excel(test_sheet(""types.xls""), sheet = ""guess_me"")
-  expect_is(types$X__1, ""logical"")
   expect_is(types$blank, ""logical"")
   expect_is(types$boolean, ""logical"")
   expect_is(types$date, ""POSIXct"")
@@ -71,9 +69,8 @@ test_that(""types guessed correctly [xls]"", {
 })
 
 test_that(""we can specify some col_types and guess others"", {
-  ctypes <- c(""numeric"", ""text"", ""guess"", ""guess"", ""text"", ""guess"")
-  exp_cls <- c(""numeric"", ""character"", ""logical"",
-               ""POSIXct"", ""character"", ""character"")
+  ctypes <- c(""text"", ""guess"", ""guess"", ""text"", ""guess"")
+  exp_cls <- c(""character"", ""logical"", ""POSIXct"", ""character"", ""character"")
 
   df <- read_excel(test_sheet(""types.xlsx""), col_types = ctypes)
   cls <- vapply(df, function(x) class(x)[1], character(1))

---FILE: tests/testthat/test-geometry.R---
@@ -0,0 +1,217 @@
+context(""Sheet geometry"")
+
+## testing of the unexported standardise_limits() ---------------------
+
+limitize <- function(x) {
+  stopifnot(length(x) == 4)
+  setNames(x, c(""min_row"", ""max_row"", ""min_col"", ""max_col""))
+}
+
+test_that(""we can say 'read nothing' via n_max and col_names"", {
+  ## n_max = 0 and col_names is not TRUE --> read nothing
+  l <- standardise_limits(range = NULL, skip = 0, n_max = 0, has_col_names = FALSE)
+  expect_identical(l, limitize(c(-2, -1, -1, -1)))
+  ## min_row max_row min_col max_col
+  ##      -2      -1      -1      -1
+
+  ## it should not matter what skip is
+  l2 <- standardise_limits(range = NULL, skip = sample(1:100, 1),
+                           n_max = 0, has_col_names = FALSE)
+  expect_identical(l, l2)
+})
+
+test_that(""we can request exactly 1 row for col_names via n_max and col_names"", {
+  my_skip <- sample(0:100, 1)
+  l <- standardise_limits(range = NULL, skip = my_skip, n_max = 0, has_col_names = TRUE)
+  expect_identical(l, limitize(c(my_skip, my_skip, -1, -1)))
+})
+
+test_that(""we can request exactly 1 row for data via n_max and col_names"", {
+  my_skip <- sample(0:100, 1)
+  l <- standardise_limits(range = NULL, skip = my_skip, n_max = 1, has_col_names = FALSE)
+  expect_identical(l, limitize(c(my_skip, my_skip, -1, -1)))
+})
+
+test_that(""we can request n rows for data via n_max and skip doesn't matter"", {
+  my_skip <- sample(0:100, 1)
+  n <- sample(1:100, 1)
+  l <- standardise_limits(range = NULL, skip = my_skip, n_max = n, has_col_names = TRUE)
+  expect_identical(l, limitize(c(my_skip, my_skip + n, -1, -1)))
+
+  my_skip <- sample(0:100, 1)
+  n <- sample(1:100, 1)
+  l <- standardise_limits(range = NULL, skip = my_skip, n_max = n, has_col_names = FALSE)
+  expect_identical(l, limitize(c(my_skip, my_skip + n - 1, -1, -1)))
+})
+
+## testing via read_excel() -------------------------------------------
+
+test_that(""geometry sheet is identical in xls and xlsx and shrink wraps by default"", {
+  ref <- tibble::tibble(
+    var1 = c(""aa"", ""dd"", ""gg""),
+    var2 = c(""bb"", ""ee"", ""hh""),
+    var3 = c(""cc"", ""ff"", ""ii"")
+  )
+  xls <- read_excel(test_sheet(""geometry.xls""))
+  xlsx <- read_excel(test_sheet(""geometry.xls""))
+  expect_identical(xls, xlsx)
+  expect_identical(xls, ref)
+})
+
+## at time of writing, clippy/geometry.key contains useful sketches
+## for choosing test cases
+## they are not comprehensive, but cover a very large number of scenarios
+
+test_that(""exact range request for data rectangle works"", {
+  ref <- tibble::tibble(
+    var1 = c(""aa"", ""dd"", ""gg""),
+    var2 = c(""bb"", ""ee"", ""hh""),
+    var3 = c(""cc"", ""ff"", ""ii"")
+  )
+  xls <- read_excel(test_sheet(""geometry.xls""), range = ""B3:D6"")
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = ""B3:D6"")
+  expect_identical(xls, xlsx)
+  expect_identical(xls, ref)
+})
+
+test_that(""range request for proper subset of data rectangle works"", {
+  ref <- tibble::tibble(
+    var1 = c(""aa""),
+    var2 = c(""bb"")
+  )
+  xls <- read_excel(test_sheet(""geometry.xls""), range = ""B3:C4"")
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = ""B3:C4"")
+  expect_identical(xls, xlsx)
+  expect_identical(xls, ref)
+})
+
+test_that(""range requests that run off one or more edges of data rectangle work"", {
+  ## all four edges
+  xls <- read_excel(test_sheet(""geometry.xls""), range = ""A2:E7"")
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = ""A2:E7"")
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(5L, 5L))
+
+  ## top edge only, partial
+  xls <- read_excel(test_sheet(""geometry.xls""), range = ""B2:C3"")
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = ""B2:C3"")
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(1L, 2L))
+
+  ## top and right, partial
+  xls <- read_excel(test_sheet(""geometry.xls""), range = ""D2:E3"")
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = ""D2:E3"")
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(1L, 2L))
+
+  ## right edge only, partial
+  xls <- read_excel(test_sheet(""geometry.xls""), range = ""C4:E5"")
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = ""C4:E5"")
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(1L, 3L))
+
+  ## left and right edges, partial
+  xls <- read_excel(test_sheet(""geometry.xls""), range = ""A4:E5"")
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = ""A4:E5"")
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(1L, 5L))
+
+  ## left and bottom edges, partial
+  xls <- read_excel(test_sheet(""geometry.xls""), range = ""A6:B7"")
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = ""A6:B7"")
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(1L, 2L))
+})
+
+test_that(""requests that use cell_rows() only work"", {
+  ## rows are within the data
+  xls <- read_excel(test_sheet(""geometry.xls""), range = cell_rows(2:3))
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = cell_rows(2:3))
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(1L, 3L))
+
+  ## rows run past the data
+  xls <- read_excel(test_sheet(""geometry.xls""), range = cell_rows(3:7))
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = cell_rows(3:7))
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(4L, 3L))
+
+  ## rows start before the data
+  xls <- read_excel(test_sheet(""geometry.xls""), range = cell_rows(1:4))
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = cell_rows(1:4))
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(3L, 3L))
+
+  ## rows start before and run past the data
+  xls <- read_excel(test_sheet(""geometry.xls""), range = cell_rows(1:7))
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = cell_rows(1:7))
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(6L, 3L))
+
+  ## unspecified upper row bound
+  xls <- read_excel(test_sheet(""geometry.xls""), range = cell_rows(c(3, NA)))
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = cell_rows(c(3, NA)))
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(3L, 3L))
+  ## unspecified lower bound not relevant because cellranger handles
+})
+
+test_that(""requests that use cell_cols() only work"", {
+  ## cols are within the data
+  xls <- read_excel(test_sheet(""geometry.xls""), range = cell_cols(2:3))
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = cell_cols(2:3))
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(3L, 2L))
+
+  ## cols run past the data
+  xls <- read_excel(test_sheet(""geometry.xls""), range = cell_cols(2:5))
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = cell_cols(2:5))
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(3L, 4L))
+
+  ## cols start before the data
+  xls <- read_excel(test_sheet(""geometry.xls""), range = cell_cols(1:3))
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = cell_cols(1:3))
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(3L, 3L))
+
+  ## cols start before and run past the data
+  xls <- read_excel(test_sheet(""geometry.xls""), range = cell_cols(1:5))
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = cell_cols(1:5))
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(3L, 5L))
+
+  ## unspecified upper col bound
+  xls <- read_excel(test_sheet(""geometry.xls""), range = cell_cols(c(3, NA)))
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = cell_cols(c(3, NA)))
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(3L, 2L))
+  ## unspecified lower bound not relevant because cellranger handles
+})
+
+test_that(""open rectangles work"", {
+  ## only worth testing openness on right and bottom
+  ## cellranger handles openness on left and top
+
+  ## open on bottom
+  lims <- cell_limits(c(5, 3), c(NA, 5))
+  xls <- read_excel(test_sheet(""geometry.xls""), range = lims)
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = lims)
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(1L, 3L))
+
+  ## open on right
+  lims <- cell_limits(c(3, 3), c(5, NA))
+  xls <- read_excel(test_sheet(""geometry.xls""), range = lims)
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = lims)
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(2L, 2L))
+
+  ## open on bottom and right
+  lims <- cell_limits(c(4, 3), c(NA, NA))
+  xls <- read_excel(test_sheet(""geometry.xls""), range = lims)
+  xlsx <- read_excel(test_sheet(""geometry.xlsx""), range = lims)
+  expect_identical(xls, xlsx)
+  expect_identical(dim(xls), c(2L, 2L))
+
+})

---FILE: tests/testthat/test-missing-values.R---
@@ -65,11 +65,16 @@ test_that(""na arg allows multiple strings [xlsx]"", {
   expect_true(all(is.na(df$y))) # formula column
 })
 
-test_that(""empty first column gives valid data.frame"", {
-  df <- read_excel(test_sheet(""missing-first-column.xlsx""), col_names = FALSE)
-  expect_equal(nrow(df), length(df[[2]]))
+test_that(""empty first column gives valid data.frame [xls]"", {
   df <- read_excel(test_sheet(""missing-first-column.xls""), col_names = FALSE)
-  expect_equal(nrow(df), length(df[[2]]))
+  expect_s3_class(df, ""tbl_df"")
+  expect_identical(dim(df), c(3L, 1L))
+})
+
+test_that(""empty first column gives valid data.frame [xlsx]"", {
+  df <- read_excel(test_sheet(""missing-first-column.xlsx""), col_names = FALSE)
+  expect_s3_class(df, ""tbl_df"")
+  expect_identical(dim(df), c(3L, 1L))
 })
 
 test_that(""empty named column gives NA column"", {

---FILE: tests/testthat/test-n-max.R---
@@ -42,7 +42,7 @@ test_that(""n_max is upper bound on nrows, if it causes trailing blank row"", {
   expect_identical(nrow(df), 2L)
 })
 
-test_that(""n_max can affect ncols, if prevents read of data in a col"", {
+test_that(""n_max can affect ncols, if prevents read of data in a col [xlsx]"", {
   ## xlsx
   df <- read_excel(test_sheet(""skipping.xlsx""), sheet = ""two_occupied_rows"",
                    n_max = 0)
@@ -51,8 +51,10 @@ test_that(""n_max can affect ncols, if prevents read of data in a col"", {
   df <- read_excel(test_sheet(""skipping.xlsx""), sheet = ""two_occupied_rows"",
                    skip = 1, n_max = 0)
   expect_identical(nrow(df), 0L)
-  expect_identical(ncol(df), 2L)
+  expect_identical(ncol(df), 1L)
+})
 
+test_that(""n_max can affect ncols, if prevents read of data in a col [xls]"", {
   ## xls
   df <- read_excel(test_sheet(""skipping.xls""), sheet = ""two_occupied_rows"",
                    n_max = 0)
@@ -61,7 +63,7 @@ test_that(""n_max can affect ncols, if prevents read of data in a col"", {
   df <- read_excel(test_sheet(""skipping.xls""), sheet = ""two_occupied_rows"",
                    skip = 1, n_max = 0)
   expect_identical(nrow(df), 0L)
-  expect_identical(ncol(df), 2L)
+  expect_identical(ncol(df), 1L)
 })
 
 test_that(""n_max = nrows in dense sheet when col_names = FALSE"", {",True,True,Documentation / Formatting,7
tidyverse,readxl,357e473d82b4a1a21658e4e5fefc4b644cb66883,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-03-31T21:21:20Z,GitHub,noreply@github.com,2017-03-31T21:21:20Z,"LABEL records in xls 1) exist and 2) have length stored as 16-bit value; fix… (#312)

* LABEL records in xls 1) exist and 2) have length stored as 16-bit value; fixes #309

* Support BIFF5 records as well as BIFF8

as per @jimhester

Changes the API of xls_getfcell to use BYTE* rather than DWORD* as the records are not aligned properly for DWORD*, then manually moves the address rather than relying on pointer arithmetic.

* Use self-documenting named constants re: xls record types

suggested by @jimhester

* Suppress valgrind false positives on Mac OS 10.11

http://valgrind.org/docs/manual/manual-core.html#manual-core.suppress",src/XlsCell.h;src/XlsWorkSheet.h;src/endian.c;src/libxls/xlstool.h;src/xls.c;src/xlstool.c;tests/BIFF5-LABEL-record-string-read-mac-10-11.supp;tests/testthat/sheets/biff5-label-records.xls;tests/testthat/test-compatibility.R,False,True,True,False,219,48,267,"---FILE: src/XlsCell.h---
@@ -4,6 +4,7 @@
 #include <Rcpp.h>
 #include <libxls/xls.h>
 #include <libxls/xlstypes.h>
+#include <libxls/xlsstruct.h>
 #include ""ColSpec.h""
 #include ""utils.h""
 
@@ -57,6 +58,20 @@ class XlsCell {
     // 2.3.1 starting p168 is ordered by name
     // 2.3.2 starting p180 is ordered by number
     //
+    // LabelSst 2.4.149 p325
+    // Label 2.4.148 p325
+    // Formula 2.4.127 p309
+    // Formula (Apple Numbers Bug) via libxls
+    // MulRk 2.4.175 p344
+    // Number 2.4.180 p348
+    // Rk 2.4.220 p376
+    // MulRk 2.4.175 p344
+    // Number 2.4.180 p348
+    // Rk 2.4.220 p376
+    // MulBlank 2.4.174 p344
+    // Blank 2.4.20 p212
+    // BoolErr 2.4.24 p216
+    //
     // For info on how libxls extracts and exposes, see xls_addCell. Also
     // consult xlsstruct.h to confirm record numbers.
     //
@@ -105,17 +120,13 @@ class XlsCell {
 
     CellType ct;
     switch(cell_->id) {
-    case 253: // 0x00FD LabelSst 2.4.149 p325:
-              // a string from the shared string table
-    case 516: // 0x0204 Label 2.4.148 p325:
-              // ""Label record specifies a label on the category axis for
-              // each series""
-              // Jenny: I think this one is a red herring = not a cell type
+    case XLS_RECORD_LABELSST:
+    case XLS_RECORD_LABEL:
       ct = na.contains((char*) cell_->str) ? CELL_BLANK : CELL_TEXT;
       break;
 
-    case 6:    // 0x0006 formula 2.4.127 p309
-    case 1030: // 0x0406 formula (Apple Numbers Bug) via libxls
+    case XLS_RECORD_FORMULA:
+    case XLS_RECORD_FORMULA_ALT:
       // l = 0     --> result is a number, possibly date
       // l = 65535 --> everything else
       if (cell_->l == 0) {
@@ -162,31 +173,25 @@ class XlsCell {
       }
       break;
 
-    case 189: // 0x00BD MulRk 2.4.175 p344:
-              // numeric data originating from series of cells
-    case 515: // 0x0203 Number 2.4.180 p348:
-              // floating-point number from single cell
-    case 638: // 0x027E Rk 2.4.220 p376:
-              // numeric data from single cell
-      {
-        if (na.contains(cell_->d)) {
-          ct = CELL_BLANK;
-          break;
-        }
-        int format = cell_->xf;
-        ct = (dateFormats.count(format) > 0) ? CELL_DATE : CELL_NUMERIC;
+    case XLS_RECORD_MULRK:
+    case XLS_RECORD_NUMBER:
+    case XLS_RECORD_RK:
+    {
+      if (na.contains(cell_->d)) {
+      ct = CELL_BLANK;
+      break;
       }
+      int format = cell_->xf;
+      ct = (dateFormats.count(format) > 0) ? CELL_DATE : CELL_NUMERIC;
+    }
       break;
 
-    case 190: // 0x00BE MulBlank 2.4.174 p344:
-              // blank cell originating from series of blank cells
-    case 513: // 0x0201 Blank 2.4.20 p212:
-              // an empty cell with no formula or value
+    case XLS_RECORD_MULBLANK:
+    case XLS_RECORD_BLANK:
       ct = CELL_BLANK;
       break;
 
-    case 517: // 0x0205 BoolErr 2.4.24 p216:
-              //  a cell that contains either a Boolean value or an error value
+    case XLS_RECORD_BOOLERR:
       if (strncmp((char *) cell_->str, ""bool"", 4) == 0) {
         if ( (cell_->d == 0 && na.contains(""FALSE"")) ||
              (cell_->d == 1 && na.contains(""TRUE"")) ) {

---FILE: src/XlsWorkSheet.h---
@@ -310,21 +310,11 @@ class XlsWorkSheet {
         // and only load those cells.
         // 2.4.90 Dimensions p273 of [MS-XLS]
 
-        if (cell->id == 0x27e || cell->id == 0x0BD || cell->id == 0x203 ||
-            // cell holds a number:
-            //   0x27e -->  638     RK (section 2.4.220) p376 of [MS-XLS]
-            //   0x0BD -->  189  MulRk (section 2.4.175) p344
-            //   0x203 -->  515 Number (section 2.4.180) p348
-            cell->id == 0x06 ||  cell->id == 0x0406 ||
-            // cell holds a formula:
-            //    0x06 -->   6 Formula (section 2.4.127) p309
-            //  0x0406 --> 1030 Formula (Apple Numbers Bug) via libxls
-            cell->id == 0x205 ||
-            // cell holds either Boolean or error:
-            //   0x205 -->  517 BoolErr (section 2.4.24) p216
-            cell->id == 0x0FD
-            // cell holds a string:
-            //   0x0FD -->  253 LabelSst (section 2.4.149) p325
+        if (cell->id == XLS_RECORD_MULRK || cell->id == XLS_RECORD_NUMBER ||
+            cell->id == XLS_RECORD_RK ||
+            cell->id == XLS_RECORD_LABELSST || cell->id == XLS_RECORD_LABEL ||
+            cell->id == XLS_RECORD_FORMULA ||  cell->id == XLS_RECORD_FORMULA_ALT ||
+            cell->id == XLS_RECORD_BOOLERR
         ) {
           cells_.push_back(cell);
         }

---FILE: src/endian.c---
@@ -112,8 +112,10 @@ void xlsConvertBiff(BIFF *b)
     b->type = xlsShortVal(b->type);
     b->id_make = xlsShortVal(b->id_make);
     b->year = xlsShortVal(b->year);
-    b->flags = xlsIntVal(b->flags);
-    b->min_ver = xlsIntVal(b->min_ver);
+    if (b->ver == 0x600) {
+      b->flags = xlsIntVal(b->flags);
+      b->min_ver = xlsIntVal(b->min_ver);
+    }
 }
 
 void xlsConvertWindow(WIND1 *w)

---FILE: src/libxls/xlstool.h---
@@ -48,6 +48,6 @@ extern void xls_showCell(struct st_cell_data* cell);
 extern void xls_showFont(struct st_font_data* font);
 extern void xls_showXF(XF8* xf);
 extern void xls_showFormat(struct st_format_data* format);
-extern BYTE* xls_getfcell(xlsWorkBook* pWB,struct st_cell_data* cell,DWORD *label);
+extern BYTE* xls_getfcell(xlsWorkBook* pWB,struct st_cell_data* cell,BYTE *label);
 extern char* xls_getCSS(xlsWorkBook* pWB);
 extern void xls_showBOF(BOF* bof);

---FILE: src/xls.c---
@@ -530,7 +530,7 @@ struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
         break;
     case XLS_RECORD_LABELSST:
     case XLS_RECORD_LABEL:
-		cell->str=xls_getfcell(pWS->workbook,cell,(DWORD_UA *)&((LABEL*)buf)->value);
+		cell->str=xls_getfcell(pWS->workbook,cell,(BYTE *)&((LABEL*)buf)->value);
 		sscanf((char *)cell->str, ""%d"", &cell->l);
 		sscanf((char *)cell->str, ""%lf"", &cell->d);
 		break;

---FILE: src/xlstool.c---
@@ -626,7 +626,7 @@ void xls_showXF(XF8* xf)
     printf(""GroundColor: 0x%x\n"",xf->groundcolor);
 }
 
-BYTE *xls_getfcell(xlsWorkBook* pWB,struct st_cell_data* cell,DWORD *label)
+BYTE *xls_getfcell(xlsWorkBook* pWB,struct st_cell_data* cell,BYTE *label)
 {
     struct st_xf_data *xf;
 	WORD	len;
@@ -646,7 +646,7 @@ BYTE *xls_getfcell(xlsWorkBook* pWB,struct st_cell_data* cell,DWORD *label)
         break;
     case XLS_RECORD_LABEL:
 		len = xlsShortVal(*label);
-        label++;
+        label += 2;
 		if(pWB->is5ver) {
 			asprintf(&ret,""%.*s"", len, (char *)label);
 			//printf(""Found BIFF5 string of len=%d \""%s\""\n"", len, ret);

---FILE: tests/BIFF5-LABEL-record-string-read-mac-10-11.supp---
@@ -0,0 +1,160 @@
+{
+   <r-or-os-01>
+   Memcheck:Cond
+   fun:bcmp
+   fun:_ZN16ImageLoaderMachO18validateFirstPagesEPK21linkedit_data_commandiPKhmxRKN11ImageLoader11LinkContextE
+   fun:_ZN26ImageLoaderMachOCompressed19instantiateFromFileEPKciPKhmyyRK4statjjPK21linkedit_data_commandPK23encryption_info_commandRKN11ImageLoader11LinkContextE
+   fun:_ZN16ImageLoaderMachO19instantiateFromFileEPKciPKhyyRK4statRKN11ImageLoader11LinkContextE
+   fun:_ZN4dyldL10loadPhase6EiRK4statPKcRKNS_11LoadContextE
+   fun:_ZN4dyldL10loadPhase5EPKcS1_RKNS_11LoadContextEPNSt3__16vectorIS1_NS5_9allocatorIS1_EEEE
+   fun:_ZN4dyldL10loadPhase4EPKcS1_RKNS_11LoadContextEPNSt3__16vectorIS1_NS5_9allocatorIS1_EEEE
+   fun:_ZN4dyldL10loadPhase3EPKcS1_RKNS_11LoadContextEPNSt3__16vectorIS1_NS5_9allocatorIS1_EEEE
+   fun:_ZN4dyldL10loadPhase1EPKcS1_RKNS_11LoadContextEPNSt3__16vectorIS1_NS5_9allocatorIS1_EEEE
+   fun:_ZN4dyldL10loadPhase0EPKcS1_RKNS_11LoadContextEPNSt3__16vectorIS1_NS5_9allocatorIS1_EEEE
+   fun:_ZN4dyld4loadEPKcRKNS_11LoadContextE
+   fun:_ZN4dyldL14libraryLocatorEPKcbS1_PKN11ImageLoader10RPathChainE
+}
+{
+   <r-or-os-02>
+   Memcheck:Value8
+   fun:bcmp
+   fun:_ZN16ImageLoaderMachO18validateFirstPagesEPK21linkedit_data_commandiPKhmxRKN11ImageLoader11LinkContextE
+   fun:_ZN26ImageLoaderMachOCompressed19instantiateFromFileEPKciPKhmyyRK4statjjPK21linkedit_data_commandPK23encryption_info_commandRKN11ImageLoader11LinkContextE
+   fun:_ZN16ImageLoaderMachO19instantiateFromFileEPKciPKhyyRK4statRKN11ImageLoader11LinkContextE
+   fun:_ZN4dyldL10loadPhase6EiRK4statPKcRKNS_11LoadContextE
+   fun:_ZN4dyldL10loadPhase5EPKcS1_RKNS_11LoadContextEPNSt3__16vectorIS1_NS5_9allocatorIS1_EEEE
+   fun:_ZN4dyldL10loadPhase4EPKcS1_RKNS_11LoadContextEPNSt3__16vectorIS1_NS5_9allocatorIS1_EEEE
+   fun:_ZN4dyldL10loadPhase3EPKcS1_RKNS_11LoadContextEPNSt3__16vectorIS1_NS5_9allocatorIS1_EEEE
+   fun:_ZN4dyldL10loadPhase1EPKcS1_RKNS_11LoadContextEPNSt3__16vectorIS1_NS5_9allocatorIS1_EEEE
+   fun:_ZN4dyldL10loadPhase0EPKcS1_RKNS_11LoadContextEPNSt3__16vectorIS1_NS5_9allocatorIS1_EEEE
+   fun:_ZN4dyld4loadEPKcRKNS_11LoadContextE
+   fun:_ZN4dyldL14libraryLocatorEPKcbS1_PKN11ImageLoader10RPathChainE
+}
+{
+   <r-or-os-03>
+   Memcheck:Cond
+   fun:_ZN16ImageLoaderMachO18validateFirstPagesEPK21linkedit_data_commandiPKhmxRKN11ImageLoader11LinkContextE
+   fun:_ZN26ImageLoaderMachOCompressed19instantiateFromFileEPKciPKhmyyRK4statjjPK21linkedit_data_commandPK23encryption_info_commandRKN11ImageLoader11LinkContextE
+   fun:_ZN16ImageLoaderMachO19instantiateFromFileEPKciPKhyyRK4statRKN11ImageLoader11LinkContextE
+   fun:_ZN4dyldL10loadPhase6EiRK4statPKcRKNS_11LoadContextE
+   fun:_ZN4dyldL10loadPhase5EPKcS1_RKNS_11LoadContextEPNSt3__16vectorIS1_NS5_9allocatorIS1_EEEE
+   fun:_ZN4dyldL10loadPhase4EPKcS1_RKNS_11LoadContextEPNSt3__16vectorIS1_NS5_9allocatorIS1_EEEE
+   fun:_ZN4dyldL10loadPhase3EPKcS1_RKNS_11LoadContextEPNSt3__16vectorIS1_NS5_9allocatorIS1_EEEE
+   fun:_ZN4dyldL10loadPhase1EPKcS1_RKNS_11LoadContextEPNSt3__16vectorIS1_NS5_9allocatorIS1_EEEE
+   fun:_ZN4dyldL10loadPhase0EPKcS1_RKNS_11LoadContextEPNSt3__16vectorIS1_NS5_9allocatorIS1_EEEE
+   fun:_ZN4dyld4loadEPKcRKNS_11LoadContextE
+   fun:_ZN4dyldL14libraryLocatorEPKcbS1_PKN11ImageLoader10RPathChainE
+   fun:_ZN11ImageLoader22recursiveLoadLibrariesERKNS_11LinkContextEbRKNS_10RPathChainE
+}
+{
+   <readxl-01-strnlen>
+   Memcheck:Cond
+   fun:strnlen
+   fun:__vfprintf
+   fun:__v2printf
+   fun:_vasprintf
+   fun:asprintf
+   fun:xls_getfcell
+   fun:xls_addCell
+   fun:xls_parseWorkSheet
+   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiii
+   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiii
+   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_NS_6vectorIS5_NS3_IS5_EEEEiii
+   fun:readxl_read_xls_
+}
+{
+   <readxl-02-vfprintf>
+   Memcheck:Cond
+   fun:__vfprintf
+   fun:__v2printf
+   fun:_vasprintf
+   fun:asprintf
+   fun:xls_getfcell
+   fun:xls_addCell
+   fun:xls_parseWorkSheet
+   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiii
+   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiii
+   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_NS_6vectorIS5_NS3_IS5_EEEEiii
+   fun:readxl_read_xls_
+   fun:R_doDotCall
+}
+{
+   <readxl-03-sfvwrite>
+   Memcheck:Cond
+   fun:__sfvwrite
+   fun:__vfprintf
+   fun:__v2printf
+   fun:_vasprintf
+   fun:asprintf
+   fun:xls_getfcell
+   fun:xls_addCell
+   fun:xls_parseWorkSheet
+   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiii
+   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiii
+   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_NS_6vectorIS5_NS3_IS5_EEEEiii
+   fun:readxl_read_xls_
+}
+{
+   <readxl-04-haswell-cond>
+   Memcheck:Cond
+   fun:_platform_memmove$VARIANT$Haswell
+   fun:__sfvwrite
+   fun:__vfprintf
+   fun:__v2printf
+   fun:_vasprintf
+   fun:asprintf
+   fun:xls_getfcell
+   fun:xls_addCell
+   fun:xls_parseWorkSheet
+   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiii
+   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiii
+   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_NS_6vectorIS5_NS3_IS5_EEEEiii
+}
+{
+   <readxl-05-haswell-value8>
+   Memcheck:Value8
+   fun:_platform_memmove$VARIANT$Haswell
+   fun:__sfvwrite
+   fun:__vfprintf
+   fun:__v2printf
+   fun:_vasprintf
+   fun:asprintf
+   fun:xls_getfcell
+   fun:xls_addCell
+   fun:xls_parseWorkSheet
+   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiii
+   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiii
+   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_NS_6vectorIS5_NS3_IS5_EEEEiii
+}
+{
+   <readxl-06-vasprintf-cond>
+   Memcheck:Cond
+   fun:_vasprintf
+   fun:asprintf
+   fun:xls_getfcell
+   fun:xls_addCell
+   fun:xls_parseWorkSheet
+   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiii
+   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiii
+   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_NS_6vectorIS5_NS3_IS5_EEEEiii
+   fun:readxl_read_xls_
+   fun:R_doDotCall
+   fun:do_dotcall
+   fun:Rf_eval
+}
+{
+   <readxl-07-vasprintf-value8>
+   Memcheck:Value8
+   fun:_vasprintf
+   fun:asprintf
+   fun:xls_getfcell
+   fun:xls_addCell
+   fun:xls_parseWorkSheet
+   fun:_ZN12XlsWorkSheetC2E11XlsWorkBookiii
+   fun:_ZN12XlsWorkSheetC1E11XlsWorkBookiii
+   fun:_Z9read_xls_NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEiN4Rcpp12RObject_ImplINS6_15PreserveStorageEEES9_NS_6vectorIS5_NS3_IS5_EEEEiii
+   fun:readxl_read_xls_
+   fun:R_doDotCall
+   fun:do_dotcall
+   fun:Rf_eval
+}

---FILE: tests/testthat/test-compatibility.R---
@@ -29,3 +29,17 @@ test_that(""we can finally read Ekaterinburg"", {
   )
   expect_identical(ek[[1,2]], ""27.05.2004"")
 })
+
+## #309
+## A BIFF5 xls from an unspecified 3rd party tool, that uses a very antiquated
+## practice of storing text strings in LABEL records.
+## Exposed the fact that the libxls patch in #293 is beneficial for indexing
+## the shared string table, but causes difficulty when parsing LABEL records.
+## We have a small patch now in libxls for that.
+test_that(""we can read the BIFF5, LABEL record sheet"", {
+  df <- read_excel(test_sheet(""biff5-label-records.xls""), skip = 2,
+                   na = c("""", ""--""))
+  expect_identical(dim(df), c(14L, 4L))
+  expect_identical(df$Date[c(1, 14)], c(""21/01/2017"", ""21/01/2017""))
+  expect_identical(df$Time[c(1, 14)], c(""01:00"", ""14:00""))
+})",True,False,Implementation / Logic,6
tidyverse,readxl,9814256bc3caf6ccf9c8217f1f98a1cbf4105560,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-03-27T17:42:56Z,GitHub,noreply@github.com,2017-03-27T17:42:56Z,Improve coercion of numbers to text in xls; fixes #298 (#305),src/XlsCell.h;tests/testthat/sheets/types.xls;tests/testthat/sheets/types.xlsx;tests/testthat/test-col-types.R,False,True,True,False,15,1,16,"---FILE: src/XlsCell.h---
@@ -223,7 +223,19 @@ class XlsCell {
       // not ideal for a date but will have to do ... one day: asDateString()?
     case CELL_NUMERIC: {
       std::ostringstream strs;
-      strs << cell_->d;
+      // if cell_->d is integer-ish, need to:
+      //   * prevent use of scientific notation
+      //   * prevent gratuitous zeros after decimal mark
+      // GOOD: ""36436153""
+      //  BAD: ""3.64362e+07""
+      //  BAD: ""36436153.000000""
+      // examples: social security or student number
+      double intpart;
+      if (std::modf(cell_->d, &intpart) == 0.0) {
+        strs << std::fixed << (int)cell_->d;
+      } else {
+        strs << cell_->d;
+      }
       std::string out_string = strs.str();
       return out_string;
     }

---FILE: tests/testthat/test-col-types.R---
@@ -230,12 +230,14 @@ test_that(""contaminated, explicit text is read as text"", {
   expect_is(df$text, ""character"")
   expect_false(anyNA(df$explanation != ""blank""))
   expect_identical(df$text[df$explanation == ""floating point""], ""1.3"")
+  expect_identical(df$text[df$explanation == ""student number""], ""36436153"")
 
   ## xlsx
   df <- read_excel(test_sheet(""types.xlsx""), sheet = ""text_coercion"",
                    col_types = c(""text"", ""text""))
   expect_is(df$text, ""character"")
   expect_false(anyNA(df$explanation != ""blank""))
   expect_identical(df$text[df$explanation == ""floating point""], ""1.3"")
+  expect_identical(df$text[df$explanation == ""student number""], ""36436153"")
 
 })",True,False,Data / Input Handling,3
tidyverse,readxl,9e86a963a14445a6dc005af79eb4dc73b8e59712,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-03-25T05:34:08Z,GitHub,noreply@github.com,2017-03-25T05:34:08Z,Close xls workbooks properly; fixes #300 (#302),src/XlsWorkBook.h;src/XlsWorkSheet.h,False,False,False,False,6,4,10,"---FILE: src/XlsWorkBook.h---
@@ -50,7 +50,7 @@ class XlsWorkBook {
       }
     }
 
-    xls_close_WB(pWB_);
+    xls::xls_close_WB(pWB_);
   }
 
   const std::string& path() const{

---FILE: src/XlsWorkSheet.h---
@@ -9,6 +9,7 @@
 
 class XlsWorkSheet {
   XlsWorkBook wb_;
+  xls::xlsWorkBook* pWB_;
   xls::xlsWorkSheet* pWS_;
   std::set<int> dateStyles_;
   std::vector<XlsCell> cells_;
@@ -28,8 +29,8 @@ class XlsWorkSheet {
     sheetName_ = wb.sheets()[sheet_i];
 
     std::string path = wb_.path();
-    xls::xlsWorkBook* pWB = xls::xls_open(path.c_str(), ""UTF-8"");
-    pWS_ = xls_getWorkSheet(pWB, sheet_i);
+    pWB_ = xls::xls_open(path.c_str(), ""UTF-8"");
+    pWS_ = xls_getWorkSheet(pWB_, sheet_i);
     if (pWS_ == NULL) {
       Rcpp::stop(""Sheet '%s' (position %d): cannot be opened"",
                  sheetName_, sheet_i + 1);
@@ -43,7 +44,8 @@ class XlsWorkSheet {
 
   ~XlsWorkSheet() {
     try {
-      xls_close_WS(pWS_);
+      xls::xls_close_WS(pWS_);
+      xls::xls_close_WB(pWB_);
     } catch(...) {}
   }
 ",False,False,Implementation / Logic,3
tidyverse,readxl,7f9fee51f3a0de5e46654e17309b35c7d461e1a8,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-03-21T22:33:12Z,GitHub,noreply@github.com,2017-03-21T22:33:12Z,Make workbook rels parsing robust to nonstandard path prefix; fixes #294 (#296),src/XlsxWorkBook.h;tests/testthat/sheets/Ekaterinburg_IP_9.xlsx;tests/testthat/test-compatibility.R,False,True,True,False,19,1,20,"---FILE: src/XlsxWorkBook.h---
@@ -73,7 +73,12 @@ class XlsxWorkBook {
         rapidxml::xml_attribute<>* id = relationship->first_attribute(""Id"");
         rapidxml::xml_attribute<>* target = relationship->first_attribute(""Target"");
         if (id != NULL && target != NULL) {
-          target_[id->value()] = target->value();
+          static const std::string prefix = ""/xl/"";
+          std::string target_value = target->value();
+          if (target_value.substr(0, prefix.size()) == prefix) {
+            target_value = target_value.substr(prefix.size());
+          }
+          target_[id->value()] = target_value;
         }
       }
     }

---FILE: tests/testthat/test-compatibility.R---
@@ -16,3 +16,16 @@ test_that(""can tolerate xls that underreports number of columns"", {
   df <- read_excel(test_sheet(""mtcars.xls""))
   expect_identical(ncol(df), ncol(mtcars))
 })
+
+## #80
+## The infamous Ekaterinburg sheet is written by an unspecified BI tool.
+## Tricky for several reasons:
+##   * Worksheet target paths demand full lookup (#233)
+##   * Worksheet target paths are prefixed with `/xl/` (#294)
+##   * Nonstandard XML namespace prefixes (#295)
+test_that(""we can finally read Ekaterinburg"", {
+  expect_silent(
+    ek <- read_excel(test_sheet(""Ekaterinburg_IP_9.xlsx""), skip = 2)
+  )
+  expect_identical(ek[[1,2]], ""27.05.2004"")
+})",True,False,Implementation / Logic,6
tidyverse,readxl,da6f8be2cf5b006c794fcb67f3d36caae55c8c78,jennybc,jenny@stat.ubc.ca,2017-03-20T22:44:35Z,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-03-21T14:36:08Z,"Use rapidxml parsing flag to strip namespace prefixes; fixes #80, fixes #202, fixes #268",NEWS.md;src/XlsxWorkBook.h;src/XlsxWorkSheet.h;src/zip.cpp;tests/testthat/sheets/nonstandard-xml-ns-prefix.xlsx;tests/testthat/test-xml-namespaces.R,False,True,True,False,35,8,43,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # readxl 0.1.1.9000
 
+* Nonstandard XML namespace prefixes in xlsx: Some 3rd party tools use different XML namespace prefixes than MS Excel. These are now stripped from element names and attributes during parsing. (#295, #268, #202, #80 @jennybc)
+
 * The [Lotus 1-2-3 leap year bug](https://support.microsoft.com/en-us/help/214326/excel-incorrectly-assumes-that-the-year-1900-is-a-leap-year) is accounted for. Date-times prior to March 1, 1900 import correctly. Date-times on the non-existent leap day February 29, 1900 import as NA and throw a warning. (#264, #148, #292 @jennybc)
 
 * Selective column type guessing: `col_types` now accepts `""guess""` to allow user to specify some column types, while allowing others to be guessed (#286 @jennybc)

---FILE: src/XlsxWorkBook.h---
@@ -21,7 +21,7 @@ class XlsxWorkBook {
     void parse_workbook(const std::string& path) {
       std::string workbookXml = zip_buffer(path, ""xl/workbook.xml"");
       rapidxml::xml_document<> workbook;
-      workbook.parse<0>(&workbookXml[0]);
+      workbook.parse<rapidxml::parse_strip_xml_namespaces>(&workbookXml[0]);
 
       rapidxml::xml_node<>* root = workbook.first_node(""workbook"");
       if (root == NULL) {
@@ -44,7 +44,7 @@ class XlsxWorkBook {
         rapidxml::xml_attribute<>* name = sheet->first_attribute(""name"");
         names_[i] = (name != NULL) ? Rf_mkCharCE(name->value(), CE_UTF8) : NA_STRING;
 
-        rapidxml::xml_attribute<>* id = sheet->first_attribute(""r:id"");
+        rapidxml::xml_attribute<>* id = sheet->first_attribute(""id"");
         id_[i] = (id != NULL) ? Rf_mkCharCE(id->value(), CE_UTF8) : NA_STRING;
 
         i++;
@@ -61,7 +61,7 @@ class XlsxWorkBook {
     void parse_workbook_rels(const std::string& path) {
       std::string rels_xml_file = zip_buffer(path, ""xl/_rels/workbook.xml.rels"");
       rapidxml::xml_document<> rels_xml;
-      rels_xml.parse<0>(&rels_xml_file[0]);
+      rels_xml.parse<rapidxml::parse_strip_xml_namespaces>(&rels_xml_file[0]);
 
       rapidxml::xml_node<>* relationships = rels_xml.first_node(""Relationships"");
       if (relationships == NULL) {
@@ -163,7 +163,7 @@ class XlsxWorkBook {
 
     std::string sharedStringsXml = zip_buffer(path_, ""xl/sharedStrings.xml"");
     rapidxml::xml_document<> sharedStrings;
-    sharedStrings.parse<0>(&sharedStringsXml[0]);
+    sharedStrings.parse<rapidxml::parse_strip_xml_namespaces>(&sharedStringsXml[0]);
 
     rapidxml::xml_node<>* sst = sharedStrings.first_node(""sst"");
     if (sst == NULL) {
@@ -188,7 +188,7 @@ class XlsxWorkBook {
   void cacheDateStyles() {
     std::string stylesXml = zip_buffer(path_, ""xl/styles.xml"");
     rapidxml::xml_document<> styles;
-    styles.parse<0>(&stylesXml[0]);
+    styles.parse<rapidxml::parse_strip_xml_namespaces>(&stylesXml[0]);
 
     rapidxml::xml_node<>* styleSheet = styles.first_node(""styleSheet"");
     if (styleSheet == NULL) {
@@ -232,7 +232,7 @@ class XlsxWorkBook {
   bool uses1904() {
     std::string workbookXml = zip_buffer(path_, ""xl/workbook.xml"");
     rapidxml::xml_document<> workbook;
-    workbook.parse<0>(&workbookXml[0]);
+    workbook.parse<rapidxml::parse_strip_xml_namespaces>(&workbookXml[0]);
 
     rapidxml::xml_node<>* root = workbook.first_node(""workbook"");
     if (root == NULL) {

---FILE: src/XlsxWorkSheet.h---
@@ -39,7 +39,7 @@ class XlsxWorkSheet {
     sheetName_ = wb.sheets()[sheet_i];
     std::string sheetPath = wb.sheetPath(sheet_i);
     sheet_ = zip_buffer(wb.path(), sheetPath);
-    sheetXml_.parse<0>(&sheet_[0]);
+    sheetXml_.parse<rapidxml::parse_strip_xml_namespaces>(&sheet_[0]);
 
     rootNode = sheetXml_.first_node(""worksheet"");
     if (rootNode == NULL) {

---FILE: src/zip.cpp---
@@ -33,7 +33,7 @@ std::string xml_print(std::string xml) {
   rapidxml::xml_document<> doc;
 
   xml.push_back('\0');
-  doc.parse<0>(&xml[0]);
+  doc.parse<rapidxml::parse_strip_xml_namespaces>(&xml[0]);
 
   std::string s;
   rapidxml::print(std::back_inserter(s), doc, 0);

---FILE: tests/testthat/test-xml-namespaces.R---
@@ -0,0 +1,25 @@
+context(""XML namespaces"")
+
+## #268, #202, #80
+## what is special about nonstandard-xml-ns-prefix.xlsx?
+## note `ns:id=""rId3""` vs `r:id=""rId3""`
+## `ns:id` has been seen in xlsx written by 3rd party tools
+## `r:id` is typical of files written by Excel
+# <workbook xmlns=""http://schemas.openxmlformats.org/spreadsheetml/2006/main"">
+#   <bookViews>
+#   <workbookView/>
+#   </bookViews>
+#   <sheets>
+#   <sheet xmlns:ns=""http://schemas.openxmlformats.org/officeDocument/2006/relationships"" name=""Sheet1"" sheetId=""1"" ns:id=""rId3""/>
+#   </sheets>
+#   <definedNames/>
+# </workbook>
+
+test_that(""XML namespace prefixes are stripped"", {
+  df <- read_excel(test_sheet(""nonstandard-xml-ns-prefix.xlsx""))
+  exp <- tibble::tibble(
+    a = c(1, 2),
+    b = c(3, 4)
+  )
+  expect_identical(df, exp)
+})",True,False,Dependency / Package,7
tidyverse,readxl,963b1cf335247ef7057ce3c6bf978203fe7d270d,jennybc,jenny@stat.ubc.ca,2017-03-20T22:44:08Z,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-03-21T14:36:08Z,"Patch rapidxml to strip namespace prefixes from element names and attributes

Using code from a patch by Dan Posluns found here and included below:
https://sourceforge.net/p/rapidxml/patches/5/

Index: rapidxml.hpp
===================================================================
250a251,259
>     //! Parse flag instructing the parser to strip any XML namespace identifiers from element names and attributes.
>     //! Turning this flag on will remove the namespace prefix and colon from all tags and attributes.
>     //! By default, XML namespace identifiers are left as part of the names of tags and attributes.
>     //! This flag does not cause the parser to modify source text.
>     //! Can be combined with other flags by use of | operator.
>     //! <br><br>
>     //! See xml_document::parse() function.
>     const int parse_strip_xml_namespaces = 0x1000;
>
1510a1520,1537
> 		// Detect element XML namespace prefix character
> 		struct element_namespace_prefix_pred
> 		{
> 			static unsigned char test(Ch ch)
> 			{
>                 return ch != ':' && internal::lookup_tables<0>::lookup_node_name[static_cast<unsigned char>(ch)];
> 			}
> 		};
>
> 		// Detect attribute XML namespace prefix character
> 		struct attribute_namespace_prefix_pred
> 		{
> 			static unsigned char test(Ch ch)
> 			{
>                 return ch != ':' && internal::lookup_tables<0>::lookup_attribute_name[static_cast<unsigned char>(ch)];
> 			}
> 		};
>
1567a1595,1596
> 		//
>
2048a2078,2084
> 			if (Flags & parse_strip_xml_namespaces)
> 			{
> 				Ch *saved_name = name;
> 				skip<element_namespace_prefix_pred, Flags>(name);
> 				if (name++ == text)
> 					name = saved_name;
> 			}
2252a2289,2295
> 				if (Flags & parse_strip_xml_namespaces)
> 				{
> 					Ch *saved_name = name;
> 					skip<attribute_namespace_prefix_pred, Flags>(name);
> 					if (name++ == text)
> 						name = saved_name;
> 				}",src/rapidxml.h,False,False,False,False,46,0,46,"---FILE: src/rapidxml.h---
@@ -246,6 +246,16 @@ namespace rapidxml
     //! See xml_document::parse() function.
     const int parse_normalize_whitespace = 0x800;
 
+    // part of the readxl namespace-prefix-stripping patch
+    //! Parse flag instructing the parser to strip any XML namespace identifiers from element names and attributes.
+    //! Turning this flag on will remove the namespace prefix and colon from all tags and attributes.
+    //! By default, XML namespace identifiers are left as part of the names of tags and attributes.
+    //! This flag does not cause the parser to modify source text.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_strip_xml_namespaces = 0x1000;
+
     // Compound flags
     
     //! Parse flags which represent default behaviour of the parser. 
@@ -1506,6 +1516,26 @@ namespace rapidxml
             }
         };
 
+        // part of the readxl namespace-prefix-stripping patch
+        // Detect element XML namespace prefix character
+        struct element_namespace_prefix_pred
+        {
+          static unsigned char test(Ch ch)
+          {
+            return ch != ':' && internal::lookup_tables<0>::lookup_node_name[static_cast<unsigned char>(ch)];
+          }
+        };
+
+        // part of the readxl namespace-prefix-stripping patch
+        // Detect attribute XML namespace prefix character
+        struct attribute_namespace_prefix_pred
+        {
+          static unsigned char test(Ch ch)
+          {
+            return ch != ':' && internal::lookup_tables<0>::lookup_attribute_name[static_cast<unsigned char>(ch)];
+          }
+        };
+
         // Insert coded character, using UTF8 or 8-bit ASCII
         template<int Flags>
         static void insert_coded_character(Ch *&text, unsigned long code)
@@ -2044,6 +2074,14 @@ namespace rapidxml
             skip<node_name_pred, Flags>(text);
             if (text == name)
                 RAPIDXML_PARSE_ERROR(""expected element name"", text);
+            // part of the readxl namespace-prefix-stripping patch
+            if (Flags & parse_strip_xml_namespaces)
+            {
+              Ch *saved_name = name;
+              skip<element_namespace_prefix_pred, Flags>(name);
+              if (name++ == text)
+                name = saved_name;
+            }
             element->name(name, text - name);
             
             // Skip whitespace between element name and attributes or >
@@ -2245,6 +2283,14 @@ namespace rapidxml
                 skip<attribute_name_pred, Flags>(text);
                 if (text == name)
                     RAPIDXML_PARSE_ERROR(""expected attribute name"", name);
+                // part of the readxl namespace-prefix-stripping patch
+                if (Flags & parse_strip_xml_namespaces)
+                {
+                  Ch *saved_name = name;
+                  skip<attribute_namespace_prefix_pred, Flags>(name);
+                  if (name++ == text)
+                    name = saved_name;
+                }
 
                 // Create new attribute
                 xml_attribute<Ch> *attribute = this->allocate_attribute();",False,False,Dependency / Package,4
tidyverse,readxl,e5d1f92e7d60358f9753ac963416ce81f7a54152,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-03-19T15:07:33Z,GitHub,noreply@github.com,2017-03-19T15:07:33Z,Use uint32_t to index into xls string table; fixes #129 (#293),src/libxls/xlstool.h;src/xls.c;src/xlstool.c,False,False,False,False,4,4,8,"---FILE: src/libxls/xlstool.h---
@@ -48,6 +48,6 @@ extern void xls_showCell(struct st_cell_data* cell);
 extern void xls_showFont(struct st_font_data* font);
 extern void xls_showXF(XF8* xf);
 extern void xls_showFormat(struct st_format_data* format);
-extern BYTE* xls_getfcell(xlsWorkBook* pWB,struct st_cell_data* cell,WORD *label);
+extern BYTE* xls_getfcell(xlsWorkBook* pWB,struct st_cell_data* cell,DWORD *label);
 extern char* xls_getCSS(xlsWorkBook* pWB);
 extern void xls_showBOF(BOF* bof);

---FILE: src/xls.c---
@@ -530,7 +530,7 @@ struct st_cell_data *xls_addCell(xlsWorkSheet* pWS,BOF* bof,BYTE* buf)
         break;
     case XLS_RECORD_LABELSST:
     case XLS_RECORD_LABEL:
-		cell->str=xls_getfcell(pWS->workbook,cell,(WORD_UA *)&((LABEL*)buf)->value);
+		cell->str=xls_getfcell(pWS->workbook,cell,(DWORD_UA *)&((LABEL*)buf)->value);
 		sscanf((char *)cell->str, ""%d"", &cell->l);
 		sscanf((char *)cell->str, ""%lf"", &cell->d);
 		break;

---FILE: src/xlstool.c---
@@ -626,7 +626,7 @@ void xls_showXF(XF8* xf)
     printf(""GroundColor: 0x%x\n"",xf->groundcolor);
 }
 
-BYTE *xls_getfcell(xlsWorkBook* pWB,struct st_cell_data* cell,WORD *label)
+BYTE *xls_getfcell(xlsWorkBook* pWB,struct st_cell_data* cell,DWORD *label)
 {
     struct st_xf_data *xf;
 	WORD	len;
@@ -638,7 +638,7 @@ BYTE *xls_getfcell(xlsWorkBook* pWB,struct st_cell_data* cell,WORD *label)
     {
     case XLS_RECORD_LABELSST:
 		//printf(""WORD: %u short: %u str: %s\n"", *label, xlsShortVal(*label), pWB->sst.string[xlsShortVal(*label)].str );
-        asprintf(&ret,""%s"",pWB->sst.string[xlsShortVal(*label)].str);
+        asprintf(&ret,""%s"",pWB->sst.string[xlsIntVal(*label)].str);
         break;
     case XLS_RECORD_BLANK:
     case XLS_RECORD_MULBLANK:",False,False,Rendering / Conversion,0
tidyverse,readxl,c9a54ae9ce0394808f6d22e8ef1a7a647b2d92bb,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-03-13T18:08:41Z,GitHub,noreply@github.com,2017-03-13T18:08:41Z,"Account for leap year bug; fixes #264 (#292)

* Account for leap year bug; fixes #264

* Put leap day adjustment inside POSIXctFromSerial",DESCRIPTION;NEWS.md;src/XlsCell.h;src/XlsWorkBook.h;src/XlsWorkSheet.h;src/XlsxCell.h;src/XlsxWorkBook.h;src/XlsxWorkSheet.h;src/utils.h;tests/testthat/sheets/dates-leap-year-1900-xls.xls;tests/testthat/sheets/dates-leap-year-1900-xlsx.xlsx;tests/testthat/test-dates.R,False,True,True,False,95,25,120,"---FILE: DESCRIPTION---
@@ -27,6 +27,6 @@ Suggests:
     rprojroot (>= 1.1),
     testthat
 Roxygen: list(markdown = TRUE)
-RoxygenNote: 6.0.0.9000
+RoxygenNote: 6.0.1.9000
 URL: https://github.com/tidyverse/readxl
 BugReports: https://github.com/tidyverse/readxl/issues

---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # readxl 0.1.1.9000
 
+* The [Lotus 1-2-3 leap year bug](https://support.microsoft.com/en-us/help/214326/excel-incorrectly-assumes-that-the-year-1900-is-a-leap-year) is accounted for. Date-times prior to March 1, 1900 import correctly. Date-times on the non-existent leap day February 29, 1900 import as NA and throw a warning. (#264, #148, #292 @jennybc)
+
 * Selective column type guessing: `col_types` now accepts `""guess""` to allow user to specify some column types, while allowing others to be guessed (#286 @jennybc)
 
 * Numeric data that appears in a `""date""` column is coerced to a date. Also throws a warning. (#277, #266 @jennybc)

---FILE: src/XlsCell.h---
@@ -277,7 +277,7 @@ class XlsCell {
     }
   }
 
-  double asDate(int offset) const {
+  double asDate(bool is1904) const {
     switch(type_) {
 
     case CELL_UNKNOWN:
@@ -288,7 +288,7 @@ class XlsCell {
 
     case CELL_DATE:
     case CELL_NUMERIC:
-      return dateRound((cell_->d - offset) * 86400);
+      return POSIXctFromSerial(cell_->d, is1904);
     }
   }
 

---FILE: src/XlsWorkBook.h---
@@ -16,7 +16,7 @@ class XlsWorkBook {
 
   // common to Xls[x]WorkBook
   std::string path_;
-  double offset_;
+  bool is1904_;
   std::set<int> dateStyles_;
 
   // kept as data + accessor in XlsWorkBook vs. member function in XlsxWorkBook
@@ -39,7 +39,7 @@ class XlsWorkBook {
       sheets_[i] = Rf_mkCharCE((char*) pWB_->sheets.sheet[i].name, CE_UTF8);
     }
 
-    offset_ = dateOffset(pWB_->is1904);
+    is1904_ = pWB_->is1904;
 
     int n_formats = pWB_->formats.count;
     for (int i = 0; i < n_formats; ++i) {
@@ -65,8 +65,8 @@ class XlsWorkBook {
     return sheets_;
   }
 
-  double offset() const {
-    return offset_;
+  bool is1904() const {
+    return is1904_;
   }
 
   const std::set<int>& dateStyles() const {

---FILE: src/XlsWorkSheet.h---
@@ -205,7 +205,7 @@ class XlsWorkSheet {
                         i + 1, j + 1,
                         xcell->asStdString());
         }
-        REAL(col)[row] = xcell->asDate(wb_.offset());
+        REAL(col)[row] = xcell->asDate(wb_.is1904());
         break;
 
       case COL_NUMERIC:
@@ -261,7 +261,7 @@ class XlsWorkSheet {
           SET_VECTOR_ELT(col, row, Rf_ScalarLogical(xcell->asInteger()));
           break;
         case CELL_DATE: {
-          Rcpp::RObject cell_val = Rf_ScalarReal(xcell->asDate(wb_.offset()));
+          Rcpp::RObject cell_val = Rf_ScalarReal(xcell->asDate(wb_.is1904()));
           cell_val.attr(""class"") = Rcpp::CharacterVector::create(""POSIXct"", ""POSIXt"");
           cell_val.attr(""tzone"") = ""UTC"";
           SET_VECTOR_ELT(col, row, cell_val);

---FILE: src/XlsxCell.h---
@@ -255,7 +255,7 @@ class XlsxCell {
     }
   }
 
-  double asDate(int offset) const {
+  double asDate(bool is1904) const {
     switch(type_) {
 
     case CELL_UNKNOWN:
@@ -268,7 +268,7 @@ class XlsxCell {
     case CELL_NUMERIC:
     {
       rapidxml::xml_node<>* v = cell_->first_node(""v"");
-      return dateRound((atof(v->value()) - offset) * 86400);
+      return POSIXctFromSerial(atof(v->value()), is1904);
     }
     }
   }

---FILE: src/XlsxWorkBook.h---
@@ -108,7 +108,7 @@ class XlsxWorkBook {
 
   // common to Xls[x]WorkBook
   std::string path_;
-  double offset_;
+  bool is1904_;
   std::set<int> dateStyles_;
 
   // specific to XlsxWorkBook
@@ -121,7 +121,7 @@ class XlsxWorkBook {
   path_(path),
   rel_(path)
   {
-    offset_ = dateOffset(is1904());
+    is1904_ = uses1904();
     cacheStringTable();
     cacheDateStyles();
   }
@@ -138,8 +138,8 @@ class XlsxWorkBook {
     return rel_.names();
   }
 
-  double offset() const {
-    return offset_;
+  bool is1904() const {
+    return is1904_;
   }
 
   const std::set<int>& dateStyles() const {
@@ -229,7 +229,7 @@ class XlsxWorkBook {
     }
   }
 
-  bool is1904() {
+  bool uses1904() {
     std::string workbookXml = zip_buffer(path_, ""xl/workbook.xml"");
     rapidxml::xml_document<> workbook;
     workbook.parse<0>(&workbookXml[0]);

---FILE: src/XlsxWorkSheet.h---
@@ -219,7 +219,7 @@ class XlsxWorkSheet {
           Rcpp::warning(""Expecting date in [%i, %i]: got '%s'"",
                         i + 1, j + 1, xcell->asStdString(wb_.stringTable()));
         }
-        REAL(col)[row] = xcell->asDate(wb_.offset());
+        REAL(col)[row] = xcell->asDate(wb_.is1904());
         break;
 
       case COL_NUMERIC:
@@ -278,7 +278,7 @@ class XlsxWorkSheet {
         }
         case CELL_DATE: {
           Rcpp::RObject cell_val =
-            Rf_ScalarReal(xcell->asDate(wb_.offset()));
+            Rf_ScalarReal(xcell->asDate(wb_.is1904()));
           cell_val.attr(""class"") = Rcpp::CharacterVector::create(""POSIXct"", ""POSIXt"");
           cell_val.attr(""tzone"") = ""UTC"";
           SET_VECTOR_ELT(col, row, cell_val);

---FILE: src/utils.h---
@@ -4,14 +4,35 @@
 #include <cerrno>
 #include ""StringSet.h""
 
+// The date offset needed to align Excel dates with R's use of 1970-01-01
+// depends on the ""date system"".
+//
+// xls ------------------------------------------------------------------------
+// Page and section numbers below refer to
+// [MS-XLS]: Excel Binary File Format (.xls) Structure
+// version, date, and download URL given in XlsCell.h
+//
+// 2.4.77 Date1904 p257 ... it boils down to a boolean
+// 0 --> 1900 date system
+// 1 --> 1904 date system
+//
+// xlsx ------------------------------------------------------------------------
+// Page and section numbers below refer to
+// ECMA-376
+// version, date, and download URL given in XlsxCell.h
+//
 // 18.2.28 workbookPr (Workbook Properties) p1582
-// date1904:
-// Value that indicates whether to use a 1900 or 1904 date system when
-// converting serial date-times in the workbook to dates.
-// A value of 1 or true indicates the workbook uses the 1904 date system.
-// A value of 0 or false indicates the workbook uses the 1900 date system. (See
-// 18.17.4.1 for the definition of the date systems.)
-// The default value for this attribute is false.
+// in xl/workbook.xml, node workbook, child node workbookPr
+// attribute date1904:
+// 0 or false --> 1900 date system
+// 1 or true --> 1904 date system (this is the default)
+//
+// 18.17.4.1 p2067 holds definition of the date systems
+//
+// Date systems ---------------------------------------------------------------
+// 1900 system: first possible date is 1900-01-01 00:00:00,
+//              which has serial value of **1**
+// 1904 system: origin 1904-01-01 00:00:00
 inline double dateOffset(bool is1904) {
   // as.numeric(as.Date(""1899-12-30""))
   // as.numeric(as.Date(""1904-01-01""))
@@ -29,6 +50,27 @@ inline double dateRound(double dttm) {
   return ms / 10000;
 }
 
+// this is even more horrible
+// correct for Excel's faithful re-implementation of the Lotus 1-2-3 bug,
+// in which February 29, 1900 is included in the date system, even though 1900
+// was not actually a leap year
+// https://support.microsoft.com/en-us/help/214326/excel-incorrectly-assumes-that-the-year-1900-is-a-leap-year
+// How we address this:
+// If date is *prior* to the non-existent leap day: add a day
+// If date is on the non-existent leap day: make negative and, in due course, NA
+// Otherwise: do nothing
+inline double POSIXctFromSerial(double xlDate, bool is1904) {
+  if (!is1904 && xlDate < 61) {
+    xlDate = (xlDate < 60) ? ++xlDate : -1;
+  }
+  if (xlDate < 0) {
+    Rcpp::warning(""NA inserted for impossible 1900-02-29 datetime"");
+    return NA_REAL;
+  } else {
+    return dateRound((xlDate - dateOffset(is1904)) * 86400);
+  }
+}
+
 // Simple parser: does not check that order of numbers and letters is correct
 inline std::pair<int, int> parseRef(const char* ref) {
   int col = 0, row = 0;

---FILE: tests/testthat/test-dates.R---
@@ -21,3 +21,29 @@ test_that(""date subsecond rounding works"", {
   df <- read_excel(test_sheet(""datetime-rounding.xls""))
   expect_identical(as.character(df$dttm), df$dttm_string)
 })
+
+## Lotus 1-2-3 leap year bug
+## #264, #148
+test_that(""we get correct dates prior to March 1, 1900, in 1900 date system"", {
+  ## xlsx
+  expect_warning(
+    df <- read_excel(test_sheet(""dates-leap-year-1900-xlsx.xlsx""),
+                     col_types = c(""date"", ""text"", ""logical"")),
+    ""NA inserted for impossible 1900-02-29 datetime""
+  )
+  dttms <- as.POSIXct(df$dttm_string, format = ""%Y-%m-%d %H:%M:%S"", tz = ""UTC"")
+  leap_day <- df$dttm_string == ""1900-02-29 08:00:00""
+  expect_identical(df$dttm[!leap_day], dttms[!leap_day])
+  expect_true(is.na(df$dttm[leap_day]))
+
+  ## xls
+  expect_warning(
+    df <- read_excel(test_sheet(""dates-leap-year-1900-xls.xls""),
+                     col_types = c(""date"", ""text"", ""logical"")),
+    ""NA inserted for impossible 1900-02-29 datetime""
+  )
+  dttms <- as.POSIXct(df$dttm_string, format = ""%Y-%m-%d %H:%M:%S"", tz = ""UTC"")
+  leap_day <- df$dttm_string == ""1900-02-29 08:00:00""
+  expect_identical(df$dttm[!leap_day], dttms[!leap_day])
+  expect_true(is.na(df$dttm[leap_day]))
+})",True,False,Documentation / Formatting,6
tidyverse,readxl,63ef215f57322dd5d7a27799a2a3fe463bd39fc7,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-03-12T04:49:20Z,GitHub,noreply@github.com,2017-03-12T04:49:20Z,"Date subsecond rounding; fixes #187 (#290)

* Date subsecond rounding; fixes #187

* Add a source for the rounding sol'n; re-save test sheets just to be safe",src/XlsCell.h;src/XlsxCell.h;src/utils.h;tests/testthat/sheets/datetime-rounding.xls;tests/testthat/sheets/datetime-rounding.xlsx;tests/testthat/test-dates.R,False,True,True,False,25,2,27,"---FILE: src/XlsCell.h---
@@ -5,6 +5,7 @@
 #include <libxls/xls.h>
 #include <libxls/xlstypes.h>
 #include ""ColSpec.h""
+#include ""utils.h""
 
 // Key reference for understanding the structure of the xls format is
 // [MS-XLS]: Excel Binary File Format (.xls) Structure
@@ -287,7 +288,7 @@ class XlsCell {
 
     case CELL_DATE:
     case CELL_NUMERIC:
-      return (cell_->d - offset) * 86400;
+      return dateRound((cell_->d - offset) * 86400);
     }
   }
 

---FILE: src/XlsxCell.h---
@@ -268,7 +268,7 @@ class XlsxCell {
     case CELL_NUMERIC:
     {
       rapidxml::xml_node<>* v = cell_->first_node(""v"");
-      return (atof(v->value()) - offset) * 86400;
+      return dateRound((atof(v->value()) - offset) * 86400);
     }
     }
   }

---FILE: src/utils.h---
@@ -18,6 +18,17 @@ inline double dateOffset(bool is1904) {
   return is1904 ? 24107 : 25569;
 }
 
+// this is sort of horrible
+// convert serial date to decimilliseconds
+// use well-known hack to round to nearest integer w/o C++11 or boost, e.g.
+// http://stackoverflow.com/questions/485525/round-for-float-in-c
+// convert back to serial date
+inline double dateRound(double dttm) {
+  double ms = dttm * 10000;
+  ms = (ms >= 0.0 ? std::floor(ms + 0.5) : std::ceil(ms - 0.5));
+  return ms / 10000;
+}
+
 // Simple parser: does not check that order of numbers and letters is correct
 inline std::pair<int, int> parseRef(const char* ref) {
   int col = 0, row = 0;

---FILE: tests/testthat/test-dates.R---
@@ -10,3 +10,14 @@ test_that(""dates respect worksheet date setting"", {
   expect_equal(d1900, d1900loo)
   expect_equal(d1900$X1, ISOdate(2000, 01, 01, 0, tz = ""UTC""))
 })
+
+## #187 Date/times missing a second
+test_that(""date subsecond rounding works"", {
+  ## xlsx
+  df <- read_excel(test_sheet(""datetime-rounding.xlsx""))
+  expect_identical(as.character(df$dttm), df$dttm_string)
+
+  ## xls
+  df <- read_excel(test_sheet(""datetime-rounding.xls""))
+  expect_identical(as.character(df$dttm), df$dttm_string)
+})",True,False,Documentation / Formatting,3
tidyverse,readxl,843724e9d776f43a837c507cc97854f0a53c3ef1,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-03-05T20:47:29Z,GitHub,noreply@github.com,2017-03-05T20:47:29Z,"Add logical cell & col types; refactor cell typing and coercion (#277)

* Add logical cell and col types; general refactor of cell typing and coercion

Rescues xls formula dates

* Make logicalFromString() to use in xls and xlsx

* Attempt to coerce text to number; fixes #217, fixes #106

* Work on NEWS.md

* Fiddle with comments and kick appveyor

* Edit Xls[x]WorkSheet.h side-by-side for parallelism

* Edit NEWS.md

* Coerce numeric to date in a ""date"" column; fixes #266

* Don't use C++11 when converting string to double

* Test all the warnings

* Enhance comments and refactor xls cell typing

* Consistently use strncmp(this, that, n) == 0

* Simplify logical cell creation in xls

* Fewer parens

* Add comment, collapse two cases

* Use Rf_StringTrue() and Rf_StringFalse()

* Beef up tests of logical coercion; delete old coercion test that adds nothing

* Frontload comments re: xls & xlsx cell types and make more parallel",NEWS.md;R/read_excel.R;docs/news/index.html;docs/reference/read_excel.html;man/read_excel.Rd;src/ColSpec.h;src/XlsCell.h;src/XlsWorkSheet.h;src/XlsxCell.h;src/XlsxWorkSheet.cpp;src/XlsxWorkSheet.h;src/utils.h;tests/testthat/sheets/types.xls;tests/testthat/sheets/types.xlsx;tests/testthat/test-col-types.R;tests/testthat/test-empty.R;tests/testthat/test-missing-values.R,False,True,True,False,792,265,1057,"---FILE: NEWS.md---
@@ -1,6 +1,18 @@
 # readxl 0.1.1.9000
 
-* Boolean cells are now detected in xls. Suppresses message `""Unknown type: 517""`. For now, Boolean cells in both xls and xlsx become numeric, with values 0 and 1. (#274, #259 @jennybc)
+* Numeric data that appears in a `""date""` column is coerced to a date. Also throws a warning. (#277, #266 @jennybc)
+
+* Dates that appear in a numeric column are converted to `NA` instead of their integer representation. Also throws warning. (#277, #263 @jennybc)
+
+* ""Number stored as text"": when a text cell is found in a `""numeric""` column, `read_excel()` attempts to coerce the string to numeric and falls back to `NA` if unsuccessful. Also throws warning. (#277, #217, #106 @jennybc)
+
+* Cells in error are treated as blank and are imported as `NA` (instead of the string `""error""`). (#277, #62 @jennybc)
+
+* Dates that arise from a formula are now treated as dates (vs. numeric) in xls. (#277 @jennybc)
+
+* `""logical""` is a new column type. When `col_types = NULL`, it is the guessed column type for cells Excel advertises as Boolean. It can be specified explicitly in `col_types`. (#277, #270 @jennybc)
+
+* BoolErr cells are now handled in xls. Suppresses message `""Unknown type: 517""`. (#274, #259 @jennybc)
 
 * xls files written by some third party software report both row and column dimensions as 0-indexed, which prevents libxls from reading the last column. Small change to libxls restores access to those cells. (#273, #180, #152, #99 @jennybc)
 

---FILE: R/read_excel.R---
@@ -14,10 +14,11 @@ NULL
 #'   unskipped column.
 #' @param col_types Either `NULL` to guess from the spreadsheet or a character
 #'   vector containing one entry per column from these options: ""skip"",
-#'   ""numeric"", ""date"", ""text"" or ""list"". The content of a cell in a skipped column is
-#'   never read and that column will not appear in the data frame output. A list cell
-#'   loads a column as a list of length 1 vectors, which are typed using the type
-#'   guessing logic from `col_types = NULL`, but on a cell-by-cell basis.
+#'   ""logical"", ""numeric"", ""date"", ""text"" or ""list"". The content of a cell in a
+#'   skipped column is never read and that column will not appear in the data
+#'   frame output. A list cell loads a column as a list of length 1 vectors,
+#'   which are typed using the type guessing logic from `col_types = NULL`, but
+#'   on a cell-by-cell basis.
 #' @param na Character vector of strings to use for missing values. By default,
 #'   readxl treats blank cells as missing data.
 #' @param skip Number of rows to skip before reading any data. Leading blank
@@ -150,7 +151,7 @@ check_col_types <- function(col_types) {
     col_types[blank] <- ""skip""
   }
 
-  accepted_types <- c(""skip"", ""numeric"", ""date"", ""text"", ""list"")
+  accepted_types <- c(""skip"", ""logical"", ""numeric"", ""date"", ""text"", ""list"")
   ok <- col_types %in% accepted_types
   if (any(!ok)) {
     info <- paste(

---FILE: docs/news/index.html---
@@ -83,30 +83,33 @@ <h1>Change log <small>All releases</small></h1>
 <h1 class=""hasAnchor"">
 <a href=""#readxl-0-1-1-9000"" class=""anchor""> </a>readxl 0.1.1.9000</h1>
 <ul>
-<li>
-<code>col_types = ""list""</code> loads data as a list of length-1 vectors, that are typed using the logic from <code>col_types = NULL</code>, but on a cell-by-cell basis (#262 @gergness).</li>
-</ul>
-<p><em>currently much of this applies only to xlsx, but will be extended to xls</em></p>
-<ul>
+<li><p>Dates that appear in a numeric column are converted to <code>NA</code> instead of their integer representation. Also throws warning. (#277, #263, @jennybc)</p></li>
+<li><p>“Number stored as text”: when a text cell is found in a <code>""numeric""</code> column, <code><a href=""../reference/read_excel.html"">read_excel()</a></code> attempts to coerce the string to numeric and falls back to <code>NA</code> if unsuccessful. Also throws warning. (#277, #217, #106 @jennybc)</p></li>
+<li><p>Cells in error are treated as blank and are imported as <code>NA</code> (instead of the string <code>""error""</code>). (#277, #62 @jennybc)</p></li>
+<li><p>Dates that arise from a formula are now treated as dates (vs. numeric) in xls. (#277 @jennybc)</p></li>
+<li><p><code>""logical""</code> is a new column type. When <code>col_types = NULL</code>, it is the guessed column type for cells Excel advertises as Boolean. It can be specified explicitly in <code>col_types</code>. (#277, #270 @jennybc)</p></li>
+<li><p>BoolErr cells are now handled in xls. Suppresses message <code>""Unknown type: 517""</code>. (#274, #259 @jennybc)</p></li>
+<li><p>xls files written by some third party software report both row and column dimensions as 0-indexed, which prevents libxls from reading the last column. Small change to libxls restores access to those cells. (#273, #180, #152, #99 @jennybc)</p></li>
+<li><p><code>col_types = ""list""</code> loads data as a list of length-1 vectors, that are typed using the logic from <code>col_types = NULL</code>, but on a cell-by-cell basis (#262 @gergness).</p></li>
 <li><p>A user-specified <code>col_types</code> of length one will be replicated to have length equal to the number of columns. (#127, #114, #261 @jennybc)</p></li>
 <li><p>Column type <code>""blank""</code> has been deprecated in favor of the more descriptive <code>""skip""</code>, which also supports the goal to become more consistent with readr. (#260, #193, #261 @jennybc)</p></li>
 <li><p>User-supplied <code>col_names</code> are processed relative to user-supplied <code>col_types</code>, if given. Specifically, <code>col_names</code> is considered valid if it has the same length as <code>col_types</code>, before <em>or after</em> removing skipped columns. (#81, #261 @jennybc)</p></li>
 <li><p>Leading or embedded empty columns are no longer dropped, regardless of whether there is a column name. (#157, #261 @jennybc)</p></li>
 <li><p>New argument <code>guess_max</code> lets user adjust the number of rows used to guess column types, similar to functions in readr. (#223, #257 @tklebel, @jennybc)</p></li>
 <li>
-<p>Improved handling of empty cells for xlsx. (#248 @jennybc)</p>
+<p>Improved handling of empty cells. (xlsx #248, xls #271 @jennybc)</p>
 <ul>
-<li>Cells with no content are not loaded. Sheet extent is always computed from loaded cells, instead of the nominal dimensions reported in the worksheet. The result is to not consult the XML for empty cells that appear there simply because they have an associated style or format. This is detectable in Excel as seemingly empty cells with a format other than “General”.</li>
-<li>Eliminates a source of trailing rows (#203, although original report was re: xls, which is not fixed yet) and columns (#236, #162, #146) consisting entirely of <code>NA</code>.</li>
+<li>Cells with no content are not loaded. Sheet extent is always computed from loaded cells, instead of the nominal dimensions reported in the worksheet, which count cells with data <em>or having an explicit format</em>. Empty, formatted cells are detectable in Excel as seemingly empty cells with a format other than “General”.</li>
+<li>Eliminates a source of trailing rows (#203) and columns (#236, #162, #146) consisting entirely of <code>NA</code>.</li>
 <li>Eliminates a subtle source of disagreement between user-provided column names and guessed column types (#169, #81).</li>
 </ul>
 </li>
 <li><p><code>tibble::repair_names()</code> is used to prevent empty, <code>NA</code>, or duplicated names. (#216, #208, #199 #182, #53, #247 @jennybc)</p></li>
 <li><p>Fix compilation warning/failure (FreeBSD 10.3 #221, gcc 4.9.3 #124) and/or problems reading xls (CentOS 6.6 #189). (#244, #245, #246 @jeroenooms)</p></li>
 <li>
-<p>Improved parsing of sheet geometry for xlsx. (#240, @jennybc)</p>
+<p>Improved parsing of sheet geometry (xlsx #240, xls #271 @jennybc)</p>
 <ul>
-<li>Location is inferred for cells that do not declare their location (e.g. xlsx written by JMP). (#163, #102)</li>
+<li>Location is inferred for cells that do not declare their location (xlsx only! e.g. xlsx written by JMP). (#163, #102)</li>
 <li>Worksheets that are completely empty or that contain only column names no longer error, but return a tibble with zero rows. (#222, #144, #65)</li>
 <li>Better handling of leading and embedded blank rows and explicit row skipping. (#224, #194, #178, #156, #101)</li>
 </ul>

---FILE: docs/reference/read_excel.html---
@@ -110,10 +110,11 @@ <h2 class=""hasAnchor"" id=""arguments""><a class=""anchor"" href=""#arguments""></a> Ar
       <dt>col_types</dt>
       <dd>Either <code>NULL</code> to guess from the spreadsheet or a character
 vector containing one entry per column from these options: &quot;skip&quot;,
-&quot;numeric&quot;, &quot;date&quot;, &quot;text&quot; or &quot;list&quot;. The content of a cell in a skipped column is
-never read and that column will not appear in the data frame output. A list cell
-loads a column as a list of length 1 vectors, which are typed using the type
-guessing logic from <code>col_types = NULL</code>, but on a cell-by-cell basis.</dd>
+&quot;logical&quot;, &quot;numeric&quot;, &quot;date&quot;, &quot;text&quot; or &quot;list&quot;. The content of a cell in a
+skipped column is never read and that column will not appear in the data
+frame output. A list cell loads a column as a list of length 1 vectors,
+which are typed using the type guessing logic from <code>col_types = NULL</code>, but
+on a cell-by-cell basis.</dd>
       <dt>na</dt>
       <dd>Character vector of strings to use for missing values. By default,
 readxl treats blank cells as missing data.</dd>

---FILE: man/read_excel.Rd---
@@ -29,10 +29,11 @@ unskipped column.}
 
 \item{col_types}{Either \code{NULL} to guess from the spreadsheet or a character
 vector containing one entry per column from these options: ""skip"",
-""numeric"", ""date"", ""text"" or ""list"". The content of a cell in a skipped column is
-never read and that column will not appear in the data frame output. A list cell
-loads a column as a list of length 1 vectors, which are typed using the type
-guessing logic from \code{col_types = NULL}, but on a cell-by-cell basis.}
+""logical"", ""numeric"", ""date"", ""text"" or ""list"". The content of a cell in a
+skipped column is never read and that column will not appear in the data
+frame output. A list cell loads a column as a list of length 1 vectors,
+which are typed using the type guessing logic from \code{col_types = NULL}, but
+on a cell-by-cell basis.}
 
 \item{na}{Character vector of strings to use for missing values. By default,
 readxl treats blank cells as missing data.}

---FILE: src/ColSpec.h---
@@ -7,27 +7,58 @@
 
 enum CellType {
   CELL_BLANK,
+  CELL_LOGICAL,
   CELL_DATE,
   CELL_NUMERIC,
   CELL_TEXT
 };
 
-// COL_BLANK is a column full of CELL_BLANKs,
-// while COL_SKIP is a user-specified column type
 enum ColType {
-  COL_BLANK,
+  COL_BLANK,   // occurs when col_types = NULL and observe only CELL_BLANKs
+  COL_LOGICAL,
   COL_DATE,
   COL_NUMERIC,
   COL_TEXT,
-  COL_LIST,
-  COL_SKIP
+  COL_LIST,    // occurs only as user-specified column type
+  COL_SKIP     // occurs only as user-specified column type
 };
 
-// ColType enum is ordered such that a simple cast
-// is sufficient to convert from CellType (user-specified
-// columns come after cell types)
-ColType inline as_ColType(CellType cell) {
-  return (ColType) cell;
+// ColType enum is ordered such that a simple cast is sufficient to convert
+// from CellType (user-specified column types come after cell types)
+ColType inline as_ColType(CellType celltype) {
+  return (ColType) celltype;
+}
+
+inline std::string cellTypeDesc(CellType type) {
+  switch(type) {
+  case CELL_BLANK:    return ""blank"";
+  case CELL_LOGICAL:  return ""logical"";
+  case CELL_DATE:     return ""date"";
+  case CELL_NUMERIC:  return ""numeric"";
+  case CELL_TEXT:     return ""text"";
+  }
+  return ""???"";
+}
+
+inline std::string colTypeDesc(ColType type) {
+  switch(type) {
+  case COL_BLANK:   return ""blank"";
+  case COL_LOGICAL: return ""logical"";
+  case COL_DATE:    return ""date"";
+  case COL_NUMERIC: return ""numeric"";
+  case COL_TEXT:    return ""text"";
+  case COL_LIST:    return ""list"";
+  case COL_SKIP:    return ""skip"";
+  }
+  return ""???"";
+}
+
+inline Rcpp::CharacterVector colTypeDescs(std::vector<ColType> types) {
+  Rcpp::CharacterVector out(types.size());
+  for (size_t i = 0; i < types.size(); ++i) {
+    out[i] = colTypeDesc(types[i]);
+  }
+  return out;
 }
 
 inline std::vector<ColType> colTypeStrings(Rcpp::CharacterVector x) {
@@ -38,6 +69,8 @@ inline std::vector<ColType> colTypeStrings(Rcpp::CharacterVector x) {
     std::string type(x[i]);
     if (type == ""blank"") {
       types.push_back(COL_BLANK);
+    } else if (type == ""logical"") {
+      types.push_back(COL_LOGICAL);
     } else if (type == ""date"") {
       types.push_back(COL_DATE);
     } else if (type == ""numeric"") {
@@ -49,24 +82,13 @@ inline std::vector<ColType> colTypeStrings(Rcpp::CharacterVector x) {
     } else if (type == ""skip"") {
       types.push_back(COL_SKIP);
     } else {
-      Rcpp::stop(""Unknown type '%s' at position %i"", type, i + 1);
+      Rcpp::stop(""Unknown column type '%s' at position %i"", type, i + 1);
     }
   }
 
   return types;
 }
 
-inline std::string colTypeDesc(ColType type) {
-  switch(type) {
-  case COL_BLANK:   return ""blank"";
-  case COL_DATE:    return ""date"";
-  case COL_NUMERIC: return ""numeric"";
-  case COL_TEXT:    return ""text"";
-  case COL_LIST:    return ""list"";
-  case COL_SKIP:    return ""skip"";
-  }
-  return ""???"";
-}
 
 bool inline isDateTime(int id, const std::set<int> custom) {
   // Date formats:
@@ -87,14 +109,6 @@ bool inline isDateTime(int id, const std::set<int> custom) {
   return custom.count(id) > 0;
 }
 
-inline Rcpp::CharacterVector colTypeDescs(std::vector<ColType> types) {
-  Rcpp::CharacterVector out(types.size());
-  for (size_t i = 0; i < types.size(); ++i) {
-    out[i] = colTypeDesc(types[i]);
-  }
-  return out;
-}
-
 inline bool isDateFormat(std::string x) {
   for (size_t i = 0; i < x.size(); ++i) {
     switch (x[i]) {
@@ -127,13 +141,13 @@ inline std::vector<ColType> recycleTypes(std::vector<ColType> types,
 }
 
 inline std::vector<ColType> finalizeTypes(std::vector<ColType> types) {
-  // convert blank columns to a default type (numeric today, but logical soon)
+  // convert blank columns to a default type: logical
   // can only happen when
   //   * col_types = NULL and we've learned them from data
   //   * all cells in column are empty or match one of the na strings
   for (size_t i = 0; i < types.size(); i++) {
     if (types[i] == COL_BLANK) {
-      types[i] = COL_NUMERIC;
+      types[i] = COL_LOGICAL;
     }
   }
   return types;
@@ -178,6 +192,9 @@ inline Rcpp::RObject makeCol(ColType type, int n) {
   case COL_SKIP:
     return R_NilValue;
     break;
+  case COL_LOGICAL:
+    return Rcpp::LogicalVector(n, NA_LOGICAL);
+    break;
   case COL_DATE: {
     Rcpp::RObject col = Rcpp::NumericVector(n, NA_REAL);
     col.attr(""class"") = Rcpp::CharacterVector::create(""POSIXct"", ""POSIXt"");

---FILE: src/XlsCell.h---
@@ -6,6 +6,13 @@
 #include <libxls/xlstypes.h>
 #include ""ColSpec.h""
 
+// Key reference for understanding the structure of the xls format is
+// [MS-XLS]: Excel Binary File Format (.xls) Structure
+// https://msdn.microsoft.com/en-us/library/cc313154(v=office.12).aspx
+// http://interoperability.blob.core.windows.net/files/MS-XLS/[MS-XLS].pdf
+// Page and section numbers below refer to
+// v20161017, Release: October 17, 2016
+
 class XlsCell {
   xls::xlsCell *cell_;
   std::pair<int,int> location_;
@@ -31,76 +38,142 @@ class XlsCell {
   CellType type(const StringSet& na,
                 const xls::st_xf* styles,
                 const std::set<int>& customDateFormats) const {
-
-    // [MS-XLS] - v20161017, Release: October 17, 2016
+    // 1. Review of Excel's declared cell types, then
+    // 2. Summary of how Excel's cell types map to our CellType enum
     //
-    // In 2.2.1 Cell Table on p80:
-    // ""Cells are specified by any of the records specified in the CELL rule.""
-    // (section 2.1.7.20.6).
-    // In 2.1.7.20.6 on p74, here is the CELL rule:
+    // 2.2.1 Cell Table p80:
+    // ""Cells are specified by any of the records specified in the CELL rule
+    // (section 2.1.7.20.6).""
+    //
+    // 2.1.7.20.6 p74 The CELL Rule:
     // CELL = FORMULA / Blank / MulBlank / RK / MulRk / BoolErr / Number / LabelSst
     //
     // 2.3 Record Enumeration
     // Has 2 tables associating each record type value with a name and number.
     // 2.3.1 starting p168 is ordered by name
     // 2.3.2 starting p180 is ordered by number
     //
-    // See xls_addCell for those used for cells
-    // and xlsstruct.h to confirm record numbers
+    // For info on how libxls extracts and exposes, see xls_addCell. Also
+    // consult xlsstruct.h to confirm record numbers.
+    //
+    // We map Excel's cell types to the CellType enum based on declared type
+    // and contents.
+    //
+    // CELL_BLANK
+    //   shared string or string formula whose value matches na
+    //   boolean or boolean formula whose value (TRUE or FALSE) matches na
+    //   number or numeric formula whose double value (d) matches na
+    //   formula in error (except #NULL!) or static error (#N/A)
+    //   explicit blank cell
+    //
+    // CELL_LOGICAL
+    //   boolean or boolean formula whose value (TRUE or FALSE) does not match na
+    //
+    // CELL_DATE
+    //   number or numeric formula with a date format, whose double value (d)
+    //   does not match na
+    //
+    // CELL_NUMERIC
+    //   number or numeric formula with no format or a non-date format, whose
+    //   double value (d) does not match na
+    //
+    // CELL_TEXT
+    //   shared string or string formula whose value does not match na
+
     switch(cell_->id) {
-    case 253: // 0x00FD LabelSst
-    case 516: // 0x0204 Label
+    case 253: // 0x00FD LabelSst 2.4.149 p325:
+              // a string from the shared string table
+    case 516: // 0x0204 Label 2.4.148 p325:
+              // ""Label record specifies a label on the category axis for
+              // each series""
+              // Jenny: I think this one is a red herring = not a cell type
       return na.contains((char*) cell_->str) ? CELL_BLANK : CELL_TEXT;
-      break;
-
-    case 6:    // 0x0006 formula
-    case 1030: // 0x0406 formula (Apple Numbers Bug)
-      if (cell_->l == 0) {
-        return na.contains(cell_->d) ? CELL_BLANK : CELL_NUMERIC;
-      } else {
-        if (na.contains((char*) cell_->str)) {
+
+    case 6:    // 0x0006 formula 2.4.127 p309
+    case 1030: // 0x0406 formula (Apple Numbers Bug) via libxls
+      if (cell_->l == 0) { // formula evaluates to numeric, possibly date
+        if (na.contains(cell_->d)) {
+          return CELL_BLANK;
+        }
+        if (styles == NULL) {
+          return CELL_NUMERIC;
+        }
+        int format = styles->xf[cell_->xf].format;
+        return isDateTime(format, customDateFormats) ? CELL_DATE : CELL_NUMERIC;
+      } else { // formula evaluates to Boolean, string, or error
+
+        // Boolean
+        if (strncmp((char *) cell_->str, ""bool"", 4) == 0) {
+          if ( (cell_->d == 0 && na.contains(""FALSE"")) ||
+               (cell_->d == 1 && na.contains(""TRUE"")) ) {
+            return CELL_BLANK;
+          } else {
+            return CELL_LOGICAL;
+          }
+        }
+
+        // error
+        // libxls puts ""error"" in str for all errors and
+        // puts the error code in d
+        //  Code Error
+        //  0x00 #NULL! <-- indistinguishable from ""error"" formula string :(
+        //  0x07 #DIV/0!
+        //  0x0F #VALUE!
+        //  0x17 #REF!
+        //  0x1D #NAME?
+        //  0x24 #NUM!
+        //  0x2A #N/A
+        //  0x2B #GETTING_DATA
+        if (strncmp((char *) cell_->str, ""error"", 5) == 0 && cell_->d > 0) {
           return CELL_BLANK;
-        } else {
-          return CELL_TEXT;
         }
+
+        // string (or #NULL! error)
+        return na.contains((char*) cell_->str) ? CELL_BLANK : CELL_TEXT;
       }
-      break;
 
-    case 189: // 0x00BD MulRk
-    case 515: // 0x0203 Number
-    case 638: // 0x027E Rk
+    case 189: // 0x00BD MulRk 2.4.175 p344:
+              // numeric data originating from series of cells
+    case 515: // 0x0203 Number 2.4.180 p348:
+              // floating-point number from single cell
+    case 638: // 0x027E Rk 2.4.220 p376:
+              // numeric data from single cell
       {
-        if (na.contains(cell_->d))
+        if (na.contains(cell_->d)) {
           return CELL_BLANK;
-
-        if (styles == NULL)
+        }
+        if (styles == NULL) {
           return CELL_NUMERIC;
-
+        }
         int format = styles->xf[cell_->xf].format;
         return isDateTime(format, customDateFormats) ? CELL_DATE : CELL_NUMERIC;
       }
-      break;
 
-    case 190: // 0x00BE MulBlank
-    case 513: // 0x0201 Blank
+    case 190: // 0x00BE MulBlank 2.4.174 p344:
+              // blank cell originating from series of blank cells
+    case 513: // 0x0201 Blank 2.4.20 p212:
+              // an empty cell with no formula or value
       return CELL_BLANK;
-      break;
 
-    case 517: // 0x0205 BoolErr
-      {
-        if (!strcmp((char *) cell_->str, ""bool"")) {
-        // switch to CELL_LOGICAL once exists; cell.d is 0/1 for FALSE/TRUE
-        return CELL_NUMERIC;
-      } else {
-        return CELL_TEXT;
-      }
+    case 517: // 0x0205 BoolErr 2.4.24 p216:
+              //  a cell that contains either a Boolean value or an error value
+      if (strncmp((char *) cell_->str, ""bool"", 4) == 0) {
+        if ( (cell_->d == 0 && na.contains(""FALSE"")) ||
+             (cell_->d == 1 && na.contains(""TRUE"")) ) {
+          return CELL_BLANK;
+        } else {
+          return CELL_LOGICAL;
+        }
       }
-      break;
+      // must be an error
+      return CELL_BLANK;
 
     default:
-      Rcpp::Rcout << ""Unknown type: "" << cell_->id << ""\n"";
-    return CELL_NUMERIC;
+      Rcpp::warning(""Unrecognized cell type at [%i, %i]: '%s'"",
+                    row() + 1, col() + 1, cell_->id);
     }
+
+    return CELL_TEXT;
   }
 
 };

---FILE: src/XlsWorkSheet.h---
@@ -61,6 +61,8 @@ class XlsWorkSheet {
       if (xcell->col() >= ncol_) {
         break;
       }
+      // revisit after this class gains functions for string conversion
+      // https://github.com/tidyverse/readxl/issues/282
       if (xcell->cell()->str == NULL) {
         out[xcell->col()] = NA_STRING;
       } else {
@@ -81,9 +83,7 @@ class XlsWorkSheet {
 
     // no cell data to consult re: types
     if (xcell == cells_.end()) {
-      for (size_t i = 0; i < types.size(); i++) {
-        types[i] = COL_BLANK;
-      }
+      std::fill(types.begin(), types.end(), COL_BLANK);
       return types;
     }
 
@@ -146,61 +146,147 @@ class XlsWorkSheet {
       int row = i - base;
       // Needs to compare to actual cell type to give warnings
       switch(types[j]) {
+
       case COL_BLANK:
       case COL_SKIP:
         break;
-      case COL_NUMERIC:
+
+      case COL_LOGICAL:
         switch(type) {
         case CELL_BLANK:
-          REAL(col)[row] = NA_REAL;
+          LOGICAL(col)[row] = NA_LOGICAL;
           break;
-        case CELL_NUMERIC:
         case CELL_DATE:
-          REAL(col)[row] = xcell->cell()->d;
+          // print date string here, when/if it's possible to do so
+          Rcpp::warning(""Expecting logical in [%i, %i] got a date"",
+                        i + 1, j + 1);
+          LOGICAL(col)[row] = NA_LOGICAL;
+          break;
+        case CELL_LOGICAL:
+        case CELL_NUMERIC:
+          LOGICAL(col)[row] = xcell->cell()->d != 0;
           break;
         case CELL_TEXT:
-          Rcpp::warning(""[%i, %i]: expecting numeric: got '%s'"",
-                        row + 1, j + 1, (char*) xcell->cell()->str);
-          REAL(col)[row] = NA_REAL;
+        {
+          std::string text_string((char*) xcell->cell()->str);
+          bool text_boolean;
+          if (logicalFromString(text_string, &text_boolean)) {
+            LOGICAL(col)[row] = text_boolean;
+          } else {
+            Rcpp::warning(""Expecting logical in [%i, %i] got '%s'"",
+                          i + 1, j + 1, xcell->cell()->str);
+            LOGICAL(col)[row] = NA_LOGICAL;
+          }
+        }
+          break;
         }
         break;
+
       case COL_DATE:
         switch(type) {
         case CELL_BLANK:
           REAL(col)[row] = NA_REAL;
           break;
+        case CELL_LOGICAL:
+          Rcpp::warning(""Expecting date in [%i, %i]: got boolean"",
+                        i + 1, j + 1);
+          REAL(col)[row] = NA_REAL;
+          break;
         case CELL_DATE:
           REAL(col)[row] = (xcell->cell()->d - offset_) * 86400;
           break;
         case CELL_NUMERIC:
-          Rcpp::warning(""Expecting date in [%i, %i] got %d"",
-                        i + 1, j + 1, xcell->cell()->d);
-          REAL(col)[row] = NA_REAL;
+          Rcpp::warning(""Coercing numeric to date in [%i, %i]"",
+                        i + 1, j + 1);
+          REAL(col)[row] = (xcell->cell()->d - offset_) * 86400;
           break;
         case CELL_TEXT:
-          Rcpp::warning(""Expecting date in [%i, %i] got '%s'"",
+          Rcpp::warning(""Expecting date in [%i, %i]: got '%s'"",
                         i + 1, j + 1, xcell->cell()->str);
           REAL(col)[row] = NA_REAL;
           break;
         }
         break;
+
+      case COL_NUMERIC:
+        switch(type) {
+        case CELL_BLANK:
+          REAL(col)[row] = NA_REAL;
+          break;
+        case CELL_LOGICAL:
+          Rcpp::warning(""Coercing boolean to numeric in [%i, %i]"",
+                        i + 1, j + 1);
+          REAL(col)[row] = xcell->cell()->d;
+          break;
+        case CELL_DATE:
+          // print date string here, when/if possible
+          Rcpp::warning(""Expecting numeric in [%i, %i]: got a date"",
+                        i + 1, j + 1);
+          REAL(col)[row] = NA_REAL;
+          break;
+        case CELL_NUMERIC:
+          REAL(col)[row] = xcell->cell()->d;
+          break;
+        case CELL_TEXT:
+        {
+          std::string num_string((char*) xcell->cell()->str);
+          double num_num;
+          bool success = doubleFromString(num_string, num_num);
+          if (success) {
+            Rcpp::warning(""Coercing text to numeric in [%i, %i]: '%s'"",
+                          i + 1, j + 1, num_string);
+            REAL(col)[row] = num_num;
+          } else {
+            Rcpp::warning(""Expecting numeric in [%i, %i]: got '%s'"",
+                          i + 1, j + 1, num_string);
+            REAL(col)[row] = NA_REAL;
+          }
+        }
+          break;
+        }
+        break;
+
       case COL_TEXT:
-        if (type == CELL_BLANK) {
+        // not issuing warnings for NAs or coercion, because ""text"" is the
+        // fallback column type and there are too many warnings to be helpful
+        switch(type) {
+        case CELL_BLANK:
           SET_STRING_ELT(col, row, NA_STRING);
-        } else {
+          break;
+        case CELL_LOGICAL:
+          if (xcell->cell()->d == 0) {
+            SET_STRING_ELT(col, row, Rf_mkChar(""FALSE""));
+          } else {
+            SET_STRING_ELT(col, row, Rf_mkChar(""TRUE""));
+          }
+          break;
+        case CELL_DATE:
+          // use date string here, when/if possible
+        {
           std::string stdString((char*) xcell->cell()->str);
           Rcpp::RObject rString = na.contains(stdString) ? NA_STRING : Rf_mkCharCE(stdString.c_str(), CE_UTF8);
           SET_STRING_ELT(col, row, rString);
+          break;
+        }
+        case CELL_NUMERIC:
+        case CELL_TEXT:
+        {
+          std::string stdString((char*) xcell->cell()->str);
+          Rcpp::RObject rString = na.contains(stdString) ? NA_STRING : Rf_mkCharCE(stdString.c_str(), CE_UTF8);
+          SET_STRING_ELT(col, row, rString);
+        }
+          break;
         }
         break;
+
       case COL_LIST:
         switch(type) {
         case CELL_BLANK: {
           SET_VECTOR_ELT(col, row, Rf_ScalarLogical(NA_LOGICAL));
           break;
         }
-        case CELL_NUMERIC: {
-          SET_VECTOR_ELT(col, row, Rf_ScalarReal(xcell->cell()->d));
+        case CELL_LOGICAL: {
+          SET_VECTOR_ELT(col, row, Rf_ScalarLogical(xcell->cell()->d));
           break;
         }
         case CELL_DATE: {
@@ -210,6 +296,10 @@ class XlsWorkSheet {
           SET_VECTOR_ELT(col, row, cell_val);
           break;
         }
+        case CELL_NUMERIC: {
+          SET_VECTOR_ELT(col, row, Rf_ScalarReal(xcell->cell()->d));
+          break;
+        }
         case CELL_TEXT: {
           std::string stdString((char*) xcell->cell()->str);
           Rcpp::CharacterVector rString = na.contains(stdString) ? NA_STRING : Rf_mkCharCE(stdString.c_str(), CE_UTF8);
@@ -239,20 +329,26 @@ class XlsWorkSheet {
           continue;
         }
 
+        // Dimensions reported by xls itself include empty cells that have
+        // formatting, therefore we test explicitly for non-blank cell types
+        // and only load those cells.
+        // 2.4.90 Dimensions p273 of [MS-XLS]
+
         if (cell->id == 0x27e || cell->id == 0x0BD || cell->id == 0x203 ||
             // cell holds a number:
-            //   0x27e --> 638     RK (section 2.4.220) p376 of [MS-XLS]
-            //   0x0BD --> 189  MulRk (section 2.4.175) p344
-            //   0x203 --> 515 Number (section 2.4.180) p348
-            cell->id == 0x06 ||
+            //   0x27e -->  638     RK (section 2.4.220) p376 of [MS-XLS]
+            //   0x0BD -->  189  MulRk (section 2.4.175) p344
+            //   0x203 -->  515 Number (section 2.4.180) p348
+            cell->id == 0x06 ||  cell->id == 0x0406 ||
             // cell holds a formula:
             //    0x06 -->   6 Formula (section 2.4.127) p309
+            //  0x0406 --> 1030 Formula (Apple Numbers Bug) via libxls
             cell->id == 0x205 ||
             // cell holds either Boolean or error:
-            //   0x205 --> 517 BoolErr (section 2.4.24) p216
+            //   0x205 -->  517 BoolErr (section 2.4.24) p216
             cell->id == 0x0FD
             // cell holds a string:
-            //   0x0FD --> 253 LabelSst (section 2.4.149) p325
+            //   0x0FD -->  253 LabelSst (section 2.4.149) p325
         ) {
           cells_.push_back(cell);
         }
@@ -273,7 +369,7 @@ class XlsWorkSheet {
     nrow_ = 0;
 
     // empty sheet case
-    if (cells_.size() == 0) {
+    if (cells_.empty()) {
       return;
     }
 

---FILE: src/XlsxCell.h---
@@ -5,6 +5,7 @@
 #include ""rapidxml.h""
 #include ""ColSpec.h""
 #include ""XlsxString.h""
+#include ""utils.h""
 
 // Key reference for understanding the structure of the XML is
 // ECMA-376 (http://www.ecma-international.org/publications/standards/Ecma-376.htm)
@@ -13,23 +14,6 @@
 // 18.3.1.96  v           (Cell Value) [p1709]
 // 18.18.11   ST_CellType (Cell Type)  [p2443]
 
-// Simple parser: does not check that order of numbers and letters is correct
-inline std::pair<int, int> parseRef(const char* ref) {
-  int col = 0, row = 0;
-
-  for (const char* cur = ref; *cur != '\0'; ++cur) {
-    if (*cur >= '0' && *cur <= '9') {
-      row = row * 10 + (*cur - '0');
-    } else if (*cur >= 'A' && *cur <= 'Z') {
-      col = 26 * col + (*cur - 'A' + 1);
-    } else {
-      Rcpp::stop(""Invalid character '%s' in cell ref '%s'"", *cur, ref);
-    }
-  }
-
-  return std::make_pair(row - 1, col - 1); // zero indexed
-}
-
 class XlsxCell {
   rapidxml::xml_node<>* cell_;
   std::pair<int,int> location_;
@@ -54,17 +38,179 @@ class XlsxCell {
     return location_.second;
   }
 
-  std::string asStdString(const std::vector<std::string>& stringTable) const {
+  CellType type(const StringSet& na,
+                const std::vector<std::string>& stringTable,
+                const std::set<int>& dateStyles) const {
+    // 1. Review of Excel's declared cell types, then
+    // 2. Summary of how Excel's cell types map to our CellType enum
+    //
+    // this table refers to the value of the t attribute of a cell
+    // 18.18.11   ST_CellType (Cell Type)  [p2443]
+    // This simple type is restricted to the values listed in the following table:
+    // -------------------------------------------------------------------------
+    // Enumeration Value          Description
+    // -------------------------------------------------------------------------
+    // b (Boolean)                Cell containing a boolean.
+    // d (Date)                   Cell contains a date in the ISO 8601 format.
+    // e (Error)                  Cell containing an error.
+    // inlineStr (Inline String)  Cell containing an (inline) rich string, i.e.,
+    //                            one not in the shared string table. If this
+    //                            cell type is used, then the cell value is in
+    //                            the is element rather than the v element in
+    //                            the cell (c element).
+    // n (Number)                 Cell containing a number.
+    // s (Shared String)          Cell containing a shared string.
+    // str (String)               Cell containing a formula string.
+    //
+    // We map Excel's cell types to the CellType enum based on declared type
+    // and contents.
+    //
+    // CELL_BLANK
+    //   inlineStr cell and (string is na or string can't be found)
+    //   cell has no v node and is not an inlineStr cell
+    //   v->value() is na
+    //   error cell
+    //   shared string cell and string is na
+    //
+    // CELL_LOGICAL
+    //   Boolean cell and its value (TRUE or FALSE) is not in na
+    //
+    // CELL_DATE
+    //   numeric cell (t attr is ""n"" or does not exist) with a date style
+    //
+    // CELL_NUMERIC
+    //   numeric cell (t attr is ""n"" or does not exist) with no style or a
+    //   non-date style
+    //
+    // CELL_TEXT
+    //   inlineStr cell and string is found and string is not na
+    //   ISO 8601 date cell (t attr is ""d"") <- we're not sure this exists IRL
+    //   shared string cell and string is not na
+    //   formula string cell and string is not na
+    //   anything that is not explicitly addressed elsewhere
+
+    rapidxml::xml_attribute<>* t = cell_->first_attribute(""t"");
     rapidxml::xml_node<>* v = cell_->first_node(""v"");
-    if (v == NULL)
-      return ""[NULL]"";
 
+    // inlineStr (Inline String)  Cell containing an (inline) rich string
+    if (t != NULL && strncmp(t->value(), ""inlineStr"", 9) == 0) {
+      // must do this first, because inlineStr cells do not have a v node
+      // and the check just below would otherwise make them all CELL_BLANK
+      rapidxml::xml_node<>* is = cell_->first_node(""is"");
+      std::string inline_string;
+      if (parseString(is, &inline_string)) {
+        return na.contains(inline_string) ? CELL_BLANK : CELL_TEXT;
+      } else {
+        return CELL_BLANK;
+      }
+    }
+
+    if (v == NULL || na.contains(v->value())) {
+      return CELL_BLANK;
+    }
+    // from here on, the only explicit NA check needed is the case of
+    // a shared string table lookup
+
+    // n (Number)                 Cell containing a number.
+    if (t == NULL || strncmp(t->value(), ""n"", 5) == 0) {
+      rapidxml::xml_attribute<>* s = cell_->first_attribute(""s"");
+      int style = (s == NULL) ? -1 : atoi(s->value());
+      return (dateStyles.count(style) > 0) ? CELL_DATE : CELL_NUMERIC;
+    }
+
+    // b (Boolean)                Cell containing a boolean.
+    if (strncmp(t->value(), ""b"", 5) == 0) {
+      return CELL_LOGICAL;
+    }
+
+    // d (Date)                   Cell contains a date in the ISO 8601 format.
+    if (strncmp(t->value(), ""d"", 5) == 0) {
+      // Hadley:
+      // Does excel use this? Regardless, don't have cross-platform ISO8601
+      // parser (yet) so need to return as text
+      // Jenny:
+      // Not entirely sure what this is about. I've never seen one IRL.
+      return CELL_TEXT;
+    }
+
+    // e (Error)                  Cell containing an error.
+    if (strncmp(t->value(), ""e"", 5) == 0) {
+      return CELL_BLANK;
+    }
+
+    // s (Shared String)          Cell containing a shared string.
+    if (strncmp(t->value(), ""s"", 5) == 0) {
+      int id = atoi(v->value());
+      const std::string& string = stringTable.at(id);
+      return na.contains(string) ? CELL_BLANK : CELL_TEXT;
+    }
+
+    // str (String)               Cell containing a formula string.
+    if (strncmp(t->value(), ""str"", 5) == 0) {
+      return CELL_TEXT;
+    }
+
+    Rcpp::warning(""Unrecognized cell type at [%i, %i]: '%s'"",
+                  row() + 1, col() + 1, t->value());
+
+    return CELL_TEXT;
+  }
+
+  std::string asStdString(const StringSet& na,
+                          const std::vector<std::string>& stringTable,
+                          const std::set<int>& dateStyles) const {
+    CellType type = this->type(na, stringTable, dateStyles);
+    rapidxml::xml_node<>* v = cell_->first_node(""v"");
     rapidxml::xml_attribute<>* t = cell_->first_attribute(""t"");
-    if (t == NULL || strncmp(t->value(), ""s"", 3) != 0)
+
+    switch(type) {
+
+    case CELL_BLANK:
+      return ""NA"";
+
+    case CELL_LOGICAL:
+      return atoi(v->value()) ? ""TRUE"" : ""FALSE"";
+
+    case CELL_DATE:
+    case CELL_NUMERIC:
+      // not ideal for a date but will have to do ... one day: asDateString()?
       return std::string(v->value());
 
-    int id = atoi(v->value());
-    return stringTable.at(id);
+    case CELL_TEXT:
+    {
+      std::string out_string;
+
+      // inlineStr
+      rapidxml::xml_node<>* is = cell_->first_node(""is"");
+      if (is != NULL) {
+        return parseString(is, &out_string) ? out_string : ""NA"";
+      }
+
+      // shared string
+      if (strncmp(t->value(), ""s"", 5) == 0) {
+        int id = atoi(v->value());
+        if (id < 0 || id >= (int) stringTable.size()) {
+          Rcpp::warning(""Invalid string id at [%i, %i]: %i"",
+                        row() + 1, col() + 1, id);
+          return ""NA"";
+        }
+        return(stringTable.at(id));
+      }
+
+      //   the mythical ISO 8601 date cell
+      //   formula string cell
+      return(v->value());
+    }
+  }
+  }
+
+  int asInteger(const StringSet& na) const {
+    rapidxml::xml_node<>* v = cell_->first_node(""v"");
+    if (v == NULL || na.contains(v->value())) {
+      return NA_LOGICAL;
+    }
+
+    return atoi(v->value());
   }
 
   double asDouble(const StringSet& na) const {
@@ -115,53 +261,9 @@ class XlsxCell {
     }
   }
 
-  CellType type(const StringSet& na,
-                const std::vector<std::string>& stringTable,
-                const std::set<int>& dateStyles) const {
-    rapidxml::xml_attribute<>* t = cell_->first_attribute(""t"");
-
-    if (t == NULL || strncmp(t->value(), ""n"", 5) == 0) {
-      rapidxml::xml_attribute<>* s = cell_->first_attribute(""s"");
-      int style = (s == NULL) ? -1 : atoi(s->value());
-
-      return (dateStyles.count(style) > 0) ? CELL_DATE : CELL_NUMERIC;
-    } else if (strncmp(t->value(), ""b"", 5) == 0) {
-      // TODO
-      return CELL_NUMERIC;
-    } else if (strncmp(t->value(), ""d"", 5) == 0) {
-      // Does excel use this? Regardless, don't have cross-platform ISO8601
-      // parser (yet) so need to return as text
-      return CELL_TEXT;
-    } else if (strncmp(t->value(), ""e"", 5) == 0) { // error
-      return CELL_BLANK;
-    } else if (strncmp(t->value(), ""s"", 5) == 0) { // string in string table
-      rapidxml::xml_node<>* v = cell_->first_node(""v"");
-      if (v == NULL)
-        return CELL_BLANK;
-
-      int id = atoi(v->value());
-      const std::string& string = stringTable.at(id);
-      return na.contains(string) ? CELL_BLANK : CELL_TEXT;
-    } else if (strncmp(t->value(), ""str"", 5) == 0) { // formula
-      rapidxml::xml_node<>* v = cell_->first_node(""v"");
-      if (v == NULL)
-        return CELL_BLANK;
-
-      return na.contains(v->value()) ? CELL_BLANK : CELL_TEXT;
-    } else if  (strncmp(t->value(), ""inlineStr"", 9) == 0) { // formula
-      return CELL_TEXT;
-    } else {
-      Rcpp::warning(""[%i, %i]: unknown type '%s'"",
-        row() + 1, col() + 1, t->value());
-      return CELL_TEXT;
-    }
-
-    return CELL_NUMERIC;
-  }
 
 private:
 
-
   Rcpp::RObject stringFromTable(const char* val, const StringSet& na,
                                 const std::vector<std::string>& stringTable) const {
     int id = atoi(val);

---FILE: src/XlsxWorkSheet.cpp---
@@ -1,6 +1,7 @@
 #include <Rcpp.h>
 #include ""XlsxWorkSheet.h""
 #include ""ColSpec.h""
+#include ""utils.h""
 using namespace Rcpp;
 
 // [[Rcpp::export]]

---FILE: src/XlsxWorkSheet.h---
@@ -94,9 +94,7 @@ class XlsxWorkSheet {
 
     // no cell data to consult re: types
     if (xcell == cells_.end()) {
-      for (size_t i = 0; i < types.size(); i++) {
-        types[i] = COL_BLANK;
-      }
+      std::fill(types.begin(), types.end(), COL_BLANK);
       return types;
     }
 
@@ -107,7 +105,9 @@ class XlsxWorkSheet {
         Rcpp::checkUserInterrupt();
       }
       if (xcell->col() < ncol_) {
-        ColType type = as_ColType(xcell->type(na, wb_.stringTable(), wb_.dateStyles()));
+        ColType type = as_ColType(
+          xcell->type(na, wb_.stringTable(), wb_.dateStyles())
+        );
         if (type > types[xcell->col()]) {
           types[xcell->col()] = type;
         }
@@ -157,55 +157,144 @@ class XlsxWorkSheet {
       int row = i - base;
       // Needs to compare to actual cell type to give warnings
       switch(types[j]) {
+
       case COL_BLANK:
       case COL_SKIP:
         break;
-      case COL_NUMERIC:
+
+      case COL_LOGICAL:
         switch(type) {
         case CELL_BLANK:
-          REAL(col)[row] = NA_REAL;
+          LOGICAL(col)[row] = NA_LOGICAL;
           break;
-        case CELL_NUMERIC:
         case CELL_DATE:
-          REAL(col)[row] = xcell->asDouble(na);
+          // print date string here, when/if it's possible to do so
+          Rcpp::warning(""Expecting logical in [%i, %i]: got a date"",
+                        i + 1, j + 1);
+          LOGICAL(col)[row] = NA_LOGICAL;
+          break;
+        case CELL_LOGICAL:
+        case CELL_NUMERIC:
+          LOGICAL(col)[row] = xcell->asInteger(na) ? TRUE : FALSE;
           break;
         case CELL_TEXT:
-          Rcpp::warning(""[%i, %i]: expecting numeric: got '%s'"",
-                        row + 1, j + 1, xcell->asStdString(wb_.stringTable()));
-          REAL(col)[row] = NA_REAL;
+        {
+          std::string text_string = xcell->asStdString(na, wb_.stringTable(),
+                                                       wb_.dateStyles());
+          bool text_boolean;
+          if (logicalFromString(text_string, &text_boolean)) {
+            LOGICAL(col)[row] = text_boolean;
+          } else {
+            Rcpp::warning(""Expecting logical in [%i, %i] got '%s'"",
+                          i + 1, j + 1, text_string);
+            LOGICAL(col)[row] = NA_LOGICAL;
+          }
+        }
+          break;
         }
         break;
+
       case COL_DATE:
         switch(type) {
         case CELL_BLANK:
           REAL(col)[row] = NA_REAL;
           break;
+        case CELL_LOGICAL:
+          Rcpp::warning(""Expecting date in [%i, %i]: got boolean"",
+                        i + 1, j + 1);
+          REAL(col)[row] = NA_REAL;
+          break;
         case CELL_DATE:
           REAL(col)[row] = xcell->asDate(na, wb_.offset());
           break;
         case CELL_NUMERIC:
+          Rcpp::warning(""Coercing numeric to date in [%i, %i]"",
+                        i + 1, j + 1);
+          REAL(col)[row] = xcell->asDate(na, wb_.offset());
+          break;
         case CELL_TEXT:
-          Rcpp::warning(""[%i, %i]: expecting date: got '%s'"",
-                        i + 1, j + 1, xcell->asStdString(wb_.stringTable()));
+          Rcpp::warning(""Expecting date in [%i, %i]: got '%s'"",
+                        i + 1, j + 1, xcell->asStdString(na, wb_.stringTable(),
+                                                         wb_.dateStyles()));
+          REAL(col)[row] = NA_REAL;
+          break;
+        }
+        break;
+
+      case COL_NUMERIC:
+        switch(type) {
+        case CELL_BLANK:
+          REAL(col)[row] = NA_REAL;
+          break;
+        case CELL_LOGICAL:
+          Rcpp::warning(""Coercing boolean to numeric in [%i, %i]"",
+                        i + 1, j + 1);
+          REAL(col)[row] = xcell->asDouble(na);
+          break;
+        case CELL_DATE:
+          // print date string here, when/if possible
+          Rcpp::warning(""Expecting numeric in [%i, %i]: got a date"",
+                        i + 1, j + 1);
           REAL(col)[row] = NA_REAL;
           break;
+        case CELL_NUMERIC:
+          REAL(col)[row] = xcell->asDouble(na);
+          break;
+        case CELL_TEXT:
+        {
+          std::string num_string = xcell->asStdString(na, wb_.stringTable(),
+                                                      wb_.dateStyles());
+          double num_num;
+          bool success = doubleFromString(num_string, num_num);
+          if (success) {
+            Rcpp::warning(""Coercing text to numeric in [%i, %i]: '%s'"",
+                          i + 1, j + 1, num_string);
+            REAL(col)[row] = num_num;
+          } else {
+            Rcpp::warning(""Expecting numeric in [%i, %i]: got '%s'"",
+                          i + 1, j + 1, num_string);
+            REAL(col)[row] = NA_REAL;
+          }
+        }
+          break;
         }
         break;
+
       case COL_TEXT:
-        if (type == CELL_BLANK) {
+        // not issuing warnings for NAs or coercion, because ""text"" is the
+        // fallback column type and there are too many warnings to be helpful
+        switch(type) {
+        case CELL_BLANK:
           SET_STRING_ELT(col, row, NA_STRING);
-        } else {
+          break;
+        case CELL_LOGICAL:
+          if (xcell->asInteger(na)) {
+            SET_STRING_ELT(col, row, Rf_mkChar(""TRUE""));
+          } else {
+            SET_STRING_ELT(col, row, Rf_mkChar(""FALSE""));
+          }
+          break;
+        case CELL_DATE:
+          // use date string here, when/if possible
+          SET_STRING_ELT(col, row, xcell->asCharSxp(na, wb_.stringTable()));
+          break;
+        case CELL_NUMERIC:
+        case CELL_TEXT:
+        {
           SET_STRING_ELT(col, row, xcell->asCharSxp(na, wb_.stringTable()));
+        }
+          break;
         }
         break;
+
       case COL_LIST:
         switch(type) {
         case CELL_BLANK: {
           SET_VECTOR_ELT(col, row, Rf_ScalarLogical(NA_LOGICAL));
           break;
         }
-        case CELL_NUMERIC: {
-          SET_VECTOR_ELT(col, row, Rf_ScalarReal(xcell->asDouble(na)));
+        case CELL_LOGICAL: {
+          SET_VECTOR_ELT(col, row, Rf_ScalarLogical(xcell->asInteger(na)));
           break;
         }
         case CELL_DATE: {
@@ -215,6 +304,10 @@ class XlsxWorkSheet {
           SET_VECTOR_ELT(col, row, cell_val);
           break;
         }
+        case CELL_NUMERIC: {
+          SET_VECTOR_ELT(col, row, Rf_ScalarReal(xcell->asDouble(na)));
+          break;
+        }
         case CELL_TEXT: {
           Rcpp::CharacterVector rStringVector = Rcpp::CharacterVector(1, NA_STRING);
           SET_STRING_ELT(rStringVector, 0, xcell->asCharSxp(na, wb_.stringTable()));
@@ -223,7 +316,7 @@ class XlsxWorkSheet {
         }
         }
       }
-    xcell++;
+      xcell++;
     }
 
     return removeSkippedColumns(cols, names, types);
@@ -269,7 +362,7 @@ class XlsxWorkSheet {
     ncol_ = 0;
 
     // empty sheet case
-    if (cells_.size() == 0) {
+    if (cells_.empty()) {
       return;
     }
 

---FILE: src/utils.h---
@@ -1,6 +1,61 @@
+#ifndef UTILS_
+#define UTILS_
 
+#include <cerrno>
+#include ""StringSet.h""
+
+// 18.2.28 workbookPr (Workbook Properties) p1582
+// date1904:
+// Value that indicates whether to use a 1900 or 1904 date system when
+// converting serial date-times in the workbook to dates.
+// A value of 1 or true indicates the workbook uses the 1904 date system.
+// A value of 0 or false indicates the workbook uses the 1900 date system. (See
+// 18.17.4.1 for the definition of the date systems.)
+// The default value for this attribute is false.
 inline double dateOffset(bool is1904) {
   // as.numeric(as.Date(""1899-12-30""))
   // as.numeric(as.Date(""1904-01-01""))
   return is1904 ? 24107 : 25569;
 }
+
+// Simple parser: does not check that order of numbers and letters is correct
+inline std::pair<int, int> parseRef(const char* ref) {
+  int col = 0, row = 0;
+
+  for (const char* cur = ref; *cur != '\0'; ++cur) {
+    if (*cur >= '0' && *cur <= '9') {
+      row = row * 10 + (*cur - '0');
+    } else if (*cur >= 'A' && *cur <= 'Z') {
+      col = 26 * col + (*cur - 'A' + 1);
+    } else {
+      Rcpp::stop(""Invalid character '%s' in cell ref '%s'"", *cur, ref);
+    }
+  }
+
+  return std::make_pair(row - 1, col - 1); // zero indexed
+}
+
+inline bool logicalFromString(std::string maybe_tf, bool *out) {
+  bool matches = false;
+  if (Rf_StringTrue(maybe_tf.c_str())) {
+    *out = true;
+    matches = true;
+  } else if (Rf_StringFalse(maybe_tf.c_str())) {
+    *out = false;
+    matches = true;
+  }
+  return matches;
+}
+
+inline bool doubleFromString(std::string mystring, double& out) {
+  char* e;
+  errno = 0;
+  out = std::strtod(mystring.c_str(), &e);
+  if (*e != '\0' ||  // error, we didn't consume the entire string
+      errno != 0 ) { // error, overflow or underflow
+    return false;
+  }
+  return true;
+}
+
+#endif

---FILE: tests/testthat/test-col-types.R---
@@ -48,48 +48,47 @@ test_that(""col_types are recycled"", {
   expect_match(vapply(df, class, character(1)), ""character"")
 })
 
-test_that(""inappropriate col_types generate warning"", {
-  expect_warning(
-    read_excel(test_sheet(""iris-excel.xlsx""),
-               col_types = c(""numeric"", ""text"", ""numeric"", ""numeric"", ""numeric"")),
-    ""expecting numeric""
-  )
-  expect_warning(
-    read_excel(test_sheet(""iris-excel.xls""),
-               col_types = c(""numeric"", ""text"", ""numeric"", ""numeric"", ""numeric"")),
-    ""expecting numeric""
-  )
-})
-
-test_that(""types imputed & read correctly [xlsx]"", {
-  types <- read_excel(test_sheet(""types.xlsx""))
-  expect_is(types$number, ""numeric"")
-  expect_is(types$string, ""character"")
-  expect_is(types$boolean, ""numeric"")
+test_that(""types guessed correctly [xlsx]"", {
+  types <- read_excel(test_sheet(""types.xlsx""), sheet = ""guess_me"")
+  expect_is(types$X__1, ""logical"")
+  expect_is(types$blank, ""logical"")
+  expect_is(types$boolean, ""logical"")
   expect_is(types$date, ""POSIXct"")
-  expect_is(types$string_in_row_3, ""character"")
-  skip(""switch expectation to logical (vs numeric) when possible (for xls too!)"")
+  expect_is(types$numeric, ""numeric"")
+  expect_is(types$text, ""character"")
+  expect_true(all(vapply(types, function(x) is.na(x[3]), logical(1))))
 })
 
-test_that(""types imputed & read correctly [xls]"", {
-  types <- read_excel(test_sheet(""types.xls""))
-  expect_is(types$number, ""numeric"")
-  expect_is(types$string, ""character"")
-  expect_is(types$boolean, ""numeric"")
-  #expect_is(types$date, ""POSIXct"")
-  expect_is(types$string_in_row_3, ""character"")
-  skip(""activate date expectation when xls formula dates are sorted"")
+test_that(""types guessed correctly [xls]"", {
+  types <- read_excel(test_sheet(""types.xls""), sheet = ""guess_me"")
+  expect_is(types$X__1, ""logical"")
+  expect_is(types$blank, ""logical"")
+  expect_is(types$boolean, ""logical"")
+  expect_is(types$date, ""POSIXct"")
+  expect_is(types$numeric, ""numeric"")
+  expect_is(types$text, ""character"")
+  expect_true(all(vapply(types, function(x) is.na(x[3]), logical(1))))
 })
 
 test_that(""guess_max is honored for col_types"", {
   expect_warning(
-    types <- read_excel(test_sheet(""types.xlsx""), guess_max = 2),
-    ""expecting numeric""
+    types <- read_excel(
+      test_sheet(""types.xlsx""),
+      sheet = ""guess_max"",
+      guess_max = 2
+    ),
+    ""Expecting numeric"",
+    all = TRUE
   )
   expect_identical(types$string_in_row_3, c(1, 2, NA))
   expect_warning(
-    types <- read_excel(test_sheet(""types.xls""), guess_max = 2),
-    ""expecting numeric""
+    types <- read_excel(
+      test_sheet(""types.xls""),
+      sheet = ""guess_max"",
+      guess_max = 2
+    ),
+    ""Expecting numeric"",
+    all = TRUE
   )
   expect_identical(types$string_in_row_3, c(1, 2, NA))
 })
@@ -133,3 +132,91 @@ test_that(""setting `na` works in list columns [xls]"", {
   na_defined <-  read_excel(test_sheet(""list_type.xls""), col_types = ""list"", na = ""a"")
   expect_equal(na_defined$var1[[3]], NA)
 })
+
+test_that(""contaminated, explicit logical is read as logical"", {
+  ## xls
+  expect_warning(
+    df <- read_excel(test_sheet(""types.xls""), sheet = ""logical_coercion"",
+                     col_types = c(""logical"", ""text"")),
+    ""Expecting logical"",
+    all = TRUE
+  )
+  expect_is(df$logical, ""logical"")
+  should_be_NA <- df$explanation %in% c(""string not logical"", ""blank"", ""date"")
+  expect_false(anyNA(df$logical[!should_be_NA]))
+
+  ## xlsx
+  expect_warning(
+    df <- read_excel(test_sheet(""types.xlsx""), sheet = ""logical_coercion"",
+                     col_types = c(""logical"", ""text"")),
+    ""Expecting logical"",
+    all = TRUE
+  )
+  expect_is(df$logical, ""logical"")
+  should_be_NA <- df$explanation %in% c(""string not logical"", ""blank"", ""date"")
+  expect_false(anyNA(df$logical[!should_be_NA]))
+})
+
+test_that(""contaminated, explicit date is read as date"", {
+  ## xls
+  expect_warning(
+    df <- read_excel(test_sheet(""types.xls""), sheet = ""date_coercion"",
+                     col_types = ""date""),
+    ""Expecting date|Coercing numeric"",
+    all = TRUE
+  )
+  expect_is(df$date, ""POSIXct"")
+  expect_false(anyNA(df$date[c(1, 5, 6, 7)]))
+  expect_true(all(is.na(df$date[c(2, 3, 4)])))
+  expect_identical(df$date[6], as.POSIXct(""2012-01-02 UTC"", tz = ""UTC""))
+
+  ## xlsx
+  expect_warning(
+    df <- read_excel(test_sheet(""types.xlsx""), sheet = ""date_coercion"",
+                     col_types = ""date""),
+    ""Expecting date|Coercing numeric"",
+    all = TRUE
+  )
+  expect_is(df$date, ""POSIXct"")
+  expect_false(anyNA(df$date[c(1, 5, 6, 7)]))
+  expect_true(all(is.na(df$date[c(2, 3, 4)])))
+  expect_identical(df$date[6], as.POSIXct(""2012-01-02 UTC"", tz = ""UTC""))
+})
+
+test_that(""contaminated, explicit numeric is read as numeric"", {
+  ## xls
+  expect_warning(
+    df <- read_excel(test_sheet(""types.xls""), sheet = ""numeric_coercion"",
+                     col_types = ""numeric""),
+    ""Expecting numeric|Coercing boolean|Coercing text"",
+    all = TRUE
+  )
+  expect_is(df$numeric, ""numeric"")
+  expect_false(anyNA(df$numeric[c(1, 2, 4, 7)]))
+  expect_equal(df$numeric[2], 72) # ""Number stored as text""
+
+  ## xlsx
+  expect_warning(
+    df <- read_excel(test_sheet(""types.xlsx""), sheet = ""numeric_coercion"",
+                     col_types = ""numeric""),
+    ""Expecting numeric|Coercing boolean|Coercing text"",
+    all = TRUE
+  )
+  expect_is(df$numeric, ""numeric"")
+  expect_false(anyNA(df$numeric[c(1, 2, 4, 7)]))
+  expect_equal(df$numeric[2], 72) # ""Number stored as text""
+})
+
+test_that(""contaminated, explicit text is read as text"", {
+  ## xls
+  df <- read_excel(test_sheet(""types.xls""), sheet = ""text_coercion"",
+                   col_types = ""text"")
+  expect_is(df$text, ""character"")
+  expect_false(anyNA(df$text[-2]))
+
+  ## xlsx
+  df <- read_excel(test_sheet(""types.xlsx""), sheet = ""text_coercion"",
+                   col_types = ""text"")
+  expect_is(df$text, ""character"")
+  expect_false(anyNA(df$text[-2]))
+})

---FILE: tests/testthat/test-empty.R---
@@ -30,9 +30,9 @@ test_that(""completely empty sheets are handled [xls]"", {
 
 test_that(""sheets with column names only are handled"", {
   out <- read_excel(test_sheet(""empty-sheets.xlsx""), ""header_only"")
-  expect_identical(out, tibble::tibble(var1 = numeric(), var2 = numeric()))
+  expect_identical(out, tibble::tibble(var1 = logical(), var2 = logical()))
   out <- read_excel(test_sheet(""empty-sheets.xls""), ""header_only"")
-  expect_identical(out, tibble::tibble(var1 = numeric(), var2 = numeric()))
+  expect_identical(out, tibble::tibble(var1 = logical(), var2 = logical()))
 })
 
 test_that(""non-empty sheets act that way if we skip past everything"", {

---FILE: tests/testthat/test-missing-values.R---
@@ -65,21 +65,6 @@ test_that(""na arg allows multiple strings [xlsx]"", {
   expect_true(all(is.na(df$y))) # formula column
 })
 
-test_that(""text values in numeric column gives warning & NA"", {
-  expect_warning(
-    df <- read_excel(test_sheet(""missing-values.xls""),
-                     col_types = rep(""numeric"", 2)),
-    ""expecting numeric""
-  )
-  expect_equal(df$x, c(NA, 1, 1))
-  expect_warning(
-    df <- read_excel(test_sheet(""missing-values.xlsx""),
-                     col_types = rep(""numeric"", 2)),
-    ""expecting numeric""
-  )
-  expect_equal(df$x, c(NA, 1, 1))
-})
-
 test_that(""empty first column gives valid data.frame"", {
   df <- read_excel(test_sheet(""missing-first-column.xlsx""), col_names = FALSE)
   expect_equal(nrow(df), length(df[[2]]))
@@ -93,11 +78,11 @@ test_that(""empty named column gives NA column"", {
   expect_equal(ncol(df1), 4)
   expect_equal(names(df1)[2], ""y"")
   expect_true(all(is.na(df1$y)))
-  expect_true(all(is.numeric(df1$y)))
+  expect_true(all(is.logical(df1$y)))
   expect_equal(ncol(df2), 4)
   expect_equal(names(df2)[2], ""y"")
   expect_true(all(is.na(df2$y)))
-  expect_true(all(is.numeric(df2$y)))
+  expect_true(all(is.logical(df2$y)))
 })
 
 test_that(""empty (styled) cells are not loaded, but can survive as NA [xlsx]"", {
@@ -111,9 +96,9 @@ test_that(""empty (styled) cells are not loaded, but can survive as NA [xlsx]"", {
   out <- read_excel(test_sheet(""style-only-cells.xlsx""))
   df <- tibble::tibble(
     var1 = c(""val1,1"", ""val2,1"", ""val3,1""),
-    var2 = NA_real_,
+    var2 = NA,
     var3 = c(""aa"", ""bb"", ""cc""),
-    X__1 = NA_real_,
+    X__1 = NA,
     var5 = c(1, 2, 3)
   )
   expect_equal(out, df)
@@ -123,9 +108,9 @@ test_that(""empty (styled) cells are not loaded, but can survive as NA [xls]"", {
   out <- read_excel(test_sheet(""style-only-cells.xls""))
   df <- tibble::tibble(
     var1 = c(""val1,1"", ""val2,1"", ""val3,1""),
-    var2 = NA_real_,
+    var2 = NA,
     var3 = c(""aa"", ""bb"", ""cc""),
-    X__1 = NA_real_,
+    X__1 = NA,
     var5 = c(1, 2, 3)
   )
   expect_equal(out, df)",True,False,Documentation / Formatting,7
tidyverse,readxl,aa95660d9e2cbf852e7cb7e2ce5497b89b1a57cb,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-02-26T15:24:39Z,GitHub,noreply@github.com,2017-02-26T15:24:39Z,"Handle xls record type BoolErr (number 517); fixes #259, relates to #… (#274)

* Handle xls record type BoolErr (number 517); fixes #259, relates to #270, relates to #62

This record type is also used for errors, but only errors that are not a result of a formula, which is most of them. So if OP on #62 provides an example, we could conceivably do more in the else branch here.

* Fix NEWS",NEWS.md;src/XlsCell.h;tests/testthat/sheets/types.xls;tests/testthat/sheets/types.xlsx;tests/testthat/test-col-types.R,False,True,True,False,44,31,75,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # readxl 0.1.1.9000
 
+* Boolean cells are now detected in xls. Suppresses message `""Unknown type: 517""`. For now, Boolean cells in both xls and xlsx become numeric, with values 0 and 1. (#274, #259 @jennybc)
+
 * xls files written by some third party software report both row and column dimensions as 0-indexed, which prevents libxls from reading the last column. Small change to libxls restores access to those cells. (#273, #180, #152, #99 @jennybc)
 
 * `col_types = ""list""` loads data as a list of length-1 vectors, that are typed using the logic from `col_types = NULL`, but on a cell-by-cell basis (#262 @gergness).

---FILE: src/XlsCell.h---
@@ -34,16 +34,29 @@ inline CellType cellType(const xls::st_cell::st_cell_data cell,
                          xls::st_xf* styles,
                          const std::set<int>& customDateFormats,
                          const StringSet &na = """") {
-  // Find codes in [MS-XLS] S2.3.2 (p175).
+  // [MS-XLS] - v20161017, Release: October 17, 2016
+  //
+  // In 2.2.1 Cell Table on p80:
+  // ""Cells are specified by any of the records specified in the CELL rule.""
+  // (section 2.1.7.20.6).
+  // In 2.1.7.20.6 on p74, here is the CELL rule:
+  // CELL = FORMULA / Blank / MulBlank / RK / MulRk / BoolErr / Number / LabelSst
+  //
+  // 2.3 Record Enumeration
+  // Has 2 tables associating each record type value with a name and number.
+  // 2.3.1 starting p168 is ordered by name
+  // 2.3.2 starting p180 is ordered by number
+  //
   // See xls_addCell for those used for cells
+  // and xlsstruct.h to confirm record numbers
   switch(cell.id) {
-  case 253: // LabelSst
-  case 516: // Label
+  case 253: // 0x00FD LabelSst
+  case 516: // 0x0204 Label
     return na.contains((char*) cell.str) ? CELL_BLANK : CELL_TEXT;
     break;
 
-  case 6:    // formula
-  case 1030: // formula (Apple Numbers Bug)
+  case 6:    // 0x0006 formula
+  case 1030: // 0x0406 formula (Apple Numbers Bug)
     if (cell.l == 0) {
       return na.contains(cell.d) ? CELL_BLANK : CELL_NUMERIC;
     } else {
@@ -55,9 +68,9 @@ inline CellType cellType(const xls::st_cell::st_cell_data cell,
     }
     break;
 
-  case 189: // MulRk
-  case 515: // Number
-  case 638: // Rk
+  case 189: // 0x00BD MulRk
+  case 515: // 0x0203 Number
+  case 638: // 0x027E Rk
     {
       if (na.contains(cell.d))
         return CELL_BLANK;
@@ -70,11 +83,22 @@ inline CellType cellType(const xls::st_cell::st_cell_data cell,
     }
     break;
 
-  case 190: // MulBlank
-  case 513: // Blank
+  case 190: // 0x00BE MulBlank
+  case 513: // 0x0201 Blank
     return CELL_BLANK;
     break;
 
+  case 517: // 0x0205 BoolErr
+    {
+      if (!strcmp((char *) cell.str, ""bool"")) {
+        // switch to CELL_LOGICAL once exists; cell.d is 0/1 for FALSE/TRUE
+        return CELL_NUMERIC;
+      } else {
+        return CELL_TEXT;
+      }
+    }
+    break;
+
   default:
     Rcpp::Rcout << ""Unknown type: "" << cell.id << ""\n"";
   return CELL_NUMERIC;

---FILE: tests/testthat/test-col-types.R---
@@ -11,7 +11,7 @@ test_that(""illegal col_types are rejected"", {
 test_that(""request for 'blank' col type gets deprecation message and fix"", {
   expect_message(
     read_excel(test_sheet(""types.xlsx""),
-               col_types = rep_len(c(""blank"", ""text""), length.out = 5)),
+               col_types = rep_len(c(""blank"", ""text""), length.out = 6)),
     ""`col_type = \""blank\""` deprecated. Use \""skip\"" instead."",
     fixed = TRUE
   )
@@ -68,27 +68,17 @@ test_that(""types imputed & read correctly [xlsx]"", {
   expect_is(types$boolean, ""numeric"")
   expect_is(types$date, ""POSIXct"")
   expect_is(types$string_in_row_3, ""character"")
-  skip(""switch expecation to logical (vs numeric) when possible"")
+  skip(""switch expectation to logical (vs numeric) when possible (for xls too!)"")
 })
 
 test_that(""types imputed & read correctly [xls]"", {
-  expect_output(
-    ## valgrind reports this
-    ## Conditional jump or move depends on uninitialised value(s)
-    types <- read_excel(test_sheet(""types.xls"")),
-    ""Unknown type: 517""
-    ## definitely due to these 'Unknown type: 517' msgs
-    ## line 52 in ColSpec.h
-    ##   Rcpp::Rcout << ""Unknown type: "" << cell.id << ""\n"";
-    ## if I skip this test, memcheck report is as clean as it ever gets
-    ## https://github.com/tidyverse/readxl/issues/259
-  )
+  types <- read_excel(test_sheet(""types.xls""))
   expect_is(types$number, ""numeric"")
   expect_is(types$string, ""character"")
-  #expect_is(types$boolean, ""numeric"")
+  expect_is(types$boolean, ""numeric"")
   #expect_is(types$date, ""POSIXct"")
   expect_is(types$string_in_row_3, ""character"")
-  skip(""revisit these expectations when xls record type 517 is handled"")
+  skip(""activate date expectation when xls formula dates are sorted"")
 })
 
 test_that(""guess_max is honored for col_types"", {
@@ -97,12 +87,9 @@ test_that(""guess_max is honored for col_types"", {
     ""expecting numeric""
   )
   expect_identical(types$string_in_row_3, c(1, 2, NA))
-  expect_output(
-    expect_warning(
-      types <- read_excel(test_sheet(""types.xls""), guess_max = 2),
-      ""expecting numeric""
-    ),
-    ""Unknown type: 517""
+  expect_warning(
+    types <- read_excel(test_sheet(""types.xls""), guess_max = 2),
+    ""expecting numeric""
   )
   expect_identical(types$string_in_row_3, c(1, 2, NA))
 })",True,False,Implementation / Logic,6
tidyverse,readxl,92b7b1641d733dde005bda00e4a9712efd51eb1d,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-02-25T15:51:05Z,GitHub,noreply@github.com,2017-02-25T15:51:05Z,"Patch xls.c to read all cols in xls written by some third-party s/w; fixes #152, fixes #99 (#273)",NEWS.md;src/xls.c;tests/testthat/sheets/mtcars.xls;tests/testthat/test-compatibility.R,False,True,True,False,13,1,14,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # readxl 0.1.1.9000
 
+* xls files written by some third party software report both row and column dimensions as 0-indexed, which prevents libxls from reading the last column. Small change to libxls restores access to those cells. (#273, #180, #152, #99 @jennybc)
+
 * `col_types = ""list""` loads data as a list of length-1 vectors, that are typed using the logic from `col_types = NULL`, but on a cell-by-cell basis (#262 @gergness).
 
 * A user-specified `col_types` of length one will be replicated to have length equal to the number of columns. (#127, #114, #261 @jennybc)

---FILE: src/xls.c---
@@ -1450,7 +1450,7 @@ xlsCell	*xls_cell(xlsWorkSheet* pWS, WORD cellRow, WORD cellCol)
 
     if(cellRow > pWS->rows.lastrow) return NULL;
     row = &pWS->rows.row[cellRow];
-    if(cellCol >= row->lcell) return NULL;
+    if(cellCol > row->lcell) return NULL;
 
     return &row->cells.cell[cellCol];
 }

---FILE: tests/testthat/test-compatibility.R---
@@ -6,3 +6,13 @@ test_that(""can read document from google doc"", {
 
   expect_equal(iris_1, iris_2)
 })
+
+## #180, #152, #99
+## Some 3rd-party s/w writes xls where lastcol is 0-indexed, like lastrow
+## Changed an inequality in xls_cell() in  xls.c to accomodate this
+## WriteXLS is (or, rather, wraps) such s/w, so it's good source of such xls.
+## WriteXLS::WriteXLS(head(mtcars), file.path(""tests"", ""testthat"", ""sheets"", ""mtcars.xls""))
+test_that(""can tolerate xls that underreports number of columns"", {
+  df <- read_excel(test_sheet(""mtcars.xls""))
+  expect_identical(ncol(df), ncol(mtcars))
+})",True,False,Implementation / Logic,6
tidyverse,readxl,d4b4ea9d9c9218b048dda790a3c0e3970ec83278,Greg Freedman Ellis,greg.freedman@gmail.com,2017-02-22T17:37:42Z,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-02-22T17:37:42Z,"Add ability to read column as a list of length-1 vectors closes #262 … (#265)

* Add ability to read column as a list of length-1 vectors closes #262 (rebase of #256)

* Reorder ColType switches for consistency

* Add tests for empty cell for list type columns (and fix for .xlsx)

* Improve description of list type columns

* Use SET_VECTOR_ELT

* Make list-col tests more stringent and use more C

* Fix for multi-character strings",NEWS.md;R/read_excel.R;man/read_excel.Rd;src/CellType.h;src/ColSpec.h;src/XlsWorkSheet.cpp;src/XlsWorkSheet.h;src/XlsxWorkSheet.cpp;src/XlsxWorkSheet.h;tests/testthat/sheets/list_type.xls;tests/testthat/sheets/list_type.xlsx;tests/testthat/test-col-types.R,False,True,True,False,169,78,247,"---FILE: NEWS.md---
@@ -1,5 +1,8 @@
 # readxl 0.1.1.9000
 
+* `col_types = ""list""` loads data as a list of length-1 vectors, that are typed using
+the logic from `col_types = NULL`, but on a cell-by-cell basis (#262 @gergness).
+
 *currently much of this applies only to xlsx, but will be extended to xls*
 
 * A user-specified `col_types` of length one will be replicated to have length equal to the number of columns. (#127, #114, #261 @jennybc)

---FILE: R/read_excel.R---
@@ -14,8 +14,10 @@ NULL
 #'   unskipped column.
 #' @param col_types Either `NULL` to guess from the spreadsheet or a character
 #'   vector containing one entry per column from these options: ""skip"",
-#'   ""numeric"", ""date"" or ""text"". The content of a cell in a skipped column is
-#'   never read and that column will not appear in the data frame output.
+#'   ""numeric"", ""date"", ""text"" or ""list"". The content of a cell in a skipped column is
+#'   never read and that column will not appear in the data frame output. A list cell
+#'   loads a column as a list of length 1 vectors, which are typed using the type
+#'   guessing logic from `col_types = NULL`, but on a cell-by-cell basis.
 #' @param na Character vector of strings to use for missing values. By default,
 #'   readxl treats blank cells as missing data.
 #' @param skip Number of rows to skip before reading any data. Leading blank
@@ -146,7 +148,7 @@ check_col_types <- function(col_types) {
     col_types[blank] <- ""skip""
   }
 
-  accepted_types <- c(""skip"", ""numeric"", ""date"", ""text"")
+  accepted_types <- c(""skip"", ""numeric"", ""date"", ""text"", ""list"")
   ok <- col_types %in% accepted_types
   if (any(!ok)) {
     info <- paste(

---FILE: man/read_excel.Rd---
@@ -29,8 +29,10 @@ unskipped column.}
 
 \item{col_types}{Either \code{NULL} to guess from the spreadsheet or a character
 vector containing one entry per column from these options: ""skip"",
-""numeric"", ""date"" or ""text"". The content of a cell in a skipped column is
-never read and that column will not appear in the data frame output.}
+""numeric"", ""date"", ""text"" or ""list"". The content of a cell in a skipped column is
+never read and that column will not appear in the data frame output. A list cell
+loads a column as a list of length 1 vectors, which are typed using the type
+guessing logic from \code{col_types = NULL}, but on a cell-by-cell basis.}
 
 \item{na}{Character vector of strings to use for missing values. By default,
 readxl treats blank cells as missing data.}

---FILE: src/CellType.h---
@@ -5,35 +5,51 @@
 #include <libxls/xls.h>
 #include ""StringSet.h""
 
-// CELL_BLANK can arise only from an individual cell during type guessing
-// important that it be the first entry = default type, instead of ...
-// CELL_SKIP  which can arise only as a user-specified column type
 enum CellType {
   CELL_BLANK,
-  CELL_SKIP,
   CELL_DATE,
   CELL_NUMERIC,
   CELL_TEXT
 };
 
+// COL_BLANK is a column full of CELL_BLANKs,
+// while COL_SKIP is a column the user-specified type
+enum ColType {
+  COL_BLANK,
+  COL_DATE,
+  COL_NUMERIC,
+  COL_TEXT,
+  COL_LIST,
+  COL_SKIP
+};
+
+// ColType enum is ordered such that a simple cast
+// is sufficient to convert from CellType (user-specified
+// columns come after cell types)
+ColType inline as_ColType(CellType cell) {
+  return (ColType) cell;
+}
+
 bool inline isDateTime(int id, const std::set<int> custom);
 
-inline std::vector<CellType> cellTypes(Rcpp::CharacterVector x) {
-  std::vector<CellType> types;
+inline std::vector<ColType> colTypeStrings(Rcpp::CharacterVector x) {
+  std::vector<ColType> types;
   types.reserve(x.size());
 
   for (int i = 0; i < x.size(); ++i) {
     std::string type(x[i]);
     if (type == ""blank"") {
-      types.push_back(CELL_BLANK);
+      types.push_back(COL_BLANK);
     } else if (type == ""date"") {
-      types.push_back(CELL_DATE);
+      types.push_back(COL_DATE);
     } else if (type == ""numeric"") {
-      types.push_back(CELL_NUMERIC);
-    } else if (type == ""skip"") {
-      types.push_back(CELL_SKIP);
+      types.push_back(COL_NUMERIC);
     } else if (type == ""text"") {
-      types.push_back(CELL_TEXT);
+      types.push_back(COL_TEXT);
+    } else if (type == ""list"") {
+      types.push_back(COL_LIST);
+    } else if (type == ""skip"") {
+      types.push_back(COL_SKIP);
     } else {
       Rcpp::stop(""Unknown type '%s' at position %i"", type, i + 1);
     }
@@ -42,13 +58,14 @@ inline std::vector<CellType> cellTypes(Rcpp::CharacterVector x) {
   return types;
 }
 
-inline std::string cellTypeDesc(CellType type) {
+inline std::string colTypeDesc(ColType type) {
   switch(type) {
-  case CELL_BLANK:   return ""blank"";
-  case CELL_DATE:    return ""date"";
-  case CELL_NUMERIC: return ""numeric"";
-  case CELL_SKIP:    return ""skip"";
-  case CELL_TEXT:    return ""text"";
+  case COL_BLANK:   return ""blank"";
+  case COL_DATE:    return ""date"";
+  case COL_NUMERIC: return ""numeric"";
+  case COL_TEXT:    return ""text"";
+  case COL_LIST:    return ""list"";
+  case COL_SKIP:    return ""skip"";
   }
   return ""???"";
 }
@@ -144,48 +161,49 @@ inline bool isDateFormat(std::string x) {
   return false;
 }
 
-inline Rcpp::RObject makeCol(CellType type, int n) {
+inline Rcpp::RObject makeCol(ColType type, int n) {
   switch(type) {
-  case CELL_BLANK:
+  case COL_BLANK:
+  case COL_SKIP:
     return R_NilValue;
     break;
-  case CELL_DATE: {
+  case COL_DATE: {
     Rcpp::RObject col = Rcpp::NumericVector(n, NA_REAL);
     col.attr(""class"") = Rcpp::CharacterVector::create(""POSIXct"", ""POSIXt"");
     col.attr(""tzone"") = ""UTC"";
     return col;
   }
     break;
-  case CELL_NUMERIC:
+  case COL_NUMERIC:
     return Rcpp::NumericVector(n, NA_REAL);
     break;
-  case CELL_SKIP:
-    return R_NilValue;
-    break;
-  case CELL_TEXT:
+  case COL_TEXT:
     return Rcpp::CharacterVector(n, NA_STRING);
     break;
+  case COL_LIST:
+    return Rcpp::List(n, Rcpp::LogicalVector(1, NA_LOGICAL));
+    break;
   }
 
   return R_NilValue;
 }
 
 inline Rcpp::List removeSkippedColumns(Rcpp::List cols,
                                        Rcpp::CharacterVector names,
-                                       std::vector<CellType> types) {
+                                       std::vector<ColType> types) {
   int p = cols.size();
 
   int p_out = 0;
   for (int j = 0; j < p; ++j) {
-    if (types[j] != CELL_SKIP)
+    if (types[j] != COL_SKIP)
       p_out++;
   }
 
   Rcpp::List out(p_out);
   Rcpp::CharacterVector names_out(p_out);
   int j_out = 0;
   for (int j = 0; j < p; ++j) {
-    if (types[j] == CELL_SKIP) {
+    if (types[j] == COL_SKIP) {
       continue;
     }
 

---FILE: src/ColSpec.h---
@@ -4,7 +4,7 @@
 #include <Rcpp.h>
 #include ""CellType.h""
 
-inline std::vector<CellType> recycleTypes(std::vector<CellType> types,
+inline std::vector<ColType> recycleTypes(std::vector<ColType> types,
                                           int ncol) {
   if (types.size() == 1) {
     types.resize(ncol);
@@ -14,7 +14,7 @@ inline std::vector<CellType> recycleTypes(std::vector<CellType> types,
 }
 
 inline Rcpp::CharacterVector reconcileNames(Rcpp::CharacterVector names,
-                                            const std::vector<CellType>& types,
+                                            const std::vector<ColType>& types,
                                             int sheet) {
   size_t ncol_names = names.size();
   size_t ncol_types = types.size();
@@ -25,7 +25,7 @@ inline Rcpp::CharacterVector reconcileNames(Rcpp::CharacterVector names,
 
   size_t ncol_noskip = 0;
   for (size_t i = 0; i < types.size(); i++) {
-    if (types[i] != CELL_SKIP) {
+    if (types[i] != COL_SKIP) {
       ncol_noskip++;
     }
   }
@@ -37,7 +37,7 @@ inline Rcpp::CharacterVector reconcileNames(Rcpp::CharacterVector names,
   Rcpp::CharacterVector newNames(ncol_types, """");
   size_t j_short = 0;
   for (size_t j_long = 0; j_long < ncol_types; ++j_long) {
-    if (types[j_long] == CELL_SKIP) {
+    if (types[j_long] == COL_SKIP) {
       continue;
     }
     newNames[j_long] = names[j_short];

---FILE: src/XlsWorkSheet.cpp---
@@ -17,19 +17,19 @@ CharacterVector xls_col_types(std::string path, std::vector<std::string> na,
                               int sheet = 0, int nskip = 0,
                               int guess_max = 1000, bool has_col_names = false) {
   XlsWorkBook wb = XlsWorkBook(path);
-  std::vector<CellType> types = wb.sheet(sheet).colTypes(na, nskip + has_col_names, guess_max);
+  std::vector<ColType> types = wb.sheet(sheet).colTypes(na, nskip + has_col_names, guess_max);
 
   CharacterVector out(types.size());
   for (size_t i = 0; i < types.size(); ++i) {
-    out[i] = cellTypeDesc(types[i]);
+    out[i] = colTypeDesc(types[i]);
   }
 
   if (has_col_names) {
     // blank columns with a name aren't blank
     CharacterVector names = xls_col_names(path, sheet, nskip);
     for (size_t i = 0; i < types.size(); ++i) {
-      if (types[i] == CELL_BLANK && names[i] != NA_STRING && names[i] != """")
-        out[i] = cellTypeDesc(CELL_NUMERIC);
+      if (types[i] == COL_BLANK && names[i] != NA_STRING && names[i] != """")
+        out[i] = colTypeDesc(COL_NUMERIC);
     }
   }
 
@@ -47,6 +47,6 @@ List xls_cols(std::string path, int i, CharacterVector col_names,
                col_names.size(), col_types.size());
   }
 
-  std::vector<CellType> types = cellTypes(col_types);
+  std::vector<ColType> types = colTypeStrings(col_types);
   return sheet.readCols(col_names, types, na, nskip);
 }

---FILE: src/XlsWorkSheet.h---
@@ -67,9 +67,9 @@ class XlsWorkSheet {
     return out;
   }
 
-  std::vector<CellType> colTypes(const StringSet &na, int nskip = 0,
+  std::vector<ColType> colTypes(const StringSet &na, int nskip = 0,
                                  int guess_max = 1000) {
-    std::vector<CellType> types(ncol_);
+    std::vector<ColType> types(ncol_);
 
     for (int i = nskip; i < nrow_ && i < nskip + guess_max; ++i) {
       if ((i + 1) % 10000 == 0)
@@ -78,7 +78,7 @@ class XlsWorkSheet {
       xls::st_row::st_row_data row = pWS_->rows.row[i];
 
       for (int j = 0; j < ncol_; ++j) {
-        CellType type = cellType(row.cells.cell[j], &pWS_->workbook->xfs, customDateFormats_, na);
+        ColType type = as_ColType(cellType(row.cells.cell[j], &pWS_->workbook->xfs, customDateFormats_, na));
 
         // Excel is simple enough we can enforce a strict ordering
         if (type > types[j]) {
@@ -90,7 +90,7 @@ class XlsWorkSheet {
     return types;
   }
 
-  Rcpp::List readCols(Rcpp::CharacterVector names, std::vector<CellType> types,
+  Rcpp::List readCols(Rcpp::CharacterVector names, std::vector<ColType> types,
                       const StringSet &na, int nskip = 0) {
     if ((int) names.size() != ncol_ || (int) types.size() != ncol_){
       Rcpp::stop(""Received %d names and %d types, but worksheet contains %d columns."",
@@ -117,29 +117,26 @@ class XlsWorkSheet {
 
         // Needs to compare to actual cell type to give warnings
         switch(types[j]) {
-        case CELL_BLANK:
+        case COL_BLANK:
+        case COL_SKIP:
           break;
-        case CELL_SKIP:
-          break;
-        case CELL_NUMERIC:
+        case COL_NUMERIC:
           switch(type) {
           case CELL_BLANK:
             REAL(col)[i] = NA_REAL;
             break;
           case CELL_NUMERIC:
-          case CELL_SKIP:
           case CELL_DATE:
             REAL(col)[i] = cell.d;
             break;
-          case CELL_TEXT:
+          case COL_TEXT:
             Rcpp::warning(""Expecting numeric in [%i, %i] got `%s`"",
               i + 1, j + 1, (char*) cell.str);
             REAL(col)[i] = NA_REAL;
           }
           break;
-        case CELL_DATE:
+        case COL_DATE:
           switch(type) {
-          case CELL_SKIP:
           case CELL_BLANK:
             REAL(col)[i] = NA_REAL;
             break;
@@ -158,7 +155,7 @@ class XlsWorkSheet {
             break;
           }
           break;
-        case CELL_TEXT:
+        case COL_TEXT:
           if (type == CELL_BLANK) {
             SET_STRING_ELT(col, i, NA_STRING);
           } else {
@@ -167,6 +164,30 @@ class XlsWorkSheet {
             SET_STRING_ELT(col, i, rString);
           }
           break;
+        case COL_LIST:
+          switch(type) {
+          case CELL_BLANK: {
+            SET_VECTOR_ELT(col, i, Rf_ScalarLogical(NA_LOGICAL));
+            break;
+          }
+          case CELL_NUMERIC: {
+            SET_VECTOR_ELT(col, i, Rf_ScalarReal(cell.d));
+            break;
+          }
+          case CELL_DATE: {
+            Rcpp::RObject cell_val = Rf_ScalarReal((cell.d - offset_) * 86400);
+            cell_val.attr(""class"") = Rcpp::CharacterVector::create(""POSIXct"", ""POSIXt"");
+            cell_val.attr(""tzone"") = ""UTC"";
+            SET_VECTOR_ELT(col, i, cell_val);
+            break;
+          }
+          case CELL_TEXT: {
+            std::string stdString((char*) cell.str);
+            Rcpp::CharacterVector rString = na.contains(stdString) ? NA_STRING : Rf_mkCharCE(stdString.c_str(), CE_UTF8);
+            SET_VECTOR_ELT(col, i, rString);
+            break;
+          }
+          }
         }
       }
     }

---FILE: src/XlsxWorkSheet.cpp---
@@ -23,11 +23,11 @@ CharacterVector xlsx_col_types(std::string path, int sheet = 0,
                                bool sheetHasColumnNames = false) {
 
   XlsxWorkSheet ws(path, sheet, nskip);
-  std::vector<CellType> types = ws.colTypes(na, guess_max, sheetHasColumnNames);
+  std::vector<ColType> types = ws.colTypes(na, guess_max, sheetHasColumnNames);
 
   CharacterVector out(types.size());
   for (size_t i = 0; i < types.size(); ++i) {
-    out[i] = cellTypeDesc(types[i]);
+    out[i] = colTypeDesc(types[i]);
   }
 
   return out;
@@ -68,13 +68,13 @@ List read_xlsx_(std::string path, int sheet, RObject col_names,
   }
 
   // Get column types --------------------------------------------------
-  std::vector<CellType> colTypes;
+  std::vector<ColType> colTypes;
   switch(TYPEOF(col_types)) {
   case NILSXP:
     colTypes = ws.colTypes(na, guess_max, sheetHasColumnNames);
     break;
   case STRSXP:
-    colTypes = cellTypes(as<CharacterVector>(col_types));
+    colTypes = colTypeStrings(as<CharacterVector>(col_types));
     colTypes = recycleTypes(colTypes, ws.ncol());
     break;
   default:
@@ -90,8 +90,8 @@ List read_xlsx_(std::string path, int sheet, RObject col_names,
   //   * col_types = NULL and we've learned them from data
   //   * all cells in column are empty or match one of the na strings
   for (size_t i = 0; i < colTypes.size(); i++) {
-    if (colTypes[i] == CELL_BLANK) {
-      colTypes[i] = CELL_NUMERIC;
+    if (colTypes[i] == COL_BLANK) {
+      colTypes[i] = COL_NUMERIC;
     }
   }
 

---FILE: src/XlsxWorkSheet.h---
@@ -68,10 +68,10 @@ class XlsxWorkSheet {
     return sheetName_;
   }
 
-  std::vector<CellType> colTypes(const StringSet& na,
+  std::vector<ColType> colTypes(const StringSet& na,
                                  int guess_max = 1000,
                                  bool has_col_names = false) {
-    std::vector<CellType> types;
+    std::vector<ColType> types;
     types.resize(ncol_);
 
     std::vector<XlsxCell>::const_iterator xcell;
@@ -80,7 +80,7 @@ class XlsxWorkSheet {
     // no cell data to consult re: types
     if (xcell == cells_.end()) {
       for (size_t i = 0; i < types.size(); i++) {
-        types[i] = CELL_BLANK;
+        types[i] = COL_BLANK;
       }
       return types;
     }
@@ -89,7 +89,7 @@ class XlsxWorkSheet {
     int base = firstRow_->row() + has_col_names;
     while (xcell != cells_.end() && xcell->row() - base < guess_max) {
       if (xcell->col() < ncol_) {
-        CellType type = xcell->type(na, wb_.stringTable(), wb_.dateStyles());
+        ColType type = as_ColType(xcell->type(na, wb_.stringTable(), wb_.dateStyles()));
         if (type > types[xcell->col()]) {
           types[xcell->col()] = type;
         }
@@ -116,7 +116,7 @@ class XlsxWorkSheet {
   }
 
   Rcpp::List readCols(Rcpp::CharacterVector names,
-                      const std::vector<CellType>& types,
+                      const std::vector<ColType>& types,
                       const StringSet& na,
                       bool has_col_names = false) {
 
@@ -143,7 +143,7 @@ class XlsxWorkSheet {
       if ((i + 1) % 1000 == 0) {
         Rcpp::checkUserInterrupt();
       }
-      if (types[j] == CELL_SKIP || j >= ncol_) {
+      if (types[j] == COL_SKIP || j >= ncol_) {
         xcell++;
         continue;
       }
@@ -154,14 +154,11 @@ class XlsxWorkSheet {
       int row = i - base;
       // Needs to compare to actual cell type to give warnings
       switch(types[j]) {
-      case CELL_SKIP:
+      case COL_BLANK:
+      case COL_SKIP:
         break;
-      case CELL_BLANK:
-        break;
-      case CELL_NUMERIC:
+      case COL_NUMERIC:
         switch(type) {
-        case CELL_SKIP:
-          break;
         case CELL_NUMERIC:
         case CELL_DATE:
           REAL(col)[row] = xcell->asDouble(na);
@@ -175,10 +172,8 @@ class XlsxWorkSheet {
           REAL(col)[row] = NA_REAL;
         }
         break;
-      case CELL_DATE:
+      case COL_DATE:
         switch(type) {
-        case CELL_SKIP:
-          break;
         case CELL_DATE:
           REAL(col)[row] = xcell->asDate(na, wb_.offset());
           break;
@@ -193,13 +188,37 @@ class XlsxWorkSheet {
           break;
         }
         break;
-      case CELL_TEXT:
+      case COL_TEXT:
         if (type == CELL_BLANK) {
           SET_STRING_ELT(col, row, NA_STRING);
         } else {
           SET_STRING_ELT(col, row, xcell->asCharSxp(na, wb_.stringTable()));
         }
         break;
+      case COL_LIST:
+        switch(type) {
+        case CELL_BLANK: {
+          SET_VECTOR_ELT(col, row, Rf_ScalarLogical(NA_LOGICAL));
+          break;
+        }
+        case CELL_NUMERIC: {
+          SET_VECTOR_ELT(col, row, Rf_ScalarReal(xcell->asDouble(na)));
+          break;
+        }
+        case CELL_DATE: {
+          Rcpp::RObject cell_val = Rf_ScalarReal(xcell->asDate(na, wb_.offset()));
+          cell_val.attr(""class"") = Rcpp::CharacterVector::create(""POSIXct"", ""POSIXt"");
+          cell_val.attr(""tzone"") = ""UTC"";
+          SET_VECTOR_ELT(col, row, cell_val);
+          break;
+        }
+        case CELL_TEXT: {
+          Rcpp::CharacterVector rStringVector = Rcpp::CharacterVector(1, NA_STRING);
+          SET_STRING_ELT(rStringVector, 0, xcell->asCharSxp(na, wb_.stringTable()));
+          SET_VECTOR_ELT(col, row, rStringVector);
+          break;
+        }
+        }
       }
     xcell++;
     }

---FILE: tests/testthat/test-col-types.R---
@@ -104,4 +104,30 @@ test_that(""wrong length col types generates error"", {
   )
 })
 
+test_that(""list column reads data correctly [xlsx]"", {
+  types <- read_excel(test_sheet(""list_type.xlsx""), col_types = ""list"")
+  expect_equal(types$var1[[1]], 1)
+  expect_equal(types$var1[[2]], NA)
+  expect_equal(types$var1[[3]], ""a"")
+  expect_equal(types$var1[[4]], as.POSIXct(""2017-01-01"", tz = ""UTC""))
+  expect_equal(types$var1[[5]], ""abc"")
+})
+
+test_that(""setting `na` works in list columns [xlsx]"", {
+  na_defined <-  read_excel(test_sheet(""list_type.xlsx""), col_types = ""list"", na = ""a"")
+  expect_equal(na_defined$var1[[3]], NA)
+})
 
+test_that(""list column reads data correctly [xls]"", {
+  types <- read_excel(test_sheet(""list_type.xls""), col_types = ""list"")
+  expect_equal(types$var1[[1]], 1)
+  expect_equal(types$var1[[2]], NA)
+  expect_equal(types$var1[[3]], ""a"")
+  expect_equal(types$var1[[4]], as.POSIXct(""2017-01-01"", tz = ""UTC""))
+  expect_equal(types$var1[[5]], ""abc"")
+})
+
+test_that(""setting `na` works in list columns [xls]"", {
+  na_defined <-  read_excel(test_sheet(""list_type.xls""), col_types = ""list"", na = ""a"")
+  expect_equal(na_defined$var1[[3]], NA)
+})",True,False,Documentation / Formatting,6
tidyverse,readxl,4a34a17fa6ae218256d48623fd46f90077a2156a,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-02-13T16:18:33Z,GitHub,noreply@github.com,2017-02-13T16:18:33Z,"Refactor xlsx col type and col name handling (#261)

* add new param n for guessing col_type

* Remove all column name processing from colTypes()

* Move colName and colType comparison out of readCols()

* Stop dropping blank columns; fixes #157

* Move tests into more logical places

* More specific error when col_names or col_types has wrong length

* Rcpp churn

* If no data, call it blank right here

* Simplify col_type learning loop

* Sketch my grand plans

* Check and test col_types

* Simplify readCols() loop

* Recycle col_types if length 1; fixes #127

* Deprecate `col_types = ""blank""`; fixes #260

* Rationalize joint processing of col_names + col_types; fixes #81

* Ignore docs for xls format

* Fix/update xlsx_col_types()

Even though I'm not sure what it's for.

* Delete benchmarks.cpp, home of the shifty, vestigial parseXml()and countRows()

* Add bullets to NEWS

* README and pkgdown

* Groom error messages and tests thereof

* Wording in NEWS

* Stop for unknown type

* Move CELL_SKIP; add comment re: enum order

* Recycle length-one col_type with std::fill()

* Indenting

* Helper function for reconciling col names

* Helper function for recycling col types

* Simplify col_type learning loop; avoid cell copy

* Simplify and avoid cell copy in readCols() too

* It's guess_max, not max_guess

* Delete comment, test code style

* Cleaner with i, j",.Rbuildignore;.gitignore;NEWS.md;R/RcppExports.R;R/read_excel.R;README.Rmd;README.md;docs/index.html;docs/news/index.html;docs/reference/read_excel.html;man/read_excel.Rd;src/CellType.h;src/ColSpec.h;src/RcppExports.cpp;src/XlsWorkSheet.cpp;src/XlsWorkSheet.h;src/XlsxCell.h;src/XlsxWorkSheet.cpp;src/XlsxWorkSheet.h;src/benchmarks.cpp;tests/testthat/test-col-names.R;tests/testthat/test-col-types.R;tests/testthat/test-empty.R;tests/testthat/test-missing-values.R;tests/testthat/test-sheets.R,True,True,True,False,423,293,716,"---FILE: .Rbuildignore---
@@ -13,3 +13,5 @@
 ^_pkgdown\.yml$
 ^docs$
 ^clippy$
+^\[MS-XLS\]\.pdf$
+^excelfileformat\.pdf$

---FILE: .gitignore---
@@ -3,3 +3,5 @@
 .RData
 ~*
 clippy
+\[MS-XLS\].pdf
+excelfileformat.pdf

---FILE: NEWS.md---
@@ -1,5 +1,15 @@
 # readxl 0.1.1.9000
 
+*currently much of this applies only to xlsx, but will be extended to xls*
+
+* A user-specified `col_types` of length one will be replicated to have length equal to the number of columns. (#127, #114, #261 @jennybc)
+
+* Column type `""blank""` has been deprecated in favor of the more descriptive `""skip""`, which also supports the goal to become more consistent with readr. (#260, #193, #261 @jennybc)
+
+* User-supplied `col_names` are processed relative to user-supplied `col_types`, if given. Specifically, `col_names` is considered valid if it has the same length as `col_types`, before *or after* removing skipped columns. (#81, #261 @jennybc)
+
+* Leading or embedded empty columns are no longer dropped, regardless of whether there is a column name. (#157, #261 @jennybc)
+
 * New argument `guess_max` lets user adjust the number of rows used to guess column types, similar to functions in readr. (#223, #257 @tklebel, @jennybc)
 
 * Improved handling of empty cells for xlsx. (#248 @jennybc)

---FILE: R/RcppExports.R---
@@ -41,8 +41,8 @@ parse_ref <- function(ref) {
     .Call('readxl_parse_ref', PACKAGE = 'readxl', ref)
 }
 
-xlsx_col_types <- function(path, sheet = 0L, na = character(), nskip = 0L, guess_max = 1000L) {
-    .Call('readxl_xlsx_col_types', PACKAGE = 'readxl', path, sheet, na, nskip, guess_max)
+xlsx_col_types <- function(path, sheet = 0L, na = character(), nskip = 0L, guess_max = 1000L, sheetHasColumnNames = FALSE) {
+    .Call('readxl_xlsx_col_types', PACKAGE = 'readxl', path, sheet, na, nskip, guess_max, sheetHasColumnNames)
 }
 
 xlsx_col_names <- function(path, sheet = 0L, nskip = 0L) {
@@ -53,14 +53,6 @@ read_xlsx_ <- function(path, sheet, col_names, col_types, na, nskip = 0L, guess_
     .Call('readxl_read_xlsx_', PACKAGE = 'readxl', path, sheet, col_names, col_types, na, nskip, guess_max)
 }
 
-parseXml <- function(base, internal) {
-    invisible(.Call('readxl_parseXml', PACKAGE = 'readxl', base, internal))
-}
-
-countRows <- function(base, sheet) {
-    .Call('readxl_countRows', PACKAGE = 'readxl', base, sheet)
-}
-
 zip_xml <- function(zip_path, file_path) {
     invisible(.Call('readxl_zip_xml', PACKAGE = 'readxl', zip_path, file_path))
 }

---FILE: R/read_excel.R---
@@ -7,14 +7,19 @@ NULL
 #' @param path Path to the xls/xlsx file
 #' @param sheet Sheet to read. Either a string (the name of a sheet), or an
 #'   integer (the position of the sheet). Defaults to the first sheet.
-#' @param col_names `TRUE` to use the first row as column names, `FALSE`
-#'   to get default names, or a character vector giving a name for each column.
+#' @param col_names `TRUE` to use the first row as column names, `FALSE` to get
+#'   default names, or a character vector giving a name for each column. If user
+#'   provides `col_types` as a vector, `col_names` can have one entry per
+#'   column, i.e. have the same length as `col_types`, or one entry per
+#'   unskipped column.
 #' @param col_types Either `NULL` to guess from the spreadsheet or a character
-#'   vector containing one entry per column from these options: ""blank"",
-#'   ""numeric"", ""date"" or ""text"".
-#' @param na Character vector of strings to use for missing values. By default
+#'   vector containing one entry per column from these options: ""skip"",
+#'   ""numeric"", ""date"" or ""text"". The content of a cell in a skipped column is
+#'   never read and that column will not appear in the data frame output.
+#' @param na Character vector of strings to use for missing values. By default,
 #'   readxl treats blank cells as missing data.
-#' @param skip Number of rows to skip before reading any data.
+#' @param skip Number of rows to skip before reading any data. Leading blank
+#'   rows are automatically skipped.
 #' @param guess_max Maximum number of rows to use for guessing column types.
 #' @export
 #' @examples
@@ -32,6 +37,7 @@ read_excel <- function(path, sheet = 1L, col_names = TRUE, col_types = NULL,
 
   path <- check_file(path)
   guess_max <- check_guess_max(guess_max)
+  col_types <- check_col_types(col_types)
 
   switch(excel_format(path),
     xls =  read_xls(path, sheet, col_names, col_types, na, skip, guess_max),
@@ -128,6 +134,30 @@ standardise_sheet <- function(sheet, sheet_names) {
   }
 }
 
+check_col_types <- function(col_types) {
+  if (is.null(col_types)) {
+    return(col_types)
+  }
+  stopifnot(is.character(col_types), length(col_types) > 0, !anyNA(col_types))
+
+  blank <- col_types == ""blank""
+  if (any(blank)) {
+    message(""`col_type = \""blank\""` deprecated. Use \""skip\"" instead."")
+    col_types[blank] <- ""skip""
+  }
+
+  accepted_types <- c(""skip"", ""numeric"", ""date"", ""text"")
+  ok <- col_types %in% accepted_types
+  if (any(!ok)) {
+    info <- paste(
+      paste0(""'"", col_types[!ok], ""' ["", seq_along(col_types)[!ok], ""]""),
+      collapse = "", ""
+    )
+    stop(paste(""Illegal column type:"", info), call. = FALSE)
+  }
+  col_types
+}
+
 ## from readr
 check_guess_max <- function(guess_max, max_limit = .Machine$integer.max %/% 100) {
 

---FILE: README.Rmd---
@@ -94,6 +94,8 @@ If you are new to the tidyverse conventions for data import, you may want to con
 * Loads datetimes into POSIXct columns. Both Windows (1900) and Mac (1904) 
   date specifications are processed correctly.
 
-* Blank columns are automatically dropped (*but this is changing!*). Blank rows that appear before the data are automatically dropped; embedded blank rows are not.
+* Blank rows that appear before the data are automatically dropped; embedded blank rows are not. User can exert more control of this with `skip`.
+
+* Column names and types are determined from the data in the sheet, by default, but user can also supply via `col_names` and `col_types`.
 
 * It returns a tibble, i.e. a data frame with an additional `tbl_df` class. Among other things, this provide nicer printing.

---FILE: README.md---
@@ -117,6 +117,8 @@ Features
 
 -   Loads datetimes into POSIXct columns. Both Windows (1900) and Mac (1904) date specifications are processed correctly.
 
--   Blank columns are automatically dropped (*but this is changing!*). Blank rows that appear before the data are automatically dropped; embedded blank rows are not.
+-   Blank rows that appear before the data are automatically dropped; embedded blank rows are not. User can exert more control of this with `skip`.
+
+-   Column names and types are determined from the data in the sheet, by default, but user can also supply via `col_names` and `col_types`.
 
 -   It returns a tibble, i.e. a data frame with an additional `tbl_df` class. Among other things, this provide nicer printing.

---FILE: docs/index.html---
@@ -142,7 +142,8 @@ <h2 class=""hasAnchor"">
 <ul>
 <li><p>Re-encodes non-ASCII characters to UTF-8.</p></li>
 <li><p>Loads datetimes into POSIXct columns. Both Windows (1900) and Mac (1904) date specifications are processed correctly.</p></li>
-<li><p>Blank columns are automatically dropped (<em>but this is changing!</em>). Blank rows that appear before the data are automatically dropped; embedded blank rows are not.</p></li>
+<li><p>Blank rows that appear before the data are automatically dropped; embedded blank rows are not. User can exert more control of this with <code>skip</code>.</p></li>
+<li><p>Column names and types are determined from the data in the sheet, by default, but user can also supply via <code>col_names</code> and <code>col_types</code>.</p></li>
 <li><p>It returns a tibble, i.e. a data frame with an additional <code>tbl_df</code> class. Among other things, this provide nicer printing.</p></li>
 </ul>
 </div>

---FILE: docs/news/index.html---
@@ -82,7 +82,13 @@ <h1>Change log <small>All releases</small></h1>
     <div id=""readxl-0-1-1-9000"" class=""section level1"">
 <h1 class=""hasAnchor"">
 <a href=""#readxl-0-1-1-9000"" class=""anchor""> </a>readxl 0.1.1.9000</h1>
+<p><em>currently much of this applies only to xlsx, but will be extended to xls</em></p>
 <ul>
+<li><p>A user-specified <code>col_types</code> of length one will be replicated to have length equal to the number of columns. (#127, #114, #261 @jennybc)</p></li>
+<li><p>Column type <code>""blank""</code> has been deprecated in favor of the more descriptive <code>""skip""</code>, which also support the goal to become more consistent with readr. (#260, #193, #261 @jennybc)</p></li>
+<li><p>User-supplied <code>col_names</code> are processed relative to user-supplied <code>col_types</code>, if given. Specifically, <code>col_names</code> are considered valid if they have length equal to <code>col_types</code> or equal to <code>col_types</code> after removing skipped columns. (#81, #261 @jennybc)</p></li>
+<li><p>Leading or embedded empty columns are no longer dropped, regardless of whether there is a column name. (#157, #261 @jennybc)</p></li>
+<li><p>New argument <code>guess_max</code> lets user adjust the number of rows used to guess column types, similar to functions in readr. (#223, #257 @tklebel, @jennybc)</p></li>
 <li>
 <p>Improved handling of empty cells for xlsx. (#248 @jennybc)</p>
 <ul>

---FILE: docs/reference/read_excel.html---
@@ -86,13 +86,13 @@ <h1>Read xls and xlsx files.</h1>
     
 
     <pre><span class='fu'>read_excel</span>(<span class='no'>path</span>, <span class='kw'>sheet</span> <span class='kw'>=</span> <span class='fl'>1L</span>, <span class='kw'>col_names</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>, <span class='kw'>col_types</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
-  <span class='kw'>na</span> <span class='kw'>=</span> <span class='st'>""""</span>, <span class='kw'>skip</span> <span class='kw'>=</span> <span class='fl'>0</span>)
+  <span class='kw'>na</span> <span class='kw'>=</span> <span class='st'>""""</span>, <span class='kw'>skip</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>guess_max</span> <span class='kw'>=</span> <span class='fl'>1000</span>)
 
 <span class='fu'>read_xls</span>(<span class='no'>path</span>, <span class='kw'>sheet</span> <span class='kw'>=</span> <span class='fl'>1L</span>, <span class='kw'>col_names</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>, <span class='kw'>col_types</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>na</span> <span class='kw'>=</span> <span class='st'>""""</span>,
-  <span class='kw'>skip</span> <span class='kw'>=</span> <span class='fl'>0</span>)
+  <span class='kw'>skip</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>guess_max</span> <span class='kw'>=</span> <span class='fl'>1000</span>)
 
 <span class='fu'>read_xlsx</span>(<span class='no'>path</span>, <span class='kw'>sheet</span> <span class='kw'>=</span> <span class='fl'>1L</span>, <span class='kw'>col_names</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>, <span class='kw'>col_types</span> <span class='kw'>=</span> <span class='kw'>NULL</span>, <span class='kw'>na</span> <span class='kw'>=</span> <span class='st'>""""</span>,
-  <span class='kw'>skip</span> <span class='kw'>=</span> <span class='fl'>0</span>)</pre>
+  <span class='kw'>skip</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>guess_max</span> <span class='kw'>=</span> <span class='fl'>1000</span>)</pre>
     
     <h2 class=""hasAnchor"" id=""arguments""><a class=""anchor"" href=""#arguments""></a> Arguments</h2>
     <dl class=""dl-horizontal"">
@@ -102,17 +102,24 @@ <h2 class=""hasAnchor"" id=""arguments""><a class=""anchor"" href=""#arguments""></a> Ar
       <dd>Sheet to read. Either a string (the name of a sheet), or an
 integer (the position of the sheet). Defaults to the first sheet.</dd>
       <dt>col_names</dt>
-      <dd><code>TRUE</code> to use the first row as column names, <code>FALSE</code>
-to get default names, or a character vector giving a name for each column.</dd>
+      <dd><code>TRUE</code> to use the first row as column names, <code>FALSE</code> to get
+default names, or a character vector giving a name for each column. If user
+provides <code>col_types</code> as a vector, <code>col_names</code> can have one entry per
+column, i.e. have the same length as <code>col_types</code>, or one entry per
+unskipped column.</dd>
       <dt>col_types</dt>
       <dd>Either <code>NULL</code> to guess from the spreadsheet or a character
-vector containing one entry per column from these options: &quot;blank&quot;,
-&quot;numeric&quot;, &quot;date&quot; or &quot;text&quot;.</dd>
+vector containing one entry per column from these options: &quot;skip&quot;,
+&quot;numeric&quot;, &quot;date&quot; or &quot;text&quot;. The content of a cell in a skipped column is
+never read and that column will not appear in the data frame output.</dd>
       <dt>na</dt>
-      <dd>Character vector of strings to use for missing values. By default
+      <dd>Character vector of strings to use for missing values. By default,
 readxl treats blank cells as missing data.</dd>
       <dt>skip</dt>
-      <dd>Number of rows to skip before reading any data.</dd>
+      <dd>Number of rows to skip before reading any data. Leading blank
+rows are automatically skipped.</dd>
+      <dt>guess_max</dt>
+      <dd>Maximum number of rows to use for guessing column types.</dd>
     </dl>
     
 

---FILE: man/read_excel.Rd---
@@ -6,8 +6,8 @@
 \alias{read_xlsx}
 \title{Read xls and xlsx files.}
 \usage{
-read_excel(path, sheet = 1, col_names = TRUE, col_types = NULL, na = """",
-  skip = 0, guess_max = 1000)
+read_excel(path, sheet = 1L, col_names = TRUE, col_types = NULL,
+  na = """", skip = 0, guess_max = 1000)
 
 read_xls(path, sheet = 1L, col_names = TRUE, col_types = NULL, na = """",
   skip = 0, guess_max = 1000)
@@ -21,17 +21,22 @@ read_xlsx(path, sheet = 1L, col_names = TRUE, col_types = NULL, na = """",
 \item{sheet}{Sheet to read. Either a string (the name of a sheet), or an
 integer (the position of the sheet). Defaults to the first sheet.}
 
-\item{col_names}{\code{TRUE} to use the first row as column names, \code{FALSE}
-to get default names, or a character vector giving a name for each column.}
+\item{col_names}{\code{TRUE} to use the first row as column names, \code{FALSE} to get
+default names, or a character vector giving a name for each column. If user
+provides \code{col_types} as a vector, \code{col_names} can have one entry per
+column, i.e. have the same length as \code{col_types}, or one entry per
+unskipped column.}
 
 \item{col_types}{Either \code{NULL} to guess from the spreadsheet or a character
-vector containing one entry per column from these options: ""blank"",
-""numeric"", ""date"" or ""text"".}
+vector containing one entry per column from these options: ""skip"",
+""numeric"", ""date"" or ""text"". The content of a cell in a skipped column is
+never read and that column will not appear in the data frame output.}
 
-\item{na}{Character vector of strings to use for missing values. By default
+\item{na}{Character vector of strings to use for missing values. By default,
 readxl treats blank cells as missing data.}
 
-\item{skip}{Number of rows to skip before reading any data.}
+\item{skip}{Number of rows to skip before reading any data. Leading blank
+rows are automatically skipped.}
 
 \item{guess_max}{Maximum number of rows to use for guessing column types.}
 }

---FILE: src/CellType.h---
@@ -5,8 +5,12 @@
 #include <libxls/xls.h>
 #include ""StringSet.h""
 
+// CELL_BLANK can arise only from an individual cell during type guessing
+// important that it be the first entry = default type, instead of ...
+// CELL_SKIP  which can arise only as a user-specified column type
 enum CellType {
   CELL_BLANK,
+  CELL_SKIP,
   CELL_DATE,
   CELL_NUMERIC,
   CELL_TEXT
@@ -26,11 +30,12 @@ inline std::vector<CellType> cellTypes(Rcpp::CharacterVector x) {
       types.push_back(CELL_DATE);
     } else if (type == ""numeric"") {
       types.push_back(CELL_NUMERIC);
+    } else if (type == ""skip"") {
+      types.push_back(CELL_SKIP);
     } else if (type == ""text"") {
       types.push_back(CELL_TEXT);
     } else {
-      Rcpp::warning(""Unknown type '%s' at position %i. Using text instead."",
-        type, i + 1);
+      Rcpp::stop(""Unknown type '%s' at position %i"", type, i + 1);
     }
   }
 
@@ -42,6 +47,7 @@ inline std::string cellTypeDesc(CellType type) {
   case CELL_BLANK:   return ""blank"";
   case CELL_DATE:    return ""date"";
   case CELL_NUMERIC: return ""numeric"";
+  case CELL_SKIP:    return ""skip"";
   case CELL_TEXT:    return ""text"";
   }
   return ""???"";
@@ -153,6 +159,9 @@ inline Rcpp::RObject makeCol(CellType type, int n) {
   case CELL_NUMERIC:
     return Rcpp::NumericVector(n, NA_REAL);
     break;
+  case CELL_SKIP:
+    return R_NilValue;
+    break;
   case CELL_TEXT:
     return Rcpp::CharacterVector(n, NA_STRING);
     break;
@@ -161,24 +170,24 @@ inline Rcpp::RObject makeCol(CellType type, int n) {
   return R_NilValue;
 }
 
-// Drop blanks from list of columns
-inline Rcpp::List removeBlankColumns(Rcpp::List cols,
-                                     Rcpp::CharacterVector names,
-                                     std::vector<CellType> types) {
+inline Rcpp::List removeSkippedColumns(Rcpp::List cols,
+                                       Rcpp::CharacterVector names,
+                                       std::vector<CellType> types) {
   int p = cols.size();
 
   int p_out = 0;
   for (int j = 0; j < p; ++j) {
-    if (types[j] != CELL_BLANK)
+    if (types[j] != CELL_SKIP)
       p_out++;
   }
 
   Rcpp::List out(p_out);
   Rcpp::CharacterVector names_out(p_out);
   int j_out = 0;
   for (int j = 0; j < p; ++j) {
-    if (types[j] == CELL_BLANK)
+    if (types[j] == CELL_SKIP) {
       continue;
+    }
 
     out[j_out] = cols[j];
     names_out[j_out] = names[j];

---FILE: src/ColSpec.h---
@@ -0,0 +1,49 @@
+#ifndef READXL_COLSPEC_
+#define READXL_COLSPEC_
+
+#include <Rcpp.h>
+#include ""CellType.h""
+
+inline std::vector<CellType> recycleTypes(std::vector<CellType> types,
+                                          int ncol) {
+  if (types.size() == 1) {
+    types.resize(ncol);
+    std::fill(types.begin(), types.end(), types[0]);
+  }
+  return types;
+}
+
+inline Rcpp::CharacterVector reconcileNames(Rcpp::CharacterVector names,
+                                            const std::vector<CellType>& types,
+                                            int sheet) {
+  size_t ncol_names = names.size();
+  size_t ncol_types = types.size();
+
+  if (ncol_names == ncol_types) {
+    return names;
+  }
+
+  size_t ncol_noskip = 0;
+  for (size_t i = 0; i < types.size(); i++) {
+    if (types[i] != CELL_SKIP) {
+      ncol_noskip++;
+    }
+  }
+  if (ncol_names != ncol_noskip) {
+    Rcpp::stop(""Sheet %d has %d columns (%d unskipped), but `col_names` has length %d."",
+               sheet + 1, ncol_types, ncol_noskip, ncol_names);
+  }
+
+  Rcpp::CharacterVector newNames(ncol_types, """");
+  size_t j_short = 0;
+  for (size_t j_long = 0; j_long < ncol_types; ++j_long) {
+    if (types[j_long] == CELL_SKIP) {
+      continue;
+    }
+    newNames[j_long] = names[j_short];
+    j_short++;
+  }
+  return newNames;
+}
+
+#endif

---FILE: src/RcppExports.cpp---
@@ -130,8 +130,8 @@ BEGIN_RCPP
 END_RCPP
 }
 // xlsx_col_types
-CharacterVector xlsx_col_types(std::string path, int sheet, CharacterVector na, int nskip, int guess_max);
-RcppExport SEXP readxl_xlsx_col_types(SEXP pathSEXP, SEXP sheetSEXP, SEXP naSEXP, SEXP nskipSEXP, SEXP guess_maxSEXP) {
+CharacterVector xlsx_col_types(std::string path, int sheet, CharacterVector na, int nskip, int guess_max, bool sheetHasColumnNames);
+RcppExport SEXP readxl_xlsx_col_types(SEXP pathSEXP, SEXP sheetSEXP, SEXP naSEXP, SEXP nskipSEXP, SEXP guess_maxSEXP, SEXP sheetHasColumnNamesSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
@@ -140,7 +140,8 @@ BEGIN_RCPP
     Rcpp::traits::input_parameter< CharacterVector >::type na(naSEXP);
     Rcpp::traits::input_parameter< int >::type nskip(nskipSEXP);
     Rcpp::traits::input_parameter< int >::type guess_max(guess_maxSEXP);
-    rcpp_result_gen = Rcpp::wrap(xlsx_col_types(path, sheet, na, nskip, guess_max));
+    Rcpp::traits::input_parameter< bool >::type sheetHasColumnNames(sheetHasColumnNamesSEXP);
+    rcpp_result_gen = Rcpp::wrap(xlsx_col_types(path, sheet, na, nskip, guess_max, sheetHasColumnNames));
     return rcpp_result_gen;
 END_RCPP
 }
@@ -174,29 +175,6 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// parseXml
-void parseXml(std::string base, std::string internal);
-RcppExport SEXP readxl_parseXml(SEXP baseSEXP, SEXP internalSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< std::string >::type base(baseSEXP);
-    Rcpp::traits::input_parameter< std::string >::type internal(internalSEXP);
-    parseXml(base, internal);
-    return R_NilValue;
-END_RCPP
-}
-// countRows
-int countRows(std::string base, int sheet);
-RcppExport SEXP readxl_countRows(SEXP baseSEXP, SEXP sheetSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< std::string >::type base(baseSEXP);
-    Rcpp::traits::input_parameter< int >::type sheet(sheetSEXP);
-    rcpp_result_gen = Rcpp::wrap(countRows(base, sheet));
-    return rcpp_result_gen;
-END_RCPP
-}
 // zip_xml
 void zip_xml(const std::string& zip_path, const std::string& file_path);
 RcppExport SEXP readxl_zip_xml(SEXP zip_pathSEXP, SEXP file_pathSEXP) {

---FILE: src/XlsWorkSheet.cpp---
@@ -42,8 +42,10 @@ List xls_cols(std::string path, int i, CharacterVector col_names,
   XlsWorkBook wb = XlsWorkBook(path);
   XlsWorkSheet sheet = wb.sheet(i);
 
-  if (col_names.size() != col_types.size())
-    stop(""`col_names` and `col_types` must have the same length"");
+  if (col_names.size() != col_types.size()) {
+    Rcpp::stop(""Received %d names but %d types."",
+               col_names.size(), col_types.size());
+  }
 
   std::vector<CellType> types = cellTypes(col_types);
   return sheet.readCols(col_names, types, na, nskip);

---FILE: src/XlsWorkSheet.h---
@@ -18,8 +18,10 @@ class XlsWorkSheet {
   XlsWorkSheet(const XlsWorkBook& wb, int i) {
     offset_ = dateOffset(wb.workbook()->is1904);
 
-    if (i < 0 || i >= wb.nSheets())
-      Rcpp::stop(""Invalid sheet index"");
+    if (i >= wb.nSheets()) {
+      Rcpp::stop(""Can't retrieve sheet in position %d, only %d sheet(s) found."",
+                 i + 1, wb.nSheets());
+    }
 
     pWS_ = xls_getWorkSheet(wb.workbook(), i);
     if (pWS_ == NULL)
@@ -90,8 +92,10 @@ class XlsWorkSheet {
 
   Rcpp::List readCols(Rcpp::CharacterVector names, std::vector<CellType> types,
                       const StringSet &na, int nskip = 0) {
-    if ((int) names.size() != ncol_ || (int) types.size() != ncol_)
-      Rcpp::stop(""Need one name and type for each column"");
+    if ((int) names.size() != ncol_ || (int) types.size() != ncol_){
+      Rcpp::stop(""Received %d names and %d types, but worksheet contains %d columns."",
+                 names.size(), types.size(),  ncol_);
+    }
 
     Rcpp::List cols(ncol_);
 
@@ -115,12 +119,15 @@ class XlsWorkSheet {
         switch(types[j]) {
         case CELL_BLANK:
           break;
+        case CELL_SKIP:
+          break;
         case CELL_NUMERIC:
           switch(type) {
           case CELL_BLANK:
             REAL(col)[i] = NA_REAL;
             break;
           case CELL_NUMERIC:
+          case CELL_SKIP:
           case CELL_DATE:
             REAL(col)[i] = cell.d;
             break;
@@ -132,6 +139,7 @@ class XlsWorkSheet {
           break;
         case CELL_DATE:
           switch(type) {
+          case CELL_SKIP:
           case CELL_BLANK:
             REAL(col)[i] = NA_REAL;
             break;
@@ -163,7 +171,7 @@ class XlsWorkSheet {
       }
     }
 
-    return removeBlankColumns(cols, names, types);
+    return removeSkippedColumns(cols, names, types);
   }
 };
 

---FILE: src/XlsxCell.h---
@@ -50,11 +50,11 @@ class XlsxCell {
     return location_.first;
   }
 
-  int col()  const {
+  int col() const {
     return location_.second;
   }
 
-  std::string asStdString(const std::vector<std::string>& stringTable) {
+  std::string asStdString(const std::vector<std::string>& stringTable) const {
     rapidxml::xml_node<>* v = cell_->first_node(""v"");
     if (v == NULL)
       return ""[NULL]"";
@@ -67,15 +67,15 @@ class XlsxCell {
     return stringTable.at(id);
   }
 
-  double asDouble(const StringSet& na) {
+  double asDouble(const StringSet& na) const {
     rapidxml::xml_node<>* v = cell_->first_node(""v"");
     if (v == NULL || na.contains(v->value()))
       return NA_REAL;
 
     return (v == NULL) ? 0 : atof(v->value());
   }
 
-  double asDate(const StringSet& na, int offset) {
+  double asDate(const StringSet& na, int offset) const {
     rapidxml::xml_node<>* v = cell_->first_node(""v"");
     if (v == NULL || na.contains(v->value()))
       return NA_REAL;
@@ -85,7 +85,7 @@ class XlsxCell {
   }
 
   Rcpp::RObject asCharSxp(const StringSet& na,
-                          const std::vector<std::string>& stringTable) {
+                          const std::vector<std::string>& stringTable) const {
 
     // Is it an inline string?  // 18.3.1.53 is (Rich Text Inline) [p1649]
     rapidxml::xml_node<>* is = cell_->first_node(""is"");
@@ -98,7 +98,6 @@ class XlsxCell {
       }
     }
 
-
     rapidxml::xml_node<>* v = cell_->first_node(""v"");
     if (v == NULL)
       return NA_STRING;
@@ -118,7 +117,7 @@ class XlsxCell {
 
   CellType type(const StringSet& na,
                 const std::vector<std::string>& stringTable,
-                const std::set<int>& dateStyles) {
+                const std::set<int>& dateStyles) const {
     rapidxml::xml_attribute<>* t = cell_->first_attribute(""t"");
 
     if (t == NULL || strncmp(t->value(), ""n"", 5) == 0) {
@@ -164,7 +163,7 @@ class XlsxCell {
 
 
   Rcpp::RObject stringFromTable(const char* val, const StringSet& na,
-                                const std::vector<std::string>& stringTable) {
+                                const std::vector<std::string>& stringTable) const {
     int id = atoi(val);
     if (id < 0 || id >= (int) stringTable.size()) {
       Rcpp::warning(""[%i, %i]: Invalid string id %i"", row() + 1, col() + 1, id);

---FILE: src/XlsxWorkSheet.cpp---
@@ -1,5 +1,6 @@
 #include <Rcpp.h>
 #include ""XlsxWorkSheet.h""
+#include ""ColSpec.h""
 using namespace Rcpp;
 
 // [[Rcpp::export]]
@@ -18,10 +19,11 @@ IntegerVector parse_ref(std::string ref) {
 // [[Rcpp::export]]
 CharacterVector xlsx_col_types(std::string path, int sheet = 0,
                                CharacterVector na = CharacterVector(),
-                               int nskip = 0, int guess_max = 1000) {
+                               int nskip = 0, int guess_max = 1000,
+                               bool sheetHasColumnNames = false) {
 
   XlsxWorkSheet ws(path, sheet, nskip);
-  std::vector<CellType> types = ws.colTypes(na, nskip, guess_max);
+  std::vector<CellType> types = ws.colTypes(na, guess_max, sheetHasColumnNames);
 
   CharacterVector out(types.size());
   for (size_t i = 0; i < types.size(); ++i) {
@@ -43,11 +45,12 @@ List read_xlsx_(std::string path, int sheet, RObject col_names,
 
   XlsxWorkSheet ws(path, sheet, nskip);
 
+  // catches empty sheets and sheets where we skip past all data
   if (ws.nrow() == 0 && ws.ncol() == 0) {
     return Rcpp::List(0);
   }
 
-  // Standardise column names --------------------------------------------------
+  // Get column names --------------------------------------------------
   CharacterVector colNames;
   bool sheetHasColumnNames = false;
   switch(TYPEOF(col_names)) {
@@ -64,18 +67,35 @@ List read_xlsx_(std::string path, int sheet, RObject col_names,
     Rcpp::stop(""`col_names` must be a logical or character vector"");
   }
 
-  // Standardise column types --------------------------------------------------
+  // Get column types --------------------------------------------------
   std::vector<CellType> colTypes;
   switch(TYPEOF(col_types)) {
   case NILSXP:
     colTypes = ws.colTypes(na, guess_max, sheetHasColumnNames);
     break;
   case STRSXP:
     colTypes = cellTypes(as<CharacterVector>(col_types));
+    colTypes = recycleTypes(colTypes, ws.ncol());
     break;
   default:
     Rcpp::stop(""`col_types` must be a character vector or NULL"");
   }
+  if ((int) colTypes.size() != ws.ncol()) {
+    Rcpp::stop(""Sheet %d has %d columns, but `col_types` has length %d."",
+               sheet + 1, ws.ncol(), colTypes.size());
+  }
+
+  // convert blank columns to a default type (numeric today, but logical soon)
+  // can only happen when
+  //   * col_types = NULL and we've learned them from data
+  //   * all cells in column are empty or match one of the na strings
+  for (size_t i = 0; i < colTypes.size(); i++) {
+    if (colTypes[i] == CELL_BLANK) {
+      colTypes[i] = CELL_NUMERIC;
+    }
+  }
+
+  colNames = reconcileNames(colNames, colTypes, sheet);
 
   return ws.readCols(colNames, colTypes, na, sheetHasColumnNames);
 }

---FILE: src/XlsxWorkSheet.h---
@@ -31,7 +31,7 @@ class XlsxWorkSheet {
   {
     rapidxml::xml_node<>* rootNode;
 
-    if (sheet_i > wb.n_sheets()) {
+    if (sheet_i >= wb.n_sheets()) {
       Rcpp::stop(""Can't retrieve sheet in position %d, only %d sheet(s) found."",
                  sheet_i + 1,  wb.n_sheets());
     }
@@ -68,79 +68,49 @@ class XlsxWorkSheet {
     return sheetName_;
   }
 
-  // JB: this should either take colNames as an argument or have a bit of code
-  // moved out of here, so we don't read column names again inside this fxn.
-  // More comments near end of fxn.
   std::vector<CellType> colTypes(const StringSet& na,
                                  int guess_max = 1000,
                                  bool has_col_names = false) {
     std::vector<CellType> types;
     types.resize(ncol_);
 
-    std::vector<XlsxCell>::const_iterator it, row_end;
-    it = has_col_names ? secondRow_: firstRow_;
+    std::vector<XlsxCell>::const_iterator xcell;
+    xcell = has_col_names ? secondRow_ : firstRow_;
 
     // no cell data to consult re: types
-    if (it == cells_.end()) {
+    if (xcell == cells_.end()) {
       for (size_t i = 0; i < types.size(); i++) {
-        types[i] = CELL_NUMERIC;
+        types[i] = CELL_BLANK;
       }
       return types;
     }
 
+    // base is row the data starts on **in the spreadsheet**
     int base = firstRow_->row() + has_col_names;
-    // we have consulted i rows re: determining col types
-    int i;
-    // account for any empty rows between column headers and data start
-    i = it->row() - base;
-
-    while (i < guess_max && it != cells_.end()) {
-      // find the end of current row
-      row_end = it;
-      while(row_end != cells_.end() && row_end->row() == it->row()) {
-        row_end++;
-      }
-
-      while (it != row_end) {
-        XlsxCell xcell = *it;
-        if (xcell.col() < ncol_) {
-          CellType type = xcell.type(na, wb_.stringTable(), wb_.dateStyles());
-          if (type > types[xcell.col()]) {
-            types[xcell.col()] = type;
-          }
+    while (xcell != cells_.end() && xcell->row() - base < guess_max) {
+      if (xcell->col() < ncol_) {
+        CellType type = xcell->type(na, wb_.stringTable(), wb_.dateStyles());
+        if (type > types[xcell->col()]) {
+          types[xcell->col()] = type;
         }
-        it++;
       }
-
-      i++;
+      xcell++;
     }
 
-    // JB: this usually rederives the column names, which seems unwise
-    // I propose to move such reconciliation of column names and types out
-    // of here and into the parent function , read_xlsx_()
-    if (has_col_names) {
-      // blank columns with a name aren't blank
-      Rcpp::CharacterVector names = colNames();
-      for (size_t i = 0; i < types.size(); i++) {
-        if (types[i] == CELL_BLANK && names[i] != NA_STRING && names[i] != """")
-          types[i] = CELL_NUMERIC;
-      }
-    }
     return types;
   }
 
   Rcpp::CharacterVector colNames() {
     Rcpp::CharacterVector out(ncol_);
-    std::vector<XlsxCell>::const_iterator it = firstRow_;
-    int base = it->row();
+    std::vector<XlsxCell>::const_iterator xcell = firstRow_;
+    int base = xcell->row();
 
-    while(it != cells_.end() && it->row() == base) {
-      XlsxCell xcell = *it;
-      if (xcell.col() >= ncol_) {
+    while(xcell != cells_.end() && xcell->row() == base) {
+      if (xcell->col() >= ncol_) {
         break;
       }
-      out[xcell.col()] = xcell.asCharSxp("""", wb_.stringTable());
-      it++;
+      out[xcell->col()] = xcell->asCharSxp("""", wb_.stringTable());
+      xcell++;
     }
     return out;
   }
@@ -149,111 +119,94 @@ class XlsxWorkSheet {
                       const std::vector<CellType>& types,
                       const StringSet& na,
                       bool has_col_names = false) {
-    // JB: suspect this should move out of here and into a function that does
-    // this and the last rationalization re col names and types in colTypes
-    if ((int) names.size() != ncol_ || (int) types.size() != ncol_)
-      Rcpp::stop(""Need one name and type for each column"");
 
-    std::vector<XlsxCell>::const_iterator it, row_end;
-    it = has_col_names ? secondRow_: firstRow_;
-
-    // no cell data to read
-    if (it == cells_.end()) {
-      Rcpp::List cols(ncol_);
-      for (int j = 0; j < ncol_; ++j) {
-        cols[j] = makeCol(types[j], 0);
-      }
-      return removeBlankColumns(cols, names, types);
-    }
+    std::vector<XlsxCell>::const_iterator xcell;
+    xcell = has_col_names ? secondRow_: firstRow_;
 
+    // base is row the data starts on **in the spreadsheet**
     int base = firstRow_->row() + has_col_names;
-    // we have read i rows of data
-    int i;
-    // account for any empty rows between column headers and data start
-    i = it->row() - base;
-
-    // Initialise columns, accounting for leading skipped or blank rows
-    int n = nrow_ - base;
+    int n = (xcell == cells_.end()) ? 0 : nrow_ - base;
     Rcpp::List cols(ncol_);
+    cols.attr(""names"") = names;
     for (int j = 0; j < ncol_; ++j) {
       cols[j] = makeCol(types[j], n);
     }
 
-    while (it != cells_.end()) {
+    if (n == 0) {
+      return cols;
+    }
 
+    while (xcell != cells_.end()) {
+
+      int i = xcell->row();
+      int j = xcell->col();
       if ((i + 1) % 1000 == 0) {
         Rcpp::checkUserInterrupt();
       }
-
-      // find the end of this row
-      row_end = it;
-      while(row_end != cells_.end() && row_end->row() == it->row()) {
-        row_end++;
+      if (types[j] == CELL_SKIP || j >= ncol_) {
+        xcell++;
+        continue;
       }
 
-      while (it != row_end) {
-        XlsxCell xcell = *it;
-        if (xcell.col() >= ncol_) {
-          continue;
-        }
-        CellType type = xcell.type(na, wb_.stringTable(), wb_.dateStyles());
-        Rcpp::RObject col = cols[xcell.col()];
-        // row to write into
-        int row = xcell.row() - base;
-        // Needs to compare to actual cell type to give warnings
-        switch(types[xcell.col()]) {
-        case CELL_BLANK:
+      CellType type = xcell->type(na, wb_.stringTable(), wb_.dateStyles());
+      Rcpp::RObject col = cols[j];
+      // row to write into
+      int row = i - base;
+      // Needs to compare to actual cell type to give warnings
+      switch(types[j]) {
+      case CELL_SKIP:
+        break;
+      case CELL_BLANK:
+        break;
+      case CELL_NUMERIC:
+        switch(type) {
+        case CELL_SKIP:
           break;
         case CELL_NUMERIC:
-          switch(type) {
-          case CELL_NUMERIC:
-          case CELL_DATE:
-            REAL(col)[row] = xcell.asDouble(na);
-            break;
-          case CELL_BLANK:
-            REAL(col)[row] = NA_REAL;
-            break;
-          case CELL_TEXT:
-            Rcpp::warning(""[%i, %i]: expecting numeric: got '%s'"",
-                          xcell.row() + 1, xcell.col() + 1,
-                          xcell.asStdString(wb_.stringTable()));
-            REAL(col)[row] = NA_REAL;
-          }
+        case CELL_DATE:
+          REAL(col)[row] = xcell->asDouble(na);
+          break;
+        case CELL_BLANK:
+          REAL(col)[row] = NA_REAL;
+          break;
+        case CELL_TEXT:
+          Rcpp::warning(""[%i, %i]: expecting numeric: got '%s'"",
+                        i + 1, j + 1, xcell->asStdString(wb_.stringTable()));
+          REAL(col)[row] = NA_REAL;
+        }
+        break;
+      case CELL_DATE:
+        switch(type) {
+        case CELL_SKIP:
           break;
         case CELL_DATE:
-          switch(type) {
-          case CELL_DATE:
-            REAL(col)[row] = xcell.asDate(na, wb_.offset());
-            break;
-          case CELL_BLANK:
-            REAL(col)[row] = NA_REAL;
-            break;
-          case CELL_NUMERIC:
-          case CELL_TEXT:
-            Rcpp::warning(""[%i, %i]: expecting date: got '%s'"",
-                          xcell.row() + 1, xcell.col() + 1,
-                          xcell.asStdString(wb_.stringTable()));
-            REAL(col)[row] = NA_REAL;
-            break;
-          }
+          REAL(col)[row] = xcell->asDate(na, wb_.offset());
           break;
+        case CELL_BLANK:
+          REAL(col)[row] = NA_REAL;
+          break;
+        case CELL_NUMERIC:
         case CELL_TEXT:
-          if (type == CELL_BLANK) {
-            SET_STRING_ELT(col, row, NA_STRING);
-          } else {
-            SET_STRING_ELT(col, row, xcell.asCharSxp(na, wb_.stringTable()));
-          }
+          Rcpp::warning(""[%i, %i]: expecting date: got '%s'"",
+                        i + 1, j + 1, xcell->asStdString(wb_.stringTable()));
+          REAL(col)[row] = NA_REAL;
           break;
         }
-        it++;
+        break;
+      case CELL_TEXT:
+        if (type == CELL_BLANK) {
+          SET_STRING_ELT(col, row, NA_STRING);
+        } else {
+          SET_STRING_ELT(col, row, xcell->asCharSxp(na, wb_.stringTable()));
+        }
+        break;
       }
-      ++i;
+    xcell++;
     }
 
-    return removeBlankColumns(cols, names, types);
+    return removeSkippedColumns(cols, names, types);
   }
 
-
 private:
 
   void loadCells() {

---FILE: src/benchmarks.cpp---
@@ -1,42 +0,0 @@
-#include <Rcpp.h>
-#include ""rapidxml.h""
-#include ""XlsxWorkBook.h""
-using namespace Rcpp;
-
-// [[Rcpp::export]]
-void parseXml(std::string base, std::string internal) {
-  std::string file = zip_buffer(base, internal);
-  Rcout << ""File size: "" << file.size() << "" bytes\n"";
-
-  rapidxml::xml_document<> xml;
-  xml.parse<0>(&file[0]);
-}
-
-// [[Rcpp::export]]
-int countRows(std::string base, int sheet) {
-  // FYI: sheet lookup logic has changed in main package
-  // this is not generally correct
-  std::string sheetPath = tfm::format(""xl/worksheets/sheet%i.xml"", sheet + 1);
-
-  std::string file = zip_buffer(base, sheetPath);
-  Rcout << ""File size: "" << file.size() << "" bytes\n"";
-
-  rapidxml::xml_document<> xml;
-  xml.parse<0>(&file[0]);
-
-  rapidxml::xml_node<>* rootNode_ = xml.first_node(""worksheet"");
-  if (rootNode_ == NULL)
-    return 0;
-
-  rapidxml::xml_node<>* sheetData_ = rootNode_->first_node(""sheetData"");
-  if (sheetData_ == NULL)
-    return 0;
-
-  int i = 0;
-  for (rapidxml::xml_node<>* row = sheetData_->first_node(""row"");
-       row; row = row->next_sibling(""row"")) {
-    i++;
-  }
-
-  return i;
-}

---FILE: tests/testthat/test-col-names.R---
@@ -57,3 +57,28 @@ test_that(""column names are de-duplicated"", {
   df <- read_excel(test_sheet(""unnamed-duplicated-columns.xls""))
   expect_identical(names(df)[4], ""var2__1"")
 })
+
+test_that(""wrong length column names are rejected [xlsx]"", {
+  expect_error(
+    read_excel(test_sheet(""iris-excel.xlsx""),col_names = LETTERS[1:3]),
+    ""Sheet 1 has 5 columns (5 unskipped), but `col_names` has length 3."",
+    fixed = TRUE
+  )
+})
+
+test_that(""wrong length column names are rejected [xls]"", {
+  expect_error(
+    read_excel(test_sheet(""iris-excel.xls""), col_names = LETTERS[1:3]),
+    ""Received 3 names but 5 types.""
+  )
+})
+
+test_that(""column_names can anticipate skipping [xlsx]"", {
+  expect_silent(
+    df <- read_excel(test_sheet(""iris-excel.xlsx""),
+                     col_names = c(""one"", ""two"", ""three""), skip = 1,
+                     col_types = c(""numeric"", ""numeric"", ""skip"", ""skip"", ""text""))
+  )
+  expect_identical(dim(df), c(150L, 3L))
+  expect_identical(names(df), c(""one"", ""two"", ""three""))
+})

---FILE: tests/testthat/test-col-types.R---
@@ -1,4 +1,55 @@
-context(""Col types"")
+context(""Column types"")
+
+test_that(""illegal col_types are rejected"", {
+  expect_error(
+    read_excel(test_sheet(""types.xlsx""),
+               col_types = c(""foo"", ""numeric"", ""text"", ""bar"")),
+    ""Illegal column type""
+  )
+})
+
+test_that(""request for 'blank' col type gets deprecation message and fix"", {
+  expect_message(
+    read_excel(test_sheet(""types.xlsx""),
+               col_types = rep_len(c(""blank"", ""text""), length.out = 5)),
+    ""`col_type = \""blank\""` deprecated. Use \""skip\"" instead."",
+    fixed = TRUE
+  )
+})
+
+test_that(""invalid col_types are rejected"", {
+  expect_error(
+    read_excel(test_sheet(""types.xlsx""), col_types = character()),
+    ""length(col_types) > 0 is not TRUE"", fixed = TRUE
+  )
+  expect_error(
+    read_excel(test_sheet(""types.xlsx""), col_types = 1:3),
+    ""is.character(col_types) is not TRUE"", fixed = TRUE
+  )
+  expect_error(
+    read_excel(test_sheet(""types.xlsx""), col_types = c(NA, ""text"", ""numeric"")),
+    ""!anyNA(col_types) is not TRUE"", fixed = TRUE
+  )
+})
+
+test_that(""col_types can be specified"", {
+  df <- read_excel(test_sheet(""iris-excel.xlsx""),
+                   col_types = c(""numeric"", ""text"", ""numeric"", ""numeric"", ""text""))
+  expect_is(df[[2]], ""character"")
+})
+
+test_that(""col_types are recycled"", {
+  df <- read_excel(test_sheet(""types.xlsx""), col_types = ""text"")
+  expect_match(vapply(df, class, character(1)), ""character"")
+})
+
+test_that(""inappropriate col_types generate warning"", {
+  expect_warning(
+    read_excel(test_sheet(""iris-excel.xlsx""),
+               col_types = c(""numeric"", ""text"", ""numeric"", ""numeric"", ""numeric"")),
+    ""expecting numeric""
+  )
+})
 
 test_that(""types imputed & read correctly [xlsx]"", {
   types <- read_excel(test_sheet(""types.xlsx""))
@@ -12,8 +63,15 @@ test_that(""types imputed & read correctly [xlsx]"", {
 
 test_that(""types imputed & read correctly [xls]"", {
   expect_output(
+    ## valgrind reports this
+    ## Conditional jump or move depends on uninitialised value(s)
     types <- read_excel(test_sheet(""types.xls"")),
     ""Unknown type: 517""
+    ## definitely due to these 'Unknown type: 517' msgs
+    ## line 102 in CellType.h
+    ##   Rcpp::Rcout << ""Unknown type: "" << cell.id << ""\n"";
+    ## if I skip this test, memcheck report is as clean as it ever gets
+    ## https://github.com/tidyverse/readxl/issues/259
   )
   expect_is(types$number, ""numeric"")
   expect_is(types$string, ""character"")
@@ -23,14 +81,27 @@ test_that(""types imputed & read correctly [xls]"", {
   skip(""revisit these expectations as xls problems are fixed"")
 })
 
-test_that(""max_guess is honored for col_types [xlsx]"", {
+test_that(""guess_max is honored for col_types [xlsx]"", {
   expect_warning(
     types <- read_excel(test_sheet(""types.xlsx""), guess_max = 2),
     ""expecting numeric""
   )
   expect_identical(types$string_in_row_3, c(1, 2, NA))
 })
 
-test_that(""max_guess is honored for col_types [xls]"", {
+test_that(""guess_max is honored for col_types [xls]"", {
   skip(""write this test as xls problems are fixed"")
 })
+
+test_that(""wrong length col types generates error"", {
+  expect_error(
+    read_excel(test_sheet(""iris-excel.xlsx""), col_types = c(""numeric"", ""text"")),
+    ""Sheet 1 has 5 columns, but `col_types` has length 2.""
+  )
+  expect_error(
+    read_excel(test_sheet(""iris-excel.xls""), col_types = c(""numeric"", ""text"")),
+    ""Received 5 names but 2 types.""
+  )
+})
+
+

---FILE: tests/testthat/test-empty.R---
@@ -23,33 +23,3 @@ test_that(""non-empty sheets act that way if we skip past everything"", {
   out <- read_excel(test_sheet(""skipping.xlsx""), skip = 10)
   expect_identical(out, tibble::tibble())
 })
-
-test_that(""empty cells with a style are not loaded"", {
-  ## what's important about this sheet?
-  ## contains empty cells with a custom format
-  ## therefore they appear in the xml and have a style attribute
-  ## where are they?
-  ## in the embedded empty columns, w/ and w/o a name
-  ## in a trailing empty column
-  ## in some trailing rows
-  out <- read_excel(test_sheet(""style-only-cells.xlsx""))
-  df <- tibble::tibble(var1 = c(""val1,1"", ""val2,1"", ""val3,1""),
-                       var2 = NA_real_,
-                       var3 = c(""aa"", ""bb"", ""cc""),
-                       var5 = c(1, 2, 3))
-  expect_equal(out, df)
-  skip(""revisit this when dust settles re: treatment of empty columns"")
-})
-
-test_that(""user-supplied column names play nicely with empty columns"", {
-  skip(""waiting for dust to settle re: treatment of empty columns"")
-  ## do stuff like this:
-  out <- read_excel(
-    test_sheet(""style-only-cells.xlsx""),
-    col_names = LETTERS[1:4]
-  )
-  out <- read_excel(
-    test_sheet(""style-only-cells.xlsx""),
-    col_names = LETTERS[1:5]
-  )
-})

---FILE: tests/testthat/test-missing-values.R---
@@ -70,14 +70,37 @@ test_that(""text values in numeric column gives warning & NA"", {
 
 test_that(""empty first column gives valid data.frame"", {
   df <- read_excel(test_sheet(""missing-first-column.xlsx""), col_names = FALSE)
-  expect_equal(nrow(df), length(df[[1]]))
+  expect_equal(nrow(df), length(df[[2]]))
 })
 
 test_that(""empty named column gives NA column"", {
   df1 <- read_excel(test_sheet(""empty-named-column.xlsx""), col_names = TRUE)
   df2 <- read_excel(test_sheet(""empty-named-column.xls""), col_names = TRUE)
   expect_equal(ncol(df1), 4)
   expect_equal(names(df1)[2], ""y"")
+  expect_true(all(is.na(df1$y)))
+  expect_true(all(is.numeric(df1$y)))
   expect_equal(ncol(df2), 4)
   expect_equal(names(df2)[2], ""y"")
+  expect_true(all(is.na(df2$y)))
+  expect_true(all(is.numeric(df2$y)))
+})
+
+test_that(""empty (styled) cells are not loaded, but can survive as NA"", {
+  ## what's important about this sheet?
+  ## contains empty cells with a custom format
+  ## therefore they appear in the xml and have a style attribute
+  ## where are they?
+  ## in the embedded empty columns, w/ and w/o a name
+  ## in a trailing empty column WHICH SHOULD BE DROPPED
+  ## in some trailing rows WHICH SHOULD BE DROPPED
+  out <- read_excel(test_sheet(""style-only-cells.xlsx""))
+  df <- tibble::tibble(
+    var1 = c(""val1,1"", ""val2,1"", ""val3,1""),
+    var2 = NA_real_,
+    var3 = c(""aa"", ""bb"", ""cc""),
+    X__1 = NA_real_,
+    var5 = c(1, 2, 3)
+  )
+  expect_equal(out, df)
 })

---FILE: tests/testthat/test-sheets.R---
@@ -19,8 +19,14 @@ test_that(""informative error when requesting non-existent sheet by name"", {
 
 test_that(""informative error when requesting non-existent sheet by position"", {
   expect_error(
-    read_excel(test_sheet(""iris-excel.xlsx""), sheet = 200),
-    ""Can't retrieve sheet in position 200""
+    read_excel(test_sheet(""iris-excel.xlsx""), sheet = 2),
+    ""Can't retrieve sheet in position 2, only 1 sheet(s) found."",
+    fixed = TRUE
+  )
+  expect_error(
+    read_excel(test_sheet(""iris-excel.xls""), sheet = 2),
+    ""Can't retrieve sheet in position 2, only 1 sheet(s) found."",
+    fixed = TRUE
   )
 })
 ",True,True,Documentation / Formatting,7
tidyverse,readxl,12dad81d69e777abf5d8b15d86ab0152fe21a14e,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-02-11T19:28:38Z,GitHub,noreply@github.com,2017-02-11T19:28:38Z,"add guess_max param for guessing col_type; fixes #223 (#257)

* add new param n for guessing col_type

* Rename `n` to `guess_max`

* Account for explicit skip in xls col type processing

* Tests re: col types and the new guess_max parameter

* Use guess_max checking and tests from readr

* guess_max EVERYWHERE and consistent default to 1000

* Add NEWS bullet re: guess_max

* oops",NEWS.md;R/RcppExports.R;R/read_excel.R;R/utils.R;man/read_excel.Rd;src/RcppExports.cpp;src/XlsWorkSheet.cpp;src/XlsWorkSheet.h;src/XlsxWorkSheet.cpp;src/XlsxWorkSheet.h;tests/testthat/sheets/types.xls;tests/testthat/sheets/types.xlsx;tests/testthat/test-col-types.R;tests/testthat/test-read-excel.R,False,True,True,False,165,79,244,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # readxl 0.1.1.9000
 
+* New argument `guess_max` lets user adjust the number of rows used to guess column types, similar to functions in readr. (#223, #257 @tklebel, @jennybc)
+
 * Improved handling of empty cells for xlsx. (#248 @jennybc)
 
     - Cells with no content are not loaded. Sheet extent is always computed from loaded cells, instead of the nominal dimensions reported in the worksheet. The result is to not consult the XML for empty cells that appear there simply because they have an associated style or format. This is detectable in Excel as seemingly empty cells with a format other than ""General"".

---FILE: R/RcppExports.R---
@@ -1,14 +1,6 @@
 # Generated by using Rcpp::compileAttributes() -> do not edit by hand
 # Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393
 
-parseXml <- function(base, internal) {
-    invisible(.Call('readxl_parseXml', PACKAGE = 'readxl', base, internal))
-}
-
-countRows <- function(base, sheet) {
-    .Call('readxl_countRows', PACKAGE = 'readxl', base, sheet)
-}
-
 xls_formats <- function(path) {
     .Call('readxl_xls_formats', PACKAGE = 'readxl', path)
 }
@@ -21,8 +13,8 @@ xls_col_names <- function(path, i = 0L, nskip = 0L) {
     .Call('readxl_xls_col_names', PACKAGE = 'readxl', path, i, nskip)
 }
 
-xls_col_types <- function(path, na, sheet = 0L, nskip = 0L, n = 100L, has_col_names = FALSE) {
-    .Call('readxl_xls_col_types', PACKAGE = 'readxl', path, na, sheet, nskip, n, has_col_names)
+xls_col_types <- function(path, na, sheet = 0L, nskip = 0L, guess_max = 1000L, has_col_names = FALSE) {
+    .Call('readxl_xls_col_types', PACKAGE = 'readxl', path, na, sheet, nskip, guess_max, has_col_names)
 }
 
 xls_cols <- function(path, i, col_names, col_types, na, nskip = 0L) {
@@ -49,16 +41,24 @@ parse_ref <- function(ref) {
     .Call('readxl_parse_ref', PACKAGE = 'readxl', ref)
 }
 
-xlsx_col_types <- function(path, sheet = 0L, na = character(), nskip = 0L, n = 100L) {
-    .Call('readxl_xlsx_col_types', PACKAGE = 'readxl', path, sheet, na, nskip, n)
+xlsx_col_types <- function(path, sheet = 0L, na = character(), nskip = 0L, guess_max = 1000L) {
+    .Call('readxl_xlsx_col_types', PACKAGE = 'readxl', path, sheet, na, nskip, guess_max)
 }
 
 xlsx_col_names <- function(path, sheet = 0L, nskip = 0L) {
     .Call('readxl_xlsx_col_names', PACKAGE = 'readxl', path, sheet, nskip)
 }
 
-read_xlsx_ <- function(path, sheet, col_names, col_types, na, nskip = 0L) {
-    .Call('readxl_read_xlsx_', PACKAGE = 'readxl', path, sheet, col_names, col_types, na, nskip)
+read_xlsx_ <- function(path, sheet, col_names, col_types, na, nskip = 0L, guess_max = 1000L) {
+    .Call('readxl_read_xlsx_', PACKAGE = 'readxl', path, sheet, col_names, col_types, na, nskip, guess_max)
+}
+
+parseXml <- function(base, internal) {
+    invisible(.Call('readxl_parseXml', PACKAGE = 'readxl', base, internal))
+}
+
+countRows <- function(base, sheet) {
+    .Call('readxl_countRows', PACKAGE = 'readxl', base, sheet)
 }
 
 zip_xml <- function(zip_path, file_path) {

---FILE: R/read_excel.R---
@@ -15,6 +15,7 @@ NULL
 #' @param na Character vector of strings to use for missing values. By default
 #'   readxl treats blank cells as missing data.
 #' @param skip Number of rows to skip before reading any data.
+#' @param guess_max Maximum number of rows to use for guessing column types.
 #' @export
 #' @examples
 #' datasets <- readxl_example(""datasets.xlsx"")
@@ -27,13 +28,14 @@ NULL
 #' # Skipping rows and using default column names
 #' read_excel(datasets, skip = 148, col_names = FALSE)
 read_excel <- function(path, sheet = 1L, col_names = TRUE, col_types = NULL,
-                       na = """", skip = 0) {
+                       na = """", skip = 0, guess_max = 1000) {
 
   path <- check_file(path)
+  guess_max <- check_guess_max(guess_max)
 
   switch(excel_format(path),
-    xls =  read_xls(path, sheet, col_names, col_types, na, skip),
-    xlsx = read_xlsx(path, sheet, col_names, col_types, na, skip)
+    xls =  read_xls(path, sheet, col_names, col_types, na, skip, guess_max),
+    xlsx = read_xlsx(path, sheet, col_names, col_types, na, skip, guess_max)
   )
 }
 
@@ -44,7 +46,7 @@ read_excel <- function(path, sheet = 1L, col_names = TRUE, col_types = NULL,
 #' @rdname read_excel
 #' @export
 read_xls <- function(path, sheet = 1L, col_names = TRUE, col_types = NULL,
-                     na = """", skip = 0) {
+                     na = """", skip = 0, guess_max = 1000) {
 
   sheet <- standardise_sheet(sheet, xls_sheets(path))
 
@@ -56,7 +58,9 @@ read_xls <- function(path, sheet = 1L, col_names = TRUE, col_types = NULL,
   }
 
   if (is.null(col_types)) {
-    col_types <- xls_col_types(path, sheet, na = na, nskip = skip, has_col_names = has_col_names)
+    col_types <- xls_col_types(path, sheet, na = na, nskip = skip,
+                               has_col_names = has_col_names,
+                               guess_max = guess_max)
   }
 
   tibble::repair_names(
@@ -72,14 +76,14 @@ read_xls <- function(path, sheet = 1L, col_names = TRUE, col_types = NULL,
 #' @rdname read_excel
 #' @export
 read_xlsx <- function(path, sheet = 1L, col_names = TRUE, col_types = NULL,
-                      na = """", skip = 0) {
+                      na = """", skip = 0, guess_max = 1000) {
   path <- check_file(path)
   sheet <- standardise_sheet(sheet, xlsx_sheets(path))
 
   tibble::repair_names(
     tibble::as_tibble(
-      read_xlsx_(path, sheet, col_names = col_names, col_types = col_types,
-                 na = na, nskip = skip),
+      read_xlsx_(path, sheet, col_names, col_types, na,
+                 nskip = skip, guess_max = guess_max),
       validate = FALSE
     ),
     prefix = ""X"", sep = ""__""
@@ -123,3 +127,19 @@ standardise_sheet <- function(sheet, sheet_names) {
     stop(""`sheet` must be either an integer or a string."", call. = FALSE)
   }
 }
+
+## from readr
+check_guess_max <- function(guess_max, max_limit = .Machine$integer.max %/% 100) {
+
+  if (length(guess_max) != 1 || !is.numeric(guess_max) || !is_integerish(guess_max) ||
+      is.na(guess_max) || guess_max < 0) {
+    stop(""`guess_max` must be a positive integer"", call. = FALSE)
+  }
+
+  if (guess_max > max_limit) {
+    warning(""`guess_max` is a very large value, setting to `"", max_limit,
+            ""` to avoid exhausting memory"", call. = FALSE)
+    guess_max <- max_limit
+  }
+  guess_max
+}

---FILE: R/utils.R---
@@ -15,3 +15,7 @@ is_absolute_path <- function(path) {
 }
 
 isFALSE <- function(x) identical(x, FALSE)
+
+is_integerish <- function(x) {
+  floor(x) == x
+}

---FILE: man/read_excel.Rd---
@@ -6,14 +6,14 @@
 \alias{read_xlsx}
 \title{Read xls and xlsx files.}
 \usage{
-read_excel(path, sheet = 1L, col_names = TRUE, col_types = NULL,
-  na = """", skip = 0)
+read_excel(path, sheet = 1, col_names = TRUE, col_types = NULL, na = """",
+  skip = 0, guess_max = 1000)
 
 read_xls(path, sheet = 1L, col_names = TRUE, col_types = NULL, na = """",
-  skip = 0)
+  skip = 0, guess_max = 1000)
 
 read_xlsx(path, sheet = 1L, col_names = TRUE, col_types = NULL, na = """",
-  skip = 0)
+  skip = 0, guess_max = 1000)
 }
 \arguments{
 \item{path}{Path to the xls/xlsx file}
@@ -32,6 +32,8 @@ vector containing one entry per column from these options: ""blank"",
 readxl treats blank cells as missing data.}
 
 \item{skip}{Number of rows to skip before reading any data.}
+
+\item{guess_max}{Maximum number of rows to use for guessing column types.}
 }
 \description{
 Read xls and xlsx files.

---FILE: src/RcppExports.cpp---
@@ -5,29 +5,6 @@
 
 using namespace Rcpp;
 
-// parseXml
-void parseXml(std::string base, std::string internal);
-RcppExport SEXP readxl_parseXml(SEXP baseSEXP, SEXP internalSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< std::string >::type base(baseSEXP);
-    Rcpp::traits::input_parameter< std::string >::type internal(internalSEXP);
-    parseXml(base, internal);
-    return R_NilValue;
-END_RCPP
-}
-// countRows
-int countRows(std::string base, int sheet);
-RcppExport SEXP readxl_countRows(SEXP baseSEXP, SEXP sheetSEXP) {
-BEGIN_RCPP
-    Rcpp::RObject rcpp_result_gen;
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< std::string >::type base(baseSEXP);
-    Rcpp::traits::input_parameter< int >::type sheet(sheetSEXP);
-    rcpp_result_gen = Rcpp::wrap(countRows(base, sheet));
-    return rcpp_result_gen;
-END_RCPP
-}
 // xls_formats
 std::map<int,std::string> xls_formats(std::string path);
 RcppExport SEXP readxl_xls_formats(SEXP pathSEXP) {
@@ -64,18 +41,18 @@ BEGIN_RCPP
 END_RCPP
 }
 // xls_col_types
-CharacterVector xls_col_types(std::string path, std::vector<std::string> na, int sheet, int nskip, int n, bool has_col_names);
-RcppExport SEXP readxl_xls_col_types(SEXP pathSEXP, SEXP naSEXP, SEXP sheetSEXP, SEXP nskipSEXP, SEXP nSEXP, SEXP has_col_namesSEXP) {
+CharacterVector xls_col_types(std::string path, std::vector<std::string> na, int sheet, int nskip, int guess_max, bool has_col_names);
+RcppExport SEXP readxl_xls_col_types(SEXP pathSEXP, SEXP naSEXP, SEXP sheetSEXP, SEXP nskipSEXP, SEXP guess_maxSEXP, SEXP has_col_namesSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
     Rcpp::traits::input_parameter< std::string >::type path(pathSEXP);
     Rcpp::traits::input_parameter< std::vector<std::string> >::type na(naSEXP);
     Rcpp::traits::input_parameter< int >::type sheet(sheetSEXP);
     Rcpp::traits::input_parameter< int >::type nskip(nskipSEXP);
-    Rcpp::traits::input_parameter< int >::type n(nSEXP);
+    Rcpp::traits::input_parameter< int >::type guess_max(guess_maxSEXP);
     Rcpp::traits::input_parameter< bool >::type has_col_names(has_col_namesSEXP);
-    rcpp_result_gen = Rcpp::wrap(xls_col_types(path, na, sheet, nskip, n, has_col_names));
+    rcpp_result_gen = Rcpp::wrap(xls_col_types(path, na, sheet, nskip, guess_max, has_col_names));
     return rcpp_result_gen;
 END_RCPP
 }
@@ -153,17 +130,17 @@ BEGIN_RCPP
 END_RCPP
 }
 // xlsx_col_types
-CharacterVector xlsx_col_types(std::string path, int sheet, CharacterVector na, int nskip, int n);
-RcppExport SEXP readxl_xlsx_col_types(SEXP pathSEXP, SEXP sheetSEXP, SEXP naSEXP, SEXP nskipSEXP, SEXP nSEXP) {
+CharacterVector xlsx_col_types(std::string path, int sheet, CharacterVector na, int nskip, int guess_max);
+RcppExport SEXP readxl_xlsx_col_types(SEXP pathSEXP, SEXP sheetSEXP, SEXP naSEXP, SEXP nskipSEXP, SEXP guess_maxSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
     Rcpp::traits::input_parameter< std::string >::type path(pathSEXP);
     Rcpp::traits::input_parameter< int >::type sheet(sheetSEXP);
     Rcpp::traits::input_parameter< CharacterVector >::type na(naSEXP);
     Rcpp::traits::input_parameter< int >::type nskip(nskipSEXP);
-    Rcpp::traits::input_parameter< int >::type n(nSEXP);
-    rcpp_result_gen = Rcpp::wrap(xlsx_col_types(path, sheet, na, nskip, n));
+    Rcpp::traits::input_parameter< int >::type guess_max(guess_maxSEXP);
+    rcpp_result_gen = Rcpp::wrap(xlsx_col_types(path, sheet, na, nskip, guess_max));
     return rcpp_result_gen;
 END_RCPP
 }
@@ -181,8 +158,8 @@ BEGIN_RCPP
 END_RCPP
 }
 // read_xlsx_
-List read_xlsx_(std::string path, int sheet, RObject col_names, RObject col_types, std::vector<std::string> na, int nskip);
-RcppExport SEXP readxl_read_xlsx_(SEXP pathSEXP, SEXP sheetSEXP, SEXP col_namesSEXP, SEXP col_typesSEXP, SEXP naSEXP, SEXP nskipSEXP) {
+List read_xlsx_(std::string path, int sheet, RObject col_names, RObject col_types, std::vector<std::string> na, int nskip, int guess_max);
+RcppExport SEXP readxl_read_xlsx_(SEXP pathSEXP, SEXP sheetSEXP, SEXP col_namesSEXP, SEXP col_typesSEXP, SEXP naSEXP, SEXP nskipSEXP, SEXP guess_maxSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
@@ -192,7 +169,31 @@ BEGIN_RCPP
     Rcpp::traits::input_parameter< RObject >::type col_types(col_typesSEXP);
     Rcpp::traits::input_parameter< std::vector<std::string> >::type na(naSEXP);
     Rcpp::traits::input_parameter< int >::type nskip(nskipSEXP);
-    rcpp_result_gen = Rcpp::wrap(read_xlsx_(path, sheet, col_names, col_types, na, nskip));
+    Rcpp::traits::input_parameter< int >::type guess_max(guess_maxSEXP);
+    rcpp_result_gen = Rcpp::wrap(read_xlsx_(path, sheet, col_names, col_types, na, nskip, guess_max));
+    return rcpp_result_gen;
+END_RCPP
+}
+// parseXml
+void parseXml(std::string base, std::string internal);
+RcppExport SEXP readxl_parseXml(SEXP baseSEXP, SEXP internalSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< std::string >::type base(baseSEXP);
+    Rcpp::traits::input_parameter< std::string >::type internal(internalSEXP);
+    parseXml(base, internal);
+    return R_NilValue;
+END_RCPP
+}
+// countRows
+int countRows(std::string base, int sheet);
+RcppExport SEXP readxl_countRows(SEXP baseSEXP, SEXP sheetSEXP) {
+BEGIN_RCPP
+    Rcpp::RObject rcpp_result_gen;
+    Rcpp::RNGScope rcpp_rngScope_gen;
+    Rcpp::traits::input_parameter< std::string >::type base(baseSEXP);
+    Rcpp::traits::input_parameter< int >::type sheet(sheetSEXP);
+    rcpp_result_gen = Rcpp::wrap(countRows(base, sheet));
     return rcpp_result_gen;
 END_RCPP
 }

---FILE: src/XlsWorkSheet.cpp---
@@ -13,10 +13,11 @@ CharacterVector xls_col_names(std::string path, int i = 0, int nskip = 0) {
 }
 
 // [[Rcpp::export]]
-CharacterVector xls_col_types(std::string path, std::vector<std::string> na, int sheet = 0,
-                              int nskip = 0, int n = 100, bool has_col_names = false) {
+CharacterVector xls_col_types(std::string path, std::vector<std::string> na,
+                              int sheet = 0, int nskip = 0,
+                              int guess_max = 1000, bool has_col_names = false) {
   XlsWorkBook wb = XlsWorkBook(path);
-  std::vector<CellType> types = wb.sheet(sheet).colTypes(na, nskip + has_col_names, n);
+  std::vector<CellType> types = wb.sheet(sheet).colTypes(na, nskip + has_col_names, guess_max);
 
   CharacterVector out(types.size());
   for (size_t i = 0; i < types.size(); ++i) {

---FILE: src/XlsWorkSheet.h---
@@ -65,10 +65,11 @@ class XlsWorkSheet {
     return out;
   }
 
-  std::vector<CellType> colTypes(const StringSet &na, int nskip = 0, int n_max = 100) {
+  std::vector<CellType> colTypes(const StringSet &na, int nskip = 0,
+                                 int guess_max = 1000) {
     std::vector<CellType> types(ncol_);
 
-    for (int i = nskip; i < nrow_ && i < n_max; ++i) {
+    for (int i = nskip; i < nrow_ && i < nskip + guess_max; ++i) {
       if ((i + 1) % 10000 == 0)
         Rcpp::checkUserInterrupt();
 

---FILE: src/XlsxWorkSheet.cpp---
@@ -17,11 +17,11 @@ IntegerVector parse_ref(std::string ref) {
 
 // [[Rcpp::export]]
 CharacterVector xlsx_col_types(std::string path, int sheet = 0,
-                               CharacterVector na = CharacterVector(), int nskip = 0,
-                               int n = 100) {
+                               CharacterVector na = CharacterVector(),
+                               int nskip = 0, int guess_max = 1000) {
 
   XlsxWorkSheet ws(path, sheet, nskip);
-  std::vector<CellType> types = ws.colTypes(na, nskip, n);
+  std::vector<CellType> types = ws.colTypes(na, nskip, guess_max);
 
   CharacterVector out(types.size());
   for (size_t i = 0; i < types.size(); ++i) {
@@ -38,7 +38,8 @@ CharacterVector xlsx_col_names(std::string path, int sheet = 0, int nskip = 0) {
 
 // [[Rcpp::export]]
 List read_xlsx_(std::string path, int sheet, RObject col_names,
-                RObject col_types, std::vector<std::string> na, int nskip = 0) {
+                RObject col_types, std::vector<std::string> na,
+                int nskip = 0, int guess_max = 1000) {
 
   XlsxWorkSheet ws(path, sheet, nskip);
 
@@ -67,7 +68,7 @@ List read_xlsx_(std::string path, int sheet, RObject col_names,
   std::vector<CellType> colTypes;
   switch(TYPEOF(col_types)) {
   case NILSXP:
-    colTypes = ws.colTypes(na, 100, sheetHasColumnNames);
+    colTypes = ws.colTypes(na, guess_max, sheetHasColumnNames);
     break;
   case STRSXP:
     colTypes = cellTypes(as<CharacterVector>(col_types));

---FILE: src/XlsxWorkSheet.h---
@@ -72,7 +72,8 @@ class XlsxWorkSheet {
   // moved out of here, so we don't read column names again inside this fxn.
   // More comments near end of fxn.
   std::vector<CellType> colTypes(const StringSet& na,
-                                 int n_max = 100, bool has_col_names = false) {
+                                 int guess_max = 1000,
+                                 bool has_col_names = false) {
     std::vector<CellType> types;
     types.resize(ncol_);
 
@@ -93,7 +94,7 @@ class XlsxWorkSheet {
     // account for any empty rows between column headers and data start
     i = it->row() - base;
 
-    while (i < n_max && it != cells_.end()) {
+    while (i < guess_max && it != cells_.end()) {
       // find the end of current row
       row_end = it;
       while(row_end != cells_.end() && row_end->row() == it->row()) {

---FILE: tests/testthat/test-col-types.R---
@@ -0,0 +1,36 @@
+context(""Col types"")
+
+test_that(""types imputed & read correctly [xlsx]"", {
+  types <- read_excel(test_sheet(""types.xlsx""))
+  expect_is(types$number, ""numeric"")
+  expect_is(types$string, ""character"")
+  expect_is(types$boolean, ""numeric"")
+  expect_is(types$date, ""POSIXct"")
+  expect_is(types$string_in_row_3, ""character"")
+  skip(""switch expecation to logical (vs numeric) when possible"")
+})
+
+test_that(""types imputed & read correctly [xls]"", {
+  expect_output(
+    types <- read_excel(test_sheet(""types.xls"")),
+    ""Unknown type: 517""
+  )
+  expect_is(types$number, ""numeric"")
+  expect_is(types$string, ""character"")
+  #expect_is(types$boolean, ""numeric"")
+  #expect_is(types$date, ""POSIXct"")
+  expect_is(types$string_in_row_3, ""character"")
+  skip(""revisit these expectations as xls problems are fixed"")
+})
+
+test_that(""max_guess is honored for col_types [xlsx]"", {
+  expect_warning(
+    types <- read_excel(test_sheet(""types.xlsx""), guess_max = 2),
+    ""expecting numeric""
+  )
+  expect_identical(types$string_in_row_3, c(1, 2, NA))
+})
+
+test_that(""max_guess is honored for col_types [xls]"", {
+  skip(""write this test as xls problems are fixed"")
+})

---FILE: tests/testthat/test-read-excel.R---
@@ -1,12 +1,5 @@
 context(""read_excel"")
 
-test_that(""types imputed & read correctly"", {
-  types <- read_excel(test_sheet(""types.xlsx""))
-  expect_is(types$number, ""numeric"")
-  expect_is(types$string, ""character"")
-  expect_is(types$date, ""POSIXct"")
-})
-
 test_that(""can read sheets with inlineStr"", {
   # Original source: http://our.componentone.com/wp-content/uploads/2011/12/TestExcel.xlsx
   # These appear to come from LibreOffice 4.2.7.2.
@@ -39,3 +32,27 @@ test_that(""can read file without extension"", {
   expect_error(read_xlsx(""iris-xls-no-ending""), ""cannot be opened"")
 
 })
+
+test_that(""read_excel catches invalid guess_max"", {
+
+  expect_error(
+    read_excel(test_sheet(""iris-excel.xlsx""), guess_max = NA),
+    ""`guess_max` must be a positive integer""
+  )
+  expect_error(
+    read_excel(test_sheet(""iris-excel.xlsx""), guess_max = -1),
+    ""`guess_max` must be a positive integer""
+  )
+  expect_warning(
+    read_excel(test_sheet(""iris-excel.xlsx""), guess_max = Inf),
+    ""`guess_max` is a very large value""
+  )
+  expect_error(
+    read_excel(test_sheet(""iris-excel.xlsx""), guess_max = NULL),
+    ""`guess_max` must be a positive integer""
+  )
+  expect_error(
+    read_excel(test_sheet(""iris-excel.xlsx""), guess_max = 1:2),
+    ""`guess_max` must be a positive integer""
+  )
+})",True,False,Documentation / Formatting,7
tidyverse,readxl,c6e0f8f2c06b5b7923e6eeffadbe59b7984ea64d,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-02-06T20:48:11Z,GitHub,noreply@github.com,2017-02-06T20:48:11Z,"Don't load empty cells; use empirical worksheet dimensions (#248)

* Don't load cells that have no child nodes; fixes #162

* Compute worksheet dimension based on loaded cells; fixes #203

* Work on NEWS

* Tests re: empty, styled cells

* Improve style of test code",NEWS.md;src/XlsxWorkSheet.h;tests/testthat/sheets/style-only-cells.xlsx;tests/testthat/test-empty.R,False,True,True,False,48,37,85,"---FILE: NEWS.md---
@@ -1,16 +1,22 @@
 # readxl 0.1.1.9000
 
+* Improved handling of empty cells for xlsx. (#248 @jennybc)
+
+    - Cells with no content are not loaded. Sheet extent is always computed from loaded cells, instead of the nominal dimensions reported in the worksheet. The result is to not consult the XML for empty cells that appear there simply because they have an associated style or format. This is detectable in Excel as seemingly empty cells with a format other than ""General"".
+    - Eliminates a source of trailing rows (#203, although original report was re: xls, which is not fixed yet) and columns (#236, #162, #146) consisting entirely of `NA`.
+    - Eliminates a subtle source of disagreement between user-provided column names and guessed column types (#169, #81). 
+
 * `tibble::repair_names()` is used to prevent empty, `NA`, or duplicated names. (#216, #208, #199 #182, #53, #247 @jennybc)
 
 * Fix compilation warning/failure (FreeBSD 10.3 #221, gcc 4.9.3 #124) and/or problems reading xls (CentOS 6.6 #189). (#244, #245, #246 @jeroenooms)
 
-* `read_xls()` and `read_xlsx()` are now exposed, such that files without an `.xls` or `.xlsx` extension can be read. (#85, @jirkalewandowski)
-
 * Improved parsing of sheet geometry for xlsx. (#240, @jennybc)
 
-    - Better handling of leading and embedded blank rows and explicit row skipping. (#224, #194, #178, #156, #101)
-    - Worksheets that are completely empty or that contain only column names no longer error, but return a tibble with zero rows. (#222, #144, #65)
     - Location is inferred for cells that do not declare their location (e.g. xlsx written by JMP). (#163, #102)
+    - Worksheets that are completely empty or that contain only column names no longer error, but return a tibble with zero rows. (#222, #144, #65)
+    - Better handling of leading and embedded blank rows and explicit row skipping. (#224, #194, #178, #156, #101)
+
+* `read_xls()` and `read_xlsx()` are now exposed, such that files without an `.xls` or `.xlsx` extension can be read. (#85, @jirkalewandowski)
 
 * Logic for sheet lookup in xlsx is more robust. Improves compatibility with xlsx written by tools other than Excel and/or xlsx containing chartsheets. (#233, #104, #200, #168, #116, @jimhester, @jennybc)
 

---FILE: src/XlsxWorkSheet.h---
@@ -53,7 +53,7 @@ class XlsxWorkSheet {
 
     nskip_ = nskip;
     loadCells();
-    cacheDimension();
+    computeDimensions();
     markRows();
   }
 
@@ -256,35 +256,6 @@ class XlsxWorkSheet {
 
 private:
 
-  void cacheDimension() {
-    // 18.3.1.35 dimension (Worksheet Dimensions) [p 1627]
-    rapidxml::xml_node<>* dimension = rootNode_->first_node(""dimension"");
-    if (dimension == NULL) {
-      return computeDimensions();
-    }
-
-    rapidxml::xml_attribute<>* ref = dimension->first_attribute(""ref"");
-    if (ref == NULL) {
-      return computeDimensions();
-    }
-
-    const char* refv = ref->value();
-    while (*refv != ':' && *refv != '\0')
-      ++refv;
-    if (*refv == '\0') {
-      return computeDimensions();
-    }
-
-    ++refv; // advanced past :
-    std::pair<int, int> dim = parseRef(refv);
-    if (dim.first == -1 || dim.second == -1) {
-      return computeDimensions();
-    }
-
-    nrow_ = dim.first + 1; // size is one greater than max position
-    ncol_ = dim.second + 1;
-  }
-
   void loadCells() {
     rapidxml::xml_node<>* row = sheetData_->first_node(""row"");
     if (row == NULL) {
@@ -296,16 +267,20 @@ class XlsxWorkSheet {
       int j = 0;
       for (rapidxml::xml_node<>* cell = row->first_node(""c"");
            cell; cell = cell->next_sibling(""c"")) {
-        XlsxCell xcell(cell, i, j);
-        cells_.push_back(xcell);
+        // don't load a cell with no child nodes, e.g. it only has style
+        rapidxml::xml_node<>* first_child = cell->first_node(0);
+        if (first_child != NULL) {
+          XlsxCell xcell(cell, i, j);
+          cells_.push_back(xcell);
+        }
         j++;
       }
       i++;
     }
 
   }
 
-  // If <dimension> not present, consult location data stored in cells
+  // compute dimension directly from loaded cells
   void computeDimensions() {
     nrow_ = 0;
     ncol_ = 0;

---FILE: tests/testthat/test-empty.R---
@@ -28,3 +28,33 @@ test_that(""non-empty sheets act that way if we skip past everything"", {
   expect_identical(nrow(out), 0L)
   skip(""figure out why empty unnamed columns aren't dropped and update test"")
 })
+
+test_that(""empty cells with a style are not loaded"", {
+  ## what's important about this sheet?
+  ## contains empty cells with a custom format
+  ## therefore they appear in the xml and have a style attribute
+  ## where are they?
+  ## in the embedded empty columns, w/ and w/o a name
+  ## in a trailing empty column
+  ## in some trailing rows
+  out <- read_excel(test_sheet(""style-only-cells.xlsx""))
+  df <- tibble::tibble(var1 = c(""val1,1"", ""val2,1"", ""val3,1""),
+                       var2 = NA_real_,
+                       var3 = c(""aa"", ""bb"", ""cc""),
+                       var5 = c(1, 2, 3))
+  expect_equal(out, df)
+  skip(""revisit this when dust settles re: treatment of empty columns"")
+})
+
+test_that(""user-supplied column names play nicely with empty columns"", {
+  skip(""waiting for dust to settle re: treatment of empty columns"")
+  ## do stuff like this:
+  out <- read_excel(
+    test_sheet(""style-only-cells.xlsx""),
+    col_names = LETTERS[1:4]
+  )
+  out <- read_excel(
+    test_sheet(""style-only-cells.xlsx""),
+    col_names = LETTERS[1:5]
+  )
+})",True,False,Implementation / Logic,6
tidyverse,readxl,387161d72597fbfd80901837c5720a55a7bd8037,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-02-06T16:12:46Z,GitHub,noreply@github.com,2017-02-06T16:12:46Z,"Use tibble::repair_names() to eliminate empty, NA, duplicated column names (#247)

* Remove leading unnamed empty column that is irrelevant to this sheet's test usage

* Use tibble::repair_names(); fixes #199, fixes #53

* Put a version on tibble and switch to as_tibble()",DESCRIPTION;NAMESPACE;NEWS.md;R/read_excel.R;tests/testthat/sheets/empty-named-column.xls;tests/testthat/sheets/empty-named-column.xlsx;tests/testthat/sheets/unnamed-duplicated-columns.xls;tests/testthat/sheets/unnamed-duplicated-columns.xlsx;tests/testthat/test-sheets.R,False,True,True,False,21,7,28,"---FILE: DESCRIPTION---
@@ -21,7 +21,7 @@ LazyData: true
 LinkingTo: Rcpp
 Imports:
     Rcpp (>= 0.11.6),
-    tibble
+    tibble (>= 1.1)
 Suggests:
     covr,
     rprojroot (>= 1.1),

---FILE: NAMESPACE---
@@ -7,5 +7,4 @@ export(read_excel)
 export(read_xls)
 export(read_xlsx)
 importFrom(Rcpp,sourceCpp)
-importFrom(tibble,as_data_frame)
 useDynLib(readxl)

---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # readxl 0.1.1.9000
 
+* `tibble::repair_names()` is used to prevent empty, `NA`, or duplicated names. (#216, #208, #199 #182, #53, #247 @jennybc)
+
 * Fix compilation warning/failure (FreeBSD 10.3 #221, gcc 4.9.3 #124) and/or problems reading xls (CentOS 6.6 #189). (#244, #245, #246 @jeroenooms)
 
 * `read_xls()` and `read_xlsx()` are now exposed, such that files without an `.xls` or `.xlsx` extension can be read. (#85, @jirkalewandowski)

---FILE: R/read_excel.R---
@@ -1,6 +1,5 @@
 #' @useDynLib readxl
 #' @importFrom Rcpp sourceCpp
-#' @importFrom tibble as_data_frame
 NULL
 
 #' Read xls and xlsx files.
@@ -57,11 +56,11 @@ read_xls <- function(path, sheet = 1, col_names = TRUE, col_types = NULL,
     col_types <- xls_col_types(path, sheet, na = na, nskip = skip, has_col_names = has_col_names)
   }
 
-  as_data_frame(
+  tibble::repair_names(tibble::as_tibble(
     xls_cols(path, sheet, col_names = col_names, col_types = col_types, na = na,
              nskip = skip + has_col_names),
     validate = FALSE
-  )
+  ))
 }
 
 #' @rdname read_excel
@@ -71,11 +70,11 @@ read_xlsx <- function(path, sheet = 1L, col_names = TRUE, col_types = NULL,
   path <- check_file(path)
   sheet <- standardise_sheet(sheet, xlsx_sheets(path))
 
-  as_data_frame(
+  tibble::repair_names(tibble::as_tibble(
     read_xlsx_(path, sheet, col_names = col_names, col_types = col_types, na = na,
                nskip = skip),
     validate = FALSE
-  )
+  ))
 }
 
 # Helper functions -------------------------------------------------------------

---FILE: tests/testthat/test-sheets.R---
@@ -59,3 +59,17 @@ test_that(""sheet data xml target is explicitly looked up (#104, #80)"", {
     expect_identical(df$continent[1], countries[i])
   }
 })
+
+test_that(""missing column names are populated"", {
+  df <- read_excel(test_sheet(""unnamed-duplicated-columns.xlsx""))
+  expect_identical(names(df)[c(1, 3)], c(""V1"", ""V2""))
+  df <- read_excel(test_sheet(""unnamed-duplicated-columns.xls""))
+  expect_identical(names(df)[c(1, 3)], c(""V1"", ""V2""))
+})
+
+test_that(""column names are de-duplicated"", {
+  df <- read_excel(test_sheet(""unnamed-duplicated-columns.xlsx""))
+  expect_identical(names(df)[4], ""var21"")
+  df <- read_excel(test_sheet(""unnamed-duplicated-columns.xls""))
+  expect_identical(names(df)[4], ""var21"")
+})",True,False,Reproducibility / Versioning,7
tidyverse,readxl,3338f92a830017962f7becdbc3d2e40e32f703f6,jennybc,jenny@stat.ubc.ca,2017-02-04T09:05:06Z,jennybc,jenny@stat.ubc.ca,2017-02-04T09:05:06Z,NEWS bullet re: recent fixes by @jeroenooms,NEWS.md,False,False,False,False,2,0,2,"---FILE: NEWS.md---
@@ -1,5 +1,7 @@
 # readxl 0.1.1.9000
 
+* Fix compilation warning/failure (FreeBSD 10.3 #221, gcc 4.9.3 #124) and/or problems reading xls (CentOS 6.6 #189). (#244, #245, #246 @jeroenooms)
+
 * `read_xls()` and `read_xlsx()` are now exposed, such that files without an `.xls` or `.xlsx` extension can be read. (#85, @jirkalewandowski)
 
 * Improved parsing of sheet geometry for xlsx. (#240, @jennybc)",False,False,Documentation / Formatting,4
tidyverse,readxl,d5c76f257a4f44555743602464dd9ceb5cf64867,Jeroen Ooms,jeroenooms@gmail.com,2017-02-04T02:34:23Z,Jeroen Ooms,jeroenooms@gmail.com,2017-02-04T02:34:23Z,Fix compiler warning,src/xlstool.c,False,False,False,False,1,1,2,"---FILE: src/xlstool.c---
@@ -642,7 +642,7 @@ BYTE *xls_getfcell(xlsWorkBook* pWB,struct st_cell_data* cell,WORD *label)
         break;
     case XLS_RECORD_BLANK:
     case XLS_RECORD_MULBLANK:
-        asprintf(&ret, """");
+        asprintf(&ret, ""%s"", """");
         break;
     case XLS_RECORD_LABEL:
 		len = xlsShortVal(*label);",False,False,Rendering / Conversion,0
tidyverse,readxl,55291b435fef0320064f3eb63fb8b06d236dbfec,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-01-31T19:06:12Z,GitHub,noreply@github.com,2017-01-31T19:06:12Z,"Load cells at xlsx worksheet ingest; handle skipping and/or blank row… (#240)

* Load cells at xlsx worksheet ingest; handle skipping and/or blank rows; fixes #224

* Actually these *should* be the same

* Make skipping tests more challenging (blank row btwn col names and data, plus another embedded blank row)

* Simplify return of 0x0 tibble for completely empty worksheet

* Mark cells to start reading from at the time of worksheet construction

* Remove vestigial, internal cell printing function

* Be quiet about empty worksheet

* More tests of nothingness

* Inform worksheet about its own name

* Tighten up the NEWs bullet for this PR

* Make some accessor member functions const

* Use skip() to issue note-to-future-self

Expedient place to park a summary of what this entire PR does.

* Improved parsing of sheet geometry for xlsx. (#240, @jennybc).

    - Better handling of leading and embedded blank rows and explicit row skipping. (#224, #194, #178, #156, #101)
    - Worksheets that are completely empty or that contain only column names no longer error, but return a tibble with zero rows. (#222, #144, #65)
    - Location is inferred for cells that do not declare their location (e.g. xlsx written by JMP). (#163, #102)",NEWS.md;R/RcppExports.R;README.md;src/CellType.h;src/RcppExports.cpp;src/XlsxCell.h;src/XlsxWorkBook.h;src/XlsxWorkSheet.cpp;src/XlsxWorkSheet.h;tests/testthat/sheets/blanks.xls;tests/testthat/sheets/blanks.xlsx;tests/testthat/sheets/empty-sheets.xlsx;tests/testthat/sheets/skipping.xlsx;tests/testthat/test-empty.R;tests/testthat/test-missing-values.R;tests/testthat/test-return.R;tests/testthat/test-skipping.R,False,True,True,False,346,146,492,"---FILE: NEWS.md---
@@ -1,5 +1,11 @@
 # readxl 0.1.1.9000
 
+* Improved parsing of sheet geometry for xlsx. (#240, @jennybc).
+
+    - Better handling of leading and embedded blank rows and explicit row skipping. (#224, #194, #178, #156, #101)
+    - Worksheets that are completely empty or that contain only column names no longer error, but return a tibble with zero rows. (#222, #144, #65)
+    - Location is inferred for cells that do not declare their location (e.g. xlsx written by JMP). (#163, #102)
+
 * Logic for sheet lookup in xlsx is more robust. Improves compatibility with xlsx written by tools other than Excel and/or xlsx containing chartsheets. (#233, #104, #200, #168, #116, @jimhester, @jennybc)
 
 * Support multiple NA values, e.g., `read_excel(""missing-values.xls"", na = c(""NA"", ""1""))` (#13, #56, @jmarshallnz).

---FILE: R/RcppExports.R---
@@ -41,12 +41,8 @@ xlsx_date_styles <- function(path) {
     .Call('readxl_xlsx_date_styles', PACKAGE = 'readxl', path)
 }
 
-xlsx_cells <- function(path, sheet = 0L) {
-    invisible(.Call('readxl_xlsx_cells', PACKAGE = 'readxl', path, sheet))
-}
-
-xlsx_dim <- function(path, sheet = 0L) {
-    .Call('readxl_xlsx_dim', PACKAGE = 'readxl', path, sheet)
+xlsx_dim <- function(path, sheet = 0L, nskip = 0L) {
+    .Call('readxl_xlsx_dim', PACKAGE = 'readxl', path, sheet, nskip)
 }
 
 parse_ref <- function(ref) {

---FILE: README.md---
@@ -46,7 +46,7 @@ read_excel(""my-spreadsheet.xls"", na = ""NA"")
 * Loads datetimes into POSIXct columns. Both Windows (1900) and Mac (1904) 
   date specifications are processed correctly.
 
-* Blank columns and rows are automatically dropped.
+* Blank columns are automatically dropped. Blank rows that appear before the data are automatically dropped; embedded blank rows are not.
 
 * It returns data frames with additional `tbl_df` class, so if you have
   dplyr loaded, you get nicer printing.

---FILE: src/CellType.h---
@@ -142,6 +142,7 @@ inline Rcpp::RObject makeCol(CellType type, int n) {
   switch(type) {
   case CELL_BLANK:
     return R_NilValue;
+    break;
   case CELL_DATE: {
     Rcpp::RObject col = Rcpp::NumericVector(n, NA_REAL);
     col.attr(""class"") = Rcpp::CharacterVector::create(""POSIXct"", ""POSIXt"");

---FILE: src/RcppExports.cpp---
@@ -128,26 +128,16 @@ BEGIN_RCPP
     return rcpp_result_gen;
 END_RCPP
 }
-// xlsx_cells
-void xlsx_cells(std::string path, int sheet);
-RcppExport SEXP readxl_xlsx_cells(SEXP pathSEXP, SEXP sheetSEXP) {
-BEGIN_RCPP
-    Rcpp::RNGScope rcpp_rngScope_gen;
-    Rcpp::traits::input_parameter< std::string >::type path(pathSEXP);
-    Rcpp::traits::input_parameter< int >::type sheet(sheetSEXP);
-    xlsx_cells(path, sheet);
-    return R_NilValue;
-END_RCPP
-}
 // xlsx_dim
-IntegerVector xlsx_dim(std::string path, int sheet);
-RcppExport SEXP readxl_xlsx_dim(SEXP pathSEXP, SEXP sheetSEXP) {
+IntegerVector xlsx_dim(std::string path, int sheet, int nskip);
+RcppExport SEXP readxl_xlsx_dim(SEXP pathSEXP, SEXP sheetSEXP, SEXP nskipSEXP) {
 BEGIN_RCPP
     Rcpp::RObject rcpp_result_gen;
     Rcpp::RNGScope rcpp_rngScope_gen;
     Rcpp::traits::input_parameter< std::string >::type path(pathSEXP);
     Rcpp::traits::input_parameter< int >::type sheet(sheetSEXP);
-    rcpp_result_gen = Rcpp::wrap(xlsx_dim(path, sheet));
+    Rcpp::traits::input_parameter< int >::type nskip(nskipSEXP);
+    rcpp_result_gen = Rcpp::wrap(xlsx_dim(path, sheet, nskip));
     return rcpp_result_gen;
 END_RCPP
 }

---FILE: src/XlsxCell.h---
@@ -36,19 +36,21 @@ class XlsxCell {
 
 public:
 
-  XlsxCell(rapidxml::xml_node<>* cell): cell_(cell) {
+  // if possible, provide guess at row and column based on position within xml
+  XlsxCell(rapidxml::xml_node<>* cell, int row = -1, int col = -1): cell_(cell) {
     rapidxml::xml_attribute<>* ref = cell_->first_attribute(""r"");
-    if (ref == NULL)
-      Rcpp::stop(""Invalid cell: lacks ref attribute"");
-
-    location_ = parseRef(ref->value());
+    if (ref == NULL) {
+      location_ = std::make_pair(row, col);
+    } else {
+      location_ = parseRef(ref->value());
+    }
   }
 
-  int row() {
+  int row() const {
     return location_.first;
   }
 
-  int col() {
+  int col()  const {
     return location_.second;
   }
 

---FILE: src/XlsxWorkBook.h---
@@ -10,7 +10,7 @@
 
 class XlsxWorkBook {
 
-  // holds objects related to sheet position, name, and xml target file
+  // holds objects related to sheet position, name, Id, and xml target file
   class SheetRelations {
     int n_;
     Rcpp::CharacterVector names_;

---FILE: src/XlsxWorkSheet.cpp---
@@ -3,13 +3,8 @@
 using namespace Rcpp;
 
 // [[Rcpp::export]]
-void xlsx_cells(std::string path, int sheet = 0) {
-  return XlsxWorkSheet(path, sheet).printCells();
-}
-
-// [[Rcpp::export]]
-IntegerVector xlsx_dim(std::string path, int sheet = 0) {
-  XlsxWorkSheet ws(path, sheet);
+IntegerVector xlsx_dim(std::string path, int sheet = 0, int nskip = 0) {
+  XlsxWorkSheet ws(path, sheet, nskip);
   return IntegerVector::create(ws.nrow(), ws.ncol());
 }
 
@@ -25,7 +20,7 @@ CharacterVector xlsx_col_types(std::string path, int sheet = 0,
                                CharacterVector na = CharacterVector(), int nskip = 0,
                                int n = 100) {
 
-  XlsxWorkSheet ws(path, sheet);
+  XlsxWorkSheet ws(path, sheet, nskip);
   std::vector<CellType> types = ws.colTypes(na, nskip, n);
 
   CharacterVector out(types.size());
@@ -38,14 +33,18 @@ CharacterVector xlsx_col_types(std::string path, int sheet = 0,
 
 // [[Rcpp::export]]
 CharacterVector xlsx_col_names(std::string path, int sheet = 0, int nskip = 0) {
-  return XlsxWorkSheet(path, sheet).colNames(nskip);
+  return XlsxWorkSheet(path, sheet, nskip).colNames();
 }
 
 // [[Rcpp::export]]
 List read_xlsx_(std::string path, int sheet, RObject col_names,
                 RObject col_types, std::vector<std::string> na, int nskip = 0) {
 
-  XlsxWorkSheet ws(path, sheet);
+  XlsxWorkSheet ws(path, sheet, nskip);
+
+  if (ws.nrow() == 0 && ws.ncol() == 0) {
+    return Rcpp::List(0);
+  }
 
   // Standardise column names --------------------------------------------------
   CharacterVector colNames;
@@ -58,7 +57,7 @@ List read_xlsx_(std::string path, int sheet, RObject col_names,
   {
     sheetHasColumnNames = as<bool>(col_names);
     if (sheetHasColumnNames) {
-      colNames = ws.colNames(nskip);
+      colNames = ws.colNames();
     } else {
       int p = ws.ncol();
       colNames = CharacterVector(p);
@@ -76,7 +75,7 @@ List read_xlsx_(std::string path, int sheet, RObject col_names,
   std::vector<CellType> colTypes;
   switch(TYPEOF(col_types)) {
   case NILSXP:
-    colTypes = ws.colTypes(na, nskip, 100, sheetHasColumnNames);
+    colTypes = ws.colTypes(na, 100, sheetHasColumnNames);
     break;
   case STRSXP:
     colTypes = cellTypes(as<CharacterVector>(col_types));
@@ -85,5 +84,5 @@ List read_xlsx_(std::string path, int sheet, RObject col_names,
     Rcpp::stop(""`col_types` must be a character vector or NULL"");
   }
 
-  return ws.readCols(colNames, colTypes, na, nskip + sheetHasColumnNames);
+  return ws.readCols(colNames, colTypes, na, sheetHasColumnNames);
 }

---FILE: src/XlsxWorkSheet.h---
@@ -20,133 +20,198 @@ class XlsxWorkSheet {
   rapidxml::xml_document<> sheetXml_;
   rapidxml::xml_node<>* rootNode_;
   rapidxml::xml_node<>* sheetData_;
-  int ncol_, nrow_;
+  std::vector<XlsxCell> cells_;
+  std::string sheetName_;
+  int ncol_, nrow_, nskip_;
+  std::vector<XlsxCell>::const_iterator firstRow_, secondRow_;
 
 public:
 
-  XlsxWorkSheet(XlsxWorkBook wb, int sheet_i): wb_(wb) {
+  XlsxWorkSheet(XlsxWorkBook wb, int sheet_i, int nskip):
+  wb_(wb)
+  {
     if (sheet_i > wb.n_sheets()) {
       Rcpp::stop(""Can't retrieve sheet in position %d, only %d sheets found."",
                  sheet_i,  wb.n_sheets());
     }
+    sheetName_ = wb.sheets()[sheet_i];
     std::string sheetPath = wb.sheetPath(sheet_i);
     sheet_ = zip_buffer(wb.path(), sheetPath);
     sheetXml_.parse<0>(&sheet_[0]);
 
     rootNode_ = sheetXml_.first_node(""worksheet"");
-    if (rootNode_ == NULL)
-      Rcpp::stop(""Invalid sheet xml (no <worksheet>)"");
+    if (rootNode_ == NULL) {
+      Rcpp::stop(""Sheet '%s' (position %d): Invalid sheet xml (no <worksheet>)"",
+                 sheetName_, sheet_i + 1);
+    }
 
     sheetData_ = rootNode_->first_node(""sheetData"");
-    if (sheetData_ == NULL)
-      Rcpp::stop(""Invalid sheet xml (no <sheetData>)"");
+    if (sheetData_ == NULL) {
+      Rcpp::stop(""Sheet '%s' (position %d): Invalid sheet xml (no <sheetData>)"",
+                 sheetName_, sheet_i + 1);
+    }
 
+    nskip_ = nskip;
+    loadCells();
     cacheDimension();
+    markRows();
   }
 
-  int ncol() {
+  int ncol() const {
     return ncol_;
   }
 
-  int nrow() {
+  int nrow() const {
     return nrow_;
   }
 
-  void printCells() {
-    for (rapidxml::xml_node<>* row = sheetData_->first_node(""row"");
-         row; row = row->next_sibling(""row"")) {
+  std::string sheetName() const {
+    return sheetName_;
+  }
 
-      for (rapidxml::xml_node<>* cell = row->first_node(""c"");
-           cell; cell = cell->next_sibling(""c"")) {
+  // JB: this should either take colNames as an argument or have a bit of code
+  // moved out of here, so we don't read column names again inside this fxn.
+  // More comments near end of fxn.
+  std::vector<CellType> colTypes(const StringSet& na,
+                                 int n_max = 100, bool has_col_names = false) {
+    std::vector<CellType> types;
+    types.resize(ncol_);
 
-        XlsxCell xcell(cell);
-        Rcpp::Rcout << xcell.row() << "","" << xcell.row() << "": "" <<
-          cellTypeDesc(xcell.type("""", wb_.stringTable(), wb_.dateStyles())) << ""\n"";
-      }
+    std::vector<XlsxCell>::const_iterator it;
+    if (has_col_names) {
+      it = secondRow_;
+    } else {
+      it = firstRow_;
     }
-  }
 
+    // no cell data to consult re: types
+    if (it == cells_.end()) {
+      for (size_t i = 0; i < types.size(); i++) {
+        types[i] = CELL_NUMERIC;
+      }
+      return types;
+    }
 
-  std::vector<CellType> colTypes(const StringSet& na, int nskip = 0, int n_max = 100, bool has_col_names = false) {
-    rapidxml::xml_node<>* row = getRow(nskip + has_col_names);
-    std::vector<CellType> types;
-    types.resize(ncol_);
+    int base = firstRow_->row() + has_col_names;
+    std::vector<XlsxCell>::const_iterator row_end;
 
-    int i = 0;
-    while(i < n_max && row != NULL) {
-      for (rapidxml::xml_node<>* cell = row->first_node(""c"");
-           cell; cell = cell->next_sibling(""c"")) {
+    // we have consulted i rows re: determining col types
+    int i;
+    // account for any empty rows between column headers and data start
+    i = it->row() - base;
 
-        XlsxCell xcell(cell);
-        if (xcell.col() >= ncol_)
-          continue;
+    while (i < n_max && it != cells_.end()) {
+      // find the end of current row
+      row_end = it;
+      while(row_end != cells_.end() && row_end->row() == it->row()) {
+        row_end++;
+      }
 
-        CellType type = xcell.type(na, wb_.stringTable(), wb_.dateStyles());
-        if (type >= types[xcell.col()]) {
-          types[xcell.col()] = type;
+      while (it != row_end) {
+        XlsxCell xcell = *it;
+        if (xcell.col() < ncol_) {
+          CellType type = xcell.type(na, wb_.stringTable(), wb_.dateStyles());
+          if (type > types[xcell.col()]) {
+            types[xcell.col()] = type;
+          }
         }
+        it++;
       }
 
-      row = row->next_sibling(""row"");
       i++;
     }
 
+    // JB: this usually rederives the column names, which seems unwise
+    // I propose to move such reconciliation of column names and types out
+    // of here and into the parent function , read_xlsx_()
     if (has_col_names) {
       // blank columns with a name aren't blank
-      Rcpp::CharacterVector names = colNames(nskip);
+      Rcpp::CharacterVector names = colNames();
       for (size_t i = 0; i < types.size(); i++) {
         if (types[i] == CELL_BLANK && names[i] != NA_STRING && names[i] != """")
           types[i] = CELL_NUMERIC;
       }
     }
-
     return types;
   }
 
-  Rcpp::CharacterVector colNames(int nskip = 0) {
-    rapidxml::xml_node<>* row = getRow(nskip);
-
+  Rcpp::CharacterVector colNames() {
     Rcpp::CharacterVector out(ncol_);
-    for (rapidxml::xml_node<>* cell = row->first_node(""c"");
-         cell; cell = cell->next_sibling(""c"")) {
-      XlsxCell xcell(cell);
+    std::vector<XlsxCell>::const_iterator it = firstRow_;
+    int base = it->row();
 
-      if (xcell.col() >= ncol_)
-        continue;
+    while(it != cells_.end() && it->row() == base) {
+      XlsxCell xcell = *it;
+      if (xcell.col() >= ncol_) {
+        break;
+      }
       out[xcell.col()] = xcell.asCharSxp("""", wb_.stringTable());
+      it++;
     }
-
     return out;
   }
 
   Rcpp::List readCols(Rcpp::CharacterVector names,
                       const std::vector<CellType>& types,
-                      const StringSet& na, int nskip = 0) {
+                      const StringSet& na,
+                      bool has_col_names = false) {
+    // JB: suspect this should move out of here and into a function that does
+    // this and the last rationalization re col names and types in colTypes
     if ((int) names.size() != ncol_ || (int) types.size() != ncol_)
       Rcpp::stop(""Need one name and type for each column"");
 
-    // Initialise columns
-    int n = nrow_ - nskip;
+    std::vector<XlsxCell>::const_iterator it;
+    if (has_col_names) {
+      it = secondRow_;
+    } else {
+      it = firstRow_;
+    }
+
+    // no cell data to read
+    if (it == cells_.end()) {
+      Rcpp::List cols(ncol_);
+      for (int j = 0; j < ncol_; ++j) {
+        cols[j] = makeCol(types[j], 0);
+      }
+      return removeBlankColumns(cols, names, types);
+    }
+
+    int base = firstRow_->row() + has_col_names;
+    std::vector<XlsxCell>::const_iterator row_end;
+
+    // we have read i rows of data
+    int i;
+    // account for any empty rows between column headers and data start
+    i = it->row() - base;
+
+    // Initialise columns, accounting for leading skipped or blank rows
+    int n = nrow_ - base;
     Rcpp::List cols(ncol_);
     for (int j = 0; j < ncol_; ++j) {
       cols[j] = makeCol(types[j], n);
     }
 
-    int i = 0;
-    for (rapidxml::xml_node<>* row = getRow(nskip);
-         row; row = row->next_sibling(""row"")) {
-      if ((i + 1) % 1000 == 0)
+    while (it != cells_.end()) {
+
+      if ((i + 1) % 1000 == 0) {
         Rcpp::checkUserInterrupt();
+      }
 
-      for (rapidxml::xml_node<>* cell = row->first_node(""c"");
-           cell; cell = cell->next_sibling(""c"")) {
+      // find the end of this row
+      row_end = it;
+      while(row_end != cells_.end() && row_end->row() == it->row()) {
+        row_end++;
+      }
 
-        XlsxCell xcell(cell);
-        CellType type = xcell.type(na, wb_.stringTable(), wb_.dateStyles());
-        if (xcell.col() >= ncol_)
+      while (it != row_end) {
+        XlsxCell xcell = *it;
+        if (xcell.col() >= ncol_) {
           continue;
-
+        }
+        CellType type = xcell.type(na, wb_.stringTable(), wb_.dateStyles());
         Rcpp::RObject col = cols[xcell.col()];
+        // row to write into
+        int row = xcell.row() - base;
         // Needs to compare to actual cell type to give warnings
         switch(types[xcell.col()]) {
         case CELL_BLANK:
@@ -155,43 +220,45 @@ class XlsxWorkSheet {
           switch(type) {
           case CELL_NUMERIC:
           case CELL_DATE:
-            REAL(col)[i] = xcell.asDouble(na);
+            REAL(col)[row] = xcell.asDouble(na);
             break;
           case CELL_BLANK:
-            REAL(col)[i] = NA_REAL;
+            REAL(col)[row] = NA_REAL;
             break;
           case CELL_TEXT:
             Rcpp::warning(""[%i, %i]: expecting numeric: got '%s'"",
-              xcell.row() + 1, xcell.col() + 1, xcell.asStdString(wb_.stringTable()));
-            REAL(col)[i] = NA_REAL;
+                          xcell.row() + 1, xcell.col() + 1,
+                          xcell.asStdString(wb_.stringTable()));
+            REAL(col)[row] = NA_REAL;
           }
           break;
         case CELL_DATE:
           switch(type) {
           case CELL_DATE:
-            REAL(col)[i] = xcell.asDate(na, wb_.offset());
+            REAL(col)[row] = xcell.asDate(na, wb_.offset());
             break;
           case CELL_BLANK:
-            REAL(col)[i] = NA_REAL;
+            REAL(col)[row] = NA_REAL;
             break;
           case CELL_NUMERIC:
           case CELL_TEXT:
             Rcpp::warning(""[%i, %i]: expecting date: got '%s'"",
-              xcell.row() + 1, xcell.col() + 1, xcell.asStdString(wb_.stringTable()));
-            REAL(col)[i] = NA_REAL;
+                          xcell.row() + 1, xcell.col() + 1,
+                          xcell.asStdString(wb_.stringTable()));
+            REAL(col)[row] = NA_REAL;
             break;
           }
           break;
         case CELL_TEXT:
           if (type == CELL_BLANK) {
-            SET_STRING_ELT(col, i, NA_STRING);
+            SET_STRING_ELT(col, row, NA_STRING);
           } else {
-            SET_STRING_ELT(col, i, xcell.asCharSxp(na, wb_.stringTable()));
+            SET_STRING_ELT(col, row, xcell.asCharSxp(na, wb_.stringTable()));
           }
           break;
         }
+        it++;
       }
-
       ++i;
     }
 
@@ -201,67 +268,112 @@ class XlsxWorkSheet {
 
 private:
 
-  rapidxml::xml_node<>* getRow(int i) {
-    rapidxml::xml_node<>* row = sheetData_->first_node(""row"");
-    while(i > 0 && row != NULL) {
-      row = row->next_sibling(""row"");
-      i--;
-    }
-    if (row == NULL)
-      Rcpp::stop(""Skipped over all data"");
-
-    return row;
-  }
-
   void cacheDimension() {
     // 18.3.1.35 dimension (Worksheet Dimensions) [p 1627]
     rapidxml::xml_node<>* dimension = rootNode_->first_node(""dimension"");
-    if (dimension == NULL)
+    if (dimension == NULL) {
       return computeDimensions();
+    }
 
     rapidxml::xml_attribute<>* ref = dimension->first_attribute(""ref"");
-    if (ref == NULL)
+    if (ref == NULL) {
       return computeDimensions();
+    }
 
     const char* refv = ref->value();
     while (*refv != ':' && *refv != '\0')
       ++refv;
-    if (*refv == '\0')
+    if (*refv == '\0') {
       return computeDimensions();
+    }
 
     ++refv; // advanced past :
     std::pair<int, int> dim = parseRef(refv);
-    if (dim.first == -1 || dim.second == -1)
+    if (dim.first == -1 || dim.second == -1) {
       return computeDimensions();
+    }
 
     nrow_ = dim.first + 1; // size is one greater than max position
     ncol_ = dim.second + 1;
   }
 
-  void computeDimensions() {
-    // If <dimension> not present, iterate over all rows and cells to count
-    nrow_ = 0;
-    ncol_ = 0;
-
-    for (rapidxml::xml_node<>* row = sheetData_->first_node(""row"");
-      row; row = row->next_sibling(""row"")) {
+  void loadCells() {
+    rapidxml::xml_node<>* row = sheetData_->first_node(""row"");
+    if (row == NULL) {
+      return;
+    }
 
+    int i = 0;
+    for (; row; row = row->next_sibling(""row"")) {
+      int j = 0;
       for (rapidxml::xml_node<>* cell = row->first_node(""c"");
-        cell; cell = cell->next_sibling(""c"")) {
+           cell; cell = cell->next_sibling(""c"")) {
+        XlsxCell xcell(cell, i, j);
+        cells_.push_back(xcell);
+        j++;
+      }
+      i++;
+    }
 
-        XlsxCell xcell(cell);
-        if (nrow_ < xcell.row())
-          nrow_ = xcell.row();
+  }
 
-        if (ncol_ < xcell.col())
-          ncol_ = xcell.col();
+  // If <dimension> not present, consult location data stored in cells
+  void computeDimensions() {
+    nrow_ = 0;
+    ncol_ = 0;
 
+    // empty sheet case
+    if (cells_.size() == 0) {
+      return;
+    }
+    for (std::vector<XlsxCell>::const_iterator it = cells_.begin();
+         it != cells_.end(); ++it) {
+      XlsxCell xcell = *it;
+      if (nrow_ < xcell.row()) {
+        nrow_ = xcell.row();
+      }
+      if (ncol_ < xcell.col()) {
+        ncol_ = xcell.col();
       }
     }
     nrow_++;
     ncol_++;
   }
 
+  // Position iterators at various landmarks for reading:
+  // firstRow_ = first cell for which declared row >= nskip
+  // secondRow_ = first cell for which declared row > that of firstRow_
+  // fallback value is cells_.end() if the above not possible
+  void markRows() {
+    // empty sheet case
+    if (cells_.size() == 0) {
+      return;
+    }
+
+    firstRow_ = cells_.end();
+    secondRow_ = cells_.end();
+
+    std::vector<XlsxCell>::const_iterator it = cells_.begin();
+    while (it != cells_.end() && it->row() < nskip_) {
+      it++;
+    }
+    if (it == cells_.end()) {
+      return;
+    }
+    firstRow_ = it++;
+
+    while (it != cells_.end()) {
+      if (it->row() < firstRow_->row()) {
+        secondRow_ = firstRow_;
+        firstRow_ = it;
+      } else if (it->row() > firstRow_->row() &&
+        (secondRow_ == cells_.end() || it->row() < secondRow_->row())) {
+        secondRow_ = it;
+      }
+      ++it;
+    }
+  }
+
 };
 
 #endif

---FILE: tests/testthat/test-empty.R---
@@ -0,0 +1,30 @@
+context(""Empty sheets"")
+
+test_that(""completely empty sheets are handled"", {
+  out <- read_excel(test_sheet(""empty-sheets.xlsx""), ""empty"")
+  expect_identical(out, tibble::tibble())
+
+  out <- read_excel(test_sheet(""empty-sheets.xlsx""), ""empty"", skip = 3)
+  expect_identical(out, tibble::tibble())
+
+  out <- read_excel(test_sheet(""empty-sheets.xlsx""), ""empty"", col_names = ""a"")
+  expect_identical(out, tibble::tibble())
+
+  out <- read_excel(test_sheet(""empty-sheets.xlsx""), ""empty"", col_names = FALSE)
+  expect_identical(out, tibble::tibble())
+})
+
+test_that(""sheets with column names only are handled"", {
+  out <- read_excel(test_sheet(""empty-sheets.xlsx""), ""header_only"")
+  expect_identical(out, tibble::tibble(var1 = numeric(), var2 = numeric()))
+})
+
+test_that(""non-empty sheets act that way if we skip past everything"", {
+  ## currently we get a 0-row tibble with 2 unnamed columns
+  ## a big improvement but when I rationlize column names, see why these
+  ## empty column names aren't causing the columns to be dropped and fix it
+  out <- read_excel(test_sheet(""skipping.xlsx""), skip = 10)
+  expect_is(out, ""tbl_df"")
+  expect_identical(nrow(out), 0L)
+  skip(""figure out why empty unnamed columns aren't dropped and update test"")
+})

---FILE: tests/testthat/test-missing-values.R---
@@ -1,17 +1,29 @@
 context(""Missing values"")
 
-test_that(""blanks read as missing [xlsx]"", {
-  blanks <- read_excel(test_sheet(""blanks.xlsx""))
+test_that(""blanks in different rows read as missing [xlsx]"", {
+  blanks <- read_excel(test_sheet(""blanks.xlsx""), sheet = ""different_rows"")
   expect_equal(blanks$x, c(NA, 1))
   expect_equal(blanks$y, c(""a"", NA))
 })
 
 test_that(""blanks read as missing [xls]"", {
-  blanks <- read_excel(test_sheet(""blanks.xls""))
+  blanks <- read_excel(test_sheet(""blanks.xls""), sheet = ""different_rows"")
   expect_equal(blanks$x, c(NA, 1))
   expect_equal(blanks$y, c(""a"", NA))
 })
 
+test_that(""blanks in same middle row are read as missing [xlsx]"", {
+  blanks <- read_excel(test_sheet(""blanks.xlsx""), sheet = ""same_row_middle"")
+  expect_equal(blanks$x, c(1, NA, 2))
+  expect_equal(blanks$y, c(""a"", NA, ""b""))
+})
+
+test_that(""blanks in same, first row are read as missing [xlsx]"", {
+  blanks <- read_excel(test_sheet(""blanks.xlsx""), sheet = ""same_row_first"")
+  expect_equal(blanks$x, c(NA, 1))
+  expect_equal(blanks$y, c(NA, ""a""))
+})
+
 test_that(""By default, NA read as text"", {
   df <- read_xls(test_sheet(""missing-values.xls""))
   expect_equal(df$x, c(""NA"", ""1.000000"", ""1.000000""))
@@ -57,13 +69,13 @@ test_that(""text values in numeric column gives warning & NA"", {
 })
 
 test_that(""empty first column gives valid data.frame"", {
-  df <- read_excel(test_sheet(""missing-first-column.xlsx""), col_names=F)
+  df <- read_excel(test_sheet(""missing-first-column.xlsx""), col_names = FALSE)
   expect_equal(nrow(df), length(df[[1]]))
 })
 
 test_that(""empty named column gives NA column"", {
-  df1 <- read_excel(test_sheet(""empty-named-column.xlsx""), col_names=T)
-  df2 <- read_excel(test_sheet(""empty-named-column.xls""), col_names=T)
+  df1 <- read_excel(test_sheet(""empty-named-column.xlsx""), col_names = TRUE)
+  df2 <- read_excel(test_sheet(""empty-named-column.xls""), col_names = TRUE)
   expect_equal(ncol(df1), 4)
   expect_equal(names(df1)[2], ""y"")
   expect_equal(ncol(df2), 4)

---FILE: tests/testthat/test-return.R---
@@ -1,4 +1,4 @@
-context(""read_excel"")
+context(""Return type"")
 
 test_that(""return type for xlsx files"", {
   types <- read_excel(test_sheet(""missing-values.xlsx""))

---FILE: tests/testthat/test-skipping.R---
@@ -0,0 +1,52 @@
+context(""Skipping"")
+
+skipping <- test_sheet(""skipping.xlsx"")
+df <- tibble::tribble(~ var1, ~ var2,
+                         NA,     NA,
+                      ""v2,1"", ""v2,2"",
+                          NA,     NA,
+                      ""v4,1"", ""v4,2"")
+
+test_that(""leading blank rows are implicitly skipped"", {
+  out <- read_excel(skipping, sheet = ""two_blank_rows"")
+  expect_identical(df, out)
+})
+
+test_that(""leading blank rows can be explicitly skipped"", {
+  out <- read_excel(skipping, sheet = ""two_blank_rows"", skip = 2)
+  expect_identical(df, out)
+})
+
+test_that(""leading blank rows can be implicitly AND explicitly skipped"", {
+  out <- read_excel(skipping, sheet = ""two_blank_rows"", skip = 1)
+  expect_identical(df, out)
+})
+
+test_that(""failure to skip junk leads to garbage df but no error"", {
+  out <- read_excel(skipping, sheet = ""occupied_row_and_blank_row"")
+  expect_identical(out$`blah blah`, c(NA, ""var1"", NA, ""v2,1"", NA, ""v4,1""))
+  expect_identical(out[[2]], c(NA, ""var2"", NA, ""v2,2"", NA, ""v4,2""))
+
+  out <- read_excel(skipping, sheet = ""two_occupied_rows"")
+  expect_identical(out$`blah blah`, c(NA, ""var1"", NA, ""v2,1"", NA, ""v4,1""))
+  expect_identical(out[[2]], c(""yada yada"", ""var2"", NA, ""v2,2"", NA, ""v4,2""))
+
+  out <- read_excel(skipping, sheet = ""two_occupied_rows"", skip = 1)
+  expect_identical(out[[1]], c(""var1"", NA, ""v2,1"", NA, ""v4,1""))
+  expect_identical(out$`yada yada`, c(""var2"", NA, ""v2,2"", NA, ""v4,2""))
+})
+
+test_that(""explicit skip of leading junk, implicit skip of blank rows"", {
+  out <- read_excel(skipping, sheet = ""occupied_row_and_blank_row"", skip = 1)
+  expect_identical(df, out)
+})
+
+test_that(""explicit skip of leading junk and blank rows"", {
+  out <- read_excel(skipping, sheet = ""occupied_row_and_blank_row"", skip = 2)
+  expect_identical(df, out)
+})
+
+test_that(""explicit skip of leading junk"", {
+  out <- read_excel(skipping, sheet = ""two_occupied_rows"", skip = 2)
+  expect_identical(out, df)
+})",True,False,Documentation / Formatting,7
tidyverse,readxl,83af028bcc577d23b01c4a1f47d2dfc314497253,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-01-26T21:46:16Z,GitHub,noreply@github.com,2017-01-26T21:46:16Z,"Test directory hygiene (#239)

* Rename test file

* Fix test

* Move tests sheets into their own directory

* Add test_sheet() helper

* Put test helper in correct place

* Assume all suggested packages are installed for testing

* Note to self re: testthat::test_path()",DESCRIPTION;tests/testthat/context-compat.R;tests/testthat/helper.R;tests/testthat/sheets/blanks.xls;tests/testthat/sheets/blanks.xlsx;tests/testthat/sheets/dates-1900-loo.xlsx;tests/testthat/sheets/dates-1900.xls;tests/testthat/sheets/dates-1904.xls;tests/testthat/sheets/embedded-chartsheet.xlsx;tests/testthat/sheets/empty-named-column.xls;tests/testthat/sheets/empty-named-column.xlsx;tests/testthat/sheets/inlineStr.xlsx;tests/testthat/sheets/inlineStr2.xlsx;tests/testthat/sheets/iris-excel.xlsx;tests/testthat/sheets/iris-google-doc.xlsx;tests/testthat/sheets/missing-first-column.xlsx;tests/testthat/sheets/missing-values.xls;tests/testthat/sheets/missing-values.xlsx;tests/testthat/sheets/new_line_errors.xlsx;tests/testthat/sheets/richtext-coloured.xlsx;tests/testthat/sheets/sheet-xml-lookup.xlsx;tests/testthat/sheets/types.xlsx;tests/testthat/sheets/utf8-sheets.xls;tests/testthat/sheets/utf8-sheets.xlsx;tests/testthat/test-compatibility.R;tests/testthat/test-dates.R;tests/testthat/test-missing-values.R;tests/testthat/test-read-excel.R;tests/testthat/test-return.R;tests/testthat/test-richtext.R;tests/testthat/test-sheets.R,False,True,True,False,46,36,82,"---FILE: DESCRIPTION---
@@ -23,5 +23,6 @@ Imports:
     tibble
 Suggests:
     covr,
+    rprojroot (>= 1.1),
     testthat
 RoxygenNote: 5.0.1.9000

---FILE: tests/testthat/context-compat.R---
@@ -1,8 +0,0 @@
-context(""Compatability"")
-
-expect_that(""can read document from google doc"", {
-  iris_1 <- read_excel(""iris-excel.xlsx"")
-  iris_2 <- read_excel(""iris-google-doc.xlsx"")
-
-  expect_equal(iris_1, iris_2)
-})

---FILE: tests/testthat/helper.R---
@@ -0,0 +1,7 @@
+## usage:
+## test_sheet(""blanks.xls"")
+test_sheet <- function(fname) rprojroot::find_testthat_root_file(""sheets"", fname)
+
+## once https://github.com/hadley/testthat/commit/c83aba9 is on CRAN
+## can use testthat::test_path() for this, i.e.,
+#test_sheet <- function(fname) testthat::test_path(""sheets"", fname)

---FILE: tests/testthat/test-compatibility.R---
@@ -0,0 +1,8 @@
+context(""Compatability"")
+
+test_that(""can read document from google doc"", {
+  iris_1 <- read_excel(test_sheet(""iris-excel.xlsx""))
+  iris_2 <- read_excel(test_sheet(""iris-google-doc.xlsx""))
+
+  expect_equal(iris_1, iris_2)
+})

---FILE: tests/testthat/test-dates.R---
@@ -1,9 +1,9 @@
 context(""Dates"")
 
 test_that(""dates respect worksheet date setting"", {
-  d1900 <- read_xls(""dates-1900.xls"", col_names = FALSE)
-  d1904 <- read_xls(""dates-1904.xls"", col_names = FALSE)
-  d1900loo <- read_xlsx(""dates-1900-loo.xlsx"", col_names = FALSE)
+  d1900 <- read_xls(test_sheet(""dates-1900.xls""), col_names = FALSE)
+  d1904 <- read_xls(test_sheet(""dates-1904.xls""), col_names = FALSE)
+  d1900loo <- read_xlsx(test_sheet(""dates-1900-loo.xlsx""), col_names = FALSE)
 
   expect_equal(d1900, d1904)
   expect_equal(d1900, d1900loo)

---FILE: tests/testthat/test-missing-values.R---
@@ -1,67 +1,69 @@
 context(""Missing values"")
 
 test_that(""blanks read as missing [xlsx]"", {
-  blanks <- read_excel(""blanks.xlsx"")
+  blanks <- read_excel(test_sheet(""blanks.xlsx""))
   expect_equal(blanks$x, c(NA, 1))
   expect_equal(blanks$y, c(""a"", NA))
 })
 
 test_that(""blanks read as missing [xls]"", {
-  blanks <- read_excel(""blanks.xls"")
+  blanks <- read_excel(test_sheet(""blanks.xls""))
   expect_equal(blanks$x, c(NA, 1))
   expect_equal(blanks$y, c(""a"", NA))
 })
 
 test_that(""By default, NA read as text"", {
-  df <- read_xls(""missing-values.xls"")
+  df <- read_xls(test_sheet(""missing-values.xls""))
   expect_equal(df$x, c(""NA"", ""1.000000"", ""1.000000""))
 })
 
 test_that(""na arg maps strings to to NA [xls]"", {
-  df <- read_excel(""missing-values.xls"", na = ""NA"")
+  df <- read_excel(test_sheet(""missing-values.xls""), na = ""NA"")
   expect_equal(df$x, c(NA, 1, 1))
   expect_equal(df$y, c(NA, 1, 1)) # formula column
 })
 
 test_that(""na arg allows multiple strings [xls]"", {
-  df <- read_excel(""missing-values.xls"", na = c(""NA"", ""1""))
+  df <- read_excel(test_sheet(""missing-values.xls""), na = c(""NA"", ""1""))
   expect_true(all(is.na(df$x)))
   expect_true(all(is.na(df$y))) # formula column
 })
 
 test_that(""na arg maps strings to to NA [xlsx]"", {
-  df <- read_excel(""missing-values.xlsx"", na = ""NA"")
+  df <- read_excel(test_sheet(""missing-values.xlsx""), na = ""NA"")
   expect_equal(df$x, c(NA, 1, 1))
   expect_equal(df$y, c(NA, 1, 1)) # formula column
 })
 
 test_that(""na arg allows multiple strings [xlsx]"", {
-  df <- read_excel(""missing-values.xlsx"", na = c(""NA"", ""1""))
+  df <- read_excel(test_sheet(""missing-values.xlsx""), na = c(""NA"", ""1""))
   expect_true(all(is.na(df$x)))
   expect_true(all(is.na(df$y))) # formula column
 })
 
 test_that(""text values in numeric column gives warning & NA"", {
   expect_warning(
-    df <- read_excel(""missing-values.xls"", col_types = rep(""numeric"", 2)),
+    df <- read_excel(test_sheet(""missing-values.xls""),
+                     col_types = rep(""numeric"", 2)),
     ""Expecting numeric""
   )
   expect_equal(df$x, c(NA, 1, 1))
   expect_warning(
-    df <- read_excel(""missing-values.xlsx"", col_types = rep(""numeric"", 2)),
+    df <- read_excel(test_sheet(""missing-values.xlsx""),
+                     col_types = rep(""numeric"", 2)),
     ""expecting numeric""
   )
   expect_equal(df$x, c(NA, 1, 1))
 })
 
 test_that(""empty first column gives valid data.frame"", {
-  df <- read_excel(""missing-first-column.xlsx"", col_names=F)
+  df <- read_excel(test_sheet(""missing-first-column.xlsx""), col_names=F)
   expect_equal(nrow(df), length(df[[1]]))
 })
 
 test_that(""empty named column gives NA column"", {
-  df1 <- read_excel(""empty-named-column.xlsx"", col_names=T)
-  df2 <- read_excel(""empty-named-column.xls"", col_names=T)
+  df1 <- read_excel(test_sheet(""empty-named-column.xlsx""), col_names=T)
+  df2 <- read_excel(test_sheet(""empty-named-column.xls""), col_names=T)
   expect_equal(ncol(df1), 4)
   expect_equal(names(df1)[2], ""y"")
   expect_equal(ncol(df2), 4)

---FILE: tests/testthat/test-read-excel.R---
@@ -1,7 +1,7 @@
 context(""read_excel"")
 
 test_that(""types imputed & read correctly"", {
-  types <- read_excel(""types.xlsx"")
+  types <- read_excel(test_sheet(""types.xlsx""))
   expect_is(types$number, ""numeric"")
   expect_is(types$string, ""character"")
   expect_is(types$date, ""POSIXct"")
@@ -10,6 +10,6 @@ test_that(""types imputed & read correctly"", {
 test_that(""can read sheets with inlineStr"", {
   # Original source: http://our.componentone.com/wp-content/uploads/2011/12/TestExcel.xlsx
   # These appear to come from LibreOffice 4.2.7.2.
-  x <- read_excel(""inlineStr.xlsx"")
+  x <- read_excel(test_sheet(""inlineStr.xlsx""))
   expect_equal(x$ID, ""RQ11610"")
 })

---FILE: tests/testthat/test-return.R---
@@ -1,15 +1,15 @@
 context(""read_excel"")
 
 test_that(""return type for xlsx files"", {
-  types <- read_excel(""missing-values.xlsx"")
+  types <- read_excel(test_sheet(""missing-values.xlsx""))
   expect_is(types, ""tbl_df"")
   expect_is(types, ""tbl"")
   expect_is(types, ""data.frame"")
   expect_false(tibble::has_rownames(types))
 })
 
 test_that(""return type for xls files"", {
-  types <- read_excel(""missing-values.xls"")
+  types <- read_excel(test_sheet(""missing-values.xls""))
   expect_is(types, ""tbl_df"")
   expect_is(types, ""tbl"")
   expect_is(types, ""data.frame"")

---FILE: tests/testthat/test-richtext.R---
@@ -1,7 +1,7 @@
 context(""Richtext"")
 
 test_that(""rich text strings are handled in stringtable"", {
-  rt <- read_excel(""richtext-coloured.xlsx"", col_names = FALSE)
+  rt <- read_excel(test_sheet(""richtext-coloured.xlsx""), col_names = FALSE)
 
   for (i in 1:4)
     expect_equal(rt[[1,i]], ""abcd"")
@@ -14,14 +14,14 @@ test_that(""rich text strings are handled in stringtable"", {
 test_that(""rich text inside inlineStr"", {
   # Original source: http://our.componentone.com/wp-content/uploads/2011/12/TestExcel.xlsx
   # Modified to have Excel-safe mixed use of <r> and <t>
-  x <- read_excel(""inlineStr2.xlsx"")
+  x <- read_excel(test_sheet(""inlineStr2.xlsx""))
   expect_equal(x$ID, ""RQ11610"")
   expect_equal(names(x)[1], ""NNNN"")
   expect_equal(names(x)[2], ""BeforeHierarchy"")
 })
 
 test_that(""strings containing escaped hexcodes are read"", {
-  df <- read_excel(""new_line_errors.xlsx"")
+  df <- read_excel(test_sheet(""new_line_errors.xlsx""))
   expect_false(grepl(""_x000D_"", df[1,1]))
   expect_equal(substring(df[1,1],20,21), ""\u000d\r"")
   expect_equal(substring(df[2,1],11,19), ""\""_x000D_\"""")

---FILE: tests/testthat/test-sheets.R---
@@ -1,7 +1,7 @@
 context(""Sheets"")
 
 test_that(""excel_sheets returns utf-8 encoded text"", {
-  sheets <- excel_sheets(""utf8-sheets.xlsx"")
+  sheets <- excel_sheets(test_sheet(""utf8-sheets.xlsx""))
   expect_equal(Encoding(sheets), rep(""UTF-8"", 2))
   expect_equal(sheets, c(""\u00b5"", ""\u2202""))
 
@@ -12,31 +12,31 @@ test_that(""excel_sheets returns utf-8 encoded text"", {
 
 test_that(""informative error when requesting non-existent sheet by name"", {
   expect_error(
-    read_excel(""iris-excel.xlsx"", sheet = ""tulip""),
+    read_excel(test_sheet(""iris-excel.xlsx""), sheet = ""tulip""),
     ""Sheet 'tulip' not found""
   )
 })
 
 test_that(""informative error when requesting non-existent sheet by position"", {
   expect_error(
-    read_excel(""iris-excel.xlsx"", sheet = 200),
+    read_excel(test_sheet(""iris-excel.xlsx""), sheet = 200),
     ""Can't retrieve sheet in position""
   )
 })
 
 test_that(""invalid sheet values caught"", {
   expect_error(
-    read_excel(""iris-excel.xlsx"", sheet = 0),
+    read_excel(test_sheet(""iris-excel.xlsx""), sheet = 0),
     ""`sheet` must be positive""
   )
   expect_error(
-    read_excel(""iris-excel.xlsx"", sheet = rep(1L, 2)),
+    read_excel(test_sheet(""iris-excel.xlsx""), sheet = rep(1L, 2)),
     ""`sheet` must have length 1""
   )
 })
 
 test_that(""sheet data xml target is explicitly looked up (#104, #80)"", {
-  xlsx <- ""sheet-xml-lookup.xlsx""
+  xlsx <- test_sheet(""sheet-xml-lookup.xlsx"")
   countries <- excel_sheets(xlsx)
   ## what's important about this workbook?
   ## xml target for worksheet i is NOT sheeti.xml",True,False,Dependency / Package,6
tidyverse,readxl,1ed5c4e61b384e2f65dbb236649a955afb3992aa,Jim Hester,james.f.hester@gmail.com,2017-01-26T16:52:51Z,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-01-26T16:52:51Z,"Do not use variadic macros (#238)

They are a C99 extension which then requires =c++11 / c++0x causing
other issues (#176) as we do not actually use the CXX1X compiler.

The only use of fprintf in ole.c uses two additional arguments, so we
will just hard code that number directly.

Fixes #176",src/Makevars;src/cran.h,False,False,False,False,6,2,8,"---FILE: src/Makevars---
@@ -1,2 +1 @@
 PKG_CPPFLAGS=-Iunix -I.
-PKG_CXXFLAGS=$(CXX1XSTD)

---FILE: src/cran.h---
@@ -4,7 +4,12 @@
 /* Mask printf for CMD check */
 #include <Rinternals.h>
 #define printf Rprintf
-#define fprintf(err, ...) Rprintf(__VA_ARGS__)
+
+/* Rather than use variadic macros (which are a C99 feature) we are going to
+ * hard code a macro with only two additional arguments, as the only usage of
+ * fprintf uses two additional arguments.
+ */
+#define fprintf(err, msg, a1, a2) Rprintf(msg, a1, a2)
 #define exit assert
 #undef assert
 #define assert(X) if (X) {}",False,False,Environment / Configuration,3
tidyverse,readxl,15b71dc4aa1b066c9dc51105a05f8e84e5b2a8f4,Jirka Lewandowski,jirka.lewandowski@posteo.de,2017-01-24T23:25:30Z,Jirka Lewandowski,jirka.lewandowski@posteo.de,2017-01-24T23:25:30Z,"Also test for error reading extension-free xls with read_xlsx()

as suggested by https://github.com/hadley/readxl/pull/100#pullrequestreview-18249630",tests/testthat/test-read-excel.R,False,True,True,False,1,0,1,"---FILE: tests/testthat/test-read-excel.R---
@@ -24,6 +24,7 @@ test_that(""can read file without ending"", {
   file.copy(""iris-excel.xls"", ""iris-xls-no-ending"")
   on.exit(file.remove(""iris-xls-no-ending""))
   x <- read_xls(""iris-xls-no-ending"")
+  expect_error(read_xlsx(""iris-xls-no-ending""))
 
 
 })",True,False,File I/O and Export,3
tidyverse,readxl,55760cae7dfe9625cab3b5fcecc1893555cea574,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-01-24T19:11:35Z,GitHub,noreply@github.com,2017-01-24T19:11:35Z,"More robust logic for xlsx sheet lookup; fixes #104, relates to #80 (#233)

* Add test for sheet data xml lookup

* Initial implementation of more correct Sheet Referencing logic, by @jimhester

* Add test workbook with embedded chartsheet

* Sheet indexing for .xls is still 0-indexed

* Tests for bad worksheet requests; add a check on the R side

* Braces

* Make sure requested sheet is not past the end

* sheet_id_ is not actually used and is easily confused with id_

* Switch to std::map

* Cautionary note in benchmarks.cpp

* Indentation of long lines in tests

* Follow convention re: linking tests and issues

* Remove file that is not used in tests

* Missing &

* Comment to motivate SheetRelations class",R/read_excel.R;src/XlsxWorkBook.h;src/XlsxWorkSheet.h;src/benchmarks.cpp;tests/testthat/embedded-chartsheet.xlsx;tests/testthat/sheet-xml-lookup.xlsx;tests/testthat/test-sheets.R,False,True,True,False,169,39,208,"---FILE: R/read_excel.R---
@@ -38,7 +38,7 @@ read_excel <- function(path, sheet = 1, col_names = TRUE, col_types = NULL,
 read_xls <- function(path, sheet = 1, col_names = TRUE, col_types = NULL,
                      na = """", skip = 0) {
 
-  sheet <- standardise_sheet(sheet, xls_sheets(path))
+  sheet <- standardise_sheet(sheet, xls_sheets(path)) - 1L
 
   has_col_names <- isTRUE(col_names)
   if (has_col_names) {
@@ -89,12 +89,15 @@ standardise_sheet <- function(sheet, sheet_names) {
   }
 
   if (is.numeric(sheet)) {
-    floor(sheet) - 1L
+    if (sheet < 1) {
+      stop(""`sheet` must be positive"", call. = FALSE)
+    }
+    floor(sheet)
   } else if (is.character(sheet)) {
     if (!(sheet %in% sheet_names)) {
       stop(""Sheet '"", sheet, ""' not found"", call. = FALSE)
     }
-    match(sheet, sheet_names) - 1L
+    match(sheet, sheet_names)
   } else {
     stop(""`sheet` must be either an integer or a string."", call. = FALSE)
   }

---FILE: src/XlsxWorkBook.h---
@@ -9,56 +9,127 @@
 #include ""zip.h""
 
 class XlsxWorkBook {
+
+  // holds objects related to sheet position, name, and xml target file
+  class SheetRelations {
+    int n_;
+    Rcpp::CharacterVector names_;
+    Rcpp::CharacterVector id_;
+    std::map<std::string, std::string> target_;
+
+    void parse_workbook(const std::string& path) {
+      std::string workbookXml = zip_buffer(path, ""xl/workbook.xml"");
+      rapidxml::xml_document<> workbook;
+      workbook.parse<0>(&workbookXml[0]);
+
+      rapidxml::xml_node<>* root = workbook.first_node(""workbook"");
+      if (root == NULL) {
+        return;
+      }
+
+      rapidxml::xml_node<>* sheets = root->first_node(""sheets"");
+      if (sheets == NULL) {
+        return;
+      }
+
+      int i = 0;
+      for (rapidxml::xml_node<>* sheet = sheets->first_node();
+           sheet; sheet = sheet->next_sibling()) {
+        if (i >= n_) {
+          n_ *= 2;
+          names_ = Rf_lengthgets(names_, n_);
+          id_ = Rf_lengthgets(id_, n_);
+        }
+        rapidxml::xml_attribute<>* name = sheet->first_attribute(""name"");
+        names_[i] = (name != NULL) ? Rf_mkCharCE(name->value(), CE_UTF8) : NA_STRING;
+
+        rapidxml::xml_attribute<>* id = sheet->first_attribute(""r:id"");
+        id_[i] = (id != NULL) ? Rf_mkCharCE(id->value(), CE_UTF8) : NA_STRING;
+
+        i++;
+      }
+
+      if (i != n_) {
+        names_ = Rf_lengthgets(names_, i);
+        id_ = Rf_lengthgets(id_, i);
+        n_ = i;
+      }
+    }
+
+    void parse_workbook_rels(const std::string& path) {
+      std::string rels_xml_file = zip_buffer(path, ""xl/_rels/workbook.xml.rels"");
+      rapidxml::xml_document<> rels_xml;
+      rels_xml.parse<0>(&rels_xml_file[0]);
+
+      rapidxml::xml_node<>* relationships = rels_xml.first_node(""Relationships"");
+      if (relationships == NULL) {
+        return;
+      }
+
+      for (rapidxml::xml_node<>* relationship = relationships->first_node();
+           relationship; relationship = relationship->next_sibling()) {
+        rapidxml::xml_attribute<>* id = relationship->first_attribute(""Id"");
+        rapidxml::xml_attribute<>* target = relationship->first_attribute(""Target"");
+        if (id != NULL && target != NULL) {
+          target_[id->value()] = target->value();
+        }
+      }
+    }
+
+  public:
+    SheetRelations(const std::string& path) :
+    n_(100),
+    names_(n_),
+    id_(n_)
+    {
+      parse_workbook(path);
+      parse_workbook_rels(path);
+    }
+    Rcpp::CharacterVector names() {
+      return names_;
+    }
+    int n_sheets() {
+      return n_;
+    }
+
+    std::string target(int sheet_i) {
+      std::string id = Rcpp::as<std::string>(id_[sheet_i - 1]);
+      std::map<std::string, std::string>::const_iterator it = target_.find(id);
+      if (it == target_.end()) {
+        Rcpp::stop(""`%s` not found"", id);
+      }
+      return it->second;
+    }
+  };
+
   std::string path_;
   std::set<int> dateStyles_;
   std::vector<std::string> stringTable_;
   double offset_;
+  SheetRelations rel_;
 
 public:
 
-  XlsxWorkBook(const std::string& path): path_(path) {
+  XlsxWorkBook(const std::string& path):
+  path_(path),
+  rel_(path)
+  {
     offset_ = dateOffset(is1904());
     cacheStringTable();
     cacheDateStyles();
   }
 
   Rcpp::CharacterVector sheets() {
-    std::string workbookXml = zip_buffer(path_, ""xl/workbook.xml"");
-    rapidxml::xml_document<> workbook;
-    workbook.parse<0>(&workbookXml[0]);
-
-    int n = 100;
-    Rcpp::CharacterVector sheetNames(n);
-
-    rapidxml::xml_node<>* root = workbook.first_node(""workbook"");
-    if (root == NULL) {
-      return sheetNames;
-    }
-
-    rapidxml::xml_node<>* sheets = root->first_node(""sheets"");
-    if (sheets == NULL) {
-      return sheetNames;
-    }
-
-    int i = 0;
-    for (rapidxml::xml_node<>* sheet = sheets->first_node();
-         sheet; sheet = sheet->next_sibling()) {
-      if (i >= n) {
-        n *= 2;
-        sheetNames = Rf_lengthgets(sheetNames, n);
-      }
-      rapidxml::xml_attribute<>* name = sheet->first_attribute(""name"");
-      sheetNames[i] = (name != NULL) ? Rf_mkCharCE(name->value(), CE_UTF8) : NA_STRING;
-      i++;
-    }
-
-    if (i != n) {
-      sheetNames = Rf_lengthgets(sheetNames, i);
-    }
+      return rel_.names();
+  }
 
-    return sheetNames;
+  int n_sheets() {
+    return rel_.n_sheets();
   }
 
+  std::string sheetPath(int sheet_i) {
+    return ""xl/"" + rel_.target(sheet_i);
+  }
 
   const std::string& path() {
     return path_;

---FILE: src/XlsxWorkSheet.h---
@@ -24,8 +24,12 @@ class XlsxWorkSheet {
 
 public:
 
-  XlsxWorkSheet(XlsxWorkBook wb, int i): wb_(wb) {
-    std::string sheetPath = tfm::format(""xl/worksheets/sheet%i.xml"", i + 1);
+  XlsxWorkSheet(XlsxWorkBook wb, int sheet_i): wb_(wb) {
+    if (sheet_i > wb.n_sheets()) {
+      Rcpp::stop(""Can't retrieve sheet in position %d, only %d sheets found."",
+                 sheet_i,  wb.n_sheets());
+    }
+    std::string sheetPath = wb.sheetPath(sheet_i);
     sheet_ = zip_buffer(wb.path(), sheetPath);
     sheetXml_.parse<0>(&sheet_[0]);
 

---FILE: src/benchmarks.cpp---
@@ -14,6 +14,8 @@ void parseXml(std::string base, std::string internal) {
 
 // [[Rcpp::export]]
 int countRows(std::string base, int sheet) {
+  // FYI: sheet lookup logic has changed in main package
+  // this is not generally correct
   std::string sheetPath = tfm::format(""xl/worksheets/sheet%i.xml"", sheet + 1);
 
   std::string file = zip_buffer(base, sheetPath);

---FILE: tests/testthat/test-sheets.R---
@@ -9,3 +9,53 @@ test_that(""excel_sheets returns utf-8 encoded text"", {
   # maybe libxls isn't reencording? It's a bit suspicious that mu is
   # \u00b5 and libxls is giving \xb5
 })
+
+test_that(""informative error when requesting non-existent sheet by name"", {
+  expect_error(
+    read_excel(""iris-excel.xlsx"", sheet = ""tulip""),
+    ""Sheet 'tulip' not found""
+  )
+})
+
+test_that(""informative error when requesting non-existent sheet by position"", {
+  expect_error(
+    read_excel(""iris-excel.xlsx"", sheet = 200),
+    ""Can't retrieve sheet in position""
+  )
+})
+
+test_that(""invalid sheet values caught"", {
+  expect_error(
+    read_excel(""iris-excel.xlsx"", sheet = 0),
+    ""`sheet` must be positive""
+  )
+  expect_error(
+    read_excel(""iris-excel.xlsx"", sheet = rep(1L, 2)),
+    ""`sheet` must have length 1""
+  )
+})
+
+test_that(""sheet data xml target is explicitly looked up (#104, #80)"", {
+  xlsx <- ""sheet-xml-lookup.xlsx""
+  countries <- excel_sheets(xlsx)
+  ## what's important about this workbook?
+  ## xml target for worksheet i is NOT sheeti.xml
+  ##       name    Id                   Target
+  ##      <chr> <chr>                    <chr>
+  ## 1   Africa  rId3 xl/worksheets/sheet4.xml
+  ## 2 Americas  rId4 xl/worksheets/sheet3.xml
+  ## 3     Asia  rId5 xl/worksheets/sheet5.xml
+  ## 4   Europe  rId6 xl/worksheets/sheet1.xml
+  ## 5  Oceania  rId7 xl/worksheets/sheet2.xml
+  ## tests that we find xml target like so: (name ->) i -> Id -> Target
+  ## embedded-chartsheet.xlsx has an embedded chartsheet but I see no
+  ## current reason to explicitly test (#116, #200)
+  for (cty in countries) {
+    df <- read_excel(xlsx, sheet = cty)
+    expect_identical(df$continent[1], cty)
+  }
+  for (i in seq_along(countries)) {
+    df <- read_excel(xlsx, sheet = i)
+    expect_identical(df$continent[1], countries[i])
+  }
+})",True,False,Implementation / Logic,6
tidyverse,readxl,6fa362a74392dd32a4abae6abb2ff5de1d815871,Rohan Shah,rohan-shah@users.noreply.github.com,2017-01-24T04:19:00Z,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-01-24T04:19:00Z,"Fixed invalid use of va_list (#195)

* Fixed invalid use of va_list

* Fix use of va_list again.",src/xlstool.c,False,False,False,False,5,3,8,"---FILE: src/xlstool.c---
@@ -167,16 +167,18 @@ static int asprintf(char **ret, const char *format, ...)
 static int asprintf(char **ret, const char *format, ...)
 {
 	int i;
-    char *str;
+	char *str;
 
 	va_list ap;
 
 	va_start(ap, format); 
-
 	i = vsnprintf(NULL, 0, format, ap) + 1;
+	va_end(ap);
+
 	str = (char *)malloc(i);
-	i = vsnprintf(str, i, format, ap);
 
+	va_start(ap, format);
+	i = vsnprintf(str, i, format, ap);
 	va_end(ap);
 
 	*ret = str;",False,False,Implementation / Logic,3
tidyverse,readxl,ad1a2be2b7a363fbcfed204099af726cfa8d80bb,Pedram Navid,pedram.navid@gmail.com,2017-01-19T03:58:11Z,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-01-19T03:58:11Z,"Update xls.c (#188); fixes #82, suppresses printed output when xls has named range",src/xls.c,False,False,False,False,5,3,8,"---FILE: src/xls.c---
@@ -914,9 +914,11 @@ void xls_parseWorkBook(xlsWorkBook* pWB)
 			break;
 		
 		case XLS_RECORD_DEFINEDNAME:
-			printf(""DEFINEDNAME: "");
-			for(int i=0; i<bof1.size; ++i) printf(""%2.2x "", buf[i]);
-			printf(""\n"");
+			if(xls_debug) {
+				printf(""DEFINEDNAME: "");
+				for(int i=0; i<bof1.size; ++i) printf(""%2.2x "", buf[i]);
+				printf(""\n"");
+			}
 			break;
 			
 #ifdef DEBUG_DRAWINGS",False,False,Dependency / Package,1
tidyverse,readxl,370ad6be67868500ed4df1b433352c987485ce89,Sergio Oller,sergioller@gmail.com,2017-01-18T18:21:28Z,Sergio Oller,soller@ibecbarcelona.eu,2017-01-18T18:21:28Z,Default col_names on xlsx now start with X1. Fixes #98,src/XlsxWorkSheet.cpp,False,False,False,False,1,1,2,"---FILE: src/XlsxWorkSheet.cpp---
@@ -63,7 +63,7 @@ List read_xlsx_(std::string path, int sheet, RObject col_names,
       int p = ws.ncol();
       colNames = CharacterVector(p);
       for (int j = 0; j < p; ++j) {
-        colNames[j] = tfm::format(""X%i"", j);
+        colNames[j] = tfm::format(""X%i"", j+1);
       }
     }
     break;",False,False,Rendering / Conversion,0
tidyverse,readxl,3ecca3c51b9ad72594cbdce60c5da5ba3c38ac9b,jennybc,jenny@stat.ubc.ca,2017-01-17T18:24:23Z,jennybc,jenny@stat.ubc.ca,2017-01-17T19:20:17Z,"Don't access value of nonexistent numFmtId attribute; fixes #191

Examples provided privately via email. ""crashing"" is a workbook written by <http://epplus.codeplex.com/>. ""working"" is same workbook, opened and re-saved from Excel.

Relevant bits of xl/styles.xml:

crashing:

<styleSheet xmlns=""http://schemas.openxmlformats.org/spreadsheetml/2006/main"">
<numFmts count=""0""/>
<fonts count=""2"">...</fonts>
<fills count=""2"">...</fills>
<borders count=""1"">...</borders>
<cellStyleXfs count=""1"">
<xf fontId=""0""/>
</cellStyleXfs>
<cellXfs count=""2"">
<xf fontId=""0"" applyFont=""1"" xfId=""0""/>
<xf fontId=""1"" applyFont=""1"" xfId=""0""/>
</cellXfs>
<cellStyles count=""1"">...</cellStyles>
<dxfs count=""0""/>
</styleSheet>

working:
<styleSheet xmlns=""http://schemas.openxmlformats.org/spreadsheetml/2006/main"" xmlns:mc=""http://schemas.openxmlformats.org/markup-compatibility/2006"" xmlns:x14ac=""http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac"" mc:Ignorable=""x14ac"">
<fonts count=""2"">...</fonts>
<fills count=""2"">...</fills>
<borders count=""1"">...</borders>
<cellStyleXfs count=""1"">
<xf numFmtId=""0"" fontId=""0"" fillId=""0"" borderId=""0""/>
</cellStyleXfs>
<cellXfs count=""2"">
<xf numFmtId=""0"" fontId=""0"" fillId=""0"" borderId=""0"" xfId=""0"" applyFont=""1""/>
<xf numFmtId=""0"" fontId=""1"" fillId=""0"" borderId=""0"" xfId=""0"" applyFont=""1""/>
</cellXfs>
<cellStyles count=""1"">...</cellStyles>
<dxfs count=""0""/>
<tableStyles count=""0"" defaultTableStyle=""TableStyleMedium2"" defaultPivotStyle=""PivotStyleLight16""/>
<extLst>...</extLst>
</styleSheet>",src/XlsxWorkBook.h,False,False,False,False,6,4,10,"---FILE: src/XlsxWorkBook.h---
@@ -141,10 +141,12 @@ class XlsxWorkBook {
     int i = 0;
     for (rapidxml::xml_node<>* cellXf = cellXfs->first_node();
          cellXf; cellXf = cellXf->next_sibling()) {
-      int formatId = atoi(cellXf->first_attribute(""numFmtId"")->value());
-      if (isDateTime(formatId, customDateFormats))
-        dateStyles_.insert(i);
-      ++i;
+      if (cellXf->first_attribute(""numFmtId"") != NULL) {
+        int formatId = atoi(cellXf->first_attribute(""numFmtId"")->value());
+        if (isDateTime(formatId, customDateFormats))
+          dateStyles_.insert(i);
+        ++i;
+      }
     }
   }
 ",False,False,Implementation / Logic,3
tidyverse,readxl,d01e5d6991d6b303ced02cef621ea9a2dd1c12d6,Jennifer (Jenny) Bryan,jenny.f.bryan@gmail.com,2017-01-17T17:00:38Z,GitHub,noreply@github.com,2017-01-17T17:00:38Z,Fix appveyor links,README.md,False,False,False,False,1,1,2,"---FILE: README.md---
@@ -1,6 +1,6 @@
 # readxl
 
-[![Travis-CI Build Status](https://travis-ci.org/hadley/readxl.svg?branch=master)](https://travis-ci.org/hadley/readxl) [![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/jennybc/readxl?branch=master&svg=true)](https://ci.appveyor.com/project/jennybc/readxl)
+[![Travis-CI Build Status](https://travis-ci.org/hadley/readxl.svg?branch=master)](https://travis-ci.org/hadley/readxl) [![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/hadley/readxl?branch=master&svg=true)](https://ci.appveyor.com/project/hadley/readxl)
 
 The readxl package makes it easy to get data out of Excel and into R. Compared to many of the existing packages (e.g. gdata, xlsx, xlsReadWrite) readxl has no external dependencies so it's easy to install and use on all operating systems.  It is designed to work with _tabular_ data stored in a single sheet.
 ",False,False,Documentation / Formatting,6
tidyverse,readxl,a02138fb304823f2268043c07617f69fb6b35f30,Kirill Müller,krlmlr@users.noreply.github.com,2017-01-03T20:10:38Z,Hadley Wickham,h.wickham@gmail.com,2017-01-03T20:10:38Z,"Import tibble (#175)

* import tibble

* adapt tests

* add explicit test for return type

* call tibble::as_data_frame()

* NEWS

Fixes #213",DESCRIPTION;NAMESPACE;NEWS.md;R/read_excel.R;src/CellType.h;src/XlsWorkSheet.h;src/XlsxWorkSheet.h;tests/testthat/test-missing-values.R;tests/testthat/test-return.R;tests/testthat/test-richtext.R,False,True,True,False,43,17,60,"---FILE: DESCRIPTION---
@@ -19,7 +19,8 @@ License: GPL-3 + file LICENSE
 LazyData: true
 LinkingTo: Rcpp
 Imports:
-    Rcpp (>= 0.11.5)
+    Rcpp (>= 0.11.5),
+    tibble
 Suggests:
     testthat
 RoxygenNote: 5.0.1

---FILE: NAMESPACE---
@@ -5,4 +5,5 @@ S3method(print,xlsx)
 export(excel_sheets)
 export(read_excel)
 importFrom(Rcpp,sourceCpp)
+importFrom(tibble,as_data_frame)
 useDynLib(readxl)

---FILE: NEWS.md---
@@ -2,5 +2,7 @@
 
 # readxl 0.1.1
 
+* Import the `tibble` package (#175, @krlmlr).
+
 * Add support for correctly reading strings in .xlsx files containing escaped 
   unicode characters (e.g. `_x005F_`) (#51, thanks to @jmarshallnz).

---FILE: R/read_excel.R---
@@ -1,5 +1,6 @@
 #' @useDynLib readxl
 #' @importFrom Rcpp sourceCpp
+#' @importFrom tibble as_data_frame
 NULL
 
 #' Read xls and xlsx files.
@@ -51,17 +52,23 @@ read_xls <- function(path, sheet = 1, col_names = TRUE, col_types = NULL,
     col_types <- xls_col_types(path, sheet, na = na, nskip = skip, has_col_names = has_col_names)
   }
 
-  xls_cols(path, sheet, col_names = col_names, col_types = col_types, na = na,
-    nskip = skip + has_col_names)
+  as_data_frame(
+    xls_cols(path, sheet, col_names = col_names, col_types = col_types, na = na,
+             nskip = skip + has_col_names),
+    validate = FALSE
+  )
 }
 
 read_xlsx <- function(path, sheet = 1L, col_names = TRUE, col_types = NULL,
                       na = """", skip = 0) {
   path <- check_file(path)
   sheet <- standardise_sheet(sheet, xlsx_sheets(path))
 
-  read_xlsx_(path, sheet, col_names = col_names, col_types = col_types, na = na,
-             nskip = skip)
+  as_data_frame(
+    read_xlsx_(path, sheet, col_names = col_names, col_types = col_types, na = na,
+               nskip = skip),
+    validate = FALSE
+  )
 }
 
 # Helper functions -------------------------------------------------------------

---FILE: src/CellType.h---
@@ -151,9 +151,10 @@ inline Rcpp::RObject makeCol(CellType type, int n) {
   return R_NilValue;
 }
 
-// Make data frame from list of columns, dropping blanks
-inline Rcpp::List colDataframe(Rcpp::List cols, Rcpp::CharacterVector names,
-                        std::vector<CellType> types) {
+// Drop blanks from list of columns
+inline Rcpp::List removeBlankColumns(Rcpp::List cols,
+                                     Rcpp::CharacterVector names,
+                                     std::vector<CellType> types) {
   int p = cols.size();
 
   int p_out = 0;
@@ -175,9 +176,6 @@ inline Rcpp::List colDataframe(Rcpp::List cols, Rcpp::CharacterVector names,
   }
 
   // Turn list into a data frame
-  int n = (p_out == 0) ? 0 : Rf_length(out[0]);
-  out.attr(""class"") = Rcpp::CharacterVector::create(""tbl_df"", ""tbl"", ""data.frame"");
-  out.attr(""row.names"") = Rcpp::IntegerVector::create(NA_INTEGER, -n);
   out.attr(""names"") = names_out;
 
   return out;

---FILE: src/XlsWorkSheet.h---
@@ -162,7 +162,7 @@ class XlsWorkSheet {
       }
     }
 
-    return colDataframe(cols, names, types);
+    return removeBlankColumns(cols, names, types);
   }
 };
 

---FILE: src/XlsxWorkSheet.h---
@@ -191,7 +191,7 @@ class XlsxWorkSheet {
       ++i;
     }
 
-    return colDataframe(cols, names, types);
+    return removeBlankColumns(cols, names, types);
   }
 
 

---FILE: tests/testthat/test-missing-values.R---
@@ -44,7 +44,7 @@ test_that(""text values in numeric column gives warning & NA"", {
 
 test_that(""empty first column gives valid data.frame"", {
   df <- read_excel(""missing-first-column.xlsx"", col_names=F)
-  expect_equal(nrow(df), length(df[,1]))
+  expect_equal(nrow(df), length(df[[1]]))
 })
 
 test_that(""empty named column gives NA column"", {

---FILE: tests/testthat/test-return.R---
@@ -0,0 +1,17 @@
+context(""read_excel"")
+
+test_that(""return type for xlsx files"", {
+  types <- read_excel(""missing-values.xlsx"")
+  expect_is(types, ""tbl_df"")
+  expect_is(types, ""tbl"")
+  expect_is(types, ""data.frame"")
+  expect_false(tibble::has_rownames(types))
+})
+
+test_that(""return type for xls files"", {
+  types <- read_excel(""missing-values.xls"")
+  expect_is(types, ""tbl_df"")
+  expect_is(types, ""tbl"")
+  expect_is(types, ""data.frame"")
+  expect_false(tibble::has_rownames(types))
+})

---FILE: tests/testthat/test-richtext.R---
@@ -4,11 +4,11 @@ test_that(""rich text strings are handled in stringtable"", {
   rt <- read_excel(""richtext-coloured.xlsx"", col_names = FALSE)
 
   for (i in 1:4)
-    expect_equal(rt[1,i], ""abcd"")
+    expect_equal(rt[[1,i]], ""abcd"")
 
-  expect_equal(rt[2,1], ""tvalrval1rval2"")
+  expect_equal(rt[[2,1]], ""tvalrval1rval2"")
   for (i in 2:4)
-    expect_equal(rt[2,i], ""rval1rval2"")
+    expect_equal(rt[[2,i]], ""rval1rval2"")
 })
 
 test_that(""rich text inside inlineStr"", {",True,False,Documentation / Formatting,7
tidyverse,readxl,244fd3633f35d185d1c9ffea17db8a309bd92cd1,hadley,h.wickham@gmail.com,2015-04-22T20:05:28Z,hadley,h.wickham@gmail.com,2015-04-22T20:05:28Z,Encode headers at UTF-8. Fixes #88,src/XlsWorkSheet.h,False,False,False,False,1,1,2,"---FILE: src/XlsWorkSheet.h---
@@ -58,7 +58,7 @@ class XlsWorkSheet {
       if (cell.str == NULL) {
         out[j] = NA_STRING;
       } else {
-        out[j] = std::string((char*) cell.str);
+        out[j] = Rf_mkCharCE((char*) cell.str, CE_UTF8);
       }
     }
 ",False,False,Implementation / Logic,3
tidyverse,readxl,c58957b4128c99da4a155a69b4a0beacffe08858,Jonathan Marshall,jmarshall@never.you.mind,2015-04-14T22:53:25Z,Jonathan Marshall,jmarshall@never.you.mind,2015-04-14T22:53:28Z,fixes .xlsx files that contain unicode character expressions such as _x000D_. Closes #51,src/XlsxString.h,False,False,False,False,26,2,28,"---FILE: src/XlsxString.h---
@@ -3,6 +3,30 @@
 
 #include <Rcpp.h>
 #include ""rapidxml.h""
+#include <R_ext/GraphicsDevice.h> // Rf_ucstoutf8 is exported in R_ext/GraphicsDevice.h
+
+// unescape an ST_Xstring. See 22.9.2.19 [p3786]
+inline std::string unescape(const std::string &s) {
+  std::string out;
+  out.reserve(s.size());
+
+  for (size_t i = 0; i < s.size(); i++) {
+    if (i+6 < s.size() && s[i] == '_' && s[i+1] == 'x'
+     && isxdigit(s[i+2]) && isxdigit(s[i+3])
+     && isxdigit(s[i+4]) && isxdigit(s[i+5]) && s[i+6] == '_') {
+      // extract character
+      unsigned int ch = strtoul(&s[i+2], NULL, 16);
+      char utf8[16]; // 16 from definition of Rf_ucstoutf8
+      Rf_ucstoutf8(utf8, ch);
+      out += utf8;
+      i += 6; // skip to the final '_'
+    } else {
+      out.push_back(s[i]);
+    }
+  }
+
+  return out;
+}
 
 // Parser for <si> and <is> inlineStr tags CT_Rst [p3893]
 // returns true if a string is found, false if missing.
@@ -30,7 +54,7 @@ inline bool parseString(const rapidxml::xml_node<>* string, std::string *out) {
     //
     // We read the <t> tag, if present, first, then concatenate any <r> tags.
     // All Excel 2010 sheets will read correctly under this regime.
-    *out = std::string(t->value());
+    *out = unescape(t->value());
     found = true;
   }
   // iterate over all r elements
@@ -40,7 +64,7 @@ inline bool parseString(const rapidxml::xml_node<>* string, std::string *out) {
     // but MacOSX preview just ignores chunks with no t element present
     const rapidxml::xml_node<>* t = r->first_node(""t"");
     if (t != NULL) {
-      *out += t->value();
+      *out += unescape(t->value());
       found = true;
     }
   }",False,False,Implementation / Logic,3
tidyverse,readxl,5a5ababc3a11eb434ab105c0cde17bfbdcd2e585,hadley,h.wickham@gmail.com,2015-04-10T19:10:57Z,hadley,h.wickham@gmail.com,2015-04-10T19:10:57Z,More build fixes,src/ole.c;src/unix/config.h;src/xls.c,False,False,False,False,9,13,22,"---FILE: src/ole.c---
@@ -82,8 +82,6 @@ void ole2_bufread(OLE2Stream* olest)
 			olest->cfat++;
 		} else {
 
-			assert(olest->fatpos >= 0);
-
 			//printf(""fatpos: %d max=%u\n"",olest->fatpos, (olest->ole->cfat*olest->ole->lsector)/4);
 			if(olest->fatpos > (olest->ole->cfat*olest->ole->lsector)/4) exit(-1);
 

---FILE: src/unix/config.h---
@@ -2,7 +2,7 @@
 /* config.h.in.  Generated from configure.in by autoheader.  */
 
 /* Define to 1 if you have the `asprintf' function. */
-#ifdef __GNUC__
+#if defined(_GNU_SOURCE) || defined(_DEFAULT_SOURCE) || defined(__APPLE__)
 #define HAVE_ASPRINTF 1
 #endif
 

---FILE: src/xls.c---
@@ -50,7 +50,7 @@
 #define min(a,b) ((a) < (b) ? (a) : (b))
 #endif
 
-#define DEBUG_DRAWINGS
+// #define DEBUG_DRAWINGS
 int xls_debug = 0;
 
 static double NumFromRk(DWORD_UA drk);
@@ -121,8 +121,8 @@ struct drawHeader {
 static char *formData;
 static char *formFunc;
 static struct drawHeader drawProc(uint8_t *buf, uint32_t maxLen, uint32_t *off, int level);
-static void dumpRec(char *comment, struct drawHeader *h, int len, uint8_t *buf);
-static int finder(uint8_t *buf, uint32_t len, uint16_t pattern);
+// static void dumpRec(char *comment, struct drawHeader *h, int len, uint8_t *buf);
+// static int finder(uint8_t *buf, uint32_t len, uint16_t pattern);
 static uint32_t sheetOffset;
 #endif
 
@@ -736,7 +736,7 @@ void xls_parseWorkBook(xlsWorkBook* pWB)
     {
 		if(xls_debug > 10) {
 			printf(""READ WORKBOOK filePos=%ld\n"",  (long)pWB->filepos);
-			printf(""  OLE: start=%d pos=%zd size=%zd fatPos=%zu\n"", pWB->olestr->start, pWB->olestr->pos, pWB->olestr->size, pWB->olestr->fatpos); 
+			printf(""  OLE: start=%d pos=%zd size=%zd fatPos=%zu\n"", pWB->olestr->start, pWB->olestr->pos, pWB->olestr->size, pWB->olestr->fatpos);
 		}
 
         ole2_read(&bof1, 1, 4, pWB->olestr);
@@ -1055,7 +1055,6 @@ void xls_parseWorkSheet(xlsWorkSheet* pWS)
     BOF tmp;
     BYTE* buf;
 	long offset = pWS->filepos;
-	int continueRec = 0;
 
 	struct st_cell_data *cell;
 	xlsWorkBook *pWB = pWS->workbook;
@@ -1190,7 +1189,7 @@ void xls_parseWorkSheet(xlsWorkSheet* pWS)
 			sheetOffset = 100;
 			unsigned int total = tmp.size;
 			unsigned int off = 0;
-			
+
 			while(off < total) {
 				struct drawHeader fooper  = drawProc(buf, total, &off, 0);
 				(void)fooper;
@@ -1201,9 +1200,9 @@ void xls_parseWorkSheet(xlsWorkSheet* pWS)
 			if(formFunc) printf(""%s\n"", formFunc);
 			free(formData), formData = NULL;
 			free(formFunc), formFunc = NULL;
-			
+
 		}	break;
-		
+
 		case XLS_RECORD_TXO:
 		{
 			struct {
@@ -1341,7 +1340,6 @@ void xls_parseWorkSheet(xlsWorkSheet* pWS)
 #endif
 
         default:
-		  printBOF:
 			if(xls_debug)
 			{
 				//xls_showBOF(&tmp);
@@ -2081,6 +2079,7 @@ static struct drawHeader drawProc(uint8_t *buf, uint32_t maxLen, uint32_t *off_p
 	return head;
 }
 
+#if 0
 static void dumpData(char *data);
 static void dumpFunc(char *func);
 
@@ -2146,7 +2145,6 @@ static void dumpFunc(char *func)
 	free(oldStr);
 }
 
-#if 0
 static int finder(uint8_t *buf, uint32_t len, uint16_t pattern)
 {
 	int ret = 0;",False,False,Implementation / Logic,3
tidyverse,readxl,6f8304c179b656fdc8330729cf52a0a51521ee63,hadley,h.wickham@gmail.com,2015-04-10T15:29:42Z,hadley,h.wickham@gmail.com,2015-04-10T15:29:42Z,Attempted fixes for CRAN issues,src/libxls/ole.h;src/libxls/xlsstruct.h;src/unix/config.h;src/xls.c;src/xlstool.c,False,False,False,False,16,14,30,"---FILE: src/libxls/ole.h---
@@ -37,7 +37,7 @@
 
 #include ""libxls/xlstypes.h""
 
-#ifdef AIX
+#if defined(_AIX) || defined(__sun)
 #pragma pack(1)
 #else
 #pragma pack(push, 1)
@@ -129,7 +129,7 @@ typedef struct OLE2Stream
 }
 OLE2Stream;
 
-#ifdef AIX
+#if defined(_AIX) || defined(__sun)
 #pragma pack(1)
 #else
 #pragma pack(push, 1)

---FILE: src/libxls/xlsstruct.h---
@@ -35,7 +35,7 @@
 
 #include ""libxls/ole.h""
 
-#ifdef AIX
+#if defined(_AIX) || defined(__sun)
 #pragma pack(1)
 #else
 #pragma pack(push, 1)
@@ -79,7 +79,7 @@ typedef struct BOUNDSHEET
     DWORD	filepos;
     BYTE	type;
     BYTE	visible;
-    BYTE	name[];
+    BYTE	name[1];
 }
 BOUNDSHEET;
 
@@ -150,7 +150,7 @@ typedef struct MULRK
 	struct {
 		WORD	xf;
 		DWORD_UA value;
-	}		rk[];
+	}		rk[1];
 	//WORD	last_col;
 }
 MULRK;
@@ -159,7 +159,7 @@ typedef struct MULBLANK
 {
     WORD	row;
     WORD	col;
-    WORD	xf[];
+    WORD	xf[1];
 	//WORD	last_col;
 }
 MULBLANK;
@@ -265,7 +265,7 @@ FONT;
 typedef struct FORMAT
 {
     WORD	index;
-    BYTE	value[0];
+    BYTE	value[1];
 }
 FORMAT;
 

---FILE: src/unix/config.h---
@@ -2,7 +2,9 @@
 /* config.h.in.  Generated from configure.in by autoheader.  */
 
 /* Define to 1 if you have the `asprintf' function. */
-/* #undef HAVE_ASPRINTF */
+#ifdef __GNUC__
+#define HAVE_ASPRINTF 1
+#endif
 
 /* Define to 1 if you have the <dlfcn.h> header file. */
 #define HAVE_DLFCN_H 1

---FILE: src/xls.c---
@@ -73,7 +73,7 @@ extern void xls_formatColumn(xlsWorkSheet* pWS);
 extern void xls_parseWorkSheet(xlsWorkSheet* pWS);
 extern void xls_dumpSummary(char *buf,int isSummary,xlsSummaryInfo	*pSI);
 
-#ifdef AIX
+#if defined(_AIX) || defined(__sun)
 #pragma pack(1)
 #else
 #pragma pack(push, 1)
@@ -90,7 +90,7 @@ typedef struct {
 	uint32_t		os;
 	uint32_t		format[4];
 	uint32_t		count;
-	sectionList		secList[0];
+	sectionList		secList[1];
 } header;
 
 typedef struct {
@@ -101,12 +101,12 @@ typedef struct {
 typedef struct {
 	uint32_t		length;
 	uint32_t		numProperties;
-	propertyList	properties[0];
+	propertyList	properties[1];
 } sectionHeader;
 
 typedef struct {
 	uint32_t		propertyID;
-	uint32_t		data[0];
+	uint32_t		data[1];
 } property;
 
 #pragma pack(pop)

---FILE: src/xlstool.c---
@@ -244,8 +244,8 @@ BYTE* unicode_decode(const BYTE *s, int len, size_t *newlen, const char* to_enc)
 {
 #ifdef HAVE_ICONV
 	// Do iconv conversion
-#ifdef AIX
-    const char *from_enc = ""UTF-16le"";
+#if defined(_AIX) || defined(__sun)
+	  const char *from_enc = ""UTF-16le"";
 #else
     const char *from_enc = ""UTF-16LE"";
 #endif",False,False,Implementation / Logic,3
tidyverse,readxl,665c251a92e296899d765fa68cbce1d0c1245dfc,hadley,h.wickham@gmail.com,2015-04-07T19:50:56Z,hadley,h.wickham@gmail.com,2015-04-07T19:50:56Z,Promote R CMD check warnings to errors on travis,.travis.yml,False,False,False,False,1,0,1,"---FILE: .travis.yml---
@@ -1,2 +1,3 @@
 language: r
 sudo: required
+warnings_are_errors: true",False,False,Data / Input Handling,3
tidyverse,readxl,81443a1c4cb97511e2ec31cb77f902edf6cc18bd,hadley,h.wickham@gmail.com,2015-04-07T19:50:21Z,hadley,h.wickham@gmail.com,2015-04-07T19:50:21Z,Fix remaining windows/R CMD check problems,src/XlsxWorkSheet.h;src/cran.h;src/endian.c;src/libxls/xls.h;src/libxls/xlstool.h;src/ole.c;src/unix/config.h;src/windows/config.h;src/xls.c;src/xlstool.c,False,False,False,False,44,35,79,"---FILE: src/XlsxWorkSheet.h---
@@ -90,7 +90,7 @@ class XlsxWorkSheet {
     if (has_col_names) {
       // blank columns with a name aren't blank
       Rcpp::CharacterVector names = colNames(nskip);
-      for (int i = 0; i < types.size(); i++) {
+      for (size_t i = 0; i < types.size(); i++) {
         if (types[i] == CELL_BLANK && names[i] != """")
           types[i] = CELL_NUMERIC;
       }

---FILE: src/cran.h---
@@ -1,5 +1,12 @@
+#ifndef __READ_XLS_CRAN_H
+#define __READ_XLS_CRAN_H
+
 /* Mask printf for CMD check */
 #include <Rinternals.h>
 #define printf Rprintf
 #define fprintf(err, ...) Rprintf(__VA_ARGS__)
 #define exit assert
+#undef assert
+#define assert(X) if (X) {}
+
+#endif

---FILE: src/endian.c---
@@ -37,6 +37,8 @@ int xls_is_bigendian()
 {
 #if defined (__BIG_ENDIAN__)
     return 1;
+#elif defined (_WIN32)
+    return 0;
 #elif defined (__LITTLE_ENDIAN__)
     return 0;
 #else
@@ -73,11 +75,11 @@ int xlsIntVal (int i)
 unsigned short xlsShortVal (short s)
 {
     unsigned char c1, c2;
-    
+
     if (xls_is_bigendian()) {
         c1 = s & 255;
         c2 = (s >> 8) & 255;
-    
+
         return (c1 << 8) + c2;
     } else {
         return s;

---FILE: src/libxls/xls.h---
@@ -31,7 +31,7 @@
 
 #ifndef XLS_INCLUDE
 #define XLS_INCLUDE
- 
+
 #ifdef __cplusplus
 namespace xls {
 extern ""C"" {
@@ -40,7 +40,8 @@ extern ""C"" {
 #include ""libxls/xlstypes.h""
 #include ""libxls/xlsstruct.h""
 #include ""libxls/xlstool.h""
-
+// Mask illegal functions for CMD check
+#include ""cran.h""
 
 #define BLANK_CELL		0x0201
 

---FILE: src/libxls/xlstool.h---
@@ -31,6 +31,7 @@
  */
 
 #include ""libxls/xlsstruct.h""
+#include ""cran.h""
 
 extern void dumpbuf(BYTE* fname,long size,BYTE* buf);
 extern void verbose(char* str);

---FILE: src/ole.c---
@@ -30,7 +30,7 @@
  *
  */
 
-#include ""config.h"" 
+#include ""config.h""
 
 #include <memory.h>
 #include <math.h>
@@ -43,6 +43,8 @@
 #include ""libxls/ole.h""
 #include ""libxls/xlstool.h""
 #include ""libxls/endian.h""
+/* Mask illegal functions for CMD check */
+#include ""cran.h""
 
 extern int xls_debug;
 
@@ -58,7 +60,7 @@ static int sector_read(OLE2* ole2, BYTE *buffer, size_t sid);
 static size_t read_MSAT(OLE2* ole2, OLE2Header *oleh);
 
 // Read next sector of stream
-void ole2_bufread(OLE2Stream* olest) 
+void ole2_bufread(OLE2Stream* olest)
 {
 	BYTE *ptr;
 
@@ -73,15 +75,13 @@ void ole2_bufread(OLE2Stream* olest)
 			assert(olest->ole->SSecID);
 
 			ptr = olest->ole->SSAT + olest->fatpos*olest->ole->lssector;
-			memcpy(olest->buf, ptr, olest->bufsize); 
+			memcpy(olest->buf, ptr, olest->bufsize);
 
 			olest->fatpos=xlsIntVal(olest->ole->SSecID[olest->fatpos]);
 			olest->pos=0;
 			olest->cfat++;
 		} else {
 
-			assert(olest->fatpos >= 0);
-
 			//printf(""fatpos: %d max=%u\n"",olest->fatpos, (olest->ole->cfat*olest->ole->lsector)/4);
 			if(olest->fatpos > (olest->ole->cfat*olest->ole->lsector)/4) exit(-1);
 
@@ -116,7 +116,7 @@ size_t ole2_read(void* buf,size_t size,size_t count,OLE2Stream* olest)
     if ((long)olest->size>=0 && !olest->sfat)	// directory is -1
     {
 		size_t rem;
-		rem = olest->size - (olest->cfat*olest->ole->lsector+olest->pos);		
+		rem = olest->size - (olest->cfat*olest->ole->lsector+olest->pos);
         totalReadCount = rem<totalReadCount?rem:totalReadCount;
         if (rem<=0) olest->eof=1;
 
@@ -309,7 +309,7 @@ OLE2* ole2_open(const BYTE *file)
     ole->lssector=64;
 	assert(oleh->lsectorB==9);	// 2**9 == 512
 	assert(oleh->lssectorB==6);	// 2**6 == 64
-	
+
     ole->cfat=oleh->cfat;
     ole->dirstart=oleh->dirstart;
     ole->sectorcutoff=oleh->sectorcutoff;
@@ -330,7 +330,7 @@ OLE2* ole2_open(const BYTE *file)
 		printf (""mini len:      %X (%i)\n"",ole->lssector,ole->lssector);	// ole
 		printf (""Fat sect.:     %i \n"",oleh->cfat);
 		printf (""Dir Start:     %i \n"",oleh->dirstart);
-		
+
 		printf (""Mini Cutoff:   %i \n"",oleh->sectorcutoff);
 		printf (""MiniFat Start: %X \n"",oleh->sfatstart);
 		printf (""Count MFat:    %i \n"",oleh->csfat);
@@ -344,22 +344,22 @@ OLE2* ole2_open(const BYTE *file)
 	// reuse this buffer
     pss = (PSS*)oleh;
 	// oleh = (void *)NULL; // Not needed as oleh not used from here on
-	
+
     olest=ole2_sopen(ole,ole->dirstart, -1);
     do
     {
         ole2_read(pss,1,sizeof(PSS),olest);
         xlsConvertPss(pss);
         name=unicode_decode(pss->name, pss->bsize, 0, ""UTF-8"");
-#ifdef OLE_DEBUG	
+#ifdef OLE_DEBUG
 		printf(""OLE NAME: %s count=%d\n"", name, ole->files.count);
 #endif
-        if (pss->type == PS_USER_ROOT || pss->type == PS_USER_STREAM) // (name!=NULL) // 
+        if (pss->type == PS_USER_ROOT || pss->type == PS_USER_STREAM) // (name!=NULL) //
         {
 
-#ifdef OLE_DEBUG		
+#ifdef OLE_DEBUG
 			printf(""OLE TYPE: %s file=%d \n"", pss->type == PS_USER_ROOT ? ""root"" : ""user"", ole->files.count);
-#endif		
+#endif
             if (ole->files.count==0)
             {
                 ole->files.file=malloc(sizeof(struct st_olefiles_data));
@@ -370,7 +370,7 @@ OLE2* ole2_open(const BYTE *file)
             ole->files.file[ole->files.count].start=pss->sstart;
             ole->files.file[ole->files.count].size=pss->size;
             ole->files.count++;
-			
+
 			if(pss->sstart == ENDOFCHAIN) {
 				if (xls_debug) verbose(""END OF CHAIN\n"");
 			} else
@@ -394,13 +394,13 @@ OLE2* ole2_open(const BYTE *file)
 			if(pss->type == PS_USER_ROOT) {
 				DWORD sector, k, blocks;
 				BYTE *wptr;
-				
+
 				blocks = (pss->size + (ole->lsector - 1)) / ole->lsector;	// count partial
 				ole->SSAT = (BYTE *)malloc(blocks*ole->lsector);
 				// printf(""blocks %d\n"", blocks);
 
 				assert(ole->SSecID);
-				
+
 				sector = pss->sstart;
 				wptr=(BYTE*)ole->SSAT;
 				for(k=0; k<blocks; ++k) {
@@ -411,7 +411,7 @@ OLE2* ole2_open(const BYTE *file)
 					wptr += ole->lsector;
 					sector = xlsIntVal(ole->SecID[sector]);
 				}
-			}	
+			}
 		} else {
 			free(name);
 		}
@@ -462,7 +462,7 @@ static int sector_read(OLE2* ole2, BYTE *buffer, size_t sid)
 		printf(""seek: wanted to seek to sector %zu (0x%zx) loc=%zu\n"", sid, sid, sector_pos(ole2, sid));
 	}
 	assert(seeked == 0);
-	
+
 	num = fread(buffer, ole2->lsector, 1, ole2->file);
 	if(num != 1) {
 		fprintf(stderr, ""fread: wanted 1 got %zu loc=%zu\n"", num, sector_pos(ole2, sid));
@@ -535,7 +535,7 @@ static size_t read_MSAT(OLE2* ole2, OLE2Header* oleh)
 	if(ole2->sfatstart != ENDOFCHAIN) {
 		DWORD sector, k;
 		BYTE *wptr;
-		
+
 		ole2->SSecID = (DWORD *)malloc(ole2->csfat*ole2->lsector);
 		sector = ole2->sfatstart;
 		wptr=(BYTE*)ole2->SSecID;

---FILE: src/unix/config.h---
@@ -1,6 +1,3 @@
-/* Mask illegal functions for CMD check */
-#include ""cran.h""
-
 /* config.h.  Generated from config.h.in by configure.  */
 /* config.h.in.  Generated from configure.in by autoheader.  */
 

---FILE: src/windows/config.h---
@@ -1,6 +1,3 @@
-/* Mask illegal functions for CMD check */
-#include ""cran.h""
-
 /* config.h.  Generated from config.h.in by configure.  */
 /* config.h.in.  Generated from configure.in by autoheader.  */
 

---FILE: src/xls.c---
@@ -711,7 +711,7 @@ void xls_parseWorkBook(xlsWorkBook* pWB)
     {
 		if(xls_debug > 10) {
 			printf(""READ WORKBOOK filePos=%ld\n"",  (long)pWB->filepos);
-			printf(""  OLE: start=%d pos=%zd size=%zd fatPos=%zu\n"", pWB->olestr->start, pWB->olestr->pos, pWB->olestr->size, pWB->olestr->fatpos); 
+			printf(""  OLE: start=%d pos=%zd size=%zd fatPos=%zu\n"", pWB->olestr->start, pWB->olestr->pos, pWB->olestr->size, pWB->olestr->fatpos);
 		}
 
         ole2_read(&bof1, 1, 4, pWB->olestr);
@@ -910,7 +910,7 @@ printf(""DRAWING! %u\n"", bof1.size);
 					uint32_t cspSaved;
 					uint32_t cdgSaved;
 				} fog;
-				memcpy(&fog, buf+off, 16); // OfficeArtRecordHeader F001 - specified BLIP - this is the imaged 
+				memcpy(&fog, buf+off, 16); // OfficeArtRecordHeader F001 - specified BLIP - this is the imaged
 				printf(""SpidMax=%d cidcl=%d cspSaved=%d cdgSaved=%d\n"", fog.spidMax, fog.cidcl, fog.cspSaved, fog.cdgSaved);
 				off += 16, fooper.len -= 16;
 			}
@@ -919,7 +919,7 @@ printf(""DRAWING! %u\n"", bof1.size);
 					uint32_t dgid;
 					uint32_t cspidCur;
 				} fog;
-				memcpy(&fog, buf+off, 8); // OfficeArtRecordHeader F001 - specified BLIP - this is the imaged 
+				memcpy(&fog, buf+off, 8); // OfficeArtRecordHeader F001 - specified BLIP - this is the imaged
 				printf(""  dgid=%d cspidCur=%d\n"", fog.dgid, fog.cspidCur);
 				off += 8;
 			}
@@ -951,7 +951,7 @@ printf(""DRAWING! %u\n"", bof1.size);
 			memcpy(&fooper, buf+off, 8); //
 			printf(""rec=%x instance=%x type=%x len=%d [size=%d off=%d]\n"", fooper.rec, fooper.instance, fooper.type, fooper.len, bof1.size, off);
 			off += 8 + fooper.len;
-			
+
 		}	break;
 #endif
         default:
@@ -1305,7 +1305,7 @@ void xls_close_WB(xlsWorkBook* pWB)
 
     // OLE first
 	ole=pWB->olestr->ole;
-	
+
 	ole2_fclose(pWB->olestr);
 
 	ole2_close(ole);

---FILE: src/xlstool.c---
@@ -289,7 +289,11 @@ BYTE* unicode_decode(const BYTE *s, int len, size_t *newlen, const char* to_enc)
             out_ptr = (BYTE*)outbuf;
             while(inlenleft)
             {
+#ifdef _WIN32
+                st = iconv(ic, (const char **)&src_ptr, &inlenleft, (char **)&out_ptr,(size_t *) &outlenleft);
+#else
                 st = iconv(ic, (char **)&src_ptr, &inlenleft, (char **)&out_ptr,(size_t *) &outlenleft);
+#endif
                 if(st == (size_t)(-1))
                 {
                     if(errno == E2BIG)",False,False,Dependency / Package,4
tidyverse,readxl,fa59a0c9cd8762a2ec92018567b94532fc606982,Jeroen Ooms,jeroenooms@gmail.com,2015-04-02T03:32:17Z,Jeroen Ooms,jeroenooms@gmail.com,2015-04-02T03:32:17Z,Fixes for CMD check,src/cran.h;src/unix/config.h;src/windows/config.h,False,False,False,False,11,0,11,"---FILE: src/cran.h---
@@ -0,0 +1,5 @@
+/* Mask printf for CMD check */
+#include <Rinternals.h>
+#define printf Rprintf
+#define fprintf(err, ...) Rprintf(__VA_ARGS__)
+#define exit assert

---FILE: src/unix/config.h---
@@ -1,3 +1,6 @@
+/* Mask illegal functions for CMD check */
+#include ""cran.h""
+
 /* config.h.  Generated from config.h.in by configure.  */
 /* config.h.in.  Generated from configure.in by autoheader.  */
 

---FILE: src/windows/config.h---
@@ -1,3 +1,6 @@
+/* Mask illegal functions for CMD check */
+#include ""cran.h""
+
 /* config.h.  Generated from config.h.in by configure.  */
 /* config.h.in.  Generated from configure.in by autoheader.  */
 ",False,False,Dependency / Package,1
tidyverse,readxl,9c3ee7a510b7a39afeffe7eb78a1bf7a11fb4a9c,Jonathan Marshall,jmarshall@never.you.mind,2015-04-02T02:19:19Z,Jonathan Marshall,jmarshall@never.you.mind,2015-04-02T02:19:19Z,fixes corrupt data.frame when the first column is empty,src/CellType.h,False,False,False,False,1,1,2,"---FILE: src/CellType.h---
@@ -155,7 +155,6 @@ inline Rcpp::RObject makeCol(CellType type, int n) {
 inline Rcpp::List colDataframe(Rcpp::List cols, Rcpp::CharacterVector names,
                         std::vector<CellType> types) {
   int p = cols.size();
-  int n = (p == 0) ? 0 : Rf_length(cols[0]);
 
   int p_out = 0;
   for (int j = 0; j < p; ++j) {
@@ -176,6 +175,7 @@ inline Rcpp::List colDataframe(Rcpp::List cols, Rcpp::CharacterVector names,
   }
 
   // Turn list into a data frame
+  int n = (p_out == 0) ? 0 : Rf_length(out[0]);
   out.attr(""class"") = Rcpp::CharacterVector::create(""tbl_df"", ""tbl"", ""data.frame"");
   out.attr(""row.names"") = Rcpp::IntegerVector::create(NA_INTEGER, -n);
   out.attr(""names"") = names_out;",False,False,Implementation / Logic,3
tidyverse,readxl,8a4466b9c77d085359655cfd2975d899333d656c,hadley,h.wickham@gmail.com,2015-03-23T14:37:02Z,hadley,h.wickham@gmail.com,2015-03-23T14:37:02Z,Patch rapidxml_print to allow printing,R/RcppExports.R;src/RcppExports.cpp;src/rapidxml_print.h;src/zip.cpp,False,True,True,False,47,13,60,"---FILE: R/RcppExports.R---
@@ -65,3 +65,7 @@ read_xlsx_ <- function(path, sheet, col_names, col_types, na, nskip = 0L) {
     .Call('readxl_read_xlsx_', PACKAGE = 'readxl', path, sheet, col_names, col_types, na, nskip)
 }
 
+zip_xml <- function(zip_path, file_path) {
+    invisible(.Call('readxl_zip_xml', PACKAGE = 'readxl', zip_path, file_path))
+}
+

---FILE: src/RcppExports.cpp---
@@ -205,3 +205,14 @@ BEGIN_RCPP
     return __result;
 END_RCPP
 }
+// zip_xml
+void zip_xml(const std::string& zip_path, const std::string& file_path);
+RcppExport SEXP readxl_zip_xml(SEXP zip_pathSEXP, SEXP file_pathSEXP) {
+BEGIN_RCPP
+    Rcpp::RNGScope __rngScope;
+    Rcpp::traits::input_parameter< const std::string& >::type zip_path(zip_pathSEXP);
+    Rcpp::traits::input_parameter< const std::string& >::type file_path(file_pathSEXP);
+    zip_xml(zip_path, file_path);
+    return R_NilValue;
+END_RCPP
+}

---FILE: src/rapidxml_print.h---
@@ -102,6 +102,17 @@ namespace rapidxml
         ///////////////////////////////////////////////////////////////////////////
         // Internal printing operations
 
+        // =====================================
+        // fix for clang for this bug in gcc and others: http://sourceforge.net/p/rapidxml/bugs/16/
+        template<class OutIt, class Ch> inline OutIt print_children(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_element_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_data_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_cdata_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_declaration_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_comment_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_doctype_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_pi_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+
         // Print node
         template<class OutIt, class Ch>
         inline OutIt print_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)

---FILE: src/zip.cpp---
@@ -1,7 +1,6 @@
 #include <Rcpp.h>
 
 #include ""zip.h""
-#include ""rapidxml.h""
 #include ""rapidxml_print.h""
 
 using namespace Rcpp;
@@ -18,15 +17,24 @@ std::string zip_buffer(const std::string& zip_path,
   return buffer;
 }
 
-// // [Rcpp::export]
-// std::string xml_print(std::string xml) {
-//   rapidxml::xml_document<> doc;
-//
-//   xml.push_back('\0');
-//   doc.parse<0>(&xml[0]);
-//
-//   std::ostringstream out;
-//   rapidxml::print(out, doc, 0);
-//
-//   return out.str();
-// }
+
+std::string xml_print(std::string xml) {
+  rapidxml::xml_document<> doc;
+
+  xml.push_back('\0');
+  doc.parse<0>(&xml[0]);
+
+  std::string s;
+  rapidxml::print(std::back_inserter(s), doc, 0);
+
+  return s;
+}
+
+// [[Rcpp::export]]
+void zip_xml(const std::string& zip_path,
+             const std::string& file_path) {
+
+  std::string buffer = zip_buffer(zip_path, file_path);
+  Rcout << xml_print(buffer);
+}
+",True,False,Implementation / Logic,6
tidyverse,readxl,1ff79049322d05ff5b0b6ac5ba663123f52e89aa,Jake Russ,jake.w.russ@gmail.com,2015-03-22T13:04:17Z,Jake Russ,jake.w.russ@gmail.com,2015-03-22T13:04:17Z,Fix typo,R/read_excel.R,False,True,True,False,1,1,2,"---FILE: R/read_excel.R---
@@ -26,7 +26,7 @@ read_excel <- function(path, sheet = 1, col_names = TRUE, col_types = NULL,
     xls =  read_xls(path, sheet, col_names, col_types, na, skip),
     xlsx = read_xlsx(path, sheet, col_names, col_types, na, skip),
     xlsm = read_xlsx(path, sheet, col_names, col_types, na, skip),
-    stop(""Unsupported format "", format, call. = FALSE)
+    stop(""Unsupported format "", ext, call. = FALSE)
   )
 }
 ",True,False,Implementation / Logic,6
tidyverse,readxl,0b38962acc33c5ef402b0b62c00554d40c33d2a7,hadley,h.wickham@gmail.com,2015-03-21T13:12:25Z,hadley,h.wickham@gmail.com,2015-03-21T13:12:25Z,"Add tests for NA setting in xlsx.

Confirms #24 is fixed.",tests/testthat/missing-values.xlsx;tests/testthat/test-missing-values.R,False,True,True,False,13,3,16,"---FILE: tests/testthat/test-missing-values.R---
@@ -17,15 +17,25 @@ test_that(""By default, NA read as text"", {
   expect_equal(df$x, c(""NA"", ""1.000000"", ""1.000000""))
 })
 
-test_that(""na arg maps strings to to NA"", {
-  df <- read_xls(""missing-values.xls"", na = ""NA"")
+test_that(""na arg maps strings to to NA [xls]"", {
+  df <- read_excel(""missing-values.xls"", na = ""NA"")
+  expect_equal(df$x, c(NA, 1, 1))
+})
+
+test_that(""na arg maps strings to to NA [xlsx]"", {
+  df <- read_excel(""missing-values.xlsx"", na = ""NA"")
   expect_equal(df$x, c(NA, 1, 1))
 })
 
 test_that(""text values in numeric column gives warning & NA"", {
   expect_warning(
-    df <- read_xls(""missing-values.xls"", col_types = ""numeric""),
+    df <- read_excel(""missing-values.xls"", col_types = ""numeric""),
     ""Expecting numeric""
   )
   expect_equal(df$x, c(NA, 1, 1))
+  expect_warning(
+    df <- read_excel(""missing-values.xlsx"", col_types = ""numeric""),
+    ""expecting numeric""
+  )
+  expect_equal(df$x, c(NA, 1, 1))
 })",True,False,Implementation / Logic,6
tidyverse,readxl,d99f4ff4a73f4ad8df22c52dd5f2a590d738c1a4,hadley,h.wickham@gmail.com,2015-03-20T16:01:27Z,hadley,h.wickham@gmail.com,2015-03-20T16:01:27Z,Fix typo,R/read_excel.R,False,True,True,False,1,1,2,"---FILE: R/read_excel.R---
@@ -22,7 +22,7 @@ read_excel <- function(path, sheet = 1, col_names = TRUE, col_types = NULL,
   path <- check_file(path)
   ext <- tolower(tools::file_ext(path))
 
-  switch(format,
+  switch(ext,
     xls =  read_xls(path, sheet, col_names, col_types, na, skip),
     xlsx = read_xlsx(path, sheet, col_names, col_types, na, skip),
     xlsm = read_xlsx(path, sheet, col_names, col_types, na, skip),",True,False,Implementation / Logic,6
tidyverse,readxl,41670a4aa139059679b6530c77db76a730e05f07,hadley,h.wickham@gmail.com,2015-03-20T15:25:06Z,hadley,h.wickham@gmail.com,2015-03-20T15:25:06Z,Fix signed comparison warnings,src/CellType.h;src/XlsWorkSheet.cpp;src/XlsWorkSheet.h;src/XlsxCell.h;src/XlsxWorkSheet.cpp;src/XlsxWorkSheet.h,False,False,False,False,6,6,12,"---FILE: src/CellType.h---
@@ -109,7 +109,7 @@ bool inline isDateTime(int id, const std::set<int> custom) {
 }
 
 inline bool isDateFormat(std::string x) {
-  for (int i = 0; i < x.size(); ++i) {
+  for (size_t i = 0; i < x.size(); ++i) {
     switch (x[i]) {
     case 'd':
     case 'm': // 'mm' for minutes

---FILE: src/XlsWorkSheet.cpp---
@@ -12,7 +12,7 @@ CharacterVector xls_col_types(std::string path, std::string na, int i = 0,
   std::vector<CellType> types = XlsWorkBook(path).sheet(i).colTypes(na, nskip, n);
 
   CharacterVector out(types.size());
-  for (int i = 0; i < types.size(); ++i) {
+  for (size_t i = 0; i < types.size(); ++i) {
     out[i] = cellTypeDesc(types[i]);
   }
 

---FILE: src/XlsWorkSheet.h---
@@ -89,7 +89,7 @@ class XlsWorkSheet {
 
   Rcpp::List readCols(Rcpp::CharacterVector names, std::vector<CellType> types,
                       std::string na, int nskip = 0) {
-    if (names.size() != ncol_ || types.size() != ncol_)
+    if ((int) names.size() != ncol_ || (int) types.size() != ncol_)
       Rcpp::stop(""Need one name and type for each column"");
 
     Rcpp::List cols(ncol_);

---FILE: src/XlsxCell.h---
@@ -144,7 +144,7 @@ class XlsxCell {
   Rcpp::RObject stringFromTable(const char* val, const std::string& na,
                                 const std::vector<std::string>& stringTable) {
     int id = atoi(val);
-    if (id < 0 || id >= stringTable.size()) {
+    if (id < 0 || id >= (int) stringTable.size()) {
       Rcpp::warning(""[%i, %i]: Invalid string id %i"", row() + 1, col() + 1, id);
       return NA_STRING;
     }

---FILE: src/XlsxWorkSheet.cpp---
@@ -29,7 +29,7 @@ CharacterVector xlsx_col_types(std::string path, int sheet = 0,
   std::vector<CellType> types = ws.colTypes(na, nskip, n);
 
   CharacterVector out(types.size());
-  for (int i = 0; i < types.size(); ++i) {
+  for (size_t i = 0; i < types.size(); ++i) {
     out[i] = cellTypeDesc(types[i]);
   }
 

---FILE: src/XlsxWorkSheet.h---
@@ -123,7 +123,7 @@ class XlsxWorkSheet {
   Rcpp::List readCols(Rcpp::CharacterVector names,
                       const std::vector<CellType>& types,
                       const std::string& na, int nskip = 0) {
-    if (names.size() != ncol_ || types.size() != ncol_)
+    if ((int) names.size() != ncol_ || (int) types.size() != ncol_)
       Rcpp::stop(""Need one name and type for each column"");
 
     // Initialise columns",False,False,Implementation / Logic,3
tidyverse,readxl,1ebd24637a003507a01889bc447a3e0f114c57e6,hadley,h.wickham@gmail.com,2015-03-19T21:36:03Z,hadley,h.wickham@gmail.com,2015-03-19T21:36:03Z,More off-by-one errors. Closes #17,src/XlsxWorkSheet.h,False,False,False,False,3,4,7,"---FILE: src/XlsxWorkSheet.h---
@@ -50,9 +50,8 @@ class XlsxWorkSheet {
       ++refv;
     ++refv; // advanced past :
     std::pair<int, int> dim = parseRef(refv);
-    nrow_ = dim.first;
-    ncol_ = dim.second;
-
+    nrow_ = dim.first + 1; // size is one greater than max position
+    ncol_ = dim.second + 1;
   }
 
   int ncol() {
@@ -128,7 +127,7 @@ class XlsxWorkSheet {
       Rcpp::stop(""Need one name and type for each column"");
 
     // Initialise columns
-    int n = nrow_ - nskip + 1;
+    int n = nrow_ - nskip;
     Rcpp::List cols(ncol_);
     for (int j = 0; j < ncol_; ++j) {
       cols[j] = makeCol(types[j], n);",False,False,Implementation / Logic,3
tidyverse,readxl,20158c93a06238f5ce5c18b0b4dec11c1ebfdd0f,hadley,h.wickham@gmail.com,2015-03-19T21:12:49Z,hadley,h.wickham@gmail.com,2015-03-19T21:12:49Z,"Fix off-by-one error.

Closes #16",src/XlsxWorkSheet.cpp,False,False,False,False,1,1,2,"---FILE: src/XlsxWorkSheet.cpp---
@@ -61,7 +61,7 @@ List read_xlsx_(std::string path, int sheet, RObject col_names,
       nskip++;
     } else {
       int p = ws.ncol();
-      colNames = CharacterVector(p + 1);
+      colNames = CharacterVector(p);
       for (int j = 0; j < p; ++j) {
         colNames[j] = tfm::format(""X%i"", j);
       }",False,False,Rendering / Conversion,0
tidyverse,readxl,dc65d1322be3798991d4e7c83681ce1ba499bedf,hadley,h.wickham@gmail.com,2015-03-19T16:09:47Z,hadley,h.wickham@gmail.com,2015-03-19T16:09:47Z,Fix off by one errors,src/XlsxWorkSheet.h,False,False,False,False,5,2,7,"---FILE: src/XlsxWorkSheet.h---
@@ -89,8 +89,11 @@ class XlsxWorkSheet {
            cell; cell = cell->next_sibling(""c"")) {
 
         XlsxCell xcell(cell);
+        if (xcell.col() >= ncol_)
+          continue;
+
         CellType type = xcell.type(na, wb_.stringTable(), wb_.dateStyles());
-        if (type > types[xcell.col()]) {
+        if (type >= types[xcell.col()]) {
           types[xcell.col()] = type;
         }
       }
@@ -142,7 +145,7 @@ class XlsxWorkSheet {
 
         XlsxCell xcell(cell);
         CellType type = xcell.type(na, wb_.stringTable(), wb_.dateStyles());
-        if (xcell.col() > ncol_)
+        if (xcell.col() >= ncol_)
           continue;
 
         Rcpp::RObject col = cols[xcell.col()];",False,False,Implementation / Logic,3
tidyverse,readxl,dbf066e71bdd6c3269fbf60cb4bfda00d685be18,hadley,h.wickham@gmail.com,2015-03-19T16:00:36Z,hadley,h.wickham@gmail.com,2015-03-19T16:00:36Z,Recognise error cells,src/XlsxCell.h,False,False,False,False,3,1,4,"---FILE: src/XlsxCell.h---
@@ -117,7 +117,9 @@ class XlsxCell {
       // Does excel use this? Regardless, don't have cross-platform ISO8601
       // parser (yet) so need to return as text
       return CELL_TEXT;
-    } else if (strncmp(t->value(), ""s"", 5) == 0) {
+    } else if (strncmp(t->value(), ""e"", 5) == 0) { // error
+      return CELL_BLANK;
+    } else if (strncmp(t->value(), ""s"", 5) == 0) { // string in string table
       rapidxml::xml_node<>* v = cell_->first_node(""v"");
       if (v == NULL)
         return CELL_BLANK;",False,False,Implementation / Logic,3
tidyverse,readxl,afc8f7bc3904899cc60d8eba32c7a943950141b8,hadley,h.wickham@gmail.com,2015-03-18T16:26:27Z,hadley,h.wickham@gmail.com,2015-03-18T16:26:27Z,Bug fixes. Start on dates,src/XlsxCell.h;src/XlsxWorkBook.h;src/XlsxWorkSheet.h,False,False,False,False,32,4,36,"---FILE: src/XlsxCell.h---
@@ -74,7 +74,8 @@ class XlsxCell {
     if (v == NULL || na.compare(v->value()) == 0)
       return NA_REAL;
 
-    return (v == NULL) ? 0 : (atof(v->value()) - offset) * 86400;
+    double value = atof(v->value());
+    return (v == NULL) ? 0 : (value - offset) * 86400;
   }
 
   Rcpp::RObject asCharSxp(const std::string& na,

---FILE: src/XlsxWorkBook.h---
@@ -4,6 +4,7 @@
 #include <Rcpp.h>
 #include ""rapidxml.h""
 #include ""CellType.h""
+#include ""utils.h""
 
 inline std::string zip_buffer(std::string zip_path, std::string file_path) {
   Rcpp::Environment exellEnv = Rcpp::Environment(""package:exell"");
@@ -19,11 +20,13 @@ inline std::string zip_buffer(std::string zip_path, std::string file_path) {
 class XlsxWorkBook {
   std::string path_;
   std::set<int> dateStyles_;
+  double offset_;
 
 
 public:
 
   XlsxWorkBook(std::string path): path_(path) {
+    cacheOffset();
     cacheDateStyles();
   }
 
@@ -85,6 +88,10 @@ class XlsxWorkBook {
     return dateStyles_;
   }
 
+  double offset() {
+    return offset_;
+  }
+
 private:
 
   void cacheDateStyles() {
@@ -125,6 +132,26 @@ class XlsxWorkBook {
     }
   }
 
+  void cacheOffset() {
+    std::string workbookXml = zip_buffer(path_, ""xl/workbook.xml"");
+    rapidxml::xml_document<> workbook;
+    workbook.parse<0>(&workbookXml[0]);
+
+    rapidxml::xml_node<>* root = workbook.first_node(""workbook"");
+    if (root == NULL) {
+      offset_ = dateOffset(false);
+      return;
+    }
+
+    rapidxml::xml_attribute<>* date1904 = root->first_attribute(""date1904"");
+    if (date1904 == NULL) {
+      offset_ = dateOffset(false);
+      return;
+    }
+
+    offset_ = dateOffset(atoi(date1904->value()) == 1);
+  }
+
 };
 
 #endif

---FILE: src/XlsxWorkSheet.h---
@@ -116,11 +116,11 @@ class XlsxWorkSheet {
     // Initialise columns
     Rcpp::List cols(p);
     for (int j = 0; j < p; ++j) {
-      cols[j] = makeCol(types[j], n);
+      cols[j] = makeCol(types[j], n + 1);
     }
 
     int i = 0;
-    for (rapidxml::xml_node<>* row = firstRow->next_sibling(""row"");
+    for (rapidxml::xml_node<>* row = firstRow;
          row; row = row->next_sibling(""row"")) {
 
       for (rapidxml::xml_node<>* cell = row->first_node(""c"");
@@ -149,7 +149,7 @@ class XlsxWorkSheet {
         case CELL_DATE:
           switch(type) {
           case CELL_DATE:
-            REAL(col)[i] = xcell.asDate(na, 0);
+            REAL(col)[i] = xcell.asDate(na, wb_.offset());
             break;
           case CELL_BLANK:
           case CELL_NUMERIC:",False,False,Documentation / Formatting,3
tidyverse,readxl,33df6519b32d8b544ee1192ae180c2b72f5c3419,Jeroen Ooms,jeroenooms@gmail.com,2015-03-17T18:09:45Z,Jeroen Ooms,jeroenooms@gmail.com,2015-03-17T18:09:45Z,Fix for windows,src/Makevars;src/Makevars.win;src/unix/config.h;src/windows/config.h,False,False,False,False,112,2,114,"---FILE: src/Makevars---
@@ -1 +1 @@
-PKG_CPPFLAGS=-I.
+PKG_CPPFLAGS=-Iunix -I.

---FILE: src/Makevars.win---
@@ -1,2 +1,2 @@
-PKG_CPPFLAGS=-I.
+PKG_CPPFLAGS=-Iwindows -I.
 PKG_LIBS=-lRiconv

---FILE: src/windows/config.h---
@@ -0,0 +1,110 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define to 1 if you have the `asprintf' function. */
+/* #undef HAVE_ASPRINTF */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+/* #undef HAVE_DLFCN_H */
+
+/* Define if you have the iconv() function. */
+#define HAVE_ICONV 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
+   to 0 otherwise. */
+#define HAVE_MALLOC 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `pow' function. */
+#define HAVE_POW 1
+
+/* Define to 1 if your system has a GNU libc compatible `realloc' function,
+   and to 0 otherwise. */
+#define HAVE_REALLOC 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strdup' function. */
+#define HAVE_STRDUP 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the <wchar.h> header file. */
+#define HAVE_WCHAR_H 1
+
+/* Major version */
+#define LIBXLS_MAJOR_VERSION 1
+
+/* Micro version */
+#define LIBXLS_MICRO_VERSION 1
+
+/* Minor version */
+#define LIBXLS_MINOR_VERSION 2
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define LT_OBJDIR "".libs/""
+
+/* Disables Assertions */
+#define NDEBUG 1
+
+/* Name of package */
+#define PACKAGE ""libxls""
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""dhoerl@users.sourceforge.net""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME ""libxls""
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING ""libxls 1.4.0""
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME ""libxls""
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL """"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION ""1.4.0""
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION ""1.2.1""
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to rpl_malloc if the replacement function should be used. */
+/* #undef malloc */
+
+/* Define to rpl_realloc if the replacement function should be used. */
+/* #undef realloc */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */",False,False,Environment / Configuration,3
tidyverse,readxl,8ec97e30d0989e0ea954b1cfd139065be83ad65f,hadley,h.wickham@gmail.com,2015-03-17T10:43:36Z,hadley,h.wickham@gmail.com,2015-03-17T10:43:36Z,"Fix lots of read problems

* Add support for NA arg
* Check both col & cell types
* Adjust nrows for nskip",R/RcppExports.R;R/read_xls.R;src/CellType.h;src/RcppExports.cpp;src/XlsWorkSheet.cpp;src/XlsWorkSheet.h;tests/testthat/missing-values.xls;tests/testthat/test-missing-values.R,False,True,True,False,95,35,130,"---FILE: R/RcppExports.R---
@@ -9,15 +9,15 @@ xls_sheets <- function(path) {
     .Call('exell_xls_sheets', PACKAGE = 'exell', path)
 }
 
-xls_col_types <- function(path, i = 0L, nskip = 0L, n = 100L) {
-    .Call('exell_xls_col_types', PACKAGE = 'exell', path, i, nskip, n)
+xls_col_types <- function(path, na, i = 0L, nskip = 0L, n = 100L) {
+    .Call('exell_xls_col_types', PACKAGE = 'exell', path, na, i, nskip, n)
 }
 
 xls_col_names <- function(path, i = 0L, nskip = 0L) {
     .Call('exell_xls_col_names', PACKAGE = 'exell', path, i, nskip)
 }
 
-xls_cols <- function(path, i, col_names, col_types, nskip = 0L) {
-    .Call('exell_xls_cols', PACKAGE = 'exell', path, i, col_names, col_types, nskip)
+xls_cols <- function(path, i, col_names, col_types, na, nskip = 0L) {
+    .Call('exell_xls_cols', PACKAGE = 'exell', path, i, col_names, col_types, na, nskip)
 }
 

---FILE: R/read_xls.R---
@@ -8,9 +8,12 @@
 #'   or a character vector giving a name for each column.
 #' @param col_types Either \code{NULL} to guess from the spreadsheet or a
 #'   character containing ""blank"", ""numeric"", ""date"" or ""text"".
+#' @param na Missing value. By default exell converts blank cells to missing
+#'   data. Set this value if you have used a sentinel value for missing values.
 #' @param skip Number of rows to skip before reading any data.
 #' @export
-read_xls <- function(path, sheet = 1, col_names = TRUE, col_types = NULL, skip = 0) {
+read_xls <- function(path, sheet = 1, col_names = TRUE, col_types = NULL,
+                     na = """", skip = 0) {
   path <- check_file(path)
 
   if (is.character(sheet)) {
@@ -26,12 +29,13 @@ read_xls <- function(path, sheet = 1, col_names = TRUE, col_types = NULL, skip =
     col_names <- xls_col_names(path, i = i, nskip = skip)
     skip <- skip + 1
   } else if (isFALSE(col_names)) {
-    col_names <- paste0(""X"", seq_along())
+    col_names <- paste0(""X"", seq_along(xls_col_names(path, i = i)))
   }
 
   if (is.null(col_types)) {
-    col_types <- xls_col_types(path, i, nskip = skip)
+    col_types <- xls_col_types(path, i, na = na, nskip = skip)
   }
 
-  xls_cols(path, i, col_names = col_names, col_types = col_types, nskip = skip)
+  xls_cols(path, i, col_names = col_names, col_types = col_types, na = na,
+    nskip = skip)
 }

---FILE: src/CellType.h---
@@ -35,14 +35,16 @@ inline std::vector<CellType> cellTypes(CharacterVector x) {
   return types;
 }
 
-inline CellType cellType(xls::st_cell::st_cell_data cell) {
+inline CellType cellType(xls::st_cell::st_cell_data cell, std::string na = """") {
   // Find codes in [MS-XLS] S2.3.2 (p175).
   // See xls_addCell for those used for cells
   switch(cell.id) {
   case 253: // LabelSst
-  case 516: // Label
-    return CELL_TEXT;
+  case 516: {// Label
+    std::string string((char*) cell.str);
+    return string == na ? CELL_BLANK : CELL_TEXT;
     break;
+  }
 
   case 6:    // formula
   case 1030: // formula (Apple Numbers Bug)

---FILE: src/RcppExports.cpp---
@@ -28,16 +28,17 @@ BEGIN_RCPP
 END_RCPP
 }
 // xls_col_types
-CharacterVector xls_col_types(std::string path, int i, int nskip, int n);
-RcppExport SEXP exell_xls_col_types(SEXP pathSEXP, SEXP iSEXP, SEXP nskipSEXP, SEXP nSEXP) {
+CharacterVector xls_col_types(std::string path, std::string na, int i, int nskip, int n);
+RcppExport SEXP exell_xls_col_types(SEXP pathSEXP, SEXP naSEXP, SEXP iSEXP, SEXP nskipSEXP, SEXP nSEXP) {
 BEGIN_RCPP
     Rcpp::RObject __result;
     Rcpp::RNGScope __rngScope;
     Rcpp::traits::input_parameter< std::string >::type path(pathSEXP);
+    Rcpp::traits::input_parameter< std::string >::type na(naSEXP);
     Rcpp::traits::input_parameter< int >::type i(iSEXP);
     Rcpp::traits::input_parameter< int >::type nskip(nskipSEXP);
     Rcpp::traits::input_parameter< int >::type n(nSEXP);
-    __result = Rcpp::wrap(xls_col_types(path, i, nskip, n));
+    __result = Rcpp::wrap(xls_col_types(path, na, i, nskip, n));
     return __result;
 END_RCPP
 }
@@ -55,17 +56,18 @@ BEGIN_RCPP
 END_RCPP
 }
 // xls_cols
-List xls_cols(std::string path, int i, CharacterVector col_names, CharacterVector col_types, int nskip);
-RcppExport SEXP exell_xls_cols(SEXP pathSEXP, SEXP iSEXP, SEXP col_namesSEXP, SEXP col_typesSEXP, SEXP nskipSEXP) {
+List xls_cols(std::string path, int i, CharacterVector col_names, CharacterVector col_types, std::string na, int nskip);
+RcppExport SEXP exell_xls_cols(SEXP pathSEXP, SEXP iSEXP, SEXP col_namesSEXP, SEXP col_typesSEXP, SEXP naSEXP, SEXP nskipSEXP) {
 BEGIN_RCPP
     Rcpp::RObject __result;
     Rcpp::RNGScope __rngScope;
     Rcpp::traits::input_parameter< std::string >::type path(pathSEXP);
     Rcpp::traits::input_parameter< int >::type i(iSEXP);
     Rcpp::traits::input_parameter< CharacterVector >::type col_names(col_namesSEXP);
     Rcpp::traits::input_parameter< CharacterVector >::type col_types(col_typesSEXP);
+    Rcpp::traits::input_parameter< std::string >::type na(naSEXP);
     Rcpp::traits::input_parameter< int >::type nskip(nskipSEXP);
-    __result = Rcpp::wrap(xls_cols(path, i, col_names, col_types, nskip));
+    __result = Rcpp::wrap(xls_cols(path, i, col_names, col_types, na, nskip));
     return __result;
 END_RCPP
 }

---FILE: src/XlsWorkSheet.cpp---
@@ -6,9 +6,9 @@ using namespace Rcpp;
 #include <libxls/xls.h>
 
 // [[Rcpp::export]]
-CharacterVector xls_col_types(std::string path, int i = 0, int nskip = 0,
-                         int n = 100) {
-  std::vector<CellType> types = XlsWorkBook(path).sheet(i).colTypes(nskip, n);
+CharacterVector xls_col_types(std::string path, std::string na, int i = 0,
+                              int nskip = 0, int n = 100) {
+  std::vector<CellType> types = XlsWorkBook(path).sheet(i).colTypes(na, nskip, n);
 
   CharacterVector out(types.size());
   for (int i = 0; i < types.size(); ++i) {
@@ -30,12 +30,12 @@ CharacterVector xls_col_names(std::string path, int i = 0, int nskip = 0) {
 
 // [[Rcpp::export]]
 List xls_cols(std::string path, int i, CharacterVector col_names,
-              CharacterVector col_types, int nskip = 0) {
+              CharacterVector col_types, std::string na, int nskip = 0) {
   XlsWorkSheet sheet = XlsWorkBook(path).sheet(i);
 
   if (col_names.size() != col_types.size())
     stop(""`col_names` and `col_types` must have the same length"");
 
   std::vector<CellType> types = cellTypes(col_types);
-  return sheet.readCols(col_names, types, nskip);
+  return sheet.readCols(col_names, types, na, nskip);
 }

---FILE: src/XlsWorkSheet.h---
@@ -61,7 +61,7 @@ class XlsWorkSheet {
     return out;
   }
 
-  std::vector<CellType> colTypes(int nskip = 0, int n_max = 100) {
+  std::vector<CellType> colTypes(std::string na, int nskip = 0, int n_max = 100) {
     std::vector<CellType> types(ncol_);
 
     for (int i = nskip; i < nrow_ && i < n_max; ++i) {
@@ -71,7 +71,7 @@ class XlsWorkSheet {
       xls::st_row::st_row_data row = pWS_->rows.row[i];
 
       for (int j = 0; j < ncol_; ++j) {
-        CellType type = cellType(row.cells.cell[j]);
+        CellType type = cellType(row.cells.cell[j], na);
 
         // Excel is simple enough we can enforce a strict ordering
         if (type > types[j]) {
@@ -84,56 +84,89 @@ class XlsWorkSheet {
   }
 
   Rcpp::List readCols(CharacterVector names, std::vector<CellType> types,
-                      int nskip = 0) {
+                      std::string na, int nskip = 0) {
     if (names.size() != ncol_ || types.size() != ncol_)
       Rcpp::stop(""Need one name and type for each column"");
 
     Rcpp::List cols(ncol_);
 
     // Initialise columns
+    int n = nrow_ - nskip;
     for (int j = 0; j < ncol_; ++j) {
       switch(types[j]) {
       case CELL_BLANK:
         break;
       case CELL_DATE: {
-          RObject col = Rcpp::NumericVector(nrow_);
+          RObject col = Rcpp::NumericVector(n);
           col.attr(""class"") = CharacterVector::create(""POSIXct"", ""POSIXt"");
           cols[j] = col;
         }
         break;
       case CELL_NUMERIC:
-        cols[j] = Rcpp::NumericVector(nrow_);
+        cols[j] = Rcpp::NumericVector(n);
         break;
       case CELL_TEXT:
-        cols[j] = Rcpp::CharacterVector(nrow_);
+        cols[j] = Rcpp::CharacterVector(n);
         break;
       }
     }
 
     // Fill with data
-    for (int i = 0; i + nskip < nrow_; ++i) {
+    for (int i = 0; i < n; ++i) {
       xls::st_row::st_row_data row = pWS_->rows.row[i + nskip];
 
       for (int j = 0; j < ncol_; ++j) {
         xls::st_cell::st_cell_data cell = row.cells.cell[j];
         RObject col = cols[j];
 
+        CellType type = cellType(cell, na);
+
         // Needs to compare to actual cell type to give warnings
         switch(types[j]) {
         case CELL_BLANK:
           break;
         case CELL_NUMERIC:
-          REAL(col)[i] = isBlank(cell) ? NA_REAL : cell.d;
+          switch(type) {
+          case CELL_BLANK:
+            REAL(col)[i] = NA_REAL;
+            break;
+          case CELL_NUMERIC:
+          case CELL_DATE:
+            REAL(col)[i] = cell.d;
+            break;
+          case CELL_TEXT:
+            Rcpp::warning(""Expecting numeric in [%i, %i] got `%s`"",
+              i + 1, j + 1, (char*) cell.str);
+            REAL(col)[i] = NA_REAL;
+          }
           break;
         case CELL_DATE:
-          REAL(col)[i] = isBlank(cell) ? NA_REAL : cell.d - offset_;
+          switch(type) {
+          case CELL_BLANK:
+            REAL(col)[i] = NA_REAL;
+            break;
+          case CELL_NUMERIC:
+            Rcpp::warning(""Expecting date in [%i, %i] got %d"",
+              i + 1, j + 1, cell.d);
+            REAL(col)[i] = NA_REAL;
+            break;
+          case CELL_DATE:
+            REAL(col)[i] = cell.d - offset_;
+            break;
+          case CELL_TEXT:
+            Rcpp::warning(""Expecting date in [%i, %i] got '%s'"",
+              i + 1, j + 1, cell.str);
+            REAL(col)[i] = NA_REAL;
+            break;
+          }
           break;
         case CELL_TEXT:
-          if (isBlank(cell)) {
+          if (type == CELL_BLANK) {
             SET_STRING_ELT(col, i, NA_STRING);
           } else {
-            RObject string = Rf_mkCharCE((char*) cell.str, CE_UTF8);
-            SET_STRING_ELT(col, i, string);
+            std::string stdString((char*) cell.str);
+            RObject rString = stdString == na ? NA_STRING : Rf_mkCharCE(stdString.c_str(), CE_UTF8);
+            SET_STRING_ELT(col, i, rString);
           }
           break;
         }
@@ -161,7 +194,7 @@ class XlsWorkSheet {
 
     // Turn list into a data frame
     out.attr(""class"") = CharacterVector::create(""tbl_df"", ""tbl"", ""data.frame"");
-    out.attr(""row.names"") = IntegerVector::create(NA_INTEGER, -nrow_);
+    out.attr(""row.names"") = IntegerVector::create(NA_INTEGER, -n);
     out.attr(""names"") = names_out;
 
     return out;

---FILE: tests/testthat/test-missing-values.R---
@@ -0,0 +1,19 @@
+context(""Missing values"")
+
+test_that(""By default, NA read as text"", {
+  df <- read_xls(""missing-values.xls"")
+  expect_equal(df$x, c(""NA"", ""1.000000"", ""1.000000""))
+})
+
+test_that(""na arg maps strings to to NA"", {
+  df <- read_xls(""missing-values.xls"", na = ""NA"")
+  expect_equal(df$x, c(NA, 1, 1))
+})
+
+test_that(""text values in numeric column gives warning & NA"", {
+  expect_warning(
+    df <- read_xls(""missing-values.xls"", col_types = ""numeric""),
+    ""Expecting numeric""
+  )
+  expect_equal(df$x, c(NA, 1, 1))
+})",True,False,Implementation / Logic,6
